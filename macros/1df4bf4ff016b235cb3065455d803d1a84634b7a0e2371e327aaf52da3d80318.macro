Attribute VB_Name = "Chart7"
Attribute VB_Base = "0{00020821-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Dictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''
' Dictionary v1.3.0
' (c) Tim Hall - https://github.com/timhall/VBA-Dictionary
'
' Drop-in replacement for Scripting.Dictionary on Mac
'
' @author: tim.hall.engr@gmail.com
' @license: MIT (http://www.opensource.org/licenses/mit-license.php
'
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' --------------------------------------------- '
' Constants and Private Variables
' --------------------------------------------- '

#Const UseScriptingDictionaryIfAvailable = True

#If Mac Or Not UseScriptingDictionaryIfAvailable Then

' dict_KeyValue 0: FormattedKey, 1: OriginalKey, 2: Value
Private dict_pKeyValues As Collection
Private dict_pKeys() As Variant
Private dict_pItems() As Variant
Private dict_pObjectKeys As Collection
Private dict_pCompareMode As CompareMethod

#Else

Private dict_pDictionary As Object

#End If

' --------------------------------------------- '
' Types
' --------------------------------------------- '

Public Enum CompareMethod
    BinaryCompare = VBA.vbBinaryCompare
    TextCompare = VBA.vbTextCompare
    DatabaseCompare = VBA.vbDatabaseCompare
End Enum

' --------------------------------------------- '
' Properties
' --------------------------------------------- '

Public Property Get CompareMode() As CompareMethod
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    CompareMode = dict_pCompareMode
#Else
    CompareMode = dict_pDictionary.CompareMode
#End If
End Property
Public Property Let CompareMode(Value As CompareMethod)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Count > 0 Then
        ' Can't change CompareMode for Dictionary that contains data
        ' http://msdn.microsoft.com/en-us/library/office/gg278481(v=office.15).aspx
        err.Raise 5 ' Invalid procedure call or argument
    End If

    dict_pCompareMode = Value
#Else
    dict_pDictionary.CompareMode = Value
#End If
End Property

Public Property Get Count() As Long
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Count = dict_pKeyValues.Count
#Else
    Count = dict_pDictionary.Count
#End If
End Property

Public Property Get Item(Key As Variant) As Variant
Attribute Item.VB_UserMemId = 0
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Dim dict_KeyValue As Variant
    dict_KeyValue = dict_GetKeyValue(Key)

    If Not IsEmpty(dict_KeyValue) Then
        If VBA.IsObject(dict_KeyValue(2)) Then
            Set Item = dict_KeyValue(2)
        Else
            Item = dict_KeyValue(2)
        End If
    Else
        ' Not found -> Returns Empty
    End If
#Else
    If VBA.IsObject(dict_pDictionary.Item(Key)) Then
        Set Item = dict_pDictionary.Item(Key)
    Else
        Item = dict_pDictionary.Item(Key)
    End If
#End If
End Property
Public Property Let Item(Key As Variant, Value As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Exists(Key) Then
        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value
    Else
        dict_AddKeyValue Key, Value
    End If
#Else
    dict_pDictionary.Item(Key) = Value
#End If
End Property
Public Property Set Item(Key As Variant, Value As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Exists(Key) Then
        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value
    Else
        dict_AddKeyValue Key, Value
    End If
#Else
    Set dict_pDictionary.Item(Key) = Value
#End If
End Property

Public Property Let Key(Previous As Variant, Updated As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Dim dict_KeyValue As Variant
    dict_KeyValue = dict_GetKeyValue(Previous)

    If Not VBA.IsEmpty(dict_KeyValue) Then
        dict_ReplaceKeyValue dict_KeyValue, Updated, dict_KeyValue(2)
    End If
#Else
    dict_pDictionary.Key(Previous) = Updated
#End If
End Property

' ============================================= '
' Public Methods
' ============================================= '

''
' Add an item with the given key
'
' @param {Variant} Key
' @param {Variant} Item
' --------------------------------------------- '
Public Sub Add(Key As Variant, Item As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Not Me.Exists(Key) Then
        dict_AddKeyValue Key, Item
    Else
        ' This key is already associated with an element of this collection
        err.Raise 457
    End If
#Else
    dict_pDictionary.Add Key, Item
#End If
End Sub

''
' Check if an item exists for the given key
'
' @param {Variant} Key
' @return {Boolean}
' --------------------------------------------- '
Public Function Exists(Key As Variant) As Boolean
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Exists = Not IsEmpty(dict_GetKeyValue(Key))
#Else
    Exists = dict_pDictionary.Exists(Key)
#End If
End Function

''
' Get an array of all items
'
' @return {Variant}
' --------------------------------------------- '
Public Function Items() As Variant
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Count > 0 Then
        Items = dict_pItems
    Else
        ' Split("") creates initialized empty array that matches Dictionary Keys and Items
        Items = VBA.Split("")
    End If
#Else
    Items = dict_pDictionary.Items
#End If
End Function

''
' Get an array of all keys
'
' @return {Variant}
' --------------------------------------------- '
Public Function Keys() As Variant
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Count > 0 Then
        Keys = dict_pKeys
    Else
        ' Split("") creates initialized empty array that matches Dictionary Keys and Items
        Keys = VBA.Split("")
    End If
#Else
    Keys = dict_pDictionary.Keys
#End If
End Function

''
' Remove an item for the given key
'
' @param {Variant} Key
' --------------------------------------------- '
Public Sub Remove(Key As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Dim dict_KeyValue As Variant
    dict_KeyValue = dict_GetKeyValue(Key)

    If Not VBA.IsEmpty(dict_KeyValue) Then
        dict_RemoveKeyValue dict_KeyValue
    Else
        ' Application-defined or object-defined error
        err.Raise 32811
    End If
#Else
    dict_pDictionary.Remove Key
#End If
End Sub

''
' Remove all items
' --------------------------------------------- '
Public Sub RemoveAll()
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Set dict_pKeyValues = New Collection

    Erase dict_pKeys
    Erase dict_pItems
#Else
    dict_pDictionary.RemoveAll
#End If
End Sub

' ============================================= '
' Private Functions
' ============================================= '

#If Mac Or Not UseScriptingDictionaryIfAvailable Then

Private Function dict_GetKeyValue(dict_Key As Variant) As Variant
    On Error Resume Next
    dict_GetKeyValue = dict_pKeyValues(dict_GetFormattedKey(dict_Key))
    err.Clear
End Function

Private Sub dict_AddKeyValue(dict_Key As Variant, dict_Value As Variant, Optional dict_Index As Long = -1)
    If Me.Count = 0 Then
        ReDim dict_pKeys(0 To 0)
        ReDim dict_pItems(0 To 0)
    Else
        ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) + 1)
        ReDim Preserve dict_pItems(0 To UBound(dict_pItems) + 1)
    End If

    Dim dict_FormattedKey As String
    dict_FormattedKey = dict_GetFormattedKey(dict_Key)

    If dict_Index > 0 And dict_Index <= dict_pKeyValues.Count Then
        Dim dict_i As Long
        For dict_i = UBound(dict_pKeys) To dict_Index Step -1
            dict_pKeys(dict_i) = dict_pKeys(dict_i - 1)
            If VBA.IsObject(dict_pItems(dict_i - 1)) Then
                Set dict_pItems(dict_i) = dict_pItems(dict_i - 1)
            Else
                dict_pItems(dict_i) = dict_pItems(dict_i - 1)
            End If
        Next dict_i

        dict_pKeys(dict_Index - 1) = dict_Key
        If VBA.IsObject(dict_Value) Then
            Set dict_pItems(dict_Index - 1) = dict_Value
        Else
            dict_pItems(dict_Index - 1) = dict_Value
        End If

        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey, Before:=dict_Index
    Else
        If VBA.IsObject(dict_Key) Then
            Set dict_pKeys(UBound(dict_pKeys)) = dict_Key
        Else
            dict_pKeys(UBound(dict_pKeys)) = dict_Key
        End If
        If VBA.IsObject(dict_Value) Then
            Set dict_pItems(UBound(dict_pItems)) = dict_Value
        Else
            dict_pItems(UBound(dict_pItems)) = dict_Value
        End If

        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey
    End If
End Sub

Private Sub dict_ReplaceKeyValue(dict_KeyValue As Variant, dict_Key As Variant, dict_Value As Variant)
    Dim dict_Index As Long
    Dim dict_i As Integer

    dict_Index = dict_GetKeyIndex(dict_KeyValue(1))

    ' Remove existing dict_Value
    dict_RemoveKeyValue dict_KeyValue, dict_Index

    ' Add new dict_Key dict_Value back
    dict_AddKeyValue dict_Key, dict_Value, dict_Index
End Sub

Private Sub dict_RemoveKeyValue(dict_KeyValue As Variant, Optional ByVal dict_Index As Long = -1)
    Dim dict_i As Long
    If dict_Index = -1 Then
        dict_Index = dict_GetKeyIndex(dict_KeyValue(1))
    Else
        dict_Index = dict_Index - 1
    End If

    If dict_Index >= 0 And dict_Index <= UBound(dict_pKeys) Then
        For dict_i = dict_Index To UBound(dict_pKeys) - 1
            dict_pKeys(dict_i) = dict_pKeys(dict_i + 1)

            If VBA.IsObject(dict_pItems(dict_i + 1)) Then
                Set dict_pItems(dict_i) = dict_pItems(dict_i + 1)
            Else
                dict_pItems(dict_i) = dict_pItems(dict_i + 1)
            End If
        Next dict_i

        If UBound(dict_pKeys) = 0 Then
            Erase dict_pKeys
            Erase dict_pItems
        Else
            ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) - 1)
            ReDim Preserve dict_pItems(0 To UBound(dict_pItems) - 1)
        End If
    End If

    dict_pKeyValues.Remove dict_KeyValue(0)
    dict_RemoveObjectKey dict_KeyValue(1)
End Sub

Private Function dict_GetFormattedKey(dict_Key As Variant) As String
    If VBA.IsObject(dict_Key) Then
        dict_GetFormattedKey = dict_GetObjectKey(dict_Key)
    ElseIf VarType(dict_Key) = VBA.vbBoolean Then
        dict_GetFormattedKey = IIf(dict_Key, "-1__-1", "0__0")
    ElseIf VarType(dict_Key) = VBA.vbString Then
        dict_GetFormattedKey = dict_Key

        If Me.CompareMode = CompareMethod.BinaryCompare Then
            ' Collection does not have method of setting key comparison
            ' So case-sensitive keys aren't supported by default
            ' -> Approach: Append lowercase characters to original key
            '    AbC -> AbC___b_, abc -> abc__abc, ABC -> ABC_____
            Dim dict_Lowercase As String
            dict_Lowercase = ""

            Dim dict_i As Integer
            Dim dict_Char As String
            Dim dict_Ascii As Integer
            For dict_i = 1 To VBA.Len(dict_GetFormattedKey)
                dict_Char = VBA.Mid$(dict_GetFormattedKey, dict_i, 1)
                dict_Ascii = VBA.Asc(dict_Char)
                If dict_Ascii >= 97 And dict_Ascii <= 122 Then
                    dict_Lowercase = dict_Lowercase & dict_Char
                Else
                    dict_Lowercase = dict_Lowercase & "_"
                End If
            Next dict_i

            If dict_Lowercase <> "" Then
                dict_GetFormattedKey = dict_GetFormattedKey & "__" & dict_Lowercase
            End If
        End If
    Else
        ' For numbers, add duplicate to distinguish from strings
        ' ->  123  -> "123__123"
        '    "123" -> "123"
        dict_GetFormattedKey = VBA.CStr(dict_Key) & "__" & CStr(dict_Key)
    End If
End Function

Private Function dict_GetObjectKey(dict_ObjKey As Variant) As String
    Dim dict_i As Integer
    For dict_i = 1 To dict_pObjectKeys.Count
        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then
            dict_GetObjectKey = "__object__" & dict_i
            Exit Function
        End If
    Next dict_i

    dict_pObjectKeys.Add dict_ObjKey
    dict_GetObjectKey = "__object__" & dict_pObjectKeys.Count
End Function

Private Sub dict_RemoveObjectKey(dict_ObjKey As Variant)
    Dim dict_i As Integer
    For dict_i = 1 To dict_pObjectKeys.Count
        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then
            dict_pObjectKeys.Remove dict_i
            Exit Sub
        End If
    Next dict_i
End Sub

Private Function dict_GetKeyIndex(dict_Key As Variant) As Long
    Dim dict_i As Long
    For dict_i = 0 To UBound(dict_pKeys)
        If VBA.IsObject(dict_pKeys(dict_i)) And VBA.IsObject(dict_Key) Then
            If dict_pKeys(dict_i) Is dict_Key Then
                dict_GetKeyIndex = dict_i
                Exit For
            End If
        ElseIf VBA.IsObject(dict_pKeys(dict_i)) Or VBA.IsObject(dict_Key) Then
            ' Both need to be objects to check equality, skip
        ElseIf dict_pKeys(dict_i) = dict_Key Then
            dict_GetKeyIndex = dict_i
            Exit For
        End If
    Next dict_i
End Function

#End If

Private Sub Class_Initialize()
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Set dict_pKeyValues = New Collection

    Erase dict_pKeys
    Erase dict_pItems
    Set dict_pObjectKeys = New Collection
#Else
    Set dict_pDictionary = CreateObject("Scripting.Dictionary")
#End If
End Sub

Private Sub Class_Terminate()
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Set dict_pKeyValues = Nothing
    Set dict_pObjectKeys = Nothing
#Else
    Set dict_pDictionary = Nothing
#End If
End Sub
Attribute VB_Name = "FileUploader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'sends multipart/form-data To the URL using WinHttprequest/XMLHTTP
'FormData - binary (VT_UI1 | VT_ARRAY) multipart form data
Function WinHTTPPostRequest(Url, FormData, Boundary, ByVal user, ByVal Password)
  Dim Http As MSXML2.ServerXMLHTTP
  
  
  'Create XMLHTTP/ServerXMLHTTP/WinHttprequest object
  Set Http = CreateObject("MSXML2.ServerXMLHTTP")
  
  With Http
    .Open "POST", Url, False, user, Password
    .SetRequestHeader "Content-Type", "multipart/form-data; boundary=" + Boundary
    .Send FormData
  End With
  
  'Get a result of the script which has received upload
  WinHTTPPostRequest = Http.ResponseText
End Function

'Build multipart/form-data document with file contents And header info
Function BuildFormData(FileContents, Boundary, FileName, Fieldname, epsidInput, machineidInput)
  Dim FormData, Pre, Po, epsid, epsValue, machineid, machineValue
  
  Const ContentType = "application/upload"
  
  'The two parts around file contents In the multipart-form data.
  Pre = "--" + Boundary + vbCrLf + mpFields(Fieldname, FileName, ContentType)
  Po = vbCrLf + "--" + Boundary + "--" + vbCrLf
  
  epsid = "--" + Boundary + vbCrLf + mpFormDataElement("epsid", "text/plain")

  epsValue = epsidInput + vbCrLf
  
  machineid = "--" + Boundary + vbCrLf + mpFormDataElement("machineid", "text/plain")

  machineValue = machineidInput + vbCrLf
    
  'Build form data using recordset binary field
  Const adLongVarBinary = 205
  Dim RS: Set RS = CreateObject("ADODB.Recordset")
  RS.Fields.Append "b", adLongVarBinary, Len(Pre) + LenB(FileContents) + Len(Po)
  RS.Open
  RS.AddNew
    Dim LenData
    
    LenData = Len(epsid)
    RS("b").AppendChunk (StringToMB(epsid) & ChrB(0))
    epsid = RS("b").GetChunk(LenData)
    RS("b") = ""
    
    LenData = Len(epsValue)
    RS("b").AppendChunk (StringToMB(epsValue) & ChrB(0))
    epsValue = RS("b").GetChunk(LenData)
    RS("b") = ""
    
    LenData = Len(machineid)
    RS("b").AppendChunk (StringToMB(machineid) & ChrB(0))
    machineid = RS("b").GetChunk(LenData)
    RS("b") = ""
    
    LenData = Len(machineValue)
    RS("b").AppendChunk (StringToMB(machineValue) & ChrB(0))
    machineValue = RS("b").GetChunk(LenData)
    RS("b") = ""
    
    'Convert Pre string value To a binary data
    LenData = Len(Pre)
    RS("b").AppendChunk (StringToMB(Pre) & ChrB(0))
    Pre = RS("b").GetChunk(LenData)
    RS("b") = ""
    
    'Convert Po string value To a binary data
    LenData = Len(Po)
    RS("b").AppendChunk (StringToMB(Po) & ChrB(0))
    Po = RS("b").GetChunk(LenData)
    RS("b") = ""
    
    RS("b").AppendChunk (epsid)
    RS("b").AppendChunk (epsValue)
    RS("b").AppendChunk (machineid)
    RS("b").AppendChunk (machineValue)
    RS("b").AppendChunk (Pre)
    RS("b").AppendChunk (FileContents)
    RS("b").AppendChunk (Po)
  RS.Update
  FormData = RS("b")
  RS.Close
  BuildFormData = FormData
End Function

' EPS & Machine fields informations
Function mpFormDataElement(Fieldname, ContentType)
  Dim MPTemplate 'template For multipart header
  MPTemplate = "Content-Disposition: form-data; name=""{field}"";" + _
   vbCrLf + _
   "Content-Type: {ct}" + vbCrLf + vbCrLf
  Dim Out
  Out = Replace(MPTemplate, "{field}", Fieldname)
  mpFormDataElement = Replace(Out, "{ct}", ContentType)
End Function

'Informations In form field header.
Function mpFields(Fieldname, FileName, ContentType)
  Dim MPTemplate 'template For multipart header
  MPTemplate = "Content-Disposition: form-data; name=""{field}"";" + _
   " filename=""{file}""" + vbCrLf + _
   "Content-Type: {ct}" + vbCrLf + vbCrLf
  Dim Out
  Out = Replace(MPTemplate, "{field}", Fieldname)
  Out = Replace(Out, "{file}", FileName)
  mpFields = Replace(Out, "{ct}", ContentType)
End Function

'Returns file contents As a binary data
Function GetFile(FileName)
  Dim Stream: Set Stream = CreateObject("ADODB.Stream")
  Stream.Type = 1 'Binary
  Stream.Open
  Stream.LoadFromFile FileName
  GetFile = Stream.Read
  Stream.Close
End Function

'Converts OLE string To multibyte string
Function StringToMB(S)
  Dim i, B
  For i = 1 To Len(S)
    B = B & ChrB(Asc(Mid(S, i, 1)))
  Next
  StringToMB = B
End Function

Attribute VB_Name = "IWebAuthenticator"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''
' IWebAuthenticator v4.1.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-Web
'
' Interface for creating authenticators for rest client
'
' @class IWebAuthenticator
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' ============================================= '
' Public Methods
' ============================================= '

''
' Hook for taking action before a request is executed
'
' @method BeforeExecute
' @param {WebClient} Client The client that is about to execute the request
' @param in|out {WebRequest} Request The request about to be executed
''
Public Sub BeforeExecute(ByVal client As WebClient, ByRef request As WebRequest)
    ' e.g Add headers, cookies, etc.
End Sub

''
' Hook for taking action after request has been executed
'
' @method AfterExecute
' @param {WebClient} Client The client that executed request
' @param {WebRequest} Request The request that was just executed
' @param in|out {WebResponse} Response to request
''
Public Sub AfterExecute(ByVal client As WebClient, ByVal request As WebRequest, ByRef response As WebResponse)
    ' e.g. Handle 401 Unauthorized or other issues
End Sub

''
' Hook for updating http before send
'
' @method PrepareHttp
' @param {WebClient} Client
' @param {WebRequest} Request
' @param in|out {WinHttpRequest} Http
''
Public Sub PrepareHttp(ByVal client As WebClient, ByVal request As WebRequest, ByRef Http As Object)
    ' e.g. Update option, headers, etc.
End Sub

''
' Hook for updating cURL before send
'
' @method PrepareCurl
' @param {WebClient} Client
' @param {WebRequest} Request
' @param in|out {String} Curl
''
Public Sub PrepareCurl(ByVal client As WebClient, ByVal request As WebRequest, ByRef Curl As String)
    ' e.g. Add flags to cURL
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "optLocalCoach, 1, 0, MSForms, OptionButton"
Attribute VB_Control = "optNetworkCoach, 2, 1, MSForms, OptionButton"
Attribute VB_Control = "cmdSendComment, 141, 2, MSForms, CommandButton"
Attribute VB_Control = "cmdSequenceExport, 142, 3, MSForms, CommandButton"
Attribute VB_Control = "cmdRepairSheet, 143, 4, MSForms, CommandButton"
Attribute VB_Control = "cmdMakeGraph, 144, 5, MSForms, CommandButton"
Attribute VB_Control = "cmdToggleToolsParts, 145, 6, MSForms, CommandButton"
Attribute VB_Control = "cmdMakeProgress, 146, 7, MSForms, CommandButton"
Attribute VB_Control = "cmdDailyUpdate, 2384, 8, MSForms, CommandButton"
Attribute VB_Control = "cmdGeneratePartsTools, 5612, 9, MSForms, CommandButton"
Attribute VB_Control = "cmdCheckVersion, 6689, 10, MSForms, CommandButton"
Attribute VB_Control = "cmdQueryOpenProcedureComments, 8245, 11, MSForms, CommandButton"

Option Explicit

Private Sub optTimeKeeperLocalCoach_Click()
    If optTimeKeeperLocalCoach.Value = True Then
'        Application.Run "TimeKeeperCoi.xlam!TimeKeeperCreateHyperlinks", True
        Application.Run "TimeKeeperCreateHyperlinks", True
    End If
End Sub

Private Sub optTimeKeeperNetworkCoach_Click()
    If optTimeKeeperNetworkCoach.Value = True Then
'        Application.Run "TimeKeeperCoi.xlam!TimeKeeperCreateHyperlinks", False
        Application.Run "TimeKeeperCreateHyperlinks", False
    End If
End Sub

Public Sub SendComment()

'Application.Run "TimeKeeperCoi.xlam!OpenCommentsForm"
Application.Run "OpenCommentsForm"

End Sub

Private Sub cmdCheckVersion_Click()
    Application.Run "CheckVersion"
End Sub

Private Sub cmdDailyUpdate_Click()

Application.Run "CreateDailyUpdate"

End Sub

Private Sub cmdGeneratePartsTools_Click()
    Application.Run "GeneratePartsAndTools"
End Sub

Private Sub cmdMakeGraph_Click()

'Application.Run "TimeKeeperCoi.xlam!MakeGraph"
Application.Run "MakeGraph"

End Sub

Private Sub cmdMakeProgress_Click()

'Application.Run "TimeKeeperCoi.xlam!MakeProgress"
Application.Run "MakeProgress"

End Sub

Private Sub cmdQueryOpenProcedureComments_Click()
    Call modCoachComments.openCoachComments
End Sub

Private Sub cmdRepairSheet_Click()

'Application.Run "TimeKeeperCoi.xlam!RepairSheet"
Application.Run "RepairSheet"

End Sub

Private Sub cmdSequenceExport_Click()

Application.Run "ExportSequence"

End Sub

Private Sub cmdSendComment_Click()
Application.Run "OpenCommentsForm"

End Sub

Private Sub cmdToggleToolsParts_Click()

Dim strText As String

'strText = Application.Run("TimeKeeperCoi.xlam!ToggleShowPartsAndTools")
strText = Application.Run("ToggleShowPartsAndTools")

cmdToggleToolsParts.Caption = strText

End Sub

Private Sub optLocalCoach_Click()

'Application.Run "TimeKeeperCOI.xlam!SwitchHyperlinks", True
Application.Run "SwitchHyperlinks", True

End Sub

Private Sub optNetworkCoach_Click()

'Application.Run "TimeKeeperCOI.xlam!SwitchHyperlinks", False
Application.Run "SwitchHyperlinks", False

End Sub


Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)

If Target.Address = Range("configuration").Address Then
    ShowConfiguration
    Cancel = True
End If

End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
' Make Recovery sheet robust against line inserts

    '    Check if this change means a line insert
    If Target.Columns.Count = ActiveSheet.Columns.Count Then
        '    Application.Run "TimeKeeperCoi.xlam!RecoveryInsertRow", ActiveSheet.Name, CLng(Target.row)
        Application.Run "RecoveryInsertRow", ActiveSheet.Name, CLng(Target.row)
    End If

    If Target.Address = [coachType].Address Then
        If Len(Target.Value) > 0 And [mappingAllowed] = True Then
            updateCoachLinks
        End If
    End If
End Sub


Sub updateCoachLinks()
Dim h As Integer
Dim pos1 As Integer
Dim pos2 As Integer
Dim link As String
    
    For h = 1 To [Hyperlinks].Count
        link = [Hyperlinks](h).Address
        pos1 = InStr(1, link, "systemList=", vbTextCompare) + 10
        If pos1 > 10 Then
            pos2 = InStr(pos1, link, "&", vbTextCompare) - 1
            [Hyperlinks](h).Address = Left(link, pos1) & [coachType] & Right(link, Len(link) - pos2)
        End If
    Next h
End Sub

Private Function coachSheet() As Worksheet
    Set coachSheet = Worksheets("CoachTypes")
End Function


Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "cmdUpdate, 1, 0, MSForms, CommandButton"
Attribute VB_Control = "cmdGenerateList, 2, 1, MSForms, CommandButton"
Option Explicit

Private Sub cmdGenerateList_Click()
   Application.Run ("GenerateList")
End Sub

Private Sub cmdUpdate_Click()
    Application.Run ("updateDates")
End Sub
Attribute VB_Name = "Sheet9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Public strSourceDir As String
Public strResultDir As String

Private Sub Workbook_Activate()

On Error GoTo errWorkbook_Activate

'Application.Run "TimeKeeperCoi.xlam!SetShortKeys"
Application.Run "SetShortKeys"
Application.Run "UpdateCoachType"

Exit Sub

errWorkbook_Activate:
MsgBox "Error occurred"
Resume Next
End Sub

Private Sub Workbook_Open()
    
On Error GoTo errWorkBookOpen

strSourceDir = ThisWorkbook.path

'LoadAddIn  ' Currently disabled, no request for stand-alone operation
LoadRecovery
Exit Sub

errWorkBookOpen:
MsgBox "Error occurred in initialisation state"
End

End Sub

Private Sub LoadRecovery()

Dim strSourceFile As String
Dim intFileInd As Integer
Dim withArguments As Boolean
Dim strFileName As String
Dim intMaxNrFiles As Integer
Dim strPlatformType As String

intMaxNrFiles = 9999

'If Application.Run("TimeKeeperCoi.xlam!ReadCfgFile", "stop") = "workbookopen" Then
If Application.Run("ReadCfgFile", "stop") = "workbookopen" Then
    MsgBox "Stop at user defined breakpoint: WorkbookOpen" & vbCrLf & "Press CTRL+BREAK to start debugging, press OK to continue", vbOKOnly
End If

'If (Application.Run("TimeKeeperCoi.xlam!ReadCfgFile", "debugmode") = "true") Then
If (Application.Run("ReadCfgFile", "debugmode") = "true") Then
'    Application.Run "TimeKeeperCoi.xlam!SetDebugFileName"
    Application.Run "SetDebugFileName"
    blnDebugMode = True
End If

WriteDebug "Set short keys"
'Application.Run "TimeKeeperCoi.xlam!SetShortKeys"
Application.Run "SetShortKeys"

WriteDebug "Change source dir"
ChDir strSourceDir
'ChDir (ThisWorkbook.Path)
'strSourceDir = ThisWorkbook.Path

WriteDebug "Source dir: " & strSourceDir

If (Application.Run("ReadCfgFile", "dailyupdate") = "false") Then
    Worksheets("Recovery").cmdDailyUpdate.Visible = False
Else
    Worksheets("Recovery").cmdDailyUpdate.Visible = True
End If
Worksheets("DailyUpdate").Visible = False

WriteDebug "Input file name: " & ThisWorkbook.Name
If ThisWorkbook.Name = "templateFG.xls" Then
    strSourceFile = ActiveWorkbook.Name
    
    WriteDebug "Source File: " & strSourceFile
    WriteDebug "Full name: " & ActiveWorkbook.FullName
    
    Worksheets("Settings").Range("template") = ActiveWorkbook.FullName
    
'    withArguments = Application.Run("TimeKeeperCOI.xlam!OpenInputFile")
    withArguments = Application.Run("OpenInputFile")
    
    If withArguments Then
        ' Rename workbook to prevent that the user saves the template file as templateFG.xls
        Workbooks(strSourceFile).Activate
        Application.DisplayAlerts = False
        
        strPlatformType = Trim(Mid(Range("areversion"), InStrRev(Range("areversion"), "-") + 2))
        strResultDir = strSourceDir & "\..\" & strPlatformType & "\Output"
        If Not CreateDir(strResultDir) Then
' Fallback to Tools directory
            strResultDir = strSourceDir
        End If
        
        intFileInd = 0
        Do
            intFileInd = intFileInd + 1
            strFileName = strResultDir & "\NewSequence" & Format(intFileInd, "0") & ".xls"
'        Loop Until Not Application.Run("TimeKeeperCoi.xlam!IsFile", strFileName) Or intFileInd > intMaxNrFiles
        Loop Until Not Application.Run("IsFile", strFileName) Or intFileInd > intMaxNrFiles
        
        If intFileInd > intMaxNrFiles Then
            MsgBox "Cannot save file. Maximum number of outputfiles (" & intMaxNrFiles & ") has been reached." & vbCrLf & "Try File > SaveAs to store file in different location", vbOKOnly
            Exit Sub
        End If
        
        If Not blnNoRename Then
            On Error GoTo errLoadRecovery
            
            WriteDebug "Save as: " & strResultDir & "\NewSequence" & Format(intFileInd, "0") & ".xls"
            
            ActiveWorkbook.saveAs FileName:=strResultDir & "\NewSequence" & Format(intFileInd, "0") & ".xls"
            Application.DisplayAlerts = True
'            Application.Run "TimeKeeperCOI.xlam!SetTemplateNameDir"
            Application.Run "SetTemplateNameDir"
'            Application.Run "TimeKeeperCoi.xlam!WriteDebug", "File saved as: " & strResultDir & "\NewSequence" & Format(intFileInd, "0") & ".xls"
            Application.Run "WriteDebug", "File saved as: " & strResultDir & "\NewSequence" & Format(intFileInd, "0") & ".xls"
            
            On Error GoTo 0
            WriteDebug "File saved"
        End If
        
    Else
        ' nothing error has already been generated
    End If
Else
    strResultDir = strSourceDir
    WriteDebug "Result dir: " & strSourceDir
End If

WriteDebug "Done"
On Error Resume Next
Exit Sub

errLoadRecovery:
    MsgBox "Cannot save sequence file as " & strFileName & vbCrLf & "Try File > SaveAs to save file in different location", vbOKOnly
    Resume Next
    
End Sub

Private Sub LoadAddIn()

On Error Resume Next    ' turn off error checking

Set wbMyAddin = Workbooks(AddIns("Timekeepercoi").Name)
lastError = err

On Error GoTo 0        ' restore error checking

If lastError <> 0 Then
    ' the add-in workbook isn't currently open. Manually open it.
    Set wbMyAddin = Workbooks.Open(AddIns("Timekeepercoi").FullName)
End If
On Error GoTo errLoadAddIn

AddIns("timekeepercoi").Installed = True
' AddIns.Add("TimeKeeperCOI.xlam").Installed = True
Exit Sub

errLoadAddIn:
MsgBox "Cannot load required Add-in", vbOKOnly

End Sub


Attribute VB_Name = "WebClient"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''
' WebClient v4.1.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-Web
'
' `WebClient` executes requests and handles response and is responsible for functionality shared between requests,
'  such as authentication, proxy configuration, and security.
'
' Usage:
'
' ```VB.net
' Dim Client As New WebClient
' Client.BaseUrl = "https://www.example.com/api/"
'
' Dim Auth As New HttpBasicAuthenticator
' Auth.Setup Username, Password
' Set Client.Authenticator = Auth
'
' Dim Request As New WebRequest
' Dim Response As WebResponse
' ' Setup WebRequest...
'
' Set Response = Client.Execute(Request)
' ' -> Uses Http Basic authentication and appends Request.Resource to BaseUrl
' ```
'
' Errors:
' 11010 / 80042b02 / -2147210494 - cURL error in Execute
' 11011 / 80042b03 / -2147210493 - Error in Execute
' 11012 / 80042b04 / -2147210492 - Error preparing http request
' 11013 / 80042b05 / -2147210491 - Error preparing cURL request
'
' @class WebClient
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' --------------------------------------------- '
' Constants and Private Variables
' --------------------------------------------- '

Private Const web_DefaultTimeoutMs As Long = 5000

Private Const web_HttpRequest_SetCredentials_ForServer = 0
Private Const web_HttpRequest_SetCredentials_ForProxy = 1

Private Const web_HttpRequest_ProxySetting_Default = 0
Private Const web_HttpRequest_ProxySetting_PreConfig = 0
Private Const web_HttpRequest_ProxySetting_Direct = 1
Private Const web_HttpRequest_ProxySetting_Proxy = 2

Private Enum web_WinHttpRequestOption
    web_WinHttpRequestOption_UserAgentString = 0
    web_WinHttpRequestOption_URL = 1
    web_WinHttpRequestOption_URLCodePage = 2
    web_WinHttpRequestOption_EscapePercentInURL = 3
    web_WinHttpRequestOption_SslErrorIgnoreFlags = 4
    web_WinHttpRequestOption_SelectCertificate = 5
    web_WinHttpRequestOption_EnableRedirects = 6
    web_WinHttpRequestOption_UrlEscapeDisable = 7
    web_WinHttpRequestOption_UrlEscapeDisableQuery = 8
    web_WinHttpRequestOption_SecureProtocols = 9
    web_WinHttpRequestOption_EnableTracing = 10
    web_WinHttpRequestOption_RevertImpersonationOverSsl = 11
    web_WinHttpRequestOption_EnableHttpsToHttpRedirects = 12
    web_WinHttpRequestOption_EnablePassportAuthentication = 13
    web_WinHttpRequestOption_MaxAutomaticRedirects = 14
    web_WinHttpRequestOption_MaxResponseHeaderSize = 15
    web_WinHttpRequestOption_MaxResponseDrainSize = 16
    web_WinHttpRequestOption_EnableHttp1_1 = 17
    web_WinHttpRequestOption_EnableCertificateRevocationCheck = 18
End Enum

Private web_pProxyServer As String
Private web_pAutoProxyDomain As String

' --------------------------------------------- '
' Properties
' --------------------------------------------- '

''
' Set the base url that is shared by all requests
' and that the request `Resource` is appended to.
'
' @example
' ```VB.net
' ' Desired URLs
' ' https://api.example.com/v1/messages
' ' https://api.example.com/v1/users/id
' '                BaseUrl <- ^ -> Resource
'
' Dim Client As New WebClient
' Client.BaseUrl = "https://api.example.com/v1/"
'
' Dim Request As New WebRequest
' Request.Resource = "messages"
' Request.Resource = "users/{id}"
' ```
'
' @property BaseUrl
' @type String
''
Public BaseUrl As String

''
' Attach an authenticator to the client for authentication requests.
'
' @example
' ```VB.net
' Dim Client As New WebClient
' Dim Auth As New OAuth1Authenticator
' Auth.Setup ...
'
' Set Client.Authenticator = Auth
' ' -> All requests use Auth to add "Authorization" header
' ```
'
' @property Authenticator
' @type IWebAuthenticator
''
Public Authenticator As IWebAuthenticator

''
' Timeout (in milliseconds) to wait for timeout in each request phase
' (Resolve, Connect, Send, Receive).

'
' @property TimeoutMs
' @type Long
' @default 5000
''
Public TimeoutMs As Long

''
' Comma separated list of domains to bypass the proxy.
'
' @property ProxyBypassList
' @type String
''
Public ProxyBypassList As String

''
' Username for proxy.
'
' @property ProxyUsername
' @type String
''
Public ProxyUsername As String

''
' Password for proxy.
'
' @property ProxyPassword
' @type String
''
Public ProxyPassword As String

''
' Load proxy server and bypass list automatically (`False` by default).
'
' @property EnableAutoProxy
' @type Boolean
' @default False
''
Public EnableAutoProxy As Boolean

''
' Turn off SSL validation (`False` by default).
' Useful for self-signed certificates and should only be used with trusted servers.
'
' @property Insecure
' @type Boolean
' @default False
''
Public Insecure As Boolean

''
' Follow redirects (301, 302, 307) using Location header
'
' @property FollowRedirects
' @type Boolean
' @default True
''
Public FollowRedirects As Boolean

''
' Proxy server to pass requests through (except for those that match `ProxyBypassList`).
'
' @property ProxyServer
' @type String
''
Public Property Get ProxyServer() As String
    ProxyServer = web_pProxyServer
End Property
Public Property Let ProxyServer(Value As String)
    Me.EnableAutoProxy = False
    web_pProxyServer = Value
End Property

' ============================================= '
' Public Methods
' ============================================= '

''
' Execute the given request
' (append the request's `FormattedResource` to the `BaseUrl`)
' and return the response.
'
' @example
' ```VB.net
' Dim Client As New WebClient
' Client.BaseUrl = "https://api.example.com/v1/"
'
' Dim Request As New WebRequest
' Request.Resource = "messages/{id}"
' Request.AddUrlSegment "id", 123
'
' ' Add querystring, body, headers, cookies, etc. for request
'
' Dim Response As WebResponse
' Set Response = Client.Execute(Request)
'
' ' -> GET https://api.example/com/v1/messages/123
' '    headers, cookies, and body...
' ```
'
' @method Execute
' @param {WebRequest} request The request to execute
' @return {WebResponse} Wrapper of server response for request
' @throws 11010 / 80042b02 / -2147210494 - cURL error in Execute
' @throws 11011 / 80042b03 / -2147210493 - Error in Execute
''
Public Function Execute(request As WebRequest) As WebResponse
    Dim web_Http As Object
    Dim web_Response As New WebResponse

    On Error GoTo web_ErrorHandling

#If Mac Then
    Dim web_Curl As String
    Dim web_Result As ShellResult

    web_Curl = Me.PrepareCurlRequest(request)
    web_Result = WebHelpers.ExecuteInShell(web_Curl)

    ' Handle cURL errors
    '
    ' Map to WinHttp error number, as possible
    ' https://msdn.microsoft.com/en-us/library/aa383770(VS.85).aspx
    If web_Result.ExitCode > 0 Then
        Dim web_ErrorNumber As Long
        Dim web_ErrorMessage As String
        Dim web_ErrorDetails As String
        web_ErrorNumber = web_Result.ExitCode / 256

        Select Case web_ErrorNumber
        Case 1
            ' 1 = CURLE_UNSUPPORTED_PROTOCOL
            ' 12006 = ERROR_WINHTTP_UNRECOGNIZED_SCHEME
            err.Raise 12006 + &H30000 + vbObjectError, "The URL does not use a recognized protocol (1: CURLE_UNSUPPORTED_PROTOCOL)" & vbNewLine & _
                "URL: " & Me.GetFullUrl(request) & vbNewLine & _
                "Protocol: " & WebHelpers.GetUrlParts(Me.GetFullUrl(request))("Protocol")
        Case 3
            ' 3 = CURLE_URL_MALFORMAT
            ' 12005 = ERROR_WINHTTP_INVALID_URL
            err.Raise 12005 + &H30000 + vbObjectError, "The URL is invalid (3: CURLE_URL_MALFORMAT)" & _
                "URL: " & Me.GetFullUrl(request)
        Case 5, 6
            ' 5 = CURLE_COULDNT_RESOLVE_PROXY
            ' 6 = CURLE_COULDNT_RESOLVE_HOST
            ' 12007 = ERROR_WINHTTP_NAME_NOT_RESOLVED
            If web_ErrorNumber = 5 Then
                web_ErrorDetails = "(5: CURLE_COULDNT_RESOLVE_PROXY)"
            Else
                web_ErrorDetails = "(6: CURLE_COULDNT_RESOLVE_HOST)"
            End If

            err.Raise 12007 + &H30000 + vbObjectError, "WebClient.Execute", "The server name or address could not be resolved " & web_ErrorDetails
        Case 7
            ' 7 = CURLE_COULDNT_CONNECT
            ' 12029 = ERROR_WINHTTP_CANNOT_CONNECT
            err.Raise 12029 + &H30000 + vbObjectError, "WebClient.Execute", "A connection with the server could not be established (7: CURLE_COULDNT_CONNECT)"
        Case 12, 28
            ' 12 = CURLE_FTP_ACCEPT_TIMEOUT
            ' 28 = CURLE_OPERATION_TIMEDOUT
            ' 12002 = ERROR_WINHTTP_TIMEOUT
            If web_ErrorNumber = 12 Then
                web_ErrorDetails = "(12: CURLE_FTP_ACCEPT_TIMEOUT)"
            Else
                web_ErrorDetails = "(28: CURLE_OPERATION_TIMEDOUT)"
            End If

            err.Raise 12002 + &H30000 + vbObjectError, "WebClient.Execute", "The operation timed out " & web_ErrorDetails
        Case 47
            ' 47 = CURLE_TOO_MANY_REDIRECTS
            ' 12156 = ERROR_WINHTTP_REDIRECT_FAILED
            err.Raise 12156 + &H30000 + vbObjectError, "WebClient.Execute", "Too many redirects (47: CURLE_TOO_MANY_REDIRECTS)"
        Case Else
            err.Raise 11010 + vbObjectError, "WebClient.Execute", "An unknown cURL error occured, #" & web_ErrorNumber & vbNewLine & _
                "Find details at http://curl.haxx.se/libcurl/c/libcurl-errors.html"
        End Select
    End If

    web_Response.CreateFromCurl Me, request, web_Result.Output

#Else
    Set web_Http = Me.PrepareHttpRequest(request)

    web_Http.Send request.Body
    Do While Not web_Http.WaitForResponse(0.025)
        VBA.DoEvents
    Loop

    web_Response.CreateFromHttp Me, request, web_Http

#End If

    WebHelpers.LogResponse Me, request, web_Response

    If Not Me.Authenticator Is Nothing Then
        Me.Authenticator.AfterExecute Me, request, web_Response
    End If

    Set web_Http = Nothing
    Set Execute = web_Response
    Exit Function

web_ErrorHandling:

    Set web_Http = Nothing
    Dim web_ErrorDescription As String

    ' Check lower 16 bits from error
    ' (e.g. 80072EE2 -> 2EE2 -> 12002)
    Select Case err.Number And 65535
    Case 12002, 12007, 12029
        ' Treat timeout-related errors as 408: timeout, name not resolved, cannot connect
        web_Response.StatusCode = WebStatusCode.RequestTimeout
        web_Response.StatusDescription = "Request Timeout: " & err.Description

        WebHelpers.LogResponse Me, request, web_Response
        Set Execute = web_Response
        err.Clear
    Case Else
        ' Error
        web_ErrorDescription = "An error occurred during execute" & vbNewLine & _
            err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

        WebHelpers.LogError web_ErrorDescription, "WebClient.Execute", 11011 + vbObjectError
        err.Raise 11011 + vbObjectError, "WebClient.Execute", web_ErrorDescription
    End Select
End Function

''
' Get JSON from the given URL
' (with options for Headers, Cookies, QuerystringParams, and UrlSegments).
'
' @example
' ```VB.net
' Dim Client As New WebClient
' Dim Url As String
' Url = "https://api.example.com/v1/messages/1"
'
' Dim Response As WebResponse
' Set Response = Client.GetJson(Url)
'
' Dim Headers As New Collection
' Headers.Add WebHelpers.CreateKeyValue("Authorization", "Bearer ...")
'
' Dim Options As New Dictionary
' Options.Add "Headers", Headers
'
' Set Response = Client.GetJson(Url, Options)
' ```
'
' @method GetJson
' @param {String} Url (appended to `BaseUrl`, if set)
' @param {Dictionary} [Options]
' @param {Collection} [Options.Headers] Collection of `KeyValue`
' @param {Collection} [Options.Cookies] Collection of `KeyValue`
' @param {Collection} [Options.QuerystringParams] Collection of `KeyValue`
' @param {Dictionary} [Options.UrlSegments]
' @return {WebResponse} Response
''
Public Function GetJson(Url As String, Optional Options As Dictionary) As WebResponse
    Dim web_Request As New WebRequest
    web_Request.CreateFromOptions Options
    web_Request.Resource = Url
    web_Request.Format = WebFormat.Json
    web_Request.Method = WebMethod.HttpGet

    Set GetJson = Me.Execute(web_Request)
End Function

''
' Post JSON Body (`Array`, `Collection`, `Dictionary`) to the given URL
' (with options for Headers, Cookies, QuerystringParams, and UrlSegments).
'
' @example
' ```VB.net
' Dim Client As New WebClient
' Dim Url As String
' Url = "https://api.example.com/v1/messages/1"
'
' ' Body
' ' Array, Collection, or Dictionary
' Dim Body As New Dictionary
' Body.Add "message", "Howdy!"
'
' Dim Response As WebResponse
' Set Response = Client.PostJson(Url, Body)
'
' Dim Headers As New Collection
' Headers.Add WebHelpers.CreateKeyValue("Authorization", "Bearer ...")
'
' Dim Options As New Dictionary
' Options.Add "Headers", Headers
'
' Set Response = Client.PostJson(Url, Body, Options)
' ```
'
' @method PostJson
' @param {String} Url (appended to `BaseUrl`, if set)
' @param {Dictionary} Body
' @param {Dictionary} [Options]
' @param {Collection} [Options.Headers] Collection of `KeyValue`
' @param {Collection} [Options.Cookies] Collection of `KeyValue`
' @param {Collection} [Options.QuerystringParams] Collection of `KeyValue`
' @param {Dictionary} [Options.UrlSegments]
' @return {WebResponse} Response
''
Public Function PostJson(Url As String, Body As Variant, Optional Options As Dictionary) As WebResponse
    Dim web_Request As New WebRequest
    web_Request.CreateFromOptions Options
    web_Request.Resource = Url
    web_Request.Format = WebFormat.Json
    web_Request.Method = WebMethod.HttpPost
    If VBA.IsObject(Body) Then
        Set web_Request.Body = Body
    Else
        web_Request.Body = Body
    End If

    Set PostJson = Me.Execute(web_Request)
End Function

''
' Set proxy for all requests
'
' @example
' ```VB.net
' Dim Client As New RestClient
'
' ' Just Server
' Client.SetProxy "proxy_server:80"
'
' ' Server + Username and Password
' Client.SetProxy "proxy_server:80", "Tim", "Password"
'
' ' Server + Username and Password + BypassList
' Client.SetProxy "proxy_server:80", "Tim", "Password", "<local>,*.bypass.com"
' ```
'
' @method SetProxy
' @param {String} ProxyServer Proxy server to pass requests through
' @param {String} [Username=""] Username for proxy
' @param {String} [Password=""] Password for proxy
' @param {String} [BypassList=""] Comma-separated list of servers that should bypass proxy
''
Public Sub SetProxy(ProxyServer As String, _
    Optional Username As String = "", Optional Password As String = "", Optional BypassList As String = "")

    Me.ProxyServer = ProxyServer
    Me.ProxyUsername = Username
    Me.ProxyPassword = Password
    Me.ProxyBypassList = BypassList
End Sub

''
' Get full url by joining given `WebRequest.FormattedResource` and `BaseUrl`.
'
' @method GetFullUrl
' @param {WebRequest} Request
' @return {String}
''
Public Function GetFullUrl(request As WebRequest) As String
    GetFullUrl = WebHelpers.JoinUrl(Me.BaseUrl, request.FormattedResource)
End Function

''
' Prepare Http request for given WebRequest
'
' @internal
' @method PrepareHttpRequest
' @param {WebRequest} Request
' @return {WinHttpRequest}
' @throws 11012 / 80042b04 / -2147210492 - Error preparing http request
''
Public Function PrepareHttpRequest(request As WebRequest, Optional Async As Boolean = True) As Object
    Dim web_Http As Object
    Dim web_KeyValue As Dictionary

    On Error GoTo web_ErrorHandling

    Set web_Http = CreateObject("WinHttp.WinHttpRequest.5.1")

    ' Prepare request (before open)
    web_BeforeExecute request

    ' Open http request
    web_Http.Open WebHelpers.MethodToName(request.Method), Me.GetFullUrl(request), Async

    ' Set timeouts
    web_Http.SetTimeouts Me.TimeoutMs, Me.TimeoutMs, Me.TimeoutMs, Me.TimeoutMs

    ' Load auto-proxy (if needed)
    If Me.EnableAutoProxy Then
        web_LoadAutoProxy request
    End If

    ' Setup proxy
    ' See http://msdn.microsoft.com/en-us/library/windows/desktop/aa384059(v=vs.85).aspx for details
    If Me.ProxyServer <> "" Then
        WebHelpers.LogDebug "SetProxy: " & Me.ProxyServer, "WebClient.PrepareHttpRequest"
        web_Http.SetProxy web_HttpRequest_ProxySetting_Proxy, Me.ProxyServer, Me.ProxyBypassList

        If Me.ProxyUsername <> "" Then
            WebHelpers.LogDebug "SetProxyCredentials: " & Me.ProxyUsername & ", " & WebHelpers.Obfuscate(Me.ProxyPassword), "WebClient.PrepareHttpRequest"
            web_Http.SetCredentials Me.ProxyUsername, Me.ProxyPassword, web_HttpRequest_SetCredentials_ForProxy
        End If
    Else
        ' Attempt to get proxy setup with Proxycfg.exe, otherwise direct
        web_Http.SetProxy web_HttpRequest_ProxySetting_PreConfig
    End If

    ' Setup security
    If Me.Insecure Then
        ' - Disable certifcate revocation check
        ' - Ignore all SSL errors
        '   Unknown certification authority (CA) or untrusted root, 0x0100
        '   Wrong usage, 0x0200
        '   Invalid common name (CN), 0x1000
        '   Invalid date or certificate expired, 0x2000
        '   = 0x3300 = 13056
        ' - Enable https-to-http redirects
        web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_EnableCertificateRevocationCheck) = False
        web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_SslErrorIgnoreFlags) = 13056
        web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_EnableHttpsToHttpRedirects) = True
    Else
        ' By default:
        ' - Enable certificate revocation check (especially useful after HeartBleed)
        ' - Ignore no SLL erros
        ' - Disable https-to-http redirects
        web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_EnableCertificateRevocationCheck) = True
        web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_SslErrorIgnoreFlags) = 0
        web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_EnableHttpsToHttpRedirects) = False
    End If

    ' Setup redirects
    web_Http.Option(web_WinHttpRequestOption.web_WinHttpRequestOption_EnableRedirects) = Me.FollowRedirects

    ' Set headers on http request (after open)
    For Each web_KeyValue In request.Headers
        web_Http.SetRequestHeader web_KeyValue("Key"), web_KeyValue("Value")
    Next web_KeyValue

    For Each web_KeyValue In request.Cookies
        web_Http.SetRequestHeader "Cookie", web_KeyValue("Key") & "=" & web_KeyValue("Value")
    Next web_KeyValue

    ' Give authenticator opportunity to update Http
    If Not Me.Authenticator Is Nothing Then
        Me.Authenticator.PrepareHttp Me, request, web_Http
    End If

    ' Log request and return
    WebHelpers.LogRequest Me, request
    Set PrepareHttpRequest = web_Http
    Exit Function

web_ErrorHandling:

    Set web_Http = Nothing
    err.Raise 11012 + vbObjectError, "WebClient.PrepareHttpRequest", _
        "An error occurred while preparing http request" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description
End Function

''
' Prepare cURL request for given WebRequest
'
' @internal
' @method PrepareCurlRequest
' @param {WebRequest} Request
' @return {String}
' @throws 11013 / 80042b05 / -2147210491 - Error preparing cURL request
''
Public Function PrepareCurlRequest(request As WebRequest) As String
    Dim web_Curl As String
    Dim web_KeyValue As Dictionary
    Dim web_CookieString As String

    On Error GoTo web_ErrorHandling

    web_Curl = "curl -i"

    ' Setup authenticator
    web_BeforeExecute request

    ' Set timeouts
    ' (max time = resolve + sent + receive)
    web_Curl = web_Curl & " --connect-timeout " & Me.TimeoutMs / 1000
    web_Curl = web_Curl & " --max-time " & 3 * Me.TimeoutMs / 1000

    ' Setup proxy
    If Me.ProxyServer <> "" Then
        web_Curl = web_Curl & " --proxy " & Me.ProxyServer

        If Me.ProxyBypassList <> "" Then
            web_Curl = web_Curl & " --noproxy " & Me.ProxyBypassList
        End If
        If Me.ProxyUsername <> "" Then
            web_Curl = web_Curl & " --proxy-user " & Me.ProxyUsername & ":" & Me.ProxyPassword
        End If
    End If

    ' Setup security
    If Me.Insecure Then
        web_Curl = web_Curl & " --insecure"
    End If

    ' Setup redirects
    If Me.FollowRedirects Then
        web_Curl = web_Curl & " --location"
    End If

    ' Set headers and cookies
    For Each web_KeyValue In request.Headers
        web_Curl = web_Curl & " -H '" & web_KeyValue("Key") & ": " & web_KeyValue("Value") & "'"
    Next web_KeyValue

    For Each web_KeyValue In request.Cookies
        web_CookieString = web_CookieString & web_KeyValue("Key") & "=" & web_KeyValue("Value") & ";"
    Next web_KeyValue
    If web_CookieString <> "" Then
        web_Curl = web_Curl & " --cookie '" & web_CookieString & "'"
    End If

    ' Add method, data, and url
    web_Curl = web_Curl & " -X " & WebHelpers.MethodToName(request.Method)
    web_Curl = web_Curl & " -d '" & request.Body & "'"
    web_Curl = web_Curl & " '" & Me.GetFullUrl(request) & "'"

    ' Give authenticator opportunity to update cURL
    If Not Me.Authenticator Is Nothing Then
        Me.Authenticator.PrepareCurl Me, request, web_Curl
    End If

    ' Log request and return
    WebHelpers.LogRequest Me, request
    PrepareCurlRequest = web_Curl
    Exit Function

web_ErrorHandling:

    err.Raise 11013 + vbObjectError, "WebClient.PrepareCURLRequest", _
        "An error occurred while preparing cURL request" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description
End Function

''
' Clone client
'
' @internal
' @method Clone
' @return {WebClient}
''
Public Function Clone() As WebClient
    Set Clone = New WebClient
    Clone.BaseUrl = Me.BaseUrl
    Clone.ProxyServer = Me.ProxyServer
    Clone.ProxyBypassList = Me.ProxyBypassList
    Clone.ProxyUsername = Me.ProxyUsername
    Clone.ProxyPassword = Me.ProxyPassword
    Clone.EnableAutoProxy = Me.EnableAutoProxy
    Clone.TimeoutMs = Me.TimeoutMs
    Clone.Insecure = Me.Insecure
    Set Clone.Authenticator = Me.Authenticator
End Function

' ============================================= '
' Private Methods
' ============================================= '

Private Sub web_BeforeExecute(web_Request As WebRequest)
    If Not Me.Authenticator Is Nothing Then
        Me.Authenticator.BeforeExecute Me, web_Request
    End If

    ' Preparing request includes adding headers
    ' -> Needs to happen after BeforeExecute in case headers were changed
    web_Request.Prepare
End Sub

Private Sub web_LoadAutoProxy(web_Request As WebRequest)
#If Win32 Or Win64 Then
    On Error GoTo web_ErrorHandling

    Dim web_Parts As Dictionary
    Dim web_Domain As String
    Dim web_ProxyServer As String
    Dim web_ProxyBypassList As String

    Set web_Parts = WebHelpers.GetUrlParts(Me.GetFullUrl(web_Request))
    web_Domain = VBA.IIf(web_Parts("Protocol") <> "", web_Parts("Protocol") & "://", "") & _
        web_Parts("Host") & ":" & web_Parts("Port")

    ' Cache auto-proxy by domain
    If web_Domain <> web_pAutoProxyDomain Then
        ' Cache first to store error as no proxy
        web_pAutoProxyDomain = web_Domain

        WebHelpers.GetAutoProxy web_Domain, web_ProxyServer, web_ProxyBypassList

        WebHelpers.LogDebug "Loaded auto-proxy for " & web_Domain & ":" & vbNewLine & _
            "Server = " & web_ProxyServer & vbNewLine & _
            "Bypass List = " & web_ProxyBypassList

        ' Store proxy server in underlying to avoid turning off auto-proxy
        web_pProxyServer = web_ProxyServer
        Me.ProxyBypassList = web_ProxyBypassList
    End If

    Exit Sub

web_ErrorHandling:

    WebHelpers.LogError "An error occurred while loading auto-proxy" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description, _
        "WebClient.LoadAutoProxy", err.Number
#End If
End Sub

Private Sub Class_Initialize()
    Me.TimeoutMs = web_DefaultTimeoutMs
    Me.EnableAutoProxy = False
    Me.Insecure = False
    Me.FollowRedirects = True
End Sub
Attribute VB_Name = "WebHelpers"
''
' WebHelpers v4.1.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-Web
'
' Contains general-purpose helpers that are used throughout VBA-Web. Includes:
'
' - Logging
' - Converters and encoding
' - Url handling
' - Object/Dictionary/Collection/Array helpers
' - Request preparation / handling
' - Timing
' - Mac
' - Cryptography
' - Converters (JSON, XML, Url-Encoded)
'
' Errors:
' 11000 - Error during parsing
' 11001 - Error during conversion
' 11002 - No matching converter has been registered
' 11003 - Error while getting url parts
' 11099 - XML format is not currently supported
'
' @module WebHelpers
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' Contents:
' 1. Logging
' 2. Converters and encoding
' 3. Url handling
' 4. Object/Dictionary/Collection/Array helpers
' 5. Request preparation / handling
' 6. Timing
' 7. Mac
' 8. Cryptography
' 9. Converters
' VBA-JSON
' VBA-UTC
' AutoProxy
' --------------------------------------------- '

' Custom formatting uses the standard version of Application.Run,
' which is incompatible with some Office applications (e.g. Word 2011 for Mac)
'
' If you have compilation errors in ParseByFormat or ConvertToFormat,
' you can disable custom formatting by setting the following compiler flag to False
#Const EnableCustomFormatting = True

' === AutoProxy Headers
#If Mac Then
#ElseIf VBA7 Then

Private Declare PtrSafe Sub AutoProxy_CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
    (ByVal AutoProxy_lpDest As LongPtr, ByVal AutoProxy_lpSource As LongPtr, ByVal AutoProxy_cbCopy As Long)
Private Declare PtrSafe Function AutoProxy_SysAllocString Lib "oleaut32" Alias "SysAllocString" _
    (ByVal AutoProxy_pwsz As LongPtr) As LongPtr
Private Declare PtrSafe Function AutoProxy_GlobalFree Lib "kernel32" Alias "GlobalFree" _
    (ByVal AutoProxy_p As LongPtr) As LongPtr
Private Declare PtrSafe Function AutoProxy_GetIEProxy Lib "WinHTTP.dll" Alias "WinHttpGetIEProxyConfigForCurrentUser" _
    (ByRef AutoProxy_proxyConfig As AUTOPROXY_IE_PROXY_CONFIG) As Long
Private Declare PtrSafe Function AutoProxy_GetProxyForUrl Lib "WinHTTP.dll" Alias "WinHttpGetProxyForUrl" _
    (ByVal AutoProxy_hSession As LongPtr, ByVal AutoProxy_pszUrl As LongPtr, ByRef AutoProxy_pAutoProxyOptions As AUTOPROXY_OPTIONS, ByRef AutoProxy_pProxyInfo As AUTOPROXY_INFO) As Long
Private Declare PtrSafe Function AutoProxy_HttpOpen Lib "WinHTTP.dll" Alias "WinHttpOpen" _
    (ByVal AutoProxy_pszUserAgent As LongPtr, ByVal AutoProxy_dwAccessType As Long, ByVal AutoProxy_pszProxyName As LongPtr, ByVal AutoProxy_pszProxyBypass As LongPtr, ByVal AutoProxy_dwFlags As Long) As LongPtr
Private Declare PtrSafe Function AutoProxy_HttpClose Lib "WinHTTP.dll" Alias "WinHttpCloseHandle" _
    (ByVal AutoProxy_hInternet As LongPtr) As Long

Private Type AUTOPROXY_IE_PROXY_CONFIG
    AutoProxy_fAutoDetect As Long
    AutoProxy_lpszAutoConfigUrl As LongPtr
    AutoProxy_lpszProxy As LongPtr
    AutoProxy_lpszProxyBypass As LongPtr
End Type
Private Type AUTOPROXY_OPTIONS
    AutoProxy_dwFlags As Long
    AutoProxy_dwAutoDetectFlags As Long
    AutoProxy_lpszAutoConfigUrl As LongPtr
    AutoProxy_lpvReserved As LongPtr
    AutoProxy_dwReserved As Long
    AutoProxy_fAutoLogonIfChallenged As Long
End Type
Private Type AUTOPROXY_INFO
    AutoProxy_dwAccessType As Long
    AutoProxy_lpszProxy As LongPtr
    AutoProxy_lpszProxyBypass As LongPtr
End Type

#Else

Private Declare Sub AutoProxy_CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
    (ByVal AutoProxy_lpDest As Long, ByVal AutoProxy_lpSource As Long, ByVal AutoProxy_cbCopy As Long)
Private Declare Function AutoProxy_SysAllocString Lib "oleaut32" Alias "SysAllocString" _
    (ByVal AutoProxy_pwsz As Long) As Long
Private Declare Function AutoProxy_GlobalFree Lib "kernel32" Alias "GlobalFree" _
    (ByVal AutoProxy_p As Long) As Long
Private Declare Function AutoProxy_GetIEProxy Lib "WinHTTP.dll" Alias "WinHttpGetIEProxyConfigForCurrentUser" _
    (ByRef AutoProxy_proxyConfig As AUTOPROXY_IE_PROXY_CONFIG) As Long
Private Declare Function AutoProxy_GetProxyForUrl Lib "WinHTTP.dll" Alias "WinHttpGetProxyForUrl" _
    (ByVal AutoProxy_hSession As Long, ByVal AutoProxy_pszUrl As Long, ByRef AutoProxy_pAutoProxyOptions As AUTOPROXY_OPTIONS, ByRef AutoProxy_pProxyInfo As AUTOPROXY_INFO) As Long
Private Declare Function AutoProxy_HttpOpen Lib "WinHTTP.dll" Alias "WinHttpOpen" _
    (ByVal AutoProxy_pszUserAgent As Long, ByVal AutoProxy_dwAccessType As Long, ByVal AutoProxy_pszProxyName As Long, ByVal AutoProxy_pszProxyBypass As Long, ByVal AutoProxy_dwFlags As Long) As Long
Private Declare Function AutoProxy_HttpClose Lib "WinHTTP.dll" Alias "WinHttpCloseHandle" _
    (ByVal AutoProxy_hInternet As Long) As Long

Private Type AUTOPROXY_IE_PROXY_CONFIG
    AutoProxy_fAutoDetect As Long
    AutoProxy_lpszAutoConfigUrl As Long
    AutoProxy_lpszProxy As Long
    AutoProxy_lpszProxyBypass As Long
End Type
Private Type AUTOPROXY_OPTIONS
    AutoProxy_dwFlags As Long
    AutoProxy_dwAutoDetectFlags As Long
    AutoProxy_lpszAutoConfigUrl As Long
    AutoProxy_lpvReserved As Long
    AutoProxy_dwReserved As Long
    AutoProxy_fAutoLogonIfChallenged As Long
End Type
Private Type AUTOPROXY_INFO
    AutoProxy_dwAccessType As Long
    AutoProxy_lpszProxy As Long
    AutoProxy_lpszProxyBypass As Long
End Type

#End If


#If Mac Then
#Else
' Constants for dwFlags of AUTOPROXY_OPTIONS
Const AUTOPROXY_AUTO_DETECT = 1
Const AUTOPROXY_CONFIG_URL = 2

' Constants for dwAutoDetectFlags
Const AUTOPROXY_DETECT_TYPE_DHCP = 1
Const AUTOPROXY_DETECT_TYPE_DNS = 2
#End If
' === End AutoProxy

' === VBA-JSON Headers
' === VBA-UTC Headers
#If Mac Then

#If VBA7 Then

' 64-bit Mac (2016)
Private Declare PtrSafe Function utc_popen Lib "libc.dylib" Alias "popen" _
    (ByVal utc_Command As String, ByVal utc_Mode As String) As LongPtr
Private Declare PtrSafe Function utc_pclose Lib "libc.dylib" Alias "pclose" _
    (ByVal utc_File As Long) As LongPtr
Private Declare PtrSafe Function utc_fread Lib "libc.dylib" Alias "fread" _
    (ByVal utc_Buffer As String, ByVal utc_Size As LongPtr, ByVal utc_Number As LongPtr, ByVal utc_File As LongPtr) As LongPtr
Private Declare PtrSafe Function utc_feof Lib "libc.dylib" Alias "feof" _
    (ByVal utc_File As LongPtr) As LongPtr

#Else

' 32-bit Mac
Private Declare Function utc_popen Lib "libc.dylib" Alias "popen" _
    (ByVal utc_Command As String, ByVal utc_Mode As String) As Long
Private Declare Function utc_pclose Lib "libc.dylib" Alias "pclose" _
    (ByVal utc_File As Long) As Long
Private Declare Function utc_fread Lib "libc.dylib" Alias "fread" _
    (ByVal utc_Buffer As String, ByVal utc_Size As Long, ByVal utc_Number As Long, ByVal utc_File As Long) As Long
Private Declare Function utc_feof Lib "libc.dylib" Alias "feof" _
    (ByVal utc_File As Long) As Long

#End If

#ElseIf VBA7 Then

' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724421.aspx
' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724949.aspx
' http://msdn.microsoft.com/en-us/library/windows/desktop/ms725485.aspx
Private Declare PtrSafe Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
Private Declare PtrSafe Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
Private Declare PtrSafe Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long

#Else

Private Declare Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
Private Declare Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
Private Declare Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long

#End If

#If Mac Then

#If VBA7 Then
Private Type utc_ShellResult
    utc_Output As String
    utc_ExitCode As LongPtr
End Type

#Else

Private Type utc_ShellResult
    utc_Output As String
    utc_ExitCode As Long
End Type

#End If

#Else

Private Type utc_SYSTEMTIME
    utc_wYear As Integer
    utc_wMonth As Integer
    utc_wDayOfWeek As Integer
    utc_wDay As Integer
    utc_wHour As Integer
    utc_wMinute As Integer
    utc_wSecond As Integer
    utc_wMilliseconds As Integer
End Type

Private Type utc_TIME_ZONE_INFORMATION
    utc_Bias As Long
    utc_StandardName(0 To 31) As Integer
    utc_StandardDate As utc_SYSTEMTIME
    utc_StandardBias As Long
    utc_DaylightName(0 To 31) As Integer
    utc_DaylightDate As utc_SYSTEMTIME
    utc_DaylightBias As Long
End Type

#End If
' === End VBA-UTC

#If Mac Then
#ElseIf VBA7 Then

Private Declare PtrSafe Sub json_CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
    (json_MemoryDestination As Any, json_MemorySource As Any, ByVal json_ByteLength As Long)

#Else

Private Declare Sub json_CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
    (json_MemoryDestination As Any, json_MemorySource As Any, ByVal json_ByteLength As Long)

#End If

Private Type json_Options
    ' VBA only stores 15 significant digits, so any numbers larger than that are truncated
    ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
    ' See: http://support.microsoft.com/kb/269370
    '
    ' By default, VBA-JSON will use String for numbers longer than 15 characters that contain only digits
    ' to override set `JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True`
    UseDoubleForLargeNumbers As Boolean

    ' The JSON standard requires object keys to be quoted (" or '), use this option to allow unquoted keys
    AllowUnquotedKeys As Boolean

    ' The solidus (/) is not required to be escaped, use this option to escape them as \/ in ConvertToJson
    EscapeSolidus As Boolean
End Type
Public JsonOptions As json_Options
' === End VBA-JSON

#If Mac Then
#If VBA7 Then
Private Declare PtrSafe Function web_popen Lib "libc.dylib" Alias "popen" (ByVal web_Command As String, ByVal web_Mode As String) As LongPtr
Private Declare PtrSafe Function web_pclose Lib "libc.dylib" Alias "pclose" (ByVal web_File As LongPtr) As LongPtr
Private Declare PtrSafe Function web_fread Lib "libc.dylib" Alias "fread" (ByVal web_OutStr As String, ByVal web_Size As LongPtr, ByVal web_Items As LongPtr, ByVal web_Stream As LongPtr) As LongPtr
Private Declare PtrSafe Function web_feof Lib "libc.dylib" Alias "feof" (ByVal web_File As LongPtr) As LongPtr
#Else
Private Declare Function web_popen Lib "libc.dylib" Alias "popen" (ByVal web_Command As String, ByVal web_Mode As String) As Long
Private Declare Function web_pclose Lib "libc.dylib" Alias "pclose" (ByVal web_File As Long) As Long
Private Declare Function web_fread Lib "libc.dylib" Alias "fread" (ByVal web_OutStr As String, ByVal web_Size As Long, ByVal web_Items As Long, ByVal web_Stream As Long) As Long
Private Declare Function web_feof Lib "libc.dylib" Alias "feof" (ByVal web_File As Long) As Long
#End If
#End If

Public Const WebUserAgent As String = "VBA-Web v4.1.3 (https://github.com/VBA-tools/VBA-Web)"

' @internal
Public Type ShellResult
    Output As String
    ExitCode As Long
End Type

Private web_pDocumentHelper As Object
Private web_pElHelper As Object
Private web_pConverters As Dictionary

' --------------------------------------------- '
' Types and Properties
' --------------------------------------------- '

''
' Helper for common http status codes. (Use underlying status code for any codes not listed)
'
' @example
' ```VB.net
' Dim Response As WebResponse
'
' If Response.StatusCode = WebStatusCode.Ok Then
'   ' Ok
' ElseIf Response.StatusCode = 418 Then
'   ' I'm a teapot
' End If
' ```
'
' @property WebStatusCode
' @param Ok `200`
' @param Created `201`
' @param NoContent `204`
' @param NotModified `304`
' @param BadRequest `400`
' @param Unauthorized `401`
' @param Forbidden `403`
' @param NotFound `404`
' @param RequestTimeout `408`
' @param UnsupportedMediaType `415`
' @param InternalServerError `500`
' @param BadGateway `502`
' @param ServiceUnavailable `503`
' @param GatewayTimeout `504`
''
Public Enum WebStatusCode
    Ok = 200
    Created = 201
    NoContent = 204
    NotModified = 304
    BadRequest = 400
    Unauthorized = 401
    Forbidden = 403
    NotFound = 404
    RequestTimeout = 408
    UnsupportedMediaType = 415
    InternalServerError = 500
    BadGateway = 502
    ServiceUnavailable = 503
    GatewayTimeout = 504
End Enum

''
' @property WebMethod
' @param HttpGet
' @param HttpPost
' @param HttpGet
' @param HttpGet
' @param HttpGet
' @default HttpGet
''
Public Enum WebMethod
    HttpGet = 0
    HttpPost = 1
    HttpPut = 2
    HttpDelete = 3
    HttpPatch = 4
    HttpHead = 5
End Enum

''
' @property WebFormat
' @param PlainText
' @param Json
' @param FormUrlEncoded
' @param Xml
' @param Custom
' @default PlainText
''
Public Enum WebFormat
    PlainText = 0
    Json = 1
    FormUrlEncoded = 2
    Xml = 3
    Custom = 9
End Enum

''
' @property UrlEncodingMode
' @param StrictUrlEncoding RFC 3986, ALPHA / DIGIT / "-" / "." / "_" / "~"
' @param FormUrlEncoding ALPHA / DIGIT / "-" / "." / "_" / "*", (space) -> "+", &...; UTF-8 encoding
' @param QueryUrlEncoding Subset of strict and form that should be suitable for non-form-urlencoded query strings
'   ALPHA / DIGIT / "-" / "." / "_"
' @param CookieUrlEncoding strict / "!" / "#" / "$" / "&" / "'" / "(" / ")" / "*" / "+" /
'   "/" / ":" / "<" / "=" / ">" / "?" / "@" / "[" / "]" / "^" / "`" / "{" / "|" / "}"
' @param PathUrlEncoding strict / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "=" / ":" / "@"
''
Public Enum UrlEncodingMode
    StrictUrlEncoding
    FormUrlEncoding
    QueryUrlEncoding
    CookieUrlEncoding
    PathUrlEncoding
End Enum

''
' Enable logging of requests and responses and other internal messages from VBA-Web.
' Should be the first step in debugging VBA-Web if something isn't working as expected.
' (Logs display in Immediate Window (`View > Immediate Window` or `ctrl+g`)
'
' @example
' ```VB.net
' Dim Client As New WebClient
' Client.BaseUrl = "https://api.example.com/v1/"
'
' Dim RequestWithTypo As New WebRequest
' RequestWithTypo.Resource = "peeple/{id}"
' RequestWithType.AddUrlSegment "idd", 123
'
' ' Enable logging before the request is executed
' WebHelpers.EnableLogging = True
'
' Dim Response As WebResponse
' Set Response = Client.Execute(Request)
'
' ' Immediate window:
' ' --> Request - (Time)
' ' GET https://api.example.com/v1/peeple/{id}
' ' Headers...
' '
' ' <-- Response - (Time)
' ' 404 ...
' ```
'
' @property EnableLogging
' @type Boolean
' @default False
''
Public EnableLogging As Boolean

''
' Store currently running async requests
'
' @property AsyncRequests
' @type Dictionary
''
Public AsyncRequests As Dictionary

' ============================================= '
' 1. Logging
' ============================================= '

''
' Log message (when logging is enabled with `EnableLogging`)
' with optional location where the message is coming from.
' Useful when writing extensions to VBA-Web (like an `IWebAuthenticator`).
'
' @example
' ```VB.net
' LogDebug "Executing request..."
' ' -> VBA-Web: Executing request...
'
' LogDebug "Executing request...", "Module.Function"
' ' -> Module.Function: Executing request...
' ```
'
' @method LogDebug
' @param {String} Message
' @param {String} [From="VBA-Web"]
''
Public Sub LogDebug(Message As String, Optional From As String = "VBA-Web")
    If EnableLogging Then
        Debug.Print From & ": " & Message
    End If
End Sub

''
' Log warning (even when logging is disabled with `EnableLogging`)
' with optional location where the message is coming from.
' Useful when writing extensions to VBA-Web (like an `IWebAuthenticator`).
'
' @example
' ```VB.net
' WebHelpers.LogWarning "Something could go wrong"
' ' -> WARNING - VBA-Web: Something could go wrong
'
' WebHelpers.LogWarning "Something could go wrong", "Module.Function"
' ' -> WARNING - Module.Function: Something could go wrong
' ```
'
' @method LogWarning
' @param {String} Message
' @param {String} [From="VBA-Web"]
''
Public Sub LogWarning(Message As String, Optional From As String = "VBA-Web")
    Debug.Print "WARNING - " & From & ": " & Message
End Sub

''
' Log error (even when logging is disabled with `EnableLogging`)
' with optional location where the message is coming from and error number.
' Useful when writing extensions to VBA-Web (like an `IWebAuthenticator`).
'
' @example
' ```VB.net
' WebHelpers.LogError "Something went wrong"
' ' -> ERROR - VBA-Web: Something went wrong
'
' WebHelpers.LogError "Something went wrong", "Module.Function"
' ' -> ERROR - Module.Function: Something went wrong
'
' WebHelpers.LogError "Something went wrong", "Module.Function", 100
' ' -> ERROR - Module.Function: 100, Something went wrong
' ```
'
' @method LogError
' @param {String} Message
' @param {String} [From="VBA-Web"]
' @param {Long} [ErrNumber=0]
''
Public Sub LogError(Message As String, Optional From As String = "VBA-Web", Optional ErrNumber As Long = 0)
    Dim web_ErrorValue As String
    If ErrNumber <> 0 Then
        web_ErrorValue = ErrNumber

        If ErrNumber < 0 Then
            web_ErrorValue = web_ErrorValue & " (" & (ErrNumber - vbObjectError) & " / " & VBA.LCase$(VBA.Hex$(ErrNumber)) & ")"
        End If

        web_ErrorValue = web_ErrorValue & ", "
    End If

    Debug.Print "ERROR - " & From & ": " & web_ErrorValue & Message
End Sub

''
' Log details of the request (Url, headers, cookies, body, etc.).
'
' @method LogRequest
' @param {WebClient} Client
' @param {WebRequest} Request
''
Public Sub LogRequest(client As WebClient, request As WebRequest)
    If EnableLogging Then
        Debug.Print "--> Request - " & Format(Now, "Long Time")
        Debug.Print MethodToName(request.Method) & " " & client.GetFullUrl(request)

        Dim web_KeyValue As Dictionary
        For Each web_KeyValue In request.Headers
            Debug.Print web_KeyValue("Key") & ": " & web_KeyValue("Value")
        Next web_KeyValue

        For Each web_KeyValue In request.Cookies
            Debug.Print "Cookie: " & web_KeyValue("Key") & "=" & web_KeyValue("Value")
        Next web_KeyValue

        If Not IsEmpty(request.Body) Then
            Debug.Print vbNewLine & CStr(request.Body)
        End If

        Debug.Print
    End If
End Sub

''
' Log details of the response (Status, headers, content, etc.).
'
' @method LogResponse
' @param {WebClient} Client
' @param {WebRequest} Request
' @param {WebResponse} Response
''
Public Sub LogResponse(client As WebClient, request As WebRequest, response As WebResponse)
    If EnableLogging Then
        Dim web_KeyValue As Dictionary

        Debug.Print "<-- Response - " & Format(Now, "Long Time")
        Debug.Print response.StatusCode & " " & response.StatusDescription

        For Each web_KeyValue In response.Headers
            Debug.Print web_KeyValue("Key") & ": " & web_KeyValue("Value")
        Next web_KeyValue

        For Each web_KeyValue In response.Cookies
            Debug.Print "Cookie: " & web_KeyValue("Key") & "=" & web_KeyValue("Value")
        Next web_KeyValue

        Debug.Print vbNewLine & response.Content & vbNewLine
    End If
End Sub

''
' Obfuscate any secure information before logging.
'
' @example
' ```VB.net
' Dim Password As String
' Password = "Secret"
'
' WebHelpers.LogDebug "Password = " & WebHelpers.Obfuscate(Password)
' -> Password = ******
' ```
'
' @param {String} Secure Message to obfuscate
' @param {String} [Character = *] Character to obfuscate with
' @return {String}
''
Public Function Obfuscate(Secure As String, Optional Character As String = "*") As String
    Obfuscate = VBA.String$(VBA.Len(Secure), Character)
End Function

' ============================================= '
' 2. Converters and encoding
' ============================================= '

'
' Parse JSON value to `Dictionary` if it's an object or `Collection` if it's an array.
'
' @method ParseJson
' @param {String} Json JSON value to parse
' @return {Dictionary|Collection}
'
' (Implemented in VBA-JSON embedded below)

'
' Convert `Dictionary`, `Collection`, or `Array` to JSON string.
'
' @method ConvertToJson
' @param {Dictionary|Collection|Array} Obj
' @return {String}
'
' (Implemented in VBA-JSON embedded below)

''
' Parse Url-Encoded value to `Dictionary`.
'
' @method ParseUrlEncoded
' @param {String} UrlEncoded Url-Encoded value to parse
' @return {Dictionary} Parsed
''
Public Function ParseUrlEncoded(Encoded As String) As Dictionary
    Dim web_Items As Variant
    Dim web_i As Integer
    Dim web_Parts As Variant
    Dim web_Key As String
    Dim web_Value As Variant
    Dim web_Parsed As New Dictionary

    web_Items = VBA.Split(Encoded, "&")
    For web_i = LBound(web_Items) To UBound(web_Items)
        web_Parts = VBA.Split(web_Items(web_i), "=")

        If UBound(web_Parts) - LBound(web_Parts) >= 1 Then
            ' TODO: Handle numbers, arrays, and object better here
            web_Key = UrlDecode(VBA.CStr(web_Parts(LBound(web_Parts))))
            web_Value = UrlDecode(VBA.CStr(web_Parts(LBound(web_Parts) + 1)))

            web_Parsed(web_Key) = web_Value
        End If
    Next web_i

    Set ParseUrlEncoded = web_Parsed
End Function

''
' Convert `Dictionary`/`Collection` to Url-Encoded string.
'
' @method ConvertToUrlEncoded
' @param {Dictionary|Collection|Variant} Obj Value to convert to Url-Encoded string
' @return {String} UrlEncoded string (e.g. a=123&b=456&...)
''
Public Function ConvertToUrlEncoded(Obj As Variant, Optional EncodingMode As UrlEncodingMode = UrlEncodingMode.FormUrlEncoding) As String
    Dim web_Encoded As String

    If TypeOf Obj Is Collection Then
        Dim web_KeyValue As Dictionary

        For Each web_KeyValue In Obj
            If VBA.Len(web_Encoded) > 0 Then: web_Encoded = web_Encoded & "&"
            web_Encoded = web_Encoded & web_GetUrlEncodedKeyValue(web_KeyValue("Key"), web_KeyValue("Value"), EncodingMode)
        Next web_KeyValue
    Else
        Dim web_Key As Variant

        For Each web_Key In Obj.Keys()
            If Len(web_Encoded) > 0 Then: web_Encoded = web_Encoded & "&"
            web_Encoded = web_Encoded & web_GetUrlEncodedKeyValue(web_Key, Obj(web_Key), EncodingMode)
        Next web_Key
    End If

    ConvertToUrlEncoded = web_Encoded
End Function

''
' Parse XML value to `Dictionary`.
'
' _Note_ Currently, XML is not supported in 4.0.0 due to lack of Mac support.
' An updated parser is being created that supports Mac and Windows,
' but in order to avoid future breaking changes, ParseXml and ConvertToXml are not currently implemented.
'
' See https://github.com/VBA-tools/VBA-Web/wiki/XML-Support-in-4.0 for details on how to use XML in Windows in the meantime.
'
' @param {String} Encoded XML value to parse
' @return {Dictionary|Object} Parsed
' @throws 11099 - XML format is not currently supported
''
Public Function ParseXml(Encoded As String) As Object
    Dim web_ErrorMsg As String

    web_ErrorMsg = "XML is not currently supported (An updated parser is being created that supports Mac and Windows)." & vbNewLine & _
        "To use XML parsing for Windows currently, use the instructions found here:" & vbNewLine & _
        vbNewLine & _
        "https://github.com/VBA-tools/VBA-Web/wiki/XML-Support-in-4.0"

    LogError web_ErrorMsg, "WebHelpers.ParseXml", 11099
    err.Raise 11099, "WebHeleprs.ParseXml", web_ErrorMsg
End Function

''
' Convert `Dictionary` to XML string.
'
' _Note_ Currently, XML is not supported in 4.0.0 due to lack of Mac support.
' An updated parser is being created that supports Mac and Windows,
' but in order to avoid future breaking changes, ParseXml and ConvertToXml are not currently implemented.
'
' See https://github.com/VBA-tools/VBA-Web/wiki/XML-Support-in-4.0 for details on how to use XML in Windows in the meantime.
'
' @param {Dictionary|Variant} XML
' @return {String} XML string
' @throws 11099 / 80042b5b / -2147210405 - XML format is not currently supported
''
Public Function ConvertToXml(Obj As Variant) As String
    Dim web_ErrorMsg As String

    web_ErrorMsg = "XML is not currently supported (An updated parser is being created that supports Mac and Windows)." & vbNewLine & _
        "To use XML parsing for Windows currently, use the instructions found here:" & vbNewLine & _
        vbNewLine & _
        "https://github.com/VBA-tools/VBA-Web/wiki/XML-Support-in-4.0"

    LogError web_ErrorMsg, "WebHelpers.ParseXml", 11099 + vbObjectError
    err.Raise 11099 + vbObjectError, "WebHeleprs.ParseXml", web_ErrorMsg
End Function

''
' Helper for parsing value to given `WebFormat` or custom format.
' Returns `Dictionary` or `Collection` based on given `Value`.
'
' @method ParseByFormat
' @param {String} Value Value to parse
' @param {WebFormat} Format
' @param {String} [CustomFormat=""] Name of registered custom converter
' @param {Variant} [Bytes] Bytes for custom convert (if `ParseType = "Binary"`)
' @return {Dictionary|Collection|Object}
' @throws 11000 - Error during parsing
''
Public Function ParseByFormat(Value As String, Format As WebFormat, _
    Optional CustomFormat As String = "", Optional Bytes As Variant) As Object

    On Error GoTo web_ErrorHandling

    ' Don't attempt to parse blank values
    If Value = "" And CustomFormat = "" Then
        Exit Function
    End If

    Select Case Format
    Case WebFormat.Json
        Set ParseByFormat = ParseJson(Value)
    Case WebFormat.FormUrlEncoded
        Set ParseByFormat = ParseUrlEncoded(Value)
    Case WebFormat.Xml
        Set ParseByFormat = ParseXml(Value)
    Case WebFormat.Custom
#If EnableCustomFormatting Then
        Dim web_Converter As Dictionary
        Dim web_Callback As String

        Set web_Converter = web_GetConverter(CustomFormat)
        web_Callback = web_Converter("ParseCallback")

        If web_Converter.Exists("Instance") Then
            Dim web_Instance As Object
            Set web_Instance = web_Converter("Instance")

            If web_Converter("ParseType") = "Binary" Then
                Set ParseByFormat = VBA.CallByName(web_Instance, web_Callback, VBA.vbMethod, Bytes)
            Else
                Set ParseByFormat = VBA.CallByName(web_Instance, web_Callback, VBA.vbMethod, Value)
            End If
        Else
            If web_Converter("ParseType") = "Binary" Then
                Set ParseByFormat = Application.Run(web_Callback, Bytes)
            Else
                Set ParseByFormat = Application.Run(web_Callback, Value)
            End If
        End If
#Else
    LogWarning "Custom formatting is disabled. To use WebFormat.Custom, enable custom formatting with the EnableCustomFormatting flag in WebHelpers"
#End If
    End Select
    Exit Function

web_ErrorHandling:

    Dim web_ErrorDescription As String
    web_ErrorDescription = "An error occurred during parsing" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

    LogError web_ErrorDescription, "WebHelpers.ParseByFormat", 11000
    err.Raise 11000, "WebHelpers.ParseByFormat", web_ErrorDescription
End Function

''
' Helper for converting value to given `WebFormat` or custom format.
'
' _Note_ Only some converters handle `Collection` or `Array`.
'
' @method ConvertToFormat
' @param {Dictionary|Collection|Variant} Obj
' @param {WebFormat} Format
' @param {String} [CustomFormat] Name of registered custom converter
' @return {Variant}
' @throws 11001 - Error during conversion
''
Public Function ConvertToFormat(Obj As Variant, Format As WebFormat, Optional CustomFormat As String = "") As Variant
    On Error GoTo web_ErrorHandling

    Select Case Format
    Case WebFormat.Json
        ConvertToFormat = ConvertToJson(Obj)
    Case WebFormat.FormUrlEncoded
        ConvertToFormat = ConvertToUrlEncoded(Obj)
    Case WebFormat.Xml
        ConvertToFormat = ConvertToXml(Obj)
    Case WebFormat.Custom
#If EnableCustomFormatting Then
        Dim web_Converter As Dictionary
        Dim web_Callback As String

        Set web_Converter = web_GetConverter(CustomFormat)
        web_Callback = web_Converter("ConvertCallback")

        If web_Converter.Exists("Instance") Then
            Dim web_Instance As Object
            Set web_Instance = web_Converter("Instance")
            ConvertToFormat = VBA.CallByName(web_Instance, web_Callback, VBA.vbMethod, Obj)
        Else
            ConvertToFormat = Application.Run(web_Callback, Obj)
        End If
#Else
    LogWarning "Custom formatting is disabled. To use WebFormat.Custom, enable custom formatting with the EnableCustomFormatting flag in WebHelpers"
#End If
    Case Else
        If VBA.VarType(Obj) = vbString Then
            ' Plain text
            ConvertToFormat = Obj
        End If
    End Select
    Exit Function

web_ErrorHandling:

    Dim web_ErrorDescription As String
    web_ErrorDescription = "An error occurred during conversion" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

    LogError web_ErrorDescription, "WebHelpers.ConvertToFormat", 11001
    err.Raise 11001, "WebHelpers.ConvertToFormat", web_ErrorDescription
End Function

''
' Encode string for URLs
'
' See https://github.com/VBA-tools/VBA-Web/wiki/Url-Encoding for details
'
' References:
' - RFC 3986, https://tools.ietf.org/html/rfc3986
' - form-urlencoded encoding algorithm,
'   https://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
' - RFC 6265 (Cookies), https://tools.ietf.org/html/rfc6265
'   Note: "%" is allowed in spec, but is currently excluded due to parsing issues
'
' @method UrlEncode
' @param {Variant} Text Text to encode
' @param {Boolean} [SpaceAsPlus = False] `%20` if `False` / `+` if `True`
'   DEPRECATED Use EncodingMode:=FormUrlEncoding
' @param {Boolean} [EncodeUnsafe = True] Encode characters that could be misunderstood within URLs.
'   (``SPACE, ", <, >, #, %, {, }, |, \, ^, ~, `, [, ]``)
'   DEPRECATED This was based on an outdated URI spec and has since been removed.
'     EncodingMode:=CookieUrlEncoding is the closest approximation of this behavior
' @param {UrlEncodingMode} [EncodingMode = StrictUrlEncoding]
' @return {String} Encoded string
''
Public Function UrlEncode(Text As Variant, _
    Optional SpaceAsPlus As Boolean = False, Optional EncodeUnsafe As Boolean = True, _
    Optional EncodingMode As UrlEncodingMode = UrlEncodingMode.StrictUrlEncoding) As String

    If SpaceAsPlus = True Then
        LogWarning "SpaceAsPlus is deprecated and will be removed in VBA-Web v5. " & _
            "Use EncodingMode:=FormUrlEncoding instead", "WebHelpers.UrlEncode"
    End If
    If EncodeUnsafe = False Then
        LogWarning "EncodeUnsafe has been removed as it was based on an outdated url encoding specification. " & _
            "Use EncodingMode:=CookieUrlEncoding to approximate this behavior", "WebHelpers.UrlEncode"
    End If

    Dim web_UrlVal As String
    Dim web_StringLen As Long

    web_UrlVal = VBA.CStr(Text)
    web_StringLen = VBA.Len(web_UrlVal)

    If web_StringLen > 0 Then
        Dim web_Result() As String
        Dim web_i As Long
        Dim web_CharCode As Integer
        Dim web_Char As String
        Dim web_Space As String
        ReDim web_Result(web_StringLen)

        ' StrictUrlEncoding - ALPHA / DIGIT / "-" / "." / "_" / "~"
        ' FormUrlEncoding   - ALPHA / DIGIT / "-" / "." / "_" / "*" / (space) -> "+"
        ' QueryUrlEncoding  - ALPHA / DIGIT / "-" / "." / "_"
        ' CookieUrlEncoding - strict / "!" / "#" / "$" / "&" / "'" / "(" / ")" / "*" / "+" /
        '   "/" / ":" / "<" / "=" / ">" / "?" / "@" / "[" / "]" / "^" / "`" / "{" / "|" / "}"
        ' PathUrlEncoding   - strict / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "=" / ":" / "@"

        ' Set space value
        If SpaceAsPlus Or EncodingMode = UrlEncodingMode.FormUrlEncoding Then
            web_Space = "+"
        Else
            web_Space = "%20"
        End If

        ' Loop through string characters
        For web_i = 1 To web_StringLen
            ' Get character and ascii code
            web_Char = VBA.Mid$(web_UrlVal, web_i, 1)
            web_CharCode = VBA.Asc(web_Char)

            Select Case web_CharCode
                Case 65 To 90, 97 To 122
                    ' ALPHA
                    web_Result(web_i) = web_Char
                Case 48 To 57
                    ' DIGIT
                    web_Result(web_i) = web_Char
                Case 45, 46, 95
                    ' "-" / "." / "_"
                    web_Result(web_i) = web_Char

                Case 32
                    ' (space)
                    ' FormUrlEncoding -> "+"
                    ' Else -> "%20"
                    web_Result(web_i) = web_Space

                Case 33, 36, 38, 39, 40, 41, 43, 58, 61, 64
                    ' "!" / "$" / "&" / "'" / "(" / ")" / "+" / ":" / "=" / "@"
                    ' PathUrlEncoding, CookieUrlEncoding -> Unencoded
                    ' Else -> Percent-encoded
                    If EncodingMode = UrlEncodingMode.PathUrlEncoding Or EncodingMode = UrlEncodingMode.CookieUrlEncoding Then
                        web_Result(web_i) = web_Char
                    Else
                        web_Result(web_i) = "%" & VBA.Hex(web_CharCode)
                    End If

                Case 35, 45, 46, 47, 60, 62, 63, 91, 93, 94, 95, 96, 123, 124, 125
                    ' "#" / "-" / "." / "/" / "<" / ">" / "?" / "[" / "]" / "^" / "_" / "`" / "{" / "|" / "}"
                    ' CookieUrlEncoding -> Unencoded
                    ' Else -> Percent-encoded
                    If EncodingMode = UrlEncodingMode.CookieUrlEncoding Then
                        web_Result(web_i) = web_Char
                    Else
                        web_Result(web_i) = "%" & VBA.Hex(web_CharCode)
                    End If

                Case 42
                    ' "*"
                    ' FormUrlEncoding, PathUrlEncoding, CookieUrlEncoding -> "*"
                    ' Else -> "%2A"
                    If EncodingMode = UrlEncodingMode.FormUrlEncoding _
                        Or EncodingMode = UrlEncodingMode.PathUrlEncoding _
                        Or EncodingMode = UrlEncodingMode.CookieUrlEncoding Then

                        web_Result(web_i) = web_Char
                    Else
                        web_Result(web_i) = "%" & VBA.Hex(web_CharCode)
                    End If

                Case 44, 59
                    ' "," / ";"
                    ' PathUrlEncoding -> Unencoded
                    ' Else -> Percent-encoded
                    If EncodingMode = UrlEncodingMode.PathUrlEncoding Then
                        web_Result(web_i) = web_Char
                    Else
                        web_Result(web_i) = "%" & VBA.Hex(web_CharCode)
                    End If

                Case 126
                    ' "~"
                    ' FormUrlEncoding, QueryUrlEncoding -> "%7E"
                    ' Else -> "~"
                    If EncodingMode = UrlEncodingMode.FormUrlEncoding Or EncodingMode = UrlEncodingMode.QueryUrlEncoding Then
                        web_Result(web_i) = "%7E"
                    Else
                        web_Result(web_i) = web_Char
                    End If

                Case 0 To 15
                    web_Result(web_i) = "%0" & VBA.Hex(web_CharCode)
                Case Else
                    web_Result(web_i) = "%" & VBA.Hex(web_CharCode)

                ' TODO For non-ASCII characters,
                '
                ' FormUrlEncoded:
                '
                ' Replace the character by a string consisting of a U+0026 AMPERSAND character (&), a "#" (U+0023) character,
                ' one or more ASCII digits representing the Unicode code point of the character in base ten, and finally a ";" (U+003B) character.
                '
                ' Else:
                '
                ' Encode to sequence of 2 or 3 bytes in UTF-8, then percent encode
                ' Reference Implementation: https://www.w3.org/International/URLUTF8Encoder.java
            End Select
        Next web_i
        UrlEncode = VBA.Join$(web_Result, "")
    End If
End Function

''
' Decode Url-encoded string.
'
' @method UrlDecode
' @param {String} Encoded Text to decode
' @param {Boolean} [PlusAsSpace = True] Decode plus as space
'   DEPRECATED Use EncodingMode:=FormUrlEncoding Or QueryUrlEncoding
' @param {UrlEncodingMode} [EncodingMode = StrictUrlEncoding]
' @return {String} Decoded string
''
Public Function UrlDecode(Encoded As String, _
    Optional PlusAsSpace As Boolean = True, _
    Optional EncodingMode As UrlEncodingMode = UrlEncodingMode.StrictUrlEncoding) As String

    Dim web_StringLen As Long
    web_StringLen = VBA.Len(Encoded)

    If web_StringLen > 0 Then
        Dim web_i As Long
        Dim web_Result As String
        Dim web_Temp As String

        For web_i = 1 To web_StringLen
            web_Temp = VBA.Mid$(Encoded, web_i, 1)

            If web_Temp = "+" And _
                (PlusAsSpace _
                 Or EncodingMode = UrlEncodingMode.FormUrlEncoding _
                 Or EncodingMode = UrlEncodingMode.QueryUrlEncoding) Then

                web_Temp = " "
            ElseIf web_Temp = "%" And web_StringLen >= web_i + 2 Then
                web_Temp = VBA.Mid$(Encoded, web_i + 1, 2)
                web_Temp = VBA.Chr(VBA.CInt("&H" & web_Temp))

                web_i = web_i + 2
            End If

            ' TODO Handle non-ASCII characters

            web_Result = web_Result & web_Temp
        Next web_i

        UrlDecode = web_Result
    End If
End Function

''
' Base64-encode text.
'
' @param {Variant} Text Text to encode
' @return {String} Encoded string
''
Public Function Base64Encode(Text As String) As String
#If Mac Then
    Dim web_Command As String
    web_Command = "printf " & PrepareTextForPrintf(Text) & " | openssl base64"
    Base64Encode = ExecuteInShell(web_Command).Output
#Else
    Dim web_Bytes() As Byte

    web_Bytes = VBA.StrConv(Text, vbFromUnicode)
    Base64Encode = web_AnsiBytesToBase64(web_Bytes)
#End If

    Base64Encode = VBA.Replace$(Base64Encode, vbLf, "")
End Function

''
' Decode Base64-encoded text
'
' @param {Variant} Encoded Text to decode
' @return {String} Decoded string
''
Public Function Base64Decode(Encoded As Variant) As String
    ' Add trailing padding, if necessary
    If (VBA.Len(Encoded) Mod 4 > 0) Then
        Encoded = Encoded & VBA.Left("====", 4 - (VBA.Len(Encoded) Mod 4))
    End If

#If Mac Then
    Dim web_Command As String
    web_Command = "echo " & PrepareTextForShell(Encoded) & " | openssl base64 -d"
    Base64Decode = ExecuteInShell(web_Command).Output
#Else
    Dim web_XmlObj As Object
    Dim web_Node As Object

    Set web_XmlObj = CreateObject("MSXML2.DOMDocument")
    Set web_Node = web_XmlObj.createElement("b64")

    web_Node.DataType = "bin.base64"
    web_Node.Text = Encoded
    Base64Decode = VBA.StrConv(web_Node.nodeTypedValue, vbUnicode)

    Set web_Node = Nothing
    Set web_XmlObj = Nothing
#End If
End Function

''
' Register custom converter for converting request `Body` and response `Content`.
' If the `ConvertCallback` or `ParseCallback` are object methods,
' pass in an object instance.
' If the `ParseCallback` needs the raw binary response value (e.g. file download),
' set `ParseType = "Binary"`, otherwise `"String"` is used.
'
' - `ConvertCallback` signature: `Function ...(Value As Variant) As String`
' - `ParseCallback` signature: `Function ...(Value As String) As Object`
'
' @example
' ```VB.net
' ' 1. Use global module functions for Convert and Parse
' ' ---
' ' Module: CSVConverter
' Function ParseCSV(Value As String) As Object
'   ' ...
' End Function
' Function ConvertToCSV(Value As Variant) As String
'   ' ...
' End Function
'
' WebHelpers.RegisterConverter "csv", "text/csv", _
'   "CSVConverter.ConvertToCSV", "CSVConverter.ParseCSV"
'
' ' 2. Use object instance functions for Convert and Parse
' ' ---
' ' Object: CSVConverterClass
' ' same as above...
'
' Dim Converter As New CSVConverterClass
' WebHelpers.RegisterConverter "csv", "text/csv", _
'   "ConvertToCSV", "ParseCSV", Instance:=Converter
'
' ' 3. Pass raw binary value to ParseCallback
' ' ---
' ' Module: ImageConverter
' Function ParseImage(Bytes As Variant) As Object
'   ' ...
' End Function
' Function ConvertToImage(Value As Variant) As String
'   ' ...
' End Function
'
' WebHelpers.RegisterConverter "image", "image/jpeg", _
'   "ImageConverter.ConvertToImage", "ImageConverter.ParseImage", _
'   ParseType:="Binary"
' ```
'
' @method RegisterConverter
' @param {String} Name
'   Name of converter for use with `CustomRequestFormat` or `CustomResponseFormat`
' @param {String} MediaType
'   Media type to use for `Content-Type` and `Accept` headers
' @param {String} ConvertCallback Global or object function name for converting
' @param {String} ParseCallback Global or object function name for parsing
' @param {Object} [Instance]
'   Use instance methods for `ConvertCallback` and `ParseCallback`
' @param {String} [ParseType="String"]
'   "String"` (default) or `"Binary"` to pass raw binary response to `ParseCallback`
''
Public Sub RegisterConverter( _
    Name As String, MediaType As String, ConvertCallback As String, ParseCallback As String, _
    Optional Instance As Object, Optional ParseType As String = "String")

    Dim web_Converter As New Dictionary
    web_Converter("MediaType") = MediaType
    web_Converter("ConvertCallback") = ConvertCallback
    web_Converter("ParseCallback") = ParseCallback
    web_Converter("ParseType") = ParseType

    If Not Instance Is Nothing Then
        Set web_Converter("Instance") = Instance
    End If

    If web_pConverters Is Nothing Then: Set web_pConverters = New Dictionary
    Set web_pConverters(Name) = web_Converter
End Sub

' Helper for getting custom converter
' @throws 11002 - No matching converter has been registered
Private Function web_GetConverter(web_CustomFormat As String) As Dictionary
    If web_pConverters.Exists(web_CustomFormat) Then
        Set web_GetConverter = web_pConverters(web_CustomFormat)
    Else
        LogError "No matching converter has been registered for custom format: " & web_CustomFormat, _
            "WebHelpers.web_GetConverter", 11002
        err.Raise 11002, "WebHelpers.web_GetConverter", _
            "No matching converter has been registered for custom format: " & web_CustomFormat
    End If
End Function

' ============================================= '
' 3. Url handling
' ============================================= '

''
' Join Url with /
'
' @example
' ```VB.net
' Debug.Print WebHelpers.JoinUrl("a/", "/b")
' Debug.Print WebHelpers.JoinUrl("a", "b")
' Debug.Print WebHelpers.JoinUrl("a/", "b")
' Debug.Print WebHelpers.JoinUrl("a", "/b")
' -> a/b
' ```
'
' @param {String} LeftSide
' @param {String} RightSide
' @return {String} Joined url
''
Public Function JoinUrl(LeftSide As String, RightSide As String) As String
    If Left(RightSide, 1) = "/" Then
        RightSide = Right(RightSide, Len(RightSide) - 1)
    End If
    If Right(LeftSide, 1) = "/" Then
        LeftSide = Left(LeftSide, Len(LeftSide) - 1)
    End If

    If LeftSide <> "" And RightSide <> "" Then
        JoinUrl = LeftSide & "/" & RightSide
    Else
        JoinUrl = LeftSide & RightSide
    End If
End Function

''
' Get relevant parts of the given url.
' Returns `Protocol`, `Host`, `Port`, `Path`, `Querystring`, and `Hash`
'
' @example
' ```VB.net
' WebHelpers.GetUrlParts "https://www.google.com/a/b/c.html?a=1&b=2#hash"
' ' -> Protocol = "https"
' '    Host = "www.google.com"
' '    Port = "443"
' '    Path = "/a/b/c.html"
' '    Querystring = "a=1&b=2"
' '    Hash = "hash"
'
' WebHelpers.GetUrlParts "localhost:3000/a/b/c"
' ' -> Protocol = ""
' '    Host = "localhost"
' '    Port = "3000"
' '    Path = "/a/b/c"
' '    Querystring = ""
' '    Hash = ""
' ```
'
' @method GetUrlParts
' @param {String} Url
' @return {Dictionary} Parts of url
'   Protocol, Host, Port, Path, Querystring, Hash
' @throws 11003 - Error while getting url parts
''
Public Function GetUrlParts(Url As String) As Dictionary
    Dim web_Parts As New Dictionary

    On Error GoTo web_ErrorHandling

#If Mac Then
    ' Run perl script to parse url

    Dim web_AddedProtocol As Boolean
    Dim web_Command As String
    Dim web_Results As Variant
    Dim web_ResultPart As Variant
    Dim web_EqualsIndex As Long
    Dim web_Key As String
    Dim web_Value As String

    ' Add Protocol if missing
    If InStr(1, Url, "://") <= 0 Then
        web_AddedProtocol = True
        If InStr(1, Url, "//") = 1 Then
            Url = "http" & Url
        Else
            Url = "http://" & Url
        End If
    End If

    web_Command = "perl -e '{use URI::URL;" & vbNewLine & _
        "$url = new URI::URL """ & Url & """;" & vbNewLine & _
        "print ""Protocol="" . $url->scheme;" & vbNewLine & _
        "print "" | Host="" . $url->host;" & vbNewLine & _
        "print "" | Port="" . $url->port;" & vbNewLine & _
        "print "" | FullPath="" . $url->full_path;" & vbNewLine & _
        "print "" | Hash="" . $url->frag;" & vbNewLine & _
    "}'"

    web_Results = Split(ExecuteInShell(web_Command).Output, " | ")
    For Each web_ResultPart In web_Results
        web_EqualsIndex = InStr(1, web_ResultPart, "=")
        web_Key = Trim(VBA.Mid$(web_ResultPart, 1, web_EqualsIndex - 1))
        web_Value = Trim(VBA.Mid$(web_ResultPart, web_EqualsIndex + 1))

        If web_Key = "FullPath" Then
            ' For properly escaped path and querystring, need to use full_path
            ' But, need to split FullPath into Path...?Querystring
            Dim QueryIndex As Integer

            QueryIndex = InStr(1, web_Value, "?")
            If QueryIndex > 0 Then
                web_Parts.Add "Path", Mid$(web_Value, 1, QueryIndex - 1)
                web_Parts.Add "Querystring", Mid$(web_Value, QueryIndex + 1)
            Else
                web_Parts.Add "Path", web_Value
                web_Parts.Add "Querystring", ""
            End If
        Else
            web_Parts.Add web_Key, web_Value
        End If
    Next web_ResultPart

    If web_AddedProtocol And web_Parts.Exists("Protocol") Then
        web_Parts("Protocol") = ""
    End If
#Else
    ' Create document/element is expensive, cache after creation
    If web_pDocumentHelper Is Nothing Or web_pElHelper Is Nothing Then
        Set web_pDocumentHelper = CreateObject("htmlfile")
        Set web_pElHelper = web_pDocumentHelper.createElement("a")
    End If

    web_pElHelper.href = Url
    web_Parts.Add "Protocol", Replace(web_pElHelper.Protocol, ":", "", Count:=1)
    web_Parts.Add "Host", web_pElHelper.hostname
    web_Parts.Add "Port", web_pElHelper.port
    web_Parts.Add "Path", web_pElHelper.pathname
    web_Parts.Add "Querystring", Replace(web_pElHelper.Search, "?", "", Count:=1)
    web_Parts.Add "Hash", Replace(web_pElHelper.Hash, "#", "", Count:=1)
#End If

    If web_Parts("Protocol") = "localhost" Then
        ' localhost:port/... was passed in without protocol
        Dim PathParts As Variant
        PathParts = Split(web_Parts("Path"), "/")

        web_Parts("Port") = PathParts(0)
        web_Parts("Protocol") = ""
        web_Parts("Host") = "localhost"
        web_Parts("Path") = Replace(web_Parts("Path"), web_Parts("Port"), "", Count:=1)
    End If
    If Left(web_Parts("Path"), 1) <> "/" Then
        web_Parts("Path") = "/" & web_Parts("Path")
    End If

    Set GetUrlParts = web_Parts
    Exit Function

web_ErrorHandling:

    Dim web_ErrorDescription As String
    web_ErrorDescription = "An error occurred while getting url parts" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

    LogError web_ErrorDescription, "WebHelpers.GetUrlParts", 11003
    err.Raise 11003, "WebHelpers.GetUrlParts", web_ErrorDescription
End Function

' ============================================= '
' 4. Object/Dictionary/Collection/Array helpers
' ============================================= '

''
' Create a cloned copy of the `Dictionary`.
' This is not a deep copy, so children objects are copied by reference.
'
' @method CloneDictionary
' @param {Dictionary} Original
' @return {Dictionary} Clone
''
Public Function CloneDictionary(Original As Dictionary) As Dictionary
    Dim web_Key As Variant

    Set CloneDictionary = New Dictionary
    For Each web_Key In Original.Keys
        CloneDictionary.Add VBA.CStr(web_Key), Original(web_Key)
    Next web_Key
End Function

''
' Create a cloned copy of the `Collection`.
' This is not a deep copy, so children objects are copied by reference.
'
' _Note_ Keys are not transferred to clone
'
' @method CloneCollection
' @param {Collection} Original
' @return {Collection} Clone
''
Public Function CloneCollection(Original As Collection) As Collection
    Dim web_Item As Variant

    Set CloneCollection = New Collection
    For Each web_Item In Original
        CloneCollection.Add web_Item
    Next web_Item
End Function

''
' Helper for creating `Key-Value` pair with `Dictionary`.
' Used in `WebRequest`/`WebResponse` `Cookies`, `Headers`, and `QuerystringParams`
'
' @example
' ```VB.net
' WebHelpers.CreateKeyValue "abc", 123
' ' -> {"Key": "abc", "Value": 123}
' ```
'
' @method CreateKeyValue
' @param {String} Key
' @param {Variant} Value
' @return {Dictionary}
''
Public Function CreateKeyValue(Key As String, Value As Variant) As Dictionary
    Dim web_KeyValue As New Dictionary

    web_KeyValue("Key") = Key
    web_KeyValue("Value") = Value
    Set CreateKeyValue = web_KeyValue
End Function

''
' Search a `Collection` of `KeyValue` and retrieve the value for the given key.
'
' @example
' ```VB.net
' Dim KeyValues As New Collection
' KeyValues.Add WebHelpers.CreateKeyValue("abc", 123)
'
' WebHelpers.FindInKeyValues KeyValues, "abc"
' ' -> 123
'
' WebHelpers.FindInKeyValues KeyValues, "unknown"
' ' -> Empty
' ```
'
' @method FindInKeyValues
' @param {Collection} KeyValues
' @param {Variant} Key to find
' @return {Variant}
''
Public Function FindInKeyValues(KeyValues As Collection, Key As Variant) As Variant
    Dim web_KeyValue As Dictionary

    For Each web_KeyValue In KeyValues
        If web_KeyValue("Key") = Key Then
            FindInKeyValues = web_KeyValue("Value")
            Exit Function
        End If
    Next web_KeyValue
End Function

''
' Helper for adding/replacing `KeyValue` in `Collection` of `KeyValue`
' - Add if key not found
' - Replace if key is found
'
' @example
' ```VB.net
' Dim KeyValues As New Collection
' KeyValues.Add WebHelpers.CreateKeyValue("a", 123)
' KeyValues.Add WebHelpers.CreateKeyValue("b", 456)
' KeyValues.Add WebHelpers.CreateKeyValue("c", 789)
'
' WebHelpers.AddOrReplaceInKeyValues KeyValues, "b", "abc"
' WebHelpers.AddOrReplaceInKeyValues KeyValues, "d", "def"
'
' ' -> [
' '      {"Key":"a","Value":123},
' '      {"Key":"b","Value":"abc"},
' '      {"Key":"c","Value":789},
' '      {"Key":"d","Value":"def"}
' '    ]
' ```
'
' @method AddOrReplaceInKeyValues
' @param {Collection} KeyValues
' @param {Variant} Key
' @param {Variant} Value
' @return {Variant}
''
Public Sub AddOrReplaceInKeyValues(KeyValues As Collection, Key As Variant, Value As Variant)
    Dim web_KeyValue As Dictionary
    Dim web_Index As Long
    Dim web_NewKeyValue As Dictionary

    Set web_NewKeyValue = CreateKeyValue(CStr(Key), Value)

    web_Index = 1
    For Each web_KeyValue In KeyValues
        If web_KeyValue("Key") = Key Then
            ' Replace existing
            KeyValues.Remove web_Index

            If KeyValues.Count = 0 Then
                KeyValues.Add web_NewKeyValue
            ElseIf web_Index > KeyValues.Count Then
                KeyValues.Add web_NewKeyValue, After:=web_Index - 1
            Else
                KeyValues.Add web_NewKeyValue, Before:=web_Index
            End If
            Exit Sub
        End If

        web_Index = web_Index + 1
    Next web_KeyValue

    ' Add
    KeyValues.Add web_NewKeyValue
End Sub

' ============================================= '
' 5. Request preparation / handling
' ============================================= '

''
' Get the media-type for the given format / custom format.
'
' @method FormatToMediaType
' @param {WebFormat} Format
' @param {String} [CustomFormat] Needed if `Format = WebFormat.Custom`
' @return {String}
''
Public Function FormatToMediaType(Format As WebFormat, Optional CustomFormat As String) As String
    Select Case Format
    Case WebFormat.FormUrlEncoded
        FormatToMediaType = "application/x-www-form-urlencoded;charset=UTF-8"
    Case WebFormat.Json
        FormatToMediaType = "application/json"
    Case WebFormat.Xml
        FormatToMediaType = "application/xml"
    Case WebFormat.Custom
        FormatToMediaType = web_GetConverter(CustomFormat)("MediaType")
    Case Else
        FormatToMediaType = "text/plain"
    End Select
End Function

''
' Get the method name for the given `WebMethod`
'
' @example
' ```VB.net
' WebHelpers.MethodToName WebMethod.HttpPost
' ' -> "POST"
' ```
'
' @method MethodToName
' @param {WebMethod} Method
' @return {String}
''
Public Function MethodToName(Method As WebMethod) As String
    Select Case Method
    Case WebMethod.HttpDelete
        MethodToName = "DELETE"
    Case WebMethod.HttpPut
        MethodToName = "PUT"
    Case WebMethod.HttpPatch
        MethodToName = "PATCH"
    Case WebMethod.HttpPost
        MethodToName = "POST"
    Case WebMethod.HttpGet
        MethodToName = "GET"
    Case WebMethod.HttpHead
        MethodToName = "HEAD"
    End Select
End Function

' ============================================= '
' 6. Timing
' ============================================= '

''
' Handle timeout timers expiring
'
' @internal
' @method OnTimeoutTimerExpired
' @param {String} RequestId
''
Public Sub OnTimeoutTimerExpired(web_RequestId As String)
    If Not AsyncRequests Is Nothing Then
        If AsyncRequests.Exists(web_RequestId) Then
            Dim web_AsyncWrapper As Object
            Set web_AsyncWrapper = AsyncRequests(web_RequestId)
            web_AsyncWrapper.TimedOut
        End If
    End If
End Sub

' ============================================= '
' 7. Mac
' ============================================= '

''
' Execute the given command
'
' @internal
' @method ExecuteInShell
' @param {String} Command
' @return {ShellResult}
''
Public Function ExecuteInShell(web_Command As String) As ShellResult
#If Mac Then
#If VBA7 Then
    Dim web_File As LongPtr
#Else
    Dim web_File As Long
#End If

    Dim web_Chunk As String
    Dim web_Read As Long

    On Error GoTo web_Cleanup

    web_File = web_popen(web_Command, "r")

    If web_File = 0 Then
        ' TODO Investigate why this could happen and what should be done if it happens
        Exit Function
    End If

    Do While web_feof(web_File) = 0
        web_Chunk = VBA.Space$(50)
        web_Read = CLng(web_fread(web_Chunk, 1, Len(web_Chunk) - 1, web_File))
        If web_Read > 0 Then
            web_Chunk = VBA.Left$(web_Chunk, web_Read)
            ExecuteInShell.Output = ExecuteInShell.Output & web_Chunk
        End If
    Loop

web_Cleanup:

    ExecuteInShell.ExitCode = CLng(web_pclose(web_File))
#End If
End Function

''
' Prepare text for shell
' - Wrap in "..."
' - Replace ! with '!' (reserved in bash)
' - Escape \, `, $, %, and "
'
' @internal
' @method PrepareTextForShell
' @param {String} Text
' @return {String}
''
Public Function PrepareTextForShell(ByVal web_Text As String) As String
    ' Escape special characters (except for !)
    web_Text = VBA.Replace(web_Text, "\", "\\")
    web_Text = VBA.Replace(web_Text, "`", "\`")
    web_Text = VBA.Replace(web_Text, "$", "\$")
    web_Text = VBA.Replace(web_Text, "%", "\%")
    web_Text = VBA.Replace(web_Text, """", "\""")

    ' Wrap in quotes
    web_Text = """" & web_Text & """"

    ' Escape !
    web_Text = VBA.Replace(web_Text, "!", """'!'""")

    ' Guard for ! at beginning or end (""'!'"..." or "..."'!'"" -> '!'"..." or "..."'!')
    If VBA.Left$(web_Text, 3) = """""'" Then
        web_Text = VBA.Right$(web_Text, VBA.Len(web_Text) - 2)
    End If
    If VBA.Right$(web_Text, 3) = "'""""" Then
        web_Text = VBA.Left$(web_Text, VBA.Len(web_Text) - 2)
    End If

    PrepareTextForShell = web_Text
End Function

''
' Prepare text for using with printf command
' - Wrap in "..."
' - Replace ! with '!' (reserved in bash)
' - Escape \, `, $, and "
' - Replace % with %% (used as an argument marker in printf)
'
' @internal
' @method PrepareTextForPrintf
' @param {String} Text
' @return {String}
''
Public Function PrepareTextForPrintf(ByVal web_Text As String) As String
    ' Escape special characters (except for !)
    web_Text = VBA.Replace(web_Text, "\", "\\")
    web_Text = VBA.Replace(web_Text, "`", "\`")
    web_Text = VBA.Replace(web_Text, "$", "\$")
    web_Text = VBA.Replace(web_Text, "%", "%%")
    web_Text = VBA.Replace(web_Text, """", "\""")

    ' Wrap in quotes
    web_Text = """" & web_Text & """"

    ' Escape !
    web_Text = VBA.Replace(web_Text, "!", """'!'""")

    ' Guard for ! at beginning or end (""'!'"..." or "..."'!'"" -> '!'"..." or "..."'!')
    If VBA.Left$(web_Text, 3) = """""'" Then
        web_Text = VBA.Right$(web_Text, VBA.Len(web_Text) - 2)
    End If
    If VBA.Right$(web_Text, 3) = "'""""" Then
        web_Text = VBA.Left$(web_Text, VBA.Len(web_Text) - 2)
    End If

    PrepareTextForPrintf = web_Text
End Function

' ============================================= '
' 8. Cryptography
' ============================================= '

''
' Determine the HMAC for the given text and secret using the SHA1 hash algorithm.
'
' Reference:
' - http://stackoverflow.com/questions/8246340/does-vba-have-a-hash-hmac
'
' @example
' ```VB.net
' WebHelpers.HMACSHA1 "Howdy!", "Secret"
' ' -> c8fdf74a9d62aa41ac8136a1af471cec028fb157
' ```
'
' @method HMACSHA1
' @param {String} Text
' @param {String} Secret
' @param {String} [Format="Hex"] "Hex" or "Base64" encoding for result
' @return {String} HMAC-SHA1
''
Public Function HMACSHA1(Text As String, Secret As String, Optional Format As String = "Hex") As String
#If Mac Then
    Dim web_Command As String
    web_Command = "printf " & PrepareTextForPrintf(Text) & " | openssl dgst -sha1 -hmac " & PrepareTextForShell(Secret)

    If Format = "Base64" Then
        web_Command = web_Command & " -binary | openssl enc -base64"
    End If

    HMACSHA1 = VBA.Replace(ExecuteInShell(web_Command).Output, vbLf, "")
#Else
    Dim web_Crypto As Object
    Dim web_TextBytes() As Byte
    Dim web_SecretBytes() As Byte
    Dim web_Bytes() As Byte

    web_TextBytes = VBA.StrConv(Text, vbFromUnicode)
    web_SecretBytes = VBA.StrConv(Secret, vbFromUnicode)

    Set web_Crypto = CreateObject("System.Security.Cryptography.HMACSHA1")
    web_Crypto.Key = web_SecretBytes
    web_Bytes = web_Crypto.ComputeHash_2(web_TextBytes)

    Select Case Format
    Case "Base64"
        HMACSHA1 = web_AnsiBytesToBase64(web_Bytes)
    Case Else
        HMACSHA1 = web_AnsiBytesToHex(web_Bytes)
    End Select
#End If
End Function

''
' Determine the HMAC for the given text and secret using the SHA256 hash algorithm.
'
' @example
' ```VB.net
' WebHelpers.HMACSHA256 "Howdy!", "Secret"
' ' -> fb5d65...
' ```
'
' @method HMACSHA256
' @param {String} Text
' @param {String} Secret
' @param {String} [Format="Hex"] "Hex" or "Base64" encoding for result
' @return {String} HMAC-SHA256
''
Public Function HMACSHA256(Text As String, Secret As String, Optional Format As String = "Hex") As String
#If Mac Then
    Dim web_Command As String
    web_Command = "printf " & PrepareTextForPrintf(Text) & " | openssl dgst -sha256 -hmac " & PrepareTextForShell(Secret)

    If Format = "Base64" Then
        web_Command = web_Command & " -binary | openssl enc -base64"
    End If

    HMACSHA256 = VBA.Replace(ExecuteInShell(web_Command).Output, vbLf, "")
#Else
    Dim web_Crypto As Object
    Dim web_TextBytes() As Byte
    Dim web_SecretBytes() As Byte
    Dim web_Bytes() As Byte

    web_TextBytes = VBA.StrConv(Text, vbFromUnicode)
    web_SecretBytes = VBA.StrConv(Secret, vbFromUnicode)

    Set web_Crypto = CreateObject("System.Security.Cryptography.HMACSHA256")
    web_Crypto.Key = web_SecretBytes
    web_Bytes = web_Crypto.ComputeHash_2(web_TextBytes)

    Select Case Format
    Case "Base64"
        HMACSHA256 = web_AnsiBytesToBase64(web_Bytes)
    Case Else
        HMACSHA256 = web_AnsiBytesToHex(web_Bytes)
    End Select
#End If
End Function

''
' Determine the MD5 hash of the given text.
'
' Reference:
' - http://www.di-mgt.com.au/src/basMD5.bas.html
'
' @example
' ```VB.net
' WebHelpers.MD5 "Howdy!"
' ' -> 7105f32280940271293ee00ac97da5a7
' ```
'
' @method MD5
' @param {String} Text
' @param {String} [Format="Hex"] "Hex" or "Base64" encoding for result
' @return {String} MD5 Hash
''
Public Function MD5(Text As String, Optional Format As String = "Hex") As String
#If Mac Then
    Dim web_Command As String
    web_Command = "printf " & PrepareTextForPrintf(Text) & " | openssl dgst -md5"

    If Format = "Base64" Then
        web_Command = web_Command & " -binary | openssl enc -base64"
    End If

    MD5 = VBA.Replace(ExecuteInShell(web_Command).Output, vbLf, "")
#Else
    Dim web_Crypto As Object
    Dim web_TextBytes() As Byte
    Dim web_Bytes() As Byte

    web_TextBytes = VBA.StrConv(Text, vbFromUnicode)

    Set web_Crypto = CreateObject("System.Security.Cryptography.MD5CryptoServiceProvider")
    web_Bytes = web_Crypto.ComputeHash_2(web_TextBytes)

    Select Case Format
    Case "Base64"
        MD5 = web_AnsiBytesToBase64(web_Bytes)
    Case Else
        MD5 = web_AnsiBytesToHex(web_Bytes)
    End Select
#End If
End Function

''
' Create random alphanumeric nonce (0-9a-zA-Z)
'
' @method CreateNonce
' @param {Integer} [NonceLength=32]
' @return {String} Randomly generated nonce
''
Public Function CreateNonce(Optional NonceLength As Integer = 32) As String
    Dim web_Str As String
    Dim web_Count As Integer
    Dim web_Result As String
    Dim web_Random As Integer

    web_Str = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUIVWXYZ"
    web_Result = ""

    VBA.Randomize
    For web_Count = 1 To NonceLength
        web_Random = VBA.Int(((VBA.Len(web_Str) - 1) * VBA.Rnd) + 1)
        web_Result = web_Result & VBA.Mid$(web_Str, web_Random, 1)
    Next
    CreateNonce = web_Result
End Function

''
' Convert string to ANSI bytes
'
' @internal
' @method StringToAnsiBytes
' @param {String} Text
' @return {Byte()}
''
Public Function StringToAnsiBytes(web_Text As String) As Byte()
    Dim web_Bytes() As Byte
    Dim web_AnsiBytes() As Byte
    Dim web_ByteIndex As Long
    Dim web_AnsiIndex As Long

    If VBA.Len(web_Text) > 0 Then
        ' Take first byte from unicode bytes
        ' VBA.Int is used for floor instead of round
        web_Bytes = web_Text
        ReDim web_AnsiBytes(VBA.Int(UBound(web_Bytes) / 2))

        web_AnsiIndex = LBound(web_Bytes)
        For web_ByteIndex = LBound(web_Bytes) To UBound(web_Bytes) Step 2
            web_AnsiBytes(web_AnsiIndex) = web_Bytes(web_ByteIndex)
            web_AnsiIndex = web_AnsiIndex + 1
        Next web_ByteIndex
    End If

    StringToAnsiBytes = web_AnsiBytes
End Function

#If Mac Then
#Else
Private Function web_AnsiBytesToBase64(web_Bytes() As Byte)
    ' Use XML to convert to Base64
    Dim web_XmlObj As Object
    Dim web_Node As Object

    Set web_XmlObj = CreateObject("MSXML2.DOMDocument")
    Set web_Node = web_XmlObj.createElement("b64")

    web_Node.DataType = "bin.base64"
    web_Node.nodeTypedValue = web_Bytes
    web_AnsiBytesToBase64 = web_Node.Text

    Set web_Node = Nothing
    Set web_XmlObj = Nothing
End Function

Private Function web_AnsiBytesToHex(web_Bytes() As Byte)
    Dim web_i As Long
    For web_i = LBound(web_Bytes) To UBound(web_Bytes)
        web_AnsiBytesToHex = web_AnsiBytesToHex & VBA.LCase$(VBA.Right$("0" & VBA.Hex$(web_Bytes(web_i)), 2))
    Next web_i
End Function
#End If

' ============================================= '
' 9. Converters
' ============================================= '

' Helper for url-encoded to create key=value pair
Private Function web_GetUrlEncodedKeyValue(Key As Variant, Value As Variant, Optional EncodingMode As UrlEncodingMode = UrlEncodingMode.FormUrlEncoding) As String
    Select Case VBA.VarType(Value)
    Case VBA.vbBoolean
        ' Convert boolean to lowercase
        If Value Then
            Value = "true"
        Else
            Value = "false"
        End If
    Case VBA.vbDate
        ' Use region invariant date (ISO-8601)
        Value = WebHelpers.ConvertToIso(CDate(Value))
    Case VBA.vbDecimal, VBA.vbSingle, VBA.vbDouble, VBA.vbCurrency
        ' Use region invariant number encoding ("." for decimal separator)
        Value = VBA.Replace(VBA.CStr(Value), ",", ".")
    End Select

    ' Url encode key and value (using + for spaces)
    web_GetUrlEncodedKeyValue = UrlEncode(Key, EncodingMode:=EncodingMode) & "=" & UrlEncode(Value, EncodingMode:=EncodingMode)
End Function

''
' VBA-JSON v2.2.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-JSON
'
' JSON Converter for VBA
'
' Errors:
' 10001 - JSON parse error
'
' @class JsonConverter
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
'
' Based originally on vba-json (with extensive changes)
' BSD license included below
'
' JSONLib, http://code.google.com/p/vba-json/
'
' Copyright (c) 2013, Ryo Yokoyama
' All rights reserved.
'
' Redistribution and use in source and binary forms, with or without
' modification, are permitted provided that the following conditions are met:
'     * Redistributions of source code must retain the above copyright
'       notice, this list of conditions and the following disclaimer.
'     * Redistributions in binary form must reproduce the above copyright
'       notice, this list of conditions and the following disclaimer in the
'       documentation and/or other materials provided with the distribution.
'     * Neither the name of the <organization> nor the
'       names of its contributors may be used to endorse or promote products
'       derived from this software without specific prior written permission.
'
' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
' DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
' DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
' (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
' LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
' ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
' SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '

' (Declarations moved to top)

' ============================================= '
' Public Methods
' ============================================= '

''
' Convert JSON string to object (Dictionary/Collection)
'
' @method ParseJson
' @param {String} json_String
' @return {Object} (Dictionary or Collection)
' @throws 10001 - JSON parse error
''
Public Function ParseJson(ByVal JsonString As String) As Object
    Dim json_Index As Long
    json_Index = 1

    ' Remove vbCr, vbLf, and vbTab from json_String
    JsonString = VBA.Replace(VBA.Replace(VBA.Replace(JsonString, VBA.vbCr, ""), VBA.vbLf, ""), VBA.vbTab, "")

    json_SkipSpaces JsonString, json_Index
    Select Case VBA.Mid$(JsonString, json_Index, 1)
    Case "{"
        Set ParseJson = json_ParseObject(JsonString, json_Index)
    Case "["
        Set ParseJson = json_ParseArray(JsonString, json_Index)
    Case Else
        ' Error: Invalid JSON string
        err.Raise 10001, "JSONConverter", json_ParseErrorMessage(JsonString, json_Index, "Expecting '{' or '['")
    End Select
End Function

''
' Convert object (Dictionary/Collection/Array) to JSON
'
' @method ConvertToJson
' @param {Variant} JsonValue (Dictionary, Collection, or Array)
' @param {Integer|String} Whitespace "Pretty" print json with given number of spaces per indentation (Integer) or given string
' @return {String}
''
Public Function ConvertToJson(ByVal JsonValue As Variant, Optional ByVal Whitespace As Variant, Optional ByVal json_CurrentIndentation As Long = 0) As String
    Dim json_buffer As String
    Dim json_BufferPosition As Long
    Dim json_BufferLength As Long
    Dim json_Index As Long
    Dim json_LBound As Long
    Dim json_UBound As Long
    Dim json_IsFirstItem As Boolean
    Dim json_Index2D As Long
    Dim json_LBound2D As Long
    Dim json_UBound2D As Long
    Dim json_IsFirstItem2D As Boolean
    Dim json_Key As Variant
    Dim json_Value As Variant
    Dim json_DateStr As String
    Dim json_Converted As String
    Dim json_SkipItem As Boolean
    Dim json_PrettyPrint As Boolean
    Dim json_Indentation As String
    Dim json_InnerIndentation As String

    json_LBound = -1
    json_UBound = -1
    json_IsFirstItem = True
    json_LBound2D = -1
    json_UBound2D = -1
    json_IsFirstItem2D = True
    json_PrettyPrint = Not IsMissing(Whitespace)

    Select Case VBA.VarType(JsonValue)
    Case VBA.vbNull
        ConvertToJson = "null"
    Case VBA.vbDate
        ' Date
        json_DateStr = ConvertToIso(VBA.CDate(JsonValue))

        ConvertToJson = """" & json_DateStr & """"
    Case VBA.vbString
        ' String (or large number encoded as string)
        If Not JsonOptions.UseDoubleForLargeNumbers And json_StringIsLargeNumber(JsonValue) Then
            ConvertToJson = JsonValue
        Else
            ConvertToJson = """" & json_Encode(JsonValue) & """"
        End If
    Case VBA.vbBoolean
        If JsonValue Then
            ConvertToJson = "true"
        Else
            ConvertToJson = "false"
        End If
    Case VBA.vbArray To VBA.vbArray + VBA.vbByte
        If json_PrettyPrint Then
            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                json_InnerIndentation = VBA.String$(json_CurrentIndentation + 2, Whitespace)
            Else
                json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                json_InnerIndentation = VBA.Space$((json_CurrentIndentation + 2) * Whitespace)
            End If
        End If

        ' Array
        json_BufferAppend json_buffer, "[", json_BufferPosition, json_BufferLength

        On Error Resume Next

        json_LBound = LBound(JsonValue, 1)
        json_UBound = UBound(JsonValue, 1)
        json_LBound2D = LBound(JsonValue, 2)
        json_UBound2D = UBound(JsonValue, 2)

        If json_LBound >= 0 And json_UBound >= 0 Then
            For json_Index = json_LBound To json_UBound
                If json_IsFirstItem Then
                    json_IsFirstItem = False
                Else
                    ' Append comma to previous line
                    json_BufferAppend json_buffer, ",", json_BufferPosition, json_BufferLength
                End If

                If json_LBound2D >= 0 And json_UBound2D >= 0 Then
                    ' 2D Array
                    If json_PrettyPrint Then
                        json_BufferAppend json_buffer, vbNewLine, json_BufferPosition, json_BufferLength
                    End If
                    json_BufferAppend json_buffer, json_Indentation & "[", json_BufferPosition, json_BufferLength

                    For json_Index2D = json_LBound2D To json_UBound2D
                        If json_IsFirstItem2D Then
                            json_IsFirstItem2D = False
                        Else
                            json_BufferAppend json_buffer, ",", json_BufferPosition, json_BufferLength
                        End If

                        json_Converted = ConvertToJson(JsonValue(json_Index, json_Index2D), Whitespace, json_CurrentIndentation + 2)

                        ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                        If json_Converted = "" Then
                            ' (nest to only check if converted = "")
                            If json_IsUndefined(JsonValue(json_Index, json_Index2D)) Then
                                json_Converted = "null"
                            End If
                        End If

                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_InnerIndentation & json_Converted
                        End If

                        json_BufferAppend json_buffer, json_Converted, json_BufferPosition, json_BufferLength
                    Next json_Index2D

                    If json_PrettyPrint Then
                        json_BufferAppend json_buffer, vbNewLine, json_BufferPosition, json_BufferLength
                    End If

                    json_BufferAppend json_buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
                    json_IsFirstItem2D = True
                Else
                    ' 1D Array
                    json_Converted = ConvertToJson(JsonValue(json_Index), Whitespace, json_CurrentIndentation + 1)

                    ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                    If json_Converted = "" Then
                        ' (nest to only check if converted = "")
                        If json_IsUndefined(JsonValue(json_Index)) Then
                            json_Converted = "null"
                        End If
                    End If

                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & json_Converted
                    End If

                    json_BufferAppend json_buffer, json_Converted, json_BufferPosition, json_BufferLength
                End If
            Next json_Index
        End If

        On Error GoTo 0

        If json_PrettyPrint Then
            json_BufferAppend json_buffer, vbNewLine, json_BufferPosition, json_BufferLength

            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
            Else
                json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
            End If
        End If

        json_BufferAppend json_buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength

        ConvertToJson = json_BufferToString(json_buffer, json_BufferPosition, json_BufferLength)

    ' Dictionary or Collection
    Case VBA.vbObject
        If json_PrettyPrint Then
            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
            Else
                json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
            End If
        End If

        ' Dictionary
        If VBA.TypeName(JsonValue) = "Dictionary" Then
            json_BufferAppend json_buffer, "{", json_BufferPosition, json_BufferLength
            For Each json_Key In JsonValue.Keys
                ' For Objects, undefined (Empty/Nothing) is not added to object
                json_Converted = ConvertToJson(JsonValue(json_Key), Whitespace, json_CurrentIndentation + 1)
                If json_Converted = "" Then
                    json_SkipItem = json_IsUndefined(JsonValue(json_Key))
                Else
                    json_SkipItem = False
                End If

                If Not json_SkipItem Then
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        json_BufferAppend json_buffer, ",", json_BufferPosition, json_BufferLength
                    End If

                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & """" & json_Key & """: " & json_Converted
                    Else
                        json_Converted = """" & json_Key & """:" & json_Converted
                    End If

                    json_BufferAppend json_buffer, json_Converted, json_BufferPosition, json_BufferLength
                End If
            Next json_Key

            If json_PrettyPrint Then
                json_BufferAppend json_buffer, vbNewLine, json_BufferPosition, json_BufferLength

                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If

            json_BufferAppend json_buffer, json_Indentation & "}", json_BufferPosition, json_BufferLength

        ' Collection
        ElseIf VBA.TypeName(JsonValue) = "Collection" Then
            json_BufferAppend json_buffer, "[", json_BufferPosition, json_BufferLength
            For Each json_Value In JsonValue
                If json_IsFirstItem Then
                    json_IsFirstItem = False
                Else
                    json_BufferAppend json_buffer, ",", json_BufferPosition, json_BufferLength
                End If

                json_Converted = ConvertToJson(json_Value, Whitespace, json_CurrentIndentation + 1)

                ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                If json_Converted = "" Then
                    ' (nest to only check if converted = "")
                    If json_IsUndefined(json_Value) Then
                        json_Converted = "null"
                    End If
                End If

                If json_PrettyPrint Then
                    json_Converted = vbNewLine & json_Indentation & json_Converted
                End If

                json_BufferAppend json_buffer, json_Converted, json_BufferPosition, json_BufferLength
            Next json_Value

            If json_PrettyPrint Then
                json_BufferAppend json_buffer, vbNewLine, json_BufferPosition, json_BufferLength

                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If

            json_BufferAppend json_buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
        End If

        ConvertToJson = json_BufferToString(json_buffer, json_BufferPosition, json_BufferLength)
    Case VBA.vbInteger, VBA.vbLong, VBA.vbSingle, VBA.vbDouble, VBA.vbCurrency, VBA.vbDecimal
        ' Number (use decimals for numbers)
        ConvertToJson = VBA.Replace(JsonValue, ",", ".")
    Case Else
        ' vbEmpty, vbError, vbDataObject, vbByte, vbUserDefinedType
        ' Use VBA's built-in to-string
        On Error Resume Next
        ConvertToJson = JsonValue
        On Error GoTo 0
    End Select
End Function

' ============================================= '
' Private Functions
' ============================================= '

Private Function json_ParseObject(json_String As String, ByRef json_Index As Long) As Dictionary
    Dim json_Key As String
    Dim json_NextChar As String

    Set json_ParseObject = New Dictionary
    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> "{" Then
        err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '{'")
    Else
        json_Index = json_Index + 1

        Do
            json_SkipSpaces json_String, json_Index
            If VBA.Mid$(json_String, json_Index, 1) = "}" Then
                json_Index = json_Index + 1
                Exit Function
            ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                json_Index = json_Index + 1
                json_SkipSpaces json_String, json_Index
            End If

            json_Key = json_ParseKey(json_String, json_Index)
            json_NextChar = json_Peek(json_String, json_Index)
            If json_NextChar = "[" Or json_NextChar = "{" Then
                Set json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
            Else
                json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
            End If
        Loop
    End If
End Function

Private Function json_ParseArray(json_String As String, ByRef json_Index As Long) As Collection
    Set json_ParseArray = New Collection

    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> "[" Then
        err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '['")
    Else
        json_Index = json_Index + 1

        Do
            json_SkipSpaces json_String, json_Index
            If VBA.Mid$(json_String, json_Index, 1) = "]" Then
                json_Index = json_Index + 1
                Exit Function
            ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                json_Index = json_Index + 1
                json_SkipSpaces json_String, json_Index
            End If

            json_ParseArray.Add json_ParseValue(json_String, json_Index)
        Loop
    End If
End Function

Private Function json_ParseValue(json_String As String, ByRef json_Index As Long) As Variant
    json_SkipSpaces json_String, json_Index
    Select Case VBA.Mid$(json_String, json_Index, 1)
    Case "{"
        Set json_ParseValue = json_ParseObject(json_String, json_Index)
    Case "["
        Set json_ParseValue = json_ParseArray(json_String, json_Index)
    Case """", "'"
        json_ParseValue = json_ParseString(json_String, json_Index)
    Case Else
        If VBA.Mid$(json_String, json_Index, 4) = "true" Then
            json_ParseValue = True
            json_Index = json_Index + 4
        ElseIf VBA.Mid$(json_String, json_Index, 5) = "false" Then
            json_ParseValue = False
            json_Index = json_Index + 5
        ElseIf VBA.Mid$(json_String, json_Index, 4) = "null" Then
            json_ParseValue = Null
            json_Index = json_Index + 4
        ElseIf VBA.InStr("+-0123456789", VBA.Mid$(json_String, json_Index, 1)) Then
            json_ParseValue = json_ParseNumber(json_String, json_Index)
        Else
            err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['")
        End If
    End Select
End Function

Private Function json_ParseString(json_String As String, ByRef json_Index As Long) As String
    Dim json_Quote As String
    Dim json_Char As String
    Dim json_Code As String
    Dim json_buffer As String
    Dim json_BufferPosition As Long
    Dim json_BufferLength As Long

    json_SkipSpaces json_String, json_Index

    ' Store opening quote to look for matching closing quote
    json_Quote = VBA.Mid$(json_String, json_Index, 1)
    json_Index = json_Index + 1

    Do While json_Index > 0 And json_Index <= Len(json_String)
        json_Char = VBA.Mid$(json_String, json_Index, 1)

        Select Case json_Char
        Case "\"
            ' Escaped string, \\, or \/
            json_Index = json_Index + 1
            json_Char = VBA.Mid$(json_String, json_Index, 1)

            Select Case json_Char
            Case """", "\", "/", "'"
                json_BufferAppend json_buffer, json_Char, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "b"
                json_BufferAppend json_buffer, vbBack, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "f"
                json_BufferAppend json_buffer, vbFormFeed, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "n"
                json_BufferAppend json_buffer, vbCrLf, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "r"
                json_BufferAppend json_buffer, vbCr, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "t"
                json_BufferAppend json_buffer, vbTab, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "u"
                ' Unicode character escape (e.g. \u00a9 = Copyright)
                json_Index = json_Index + 1
                json_Code = VBA.Mid$(json_String, json_Index, 4)
                json_BufferAppend json_buffer, VBA.ChrW(VBA.Val("&h" + json_Code)), json_BufferPosition, json_BufferLength
                json_Index = json_Index + 4
            End Select
        Case json_Quote
            json_ParseString = json_BufferToString(json_buffer, json_BufferPosition, json_BufferLength)
            json_Index = json_Index + 1
            Exit Function
        Case Else
            json_BufferAppend json_buffer, json_Char, json_BufferPosition, json_BufferLength
            json_Index = json_Index + 1
        End Select
    Loop
End Function

Private Function json_ParseNumber(json_String As String, ByRef json_Index As Long) As Variant
    Dim json_Char As String
    Dim json_Value As String
    Dim json_IsLargeNumber As Boolean

    json_SkipSpaces json_String, json_Index

    Do While json_Index > 0 And json_Index <= Len(json_String)
        json_Char = VBA.Mid$(json_String, json_Index, 1)

        If VBA.InStr("+-0123456789.eE", json_Char) Then
            ' Unlikely to have massive number, so use simple append rather than buffer here
            json_Value = json_Value & json_Char
            json_Index = json_Index + 1
        Else
            ' Excel only stores 15 significant digits, so any numbers larger than that are truncated
            ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
            ' See: http://support.microsoft.com/kb/269370
            '
            ' Fix: Parse -> String, Convert -> String longer than 15/16 characters containing only numbers and decimal points -> Number
            ' (decimal doesn't factor into significant digit count, so if present check for 15 digits + decimal = 16)
            json_IsLargeNumber = IIf(InStr(json_Value, "."), Len(json_Value) >= 17, Len(json_Value) >= 16)
            If Not JsonOptions.UseDoubleForLargeNumbers And json_IsLargeNumber Then
                json_ParseNumber = json_Value
            Else
                ' VBA.Val does not use regional settings, so guard for comma is not needed
                json_ParseNumber = VBA.Val(json_Value)
            End If
            Exit Function
        End If
    Loop
End Function

Private Function json_ParseKey(json_String As String, ByRef json_Index As Long) As String
    ' Parse key with single or double quotes
    If VBA.Mid$(json_String, json_Index, 1) = """" Or VBA.Mid$(json_String, json_Index, 1) = "'" Then
        json_ParseKey = json_ParseString(json_String, json_Index)
    ElseIf JsonOptions.AllowUnquotedKeys Then
        Dim json_Char As String
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
            If (json_Char <> " ") And (json_Char <> ":") Then
                json_ParseKey = json_ParseKey & json_Char
                json_Index = json_Index + 1
            Else
                Exit Do
            End If
        Loop
    Else
        err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '""' or '''")
    End If

    ' Check for colon and skip if present or throw if not present
    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> ":" Then
        err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting ':'")
    Else
        json_Index = json_Index + 1
    End If
End Function

Private Function json_IsUndefined(ByVal json_Value As Variant) As Boolean
    ' Empty / Nothing -> undefined
    Select Case VBA.VarType(json_Value)
    Case VBA.vbEmpty
        json_IsUndefined = True
    Case VBA.vbObject
        Select Case VBA.TypeName(json_Value)
        Case "Empty", "Nothing"
            json_IsUndefined = True
        End Select
    End Select
End Function

Private Function json_Encode(ByVal json_Text As Variant) As String
    ' Reference: http://www.ietf.org/rfc/rfc4627.txt
    ' Escape: ", \, /, backspace, form feed, line feed, carriage return, tab
    Dim json_Index As Long
    Dim json_Char As String
    Dim json_AscCode As Long
    Dim json_buffer As String
    Dim json_BufferPosition As Long
    Dim json_BufferLength As Long

    For json_Index = 1 To VBA.Len(json_Text)
        json_Char = VBA.Mid$(json_Text, json_Index, 1)
        json_AscCode = VBA.AscW(json_Char)

        ' When AscW returns a negative number, it returns the twos complement form of that number.
        ' To convert the twos complement notation into normal binary notation, add 0xFFF to the return result.
        ' https://support.microsoft.com/en-us/kb/272138
        If json_AscCode < 0 Then
            json_AscCode = json_AscCode + 65536
        End If

        ' From spec, ", \, and control characters must be escaped (solidus is optional)

        Select Case json_AscCode
        Case 34
            ' " -> 34 -> \"
            json_Char = "\"""
        Case 92
            ' \ -> 92 -> \\
            json_Char = "\\"
        Case 47
            ' / -> 47 -> \/ (optional)
            If JsonOptions.EscapeSolidus Then
                json_Char = "\/"
            End If
        Case 8
            ' backspace -> 8 -> \b
            json_Char = "\b"
        Case 12
            ' form feed -> 12 -> \f
            json_Char = "\f"
        Case 10
            ' line feed -> 10 -> \n
            json_Char = "\n"
        Case 13
            ' carriage return -> 13 -> \r
            json_Char = "\r"
        Case 9
            ' tab -> 9 -> \t
            json_Char = "\t"
        Case 0 To 31, 127 To 65535
            ' Non-ascii characters -> convert to 4-digit hex
            json_Char = "\u" & VBA.Right$("0000" & VBA.Hex$(json_AscCode), 4)
        End Select

        json_BufferAppend json_buffer, json_Char, json_BufferPosition, json_BufferLength
    Next json_Index

    json_Encode = json_BufferToString(json_buffer, json_BufferPosition, json_BufferLength)
End Function

Private Function json_Peek(json_String As String, ByVal json_Index As Long, Optional json_NumberOfCharacters As Long = 1) As String
    ' "Peek" at the next number of characters without incrementing json_Index (ByVal instead of ByRef)
    json_SkipSpaces json_String, json_Index
    json_Peek = VBA.Mid$(json_String, json_Index, json_NumberOfCharacters)
End Function

Private Sub json_SkipSpaces(json_String As String, ByRef json_Index As Long)
    ' Increment index to skip over spaces
    Do While json_Index > 0 And json_Index <= VBA.Len(json_String) And VBA.Mid$(json_String, json_Index, 1) = " "
        json_Index = json_Index + 1
    Loop
End Sub

Private Function json_StringIsLargeNumber(json_String As Variant) As Boolean
    ' Check if the given string is considered a "large number"
    ' (See json_ParseNumber)

    Dim json_Length As Long
    Dim json_CharIndex As Long
    json_Length = VBA.Len(json_String)

    ' Length with be at least 16 characters and assume will be less than 100 characters
    If json_Length >= 16 And json_Length <= 100 Then
        Dim json_CharCode As String
        Dim json_Index As Long

        json_StringIsLargeNumber = True

        For json_CharIndex = 1 To json_Length
            json_CharCode = VBA.Asc(VBA.Mid$(json_String, json_CharIndex, 1))
            Select Case json_CharCode
            ' Look for .|0-9|E|e
            Case 46, 48 To 57, 69, 101
                ' Continue through characters
            Case Else
                json_StringIsLargeNumber = False
                Exit Function
            End Select
        Next json_CharIndex
    End If
End Function

Private Function json_ParseErrorMessage(json_String As String, ByRef json_Index As Long, ErrorMessage As String)
    ' Provide detailed parse error message, including details of where and what occurred
    '
    ' Example:
    ' Error parsing JSON:
    ' {"abcde":True}
    '          ^
    ' Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['

    Dim json_StartIndex As Long
    Dim json_StopIndex As Long

    ' Include 10 characters before and after error (if possible)
    json_StartIndex = json_Index - 10
    json_StopIndex = json_Index + 10
    If json_StartIndex <= 0 Then
        json_StartIndex = 1
    End If
    If json_StopIndex > VBA.Len(json_String) Then
        json_StopIndex = VBA.Len(json_String)
    End If

    json_ParseErrorMessage = "Error parsing JSON:" & VBA.vbNewLine & _
                             VBA.Mid$(json_String, json_StartIndex, json_StopIndex - json_StartIndex + 1) & VBA.vbNewLine & _
                             VBA.Space$(json_Index - json_StartIndex) & "^" & VBA.vbNewLine & _
                             ErrorMessage
End Function

Private Sub json_BufferAppend(ByRef json_buffer As String, _
                              ByRef json_Append As Variant, _
                              ByRef json_BufferPosition As Long, _
                              ByRef json_BufferLength As Long)
#If Mac Then
    json_buffer = json_buffer & json_Append
#Else
    ' VBA can be slow to append strings due to allocating a new string for each append
    ' Instead of using the traditional append, allocate a large empty string and then copy string at append position
    '
    ' Example:
    ' Buffer: "abc  "
    ' Append: "def"
    ' Buffer Position: 3
    ' Buffer Length: 5
    '
    ' Buffer position + Append length > Buffer length -> Append chunk of blank space to buffer
    ' Buffer: "abc       "
    ' Buffer Length: 10
    '
    ' Copy memory for "def" into buffer at position 3 (0-based)
    ' Buffer: "abcdef    "
    '
    ' Approach based on cStringBuilder from vbAccelerator
    ' http://www.vbaccelerator.com/home/VB/Code/Techniques/RunTime_Debug_Tracing/VB6_Tracer_Utility_zip_cStringBuilder_cls.asp

    Dim json_AppendLength As Long
    Dim json_LengthPlusPosition As Long

    json_AppendLength = VBA.LenB(json_Append)
    json_LengthPlusPosition = json_AppendLength + json_BufferPosition

    If json_LengthPlusPosition > json_BufferLength Then
        ' Appending would overflow buffer, add chunks until buffer is long enough
        Dim json_TemporaryLength As Long

        json_TemporaryLength = json_BufferLength
        Do While json_TemporaryLength < json_LengthPlusPosition
            ' Initially, initialize string with 255 characters,
            ' then add large chunks (8192) after that
            '
            ' Size: # Characters x 2 bytes / character
            If json_TemporaryLength = 0 Then
                json_TemporaryLength = json_TemporaryLength + 510
            Else
                json_TemporaryLength = json_TemporaryLength + 16384
            End If
        Loop

        json_buffer = json_buffer & VBA.Space$((json_TemporaryLength - json_BufferLength) \ 2)
        json_BufferLength = json_TemporaryLength
    End If

    ' Copy memory from append to buffer at buffer position
    json_CopyMemory ByVal json_UnsignedAdd(StrPtr(json_buffer), _
                    json_BufferPosition), _
                    ByVal StrPtr(json_Append), _
                    json_AppendLength

    json_BufferPosition = json_BufferPosition + json_AppendLength
#End If
End Sub

Private Function json_BufferToString(ByRef json_buffer As String, ByVal json_BufferPosition As Long, ByVal json_BufferLength As Long) As String
#If Mac Then
    json_BufferToString = json_buffer
#Else
    If json_BufferPosition > 0 Then
        json_BufferToString = VBA.Left$(json_buffer, json_BufferPosition \ 2)
    End If
#End If
End Function

#If VBA7 Then
Private Function json_UnsignedAdd(json_Start As LongPtr, json_Increment As Long) As LongPtr
#Else
Private Function json_UnsignedAdd(json_Start As Long, json_Increment As Long) As Long
#End If

    If json_Start And &H80000000 Then
        json_UnsignedAdd = json_Start + json_Increment
    ElseIf (json_Start Or &H80000000) < -json_Increment Then
        json_UnsignedAdd = json_Start + json_Increment
    Else
        json_UnsignedAdd = (json_Start + &H80000000) + (json_Increment + &H80000000)
    End If
End Function

''
' VBA-UTC v1.0.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-UtcConverter
'
' UTC/ISO 8601 Converter for VBA
'
' Errors:
' 10011 - UTC parsing error
' 10012 - UTC conversion error
' 10013 - ISO 8601 parsing error
' 10014 - ISO 8601 conversion error
'
' @module UtcConverter
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '

' (Declarations moved to top)

' ============================================= '
' Public Methods
' ============================================= '

''
' Parse UTC date to local date
'
' @method ParseUtc
' @param {Date} UtcDate
' @return {Date} Local date
' @throws 10011 - UTC parsing error
''
Public Function ParseUtc(utc_UtcDate As Date) As Date
    On Error GoTo utc_ErrorHandling

#If Mac Then
    ParseUtc = utc_ConvertDate(utc_UtcDate)
#Else
    Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
    Dim utc_LocalDate As utc_SYSTEMTIME

    utc_GetTimeZoneInformation utc_TimeZoneInfo
    utc_SystemTimeToTzSpecificLocalTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_UtcDate), utc_LocalDate

    ParseUtc = utc_SystemTimeToDate(utc_LocalDate)
#End If

    Exit Function

utc_ErrorHandling:
    err.Raise 10011, "UtcConverter.ParseUtc", "UTC parsing error: " & err.Number & " - " & err.Description
End Function

''
' Convert local date to UTC date
'
' @method ConvertToUrc
' @param {Date} utc_LocalDate
' @return {Date} UTC date
' @throws 10012 - UTC conversion error
''
Public Function ConvertToUtc(utc_LocalDate As Date) As Date
    On Error GoTo utc_ErrorHandling

#If Mac Then
    ConvertToUtc = utc_ConvertDate(utc_LocalDate, utc_ConvertToUtc:=True)
#Else
    Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
    Dim utc_UtcDate As utc_SYSTEMTIME

    utc_GetTimeZoneInformation utc_TimeZoneInfo
    utc_TzSpecificLocalTimeToSystemTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_LocalDate), utc_UtcDate

    ConvertToUtc = utc_SystemTimeToDate(utc_UtcDate)
#End If

    Exit Function

utc_ErrorHandling:
    err.Raise 10012, "UtcConverter.ConvertToUtc", "UTC conversion error: " & err.Number & " - " & err.Description
End Function

''
' Parse ISO 8601 date string to local date
'
' @method ParseIso
' @param {Date} utc_IsoString
' @return {Date} Local date
' @throws 10013 - ISO 8601 parsing error
''
Public Function ParseIso(utc_IsoString As String) As Date
    On Error GoTo utc_ErrorHandling

    Dim utc_Parts() As String
    Dim utc_DateParts() As String
    Dim utc_TimeParts() As String
    Dim utc_OffsetIndex As Long
    Dim utc_HasOffset As Boolean
    Dim utc_NegativeOffset As Boolean
    Dim utc_OffsetParts() As String
    Dim utc_Offset As Date

    utc_Parts = VBA.Split(utc_IsoString, "T")
    utc_DateParts = VBA.Split(utc_Parts(0), "-")
    ParseIso = VBA.DateSerial(VBA.CInt(utc_DateParts(0)), VBA.CInt(utc_DateParts(1)), VBA.CInt(utc_DateParts(2)))

    If UBound(utc_Parts) > 0 Then
        If VBA.InStr(utc_Parts(1), "Z") Then
            utc_TimeParts = VBA.Split(VBA.Replace(utc_Parts(1), "Z", ""), ":")
        Else
            utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "+")
            If utc_OffsetIndex = 0 Then
                utc_NegativeOffset = True
                utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "-")
            End If

            If utc_OffsetIndex > 0 Then
                utc_HasOffset = True
                utc_TimeParts = VBA.Split(VBA.Left$(utc_Parts(1), utc_OffsetIndex - 1), ":")
                utc_OffsetParts = VBA.Split(VBA.Right$(utc_Parts(1), Len(utc_Parts(1)) - utc_OffsetIndex), ":")

                Select Case UBound(utc_OffsetParts)
                Case 0
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), 0, 0)
                Case 1
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), 0)
                Case 2
                    ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), Int(VBA.Val(utc_OffsetParts(2))))
                End Select

                If utc_NegativeOffset Then: utc_Offset = -utc_Offset
            Else
                utc_TimeParts = VBA.Split(utc_Parts(1), ":")
            End If
        End If

        Select Case UBound(utc_TimeParts)
        Case 0
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), 0, 0)
        Case 1
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), 0)
        Case 2
            ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), Int(VBA.Val(utc_TimeParts(2))))
        End Select

        ParseIso = ParseUtc(ParseIso)

        If utc_HasOffset Then
            ParseIso = ParseIso + utc_Offset
        End If
    End If

    Exit Function

utc_ErrorHandling:
    err.Raise 10013, "UtcConverter.ParseIso", "ISO 8601 parsing error for " & utc_IsoString & ": " & err.Number & " - " & err.Description
End Function

''
' Convert local date to ISO 8601 string
'
' @method ConvertToIso
' @param {Date} utc_LocalDate
' @return {Date} ISO 8601 string
' @throws 10014 - ISO 8601 conversion error
''
Public Function ConvertToIso(utc_LocalDate As Date) As String
    On Error GoTo utc_ErrorHandling

    ConvertToIso = VBA.Format$(ConvertToUtc(utc_LocalDate), "yyyy-mm-ddTHH:mm:ss.000Z")

    Exit Function

utc_ErrorHandling:
    err.Raise 10014, "UtcConverter.ConvertToIso", "ISO 8601 conversion error: " & err.Number & " - " & err.Description
End Function

' ============================================= '
' Private Functions
' ============================================= '

#If Mac Then

Private Function utc_ConvertDate(utc_Value As Date, Optional utc_ConvertToUtc As Boolean = False) As Date
    Dim utc_ShellCommand As String
    Dim utc_Result As utc_ShellResult
    Dim utc_Parts() As String
    Dim utc_DateParts() As String
    Dim utc_TimeParts() As String

    If utc_ConvertToUtc Then
        utc_ShellCommand = "date -ur `date -jf '%Y-%m-%d %H:%M:%S' " & _
            "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & "' " & _
            " +'%s'` +'%Y-%m-%d %H:%M:%S'"
    Else
        utc_ShellCommand = "date -jf '%Y-%m-%d %H:%M:%S %z' " & _
            "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & " +0000' " & _
            "+'%Y-%m-%d %H:%M:%S'"
    End If

    utc_Result = utc_ExecuteInShell(utc_ShellCommand)

    If utc_Result.utc_Output = "" Then
        err.Raise 10015, "UtcConverter.utc_ConvertDate", "'date' command failed"
    Else
        utc_Parts = Split(utc_Result.utc_Output, " ")
        utc_DateParts = Split(utc_Parts(0), "-")
        utc_TimeParts = Split(utc_Parts(1), ":")

        utc_ConvertDate = DateSerial(utc_DateParts(0), utc_DateParts(1), utc_DateParts(2)) + _
            TimeSerial(utc_TimeParts(0), utc_TimeParts(1), utc_TimeParts(2))
    End If
End Function

Private Function utc_ExecuteInShell(utc_ShellCommand As String) As utc_ShellResult
#If VBA7 Then
    Dim utc_File As LongPtr
    Dim utc_Read As LongPtr
#Else
    Dim utc_File As Long
    Dim utc_Read As Long
#End If

    Dim utc_Chunk As String

    On Error GoTo utc_ErrorHandling
    utc_File = utc_popen(utc_ShellCommand, "r")

    If utc_File = 0 Then: Exit Function

    Do While utc_feof(utc_File) = 0
        utc_Chunk = VBA.Space$(50)
        utc_Read = CLng(utc_fread(utc_Chunk, 1, Len(utc_Chunk) - 1, utc_File))
        If utc_Read > 0 Then
            utc_Chunk = VBA.Left$(utc_Chunk, utc_Read)
            utc_ExecuteInShell.utc_Output = utc_ExecuteInShell.utc_Output & utc_Chunk
        End If
    Loop

utc_ErrorHandling:
    utc_ExecuteInShell.utc_ExitCode = CLng(utc_pclose(utc_File))
End Function

#Else

Private Function utc_DateToSystemTime(utc_Value As Date) As utc_SYSTEMTIME
    utc_DateToSystemTime.utc_wYear = VBA.Year(utc_Value)
    utc_DateToSystemTime.utc_wMonth = VBA.Month(utc_Value)
    utc_DateToSystemTime.utc_wDay = VBA.Day(utc_Value)
    utc_DateToSystemTime.utc_wHour = VBA.Hour(utc_Value)
    utc_DateToSystemTime.utc_wMinute = VBA.Minute(utc_Value)
    utc_DateToSystemTime.utc_wSecond = VBA.Second(utc_Value)
    utc_DateToSystemTime.utc_wMilliseconds = 0
End Function

Private Function utc_SystemTimeToDate(utc_Value As utc_SYSTEMTIME) As Date
    utc_SystemTimeToDate = DateSerial(utc_Value.utc_wYear, utc_Value.utc_wMonth, utc_Value.utc_wDay) + _
        TimeSerial(utc_Value.utc_wHour, utc_Value.utc_wMinute, utc_Value.utc_wSecond)
End Function

#End If

''
' AutoProxy 1.0.2
' (c) Damien Thirion
'
' Auto configure proxy server
'
' Based on code shared by Stephen Sulzer
' https://groups.google.com/d/msg/microsoft.public.winhttp/ZeWN2Xig82g/jgHIBDSfBwsJ
'
' Errors:
' 11020 - Unknown error while detecting proxy
' 11021 - WPAD detection failed
' 11022 - Unable to download proxy auto-config script
' 11023 - Error in proxy auto-config script
' 11024 - No proxy can be located for the specified URL
' 11025 - Specified URL is not valid
'
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '

''
' Returns IE proxy settings
' including auto-detection and auto-config scripts results
'
' @param {String} Url
' @param[out] {String} ProxyServer
' @param[out] {String} ProxyBypass
''
Public Sub GetAutoProxy(ByVal Url As String, ByRef ProxyServer As String, ByRef ProxyBypass As String)
#If Mac Then
    ' (Windows only)
#ElseIf VBA7 Then
    Dim AutoProxy_ProxyStringPtr As LongPtr
    Dim AutoProxy_ptr As LongPtr
    Dim AutoProxy_hSession As LongPtr
#Else
    Dim AutoProxy_ProxyStringPtr As Long
    Dim AutoProxy_ptr As Long
    Dim AutoProxy_hSession As Long
#End If
#If Mac Then
#Else
    Dim AutoProxy_IEProxyConfig As AUTOPROXY_IE_PROXY_CONFIG
    Dim AutoProxy_AutoProxyOptions As AUTOPROXY_OPTIONS
    Dim AutoProxy_ProxyInfo As AUTOPROXY_INFO
    Dim AutoProxy_doAutoProxy As Boolean
    Dim AutoProxy_Error As Long
    Dim AutoProxy_ErrorMsg As String

    AutoProxy_AutoProxyOptions.AutoProxy_fAutoLogonIfChallenged = 1
    ProxyServer = ""
    ProxyBypass = ""

    ' WinHttpGetProxyForUrl returns unexpected errors if Url is empty
    If Url = "" Then Url = " "

    On Error GoTo AutoProxy_Cleanup

    ' Check IE's proxy configuration
    If (AutoProxy_GetIEProxy(AutoProxy_IEProxyConfig) > 0) Then
        ' If IE is configured to auto-detect, then we will too.
        If (AutoProxy_IEProxyConfig.AutoProxy_fAutoDetect <> 0) Then
            AutoProxy_AutoProxyOptions.AutoProxy_dwFlags = AUTOPROXY_AUTO_DETECT
            AutoProxy_AutoProxyOptions.AutoProxy_dwAutoDetectFlags = _
                AUTOPROXY_DETECT_TYPE_DHCP + AUTOPROXY_DETECT_TYPE_DNS
            AutoProxy_doAutoProxy = True
        End If

        ' If IE is configured to use an auto-config script, then
        ' we will use it too
        If (AutoProxy_IEProxyConfig.AutoProxy_lpszAutoConfigUrl <> 0) Then
            AutoProxy_AutoProxyOptions.AutoProxy_dwFlags = _
                AutoProxy_AutoProxyOptions.AutoProxy_dwFlags + AUTOPROXY_CONFIG_URL
            AutoProxy_AutoProxyOptions.AutoProxy_lpszAutoConfigUrl = AutoProxy_IEProxyConfig.AutoProxy_lpszAutoConfigUrl
            AutoProxy_doAutoProxy = True
        End If
    Else
        ' If the IE proxy config is not available, then
        ' we will try auto-detection
        AutoProxy_AutoProxyOptions.AutoProxy_dwFlags = AUTOPROXY_AUTO_DETECT
        AutoProxy_AutoProxyOptions.AutoProxy_dwAutoDetectFlags = _
            AUTOPROXY_DETECT_TYPE_DHCP + AUTOPROXY_DETECT_TYPE_DNS
        AutoProxy_doAutoProxy = True
    End If

    If AutoProxy_doAutoProxy Then
        On Error GoTo AutoProxy_TryIEFallback

        ' Need to create a temporary WinHttp session handle
        ' Note: Performance of this GetProxyInfoForUrl function can be
        '       improved by saving this AutoProxy_hSession handle across calls
        '       instead of creating a new handle each time
        AutoProxy_hSession = AutoProxy_HttpOpen(0, 1, 0, 0, 0)

        If (AutoProxy_GetProxyForUrl( _
            AutoProxy_hSession, StrPtr(Url), AutoProxy_AutoProxyOptions, AutoProxy_ProxyInfo) > 0) Then

            AutoProxy_ProxyStringPtr = AutoProxy_ProxyInfo.AutoProxy_lpszProxy
        Else
            AutoProxy_Error = err.LastDllError
            Select Case AutoProxy_Error
            Case 12180
                AutoProxy_ErrorMsg = "WPAD detection failed"
                AutoProxy_Error = 10021
            Case 12167
                AutoProxy_ErrorMsg = "Unable to download proxy auto-config script"
                AutoProxy_Error = 10022
            Case 12166
                AutoProxy_ErrorMsg = "Error in proxy auto-config script"
                AutoProxy_Error = 10023
            Case 12178
                AutoProxy_ErrorMsg = "No proxy can be located for the specified URL"
                AutoProxy_Error = 10024
            Case 12005, 12006
                AutoProxy_ErrorMsg = "Specified URL is not valid"
                AutoProxy_Error = 10025
            Case Else
                AutoProxy_ErrorMsg = "Unknown error while detecting proxy"
                AutoProxy_Error = 10020
            End Select
        End If

        AutoProxy_HttpClose AutoProxy_hSession
        AutoProxy_hSession = 0
    End If

AutoProxy_TryIEFallback:
    On Error GoTo AutoProxy_Cleanup

    ' If we don't have a proxy server from WinHttpGetProxyForUrl,
    ' then pick one up from the IE proxy config (if given)
    If (AutoProxy_ProxyStringPtr = 0) Then
        AutoProxy_ProxyStringPtr = AutoProxy_IEProxyConfig.AutoProxy_lpszProxy
    End If

    ' If there's a proxy string, convert it to a Basic string
    If (AutoProxy_ProxyStringPtr <> 0) Then
        AutoProxy_ptr = AutoProxy_SysAllocString(AutoProxy_ProxyStringPtr)
        AutoProxy_CopyMemory VarPtr(ProxyServer), VarPtr(AutoProxy_ptr), 4
    End If

    ' Pick up any bypass string from the IEProxyConfig
    If (AutoProxy_IEProxyConfig.AutoProxy_lpszProxyBypass <> 0) Then
        AutoProxy_ptr = AutoProxy_SysAllocString(AutoProxy_IEProxyConfig.AutoProxy_lpszProxyBypass)
        AutoProxy_CopyMemory VarPtr(ProxyBypass), VarPtr(AutoProxy_ptr), 4
    End If

    ' Ensure WinHttp session is closed, an error might have occurred
    If (AutoProxy_hSession <> 0) Then
        AutoProxy_HttpClose AutoProxy_hSession
    End If

AutoProxy_Cleanup:
    On Error GoTo 0

    ' Free any strings received from WinHttp APIs
    If (AutoProxy_IEProxyConfig.AutoProxy_lpszAutoConfigUrl <> 0) Then
        AutoProxy_GlobalFree AutoProxy_IEProxyConfig.AutoProxy_lpszAutoConfigUrl
        AutoProxy_IEProxyConfig.AutoProxy_lpszAutoConfigUrl = 0
    End If
    If (AutoProxy_IEProxyConfig.AutoProxy_lpszProxy <> 0) Then
        AutoProxy_GlobalFree AutoProxy_IEProxyConfig.AutoProxy_lpszProxy
        AutoProxy_IEProxyConfig.AutoProxy_lpszProxy = 0
    End If
    If (AutoProxy_IEProxyConfig.AutoProxy_lpszProxyBypass <> 0) Then
        AutoProxy_GlobalFree AutoProxy_IEProxyConfig.AutoProxy_lpszProxyBypass
        AutoProxy_IEProxyConfig.AutoProxy_lpszProxyBypass = 0
    End If
    If (AutoProxy_ProxyInfo.AutoProxy_lpszProxy <> 0) Then
        AutoProxy_GlobalFree AutoProxy_ProxyInfo.AutoProxy_lpszProxy
        AutoProxy_ProxyInfo.AutoProxy_lpszProxy = 0
    End If
    If (AutoProxy_ProxyInfo.AutoProxy_lpszProxyBypass <> 0) Then
        AutoProxy_GlobalFree AutoProxy_ProxyInfo.AutoProxy_lpszProxyBypass
        AutoProxy_ProxyInfo.AutoProxy_lpszProxyBypass = 0
    End If

    ' Error handling
    If err.Number <> 0 Then
        ' Unmanaged error
        err.Raise err.Number, "AutoProxy:" & err.source, err.Description, err.HelpFile, err.HelpContext
    ElseIf AutoProxy_Error <> 0 Then
        err.Raise AutoProxy_Error, "AutoProxy", AutoProxy_ErrorMsg
    End If
#End If
End Sub
Attribute VB_Name = "WebRequest"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''
' WebRequest v4.1.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-Web
'
' `WebRequest` is used to create detailed requests
' (including formatting, querystrings, headers, cookies, and much more).
'
' Usage:
' ```VB.net
' Dim Request As New WebRequest
' Request.Resource = "users/{Id}"
'
' Request.Method = WebMethod.HttpPut
' Request.RequestFormat = WebFormat.UrlEncoded
' Request.ResponseFormat = WebFormat.Json
'
' Dim Body As New Dictionary
' Body.Add "name", "Tim"
' Body.Add "project", "VBA-Web"
' Set Request.Body = Body
'
' Request.AddUrlSegment "Id", 123
' Request.AddQuerystringParam "api_key", "abcd"
' Request.AddHeader "Authorization", "Token ..."
'
' ' -> PUT (Client.BaseUrl)users/123?api_key=abcd
' '    Authorization: Token ...
' '
' '    name=Tim&project=VBA-Web
' ```
'
' Errors:
' 11020 / 80042b0c / -2147210484 - Cannot add body parameter to non-Dictionary
'
' @class WebRequest
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' --------------------------------------------- '
' Constants and Private Variables
' --------------------------------------------- '

Private web_pRequestFormat As WebFormat
Private web_pResponseFormat As WebFormat
Private web_pCustomRequestFormat As String
Private web_pCustomResponseFormat As String
Private web_pBody As Variant
Private web_pConvertedBody As Variant
Private web_pContentType As String
Private web_pAccept As String
Private web_pContentLength As Long
Private web_pId As String

' --------------------------------------------- '
' Properties
' --------------------------------------------- '

''
' Set the request's portion of the url to be appended to the client's BaseUrl.
' Can include Url Segments for dynamic values
' and Querystring parameters are smart enough to be appended to existing querystring
' (or added to resource if there isn't an existing querystring).
'
' @example
' ```VB.net
' Dim Client As New WebClient
' Client.BaseUrl = "https://api.example.com/"
'
' Dim Request As New WebRequest
' Request.Resource = "messages"
'
' ' -> Url: https://api.example.com/messages
'
' Request.Resource = "messages/{id}?a=1"
' Request.AddUrlSegment "id", 123
' Request.AddQuerystringParam "b", 2
'
' ' -> Url: https://api.example.com/messages/123?a=1&b=2
' ```
'
' @property Resource
' @type String
''
Public Resource As String

''
' Set the HTTP method to be used for the request:
' GET, POST, PUT, PATCH, DELETE
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Method = WebMethod.HttpGet
' Request.Method = WebMethod.HttpPost
' ' or HttpPut / HttpPatch / HttpDelete
' ```
'
' @property Method
' @type WebMethod
''
Public Method As WebMethod

''
' _Note_ To add headers, use [`AddHeader`](#/WebRequest/AddHeader).
'
' `Collection` of Headers to include with request,
' stored as `KeyValue` (`Dictionary: {Key: "...", Value: "..."}`).
'
' @property Headers
' @type Collection
''
Public Headers As Collection

''
' _Note_ To add querystring parameters, use [`AddQuerystringParam`](#/WebRequest/AddQuerystringParam).
'
' `Collection` of querystring parameters to include with request,
' stored as `KeyValue` (`Dictionary: {Key: "...", Value: "..."}`).
'
' @property QuerystringParams
' @type Collection
''
Public QuerystringParams As Collection

''
' _Note_ To add Url Segments, use [`AddUrlSegment`](#/WebRequest/AddUrlSegment)
'
' Url Segments are used to easily add dynamic values to `Resource`.
' Create a Url Segement in `Resource` with curly brackets and then
' replace with dynamic value with [`AddUrlSegment`](#AddUrlSegment).
'
' @example
' ```VB.net
' Dim Request As New WebRequest
'
' Dim User As String
' Dim Id As Long
' User = "Tim"
' Id = 123
'
' ' OK: Use string concatenation for dynamic values
' Request.Resource = User & "/messages/" & Id
'
' ' BETTER: Use Url Segments for dynamic values
' Request.Resource = "{User}/messages/{Id}"
' Request.AddUrlSegment "User", User
' Request.AddUrlSegment "Id", Id
'
' Request.FormattedResource ' = "Tim/messages/123"
' ```
'
' @property UrlSegments
' @type Dictionary
''
Public UrlSegments As Dictionary

''
' _Note_ To add cookies, use [`AddCookie`](#/WebRequest/AddCookie).
'
' `Collection` of cookies to include with request,
' stored as `KeyValue` (`Dictionary: {Key: "...", Value: "..."}`).
'
' @property Cookies
' @type Collection
''
Public Cookies As Collection

''
' User agent to use with request
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.UserAgent = "Mozilla/5.0"
'
' ' -> (Header) User-Agent: Mozilla/5.0
' ```
'
' @property UserAgent
' @type String
' @default "VBA-Web v#.#.# (https://github.com/VBA-tools/VBA-Web)"
''
Public UserAgent As String

''
' Set `RequestFormat`, `ResponseFormat`, and `Content-Type` and `Accept`
' headers for the `WebRequest`
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Format = WebFormat.Json
' ' -> Request.RequestFormat = WebFormat.Json
' '    Request.ResponseFormat = WebFormat.Json
' '    (Header) Content-Type: application/json
' '    (Header) Accept: application/json
' ```
'
' @property Format
' @type WebFormat
''
Public Property Get Format() As WebFormat
    Format = RequestFormat
End Property
Public Property Let Format(Value As WebFormat)
    Me.RequestFormat = Value
    Me.ResponseFormat = Value
End Property

''
' Set the format to use for converting the response `Body` to string and for the `Content-Type` header
'
' _Note_ If `WebFormat.Custom` is used, the [`CustomRequestFormat`](#/WebRequest/CustomRequestFormat) must be set.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Body = Array("A", "B", "C")
'
' Request.RequestFormat = WebFormat.Json
'
' ' -> (Header) Content-Type: application/json
' ' -> Convert Body to JSON string
' Request.Body ' = "["A","B","C"]"
' ```
'
' @property RequestFormat
' @type WebFormat
' @default WebFormat.Json
''
Public Property Get RequestFormat() As WebFormat
    RequestFormat = web_pRequestFormat
End Property
Public Property Let RequestFormat(Value As WebFormat)
    If Value <> web_pRequestFormat Then
        web_pRequestFormat = Value

        ' Clear cached converted body
        web_pConvertedBody = Empty
    End If
End Property

''
' Set the format to use for converting the response `Content` to `Data` and for the `Accept` header
'
' _Note_ If `WebFormat.Custom` is used, the [`CustomResponseFormat`](#/WebRequest/CustomResponseFormat) must be set.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.ResponseFormat = WebFormat.Json
'
' ' -> (Header) Accept: application/json
'
' Dim Response As WebResponse
' ' ... from Execute
' Response.Content = "{""message"":""Howdy!""}"
'
' ' -> Parse Content to JSON Dictionary
' Debug.Print Response.Data("message") ' -> "Howdy!"
' ```
'
' @property ResponseFormat
' @type WebFormat
' @default WebFormat.Json
''
Public Property Get ResponseFormat() As WebFormat
    ResponseFormat = web_pResponseFormat
End Property
Public Property Let ResponseFormat(Value As WebFormat)
    If Value <> web_pResponseFormat Then
        web_pResponseFormat = Value

        ' Clear cached converted body
        web_pConvertedBody = Empty
    End If
End Property

''
' Use converter registered with [`WebHelpers.RegisterConverter`](#/WebHelpers/RegisterConverter)
' to convert `Body` to string and set `Content-Type` header.
'
' (Automatically sets `RequestFormat` to `WebFormat.Custom`)
'
' @example
' ```VB.net
' WebHelpers.RegisterConverter "csv", "text/csv", "Module.ConvertToCsv", "Module.ParseCsv"
'
' Dim Request As New WebRequest
' Request.CustomRequestFormat = "csv"
'
' ' -> (Header) Content-Type: text/csv
' ' -> Body converted to string with Module.ConvertToCsv
' ```
'
' @property CustomRequestFormat
' @type String
''
Public Property Get CustomRequestFormat() As String
    CustomRequestFormat = web_pCustomRequestFormat
End Property
Public Property Let CustomRequestFormat(Value As String)
    If Value <> web_pCustomRequestFormat Then
        web_pCustomRequestFormat = Value

        ' Clear cached converted body
        web_pConvertedBody = Empty

        If Value <> "" Then
            web_pRequestFormat = WebFormat.Custom
        End If
    End If
End Property

''
' Use converter registered with [`WebHelpers.RegisterConverter`](#/WebHelpers/RegisterConverter)
' to convert the response `Content` to `Data` and set `Accept` header.
'
' (Automatically sets `ResponseFormat` to `WebFormat.Custom`)
'
' @example
' ```VB.net
' WebHelpers.RegisterConverter "csv", "text/csv", "Module.ConvertToCsv", "Module.ParseCsv"
'
' Dim Request As New WebRequest
' Request.CustomResponseFormat = "csv"
'
' ' -> (Header) Accept: text/csv
' ' -> WebResponse Content converted Data with Module.ParseCsv
' ```
'
' @property CustomResponseFormat
' @type String
''
Public Property Get CustomResponseFormat() As String
    CustomResponseFormat = web_pCustomResponseFormat
End Property
Public Property Let CustomResponseFormat(Value As String)
    If Value <> web_pCustomResponseFormat Then
        web_pCustomResponseFormat = Value

        ' Clear cached converted body
        web_pConvertedBody = Empty

        If Value <> "" Then
            ResponseFormat = WebFormat.Custom
        End If
    End If
End Property

''
' Set automatically from `RequestFormat` or `CustomRequestFormat`,
' but can be overriden to set `Content-Type` header for request.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.ContentType = "text/csv"
'
' ' -> (Header) Content-Type: text/csv
' ```
'
' @property ContentType
' @type String
' @default Media-type of request format
''
Public Property Get ContentType() As String
    If web_pContentType <> "" Then
        ContentType = web_pContentType
    Else
        ContentType = WebHelpers.FormatToMediaType(Me.RequestFormat, Me.CustomRequestFormat)
    End If
End Property
Public Property Let ContentType(Value As String)
    web_pContentType = Value
End Property

''
' Set automatically from `ResponseFormat` or `CustomResponseFormat`,
' but can be overriden to set `Accept` header for request.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Accept = "text/csv"
'
' ' -> (Header) Accept: text/csv
' ```
'
' @property Accept
' @type String
' @default Media-type of response format
''
Public Property Get Accept() As String
    If web_pAccept <> "" Then
        Accept = web_pAccept
    Else
        Accept = WebHelpers.FormatToMediaType(Me.ResponseFormat, Me.CustomResponseFormat)
    End If
End Property
Public Property Let Accept(Value As String)
    web_pAccept = Value
End Property

''
' Set automatically by length of `Body`,
' but can be overriden to set `Content-Length` header for request.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.ContentLength = 200
'
' ' -> (Header) Content-Length: 200
' ```
'
' @property ContentLength
' @type Long
' @default Length of `Body`
''
Public Property Get ContentLength() As Long
    If web_pContentLength >= 0 Then
        ContentLength = web_pContentLength
    Else
        ContentLength = Len(Me.Body)
    End If
End Property
Public Property Let ContentLength(Value As Long)
    web_pContentLength = Value
End Property

''
' - Get: Body value converted to string using `RequestFormat` or `CustomRequestFormat`
' - Let: Use `String` or `Array` for Body
' - Set: Use `Collection`, `Dictionary`, or `Object` for Body
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.RequestFormat = WebFormat.Json
'
' ' Let: String|Array
' Request.Body = "text"
' Debug.Print Request.Body ' -> "text"
'
' Request.Body = Array("A", "B", "C")
' Debug.Print Request.Body ' -> "["A","B","C"]"
'
' ' Set: Collection|Dictionary|Object
' Dim Body As Object
' Set Body = New Collection
' Body.Add "Howdy!"
' Set Request.Body = Body
' Debug.Print Request.Body ' -> "["Howdy!"]"
'
' Set Body = New Dictionary
' Body.Add "a", 123
' Body.Add "b", 456
' Set Request.Body = Body
' Debug.Print Request.Body ' -> "{"a":123,"b":456}"
' ```
'
' @property Body
' @type String|Array|Collection|Dictionary|Variant
''
Public Property Get Body() As Variant
    If Not VBA.IsEmpty(web_pBody) Then
        If VBA.VarType(web_pBody) = vbString Then
            Body = web_pBody
        ElseIf IsEmpty(web_pConvertedBody) Then
            ' Convert body and cache
            Body = WebHelpers.ConvertToFormat(web_pBody, Me.RequestFormat, Me.CustomRequestFormat)
            web_pConvertedBody = Body
        Else
            Body = web_pConvertedBody
        End If
    End If
End Property
Public Property Let Body(Value As Variant)
    web_pConvertedBody = Empty
    web_pBody = Value
End Property
Public Property Set Body(Value As Variant)
    web_pConvertedBody = Empty
    Set web_pBody = Value
End Property

''
' Get `Resource` with Url Segments replaced and Querystring added.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Resource = "examples/{Id}"
' Request.AddUrlSegment "Id", 123
' Request.AddQuerystringParam "message", "Hello"
'
' Debug.Print Request.FormattedResource ' -> "examples/123?message=Hello"
' ```
'
' @property FormattedResource
' @type String
''
Public Property Get FormattedResource() As String
    Dim web_Segment As Variant
    Dim web_Encoding As UrlEncodingMode

    FormattedResource = Me.Resource

    ' Replace url segments
    For Each web_Segment In Me.UrlSegments.Keys
        FormattedResource = VBA.Replace(FormattedResource, "{" & web_Segment & "}", WebHelpers.UrlEncode(Me.UrlSegments(web_Segment)))
    Next web_Segment

    ' Add querystring
    If Me.QuerystringParams.Count > 0 Then
        If VBA.InStr(FormattedResource, "?") <= 0 Then
            FormattedResource = FormattedResource & "?"
        Else
            FormattedResource = FormattedResource & "&"
        End If

        ' For querystrings, W3C defines form-urlencoded as the required encoding,
        ' but the treatment of space -> "+" (rather than "%20") can cause issues
        '
        ' If the request format is explicitly form-urlencoded, use FormUrlEncoding (space -> "+")
        ' otherwise, use subset of RFC 3986 and form-urlencoded that should work for both cases (space -> "%20")
        If Me.RequestFormat = WebFormat.FormUrlEncoded Then
            web_Encoding = UrlEncodingMode.FormUrlEncoding
        Else
            web_Encoding = UrlEncodingMode.QueryUrlEncoding
        End If
        FormattedResource = FormattedResource & WebHelpers.ConvertToUrlEncoded(Me.QuerystringParams, EncodingMode:=web_Encoding)
    End If
End Property

''
' @internal
' @property Id
' @type String
''
Public Property Get Id() As String
    If web_pId = "" Then: web_pId = WebHelpers.CreateNonce
    Id = web_pId
End Property

' ============================================= '
' Public Methods
' ============================================= '

''
' Add header to be sent with request.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.AddHeader "Authentication", "Bearer ..."
'
' ' -> (Header) Authorization: Bearer ...
' ```
'
' @method AddHeader
' @param {String} Key
' @param {Variant} Value
''
Public Sub AddHeader(Key As String, Value As Variant)
    Me.Headers.Add WebHelpers.CreateKeyValue(Key, Value)
End Sub

''
' Add/replace header to be sent with request.
' `SetHeader` should be used for headers that can only be included once with a request
' (e.g. Authorization, Content-Type, etc.).
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.AddHeader "Authorization", "A..."
' Request.AddHeader "Authorization", "B..."
'
' ' -> Headers:
' '    Authorization: A...
' '    Authorization: B...
'
' Request.SetHeader "Authorization", "C..."
'
' ' -> Headers:
' '    Authorization: C...
' ```
'
' @method SetHeader
' @param {String} Key
' @param {Variant} Value
''
Public Sub SetHeader(Key As String, Value As Variant)
    WebHelpers.AddOrReplaceInKeyValues Me.Headers, Key, Value
End Sub

''
' Url Segments are used to easily add dynamic values to `Resource`.
' Create a Url Segement in `Resource` with curly brackets and then
' replace with dynamic value with `AddUrlSegment`.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Dim User As String
' Dim Id As Long
'
' User = "Tim"
' Id = 123
'
' ' OK: Use string concatenation for dynamic values
' Request.Resource = User & "/messages/" & Id
'
' ' BETTER: Use Url Segments for dynamic values
' Request.Resource = "{User}/messages/{Id}"
' Request.AddUrlSegment "User", User
' Request.AddUrlSegment "Id", Id
'
' Debug.Print Request.FormattedResource ' > "Tim/messages/123"
' ```
'
' @method AddUrlSegment
' @param {String} Key
' @param {String} Value
''
Public Sub AddUrlSegment(Segment As String, Value As Variant)
    Me.UrlSegments.Item(Segment) = Value
End Sub

''
' Add querysting parameter to be used in `FormattedResource` for request.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Resource = "messages"
' Request.AddQuerystringParam "from", "Tim"
'
' Request.FormattedResource ' = "messages?from=Tim"
' ```
'
' @method AddQuerystringParam
' @param {String} Key
' @param {Variant} Value
''
Public Sub AddQuerystringParam(Key As String, Value As Variant)
    Me.QuerystringParams.Add WebHelpers.CreateKeyValue(Key, Value)
End Sub

''
' Add cookie to be sent with request.
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.AddCookie "a", "abc"
' Request.AddCookie "b", 123
'
' ' -> (Header) Cookie: a=abc; b=123;
' ```
'
' @method AddCookie
' @param {String} Key
' @param {Variant} Value
''
Public Sub AddCookie(Key As String, Value As Variant)
    Me.Cookies.Add WebHelpers.CreateKeyValue( _
        web_EncodeCookieName(Key), _
        WebHelpers.UrlEncode(Value, EncodingMode:=UrlEncodingMode.CookieUrlEncoding) _
    )
End Sub

''
' Add `Key-Value` to `Body`.
' `Body` must be a `Dictionary` (if it's an `Array` or `Collection` an error is thrown)
'
' @example
' ```VB.net
' Dim Request As New WebRequest
' Request.Format = WebFormat.Json
'
' Request.AddBodyParameter "a", 123
' Debug.Print Request.Body ' -> "{"a":123}"
'
' ' Can add parameters to existing Dictionary
' Dim Body As New Dictionary
' Body.Add "a", 123
'
' Set Request.Body = Body
' Request.AddBodyParameter "b", 456
'
' Debug.Print Request.Body ' -> "{"a":123,"b":456}"
' ```
'
' @method AddBodyParameter
' @param {Variant} Key
' @param {Variant} Value
' @throws 11020 / 80042b0c / -2147210484 - Cannot add body parameter to non-Dictionary
''
Public Sub AddBodyParameter(Key As Variant, Value As Variant)
    If VBA.IsEmpty(web_pBody) Then
        Set web_pBody = New Dictionary
    ElseIf Not TypeOf web_pBody Is Dictionary Then
        Dim web_ErrorDescription As String
        web_ErrorDescription = "Cannot add body parameter to non-Dictionary Body (existing Body must be of type Dictionary)"

        WebHelpers.LogError web_ErrorDescription, "WebRequest.AddBodyParameter", 11020 + vbObjectError
        err.Raise 11020 + vbObjectError, "WebRequest.AddBodyParameter", web_ErrorDescription
    End If

    If VBA.IsObject(Value) Then
        Set web_pBody(Key) = Value
    Else
        web_pBody(Key) = Value
    End If

    ' Clear cached converted body
    web_pConvertedBody = Empty
End Sub

''
' Prepare request for execution
'
' @internal
' @method Prepare
''
Public Sub Prepare()
    ' Add/replace general headers for request
    SetHeader "User-Agent", Me.UserAgent
    SetHeader "Content-Type", Me.ContentType
    SetHeader "Accept", Me.Accept
    SetHeader "Content-Length", VBA.CStr(Me.ContentLength)
End Sub

''
' Clone request
'
' @internal
' @method Clone
' @return {WebRequest}
''
Public Function Clone() As WebRequest
    Set Clone = New WebRequest

    ' Note: Clone underlying for properties with default values
    Clone.Resource = Me.Resource
    Clone.Method = Me.Method
    Clone.UserAgent = Me.UserAgent
    Clone.Accept = web_pAccept
    Clone.ContentType = web_pContentType
    Clone.ContentLength = web_pContentLength
    Clone.RequestFormat = Me.RequestFormat
    Clone.ResponseFormat = Me.ResponseFormat
    Clone.CustomRequestFormat = Me.CustomRequestFormat
    Clone.CustomResponseFormat = Me.CustomResponseFormat

    Set Clone.Headers = WebHelpers.CloneCollection(Me.Headers)
    Set Clone.QuerystringParams = WebHelpers.CloneCollection(Me.QuerystringParams)
    Set Clone.UrlSegments = WebHelpers.CloneDictionary(Me.UrlSegments)
    Set Clone.Cookies = WebHelpers.CloneCollection(Me.Cookies)

    If VBA.IsObject(web_pBody) Then
        Set Clone.Body = web_pBody
    Else
        Clone.Body = web_pBody
    End If
End Function

''
' Create WebRequest from options
'
' @method CreateFromOptions
' @param {Dictionary} Options
' @param {Collection} [Options.Headers] Collection of `KeyValue`
' @param {Collection} [Options.Cookies] Collection of `KeyValue`
' @param {Collection} [Options.QuerystringParams] Collection of `KeyValue`
' @param {Dictionary} [Options.UrlSegments]
''
Public Sub CreateFromOptions(Options As Dictionary)
    If Not Options Is Nothing Then
        If Options.Exists("Headers") Then
            Set Me.Headers = Options("Headers")
        End If
        If Options.Exists("Cookies") Then
            Set Me.Cookies = Options("Cookies")
        End If
        If Options.Exists("QuerystringParams") Then
            Set Me.QuerystringParams = Options("QuerystringParams")
        End If
        If Options.Exists("UrlSegments") Then
            Set Me.UrlSegments = Options("UrlSegments")
        End If
    End If
End Sub

' ============================================= '
' Private Functions
' ============================================= '

' Encode cookie name
'
' References:
' - RFC 6265 https://tools.ietf.org/html/rfc6265
Private Function web_EncodeCookieName(web_CookieName As Variant) As String
    Dim web_CookieVal As String
    Dim web_StringLen As Long

    web_CookieVal = VBA.CStr(web_CookieName)
    web_StringLen = VBA.Len(web_CookieVal)

    If web_StringLen > 0 Then
        Dim web_Result() As String
        Dim web_i As Long
        Dim web_CharCode As Integer
        Dim web_Char As String
        ReDim web_Result(web_StringLen)

        ' ALPHA / DIGIT / "!" / "#" / "$" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
        ' Note: "%" is allowed in spec, but is currently excluded due to parsing issues

        ' Loop through string characters
        For web_i = 1 To web_StringLen
            ' Get character and ascii code
            web_Char = VBA.Mid$(web_CookieVal, web_i, 1)
            web_CharCode = VBA.Asc(web_Char)

            Select Case web_CharCode
                Case 65 To 90, 97 To 122
                    ' ALPHA
                    web_Result(web_i) = web_Char
                Case 48 To 57
                    ' DIGIT
                    web_Result(web_i) = web_Char
                Case 33, 35, 36, 38, 39, 42, 43, 45, 46, 94, 95, 96, 124, 126
                    ' "!" / "#" / "$" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                    web_Result(web_i) = web_Char

                Case 0 To 15
                    web_Result(web_i) = "%0" & VBA.Hex(web_CharCode)
                Case Else
                    web_Result(web_i) = "%" & VBA.Hex(web_CharCode)
            End Select
        Next web_i

        web_EncodeCookieName = VBA.Join$(web_Result, "")
    End If
End Function

Private Sub Class_Initialize()
    ' Set default values
    Me.RequestFormat = WebFormat.Json
    Me.ResponseFormat = WebFormat.Json
    Me.UserAgent = WebUserAgent

    Set Me.Headers = New Collection
    Set Me.QuerystringParams = New Collection
    Set Me.UrlSegments = New Dictionary
    Set Me.Cookies = New Collection
    Me.ContentLength = -1
End Sub
Attribute VB_Name = "WebResponse"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''
' WebResponse v4.1.3
' (c) Tim Hall - https://github.com/VBA-tools/VBA-Web
'
' Wrapper for http/cURL responses that includes parsed Data based on WebRequest.ResponseFormat.
'
' Usage:
' ```VB.net
' Dim Response As WebResponse
' Set Response = Client.Execute(Request)
'
' If Response.StatusCode = WebStatusCode.Ok Then
'   ' Response.Headers, Response.Cookies
'   ' Response.Data -> Parsed Response.Content based on Request.ResponseFormat
'   ' Response.Body -> Raw response bytes
' Else
'   Debug.Print "Error: " & Response.StatusCode & " - " & Response.Content
' End If
' ```
'
' Errors:
' 11030 / 80042b16 / -2147210474 - Error creating from http
' 11031 / 80042b17 / -2147210473 - Error creating from cURL
' 11032 / 80042b18 / -2147210472 - Error extracting headers
'
' @class WebResponse
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

Private web_CrLf As String

' --------------------------------------------- '
' Properties
' --------------------------------------------- '

''
' Status code that the server returned (e.g. 200).
'
' @property StatusCode
' @type WebStatusCode
''
Public StatusCode As WebStatusCode

''
' Status string that the server returned (e.g. `404 -> "Not Found"`)
'
' @property StatusDescription
' @type String
''
Public StatusDescription As String

''
' Content string that the server returned.
'
' @property Content
' @type String
''
Public Content As String

''
' Raw bytes for the response.
'
' @property Body
' @type Byte()
''
Public Body As Variant

''
' Parsed `Content` or `Body` based on the `WebRequest.ResponseFormat`.
'
' @property Data
' @type Dictionary|Collection
''
Public Data As Object

''
' Headers that were included with the response.
' (`Collection` of `KeyValue`)
'
' @property Headers
' @type Collection
''
Public Headers As Collection

''
' Cookies that were included with the response.
' (`Collection` of `KeyValue`)
'
' @property Cookies
' @type Collection
''
Public Cookies As Collection

' ============================================= '
' Public Methods
' ============================================= '

''
' Helper for updating the response with the given updated response values.
' Useful for `ByRef` cases to update response in place.
'
' @method Update
' @param Updated {WebResponse} Updated `WebResponse` to pull updated values from
''
Public Sub Update(Updated As WebResponse)
    Me.StatusCode = Updated.StatusCode
    Me.StatusDescription = Updated.StatusDescription
    Me.Content = Updated.Content
    Me.Body = Updated.Body
    Set Me.Headers = Updated.Headers
    Set Me.Cookies = Updated.Cookies
    Set Me.Data = Updated.Data
End Sub

''
' Create response from http
'
' @internal
' @method CreateFromHttp
' @param {WebClient} Client
' @param {WebRequest} Request
' @param {WinHttpRequest} Http
' @throws 11030 / 80042b16 / -2147210474 - Error creating from http
''
Public Sub CreateFromHttp(client As WebClient, request As WebRequest, Http As Object)
    On Error GoTo web_ErrorHandling

    Me.StatusCode = Http.Status
    Me.StatusDescription = Http.StatusText
    Me.Content = Http.ResponseText
    Me.Body = Http.ResponseBody

    web_LoadValues Http.GetAllResponseHeaders, Me.Content, Me.Body, request

    Exit Sub

web_ErrorHandling:

    Dim web_ErrorDescription As String
    web_ErrorDescription = "An error occurred while creating response from http" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

    WebHelpers.LogError web_ErrorDescription, "WebResponse.CreateFromHttp", 11030 + vbObjectError
    err.Raise 11030 + vbObjectError, "WebResponse.CreateFromHttp", web_ErrorDescription
End Sub

''
' Create response from cURL
'
' @internal
' @method CreateFromCurl
' @param {WebClient} Client
' @param {WebRequest} Request
' @param {String} Result
' @throws 11031 / 80042b17 / -2147210473 - Error creating from cURL
''
Public Sub CreateFromCurl(client As WebClient, request As WebRequest, result As String)
    On Error GoTo web_ErrorHandling

    Dim web_Lines() As String

    web_Lines = VBA.Split(result, web_CrLf)

    Me.StatusCode = web_ExtractStatusFromCurlResponse(web_Lines)
    Me.StatusDescription = web_ExtractStatusTextFromCurlResponse(web_Lines)
    Me.Content = web_ExtractResponseTextFromCurlResponse(web_Lines)
    Me.Body = WebHelpers.StringToAnsiBytes(Me.Content)

    web_LoadValues web_ExtractHeadersFromCurlResponse(web_Lines), Me.Content, Me.Body, request

    Exit Sub

web_ErrorHandling:

    Dim web_ErrorDescription As String
    web_ErrorDescription = "An error occurred while creating response from cURL" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

    WebHelpers.LogError web_ErrorDescription, "WebResponse.CreateFromCurl", 11031 + vbObjectError
    err.Raise 11031 + vbObjectError, "WebResponse.CreateFromCurl", web_ErrorDescription
End Sub

''
' Extract headers from response headers
'
' @internal
' @method ExtractHeaders
' @param {String} ResponseHeaders
' @return {Collection} Headers
' @throws 11032 / 80042b18 / -2147210472 - Error extracting headers
''
Public Function ExtractHeaders(ResponseHeaders As String) As Collection
    On Error GoTo web_ErrorHandling

    Dim web_Lines As Variant
    Dim web_i As Integer
    Dim web_Headers As New Collection
    Dim web_Header As Dictionary
    Dim web_ColonPosition As Long
    Dim web_Multiline As Boolean

    web_Lines = VBA.Split(ResponseHeaders, web_CrLf)

    For web_i = LBound(web_Lines) To (UBound(web_Lines) + 1)
        If web_i > UBound(web_Lines) Then
            web_Headers.Add web_Header
        ElseIf web_Lines(web_i) <> "" Then
            web_ColonPosition = VBA.InStr(1, web_Lines(web_i), ":")
            If web_ColonPosition = 0 And Not web_Header Is Nothing Then
                ' Assume part of multi-line header
                web_Multiline = True
            ElseIf web_Multiline Then
                ' Close out multi-line string
                web_Multiline = False
                web_Headers.Add web_Header
            ElseIf Not web_Header Is Nothing Then
                ' Add previous header
                web_Headers.Add web_Header
            End If

            If Not web_Multiline Then
                Set web_Header = WebHelpers.CreateKeyValue( _
                    Key:=VBA.Trim(VBA.Mid$(web_Lines(web_i), 1, web_ColonPosition - 1)), _
                    Value:=VBA.Trim(VBA.Mid$(web_Lines(web_i), web_ColonPosition + 1, VBA.Len(web_Lines(web_i)))) _
                )
            Else
                web_Header("Value") = web_Header("Value") & web_CrLf & web_Lines(web_i)
            End If
        End If
    Next web_i

    Set ExtractHeaders = web_Headers
    Exit Function

web_ErrorHandling:

    Dim web_ErrorDescription As String
    web_ErrorDescription = "An error occurred while extracting headers" & vbNewLine & _
        err.Number & VBA.IIf(err.Number < 0, " (" & VBA.LCase$(VBA.Hex$(err.Number)) & ")", "") & ": " & err.Description

    WebHelpers.LogError web_ErrorDescription, "WebResponse.CreateFromCurl", 11032 + vbObjectError
    err.Raise 11032 + vbObjectError, "WebResponse.CreateFromCurl", web_ErrorDescription
End Function

''
' Extract cookies from response headers
'
' @internal
' @method ExtractCookies
' @param {Collection} Headers
' @return {Collection} Cookies
''
Public Function ExtractCookies(Headers As Collection) As Collection
    Dim web_Header As Dictionary
    Dim web_Cookie As String
    Dim web_Key As String
    Dim web_Value As String
    Dim web_Cookies As New Collection

    For Each web_Header In Headers
        If web_Header("Key") = "Set-Cookie" Then
            web_Cookie = web_Header("Value")
            If VBA.InStr(1, web_Cookie, "=") > 0 Then
                web_Key = VBA.Mid$(web_Cookie, 1, VBA.InStr(1, web_Cookie, "=") - 1)
                web_Value = VBA.Mid$(web_Cookie, VBA.InStr(1, web_Cookie, "=") + 1, VBA.Len(web_Cookie))

                ' Ignore text after semi-colon
                If VBA.InStr(1, web_Value, ";") > 0 Then
                    web_Value = VBA.Mid$(web_Value, 1, VBA.InStr(1, web_Value, ";") - 1)
                End If

                ' Ignore surrounding quotes
                If VBA.Left$(web_Value, 1) = """" Then
                    web_Value = VBA.Mid$(web_Value, 2, VBA.Len(web_Value) - 2)
                End If

                web_Cookies.Add WebHelpers.CreateKeyValue(web_Key, WebHelpers.UrlDecode(web_Value, PlusAsSpace:=False, EncodingMode:=UrlEncodingMode.CookieUrlEncoding))
            Else
                WebHelpers.LogWarning _
                    "Unrecognized cookie format: " & web_Cookie, "WebResponse.ExtractCookies"
            End If
        End If
    Next web_Header

    Set ExtractCookies = web_Cookies
End Function

' ============================================= '
' Private Functions
' ============================================= '

Private Sub web_LoadValues(web_Headers As String, web_Content As String, web_Body As Variant, web_Request As WebRequest)
    ' Convert content to data by format
    If web_Request.ResponseFormat <> WebFormat.PlainText Then
        On Error Resume Next
        Set Me.Data = _
            WebHelpers.ParseByFormat(web_Content, web_Request.ResponseFormat, web_Request.CustomResponseFormat, web_Body)

        If err.Number <> 0 Then
            WebHelpers.LogError err.Description, err.source, err.Number
            err.Clear
        End If
        On Error GoTo 0
    End If

    ' Extract headers
    Set Me.Headers = ExtractHeaders(web_Headers)

    ' Extract cookies
    Set Me.Cookies = ExtractCookies(Me.Headers)
End Sub

Private Function web_ExtractStatusFromCurlResponse(web_CurlResponseLines() As String) As Long
    Dim web_StatusLineParts() As String

    web_StatusLineParts = VBA.Split(web_CurlResponseLines(web_FindStatusLine(web_CurlResponseLines)), " ")
    web_ExtractStatusFromCurlResponse = VBA.CLng(web_StatusLineParts(1))
End Function

Private Function web_ExtractStatusTextFromCurlResponse(web_CurlResponseLines() As String) As String
    Dim web_StatusLineParts() As String
    Dim web_i As Long
    Dim web_StatusText As String

    web_StatusLineParts = VBA.Split(web_CurlResponseLines(web_FindStatusLine(web_CurlResponseLines)), " ", 3)
    web_ExtractStatusTextFromCurlResponse = web_StatusLineParts(2)
End Function

Private Function web_ExtractHeadersFromCurlResponse(web_CurlResponseLines() As String) As String
    Dim web_StatusLineIndex As Long
    Dim web_BlankLineIndex As Long
    Dim web_HeaderLines() As String
    Dim web_WriteIndex As Long
    Dim web_ReadIndex As Long

    ' Find status line and blank line before body
    web_StatusLineIndex = web_FindStatusLine(web_CurlResponseLines)
    web_BlankLineIndex = web_FindBlankLine(web_CurlResponseLines)

    ' Extract headers string
    ReDim web_HeaderLines(0 To web_BlankLineIndex - 2 - web_StatusLineIndex)

    web_WriteIndex = 0
    For web_ReadIndex = (web_StatusLineIndex + 1) To web_BlankLineIndex - 1
        web_HeaderLines(web_WriteIndex) = web_CurlResponseLines(web_ReadIndex)
        web_WriteIndex = web_WriteIndex + 1
    Next web_ReadIndex

    web_ExtractHeadersFromCurlResponse = VBA.Join$(web_HeaderLines, web_CrLf)
End Function

Private Function web_ExtractResponseTextFromCurlResponse(web_CurlResponseLines() As String) As String
    Dim web_BlankLineIndex As Long
    Dim web_BodyLines() As String
    Dim web_WriteIndex As Long
    Dim web_ReadIndex As Long

    ' Find blank line before body
    web_BlankLineIndex = web_FindBlankLine(web_CurlResponseLines)

    ' Extract body string
    ReDim web_BodyLines(0 To UBound(web_CurlResponseLines) - web_BlankLineIndex - 1)

    web_WriteIndex = 0
    For web_ReadIndex = web_BlankLineIndex + 1 To UBound(web_CurlResponseLines)
        web_BodyLines(web_WriteIndex) = web_CurlResponseLines(web_ReadIndex)
        web_WriteIndex = web_WriteIndex + 1
    Next web_ReadIndex

    web_ExtractResponseTextFromCurlResponse = VBA.Join$(web_BodyLines, web_CrLf)
End Function

Private Function web_FindStatusLine(web_CurlResponseLines() As String) As Long
    ' Special case for cURL: 100 Continue is included before final status code
    ' -> ignore 100 and find final status code (next non-100 status code)
    For web_FindStatusLine = LBound(web_CurlResponseLines) To UBound(web_CurlResponseLines)
        If VBA.Trim$(web_CurlResponseLines(web_FindStatusLine)) <> "" Then
            If VBA.Split(web_CurlResponseLines(web_FindStatusLine), " ")(1) <> "100" Then
                Exit Function
            End If
        End If
    Next web_FindStatusLine
End Function

Private Function web_FindBlankLine(web_CurlResponseLines() As String) As Long
    For web_FindBlankLine = (web_FindStatusLine(web_CurlResponseLines) + 1) To UBound(web_CurlResponseLines)
        If VBA.Trim$(web_CurlResponseLines(web_FindBlankLine)) = "" Then
            Exit Function
        End If
    Next web_FindBlankLine
End Function

Private Sub Class_Initialize()
    web_CrLf = VBA.Chr$(13) & VBA.Chr$(10)

    Set Headers = New Collection
    Set Cookies = New Collection
End Sub
Attribute VB_Name = "frmExport"
Attribute VB_Base = "0{66700D38-F6B9-4199-8BA6-4CA671B06192}{AA8D7C92-6EA2-407C-998F-35BBD4E584A4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cmdExportCancel_Click()

blnOK = False
Me.Hide

End Sub

Private Sub cmdExportOK_Click()

blnOK = True
Me.Hide

End Sub

Private Sub optExportTypeSequenceRunner_Click()

End Sub
Attribute VB_Name = "frmHandleComments"
Attribute VB_Base = "0{DF843932-2977-482C-B096-6C5FBEB7BDBE}{8F8D9982-712C-4799-BF48-16CCF79B63F9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub cmbCommentType_Change()
    cmdHandleCommentsOK.Enabled = cmbSubsystems.ListIndex > -1 And cmbCommentType.ListIndex > -1
End Sub

Private Sub cmbSubsystems_Change()
    cmdHandleCommentsOK.Enabled = cmbSubsystems.ListIndex > -1 And cmbCommentType.ListIndex > -1
End Sub

Private Sub cmdHandleCommentsCancel_Click()

blnOK = False
Me.Hide

End Sub

Private Sub cmdHandleCommentsOK_Click()

blnOK = True
Me.Hide

End Sub

Private Sub UserForm_Activate()

blnOK = False

End Sub

Public Sub ListSubsystems(strArr() As String, Optional blnNXE As Boolean = False)

If blnNXE Then
    strArr = Split( _
        "AL: Alignment|AM: Airmounts|CO2: CO2 drive laser|CT: Cont.&Temp Ctrl|DC: Dose Control|" & _
        "H2: IL: Illumination|ILIAS: ILIAS|" & _
        "LS: Level Sensor|ME: Metorlogy|OLT: Optics Lifetime|POB: Projection|" & _
        "RM: ReMa|RH: Reticle Handling|RS: Reticle Stage|" & _
        "SPM: Stage Position Meas.|SRC: Source|SY: System|TIS: Tr. Image Sensor|VS: Vacuum System|WH: Wafer Handling|WS: Wafer Stage", "|")
Else
    strArr = Split( _
        "AL: Alignment|AM: Airmounts|DC: Dose Control|IH: Immersion|IL: Illumination|IS: Image Sensor|" & _
        "LS: Level Sensor|ME: Metorlogy|PR: Projection|RH: Reticle Handling|RS: Reticle Stage|" & _
        "SPM: Stage Position Meas.|SY: System|WH: Wafer Handling|WP: Wafer Positioning", "|")
End If
        
End Sub


Attribute VB_Name = "frmSQRtoEPS"
Attribute VB_Base = "0{488DE1A0-0024-41A1-96C1-0FBEE0B1171C}{E4517684-150B-4029-BF22-242EB2F9C1B6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub cmdSQRtoEPSCancel_Click()

blnOK = False
Me.Hide

End Sub

Private Sub cmdSQRtoEPSTransfer_Click()

blnOK = True
Me.Hide

End Sub

Private Sub lstSQRtoEPS_Change()

CheckInput

End Sub

Private Sub CheckInput()

If cmbSQRtoEPS.Text <> "" And txtSQRtoEPSMachNr.Text <> "" And txtSQRtoEPSReason <> "" _
    And txtSQRtoEPSName <> "" And txtUser <> "" And txtPassword <> "" Then
    cmdSQRtoEPSTransfer.Enabled = True
Else
    cmdSQRtoEPSTransfer.Enabled = False
End If

End Sub

Private Sub txtPassword_Change()

CheckInput

End Sub

Private Sub txtSQRtoEPSMachNr_Change()

CheckInput

End Sub

Private Sub txtSQRtoEPSName_Change()

CheckInput

End Sub

Private Sub txtSQRtoEPSReason_Change()

CheckInput

End Sub

Private Sub txtUser_Change()

CheckInput

End Sub

Attribute VB_Name = "frmScenarioList"
Attribute VB_Base = "0{B5FABD5C-CC88-41B6-8B86-9361ABE442B2}{13C65869-3FC6-4B74-9C28-2EDAF5D8D527}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Attribute VB_Name = "frmSelectPartial"
Attribute VB_Base = "0{71C5CE97-C9CD-4674-B0B8-41A93C53B12B}{6ABED610-2D49-460C-9CA6-B99539782E03}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Private Sub chkSelectPartialFrom_Click()

lblSelectPartialFromState.Visible = Not chkSelectPartialFrom.Value
cmbSelectPartialFromState.Visible = Not chkSelectPartialFrom.Value
lblSelectPartialFromStep.Visible = cmbSelectPartialFromStep.Enabled And Not chkSelectPartialFrom.Value
cmbSelectPartialFromStep.Visible = cmbSelectPartialFromStep.Enabled And Not chkSelectPartialFrom.Value

End Sub

Private Sub chkSelectPartialTo_Click()

lblSelectPartialToState.Visible = Not chkSelectPartialTo.Value
cmbSelectPartialToState.Visible = Not chkSelectPartialTo.Value
lblSelectPartialToStep.Visible = cmbSelectPartialToStep.Enabled And Not chkSelectPartialTo.Value
cmbSelectPartialToStep.Visible = cmbSelectPartialToStep.Enabled And Not chkSelectPartialTo.Value

End Sub

Private Sub cmbSelectPartialFromState_Change()

Dim intCurRow As Integer
Dim strSheetname As String

strSheetname = Range("areversion").Worksheet.Name

' Update FromStep combo box
If cmbSelectPartialFromStep.Visible Then
    cmbSelectPartialFromStep.Clear
    intCurRow = FindSequenceRow(strSheetname, cmbSelectPartialFromState.Text) + 1
    While Worksheets(strSheetname).Cells(intCurRow, cTestIDCol) <> ""
        cmbSelectPartialFromStep.AddItem Worksheets(strSheetname).Cells(intCurRow, cTestNameCol)
        intCurRow = intCurRow + 1
    Wend
End If

' Update ToState combo box

End Sub

Private Sub cmbSelectPartialToState_Change()

Dim intCurRow As Integer
Dim strSheetname As String

strSheetname = Range("areversion").Worksheet.Name

' Update ToStep combo box
If cmbSelectPartialToStep.Visible Then
    cmbSelectPartialToStep.Clear
    intCurRow = FindSequenceRow(strSheetname, cmbSelectPartialToState.Text) + 1
    While Worksheets(strSheetname).Cells(intCurRow, cTestIDCol) <> ""
        cmbSelectPartialToStep.AddItem Worksheets(strSheetname).Cells(intCurRow, cTestNameCol)
        intCurRow = intCurRow + 1
    Wend
End If

End Sub

Private Sub cmdSelectPartialCancel_Click()

blnOK = False
Me.Hide

End Sub

Private Sub cmdSelectPartialOK_Click()

blnOK = True
Me.Hide

End Sub

Attribute VB_Name = "frmTextWindow"
Attribute VB_Base = "0{E7652413-5B3C-43D5-A2A3-AF7F23CF8D7F}{0183240E-6B04-490A-8CB2-B214339F937F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub closeButton_Click()

Unload Me

End Sub


Attribute VB_Name = "modARES"
Option Explicit

'--------------------------------------------------------------------------
' ARES Export Module
' (v0.1, Onno Hovers)
'
' ARES is an XML-based data exchange format designed to transfer procedure/plan
' information to other applications (notably, Sequence Runner).
'
' This module generates ARES based on Excel sheets.
'--------------------------------------------------------------------------

'--------------------------------------------------------------------------
' ARES module imported in ARE template.
'
' Output is a text file
'
' ARES updates can be copied into the code below.
'--------------------------------------------------------------------------

'-
' Exports the given worksheet to ARES-compatible XML
'
Public Sub ARESExport()
    Dim FileName As String
    
    If Not IsSheet("Source") Then
        MsgBox "Cannot create XML export file, source sheet is not found", vbOKOnly
        Exit Sub
    End If
    
    FileName = saveAs()
    If FileName <> "" Then
        createXML (FileName)
    End If
End Sub

'-
' Get the name of the XML file from the user
'
Private Function saveAs() As String
    Dim FileName As String
    Dim fd As FileDialog
    Dim fdf As FileDialogFilter
    Dim index As Long
    
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
        
    fd.AllowMultiSelect = False
    fd.InitialFileName = "*.xml"
    index = 0
    For Each fdf In fd.Filters
        If InStr(1, fdf.Extensions, "xml", vbTextCompare) > 0 Then
            fd.FilterIndex = index + 1
            Exit For
        End If
        index = index + 1
    Next
    fd.title = "Choose XML file to export to the Sequence Runner"
    fd.Show
    If fd.SelectedItems.Count > 0 Then
        FileName = fd.SelectedItems(1)
    Else
        FileName = ""
    End If

    Set fd = Nothing
    saveAs = FileName
End Function

'-
' Create the XML file from the worksheets
'
Private Sub createXML(FileName As String)
    Dim source As Worksheet
    Dim sheet As Worksheet
    Dim strSheetname As String
    Dim strPlatformType As String
    
    Dim myHeader As tHeaderRecord
    
    SetTemplateNameDir
    
    Set source = Workbooks(strTemplate).Worksheets("Source")
    Set sheet = Workbooks(strTemplate).Worksheets(ActiveSheet.Name)

    strSheetname = GetRecoverySheetName
    CreateHeader myHeader, ""
    
    Open FileName For Output As #1
    Print #1, "<?xml version=""1.0"" encoding=""UTF-8""?>"
    Print #1, "<ares xsi:noNamespaceSchemaLocation=""AresValidator1.0.xsd"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">"

' Process Source worksheet
    Dim sourceRow As Long
    Dim sourceLine As String
    Dim sourceFields() As String
    
    Dim areInput As String
    Dim areConfig As String
    Dim machineConfig As String
    
    For sourceRow = 1 To source.Rows.Count
        sourceLine = source.Cells(sourceRow, 1)
        If Left(sourceLine, 9) = "[INPUT]$$" Then
            sourceLine = Mid(sourceLine, 10)
            sourceFields = Split(sourceLine, "|")
            If sourceFields(0) = "RECOVERY" Then
                areInput = areInput & "    <recovery>" & encode(sourceFields(1)) & "</recovery>" & vbCrLf
            ElseIf sourceFields(0) = "SCENARIOS" Then
                areInput = areInput & "    <scenario>" & encode(sourceFields(1)) & "</scenario>" & vbCrLf
            ElseIf sourceFields(0) = "STATE" Then
                areInput = areInput & "    <state>" & encode(sourceFields(1)) & "</state>" & vbCrLf
            Else
                machineConfig = machineConfig & "    <item><key>" & encode(sourceFields(0)) & "</key><value>" & encode(sourceFields(1)) & "</value></item>" & vbCrLf
            End If
            
        ElseIf Left(sourceLine, 9) = "[INPUT]##" Then
            sourceLine = Mid(sourceLine, 10)
            If Left(sourceLine, 28) = "AUTOMATIC GENERATED RECOVERY" Then
                ' TODO
                sourceFields = Split(sourceLine, "[")
                sourceFields = Split(sourceFields(1), "]")
                areConfig = areConfig & "      <item><key>CREATION_USER</key><value>" & encode(sourceFields(0)) & "</value></item>" & vbCrLf
                areConfig = areConfig & "      <item><key>CREATION_DATE</key><value>" & encode(Mid(sourceFields(1), 5)) & "</value></item>" & vbCrLf
            Else
                sourceFields = Split(sourceLine, "|")
                If InStr(sourceLine, "GroupTest") = 0 And sourceFields(0) <> "Duration" Then
                    areConfig = areConfig & "      <item><key>" & encode(sourceFields(0)) & "</key><value>" & encode(sourceFields(1)) & "</value></item>" & vbCrLf
                End If
            End If
        ElseIf sourceLine = "" Then
            Exit For
        End If
    Next

    Print #1, _
        "  <header>" & vbCrLf & _
        "    <name>" & encode(CreateObject("Scripting.FileSystemObject").GetBaseName(FileName)) & "</name>" & vbCrLf & _
        areInput & _
        "    <areconfig>" & vbCrLf & areConfig & "    </areconfig>" & vbCrLf & _
        "  </header>" & vbCrLf & _
        "  <machineconfig>" & vbCrLf & machineConfig & "  </machineconfig>"

' Process Recovery worksheet
    Dim procedure As String
    Dim proctype As String
    Dim procUrl As String
    Dim urlfields() As String
    Dim field As Variant
    Dim moid As String
    Dim testName As String
    Dim executable As String
    Dim project As String
    Dim hyperlink As String
    Dim Key As String
    Dim sap As String
    Dim chucks As String
    Dim duration As String
    Dim totalDuration As Double
    Dim Parts As String
    Dim Tools As String
    Dim Group As String
    Dim runmode As String
    Dim scenarioChucks As Collection
    Dim strArr() As String
    Dim blnSourceProc As Boolean
    Dim lngHeaderRow As Long
    Dim lngStartRecRow As Long
    Dim lngLastSeqRow As Long
    
    Set scenarioChucks = getScenarioChucks()
    
    totalDuration = 0
    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    
    strArr = Split(Range("status"), " ")
    proctype = strArr(1)
    Print #1, "  <sequence>"
    For sourceRow = lngStartRecRow To lngLastSeqRow
        procedure = sheet.Cells(sourceRow, cProcedureNameCol)
        If procedure <> "" Then
'            proctype = GetProcedureType(procedure)
            If sheet.Cells(sourceRow, cProcedureNameCol).Hyperlinks.Count > 0 Then
                procUrl = sheet.Cells(sourceRow, cProcedureNameCol).Hyperlinks(1).Address
                urlfields = Split(procUrl, "&")
                For Each field In urlfields
                    If Left(field, 5) = "moid=" Then
                        moid = Mid(field, 6)
                    End If
                Next
            Else
                moid = ""
            End If
            blnSourceProc = (LCase(Left(procedure, 1)) = "g")
        End If
        testName = sheet.Cells(sourceRow, cTestNameCol)
        executable = sheet.Cells(sourceRow, cTestExecCol)
        project = sheet.Cells(sourceRow, cProjectCol)
        Key = sheet.Cells(sourceRow, cTestIDCol)
        sap = sheet.Cells(sourceRow, cSAPCol)
        chucks = sheet.Cells(sourceRow, cPerChuckCol)
        duration = sheet.Cells(sourceRow, cATimeCol)
        Parts = sheet.Cells(sourceRow, cPartsCol)
        Tools = sheet.Cells(sourceRow, cToolsCol)
        runmode = sheet.Cells(sourceRow, cStartModeCol)
        If procedure = "" And project = "" And Key = "" Then
            If testName = "" Then
                Exit For
            Else
                If Group <> "" Then
                    Print #1, "    </jobstep>"
                End If
                Group = testName
                Print #1, "    <jobstep>"
                Print #1, "      <name>" & encode(Group) & "</name>"
            End If
        ElseIf Key <> " " Then
            If Contains(scenarioChucks, Key) Then
                If chucks = "" Or Not scenarioChucks(Key) Then
                    chucks = "None"
                End If
            End If
            Select Case chucks
                Case "Chuck 1"
                    myHeader.ChuckSelection = "CHUCK_1"
                Case "Chuck 2"
                    myHeader.ChuckSelection = "CHUCK_2"
                Case "Both chucks"
                    myHeader.ChuckSelection = "BOTH_CHUCKS"
                    ' nothing
                Case Else
                    myHeader.ChuckSelection = "BOTH_CHUCKS"
                    chucks = "None"
            End Select
            If Parts = "No special parts needed." Then
                Parts = ""
            End If
            If Tools = "No special tools needed." Then
                Tools = ""
            End If
            Select Case runmode
                Case "M", "S"
                    runmode = "Manual"
                Case "A"
                    runmode = "Automatic"
                Case Else
                    runmode = "Default"
            End Select
            totalDuration = totalDuration + Val(duration)
            
            myHeader.Procedures = SetProcedureType(proctype)
'            myheader.ChuckSelection = chucks
            
            hyperlink = fnProcedureLink(strSheetname, moid, myHeader, (LCase(myHeader.ChuckSelection) <> "both chucks"), "", False, blnSourceProc)

            Print #1, "      <step>"
            PrintXml "        ", "title", testName
            PrintXml "        ", "module", project
            PrintXml "        ", "executable", executable
            PrintXml "        ", "sequence", Key
            PrintXml "        ", "duration", duration
            PrintXml "        ", "chuck", chucks
            PrintXml "        ", "runmode", runmode
            PrintXml "        ", "sap", sap
            PrintXml "        ", "parts", Parts
            PrintXml "        ", "tools", Tools
            PrintXml "        ", "procedure", procedure
            PrintXml "        ", "hyperlink", hyperlink
'            PrintXml "        ", "proctype", proctype
'            PrintXml "        ", "moid", moid
            Print #1, "      </step>"
        End If
    Next
    If Group <> "" Then
        Print #1, "    </jobstep>"
    End If
    Print #1, "    <duration>" & encodeTotalDuration(totalDuration) & "</duration>"
    Print #1, "  </sequence>"
    Print #1, "</ares>"
    Close #1
End Sub

Private Sub PrintXml(indent As String, tag As String, Value As String)
    If Value <> "" Then
        Print #1, indent & "<" & tag & ">" & encode(Value) & "</" & tag & ">"
    Else
        Print #1, indent & "<" & tag & "/>"
    End If
End Sub


Private Function encodeTotalDuration(duration As Double) As String
    Dim minutes As Long
    Dim hours As Long
    minutes = CLng(duration)
    hours = minutes / 60
    minutes = minutes Mod 60
    encodeTotalDuration = hours & "h " & minutes & "m"
End Function
'-
' Encode a number of nasty characters for XML
Private Function encode(inp As String) As String
    inp = Replace(inp, "&", "&amp;")
    inp = Replace(inp, "<", "&lt;")
    inp = Replace(inp, ">", "&gt;")
    inp = Replace(inp, "'", "&apos;")
    inp = Replace(inp, """", "&quot;")
    encode = inp
End Function


'-
' Get a collection with procedures with automated mapping
' And if they take a chuck parameter
' FIXME: ARE should deliver this data as 'None' Chucks
Private Function getScenarioChucks() As Collection
    Dim result As New Collection
    result.Add Key:="AM_MASA", Item:=False
    result.Add Key:="IH_HIBO_1", Item:=False
    result.Add Key:="IH_HIBO_2", Item:=False
    result.Add Key:="IH_HIBO_3", Item:=False
    result.Add Key:="IH_HICR_FOCUS", Item:=False
    result.Add Key:="IH_HICR_LBC", Item:=False
    result.Add Key:="IH_HIHM_0", Item:=False
    result.Add Key:="IH_HIHM_2", Item:=False
    result.Add Key:="IH_HIHM_3_COARSE", Item:=False
    result.Add Key:="IH_HIHM_3_FINE", Item:=False
    result.Add Key:="IH_HIHS_DRY", Item:=False
    result.Add Key:="IH_HIHS_WET", Item:=False
    result.Add Key:="IH_HIHS_DEFAULT", Item:=False
    result.Add Key:="IH_HIRO_DEFAULT", Item:=False
    result.Add Key:="IH_HIRO_MANUAL", Item:=False
    result.Add Key:="RS_QRDC_FINAL", Item:=False
    result.Add Key:="RS_QRDC_GAIN", Item:=False
    result.Add Key:="RS_QRDC_INITIAL", Item:=False
    result.Add Key:="SPM_ENAR", Item:=True
    result.Add Key:="SPM_ENHO", Item:=False
    result.Add Key:="SPM_ENHO_PASSAGE", Item:=True
    result.Add Key:="SPM_ENIR_COURSE", Item:=True
    result.Add Key:="SPM_ENIR_FINE_EXP_FULL", Item:=True
    result.Add Key:="SPM_ENIR_FINE_MEA", Item:=True
    result.Add Key:="SPM_ENTR_INITIAL", Item:=True
    result.Add Key:="SPM_IMGC", Item:=True
    result.Add Key:="SPM_IMGZ", Item:=False
    result.Add Key:="WH_HWCR", Item:=False
    result.Add Key:="WH_HWCZ", Item:=False
    result.Add Key:="WP_PWCF_LA_COURSE", Item:=True
    result.Add Key:="WP_PWCF_LA_FINE", Item:=True
    result.Add Key:="WP_PWCF_LOS", Item:=True
    result.Add Key:="WP_PWCO_LA", Item:=True
    result.Add Key:="WP_PWCO_LA_LOS", Item:=True
    result.Add Key:="WP_PWCO_LOS_BMROT", Item:=True
    result.Add Key:="WP_PWCO_LOS", Item:=True
    result.Add Key:="WP_PWCR_BF", Item:=True
    result.Add Key:="WP_PWCR_LA2BM", Item:=True
    result.Add Key:="WP_PWCR_LA2BM_L", Item:=True
    result.Add Key:="WP_PWCR_LA2BM_R", Item:=True
    result.Add Key:="WP_PWCR_LOS_COMPLETE", Item:=True
    result.Add Key:="WP_PWCR_LOS2BF", Item:=True
    result.Add Key:="WP_PWCR_LOS2BF_L", Item:=True
    result.Add Key:="WP_PWCR_LOS2BF_R", Item:=True
    result.Add Key:="WP_PWCR_LOS2BM", Item:=True
    result.Add Key:="WP_PWCR_LOS2BM_L", Item:=True
    result.Add Key:="WP_PWCR_LOS2BM_R", Item:=True
    result.Add Key:="WP_PWCR_SPM", Item:=True
    result.Add Key:="WP_PWCR_SPM_EL", Item:=True
    result.Add Key:="WP_PWCR_SPM_ER", Item:=True
    result.Add Key:="WP_PWCR_SPM_ML", Item:=True
    result.Add Key:="WP_PWCR_SPM_MR", Item:=True
    result.Add Key:="WP_PWCR_SS2LOS", Item:=True
    result.Add Key:="WP_PWCR_SS2LOS_L", Item:=True
    result.Add Key:="WP_PWCR_SS2LOS_R", Item:=True
    result.Add Key:="WP_PWGL_LOS", Item:=True
    result.Add Key:="WP_PWLZ_1", Item:=True
    result.Add Key:="WP_PWLZ_2", Item:=True
    result.Add Key:="WP_PWLZ_3", Item:=True
    result.Add Key:="WP_PWLZ_4", Item:=True
    result.Add Key:="WP_PWLZ_5", Item:=True
    result.Add Key:="WP_PWLZ_6", Item:=True
    result.Add Key:="WP_PWLZ_7", Item:=True
    result.Add Key:="WP_PWMS_BM_END", Item:=False
    result.Add Key:="WP_PWMS_BM_GAIN", Item:=False
    result.Add Key:="WP_PWMS_BM0_LA0", Item:=False
    result.Add Key:="WP_PWMS_HOR", Item:=True
    result.Add Key:="WP_PWMS_RZ", Item:=True
    result.Add Key:="WP_PWMS_SS_GAIN", Item:=True
    result.Add Key:="WP_PWMS_VAL", Item:=False
    result.Add Key:="WP_PWMS_VER", Item:=True
    result.Add Key:="WP_PWRE_INIT", Item:=False
    result.Add Key:="WP_PWRE_SCAN", Item:=False
    result.Add Key:="WP_HIGH_SPEED", Item:=False
    result.Add Key:="WP_PWRO_LA", Item:=True
    result.Add Key:="WP_PWRO_LOS_COM", Item:=True
    result.Add Key:="WP_PWRO_LOS_GB", Item:=True
    result.Add Key:="WP_LOW_SPEED", Item:=False
    result.Add Key:="WP_PWRO_PM", Item:=True
    result.Add Key:="WP_PWRO_SS", Item:=True
    result.Add Key:="WP_PWRO_Z", Item:=True
    Set getScenarioChucks = result
End Function


'-
' Check if the collection contains an item
Public Function Contains(col As Collection, Key As Variant) As Boolean
Dim Obj As Variant
On Error GoTo err
    Contains = True
    Obj = col(Key)
    Exit Function
err:

    Contains = False
End Function


Attribute VB_Name = "modAREX"
Option Explicit

'--------------------------------------------------------------------------
' AREX Export Module
' (v0.1, Rico Huijbers)
' (v0.2, Modifications TBoo)
'
' AREX is an XML-based data exchange format designed to transfer procedure/plan
' information to other applications (notably, MPT).
'
' This module generates AREX based on Excel sheets. It is currently designed
' to support both SMT and ARE export worksheets.
'
' changes in v0.2
' * removed sub export. Not needed.
' * renamed getColumn (existed already) to getColumnContent
' * adapted code to allow conversion of Sequence sheet
' * added procedure type tag, SW release tag, machine type tag, exec tag
' * replaced isProcedure function by isSequenceStep function
' * added function ShowMachineCfg
'--------------------------------------------------------------------------

'--------------------------------------------------------------------------
' AREX module imported in ARE template.
'
' Output is the full text string, which is shown in a form (when
' using SMT) or in a text file (when using the exported sheet)
'
' AREX updates can be copied into the code below.
'--------------------------------------------------------------------------

'-
' Converts the given worksheet to AREX-compatible XML
'
Public Function convert(sheet As Worksheet, rng As Range, _
    strMinCol As String, strMaxCol As String, _
    strMachineType As String, strMachineCfg As String, strSWRelease As String, _
    strProcSheet As String, intProcColID As Integer) As String

' This is the function that outputs the XML content
' v0.2 added rng, min and max col ID and strMachineCfg as arguments

    Dim extent As Object
    
    Set extent = CreateObject("Scripting.Dictionary")

    determineSheetExtent sheet, extent, rng
' v0.2 added rng, min and max col ID and strMachineCfg as arguments
    convert = convertTable(sheet, extent, strMinCol, _
        strMaxCol, strMachineType, strMachineCfg, strSWRelease, strProcSheet, intProcColID)
End Function

'-
' Determine the location of various important columns in the table, and the
' row where the data starts.
'
' The columns are expected to be in either row 9 or row 10
'
Private Sub determineSheetExtent(sheet As Worksheet, extent As Object, rng As Range)
' v0.2 Added: rng as argument to this sub
    
    findColumn rng, "Procedure", extent
    findColumn rng, "Exec.", extent
    findColumn rng, "Test", extent
    findColumn rng, "Key", extent
    findColumn rng, "Expected", extent
    findColumn rng, "A-Time", extent
    findColumn rng, "Project", extent
    findColumn rng, "Iter.", extent
    findColumn rng, "Per chuck", extent
    findColumn rng, "Explanation", extent
    
    If Not extent.Exists("Procedure") Then err.Raise 1, Description:= _
        sheet & " does not appear to be an SMT or ARE export sheet. " & _
        "Cannot find the 'Procedure' column in the header row. " & _
        "Please execute on an appropriate worksheet or adapt the code if the worksheet has changed."
        
    extent.Add "StartRow", extent.Item("Procedure").row + 1
End Sub

Private Sub findColumn(SearchRange As Range, columnName As String, extent As Object)
    Dim r As Range
    Set r = SearchRange.Find(columnName, LookIn:=xlValues, Lookat:=xlWhole, MatchCase:=False, SearchOrder:=xlByRows)
    If r Is Nothing Then
        Set r = SearchRange.Find(columnName, LookIn:=xlValues, Lookat:=xlPart, MatchCase:=False, SearchOrder:=xlByRows)
    End If
    If Not r Is Nothing Then
        extent.Add columnName, r
    End If
End Sub

'-
' Returns whether the given range appears to contain data
Private Function containsData(rng As Range) As Boolean
    containsData = firstValue(rng) <> ""
End Function

'-
' Returns the first piece of data in the range
Private Function firstValue(rng As Range) As String
    Dim cell As Range
    For Each cell In rng
        If cell.Value <> "" Then firstValue = cell.Value: Exit Function
    Next
    firstValue = ""
End Function

'-
' Walks the worksheet and formats the rows as AREX <group> or <step> tags
'
Private Function convertTable(sheet As Worksheet, extent As Object, _
    strMinCol As String, strMaxCol As String, _
    strMachineType As String, strMachineCfg As String, strSWRelease As String, _
    strProcSheet As String, intProcColID As Integer) As String
    
    Dim ret As String
    ret = "<arex>" & vbCrLf

' v0.3 moved machinf cfg to XML "header"
    ret = ret & "  <machineconfig>" & vbCrLf & _
        "    <machinetype>" & encode(strMachineType) & "</machinetype>" & _
        ShowMachineCfg(encode(strMachineCfg)) & vbCrLf & _
        "  </machineconfig>" & vbCrLf & _
        "  <sw-release>" & encode(strSWRelease) & "</sw-release>" & vbCrLf

' v0.2 changed type of rowNr from integer to long
    Dim rowNr As Long, inGroup As Boolean
    Dim lngHeaderRow As Long
    Dim lngStartRecRow As Long
    Dim lngLastSeqRow As Long
    Dim strSheetname As String
    
    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    rowNr = lngStartRecRow
    
    ' Try at least 10 rows before giving up (there may be empty starting rows on the AREX sheet)
    While containsData(sheet.Range(strMinCol & rowNr & ":" & strMaxCol & rowNr)) Or rowNr <= lngStartRecRow + 10
        Dim row As Range
        Set row = sheet.Rows(rowNr)
        
' v0.2 Use IsSequenceStep rather than IsProcedure
'        If isProcedure(row, extent) Then
        If isSequenceStep(row, extent) Then
            ret = ret & arexStep(row, extent, strProcSheet, intProcColID)
        Else
            ' May be a group, or may be nothing
            Dim groupTitle As String
            groupTitle = firstValue(sheet.Range(strMinCol & rowNr & ":" & strMaxCol & rowNr))
            If groupTitle <> "" Then
                If inGroup Then ret = ret & "</group>" & vbCrLf
                inGroup = False
                
                ret = ret & "<group><name>" & encode(groupTitle) & "</name>" & vbCrLf
                
                inGroup = True
            End If
        End If
        
        rowNr = rowNr + 1
    Wend
    
    If inGroup Then ret = ret & "</group>" & vbCrLf
    
    ret = ret & "</arex>"

    convertTable = ret
End Function

'-
' Returns whether the given row is a procedure. It's a procedure if the
' procedure column is filled.
Private Function isProcedure(row As Range, extent As Object)
    isProcedure = getColumnContent(row, "Procedure", extent) <> ""
End Function

' v0.2 added function isSequenceStep
Private Function isSequenceStep(row As Range, extent As Object)

isSequenceStep = ( _
    getColumnContent(row, "Procedure", extent) <> "" Or _
    getColumnContent(row, "Description", extent) <> "")
    
End Function

Private Function arexStep(row As Range, extent As Object, _
        strProcSheet As String, intProcColID As Integer)
    
' v0.2 added machine type, configuration and SW release as arguments
    
    Dim title As String, module As String, procedure As String, time As String
    Dim repetitions As String
    Dim strProcType As String
    Dim strExec As String
    Dim strCfg As String
    Dim strExpl As String

    
    procedure = getColumnContent(row, "Procedure", extent)
    strProcType = GetProcedureType(Worksheets(strProcSheet).Cells(row.row, intProcColID))
            
    strExec = getColumnContent(row, "Exec.", extent)
    title = getColumnContent(row, "Test", extent) & getColumnContent(row, "Description", extent)
    module = getColumnContent(row, "Project", extent)
    time = getColumnContent(row, "Expected", extent) ' & getColumnContent(row, "A-Time", extent)
    repetitions = 1
    strCfg = getColumnContent(row, "Per chuck", extent)
    strExpl = getColumnContent(row, "Explanation", extent)
    
    arexStep = _
        "<step>" & vbCrLf & _
        "  <title>" & encode(title) & "</title>" & vbCrLf & _
        "  <module>" & encode(module) & "</module>" & vbCrLf & _
        "  <proceduretype>" & strProcType & "</proceduretype>" & vbCrLf & _
        "  <executable>" & encode(strExec) & "</executable>" & vbCrLf & _
        "  <cs-procedure>" & encode(procedure) & "</cs-procedure>" & vbCrLf & _
        "  <cs-time>" & encode(time) & "</cs-time>" & vbCrLf & _
        "  <repetitions>" & encode(repetitions) & "</repetitions>" & vbCrLf & _
        "  <configuration>" & encode(strCfg) & "</configuration>" & vbCrLf & _
        "  <explanation>" & encode(strExpl) & "</explanation>" & vbCrLf & _
        "</step>" & vbCrLf
        
End Function

' v0.2 renamed getColumn (name already used) to getColumnContent
Private Function getColumnContent(row As Range, columnName As String, extent As Object)
    If extent.Exists(columnName) Then
        Dim header As Range
        Set header = extent.Item(columnName)
        getColumnContent = row.Columns(header.Column).Value
    Else
        getColumnContent = ""
    End If
End Function

'-
' Encode a number of nasty characters for XML
Private Function encode(inp As String) As String
    inp = Replace(inp, "&", "&amp;")
    inp = Replace(inp, "<", "&lt;")
    inp = Replace(inp, ">", "&gt;")
    encode = inp
End Function

Public Function CoachMachineType(strMachineType As String) As String

' CoachMachineType = Trim(Replace(Replace(Replace(strMachineType, ":", "_"), "IV", ""), "I", ""))
CoachMachineType = Trim(Replace(Replace(strMachineType, "NT1", "NXT"), "-", "_"))

End Function

Public Function CoachSWRelease(strSWRelease As String) As String

Dim strTmpTxt As String

If InStr(strSWRelease, " ") > 0 Then
    strTmpTxt = Left(strSWRelease, InStr(strSWRelease, " ") - 1)
Else
    strTmpTxt = strSWRelease
End If

CoachSWRelease = Trim(Replace(strTmpTxt, "R", ""))

End Function

Public Function GetProcedureType(strProcedure As String) As String

Select Case Left(strProcedure, 2)
    Case Is = "ct"
        GetProcedureType = "Test"
    Case Is = "ci"
        GetProcedureType = "Install"
    Case Is = "cs"
        GetProcedureType = "Service"
    Case Else
        GetProcedureType = "Unknown"
End Select

End Function

Public Function ProcedureLink(strInvTxt As String, strMachineType As String, _
    strSWRelease As String, Optional blnUseLocalCoach As Boolean = False, _
    Optional blnUseCoach5 As Boolean = True)

' This function has become obsolete

Dim strProcTmp As String
Dim strProcType As String
Dim blnValidLink As Boolean

blnValidLink = True

strProcTmp = strInvTxt

If InStr(strProcTmp, " ") > 0 Then
    strProcTmp = Left(strProcTmp, InStr(strProcTmp, " ") - 1)
End If
    
If InStr(strProcTmp, ",") > 0 Then
    strProcTmp = Left(strProcTmp, InStr(strProcTmp, ",") - 1)
End If

If Len(strProcTmp) > 2 And LCase(Left(strProcTmp, 1)) = "c" And InStr(strProcTmp, ".") > 0 Then

    If blnUseCoach5 Then
' linking to new coach
        Select Case Mid(strProcTmp, 2, 1)
        Case Is = "t"
            strProcType = "Test"
        Case Is = "s"
            strProcType = "Service"
        Case Is = "i"
            strProcType = "IntegrationInstall"
        Case Is = "f"
            strProcType = "Fasy"
            blnValidLink = blnValidLink And Not blnUseLocalCoach
        Case Is = "a"
            strProcType = "Assy"
            blnValidLink = blnValidLink And Not blnUseLocalCoach
        Case Else
            blnValidLink = False
        End Select
        
        strProcTmp = "c" + Mid(strProcTmp, 3)
        If blnUseLocalCoach Then
            ProcedureLink = _
            "http://localhost:8888/Coach/CoachAPI?rm=listproc&proc=" + strProcTmp + "&destinationList=" + strProcType + "&systemList=" + strMachineType + "&softwarelist=" + strSWRelease + "&optionlist=none"
        Else
            ProcedureLink = _
            "http://coach.asml.com/Coach/CoachAPI?rm=listproc&proc=" + strProcTmp + "&destinationList=" + strProcType + "&systemList=" + strMachineType + "&softwarelist=" + strSWRelease + "&optionlist=none"
        End If
        
    Else
        Select Case LCase(Left(strProcType, 1))
        Case Is = "t"
            strProcType = "test"
        Case Is = "s"
            strProcType = "proc"
        Case Is = "i"
            strProcType = "inst"
        Case Is = "f"
            strProcType = "fasy"
        Case Is = "a"
            strProcType = "assy"
        Case Else
        End Select
        
        ProcedureLink = _
            "http://netscanner.asml.com/nl018000/nonconf/coach/data/twinscan/DocFinder/" & strProcType & "/en/" & Replace(strProcTmp, ".", "_") & ".html"
    End If
Else
    blnValidLink = False
End If

End Function
    
Public Function ShowMachineCfg(strMachCfg As String) As String

' Split input string (divide along vbCrLf, then along :)

Dim intChrInd As Integer
Dim strCfgItem As String
Dim strCfgTxt As String
Dim strTmpTxt As String
Dim strCfgName As String
Dim strCfgVal As String

strCfgTxt = ""
strTmpTxt = strMachCfg
intChrInd = InStr(strTmpTxt, vbCrLf)
While intChrInd > 0
    strCfgItem = Left(strTmpTxt, intChrInd - 1)
    strTmpTxt = Mid(strTmpTxt, intChrInd + Len(vbCrLf))
    
    getCfgItem strCfgItem, strCfgName, strCfgVal
    strCfgTxt = strCfgTxt & vbCrLf & "    <" & strCfgName & ">" & strCfgVal & "</" & strCfgName & ">"
    intChrInd = InStr(strTmpTxt, vbCrLf)
Wend
getCfgItem strTmpTxt, strCfgName, strCfgVal
strCfgTxt = strCfgTxt & vbCrLf & "    <" & strCfgName & ">" & strCfgVal & "</" & strCfgName & ">"

ShowMachineCfg = strCfgTxt

End Function

Private Sub getCfgItem(strCfgItem As String, strCfgName As String, strCfgVal As String)

Dim intChrInd As Integer

intChrInd = InStr(strCfgItem, ":")

If intChrInd > 0 Then
    strCfgName = LCase(Left(strCfgItem, intChrInd - 1))
    strCfgVal = Mid(strCfgItem, intChrInd + 1)
Else
    strCfgName = LCase(strCfgItem)
    strCfgVal = ""
End If

End Sub
Attribute VB_Name = "modCOIExport"
Public Const strEmpty As String = """"""

Public Const cStatusCol As Integer = 1
Public Const cVacuumStateCol As Integer = 2
Public Const cProcedureNameCol As Integer = 3
Public Const cTestNameCol As Integer = 4
Public Const cCommentsProcedureCol As Integer = 5
Public Const cTestIDCol As Integer = 6
Public Const cPerChuckCol As Integer = 7
Public Const cATimeCol As Integer = 8
Public Const cStartModeCol As Integer = 9
Public Const cHasSubtestsCol As Integer = 10
Public Const cTestExecCol As Integer = 11
Public Const cProjectCol As Integer = 12
Public Const cTangoCol As Integer = 13
Public Const cSAPCol As Integer = 14
Public Const cPartsCol As Integer = 15
Public Const cToolsCol As Integer = 16
Public Const cEstimatedStartTimeCol As Integer = 17
Public Const cEstimatedEndTimeCol As Integer = 18
Public Const cCorrectedEndTimeCol As Integer = 19
Public Const cIdleTimeCol As Integer = 20
Public Const cActualStartTimeCol As Integer = 21
Public Const cActualFinishTimeCol As Integer = 22
Public Const cActualBTimeCol As Integer = 23
Public Const cOrgPlanFinishCol As Integer = 24
Public Const cBTimeCauseCol As Integer = 25
Public Const cSONumberCol As Integer = 26
Public Const cComments1stLineCol As Integer = 27
Public Const cTimeKeeperBalloonTitleCol As Integer = 28
Public Const cTimeKeeperDetailsCol As Integer = 29
Public Const cPercStepCol As Integer = 30
Public Const cPercCumCol As Integer = 31
Public Const cCumBTimeCol As Integer = 32
Public Const cSeqCheckCol As Integer = 33

Public Const cBTimeCauseListCol As Integer = 35

Public Const cSequenceHeaderStartCell As String = "C1"
Public Const cSequenceConfigCell As String = "D5"

Public Const cA2BHeaderCol As Integer = 20
Public Const cPlannedTimeCol As Integer = 21
Public Const cActualTimeCol As Integer = 22
Public Const cDelayCol As Integer = 23

Public Const cLegendRow As Integer = 2
Public Const cA2BHeaderRow As Integer = 4
Public Const cA2BFactorRow As Integer = 5
Public Const cStartTimeRow As Integer = 6
Public Const cEndTimeRow As Integer = 7
Public Const cWeekNrRow As Integer = 8

Public Const cUserInputCellColor As Integer = 42
Public Const cCalculatedCellColor As Integer = 40

Public Const cBTimeCauseCellColor As Integer = 46

Public Const cNrSourceHeaderRows As Integer = 2

Public Const blnAllowDifferentProcedureType As Boolean = True

Public Const strCommentIndicator As String = " / Comments"
Public Const strCompareIndicator As String = " / Compare"

Public Const sngReductionSemiAutomatic As Single = 0.8
Public Const sngReductionAutomatic As Single = 0.3

'CSMan Hosts:
'Public Const strCSManHost As String = "ics106048023.ics-eu-1.asml.com"       'Dev
'Public Const strCSManHost As String = "ics106048024.ics-eu-1.asml.com"       'Test
Public Const strCSManHost As String = "ics106052151.ics-eu-1.asml.com"       'Acc
'Public Const strCSManHost As String = "ics106060030.ics-eu-2.asml.com"       'Prd

Public Sub TimeKeeperExport(Optional strSheetname As String = "Recovery")

' This routine formats the imported sequence and adds the excel formulae that
' are needed to allow time keeping of the recovery sequence

Dim strExportFile As String
Dim strExportSheet As String
Dim strSourceFile As String
Dim strSourceSheet As String
Dim strEmpty As String
Dim lngLastSeqRow As Long
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngMaxRow As Long ' including greyed out rows
Dim blnLocalCoach As Boolean

Dim strHeaderRange As String

WriteDebug "Start TimeKeeperExport"

' Check if breakpoint is activated
If ReadCfgFile("stop") = "timekeeperexport" Then
    ShowBreakpoint "TimeKeeperExport"
End If

If ReadCfgFile("showsimpleduration") = "true" Then
    blnShowDurationSimple = True
Else
    blnShowDurationSimple = False
End If

If ReadCfgFile("sqrduration") = "true" Then
    blnShowSQRDuration = True
Else
    blnShowSQRDuration = False
End If

SuspendScreenUpdates
    
' Determine sequence layout
WriteDebug "Determine sequence layout"
FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngMaxRow, False
WriteDebug "HeaderRow= " & lngHeaderRow & " Last row= " & lngLastSeqRow & " Max row=" & lngMaxRow

' Read file and sheet names
strSourceFile = ""
strSourceSheet = ActiveSheet.Name

strExportFile = ""
strExportSheet = ActiveSheet.Name
WriteDebug "Export sheet: " & strExportSheet

' Update header cells where applicable
WriteDebug "Update header cells"
UpdateHeader strExportSheet, lngHeaderRow, lngLastSeqRow
    
' Create column where status per procedure can be filled in
WriteDebug "SetStatusColumnValidationList"
SetStatusColumnValidationList strExportSheet, 1, cBTimeCauseCol

WriteDebug "CreateStatusColumn"
CreateStatusColumn strExportFile, strExportSheet, cStatusCol, lngHeaderRow, lngLastSeqRow

WriteDebug "SetHeaderRowFormat"
SetHeaderRowFormat lngHeaderRow

WriteDebug "CopySequenceFormatting"
CopySequenceFormatting strExportSheet, fRange(lngHeaderRow + 1, cTestIDCol, lngLastSeqRow, cTestIDCol), fRange(lngHeaderRow + 1, cStartModeCol, lngLastSeqRow, cCumBTimeCol)

WriteDebug "SetVacuumStateColumn"
SetVacuumStateColumn strExportSheet, cVacuumStateCol

WriteDebug "CreateColumnATime"
CreateColumnATime strExportSheet, lngHeaderRow, lngMaxRow, cATimeCol

WriteDebug "CreateColumnEstimatedStartTime"
CreateColumnEstimatedStartTime strExportSheet, lngHeaderRow, lngLastSeqRow, cEstimatedStartTimeCol

WriteDebug "CreateColumnEstimatedEndTime"
CreateColumnEstimatedEndTime strExportSheet, lngHeaderRow, lngLastSeqRow, cEstimatedEndTimeCol

WriteDebug "CreateColumnCorrectedEndTime"
CreateColumnCorrectedEndTime strExportSheet, lngHeaderRow, lngLastSeqRow, cCorrectedEndTimeCol

WriteDebug "CreateColumnIdleTime"
CreateColumnIdleTime strExportSheet, lngHeaderRow, lngLastSeqRow, cIdleTimeCol

WriteDebug "CreateColumnActualStart"
CreateColumnActualStart strExportSheet, lngHeaderRow, lngLastSeqRow, cActualStartTimeCol

WriteDebug "CreateColumnActualFinish"
CreateColumnActualFinish strExportSheet, lngHeaderRow, lngLastSeqRow, cActualFinishTimeCol

WriteDebug "CreateColumnActualBTime"
CreateColumnActualBTime strExportSheet, lngHeaderRow, lngLastSeqRow, cActualBTimeCol

WriteDebug "CreateColumnOrgPlanFinish"
CreateColumnOrgPlanFinish strExportSheet, lngHeaderRow, lngLastSeqRow, cOrgPlanFinishCol

WriteDebug "CreateColumnBTimeCause"
CreateColumnBTimeCause strExportSheet, lngHeaderRow, lngLastSeqRow, cBTimeCauseCol

WriteDebug "CreateColumnSONumber"
CreateColumnSONumber strExportSheet, lngHeaderRow, lngLastSeqRow, cSONumberCol

WriteDebug "CreateColumnCommentsProcedure"
CreateColumnCommentsProcedure strExportSheet, lngHeaderRow, lngLastSeqRow, cCommentsProcedureCol

WriteDebug "CreateColumnComments1stLine"
CreateColumnComments1stLine strExportSheet, lngHeaderRow, lngLastSeqRow, cComments1stLineCol

WriteDebug "CreateColumnTimeKeeperBalloonTitle"
CreateColumnTimeKeeperBalloonTitle strExportSheet, lngHeaderRow, lngLastSeqRow, cTimeKeeperBalloonTitleCol

WriteDebug "CreateColumnTimeKeeperDetailComments"
CreateColumnTimeKeeperDetailComments strExportSheet, lngHeaderRow, lngLastSeqRow, cTimeKeeperDetailsCol

WriteDebug "CreateColumnPercStep"
CreateColumnPercStep strExportSheet, lngHeaderRow, lngLastSeqRow, cPercStepCol

WriteDebug "CreateColumnPercCum"
CreateColumnPercCum strExportSheet, lngHeaderRow, lngLastSeqRow, cPercCumCol

WriteDebug "CreateColumnCumulativeBTime"
CreateColumnCumulativeBTime strExportSheet, lngHeaderRow, lngLastSeqRow, cCumBTimeCol

WriteDebug "SetBTimeCauseValidationList"
SetBTimeCauseValidationList strExportSheet, lngHeaderRow, cBTimeCauseCol

WriteDebug "CreateABTimeTable"
CreateABTimeTable strExportSheet, lngStartRecRow + 1, lngLastSeqRow

WriteDebug "HighlightUserInputCells"
HighlightUserInputCells strExportSheet, lngHeaderRow + 1, lngLastSeqRow

WriteDebug "HighlightAutoCalculationCells"
' HighlightAutoCalculationCells strExportSheet, lngHeaderRow + 1, lngLastSeqRow

WriteDebug "SetPartsToolsFormatting"
SetPartsToolsFormatting lngHeaderRow, lngLastSeqRow

Worksheets(strExportSheet).Range("A1").Select
    
' Copy formula to all sequence rows
WriteDebug "CopySequenceFormulae"
CopySequenceFormulae strExportSheet, lngHeaderRow + 1, cEstimatedStartTimeCol, lngLastSeqRow, cIdleTimeCol
CopySequenceFormulae strExportSheet, lngHeaderRow + 1, cActualBTimeCol, lngLastSeqRow, cOrgPlanFinishCol
CopySequenceFormulae strExportSheet, lngHeaderRow + 1, cBTimeCauseCol, lngLastSeqRow, cBTimeCauseCol, True
CopySequenceFormulae strExportSheet, lngHeaderRow + 1, cPercStepCol, lngLastSeqRow, cCumBTimeCol

WriteDebug "SetActualBTimeFormatting"
SetActualBTimeFormatting strExportSheet, lngStartRecRow, lngLastSeqRow

' Center columns where required
WriteDebug "Format sequence sheet"
Worksheets(strExportSheet).Range(fRange(lngHeaderRow, cATimeCol, lngMaxRow, cATimeCol)).Select
With Selection
    .HorizontalAlignment = xlCenter
    .VerticalAlignment = xlBottom
End With

Worksheets(strExportSheet).Range(fRange(lngHeaderRow, cEstimatedStartTimeCol, lngLastSeqRow, cOrgPlanFinishCol)).Select
With Selection
    .HorizontalAlignment = xlCenter
    .VerticalAlignment = xlBottom
End With

Worksheets(strExportSheet).Range(fRange(lngHeaderRow, cPercStepCol, lngLastSeqRow, cCumBTimeCol)).Select
With Selection
    .HorizontalAlignment = xlCenter
    .VerticalAlignment = xlBottom
End With

Worksheets(strExportSheet).Range(fRange(1, cA2BHeaderCol, CLng(cWeekNrRow), cDelayCol)).Select
With Selection
    .HorizontalAlignment = xlCenter
    .VerticalAlignment = xlBottom
End With

'Hide columns that shall - by default - not be visible to the user
WriteDebug "HideColumns"
HideColumn strExportSheet, cTestExecCol
HideColumn strExportSheet, cProjectCol
HideColumn strExportSheet, cTangoCol
HideColumn strExportSheet, cSAPCol
HideColumn strExportSheet, cPartsCol
HideColumn strExportSheet, cToolsCol
HideColumn strExportSheet, cHasSubtestsCol
HideColumn strExportSheet, cCorrectedEndTimeCol

HideColumn strExportSheet, cPercStepCol
HideColumn strExportSheet, cPercCumCol
HideColumn strExportSheet, cCumBTimeCol

'Set Hyperlinks range
WriteDebug "SetHyperlinks"
SetHyperlinkRange strExportSheet, lngHeaderRow + 1, lngLastSeqRow, cProcedureNameCol

'Set value for B-factor (default is 1.8)
If Len(Cells(cA2BFactorRow, cPlannedTimeCol).Text) = 0 Then
    sngBFactor = Val(ReadCfgFile("bfactor"))
Else
    sngBFactor = Val(Cells(cA2BFactorRow, cPlannedTimeCol).Text)
End If

If sngBFactor = 0 Then sngBFactor = 1.8

WriteDebug "Set B-factor=" & sngBFactor
Worksheets(strExportSheet).Range(fCell(cA2BFactorRow, cPlannedTimeCol)).Formula = sngBFactor

'Set nr of digits in "total expected time" cell
Dim strNrDigits As String

strNrDigits = ReadCfgFile("nrdigits")
If strNrDigits = "" Then
    intNrDigits = 1
Else
    intNrDigits = Val(strNrDigits)
End If

If intNrDigits <= 0 Then
    Worksheets(strExportSheet).Range("duration").NumberFormat = "0"
Else
    Worksheets(strExportSheet).Range("duration").NumberFormat = "0." & String(intNrDigits, "0")
End If

'Show grouped formatting of "sub" tests
HandleGroupedTests

Sheets(strExportSheet).Select
Range("A1").Select

'Hide source sheet (not visible by default to user, but can be made visible with CTRL+ALT+a)
If IsSheet("Source") Then
    WriteDebug "ShowOrHideSourceSheet"
    Sheets("Source").Visible = False
End If

'Done
ResumeScreenUpdates

End Sub

Private Sub SetHyperlinkRange(strExportSheet As String, lngMinRow As Long, lngMaxRow As Long, intColID As Integer)

' This routine names the range of cells where procedure hyperlinks are shown
On Error Resume Next

ActiveWorkbook.Names("Hyperlinks").Delete
ActiveWorkbook.Names.Add Name:="Hyperlinks", RefersTo:="=" & strExportSheet & "!" & fCell(lngMinRow, intColID, True, True) & ":" & fCell(lngMaxRow, intColID, True, True)

On Error GoTo 0

End Sub

Private Sub SetVacuumStateColumn(strExportSheet As String, intColID As Integer)

' The vacuum state column must be hidden if not an EUV machine
HideColumn strExportSheet, intColID, Not ShowVacuumStateColumn

End Sub

Private Sub SetCellHeaderFormat(strExportSheet As String, fRange As String, Optional strTitle As String = "")

' Sets the format of the header cells (deep blue fill color with white boldtyped font)
Worksheets(strExportSheet).Range(fRange).Select
With Selection
    With .Interior
        .ColorIndex = 49
    .Pattern = xlSolid
    End With
    With .Font
        .Name = "Arial"
        .Size = 10
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = 2
        .Bold = True
    End With
    .HorizontalAlignment = xlCenter
    .VerticalAlignment = xlCenter
    .WrapText = True
    .Orientation = 0
    .AddIndent = False
    .IndentLevel = 0
    .ShrinkToFit = False
    .ReadingOrder = xlContext
    .MergeCells = False
End With

If strTitle <> "" Then
    Worksheets(strExportSheet).Range(fRange) = strTitle
End If


End Sub

Private Sub SetCellBackColor(strExportSheet As String, fRange As String, _
    Optional intCellColor As Integer = 8)

' Sets cell back color
On Error Resume Next

With Worksheets(strExportSheet)
    .Range(fRange).Select
    Selection.Interior.ColorIndex = intCellColor
    Selection.Borders(xlEdgeLeft).LineStyle = xlContinuous
    Selection.Borders(xlEdgeTop).LineStyle = xlContinuous
    Selection.Borders(xlEdgeBottom).LineStyle = xlContinuous
    Selection.Borders(xlEdgeRight).LineStyle = xlContinuous
    Selection.Borders(xlInsideVertical).LineStyle = xlContinuous
    Selection.Borders(xlInsideHorizontal).LineStyle = xlContinuous
End With

End Sub

Private Sub CopyRange(strSourceSheet As String, strSourceRange As String, _
    strExportSheet As String, strExportCell As String, lngPasteMode As Long, _
    Optional strSourceFile As String = "", Optional strExportFile As String = "")
    
    If strSourceFile <> "" Then
        Workbooks(strSourceFile).Activate
    End If
    
    Sheets(strSourceSheet).Select
    Range(strSourceRange).Select
    Selection.Copy
    
    If strExportFile <> "" Then
        Workbooks(strExportFile).Activate
    End If
    
    Sheets(strExportSheet).Select
    Range(strExportCell).Select
    Selection.PasteSpecial Paste:=lngPasteMode, Operation:=xlNone, SkipBlanks:=False, Transpose:=False

End Sub

Private Sub CopySequenceColumn(strSourceFile As String, strSourceSheet As String, lngHeaderRow As Long, _
    strCellTitle As String, lngLastRow As Long, strExportFile As String, strExportSheet As String, _
    intOutputColumn As Integer, lngPasteMode As Long, Optional blnHideColumnOnError As Boolean = False)

Dim intColumnID As Integer

Workbooks(strSourceFile).Activate
Sheets(strSourceSheet).Select

intColumnID = FindCellInRow(strCellTitle, strSourceSheet, lngHeaderRow, 1)
If intColumnID > 0 Then
    Range(fRange(lngHeaderRow, intColumnID, lngLastRow, intColumnID)).Select
    Selection.Copy
    
    If strExportFile <> "" Then
        Workbooks(strExportFile).Activate
    End If
    
    Sheets(strExportSheet).Select
    Range(fCell(lngHeaderRow, intOutputColumn)).Select
    
    Selection.PasteSpecial Paste:=lngPasteMode
Else
    If blnHideColumnOnError Then
        If strExportFile <> "" Then
            Workbooks(strExportFile).Activate
        End If
        Sheets(strExportSheet).Select
        Columns(fColumn(intOutputColumn)).Select
        Selection.EntireColumn.Hidden = True
    End If
End If

End Sub

Private Sub CreateStatusColumn(strExportFile As String, strExportSheet As String, _
    intColumnID As Integer, lngHeaderRow As Long, lngLastSeqRow As Long)

On Error GoTo errCreateStatusColumn

Dim strListSep As String
Dim strValidList As String

If strExportFile <> "" Then
    Workbooks(strExportFile).Activate
End If

' Show title
Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)) = "Status"
    
' Determine list separator (dependent on user keyboard settings)
strListSep = GetListSeparator

' Set validation list
strValidList = "Todo" & strListSep & "Ongoing" & strListSep & "Finish" & strListSep & "Skip" & strListSep & "NOK"
Worksheets(strExportSheet).Range(fRange(lngHeaderRow + 1, intColumnID, lngLastSeqRow, intColumnID)).Select
With Selection.Validation
    .Delete
    .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _
        xlBetween, Formula1:="=" & fCell(2, cBTimeCauseListCol, True, True) & ":" & fCell(lngHeaderRow - 1, cBTimeCauseListCol, True, True)
                            
    .IgnoreBlank = True
    .InCellDropdown = True
    .InputTitle = ""
    .ErrorTitle = ""
    .InputMessage = ""
    .ErrorMessage = "The input to this field is restricted." & vbCrLf & "Please select an item from the dropdown list."
    .ShowInput = True
    .ShowError = True
End With

Exit Sub

errCreateStatusColumn:

End Sub

Private Sub CreateColumnATime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim lngCurRow As Long

'Show header
Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "A time" & Chr(10) & "[min]"

'Set format
For lngCurRow = lngHeaderRow + 1 To lngLastSeqRow
    Worksheets(strExportSheet).Range(fCell(lngCurRow, intColumnID)).Select
    Selection.NumberFormat = "0.0"
Next lngCurRow

End Sub

Private Sub CreateColumnEstimatedStartTime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim strStartCell As String

' Show title
Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Estimated start time" & Chr(10) & "(auto)" & Chr(10) & "[dd/mmm/yyyy hh:mm]"

strStartCell = fCell(cStartTimeRow, cPlannedTimeCol, True, True)

' Create column 'estimated start time'
Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
    "=IF(" & fCell(lngHeaderRow + 1, cActualStartTimeCol) & "=" & strEmpty & _
        ",IF(ROW()=ROW(header)+1,IF(" & strStartCell & "=" & strEmpty & "," & strEmpty & "," & strStartCell & ")" & _
        ",IF(" & fCell(lngHeaderRow, intColumnID) & "=" & strEmpty & "," & strEmpty & _
        ",IF(" & fCell(lngHeaderRow, cActualFinishTimeCol) & "=" & strEmpty & _
        ",IF(OR(" & fCell(lngHeaderRow, cATimeCol) & "=" & strEmpty & ",LOWER(" & fCell(lngHeaderRow, cStatusCol) & ")=" & fStr("skip") & ")" & _
        "," & fCell(lngHeaderRow, cEstimatedStartTimeCol) & "," & _
        fCell(lngHeaderRow, cCorrectedEndTimeCol) & "),MAX(" & fCell(lngHeaderRow + 1, cActualStartTimeCol, True) & ":" & fCell(lngLastSeqRow, cActualFinishTimeCol, True) & "," & fCell(lngHeaderRow, cCorrectedEndTimeCol, True, True) & ":" & fCell(lngHeaderRow, cCorrectedEndTimeCol, False, True) & "))))," & fCell(lngHeaderRow + 1, cActualStartTimeCol) & ")"

Range(fRange(lngHeaderRow + 1, intColumnID, CLng(lngLastSeqRow), intColumnID)).Select
Selection.NumberFormat = "dd/mmm/yyyy hh:mm"

End Sub

Private Sub CreateColumnEstimatedEndTime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim strStartCell As String
Dim strActualFinishCell As String
Dim strStatusCell As String
Dim strDurationCell As String
Dim strEstimatedStartCell As String
Dim strTestKeyCell As String

'Dim strBFactor As String

' Show title
Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Estimated end time" & Chr(10) & "(auto)" & Chr(10) & "[dd/mmm/yyyy hh:mm]"

strStartCell = fCell(cStartTimeRow, cPlannedTimeCol, True, True)
strStatusCell = fCell(lngHeaderRow + 1, cStatusCol)
strActualFinishCell = fCell(lngHeaderRow + 1, cActualFinishTimeCol)
strDurationCell = fCell(lngHeaderRow + 1, cATimeCol)
strEstimatedStartCell = fCell(lngHeaderRow + 1, cEstimatedStartTimeCol)
strTestKeyCell = fCell(lngHeaderRow + 1, cTestIDCol)

Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
    "=IF(OR(" & strEstimatedStartCell & "=" & strEmpty & ",TRIM(" & strTestKeyCell & ")=" & strEmpty & ")," & strEmpty & "," & _
        "IF(LOWER(" & strStatusCell & ")=" & fStr("skip") & "," & strEstimatedStartCell & "," & _
        "IF(" & strActualFinishCell & "=" & strEmpty & "," & strEstimatedStartCell & "+VALUE(" & fCell(lngHeaderRow + 1, cATimeCol) & ")/24/60," & strActualFinishCell & ")))"

Range(fRange(lngHeaderRow + 1, intColumnID, CLng(lngLastSeqRow), intColumnID)).Select
Selection.NumberFormat = "dd/mmm/yyyy hh:mm"

End Sub

Private Sub CreateColumnCorrectedEndTime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim strSubTestsCell As String
Dim strEstimatedStartCell As String
Dim strEstimatedEndCell As String
Dim strBfactor As String
Dim strDuration As String
Dim strStatusCell As String

strBfactor = fCell(cA2BFactorRow, cPlannedTimeCol, True, True)
' Show title
Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Corrected end time" & Chr(10) & "(auto)" & Chr(10) & "[dd/mmm/yyyy hh:mm]"

strStatusCell = fCell(lngHeaderRow + 1, cStatusCol)
strSubTestsCell = fCell(lngHeaderRow + 1, cHasSubtestsCol)
strEstimatedStartCell = fCell(lngHeaderRow + 1, cEstimatedStartTimeCol)
strEstimatedEndCell = fCell(lngHeaderRow + 1, cEstimatedEndTimeCol)

' Create column 'corrected end time'
strDuration = fCell(lngHeaderRow + 1, cATimeCol)
Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
    "=IF(" & strEstimatedStartCell & "=" & strEmpty & "," & strEmpty & "," & _
    "IF(OR(" & strStatusCell & "=" & fStr("skip") & "," & strSubTestsCell & "=" & fStr("Y") & "," & strEstimatedEndCell & "=" & strEmpty & ")," & strEstimatedStartCell & "," & strEstimatedEndCell & "+(" & strBfactor & "-1)*VALUE(" & strDuration & ")/24/60))"

Range(fRange(lngHeaderRow + 1, intColumnID, CLng(lngLastSeqRow), intColumnID)).Select
Selection.NumberFormat = "dd/mmm/yyyy hh:mm"

End Sub

Private Sub CreateColumnIdleTime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim strActStart As String
Dim strActFinish As String
Dim strEstStart As String

Dim strStartRange As String
Dim strFinishRange As String

'Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Idle time" & Chr(10) & "(auto)" & Chr(10) & "[min]"

    strActStart = fCell(lngHeaderRow + 1, cActualStartTimeCol)
    strActFinish = fCell(lngHeaderRow + 1, cActualFinishTimeCol)
    strEstStart = fCell(lngHeaderRow + 1, cEstimatedStartTimeCol)
    strStartRange = fCell(lngHeaderRow, cActualStartTimeCol, True) & ":" & fCell(lngLastSeqRow, cActualStartTimeCol, True)
    strFinishRange = fCell(lngHeaderRow, cActualFinishTimeCol, True) & ":" & fCell(lngLastSeqRow, cActualFinishTimeCol, True)
    
' Create column 'idle time'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
        "=IF(" & strActStart & "=" & strEmpty & "," & strEmpty & _
                ",IF(OR(" & strActStart & "<=MIN(" & strStartRange & ")," & _
                        strActStart & "<=MIN(" & strFinishRange & ")," & _
                        "COUNT(" & strFinishRange & ")=0," & _
                        "COUNTIF(" & strFinishRange & "," & strActStart & ")>=1+INT(" & strActStart & "=" & strActFinish & ")," & _
                        "COUNTIF(" & strStartRange & "," & fStr("<=") & "&" & strEstStart & ")<>COUNT(" & strFinishRange & ")-COUNTIF(" & strFinishRange & "," & fStr(">") & "&" & strEstStart & ")+1),0," & _
                        strActStart & "-SMALL(" & strFinishRange & ",COUNTIF(" & strFinishRange & "," & fStr("<") & "&" & strActStart & ")))*24*60)"

    Range(fCell(lngHeaderRow + 1, intColumnID)).Select
    Selection.NumberFormat = "0.0"
    
End Sub

Private Sub CreateColumnActualStart(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Create column 'Actual start'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Actual start" & Chr(10) & "[dd/mmm/yyyy hh:mm]"
    Range(fRange(lngHeaderRow + 1, intColumnID, lngLastSeqRow, intColumnID)).Select
    With Selection
        .NumberFormat = "dd/mmm/yyyy hh:mm"
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlBottom
    End With

End Sub

Private Sub CreateColumnActualFinish(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Create column 'Actual finish'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Actual finish" & Chr(10) & "[dd/mmm/yyyy hh:mm]"
    Range(fRange(lngHeaderRow + 1, intColumnID, lngLastSeqRow, intColumnID)).Select
    With Selection
        .NumberFormat = "dd/mmm/yyyy hh:mm"
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlBottom
    End With

End Sub

Private Sub CreateColumnActualBTime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Actual time" & Chr(10) & "(auto)" & Chr(10) & "[min]"
' Create column 'Actual time'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
        "=IF((OR(" & fCell(lngHeaderRow + 1, cActualStartTimeCol) & "=" & strEmpty & "," & fCell(lngHeaderRow + 1, cActualFinishTimeCol) & "=" & strEmpty & "))," & strEmpty & _
            ",(" & fCell(lngHeaderRow + 1, cActualFinishTimeCol) & "-" & fCell(lngHeaderRow + 1, cActualStartTimeCol) & ")*24*60)"

Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Select
Selection.NumberFormat = "0.0"

End Sub

Private Sub CreateColumnOrgPlanFinish(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim strStartCell As String
Dim strBfactor As String
Dim strGroupedCell As String

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Expected Plan" & Chr(10) & "(auto)" & Chr(10) & "[dd/mmm/yyyy hh:mm]"

' Create column 'Expected Plan'
    strStartCell = fCell(CLng(cStartTimeRow), cPlannedTimeCol, True, True)
    strGroupedCell = fCell(CLng(lngHeaderRow + 1), cHasSubtestsCol)
    
    strBfactor = fCell(cA2BFactorRow, cPlannedTimeCol, True, True)
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
        "=IF(OR(AND(ROW()=" & lngHeaderRow + 1 & "," & strStartCell & "=" & strEmpty & ")," & fCell(lngHeaderRow, intColumnID) & "=" & strEmpty & ")," & strEmpty & _
        ",IF(ROW()=" & lngHeaderRow + 1 & "," & strStartCell & "," & fCell(lngHeaderRow, intColumnID) & _
        ") + IF(OR(LOWER(" & fCell(lngHeaderRow + 1, cStatusCol) & ")=" & fStr("skip") & "," & fCell(lngHeaderRow + 1, cATimeCol) & "=" & strEmpty & "," & strGroupedCell & "=" & fStr("Y") & "),0," & strBfactor & "*" & fCell(lngHeaderRow + 1, cATimeCol) & "/24/60))"
    
    Range(fCell(lngHeaderRow + 1, intColumnID)).Select
    With Selection
        .NumberFormat = "dd/mmm/yyyy hh:mm"
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlBottom
    End With

End Sub

Private Sub CreateColumnBTimeCause(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "B-time cause"

End Sub

Private Sub CreateColumnSONumber(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "SO number"
    
End Sub

Private Sub CreateColumnCommentsProcedure(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Create column 'Comments on procedure and WoW'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Comments on procedure and WoW"

End Sub

Private Sub CreateColumnComments1stLine(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Create column 'Comments from 1st line'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Comments from 1st line"

End Sub

Private Sub CreateColumnTimeKeeperBalloonTitle(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Create header 'Time keeper balloon title'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow - 1, intColumnID)).Formula = "Time keeper comments"

' Create column 'Time keeper balloon title'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Time keeper balloon title"


End Sub

Private Sub CreateColumnTimeKeeperDetailComments(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Create column 'Time keeper detail comments'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Time keeper detail comments"

End Sub

Private Sub CreateColumnPercStep(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "% step" & Chr(10) & "(auto)"
' Create column '% step'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
        "=IF(OR(" & fCell(lngHeaderRow + 1, cATimeCol) & "=" & strEmpty & ",LOWER(" & fCell(lngHeaderRow + 1, cStatusCol) & ")=" & fStr("skip") & ")" & _
        ",0,(" & fCell(lngHeaderRow + 1, cCumBTimeCol) & "-" & fCell(lngHeaderRow, cCumBTimeCol) & ")/" & fCell(lngLastSeqRow, cCumBTimeCol, True, True) & ")"

Columns(fColName(intColumnID)).Select
Selection.NumberFormat = "0.0%"

End Sub

Private Sub CreateColumnPercCum(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "% cum." & Chr(10) & "(auto)"
' Create column '% cum.'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
        "=" & fCell(lngHeaderRow + 1, cCumBTimeCol) & "/max(" & fCell(lngHeaderRow + 1, cCumBTimeCol, True, True) & ":" & fCell(lngLastSeqRow, cCumBTimeCol, True, True) & ")"

Columns(fColName(intColumnID)).Select
Selection.NumberFormat = "0.0%"

End Sub

Private Sub CreateColumnCumulativeBTime(strExportSheet As String, lngHeaderRow As Long, _
    lngLastSeqRow As Long, intColumnID As Integer)

Dim strBfactor As String

strBfactor = fCell(cA2BFactorRow, cPlannedTimeCol, True, True)

' Show title
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow, intColumnID)).Formula = "Cumulative B-time (auto) [min]"
' Create column 'Cum. B-time'
    Worksheets(strExportSheet).Range(fCell(lngHeaderRow + 1, intColumnID)).Formula = _
        "=if(" & fCell(lngHeaderRow + 1, cActualBTimeCol) & "=" & strEmpty & _
            ",IF(OR(TRIM(" & fCell(lngHeaderRow + 1, cTestIDCol) & ")=" & strEmpty & "," & fCell(lngHeaderRow + 1, cATimeCol) & "=" & strEmpty & ",LOWER(" & fCell(lngHeaderRow + 1, cStatusCol) & ")=" & fStr("skip") & ")" & _
            ",0," & strBfactor & "*" & fCell(lngHeaderRow + 1, cATimeCol) & ")," & fCell(lngHeaderRow + 1, cActualBTimeCol) & _
            ")+IF(ISERROR(VALUE(" & fCell(lngHeaderRow, intColumnID) & ")),0," & fCell(lngHeaderRow, intColumnID) & ")"
    
Columns(fColName(intColumnID)).Select
Selection.NumberFormat = "0.0"

End Sub

Public Sub SetHeaderRowFormat(lngHeaderRow As Long)

' Set format for header row
Rows(fRows(lngHeaderRow)).Select

With Selection
    With .Interior
        .ColorIndex = 49
        .Pattern = xlSolid
    End With
    .Font.Size = 10
    .Font.ColorIndex = 2
    .Font.Bold = True
    .HorizontalAlignment = xlGeneral
    .VerticalAlignment = xlBottom
    .WrapText = True
    .Orientation = 0
    .AddIndent = False
    .IndentLevel = 0
    .ShrinkToFit = False
    .ReadingOrder = xlContext
    .MergeCells = False
End With

End Sub

Private Sub HighlightUserInputCells(strExportSheet As String, lngMinRow As Long, lngMaxRow As Long)

Dim strListSep As String

On Error GoTo errHighlightUserInputCells

strListSep = GetListSeparator

' Format status column
Selection.FormatConditions.Add Type:=xlExpression, Formula1:="=OR(" & fCell(lngMinRow, cStatusCol) & "=" & fStr("Finished") & strListSep & fCell(lngMinRow, cStatusCol) & "=" & fStr("OK") & ")"
Selection.FormatConditions(1).Interior.ColorIndex = 35
Selection.FormatConditions.Add Type:=xlExpression, Formula1:="=OR(" & fCell(lngMinRow, cStatusCol) & "=" & fStr("Failed") & strListSep & fCell(lngMinRow, cStatusCol) & "=" & fStr("Out of limits") & ")"
Selection.FormatConditions(2).Interior.ColorIndex = 22
Selection.FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=" & fStr("Skip")
Selection.FormatConditions(3).Interior.ColorIndex = 44
        
' Use conditional formatting
ConditionalFormatInputCells fRange(lngMinRow, cStatusCol, lngMaxRow, cStatusCol), lngMinRow, lngMaxRow, False
ConditionalFormatInputCells fRange(lngMinRow, cActualStartTimeCol, lngMaxRow, cActualFinishTimeCol), lngMinRow, lngMaxRow

Exit Sub

errHighlightUserInputCells:
WriteError "HighlightUserInputCells", err
Resume Next

End Sub

Private Sub HighlightAutoCalculationCells(strExportSheet, lngMinRow As Long, lngMaxRow As Long)

ConditionalFormatCalculationCells fRange(lngMinRow, cEstimatedStartTimeCol, lngMaxRow, cEstimatedEndTimeCol), lngMinRow, lngMaxRow

End Sub

Public Sub ConditionalFormatInputCells(strRange As String, lngMinRow As Long, lngMaxRow As Long, Optional blnDeletePrevious As Boolean = True)

Dim strListSep As String

Range(strRange).Select

strListSep = GetListSeparator

If blnDeletePrevious Then
    Selection.FormatConditions.Delete
End If

Selection.FormatConditions.Add Type:=xlExpression, Formula1:= _
    "=AND(" & fCell(lngMinRow, cTestIDCol, False, True) & "<>" & strEmpty & strListSep & fCell(lngMinRow, cHasSubtestsCol, False, True) & "<>" & fStr("Y") & ")"

With Selection.FormatConditions(Selection.FormatConditions.Count).Borders(xlLeft)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With
With Selection.FormatConditions(Selection.FormatConditions.Count).Borders(xlRight)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With
With Selection.FormatConditions(Selection.FormatConditions.Count).Borders(xlTop)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With
With Selection.FormatConditions(Selection.FormatConditions.Count).Borders(xlBottom)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With

Selection.FormatConditions(Selection.FormatConditions.Count).Interior.ColorIndex = cUserInputCellColor
Selection.FormatConditions(Selection.FormatConditions.Count).StopIfTrue = True

End Sub

Private Sub ConditionalFormatCalculationCells(strRange As String, lngMinRow As Long, lngMaxRow As Long)

Dim strListSep As String

On Error GoTo errConditionalFormatCalculationCells

Range(strRange).Select

strListSep = GetListSeparator

Selection.FormatConditions.Delete

Selection.FormatConditions.Add Type:=xlExpression, Formula1:= _
    "=AND(" & fCell(lngMinRow, cTestIDCol, False, True) & "<>" & strEmpty & strListSep & fCell(lngMinRow, cHasSubtestsCol, False, True) & "<>" & fStr("Y") & ")"

Selection.FormatConditions(Selection.FormatConditions.Count).SetFirstPriority
    
With Selection.FormatConditions(1).Borders(xlLeft)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With
With Selection.FormatConditions(1).Borders(xlRight)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With
With Selection.FormatConditions(1).Borders(xlTop)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With
With Selection.FormatConditions(1).Borders(xlBottom)
    .LineStyle = xlContinuous
    .TintAndShade = 0
    .Weight = xlThin
End With

Selection.FormatConditions(1).Interior.ColorIndex = cCalculatedCellColor
Selection.FormatConditions(1).StopIfTrue = True

Exit Sub

errConditionalFormatCalculationCells:
WriteDebug "Error occurred in ConditionalFormatCalculationCells"
WriteDebug err.Description
Resume Next

End Sub

Private Sub CreateABTimeTable(strExportSheet As String, lngMinRow As Long, lngMaxRow As Long)

On Error GoTo errCreateABTimeTable

' Show remaining header cells
SetCellHeaderFormat strExportSheet, fCell(cA2BHeaderRow, cPlannedTimeCol), "Planned"
SetCellHeaderFormat strExportSheet, fCell(cA2BHeaderRow, cActualTimeCol), "Actual"
SetCellHeaderFormat strExportSheet, fCell(cStartTimeRow, cDelayCol), "Delay [hrs]"
SetCellHeaderFormat strExportSheet, fCell(cA2BFactorRow, cA2BHeaderCol), "A2B factor"
SetCellHeaderFormat strExportSheet, fCell(cStartTimeRow, cA2BHeaderCol), "Start time"
SetCellHeaderFormat strExportSheet, fCell(cEndTimeRow, cA2BHeaderCol), "End time"
SetCellHeaderFormat strExportSheet, fCell(cWeekNrRow, cA2BHeaderCol), "Weeknr."
    
Range(fRange(CLng(cStartTimeRow), cPlannedTimeCol, CLng(cWeekNrRow), cDelayCol)).Select
Selection.Borders(xlDiagonalDown).LineStyle = xlNone
Selection.Borders(xlDiagonalUp).LineStyle = xlNone
With Selection.Borders(xlEdgeLeft)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With
With Selection.Borders(xlEdgeTop)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With
With Selection.Borders(xlEdgeBottom)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With
With Selection.Borders(xlEdgeRight)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With
With Selection.Borders(xlInsideVertical)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With
With Selection.Borders(xlInsideHorizontal)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With
    
SetCellBackColor strExportSheet, fRange(CLng(cA2BFactorRow), cPlannedTimeCol, CLng(cWeekNrRow), cActualTimeCol), cCalculatedCellColor

SetCellBackColor strExportSheet, fCell(cA2BFactorRow, cPlannedTimeCol), cUserInputCellColor
SetCellBackColor strExportSheet, fCell(cStartTimeRow, cPlannedTimeCol), cUserInputCellColor
SetCellBackColor strExportSheet, fCell(cEndTimeRow, cDelayCol), cCalculatedCellColor

SetCellBackColor strExportSheet, fCell(cLegendRow, cPlannedTimeCol), cUserInputCellColor
SetCellBackColor strExportSheet, fCell(cLegendRow, cActualTimeCol), cCalculatedCellColor

Worksheets(strExportSheet).Range(fCell(cLegendRow, cPlannedTimeCol)) = "User input"
Worksheets(strExportSheet).Range(fCell(cLegendRow, cActualTimeCol)) = "Calculated"

'Now define the formulae for this table
Worksheets(strExportSheet).Range(fCell(cStartTimeRow, cActualTimeCol)).Formula = "=IF(COUNT(" & fRange(lngMinRow, cActualStartTimeCol, lngMaxRow, cActualStartTimeCol) & ")=0," & strEmpty & ",MIN(" & fRange(lngMinRow, cActualStartTimeCol, lngMaxRow, cActualStartTimeCol) & "))"
Worksheets(strExportSheet).Range(fCell(cEndTimeRow, cPlannedTimeCol)).Formula = "=IF(MAX(" & fRange(lngMinRow, cOrgPlanFinishCol, lngMaxRow, cOrgPlanFinishCol) & ")=0," & strEmpty & ",MAX(" & fRange(lngMinRow, cOrgPlanFinishCol, lngMaxRow, cOrgPlanFinishCol) & "))"
Worksheets(strExportSheet).Range(fCell(cEndTimeRow, cActualTimeCol)).Formula = "=IF(MAX(" & fRange(lngMinRow, cEstimatedStartTimeCol, lngMaxRow, cEstimatedEndTimeCol) & ")=0," & strEmpty & ",MAX(" & fRange(lngMinRow, cEstimatedStartTimeCol, lngMaxRow, cEstimatedEndTimeCol) & "))"

AddWeekNumberCalculation strExportSheet

'Calculate actual B-factor
Dim strBTimeRange As String
Dim strBTimeSummed As String
Dim strExpectedBTimeRange As String
Dim strIdleTimeRange As String

strBTimeRange = fRange(lngMinRow, cActualBTimeCol, lngMaxRow, cActualBTimeCol)
strExpectedBTimeRange = fRange(lngMinRow, cATimeCol, lngMaxRow, cATimeCol)
strIdleTimeRange = fRange(lngMinRow, cIdleTimeCol, lngMaxRow, cIdleTimeCol)

strBTimeSummed = "SUM(IF(" & strBTimeRange & "<>" & strEmpty & "," & strExpectedBTimeRange & "))"

'Calculate actual A2B factor
Worksheets(strExportSheet).Range(fCell(cA2BFactorRow, cActualTimeCol)).FormulaArray = _
    "=IF(" & strBTimeSummed & "=0," & strEmpty & ",(SUM(" & strBTimeRange & ")+SUM(" & strIdleTimeRange & "))/" & strBTimeSummed & ")"

'Calculate delay time
Worksheets(strExportSheet).Range(fCell(cEndTimeRow, cDelayCol)).Formula = _
    "=IF(ISERROR(" & fCell(cEndTimeRow, cActualTimeCol) & "-" & fCell(cEndTimeRow, cPlannedTimeCol) & ")," & strEmpty & ",(" & fCell(cEndTimeRow, cActualTimeCol) & "-" & fCell(cEndTimeRow, cPlannedTimeCol) & ")*24)"

'Set number formats
Range(fRange(CLng(cStartTimeRow), cPlannedTimeCol, CLng(cEndTimeRow), cActualTimeCol)).Select
Selection.NumberFormat = "dd/mmm/yyyy hh:mm"

Range(fCell(cA2BFactorRow, cActualTimeCol)).Select
Selection.NumberFormat = "0.0"
    
Range(fCell(cEndTimeRow, cDelayCol)).Select
Selection.NumberFormat = "0.0"
    
Range(fRange(CLng(cWeekNrRow), cPlannedTimeCol, CLng(cWeekNrRow), cActualTimeCol)).Select
Selection.NumberFormat = "0.0"

Exit Sub

errCreateABTimeTable:
Resume Next

End Sub

Private Sub AddSheet(strSheetname As String, Optional strAfterSheet As String = "")

If strAfterSheet <> "" Then
    Sheets(strAfterSheet).Select
End If

Sheets.Add
ActiveSheet.Select
ActiveSheet.Name = strSheetname

End Sub

Private Sub SetBTimeCauseValidationList(strExportSheet As String, lngStartRow As Long, intValidationCol As Integer)

Dim blnBTimeBuckets As Boolean
Dim intListLength As Integer

blnBTimeBuckets = True

' Set validation values for B-time cause

Worksheets(strExportSheet).Cells(lngStartRow, cBTimeCauseListCol) = "B-time cause list"

If blnBTimeBuckets Then
    intListLength = 8
    Worksheets(strExportSheet).Cells(lngStartRow + 1, cBTimeCauseListCol) = "B1: Material Availability"
    Worksheets(strExportSheet).Cells(lngStartRow + 2, cBTimeCauseListCol) = "B2: Material Quality"
    Worksheets(strExportSheet).Cells(lngStartRow + 3, cBTimeCauseListCol) = "B3: People"
    Worksheets(strExportSheet).Cells(lngStartRow + 4, cBTimeCauseListCol) = "B4: Tooling"
    Worksheets(strExportSheet).Cells(lngStartRow + 5, cBTimeCauseListCol) = "B5: Facility"
    Worksheets(strExportSheet).Cells(lngStartRow + 6, cBTimeCauseListCol) = "B6: Documentation "
    Worksheets(strExportSheet).Cells(lngStartRow + 7, cBTimeCauseListCol) = "B7: Procedure"
    Worksheets(strExportSheet).Cells(lngStartRow + 8, cBTimeCauseListCol) = "B8: Technical"
Else
    intListLength = 27
    Worksheets(strExportSheet).Cells(lngStartRow + 1, cBTimeCauseListCol) = "[Instable] Init fails"
    Worksheets(strExportSheet).Cells(lngStartRow + 2, cBTimeCauseListCol) = "[Instable] Test execution fails"
    Worksheets(strExportSheet).Cells(lngStartRow + 3, cBTimeCauseListCol) = "[Instable] Wait time for CT"
    Worksheets(strExportSheet).Cells(lngStartRow + 4, cBTimeCauseListCol) = "[Instable] Test Constants"
    Worksheets(strExportSheet).Cells(lngStartRow + 5, cBTimeCauseListCol) = "[Instable] Patch"
    Worksheets(strExportSheet).Cells(lngStartRow + 6, cBTimeCauseListCol) = "[Instable] Rerun needed, convergence"
    Worksheets(strExportSheet).Cells(lngStartRow + 7, cBTimeCauseListCol) = "[Instable] Unknown"
    Worksheets(strExportSheet).Cells(lngStartRow + 8, cBTimeCauseListCol) = "[Procedures] Inaccurate / missing"
    Worksheets(strExportSheet).Cells(lngStartRow + 9, cBTimeCauseListCol) = "[Procedures] Sequence incorrect"
    Worksheets(strExportSheet).Cells(lngStartRow + 10, cBTimeCauseListCol) = "[Issues] Diagnostic tools missing"
    Worksheets(strExportSheet).Cells(lngStartRow + 11, cBTimeCauseListCol) = "[Issues] Diagnostic skills missing (KT)"
    Worksheets(strExportSheet).Cells(lngStartRow + 12, cBTimeCauseListCol) = "[Issues] ER log polution, broken links, etc"
    Worksheets(strExportSheet).Cells(lngStartRow + 13, cBTimeCauseListCol) = "[Issues] Waiting for parts, tools, 2nd line"
    Worksheets(strExportSheet).Cells(lngStartRow + 14, cBTimeCauseListCol) = "[Facilities] Cust. Wait time (wafers, tools, etc)"
    Worksheets(strExportSheet).Cells(lngStartRow + 15, cBTimeCauseListCol) = "[Facilities] Track / Wafer processing"
    Worksheets(strExportSheet).Cells(lngStartRow + 16, cBTimeCauseListCol) = "[Facilities] Fab / Facilities"
    Worksheets(strExportSheet).Cells(lngStartRow + 17, cBTimeCauseListCol) = "[Prepare] Tools not available on time"
    Worksheets(strExportSheet).Cells(lngStartRow + 18, cBTimeCauseListCol) = "[Prepare] Parts not available on time"
    Worksheets(strExportSheet).Cells(lngStartRow + 19, cBTimeCauseListCol) = "[Prepare] Operator error (Shifts take too long so operators make errors more easily)"
    Worksheets(strExportSheet).Cells(lngStartRow + 20, cBTimeCauseListCol) = "[Prepare] Seq/proc not checked for tools, skills, etc"
    Worksheets(strExportSheet).Cells(lngStartRow + 21, cBTimeCauseListCol) = "[Prepare] Not the right engineer in the right shift"
    Worksheets(strExportSheet).Cells(lngStartRow + 22, cBTimeCauseListCol) = "[Materials] missing"
    Worksheets(strExportSheet).Cells(lngStartRow + 23, cBTimeCauseListCol) = "[Materials] Contaminated / damaged / optical"
    Worksheets(strExportSheet).Cells(lngStartRow + 24, cBTimeCauseListCol) = "[Materials] Non qualified"
    Worksheets(strExportSheet).Cells(lngStartRow + 25, cBTimeCauseListCol) = "[Materials] Tools missing / incorrect"
    Worksheets(strExportSheet).Cells(lngStartRow + 26, cBTimeCauseListCol) = "[Materials] Labelling NOK"
    Worksheets(strExportSheet).Cells(lngStartRow + 27, cBTimeCauseListCol) = "[Materials] Not compatible"
End If

Range(fCell(lngStartRow + 1, intValidationCol)).Select
Application.CutCopyMode = False
With Selection.Validation
    .Delete
    .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, _
        Formula1:="=" & fCell(lngStartRow + 1, cBTimeCauseListCol, True, True) & ":" & fCell(lngStartRow + intListLength, cBTimeCauseListCol, True, True)
    .IgnoreBlank = True
    .InCellDropdown = True
    .InputTitle = ""
    .ErrorTitle = "Input validation error"
    .InputMessage = ""
    .ErrorMessage = "The input to this field is restricted." & vbCrLf & "Please select one of the items from the dropdown list."
    .ShowInput = True
    .ShowError = True
End With

End Sub

Private Sub SetStatusColumnValidationList(strExportSheet As String, lngStartRow As Long, intValidationCol As Integer)

' Set validation values status column

Worksheets(strExportSheet).Cells(lngStartRow, cBTimeCauseListCol) = "Status validation list"
Worksheets(strExportSheet).Cells(lngStartRow + 1, cBTimeCauseListCol) = "ToDo"
Worksheets(strExportSheet).Cells(lngStartRow + 2, cBTimeCauseListCol) = "OK"
Worksheets(strExportSheet).Cells(lngStartRow + 3, cBTimeCauseListCol) = "Skip"
Worksheets(strExportSheet).Cells(lngStartRow + 4, cBTimeCauseListCol) = "Ongoing"
Worksheets(strExportSheet).Cells(lngStartRow + 5, cBTimeCauseListCol) = "Queue"
Worksheets(strExportSheet).Cells(lngStartRow + 6, cBTimeCauseListCol) = "Finished"
Worksheets(strExportSheet).Cells(lngStartRow + 7, cBTimeCauseListCol) = "Failed"
Worksheets(strExportSheet).Cells(lngStartRow + 8, cBTimeCauseListCol) = "Out of limits"

End Sub

Private Sub CopySequenceFormatting(strExportSheet As String, strFromRange As String, strToRange As String)

Worksheets(strExportSheet).Select
Range(strFromRange).Select
Selection.Copy
    
Range(strToRange).Select
Selection.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
Selection.Font.Italic = False

End Sub

Public Sub UpdateHeader(strExportSheet As String, lngHeaderRow As Long, lngLastSeqRow As Long)

Dim strFormula As String

If Not UseParallellismLight Then
' Do NOT count the subtests (denoted "S")
    
    Worksheets(strExportSheet).Range("nrtests") = _
        "=COUNTIFS(" & _
        fRange(lngHeaderRow + 1, cHasSubtestsCol, lngLastSeqRow, cHasSubtestsCol) & "," & fStr("N") & "," & _
        fRange(lngHeaderRow + 1, cStatusCol, lngLastSeqRow, cStatusCol) & "," & fStr("<>Skip") & ")" & _
        "+COUNTIFS(" & _
        fRange(lngHeaderRow + 1, cHasSubtestsCol, lngLastSeqRow, cHasSubtestsCol) & "," & fStr("Y") & "," & _
        fRange(lngHeaderRow + 1, cStatusCol, lngLastSeqRow, cStatusCol) & "," & fStr("<>Skip") & ")"

    Worksheets(strExportSheet).Range("EstimatedDurationRaw") = "=" & fCell(cA2BFactorRow, cPlannedTimeCol, True, True) & _
        "*(" & _
        "SUMIFS(" & _
            fRange(lngHeaderRow + 1, cATimeCol, lngLastSeqRow, cATimeCol) & "," & _
            fRange(lngHeaderRow + 1, cHasSubtestsCol, lngLastSeqRow, cHasSubtestsCol) & "," & fStr("N") & "," & _
            fRange(lngHeaderRow + 1, cStatusCol, lngLastSeqRow, cStatusCol) & "," & fStr("<>Skip") & ")" & _
        "+SUMIFS(" & _
            fRange(lngHeaderRow + 1, cATimeCol, lngLastSeqRow, cATimeCol) & "," & _
            fRange(lngHeaderRow + 1, cHasSubtestsCol, lngLastSeqRow, cHasSubtestsCol) & "," & fStr("Y") & "," & _
            fRange(lngHeaderRow + 1, cStatusCol, lngLastSeqRow, cStatusCol) & "," & fStr("<>Skip") & ")" & _
            ")/60"
    
    If blnShowDurationSimple Then
        Worksheets(strExportSheet).Range("Duration") = "=EstimatedDurationRaw"
        Worksheets(strExportSheet).Range("DurationUnit") = "hrs"
    Else
        Worksheets(strExportSheet).Range("Duration") = _
            "=IF(EstimatedDurationRaw<1," & fStr("") & ",INT(EstimatedDurationRaw) &" & fStr(" hrs ") & _
            ")&TEXT(60*(EstimatedDurationRaw-INT(EstimatedDurationRaw))," & fStr("#0") & ")&" & fStr(" min")
    End If
    
    If blnShowSQRDuration Then
        Worksheets(strExportSheet).Range("SQRCaption") = "Estimated duration with SQR:"
        Worksheets(strExportSheet).Range("SQRCaption").Font.Size = 8
        Worksheets(strExportSheet).Range("SQRUnit").Font.Size = 8
        Worksheets(strExportSheet).Range("SQRDuration").Font.Size = 8
        Worksheets(strExportSheet).Range("EstimatedDurationSQRRaw") = "=EstimatedDurationRaw-(" & _
        "(1-" & sngReductionAutomatic & ")*(" & fCell(cA2BFactorRow, cPlannedTimeCol, True, True) & "-1)*" & _
        "SUMIFS(" & _
            fRange(lngHeaderRow + 1, cATimeCol, lngLastSeqRow, cATimeCol) & "," & _
            fRange(lngHeaderRow + 1, cHasSubtestsCol, lngLastSeqRow, cHasSubtestsCol) & "," & fStr("N") & "," & _
            fRange(lngHeaderRow + 1, cStatusCol, lngLastSeqRow, cStatusCol) & "," & fStr("<>Skip") & "," & _
            fRange(lngHeaderRow + 1, cStartModeCol, lngLastSeqRow, cStartModeCol) & "," & fStr("A") & ")" & _
        "+(1-" & sngReductionSemiAutomatic & ")*(" & fCell(cA2BFactorRow, cPlannedTimeCol, True, True) & "-1)*" & _
        "SUMIFS(" & _
            fRange(lngHeaderRow + 1, cATimeCol, lngLastSeqRow, cATimeCol) & "," & _
            fRange(lngHeaderRow + 1, cHasSubtestsCol, lngLastSeqRow, cHasSubtestsCol) & "," & fStr("Y") & "," & _
            fRange(lngHeaderRow + 1, cStatusCol, lngLastSeqRow, cStatusCol) & "," & fStr("<>Skip") & "," & _
            fRange(lngHeaderRow + 1, cStartModeCol, lngLastSeqRow, cStartModeCol) & "," & fStr("M") & ")" & _
            ")/60"
        
        If blnShowDurationSimple Then
            Worksheets(strExportSheet).Range("SQRDuration") = "=EstimatedDurationSQRRaw"
            Worksheets(strExportSheet).Range("SQRUnit") = "hrs"
        Else
            Worksheets(strExportSheet).Range("SQRDuration") = _
                "=IF(EstimatedDurationSQRRaw<1," & fStr("") & ",INT(EstimatedDurationSQRRaw) &" & fStr(" hrs ") & _
                ")&TEXT(60*(EstimatedDurationSQRRaw-INT(EstimatedDurationSQRRaw))," & fStr("#0") & ")&" & fStr(" min")
        End If
    End If
Else
    Dim lngCurRow As Long
    Dim lngTestRow As Long
    
    Worksheets(strExportSheet).Range("nrtests") = "=COUNT(" & fRange(lngHeaderRow + 1, cATimeCol, lngLastSeqRow, cATimeCol) & ")"
    
    strFormula = "SUM(" & fRange(lngHeaderRow + 1, cATimeCol, lngLastSeqRow, cATimeCol) & ")"
    For lngCurRow = lngHeaderRow + 1 To lngLastSeqRow
        Select Case Worksheets(strExportSheet).Cells(lngCurRow, cHasSubtestsCol)
            Case Is = "P1"
                If lngTestRow > 0 And lngCurRow > lngTestRow + 1 Then
                    strFormula = strFormula & "-MIN(" & fCell(lngTestRow, cATimeCol) & ",SUM(" & fRange(lngTestRow + 1, cATimeCol, lngCurRow - 1, cATimeCol) & "))"
                End If
                lngTestRow = lngCurRow
            Case Is = "p", "P2"
            Case Else
                If lngTestRow > 0 And lngCurRow > lngTestRow + 1 Then
                    strFormula = strFormula & "-MIN(" & fCell(lngTestRow, cATimeCol) & ",SUM(" & fRange(lngTestRow + 1, cATimeCol, lngCurRow - 1, cATimeCol) & "))"
                    lngTestRow = 0
                End If
        End Select
    Next lngCurRow
    Worksheets(strExportSheet).Range("duration") = "=" & fCell(cA2BFactorRow, cPlannedTimeCol, True, True) & "*(" & strFormula & ")/60"
End If


End Sub

Private Sub SetActualBTimeFormatting(strExportSheet As String, lngMinRow As Long, lngMaxRow As Long)

On Error GoTo errSetActualBTimeFormatting

Dim lngCurRow As Long
Dim strMaxFac As String
Dim strMidFac As String
Dim strMinFac As String
Dim strDefaultBFactor As String
Dim strListSep As String
Dim strCndFmtFormula As String
Dim strMaxBTimeDifference As String
Dim strMaxIdleTime As String

Dim strA2BCell As String

strMaxFac = "12/10"
strMidFac = "11/10"
strMinFac = "8/10"
strDefaultBFactor = "12/10"

strMaxBTimeDifference = "20"
strMaxIdleTime = "20"

strListSep = GetListSeparator

strA2BCell = fCell(cA2BFactorRow, cPlannedTimeCol, True, True)

Worksheets(strExportSheet).Select

For lngCurRow = lngMinRow To lngMaxRow
    
    strCndFmtFormula = _
        "OR(" & _
            "AND(" & _
                fCell(lngCurRow, cActualBTimeCol) & ">" & strMaxBTimeDifference & "+" & fCell(lngCurRow, cATimeCol) & strListSep & _
                fCell(lngCurRow, cActualBTimeCol) & ">" & strDefaultBFactor & "*" & fCell(lngCurRow, cATimeCol) & _
                ")" & strListSep & _
            fCell(lngCurRow, cIdleTimeCol) & ">" & strMaxIdleTime & ")"
    
    Range(fCell(lngCurRow, cBTimeCauseCol)).Select
    Selection.FormatConditions.Delete
    Selection.FormatConditions.Add Type:=xlExpression, Formula1:= _
        "=AND(" & _
                    fCell(lngCurRow, cActualBTimeCol) & "<>" & strEmpty & strListSep & _
                    fCell(lngCurRow, cBTimeCauseCol) & "=" & strEmpty & strListSep & strCndFmtFormula & ")"
    Selection.FormatConditions(1).Interior.ColorIndex = cBTimeCauseCellColor

    Range(fCell(lngCurRow, cComments1stLineCol)).Select
    Selection.FormatConditions.Delete
    Selection.FormatConditions.Add Type:=xlExpression, Formula1:= _
        "=AND(" & _
                    fCell(lngCurRow, cActualBTimeCol) & "<>" & strEmpty & strListSep & _
                    fCell(lngCurRow, cComments1stLineCol) & "=" & strEmpty & strListSep & strCndFmtFormula & ")"
    Selection.FormatConditions(1).Interior.ColorIndex = cBTimeCauseCellColor
    
Next lngCurRow

Exit Sub

errSetActualBTimeFormatting:
MsgBox "Cannot set conditional formatting for the B-time related cells in this sheet." & Chr(13) & _
"You can continue to use the sequence." & Chr(13) & _
"To help us solving this issue, please inform dl-NXT-setup using the Comments button. ", vbOKOnly

End Sub

Public Function ActualA2BFactor(strSheetname As String) As String

Dim lngCurRow As Long
Dim sglSumIdleTime As Single
Dim sglSumActualBTime As Single
Dim sglSumExpectedBTime As Single
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

sglSumIdleTime = 0
sglSumActualBTime = 0
sglSumExpectedBTime = 0

For lngCurRow = lngStartRecRow To lngLastSeqRow
    If Worksheets(strSheetname).Cells(lngCurRow, cActualBTimeCol) <> "" Then
        sglSumIdleTime = sglSumIdleTime + Worksheets(strSheetname).Cells(lngCurRow, cIdleTimeCol)
        sglSumActualBTime = sglSumActualBTime + Worksheets(strSheetname).Cells(lngCurRow, cActualBTimeCol)
        sglSumExpectedBTime = sglSumExpectedBTime + Worksheets(strSheetname).Cells(lngCurRow, cATimeCol)
    End If
Next lngCurRow

If sglSumExpectedBTime > 0 Then
    ActualA2BFactor = Format((sglSumIdleTime + sglSumActualBTime) / sglSumExpectedBTime, "#0.0")
    
Else
    ActualA2BFactor = ""
End If
End Function

Public Sub RecoveryInsertRow(strSheetname As String, lngRowID As Long)

Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long

SuspendScreenUpdates

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    
If lngRowID = lngHeaderRow + 1 Then
    
ElseIf lngRowID >= lngStartRecRow And lngRowID <= lngLastSeqRow + 1 Then
    CopySequenceFormulae strSheetname, lngHeaderRow + 1, cEstimatedStartTimeCol, lngLastSeqRow, cIdleTimeCol
    CopySequenceFormulae strSheetname, lngHeaderRow + 1, cActualBTimeCol, lngLastSeqRow, cOrgPlanFinishCol
    CopySequenceFormulae strSheetname, lngHeaderRow + 1, cPercStepCol, lngLastSeqRow, cCumBTimeCol
    Rows(fRow(lngRowID)).Select
End If
ResumeScreenUpdates

End Sub

Private Sub CopySequenceFormulae(strSheetname As String, _
    lngMinRow As Long, intMinCol As Integer, lngMaxRow As Long, intMaxCol As Integer, _
    Optional blnPasteValidationOnly As Boolean = False)

Worksheets(strSheetname).Range(fRange(lngMinRow, intMinCol, lngMinRow, intMaxCol)).Select
Selection.Copy

Worksheets(strSheetname).Range(fRange(lngMinRow, intMinCol, lngMaxRow, intMaxCol)).Select
If Not blnPasteValidationOnly Then
    Selection.PasteSpecial Paste:=xlPasteFormulasAndNumberFormats, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
End If
Selection.PasteSpecial Paste:=xlPasteValidation, Operation:=xlNone, SkipBlanks:=False, Transpose:=False

End Sub

Public Sub SetShortKeys()

Application.OnKey "%^a", "ShowOrHideSourceSheet"
Application.OnKey "%^b", "AddDiagnosticsAndHW"
Application.OnKey "%^c", "ClearTemplate"
Application.OnKey "%^d", "ToggleShowDifferencesWithOriginal"
Application.OnKey "%^D", "ToggleShowFullDifferencesWithOriginal"
Application.OnKey "%^e", "ToggleShowDifferencesWithOtherFile"
Application.OnKey "%^f", "ToggleShowAdditionalColumns"
Application.OnKey "%^h", "RepairHyperlinks"
Application.OnKey "%^i", "CombineSequences"
Application.OnKey "%^l", "ReloadSequence"
Application.OnKey "%^m", "ConvertFiles"
Application.OnKey "%^n", "EnterCurrentDateTime"
Application.OnKey "%^o", "ManualOpenFile"
Application.OnKey "%^p", "ShowPartialSequence"
Application.OnKey "%^r", "RepairSheet"
Application.OnKey "%^s", "ShowScenarios"
Application.OnKey "%^t", "ToggleShowComments"
Application.OnKey "%^u", "CustomizeSequence"
Application.OnKey "%^x", "ExportSequence"
Application.OnKey "%^z", "RepairSequence"
Application.OnKey "%^q", "TestSQRExport"

End Sub

Public Sub RepairSheet(Optional blnConfirm As Boolean = True)

Dim strSheetname As String
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long

strSheetname = ActiveSheet.Name

'Check if Recovery sheet does exist and contains information
If SheetExists(strSheetname) Then
    
    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    
    If lngLastSeqRow >= lngStartRecRow Then
        If blnConfirm Then
            If MsgBox( _
                "This will restore the formulae and the formatting of the Recovery sheet." & vbCrLf & _
                "All other sheets in this workbook will not be affected." & vbCrLf & _
                "Do you wish to continue?", vbYesNo) <> vbYes Then
                    Exit Sub
            End If
        End If
        TimeKeeperExport strSheetname
    Else
        MsgBox "No sequence found in this sheet.", vbOKOnly
    End If
Else
    MsgBox "Cannot repair the recovery sheet." & vbCrLf & "There is no sheet named " & fStr(strSheetname) & " in this workbook.", vbOKOnly
End If

End Sub

Private Sub AddWeekNumberCalculation(strExportSheet As String)

'The weekday calculation is as follows
' =IF(D="","",IF(YEAR(D)<2000,"",_
'   100*YEAR(D)+1+IF(W<=4,1,0)+IF(AND(W>4,INT((D-J-(8-W))/7)<0),51+IF(W=5,1,0),INT((D-J-(8-W))/7))
'
' where D = input date                      -> strRefCell
'       J = Jan-1 of same year              -> strRefDate
'       W = Weekday of Jan-1 of same year   -> strRefWkNr

Dim strRefCell As String
Dim strRefDate As String
Dim strRefWkNr As String
Dim strFormula As String

strRefCell = fCell(cEndTimeRow, cPlannedTimeCol)
strRefDate = "DATE(YEAR(" & strRefCell & "),1,1)"
strRefWkNr = "WEEKDAY(" & strRefDate & ",2)"

strFormula = _
    "=IF(" & strRefCell & "=" & strEmpty & "," & strEmpty & _
    ",IF(YEAR(" & strRefCell & ")<2000," & strEmpty & _
    ",100*(YEAR(" & strRefCell & ")-2000)" & _
    "+1+IF(" & strRefWkNr & "<4,1,0)" & _
    "+IF(AND(" & strRefWkNr & ">4,INT((" & strRefCell & "-" & strRefDate & "-(8-" & strRefWkNr & "))/7)<0),-49+IF(" & strRefWkNr & "=5,1,0),INT((" & strRefCell & "-" & strRefDate & "-(8-" & strRefWkNr & "))/7))" & _
    "+WEEKDAY(" & strRefCell & ",2)/10))"

Worksheets(strExportSheet).Range(fCell(cWeekNrRow, cPlannedTimeCol)).Formula = strFormula

strRefCell = fCell(cEndTimeRow, cActualTimeCol)
strRefDate = "DATE(YEAR(" & strRefCell & "),1,1)"
strRefWkNr = "WEEKDAY(" & strRefDate & ",2)"

strFormula = _
    "=IF(" & strRefCell & "=" & strEmpty & "," & strEmpty & _
    ",IF(YEAR(" & strRefCell & ")<2000," & strEmpty & _
    ",100*(YEAR(" & strRefCell & ")-2000)" & _
    "+1+IF(" & strRefWkNr & "<4,1,0)" & _
    "+IF(AND(" & strRefWkNr & ">4,INT((" & strRefCell & "-" & strRefDate & "-(8-" & strRefWkNr & "))/7)<0),-49+IF(" & strRefWkNr & "=5,1,0),INT((" & strRefCell & "-" & strRefDate & "-(8-" & strRefWkNr & "))/7))" & _
    "+WEEKDAY(" & strRefCell & ",2)/10))"

Worksheets(strExportSheet).Range(fCell(cWeekNrRow, cActualTimeCol)).Formula = strFormula

End Sub

Public Sub ShowScenarios()

Dim intCurRow As Integer
Dim intNrScenarios As Integer
Dim strScenario() As String
Dim intScenarioID As Integer

intCurRow = 1
intNrScenarios = 0
Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
    If InStr(Worksheets("Source").Cells(intCurRow, 1), "##SCENARIOS") > 0 Or InStr(Worksheets("Source").Cells(intCurRow, 1), "$$SCENARIOS") > 0 Then
        intNrScenarios = intNrScenarios + 1
        ReDim Preserve strScenario(intNrScenarios) As String
        strScenario(intNrScenarios) = Mid(Worksheets("Source").Cells(intCurRow, 1), InStr(Worksheets("Source").Cells(intCurRow, 1), "|") + 1)

    ElseIf InStr(Worksheets("Source").Cells(intCurRow, 1), "##STATE") > 0 Then
        intNrScenarios = intNrScenarios + 1
        ReDim Preserve strScenario(intNrScenarios) As String
        strScenario(intNrScenarios) = Mid(Worksheets("Source").Cells(intCurRow, 1), InStrRev(Worksheets("Source").Cells(intCurRow, 1), "|") + 1)
    End If

    intCurRow = intCurRow + 1
Loop

If intNrScenarios = 0 Then
    MsgBox "No additional scenario information is present in the sequence file", vbOKOnly
Else
   
' Unload the form (to be sure, since the form is used for multiple purposes)
    Unload frmScenarioList
    
    Load frmScenarioList
    For intScenarioID = 1 To intNrScenarios
        frmScenarioList.lstList.AddItem strScenario(intScenarioID)
    Next intScenarioID
    frmScenarioList.Show vbModal
End If

End Sub

Private Sub ShowOrHideSourceSheet()

On Error GoTo errShowOrHideSourceSheet

Sheets("Source").Visible = Not Sheets("Source").Visible
If Sheets("Source").Visible Then Sheets("Source").Activate

Exit Sub

errShowOrHideSourceSheet:

End Sub

Private Sub EnterCurrentDateTime()

ActiveCell.Value = Format(date, "dd/mmm/yyyy") & " " & time

End Sub

Public Sub ShowHelp()

Load frmTextWindow
frmTextWindow.Caption = "ARE Template Help"
frmTextWindow.lblTextWindow = ""
frmTextWindow.outputBox.Text = _
    "Sequence help:" & vbCrLf & _
    "   Press CTRL+ALT+f to toggle additional information." & vbCrLf & _
    "   Press CTRL+ALT+o to open an ARE generated sequence file." & vbCrLf & _
    "   Press CTRL+ALT+p to obtain a partial sequence." & vbCrLf & _
    "   Press CTRL+ALT+s to view the selected scenarios for the current sequence." & vbCrLf & _
    vbCrLf & _
    "TimeKeeper help:" & vbCrLf & _
    "   Press CTRL+ALT+h to repair the TimeKeeper hyperlinks." & vbCrLf & _
    "   Press CTRL+ALT+n to enter the current date and time in the selected cell." & vbCrLf & _
    "   Press CTRL+ALT+r to repair the TimeKeeper formulae." & vbCrLf & _
    vbCrLf & _
    "Export help:" & vbCrLf & _
    "   Press CTRL+ALT+x to export the sequence to an XML file." & vbCrLf & _
    "Feedback:" & vbCrLf & _
    "   Use the comments button to send sequence or TimeKeeper feedback."
    
frmTextWindow.Show 0

End Sub

Public Function ToggleShowPartsAndTools() As String
    
Dim intMinCol As Integer
Dim intMaxCol As Integer

intMinCol = FindHeaderText("Parts")
intMaxCol = FindHeaderText("Tools")
If intMinCol > 0 And intMaxCol > intMinCol Then
    If Columns(fColumn(intMinCol, intMaxCol)).EntireColumn.Hidden Then
        Columns(fColumn(intMinCol, intMaxCol)).EntireColumn.Hidden = False
        ToggleShowPartsAndTools = "Hide parts and tools"
    Else
        Columns(fColumn(intMinCol, intMaxCol)).EntireColumn.Hidden = True
        ToggleShowPartsAndTools = "Show parts and tools"
    End If
End If

End Function

Private Sub SetPartsToolsFormatting(lngHeaderRow As Long, lngMaxRow As Long)
    
Range(fRange(lngHeaderRow + 1, cPartsCol, lngMaxRow, cPartsCol)).Select
Selection.FormatConditions.Delete
Selection.FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""No special parts needed."""
Selection.FormatConditions(1).Font.ColorIndex = 15

Range(fRange(lngHeaderRow + 1, cToolsCol, lngMaxRow, cToolsCol)).Select
Selection.FormatConditions.Delete
Selection.FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="=""No special tools needed."""
Selection.FormatConditions(1).Font.ColorIndex = 15

End Sub

Public Sub FindSequenceLayout(strSheetname As String, lngHeaderRow As Long, lngStartRecRow As Long, _
    lngLastSeqRow As Long, Optional blnCheckSwitchPoint As Boolean = True)

If strSheetname = "" Then
    strSheetname = Range("areversion").Worksheet.Name
End If

FindHeaderRow lngHeaderRow
If RangeExists(strSheetname, "endDiagHW") Then
    lngStartRecRow = Range("endDiagHW").row + 1
Else
    lngStartRecRow = lngHeaderRow + 1
End If

FindLastSequenceRow strSheetname, lngHeaderRow + 1, lngLastSeqRow, , blnCheckSwitchPoint

End Sub

Public Sub ToggleShowAdditionalColumns()

Dim blnHideColumns As Boolean

blnHideColumns = Not Columns(fColumn(cTestExecCol)).EntireColumn.Hidden

Columns(fColumn(cTestExecCol)).EntireColumn.Hidden = blnHideColumns
Columns(fColumn(cSAPCol)).EntireColumn.Hidden = blnHideColumns
Columns(fColumn(cProjectCol)).EntireColumn.Hidden = blnHideColumns

End Sub

Public Function FindSequenceRow(strSheetname As String, strKey As String) As Long

Dim c1 As Variant

Set c1 = Worksheets(strSheetname).Cells.Find(What:=strKey, After:=Worksheets(strSheetname).Cells(1, 1), LookIn:=xlFormulas, _
    Lookat:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=False)
    
If c1 Is Nothing Then
    FindSequenceRow = -1
Else
    FindSequenceRow = c1.row
End If

End Function

Public Sub ShowBreakpoint(strStop As String)

MsgBox "Stop at user defined breakpoint: " & strStop & vbCrLf & "Press CTRL+BREAK to start debugging, press OK to continue", vbOKOnly

End Sub

Public Sub FindHeaderRow(lngHeaderRow As Long)

On Error GoTo errFindHeaderRow

lngHeaderRow = 0

lngHeaderRow = Range("header").row
If lngHeaderRow = 0 Then
    lngHeaderRow = 10
End If

Exit Sub

errFindHeaderRow:
Resume Next

End Sub

Public Sub FindLastSequenceRow(strSheetname As String, lngStartRow As Long, lngLastSeqRow As Long, Optional intCheckCol As Integer = cTestNameCol, Optional blnCheckSwitchPoint As Boolean = True)

FindRecoveryFinished strSheetname, lngLastSeqRow, blnCheckSwitchPoint

If lngLastSeqRow <= 0 Then
    lngLastSeqRow = lngStartRow
    While Worksheets(strSheetname).Cells(lngLastSeqRow, intCheckCol) <> "" Or Worksheets(strSheetname).Cells(lngLastSeqRow + 1, intCheckCol) <> ""
        lngLastSeqRow = lngLastSeqRow + 1
    Wend
End If

End Sub

Private Sub FindRecoveryFinished(strSheetname As String, lngRow As Long, Optional blnCheckSwitchPoint As Boolean = True)

Dim c1 As Variant
Dim c2 As Variant

' Determine row with "RECOVERY_FINISHED" in the sequence
Set c1 = Worksheets(strSheetname).Cells.Find(What:="RECOVERY_FINISHED", After:=Worksheets(strSheetname).Cells(1, 1), LookIn:=xlFormulas, _
    Lookat:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, _
    MatchCase:=False, SearchFormat:=False)

' Determine row with PEP-NXT switchpoint (obsolete)
Set c2 = Worksheets(strSheetname).Cells.Find(What:="SY_200WPH_SWITCHPOINT", After:=Worksheets(strSheetname).Cells(1, 1), LookIn:=xlFormulas, _
    Lookat:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, _
    MatchCase:=False, SearchFormat:=False)

If blnCheckSwitchPoint And Not c2 Is Nothing Then
    lngRow = c2.row
Else
    If c1 Is Nothing Then
        lngRow = -1
    Else
        lngRow = c1.row
    End If
End If

End Sub

Public Function ReadCfgFile(strArgument As String) As String

Dim intCfgFile As Integer
Dim strCfgFile As String
Dim strInvTxt As String
Dim strKey As String
Dim strValue As String

' Read templateFG.xls configuration file

If strSourceDir = "" Then
    strSourceDir = ActiveWorkbook.path
End If

strCfgFile = strSourceDir & "\" & "templateFG.cfg"

If IsFile(strCfgFile) Then
    intCfgFile = FreeFile
    Open strCfgFile For Input As #intCfgFile
    While Not EOF(intCfgFile)
        Line Input #intCfgFile, strInvTxt
        If InStr(strInvTxt, "=") > 0 Then
            strKey = LCase(Left(strInvTxt, InStr(strInvTxt, "=") - 1))
            strValue = Mid(strInvTxt, InStr(strInvTxt, "=") + 1)
            If strKey = strArgument Then
                ReadCfgFile = LCase(strValue)
            End If
        End If
    Wend
    
    Close #intCfgFile
Else
    ReadCfgFile = ""
End If

End Function

Private Sub GroupSubTests(blnUseGrouping As Boolean)
    Dim lngCurRow As Long
    Dim lngChkRow As Long
    Dim lngHeaderRow As Long
    Dim lngLastSeqRow As Long
    Dim lngStartRecRow As Long
    Dim lngTestRow As Long
    Dim strTest As String
    Dim strSheetname As String
    Dim blnGroupedTest As Boolean
    Dim blnAllSubProcPresent As Boolean

    ' Grouping of ARE steps is handled differently for SRC_HW/NXE and for other platforms
    ' For other platforms:
    '   A group of tests contains a summary line, followed by the subtests.
    '   If ALL subtests have been given a procedure/MOID: show procedure per subtest, NOT for summary line
    '   Else show procedure for summary line, NOT for the subtests
    ' For SRC_HW/NXE:
    '   Grouping is used to show parallellism of steps.
    
    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

    On Error Resume Next

    ' Define settings for grouping
    With ActiveSheet.Outline
        .AutomaticStyles = False
        .SummaryRow = xlAbove
        .SummaryColumn = xlRight
    End With

    Range(fRows(lngStartRecRow + 1, lngLastSeqRow)).Select
    Selection.Rows.Ungroup

    lngCurRow = lngStartRecRow
    lngTestRow = lngStartRecRow
    strTest = "No name"
    blnGroupedTest = False

    While lngCurRow <= lngLastSeqRow
        If Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "S" Then
            blnGroupedTest = True
        ElseIf Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "P2" Then
            Range(fRange(lngCurRow, cTestNameCol, lngCurRow, cTestNameCol)).InsertIndent 2
            Range(fRange(lngCurRow, cATimeCol, lngCurRow, cATimeCol)).Font.Italic = True
        ElseIf Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "p" Then
            Range(fRange(lngCurRow, cTestNameCol, lngCurRow, cTestNameCol)).InsertIndent 1
            Range(fRange(lngCurRow, cTestNameCol, lngCurRow, cTestNameCol)).Font.Italic = True
        Else
            If blnGroupedTest Then
                Range(fRange(lngTestRow + 1, cTestNameCol, lngCurRow - 1, cTestNameCol)).InsertIndent 1
    
                If blnUseGrouping Then
                    Rows(fRows(lngTestRow + 1, lngCurRow - 1)).Group
                End If

                blnGroupedTest = False
                blnAllSubProcPresent = True

                For lngChkRow = lngTestRow + 1 To lngCurRow - 1
                    If Range(fCell(lngChkRow, cProcedureNameCol)) = "" Then
                        blnAllSubProcPresent = False
                        Exit For
                    End If
                Next lngChkRow

                If blnAllSubProcPresent Then
                    
                Else
                    For lngChkRow = lngTestRow + 1 To lngCurRow - 1
                        'MBTR: ARE-1295:
                        If Not Worksheets(strSheetname).Cells(lngChkRow, cProcedureNameCol).Hyperlinks.Count > 0 Then
                            Range(fCell(lngChkRow, cProcedureNameCol)) = ""
                        End If
                    Next lngChkRow

                    'MBTR: ARE-1295:
                    If Not Worksheets(strSheetname).Cells(lngCurRow - 1, cProcedureNameCol).Hyperlinks.Count > 0 Then
                            Range(fCell(lngCurRow - 1, cProcedureNameCol)) = ""
                        End If
                    
                End If
            End If

            If Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "Y" Then
                lngTestRow = lngCurRow
                Rows(fRows(lngTestRow)).Font.Italic = True
            End If

        End If
        lngCurRow = lngCurRow + 1
    Wend
End Sub

Public Function FindHeaderText(strText As String) As Integer

Dim lngHeaderRow As Long
Dim intCurCol As Integer
Dim strSheetname As String

FindHeaderRow lngHeaderRow
strSheetname = Range("areversion").Worksheet.Name

For intCurCol = 1 To 99
    If Worksheets(strSheetname).Cells(lngHeaderRow, intCurCol) = strText Then
        FindHeaderText = intCurCol
        Exit Function
    End If
Next intCurCol

End Function

Private Sub HandleGroupedTests()

Dim strPlatform As String

strPlatform = GetPlatformType(Worksheets("Source").Cells(1, 1))

If strPlatform <> "SRC_HW" Then
    GroupSubTests True
Else
    GroupSubTests False
End If

End Sub


Attribute VB_Name = "modCoachComments"
Option Explicit

Public Sub openCoachComments()
    Dim wsCom As Worksheet
    Dim wsRecovery As Worksheet
    Dim intCurRecRow As Integer
    Dim intCurComRow As Integer
    Dim procedure As String
    Dim Key As String
    Dim testName As String
    Dim procUrl As String
    Dim moids() As String
    Dim moids1() As String
    Dim moidIndex As Integer
    Dim moidPattern As Object
    Dim moidMatches As Object
    Dim moid As String
    Dim request As New WebRequest
    Dim response As WebResponse
    Dim client As New WebClient
    Dim i As Integer
    Dim commentId As String
    Dim commentStatus As String
        
    
    Application.ScreenUpdating = False

    Set wsCom = Worksheets("OpenComments")
    Set wsRecovery = Worksheets("Recovery")
    wsCom.Visible = True
    wsCom.Activate
    
    Set moidPattern = CreateObject("vbscript.regexp")
    moidPattern.Pattern = "moid=(\d*)"
    moidPattern.Global = True
    moidPattern.IgnoreCase = True
    moidIndex = 0
    intCurRecRow = recFirstSequenceRow
    wsCom.Hyperlinks.Delete
    wsCom.Range("A5:Z6000").ClearContents
    
    Do While Not recoveryRowEmpty(intCurRecRow)
        procedure = wsRecovery.Cells(intCurRecRow, recProcCol)
        If procedure <> "" Then
            procUrl = getUrl(wsRecovery, intCurRecRow)
            If procUrl <> "" Then
                Set moidMatches = moidPattern.Execute(procUrl)
                If moidMatches.Count > 0 Then
                    moid = moidMatches.Item(0).SubMatches.Item(0)
                    ReDim Preserve moids(moidIndex)
                    moids(moidIndex) = moid
                    moidIndex = moidIndex + 1
                End If
            End If
        End If
        intCurRecRow = intCurRecRow + 1
    Loop

    request.Method = WebMethod.HttpPost
    request.Format = WebFormat.Json
    request.Body = moids
    
    client.BaseUrl = "http://pc305805.eu.asml.com/SatServer/Comments/getMultipleOpenComments"
    Set response = client.Execute(request)
    If response.StatusCode = WebStatusCode.RequestTimeout Then
        MsgBox "Request Timeout: Probably not connected to ASML network"
    Else
        intCurRecRow = recFirstSequenceRow
        intCurComRow = 2
        Do While Not recoveryRowEmpty(intCurRecRow)
            procedure = wsRecovery.Cells(intCurRecRow, recProcCol)
            If procedure <> "" Then
                procUrl = getUrl(wsRecovery, intCurRecRow)
                If procUrl <> "" Then
                    wsCom.Hyperlinks.Add _
                        Anchor:=wsCom.Cells(intCurComRow, 1), _
                        Address:=procUrl, _
                        TextToDisplay:=procedure
                    wsCom.Cells(intCurComRow, 2) = wsRecovery.Cells(intCurRecRow, recTestNameCol)
                    wsCom.Cells(intCurComRow, 3) = wsRecovery.Cells(intCurRecRow, recKeyCol)
                    
                    
                    Set moidMatches = moidPattern.Execute(procUrl)
                    If moidMatches.Count > 0 Then
                        moid = moidMatches.Item(0).SubMatches.Item(0)
                        If response.StatusCode = WebStatusCode.Ok Then
                            For i = 1 To response.Data("data")(moid).Count
                                commentId = response.Data("data")(moid)(i)(2)
                                commentStatus = response.Data("data")(moid)(i)(1)
                                wsCom.Hyperlinks.Add _
                                    Anchor:=wsCom.Cells(intCurComRow, 3 + i), _
                                    Address:="https://comments.asml.com/cgi-bin/comments.cgi?rm=mode9&id=" & commentId, _
                                    TextToDisplay:=str(commentId)
                            Next
                        End If
                    Else
                        moid = ""
                    End If
                    
                    intCurComRow = intCurComRow + 1
                End If
            End If
            intCurRecRow = intCurRecRow + 1
        Loop
    End If

    Application.ScreenUpdating = True
End Sub

Private Function getUrl(ws As Worksheet, rowIndex As Integer) As String
    Dim result As String
    
    result = ""
    If ws.Cells(rowIndex, recProcCol).Hyperlinks.Count > 0 Then
        result = ws.Cells(rowIndex, recProcCol).Hyperlinks(1).Address
    End If
    getUrl = result
End Function




Attribute VB_Name = "modCombine"
Sub CombineSequences()

Dim strCopyFromFile As String
Dim wbCopyFrom As Workbook
Dim intFirstRow As Integer
Dim intLastRow As Integer
Dim intInsertRow As Integer
Dim blnSkipAllFollowing As Boolean
Dim strVersion As String
Dim strConfiguration As String
Dim blnStatus As Boolean

blnStatus = True

' Pick file to copy from
PickFile strCopyFromFile, , "Pick file to copy from:", "*.xls*"
If strCopyFromFile = "" Then Exit Sub

strVersion = Range("TKVersion").Text
strConfiguration = Range("configuration").Text

' Open file
Set wbCopyFrom = Workbooks.Open(strCopyFromFile, 0, True)

wbCopyFrom.Activate
' Check if this is a template file with the correct version
If Not CheckTemplateFile() Then
    MsgBox "This is not a regular template file, sequence merging is not possible.", vbOKOnly
    blnStatus = False
End If

If blnStatus And Not CheckTemplateFileVersion(strVersion) Then
    MsgBox "The template version is different. Merging may not work properly.", vbOKOnly
    blnStatus = False
End If

' Check configurations
If blnStatus And Not CheckConfiguration(strConfiguration) Then
    If MsgBox("The configuration is different. Do you want to continue anyway?", vbYesNo) = vbNo Then
        blnStatus = False
    End If
End If

strSheetname = GetRecoverySheetName
' Select lines
If blnStatus Then
    GetCopyLines wbCopyFrom, intFirstRow, intLastRow, blnStatus
End If

'Workbooks(strTemplate).Activate
ThisWorkbook.Activate

If blnStatus Then
    If intFirstRow > 0 And intLastRow > 0 Then
        ' Determine insertion point
        DetermineInsertionRow intInsertRow, blnSkipAllFollowing
        
'        Debug.Print intFirstRow, intLastRow, intInsertRow
        
        ' Paste
        If intInsertRow > 0 Then
'            CheckLastLineAction wbCopyFrom, intFirstRow, intLastRow, Workbooks(strTemplate), intInsertRow, blnSkipAllFollowing
            PasteRows wbCopyFrom, intFirstRow, intLastRow, Workbooks(strTemplate), intInsertRow, blnSkipAllFollowing
        End If
    End If
End If

wbCopyFrom.Close
SetShortKeys

End Sub

Public Function CheckTemplateFile() As Boolean

Dim strTmpVal As String
Dim strSheetname As String

On Error GoTo errCheckTemplateFile

strTmpVal = Range("areversion").Text
CheckTemplateFile = True
Exit Function

errCheckTemplateFile:
CheckTemplateFile = False
On Error GoTo 0

End Function

Private Function CheckTemplateFileVersion(strVersion As String) As Boolean

On Error GoTo errCheckTemplateFileVersion

CheckTemplateFileVersion = (strVersion = Range("TKVersion"))
Exit Function

errCheckTemplateFileVersion:
CheckTemplateFileVersion = False
On Error GoTo 0

End Function

Private Function CheckConfiguration(strConfiguration As String) As Boolean

On Error GoTo errCheckConfiguration

CheckConfiguration = (Trim(LCase(strConfiguration)) = Trim(LCase(Range("configuration"))))
Exit Function

errCheckConfiguration:
CheckConfiguration = False
On Error GoTo 0

End Function

Private Sub GetCopyLines(wbCopyFrom As Workbook, intFirstRow As Integer, intLastRow As Integer, blnStatus As Boolean)

Dim intCurFMS As Integer
Dim intNrFMS As Integer
Dim strFMS() As String
Dim strFromState As String
Dim intNrFromSteps As Integer
Dim strToState As String
Dim intNrToSteps As Integer
Dim strSheetname As String

GetAllFMS strFMS(), intNrFMS

Load frmSelectPartial

frmSelectPartial.Caption = "Select lines to copy from " & wbCopyFrom.Name
frmSelectPartial.lblSelectPartialFromState = "From functional state"
frmSelectPartial.lblSelectPartialFromStep = "First step"
frmSelectPartial.lblSelectPartialToState = "To functional state"
frmSelectPartial.lblSelectPartialToStep = "Last step"

frmSelectPartial.chkSelectPartialSkip.Visible = False

frmSelectPartial.cmbSelectPartialFromState.Clear
frmSelectPartial.cmbSelectPartialToState.Clear

For intCurFMS = 1 To intNrFMS
    frmSelectPartial.cmbSelectPartialFromState.AddItem strFMS(intCurFMS)
    frmSelectPartial.cmbSelectPartialToState.AddItem strFMS(intCurFMS)
Next intCurFMS

frmSelectPartial.chkSelectPartialFrom.Visible = True
frmSelectPartial.chkSelectPartialFrom.Value = True
frmSelectPartial.chkSelectPartialTo.Visible = True
frmSelectPartial.chkSelectPartialTo.Value = True

frmSelectPartial.Show 1

If blnOK Then
    If frmSelectPartial.chkSelectPartialFrom Then
        strFromState = "#Start#"
        intNrFromSteps = 0
    Else
        strFromState = frmSelectPartial.cmbSelectPartialFromState.Text
        intNrFromSteps = frmSelectPartial.cmbSelectPartialFromStep.ListIndex + 1
    End If
    
    If frmSelectPartial.chkSelectPartialTo Then
        strToState = "#End#"
        strToStep = ""
    Else
        strToState = frmSelectPartial.cmbSelectPartialToState.Text
        intNrToSteps = frmSelectPartial.cmbSelectPartialToStep.ListIndex + 1
    End If
    
    intFirstRow = FindSequenceStep(wbCopyFrom, strFromState, intNrFromSteps)
    intLastRow = FindSequenceStep(wbCopyFrom, strToState, intNrToSteps)

    intLastRow = CheckIfLastRowIsRecoveryFinished(wbCopyFrom, intLastRow)
    
    If intFirstRow > intLastRow Then
        MsgBox "This is not a valid selection, first row number is higher than last row number", vbOKOnly
        blnStatus = False
    End If
Else
    intFirstRow = -1
    intLastRow = -1
    blnStatus = False
End If

Unload frmSelectPartial

End Sub

Private Function FindSequenceStep(wbCopyFrom As Workbook, strState As String, intNrSteps As Integer) As Integer

Dim lngFirstRow As Long
Dim lngStartRecRow As Long
Dim lngLastRow As Long
Dim lngFMSRow As Long
Dim lngCurRow As Long
Dim strSheetname As String

FindSequenceLayout strSheetname, lngFirstRow, lngStartRecRow, lngLastRow

Select Case strState
Case Is = "#Start#"
    FindHeaderRow lngFirstRow
    FindSequenceStep = lngFirstRow + 1
Case Is = "#End#"
    FindHeaderRow lngFirstRow
    FindLastSequenceRow strSheetname, lngFirstRow + 1, lngLastRow
    FindSequenceStep = lngLastRow
Case Else
    lngFMSRow = FindSequenceRow(strSheetname, strState)
    If lngFMSRow < 0 Then
    ' Something's gone horribly wrong
        MsgBox "An error has occurred. The selected FMS is not found", vbOKOnly
        FindSequenceStep = -1
    Else
        FindSequenceStep = lngFMSRow + intNrSteps
    End If
End Select

End Function

Private Sub DetermineInsertionRow(intInsertRow As Integer, blnSkipAllFollowing As Boolean)

Dim intCurFMS As Integer
Dim intNrFMS As Integer
Dim strFMS() As String
Dim lngFMSRow As Long
Dim strSheetname As String
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long

strSheetname = Range("areversion").Worksheet.Name

GetAllFMS strFMS(), intNrFMS

Load frmSelectPartial
frmSelectPartial.Caption = "Select insertion row in " & Workbooks(strTemplate).Name
frmSelectPartial.chkSelectPartialSkip.Visible = True
frmSelectPartial.chkSelectPartialFrom.Visible = True
frmSelectPartial.chkSelectPartialFrom.Caption = "Append to current sequence"
frmSelectPartial.chkSelectPartialFrom.Value = False

frmSelectPartial.chkSelectPartialTo.Visible = False
frmSelectPartial.cmbSelectPartialToState.Visible = False
frmSelectPartial.cmbSelectPartialToStep.Visible = False

frmSelectPartial.lblSelectPartialFromState.Caption = "In functional state: "
frmSelectPartial.lblSelectPartialFromStep.Caption = "Insert after step: "
frmSelectPartial.lblSelectPartialToState.Visible = False
frmSelectPartial.lblSelectPartialToStep.Visible = False

For intCurFMS = 1 To intNrFMS
    frmSelectPartial.cmbSelectPartialFromState.AddItem strFMS(intCurFMS)
Next intCurFMS

frmSelectPartial.Show 1

If blnOK Then
    If frmSelectPartial.chkSelectPartialFrom.Value Then
        FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngFMSRow
        intInsertRow = lngFMSRow + 1
        blnSkipAllFollowing = False
    Else
        lngFMSRow = FindSequenceRow(strSheetname, frmSelectPartial.cmbSelectPartialFromState.Text)
        intInsertRow = lngFMSRow + frmSelectPartial.cmbSelectPartialFromStep.ListIndex + 1
        blnSkipAllFollowing = frmSelectPartial.chkSelectPartialSkip
    End If
    intInsertRow = CheckIfLastRowIsRecoveryFinished(Workbooks(strTemplate), intInsertRow)
Else
    intInsertRow = -1
End If

End Sub

Private Sub PasteRows(wbCopyFrom As Workbook, intStartRow As Integer, intEndRow As Integer, _
    wbCopyTo As Workbook, intInsertRow As Integer, blnSkipAllFollowing As Boolean)

Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim strSheetname As String

If blnSkipAllFollowing Then
    wbCopyTo.Activate
    strSheetname = Range("areversion").Worksheet.Name
    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    lngLastSeqRow = CLng(CheckIfLastRowIsRecoveryFinished(wbCopyTo, CInt(lngLastSeqRow)))
    Rows(fRows(CLng(intInsertRow + 1), lngLastSeqRow)).Delete Shift:=xlUp
End If

Application.DisplayAlerts = False

wbCopyFrom.Activate
Rows(fRows(CLng(intStartRow), CLng(intEndRow))).Copy
wbCopyTo.Activate
Rows(fRows(CLng(intInsertRow + 1))).Insert Shift:=xlDown

Application.DisplayAlerts = True

End Sub

Private Function CheckIfLastRowIsRecoveryFinished(wbCheck As Workbook, intLastRow As Integer)

Dim strSheetname As String
Dim lngFirstRow As Long
Dim lngStartRecRow As Long
Dim lngLastRow As Long

FindSequenceLayout strSheetname, lngFirstRow, lngStartRecRow, lngLastRow

If wbCheck.Worksheets(strSheetname).Cells(intLastRow, cTestIDCol) = "RECOVERY_FINISHED" Then
    If wbCheck.Worksheets(strSheetname).Cells(intLastRow - 1, cTestIDCol) = "" Then
        CheckIfLastRowIsRecoveryFinished = intLastRow - 2
    Else
        CheckIfLastRowIsRecoveryFinished = intLastRow - 1
    End If
Else
    CheckIfLastRowIsRecoveryFinished = intLastRow
End If

End Function

Attribute VB_Name = "modComments"
Public Sub ToggleShowComments()

Dim blnShowComments As Boolean
Dim strSheetname As String
Dim myHeader As tHeaderRecord
Dim strCommentsFile As String

On Error GoTo errToggleShowComments

strSheetname = GetRecoverySheetName

blnShowComments = (InStr(Worksheets(strSheetname).Range("status"), strCommentIndicator) = 0)
If Not blnShowComments Then
    HideComments strSheetname
    Worksheets(strSheetname).Range("status") = Replace(Worksheets(strSheetname).Range("status"), strCommentIndicator, "")
Else
    GetCommentsFile strCommentsFile
    If IsFile(strCommentsFile) Then
        ReadHeader myHeader
        ShowComments strSheetname, myHeader.recovery, strCommentsFile
        Worksheets(strSheetname).Range("status") = Worksheets(strSheetname).Range("status") & strCommentIndicator
    End If
End If

Exit Sub

errToggleShowComments:
If blnShowComments Then
    MsgBox "Error accessing comments file", vbOKOnly
End If

End Sub

Private Sub GetCommentsFile(strCommentsFile As String)
        
Dim strCommentsDir As String
        
If IsSheet("Source") Then
    strCommentsDir = Replace(Worksheets("Source").Cells(2, 1), "[DIR]", "")
    strCommentsFile = strCommentsDir & "\" & "AREComments.xls"
End If

If Not IsFile(strCommentsFile) Then
    PickFile strCommentsFile, "AREComments.xls", "Select ARE comments file: ", "*.xls"
End If

End Sub

Private Sub ShowComments(strSheetname As String, strSequence As String, _
    strCommentsFile As String)

Dim lngCurRow As Long
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim strKey As String
Dim intCommentRow As Integer
Dim intCommentCol As Integer
Dim intNoteCol As Integer
Dim strComment As String
Dim strNote As String
Dim strScenario As String
Dim wbComments As Workbook
Dim wsComments As Worksheet
Dim blnScenarioExactMatch As Boolean

blnScenarioExactMatch = False

On Error GoTo errShowComments

If Not IsFile(strCommentsFile) Then
    Exit Sub
End If

SetTemplateNameDir
Application.ScreenUpdating = False

Set wbComments = Workbooks.Open(strCommentsFile, 0, True)
Set wsComments = wbComments.Worksheets("Comments")

Workbooks(strTemplate).Activate

strScenario = GetScenarioList(strSequence)
intCommentCol = wsComments.Range("CommentsText").Column
intNoteCol = wsComments.Range("Notes").Column

FindHeaderRow lngHeaderRow
FindLastSequenceRow strSheetname, lngHeaderRow + 1, lngLastSeqRow

For lngCurRow = lngHeaderRow + 1 To lngLastSeqRow
    strKey = Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol)
        
    intCommentRow = FindCommentRow(strScenario, strKey, wsComments, blnScenarioExactMatch)
    If intCommentRow > 0 Then
        strComment = wsComments.Cells(intCommentRow, intCommentCol)
        If intNoteCol > 0 Then
            strNote = wsComments.Cells(intCommentRow, intNoteCol)
        Else
            strNote = "Comment"
        End If
        If Trim(strComment) <> "" Then
        ' Show comment
            If HasComment(Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol)) Then
                Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).ClearComments
            End If
            Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).AddComment
            Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).Comment.Visible = False
            Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).Comment.Text Text:=strComment
        ' Format: orange pattern
            With Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).Interior
                .Pattern = xlSolid
                .PatternColorIndex = xlAutomatic
                .Color = 49407
                .TintAndShade = 0
                .PatternTintAndShade = 0
            End With
        End If
        If Trim(strNote) <> "" Then
            Worksheets(strSheetname).Cells(lngCurRow, cCommentsProcedureCol) = strNote
        ' Format: red pattern, white bold font
            With Worksheets(strSheetname).Cells(lngCurRow, cCommentsProcedureCol)
                With .Interior
                    .Pattern = xlSolid
                    .PatternColorIndex = xlAutomatic
                    .Color = 255
                    .TintAndShade = 0
                    .PatternTintAndShade = 0
                End With
                With .Font
                    .ThemeColor = xlThemeColorDark1
                    .TintAndShade = 0
                    .Bold = True
                End With
            End With
        End If
    End If
Next lngCurRow

Application.ScreenUpdating = True

blnDisplayAlerts = Application.DisplayAlerts
Application.DisplayAlerts = False
wbComments.Close
Application.DisplayAlerts = blnDisplayAlerts

Exit Sub

errShowComments:
MsgBox "Cannot read comments from file", vbOKOnly

End Sub

Public Function GetScenarioList(strSequence As String) As String

Dim intArrInd As Integer
Dim strList() As String
Dim strSeqList As String

On Error GoTo errGetScenarioList

strList = Split(strSequence, vbCrLf)
strSeqList = ""
For intArrInd = 0 To UBound(strList)
    If intArrInd >= 1 Then strSeqList = strSeqList & "#"
    If InStr(strList(intArrInd), "[") > 0 Then
        strSeqList = strSeqList & Trim(Left(strList(intArrInd), InStr(strList(intArrInd), "[") - 1))
    Else
        strSeqList = strSeqList & strList(intArrInd)
    End If
Next intArrInd

GetScenarioList = strSeqList

Exit Function

errGetScenarioList:
GetScenarioList = ""

End Function

Private Function FindCommentRow(strScenario As String, strKey As String, wsComments As Worksheet, blnExact As Boolean) As Integer

Dim intCurRow As Integer
Dim intScenInd As Integer
Dim strScenarioList() As String

If blnExact Then
    FindCommentRow = FindComment(strScenario & "|" & strKey, wsComments)
Else
    strScenarioList = Split(strScenario, "#")
    For intScenInd = 0 To UBound(strScenarioList)
        intCurRow = FindComment(strScenarioList(intScenInd) & "|" & strKey, wsComments)
        If intCurRow > 0 Then
            FindCommentRow = intCurRow
            Exit Function
        End If
    Next intScenInd
End If

FindCommentRow = -1

End Function

Private Function FindComment(strText As String, wsComments As Worksheet) As Integer

Set c = wsComments.Cells.Find(What:=strText, After:=wsComments.Cells(1, 1), LookIn:=xlValues, _
    Lookat:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, _
    MatchCase:=False, SearchFormat:=False)

If c Is Nothing Then
    FindComment = -1
Else
    FindComment = c.row
End If

End Function

Private Sub HideComments(strSheetname As String)

Dim lngCurRow As Long
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long

Application.ScreenUpdating = False

FindHeaderRow lngHeaderRow
FindLastSequenceRow strSheetname, lngHeaderRow + 1, lngLastSeqRow

For lngCurRow = lngHeaderRow + 1 To lngLastSeqRow
    If Worksheets(strSheetname).Cells(lngCurRow, cCommentsProcedureCol) <> "" Then
        If HasComment(Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol)) Then
            Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).ClearComments
        End If
        Worksheets(strSheetname).Cells(lngCurRow, cCommentsProcedureCol) = ""
        With Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).Interior
            .Pattern = xlNone
            .TintAndShade = 0
            .PatternTintAndShade = 0
        End With
        With Worksheets(strSheetname).Cells(lngCurRow, cCommentsProcedureCol)
            With .Interior
                .Pattern = xlNone
                .TintAndShade = 0
                .PatternTintAndShade = 0
            End With
            With .Font
                .ThemeColor = xlThemeColorLight1
                .TintAndShade = 0
                .Bold = False
            End With
        End With
    End If
Next lngCurRow

Application.ScreenUpdating = True

End Sub

Public Function HasComment(strRange As Range) As Boolean

Dim cmt As Object
On Error Resume Next

Set cmt = strRange.Comment
HasComment = Not (cmt Is Nothing)

End Function

Public Sub ExportComments()

Dim strRplChr As String
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long
Dim strScenario As String
Dim strKey As String
Dim strNote As String
Dim strComment As String
Dim intOutFile As Integer
Dim strSheetname As String

strRplChr = "#"

On Error GoTo errExportComments

strSheetname = Range("AreVersion").Worksheet.Name

intOutFile = FreeFile
Open strSourceDir & "AREComments.txt" For Append As #intOutFile

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
strScenario = Range("Recovery")
For lngCurRow = lngHeaderRow + 1 To lngLastSeqRow
    strKey = Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol)
    strNote = Worksheets(strSheetname).Cells(lngCurRow, cCommentsProcedureCol)
    If HasComment(Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol)) Then
        strComment = Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol).Comment.Text
        strComment = Replace(Replace(strComment, Chr(10), strRplChr), vbCrLf, strRplChr)
    Else
        strComment = ""
    End If
    If strNote <> "" Or strComment <> "" Then
        Write #intOutFile, strScenario & "|" & strKey & "||" & strNote & "|" & strComment
        Debug.Print strScenario & "|" & strKey & "||" & strNote & "|" & strComment
    End If
Next lngCurRow

Close #intOutFile

errExportComments:
Close #intOutFile

End Sub

Public Sub CustomizeSequence()

Dim lngCurRow As Long
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim strKey As String
Dim strScenario As String
Dim wbComments As Workbook
Dim wsComments As Worksheet
Dim strSheetname As String
Dim myHeader As tHeaderRecord
Dim intNrSkip As Integer
Dim strCommentsFile As String

On Error GoTo errCustomizeSequence
    
ReadHeader myHeader

' Skip lines that you don't need, as defined in AREComments.xls
GetCommentsFile strCommentsFile
If Not IsFile(strCommentsFile) Then
    Exit Sub
End If

SetTemplateNameDir
strSheetname = "Recovery"

Application.ScreenUpdating = False

Set wbComments = Workbooks.Open(strCommentsFile, 0, True)
Set wsComments = wbComments.Worksheets("Skip")

Workbooks(strTemplate).Activate

' Only in case of PEP sequence

strScenario = Trim(Left(myHeader.recovery, InStr(myHeader.recovery, "[") - 1))

intNrSkip = 0
FindHeaderRow lngHeaderRow
FindLastSequenceRow strSheetname, lngHeaderRow + 1, lngLastSeqRow
    
For lngCurRow = lngHeaderRow + 1 To lngLastSeqRow
        'If not FMS, check if line must be hidden
    If Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "" Then
        strFMS = Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol)
    Else
        strKey = Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol)
        intSkipRow = FindComment(strScenario & "|" & strFMS & "|" & strKey, wsComments)
        If intSkipRow > 0 Then
            Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "delete"
        End If
    End If
Next lngCurRow
For lngCurRow = lngLastSeqRow To lngHeaderRow + 1 Step -1
    If Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "delete" Then
        Worksheets(strSheetname).Rows(fRows(lngCurRow, lngCurRow)).Delete Shift:=xlUp
        intNrSkip = intNrSkip + 1
    End If
    If Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "" And _
        Worksheets(strSheetname).Cells(lngCurRow + 1, cTestIDCol) = "" And _
        Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol) <> "" Then
        'If FMS, check if not empty
        Worksheets(strSheetname).Rows(fRows(lngCurRow, lngCurRow)).Delete Shift:=xlUp
    End If
        
Next lngCurRow

Application.ScreenUpdating = True

blnDisplayAlerts = Application.DisplayAlerts
Application.DisplayAlerts = False
wbComments.Close
Application.DisplayAlerts = blnDisplayAlerts

If intNrSkip > 0 Then
    MsgBox intNrSkip & " steps have been removed from the sequence.", vbOKOnly
End If

' RepairRecoverySequence True, True, False

Exit Sub

errCustomizeSequence:
MsgBox "Cannot read comments from file", vbOKOnly

End Sub







Attribute VB_Name = "modCompare"
Public Const clrFontStepMoved As Integer = 5
Public Const clrFontStepAdded As Integer = 10
Public Const clrFontStepRemoved As Integer = 3
Public Const clrPatternStepMoved As Integer = 37
Public Const clrPatternStepAdded As Integer = 35
Public Const clrPatternStepRemoved As Integer = 40

Public Type test
    Name As String
    Repeats As Integer
    duration As Single
    StartRow As Long
    details As String
End Type

Public Type CmbTest
    RefTest As test
    ActTest As test
    CombiMode As Integer
End Type

Public NoTest As test

Public Sub ToggleShowDifferencesWithOriginal()

If IsSheet("Source") Then
    ToggleShowDifferences True, False
Else
    MsgBox "Cannot compare sequence, source sheet not found", vbOKOnly
End If

End Sub

Public Sub ToggleShowFullDifferencesWithOriginal()

If IsSheet("Source") Then
    ToggleShowDifferences True, True
Else
    MsgBox "Cannot compare sequence, source sheet not found", vbOKOnly
End If

End Sub

Public Sub ToggleShowDifferencesWithOtherFile()

ToggleShowDifferences False, False

End Sub

Public Sub ToggleShowFullDifferencesWithOtherFile()

ToggleShowDifferences False, True

End Sub

Public Sub ToggleShowDifferences(blnUseSourceSheet As Boolean, blnFullCompare As Boolean)

Dim strSheetname As String

Application.ScreenUpdating = False

strSheetname = GetRecoverySheetName

If strSheetname <> "" Then
    If ActiveSheet.Name <> strSheetname Then
        Worksheets(strSheetname).Activate
    End If
    
    If InStr(Range("status"), strCompareIndicator) = 0 Then
        ShowDifferences blnUseSourceSheet, blnFullCompare
    Else
        HideDifferences
    End If
    
    Worksheets(strSheetname).Range("A1").Select
End If

Application.ScreenUpdating = True

End Sub

Public Sub ShowDifferences(blnUseSourceSheet As Boolean, blnFullCompare As Boolean)

Dim TestArr1() As test
Dim TestArr2() As test
ReDim CmbTestArr(2, 0 To 0) As CmbTest
Dim strSheetname As String
Dim wbCompare As Workbook
Dim strTKVersion As String
Dim strCfg As String
Dim strFileName As String
Dim strCompareSheetName As String

On Error GoTo errShowDifferences

WriteDebug "Start ShowDifferences"
WriteDebug "Use source sheet: " & blnUseSourceSheet
WriteDebug "Full compare mode: " & blnFullCompare

strSheetname = ActiveSheet.Name

NoTest.Name = ""
NoTest.Repeats = 0
NoTest.duration = 0

' Create array with keys from original sequence
If blnUseSourceSheet Then
    ReadSequence "seq", "Source", TestArr1(), blnFullCompare
Else
    strTKVersion = Range("tkversion")
    strCfg = Range("configuration")
    
' Pick sequence file
    PickFile strFileName, "", "File to compare: ", "*.xls*"
    If strFileName = "" Then
        Exit Sub
    End If
    
    Set wbCompare = Workbooks.Open(strFileName, 0, True)
    wbCompare.Activate
    
' Check TK versions
    If Not CheckTemplateFile Then
        MsgBox "File not recognized as regular COI file", vbOKOnly
        wbCompare.Close
        Exit Sub
    End If
    
    If strTKVersion <> Range("tkversion") Then
        If MsgBox("COI formats are different, results may be incorrect" & vbCrLf & "Do you want to continue?", vbYesNo) = vbNo Then
            wbCompare.Close
            Exit Sub
        End If
    End If
    
' Check configuration
    strCompareSheetName = Range("areversion").Worksheet.Name
    ReadSequence "COI", strCompareSheetName, TestArr1(), blnFullCompare

    Workbooks(strTemplate).Activate
    wbCompare.Close
End If

' Create array with keys from actual sequence
ReadSequence "COI", strSheetname, TestArr2(), blnFullCompare

' Compare sequences
Application.StatusBar = "Busy..."

'If blnDebugMode Then
    WriteSequence TestArr1(), TestArr2()
'End If

Compare TestArr1(), TestArr2(), CmbTestArr(), 0
SetCombiTestMode CmbTestArr()
OptimizeMatch CmbTestArr()

' Show differences in actual sheet
ShowSequenceDifferences strSheetname, CmbTestArr()
    
Exit Sub

errShowDifferences:

End Sub

Private Sub WriteSequence(TestArr1() As test, TestArr2() As test)

Dim intNrTest1 As Integer
Dim intNrTest2 As Integer
Dim strText As String
intNrTest1 = UBound(TestArr1)
intNrTest2 = UBound(TestArr2)

For i = 1 To matMax(intNrTest1, intNrTest2)
    strText = String(72, " ")
    If i <= intNrTest1 Then
        Mid(strText, 1, Len(TestArr1(i).Name)) = TestArr1(i).Name
    Else
        Mid(strText, 1, 1) = "-"
    End If
    If i <= intNrTest2 Then
        Mid(strText, 37, Len(TestArr2(i).Name)) = TestArr2(i).Name
    Else
        Mid(strText, 37, 1) = "-"
    End If
    WriteDebug strText
'    Debug.Print strText
Next i

End Sub

Public Sub HideDifferences()

Dim lngCurRow As Long
Dim strSheetname As String
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long

On Error GoTo errHideDifferences

strSheetname = GetRecoverySheetName

If strSheetname <> "" Then
    FindSequenceLayout strSheetname, lngCurRow, lngStartRecRow, lngLastSeqRow
    lngCurRow = lngCurRow + 2
    
    Do While Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol) <> "" Or Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) <> ""
        Select Case Worksheets(strSheetname).Cells(lngCurRow, cSeqCheckCol)
            Case Is = "Moved", "Added"
                If StepIsFMS(strSheetname, lngCurRow) Then
                    SetSequenceRowFormat lngCurRow, 36, 1, True, 1
                Else
                    SetSequenceRowFormat lngCurRow, xlNone, 1
                End If
                Worksheets(strSheetname).Cells(lngCurRow, cSeqCheckCol) = ""
                lngCurRow = lngCurRow + 1
            Case Is = "Removed"
                Range(fRow(lngCurRow)).Select
                Selection.Delete Shift:=xlUp
            Case Else
                lngCurRow = lngCurRow + 1
        End Select
    Loop
    
    Range("status") = Replace(Range("status"), strCompareIndicator, "")
End If

Exit Sub

errHideDifferences:
Resume Next
End Sub

Private Sub ReadSequence(strType As String, strSheetname As String, TestArr() As test, blnFullCompare As Boolean)

Dim lngCurRow As Long
Dim intArrInd As Integer
Dim lngMinRow As Long
Dim lngStartRecRow As Long
Dim lngTmpRow As Long
Dim strTxt As String
Dim strKey As String
Dim lngLastSeqRow As Long
Dim sglBFactor As Single
Dim strChuckType As String
Dim strDetails As String

intArrInd = 0

WriteDebug "Start read sequence, strType = " & strType
' Debug.Print "Start read sequence, strType = " & strType

If LCase(strType) = "coi" Then
        
    FindSequenceLayout strSheetname, lngMinRow, lngStartRecRow, lngLastSeqRow
    
    sglBFactor = Worksheets(strSheetname).Range(fCell(cA2BFactorRow, cPlannedTimeCol))
    
    For lngCurRow = lngMinRow + 2 To lngLastSeqRow
        If Trim(Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol)) <> "" Then
            If blnFullCompare Then
                strChuckType = Worksheets(strSheetname).Cells(lngCurRow, cPerChuckCol)
                If strChuckType = "" Then strChuckType = " "
                
                strKey = Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) & "#" & _
                    Worksheets(strSheetname).Cells(lngCurRow, cProcedureNameCol) & "#" & _
                    strChuckType & "#" & _
                    Format(Worksheets(strSheetname).Cells(lngCurRow, cATimeCol) / sglBFactor, "###0")
            Else
                strKey = Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol)
            End If
            AddKey TestArr(), intArrInd, strKey, "", 0, 1, CInt(lngCurRow)
        ElseIf Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "Y" Then
            AddKey TestArr(), intArrInd, "StartGroupedTest", "", 0, 1, CLng(lngCurRow)
        ElseIf Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol) <> "" Then
            AddKey TestArr(), intArrInd, "FMS: " & Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol), "", 0, 1, CInt(lngCurRow)
        Else
            AddKey TestArr(), intArrInd, "[Empty row " & lngCurRow & "]", "", 0, 1, CLng(lngCurRow)
        End If
    Next lngCurRow

ElseIf LCase(strType) = "seq" Then
    
    lngCurRow = 1
    lngMinRow = 0
    
    Do While Worksheets(strSheetname).Cells(lngCurRow, 1) <> ""
        If Left(Worksheets(strSheetname).Cells(lngCurRow, 1), 7) = "[INPUT]" Then
            strTxt = Replace(Worksheets(strSheetname).Cells(lngCurRow, 1), "[INPUT]", "")
            If InStr(strTxt, "AUTOMATIC GENERATED RECOVERY") > 0 Then
    ' skip
            ElseIf InStr(strText, "##<Group") = 0 And (InStr(strTxt, "##") = 1 Or InStr(strTxt, "$$") > 0) Then
    ' skip
            ElseIf InStr(strTxt, "===") > 0 Then
                lngMinRow = lngCurRow + 1
            ElseIf InStr(strTxt, "FMS COMPLETE:") > 0 Then
                If lngMinRow > 0 And lngCurRow > lngMinRow Then
                    AddKey TestArr(), intArrInd, Replace(strTxt, "FMS COMPLETE: ", ""), "", 0, 1, lngCurRow
                    For lngTmpRow = lngMinRow To lngCurRow - 1
                        If InStr(Worksheets(strSheetname).Cells(lngTmpRow, 1), "##</Group") = 0 Then
                            If blnFullCompare Then
                                GetSequenceKey strKey, Worksheets(strSheetname).Cells(lngTmpRow, 1)
                            Else
                                strKey = Worksheets(strSheetname).Cells(lngTmpRow, 1)
                                If InStr(strKey, "##<Group") > 0 Then
                                    strKey = "StartGroupedTest"
                                Else
                                    strKey = Replace(strKey, "[INPUT]", "")
                                    If InStr(strKey, " ") > 0 Then
                                        strDetails = Mid(strKey, InStr(strKey, " ") + 1)
                                        strKey = Left(strKey, InStr(strKey, " ") - 1)
                                    Else
                                        strDetails = ""
                                    End If
                                    If strKey = "Grouped" Then strKey = " "
                                End If
                            End If
                            AddKey TestArr(), intArrInd, strKey, strDetails, 0, 1, lngTmpRow
                        End If
                    Next lngTmpRow
                End If
                lngMinRow = lngCurRow + 1
            Else
                If lngMinRow = 0 Then
                    lngMinRow = lngCurRow
                End If
            End If
        End If
        
        lngCurRow = lngCurRow + 1
    Loop
End If

End Sub

Private Sub ReadOriginalSequence(strSheetname As String, TestArr() As test)

Dim intCurRow As Integer
Dim intArrInd As Integer
Dim intMinRow As Integer
Dim intTmpRow As Integer
Dim strTxt As String
Dim strKey As String

intCurRow = 1
intArrInd = 0
intMinRow = 0

Do While Worksheets(strSheetname).Cells(intCurRow, 1) <> ""
    If Left(Worksheets(strSheetname).Cells(intCurRow, 1), 7) = "[INPUT]" Then
        strTxt = Replace(Worksheets(strSheetname).Cells(intCurRow, 1), "[INPUT]", "")
        If InStr(strTxt, "AUTOMATIC GENERATED RECOVERY") > 0 Then
' skip
        ElseIf InStr(strTxt, "##") = 1 Or InStr(strTxt, "$$") > 0 Then
' skip
        ElseIf InStr(strTxt, "=") > 0 Then
            intMinRow = intCurRow + 1
        ElseIf InStr(strTxt, "FMS COMPLETE:") > 0 Then
            If intMinRow > 0 And intCurRow > intMinRow Then
                AddKey TestArr(), intArrInd, Replace(strTxt, "FMS COMPLETE: ", ""), 0, 1, intCurRow
                For intTmpRow = intMinRow To intCurRow - 1
                    strKey = Worksheets(strSheetname).Cells(intTmpRow, 1)
                    strKey = Replace(strKey, "[INPUT]", "")
                    If InStr(strKey, " ") > 0 Then
                        strKey = Left(strKey, InStr(strKey, " ") - 1)
                    End If
                    If strKey = "Grouped" Then strKey = " "
                    AddKey TestArr(), intArrInd, strKey, 0, 1, intTmpRow
                Next intTmpRow
            End If
            intMinRow = intCurRow + 1
        Else
            If intMinRow = 0 Then
                intMinRow = intCurRow
            End If
            
        End If
    End If
    
    intCurRow = intCurRow + 1
Loop

End Sub

Private Sub ReadActualSequence(strSheetname As String, TestArr() As test)

Dim lngCurRow As Long
Dim lngStartRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim intArrInd As Integer

FindSequenceLayout strSheetname, lngStartRow, lngStartRecRow, lngLastSeqRow
intArrInd = 0

For lngCurRow = lngStartRow + 2 To lngLastSeqRow
    If Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) <> "" Then
        AddKey TestArr(), intArrInd, Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol), 0, 1, CInt(lngCurRow)
    ElseIf Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol) <> "" Then
        AddKey TestArr(), intArrInd, "FMS: " & Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol), 0, 1, CInt(lngCurRow)
    Else
        AddKey TestArr(), intArrInd, "[Empty row " & lngCurRow & "]", 0, 1, CLng(intCurRow)
    End If
Next lngCurRow

End Sub

Private Sub AddKey(TestArr() As test, intArrInd As Integer, _
    strKey As String, strDetails As String, intDuration As Integer, intRepeats As Integer, lngRow As Long)
                    
intArrInd = intArrInd + 1
ReDim Preserve TestArr(intArrInd) As test
With TestArr(intArrInd)
    If InStr(strKey, "##") > 0 Then
        .Name = UCase(Left(strKey, InStr(strKey, "##") - 1))
    Else
        .Name = UCase(strKey)
    End If
    .duration = intDuration
    .Repeats = intRepeats
    .StartRow = lngRow
    .details = strDetails
    
    WriteDebug "Added key: " & .Name
'    Debug.Print "Added key: " & .Name, intArrInd
End With

End Sub

Public Sub Compare(TestArr1() As test, TestArr2() As test, CmbTest() As CmbTest, intLevel As Integer)

Dim i As Integer
Dim j As Integer
Dim intLen1 As Integer
Dim intLen2 As Integer
Dim TestSubArr1() As test
Dim TestSubArr2() As test
Dim intArrID As Integer
Dim intSeqLen As Integer
Dim intMinLen As Integer
Dim TestCurCmbArr() As CmbTest
Dim TestMinCmbArr() As CmbTest
Dim TestSubCmbArr() As CmbTest
Dim blnGevonden As Boolean

Dim intMin As Integer
Dim intMax As Integer

intLen1 = UBound(TestArr1)
intLen2 = UBound(TestArr2)

On Error GoTo errCompare

If intLen1 = 0 Then
    ReDim CmbTest(intLen2) As CmbTest
    For k = 1 To intLen2
        CmbTest(k).RefTest = NoTest
        CmbTest(k).ActTest = TestArr2(k)
    Next k
    Exit Sub
ElseIf intLen2 = 0 Then
    ReDim CmbTest(intLen1) As CmbTest
    For k = 1 To intLen1
        CmbTest(k).RefTest = TestArr1(k)
        CmbTest(k).ActTest = NoTest
    Next k
    Exit Sub
End If

blnGevonden = False
intMinLen = intLen1 + intLen2 + 1

GetSearchRange TestArr1(), TestArr2(), intMin, intMax

For i = intMax To intMin Step -1
    For j = 1 To intLen1 - i + 1
        ReDim TestCurCmbArr(0) As CmbTest
        
        SubArray TestSubArr1(), TestArr1(), j, i + j - 1
        SubArray TestSubArr2(), TestArr2(), 1, intLen2
        
        intArrID = ArrayCompare(TestSubArr1, TestSubArr2)
        If intArrID > 0 Then
            blnGevonden = True
            SubArray TestSubArr1(), TestArr1(), 1, j - 1
            SubArray TestSubArr2(), TestArr2(), 1, intArrID - 1
            Compare TestSubArr1(), TestSubArr2(), TestCurCmbArr(), intLevel + 1
            
            intSeqLen = UBound(TestCurCmbArr)
            ReDim Preserve TestCurCmbArr(intSeqLen + i) As CmbTest
            For k = 1 To i
                TestCurCmbArr(intSeqLen + k).RefTest = TestArr1(k + j - 1)
                TestCurCmbArr(intSeqLen + k).ActTest = TestArr2(k + intArrID - 1)
            Next k
            
            SubArray TestSubArr1(), TestArr1(), i + j, intLen1
            SubArray TestSubArr2(), TestArr2(), intArrID + i, intLen2
            Compare TestSubArr1(), TestSubArr2(), TestSubCmbArr(), intLevel + 1
        
            intSeqLen = UBound(TestCurCmbArr)
            ReDim Preserve TestCurCmbArr(intSeqLen + UBound(TestSubCmbArr))
            For k = 1 To UBound(TestSubCmbArr)
                TestCurCmbArr(intSeqLen + k) = TestSubCmbArr(k)
            Next k
        Else
            intSeqLen = UBound(TestCurCmbArr)
            ReDim Preserve TestCurCmbArr(intSeqLen + intLen1 + intLen2) As CmbTest
            For k = 1 To intLen1
                TestCurCmbArr(intSeqLen + k).RefTest = TestArr1(k)
            Next k
            For k = 1 To intLen2
                TestCurCmbArr(intSeqLen + intLen1 + k).ActTest = TestArr2(k)
            Next k

        End If
        
        intCurLen = UBound(TestCurCmbArr)
        
        If intCurLen < intMinLen Then
            intMinLen = intCurLen
            TestMinCmbArr = TestCurCmbArr
            
            If intLevel = 0 Then
                WriteDebug "Shortest sequence so far: " & UBound(TestMinCmbArr) & " steps"
            End If
            
        End If
    
    Next j
    If blnGevonden Then
        Exit For
    End If
Next i

CmbTest = TestMinCmbArr

Exit Sub
errCompare:
MsgBox "Error: " & err.Description
Resume
End

End Sub

Private Sub GetSearchRange(TestArr1() As test, TestArr2() As test, intMin As Integer, intMax As Integer)

Dim intLen1 As Integer
Dim intCurLen As Integer

On Error GoTo errGetSearchRange

intLen1 = UBound(TestArr1)
If intLen1 < 10 Then
    intMin = 1
    intMax = intLen1
    Exit Sub
End If

intMinLen = 1
intMaxLen = intLen1
intCurLen = (intMinLen + intMaxLen) \ 2
While intCurLen > intMinLen And intCurLen < intMaxLen
    If HasSubRange(TestArr1(), TestArr2(), intCurLen) Then
'        Debug.Print intMinLen, intMaxLen, intCurLen, True
        intMinLen = intCurLen
    Else
'        Debug.Print intMinLen, intMaxLen, intCurLen, False
        intMaxLen = intCurLen
    End If
    intCurLen = (intMinLen + intMaxLen) \ 2
Wend

intMax = intCurLen + 1
If intMax < 10 Then
    intMin = 1
Else
    intMin = intMax - 10
End If

Exit Sub

errGetSearchRange:
MsgBox err.Description
Resume
End Sub

Private Function HasSubRange(TestArr1() As test, TestArr2() As test, intArrLen As Integer)

On Error GoTo errHasSubRange

Dim i As Integer
Dim intLen1 As Integer
Dim intArrInd As Integer
Dim TestSubArr() As test

intLen1 = UBound(TestArr1)
For i = 1 To intLen1 - intArrLen + 1
    SubArray TestSubArr(), TestArr1(), i, i + intArrLen - 1
    intArrInd = ArrayCompare(TestSubArr, TestArr2)
    If intArrInd > 0 Then
        HasSubRange = True
'        Debug.Print intArrInd, intArrLen
        Exit Function
    End If
Next i
HasSubRange = False

Exit Function

errHasSubRange:
MsgBox err.Description
Resume
End Function

Private Sub SubArray(TestNewArr() As test, TestRefArr() As test, intMin As Integer, intMax As Integer)

ReDim TestNewArr(0 To intMax - intMin + 1) As test
Dim i As Integer

For i = intMin To intMax
    TestNewArr(i - intMin + 1) = TestRefArr(i)
Next i

End Sub

Private Function ArrayCompare(TestArr1() As test, TestArr2() As test) As Integer

Dim strTxt1 As String
Dim strTxt2 As String
Dim lngChrInd As Long
Dim i As Integer

On Error GoTo errArrayCompare

strTxt1 = "|"
strTxt2 = "|"
For i = 1 To UBound(TestArr1)
    strTxt1 = strTxt1 & TestArr1(i).Name & "|"
Next i
For i = 1 To UBound(TestArr2)
    strTxt2 = strTxt2 & TestArr2(i).Name & "|"
Next i

lngChrInd = InStr(strTxt2, strTxt1)
If lngChrInd = 0 Then
    ArrayCompare = 0
Else
'    Debug.Print "Found "; strTxt1; " in "; strTxt2
    ArrayCompare = StrCount(Left(strTxt2, lngChrInd), "|")
End If

Exit Function

errArrayCompare:
MsgBox err.Description
Resume

End Function

Public Function StrCount(ByVal strTmpTxt As String, strChr As String) As Integer

Dim intTmpVal As Integer
Dim intChrInd As Integer

intTmpVal = 0
intChrInd = InStr(strTmpTxt, strChr)

While intChrInd > 0
    strTmpTxt = Mid(strTmpTxt, InStr(strTmpTxt, strChr) + 1)
    intTmpVal = intTmpVal + 1
    intChrInd = InStr(strTmpTxt, strChr)
Wend

StrCount = intTmpVal

End Function

Private Sub ReadArray(strSheetname As String, intColID As Integer, intStartRow As Integer, _
    TestArr() As test, Optional blnSkipRepeats As Boolean = False, _
    Optional intMinDurCol As Integer = -1)

Dim lngCurRow As Long
Dim intArrInd As Integer
Dim blnInclude As Boolean
Dim strPrevTest As String

lngCurRow = intStartRow
intArrInd = 0
While Worksheets(strSheetname).Cells(lngCurRow, intColID) <> ""
    If intMinDurCol > 0 Then
        blnInclude = (Worksheets(strSheetname).Cells(lngCurRow, intMinDurCol) > 1)
    Else
        blnInclude = True
    End If
    
    If blnInclude Then
        If blnSkipRepeats And Worksheets(strSheetname).Cells(lngCurRow, intColID) = strPrevTest Then
            With TestArr(intArrInd)
                .Repeats = .Repeats + 1
                .duration = 0
            End With
        Else
            intArrInd = intArrInd + 1
            ReDim Preserve TestArr(intArrInd) As test
            With TestArr(intArrInd)
                .Name = Worksheets(strSheetname).Cells(lngCurRow, intColID)
                .Repeats = 1
                .duration = 0
                .StartRow = lngCurRow
            End With
        End If
        strPrevTest = Worksheets(strSheetname).Cells(lngCurRow, intColID)
    End If
    lngCurRow = lngCurRow + 1
Wend

End Sub

Private Sub ShowSequenceDifferences(strSheetname As String, TestCmbArr() As CmbTest)

Dim i As Integer

Dim intFontColorIndex(4) As Integer
Dim intPatternColorIndex(4) As Integer
Dim blnNoDiff As Boolean
Dim lngHeaderRow As Long
Dim intStartRow As Integer
Dim lngCurRow As Long
Dim strType(4) As String
Dim blnFMS As Boolean

intFontColorIndex(1) = 1
intFontColorIndex(2) = clrFontStepMoved
intFontColorIndex(3) = clrFontStepAdded
intFontColorIndex(4) = clrFontStepRemoved

intPatternColorIndex(1) = 1
intPatternColorIndex(2) = clrPatternStepMoved
intPatternColorIndex(3) = clrPatternStepAdded
intPatternColorIndex(4) = clrPatternStepRemoved

strType(1) = ""
strType(2) = "Moved"
strType(3) = "Added"
strType(4) = "Removed"

blnNoDiff = True

FindHeaderRow lngHeaderRow
lngCurRow = lngHeaderRow + 2

On Error GoTo 0

For i = 1 To UBound(TestCmbArr())
    blnFMS = False
    If TestCmbArr(i).CombiMode = 4 Then 'removed
        Application.EnableEvents = False
        Range(fRow(lngCurRow)).Insert Shift:=xlDown
        If InStr(TestCmbArr(i).RefTest.Name, "#") > 0 Then
            Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "#" & _
                Left(TestCmbArr(i).RefTest.Name, InStr(TestCmbArr(i).RefTest.Name, "#") - 1) & "|" & _
                TestCmbArr(i).RefTest.StartRow
        Else
            Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "#" & TestCmbArr(i).RefTest.Name & _
                " " & TestCmbArr(i).RefTest.details
        End If
        If Left(TestCmbArr(i).RefTest.Name, 3) = "FMS" Then
            Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol) = Replace(TestCmbArr(i).RefTest.Name, "FMS:", "")
            blnFMS = True
        End If
        Application.EnableEvents = True
    ElseIf TestCmbArr(i).CombiMode > 1 Then
        blnFMS = StepIsFMS(strSheetname, lngCurRow)
    End If
    If TestCmbArr(i).CombiMode > 1 Then
        SetSequenceRowFormat lngCurRow, intPatternColorIndex(TestCmbArr(i).CombiMode), intFontColorIndex(TestCmbArr(i).CombiMode), blnFMS, 2 - Abs(CInt(blnFMS)), blnFMS
        Worksheets(strSheetname).Cells(lngCurRow, cSeqCheckCol) = strType(TestCmbArr(i).CombiMode)
      
        blnNoDiff = False
    End If
    
    lngCurRow = lngCurRow + 1
Next i

RepairRecoverySequence True, True, True

If blnNoDiff Then
    MsgBox "No differences found between sequences.", vbOKOnly
    WriteDebug "No differences found between sequences"
    Range("status") = Replace(Range("status"), strCompareIndicator, "")
Else
    MsgBox "Differences found and indicated in sequence sheet", vbOKOnly
    WriteDebug "Differences found and indicated in sequence sheet"
    Range("status") = Range("status") & strCompareIndicator
End If

End Sub

Private Sub OptimizeMatch(CmbTestList() As CmbTest)

'Given an array of type test (named CmbTestList)
'For all array elements where TestRef<>"" and TestAct=""
'Determine if TestRef is found as TestAct elsewhere in the sequence where TestRef=""
'If multiple locations are found, define the match as the one nearest to the original location
'If a location is found, move TestRef to TestAct

Dim intTestID As Integer

Application.StatusBar = "Comparing sequence..."

While intTestID < UBound(CmbTestList)
    If CmbTestList(intTestID).RefTest.Name <> "" And CmbTestList(intTestID).ActTest.Name = "" Then
        FindNearestExecutedTest CmbTestList(), intTestID
    End If
    
    intTestID = intTestID + 1
Wend

WriteDebug "Final sequence has " & UBound(CmbTestList) & " steps"
Application.StatusBar = ""

End Sub

Private Sub FindNearestExecutedTest(CmbTestList() As CmbTest, intTestID As Integer)

Dim intCmbTestArrSize As Integer
Dim intCurTest As Integer
Dim intCheckID As Integer

intCmbTestArrSize = UBound(CmbTestList)

For intCheckID = 1 To WorksheetFunction.Max(intCmbTestArrSize - intTestID, intTestID)
    If intTestID - intCheckID > 0 Then
        If CheckTestMatch(CmbTestList(intTestID - intCheckID), CmbTestList(intTestID)) Then
            MatchTest CmbTestList(), intTestID - intCheckID, intTestID
            Exit Sub
        End If
    End If
    If intTestID + intCheckID <= intCmbTestArrSize Then
        If CheckTestMatch(CmbTestList(intTestID + intCheckID), CmbTestList(intTestID)) Then
            MatchTest CmbTestList(), intTestID + intCheckID, intTestID
            Exit Sub
        End If
    End If
    
Next intCheckID

End Sub

Private Function CheckTestMatch(FirstTest As CmbTest, SecondTest As CmbTest) As Boolean

CheckTestMatch = (FirstTest.RefTest.Name = "" And FirstTest.ActTest.Name = SecondTest.RefTest.Name)

End Function

Private Sub SetCombiTestMode(CmbTestList() As CmbTest)

Dim intTestID As Integer

For intTestID = 1 To UBound(CmbTestList)
    If CmbTestList(intTestID).ActTest.Name = CmbTestList(intTestID).RefTest.Name Then
        CmbTestList(intTestID).CombiMode = 1
    ElseIf CmbTestList(intTestID).ActTest.Name <> "" Then
        CmbTestList(intTestID).CombiMode = 3
    ElseIf CmbTestList(intTestID).RefTest.Name <> "" Then
        CmbTestList(intTestID).CombiMode = 4
    Else
        CmbTestList(intTestID).CombiMode = 0
    End If
Next intTestID

End Sub

Private Sub MatchTest(CmbTestList() As CmbTest, intTest1ID As Integer, intTest2ID As Integer)

CmbTestList(intTest1ID).RefTest = CmbTestList(intTest2ID).RefTest
CmbTestList(intTest1ID).CombiMode = 2

For intTestID = intTest2ID To UBound(CmbTestList) - 1
    CmbTestList(intTestID) = CmbTestList(intTestID + 1)
Next intTestID

ReDim Preserve CmbTestList(UBound(CmbTestList) - 1)

End Sub

Public Function StepIsFMS(strSheetname As String, lngStepRow As Long) As Boolean

If Worksheets(strSheetname).Cells(lngStepRow, cTestNameCol) <> "" And _
    Worksheets(strSheetname).Cells(lngStepRow, cTestIDCol) = "" Then
    StepIsFMS = True
Else
    StepIsFMS = False
End If

End Function

Private Sub GetSequenceKey(strKey As String, strInputLine As String)

Dim strTxtArr() As String
Dim strProcName As String
Dim strChuckType As String

strInputLine = Replace(strInputLine, "[INPUT]", "")
strTxtArr() = Split(strInputLine, " ")

Select Case strTxtArr(1)
    Case Is = "CHUCK_BOTH"
        strChuckType = "BOTH CHUCKS"
    Case Is = "CHUCK_1"
        strChuckType = "CHUCK 1"
    Case Is = "CHUCK_2"
        strChuckType = "CHUCK 2"
    Case Else
        strChuckType = " "
End Select

strProcName = GetXMLValue(strInputLine, "Proc")
If InStr("ct|cs|ci", Left(strProcName, 2)) > 0 Then
    strProcName = Left(strProcName, 1) & Mid(strProcName, 3)
End If
If strProcName = "" Then
    strProcName = "MISSING"
End If

strKey = strTxtArr(0) & "#" & strProcName & "#" & strChuckType & "#" & Format(Val(strTxtArr(2)), "###0")

End Sub








Attribute VB_Name = "modDailyUpdate"
' %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
' %%%             Daily update mail creation             %%%
' %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Type tSequenceStep
    Name As String
    Key As String
    Atime As Single
    startTime As Double
    EndTime As Double
    fms As String
End Type

Public Const cDailyUpdateTimeSpan As Single = 12       ' Time span in hrs
Public strTitles(6) As String

Sub ReadTitles()
    
strTitles(1) = "1. Status & Timing"
strTitles(2) = "2. Last " & Format(cDailyUpdateTimeSpan, "#0") & " hours"
strTitles(3) = "3. Issues"
strTitles(4) = "4. Current support needed"
strTitles(5) = "5. Next " & Format(cDailyUpdateTimeSpan, "#0") & " hours"
strTitles(6) = "6. Serial nrs"
    
End Sub

Sub CreateDailyUpdate()

On Error GoTo errCreateDailyUpdate

If Not Worksheets("DailyUpdate").Visible Then
    Worksheets("DailyUpdate").Visible = True
End If

If Worksheets("DailyUpdate").Visible Then
    MakeProgress
    ReadTitles
    ReadMachineId
    PrepareDailyUpdate
    Worksheets("DailyUpdate").Activate
End If

Exit Sub

errCreateDailyUpdate:
End Sub
Sub ReadMachineId()
    Dim machineid As String
    
    machineid = GetConfigurationItemByName("MachineId")
    If Not machineid = "" Then
        Worksheets("DailyUpdate").Cells(3, 7).Value = machineid
    End If
End Sub


Sub PrepareDailyUpdate()

Dim strSheetname As String
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim tSeqSteps() As tSequenceStep
Dim intNrSteps As Integer
 
Worksheets("Settings").Cells(2, 1) = "Concept"
FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

With Worksheets("DailyUpdate")
    .Range("updStartDate") = Worksheets(strSheetname).Cells(cStartTimeRow, cActualTimeCol)
    .Range("updUpgradeName") = GetTitle(Worksheets(strSheetname).Range("recovery"))
    .Range("updBFactor") = Format(Worksheets(strSheetname).Cells(cA2BFactorRow, cPlannedTimeCol), "#0.00")
    .Range("updSWRelease") = Worksheets(strSheetname).Range("swrelease")
    .Range("updPrepareTime") = FormatPrepareTime(strSheetname)
    .Range("updCurrentActivity") = GetCurrentActivity(strSheetname, lngHeaderRow, lngLastSeqRow)
    .Range("updAheadBehind") = GetAheadBehindSchedule(strSheetname)
    
    ClearListactions strTitles(2)
    ClearListactions strTitles(5)
' Still need to export these actions
    GetListActions strSheetname, lngHeaderRow, lngLastSeqRow, CDbl(date + time) - cDailyUpdateTimeSpan / 24, CDbl(date + time), tSeqSteps, intNrSteps, True
    ShowListActions tSeqSteps(), intNrSteps, strTitles(2)
    GetListActions strSheetname, lngHeaderRow, lngLastSeqRow, CDbl(date + time), CDbl(date + time) + cDailyUpdateTimeSpan / 24, tSeqSteps, intNrSteps, False
    ShowListActions tSeqSteps(), intNrSteps, strTitles(5)
End With

End Sub

Public Function GetPrepareTime(strSheetname As String) As Double

Dim intCurRow As Integer
Dim dblSumTime As Double
Dim blnPrepareTimeFound As Boolean

blnPrepareTimeFound = False
For intCurRow = 10 To 199
    If InStr("DIAGNOSTICS|HW_UPGRADE", Worksheets(strSheetname).Cells(intCurRow, cTestIDCol)) > 0 Then
        If Val(Worksheets(strSheetname).Cells(intCurRow, cActualStartTimeCol)) > 0 And _
            Val(Worksheets(strSheetname).Cells(intCurRow, cActualFinishTimeCol)) >= Val(Worksheets(strSheetname).Cells(intCurRow, cActualStartTimeCol)) Then
                dblSumTime = dblSumTime _
                    + Val(CDbl(Worksheets(strSheetname).Cells(intCurRow, cActualFinishTimeCol))) _
                    - Val(CDbl(Worksheets(strSheetname).Cells(intCurRow, cActualStartTimeCol)))
            blnPrepareTimeFound = True
        End If
    End If
Next intCurRow
        
If blnPrepareTimeFound Then
    GetPrepareTime = dblSumTime
Else
    GetPrepareTime = -1
End If
    
End Function

Function FormatPrepareTime(strSheetname As String) As String

Dim dblSumTime As Double

dblSumTime = GetPrepareTime(strSheetname)
If dblSumTime > 0 Then
' Days -> Hrs
    FormatPrepareTime = Format(dblSumTime * 24, "###0.0") & " hrs"
Else
    FormatPrepareTime = "Unknown"
End If
 
End Function

Function GetTitle(strTitle As String) As String

Dim intChrInd As Integer
Dim strArgs() As String

strArgs() = Split(strTitle, vbCrLf)
strTitle = ""
For i = 0 To UBound(strArgs)
    intChrInd = InStrRev(strArgs(i), "[")
    If strTitle <> "" Then
        strTitle = strTitle & " + "
    End If
    If intChrInd = 0 Then
        strTitle = strTitle & strArgs(i)
    Else
        strTitle = strTitle & Trim(Left(strArgs(i), intChrInd - 1))
    End If
Next i

GetTitle = strTitle
End Function

Sub ClearListactions(strTitle As String)

Dim lngRowNr As Long
Dim lngCurRow As Long

lngRowNr = FindSequenceRow("DailyUpdate", strTitle)
lngCurRow = lngRowNr + 1

While Worksheets("DailyUpdate").Cells(lngCurRow, 3) <> ""
    lngCurRow = lngCurRow + 1
Wend

If lngCurRow > lngRowNr + 1 Then
    Worksheets("DailyUpdate").Range(fRows(lngRowNr + 1, lngCurRow - 1)).Delete
End If

End Sub

Function GetAheadBehindSchedule(strSheetname As String)

Dim sngDelay As Single

sngDelay = Worksheets(strSheetname).Cells(cEndTimeRow, cDelayCol)

If sngDelay = 0 Then
    GetAheadBehindSchedule = "On schedule"
ElseIf sngDelay < 0 Then
    GetAheadBehindSchedule = Format(Abs(sngDelay), "###0.0") & " hrs ahead of schedule"
Else
    GetAheadBehindSchedule = Format(Abs(sngDelay), "###0.0") & " hrs behind schedule"
End If

End Function

Function GetCurrentActivity(strSheetname As String, lngHeaderRow As Long, lngLastSeqRow As Long)

Dim intCurRow As Integer

For intCurRow = lngHeaderRow To lngLastSeqRow
    If Worksheets(strSheetname).Cells(intCurRow, cTestIDCol) <> "" And _
        Worksheets(strSheetname).Cells(intCurRow, cActualStartTimeCol) <> "" And _
        Worksheets(strSheetname).Cells(intCurRow, cActualFinishTimeCol) = "" Then
            GetCurrentActivity = Worksheets(strSheetname).Cells(intCurRow, cTestIDCol)
            Exit Function
    End If
Next intCurRow

GetCurrentActivity = "No ongoing activity found"

End Function

Sub GetListActions(strSheetname As String, lngHeaderRow As Long, lngLastSeqRow As Long, _
    dblStartTime As Double, dblEndTime As Double, tActions() As tSequenceStep, intNrSteps As Integer, _
    blnUseActual As Boolean)

Dim intCurRow As Integer
Dim intStartCol As Integer
Dim intEndCol As Integer
Dim dblGetStartVal As Double
Dim dblGetEndVal As Double
Dim strFMS As String

On Error GoTo errGetListActions

intNrSteps = 0

If blnUseActual Then
    intStartCol = cActualStartTimeCol
    intEndCol = cActualFinishTimeCol
Else
    intStartCol = cEstimatedStartTimeCol
    intEndCol = cEstimatedEndTimeCol
End If

' This routine will determine the Functional Machine States (FMSs) in which step(s) have been
' executed in the defined time frame

intCurRow = lngHeaderRow + 1
While intCurRow <= lngLastSeqRow
    If StepIsFMS(strSheetname, CLng(intCurRow)) Then
        strFMS = Worksheets(strSheetname).Cells(intCurRow, cTestNameCol)
    
'        If IsDate(Worksheets(strSheetName).Cells(intCurRow, intStartCol)) Or _
'            IsDate(Worksheets(strSheetName).Cells(intCurRow, intEndCol)) Then
'                dblGetStartVal = GetDateTimeVal(Worksheets(strSheetName).Cells(intCurRow, intStartCol))
'                dblGetEndVal = GetDateTimeVal(Worksheets(strSheetName).Cells(intCurRow, intEndCol))
'        Else
            dblGetStartVal = 99999
            dblGetEndVal = -99999
            While Not StepIsFMS(strSheetname, CLng(intCurRow + 1)) And intCurRow < lngLastSeqRow
                If IsDate(Worksheets(strSheetname).Cells(intCurRow + 1, intStartCol)) Then
                    dblGetStartVal = Application.WorksheetFunction.Min(dblGetStartVal, GetDateTimeVal(Worksheets(strSheetname).Cells(intCurRow + 1, intStartCol)))
                End If
                If IsDate(Worksheets(strSheetname).Cells(intCurRow + 1, intStartCol)) Then
                    dblGetEndVal = Application.WorksheetFunction.Max(dblGetEndVal, GetDateTimeVal(Worksheets(strSheetname).Cells(intCurRow + 1, intEndCol)))
                End If
                intCurRow = intCurRow + 1
            Wend
    ' loop over all subsequent steps and find
'        End If
        
'        Debug.Print Left(strFMS & String(20, " "), 24) & " " & dblStartTime & " " & dblGetStartVal & " " & dblGetEndVal & " " & dblEndTime
        If IsBetween(dblGetStartVal, dblStartTime, dblEndTime) Or IsBetween(dblGetEndVal, dblStartTime, dblEndTime) _
            Or (dblGetStartVal <= dblStartTime And dblGetEndVal >= dblEndTime) Then
            intNrSteps = intNrSteps + 1
            ReDim Preserve tActions(intNrSteps) As tSequenceStep
            With tActions(intNrSteps)
'                .Name = Worksheets(strSheetName).Cells(intCurRow, cTestNameCol)
                .Name = strFMS
                .Key = Worksheets(strSheetname).Cells(intCurRow, cTestIDCol)
                .Atime = Worksheets(strSheetname).Cells(intCurRow, cATimeCol)
                .startTime = dblGetStartVal
                .EndTime = dblGetEndVal
                .fms = strFMS
            End With
'            Debug.Print "---> OK"
        End If
    End If
    intCurRow = intCurRow + 1
Wend

If intNrSteps = 0 Then
    intNrSteps = 1
    ReDim tActions(intNrSteps) As tSequenceStep
    tActions(1).Name = "No steps found."
    tActions(1).fms = "No steps found."
End If

Exit Sub

errGetListActions:
MsgBox err.Description, vbOKOnly
Resume Next

End Sub

Sub ShowListActions(tActions() As tSequenceStep, intNrActions As Integer, strHeader As String)

On Error GoTo errShowListActions

Dim intStepID As Integer
Dim blnShowOnlyFMS As Boolean

blnShowOnlyFMS = True

' Find header line
lngRowNr = FindSequenceRow("DailyUpdate", strHeader)

' If not found, skip
If lngRowNr <= 0 Then
    Exit Sub
End If

Worksheets("DailyUpdate").Activate
Application.ScreenUpdating = False
For intStepID = intNrActions To 1 Step -1
    If (blnShowOnlyFMS = (tActions(intStepID).Name = tActions(intStepID).fms)) Then
        Rows(fRows(lngRowNr + 1)).Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove
        Worksheets("DailyUpdate").Cells(lngRowNr + 1, 3) = tActions(intStepID).Name
    End If
Next intStepID
Application.ScreenUpdating = True

Exit Sub

errShowListActions:
Application.ScreenUpdating = True
Resume Next

End Sub

Function GetDateTimeVal(strText) As Double

On Error GoTo errGetDateTimeVal

GetDateTimeVal = CDbl(strText)

Exit Function

errGetDateTimeVal:
GetDateTimeVal = -1

End Function

Sub CreateDailyUpdateMailFinal()

CreateDailyUpdateMail True

End Sub

Sub CreateDailyUpdateMailOngoing()

CreateDailyUpdateMail False

End Sub

Sub CreateDailyUpdateMail(blnFinal As Boolean)

' Don't forget to copy the function RangetoHTML in the module.
' Working in Office 2000-2010
    
    Dim ThisRange As Range
    Dim cel_row As Integer
    Dim cel_start_b As String
    Dim cel_one_b As String
    Dim cel_one_m As String
    Dim cel_six_b As String
    Dim cel_six_m As String
    Dim cel_seven_b As String
    Dim cel_seven_m As String
    Dim cel_end_m As String
    Dim rng_start As Range
    Dim rng_timeline As Range
    Dim rng_n24h As Range
    Dim rng_recovery As Range
    Dim rng_AOB As Range
    Dim rng_Last As Range
    Dim Mypath As String
    Dim path_timeline As String
    Dim path_recovery As String
    Dim RowNumber As Integer
    Dim RowAmount As Integer
    Dim OutApp As Object
    Dim OutMail As Object
    Dim LastRow As Long
    Dim ColNumber As Integer
    Dim Firstcell As String
    Dim Lastcell As String
    Dim email_body As String
 
'Range for lookup of chapters
    Sheets("DailyUpdate").Activate
    Set ThisRange = Range("B10", "B100")
        
'Range up to item "1. Status & Timing"
    Set rng_start = Nothing
    On Error Resume Next
    cel_row = CelAddress(ThisRange, "Dear all,")
    cel_start_b = "B" & cel_row
    cel_row = CelAddress(ThisRange, strTitles(1))
    cel_one_m = "M" & cel_row
    Set rng_start = Range(cel_start_b, cel_one_m) '.SpecialCells(xlCellTypeVisible)
    
    On Error GoTo 0

    If rng_start Is Nothing Then
        MsgBox "The selection rng_start is not a range or the sheet is protected" & _
               vbNewLine & "please correct and try again.", vbOKOnly
        Exit Sub
    End If
    
'Range of the Timeline
    Set rng_timeline = Nothing
    On Error Resume Next
    Sheets("StatusBar").Activate
'    Firstcell = Range("B2").value
'    Lastcell = Range("B3").value
    
' For now, hard-coded
    Firstcell = "B1"
    Lastcell = "DZ30"
    Set rng_timeline = Range(Firstcell, Lastcell) '.SpecialCells(xlCellTypeVisible)
    Mypath = ActiveWorkbook.path
    path_timeline = Mypath & "\" & "Timeline.png"

    
    If ExportRangeToPicture(rng_timeline, path_timeline) Then
    'MsgBox "Hooray it worked"
    Else
        MsgBox "Picture export didn't work"
    End If
    'Export_Range_Images (rngMiddle)
    Sheets("DailyUpdate").Activate
    On Error GoTo 0

    If rng_timeline Is Nothing Then
        MsgBox "The timeline selection is not a range or the sheet is protected" & _
               vbNewLine & "please correct and try again.", vbOKOnly
        Exit Sub
    End If
    
'Range up to item "5. Next 24 hours"
    Set rng_n24h = Nothing
    On Error Resume Next
    cel_row = CelAddress(ThisRange, strTitles(1))
    cel_one_b = "B" & cel_row + 2
    cel_row = CelAddress(ThisRange, strTitles(6))
    cel_six_m = "M" & cel_row - 2
    Set rng_n24h = Range(cel_one_b, cel_six_m) '.SpecialCells(xlCellTypeVisible)
    
    On Error GoTo 0

    If rng_n24h Is Nothing Then
        MsgBox "The selection is not a range or the sheet is protected" & _
               vbNewLine & "please correct and try again.", vbOKOnly
        Exit Sub
    End If
    
    RowNumber = 0
    On Error GoTo 0
    
'Range of the part of the email up to including AOB
    Set rng_AOB = Nothing
    cel_row = CelAddress(ThisRange, strTitles(6))
    cel_six_b = "B" & cel_row
    cel_row = CelAddress(ThisRange, strTitles(6))
    cel_seven_m = "M" & cel_row + 3
    On Error Resume Next
    Set rng_AOB = Range(cel_six_b, cel_seven_m) '.SpecialCells(xlCellTypeVisible)
    On Error GoTo 0

    If rng_AOB Is Nothing Then
        MsgBox "The up to AOB selection is not a range or the sheet is protected" & _
               vbNewLine & "please correct and try again.", vbOKOnly
        Exit Sub
    End If

'Range of the last part of the email
    cel_row = CelAddress(ThisRange, strTitles(6))
    cel_seven_b = "B" & cel_row + 5
    LastRow = ActiveSheet.UsedRange.Rows.Count
    cel_end_m = "M" & LastRow
    
    Set rng_Last = Nothing
    On Error Resume Next
    Set rng_Last = Range(cel_seven_b, cel_end_m) '.SpecialCells(xlCellTypeVisible)
    On Error GoTo 0

    If rng_Last Is Nothing Then
        MsgBox "The last selection is not a range or the sheet is protected" & _
               vbNewLine & "please correct and try again.", vbOKOnly
        Exit Sub
    End If

    With Application
        .EnableEvents = False
        .ScreenUpdating = False
    End With

    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)
    
    If RowNumber = 0 Then
        email_body = RangetoHTML(rng_start) & "<HTML><BODY><IMG src='Timeline.png'></BODY></HTML>" _
                        & RangetoHTML(rng_n24h) & RangetoHTML(rng_AOB) & RangetoHTML(rng_Last)
    Else
        email_body = RangetoHTML(rng_start) & "<HTML><BODY><IMG src='Timeline.png'></BODY></HTML>" _
                        & RangetoHTML(rng_n24h) & RangetoHTML(rng_recovery) & RangetoHTML(rng_AOB) _
                        & RangetoHTML(rng_Last)
    End If
    
    On Error Resume Next
    
    
    With OutMail
        .To = Range("C8").Value
        .CC = Range("C9").Value
        .BCC = ""
        If blnFinal Then
            .Subject = "[FINAL} " & Range("C6").Value
        Else
            .Subject = Range("C6").Value
        End If
        
        .Attachments = .Attachments.Add(Mypath & "\" & "Timeline.png")
'        .Body = email_body
        .HTMLBody = email_body
        .Display   'or use .Send
    End With
    
    Sheets("DailyUpdate").Visible = False
    On Error GoTo 0

    With Application
        .EnableEvents = True
        .ScreenUpdating = True
    End With

    Set OutMail = Nothing
    Set OutApp = Nothing

    Worksheets("Settings").Cells(2, 1) = "Concept"

End Sub

' %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Function ExportRangeToPicture(rng As Excel.Range, img As String) As Boolean
' save a range from Excel as a picture
' rng = Range to export
' img = filename & path

' basic error checking
' check for valid filetypes
' from http://peltiertech.com/WordPress/export-chart-as-image-file/
Const FILE_EXT As String = "gif,png,jpg,jpe,jpeg"
If InStr(FILE_EXT, LCase$(Right$(img, 3))) = 0 Then
  GoTo ExitProc
End If

' check for valid path
Dim path As String
path = Left$(img, InStrRev(img, "\"))
If Dir(path, vbDirectory) = "" Then GoTo ExitProc

' check for valid range
Dim rRng As Excel.Range
On Error Resume Next
Set rRng = rng
On Error GoTo 0
If rRng Is Nothing Then GoTo ExitProc

' check for protected worksheet
If ActiveSheet.ProtectContents Then GoTo ExitProc
 
' copy range to picture, put into chart, export it
Application.ScreenUpdating = False
rRng.CopyPicture xlScreen, xlPicture

Dim cht As Excel.ChartObject
Set cht = ActiveSheet.ChartObjects.Add(0, 0, rng.Width, rng.Height)
cht.Activate

' MBTR: ARE-1477: START
Dim iWidth As Integer
Dim iHeight As Integer

iWidth = Round(rng.Width * 0.75, 0)
iHeight = Round(rng.Height * 0.75, 0)
' MBTR: ARE-1477: END

With cht
  .Chart.Paste
  .Chart.Export img
  .Delete
End With

' if we got this far, assume success
ExportRangeToPicture = True

ExitProc:
Application.ScreenUpdating = True
Set cht = Nothing
Set rRng = Nothing
End Function

Function RangetoHTML(rngTop As Range)
' Changed by Ron de Bruin 28-Oct-2006
' Working in Office 2000-2010
    Dim fso As Object
    Dim ts As Object
    Dim TempFile As String
    Dim TempWB As Workbook
 
    TempFile = Environ$("temp") & "/" & Format(Now, "dd-mm-yy h-mm-ss") & ".htm"
 
    'Copy the range and create a new workbook to past the data in
    rngTop.Copy
    Set TempWB = Workbooks.Add(1)
    With TempWB.Sheets(1)
        .Cells(1).PasteSpecial Paste:=8
        .Cells(1).PasteSpecial xlPasteValues, , False, False
        .Cells(1).PasteSpecial xlPasteFormats, , False, False
        .Cells(1).Select
        Application.CutCopyMode = False
        On Error Resume Next
        .DrawingObjects.Visible = True
        .DrawingObjects.Delete
        On Error GoTo 0
    End With
 
    'Publish the sheet to a htm file
    With TempWB.PublishObjects.Add( _
         SourceType:=xlSourceRange, _
         FileName:=TempFile, _
         sheet:=TempWB.Sheets(1).Name, _
         source:=TempWB.Sheets(1).UsedRange.Address, _
         HtmlType:=xlHtmlStatic)
        .Publish (True)
    End With
 
    'Read all data from the htm file into RangetoHTML
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set ts = fso.GetFile(TempFile).OpenAsTextStream(1, -2)
    RangetoHTML = ts.ReadAll
    ts.Close
    RangetoHTML = Replace(RangetoHTML, "align=center x:publishsource=", _
                          "align=left x:publishsource=")
 
    'Close TempWB
    TempWB.Close savechanges:=False
 
    'Delete the htm file we used in this function
    Kill TempFile
 
    Set ts = Nothing
    Set fso = Nothing
    Set TempWB = Nothing
End Function

'Return weeknumber of given date
Public Function WeekNr(d1 As Date) As Integer
' Attributed to Daniel Maher
    Dim d2 As Long
    d2 = DateSerial(Year(d1 - Weekday(d1 - 1) + 4), 1, 3)
    WeekNr = Int((d1 - d2 + Weekday(d2) + 5) / 7)
End Function

' Find address of specific cell
Public Function CelAddress(ByRef ThisRange As Range, CellName As String) As Integer
    Dim cel As Range
    For Each cel In ThisRange
        If cel = CellName Then CelAddress = cel.row
    Next cel
End Function

Public Function IsBetween(dblVal As Double, dblMin As Double, dblMax As Double) As Boolean

IsBetween = (dblVal >= dblMin And dblVal <= dblMax)

End Function








Attribute VB_Name = "modData"
Option Explicit

Public Type NameVal
     Name As String
     Value As String
End Type

Public Type Step
    startMode As String
    Intention As String
    StepId As String
    DocumentReference As String
    Description As String
    TestID As String
    duration As String
    ProcedureId As String
    ProcedureName As String
    ProcedureLink As String
    Parts As String
    Tools As String
    Exec As String
    NsVersion As String
    Scenario As String
    LongChuck As String
    EquipmentItem() As NameVal
End Type

Public Type StepGroup
    groupName As String
    Step() As Step
End Type

Public Type SequenceInfo
    Group() As StepGroup
    totalDuration As String
End Type

Public Type testdata
    Exec As String
    NsVersion As String
    Scenario As String
    Equipment() As NameVal
End Type

Private Type GuidType
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(7) As Byte
End Type
Private Declare PtrSafe Function CoCreateGuid Lib "ole32.dll" (guid As GuidType) As LongPtr
Private Declare PtrSafe Function StringFromGUID2 Lib "ole32.dll" (guid As GuidType, ByVal lpStrGuid As LongPtr, ByVal cbMax As Long) As LongPtr

Public Const recFirstSequenceRow As Integer = 18
Public Const recStatusCol As Integer = 1
Public Const recProcCol As Integer = 3
Public Const recTestNameCol As Integer = 4
Public Const recKeyCol As Integer = 6
Public Const recChuckCol As Integer = 7
Public Const recDurationCol As Integer = 8
Public Const recStartModeCol As Integer = 9
Public Const recHasSubtestsCol As Integer = 10
Public Const recExecCol As Integer = 11
Public Const recPartsCol As Integer = 15
Public Const recToolsCol As Integer = 16


'--------------------------------------------------------------
' Get the platform
'--------------------------------------------------------------
Public Function getPlatform() As String
    Dim strText As String
    Dim strPlatform As String

    strText = Worksheets("Source").Cells(1, 1)
    strPlatform = ""
    If InStr(strText, "Platform") > 0 Then
        strPlatform = Replace(strText, "[Platform]", "")
    End If
    getPlatform = strPlatform
End Function

'--------------------------------------------------------------
' Get the version of ARE
'--------------------------------------------------------------
Public Function getAREVersion() As String
    Dim intCurRow As Integer
    Dim strText As String
    Dim strKey As String
    Dim strVal As String
    
    intCurRow = 1
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If Mid(strText, 1, 2) = "##" Then
            strKey = Replace(SubString(strText, "|", 1), "##", "")
            If strKey = "UserInterface" Then
                strVal = SubString(strText, "|", 2)
                Exit Do
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
    getAREVersion = strVal
End Function

'--------------------------------------------------------------
' Get value of one configuration item
'--------------------------------------------------------------
Public Function getConfigurationItem(Key As String) As String
    Dim intCurRow As Integer
    Dim strKey As String
    Dim strVal As String
    Dim strText As String

    intCurRow = 1
    strVal = ""
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If Mid(strText, 1, 2) = "$$" Then
            strKey = Replace(SubString(strText, "|", 1), "$$", "")
            If strKey = Key Then
                strVal = SubString(strText, "|", 2)
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
    getConfigurationItem = strVal
End Function


'--------------------------------------------------------------
' Get all configuration items
'--------------------------------------------------------------
Public Function getConfigurationItems() As NameVal()
    Dim result() As NameVal
    Dim nrItems As Integer
    Dim intCurRow As Integer
    Dim strText As String
    
    nrItems = 0
    intCurRow = 1
    ReDim Preserve result(0)
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If Mid(strText, 1, 2) = "$$" Then
            If Not ((InStr(strText, "$$RECOVERY") > 0) Or (InStr(strText, "$$SERVICEACTION") > 0) Or (InStr(strText, "$$SCENARIOS") > 0)) Then
                ReDim Preserve result(nrItems)
                result(nrItems).Name = Replace(SubString(strText, "|", 1), "$$", "")
                result(nrItems).Value = SubString(strText, "|", 2)
                nrItems = nrItems + 1
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
    getConfigurationItems = result
End Function

'--------------------------------------------------------------
' Get the name of the sequence
'--------------------------------------------------------------
Public Function getSequenceName() As String
    Dim result As String
    Dim machineid As String
    Dim intCurRow As Integer
    Dim strText As String
    Dim nrRecoveries As Integer
    Dim nrServiceActions As Integer
    Dim recovery As String
    Dim serviceaction As String
    
    result = ""
    nrRecoveries = 0
    nrServiceActions = 0
    recovery = ""
    serviceaction = ""
    intCurRow = 1
    ' When a machine id is available, the sequence will begin with that machine id
    machineid = getConfigurationItem("MachineId")
    If Not (machineid = "") Then
        result = machineid & "-"
    End If
    ' When there is only one recovery or service action, the sequence will get that
    ' name, otherwise it will be combined
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If (InStr(strText, "$$RECOVERY") > 0) Or (InStr(strText, "$$SERVICEACTION") > 0) Then
            If SubString(strText, "|", 1) = "$$RECOVERY" Then
                nrRecoveries = nrRecoveries + 1
                ' strText is something like "$$RECOVERY|<recovery Name> [<recovery status]
                recovery = SubString(SubString(strText, "|", 2), "[", 1)
            End If
            If SubString(strText, "|", 1) = "$$SERVICEACTION" Then
                nrServiceActions = nrServiceActions + 1
                serviceaction = SubString(SubString(strText, "|", 2), "[", 1)
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
    If nrRecoveries + nrServiceActions = 1 Then
        If nrRecoveries = 1 Then
            result = result & recovery
        End If
        If nrServiceActions = 1 Then
            result = result & serviceaction
        End If
    Else
        result = result & "combined"
    End If
    getSequenceName = result
End Function

'--------------------------------------------------------------
' Get the reason of the sequence
'--------------------------------------------------------------
Public Function getSequenceReason() As String
    Dim result As String
    
    result = getConfigurationItem("InitiatingNumber")
    If result = "" Then
      result = "Unknown"
    End If
    getSequenceReason = result
End Function

'--------------------------------------------------------------
' Get all the used recoveries
'--------------------------------------------------------------
Public Function getRecoveries() As String()
    Dim result() As String
    Dim nrItems As Integer
    Dim intCurRow As Integer
    Dim strText As String
    
    nrItems = 0
    intCurRow = 1
    ReDim Preserve result(0)
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If (InStr(strText, "$$RECOVERY") > 0) Or (InStr(strText, "$$SERVICEACTION") > 0) Then
            If (SubString(strText, "|", 1) = "$$RECOVERY") Or (SubString(strText, "|", 1) = "$$SERVICEACTION") Then
                ReDim Preserve result(nrItems)
                result(nrItems) = SubString(SubString(strText, "|", 2), "[", 1)
                nrItems = nrItems + 1
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
    getRecoveries = result
End Function

'--------------------------------------------------------------
' Convert the duration format of the template (e.g. 179h 50m)
' to the xml output (P0Y0M0DT179H50M0.000S)
'--------------------------------------------------------------
Private Function getXMLDuration(duration As String) As String
    Dim hours As String
    Dim minutes As String
    Dim intHours As Integer
    Dim intMinutes As Integer
    Dim intDays As Integer
    
    If duration = "" Then
        getXMLDuration = ""
    Else
        hours = SubString(duration, "h ", 1)
        minutes = SubString(duration, "h ", 2)
        minutes = Left(minutes, Len(minutes) - 1)
    
        intHours = CInt(hours)
        intDays = Int(intHours / 24)
        intHours = intHours - 24 * intDays
        getXMLDuration = "P0Y0M" & intDays & "DT" & intHours & "H" & minutes & "M0.000S"
    End If
End Function
'--------------------------------------------------------------
' Convert the duration in minutes(e.g. 5)
' to the xml output (P0Y0M0DT0H5M0.000S)
'--------------------------------------------------------------
Private Function getXMLDurationFromMinutes(minutes As String)
    Dim inp As Integer
    Dim hours As Integer
    Dim mins As Integer
    
    If minutes <> "" Then
        getXMLDurationFromMinutes = getXMLDurationFromIntegerMinutes(CInt(minutes))
    Else
        getXMLDurationFromMinutes = "P0Y0M0DT00H00M0.000S"
    End If
End Function

'--------------------------------------------------------------
' Check if the row is empty
'--------------------------------------------------------------
Public Function recoveryRowEmpty(rowIndex As Integer) As Boolean
    recoveryRowEmpty = Worksheets("Recovery").Cells(rowIndex, recStatusCol) = "" And _
                       Worksheets("Recovery").Cells(rowIndex, recProcCol) = "" And _
                       Worksheets("Recovery").Cells(rowIndex, recTestNameCol) = "" And _
                       Worksheets("Recovery").Cells(rowIndex, recKeyCol) = "" And _
                       Worksheets("Recovery").Cells(rowIndex, recChuckCol) = "" And _
                       Worksheets("Recovery").Cells(rowIndex, recDurationCol) = "" And _
                       Worksheets("Recovery").Cells(rowIndex, recStartModeCol) = ""
End Function

Private Function getXMLDurationFromIntegerMinutes(minutes As Integer)
    Dim hours As Integer
    Dim days As Integer
    
    hours = Int(minutes / 60)
    minutes = minutes - 60 * Int(minutes / 60)
    
    days = Int(hours / 24)
    hours = hours - 24 * days

    getXMLDurationFromIntegerMinutes = "P0Y0M" & days & "DT" & hours & "H" & minutes & "M0.000S"

End Function

'--------------------------------------------------------------
' Check if the row is empty
'--------------------------------------------------------------
Private Function rowEmpty(rowIndex As Integer) As Boolean
    rowEmpty = Worksheets("Recovery").Cells(rowIndex, recStatusCol) = "" And _
               Worksheets("Recovery").Cells(rowIndex, recProcCol) = "" And _
               Worksheets("Recovery").Cells(rowIndex, recTestNameCol) = "" And _
               Worksheets("Recovery").Cells(rowIndex, recKeyCol) = "" And _
               Worksheets("Recovery").Cells(rowIndex, recChuckCol) = "" And _
               Worksheets("Recovery").Cells(rowIndex, recDurationCol) = "" And _
               Worksheets("Recovery").Cells(rowIndex, recStartModeCol) = ""
End Function

'--------------------------------------------------------------
' Check if the row is an SQR group. This is the case when
' there is data in col D and nowere else
'--------------------------------------------------------------
Private Function rowIsSQRGroup(rowIndex As Integer) As Boolean
    rowIsSQRGroup = Worksheets("Recovery").Cells(rowIndex, recStatusCol) = "" And _
                    Worksheets("Recovery").Cells(rowIndex, recProcCol) = "" And _
                    Worksheets("Recovery").Cells(rowIndex, recTestNameCol) <> "" And _
                    Worksheets("Recovery").Cells(rowIndex, recKeyCol) = "" And _
                    Worksheets("Recovery").Cells(rowIndex, recChuckCol) = "" And _
                    Worksheets("Recovery").Cells(rowIndex, recDurationCol) = "" And _
                    Worksheets("Recovery").Cells(rowIndex, recStartModeCol) = ""
End Function

'--------------------------------------------------------------
' Check if the row is an ARE group. This is the case when
' there is data in col D and in F and col J contains a Y
'--------------------------------------------------------------
Private Function rowIsAREGroup(rowIndex As Integer) As Boolean
    rowIsAREGroup = Worksheets("Recovery").Cells(rowIndex, recTestNameCol) <> "" And _
                    Worksheets("Recovery").Cells(rowIndex, recKeyCol) <> "" And _
                    Worksheets("Recovery").Cells(rowIndex, recHasSubtestsCol) = "Y"
End Function

'--------------------------------------------------------------
' Check if the row is a test step. This is the case when
' there is data in col D and in F and col J does not contain a Y
'--------------------------------------------------------------
Private Function rowIsTestStep(rowIndex As Integer) As Boolean
    rowIsTestStep = Worksheets("Recovery").Cells(rowIndex, recTestNameCol) <> "" And _
                    Worksheets("Recovery").Cells(rowIndex, recKeyCol) <> "" And _
                    Worksheets("Recovery").Cells(rowIndex, recHasSubtestsCol) <> "Y"
End Function



'--------------------------------------------------------------
' Get all the step groups
'--------------------------------------------------------------
Public Function getStepGroups() As SequenceInfo
    Dim result As SequenceInfo
    Dim intCurRow As Integer
    Dim nrGroupSteps As Integer
    Dim nrSteps As Integer
    Dim recoverySheet As Worksheet
    Dim strStartMode As String
    Dim TestID As String
    Dim strLongChuck As String
    Dim strShortChuck As String
    Dim testdata As testdata
    Dim i As Integer
    Dim warningLines() As String
    Dim warningIndex As Integer
    Dim strWarning As String
    Dim strDuration As String
    Dim Exec As String
    Dim chuck As String
    Dim moid As String
    Dim totDuration As String
    Dim int1 As Integer
    Dim int2 As Integer
    Dim intHours As Integer
    Dim intMins As Integer
    Dim bShowWarning As Boolean
    
    
    intCurRow = recFirstSequenceRow
    Set recoverySheet = Worksheets("Recovery")
    nrGroupSteps = 0
    nrSteps = 0
    ReDim Preserve warningLines(0)
    warningIndex = 0
    ReDim Preserve result.Group(0)
    ReDim Preserve result.Group(0).Step(0)
    bShowWarning = False
    
    Do While Not rowEmpty(intCurRow)
        If rowIsSQRGroup(intCurRow) Then
            'Fill step group data
            nrSteps = 0
            
            ReDim Preserve result.Group(nrGroupSteps)
            ReDim Preserve result.Group(nrGroupSteps).Step(0)
            result.Group(nrGroupSteps).groupName = recoverySheet.Cells(intCurRow, recTestNameCol)
            nrGroupSteps = nrGroupSteps + 1
        ElseIf rowIsAREGroup(intCurRow) Or rowIsTestStep(intCurRow) Then
            'Fill step data
            If nrGroupSteps = 0 Then
                ' This is the case when this is the first test step, but there was no group before
                ' Make a dummy group
                
                MsgBox ("Note thate the sequence did not start with a FMS. A dummy stepgroup will be created.")
                ReDim Preserve result.Group(nrGroupSteps)
                ReDim Preserve result.Group(nrGroupSteps).Step(0)
                result.Group(nrGroupSteps).groupName = "Dummy"
                nrGroupSteps = nrGroupSteps + 1
            End If
            
            ReDim Preserve result.Group(nrGroupSteps - 1).Step(nrSteps)
            
            'StartMode
            strStartMode = recoverySheet.Cells(intCurRow, recStartModeCol)
            If strStartMode = "S" Then
                result.Group(nrGroupSteps - 1).Step(nrSteps).startMode = "Semi-Automatic"
            ElseIf strStartMode = "M" Then
                result.Group(nrGroupSteps - 1).Step(nrSteps).startMode = "Manual"
            ElseIf strStartMode = "A" Then
                result.Group(nrGroupSteps - 1).Step(nrSteps).startMode = "Automatic"
            Else
                result.Group(nrGroupSteps - 1).Step(nrSteps).startMode = "Manual"
            End If
            'Intention
            If (recoverySheet.Cells(intCurRow, recStatusCol) = "Skip") Or (rowIsAREGroup(intCurRow)) Then
                result.Group(nrGroupSteps - 1).Step(nrSteps).Intention = "Skip"
            Else
                result.Group(nrGroupSteps - 1).Step(nrSteps).Intention = "Execute"
            End If
            'StepId
            result.Group(nrGroupSteps - 1).Step(nrSteps).StepId = CreateGuid
            'DocumentReference
            TestID = recoverySheet.Cells(intCurRow, recKeyCol)
            chuck = recoverySheet.Cells(intCurRow, recChuckCol)
            
            If recoverySheet.Cells(intCurRow, recProcCol).Hyperlinks.Count > 0 Then
                moid = getMOIDFromLink(recoverySheet.Cells(intCurRow, recProcCol).Hyperlinks(1).Address)
            ElseIf recoverySheet.Cells(intCurRow, recTestNameCol).Hyperlinks.Count > 0 Then
                moid = getMOIDFromLink(recoverySheet.Cells(intCurRow, recTestNameCol).Hyperlinks(1).Address)
            Else
                moid = ""
            End If
            
            testdata = getDataFromTest(TestID, chuck, moid)
            Exec = recoverySheet.Cells(intCurRow, recExecCol)
            If Exec = "" Then
                Exec = testdata.Exec
            End If
            
            strShortChuck = getShortChuck(chuck)
                
            result.Group(nrGroupSteps - 1).Step(nrSteps).DocumentReference = "ADELcpd" & Exec & testdata.NsVersion & "_" & testdata.Scenario _
                & "_" & strShortChuck & "_" & TestID & "_" & Format(date, "yyyymmdd") & "_" & Format(time, "hhmm") & ".xml"
                 
            'Description
            result.Group(nrGroupSteps - 1).Step(nrSteps).Description = recoverySheet.Cells(intCurRow, recTestNameCol)
            'TestID
            result.Group(nrGroupSteps - 1).Step(nrSteps).TestID = TestID
            'Duration
            strDuration = recoverySheet.Cells(intCurRow, recDurationCol)
            result.Group(nrGroupSteps - 1).Step(nrSteps).duration = getXMLDurationFromMinutes(strDuration)
            'ProcedureName
            result.Group(nrGroupSteps - 1).Step(nrSteps).ProcedureName = recoverySheet.Cells(intCurRow, recProcCol)
            'ProcedureLink and ProcedureId
            
            If recoverySheet.Cells(intCurRow, recProcCol).Hyperlinks.Count > 0 Then
                result.Group(nrGroupSteps - 1).Step(nrSteps).ProcedureLink = getHyperlink(recoverySheet.Cells(intCurRow, recProcCol).Hyperlinks(1).Address)
            ElseIf recoverySheet.Cells(intCurRow, recTestNameCol).Hyperlinks.Count > 0 Then
                result.Group(nrGroupSteps - 1).Step(nrSteps).ProcedureLink = getHyperlink(recoverySheet.Cells(intCurRow, recTestNameCol).Hyperlinks(1).Address)
            Else
                result.Group(nrGroupSteps - 1).Step(nrSteps).ProcedureLink = ""
            End If
            

            result.Group(nrGroupSteps - 1).Step(nrSteps).ProcedureId = moid
            'Parts
            result.Group(nrGroupSteps - 1).Step(nrSteps).Parts = Replace(recoverySheet.Cells(intCurRow, recPartsCol), "||", ";")
            'Tools
            result.Group(nrGroupSteps - 1).Step(nrSteps).Tools = Replace(recoverySheet.Cells(intCurRow, recToolsCol), "||", ";")
            'Exec
            result.Group(nrGroupSteps - 1).Step(nrSteps).Exec = Exec
            'NsVersion
            result.Group(nrGroupSteps - 1).Step(nrSteps).NsVersion = testdata.NsVersion
            'Scenario
            result.Group(nrGroupSteps - 1).Step(nrSteps).Scenario = testdata.Scenario
            ' Chuck
            result.Group(nrGroupSteps - 1).Step(nrSteps).LongChuck = getLongChuck(recoverySheet.Cells(intCurRow, recChuckCol))
            
            'EquipementData
            ReDim Preserve result.Group(nrGroupSteps - 1).Step(nrSteps).EquipmentItem(UBound(testdata.Equipment))
            For i = 0 To UBound(testdata.Equipment)
                result.Group(nrGroupSteps - 1).Step(nrSteps).EquipmentItem(i).Name = testdata.Equipment(i).Name
                result.Group(nrGroupSteps - 1).Step(nrSteps).EquipmentItem(i).Value = testdata.Equipment(i).Value
            Next i
                      
            nrSteps = nrSteps + 1
        Else
            ' This line in neither sqr group nor are group nor test step. Add it to list
            ReDim Preserve warningLines(warningIndex)
            warningLines(warningIndex) = intCurRow
            warningIndex = warningIndex + 1
        End If
        intCurRow = intCurRow + 1
    Loop
    
    If UBound(warningLines) > -1 Then
        strWarning = "The following lines are not recognized and will be ignored: " & vbCrLf
        For i = 0 To UBound(warningLines)
            If warningLines(i) <> "" Then
                strWarning = strWarning & warningLines(i) & vbCrLf
                bShowWarning = True
            End If
        Next i
        strWarning = strWarning & vbCrLf & _
         "* A Grouped-Process-Step must at least have a value in the 'TestName',  the 'Key' and 'Grouped test = Y'. (column D, F and J)" & vbCrLf & vbCrLf & _
         "* A Process-Step must at least have a value in the 'TestName' and the 'Key'. (column D, F)" & vbCrLf & vbCrLf & _
         "* The FMS is used for <SQR Group> and is recognized by the name in column D and the other fields are empty." & vbCrLf & vbCrLf & _
         "Use CTRL+C to copy the information in this window"
        If bShowWarning Then
            MsgBox (strWarning)
        End If
    End If
    
    'the total duration should be taken from the G4 cell in de template. The format is something
    'like 123 hrs 45 min
    totDuration = recoverySheet.Cells(4, 7)
    int1 = InStr(1, totDuration, "hrs")
    If int1 > 0 Then
        intHours = CInt(Mid(totDuration, 1, int1 - 1))
        
        int2 = InStr(1, totDuration, "min")
        If int2 > 0 Then
            intMins = CInt(Mid(totDuration, int1 + 3, int2 - int1 - 3))
        End If
    Else
       '  the format is something like 12 min
       intHours = 0
       int2 = InStr(1, totDuration, "min")
       If int2 > 0 Then
            intMins = CInt(Mid(totDuration, 1, Len(totDuration) - 3))
       Else
            ' the format is something like 0.9, which means 0.9 hours
            intMins = totDuration * 60
       End If
    End If
    
    
    result.totalDuration = getXMLDurationFromIntegerMinutes(60 * intHours + intMins)
    getStepGroups = result
End Function
'--------------------------------------------------------------
' Get short chuckname from the template input
' CH1, CH2, CHB, NCH
'--------------------------------------------------------------
Private Function getShortChuck(chuck As String) As String
    Dim result As String
    
    If chuck = "Chuck 1" Then
        result = "CH1"
    ElseIf chuck = "Chuck 2" Then
        result = "CH2"
    ElseIf chuck = "Both chucks" Then
        result = "CHB"
    Else
        result = "NCH"
    End If
    getShortChuck = result
End Function

Private Function getHyperlink(link As String) As String
    Dim result As String
        
    If InStr(1, link, "http://coach.asml.com") > 0 Then
        result = Replace(link, "http://coach.asml.com", "")
    ElseIf InStr(1, link, "https://coach.asml.com") > 0 Then
        result = Replace(link, "https://coach.asml.com", "")
    ElseIf InStr(1, link, "http://localhost:8888") > 0 Then
        result = Replace(link, "http://localhost:8888", "")
    ElseIf InStr(1, link, "https://localhost:8888") > 0 Then
        result = Replace(link, "https://localhost:8888", "")
    ElseIf InStr(1, link, "http://coach-eu1.asml.com") > 0 Then
        result = Replace(link, "http://coach-eu1.asml.com", "")
    ElseIf InStr(1, link, "https://coach-eu1.asml.com") > 0 Then
        result = Replace(link, "https://coach-eu1.asml.com", "")
    Else
        result = "Error"
    End If
    
    getHyperlink = result
End Function

'--------------------------------------------------------------
' Get long chuckname from the template input
' Chuck1, Chuck2, Both
'--------------------------------------------------------------
Private Function getLongChuck(chuck As String) As String
    Dim result As String
    
    If chuck = "Chuck 1" Then
        result = "Chuck1"
    ElseIf chuck = "Chuck 2" Then
        result = "Chuck2"
    ElseIf chuck = "Both chucks" Then
        result = "Both"
    Else
        result = ""
    End If
    getLongChuck = result
End Function

Private Function chuckSame(chucka As String, chuckb As String) As Boolean
    Dim result As Boolean
    
    result = False
    
    If InStr(1, UCase(chucka), "NONE") > 0 And InStr(1, UCase(chuckb), "NONE") > 0 Then
        result = True
    ElseIf InStr(1, UCase(chucka), "BOTH") > 0 And InStr(1, UCase(chuckb), "BOTH") > 0 Then
        result = True
    ElseIf InStr(1, UCase(chucka), "1") > 0 And InStr(1, UCase(chuckb), "1") > 0 Then
        result = True
    ElseIf InStr(1, UCase(chucka), "2") > 0 And InStr(1, UCase(chuckb), "2") > 0 Then
        result = True
    ElseIf chucka = "" And InStr(1, UCase(chuckb), "NONE") > 0 Then
        result = True
    ElseIf chuckb = "" And InStr(1, UCase(chucka), "NONE") > 0 Then
        result = True
    End If
    
    chuckSame = result
End Function

'--------------------------------------------------------------
' Get the data from one test
'--------------------------------------------------------------
Private Function getDataFromTest(TestID As String, chuck As String, moid As String) As testdata
    Dim result As testdata
    Dim intCurRow As Integer
    Dim strText As String
    Dim str As String
    Dim equipmentItemIndex As Integer
    Dim beginPos As Integer
    Dim endPos As Integer
    Dim equipmentData As String
    Dim strKey As String
    Dim strVal As String
    Dim curPos As String
    Dim bTestIdFound As Boolean
    Dim sourceMoid As String
    Dim sourceChuck As String

    intCurRow = 1
    bTestIdFound = False
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If InStr(1, strText, TestID + " ") = 1 Then
            ' Check if moid and chuck are also the same
            sourceMoid = getOneItemFromTestData(strText, "MOID")
            sourceChuck = getChuckFromTestData(strText)
            If sourceMoid = moid And chuckSame(sourceChuck, chuck) Then
                result.NsVersion = getOneItemFromTestData(strText, "NSVersion")
                result.Scenario = getOneItemFromTestData(strText, "Scenario")
                result.Exec = getOneItemFromTestData(strText, "Exec")
            
                ReDim Preserve result.Equipment(0)
                'Filter equipment data from testdata
                equipmentItemIndex = 0
                curPos = 1
                beginPos = InStr(1, strText, "<equipment>") + Len("<equipment>")
                endPos = InStr(beginPos, strText, "</equipment>")
                equipmentData = Mid(strText, beginPos, endPos - beginPos)
                'get all the items from the equipment data
                Do While curPos < Len(equipmentData)
                    beginPos = InStr(curPos, equipmentData, "<")
                    endPos = InStr(beginPos, equipmentData, ">")
                    strKey = Mid(equipmentData, beginPos + 1, endPos - beginPos - 1)
                    If InStr(strKey, "/") = 0 Then
                        beginPos = endPos + 1
                        endPos = InStr(beginPos, equipmentData, "</")
                        strVal = Mid(equipmentData, beginPos, endPos - beginPos)
                        If (strVal <> "") And (strKey <> "Chuck") Then
                            ReDim Preserve result.Equipment(equipmentItemIndex)
                            result.Equipment(equipmentItemIndex).Name = strKey
                            result.Equipment(equipmentItemIndex).Value = strVal
                            equipmentItemIndex = equipmentItemIndex + 1
                        End If
                        curPos = InStr(endPos + 1, equipmentData, ">")
                    Else
                        curPos = endPos
                    End If
                Loop
                bTestIdFound = True
                Exit Do
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
    
    If Not bTestIdFound Then
        result.NsVersion = ""
        result.Scenario = ""
        ReDim Preserve result.Equipment(0)
    End If
    getDataFromTest = result
End Function
Private Function getChuckFromTestData(strTestData As String) As String
    Dim curPos As Integer
    Dim beginPos As Integer
    Dim endPos As Integer
    Dim executionIndex As Integer
    Dim executionData As String
    Dim result As String
    Dim strKey As String
    Dim strVal As String
    
    result = ""
    'First get the executionData
    executionIndex = 0
    curPos = 1
    beginPos = InStr(1, strTestData, "<execution>") + Len("<execution>")
    endPos = InStr(beginPos, strTestData, "</execution>")
    executionData = Mid(strTestData, beginPos, endPos - beginPos)

    Do While curPos < Len(executionData)
        beginPos = InStr(curPos, executionData, "<")
        endPos = InStr(beginPos, executionData, ">")
        strKey = Mid(executionData, beginPos + 1, endPos - beginPos - 1)
        If InStr(strKey, "/") = 0 Then
            beginPos = endPos + 1
            endPos = InStr(beginPos, executionData, "</")
            strVal = Mid(executionData, beginPos, endPos - beginPos)
            If (strKey = "Chuck") Then
                result = strVal
                Exit Do
            End If
            curPos = InStr(endPos + 1, executionData, ">")
        Else
            curPos = endPos
        End If
    Loop
    getChuckFromTestData = result
End Function


Private Function getOneItemFromTestData(testdata As String, dataItem As String) As String
    Dim beginPos As Integer
    Dim endPos As Integer
    
    beginPos = InStr(1, testdata, "<" & dataItem & ">") + Len(dataItem) + 2
    endPos = InStr(beginPos, testdata, "</")
    getOneItemFromTestData = Mid(testdata, beginPos, endPos - beginPos)
End Function

Private Function getEquipmentDataFromTestData(testdata As String) As NameVal()
    Dim result() As NameVal
    Dim equipmentItemIndex As Integer
    Dim beginPos As Integer
    Dim endPos As Integer
    Dim equipmentData As String
    Dim strKey As String
    Dim strVal As String
    Dim curPos As String
    
    'Filter equipment data from testdata
    equipmentItemIndex = 0
    curPos = 1
    beginPos = InStr(1, testdata, "<equipment>") + Len("<equipment>")
    endPos = InStr(beginPos, testdata, "</equipment>")
    equipmentData = Mid(testdata, beginPos, endPos - beginPos)
    
    Do While curPos < Len(equipmentData)
        beginPos = InStr(curPos, equipmentData, "<")
        endPos = InStr(beginPos, equipmentData, ">")
        strKey = Mid(equipmentData, beginPos + 1, endPos - beginPos - 1)
        If InStr(strKey, "/") = 0 Then
            beginPos = endPos + 1
            endPos = InStr(beginPos, equipmentData, "</")
            strVal = Mid(equipmentData, beginPos, endPos - beginPos)
            If (strVal <> "") And (strKey <> "Chuck") Then
                ReDim Preserve result(equipmentItemIndex)
                result(equipmentItemIndex).Name = strKey
                result(equipmentItemIndex).Value = strVal
                equipmentItemIndex = equipmentItemIndex + 1
            End If
            curPos = InStr(endPos + 1, equipmentData, ">")
        Else
            curPos = endPos
        End If
        
    Loop
    getEquipmentDataFromTestData = result
End Function


Public Function CreateGuid() As String
    Dim guid As GuidType
    Dim strGuid As String
    Dim retValue As LongPtr
    Const guidLength As Long = 39 'registry GUID format with null terminator {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    retValue = CoCreateGuid(guid)
    If retValue = 0 Then
        strGuid = String$(guidLength, vbNullChar)
        retValue = StringFromGUID2(guid, StrPtr(strGuid), guidLength)
        If retValue = guidLength Then
            ' valid GUID as a string
            strGuid = Replace(strGuid, "{", "")
            strGuid = Replace(strGuid, "}", "")
            CreateGuid = strGuid
        End If
    End If
End Function

Private Function getMOIDFromLink(link As String) As String
    Dim intB As Integer
    Dim intE As Integer
    
    If Len(link) < 4 Then
        getMOIDFromLink = ""
    Else
        intB = InStr(1, link, "moid=") + Len("moid=")
        intE = InStr(intB, link, "&")
    
        If intE = 0 Then
            getMOIDFromLink = Mid(link, intB, Len(link) - intB + 1)
        Else
            getMOIDFromLink = Mid(link, intB, intE - intB)
        End If
    
        If (InStr(1, getMOIDFromLink, "dummy", vbTextCompare) > 0) Then
            getMOIDFromLink = ""
        End If
    End If
    
End Function






Attribute VB_Name = "modExcel"
'------------------------------------------------
Declare Function GetLocaleInfo Lib "kernel32" Alias _
"GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, _
ByVal lpLCData As String, ByVal cchData As Long) As Long

Declare Function GetUserDefaultLCID% Lib "kernel32" ()

Public Const LOCALE_SLIST = &HC

Public Function GetListSeparator() As String
Dim ListSeparator As String
Dim lngRetVal1 As Long
Dim lngRetVal2 As Long
Dim lpLCDataVar As String

Dim intChrPos As Integer
Dim lngLocale As Long

lngLocale = GetUserDefaultLCID()

lngRetVal1 = GetLocaleInfo(lngLocale, LOCALE_SLIST, lpLCDataVar, 0)

ListSeparator = String$(lngRetVal1, 0)

lngRetVal2 = GetLocaleInfo(lngLocale, LOCALE_SLIST, ListSeparator, lngRetVal1)

intChrPos = InStr(ListSeparator, Chr$(0))
If intChrPos > 0 Then
    GetListSeparator = Left$(ListSeparator, intChrPos - 1)
Else
    GetListSeparator = ""
End If

End Function

Public Sub genDebugMsg(intDbgVal As Integer, strDbgTxt As String)

If intDbgVal <= intDbgLvl Then
    Debug.Print strDbgTxt
End If

End Sub

Public Sub genErrorMsg(Error As ErrObject, strRoutine As String, Optional varValue As Variant)

Dim intErrChc As Integer
Dim strErrMsg As String

strErrMsg = "Error " & Error.Number & " occurred in " & strRoutine & Chr(13) & err.Description & Chr(13)

Select Case varValue
Case Is = vbOKOnly
    intErrChc = MsgBox(strErrMsg, vbOKOnly)
    Resume Next
Case Is = vbYesNo
    intErrChc = MsgBox(strErrMsg & Chr(13) & "Do you want to continue? ", vbYesNo)
    If intErrChc = vbYes Then
        Resume Next
    Else
        ResumeUpdates
        End
    End If
Case Else
End Select

End Sub

Public Sub PickFile(strFileName As String, Optional strInitialFileName As String, _
    Optional strDescrName As String, Optional strFilterName As String, _
    Optional blnAllowMultiple As Boolean = False)

' Select a file using the built-in dialog forms

Dim fd As FileDialog
Dim vrtSelectedItem As Variant

Set fd = Application.FileDialog(msoFileDialogFilePicker)

With fd
    If strFilterName <> "" Then .InitialFileName = strFilterName
    If .Show = -1 Then
        For Each vrtSelectedItem In .SelectedItems
            If blnAllowMultiple And strFileName <> "" Then
                strFileName = strFileName & "#" & vrtSelectedItem
            Else
                strFileName = vrtSelectedItem
            End If
        Next vrtSelectedItem
    Else
        strFileName = ""
    End If
End With

End Sub

Public Sub SetCellValidation(strWorksheet As String, strCellName As String, _
    intValidationType As Integer, strValidationFormula As String)
    
' Allows to set the validation for a specific cell

    Sheets(strWorksheet).Activate
    Range(strCellName).Select
    
    With Selection.Validation
        .Delete
        If intValidationType = xlValidateInputOnly Then
            .Add Type:=xlValidateInputOnly, AlertStyle:=xlValidAlertStop, Operator _
            :=xlBetween
        ElseIf intValidationType = xlValidateList Then
            .Add Type:=intValidationType, AlertStyle:=xlValidAlertStop, Operator:= _
            xlBetween, Formula1:=strValidationFormula
        End If
        .IgnoreBlank = True
        .InCellDropdown = True
        .InputTitle = ""
        .ErrorTitle = "Input validation error"
        .InputMessage = ""
        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With

End Sub

Public Sub SetRangeValidation(strWorksheet As String, objRange As Object, _
    intValidationType As Integer, strValidationFormula As String)
    
' Allows to set the validation for an Excel cell range
    
    Sheets(strWorksheet).Activate
    objRange.Select
    
    With Selection.Validation
        .Delete
        If intValidationType = xlValidateInputOnly Then
            .Add Type:=xlValidateInputOnly, AlertStyle:=xlValidAlertStop, Operator _
            :=xlBetween
        ElseIf intValidationType = xlValidateList Then
            .Add Type:=intValidationType, AlertStyle:=xlValidAlertStop, Operator:= _
            xlBetween, Formula1:=strValidationFormula
        End If
        .IgnoreBlank = True
        .InCellDropdown = True
        .InputTitle = ""
        .ErrorTitle = ""
        .InputMessage = ""
        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
End Sub

Public Function FindCellInColumn(strText As String, strSheetname As String, intColVal As Integer, _
    lngStartRow As Long, Optional lngMaxRow As Long = 299) As Integer

' Looks downward, starting in row intStartRow, in column intColVal of
' worksheet strSheetName to find a cell with entry strText.
' Stops looking when RowNr exceeds intMaxRow.

Dim lngCurRow As Long

lngCurRow = lngStartRow
While lngCurRow <= lngMaxRow
    If Worksheets(strSheetname).Cells(lngCurRow, intColVal) = strText Then
        FindCellInColumn = lngCurRow
        Exit Function
    End If
    lngCurRow = lngCurRow + 1
Wend

FindCellInColumn = -1

End Function

Public Function FindCellInRow(strText As String, strSheetname As String, lngRowVal As Long, _
    intStartCol As Integer, Optional intMaxCol As Integer = 255) As Integer

' Looks downward, starting in row intStartRow, in column intColVal of
' worksheet strSheetName to find a cell with entry strText.
' Stops looking when RowNr exceeds intMaxRow.

Dim intCurCol As Integer

intCurCol = intStartCol
While intCurCol <= intMaxCol
    If Worksheets(strSheetname).Cells(lngRowVal, intCurCol) = strText Then
        FindCellInRow = intCurCol
        Exit Function
    End If
    intCurCol = intCurCol + 1
Wend

FindCellInRow = -1

End Function

Public Function fRange(lngMinRow As Long, intMinCol As Integer, lngMaxRow As Long, intMaxCol As Integer)

' Returns the range name used by Excel, such as B1:C5,
' for the range defined by (lngMinRow, intMinCol) and
' (lngMaxRow, intMaxCol)

fRange = fCell(lngMinRow, intMinCol) & ":" & fCell(lngMaxRow, intMaxCol)

End Function

Public Function fCell(varRowNr As Variant, intColNr As Integer, _
    Optional blnAbsoluteRow As Boolean = False, Optional blnAbsoluteCol As Boolean = False)

Dim strTmpVal As String

' Returns the Excel name of the cell at row intRow and column intCol
' The Booleans blnAbsoluteRow and blnAbsoluteCol define whether the reference shall be made absolute or not

strTmpVal = ""
If blnAbsoluteCol Then
    strTmpVal = strTmpVal & "$"
End If
strTmpVal = strTmpVal & fColName(intColNr)
If blnAbsoluteRow Then
    strTmpVal = strTmpVal & "$"
End If
strTmpVal = strTmpVal & Format(varRowNr, "####0")

fCell = strTmpVal

End Function

Public Function fColName(intColNr As Integer) As String

' Returns the column name (such as "AZ") for column nr intCol

If intColNr > 26 Then
    fColName = fChar(Int((intColNr - 1) / 26)) + fChar(fExcelMod(intColNr, 26))
Else
    fColName = fChar(intColNr)
End If

End Function

Public Function fChar(intVal As Integer) As String

' Converts a number in to the corresponding letter in the alphabet

fChar = Chr(64 + intVal)

End Function

Public Function fExcelMod(intVal, intModVal) As Integer

' The alternative mod function, working "properly" for negative numbers

fExcelMod = 1 + ((intVal - 1) Mod intModVal)

End Function

Public Sub SuspendUpdates()

' Procedure to suspend the automatic Excel calculations

With Application
    .Calculation = xlManual
    .MaxChange = 0.001
End With
ActiveWorkbook.PrecisionAsDisplayed = False

End Sub

Public Sub ResumeUpdates()

' Procedure to resume the automatic Excel calculations

With Application
    .Calculation = xlAutomatic
    .MaxChange = 0.001
End With
ActiveWorkbook.PrecisionAsDisplayed = False

End Sub

Public Sub TraceText(strText, Optional intTraceTextLevel As Integer = 1)

If intTraceTextLevel <= intTraceLevel Then
    Debug.Print strText
End If
End Sub

Public Function fYesNo(blnInvVal As Boolean) As String

If blnInvVal Then
    fYesNo = "Yes"
Else
    fYesNo = "No"
End If

End Function

Public Sub PauseTime(sglSeconds As Single)

Dim sglStartTime As Single

sglStartTime = Timer
Do While Timer < sglStartTime + sglSeconds
Loop

End Sub

Public Function blnYesNo(strInvVal As String) As Boolean

blnYesNo = (LCase(strInvVal) = "yes" Or LCase(strInvVal) = "y")

End Function

Public Sub CellAlign(strSheetname As String, intRow As Integer, intCol As Integer, _
    intHorAlign As Integer, intVertAlign As Integer)

Worksheets(strSheetname).Range(fCell(intRow, intCol)).Select
With Selection
    .HorizontalAlignment = intHorAlign
    .VerticalAlignment = intVertAlign
End With

End Sub

Public Function IsFile(strFileName As String, Optional blnErrorFound As Boolean = False) As Boolean

On Error GoTo ErrIsFile

IsFile = (strFileName <> "" And Len(Dir(strFileName)) > 0)
blnErrorFound = False

Exit Function

ErrIsFile:
MsgBox "Cannot access directory or file " & strFileName, vbCritical
IsFile = False
blnErrorFound = True

End Function

Public Function matMin(varVal1 As Variant, varVal2 As Variant) As Variant

If varVal1 <= varVal2 Then
    matMin = varVal1
Else
    matMin = varVal2
End If

End Function

Public Function matMax(varVal1 As Variant, varVal2 As Variant) As Variant

If varVal1 >= varVal2 Then
    matMax = varVal1
Else
    matMax = varVal2
End If

End Function

Public Function fCountStr(strTxt As String, strFind As String, Optional blnMatchCase As Boolean = True) As Integer

Dim intNrFound As Integer
Dim intCurPos As Integer
Dim strTmpTxt As String
Dim strTmpFnd As String

If blnMatchCase Then
    strTmpTxt = strTxt
    strTmpFnd = strFind
Else
    strTmpTxt = LCase(strTxt)
    strTmpFnd = LCase(strFind)
End If

intNrFound = 0
intCurPos = 1
While InStr(intCurPos, strTmpTxt, strTmpFnd) > 0
    intNrFound = intNrFound + 1
    intCurPos = InStr(intCurPos, strTmpTxt, strTmpFnd) + 1
Wend

fCountStr = intNrFound

End Function

Public Sub SplitText(strInvTxt As String, strTxtSep As String, strTxtArr() As String, Optional blnMltSepAsOne As Boolean = False)

Dim intCurPos As Integer
Dim strHlpTxt As String
Dim intNrTxt As Integer

strHlpTxt = strInvTxt
intNrTxt = 0
intCurPos = InStr(strHlpTxt, strTxtSep)

While intCurPos > 0
    If Not blnMltSepAsOne Or intCurPos > 1 Then
        intNrTxt = intNrTxt + 1
        ReDim Preserve strTxtArr(intNrTxt) As String
        strTxtArr(intNrTxt) = Left(strHlpTxt, intCurPos - 1)
    End If
    
    strHlpTxt = Mid(strHlpTxt, intCurPos + 1)
    intCurPos = InStr(strHlpTxt, strTxtSep)
Wend

If Len(strHlpTxt) > 0 Then
    intNrTxt = intNrTxt + 1
    ReDim Preserve strTxtArr(intNrTxt) As String
    strTxtArr(intNrTxt) = strHlpTxt
End If

End Sub

Public Function IsNumber(strInvTxt As String) As Boolean

Dim blnDecimalFound As Boolean
Dim strTmpTxt As String

strTmpTxt = Trim(strInvTxt)
If strTmpTxt = "" Then
    IsNumber = False
    Exit Function
End If

For i = 1 To Len(strTmpTxt)
    If Mid(strTmpTxt, i, 1) = "." Then
        If blnDecimalFound Then
            IsNumber = False
            Exit Function
        Else
            blnDecimalFound = True
        End If
    ElseIf Mid(strTmpTxt, i, 1) < 0 Or Mid(strTmpTxt, i, 1) > 9 Then
        IsNumber = False
        Exit Function
    End If
Next i

IsNumber = True
    
End Function

Public Sub genPrint(intFileId As Integer, strPrintLine As String, Optional blnNewLine As Boolean = False)

genPrintLine intFileId, strPrintLine
If blnNewLine Then
    genPrintLine intFileId, ""
End If

End Sub

Public Sub genPrintLine(intFileId As Integer, strPrintLine As String)

If intFileId <= 0 Then
    Debug.Print strPrintLine
Else
    Print #intFileId, strPrintLine
End If

End Sub

Public Function txtAddSpc(strInvTxt As String, intStrLen As Integer, intAlignType As Integer)

Dim intNrSpcL As Integer
Dim intNrSpcR As Integer

If Len(strInvTxt) < intStrLen Then
    Select Case intAlignType
    Case Is = 0 ' left align
        intNrSpcL = 0
        intNrSpcR = intStrLen - Len(strInvTxt)
    Case Is = 1 ' center
        intNrSpcL = (intStrLen - Len(strInvTxt)) \ 2
        intNrSpcR = intStrLen - Len(strInvTxt) - intNrSpcL
    Case Is = 2 ' right align
        intNrSpcL = intStrLen - Len(strInvTxt)
        intNrSpcR = 0
    Case Else
    End Select
    txtAddSpc = String(intNrSpcL, " ") & strInvTxt & String(intNrSpcR, " ")
Else
    txtAddSpc = Left(strInvTxt, intStrLen)
End If

End Function

Public Function genFormat(varInvVal As Variant, strInvFmt As String, _
    Optional blnAllowSign As Boolean = False, Optional varMinVal As Variant, Optional varMaxVal As Variant)

Dim strTmpTxt As String
Dim blnIsWithinRange As Boolean

blnIsWithinRange = True
If Not IsMissing(varMinVal) Then
    If varInvVal < varMinVal Then blnIsWithinRange = False
End If

If Not IsMissing(varMaxVal) Then
    If varInvVal > varMaxVal Then blnIsWithinRange = False
End If

If blnIsWithinRange Then
    If InStr(strInvFmt, "#") > 0 Then
        strTmpTxt = txtAddSpc(Format(varInvVal, strInvFmt), Len(strInvFmt), 2)
    Else
        strTmpTxt = Format(varInvVal, strInvFmt)
    End If
    
    If blnAllowSign And varInvVal >= 0 Then
        genFormat = " " & strTmpTxt
    Else
        genFormat = strTmpTxt
    End If
Else
    genFormat = txtAddSpc("-", Len(strInvFmt), 1)
End If

End Function

Public Function TranslateDate(strInvTxt As String) As String

Dim strHlpTxt As String

strHlpTxt = Replace(LCase(strInvTxt), "maa", "mar")
strHlpTxt = Replace(LCase(strHlpTxt), "mrt", "mar")
strHlpTxt = Replace(LCase(strHlpTxt), "okt", "oct")

TranslateDate = strHlpTxt

End Function

Public Function GetDateTimeValue(strInvTxt, Optional dblDefaultValue As Double = 0) As Double

On Error GoTo errGetDateTimeValue

GetDateTimeValue = CDbl(DateValue(strInvTxt)) + CDbl(TimeValue(strInvTxt))
Exit Function

errGetDateTimeValue:
GetDateTimeValue = dblDefaultValue

End Function
Public Function IsTime(strInvTxt As String) As Boolean

Dim dblTimVal As Double

On Error GoTo errIsTime

dblTimVal = CDbl(CDate(strInvTxt))
IsTime = True
Exit Function

errIsTime:
IsTime = False

End Function

Public Function IsBetween(varInvVal As Variant, varMinVal As Variant, varMaxVal As Variant) As Boolean

IsBetween = (varInvVal >= varMinVal And varInvVal <= varMaxVal)

End Function

Public Function RangeAverage(strSheetname As String, varMinRow As Variant, intMinCol As Integer, varMaxRow As Variant, intMaxCol As Integer) As Single

Dim intNrEntries As Integer
Dim sglSum As Single
Dim i As Long
Dim j As Integer

sglSum = 0
intNrEntries = 0

For i = varMinRow To varMaxRow
    For j = intMinCol To intMaxCol
        If IsNumber(Worksheets(strSheetname).Cells(i, j)) Then
            intNrEntries = intNrEntries + 1
            sglSum = sglSum + Val(Worksheets(strSheetname).Cells(i, j))
        End If
    Next j
Next i

If intNrEntries >= 1 Then
    RangeAverage = sglSum / intNrEntries
Else
    RangeAverage = 0
End If

End Function

Public Function matLog10(varInvVal As Variant) As Double

' VB only knows the ln function

If varInvVal <= 0 Then
    matLog10 = -1
Else
    matLog10 = Log(varInvVal) / Log(10)
End If

End Function

Public Function ReadLine(intNegFile, Optional blnResetData As Boolean = False) As String

Static lngChrPos As Long

Dim lngNrChr As Long
Dim strChr As String * 1

If blnResetData Then lngChrPos = 0

lngNrChr = 0
Do
    lngChrPos = lngChrPos + 1
    Get #intNegFile, lngChrPos, strChr
    strNewTxt = strNewTxt & strChr
Loop Until EOF(intNegFile) Or Asc(strChr) = 10 Or Asc(strChr) = 13
ReadLine = Replace(strNewTxt, Chr(10), Chr(13))

End Function

Public Sub SetStatusBar(strTitle As String)

Application.StatusBar = strTitle

End Sub

Public Function GetColor(strColorName As String) As Integer

Select Case LCase(strColorName)
    Case Is = "red"
        GetColor = 3
    Case Is = "orange"
        GetColor = 45
    Case Is = "yellow"
        GetColor = 6
    Case Is = "light green"
        GetColor = 4
    Case Is = "green"
        GetColor = 10
    Case Is = "light blue"
        GetColor = 8
    Case Is = "blue"
        GetColor = 41
    Case Is = "purple"
        GetColor = 13
    Case Is = "pink"
        GetColor = 7
    Case Is = "grey"
        GetColor = 48
    Case Is = "white"
        GetColor = 2
    Case Is = "black"
        GetColor = 1
    Case Else
        GetColor = 48
End Select

End Function

Public Sub SetRowColor(lngRowNr As Long, intRowColor As Integer, Optional strSheetname As String = "", Optional blnBoldFace As Boolean = False)

If strSheetname <> "" Then
    Worksheets(strSheetname).Select
End If

Rows(fRow(lngRowNr)).Select
With Selection.Interior
    .ColorIndex = intRowColor
    .Pattern = xlSolid
End With
Selection.Font.Bold = blnBoldFace

End Sub

Public Sub GroupRows(lngMinRow As Long, lngMaxRow As Long, Optional strSheetname As String = "", _
    Optional blnGroupLineAbove As Boolean = True)

If strSheetname <> "" Then
    Worksheets(strSheetname).Select
End If

With ActiveSheet.Outline
    .AutomaticStyles = False
    If blnGroupLineAbove Then
        .SummaryRow = xlAbove
    Else
        .SummaryRow = xlBelow
    End If
    .SummaryColumn = xlRight
End With

Rows(Format(lngMinRow, "####0") & ":" & Format(lngMaxRow, "####0")).Select
Selection.Rows.Group

End Sub

Public Sub ClearImmediatePane()

Application.SendKeys "^g ^a {DEL}"

End Sub

Public Function fRow(lngRowNr As Long) As String

' Returns the full row as used in Excel VBA

fRow = Format(lngRowNr, "####0") & ":" & Format(lngRowNr, "####0")

End Function

Public Function fColumn(intColNr As Integer, Optional intMaxColNr As Integer = -1) As String

' Returns the full column as used in Excel VBA

If intMaxColNr < 0 Then intMaxColNr = intColNr

fColumn = fColName(intColNr) & ":" & fColName(intMaxColNr)

End Function

Public Function fRows(lngRowNr As Long, Optional lngMaxRowNr As Long = -1) As String

If lngMaxRowNr < 0 Then lngMaxRowNr = lngRowNr

fRows = Format(lngRowNr, "####0") & ":" & Format(lngMaxRowNr, "####0")

End Function

Public Function fStr(strTxt As String) As String

' Adds "" to string

fStr = Chr(34) & strTxt & Chr(34)

End Function

Public Function SheetExists(strSheetname As String) As Boolean

Dim objSheet As Worksheet

On Error Resume Next
Set objSheet = Sheets(strSheetname)
On Error GoTo 0

SheetExists = (Not objSheet Is Nothing)

End Function

Public Function txtNormalCase(strTxt As String) As String

Dim strTmpTxt As String
Dim intChrInd As Integer

For intChrInd = 1 To Len(strTxt)
    If intChrInd = 1 Then
        strTmpTxt = UCase(Mid(strTxt, 1, 1))
    ElseIf Mid(strTxt, intChrInd - 1, 1) = " " Then
        strTmpTxt = strTmpTxt & UCase(Mid(strTxt, intChrInd, 1))
    Else
        strTmpTxt = strTmpTxt & LCase(Mid(strTxt, intChrInd, 1))
    End If
Next intChrInd

txtNormalCase = strTmpTxt

End Function

Public Sub HideColumn(strSheetname As String, intColInd As Integer, Optional blnHidden As Boolean = True)

Columns(fColumn(intColInd)).Select
Selection.EntireColumn.Hidden = blnHidden

End Sub

Public Function txtRemoveDoubles(strInvText As String, Optional strChar As String = "") As String

Dim strHlpText As String
Dim intChrInd As Integer

strHlpText = Mid(strInvText, 1, 1)

intChrInd = 1

Do
    intChrInd = intChrInd + 1
    If (Mid(strInvText, intChrInd, 1) = strChar Or strChar = "") And (Mid(strInvText, intChrInd, 1) = Mid(strInvText, intChrInd - 1, 1)) Then
    Else
        strHlpText = strHlpText & Mid(strInvText, intChrInd, 1)
    End If
Loop Until intChrInd >= Len(strInvText)
txtRemoveDoubles = strHlpText

End Function

Public Sub SetBorder(strSheetname As String, lngMinRow As Long, intMinCol As Integer, lngMaxRow As Long, intMaxCol As Integer, _
    lngBorderType As Long, intColorID As Integer, lngLineWidth As Long, Optional blnSkipAllOtherBorders As Boolean = False)
    
Dim blnNewMethod As Boolean

With Worksheets(strSheetname).Range(fRange(lngMinRow, intMinCol, lngMaxRow, intMaxCol))
    If blnSkipAllOtherBorders Then
        .Borders(xlDiagonalDown).LineStyle = xlNone
        .Borders(xlDiagonalUp).LineStyle = xlNone
        .Borders(xlEdgeLeft).LineStyle = xlNone
        .Borders(xlEdgeTop).LineStyle = xlNone
        .Borders(xlEdgeBottom).LineStyle = xlNone
        .Borders(xlEdgeRight).LineStyle = xlNone
        .Borders(xlInsideVertical).LineStyle = xlNone
        .Borders(xlInsideHorizontal).LineStyle = xlNone
    End If
        
    With .Borders(lngBorderType)
        .LineStyle = xlContinuous
        .ColorIndex = intColorID
        .TintAndShade = 0
        .Weight = lngLineWidth
    End With
End With

End Sub

Public Function GetHyperlinkAddress(strSheetname As String, lngCurRow As Long, intCurCol As Integer) As String

If Worksheets(strSheetname).Cells(lngCurRow, intCurCol).Hyperlinks.Count = 0 Then
    GetHyperlinkAddress = ""
Else
    GetHyperlinkAddress = Worksheets(strSheetname).Cells(lngCurRow, intCurCol).Hyperlinks(1).Address
End If

End Function

Public Function GetHyperlinkName(strSheetname As String, lngCurRow As Long, intCurCol As Integer) As String

If Worksheets(strSheetname).Cells(lngCurRow, intCurCol).Hyperlinks.Count = 0 Then
    GetHyperlinkName = ""
Else
    GetHyperlinkName = Worksheets(strSheetname).Cells(lngCurRow, intCurCol).Hyperlinks(1).Name
End If

End Function

Public Function GetHyperlinkSubAddress(strSheetname As String, lngCurRow As Long, intCurCol As Integer) As String

If Worksheets(strSheetname).Cells(lngCurRow, intCurCol).Hyperlinks.Count = 0 Then
    GetHyperlinkSubAddress = ""
Else
    GetHyperlinkSubAddress = Worksheets(strSheetname).Cells(lngCurRow, intCurCol).Hyperlinks(1).SubAddress
End If

End Function

Public Function IsSheet(strSheetname As String) As Boolean

Dim strDummy As String

On Error GoTo errHasSourceSheet

strDummy = Worksheets(strSheetname).Cells(1, 1)
IsSheet = True
Exit Function

errHasSourceSheet:
IsSheet = False

End Function

Public Function RangeExists(strSheetname As String, strRangeName As String) As Boolean

Dim strDummyVal As String

On Error GoTo errRangeExists

strDummyVal = Worksheets(strSheetname).Range(strRangeName)
RangeExists = True

Exit Function

errRangeExists:
RangeExists = False
End Function

Public Function CreateDir(strDir As String) As Boolean

' Check if strDir exists, if not, create it
On Error GoTo errCreateDir

If Dir(strDir, vbDirectory) = vbNullString Then
    MkDir strDir
    CreateDir = True
Else
    CreateDir = True
' Directory exists, no action needed
End If
Exit Function

errCreateDir:
CreateDir = False

End Function

Attribute VB_Name = "modExport"
Public Sub ExportSequence()

Const intHeightStep As Integer = 24
Dim intControlTop As Integer

intControlTop = 6

Load frmExport
SetControlTop frmExport.optExportTypeMPT, intControlTop, intHeightStep, True
SetControlTop frmExport.optExportTypeSequenceRunner, intControlTop, intHeightStep, True
SetControlTop frmExport.optSQRtoEPS, intControlTop, intHeightStep, True
SetControlTop frmExport.optExportTypeSAP, intControlTop, intHeightStep, True
SetControlTop frmExport.optExportTypeGRE, intControlTop, intHeightStep, True
frmExport.optExportTypeGRE.Value = True
SetControlTop frmExport.optExportTypeSAPME, intControlTop, intHeightStep, True
SetControlTop frmExport.optExportTypeTxt, intControlTop, intHeightStep, True

frmExport.Show 1

If blnOK Then
    If frmExport.optExportTypeGRE.Value Then
        GREExport
    ElseIf frmExport.optExportTypeMPT.Value Then
        XMLExport
    ElseIf frmExport.optExportTypeSAP.Value Then
        SAPExport
    ElseIf frmExport.optExportTypeSequenceRunner.Value Then
        ADECExport
    ElseIf frmExport.optSQRtoEPS Then
        TransferSequenceToEPS
    ElseIf frmExport.optExportTypeSAPME.Value Then
        SAPMEExport
    ElseIf frmExport.optExportTypeTxt.Value Then
        TxtExport
    Else
    End If
End If

Unload frmExport

End Sub


Public Sub XMLExport()

' On Error GoTo errXMLExport

Dim strExportTxt As String
Dim rngHeader As Range
Dim strColMin As String
Dim strColMax As String
Dim strMachType As String
Dim strMachCfg As String
Dim strSWRelease As String

Dim strSheetname As String

strSheetname = ActiveSheet.Name

Set rngHeader = Worksheets(strSheetname).Range(fRows(Range("header").row))

With Workbooks(strTemplate).Worksheets(strSheetname)

    Set rngHeader = .Range(fRows(.Range("header").row))

    strMachType = CoachMachineType(.Range("machinetype"))
    strMachCfg = .Range("configuration")
    strSWRelease = CoachSWRelease(.Range("swrelease"))

End With

strColMin = "A"
strColMax = "P"

strExportTxt = convert( _
    Workbooks(strTemplate).Worksheets(strSheetname), rngHeader, strColMin, strColMax, _
        strMachType, strMachCfg, strSWRelease, strSheetname, cProcedureNameCol)

frmTextWindow.outputBox.Text = strExportTxt
frmTextWindow.Caption = "AREX output"
frmTextWindow.lblTextWindow = "Below is the sequence in AREX format. Copy and paste the text below to any AREX-aware application. (Hint: press Ctrl-C, Ctrl-V)"

frmTextWindow.outputBox.SelStart = 0
frmTextWindow.outputBox.SelLength = Len(frmTextWindow.outputBox.Text)
frmTextWindow.outputBox.EnterFieldBehavior = fmEnterFieldBehaviorSelectAll


frmTextWindow.Show


Exit Sub
    
errXMLExport:
MsgBox "An error occurred during AREX conversion: " & vbCrLf & err.Description, vbCritical, "Conversion Error"
End Sub

Private Sub SetControlTop(objCtrl As Control, intTop As Integer, intStep As Integer, blnInclude As Boolean)

If blnInclude Then
    objCtrl.Top = intTop
    intTop = intTop + intStep
End If
objCtrl.Visible = blnInclude

End Sub

Public Sub SAPExport()

Dim strSheetname As String
strSheetname = ActiveSheet.Name

CreateSapExportFile strSheetname

End Sub

Public Sub GREExport()
    CreateGREExportFile ActiveSheet.Name
End Sub

Public Sub TxtExport()

Dim strSheetname As String
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long
Dim lngCurRow As Long
Dim strTxt As String
Dim strChuckSel As String
Dim blnSimple As Boolean

' Sequence validation against SMT: set blnSimple to TRUE
blnSimple = False

Load frmTextWindow
frmTextWindow.Caption = "Export - text format"
frmTextWindow.lblTextWindow = "Use CTRL+C CTRL+V to copy and paste the sequence shown below"

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

If blnSimple Then
    strTxt = Worksheets(strSheetname).Range("recovery") & vbCrLf & _
            Worksheets(strSheetname).Range("machinetype") & vbCrLf & _
            Worksheets(strSheetname).Range("swrelease")
Else
    strTxt = ""
End If
    
For lngCurRow = lngStartRecRow To lngLastSeqRow - 1
    With Worksheets(strSheetname)
        If .Cells(lngCurRow, cTestIDCol) <> "" Then
            strChuckSel = .Cells(lngCurRow, cPerChuckCol)
            If strChuckSel = "" Then strChuckSel = "-"
            
            If blnSimple Then
                strTxt = strTxt & _
                    txtAddSpc(.Cells(lngCurRow, cProcedureNameCol), 12, 0) & " #" & _
                    txtAddSpc(.Cells(lngCurRow, cTestIDCol), 20, 0) & vbCrLf
            Else
                strTxt = strTxt & "[] " & _
                    txtAddSpc(.Cells(lngCurRow, cProcedureNameCol), 12, 0) & " " & _
                    txtAddSpc(.Cells(lngCurRow, cTestNameCol), 64, 0) & " " & _
                    txtAddSpc(.Cells(lngCurRow, cTestIDCol), 20, 0) & " " & _
                    txtAddSpc(strChuckSel, 11, 0) & vbCrLf
            End If
        End If
    End With
Next lngCurRow

frmTextWindow.closeButton.Left = frmTextWindow.closeButton.Left + 200
frmTextWindow.Width = frmTextWindow.Width + 200
frmTextWindow.outputBox.Width = frmTextWindow.outputBox.Width + 200

frmTextWindow.outputBox.Font.Name = "Courier"
frmTextWindow.outputBox.Font.Size = 5
frmTextWindow.outputBox.Text = strTxt

frmTextWindow.outputBox.SelStart = 0
frmTextWindow.outputBox.SelLength = Len(frmTextWindow.outputBox.Text)

frmTextWindow.Show 0

End Sub

Attribute VB_Name = "modGREExport"

Public Sub CreateGREExportFile(strSheetname As String)

Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long
Dim lngCurRow As Long
Dim lngStartRow As Long
Dim wsGRE As Worksheet
Dim strCurFMS As String
Dim strMOID As String
Dim strMOIDType As String
Dim strChuckInfo As String
Dim strComment As String
Dim strName As String
Dim strStartMode As String
Dim strQueuableOverride As String
Dim blnHasDependency As Boolean
Dim strType As String
Dim moidLength As Integer
Dim moidBegin As Integer
Dim location As String


' [2014-12-18] Modified GRE output format (based on input Raoul van Esdonk)

On Error Resume Next

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

strMOIDType = "T"
location = GetConfigurationItemByName("location")
i = 4
While Not Worksheets("Settings").Cells(i, 1) = ""
    If Worksheets("Settings").Cells(i, 1) = location Then
        strMOIDType = Worksheets("Settings").Cells(i, 2)
    End If
    i = i + 1
Wend

' Open new excel file
Workbooks.Add
Application.DisplayAlerts = False
Sheets("Sheet2").Delete
Sheets("Sheet3").Delete
Application.DisplayAlerts = True
Set wsGRE = ActiveWorkbook.Worksheets("Sheet1")
ThisWorkbook.Activate

'Add header
With wsGRE
    .Cells(1, 1) = "Type"
    .Cells(1, 2) = "SubRouting"
    .Cells(2, 1) = "Name"
    .Cells(2, 2) = "DNxxxxxxxxx"
    .Cells(3, 1) = "Description"
    .Cells(4, 1) = "Header"
    .Cells(4, 2) = "RoutingStep"
    .Cells(5, 1) = "Header"
    .Cells(5, 2) = "Dependency"

    ' MBTR: SQR-267: Added code to write TestProcedure header definition
    .Cells(6, 1) = "Header"
    .Cells(6, 2) = "TestParameter"

    .Cells(4, 3) = "Name"
    .Cells(4, 4) = "Comment"
    .Cells(4, 5) = "ATime"
    .Cells(4, 6) = "BTime"
    .Cells(4, 7) = "LaborTime"
    .Cells(4, 8) = "Owner"
    .Cells(4, 9) = "Functionality"
    .Cells(4, 10) = "SwTestAbbreviation"
    .Cells(4, 11) = "EntryElement"
    .Cells(4, 12) = "MinVacuumState"
    .Cells(4, 13) = "MaxVacuumState"
    .Cells(4, 14) = "Containment"
    .Cells(4, 15) = "QualityGate"
    ' MBTR: SQR-267: Added code to write the TestID and QueueableOverride headers
    .Cells(4, 16) = "TestID"
    .Cells(4, 17) = "QueueableOverride"

    .Cells(5, 3) = "Predecessor"
    .Cells(5, 4) = "DependencyType"
    .Cells(5, 5) = "MinWaitingMinutes"
    .Cells(5, 6) = "MaxWaitingMinutes"
    .Cells(5, 7) = "MinWaitingDays"
    .Cells(5, 8) = "MaxWaitingDays"
    .Cells(5, 9) = "Direct"
    .Cells(5, 10) = "QueueRelated"
    .Cells(5, 11) = "Comment"

    ' MBTR: SQR-267: Added code to write TestProcedure header fields
    .Cells(6, 3) = "Name"
    .Cells(6, 4) = "Value"
End With

lngStepNr = -1
' MBTR: SQR-267: Increment value: 5 --> 6
lngOutRow = 6
'lngOutRow = 5
strCurFMS = ""

' MBTR: SQR-267: Added code to fetch the 'InitiatingNumber' value from the configuration (instead of the recovery name) for the 'Name' field
strName = GetConfigurationItemByName("InitiatingNumber", "ARE Recovr")
If strName <> "ARE Recovr" And Mid$(LCase$(strName), 1, 2) <> "dn" Then
    strName = "DN" & strName
End If

'wsGRE.Cells(2, 2) = ThisWorkbook.Worksheets(strSheetname).Range("recovery")
wsGRE.Cells(2, 2) = strName
wsGRE.Cells(3, 2) = "ARE" & Mid(ThisWorkbook.Worksheets(strSheetname).Range("areversion"), 1, InStr(ThisWorkbook.Worksheets(strSheetname).Range("areversion"), "(") - 1)
strComment = ThisWorkbook.Worksheets(strSheetname).Range("recovery") & Chr(10) & ThisWorkbook.Worksheets(strSheetname).Range("serviceaction") 'Added code to write Scenario names as routing step comment
' Convert all lines



For lngCurRow = lngStartRecRow To lngLastSeqRow
    If ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "" And ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "" Then
        strCurFMS = ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol)
    ElseIf Left(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cSAPCol), 3) <> "AR#" Then
        If ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, 1) <> "Skip" Then
                If ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) <> "S" Then exportsubsteps = True 'reset code to export all steps
                If ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "Y" Then
                    For lngLoopGroupRow = lngCurRow + 1 To lngLastSeqRow 'loop to determine if all substeps have procedures or not.
                        If ThisWorkbook.Worksheets(strSheetname).Cells(lngLoopGroupRow, cHasSubtestsCol) <> "S" Then Exit For
                        If (ThisWorkbook.Worksheets(strSheetname).Cells(lngLoopGroupRow, 3).Text = "" And _
                            ThisWorkbook.Worksheets(strSheetname).Cells(lngLoopGroupRow, cTestNameCol).Hyperlinks.Count = 0) Then
                            exportmaingroupsteps = True
                            exportsubsteps = False
                            Exit For
                        Else
                            exportsubsteps = True
                            exportmaingroupsteps = False
                        End If
                    Next lngLoopGroupRow
                End If
                
                If (ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "Y" And exportmaingroupsteps = False) Or _
                    (ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cHasSubtestsCol) = "S" And exportsubsteps = False) Or _
                    ((ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cVacuumStateCol) = "") And _
                      (ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cProcedureNameCol) = "") And _
                      (ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol) = "")) Then
                    'do nothing if mainstep doesnot need to export(subprocedures are present), and if substep does not need to export(missing subprocedures)
                Else
                    lngStepNr = lngStepNr + 1
                    wsGRE.Cells(lngOutRow + 1, 1) = Format(lngStepNr, "####0")
        
                    If lngStepNr > 0 Then
                        blnHasDependency = True
                    End If
        
                    wsGRE.Cells(lngOutRow + 1, 2) = "RoutingStep"
        
                
                    strHyperlink = GetHyperlinkName(strSheetname, lngCurRow, cTestNameCol)
                    strHyperlinkgSubAddress = GetHyperlinkSubAddress(strSheetname, lngCurRow, cTestNameCol)
                    If strHyperlink = "" Then
                        strHyperlink = GetHyperlinkName(strSheetname, lngCurRow, cProcedureNameCol)
                        strHyperlinkgSubAddress = GetHyperlinkSubAddress(strSheetname, lngCurRow, cProcedureNameCol)
                    End If
                    
                    If strHyperlink = "" Then
                        wsGRE.Cells(lngOutRow + 1, 3) = "Missing"
                    Else
                        moidBegin = InStr(strHyperlink, "moid=") + 5
                        moidLength = InStr(moidBegin, strHyperlink, "&") - moidBegin
                        If moidLength < 0 Then moidLength = Len(strHyperlink)
                        strMOID = "M" & Replace(Mid(strHyperlink, moidBegin, moidLength), "&", "")
                        If strHyperlinkgSubAddress <> "" Then
                            wsGRE.Cells(lngOutRow + 1, 3) = strMOID & "_" & strHyperlinkgSubAddress & "_" & strMOIDType
                        Else
                            wsGRE.Cells(lngOutRow + 1, 3) = strMOID & "_" & strMOIDType
                        End If
                    End If
        
                    strQueuableOverride = "No"
        
                    strStartMode = Trim$(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cStartModeCol))
                    If strStartMode = "A" Then
                        ' Automatic
                        strQueuableOverride = "FQ"
                    ElseIf strStartMode = "S" Then
                        ' Semi-automatic
                        strQueuableOverride = "Q"
                    ElseIf strStartMode = "M" Then
                        ' Manual
                        strQueuableOverride = "No"
                    End If
                    
                    wsGRE.Cells(lngOutRow + 1, 4) = Left(strComment, 255)
                    wsGRE.Cells(lngOutRow + 1, 4).WrapText = False
                    wsGRE.Cells(lngOutRow + 1, 5) = matMax(1, Int(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cATimeCol)))
                    wsGRE.Cells(lngOutRow + 1, 6) = matMax(1, Int(0.8 * Val(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cATimeCol))))
                    wsGRE.Cells(lngOutRow + 1, 7) = (matMax(1, Int(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cATimeCol))) + matMax(1, Int(0.8 * Val(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cATimeCol)))))
                    wsGRE.Cells(lngOutRow + 1, 8) = "ARE"
                    wsGRE.Cells(lngOutRow + 1, 9) = strCurFMS
                    wsGRE.Cells(lngOutRow + 1, 10) = Trim(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cTestExecCol))
                    wsGRE.Cells(lngOutRow + 1, 11) = (lngStepNr = 0)
                    wsGRE.Cells(lngOutRow + 1, 12) = "N.A."
                    wsGRE.Cells(lngOutRow + 1, 13) = "N.A."
                    wsGRE.Cells(lngOutRow + 1, 14) = False
                    wsGRE.Cells(lngOutRow + 1, 15) = "No"
                    ' MBTR: SQR-267: Added code to write the TestID and QueueableOverride
                    wsGRE.Cells(lngOutRow + 1, 16) = Trim(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cTestIDCol))
                    wsGRE.Cells(lngOutRow + 1, 17) = strQueuableOverride
        
                    If blnHasDependency Then
                        lngOutRow = lngOutRow + 1
                        wsGRE.Cells(lngOutRow + 1, 1) = Format(lngStepNr, "####0")
                        wsGRE.Cells(lngOutRow + 1, 2) = "Dependency"
                        wsGRE.Cells(lngOutRow + 1, 3) = Format(lngStepNr - 1, "####0")
                        wsGRE.Cells(lngOutRow + 1, 4) = "Technical"
                        wsGRE.Cells(lngOutRow + 1, 5) = ""
                        wsGRE.Cells(lngOutRow + 1, 6) = ""
                        wsGRE.Cells(lngOutRow + 1, 7) = ""
                        wsGRE.Cells(lngOutRow + 1, 8) = ""
                        wsGRE.Cells(lngOutRow + 1, 9) = False
                        wsGRE.Cells(lngOutRow + 1, 10) = False
                        wsGRE.Cells(lngOutRow + 1, 11) = ""
                    End If
        
                    ' MBTR: SQR-267: Added code to write chuck information
                    Select Case LCase(Trim$(ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cPerChuckCol)))
                        Case "chuck 1"
                            strChuckInfo = "CHUCK_1"
                        Case "chuck 2"
                            strChuckInfo = "CHUCK_2"
                        Case "both chucks"
                            strChuckInfo = "CHUCK_BOTH"
                        Case ""
                            strChuckInfo = "CHUCK_NONE"
                    End Select
        
                    ' MBTR: SQR-267: Added code to write the chuck information (TestParameter)
                    wsGRE.Cells(lngOutRow + 2, 1) = Format(lngStepNr, "####0")
                    wsGRE.Cells(lngOutRow + 2, 2) = "TestParameter"
                    wsGRE.Cells(lngOutRow + 2, 3) = "Chuck"
                    wsGRE.Cells(lngOutRow + 2, 4) = strChuckInfo
        
                    ' MBTR: SQR-267: Incremented: 1-- > 2
                    lngOutRow = lngOutRow + 2
                    'lngOutRow = lngOutRow + 1
                    
                End If
                exportmaingroupsteps = False
        End If
    End If
Next lngCurRow

Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic

' Show Excel file
wsGRE.Activate
End Sub

'---------------------------------------------------------------------------------------
' Procedure : GetConfigurationItemByName
' Author    : micbrouw
' Date      : 2-sep, 2015
' Purpose   : Get a configuration item by name (from the 'configuration' range)
'---------------------------------------------------------------------------------------
'
Public Function GetConfigurationItemByName(ByVal Key As String, Optional ByVal defaultIfNotFound As String = "") As String
    Dim strCfg As String
    Dim strArg() As String
    Dim intArg As Integer
    Dim strKey As String
    Dim strVal As String

    GetConfigurationItemByName = defaultIfNotFound

    strCfg = Worksheets("Recovery").Range("configuration").Value
    If strCfg <> "" Then
        strArg = Split(strCfg, ";")

        For intArg = 0 To UBound(strArg)
            strKey = Trim(Left(strArg(intArg), InStr(strArg(intArg), ":") - 1))
            strValue = Trim(Mid(strArg(intArg), InStr(strArg(intArg), ":") + 1))

            If LCase$(strKey) = LCase$(Key) Then
                If Len(strValue) = 0 Then
                    strValue = defaultIfNotFound
                End If

                GetConfigurationItemByName = strValue

                Exit For
            End If
        Next intArg
    End If
End Function

Public Sub SAPMEExport()

Dim intOutFile As Integer
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim lngCurRow As Long
Dim strSheetname As String
Dim strMOID As String
Dim strHandle As String
Dim strFileName As String
Dim strMOIDType As String
Dim strHyperlink As String

Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

If InStr(LCase(Worksheets(strSheetname).Range("configuration")), "testrig") > 0 Then
    strMOIDType = "A"
Else
    strMOIDType = "T"
End If

strFileName = ThisWorkbook.path & "\SAPME.xml"

intOutFile = FreeFile

Open strFileName For Output As #intOutFile

Print #intOutFile, "<?xml version=" & fStr("1.0") & " encoding=" & fStr("UTF-8") & " standalone=" & fStr("yes") & "?>"
Print #intOutFile, "<ns4:TransferObjectCollection xmlns:ns4=" & fStr("http://www.sap.com/me/datatransfer") & " xmlns:ns3=" & fStr("http://www.sap.com/me/productdefinition/domain") & " xmlns:ns2=" & fStr("http://www.sap.com/me/common/domain") & ">"

For lngCurRow = lngStartRecRow To lngLastSeqRow
    If ThisWorkbook.Worksheets(strSheetname).Cells(lngCurRow, cSAPCol) = "" Then
' Skip line, FMS
    Else
        Print #intOutFile, "<ns4:collection xsi:type=" & fStr("ns3:OperationDO") & " xmlns:xsi=" & fStr("http://www.w3.org/2001/XMLSchema-instance") & ">"
        
        strHyperlink = GetHyperlinkAddress(strSheetname, lngCurRow, cProcedureNameCol)
        If strHyperlink = "" Then
            strMOID = "Missing"
        Else
            strMOID = "M" & Replace(Mid(strHyperlink, InStr(strHyperlink, "moid=") + 5, 7), "&", "") & "_" & strMOIDType
        End If
        
        strHandle = "OperationBO:NL01," & strId & ",A"
        AddCustomFieldList intOutFile, strHandle, "COMPETENCE", "CMP1"
        AddCustomFieldList intOutFile, strHandle, "CRANE_REQUIRED", "false"
        AddCustomFieldList intOutFile, strHandle, "FUNCTIONAL_CLUSTER", "f"
        AddCustomFieldList intOutFile, strHandle, "LONG_TEXT", Worksheets(strSheetname).Cells(lngCurRow, cTestNameCol)
        AddCustomFieldList intOutFile, strHandle, "MACHINE_OPEN", "false"
        AddCustomFieldList intOutFile, strHandle, "NR_OF_OPERATORS", "1"
        AddCustomFieldList intOutFile, strHandle, "OPERATOR_POSITION", "A"
        AddCustomFieldList intOutFile, strHandle, "QUEUEABLE", "No"
        AddXMLField intOutFile, "createdDateTime", ""
        AddXMLField intOutFile, "modifiedDateTime", ""
        AddXMLField intOutFile, "revision", "A"
        AddXMLField intOutFile, "currentRevision", "true"
        AddXMLField intOutFile, "type", "NORMAL_OPERATION"
        AddXMLField intOutFile, "ns2:operation", strMOID
        AddXMLField intOutFile, "ns2:site", "NL01"
        AddXMLField intOutFile, "statusRef", "StatusBO:NL01,201"
        AddXMLField intOutFile, "maxLoop", "0"
        AddXMLField intOutFile, "resourceTypeRef", "ResourceTypeBO:NL01,DEFAULT"
        AddXMLField intOutFile, "ns2:description", "Scheduling operation"
        AddXMLField intOutFile, "requiredTimeInProcess", "0"
        
        Print #intOutFile, "</ns4:collection>"
    End If
Next lngCurRow

AddXMLField intOutFile, "ns4:sourceSite", "NL01"
AddXMLField intOutFile, "ns4:version", "6.0.3.5"
Print #intOutFile, "</ns4:TransferObjectCollection>"

Close #intOutFile

Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic

MsgBox "Outputfile saved as " & strFileName, vbOKOnly, "Export completed"

End Sub

Private Sub AddCustomFieldList(intOutFile As Integer, strHandle As String, strAttribute As String, strValue As String)

Print #intOutFile, "<customFieldList>"
AddXMLField intOutFile, "handle", strHandle
AddXMLField intOutFile, "attribute", strAttribute
AddXMLField intOutFile, "value", strValue
Print #intOutFile, "</customFieldList>"

End Sub

Private Sub AddXMLField(intOutFile As Integer, strName As String, strValue As String)

Print #intOutFile, "<" & strName & ">" & strValue & "</" & strName & ">"

End Sub

Private Function XMLDateTime() As String

XMLDateTime = Format(date, "yyyy-mm-dd") & "T" & Format(time, "hh:mm:ss") & ".000+02:00"

End Function

Private Function GetHyperlinkItem(strHyperlink As String, strItem As String) As String

Dim strSearchItem As String
strSearchItem = strItem & "="

If InStr(strHyperlink, strItem) = 0 Then
    GetHyperlinkItem = "None"
Else
    GetHyperlinkItem = Mid(strHyperlink, InStr(strHyperlink, strSearchItem) + Len(strSearchItem), InStr(InStr(strHyperlink, strSearchItem), strHyperlink, "&") - (InStr(strHyperlink, strSearchItem) + Len(strSearchItem)))
End If

End Function











Attribute VB_Name = "modGeneral"
Public Sub SuspendScreenUpdates()

Application.ScreenUpdating = False

End Sub

Public Sub ResumeScreenUpdates()

Application.ScreenUpdating = True

End Sub

Public Sub CreateHyperlinks(bUseLocalCoach As Boolean, header As tHeaderRecord)

' This routine is obsolete and will be removed - April 2014

Dim intCurRow As Integer
Dim intEndRow As Integer
Dim intStartRow As Integer
Dim intCol As Integer

Dim strHyperlink As String
Dim screenupdate As Boolean

Dim strSheetname As String
Dim strSpotSensorType As String

strSheetname = ActiveSheet.Name

screenupdate = Application.ScreenUpdating
If screenupdate Then
    Application.ScreenUpdating = False
End If

strSpotSensorType = GetSpotSensorType

' make sure the option buttons agree with the current links
If bUseLocalCoach Then
    Worksheets(strSheetname).optLocalCoach.Value = True
    Worksheets(strSheetname).optNetworkCoach.Value = False
Else
    Worksheets(strSheetname).optLocalCoach.Value = False
    Worksheets(strSheetname).optNetworkCoach.Value = True
End If


With ActiveSheet

    intStartRow = .Range("Hyperlinks").row
    intEndRow = .Range("Hyperlinks").Rows.Count + intStartRow
    
    intCol = .Range("Hyperlinks").Column
    intPerChuck = .Range("PerChuck").Column
    If header.Initialised Then
        For intCurRow = intStartRow To intEndRow
            If header.Initialised Then
                strHyperlink = fnProcedureLink(strSheetname, .Cells(intCurRow, intCol), header, .Cells(intCurRow, intPerChuck), strSpotSensorType, bUseLocalCoach)
            End If
        
            If InStr(LCase(strHyperlink), "coach") > 0 Or InStr(strHyperlink, ".html") > 0 Then
                .Hyperlinks.Add _
                    Anchor:=.Cells(intCurRow, intCol), _
                    Address:=strHyperlink
            Else
                .Cells(intCurRow, intCol).Hyperlinks.Delete
            End If
        Next
    Else
        On Error Resume Next
        Set colHL = ActiveSheet.Hyperlinks
        If err.Number <> 0 Then
            MsgBox "Could not get current hyperlinks collection"
        End If
        
        For Each h In ActiveSheet.Hyperlinks
            If bUseLocalCoach Then
                h.Address = Replace(h.Address, "coach.asml.com", "localhost:8888")
                h.Name = h.Address
            Else
                h.Address = Replace(h.Address, "localhost:8888", "coach.asml.com")
                h.Name = h.Address
            End If
        Next h
    End If
    
    .Range("a1").Select
End With

If screenupdate Then
    Application.ScreenUpdating = True
End If

End Sub

Public Function GetPlatformType(strSourceTxt As String) As String

On Error GoTo errGetPlatformType

Dim strTxtArr() As String

If InStr(strSourceTxt, "[Platform]") > 0 Then
    SplitText strSourceTxt, "]", strTxtArr()
ElseIf InStr(strSourceTxt, "\ARE\") > 0 Then
    SplitText Mid(strSourceTxt, InStr(strSourceTxt, "\ARE\") + 1), "\", strTxtArr()
Else
    SplitText Mid(strSourceTxt, InStr(strSourceTxt, "..") + 1), "\", strTxtArr()
End If

If UBound(strTxtArr) < 2 Then
    Debug.Print "Use default platformtype: NXT"
    GetPlatformType = "NXT"
Else
    GetPlatformType = strTxtArr(2)
End If

Exit Function

errGetPlatformType:
GetPlatformType = "Unknown"

End Function

Public Function GetRecoverySheetName() As String

On Error GoTo errGetRecoverySheetName

GetRecoverySheetName = Range("AreVersion").Worksheet.Name

Exit Function

errGetRecoverySheetName:
MsgBox "Cannot find the recovery sequence sheet." & vbCrLf & "A cell named AreVersion is not present in this workbook.", vbOKOnly
GetRecoverySheetName = ""

End Function

Public Function GetXMLValue(strText As String, strTag As String) As String

Dim strStartTag As String
Dim strEndTag As String
Dim intStartID As Integer
Dim intEndID As Integer

On Error GoTo errGetXMLValue

strStartTag = "<" & LCase(strTag) & ">"
strEndTag = "</" & LCase(strTag) & ">"

intStartID = InStr(LCase(strText), strStartTag) + Len(strStartTag)
intEndID = InStr(LCase(strText), strEndTag)
GetXMLValue = Mid(strText, intStartID, intEndID - intStartID)

Exit Function

errGetXMLValue:
GetXMLValue = ""

End Function
Attribute VB_Name = "modGeneralPartsAndTools"
Option Explicit
'-----------------------------------------------------------------------
'
' Contains general functions used for generating the parts en tools tab
'
'-----------------------------------------------------------------------

'---------------------------------------------------------------------------------------
' Procedure : IsInArray
' Date      : 2017, nov 16
' Purpose   : Check if a 12NC number is in the array with 12NC numbers. The array
'             consists of all SERV numbers that are full 12NCs. This means that the
'             last digit is NOT a revision/LD number. It is a completely new 12NC.
'---------------------------------------------------------------------------------------
Function IsInArray(stringToBeFound As String) As Boolean
    Dim TwelveNCArray As Variant
    
    TwelveNCArray = Array("SERV.434.", _
                          "SERV.438.", _
                          "SERV.439.", _
                          "SERV.473.", _
                          "SERV.478.", _
                          "SERV.479.", _
                          "SERV.488.", _
                          "SERV.489.", _
                          "SERV.502.", _
                          "SERV.626.", _
                          "SERV.628.", _
                          "SERV.629.", _
                          "SERV.663.", _
                          "4035.200.", _
                          "9428.998.", _
                          "9428.999.", _
                          "EREP.502.", _
                          "FURE.502.", _
                          "MOVE.502.")
    
    
    IsInArray = (UBound(Filter(TwelveNCArray, stringToBeFound)) > -1)
    
End Function

'---------------------------------------------------------------------------------------
' Procedure : findColumnWithName
' Date      : 2017, nov 16
' Purpose   : Find a column number with a specific header
'             name : the name of the header
'             ws   : the worksheet to look in
'             row  : the row to look in
'---------------------------------------------------------------------------------------
Function findColumnWithName(Name As String, ws As Worksheet, row As Integer) As Integer
    Dim i As Integer
    
    For i = 1 To 99
        If InStr(ws.Cells(row, i), Name) Then
            findColumnWithName = i
            Exit Function
        End If
    Next i
End Function

Attribute VB_Name = "modGenerateList"
Option Explicit
'-----------------------------------------------------------------------
'
' Contains the functionality to generate the parts and tools list and
' fill "Parts and Tools List" tab
'
'-----------------------------------------------------------------------

'---------------------------------------------------------------------------------------
' Procedure : GenerateList
' Date      : 2017, nov 16
' Purpose   : Generate the list with parts and tools
'---------------------------------------------------------------------------------------
Sub GenerateList()

    Dim wsList As Worksheet
    Dim wsPandT As Worksheet
    Dim a As Range
    Dim lHeaderRow As Integer
    Dim lTypeCol As Integer
    Dim lNCCol As Integer
    Dim lDescriptionCol As Integer
    Dim lQuantityCol As Integer
    Dim lUNDCol As Integer
    Dim lEarliestCol As Integer
    Dim lProcedureCol As Integer
    Dim ptHeaderRow As Integer
    Dim ptNCCol As Integer
    Dim ptQuantityCol As Integer
    Dim ptReqQuanCol As Integer
    Dim ptNumberCol As Integer
    Dim ptUNDCol As Integer
    Dim ptProcedureCol As Integer
    Dim ptTypeCol As Integer
    Dim ptDescriptionCol As Integer
    Dim ptLastLine As Integer
    Dim i As Integer
    Dim j As Integer
    Dim k As Integer
    Dim l As Integer
    Dim lCurRow As Integer
    Dim lLastLine As Integer
    Dim lLastLine2 As Integer
    Dim match As Boolean
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
  
    Set wsList = Worksheets("Parts and Tools list")
    wsList.Visible = True
    wsList.Activate
    Set wsPandT = Worksheets("Parts and Tools")
    
    Set a = wsList.Range("A:D").Find("12NC", LookIn:=xlValues, Lookat:=xlWhole)
    lHeaderRow = a.row
    Set a = wsPandT.Range("A:D").Find("Procedure", LookIn:=xlValues, Lookat:=xlWhole)
    ptHeaderRow = a.row

    ''''''''''' Clear the contents of the "parts and tools list" tab, not the header
    lCurRow = lHeaderRow + 1
    wsList.Range("A" & lCurRow, "Z10000").ClearContents
    wsList.Range("A" & lCurRow, "Z10000").ClearFormats

    ''''''''''' Define Column names
    lTypeCol = findColumnWithName("Type", wsList, lHeaderRow)
    lNCCol = findColumnWithName("12NC", wsList, lHeaderRow)
    lDescriptionCol = findColumnWithName("Description", wsList, lHeaderRow)
    lQuantityCol = findColumnWithName("Quantity", wsList, lHeaderRow)
    lUNDCol = findColumnWithName("Ultimate", wsList, lHeaderRow)
    lEarliestCol = findColumnWithName("Earliest", wsList, lHeaderRow)
    lProcedureCol = findColumnWithName("Procedure", wsList, lHeaderRow)
    ptNCCol = findColumnWithName("12NC", wsPandT, ptHeaderRow)
    ptQuantityCol = findColumnWithName("Quantity", wsPandT, ptHeaderRow)
    ptReqQuanCol = findColumnWithName("Required", wsPandT, ptHeaderRow)
    ptNumberCol = findColumnWithName("Occurences", wsPandT, ptHeaderRow)
    ptUNDCol = findColumnWithName("UND", wsPandT, ptHeaderRow)
    ptProcedureCol = findColumnWithName("Procedure", wsPandT, ptHeaderRow)
    ptTypeCol = findColumnWithName("Type", wsPandT, ptHeaderRow)
    ptDescriptionCol = findColumnWithName("Description", wsPandT, ptHeaderRow)

    '''''''''''' Fill Parts and tools list initially, from the output sheet.
    ptLastLine = wsPandT.Cells(wsPandT.Rows.Count, ptProcedureCol).End(xlUp).row

    For i = ptHeaderRow + 1 To ptLastLine
        If Not IsEmpty(wsPandT.Cells(i, ptNCCol)) Then
            wsList.Cells(lCurRow, lNCCol).Value = wsPandT.Cells(i, ptNCCol).Value
            wsList.Cells(lCurRow, lQuantityCol).Value = wsPandT.Cells(i, ptReqQuanCol).Value
            wsList.Cells(lCurRow, lUNDCol).Value = wsPandT.Cells(i, ptUNDCol).Value
            wsList.Cells(lCurRow, lTypeCol).Value = wsPandT.Cells(i, ptTypeCol).Value
            wsList.Cells(lCurRow, lDescriptionCol).Value = wsPandT.Cells(i, ptDescriptionCol).Value
            lCurRow = lCurRow + 1
        End If
    Next i
    


    '''''''''''' Process the parts and tools list (compress the list, determine earliest release date)
    lLastLine = wsList.Cells(wsList.Rows.Count, lNCCol).End(xlUp).row
    lLastLine2 = lLastLine

    For j = lLastLine To lHeaderRow Step -1
        For k = j + 1 To lLastLine2 + 2
            ''''''''' IsInArray check if the 12NC is a 11NC + LD or a 12NC
            If IsInArray(Left(wsList.Cells(j, lNCCol), 9)) = False Then
                ''''' In case of 11NC + LD and a double in the list
                If Left(wsList.Cells(j, lNCCol), 13) = Left(wsList.Cells(k, lNCCol), 13) Then
                    wsList.Cells(k, lUNDCol).Value = wsList.Cells(j, lUNDCol).Value
                    match = True
                End If
            Else
                ''''' In case of 12NC and a double in the list
                If Left(wsList.Cells(j, lNCCol), 14) = Left(wsList.Cells(k, lNCCol), 14) Then
                    wsList.Cells(k, lUNDCol).Value = wsList.Cells(j, lUNDCol).Value
                    match = True
                End If
            End If
            ''''' In case of no double in the list
            If Not match And wsList.Cells(j, lTypeCol) = "Tool" Then
                If Right(wsList.Cells(j, lUNDCol).Value, 2) = ".7" Then
                    wsList.Cells(j, lEarliestCol).Value = wsList.Cells(j, lUNDCol).Value + 0.6
                ElseIf Right(wsList.Cells(j, lUNDCol).Value, 2) = ".6" Then
                    wsList.Cells(j, lEarliestCol).Value = wsList.Cells(j, lUNDCol).Value + 0.6
                ElseIf Right(wsList.Cells(j, lUNDCol).Value, 2) = ".5" Then
                    wsList.Cells(j, lEarliestCol).Value = wsList.Cells(j, lUNDCol).Value + 0.6
                Else: wsList.Cells(j, lEarliestCol).Value = wsList.Cells(j, lUNDCol).Value + 0.3
                End If
            End If
        Next k

        '''''''''''' Delete doubles from list
        If match Then
            wsList.Rows(j).EntireRow.Delete Shift:=xlShiftUp
        End If
        match = False

        '''''''''''' Make all 4022 parts bold and red, because they should not be ordered

        lLastLine2 = wsList.Cells(wsList.Rows.Count, lNCCol).End(xlUp).row
    Next j

    For l = lHeaderRow To lLastLine2
        If Left(wsList.Cells(l, lNCCol), 5) = "4022." Then
            If Not (Left(wsList.Cells(l, lNCCol), 9) = "4022.502." Or Left(wsList.Cells(l, lNCCol), 9) = "4022.502.") Then 'toolkits have a 12NC starting with 4022.502.8 and they don't have a SERV equivalent. These should be used in the field and are therefore not displayed in red.
                wsList.Cells(l, lNCCol).Font.ColorIndex = 3
                wsList.Cells(l, lNCCol).Font.Bold = True
            End If
        End If
    Next l
    ActiveSheet.Range("A1").Select
    
    wsList.Columns("A:G").AutoFit
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
End Sub


Attribute VB_Name = "modGeneratePartsAndTools"
Option Explicit
'-----------------------------------------------------------------------
'
' Contains the functionality to generate the parts and tools and
' fill "Parts and Tool" tab
'
'-----------------------------------------------------------------------

Private Const MAX_PROC_COL_WIDTH As Integer = 120

Type Parttool
    twelveNC As String
    Description As String
End Type

Type DateTime
    date As String
    time As String
End Type

'---------------------------------------------------------------------------------------
' Procedure : GeneratePartsAndTools
' Date      : 2017, nov 16
' Purpose   : Generate the parts and tools
'---------------------------------------------------------------------------------------
Sub GeneratePartsAndTools()

    Dim wsPandT As Worksheet
    Dim wsRecovery As Worksheet
    Dim a As Range
    Dim currentRow As Integer
    Dim ptHeaderRow As Integer
    Dim ptProcedureCol As Integer
    Dim ptNameCol As Integer
    Dim ptDurationCol As Integer
    Dim ptNCCol As Integer
    Dim ptTypeCol As Integer
    Dim ptDescriptionCol As Integer
    Dim ptQuantityCol As Integer
    Dim ptReqQuanCol As Integer
    Dim ptNumberCol As Integer
    Dim recHeaderRow As Integer
    Dim recStartRow As Integer
    Dim recProcedureCol As Integer
    Dim recTestNameCol As Integer
    Dim recPartsCol As Integer
    Dim recToolsCol As Integer
    Dim recLastRow As Integer
    Dim recDurationCol As Integer
    Dim i As Integer
    Dim j As Integer
    Dim ptCurProcedureRow As Integer
    Dim hl As Hyperlinks
    Dim initialString As String
    Dim pts() As Parttool
    Dim recStart As Date
    Dim SearchRange As Range
    Dim SearchValue As String
    Dim MaxQuant As Integer
    Dim TotalQuant As Integer
    Dim ptStartDateCol As Integer
    Dim ptStartTimeCol As Integer
    Dim recStartTimeCol As Integer
    Dim d As Date
    Dim ds As String
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
  
    Set wsPandT = Worksheets("Parts and Tools")
    Set wsRecovery = Worksheets("Recovery")
    wsPandT.Visible = True
    wsPandT.Activate
  
    ''''''''''' Find where the header in the "parts and tools list" tab ends
    Set a = wsPandT.Range("A:F").Find("12NC", LookIn:=xlValues, Lookat:=xlWhole)
    ptHeaderRow = a.row
    currentRow = a.row + 1
  
    '''''''''''Find reference point in recovery sheet: 'Procedure' in the blue row ''''''''''
    Set a = wsRecovery.Range("A1:P35").Find("Procedure", LookIn:=xlValues, Lookat:=xlWhole)
    recHeaderRow = a.row
    recProcedureCol = a.Column
  
    ''''''''''' Clear the contents of the "parts and tools" tab, not the header
    wsPandT.Range("A" & currentRow, "Z10000").ClearContents
    wsPandT.Range("A" & currentRow, "Z10000").ClearFormats
    wsPandT.Range("A" & currentRow, "Z10000").Hyperlinks.Delete

    ''''''''''' Define Column names
    ptProcedureCol = findColumnWithName("Procedure", wsPandT, ptHeaderRow)
    ptNameCol = findColumnWithName("name", wsPandT, ptHeaderRow)
    ptDurationCol = findColumnWithName("Duration", wsPandT, ptHeaderRow)
    ptNCCol = findColumnWithName("12NC", wsPandT, ptHeaderRow)
    ptTypeCol = findColumnWithName("Type", wsPandT, ptHeaderRow)
    ptDescriptionCol = findColumnWithName("Description", wsPandT, ptHeaderRow)
    ptQuantityCol = findColumnWithName("Quantity", wsPandT, ptHeaderRow)
    ptReqQuanCol = findColumnWithName("Required quantity", wsPandT, ptHeaderRow)
    ptNumberCol = findColumnWithName("Occurences", wsPandT, ptHeaderRow)
    ptStartDateCol = findColumnWithName("Start Date", wsPandT, ptHeaderRow)
    ptStartTimeCol = findColumnWithName("Start Time", wsPandT, ptHeaderRow)
    recStartTimeCol = findColumnWithName("Estimated start time", wsRecovery, recHeaderRow)
    recTestNameCol = findColumnWithName("Name", wsRecovery, recHeaderRow)
    recPartsCol = findColumnWithName("Parts", wsRecovery, recHeaderRow)
    recToolsCol = findColumnWithName("Tools", wsRecovery, recHeaderRow)
    recDurationCol = findColumnWithName("A time", wsRecovery, recHeaderRow)
    
    ''''''''''' Fill header
    recStart = wsRecovery.Range("U6").Value
    If wsRecovery.Range("U6").Value = Empty Then
        wsPandT.Range("C6").Value = ""
        wsPandT.Range("C7").Value = ""
    Else
        wsPandT.Range("C6").Value = DateValue(recStart)
        wsPandT.Range("C7").Value = TimeValue(recStart)
    End If
    
    wsPandT.Range("H6").Value = Application.WorksheetFunction.RoundUp(wsRecovery.Range("U5").Value * 100, 0) / 100
    
    ''''''''''' Fill rows
    recLastRow = wsRecovery.Range("C" & Rows.Count).End(xlUp).row
    ptCurProcedureRow = ptHeaderRow + 1
    For i = recHeaderRow + 1 To recLastRow
        If Not IsEmpty(wsRecovery.Cells(i, recProcedureCol)) Then
            ''''''''''' Filter the parts from the string
            Call filterPartsAndTools(wsRecovery.Cells(i, recToolsCol).Value, pts)
            For j = 0 To UBound(pts)
                ''''''''''' Add the name, the duration, the type, the 12NC, the description and the quantity
                If Not (pts(j).Description = "" And pts(j).twelveNC = "") Then
                    wsPandT.Cells(ptCurProcedureRow, ptProcedureCol).Value = wsRecovery.Cells(i, recProcedureCol).Value
                    Set hl = wsRecovery.Cells(i, recProcedureCol).Hyperlinks
                    If hl.Count > 0 Then
                        wsPandT.Cells(ptCurProcedureRow, ptProcedureCol).Hyperlinks.Add Anchor:=wsPandT.Cells(ptCurProcedureRow, ptProcedureCol), Address:=hl(1).Address
                    End If
                    wsPandT.Cells(ptCurProcedureRow, ptNameCol).Value = wsRecovery.Cells(i, recTestNameCol).Value
                    wsPandT.Cells(ptCurProcedureRow, ptDurationCol).Value = wsRecovery.Cells(i, recDurationCol).Value
                    wsPandT.Cells(ptCurProcedureRow, ptTypeCol).Value = "Tool"
                    wsPandT.Cells(ptCurProcedureRow, ptNCCol).Value = pts(j).twelveNC
                    wsPandT.Cells(ptCurProcedureRow, ptDescriptionCol).Value = pts(j).Description
                    wsPandT.Cells(ptCurProcedureRow, ptQuantityCol).Value = QuantityFromString(wsPandT.Cells(ptCurProcedureRow, ptDescriptionCol).Value)
                    If wsRecovery.Cells(i, recStartTimeCol).Value = Empty Then
                        wsPandT.Cells(ptCurProcedureRow, ptStartDateCol).Value = ""
                        wsPandT.Cells(ptCurProcedureRow, ptStartTimeCol).Value = ""
                    Else
                        wsPandT.Cells(ptCurProcedureRow, ptStartDateCol).Value = DateValue(wsRecovery.Cells(i, recStartTimeCol).Value)
                        wsPandT.Cells(ptCurProcedureRow, ptStartTimeCol).Value = TimeValue(wsRecovery.Cells(i, recStartTimeCol).Value)
                    End If
                    ptCurProcedureRow = ptCurProcedureRow + 1
                End If
            Next
            ReDim pts(0)
            ''''''''''' Filter the tools from the string
            Call filterPartsAndTools(wsRecovery.Cells(i, recPartsCol).Value, pts)
            For j = 0 To UBound(pts)
                ''''''''''' Add the name, the duration, the type, the 12NC, the description and the quantity
                If Not (pts(j).Description = "" And pts(j).twelveNC = "") Then
                    wsPandT.Cells(ptCurProcedureRow, ptProcedureCol).Value = wsRecovery.Cells(i, recProcedureCol).Value
                    Set hl = wsRecovery.Cells(i, recProcedureCol).Hyperlinks
                    If hl.Count > 0 Then
                        wsPandT.Cells(ptCurProcedureRow, ptProcedureCol).Hyperlinks.Add Anchor:=wsPandT.Cells(ptCurProcedureRow, ptProcedureCol), Address:=hl(1).Address
                    End If
                    wsPandT.Cells(ptCurProcedureRow, ptNameCol).Value = wsRecovery.Cells(i, recTestNameCol).Value
                    wsPandT.Cells(ptCurProcedureRow, ptDurationCol).Value = wsRecovery.Cells(i, recDurationCol).Value
                    wsPandT.Cells(ptCurProcedureRow, ptTypeCol).Value = "Part"
                    wsPandT.Cells(ptCurProcedureRow, ptNCCol).Value = pts(j).twelveNC
                    wsPandT.Cells(ptCurProcedureRow, ptDescriptionCol).Value = pts(j).Description
                    wsPandT.Cells(ptCurProcedureRow, ptQuantityCol).Value = QuantityFromString(wsPandT.Cells(ptCurProcedureRow, ptDescriptionCol).Value)
                    If wsRecovery.Cells(i, recStartTimeCol).Value = Empty Then
                        wsPandT.Cells(ptCurProcedureRow, ptStartDateCol).Value = ""
                        wsPandT.Cells(ptCurProcedureRow, ptStartTimeCol).Value = ""
                    Else
                        wsPandT.Cells(ptCurProcedureRow, ptStartDateCol).Value = DateValue(wsRecovery.Cells(i, recStartTimeCol).Value)
                        wsPandT.Cells(ptCurProcedureRow, ptStartTimeCol).Value = TimeValue(wsRecovery.Cells(i, recStartTimeCol).Value)
                    End If
                    ptCurProcedureRow = ptCurProcedureRow + 1
                End If
            Next
        End If
    Next i
    
    ''''''''''' calculate the required quantity
    For i = ptHeaderRow + 1 To ptCurProcedureRow - 1
        MaxQuant = 0
        TotalQuant = 0

        If Not IsEmpty(wsPandT.Cells(i, ptNCCol).Value) Then
            ''''''''''''' Fill the column with # of occurences in sequence
            '''' Fill for 12NCs
            If IsInArray(Left(wsPandT.Cells(i, ptNCCol), 9)) Then
                SearchValue = wsPandT.Cells(i, ptNCCol).Value
                Set SearchRange = wsPandT.Range(wsPandT.Cells(ptHeaderRow, ptNCCol), wsPandT.Cells(ptCurProcedureRow + 100, ptNCCol))
                wsPandT.Cells(i, ptNumberCol) = Application.WorksheetFunction.CountIf(SearchRange, SearchValue)
            '''' Fill for 11NCs + LD
            Else
                SearchValue = Left(wsPandT.Cells(i, ptNCCol), 13)
                Set SearchRange = wsPandT.Range(wsPandT.Cells(ptHeaderRow, ptNCCol), wsPandT.Cells(ptCurProcedureRow + 100, ptNCCol))
                wsPandT.Cells(i, ptNumberCol) = Application.WorksheetFunction.CountIf(SearchRange, SearchValue & "*")
            End If
        
            ''''''''''''' Fill the required quantity column
            For j = ptHeaderRow + 1 To ptCurProcedureRow - 1
                '''' Fill for 12NCs
                If IsInArray(Left(wsPandT.Cells(i, ptNCCol), 9)) Then
                    If wsPandT.Cells(j, ptNCCol) = wsPandT.Cells(i, ptNCCol) Then
                        TotalQuant = TotalQuant + wsPandT.Cells(j, ptQuantityCol)
                        If wsPandT.Cells(j, ptQuantityCol).Value > MaxQuant Then
                            MaxQuant = wsPandT.Cells(j, ptQuantityCol).Value
                        End If
                    End If
                '''' Fill for 11NCs + LD
                Else
                    If Left(wsPandT.Cells(j, ptNCCol), 13) = Left(wsPandT.Cells(i, ptNCCol), 13) Then
                        TotalQuant = TotalQuant + wsPandT.Cells(j, ptQuantityCol)
                        If wsPandT.Cells(j, ptQuantityCol).Value > MaxQuant Then
                            MaxQuant = wsPandT.Cells(j, ptQuantityCol).Value
                        End If
                    End If
                End If
            
                If wsPandT.Cells(i, ptTypeCol) = "Tool" Then
                    wsPandT.Cells(i, ptReqQuanCol) = MaxQuant
                End If
                If wsPandT.Cells(i, ptTypeCol) = "Part" Then
                    wsPandT.Cells(i, ptReqQuanCol) = TotalQuant
                End If
            Next j
        Else
            wsPandT.Cells(i, ptReqQuanCol) = 0
            wsPandT.Cells(i, ptNumberCol) = 0
        End If
    Next i
    
    ''''''''''' update the dates
    Call updateDates
  
    wsPandT.Columns("A:K").AutoFit
    
    If (wsPandT.Columns(ptNameCol).ColumnWidth > MAX_PROC_COL_WIDTH) Then
        wsPandT.Columns(ptNameCol).ColumnWidth = MAX_PROC_COL_WIDTH
    End If
    
    
    wsPandT.Activate
    With ActiveWindow
        If .FreezePanes Then .FreezePanes = False
        .SplitColumn = 0
        .SplitRow = ptHeaderRow
        .FreezePanes = True
    End With
    
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
End Sub

'---------------------------------------------------------------------------------------
' Procedure : filterPartsAndTools
' Date      : 2017, nov 16
' Purpose   : Filter the parts or tools from a string. The result will be an array of
'             Parttool
'---------------------------------------------------------------------------------------
Function filterPartsAndTools(initialString As String, ByRef pts() As Parttool) As Boolean
    Dim inputString As String
    Dim partstools() As String
    Dim tmp As String
    Dim i As Integer
    Dim pt As Parttool
    
    inputString = initialString
    inputString = Trim(inputString)
    ReDim pts(0)
             
    ''''' Delete " - " delimeter that sometimes occurs in front of the string
    If Left(inputString, 2) = "- " Then
        inputString = Replace(inputString, Left(inputString, 2), "", , 1)
    End If
    inputString = Trim(inputString)
        
    If Not (InStr(inputString, "No special tools needed") > 0) And Not (InStr(inputString, "No special parts needed") > 0) Then
        partstools = Split(inputString, "||")
        ReDim pts(UBound(partstools))
        For i = 0 To UBound(partstools)
            tmp = partstools(i)
            If Left(tmp, 5) = "SERV." Or Left(tmp, 5) = "4022." Or Left(tmp, 5) = "9428." Then
                Call TwelveNCFound(tmp, pt)
            Else
                Call DescriptionFound(tmp, pt)
            End If
            pts(i) = pt
        Next i
    End If
End Function
'---------------------------------------------------------------------------------------
' Procedure : TwelveNCFound
' Date      : 2017, nov 16
' Purpose   : A 12NC is found, filter it and put it in the Parttool
'---------------------------------------------------------------------------------------
Sub TwelveNCFound(inputString, ByRef pt As Parttool)
    Dim DashDelimiter As Long
    Dim StripeDelimiter As Long
    Dim StringLength As Long
    Dim stringInProgress As Boolean
    Dim wsPandT As Worksheet

    Set wsPandT = Worksheets("Parts and Tools")
    
    DashDelimiter = InStr(inputString, " - ")
    StripeDelimiter = InStr(inputString, "||")

    pt.twelveNC = Left(inputString, 14)

    If StripeDelimiter > 0 Then
        pt.Description = Mid(inputString, DashDelimiter + 3, StripeDelimiter - DashDelimiter - 3)
    Else
        StringLength = Len(inputString)
        pt.Description = Right(inputString, StringLength - DashDelimiter - 2)
    End If
End Sub

'---------------------------------------------------------------------------------------
' Procedure : DescriptionFound
' Date      : 2017, nov 16
' Purpose   : A description is found, filter it and put it in the Parttool
'---------------------------------------------------------------------------------------
Sub DescriptionFound(inputString, ByRef pt As Parttool)
    Dim StripeDelimiter As Long

    StripeDelimiter = InStr(inputString, "||")

    pt.twelveNC = ""
    If StripeDelimiter > 0 Then
        pt.Description = Left(inputString, StripeDelimiter - 1)
    Else
        pt.Description = inputString
    End If
End Sub

'---------------------------------------------------------------------------------------
' Procedure : QuantityFromString
' Date      : 2017, nov 16
' Purpose   : Filter out the quantity (format xN) of a string
'---------------------------------------------------------------------------------------
Function QuantityFromString(strDescription As String) As String
    Dim objRegExp_1 As Object

    Set objRegExp_1 = CreateObject("vbscript.regexp")
    objRegExp_1.Global = True
    objRegExp_1.IgnoreCase = True
    objRegExp_1.Pattern = "[\(][x][\d{1,2}(?!\d)][\)]"

    If objRegExp_1.Execute(strDescription).Count <> 0 Then
        QuantityFromString = Mid(objRegExp_1.Execute(strDescription).Item(0), 3, 1)
    Else
        QuantityFromString = 1
    End If
End Function

'---------------------------------------------------------------------------------------
' Procedure : updateDates
' Date      : 2017, nov 16
' Purpose   : Update the dates
'---------------------------------------------------------------------------------------
Sub updateDates()
    Dim wsPandT As Worksheet
    Dim wsRecovery As Worksheet
    Dim a As Range
    Dim ptHeaderRow As Integer
    Dim ptProcedureCol As Integer
    Dim ptDurationCol As Integer
    Dim ptLastLine As Integer
    Dim ptUsageCol As Integer
    Dim ptUNDCol As Integer
    Dim ptStartDateCol As Integer
    Dim ptStartTimeCol As Integer
    Dim i As Integer
    Dim j As Integer
    Dim startDate As String
    Dim startTime As String
    Dim daysPerWeek As Integer
    Dim hoursPerDay As Integer
    Dim bTimeFactor As Double
    Dim currentDate As Date
    Dim currentTime As Date
    Dim procedure1 As String
    Dim procedure2 As String
    Dim duration As Double
    Dim procTime As Double
    Dim yearNumber As String
    Dim weekNumber As String
    Dim dayOfWeek As String
    Dim startDateVal As String
    Dim startTimeVal As String
    Dim bCurrentTimeSet As Boolean
    Dim recStart As String
    Dim usageDate As Date
    Dim UNDDate As Date
    
    Application.Calculation = xlCalculationManual
    Application.ScreenUpdating = False
    bCurrentTimeSet = False

    Set wsPandT = Worksheets("Parts and Tools")
    Set wsRecovery = Worksheets("Recovery")

    Set a = wsPandT.Range("A:F").Find("12NC", LookIn:=xlValues, Lookat:=xlWhole)
    ptHeaderRow = a.row
    ptProcedureCol = findColumnWithName("Procedure", wsPandT, ptHeaderRow)
    ptDurationCol = findColumnWithName("Duration", wsPandT, ptHeaderRow)
    ptUsageCol = findColumnWithName("Usage", wsPandT, ptHeaderRow)
    ptUNDCol = findColumnWithName("UND", wsPandT, ptHeaderRow)
    ptStartDateCol = findColumnWithName("Start Date", wsPandT, ptHeaderRow)
    ptStartTimeCol = findColumnWithName("Start Time", wsPandT, ptHeaderRow)
    
    recStart = wsRecovery.Range("U6").Value
    If recStart = Empty Then
        startDate = ""
        startTime = ""
    Else
        startDate = DateValue(recStart)
        startTime = TimeValue(recStart)
    End If
    daysPerWeek = wsPandT.Range("F6").Value
    hoursPerDay = wsPandT.Range("F7").Value * 60
    bTimeFactor = wsPandT.Range("H6").Value

  
    startDateVal = wsPandT.Cells(ptHeaderRow + 1, ptStartDateCol).Value
    startTimeVal = wsPandT.Cells(ptHeaderRow + 1, ptStartTimeCol).Value
    If (startDateVal <> "") And (startTimeVal <> "") Then
        startDate = startDateVal
        startTime = startTimeVal
    End If
        
    If Not (startDate = "" Or startTime = "") Then
        currentDate = startDate
        currentTime = startTime
        bCurrentTimeSet = True
    End If
    
    ''''''''''''''''''''''''''' Find last line of the sheet ''''''''''''''''''''''''''''''
    ptLastLine = wsPandT.Range("B" & Rows.Count).End(xlUp).row

    'SOER code removed 2
        
    'SOER code removed 1

    For j = ptHeaderRow + 1 To ptLastLine
            
        If wsPandT.Cells(j, ptStartDateCol).Value <> "" Then
            'first determine the usage date
            usageDate = wsPandT.Cells(j, ptStartDateCol).Value
            wsPandT.Cells(j, ptUsageCol).NumberFormat = "General"
            wsPandT.Cells(j, ptUsageCol).Value = getUNDFormat(usageDate)
    
            'determine UND
            UNDDate = DateAdd("d", -2, usageDate)
            wsPandT.Cells(j, ptUNDCol).NumberFormat = "General"
            wsPandT.Cells(j, ptUNDCol).Value = getUNDFormat(UNDDate)
        Else
            wsPandT.Cells(j, ptUNDCol).Value = ""
        End If
    Next j

    wsPandT.Columns("A:K").AutoFit
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True

End Sub

Function getUNDFormat(d As Date) As String
    Dim yearNumber As String
    Dim weekNumber As String
    Dim dayNumber As String
    
    yearNumber = Mid(Year(d), 3, 2)
    weekNumber = Format(DatePart("ww", d, vbMonday, vbFirstJan1), "00")
    dayNumber = Weekday(d, vbMonday)

    getUNDFormat = yearNumber & weekNumber & "." & dayNumber
End Function

Attribute VB_Name = "modHelp"
' Short keys available in templateFG.xls
' ======================================
'
' CTRL+ALT+a Hide/unhide the ARE seq file contents in the Source sheet
' CTRL+ALT+b RepairSequence
' CTRL+ALT+c Clear the Template file
' CTRL+ALT+d Toggle Show Differences between sequence and source
' CTRL+ALT+f Toggle Show additional information (StartMode, exec, project, SAP key)
' CTRL+ALT+h Repair Hyperlinks
' CTRL+ALT+l Reload Sequence
' CTRL+ALT+m Convert one or more seq files to xls
' CTRL+ALT+n Enter current date and time
' CTRL+ALT+o Manual load seq file
' CTRL+ALT+p Show partial sequence
' CTRL+ALT+r Repair Sheet
' CTRL+ALT+s Show selected scenarios in list form
' CTRL+ALT+t ToggleShowComments (comments must be available in file AREComments.xls, in dependencies directory)
' CTRL+ALT+u CustomizeSequence (as defined in file AREComments.xls, in dependencies directory)
' CTRL+ALT+x Export sequence to XML format

Attribute VB_Name = "modReadInit"
' Option Base 0
' Option Explicit

Declare Function GetCommandLine Lib "kernel32" Alias "GetCommandLineW" () As Long
Declare Function GetCommandLineA Lib "kernel32" () As String
Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long
Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (MyDest As Any, MySource As Any, ByVal MySize As Long)

Public Const cTestId As Integer = 4
Public Const cImport As Integer = 8
Public Const cFunctionalStep As Integer = 1
Public Const cProcTypes As String = "Test:IntegrationInstall:Service"

Public Const cTestProc As Integer = 1
Public Const cInstallProc As Integer = 2
Public Const cServiceProc As Integer = 3

Public blnDebugMode As Boolean
Public intNrDigits As Integer
Public sngBFactor As Single
Public blnNoRename As Boolean
Public strStop As String

Public Const blnGetDetailsFromSource As Boolean = True
Public Const blnReduceProcedureName As Boolean = False

Public Const strFMSDiagnostics As String = "DIAGNOSTIC_STEPS"
Public Const strFMSDTWP As String = "DTWP"
Public Const strFMSHWReplacement As String = "HW_REPLACEMENT"

Public seqInputFile As String
Public strTemplate As String
Public strSourceDir As String
Public strResultDir As String
Public strProcTypeList(3) As String
Public strDebugFile As String

Public blnShowSQRDuration As Boolean
Public blnShowDurationSimple As Boolean

Public Type tHeaderRecord
    Initialised As Boolean
    platform As String
    Release As String
    SourceRelease As String
    ReleaseCandidate As String
    Scenarios As String
    States As String
    PatchLevel As String
    MachineType As String
    MachineSpec As String
    Architecture As String
    SourceType As String
    recovery As String
    serviceaction As String
    Version As String
    Modified As String
    Revision As String
    ExportDate As String
    Configuration As String
    Status As String
    Published As String
    StartStep As String
    StopStep As String
    Procedures As Integer
    ChuckSelection As String
    SpotSensorType As String
    RecoveryReduction As String
    SourceSWatLeast As String
End Type

Public Type tProcedure
    ProcCol As Integer
    MOIDCol As Integer
End Type

Function OpenInputFile() As Boolean
    Dim seqfile As String
    Dim strDivision As String
    Dim strCommand As String
    Dim strCommandA As String
    Dim strSheetname As String
    
    Dim header As tHeaderRecord
    Dim screenupdate As Boolean
    
    SetTemplateNameDir
    
    WriteDebug "Start OpenInputFile"
    
' Get Excel's command line arguments
    GetCommand strCommand, strCommandA
    WriteDebug "OpenInputFile strCommand=" & strCommand
    WriteDebug "OpenInputFile strCommandA=" & strCommandA

' Check if breakpoint is desired here
    If ReadCfgFile(LCase("stop")) = "openinputfile" Then
        ShowBreakpoint "OpenInputFile"
    End If

' Work-around in case GetCommandLineW function does not show any arguments (happened occasionally)
   If InStr(LCase(strCommand), "/e") = 0 Then
        If InStr(strCommandA, "/e") > 0 And InStr(strCommandA, "/e") < 9999 Then
            strCommand = strCommandA
        End If
        WriteDebug "OpenInputFile strCommand=" & strCommand
    End If
    
' Handles Excel's arguments
    If Right(strCommand, 2) = "/e" Or InStr(strCommand, "/e") = 0 Then
        seqfile = "No valid argument"
    Else
        strCommand = SubString(strCommand, "/e/", -1, "No valid argument")
        strCommand = Replace(strCommand, """", "")
        If InStr(strCommand, "ERROR") = 1 Then
            strCommand = Trim(Mid(strCommand, InStr(strCommand, "|") + 1))
        End If
        seqfile = SubString(strCommand, "|", 1, "No valid argument")
        seqfile = Replace(seqfile, "/", "\")
    End If
    
    WriteDebug "OpenInputFile inputfile=" & seqfile
    
    If seqfile = "No valid argument" Then
        WriteDebug "End OpenInputFile"
        OpenInputFile = False
        Exit Function
    End If
    
    strDivision = SubString(strCommand, "|", 2, "development")
    strDivision = Replace(strDivision, "'", "")
    strDivision = LCase(Replace(strDivision, """", ""))
    
    WriteDebug "Division=" & strDivision
    
' Check that this is a COI template file
    strSheetname = GetRecoverySheetName
    If strSheetname = "" Then
        WriteDebug "AreVersion cell not found..."
        WriteDebug "End OpenInputFile"
        OpenInputFile = False
        Exit Function
    End If
    
' Store ARE version in template sheet
    Worksheets(strSheetname).Range("areversion") = strAreVersion
    
' Suspend screen updating
    WriteDebug "Suspend screenupdating"
    screenupdate = Application.ScreenUpdating
    If screenupdate Then
        Application.ScreenUpdating = False
    End If
    
' Input sequence information
    ImportRecovery seqfile, strDivision, header

' Create COI
    TimeKeeperExport
    
' Restore screen updating
    WriteDebug "Restore screenupdating"
    If screenupdate Then
        Application.ScreenUpdating = True
    End If
        
' Successfully opened input file
    OpenInputFile = True
    WriteDebug "End OpenInputFile"
    
End Function

Private Sub GetCommand(strCommand As String, strCommandA As String)

' There are two possible methods of collecting the command line arguments.
' The first method uses the GetCommandLineW function, this yields a long integer, which is
' translated using the CmdToStr function. Incidentally, this fails.
' The second method uses the GetCommandLineA function, this yields a string which also contains
' a lot of binary stuff. Only for Office 2003.

Dim CmdRaw As Long

CmdRaw = GetCommandLine
strCommand = CmdToSTr(CmdRaw)

If Application.Version = "10" Then
    strCommandA = GetCommandLineA
    intChrPos = InStr(strCommandA, "seq")
    If intChrPos > 0 Then
        intChrPos = matMin(InStr(intChrPos, strCommandA, " "), InStr(intChrPos, strCommandA, Chr(0)))
        strCommandA = Replace(Left(strCommandA, intChrPos - 1), Chr(0), " ")
    End If
End If

End Sub

Private Sub ImportRecovery(strFName As String, Division As String, myHeader As tHeaderRecord)
    
' Import the required file

Dim strSheetname As String
Dim blnNXE As Boolean
Dim intSwitchPointRow As Integer
Dim blnStatus As Boolean
Dim strDependenciesDir As String
Dim strPlatformType As String

On Error GoTo errImportRecovery
    
blnStatus = True
    
' Check that this a COI template sheet
strSheetname = GetRecoverySheetName
If strSheetname = "" Then
    Exit Sub
End If
    
' Check if breakpoint is desired here
If ReadCfgFile("stop") = "importrecovery" Then
    ShowBreakpoint "ImportRecovery"
End If

' Read procedure types (from constant defined in this file)
ReadProcTypes
    
' Determine machine platform type
WriteDebug "strFName =" & strFName
strPlatformType = GetPlatformType(strFName)
Worksheets("Source").Cells(1, 1) = "[Platform]" & strPlatformType
WriteDebug "Platform type  =" & strPlatformType
   
strDependenciesDir = RepairDirName(strSourceDir & "\..\" & strPlatformType & "\dependencies")
        
' Check if this is NXE platform (layout slightly different in that case)
blnNXE = InStr(strPlatformType, "NXE") > 0
    
' Restore strSourceDir for this file if necessary
If strSourceDir = "" Then
    strSourceDir = ThisWorkbook.path
End If

' Store Dependencies directory in Source sheet
Workbooks(strTemplate).Activate
Worksheets("Source").Cells(2, 1) = "[DIR]" & strDependenciesDir
    
' Copy contents of seq file to source sheet
WriteDebug "Seq file: " & strFName
If Left(strFName, 2) = ".." Then
    strFName = strSourceDir & "\" & strFName
End If
CopySequenceFile strFName, blnStatus
     
If blnStatus Then
' Create header from copied info
    CreateHeader myHeader, Division ', wsBL
    myHeader.Procedures = SetProcedureType(Division)

' Convert source sheet info to sequence
    CreateSequence strSheetname, strPlatformType, "", "", myHeader, blnNXE, intSwitchPointRow
End If

If Not blnStatus Then
' Import NOK, so stop here
    End
End If
    
' Write header
WriteHeaderInfo myHeader
    
' For NXE, show (or hide) vacuum state column
If ShowVacuumStateColumn Then
    ShowVacuumStates
End If
    
' These lines are obsolete, switch point ("stop here") now handled in ARE. To be removed.
If intSwitchPointRow > 0 Then
    GreyOutLines intSwitchPointRow
End If
    
' Find sequence layout (nr of lines)
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
    
FindSequenceLayout "Recovery", lngHeaderRow, lngStartRecRow, lngLastSeqRow
    
'Update print settings for exported file
WriteDebug "Update print settings"
ActiveWorkbook.Sheets(strSheetname).PageSetup.PrintArea = Cells(1, 1).Address + ":" + Cells(lngLastSeqRow, cATimeCol).Address
    
'Different format for NXE
If Not blnNXE Then
    Worksheets(strSheetname).Cells(lngHeaderRow, cPerChuckCol) = "Chuck selection"
Else
    Worksheets(strSheetname).Cells(lngHeaderRow, cPerChuckCol) = ""
End If
    
' Done!
WriteDebug "End ImportRecovery"

Exit Sub
    
errImportRecovery:
    MsgBox "An error occurred while creating the recovery sequence" & Chr(13) & err.Description & Chr(13) & "For feedback please use the Comments button.", vbOKOnly
    WriteDebug "Error: [" & err.Number & "] " & err.Description
    Resume Next
    
End Sub

Private Sub CopySequenceFile(strFName As String, blnStatus As Boolean)

Dim intSeqFile As Integer
Dim strText As String
Dim strInputLine() As String
Dim intNrLines As Integer
Dim strError As String
Dim intNrGrouped As Integer
Dim intCurInd As Integer
Dim sglDurationArr() As Single
Dim sglDuration As Single
Dim strOldVal As String
Dim strNewVal As String
Dim strOldProc As String
Dim strNewProc As String
Dim intLineInd As Integer

' Purpose of this routine is to copy the .seq file to the Source sheet

WriteDebug "CopySequenceFile"

intNrLines = 1
strError = ""
intSeqFile = FreeFile
Open strFName For Input Access Read As #intSeqFile

' Check if this file is in the right format
Line Input #intSeqFile, strText
If InStr(strText, "##AUTOMATIC GENERATED RECOVERY") = 0 Then
    If MsgBox("File is not in expected format. Please make sure that ARE debug mode is disabled." & vbCrLf & "Do you want to continue anyway?", vbYesNo) = vbNo Then
        Close #intSeqFile
        blnStatus = False
        Exit Sub
    End If
End If
Worksheets("Source").Cells(cNrSourceHeaderRows + 1, 1) = "[INPUT]" & strText

' Read remaining lines from file
' Looks like this can be combined with next for loop, to be investigated later
WriteDebug "Start reading rest of file"
Do While Not EOF(intSeqFile)
    Line Input #intSeqFile, strText
    WriteDebug "Input [" & intNrLines & "] " & strText
    intNrLines = intNrLines + 1
    ReDim Preserve strInputLine(intNrLines) As String
    strInputLine(intNrLines) = strText

    If InStr(strText, "##Platform") > 0 Then
        Worksheets("Source").Cells(1, 1) = "[Platform]" & Mid(strText, InStr(strText, "|") + 1)
    End If

Loop
WriteDebug "End of input file reached"
    
' Write input to source sheet (with [INPUT] prefix)
For intCurInd = 1 To intNrLines
    If Trim(strInputLine(intCurInd)) = "" Then
' Skip empty lines
    ElseIf Left(strInputLine(intCurInd), 6) = "ERROR:" And InStr(strError, strInputLine(intCurInd)) > 0 Then
' This error has already been recorded, so skip
    Else
' New error reported, add to strError
        If Left(strInputLine(intCurInd), 6) = "ERROR:" Then
            strError = strError & "|" & strInputLine(intCurInd)
        End If
            
' Write line
        Worksheets("Source").Cells(intCurInd + cNrSourceHeaderRows, 1) = "[INPUT]" & strInputLine(intCurInd)
    End If
Next intCurInd

If Not strError = "" Then
' Something went wrong in ARE when generating a sequence
    MsgBox "Please note that a valid sequence could not be created in ARE.", vbOKOnly & vbCritical
End If

Close #intSeqFile

End Sub

Public Function GetDuration(strText As String) As Single

' Read duration from input string

Dim strArr() As String

strArr = Split(strText, " ")
GetDuration = Val(strArr(1))

End Function

Public Function GetGroupedName(strText As String) As String

' Read grouped test name (header) from input string
Dim strArg() As String

strArg = Split(strText, Chr(34))
GetGroupedName = strArg(1)

End Function

Public Function GetGroupedId(strText As String) As String

    ' Read grouped test id (header) from input string
    Dim strArg() As String

    strArg = Split(strText, Chr(34))
    If UBound(strArg) > 2 Then
        GetGroupedId = strArg(3)
    Else
        GetGroupedId = " "
    End If
    
End Function

Public Function GetGroupedSrcText(strSrcText As String, strGroupedName As String, sglDuration As Single) As String

Dim strTmpTxt As String
Dim strArg() As String

strTmpTxt = strSrcText
' Replace description
strTmpTxt = Left(strTmpTxt, InStr(strTmpTxt, "<Desc>") + 5) & strGroupedName & Mid(strTmpTxt, InStr(strTmpTxt, "</Desc>"))

' Replace duration
strArg = Split(strTmpTxt, " ")
strArg(1) = Format(sglDuration, "####0.0")

GetGroupedSrcText = Join(strArg(), " ")

End Function

Public Sub CreateHeader(myHeader As tHeaderRecord, strDivision As String)

Dim intCurRow As Integer
Dim strText As String
Dim strKey As String
Dim strValue As String

WriteDebug "CreateHeader"
intCurRow = cNrSourceHeaderRows + 1
myHeader.Initialised = True
WriteDebug "Procedures  =" & myHeader.Procedures

myHeader.platform = GetPlatformType(Worksheets("Source").Cells(1, 1))

Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
    strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
    If Mid(strText, 1, 2) = "##" Then
' read ARE version input
        strKey = Replace(SubString(strText, "|", 1), "##", "")
        strValue = SubString(strText, "|", 2)
        UpdateAREVersion myHeader, strKey, strValue
        
    ElseIf Mid(strText, 1, 2) = "$$" Then
' read configuration input
        strKey = Replace(SubString(strText, "|", 1), "$$", "")
        strValue = SubString(strText, "|", 2)
        UpdateHeaderInfo myHeader, strKey, strValue
    
' determine procedure type from configuration text
        If strKey = "Location" Then
            strDivision = strValue
        End If
        
        If InStr(LCase(strText), "spotleading") > 0 Then
            myHeader.SpotSensorType = GetSpotSensorType(myHeader.Configuration)
        End If
    End If
    intCurRow = intCurRow + 1
Loop
myHeader.MachineType = ConstructMachineType(myHeader)

End Sub

Private Sub FindJobStepRows(strFirstStep As String, strLastStep As String, intMinRow As Integer, intMaxRow As Integer)

Dim intCurRow As Integer
Dim strText As String
Dim intPrevFMSRow As Integer

intMinRow = cNrSourceHeaderRows + 1
intMaxRow = 9999
intPrevFMSRow = 1

If strFirstStep <> "" Or strLastStep <> "" Then
    intCurRow = cNrSourceHeaderRows + 1
    
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
        If InStr(UCase(strText), "FMS COMPLETE") > 0 Then
            strText = Trim(Replace(UCase(strText), "FMS COMPLETE: FMS:", ""))
        
            If UCase(strText) = UCase(strFirstStep) Then
                intMinRow = intPrevFMSRow + 1
            End If
            If UCase(strText) = UCase(strLastStep) Then
                intMaxRow = intCurRow
            End If
            
            intPrevFMSRow = intCurRow
        
        End If
        
        intCurRow = intCurRow + 1
    Loop
End If

WriteDebug "Job step rows: [" & Format(intMinRow, "###0") & "," & Format(intMaxRow, "###0") & "]"

End Sub

Private Sub CreateSequence(strSheetname As String, strPlatformType As String, _
    strFirstStep As String, strLastStep As String, _
    myHeader As tHeaderRecord, blnNXE As Boolean, intSwitchPointRow As Integer)

Dim intMinRow As Integer
Dim intMaxRow As Integer
Dim intCurRow As Integer
Dim intOutRow As Integer
Dim intBLRow As Integer
Dim strText As String
Dim RS As Worksheet
Dim blnSingleChuckAllowed As Boolean
Dim blnUseLocalCoach As Boolean
Dim intNrStepsInFMS As Integer
Dim intCurFMSRow As Integer
Dim strSrcText As String
Dim blnMissingInfo As Boolean
Dim strSpotValue As String

Dim blnGroupedTest As Boolean
Dim sglDuration As Single
Dim intGroupedRow As Integer
Dim strGroupedSrcText As String
Dim strGroupedName As String
Dim strGroupedId As String
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim blnParallelGrouping As Boolean
Dim iParallelItems As Integer

WriteDebug "CreateSequence"

blnMissingInfo = False

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
FindJobStepRows strFirstStep, strLastStep, intMinRow, intMaxRow
blnUseLocalCoach = Worksheets(strSheetname).optLocalCoach.Value
blnSingleChuckAllowed = (InStr(LCase(myHeader.ChuckSelection), "both") = 0)
blnParallelGrouping = UseParallellismLight

Set RS = Worksheets(strSheetname)
intCurFMSRow = lngStartRecRow

intOutRow = lngStartRecRow + 1
intNrStepsInFMS = 0
intSwitchPointRow = -1
iParallelItems = 0

For intCurRow = intMinRow To intMaxRow
    strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")
    If strText = "" Then Exit For

    If InStr(strText, "$$") = 0 And InStr(strText, "##") <> 1 And Left(strText, 1) <> "=" And InStr(strText, "DEBUG") <> 1 And Not IsNumber(strText) Then
' This is not a seq file header line

        If InStr(UCase(strText), "FMS COMPLETE") > 0 Then
' FMS header line
            If intNrStepsInFMS > 0 Then
                RS.Cells(intCurFMSRow, cTestNameCol) = FormatFMSstring(strText)
                FormatFMS Range(fCell(intCurFMSRow, 1) & ":" & fCell(intCurFMSRow, cATimeCol)), (InStr(Text, " ML_") > 0)
                intCurFMSRow = intOutRow
                intOutRow = intOutRow + 1
                intNrStepsInFMS = 0
            End If
        ElseIf Left(strText, 6) = "ERROR:" Then
' Sequence creation error
            
            intNrStepsInFMS = intNrStepsInFMS + 1
            
            If Left(strText, 6) = "ERROR:" Then
                                                    
                RS.Cells(intOutRow, cTestNameCol) = strText
                RS.Cells(intOutRow, cTestExecCol) = ""
                RS.Cells(intOutRow, cProjectCol) = ""
                RS.Cells(intOutRow, cATimeCol) = 0
                RS.Cells(intOutRow, cTestIDCol) = ""
                RS.Cells(intOutRow, cProcedureNameCol) = ""
                FormatError CLng(intOutRow)
            End If
            
            intOutRow = intOutRow + 1
        Else
' Regular line
            
            strSrcText = Mid(strText, InStr(strText, " ") + 1)
            strText = Left(strText, InStr(strText, " ") - 1)
            
            intNrStepsInFMS = intNrStepsInFMS + 1
            
            If blnGroupedTest Then
                strGroupedSrcText = strSrcText
                sglDuration = sglDuration + GetDuration(strSrcText)
            End If

            If blnParallelGrouping And blnGroupedTest And InStr(Worksheets("Source").Cells(intCurRow + 1, 1), "##</GroupTest>") > 0 Then
                ShowSequenceStepInfo strText, intGroupedRow, RS, blnSingleChuckAllowed, myHeader, Not blnNXE, strSrcText, 2
                ShowSequenceStepProcedure blnMissingInfo, intGroupedRow, RS, myHeader, blnUseLocalCoach, "", strSrcText, blnParallelGrouping Or Not blnGroupedTest, blnGroupedTest

                If iParallelItems = 0 Then
                    intOutRow = intOutRow - 1
                Else
                    RS.Cells(intGroupedRow + 1, cTestNameCol) = "Parallel with " & RS.Cells(intGroupedRow, 4)
                    RS.Cells(intGroupedRow + 1, cHasSubtestsCol) = "p"
                    iParallelItems = 0
                End If
            Else
                If blnParallelGrouping And blnGroupedTest Then
                    ShowSequenceStepInfo strText, intOutRow, RS, blnSingleChuckAllowed, myHeader, Not blnNXE, strSrcText, 3
                    iParallelItems = iParallelItems + 1
                Else
                    If Not (InStr(Worksheets("Source").Cells(intCurRow + 1, 1), "##</GroupTest>") > 0) Then
                        ShowSequenceStepInfo strText, intOutRow, RS, blnSingleChuckAllowed, myHeader, Not blnNXE, strSrcText, CInt(blnGroupedTest)
                    End If
                End If
                If Not (InStr(Worksheets("Source").Cells(intCurRow + 1, 1), "##</GroupTest>") > 0) Then
                    ShowSequenceStepProcedure blnMissingInfo, intOutRow, RS, myHeader, blnUseLocalCoach, "", strSrcText, blnParallelGrouping Or Not blnGroupedTest
                    intOutRow = intOutRow + 1
                End If
            End If
            
        End If
    ElseIf InStr(strText, "##<GroupTest") > 0 Then
        blnGroupedTest = True
        intGroupedRow = intOutRow

        If blnParallelGrouping Then
            intOutRow = intOutRow + 2
        Else
            strGroupedName = GetGroupedName(strText)
            strGroupedId = GetGroupedId(strText)
            strGroupedSrcText = ""
            sglDuration = 0
            intOutRow = intOutRow + 1
        End If
    ElseIf InStr(strText, "##</GroupTest>") > 0 Then
        If Not blnParallelGrouping Then
' Store total duration
            strSrcText = GetGroupedSrcText(strGroupedSrcText, strGroupedName, sglDuration)
            ShowSequenceStepInfo "Grouped", intGroupedRow, RS, blnSingleChuckAllowed, myHeader, Not blnNXE, strSrcText, 1, strGroupedId
            ShowSequenceStepProcedure blnMissingInfo, intGroupedRow, RS, myHeader, blnUseLocalCoach, "", strSrcText, , True
            sglDuration = 0
        End If
        blnGroupedTest = False
    End If
Next intCurRow

If blnMissingInfo Then
    MsgBox "Not all required information can be found and shown in this sheet", vbOKOnly
End If

End Sub

Function CmdToSTr(cmd As Long) As String
    Dim Buffer() As Byte
    Dim StrLen As Long
   
   If cmd Then
      StrLen = lstrlenW(cmd) * 2
      If StrLen Then
         ReDim Buffer(0 To (StrLen - 1)) As Byte
         CopyMemory Buffer(0), ByVal cmd, StrLen
         CmdToSTr = Buffer
      End If
   End If
End Function

Public Function SubString(ByVal str As String, sep As String, nr As Integer, Optional def As String)
    Dim aFnd(50) As Integer
    If str = "" Then
       SubString = def
       Exit Function
    End If
   
    iLen = matMin(32000, Len(str))
    iSep = Len(sep)
    If Not Right(str, iLen - 1) = sep Then
       str = str & sep
       iLen = iLen + iSep
    End If
    iFnd = 0
    For ind = 1 To iLen
         If Mid(str, ind, iSep) = sep Then
            iFnd = iFnd + 1
            aFnd(iFnd) = ind
         End If
    Next ind
    
    If nr = -1 Then
       ' take the last item
       nr = iFnd
    End If
    If iFnd < nr Then
        'not that much substrings, use default, if exist
        If Len(def) > 0 Then
            SubString = def
        End If
    Else
        If nr = 1 Then
            SubString = Mid(str, 1, aFnd(1) - 1)
        Else
            SubString = Mid(str, aFnd(nr - 1) + iSep, aFnd(nr) - aFnd(nr - 1) - iSep)
        End If
        SubString = Trim(SubString)
    End If
End Function

Public Function cnvColIndex(nbr As Integer) As String
    lastLetterInd = nbr Mod 26
    cnvColIndex = Chr(Asc("A") - 1 + lastLetterInd)
    firstLetterInd = Round(nbr \ 26)
    If firstLetterInd > 0 Then
        cnvColIndex = Chr(Asc("A") - 1 + firstLetterInd) & cnvColIndex
    End If
End Function

Sub UpdateAREVersion(myHeader As tHeaderRecord, Key As String, Value As String)

Dim strArg() As String
Dim strDate As String
Dim strTime As String

Select Case LCase(Key)
    Case "userinterface"
        strArg = Split(Value, "-")
        myHeader.Version = strArg(0)
    Case "xmldata"
' Allowed formats: 15269-20140819-053551, and 15269-M-20140819-053551
        strArg = Split(Value, "-")
        myHeader.Revision = strArg(0)
        
        strDate = ""
        strTime = ""
        
        If UBound(strArg) < 2 Then
            myHeader.Modified = False
        ElseIf UBound(strArg) = 2 Then
            If Len(strArg(1)) = 8 And Len(strArg(2)) = 6 Then
                strDate = strArg(1)
                strTime = strArg(2)
            End If
            myHeader.Modified = False
        ElseIf UBound(strArg) = 3 Then
            If Len(strArg(2)) = 8 And Len(strArg(3)) = 6 Then
                strDate = strArg(2)
                strTime = strArg(3)
            End If
            myHeader.Modified = True
        End If
        
        If strDate <> "" And strTime <> "" Then
            myHeader.ExportDate = Format(CDate(Left(strDate, 4) & "-" & Mid(strDate, 5, 2) & "-" & Mid(strDate, 7, 2)), "dd/mmm/yyyy") & " " & _
                Format(TimeValue(Left(strTime, 2) & ": " & Mid(strTime, 3, 2) & ":" & Mid(strTime, 5, 2)), "hh:mm:ss")
        Else
            myHeader.ExportDate = ""
        End If
    Case Else
    ' Ignore
End Select

End Sub

Sub UpdateHeaderInfo(myHeader As tHeaderRecord, Key As String, Value As String)

Select Case LCase(Key)
    Case "areversion"
' ARE version is now controlled via Excel arguments
        myHeader.Version = Value
    Case "svn_deps_revision"
        myHeader.Revision = Value
    Case "svn_deps_exported"
        myHeader.ExportDate = Value
    Case "recovery"
        If myHeader.recovery = "" Then
            myHeader.recovery = Value
        Else
            myHeader.recovery = myHeader.recovery & vbCrLf & Value
        End If
    Case "serviceaction"
        If myHeader.serviceaction = "" Then
            myHeader.serviceaction = Value
        Else
            myHeader.serviceaction = myHeader.serviceaction & vbCrLf & Value
        End If
    Case "scenarios"
        If myHeader.Scenarios = "" Then
            myHeader.Scenarios = "+ " & Value
        Else
            myHeader.Scenarios = myHeader.Scenarios & vbCrLf & "+ " & Value
        End If
    Case "state"
        If Value <> "ADD" And Value <> "REMOVE" Then
            If myHeader.States = "" Then
                myHeader.States = "State: " & Value
            Else
                myHeader.States = myHeader.States & vbCrLf & "State: " & Value
            End If
        End If
    Case "machinetype"
        Select Case LCase(Value)
            Case Is = "nxt2_1960i"
                Value = "NXT2_1960Bi"
            Case Is = "nxt3_1970i"
                Value = "NXT3_1970Ci"
            Case Else
                If Left(LCase(Value), 4) = "nxe3" Then
                    Value = "NXE:" & Mid(Value, 4)
                End If
        End Select
        myHeader.MachineType = Replace(Value, "I", "i")
    Case "machinespec"
        myHeader.MachineSpec = UCase(Value)
    Case "xtarchitecture"
        myHeader.Architecture = UCase(Value)
    Case "sourcetype"
        myHeader.SourceType = UCase(Value)
        AddConfigItem myHeader.Configuration, Key, Value
    Case "release"
        myHeader.Release = Replace(Value, "_", ".")
    Case "source_release"
        myHeader.SourceRelease = Replace(Value, "_", ".")
    Case "source_sw_rc_at_least"
        myHeader.ReleaseCandidate = Value
    Case "patchlevel"
        myHeader.PatchLevel = Value
    Case "gridframemeashiftxy", "gridframemeashiftz", "gridframeexpshiftxy", "gridframeexpshiftz"
        ' Ignore
    Case "encoderpositionxy", "encoderpositionz", "wafertablez", "rsencoderposupdate", "wpdeltahome", "wpsetupaccuracy"
        ' Ignore
    Case "applicabilityitem", "applicability1"
        ' Ignore
    Case "duration"
        ' Ignore
    Case "chuckselection"
        AddConfigItem myHeader.Configuration, Key, Value
        myHeader.ChuckSelection = GetChuckSelection(Value)
    Case "systemlayout"
        AddConfigItem myHeader.Configuration, Key, Value
        If InStr(LCase(Value), "complete") = 0 Then
            myHeader.MachineType = myHeader.MachineType & " - " & Value
        End If
    Case "status"
        myHeader.Status = Value
    Case "published"
        myHeader.Published = LCase(Value)
    Case "recoveryreduction"
        myHeader.RecoveryReduction = Value
    Case "source_sw_at_least"
        myHeader.SourceSWatLeast = Value
    Case Else
        AddConfigItem myHeader.Configuration, Key, Value
End Select

End Sub

Private Function GetChuckSelection(strTxt As String) As String

If InStr(LCase(strTxt), "both") > 0 Then
    GetChuckSelection = "Both Chucks"
ElseIf InStr(strTxt, "1") > 0 Then
    GetChuckSelection = "Chuck 1 only"
ElseIf InStr(strTxt, "2") > 0 Then
    GetChuckSelection = "Chuck 2 only"
Else
    GetChuckSelection = "Unknown"
End If
End Function

Sub WriteHeaderInfo(myHeader As tHeaderRecord)

Dim blnShowScenarios As Boolean
Dim strTmpVal As String
Dim strPlatformType As String
Dim strRelease As String

blnShowScenarios = False

WriteDebug "Write header info"
strPlatformType = GetPlatformType(Worksheets("Source").Cells(1, 1))

' ARE version is now controlled in Excel arguments

If myHeader.Modified Then
    Range("areversion").Value = myHeader.Version & " - Modified data: " & myHeader.Revision & " (" & myHeader.ExportDate & ")" & " - " & strPlatformType
    With Range("Areversion").Characters(Start:=InStr(Range("areversion").Value, "Modified data"), Length:=13).Font
        .ColorIndex = 3
    End With
Else
    Range("areversion").Value = myHeader.Version & " - Rev.: " & myHeader.Revision & " (" & myHeader.ExportDate & ")" & " - " & strPlatformType
End If
WriteDebug "ARE version: " & Range("areversion").Value

If (myHeader.Scenarios = "" Or Not blnShowScenarios) And Not (LCase(myHeader.recovery) = "manualscenario") Then
    Range("recovery").Value = myHeader.recovery
Else
    Range("recovery").Value = myHeader.recovery & ":" & vbCrLf & myHeader.Scenarios
End If

Range("serviceaction").Value = myHeader.serviceaction

If myHeader.States <> "" Then
    Range("recovery").Value = Range("recovery").Value & vbCrLf & myHeader.States
End If

Rows(fRow(Range("recovery").row)).RowHeight = 14.25 * (matMin(8, StrCount(Range("recovery").Value, vbCrLf)) + 1)

If myHeader.StartStep <> "" And myHeader.StartStep <> "Fingerprint" Then
    Range("recovery").Value = Range("recovery").Value + " - from " + myHeader.StartStep
End If

If myHeader.StopStep <> "" And myHeader.StopStep <> "Wrapup" Then
    Range("recovery").Value = Range("recovery").Value + " - to " + myHeader.StopStep
End If

Range("machinetype").Value = myHeader.MachineType
' Range("configuration").value = Replace(myheader.configuration, "; ", vbCrLf)
Range("configuration").Value = myHeader.Configuration

updateCoachType

If strPlatformType = "NXE" Then
    strRelease = "Scanner: "
Else
    strRelease = ""
End If

If myHeader.PatchLevel = "9999" Then
    strRelease = strRelease & myHeader.Release + " - Patch level: LATEST"
Else
    strRelease = strRelease & myHeader.Release + " - Patch level: " + myHeader.PatchLevel
End If

If strPlatformType = "NXE" Then
    strRelease = strRelease & " / Source: at least " & myHeader.SourceSWatLeast
    If myHeader.ReleaseCandidate <> "" Then
        'strRelease = strRelease & " - RC: at least " & myheader.ReleaseCandidate
    End If
End If

Range("swrelease").Value = strRelease

If Trim(myHeader.Status) = "" Then
    strTmpVal = ""
Else
    strTmpVal = myHeader.Status & " / "
End If

If LCase(myHeader.RecoveryReduction) <> "" And LCase(myHeader.RecoveryReduction) <> "none" And LCase(myHeader.RecoveryReduction) <> "unknown" Then
    Range("status").Value = strTmpVal & "Procedures: " & strProcTypeList(myHeader.Procedures) & " / Recovery reduction: " & myHeader.RecoveryReduction
    Range("C2:H8").Select
    Selection.Interior.ColorIndex = 44
Else
    Range("status").Value = strTmpVal & "Procedures: " & strProcTypeList(myHeader.Procedures)
End If

Range("generated") = "'" & Format(Now, "dd/mmm/yyyy hh:mm:ss")
Range("Copyright") = "'(c) ASML " & Year(Now)

End Sub
Private Sub checkVersion()
    Dim strFileName
    Dim i As Integer
    Dim strUser As String
    Dim strPlatform As String
    Dim strSector As String
    Dim strPublishedVersion As String
    Dim strVersion As String
    Dim strAreVersion As String
    Dim ddExists As Boolean
    Dim fileDate As String
    Dim strPlatformFileName As String
       
    strUser = Environ("username")
    strPlatform = GetPlatformType(Worksheets("Source").Cells(1, 1))
    intCurRow = 3
    While InStr(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]##") > 0
        strText = Worksheets("Source").Cells(intCurRow, 1)
        If InStr(strText, "[INPUT]##Sector|") > 0 Then
            strSector = Replace(strText, "[INPUT]##Sector|", "")
        End If
        If InStr(strText, "[INPUT]##XmlData|") > 0 Then
            strVersion = Replace(strText, "[INPUT]##XmlData|", "")
        End If
        If InStr(strText, "[INPUT]##UserInterface|") > 0 Then
            strAreVersion = Replace(strText, "[INPUT]##UserInterface|", "")
        End If
        intCurRow = intCurRow + 1
    Wend
    
          
    If (strSector = "CS" Or strSector = "DE" Or strSector = "MF") Then
        Set oApp = CreateObject("Shell.Application")
        Set Ofs = CreateObject("Scripting.FilesystemObject")
        'make tmp folder to extract the versions file
        strPlatformFileName = "C:\Users\" & strUser & "\ARE\" & strPlatform
        strTmpFileName = "C:\Users\" & strUser & "\ARE\" & strPlatform & "\tmp\"
        If Not Ofs.FolderExists(strPlatformFileName) Then
            Ofs.CreateFolder strPlatformFileName
        End If
        If Not Ofs.FolderExists(strTmpFileName) Then
            Ofs.CreateFolder strTmpFileName
        End If
        For Each f In Ofs.GetFolder(strTmpFileName).Files
            f.Delete Force = True
        Next
        
        'look for dd.zip on publushed data
        strDir = "\\asml.com\eu\shared\nl012621\WWW\Recovery-Tooling\ARE\" & strPlatform & "\baseline2\" & strSector & "\"
        strFileName = "\\asml.com\eu\shared\nl012621\WWW\Recovery-Tooling\ARE\" & strPlatform & "\baseline2\" & strSector & "\dd.zip"
        
        
        
        If Ofs.FolderExists(strDir) Then
            fileDate = Format(DateValue(FileDateTime(strFileName)), "dd-mmm-yyyy")
            For Each sFilenameInZip In oApp.Namespace(strFileName).Items
                If sFilenameInZip = "version" Then
                    oApp.Namespace(strTmpFileName).copyHere oApp.Namespace(strFileName).Items.Item(CStr(sFilenameInZip))
                End If
            Next
        End If
        
        ddExists = False
        For Each f In Ofs.GetFolder(strTmpFileName).Files
            If f = strTmpFileName & "version" Then
             ddExists = True
            End If
        Next
        
        'if published data is not availabe look in local cache
        'Note that this is not requested anymore, but keep in in case they change their minds
        'If Not ddExists Then
        '    If Not strAreVersion = "" And Not strAreVersion = "null" Then
        '        strDir = "C:\Program Files (x86)\ASML\ARE " & strAreVersion & "\var\" & strPlatform & "\Cache\" & strSector & "\"
        '        strFileName = "C:\Program Files (x86)\ASML\ARE " & strAreVersion & "\var\" & strPlatform & "\Cache\" & strSector & "\dd.zip"
        '        If Ofs.FolderExists(strDir) Then
        '            For Each sFilenameInZip In oApp.Namespace(strFileName).items
        '                If sFilenameInZip = "version" Then
        '                    oApp.Namespace(strTmpFileName).copyHere oApp.Namespace(strFileName).items.Item(CStr(sFilenameInZip))
        '                End If
        '            Next
        '       End If
        '    End If
        'End If

        'ddExists = False
        'For Each f In Ofs.GetFolder(strTmpFileName).Files
        '    If f = strTmpFileName & "version" Then
        '     ddExists = True
        '    End If
        'Next
        
        If ddExists Then
            Set f = Ofs.OpenTextFile(strTmpFileName & "version", 1)
            strPublishedVersion = f.ReadAll
            f.Close
    
            If strVersion <> strPublishedVersion Then
                MsgBox ("A newer version of the sequence may be available since " & fileDate)
            Else
                MsgBox ("ARE version is OK")
            End If
        Else
            MsgBox ("ARE version could not be verified. Make sure you are connected to ASML network")
        End If
    
        'free memory
        Set oApp = Nothing
        Set Ofs = Nothing
    End If
End Sub

Function GetConfigValue(Key As String) As String
Dim intCurRow As Integer
Dim strTmpVal As String

intCurRow = cNrSourceHeaderRows + 1
strTmpVal = ""
Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
    strText = Replace(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]", "")

    If Mid(strText, 1, 2) = "$$" Then
    ' read configuration input
        If Replace(SubString(strText, "|", 1), "$$", "") = Key Then
            strTmpVal = SubString(strText, "|", 2)
        End If
    End If
    intCurRow = intCurRow + 1
Loop

GetConfigValue = strTmpVal

End Function

Private Sub updateCoachType()
    'Try to find and use a valid CoachTypeFather
    [mappingAllowed] = False
    
    If (GetConfigValue("MachineModel") = "" And GetConfigValue("CoachMachineType") = "" And [MachineType].Value = "") Then
        [coachType].Value = "no machinetype available"
    Else
        setCoachType (GetConfigValue("MachineModel"))
        If (Not [mappingAllowed]) Then
                setCoachType (GetConfigValue("CoachMachineType"))
        End If
        If (Not [mappingAllowed]) Then
                setCoachType ([MachineType].Value)
        End If
        If (Not [mappingAllowed]) Then
                [coachType].Value = "unsupported machinetype"
        End If
    End If
   
End Sub

Private Sub setCoachType(coachMachTypeFather As String)
Dim endRow As Integer
Dim c As Range
Dim col As String
Dim coachSheet As Worksheet

Set coachSheet = Worksheets("CoachTypes")

If Not coachMachTypeFather = "" Then
        Set c = [coachFathers].Find(coachMachTypeFather, LookIn:=xlValues)
        If Not c Is Nothing Then
            col = Mid(c.Address, 2, InStr(2, c.Address, "$", vbTextCompare) - 2)
            endRow = coachSheet.Range(col & 1).End(xlDown).row
            With [coachType].Validation
                .Delete
                .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _
                xlBetween, Formula1:="=CoachTypes!$" & col & "$2:$" & col & "$" & endRow
                .IgnoreBlank = True
                .InCellDropdown = True
                .InputTitle = ""
                .ErrorTitle = ""
                .InputMessage = ""
                .ErrorMessage = ""
                .ShowInput = True
                .ShowError = True
            End With
            [coachType].Value = coachSheet.Range(col & 2).Value
            [mappingAllowed] = True
        End If
    End If

End Sub



Function ConstructMachineType(myHeader As tHeaderRecord) As String

Dim strTmpVal As String

Select Case myHeader.Architecture
    Case Is = ""
        strTmpVal = ""
    Case Is = "NONE"
        strTmpVal = "AT_"
    Case Else
        strTmpVal = "XT_"
End Select

strTmpVal = strTmpVal & myHeader.MachineType

If myHeader.MachineSpec <> "" Then
    strTmpVal = strTmpVal & myHeader.MachineSpec
End If

ConstructMachineType = strTmpVal

End Function

Sub FormatFMS(r As Range, Optional blnMLState As Boolean = False)

r.Font.Bold = True
With r.Borders(xlEdgeTop)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With

With r.Borders(xlEdgeBottom)
    .LineStyle = xlContinuous
    .Weight = xlThin
    .ColorIndex = xlAutomatic
End With

With r.Interior
    If blnMLState Then
        .ColorIndex = 3
    Else
        .ColorIndex = 36
    End If
    .Pattern = xlSolid
End With

If blnMLState Then
    r.Font.ColorIndex = 2
Else
    r.Font.ColorIndex = 1
End If

End Sub

Private Function FormatFMSstring(fms As String) As String
    Dim result As String
    result = fms
    If InStr(result, "[") > 0 Then
        result = Left(result, InStr(result, "[") - 1)
    End If
    result = Trim(Replace(result, "FMS COMPLETE: FMS:", ""))
FormatFMSstring = Trim(Replace(result, "_", " "))
End Function

Sub Check_ref_and_VbaSec()
     'Macro purpose:  To check for missing references and the correct security for vb projects
     
    Dim i, NrRef As Long
    Dim mpVBC As Object
    Dim mpAlerts, VBAIsTrusted As Boolean
    
    'check is trust access to visual basic projects is activated
    mpAlerts = Application.DisplayAlerts
    Application.DisplayAlerts = False
    On Error Resume Next
    Set mpVBC = ThisWorkbook.VBProject.VBComponents.Item(1)
    Application.DisplayAlerts = mpAlerts
    VBAIsTrusted = Not mpVBC Is Nothing
    If Not VBAIsTrusted Then MsgBox ("please activate: Trust access to visual basic projects. Tools, Macros, security")
     
    On Error Resume Next
    ' check for missing references
    NrRef = ThisWorkbook.VBProject.References.Count
    For i = 1 To NrRef
        If ThisWorkbook.VBProject.References.Item(i).IsBroken Then
            MsgBox ("A reference is missing, see visual basic (alt + F11), Tools, References")
        End If
    Next i
     
    If err <> 0 Then
        MsgBox "Error occurred checking references"
    End If
     
    On Error GoTo 0
    
End Sub

Private Sub ShowVacuumStates()

Dim VacState As Integer
Dim sVacState(0 To 3) As String
Dim ciVacState(0 To 3) As Integer
Dim bVacStateTransition As Boolean
Dim iCount As Integer
Dim iEndRange As Integer
Dim rTestIDStart As Integer
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long
Dim lngHeaderRow As Long
Dim RS As Worksheet

WriteDebug "ShowVacuumStates"

FindSequenceLayout "Recovery", lngHeaderRow, lngStartRecRow, lngLastSeqRow

' Definition of vacuumstates
        
' define vacuumstates names and color index
sVacState(0) = "Atmosphere"
sVacState(1) = "Vacuum N2"
sVacState(2) = "Vacuum H2"
sVacState(3) = "Vacuum RFE"
        
ciVacState(0) = 5  ' blue
ciVacState(1) = 10 ' green
ciVacState(2) = 53 ' brown
ciVacState(3) = 46 ' orange
       
rTestIDStart = lngStartRecRow + 1

' Vacuum state transitions IDs:
' VS_VENTING               (used in PM-sheet)
' VS_GOTO_SERVICE_3100     (used in WS-sheet)
' VS_GOTO_SERVICE_3300     (used in WS-sheet)
' VS_GOTO_N2_3100_1        (used in VS-sheet)
' VS_GOTO_N2_3300_1        (used in VS-sheet)
' VS_GOTO_N2_3100_2        (used in WS-sheet)
' VS_GOTO_N2_3300_2        (used in WS-sheet)
' VS_GOTO_H2_STANDBY_3100  (used in VS-sheet)
' VS_GOTO_H2_STANDBY_3300  (used in VS-sheet)
' VS_GOTO_RFE_CLEAN_3100   (used in VS-sheet)
' VS_GOTO_RFE_CLEAN_3300   (used in VS-sheet)
' VS_GOTO_RFE_DIRTY        (used in VS-sheet)
' ----
' Loop backwards over vacuum states.
' Last state is always defined as RFE (=3), first state is not always Atmosphere
        
strSheetname = GetRecoverySheetName
Set RS = Worksheets(strSheetname)

VacState = 3 '
bVacStateTransition = False
iCount = lngLastSeqRow
iEndRange = iCount
Do While iCount >= rTestIDStart
    Select Case RS.Cells(iCount, cTestIDCol).Value
    Case "VS_GOTO_N2_3100_1", "VS_GOTO_N2_3300_1", "VS_GOTO_N2_3100_2", "VS_GOTO_N2_3300_2"
        VacState = 1
        bVacStateTransition = True
        RS.Cells(iCount, cVacuumStateCol).Value = "x1"
    Case "VS_GOTO_H2_STANDBY_3100", "VS_GOTO_H2_STANDBY_3300"
        VacState = 2
        bVacStateTransition = True
        RS.Cells(iCount, cVacuumStateCol).Value = "x2"
    Case "VS_GOTO_RFE_CLEAN_3100", "VS_GOTO_RFE_CLEAN_3300", "VS_GOTO_RFE_DIRTY"
        VacState = 3
        bVacStateTransition = True
        RS.Cells(iCount, cVacuumStateCol).Value = "x3"
    Case "VS_VENTING", "VS_GOTO_SERVICE_3100", "VS_GOTO_SERVICE_3300"
        VacState = 0
        bVacStateTransition = True
        RS.Cells(iCount, cVacuumStateCol).Value = "x4"
    Case "A" To "Z", "a" To "z"
        ' All vacuum transitions have been tested. So it's either a normal test or FMS line
        ' FMS lines stay empty. Fill all other lines with 'marker for undefined state'
        RS.Cells(iCount, cVacuumStateCol).Value = "x-any"
    Case Else
        RS.Cells(iCount, cVacuumStateCol).Value = ""
    End Select
    If bVacStateTransition Or iCount = rTestIDStart Then
        ' Fill the range with the correct vac state
        If iCount = iEndRange Then
            With RS.Cells(iCount, cVacuumStateCol)
                If Not (.Value = "") Then
                    .Value = sVacState(VacState)
                    .Font.ColorIndex = ciVacState(VacState)
                    .Font.Size = 10
                End If
            End With
        Else
            With RS.Range(RS.Cells(iCount, cVacuumStateCol).Address + ":" + RS.Cells(iEndRange, cVacuumStateCol).Address).SpecialCells(xlCellTypeConstants)
                .Value = sVacState(VacState)
                .Font.ColorIndex = ciVacState(VacState)
                .Font.Size = 10
            End With
        End If
        ' Start a new range
        bVacStateTransition = False
        iEndRange = iCount - 1
        ' Assume vacuum state transition is unidirectional. Will be corrected later if turns out not to be true
        If VacState > 0 Then
            VacState = VacState - 1
        End If
    End If
    iCount = iCount - 1
Loop

End Sub


Sub ReadFile(strFileName As String, strDivision As String, header As tHeaderRecord)
   
' Read the input file, import the recovery information and format the COI

SetTemplateNameDir
ImportRecovery strFileName, strDivision, header
TimeKeeperExport

End Sub

Sub AddConfigItem(strText As String, strKey As String, Value)

' Adds a configuration item to the configuration string

If strText <> "" Then
    strText = strText & "; "
End If
strText = strText & strKey & ": " & Value

End Sub

Sub ManualOpenFile(Optional blnConvertFiles As Boolean = False)

' Stand-alone mode: pick an input file and handle its input
' If multiple files are to be read and converted, the blnConvertFiles variable can be set to TRUE

Dim strFileName As String
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim lngStartRecRow As Long
Dim strSheetname As String
Dim strFileNameList() As String
Dim intFileId As Integer
Dim strSaveFileName As String

If Not IsSheet("Source") Then
    Sheets.Add.Name = "Source"
End If

sngBFactor = 1.8

' Check if sheet is empty
strSheetname = GetRecoverySheetName
If strSheetname <> "" Then
    FindSequenceLayout Range("AreVersion").Worksheet.Name, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    
' Ask for confirmation that overwriting is allowed
    If lngLastSeqRow > lngStartRecRow Then
        Select Case MsgBox("The sequence is sheet is not empty. Clear sheet and continue?", vbYesNo)
            Case Is = vbYes
            Case Is = vbNo
                Exit Sub
        End Select
    End If
    
' Get sequence file name
    PickFile strFileName, , , "*.seq", blnConvertFiles
    
    If strFileName <> "" Then
                
        If Not blnConvertFiles Then
' Read a single file
            ReDim strFileNameList(0) As String
            strFileNameList(0) = strFileName
        Else
' Read and convert (to xls) a list of files
            strFileNameList = Split(strFileName, "#")
        End If
        
' Loop over all defined filenames
        For intFileId = 0 To UBound(strFileNameList)
            
            ClearTemplate False
            
            Dim header As tHeaderRecord
            
            SuspendUpdates
            SuspendScreenUpdates
            
' Actual file reading starts here
            ReadFile strFileNameList(intFileId), "", header
        
            If blnConvertFiles Then
                strSaveFileName = Replace(strFileNameList(intFileId), ".seq", "") & ".xls"
                ActiveWorkbook.saveAs FileName:=strSaveFileName
            End If
            
            ResumeUpdates
            ResumeScreenUpdates
        Next intFileId
        
' In case of file conversion, show result using MsgBox
        If blnConvertFiles Then
            If UBound(strFileNameList) > 0 Then
                MsgBox Format(UBound(strFileNameList) + 1, "####0") & " files converted."
            Else
                MsgBox "1 file converted."
            End If
        Else
            Worksheets(strSheetname).Activate
        End If
    End If
End If

End Sub

Sub ClearTemplate(Optional blnAskVerification As Boolean = True, Optional blnClearSourceSheet As Boolean = True)
    
' Purpose of this routine is to clear all sequence related input and provide a fresh template file

Dim lngLastSeqRow As Long
Dim lngHeaderRow As Long
Dim intHeaderCol As Integer
Dim strSheetname As String
Dim blnClearSheet As Boolean
Dim lngStartRecRow As Long

' Ask for confirmation before clearing sheets
If blnAskVerification Then
    blnClearSheet = (MsgBox("Are you sure you want the clear the template sheet?", vbYesNo) = vbYes)
Else
    blnClearSheet = True
End If

If blnClearSheet Then
    Application.ScreenUpdating = False
    
' Find which sheet to clear
    strSheetname = GetRecoverySheetName
    If strSheetname = "" Then
        Exit Sub
    End If
    
' Activate sheet
    Worksheets(strSheetname).Activate
    
' Clear header area
    intHeaderCol = Range("areversion").Column
    Range(fRange(2, intHeaderCol, 8, intHeaderCol)).Select
    Selection.ClearContents
    
' Clear A2B-factor area
    Range(fRange(cA2BFactorRow, cPlannedTimeCol, cWeekNrRow, cDelayCol)).Select
    Selection.ClearContents
    
' Find sequence in sheet
    FindSequenceLayout ActiveSheet.Name, lngHeaderRow, lngStartRecRow, lngLastSeqRow, False
    
' Clear sequence contents
    Rows(Format(lngStartRecRow, "####0") & ":" & Format(lngLastSeqRow + 1, "####0")).Select
    Selection.Delete Shift:=xlUp
    
' Update formulae for sequence duration and nr of tests
    UpdateHeader ActiveSheet.Name, lngHeaderRow, lngStartRecRow
    
' Restore row heights
    Rows(fRows(Range("recovery").row)).RowHeight = 14.25
    
    Range("A1").Select
    
    On Error Resume Next
' Clear the Source sheet if required
    If blnClearSourceSheet Then
        Worksheets("Source").Cells.ClearContents
        Worksheets(strSheetname).Select
    End If
    
' Clear the Graph sheet
    Worksheets("Graph").Cells.ClearContents
    
' Clear the StatusBar sheet
    Worksheets("StatusBar").Cells.ClearContents
    Worksheets("StatusBar").Cells.ClearFormats
    
    Application.ScreenUpdating = True
End If

End Sub

Sub FormatError(lngErrorRow As Long, Optional intColorIndex As Integer = 3)

' This routine formats a sequence row in which ARE reported an error

Range(fRows(lngErrorRow)).Select

With Selection.Interior
    .ColorIndex = intColorIndex
    .Pattern = xlSolid
End With

End Sub

Private Sub ReadProcTypes()

' This routine reads procedure types from the defined constant cProcTypes
Dim varSplit As Variant
Dim i As Integer

varSplit = Split(cProcTypes, ":")

For i = 0 To UBound(varSplit)
    strProcTypeList(i + 1) = varSplit(i)
Next i

End Sub

Public Function SetProcedureType(strText As String) As Integer

' This function converts a strText containing procedure context information to the defined procedure type

Select Case LCase(strText)
    Case Is = "test", "factory", "manufacturing", "development"
        SetProcedureType = cTestProc
    Case Is = "install", "integrationinstall"
        SetProcedureType = cInstallProc
    Case Is = "field", "service"
        SetProcedureType = cServiceProc
    Case Else
        Debug.Print "Warning! Procedure type " & strText & " not recognized. Will use 'Test' instead."
End Select

End Function

Private Sub ShowSequenceStepInfo(strText As String, _
    intOutRow As Integer, _
    RS As Worksheet, _
    blnSingleChuckAllowed As Boolean, _
    myHeader As tHeaderRecord, _
    blnShowChuckSelection As Boolean, _
    Optional strSrcText As String = "", _
    Optional intGroupedTestType As Integer = 0, _
    Optional strGroupId As String)

Dim blnSpotSensorDependent As Boolean
Dim strTxtArr() As String
Dim strStatus As String
Dim sglATime As Single
Dim strSpotSensorType As String
Dim blnSingleChuckMode As Boolean
Dim origLink As String


strTxtArr() = Split(strSrcText, " ")
strChuckSelection = UCase(strTxtArr(0))
strSpotSensorType = myHeader.SpotSensorType

sglATime = Val(strTxtArr(1))

' ARE-1455: Detect test intention (status) and set the status dropdown
strStatus = GetXMLValue(strSrcText, "Intention")
If strStatus <> "EXECUTE" Then
    RS.Cells(intOutRow, cStatusCol) = WorksheetFunction.Proper(strStatus)
End If

RS.Cells(intOutRow, cTestNameCol) = GetXMLValue(strSrcText, "Desc")
origLink = GetXMLValue(strSrcText, "CoachURL")

If HasSubLink(origLink) Then
    blnSingleChuckMode = (RS.Cells(intOutRow, cPerChuckCol) <> "" And InStr(RS.Cells(intOutRow, cPerChuckCol), "Both") = 0)
    strHyperlink = fnProcedureLink("Recovery", "url:" & origLink, myHeader, blnSingleChuckMode, "")
    RS.Hyperlinks.Add _
        Anchor:=RS.Cells(intOutRow, cTestNameCol), _
        Address:=strHyperlink
End If
RS.Cells(intOutRow, cStartModeCol) = GetXMLValue(strSrcText, "StartMode")
RS.Cells(intOutRow, cTestExecCol) = GetXMLValue(strSrcText, "Exec")
RS.Cells(intOutRow, cProjectCol) = GetXMLValue(strSrcText, "Ownr")
If strText = "Grouped" Then
    RS.Cells(intOutRow, cTestIDCol) = strGroupId   ' Cannot use empty string (yet), has impact on other routines
Else
    RS.Cells(intOutRow, cTestIDCol) = strText
End If
RS.Cells(intOutRow, cTangoCol) = GetXMLValue(strSrcText, "TangoID")
RS.Cells(intOutRow, cSAPCol) = GetXMLValue(strSrcText, "SAPk")
If GetXMLValue(strSrcText, "Proc") <> "NA" Then
    RS.Cells(intOutRow, cPartsCol) = FormatToolsParts(GetXMLValue(strSrcText, "Pts"))
    RS.Cells(intOutRow, cToolsCol) = FormatToolsParts(GetXMLValue(strSrcText, "Tls"))
Else
    RS.Cells(intOutRow, cPartsCol) = ""
    RS.Cells(intOutRow, cToolsCol) = ""
End If

strSpotValue = GetXMLValue(strSrcText, "Spot")

Select Case intGroupedTestType
    Case Is = -1    ' sub test
        RS.Cells(intOutRow, cHasSubtestsCol) = "S"
    Case Is = 0     ' single test
        RS.Cells(intOutRow, cHasSubtestsCol) = "N"
    Case Is = 1     ' header test
        RS.Cells(intOutRow, cHasSubtestsCol) = "Y"
    Case Is = 2     ' first parallel test
        RS.Cells(intOutRow, cHasSubtestsCol) = "P1"
    Case Is = 3     ' second parallel test
        RS.Cells(intOutRow, cHasSubtestsCol) = "P2"
    Case Else       ' should never happen
End Select

' ************* Duration ***************
RS.Cells(intOutRow, cATimeCol) = Replace(Format(sglATime, "##0.0"), ",", ".")

' ************* Spot sensor selection ***************
blnSpotSensorDependent = (LCase(strSpotValue) = "true")

' ************* Chuck mode ***************
Dim strPerChuck As String

If blnShowChuckSelection Then
    If Not blnSingleChuckAllowed Then
        RS.Cells(intOutRow, cPerChuckCol) = "Both chucks"
    Else
        If InStr(strChuckSelection, "BOTH") = 0 And blnSpotSensorDependent Then
            If (InStr(strChuckSelection, "1") > 0 And strSpotSensorType = "SpotLeadingChk2") Or _
                (InStr(strChuckSelection, "2") > 0 And strSpotSensorType = "SpotLeadingChk1") Then
                strPerChuck = "Non-leading spot sensor"
            Else
                strPerChuck = "Leading spot sensor"
            End If
        Else
            If InStr(strChuckSelection, "BOTH") > 0 Then
                strPerChuck = "Both chucks"
            ElseIf InStr(strChuckSelection, "1") > 0 Then
                strPerChuck = "Chuck 1"
            ElseIf InStr(strChuckSelection, "2") > 0 Then
                strPerChuck = "Chuck 2"
            Else
            End If
        End If
        
        RS.Cells(intOutRow, cPerChuckCol) = strPerChuck
    End If
Else
    RS.Cells(intOutRow, cPerChuckCol) = ""
End If

End Sub
Private Function HasSubLink(origLink As String) As Boolean
    Dim result As Boolean
    Dim strArr() As String

    result = False
    If InStr(origLink, "#") > 0 Then
        strArr() = Split(origLink, "#")
        result = IsNumber(strArr(UBound(strArr)))
    End If
    HasSubLink = result
End Function

Private Sub ShowSequenceStepProcedure(blnMissingInfo As Boolean, _
    intOutRow As Integer, RS As Worksheet, myHeader As tHeaderRecord, blnUseLocalCoach As Boolean, _
    strSpotSensorType As String, Optional strSrcText As String = "", Optional blnShowMissing As Boolean = True, _
    Optional blnGroupTest As Boolean = False)

Dim blnSingleChuckMode As Boolean
Dim strSpotSensorOption As String
Dim strProcName As String
Dim strProcSection As String
Dim strMOID As String
Dim strSrcMOID As String
Dim strCoachURL As String
Dim strTxtArr() As String
Dim strHyperlink As String

If blnGetDetailsFromSource And strSrcText <> "" And InStr(strSrcText, "##") > 0 Then
    strTxtArr() = Split(strSrcText, "##")
    strTxtArr() = Split(strTxtArr(0), " ")
    strCoachURL = GetXMLValue(strSrcText, "CoachURL")
    If strCoachURL <> "" Then
        strMOID = "url:" & strCoachURL
    Else
        strMOID = strTxtArr(2)
    End If
    
    strProcName = GetXMLValue(strSrcText, "Proc")
    strSrcMOID = GetXMLValue(strSrcText, "MOID")
    strProcSection = GetXMLValue(strSrcText, "ProcSection")
    
    If strProcName = "" And blnShowMissing And blnGroupTest And strSrcMOID = "NA" Then 'group Test with MOID = NA
        strProcName = "NA"
    ElseIf strProcName = "" And blnShowMissing Then 'Any Other case when MOID is missing
        strProcName = "Missing"
    End If
Else
    strProcName = "Missing"
    strMOID = "Missing"
End If
RS.Cells(intOutRow, cProcedureNameCol) = strProcName

blnSingleChuckMode = (RS.Cells(intOutRow, cPerChuckCol) <> "" And InStr(RS.Cells(intOutRow, cPerChuckCol), "Both") = 0)

strSpotSensorOption = ""
' I don't like the '-' in spot-sensor, but that's how it's used in coach
If blnSingleChuckMode Then
    If RS.Cells(intOutRow, cPerChuckCol) = "Leading spot sensor" Then
        strSpotSensorOption = "Leading spot-sensor"
    ElseIf RS.Cells(intOutRow, cPerChuckCol) = "Non-leading spot sensor" Then
        strSpotSensorOption = "Non-leading spot-sensor"
    End If
End If

Dim strSheetname As String
strSheetname = GetRecoverySheetName
If strSheetname <> "" Then
    If myHeader.Initialised Then
        strHyperlink = fnProcedureLink(strSheetname, strMOID, myHeader, blnSingleChuckMode, strSpotSensorOption, _
            blnUseLocalCoach, LCase(Left(RS.Cells(intOutRow, cProcedureNameCol), 1)) = "g")
                    
        ' CoachURL on TestName if it points to a section
        If strProcName <> "" And strProcName <> "Missing" And strProcName <> "NA" And (InStr(LCase(strHyperlink), "coach") > 0 Or InStr(strHyperlink, ".html") > 0) Then
             If Not HasSubLink(strHyperlink) Then
               If strProcSection <> "" Then
                RS.Hyperlinks.Add _
                Anchor:=RS.Cells(intOutRow, cTestNameCol), _
                Address:=strHyperlink
               Else
                RS.Hyperlinks.Add _
                Anchor:=RS.Cells(intOutRow, cProcedureNameCol), _
                Address:=strHyperlink
               End If
            End If
        Else
            RS.Cells(intOutRow, cProcedureNameCol).Hyperlinks.Delete
        End If
    End If
End If

End Sub

Public Function fnProcedureLink(strSheetname As String, strInvTxt As String, _
    header As tHeaderRecord, blPerChuck As Variant, strSpotSensorOption As String, _
    Optional bUseLocalCoach As Boolean = False, Optional blnSourceProc As Boolean = False)

Dim strProcTmp As String
Dim strProcType As String
Dim strMachine As String
Dim strRelease As String
Dim blnCoachURL As Boolean
Dim bValidLink As Boolean

bValidLink = True
blnCoachURL = False
If InStr(strInvTxt, ":") > 0 Then
    If Left(strInvTxt, InStr(strInvTxt, ":") - 1) = "url" Then
        blnCoachURL = True
    End If
    strProcTmp = Mid(strInvTxt, InStr(strInvTxt, ":") + 1)
Else
    strProcTmp = strInvTxt
End If

If InStr(strProcTmp, " ") > 0 Then
    strProcTmp = Left(strProcTmp, InStr(strProcTmp, " ") - 1)
End If
    
If InStr(strProcTmp, ",") > 0 Then
    strProcTmp = Left(strProcTmp, InStr(strProcTmp, ",") - 1)
End If

If blnSourceProc Then
    strRelease = UCase(header.SourceRelease)
Else
    strRelease = Replace(UCase(header.Release), "R", "")
    strRelease = Replace(strRelease, "B", "")
    strRelease = Replace(strRelease, "C", "")
End If

If IsNumber(strProcTmp) Or blnCoachURL Then
    If header.Initialised Then
        If blnCoachURL Then
' Next line yielded out of memory results when switching coach, likely due to double profiling arguments
'            fnProcedureLink = "http://coach.asml.com" & strProcTmp & "&destinationList=##DESTINATION##&systemList=##SYSTEM##&softwareList=##SWREL##&optionList=##CHUCKOPT##&department=&mode=&expertLevel=&revision=&indicenterMode="
'            fnProcedureLink = "http://coach.asml.com" & strProcTmp & "&optionList=##CHUCKOPT##&department=&mode=&expertLevel=&revision=&indicenterMode="
             fnProcedureLink = "http://coach.asml.com" & strProcTmp
        Else
            fnProcedureLink = "http://coach.asml.com/Coach/ViewDocument?moid=" & strProcTmp & "&destinationList=##DESTINATION##&systemList=##SYSTEM##&softwareList=##SWREL##&optionList=##CHUCKOPT##&department=&mode=&expertLevel=&revision=&indicenterMode="
        End If

        strProcType = strProcTypeList(header.Procedures)
            
        fnProcedureLink = Replace(fnProcedureLink, "##DESTINATION##", strProcType)
        If blnSourceProc Then
            fnProcedureLink = Replace(fnProcedureLink, "##SYSTEM##", header.SourceType)
        Else
            fnProcedureLink = Replace(fnProcedureLink, "##SYSTEM##", Replace(header.MachineType, ":", "%3A"))
        End If
            
        fnProcedureLink = Replace(fnProcedureLink, "##SWREL##", strRelease)
        If header.platform = "NXE" Then
            If InStr(LCase(header.SourceType), "ushio") > 0 Then
                fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", "USHIO")
            Else
                fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", "CYMER")
            End If
        Else
            If Not blPerChuck Then
                fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", "Both Chucks")
            Else
                If strSpotSensorOption = "" Then
                    If InStr(header.ChuckSelection, "1") > 0 Then
                        fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", "Chuck 1 only")
                    ElseIf InStr(header.ChuckSelection, "2") > 0 Then
                        fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", "Chuck 2 only")
                    Else
                        fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", "Both chucks")
                    End If
                Else
                    fnProcedureLink = Replace(fnProcedureLink, "##CHUCKOPT##", strSpotSensorOption)
                End If
            End If
        End If
            
    Else
        'link already exists
    End If
        
    If bUseLocalCoach Then
        fnProcedureLink = Replace(fnProcedureLink, "coach.asml.com", "localhost:8888")
    Else
        fnProcedureLink = Replace(fnProcedureLink, "localhost:8888", "coach.asml.com")
    End If
ElseIf Len(strProcTmp) > 2 And InStr(strProcTmp, ".") > 0 Then
    
    If LCase(Left(strProcTmp, 1)) = "c" Then 'NXT, NXT3
        Select Case Mid(strProcTmp, 2, 1)
        Case Is = "t"
            strProcType = "Test"
        Case Is = "s"
            strProcType = "Service"
        Case Is = "i"
            strProcType = "IntegrationInstall"
        Case Is = "f"
            strProcType = "Fasy"
            bValidLink = bValidLink And Not bUseLocalCoach
        Case Is = "a"
            strProcType = "Assy"
            bValidLink = bValidLink And Not bUseLocalCoach
        Case Else
            bValidLink = False
        End Select
            
        strProcTmp = "c" + Mid(strProcTmp, 3)
        strMachine = Replace(Replace(Replace(Worksheets(strSheetname).Range("machinetype"), ":", "_"), "IV", ""), "I", "")
        strMachine = Replace(strMachine, "NT1-", "NXT_")
        strMachine = Replace(strMachine, "NXT2_1960i", "NXT2_1960Bi")
        strMachine = Replace(strMachine, "NXT3_1970i", "NXT3_1970Ci")
            
    ElseIf LCase(Left(strProcTmp, 1)) = "e" Then 'NXE
        strMachine = Replace(Worksheets(strSheetname).Range("machinetype"), "NXE3", "NXE%3A3")
    Else
        bValidLink = False
    End If
        
    If bUseLocalCoach Then
        ' linking to new coach
        fnProcedureLink = _
            "http://localhost:8888/Coach/CoachAPI?rm=listproc&proc=" + strProcTmp + "&sys=" + strMachine + "&dest=" + strProcType + "&optionlist=none"
    Else
        ' linking to new coach
        fnProcedureLink = _
            "http://coach.asml.com/Coach/CoachAPI?rm=listproc&proc=" + strProcTmp + "&sys=" + strMachine + "&dest=" + strProcType + "&optionlist=none"
    End If
Else
    bValidLink = False
    fnProcedureLink = ""
End If

End Function

Public Sub RepairRecoverySequence(blnRepairSteps As Boolean, blnRepairLinks As Boolean, blnOnlyUpdateRestoredSteps As Boolean)

Dim RS As Worksheet
Dim blnSingleChuckAllowed As Boolean
Dim blnUseLocalCoach As Boolean
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim intBLRow As Integer
Dim intOutRow As Integer
Dim strText As String
Dim myHeader As tHeaderRecord
Dim strSheetname As String
Dim blnRepairedStep As Boolean
Dim strSpotSensorType As String
Dim blnMissingInfo As Boolean
Dim bNXE As Boolean
Dim intSourceRow As Integer
Dim strDetails As String
Dim strDetailArray() As String

On Error GoTo errRepairRecoverySequence

strSheetname = GetRecoverySheetName
If strSheetname = "" Then
    Exit Sub
End If

Set RS = Worksheets(strSheetname)
    
blnUseLocalCoach = Worksheets(strSheetname).optLocalCoach.Value
blnSingleChuckAllowed = (InStr(LCase(myHeader.ChuckSelection), "both") = 0)

ReadHeader myHeader
FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
strSpotSensorType = GetSpotSensorType(myHeader.Configuration)

If blnRepairLinks And Not blnRepairSteps Then
    ReadDetailsFromSource strDetailArray()
End If

For intOutRow = lngStartRecRow To lngLastSeqRow
    strText = RS.Cells(intOutRow, cTestIDCol)
    
    blnRepairedStep = (Left(strText, 1) = "#")
    If blnRepairedStep Then
        If InStr(strText, "|") > 0 Then
            intSourceRow = Val(Mid(strText, InStr(strText, "|") + 1))
            strDetails = Worksheets("Source").Cells(intSourceRow, 1) & Worksheets("Source").Cells(intSourceRow, 2)
            strDetails = Mid(strDetails, InStr(strDetails, " ") + 1)
            strText = Mid(Left(strText, InStr(strText, "|") - 1), 2)
        Else
            strDetails = Mid(strText, InStr(strText, " ") + 1)
            strText = Trim(Replace(Mid(strText, 2), strDetails, ""))
        End If
    Else
        strDetails = FindDetails(strText, strDetailArray())
    End If
    
    If InStr(strText, "SY_DUALCHUCK_MANDATORY") > 0 Then
        blnSingleChuckAllowed = False
    End If

    If Trim(strText) <> "" And (blnRepairedStep Or Not blnOnlyUpdateRestoredSteps) Then
        If blnRepairSteps Then
            If strText <> "FMS:" Then
                ShowSequenceStepInfo strText, intOutRow, RS, blnSingleChuckAllowed, myHeader, Not bNXE, strDetails
            Else
                RS.Cells(intOutRow, cTestIDCol) = ""
            End If
        End If
        If blnRepairLinks Then
            If InStr(strDetails, "CHUCK_1") > 0 Then
                myHeader.ChuckSelection = "Chuck 1"
            ElseIf InStr(strDetails, "CHUCK_2") > 0 Then
                myHeader.ChuckSelection = "Chuck 2"
            Else
                myHeader.ChuckSelection = "Both chucks"
            End If
                
            If strText <> "FMS:" Then
                ShowSequenceStepProcedure blnMissingInfo, intOutRow, RS, _
                    myHeader, blnUseLocalCoach, strSpotSensorType, strDetails
            End If
        End If
    End If
Next intOutRow

Exit Sub

errRepairRecoverySequence:
MsgBox "Error during repair sequence: " & vbCrLf & err.Description
End Sub

Public Sub ReadHeader(header As tHeaderRecord)

Dim strCfg As String
Dim strVersion As String
Dim strMachType As String
Dim strRecovery As String
Dim strSWRelease As String
Dim strStatus As String
Dim strProcType As String

On Error GoTo errReadHeader

strVersion = Range("AreVersion")
strRecovery = Range("Recovery")

strMachType = Range("machinetype")
If strMachType = "NXT2_1960i" Then strMachType = "NXT2_1960Bi"
If strMachType = "NXT3_1970i" Then strMachType = "NXT3_1960Ci"

strCfg = Range("configuration")
strSWRelease = Range("SWrelease")
strStatus = Range("status")

header.Initialised = True
If InStr(strVersion, "-") > 0 Then
    header.Version = Trim(Left(strVersion, InStr(strVersion, "-") - 1))
Else
    header.Version = Trim(strVersion)
End If

If InStr(strRecovery, ":" & vbCrLf) > 0 Then
    header.recovery = Left(strRecovery, InStr(strRecovery, ":" & vbCrLf) - 1)
Else
    header.recovery = strRecovery
End If

header.MachineType = strMachType
header.Configuration = strCfg
header.Release = Left(strSWRelease, InStr(strSWRelease, " -") - 1)
header.PatchLevel = Trim(Mid(strSWRelease, InStr(strSWRelease, ":") + 1))

If InStr(strStatus, " / Recovery reduction: ") > 0 Then
    strProcType = Trim(Mid(strStatus, InStr(strStatus, ":") + 1, InStr(strStatus, " / R") - InStr(strStatus, ":")))
Else
    strProcType = Trim(Mid(strStatus, InStr(strStatus, ":") + 1))
End If

header.Procedures = cTestProc

On Error GoTo 0

ReadProcTypes
For intProcType = 1 To UBound(strProcTypeList)
    If LCase(strProcType) = LCase(strProcTypeList(intProcType)) Then
        header.Procedures = intProcType
    End If
Next intProcType

Exit Sub

errReadHeader:
MsgBox "Cannot read sequence header"

End Sub

Public Sub RepairSequence()

If MsgBox("Do you want to reload the sequence step details?", vbYesNo) = vbYes Then
    Application.ScreenUpdating = False
    RepairRecoverySequence True, True, False
    Application.ScreenUpdating = True
End If

End Sub

Public Sub RepairHyperlinks()

If Not IsSheet("Source") Then
    MsgBox "Cannot repair hyperlinks, source sheet not found", vbOKOnly
    Exit Sub
Else
    If MsgBox("Do you want to repair the procedure hyperlinks?", vbYesNo) = vbYes Then
        Application.ScreenUpdating = False
        RepairRecoverySequence False, True, False
        Application.ScreenUpdating = True
    End If
End If

End Sub

Public Sub SetDebugFileName()

If strSourceDir = "" Then
    strSourceDir = ActiveWorkbook.path
End If

strDebugFile = strSourceDir & "\ARETemplate.dbg"
MsgBox "ARE output template running in debug mode." & vbCrLf & "Debug file: " & strDebugFile, vbOKOnly

WriteDebug "Debug file opened"
WriteDebug "Excel version: " & Application.Version
WriteDebug "Template version: " & Range("TKVersion").Value

End Sub

Public Sub WriteDebug(strText As String)

Dim intDebugFile As Integer

If Not blnDebugMode Then Exit Sub

On Error GoTo errWriteDebug

intDebugFile = FreeFile
Open strDebugFile For Append As #intDebugFile
Print #intDebugFile, date & " " & time & " " & strText
Close #intDebugFile

Exit Sub

errWriteDebug:
MsgBox "Cannot write to " & strDebugFile
End

End Sub

Public Sub WriteError(strRoutine As String, objError As Object)

WriteDebug "An error occurred in routine " & strRoutine
WriteDebug objError.Description

End Sub

Public Sub SetSequenceRowFormat(lngCurRow As Long, intPatternColor As Integer, intFontColor As Integer, _
    Optional blnBoldFont As Boolean = False, Optional intMinCol As Integer = 2, Optional blnHorBorders As Boolean = False)

' blnHorBorders = False
Range(fRange(lngCurRow, cTestNameCol, lngCurRow, cTimeKeeperDetailsCol)).Select
Selection.Font.ColorIndex = intFontColor
Range(fRange(lngCurRow, intMinCol, lngCurRow, cTimeKeeperDetailsCol)).Select
With Selection
    With .Interior
        .ColorIndex = intPatternColor
        If intPatternColor <> xlNone Then
            .Pattern = xlSolid
        End If
    End With
    .Font.Bold = blnBoldFont
    
    .Borders(xlDiagonalDown).LineStyle = xlNone
    .Borders(xlDiagonalDown).LineStyle = xlNone
    .Borders(xlDiagonalUp).LineStyle = xlNone
    .Borders(xlEdgeLeft).LineStyle = xlNone
    If blnHorBorders Then
        With .Borders(xlEdgeTop)
            .LineStyle = xlContinuous
            .ColorIndex = xlAutomatic
            .TintAndShade = 0
            .Weight = xlThin
        End With
        With .Borders(xlEdgeBottom)
            .LineStyle = xlContinuous
            .ColorIndex = xlAutomatic
            .TintAndShade = 0
            .Weight = xlThin
        End With
    End If
    .Borders(xlEdgeRight).LineStyle = xlNone
    .Borders(xlInsideVertical).LineStyle = xlNone
    .Borders(xlInsideHorizontal).LineStyle = xlNone
End With

End Sub

Public Sub ConvertFiles()

If IsSheet("Source") Then
    ManualOpenFile True
Else
    MsgBox "Cannot convert files, source sheet not found", vbOKOnly
End If

End Sub

Private Function GetSpotSensorType(strConfiguration As String) As String

Dim strTmpVal As String
Dim strCfg As String
Dim blnIsChuck2 As Boolean
Dim blnSpotLeadingChk2 As Boolean

strCfg = LCase(strConfiguration)

If InStr(strCfg, "spotleadingchk2: true") > 0 Then
    strTmpVal = "SpotLeadingChk2"
ElseIf InStr(strCfg, "spotleadingchk2: false") > 0 Then
    strTmpVal = "SpotLeadingChk1"
Else
    strTmpVal = "Unknown"
End If

GetSpotSensorType = strTmpVal

End Function

Public Function ShowVacuumStateColumn() As Boolean

'If InStr(LCase(Range("recovery")), " pm scheme") > 0 Then
'    ShowVacuumStateColumn = False
'Else
'    ShowVacuumStateColumn = (InStr(LCase(Range("machinetype")), "nxe") > 0)
'End If

Dim strPlatformType As String

strPlatformType = GetPlatformType(Worksheets("Source").Cells(1, 1))
ShowVacuumStateColumn = (UCase(strPlatformType) = "NXE")

End Function

Public Sub ShowPartialSequence()

Dim strFirstState As String
Dim strLastState As String
Dim strSheetname As String
Dim blnNXE As Boolean
Dim myHeader As tHeaderRecord
Dim intNrFMS As Integer
Dim strFMS() As String
Dim intSwitchPointRow As Integer
Dim strPlatformType As String

If Not IsSheet("Source") Then
    MsgBox "Cannot load partial sequence, source sheet not found", vbOKOnly
    Exit Sub
End If

strPlatformType = GetPlatformType(Worksheets("Source").Cells(1, 1))
blnNXE = (strPlatformType = "NXE")

GetAllFMS strFMS(), intNrFMS

If intNrFMS <= 0 Then
    Exit Sub
End If

Load frmSelectPartial

frmSelectPartial.cmbSelectPartialFromStep.Enabled = False
frmSelectPartial.cmbSelectPartialToStep.Enabled = False
frmSelectPartial.cmbSelectPartialFromStep.Visible = False
frmSelectPartial.cmbSelectPartialToStep.Visible = False
frmSelectPartial.lblSelectPartialFromStep.Visible = False
frmSelectPartial.lblSelectPartialToStep.Visible = False
frmSelectPartial.chkSelectPartialSkip.Visible = False

For intCurFMS = 1 To intNrFMS
    frmSelectPartial.cmbSelectPartialFromState.AddItem strFMS(intCurFMS)
    frmSelectPartial.cmbSelectPartialToState.AddItem strFMS(intCurFMS)
Next intCurFMS

frmSelectPartial.cmbSelectPartialFromState.ListIndex = 0
frmSelectPartial.cmbSelectPartialToState.ListIndex = intNrFMS - 1
frmSelectPartial.Show 1

If blnOK Then
    strFirstState = frmSelectPartial.cmbSelectPartialFromState.Text
    strLastState = frmSelectPartial.cmbSelectPartialToState.Text
    Unload frmSelectPartial
    
    ReadProcTypes
    ClearTemplate False, False
    strSheetname = GetRecoverySheetName
    
    Application.ScreenUpdating = False

    Workbooks(strTemplate).Activate
    Workbooks(strTemplate).Sheets(strSheetname).Select
    
    CreateHeader myHeader, "" ', wsBL
    myHeader.Procedures = 1
    myHeader.StartStep = strFirstState
    myHeader.StopStep = strLastState
    
    CreateSequence strSheetname, strPlatformType, strFirstState, strLastState, myHeader, blnNXE, intSwitchPointRow
    
    WriteHeaderInfo myHeader
    TimeKeeperExport
   
    If ShowVacuumStateColumn Then
        ShowVacuumStates
    End If
    
    If intSwitchPointRow > 0 Then
        GreyOutLines intSwitchPointRow
    End If
    
    Application.ScreenUpdating = True
Else
    Unload frmSelectPartial
End If

End Sub

Private Sub ReloadSequence()

Dim strSheetname As String
Dim blnNXE As Boolean
Dim myHeader As tHeaderRecord
Dim intSwitchPointRow As Integer
Dim strPlatformType As String

If Not IsSheet("Source") Then
    MsgBox "Cannot reload sequence, source sheet not found", vbOKOnly
    Exit Sub
End If

If MsgBox("TimeKeeper information will be lost." & vbCrLf & "Are you sure you want to reload the original sequence file?", vbOKCancel) = vbOK Then
    
    strPlatformType = GetPlatformType(Worksheets("Source").Cells(1, 1))

    blnNXE = (strPlatformType = "NXE")
    
    sngBFactor = 1.8
    
    ReadProcTypes
    ClearTemplate False, False
    strSheetname = GetRecoverySheetName
    
    Application.ScreenUpdating = False
    
    SetTemplateNameDir
    Workbooks(strTemplate).Activate
    Workbooks(strTemplate).Sheets(strSheetname).Select
        
    CreateHeader myHeader, "" ', wsBL
    myHeader.Procedures = 1
        
    CreateSequence strSheetname, strPlatformType, "", "", myHeader, blnNXE, intSwitchPointRow
    
    WriteHeaderInfo myHeader
    TimeKeeperExport
       
    If ShowVacuumStateColumn Then
        ShowVacuumStates
    End If
        
    If intSwitchPointRow > 0 Then
        GreyOutLines intSwitchPointRow
    End If
    
    Application.ScreenUpdating = True
End If

End Sub

Public Sub GetAllFMS(strFMS() As String, intNrFMS As Integer, Optional blnIncludeDiagHW As Boolean = True)

Dim intCurRow As Integer
Dim intNrStepsInFMS As Integer
Dim strText As String

intNrStepsInFMS = 0

If IsSheet("Source") Then
    If blnIncludeDiagHW Then
        intNrFMS = 3
        ReDim Preserve strFMS(intNrFMS) As String
        strFMS(1) = strFMSDiagnostics
        strFMS(2) = strFMSDTWP
        strFMS(3) = strFMSHWReplacement
    Else
        intNrFMS = 0
    End If
    
    intCurRow = 2
' If source sheet is available, use it
    Do While Worksheets("Source").Cells(intCurRow, 1) <> ""
        If InStr(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]") > 0 Then
            strText = Mid(Worksheets("Source").Cells(intCurRow, 1), 8)
            If InStr(strText, "##") <> 1 And InStr(strText, "$$") = 0 And Left(strText, 1) <> "=" And InStr(strText, "DEBUG") = 0 Then
                If InStr(strText, "FMS COMPLETE:") > 0 Then
                    If intNrStepsInFMS > 0 Then
                        intNrFMS = intNrFMS + 1
                        ReDim Preserve strFMS(intNrFMS) As String
                        strFMS(intNrFMS) = FormatFMSstring(strText)
                        intNrStepsInFMS = 0
                    End If
                Else
                    intNrStepsInFMS = intNrStepsInFMS + 1
                End If
            End If
        End If
        intCurRow = intCurRow + 1
    Loop
Else
' else use recovery sheet
    Dim strSheetname As String
    Dim lngHeaderRow As Long
    Dim lngStartRecRow As Long
    Dim lngLastSeqRow As Long
    
    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
    For intCurRow = lngHeaderRow + 1 To lngLastSeqRow
'        If Worksheets(strSheetName).Cells(intCurRow, cHasSubtestsCol) = "F" Then
        If Worksheets(strSheetname).Cells(intCurRow, cTestIDCol) = "" Then
            intNrFMS = intNrFMS + 1
            ReDim Preserve strFMS(intNrFMS) As String
            strFMS(intNrFMS) = Worksheets(strSheetname).Cells(intCurRow, cTestNameCol)
        End If
    Next intCurRow
End If

End Sub

Public Function FormatToolsParts(strText As String) As String

Dim strTmpVal As String

If Trim(strText) = "\n" Then
    FormatToolsParts = ""
Else
    strTmpVal = txtRemoveDoubles(strText, " ")
    strTmpVal = Replace(strTmpVal, "\n", ";")
    If Right(strTmpVal, 1) = ";" Then
        strTmpVal = Left(strTmpVal, Len(strTmpVal) - 1)
    End If
    FormatToolsParts = strTmpVal
End If

End Function

Private Sub GreyOutLines(intStartRow As Integer)

Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long
Dim strSheetname As String
    
strSheetname = GetRecoverySheetName
FindHeaderRow lngHeaderRow
FindLastSequenceRow strSheetname, lngHeaderRow + 1, lngLastSeqRow, , False

If intStartRow < lngLastSeqRow Then
    With Rows(fRows(intStartRow + 1, lngLastSeqRow)).Font
        .ColorIndex = 15
    End With
End If

End Sub

Public Function RepairDirName(strDirName As String) As String

Dim strArr() As String
Dim intStepInd As Integer
Dim strTmpVal As String
Dim i As Integer

' Remove ".." from dir

If InStr(strDirName, "..") > 0 Then
    strArr = Split(strDirName, "\")
    
    intStepInd = 0
    For i = 1 To UBound(strArr)
        If strArr(i) = ".." Then
            intStepInd = i
        End If
    Next i

    If intStepInd > 0 Then
        strTmpVal = ""
        For i = 0 To UBound(strArr)
            If i < intStepInd - 1 Or i > intStepInd Then
                strTmpVal = strTmpVal & strArr(i) & "\"
            End If
        Next i
        RepairDirName = strTmpVal
    Else
        RepairDirName = strDirName
    End If
Else
    RepairDirName = strDirName
End If


End Function

Sub ReadDetailsFromSource(strDetailArray() As String)

Dim intCurRow As Integer
Dim strText As String
Dim intArrSize As Integer

intArrSize = 0
intCurRow = 1
While Worksheets("Source").Cells(intCurRow, 1) <> ""
    strText = Worksheets("Source").Cells(intCurRow, 1)
    If InStr(strText, "##<Detl>") > 0 Then
        intArrSize = intArrSize + 1
        ReDim Preserve strDetailArray(intArrSize) As String
        strDetailArray(intArrSize) = Replace(strText, "[INPUT]", "")
    End If
    intCurRow = intCurRow + 1
Wend

End Sub

Private Function FindDetails(strText As String, strDetailArray() As String) As String

Dim intArrInd As Integer

On Error GoTo errFindDetails

For intArrInd = 1 To UBound(strDetailArray)
    If InStr(strDetailArray(intArrInd), strText) = 1 Then
        FindDetails = Mid(strDetailArray(intArrInd), InStr(strDetailArray(intArrInd), " ") + 1)
        Exit Function
    End If
Next intArrInd

errFindDetails:
FindDetails = ""

End Function

Public Sub SwitchHyperlinks(bUseLocalCoach As Boolean)

Application.ScreenUpdating = False
With Application
    .Calculation = xlManual
    .MaxChange = 0.001
End With
ActiveWorkbook.PrecisionAsDisplayed = False

With ActiveSheet
    For Each h In .Hyperlinks
        If bUseLocalCoach Then
            h.Address = Replace(h.Address, "coach.asml.com", "localhost:8888")
'            h.Name = h.Address
        Else
            h.Address = Replace(h.Address, "localhost:8888", "coach.asml.com")
'            h.Name = h.Address
        End If
    Next h
    .Range("a1").Select
End With

' Procedure to resume the automatic Excel calculations
With Application
    .Calculation = xlAutomatic
    .MaxChange = 0.001
End With
ActiveWorkbook.PrecisionAsDisplayed = False
Application.ScreenUpdating = True

End Sub

Sub SetTemplateNameDir()
    
strTemplate = ActiveWorkbook.Name
strSourceDir = ActiveWorkbook.path

End Sub

Public Function UseParallellismLight() As Boolean

Dim strPlatformType As String

strPlatformType = GetPlatformType(Worksheets("Source").Cells(1, 1))

UseParallellismLight = (strPlatformType = "SRC" Or strPlatformType = "SRC_HW" Or strPlatformType = "NXE")

End Function

Public Sub ShowConfiguration()

Dim strCfg As String
Dim strArg() As String
Dim intArg As Integer
Dim strKey As String
Dim strVal As String

strCfg = Range("configuration").Value
If strCfg <> "" Then
    strArg = Split(strCfg, ";")
    SortList strArg()
    
    Load frmScenarioList
    frmScenarioList.Caption = "Configuration Settings:"
    With frmScenarioList.lstList
        .ColumnCount = 2
           
        For intArg = 0 To UBound(strArg)
            strKey = Trim(Left(strArg(intArg), InStr(strArg(intArg), ":") - 1))
            strValue = Trim(Mid(strArg(intArg), InStr(strArg(intArg), ":") + 1))
            .AddItem strKey
            .List(.ListCount - 1, 1) = strValue
        Next intArg
    End With
    
    frmScenarioList.Show 0
End If

End Sub

Private Sub SortList(strArg() As String)

Dim i As Integer
Dim j As Integer
Dim strTmp As String

For i = 0 To UBound(strArg) - 1
    For j = i + 1 To UBound(strArg)
        If Trim(strArg(i)) > Trim(strArg(j)) Then
            strTmp = strArg(j)
            strArg(j) = strArg(i)
            strArg(i) = strTmp
        End If
    Next j
Next i

End Sub
Attribute VB_Name = "modSQRExport"
Public Sub TransferSequenceToEPS()

Dim strEPS As String
Dim strEPSList() As String
Dim intNrEPS As Integer
Dim strMachNr As String
Dim strName As String
Dim strReason As String
Dim strADECFile As String

' Fill list of available EPS's
GetEPSList strEPSList(), intNrEPS

If intNrEPS <= 0 Then
    MsgBox "Cannot upload file: no EPS IDs found.", vbOKOnly
Else
    Load frmSQRtoEPS
    
    frmSQRtoEPS.cmbSQRtoEPS.Clear
    frmSQRtoEPS.txtSQRtoEPSMachNr.Text = ""
    frmSQRtoEPS.txtSQRtoEPSReason.Text = ""
    
    For intEPSInd = 1 To UBound(strEPSList)
        frmSQRtoEPS.cmbSQRtoEPS.AddItem strEPSList(intEPSInd)
    Next intEPSInd
    
    frmSQRtoEPS.cmdSQRtoEPSTransfer.Enabled = False
    frmSQRtoEPS.Show 1
    
    If blnOK Then
        strEPS = frmSQRtoEPS.cmbSQRtoEPS.Text
        strMachNr = Replace(LCase(frmSQRtoEPS.txtSQRtoEPSMachNr.Text), "m", "")
        strName = frmSQRtoEPS.txtSQRtoEPSName.Text
        strReason = frmSQRtoEPS.txtSQRtoEPSReason.Text
        
    ' Create sequence file and test files
        SQRCreateXML strMachNr, strName, strReason, strADECFile
        
    ' Upload file
        UploadFile strEPS, strMachNr, strReason, frmSQRtoEPS.txtUser.Text, frmSQRtoEPS.txtPassword.Text, strADECFile
        
    End If
    
    Unload frmSQRtoEPS
    
End If

End Sub
'--------------------------------------------------------------
' Open a new xml file
'--------------------------------------------------------------
Private Sub OpenXML(xmlDoc As Object, mxxml As Object, cnth As Object, blnStatus As Boolean)

blnStatus = True
Set xmlDoc = CreateObject("MSXML2.DOMDocument.6.0")

If xmlDoc Is Nothing Then
    MsgBox "Cannot create MSXML DOM Document"
    blnStatus = False
    Exit Sub
End If
    
Set mxxml = CreateObject("MSXML2.MXXMLWriter.6.0")
If mxxml Is Nothing Then
    MsgBox "Cannot create MXXML Writer"
    blnStatus = False
    Exit Sub
End If

Set cnth = mxxml
mxxml.Output = xmlDoc
mxxml.indent = True

End Sub

'--------------------------------------------------------------
' Create an SQR ADEC file
'    strZipFile : the name of the ADEC to be created
'--------------------------------------------------------------
Private Sub SQRCreateADEC(strZipFile As String)
    Dim strSeqFile As String
    Dim intNrCPDFiles As Integer
    Dim intNrManaulFiles As Integer
    Dim strCPDFiles() As String
    Dim strZipBinary As String
    Dim xmlDoc As Object
    Dim mxxml As Object
    Dim cnth As Object
    Dim atrs As New SAXAttributes30
    Dim blnStatus As Boolean
    Dim configItems() As NameVal
    Dim i As Integer
    Dim j As Integer
    Dim k As Integer
    Dim Item As NameVal
    Dim recoveries() As String
    Dim sequence As SequenceInfo
    Dim curStep As Step
    Dim ns As String
    Dim machineid As String
    Dim docRef As String
    Dim startMode As String
    Dim warningTests() As String
    Dim warningLinks() As String
    Dim warTestIndex As Integer
    Dim warLinkIndex As Integer
    Dim strWarning As String
    Dim testName As String
    Dim bDuplicateTest As Boolean
    Dim bDuplicateLink As Boolean
    Dim bItemVisible As Boolean
    
    If Not IsSheet("Source") Then
        MsgBox "Cannot create XML export file, source sheet is not found", vbOKOnly
        Exit Sub
    End If
    ' Define output paths and filenames
    strZipBinary = "C:\Program Files\7-Zip\7z.exe"
    strPostFix = "_" & strMachNr & "_" & Format(date, "yyyymmdd") & "_" & Format(time, "hhmm")
    strSourceDir = Left(strZipFile, InStrRev(strZipFile, "\"))
    strSeqFile = strSourceDir & "\ADELcpdSequence.xml"

    intNrCPDFiles = 0
    intNrManaulFiles = 0
    warTestIndex = 0
    warLinkIndex = 0
    ReDim Preserve warningTests(0)
    ReDim Preserve warningLinks(0)
    bDuplicateTest = False
    bDuplicateLink = False
    bItemVisible = False

    OpenXML xmlDoc, mxxml, cnth, blnStatus
    If Not blnStatus Then
        Exit Sub
    End If

    cnth.startDocument
    cnth.processingInstruction "xml", "version=""1.0"" encoding=""UTF-8"" standalone=""yes"""
    ns = "http://www.asml.com/XMLSchema/MT/Generic/ADELcpdSequence/v2.0"

    StartElement cnth, "ADELcpdSequence", Nothing, ns

    'Header-------------------------------------------------------------------------------------------------------------------------------
        StartElement cnth, "Header", Nothing, ns
            'MachineName
            machineid = getConfigurationItem("MachineId")
            If machineid = "" Then
                machineid = "0000"
            End If
            WriteElement cnth, "MachineName", machineid, ns
            'CreatedBy
            WriteElement cnth, "CreatedBy", "are-sqr", ns
            'CreatedTime
            WriteElement cnth, "CreatedTime", Format(date + time, "yyyy-mm-ddThh:mm:ss"), ns
            'Generator
            StartElement cnth, "Generator", Nothing, ns
                WriteElement cnth, "GeneratorName", "ARE COI SQR Coupling", ns
                WriteElement cnth, "GeneratorId", "com.asml.sr.core:adel", ns
                WriteElement cnth, "GeneratorVersion", getAREVersion, ns
            EndElement cnth, "Generator"
        EndElement cnth, "Header"

    'GenericInfo--------------------------------------------------------------------------------------------------------------------------
        StartElement cnth, "GenericInfo", Nothing, ns
            'Configuration
            StartElement cnth, "Configuration", Nothing, ns
                'Platform
                WriteElement cnth, "Platform", getPlatform, ns
                'Elements
                configItems = getConfigurationItems
                For i = 0 To UBound(configItems)
                    Item = configItems(i)
                    If Not Item.Name = "" Then
                        StartElement cnth, "Element", Nothing, ns
                            WriteElement cnth, "Name", Item.Name, ns
                            WriteElement cnth, "Value", Item.Value, ns
                        EndElement cnth, "Element"
                    End If
                Next i
            EndElement cnth, "Configuration"
            WriteElement cnth, "SequenceId", CreateGuid(), ns
        EndElement cnth, "GenericInfo"
    
    'Sequence-----------------------------------------------------------------------------------------------------------------------------
        StartElement cnth, "Sequence", Nothing, ns
            sequence = getStepGroups
        
            'SequenceInfo
            StartElement cnth, "SequenceInfo", Nothing, ns
                WriteElement cnth, "Name", getSequenceName, ns
                WriteElement cnth, "Reason", getSequenceReason, ns
                recoveries = getRecoveries
                For i = 0 To UBound(recoveries)
                    If Not (recoveries(i) = "") Then
                        WriteElement cnth, "Recovery", recoveries(i), ns
                    End If
                Next i
                WriteElement cnth, "Duration", sequence.totalDuration, ns
            EndElement cnth, "SequenceInfo"
        
            For i = 0 To UBound(sequence.Group)
                'StepGroup
                StartElement cnth, "StepGroup", Nothing, ns
                    WriteElement cnth, "GroupName", sequence.Group(i).groupName, ns
                    For j = 0 To UBound(sequence.Group(i).Step)
                        curStep = sequence.Group(i).Step(j)
                        
                        
                        If execNameIsOke(curStep.Exec) And curStep.Scenario <> "" And curStep.NsVersion <> "" Then
                            docRef = curStep.DocumentReference
                            startMode = curStep.startMode
                            Call createADELcpd(strSourceDir & "\" & docRef, curStep, False)
                        Else
                           docRef = "ADELcpdManualTask_" & Format(date, "yyyymmdd") & "_" & Format(time, "hhmm") & "_" & intNrManaulFiles & ".xml"
                            startMode = "Manual"
                            If curStep.startMode <> "Manual" Then
                               'a not-manual step should always have an exec, a scenario and a version, add this one to a list
                               'and show the warning later on
                                ReDim Preserve warningTests(warTestIndex)
                                testName = curStep.Description & " - " & curStep.TestID
                                
                                For k = 0 To UBound(warningTests)
                                    If warningTests(k) = testName Then
                                        bDuplicateTest = True
                                        Exit For
                                    End If
                                Next k
                                If Not bDuplicateTest Then
                                    warningTests(warTestIndex) = testName
                                    warTestIndex = warTestIndex + 1
                                End If
                                
                            End If
                            Call createADELcpd(strSourceDir & "\" & docRef, curStep, True)
                            intNrManaulFiles = intNrManaulFiles + 1
                        End If
                        
                        
                        atrs.Clear
                        If startMode <> "" And curStep.Intention <> "" Then
                            atrs.addAttribute "", "", "ExecuteMode", "", startMode
                            atrs.addAttribute "", "", "Intention", "", curStep.Intention
                        End If
                        StartElement cnth, "Step", atrs, ns
                        
                            WriteElement cnth, "StepId", curStep.StepId, ns
                            WriteElement cnth, "DocumentReference", docRef, ns
                            WriteElement cnth, "Description", curStep.Description, ns
                            WriteElement cnth, "TestID", curStep.TestID, ns
                            WriteElement cnth, "Duration", curStep.duration, ns
                            WriteElement cnth, "ProcedureID", curStep.ProcedureId, ns
                            WriteElement cnth, "ProcedureName", curStep.ProcedureName, ns
                            If curStep.ProcedureLink = "Error" Then
                                ReDim Preserve warningLinks(warLinkIndex)
                                testName = curStep.Description & " - " & curStep.TestID
                                For k = 0 To UBound(warningLinks)
                                    If warningLinks(k) = testName Then
                                        bDuplicateLink = True
                                        Exit For
                                    End If
                                Next k
                                If Not bDuplicateLink Then
                                    warningLinks(warLinkIndex) = testName
                                    warLinkIndex = warLinkIndex + 1
                                End If
                                WriteElement cnth, "ProcedureLink", "", ns
                            Else
                                WriteElement cnth, "ProcedureLink", curStep.ProcedureLink, ns
                            End If
                            WriteElement cnth, "Parts", curStep.Parts, ns
                            WriteElement cnth, "Tools", curStep.Tools, ns
                            WriteElement cnth, "Exec", curStep.Exec, ns
                        EndElement cnth, "Step"
                        intNrCPDFiles = intNrCPDFiles + 1
                        ReDim Preserve strCPDFiles(intNrCPDFiles) As String
                        strCPDFiles(intNrCPDFiles) = docRef
                        
                    Next j
                EndElement cnth, "StepGroup"
            Next i
            
            If UBound(warningTests) > -1 Then
                strWarning = "The following (semi-) automatic steps have an incomplete exec, CPDscenario and CPDversion while the reference is " & _
                    "not found. Note that the reference is done with the moid, the ARE key and the chuck. The StartModes will be downgraded to manual" & vbCrLf & vbCrLf
                For i = 0 To UBound(warningTests)
                    If warningTests(i) <> "" Then
                        strWarning = strWarning & warningTests(i) & vbCrLf
                        bItemVisible = True
                    End If
                Next i
                strWarning = vbCrLf & strWarning & vbCrLf & _
                "Use CTRL+C to copy the information in this window"
                If bItemVisible Then
                    MsgBox (strWarning)
                End If
            End If
            
            bItemVisible = False
            If UBound(warningLinks) > -1 Then
                strWarning = "The following steps do not have a correct coach link." & vbCrLf & vbCrLf
                For i = 0 To UBound(warningLinks)
                    If warningLinks(i) <> "" Then
                        strWarning = strWarning & warningLinks(i) & vbCrLf
                        bItemVisible = True
                    End If
                Next i
                strWarning = vbCrLf & strWarning & vbCrLf & _
                "Use CTRL+C to copy the information in this window"
                If bItemVisible Then
                    MsgBox (strWarning)
                End If
            End If
        EndElement cnth, "Sequence"
    EndElement cnth, "ADELcpdSequence"
    cnth.endDocument
    xmlDoc.Save strSeqFile

    CreateDirFile strSourceDir & "\", "ADELdirectory.xml", strSeqFile, intNrCPDFiles, strCPDFiles()

    ' Now create zip file and wait until file exists
    Shell strZipBinary & " a " & """" & strZipFile & """" & " " & strSourceDir & "\ADEL*.xml " & strSourceDir & "\ADELdirectory.xml"
    PauseTime 2

    ' Delete the genereated xml files (previously, WinZip was used to Zip files using a move argument,
    ' unfortenately 7Zip doesn't support moving files into archives, therefor they must be deleted them manually
    Kill strSourceDir & "\ADEL*.xml"
End Sub

Private Function execNameIsOke(strValue As String) As Boolean
    Dim i As Integer
    Dim result As Boolean
    Dim asci As Integer
    
    If strValue = "" Then
        result = False
    Else
        For i = 1 To Len(strValue)
            asci = Asc(Mid(strValue, i, 1))
            If (65 <= asci And asci <= 90) Or (97 <= asci And asci <= 122) Or (48 <= asci And asci <= 57) Then
                result = True
            Else
                result = False
                Exit For
            End If
        Next i
    End If
    execNameIsOke = result
End Function



Private Sub WriteElement(cnth As Object, strKey As String, strValue As String, Optional strNameSpace As String = "")

StartElement cnth, strKey, Nothing, strNameSpace
cnth.Characters strValue
EndElement cnth, strKey

End Sub

Private Sub StartElement(cnth As Object, strName As String, objAtt As Object, Optional strNameSpace As String = "", Optional blnDbg As Boolean = False)

cnth.StartElement strNameSpace, "", strName, objAtt
If blnDbg Then Debug.Print "> " & strName

End Sub

Private Sub EndElement(cnth As Object, strName As String, Optional blnDbg As Boolean = False)

cnth.EndElement "", "", strName
If blnDbg Then Debug.Print "< " & strName

End Sub

Private Sub CreateDirFile(strOutputDir As String, strFileName As String, strSeqFile As String, _
    intNrCPDFiles As Integer, strCPDFiles() As String)

Dim xmlDoc As Object
Dim mxxml As Object
Dim cnth As Object
Dim blnStatus As Boolean
Dim atrs As New SAXAttributes30

OpenXML xmlDoc, mxxml, cnth, blnStatus
cnth.startDocument
cnth.processingInstruction "xml", "version=""1.0"" encoding=""UTF-8"""

atrs.Clear
atrs.addAttribute "", "", "xmlns:ADELdirectory", "", "http://www.asml.com/XMLSchema/MT/Generic/ADELdirectory/v1.0"
atrs.addAttribute "", "", "xmlns:xsi", "", "http://www.w3.org/2001/XMLSchema-instance"
atrs.addAttribute "", "", "xsi:schemaLocation", "", "http://www.asml.com/XMLSchema/MT/Generic/ADELdirectory/v1.0 ADELdirectory"

StartElement cnth, "ADELdirectory:ADELdirectory", atrs
    StartElement cnth, "Header", Nothing
    EndElement cnth, "Header"
    StartElement cnth, "GenericInfo", Nothing
        StartElement cnth, "List", Nothing
            StartElement cnth, "List", Nothing
            WriteElement cnth, "Type", "Sequence"
            WriteElement cnth, "Link", "ADELcpdSequence.xml"
            EndElement cnth, "List"
                    
            For i = 1 To intNrCPDFiles
                StartElement cnth, "List", Nothing
                WriteElement cnth, "Type", "cpd"
                WriteElement cnth, "Link", strCPDFiles(i)
                EndElement cnth, "List"
            Next i
        
        EndElement cnth, "List"
    EndElement cnth, "GenericInfo"
EndElement cnth, "ADELdirectory:ADELdirectory"

cnth.endDocument

xmlDoc.Save strOutputDir & strFileName

End Sub

Private Sub WriteKeyValue(cnth As Object, strKey As String)

Dim strValue As String

strValue = SourceKeyValue(strKey)
If strValue <> "Unknown" Then
    StartElement cnth, "Item", Nothing
    StartElement cnth, "Key", Nothing
    cnth.Characters strKey
    EndElement cnth, "Key"
    StartElement cnth, "Value", Nothing
    cnth.Characters strValue
    EndElement cnth, "Value"
    EndElement cnth, "Item"
End If

End Sub

Private Function SourceKeyValue(strKey As String) As String

Dim intCurRow As Integer

intCurRow = 1
While Worksheets("Source").Cells(intCurRow, 1) <> "" And intCurRow < 999
    If InStr(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]" & strKey) = 1 Then
        SourceKeyValue = Mid(Worksheets("Source").Cells(intCurRow, 1), InStr(Worksheets("Source").Cells(intCurRow, 1), "|") + 1)
        Exit Function
    End If
    intCurRow = intCurRow + 1
Wend
SourceKeyValue = "Unknown"

End Function

Private Function WriteSourceValues(cnth As Object, strKey As String) As String

Dim intCurRow As Integer
Dim strValue As String

intCurRow = 1
While Worksheets("Source").Cells(intCurRow, 1) <> "" And intCurRow < 999
    If InStr(Worksheets("Source").Cells(intCurRow, 1), "[INPUT]$$" & UCase(strKey)) = 1 Then
        strValue = Mid(Worksheets("Source").Cells(intCurRow, 1), InStr(Worksheets("Source").Cells(intCurRow, 1), "|") + 1)
        StartElement cnth, strKey, Nothing
        cnth.Characters strValue
        EndElement cnth, strKey
    End If
    intCurRow = intCurRow + 1
Wend

End Function
Private Sub createADELcpd(strDocName As String, curStep As Step, bManual As Boolean)
    Dim xmlDoc As Object
    Dim mxxml As Object
    Dim cnth As Object
    Dim blnStatus As Boolean
    Dim atrs As New SAXAttributes30
    Dim i As Integer

    OpenXML xmlDoc, mxxml, cnth, blnStatus

    If Not blnStatus Then
        Exit Sub
    End If

    cnth.startDocument
    cnth.processingInstruction "xml", "version=""1.0"" encoding=""UTF-8"""

    atrs.Clear
    If bManual Then
        atrs.addAttribute "", "", "xmlns:ADELcpdManualTask", "", "http://www.asml.com/XMLSchema/MT/Generic/ADELcpdManualTask/v1.0"
        atrs.addAttribute "", "", "xmlns:xsi", "", "http://www.w3.org/2001/XMLSchema-instance"
        atrs.addAttribute "", "", "xsi:schemaLocation", "", "http://www.asml.com/XMLSchema/MT/Generic/ADELcpdManualTask/v1.0 ADELcpdManualTask"
        StartElement cnth, "ADELcpdManualTask:Manual", atrs
    Else
        atrs.addAttribute "", "", "xmlns:ADELcpd" & curStep.Exec, "", "http://www.asml.com/XMLSchema/MT/Generic/ADELcpd" & curStep.Exec & "/" & curStep.NsVersion
        atrs.addAttribute "", "", "xmlns:xsi", "", "http://www.w3.org/2001/XMLSchema-instance"
        atrs.addAttribute "", "", "xsi:schemaLocation", "", "http://www.asml.com/XMLSchema/MT/Generic/ADELcpd" & curStep.Exec & "/" & curStep.NsVersion & " ADELcpd" & curStep.Exec & ".xsd"
        StartElement cnth, "ADELcpd" & curStep.Exec & ":Cpd", atrs
    End If

    
        'Header
        StartElement cnth, "Header", Nothing
            WriteElement cnth, "MachineName", ""
            WriteElement cnth, "SoftwareRelease", ""
            WriteElement cnth, "RecipeName", ""
            WriteElement cnth, "CreatedBy", "are-sqr"
            WriteElement cnth, "CreateTime", Format(date + time, "yyyy-mm-ddThh:mm:ss")
            WriteElement cnth, "LastModifiedBy", "are-sqr"
            WriteElement cnth, "LastModifiedTime", Format(date + time, "yyyy-mm-ddThh:mm:ss")
            WriteElement cnth, "VersionId", ""
            WriteElement cnth, "DocumentId", ""
            If bManual Then
                WriteElement cnth, "DocumentType", "ADELcpdManualTask"
                WriteElement cnth, "DocumentTypeVersion", "v1.0"
            Else
                WriteElement cnth, "DocumentType", "ADELcpd" & curStep.Exec
                WriteElement cnth, "DocumentTypeVersion", curStep.NsVersion
            End If
        EndElement cnth, "Header"
        
        'Generic Info
        StartElement cnth, "GenericInfo", Nothing
            If bManual Then
                WriteElement cnth, "ClaimId", "{CLAIM_ID}"
            Else
                WriteElement cnth, "ClaimId", ""
                WriteElement cnth, "SequenceId", ""
                'Note that in de ADELcpdsequence semi automatic is "Semi-Automatic", but in the other cpd files it should be "SemiAutomatic
                WriteElement cnth, "ExecuteMode", Replace(curStep.startMode, "-", "")
            End If
        EndElement cnth, "GenericInfo"
        
        If bManual Then
            StartElement cnth, "Input", Nothing
                WriteElement cnth, "TaskID", "{STEP_ID}"
                WriteElement cnth, "Message", "{COMMENT}"
            EndElement cnth, "Input"
        Else
            'Scenarios
            StartElement cnth, "Scenarios", Nothing
                StartElement cnth, curStep.Scenario, Nothing
                    'Header
                    StartElement cnth, "Header", Nothing
                        WriteElement cnth, "ProcedureVersion", ""
                        WriteElement cnth, "Active", "true"
                    EndElement cnth, "Header"
                    'Inputs
                    StartElement cnth, "Inputs", Nothing
                        For i = 0 To UBound(curStep.EquipmentItem)
                            If curStep.EquipmentItem(i).Name <> "" Then
                                WriteElement cnth, curStep.EquipmentItem(i).Name, curStep.EquipmentItem(i).Value
                            End If
                        Next i
  
                        If curStep.LongChuck <> "" Then
                            WriteElement cnth, "Chuck", curStep.LongChuck
                        End If
                    
                    EndElement cnth, "Inputs"
                EndElement cnth, curStep.Scenario
            EndElement cnth, "Scenarios"
        End If
        
    If bManual Then
        EndElement cnth, "ADELcpdManualTask:Manual"
    Else
        EndElement cnth, strADELcpd & ":Cpd"
    End If
    cnth.endDocument
    'Note that there can be no * in the filename, while sometimes that exec contains a *. Remove this one
    xmlDoc.Save Replace(strDocName, "*", "")
End Sub


Public Function EncodeDuration(dblDuration As Double, Optional strUnit As String = "M") As String
    
Dim lngMin As Long
Dim lngHrs As Long

If strUnit = "H" Then
    lngHrs = Int(dblDuration)
    lngMin = 60 * (dblDuration - lngHrs)
Else
    lngMin = CLng(dblDuration)
    lngHrs = Int(dblDuration / 60)
    lngMin = lngMin - 60 * lngHrs
End If

strTmpVal = "PT"
If lngHrs > 0 Then strTmpVal = strTmpVal & Format(lngHrs, "###0") & "H"
strTmpVal = strTmpVal & Format(lngMin, "00") & "M"

EncodeDuration = strTmpVal

End Function
'-
' Encode a number of nasty characters for XML
Private Function encode(inp As String) As String
    inp = Replace(inp, "&", "&amp;")
    inp = Replace(inp, "<", "&lt;")
    inp = Replace(inp, ">", "&gt;")
    inp = Replace(inp, "'", "&apos;")
    inp = Replace(inp, """", "&quot;")
    encode = inp
End Function

End Function

Private Sub KeyToExecScenario(strInvTxt As String, strCPD As String, strModule As String, strScenario As String)

Dim strArr() As String

strArr = Split(strInvTxt, "_")
strModule = strArr(0)

If UBound(strArr) <= 1 Then
    strScenario = txtNormalCase(strCPD)
Else
    If LCase(strArr(1)) = LCase(strCPD) Then
        If IsNumber(strArr(2)) Then
            strScenario = txtNormalCase(strCPD) & strArr(2)
        Else
            strScenario = ""
            For i = 2 To UBound(strArr)
                strScenario = strScenario & txtNormalCase(strArr(i))
            Next i
        End If
    Else
        strScenario = ""
        For i = 1 To UBound(strArr)
            strScenario = strScenario & txtNormalCase(strArr(i))
        Next i
    End If
End If

End Sub

Private Sub GetEPSList(strEPSArr() As String, intNrEPS As Integer)

On Error GoTo errGetEPSList

Dim xmlhttp As New MSXML2.xmlhttp

xmlhttp.Open "GET", "http://" & strCSManHost & ":8080/filetransfer/services/eps/list", False
xmlhttp.Send
            
Dim XMLDocument As New MSXML2.DOMDocument
Dim epsIds As MSXML2.IXMLDOMNodeList
    
intNrEPS = 0
With XMLDocument
    .Async = False
    .validateOnParse = True
    .LoadXML (xmlhttp.ResponseText)
        
    Dim eps As MSXML2.IXMLDOMNode
    For Each eps In .SelectNodes("//epsList/eps/id")
        intNrEPS = intNrEPS + 1
        ReDim Preserve strEPSArr(intNrEPS) As String
        strEPSArr(intNrEPS) = eps.Text
    Next
End With
    
Exit Sub

errGetEPSList:
MsgBox "Cannot retrieve EPS list" & vbCrLf & err.Description, vbOKOnly
intNrEPS = 0

End Sub

Private Sub UploadFile(strEPS As String, strMachNr As String, strReason As String, _
    strUser As String, strPassword As String, strADECFile As String)

On Error GoTo errUploadFile

Dim RetVal
Dim strJarFile As String
Dim strTmpFile As String    ' Return code will be temporarily stored in this file
Dim strJavaDir As String

Dim sngTimeOut As Single   ' File upload time out in [s]

sngTimeOut = 200

strJarFile = "lib\sqr-upload-0.0.1-SNAPSHOT.jar"
strTmpFile = "C:\Localdata\Setup\ARE\Tools\UplStat.dat"
strJavaDir = "C:\Localdata\Setup\Tools\Java\jre1.7.0_45\bin\"

If IsFile(strADECFile) Then
    
    If IsFile(strTmpFile) Then
' Remove old upload status file (if it exists)
        Kill strTmpFile
    End If
    
' The cmd /c prefix ensures that redirection of the output will work
    RetVal = Shell( _
        "cmd /c " & strJavaDir & "java -jar " & strJarFile & " -user " & strUser & " -pass " & strPassword & _
        " -url https://" & strCSManHost & ":8443/filetransfer/services/sqr/upload" & _
        " -file " & strADECFile & " -eps " & strEPS & " -machine " & strMachNr & " > " & strTmpFile, vbMinimizedNoFocus)

    If RetVal = 0 Then
        'Something has gone wrong. Handle the error
        MsgBox "Error when uploading file", vbOKOnly, "Error"
    Else
        Application.Wait (Now + CDate("00:00:05"))
' The output of the java function is redirected to a file. We must only open this file after it has become non-empty
        If CheckFileStatus(strTmpFile, sngTimeOut) Then
            strStatus = GetReturnCode(strTmpFile)
            If strStatus = "200" Then
                MsgBox "File upload completed"
            Else
                MsgBox "File upload failed" & vbCrLf & "Return code: " & strStatus
            End If
            
'            If IsFile(strTmpFile) Then
'                Kill strTmpFile
'            End If
        Else
            MsgBox "Time-out occurred"
        End If
    End If
Else
    MsgBox "Cannot find file " & strADECFile
End If
    
Exit Sub

errUploadFile:
MsgBox "Error during file upload" & vbCrLf & err.Description, vbOKOnly

End Sub

Private Function CheckFileStatus(strFileName As String, sngTimeOut As Single) As Boolean

Dim dStartTime As Date
Dim dCurTime As Date

dStartTime = Now
Do
    dCurTime = Now
Loop Until FileLen(strFileName) > 0 Or CSng(dCurTime - dStartTime) > sngTimeOut / 24 / 3600

CheckFileStatus = (FileLen(strFileName) > 0)

End Function

Private Function GetReturnCode(strFileName As String) As String

Dim intStatFile As Integer
Dim strTmpVal As String

intStatFile = FreeFile

On Error GoTo errGetReturnCode

Open strFileName For Input As #intStatFile
Line Input #intStatFile, strTmpVal
Close #intStatFile

GetReturnCode = strTmpVal

Exit Function

errGetReturnCode:
GetReturnCode = "Unknown"

End Function

Public Sub ADECExport()
    Dim vZipFile As Variant
    Dim strFileName As String
    Dim strZipFile As String

    strFileName = "C:\Localdata\sqr\data\ADECcpdSequence" & Format(date, "yyyymmdd") & "_" & Format(time, "hhmm") & ".zip"
    vZipFile = Application.GetSaveAsFilename(InitialFileName:=strFileName, _
        FileFilter:="ADEC sequence, *.zip")
    
    If vZipFile <> False Then
        strZipFile = vZipFile
        SQRCreateADEC strZipFile
        MsgBox strZipFile & " created"
    End If
End Sub









Attribute VB_Name = "modSapExport"
Option Explicit

Private Const SapRowFactor = 10

Const PRT_HeaderRow = "PLNNR" & vbTab & "PLNAL" & vbTab & "WERKS" & vbTab & _
    "VERWE" & vbTab & "STATU" & vbTab & "VORNR" & vbTab & "MATNR" & vbTab & _
    "PSNFH" & vbTab & "STEUF" & vbTab & "BZOFFB" & vbTab & "OFFSTB" & vbTab & _
    "EHOFFB" & vbTab & "BZOFFE" & vbTab & "OFFSTE" & vbTab & _
    "EHOFFE" & vbTab & "MGEIBH" & vbTab & "MGVGW" & vbTab & "MGFORM" & vbTab & _
    "EWEINH" & vbTab & "EWVGW" & vbTab & "EWFORM" & vbTab & "TXTSP" & vbTab & _
    "KTSCH2" & vbTab & "TXTZ1" & vbTab & "FHMAR" & vbTab & "FHMNR" & vbTab & _
    "FHWRK" & vbTab & "SFHNR" & vbTab & "DOKAR" & vbTab & "DOKNR" & vbTab & _
    "DOKTL" & vbTab & "DOKVR" & vbTab & "EQUNR"

Const PRT_DefaultRow = "#PLNNR" & vbTab & "1" & vbTab & "NL01" & vbTab & _
    "1" & vbTab & "4" & vbTab & "#VORNR" & vbTab & vbTab & "#PSNFH" & vbTab & _
    "0" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & _
    "PC" & vbTab & "1" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & _
    vbTab & vbTab & "D" & vbTab & vbTab & "NL01" & vbTab & vbTab & _
    "PE" & vbTab & "#DOKNR" & vbTab & "000" & vbTab & "00" & vbTab
                       

Const ROS_HeaderRow = "PLNNR" & vbTab & "PLNAL" & vbTab & "WERKS" & vbTab & _
    "VERWE" & vbTab & "STATU" & vbTab & "VORNR" & vbTab & "ARBPL" & vbTab & _
    "STEUS" & vbTab & "KTSCH" & vbTab & "BMSCH" & vbTab & "VGE01" & vbTab & _
    "VGW01" & vbTab & "VGE02" & vbTab & "VGW02" & vbTab & "VGE03" & vbTab & _
    "VGW03" & vbTab & "VGE04" & vbTab & "VGW04" & vbTab & "VGE05" & vbTab & _
    "VGW05" & vbTab & "VGE06" & vbTab & "VGW06" & vbTab & "RFGRP" & vbTab & _
    "VORNR1" & vbTab & "VORNR2" & vbTab & "KTEXT" & vbTab & "LTXTS" & vbTab & _
    "LTXTO" & vbTab & "ZLMAX" & vbTab & "ZEILM" & vbTab & "ZLPRO" & vbTab & _
    "ZEILP" & vbTab & "UEMUS" & vbTab & "ZMINU" & vbTab & "ZEIMU" & vbTab & _
    "SPMUS" & vbTab & "SPLIM" & vbTab & "SLWID" & vbTab & "USR00" & vbTab & _
    "USR01" & vbTab & "USR02" & vbTab & "USR03" & vbTab & "USR04" & vbTab & _
    "USE04" & vbTab & "USR05" & vbTab & "USE05" & vbTab & "USR06" & vbTab & _
    "USE06" & vbTab & "USR07" & vbTab & "USE07" & vbTab & "USR08" & vbTab & _
    "USR09" & vbTab & "USR010" & vbTab & "USR11" & vbTab & _
    "KNNAM01" & vbTab & "KNNAM02" & vbTab & "KNNAM03" & vbTab & _
    "KNNAM04" & vbTab & "KNNAM05" & vbTab & "KNNAM06" & vbTab & _
    "KNNAM07" & vbTab & "KNNAM08" & vbTab & "KNNAM09" & vbTab & _
    "KNNAM10" & vbTab & "KNNAM11" & vbTab & "KNNAM12" & vbTab & _
    "KNNAM13" & vbTab & "KNNAM14" & vbTab & "KNNAM15"
    
Const ROS_DefaultRow = "#PLNNR" & vbTab & "1" & vbTab & "NL01" & vbTab & _
    "1" & vbTab & "4" & vbTab & "#VORNR" & vbTab & "TEST" & vbTab & _
    "ZMP1" & vbTab & "#KEY" & vbTab & "1" & vbTab & vbTab & vbTab & vbTab & vbTab & _
    "MIN" & vbTab & "#TIME" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & "#RECOVERY" & _
     vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & "ZMES" & vbTab & vbTab & vbTab & vbTab & "NO" & _
     vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & "X" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab

Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
(ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal _
lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long

Private Type TestInfo
    ProcessID As String 'key
    ProcessName As String 'desc
    time As Integer 'a-time
    TangoID As String 'tango
    TextKeyDesc As String 'desc
    TextKeyID As String 'sap
    
    ProcName As String
    
    Operation As Integer 'calc
    startTime As Integer 'calc
    EndTime As Integer 'calc
    
    Task As String 'unique generated key
    TaskDesc As String  'recovery scenario
    
    WorkCenter As String 'default "TEST"
    Tools As String 'default ""
End Type

Private Type tHeaderRecord
    Release As String
    PatchLevel As String
    MachineType As String
    recovery As String
    serviceaction As String
    Version As String
    Modified As Boolean
    Configuration As String
    Status As String
    Published As String
    StartStep As String
    StopStep As String
    Procedures As String
End Type

Public Sub CreateSapExport(inputfile As String, outputfile As String, Optional publishAlways As Boolean = False)

Dim fileInNo As Integer
Dim Key As String
Dim Value As String
Dim header As tHeaderRecord

' open inputfile
fileInNo = FreeFile()
Open inputfile For Input Access Read As fileInNo

Do While Not EOF(1)
    ' get the test id:
    Line Input #1, Key
        
    If Mid(Key, 1, 2) = "##" Or Mid(Key, 1, 2) = "$$" Then
        Key = Replace(Replace(SubString(Key, "|", 1), "##", ""), "$$", "")
        Value = SubString(Key, "|", 2)
        Call UpdateHeaderInfo(header, Key, Value)
    End If
Loop
               
Close #fileInNo

If (header.Published = "true" And (LCase(header.Status) = "reviewed" Or LCase(header.Status) = "tested")) Or publishAlways Then
    Call CreateSapExportFile(outputfile)
End If

End Sub

Public Sub CreateSapExportFile(strSheetname As String, Optional outputfile As String = "")

Dim scn As String
Dim wsTK As Worksheet

Dim sequenceKey As String

Dim info As TestInfo
Dim Step As Integer

Dim fileInNo As Integer
Dim fileOutNo As Integer
    
' new
Dim fileROSNo As Integer
Dim filePRTNo As Integer
Dim PRTfile As String
Dim ROSfile As String
    
Dim strPlatformType As String

Dim Key As String
Dim silentmode As Boolean

Set wsTK = ActiveWorkbook.Sheets(strSheetname)

If Not IsSheet("Source") Then
    MsgBox "Cannot export to SAP format, source sheet not found.", vbOKOnly
    Exit Sub
End If

strPlatformType = GetPlatformType(Worksheets("Source").Cells(1, 1))

If outputfile = "" Then
    sequenceKey = UniqueSequenceKey
    outputfile = GetFileName(strResultDir & "\" & sequenceKey & ".txt")
    silentmode = False
Else
    silentmode = True
End If
    
If outputfile = "" Then
    Exit Sub
End If

ROSfile = Replace(outputfile, ".txt", "_ROS.txt")
PRTfile = Replace(outputfile, ".txt", "_PRTS.txT")
    
info.TaskDesc = GetScenario
    
' open outputfile
fileOutNo = FreeFile()
Open outputfile For Output As fileOutNo

fileROSNo = FreeFile()
Open ROSfile For Output As fileROSNo

filePRTNo = FreeFile()
Open PRTfile For Output As filePRTNo
    
ResetTestInfo info, True
info.Task = sequenceKey
 
Dim blnGrouped As Boolean
Dim sglATime As Single

Step = 0
 
' headers
Call WriteHeader(fileOutNo)
Print #fileROSNo, ROS_HeaderRow
Print #filePRTNo, PRT_HeaderRow
  
Dim intCurRowID As Integer
Dim intKeyCol As Integer
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long

On Error GoTo errCreateSapExportFile
intKeyCol = wsTK.Range("TestKey").Column
On Error GoTo 0

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow
If intKeyCol > 0 Then
    intCurRowID = lngStartRecRow
    Do
        intCurRowID = intCurRowID + 1
        If wsTK.Cells(intCurRowID, intKeyCol) <> "" And wsTK.Cells(intCurRowID, cHasSubtestsCol) <> "S" Then

' For grouped test, use summed duration + key from last subtest
            If wsTK.Cells(intCurRowID, cHasSubtestsCol) = "Y" Then
                blnGrouped = True
                sglATime = wsTK.Cells(intCurRowID, cATimeCol)
                Do
                    intCurRowID = intCurRowID + 1
                Loop Until wsTK.Cells(intCurRowID + 1, cHasSubtestsCol) <> "S"
            Else
                blnGrouped = False
            End If
                        
            Key = wsTK.Cells(intCurRowID, intKeyCol)                    ' Will be removed in future
                     
            If GetTestInfo(Key, wsTK, intCurRowID, info) Then

                If blnGrouped Then
                    info.time = sglATime
                End If
                
                Call WriteLine(fileOutNo, info)
                
                Print #fileROSNo, ROS_CreateRowString(info.Task, info.Operation, info.TextKeyID, info.time, info.TaskDesc)
                                    
                If Left(info.Task, 3) <> "AR#" Then
                    If info.TangoID <> "" And (info.TextKeyID) <> "" Then ' no procedure info for header/pseudo/dummy steps
                        Step = Step + 10
                        Print #filePRTNo, PRT_CreateRowString(info.Task, info.Operation, Step, info.TangoID)
                    ElseIf Left(info.TextKeyID, 3) <> "AR#" Then
                        Call MsgBox("Warning! Missing tango ID and/or SAP key for " & Key & ". SAP import may fail." & vbCrLf & "Send email with details to dl-setup-" & strPlatformType & ".", vbOKOnly, "File not saved")
                    End If
                End If
            Else
                Call MsgBox("Invalid key " & Key & " encountered. Send email with details to dl-setup-" & strPlatformType & ".", vbOKOnly, "File not saved")
                Print #fileOutNo, "Invalid key encountered, this line makes MEWT import impossible"
                Exit Do
            End If
        End If
    Loop Until wsTK.Cells(intCurRowID, intKeyCol) = "RECOVERY_FINISHED" Or intCurRowID > 1999
End If

Call WriteFooter(fileOutNo)

Close #fileOutNo
Close #fileROSNo
Close #filePRTNo
    
If Not silentmode Then
    ShellExecute 0&, vbNullString, outputfile, vbNullString, vbNullString, vbNormalFocus
End If

Exit Sub

errCreateSapExportFile:
MsgBox "SAP export failed - cannot find test key column."
intKeyCol = 0
Resume Next

End Sub

Public Function UniqueSequenceKey() As String

Dim user As String
Dim Timestamp As String

user = Environ("username")
Timestamp = Round(Timer / 10)

If Timestamp < 100 Then
    Timestamp = Timestamp + 100
End If

UniqueSequenceKey = UCase("ARE" + Left(user, 2) + Right(Timestamp, 3))

End Function

Private Function GetTestInfo(Key As String, wsRef As Worksheet, intRowNr As Integer, info As TestInfo) As Boolean

On Error Resume Next

GetTestInfo = True

If intRowNr > 0 Then
    With wsRef
        info.ProcessID = .Cells(intRowNr, cTestIDCol).Value
        info.ProcessName = .Cells(intRowNr, cTestNameCol).Value
        info.time = .Cells(intRowNr, cATimeCol).Value
        info.startTime = info.EndTime
        info.EndTime = info.startTime + info.time
        info.Operation = info.Operation + SapRowFactor
        info.TangoID = .Cells(intRowNr, cTangoCol).Value
        info.TextKeyDesc = info.ProcessName
        info.TextKeyID = .Cells(intRowNr, cSAPCol).Value
        
        info.ProcName = .Cells(intRowNr, cProcedureNameCol).Value
    End With
Else
    GetTestInfo = False
End If

End Function

Private Sub ResetTestInfo(info As TestInfo, blnResetStartEndTime As Boolean)

info.WorkCenter = "TEST"
info.Tools = ""
If blnResetStartEndTime Then
    info.startTime = 0
    info.EndTime = 0
    info.Operation = 0
End If
info.time = 0
info.ProcessName = "NA"
info.ProcName = "NA"
info.ProcessID = 0
info.TangoID = "NA"
info.TextKeyDesc = "NA"
info.TextKeyID = 0

End Sub

Private Sub WriteHeader(fileNo As Integer)

Print #fileNo, "TASK ID" & vbTab & "Process step ID" & vbTab & "Process step name" & vbTab & "Operation Number" _
& vbTab & "Work Center" & vbTab & "Start Time [min]" & vbTab & "End Time [min]" & vbTab & "A-Time [min]" & vbTab & _
"Task List Description" & vbTab & "TangoID" & vbTab & "Tool(s)" & vbTab & "Text Key Description" & vbTab & "Text Key"

End Sub

Private Sub WriteLine(fileNo As Integer, info As TestInfo)

Print #fileNo, _
info.Task & _
vbTab & info.ProcessID & vbTab & info.ProcessName & vbTab & info.Operation & _
vbTab & info.WorkCenter & _
vbTab & info.startTime & vbTab & info.EndTime & vbTab & info.time & _
vbTab & info.TaskDesc & vbTab & info.TangoID & vbTab & info.Tools & _
vbTab & info.TextKeyDesc & vbTab & info.TextKeyID & vbTab & info.ProcName

End Sub

Private Sub WriteFooter(fileNo As Integer)
 
Print #fileNo, "*TRACE INFO (Takted Sequence)"
Print #fileNo, "Date of creation: " & date
Print #fileNo, "User who created it: ARE-MEWT/SAP export"
Print #fileNo, "ROS ID: dummy"
Print #fileNo, "Takt Duration: dummy"
Print #fileNo, "C-Time: dummy"
Print #fileNo, "Extra Process Added:"
Print #fileNo, "Takt Calculation Method: dummy"
Print #fileNo, "File used: dummy.pbp"
Print #fileNo, "*TRACE INFO (Optimum Sequence)"
Print #fileNo, "Type of sequence: dummy"
Print #fileNo, "WOW: dummy"
Print #fileNo, "Sorting Criterias used: dummy"
Print #fileNo, "File used: dummy.pbp"

End Sub

Private Function GetFileName(suggestedFile As String) As String
Dim file_name As Variant

' Get the file name.
file_name = Application.GetSaveAsFilename( _
    InitialFileName:=suggestedFile, _
    FileFilter:="TXT Files,*.txt", _
    title:="Save As File Name")
        

' See if the user canceled.
If file_name = False Then
    GetFileName = ""
    Exit Function
Else
    If LCase$(Right$(file_name, 4)) <> ".txt" Then
        file_name = file_name & ".txt"
    End If
    
    GetFileName = file_name
End If

End Function

'Sub UpdateHeaderInfo(myheader As tHeaderRecord, Key As String, value As String)

'Select Case LCase(Key)
'    Case "areversion"
'        myheader.Version = value
'    Case "recovery"
'        myheader.Recovery = value
'    Case "machinetype"
'        myheader.MachineType = value
'    Case "configuration"
'        myheader.Configuration = value
'    Case "swrelease"
'        myheader.Release = value
'    Case "patchlevel"
'        myheader.PatchLevel = value
'    Case "status"
'        myheader.Status = value
'    Case "startstep"
'        myheader.StartStep = value
'    Case "stopstep"
'        myheader.StopStep = value
'    Case "published"
'        myheader.Published = LCase(value)
'    Case Else
'        Debug.Print "IGNORED: ", key, " = ", value
'End Select

'End Sub

Function PRT_CreateRowString(Id As String, Step As Integer, prt_step As Integer, tango As String) As String

PRT_CreateRowString = PRT_DefaultRow
PRT_CreateRowString = Replace(PRT_CreateRowString, "#PLNNR", Id)
PRT_CreateRowString = Replace(PRT_CreateRowString, "#VORNR", CStr(Step))
PRT_CreateRowString = Replace(PRT_CreateRowString, "#PSNFH", CStr(prt_step))
PRT_CreateRowString = Replace(PRT_CreateRowString, "#DOKNR", tango)

End Function

Function ROS_CreateRowString(Id As String, Step As Integer, Key As String, time As Integer, recovery As String) As String

ROS_CreateRowString = ROS_DefaultRow
ROS_CreateRowString = Replace(ROS_CreateRowString, "#PLNNR", Id)
ROS_CreateRowString = Replace(ROS_CreateRowString, "#VORNR", CStr(Step))
ROS_CreateRowString = Replace(ROS_CreateRowString, "#KEY", Key)
ROS_CreateRowString = Replace(ROS_CreateRowString, "#TIME", CStr(time))
ROS_CreateRowString = Replace(ROS_CreateRowString, "#RECOVERY", recovery)

End Function

Private Function GetScenario() As String

Dim intCurRowID As Integer
Dim strTxt As String

intCurRowID = 1

Do While Worksheets("Source").Cells(intCurRowID, 1) <> ""
    strTxt = Worksheets("Source").Cells(intCurRowID, 1)
    If InStr(strTxt, "AUTOMATIC GENERATED RECOVERY") > 0 Then
        GetScenario = Trim(Mid(strTxt, InStr(strTxt, ":") + 1))
        Exit Function
    End If
    intCurRowID = intCurRowID + 1
Loop

GetScenario = ""

End Function






Attribute VB_Name = "modSendComments"
Option Explicit

Public blnOK As Boolean

Private Type COMMENTS_MAPPING
    subsystem As String
    coach_name As String
    moid As Long
    section_id As Long
End Type

Private Const mcSEPERATOR As String = "#"

Private marrCommentsMappings() As COMMENTS_MAPPING

'---------------------------------------------------------------------------------------
' Procedure : OpenCommentsForm
' Author    : micbrouw
' Date      : 2015, jun 22
' Purpose   : Open the comments dialog, fill in the options and compose the email to send.
'---------------------------------------------------------------------------------------
'
Public Sub OpenCommentsForm()
    Dim strAreVersion As String
    Dim strSequence As String
    Dim strServiceAction As String
    Dim strMachType As String
    Dim strConfiguration As String
    Dim strSWRelease As String
    Dim strModule As String
    Dim strId As String
    Dim strSectionID As String
    Dim strProcedureName As String
    Dim strTKSheet As String
    Dim strProcedureDestination As String
    Dim strSubsystem As String
    Dim strPlatform As String
    Dim strBody As String
    Dim iSubsystemCmbIndex As Integer
    Dim objCommentsMapping As COMMENTS_MAPPING
    Dim OutApp As Object
    Dim OutMail As Object
    Dim strPlatformType As String

    Load frmHandleComments

    strPlatform = GetPlatformType(Worksheets("Source").Cells(1, 1))
    InitCommentsMapping strPlatform

    With frmHandleComments.cmbCommentType
        .Clear
        .AddItem "Typographical"
        .AddItem "Configurational"
        .AddItem "Technical"
    End With

    frmHandleComments.Show vbModal

    If blnOK Then
        iSubsystemCmbIndex = frmHandleComments.cmbSubsystems.ListIndex
        objCommentsMapping = marrCommentsMappings(iSubsystemCmbIndex)

        strAreVersion = "ARE version " & Range("areversion") & " / TK sheet " & Range("TKVersion")
        strSequence = Range("recovery")
        strServiceAction = Range("serviceaction")
        strMachType = Range("machinetype")
        strConfiguration = Range("configuration")
        strSWRelease = Range("swrelease")

        strConfiguration = strAreVersion & vbCrLf & _
            strSequence & vbCrLf & _
            strServiceAction & vbCrLf & _
            strMachType & vbCrLf & _
            strSWRelease & vbCrLf & _
            Replace$(strConfiguration, "; ", vbCrLf)

        strTKSheet = GetTKSequence

        strBody = "Filename = " & objCommentsMapping.coach_name & vbCrLf & _
            "Id = " & marrCommentsMappings(iSubsystemCmbIndex).moid & vbCrLf & _
            "Date = " & Format$(date + time, "mmm dd hh:mm:ss yyyy") & vbCrLf & _
            "Section Id = " & objCommentsMapping.section_id & vbCrLf & vbCrLf & _
            "My department = other" & vbCrLf & _
            "Machine type = " & Range("machinetype").Value & vbCrLf & _
            "Machine number = " & frmHandleComments.txtCommentsMachineNr.Text & vbCrLf & _
            "Software version = " & Range("swrelease") & vbCrLf & _
            "Subsystem = " & UCase$(objCommentsMapping.subsystem) & vbCrLf & _
            "Comment type = " & frmHandleComments.cmbCommentType.Text & vbCrLf & vbCrLf & _
            "Configuration = " & vbCrLf & strConfiguration & vbCrLf & vbCrLf & _
            "What is wrong = " & vbCrLf & frmHandleComments.txtCommentsProblem.Text & vbCrLf & vbCrLf & _
            "Contents = " & vbCrLf & strTKSheet

        Set OutApp = CreateObject("Outlook.Application")
        OutApp.Session.Logon
        Set OutMail = OutApp.CreateItem(0)

        If strPlatform = "YS" Then
            strPlatformType = "[Yieldstar]"
        Else
            strPlatformType = "[Twin]"
        End If
        
        With OutMail
            .To = "comments-prd@asml.com"
            .CC = ""
            .Subject = strPlatformType & " Comment on " & objCommentsMapping.coach_name
            .Body = strBody
            .BodyFormat = 1
            .Display
        End With

        Set OutMail = Nothing
        Set OutApp = Nothing
    End If

    Unload frmHandleComments
End Sub

'---------------------------------------------------------------------------------------
' Procedure : InitCommentsMapping
' Author    : micbrouw
' Date      : 2015, jun 22
' Purpose   : Initialize the comments mapping file, located in: \ARE\shared\comments_mapping.xml.
'---------------------------------------------------------------------------------------
'
Private Sub InitCommentsMapping(ByVal platform As String)
    Dim dom As DOMDocument60
    Dim eltMapping As IXMLDOMElement
    Dim eltMappings As IXMLDOMNodeList
    Dim eltEntries As IXMLDOMNodeList

    Dim strId As String
    Dim strSubsystem As String
    Dim strCoachName As String
    Dim lngMoid As Long
    Dim iMapping As Integer
    Dim iEntry As Integer

    On Error Resume Next

    'Set dom = New DOMDocument60
    'dom.Load "comments_mapping.xml"
    Set dom = CreateCommentsMappingXml
    
    ReDim marrCommentsMappings(0)

    Set eltMappings = dom.SelectNodes(".//index/mappings/mapping[platform='" & platform & "']")
    For iMapping = 0 To eltMappings.Length - 1
        Set eltMapping = eltMappings.Item(iMapping)
        strId = eltMapping.getAttribute("id")

        Set eltEntries = dom.SelectNodes(".//index/procedures[@mapping='" & strId & "']/entry")
        ReDim Preserve marrCommentsMappings(UBound(marrCommentsMappings) + eltEntries.Length)

        For iEntry = 0 To eltEntries.Length - 1
            strSubsystem = eltEntries.Item(iEntry).SelectSingleNode("subsystem").Text
            strCoachName = eltEntries.Item(iEntry).SelectSingleNode("coach_name").Text
            lngMoid = CLng(eltEntries.Item(iEntry).SelectSingleNode("moid").Text)

            marrCommentsMappings(frmHandleComments.cmbSubsystems.ListCount) = CreateCommentsMappingObj(strSubsystem, strCoachName, lngMoid)
            frmHandleComments.cmbSubsystems.AddItem strSubsystem
        Next iEntry
    Next iMapping

    With frmHandleComments.cmbSubsystems
        If .ListCount = 0 Then
            .AddItem "Failed to determine subsystem"
            .ListIndex = 0
            .Enabled = False
        End If
    End With

    Set dom = Nothing
End Sub

'---------------------------------------------------------------------------------------
' Procedure : CreateCommentsMappingObj
' Author    : micbrouw
' Date      : 2015, jun 22
' Purpose   : Create a comments mapping object.
'---------------------------------------------------------------------------------------
'
Private Function CreateCommentsMappingObj(ByVal subsystem As String, ByVal coachName As String, ByVal lngMoid As Long) As COMMENTS_MAPPING
    Dim result As COMMENTS_MAPPING

    On Error Resume Next

    result.subsystem = subsystem
    result.coach_name = coachName
    result.moid = lngMoid
    result.section_id = lngMoid + 1

    CreateCommentsMappingObj = result
End Function

'---------------------------------------------------------------------------------------
' Procedure : GetTKSequence
' Author    : micbrouw
' Date      : 2015, jun 22
' Purpose   : Get the TKSequence string.
'---------------------------------------------------------------------------------------
'
Private Function GetTKSequence() As String
    Dim result As String

    Dim lngHeaderRow As Long
    Dim lngLastSeqRow As Long
    Dim lngStartRecRow As Long
    Dim intCurRow As Integer
    Dim strSheetname As String

    strSheetname = GetRecoverySheetName
    result = "B-factor: " & Worksheets(strSheetname).Range(fCell(cA2BFactorRow, cPlannedTimeCol))

    FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

    For intCurRow = lngHeaderRow + 1 To lngLastSeqRow
        result = result & _
            vbCrLf & mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cProcedureNameCol) & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cTestNameCol) & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cCommentsProcedureCol) & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cTestExecCol) & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cProjectCol) & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cTestIDCol) & _
            mcSEPERATOR & Replace$(Worksheets(strSheetname).Cells(intCurRow, cPerChuckCol), " ", "_") & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cSAPCol) & _
            mcSEPERATOR & Worksheets(strSheetname).Cells(intCurRow, cATimeCol) & mcSEPERATOR
    Next intCurRow

    GetTKSequence = result
End Function

'---------------------------------------------------------------------------------------
' Procedure : CreateCommentsMappingXml
' Author    : micbrouw
' Date      : 2015, jun 24
' Purpose   : Create the comments_mapping.xml file in memory.
'---------------------------------------------------------------------------------------
'
Private Function CreateCommentsMappingXml() As DOMDocument60
    Dim result As DOMDocument60

    Dim eltIndex As IXMLDOMElement
    Dim eltProcedures As IXMLDOMElement
    Dim eltEntry As IXMLDOMElement
    Dim eltMappings As IXMLDOMElement
    Dim eltMapping As IXMLDOMElement

    Set result = CreateDOM

    Set eltIndex = CreateXMLElement(result, Nothing, "index", "")
    
    'SOER3
    

    ' Procedure mapping 1
    Set eltProcedures = CreateXMLElement(result, eltIndex, "procedures", "")
    eltProcedures.setAttribute "mapping", "1"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Alignment"
    CreateXMLElement result, eltEntry, "coach_name", "eal001.rec"
    CreateXMLElement result, eltEntry, "moid", "8107708"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Airmounts"
    CreateXMLElement result, eltEntry, "coach_name", "eam003.rec"
    CreateXMLElement result, eltEntry, "moid", "8107782"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: C&T"
    CreateXMLElement result, eltEntry, "coach_name", "ecc001.rec"
    CreateXMLElement result, eltEntry, "moid", "8107794"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Dose Control"
    CreateXMLElement result, eltEntry, "coach_name", "edc004.rec"
    CreateXMLElement result, eltEntry, "moid", "8107801"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: El"
    CreateXMLElement result, eltEntry, "coach_name", "eel005.rec"
    CreateXMLElement result, eltEntry, "moid", "8107809"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Illumination"
    CreateXMLElement result, eltEntry, "coach_name", "eil003.rec"
    CreateXMLElement result, eltEntry, "moid", "8107816"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: H2-Safety"
    CreateXMLElement result, eltEntry, "coach_name", "evs034.rec"
    CreateXMLElement result, eltEntry, "moid", "8107823"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Ilias"
    CreateXMLElement result, eltEntry, "coach_name", "ezk001.rec"
    CreateXMLElement result, eltEntry, "moid", "8107837"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Level Sensor / Uv-Ls"
    CreateXMLElement result, eltEntry, "coach_name", "els001.rec"
    CreateXMLElement result, eltEntry, "moid", "8107852"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Setup Me: Leveling"
    CreateXMLElement result, eltEntry, "coach_name", "eme003.rec"
    CreateXMLElement result, eltEntry, "moid", "8107859"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Metrology"
    CreateXMLElement result, eltEntry, "coach_name", "eme004.rec"
    CreateXMLElement result, eltEntry, "moid", "8107876"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Optics Life-Time"
    CreateXMLElement result, eltEntry, "coach_name", "eol001.rec"
    CreateXMLElement result, eltEntry, "moid", "8107888"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Preventive Maintenance"
    CreateXMLElement result, eltEntry, "coach_name", "esy004.rec"
    CreateXMLElement result, eltEntry, "moid", "8107894"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Projection"
    CreateXMLElement result, eltEntry, "coach_name", "epr002.rec"
    CreateXMLElement result, eltEntry, "moid", "8107902"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Qualification"
    CreateXMLElement result, eltEntry, "coach_name", "esy006.rec"
    CreateXMLElement result, eltEntry, "moid", "8109332"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Reticle Handling"
    CreateXMLElement result, eltEntry, "coach_name", "erh009.rec"
    CreateXMLElement result, eltEntry, "moid", "8107920"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Reticle Masking"
    CreateXMLElement result, eltEntry, "coach_name", "erm001.rec"
    CreateXMLElement result, eltEntry, "moid", "8107937"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Reticle Stage"
    CreateXMLElement result, eltEntry, "coach_name", "ers012.rec"
    CreateXMLElement result, eltEntry, "moid", "8108007"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Spm"
    CreateXMLElement result, eltEntry, "coach_name", "epm001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108015"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Tis"
    CreateXMLElement result, eltEntry, "coach_name", "eal002.rec"
    CreateXMLElement result, eltEntry, "moid", "8108028"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Vacuum Systems"
    CreateXMLElement result, eltEntry, "coach_name", "evs035.rec"
    CreateXMLElement result, eltEntry, "moid", "8108043"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Wafer Handling"
    CreateXMLElement result, eltEntry, "coach_name", "ewh001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108049"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: Wafer Stage"
    CreateXMLElement result, eltEntry, "coach_name", "ews001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108065"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Scanner: System Level"
    CreateXMLElement result, eltEntry, "coach_name", "esy005.rec"
    CreateXMLElement result, eltEntry, "moid", "8108080"

    ' Procedure mapping 2
    Set eltProcedures = CreateXMLElement(result, eltIndex, "procedures", "")
    eltProcedures.setAttribute "mapping", "2"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Beam Transport And Focusing"
    CreateXMLElement result, eltEntry, "coach_name", "gbt004.rec"
    CreateXMLElement result, eltEntry, "moid", "8108197"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Computer System"
    CreateXMLElement result, eltEntry, "coach_name", "gcs002.rec"
    CreateXMLElement result, eltEntry, "moid", "8108215"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Contamination Control"
    CreateXMLElement result, eltEntry, "coach_name", "gcc002.rec"
    CreateXMLElement result, eltEntry, "moid", "8108232"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Drivelaser"
    CreateXMLElement result, eltEntry, "coach_name", "gdl010.rec"
    CreateXMLElement result, eltEntry, "moid", "8108265"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Droplet Generation"
    CreateXMLElement result, eltEntry, "coach_name", "gdg013.rec"
    CreateXMLElement result, eltEntry, "moid", "8108284"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Droplet Steering"
    CreateXMLElement result, eltEntry, "coach_name", "gds001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108292"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Electrical Layout"
    CreateXMLElement result, eltEntry, "coach_name", "gel001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108314"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Euv Collection"
    CreateXMLElement result, eltEntry, "coach_name", "gec003.rec"
    CreateXMLElement result, eltEntry, "moid", "8108329"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Flow And Temperature Control"
    CreateXMLElement result, eltEntry, "coach_name", "gft002.rec"
    CreateXMLElement result, eltEntry, "moid", "8108339"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: General Maintenance"
    CreateXMLElement result, eltEntry, "coach_name", "ggm006.rec"
    CreateXMLElement result, eltEntry, "moid", "8108351"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Handling And Transport"
    CreateXMLElement result, eltEntry, "coach_name", "ght001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108365"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Mechanical Layout"
    CreateXMLElement result, eltEntry, "coach_name", "gml001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108374"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Plasma Generation"
    CreateXMLElement result, eltEntry, "coach_name", "gpg008.rec"
    CreateXMLElement result, eltEntry, "moid", "8139105"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Seed Module"
    CreateXMLElement result, eltEntry, "coach_name", "gsm003.rec"
    CreateXMLElement result, eltEntry, "moid", "8108400"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Source: Vacuum System"
    CreateXMLElement result, eltEntry, "coach_name", "gvs019.rec"
    CreateXMLElement result, eltEntry, "moid", "8108442"

    ' Procedure mapping 3
    Set eltProcedures = CreateXMLElement(result, eltIndex, "procedures", "")
    eltProcedures.setAttribute "mapping", "3"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Alignment"
    CreateXMLElement result, eltEntry, "coach_name", "cal001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108872"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Dynamics"
    CreateXMLElement result, eltEntry, "coach_name", "cam001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108891"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Applications"
    CreateXMLElement result, eltEntry, "coach_name", "cap001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108908"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Contamination & Temperature control"
    CreateXMLElement result, eltEntry, "coach_name", "ccc001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108914"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Dose control"
    CreateXMLElement result, eltEntry, "coach_name", "cdc002.rec"
    CreateXMLElement result, eltEntry, "moid", "8108928"
    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")

    CreateXMLElement result, eltEntry, "subsystem", "Dose control (Reticle Masking)"
    CreateXMLElement result, eltEntry, "coach_name", "cdc003.rec"
    CreateXMLElement result, eltEntry, "moid", "8108953"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Dose control (Laser)"
    CreateXMLElement result, eltEntry, "coach_name", "cdc004.rec"
    CreateXMLElement result, eltEntry, "moid", "8108961"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Immersion"
    CreateXMLElement result, eltEntry, "coach_name", "cih011.rec"
    CreateXMLElement result, eltEntry, "moid", "8108988"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Illumination"
    CreateXMLElement result, eltEntry, "coach_name", "cil004.rec"
    CreateXMLElement result, eltEntry, "moid", "8108996"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Image Sensor"
    CreateXMLElement result, eltEntry, "coach_name", "cis002.rec"
    CreateXMLElement result, eltEntry, "moid", "8109032"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Level Sensor"
    CreateXMLElement result, eltEntry, "coach_name", "cls001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109042"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Image Quality"
    CreateXMLElement result, eltEntry, "coach_name", "cme034.rec"
    CreateXMLElement result, eltEntry, "moid", "8109062"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Image Align"
    CreateXMLElement result, eltEntry, "coach_name", "cme035.rec"
    CreateXMLElement result, eltEntry, "moid", "8109077"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: grid"
    CreateXMLElement result, eltEntry, "coach_name", "cme036.rec"
    CreateXMLElement result, eltEntry, "moid", "8109084"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Leveling"
    CreateXMLElement result, eltEntry, "coach_name", "cme037.rec"
    CreateXMLElement result, eltEntry, "moid", "8109097"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Wafer Align"
    CreateXMLElement result, eltEntry, "coach_name", "cme038.rec"
    CreateXMLElement result, eltEntry, "moid", "8109104"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Stage Position Measurement"
    CreateXMLElement result, eltEntry, "coach_name", "cpm002.rec"
    CreateXMLElement result, eltEntry, "moid", "8109111"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Projection"
    CreateXMLElement result, eltEntry, "coach_name", "cpr003.rec"
    CreateXMLElement result, eltEntry, "moid", "8109127"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "PARIS"
    CreateXMLElement result, eltEntry, "coach_name", "cpi001.rec"
    CreateXMLElement result, eltEntry, "moid", "8143183"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Reticle Handler"
    CreateXMLElement result, eltEntry, "coach_name", "crh001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109158"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Reticle Stage"
    CreateXMLElement result, eltEntry, "coach_name", "crs003.rec"
    CreateXMLElement result, eltEntry, "moid", "8109166"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "System Level"
    CreateXMLElement result, eltEntry, "coach_name", "csy001.rec"
    CreateXMLElement result, eltEntry, "moid", "2286257"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Preventive Maintenance"
    CreateXMLElement result, eltEntry, "coach_name", "csy004.rec"
    CreateXMLElement result, eltEntry, "moid", "8109188"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Wafer Handler"
    CreateXMLElement result, eltEntry, "coach_name", "cwh001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109271"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Wafer Stage: Position Module"
    CreateXMLElement result, eltEntry, "coach_name", "cws143.rec"
    CreateXMLElement result, eltEntry, "moid", "8109280"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Wafer Stage: Base Module"
    CreateXMLElement result, eltEntry, "coach_name", "cws144.rec"
    CreateXMLElement result, eltEntry, "moid", "8109290"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Wafer Stage: Wafer Table"
    CreateXMLElement result, eltEntry, "coach_name", "cws145.rec"
    CreateXMLElement result, eltEntry, "moid", "8109299"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "ILIAS"
    CreateXMLElement result, eltEntry, "coach_name", "czk001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109315"

    ' Procedure mapping 4
    Set eltProcedures = CreateXMLElement(result, eltIndex, "procedures", "")
    eltProcedures.setAttribute "mapping", "4"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Alignment"
    CreateXMLElement result, eltEntry, "coach_name", "cal001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108872"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Dynamics"
    CreateXMLElement result, eltEntry, "coach_name", "cam001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108891"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Applications"
    CreateXMLElement result, eltEntry, "coach_name", "cap001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108908"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Contamination & Temperature control"
    CreateXMLElement result, eltEntry, "coach_name", "ccc001.rec"
    CreateXMLElement result, eltEntry, "moid", "8108914"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Dose control"
    CreateXMLElement result, eltEntry, "coach_name", "cdc002.rec"
    CreateXMLElement result, eltEntry, "moid", "8108928"
    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")

    CreateXMLElement result, eltEntry, "subsystem", "Dose control (Reticle Masking)"
    CreateXMLElement result, eltEntry, "coach_name", "cdc003.rec"
    CreateXMLElement result, eltEntry, "moid", "8108953"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Dose control (Laser)"
    CreateXMLElement result, eltEntry, "coach_name", "cdc004.rec"
    CreateXMLElement result, eltEntry, "moid", "8108961"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Immersion"
    CreateXMLElement result, eltEntry, "coach_name", "cih011.rec"
    CreateXMLElement result, eltEntry, "moid", "8108988"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Illumination"
    CreateXMLElement result, eltEntry, "coach_name", "cil004.rec"
    CreateXMLElement result, eltEntry, "moid", "8108996"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Image Sensor"
    CreateXMLElement result, eltEntry, "coach_name", "cis002.rec"
    CreateXMLElement result, eltEntry, "moid", "8109032"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Level Sensor"
    CreateXMLElement result, eltEntry, "coach_name", "cls001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109042"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Image Quality"
    CreateXMLElement result, eltEntry, "coach_name", "cme034.rec"
    CreateXMLElement result, eltEntry, "moid", "8109062"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Image Align"
    CreateXMLElement result, eltEntry, "coach_name", "cme035.rec"
    CreateXMLElement result, eltEntry, "moid", "8109077"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: grid"
    CreateXMLElement result, eltEntry, "coach_name", "cme036.rec"
    CreateXMLElement result, eltEntry, "moid", "8109084"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Leveling"
    CreateXMLElement result, eltEntry, "coach_name", "cme037.rec"
    CreateXMLElement result, eltEntry, "moid", "8109097"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Metrology: Wafer Align"
    CreateXMLElement result, eltEntry, "coach_name", "cme038.rec"
    CreateXMLElement result, eltEntry, "moid", "8109104"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Stage Position Measurement"
    CreateXMLElement result, eltEntry, "coach_name", "cpm002.rec"
    CreateXMLElement result, eltEntry, "moid", "8109111"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Projection"
    CreateXMLElement result, eltEntry, "coach_name", "cpr003.rec"
    CreateXMLElement result, eltEntry, "moid", "8109127"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "PARIS"
    CreateXMLElement result, eltEntry, "coach_name", "cpi001.rec"
    CreateXMLElement result, eltEntry, "moid", "8143183"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Reticle Handler"
    CreateXMLElement result, eltEntry, "coach_name", "crh001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109158"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Reticle Stage"
    CreateXMLElement result, eltEntry, "coach_name", "crs003.rec"
    CreateXMLElement result, eltEntry, "moid", "8109166"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "System Level"
    CreateXMLElement result, eltEntry, "coach_name", "csy001.rec"
    CreateXMLElement result, eltEntry, "moid", "2286257"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Preventive Maintenance"
    CreateXMLElement result, eltEntry, "coach_name", "csy004.rec"
    CreateXMLElement result, eltEntry, "moid", "8109188"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Wafer Handler"
    CreateXMLElement result, eltEntry, "coach_name", "cwh001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109271"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Short Stroke Module"
    CreateXMLElement result, eltEntry, "coach_name", "cws143.rec"
    CreateXMLElement result, eltEntry, "moid", "8109280"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Long Stroke Module"
    CreateXMLElement result, eltEntry, "coach_name", "cws144.rec"
    CreateXMLElement result, eltEntry, "moid", "8109290"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "Wafer Stage: Wafer Table"
    CreateXMLElement result, eltEntry, "coach_name", "cws145.rec"
    CreateXMLElement result, eltEntry, "moid", "8109299"

    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "ILIAS"
    CreateXMLElement result, eltEntry, "coach_name", "czk001.rec"
    CreateXMLElement result, eltEntry, "moid", "8109315"
    
    'mapping for yieldstar
    Set eltProcedures = CreateXMLElement(result, eltIndex, "procedures", "")
    eltProcedures.setAttribute "mapping", "5"
    
    Set eltEntry = CreateXMLElement(result, eltProcedures, "entry", "")
    CreateXMLElement result, eltEntry, "subsystem", "System Level"
    CreateXMLElement result, eltEntry, "coach_name", "fsy001.rec"
    CreateXMLElement result, eltEntry, "moid", "19305543"

    Set eltMappings = CreateXMLElement(result, eltIndex, "mappings", "")

    ' Platform mapping 1
    Set eltMapping = CreateXMLElement(result, eltMappings, "mapping", "")
    eltMapping.setAttribute "id", "1"
    CreateXMLElement result, eltMapping, "platform", "NXE"

    ' Platform mapping 2
    Set eltMapping = CreateXMLElement(result, eltMappings, "mapping", "")
    eltMapping.setAttribute "id", "2"
    CreateXMLElement result, eltMapping, "platform", "NXE"
    CreateXMLElement result, eltMapping, "platform", "SRC"

    ' Platform mapping 3
    Set eltMapping = CreateXMLElement(result, eltMappings, "mapping", "")
    eltMapping.setAttribute "id", "3"
    CreateXMLElement result, eltMapping, "platform", "NXT3"
    CreateXMLElement result, eltMapping, "platform", "NXT"

    ' Platform mapping 4
    Set eltMapping = CreateXMLElement(result, eltMappings, "mapping", "")
    eltMapping.setAttribute "id", "4"
    CreateXMLElement result, eltMapping, "platform", "XT"
    
    ' Yieldstar platform mapping
    Set eltMapping = CreateXMLElement(result, eltMappings, "mapping", "")
    eltMapping.setAttribute "id", "5"
    CreateXMLElement result, eltMapping, "platform", "YS"
    

    Set CreateCommentsMappingXml = result
End Function

'---------------------------------------------------------------------------------------
' Procedure : CreateDOM
' Author    : micbrouw
' Date      : 2015, jun 24
' Purpose   : Create a new XML document object.
'---------------------------------------------------------------------------------------
'
Private Function CreateDOM()
    Dim dom, node
    Set dom = New DOMDocument60
    dom.Async = False
    dom.validateOnParse = False
    dom.resolveExternals = False
    dom.preserveWhiteSpace = True
    Set node = dom.createProcessingInstruction("xml", "version='1.0' encoding='UTF-8'")
    dom.appendChild node
    Set node = Nothing
    Set CreateDOM = dom
End Function

'---------------------------------------------------------------------------------------
' Procedure : CreateXMLElement
' Author    : micbrouw
' Date      : 2015, jun 24
' Purpose   : Create a new XML element.
'---------------------------------------------------------------------------------------
'
Private Function CreateXMLElement(xmlDoc As DOMDocument60, Parent As IXMLDOMNode, Name As String, Value As String, Optional ns As String = "") As IXMLDOMElement
    Dim element As IXMLDOMElement

    Set element = xmlDoc.createNode(NODE_ELEMENT, Name, ns)

    ' Add the text if it has any
    If Value <> "" Then
        element.Text = Value
    End If

    ' Add the node to the document
    If Parent Is Nothing Then
        Set xmlDoc.DocumentElement = element
    Else
        Parent.appendChild element
    End If

    Set CreateXMLElement = element
    Set element = Nothing
End Function
Attribute VB_Name = "modTimeKeeperAnalysis"
Sub MakeGraph()

' Purpose: create a graph with:
' - time line on horizontal axis
' - % completed on vertical axis
' - A-time based plan
' - Original plan
' - Actual plan
' - TimeKeeper balloons indicating specific entries in the sequence

Dim lngHeaderRow As Long
Dim intTKPlannedFinishCol As Integer
Dim intTKActualFinishCol As Integer
Dim intTKProcStepCol As Integer
Dim intTKProcCumCol As Integer
Dim intTKBalloonTitleCol As Integer
Dim intTKPlannedLastRow As Integer
Dim intTKActualLastRow As Integer
Dim dblFirstFinishOffset As Double
Dim blnExists As Boolean
Dim i As Integer
Dim strSheetname As String

strSheetname = ActiveSheet.Name

Application.Calculation = xlAutomatic

Dim strStartCell As String

strStartCell = fCell(cStartTimeRow, cPlannedTimeCol)
If Worksheets(strSheetname).Range(strStartCell) = "" Then
    If MsgBox("The start time (cell " & strStartCell & ") has not been given." & Chr(13) & _
        "The horizontal graph axis will be incorrect. Continue anyway?", vbYesNo) = vbNo Then
        Exit Sub
    End If
End If

'Generate constants (find data)
Application.ScreenUpdating = False

Sheets(strSheetname).Select

lngHeaderRow = -1

FindTKColumn strSheetname, "Expected Plan", intTKPlannedFinishCol, lngHeaderRow, True, "timeline graph"
FindTKColumn strSheetname, "Actual finish", intTKActualFinishCol, lngHeaderRow, True, "timeline graph"
FindTKColumn strSheetname, "% step", intTKProcStepCol, lngHeaderRow, True, "timeline graph"
FindTKColumn strSheetname, "% cum.", intTKProcCumCol, lngHeaderRow, True, "timeline graph"
FindTKColumn strSheetname, "Time keeper balloon title", intTKBalloonTitleCol, lngHeaderRow, True, "timeline graph"

intTKPlannedLastRow = Cells(10000, intTKPlannedFinishCol).End(xlUp).row
intTKActualLastRow = Cells(10000, intTKActualFinishCol).End(xlUp).row

'Generate datasheet ("Graph")
On Error Resume Next
Sheets("Graph").Visible = True
'blnExists = Sheets("Graph").Range("a1")
If err.Number = 0 Then                                                              'if sheet exists, select it
'    Sheets("Graph").Visible = True
    Sheets("Graph").Select
    Worksheets("Graph").Range("A1:K" & intTKPlannedLastRow).Clear
Else                                                                                'if sheet does not exist, make it
    Sheets.Add.Name = "Graph"
End If
 
With Worksheets("Graph")
'Make header
    .Range("A1").FormulaR1C1 = "Start time"
    .Range("B1").FormulaR1C1 = "Expected Plan (B)"
    .Range("E1").FormulaR1C1 = "Actual Finish"
    .Range("C1,F1").FormulaR1C1 = "% step"
    .Range("D1,G1").FormulaR1C1 = "% cum."
    .Range("A1:G1").Font.FontStyle = "Bold"
 
'Copy data from TimeKeeper sheet
    .Range("A3").Formula = "=Value('" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKPlannedFinishCol) & ")"
    .Range("B3").Formula = "=Value('" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKPlannedFinishCol) & ")"
    .Range("C3").Formula = "=Value('" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKProcStepCol) & ")"
    .Range("D3").Formula = "=D2+C3"
    .Range("E3").Formula = "=Value('" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKActualFinishCol) & ")"
    .Range("F3").Formula = "=Value('" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKProcStepCol) & ")"
    .Range("G3").Formula = "=G2+F3"
' Is column I needed? It contains the same information as column E.
    .Range("I3").Formula = "=Value('" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKActualFinishCol) & ")"
    .Range("J3").Formula = "='" & strSheetname & "'!" & fCell(lngHeaderRow + 1, intTKBalloonTitleCol)

' Extend table to cover all TimeKeeper rows
    .Range("A3:J3").AutoFill Destination:=.Range("A3:J" & intTKPlannedLastRow - lngHeaderRow + 2), Type:=xlFillDefault

' Replace formulae by values, except for column G, which must be recalculated after sorting the information
    .Columns("A:F").Copy:     .Columns("A:F").PasteSpecial Paste:=xlPasteValues
    .Columns("I:J").Copy:     .Columns("I:J").PasteSpecial Paste:=xlPasteValues

' Remove all #VALUE! entries, since they will disturb the graph. Replace by empty cells.
    .Columns("B:J").Replace What:="#VALUE!", Replacement:=""
    
' Determine last rows for the GRAPH sheet
    intTKPlannedLastRow = .Cells(10000, 2).End(xlUp).row                                          'Last row of Original plan
    intTKActualLastRow = .Cells(1000, 5).End(xlUp).row                                           'Last row of Actual Finish

' Remove all zero's in the time keeper balloon column.
    Application.Calculation = xlCalculationManual
    ReplaceExact 3, 10, CLng(intTKActualLastRow), 10, 0, ""
    Application.Calculation = xlCalculationAutomatic

' In column E replace all zero's by a 'very large number'
    ReplaceExact 3, 5, CLng(intTKActualLastRow), 5, 0, 99999
    
' Sort data for actual time line
    .Range("E3:J" & intTKActualLastRow).Select:     Selection.Sort Key1:=.Range("E3"), Order1:=xlAscending
'    .Range("I3:J" & intTKActualLastRow).Select:     Selection.Sort Key1:=.Range("I3"), Order1:=xlAscending
    
' Now remove all entries with 'very large number' in column E
    ReplaceExact 3, 5, CLng(intTKActualLastRow), 5, 99999, ""

' Re-determine the last row number for column E
    intTKActualLastRow = .Cells(1000, 5).End(xlUp).row
    
' Set formatting
    .Range("A:A,B:B,E:E,I:I").NumberFormat = "d-mmm-yy hh:mm"
    .Range("C:C,D:D,F:F,G:G").NumberFormat = "0.0"

    Application.Calculation = xlCalculationManual
    
' Now make the information in A, B and E start at the same time (we are not interested in start delays)
' Calculate the actual finish offset of the first step
'    dblFirstFinishOffset = .Range("B3") - .Range("E3")
    dblFirstFinishOffset = 0
' Calculate the actual starting time from column E and A
    .Range("A2") = .Range("E3") - (.Range("A3") / 60 / 24)
' For all rows: correct column B, convert column A to cumulative date/time and store the cumulative score for those
' rows that contain a balloon title entry
    For i = 3 To intTKPlannedLastRow
        If .Range("J" & i) <> "" Then .Range("K" & i) = .Range("G" & i)
        .Range("B" & i) = CDbl(.Range("B" & i)) - dblFirstFinishOffset
'        .Range("A" & i) = (.Range("A" & i) / 60 / 24) + .Range("A" & i - 1)
    Next i
    
    Application.Calculation = xlCalculationAutomatic

' Format columns
    .Columns("A:K").ColumnWidth = 36
    .Columns("A:K").EntireColumn.AutoFit
    .Columns("H:H").ColumnWidth = 6

'Generate Graph
    .Range("N11").Select
End With

On Error Resume Next
blnExists = Sheets("Timeline").Select
If blnExists Then
    Application.DisplayAlerts = False
    Sheets("Timeline").Select
    ActiveWindow.SelectedSheets.Delete
    Application.DisplayAlerts = True
End If

Charts.Add                                                                              'add chart
ActiveChart.location where:=xlLocationAsNewSheet, Name:="Timeline"
ActiveChart.ChartType = xlXYScatterLinesNoMarkers
    
Dim blnShowBalloons As Boolean
blnShowBalloons = (Application.WorksheetFunction.CountA("J3:J" & intTKActualLastRow) > 0)

With Worksheets("Graph")
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).XValues = .Range(.Cells(3, 2), .Cells(intTKPlannedLastRow, 2))   'Original plan series
    ActiveChart.SeriesCollection(1).Values = .Range(.Cells(3, 4), .Cells(intTKPlannedLastRow, 4))
    ActiveChart.SeriesCollection(1).Name = "='Graph'!R1C2"
    ActiveChart.SeriesCollection(1).Border.ColorIndex = 1
    ActiveChart.SeriesCollection(1).Border.Weight = xlMedium
    
    If intTKActualLastRow > 1 Then
        ActiveChart.SeriesCollection.NewSeries
        ActiveChart.SeriesCollection(2).XValues = .Range(.Cells(3, 5), .Cells(intTKActualLastRow, 5))   'Actual series
        ActiveChart.SeriesCollection(2).Values = .Range(.Cells(3, 7), .Cells(intTKActualLastRow, 7))
        ActiveChart.SeriesCollection(2).Name = "='Graph'!R1C5"
        ActiveChart.SeriesCollection(2).Border.ColorIndex = 45
        ActiveChart.SeriesCollection(2).Border.Weight = xlMedium
    End If
    
    If blnShowBalloons Then
        ActiveChart.SeriesCollection(3).XValues = .Range(.Cells(3, 9), .Cells(intTKActualLastRow, 9))
        ActiveChart.SeriesCollection(3).Values = .Range(.Cells(3, 11), .Cells(intTKActualLastRow, 11))  'baloon marker series
        ActiveChart.SeriesCollection(3).MarkerStyle = xlDiamond                             'define baloon markers
        ActiveChart.SeriesCollection(3).MarkerBackgroundColorIndex = 3
        ActiveChart.SeriesCollection(3).MarkerSize = 6
        ActiveChart.Legend.LegendEntries(3).LegendKey.Border.LineStyle = xlNone
        ActiveChart.SeriesCollection(3).Name = "|fffd|: " & Format(Sheets(strSheetname).Range("N5"), "0.0") & " (" & Sheets(strSheetname).Range("M5") & ")"
    End If
End With

ActiveChart.Axes(xlCategory).HasMajorGridlines = True                                   'X gridlines
ActiveChart.Axes(xlCategory).TickLabels.NumberFormat = "d-mmm-yy"                       'date format
ActiveChart.Legend.Position = xlTop                                                     'Put legend on top

' Now start overlaying the balloons
Dim intMaxNrBalloons
Dim intBalloon As Integer
Dim intNrBalloons As Integer

intMaxNrBalloons = 24

'Determine coordination systems of chart
Dim dblGl As Double
Dim dblGt As Double
Dim dblGw As Double
Dim dblGh As Double

 'Graph grid
ActiveChart.PlotArea.Select
dblGl = Selection.InsideLeft
dblGt = Selection.InsideTop
dblGw = Selection.InsideWidth
dblGh = Selection.InsideHeight

'ActiveChart.SeriesCollection(2).Select
'Selection.MarkerStyle = -4105
'Selection.Format.Line.Visible = msoFalse

ActiveChart.Deselect
 
 'TimeAxis grid
Dim sngStartX As Single
Dim sngRangeX As Single
Dim sngRangeY As Single
Dim dblX As Double
Dim dblY As Double
Dim intColor As Integer
Dim sngBalloonX As Single
Dim sngBalloonY As Single
Dim sngBalloonTime() As Single
Dim sngBalloonValue() As Single
Dim strBalloonTitle() As String

sngStartX = Sheets("Timeline").Axes(xlCategory).MinimumScale
sngRangeX = Sheets("Timeline").Axes(xlCategory).MaximumScale - sngStartX
sngRangeY = ActiveChart.Axes(xlValue).MaximumScale                                                 'y scale length

ReDim sngBalloonTime(intMaxNrBalloons) As Single
ReDim sngBalloonValue(intMaxNrBalloons) As Single
ReDim strBalloonTitle(intMaxNrBalloons) As String

' Count nr of balloons
intNrBalloons = 0
For i = intTKActualLastRow To 3 Step -1
    If Sheets("Graph").Range("J" & i) <> "" Then
        intNrBalloons = intNrBalloons + 1
        If intNrBalloons <= intMaxNrBalloons Then
            sngBalloonTime(intNrBalloons) = Sheets("Graph").Range("I" & i)
            sngBalloonValue(intNrBalloons) = Sheets("Graph").Range("K" & i)
            strBalloonTitle(intNrBalloons) = Sheets("Graph").Range("J" & i)
        End If
    End If
Next i

If intNrBalloons > intMaxNrBalloons Then
    MsgBox "Maximum number of balloon titles (" & Format(intMaxNrBalloons, "##0") & ") exceeded." & vbCrLf & "Not all balloons will be plotted.", vbOKOnly
    intNrBalloons = intMaxNrBalloons
End If

Dim intMinLeft As Integer
Dim intMaxLeft As Integer
Dim intMinRight As Integer
Dim intMaxRight As Integer

If intNrBalloons > 12 Then
    intMinLeft = intNrBalloons \ 2 + 1
Else
    intMinLeft = 1
End If
intMaxLeft = intNrBalloons
intMaxRight = intMinLeft - 1
intMinRight = 1

For i = intMaxRight To intMinRight Step -1
    GetBalloonLocation (i - intMinRight + 1), intNrBalloons, sngBalloonX, sngBalloonY, intColor, False
    PlotBalloon sngBalloonX, sngBalloonY, sngBalloonTime(i), sngBalloonValue(i), strBalloonTitle(i), _
        dblGl, dblGw, dblGt, dblGh, sngStartX, sngRangeX, sngRangeY, intColor
Next i
For i = intMinLeft To intMaxLeft
    GetBalloonLocation (i - intMinLeft + 1), intNrBalloons, sngBalloonX, sngBalloonY, intColor, True
    PlotBalloon sngBalloonX, sngBalloonY, sngBalloonTime(i), sngBalloonValue(i), strBalloonTitle(i), _
        dblGl, dblGw, dblGt, dblGh, sngStartX, sngRangeX, sngRangeY, intColor
Next i

Application.Calculation = xlAutomatic

ActiveChart.Deselect
Sheets("Graph").Visible = False

End Sub

Sub GetBalloonLocation(intBalloon As Integer, intNrBalloons As Integer, _
    sngBalloonX As Single, sngBalloonY As Single, intColor As Integer, blnLeft As Boolean)

If blnLeft Then
    sngBalloonX = 150 - 20 * intBalloon
    sngBalloonY = 55 + 25 * intBalloon
Else
    sngBalloonX = 600 - 20 * intBalloon
    sngBalloonY = 200 + 25 * intBalloon
End If

intColor = (intBalloon Mod 17) + 11

End Sub

Sub PlotBalloon(sngBalloonX As Single, sngBalloonY As Single, sngStartTime As Single, sngValue As Single, strTitle As String, _
    dblGl As Double, dblGw As Double, dblGt As Double, dblGh As Double, _
    sngStartX As Single, sngRangeX As Single, sngRangeY As Single, intColor As Integer)

Dim dblX As Double
Dim dblY As Double

dblX = dblGl + (sngStartTime - sngStartX) / sngRangeX * dblGw                        'x coordinate
dblY = dblGt + dblGh - sngValue / sngRangeY * dblGh                                  'y coordinate

dblX = dblX - 52
dblY = dblY - 13
        
ActiveChart.Shapes.AddShape(msoShapeRoundedRectangularCallout, sngBalloonX, sngBalloonY, 184.45, 16).Select
Selection.Characters.Text = strTitle
Selection.Font.Size = 10
Selection.ShapeRange.Line.ForeColor.SchemeColor = intColor
Selection.AutoSize = True
 
 'determine shape parameters
Dim sngSl As Single
Dim sngSt As Single
Dim sngSw As Single
Dim sngSh As Single
 
sngSl = Selection.Left
sngSt = Selection.Top
sngSw = Selection.Width
sngSh = Selection.Height

If sngSw < 100 Then
    Selection.ShapeRange.Width = 100
    sngSw = 100
End If

'Selection.Move
Selection.ShapeRange.Adjustments.Item(1) = (dblX - sngSl) / sngSw                                'pointer value x
Selection.ShapeRange.Adjustments.Item(2) = (dblY - sngSt) / sngSh                                'pointer value y
Selection.ShapeRange.Fill.Transparency = 0.5

End Sub

Sub MakeProgress()

' Purpose of this routine is to create a status bar of the planned and the actual progress
' The results will be shown in sheet "StatusBar"

' Declare variables
Dim strTKSheetName As String                ' The name of the recovery sheet
Dim lngHeaderRow As Long
Dim lngLastSeqRow As Long

Dim intTKTestNameCol As Integer
Dim intTKStartCol(0 To 1) As Integer
Dim intJobStepStartRow() As Integer
Dim dblJobStepStart() As Double
Dim intJobStepColorIndex() As Integer
Dim strJobStepTitle() As String
Dim strLegendTitle() As String
Dim intPeriod As Integer
Dim intNrDays As Integer

Dim intStepID As Integer
Dim intNrEvents As Integer
Dim lngMinDate As Long
Dim lngMaxDate As Long
Dim intStartIssueList As Integer
Dim strStartCell As String

Dim dblPlannedEndTime As Double
Dim dblActualEndTime As Double
Dim blnUseDefaultLayout As Boolean

' The intStartRow and intStartCol variables define where the status bar will be shown

Const intStartRow As Integer = 4
Const intStartCol As Integer = 2

Const blnDebugMakeProgress As Boolean = False       ' Boolean for subroutine debugging

blnUseDefaultLayout = False

Dim i As Integer
Dim j As Integer
Dim k As Integer

Dim strGroupedFMS() As String
Dim strSearchText() As String
Dim lngGroupedColors() As Long

' If required, define the name of the debug file
If blnDebugMakeProgress And Not blnDebugMode Then
    blnDebugMode = True
    strDebugFile = strSourceDir & "\MakeProgress.dbg"
End If

' Retrieve the name of the recovery sheet
strTKSheetName = ActiveSheet.Name
WriteDebug "TimeKeeperSheet: " & strTKSheetName

' Retrieve the planned start time from the recovery sheet
strStartCell = fCell(cStartTimeRow, cPlannedTimeCol)
If Worksheets(strTKSheetName).Range(strStartCell) = "" Then
    If MsgBox("The start time (cell " & strStartCell & ") has not been given." & Chr(13) & _
        "The horizontal axis will be incorrect. Continue anyway?", vbYesNo) = vbNo Then
        Exit Sub
    End If
End If

' Because of the possibly large number of FMSs, not all separate FMSs will be shown in the statusbar
' Instead, the FMSs will be grouped as defined in the
' If this sheet is not available, we will use the default layout as fallback
If Not blnUseDefaultLayout Then
    If IsSheet("FMSGrouping") Then
        GetGroupedFMS intNrEvents, strGroupedFMS(), strSearchText(), lngGroupedColors()
    Else
        blnUseDefaultLayout = True
    End If
End If

WriteDebug "intNrEvents: " & intNrEvents

' Declare the dynamics arrays with JobStep names etc.
ReDim intJobStepStartRow(0 To intNrEvents + 1) As Integer
ReDim dblJobStepStart(0 To intNrEvents + 1, 0 To 1) As Double
ReDim intJobStepColorIndex(0 To intNrEvents) As Integer
ReDim strJobStepTitle(0 To intNrEvents) As String
ReDim strLegendTitle(0 To intNrEvents) As String
Dim intRecoveryEndRow As Integer

'Generate Statussheet
On Error Resume Next

If err.Number = 0 Then
'if sheet exists, select it
    Sheets("StatusBar").Visible = True
    Sheets("StatusBar").Select
    Worksheets("StatusBar").[A1:IV100].Clear
    WriteDebug "StatusBar sheet exists"
Else
'if sheet does not exist, make it
    Sheets.Add.Name = "StatusBar"
    WriteDebug "StatusBar sheet added"
End If

'Format the output sheet
Application.ScreenUpdating = False
SetBorder "StatusBar", 1, 1, 999, 255, xlEdgeLeft, 2, xlThin
SetBorder "StatusBar", 1, 1, 999, 255, xlEdgeTop, 2, xlThin
SetBorder "StatusBar", 1, 1, 999, 255, xlEdgeBottom, 2, xlThin
SetBorder "StatusBar", 1, 1, 999, 255, xlEdgeRight, 2, xlThin
SetBorder "StatusBar", 1, 1, 999, 255, xlInsideVertical, 2, xlThin
SetBorder "StatusBar", 1, 1, 999, 255, xlInsideHorizontal, 2, xlThin
Application.ScreenUpdating = True

' Identify the relevant columns in the recovery sheet
FindTKColumn strTKSheetName, "Test Name", intTKTestNameCol, lngHeaderRow, True, "status bar"
FindTKColumn strTKSheetName, "Expected Plan", intTKStartCol(0), lngHeaderRow, True, "status bar"
FindTKColumn strTKSheetName, "Actual start", intTKStartCol(1), lngHeaderRow, True, "status bar"

WriteDebug "TKTestNameCol     : " & intTKTestNameCol
WriteDebug "TKOrgPlanFinishCol: " & intTKStartCol(0)
WriteDebug "TKActualStartCol  : " & intTKStartCol(1)

Application.ScreenUpdating = False

' Define the colours used in the statusbar
GetJobStepColorIndex intJobStepColorIndex(), intNrEvents

If blnUseDefaultLayout Then
' Fallback scenario
    strLegendTitle(1) = "HW Recovery"
    strLegendTitle(2) = "Metrology SPM"
    strLegendTitle(3) = "Metrology grid"
    strLegendTitle(4) = "Metrology lens"
    strLegendTitle(5) = "Metrology fine"
    strLegendTitle(6) = "Post Fingerprint"
    
    strJobStepTitle(1) = "IH_HARDWARE_SAFETY_GUARANTEED"
    strJobStepTitle(2) = "METROLOGY_SPM"
    strJobStepTitle(3) = "METROLOGY_GRID"
    strJobStepTitle(4) = "METROLOGY_LENS"
    strJobStepTitle(5) = "METROLOGY_FINE"
    strJobStepTitle(6) = "WRAPUP"
Else
    For i = 0 To intNrEvents
        strLegendTitle(i) = strGroupedFMS(i)
        strJobStepTitle(i) = strGroupedFMS(i)
    Next i
End If

intJobStepStartRow(0) = lngHeaderRow + 1

' Find job steps in recovery sequence
WriteDebug "JobStep: 0 Legend: " & strLegendTitle(i) & " Title: " & strJobStepTitle(i) & " Start row: " & intJobStepStartRow(i)
For i = 1 To intNrEvents
    intJobStepStartRow(i) = Sheets(strTKSheetName).Columns(fColName(intTKTestNameCol)).Find(What:=strSearchText(i)).row
    WriteDebug "JobStep: " & Format(i, "#0") & " Legend: " & strLegendTitle(i) & " Title: " & strJobStepTitle(i) & " Search: " & strSearchText(i) & " Start row: " & intJobStepStartRow(i)
Next i

' Determine end of sequence
intJobStepStartRow(intNrEvents + 1) = Sheets(strTKSheetName).Range(fCell(2000, intTKStartCol(0))).End(xlUp).row

For i = intNrEvents To 1 Step -1
    If intJobStepStartRow(i) <= 0 Then
        intJobStepStartRow(i) = intJobStepStartRow(i + 1)
    End If
    WriteDebug "Job step: " & Format(i, "#0") & " Start Row: " & intJobStepStartRow(i)
Next i

lngMinDate = 99999
lngMaxDate = 0

Dim lngMinRow As Long
Dim lngMaxRow As Long
Dim lngStartRecRow As Long
Dim lngCurDat As Long

FindSequenceLayout strTKSheetName, lngMinRow, lngStartRecRow, lngLastSeqRow
lngMaxRow = lngLastSeqRow
WriteDebug strTKSheetName & " " & lngMinRow & " " & lngLastSeqRow

dblPlannedEndTime = CDbl(Worksheets(strTKSheetName).Cells(cEndTimeRow, cPlannedTimeCol))
dblActualEndTime = CDbl(Worksheets(strTKSheetName).Cells(cEndTimeRow, cActualTimeCol))
WriteDebug "Planned end date/time: " & Format(dblPlannedEndTime, "dd-mmm-yyy hh:mm")
WriteDebug "Actual end date/time: " & Format(dblActualEndTime, "dd-mmm-yyy hh:mm")
lngMaxDate = Application.WorksheetFunction.Max(CLng(dblPlannedEndTime), CLng(dblActualEndTime))

' Determine min and max dates for the recovery sequence
' The variable k is used to distinguish between planned (k=0) and actual (k=1) timings
For k = 0 To 1
' Use fix function for rounding down
    lngCurDat = CLng(Fix(Application.WorksheetFunction.Min(Worksheets(strTKSheetName).Range(fCell(lngMinRow, intTKStartCol(k)) & ":" & fCell(lngMaxRow, intTKStartCol(k))))))
    WriteDebug "Range: " & fCell(lngMinRow, intTKStartCol(k)) & ":" & fCell(lngMaxRow, intTKStartCol(k)) & " Min date: " & CDate(lngCurDat)
    lngMinDate = CLng(Fix(Application.WorksheetFunction.Min(lngMinDate, Worksheets(strTKSheetName).Range(fCell(lngMinRow, intTKStartCol(k)) & ":" & fCell(lngMaxRow, intTKStartCol(k))))))
    
    lngCurDat = CLng(Application.WorksheetFunction.Max(Worksheets(strTKSheetName).Range(fCell(lngMinRow, intTKStartCol(k)) & ":" & fCell(lngMaxRow, intTKStartCol(k)))))
    WriteDebug "Range: " & fCell(lngMinRow, intTKStartCol(k)) & ":" & fCell(lngMaxRow, intTKStartCol(k)) & " Max date: " & CDate(lngCurDat)
    lngMaxDate = CLng(Application.WorksheetFunction.Max(lngMaxDate, Worksheets(strTKSheetName).Range(fCell(lngMinRow, intTKStartCol(k)) & ":" & fCell(lngMaxRow, intTKStartCol(k)))))
    WriteDebug k & " " & intTKStartCol(k) & " [" & CDate(lngMinDate) & "] [" & CDate(lngMaxDate) & "]"
Next k

' Determine job step start for all events, planned and actual
For intStepID = 0 To intNrEvents + 1
    For k = 0 To 1
' To be replaced by MIN(range) for more flexibility
        If intStepID <= intNrEvents Then
            WriteDebug intStepID & " " & k & " " & fRange(CLng(intJobStepStartRow(intStepID)), intTKStartCol(k), CLng(intJobStepStartRow(intStepID + 1)), intTKStartCol(k))
            dblJobStepStart(intStepID, k) = Application.WorksheetFunction.Min(Worksheets(strTKSheetName).Range(fRange(CLng(intJobStepStartRow(intStepID)), intTKStartCol(k), CLng(intJobStepStartRow(intStepID + 1)), intTKStartCol(k))))
        Else
            WriteDebug intStepID & " " & k & " " & fCell(intJobStepStartRow(intStepID), intTKStartCol(k))
            dblJobStepStart(intStepID, k) = Sheets(strTKSheetName).Cells(intJobStepStartRow(intStepID), intTKStartCol(k))
        End If
        
        WriteDebug intStepID & " " & k & " " & intJobStepStartRow(intStepID) & " " & intTKStartCol(k) & " " & CDate(dblJobStepStart(intStepID, k))
    Next k
Next intStepID

' Start formatting output sheet
Sheets("StatusBar").Select
'Worksheets("StatusBar").[A1:DA100].Clear
Worksheets("StatusBar").Cells(intStartRow, intStartCol) = "Planned:"
Worksheets("StatusBar").Cells(intStartRow + 1, intStartCol) = "Actual:"

Dim intRowOffset As Integer
Dim intColOffset As Integer

intRowOffset = 0
intColOffset = 0

With Worksheets("StatusBar")

' Determine total time span to be plotted (min = 2 days)
    intNrDays = Application.WorksheetFunction.Max(2, (lngMaxDate - lngMinDate) + 1)
    WriteDebug "Nr of days: " & intNrDays
    
' Determine intPeriod, such that the statusbar fits
    intPeriod = Application.WorksheetFunction.Min(24, Int(150 / intNrDays))
    WriteDebug "Period: " & intPeriod

' Print legend
    For i = 1 To intNrEvents
        If lngGroupedColors(i) > 1 Then
            .Cells(6 + intStartRow + intRowOffset, intStartCol + 1 + intColOffset).Interior.Color = lngGroupedColors(i)
        Else
            .Cells(6 + intStartRow + intRowOffset, intStartCol + 1 + intColOffset).Interior.ColorIndex = intJobStepColorIndex(i)
        End If
        .Cells(6 + intStartRow + intRowOffset, intStartCol + 2 + intColOffset) = strLegendTitle(i)
        
        intColOffset = intColOffset + 20
        If intColOffset > intPeriod * (intNrDays - 1) Then
            intColOffset = 0
            intRowOffset = intRowOffset + 2
        End If
        
    Next i
    
    intRowOffset = intRowOffset + 2
    .Cells(6 + intStartRow + intRowOffset, intStartCol + 1).Interior.ColorIndex = 3
    intStartIssueList = 6 + intStartRow + intRowOffset
    .Cells(intStartIssueList, intStartCol + 2) = "Issues"
    
    Dim intMinRow As Integer
    Dim intMaxRow As Integer
    Dim intMinCol As Integer
    Dim intMaxCol As Integer
    
' Show results
    Dim lngRecoveryStart As Long
    Dim intStartCell As Integer
    Dim dblJobStepEnd As Double
    Dim intEndCell As Integer
    
    lngRecoveryStart = Int(Application.WorksheetFunction.Min(Worksheets(strTKSheetName).Range(strStartCell).Value, _
        Worksheets(strTKSheetName).Range(fRange(lngHeaderRow + 1, cEstimatedStartTimeCol, lngLastSeqRow, cEstimatedStartTimeCol))))
    
    WriteDebug "RecoveryStart    : " & lngRecoveryStart
    
    WriteDebug "k j JSStart StartCell CellRange JSEnd NextJSStart EndCell"
    For k = 0 To 1
        For j = 0 To intNrEvents
            If dblJobStepStart(j, k) > 0 Then
                intStartCell = intStartCol + 1 + Int(intPeriod * (dblJobStepStart(j, k) - lngRecoveryStart))
                dblJobStepEnd = Application.WorksheetFunction.Max( _
                Worksheets(strTKSheetName).Range(fCell(intJobStepStartRow(j), intTKStartCol(k)) & ":" & fCell(intJobStepStartRow(j + 1), intTKStartCol(k))))
                
                If dblJobStepStart(j + 1, k) > 0 Then
                    intEndCell = intStartCol + 1 + Int(intPeriod * (Application.WorksheetFunction.Max(dblJobStepEnd, dblJobStepStart(j + 1, k)) - lngRecoveryStart))
                Else
                    intEndCell = intStartCol + 1 + Int(intPeriod * (dblJobStepEnd - lngRecoveryStart))
                End If
                
'            Debug.Print k; " "; j; " "; dblJobStepStart(j, k); " "; intStartCell; " "; _
'                fCell(intJobStepStartRow(j), intTKStartCol(1)) & ":" & fCell(intJobStepStartRow(j + 1), intTKStartCol(k)); " "; _
'                dblJobStepEnd; " "; dblJobStepStart(j + 1, k); " "; intEndCell
            
                WriteDebug k & " " & j & " " & dblJobStepStart(j, k) & " " & intStartCell & " " & _
                fCell(intJobStepStartRow(j), intTKStartCol(1)) & ":" & fCell(intJobStepStartRow(j + 1), intTKStartCol(k)) & " " & _
                CDate(dblJobStepEnd) & " " & CDate(dblJobStepStart(j + 1, k)) & " " & intEndCell
            
                If intStartCell > 0 And intEndCell > 0 Then
                    For i = intStartCell To intEndCell
                        .Range(.Cells(intStartRow + k, i), .Cells(intStartRow + k, i)).Select
                        If lngGroupedColors(j) > 1 Then
                            Selection.Interior.Color = lngGroupedColors(j)
                        Else
                            Selection.Interior.ColorIndex = intJobStepColorIndex(j)
                        End If
                    Next i
                    
'                   Debug.Print k, j, intStartCell, strLegendTitle(j)
'                    .Cells(2 + k, intStartCell) = strLegendTitle(j)
                    With Range(fCell(intStartRow + k, intStartCell))
                        .Select
                        .AddComment
                        With .Comment
                            .Visible = False
                            .Text Text:=strLegendTitle(j)
                            .Shape.ScaleWidth 1.13, msoFalse, msoScaleFromTopLeft
                            .Shape.ScaleHeight 0.24, msoFalse, msoScaleFromTopLeft
                        End With
                    End With
                End If
            End If
        Next j
    Next k

    For i = 1 To intNrDays
' Print dates
        .Cells(intStartRow + 2, intStartCol + 1 + intPeriod * (i - 1)) = lngRecoveryStart - 1 + i
        .Cells(intStartRow + 2, intStartCol + 1 + intPeriod * (i - 1)).NumberFormat = "d-mmm"
        .Range(fRange(intStartRow + 2, intStartCol + 1 + intPeriod * (i - 1), intStartRow + 2, intStartCol + intPeriod * i)).Merge
        .Range(fRange(intStartRow + 2, intStartCol + 1 + intPeriod * (i - 1), intStartRow + 2, intStartCol + intPeriod * i)).HorizontalAlignment = xlCenter
        .Range(fRange(intStartRow + 2, intStartCol + 1 + intPeriod * (i - 1), intStartRow + 2, intStartCol + intPeriod * i)).ColumnWidth = 4 / intPeriod
        
' Set border
        For j = 0 To 1
            .Range(fRange(intStartRow + j, intStartCol + 1 + intPeriod * (i - 1), intStartRow + j, intPeriod * i + intStartCol)).Select
            Selection.Borders(xlEdgeLeft).Weight = xlMedium
            Selection.Borders(xlEdgeLeft).ColorIndex = 0
            Selection.Borders(xlEdgeTop).Weight = xlMedium
            Selection.Borders(xlEdgeTop).ColorIndex = 0
            Selection.Borders(xlEdgeBottom).Weight = xlMedium
            Selection.Borders(xlEdgeBottom).ColorIndex = 0
            Selection.Borders(xlEdgeRight).Weight = xlMedium
            Selection.Borders(xlEdgeRight).ColorIndex = 0
            
            Selection.Borders(xlInsideVertical).LineStyle = xlThin
            Selection.Borders(xlInsideHorizontal).LineStyle = xlThin
        Next j
    Next i
    
    .Columns(fColName(intStartCol + 1) & ":" & fColName(intStartCol + 1 + intPeriod * intNrDays)).ColumnWidth = 0.76
    
    With .Range(fRange(CLng(intStartRow), intStartCol + 1, CLng(intStartRow) + 1, intStartCol + 1 + intPeriod * intNrDays))
        .Font.Size = 6
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
' Show planned end time
    intStartCell = intStartCol + 1 + Int(intPeriod * (dblPlannedEndTime - lngRecoveryStart))
' .Range(.Cells(intStartRow - 2, intStartCell), .Cells(intStartRow - 1, intStartCell)).Interior.ColorIndex = 5
    SetBorder "StatusBar", intStartRow - 2, CLng(intStartCell), intStartRow - 1, CLng(intStartCell), xlEdgeRight, 5, xlMedium, False
    .Range(.Cells(intStartRow - 2, intStartCell + 1), .Cells(intStartRow - 2, intStartCell + 1)) = "Planned end time"

' Show actual end time
    intStartCell = intStartCol + 1 + Int(intPeriod * (dblActualEndTime - lngRecoveryStart))
' .Range(.Cells(intStartRow + 3, intStartCell), .Cells(intStartRow + 4, intStartCell)).Interior.ColorIndex = 3
    SetBorder "StatusBar", intStartRow + 3, CLng(intStartCell), intStartRow + 4, CLng(intStartCell), xlEdgeRight, 3, xlMedium, False
    .Range(.Cells(intStartRow + 4, intStartCell + 1), .Cells(intStartRow + 4, intStartCell + 1)) = "Expected end time"

    With Rows(fRows(intStartRow + 6, 99)).Font
        .Name = "Arial"
        .Size = 8
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
        .ThemeFont = xlThemeFontNone
    End With

' Show issues
    Dim intNrIssues As Integer
    Dim intIssueID As Integer
    Dim dblStartIssue() As Double
    Dim dblEndIssue() As Double
    Dim strIssue() As String

    GetIssueTime intNrIssues, dblStartIssue(), dblEndIssue(), strIssue()
    
    For intIssueID = 1 To intNrIssues
        intStartCell = intStartCol + 1 + Int(intPeriod * (dblStartIssue(intIssueID) - lngRecoveryStart))

' This is the original line
'       intEndCell = intStartCol + 1 + Int(intPeriod * (dblEndIssue(intIssueID) - lngRecoveryStart))
' Which is replaced by
        intEndCell = intStartCell - 1 + Int(0.5 + intPeriod * (dblEndIssue(intIssueID) - dblStartIssue(intIssueID)))
        
        If intStartCell > 0 And intEndCell > 0 Then
            For i = intStartCell To intEndCell
                .Range(.Cells(intStartRow + 1, i), .Cells(intStartRow + 1, i)).Interior.ColorIndex = 3 'red
                .Range(.Cells(intStartRow + 1, i), .Cells(intStartRow + 1, i)).Font.Size = 6
            Next i
            .Cells(intStartRow + 1, intStartCell) = Format(intIssueID, "##0")
            .Cells(intStartIssueList + intIssueID, intStartCol + 3) = Format(intIssueID, "##0") & ": " & strIssue(intIssueID)
        End If
    Next intIssueID

End With

If blnDebugMakeProgress Then
    blnDebugMode = False
End If

Application.ScreenUpdating = True
Worksheets("StatusBar").[A1].Select

End Sub

Private Sub GetIssueTime(intNrIssues As Integer, dblStartIssue() As Double, _
    dblEndIssue() As Double, strIssue() As String)

Dim strSheetname As String
Dim lngHeaderRow As Long
Dim lngStartRecRow As Long
Dim lngLastSeqRow As Long
Dim intCurRow As Integer
Dim sngBTime As Single
Dim sngATime As Single

FindSequenceLayout strSheetname, lngHeaderRow, lngStartRecRow, lngLastSeqRow

intNrIssues = 0
For intCurRow = lngStartRecRow To lngLastSeqRow
    sngATime = Val(Worksheets(strSheetname).Cells(intCurRow, cATimeCol))
    sngBTime = Val(Worksheets(strSheetname).Cells(intCurRow, cActualBTimeCol))
    
    If (sngBTime > sngATime + 20 Or sngBTime > 1.2 * sngATime) And (sngBTime > sngATime + 60) Then
        intNrIssues = intNrIssues + 1
        ReDim Preserve dblEndIssue(intNrIssues) As Double
        ReDim Preserve dblStartIssue(intNrIssues) As Double
        ReDim Preserve strIssue(intNrIssues) As String
        dblEndIssue(intNrIssues) = CDbl(Worksheets(strSheetname).Cells(intCurRow, cActualFinishTimeCol))
        dblStartIssue(intNrIssues) = dblEndIssue(intNrIssues) - (sngBTime - sngATime) / 1440
        strIssue(intNrIssues) = Worksheets(strSheetname).Cells(intCurRow, cComments1stLineCol)
        If strIssue(intNrIssues) = "" Then strIssue(intNrIssues) = "No description given"
    End If
Next intCurRow

End Sub

Private Sub GetGroupedFMS(intNrEvents As Integer, strGroupedFMS() As String, strSearchText() As String, _
    lngGroupedColors() As Long)
    
Dim strFMS() As String
Dim intNrFMS As Integer
Dim strPlatform As String

strPlatform = GetPlatformType(Worksheets("Source").Cells(1, 1))

' First read all FMS states used in this recovery
GetAllFMS strFMS(), intNrEvents

If IsSheet("FMSGrouping") Then
    intNrFMS = intNrEvents
    ReadGroupedFMS "FMSGrouping", strPlatform, intNrFMS, strFMS(), intNrEvents, strGroupedFMS(), strSearchText(), lngGroupedColors()
Else
    ReDim strGroupedFMS(intNrEvents) As String
    ReDim strSearchText(intNrEvents) As String
    ReDim lngGroupedColors(intNrEvents) As Long
    For i = 1 To intNrEvents
        strGroupedFMS(i) = strFMS(i)
        strSearchText(i) = strFMS(i)
        lngGroupedColors(i) = -1
    Next i
End If

End Sub

Private Sub ReadGroupedFMS(strFMSSheetname As String, strPlatform As String, intNrFMS As Integer, strFMS() As String, intNrGrpFMS As Integer, _
    strGroupedFMS() As String, strSearchText() As String, lngGroupedColors() As Long)

Dim strThisGroup As String
Dim strPreviousGroup As String
Dim strThisFMS As String
Dim strFMSInd As Integer
Dim intCurRow As Integer
Dim intGrpCol As Integer

' Information is retrieved from hidden sheet.

intGroupedFMSFile = FreeFile
strPreviousGroup = ""
intNrGrpFMS = 0

blnColorSection = False
blnFMSSection = False

' Grouping
intCurRow = Worksheets(strFMSSheetname).Range("grpFMS_" & strPlatform).row
intGrpCol = Worksheets(strFMSSheetname).Range("grpFMS_" & strPlatform).Column

While Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol) <> ""
    ' Read FMS and groupedFMS
    strThisFMS = Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol)
    strThisGroup = Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol + 1)
                
    If strThisGroup <> strPreviousGroup Then
        strFMSInd = 0
        For i = 1 To intNrFMS
        ' Identify the first FMS (if any) in this new group
            If Replace(LCase(strFMS(i)), "_", " ") = Replace(LCase(strThisFMS), "_", " ") Then
                strFMSInd = i
                Exit For
            End If
        Next i
                
        If strFMSInd > 0 Then
            intNrGrpFMS = intNrGrpFMS + 1
                        
            ReDim Preserve strGroupedFMS(intNrGrpFMS) As String
            strGroupedFMS(intNrGrpFMS) = strThisGroup
                        
            ReDim Preserve strSearchText(intNrGrpFMS) As String
            strSearchText(intNrGrpFMS) = strFMS(strFMSInd)
                        
            ReDim Preserve lngGroupedColors(intNrGrpFMS) As Long
            lngGroupedColors(intNrGrpFMS) = GetGroupedColor(strFMSSheetname, strGroupedFMS(intNrGrpFMS), intGrpCol)
                        
            strPreviousGroup = strThisGroup
        End If
    End If
    intCurRow = intCurRow + 1
Wend

'Group colors
intCurRow = 1
While Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol) <> ""
    strThisGroup = Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol)
    lngColor = CLng(Val(Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol + 1)))
    For i = 1 To intNrGrpFMS
        If strGroupedFMS(i) = strThisGroup Then
            lngGroupedColors(i) = lngColor
            Exit For
        End If
    Next i
    intCurRow = intCurRow + 1
Wend

End Sub

Private Function GetGroupedColor(strFMSSheetname As String, strGrpFMS As String, intGrpCol As Integer) As Long

Dim intCurRow As Integer

intCurRow = 2
While Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol) <> ""
    If Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol) = strGrpFMS Then
        GetGroupedColor = Worksheets(strFMSSheetname).Cells(intCurRow, intGrpCol + 1)
        Exit Function
    End If
    intCurRow = intCurRow + 1
Wend
GetGroupedColor = 1

End Function

Private Sub GetJobStepColorIndex(intColorIndex() As Integer, intNrEvents As Integer)

'Const intNrColorsDefined As Integer = 15
Const intNrColorsDefined As Integer = 48

Dim intColor(0 To intNrColorsDefined) As Integer

intColor(0) = 9     ' Brown-ish
intColor(1) = 46    ' DarkOrange
intColor(2) = 45    ' Orange
intColor(3) = 44    ' LightOrange
intColor(4) = 6     ' Yellow
intColor(5) = 43    ' YellowGreen
intColor(6) = 4     ' LightGreen
intColor(7) = 10    ' Green
intColor(8) = 14    ' GreenBlue
intColor(9) = 8     ' LightBlue
intColor(10) = 5    ' Blue
intColor(11) = 11   ' DarkBlue
intColor(12) = 13   ' Purple
intColor(13) = 26   ' Pink
intColor(14) = 22   ' Salmon
intColor(15) = 18   ' PurpleRed

For i = 0 To intNrEvents
'    intColorIndex(i) = intColor(i Mod intNrColorsDefined)
    intColorIndex(i) = 7 + (i Mod intNrColorsDefined)
Next i

End Sub

Private Sub FindTKColumn(strSheetname As String, strText As String, intColID As Integer, lngRowID As Long, blnEndIfColumnNotFound, strReason)

' Find column in TimeKeeper sheet
On Error GoTo errTKColumnNotFound

Dim strLookUpRange As String

If lngRowID > 0 Then
    strLookUpRange = fCell(lngRowID, 1) & ":" & fCell(lngRowID, 99)
Else
    strLookUpRange = "A1:CU99"
End If

Dim MatchCell As Range
Set MatchCell = Sheets(strSheetname).Range(strLookUpRange).Find(What:=strText, Lookat:=xlPart)
intColID = MatchCell.Column
lngRowID = MatchCell.row

Exit Sub

errTKColumnNotFound:
If blnEndIfColumnNotFound Then
    MsgBox "Cannot create " & strReason & Chr(13) & "Cause: cannot find TimeKeeper column named " & strText
    End
Else
    Resume Next
End If

End Sub

Private Sub ReplaceExact(lngMinRow As Long, intMinCol As Integer, lngMaxRow As Long, intMaxCol As Integer, varOldVal As Variant, varNewVal As Variant)

Dim intCurCol As Integer
Dim lngCurRow As Long

For lngCurRow = lngMinRow To lngMaxRow
    For intCurCol = intMinCol To intMaxCol
        If Worksheets("Graph").Cells(lngCurRow, intCurCol) = varOldVal Then
            Worksheets("Graph").Cells(lngCurRow, intCurCol) = varNewVal
        End If
    Next intCurCol
Next lngCurRow

End Sub

Public Sub AddArrow(sngXmin As Single, sngXmax As Single, sngYmin As Single, sngYmax As Single, sngWeight As Single, lngColor As Long)
    
ActiveSheet.Shapes.AddConnector(msoConnectorStraight, sngXmin, sngXmax, sngYmin, sngYmax).Select
With Selection.ShapeRange.Line
    .EndArrowheadStyle = msoArrowheadOpen
    .Visible = msoTrue
    .ForeColor.RGB = lngColor
    .Transparency = 0
    .Weight = sngWeight
End With

End Sub




' InQuest injected base64 decoded content
' K+-zd
' xZ+-
' ?"{^
' rgGjwex*&
' rgRzW
' ^u+Z
' njQb
' njPS
' *'jQh
' -zak
' Rz{(
' ZrH+

INQUEST-PP=macro
