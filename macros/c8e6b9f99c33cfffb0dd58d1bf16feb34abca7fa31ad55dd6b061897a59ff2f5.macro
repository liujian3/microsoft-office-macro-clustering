Attribute VB_Name = "ModAddOnCounters"
Option Explicit

Global wsAddOnCounters As Worksheet

'// Global Const sAddOn_Path = "C:\Documents and Settings\HQNIT011\Documenti\Temp\"
'// Global Const sAddOn_Path = "\\DSLKIDFPS\PRODUCTION_props\Production_Shared\DPPPD\00- ORDINI DI PRODUZIONE\ADDONCOUNTERS\" ===> Old Server
'// Global Const sAddOn_Path = "\\BRVKDFPS\PRODUCTION_props\Production_Shared\DPPPD\00- ORDINI DI PRODUZIONE\ADDONCOUNTERS\" ===> Old Server
Global Const sAddOn_Path = "\\CLMFSXP01.HQ.OTB.NET\PRODUCTION_props\Production_Shared\DPPPD\00- ORDINI DI PRODUZIONE\ADDONCOUNTERS\"
Global Const sAddOn_File = "AddOnCounters"
Global Const sAddOn_Extn = ".txt"


Function pfAddOnCountersManagement(sAddOn_Key As String) As Integer

Dim iAddOn_Counter As Integer
Dim lAddOn_KeyRow As Long
Dim lFind_Error As Long

    On Error GoTo Error
    
    wsAddOnCounters.Activate
    wsAddOnCounters.Columns("A:A").Select

    On Error Resume Next
    
    Selection.Find(What:=sAddOn_Key, LookIn:=xlValues, _
        LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:= _
        xlNext, MatchCase:=True, SearchFormat:=False).Activate
    lFind_Error = Err.Number
    
    On Error GoTo Error
    
    Select Case lFind_Error
    
    Case 0 '// AddOn trovato: incremento
        lAddOn_KeyRow = ActiveCell.Row
        iAddOn_Counter = CInt(Cells(lAddOn_KeyRow, 2) + 1)
        If iAddOn_Counter > 999 Then
            iAddOn_Counter = 0
        End If
        wsAddOnCounters.Cells(lAddOn_KeyRow, 2) = CStr(iAddOn_Counter)
        wsAddOnCounters.Cells(lAddOn_KeyRow, 3) = Format$(Date, "DD/MM/YYYY")
    
    Case 91 '// AddOn non trovato: inserimento
        wsAddOnCounters.Rows("1:1").Select
        Selection.Insert
        wsAddOnCounters.Cells(1, 1) = sAddOn_Key
        wsAddOnCounters.Cells(1, 2) = "0"
        wsAddOnCounters.Cells(1, 3) = Format$(Date, "DD/MM/YYYY")
        wsAddOnCounters.Columns("A:B").Select
        wsAddOnCounters.Sort.SortFields.Clear
        wsAddOnCounters.Sort.SortFields.Add Key:=Range("A1"), SortOn:=xlSortOnValues, _
            Order:=xlAscending, DataOption:=xlSortTextAsNumbers
        With wsAddOnCounters.Sort
            .SetRange Range("A:B")
            .Header = xlNo
            .MatchCase = False
            .Orientation = xlTopToBottom
            .SortMethod = xlPinYin
            .Apply
        End With
        iAddOn_Counter = 0
    
    Case Else '// Errore!
        iAddOn_Counter = -1
    
    End Select

    pfAddOnCountersManagement = iAddOn_Counter

    Exit Function
    
Error:
    pfAddOnCountersManagement = False

End Function

Function pfAddOnOpenDatabase() As Boolean

    On Error GoTo Error
    
    Workbooks.OpenText sAddOn_Path & sAddOn_File & sAddOn_Extn, "65001", , xlDelimited, xlTextQualifierDoubleQuote, False, True

    '// foglio dati contatori AddOn
    Set wsAddOnCounters = Worksheets(sAddOn_File)

    pfAddOnOpenDatabase = True
    
    Exit Function

Error:
    pfAddOnOpenDatabase = False

End Function


Function pfAddOnSaveDatabase() As Boolean

    On Error GoTo Error
    
    wsAddOnCounters.Activate
    Workbooks(sAddOn_File & sAddOn_Extn).Close True
    pfAddOnSaveDatabase = True

    Exit Function
    
Error:
    pfAddOnSaveDatabase = False

End Function

Attribute VB_Name = "ModDati"
Option Explicit

Public Function GetDataIntoWorkBook(ByRef MyWB As Workbook) As Integer

Dim TxtWS As Worksheet

Dim bFileSaveAs As Boolean
Dim bAddOnSaved As Boolean
Dim bAddOnOpened As Boolean
Dim bRunLoadPics As Boolean
Dim bRunShowPics As Boolean
Dim bVSizesDataSet As Boolean
Dim bAskLoadPassword As Boolean

Dim iAddOnSeq As Integer
Dim iModProgrBar As Integer

Dim lCel As Long
Dim lCol As Long
Dim lRow As Long
Dim lCur As Long
Dim lVoid As Long
Dim lBlkLns As Long
Dim lIdxArr As Long
Dim lTotRow As Long
Dim lTotCol As Long
Dim lRowTxt As Long
Dim lRowXls As Long
Dim lColTxt As Long
Dim lColXls As Long
Dim lRowsXls As Long
Dim lRowHead As Long
Dim lColComm As Long
Dim lColPics As Long
Dim lPicBrkk As Long
Dim lFamBrkk As Long
Dim lMaxSapHD As Long
Dim lMaxSapHV As Long
Dim lColIdPdf As Long
Dim lColSapCA As Long
Dim lColSapNA As Long
Dim lColToExp As Long
Dim lColTitle As Long
Dim lCpiTitle As Long
Dim lRowAddOn As Long
Dim lColAddOn As Long
Dim lFmtArr() As Long
Dim lColAddOnQ As Long
Dim lColInzTxt As Long
Dim lMaxColXls As Long
Dim lPosSep(9) As Long
Dim lColMadeIn As Long
Dim lCorrectNo As Long
Dim lCurrentNo As Long
Dim lSapHeaderL As Long
Dim lColBarcode As Long
Dim lCurrExpKey As Long
Dim lPrevExpKey As Long
Dim lMaxSapPost As Long
Dim lMaxFCondHL As Long
Dim lMaxColToHL As Long
Dim lMaxColorHL As Long
Dim lMaxColToWT As Long
Dim lMaxColToBrk As Long
Dim lMaxColToTot As Long
Dim lMaxColToExp As Long
Dim lMaxColToChk As Long
Dim lMaxColToFmt As Long
Dim lMaxFilterFL As Long
Dim lMaxFilterC1 As Long
Dim lMaxFilterC2 As Long
Dim lMaxFilterOP As Long
Dim lColSapCS(9) As Long
Dim lColToChkSeq As Long
Dim lColToChkDate As Long
Dim lColToTestIdx As Long
Dim lColToZeroIdx As Long
Dim lMaxColToTest As Long
Dim lMaxColToZero As Long
Dim lMaxColToPrtc As Long
Dim lPicRowHeight As Long
Dim lDataToExpCntr As Long
Dim lRowExpanded() As Long
Dim lColExpanded() As Long
Dim lTotColFormula As Long
Dim lMaxColPageBrk As Long
Dim lColFormula(99) As Long
Dim lMaxColLoadPics As Long
Dim lMaxLineWarning As Long
Dim lMaxLineLoopExec As Long

Dim sTitle As String
Dim sValue As String
Dim sColLbl As String
Dim sSapPrm As String
Dim sRangeFr As String
Dim sRangeTo As String
Dim sTmpDate As String
Dim sAddOnBC As String
Dim sAddOnMI As String
Dim sFileExtn As String
Dim sFuncName As String
Dim sFuncPrms As String
Dim sRangeDim As String
Dim sRangeArea As String
Dim sPrtParams As String
Dim sTestBrkKey As String
Dim sZeroBrkKey As String
Dim sDateFormat As String
Dim sSapHeaderD As String
Dim sSapHeaderV As String
Dim sValidDateFr As String
Dim sValidDateTo As String
Dim sCompanyCode As String
Dim sCurrColToBrk As String
Dim sPrevColToBrk As String
Dim sLoadPassword As String
Dim sDefaultToOmit As String
Dim sCurrColPageBrk As String
Dim sPrevColPageBrk As String

Dim dValue As Double
Dim dAddOnQta As Double
Dim dColSubTot(99) As Double

Dim vOperator As Variant
Dim vCellValue As Variant
Dim vCondit(2) As Variant
Dim vColSapVC(9) As Variant
Dim vSapPost(99) As Variant
Dim vFCondHL(99) As Variant
Dim vColToHL(99) As Variant
Dim vColorHL(99) As Variant
Dim vColToWT(99) As Variant
Dim vFilterFL(99) As Variant
Dim vFilterC1(99) As Variant
Dim vFilterC2(99) As Variant
Dim vFilterOP(99) As Variant
Dim vFilterFV(99) As Variant
Dim vColToBrk(99) As Variant
Dim vColToTot(99) As Variant
Dim vColToFmt(99) As Variant
Dim vColToTest(99) As Variant
Dim vColToZero(99) As Variant
Dim vColToPrtc(99) As Variant
Dim vArrColHAl(99) As Variant
Dim vArrNumFmt(99) As Variant
Dim vSapHeaderD(99) As Variant
Dim vSapHeaderV(99) As Variant
Dim vDataExpanded() As Variant
Dim vColPageBrk(99) As Variant
Dim vColToChkKey(99) As Variant
Dim vColLoadPics(99) As Variant

    GetDataIntoWorkBook = False
    On Error GoTo lblError

    '// foglio dati origine
    Set TxtWS = MyWB.ActiveSheet

    '// foglio dati destinazione
    ThisWorkbook.Activate

    '// display progress bar
    frmWait.Show vbModeless
    frmWait.SetMsg "Processing..."
    'DoEvents
    'ThisWorkbook.Activate

    '// format vari
    sDateFormat = TxtWS.Cells(gklData_Row_Info, gkiData_Col_FormatoData)
    gwsFormatFont = gksFormatFont
    gwlFormatCPI = gklFormatCPI

    '// calcolo totale righe
    lTotRow = TxtWS.Cells(gklData_Row_Info, gkiData_Col_TotRighe).Text
    If lTotRow < 0 Then
        lTotRow = 0
    Else
        lTotRow = lTotRow + gklData_FirstRow - 1
    End If

    '// calcolo posizione colonne (le ultime tre relative alle taglie non sono nel totale)
    lTotCol = TxtWS.Cells(gklData_Row_Info, gkiData_Col_TotColonne).Value

    '// array formato colonne
    ReDim lFmtArr(lTotCol)
    Do
      lIdxArr = lIdxArr + 1
      lFmtArr(lIdxArr) = TxtWS.Cells(gklData_Row_TipoDato, lIdxArr)
    Loop Until lIdxArr = lTotCol

    '// decodifica funzioni speciali (colonne intestate con @)
    sColLbl = TxtWS.Cells(gklData_Row_Labels, lTotCol).Value
    Do While Left$(sColLbl, 1) = "@"
        lPosSep(1) = InStr(1, sColLbl, "(", vbTextCompare)
        lPosSep(2) = lPosSep(1) + 1
        lPosSep(3) = Len(sColLbl) - lPosSep(2)
        sFuncName = Left$(sColLbl, lPosSep(1))
        sFuncPrms = Mid$(sColLbl, lPosSep(2), lPosSep(3))

        Select Case sFuncName

        Case gksFunc_CPI    '// CPI report
            gwlFormatCPI = CLng(sFuncPrms)
            If gwlFormatCPI = 0 Then gwlFormatCPI = gklFormatCPI

        Case gksFunc_OMIT   '// omette settaggi di default
            sDefaultToOmit = ";" & sFuncPrms & ";"

            Case gksFunc_ADDON  '// gestione AddOn
            lPosSep(1) = CLng(InStr(1, sFuncPrms, ";", vbBinaryCompare))
            lPosSep(2) = CLng(InStr(lPosSep(1) + 1, sFuncPrms, ";", vbBinaryCompare))
            lPosSep(3) = CLng(InStr(lPosSep(2) + 1, sFuncPrms, ";", vbBinaryCompare))
            lColBarcode = CLng(Left$(sFuncPrms, lPosSep(1) - 1))
            lColMadeIn = CLng(Mid$(sFuncPrms, lPosSep(1) + 1, lPosSep(2) - lPosSep(1) - 1))
            lColAddOn = CLng(Mid$(sFuncPrms, lPosSep(2) + 1, lPosSep(3) - lPosSep(2) - 1))
            lColAddOnQ = CLng(Right$(sFuncPrms, Len(sFuncPrms) - lPosSep(3)))
            If lColBarcode + lColMadeIn + lColAddOn Then
                '// apro il file dei contatori solo se uno dei campi |fffd| valorizzato
                bAddOnOpened = pfAddOnOpenDatabase()
                If Not bAddOnOpened Then
                    MsgBox "WARNING: AddOn Counters File Not Found!", vbCritical + vbOKOnly, "AddOn Management"
                    GoTo lblError
                End If
            Else
                '// serve per usare la funzione di duplica righe senza gestire i contatori
                bAddOnOpened = True
            End If
            iModProgrBar = 10

        Case gksFunc_TITLE  '// titolo report
            lPosSep(1) = CLng(InStr(1, sFuncPrms, ";", vbBinaryCompare))
            lPosSep(2) = CLng(InStr(lPosSep(1) + 1, sFuncPrms, ";", vbBinaryCompare))
            lPosSep(3) = CLng(InStr(lPosSep(2) + 1, sFuncPrms, ";", vbBinaryCompare))
            lColTitle = CLng(Left$(sFuncPrms, lPosSep(1) - 1))
            If lColTitle < 1 Then lColTitle = 1
            lCpiTitle = CLng(Mid$(sFuncPrms, lPosSep(1) + 1, lPosSep(2) - lPosSep(1) - 1))
            If lCpiTitle = 0 Then lCpiTitle = 12
            If lPosSep(3) = 0 Then lPosSep(3) = Len(sFuncPrms) + 1
            sTitle = Mid$(sFuncPrms, lPosSep(2) + 1, lPosSep(3) - lPosSep(2) - 1)
            If lPosSep(3) > Len(sFuncPrms) Then
                lBlkLns = 1
            Else
                lBlkLns = CLng(Right$(sFuncPrms, Len(sFuncPrms) - lPosSep(3)))
            End If

        Case gksFunc_PROTECT     '// protegge celle
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToPrtc, vColToPrtc(), vbString)
        
        Case gksFunc_TO_TEST     '// colonne da testare per azzeramento
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToTest, vColToTest(), vbLong)
        
        Case gksFunc_TO_ZERO     '// colonne da azzerare
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToZero, vColToZero(), vbLong)
        
        Case gksFunc_SAVE_AS     '// salva come xls o xlsx
            bFileSaveAs = True

        Case gksFunc_CHK_SEQ     '// controllo sequenza numerazione
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToChk, vColToChkKey(), vbLong)
            lColToChkSeq = vColToChkKey(1)
            For lCur = 1 To lMaxColToChk
                vColToChkKey(lCur) = vColToChkKey(lCur + 1)
            Next lCur
            lMaxColToChk = lMaxColToChk - 1
            If vColToChkKey(lMaxColToChk) < 0 Then
                '// opzione "D" colonna range di date
                lColToChkDate = vColToChkKey(lMaxColToChk) * -1
                vColToChkKey(lMaxColToChk) = 0
                lMaxColToChk = lMaxColToChk - 1
            End If
        
        Case gksFunc_SET_PRT     '// imposta stampa
            sPrtParams = ";" & sFuncPrms & ";"
        
        Case gksFunc_FMT_COL     '// format: colonna
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToFmt, vColToFmt(), vbLong)
        
        Case gksFunc_FMT_NUM     '// format: numero
            Call GetDataFromFunctions(sFuncPrms & ";", lVoid, vArrNumFmt(), vbString)
        
        Case gksFunc_FMT_HAL     '// format: allineamento orizzontale
            Call GetDataFromFunctions(sFuncPrms & ";", lVoid, vArrColHAl(), vbString)
        
        Case gksFunc_BREAK_ON    '// colonne di rottura
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToBrk, vColToBrk(), vbLong)
        
        Case gksFunc_TOTAL_ON    '// colonne totali da rottura
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToTot, vColToTot(), vbLong)
        
        Case gksFunc_FONTNAME    '// font report
            gwsFormatFont = sFuncPrms

        Case gksFunc_WRAPTEXT    '// Testo a capo su riga intestazioni o su colonna
            Select Case sFuncPrms
            Case "ON"
                lMaxColToWT = True
            Case Else
                Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToWT, vColToWT(), vbLong)
            End Select

        Case gksFunc_HL_COLUMN   '// colonne da evidenziare
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColToHL, vColToHL(), vbLong)
        
        Case gksFunc_HL_COLOUR   '// colori colonne da evidenziare
            Call GetDataFromFunctions("ColDec" & sFuncPrms & ";", lMaxColorHL, vColorHL(), vbLong)
        
        Case gksFunc_HL_CONDIT   '// format condition colonne da evidenziare
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxFCondHL, vFCondHL(), vbString)

        Case gksFunc_FILTER_FL   '// filtro: colonne da filtrare
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxFilterFL, vFilterFL(), vbLong)

        Case gksFunc_FILTER_C1   '// filtro: criterio 1 da applicare alle colonne da filtrare
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxFilterC1, vFilterC1(), vbString)

        Case gksFunc_FILTER_C2   '// filtro: criterio 2 da applicare alle colonne da filtrare
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxFilterC2, vFilterC2(), vbString)

        Case gksFunc_FILTER_OP   '// filtro: operatore da applicare ai criteri
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxFilterOP, vFilterOP(), vbString)

        Case gksFunc_COL_EXPAND  '// espande colonne per campi multirecord
            lColToExp = CLng(sFuncPrms)
        
        Case gksFunc_PAGE_BREAK  '// inserisce una rottura di pagina
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColPageBrk, vColPageBrk(), vbLong)
        
        Case gksFunc_SAP_POSTING '// prepara un file excel per SAP Posting
            lMaxSapPost = 0
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxSapPost, vSapPost(), vbString)
            '// elabora riga per riga aggiungendo riga di contropartita
            For lCol = 1 To lMaxSapPost
                sSapPrm = CStr(Left$(vSapPost(lCol), 2))
                Select Case sSapPrm
                Case "CA" '// Colonna Account
                    lColSapCA = CLng(Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4))
                Case "NA" '// Numero Accounts
                    lColSapNA = CLng(Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4))
                Case "CS" '// Cambia Segno
                    sSapPrm = "," & Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4) & ","
                    lPosSep(2) = 1
                    lCur = 1
                    Do
                        lPosSep(1) = CLng(InStr(lPosSep(2), sSapPrm, ",", vbTextCompare))
                        lPosSep(2) = CLng(InStr(lPosSep(1) + 1, sSapPrm, ",", vbTextCompare))
                        If lPosSep(1) = 0 Or lPosSep(2) = 0 Then Exit Do
                        lColSapCS(lCur) = CLng(Mid$(sSapPrm, lPosSep(1) + 1, lPosSep(2) - lPosSep(1) - 1))
                        lCur = lCur + 1
                    Loop
                Case "VC" '// Imposta Valore Cella
                    sSapPrm = "," & Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4) & ","
                    lPosSep(2) = 1
                    lCur = 1
                    Do
                        lPosSep(1) = CLng(InStr(lPosSep(2), sSapPrm, ",", vbTextCompare))
                        lPosSep(2) = CLng(InStr(lPosSep(1) + 1, sSapPrm, ",", vbTextCompare))
                        If lPosSep(1) = 0 Or lPosSep(2) = 0 Then Exit Do
                        vColSapVC(lCur) = CVar(Mid$(sSapPrm, lPosSep(1) + 1, lPosSep(2) - lPosSep(1) - 1))
                        lCur = lCur + 1
                    Loop
                Case "HL" '// Numero righe testata
                    lSapHeaderL = CLng(Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4))
                Case "H1", "H2"  '// Label testata
                    lMaxSapHD = lMaxSapHD + 1
                    sSapHeaderD = Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4) & "," & sSapHeaderD
                    If lMaxSapHD = 2 Then
                        lMaxSapHD = 0
                        sSapHeaderD = Replace(sSapHeaderD, ",", ";", 1, -1, vbBinaryCompare)
                        Call GetDataFromFunctions(sSapHeaderD, lMaxSapHD, vSapHeaderD(), vbString)
                    End If
                Case "HV" '// Valori testata
                    sSapHeaderV = Mid$(vSapPost(lCol), 4, Len(vSapPost(lCol)) - 4) & ","
                    sSapHeaderV = Replace(sSapHeaderV, ",", ";", 1, -1, vbBinaryCompare)
                    Call GetDataFromFunctions(sSapHeaderV, lMaxSapHV, vSapHeaderV(), vbString)
                End Select
            Next lCol
        
        Case gksFunc_VSIZES '// verticalizza taglie
            bVSizesDataSet = True

        Case gksFunc_WRKPDF '// gestione PDF (download & zip)
            lPosSep(1) = CLng(InStr(1, sFuncPrms, ";", vbBinaryCompare))
            If lPosSep(1) = 0 Then
                lColIdPdf = CLng(sFuncPrms)
                sFileExtn = "pdf"
            Else
                lColIdPdf = CLng(Left$(sFuncPrms, lPosSep(1) - 1))
                sFileExtn = Right$(sFuncPrms, Len(sFuncPrms) - lPosSep(1))
            End If

        Case gksFunc_LOADPICS '// carica immagini per ogni riga
            Call GetDataFromFunctions(sFuncPrms & ";", lMaxColLoadPics, vColLoadPics(), vbVariant)
            lColPics = CLng(vColLoadPics(1))
            lColComm = CLng(vColLoadPics(2))
            lPicBrkk = CLng(vColLoadPics(3))
            lFamBrkk = CLng(vColLoadPics(4))
            gwsURLPath = CStr(vColLoadPics(5))
            lPicRowHeight = CLng(vColLoadPics(6))
            lMaxLineWarning = CLng(vColLoadPics(7))
            lMaxLineLoopExec = CLng(vColLoadPics(8)): If lMaxLineLoopExec = 0 Then lMaxLineLoopExec = 100
            bAskLoadPassword = CBool(vColLoadPics(9))
            bRunLoadPics = CBool(CInt(vColLoadPics(10)) > 0)
            bRunShowPics = CBool(CInt(vColLoadPics(10)) = 2)
            sLoadPassword = Left$(Format$(TxtWS.Cells(gklData_Row_Info, gkiData_Col_DataLancio), sDateFormat), 2) & _
                            Left$(Format$(TxtWS.Cells(gklData_Row_Info, gkiData_Col_OraLancio), "Hh:Nn:Ss"), 2)

        End Select

        '// decremento totale colonne e rileggo label
        lTotCol = lTotCol - 1
        sColLbl = TxtWS.Cells(gklData_Row_Labels, lTotCol).Value
    Loop
    
    '// modulo contatore righe processate
    If Not iModProgrBar Then
        iModProgrBar = 50
    End If
    
    '// funzione VSIZES: Verticalizza Records Taglie
    If bVSizesDataSet Then
        bVSizesDataSet = VSizesDataSet(MyWB, lTotCol, lTotRow)
        If bVSizesDataSet Then
            '// apre nuovo file e lo riprocessa
            GetDataIntoWorkBook = 2
            Exit Function
        Else
            '// esce per lblError
            GetDataIntoWorkBook = 0
            GoTo lblError
        End If
    End If
    
    '// indici riga testata e colonne da-a
    lRowHead = 1
    lColInzTxt = 1
    lMaxColXls = lTotCol
    
    '// chiavi di rottura
    lCurrExpKey = 1
    lPrevExpKey = 99

    '// contatori file Xls
    lRowXls = 0
    lColXls = 0
    
    '// foglio dati destinazione
    ThisWorkbook.Activate

    If lTotRow > 0 Then
                
        '// formattazione generale foglio
        FormatThisSheet gwlFormatCPI, False, False, False, vbBlack

        '// display progress bar
        frmWait.SetMsg "Loading Data: 1 of " & lTotRow & " lines"
        'DoEvents
        'ThisWorkbook.Activate

        '// ciclo righe
        For lRowTxt = gklData_FirstRow To lTotRow

            If lColToExp Then
                '// funzione COL-EXPAND: chiave di espansione
                lCurrExpKey = CLng(Val(Replace(TxtWS.Cells(lRowTxt, lColToExp + 1), "'", "0")))
                If lCurrExpKey < lPrevExpKey Or lPrevExpKey = 0 Then
                    lPrevExpKey = lCurrExpKey
                End If
            Else
                lPrevExpKey = lCurrExpKey
            End If

            If bAddOnOpened Then
                '// elaborazione AddOn: crea tante righe di AddOn in base alla quantit|fffd|
                vCellValue = GetQuoteStrippedValueFromCell(TxtWS.Cells(lRowTxt, lColAddOnQ).Value)
                dAddOnQta = ConvNum(vCellValue)
                TxtWS.Cells(lRowTxt, lColAddOnQ).Value = "1"
                sAddOnBC = ""
            Else
                '// elaborazione normale: crea una riga
                dAddOnQta = 1
            End If
            
            If lCurrExpKey = lPrevExpKey Then
                '// dAddOnQta=1: elaborazione normale
                '// dAddOnQta>1: elaborazione AddOn
                
                For lRowAddOn = 1 To dAddOnQta
        
                    '// funzioni TO-BREAK & TO-TOTAL
                    If lMaxColToBrk Then
                        GoSub srBreakOnTotalOn
                    End If
                    
                    '// funzioni PAGE-BREAK
                    If lMaxColPageBrk Then
                        GoSub srPageBreak
                    End If

                    lRowXls = lRowXls + 1
                    
                    '// ciclo colonne
                    For lColTxt = lColInzTxt To lMaxColXls
        
                        '// contenuto cella senza apice
                        vCellValue = GetQuoteStrippedValueFromCell(TxtWS.Cells(lRowTxt, lColTxt).Value)
    
                        lColXls = lColTxt
    
                        '// elaborazione AddOn
                        If bAddOnOpened And lColXls = lColAddOn Then
                            '// costruzione chiave contatore addOn
                            If sAddOnBC = "" Then
                                vCellValue = GetQuoteStrippedValueFromCell(TxtWS.Cells(lRowTxt, lColBarcode).Value)
                                sAddOnBC = CStr(vCellValue)
                                vCellValue = GetQuoteStrippedValueFromCell(TxtWS.Cells(lRowTxt, lColMadeIn).Value)
                                sAddOnMI = CStr(vCellValue)
                            End If
                            '// lettura contatore AddOn
                            iAddOnSeq = pfAddOnCountersManagement(sAddOnBC & "-" & sAddOnMI)
                            ThisWorkbook.Activate
                            vCellValue = sAddOnMI & Format$(CStr(iAddOnSeq), "000")
                        End If
        
                        '// inserisco valore cella formattatato
                        Select Case lFmtArr(lColTxt)
                        Case 2 '// number
                            dValue = ConvNum(vCellValue)
                            If dValue Then
                                Cells(lRowXls, lColXls).Value = dValue
                            End If
                        Case 3 '// date
                            sTmpDate = vCellValue
                            Cells(lRowXls, lColXls).Value = GetDateFromString(sTmpDate, sDateFormat)
                        Case Else '// string
                            If Left$(vCellValue, Len(gksFunc_FORMULA)) = gksFunc_FORMULA Then
                                If lRowXls = 1 Then
                                    lTotColFormula = lTotColFormula + 1
                                    lColFormula(lTotColFormula) = lColXls
                                    vCellValue = Right$(vCellValue, Len(vCellValue) - Len(gksFunc_FORMULA) + 1)
                                    vCellValue = Replace(vCellValue, ";", ",", 1, True, vbTextCompare)
                                    On Error Resume Next
                                    Cells(lRowXls, lColXls).Formula = vCellValue
                                    On Error GoTo lblError
                                End If
                            Else
                                Cells(lRowXls, lColXls).Value = gksChar_Apice & vCellValue
                            End If
                        End Select
        
                    Next lColTxt
        
                Next lRowAddOn

            Else
                
                '// funzione COL-EXPAND: memorizzazione coordinate e dati colonne aggiunte
                If lColToExp Then
                    If lCurrExpKey > lPrevExpKey Then
                        lPrevExpKey = lCurrExpKey
                        '// dati per colonne da espandere
                        If lMaxColToExp < lCurrExpKey Then
                            lMaxColToExp = lCurrExpKey
                        End If
                        If lDataToExpCntr Mod 99 = 0 Then
                            ReDim Preserve lRowExpanded(99 * ((lDataToExpCntr / 99) + 1))
                            ReDim Preserve lColExpanded(99 * ((lDataToExpCntr / 99) + 1))
                            ReDim Preserve vDataExpanded(99 * ((lDataToExpCntr / 99) + 1))
                        End If
                        lDataToExpCntr = lDataToExpCntr + 1
                        lRowExpanded(lDataToExpCntr) = lRowXls
                        lColExpanded(lDataToExpCntr) = lColToExp + lCurrExpKey - 1
                        vCellValue = GetQuoteStrippedValueFromCell(TxtWS.Cells(lRowTxt, lColToExp).Value)
                        vDataExpanded(lDataToExpCntr) = vCellValue
                    Else
                        lPrevExpKey = 1
                    End If
                End If
            
            End If

            '// funzioni TO-TEST & TO-ZERO
            If lMaxColToZero Then
                GoSub srColToZero
            End If

            '// funzione SAP-POSTING
            If lMaxSapPost Then
                GoSub srSapPosting
            End If

            '// update progress bar
            If lRowTxt Mod iModProgrBar = 0 Then
                frmWait.SetMsg "Loading Data " & lRowTxt & " of " & lTotRow & " lines"
                'DoEvents
                'ThisWorkbook.Activate
            End If

        Next lRowTxt
    
        '// funzioni TO-BREAK & TO-TOTAL
        If lMaxColToBrk Then
            GoSub srBreakOnTotalOn
        End If

        '// funzioni PAGE-BREAK
        If lMaxColPageBrk Then
            GoSub srPageBreak
        End If

        '// last update progress bar
        frmWait.SetMsg "Formatting Data..."
        'DoEvents
        'ThisWorkbook.Activate

        '// memorizzo totale righe Xls
        lRowsXls = lRowXls

        '// copia formule
        If lRowsXls > 1 Then
            For lCol = 1 To lTotColFormula
                Cells(1, lColFormula(lCol)).Select
                Selection.AutoFill Destination:=Range(Cells(1, lColFormula(lCol)), Cells(lRowsXls, lColFormula(lCol)))
            Next lCol
        End If
        
        '// formatta colonne dati
        For lCol = 1 To lMaxColXls
            Select Case lFmtArr(lCol)
            Case 2 '// number
                FormatThisCol lCol, xlRight, xlBottom, False
            Case 3 '// date
                FormatThisCol lCol, xlCenter, xlBottom, False
            Case Else '// string
                FormatThisCol lCol, xlLeft, xlBottom, False
            End Select
        Next lCol

        '// inserimento riga vuota per testata colonne
        Rows(1).Select
        Selection.Insert
        lRowsXls = lRowsXls + 1
        
        '// testata colonne
        For lColXls = 1 To lMaxColXls
            Cells(1, lColXls).Value = TxtWS.Cells(gklData_Row_Labels, lColXls).Value
        Next lColXls
        FormatThisRow 1, gwlFormatCPI, True, False, False, gklColor_DarkBlue
        SetThisRange_Line 1, 1, 1, lMaxColXls, xlContinuous, xlThin, , , , , xlContinuous, xlThin

        '// Testo a capo (wraptext)
        If lMaxColToWT Then
            Select Case lMaxColToWT
            Case True
                Rows(lRowHead).WrapText = True
            Case Else
                For lCol = 1 To lMaxColToWT
                    Columns(vColToWT(lCol)).WrapText = True
                Next lCol
            End Select
        End If
        
        '// colonne da evidenziare
        For lCol = 1 To lMaxColToHL
            Range(Cells(lRowHead, vColToHL(lCol)), Cells(lRowsXls, vColToHL(lCol))).Select
            If lMaxFCondHL Then
                vOperator = Left$(vFCondHL(lCol), 2)
                Select Case vOperator
                    Case "EQ": vOperator = xlEqual
                    Case "NE": vOperator = xlNotEqual
                    Case "GT": vOperator = xlGreater
                    Case "LT": vOperator = xlLess
                    Case "GE": vOperator = xlGreaterEqual
                    Case "LE": vOperator = xlLessEqual
                    Case "BT": vOperator = xlBetween
                    Case "NB": vOperator = xlNotBetween
                End Select
                vCondit(2) = Null
                vCondit(1) = Mid$(CStr(vFCondHL(lCol)), 4, Len(vFCondHL(lCol)) - 4)
                lCur = InStr(1, vCondit(1), "&", vbTextCompare)
                If lCur Then
                    '// |fffd| un range
                    vCondit(2) = Right$(vCondit(1), Len(vCondit(1)) - lCur)
                    vCondit(1) = Left$(vCondit(1), lCur - 1)
                End If
                If lFmtArr(vColToHL(lCol)) = 2 Or _
                   (IsNumeric(vCondit(1)) And IsNull(vCondit(2))) Or _
                   (IsNumeric(vCondit(1)) And IsNumeric(vCondit(2))) Then
                    '// formato numerico
                    If vCondit(2) Then
                        vCondit(2) = "=" & vCondit(2)
                    End If
                    vCondit(1) = "=" & vCondit(1)
                Else
                    '// formato stringa
                    If vCondit(2) Then
                        vCondit(2) = "=""" & vCondit(2) & """"
                    End If
                    vCondit(1) = "=""" & vCondit(1) & """"
                End If
                '// applica formattazione condizionale
                Selection.FormatConditions.Add xlCellValue, vOperator, vCondit(1), vCondit(2)
                Selection.FormatConditions(1).SetFirstPriority
                With Selection.FormatConditions(1).Interior
                    .PatternColorIndex = xlAutomatic
                    If vColorHL(lCol) Then
                        .Color = vColorHL(lCol)
                    Else
                        .Color = "65535" '// default giallo
                    End If
                End With
                Selection.FormatConditions(1).StopIfTrue = True
            Else
                With Selection.Interior
                    .Pattern = xlPatternNone
                    .PatternColorIndex = xlColorIndexNone
                    If vColorHL(lCol) Then
                        .Color = vColorHL(lCol)
                    Else
                        .Color = "65535" '// default giallo
                    End If
                End With
            End If
        Next lCol

        '// controllo sequenza numerazione
        If lColToChkSeq Then
            lCorrectNo = Val(Cells(lRowHead + 1, lColToChkSeq).Value)
            lRow = lRowHead + 2
            Do
                lCorrectNo = lCorrectNo + 1
                lCurrentNo = Val(Cells(lRow, lColToChkSeq).Value)
                If lCurrentNo <> lCorrectNo Then
                    Rows(lRow).Select
                    Selection.Insert
                    With Selection.Interior
                        .Pattern = xlPatternNone
                        .PatternColorIndex = xlColorIndexNone
                        .Color = 255 '// rosso
                    End With
                    lRowsXls = lRowsXls + 1
                    '// numbero mancante
                    Cells(lRow, lColToChkSeq).Value = Val(lCorrectNo)
                    For lCol = 1 To lMaxColToChk
                        '// altre colonne da riportare per numero mancante
                        Cells(lRow, vColToChkKey(lCol)).Value = Cells(lRow - 1, vColToChkKey(lCol)).Value
                    Next lCol
                    If lColToChkDate Then
                        '// range date
                        lCur = lRow
                        Do
                            lCur = lCur - 1
                        Loop While Len(CStr(Cells(lCur, lColToChkDate).Value)) > 10
                        sValidDateFr = CStr(Cells(lCur, lColToChkDate).Value)
                        sValidDateTo = CStr(Cells(lRow + 1, lColToChkDate).Value)
                        Cells(lRow, lColToChkDate).Value = sValidDateFr & "-" & sValidDateTo
                    End If
                End If
                lRow = lRow + 1
            Loop Until lRow > lRowsXls
        End If

        '// funzione Sap Posting: elimino le colonne account per cui sono state inserite nuove righe
        If lMaxSapPost Then
            For lCur = 1 To lColSapNA
                Columns(lMaxColXls).Select
                Selection.Delete
                lMaxColXls = lMaxColXls - 1
            Next lCur
        End If

        '// funzione Sap Posting Header: inserisce tre righe e imposta la testata SAP
        If lMaxSapHD Then
            Rows(1).Select
            For lCur = 1 To lSapHeaderL
                Selection.Insert
                lRowsXls = lRowsXls + 1
                lRowHead = lRowHead + 1
            Next lCur
            For lCur = 1 To lMaxSapHD
                Cells(1, lCur).Value = CStr(vSapHeaderD(lCur))
            Next lCur
            sCompanyCode = GetFieldFromKey(TxtWS.Cells(gklData_Row_Info, gkiData_Col_TotQuery), gksCharSepKeyQuery, gklPosAzienda_Code)
            For lCur = 1 To lMaxSapHV
                Select Case CStr(vSapHeaderV(lCur))
                Case "$COMPANY"
                    vSapHeaderV(lCur) = sCompanyCode
                Case "$CURRENCY"
                    Select Case sCompanyCode
                    Case "027", "039", "047", "084", "093"
                        vSapHeaderV(lCur) = "JPY"
                    Case "029", "077"
                        vSapHeaderV(lCur) = "CNY"
                    Case "018", "062", "097"
                        vSapHeaderV(lCur) = "CHF"
                    Case "045", "064", "075", "088", "089"
                        vSapHeaderV(lCur) = "GBP"
                    Case "069"
                        vSapHeaderV(lCur) = "SEK"
                    Case "028", "044", "071", "079", "082", "086"
                        vSapHeaderV(lCur) = "USD"
                    Case "083"
                        vSapHeaderV(lCur) = "NOK"
                    Case "090"
                        vSapHeaderV(lCur) = "DKK"
                    Case "032", "048", "087", "091", "092"
                        vSapHeaderV(lCur) = "HKD"
                    Case Else
                        vSapHeaderV(lCur) = "EUR"
                    End Select
                End Select
                Cells(2, lCur).Value = gksChar_Apice & CStr(vSapHeaderV(lCur))
            Next lCur
        End If

        '// inserisce filtro automatico
        If InStr(1, sDefaultToOmit, ";AF;", vbTextCompare) = 0 Then
            Rows(lRowHead).Select
            Selection.AutoFilter
            If lMaxFilterFL Then
                GoSub srFilter
            End If
        End If

        '// allineamento a sinistra e larghezza automatica colonne
        Rows(lRowHead).Select
        Selection.HorizontalAlignment = xlLeft
        Columns.AutoFit

        '// funzioni format colonna: formato numero, allineamento orizzontale
        For lCol = 1 To lMaxColToFmt
            Columns(vColToFmt(lCol)).Select
            If vArrNumFmt(lCol) <> "" Then
                Selection.NumberFormat = vArrNumFmt(lCol)
            End If
            If vArrColHAl(lCol) <> "" Then
                Select Case vArrColHAl(lCol)
                Case "AC"
                    Selection.HorizontalAlignment = xlCenter
                Case "AL"
                    Selection.HorizontalAlignment = xlLeft
                Case "AR"
                    Selection.HorizontalAlignment = xlRight
                End Select
            End If
        Next lCol

        '// inserimento titolo report
        If lColTitle Then
            Rows(1).Select '// riga titolo
            Selection.Insert
            lRowsXls = lRowsXls + 1
            lRowHead = lRowHead + 1
            Cells(1, lColTitle).WrapText = False
            Cells(1, lColTitle).Value = sTitle
            FormatThisCell 1, lColTitle, xlLeft, lCpiTitle, True, False, False, gklColor_DarkBlue
            SetRowHeight 1, lCpiTitle + Int(lCpiTitle * 25 / 100 + 0.99), False
            For lCol = 1 To lBlkLns '// blank lines
                Rows(2).Select
                Selection.Insert
                lRowsXls = lRowsXls + 1
                lRowHead = lRowHead + 1
            Next lCol
        End If

        '// inserimento riga con societ|fffd|, query, data e ora
        If InStr(1, sDefaultToOmit, ";QDT;", vbTextCompare) = 0 Then
            Rows(1).Select
            Selection.Insert
            lRowsXls = lRowsXls + 1
            lRowHead = lRowHead + 1
            If lColTitle = 0 Then
                Selection.Insert
                lRowsXls = lRowsXls + 1
                lRowHead = lRowHead + 1
            End If
            Cells(1, 1).Value = GetFieldFromKey(TxtWS.Cells(gklData_Row_Info, gkiData_Col_TotQuery), gksCharSepKeyQuery, gklPosAzienda_Code) & " " & _
                                Trim$(GetFieldFromKey(TxtWS.Cells(gklData_Row_Info, gkiData_Col_AziendaDesc), gksCharSepKeyQuery, 1)) & " [ " & _
                                GetFieldFromKey(TxtWS.Cells(gklData_Row_Info, gkiData_Col_TotQuery), gksCharSepKeyQuery, gklPosQuery_Code) & " ] " & _
                                Format$(TxtWS.Cells(gklData_Row_Info, gkiData_Col_DataLancio), sDateFormat) & " " & _
                                Format$(TxtWS.Cells(gklData_Row_Info, gkiData_Col_OraLancio), "Hh:Nn:Ss") & " [ " & _
                                TxtWS.Cells(gklData_Row_Info, gkiData_Col_IdRichiesta) & " - " & _
                                TxtWS.Cells(gklData_Row_Info, gkiData_Col_IdLancio) & " ]"
            FormatThisCell 1, 1, xlLeft, gwlFormatCPI, True, False, False, gklColor_DarkBlue
        End If

        '// funzione COL-EXPAND: inserimento colonne e dati formattati
        If lColToExp Then
            Columns(lColToExp + 1).Select
            Selection.Delete
            lMaxColToExp = lMaxColToExp - 1
            For lCur = 1 To lMaxColToExp
                Selection.Insert
            Next lCur
            For lCur = 1 To lMaxColToExp
                Cells(lRowHead, lColToExp + lCur).Value = Replace(CStr(Cells(lRowHead, lColToExp).Value), "1", CStr(lCur + 1), 1, 1, vbBinaryCompare)
            Next lCur
            For lCur = 1 To lDataToExpCntr
                Select Case lFmtArr(lColToExp)
                Case 2 '// number
                    dValue = ConvNum(vDataExpanded(lCur))
                    If dValue Then
                        Cells(lRowExpanded(lCur) + lRowHead, lColExpanded(lCur)).Value = dValue
                    End If
                Case 3 '// date
                    sTmpDate = vDataExpanded(lCur)
                    Cells(lRowExpanded(lCur) + lRowHead, lColExpanded(lCur)).Value = GetDateFromString(sTmpDate, sDateFormat)
                Case Else '// string
                    Cells(lRowExpanded(lCur) + lRowHead, lColExpanded(lCur)).Value = gksChar_Apice & CStr(vDataExpanded(lCur))
                End Select
            Next lCur
            For lCur = 1 To lMaxColToExp
                Columns(lColExpanded(lCur)).AutoFit
            Next lCur
        End If

        '// funzione LOADPICS: carica immagini per riga
        If lColPics Then
            '// display pulsante
            Call AddLoadPicsButton
            '// ricalcolo ultima riga foglio (nel caso ne siano state cancellate)
            lRowsXls = ActiveSheet.Cells(Rows.Count, lColPics).End(xlUp).Row
            '// info in commento cella
            Cells(1, 1).AddComment.Text _
            Format$(CStr(lColPics), "!@@@") & _
            Format$(CStr(lColComm), "!@@@") & _
            Format$(CStr(lPicBrkk), "!@@@") & _
            Format$(CStr(lFamBrkk), "!@@@") & _
            Format$(CStr(lRowHead + 1), "!@@@") & _
            Format$(CStr(lRowsXls), "!@@@@@@@") & _
            "0" & _
            Format$(CStr(lPicRowHeight), "!@@@") & _
            Format$(CStr(lMaxLineWarning), "!@@@") & _
            Format$(CStr(lMaxLineLoopExec), "!@@@") & _
            Format$(CStr(CInt(bAskLoadPassword)), "!@") & _
            Format$(CStr(sLoadPassword), "!@@@@")
            Cells(1, 1).Comment.Visible = False
        End If
        
        '// toglie griglia
        If InStr(1, sDefaultToOmit, ";DG;", vbTextCompare) = 0 Then
            ActiveWindow.DisplayGridlines = False
        End If

        '// blocca riga testata
        If InStr(1, sDefaultToOmit, ";FP;", vbTextCompare) = 0 Then
            Cells(lRowHead + 1, 1).Select
            ActiveWindow.FreezePanes = True
        End If

        '// imposta parametri di stampa
        If sPrtParams <> "" Then
            If InStr(1, sPrtParams, ";TR=A;", vbTextCompare) Then
                '// opzione TR=A: ripete testata con righe dalla 1 a intestazione colonne
                sPrtParams = Replace(sPrtParams, ";TR=A;", ";TR=A" & CStr(lRowHead) & ";", 1, 1, vbTextCompare)
            End If
            If InStr(1, sPrtParams, ";TR=H;", vbTextCompare) Then
                '// opzione TR=H: ripete testata con riga intestazione colonne
                sPrtParams = Replace(sPrtParams, ";TR=H;", ";TR=H" & CStr(lRowHead) & ";", 1, 1, vbTextCompare)
            End If
            frmWait.SetMsg "Setting Printing Parameters..."
            'DoEvents
            Call SetPrintingParameters(sPrtParams)
        End If
        
        '// pulsante Copy and SaveAs
        If bFileSaveAs Then
            Call AddButtons_SAVEAS(False)
        End If

        '// info e pulsanti per gestione PDF
        If lColIdPdf Then
            '// info: prima riga dati, colonna ID PDF, colonna nome file PDF
            Cells(1, 1).AddComment.Text _
            Format$(CStr(lRowHead + 1), "!@@@") & _
            Format$(CStr(lColIdPdf), "!@@@") & _
            Format$(CStr(lColIdPdf + 1), "!@@@") & _
            Format$(sFileExtn, "!@@@@@")
            Cells(1, 1).Comment.Visible = False
            '// crea bottoni per gestione PDF
            Call AddButtons_WRKPDF(False)
        End If

        '// pulisce cella per non rieseguire la macro
        If Cells(lRowHead + gklRow_MacroExe, gklCol_MacroExe).Value = gksValue_MacroExe Then
            Cells(lRowHead + gklRow_MacroExe, gklCol_MacroExe).Value = Null
        End If
        
        '// protezione celle
        If lMaxColToPrtc Then
        
            '// sprotezione tutte le celle del foglio
            Cells.Select
            Selection.Locked = False
            Selection.FormulaHidden = False
    
            For lCol = 1 To lMaxColToPrtc
                
                '// calcolo range
                sRangeArea = Right$(vColToPrtc(lCol), Len(vColToPrtc(lCol)) - 1)
                lCur = InStr(1, sRangeArea, "&", vbTextCompare)
                If lCur Then
                    sRangeFr = Mid$(sRangeArea, 1, lCur - 1)
                    sRangeTo = Mid$(sRangeArea, lCur + 1, Len(sRangeArea) - lCur)
                Else
                    sRangeFr = sRangeArea
                    sRangeTo = sRangeArea
                End If
                
                '// calcolo area range e selezione range
                sRangeDim = Left$(vColToPrtc(lCol), 1)
                Select Case sRangeDim
                Case "C" '// colonna o range di colonne
                    sRangeArea = Chr$(64 + CInt(sRangeFr)) & ":" & Chr$(64 + CInt(sRangeTo))
                    Columns(sRangeArea).Select
                Case "R" '// riga o range di righe
                    sRangeArea = sRangeFr & ":" & sRangeTo
                    Rows(sRangeArea).Select
                Case "K" '// cella o range di celle
                    lCur = InStr(1, sRangeFr, ",", vbTextCompare)
                    sRangeFr = Chr$(64 + CInt(Left$(sRangeFr, lCur - 1))) & Right$(sRangeFr, Len(sRangeFr) - lCur)
                    lCur = InStr(1, sRangeTo, ",", vbTextCompare)
                    sRangeTo = Chr$(64 + CInt(Left$(sRangeTo, lCur - 1))) & Right$(sRangeTo, Len(sRangeTo) - lCur)
                    sRangeArea = sRangeFr & ":" & sRangeTo
                    Range(sRangeArea).Select
                End Select
                
                '// protezione celle selezionate
                Selection.Locked = True
                Selection.FormulaHidden = False
    
            Next lCol
            
            '// protezione foglio
            ActiveSheet.Protect AllowFiltering:=True
        
        End If

        '// esegue "LoadPics"
        If bRunLoadPics Then
            Call srLoadPics
        End If

        '// esegue "ShowPics"
        If bRunShowPics Then
            Call srPicsVisible
        End If

        '// imposta keyboard shortcut
        Application.OnKey "^+{INSERT}", "FileSaveAs"
        
        '// elaborazione terminata senza errori
        GetDataIntoWorkBook = True

    End If

lblError:
    If bAddOnOpened And (lColBarcode + lColMadeIn + lColAddOn) Then
        bAddOnSaved = pfAddOnSaveDatabase()
        If Not bAddOnSaved Then
            MsgBox "WARNING: AddOn Counters File Not Saved!", vbOKOnly + vbInformation, "AddOn Management"
        End If
    End If
    
    If Err Then
        MsgBox "Excel Error No." & Err & ": " & Error$(Err), vbOKOnly + vbCritical, "Excel Template Error"
    End If

    '// chiude progress bar
    frmWait.CloseForm
    Cells(lRowHead + 1, 1).Select
    'DoEvents
    'ThisWorkbook.Activate

    Exit Function
    
srColToZero:
    '// gestione funzioni TO-TEST & TO-ZERO
    sTestBrkKey = ""
    '// costruzione chiave di rottura
    For lCol = 1 To lMaxColToTest
        sTestBrkKey = sTestBrkKey & TxtWS.Cells(lRowTxt, vColToTest(lCol))
    Next lCol
    '// azzeramento colonne
    If sTestBrkKey = sZeroBrkKey Then
        For lCol = 1 To lMaxColToZero
            Cells(lRowXls, vColToZero(lCol)).Value = ""
        Next lCol
    End If
    sZeroBrkKey = sTestBrkKey
Return

srBreakOnTotalOn:
    '// funzioni BREAK-ON & TOTAL-ON
    If lRowXls Then
        '// somma colonne subtotali
        For lCol = 1 To lMaxColToTot
            If lFmtArr(vColToTot(lCol)) = 2 Then '// number
                dColSubTot(lCol) = dColSubTot(lCol) + CDbl(Cells(lRowXls, vColToTot(lCol)).Value)
            End If
        Next lCol
    End If
    '// costruzione chiave di rottura
    sCurrColToBrk = ""
    For lCol = 1 To lMaxColToBrk
        sCurrColToBrk = sCurrColToBrk & TxtWS.Cells(lRowTxt, vColToBrk(lCol))
    Next lCol
    If sCurrColToBrk <> sPrevColToBrk Then
        sPrevColToBrk = sCurrColToBrk
        If lRowXls Then
            '// stampa riga subtotali
            lRowXls = lRowXls + 1
            For lCol = 1 To lMaxColToTot
                Select Case lFmtArr(vColToTot(lCol))
                Case 2 '// number
                    Cells(lRowXls, vColToTot(lCol)).Value = dColSubTot(lCol)
                    dColSubTot(lCol) = 0
                Case 3 '// date
                    sTmpDate = Cells(lRowXls - 1, vColToTot(lCol)).Value
                    Cells(lRowXls, vColToTot(lCol)).Value = GetDateFromString(sTmpDate, sDateFormat)
                Case Else '// string
                    Cells(lRowXls, vColToTot(lCol)).Value = gksChar_Apice & Cells(lRowXls - 1, vColToTot(lCol)).Value
                End Select
            Next lCol
            '// formatta riga subtotali
            SetThisRange_Line lRowXls, 1, lRowXls, lMaxColXls, , , , , , , xlContinuous, xlThin
            FormatThisRow lRowXls, gwlFormatCPI, True, False, False, False
            Range(Cells(lRowXls, 1), Cells(lRowXls, lMaxColXls)).Select
            With Selection.Interior
                .Pattern = xlPatternNone
                .PatternColorIndex = xlColorIndexNone
                .Color = "65535" '// giallo per default
            End With
        End If
    End If
Return

srPageBreak:
    '// costruzione chiave di rottura
    sCurrColPageBrk = ""
    For lCol = 1 To lMaxColPageBrk
        sCurrColPageBrk = sCurrColPageBrk & TxtWS.Cells(lRowTxt, vColPageBrk(lCol))
    Next lCol
    If sCurrColPageBrk <> sPrevColPageBrk Then
        sPrevColPageBrk = sCurrColPageBrk
        If lRowXls Then
            Cells(lRowXls + 1, 1).Select
            ActiveWindow.SelectedSheets.HPageBreaks.Add Before:=ActiveCell
        End If
    End If
Return

srSapPosting:
    '// funzioni per formatazione file SAP-POSTING
    lRow = lRowXls
    For lCur = 1 To lColSapNA
        '// inserimento riga
        Rows(lRow).Select
        Selection.Copy
        Selection.Insert Shift:=xlDown
        Application.CutCopyMode = False
        lRowXls = lRowXls + 1
        '// cambio account
        Cells(lRow + 1, lColSapCA).Value = gksChar_Apice & Cells(lRow + 1, lMaxColXls - lCur + 1).Value
        '// cambio segno
        lCol = 1
        Do
            If lColSapCS(lCol) = 0 Then Exit Do
            If IsNumeric(Cells(lRow + 1, lColSapCS(lCol)).Value) Then
                Cells(lRow + 1, lColSapCS(lCol)).Value = Cells(lRow + 1, lColSapCS(lCol)).Value * -1
            End If
            lCol = lCol + 1
        Loop
        '// imposta celle
        lCol = 1
        Do
            If vColSapVC(lCol) = 0 Then Exit Do
            lPosSep(1) = InStr(1, vColSapVC(lCol), "=", vbTextCompare)
            lCel = Left$(vColSapVC(lCol), lPosSep(1) - 1)
            sValue = Right$(vColSapVC(lCol), Len(vColSapVC(lCol)) - lPosSep(1))
            If sValue = "''" Then sValue = ""
            Cells(lRow + 1, lCel).Value = sValue
            lCol = lCol + 1
        Loop
    Next lCur
Return

srFilter:
    '// applica filtro a colonna
    For lCol = 1 To lMaxFilterFL
        
        Select Case vFilterOP(lCol)
        Case "AND"
            vOperator = xlAnd
        Case "OR"
            vOperator = xlOr
'// Excel 2007 only - Begin
        Case "CC"
            vOperator = xlFilterCellColor
        Case "FC"
            vOperator = xlFilterFontColor
        Case "FV"
            vOperator = xlFilterValues
'// Excel 2007 only - End
        Case Else
            vOperator = False
        End Select
        
        Select Case vOperator
        Case False
            Selection.AutoFilter vFilterFL(lCol), vFilterC1(lCol), , , True
        Case xlAnd, xlOr
            Selection.AutoFilter vFilterFL(lCol), vFilterC1(lCol), vOperator, vFilterC2(lCol), True
'// Excel 2007 only - Begin
        Case xlFilterValues
            vFilterC1(lCol) = Replace(vFilterC1(lCol), ",", ";", 1, -1, vbBinaryCompare)
            Call GetDataFromFunctions(vFilterC1(lCol) & ";", lVoid, vFilterFV(), vbString)
            Selection.AutoFilter vFilterFL(lCol), vFilterFV, vOperator, , True
'// Excel 2007 only - End
        Case Else
            Selection.AutoFilter vFilterFL(lCol), vFilterC1(lCol), vOperator, , True
        End Select
        
    Next lCol
Return

End Function

Public Sub GetDataFromFunctions(ByVal sFuncFields As String, ByRef lFuncFieldsCounters As Long, ByRef vFuncFields() As Variant, ByVal iVarType As Integer)

Dim bRange As Boolean
Dim bColDec As Boolean
Dim iStrLen As Integer
Dim iStrPos As Integer
Dim lCurIx As Long
Dim lRngFr As Long
Dim lRngTo As Long
Dim sStrFld As String
Dim sStrChr As String

    If Left$(sFuncFields, 6) = "ColDec" Then
        bColDec = True
        sFuncFields = Right$(sFuncFields, Len(sFuncFields) - 6)
    End If
    
    iStrLen = Len(sFuncFields)
    lFuncFieldsCounters = 0
    sStrFld = ""
    
    For iStrPos = 1 To iStrLen
        sStrChr = Mid$(sFuncFields, iStrPos, 1)
        Select Case sStrChr
        Case ";"
            If bRange Then
                lRngTo = CLng(sStrFld)
                For lCurIx = lRngFr To lRngTo
                    lFuncFieldsCounters = lFuncFieldsCounters + 1
                    vFuncFields(lFuncFieldsCounters) = lCurIx
                Next lCurIx
                bRange = False
            Else
                If bColDec Then
                    GoSub srColorDecode
                End If
                If Left$(sStrFld, 1) = "D" Then
                    '// opzione "D" colonna range di date CHK_SEQ
                    sStrFld = "-" & Right$(sStrFld, Len(sStrFld) - 1)
                End If
                lFuncFieldsCounters = lFuncFieldsCounters + 1
                GoSub srVarTypeDecode
            End If
            sStrFld = ""
        Case "-"
            bRange = True
            lRngFr = CLng(sStrFld)
            sStrFld = ""
        Case Else
            sStrFld = sStrFld & sStrChr
        End Select
    Next iStrPos

    Exit Sub

srVarTypeDecode:
    Select Case iVarType
    Case vbInteger: vFuncFields(lFuncFieldsCounters) = CInt(sStrFld)
    Case vbLong:    vFuncFields(lFuncFieldsCounters) = CLng(sStrFld)
    Case vbSingle:  vFuncFields(lFuncFieldsCounters) = CSng(sStrFld)
    Case vbDouble:  vFuncFields(lFuncFieldsCounters) = CDbl(sStrFld)
    Case vbDate:    vFuncFields(lFuncFieldsCounters) = CDate(sStrFld)
    Case vbString:  vFuncFields(lFuncFieldsCounters) = CStr(sStrFld)
    Case vbBoolean: vFuncFields(lFuncFieldsCounters) = CBool(sStrFld)
    Case vbVariant: vFuncFields(lFuncFieldsCounters) = CVar(sStrFld)
    End Select
Return

srColorDecode:
    Select Case sStrFld
    Case "DARK_RED"
        sStrFld = "192"
    Case "RED"
        sStrFld = "255"
    Case "ORANGE"
        sStrFld = "49407"
    Case "YELLOW"
        sStrFld = "65535"
    Case "LIGHT_GREEN"
        sStrFld = "5296274"
    Case "GREEN"
        sStrFld = "5287936"
    Case "LIGHT_BLUE"
        sStrFld = "15773696"
    Case "BLUE"
        sStrFld = "12611584"
    Case "DARK_BLUE"
        sStrFld = "6299648"
    Case "VIOLET"
        sStrFld = "10498160"
    Case Else
        If Not IsNumeric(sStrFld) Then
            sStrFld = "0"
        End If
    End Select
Return

End Sub

Public Sub SetPrintingParameters(sPrintingParameters As String)

Dim sLH As String
Dim sCH As String
Dim sRH As String
Dim sLF As String
Dim sCF As String
Dim sRF As String
Dim sChr As String
Dim sVal As String
Dim sTitleRows As String

Dim lPos As Long
Dim lTitleRows As Long
Dim lOrientation As Long
Dim lPrintComments As Long

Dim dLM As Double
Dim dRM As Double
Dim dTM As Double
Dim dBM As Double
Dim dHM As Double
Dim dFM As Double

Dim vZoom As Variant
Dim vFitToWide As Variant

    '// orientamento foglio
    lOrientation = ActiveSheet.PageSetup.Orientation
    lPos = InStr(1, sPrintingParameters, ";OR=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        lOrientation = CLng(sVal)
        If lOrientation <> xlLandscape And lOrientation <> xlPortrait Then
            lOrientation = ActiveSheet.PageSetup.Orientation
        End If
    End If
    
    '// adatta a larghezza pagina
    vZoom = 100
    vFitToWide = False
    lPos = InStr(1, sPrintingParameters, ";FW=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        vFitToWide = CLng(sVal)
        If vFitToWide Then
            vFitToWide = 1
            vZoom = False
        End If
    End If
    
    '// righe titolo
    sTitleRows = ""
    lPos = InStr(1, sPrintingParameters, ";TR=", vbTextCompare)
    If lPos Then
        sVal = Mid$(sPrintingParameters, lPos + 4, 9)
        sVal = Left$(sVal, InStr(1, sVal, ";", vbTextCompare) - 1)
        Select Case Left$(sVal, 1)
        Case "A"
            lTitleRows = CLng(Mid$(sVal, 2, 9))
            sTitleRows = "$1:$" & CStr(lTitleRows)
        Case "H"
            lTitleRows = CLng(Mid$(sVal, 2, 9))
            sTitleRows = "$" & CStr(lTitleRows) & ":$" & CStr(lTitleRows)
        Case Else
            GoSub srParameterDecode
            lTitleRows = CLng(sVal)
            If lTitleRows Then
                sTitleRows = "$1:$" & CStr(lTitleRows)
            End If
        End Select
    End If

    '// stampa commenti
    lPrintComments = ActiveSheet.PageSetup.PrintComments
    lPos = InStr(1, sPrintingParameters, ";PC=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        Select Case sVal
        Case "IP"
            lPrintComments = xlPrintInPlace
        Case "NC"
            lPrintComments = xlPrintNoComments
        Case "SE"
            lPrintComments = xlPrintSheetEnd
        End Select
    End If
    
    '// Left Margin
    lPos = InStr(1, sPrintingParameters, ";LM=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        dLM = Application.CentimetersToPoints(CDbl(sVal))
    End If
    If dLM = 0 Then
        dLM = ActiveSheet.PageSetup.LeftMargin
    End If
    
    '// Right Margin
    lPos = InStr(1, sPrintingParameters, ";RM=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        dRM = Application.CentimetersToPoints(CDbl(sVal))
    End If
    If dRM = 0 Then
        dRM = ActiveSheet.PageSetup.RightMargin
    End If
    
    '// Top Margin
    lPos = InStr(1, sPrintingParameters, ";TM=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        dTM = Application.CentimetersToPoints(CDbl(sVal))
    End If
    If dTM = 0 Then
        dTM = ActiveSheet.PageSetup.TopMargin
    End If
    
    '// Bottom Margin
    lPos = InStr(1, sPrintingParameters, ";BM=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        dBM = Application.CentimetersToPoints(CDbl(sVal))
    End If
    If dBM = 0 Then
        dBM = ActiveSheet.PageSetup.BottomMargin
    End If
    
    '// Header Margin
    lPos = InStr(1, sPrintingParameters, ";HM=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        dHM = Application.CentimetersToPoints(CDbl(sVal))
    End If
    If dHM = 0 Then
        dHM = ActiveSheet.PageSetup.HeaderMargin
    End If
    
    '// Footer Margin
    lPos = InStr(1, sPrintingParameters, ";FM=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        dFM = Application.CentimetersToPoints(CDbl(sVal))
    End If
    If dFM = 0 Then
        dFM = ActiveSheet.PageSetup.FooterMargin
    End If

    '// Left Header
    sLH = ""
    lPos = InStr(1, sPrintingParameters, ";LH=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        sLH = sVal
    End If

    '// Center Header
    sCH = ""
    lPos = InStr(1, sPrintingParameters, ";CH=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        sCH = sVal
    End If

    '// Right Header
    sRH = ""
    lPos = InStr(1, sPrintingParameters, ";RH=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        sRH = sVal
    End If

    '// Left Footer
    sLF = ""
    lPos = InStr(1, sPrintingParameters, ";LF=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        sLF = sVal
    End If

    '// Center Footer
    sCF = ""
    lPos = InStr(1, sPrintingParameters, ";CF=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        sCF = sVal
    End If

    '// Right Footer
    sRF = ""
    lPos = InStr(1, sPrintingParameters, ";RF=", vbTextCompare)
    If lPos Then
        GoSub srParameterDecode
        sRF = sVal
    End If

    '// impostazione parametri
    With ActiveSheet.PageSetup
        .PrintTitleRows = sTitleRows
        .PrintTitleColumns = ""
    End With
    ActiveSheet.PageSetup.PrintArea = ""
    With ActiveSheet.PageSetup
        .LeftHeader = sLH
        .CenterHeader = sCH
        .RightHeader = sRH
        .LeftFooter = sLF
        .CenterFooter = sCF
        .RightFooter = sRF
        .LeftMargin = dLM
        .RightMargin = dRM
        .TopMargin = dTM
        .BottomMargin = dBM
        .HeaderMargin = dHM
        .FooterMargin = dFM
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = lPrintComments
'//        .PrintQuality = 600
        .CenterHorizontally = True
        .CenterVertically = False
        .Orientation = lOrientation
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = vZoom
        .FitToPagesWide = vFitToWide
        .FitToPagesTall = False
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = ""
        .EvenPage.CenterHeader.Text = ""
        .EvenPage.RightHeader.Text = ""
        .EvenPage.LeftFooter.Text = ""
        .EvenPage.CenterFooter.Text = ""
        .EvenPage.RightFooter.Text = ""
        .FirstPage.LeftHeader.Text = ""
        .FirstPage.CenterHeader.Text = ""
        .FirstPage.RightHeader.Text = ""
        .FirstPage.LeftFooter.Text = ""
        .FirstPage.CenterFooter.Text = ""
        .FirstPage.RightFooter.Text = ""
    End With

    Exit Sub

srParameterDecode:
    '// decodifica parametro di stampa
    lPos = lPos + 4
    sVal = ""
    Do
        sChr = Mid$(sPrintingParameters, lPos, 1)
        If sChr = ";" Then
            Exit Do
        End If
        sVal = sVal & sChr
        lPos = lPos + 1
    Loop Until Null
Return

End Sub

Public Function GetQuoteStrippedValueFromCell(ByVal vCellValueToStrip As Variant) As Variant

    If Left$(vCellValueToStrip, 1) = gksChar_Apice Then
        vCellValueToStrip = Right$(vCellValueToStrip, Len(vCellValueToStrip) - 1)
    End If
    GetQuoteStrippedValueFromCell = vCellValueToStrip

End Function

Function VSizesDataSet(ByRef MyWB As Workbook, lTotCol As Long, lTotRow As Long) As Boolean

Dim TxtWS As Worksheet

Dim iOutFileNo As Integer

Dim lRow As Long
Dim lCol As Long
Dim lBodyCol As Long
Dim lSizeCol As Long
Dim lTotFunc As Long

Dim sOutLine As String
Dim sBodyLine As String
Dim sOutFName As String
Dim sFuncName As String
Dim sFuncLine As String

    VSizesDataSet = False
    On Error GoTo lblError

    '// progress bar
    frmWait.SetMsg "Building Sizes DataSet... "
    'DoEvents
    'ThisWorkbook.Activate

    '// puntatore foglio dati origine
    Set TxtWS = MyWB.ActiveSheet

    '// file da aprire in overwrite per scrivere record con taglie verticalizzate
    sOutFName = Environ$(Left(gksEnvr_Temp, 4)) & "\" & gksVSIZES_FileName & gksData_EstensioneFile
    iOutFileNo = FreeFile
    Open sOutFName For Output As #iOutFileNo
     
    '// salva stringa funzioni
    lTotFunc = 0
    sFuncLine = ""
    lCol = lTotCol + 1
    sFuncName = TxtWS.Cells(4, lCol).Value
    Do While Left$(sFuncName, 1) = "@"
        If Left$(sFuncName, 7) <> "@VSIZES" Then
            sFuncLine = sFuncLine & sFuncName & vbTab
            lTotFunc = lTotFunc + 1
        End If
        lCol = lCol + 1
        sFuncName = TxtWS.Cells(4, lCol).Value
    Loop

    '// nuovi numeri righe e colonne del file dati
    lTotCol = lTotCol - 57
    TxtWS.Cells(1, 1).Value = 20 * (lTotRow - 4)
    TxtWS.Cells(1, 2).Value = lTotCol + lTotFunc

    '// scrittura righe 1-4
    For lRow = 1 To 4
        sOutLine = ""
        For lCol = 1 To lTotCol
            sOutLine = sOutLine & TxtWS.Cells(lRow, lCol).Value & vbTab
        Next lCol
        '// aggiunge stringa funzioni alla riga 4
        If lRow = 4 Then
            sOutLine = sOutLine & sFuncLine
        End If
        Print #iOutFileNo, sOutLine
    Next lRow

    '// scrittura righe dalla 5 in poi
    lBodyCol = lTotCol - 3
    For lRow = 5 To lTotRow

        sBodyLine = ""
        For lCol = 1 To lBodyCol
            sBodyLine = sBodyLine & TxtWS.Cells(lRow, lCol).Value & vbTab
        Next lCol

        lSizeCol = lBodyCol
        For lCol = 1 To 20
            '// solo taglie con quantit|fffd| > 0
            If Val(GetQuoteStrippedValueFromCell(TxtWS.Cells(lRow, lSizeCol + 1).Value)) Then
                sOutLine = sBodyLine
                lSizeCol = lSizeCol + 1
                sOutLine = sOutLine & TxtWS.Cells(lRow, lSizeCol).Value & vbTab
                lSizeCol = lSizeCol + 1
                sOutLine = sOutLine & TxtWS.Cells(lRow, lSizeCol).Value & vbTab
                lSizeCol = lSizeCol + 1
                sOutLine = sOutLine & TxtWS.Cells(lRow, lSizeCol).Value
                Print #iOutFileNo, sOutLine
            Else
                lSizeCol = lSizeCol + 3
            End If
        Next lCol

        '// progress bar
        If lRow Mod 100 = 0 Then
            frmWait.SetMsg "Building Sizes DataSet: line " & lRow & " of " & lTotRow & " lines"
            'DoEvents
            'ThisWorkbook.Activate
        End If

    Next lRow

    '// Close the file
    Close #iOutFileNo

    '// progress bar
    frmWait.SetMsg "Building Sizes DataSet Completed."
    'DoEvents
    'ThisWorkbook.Activate

    '// uscita ok
    VSizesDataSet = True
    Exit Function

lblError:
    Close #iOutFileNo
    MsgBox "Undefined error while processing VSIZES function.", vbOKOnly + vbCritical, "Excel Template Error"
    VSizesDataSet = False

End Function

Private Sub AddLoadPicsButton()

Dim btnLoadPics As Object

    Set btnLoadPics = ActiveSheet.Buttons.Add(480, 2, 60, 15) '// col,row,width,heigh
    With btnLoadPics
        .Caption = "Load Pictures"
        .Name = "btnLoadPics"
        .Placement = xlFreeFloating
        .PrintObject = False
        .OnAction = "srLoadPics"
        .Locked = False
    End With

    ActiveSheet.Shapes("btnLoadPics").Select
    With Selection.Font
        .Size = 8
    End With

End Sub

Private Sub AddPicsVisibleButton()

Dim btnPicsVisible As Object

    Set btnPicsVisible = ActiveSheet.Buttons.Add(480, 2, 60, 15) '// col,row,width,heigh
    With btnPicsVisible
        .Caption = "Show Pictures"
        .Name = "btnPicsVisible"
        .Placement = xlFreeFloating
        .PrintObject = False
        .OnAction = "srPicsVisible"
        .Locked = False
    End With

    ActiveSheet.Shapes("btnPicsVisible").Select
    With Selection.Font
        .Size = 8
    End With

End Sub

Private Sub srLoadPics()

Dim ShpBox As Shape
Dim ShpRng As ShapeRange
Dim RngPic As Range

Dim bPicsVisible As Boolean
Dim bAskLoadPassword As Boolean

Dim lRow As Long
Dim lRowFr As Long
Dim lRowTo As Long
Dim lColComm As Long
Dim lColPics As Long
Dim lPicBrkk As Long
Dim lLoadPic As Long
Dim lFamBrkk As Long
Dim lDelayTime As Long
Dim lPasswordTry As Long
Dim lPicsCounter As Long
Dim lPicRowHeight As Long
Dim lPicsCellWidth As Long
Dim lMaxLineWarning As Long
Dim lMaxLineLoopExec As Long

Dim sURLName As String
Dim sPicName As String
Dim sFamName As String
Dim sPrevPicName As String
Dim sPrevFamName As String
Dim sCommentText As String
Dim sLoadPassword As String
Dim sAskLoadPassword As String

    On Error Resume Next

    '// reperisce colonna pics, da riga a riga
    lColPics = CLng(Left$(Cells(1, 1).Comment.Text, 3))
    lColComm = CLng(Mid$(Cells(1, 1).Comment.Text, 4, 3))
    lPicBrkk = CLng(Mid$(Cells(1, 1).Comment.Text, 7, 3))
    lFamBrkk = CLng(Mid$(Cells(1, 1).Comment.Text, 10, 3))
    lRowFr = CLng(Mid$(Cells(1, 1).Comment.Text, 13, 3))
    lRowTo = CLng(Mid$(Cells(1, 1).Comment.Text, 16, 7))
    bPicsVisible = CBool(Mid$(Cells(1, 1).Comment.Text, 23, 1) = "1")
    lPicRowHeight = CLng(Mid$(Cells(1, 1).Comment.Text, 24, 3))
    lMaxLineWarning = CLng(Mid$(Cells(1, 1).Comment.Text, 27, 3))
    lMaxLineLoopExec = CLng(Mid$(Cells(1, 1).Comment.Text, 30, 3))
    bAskLoadPassword = CBool(Mid$(Cells(1, 1).Comment.Text, 33, 1))
    sLoadPassword = Mid$(Cells(1, 1).Comment.Text, 34, 4)
    
    '// set lRowTo con ultima riga attuale del foglio
    Application.CutCopyMode = False
    lRowTo = ActiveSheet.Cells(Rows.Count, 1).End(xlUp).Row
    Cells(lRowFr, 1).Select

    '// richiesta password
    If bAskLoadPassword Then
        Do
            lPasswordTry = lPasswordTry + 1
            sAskLoadPassword = Application.InputBox(Prompt:="Password ", _
                                                    Title:="Load Picture Password Request")
        Loop Until sAskLoadPassword = sLoadPassword Or lPasswordTry > 2
        If sAskLoadPassword <> sLoadPassword Then
            GoTo lblExitSub
        End If
    End If
    
    '// avviso supero lMaxLineWarning righe
    If lMaxLineWarning Then
        lRow = MsgBox("Please be aware that there are more than " & CStr(lMaxLineWarning) & " lines to process and therefore the loading of pictures could take long time to be executed!   ", _
               vbOKCancel + vbExclamation, "Warning about Pictures Loading")
        If lRow = 2 Then
            GoTo lblExitSub
        End If
    End If

    '// richiede altezza picture
    If lPicRowHeight = 0 Then
        Do
            lPicRowHeight = Application.InputBox(Prompt:="Picture Height in points (30-999, 30 points = 1 cm)" & vbLf & vbLf, _
                                                 Title:="Row and Picture Height", Default:="80", Type:=1)
        Loop While lPicRowHeight < 30 Or lPicRowHeight > 999
        If lPicRowHeight < 30 Or lPicRowHeight > 999 Then
            GoTo lblExitSub
        End If
    End If

    '// cancella pulsante
    ActiveSheet.Shapes("btnLoadPics").Select
    Selection.Delete

    '// aggiorna info: col pic, col com, URL break, FAM break, da riga, a riga, picsvisible, cellheight
    Cells(1, 1).Comment.Delete
    Cells(1, 1).AddComment.Text _
    Format$(CStr(lColPics), "!@@@") & _
    Format$(CStr(lColComm), "!@@@") & _
    Format$(CStr(lPicBrkk), "!@@@") & _
    Format$(CStr(lFamBrkk), "!@@@") & _
    Format$(CStr(lRowFr), "!@@@") & _
    Format$(CStr(lRowTo), "!@@@@@@@") & _
    Format$(CStr(Abs(bPicsVisible)), "!@") & _
    Format$(CStr(lPicRowHeight), "!@@@") & _
    Format$(CStr(lMaxLineWarning), "!@@@") & _
    Format$(CStr(lMaxLineLoopExec), "!@@@") & _
    Format$(CStr(CInt(bAskLoadPassword)), "!@") & _
    Format$(CStr(sLoadPassword), "!@@@@")
    '// display progress bar
    frmWait.Show vbModeless
    frmWait.SetMsg "Loading Picture 1 of " & lRowTo - lRowFr + 1
    'DoEvents
    
    For lRow = lRowFr To lRowTo

        '// flag carica immagine
        lLoadPic = True
        
        '// reperisce URL
        sURLName = GetQuoteStrippedValueFromCell(Cells(lRow, lColPics).Value)
        Cells(lRow, lColPics).ClearContents
        '// controllo URL
        If sURLName = "" Then
            Cells(lRow, lColPics).Value = "URL not found"
            lLoadPic = False
        End If

        '// controllo rottura Picture
        If lLoadPic And lPicBrkk > 0 Then
            sPicName = GetQuoteStrippedValueFromCell(Cells(lRow, lPicBrkk).Value)
            If sPicName = sPrevPicName Then
                lLoadPic = False
            End If
            '// chiave di rottura
            sPrevPicName = sPicName
        End If

        '// controllo rottura Family
        If lLoadPic And lFamBrkk > 0 Then
            sFamName = GetQuoteStrippedValueFromCell(Cells(lRow, lFamBrkk).Value)
            If sFamName = sPrevFamName Then
                lLoadPic = False
            End If
            '// chiave di rottura
            sPrevFamName = sFamName
        End If

        If lLoadPic Then
            '// carica picture
            Err = 0
            Set RngPic = Cells(lRow, lColPics)
            Set ShpBox = ActiveSheet.Shapes.AddPicture( _
                         Filename:=gwsURLPath & sURLName, _
                         LinkToFile:=False, _
                         SaveWithDocument:=True, _
                         Left:=RngPic.Left, _
                         Top:=RngPic.Top, _
                         Width:=True, _
                         Height:=True)
            If Err = 0 Then
                '// commento OK
                sCommentText = CStr(Cells(lRow, lColComm))
                GoSub srAddCommentOK

                '// update loaded pictures counter
                lPicsCounter = lPicsCounter + 1
                If lPicsCounter Mod lMaxLineLoopExec = 0 Then
                    '// ciclo di riposo 5 secondi
                    Application.Wait TimeSerial(Hour(Now), Minute(Now), Second(Now) + 5)
                End If
            Else
                '// commento KO
                sCommentText = "MISSING PICTURE"
                GoSub srAddCommentKO

            End If
        Else
            '// commento KO
            If sCommentText <> "MISSING PICTURE" Then
                sCommentText = "SAME AS ABOVE"
            End If
            GoSub srAddCommentKO
        End If

        '// commento non visibile
        Cells(lRow, lColPics).Comment.Visible = False

        '// update progress bar
        frmWait.SetMsg "Loading Picture " & lRow - lRowFr + 1 & " of " & lRowTo - lRowFr + 1
        'DoEvents

    Next lRow

    '// allineamento orizzontale al centro
    Rows(lRowFr & ":" & lRowTo).VerticalAlignment = xlCenter

    '// larghezza colonna pictures
    Columns(lColPics).ColumnWidth = lPicsCellWidth

    '// nasconde colonna commenti
    Columns(lColComm).Select
    Selection.EntireColumn.Hidden = True

    '// display pulsante
    Call AddPicsVisibleButton
    
    '// reset variabile errore (resume next)
    Err = 0

lblExitSub:
    '// chiude progress bar
    frmWait.Hide
    Cells(1, 1).Select
    Exit Sub

srAddCommentOK:
    '// attributi picture
    ShpBox.Placement = xlMoveAndSize
    ShpBox.ControlFormat.PrintObject = True
    ShpBox.LockAspectRatio = True
    ShpBox.Height = lPicRowHeight

    '// aggiunge commento
    If Cells(lRow, lColPics).Comment Is Nothing Then
        Cells(lRow, lColPics).AddComment (sCommentText)
        Cells(lRow, lColPics).Comment.Visible = True
        Cells(lRow, lColPics).Comment.Shape.Select True
        With Selection
            .HorizontalAlignment = xlLeft
            .VerticalAlignment = xlTop
            .ReadingOrder = xlContext
            .Orientation = xlUpward
            .AutoSize = False
            .Height = ShpBox.Height
            .Width = ShpBox.Width
            .Left = ShpBox.Left
            .Top = ShpBox.Top
        End With
    End If

    '// comment font size
    Cells(lRow, lColPics).Comment.Shape.TextFrame.Characters.Font.Size = 6
'    With Range("A1").Comment.Shape.TextFrame.Characters.Font
'      .Name = "Tahoma"
'      .Size = 11
'      .Bold = False
'      .Italic = False
'      .Color = RGB(255, 255, 255)
'    End With

    '// picture su sfondo commento
    With Cells(lRow, lColPics).Comment.Shape
        .Fill.Visible = msoTrue
        .Fill.ForeColor.RGB = RGB(255, 255, 255)
        .Fill.BackColor.SchemeColor = 80
        .Fill.UserPicture (gwsURLPath & sURLName)
        .Placement = xlFreeFloating
    End With

    '// larghezza colonna = larghezza shape
    If CLng(ShpBox.Width / 5.53) > lPicsCellWidth Then
        lPicsCellWidth = CLng(ShpBox.Width / 5.53)
    End If

    '// cancella picture
    ShpBox.Delete
Return

srAddCommentKO:
    '// aggiunge commento
    If Cells(lRow, lColPics).Comment Is Nothing Then
        Cells(lRow, lColPics).AddComment (sCommentText)
        Cells(lRow, lColPics).Comment.Visible = True
        Cells(lRow, lColPics).Comment.Shape.Select True
        With Selection
            .HorizontalAlignment = xlLeft
            .VerticalAlignment = xlCenter
            .ReadingOrder = xlContext
            .Orientation = xlHorizontal
            .AutoSize = False
            .Height = lPicRowHeight
            .Width = 40
            .Left = RngPic.Left
            .Top = RngPic.Top
        End With
    End If
    
    '// comment font size
    Cells(lRow, lColPics).Comment.Shape.TextFrame.Characters.Font.Size = 6
Return

End Sub

Private Sub srPicsVisible()

Dim ShpBox As Shape
Dim ShpRng As ShapeRange
Dim RngPic As Range

Dim bPicsVisible As Boolean
Dim bAskLoadPassword As Boolean

Dim lRow As Long
Dim lRowFr As Long
Dim lRowTo As Long
Dim lColComm As Long
Dim lColPics As Long
Dim lPicBrkk As Long
Dim lLoadPic As Long
Dim lFamBrkk As Long
Dim lCurRowHeight As Long
Dim lPicRowHeight As Long
Dim lPicsCellWidth As Long
Dim lMaxLineWarning As Long
Dim lMaxLineLoopExec As Long

Dim sURLName As String
Dim sFamName As String
Dim sPrevURLName As String
Dim sPrevFamName As String
Dim sLoadPassword As String

    On Error Resume Next

    '// reperisce colonna pics, da riga a riga
    lColPics = CLng(Left$(Cells(1, 1).Comment.Text, 3))
    lColComm = CLng(Mid$(Cells(1, 1).Comment.Text, 4, 3))
    lPicBrkk = CLng(Mid$(Cells(1, 1).Comment.Text, 7, 3))
    lFamBrkk = CLng(Mid$(Cells(1, 1).Comment.Text, 10, 3))
    lRowFr = CLng(Mid$(Cells(1, 1).Comment.Text, 13, 3))
    lRowTo = CLng(Mid$(Cells(1, 1).Comment.Text, 16, 7))
    bPicsVisible = Mid$(Cells(1, 1).Comment.Text, 23, 1) = "1"
    lPicRowHeight = CLng(Mid$(Cells(1, 1).Comment.Text, 24, 3))
    lMaxLineWarning = CLng(Mid$(Cells(1, 1).Comment.Text, 27, 3))
    lMaxLineLoopExec = CLng(Mid$(Cells(1, 1).Comment.Text, 30, 3))
    bAskLoadPassword = CBool(Mid$(Cells(1, 1).Comment.Text, 33, 1))
    sLoadPassword = Mid$(Cells(1, 1).Comment.Text, 34, 4)

    '// turn visible on/off, aggiorna bottone, altezza riga
    If bPicsVisible Then
        bPicsVisible = False
        ActiveSheet.Buttons("btnPicsVisible").Caption = "Show Pictures"
        lCurRowHeight = CLng(ActiveSheet.StandardHeight * 100)
    Else
        bPicsVisible = True
        ActiveSheet.Buttons("btnPicsVisible").Caption = "Hide Pictures"
        lCurRowHeight = lPicRowHeight * 100
    End If

    '// imposta altezza riga
    Rows(lRowFr & ":" & lRowTo).RowHeight = lCurRowHeight / 100

    '// display progress bar
    frmWait.Show vbModeless
    frmWait.SetMsg "Processing Picture 1 of " & lRowTo - lRowFr + 1
    'DoEvents

    For lRow = lRowFr To lRowTo

        '// commento visibile si/no
        Cells(lRow, lColPics).Comment.Visible = bPicsVisible

        '// copia picture in sfondo commento
        Set RngPic = Cells(lRow, lColPics)
        With Cells(lRow, lColPics).Comment.Shape
            .Left = RngPic.Left
            .Top = RngPic.Top
        End With
        
        '// update progress bar
        frmWait.SetMsg "Processing Picture " & lRow - lRowFr + 1 & " of " & lRowTo - lRowFr + 1
        'DoEvents

    Next lRow

    '// aggiorna info: col pic, col com, URL break, FAM break, da riga, a riga, picsvisible
    Cells(1, 1).Comment.Delete
    Cells(1, 1).AddComment.Text _
    Format$(CStr(lColPics), "!@@@") & _
    Format$(CStr(lColComm), "!@@@") & _
    Format$(CStr(lPicBrkk), "!@@@") & _
    Format$(CStr(lFamBrkk), "!@@@") & _
    Format$(CStr(lRowFr), "!@@@") & _
    Format$(CStr(lRowTo), "!@@@@@@@") & _
    Format$(CStr(Abs(bPicsVisible)), "!@") & _
    Format$(CStr(lPicRowHeight), "!@@@") & _
    Format$(CStr(lMaxLineWarning), "!@@@") & _
    Format$(CStr(lMaxLineLoopExec), "!@@@") & _
    Format$(CStr(CInt(bAskLoadPassword)), "!@") & _
    Format$(CStr(sLoadPassword), "!@@@@")

    '// reset variabile errore (resume next)
    Err = 0

    '// chiude progress bar
    frmWait.Hide
    Cells(1, 1).Select

End Sub

Attribute VB_Name = "ModDec"
Option Explicit

Public Const gklData_Row_Info = 1
Public Const gklData_Row_TipoDato = 3
Public Const gklData_Row_Labels = 4
Public Const gklData_FirstRow = 5

Public Const gksData_String = "1"
Public Const gksData_Number = "2"
Public Const gksData_Date = "3"

Public Const gkiData_Col_TotRighe = 1
Public Const gkiData_Col_TotColonne = 2
Public Const gkiData_Col_TotQuery = 3
Public Const gkiData_Col_TotOrdinamento = 4
Public Const gkiData_Col_LangCode = 5
Public Const gkiData_Col_AziendaDesc = 6
Public Const gkiData_Col_FormatoData = 7
Public Const gkiData_Col_ISOChrSet = 8
Public Const gkiData_Col_DataLancio = 9
Public Const gkiData_Col_OraLancio = 10
Public Const gkiData_Col_IdRichiesta = 11
Public Const gkiData_Col_IdLancio = 12
Public Const gksCharSepKeyQuery = "/"
Public Const gklPosAzienda_Code = 1
Public Const gklPosQuery_Code = 4
              
Public Const gklMaxSheetRows = 65535
Public Const gklMinExcelVersionWithNoRowsLimit = 12
Public Const gksEnvr_Temp = "TEMP="
Public Const gksChar_Apice = "'"
Public Const gksData_EstensioneFile = ".txt.xls"
'// Public Const gksServer_S3K_Path = "http:\\st3k.otb.net\st3kweb_RS\"
Public Const gksServer_S3K_Path = "http:\\s3000.otb.net\st3kweb_RS\"
Public Const gksVSIZES_FileName = "v_tmp_VSIZES"
Public Const gksVoid_Const = ""

Public Const gklRow_MacroExe = 2
Public Const gklCol_MacroExe = 1
Public Const gksValue_MacroExe = "###{runmacro}###"

Public Const gklColor_DarkBlue = 8388608

Public Const gksFormatPrice = "#,##0.00"
Public Const gksFormatSconto = "0.00"
Public Const gksFormatQta = "#,##0"
Public Const gksFormatFont = "Arial"
Public Const gklFormatCPI = 8
Public Const gksSepDecimale = "D"

Public Const gklWrapText_NON_SETTATO = -1
Public Const gklWrapText_NO = 1
Public Const gklWrapText_YES = 2

Public Const gksFunc_FORMULA = "@FORMULA="

Public Const gksFunc_CPI = "@CPI("
Public Const gksFunc_OMIT = "@OMIT("
Public Const gksFunc_ADDON = "@ADDON("
Public Const gksFunc_TITLE = "@TITLE("
Public Const gksFunc_VSIZES = "@VSIZES("
Public Const gksFunc_WRKPDF = "@WRKPDF("
Public Const gksFunc_PROTECT = "@PROTECT("
Public Const gksFunc_TO_TEST = "@TO-TEST("
Public Const gksFunc_TO_ZERO = "@TO-ZERO("
Public Const gksFunc_SAVE_AS = "@SAVE-AS("
Public Const gksFunc_CHK_SEQ = "@CHK-SEQ("
Public Const gksFunc_SET_PRT = "@SET-PRT("
Public Const gksFunc_FMT_COL = "@FMT-COL("
Public Const gksFunc_FMT_NUM = "@FMT-NUM("
Public Const gksFunc_FMT_HAL = "@FMT-HAL("
Public Const gksFunc_BREAK_ON = "@BREAK-ON("
Public Const gksFunc_TOTAL_ON = "@TOTAL-ON("
Public Const gksFunc_FONTNAME = "@FONTNAME("
Public Const gksFunc_WRAPTEXT = "@WRAPTEXT("
Public Const gksFunc_LOADPICS = "@LOADPICS("
Public Const gksFunc_HL_COLUMN = "@HL-COLUMN("
Public Const gksFunc_HL_COLOUR = "@HL-COLOUR("
Public Const gksFunc_HL_CONDIT = "@HL-CONDIT("
Public Const gksFunc_FILTER_FL = "@FILTER-FL("
Public Const gksFunc_FILTER_C1 = "@FILTER-C1("
Public Const gksFunc_FILTER_C2 = "@FILTER-C2("
Public Const gksFunc_FILTER_OP = "@FILTER-OP("
Public Const gksFunc_COL_EXPAND = "@COL-EXPAND("
Public Const gksFunc_PAGE_BREAK = "@PAGE-BREAK("
Public Const gksFunc_SAP_POSTING = "@SAP-POSTING("

Public Const gkiColTaglie_Width = 8

Global gwbZipYesNo As Boolean
Global gwlFormatCPI As Long
Global gwsURLPath As String
Global gwsPicComm As String
Global gwsFormatFont As String

Attribute VB_Name = "ModUtily"
Option Explicit

'// funzione per gestione URL (download PDF files)
#If VBA7 Then
    '// compatibile con VBA7 o superiori
    Private Declare PtrSafe Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#Else
    '// compatibile con VBA6 o inferiori
    Private Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#End If


Public Function GetDateFromString(ByVal sTmpDate As String, ByVal sFormat As String) As Variant
'//-----------------------------------------------------------------------------------------
'// 26/10/2010 MS,AT: modificata la gestione della data
'// cambiato il tipo di dato restituito dalla funzione da "Date" a "Variant"
'// contempla due formati specifici (europeo e americano) e uno generico
'// restituisce:
'//  1) la data formattata in base alla configurazione locale (DateSerial > 0)
'//         il numero corrisponde ad una data superiore al 31/12/1899
'//         si converte correttamente ed |fffd| valida al 100%
'//         Excel riesce a fare operazioni algebriche tra date
'//  2) in caso di errore:
'//     se DateSerial < 0
'//         il numero corrisponde ad una data inferiore al 01/01/1900
'//         si converte correttamente MA NON E' VALIDA al 100%
'//         in quanto Excel NON riesce a fare operazioni algebriche tra date
'//         restituisce la data convertita evidenziata come data non conforme
'//     se DateSerial = 0
'//         la funzione DateSerial non riesce a convertire la stringa in data
'//         restituisce sTmpDate evidenziato come dato non conforme
'//     se sTmpDate non |fffd| una data
'//         restituisce sTmpDate invariato
'//-----------------------------------------------------------------------------------------

Dim lLenFormat As Long
Dim i As Long
Dim sChar As String
Dim sDay As String
Dim sMonth As String
Dim sYear As String
Dim sValue As String
Dim lDateSerial As Long
Dim sSeps As String
    
    On Error GoTo Errore
    
    sTmpDate = Replace(sTmpDate, gksChar_Apice, "", , , vbBinaryCompare)
    sFormat = UCase$(sFormat)
    lLenFormat = Len(sFormat)
    
    GetDateFromString = gksChar_Apice & sTmpDate
    
    If (Len(Trim$(sTmpDate)) > 0) Then
        If (Len(Trim$(sFormat)) > 0) Then
            If (lLenFormat = Len(sTmpDate)) Then

                '// analisi del formato della data
                Select Case sFormat
                Case "DD/MM/YYYY" '// formato europeo
                    sDay = Mid$(sTmpDate, 1, 2)
                    sMonth = Mid$(sTmpDate, 4, 2)
                    sYear = Mid$(sTmpDate, 7, 4)
                    sSeps = Mid$(sTmpDate, 3, 1) & Mid$(sTmpDate, 6, 1)
                Case "MM/DD/YYYY" '// formato americano
                    sMonth = Mid$(sTmpDate, 1, 2)
                    sDay = Mid$(sTmpDate, 4, 2)
                    sYear = Mid$(sTmpDate, 7, 4)
                    sSeps = Mid$(sTmpDate, 3, 1) & Mid$(sTmpDate, 6, 1)
                Case Else '// altri formati
                    For i = 1 To lLenFormat
                        sChar = Mid$(sFormat, i, 1)
                        sValue = Mid$(sTmpDate, i, 1)
                        Select Case sChar
                        Case "D"
                            sDay = sDay & sValue
                        Case "M"
                            sMonth = sMonth & sValue
                        Case "Y"
                            sYear = sYear & sValue
                        Case Else
                            sSeps = sSeps & "/"
                        End Select
                    Next i
                End Select
                
                '// analisi formale della data
                If IsNumeric(sYear) And IsNumeric(sMonth) And IsNumeric(sDay) Then
                    If Val(sYear) > 99 And Val(sMonth) > 0 And Val(sMonth) < 13 And Val(sDay) > 0 And Val(sDay) < 32 Then
                        If sSeps = "//" Then
                            '// i fattori della data sono numerici e congruenti e i separatori corretti
                            '// si esegue il controllo della data
                            lDateSerial = DateSerial(Val(sYear), Val(sMonth), Val(sDay))
                            If lDateSerial > 0 Then
                                '// data superiore al 31/12/1899 |fffd| valida al 100%
                                '// Excel riesce a fare operazioni algebriche tra date
                                GetDateFromString = CDate(lDateSerial)
                            Else
                                '// data inferiore al 01/01/1900 o dato errato
                                If lDateSerial < 0 Then
                                    '// la data si converte correttamente ma poi Excel
                                    '// non riesce a fare operazioni algebriche tra date
                                    '// viene evidenziata come data non conforme
                                    GetDateFromString = gksChar_Apice & "?>" & CDate(lDateSerial) & "<"
                                Else
                                    '// lDateSerial=0: la funzione DateSerial ha dato errore
                                    '// si lascia il valore stringa originale evitando conversioni fuorvianti
                                    '// viene evidenziato come dato non conforme
                                    GetDateFromString = gksChar_Apice & "?>" & sTmpDate & "<"
                                End If
                            End If
                        End If
                    Else
                        '// i componenti della data non sono congruenti
                        If sSeps = "//" Then
                            '// essendo corretti i separatori, si presume che sia una data non corretta
                            '// viene evidenziata come data non conforme
                            GetDateFromString = gksChar_Apice & "?>" & sTmpDate & "<"
                        End If
                    End If
                End If
                
            End If
        End If
    End If
    
    Exit Function

Errore:
    
    GetDateFromString = gksChar_Apice & sTmpDate
    
End Function


Public Function MettiBarra(percorso As String, nomefile As String) As String
  
  If Right(percorso, 1) = "\" Then
        If Left(nomefile, 1) = "\" Then
            MettiBarra = percorso & Mid(nomefile, 2)
        Else
            MettiBarra = percorso & nomefile
        End If
    Else
        If Left(nomefile, 1) = "\" Then
            MettiBarra = percorso & nomefile
        Else
            MettiBarra = percorso & "\" & nomefile
        End If
    End If

End Function


Public Function OpenFileXLS_Text(ByVal sPathWB As String, ByVal sNomeFileDati As String, ByVal bForceV2003 As Boolean) As Boolean

'// variabili generiche
Dim Worbk As Workbook
Dim sFileNameWithPath As String

'// variabili per UnZip
Dim oShellApp As Object
Dim iOptions As Integer
Dim vZipPath As Variant
Dim vZipFile As Variant
Dim vZipName As Variant
Dim vFileInZip As Variant

    On Error Resume Next
    Set Worbk = Workbooks(sFileNameWithPath)
    On Error GoTo 0
    On Error GoTo Errore

    If Worbk Is Nothing Then

        '// costruisco path completo
        sFileNameWithPath = MettiBarra(sPathWB, sNomeFileDati)

        '// gestione UnZip
        iOptions = 256
        If FileOrDirExists(sFileNameWithPath) = False Then
            vZipPath = sPathWB
            vZipFile = Replace(sNomeFileDati, ".xls", ".zip")
            vZipName = sPathWB & "\" & vZipFile
            If FileOrDirExists(CStr(vZipName)) Then
                frmWait.Show vbModeless
                frmWait.SetMsg "UnZipping Data..."
                'DoEvents
                'ThisWorkbook.Activate
                Set oShellApp = CreateObject("Shell.Application")
                For Each vFileInZip In oShellApp.Namespace(vZipName).Items
                    If vFileInZip.IsFolder = False And Right(vFileInZip, 3) <> "zip" Then
                        oShellApp.Namespace(vZipPath).CopyHere oShellApp.Namespace(vZipName).Items, iOptions
                        If FileOrDirExists(vZipPath & "\" & vFileInZip) = True Then
                            '// estensione file visibile su esplora risorse
                            Name vZipPath & "\" & vFileInZip As vZipPath & "\" & sNomeFileDati
                        Else
                            '// estensione file NON visibile su esplora risorse
                            Name vZipPath & "\" & vFileInZip & ".xls" As vZipPath & "\" & sNomeFileDati
                        End If
                    End If
                Next
                Set oShellApp = Nothing
                frmWait.CloseForm
                'DoEvents
                'ThisWorkbook.Activate
            End If
        End If

        '// annulla lo stato di "copia" eventualmente presente su una o pi|fffd| celle
        ActiveSheet.Application.CutCopyMode = False

        'vedere se settare i separatori decimali e migliaia fissi...
        'al momento valgono quelli di sistema...
        If (GetRightExcelVersion < 110) Then
            'nelle verioni inferiori a Excel 2003 (11.0) non |fffd| supportato l'import degli UTF-8..
            '// Workbooks.OpenText sFileNameWithPath, , , xlDelimited, xlTextQualifierDoubleQuote, False, True
            '// aggiunta l'opzione "Local:=True" per applicare le impostazioni internazionali locali
            Workbooks.OpenText _
            Filename:=sFileNameWithPath, _
            DataType:=xlDelimited, _
            TextQualifier:=xlTextQualifierDoubleQuote, _
            ConsecutiveDelimiter:=False, _
            Tab:=True, _
            Local:=True
        ElseIf (GetRightExcelVersion >= 110 Or bForceV2003) Then
            '// per bForceV2003 forza la lettura in modalit|fffd| 2003
            '"65001" sta per UTF-8..
            '// Workbooks.OpenText sFileNameWithPath, "65001", , xlDelimited, xlTextQualifierDoubleQuote, False, True
            '// aggiunta l'opzione "Local:=True" per applicare le impostazioni internazionali locali
            Workbooks.OpenText _
            Filename:=sFileNameWithPath, _
            Origin:="65001", _
            DataType:=xlDelimited, _
            TextQualifier:=xlTextQualifierDoubleQuote, _
            ConsecutiveDelimiter:=False, _
            Tab:=True, _
            Local:=True
        End If

    Else

        Set Worbk = Nothing

    End If

    OpenFileXLS_Text = True

    Exit Function

Errore:
    OpenFileXLS_Text = False

End Function


Public Function ConvNum(ByVal sValue As String) As Double

Dim iPos As Integer
Dim sTmp As String
    
    On Error GoTo Errore
    
    iPos = InStr(1, sValue, gksSepDecimale, vbTextCompare)
    If iPos Then
        sTmp = Mid$(sValue, 1, iPos - 1) & "." & Mid$(sValue, iPos + 1, Len(sValue) - iPos)
    Else
        sTmp = sValue
    End If
    
    ConvNum = Val(sTmp)
            
    Exit Function

Errore:
    ConvNum = 0

End Function


Public Function IsMaxRowSheetReached(ByVal lRow As Long) As Boolean
    
    If (Val(Left$(Trim$(Application.Version), 2)) < gklMinExcelVersionWithNoRowsLimit) Then
        IsMaxRowSheetReached = (lRow >= gklMaxSheetRows)
    End If

End Function


Public Function GetFieldFromKey(ByVal sKey As String, ByVal sSepChar As String, ByVal lPosField As Long) As String
Dim i As Long
Dim lPosS As Long
Dim lPosE As Long
Dim lCountPos As Long
    
    On Error GoTo Errore
    
    GetFieldFromKey = ""
    
    lCountPos = 0
    lPosS = 0
    lPosE = 0
    
    For i = 1 To Len(sKey)
        If (Mid$(sKey, i, 1) = sSepChar) Then
            lCountPos = lCountPos + 1
            If (lCountPos = (lPosField - 1)) Then
                lPosS = i
            End If
            If (lCountPos = (lPosField)) Then
                lPosE = i
                Exit For
            End If
        End If
    Next i
    
    If (Not ((lPosS = 0) And (lPosE = 0) And (lCountPos <> 0))) Then
        If ((lCountPos = 0) And (lPosField <> 1)) Then
            GoTo Errore
        End If
        If (lPosS = 0) Then
            lPosS = 1
        Else
            lPosS = lPosS + 1
        End If
        If (lPosE = 0) Then
            lPosE = Len(sKey)
        Else
            lPosE = lPosE - 1
        End If
    End If
    
    GetFieldFromKey = Mid$(sKey, lPosS, lPosE - lPosS + 1)
    
    Exit Function

Errore:
   GetFieldFromKey = ""

End Function


Public Function GetRightExcelVersion() As Long
Dim sTmp1 As String
    
    On Error Resume Next
    
    sTmp1 = Application.Version
    sTmp1 = Left$(Format$(Val(Trim$(Replace(sTmp1, ".", "", , , vbTextCompare))), "000"), 3)
    GetRightExcelVersion = Val(sTmp1)
    
End Function


Public Sub FormatThisCell(ByVal lRow As Long, ByVal lCol As Long, ByVal lHorizontalAlignment As Long, ByVal lSize As Long, ByVal bBold As Boolean, ByVal bItalic As Boolean, ByVal bUnderline As Boolean, ByVal lColor As Long, Optional ByVal lLineStyleTop As Long = xlLineStyleNone, Optional ByVal lLineWeightTop As Long = xlNone, Optional ByVal lLineStyleLeft As Long = xlLineStyleNone, Optional ByVal lLineWeightLeft As Long = xlNone, Optional ByVal lLineStyleRight As Long = xlLineStyleNone, Optional ByVal lLineWeightRight As Long = xlNone, Optional ByVal lLineStyleBottom As Long = xlLineStyleNone, Optional ByVal lLineWeightBottom As Long = xlNone, Optional ByVal lWrapText As Long)
    
    On Error Resume Next
    
    With Cells(lRow, lCol)
        .HorizontalAlignment = lHorizontalAlignment
        .Font.Name = gwsFormatFont
        .Font.Size = lSize
        .Font.Bold = bBold
        .Font.Italic = bItalic
        .Font.Underline = bUnderline
        .Font.Color = lColor
    End With
    
    If (lWrapText <> gklWrapText_NON_SETTATO) Then
        Cells(lRow, lCol).WrapText = (lWrapText = gklWrapText_YES)
    End If
    
    If (lLineStyleTop <> xlLineStyleNone) Then
        Cells(lRow, lCol).Borders(xlTop).LineStyle = lLineStyleTop
    End If
    If (lLineWeightTop <> xlNone) Then
        Cells(lRow, lCol).Borders(xlTop).Weight = lLineWeightTop
    End If
    
    If (lLineStyleLeft <> xlLineStyleNone) Then
        Cells(lRow, lCol).Borders(xlLeft).LineStyle = lLineStyleLeft
    End If
    If (lLineWeightLeft <> xlNone) Then
        Cells(lRow, lCol).Borders(xlLeft).Weight = lLineWeightLeft
    End If
    
    If (lLineStyleRight <> xlLineStyleNone) Then
        Cells(lRow, lCol).Borders(xlRight).LineStyle = lLineStyleRight
    End If
    If (lLineWeightRight <> xlNone) Then
        Cells(lRow, lCol).Borders(xlRight).Weight = lLineWeightRight
    End If
    
    If (lLineStyleBottom <> xlLineStyleNone) Then
        Cells(lRow, lCol).Borders(xlBottom).LineStyle = lLineStyleBottom
    End If
    If (lLineWeightBottom <> xlNone) Then
        Cells(lRow, lCol).Borders(xlBottom).Weight = lLineWeightBottom
    End If
    
End Sub


Public Sub FormatThisSheet(ByVal lSize As Long, ByVal bBold As Boolean, ByVal bItalic As Boolean, ByVal bUnderline As Boolean, ByVal lColor As Long)

    On Error Resume Next
    
    With Cells.Font
        .Name = gwsFormatFont
        .Size = lSize
        .Bold = bBold
        .Italic = bItalic
        .Underline = bUnderline
        .Color = lColor
    End With

End Sub


Public Sub FormatThisRow(ByVal lRow As Long, ByVal lSize As Long, ByVal bBold As Boolean, ByVal bItalic As Boolean, ByVal bUnderline As Boolean, ByVal lColor As Long)

    On Error Resume Next
    
    With Rows(lRow).EntireRow.Font
        .Name = gwsFormatFont
        .Size = lSize
        .Bold = bBold
        .Italic = bItalic
        .Underline = bUnderline
        .Color = lColor
    End With

End Sub

Public Sub FormatThisCol(ByVal lCol As Long, ByVal lHorizAlign As Long, ByVal lVertAlign As Long, ByVal bWrapText As Boolean)

    On Error Resume Next
    
    With Columns(lCol).EntireColumn
        .HorizontalAlignment = lHorizAlign
        .VerticalAlignment = lVertAlign
        .WrapText = bWrapText
    End With

End Sub


Public Sub SetRowHeight(ByRef lRow As Long, ByRef lHeight As Double, ByVal bWrapText As Boolean)
    
    On Error Resume Next
    
    With Rows(lRow).EntireRow
        .RowHeight = lHeight
        .WrapText = bWrapText
    End With

End Sub


Public Sub SetColWidth(ByRef lCol As Long, ByRef dWidth As Double, ByVal bWrapText As Boolean)
    
    On Error Resume Next
    
    With Columns(lCol).EntireColumn
        .ColumnWidth = dWidth
        .WrapText = bWrapText
    End With
    
End Sub


Public Sub SetThisRange_Line(ByVal lRowStart As Long, ByVal lColStart As Long, ByVal lRowEnd As Long, ByVal lColEnd As Long, Optional ByVal lLineStyleTop As Long = xlLineStyleNone, Optional ByVal lLineWeightTop As Long = xlNone, Optional ByVal lLineStyleLeft As Long = xlLineStyleNone, Optional ByVal lLineWeightLeft As Long = xlNone, Optional ByVal lLineStyleRight As Long = xlLineStyleNone, Optional ByVal lLineWeightRight As Long = xlNone, Optional ByVal lLineStyleBottom As Long = xlLineStyleNone, Optional ByVal lLineWeightBottom As Long = xlNone)
    
    On Error Resume Next
    
    With Range(Cells(lRowStart, lColStart), Cells(lRowEnd, lColEnd))
        
        If (lLineStyleTop <> xlLineStyleNone) Then
            .Borders(xlEdgeTop).LineStyle = lLineStyleTop
        End If
        If (lLineWeightTop <> xlNone) Then
            .Borders(xlEdgeTop).Weight = lLineWeightTop
        End If
        
        If (lLineStyleLeft <> xlLineStyleNone) Then
            .Borders(xlEdgeLeft).LineStyle = lLineStyleLeft
        End If
        If (lLineWeightLeft <> xlNone) Then
            .Borders(xlEdgeLeft).Weight = lLineWeightLeft
        End If
        
        If (lLineStyleRight <> xlLineStyleNone) Then
            .Borders(xlEdgeRight).LineStyle = lLineStyleRight
        End If
        If (lLineWeightRight <> xlNone) Then
            .Borders(xlEdgeRight).Weight = lLineWeightRight
        End If
        
        If (lLineStyleBottom <> xlLineStyleNone) Then
            .Borders(xlEdgeBottom).LineStyle = lLineStyleBottom
        End If
        If (lLineWeightBottom <> xlNone) Then
            .Borders(xlEdgeBottom).Weight = lLineWeightBottom
        End If
    
    End With

End Sub


Public Sub AddButtons_SAVEAS(ByVal bDummy As Boolean)
'// crea pulsanti

Dim btnFileSaveAs As Object
    
    '// pulsante copy and save as
    Set btnFileSaveAs = ActiveSheet.Buttons.Add(220, 2, 110, 18) '// col,row,width,heigh
    With btnFileSaveAs
        .Caption = "Copy and Save As"
        .Name = "btnFileSaveAs"
        .Placement = xlFreeFloating
        .PrintObject = False
        .OnAction = "FileSaveAs"
    End With

End Sub


Private Sub FileSaveAs()
'// Save As the current sheet
'// Working in Excel 2000-2013 only

    Dim fname As Variant
    Dim NewWb As Workbook
    Dim OldWb As Workbook
    Dim FileFormatValue As Long

    '// Check the Excel version
    If Val(Application.Version) < 9 Then
        '// version before 2000
        Exit Sub
    End If
    If Val(Application.Version) < 12 Then
        '// versions 2000-2003
        '// Only choice in the "Save as type" dropdown is Excel files(xls)
        '// because the Excel version is 2000-2003
        fname = Application.GetSaveAsFilename(InitialFileName:="", _
        filefilter:="Excel Files (*.xls), *.xls", _
        Title:="Save a copy of this active sheet to a new workbook, as.....")

        If fname <> False Then
            Set OldWb = ActiveWorkbook
            '// Copy the ActiveSheet to new workbook
            ActiveSheet.Copy
            Set NewWb = ActiveWorkbook

            '// We use the 2000-2003 format xlWorkbookNormal here to save as xls
            NewWb.SaveAs fname, FileFormat:=-4143, CreateBackup:=False
            '// close xlsm and leave open xlsx
            '// NewWb.Close False
            '// Set NewWb = Nothing
            OldWb.Close savechanges:=False

        End If
    Else
        '// version greater than 2003
        '// Give the user the choice to save in 2000-2003 format or in one of the
        '// new formats. Use the "Save as type" dropdown to make a choice,Default =
        '// Excel Macro Enabled Workbook. You can add or remove formats to/from the list

        '// Example with many formats
        '//        fname = Application.GetSaveAsFilename(InitialFileName:="", filefilter:= _
        '//            " Excel Macro Free Workbook (*.xlsx), *.xlsx," & _
        '//            " Excel Macro Enabled Workbook (*.xlsm), *.xlsm," & _
        '//            " Excel 2000-2003 Workbook (*.xls), *.xls," & _
        '//            " Excel Binary Workbook (*.xlsb), *.xlsb", _
        '//            FilterIndex:=2, Title:="This example copies the ActiveSheet to a new workbook")

        fname = Application.GetSaveAsFilename(InitialFileName:="", filefilter:= _
            " Excel MacroFree Workbook (*.xlsx), *.xlsx," & _
            " Excel 2000-2003 Workbook (*.xls), *.xls,", _
            FilterIndex:=1, Title:="Save a copy of this active sheet to a new workbook, as.....")

        '// Find the correct FileFormat that match the choice in the "Save as type" list
        If fname <> False Then
            Select Case LCase(Right(fname, Len(fname) - InStrRev(fname, ".", , 1)))
            Case "xls":  FileFormatValue = xlExcel8                         '// 56
            Case "xlsm": FileFormatValue = xlOpenXMLWorkbookMacroEnabled    '// 52
            Case "xlsx": FileFormatValue = xlOpenXMLWorkbook                '// 51
            Case "xlsb": FileFormatValue = xlExcel12                        '// 50
            Case Else:   FileFormatValue = 0
            End Select

            '// Now we can create/Save the file with the xlFileFormat parameter
            '// value that match the file extension
            If FileFormatValue = 0 Then
                MsgBox "Sorry, unknown file extension"
            Else
                Set OldWb = ActiveWorkbook

                '// Copies the ActiveSheet to new workbook
                ActiveSheet.Copy
                Set NewWb = ActiveWorkbook
                
                '// delete button (if exists)
                On Error Resume Next
                ActiveSheet.Shapes("btnFileSaveAs").Delete
                On Error GoTo 0

                '// Save the file in the format you choose in the "Save as type" dropdown
                NewWb.SaveAs fname, _
                             FileFormat:=FileFormatValue, _
                             CreateBackup:=False

                '// close xlsm and leave open xlsx
                '// NewWb.Close False
                '// Set NewWb = Nothing
                OldWb.Close savechanges:=False
            End If
        End If
    End If
End Sub


Private Function DownloadFiles() As String
                    
    '--------------------------------------------------------------------------------------------------
    'The macro loops throuhg all the URLs (column C) and downloads the files at the specified folder.
    'The characters after the last "/" of the URL string are used to create the file path.
    'If the file is downloaded successfully an OK will appear in column D (otherwise an ERROR value).
    'The code is based on API function URLDownloadToFile, which actually does all the work.
            
    'Written by:    Christos Samaras
    'Date:          02/11/2013
    'e-mail:        xristos.samaras@gmail.com
    'site:          http://www.myengineeringworld.net
    
    'Revised by:    Sergio Meneghin
    'Date:          01 Jul 2014
    'Purpose:       Diesel Spa PDF management by Q&L
    '--------------------------------------------------------------------------------------------------
    
    'Declaring the necessary variables.
    Dim lRow                 As Long
    Dim lChr                 As Long
    Dim lResult              As Long
    Dim lFirstRow            As Long
    Dim lLastRow             As Long
    Dim lColIdPdf            As Long
    Dim lColFnPdf            As Long
    Dim lCountErrors         As Long
    Dim lCountDownloads      As Long
    Dim lTotalDownloads      As Long
    Dim dSpecialCharFound    As Double
    Dim sDownloadFolder      As String
    Dim sSpecialChar()       As String
    Dim sFolderPath          As String
    Dim sFilePath            As String
    Dim sFileName            As String
    Dim sFileExtn            As String
    
    'Disable screen flickering.
    Application.ScreenUpdating = False
    
    '// retrieve parameters from comment
    lFirstRow = CLng(Mid$(Cells(1, 1).Comment.Text, 1, 3))
    lColIdPdf = CLng(Mid$(Cells(1, 1).Comment.Text, 4, 3))
    lColFnPdf = CStr(Mid$(Cells(1, 1).Comment.Text, 7, 3))
    sFileExtn = Mid$(Cells(1, 1).Comment.Text, 10, 5)
    
    '// calcola prima e ultima riga
    lFirstRow = CLng(Range(Cells(lFirstRow, lColIdPdf), Cells(Rows.Count, lColIdPdf)).SpecialCells(xlCellTypeVisible).Row)
    lLastRow = CLng(Cells(Rows.Count, lColIdPdf).End(xlUp).Row)
    
    '// avvisa quando numero immagini da scaricare = 0 oppure > 1000
    For lRow = lFirstRow To lLastRow
        If Not Rows(lRow).Hidden Then
            If InStr(1, Cells(lRow, lColIdPdf), "http:", vbTextCompare) Then
                lTotalDownloads = lTotalDownloads + 1
            End If
        End If
    Next lRow
    If lTotalDownloads = 0 Then
        MsgBox "No files to be downloaded!", vbExclamation + vbOKOnly, "Download Warning!"
        Exit Function
    ElseIf lTotalDownloads > 1000 Then
        lResult = CLng(MsgBox("There are too many files (" & lTotalDownloads & ") to be downloaded" & Chr$(10) & _
        "and process might not complete successfully!" & String$(2, Chr$(10)) & _
        "Do You really want to continue?", vbExclamation + vbYesNo + vbDefaultButton2, "Download Warning!"))
        If lResult = vbNo Then
            Exit Function
        End If
    End If

    'An array with special characters that cannot be used for naming a file.
    sSpecialChar() = Split("\ / : * ? " & Chr$(34) & " < > |", " ")
    
    'Find the last row and clear the lResults column.
    With ActiveSheet
        .Activate

        '// download folder path selection
        sFolderPath = ""
        Call FolderSelection(sFolderPath)

        ' Check if the download folder exists.
        On Error Resume Next
        If sFolderPath = "" Or Dir(sFolderPath, vbDirectory) = vbNullString Then
            MsgBox "The folder's path " & sFolderPath & " is incorect!", vbCritical, "Wrong folder's path"
            Exit Function
        End If
        On Error GoTo 0
        
        '// se Zip il folder dei PDF |fffd| il defaultpath e il folder dello Zip |fffd| il folderpath
        If gwbZipYesNo = True Then
            '// crea directory in default path se non esiste
            sDownloadFolder = Application.DefaultFilePath & "\MyDownloadedFiles"
            If Len(Dir(CVar(sDownloadFolder), vbDirectory)) = 0 Then
                MkDir (CVar(sDownloadFolder))
            End If
        Else
            '// folder path
            sDownloadFolder = sFolderPath
        End If

        'Check if there is at least one URL.
        If lLastRow < lFirstRow Then
            MsgBox "There are no URLs!", vbCritical, "No URL"
            .Cells(lFirstRow, lColIdPdf).Select
            Exit Function
        End If

        'Add the backslash if doesn't exist.
        If Right(sDownloadFolder, 1) <> "\" Then
            sDownloadFolder = sDownloadFolder & "\"
        End If

        '// display progress bar
        frmWait.Show vbModeless
        frmWait.SetMsg "Processing..."
        'DoEvents
        'ThisWorkbook.Activate

        'Save the internet files at the specified folder of your hard disk.
        On Error Resume Next
        For lRow = lFirstRow To lLastRow

            If Not Rows(lRow).Hidden Then
                '// nome file PDF
                sFileName = Cells(lRow, lColFnPdf).Value

'//                If Len(sFileName) = 0 Then
'// 25/09/2017         MsgBox "File Name is missing on cell " & Chr$(64 + lColFnPdf) & CStr(lRow) & ", file cannot be downloaded!"
'//                Else

                If Len(sFileName) > 0 Then
                    'Check if the file path contains a special/illegal character.
                    For lChr = LBound(sSpecialChar) To UBound(sSpecialChar)
                        dSpecialCharFound = WorksheetFunction.Find(sSpecialChar(lChr), sFileName)
                        'If an illegal character is found substitute it with a "_" character.
                        If dSpecialCharFound > 0 Then
                            sFileName = WorksheetFunction.Substitute(sFileName, sSpecialChar(lChr), "_")
                        End If
                    Next lChr
    
                    'Create the final file path.
                    sFilePath = sDownloadFolder & sFileName & "." & sFileExtn
    
                    'Check if the file path exceeds the maximum allowable characters.
                    If Len(sFilePath) > 255 Then
                        MsgBox "File Name is too long, file cannot be downloaded!"
                    Else
    
                        'If the file path is valid save the file to the selected folder.
                        'Save the files to the selected folder.
                        lResult = URLDownloadToFile(0, Cells(lRow, lColIdPdf).Value, sFilePath, 0, 0)
                        If lCountDownloads Mod 10 = 0 Then
                            Application.Wait Now + TimeValue("00:00:01")
                        End If
                        
                        'Check if the file downloaded successfully  and if it exists.
                        If lResult = 0 And Not Dir(sFilePath, vbDirectory) = vbNullString Then
                            'Success!
                            lCountDownloads = lCountDownloads + 1
                        Else
                            'Error!
                            lCountErrors = lCountErrors + 1
                        End If
                    
                    End If
    
                    '// display progress bar
                    frmWait.SetMsg "Processing PDF " & lCountDownloads & " of " & lTotalDownloads
                    'DoEvents
                    'ThisWorkbook.Activate
    
                End If
            End If
    
        Next lRow
        On Error GoTo 0
        Application.Wait Now + TimeValue("00:00:02")

        '// chiude progress bar
        frmWait.CloseForm
        'DoEvents
        'ThisWorkbook.Activate
        Cells(lFirstRow, 1).Select

    End With
    
    'Inform the user that macro finished successfully or with errors and enable the screen.
    If lCountErrors = 0 Then
        'Success!
        If gwbZipYesNo = False Then
            If lCountDownloads = 1 Then
                Application.ScreenUpdating = True
                MsgBox "The file was successfully downloaded!", vbInformation, "Done"
            Else
                Application.ScreenUpdating = True
                MsgBox lCountDownloads & " files were successfully downloaded!", vbInformation, "Done"
            End If
        End If
    Else
        'Error!
        If lCountErrors = 1 Then
            Application.ScreenUpdating = True
            MsgBox "There was an error in one of the files!", vbCritical, "Error"
        Else
            Application.ScreenUpdating = True
            MsgBox "There was an error in " & lCountErrors & " files!", vbCritical, "Error"
        End If
    End If

    DownloadFiles = sFolderPath

End Function


Private Sub DownloadZipFiles()
    
    'Download files and ZIP files
    gwbZipYesNo = True
    Call Zip_All_Files_in_Folder(DownloadFiles)
    gwbZipYesNo = False
    
End Sub

Private Sub FolderSelection(FoldersPath)
    
    'Shows the folder picker dialog in order the user to select the folder
    'in which the downloaded files will be saved.
    
    'Show the folder picker dialog.
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = "Select a folder to save your files..."
        .Show
            If .SelectedItems.Count = 0 Then
                MsgBox "You did't select a folder!", vbExclamation, "Cancelled"
                Exit Sub
            Else
                FoldersPath = .SelectedItems(1)
            End If
    End With
    
End Sub

Sub Zip_All_Files_in_Folder(sDownloadFolder)

    Dim sDateTimeStamp As String
    Dim sDefaultPath As String
    Dim vFromTime As Variant
    Dim vFileNameZip As Variant
    Dim vFilesFolderName As Variant
    Dim oCopyApp As Object

    '// controllo percorso folder valorizzato
    If sDownloadFolder = "" Then
        Exit Sub
    End If

    '// display progress bar
    frmWait.Show vbModeless
    frmWait.SetMsg "Zipping files, please wait..."

    '// default path
    sDefaultPath = Application.DefaultFilePath

    '// Files Folder Name
    vFilesFolderName = sDefaultPath & "\MyDownloadedFiles"

    On Error Resume Next

    '// data ora
    sDateTimeStamp = Format(Now, " dd-mm-yy hh-mm-ss")

    '// zip file name
    vFileNameZip = sDownloadFolder & "\MyZipFiles" & sDateTimeStamp & ".zip"

    'Create empty Zip File
    Call NewZip(vFileNameZip)
    Application.Wait Now + TimeValue("00:00:03")

    'Copy the files to the compressed folder
    Set oCopyApp = CreateObject("Shell.Application")
    oCopyApp.Namespace(vFileNameZip).CopyHere oCopyApp.Namespace(vFilesFolderName)

    'Keep script waiting until Compressing is done
    Application.Wait Now + TimeValue("00:00:03")
    vFromTime = Now
    Do Until oCopyApp.Namespace(vFileNameZip & "\MyDownloadedFiles").Items.Count = oCopyApp.Namespace(vFilesFolderName).Items.Count _
          Or Now > vFromTime + TimeValue("00:00:15")
    Loop

    '// chiude progress bar
    frmWait.CloseForm

    '// se conteggio non corrisponde allora messaggio errore
    If oCopyApp.Namespace(vFileNameZip & "\MyDownloadedFiles").Items.Count <> oCopyApp.Namespace(vFilesFolderName).Items.Count Then
        MsgBox "WARNING!" & Chr$(10) & Chr$(13) & _
        "The Zip File could be incomplete!" & Chr$(10) & Chr$(13) & _
        "Please check the Zip File content and retry in case", _
        vbCritical, _
        "Zip File"
    End If

    '// cancella file e directory di comodo
    Kill vFilesFolderName & "\*.*"
    RmDir vFilesFolderName
    
    On Error GoTo 0
    
    MsgBox "You find the Zip File here: " & vFileNameZip, vbInformation, "Zip File"

End Sub


Private Sub NewZip(sPath)
'Create empty Zip File
'Changed by keepITcool Dec-12-2005
    
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1

End Sub


Public Sub AddButtons_WRKPDF(ByVal bDummy As Boolean)
'// crea pulsanti per gestione PDF

Dim btnPDF_DnLd As Object
Dim btnPDF_DnLdZip As Object
    
    '// pulsante download PDF
    Set btnPDF_DnLd = ActiveSheet.Buttons.Add(280, 2, 180, 18) '// col,row,width,heigh
    With btnPDF_DnLd
        .Caption = "Download all PDFs to selected folder"
        .Name = "btnPDF_DnLd"
        .Placement = xlFreeFloating
        .PrintObject = False
        .OnAction = "DownloadFiles"
    End With
    
    '// pulsante download and Zip PDF
    Set btnPDF_DnLdZip = ActiveSheet.Buttons.Add(480, 2, 200, 18) '// col,row,width,heigh
    With btnPDF_DnLdZip
        .Caption = "Download & Zip all PDFs to selected folder"
        .Name = "btnPDF_DnLdZip"
        .Placement = xlFreeFloating
        .PrintObject = False
        .OnAction = "DownloadZipFiles"
    End With

End Sub

Function FileOrDirExists(PathName As String) As Boolean
'Macro Purpose: Function returns TRUE if the specified file or folder exists, false if not.
'PathName     : Supports Windows mapped drives or UNC
'             : Supports Macintosh paths
'File usage   : Provide full file path and extension
'Folder usage : Provide full folder path
'               Accepts with/without trailing "\" (Windows)
'               Accepts with/without trailing ":" (Macintosh)

Dim iTemp As Integer

    'Ignore errors to allow for error evaluation
    On Error Resume Next
    iTemp = GetAttr(PathName)

    'Check if error exists and set response appropriately
    Select Case Err.Number
    Case Is = 0
        FileOrDirExists = True
    Case Else
        FileOrDirExists = False
    End Select

    'Resume error checking
    On Error GoTo 0

End Function


Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


Private Sub Workbook_Open()

    Call Go

End Sub


Public Sub Go()

Dim bForceV2003 As Boolean

Dim iReturn As Integer
Dim iDotPos As Integer
Dim iLastDotPos As Integer

Dim lPosChr As Long
Dim lTotRows As Long
Dim lResMaxRows As Long

Dim sPosChr As String
Dim sPathWB As String
Dim sFileName As String
Dim sNomeFileDati As String
Dim sNomeFileDati_Org As String
Dim sNomeFileDati_Clr As String

    On Error Resume Next

    ThisWorkbook.Activate

    '// esce per macro gi|fffd| eseguita
    If Cells(gklRow_MacroExe, gklCol_MacroExe).Value <> gksValue_MacroExe Then
        Exit Sub
    End If
 
    Application.ScreenUpdating = False
    Application.EnableEvents = False

    sPathWB = ThisWorkbook.Path
    sFileName = ThisWorkbook.Name
    
    '// determina la posizione del punto separatore dell'estensione file
    Windows(ThisWorkbook.Name).Visible = True
    iLastDotPos = 0
    For iDotPos = 1 To Len(sFileName)
        If Mid(sFileName, iDotPos, 1) = "." Then
            iLastDotPos = iDotPos
        End If
    Next iDotPos
    
    '// costruisce nomi files
    sFileName = Mid(sFileName, 1, iLastDotPos - 1) & LCase(Mid(sFileName, iLastDotPos))
    sNomeFileDati = Mid(sFileName, 1, iLastDotPos - 1) & gksData_EstensioneFile
            
    '// controllo compatibilit|fffd| versione
    If (GetRightExcelVersion < 120) And LCase(Mid(sFileName, iLastDotPos + 1)) = "tmp" Then
        MsgBox "Excel version not compatible with user selection, please check client Excel version", vbExclamation
        ThisWorkbook.Close False
        Exit Sub
    End If
    
'// ===> INIZIO nuova apertura file dati compatibile Java/Firefox

lblOpenFile:
    bForceV2003 = False
    Application.DisplayAlerts = False

    If OpenFileXLS_Text(sPathWB, sNomeFileDati, bForceV2003) = False Then

        '// lettura file da server di produzione S3K
        sPathWB = gksServer_S3K_Path

        '// lettura da server S3K nel caso di file FireFox scaricato su cache per la prima volta
        If OpenFileXLS_Text(sPathWB, sNomeFileDati, bForceV2003) Then
            GoTo Exit_Read
        Else
            '// salvo nome file dati originale
            sNomeFileDati_Org = sNomeFileDati
            sNomeFileDati_Clr = sNomeFileDati
        End If

        '// tolgo (n) o [n] dal nome file nel caso di file scaricato su cache da Explorer
        lPosChr = InStr(1, sNomeFileDati, gksData_EstensioneFile, vbBinaryCompare) - 1
        sPosChr = Mid(sNomeFileDati, lPosChr, 1)
        If InStr(1, ")]", sPosChr, vbBinaryCompare) > 0 Then
            Do
                sPosChr = Right(sNomeFileDati, 1)
                lPosChr = lPosChr - 1
                sNomeFileDati = Left(sNomeFileDati, lPosChr)
            Loop Until InStr(1, "([", sPosChr, vbBinaryCompare) > 0
            sNomeFileDati = sNomeFileDati & gksData_EstensioneFile
            If OpenFileXLS_Text(sPathWB, sNomeFileDati, bForceV2003) Then
                GoTo Exit_Read
            Else
                '// reimposto nome file dati originale
                sNomeFileDati_Clr = sNomeFileDati
                sNomeFileDati = sNomeFileDati_Org
            End If
        End If

        '// tolgo -n dal nome file nel caso di file scaricato su cache da FireFox per le volte seguenti la prima
        lPosChr = InStr(1, sNomeFileDati, gksData_EstensioneFile, vbBinaryCompare) - 1
        sPosChr = Mid(sNomeFileDati, lPosChr, 1)
        For iDotPos = 1 To 3
            If sPosChr = "-" Then
                sNomeFileDati = Left(sNomeFileDati, lPosChr - 1) & gksData_EstensioneFile
                If OpenFileXLS_Text(sPathWB, sNomeFileDati, bForceV2003) Then
                    GoTo Exit_Read
                Else
                    '// reimposto nome file dati originale
                    sNomeFileDati_Clr = sNomeFileDati
                    sNomeFileDati = sNomeFileDati_Org
                End If
                Exit For
            Else
                lPosChr = lPosChr - 1
                sPosChr = Mid(sNomeFileDati, lPosChr, 1)
            End If
        Next iDotPos

        '// forzo lettura in modalit|fffd| 2003 con nome file pulito
        bForceV2003 = True
        sNomeFileDati = sNomeFileDati_Clr
        If OpenFileXLS_Text(sPathWB, sNomeFileDati, bForceV2003) Then
            GoTo Exit_Read
        Else
            '// reimposto nome file dati originale
            sNomeFileDati = sNomeFileDati_Org
        End If

        '// nessuna open riuscita
        MsgBox "Data file not found: " & sNomeFileDati, vbCritical + vbOKOnly, "Warning..."
        GoTo Errore

Exit_Read:
    End If
    Application.DisplayAlerts = True

'// ===> FINE nuova apertura file dati compatibile Java/Firefox

    '// rimozione pulsante avvio manuale
    Application.ScreenUpdating = True
    ActiveSheet.Buttons("ManualStart").Visible = False
    Application.ScreenUpdating = False

    '// totale righe contenute nel file dati
    lTotRows = Val(Workbooks(sNomeFileDati).Worksheets(1).Cells(1, gkiData_Col_TotRighe).Value)
    
    '// controllo numero massimo righe gestibili in base alla versione Excel
    lResMaxRows = vbYes
    If (IsMaxRowSheetReached(lTotRows + 4) = True) Then
        lResMaxRows = MsgBox("The number of data rows " & CStr(lTotRows + 4) & " is greater than the max (" & CStr(gklMaxSheetRows) & _
        ") handled by this Excel Ver." & Chr$(13) & Chr$(10) & _
        "The exceeding data will be lost, continue?", vbYesNo + vbQuestion, "Warning...")
    End If
    
    If (lResMaxRows = vbYes) Then
        '// legge file e carica foglio excel
        iReturn = GetDataIntoWorkBook(Workbooks(sNomeFileDati))

        '// funzione VSIZES: riesegue l'apertura del nuovo file verticalizzato
        If iReturn = 2 Then
            Workbooks(sNomeFileDati).Close False
            sPathWB = Environ$(Left(gksEnvr_Temp, 4))
            sNomeFileDati = gksVSIZES_FileName & gksData_EstensioneFile
            GoTo lblOpenFile
        End If

    End If

Errore:
    Workbooks(sNomeFileDati).Close False
    Application.EnableEvents = True
    Application.ScreenUpdating = True

    If iReturn <> 0 Then
        '// save .xlsx guidelines
        If Application.LanguageSettings.LanguageID(msoLanguageIDInstall) = msoLanguageIDItalian Then
            '// Italian
            MsgBox "LEGGERE ATTENTAMENTE QUESTA REGOLA PER SALVARE IL FILE" & Chr$(13) & Chr$(13) & _
                   "Se intendi inviare il file Excel via eMail, " & Chr$(13) & _
                   "al fine di evitare problemi con AntiVirus e AntiMalware, " & Chr$(13) & _
                   "completa il lavoro e salva il file con tipo: " & Chr$(13) & Chr$(13) & _
                   "                    Cartella di lavoro di Excel (*.xlsx)." & Chr$(13) & Chr$(13) & _
                   "Puoi fare ci|fffd| velocemente usando la combinazione di tasti: " & Chr$(13) & Chr$(13) & _
                   "                            Ctrl + Maiusc + Ins" & Chr$(13) & Chr$(13) & _
                   "che apre la finestra di salvataggio dove devi inserire solo il nome file, " & _
                   "mentre il tipo file |fffd| gi|fffd| impostato correttamente.", _
                   vbCritical + vbApplicationModal + vbExclamation + vbOKOnly, _
                   "                                 ATTENZIONE: Messaggio Importante"
        Else
            '// English
            MsgBox "PLEASE READ CAREFULLY THIS RULE FOR SAVING THE FILE" & Chr$(13) & Chr$(13) & _
                   "If You later want to send the Excel file via eMail, " & Chr$(13) & _
                   "in order to avoid problems with AntiVirus and AntiMalware, " & Chr$(13) & _
                   "complete all necessary actions and then save the file as type: " & Chr$(13) & Chr$(13) & _
                   "                    Excel Workbook (*.xlsx)." & Chr$(13) & Chr$(13) & _
                   "You can do that quickly by using the keyboard shortcut: " & Chr$(13) & Chr$(13) & _
                   "                            Ctrl + Shift + Ins" & Chr$(13) & Chr$(13) & _
                   "which opens the save window where You have to enter just the file name, " & _
                   "while the file type is already set correctly.", _
                   vbCritical + vbApplicationModal + vbExclamation + vbOKOnly, _
                   "                                 WARNING: Important Message"
        End If
        
    End If

End Sub

'
'// routine da inserire in Sheet1 in caso di utilizzo dell'opzione AVAIL della funzione CROSSWORD
'
'Private Sub Workbook_SheetChange(ByVal Sh As Object, ByVal Target As Range)
'
'Dim sQStock As String
'Dim sQAlloc As String
'Dim sQAvail As String
'
'    If gwsCWType = gksCWTypeAvail Then
'        If Not Target.Comment Is Nothing Then
'            sQStock = Trim$(Mid$(Target.Comment.Text, 6, 4))
'            sQAlloc = Target.Value
'            sQAvail = CStr(Val(sQStock) - Val(sQAlloc))
'            Target.ClearComments
'            Target.AddComment.Text "Stk: " & Format$(sQStock, "!@@@@") & Chr$(10) & "Avl: " & Format$(sQAvail, "!@@@@")
'        End If
'    End If
'
'End Sub




Attribute VB_Name = "frmWait"
Attribute VB_Base = "0{186017EE-19A9-4F63-A596-DE00BAE523BD}{78B381E3-D173-40D1-8C72-E59E00BD4735}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Option Explicit


Public Sub SetMsg(ByVal sMsg As String)
    
    '// visualizza messaggio su progress bar
    lblMsg.Caption = sMsg
    Me.Repaint
    'DoEvents
    'ThisWorkbook.Activate

End Sub


Public Sub CloseForm()

    '// chiude progress bar
    frmWait.Hide
    'DoEvents
    'ThisWorkbook.Activate

End Sub



INQUEST-PP=macro
