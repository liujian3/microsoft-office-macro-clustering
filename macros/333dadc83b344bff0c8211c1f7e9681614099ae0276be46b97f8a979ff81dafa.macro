Attribute VB_Name = "Mod1Prepare"
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'|fffd| APPLICATION:   PrintThruEmail.xla
'|fffd|
'|fffd| AUTHOR & DATE: FCO ORLANDO MAGALH|fffd|ES FILHO  4 April 2000
'|fffd|                Microsoft MVP - Excel
'|fffd|                Santa Quit|fffd|ria-Ce - Brazil
'|fffd|
'|fffd| CONTACT:       orlando@cpap.com.br
'|fffd| WEB SITE:      http://cpap.com.br/orlando
'|fffd|
'|fffd| DESCRIPTION:   Print Excel report thru email
'|fffd|
'|fffd| COPYRIGHTS:    Free to use with your application and free to distribute
'|fffd|                since this pack and any of file is not alter without previous
'|fffd|                authorization of the author.
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
Option Explicit

Type tPaperSize
    vXlIndex As Integer
    vName As String
    vWidth As Double
    vHeight As Double
End Type
Public vPaperSize As tPaperSize

Public Pindx As Integer
Public PressBot As Integer
Public P(44, 4)

Public bPrintProtect As Boolean
Public bShHasPass As Boolean
Public sShPass As String
Public sPrintPass As String
Public HasVBAProject As Boolean
Public RetError As Long

Dim filtArray()
Dim sFiltRng As String
Dim i As Long
Dim bEnableEvents As Boolean
Dim Cfg(34 + 1)

Sub EnviarEmailPrintArea()
    Dim ActWkb As Workbook
    Dim ActWkbSel    'As Range
    Dim NewWkb As Workbook
    Dim sPrintArea As String
    Dim Fig As Shape
    Dim Nome As Name
    Dim bHasShapes As Boolean
    Dim bShapeOutPrnt As Boolean
    Dim TmpWkb As Workbook
    Dim bHasVCmOutPrtA As Boolean    'Tem dados visiveis fora da |fffd|rea de impress|fffd|o

    Dim LinI As Long
    Dim LinF As Long
    Dim ColI As Long
    Dim ColF As Long
    Dim LinFt As Long
    Dim ColFt As Long
    Dim j As Long
    Dim AppCalc As Long
    Dim WbSaved As Boolean
    Dim ShScrArea As String

    On Error Resume Next
    Set ActWkb = ActiveWorkbook
    Set ActWkbSel = Selection
    Range("A1").Select
    If Err.Number <> 0 Then
        RetError = 1
        Exit Sub
    End If
    On Error GoTo 0

    'Obtendo |fffd|rea de impress|fffd|o
    WbSaved = ActiveWorkbook.Saved
    ShScrArea = ActiveWorkbook.ActiveSheet.ScrollArea
    If ActiveWorkbook.ActiveSheet.Type <> xlWorksheet Then GetMacroSheetPrintProperties    'Necess|fffd|rio antes de copiar...
    sPrintArea = ActiveWorkbook.ActiveSheet.PageSetup.PrintArea
    If sPrintArea = "" Then
        Dim s As Shape
        Dim lHeight As Double
        Dim lWidth As Double
        lHeight = 0
        lWidth = 0
        For Each s In ActiveWorkbook.ActiveSheet.Shapes
            If s.Visible Then
                If s.Left + s.Width > lWidth Then lWidth = s.Left + s.Width
                If s.Top + s.Height > lHeight Then lHeight = s.Top + s.Height
            End If
        Next

        Dim c As Range
        Set c = ActiveWorkbook.ActiveSheet.UsedRange
        If c.Left + c.Width >= lWidth Then lWidth = c.Left + c.Width
        If c.Top + c.Height >= lHeight Then lHeight = c.Top + c.Height

        For Each c In Range("A1").EntireRow.Cells
            If c.Left + c.Width >= lWidth Then
                sPrintArea = c.Column
                Exit For
            End If
        Next
        For Each c In Range("A1").EntireColumn.Cells
            If c.Top + c.Height >= lHeight Then
                sPrintArea = Range(Cells(1, 1), Cells(c.Row, sPrintArea * 1)).Address
                Exit For
            End If
        Next
    End If

    'Capta e envia s|fffd| |fffd|rea de impress|fffd|o da planilha ativa
    AppCalc = Application.Calculation
    Application.Calculation = xlManual
    Application.ScreenUpdating = False: If Val(Application.Version) >= 15 Then Application.ScreenUpdating = True    'No 2013 necess|fffd|rio para o Excel atualiza a ribbon na nova janela SDI criada na c|fffd|pia
    bEnableEvents = Application.EnableEvents
    Application.EnableEvents = False: If Val(Application.Version) >= 15 Then Application.Run "cpap_ex8.mac!WinSDIalinhGet"    'No Excel 2013 SDI estoca pos e size da janela ativa para alinh a abrir.
    If ShScrArea <> "" Then ActiveWorkbook.ActiveSheet.ScrollArea = ""

    If Val(Application.Version) >= 12 And (ActiveWorkbook.ActiveSheet.Type = xlExcel4MacroSheet Or ActiveWorkbook.ActiveSheet.Type = xlExcel4IntlMacroSheet) Then
        If Not MacroSheetCopyViaSCopyAs Then ActiveWorkbook.ActiveSheet.Copy    'Para evitar GPF em ActiveWorkbook.ActiveSheet.Copy tenta primeiro via SaveCopyAs.
        Application.StatusBar = "  "    'False nao atualiza imediatamente no Excel 2007, parece bug
    Else
        ActiveWorkbook.ActiveSheet.Copy
    End If

    MyWait 0.1    '10 = 10 Necess|fffd|rio no 2010 se n|fffd|o o conte|fffd|do de c|fffd|lulas n|fffd|o |fffd| copiado
    Set NewWkb = ActiveWorkbook: Application.Run "cpap_ex8.mac!EnableExc7Verif", True: If Val(Application.Version) >= 15 Then Application.Run "cpap_ex8.mac!MyWait", 0.1: Application.ExecuteExcel4Macro ("SHOW.TOOLBAR(""Ribbon"",FALSE)"): Application.Run "cpap_ex8.mac!WinSDIalinhSet": Application.ScreenUpdating = False   'No 2013 alinh e oculta Ribbon para evitar a exib. da do Excel.
    If bShHasPass Then
        On Error Resume Next
        ActiveWorkbook.ActiveSheet.Unprotect sShPass
        If Err.Number <> 0 Then
            ActWkb.Activate    'No 2013 tive que inverter ativando ActWkb para depois ocultar janela e fechar NewWkb que fechava por ActiveWindow
            NewWkb.Windows(1).Visible = False: NewWkb.Close False
            Application.Calculation = AppCalc
            Application.EnableEvents = bEnableEvents
            Application.ScreenUpdating = True
            ActWkb.Saved = WbSaved
            RetError = 2
            Exit Sub
        End If
    End If
    On Error Resume Next    'Isso ignora qualquer problema. Quando quiser testar o ideal |fffd| quebrar esta linha e usar    On Error GoTo 0

    ActiveWindow.FreezePanes = False

    'Limpa AutoFilter
    Dim bAFmode As Boolean
    Dim HiddRow() As Long
    Dim AFRng As Range
    Dim r As Range
    bAFmode = ActiveWorkbook.ActiveSheet.AutoFilterMode
    If bAFmode Then
        Set AFRng = ActiveWorkbook.ActiveSheet.AutoFilter.Range
        For Each r In AFRng.Rows
            If r.Hidden Then
                i = i + 1
                ReDim Preserve HiddRow(i - 1)
                HiddRow(i - 1) = r.Row
            End If
        Next
        ActiveWorkbook.ActiveSheet.AutoFilterMode = False
        If i > 0 Then
            For j = 0 To i - 1
                ActiveWorkbook.ActiveSheet.Cells(HiddRow(j), 1).EntireRow.Hidden = True
            Next
        End If
    End If

    'Paste |fffd| necess|fffd|rio aqui para completar texto de c|fffd|lulas com mais de 255
    'caracteres n|fffd|o suportada pela c|fffd|pia de planilha inteira. Paste special
    'n|fffd|o funciona aqui se houver c|fffd|lulas mescladas ent|fffd|o usa CopyObjectsWithCells
    ActWkb.Activate
    If bAFmode Then StoreAutoFilter
    Application.CopyObjectsWithCells = False
    Application.GoTo Reference:=Range(sPrintArea)
    Selection.Copy

    NewWkb.Activate
    Application.GoTo Reference:=Range(sPrintArea)
    Application.DisplayAlerts = False    'Skip name alert
    ActiveWorkbook.ActiveSheet.Paste
    Application.CutCopyMode = False
    Application.DisplayAlerts = True

    If bAFmode Then
        ActWkb.Activate
        RestoreAutoFilter
        NewWkb.Activate
    End If

    'Paste especial para eliminar formulas
    Application.GoTo Reference:=Range(sPrintArea)
    Selection.Copy
    Selection.PasteSpecial Paste:=xlValues
    Application.CutCopyMode = False
    Application.CopyObjectsWithCells = True
    Selection.Locked = True

    'Quebrar links de gr|fffd|ficos convertendo em figura e excluir se n|fffd|o imprim|fffd|veis
    Dim Ch As ChartObject, Ch1 As ChartObject
    Dim sr As Series
    Dim sNumbFormC As String, sNumbFormV As String
    Dim oPic As Object
    Dim i1 As Long
    For Each Ch In ActiveWorkbook.ActiveSheet.ChartObjects
        i = i + 1
        If Not Ch.PrintObject Or Ch.ShapeRange.Left > Range(sPrintArea).Left + Range(sPrintArea).Width Or Ch.ShapeRange.Top > Range(sPrintArea).Top + Range(sPrintArea).Height Then
            Ch.Delete
        Else
            Ch.Chart.Axes(xlCategory).TickLabels.AutoScaleFont = False
            Ch.Chart.Axes(xlValue).TickLabels.AutoScaleFont = False
            Ch.Chart.Axes(xlCategory).TickLabels.NumberFormatLinked = False
            Ch.Chart.Axes(xlValue).TickLabels.NumberFormatLinked = False

            'Obter algumas propriedades do original que podem ter sido alterada na copia da planilha normalmente quando h|fffd| links externos
            i1 = 0
            For Each Ch1 In ActWkb.ActiveSheet.ChartObjects
                i1 = i1 + 1
                If i1 = i Then
                    sNumbFormC = Ch1.Chart.Axes(xlCategory).TickLabels.NumberFormat
                    sNumbFormV = Ch1.Chart.Axes(xlValue).TickLabels.NumberFormat
                    Exit For
                End If
            Next

            Ch.Chart.Axes(xlCategory).TickLabels.NumberFormat = sNumbFormC
            If Ch.Chart.Axes(xlCategory).CategoryType = xlAutomaticScale _
                    And InStr(1, sNumbFormC, "/") > 0 Then
                Ch.Chart.Axes(xlCategory).CategoryType = xlTimeScale
                sNumbFormC = IIf(Application.International(xl4DigitYears), "yyyy", "yy")
                Select Case Application.International(xlDateOrder)
                Case 0
                    sNumbFormC = IIf(Application.International(xlMonthLeadingZero), "mm", "m") & "/" & IIf(Application.International(xlDayLeadingZero), "dd", "d") & "/" & sNumbFormC
                Case 1
                    sNumbFormC = IIf(Application.International(xlDayLeadingZero), "dd", "d") & "/" & IIf(Application.International(xlMonthLeadingZero), "mm", "m") & "/" & sNumbFormC
                Case 2
                    sNumbFormC = sNumbFormC & "/" & IIf(Application.International(xlMonthLeadingZero), "mm", "m") & "/" & IIf(Application.International(xlDayLeadingZero), "dd", "d")
                End Select
                Ch.Chart.Axes(xlCategory).TickLabels.NumberFormat = sNumbFormC
            End If

            Ch.Chart.Axes(xlValue).TickLabels.NumberFormat = sNumbFormV

            Ch.Chart.CopyPicture Appearance:=xlScreen, Size:=xlScreen, Format:=xlPicture
            Set oPic = ActiveWorkbook.ActiveSheet.Pictures.Paste
            oPic.ShapeRange.Left = Ch.Left
            oPic.ShapeRange.Top = Ch.Top
            While oPic.ZOrder > Ch.ZOrder
                oPic.ShapeRange.ZOrder msoSendBackward
            Wend
            oPic.Placement = xlMove
            Ch.Delete
        End If
    Next

    'Excluindo coment|fffd|rios n|fffd|o imprim|fffd|veis
    Dim cm As Comment
    If ActiveWorkbook.ActiveSheet.Comments.Count > 0 Then
        Select Case ActiveWorkbook.ActiveSheet.PageSetup.PrintComments
        Case xlPrintNoComments
            Range("A1").SpecialCells(xlCellTypeComments).ClearComments
        Case xlPrintInPlace
            For Each cm In ActiveWorkbook.ActiveSheet.Comments
                If cm.Visible Then
                    bShapeOutPrnt = cm.Shape.Top + cm.Shape.Height < Range(sPrintArea).Top _
                            Or cm.Shape.Left + cm.Shape.Width < Range(sPrintArea).Left _
                            Or cm.Shape.Left > Range(sPrintArea).Left + Range(sPrintArea).Width _
                            Or cm.Shape.Top > Range(sPrintArea).Top + Range(sPrintArea).Height
                    If bShapeOutPrnt Then
                        cm.Delete
                    Else
                        cm.Shape.Placement = xlMove
                        If Intersect(cm.Parent, Range(sPrintArea)) Is Nothing Then bHasVCmOutPrtA = True
                    End If
                Else
                    cm.Delete
                End If
            Next
        Case xlPrintSheetEnd
            For Each cm In ActiveWorkbook.ActiveSheet.Comments
                If Intersect(cm.Parent, Range(sPrintArea)) Is Nothing Then cm.Delete
            Next
        End Select
    End If

    'Excluindo objetos n|fffd|o imprim|fffd|veis e quebrar links
    For Each Fig In ActiveWorkbook.ActiveSheet.Shapes
        If Fig.Type <> msoComment And Fig.Type <> msoChart Then
            If Not Fig.Visible Then
                Fig.Delete
            Else
                bShapeOutPrnt = Fig.Top + Fig.Height < Range(sPrintArea).Top _
                        Or Fig.Left + Fig.Width < Range(sPrintArea).Left _
                        Or Fig.Left > Range(sPrintArea).Left + Range(sPrintArea).Width _
                        Or Fig.Top > Range(sPrintArea).Top + Range(sPrintArea).Height
                If bShapeOutPrnt Then
                    Fig.Delete
                Else
                    If Fig.ControlFormat.PrintObject Then
                        If Fig.Type <> msoOLEControlObject Then
                            Fig.OnAction = ""
                            If Fig.Type <> msoFormControl And Fig.Type <> msoGroup And Fig.Type <> msoLine Then Fig.DrawingObject.Formula = ""
                        End If
                        Fig.Placement = xlMove
                    Else
                        Fig.Delete
                    End If
                End If
            End If
        End If
    Next
    Range("A1").Select

    'Quebrar query table links
    Dim qt As QueryTable
    If ActiveWorkbook.ActiveSheet.Type = xlWorksheet Then
        If ActiveWorkbook.ActiveSheet.QueryTables.Count > 0 Then
            For Each qt In ActiveWorkbook.ActiveSheet.QueryTables
                qt.Delete
            Next
        End If
    End If

    'Quebrar hyperlinks
    Dim h As Hyperlink
    For Each h In ActiveWorkbook.ActiveSheet.Hyperlinks
        h.Address = ""
        h.SubAddress = ActiveWorkbook.ActiveSheet.Name & "!A1"
    Next

    'Excluindo nomes (Preciso verificar links aqui tamb|fffd|m xxxx)
    For Each Nome In ActiveWorkbook.Names
        If Right(Nome.Name, 10) = "Print_Area" _
                Or Right(Nome.Name, 12) = "Print_Titles" _
                Then Else Nome.Delete
    Next

    'Quebrar links externos restantes (O m|fffd|todo BreakLink s|fffd| funciona Excel 2002 em diante)
    Dim arrLinks As Variant
    Dim sLnk As Variant
    Dim bHasLnkYet As Boolean
    arrLinks = ActiveWorkbook.LinkSources(Type:=xlLinkTypeOLELinks)
    If Not IsEmpty(arrLinks) Then
        For Each sLnk In arrLinks
            If Val(Application.Version) > 9 Then ActiveWorkbook.BreakLink _
                    Name:=sLnk, Type:=xlLinkTypeOLELinks Else bHasLnkYet = True
        Next
    End If
    arrLinks = ActiveWorkbook.LinkSources(Type:=xlLinkTypeExcelLinks)
    If Not IsEmpty(arrLinks) Then
        For Each sLnk In arrLinks
            If Val(Application.Version) > 9 Then ActiveWorkbook.BreakLink _
                    Name:=sLnk, Type:=xlLinkTypeExcelLinks Else bHasLnkYet = True
        Next
    End If
    '    If bHasLnkYet Then 'Esse alert pode ser falso, por isso foi removido
    '        If IsPortg Then
    '            Msg1 = "Nem todos os v|fffd|nculos foram removidos. Normalmente isto n|fffd|o causa qualquer problema, se o destinat|fffd|rio, ao abrir, cancelar o alerta para atualizar v|fffd|nculos. " _
                 '                    & Chr(10) & Chr(10) & "Por favor, se for poss|fffd|vel, envie uma c|fffd|pia da impress|fffd|o para orlando@cpap.com.br para que o problema possa ser corrigido. "
    '                    Msg2 = "Falha! Removendo V|fffd|nculos"
    '        Else
    '            Msg1 = "Nor all links were removed. Normally this don't cause any problem, if the recipient, when open, cancels the alert to update links. " _
                 '                    & Chr(10) & Chr(10) & "Please, if it's possible, send a print copy to orlando@cpap.com.br for that the problem could be corrected."
    '                    Msg2 = "Fail! Removing Links"
    '        End If
    '        MyMsgBox Msg1, 1, Msg2
    '    End If

    'Limpando colunas e linhas fora da |fffd|rea de impress|fffd|o (N|fffd|o d|fffd| para excluir, pois pode haver coment|fffd|rios)
    LinI = ActiveWorkbook.ActiveSheet.Range(sPrintArea).Row
    LinF = LinI + ActiveWorkbook.ActiveSheet.Range(sPrintArea).Rows.Count - 1
    ColI = ActiveWorkbook.ActiveSheet.Range(sPrintArea).Column
    ColF = ColI + ActiveWorkbook.ActiveSheet.Range(sPrintArea).Columns.Count - 1
    LinFt = ActiveWorkbook.ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell).Row + 100
    ColFt = ActiveWorkbook.ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell).Column + 100
    If LinFt > 65536 Then LinFt = 65536
    If ColFt > 250 Then ColFt = 250
    If LinFt > LinF Then
        With ActiveWorkbook.ActiveSheet.Range(Cells(LinF + 1, 1), Cells(LinFt, 1)).EntireRow
            If bHasVCmOutPrtA Then
                .ClearContents
                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
            Else
                .Delete
            End If
        End With
    End If
    If ColFt > ColF Then
        With ActiveWorkbook.ActiveSheet.Range(Cells(1, ColF + 1), Cells(1, ColFt)).EntireColumn
            If bHasVCmOutPrtA Then
                .ClearContents
                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
            Else
                .Delete
            End If
        End With
    End If
    If LinI > 1 Then
        With ActiveWorkbook.ActiveSheet.Range(Cells(1, 1), Cells(LinI - 1, 1)).EntireRow
            If bHasVCmOutPrtA Then
                .ClearContents
                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                .Hidden = True
            Else
                .Delete
            End If
        End With
    End If
    If ColI > 1 Then
        With ActiveWorkbook.ActiveSheet.Range(Cells(1, 1), Cells(1, ColI - 1)).EntireColumn
            If bHasVCmOutPrtA Then
                .ClearContents
                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                .Hidden = True
            Else
                .Delete
            End If
        End With
    End If

    'Excluindo linhas e colunas ocultas em lote para maior rapidez
    Dim iAc As Long
    If Not bHasVCmOutPrtA Then
        j = ActiveWorkbook.ActiveSheet.Range(sPrintArea).Rows.Count
        iAc = 0
        For i = j To 1 Step -1
            If i - 1 > 0 Then
                iAc = iAc - 1 * (Cells(i, 1).Height = 0)
                If iAc > 0 And (Cells(i - 1, 1).Height <> 0 Or i - 1 = 1) Then
                    Range(Cells(i, 1), Cells(i + iAc - 1, 1)).EntireRow.Delete
                    iAc = 0
                End If
            Else
                If Cells(1, 1).Height = 0 Then Cells(1, 1).EntireRow.Delete
            End If
            Application.StatusBar = IIf(IsPortg, "Limpando linhas: ", "Cleaning rows: ") & Int((j - i) / j * 100) & "%"
        Next
        j = ActiveWorkbook.ActiveSheet.Range(sPrintArea).Columns.Count
        iAc = 0
        For i = j To 1 Step -1
            If i - 1 > 0 Then
                iAc = iAc - 1 * (Cells(1, i).Width = 0)
                If iAc > 0 And (Cells(1, i - 1).Width <> 0 Or i - 1 = 1) Then
                    Range(Cells(1, i), Cells(1, i + iAc - 1)).EntireColumn.Delete
                    iAc = 0
                End If
            Else
                If Cells(1, 1).Width = 0 Then Cells(1, 1).EntireColumn.Delete
            End If
            Application.StatusBar = IIf(IsPortg, "Limpando colunas: ", "Cleaning columns: ") & Int((j - i) / j * 100) & "%"
        Next
    End If
    Application.StatusBar = False
    Application.Calculation = AppCalc

    'Evitar alerta de macro
    If ActiveWorkbook.ActiveSheet.Type <> xlWorksheet Then
        'Convertendo macrosheet para sheet
        MacroSheetToSheet LinFt, ColFt: Set NewWkb = ActiveWorkbook    'No 2013, mas era bug antigo.
    Else
        'Limpando VBAProject
        Dim ShCN As String
        Dim CofL As Long
        HasVBAProject = False
        On Error Resume Next    'Se a op|fffd||fffd|o de acesso ao VBA por c|fffd|digo n|fffd|o estiver assinalada causa erro
        If ActiveWorkbook.ActiveSheet.Parent.VBProject.Protection = 0 Then
            If Err.Number = 0 Then
                ShCN = ActiveWorkbook.ActiveSheet.CodeName
                CofL = ActiveWorkbook.ActiveSheet.Parent.VBProject.VBComponents(ShCN).CodeModule.CountOfLines
                If CofL > 1 Then
                    HasVBAProject = True
                    ActiveWorkbook.ActiveSheet.Parent.VBProject.VBComponents(ShCN).CodeModule.DeleteLines 1, CofL
                End If
            End If
        End If
    End If

    Application.GoTo Range("A1"), True
    'ActiveWorkbook.ActiveSheet.ScrollArea = Range(sPrintArea).Address
    If bPrintProtect Then ActiveWorkbook.ActiveSheet.Protect sPrintPass
    ActWkb.Windows(1).Visible = False: NewWkb.Activate    'No 2013 SDI oculta para ficar janela |fffd|nica.
    EnviarEmailTudo

    ActWkb.Windows(1).Visible = True: ActWkb.Activate   'No 2013 tive que inverter ativando ActWkb para depois ocultar janela e fechar NewWkb que fechava por ActiveWindow
    NewWkb.Windows(1).Visible = False: NewWkb.Saved = True: NewWkb.Close False
    ActWkb.Activate: If ShScrArea <> "" Then ActiveWorkbook.ActiveSheet.ScrollArea = ShScrArea
    ActWkbSel.Select
    Application.EnableEvents = bEnableEvents
    ActWkb.Saved = WbSaved
    Application.ScreenUpdating = True
End Sub

Sub StoreAutoFilter()
    If bShHasPass Then ActiveWorkbook.ActiveSheet.Unprotect sShPass
    With ActiveWorkbook.ActiveSheet.AutoFilter
        sFiltRng = .Range.Address
        With .Filters
            ReDim filtArray(1 To .Count, 1 To 3)
            For i = 1 To .Count
                With .Item(i)
                    If .On Then
                        filtArray(i, 1) = .Criteria1
                        If .Operator Then
                            filtArray(i, 2) = .Operator
                            filtArray(i, 3) = .Criteria2
                        End If
                    End If
                End With
            Next
        End With
    End With
    ActiveWorkbook.ActiveSheet.AutoFilterMode = False
End Sub

Sub RestoreAutoFilter()
    ActiveWorkbook.ActiveSheet.AutoFilterMode = False
    For i = 1 To UBound(filtArray(), 1)
        If Not IsEmpty(filtArray(i, 1)) Then
            If filtArray(i, 2) Then
                ActiveWorkbook.ActiveSheet.Range(sFiltRng).AutoFilter field:=i, _
                        Criteria1:=filtArray(i, 1), _
                        Operator:=filtArray(i, 2), _
                        Criteria2:=filtArray(i, 3)
            Else
                ActiveWorkbook.ActiveSheet.Range(sFiltRng).AutoFilter field:=i, _
                        Criteria1:=filtArray(i, 1)
            End If
        End If
    Next
    If bShHasPass Then ActiveWorkbook.ActiveSheet.Protect sShPass
End Sub

Sub GetMacroSheetPrintProperties()
'Necess|fffd|rio pegar no original porque ao copiar propriedade podem sofrer altera|fffd||fffd|o como a Zoom em macrosheet no 2007 (Bug relatado a MS). E acredido que usando PageSetup s|fffd| em planilha ativa fica mais r|fffd|pido e est|fffd|vel.
    With ActiveWindow
        Cfg(1) = .DisplayGridlines
        Cfg(2) = .DisplayHeadings
        Cfg(3) = .DisplayOutline
        Cfg(4) = .DisplayZeros
        Cfg(5) = .DisplayWorkbookTabs
    End With

    With ActiveWorkbook.ActiveSheet.PageSetup
        Cfg(6) = .PrintTitleRows
        Cfg(7) = .PrintTitleColumns
        Cfg(8) = .PrintArea
        Cfg(9) = .LeftHeader
        Cfg(10) = .CenterHeader
        Cfg(11) = .RightHeader
        Cfg(12) = .LeftFooter
        Cfg(13) = .CenterFooter
        Cfg(14) = .RightFooter
        Cfg(15) = .LeftMargin
        Cfg(16) = .RightMargin
        Cfg(17) = .TopMargin
        Cfg(18) = .BottomMargin
        Cfg(19) = .HeaderMargin
        Cfg(20) = .FooterMargin
        Cfg(21) = .PrintHeadings
        Cfg(22) = .PrintGridlines
        Cfg(23) = .PrintComments
        Cfg(24) = .CenterHorizontally
        Cfg(25) = .CenterVertically
        Cfg(26) = .Orientation
        Cfg(27) = .Draft
        Cfg(28) = .PaperSize
        Cfg(29) = .FirstPageNumber
        Cfg(30) = .Order
        Cfg(31) = .BlackAndWhite
        Cfg(32) = .Zoom
        Cfg(33) = .FitToPagesWide
        Cfg(34) = .FitToPagesTall
    End With
End Sub

Sub MacroSheetToSheet(LinFt As Long, ColFt As Long)
'Se fosse MacroSheet daria alerta de virus
    Dim ActMacroSh As Worksheet
    Dim NewNormalSh As Worksheet

    Application.StatusBar = IIf(IsPortg, "Planilha de macro para planilha: C|fffd|lulas...", "Macrosheet to sheet: Cells...")
    Set ActMacroSh = ActiveWorkbook.ActiveSheet: On Error GoTo ErrorHandler    'No 2013 acontece erro em sil|fffd|ncio e volta deixando NewNormalSh aberto e perdido. Agora alerta e fecha, voltando e enviando mesmo a macrosheet que vai dar alerta da macro ao impormir.
    'Atualizando propriedadades que podem ter sofrido altera|fffd||fffd|es na c|fffd|pia tratada em rela|fffd||fffd|o |fffd| original
    With ActMacroSh.PageSetup
        Cfg(6) = .PrintTitleRows
        Cfg(7) = .PrintTitleColumns
        Cfg(8) = .PrintArea
    End With

    Application.CopyObjectsWithCells = False: If Val(Application.Version) >= 15 Then Application.Run "cpap_ex8.mac!WinSDIalinhGet": Application.ScreenUpdating = True    'No Excel 2013 SDI estoca pos e size da janela ativa para alinh a abrir. E ScreenUpdating True para o Excel atualizar a ribbon na nova janela SDI criada no new sheet
    Application.Workbooks.Add xlWBATWorksheet    'Cria planilha em uma nova pasta, pois na mesma deu gpf no Excel XP, mas apenas em tab.mac
    Set NewNormalSh = ActiveWorkbook.ActiveSheet: Application.Run "cpap_ex8.mac!EnableExc7Verif", True: If Val(Application.Version) >= 15 Then Application.Run "cpap_ex8.mac!MyWait", 0.1: Application.ExecuteExcel4Macro ("SHOW.TOOLBAR(""Ribbon"",FALSE)"): Application.Run "cpap_ex8.mac!WinSDIalinhSet": Application.ScreenUpdating = False   'No 2013 alinh e oculta Ribbon para evitar a exib. da do Excel.
    ActMacroSh.Activate: Application.Run "cpap_ex8.mac!ClearClipb": ActMacroSh.Range(ActMacroSh.Cells(1, 1), ActMacroSh.Cells(LinFt, ColFt)).Copy: Application.Wait Now() + TimeSerial(0, 0, 1)   'ActMacroSh.Cells.Copy O copy total com o paste falha no 2007 na largura das colunas. No Excel 2013 falha aqui sem alert de erro, ent|fffd|o tentei usar a seq. em car de ClearClipb()&COPY()&WAIT() e implemente o controle de erro.
    Selection.PasteSpecial Paste:=xlPasteValues        'No 2013 fiz para detonar as formulas XLM na pr|fffd|pria MacroSheet e n|fffd|o gerar em no paste total na Sheet
    Application.Run "cpap_ex8.mac!ClearClipb": ActMacroSh.Range(ActMacroSh.Cells(1, 1), ActMacroSh.Cells(LinFt, ColFt)).Copy: Application.Wait Now() + TimeSerial(0, 0, 1)
    NewNormalSh.Activate: NewNormalSh.Range("A1").PasteSpecial Paste:=8   'Falha se usar  xlPasteColumnWidths. Antes porque a altura de c|fffd|lulas com quebra de linha n|fffd|o se restaura ao aumentar coluna depois
    NewNormalSh.Paste
    Application.CutCopyMode = False
    Application.CopyObjectsWithCells = True

    With ActiveWindow
        .DisplayGridlines = Cfg(1)
        .DisplayHeadings = Cfg(2)
        .DisplayOutline = Cfg(3)
        .DisplayZeros = Cfg(4)
        .DisplayWorkbookTabs = Cfg(5)
    End With

    With NewNormalSh.PageSetup
        .PrintTitleRows = Cfg(6)
        .PrintTitleColumns = Cfg(7)
        .PrintArea = Cfg(8)
        .LeftHeader = Cfg(9)
        .CenterHeader = Cfg(10)
        .RightHeader = Cfg(11)
        .LeftFooter = Cfg(12)
        .CenterFooter = Cfg(13)
        .RightFooter = Cfg(14)
        .LeftMargin = Cfg(15)
        .RightMargin = Cfg(16)
        .TopMargin = Cfg(17)
        .BottomMargin = Cfg(18)
        .HeaderMargin = Cfg(19)
        .FooterMargin = Cfg(20)
        .PrintHeadings = Cfg(21)
        .PrintGridlines = Cfg(22)
        .PrintComments = Cfg(23)
        .CenterHorizontally = Cfg(24)
        .CenterVertically = Cfg(25)
        .Orientation = Cfg(26)
        .Draft = Cfg(27)
        .PaperSize = Cfg(28)
        .FirstPageNumber = Cfg(29)
        .Order = Cfg(30)
        .BlackAndWhite = Cfg(31)
        .Zoom = Cfg(32)
        .FitToPagesWide = Cfg(33)
        .FitToPagesTall = Cfg(34)
    End With

    'Copiando ajustando objetos
    If ActMacroSh.Shapes.Count > 0 Then
        Application.StatusBar = IIf(IsPortg, "Planilha de macro para planilha: Objetos...", "Macrosheet to sheet: Objects...")
        ActMacroSh.Parent.Activate
        With ActMacroSh.Shapes.AddShape(msoShapeRectangle, 0, 0, 1, 1)    'Para o shapes copiados n|fffd|o perderem posi|fffd||fffd|o no paste
            .Fill.Visible = msoFalse
            .Fill.Transparency = 0#
            .Line.Visible = msoFalse
        End With
        ActMacroSh.Range("A1").Select
        Dim Shp As Shape
        For Each Shp In ActMacroSh.Shapes    'Ao copiar e colar na sheet, nomes padr|fffd|o tipo Line 17 ou Rectangule 17 podem sofrer altera|fffd||fffd|o. Ent|fffd|o renomear todos os nomes padr|fffd|o na macrosheet e depois restaurar na sheet.
            If Shp.Visible And InStr(1, Shp.Name, "Commen") = 0 Then Shp.Name = Replace(Shp.Name, " ", "{/}SpaceMrk(/}")
        Next
        Application.Run "cpap_ex8.mac!ClearClipb"    'N|fffd|o parece ser necess|fffd|rio
        ActMacroSh.Shapes.SelectAll    'ActMacroSh.DrawingObjects.Select
        If Selection.ShapeRange.Count = 1 Then Selection.Copy _
            Else Selection.ShapeRange.Group.Copy               'No 2007 e 2010 o copy mesmo n|fffd|o usando DrawingObjects tem instabilida, mas agrupando parece melhorar
        Application.Wait Now() + TimeSerial(0, 0, 1)   'No Excel 2013 completei para ficar a mesma seq. em car de ClearClipb()&COPY()&WAIT()
        NewNormalSh.Parent.Activate
        NewNormalSh.Range("A1").Select
        NewNormalSh.Paste
        NewNormalSh.Range("A1").Select
        Application.Run "cpap_ex8.mac!ClearClipb"    'Mais por seguran|fffd|a autoral

        'Copiar agrupado com balizando um objto em A1 mantem a posi|fffd||fffd|o absoluta, mas linhas em sheet apesar da mesma formata|fffd||fffd|o tem menor altura. Ent|fffd|o |fffd| necessario reposicionar objto de acordo com TopLeftCell
        'Application.ScreenUpdating = True
        Dim lRow As Long, lCol As Long, dLeft As Double, dTop As Double, dZoom As Double
        ActMacroSh.Parent.Activate: dZoom = Application.ActiveWindow.Zoom: Application.ActiveWindow.Zoom = 100: ActMacroSh.Shapes.SelectAll: Selection.Ungroup
        NewNormalSh.Parent.Activate: Application.ActiveWindow.Zoom = 100: NewNormalSh.Shapes.SelectAll: Selection.Ungroup
        For Each Shp In ActMacroSh.Shapes
            If Shp.Visible And InStr(1, Shp.Name, "Commen") = 0 Then
                lRow = Shp.TopLeftCell.Row: lCol = Shp.TopLeftCell.Column
                If Shp.Top > 0 Then    'No Excel 2010 n|fffd|o ajusta negativo ent|fffd|o deixa como ficou
                    dTop = Shp.Top - ActMacroSh.Cells(lRow, lCol).Top
                    NewNormalSh.Shapes(Shp.Name).Top = NewNormalSh.Cells(lRow, lCol).Top + dTop
                End If
                If Shp.Left > 0 Then
                    dLeft = Shp.Left - ActMacroSh.Cells(lRow, lCol).Left
                    NewNormalSh.Shapes(Shp.Name).Left = NewNormalSh.Cells(lRow, lCol).Left + dLeft
                End If
            End If
        Next
        Application.ActiveWindow.Zoom = dZoom
        For Each Shp In NewNormalSh.Shapes    'Restaurando nomes padr|fffd|o
            If Shp.Visible And InStr(1, Shp.Name, "Commen") = 0 Then Shp.Name = Replace(Shp.Name, "{/}SpaceMrk(/}", " ")
        Next
    End If

    Application.StatusBar = IIf(IsPortg, "Planilha de macro para planilha: Finalizando...", "Macrosheet to sheet: Finishing...")
    Application.DisplayAlerts = False
    NewNormalSh.Parent.Activate    'No 2013 tive que inverter ativando NewNormalSh para depois ocultar janela e fechar ActMacroSh
    ActMacroSh.Parent.Windows(1).Visible = False: ActMacroSh.Parent.Saved = True: ActMacroSh.Parent.Close False: NewNormalSh.Parent.Activate
    Application.DisplayAlerts = True
    Application.StatusBar = False
    Exit Sub
ErrorHandler:        'No 2013, na falha, vai ser impressa mesma a macrosheet, mas as formulas j|fffd| foram matadas acima
    MsgBox "(" & Err.Number & ") " & Err.Description, , "Falha! Sub MacroSheetToSheet Evitar Alerta de Macro"
    ActMacroSh.Parent.Activate: ActMacroSh.Activate
    If Not NewNormalSh Is Nothing Then NewNormalSh.Parent.Saved = True: NewNormalSh.Parent.Close False
End Sub

Function MacroSheetCopyViaSCopyAs() As Boolean
'No 2010 e 2077 ActiveWorkbook.ActiveSheet.Copy causa GPF e instabilidade se macrosheet. Um problema |fffd| que se o
'workbook original for protegido a senha precisa ser trocada e deve ser fechado depois sem salvar.
'Como s|fffd| trabalha read-only ent|fffd|o n|fffd|o |fffd| problema para o CPAP, mas vou deixar s|fffd| para o 2007 em diante.
    Dim PathTemp As String
    Dim sShName As String
    Application.StatusBar = "C|fffd|pia especial de macrosheets..."

    PathTemp = fReturnTempDir()
    If Right(PathTemp, 1) = "\" Then PathTemp = Left(PathTemp, Len(PathTemp) - 1)
    PathTemp = PathTemp & "\McShToSh.tmp"
    On Error Resume Next
    If Dir(PathTemp) <> "" Then Kill PathTemp
    sShName = ActiveWorkbook.ActiveSheet.Name
    ActiveWorkbook.ActiveSheet.Calculate
    If Err.Number = 0 Then
        If ActiveWorkbook.HasPassword = True Then ActiveWorkbook.Password = "123abc*-8@32ui": ActiveWorkbook.Saved = True
        ActiveWorkbook.SaveCopyAs PathTemp
    End If
    If Err.Number <> 0 Then Exit Function

    Workbooks.Open PathTemp, 0, True, , "123abc*-8@32ui"
    If Err.Number <> 0 Then Exit Function

    ActiveWorkbook.Sheets(sShName).Select
    If Err.Number <> 0 Then Exit Function

    If Dir(PathTemp) <> "" Then Kill PathTemp
    MacroSheetCopyViaSCopyAs = True
End Function


Function fPrintThruEmail(Wb As String, Sh As String, Optional ShPass As String, Optional PrintPass As String) As Long
    If IsMissing(ShPass) Then
        bShHasPass = False
    Else
        bShHasPass = True
        sShPass = ShPass
    End If
    If IsMissing(PrintPass) Then
        sPrintPass = "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|"
    Else
        sPrintPass = PrintPass
    End If
    On Error Resume Next
    Workbooks(Wb).Activate
    If Err.Number <> 0 Then
        fPrintThruEmail = 1
        Exit Function
    End If
    Sheets(Sh).Activate
    If Err.Number <> 0 Then
        fPrintThruEmail = 2
        Exit Function
    End If

    EnviarEmailPrintArea
    If Err.Number <> 0 Then
        fPrintThruEmail = 3
    Else
        fPrintThruEmail = 0
    End If
End Function

Sub test()
'Dica! Para testar no CPAP basta ativar a planilha, desproteger e rodar o EnviarEmailPrintArea acima
    Dim Ret As Long, Wb As Workbook
    Set Wb = Workbooks.Open("T:\ComoMVP\MeuSite\Projetos\PrintThruEmail\PrintThruEmaiTest1.xls")
    Ret = fPrintThruEmail("PrintThruEmaiTest1.xls", "Sheet1", "")
    Wb.Close False
End Sub
Attribute VB_Name = "Mod2aEnviar"
Option Explicit
Public lResult As Long
Public EmlEmail As String
Public bProtect As Boolean
Public bSendByWebmail As Boolean
Public bSendBySMTP As Boolean
Public sAttachDefName As String
Public sAttachFullName As String
Dim bActWbSaved As Boolean    'Indica para n|fffd|o alterar prote|fffd||fffd|o e atachar diretamente o arquivo salvo. |fffd|til no envio de arquivos completo como os de plano
Dim ExcelObj As Object

Sub EnviarEmailTudo()
'Envia a pasta ativa toda
    Dim EmlEmprRed As String
    Dim EmlRel As String
    Dim EmlSubj As String
    Dim EmlEmpr As String
    Dim EmlNome As String
    Dim RelView As String: Dim DirBD, Ctr, WinVer, i, ExcelL|fffd|ngua, ExcelVer, UsarClipb    'Ao implementar CreateNewExcelObj em 17/7/14 em dvr.mac, defini estas |fffd|ltimas para usar Option Explicit, ent|fffd|o descobri antiga refer a UserForm2Cad em vez de UserForm1Email. Isto mostra a import|fffd|ncia de Explicit, principalmente onde tem controle de erro.

    bActWbSaved = ActiveWorkbook.Saved

    EmlEmail = Workbooks("cpap_jap.mac").Sheets(1).Range("EmlEmail").Value
    If EmlEmail <> "suporte@cpap.com.br" Then
        NomeArqHist = "Cadastro.hst"

        If InStr(1, EmlEmail, "@") = 0 Then EmlEmail = "suporte@cpap.com.br"
        Application.ScreenUpdating = False
        DirBD = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirBD").Value)    'DirP = ThisWorkbook.Path
        If MyOpenFile(DirBD & "\banco\" & NomeArqHist, True) Then
            ActiveWindow.Close False
        End If
        'Ajuda
        '      I = Application.WorksheetFunction.Find("!", Cadastr(2).Value)
        '      'Application.VBE.VBProjects("VBAProjectCxCad").HelpFile = Left(Cadastr(2).Value, I - 1)
        '      If Mid(ThisWorkbook.Path, 2, 1) = ":" Then ChDrive ThisWorkbook.Path
        '      If Mid(ThisWorkbook.Path, 2, 1) = ":" Then ChDir ThisWorkbook.Path Else Application.Run "CPAP_EX8.MAC!DirectoryVBA", ThisWorkbook.Path, False
        '      UserForm2Cad.HelpContextID = Right(Cadastr(2).Value, Len(Cadastr(2).Value) - I)

        vEnableEvents = False
        UserForm1Email.Protect_Chb.Value = Not bActWbSaved
        If bActWbSaved Then UserForm1Email.Protect_Chb.Visible = False
        UserForm1Email.Internet_Cb.Value = EmlEmail
        vEnableEvents = True
        Application.ScreenUpdating = True
        Application.StatusBar = False
        UserForm1Email.Internet_Cb.SetFocus
        UserForm1Email.Show
        Application.ScreenUpdating = False
        If BotAcionado = 1 Then Exit Sub
        If BotAcionado = 2 Then
            On Error Resume Next    'Aqui antes de proteger, porque so o padr|fffd|o no form |fffd| proteger e vier direto j|fffd| protegido falha. Este era um bug antigo ao enviar tabela de |fffd|ndice que descobri editan Cpap14 para trabalhar a partir de temp em rede.
            If bProtect Then ActiveWorkbook.ActiveSheet.Protect "OrlandoFranciscoFilho"
            'Eliminar espa|fffd|os no final de textos desde que o controle aceite sem erro
            Application.ScreenUpdating = False
            For Each Ctr In UserForm1Email.Controls
                If Right(Ctr.Name, 2) = "Cb" Then Ctr.Value = RTrim(Ctr.Value)
            Next
            On Error GoTo 0

            'Atualizar hist|fffd|rico
            If MyOpenFile(DirBD & "\banco\" & NomeArqHist, False) Then
                SalvarHist = False
                AtuHist "Internet", UserForm1Email.Internet_Cb.Value, EmlEmail
                If SalvarHist Then SalvandoHist Else Workbooks(NomeArqHist).Close False
            End If
            'Transferindo dados
            EmlEmail = UserForm1Email.Internet_Cb.Value
            Application.ScreenUpdating = False
        End If
        Unload UserForm1Email
        ThisWorkbook.Saved = True
    End If

    EmlEmprRed = Workbooks("cpap_pri.mac").Sheets(1).Range("NomRed").Value
    EmlRel = Workbooks("cpap_jap.mac").Sheets(1).Range("EmlRel").Value
    EmlSubj = EmlEmprRed & " - " & EmlRel
    EmlEmpr = Workbooks("cpap_pri.mac").Sheets(1).Range("NomeEmpr").Value
    EmlNome = Workbooks("cpap_jap.mac").Sheets(1).Range("EmlNome").Value

    RelView = " que pode ser visualizado e impresso atrav|fffd|s do Excel ou de qualquer outro editor de planilha."
    If LCase(Right(ActiveWorkbook.Name, 4)) = ".mda" Then RelView = " que pode ser aberto atrav|fffd|s do CPAP."
    If InStr(1, EmlRel, "de |fffd|ndices") > 0 Then RelView = " que pode ser aberto atrav|fffd|s do CPAP."


    'Primeira tentativa envia usando MAPIvb32.bas sem necessidade de sendkeys.
    'Se falhar tenta o metodo anterior que necessita de send.keys usando ou n|fffd|o o clipboard
    If bActWbSaved Then
        sAttachFullName = ActiveWorkbook.FullName
    Else
        sAttachFullName = fReturnTempDir()
        If Right(sAttachFullName, 1) = "\" Then sAttachFullName = Left(sAttachFullName, Len(sAttachFullName) - 1)
        sAttachDefName = "Cpap_rel.xls" & IIf(Val(Application.Version) >= 12, "x", "")
        sAttachFullName = sAttachFullName & "\" & sAttachDefName
        On Error Resume Next
        If Dir(sAttachFullName) <> "" Then Kill sAttachFullName
        ActiveWorkbook.ActiveSheet.Calculate
        If Err.Number = 0 Then ActiveWorkbook.SaveCopyAs sAttachFullName
        '      ActiveWorkbook.Close False
        If Err.Number <> 0 Then
            MsgBox Err.Description, , "Falha ao salvar arquivo tempor|fffd|rio"
            Exit Sub
        End If
    End If

    Dim Msg As String
    Msg = "Prezado(a) " & EmlNome & "," & vbCrLf & vbCrLf
    Msg = Msg & "Segue, anexo, o(a) " & EmlRel & RelView & vbCrLf & vbCrLf
    Msg = Msg & "Atenciosamente," & vbCrLf & vbCrLf
    Msg = Msg & Application.Rept("_", Len(EmlEmpr)) & vbCrLf
    Msg = Msg & EmlEmpr & vbCrLf

    If Right(EmlEmail, 12) = "@cpap.com.br" Then
        WinVer = Application.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
        i = Application.International(xlCountryCode)
        ExcelL|fffd|ngua = IIf(i = 1, "Ingl|fffd|s", IIf(i = 55, "Portugu|fffd|s", "L|fffd|ngua " & i))
        ExcelVer = "Excel " & Application.Version & " (" & ExcelL|fffd|ngua & ")"
        Msg = Msg & WinVer & vbCrLf
        Msg = Msg & ExcelVer & vbCrLf
        With Workbooks("cpap_pri.mac").Excel4MacroSheets(1)
            Msg = Msg & "CPAP" & IIf(.Range("InfDsk").Value <> 0, "|fffd| ", " ") & "Vers|fffd|o " & Choose(.Range("NumVer").Value, "7,0", "", "2000", "2002") & Format(.Range("DataEd").Value, "yy.mm.dd.hh")   'Vers|fffd|o. Se estiver registrada sai |fffd|
            Msg = Msg & "/HD" & Run("cpap_ex8.mac!GetDriveInfo") & vbCrLf
            Msg = Msg & "|fffd|ltima Atualiza|fffd||fffd|o: " & .Range("DataArq").Value & vbCrLf  '|fffd|lt. Atual
            Msg = Msg & "Data Inicial: " & .Range("DatInic").Value & vbCrLf & vbCrLf   'Data Inicial

            Msg = Msg & "Favor conferir e atualizar nosso cadastro em" & vbCrLf
            Msg = Msg & "vosso banco de dados:" & vbCrLf
            Msg = Msg & "Nome(Raz|fffd|o social): " & .Range("NomeEmpr").Value & vbCrLf
            Msg = Msg & "Nome reduzido: " & .Range("NomRed").Value & vbCrLf
            Msg = Msg & "CNPJ/CPF: " & .Range("CGCempr").Value & vbCrLf
            Msg = Msg & "Endere|fffd|o: " & .Range("EndEmpr").Value & vbCrLf
            Msg = Msg & "CEP: " & .Range("CepEmpr").Value & vbCrLf
            Msg = Msg & "Cidade-Estado: " & .Range("CidUF").Value & vbCrLf
            Msg = Msg & "Fone: " & .Range("FonEmpr").Value & vbCrLf
            Msg = Msg & "Fax: " & .Range("FaxEmpr").Value & vbCrLf
            Msg = Msg & "Licen|fffd|as adicionais: " & .Range("NUsu").Value - 1 & vbCrLf
            Msg = Msg & "M|fffd|dulo de Atualiza|fffd||fffd|es: " & "SIM" & vbCrLf
            Msg = Msg & "M|fffd|dulo de Planos de Pagamentos: " & IIf(.Range("Mplano").Value, "N|fffd|O", "SIM") & vbCrLf
            Msg = Msg & "M|fffd|dulo de Emiss|fffd|o de Contratos: " & IIf(.Range("Mcont").Value, "N|fffd|O", "SIM") & vbCrLf
            Msg = Msg & "M|fffd|dulos de Acompanhamentos de Contrato e de Contas a Receber: " & IIf(.Range("Macomp").Value, "N|fffd|O", "SIM") & vbCrLf
        End With
    End If

    If bSendByWebmail Or bSendBySMTP Then          '10 = 10 Em vez de Outlook, simplesmente desvia para o form de Webmail ou Enviar direto por SMTP onde tudo acontece e reacontece isoladamente at|fffd| fechar
        If Workbooks("cpap_pri.mac").Sheets(1).Range("NomeUsua") = "" Then Application.Run "cpap_pri.mac!Logar"    'Verificar se tem usu|fffd|rio logado, pois precisa da configura|fffd||fffd|o de smptp
        If Workbooks("cpap_pri.mac").Sheets(1).Range("NomeUsua") = "" Then Exit Sub

        With UserForm1SMTPwebmail
            .To_Tb.Text = EmlEmail
            .Subject_Tb.Text = EmlSubj
            .Attach_Tb.Text = sAttachFullName
            .Msg_Tb.Text = Msg
            Application.ScreenUpdating = True
            .Show
            Application.ScreenUpdating = False
        End With
        Exit Sub
    End If

    SendMailByMAPIvb32 EmlEmail, EmlSubj, Msg, sAttachFullName

    If lResult > 1 Or lResult < 0 Then   'Se falhar com MAPIvb32 tenta exibindo xlDialogSendMail do Excel e cola msg com sendkeys
        'Se estiver usando userform VBA, tenta montar o email pelo clipboard
        'pois a cola instant|fffd|nea parece mais elegante do que a inclus|fffd|o demorada com sendkeys
        UsarClipb = Workbooks("cpap_jap.mac").Sheets(1).Range("FormTipo").Value
        On Error Resume Next
        If UsarClipb Then
            Dim MyData As DataObject: Set MyData = New DataObject
            MyData.SetText Msg
            MyData.PutInClipboard
            If Err.Number = 0 Then
                SendKeys "{TAB}{TAB}{BS 30}^v"
            Else
                UsarClipb = False
            End If
        End If

        If UsarClipb = False Then
            Msg = PrepToSendKeys(Msg)
            SendKeys "{TAB}{TAB}{BS 10}" & Msg
        End If

        Application.Dialogs(xlDialogSendMail).Show EmlEmail, EmlSubj
    End If
    AppActivate Application.Caption
End Sub

Sub SendMailByMAPIvb32(Email As String, Subj As String, Msg As String, Attach As String)
    Dim oMsg As MAPIMessage
    Dim oRecipients(0) As MapiRecip
    Dim oAttachments(0) As MapiFile
    Dim lSession As Long
    Dim oCurDir As String

    'Verifica se Outlook Express |fffd| o padr|fffd|o e se for verifica e concerta o registro
    If Left(GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail", ""), 15) = "Outlook Express" Then
        Dim DLLPath
        Dim DLLPathEx
        DLLPath = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPath")
        DLLPath = Application.WorksheetFunction.Clean(DLLPath)
        DLLPathEx = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx")
        DLLPathEx = Application.WorksheetFunction.Clean(DLLPathEx)
        If DLLPath <> DLLPathEx Then
            SetKeyValue HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx", DLLPath, REG_SZ
        End If
    End If

    oCurDir = CurDir   'Store to restore because MAPIvb32 change currente dir

    ' Logon
    lResult = MAPILogon(0, "", "", MAPI_LOGON_UI + MAPI_NEW_SESSION, 0, lSession)

    If lResult = 3 Then   'S|fffd| suspende o envio se usu|fffd|rio cancelar
        '        MsgBox "Logon failed. Result = " & lResult
        lResult = 1   'Indica cancelado pelo usu|fffd|rio
        GoTo RestCurDir
        Exit Sub
    End If

    ' Fill out the message
    With oMsg
        .Reserved = 0
        .NoteText = Msg
        .FileCount = IIf(Attach = "", 0, 1)
        .RecipCount = 1  'only 1 recipient
        .Subject = Subj
    End With

    ' Fill out the recipient
    With oRecipients(0)
        ' TODO: Change "test@online.microsoft.com" to the address you want to send to
        .Name = Email
        .RecipClass = MAPI_TO
        .Reserved = 0
    End With

    If Attach <> "" Then
        With oAttachments(0)
            '         .FileName = "filename.ext" 'File name on the email
            .PathName = Attach   'File fullname on HD
            '    .Position = 0
            '    .FileType = 0
        End With
    End If

    '    lResult = MAPIResolveName(lSession, 0, oRecipients(0).Name, 0, 0, oRecipients(0))
    '
    '    If lResult <> 0 Then
    '        MsgBox "MAPIResolveName failed. Result = " & lResult
    '        GoTo RestCurDir
    '    End If


    ' Send the message
    lResult = MAPISendMail(0, 0, oMsg, oRecipients, oAttachments, MAPI_DIALOG, 0&)

    '   If lResult = 0 Then
    '      MsgBox "Mensagem enviada!", , "CPAP|fffd|"
    '   Else
    '      If lResult <> 1 Then MsgBox "Motivo = " & lResult, , "Falha ao Enviar Mensagem!"
    '   End If

    ' Log off
    If lResult = 0 Or lResult = 1 Then MAPILogoff lSession, 0, 0, 0

    '   If lResult <> 0 Then
    '      MsgBox "Logoff failed. Result = " & lResult
    '   End If

RestCurDir:
    If Mid(oCurDir, 2, 1) = ":" Then ChDrive oCurDir
    If Mid(oCurDir, 2, 1) = ":" Then ChDir oCurDir Else Application.Run "CPAP_EX8.MAC!DirectoryVBA", oCurDir, False
End Sub


Function PrepToSendKeys(vStr As String) As String
    With Application.WorksheetFunction
        vStr = .Substitute(vStr, "{", "[")
        vStr = .Substitute(vStr, "}", "]")

        vStr = .Substitute(vStr, "+", "{+}")
        vStr = .Substitute(vStr, "%", "{%}")
        vStr = .Substitute(vStr, "^", "{^}")
        vStr = .Substitute(vStr, "~", "{~}")
        vStr = .Substitute(vStr, "(", "{(}")
        vStr = .Substitute(vStr, ")", "{)}")
        vStr = .Substitute(vStr, "[", "{[}")
        vStr = .Substitute(vStr, "]", "{]}")
    End With
    PrepToSendKeys = vStr
End Function

Sub VisualizarImp(AppActWb As Workbook)
    Dim PathTemp As String
    If bActWbSaved Then
        PathTemp = AppActWb.FullName
    Else
        PathTemp = fReturnTempDir()
        If Right(PathTemp, 1) = "\" Then PathTemp = Left(PathTemp, Len(PathTemp) - 1)
        PathTemp = PathTemp & "\CpapVTmp.xls" & IIf(Val(Application.Version) >= 12, "x", "")
        On Error Resume Next
        If Dir(PathTemp) <> "" Then Kill PathTemp
        AppActWb.ActiveSheet.Calculate
        If Err.Number = 0 Then AppActWb.SaveCopyAs PathTemp
        '      AppActWb.Close False
        If Err.Number <> 0 Then
            MsgBox Err.Description, , "Falha ao salvar arquivo tempor|fffd|rio"
            Exit Sub
        End If
    End If

    OpenNewExcel PathTemp, 1
End Sub

Function OpenNewExcel(nFile As String, lOper As Long)    'lOper 1-Visualizar Impress; 2-SalvarComo
    On Error GoTo ErrorHandler    'O controle de erro possibilita o uso de um objeto excel j|fffd| criado e ainda aberto.
    If Not ExcelObj Is Nothing Then If ExcelObj.Caption = "Microsoft Excel" Then Set ExcelObj = Nothing    'Estranho, apesar do Excel fechado, o objeto continua existindo. Ent|fffd|o testa sob controle de erro e mata se vazio.
    ExcelObj.Visible = False
    On Error GoTo ErrorHandlerFim
    With ExcelObj
        .Workbooks.Open nFile, , True

        'On Error Resume Next    'N|fffd|o seria necess|fffd|rio, mas deleta para dificultar pirataria
        'MyWait 0.2
        'If Dir(nFile) <> "" Then Kill nFile
        'On Error GoTo 0

        .ActiveSheet.EnableSelection = xlNoSelection
        .WindowState = xlMinimized: .WindowState = xlMaximized    'Necessita no Vista, pois perde o foco
        .Visible = True
        .Caption = "CPAP E-mail"
        .ActiveWindow.Caption = "Visualizando Arquivo de Impress|fffd|o (ESC para Voltar)"
        Application.DisplayAlerts = False    'No 2013, mas era bug antigo onde demorando na visualiza|fffd||fffd|o OLE emitia o alert 'Excel is waiting for another application to complete an OLE action.' Isso |fffd| similar OleServerBusyTimeout=100000000 no VB6. kb2663513
        If lOper = 1 Then
            .ActiveSheet.PrintPreview
        ElseIf lOper = 2 Then
            On Error Resume Next
            .Dialogs(xlDialogSaveAs).Show "CPAP_Relatorio"    'O arg sugere nome do arquivo, "" para vazio, mas resolvi sugerir, al|fffd|m de facilitar para o usu|fffd|rio, pode levar nome do CPAP al|fffd|m.
            If Err.Number = 0 Then nFile = .ActiveWorkbook.FullName
        End If
        .Quit: Set ExcelObj = Nothing    'N|fffd|o seria necess|fffd|rio, mas mata para dificultar pirataria
        Application.DisplayAlerts = True
        If Err.Number <> 0 Then MsgBox Err.Number & ":" & Err.Description    'Aqui para ganhar o foco
    End With
    '    MyWait 5    'Para a janela do CPAP n|fffd|o ser ativada por cima
    '    MsgBox "Acione OK para continuar.", vbOKOnly + vbInformation, "CPAP - Esperando Envio Webmail"
    Exit Function
ErrorHandler:
    Dim bFail As Boolean
    Set ExcelObj = Nothing
    Set ExcelObj = CreateObject("Excel.Application")
    bFail = ExcelObj Is Nothing
    If Not bFail Then
        If ExcelObj.Version = Application.Version Then
            If ExcelObj.Workbooks.Count > 0 Then Set ExcelObj = Nothing: bFail = True    'Se de mesma vers|fffd|o, mas n|fffd|o vazia pode ser uma rodando ou esta pr|fffd|pria, ent|fffd|o mata objeto sem quit e flag falha.
        Else
            bFail = True: If ExcelObj.Workbooks.Count = 0 Then ExcelObj.Quit: Set ExcelObj = Nothing        'Vers|fffd|o diferente, flag falha. Se vazia mata objeto e quit vazia
        End If
    End If
    If bFail Then    'Em dvr.mac criei para todo CPAP a possibilidade de sempre criar objeto de mesma vers|fffd|o usando o mesmo c|fffd|digo do XLtoEXE para criar padr|fffd|o ou especial.
        Application.ExecuteExcel4Macro ("cpap_pri.mac!AbrirDVR()")
        Set ExcelObj = Application.Run("CPAP_DVR.MAC!CreateNewExcelObj", True)
        Application.Workbooks("CPAP_DVR.MAC").Close False
    End If
    Resume Next
ErrorHandlerFim:
    ExcelObj.Visible = True
End Function

Attribute VB_Name = "Mod2aOutros"
'Ok from watermark.xla
Option Explicit
Public Const LOCALE_USER_DEFAULT& = &H400
Public Const LOCALE_SENGLANGUAGE = &H1001   'English name of language
Public Const LOCALE_SLANGUAGE = &H2   'localized name of language
Private Declare Function apiGetLocaleInfo Lib "kernel32" _
        Alias "GetLocaleInfoA" (ByVal Locale As Long, _
        ByVal LCType As Long, ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

Public Declare Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal vKey As Integer) As Integer

Private Declare Function GetTempPath Lib "kernel32" Alias _
        "GetTempPathA" (ByVal nBufferLength As Long, _
        ByVal lpBuffer As String) As Long

Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare Function GetForegroundWindow Lib "user32" () As Long
Public Declare Function SetForegroundWindow Lib "user32" (ByVal hWnd As Long) As Long

Public IsPortg As Boolean
Public MsgXpos As Long
Public MsgYpos As Long

Function gLocInfo(vType As Long) As String
    Dim vLoc As Long
    Dim vStr As String, vLng As Long
    Dim Ret As Long
    vStr = String$(255, 0)
    vLng = 255 - 1
    Ret = apiGetLocaleInfo(LOCALE_USER_DEFAULT, vType, vStr, vLng)
    If Ret <> 0 Then
        gLocInfo = Left$(vStr, Ret - 1)
    End If
End Function

Sub MyWait(PauseSeg As Double)
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        DoEvents
    Loop
End Sub


Function TempFolder() As String
'Get Temp Folder
    Dim fctRet As Long
    TempFolder = String$(255, 0)
    fctRet = GetTempPath(255, TempFolder)
    If fctRet <> 0 Then
        TempFolder = Left(TempFolder, fctRet)
        If Right(TempFolder, 1) = "\" Then TempFolder = Left(TempFolder, Len(TempFolder) - 1)
    Else
        TempFolder = ""
    End If
End Function

Sub SetForegroundWindowEsp(lhWnd As Long, PauseSeg As Double) 'Esta fun|fffd||fffd|o veio do PageSetpMgr tal como est|fffd|.
'No Vista e Win7, se vier de um runas com pedido de eleva|fffd||fffd|o de direitos, h|fffd| perda do foco que fica
'travado por outro processo que n|fffd|o permite apiSetForegroundWindow. Ent|fffd|o |fffd| usar o Alt+Tab para
'simular a|fffd||fffd|o do usu|fffd|rio indo para outro processo.
    Dim i As Long
    Do
        If i > 0 Then SendKeys "%{TAB}": MyWait 0.1
        SetForegroundWindow lhWnd                          ' Como tenho o handle melhor que AppActivate.
        i = i + 1
    Loop While GetForegroundWindow() <> lhWnd And i < 40
    
    If PauseSeg <> 0 Then MyWait PauseSeg 'Esta espera foi necess|fffd|ria para a Ribbon em PrintPreview n|fffd|o ficar travada. Talvez s|fffd| isto fosse suficiente, mas deixei completo.
End Sub


Attribute VB_Name = "ModAPIDir"
'---Posted by Dev Ashish---
Private Const MAX_PATH As Integer = 255
Private Declare Function apiGetSystemDirectory& Lib "kernel32" _
        Alias "GetSystemDirectoryA" _
        (ByVal lpBuffer As String, ByVal nSize As Long)

Private Declare Function apiGetWindowsDirectory& Lib "kernel32" _
        Alias "GetWindowsDirectoryA" _
        (ByVal lpBuffer As String, ByVal nSize As Long)

Private Declare Function apiGetTempDir Lib "kernel32" _
        Alias "GetTempPathA" (ByVal nBufferLength As Long, _
        ByVal lpBuffer As String) As Long

Function fReturnTempDir()
'Returns Temp Folder Name
    Dim strTempDir As String
    Dim lngx As Long
    strTempDir = String$(MAX_PATH, 0)
    lngx = apiGetTempDir(MAX_PATH, strTempDir)
    If lngx <> 0 Then
        fReturnTempDir = Left$(strTempDir, lngx)
    Else
        fReturnTempDir = ""
    End If
End Function

Function fReturnSysDir()
'Returns System Folder Name (C:\WinNT\System32)
    Dim strSysDirName As String
    Dim lngx As Long
    strSysDirName = String$(MAX_PATH, 0)
    lngx = apiGetSystemDirectory(strSysDirName, MAX_PATH)
    If lngx <> 0 Then
        fReturnSysDir = Left$(strSysDirName, lngx)
    Else
        fReturnSysDir = ""
    End If
End Function

Function fReturnWinDir()
'Returns OS Folder (C:\Win95)
    Dim strWinDirName As String
    Dim lngx As Long
    strWinDirName = String$(MAX_PATH, 0)
    lngx = apiGetWindowsDirectory(strWinDirName, MAX_PATH)
    If lngx <> 0 Then
        fReturnWinDir = Left$(strWinDirName, lngx)
    Else
        fReturnWinDir = ""
    End If
End Function


Attribute VB_Name = "ModMAPIvb32"
'**************************************************************************
'
'
'
' Visual Basic declaration for the MAPI functions.
'
' This file can be loaded into the global module.
'
'
'
'
'**************************************************************************
'

'***************************************************
'   MAPI Message holds information about a message
'***************************************************

Type MAPIMessage
    Reserved As Long
    Subject As String
    NoteText As String
    MessageType As String
    DateReceived As String
    ConversationID As String
    Flags As Long
    RecipCount As Long
    FileCount As Long
End Type


'************************************************
'   MAPIRecip holds information about a message
'   originator or recipient
'************************************************

Type MapiRecip
    Reserved As Long
    RecipClass As Long
    Name As String    'myemail@server.com (Don't forget to set RecipCount=1 in Type MAPIMessage)
    Address As String
    EIDSize As Long
    EntryID As String
End Type


'******************************************************
'   MapiFile holds information about file attachments
'******************************************************

Type MapiFile
    Reserved As Long
    Flags As Long
    Position As Long
    PathName As String    'Fullname (Path and name of a file to attached. Don't forget to set FileCount=1 in Type MAPIMessage)
    FileName As String    'Any name that you want to show on email
    FileType As String
End Type


'***************************
'   FUNCTION Declarations
'***************************

Declare Function MAPILogon Lib "MAPI32.DLL" (ByVal UIParam&, ByVal User$, _
        ByVal Password$, ByVal Flags&, ByVal Reserved&, Session&) As Long
Declare Function MAPILogoff Lib "MAPI32.DLL" (ByVal Session&, ByVal _
        UIParam&, ByVal Flags&, ByVal Reserved&) As Long
Declare Function BMAPIReadMail Lib "MAPI32.DLL" (lMsg&, nRecipients&, _
        nFiles&, ByVal Session&, ByVal UIParam&, MessageID$, ByVal Flag&, ByVal _
        Reserved&) As Long
Declare Function BMAPIGetReadMail Lib "MAPI32.DLL" (ByVal lMsg&, Message As _
        MAPIMessage, Recip() As MapiRecip, File() As MapiFile, Originator As _
        MapiRecip) As Long
Declare Function MAPIFindNext Lib "MAPI32.DLL" Alias "BMAPIFindNext" (ByVal _
        Session&, ByVal UIParam&, MsgType$, SeedMsgID$, ByVal Flag&, ByVal _
        Reserved&, MsgID$) As Long
Declare Function MAPISendDocuments Lib "MAPI32.DLL" (ByVal UIParam&, ByVal _
        DelimStr$, ByVal FilePaths$, ByVal FileNames$, ByVal Reserved&) As Long
Declare Function MAPIDeleteMail Lib "MAPI32.DLL" (ByVal Session&, ByVal _
        UIParam&, ByVal MsgID$, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPISendMail Lib "MAPI32.DLL" Alias "BMAPISendMail" (ByVal _
        Session&, ByVal UIParam&, Message As MAPIMessage, Recipient() As MapiRecip, _
        File() As MapiFile, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPISaveMail Lib "MAPI32.DLL" Alias "BMAPISaveMail" (ByVal _
        Session&, ByVal UIParam&, Message As MAPIMessage, Recipient() As MapiRecip, _
        File() As MapiFile, ByVal Flags&, ByVal Reserved&, MsgID$) As Long
Declare Function BMAPIAddress Lib "MAPI32.DLL" (lInfo&, ByVal Session&, _
        ByVal UIParam&, Caption$, ByVal nEditFields&, Label$, nRecipients&, Recip() _
        As MapiRecip, ByVal Flags&, ByVal Reserved&) As Long
Declare Function BMAPIGetAddress Lib "MAPI32.DLL" (ByVal lInfo&, ByVal _
        nRecipients&, Recipients() As MapiRecip) As Long
Declare Function MAPIDetails Lib "MAPI32.DLL" Alias "BMAPIDetails" (ByVal _
        Session&, ByVal UIParam&, Recipient As MapiRecip, ByVal Flags&, ByVal _
        Reserved&) As Long
Declare Function MAPIResolveName Lib "MAPI32.DLL" Alias "BMAPIResolveName" _
        (ByVal Session&, ByVal UIParam&, ByVal UserName$, ByVal Flags&, ByVal _
        Reserved&, Recipient As MapiRecip) As Long



'**************************
'   CONSTANT Declarations
'**************************
'

Global Const SUCCESS_SUCCESS = 0
Global Const MAPI_USER_ABORT = 1
Global Const MAPI_E_USER_ABORT = MAPI_USER_ABORT
Global Const MAPI_E_FAILURE = 2
Global Const MAPI_E_LOGIN_FAILURE = 3
Global Const MAPI_E_LOGON_FAILURE = MAPI_E_LOGIN_FAILURE
Global Const MAPI_E_DISK_FULL = 4
Global Const MAPI_E_INSUFFICIENT_MEMORY = 5
Global Const MAPI_E_BLK_TOO_SMALL = 6
Global Const MAPI_E_TOO_MANY_SESSIONS = 8
Global Const MAPI_E_TOO_MANY_FILES = 9
Global Const MAPI_E_TOO_MANY_RECIPIENTS = 10
Global Const MAPI_E_ATTACHMENT_NOT_FOUND = 11
Global Const MAPI_E_ATTACHMENT_OPEN_FAILURE = 12
Global Const MAPI_E_ATTACHMENT_WRITE_FAILURE = 13
Global Const MAPI_E_UNKNOWN_RECIPIENT = 14
Global Const MAPI_E_BAD_RECIPTYPE = 15
Global Const MAPI_E_NO_MESSAGES = 16
Global Const MAPI_E_INVALID_MESSAGE = 17
Global Const MAPI_E_TEXT_TOO_LARGE = 18
Global Const MAPI_E_INVALID_SESSION = 19
Global Const MAPI_E_TYPE_NOT_SUPPORTED = 20
Global Const MAPI_E_AMBIGUOUS_RECIPIENT = 21
Global Const MAPI_E_AMBIG_RECIP = MAPI_E_AMBIGUOUS_RECIPIENT
Global Const MAPI_E_MESSAGE_IN_USE = 22
Global Const MAPI_E_NETWORK_FAILURE = 23
Global Const MAPI_E_INVALID_EDITFIELDS = 24
Global Const MAPI_E_INVALID_RECIPS = 25
Global Const MAPI_E_NOT_SUPPORTED = 26

Global Const MAPI_ORIG = 0
Global Const MAPI_TO = 1
Global Const MAPI_CC = 2
Global Const MAPI_BCC = 3


'***********************
'   FLAG Declarations
'***********************

'* MAPILogon() flags *

Global Const MAPI_LOGON_UI = &H1
Global Const MAPI_NEW_SESSION = &H2
Global Const MAPI_FORCE_DOWNLOAD = &H1000

'* MAPILogoff() flags *

Global Const MAPI_LOGOFF_SHARED = &H1
Global Const MAPI_LOGOFF_UI = &H2

'* MAPISendMail() flags *

Global Const MAPI_DIALOG = &H8
Global Const MAPI_NO_DIALOG = &H0

'* MAPIFindNext() flags *

Global Const MAPI_UNREAD_ONLY = &H20
Global Const MAPI_GUARANTEE_FIFO = &H100

'* MAPIReadMail() flags *

Global Const MAPI_ENVELOPE_ONLY = &H40
Global Const MAPI_PEEK = &H80
Global Const MAPI_BODY_AS_FILE = &H200
Global Const MAPI_SUPPRESS_ATTACH = &H800

'* MAPIDetails() flags *

Global Const MAPI_AB_NOMODIFY = &H400

'* Attachment flags *

Global Const MAPI_OLE = &H1
Global Const MAPI_OLE_STATIC = &H2

'* MapiMessage flags *

Global Const MAPI_UNREAD = &H1
Global Const MAPI_RECEIPT_REQUESTED = &H2
Global Const MAPI_SENT = &H4

Function CopyFiles(MfIn As MapiFile, MfOut As MapiFile) As Long

    MfOut.FileName = MfIn.FileName
    MfOut.PathName = MfIn.PathName
    MfOut.Reserved = MfIn.Reserved
    MfOut.Flags = MfIn.Flags
    MfOut.Position = MfIn.Position
    MfOut.FileType = MfIn.FileType
    CopyFiles = 1&

End Function

Function CopyRecipient(MrIn As MapiRecip, MrOut As MapiRecip) As Long

    MrOut.Name = MrIn.Name
    MrOut.Address = MrIn.Address
    MrOut.EIDSize = MrIn.EIDSize
    MrOut.EntryID = MrIn.EntryID
    MrOut.Reserved = MrIn.Reserved
    MrOut.RecipClass = MrIn.RecipClass

    CopyRecipient = 1&

End Function

Function MAPIAddress(Session As Long, UIParam As Long, Caption As String, _
        nEditFields As Long, Label As String, nRecipients As Long, Recips() As _
        MapiRecip, Flags As Long, Reserved As Long) As Long


    Dim Info&
    Dim rc&
    Dim nRecips As Long

    ReDim Rec(0 To nRecipients) As MapiRecip
    ' Use local variable since BMAPIAddress changes the passed value
    nRecips = nRecipients

    '*****************************************************
    ' Copy input recipient structure into local
    ' recipient structure used as input to BMAPIAddress
    '*****************************************************

    For i = 0 To nRecipients - 1
        Ignore& = CopyRecipient(Recips(i), Rec(i))
    Next i

    rc& = BMAPIAddress(Info&, Session&, UIParam&, Caption$, nEditFields&, _
            Label$, nRecips&, Rec(), Flags, 0&)

    If (rc& = SUCCESS_SUCCESS) Then

        '**************************************************
        ' New recipients are now in the memory referenced
        ' by Info (HANDLE). nRecipients is the number of
        ' new recipients.
        '**************************************************
        nRecipients = nRecips     ' Copy back to parameter

        If (nRecipients > 0) Then
            ReDim Rec(0 To nRecipients - 1) As MapiRecip
            rc& = BMAPIGetAddress(Info&, nRecipients&, Rec())

            '*********************************************
            ' Copy local recipient structure to
            ' recipient structure passed as procedure
            ' parameter. This is necessary because
            ' VB doesn't seem to work properly when
            ' the procedure parameter gets passed
            ' directory to the BMAPI.DLL Address routine
            '*********************************************

            ReDim Recips(0 To nRecipients - 1) As MapiRecip

            For i = 0 To nRecipients - 1
                Ignore& = CopyRecipient(Rec(i), Recips(i))
            Next i

        End If

    End If

    MAPIAddress = rc&

End Function

Function MAPIReadMail(Session As Long, UIParam As Long, MessageID As _
        String, Flags As Long, Reserved As Long, Message As MAPIMessage, Orig As _
        MapiRecip, RecipsOut() As MapiRecip, FilesOut() As MapiFile) As Long

    Dim Info&
    Dim nFiles&, nRecips&

    rc& = BMAPIReadMail(Info&, nRecips, nFiles, Session, 0, MessageID, _
            Flags, Reserved)

    If (rc& = SUCCESS_SUCCESS) Then

        'Message is now read into the handles array. We have to redim the
        'arrays and read the information in.

        If (nRecips = 0) Then nRecips = 1
        If (nFiles = 0) Then nFiles = 1

        ReDim Recips(0 To nRecips - 1) As MapiRecip
        ReDim Files(0 To nFiles - 1) As MapiFile

        rc& = BMAPIGetReadMail(Info&, Message, Recips(), Files(), Orig)

        '*******************************************
        ' Copy Recipient and File structures from
        ' Local structures to those passed as
        ' parameters
        '*******************************************

        ReDim FilesOut(0 To nFiles - 1) As MapiFile
        ReDim RecipsOut(0 To nRecips - 1) As MapiRecip

        For i = 0 To nRecips - 1
            Ignore& = CopyRecipient(Recips(i), RecipsOut(i))
        Next i

        For i = 0 To nFiles - 1
            Ignore& = CopyFiles(Files(i), FilesOut(i))
        Next i

    End If

    MAPIReadMail = rc&

End Function


Attribute VB_Name = "ModRegEdit"
'Option Explicit
Public Const MAX_STRING As Long = 128
Public Const REG_SZ As Long = &H1    'String
Public Const REG_EXPAND_SZ = &H2
Public Const REG_BINARY As Long = &H3
Public Const REG_DWORD As Long = &H4

Public Const HKEY_CLASSES_ROOT As Long = &H80000000
Public Const HKEY_CURRENT_USER As Long = &H80000001
Public Const HKEY_LOCAL_MACHINE As Long = &H80000002
Public Const HKEY_USERS As Long = &H80000003
Public Const HKEY_PERFORMANCE_DATA As Long = &H80000004
Public Const HKEY_CURRENT_CONFIG As Long = &H80000005
Public Const HKEY_DYN_DATA As Long = &H80000006

Public Const ERROR_SUCCESS As Long = 0
Public Const ERROR_BADDB As Long = 1009
Public Const ERROR_BADKEY As Long = 1010
Public Const ERROR_CANTOPEN As Long = 1011
Public Const ERROR_CANTREAD As Long = 1012
Public Const ERROR_CANTWRITE As Long = 1013
Public Const ERROR_OUTOFMEMORY As Long = 14
Public Const ERROR_INVALID_PARAMETER As Long = 87
Public Const ERROR_ACCESS_DENIED As Long = 5
Public Const ERROR_MORE_DATA As Long = 234
Public Const ERROR_NO_MORE_ITEMS As Long = 259

Public Const KEY_ALL_ACCESS As Long = &H3F
Public Const REG_OPTION_NON_VOLATILE As Long = 0

Public Declare Function RegQueryValueEx Lib "advapi32.dll" _
        Alias "RegQueryValueExA" _
        (ByVal hKey As Long, _
        ByVal sValueName As String, _
        ByVal dwReserved As Long, _
        ByRef lValueType As Long, _
        ByVal sValue As String, _
        ByRef lResultLen As Long) As Long

Public Declare Function RegCloseKey Lib "advapi32.dll" _
        (ByVal hKey As Long) As Long

Public Declare Function RegCreateKeyEx Lib "advapi32" _
        Alias "RegCreateKeyExA" _
        (ByVal hKey As Long, _
        ByVal lpSubKey As String, _
        ByVal Reserved As Long, _
        ByVal lpClass As String, _
        ByVal dwOptions As Long, _
        ByVal samDesired As Long, _
        ByVal lpSecurityAttributes As Long, _
        phkResult As Long, _
        lpdwDisposition As Long) As Long

Private Declare Function RegDeleteKey Lib "advapi32.dll" _
        Alias "RegDeleteKeyA" _
        (ByVal hKey As Long, _
        ByVal lpSubKey As String) As Long

Public Declare Function RegOpenKeyEx Lib "advapi32" _
        Alias "RegOpenKeyExA" _
        (ByVal hKey As Long, _
        ByVal lpSubKey As String, _
        ByVal ulOptions As Long, _
        ByVal samDesired As Long, _
        phkResult As Long) As Long

Public Declare Function RegSetValueExString Lib "advapi32" _
        Alias "RegSetValueExA" _
        (ByVal hKey As Long, _
        ByVal lpValueName As String, _
        ByVal Reserved As Long, _
        ByVal dwType As Long, _
        ByVal lpValue As String, _
        ByVal cbData As Long) As Long

Public Declare Function RegSetValueExLong Lib "advapi32" _
        Alias "RegSetValueExA" _
        (ByVal hKey As Long, _
        ByVal lpValueName As String, _
        ByVal Reserved As Long, _
        ByVal dwType As Long, _
        lpValue As Long, _
        ByVal cbData As Long) As Long


Public Function SetValueEx(ByVal hKey As Long, _
        sValueName As String, _
        lType As Long, _
        vValue As Variant) As Long

    Dim nValue As Long
    Dim sValue As String

    Select Case lType
    Case REG_SZ
        sValue = vValue & Chr$(0)
        SetValueEx = RegSetValueExString(hKey, _
                sValueName, _
                0&, _
                lType, _
                sValue, _
                Len(sValue))

    Case REG_DWORD
        nValue = vValue
        SetValueEx = RegSetValueExLong(hKey, _
                sValueName, _
                0&, _
                lType, _
                nValue, _
                4)
    End Select
End Function


Public Sub CreateNewKey(sNewKeyName As String, _
        lPredefinedKey As Long)

'handle to the new key
    Dim KeyHdlAddr As Long
    Dim result As Long

    Call RegCreateKeyEx(lPredefinedKey, _
            sNewKeyName, 0&, _
            vbNullString, _
            REG_OPTION_NON_VOLATILE, _
            KEY_ALL_ACCESS, 0&, KeyHdlAddr, result)

    Call RegCloseKey(KeyHdlAddr)

End Sub


Public Sub SetKeyValue(hKey, sKeyName As String, _
        sValueName As String, _
        vValueSetting As Variant, _
        lValueType As Long)

'handle of opened key
    Dim KeyHdlAddr As Long

    'open the specified key
    Call RegOpenKeyEx(hKey, _
            sKeyName, 0, _
            KEY_ALL_ACCESS, KeyHdlAddr)

    Call SetValueEx(KeyHdlAddr, _
            sValueName, _
            lValueType, _
            vValueSetting)

    Call RegCloseKey(KeyHdlAddr)
End Sub

Function GetRegistryValue(KEY As Long, SubKey As String, ValueName As String) As String
'KEY (e.g., HKEY_CLASSES_ROOT),
'SubKey (e.g., "Excel.Sheet.5"),
'ValueName (e.g., "" [for default] or "whatever")
    Dim Buffer As String * MAX_STRING, ReturnCode As Long
    Dim KeyHdlAddr As Long, ValueType As Long, ValueLen As Long
    Dim TempBuffer As String, Counter As Integer
    ValueLen = MAX_STRING
    ReturnCode = RegOpenKeyEx(KEY, SubKey, 0, KEY_ALL_ACCESS, KeyHdlAddr)
    If ReturnCode = 0 Then
        ReturnCode = RegQueryValueEx(KeyHdlAddr, ValueName, _
                0&, ValueType, Buffer, ValueLen)
        RegCloseKey KeyHdlAddr
        'If successful ValueType contains data type
        'of value and ValueLen its length
        If ReturnCode = 0 Then
            Select Case ValueType
            Case REG_BINARY
                For Counter = 1 To ValueLen
                    TempBuffer = TempBuffer & _
                            Stretch(Hex(Asc(Mid(Buffer, Counter, 1)))) & " "
                Next
                GetRegistryValue = TempBuffer
            Case REG_DWORD
                TempBuffer = "0x"
                For Counter = 4 To 1 Step -1
                    TempBuffer = TempBuffer & _
                            Stretch(Hex(Asc(Mid(Buffer, Counter, 1))))
                Next
                GetRegistryValue = TempBuffer
            Case Else
                GetRegistryValue = Buffer
            End Select
            Exit Function
        End If
    End If
    GetRegistryValue = "Error"
End Function
Function Stretch(ByteStr As String) As String
    If Len(ByteStr) = 1 Then ByteStr = "0" & ByteStr
    Stretch = ByteStr
End Function


Sub TestAboveFunctions()
'To test, let's go to create an extension (.aaa)
'and assosiation it to MyNotepad.Document (Copy and
'rename Notepad.exe to c:\)
    FileCopy "c:\windows\notepad.exe", "c:\MyNotepad.exe"
    FileCopy "C:\Windows\LICENSE.TXT", "C:\Windows\desktop\LICENSE.aaa"   'to test with two clicks on desktop

    'File Associations begin with a listing
    'of the default extension under HKEY_CLASSES_ROOT.
    'So the first step is to create that
    'root extension item
    CreateNewKey ".aaa", HKEY_CLASSES_ROOT

    'To the extension just added, add a
    'subitem where the registry will look for
    'commands relating to the .aaa extension
    '("MyNotepad.Document"). Its type is String (REG_SZ)
    SetKeyValue HKEY_CLASSES_ROOT, ".aaa", "", "MyNotepad.Document", REG_SZ

    'Create the 'MyNotepad.Document' item under
    'HKEY_CLASSES_ROOT. This is where you'll put
    'the command line to execute or other shell
    'statements necessary.
    CreateNewKey "MyNotepad.Document\shell\open\command", HKEY_CLASSES_ROOT

    'Set its default item to "MyNotepad Document".
    'This is what is displayed in Explorer against
    'for files with a aaa extension. Its type is
    'String (REG_SZ)
    SetKeyValue HKEY_CLASSES_ROOT, "MyNotepad.Document", "", "MyNotepad Document", REG_SZ

    'Finally, add the path to MyNotepad.exe
    'Remember to add %1 as the final command
    'parameter to assure the app opens the passed
    'command line item.
    '(results in '"c:\MyNotepad.exe %1")
    'Again, its type is string.

    SetKeyValue HKEY_CLASSES_ROOT, "MyNotepad.Document\shell\open\command", "", "c:\MyNotepad.exe %1", REG_SZ
    'All done

    'Now test created above
    MsgBox GetRegistryValue(HKEY_CLASSES_ROOT, "MyNotepad.Document\shell\open\command", "")
End Sub

Sub TestOthersGet()
'Default Mail program
    MsgBox GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail", "")
    'Outlook Journal
    MsgBox GetRegistryValue(HKEY_CURRENT_USER, "Software\Microsoft\Shared Tools\Outlook\Journaling\Microsoft Excel", "Enabled")
    'If MsCall.ocx is installed
    i = GetRegistryValue(HKEY_CLASSES_ROOT, "MSCAL.Calendar", "")
    MsgBox Left(i, 23) = "Controle calend|fffd|rio 8.0" Or Left(i, 20) = "Calendar Control 9.0" Or Left(i, 20) = "Calendar Control 8.0"
    'Display Resolution
    MsgBox Application.WorksheetFunction.Clean(GetRegistryValue(HKEY_LOCAL_MACHINE, "Config\0001\Display\Settings", "Resolution"))
    'Default folders
    MsgBox GetRegistryValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Desktop")
    MsgBox GetRegistryValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Programs")
End Sub

Public Sub DeleteKey(sKeyName As String, _
        lPredefinedKey As Long)

    Call RegDeleteKey(lPredefinedKey, _
            sKeyName)

End Sub

Sub TestDeleteKey()
'Delete Keys and files created on above TestAboveFunctions
    DeleteKey ".aaa", HKEY_CLASSES_ROOT
    DeleteKey "MyNotepad.Document\shell\open\command", HKEY_CLASSES_ROOT
    Kill "c:\MyNotepad.exe"
    Kill "C:\Windows\desktop\LICENSE.aaa"
End Sub


'This code was adapted from an existing code.
'Thanks to an newsgroup example provided by Paul Clement
'get from Randy Birch's VBnet code examples at http://www.mvps.org/vbnet



Attribute VB_Name = "M|fffd|d2Comum"
Public Const MarcHist = "|fffd|Hist|fffd|rico|fffd|"
Public NomeArqHist As String
Public vEnableEvents As Boolean
Public BotAcionado As Variant
Public SalvarHist As Boolean
Public FormatoHist As String
Public HistEditCampo As String
Public vCloseMode As Integer
Public FecharArq As Boolean
Public NmesIndMax As Long: Public bHtmlHelp As Boolean

Sub AtuHist(vCampo As String, ValorCb As String, ValorOrig As String)
    If ValorCb = "" Or ValorCb = ValorOrig Then Exit Sub
    'Verificando exist|fffd|ncia - Sug. Fixas
    Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(vCampo)
    j = 0
    For Each c In campo
        j = j + 1
        If j > 1 And IIf(IsError(c.Value), "", c.Value) = ValorCb Then Exit Sub
    Next

    'Verificando exist|fffd|ncia - Sug. Hist|fffd|ricas
    Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(vCampo & "Hist", ThisWorkbook.Sheets(NomeArqHist).Range(vCampo & "Hist").End(xlDown))
    If campo.Rows.Count > 10000 Then Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(vCampo & "Hist")
    j = 0
    For Each c In campo
        j = j + 1
        If j > 1 And IIf(IsError(c.Value), "", c.Value) = ValorCb Then Exit Sub
    Next
    'Adicionando |fffd| lista de hist|fffd|rico
    campo.Rows(2).Insert Shift:=xlDown
    campo.Rows(2).Value = "'" & ValorCb   'O ap|fffd|strofo arquivo tudo como texto, previnindo erro em caso de f|fffd|rmula e altera no formato de n|fffd|meros pela planilha
    NumM|fffd|x = ThisWorkbook.Sheets(NomeArqHist).Range(vCampo & "Hist").Offset(-1, 0).Value
    If campo.Rows.Count > NumM|fffd|x Then campo(NumM|fffd|x + 2).ClearContents
    SalvarHist = True
End Sub

Function MyOpenFile(vFileName As String, vReadOnly As Boolean)
    On Error Resume Next
Retry:
    Application.DisplayAlerts = False
    '                                                         bEnableEvents = Application.EnableEvents
    Application.Run "cpap_ex8.mac!EnableEventsVBA", False    'Application.EnableEvents = False
    Set i = Workbooks.Open(FileName:=vFileName, ReadOnly:=vReadOnly, Notify:=False)
    Application.Run "cpap_ex8.mac!EnableEventsVBA", True    'Application.EnableEvents = bEnableEvents

    'Testar integridade. Ver se abre como texto, se n|fffd|o existe o nome DadosHist, se A1&His<>Ahist
    t1 = i.FileFormat = xlCurrentPlatformText
    t2 = i.Sheets(1).Range("DadosHist").Value
    t2 = t2 = Empty
    If t2 = False Then t3 = i.Sheets(1).Range("DadosHist").Offset(1).Value <> i.Sheets(1).Range("A1").Value & "Hist" Else t3 = False
    If t1 Or t2 Or t3 Then i.Close False

    Application.DisplayAlerts = True
    If i.Name = "" Then
        Select Case MsgBox("O arquivo " & vFileName & " contendo o hist|fffd|rico das caixas de inclus|fffd|o n|fffd|o foi encontrado ou est|fffd| corrompido." & Chr(10) & Chr(10) & "Se acionar Ignorar, o arquivo ser|fffd| ignorado e um novo ser|fffd| gerado para iniciar outro hist|fffd|rico.", vbQuestion + vbAbortRetryIgnore + vbDefaultButton2, "CPAP|fffd| - Tentando Abrir Arquivo de Hist|fffd|rico")
        Case Is = vbRetry
            GoTo Retry
        Case Is = vbAbort
            MyOpenFile = False
            Exit Function
        Case Is = vbIgnore
            Application.Workbooks.Add xlWBATWorksheet
            ActiveWorkbook.Names.Add Name:="DadosHist", RefersToR1C1:=Cells(100, 1)
            If Dir(vFileName) <> "" Then Kill vFileName
            ActiveWorkbook.SaveAs vFileName, IIf(Val(Application.Version) >= 12, 56, xlWorkbookNormal)    'xlExcel8 56
            SalvandoHist
            GoTo Retry
        End Select
    End If
    On Error GoTo 0
    If vReadOnly = False And i.ReadOnly Then
        i.Close False
        j = j + 1
        If j < 4 Then
            Application.Wait Now + TimeValue("00:00:01")
            GoTo Retry
        Else
            If MsgBox("O arquivo " & vFileName & " contendo o hist|fffd|rico das caixas de inclus|fffd|o pode estar em uso por outra esta|fffd||fffd|o. Acione OK para continuar tentando ou Cancelar para desistir?", vbQuestion + vbOKCancel, "CPAP|fffd|") = vbOK Then
                GoTo Retry
            Else
                MyOpenFile = False
                Exit Function
            End If
        End If
    End If
    ActiveWorkbook.ActiveSheet.Unprotect "MP542"
    ThisWorkbook.Sheets(NomeArqHist).Range("DadosFixos").CurrentRegion.ClearContents
    Set CopyRng = Range("A1").CurrentRegion
    Set PasteRng = ThisWorkbook.Sheets(NomeArqHist).Range("DadosFixos")
    PasteRng.Resize(CopyRng.Rows.Count, CopyRng.Columns.Count).Value2 = CopyRng.Value2

    ThisWorkbook.Sheets(NomeArqHist).Range("DadosHist").CurrentRegion.ClearContents
    Set CopyRng = Range("DadosHist").CurrentRegion
    Set PasteRng = ThisWorkbook.Sheets(NomeArqHist).Range("DadosHist")
    PasteRng.Resize(CopyRng.Rows.Count, CopyRng.Columns.Count).Value2 = CopyRng.Value2
    MyOpenFile = True
End Function

Sub SalvandoHist()
    Workbooks(NomeArqHist).Sheets(1).Range("A1").CurrentRegion.ClearContents
    Set CopyRng = ThisWorkbook.Sheets(NomeArqHist).Range("DadosFixos").CurrentRegion
    Set PasteRng = Workbooks(NomeArqHist).Sheets(1).Range("A1")
    PasteRng.Resize(CopyRng.Rows.Count, CopyRng.Columns.Count).Value2 = CopyRng.Value2

    Workbooks(NomeArqHist).Sheets(1).Range("DadosHist").CurrentRegion.ClearContents
    i = ThisWorkbook.Sheets(NomeArqHist).Range("DadosHist").Row
    Workbooks(NomeArqHist).Names.Add Name:="DadosHist", RefersToR1C1:=Workbooks(NomeArqHist).Sheets(1).Cells(i, 1)
    Set CopyRng = ThisWorkbook.Sheets(NomeArqHist).Range("DadosHist").CurrentRegion
    Set PasteRng = Workbooks(NomeArqHist).Sheets(1).Range("DadosHist")
    PasteRng.Resize(CopyRng.Rows.Count, CopyRng.Columns.Count).Value2 = CopyRng.Value2

    Workbooks(NomeArqHist).Activate
    ActiveWorkbook.ActiveSheet.Protect "MP542"
    If Run("cpap_ex8.mac!SaveVBA") Then ActiveWorkbook.Close False
End Sub

Sub ConfHist(vComboBox As Object, vOriginal As String, Optional SemEditSring As Boolean = False, Optional Formato As String)
    i = InStr(1, vComboBox.Name, "_")
    HistEditCampo = Left(vComboBox.Name, i - 1)
    i = MsgBox("OK  -  Configurar sugest|fffd|es fixas e hist|fffd|ricas;" & Chr(10) & Chr(10) & "Cancelar - Restaurar inicial.", vbQuestion + vbOKCancel, "Hist|fffd|rico de Inclus|fffd|es no Campo " & HistEditCampo) = vbOK
    If i Then
        FormatoHist = Formato
        UserFormEditHist.Nova_Bt.Enabled = Not SemEditSring
        UserFormEditHist.SugFixas_Ct.Enabled = Not SemEditSring
        UserFormEditHist.SugHist_Ct.Enabled = Not SemEditSring
        UserFormEditHist.Show
        Unload UserFormEditHist
    End If
    vComboBox.Value = vOriginal
    If i Then ListandoComboBox vComboBox, Formato
    SendKeys "{RIGHT}"
End Sub

Sub ListandoComboBox(vComboBox As Object, Optional Formato As String)
    i = InStr(1, vComboBox.Name, "_")
    vCampo = Left(vComboBox.Name, i - 1)
    'Limpando comboboxes
    While vComboBox.ListCount >= 1
        vComboBox.RemoveItem (0)
    Wend
    'Listando comboboxes - Lista de sug. fixas
    Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(vCampo, ThisWorkbook.Sheets(NomeArqHist).Range(vCampo).End(xlDown))
    If campo.Rows.Count < 100 Then
        j = 0
        For Each c In campo
            cf = Format(IIf(IsError(c.Value), "", c.Value), Formato)
            j = j + 1
            If j > 1 Then
                vRep = False
                For i = 1 To vComboBox.ListCount
                    If vComboBox.List(i - 1) = cf Then vRep = True
                Next
                If vRep = False And cf <> "" Then vComboBox.AddItem (cf)
            End If
        Next
    End If
    'Listando comboboxes - Lista de sug. hist|fffd|ricas
    vComboBox.AddItem (MarcHist)
    Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(vCampo & "Hist", ThisWorkbook.Sheets(NomeArqHist).Range(vCampo & "Hist").End(xlDown))
    If campo.Rows.Count > 10000 Then Exit Sub
    j = 0
    For Each c In campo
        cf = Format(IIf(IsError(c.Value), "", c.Value), Formato)
        j = j + 1
        If j > 1 Then
            vRep = False
            For i = 1 To vComboBox.ListCount
                If vComboBox.List(i - 1) = cf Then vRep = True
            Next
            If vRep = False And cf <> "" Then vComboBox.AddItem (cf)
        End If
        Application.StatusBar = "Sugest|fffd|es Hist|fffd|ricas em " & vCampo & " " & j & "/" & campo.Rows.Count
    Next
    Application.StatusBar = False
End Sub


'EVENTOS DE CAIXA DE TEXTO PARA VALOR FINANCEIRO

Sub EvValor_Cb_MouseMove(Valor_Cb As Control, ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    Valor_Cb.Locked = False
    sd = Application.International(xlDecimalSeparator)
    If Valor_Cb.Text = "0" Or Valor_Cb.Text = "0" & sd & "00" Then
        Valor_Cb.SelStart = 0
        Valor_Cb.SelLength = Len(Valor_Cb.Text)
    End If
End Sub

Sub EvValor_Cb_KeyDown(Valor_Cb As Control, ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    sd = Application.International(xlDecimalSeparator)
    vKeyCode = IIf(sd = ",", 188, 190)
    Valor_Cb.Locked = False
    If KeyCode = 37 Or (Shift = 2 And KeyCode = 86) Or (Shift = 1 And KeyCode = 45) Or (Shift = 2 And KeyCode = 88) Then Exit Sub   'Seta Esquerda e teclas do clipboard
    If KeyCode = 110 Or KeyCode = 190 Then KeyCode = vKeyCode
    If KeyCode = 188 Then If InStr(1, Valor_Cb.Value, sd) > 0 Then Valor_Cb.Locked = True
    If (KeyCode >= 96 And KeyCode <= 105) _
            Or (KeyCode >= 48 And KeyCode <= 57 And Shift = 0) _
            Or KeyCode = 188 Or KeyCode = 8 Or KeyCode = 46 _
            Or KeyCode = 107 Or (KeyCode = 187 And Shift = 1) _
            Or KeyCode = 109 Or (KeyCode = 189 And Shift = 0) Then Else Valor_Cb.Locked = True
End Sub

Sub EvValor_Cb_Change(Valor_Cb As Control, Optional vAbs As Boolean = False)
    i = Valor_Cb.Value
    j = Valor_Cb.SelStart
    SinNeg = vAbs = False And InStr(1, i, "-") > 0 And InStr(1, i, "+") = 0
    i = Application.WorksheetFunction.Substitute(i, "-", "")
    i = Application.WorksheetFunction.Substitute(i, "+", "")
    PartInt = i
    sd = Application.International(xlDecimalSeparator)
    sm = Application.International(xlThousandsSeparator)
    k = InStr(1, i, sd)
    If k > 0 Then
        PartFrac = Mid(i, k + 1, 100)
        PartFrac = Application.WorksheetFunction.Substitute(PartFrac, sm, "")
        PartInt = Mid(i, 1, k - 1)
        If PartInt = "" Then PartInt = "0"
    End If
    TamPartInt = Len(PartInt)
    PartInt = Application.WorksheetFunction.Substitute(PartInt, sm, "")
    PartInt = Format(PartInt, "#,##0")
    RepCurs = Len(PartInt) - TamPartInt
    vEnableEvents = False
    Valor_Cb.Value = IIf(SinNeg, "-", "") & PartInt & IIf(PartInt = "" Or k = 0, "", sd) & PartFrac
    vEnableEvents = True
    j = -(j + RepCurs) * (j + RepCurs >= 0)
    If Left(Valor_Cb.Value, 2) = "0" & sd And j < 3 Then j = 2
    Valor_Cb.SelStart = j

    'Evita colar texto
    Static ValorOld
    If Valor_Cb.Value <> "" And Valor_Cb.Value <> "-" And Not (IsNumeric(Valor_Cb.Value)) Then
        MsgBox Valor_Cb.Value, vbCritical, "Valor Inv|fffd|lido!"
        Valor_Cb.Value = ValorOld
    Else
        ValorOld = Valor_Cb.Value
    End If
End Sub

Sub EvValor_Cb_Exit(Valor_Cb As Control, Cancel As MSForms.ReturnBoolean, Formato As String)
    If Valor_Cb.Value = "" Then Valor_Cb.Value = 0
    If IsNumeric(Valor_Cb.Value) Then
        If Valor_Cb.Value <> Format(Valor_Cb.Value, Formato) Then Valor_Cb.Value = Format(Valor_Cb.Value, Formato)
    Else
        MsgBox "Data inv|fffd|lida!", vbCritical, "CPAP|fffd|"
        Cancel = True
    End If
End Sub


Sub CalculadoraBtClick(vForm As Object, Valor_Cb As Control, Calculadora_Bt As Control, NumDecim As Integer)
    Calculadora_Bt.SpecialEffect = fmSpecialEffectSunken
    If IsNumeric(Valor_Cb.Value) Then CalculadoraValorIni = IIf(Valor_Cb.Value * 1 = 0, 0, Valor_Cb.Value) Else CalculadoraValorIni = 0
    Workbooks("cpap_pri.mac").Sheets(1).Range("CalcVal").Value = CalculadoraValorIni
    Workbooks("cpap_pri.mac").Sheets(1).Range("CalcDec").Value = NumDecim

    Application.ExecuteExcel4Macro ("cpap_pri.mac!CalcVBA()")

    Valor_Cb.Value = Workbooks("cpap_pri.mac").Sheets(1).Range("CalcVal").Value
    Valor_Cb.SetFocus
    Calculadora_Bt.SpecialEffect = fmSpecialEffectEtched
End Sub



'EVENTOS DE CAIXA DE TEXTO DO CALEND|fffd|RIO

Sub EvCalend_Cb_MouseMove(Data_Cb As Control, ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    Data_Cb.Locked = False
End Sub

Sub EvCalend_Cb_KeyDown(Data_Cb As Control, ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    j = Data_Cb.SelStart
    If KeyCode = 220 Or KeyCode = 191 Then KeyCode = 111   'Trocando \ por /
    If KeyCode = 8 Then KeyCode = 37    'Trocando Backspace por ser a esquerda

    'Setas, teclas do clipboard e /
    If KeyCode = 16 Or KeyCode = 17 _
            Or KeyCode = 37 Or KeyCode = 39 _
            Or (Shift = 2 And KeyCode = 67) _
            Or (Shift = 2 And KeyCode = 86) _
            Or (Shift = 1 And KeyCode = 45) _
            Or (Shift = 2 And KeyCode = 88) _
            Or (KeyCode = 111 And j > 0 And j < 8) Then
        Data_Cb.Locked = False
        Exit Sub
    End If
    If Data_Cb.SelLength > 1 Then Data_Cb.SelStart = j
    If j = 2 Or j = 5 Then Data_Cb.SelStart = j + 1
    Data_Cb.Locked = False
    If (KeyCode >= 96 And KeyCode <= 105) Or (KeyCode >= 48 And KeyCode <= 57 And Shift = 0) Then Else Data_Cb.Locked = True
    If j >= 8 Then Data_Cb.Locked = True
End Sub

Sub EvCalend_Cb_Change(Data_Cb As Control)
    If vEnableEvents = False Then Exit Sub
    i = Data_Cb.Value
    j = Data_Cb.SelStart
    'Eliminando barra dupla
    iSbd = Application.WorksheetFunction.Substitute(i, "//", "/")
    If i <> iSbd Then
        vEnableEvents = False
        Data_Cb.Value = iSbd
        vEnableEvents = True
        j = InStr(1, i, "//")
        Data_Cb.SelStart = j
        Exit Sub
    End If
    'Prevendo e para manter o formato dd/mm/yy, substituir
    If Len(i) > 8 And j > 0 Then
        vEnableEvents = False
        Data_Cb.Value = Left(i, j) & Mid(i, j + 2, 200)
        vEnableEvents = True
        If j = 2 Or j = 5 Then
            Data_Cb.SelStart = j + 1
        Else
            Data_Cb.SelStart = j
        End If
    End If
    'Tentando limitar a parte do dia
    i = Data_Cb.Value
    If Mid(i, 3, 1) = "/" And IsNumeric(Left(i, 2)) Then
        If Left(i, 2) > 31 And Left(i, 2) < 40 Then
            vEnableEvents = False
            Data_Cb.Value = "30" & Mid(i, 3, 200)
            vEnableEvents = True
            Data_Cb.SelStart = 1
        End If
        If Left(i, 2) > 39 Then
            vEnableEvents = False
            Data_Cb.Value = "0" & Left(i, 1) & Mid(i, 3, 200)
            vEnableEvents = True
            Data_Cb.SelStart = 3
        End If
    End If
    'Tentando limitar a parte do m|fffd|s
    If Mid(i, 3, 1) = "/" And Mid(i, 6, 1) = "/" And IsNumeric(Mid(i, 4, 2)) Then
        If Mid(i, 4, 2) > 12 And Mid(i, 4, 2) < 20 Then
            vEnableEvents = False
            Data_Cb.Value = Left(i, 3) & "12" & Mid(i, 6, 200)
            vEnableEvents = True
            Data_Cb.SelStart = 4
        End If
        If Mid(i, 4, 2) > 19 Then
            vEnableEvents = False
            Data_Cb.Value = Left(i, 3) & "0" & Mid(i, 4, 1) & Mid(i, 6, 200)
            vEnableEvents = True
            Data_Cb.SelStart = 6
        End If
    End If
End Sub

Sub EvCalend_Cb_Exit(Data_Cb As Control, ByVal Cancel As MSForms.ReturnBoolean, Optional DataIni As Date)
    If DataIni = 0 Then DataIni = Now
    i = Data_Cb.Value
    If IsDate(i) Then
        If NmesIndMax = 0 Then NmesIndMax = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("NmesIndMax").Value
        If DateValue(i) < DateSerial(1970, 5, 15) Or DateValue(Data_Cb.Value) > DateSerial(1970, 5 + NmesIndMax, 1) Then
            MsgBox "Data inv|fffd|lida. Digite uma data entre " & Format(DateSerial(1970, 5, 15), "dd/mm/yyyy") & " e " & Format(DateSerial(1970, 5 + NmesIndMax, 1), "dd/mm/yyyy") & ".", vbCritical, "CPAP|fffd|"
            Cancel = True
        End If
        If i <> Format(DateValue(i), "dd/mm/yy") Then Data_Cb.Value = Format(DateValue(i), "dd/mm/yy")
    Else
        'Tentando resolver final de m|fffd|s
        z = InStr(1, i, "/")
        If z > 1 Then
            i1 = Left(i, z - 1)
            i2 = Mid(i, z, 250)
            If IsNumeric(i1) Then
                If IsDate(i1 - 1 & i2) Then
                    Data_Cb.Value = Format(DateValue(i1 - 1 & i2), "dd/mm/yy")
                    Exit Sub
                End If
                If IsDate(i1 - 2 & i2) Then
                    Data_Cb.Value = Format(DateValue(i1 - 2 & i2), "dd/mm/yy")
                    Exit Sub
                End If
                If IsDate(i1 - 3 & i2) Then
                    Data_Cb.Value = Format(DateValue(i1 - 3 & i2), "dd/mm/yy")
                    Exit Sub
                End If
            End If
        End If
        If MsgBox("OK  -  Restaurar inicial, " & Format(DataIni, "dd/mm/yy") & ";" & Chr(10) & Chr(10) & "Cancelar - Voltar para alterar.", vbQuestion + vbOKCancel, "Data Inv|fffd|lida!  Campo: " & Left(Data_Cb.Name, InStr(1, Data_Cb.Name, "_") - 1)) = vbOK Then
            Data_Cb.Value = Format(DataIni, "dd/mm/yy")
        Else
            Cancel = True
        End If
    End If
End Sub


Sub CalendBtClick(vForm As Object, Data_Cb As Control, Calend_Bt As Control)
    Calend_Bt.SpecialEffect = fmSpecialEffectSunken
    CalendDataIni = IIf(IsDate(Data_Cb.Value), Data_Cb.Value, Date)
    Workbooks("cpap_pri.mac").Sheets(1).Range("CalendVal").Value = CalendDataIni

    Application.ExecuteExcel4Macro ("cpap_pri.mac!CalendVBA()")

    Data_Cb.Value = Format(Workbooks("cpap_pri.mac").Sheets(1).Range("CalendVal").Value, "dd/mm/yy")
    Data_Cb.SetFocus
    Calend_Bt.SpecialEffect = fmSpecialEffectEtched
End Sub



'EVENTOS DE CAIXA DE TEXTO PARA N|fffd|MERO DE TELEFONE

Sub EvFone_Cb_Change(Fone_Cb As Control)
    i = Fone_Cb.Value
    j = Fone_Cb.SelStart
    k = Len(i)
    i = Application.WorksheetFunction.Substitute(i, ".", "")
    i = Application.WorksheetFunction.Substitute(i, "-", "")
    vEnableEvents = False
    Fone_Cb.Value = IIf(Len(i) > 3, Left(i, 3) & "-" & Mid(i, 4, 20), i)
    If Len(i) > 7 Then Fone_Cb.Value = Left(i, Len(i) + 4 * (Len(i) > 4)) & "-" & Right(i, 4)
    vEnableEvents = True
    If j < k Then Fone_Cb.SelStart = j
End Sub

Sub EvFone_Cb_KeyDown(Fone_Cb As Control, ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Fone_Cb.Locked = False
    If KeyCode = 37 Or (Shift = 2 And KeyCode = 86) Or (Shift = 1 And KeyCode = 45) Or (Shift = 2 And KeyCode = 88) Then Exit Sub   'Seta Esquerda e teclas do clipboard
    If KeyCode = 188 Then If InStr(1, Fone_Cb.Value, sd) > 0 Then Fone_Cb.Locked = True
    If (KeyCode >= 96 And KeyCode <= 105) Or (KeyCode >= 48 And KeyCode <= 57 And Shift = 0) Or KeyCode = 188 Or KeyCode = 8 Or KeyCode = 46 Then Else Fone_Cb.Locked = True
End Sub

Sub DesvanecerMesmoPa|fffd|s(Fone_Cb As Control)
    Pa|fffd|sEmpr = Workbooks("Cpap_pri.mac").Excel4MacroSheets(1).Range("Pa|fffd|sEmpr").Value & ""
    Fone_Cb.BackColor = IIf(Fone_Cb.Value = Pa|fffd|sEmpr, &H8000000F, &H80000005)
    Fone_Cb.ForeColor = IIf(Fone_Cb.Value = Pa|fffd|sEmpr, &H80000016, &H80000008)
End Sub

Sub DesvanecerMesmaCid(Fone_Cb As Control)
    CidEmpr = Workbooks("Cpap_pri.mac").Excel4MacroSheets(1).Range("CidEmpr").Value & ""
    Fone_Cb.BackColor = IIf(Fone_Cb.Value = CidEmpr, &H8000000F, &H80000005)
    Fone_Cb.ForeColor = IIf(Fone_Cb.Value = CidEmpr, &H80000016, &H80000008)
End Sub


Attribute VB_Name = "M|fffd|d4Editada"
Sub Editada()
    Dim WbEditada As Workbook
    Set WbEditada = ThisWorkbook
    Windows(WbEditada.Windows(1).Caption).Visible = True
    WbEditada.Activate

    For Each Sh In WbEditada.Sheets
        'Este loop |fffd| usado s|fffd| onde houver planilha de hist|fffd|rico
        If Right(Sh.Name, 4) = ".hst" Then
            Sh.Activate
            NumCampos = Range("A1").CurrentRegion.Columns.Count
            NumSugPadr = Range("A1").CurrentRegion.Rows.Count
            Set Campos = Range(Cells(1, 1), Cells(1, NumCampos))

            'Limpando
            Range("DadosFixos").CurrentRegion.Clear
            Range("DadosHist").CurrentRegion.Clear
            For Each Nome In ActiveWorkbook.ActiveSheet.Names
                Nome.Delete
            Next
            With ActiveWindow
                .SplitColumn = 0
                .SplitRow = 12
            End With

            'Redefinindo
            LFix = 4 + 100   'N|fffd|m de linhas reservadas para sug. fixas. Pode ser alterado o c|fffd|digo |fffd| flex|fffd|vel
            With ActiveWorkbook.ActiveSheet.Names
                Ref = "=" & ActiveWorkbook.ActiveSheet.Name & "!" & Cells(NumSugPadr + 4, 1).Address(ReferenceStyle:=xlR1C1)
                .Add Name:="DadosFixos", RefersToR1C1:=Ref
                Ref = "=" & ActiveWorkbook.ActiveSheet.Name & "!" & Cells(NumSugPadr + 4 + LFix + 1, 1).Address(ReferenceStyle:=xlR1C1)
                .Add Name:="DadosHist", RefersToR1C1:=Ref


                For Each c In Campos
                    .Add Name:=c.Value, RefersToR1C1:=Cells(NumSugPadr + 4, c.Column)
                    .Add Name:=c.Value & "Hist", RefersToR1C1:=Cells(NumSugPadr + 4 + LFix + 2, c.Column)
                    c.Offset(NumSugPadr + 4 + LFix, 0).Value = 15
                    c.Offset(NumSugPadr + 4 + LFix + 1, 0).Value = c.Value & "Hist"
                Next
            End With
            Range("A1").CurrentRegion.Copy
            Range("DadosFixos").PasteSpecial xlPasteValues
            Application.CutCopyMode = False

            ActiveWindow.Panes(1).Activate
            Application.GoTo Reference:="DadosFixos", Scroll:=True
            ActiveWindow.Panes(3).Activate
            Application.GoTo Reference:="DadosHist", Scroll:=True
        End If
    Next

    If WbEditada.ReadOnly Then WbEditada.ChangeFileAccess xlReadWrite
    If Val(Application.Version) < 9 Then If MsgBox(WbEditada.Name & ".  Indenter? (Distanciar margens)", vbOKCancel) = vbOK Then Run "Indenter97.xla!IndentProject"
    WbEditada.Sheets(1).Select
    If MsgBox(WbEditada.Name & ".  Limpar C|fffd|digo?", vbOKCancel) = vbOK Then
        Application.OnTime Now, "VBACodeCleaner.xla!CodeCleanerMain"
    Else
        WbEditada.Save
    End If
End Sub
Attribute VB_Name = "Plan2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


































Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True







Attribute VB_Name = "UserForm1Email"
Attribute VB_Base = "0{C0DEC398-A521-41E5-B5E7-DB2F2E576B3E}{75AFCF67-2BAB-44A1-9F62-B27B79BE7EE6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Necess|fffd|rio, devido bug Setfocus em textbox do Excel2k. Isto foi resolvido com SendKeys tamb|fffd|m
Public ControleAtivo As Control

Private Sub UserForm_Activate()
    SendDirSMTP_Bt.SetFocus
    ControleAtivo.SetFocus
End Sub
Private Sub UserForm_Deactivate()
    Set ControleAtivo = ActiveControl
End Sub

Private Sub UserForm_Initialize()
    ListandoComboBox Internet_Cb
    bSendByWebmail = False
    bSendBySMTP = False
    If Not Application.Run("cpap_ex8.mac!CtrlDown") Then
        Protect_Chb.Visible = False    'Agora com a possibilidade de salvar relat|fffd|rio como |fffd| melhor sempre proteger. Com Ctrl habilita
        OutlookExpress_Lb.Visible = False    'Outlook s|fffd| existe no WinXP, poucos usam, se usar |fffd| prov|fffd|vel que esteja ok e op|fffd||fffd|o de smtp |fffd| melhor ocultar. Com Ctrl habilita
    End If
    Set ControleAtivo = Internet_Cb
End Sub

Private Sub Internet_Cb_Change()
    If vEnableEvents = False Then Exit Sub
    If Internet_Cb.Value = MarcHist Then ConfHist Internet_Cb, EmlEmail
End Sub

Private Sub Visualizar_Bt_Click()
'Objetivo principal deste comando |fffd| possibilitar imprimir em outra execu|fffd||fffd|o do Excel. Isso porque
'no Vinicius a impress|fffd|o falhava apenas dentro do cpap.
    sCapt = Caption
    Caption = sCapt & " (Visualizando)"
    Enabled = False
    Me.MousePointer = fmMousePointerHourGlass
    Visualizar_Bt.BackColor = &H808080: Visualizar_Bt.Enabled = False

    Dim AppActWb As Workbook, w As Window, AppWst As Long, Form_hWnd1 As Long        'No 2013 SDI foi necess|fffd|rio altera|fffd||fffd|es, pois Application.Visible=True vai exibir todas as janelas de wb. Ent|fffd|o procura e exibi s|fffd| a do AppActWb.
    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    Set AppActWb = Application.ActiveWorkbook: AppWst = Application.WindowState
    Application.Visible = False: DoEvents

    VisualizarImp AppActWb    'No 2013 por seguran|fffd|a passa wb como objeto, pois ao ocultar pode haver perca de foco do wb ativo.

    If Val(Application.Version) < 15 Then
        Application.Visible = True
        Application.WindowState = xlMinimized: Application.WindowState = AppWst    '2013 Workaround para recuperar foco.
    Else
        For Each w In Application.Windows
            If w.Parent.Name = AppActWb.Name Then w.WindowState = xlMinimized: w.WindowState = AppWst    'Usei WindowState como um workaround, pois w.Visible = True n|fffd|o funciona e, apesar do aplicativo oculto, ele continua True.
        Next
    End If

    Enabled = True
    MousePointer = fmMousePointerDefault
    Visualizar_Bt.BackColor = &H8000000F: Visualizar_Bt.Enabled = True
    Caption = sCapt

    'AppActivate Application.Caption 'Perde foco ao voltar nenhuma tentativa abaixo funcionou foi necess|fffd|rio API.
    'AppActivate sCapt
    '    Application.Visible = False
    '    DoEvents
    '    Application.Visible = True

    '    Application.WindowState = xlMinimized
    '    MyWait 1
    '    Application.WindowState = xlMaximized
    '    Application.ExecuteExcel4Macro ("APP.ACTIVATE()"): AppActivate sCapt
    SetForegroundWindowEsp Form_hWnd1, 0
End Sub

Private Sub Cancelar_Bt_Click()
    BotAcionado = 1
    Hide
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    BotAcionado = 1
End Sub

Private Sub SendOutlook_Bt_Click()    'OK do send original pelo outlook os outros send s|fffd|o apenas desvio
    If InStr(1, Internet_Cb.Value, "@") = 0 Then Internet_Cb.Value = "suporte@cpap.com.br"
    bProtect = Protect_Chb.Value
    BotAcionado = 2
    Hide
End Sub
Private Sub SendWebmail_Bt_Click()
    bSendByWebmail = True
    SendOutlook_Bt_Click
End Sub
Private Sub SendDirSMTP_Bt_Click()
    bSendBySMTP = True
    SendOutlook_Bt_Click
End Sub

Private Sub EmailSuporte_Lb_Click()
    Static EmailBak As String
    If EmailBak = "" Then
        EmailBak = Internet_Cb.Value
        Internet_Cb.Value = "suporte@cpap.com.br"
        EmailSuporte_Lb.Caption = EmailBak
    Else
        Internet_Cb.Value = EmailBak
        EmailBak = ""
        EmailSuporte_Lb.Caption = "suporte@cpap.com.br"
    End If
End Sub

Private Sub OutlookExpress_Lb_Click()
    If MsgBox("Verificar a configura|fffd||fffd|o e tornar o Outlook Express seu programa padr|fffd|o para o envio de emails?" & Chr(10) & Chr(10) & "   Obs.: S|fffd| use se estiver com problema para o envio de Email.", vbOKCancel + vbQuestion, "Outlook Express") = vbCancel Then Exit Sub
    Dim DLLPath
    Dim DLLPathEx
    Dim GetValue
    DLLPath = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPath")
    DLLPath = Application.WorksheetFunction.Clean(DLLPath)
    If DLLPath = "Error" Then GoTo FalhaNoRegitro

    DLLPathEx = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx")
    DLLPathEx = Application.WorksheetFunction.Clean(DLLPathEx)
    If DLLPath <> DLLPathEx Then
        SetKeyValue HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx", DLLPath, REG_SZ
    End If

    GetValue = "Outlook Express"
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\Clients\Mail", "", GetValue, REG_SZ
    '@="Outlook Express"

    GetValue = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express\Protocols\mailto", "")
    GetValue = Application.WorksheetFunction.Clean(GetValue)
    If InStr(1, GetValue, "MailTo") = 0 Then GoTo FalhaNoRegitro
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\CLASSES\mailto", "", GetValue, REG_SZ
    '[HKEY_LOCAL_MACHINE\Software\Clients\Mail\Outlook Express\Protocols\mailto]
    '@="URL:protocolo MailTo"
    '[HKEY_LOCAL_MACHINE\Software\CLASSES\mailto]
    '@="URL:protocolo MailTo"

    GetValue = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express\Protocols\mailto\DefaultIcon", "")
    GetValue = Application.WorksheetFunction.Clean(GetValue)
    If InStr(1, GetValue, "\MSIMN.EXE") = 0 Then GoTo FalhaNoRegitro
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\CLASSES\mailto\DefaultIcon", "", GetValue, REG_SZ
    '[HKEY_LOCAL_MACHINE\Software\Clients\Mail\Outlook Express\Protocols\mailto\DefaultIcon]
    '@="C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE,-2"
    '[HKEY_LOCAL_MACHINE\Software\CLASSES\mailto\DefaultIcon]
    '@="C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE,-2"

    GetValue = GetRegistryValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express\Protocols\mailto\shell\open\command", "")
    GetValue = Application.WorksheetFunction.Clean(GetValue)
    If InStr(1, GetValue, "\MSIMN.EXE") = 0 Then GoTo FalhaNoRegitro
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\CLASSES\mailto\shell\open\command", "", GetValue, REG_SZ
    '[HKEY_LOCAL_MACHINE\Software\Clients\Mail\Outlook Express\Protocols\mailto\shell\open\command]
    '@="\"C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE\" /mailurl:%1"
    '[HKEY_LOCAL_MACHINE\Software\CLASSES\mailto\shell\open\command]
    '@="\"C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE\" /mailurl:%1"

    MsgBox "Agora o Outlook Express |fffd| o programa padr|fffd|o para o envio de emails, mas voc|fffd| precisa sair e reiniciar o CPAP para efetivar a nova configura|fffd||fffd|o.", vbInformation, "Outlook Express - Sucesso na Configura|fffd||fffd|o!"
    Hide
    BotAcionado = 1
    Exit Sub
FalhaNoRegitro:
    MsgBox "Antes voc|fffd| precisa instalar ou reinstalar o Outlook Express em seu computador!", vbCritical, "Outlook Express - Falha no Registro!"
End Sub
Attribute VB_Name = "UserForm1SMTPwebmail"
Attribute VB_Base = "0{BBD0E3E5-ABF1-40B5-A507-4D8964E5B2DA}{EC2942EC-0328-494A-B10F-BEF1912B3674}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim sPrintThruEmailCfg As String    'Ini captu em pri ou padr|fffd|o definido aqui
Dim PrintThruEmailCfg As Variant    'Split de sPrintThruEmailCfg
Dim sSMTP As String
Dim sSMTPemail As String
Dim sSMTPpsw As String
Dim lSMTPport As Long
Dim bSMTPauthent As Boolean
Dim bSMTPssl As Boolean
Dim sSMTPreplyEmail As String

Dim sEmlEmail As String
Dim sEmlCc As String
Dim sEmlSubj As String
Dim sAttachDefNameChange As String
Dim sMsg As String

Private Sub UserForm_Activate()
'    Msg_Tb.SetFocus 'Acredito que poucos v|fffd|o editar ent|fffd|o |fffd| melhor deixar o bot|fffd|o enviar padr|fffd|o
'    Msg_Tb.SelStart = 0
End Sub

Private Sub UserForm_Initialize()
    Cc_LbCopiar.Picture = To_LbCopiar.Picture
    Subject_LbCopiar.Picture = To_LbCopiar.Picture
    Attach_LbCopiar.Picture = To_LbCopiar.Picture
    Msg_LbCopiar.Picture = To_LbCopiar.Picture
    Tip_LbCopiar.Picture = To_LbCopiar.Picture

    To_LbCopiar.ControlTipText = "Copiar 'Para:' para colar no Webmail"
    Cc_LbCopiar.ControlTipText = "Copiar 'Cc:' para colar no Webmail"
    Subject_LbCopiar.ControlTipText = "Copiar 'Assunto:' para colar no Webmail"
    Attach_LbCopiar.ControlTipText = "Copiar 'Anexo:' para colar no Webmail"
    Msg_LbCopiar.ControlTipText = "Copiar 'Mensagem:' para colar no Webmail"

    vEnableEvents = False
    SendByWebmail_OpB.Value = bSendByWebmail

    sPrintThruEmailCfg = Workbooks("cpap_pri.mac").Sheets(1).Range("PrintThruEmailCfg")    'Capt cfg salva
    If sPrintThruEmailCfg = "" Then sPrintThruEmailCfg = "1;;1;;;;0;25;1;1;"    'Default if empty
    '                                                     0 12 3456 7  8 9 10 posicione o cursor no in|fffd|cio do campo logo ap|fffd|s o ponto e virgula e des|fffd|a a seta para ver a posi|fffd||fffd|o ao lado direito do cursor
    sPrintThruEmailCfg = sPrintThruEmailCfg & ";"    'Def. de vari|fffd|veis adic. depois
    PrintThruEmailCfg = Split(sPrintThruEmailCfg, ";")

    SMTPcpap_OpB.Value = False: SMTPcpap_OpB.Visible = False    'PrintThruEmailCfg(0) = "1" 'Desabilitei e ocultei a op|fffd||fffd|o do smtp cpap no inicio (1/2)
    SMTPreplyEmail_Tb.Text = PrintThruEmailCfg(1)
    SMTPreplyEmailSame_Chb.Value = PrintThruEmailCfg(2) = "1"
    SMTP_Tb.Text = PrintThruEmailCfg(3)
    SMTPemail_Tb.Text = PrintThruEmailCfg(4)
    SMTPpsw_Tb.Value = PrintThruEmailCfg(5)
    SMTPpswSave_ChB.Value = PrintThruEmailCfg(6) = "1"
    SMTPport_Tb.Value = PrintThruEmailCfg(7)
    SMTPauthent_ChB.Value = PrintThruEmailCfg(8) = "1"
    SMTPssl_ChB.Value = PrintThruEmailCfg(9) = "1"
    sAttachDefNameChange = PrintThruEmailCfg(10)

    Attach_Tb.Text = sAttachFullName
    If sAttachDefNameChange <> "" And LCase(sAttachDefNameChange) <> _
            LCase(sAttachDefName) Then AttachDefNameChange sAttachDefNameChange
    vEnableEvents = True

    FormHideShowCtrls
End Sub

Private Sub SendByWebmail_OpB_Click(): FormHideShowCtrls: End Sub
Private Sub SendBySMTP_OpB_Click(): FormHideShowCtrls: End Sub
Private Sub SMTPcpap_OpB_Click(): FormHideShowCtrls: End Sub
Private Sub SMTP_OpB_Click(): FormHideShowCtrls: End Sub
Private Sub SMTPreplyEmailSame_Chb_Click(): FormHideShowCtrls: End Sub
Sub FormHideShowCtrls()
    If vEnableEvents = False Then Exit Sub
    SendByWebmail_Lb.Visible = SendByWebmail_OpB.Value
    SendByWebmail2_Lb.Visible = SendByWebmail_OpB.Value
    Tip_LbCopiar.Visible = SendByWebmail_OpB.Value
    To_LbCopiar.Visible = SendByWebmail_OpB.Value
    Cc_LbCopiar.Visible = SendByWebmail_OpB.Value
    Subject_LbCopiar.Visible = SendByWebmail_OpB.Value
    Attach_LbCopiar.Visible = SendByWebmail_OpB.Value
    Msg_LbCopiar.Visible = SendByWebmail_OpB.Value
    SMTP_Fr.Visible = Not SendByWebmail_OpB.Value

    SMTPcpap_Lb.Visible = SMTPcpap_OpB.Value: If Application.Run("cpap_ex8.mac!ShiftDown") Then SMTPcpap_OpB.Visible = True    'Exibe op|fffd||fffd|o do smtp cpap oculta no inicio (2/2)
    SMTPreplyEmailSame_Chb.Visible = Not SMTPcpap_OpB.Value
    SMTP_Tb.Visible = Not SMTPcpap_OpB.Value
    SMTPemail_Tb.Visible = Not SMTPcpap_OpB.Value: SMTP_Lb.Visible = Not SMTPcpap_OpB.Value
    SMTPssl_ChB.Visible = Not SMTPcpap_OpB.Value
    SMTPport_Tb.Visible = Not SMTPcpap_OpB.Value: SMTPport_Lb.Visible = Not SMTPcpap_OpB.Value
    SMTPauthent_ChB.Visible = Not SMTPcpap_OpB.Value
    SMTPssl_ChB.Visible = Not SMTPcpap_OpB.Value
    SMTPpsw_Tb.Visible = Not SMTPcpap_OpB.Value: SMTPpsw_Lb.Visible = Not SMTPcpap_OpB.Value
    SMTPpswSave_ChB.Visible = Not SMTPcpap_OpB.Value

    SMTPreplyEmail_Lb.Caption = "Seu e-mail para receber resposta" & IIf(SMTPcpap_OpB.Value, " e um Cc:", ":")
    SMTPreplyEmail_Tb.Left = SMTPreplyEmail_Lb.Left + SMTPreplyEmail_Lb.Width + 2
    SMTPreplyEmail_Tb.Width = IIf(Not SMTPcpap_OpB.Value And SMTPreplyEmailSame_Chb.Value, 1, 106)
    SMTPreplyEmail_Tb.Visible = SMTPreplyEmail_Tb.Width > 1
    SMTPreplyEmailSame_Chb.Left = SMTPreplyEmail_Tb.Left + SMTPreplyEmail_Tb.Width + 2
    SMTPreplyEmailSame_Chb.Caption = IIf(SMTPreplyEmailSame_Chb.Value, "Usar o mesmo do seu SMTP", "Usar o do SMTP")

    Me.Height = IIf(SendByWebmail_OpB.Value, SMTP_Fr.Top, SMTP_Fr.Top + SMTP_Fr.Height) + 28
    Me.Caption = IIf(SendByWebmail_OpB.Value, "Enviar Webmail - Sugest|fffd|es para Copiar e Colar no Webmail", "Enviar E-mail Direto via SMTP")
End Sub

Private Sub Close_Bt_Click()
    Hide
End Sub

Private Sub To_LbCopiar_Click(): xCtrl_LbCopiar_Click To_LbCopiar, To_Tb: End Sub
Private Sub Cc_LbCopiar_Click(): xCtrl_LbCopiar_Click Cc_LbCopiar, Cc_Tb: End Sub
Private Sub Subject_LbCopiar_Click(): xCtrl_LbCopiar_Click Subject_LbCopiar, Subject_Tb: End Sub
Private Sub Attach_LbCopiar_Click(): xCtrl_LbCopiar_Click Attach_LbCopiar, Attach_Tb: End Sub
Private Sub Msg_LbCopiar_Click(): xCtrl_LbCopiar_Click Msg_LbCopiar, Msg_Tb: End Sub
Private Sub xCtrl_LbCopiar_Click(Ctrl As Object, Ctrl_Tb As Object)
    PressEfect Ctrl: Ctrl_Tb.SetFocus

    'CopyClipboard
    Ctrl_Tb.SelStart = 0
    Ctrl_Tb.SelLength = Ctrl_Tb.TextLength
    Ctrl_Tb.Copy
End Sub

Sub PressEfect(Ctrl As Object)
    Dim mp, se
    mp = Ctrl.MousePointer
    se = Ctrl.SpecialEffect
    Ctrl.MousePointer = fmMousePointerHourGlass
    Ctrl.SpecialEffect = fmSpecialEffectSunken
    MyWait 0.2
    Ctrl.SpecialEffect = se
    Ctrl.MousePointer = mp
End Sub

Private Sub SendSMTP_Bt_Click()
    Dim mp: mp = Me.MousePointer: Me.MousePointer = fmMousePointerHourGlass: MyWait 0.2

    'Get data from form and critisize
    If SMTPcpap_OpB.Value Then
        sSMTP = "smtp.braslink.com"    '"smtp.cpap.com.br"
        sSMTPemail = "cpapprn@cpap.com.br"
        sSMTPpsw = "cpapprn123"
        lSMTPport = 587    '25
        bSMTPauthent = True
        bSMTPssl = False
        sSMTPreplyEmail = SMTPreplyEmail_Tb.Text
        If Not fCritEmailAddr(sSMTPreplyEmail) Then
            MsgBox "|fffd| obrigat|fffd|rio informar um endere|fffd|o de e-mail v|fffd|lido para receber uma poss|fffd|vel resposta do destinat|fffd|rio.", vbCritical, "CPAP - E-mail para Resposta Inv|fffd|lido!"
            SMTPreplyEmail_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If
    Else
        sSMTP = SMTP_Tb.Text
        If Not fCritSMTPAddr(sSMTP) Then
            MsgBox "|fffd| obrigat|fffd|rio informar um endere|fffd|o de SMTP v|fffd|lido.", vbCritical, "CPAP - SMTP Inv|fffd|lido!"
            SMTP_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If

        sSMTPemail = SMTPemail_Tb.Text
        If Not fCritEmailAddr(sSMTPemail) Then
            MsgBox "|fffd| obrigat|fffd|rio informar um endere|fffd|o de e-mail v|fffd|lido do SMTP.", vbCritical, "CPAP - E-mail do SMTP Inv|fffd|lido!"
            SMTPemail_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If

        sSMTPpsw = SMTPpsw_Tb.Value
        If Len(sSMTPpsw) < 3 Then
            MsgBox "|fffd| obrigat|fffd|rio informar a senha do endere|fffd|o de e-mail do SMTP.", vbCritical, "CPAP - Falta Informar a Senha!"
            SMTPpsw_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If

        lSMTPport = SMTPport_Tb.Value
        If lSMTPport <= 0 Then
            MsgBox "|fffd| obrigat|fffd|rio informar a porta do servidor do SMTP. " & SMTPport_Tb.ControlTipText, vbCritical, "CPAP - Porta do SMTP Inv|fffd|lida!"
            SMTPport_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If

        bSMTPauthent = SMTPauthent_ChB.Value
        bSMTPssl = SMTPssl_ChB.Value
        sSMTPreplyEmail = IIf(SMTPreplyEmailSame_Chb.Value, SMTPemail_Tb.Text, SMTPreplyEmail_Tb.Text)
        If Not fCritEmailAddr(sSMTPreplyEmail) Then
            MsgBox "|fffd| obrigat|fffd|rio informar um endere|fffd|o de e-mail v|fffd|lido e |fffd|nico para receber uma poss|fffd|vel resposta do destinat|fffd|rio.", vbCritical, "CPAP - E-mail para Resposta Inv|fffd|lido!"
            SMTPreplyEmail_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If
        If SMTPreplyEmailSame_Chb.Value Then sSMTPreplyEmail = ""    'Se igual ao SMTP, n|fffd|o parece ser necess|fffd|rio para resposta e nem Cc
    End If

    sEmlEmail = To_Tb.Text
    If Not fCritEmailAddrList(sEmlEmail) Then
        MsgBox "|fffd| obrigat|fffd|rio informar um ou mais endere|fffd|os de e-mail v|fffd|lidos para destinat|fffd|rios da mensagem.", vbCritical, "CPAP - E-mail de Destinat|fffd|rio Inv|fffd|lido!"
        To_Tb.SetFocus
        Me.MousePointer = mp
        Exit Sub
    End If

    sEmlCc = Cc_Tb.Text
    If sEmlCc <> "" Then
        If Not fCritEmailAddrList(sEmlCc) Then
            MsgBox "Verifique e corrija o(s) endere|fffd|o(s) de e-mail para destinat|fffd|rio de uma c|fffd|pia carbono da mensagem.", vbCritical, "CPAP - E-mail de Destinat|fffd|rio 'Cc' Inv|fffd|lido!"
            Cc_Tb.SetFocus
            Me.MousePointer = mp
            Exit Sub
        End If
    End If
    If sEmlCc <> "" And sSMTPreplyEmail <> "" Then sEmlCc = sSMTPreplyEmail & "," & sEmlCc    'Envia um Cc para o e-mail de resposta se existir e for diferente do do SMTP
    If sEmlCc = "" And sSMTPreplyEmail <> "" Then sEmlCc = sSMTPreplyEmail

    sEmlSubj = Subject_Tb.Text
    If Len(sEmlSubj) < 3 Then
        MsgBox "Insira algum texto para o assunto da mensagem.", vbCritical, "CPAP - Mensagem Sem Assunto!"
        Subject_Tb.SetFocus
        Me.MousePointer = mp
        Exit Sub
    End If

    If Len(sAttachFullName) < 5 Or Dir(sAttachFullName) = "" Then
        MsgBox "O arquivo a anexar pode ter sido exclu|fffd|do. Feche e depois tente imprimir novamente.", vbCritical, "CPAP - Anexo N|fffd|o Encontrado!"
        Attach_Tb.SetFocus
        Me.MousePointer = mp
        Exit Sub
    End If

    sMsg = Msg_Tb.Text
    If Len(sMsg) < 1 Then
        MsgBox "Insira algum texto para a mensagem.", vbCritical, "CPAP - Mensagem Vazia!"
        Msg_Tb.SetFocus
        Me.MousePointer = mp
        Exit Sub
    End If

    If SMTPcpap_OpB.Value And UBound(Split(sEmlEmail & sEmlCc, "@")) > 5 Then   'Limitando
        MsgBox "O servidor de SMTP do CPAP est|fffd| limitado ao m|fffd|ximo de 4 destinat|fffd|rios. Use o SMTP de seu e-mail ou webmail.", vbCritical, "CPAP - Limites!"
        To_Tb.SetFocus
        Me.MousePointer = mp
        Exit Sub
    End If

    SendMailBySMTP
    Me.MousePointer = mp
End Sub

Private Sub SendMailBySMTP()
    Dim cdoMsg        ' As CDO.Message       Based from http://msdn.microsoft.com/en-us/library/ms875947(EXCHG.65).aspx. See CDO for Windows 2000 reference at: http://msdn.microsoft.com/en-us/library/ms526266(v=EXCHG.10).aspx
    Dim cdoConfig     ' As CDO.Configuration   See ref. in http://msdn.microsoft.com/en-us/library/ms526266(v=EXCHG.10).aspx

    Set cdoConfig = CreateObject("CDO.Configuration")    'Create CDO configuration objects and then set some configuration fields.
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/smtpserver") = sSMTP

    cdoConfig("http://schemas.microsoft.com/cdo/configuration/sendemailaddress") = IIf(SMTPcpap_OpB.Value, """Impress|fffd|o por E-mail (CPAP)"" <" & sSMTPemail & ">", sSMTPemail)    '"""YourDisplayName"" <youremailaddress@serv.com>"
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/sendusername") = sSMTPemail  'This and above fields substitute cdoMsg.From. Normmally is the email anddress with the server

    cdoConfig("http://schemas.microsoft.com/cdo/configuration/sendpassword") = sSMTPpsw
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/smtpserverport") = SMTPport_Tb.Value    '25  465
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate") = IIf(bSMTPauthent, 1, 0)
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/smtpusessl") = bSMTPssl    'True
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/sendusing") = 2    '(1)Local SMTP (2)Over network
    cdoConfig("http://schemas.microsoft.com/cdo/configuration/smtpconnectiontimeout") = 150
    cdoConfig.Fields.Update     'Update configuration fields

    Set cdoMsg = CreateObject("CDO.Message")    'Create CDO message
    With cdoMsg
        Set .Configuration = cdoConfig
        'From = Isn't need, if set both sendemailaddress and sendusername fiels in cdoConfig. Other wise set only sendusername and set here the value that I put in sendemailaddress
        If sSMTPreplyEmail <> "" Then .ReplyTo = sSMTPreplyEmail     '"orlandof6@hotmail.com"
        .To = sEmlEmail    '"orlando@cpap.com.br"
        If sEmlCc <> "" Then .CC = sEmlCc
        '.BCC = ""
        .Subject = sEmlSubj    '"Message subject"
        .TextBody = sMsg    '"dod fof ofo dood ododoo dod"
        .AddAttachment sAttachFullName    '"D:\Documents and Settings\Orlando Filho\Desktop\RedeUsando3G.txt"
        On Error Resume Next
        .Send
    End With

    Set cdoMsg = Nothing     'Clean up.
    Set cdoConfig = Nothing

    If Err.Number <> 0 Then
        MsgBox Err.Number & ": " & Err.Description, vbCritical, "CPAP - Erro ao Enviar Mensagem!"
    Else
        MsgBox "Mensagem Enviada!", vbInformation, "CPAP - Enviar Impress|fffd|o por E-mail"
        'Salvar config com sucesso
        If SMTPcpap_OpB.Value Then    'Se enviado pelo SMTP do CPAP s|fffd| afeta e salva duas cfg
            PrintThruEmailCfg(0) = IIf(SMTPcpap_OpB.Value, "1", "")
            PrintThruEmailCfg(1) = SMTPreplyEmail_Tb.Text
        Else    'Se enviado SMTP n|fffd|o do CPAP afeta e salva todas exceto sAttachDefNameChange
            PrintThruEmailCfg(0) = IIf(SMTPcpap_OpB.Value, "1", "")
            PrintThruEmailCfg(1) = IIf(SMTPreplyEmailSame_Chb.Value, PrintThruEmailCfg(1), SMTPreplyEmail_Tb.Text)
            PrintThruEmailCfg(2) = IIf(SMTPreplyEmailSame_Chb.Value, "1", "")
            PrintThruEmailCfg(3) = SMTP_Tb.Text
            PrintThruEmailCfg(4) = SMTPemail_Tb.Text
            PrintThruEmailCfg(5) = SMTPpsw_Tb.Value
            PrintThruEmailCfg(6) = IIf(SMTPpswSave_ChB.Value, "1", "")
            PrintThruEmailCfg(7) = SMTPport_Tb.Value
            PrintThruEmailCfg(8) = IIf(SMTPauthent_ChB.Value, "1", "")
            PrintThruEmailCfg(9) = IIf(SMTPssl_ChB.Value, "1", "")
            'PrintThruEmailCfg(10) = sAttachDefNameChange
        End If
        If Join(PrintThruEmailCfg, ";") <> sPrintThruEmailCfg Then Application.Run "Cpap_pri.mac!AltCfgPorUsu", Join(PrintThruEmailCfg, ";"), 10
        Close_Bt_Click
    End If
End Sub

Function fCritEmailAddr(sEmailAddr As String) As Boolean
    If InStr(1, sEmailAddr, "@") = 0 Or InStr(1, sEmailAddr, ".") = 0 Then Exit Function
    If InStr(1, sEmailAddr, "@") < 4 Or Len(sEmailAddr) - InStr(1, sEmailAddr, "@") < 6 Then Exit Function
    If InStr(1, sEmailAddr, " ") > 0 Or InStr(1, sEmailAddr, ",") > 0 Or InStr(1, sEmailAddr, ";") > 0 Then Exit Function
    fCritEmailAddr = True
End Function

Function fCritEmailAddrList(sEmailAddr As String) As Boolean
    Dim EmailAddrSpl, ea
    If Len(sEmailAddr) < 4 Then Exit Function
    sEmailAddr = Replace(sEmailAddr, " ", "")
    sEmailAddr = Replace(sEmailAddr, ";", ",")
    EmailAddrSpl = Split(sEmailAddr, ",")

    For Each ea In EmailAddrSpl
        If Not fCritEmailAddr(CStr(ea)) Then Exit Function
    Next
    fCritEmailAddrList = True
End Function

Function fCritSMTPAddr(sSMTPAddr As String) As Boolean
    If InStr(1, sSMTPAddr, "@") > 0 Or InStr(1, sSMTPAddr, ".") = 0 Then Exit Function
    If InStr(1, sSMTPAddr, ".") < 5 Or Len(sSMTPAddr) - InStrRev(sSMTPAddr, ".") < 2 Or Len(sSMTPAddr) - InStrRev(sSMTPAddr, ".") > 3 Then Exit Function
    If InStr(1, sSMTPAddr, " ") > 0 Or InStr(1, sSMTPAddr, ",") > 0 Or InStr(1, sSMTPAddr, ";") > 0 Then Exit Function
    fCritSMTPAddr = True
End Function

Private Sub AttachDefNameChange_Lb_Click()
    Dim NewName
    Application.SendKeys "{HOME}"
    NewName = Application.InputBox("Sugira um novo nome, mas recomenda-se manter a extens|fffd|o padr|fffd|o '" & Mid(sAttachDefName, InStr(1, sAttachDefName, ".")) & "' de formato de arquivo do Excel.", "Alterar Nome Padr|fffd|o do Arquivo de Impress|fffd|o a Anexar", sAttachDefName)
    If NewName = False Then Exit Sub
    If InStr(1, NewName, ".") < 2 Or InStr(1, NewName, ".") = Len(NewName) _
            Or InStr(1, NewName, ".") <> InStrRev(NewName, ".") Then MsgBox "O nome do arquivo deve conter um ponto, e somente um, para separar a extens|fffd|o no final.", vbCritical, "CPAP - Extens|fffd|o Inv|fffd|lida!": Exit Sub
    If InStr(1, NewName, "'") > 0 Or InStr(1, NewName, "/") > 0 Or InStr(1, NewName, "\") > 0 _
            Or InStr(1, NewName, "[") > 0 Or InStr(1, NewName, "]") > 0 Or InStr(1, NewName, ":") > 0 _
            Or InStr(1, NewName, ";") > 0 Or InStr(1, NewName, "|") > 0 Or InStr(1, NewName, "=") > 0 _
            Or InStr(1, NewName, ",") > 0 Then MsgBox "O nome cont|fffd|m um ou mais dos seguintes caracteres: ponto(.); aspas(''); barra (/); barra invertida (\); colchetes ([ ]); dois-pontos (:); ponto-e-v|fffd|rgula (;); barra vertical (|); sinal de igualdade (=); v|fffd|rgula (,)", vbCritical, "CPAP - Nome Inv|fffd|lido para Arquivo": Exit Sub
    If AttachDefNameChange(CStr(NewName)) Then
        sAttachDefNameChange = IIf(LCase(NewName) = LCase(sAttachDefName), "", NewName)    'Se igual ao padr|fffd|o conforme sugerido restaura config para vazio
        PrintThruEmailCfg(10) = sAttachDefNameChange
        If Join(PrintThruEmailCfg, ";") <> sPrintThruEmailCfg Then Application.Run "Cpap_pri.mac!AltCfgPorUsu", Join(PrintThruEmailCfg, ";"), 10
    End If
End Sub

Private Function AttachDefNameChange(sNewName As String) As Boolean
    If Dir(sAttachFullName) = "" Then MsgBox "O arquivo a anexar pode ter sido exclu|fffd|do. Feche e depois tente imprimir novamente.", vbCritical, "CPAP - Anexo N|fffd|o Encontrado!"
    sAttachFullName = Replace(sAttachFullName, Dir(sAttachFullName), sNewName)
    If LCase(sAttachFullName) = LCase(Attach_Tb.Text) Then Exit Function
    On Error Resume Next
    If Dir(sAttachFullName) <> "" Then Kill sAttachFullName
    If Err.Number = 0 Then Name Attach_Tb.Text As sAttachFullName
    If Err.Number = 0 Then
        Attach_Tb.Text = sAttachFullName
        AttachDefNameChange = True
    Else
        sAttachFullName = Attach_Tb.Text
        MsgBox Err.Number & ": " & Err.Description, vbCritical, "CPAP - Erro ao Alterar Nome Padr|fffd|o do Arquivo de Impress|fffd|o a Anexar!"
    End If
End Function

Private Sub AttachSaveAs_Lb_Click()
    If AttachSaveAs_Lb.Enabled = False Then Exit Sub Else AttachSaveAs_Lb.Enabled = False    'Tenta evitar dois cliques
    Dim mp: mp = Me.MousePointer: Me.MousePointer = fmMousePointerHourGlass: MyWait 0.2

    OpenNewExcel sAttachFullName, 2
    If sAttachFullName <> Attach_Tb.Text Then Attach_Tb.Text = sAttachFullName
    Me.MousePointer = mp
    AttachSaveAs_Lb.Enabled = True
End Sub

Attribute VB_Name = "UserFormEditHist"
Attribute VB_Base = "0{37175F80-A438-4A6E-909F-9BC61B18F9F4}{B6BE90DF-26E6-4E82-85A2-75ECF39278DF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private vListBox As Control
Private vTextBox As Control
Private SemAltera|fffd||fffd|es As Boolean


Private Sub Ajuda_Bt_Click()
    Application.Help ThisWorkbook.Path & "\cpap.hlp", HelpContextID
End Sub

Private Sub UserForm_Initialize()
    vEnableEvents = True
    Caption = "Editando Sugest|fffd|es do Campo " & HistEditCampo
    'Listando listboxes - Lista de sug fixas
    Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo, ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo).End(xlDown))
    If campo.Rows.Count < 100 Then
        j = 0
        For Each c In campo
            cf = Format(IIf(IsError(c.Value), "", c.Value), FormatoHist)
            j = j + 1
            If j > 1 Then
                vRep = False
                For i = 1 To SugFixas_Lb.ListCount
                    If SugFixas_Lb.List(i - 1) = cf Then vRep = True
                Next
                If vRep = False Then SugFixas_Lb.AddItem (cf)
            End If
        Next
    End If

    'Listando ListBox - Sugest Hist|fffd|ricas
    Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist", ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist").End(xlDown))
    If campo.Rows.Count < 10000 Then
        j = 0
        For Each c In campo
            cf = Format(IIf(IsError(c.Value), "", c.Value), FormatoHist)
            j = j + 1
            If j > 1 Then
                vRep = False
                For i = 1 To SugHist_Lb.ListCount
                    If SugHist_Lb.List(i - 1) = cf Then vRep = True
                Next
                If vRep = False And cf <> "" Then SugHist_Lb.AddItem (cf)
            End If
        Next
    End If
    NumMax_Ct.Value = ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist").Offset(-1, 0)
    MultiPage1.Value = 0
    MultiPage1_Change
    SemAltera|fffd||fffd|es = True
    OcultarExibControlesHist
End Sub

Private Sub NumMax_Ct_Change()
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub NumMax_Ct_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If IsNumeric(NumMax_Ct.Value) Then
        If NumMax_Ct.Value < 0 Then NumMax_Ct.Value = 0
        If NumMax_Ct.Value > 100 Then NumMax_Ct.Value = 100
    Else
        NumMax_Ct.Value = 15
    End If
End Sub

Private Sub Fechar_Bt_Click()
    Hide
    If SemAltera|fffd||fffd|es = True Then Exit Sub
    If MsgBox("Salvar altera|fffd||fffd|es nas sugest|fffd|es para o campo " & HistEditCampo & "?", vbQuestion + vbOKCancel, "CPAP|fffd|") = vbCancel Then Exit Sub
    DirBD = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirBD").Value)    'DirP = ThisWorkbook.Path
    Application.ScreenUpdating = False
    If MyOpenFile(DirBD & "\banco\" & NomeArqHist, False) Then
        'Limpando c|fffd|lulas
        Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo, ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo).End(xlDown))
        If campo.Rows.Count < 100 Then
            i = campo(1)
            campo.ClearContents
            campo(1) = i
        End If
        Set campo = ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist", ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist").End(xlDown))
        If campo.Rows.Count > 10000 Then
        Else
            i = campo(1)
            campo.ClearContents
            campo(1) = i
        End If

        'Descaregando comboboxes - Sug. Fixas
        k = 0
        NumM|fffd|x = ThisWorkbook.Sheets(NomeArqHist).Range("DadosHist").Row - ThisWorkbook.Sheets(NomeArqHist).Range("DadosFixos").Row - 3
        For j = 1 To SugFixas_Lb.ListCount
            If j > NumM|fffd|x Then Exit For
            vRep = False
            If j > 1 Then
                For i = 1 To j
                    If ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo).Offset(i, 0) = SugFixas_Lb.List(j - 1) Then vRep = True
                Next
            End If
            If vRep = False Then
                k = k + 1
                ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo).Offset(k, 0) = SugFixas_Lb.List(j - 1)
            End If
        Next

        'Descarregando comboboxes - Sug. Hist|fffd|ricas
        k = 0
        For j = 1 To SugHist_Lb.ListCount
            If j > NumMax_Ct.Value * 1 Then Exit For
            vRep = False
            If j > 1 Then
                For i = 1 To j
                    If ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist").Offset(i, 0) = SugHist_Lb.List(j - 1) Then vRep = True
                Next
            End If
            If vRep = False Then
                k = k + 1
                ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist").Offset(k, 0) = SugHist_Lb.List(j - 1)
            End If
        Next
    End If
    ThisWorkbook.Sheets(NomeArqHist).Range(HistEditCampo & "Hist").Offset(-1, 0) = NumMax_Ct.Value
    SalvandoHist
    Application.ScreenUpdating = True
End Sub

Private Sub Mover_Sb_SpinUp()
    i = vListBox.ListIndex
    If i < 1 Then Exit Sub
    vListBox.AddItem vListBox.List(i), i - 1
    vListBox.RemoveItem i + 1
    vListBox.Selected(i - 1) = True
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub Mover_Sb_SpinDown()
    i = vListBox.ListIndex
    If i < 0 Or i + 1 >= vListBox.ListCount Then Exit Sub
    vListBox.AddItem vListBox.List(i), i + 2
    vListBox.RemoveItem i
    vListBox.Selected(i + 1) = True
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub Transf_Bt_Click()
    i = vListBox.ListIndex
    If i < 0 Then Exit Sub
    If vListBox.Selected(i) Then
        i1 = vListBox.Value
        vListBox.RemoveItem i
        vEnableEvents = False
        If vListBox.ListIndex = -1 Then vTextBox.Value = ""
        vEnableEvents = True
    End If
    If MultiPage1.Value = 0 Then MultiPage1.Value = 1 Else MultiPage1.Value = 0
    vListBox.AddItem i1
    vListBox.Selected(vListBox.ListCount - 1) = True
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub Excluir_Bt_Click()
    i = vListBox.ListIndex
    If i < 0 Then Exit Sub
    If vListBox.Selected(i) Then vListBox.RemoveItem i
    vEnableEvents = False
    If vListBox.ListIndex = -1 Then vTextBox.Value = ""
    vEnableEvents = True
    OcultarExibControlesHist
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub Nova_Bt_Click()
    vListBox.AddItem "Nova Sugest|fffd|o" & vListBox.ListCount + 1
    vListBox.Selected(vListBox.ListCount - 1) = True
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub MultiPage1_Change()
    If MultiPage1.Value = 0 Then
        Set vListBox = SugHist_Lb
        Set vTextBox = SugHist_Ct
    Else
        Set vListBox = SugFixas_Lb
        Set vTextBox = SugFixas_Ct
    End If
    OcultarExibControlesHist
End Sub

Private Sub SugFixas_Ct_Change()
    If vEnableEvents = False Then Exit Sub
    i = SugFixas_Lb.ListIndex
    i1 = SugFixas_Ct.SelStart
    If i < 0 Then
        j = SugFixas_Ct.Value
        Nova_Bt_Click
        SugFixas_Ct.Value = j
        i = SugFixas_Lb.ListCount - 1
    End If
    SugFixas_Lb.AddItem SugFixas_Ct.Value, i
    SugFixas_Lb.RemoveItem i + 1
    SugFixas_Lb.Selected(i) = True
    SugFixas_Ct.SelStart = i1
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub SugFixas_Ct_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    i = SugFixas_Lb.ListIndex
    If SugFixas_Ct.Value <> "" Or i < 0 Then Exit Sub
    SugFixas_Lb.RemoveItem i
End Sub

Private Sub SugFixas_LB_Click()
    vEnableEvents = False
    SugFixas_Ct.Value = SugFixas_Lb.Value
    If SugFixas_Ct.Enabled Then SugFixas_Ct.SetFocus
    vEnableEvents = True
    OcultarExibControlesHist
End Sub

Private Sub SugHist_Ct_Change()
    If vEnableEvents = False Then Exit Sub
    i = SugHist_Lb.ListIndex
    i1 = SugHist_Ct.SelStart
    If i < 0 Then
        j = SugHist_Ct.Value
        Nova_Bt_Click
        SugHist_Ct.Value = j
        i = SugHist_Lb.ListCount - 1
    End If
    SugHist_Lb.AddItem SugHist_Ct.Value, i
    SugHist_Lb.RemoveItem i + 1
    SugHist_Lb.Selected(i) = True
    SugHist_Ct.SelStart = i1
    SemAltera|fffd||fffd|es = False
End Sub

Private Sub SugHist_Ct_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    i = SugHist_Lb.ListIndex
    If SugHist_Ct.Value <> "" Or i < 0 Then Exit Sub
    SugHist_Lb.RemoveItem i
End Sub

Private Sub SugHist_Lb_Click()
    vEnableEvents = False
    SugHist_Ct.Value = SugHist_Lb.Value
    If SugHist_Ct.Enabled Then SugHist_Ct.SetFocus
    vEnableEvents = True
    OcultarExibControlesHist
End Sub

Sub OcultarExibControlesHist()
    i = vListBox.ListIndex > -1
    Excluir_Bt.Enabled = i
    Mover_Sb.Enabled = i
    Mover_Lb.Enabled = i
    Transf_Bt.Enabled = i
    Transf_Bt.ControlTipText = "Transfere para " & IIf(MultiPage1.Value = 0, "Fixas", "Hist|fffd|ricas")
End Sub

' InQuest injected base64 decoded content
' x"{e1
' %bi 
' j)Zu

INQUEST-PP=macro
