Attribute VB_Name = "CController"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Implements IController

Private mView As IView
Private mModel As IModel
Private mStorage As IStorage

Private mpEvents As New IControllerEvents

Private Property Get IController_Events() As IControllerEvents
    Set IController_Events = mpEvents
End Property

Private Property Get IController_Model() As IModel
    Set IController_Model = mModel
End Property
Private Property Set IController_Model(ByVal pModel As IModel)
    Set mModel = pModel
    mpEvents.RaiseModelChanged
End Property

Private Property Get IController_View() As IView
    Set IController_View = mView
End Property
Private Property Set IController_View(ByVal pView As IView)
    Set mView = pView
    Set mView.Controller = Me
End Property

Private Property Get IController_Storage() As IStorage
    Set IController_Storage = mStorage
End Property
Private Property Set IController_Storage(ByVal pStorage As IStorage)
    Set mStorage = pStorage
    Set mView.Storage = pStorage
End Property

Private Sub IController_Run()
    #If Win32 Or Win64 Then
    mView.Show vbModeless
    #Else
    mView.Show vbModal
    #End If
End Sub
Attribute VB_Name = "CModel"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Implements IModel

Dim sb As StringBuilder
Dim CellWidth As Integer    'Characters per Cell in output file
Dim convertDollar As Boolean
Dim booktabs As Boolean
Dim tableFloat As Boolean
Dim Indent As Integer
Dim sFileName As String
Dim RangeToUse As Range

Private mpEvents As New IModelEvents

Private Sub Class_Initialize()
    Set sb = New StringBuilder
End Sub

' IModel implementation

Public Property Get IModel_Events() As IModelEvents
    Set IModel_Events = mpEvents
End Property

Public Property Get IModel_Options() As x2lOptions
    If convertDollar Then IModel_Options = IModel_Options Or x2lConvertMathChars
    If booktabs Then IModel_Options = IModel_Options Or x2lBooktabs
    If tableFloat Then IModel_Options = IModel_Options Or x2lCreateTableEnvironment
End Property
Public Property Let IModel_Options(ByVal Options As x2lOptions)
    Dim oldOptions As x2lOptions
    oldOptions = IModel_Options()
    
    convertDollar = (Options And x2lConvertMathChars) <> x2lNone
    booktabs = (Options And x2lBooktabs) <> x2lNone
    tableFloat = (Options And x2lCreateTableEnvironment) <> x2lNone
    
    If oldOptions <> IModel_Options() Then
        mpEvents.RaiseChanged
    End If
End Property

Public Property Get IModel_Indent() As Integer
    IModel_Indent = Indent
End Property
Public Property Let IModel_Indent(ByVal iIndent As Integer)
    If Indent = iIndent Then Exit Property
    Indent = iIndent
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_CellWidth() As Integer
    IModel_CellWidth = CellWidth
End Property
Public Property Let IModel_CellWidth(ByVal iCellWidth As Integer)
    If CellWidth = iCellWidth Then Exit Property
    CellWidth = iCellWidth
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_FileName() As String
    IModel_FileName = sFileName
End Property
Public Property Let IModel_FileName(ByVal iFileName As String)
    Dim sBaseDir As String
    sBaseDir = WorksheetDir
    If UCase(iFileName) Like UCase(sBaseDir) & "\*" Then
        iFileName = Mid$(iFileName, Len(sBaseDir) + 2)
    End If
    sFileName = iFileName
End Property
Public Property Get IModel_AbsoluteFileName() As String
    If sFileName Like "?:\*" Or sFileName Like "\\*\*" Then
        IModel_AbsoluteFileName = sFileName
    Else
        IModel_AbsoluteFileName = Printf("%1\%2", WorksheetDir, sFileName)
    End If
End Property

Public Property Get IModel_RangeAddress() As String
    IModel_RangeAddress = RangeToAddress(RangeToUse)
End Property
Public Property Let IModel_RangeAddress(ByVal iRange As String)
    Set RangeToUse = AddressToRange(iRange)
    mpEvents.RaiseChanged
End Property

Public Function IModel_GetConversionResult() As String
    Dim r As Range, rc As Range, c As Range
    Dim FileName As String
    Dim i As Integer
    Dim j As Integer
    Dim pos As Integer
    
    Set sb = New StringBuilder
    If RangeToUse Is Nothing Then
        AddText "% Error: No range selected.", True
        GoTo leave
    End If
    AddText Space(Indent) + "% Table generated by Excel2LaTeX from sheet '" + RangeToUse.Worksheet.Name + "'", True
    
    If tableFloat Then
        AddText Space(Indent) + "\begin{table}[htbp]", True
        Indent = Indent + 2
        AddText Space(Indent) + "\centering", True
        AddText Space(Indent) + "\caption{Add caption}", True
        Indent = Indent + 2
    End If
    
    AddText Space(Indent) + "\begin{tabular}{"
    AddText GetColumnsFormat(RangeToUse)
    AddText "}", True
      
    'Start checking top border
    Set r = RangeToUse.Rows(1)
    
    AddText HorizontalBorder(r, Indent, Top:=True)
    
    'Table contents:
    For j = 1 To RangeToUse.Rows.Count ' for each row
        Set r = RangeToUse.Rows(j)
        Set rc = r.Cells
        AddText Space(Indent)
        Indent = Indent + 2
    
        Dim RowColor&
        RowColor = GetRowColor(rc)
        If RowColor <> &HFFFFFF Then AddText Printf("\rowcolor[rgb]{%1} ", ColorToRGB(RowColor))
        For i = 1 To rc.Count  ' for each cell in row r
            Set c = rc.Item(i)
            i = i + AddCell(c, i = 1, i + c.MergeArea.Columns.Count > rc.Count, RowColor) - 1
        Next i 'cells in row
        
        ' Struts and end of line
        AddText Printf("%1\\", GetStruts(r)), True
        Indent = Indent - 2
        
        ' Check for Border lines
        AddText HorizontalBorder(r.Offset(RowOffset:=1), Indent, Bottom:=j = RangeToUse.Rows.Count)
    Next j 'row
    
theend:      'Tabellenende
    AddText Space(Indent) + "\end{tabular}%", True
    
    If tableFloat Then
        Indent = Indent - 2
        AddText Space(Indent) + "\label{tab:addlabel}%", True
        Indent = Indent - 2
        AddText Space(Indent) + "\end{table}%", True
    End If
    
leave:
    IModel_GetConversionResult = sb.ToString()
    
    ' Save to registry after successful conversion
    SaveToRegistry
End Function

Public Sub IModel_InitDefault()
    Indent = 0
    CellWidth = 5
    IModel_Options = x2lBooktabs Or x2lConvertMathChars Or x2lCreateTableEnvironment
    
    InitFromRegistry

    Set RangeToUse = GetDefaultRange
    sFileName = GetDefaultFileName
End Sub

Private Property Get IModel_Description() As String
    If RangeToUse Is Nothing Then
        IModel_Description = "(empty range)"
        Exit Property
    End If
    IModel_Description = Printf("%1: %2", Me.IModel_RangeAddress, Me.IModel_FileName)
End Property

Private Property Get IModel_Range() As Range
    Set IModel_Range = RangeToUse
End Property
Private Property Set IModel_Range(ByVal pRange As Range)
    Set RangeToUse = pRange.Areas(1)
    mpEvents.RaiseChanged
End Property

' Class implementation

Private Function GetRowColor(Row As Range) As Long
    GetRowColor = RangeOrDisplayFormat(Row).Interior.Color
    If GetRowColor <> 0 Then Exit Function
    GetRowColor = RangeOrDisplayFormat(Row.Cells(1, 1)).Interior.Color
End Function

Private Sub InitFromRegistry()
    On Error Resume Next
    StringToModel Me, VBA.GetSetting("Excel2LaTeX", "Main", "DefaultSettings")
End Sub

Private Sub SaveToRegistry()
    On Error Resume Next
    VBA.SaveSetting "Excel2LaTeX", "Main", "DefaultSettings", ModelToString(Me)
End Sub

Private Function WorksheetDir() As String
    If RangeToUse Is Nothing Then
        WorksheetDir = "."
        Exit Function
    End If
    
    WorksheetDir = RangeToUse.Worksheet.Parent.PATH
End Function

Private Function GetDefaultRange() As Range
    If Selection Is Nothing Then Exit Function
    If Not TypeOf Selection Is Range Then Exit Function
    If Selection.Count = 1 Then
        Set GetDefaultRange = Selection.CurrentRegion
    Else
        Set GetDefaultRange = Selection
    End If
End Function

Private Function GetDefaultFileName()
    Dim sName As String
    On Error Resume Next
    sName = ActiveSheet.Name
    sName = RangeToUse.Name.Name
    On Error GoTo 0
    GetDefaultFileName = Printf("%1.tex", sName)
End Function

Private Sub AddText(ByVal txt As String, Optional ByVal LineFeed = False)
    sb.Append txt
    If LineFeed Then sb.Append vbLf
End Sub

Private Function PadSpace(ByVal n As Long)
    PadSpace = Space(Application.WorksheetFunction.Max(0, n))
End Function

Private Function GetStruts(ByVal rRow As Range) As String
    Debug.Assert rRow.Rows.Count = 1
    
    ' No struts in booktabs mode
    If booktabs Then Exit Function
    
    Dim bHasTopBorder As Boolean
    Dim bHasBottomBorder As Boolean
    
    bHasTopBorder = HasHorizontalBorder(rRow)
    bHasBottomBorder = HasHorizontalBorder(rRow.Offset(RowOffset:=1))
    
    If bHasTopBorder Then
        If bHasBottomBorder Then
            GetStruts = "\bigstrut"
        Else
            GetStruts = "\bigstrut[t]"
        End If
    Else
        If bHasBottomBorder Then
            GetStruts = "\bigstrut[b]"
        End If
    End If
End Function

Private Function GetColumnsFormat(ByVal RangeToUse As Range, Optional ByVal bSkipFirst = False, Optional ByVal lStep As Long = 1) As String
    Dim rc As Range, c As Range, cn As Range
    
    Dim i As Long
    Dim stg As String
    
    Set rc = RangeToUse.Columns
    Set cn = rc.Item(1)
    
    If Not bSkipFirst Then
        stg = VerticalBorder(cn)
    End If
    
    For i = 1 To rc.Count Step lStep
        Set c = cn
        Set cn = Nothing
        On Error Resume Next
        Set cn = rc(i + lStep)
        On Error GoTo 0
        Dim HorizontalAlignment
        'get horizontal alignment using the last row of the table
        HorizontalAlignment = RangeOrDisplayFormat(c.Cells(c.Rows.Count, 1)).HorizontalAlignment
        If VarType(c.Cells(c.Rows.Count, 1).Value2) = vbString And c.Cells(c.Rows.Count, 1).WrapText Then
            If RangeToUse.MergeCells Then
                stg = stg + "p{" & LTrim$(Str$(0.5 * SumColumnWidths(RangeToUse))) & "em}"
            Else
                stg = stg + "p{" & LTrim$(Str$(0.5 * c.ColumnWidth)) & "em}"
            End If
        Else
            Select Case HorizontalAlignment
            Case xlLeft
                stg = stg + "l"
            Case xlCenter
                stg = stg + "c"
            Case xlGeneral
                stg = stg + IIf(VarType(c.Cells(c.Rows.Count, 1).Value2) = vbString, "l", "r")
            Case Else
                stg = stg + "r" 'Default alignment is right
            End Select
        End If
        If Not (cn Is Nothing) Then
            stg = stg + VerticalBorder(cn)
        End If
    Next i
    GetColumnsFormat = stg
End Function

Private Function SumColumnWidths(r As Range) As Double
    Dim col As Range
    For Each col In r
        SumColumnWidths = SumColumnWidths + col.ColumnWidth
    Next
End Function

Private Function VerticalBorder(ByVal pRightRange As Range)
    'return nothing, | or ||
    Dim stg As String
    Select Case VerticalBorderStyle(pRightRange)
    Case xlDouble
        stg = "||"
    Case xlContinuous
        stg = "|"
    Case Else
        stg = ""
    End Select
    VerticalBorder = stg
End Function

Private Function VerticalBorderStyle(ByVal pRightRange As Range) As Variant
    VerticalBorderStyle = xlNone
    
    Dim pRightRow As Range
    Dim pLeftRow As Range
    Set pRightRow = pRightRange.Cells(pRightRange.Rows.Count, 1)
    VerticalBorderStyle = ResolveLine(VerticalBorderStyle, RangeOrDisplayFormat(pRightRow).Borders(xlLeft).LineStyle)
    
    If pRightRow.Column > 1 Then
        Set pLeftRow = pRightRow.Resize(ColumnSize:=1).Offset(ColumnOffset:=-1)
        
        VerticalBorderStyle = ResolveLine(VerticalBorderStyle, RangeOrDisplayFormat(pLeftRow).Borders(xlRight).LineStyle)
    End If
End Function

Private Function HasHorizontalBorder(ByVal rBelowRange As Range) As Boolean
    HasHorizontalBorder = (HorizontalBorder(rBelowRange, 0) <> "")
End Function

Private Function HorizontalBorder(ByVal rBelowRange As Range, ByVal spaces As Integer, Optional ByVal Top As Boolean, Optional ByVal Bottom As Boolean) As String
    Debug.Assert rBelowRange.Rows.Count = 1
    
    Dim rAboveRange As Range
    If rBelowRange.Row > 1 Then
        Set rAboveRange = rBelowRange.Offset(RowOffset:=-1)
    End If
    
    Dim sRangeDef As String
    Dim lLineOpenFrom As Long
    Dim bOpenLine As Boolean
    Dim borderStyle As Variant
    
    Dim rBelowColumn As Range
    Dim rAboveColumn As Range
    For Each rBelowColumn In rBelowRange.Columns
        If Not rAboveRange Is Nothing Then
            Set rAboveColumn = rAboveRange.Columns(rBelowColumn.Column - rBelowRange.Column + 1)
        End If
        
        If Not IsFirstRowOfMultiRowCell(rBelowColumn) Then
            bOpenLine = False
        Else
            borderStyle = ResolveHorizontalLine(rBelowColumn, rAboveColumn)
            bOpenLine = (borderStyle <> xlNone)
        End If
        
        AppendToRangeSet sRangeDef, lLineOpenFrom, bOpenLine, rBelowColumn.Column - rBelowRange.Column + 1
    Next
    
    AppendToRangeSet sRangeDef, lLineOpenFrom, False, rBelowRange.Columns.Count + 1
    
    Dim HLineCmd$, CLineCmd$, MoreCLineCmd$
    If booktabs Then
        If Top Then
            HLineCmd = "\toprule"
        ElseIf Bottom Then
            HLineCmd = "\bottomrule"
        Else
            HLineCmd = "\midrule"
        End If
    Else
        HLineCmd = "\hline"
    End If
    CLineCmd = IIf(booktabs, "\cmidrule", "\cline")
    MoreCLineCmd = IIf(booktabs, "\morecmidrules", "")
    
    ' Straight line? => revert to old behavior
    If sRangeDef = Printf("1-%1", rBelowRange.Columns.Count) Then
        'return nothing, \hline or \hline\hline
        borderStyle = ResolveHorizontalLine(rBelowRange, rAboveRange)
    
        Select Case borderStyle
        Case xlDouble
            HorizontalBorder = Space(spaces) + HLineCmd + vbLf + Space(spaces) + HLineCmd + vbLf
        Case xlContinuous
            HorizontalBorder = Space(spaces) + HLineCmd + vbLf
        Case Else
            HorizontalBorder = ""
        End Select
    ElseIf sRangeDef = "" Then
        HorizontalBorder = ""
    Else
        HorizontalBorder = Printf(CLineCmd + "{%1}", Replace(sRangeDef, ";", "}" + CLineCmd + "{"))
    End If
End Function

Public Sub AppendToRangeSet(ByRef sRangeDef As String, ByRef lLineOpenFrom As Long, ByVal bOpenLine As Boolean, ByVal lCurrentPos As Long)
    If bOpenLine Then
        If lLineOpenFrom <= 0 Then
            lLineOpenFrom = lCurrentPos
            sRangeDef = Printf("%1%3%2", sRangeDef, lCurrentPos, IIf(sRangeDef = "", "", ";"))
        End If
    Else
        If lLineOpenFrom > 0 Then
            sRangeDef = Printf("%1-%2", sRangeDef, lCurrentPos - 1)
            lLineOpenFrom = 0
        End If
    End If
End Sub

Private Function ResolveHorizontalLine(ByVal rBelowRange As Range, ByVal rAboveRange As Range)
    ResolveHorizontalLine = RangeOrDisplayFormat(rBelowRange).Borders(xlTop).LineStyle
    If rAboveRange Is Nothing Then Exit Function
    ResolveHorizontalLine = ResolveLine(ResolveHorizontalLine, RangeOrDisplayFormat(rAboveRange).Borders(xlBottom).LineStyle)
End Function

Private Function ResolveLine(ByVal line1, ByVal line2)
    ResolveLine = xlNone
    If line1 = xlContinuous Or line2 = xlContinuous Then ResolveLine = xlContinuous
    If line1 = xlDouble Or line2 = xlDouble Then ResolveLine = xlDouble
End Function

Private Function AddCell(ByVal rCell As Range, ByVal bFirstCell As Boolean, ByVal bLastCell As Boolean, ByVal RowColor&) As Long
    Dim txt As String
    Dim nColumns As Long
    Dim nRows As Long
    
    txt = FormatCell(rCell, RowColor)
    
    Dim bRequiresDifferentVlineFormat As Boolean
    bRequiresDifferentVlineFormat = RequiresDifferentVlineFormat(rCell)
    
    'Check for multicolumns
    If rCell.MergeCells Or bRequiresDifferentVlineFormat Then   'multicolumn cell
        With rCell.MergeArea
            nColumns = .Columns.Count
            nRows = .Rows.Count
        End With
        
        If nRows > 1 Then
            ' Add contents only for first row of a multi-row cell
            If IsFirstRowOfMultiRowCell(rCell) Then
                txt = Printf("\multirow{%1}[%3]{*}{%2}", nRows, txt, GetMultiRowStruts(rCell))
            Else
                txt = ""
            End If
        End If
        If (nColumns > 1) Or bRequiresDifferentVlineFormat Then
            txt = Printf("\multicolumn{%1}{%2}{%3}", _
                nColumns, _
                GetColumnsFormat(rCell.MergeArea, Not bFirstCell, rCell.MergeArea.Columns.Count), _
                txt)
        End If
    Else 'single cell
        nColumns = 1
        nRows = 1
    End If
    
    AddText txt
    If Not bLastCell Then
        If CellWidth > 0 Then
            AddText PadSpace(nColumns * (3 + CellWidth) - 3 - Len(txt))
        End If
        AddText " &"
    End If
    If CellWidth > 0 Then
        AddText " "
    Else
        AddText vbLf & Space(Indent)
    End If
    
    AddCell = nColumns
End Function

Private Function FormatCell(ByVal rCell As Range, ByVal RowColor&) As String
    FormatCell = rCell.Text
    
    If Len(FormatCell) > 0 Then
        FormatCell = ConvertSpecialChars(FormatCell, isnumeric(rCell.Value2))
        FormatCell = FormatCellFont(FormatCell, rCell)
        FormatCell = FormatCellOrientation(FormatCell, rCell)
    End If
    FormatCell = FormatCellColor(FormatCell, rCell, RowColor)
End Function

Private Function FormatCellColor(Text$, Cell As Range, ByVal RowColor&) As String
    Dim FontColor&, InteriorColor&
    FontColor = ZeroIfNull(RangeOrDisplayFormat(cell).Font.Color)
    InteriorColor = RangeOrDisplayFormat(cell).Interior.Color
    
    If FontColor = 0 Then
        FormatCellColor = Text
    Else
        FormatCellColor = Printf("\textcolor[rgb]{%1}{%2}", ColorToRGB(FontColor), Text)
    End If
    
    If InteriorColor <> RowColor Then FormatCellColor = Printf("\cellcolor[rgb]{%1}", _
            ColorToRGB(InteriorColor)) & FormatCellColor
End Function

Private Function ColorToRGB(ByVal Color&) As String
    ColorToRGB = Printf("%1, %2, %3", Str$(Round((Color And &HFF&) / 255, 3)), _
                Str$(Round((Color And &HFF00&) / &H100 / 255, 3)), _
                Str$(Round((Color And &HFF0000) / &H10000 / 255, 3)))
End Function

Private Function ConvertSpecialChars(ByVal sText As String, ByVal Number As Boolean) As String
    ConvertSpecialChars = sText
    
    'Check for special characters - always convert if numeric
    If convertDollar Or Number Then
        ConvertSpecialChars = Replace(ConvertSpecialChars, "\", "\textbackslash{}")
        ConvertSpecialChars = Replace(ConvertSpecialChars, "$", "\$")
        ConvertSpecialChars = Replace(ConvertSpecialChars, "_", "\_")
        ConvertSpecialChars = Replace(ConvertSpecialChars, "^", "\^")
    End If
    ConvertSpecialChars = Replace(ConvertSpecialChars, "%", "\%")
    ConvertSpecialChars = Replace(ConvertSpecialChars, "&", "\&")
    ConvertSpecialChars = Replace(ConvertSpecialChars, "#", "\#")
    ConvertSpecialChars = Replace$(ConvertSpecialChars, vbLf, "\newline{}")
End Function

Private Function FormatCellFont(ByVal sText As String, ByVal rCell As Range) As String
    Dim pFont As Font
    Set pFont = RangeOrDisplayFormat(rCell).Font
    
    FormatCellFont = sText
    
    'Check for Font Styles
    If pFont.Bold Then FormatCellFont = Printf("\textbf{%1}", FormatCellFont)
    If pFont.Italic Then FormatCellFont = Printf("\textit{%1}", FormatCellFont)
    
    'Typeset math in bold if required
    If Not pFont.Bold Then
    ElseIf convertDollar Then
    ElseIf InStr(1, FormatCellFont, "$") > 0 Then
        FormatCellFont = Printf("\boldmath{}%1\unboldmath{}", FormatCellFont)
    End If
End Function

Private Function FormatCellOrientation(ByVal sText As String, ByVal rCell As Range) As String
    ' Requires "rotating" package
    FormatCellOrientation = sText
    
    Dim Orientation
    Orientation = RangeOrDisplayFormat(rCell).Orientation
    
    ' Check for orientation
    Select Case Orientation
    Case xlHorizontal
        ' Do nothing
        
    Case xlUpward
        FormatCellOrientation = Printf("\begin{sideways}%1\end{sideways}", FormatCellOrientation)
        
    Case xlDownward
        FormatCellOrientation = Printf("\begin{turn}{-90}%1\end{turn}", FormatCellOrientation)
        
    Case Else
        FormatCellOrientation = Printf("\begin{turn}{%2}%1\end{turn}", FormatCellOrientation, rCell.Orientation)
    
    End Select
End Function

Private Function RequiresDifferentVlineFormat(ByVal rCell As Range) As Boolean
    Dim sColumnFormat As String
    Dim sCellFormat As String
    
    Dim lRelativeColumn As Long
    lRelativeColumn = GetRelativeColumn(rCell)
    
    Dim rColumn As Range
    Set rColumn = RangeToUse.Columns(lRelativeColumn)
    
    sColumnFormat = GetColumnsFormat(rColumn, lRelativeColumn > 1, rCell.MergeArea.Columns.Count)
    sCellFormat = GetColumnsFormat(rCell, lRelativeColumn > 1, rCell.MergeArea.Columns.Count)
    
    If IsEmpty(rCell.Value2) Then
        ' if the cell is empty, ignore alignment changes and only change the vline format
        ' if a vline was added or removed
        RequiresDifferentVlineFormat = (Len(sColumnFormat) <> Len(sCellFormat))
    Else
        RequiresDifferentVlineFormat = (sColumnFormat <> sCellFormat)
    End If
End Function

Private Function GetRelativeColumn(ByVal rCell As Range) As Long
    GetRelativeColumn = rCell.Column - RangeToUse.Column + 1
End Function

Private Function GetRelativeRow(ByVal rCell As Range) As Long
    GetRelativeRow = rCell.Row - RangeToUse.Row + 1
End Function

Function IsFirstRowOfMultiRowCell(ByVal rCell As Range) As Boolean
    IsFirstRowOfMultiRowCell = (rCell.Row = rCell.MergeArea.Row)
End Function

Function GetMultiRowStruts(ByVal rCell As Range) As Long
    Dim lStartRow As Long
    Dim lEndRow As Long
    Dim lRow As Long
    Dim bBorder As Boolean
    
    lStartRow = GetRelativeRow(rCell)
    lEndRow = lStartRow + rCell.MergeArea.Rows.Count
    
    For lRow = lStartRow To lEndRow
        bBorder = HasHorizontalBorder(RangeToUse.Rows(lRow))
        
        ' First and last horizontal lines account for one strut,
        ' the others account for two struts each:
        If bBorder Then
            GetMultiRowStruts = GetMultiRowStruts + 1
            If (lRow > lStartRow) And (lRow < lEndRow) Then
                GetMultiRowStruts = GetMultiRowStruts + 1
            End If
        End If
    Next
End Function

#If VBA7 Then
' under Excel 2010+, RangeOrDisplayFormat() returns a DisplayFormat,
' so we can see conditional formatting
Private Function RangeOrDisplayFormat(cell As Range) As DisplayFormat
    Set RangeOrDisplayFormat = cell.DisplayFormat
End Function
#ElseIf Mac Then
' VBA7 isn't supported in Excel 2011 and 2016 for Mac, so need to
' actually check against Application.Version on that platform
Private Function RangeOrDisplayFormat(cell As Range) As Object
    If Val(Application.Version) >= 14# Then
        Set RangeOrDisplayFormat = cell.DisplayFormat
    Else
        Set RangeOrDisplayFormat = cell
    End If
End Function
#Else
' under Excel 2007 and earlier, DisplayFormat is not supported, so
' RangeOrDisplayFormat() just gives back the range it was passed
Private Function RangeOrDisplayFormat(cell As Range) As Range
    Set RangeOrDisplayFormat = cell
End Function
#End If

Private Function ZeroIfNull(v) As Long
    If Not IsNull(v) Then
        If isnumeric(v) Then
            ZeroIfNull = CLng(v)
        End If
    End If
End Function
Attribute VB_Name = "CSheetStorage"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Implements IStorage

Private mpEvents As New IStorageEvents

Private Const MAX_DIM = 10000


Private Property Get IStorage_Events() As IStorageEvents
    Set IStorage_Events = mpEvents
End Property

Private Function IStorage_Add(ByVal pModel As IModel, Optional ByVal lIndex = -1) As Long
    Dim lFreeRow As Long
    If lIndex < 0 Then
        lFreeRow = GetFreeRowIndex
    Else
        lFreeRow = lIndex + 2
        GetStorageSheet().Rows(lFreeRow).Insert xlShiftDown
    End If
    
    Dim rRow As Range
    Set rRow = GetStorageSheet().Rows(lFreeRow)
    
    Dim cColumns As Collection
    Set cColumns = GetColumnList()
    
    Dim cValues As Collection
    Set cValues = ModelToCollection(pModel)
    
    Dim sKey As Variant
    Dim lColumnIndex As Long
    For Each sKey In ModelPropertyNames()
        On Error Resume Next
        lColumnIndex = -1
        lColumnIndex = cColumns(sKey)
        On Error GoTo 0
        
        If lColumnIndex < 0 Then lColumnIndex = CreateColumn(sKey)
        Debug.Assert lColumnIndex > 0
        
        If sKey = "RangeAddress" Then
            AddressToFormula cValues(sKey), rRow.Cells(1, lColumnIndex)
        Else
            rRow.Cells(1, lColumnIndex) = cValues(sKey)
        End If
    Next
    
    IStorage_Add = lFreeRow - 1
    
    mpEvents.RaiseChanged
End Function

Private Sub IStorage_Remove(ByVal lIndex As Long)
    Dim rRow As Range
    Set rRow = GetStorageSheet().Rows(lIndex + 1)
    rRow.Delete xlShiftUp
    
    mpEvents.RaiseChanged
End Sub

Private Function IStorage_GetItems() As Collection
    Set IStorage_GetItems = New Collection
    
    Dim pStorageSheet As Worksheet
    Set pStorageSheet = GetStorageSheet(False)
    
    If pStorageSheet Is Nothing Then Exit Function

    Dim cColumns As Collection
    Dim cKeys As Collection
    Set cColumns = GetColumnList(cKeys)
    
    Dim cRow As Collection
    Dim lRow As Long
    Dim lColumn As Variant
    Dim sKey As String, sValue As String
    Dim rRow As Range
    For lRow = 2 To MAX_DIM
        Set rRow = pStorageSheet.Rows(lRow)
        If Application.WorksheetFunction.CountA(rRow) = 0 Then Exit For
        Set cRow = New Collection
        
        For Each lColumn In cColumns
            sKey = cKeys(lColumn)
            If sKey = "RangeAddress" Then
                sValue = FormulaToAddress(rRow.Cells(ColumnIndex:=lColumn))
            Else
                sValue = rRow.Cells(ColumnIndex:=lColumn)
            End If
            cRow.Add sValue, sKey
        Next
        
        IStorage_GetItems.Add CollectionToNewModel(cRow)
        Set cRow = Nothing
    Next
End Function



Private Sub AddressToFormula(ByVal sAddress As String, ByVal rCell As Range)
    rCell.Formula = Printf("=COUNT(%1)", sAddress)
End Sub
Private Function FormulaToAddress(ByVal rCell As Range) As String
    On Error Resume Next
    FormulaToAddress = Mid(rCell.Formula, 8, Len(rCell.Formula) - 8)
End Function

Private Function GetStorageSheet(Optional ByVal bCreate As Boolean = True) As Worksheet
    On Error Resume Next
    With ActiveWorkbook.Worksheets
        Set GetStorageSheet = .Item("Excel2LaTeX")
        If (Err.Number <> 0) And bCreate Then
            On Error GoTo 0
            Set GetStorageSheet = .Add
            GetStorageSheet.Name = "Excel2LaTeX"
            GetStorageSheet.Visible = xlSheetHidden
        End If
    End With
End Function

Private Function GetColumnList(Optional ByRef cNameList As Collection) As Collection
    Set GetColumnList = New Collection
    Set cNameList = New Collection
    
    Dim pStorageSheet As Worksheet
    Set pStorageSheet = GetStorageSheet(False)
    
    If pStorageSheet Is Nothing Then Exit Function
    
    Dim pFirstRow As Range
    Set pFirstRow = pStorageSheet.Rows(1)
    
    Dim l1 As Long
    Dim sName As String
    For l1 = 1 To MAX_DIM
        sName = pFirstRow.Cells(ColumnIndex:=l1)
        If sName = "" Then Exit For
        GetColumnList.Add l1, sName
        cNameList.Add sName
    Next
End Function

Private Function GetFreeRowIndex() As Long
    Dim pStorageSheet As Worksheet
    Set pStorageSheet = GetStorageSheet()
    
    Dim pFirstColumn As Range
    Set pFirstColumn = pStorageSheet.Columns(1)
    
    Dim l1 As Long
    Dim sValue As String
    For l1 = 2 To MAX_DIM
        sValue = pFirstColumn.Cells(RowIndex:=l1)
        If sValue = "" Then
            GetFreeRowIndex = l1
            Exit Function
        End If
    Next
End Function

Private Function GetFreeColumnIndex() As Long
    Dim pStorageSheet As Worksheet
    Set pStorageSheet = GetStorageSheet()
    
    Dim pFirstRow As Range
    Set pFirstRow = pStorageSheet.Rows(1)
    
    Dim l1 As Long
    Dim sValue As String
    For l1 = 1 To MAX_DIM
        sValue = pFirstRow.Cells(ColumnIndex:=l1)
        If sValue = "" Then
            GetFreeColumnIndex = l1
            Exit Function
        End If
    Next
End Function

Private Function CreateColumn(ByVal sName As String) As Long
    CreateColumn = GetFreeColumnIndex()
    
    Dim pStorageSheet As Worksheet
    Set pStorageSheet = GetStorageSheet()
    
    pStorageSheet.Cells(1, CreateColumn) = sName
End Function
Attribute VB_Name = "CVolatileStorage"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Implements IStorage

Private mCollection As New Collection

Private mpEvents As New IStorageEvents


Private Property Get IStorage_Events() As IStorageEvents
    Set IStorage_Events = mpEvents
End Property

Private Function IStorage_Add(ByVal pModel As IModel, Optional ByVal lIndex = -1) As Long
    IStorage_Add = mCollection.Count + 1
    If (lIndex < 0) Or (mCollection.Count = 0) Then
        mCollection.Add ModelToString(pModel)
    ElseIf lIndex = 0 Then
        mCollection.Add ModelToString(pModel), Before:=1
    Else
        mCollection.Add ModelToString(pModel), After:=lIndex
    End If
    mpEvents.RaiseChanged
End Function

Private Sub IStorage_Remove(ByVal lIndex As Long)
    mCollection.Remove lIndex
    mpEvents.RaiseChanged
End Sub

Private Function IStorage_GetItems() As Collection
    Set IStorage_GetItems = New Collection
    
    Dim sModel As Variant
    For Each sModel In mCollection
        IStorage_GetItems.Add StringToNewModel(sModel)
    Next
End Function
Attribute VB_Name = "Conversion"
' Excel2LaTeX: The Excel add-in for creating LaTeX tables
'
' Converts the selected cells to a LaTeX table, that can be included in a .tex file
' via \input{"table.tex"} or that can be copied to the clipboard. Most of the formatting
' is converted too. You can put additional LaTeX code in the cells, which will remain
' untouched by the converter.
'
' Copyright (c) 1996|fffd|2016 Chelsea Hughes, Kirill M|fffd|ller, Andrew Hawryluk, Germ|fffd|n Ria|fffd|o,
' and Joachim Marder.
'
' This work is distributed under the LaTeX Project Public License, version 1.3 or later,
' available at http://www.latex-project.org/lppl.txt
'
' Chelsea Hughes currently maintains this project (comprising Excel2LaTeX.xla and
' README.md) and will receive error reports at the project GitHub page,
' https://github.com/krlmlr/Excel2LaTeX

Option Explicit

Sub LaTeX()
Attribute LaTeX.VB_Description = "Opens the main dialog for converting into LaTeX"
Attribute LaTeX.VB_ProcData.VB_Invoke_Func = "l\n14"
    With NewController
        Set .View = NewView
        Set .Model = NewDefaultModel
        Set .Storage = NewStorage
        .Run
    End With
End Sub

Sub LaTeXAllToFiles()
Attribute LaTeXAllToFiles.VB_Description = "Converts all configured selections into LaTeX"
Attribute LaTeXAllToFiles.VB_ProcData.VB_Invoke_Func = "l\n14"
    SaveAllStoredItems NewStorage
End Sub
Attribute VB_Name = "Factory"
Option Explicit

Public Function NewController() As IController
    Set NewController = New CController
End Function

Public Function NewModel() As IModel
    Set NewModel = New CModel
End Function

Public Function NewDefaultModel() As IModel
    Set NewDefaultModel = NewModel
    NewDefaultModel.InitDefault
End Function

Public Function NewView() As frmConvert
    Set NewView = New frmConvert
End Function

Function NewStorage() As IStorage
    Set NewStorage = New CSheetStorage
End Function
Attribute VB_Name = "IController"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Property Get Events() As IControllerEvents
'
End Property

Public Property Get Model() As IModel
'
End Property
Public Property Set Model(ByVal pModel As IModel)
'
End Property

Public Property Get View() As IView
'
End Property
Public Property Set View(ByVal pView As IView)
'
End Property

Public Property Get Storage() As IStorage
'
End Property
Public Property Set Storage(ByVal pStorage As IStorage)
'
End Property

Public Sub Run()
'
End Sub
Attribute VB_Name = "IControllerEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event ModelChanged()

Public Sub RaiseModelChanged()
    RaiseEvent ModelChanged
End Sub
Attribute VB_Name = "IModel"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum x2lOptions
    x2lNone = &H0
    
    x2lCreateTableEnvironment = &H1
    x2lBooktabs = &H2
    x2lConvertMathChars = &H4
End Enum

Public Property Get Events() As IModelEvents
'
End Property

Public Property Get Options() As x2lOptions
'
End Property
Public Property Let Options(ByVal Options As x2lOptions)
'
End Property

Public Property Get Indent() As Integer
'
End Property
Public Property Let Indent(ByVal Indent As Integer)
'
End Property

Public Property Get CellWidth() As Integer
'
End Property
Public Property Let CellWidth(ByVal CellWidth As Integer)
'
End Property

Public Property Get FileName() As String
'
End Property
Public Property Let FileName(ByVal FileName As String)
'
End Property
Public Property Get AbsoluteFileName() As String
'
End Property

Public Property Get RangeAddress() As String
'
End Property
Public Property Let RangeAddress(ByVal iRange As String)
'
End Property

Public Function GetConversionResult() As String
'
End Function

Public Sub InitDefault()
'
End Sub

Public Property Get Description() As String
'
End Property

Public Property Get Range() As Range
'
End Property
Public Property Set Range(ByVal pRange As Range)
'
End Property
Attribute VB_Name = "IModelEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event Changed()

Public Sub RaiseChanged()
    RaiseEvent Changed
End Sub
Attribute VB_Name = "IStorage"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Property Get Events() As IStorageEvents
'
End Property

Public Function Add(ByVal pModel As IModel, Optional ByVal lIndex = -1) As Long
'
End Function

Public Sub Remove(ByVal lIndex As Long)
'
End Sub

Public Function GetItems() As Collection
'
End Function
Attribute VB_Name = "IStorageEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event Changed()

Public Sub RaiseChanged()
    RaiseEvent Changed
End Sub
Attribute VB_Name = "IView"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Property Get Controller() As IController
'
End Property
Public Property Set Controller(ByVal pController As IController)
'
End Property

Public Property Get Storage() As IStorage
'
End Property
Public Property Set Storage(ByVal pStorage As IStorage)
'
End Property

Public Sub Show(ByVal Modal As FormShowConstants)
'
End Sub
Attribute VB_Name = "Memento"
Option Explicit

Public Function ModelPropertyNames() As String()
    Const NAMES As String = "RangeAddress|Options|CellWidth|Indent|FileName"
    ModelPropertyNames = Split(NAMES, "|")
End Function

Public Function ModelToCollection(ByVal pModel As IModel) As Collection
    Set ModelToCollection = New Collection
    
    Dim sName As Variant
    For Each sName In ModelPropertyNames()
        ModelToCollection.Add CallByName(pModel, sName, VbGet), sName
    Next
End Function

Public Function ModelToString(ByVal pModel As IModel) As String
    Dim sName As Variant
    For Each sName In ModelPropertyNames()
        ModelToString = ModelToString & Printf("%1=%2;", sName, CallByName(pModel, sName, VbGet))
    Next
End Function

Public Sub CollectionToModel(ByVal pModel As IModel, ByVal pCollection As Collection)
    Dim sName As Variant
    For Each sName In ModelPropertyNames()
        On Error Resume Next
        CallByName pModel, sName, VbLet, pCollection(sName)
        On Error GoTo 0
    Next
End Sub


Public Sub StringToModel(ByVal pModel As IModel, ByVal sSettings As String)
    Dim aSettings() As String
    aSettings = Split(sSettings, ";")
    
    Dim l1 As Long
    Dim sKey As String
    Dim sValue As String
    For l1 = 0 To UBound(aSettings)
        SplitKeyValue aSettings(l1), sKey, sValue
        
        On Error Resume Next
        CallByName pModel, sKey, VbLet, sValue
        On Error GoTo 0
    Next
End Sub

Public Function CollectionToNewModel(ByVal pSettings As Collection) As IModel
    Set CollectionToNewModel = NewModel()
    CollectionToModel CollectionToNewModel, pSettings
End Function
Public Function StringToNewModel(ByVal sSettings As String) As IModel
    Set StringToNewModel = NewModel()
    StringToModel StringToNewModel, sSettings
End Function


Public Function RangeToAddress(ByVal pRange As Range) As String
    If pRange Is Nothing Then Exit Function
    RangeToAddress = Printf("'%1'!%2", pRange.Worksheet.Name, pRange.Address)
End Function

Public Function AddressToRange(ByVal sRangeAddress As String) As Range
    Set AddressToRange = Nothing
    If sRangeAddress = "" Then Exit Function
    Set AddressToRange = Application.Range(sRangeAddress)
End Function

Public Sub SaveConversionResultToFile(ByVal pModel As IModel)
    Dim sFileName As String
    sFileName = pModel.AbsoluteFileName
    If sFileName = "" Then Exit Sub
    
    Open sFileName For Output As 1
    Print #1, pModel.GetConversionResult;
    Close #1
End Sub

Public Sub SaveAllStoredItems(ByVal pStorage As IStorage)
    Dim l1 As Long
    Dim cItems As Collection
    Set cItems = pStorage.GetItems
    
    For l1 = 1 To cItems.Count
        SaveConversionResultToFile cItems(l1)
    Next
End Sub
Attribute VB_Name = "StringBuilder"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const INITIAL_SIZE = 16&

Private m_buf As String 'current buffer
Private m_len As Long 'size in characters

Private Sub Class_Initialize()
    m_buf = Space$(INITIAL_SIZE)
End Sub

Public Property Get Length() As Long
    Length = m_len
End Property

Public Function Append(s As String) As StringBuilder
    If m_len + Len(s) > 2 * Len(m_buf) Then
        m_buf = m_buf & Space$(2 * Len(s))
    ElseIf m_len + Len(s) > Len(m_buf) Then
        m_buf = m_buf & Space$(Len(m_buf))
    End If
    If Len(s) > 0 Then
        Mid(m_buf, m_len + 1, Len(s)) = s
        m_len = m_len + Len(s)
    End If
    
    Set Append = Me
End Function

Public Function ToString() As String
    ToString = Left$(m_buf, m_len)
End Function
Attribute VB_Name = "Test"
Option Explicit

Private Sub Test_VolatileStorage()
    Test_Storage New CVolatileStorage
End Sub

Private Sub Test_SheetStorage()
    On Error Resume Next
    With ActiveWorkbook.Sheets("Excel2LaTeX")
        .Range.Clear
        .Delete
    End With
    On Error GoTo 0
    Test_Storage New CSheetStorage
End Sub

Private Sub Test_Storage(ByVal pStorage As IStorage)
    Dim lIndex As Long
    lIndex = pStorage.Add(NewDefaultModel())
    Debug.Assert lIndex = 1
    
    Dim pModel As IModel
    Set pModel = NewDefaultModel
    pModel.CellWidth = pModel.CellWidth + 1
    Dim lIndex2 As Long
    lIndex2 = pStorage.Add(pModel)
    Debug.Assert lIndex <> lIndex2
    
    pStorage.Remove lIndex
    Debug.Assert pStorage.GetItems.Count = 1
    
    Debug.Assert pStorage.GetItems.Count = 1
    Debug.Assert pStorage.GetItems.Item(1).CellWidth = NewDefaultModel().CellWidth + 1
    
    pStorage.Add NewDefaultModel, 0
    Debug.Assert pStorage.GetItems.Item(2).CellWidth = NewDefaultModel().CellWidth + 1
    pStorage.Add NewDefaultModel, 2
    Debug.Assert pStorage.GetItems.Item(2).CellWidth = NewDefaultModel().CellWidth + 1
    pStorage.Add NewDefaultModel, 1
    Debug.Assert pStorage.GetItems.Item(3).CellWidth = NewDefaultModel().CellWidth + 1
    pStorage.Add NewDefaultModel, pStorage.GetItems.Count
    Debug.Assert pStorage.GetItems.Count = 5
    
    pStorage.Remove 1
    pStorage.Remove 2
    pStorage.Remove 3
    pStorage.Remove 2
    pStorage.Remove 1
    Debug.Assert pStorage.GetItems.Count = 0
End Sub

Private Sub Test_Model_AppendToRangeSet()
    Dim pModel As New CModel
    
    Dim sLineDef As String
    Dim lLineOpenFrom As Long
    
    pModel.AppendToRangeSet sLineDef, lLineOpenFrom, True, 1
    Debug.Assert sLineDef = "1"
    pModel.AppendToRangeSet sLineDef, lLineOpenFrom, False, 2
    Debug.Assert sLineDef = "1-1"
    pModel.AppendToRangeSet sLineDef, lLineOpenFrom, False, 3
    Debug.Assert sLineDef = "1-1"
    pModel.AppendToRangeSet sLineDef, lLineOpenFrom, True, 4
    Debug.Assert sLineDef = "1-1;4"
    pModel.AppendToRangeSet sLineDef, lLineOpenFrom, True, 5
    Debug.Assert sLineDef = "1-1;4"
    pModel.AppendToRangeSet sLineDef, lLineOpenFrom, False, 6
    Debug.Assert sLineDef = "1-1;4-5"
End Sub

Private Sub Test_StringBuilder()
    Dim sb As StringBuilder
    Set sb = New StringBuilder
    Debug.Assert Len(sb.ToString()) = 0
    sb.Append("This ").Append("is ").Append("a ").Append("test ").Append("of ").Append "the "
    sb.Append("StringBuilder's ").Append("incremental ").Append("expansion ").Append "ability."
    Debug.Assert sb.ToString() = "This is a test of the StringBuilder's incremental expansion ability."
    sb.Append vbNullString
    sb.Append ""
    Debug.Assert sb.ToString() = "This is a test of the StringBuilder's incremental expansion ability."
    sb.Append " "
    sb.Append "Now I'm adding a very long string to test that StringBuilder correctly handles strings that are " & _
            "more than double the length of the current buffer. Godspeed, StringBuilder! Lorem ipsum dolor sit " & _
            "amet, consectetur adipiscing elit. Suspendisse hendrerit lectus ligula, sodales rhoncus nunc " & _
            "porttitor vitae. Integer commodo vestibulum suscipit. Donec ultrices tellus ac tincidunt condimentum."
    Debug.Assert sb.ToString() = "This is a test of the StringBuilder's incremental expansion ability. " & _
            "Now I'm adding a very long string to test that StringBuilder correctly handles strings that are " & _
            "more than double the length of the current buffer. Godspeed, StringBuilder! Lorem ipsum dolor sit " & _
            "amet, consectetur adipiscing elit. Suspendisse hendrerit lectus ligula, sodales rhoncus nunc " & _
            "porttitor vitae. Integer commodo vestibulum suscipit. Donec ultrices tellus ac tincidunt condimentum."
    Set sb = New StringBuilder
    Debug.Assert sb.Append("This is a test of adding a big string to StringBuilder up-front. Will it choke? " & _
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse hendrerit lectus ligula, " & _
            "sodales rhoncus nunc porttitor vitae. Integer commodo vestibulum suscipit. Donec ultrices tellus " & _
            "ac tincidunt condimentum. Etiam volutpat ligula ipsum, a commodo neque tempor vitae. Vestibulum a " & _
            "cursus nisl. Interdum et malesuada fames ac ante ipsum primis in faucibus.").ToString() = _
            "This is a test of adding a big string to StringBuilder up-front. Will it choke? " & _
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse hendrerit lectus ligula, " & _
            "sodales rhoncus nunc porttitor vitae. Integer commodo vestibulum suscipit. Donec ultrices tellus " & _
            "ac tincidunt condimentum. Etiam volutpat ligula ipsum, a commodo neque tempor vitae. Vestibulum a " & _
            "cursus nisl. Interdum et malesuada fames ac ante ipsum primis in faucibus."
End Sub
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
    CreateMenuItems
End Sub

Private Sub CreateMenuItem(ByVal Caption As String, ByVal Action As String, ByVal FaceID As Long)
    Dim myMenubar As CommandBar, toolsMenu As CommandBarPopup, newMenuItem As CommandBarControl
    Set myMenubar = Application.CommandBars("Worksheet Menu Bar")
    Set toolsMenu = myMenubar.Controls(6)
    Set newMenuItem = myMenubar.FindControl(Tag:=Action, Recursive:=True)
    If Not newMenuItem Is Nothing Then newMenuItem.Delete
    Set newMenuItem = toolsMenu.Controls.Add(Type:=msoControlButton, Before:=3, Temporary:=True)
    newMenuItem.Tag = Action
    newMenuItem.OnAction = Action
    newMenuItem.FaceID = FaceID
    newMenuItem.TooltipText = Caption
    newMenuItem.Caption = Caption
End Sub

Private Sub CreateMenuItems()
    #If Mac Then
        ' on Excel 2016 Mac, we can't manipulate menus
        If Val(Application.Version) >= 15 Then Exit Sub
    #End If
    CreateMenuItem "Con&vert Table to LaTeX", "Conversion.LaTeX", 8
    CreateMenuItem "Convert All Stored Tab&les to LaTeX", "Conversion.LaTeXAllToFiles", 107
    If Val(Application.Version) >= 12 Then
        ' don't show the toolbar on Excel 2007+, since it just shows up as duplicated buttons in the ribbon
        If FindCommandBar("Excel2LaTeX") > 0 Then Application.CommandBars("Excel2LaTeX").Delete
    End If
End Sub

Private Function FindCommandBar(ByVal Name As String)
    Dim i As Long
    For i = 1 To Application.CommandBars.Count
        If Application.CommandBars(i).Name = Name Then
            FindCommandBar = i
            Exit Function
        End If
    Next
End Function
Attribute VB_Name = "Tools"
Option Explicit

Public Function Printf(ByVal sFormat As String, ParamArray Values()) As String
    Dim lValuesUBound As Long
    Dim sResult As String
    Dim vElement As Variant
    Dim lText As Long
    Dim aText() As String
    Dim sFirstChar As String
    Dim lValuePos As Long
    Dim sCurrentValue As String
    
    If IsMissing(Values()) Then
        lValuesUBound = -1
    Else
        lValuesUBound = UBound(Values)
    End If
    
    ' Handle all tokens:
    aText = Split(sFormat, "%")
    
    ' First entry of aText is text until the first occurence of %
    ' Start from second entry:
    For lText = LBound(aText) + 1 To UBound(aText)
        sFirstChar = Left$(aText(lText), 1)
        Select Case sFirstChar
        Case "1" To "9"
            ' Positional parameter: Lookup and insert
            lValuePos = CLng(sFirstChar) - 1
            
            If lValuePos <= lValuesUBound Then
                sCurrentValue = Values(lValuePos)
            Else
                ' Default: E.g., keep %3 if only two parameters are passed
                sCurrentValue = "%" & sFirstChar
            End If
            aText(lText) = sCurrentValue & Mid$(aText(lText), 2)
        
        Case "%"
            Debug.Assert False
            
        Case ""
            ' Special case: %% (or % at end of string):
            ' keep single % and ignore next token
            aText(lText) = "%" & aText(lText)
            lText = lText + 1
            
        Case Else
            ' Silently ignore all other %x tokens
            aText(lText) = "%" & aText(lText)
        End Select
    Next
    
    ' Combine result:
    Printf = Join(aText, "")
End Function

Sub SplitKeyValue(ByVal sKeyValue As String, ByRef sKey As String, ByRef sValue As String)
    Dim lPos As Long
    lPos = VBA.InStr(1, sKeyValue, "=")
    
    If lPos <= 0 Then
        sKey = sKeyValue
        sValue = ""
    Else
        sKey = Left$(sKeyValue, lPos - 1)
        sValue = Mid$(sKeyValue, lPos + 1)
    End If
End Sub















Private Sub Test_Printf()
    Debug.Assert Printf("%1", "abc") = "abc"
    Debug.Assert Printf("This is a %2%1.", "test", "(not too simple) ") = "This is a (not too simple) test."
    Debug.Assert Printf("Let's see how it handles out-of-range parameters %3 and occurences of %% and %y, and even at end: %") = "Let's see how it handles out-of-range parameters %3 and occurences of % and %y, and even at end: %"
    Debug.Assert Printf("%1%%%2%%%") = "%1%%2%%"
End Sub

Private Sub Test_SplitKeyValue()
    Dim sKey As String
    Dim sValue As String
    
    SplitKeyValue "ab=cd", sKey, sValue
    Debug.Assert sKey = "ab"
    Debug.Assert sValue = "cd"
    
    SplitKeyValue "ab=cd=ef", sKey, sValue
    Debug.Assert sKey = "ab"
    Debug.Assert sValue = "cd=ef"
    
    SplitKeyValue "abc", sKey, sValue
    Debug.Assert sKey = "abc"
    Debug.Assert sValue = ""
End Sub
Attribute VB_Name = "Win32Clipboard"
Option Explicit

' this code adapted from Stack Overflow: "Excel 2013 64-bit VBA: Clipboard API doesn't work"
' http://stackoverflow.com/q/18668928/2146688

' changed to use CF_UNICODETEXT, and RtlMoveMemory instead of lstrcpy

#If VBA7 And Win32 Then
Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalFree Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalSize Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
Private Declare PtrSafe Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As LongPtr
Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByVal DestPtr As LongPtr, ByVal SrcPtr As LongPtr, ByVal sz As Long)

Private Const GMEM_MOVEABLE = &H2
Private Const GMEM_ZEROINIT = &H40
Private Const GHND = (GMEM_MOVEABLE Or GMEM_ZEROINIT)

Public Const CF_UNICODETEXT = 13
Public Const CB_MAXSIZE = 4096

Public Function Win32_SetClipBoard(MyString As String) As Boolean
'32-bit code by Microsoft: http://msdn.microsoft.com/en-us/library/office/ff192913.aspx
    Dim hGlobalMemory As LongPtr, lpGlobalMemory As LongPtr
    Dim hClipMemory As LongPtr, X As Long

    ' Allocate moveable global memory.
    hGlobalMemory = GlobalAlloc(GHND, Len(MyString) * 2 + 2)
    If hGlobalMemory = 0 Then MsgBox "Could not allocate memory.": Exit Function

    ' Lock the block to get a far pointer to this memory.
    lpGlobalMemory = GlobalLock(hGlobalMemory)

    ' Copy the string to this global memory.
    CopyMemory lpGlobalMemory, StrPtr(MyString), Len(MyString) * 2

    ' Unlock the memory.
    If GlobalUnlock(hGlobalMemory) <> 0 Then
       MsgBox "Could not unlock memory location. Copy aborted."
       'Debug.Print "GlobalFree returned: " & CStr(GlobalFree(hGlobalMemory))
       GoTo OutOfHere
    End If

    ' Open the Clipboard to copy data to.
    If OpenClipboard(0&) = 0 Then
       MsgBox "Could not open the Clipboard. Copy aborted."
       Exit Function
    End If

    ' Clear the Clipboard.
    EmptyClipboard

    ' Copy the data to the Clipboard.
    SetClipboardData CF_UNICODETEXT, hGlobalMemory

OutOfHere:
    If CloseClipboard() = 0 Then
       MsgBox "Could not close Clipboard."
    End If
    Win32_SetClipBoard = True
End Function
#End If
Attribute VB_Name = "Working"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Option Explicit
Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{9C7DC01B-B6DB-4D30-9443-DA5E449911AF}{C224D3FA-BA57-4098-AD07-72A8681ED9A2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdClose_Click()
  Hide
End Sub

Private Sub UserForm_Initialize()
    Label2.Caption = "Excel2LaTeX v" & ChrW$(8202) & "3.5.0"
    Label1.Caption = "Copyright " & ChrW$(169) & " 1996" & ChrW$(8211) & "2016 Chelsea Hughes, " & _
                     "Kirill M" & ChrW$(252) & "ller," & vbLf & "Andrew Hawryluk, " & _
                     "Germ" & ChrW$(225) & "n Ria" & ChrW$(241) & "o, and Joachim Marder"
    TextBox1.Text = "The development repository and the bug tracker for this package are hosted at" & vbCrLf & _
                    "        https://github.com/krlmlr/Excel2LaTeX" & vbCrLf & vbCrLf & _
                    "This work is distributed under the LaTeX Project Public License, version 1.3 or later, available at" & vbCrLf & _
                    "        http://www.latex-project.org/lppl.txt" & vbCrLf & vbCrLf & _
                    "Chelsea Hughes currently maintains this project (comprising Excel2LaTeX.xla and README.md) and will " & _
                    "receive error reports at the project GitHub page (see above)."
    TextBox1.SelStart = 0
    TextBox1.SelLength = 0
End Sub
Attribute VB_Name = "frmConvert"
Attribute VB_Base = "0{86998920-9B42-405F-8BA3-9B10214C86E8}{A87D0BBE-8D68-4653-9A87-9251ECDE6A1F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Implements IView

Private mController As IController
Attribute mController.VB_VarHelpID = -1
Private WithEvents mControllerEvents As IControllerEvents
Attribute mControllerEvents.VB_VarHelpID = -1

Private mModel As IModel
Private WithEvents mModelEvents As IModelEvents
Attribute mModelEvents.VB_VarHelpID = -1

Private mStorage As IStorage
Private WithEvents mStorageEvents As IStorageEvents
Attribute mStorageEvents.VB_VarHelpID = -1

Private WithEvents mActiveWkSheet As Worksheet
Attribute mActiveWkSheet.VB_VarHelpID = -1

Private mbIgnoreControlEvents As Boolean

'
' IView implementation
'
Private Property Get IView_Controller() As IController
    Set IView_Controller = mController
End Property
Private Property Set IView_Controller(ByVal pController As IController)
    Set mController = pController
    Set mControllerEvents = pController.Events
End Property

Private Property Get IView_Storage() As IStorage
    Set IView_Storage = mStorage
End Property
Private Property Set IView_Storage(ByVal pStorage As IStorage)
    Set mStorage = pStorage
    Set mStorageEvents = pStorage.Events
    LoadStoredTablesList
End Property

Private Sub IView_Show(ByVal Modal As FormShowConstants)
    Me.Show Modal
End Sub


'
' Form implementation
'
Private Function SafeRangePrecedents(ByVal pRange As Range) As Range
    On Error Resume Next
    Set SafeRangePrecedents = pRange.Precedents
End Function

Private Function UnionOfRangeAndItsPrecedents(ByVal pRange As Range) As Range
    Dim pPrecedents As Range
    Set pPrecedents = SafeRangePrecedents(pRange)
    
    If pPrecedents Is Nothing Then
        Set UnionOfRangeAndItsPrecedents = pRange
    Else
        Set UnionOfRangeAndItsPrecedents = Union(pRange, pPrecedents)
    End If
End Function


Private Sub AutoApplyBox_Click()
    ApplyButton.Enabled = Not AutoApplyBox.Value
    If AutoApplyBox.Value Then ApplyButton_Click
End Sub

Private Sub chkBooktabs_Click()
    If AutoApplyBox.Value Then UpdateOptions
End Sub

Private Sub chkConvertDollar_Click()
    If AutoApplyBox.Value Then UpdateOptions
End Sub

Private Sub chkTableFloat_Click()
    If AutoApplyBox.Value Then UpdateOptions
End Sub

Private Sub ApplyButton_Click()
    UpdateOptions
    mModel.CellWidth = txtCellSize
    mModel.Indent = txtIndent
End Sub

Private Sub lvwStoredTables_Change()
    Dim bSelected As Boolean
    bSelected = (lvwStoredTables.ListIndex >= 0)
    cmdLoad.Enabled = bSelected
    cmdDelete.Enabled = bSelected
    cmdOverwrite.Enabled = bSelected
End Sub

Private Sub lvwStoredTables_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If cmdLoad.Enabled Then cmdLoad_Click
End Sub

Private Sub lvwStoredTables_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Select Case KeyCode
    Case 46 ' delete
        cmdDelete_Click
    End Select
End Sub

Private Sub mActiveWkSheet_Change(ByVal Target As Range)
    On Error GoTo errfail
    If Not Me.Visible Then Exit Sub
    If Not Intersect(Target, UnionOfRangeAndItsPrecedents(mModel.Range)) Is Nothing Then
        ConvertSelection
    End If
errfail:
End Sub

Private Sub mControllerEvents_ModelChanged()
    Dim pModel As IModel
    Set pModel = mController.Model
    
    Set mModel = pModel
    Set mModelEvents = pModel.Events
    InitFromModel mModel
    
    Set mActiveWkSheet = Nothing
    If Not mModel.Range Is Nothing Then Set mActiveWkSheet = mModel.Range.Worksheet
End Sub

Private Sub mModelEvents_Changed()
    If mbIgnoreControlEvents Then Exit Sub
    SetResult mModel.GetConversionResult
End Sub

Private Sub mStorageEvents_Changed()
    LoadStoredTablesList
End Sub

Private Sub SetResult(ByVal sResult As String)
    #If Mac Then
    txtResult.Locked = False
    #End If
    
    txtResult.Text = sResult
    
    #If Mac Then
    txtResult.Locked = True
    #End If
End Sub

Private Sub ConvertSelection()
    If mbIgnoreControlEvents Then Exit Sub
    SetResult mModel.GetConversionResult
    txtResult.SetFocus
End Sub

Public Sub InitModel(ByVal pModel As IModel)
    With pModel
        .CellWidth = Val(Me.txtCellSize)
        .Options = Me.GetOptions()
        .Indent = Val(Me.txtIndent)
        .FileName = Me.txtFilename
    End With
End Sub

Public Sub InitFromModel(ByVal pModel As IModel)
    mbIgnoreControlEvents = True
    With pModel
        Me.txtCellSize = .CellWidth
        Me.SetOptions (.Options)
        Me.txtIndent = .Indent
        Me.txtFilename = .FileName
        Me.cmdSelection.Caption = .RangeAddress
    End With
    mbIgnoreControlEvents = False
    ConvertSelection
End Sub

Private Sub LoadStoredTablesList()
    lvwStoredTables.Clear
    
    Dim pModel As IModel
    For Each pModel In mStorage.GetItems
        lvwStoredTables.AddItem pModel.Description
    Next
End Sub

Function GetOptions() As x2lOptions
    If chkBooktabs.Value Then GetOptions = GetOptions Or x2lBooktabs
    If chkConvertDollar.Value Then GetOptions = GetOptions Or x2lConvertMathChars
    If chkTableFloat.Value Then GetOptions = GetOptions Or x2lCreateTableEnvironment
End Function
Sub SetOptions(ByVal Options As x2lOptions)
    chkBooktabs.Value = (Options And x2lBooktabs) <> 0
    chkConvertDollar.Value = (Options And x2lConvertMathChars) <> 0
    chkTableFloat.Value = (Options And x2lCreateTableEnvironment) <> 0
End Sub

Private Sub UpdateOptions()
    mModel.Options = GetOptions()
End Sub

Private Sub cmdBrowse_Click()
    Dim sFileName
    sFileName = Application.GetSaveAsFilename(mModel.AbsoluteFileName, "TeX documents (*.tex), *.tex")
    If sFileName <> False Then
        txtFilename = sFileName
    End If
End Sub

Private Sub cmdCancel_Click()
  Hide
End Sub



Private Sub cmdCopy_Click()
    #If VBA7 And Win32 Then
        If Not Win32_SetClipBoard(txtResult) Then Exit Sub
    #Else
        Dim dataObj As New DataObject
        dataObj.SetText txtResult
        dataObj.PutInClipboard
    #End If
    Hide
End Sub

Private Sub cmdSave_Click()
    SaveConversionResultToFile mModel
    Hide
End Sub




Private Sub cmdStore_Click()
    mStorage.Add mModel
    lvwStoredTables.ListIndex = lvwStoredTables.ListCount - 1
End Sub

Private Sub cmdOverwrite_Click()
    Dim lIndex As Long
    lIndex = lvwStoredTables.ListIndex
    mStorage.Remove lIndex + 1
    mStorage.Add mModel, lIndex
    lvwStoredTables.ListIndex = lIndex
End Sub

Private Sub cmdLoad_Click()
    Set mController.Model = mStorage.GetItems.Item(lvwStoredTables.ListIndex + 1)
End Sub

Private Sub cmdDelete_Click()
    mStorage.Remove lvwStoredTables.ListIndex + 1
End Sub


Private Sub cmdExportAll_Click()
    SaveAllStoredItems mStorage
End Sub

Private Sub CommandButton2_Click()
  frmAbout.Show
End Sub


Private Sub spnCellWidth_Change()
  txtCellSize.Text = spnCellWidth
End Sub

Private Sub spnIndent_Change()
  txtIndent.Text = spnIndent
End Sub

Private Sub txtCellSize_Change()
    On Error Resume Next
    spnCellWidth = txtCellSize
    If AutoApplyBox.Value Then mModel.CellWidth = txtCellSize
End Sub

Private Sub txtFilename_Change()
    mModel.FileName = txtFilename
    If txtFilename <> mModel.FileName Then
        txtFilename = mModel.FileName
    End If
End Sub

Private Sub txtIndent_Change()
    On Error Resume Next
    spnIndent = txtIndent
    If AutoApplyBox.Value Then mModel.Indent = txtIndent
End Sub

Private Sub cmdSelection_Click()
    Set mModel.Range = Application.Selection
    Me.cmdSelection.Caption = mModel.RangeAddress
End Sub

Private Sub UserForm_Click()
' This is regenerated every time the form is activated in the IDE. Just keep it here.
End Sub

Private Sub UserForm_Initialize()
    lvwStoredTables_Change
End Sub


INQUEST-PP=macro
