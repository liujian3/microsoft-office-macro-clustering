Attribute VB_Name = "AutoMacros"
Option Explicit
Sub AutoNew()
Call Config.CheckDocumentVariables(ActiveDocument)
Call Config.ConfigureBySeries(ActiveDocument)
Call Config.DisplayORAToolbars
End Sub
Sub AutoOpen()
Call Config.VerifyDisplaySettings
Call Config.DisplayORAToolbars
End Sub


Attribute VB_Name = "Captions"
Option Explicit
Function PreCaptionInspection(ByRef sel As Selection, _
                              ByVal sCaptionStyleName As String) As String
On Error GoTo ERR_HANDLER
Dim oORAStyles As ORAStyles
'========== Settings and Messages ==========
Dim sMessageMultipleParagraphs As String
Dim sMessageMissingStyle As String
Dim sMessageMissingChapterLabel As String

sMessageMultipleParagraphs = _
    "Selection cannot include more than one paragraph."

sMessageMissingStyle = _
    "Couldn't insert caption. This document is missing " & _
    "the " & sCaptionStyleName & " style."

sMessageMissingChapterLabel = _
    "The first paragraph in the document must be styled" & vbCr & _
    "with the " & cCHAPTER_LABEL_STYLE & " style," & vbCr & _
    "and must contain only the chapter number (or appendix letter)." & vbCr & _
    "Use " & Chr$(34) & "P" & Chr$(34) & " for the Preface."
    
'===========================================

If sel.Paragraphs.Count > 1 Then
    PreCaptionInspection = sMessageMultipleParagraphs
    Exit Function
End If

Set oORAStyles = New ORAStyles
If Not (oORAStyles.Item(sCaptionStyleName).InDoc(sel.Document)) Then
    PreCaptionInspection = sMessageMissingStyle
    Set oORAStyles = Nothing
    Exit Function
End If
Set oORAStyles = Nothing

If Len(DocumentValidation.CheckChapterLabel(sel.Document)) = 0 Then
    PreCaptionInspection = sMessageMissingChapterLabel
    Exit Function
End If

PreCaptionInspection = vbNullString
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("PreCaptionInspection", Err.Description)
Err.Clear
End Function

Sub InsertFigureCaption()
On Error GoTo ERR_HANDLER
Dim sel As Selection
Dim doc As Document
Dim sInspectionReport As String

'======= Settings and Messages ===========
Dim lngDocID As Long
Dim sCaptionType As String

sCaptionType = "Figure"

'=========================================

Set sel = Selection
Call Config.CheckDocumentVariables(sel.Document)

lngDocID = sel.Document.Variables(cVAR_DOC_ID)

sInspectionReport = PreCaptionInspection(sel, cFIGURE_CAPTION_STYLE)

If Len(sInspectionReport) <> 0 Then
    MsgBox sInspectionReport, vbExclamation, cORA_DIALOG_CAPTION
    Exit Sub
End If
Call InsertCaption(sel, _
                   sel.Document.Styles(cFIGURE_CAPTION_STYLE), _
                   sel.Document.Styles(cCHAPTER_LABEL_STYLE), _
                   sCaptionType, _
                   lngDocID)

Call UpdateCaptionNumbering
Exit Sub
ERR_HANDLER:
    Call ErrorHandler.ModuleErrorCatcher("InsertFigureCaption", Err.Description)
    Err.Clear
End Sub

Sub InsertTableCaption()
On Error GoTo ERR_HANDLER
Dim sel As Selection
Dim doc As Document
Dim sInspectionReport As String

'======= Settings and Messages ===========
Dim lngDocID As Long
Dim sCaptionType As String

sCaptionType = "Table"
'=========================================

Set sel = Selection
Call Config.CheckDocumentVariables(sel.Document)

lngDocID = sel.Document.Variables(cVAR_DOC_ID)

sInspectionReport = PreCaptionInspection(sel, cTABLE_CAPTION_STYLE)

If Len(sInspectionReport) <> 0 Then
    MsgBox sInspectionReport, vbExclamation, cORA_DIALOG_CAPTION
    Exit Sub
End If
Call InsertCaption(sel, _
                   sel.Document.Styles(cTABLE_CAPTION_STYLE), _
                   sel.Document.Styles(cCHAPTER_LABEL_STYLE), _
                   sCaptionType, _
                   lngDocID)

Call UpdateCaptionNumbering
Exit Sub
ERR_HANDLER:
    Call ErrorHandler.ModuleErrorCatcher("InsertTableCaption", Err.Description)
    Err.Clear
End Sub

Sub InsertExampleCaption()
On Error GoTo ERR_HANDLER
Dim sel As Selection
Dim doc As Document
Dim sInspectionReport As String

'======= Settings and Messages ===========
Dim lngDocID As Long
Dim sCaptionType As String

sCaptionType = "Example"
'=========================================

Set sel = Selection
Call Config.CheckDocumentVariables(sel.Document)

lngDocID = sel.Document.Variables(cVAR_DOC_ID)

sInspectionReport = PreCaptionInspection(sel, cEXAMPLE_CAPTION_STYLE)

If Len(sInspectionReport) <> 0 Then
    MsgBox sInspectionReport, vbExclamation, cORA_DIALOG_CAPTION
    Exit Sub
End If
Call InsertCaption(sel, _
                   sel.Document.Styles(cEXAMPLE_CAPTION_STYLE), _
                   sel.Document.Styles(cCHAPTER_LABEL_STYLE), _
                   sCaptionType, _
                   lngDocID)

Call UpdateCaptionNumbering
Exit Sub
ERR_HANDLER:
    Call ErrorHandler.ModuleErrorCatcher("InsertExampleCaption", Err.Description)
    Err.Clear
End Sub
Function InsertCaption(ByRef sel As Selection, _
                        ByRef styCaptionStyle As Style, _
                        ByRef styRefStyle As Style, _
                        ByVal sCaptionType As String, _
                        Optional ByVal lngDocID As Long) As Boolean


Dim bIsEmpty As Boolean ' For testing if selected paragraph is empty
Dim sSEQStream As String ' For inserting optional unique ID in SEQ field

InsertCaption = False
bIsEmpty = False

On Error GoTo ERR_HANDLER

If lngDocID = 0 Then
    sSEQStream = vbNullString
Else
    sSEQStream = CStr(lngDocID)
End If

With sel
    .Expand wdParagraph
    If .Characters.Count = 1 Then
        bIsEmpty = True
    End If
    
    .Collapse wdCollapseStart
    .Style = .Document.Styles(styCaptionStyle)
    .InsertBefore sCaptionType & cSPACE
    .Collapse wdCollapseEnd
    
    .Fields.Add _
        Range:=Selection.Range, _
        Type:=wdFieldStyleRef, _
        Text:=Chr$(34) & .Document.Styles(styRefStyle).NameLocal & Chr$(34), _
        preserveformatting:=True
    
    .Collapse wdCollapseEnd
    .InsertAfter "-"
    .Collapse wdCollapseEnd
    
    .Fields.Add _
        Range:=Selection.Range, _
        Type:=wdFieldSequence, _
        Text:=sSEQStream & cUNDERSCORE & sCaptionType, _
        preserveformatting:=True
    .InsertAfter cCAPTION_LABEL_DELIM & cSPACE
    
    .Collapse wdCollapseEnd
    If bIsEmpty = True Then
        .InsertAfter sCaptionType & " Caption Text Goes Here"
    Else
        .Expand wdParagraph
    End If
End With

InsertCaption = True
Exit Function

ERR_HANDLER:
   Call ErrorHandler.ModuleErrorCatcher("InsertCaption", Err.Description)
   Err.Clear
Exit Function
End Function
Sub CheckCaptionNumberingInActiveDoc()
Dim doc As Document
Set doc = ActiveDocument
Dim para As Paragraph
For Each para In doc.Paragraphs
    Call ValidateAndFixCaptionParagraph(para)
Next para
End Sub
Function ValidateAndFixCaptionParagraph(ByRef para As Paragraph)
' This function is clever, but complex, and would likely
' be difficult to maintain across substantial template modifications.
On Error GoTo ERR_HANDLER
Dim rng As Range
Dim rngOriginalSelection As Range
Dim rngSecondWord As Range
Dim rngFourthWord As Range
Dim rngFifthWord As Range
Dim oORAStyles As ORAStyles
Dim sFirstWordText As String
Dim sParaStyleName As String
Dim lCharCount As Long
Dim k As Integer
Dim v As Variant

Set oORAStyles = New ORAStyles
sParaStyleName = para.Style.NameLocal
If Not (oORAStyles.Exists(sParaStyleName) And _
        oORAStyles.Item(sParaStyleName).XRefType = "CAPTION") Then
    Exit Function
End If
Set oORAStyles = Nothing

Set rng = para.Range.Duplicate
Set rngOriginalSelection = Selection.Range.Duplicate

sFirstWordText = Trim$(rng.Words.First.Text)

If rng.Words.Count >= 5 And _
  InStr(cCAPTION_TYPES, "/" & sFirstWordText & "/") <> 0 Then
    Set rngSecondWord = rng.Words(2)
    Set rngFourthWord = rng.Words(4)
    Set rngFifthWord = rng.Words(5)
    
    rngFifthWord.Text = Replace(rngFifthWord.Text, ":", cCAPTION_LABEL_DELIM)
    
    If rngSecondWord.Fields.Count <> 0 Then
        If rngSecondWord.Fields(1).Type = wdFieldStyleRef Then
            If rngFourthWord.Fields.Count <> 0 Then
                If rngFourthWord.Fields(1).Type = wdFieldSequence Then
                    ' Caption is A-OK!
                    Exit Function
                End If
            End If
        End If
    End If
End If

lCharCount = rng.Characters.Count

rng.Collapse wdCollapseStart

' This is U-G-L-Y
If InStr(cCAPTION_TYPES, "/" & sFirstWordText & "/") <> 0 Then
    If (rng.MoveEndUntil(cset:=":" & cCAPTION_LABEL_DELIM, Count:=lCharCount)) Then
        If (rng.MoveEndWhile(cset:=cSPACE & cCAPTION_LABEL_DELIM & ":", Count:=lCharCount)) Then
            rng.Delete
        End If
    End If
    rng.Select
    Application.Run ("Insert" & sFirstWordText & "Caption")
Else
    rng.Select
    v = Split(cCAPTION_TYPES, "/")
    For k = 0 To UBound(v)
        If Len(v(k)) <> 0 And InStr(sParaStyleName, v(k)) Then
            Application.Run ("Insert" & v(k) & "Caption")
        End If
    Next k
End If
rngOriginalSelection.Select
Exit Function
ERR_HANDLER:
   Call ErrorHandler.ModuleErrorCatcher("ValidateAndFixCaptionParagraph", Err.Description)
   Err.Clear
Exit Function
End Function

Function DoesStringReferToCaptionLabel(ByVal str As String) As Boolean
str = Trim$(str)
str = Split(str)(0)
If InStr(UCase$(cCAPTION_TYPES), "/" & UCase$(str) & "/") <> 0 Then
    DoesStringReferToCaptionLabel = True
    Exit Function
End If
End Function
Function DoesStringMatchThisCaption(str As String, para As Paragraph) As Boolean
'Call ValidateAndFixCaptionParagraph(para)
If UCase$(Trim$(str)) = UCase$(Split(para.Range.Text, ".")(0)) Then
    DoesStringMatchThisCaption = True
    Exit Function
End If
DoesStringMatchThisCaption = False
End Function

Function ValidateSEQFieldIDs(ByRef doc As Document)
'On Error GoTo ERR_HANDLER
Dim fld As Field
Dim sDocID As String
Dim sPattern As String
Dim vfldcode As Variant
Dim sFldNumStream As String
Dim sFldDocID As String
Dim sFldCaptionType As String

sPattern = String(cVAR_DOC_ID_LENGTH, "#")
sPattern = sPattern & "_[EFT]*"

Call Config.CheckDocumentVariables(doc)
sDocID = doc.Variables(cVAR_DOC_ID)

For Each fld In doc.Fields
    If fld.Type = wdFieldSequence And fld.Parent = doc Then
        vfldcode = Split(fld.Code.Text)
        sFldNumStream = vfldcode(2)
        If sFldNumStream Like sPattern Then
            sFldCaptionType = Split(sFldNumStream, cUNDERSCORE)(1)
            sFldDocID = Split(sFldNumStream, cUNDERSCORE)(0)
            If Not sFldDocID = sDocID Then
                sFldDocID = sDocID
                sFldNumStream = sFldDocID & cUNDERSCORE & sFldCaptionType
                fld.Code.Text = "SEQ " & sFldNumStream
            End If
        End If
        fld.Update
    ElseIf fld.Type = wdFieldStyleRef Then
        If fld.Parent = doc Then
            fld.Update
        End If
    End If
Next fld
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ValidateSEQFieldIDs", Err.Description)
Err.Clear
End Function
Function UpdateCaptionFields(ByRef doc As Document)
'Call ValidateSEQFieldIDs(doc)
doc.Fields.Update
End Function
Sub UpdateCaptionNumbering()
Call UpdateCaptionFields(ActiveDocument)
ActiveDocument.Fields.Update
End Sub

Attribute VB_Name = "Config"
Option Explicit

Function CheckDocumentVariables(doc As Document)
On Error Resume Next

Dim vDocVar As Variant
Dim vDocProp As Variant

' Variables with no corresponding property

' Set unique Doc Id
vDocVar = doc.Variables(cVAR_DOC_ID)
If Err.Number = cERR_BADVARIABLE Then
    doc.Variables(cVAR_DOC_ID).Value = _
        VBAUtilities.GenerateFixedLengthRandomNumber(cVAR_DOC_ID_LENGTH)
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If

vDocVar = ActiveDocument.Variables(cCUSTOM_PROP_XREFS_PREVIOUS_STYLE)
If Err.Number = cERR_BADVARIABLE Then
    doc.Variables(cCUSTOM_PROP_XREFS_PREVIOUS_STYLE) = cDEFAULT_XREFS_PREVIOUS_STYLE
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If

vDocVar = ActiveDocument.Variables(cCUSTOM_PROP_COOKBOOK_NUMBERING)
If Err.Number = cERR_BADVARIABLE Then
    doc.Variables(cCUSTOM_PROP_COOKBOOK_NUMBERING) = cDEFAULT_COOKBOOK_NUMBERING
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If

' Properties with variables
vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_XREFS_LIST_ALL_STYLES)
If Err.Number = cERR_BADPROP Then
    doc.CustomDocumentProperties.Add Name:=cCUSTOM_PROP_XREFS_LIST_ALL_STYLES, _
        LinkToContent:=False, _
        Type:=msoPropertyTypeBoolean, _
        Value:=cDEFAULT_XREFS_LIST_ALL_STYLES
    vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_XREFS_LIST_ALL_STYLES)
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If
doc.Variables(cCUSTOM_PROP_XREFS_LIST_ALL_STYLES) = vDocProp


vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_TAB_SPACES)
If Err.Number = cERR_BADPROP Then
    doc.CustomDocumentProperties.Add Name:=cCUSTOM_PROP_TAB_SPACES, _
        LinkToContent:=False, _
        Type:=msoPropertyTypeNumber, _
        Value:=cDEFAULT_TAB_SPACES
    vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_TAB_SPACES)
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If
doc.Variables(cCUSTOM_PROP_TAB_SPACES) = vDocProp


vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH)
If Err.Number = cERR_BADPROP Then
    doc.CustomDocumentProperties.Add Name:=cCUSTOM_PROP_MAX_CODE_LINE_LENGTH, _
        LinkToContent:=False, _
        Type:=msoPropertyTypeNumber, _
        Value:=cDEFAULT_MAX_CODE_LINE_LENGTH
    vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH)
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If
doc.Variables(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH) = vDocProp


vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_SERIES)
If Err.Number = cERR_BADPROP Then
    doc.CustomDocumentProperties.Add Name:=cCUSTOM_PROP_SERIES, _
        LinkToContent:=False, _
        Type:=msoPropertyTypeString, _
        Value:=cDEFAULT_SERIES
    vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_SERIES)
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If
If (ValidateBookSeriesChoice(CStr(vDocProp))) Then
    doc.Variables(cCUSTOM_PROP_SERIES) = vDocProp
Else
    doc.CustomDocumentProperties(cCUSTOM_PROP_SERIES) = cDEFAULT_SERIES
End If


vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_INSERT_FILENAME_NOT_FIGURE)
If Err.Number = cERR_BADPROP Then
    doc.CustomDocumentProperties.Add Name:=cCUSTOM_PROP_INSERT_FILENAME_NOT_FIGURE, _
        LinkToContent:=False, _
        Type:=msoPropertyTypeBoolean, _
        Value:=cDEFAULT_INSERT_FILENAME_NOT_FIGURE
    vDocProp = doc.CustomDocumentProperties(cCUSTOM_PROP_INSERT_FILENAME_NOT_FIGURE)
    Err.Clear
ElseIf Err.Number <> 0 Then
    GoTo ERR_HANDLER
End If
doc.Variables(cCUSTOM_PROP_INSERT_FILENAME_NOT_FIGURE) = vDocProp


Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("CheckDocumentVariables", Err.Description)
Err.Clear
End Function

Function VerifyDisplaySettings(Optional bNull As Boolean)
If Not ShouldSkipViewSettings Then
    With ActiveWindow.View
    ' disabled 4/2005 pending review
        '.ShowBookmarks = True
        '.FieldShading = wdFieldShadingAlways
        '.ShowParagraphs = True
    End With
End If
End Function
Sub ViewFormattingMarks()
With ActiveWindow.View
    .ShowBookmarks = True
    .FieldShading = wdFieldShadingAlways
    .ShowParagraphs = True
End With
End Sub
Sub ToggleCookbookNumbering()
' Toggle Cookbook style heading numbering

' Handle error that would be raised if variable
' not defined in current document
On Error GoTo ERR_HANDLER
Dim doc As Document
Set doc = ActiveDocument
Call Config.CheckDocumentVariables(doc)

If doc.Variables(cCUSTOM_PROP_COOKBOOK_NUMBERING) = True Then
    Call DocumentFormatting.TurnCookbookNumberingOff(doc)
Else
    Call DocumentFormatting.TurnCookbookNumberingOn(doc)
End If
Exit Sub
ERR_HANDLER:
If Err.Number = cERR_BADVARIABLE Then
    Call DocumentFormatting.TurnCookbookNumberingOn(doc)
Else
    Call ErrorHandler.ModuleErrorCatcher("ToggleCookbookNumbering", Err.Description)
End If
End Sub
Function ConfigureBySeries(doc As Document)
Dim sBookSeries As String
Call CheckDocumentVariables(doc)
sBookSeries = doc.Variables(cCUSTOM_PROP_SERIES)
Select Case sBookSeries
    Case cCUSTOM_PROP_SERIES_POCKET
        Call PocketRefMargins(doc)
        doc.CustomDocumentProperties(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH) = _
            cCUSTOM_PROP_SERIES_POCKET_MAX_CODE_LINE_LENGTH
        Call BoldListStyles(False)
    Case cCUSTOM_PROP_SERIES_TRADE
        Call TradeBookMargins(doc)
        doc.CustomDocumentProperties(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH) = _
            cDEFAULT_MAX_CODE_LINE_LENGTH
        Call BoldListStyles(False)
    Case cCUSTOM_PROP_SERIES_HACKS
        Call StandardMargins(doc)
        Call ChangeHacksHeadingAfter(doc)
        doc.CustomDocumentProperties(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH) = _
            cDEFAULT_MAX_CODE_LINE_LENGTH
        Call BoldListStyles(False)
    Case cCUSTOM_PROP_SERIES_MM
        ' Deactivated pending further discussions with MM staff
        'Call BoldListStyles(True)
    Case Else
        Call StandardMargins(doc)
        doc.CustomDocumentProperties(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH) = _
            cDEFAULT_MAX_CODE_LINE_LENGTH
        Call BoldListStyles(False)
End Select

Call DisplayORAToolbars

End Function
Sub ChangeMarginsToPocketRef()
Call PocketRefMargins(ActiveDocument)
End Sub
Sub ChangeMarginsToTradeBook()
Call TradeBookMargins(ActiveDocument)
End Sub
Sub ChangeMarginsToStandard()
Call StandardMargins(ActiveDocument)
End Sub
Sub ReconfigureDocByBookSeries()
Dim doc As Document
Dim sSeries As String

Set doc = ActiveDocument
Call CheckDocumentVariables(doc)
sSeries = doc.Variables(cCUSTOM_PROP_SERIES)
If Not Config.ShouldIgnoreConfirmDialog Then
    If MsgBox(prompt:="This command reconfigures certain settings," & vbCr & _
                      "such as page margins and visible toolbars," & vbCr & _
                      "according to the book series you're working on." & vbCr & vbCr & _
                      "This command will now configure " & Chr$(34) & doc.Name & Chr$(34) & vbCr & _
                      "according to the settings for the " & Chr$(34) & sSeries & Chr$(34) & " series." & vbCr & vbCr & _
                      "If that is incorrect, please press No, and go to" & vbCr & _
                      "File > Properties > Custom to change the series.", _
                      buttons:=vbYesNo, _
                      Title:=cORA_DIALOG_CAPTION) = vbNo Then Exit Sub
End If
                  
Call ConfigureBySeries(doc)
End Sub
Function ChangeHacksHeadingAfter(doc As Document)
Dim styHacksDescription As Style
Set styHacksDescription = doc.Styles("RefSynopsis")
doc.Styles(wdStyleHeading1).NextParagraphStyle = styHacksDescription
styHacksDescription.NextParagraphStyle = doc.Styles(wdStyleBodyText)

End Function
Function PocketRefMargins(doc As Document)
On Error Resume Next
CustomizationContext = doc
   With doc.PageSetup
        .TopMargin = InchesToPoints(2.5)
        .BottomMargin = InchesToPoints(2.5)
        .LeftMargin = InchesToPoints(2.67)
        .RightMargin = InchesToPoints(2.83)
        .MirrorMargins = True
        .TwoPagesOnOne = False
        .SetAsTemplateDefault
    End With
    
End Function

Function StandardMargins(doc As Document)
On Error Resume Next
CustomizationContext = doc
   With doc.PageSetup
        .TopMargin = InchesToPoints(1.4)
        .BottomMargin = InchesToPoints(1.4)
        .LeftMargin = InchesToPoints(1.75)
        .RightMargin = InchesToPoints(1.75)
        .MirrorMargins = True
        .TwoPagesOnOne = False
        .SetAsTemplateDefault
    End With
End Function
 
Function TradeBookMargins(doc As Document)
On Error Resume Next
CustomizationContext = doc
   With doc.PageSetup
        .TopMargin = InchesToPoints(1.75)
        .BottomMargin = InchesToPoints(1.75)
        .LeftMargin = InchesToPoints(2)
        .RightMargin = InchesToPoints(2)
        .MirrorMargins = True
        .TwoPagesOnOne = False
        .SetAsTemplateDefault
    End With
End Function
Function ValidateBookSeriesChoice(ByVal sSeries As String) As Boolean
Dim v As Variant
For Each v In Array(cCUSTOM_PROP_SERIES_MM, cCUSTOM_PROP_SERIES_STANDARD, cCUSTOM_PROP_SERIES_HACKS, cCUSTOM_PROP_SERIES_CKBK, cCUSTOM_PROP_SERIES_TRADE, cCUSTOM_PROP_SERIES_POCKET, cCUSTOM_PROP_SERIES_NUT, cCUSTOM_PROP_SERIES_ANNOY, cCUSTOM_PROP_SERIES_DEVNOTE)
    If v = sSeries Then
        ValidateBookSeriesChoice = True
        Exit Function
    End If
Next v
ValidateBookSeriesChoice = False
End Function

Sub AboutThisTemplate()
MsgBox cABOUT, vbOKOnly + vbInformation, cORA_DIALOG_CAPTION
End Sub
Function DisplayORAToolbars(Optional bNull As Boolean)
On Error Resume Next
Dim cbar As CommandBar
Dim sSeries As String
Dim bShowProdEdToolbar As Boolean
Dim bShowToolsDeptToolbar As Boolean
Dim sConfigFilePath As String
Dim doc As Document
Set doc = ActiveDocument
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE
Call CheckDocumentVariables(doc)
sSeries = doc.Variables(cCUSTOM_PROP_SERIES)

With Application
    Select Case sSeries
        Case cCUSTOM_PROP_SERIES_MM
                .CommandBars(cTOOLBAR_ORAToolbar).Visible = False
                .CommandBars(cTOOLBAR_SmartStyler).Visible = True
                .CommandBars(cTOOLBAR_MMToolbar).Visible = True
        Case Else
                .CommandBars(cTOOLBAR_ORAToolbar).Visible = True
                .CommandBars(cTOOLBAR_SmartStyler).Visible = True
                .CommandBars(cTOOLBAR_MMToolbar).Visible = False
    End Select
    
    bShowToolsDeptToolbar = System.PrivateProfileString(sConfigFilePath, _
                            cORA_CONFIG_PREFERENCES_KEY, _
                            cORA_CONFIG_PREFERENCES_SHOWTOOLSTB)
    
    If (bShowToolsDeptToolbar) Then
        .CommandBars(cTOOLBAR_TOOLS_USE).Visible = True
        If ApplyToolsToolbarOverrides = False Then
            ' In development
        End If
    Else
        .CommandBars(cTOOLBAR_TOOLS_USE).Visible = False
    End If
    
    bShowProdEdToolbar = System.PrivateProfileString(sConfigFilePath, _
                            cORA_CONFIG_PREFERENCES_KEY, _
                            cORA_CONFIG_PREFERENCES_SHOWPRODTB)
    
    If (bShowProdEdToolbar) Then
        .CommandBars(cTOOLBAR_PROD_EDS).Visible = True
    Else
        .CommandBars(cTOOLBAR_PROD_EDS).Visible = False
    End If
End With
doc.Saved = True
Set doc = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DisplayORAToolbars", Err.Description)
Err.Clear
End Function
Sub BoldListStyles(bYesNo As Boolean)
Dim doc As Document
Dim sListNumberStyleName As String
Dim sListBulletStyleName As String

sListNumberStyleName = "ListNumber"
sListBulletStyleName = "ListBullet"

Set doc = ActiveDocument

If Not doc.Styles(sListBulletStyleName).Font.Bold = bYesNo Then
    doc.Styles(sListBulletStyleName).Font.Bold = bYesNo
End If

If Not doc.Styles(sListNumberStyleName).Font.Bold = bYesNo Then
    doc.Styles(sListNumberStyleName).Font.Bold = bYesNo
End If

End Sub
Function GenerateConfigFile(Optional bShowProdEdToolbar As Variant, _
                            Optional bShowToolsDeptToolbar As Variant, _
                            Optional bNoConfirm As Variant, _
                            Optional bDisableForcedViewSettings As Variant, _
                            Optional bNoAutoApplyFilenameTag As Variant, _
                            Optional bNoAutoApplyTechItalicTag As Variant) As String
Dim sFullName As String
Dim sMessageSuccess As String
Dim sMessageFAIL As String

sFullName = Options.DefaultFilePath(wdUserTemplatesPath) & _
        Application.PathSeparator & cORA_CONFIG_FILE
'MsgBox IsMissing(bShowToolsDeptToolbar)

With System
    .PrivateProfileString(sFullName, _
                          cORA_CONFIG_PREFERENCES_KEY, _
                          cORA_CONFIG_PREFERENCES_EXISTS) _
                                = True

    If Not IsMissing(bShowProdEdToolbar) Then
        .PrivateProfileString(sFullName, _
                          cORA_CONFIG_PREFERENCES_KEY, _
                          cORA_CONFIG_PREFERENCES_SHOWPRODTB) _
                                = bShowProdEdToolbar
    End If
    
    If Not IsMissing(bShowToolsDeptToolbar) Then
        .PrivateProfileString(sFullName, _
                              cORA_CONFIG_PREFERENCES_KEY, _
                              cORA_CONFIG_PREFERENCES_SHOWTOOLSTB) _
                                    = bShowToolsDeptToolbar
    End If
                                
    If Not IsMissing(bNoConfirm) Then
        .PrivateProfileString(sFullName, _
                          cORA_CONFIG_PREFERENCES_KEY, _
                          cORA_CONFIG_PREFERENCES_NOCONFIRM) _
                                = bNoConfirm
    End If
    
    If Not IsMissing(bDisableForcedViewSettings) Then
        .PrivateProfileString(sFullName, _
                          cORA_CONFIG_PREFERENCES_KEY, _
                          cORA_CONFIG_PREFERENCES_NOVIEWOPTS) _
                                = bDisableForcedViewSettings
    End If
    
    If Not IsMissing(bNoAutoApplyFilenameTag) Then
        .PrivateProfileString(sFullName, _
                          cORA_CONFIG_PREFERENCES_KEY, _
                          cORA_CONFIG_SMARTSTYLER_NOAPPLYFILENAME) _
                                = bNoAutoApplyFilenameTag
    End If
    
        If Not IsMissing(bNoAutoApplyTechItalicTag) Then
        .PrivateProfileString(sFullName, _
                          cORA_CONFIG_PREFERENCES_KEY, _
                          cORA_CONFIG_SMARTSTYLER_NOAPPLYTECHITAL) _
                                = bNoAutoApplyTechItalicTag
    End If

    If Len(.PrivateProfileString(sFullName, _
                    cORA_CONFIG_PREFERENCES_KEY, _
                    cORA_CONFIG_PREFERENCES_EXISTS)) <> 0 Then
        GenerateConfigFile = sFullName
    Else
        GenerateConfigFile = vbNullString
    End If
End With
End Function
Sub RegisterAsProdEd()

Dim sConfigFilePath As String
Dim sMessageSuccess As String
Dim sMessageFAIL As String
sMessageFAIL = "FAILED to register you and generate configuration file."
sMessageSuccess = "Successfully registered you as a Production Editor! " & _
            "The " & cTOOLBAR_PROD_EDS & " toolbar will now be displayed by default " & _
            "whenever you work with the O'Reilly Template on this computer. To delete this setting, remove " & _
            "the following configuration file:" & vbCr & vbCr

sConfigFilePath = GenerateConfigFile(bShowProdEdToolbar:=True)
                        
If Len(sConfigFilePath) <> 0 Then
    Call DisplayORAToolbars
    MsgBox sMessageSuccess & sConfigFilePath, _
        vbInformation + vbOKOnly, _
        cORA_DIALOG_CAPTION
Else
        MsgBox sMessageFAIL, _
            vbCritical, _
            cORA_DIALOG_CAPTION
        
End If

End Sub

Sub RegisterAsToolsDept()

Dim sConfigFilePath As String
Dim sMessageSuccess As String
Dim sMessageFAIL As String
sMessageFAIL = "FAILED to register you and generate configuration file."
sMessageSuccess = "Successfully registered you as a member of Tools. " & _
            "The " & cTOOLBAR_TOOLS_USE & " toolbar will now be displayed by default " & _
            "whenever you work with the O'Reilly Template on this computer. To delete this setting, remove " & _
            "the following configuration file:" & vbCr & vbCr


sConfigFilePath = GenerateConfigFile(bShowToolsDeptToolbar:=True)
    
If Len(sConfigFilePath) <> 0 Then
    Call DisplayORAToolbars
    MsgBox sMessageSuccess & sConfigFilePath, _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox sMessageFAIL, _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If


End Sub

Sub CreateDefaultConfigurationFile()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bShowProdEdToolbar:=False, _
                        bShowToolsDeptToolbar:=False, _
                        bNoConfirm:=False, _
                        bDisableForcedViewSettings:=False)
    
If Len(sConfigFilePath) <> 0 Then
    MsgBox "Successfully created a configuration file, using default settings, located at:" & vbCr & _
           sConfigFilePath, _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
    


End Sub
Sub SetIgnoreConfirmDialog()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bNoConfirm:=True)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "Confirmation dialogs have been disabled. This setting will remain in effect " & vbCr & _
               "for ALL documents you use with this template", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Sub ResetConfirmDialog()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bNoConfirm:=False)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "Confirmation dialogs have been re-enabled.", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Function ShouldIgnoreConfirmDialog() As Boolean
Dim sIgnore As String
Dim bIgnore As Boolean
Dim sConfigFilePath As String
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE

sIgnore = System.PrivateProfileString(sConfigFilePath, _
                cORA_CONFIG_PREFERENCES_KEY, _
                cORA_CONFIG_PREFERENCES_NOCONFIRM)
If Len(sIgnore) = 0 Then
    bIgnore = False
Else
    bIgnore = CBool(sIgnore)
End If

ShouldIgnoreConfirmDialog = bIgnore
End Function
Function ShouldSkipViewSettings() As Boolean
Dim sSkip As String
Dim bSkip As Boolean
Dim sConfigFilePath As String
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE

sSkip = System.PrivateProfileString(sConfigFilePath, _
                cORA_CONFIG_PREFERENCES_KEY, _
                cORA_CONFIG_PREFERENCES_NOVIEWOPTS)
If Len(sSkip) = 0 Then
    bSkip = False
Else
    bSkip = CBool(sSkip)
End If

ShouldSkipViewSettings = bSkip
End Function
Sub SetSkipViewSettings()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bDisableForcedViewSettings:=True)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "View options now won't be reset when template loads. This setting will remain " & vbCr & _
               "in effect for ALL documents you work on with this template.", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Sub ResetShouldSkipViewSettings()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bDisableForcedViewSettings:=False)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "View options will now be reset to template defaults when template loads.", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Sub TogglePgfTagsOnLeftOfScreen()
With ActiveWindow
    .View = wdNormalView
    If .StyleAreaWidth = 0 Then
        .StyleAreaWidth = InchesToPoints(1)
    Else
        .StyleAreaWidth = 0
    End If
End With
End Sub

Function ShouldDeleteFigHolderTextWithFigure() As Boolean
Dim sShould As String
Dim bShould As Boolean
Dim sConfigFilePath As String
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE

sShould = System.PrivateProfileString(sConfigFilePath, _
                cORA_CONFIG_PREFERENCES_KEY, _
                cORA_CONFIG_PREFERENCES_DELFIGHOLDTEXT)
If Len(sShould) = 0 Then
    bShould = False
Else
    bShould = CBool(sShould)
End If

ShouldDeleteFigHolderTextWithFigure = bShould
End Function
Function ApplyToolsToolbarOverrides(Optional bNull As Boolean) As Boolean
On Error Resume Next
Dim sConfigFilePath As String
Dim strMacrosList As String
Dim vMacroPosInfo As Variant
Dim vMacrosList As Variant
Dim lPosition As Long
Dim sMacroName As String
Dim v As Variant
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE
strMacrosList = System.PrivateProfileString(sConfigFilePath, _
                cORA_CONFIG_TOOLS_TOOLBAR_KEY, _
                "Overrides")
If Len(strMacrosList) = 0 Then Exit Function
vMacrosList = Split(strMacrosList, ",,")
For Each v In vMacrosList
    vMacroPosInfo = Split(v, cSTYLEALIAS_DELIMITER)
    sMacroName = vMacroPosInfo(0)
    lPosition = vMacroPosInfo(1)
    Application.CommandBars(cTOOLBAR_TOOLS_USE).Controls(sMacroName).Move Before:=lPosition
    If Err.Number = cERR_BADTOOLBARCONTROLNAME Or Err.Number = 0 Then
        Err.Clear
    Else
        GoTo ERR_HANDLER
    End If
Next v
ActiveDocument.AttachedTemplate.Saved = True
ApplyToolsToolbarOverrides = True
Exit Function
ERR_HANDLER:
ApplyToolsToolbarOverrides = False
End Function
Function ShouldNotApplyFilenameTagAutomatically() As Boolean
Dim sIgnore As String
Dim bIgnore As Boolean
Dim sConfigFilePath As String
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE

sIgnore = System.PrivateProfileString(sConfigFilePath, _
                cORA_CONFIG_PREFERENCES_KEY, _
                cORA_CONFIG_SMARTSTYLER_NOAPPLYFILENAME)
If Len(sIgnore) = 0 Then
    bIgnore = False
Else
    bIgnore = CBool(sIgnore)
End If

ShouldNotApplyFilenameTagAutomatically = bIgnore
End Function
Function ShouldNotApplyTechItalicTagAutomatically() As Boolean
Dim sIgnore As String
Dim bIgnore As Boolean
Dim sConfigFilePath As String
sConfigFilePath = Options.DefaultFilePath(wdUserTemplatesPath)
sConfigFilePath = sConfigFilePath & Application.PathSeparator
sConfigFilePath = sConfigFilePath & cORA_CONFIG_FILE

sIgnore = System.PrivateProfileString(sConfigFilePath, _
                cORA_CONFIG_PREFERENCES_KEY, _
                cORA_CONFIG_SMARTSTYLER_NOAPPLYTECHITAL)
If Len(sIgnore) = 0 Then
    bIgnore = False
Else
    bIgnore = CBool(sIgnore)
End If

ShouldNotApplyTechItalicTagAutomatically = bIgnore
End Function
Sub SetShouldNotApplyFilenameTagAutomatically()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bNoAutoApplyFilenameTag:=True)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "The " & cFILENAME_STYLE & " style won't be applied automatically. This setting will remain in effect " & vbCr & _
               "for ALL documents you use with this template", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Sub SetShouldNotApplyTechItalicTagAutomatically()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bNoAutoApplyTechItalicTag:=True)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "The " & cTECH_ITAL_STYLE & " style won't be applied automatically. This setting will remain in effect " & vbCr & _
               "for ALL documents you use with this template", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Sub ResetAutoApplyFilenameTag()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bNoAutoApplyFilenameTag:=False)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "The " & cFILENAME_STYLE & " tag will now be automatically applied by the SmartStyler", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub
Sub ResetAutoApplyTechItalicTag()
Dim sConfigFilePath As String
sConfigFilePath = GenerateConfigFile(bNoAutoApplyTechItalicTag:=False)
If Len(sConfigFilePath) <> 0 Then
        MsgBox "The " & cTECH_ITAL_STYLE & " tag will now be automatically applied by the SmartStyler", _
            vbInformation + vbOKOnly, _
            cORA_DIALOG_CAPTION
Else
    MsgBox "FAILED to create configuration file.", _
            vbCritical, _
            cORA_DIALOG_CAPTION
End If
End Sub

Attribute VB_Name = "Constants"
Option Explicit
' Current version and info
Public Const cORA_VERSION = "3.9.7.7"
' 3.9.7.7  08/2006 -- Added macros to delete index markers (for MM series)
' 3.9.7.6  07/2006 -- Added Cookbook xrefs helper
'                     Added >Code, ListVariable..., SidebarListVariable tags
' 3.9.7.5  03/2006 -- Updated Hacks xref to add space after "hack" and xref color (added xref color const)
' 3.9.7.4  08/2005 -- Fixed bug in Fig reporter
' 3.9.7.3  08/2005 -- Added insertion of "Hack" before xrefs for Hacks series
' 3.9.7.2  08/2005 -- Fixed bug in Fig reporter
' 3.9.7.1  07/2005 -- UnlinkHyperlinks now does footnotes
' 3.9.7 -- 06/2005 -- fixed bug so docs aren't "dirty" after opening
' 3.9.6 -- special for dreamweaver mm
' 3.9.5 -- 05/2005 -- Tweaked ValidateSEQField macro
' 3.9.4 -- 04/2005 -- experimenting with language issues. Added cSTYLEALIAS_DELIM constant for int'l
' 3.9.3 -- 03/2005 -- Added experimental style mappping code for Sarah Milstein
'                      may also be useful for conversions
' 3.9.2 -- 04/2005 -- Disabled forced view settings; added Show Formatting Marks
'                       to ORATools->Configure
' 3.9.1 -- 03/2005 -- Added Index Tag space remover for Deb Cameron. Not added to GUI
' 3.9.0 -- 03/2005 -- Fixed SmartStyler so correctly applies style with no text selected
'                     Modified API-level functions to use optional doc objects as arguments
' 3.8.9 -- 02/2005 -- Fixed bugs in NoteWarningListNumber style and SidebarCode Style
'                     Added cleanup macros for use with MarkLogic generated files
' 3.8.8 -- 02/2005 -- Added interactive formatting repair macros (for user input and bookmarks)
' 3.8.7 -- 02/2005 -- Cosmetic toolbar changes
' 3.8.6 -- 02/2005 -- Added auto application of Filename and Tech Italic tags
'                       (and corresponding config options)
'                     Added Filename tag
'                     Added Inline Comment tag
' 3.8.5 -- 02/2005 -- Added mapping file function to Reapply/Global Swap
' 3.8.4 -- 02/2005 -- Standardizing error handling
' 3.8.3 -- 02/2005 -- Misc. bug fixes
' 3.8.2 -- 01/2005 -- Rewrote DeleteAllEmptyBodyParagraphs to use linked list,
'                       and to temporarily turn off revision tracking as it runs
' 3.8.1 -- 01/2005 -- Slight changes to Tools dept. toolbar, also added macro
'                       FixManuallyAppliedInlineFormattingInSelection, required
'                       modifying FixManuallyAppliedInlineFormattingInDoc to instead be
'                       FixManuallyAppliedInlineFormattingInRange
'                       Also added error handling to those subs/functions.
' 3.8.0 -- 01/2005 -- Added conversion macros, separated versioning code into separate module,
'                     Changed Style Width Area macro to toggle on/off,
'                     Modified several macros to match Sub/Function (function does the work,
'                      sub calls from active doc and interacts with user) in advance of
'                      creating API reference for batch processing
' 3.7.3 -- 01/2005 -- Fixed bug in GenerateConfigFile function
' 3.7.2 -- 01/2005 -- Fixed UCase glitch in SmartStyler Code, now accepts "TIMES"
' 3.7.1 -- 10/2004 -- Added URL Fixer
' 3.7.0 -- 10/2004 -- Complete rewrite of Inline formatting repair macro to improve performance
' 3.6.7 -- 10/2004 -- Added config file support
'
' 3.0 -- 8/2004 -- Milestone release. Reconfigured menus, complete rewrite for Mac compatibility
' 2.0 -- 9/2003 -- Milestone release. First replacement of ORA template since 1998
Public Const cTOOLS_EMAIL = "toolsreqwd@oreilly.com"
Public Const cABOUT = _
    "O'Reilly Media, Inc., custom Microsoft Word Template" & vbCr & vbCr & _
    "Version: " & cORA_VERSION & vbCr & vbCr & _
    "Included VBA code is provided " & _
    "under the BSD License." & vbCr & vbCr & _
    "For questions or support, send email to:" & vbCr & _
    cTOOLS_EMAIL


' Message box and dialog caption
Public Const cORA_DIALOG_CAPTION = "O'Reilly Word Template -- " & cORA_VERSION
Public Const cDONE = "Done."

' misc constants
Public Const cNONE = "NONE"
Public Const cDEFAULT = "DEFAULT"
Public Const cCAPTION_LABEL_DELIM = "."
Public Const cSPACE = " "
Public Const cFIGURE_NOT_LINKED = "IMAGE NOT ASSOCIATED WITH A FILE"
Public Const cUNDERSCORE = "_"
Public Const cFILENAME_PATTERN = "*.???"

' Mapping file constants
Public Const cMAPPING_FILE = "style_mapping.txt"
Public Const cMAPPING_FILE_PARAGRAPH_STYLES = "Paragraph Style Mappings"
Public Const cMAPPING_FILE_CHARACTER_STYLES = "Character Style Mappings"

' Book series constants
Public Const cCUSTOM_PROP_SERIES_MM = "Missing Manual"
Public Const cCUSTOM_PROP_SERIES_STANDARD = "Main"
Public Const cCUSTOM_PROP_SERIES_HACKS = "Hacks"
Public Const cCUSTOM_PROP_SERIES_CKBK = "Cookbook"
Public Const cCUSTOM_PROP_SERIES_TRADE = "TradeBook"
Public Const cCUSTOM_PROP_SERIES_POCKET = "Pocket"
Public Const cCUSTOM_PROP_SERIES_NUT = "Nutshell"
Public Const cCUSTOM_PROP_SERIES_ANNOY = "Annoyances"
Public Const cCUSTOM_PROP_SERIES_DEVNOTE = "Developer Notebook"
Public Const cCUSTOM_PROP_SERIES_TRAINER = "Personal Trainer"
Public Const cCUSTOM_PROP_SERIES_POCKET_MAX_CODE_LINE_LENGTH = 60

' Toolbar Titles
Public Const cTOOLBAR_SmartStyler = "O'Reilly SmartStyler"
Public Const cTOOLBAR_ORAToolbar = "O'Reilly Toolbar"
Public Const cTOOLBAR_MMToolbar = "Missing Manual"
Public Const cTOOLBAR_TOOLS_USE = "Tools Dept."
Public Const cTOOLBAR_PROD_EDS = "Prod Eds"

' Chapter types
Public Const cCHAP = "Chapter"
Public Const cAPP = "Appendix"

' Smart styler options
Public Const cBOLD = 1
Public Const cITALIC = 2
Public Const cCW = 3

' Smart styler fonts
Public Const cFONT_STANDARD = "Times"
Public Const cFONT_CONSTANT_WIDTH = "Courier"

' Document Variable Names
Public Const cVAR_DOC_ID = "DocID"
Public Const cCUSTOM_PROP_XREFS_LIST_ALL_STYLES = "ListAllDocumentStyles"
Public Const cCUSTOM_PROP_TAB_SPACES = "TabSpaces"
Public Const cCUSTOM_PROP_MAX_CODE_LINE_LENGTH = "MaxCodeLineLength"
Public Const cCUSTOM_PROP_XREFS_PREVIOUS_STYLE = "PreviousXRefStyle"
Public Const cCUSTOM_PROP_INSERT_FILENAME_NOT_FIGURE = "InsertFileNameNotFigure"
Public Const cCUSTOM_PROP_COOKBOOK_NUMBERING = "CookbookNumbering"
Public Const cCUSTOM_PROP_SERIES = "BookSeries"

' XRef Constants
Public Const cXREF_PREFIX = "XREF"

' Config Settings
Public Const cVAR_DOC_ID_LENGTH = 5
Public Const cDEFAULT_XREFS_LIST_ALL_STYLES = False
Public Const cDEFAULT_XREFS_PREVIOUS_STYLE = cNONE
Public Const cDEFAULT_TAB_SPACES = 4
Public Const cDEFAULT_MAX_CODE_LINE_LENGTH = 85
Public Const cDEFAULT_INSERT_FILENAME_NOT_FIGURE = False
Public Const cDEFAULT_COOKBOOK_NUMBERING = False
Public Const cDEFAULT_SERIES = cCUSTOM_PROP_SERIES_STANDARD

' Styles constants
Public Const cCHAPTER_LABEL_STYLE = "ChapterLabel"
Public Const cFIGURE_CAPTION_STYLE = "FigureTitle"
Public Const cFIGURE_HOLDER_STYLE = "FigureHolder"
Public Const cTABLE_CAPTION_STYLE = "TableTitle"
Public Const cEXAMPLE_CAPTION_STYLE = "ExampleTitle"
Public Const cFILENAME_STYLE = "Filename"
Public Const cTECH_ITAL_STYLE = "Technical Italic"
Public Const cUSER_INPUT_STYLE = "User Input"
Public Const cXREF_CHAR_STYLE = "XRefColor"
Public Const cCODE_EMPHASIS_STYLE = "CodeEmphasis"
Public Const cCODE_STYLE = "Code"
Public Const cSTYLEALIAS_DELIMITER = ","

' Error constants
Public Const cERR_BADBOOKMARKNAME = 5828
Public Const cERR_BADVARIABLE = 5825
Public Const cERR_BADPROP = 5
Public Const cERR_BADTOOLBARCONTROLNAME = 5
Public Const cERR_NODELETEBUILTIN = 5173
Public Const cERR_NOTLINKEDIMAGE = 91
Public Const cERR_MISSING_STYLE = 5834
Public Const cERR_STYLE_DOES_NOT_EXIST = 5941



' Xref UserForm constants
Public Const cUF_XREFS_SHOW_SHORT_LIST = "List Only Common Styles"
Public Const cUF_XREFS_SHOW_ALL = "List All Document Styles"

 
' Pseudo-arrays
Public Const cCAPTION_TYPES = "/Figure/Example/Table/"
Public Const cCAPTION_STYLE_NAMES = ";;FigureTitle;;ExampleTitle;;TableTitle;;"

' Config file info
Public Const cORA_CONFIG_FILE = "ORA.ini"
Public Const cORA_CONFIG_PREFERENCES_KEY = "Preferences"
Public Const cORA_CONFIG_PREFERENCES_SHOWPRODTB = "ShowProdEdToolbar"
Public Const cORA_CONFIG_PREFERENCES_SHOWTOOLSTB = "ShowToolsDeptToolbar"
Public Const cORA_CONFIG_PREFERENCES_NOCONFIRM = "NoConfirmationDialogs"
Public Const cORA_CONFIG_PREFERENCES_NOVIEWOPTS = "DisableForcedViewSettings"
Public Const cORA_CONFIG_PREFERENCES_EXISTS = "ConfigFileExists"
Public Const cORA_CONFIG_TOOLS_TOOLBAR_KEY = "Tools Toolbar Overrides"
Public Const cORA_CONFIG_SMARTSTYLER_NOAPPLYFILENAME = "NoAutoApplyFilename"
Public Const cORA_CONFIG_SMARTSTYLER_NOAPPLYTECHITAL = "NoAutoApplyTechItalic"

' This one's unsettable from UI -- experimental key for Julie's use
' To activate, add this key to "Preferences" section of config file,
' with value of True
Public Const cORA_CONFIG_PREFERENCES_DELFIGHOLDTEXT = "DeleteFigHolderText"



Attribute VB_Name = "Conversion"
Option Explicit

Function CreateStyleIfNotExtant(sStyleName As String, _
                                lStyleType As Long, _
                                doc As Document) As Boolean

    On Error Resume Next
    doc.Styles.Add sStyleName, lStyleType
    
    If Err.Number = cERR_NODELETEBUILTIN Or Err.Number = 0 Then
        CreateStyleIfNotExtant = True
        Exit Function
    Else
        CreateStyleIfNotExtant = False
    End If
End Function
Sub AddChapterStartPara()
On Error GoTo ERR_HANDLER

If Not Config.ShouldIgnoreConfirmDialog Then
    If MsgBox("This macro should only be run just prior to conversion to FrameMaker. Continue?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If AddChapterStartParaToDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("AddChapterStartPara", Err.Description)
End Sub
Function AddChapterStartParaToDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sChapterStartStyleName As String
Dim para As Paragraph
sChapterStartStyleName = "ChapterStart"
If doc Is Nothing Then Set doc = ActiveDocument

If CreateStyleIfNotExtant(sChapterStartStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If
If Not doc.Paragraphs.First.Style = doc.Styles(sChapterStartStyleName) Then
    Set para = doc.Paragraphs.Add(Range:=doc.Range)
    para.Style = doc.Styles(sChapterStartStyleName)
End If
AddChapterStartParaToDoc = True
Exit Function
ERR_HANDLER:
AddChapterStartParaToDoc = False
End Function
Sub PrepareNoteParasForConversion()
On Error GoTo ERR_HANDLER

If Not Config.ShouldIgnoreConfirmDialog Then
    If MsgBox("This macro should only be run just prior to conversion to FrameMaker. Continue?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If PrepareNoteParasForConversionInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("PrepareNoteParasForConversion", Err.Description)
End Sub
Function PrepareNoteParasForConversionInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sNoteWarningIconParaStyleName As String
Dim sNoteTipIconParaStyleName As String
Dim sNoteNoteParaStyleName As String
Dim sNoteContinueParaStyleName As String
Dim sNoteStyle As String
Dim sNoteWarningStyle As String

Dim oCurrPara As Paragraph
Dim oPrevPara As Paragraph
Dim oNextPara As Paragraph

sNoteStyle = "Note"
sNoteWarningStyle = "NoteWarning"
sNoteWarningIconParaStyleName = "NoteWarning"
sNoteTipIconParaStyleName = "NoteTip"
sNoteNoteParaStyleName = "NoteNote" ' Not currently used
sNoteContinueParaStyleName = "Note..."

If doc Is Nothing Then Set doc = ActiveDocument

If CreateStyleIfNotExtant(sNoteWarningIconParaStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If
If CreateStyleIfNotExtant(sNoteTipIconParaStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If
If CreateStyleIfNotExtant(sNoteNoteParaStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If
If CreateStyleIfNotExtant(sNoteContinueParaStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

Set oCurrPara = doc.Paragraphs.First
Do While Not oCurrPara Is Nothing
    Set oNextPara = oCurrPara.Next
    If oCurrPara.Style = doc.Styles(sNoteStyle) Then
        Set oPrevPara = oCurrPara.Previous
        If InStr(oPrevPara.Style, "Note") = 0 Then
            Set oPrevPara = doc.Paragraphs.Add(Range:=oCurrPara.Range)
            oPrevPara.Style = doc.Styles(sNoteTipIconParaStyleName)
        End If
        If oNextPara.Style = doc.Styles(sNoteStyle) Then
            oCurrPara.Style = doc.Styles(sNoteContinueParaStyleName)
        End If
    ElseIf oCurrPara.Style = doc.Styles(sNoteWarningStyle) And _
        oCurrPara.Range.Characters.Count > 1 Then
        Set oPrevPara = oCurrPara.Previous
        If InStr(oPrevPara.Style, "Note") = 0 Then
            Set oPrevPara = doc.Paragraphs.Add(Range:=oCurrPara.Range)
            oPrevPara.Style = doc.Styles(sNoteWarningIconParaStyleName)
        End If
        If oNextPara.Style = doc.Styles(sNoteWarningStyle) Then
            oCurrPara.Style = doc.Styles(sNoteContinueParaStyleName)
        Else
            oCurrPara.Style = doc.Styles(sNoteStyle)
        End If

    End If
    Set oCurrPara = oNextPara
Loop
PrepareNoteParasForConversionInDoc = True
Exit Function
ERR_HANDLER:
PrepareNoteParasForConversionInDoc = False
End Function
Sub AddTableHolderParasToExamples()
On Error GoTo ERR_HANDLER

If Not Config.ShouldIgnoreConfirmDialog Then
    If MsgBox("This macro should only be run just prior to conversion to FrameMaker. Continue?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If AddTableHolderParasToExamplesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("AddTableHolderParasToExamples", Err.Description)
End Sub
Function AddTableHolderParasToExamplesInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim paraNew As Paragraph
Dim sExampleTitleStyleName As String
Dim sTableHolderStyleName As String

sExampleTitleStyleName = "ExampleTitle"
sTableHolderStyleName = "TableHolder"
If doc Is Nothing Then Set doc = ActiveDocument
If CreateStyleIfNotExtant(sTableHolderStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

Set para = doc.Paragraphs.First
Do While Not para Is Nothing
    If para.Style = doc.Styles(sExampleTitleStyleName) Then
        If Not para.Previous.Style = doc.Styles(sTableHolderStyleName) Then
            Set paraNew = doc.Paragraphs.Add(Range:=para.Range)
            paraNew.Style = doc.Styles(sTableHolderStyleName)
        End If
    End If
    Set para = para.Next
Loop
AddTableHolderParasToExamplesInDoc = True

Exit Function
ERR_HANDLER:
AddTableHolderParasToExamplesInDoc = False
End Function
Sub PrepareHeadingsForHacksConversion()
On Error GoTo ERR_HANDLER

If Not Config.ShouldIgnoreConfirmDialog Then
    If MsgBox("This macro should only be run just prior to conversion to FrameMaker. Continue?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If PrepareHeadingsForHacksConversionInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("PrepareHeadingsForHacksConversion", Err.Description)
End Sub
Function PrepareHeadingsForHacksConversionInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim oCurrPara As Paragraph
Dim oPrevPara As Paragraph
Dim oNextPara As Paragraph
Dim oBoxPara As Paragraph
Dim oNumPara As Paragraph
Dim sHacksBoxBStyleName As String
Dim sHacksBoxMStyleName As String
Dim sHacksBoxEStyleName As String
Dim sHacksDescriptionStyleName As String
Dim sHacksNumberStyleName As String
Dim sNonNumberedHeadAStyleName As String
Dim sHacksNumberedHeadPrefix As String
Dim sHacksStylePrefix As String
Dim sHacksDescriptionWordStyleName As String


sHacksDescriptionWordStyleName = "RefSynopsis"
sHacksNumberedHeadPrefix = "#"

sHacksStylePrefix = "!hacks"
sHacksBoxBStyleName = "!hacksBoxB"
sHacksBoxMStyleName = "!hacksBoxM"
sHacksBoxEStyleName = "!hacksBoxE"
sHacksDescriptionStyleName = "!hacksDescription"
sHacksNumberStyleName = "!hacksNumber"
sNonNumberedHeadAStyleName = "-HeadA"

If doc Is Nothing Then Set doc = ActiveDocument

If CreateStyleIfNotExtant(sHacksBoxBStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

If CreateStyleIfNotExtant(sHacksBoxMStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

If CreateStyleIfNotExtant(sHacksBoxEStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

If CreateStyleIfNotExtant(sHacksDescriptionStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

If CreateStyleIfNotExtant(sHacksNumberStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

If CreateStyleIfNotExtant(sNonNumberedHeadAStyleName, wdStyleTypeParagraph, doc) = False Then
    GoTo ERR_HANDLER
End If

Set oCurrPara = doc.Paragraphs.First
Do While Not oCurrPara Is Nothing
    Set oNextPara = oCurrPara.Next
    If oCurrPara.Style = doc.Styles("Heading 1") Then
        Set oPrevPara = oCurrPara.Previous
        If InStr(oPrevPara.Style, sHacksStylePrefix) = 0 Then
            If Not oCurrPara.Range.Characters.First.Text = sHacksNumberedHeadPrefix Then
                oCurrPara.Style = doc.Styles(sNonNumberedHeadAStyleName)
            Else
                oCurrPara.Range.Characters.First.Delete
                Set oBoxPara = doc.Paragraphs.Add(Range:=oCurrPara.Range)
                Set oNumPara = doc.Paragraphs.Add(Range:=oCurrPara.Range)
                oBoxPara.Style = doc.Styles(sHacksBoxBStyleName)
                oNumPara.Style = doc.Styles(sHacksNumberStyleName)
                If oNextPara.Style = doc.Styles(sHacksDescriptionWordStyleName) Then
                    oNextPara.Style = doc.Styles(sHacksDescriptionStyleName)
                End If
            End If
        End If
    End If
    
    Set oCurrPara = oNextPara
Loop
PrepareHeadingsForHacksConversionInDoc = True
Exit Function
ERR_HANDLER:
PrepareHeadingsForHacksConversionInDoc = False
End Function
Attribute VB_Name = "DefineStyles"
Option Explicit
Function NewDefineStyles() As String
Dim sInfo As String

' YUCK! Stupid VBA on Macintosh. Curse you, Microsoft!

'===============";;Name;;Aliases;;FixInlineItalic;;FixInlineBold;;FixInlineCourier;;InlinesAllowed;;XRefShortList;;XRefType;;ListBulletStyle;;ListNumberStyle;;ListVariableTermStyle;;ListVariableStyle;;ListContinueStyle;;IncreaseIndentStyle;;DecreaseIndentStyle;;MissingManualStyle;;TypographerQuotes
sInfo = sInfo & ";;>ListBullet;;>lb;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;Body Text;;>ListNumber;;DEFAULT;;DEFAULT;;>ListBullet...;;DEFAULT;;ListBullet;;FALSE;;TRUE;;"
sInfo = sInfo & ";;>ListBullet...;;>lbb;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;Body Text;;>ListNumber...;;DEFAULT;;DEFAULT;;>ListBullet;;DEFAULT;;ListBullet...;;FALSE;;TRUE;;"
sInfo = sInfo & ";;>ListNumber;;>ln;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;>ListBullet;;Body Text;;DEFAULT;;DEFAULT;;>ListNumber...;;DEFAULT;;ListNumber;;FALSE;;TRUE;;"
sInfo = sInfo & ";;>ListNumber...;;>lnn;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;>ListBullet...;;Body Text;;DEFAULT;;DEFAULT;;>ListNumber...;;DEFAULT;;ListNumber...;;FALSE;;TRUE;;"
sInfo = sInfo & ";;>ListVariable;;>lv;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;>ListBullet;;>ListNumber;;DEFAULT;;DEFAULT;;>ListVariable;;DEFAULT;;ListVariable;;FALSE;;TRUE;;"
sInfo = sInfo & ";;>ListVariableTerm;;>lvt;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;>ListBullet;;>ListNumber;;DEFAULT;;DEFAULT;;>ListVariableTerm;;DEFAULT;;ListVariableTerm;;FALSE;;TRUE;;"
sInfo = sInfo & ";;>Code;;>x;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;>CodeEmphasis;;>xe;;TRUE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;>CodeNum;;DEFAULT;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;Body Text;;b;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;CellBody;;tb;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;CellCode;;tc;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;CellHeading;;th;;TRUE;;FALSE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;CellSubhead;;ts;;TRUE;;FALSE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;FALSE;;TRUE;;"
sInfo = sInfo & ";;ChapterLabel;;cl;;FALSE;;FALSE;;FALSE;;FALSE;;TRUE;;CHAPNUM;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ChapterTitle;;ct;;FALSE;;FALSE;;FALSE;;FALSE;;TRUE;;CHAPTITLE;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Code;;x;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;CodeEmphasis;;xe;;TRUE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;CodeNum;;DEFAULT;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;Comment;;z;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Emphasis;;fi;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Epigraph;;e;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;EpigraphAuthor;;ea;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;EpigraphCitation;;ec;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ExampleTitle;;xt;;FALSE;;FALSE;;FALSE;;FALSE;;TRUE;;CAPTION;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;FigureHolder;;fh;;FALSE;;FALSE;;FALSE;;FALSE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;FigureTitle;;ft;;FALSE;;FALSE;;FALSE;;FALSE;;TRUE;;CAPTION;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Filename;;DEFAULT;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Footnote Text;;fn;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;XRefColor;;xc;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;XRefColorCW;;xw;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;Heading 1;;heading 1,HeadA,h1;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 2;;heading 2,HeadB,h2;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 3;;heading 3,HeadC,h3;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 4;;heading 4,HeadD,h4;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 5;;heading 5,h5;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 6;;heading 6,h6;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 7;;heading 7,h7;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 8;;heading 8,h8;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Heading 9;;heading 9,h9;;TRUE;;FALSE;;FALSE;;FALSE;;TRUE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Inline Comment;;DEFAULT;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Literal;;fc;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;Replaceable;;fci;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;User Input;;fcb;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;User Input Replaceable;;fcbi;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;ListBullet;;lb;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;Body Text;;ListNumber;;DEFAULT;;DEFAULT;;ListBullet...;;>ListBullet;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListBullet...;;lbb;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;ListBullet;;>LIstBullet...;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListNumber;;ln;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;Body Text;;DEFAULT;;DEFAULT;;ListNumber...;;>ListNumber;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListNumber...;;lnn;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;ListNumber;;>ListNumber...;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListSimple;;ls;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListVariable;;lv;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;>ListVariable;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListVariable...;;lvv;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;>ListVariable;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;ListVariableTerm;;lvt;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;>ListVariableTerm;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Normal;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Note;;n;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;Note>ListBullet;;Note>ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Note>Code;;DEFAULT;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;Note>ListBullet;;Note>ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;Note>ListBullet;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;Note;;Note>ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Note>ListNumber;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;Note>ListBullet;;Note;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;NoteWarning;;nw;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;NoteWarning>ListBullet;;NoteWarning>ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;NoteWarning>Code;;DEFAULT;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;NoteWarning>ListBullet;;NoteWarning>ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;NoteWarning>ListBullet;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;NoteWarning ;;NoteWarning>ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;NoteWarning>ListNumber;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;NoteWarning>ListBullet;;NoteWarning;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Quote;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;RefPurpose;;rp;;FALSE;;FALSE;;FALSE;;FALSE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;RefSynopsis;;Hack Description,rs,hd;;FALSE;;FALSE;;FALSE;;FALSE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarBody;;yb;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;SidebarListBullet;;SidebarListNumber;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarCode;;yc;;TRUE;;TRUE;;FALSE;;TRUE;;FALSE;;DEFAULT;;SidebarListBullet;;SidebarListNumber;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;FALSE;;"
sInfo = sInfo & ";;SidebarListBullet;;ylb;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;SidebarBody;;SidebarListNumber;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarListNumber;;yln;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;SidebarListBullet;;SidebarBody;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarListVariable;;ylv;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;SidebarListBullet;;SidebarBody;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarListVariableTerm;;ylvt;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;SidebarListBullet;;SidebarBody;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarType;;yy;;FALSE;;FALSE;;FALSE;;TRUE;;TRUE;;DEFAULT;;SidebarListBullet;;SidebarListNumber;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;SidebarTitle;;yt;;FALSE;;FALSE;;FALSE;;TRUE;;TRUE;;DEFAULT;;SidebarListBullet;;SidebarListNumber;;SidebarListVariable;;SidebarListVariableTerm;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Strong;;fb;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Subscript;;DEFAULT;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Superscript;;DEFAULT;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Symbol;;DEFAULT;;TRUE;;TRUE;;TRUE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;TableTitle;;tt;;FALSE;;FALSE;;FALSE;;FALSE;;TRUE;;CAPTION;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"
sInfo = sInfo & ";;Technical Italic;;fix;;FALSE;;FALSE;;FALSE;;TRUE;;FALSE;;DEFAULT;;ListBullet;;ListNumber;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;DEFAULT;;TRUE;;TRUE;;"

'Dim lLength As Long
'l = Len(sInfo)
' Trims leading and trailing ;; characters
sInfo = Mid$(sInfo, 3, Len(sInfo) - 4)

NewDefineStyles = sInfo
End Function
Public Function DefineORAStyles() As Collection
Dim i As Integer
Dim col As Collection
Dim s As String
Dim MyColORAStyles As Collection
Set MyColORAStyles = New Collection
'============================
'= Define the ORA Styles info
'============================

'===================================
s = NewDefineStyles

Dim var As Variant
Dim v As Variant
Dim vinfo As Variant

var = Split(s, ";;;;")

For Each v In var
    vinfo = Split(v, ";;")
        Set col = New Collection
        col.Add Key:="Name", Item:=vinfo(0)
        col.Add Key:="Aliases", Item:=vinfo(1)
        col.Add Key:="FixInlineItalic", Item:=vinfo(2)
        col.Add Key:="FixInlineBold", Item:=vinfo(3)
        col.Add Key:="FixInlineCW", Item:=vinfo(4)
        col.Add Key:="InlinesAllowed", Item:=vinfo(5)
        col.Add Key:="XRefShowInShortList", Item:=vinfo(6)
        col.Add Key:="XRefType", Item:=vinfo(7)
        col.Add Key:="ListBulletStyle", Item:=vinfo(8)
        col.Add Key:="ListNumberStyle", Item:=vinfo(9)
        col.Add Key:="ListVariableTermStyle", Item:=vinfo(10)
        col.Add Key:="ListVariableStyle", Item:=vinfo(11)
        col.Add Key:="ListContinueStyle", Item:=vinfo(12)
        col.Add Key:="IncreaseIndent", Item:=vinfo(13)
        col.Add Key:="DecreaseIndent", Item:=vinfo(14)
        col.Add Key:="MissingManualStyle", Item:=vinfo(15)
        col.Add Key:="TypographerQuotes", Item:=vinfo(16)
        MyColORAStyles.Add Key:=vinfo(0), Item:=col
        Set col = Nothing
Next v

Set DefineORAStyles = MyColORAStyles

End Function

Function CheckForStyleInDocPromptToUpdate(sStyleName As String, doc As Document) As Boolean
On Error Resume Next
Dim sName As String
sName = doc.Styles(sStyleName).NameLocal
If Err.Number = cERR_STYLE_DOES_NOT_EXIST Then
    If MsgBox("This document (" & doc.Name & ") doesn't have the " & sStyleName & _
              " style. It may have been recently added to the template. Would you " & _
              "like to update this document's styles to reflect those in the template? (Recommended)", _
              vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
        doc.UpdateStyles
        CheckForStyleInDocPromptToUpdate = True
    End If
ElseIf Err.Number = 0 Then
    CheckForStyleInDocPromptToUpdate = True
Else
    Call ErrorHandler.ModuleErrorCatcher("CheckForStyleInDocPromptToUpdate", Err.Description)
End If
End Function
Attribute VB_Name = "DocumentFormatting"
Option Explicit
Function TurnCookbookNumberingOn(doc As Document)
' Applies cookbook style numbering to the current document
On Error GoTo ERR_HANDLER
Dim i As Integer
Dim strChapNum As String

'=========== Settings and Messages ============
Dim sMessageMissingChapterLabel As String

sMessageMissingChapterLabel = _
   "First paragraph in your document must be styled ChapterLabel"

'==============================================

' First verify first paragraph is Chapter Label
If doc.Paragraphs(1).Style = "ChapterLabel,cl" Then
    ' Get the contents of the ChapterLabel paragraph
    ' to use as first number in heading numbering
    strChapNum = Left$(doc.Paragraphs(1).Range.Text, _
                 doc.Paragraphs(1).Range.Characters.Count - 1)
Else
    MsgBox sMessageMissingChapterLabel, _
    vbExclamation, _
    cORA_DIALOG_CAPTION
    Exit Function
End If

' Set variable to track status
doc.Variables(cCUSTOM_PROP_COOKBOOK_NUMBERING) = True

' Apply numbering to Heading 1 paragraphs only
With ListGalleries(wdOutlineNumberGallery).ListTemplates(5).ListLevels(1)
    .NumberFormat = strChapNum & ".%1"
    .TrailingCharacter = wdTrailingSpace
    .NumberStyle = wdListNumberStyleArabic
    .NumberPosition = InchesToPoints(0)
    .Alignment = wdListLevelAlignLeft
    .TextPosition = InchesToPoints(0.3)
    .TabPosition = wdUndefined
    .ResetOnHigher = 0
    .StartAt = 0
    .LinkedStyle = wdStyleHeading1
End With
    
' Apply no numbering and no indent to other Heading paragraphs
For i = 2 To 9
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(5).ListLevels(i)
        .NumberFormat = vbNullString
        .TrailingCharacter = wdTrailingSpace
        .NumberStyle = wdListNumberStyleArabic
        .NumberPosition = InchesToPoints(0)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = InchesToPoints(0.3)
        .TabPosition = wdUndefined
        .ResetOnHigher = 0
        .StartAt = 0
        .LinkedStyle = vbNullString
    End With
Next i

' Activate numbering on Heading 1 paragraphs
    doc.Styles(wdStyleHeading1).LinkToListTemplate _
        ListTemplate:=ListGalleries(wdOutlineNumberGallery).ListTemplates(5), _
        ListLevelNumber:=1
' Be sure no numbering is linked to other headings
For i = 2 To 9
    doc.Styles("Heading " & CStr(i)).LinkToListTemplate _
    ListTemplate:=Nothing
Next i
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("TurnCookbookNumberingOn", Err.Description)
Err.Clear
End Function

Function TurnCookbookNumberingOff(doc As Document)
On Error GoTo ERR_HANDLER
doc.Styles(wdStyleHeading1).LinkToListTemplate ListTemplate:=Nothing
doc.Variables(cCUSTOM_PROP_COOKBOOK_NUMBERING) = False
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("TurnCookbookNumberingOn", Err.Description)
Err.Clear
End Function
Sub SkipNumberingInCurrentHeading()
On Error GoTo ERR_HANDLER
Dim sel As Selection

'=========== Settings and Messages ============
Dim sMessageSelectSingle As String
Dim sMessageSelecteHeading1 As String

sMessageSelectSingle = _
   "Please select only a single paragraph"

sMessageSelecteHeading1 = _
    "Please select a Heading 1 paragraph"

'==============================================

Set sel = Selection

If sel.Range.Paragraphs.Count > 1 Then
    MsgBox sMessageSelectSingle, _
            vbExclamation, _
            cORA_DIALOG_CAPTION
    Exit Sub
ElseIf Not (sel.Range.Style = sel.Document.Styles(wdStyleHeading1)) Then
    MsgBox sMessageSelecteHeading1, _
            vbExclamation, _
            cORA_DIALOG_CAPTION
Else
    If sel.Document.Variables(cCUSTOM_PROP_COOKBOOK_NUMBERING) = True Then
        sel.Range.ListFormat.RemoveNumbers
    End If
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("SkipNumberingInCurrentHeading", Err.Description)
Err.Clear
End Sub


Attribute VB_Name = "DocumentValidation"
Option Explicit
Sub CheckDocumentStyles()
On Error GoTo ERR_HANDLER
Dim doc As Document
Dim sty As Style
Dim oORAStyles As ORAStyles
Dim oORAStyle As ORAStyle
Dim strStyleName As String
Dim i As Integer
Dim strMissingStyles As String
Dim strExtraStyles As String
Dim strReportMessage As String

Set doc = ActiveDocument
Set oORAStyles = New ORAStyles

For Each sty In doc.Styles
    If (sty.Type = wdStyleTypeCharacter Or _
        sty.Type = wdStyleTypeParagraph) Then
        If Not (sty.BuiltIn) Then
        strStyleName = sty.NameLocal
            If Not (oORAStyles.Exists(strStyleName)) Then
                strExtraStyles = strExtraStyles & strStyleName & vbCrLf
            End If
        End If
    End If
Next sty

For i = 1 To oORAStyles.Count
    If Not (oORAStyles.Item(i).InDoc(doc)) Then
        strMissingStyles = strMissingStyles & oORAStyles.Item(i).Name & vbCrLf
    End If
Next i

Select Case True
    Case (Len(strExtraStyles) = 0 And Len(strMissingStyles) = 0)
        strReportMessage = "All Styles are OK."
    
    Case (Len(strExtraStyles) = 0 And Len(strMissingStyles) <> 0)
        strReportMessage = "This document is missing the following " & _
                           "custom O'Reilly styles:" & _
                           vbCrLf & _
                           vbCrLf & _
                           strMissingStyles
    
    Case (Len(strExtraStyles) <> 0 And Len(strMissingStyles) = 0)
        strReportMessage = "This document contains the following " & _
                           "styles that aren't defined in the O'Reilly template:" & _
                           vbCrLf & _
                           vbCrLf & _
                           strExtraStyles
    
    Case (Len(strExtraStyles) <> 0 And Len(strMissingStyles) <> 0)
        strReportMessage = "This document contains the following " & _
                           "styles that aren't defined in the O'Reilly template:" & _
                           vbCrLf & _
                           vbCrLf & _
                           strExtraStyles & _
                           vbCrLf & _
                           "And this document is missing the following " & _
                           "custom O'Reilly styles:" & _
                           vbCrLf & _
                           vbCrLf & _
                           strMissingStyles
End Select

MsgBox strReportMessage, _
        vbInformation, _
        cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("CheckDocumentStyles", Err.Description)
Err.Clear
End Sub
Sub CheckHeadingOrder()
On Error GoTo ERR_HANDLER

Dim para As Paragraph
Dim styPara As Style
Dim oDocStyles As Styles
Dim styHeading1 As Style
Dim styHeading2 As Style
Dim styHeading3 As Style
Dim styHeading4 As Style

Dim bHeading1 As Boolean
Dim bHeading2 As Boolean
Dim bHeading3 As Boolean
Dim bHeading4 As Boolean

Set oDocStyles = ActiveDocument.Styles
Set styHeading1 = oDocStyles(wdStyleHeading1)
Set styHeading2 = oDocStyles(wdStyleHeading2)
Set styHeading3 = oDocStyles(wdStyleHeading3)
Set styHeading4 = oDocStyles(wdStyleHeading4)

bHeading1 = False
bHeading2 = False
bHeading3 = False
bHeading4 = False

For Each para In ActiveDocument.Paragraphs
    Set styPara = para.Style
    
    If (InStr(styPara.NameLocal, "Heading") <> 0) Then
         
        Select Case styPara
            Case styHeading1
                bHeading1 = True
                bHeading2 = False
                bHeading3 = False
                bHeading4 = False
        
            Case styHeading2
                bHeading2 = True
                bHeading3 = False
                bHeading4 = False
           
            Case styHeading3
                bHeading3 = True
                bHeading4 = False
           
            Case styHeading4
                bHeading4 = True
        End Select
    
        
        Select Case True
        
             Case (bHeading2 And Not bHeading1)
                 para.Range.Select
                 If MsgBox("Heading 2 without preceding Heading 1" & vbCr & _
                     "Press Yes to fix now, No to continue checking", _
                     vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
                     Exit Sub
                 End If
             Case (bHeading3 And Not bHeading2)
                 para.Range.Select
                 If MsgBox("Heading 3 without preceding Heading 2" & vbCr & _
                     "Press Yes to fix now, No to continue checking", _
                     vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
                     Exit Sub
                 End If
             Case (bHeading3 And Not bHeading1)
                 para.Range.Select
                 If MsgBox("Heading 3 without preceding Heading 1" & vbCr & _
                     "Press Yes to fix now, No to continue checking", _
                     vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
                     Exit Sub
                 End If
             Case (bHeading4 And Not bHeading3)
             
                 para.Range.Select
                 If MsgBox("Heading 4 without preceding Heading 3" & vbCr & _
                     "Press Yes to fix now, No to continue checking", _
                     vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
                     Exit Sub
                 End If
            Case (bHeading4 And Not bHeading2)
                para.Range.Select
                 If MsgBox("Heading 4 without preceding Heading 2" & vbCr & _
                     "Press Yes to fix now, No to continue checking", _
                     vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
                     Exit Sub
                 End If
             Case (bHeading4 And Not bHeading1)
                 para.Range.Select
                 If MsgBox("Heading 4 without preceding Heading 1" & vbCr & _
                     "Press Yes to fix now, No to continue checking", _
                     vbYesNo, cORA_DIALOG_CAPTION) = vbYes Then
                     Exit Sub
                 End If
        
        End Select

    End If
Next para

MsgBox "Finished checking heading order.", _
    vbInformation, _
    cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("CheckHeadingOrder", Err.Description)
Err.Clear
Exit Sub
End Sub

Function CheckChapterLabel(doc As Document) As String
Dim sFirstParaStyle As String
Dim sParaText As String
Dim para As Paragraph

Set para = doc.Paragraphs.First
sFirstParaStyle = para.Style.NameLocal
sFirstParaStyle = Split(sFirstParaStyle, cSTYLEALIAS_DELIMITER)(0)
sParaText = para.Range.Text

If (sFirstParaStyle = cCHAPTER_LABEL_STYLE And Len(sParaText) > 1) Then
     Select Case Asc(CStr(doc.Paragraphs.First.Range.Text))
        Case 49 - 57
            CheckChapterLabel = cCHAP
        Case Else
            CheckChapterLabel = cAPP
     End Select
Else
    CheckChapterLabel = vbNullString
End If
End Function

Sub CheckDocumentBookmarks()
On Error GoTo ERR_HANDLER
Dim bk As Bookmark
Dim doc As Document
Dim lResponse As Long
' ========== Settings and Messages ==========
Dim sMessageBadBookmark As String
Dim sMessageBookmarksOK As String
sMessageBadBookmark = "The selected bookmark is needed for the correct operation of cross references. " & _
            "It currently spans multiple paragraphs, which will cause errors when you update references. " & _
            "Please adjust its ends, or re-create it. The bookmark is named:" & vbCr
sMessageBookmarksOK = "Document Bookmarks are all OK."
' ===========================================
Set doc = ActiveDocument
Call Config.VerifyDisplaySettings
For Each bk In doc.Bookmarks
    If bk.Range.Paragraphs.Count > 1 Then
        If InStr(bk.Name, cXREF_PREFIX) Then
            bk.Range.Select
            lResponse = MsgBox("There's a problem with the selected bookmark (" & bk.Name & "). " & _
                               "Bookmarks like this, which are used to mark cross references, " & _
                               "shouldn't span multiple paragraphs. Unfortunately, due to Word's " & _
                               "poor design, this can easily happen inadvertently. " & vbCr & vbCr & "In most cases, the " & _
                               "bookmark belongs around the first or the last paragraph of the selected " & _
                               "text. Please press Yes if the bookmark should be around the first paragraph " & _
                               "in the current selection, press No if the bookmark should be around the last " & _
                               "paragraph in the current selection, or press Cancel if you want to try fixing " & _
                               "it yourself (or just want to quit this macro). Again, that's: " & vbCr & vbCr & _
                               "   * Yes: If the bookmark belongs around first paragraph in selection" & vbCr & _
                               "   * No: If the bookmark belongs around the last paragraph in selection" & vbCr & _
                               "   * Cancel: To exit this macro", _
                                vbYesNoCancel + vbExclamation, _
                                cORA_DIALOG_CAPTION)
            Select Case lResponse
                Case vbYes
                    bk.End = bk.Range.Paragraphs.First.Range.End - 1
                Case vbNo
                    bk.Start = bk.Range.Paragraphs.Last.Range.Start
                Case Else
                    Exit Sub
            End Select
            'Exit Sub
        End If
    End If
Next bk
MsgBox sMessageBookmarksOK, vbInformation, cORA_DIALOG_CAPTION

Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("CheckDocumentBookmarks", Err.Description)
End Sub

Sub CheckCodeLineLengths()
On Error GoTo ERR_HANDLER
Dim lMaxCodeLineLength As Long
Dim para As Paragraph
Dim sParaStyleName As String
Dim lParaCharCount As Long
Dim doc As Document
Dim v As Variant

'========== Settings and Messages ==========
Dim vCodeStyles As Variant

vCodeStyles = Array("Code", "CodeEmphasis", "CodeNum")
'===========================================

Set doc = ActiveDocument
Call Config.CheckDocumentVariables(doc)
lMaxCodeLineLength = doc.Variables(cCUSTOM_PROP_MAX_CODE_LINE_LENGTH)
For Each para In doc.Paragraphs
    sParaStyleName = para.Style.NameLocal
    sParaStyleName = Split(sParaStyleName, cSTYLEALIAS_DELIMITER)(0)
    For Each v In vCodeStyles
        If sParaStyleName = v Then
            lParaCharCount = para.Range.Characters.Count - 1
            If lParaCharCount > lMaxCodeLineLength Then
               para.Range.Select
               If MsgBox("This paragraph is longer than " & lMaxCodeLineLength & " lines." & _
                       "Please break it into two or more paragraphs." & vbCr & _
                       "(To change the maximum number of characters allowed, go to File -> Properties -> Custom)." _
                           & String(2, vbCr) & _
                       "Press Yes to fix now, press No to continue checking document.", _
                       vbYesNo, _
                       cORA_DIALOG_CAPTION) = vbYes Then
                    Exit Sub
                End If
            End If
        End If
    Next v
Next para
MsgBox "Finished checking Code paragraph line lengths.", vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("CheckCodeLineLengths", Err.Description)
Err.Clear
End Sub
Sub CheckForIncorrectUserInput()
On Error GoTo ERR_HANDLER
If CheckForIncorrectUserInputInDoc(ActiveDocument, True) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("CheckForIncorrectUserInput", Err.Description)
End Sub
Function CheckForIncorrectUserInputInDoc(Optional doc As Document, Optional bNotInteractive As Boolean) As Boolean
On Error GoTo ERR_HANDLER

Dim para As Paragraph
Dim rng As Range
Dim sMessage As String
Dim lResponse As Long
sMessage = "All of the text in this paragraph is styled with the " & cUSER_INPUT_STYLE & cSPACE & _
           "Character style. If you want an entire " & cCODE_STYLE & " paragraph to be bold, " & _
           "you should use the " & cCODE_EMPHASIS_STYLE & " *Paragraph* style." & vbCr & vbCr & _
           "Would you like to change the selected paragraph to " & cCODE_EMPHASIS_STYLE & "? (Recommended)"

If doc Is Nothing Then Set doc = ActiveDocument

For Each para In doc.Paragraphs
    If para.Style = doc.Styles(cCODE_STYLE) Then
        Set rng = para.Range
        rng.MoveEnd unit:=wdCharacter, Count:=-1
        If rng.Style = doc.Styles(cUSER_INPUT_STYLE) Then
        
            If bNotInteractive = False Then
                para.Range.Select
                lResponse = MsgBox(sMessage, _
                                   vbQuestion + vbYesNoCancel, _
                                   cORA_DIALOG_CAPTION)
                Select Case lResponse
                    Case vbYes
                        rng.Font.Reset
                        para.Style = doc.Styles(cCODE_EMPHASIS_STYLE)
                    Case vbCancel
                        Exit Function
                End Select
            Else
                rng.Font.Reset
                para.Style = doc.Styles(cCODE_EMPHASIS_STYLE)
            End If
        End If
    End If
Next para
If Not bNotInteractive Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
CheckForIncorrectUserInputInDoc = True
Exit Function
ERR_HANDLER:
CheckForIncorrectUserInputInDoc = False

End Function
Attribute VB_Name = "EditingTools"
Option Explicit
Sub DeleteAllComments()
On Error GoTo ERR_HANDLER
Dim doc As Document
Dim i As Integer
Dim iNumberOfComments As Integer
Dim lContinue As Long
Dim bNoDialogs As Boolean
Set doc = ActiveDocument

iNumberOfComments = doc.Comments.Count
If iNumberOfComments = 0 Then
    MsgBox "There are no comments in this document.", vbInformation, cORA_DIALOG_CAPTION
    Exit Sub
End If
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to delete ALL " & iNumberOfComments & " comments?", _
                vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If

If DeleteAllCommentsInDoc(doc) = False Then
    GoTo ERR_HANDLER
ElseIf Not bNoDialogs Then
    MsgBox iNumberOfComments & " Comment(s) Deleted.", vbInformation, cORA_DIALOG_CAPTION
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DeleteAllComments", Err.Description)
Err.Clear
End Sub
Function DeleteAllCommentsInDoc(Optional doc As Document) As Boolean
Dim iNumberOfComments As Integer
Dim i As Integer
If doc Is Nothing Then
    Set doc = ActiveDocument
End If
On Error GoTo ERR_HANDLER
iNumberOfComments = doc.Comments.Count
For i = iNumberOfComments To 1 Step -1
    doc.Comments(i).Delete
Next i
DeleteAllCommentsInDoc = True
Exit Function
ERR_HANDLER:
DeleteAllCommentsInDoc = False
End Function
Sub UnlinkAllHyperlinks()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to unlink ALL hyperlinks?", _
            vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If UnlinkAllHyperlinksInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("UnlinkAllHyperlinks", Err.Description)
End Sub

Sub DeleteAllFigures()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to delete ALL figures?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If DeleteAllFiguresInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DeleteAllFigures", Err.Description)
End Sub
Sub DeleteAllBookmarks()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to delete ALL bookmarks?", _
            vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If DeleteAllBookmarksInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DeleteAllBookmarks", Err.Description)
End Sub
Function UnlinkAllHyperlinksInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim oHyperlink As Hyperlink
Dim i As Integer
Dim rng As Range
Dim bHasHyperlinks As Boolean
Dim oStoryRange As Range

If doc Is Nothing Then Set doc = ActiveDocument

For Each oStoryRange In doc.StoryRanges
    If oStoryRange.Hyperlinks.Count <> 0 Then
        bHasHyperlinks = True
        Exit For
    End If
Next oStoryRange

If Not bHasHyperlinks Then
    UnlinkAllHyperlinksInDoc = True
    Exit Function
End If

For Each oStoryRange In doc.StoryRanges
    If oStoryRange.Hyperlinks.Count <> 0 Then
        For i = oStoryRange.Hyperlinks.Count To 1 Step -1
            Set oHyperlink = oStoryRange.Hyperlinks(i)
            Set rng = oHyperlink.Range
            oHyperlink.Delete
            rng.Style = wdStyleHyperlink
        Next i
    End If
Next oStoryRange
UnlinkAllHyperlinksInDoc = True
Exit Function
ERR_HANDLER:
UnlinkAllHyperlinksInDoc = False
End Function
Function DeleteAllFiguresInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim shp As InlineShape
Dim rng As Range
Dim para As Paragraph
Dim i As Integer
If doc Is Nothing Then Set doc = ActiveDocument
If doc.InlineShapes.Count = 0 Then
    DeleteAllFiguresInDoc = True
    Exit Function
End If
For i = doc.InlineShapes.Count To 1 Step -1
    doc.InlineShapes(i).Delete
Next i
If (Config.ShouldDeleteFigHolderTextWithFigure) Then
    For Each para In doc.Paragraphs
        Set rng = para.Range
        If rng.Style = doc.Styles(cFIGURE_HOLDER_STYLE) _
            And rng.Characters.Count > 1 Then
                rng.MoveEnd unit:=wdCharacter, Count:=-1
                rng.Delete
        End If
    Next para
End If
DeleteAllFiguresInDoc = True
Exit Function
ERR_HANDLER:
DeleteAllFiguresInDoc = False
End Function

Function DeleteAllBookmarksInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim i As Integer
If doc Is Nothing Then Set doc = ActiveDocument
For i = doc.Bookmarks.Count To 1 Step -1
    doc.Bookmarks(i).Delete
Next i
DeleteAllBookmarksInDoc = True
Exit Function
ERR_HANDLER:
DeleteAllBookmarksInDoc = False
End Function
Sub DeleteAllEmptyBodyParagraphs()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to delete ALL empty body paragraphs?", _
            vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If DeleteAllEmptyBodyParagraphsInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DeleteAllEmptyBodyParagraphs", Err.Description)

End Sub

Function DeleteAllEmptyBodyParagraphsInDoc(Optional doc As Document) As Boolean
Dim para As Paragraph
Dim paraNext As Paragraph
Dim bTrackChanges As Boolean
If doc Is Nothing Then Set doc = ActiveDocument
bTrackChanges = doc.TrackRevisions
doc.TrackRevisions = False
Set para = doc.Paragraphs.First
Do While Not para Is Nothing
    Set paraNext = para.Next
    If para.Range.Characters.Count = 1 Then
        If para.Style = doc.Styles(wdStyleBodyText) Or para.Style = doc.Styles(wdStyleNormal) Then
            para.Range.Delete
        End If
    End If
    Set para = paraNext
Loop
doc.TrackRevisions = bTrackChanges
DeleteAllEmptyBodyParagraphsInDoc = True
Exit Function
ERR_HANDLER:
DeleteAllEmptyBodyParagraphsInDoc = False
End Function
Sub PasteAsCode()
On Error GoTo ERR_HANDLER
Dim sel As Selection
Dim rng As Range
Dim rngOriginal As Range
Dim para As Paragraph
Dim lCodeTabs As Long
Dim styCodeStyle As Style
'========== Settings and Messages ==========
Dim sCodeStyleName As String
sCodeStyleName = "Code"
'===========================================
Set sel = Selection
Set rngOriginal = sel.Range.Duplicate
Set styCodeStyle = sel.Document.Styles(sCodeStyleName)
Call Config.CheckDocumentVariables(sel.Document)
lCodeTabs = sel.Document.Variables(cCUSTOM_PROP_TAB_SPACES)

sel.PasteSpecial Link:=False, _
  DataType:=wdPasteText, _
  Placement:=wdInLine, _
  DisplayAsIcon:=False

Set rng = sel.Document.Range(rngOriginal.Start, sel.End + 1)

With rng.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .MatchCase = False
    .MatchWildcards = False
    .Forward = True
    .Format = False
    .Wrap = wdFindStop
    .Text = "^t"
    .Replacement.Text = String(lCodeTabs, cSPACE)
    .Execute Replace:=wdReplaceAll
End With

For Each para In rng.Paragraphs
    para.Style = styCodeStyle
Next para
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("PasteAsCode", Err.Description)
End Sub
Sub RemoveDoubleSpaces()
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to replace double spaces with single ones (Code paragraphs are ignored)?", _
    vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If RemoveDoubleSpacesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("RemoveDoubleSpaces", Err.Description)
End Sub
Function RemoveDoubleSpacesInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim vIgnoreStyles As Variant
Dim v As Variant
Dim sty As Style
If doc Is Nothing Then Set doc = ActiveDocument
For Each sty In doc.Styles
    If sty.Type = wdStyleTypeCharacter Or _
       sty.Type = wdStyleTypeParagraph Then
        If Not sty.NameLocal = "Default Paragraph Font" Then
            If InStr(sty.NameLocal, "Code") = 0 Then
                With doc.Range.Find
                        .ClearFormatting
                        .Text = String(2, cSPACE)
                        .Style = sty.NameLocal
                        .Replacement.Text = cSPACE
                        .Forward = True
                        .Wrap = wdFindContinue
                        .Format = True
                        .MatchCase = False
                        .MatchWholeWord = False
                        .MatchWildcards = False
                        .MatchSoundsLike = False
                        .MatchAllWordForms = False
                        .Execute Replace:=wdReplaceAll
                End With
            End If
        End If
    End If
Next sty
RemoveDoubleSpacesInDoc = True
Exit Function
ERR_HANDLER:
RemoveDoubleSpacesInDoc = False
End Function
Function AcceptAllRevisionsInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
If doc Is Nothing Then Set doc = ActiveDocument
doc.AcceptAllRevisions
AcceptAllRevisionsInDoc = True
Exit Function
ERR_HANDLER:
AcceptAllRevisionsInDoc = False
End Function
Sub AcceptAllRevisions()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Accept ALL Revisions without review?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If AcceptAllRevisionsInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("AcceptAllRevisions", Err.Description)
End Sub
Sub ListCommentsInDocument()
On Error GoTo ERR_HANDLER
Dim docActive As Document
Dim docComments As Document
Dim c As Comment

Set docActive = ActiveDocument
For Each c In docActive.Comments
    If docComments Is Nothing Then
        Set docComments = Documents.Add
    End If
    docComments.Range.InsertAfter _
        c.Author & ": " & c.Range.Text & vbCr & vbCr
Next c
Set docActive = Nothing
Set docComments = Nothing
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ListCommmentsInDocument", Err.Description)
Err.Clear
End Sub
Sub MakeOutlineOnlyCopyOfCurrentDoc()
On Error GoTo ERR_HANDLER
Dim docFull As Document
Dim docOutline As Document
Dim lngMaxLevel As Integer
Dim strUserInput As String
Dim para As Paragraph

lngMaxLevel = 4
Set docFull = ActiveDocument

Application.ScreenUpdating = False

Do
   strUserInput = InputBox("Create an outline-only copy of this document " & _
                           "to what level (1-9)?", _
                  cORA_DIALOG_CAPTION, _
                  lngMaxLevel)
   If Len(strUserInput) = 0 Then Exit Sub

   If Not strUserInput Like "[1-9]" Then
   MsgBox Chr(34) & strUserInput & Chr(34) & " is not a valid Outline Level.", _
          vbInformation, cORA_DIALOG_CAPTION
   End If
Loop Until strUserInput Like "[1-9]"

lngMaxLevel = CLng(strUserInput)

Set docOutline = Documents.Add
StatusBar = "Collecting outline information. Please wait ..."

For Each para In docFull.Paragraphs
   If para.OutlineLevel <= lngMaxLevel Then
       para.Range.Copy
       docOutline.Range(docOutline.Range.End - 1).Paste
   End If
Next para

StatusBar = vbNullString
docOutline.Activate
Application.ScreenUpdating = True
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("MakeOutlineOnlyCopyOfCurrentDoc", Err.Description)
Err.Clear
End Sub
Sub ListKeyBindings()
On Error GoTo ERR_HANDLER
Dim kb As KeyBinding
Dim var As Variant
Dim rng As Range
Dim sKeyBindings As String
Dim docKeyBindings As Document
Dim docActive As Document

If VBAUtilities.IsThisAMac = True Then
    MsgBox _
      "You're working on a Mac (you probably already knew that). " & _
      "As much as we tried, there were a few things that just wouldn't work " & _
      "on a Mac, and listing the keyboard shortcuts from a macro was one of them." & vbCr & vbCr & _
      "There's a list of commands in the documentation that came " & _
      "with the template. If that's missing, send email to: " & cTOOLS_EMAIL, _
      vbInformation, _
      cORA_DIALOG_CAPTION
      Exit Sub
End If

Set docActive = ActiveDocument
Application.ScreenUpdating = False
StatusBar = "Collecting Key Commands ..."
Set docKeyBindings = Documents.Add(Template:=docActive.AttachedTemplate.Name)
CustomizationContext = docActive.AttachedTemplate
sKeyBindings = "Command/Style" & vbTab & "Shortcut" & vbCr

For Each kb In Application.KeyBindings
    var = Split(kb.Command, ".")
    sKeyBindings = sKeyBindings & _
        Split(var(UBound(var)), cSTYLEALIAS_DELIMITER)(0) & _
        vbTab & _
        kb.KeyString & _
        vbCr
Next kb
Set rng = docKeyBindings.Range
With rng
    .Collapse wdCollapseEnd
    .InsertAfter sKeyBindings
    .ConvertToTable Separator:=vbTab, Format:=wdTableFormatWeb1
    .Rows.First.Range.Font.Bold = True
End With
Set rng = docKeyBindings.Paragraphs(2).Range
rng.MoveEnd unit:=wdCharacter, Count:=-1
rng.Text = "ORA Template Keyboard Shortcuts"
Application.ScreenUpdating = True
StatusBar = vbNullString
Exit Sub
ERR_HANDLER:
StatusBar = vbNullString
Call ErrorHandler.ModuleErrorCatcher("ListKeyBindings", Err.Description)
Err.Clear
End Sub
Function ConvertCommentsToTextInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim k As Integer
Dim rngCommentReference As Range
Dim rngComment As Range
Dim oComment As Comment
Dim rng As Range

'========== Settings and messges ==========
Dim sCommentStyleName As String
sCommentStyleName = "Comment"
'==========================================
If doc Is Nothing Then Set doc = ActiveDocument
For k = doc.Comments.Count To 1 Step -1
    Set oComment = doc.Comments(k)
    Set rngCommentReference = oComment.Reference
    Set rng = rngCommentReference.Paragraphs.Last.Range.Duplicate
    With rng
        .Paragraphs.Add
        .MoveStart unit:=wdParagraph
        .Collapse wdCollapseStart
        .FormattedText = oComment.Range.FormattedText
        .Paragraphs.Style = sCommentStyleName
        .Collapse wdCollapseEnd
        .Select
        .InsertAfter " -- " & oComment.Author
    End With
    oComment.Delete
Next k
ConvertCommentsToTextInDoc = True
Exit Function
ERR_HANDLER:
ConvertCommentsToTextInDoc = False
End Function

Sub ConvertWordCommentsToStyledText()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to convert ALL Word comments to styled text?", _
            vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If ConvertCommentsToTextInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ConvertWordCommentstoStyledText", Err.Description)
End Sub
Function DeleteSectionBreaksInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
If doc Is Nothing Then Set doc = ActiveDocument
With doc.Range.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .Text = "^b"
    .Replacement.Text = vbNullString
    .Forward = True
    .Wrap = wdFindContinue
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .Execute Replace:=wdReplaceAll
End With
DeleteSectionBreaksInDoc = True
Exit Function
ERR_HANDLER:
DeleteSectionBreaksInDoc = False
End Function
Sub DeleteAllSectionBreaks()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to delete ALL section breaks?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If DeleteSectionBreaksInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DeleteAllSectionBreaks", Err.Description)
End Sub
Sub ConvertAllFieldsToText()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to convert ALL fields to text? (Hyperlinks will be left as-is)", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If ConvertAllFieldsToTextInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ConvertAllFieldsToText", Err.Description)
End Sub
Function ConvertAllFieldsToTextInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim fld As Field
Dim fldNext As Field
If doc Is Nothing Then Set doc = ActiveDocument
If doc.Fields.Count = 0 Then
    ConvertAllFieldsToTextInDoc = True
    Exit Function
End If
Set fld = doc.Fields(1)
Do While Not fld Is Nothing
    Set fldNext = fld.Next
    If Not fld.Type = wdFieldHyperlink Then
        fld.Unlink
    End If
    Set fld = fldNext
Loop
ConvertAllFieldsToTextInDoc = True
Exit Function
ERR_HANDLER:
ConvertAllFieldsToTextInDoc = False
End Function
Function DeleteAllIndexMarkersInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim fld As Field
Dim fldNext As Field
If doc Is Nothing Then Set doc = ActiveDocument
If doc.Fields.Count = 0 Then
    DeleteAllIndexMarkersInDoc = True
    Exit Function
End If
Set fld = doc.Fields(1)
Do While Not fld Is Nothing
    Set fldNext = fld.Next
        If fld.Type = wdFieldIndexEntry Then
         fld.Delete
        End If
    Set fld = fldNext
Loop

DeleteAllIndexMarkersInDoc = True
Exit Function
ERR_HANDLER:
DeleteAllIndexMarkersInDoc = False
    
End Function
Sub DeleteAllIndexMarkers()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to delete ALL Index markers?", _
        vbYesNo, cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If DeleteAllIndexMarkersInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("DeleteAllIndexMarkers", Err.Description)
End Sub
Attribute VB_Name = "ErrorHandler"
Option Explicit
Function ModuleErrorCatcher(sProcedureName As String, sErrType As String)
MsgBox "An error has occurred in: " & sProcedureName & vbCrLf & vbCrLf & _
       "VBA reports the error as: " & vbCrLf & sErrType & vbCrLf & vbCrLf & _
       "If you continue to experience problems, please contact" & vbCrLf & _
       "the O'Reilly Tools group: " & cTOOLS_EMAIL & ".", _
       vbExclamation, _
       cORA_DIALOG_CAPTION
Err.Clear
End Function

Function ClassErrorCatcher(sClassName, sProcedureName As String, sErrType As String)
MsgBox "An error has occurred in the " & _
        sProcedureName & _
        " procedure in the " & _
        sClassName & _
        " class." & _
        vbCrLf & _
        vbCrLf & _
        "VBA reports the error as: " & _
        vbCrLf & _
        sErrType & _
        vbCrLf & _
        vbCrLf & _
        "If you continue to experience problems, please contact" & _
        vbCrLf & _
        "the O'Reilly Tools group: " & cTOOLS_EMAIL & ".", _
        vbExclamation, _
        cORA_DIALOG_CAPTION
Err.Clear
End Function

Function BadBookmark(sBookmarkName As String)
MsgBox "An error occurred while trying to create a bookmark using the text:" & vbCrLf & _
       sBookmarkName & vbCrLf & _
       "I'm sorry, but you won't be able to create a cross reference to the desired text." & vbCrLf & _
       "It appears that it contains some special characters.", _
       vbExclamation, _
       cORA_DIALOG_CAPTION
Err.Clear
End Function
Attribute VB_Name = "Figures"
Option Explicit


Function InsertFigure() As Boolean
On Error GoTo ERR_HANDLER
Dim dial As Dialog
Dim sFileName As String
Dim sel As Selection
Dim styFigureHolder As Style
Dim bFileNameNotFig As Boolean

'=========== Settings and Messages ==============
Dim sMessageSelectionNotEmpty As String
Dim sFigureHolderStyleName As String

sFigureHolderStyleName = "FigureHolder"

sMessageSelectionNotEmpty = _
     "Insertion point must be in an empty paragraph to insert a picture"

'================================================


Set sel = Selection
Set styFigureHolder = sel.Document.Styles(sFigureHolderStyleName)
Call Config.CheckDocumentVariables(sel.Document)
bFileNameNotFig = sel.Document.Variables(cCUSTOM_PROP_INSERT_FILENAME_NOT_FIGURE)

If (sel.Range.Paragraphs.Count > 1 Or _
    sel.Range.Paragraphs.First.Range.Characters.Count > 1) Then
    MsgBox sMessageSelectionNotEmpty, _
            vbInformation, _
            cORA_DIALOG_CAPTION
    InsertFigure = False
    Exit Function
End If
sel.Collapse wdCollapseStart

Set dial = Dialogs(wdDialogInsertPicture)

If dial.Display = 0 Then
    InsertFigure = False
    Exit Function
End If

sFileName = dial.Name

If (bFileNameNotFig) Then
    
    sFileName = VBAUtilities.GetFileName(sFileName, Application.PathSeparator)
    sel.TypeText "[" & sFileName & "]"
Else
    sel.InlineShapes.AddPicture FileName:=sFileName, _
                                LinkToFile:=True, _
                                SaveWithDocument:=True
End If
sel.Range.Paragraphs.First.Style = styFigureHolder
InsertFigure = True
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("InsertPicture", Err.Description)
Err.Clear
InsertFigure = False
End Function
Sub InsertFigureWithCaption()
On Error GoTo ERR_HANDLER
Dim sel As Selection
Dim rng As Range
Dim styFigureCaption As Style


'=========== Settings and Messages ==============
Dim sMessageSelectionNotEmpty As String
Dim sFigureCaptionStyleName As String

sFigureCaptionStyleName = "FigureTitle"

sMessageSelectionNotEmpty = _
     "Insertion point must be in an empty paragraph to insert a picture"

'================================================

Set sel = Selection
If VBAUtilities.IsInsertionPointInEmptyParagraph(sel) = False Then
    MsgBox sMessageSelectionNotEmpty, _
            vbInformation, _
            cORA_DIALOG_CAPTION
    Exit Sub
End If

Set rng = sel.Range
Set styFigureCaption = sel.Document.Styles(sFigureCaptionStyleName)

If Figures.InsertFigure = False Then
    Exit Sub
End If

sel.Collapse wdCollapseEnd
sel.InsertAfter vbCrLf
sel.Collapse wdCollapseEnd

Call Captions.InsertFigureCaption
sel.Range.Style = styFigureCaption

Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("InsertPicture", Err.Description)
Err.Clear
End Sub

Sub GenerateFigureList()

Dim lResponse As Long


'========== Settings and Messages =========
Dim bShowFileNameNotFigure As Boolean
Dim sMessage As String

bShowFileNameNotFigure = False

sMessage = "A list of figures and their captions will be created in a new document. " & vbCr & _
    "Put the actual figures in the list? (Press No to insert the file name instead of the figure)"
'=========================================

lResponse = MsgBox(sMessage, vbYesNoCancel + vbQuestion, cORA_DIALOG_CAPTION)

Select Case lResponse
    Case vbCancel
        Exit Sub
    Case vbNo
        bShowFileNameNotFigure = True
End Select

If GenerateFigureListFromDoc(ActiveDocument, bShowFileNameNotFigure) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("GenerateFigureList", Err.Description)
Err.Clear
End Sub

Function GenerateFigureListFromDoc(Optional doc As Document, Optional bShowFileNameNotFigure As Boolean = False) As Boolean
Dim docActive As Document
Dim docFigList As Document
Dim rngFigList As Range
Dim rng As Range
Dim tbl As Table
Dim fld As Field
Dim shp As InlineShape
Dim para As Paragraph
Dim sParaStyleName As String
Dim k As Integer
Dim sExt As String
Dim sStylesToCopy As String
Dim sFigureHolderStyle As String

sStylesToCopy = "/ChapterLabel/ChapterTitle/FigureHolder/FigureTitle/"
sFigureHolderStyle = "FigureHolder"
Dim v As Variant

On Error GoTo ERR_HANDLER
If doc Is Nothing Then Set doc = ActiveDocument
Set docActive = doc
Set docFigList = Documents.Add
Set rngFigList = docFigList.Range

For Each para In docActive.Paragraphs
    sParaStyleName = para.Style.NameLocal
    sParaStyleName = "/" & Split(sParaStyleName, cSTYLEALIAS_DELIMITER)(0) & "/"
    If InStr(sStylesToCopy, sParaStyleName) <> 0 Then
        para.Range.Copy
        rngFigList.Collapse wdCollapseEnd
        rngFigList.Paste
    End If
Next para

If (bShowFileNameNotFigure) Then
    On Error Resume Next
    For Each shp In docFigList.InlineShapes
        Set rng = shp.Range
        rng.Text = "[" & shp.LinkFormat.SourceName & "]"
        If Err.Number = 0 Then
            rng.Collapse wdCollapseEnd
            rng.Style = sFigureHolderStyle
        ElseIf Err.Number = cERR_NOTLINKEDIMAGE Then
            rng.Text = "[" & cFIGURE_NOT_LINKED & "]"
            Err.Clear
        Else
            GoTo ERR_HANDLER
        End If
    Next shp
End If

Set rng = docFigList.Range.Duplicate
Do Until rng.Paragraphs.First.Style = docFigList.Styles(sFigureHolderStyle)
    rng.MoveStart unit:=wdParagraph
    If rng.Paragraphs.Count = 1 Then Exit Do
Loop

rng.ConvertToTable Separator:=vbCr, numcolumns:=2, Format:=wdTableFormatWeb1
rng.Style = wdStyleBodyText

Set tbl = docFigList.Tables(1)

tbl.Columns.Add

For k = 1 To tbl.Rows.Count
    Set rng = tbl.Rows(k).Cells(3).Range
    tbl.Rows(k).Cells(1).Range.Select
    If bShowFileNameNotFigure Then
        sExt = tbl.Rows(k).Cells(1).Range.Text
        sExt = Left(sExt, Len(sExt) - 2)
        sExt = Mid(sExt, 2, Len(sExt) - 2)
    Else
        tbl.Rows(k).Cells(1).Range.Select
        sExt = tbl.Rows(k).Cells(1).Range.InlineShapes(1).LinkFormat.SourceName
    End If
    If InStr(sExt, cFIGURE_NOT_LINKED) = 0 Then
        sExt = Split(sExt, ".")(1)
    Else
        sExt = "tif"
    End If
    With rng
        .MoveEnd unit:=wdCharacter, Count:=-1
        If Len(sExt) <> 0 Then
            .InsertAfter "." & sExt
        Else
            .InsertAfter ".eps"
        End If
        .Collapse wdCollapseStart
        .Fields.Add Range:=rng, _
            Type:=wdFieldEmpty, _
            Text:="seq fignum \# 0#", _
            preserveformatting:=False
        .Fields.Add Range:=rng, _
            Type:=wdFieldEmpty, _
            Text:="styleref chapterlabel,cl \# 0#", _
            preserveformatting:=False
    End With
Next k

docFigList.Fields.Update
docFigList.Fields.Unlink

Call EditingTools.DeleteAllBookmarksInDoc(docFigList)
With tbl
    .Rows.Add beforerow:=tbl.Rows(1)
    .Rows(1).Cells(1).Range.Text = "Current Filename"
    .Rows(1).Cells(2).Range.Text = "Caption"
    .Rows(1).Cells(3).Range.Text = "To-Production Filename"
    .Rows(1).Range.Font.Bold = True
End With
tbl.AutoFitBehavior wdAutoFitWindow
GenerateFigureListFromDoc = True
Exit Function
ERR_HANDLER:
GenerateFigureListFromDoc = False
End Function
Attribute VB_Name = "FormattingRepair"
Option Explicit


Function FixCharCharStylesInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sty As Style
Dim i As Integer

Dim sStyleName As String
Dim sStyleReName As String
Dim bCharCharFound As Boolean
If doc Is Nothing Then Set doc = ActiveDocument
Do
    bCharCharFound = False
    For i = doc.Styles.Count To 1 Step -1
        Set sty = doc.Styles(i)
        sStyleName = sty.NameLocal
        If sStyleName Like "* Char*" Then
            bCharCharFound = True
            If sty.Type = wdStyleTypeCharacter Then
                Call StripStyleKeepFormatting(sty, doc)
                If Int(Application.Version) >= 10 Then
                    If VBAUtilities.IsThisAMac = False Then
                        Call VersionSpecific.UnlinkStyle(sty)
                    End If
                End If
                sty.Delete
                Err.Clear
            Else
                sStyleReName = Replace(sStyleName, " Char", vbNullString)
                On Error Resume Next
                sty.NameLocal = sStyleReName
                If Err.Number = cERR_NODELETEBUILTIN Then
                    Call SwapStyles(doc.Styles(sStyleName), doc.Styles(sStyleReName), doc)
                    sty.Delete
                    Err.Clear
                Else
                    On Error GoTo ERR_HANDLER
                End If
            End If
            Exit For
        End If
        Set sty = Nothing
    Next i
Loop While bCharCharFound = True
FixCharCharStylesInDoc = True
Exit Function
ERR_HANDLER:
FixCharCharStylesInDoc = False
End Function
Sub FixCharCharStyles()
On Error GoTo ERR_HANDLER
Dim lResponse As Long
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("This macro will remove any Char Char styles from the document." & vbCr & _
              "Are you sure you want to continue?", _
            vbYesNo, _
            cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If FixCharCharStylesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then
    lResponse = MsgBox("Linked Char Char styles have been removed. To be sure that no formatting " & _
                       "is lost, you should probably run the macro that replaces any direct character " & _
                       "formatting with an appropriate character style. Would you like to do that now? (Recommended)", _
                       vbYesNo + vbQuestion, _
                       cORA_DIALOG_CAPTION)
    If lResponse = vbYes Then
        Call FormattingRepair.FixManuallyAppliedInlineFormatting
    End If
End If

Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("FixCharCharStyles", Err.Description)
End Sub

Sub FindAndTagURLs()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("This macro will attempt to find and properly tag URLs. Its matching algorithm " & _
              "is only as good as Word's wildcard feature, and we can't promise 100% accuracy." & vbCr & _
              "Are you sure you want to continue?", _
            vbYesNo, _
            cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If FixURLsInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("FindAndTagURLs", Err.Description)
End Sub

Function SwapStyles(ByRef styFind As Style, ByRef styReplace As Style, ByRef doc As Document)
With doc.Range.Find
    .ClearFormatting
    .Text = vbNullString
    .Wrap = wdFindContinue
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
    .Style = styFind
    .Replacement.ClearFormatting
    .Replacement.Style = styReplace
    .Replacement.Text = "^&"
    .Execute Replace:=wdReplaceAll
End With
End Function

Function StripStyleKeepFormatting(ByRef sty As Style, ByRef doc As Document)
Dim rngToSearch As Range
Dim rngResult As Range
Dim f As Font

If Not sty.Type = wdStyleTypeCharacter Then
    MsgBox "Must be a char style"
    Exit Function
End If

Set rngToSearch = doc.Range
Set rngResult = rngToSearch.Duplicate

Do
    With rngResult.Find
        .ClearFormatting
        .Style = sty
        .Text = vbNullString
        .Forward = True
        .Wrap = wdFindStop
        .Execute
    End With
    
    If Not rngResult.Find.Found Then Exit Do
    
    Set f = rngResult.Font.Duplicate
    With rngResult
        .Font.Reset
        .Font = f
        .MoveStart wdWord
        .End = rngToSearch.End
    End With
    Set f = Nothing
Loop Until Not rngResult.Find.Found
End Function
Public Function HideInDoc(sty As Style) As Boolean
CustomizationContext = Documents(sty.Parent)
sty.Font.Hidden = True
End Function
Public Function UnHideInDoc(sty As Style) As Boolean
CustomizationContext = Documents(sty.Parent)
sty.Font.Hidden = False
End Function
Function FixURLsInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER

Dim sSearchPattern As String
Dim rngToSearch As Range
Dim rngResult As Range
sSearchPattern = "[ (][htp:/wf.]{3,4}[! ,)(^013^019]@[ ,)(^013^019]"
If doc Is Nothing Then Set doc = ActiveDocument
Set rngToSearch = doc.Range
Set rngResult = rngToSearch.Duplicate

Do
    With rngResult.Find
        .ClearFormatting
        .Text = sSearchPattern
        .Forward = True
        .MatchWildcards = True
        .Wrap = wdFindStop
        .Execute
    End With
    
    If rngResult.Find.Found = False Then
        Exit Do
    End If
    With rngResult
        
        .MoveEnd unit:=wdCharacter, Count:=-1
        .MoveStart unit:=wdCharacter, Count:=1
        .Font.Reset
        .Style = doc.Styles(wdStyleHyperlink)
        If .Information(wdWithInTable) = True Then
            .MoveStart unit:=wdRow, Count:=1
        Else
            .MoveStart unit:=wdWord, Count:=2
        End If
      
        .End = rngToSearch.End
  
    End With
Loop Until rngResult.Find.Found = False

FixURLsInDoc = True
Exit Function
ERR_HANDLER:
FixURLsInDoc = False
End Function

Sub FixFootnoteReferences()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Turn all footnote references in this document to superscript?", _
            vbYesNo, _
            cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If FixFootnoteReferencesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("FixFootnoteReferences", Err.Description)
End Sub
Function FixFootnoteReferencesInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim fnote As Footnote
If doc Is Nothing Then Set doc = ActiveDocument
'=========== Settings and Messages ==========
Dim styFootnoteReferenceStyle

Set styFootnoteReferenceStyle = _
    doc.Styles(wdStyleFootnoteReference)
'============================================

For Each fnote In doc.Footnotes
    fnote.Reference.Style = styFootnoteReferenceStyle
Next fnote
FixFootnoteReferencesInDoc = True
Exit Function
ERR_HANDLER:
FixFootnoteReferencesInDoc = False
End Function
Sub ReplaceCodeTabsWithSpaces()
On Error GoTo ERR_HANDLER
Dim lTabSetting As Long
Dim sNewTabSetting As String
Dim doc As Document
Set doc = ActiveDocument

Call Config.CheckDocumentVariables(doc)
lTabSetting = doc.CustomDocumentProperties(cCUSTOM_PROP_TAB_SPACES)

sNewTabSetting = InputBox("Replace tabs in Code with how many spaces?" & vbCr & _
                        "(Must be between 1 and 9)", _
                        cORA_DIALOG_CAPTION, _
                        lTabSetting)

If Len(sNewTabSetting) = 0 Then Exit Sub

If Not sNewTabSetting Like "[1-9]" Then
    MsgBox "Must be a number between 1 and 9"
    Set doc = Nothing
    Exit Sub
End If

lTabSetting = CLng(sNewTabSetting)
doc.CustomDocumentProperties(cCUSTOM_PROP_TAB_SPACES) = lTabSetting
If ReplaceCodeTabsWithSpacesInDoc(doc, lTabSetting) = False Then
    GoTo ERR_HANDLER
End If
MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ReplaceCodeTabsWithSpaces", Err.Description)
Err.Clear
End Sub
Function ReplaceCodeTabsWithSpacesInDoc(Optional doc As Document, Optional lNumSpaces As Long = 4) As Boolean
On Error GoTo ERR_HANDLER
Dim vCodeStyles As Variant
Dim v As Variant
'================================
' What qualifies as "Code" is defined here:
vCodeStyles = Array("Code", _
                    "CodeEmphasis", _
                    "CodeNum")
'================================

With doc.Range.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .MatchCase = False
    .MatchWildcards = False
    .Forward = True
    .Text = "^t"
    .Replacement.Text = String(lNumSpaces, cSPACE)
    For Each v In vCodeStyles
        .Style = CStr(v)
        .Execute Replace:=wdReplaceAll
    Next v
End With

Set doc = Nothing
ReplaceCodeTabsWithSpacesInDoc = True
Exit Function
ERR_HANDLER:
ReplaceCodeTabsWithSpacesInDoc = False
Exit Function
End Function

Function FixQuotesInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sty As Style
Dim sStyName As String
Dim oORAStyles As ORAStyles
Dim bReplaceQuotes As Boolean
Set oORAStyles = New ORAStyles
bReplaceQuotes = Options.AutoFormatAsYouTypeReplaceQuotes
If doc Is Nothing Then Set doc = ActiveDocument
For Each sty In doc.Styles
    If sty.Type = wdStyleTypeParagraph Then
        If oORAStyles.Exists(sty.NameLocal) Then
            sStyName = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
            If oORAStyles.Item(sStyName).TypographerQuotes = True Then
                Options.AutoFormatAsYouTypeReplaceQuotes = True
                With doc.Range.Find
                    .ClearFormatting
                    .Format = True
                    .Replacement.ClearFormatting
                    .Style = sty
                    .Text = """"
                    .Replacement.Text = """"
                    .Execute Replace:=wdReplaceAll
                    
                    .Text = "'"
                    .Replacement.Text = "'"
                    .Execute Replace:=wdReplaceAll
                    
                End With
            Else
                Options.AutoFormatAsYouTypeReplaceQuotes = False
                With doc.Range.Find
                    .ClearFormatting
                    .Format = True
                    .Replacement.ClearFormatting
                    .Style = sty
                    .Text = """"
                    .Replacement.Text = """"
                    .Execute Replace:=wdReplaceAll
                    
                    .Text = "'"
                    .Replacement.Text = "'"
                    .Execute Replace:=wdReplaceAll
                End With
            End If
        End If
    End If
Next sty

'===
For Each sty In doc.Styles
    If sty.Type = wdStyleTypeCharacter Then
        If oORAStyles.Exists(sty.NameLocal) Then
            sStyName = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
            If oORAStyles.Item(sStyName).TypographerQuotes = True Then
                Options.AutoFormatAsYouTypeReplaceQuotes = True
                With doc.Range.Find
                    .ClearFormatting
                    .Format = True
                    .Replacement.ClearFormatting
                    .Style = sty
                    .Text = """"
                    .Replacement.Text = """"
                    .Execute Replace:=wdReplaceAll
                    
                    .Text = "'"
                    .Replacement.Text = "'"
                    .Execute Replace:=wdReplaceAll
                    
                End With
            Else
                Options.AutoFormatAsYouTypeReplaceQuotes = False
                With doc.Range.Find
                    .ClearFormatting
                    .Format = True
                    .Replacement.ClearFormatting
                    .Style = sty
                    .Text = """"
                    .Replacement.Text = """"
                    .Execute Replace:=wdReplaceAll
                    
                    .Text = "'"
                    .Replacement.Text = "'"
                    .Execute Replace:=wdReplaceAll
                End With
            End If
        End If
    End If
Next sty
'===
Options.AutoFormatAsYouTypeReplaceQuotes = bReplaceQuotes
FixQuotesInDoc = True
Exit Function
ERR_HANDLER:
FixQuotesInDoc = False
End Function
Sub FixTypographerQuotes()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Are you sure you want to check and fix typographer (smart) quotes?", _
            vbYesNo, _
            cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If FixQuotesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("FixTypographerQuotes", Err.Description)
End Sub
Sub ResetStyleNames()
On Error GoTo ERR_HANDLER
If ResetStylesToTemplateDefaultsInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ResetStyleNames", Err.Description)
End Sub
Function ResetStylesToTemplateDefaultsInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
If doc Is Nothing Then Set doc = ActiveDocument
Call ToolsDeptUse.StripStyleAliasesInDoc(doc)
doc.UpdateStyles
ResetStylesToTemplateDefaultsInDoc = True
Exit Function
ERR_HANDLER:
ResetStylesToTemplateDefaultsInDoc = False
End Function
Function AnyDiffFontsInPara(para As Paragraph) As Boolean
Dim lDiffBold As Long
Dim lDiffItal As Long
Dim lDiffSize As Long
Dim sDiffName As String

AnyDiffFontsInPara = False

With para.Range.Font
    lDiffBold = .Bold
    lDiffItal = .Italic
    lDiffSize = .Size
    sDiffName = .Name
End With

Select Case wdUndefined
    Case lDiffBold
        AnyDiffFontsInPara = True
        Exit Function
     Case lDiffItal
        AnyDiffFontsInPara = True
        Exit Function
     Case lDiffSize
        AnyDiffFontsInPara = True
        Exit Function
End Select

If Len(sDiffName) = 0 Then
     AnyDiffFontsInPara = True
    Exit Function
End If
End Function
Function AnyDiffFontsInWord(wrd As Range, docstyles As Styles) As Boolean
Dim doc As Document

Dim wrdstyle As String
wrdstyle = wrd.Style

Select Case True
    Case (Not wrd.Font.Bold = docstyles(wrdstyle).Font.Bold)
        AnyDiffFontsInWord = True
    Case (Not wrd.Font.Italic = docstyles(wrdstyle).Font.Italic)
        AnyDiffFontsInWord = True
    Case (Not wrd.Font.Name = docstyles(wrdstyle).Font.Name)
        AnyDiffFontsInWord = True
End Select
End Function
Function FixInlineFormattingInWord(wrd As Range, docstyles As Styles)
Dim char As Range
Dim scharstyle As String

For Each char In wrd.Characters
    char.Select
    scharstyle = char.Style

   Select Case True
    Case (Not char.Font.Bold = docstyles(scharstyle).Font.Bold)
         If docstyles(scharstyle).Font.Bold = False Then
          char.Font.Bold = False
          Call ApplyCharStyle(char, cBOLD)
       Else
          char.Font.Bold = True
          Call ApplyCharStyle(char, cBOLD)
       End If
    Case (Not char.Font.Italic = docstyles(scharstyle).Font.Italic)
       If docstyles(scharstyle).Font.Italic = False Then
          char.Font.Italic = False
          Call ApplyCharStyle(char, cITALIC)
       Else
          char.Font.Italic = True
          Call ApplyCharStyle(char, cITALIC)
       End If
    Case (Not char.Font.Name = docstyles(scharstyle).Font.Name)
        If InStr(docstyles(scharstyle).Font.Name, cFONT_STANDARD) <> 0 _
            And InStr(char.Font.Name, cFONT_STANDARD) = 0 _
            And InStr(char.Font.Name, cFONT_CONSTANT_WIDTH) <> 0 Then
                char.Font.Reset
                Call ApplyCode(char)
        Else
            char.Font.Reset
        End If
End Select
Next char
End Function
Sub FixManuallyAppliedInlineFormatting()
On Error GoTo ERR_HANDLER
Dim sMessage As String
Dim bNoDialogs As Boolean
sMessage = "This macro will attempt to replace any manually applied inline formatting, " & _
            "(like Italic or Bold), with an appropriate character style. This may take " & _
            "several minutes. You can view the macro's progress on the status bar." & vbCr & _
            "Are you sure you want to continue?"

bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox(sMessage, _
            vbYesNo, _
            cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If FixManuallyAppliedInlineFormattingInRange(ActiveDocument.Range) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("FixManuallyAppliedInlineFormatting", Err.Description)
End Sub
Sub FixManuallyAppliedInlineFormattingInSelection()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
Dim sMessage As String
sMessage = "This macro will attempt to replace any manually applied inline formatting, " & _
            "(like Italic or Bold), in all paragraphs within the current selection with an appropriate character style. This may take " & _
            "several minutes. You can view the macro's progress on the status bar." & vbCr & _
            "Are you sure you want to continue?"
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox(sMessage, _
            vbYesNo, _
            cORA_DIALOG_CAPTION) = vbNo Then
        Exit Sub
    End If
End If
If FixManuallyAppliedInlineFormattingInRange(Selection.Range) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("FixManuallyAppliedInlineFormattingInSelection", _
                                      Err.Description)
End Sub
Function FixManuallyAppliedInlineFormattingInRange(rng As Range) As Boolean

On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim k As Long
Dim j As Integer
Dim wrd As Range
Dim char As Range
Dim sStatusBarMessage As String
Dim sStatusBarMessagePrefix As String
Dim sStatusBarMessageSuffix As String
Dim lWordCount As Long
Dim lParaCount As Long

    sStatusBarMessagePrefix = "Examining paragraph: "
    sStatusBarMessageSuffix = "% complete) ... Examining words in paragraph:"

k = 0
lParaCount = rng.Paragraphs.Count

For Each para In rng.Paragraphs
    k = k + 1
    
        sStatusBarMessage = sStatusBarMessagePrefix & k & "/" & lParaCount & _
                    " (" & Format((k / lParaCount) * 100, "0.0") & sStatusBarMessageSuffix
        StatusBar = sStatusBarMessage
 
    If AnyDiffFontsInPara(para) Then
        j = 0
        lWordCount = para.Range.Words.Count
        For Each wrd In para.Range.Words
            
            j = j + 1
          
            StatusBar = sStatusBarMessage & j & "/" & lWordCount
            If (AnyDiffFontsInWord(wrd, rng.Parent.Styles)) Then
                Call FixInlineFormattingInWord(wrd, rng.Parent.Styles)
            End If
        Next wrd
    End If
Next para
If Application.Visible Then
    Application.ScreenRefresh
End If
FixManuallyAppliedInlineFormattingInRange = True
Exit Function
ERR_HANDLER:
FixManuallyAppliedInlineFormattingInRange = False
End Function
Function ChangeCodeLinebreaksToParabreaksInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sty As Style
If doc Is Nothing Then Set doc = ActiveDocument
For Each sty In doc.Styles
    If InStr(sty.NameLocal, "Code") <> 0 Then
        With doc.Content.Find
            .Text = "^l"
            .Style = doc.Styles(sty.NameLocal)
            .Replacement.Text = "^p"
            .Forward = True
            .Wrap = wdFindContinue
            .Format = True
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
           .Execute Replace:=wdReplaceAll
        End With
    End If
Next sty
ChangeCodeLinebreaksToParabreaksInDoc = True
Exit Function
ERR_HANDLER:
ChangeCodeLinebreaksToParabreaksInDoc = False
End Function
Function RemoveExtraneousSpacesInNonCodeParasInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sty As Style
If doc Is Nothing Then Set doc = ActiveDocument
If doc Is Nothing Then Set doc = ActiveDocument
For Each sty In doc.Styles
    If InStr(sty.NameLocal, "Code") <> 0 Then
        sty.Font.Hidden = True
    End If
Next sty
    
        With doc.Content.Find
            .Text = " @([! ])"
            .Replacement.Text = " \1"
            .Forward = True
            .Wrap = wdFindContinue
            .Format = True
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = True
            .MatchSoundsLike = False
            .MatchAllWordForms = False
           .Execute Replace:=wdReplaceAll
        End With

For Each sty In doc.Styles
    If InStr(sty.NameLocal, "Code") <> 0 Then
        sty.Font.Hidden = False
    End If
Next sty

RemoveExtraneousSpacesInNonCodeParasInDoc = True
Exit Function
ERR_HANDLER:
RemoveExtraneousSpacesInNonCodeParasInDoc = False
End Function
Sub RemoveExtraneousSpacesInNonCodeParas()
Call RemoveExtraneousSpacesInNonCodeParasInDoc(ActiveDocument)
End Sub
Sub ChangeCodeLinebreaksToParabreaks()
Call ChangeCodeLinebreaksToParabreaksInDoc(ActiveDocument)
End Sub

Sub DeleteExtraSpacesAroundIndexMarkers()
    Call DeleteExtraSpacesAroundIndexMarkersInDoc(ActiveDocument)
End Sub
Function DeleteExtraSpacesAroundIndexMarkersInDoc(Optional doc As Document)
On Error GoTo ERR_HANDLER
If doc Is Nothing Then
    Set doc = ActiveDocument
End If

Dim fld As Field
Dim sel As Selection
Dim rng As Range
Dim bHidden As Boolean
bHidden = doc.ActiveWindow.View.ShowHiddenText
doc.ActiveWindow.View.ShowHiddenText = True

For Each fld In doc.Fields
    If fld.Type = wdFieldIndexEntry Then
        fld.Select
        Set sel = Selection
        Set rng = sel.Range.Next
        If (rng.Text = cSPACE And Asc(rng.Next) = 19) Then
            sel.Cut
            rng.Paste
        End If
    End If
Next fld

doc.ActiveWindow.View.ShowHiddenText = bHidden
DeleteExtraSpacesAroundIndexMarkersInDoc = True
Exit Function
ERR_HANDLER:
DeleteExtraSpacesAroundIndexMarkersInDoc = False
End Function
Sub NewReplaceNonTemplateStyles()
Dim doc As Document
Dim sty As Style
Dim oORAStyles As New ORAStyles
Set doc = ActiveDocument
Dim str As String
For Each sty In doc.Styles
    If sty.Type = wdStyleTypeCharacter Then
        str = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
        If oORAStyles.Exists(str) = False Then
            'If VBAUtilities.IsStyleInUseInDoc(sty.NameLocal, doc) = True Then
                If Not sty = doc.Styles(wdStyleDefaultParagraphFont) Then
                    MsgBox "The style " & sty.NameLocal & " doesn't belong"
                End If
            'End If
        End If
    End If
Next sty

End Sub
Function ReplaceMappedCharacterStylesInDoc(Optional doc As Document) As Boolean
' #$# Experimental function
If doc Is Nothing Then Set doc = ActiveDocument
Dim oORAStyles As New ORAStyles
Dim sty As Style
Dim sStyleShortName As String
Dim sReplacementStyleName As String
For Each sty In doc.Styles
    If sty.Type = wdStyleTypeCharacter Then
        If VBAUtilities.IsStyleInUseInDoc(sty.NameLocal, doc) Then
            sStyleShortName = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
            sReplacementStyleName = ToolsDeptUse.GetReplacementStyleName(sStyleShortName, _
                                                                         cMAPPING_FILE_CHARACTER_STYLES)
            If Len(sReplacementStyleName) <> 0 Then
                Call ReplaceStyleInDoc(sStyleShortName, sReplacementStyleName, doc)
            End If
        End If
    End If
Next sty
End Function
Sub ReplaceMappedCharacterStyles()
' #$# Experimental
Call ReplaceMappedCharacterStylesInDoc(ActiveDocument)
End Sub
Function ReplaceMappedParagraphStylesInDoc(Optional doc As Document) As Boolean
' #$# Experimental function
If doc Is Nothing Then Set doc = ActiveDocument
Dim oORAStyles As New ORAStyles
Dim sty As Style
Dim sStyleShortName As String
Dim sReplacementStyleName As String
For Each sty In doc.Styles
    If sty.Type = wdStyleTypeParagraph Then
        If VBAUtilities.IsStyleInUseInDoc(sty.NameLocal, doc) Then
            sStyleShortName = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
            sReplacementStyleName = ToolsDeptUse.GetReplacementStyleName(sStyleShortName, _
                                                                         cMAPPING_FILE_PARAGRAPH_STYLES)
            If Len(sReplacementStyleName) <> 0 Then
                Call ReplaceStyleInDoc(sStyleShortName, sReplacementStyleName, doc)
            End If
        End If
    End If
Next sty
End Function
Sub ReplaceMappedParagraphStyles()
' #$# Experimental
Call ReplaceMappedParagraphStylesInDoc(ActiveDocument)
End Sub
Sub ReplaceAllMappedStyles()
' #$# Experimental
Call ReplaceMappedCharacterStylesInDoc(ActiveDocument)
Call ReplaceMappedParagraphStylesInDoc(ActiveDocument)
End Sub
Function ReplaceStyleInDoc(ByVal strStyleName As String, _
                           ByVal strReplacementStyleName As String, _
                           doc As Document) As Boolean
' #$# Experimental
Dim stySearch As Style
Dim styReplace As Style

If VBAUtilities.DoesStyleExistInDoc(strStyleName, doc) = False Then
    Exit Function
End If

If VBAUtilities.DoesStyleExistInDoc(strReplacementStyleName, doc) = False Then
    Exit Function
End If

Set stySearch = doc.Styles(strStyleName)
Set styReplace = doc.Styles(strReplacementStyleName)

If Not stySearch.Type = styReplace.Type Then Exit Function

With doc.Range.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .Format = True
    .MatchCase = False
    .MatchWholeWord = False
    .Forward = True
    .Wrap = wdFindContinue
    .Style = doc.Styles(strStyleName)
    .Replacement.Style = doc.Styles(strReplacementStyleName)
    .Execute Replace:=wdReplaceAll
End With
End Function
Sub FixArrowsInDoc()

 Dim rngToSrch As Range
 Dim rngResult As Range
 Set rngToSrch = ActiveDocument.Range
 Set rngResult = rngToSrch.Duplicate

 Do
   With rngResult.Find
         .Text = " " & ChrW(8594) & " "
         .Replacement.Text = ""
         .Forward = True
         .Wrap = wdFindContinue
         .Format = False
         .MatchCase = False
         .MatchWholeWord = False
         .MatchWildcards = False
         .MatchSoundsLike = False
         .MatchAllWordForms = False
         .Execute
     End With

     If Not rngResult.Find.Found Then Exit Do

     rngResult.Select

     Selection.InsertSymbol _
       Font:="Symbol", _
       CharacterNumber:=-3922, _
       Unicode:=True

     rngResult.MoveStart wdWord
     rngResult.End = rngToSrch.End

     Loop Until Not rngResult.Find.Found

 End Sub
Attribute VB_Name = "Intercepts"
Option Explicit
Sub Italic()
Call SmartStyler.ApplyItalic(Selection)
End Sub
Sub Bold()
Call SmartStyler.ApplyBold(Selection)
End Sub
Sub InsertPicture()
Call Figures.InsertFigure
End Sub
Sub InsertCrossReference()
Call XRefs.ShowXRefDialog
End Sub
Sub FormatBulletDefault()
Call SmartStyler.ApplyListBullet(Selection)
End Sub
Sub FormatNumberDefault()
Call SmartStyler.ApplyListNumber(Selection)
End Sub

Attribute VB_Name = "ORAStyle"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private myName As String
Private myAliases As String
Private myFixInlineItalic As Boolean
Private myFixInlineBold As Boolean
Private myFixInlineCW As Boolean
Private myInlinesAllowed As Boolean
Private myXRefShowInShortList As Boolean
Private myXRefType As String
Private myListBulletStyle As String
Private myListNumberStyle As String
Private myListVariableTermStyle As String
Private myListVariableStyle As String
Private myListContinueStyle As String
Private myIncreaseIndent As String
Private myDecreaseIndent As String
Private myMissingManualStyle As Boolean
Private myTypographerQuotes As Boolean

Public Function InDoc(doc As Document) As Boolean
   On Error GoTo ERR_HANDLER
   Dim sty As Style
   
   Set sty = doc.Styles(Me.Name)
   InDoc = True
   Exit Function
ERR_HANDLER:
    If Err.Number = 5941 Then
        InDoc = False
        Exit Function
    Else
        Call ErrorHandler.ClassErrorCatcher("ORAStyle", "InDoc", Err.Description)
        Err.Clear
        Exit Function
    End If
End Function


Public Property Get Name() As String
    Name = myName
End Property

Public Property Let Name(sName As String)
    myName = sName
End Property
Public Property Get Aliases() As String
    Aliases = myAliases
End Property
Public Property Let Aliases(sAliases As String)
    myAliases = sAliases
End Property

Public Property Get FixInlineItalic() As Boolean
    FixInlineItalic = myFixInlineItalic
End Property
Public Property Let FixInlineItalic(bFixInlineItalic As Boolean)
    myFixInlineItalic = bFixInlineItalic
End Property
Public Property Get FixInlineBold() As Boolean
    FixInlineBold = myFixInlineBold
End Property
Public Property Let FixInlineBold(bFixInlineBold As Boolean)
    myFixInlineBold = bFixInlineBold
End Property
Public Property Get FixInlineCW() As Boolean
    FixInlineCW = myFixInlineCW
End Property
Public Property Let FixInlineCW(bFixInlineCW As Boolean)
    myFixInlineCW = bFixInlineCW
End Property
Public Property Get InlinesAllowed() As Boolean
    InlinesAllowed = myInlinesAllowed
End Property
Public Property Let InlinesAllowed(bInlinesAllowed As Boolean)
    myInlinesAllowed = bInlinesAllowed
End Property
Public Property Get XRefShowInShortList() As Boolean
    XRefShowInShortList = myXRefShowInShortList
End Property
Public Property Let XRefShowInShortList(bXRefShowInShortList As Boolean)
    myXRefShowInShortList = bXRefShowInShortList
End Property
Public Property Get XRefType() As String
    XRefType = myXRefType
End Property
Public Property Let XRefType(sXRefType As String)
    myXRefType = sXRefType
End Property
Public Property Get ListBulletStyle() As String
    ListBulletStyle = myListBulletStyle
End Property
Public Property Let ListBulletStyle(sListBulletStyle As String)
    myListBulletStyle = sListBulletStyle
End Property
Public Property Get ListNumberStyle() As String
    ListNumberStyle = myListNumberStyle
End Property
Public Property Let ListNumberStyle(sListNumberStyle As String)
    myListNumberStyle = sListNumberStyle
End Property
Public Property Get ListVariableTermStyle() As String
    ListVariableTermStyle = myListVariableTermStyle
End Property
Public Property Let ListVariableTermStyle(sListVariableTermStyle As String)
    myListVariableTermStyle = sListVariableTermStyle
End Property
Public Property Get ListVariableStyle() As String
    ListVariableStyle = myListVariableStyle
End Property
Public Property Let ListVariableStyle(sListVariableStyle As String)
    myListVariableStyle = sListVariableStyle
End Property
Public Property Get ListContinueStyle() As String
    ListContinueStyle = myListContinueStyle
End Property
Public Property Let ListContinueStyle(sListContinueStyle As String)
    myListContinueStyle = sListContinueStyle
End Property
Public Property Get IncreaseIndent() As String
    IncreaseIndent = myIncreaseIndent
End Property
Public Property Let IncreaseIndent(sIncreaseIndent As String)
    myIncreaseIndent = sIncreaseIndent
End Property
Public Property Get DecreaseIndent() As String
    DecreaseIndent = myDecreaseIndent
End Property
Public Property Let DecreaseIndent(sDecreaseIndent As String)
    myDecreaseIndent = sDecreaseIndent
End Property
Public Property Get MissingManualStyle() As Boolean
    MissingManualStyle = myMissingManualStyle
End Property
Public Property Let MissingManualStyle(bMissingManualStyle As Boolean)
    myMissingManualStyle = bMissingManualStyle
End Property
Public Property Get TypographerQuotes() As Boolean
    TypographerQuotes = myTypographerQuotes
End Property
Public Property Let TypographerQuotes(bTypographerQuotes As Boolean)
    myTypographerQuotes = bTypographerQuotes
End Property
Attribute VB_Name = "ORAStyles"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mcolStyles As Collection
Const cNUM_ORASTYLES = 2
Const cNOTHING = 0
Private Sub Class_Initialize()
    Set mcolStyles = New Collection
    Dim col As Collection
    Dim i As Integer
    
    Set col = DefineORAStyles
    For i = 1 To col.Count
      Call Add( _
      CStr(col.Item(i)("Name")), _
      CStr(col.Item(i)("Aliases")), _
      CBool(col.Item(i)("FixInlineItalic")), _
      CBool(col.Item(i)("FixInlineBold")), _
      CBool(col.Item(i)("FixInlineCW")), _
      CBool(col.Item(i)("InlinesAllowed")), _
      CBool(col.Item(i)("XRefShowInShortList")), _
      CStr(col.Item(i)("XRefType")), _
      CStr(col.Item(i)("ListBulletStyle")), _
      CStr(col.Item(i)("ListNumberStyle")), _
      CStr(col.Item(i)("ListVariableTermStyle")), _
      CStr(col.Item(i)("ListVariableStyle")), _
      CStr(col.Item(i)("ListContinueStyle")), _
      CStr(col.Item(i)("IncreaseIndent")), _
      CStr(col.Item(i)("DecreaseIndent")), _
      CBool(col.Item(i)("MissingManualStyle")), _
      CBool(col.Item(i)("TypographerQuotes")) _
      )
    Next i
    
    
     
    

End Sub

Public Property Get Count() As Long
    Count = mcolStyles.Count
End Property

Private Function Add( _
    sName As String, _
    sAliases As String, _
    bFixInlineItalic As Boolean, _
    bFixInlineBold As Boolean, _
    bFixInlineCW As Boolean, _
    bInlinesAllowed As Boolean, _
    bXRefShowInShortList As Boolean, _
    sXRefType As String, _
    sListBulletStyle As String, _
    sListNumberStyle As String, _
    sListVariableTermStyle As String, _
    sListVariableStyle As String, _
    sListContinueStyle As String, _
    sIncreaseIndent As String, _
    sDecreaseIndent As String, _
    bMisingManualStyle As Boolean, _
    bTypographerQuotes As Boolean _
    ) As ORAStyle

Dim oORAStyle As ORAStyle
Set oORAStyle = New ORAStyle

oORAStyle.Name = sName
oORAStyle.Aliases = sAliases
oORAStyle.FixInlineItalic = bFixInlineItalic
oORAStyle.FixInlineBold = bFixInlineBold
oORAStyle.FixInlineCW = bFixInlineCW
oORAStyle.InlinesAllowed = bInlinesAllowed
oORAStyle.XRefShowInShortList = bXRefShowInShortList
oORAStyle.XRefType = sXRefType
oORAStyle.ListBulletStyle = sListBulletStyle
oORAStyle.ListNumberStyle = sListNumberStyle
oORAStyle.ListVariableTermStyle = sListVariableTermStyle
oORAStyle.ListVariableStyle = sListVariableStyle
oORAStyle.ListContinueStyle = sListContinueStyle
oORAStyle.IncreaseIndent = sIncreaseIndent
oORAStyle.DecreaseIndent = sDecreaseIndent
oORAStyle.MissingManualStyle = bMisingManualStyle
oORAStyle.TypographerQuotes = bTypographerQuotes
mcolStyles.Add Item:=oORAStyle, Key:=sName
Set Add = oORAStyle
Set oORAStyle = Nothing
End Function

Public Function Item(Index As Variant) As ORAStyle
    Set Item = mcolStyles.Item(Index)
End Function

Public Function Exists(sName As String) As Boolean
    Dim ora_s As New ORAStyle
    On Error GoTo ERR_HANDLER
    sName = Split(sName, cSTYLEALIAS_DELIMITER)(0)
    Set ora_s = mcolStyles(sName)
    Exists = True
    Exit Function
ERR_HANDLER:
    If Err.Number = 5 Then
        Exists = False
        Set ora_s = Nothing
    Else
        MsgBox "An error has occured in the exists function", vbCritical, "ORAStyles Class"
        Set ora_s = Nothing
    End If
End Function

Public Function AddAliases(ByRef sty As Style) As Boolean
Dim oORAStyle As New ORAStyle
sty.NameLocal = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
If Exists(sty.NameLocal) Then
    Set oORAStyle = mcolStyles(sty.NameLocal)
    sty.NameLocal = oORAStyle.Name & Chr$(44) & oORAStyle.Aliases
End If
AddAliases = True
End Function
Public Function RemoveAliases(ByRef sty As Style) As Boolean
sty.NameLocal = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
RemoveAliases = True
End Function

Attribute VB_Name = "README"
'#######################################################################################################
' Copyright (c) 2004, O'Reilly Media, Inc
' All rights reserved.

' Redistribution and use in source and binary forms,
' with or without modification, are permitted provided
' that the following conditions are met:

' * Redistributions of source code must retain the above copyright notice,
'   this list of conditions and the following disclaimer.

' * Redistributions in binary form must reproduce the above copyright notice,
'   this list of conditions and the following disclaimer in the documentation
'   and/or other materials provided with the distribution.

' Neither the name of O'Reilly Media, Inc nor the names of its contributors
' may be used to endorse or promote products derived from this software
' without specific prior written permission.

' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
' THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
' IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
' INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
' (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
' WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
' ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'########################################################################################################

Attribute VB_Name = "SmartStyler"
Option Explicit
Function ApplyCharStyle(ByRef rng As Range, ByVal lButtonPressed As Long) As Boolean
Dim doc As Document

Dim Range_Bold As Boolean ' Whether selected text is bold
Dim Range_Italic As Boolean ' Whether selected text is italic
Dim Paragraph_Bold As Boolean ' Whether paragraph containing Range is bold
Dim Paragraph_Italic As Boolean 'Whether paragraph containing Range is italic

Dim Range_Font_Standard As Boolean ' Whether the Range's font is Times
Dim Range_Font_CW As Boolean ' Whether the Range's font is Courier (New)

Dim Range_Font_SameAs_Paragraph_Font As Boolean ' Whether the Range and paragraph font are equal

Set doc = rng.Parent

'========= Settings and Messages ==========
Dim styEmphasis As Style
Dim styStrong As Style
Dim styCWEmphasis As Style
Dim styCW As Style
Dim styCWStrong As Style
Dim styCWStrongEmphasis As Style
Dim sStandardFont As String
Dim sCWFont As String

Set styEmphasis = doc.Styles(wdStyleEmphasis)
Set styStrong = doc.Styles(wdStyleStrong)
Set styCW = doc.Styles("Literal")
Set styCWEmphasis = doc.Styles("Replaceable")
Set styCWStrong = doc.Styles("User Input")
Set styCWStrongEmphasis = doc.Styles("User Input Replaceable")

sStandardFont = cFONT_STANDARD
sCWFont = cFONT_CONSTANT_WIDTH
'==========================================

' Set font Range properties:
If InStr(UCase$(rng.Font.Name), UCase$(sStandardFont)) Then
    Range_Font_Standard = True
    Range_Font_CW = False
ElseIf InStr(UCase$(rng.Font.Name), UCase$(sCWFont)) Then
    Range_Font_Standard = False
    Range_Font_CW = True
Else
     Range_Font_CW = False
     Range_Font_Standard = False
End If

' Set paragraph contaning Range's properties:
If InStr(UCase(doc.Styles((rng.ParagraphFormat.Style)).Font.Name), UCase(sStandardFont)) Then
    If (Range_Font_Standard) Then
        Range_Font_SameAs_Paragraph_Font = True
    Else
        Range_Font_SameAs_Paragraph_Font = False
    End If
ElseIf InStr(UCase(doc.Styles((rng.ParagraphFormat.Style)).Font.Name), UCase(sCWFont)) Then
    If (Range_Font_CW) Then
        Range_Font_SameAs_Paragraph_Font = True
    Else
        Range_Font_SameAs_Paragraph_Font = False
    End If
End If

Paragraph_Bold = doc.Styles(rng.ParagraphFormat.Style).Font.Bold
Paragraph_Italic = doc.Styles(rng.ParagraphFormat.Style).Font.Italic

If lButtonPressed = cBOLD Then
    Range_Bold = Not rng.Font.Bold
Else
    Range_Bold = rng.Font.Bold
End If

If lButtonPressed = cITALIC Then
    Range_Italic = Not rng.Font.Italic
Else
    Range_Italic = rng.Font.Italic
End If

' Now here's the massive case statement
' to handle the permutations of the 6 properties

' There are some reduntant if ... then statements,
' for easier future modification of logic
Select Case True

' Selected text is in Times:

    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
        End If
    
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styEmphasis)
        End If
        
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        End If
    
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        End If
    
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styEmphasis)
        End If
        
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        End If
        
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styEmphasis)
        End If
        
    Case ((Range_Font_Standard) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styStrong)
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styStrong)
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styStrong)
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styEmphasis)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styEmphasis)
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styStrong)
        End If
        
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styEmphasis)
        End If
    
    Case ((Range_Font_Standard) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        End If
        

    '#######################################
    '========= Range is courier ========
    '#######################################
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWEmphasis)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWEmphasis)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWEmphasis)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWEmphasis)
        End If
        
    Case ((Range_Font_CW) And _
        (Not Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWEmphasis)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWEmphasis)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
         Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Not Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrong)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrongEmphasis)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrongEmphasis)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Not Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrongEmphasis)
        Else
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Not Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrongEmphasis)
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCWStrongEmphasis)
        End If
        
    Case ((Range_Font_CW) And _
        (Range_Bold) And _
        (Range_Italic) And _
        (Paragraph_Bold) And _
        (Paragraph_Italic))
        
        If Range_Font_SameAs_Paragraph_Font = True Then
            rng.Font.Reset
        Else
            rng.Font.Reset
            Call ApplyStyleToSelectionIfRange(rng, styCW)
        End If
    
    Case Else
        If lButtonPressed = cITALIC Then
            rng.Font.Italic = wdToggle
        Else
            rng.Font.Bold = wdToggle
        End If
    End Select
End Function

Function ApplyBold(ByRef sel As Selection)
Dim rng As Range
Set rng = sel.Range
Dim para As Paragraph
Dim styCWParaStrong As Style
Dim styCWPara As Style


If (rng.Paragraphs.Count > 1) Or _
    (rng.Paragraphs.First.Range.Characters.Count = rng.Characters.Count) Then
    
    Set styCWPara = sel.Document.Styles("Code")
    Set styCWParaStrong = sel.Document.Styles("CodeEmphasis")
    
    For Each para In rng.Paragraphs
        Select Case para.Style
            Case Is = styCWPara
                para.Style = styCWParaStrong
            Case Is = styCWParaStrong
                para.Style = styCWPara
        End Select
    Next para

    Set styCWPara = Nothing
    Set styCWParaStrong = Nothing
    
Else
    Call ApplyCharStyle(sel.Range, cBOLD)
End If

End Function
Sub IncreaseIndent()
Call ApplyIncreaseIndent(Selection)
End Sub
Function ApplyIncreaseIndent(sel As Selection)
On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim rng As Range
Dim lCodeTabSpaces As Long
Dim sSeries As String
Dim strParaStyleName As String
Dim strIncreaseIndentStyleName As String
Dim oORAStyles As ORAStyles
Set oORAStyles = New ORAStyles

Call Config.CheckDocumentVariables(sel.Document)
sSeries = sel.Document.Variables(cCUSTOM_PROP_SERIES)

For Each para In sel.Paragraphs
    strParaStyleName = para.Style.NameLocal
    strParaStyleName = Split(strParaStyleName, cSTYLEALIAS_DELIMITER)(0)
    If oORAStyles.Exists(strParaStyleName) Then
        strIncreaseIndentStyleName = oORAStyles.Item(strParaStyleName).IncreaseIndent
        Select Case sSeries
            Case cCUSTOM_PROP_SERIES_MM
                ' Do nothing
            Case Else
                If Not strIncreaseIndentStyleName = cDEFAULT Then
                    para.Style = sel.Document.Styles(strIncreaseIndentStyleName)
                End If
        End Select

    End If
    ' Handle code paragraphs
    If InStr(strParaStyleName, "Code") <> 0 Then
       Call ChangeCodeIndent(para, True)
    End If
Next para
Set oORAStyles = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyIncreaseIndent", Err.Description)
Err.Clear
End Function
Sub DecreaseIndent()
Call ApplyDecreaseIndent(Selection)
End Sub
Function ApplyDecreaseIndent(sel As Selection)
On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim strParaStyleName As String
Dim strDecreaseIndentStyleName As String
Dim oORAStyles As ORAStyles

Set oORAStyles = New ORAStyles

For Each para In sel.Paragraphs
    strParaStyleName = para.Style.NameLocal
    strParaStyleName = Split(strParaStyleName, cSTYLEALIAS_DELIMITER)(0)
    If oORAStyles.Exists(strParaStyleName) Then
        strDecreaseIndentStyleName = oORAStyles.Item(strParaStyleName).DecreaseIndent
        If Not strDecreaseIndentStyleName = cDEFAULT Then
            para.Style = sel.Document.Styles(strDecreaseIndentStyleName)
        End If
    End If
    ' Handle code paragraphs
    If InStr(strParaStyleName, "Code") <> 0 Then
       Call ChangeCodeIndent(para, False)
    End If
Next para
Set oORAStyles = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyDecreaseIndent", Err.Description)
Err.Clear
End Function
Function ApplyItalic(ByRef sel As Selection)

Dim rng As Range
Dim doc As Document
Set rng = sel.Range
Set doc = sel.Document
Dim para As Paragraph

If DefineStyles.CheckForStyleInDocPromptToUpdate(cFILENAME_STYLE, doc) = False Then
    MsgBox "The SmartStyler won't work properly unless you update the styles in this document. " & _
           "Please choose Yes in the following dialog.", vbExclamation + vbOKOnly, cORA_DIALOG_CAPTION
    If DefineStyles.CheckForStyleInDocPromptToUpdate(cFILENAME_STYLE, doc) = False Then
        MsgBox "The SmartStyler could not style the selected text.", vbExclamation + vbOKOnly, cORA_DIALOG_CAPTION
        Exit Function
    End If
End If
 

If Not (rng.Paragraphs.Count > 1) And _
    Not (rng.Paragraphs.First.Range.Characters.Count = rng.Characters.Count) Then
    Select Case True
        Case IsSelectionAFilename(sel) And Not sel.Style = doc.Styles(cFILENAME_STYLE)
            If Not Config.ShouldNotApplyFilenameTagAutomatically Then
                sel.Font.Reset
                sel.Style = doc.Styles(cFILENAME_STYLE)
            Else
                Call ApplyCharStyle(sel.Range, cITALIC)
            End If
        Case IsSelectionASingleWordNotInDictionary(sel) And Not sel.Style = doc.Styles(cTECH_ITAL_STYLE)
            If Not Config.ShouldNotApplyTechItalicTagAutomatically Then
                sel.Font.Reset
                sel.Style = doc.Styles(cTECH_ITAL_STYLE)
            Else
                Call ApplyCharStyle(sel.Range, cITALIC)
            End If
        Case Else
            Call ApplyCharStyle(sel.Range, cITALIC)
    End Select
Else
    ' message to status bar?
End If



End Function

Function ApplyCode(ByRef rng As Range)
On Error GoTo ERR_HANDLER

'Dim rng As Range
Dim rngParagraph As Range
Dim rngOriginalSelection As Range

Dim para As Paragraph
Dim doc As Document
Dim iSelectionCharacterCount As Integer
Dim iFirstParagraphCharacterCount As Integer
Dim strParaStyleName As String

Set doc = rng.Parent

'========== Settings and Messages ==========
Dim strListTrigger As String
Dim strNoteTrigger As String
Dim strWarningTrigger As String
Dim strSidebarTrigger As String
Dim strCodeTrigger As String
Dim styBodyInlineCode As Style
Dim styTableCode As Style
Dim styNoteCode As Style
Dim styWarningCode As Style
Dim stySidebarCode As Style
Dim styCode As Style
Dim styCodeEmphasis As Style

strListTrigger = "List"
strNoteTrigger = "Note"
strWarningTrigger = "NoteWarning"
strSidebarTrigger = "Sidebar"
strCodeTrigger = "Code"

Set styBodyInlineCode = doc.Styles("Literal")
Set styTableCode = doc.Styles("CellCode")
Set styNoteCode = doc.Styles("Note>Code")
Set styWarningCode = doc.Styles("NoteWarning>Code")
Set stySidebarCode = doc.Styles("SidebarCode")
Set styCode = doc.Styles("Code")
Set styCodeEmphasis = doc.Styles("CodeEmphasis")
'==============================================

'Set rng = sel.Range
Set rngOriginalSelection = rng.Duplicate

iSelectionCharacterCount = rng.Characters.Count
iFirstParagraphCharacterCount = rng.Paragraphs.First.Range.Characters.Count
'Call VBAUtilities.ChompRange(rng)
If iSelectionCharacterCount <= (iFirstParagraphCharacterCount - 1) Then
   Call VBAUtilities.ChompRange(rng)
    ' Less than entire paragraph
    If InStr(rng.ParagraphFormat.Style.NameLocal, strCodeTrigger) = 0 Then
        Call ApplyStyleToSelectionIfRange(rng, styBodyInlineCode)
    End If
    Exit Function
End If

For Each para In rng.Paragraphs
    Set rngParagraph = para.Range
    strParaStyleName = rngParagraph.ParagraphFormat.Style.NameLocal
    Select Case rngParagraph.Style
        Case styCode
            If rngParagraph.Information(wdWithInTable) Then
                rngParagraph.Style = styTableCode
            End If
        Case styCodeEmphasis
            If rngParagraph.Information(wdWithInTable) Then
                rngParagraph.Style = styTableCode
            Else
                rngParagraph.Style = styCode
            End If
        Case Else
            If rngParagraph.Information(wdWithInTable) Then
                rngParagraph.Style = styTableCode
            Else
                Select Case True
                    Case InStr(strParaStyleName, strListTrigger)
                        rngParagraph.Style = styBodyInlineCode
                    Case InStr(strParaStyleName, strWarningTrigger)
                        rngParagraph.Style = styWarningCode
                    Case InStr(strParaStyleName, strNoteTrigger)
                        rngParagraph.Style = styNoteCode
                    Case InStr(strParaStyleName, strSidebarTrigger)
                        rngParagraph.Style = stySidebarCode
                    Case Else
                        rngParagraph.Style = styCode
                End Select
            End If
    End Select
Next para
'rngOriginalSelection.Select
Application.ScreenRefresh
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyCode", Err.Description)
Err.Clear
End Function

Sub Code()
Call ApplyCode(Selection.Range)
End Sub
Sub ListBullet()
Call ApplyListBullet(Selection)
End Sub
Function ApplyListBullet(sel As Selection)
On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim strParaStyleName As String
Dim strListBulletStyleName As String
Dim oORAStyles As ORAStyles

'========== Settings and Messages ==========
Dim styDefaultListBulletStyle As Style
Set styDefaultListBulletStyle = sel.Document.Styles("ListBullet")
'===========================================



Set oORAStyles = New ORAStyles

For Each para In sel.Paragraphs
    strParaStyleName = para.Style.NameLocal
    strParaStyleName = Split(strParaStyleName, cSTYLEALIAS_DELIMITER)(0)
    If oORAStyles.Exists(strParaStyleName) Then
        strListBulletStyleName = oORAStyles.Item(strParaStyleName).ListBulletStyle
        If Not strListBulletStyleName = cDEFAULT Then
            para.Style = sel.Document.Styles(strListBulletStyleName)
        Else
            para.Style = styDefaultListBulletStyle
        End If
    Else
        para.Style = styDefaultListBulletStyle
    End If
Next para
Set oORAStyles = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyListBullet", Err.Description)
Err.Clear
End Function
Sub ListNumber()
Call ApplyListNumber(Selection)
End Sub
Function ApplyListNumber(sel As Selection)
On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim strParaStyleName As String
Dim strListNumberStyleName As String
Dim oORAStyles As ORAStyles

'========== Settings and Messages ==========
Dim styDefaultListNumberStyle As Style
Set styDefaultListNumberStyle = sel.Document.Styles("ListNumber")
'===========================================

Set oORAStyles = New ORAStyles

For Each para In sel.Paragraphs
    strParaStyleName = para.Style.NameLocal
    strParaStyleName = Split(strParaStyleName, cSTYLEALIAS_DELIMITER)(0)
    If oORAStyles.Exists(strParaStyleName) Then
        strListNumberStyleName = oORAStyles.Item(strParaStyleName).ListNumberStyle
        If Not strListNumberStyleName = cDEFAULT Then
            para.Style = sel.Document.Styles(strListNumberStyleName)
        Else
            para.Style = styDefaultListNumberStyle
        End If
    Else
        para.Style = styDefaultListNumberStyle
    End If
Next para
Set oORAStyles = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyListNumber", Err.Description)
Err.Clear
End Function
Sub ListVariable()
Call ApplyListVariable(Selection)
End Sub
Function ApplyListVariable(sel As Selection)
'On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim strParaStyleName As String
Dim oORAStyles As ORAStyles
Dim sSeries As String
Dim strListVariableStyle As String
Dim strListVariableTermStyle As String
Dim i As Integer

'========== Settings and Messages ==========
Dim styDefaultListVariableTerm As Style
Dim styDefaultListVariable As Style

Set styDefaultListVariableTerm = sel.Document.Styles("ListVariableTerm")
Set styDefaultListVariable = sel.Document.Styles("ListVariable")
'============================================

Call Config.CheckDocumentVariables(sel.Document)
sSeries = sel.Document.Variables(cCUSTOM_PROP_SERIES)

Set oORAStyles = New ORAStyles

Select Case sSeries
    
    Case Is = cCUSTOM_PROP_SERIES_MM
        MsgBox prompt:= _
            "Variable lists aren't part of the Missing Manual style set." & vbCr & _
            "Use a bulleted list and apply Bold to the term or text to emphasize.", _
            buttons:=vbOKOnly + vbInformation, _
            Title:=cORA_DIALOG_CAPTION
    Case Else
        For i = 1 To sel.Paragraphs.Count
            Set para = sel.Paragraphs(i)
                strParaStyleName = para.Style.NameLocal
                strParaStyleName = Split(strParaStyleName, cSTYLEALIAS_DELIMITER)(0)
                If oORAStyles.Exists(strParaStyleName) Then
                    If i Mod 2 = 1 Then
                        strListVariableTermStyle = oORAStyles.Item(strParaStyleName).ListVariableTermStyle
                        If Not strListVariableTermStyle = cDEFAULT Then
                            para.Style = sel.Document.Styles(strListVariableTermStyle)
                        Else
                            para.Style = styDefaultListVariableTerm
                        End If
                    Else
                        strListVariableStyle = oORAStyles.Item(strParaStyleName).ListVariableStyle
                        If Not strListVariableTermStyle = cDEFAULT Then
                            para.Style = sel.Document.Styles(strListVariableStyle)
                        Else
                            para.Style = styDefaultListVariable
                        End If
                    End If
                Else
                    If i Mod 2 = 1 Then
                        para.Style = styDefaultListVariableTerm
                    Else
                        para.Style = styDefaultListVariable
                    End If
                End If
                
            Set para = Nothing
        Next i
End Select

Set oORAStyles = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyListNumber", Err.Description)
Err.Clear
End Function
Sub ListContinue()
Call ApplyListContinue(Selection)
End Sub
Function ApplyListContinue(sel As Selection)
On Error GoTo ERR_HANDLER
Dim para As Paragraph
Dim strParaStyleName As String
Dim strListContinueStyleName As String
Dim oORAStyles As ORAStyles

Set oORAStyles = New ORAStyles

For Each para In sel.Paragraphs
    strParaStyleName = para.Style.NameLocal
    strParaStyleName = Split(strParaStyleName, cSTYLEALIAS_DELIMITER)(0)
    If oORAStyles.Exists(strParaStyleName) Then
        strListContinueStyleName = oORAStyles.Item(strParaStyleName).ListContinueStyle
        If Not strListContinueStyleName = cDEFAULT Then
            para.Style = sel.Document.Styles(strListContinueStyleName)
        End If
    End If
Next para
Set oORAStyles = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplyListContinue", Err.Description)
Err.Clear
End Function
Sub Superscript()
Call ApplySuperscript(Selection)
End Sub
Function ApplySuperscript(sel As Selection)
On Error GoTo ERR_HANDLER
Dim char As Range

'========== Settings and Messages ==========
Dim stySuperScript As Style
Set stySuperScript = sel.Document.Styles("Superscript")
'===========================================

If sel.Range.Characters.Count >= _
   sel.Range.Paragraphs.First.Range.Characters.Count - 1 Then
    Exit Function
End If

For Each char In sel.Range.Characters
    char.Font.Reset
    char.Style = stySuperScript
Next char
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplySuperscript", Err.Description)
Err.Clear
End Function

Sub Subscript()
Call ApplySubscript(Selection)
End Sub
Function ApplySubscript(sel As Selection)
On Error GoTo ERR_HANDLER
Dim char As Range

'========== Settings and Messages ==========
Dim stySubScript As Style
Set stySubScript = sel.Document.Styles("Subscript")
'===========================================

If sel.Range.Characters.Count >= _
   sel.Range.Paragraphs.First.Range.Characters.Count - 1 Then
    Exit Function
End If

For Each char In sel.Range.Characters
    char.Font.Reset
    char.Style = stySubScript
Next char
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ApplySubscript", Err.Description)
Err.Clear
End Function
Function ChangeCodeIndent(ByRef para As Paragraph, ByVal bIncrease As Boolean)
On Error GoTo ERR_HANDLER
'# If bIncrease is true, then add space at beginning
'# If bIncrease is false, then remove space at beginning
Dim lCodeIndentIncrement As Long
Dim rng As Range
Dim k As Integer
Call Config.CheckDocumentVariables(para.Parent)
lCodeIndentIncrement = para.Parent.Variables(cCUSTOM_PROP_TAB_SPACES)

Set rng = para.Range
Dim char As Range
Dim charNext As Range

rng.Collapse wdCollapseStart
If (bIncrease) Then
    rng.InsertAfter String(lCodeIndentIncrement, cSPACE)
Else
    rng.MoveEndWhile cset:=cSPACE, _
    Count:=lCodeIndentIncrement
    If Len(rng.Text) <> 0 Then
        With rng.Find
            .ClearFormatting
            .Replacement.ClearFormatting
            .MatchWildcards = True
            .Wrap = wdFindStop
            .Format = False
            .Forward = True
            .Text = " "
            .Replacement.Text = vbNullString
            .Execute Replace:=wdReplaceAll
        End With
    End If
   ' If Len(rng.Text) > 0 Then rng.Delete
End If
Set rng = Nothing
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ChangeCodeIndent", Err.Description)
Err.Clear
End Function
Function IsSelectionAFilename(sel As Selection) As Boolean
Call VBAUtilities.ChompSelection(sel)
If sel.Text Like cFILENAME_PATTERN Then
    IsSelectionAFilename = True
End If

End Function
Function IsSelectionASingleWordNotInDictionary(sel As Selection) As Boolean
Dim rngWord As Range
Call VBAUtilities.ChompSelection(sel)
If sel.Words.Count = 1 Then
    Set rngWord = sel.Words.First
    If rngWord.SpellingErrors.Count <> 0 Then
        IsSelectionASingleWordNotInDictionary = True
    End If
Else
    IsSelectionASingleWordNotInDictionary = False
End If
End Function
Function ApplyStyleToSelectionIfRange(rng As Range, sty As Style)
If rng = Selection.Range Then
    Selection.Style = sty
Else
    rng.Style = sty
End If
End Function
Attribute VB_Name = "SpecialCharacters"
Option Explicit
Sub CharMenuDelim()
    Selection.InsertSymbol _
      Font:="Symbol", _
      CharacterNumber:=-3922, _
      Unicode:=True
End Sub
Sub EmDash()
' Inserts EmDash at cursor point
    Selection.InsertSymbol _
        CharacterNumber:=8212, _
        Unicode:=True, _
        Bias:=0
End Sub

Attribute VB_Name = "Tables"
Option Explicit
Sub InsertTableWithCaptionWithHeadingRow()
Call InsertTable(Selection, True, True)
End Sub
Sub InsertTableWithCaptionNoHeadingRow()
Call InsertTable(Selection, True, False)
End Sub
Sub InsertTableNoCaptionNoHeadingRow()
Call InsertTable(Selection, False, False)
End Sub
Sub InsertTableNoCaptionWithHeadingRow()
Call InsertTable(Selection, False, True)
End Sub
Function InsertTable(sel As Selection, bCaption As Boolean, bHeadingRow As Boolean)
On Error GoTo ERR_HANDLER
Dim lngRows As Long
Dim lngColumns As Long
Dim doc As Document
Dim i As Integer
Dim dial As Dialog
Dim tbl As Table

Set doc = sel.Document

'========== Settings and Messages ==========
Dim styTableBody As Style
Dim styTableHeading As Style
Dim sMessageInsertionPointNotEmpty As String
Dim sMessageInsertionPointInTable As String

sMessageInsertionPointNotEmpty = "Insertion point must be in an empty paragraph"
sMessageInsertionPointInTable = "Insertion point can't be inside a table"

Set styTableBody = doc.Styles("CellBody")
Set styTableHeading = doc.Styles("CellHeading")
'============================================

If VBAUtilities.IsInsertionPointInEmptyParagraph(sel) = False Then
    MsgBox sMessageInsertionPointNotEmpty, _
            vbExclamation, _
            cORA_DIALOG_CAPTION
    Exit Function
End If

If (sel.Information(wdWithInTable)) Then
    MsgBox sMessageInsertionPointInTable, _
            vbExclamation, _
            cORA_DIALOG_CAPTION
    Exit Function
End If

Set dial = Dialogs(wdDialogTableInsertTable)
If dial.Display = 0 Then
    Exit Function
Else
    lngRows = dial.NumRows
    lngColumns = dial.numcolumns
End If

sel.Collapse wdCollapseStart
If (bCaption) Then
    Call Captions.InsertTableCaption
End If

sel.Collapse wdCollapseEnd
sel.InsertAfter vbCrLf
sel.Collapse wdCollapseEnd
sel.Range.Style = doc.Styles(wdStyleBodyText)

doc.Tables.Add _
    Range:=sel.Range, _
    NumRows:=lngRows, _
    numcolumns:=lngColumns, _
    defaulttablebehavior:=wdWord9TableBehavior, _
    AutoFitBehavior:=wdAutoFitFixed

Set tbl = sel.Tables(1)

tbl.Range.Style = styTableBody
If (bHeadingRow) Then
    tbl.Rows.First.HeadingFormat = True
    tbl.Rows.First.Range.Style = styTableHeading
End If

Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("InsertTable", Err.Description)
Err.Clear
End Function
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ToolsDeptUse"
Option Explicit

Sub FixStylesWithInvalidCharacters()
' Removes "\" characters from style names.
' Docs created from Frame files often include
' that character, which isn't allowed in Word style names
Dim sty As Style
Dim str As String
Dim para As Paragraph
Dim doc As Document
Set doc = ActiveDocument
For Each para In doc.Paragraphs
    Set sty = para.Style
    str = sty.NameLocal
    If InStr(str, "\") <> 0 Then
        str = Replace(str, "\", vbNullString)
        para.Reset
        para.Style = doc.Styles(str)
    End If
Next para
End Sub

Sub UnhideAllHiddenText()
ActiveDocument.Range.Font.Hidden = False
End Sub

Sub ReapplyStylesAndGlobalSwap()
Dim para As Paragraph
Dim doc As Document
Dim styName As String
Dim styShortName As String

Dim sty As Style
Dim oORAStyles As ORAStyles
Dim sReplaceWithStyleName As String
Dim bOKReplacement As Boolean
Dim dial As Dialog
Dim bNoDialogs As Boolean
Dim bReplaceWithStyle As String

bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("You should only run this macro if you know what it does. Are you sure you want to continue?", _
        vbYesNo, _
        cORA_DIALOG_CAPTION) = vbNo Then
    Exit Sub
    End If
End If

Set oORAStyles = New ORAStyles
Set dial = Dialogs(wdDialogFormatStyle)
Set doc = ActiveDocument

For Each para In doc.Paragraphs
    Set sty = para.Style
    If sty.BuiltIn = False Then
        styName = sty.NameLocal
        If oORAStyles.Exists(styName) = False Then
            ' Get replacement style from mapping file
            styShortName = Split(styName, cSTYLEALIAS_DELIMITER)(0)
            sReplaceWithStyleName = GetReplacementStyleName(styShortName, cMAPPING_FILE_PARAGRAPH_STYLES)
            ' If there's no mapping defined ...
            If Len(sReplaceWithStyleName) = 0 Then
                ' ... then prompt user for a new style
                para.Range.Select
                MsgBox "The style " & Chr$(34) & styName & Chr$(34) & " isn't valid. Choose a new one from the following dialog.", _
                    vbOKOnly + vbInformation, _
                    cORA_DIALOG_CAPTION
                bOKReplacement = False
                Do
                    If dial.Display = 0 Then Exit Sub
                    sReplaceWithStyleName = dial.Name
                    If sReplaceWithStyleName = styName Then
                        MsgBox "Can't replace " & Chr$(34) & sReplaceWithStyleName & Chr$(34) & " with itself. " & _
                            "Please choose a different replacement style.", _
                            vbExclamation + vbOKOnly, _
                            cORA_DIALOG_CAPTION
                    ElseIf doc.Styles(sReplaceWithStyleName).BuiltIn = False And _
                        oORAStyles.Exists(sReplaceWithStyleName) = False Then
                             MsgBox Chr$(34) & sReplaceWithStyleName & Chr$(34) & _
                                " isn't a valid replacment style. " & _
                            "Please choose a different replacement style", _
                            vbExclamation + vbOKOnly, _
                            cORA_DIALOG_CAPTION
                            doc.Undo
                    ElseIf Not doc.Styles(sReplaceWithStyleName).Type = wdStyleTypeParagraph Then
                             MsgBox Chr$(34) & sReplaceWithStyleName & Chr$(34) & " isn't a Paragraph Style. " & _
                            "Please choose a Paragraph style to replace " & Chr$(34) & styName & Chr$(34), _
                            vbExclamation + vbOKOnly, _
                            cORA_DIALOG_CAPTION
                            doc.Undo
                    Else
                        bOKReplacement = True
                    End If
                Loop While bOKReplacement = False
            End If
            With doc.Range.Find
                .ClearFormatting
                .Replacement.ClearFormatting
                .Format = True
                .MatchCase = False
                .MatchWholeWord = False
                .Forward = True
                .Wrap = wdFindContinue
                .Style = styName
                .Replacement.Style = sReplaceWithStyleName
                .Execute Replace:=wdReplaceAll
            End With
            '==
        Else
            para.Style = para.Style
        End If
    Else
        para.Style = para.Style
    End If
Next para

End Sub
Function ReplaceOldORAStylesInDoc(Optional doc As Document) As Boolean
' Replaces deprecated O'Reilly styles with their
' new counterparts.
On Error Resume Next
If doc Is Nothing Then Set doc = ActiveDocument
With doc.Range.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .Text = vbNullString
    .Replacement.Text = "^&"
    .Forward = True
    .MatchWildcards = False
    .Format = True
    
    .Style = doc.Styles(wdStyleNormal)
    .Replacement.Style = doc.Styles(wdStyleBodyText)
    .Execute Replace:=wdReplaceAll
    
    .Style = "online item, fiy"
    If Err.Number = cERR_MISSING_STYLE Then
        Err.Clear
    ElseIf Err.Number <> 0 Then
        GoTo ERR_HANDLER
    Else
        .Replacement.Style = doc.Styles(wdStyleHyperlink)
        .Execute Replace:=wdReplaceAll
        doc.Styles("online item,fiy").Delete
    End If
    
    
    .Style = "HacksXRefColor"
    If Err.Number = cERR_MISSING_STYLE Then
        Err.Clear
    ElseIf Err.Number <> 0 Then
        GoTo ERR_HANDLER
    Else
        .Replacement.Style = doc.Styles("XRefColor")
        .Execute Replace:=wdReplaceAll
        doc.Styles("HacksXRefColor").Delete
    End If
    
    .Style = "HacksXRefColorCW"
    If Err.Number = cERR_MISSING_STYLE Then
        Err.Clear
    ElseIf Err.Number <> 0 Then
        GoTo ERR_HANDLER
    Else
        .Replacement.Style = doc.Styles("XRefColorCW")
        .Execute Replace:=wdReplaceAll
        doc.Styles("HacksXRefColorCW").Delete
    End If
    
End With
ReplaceOldORAStylesInDoc = True
Exit Function
ERR_HANDLER:
ReplaceOldORAStylesInDoc = False
End Function
Sub ReplaceOldORAStyles()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Replace deprecated ORA styles with their newer counterparts?", _
        vbYesNo, _
        cORA_DIALOG_CAPTION) = vbNo Then
    Exit Sub
    End If
End If
If ReplaceOldORAStylesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ReplaceOldORAStyles", Err.Description)
End Sub
Sub StripStyleAliases()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Really remove aliases from ALL styles in this document?", _
        vbYesNo, _
        cORA_DIALOG_CAPTION) = vbNo Then
    Exit Sub
    End If
End If
If StripStyleAliasesInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("StripStyleAliases", Err.Description)
End Sub
Function StripStyleAliasesInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim sty As Style
If doc Is Nothing Then Set doc = ActiveDocument
For Each sty In doc.Styles
    sty.NameLocal = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
Next sty
StripStyleAliasesInDoc = True
Exit Function
ERR_HANDLER:
StripStyleAliasesInDoc = False
End Function
Function NormalizeTableWidthsInDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim tbl As Table
If doc Is Nothing Then Set doc = ActiveDocument
For Each tbl In doc.Tables
    tbl.AutoFitBehavior (wdAutoFitWindow)
Next tbl
NormalizeTableWidthsInDoc = True
Exit Function
ERR_HANDLER:
NormalizeTableWidthsInDoc = False
End Function
Sub NormalizeTableWidths()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Auto-fit all tables in this document?", _
        vbYesNo, _
        cORA_DIALOG_CAPTION) = vbNo Then
    Exit Sub
    End If
End If
If NormalizeTableWidthsInDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("NormalizeTableWidths", Err.Description)
End Sub

Function AddCaptionNumberingToDoc(Optional doc As Document) As Boolean
On Error GoTo ERR_HANDLER
Dim para As Paragraph
If doc Is Nothing Then Set doc = ActiveDocument
For Each para In doc.Paragraphs
    Call Captions.ValidateAndFixCaptionParagraph(para)
Next para
AddCaptionNumberingToDoc = True
Exit Function
ERR_HANDLER:
AddCaptionNumberingToDoc = False
End Function
Sub AddCaptionNumbering()
On Error GoTo ERR_HANDLER
Dim bNoDialogs As Boolean
bNoDialogs = Config.ShouldIgnoreConfirmDialog
If Not bNoDialogs Then
    If MsgBox("Try to fix/add caption numbers throughout this document?", _
        vbYesNo, _
        cORA_DIALOG_CAPTION) = vbNo Then
    Exit Sub
    End If
End If
If AddCaptionNumberingToDoc(ActiveDocument) = False Then
    GoTo ERR_HANDLER
End If
If Not bNoDialogs Then MsgBox cDONE, vbOKOnly, cORA_DIALOG_CAPTION
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("NormalizeTableWidths", Err.Description)
End Sub
Function GetReplacementStyleName(sOldStyleName As String, sStyleTypeSectionName As String) As String
Dim sReplacementStyleName As String
Dim sFullName As String
sFullName = Options.DefaultFilePath(wdUserTemplatesPath) & _
        Application.PathSeparator & cMAPPING_FILE
sReplacementStyleName = System.PrivateProfileString( _
                                        sFullName, _
                                        sStyleTypeSectionName, _
                                        sOldStyleName)
GetReplacementStyleName = sReplacementStyleName
End Function
Attribute VB_Name = "VB6Strings"
Option Explicit
'Split         Split a string into a variant array.
'
'InStrRev      Similar to InStr but searches from end of string.
'
'Replace       To find a particular string and replace it.
'
'Reverse       To reverse a string.

Public Function InStrRev(ByVal sIn As String, ByVal _
   sFind As String, Optional nStart As Long = 1) _
    As Long

    Dim nPos As Long
    
    sIn = Reverse(sIn)
    sFind = Reverse(sFind)
    
    nPos = InStr(nStart, sIn, sFind)
    If nPos = 0 Then
        InStrRev = 0
    Else
        InStrRev = Len(sIn) - nPos - Len(sFind) + 2
    End If
End Function

Public Function Join(Source As Variant, _
    Optional sDelim As String = cSPACE) As String
    
    Dim k As Long
    Dim sOut As String
    
    For k = LBound(Source) To UBound(Source) - 1
        sOut = sOut & Source(k) & sDelim
    Next
    
    Join = sOut & Source(k)
End Function

Public Function Replace(ByVal sIn As String, ByVal sFind As _
    String, ByVal sReplace As String, Optional nStart As _
     Long = 1, Optional nCount As Long = -1) As _
     String

    Dim nC As Long, nPos As Long
    Dim nFindLen As Long, nReplaceLen As Long

    nFindLen = Len(sFind)
    nReplaceLen = Len(sReplace)
    
    If (sFind <> vbNullString) And (sFind <> sReplace) Then
        nPos = InStr(nStart, sIn, sFind)
        Do While nPos
            nC = nC + 1
            sIn = Left(sIn, nPos - 1) & sReplace & _
             Mid(sIn, nPos + nFindLen)
            If nCount <> -1 And nC >= nCount Then Exit Do
            nPos = InStr(nPos + nReplaceLen, sIn, sFind)
        Loop
    End If

    Replace = sIn
End Function

Public Function Reverse(ByVal sIn As String) As String
    Dim nC As Long
    Dim sOut As String

    For nC = Len(sIn) To 1 Step -1
        sOut = sOut & Mid(sIn, nC, 1)
    Next nC
    
    Reverse = sOut
End Function

Public Function Split(ByVal sIn As String, _
    Optional sDelim As String = cSPACE, _
    Optional nLimit As Long = -1) _
    As Variant

    Dim nC As Long, nPos As Long, nDelimLen As Long
    Dim sOut() As String
    
    If sDelim <> vbNullString Then
        nDelimLen = Len(sDelim)
        nPos = InStr(1, sIn, sDelim)
        Do While nPos
            ReDim Preserve sOut(nC)
            sOut(nC) = Left(sIn, nPos - 1)
            sIn = Mid(sIn, nPos + nDelimLen)
            nC = nC + 1
            If nLimit <> -1 And nC >= nLimit Then Exit Do
            nPos = InStr(1, sIn, sDelim)
        Loop
    End If

    ReDim Preserve sOut(nC)
    sOut(nC) = sIn

    Split = sOut
End Function


Attribute VB_Name = "VBAUtilities"
Option Explicit
Function ChompRange(ByRef rng As Range)
If rng.Characters.Count = 1 Then Exit Function
rng.MoveStartWhile cset:=(Chr$(32) & Chr$(13)), Count:=rng.Characters.Count
rng.MoveEndWhile cset:=(Chr$(32) & Chr$(13)), Count:=-rng.Characters.Count
End Function
Function ChompSelection(ByRef sel As Selection)
If sel.Range.Characters.Count = 1 Then Exit Function
sel.MoveStartWhile cset:=(Chr$(32) & Chr$(13)), Count:=sel.Characters.Count
sel.MoveEndWhile cset:=(Chr$(32) & Chr$(13)), Count:=-sel.Characters.Count
End Function
Function Sleep(lSleepTime As Long)
Dim lStart As Long
lStart = Timer
Do While Timer < lStart + lSleepTime
Loop
End Function
Function GenerateFixedLengthRandomNumber(iLength As Integer) As Long
Randomize
GenerateFixedLengthRandomNumber = _
                Int(((10 ^ (iLength) - 1) - (10 ^ (iLength - 1)) + 1) _
                * Rnd + (10 ^ (iLength - 1)))
End Function
Function GenerateBoundedRandomNumber(lLowerBound As Long, _
                                     lUpperBound As Long) As Long
Randomize
GenerateBoundedRandomNumber = _
            Int((lUpperBound - lLowerBound + 1) * Rnd + lLowerBound)
End Function
Function GetParaIndex(para As Paragraph) As Long
Dim rng As Range
Set rng = para.Range
GetParaIndex = para.Parent.Range(0, rng.Paragraphs(1).Range.End).Paragraphs.Count
End Function
Function IsInsertionPointInEmptyParagraph(ByRef sel As Selection) As Boolean
If (sel.Paragraphs.Count = 1 And sel.Paragraphs.First.Range.Characters.Count = 1) Then
    IsInsertionPointInEmptyParagraph = True
Else
    IsInsertionPointInEmptyParagraph = False
End If
End Function
Function StripInvalidBookmarkCharacters(ByVal str As String) As String
Dim i As Integer
For i = 33 To 255
    Select Case i
        Case 33 To 47, 58 To 64, 91 To 96, 123 To 255
            str = Replace(str, Chr$(i), vbNullString)
    End Select
Next i
StripInvalidBookmarkCharacters = str
End Function
Function TrimLeadingNumbersFromString(ByVal str As String) As String
Dim k As Integer
Do While str Like "[0-9]*"
    str = Right$(str, Len(str) - 1)
Loop
TrimLeadingNumbersFromString = str
End Function
Function ConvertStringToValidBookmarkName(ByVal str As String) As String
str = StripInvalidBookmarkCharacters(str)
str = Replace(str, cSPACE, cUNDERSCORE)
str = cUNDERSCORE & str
ConvertStringToValidBookmarkName = str

End Function

Function PathName(str As String) As String
Dim sSep As String
sSep = Application.PathSeparator
PathName = Left$(str, InStrRev(str, sSep) - 1)
End Function
Function GetFileName(sPath As String, sSeparator As String) As String
GetFileName = Right$(sPath, (Len(sPath) - (InStrRev(sPath, sSeparator))))
End Function
Function CheckDirectory(Optional bNull As Boolean)
' Won't work on network directory
' Just changes to top level directory
' in current drive.
Dim sDocDir As String
sDocDir = ActiveDocument.Path
If Not sDocDir = CurDir And Len(sDocDir) <> 0 Then
    ChDir (sDocDir)
End If
End Function
Function LockExternalFields(ByRef doc As Document)
Dim fld As Field
For Each fld In doc.Fields
    If Not fld.Parent = doc Then
        fld.Locked = True
    End If
Next fld
End Function
Function UnlockExternalFields(ByRef doc As Document)
Dim fld As Field
For Each fld In doc.Fields
    If Not fld.Parent = doc Then
        fld.Locked = False
    End If
Next fld
End Function

Function UpdateAllFieldsInDoc(Optional doc As Document)
If doc Is Nothing Then Set doc = ActiveDocument
doc.Fields.Update
End Function
Function IsThisAMac() As Boolean
If InStr(UCase$(Application.System.OperatingSystem), "MAC") <> 0 Then
    IsThisAMac = True
Else
    IsThisAMac = False
End If
End Function
Function IsStyleInUseInDoc(strStyleName As String, doc As Document) As Boolean
Dim sty As Style
If VBAUtilities.DoesStyleExistInDoc(strStyleName, doc) = False Then
    IsStyleInUseInDoc = False
    Exit Function
End If

Set sty = doc.Styles(strStyleName)

If sty.InUse = False Then
    IsStyleInUseInDoc = False
    Exit Function
End If

With doc.Content.Find
    .ClearFormatting
    .MatchWildcards = False
    .Format = True
    .Style = sty
    .Text = vbNullString
    .Forward = True
    .Wrap = wdFindContinue
    .Execute
    IsStyleInUseInDoc = .Found
End With

End Function
Function DoesStyleExistInDoc(strStyleName As String, doc As Document) As Boolean
On Error Resume Next
Dim sty As Style
Set sty = doc.Styles(strStyleName)
Select Case Err.Number
    Case 0
        DoesStyleExistInDoc = True
    Case cERR_STYLE_DOES_NOT_EXIST
        DoesStyleExistInDoc = False
    Case Else
        Call ErrorHandler.ModuleErrorCatcher("DoesStyleExistInDoc", Err.Number & cSPACE & Err.Description)
End Select
End Function
Function GetHeadAndTail(ByVal strIn As String, ByVal strDelim As String) As Variant
Dim lPos As Long
lPos = InStr(strIn, strDelim)
If lPos = 0 Then
    GetHeadAndTail = Array(strIn, vbNullString)
Else
    GetHeadAndTail = Array(Left(strIn, lPos - 1), Mid(strIn, lPos + Len(strDelim)))
End If
End Function
Function BuildCollectionFromPairListString(ByVal strPairList As String, _
                                     ByVal strEntrySeparator As String, _
                                     ByVal strKeyValueDelim As String) As Collection
' Expects a list like this:
' {name;>ListBullet}{aliases:lb}{fixinlineitalic:True}
' First and last character in strPairList will be chopped off
Dim var As Variant
Dim v As Variant
Dim lPos As Long
Dim vPair As Variant
Dim col As Collection
Set col = New Collection
strPairList = Mid(strPairList, 2, Len(strPairList) - 2)
var = Split(strPairList, strEntrySeparator)
For Each v In var
    lPos = InStr(v, strKeyValueDelim)
    col.Add Key:=Left(v, lPos - 1), Item:=Mid(v, lPos + Len(strKeyValueDelim))
Next v
Set BuildCollectionFromPairListString = col
End Function

Attribute VB_Name = "VersionSpecific"
Option Explicit
' This module holds code that can only run in Word 2002 or later
Function UnlinkStyle(ByRef sty As Style)
sty.LinkStyle = wdStyleNormal
End Function
Attribute VB_Name = "XRefs"
Option Explicit
Function CreateRefBookmarkNameFromString(ByVal str As String) As String
Dim sRandom As String
sRandom = CStr(VBAUtilities.GenerateFixedLengthRandomNumber(5))
str = VBAUtilities.ConvertStringToValidBookmarkName(str)
str = cXREF_PREFIX & sRandom & str
CreateRefBookmarkNameFromString = str
End Function
Function GetOrSetParaXRefBookmark(para As Paragraph) As String
On Error GoTo ERR_HANDLER
Dim rng As Range
Dim sBookmarkName As String
Dim iBookmarksCount As Integer
Dim i As Integer
Dim doc As Document
Dim oORAStyles As ORAStyles

Set oORAStyles = New ORAStyles
iBookmarksCount = para.Range.Bookmarks.Count

If iBookmarksCount <> 0 Then
    For i = 1 To iBookmarksCount
        If InStr(1, para.Range.Bookmarks(i), cXREF_PREFIX) <> 0 Then
            sBookmarkName = para.Range.Bookmarks(i).Name
            GetOrSetParaXRefBookmark = sBookmarkName
            Exit Function
        End If
    Next i
End If

Set rng = para.Range
Set doc = Documents(para.Range.Parent)

Call VBAUtilities.ChompRange(rng)
'Adjust range for other xref types

Call SetXRefBookmarkRange(rng)
sBookmarkName = CreateRefBookmarkNameFromString(rng.Text)

doc.Bookmarks.Add _
    Name:=sBookmarkName, _
    Range:=rng
GetOrSetParaXRefBookmark = sBookmarkName
Exit Function
ERR_HANDLER:
If Err.Number = cERR_BADBOOKMARKNAME Then
    MsgBox "An error occurred while trying to create a bookmark using the text:" & vbCrLf & _
       sBookmarkName & vbCrLf & _
       "I'm sorry, but you won't be able to create a cross reference to the desired text." & vbCrLf & _
       "It appears that it contains some special characters.", _
       vbExclamation, _
       cORA_DIALOG_CAPTION
Else
    Call ErrorHandler.ModuleErrorCatcher("GetOrSetParaXRefBookmark", Err.Description)
End If
Err.Clear
End Function
Function SetXRefBookmarkRange(ByRef rng As Range)
Dim para As Paragraph
Dim sParaStyleName As String
Dim oORAStyles As ORAStyles
Set oORAStyles = New ORAStyles

Set para = rng.Paragraphs.First
sParaStyleName = para.Style.NameLocal

If Not oORAStyles.Exists(sParaStyleName) Then
    Exit Function
End If

Select Case oORAStyles.Item(sParaStyleName).XRefType
    Case Is = "CAPTION"
        Call Captions.ValidateAndFixCaptionParagraph(para)
        rng.Collapse wdCollapseStart
        rng.MoveEndUntil cset:=cCAPTION_LABEL_DELIM
    Case Else
End Select

Set oORAStyles = Nothing

End Function

Function InsertInternalXRef(ByRef sel As Selection, _
                            ByVal sBookmarkName As String, _
                            ByVal sType As String)
Dim rng As Range
Dim rngSel As Range
Dim iBookmarkParaIndex As Integer
Dim sStyleName As String
iBookmarkParaIndex = GetParaIndex(sel.Document.Bookmarks(sBookmarkName).Range.Paragraphs.First)

If VBAUtilities.GetParaIndex(sel.Paragraphs.First) = iBookmarkParaIndex Then
    MsgBox "Can't create self reference.", vbExclamation, cORA_DIALOG_CAPTION
    Exit Function
End If

sStyleName = sel.Paragraphs.First.Style.NameLocal
sStyleName = Split(sStyleName, cSTYLEALIAS_DELIMITER)(0)
sStyleName = ";;" & sStyleName & ";;"
If InStr(cCAPTION_STYLE_NAMES, sStyleName) <> 0 Then
    MsgBox "Sorry, you can't put a cross reference into a caption."
    Exit Function
End If
    

Set rng = sel.Range.Duplicate
sel.InsertCrossReference _
    referencekind:=wdContentText, _
    referenceitem:=sel.Document.Bookmarks(sBookmarkName), _
    referencetype:=wdRefTypeBookmark, _
    insertashyperlink:=True

Select Case sType
    Case "CAPTION"

    Case Else
        Select Case sel.Document.CustomDocumentProperties(cCUSTOM_PROP_SERIES)
            Case cCUSTOM_PROP_SERIES_HACKS
                If sel.Document.Bookmarks(sBookmarkName).Range.Characters.First = "#" Then
                    sel.Style = sel.Document.Styles(cXREF_CHAR_STYLE)
                    rng.InsertBefore "[Hack " & Chr(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34) & "]"
                    Set rngSel = sel.Range
                    rng.Select
                    sel.Style = sel.Document.Styles(cXREF_CHAR_STYLE)
                    rngSel.Select
                    Selection.Font.Reset
                Else
                    rng.InsertBefore Chr$(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34)
                End If
            Case cCUSTOM_PROP_SERIES_CKBK
                If sel.Document.Bookmarks(sBookmarkName).Range.Paragraphs.First.Style = sel.Document.Styles(wdStyleHeading1) Then
                    rng.InsertBefore "[Recipe " & Chr(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34) & "]"
                    Set rngSel = sel.Range
                    rng.Select
                    rngSel.Select
                    Selection.Font.Reset
                Else
                    
                    rng.InsertBefore Chr$(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34)
                End If
            Case Else
                rng.InsertBefore Chr$(34)
                sel.Collapse wdCollapseEnd
                sel.TypeText Chr$(34)
        End Select
End Select
End Function
Function InsertExternalXRef(ByRef sel As Selection, _
                            ByRef docTarget As Document, _
                            ByVal sBookmarkName As String, _
                            ByVal sType As String)
Dim rng As Range
Dim iBookmarkParaIndex As Integer
Dim sTargetDocType As String
Dim sStyleName As String

sStyleName = sel.Paragraphs.First.Style.NameLocal
sStyleName = Split(sStyleName, cSTYLEALIAS_DELIMITER)(0)
sStyleName = ";;" & sStyleName & ";;"
If InStr(cCAPTION_STYLE_NAMES, sStyleName) <> 0 Then
    MsgBox "Sorry, you can't put a cross reference into a caption."
    Exit Function
End If


iBookmarkParaIndex = GetParaIndex(docTarget.Bookmarks(sBookmarkName).Range.Paragraphs.First)
sTargetDocType = DocumentValidation.CheckChapterLabel(docTarget)

Set rng = sel.Range.Duplicate

sel.Document.Fields.Add _
    Range:=sel.Range, _
    Type:=wdFieldIncludeText, _
    Text:=Chr$(34) & docTarget.Name & Chr$(34) & _
           Chr$(34) & docTarget.Bookmarks(sBookmarkName) & Chr$(34) & "\!", _
    preserveformatting:=False

Select Case sType
    Case "CAPTION"

    Case Else
        Select Case sel.Document.CustomDocumentProperties(cCUSTOM_PROP_SERIES)
            Case cCUSTOM_PROP_SERIES_HACKS
            
                If docTarget.Bookmarks(sBookmarkName).Range.Characters.First = "#" Then
                    rng.InsertBefore "[Hack" & Chr(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34) & "]"
                Else
                    rng.InsertBefore Chr$(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34)
                End If
            Case cCUSTOM_PROP_SERIES_CKBK
            
                If docTarget.Bookmarks(sBookmarkName).Range.Paragraphs.First.Style = docTarget.Styles(wdStyleHeading1) Then
                    rng.InsertBefore "[Recipe " & Chr(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34) & "]"
                Else
                    rng.InsertBefore Chr$(34)
                    sel.Collapse wdCollapseEnd
                    sel.TypeText Chr$(34)
                End If
            Case Else
                rng.InsertBefore Chr$(34)
                sel.Collapse wdCollapseEnd
                sel.TypeText Chr$(34)
        End Select
End Select

End Function
Function GetChapterLabelBookmark(doc As Document) As String
Dim para As Paragraph
Dim sBookmarkName As String
If Len(DocumentValidation.CheckChapterLabel(doc)) = 0 Then
    GetChapterLabelBookmark = vbNullString
    Exit Function
End If
Set para = doc.Paragraphs.First
sBookmarkName = GetOrSetParaXRefBookmark(para)
Set para = Nothing
GetChapterLabelBookmark = sBookmarkName
End Function
Sub InsertAutoXRef()
'On Error GoTo ERR_HANDLER
Dim sSelectedText As String
Dim paraSelection As Paragraph
Dim paraMatch As Paragraph
Dim paraText As String
Dim sSelectionStyleName As String
Dim sBookmarkName As String
Dim sParaStyleName As String
Dim para As Paragraph
Dim sel As Selection
Dim iNumMatches As Integer
Dim oORAStyles As ORAStyles

'========== Settings and Messages ===========
Dim sMessageMissingChapterLabel As String
Dim sMessageNoXRefsInsideCaption As String
Dim sMessageSelectionSpansMultipleParagraphs As String


sMessageSelectionSpansMultipleParagraphs = _
 "Can't do this if selection spans multiple paragraphs"

sMessageNoXRefsInsideCaption = _
 "Sorry, can't create a cross reference inside a caption."

sMessageMissingChapterLabel = _
    "The first paragraph in the document must be styled" & vbCr & _
    "with the " & cCHAPTER_LABEL_STYLE & " style," & vbCr & _
    "and must contain only the chapter number (or appendix letter)." & vbCr & _
    "Use " & Chr$(34) & "P" & Chr$(34) & " for the Preface."

'============================================

Set sel = Selection

If sel.Range.Paragraphs.Count > 1 Then
    MsgBox sMessageSelectionSpansMultipleParagraphs, _
        vbExclamation, _
        cORA_DIALOG_CAPTION
    Set sel = Nothing
    Exit Sub
End If

Set oORAStyles = New ORAStyles
sSelectionStyleName = Split(sel.Range.Paragraphs.First.Style.NameLocal, cSTYLEALIAS_DELIMITER)(0)

If oORAStyles.Exists(sSelectionStyleName) Then
    If oORAStyles.Item(sSelectionStyleName).XRefType = "CAPTION" Then
        MsgBox sMessageNoXRefsInsideCaption, _
        vbExclamation, _
        cORA_DIALOG_CAPTION
    Set sel = Nothing
    Set oORAStyles = Nothing
    Exit Sub
    End If
End If

Call VBAUtilities.ChompSelection(sel)
sSelectedText = sel.Text

StatusBar = "Looking for: " & Chr$(34) & sSelectedText & Chr$(34) & " ... Please Wait."

If (Captions.DoesStringReferToCaptionLabel(sSelectedText)) Then
    ' User is trying to reference a caption
    If Len(DocumentValidation.CheckChapterLabel(sel.Document)) = 0 Then
        MsgBox sMessageMissingChapterLabel, _
        vbExclamation, _
        cORA_DIALOG_CAPTION
        
        Set sel = Nothing
        Set oORAStyles = Nothing
        StatusBar = vbNullString
        Exit Sub
    End If

    For Each para In sel.Document.Paragraphs
        sParaStyleName = Split(para.Style.NameLocal, cSTYLEALIAS_DELIMITER)(0)
        If oORAStyles.Exists(sParaStyleName) Then
            If oORAStyles.Item(sParaStyleName).XRefType = "CAPTION" Then
                If Captions.DoesStringMatchThisCaption(sSelectedText, para) = True Then
                    ' Found a match
                    sBookmarkName = GetOrSetParaXRefBookmark(para)
                    Call InsertInternalXRef(sel, sBookmarkName, "CAPTION")
                    Set sel = Nothing
                    Set para = Nothing
                    Set oORAStyles = Nothing
                    StatusBar = vbNullString
                    Exit Sub
                End If
            End If
        End If
        
    Next para
Else
    Set paraSelection = sel.Paragraphs.First
    ' User is referencing a paragraph other than a caption
    For Each para In sel.Document.Paragraphs
        If Not paraSelection Is para Then
             paraText = Left$(para.Range.Text, para.Range.Characters.Count - 1)
             paraText = Trim$(paraText)
             If sSelectedText = paraText Then
                iNumMatches = iNumMatches + 1
                Set paraMatch = para
             End If
        End If
    Next para
End If

Select Case iNumMatches
    Case 0
        If (MsgBox("Couldn't find a reference target for: " & vbCr & _
                   Chr$(34) & sSelectedText & Chr$(34) & vbCr & _
                   "Would you like to try and find in manually?", _
                   vbYesNo, _
                   cORA_DIALOG_CAPTION)) = vbYes Then
            Call XRefs.ShowXRefDialog
        Else
            Exit Sub
        End If
    Case 1
        sBookmarkName = XRefs.GetOrSetParaXRefBookmark(paraMatch)
        Call XRefs.InsertInternalXRef(sel, sBookmarkName, "DEFAULT")
        Exit Sub
    Case Else
        If (MsgBox("Found " & iNumMatches & " possible matches for:" & vbCr & _
                   Chr$(34) & sSelectedText & Chr$(34) & vbCr & _
                   "Would you like to choose one manually?", _
                   vbYesNo, _
                   cORA_DIALOG_CAPTION)) = vbYes Then
            Call XRefs.ShowXRefDialog
        Else
            Exit Sub
        End If
End Select
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("InsertAutoXRef", Err.Description)
Err.Clear

End Sub
Sub ShowXRefDialog()
    Call VBAUtilities.CheckDirectory
    ufXRefs.Show
End Sub
Function ChangeXRefSrcFile(doc As Document, ByVal sOld As String, ByVal sNew As String)
On Error GoTo ERR_HANDLER
Dim fld As Field
For Each fld In doc.Fields
    If fld.Type = wdFieldIncludeText Then
        fld.Code.Text = Replace(fld.Code, sOld, sNew)
    End If
Next fld
Exit Function
ERR_HANDLER:
Call ErrorHandler.ModuleErrorCatcher("ChangeXRefSrcFile", Err.Description)
Err.Clear
End Function
Function UpdateXRefs(doc As Document)
Dim fld As Field
Dim sOpenFiles As String
Dim v As Variant
Dim i As Integer
For i = 1 To Documents.Count
    If Not Documents(i).Name = doc.Name Then
        sOpenFiles = sOpenFiles & Documents(i).Name & "/"
    End If
Next i

For Each fld In doc.Fields
    If fld.Type = wdFieldIncludeText Then
        If InStr(sOpenFiles, fld.Parent) Then
            fld.Locked = False
            fld.Update
            fld.Locked = True
        Else
            fld.Locked = True
        End If
    End If
Next fld
doc.Fields.Update
End Function
Sub ShowChangeXRefSrcDialog()
ufSwapXRefSrc.Show
End Sub
Sub UpdateDocumentReferences()
Call UpdateXRefs(ActiveDocument)
End Sub
Sub UseWordXRefs()
Dim dial As Dialog
Set dial = Dialogs(wdDialogInsertCrossReference)
dial.Show
End Sub
Attribute VB_Name = "ufSwapXRefSrc"
Attribute VB_Base = "0{B40BEBBB-5A9A-461B-A38E-51BED5841846}{3E91A04C-F841-4BE1-A401-1B2D1AF1B9AB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Private Sub cbDone_Click()
Unload Me
End Sub

Private Sub UserForm_Initialize()
Dim doc As Document
Dim fld As Field
Dim sExternalFiles As String
'Dim sOpenFiles As String
Dim vFieldCode As Variant
Dim vFilesFound As Variant
Dim v As Variant
Dim i As Integer
Dim j As Integer
Dim k As Integer

'========== Settings and Messages ==========
Dim sDocExtenstion As String
Dim sNoFilesFound As String

sDocExtenstion = ".doc"
sNoFilesFound = cNONE
'===========================================

'sOpenFiles = "/"
Set doc = ActiveDocument


sExternalFiles = "/"
For Each fld In doc.Fields
    If fld.Type = wdFieldIncludeText Then
        vFieldCode = Split(fld.Code.Text, Chr$(34))
        For Each v In vFieldCode
            If InStr(v, sDocExtenstion) Then
                If InStr(sExternalFiles, ("/" & v & "/")) = 0 Then
                    sExternalFiles = sExternalFiles & v & "/"
                End If
            End If
        Next v
    End If
Next fld

If Len(sExternalFiles) = 1 Then
    sExternalFiles = sNoFilesFound
End If

vFilesFound = Split(sExternalFiles, "/")
For Each v In vFilesFound
    If Len(v) <> 0 Then
        lbFrom.AddItem v
    End If
Next v

For i = 1 To Documents.Count
    If Not Documents(i).Name = doc.Name Then
        lbTo.AddItem Documents(i).Name
    End If
Next i
End Sub
Private Sub cbChange_Click()
Dim i As Integer
Dim doc As Document
Dim sFromFile As String
Dim sToFile As String

'========= Settings and Messages ==========
Dim sMessageNoFrom As String
Dim sMessageInvalidTo As String

sMessageNoFrom = _
    "No external references were found in the current document." & vbCr & _
    "Press Done to close the dialog."
    
sMessageInvalidTo = _
    "Either there are no other files open, or you haven't selected" & vbCr & _
    "one from the list of choices. Please choose one or press Done to exit"
'==========================================
If IsNull(lbTo.Value) Then Exit Sub

sFromFile = lbFrom.Value
sToFile = lbTo.Value

If sFromFile = cNONE Then
    MsgBox sMessageNoFrom, _
        vbInformation, _
        cORA_DIALOG_CAPTION
    Exit Sub
ElseIf sToFile = vbNullString Then
    MsgBox sMessageInvalidTo, _
        vbInformation, _
        cORA_DIALOG_CAPTION
    Exit Sub
End If

If chkAllFiles = True Then
    For i = 1 To Documents.Count
        Set doc = Documents(i)
        Call XRefs.ChangeXRefSrcFile(doc, sFromFile, sToFile)
        Call XRefs.UpdateXRefs(doc)
        'Set doc = Nothing
    Next i
Else
    Set doc = ActiveDocument
    Call XRefs.ChangeXRefSrcFile(doc, sFromFile, sToFile)
End If
Call XRefs.UpdateXRefs(doc)
Unload Me
Call XRefs.ShowChangeXRefSrcDialog
Exit Sub

End Sub
Attribute VB_Name = "ufXRefs"
Attribute VB_Base = "0{D64E8EFC-2E45-4363-9D2B-CF47C845E5CC}{F3FC37F7-18C7-4471-A4C1-71509F471370}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




Option Explicit
Private G_colParagraphData As Collection
Private G_oORAStyles As ORAStyles
Private G_docSelectedInDialog As Document
'########################################
' This is the code "behind" the Insert Cross Reference
' dialog. The user form is loosely based on the dialog
' in FrameMaker. These are the userform's controls:
'
' cbOpenFiles: A combo box that lists all the open
'              Word files in the same directory as
'              the active document
' lbStyles:    A list box that lists all the paragraph
'              styles in the current document, unless
'              user has optionally chosen to list only
'              a subset
' lbParas:     All of the paragraphs in the selected
'              document that are tagged with the style
'              selected in the lbStyles listbox
' cmbInsert:   Calls the appropriate functions to insert
'              a cross reference at the insertion point
' cmbCancel:   Unloads and exits the UserForm
'
' cmbShowShortList: Button to toggle between listing all
'              the styles in a document, or just a subset
' ########################################
Private Sub cmbCancel_Click()
    Unload Me
End Sub



Private Sub lbParas_DblClick(ByVal cancel As MSForms.ReturnBoolean)
    Call cmbInsert_Click
End Sub

Private Sub UserForm_Initialize()
'On Error GoTo ERR_HANDLER
Dim doc As Document
Dim docActive As Document
Dim i As Integer
Set G_oORAStyles = New ORAStyles

Set docActive = Selection.Document
For i = 1 To Documents.Count
    Set doc = Documents(i)
    If Not doc = docActive Then
        If doc.Path = docActive.Path Then
            cbOpenFiles.AddItem doc.Name
        End If
    End If
    Set doc = Nothing
Next i

cbOpenFiles.AddItem pvargitem:=docActive.Name, pvargindex:=0
cbOpenFiles.ListIndex = 0
Set docActive = Nothing
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ClassErrorCatcher("ufXRefs", "Initialize", Err.Description)
Err.Clear
End Sub
Private Sub cbOpenFiles_Change()
'On Error GoTo ERR_HANDLER
Dim sty As Style
Dim i As Integer
Dim sStyleName As String
Dim sPreviousStyle As String
Dim bShowOnlyShortList As Boolean


lbStyles.Clear

Set G_docSelectedInDialog = Documents(cbOpenFiles.Value)
Call Config.CheckDocumentVariables(G_docSelectedInDialog)
bShowOnlyShortList = G_docSelectedInDialog.Variables(cCUSTOM_PROP_XREFS_LIST_ALL_STYLES)
sPreviousStyle = G_docSelectedInDialog.Variables(cCUSTOM_PROP_XREFS_PREVIOUS_STYLE)

If (bShowOnlyShortList) Then
    cbShowShortList.Caption = cUF_XREFS_SHOW_ALL
Else
    cbShowShortList.Caption = cUF_XREFS_SHOW_SHORT_LIST
End If

For Each sty In G_docSelectedInDialog.Styles
    If sty.Type = wdStyleTypeParagraph Then
        sStyleName = Split(sty.NameLocal, cSTYLEALIAS_DELIMITER)(0)
        If (bShowOnlyShortList) Then
            If (G_oORAStyles.Exists(sStyleName)) Then
                If (G_oORAStyles.Item(sStyleName).XRefShowInShortList) Then
                    lbStyles.AddItem sStyleName
                End If
            End If
        Else
            lbStyles.AddItem sStyleName
        End If
    End If
Next sty

If Not (sPreviousStyle = cNONE) Then ' And (Not lbStyles = Null) Then
    
    For i = 0 To (lbStyles.ListCount - 1)
        If lbStyles.List(i) = sPreviousStyle Then
            lbStyles.Selected(i) = True
            Call lbStyles_Change
            Exit For
        End If
    Next i
End If

Exit Sub
ERR_HANDLER:
Call ErrorHandler.ClassErrorCatcher("ufXRefs", "Initialize", Err.Description)
Err.Clear
End Sub
Private Sub lbStyles_Change()
'On Error GoTo ERR_HANDLER
Dim col As Collection
Dim para As Paragraph
Dim sParaStyleName As String
Dim k As Integer

Set G_colParagraphData = New Collection
lbParas.Clear

k = 1
For Each para In G_docSelectedInDialog.Paragraphs
    sParaStyleName = Split(para.Style.NameLocal, cSTYLEALIAS_DELIMITER)(0)
    If sParaStyleName = lbStyles.Value Then
        Set col = New Collection
        col.Add Key:="Index", Item:=k
        col.Add Key:="Text", Item:=Left(para.Range.Text, para.Range.Characters.Count - 1)
        col.Add Key:="Style", Item:=para.Style
        col.Add Key:="Type", Item:=G_oORAStyles.Item(sParaStyleName).XRefType
        G_colParagraphData.Add Item:=col
        lbParas.AddItem (col("Text"))
        Set col = Nothing
   End If
k = k + 1
Next para

If Not IsNull(lbStyles.Value) Then
    G_docSelectedInDialog.Variables(cCUSTOM_PROP_XREFS_PREVIOUS_STYLE) = lbStyles.Value
End If

lbStyles.SetFocus
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ClassErrorCatcher("ufXRefs", "lbStyles_Change", Err.Description)
Err.Clear
End Sub
Private Sub cmbInsert_Click()
'On Error GoTo ERR_HANDLER
Dim iSelectedPara As Integer
Dim paraSelected As Paragraph

Dim sXRefType As String
Dim sel As Selection
Dim sXRefBookmarkName As String
Dim bExternalRef As Boolean

iSelectedPara = lbParas.ListIndex + 1
If iSelectedPara = 0 Then Exit Sub


Set sel = Selection
If sel.Paragraphs.Count <> 1 Then
    MsgBox "Can't insert a cross reference when selection includes more than one paragraph", _
           vbExclamation, _
           cORA_DIALOG_CAPTION
    Unload Me
    Exit Sub
End If

Set paraSelected = G_docSelectedInDialog.Paragraphs(G_colParagraphData(iSelectedPara)("Index"))
sXRefType = G_colParagraphData(iSelectedPara)("Type")
If Not (G_docSelectedInDialog = Selection.Document) Then
    bExternalRef = True
End If

sXRefBookmarkName = XRefs.GetOrSetParaXRefBookmark(paraSelected)

Select Case bExternalRef
    Case Is = False
        Call XRefs.InsertInternalXRef(sel, sXRefBookmarkName, sXRefType)
    Case Is = True
        Call XRefs.InsertExternalXRef(sel, G_docSelectedInDialog, sXRefBookmarkName, sXRefType)
End Select

Unload Me
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ClassErrorCatcher("ufXRefs", "cmbInsert_Click", Err.Description)
Err.Clear
End Sub
Private Sub cbShowShortList_Click()
'On Error GoTo ERR_HANDLER
Dim bShowAllStyles As Boolean

bShowAllStyles = G_docSelectedInDialog.Variables(cCUSTOM_PROP_XREFS_LIST_ALL_STYLES)

bShowAllStyles = Not bShowAllStyles

If bShowAllStyles Then
    cbShowShortList.Caption = cUF_XREFS_SHOW_SHORT_LIST
Else
    cbShowShortList.Caption = cUF_XREFS_SHOW_ALL
End If

G_docSelectedInDialog.CustomDocumentProperties(cCUSTOM_PROP_XREFS_LIST_ALL_STYLES) = bShowAllStyles

Call cbOpenFiles_Change
Exit Sub
ERR_HANDLER:
Call ErrorHandler.ClassErrorCatcher("ufXRefs", "cbShowShortList_Click", Err.Description)
Err.Clear
End Sub



' InQuest injected base64 decoded content
' Qjwh
' *'~(.
' z+x*'~*
' N}'+y
'  hw#
' ,Lj{
' -x*'
' ^N+ey+r
' j+u+r
' J'^m
' Z+"w(
' Z+"w(
' z{l"p
' QbzWlN
' QbzWlN
' Z+a	
' xz%u
' ,Lj{
' ^t(Z
' *'Z+a
' jZ M
' Qjwh
' jZ "{

INQUEST-PP=macro
