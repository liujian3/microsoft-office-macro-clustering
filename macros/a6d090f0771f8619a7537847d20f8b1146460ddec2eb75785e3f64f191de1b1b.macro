Attribute VB_Name = "CRangeGrid"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#Const DOTNETBUILD = 1


#If Win64 Then
Private Declare PtrSafe Function VarFormatFromTokensVB Lib "oleaut32" Alias "VarFormatFromTokens" (ByRef pvarIn As Variant, ByVal pstrFormat As LongPtr, ByRef pbTokCur As Byte, ByVal dwFlags As Long, ByVal pbstrOut As LongPtr, ByVal lcid As Long) As Long
Private Declare PtrSafe Function VarTokenizeFormatStringVB Lib "oleaut32" Alias "VarTokenizeFormatString" (ByVal pstrFormat As LongPtr, ByRef rgbTok As Byte, ByVal cbTok As Long, ByVal iFirstDay As Long, ByVal iFirstWeek As Long, ByVal lcid As Long, pcbActual As Long) As Long
Private Declare PtrSafe Function VariantChangeTypeExVB Lib "oleaut32" Alias "VariantChangeTypeEx" (ByRef pvargDest As Variant, ByRef pvarSrc As Variant, ByVal lcid As Long, ByVal wFlags As Integer, ByVal vt As Integer) As Long
#Else
Private Declare Function VarFormatFromTokensVB Lib "oleaut32" Alias "VarFormatFromTokens" (ByRef pvarIn As Variant, ByVal pstrFormat As Long, ByRef pbTokCur As Byte, ByVal dwFlags As Long, ByVal pbstrOut As Long, ByVal lcid As Long) As Long
Private Declare Function VarTokenizeFormatStringVB Lib "oleaut32" Alias "VarTokenizeFormatString" (ByVal pstrFormat As Long, ByRef rgbTok As Byte, ByVal cbTok As Long, ByVal iFirstDay As Long, ByVal iFirstWeek As Long, ByVal lcid As Long, pcbActual As Long) As Long
Private Declare Function VariantChangeTypeExVB Lib "oleaut32" Alias "VariantChangeTypeEx" (ByRef pvargDest As Variant, ByRef pvarSrc As Variant, ByVal lcid As Long, ByVal wFlags As Integer, ByVal vt As Integer) As Long
#End If

Private WithEvents m_worksheet As Excel.Worksheet
Attribute m_worksheet.VB_VarHelpID = -1
Private WithEvents m_frmLog_cbOK As MSForms.CommandButton
Attribute m_frmLog_cbOK.VB_VarHelpID = -1
Private WithEvents m_cmb9 As MSForms.ComboBox
Attribute m_cmb9.VB_VarHelpID = -1
Private WithEvents m_cmb8 As MSForms.ComboBox
Attribute m_cmb8.VB_VarHelpID = -1
Private WithEvents m_cmb7 As MSForms.ComboBox
Attribute m_cmb7.VB_VarHelpID = -1
Private WithEvents m_cmb6 As MSForms.ComboBox
Attribute m_cmb6.VB_VarHelpID = -1
Private WithEvents m_cmb5 As MSForms.ComboBox
Attribute m_cmb5.VB_VarHelpID = -1
Private WithEvents m_cmb4 As MSForms.ComboBox
Attribute m_cmb4.VB_VarHelpID = -1
Private WithEvents m_cmb3 As MSForms.ComboBox
Attribute m_cmb3.VB_VarHelpID = -1
Private WithEvents m_cmb2 As MSForms.ComboBox
Attribute m_cmb2.VB_VarHelpID = -1
Private WithEvents m_cmb1 As MSForms.ComboBox
Attribute m_cmb1.VB_VarHelpID = -1
Private WithEvents m_cmb0 As MSForms.ComboBox
Attribute m_cmb0.VB_VarHelpID = -1
Private m_frmLog As Object
Private m_DiffActValue As Variant
Private m_DiffLevel0() As Variant
Private m_Diff() As Variant
Private m_bAddDetails_Toplevel As Boolean
Private m_lblValueDifference As MSForms.Label
Private m_arColIndicesPredef(1 To 9) As Integer
Private m_arElementIndicesPredef(1 To 9) As Integer
Private m_bSPIBEW_DiffVPeriode As Boolean
Private m_nCountColInfos As Long
Private m_arColInfos() As TColInfo
Private m_Config As TConfig
Private Const NLevel_Static = -1
Private Const NLevel_Max = -2
Private Const EnStgType_Bound = 8
Private Const EnStgType_CellComment = 4
Private Const EnStgType_CellAttribute = 2
Private Const EnStgType_Cell = 1
Private m_CallContext_LocaleID_temp As Long

Private m_CallContext_LocaleIDNumberSeparator_temp As Long 'ggf. abweichende Kennung f|fffd|r Dezimaltrenner

Private m_collCellAttributes As Collection
Private Const N_COUNT_CMB_MAX As Integer = 10
Private m_collNameToIndex As Collection
Private m_ListFieldOleObject As Object
Private m_bListFieldSelectedInsert As Boolean
Private m_nListFieldSelectedLevel As Long
Private Const EnCheckErrorInvalidRef = 273
Private Const EnCheckErrorFunctionalWildcards = 199
Private Const EnCheckErrorInvalidValue = 198
Private Const EnCheckErrorInvalidType = 197
Private Const EnCheckErrorInvalidNull = 196
Private Const EnCheckErrorExportWildcards = 190
Private Const EnCheckErrorExceedsLen = 189
Private Const EnCheckErrorMissingValue = 188
Private Const IDL_ERROR_BASE = &HA0080000
Private m_bContextMenuLoaded As Boolean
Private m_nColIndexAddDetails As Long
Private m_nListFieldEndRow As Long
Private m_rListFieldStart As Range
Private m_nCountYKeyLevels As Long
Private m_container As CSaldenEditor
Private m_bActive As Boolean
Private m_ClassName As String
Public CallContext As Object
Private Type TColInfo
  Name As String
  uml_ex As Long
  BrowseFlags As Long
  VarType As Long
  oType As Object
  CallType As Long
  StgType As Long
  rMap_Keys_BrowseSet As Range
  nCount_Keys_BrowseSet As Long
  IncludeInContextMenu As Boolean
  IncludeInListField As Boolean
  Left As Long
  Top As Long
  Level As Long
  Digits As Long
  Length As Long
  cmb As MSForms.ComboBox
  nListFieldSelectionBegin As Long
  nListFieldSelectionEnd As Long
  Bene3_CommentAttribute As String
  BrowseDependents() As Long
  Formula As String
End Type
Private Type TConfig
  MaintainQuickEditField As Boolean
  Level0_AllignRight As Boolean
  YSizeHeader As Long
  YOffsetHeaderLine As Long
  AutoFilterEnabled As Boolean
  StandardReportFormat As Boolean
End Type

Public Property Get lastDerived() As Object
  Err.Raise E_NOTIMPL
End Property


Private Property Get DetailGrid_PropertiesBrowseset(ByVal oValue As Range, Name As Variant, Optional ByRef nRows As Long) As Range
  Dim bHandled As Boolean
  Dim i As Long
  Dim rBrowseset As Range
  Dim rObjID As Range
  Dim rObjIDsSrc As Range
  Dim nBindingSrc As Long
  Dim nBinding As Long
  Dim vntMember As Variant
  Dim strKtoNr As String
  Dim vntValue As Variant
  If VarType(Name) = vbString Then
    vntMember = Name
    InvokeRange 0, vntMember
    nBinding = vntMember
  Else
    nBinding = Name
  End If
  Select Case m_arColInfos(nBinding).Name
    Case "IcUBR"
      nBindingSrc = nBinding - 1
      Do
        If m_arColInfos(nBindingSrc).Name = "IcGes" Then
          Exit Do
        End If
        nBindingSrc = nBindingSrc - 1
        If nBindingSrc < 0 Then
          Exit Do
        End If
      Loop
      If nBindingSrc >= 0 Then
        Set rObjIDsSrc = m_arColInfos(nBindingSrc).rMap_Keys_BrowseSet
        Set rObjID = Nothing
        If oValue Is Nothing Then
          i = m_arColInfos(nBindingSrc).cmb.ListIndex
          If (m_arColInfos(nBindingSrc).uml_ex And EnUmlEx_OPTIONAL) <> 0 Then
            i = i - 1
          End If
          If i >= 0 And Not rObjIDsSrc Is Nothing Then
            Set rObjID = RangeMulti_Item(rObjIDsSrc, i)
          End If
        Else
          InvokeRange VbGet, nBindingSrc, vntValue, oValue
          Set rObjID = IDLVLookup(rObjIDsSrc, vntValue)
        End If
        If Not rObjID Is Nothing Then
          Set rObjIDsSrc = m_container.DataRange_Find("UBR")
          Set rBrowseset = m_container.EvaluteRefKeyList(rObjIDsSrc.Resize(1, 1), rObjID.Offset(0, EnDataCols_Knz2), i)
        End If
        bHandled = True
      End If
    Case "Pro"
      nBindingSrc = 0
      If m_arColInfos(nBindingSrc).Name = "KtoNr" Then
        Set rObjIDsSrc = m_arColInfos(nBindingSrc).rMap_Keys_BrowseSet
        Set rObjID = Nothing
        If oValue Is Nothing Then
          i = m_arColInfos(nBindingSrc).cmb.ListIndex
          If (m_arColInfos(nBindingSrc).uml_ex And EnUmlEx_OPTIONAL) <> 0 Then
            i = i - 1
          End If
          If i >= 0 And Not rObjIDsSrc Is Nothing Then
            Set rObjID = RangeMulti_Item(rObjIDsSrc, i)
          End If
        Else
          InvokeRange VbGet, nBindingSrc, vntValue, oValue
          Set rObjID = IDLVLookup(rObjIDsSrc, vntValue)
        End If
        If Not rObjID Is Nothing Then
          strKtoNr = rObjID.Value
          Set rObjIDsSrc = m_container.DataRange_Find("PRO")
          If Not rObjIDsSrc Is Nothing Then
            For Each rObjID In rObjIDsSrc
              If rObjID.Offset(0, EnDataCols_Knz).Value = strKtoNr Then
                If rBrowseset Is Nothing Then
                  Set rBrowseset = rObjID
                Else
                  Set rBrowseset = Union(rBrowseset, rObjID)
                End If
              End If
            Next rObjID
          End If
        End If
        bHandled = True
      End If
  End Select
  If bHandled Then
    Set DetailGrid_PropertiesBrowseset = rBrowseset
  Else
    Set DetailGrid_PropertiesBrowseset = CRangeGrid_PropertiesBrowseset(Nothing, nBinding, nRows)
  End If
End Property

Public Property Get PropertiesBrowseset(ByVal oValue As Range, Name As Variant, Optional ByRef nRows As Long) As Range
  Set PropertiesBrowseset = DetailGrid_PropertiesBrowseset(oValue, Name, nRows)
End Property

Private Property Get CRangeGrid_PropertiesBrowseset(ByVal oValue As Range, Name As Variant, Optional ByRef nRows As Long) As Range
  Dim vntMember As Variant
  If VarType(Name) = vbString Then
    vntMember = Name
    InvokeRange 0, vntMember
  Else
    vntMember = Name
  End If
  Set CRangeGrid_PropertiesBrowseset = m_arColInfos(vntMember).rMap_Keys_BrowseSet
End Property

Public Property Get TopLeftImpl(ByVal rObjID As Range) As Range
  If rObjID.Column = NColObjID Then
    Set TopLeftImpl = rObjID.Offset(0, 1 - NColObjID)
  Else
    Set TopLeftImpl = rObjID
  End If
End Property


Public Property Get KeyLevelImpl(ByVal rObjID As Range) As Integer
  Dim nLevel As Integer
  Dim nYLevel As Integer, nXLevel As Integer
  Dim i As Long
  nLevel = -1
  If Not rObjID Is Nothing Then
    nXLevel = 0
    If m_nColIndexAddDetails >= 0 Then
      i = rObjID.Column
      If i >= NColAddDetailsFirst Then
        nXLevel = 1
        Set rObjID = rObjID.Offset(0, NColObjID - i)
      End If
    End If
    If rObjID.Value = "" Then
      nYLevel = -1
    Else
      If rObjID.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
        If m_Config.Level0_AllignRight Then
          nYLevel = 0
        Else
          nYLevel = m_nCountYKeyLevels - 1
        End If
      Else
        nYLevel = rObjID.IndentLevel
        If m_Config.Level0_AllignRight Then nYLevel = nYLevel + 1
      End If
    End If
    If nYLevel >= 0 Then
      nLevel = nXLevel + nYLevel
    End If
  End If
  KeyLevelImpl = nLevel
End Property


Public Property Get KeyLevels_Count() As Integer
  If m_nColIndexAddDetails >= 0 Then
    KeyLevels_Count = m_nCountYKeyLevels + 1
  Else
    KeyLevels_Count = m_nCountYKeyLevels
  End If
End Property



Public Sub MoveNextImpl(ByVal nLevelBegin As Integer, ByVal nLevelEnd As Integer, ByRef rObjID As Range, ByVal bInitFirst As Boolean)
  Dim rObjIDAct_x As Range
  Dim rObjIDAct_y As Range
  Dim nXLevelAct As Long, nYLevelAct As Long
  Dim nLevelEndAct As Long
  Dim nLevel As Long
  Dim nIndexAddDetails As Long
  Dim bAddDetailsOptional As Boolean
  Dim bAddDetails As Boolean
  Dim bAddDetailsThisLine As Boolean


  Dim nYLevelOptionalCount As Long 'Anzahl der optionalen Y Levels (vom Ende her gez|fffd|hlt)
  Dim i As Long

  nYLevelOptionalCount = 0
  For i = m_nCountYKeyLevels - 1 To 0 Step -1
    If Not TColInfo_IsOptional(m_arColInfos(i)) Then
      Exit For
    End If
    nYLevelOptionalCount = nYLevelOptionalCount + 1
  Next i

 
  If rObjID Is Nothing Then Err.Raise ERR_INVALIDARG
  If m_nColIndexAddDetails >= 0 Then
    bAddDetailsOptional = TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails))
    If Not bAddDetailsOptional Then
      If nLevelEnd = NLevel_Max Then
        nLevelEnd = m_nCountYKeyLevels + 1
      End If
    End If
    bAddDetails = True
  ElseIf nLevelEnd = NLevel_Max Then
    nLevelEnd = m_nCountYKeyLevels
    bAddDetails = False
  End If
  If nLevelEnd >= 0 And nLevelEnd <= m_nCountYKeyLevels Then
    bAddDetails = False
  End If
  nXLevelAct = -1
  If bAddDetails Then
    If rObjID.Column = NColObjID Then
      Set rObjIDAct_y = rObjID
      If bInitFirst Then
        nXLevelAct = -1
      ElseIf bAddDetailsOptional Then
        nXLevelAct = -1
        bInitFirst = True
      Else
        nXLevelAct = 0
        bAddDetailsThisLine = True
      End If
    Else
      Set rObjIDAct_y = rObjID.Offset(0, NColObjID - rObjID.Column)
      nXLevelAct = 1
      Set rObjIDAct_x = rObjID
      nIndexAddDetails = rObjID.Column - NColAddDetailsFirst
    End If
  Else
    Set rObjIDAct_y = rObjID
  End If
  nYLevelAct = -1
  Do
    If nXLevelAct = 0 And bAddDetailsThisLine Then
      Set rObjIDAct_x = rObjIDAct_y.Offset(0, NColAddDetailsFirst - NColObjID)
      nXLevelAct = 1
      nIndexAddDetails = 0
    ElseIf nXLevelAct = 1 Then
      Set rObjIDAct_x = rObjIDAct_x.Offset(0, 1)
      nIndexAddDetails = nIndexAddDetails + 1
      If nIndexAddDetails >= m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet Then
        nXLevelAct = -1
        GoTo NextY
      End If
      If nLevelEnd = NLevel_Max Then
        Exit Do
      End If
    Else
NextY:
      If Not bInitFirst Then
        Set rObjIDAct_y = rObjIDAct_y.Offset(1, 0)
      End If
      nYLevelAct = -1
      If rObjIDAct_y.Row >= m_nListFieldEndRow Then
        Set rObjIDAct_y = Nothing
        Exit Do
      End If
    End If
    If nYLevelAct < 0 Then
      If rObjIDAct_y.Value = "" Then
        GoTo NextEntry
      Else
        If rObjIDAct_y.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
          If m_Config.Level0_AllignRight Then
            nYLevelAct = 0
          Else
            nYLevelAct = m_nCountYKeyLevels - 1
          End If
        Else
          nYLevelAct = rObjIDAct_y.IndentLevel
          If m_Config.Level0_AllignRight Then nYLevelAct = nYLevelAct + 1
        End If
      End If
    End If
    nLevel = nYLevelAct

    If bAddDetails Then
      If nLevel <= m_nCountYKeyLevels - 1 And nLevel >= m_nCountYKeyLevels - nYLevelOptionalCount - 1 Then
        If bAddDetailsOptional And nXLevelAct < 1 Then
          bAddDetailsThisLine = m_container.DetailSheet_IsAddDetail(Me, rObjIDAct_y)
          If Not bAddDetailsThisLine Then
            If nXLevelAct <= 0 Then
              nXLevelAct = 0
              If nLevelEnd = NLevel_Max And Not bInitFirst Then
                Exit Do
              End If
            ElseIf nXLevelAct = 0 Then
              Set rObjIDAct_x = rObjIDAct_y.Offset(0, NColAddDetailsFirst - NColObjID)
              nXLevelAct = 1
              nIndexAddDetails = 0
              If nLevelEnd = NLevel_Max And Not bInitFirst Then
                Exit Do
              End If
            Else
              GoTo NextEntry
            End If
          End If
        Else
          bAddDetailsThisLine = True
        End If
        If nXLevelAct < 0 Then
          nXLevelAct = 0
        ElseIf nXLevelAct > 0 Then
          nLevel = nLevel + nXLevelAct
        End If
      End If
    End If
    If Not bInitFirst And nLevel < nLevelBegin Then
      Set rObjIDAct_y = Nothing
      Exit Do
    End If

    If bInitFirst Then
      If nLevel <= nLevelEnd - 1 And nLevel >= nLevelEnd - nYLevelOptionalCount - 1 Then
        Exit Do 'bereits gefunden
      End If
    Else
      If nLevel <= nLevelEnd - 1 And nLevel >= nLevelEnd - nYLevelOptionalCount - 1 Then
        Exit Do
      ElseIf bAddDetailsOptional Then
        If bAddDetailsThisLine Then
          nLevelEndAct = m_nCountYKeyLevels + 1
        Else
          nLevelEndAct = m_nCountYKeyLevels
        End If
        If nLevel = nLevelEndAct - 1 Then
          Exit Do
        End If
      End If
    End If
NextEntry:
    bInitFirst = False
  Loop
  If nXLevelAct = 1 Then
    Set rObjID = rObjIDAct_x
  Else
    Set rObjID = rObjIDAct_y
  End If
End Sub



Public Sub CheckSelectionStatusDecentral_Impl()
  On Error GoTo ErrHandler
  If ThisPlugin.MenuEnabled Then
    Set CallContext = ThisPlugin
    

    CheckSelectionStatus False
    If ThisPlugin.StatusText = "" Then
      Application.StatusBar = False
    Else
      Application.StatusBar = ThisPlugin.StatusText
      ThisPlugin.StatusText = ""
    End If
    Set CallContext = Nothing
  End If
  Exit Sub
ErrHandler:
  ThisPlugin.StatusText = ""
  Set CallContext = Nothing
End Sub

Public Sub CheckSelectionStatus(ByVal bLeaveSelection As Boolean)
  Dim bSetStatus As Boolean
  Dim strStatus As String
  Dim rObjID As Range
  Dim r As Range
  Dim rKST_Enabled As Range
  If Not bLeaveSelection Then
    If m_container.RepOption = "C" And m_nListFieldSelectedLevel >= 0 Then
      Set rObjID = m_worksheet.Cells(m_arColInfos(0).nListFieldSelectionBegin, NColObjID)
      If Not rObjID Is Nothing Then
        If rObjID.count = 1 Then
          Set r = m_container.EvalRefCell(rObjID)
          If Not r Is Nothing Then
            Set rKST_Enabled = m_container.DataRange_Find("KST_Enabled")
            Set r = IDLVLookup(rKST_Enabled, r.Offset(0, EnDataCols_Knz2 - EnDataCols_ObjID), 0, 1, False)
            If Not r Is Nothing Then
              bSetStatus = True
              strStatus = r.Value & " - " & SearchTextByRObjID(r, nBene:=1)
            End If
          End If
        End If
      End If
    End If
  End If
  If bSetStatus Then
    CallContext.StatusBar.StatusText = strStatus
  End If
End Sub

Private Function CreateLogWindow() As Object
  Dim oDialog As Object
  Dim lbl As MSForms.Label
  Dim cmd As MSForms.CommandButton
  Dim bDotNetSite As Boolean
  Dim oControl As MSForms.Control
  Set oDialog = ThisPlugin.CreateFrame(Width:=400 * 4 / 3, Height:=178 * 4 / 3)
  bDotNetSite = (VBA.TypeName(oDialog) = "Object")
  If bDotNetSite Then
    'eingebaute .Net LogView
    Set ThisPlugin.LogList = oDialog.loadView("de.idl.connector.Gui.LogView")
  Else
    Set lbl = CreateLabel(oDialog.Object, "lblStatus")
    Set oControl = oDialog.Object.Controls.Add("Forms.ListBox.1", "lstLog")
    oControl.Visible = True
    oControl.Height = 100
    oControl.Width = 400
    Set oControl = oDialog.Object.Controls.Add("Forms.CommandButton.1", "cmdOK")
    oControl.Visible = True
    oControl.Top = 120
    oControl.Left = 300
    oControl.Height = 24
    oControl.Width = 78
    Set cmd = oControl
    cmd.Caption = "OK"
    Set m_frmLog_cbOK = cmd
    Set ThisPlugin.LogList = oDialog.Object.lstLog
  End If
  
  Set CreateLogWindow = oDialog
End Function

Private Sub KtoLocatePredfinedColumns()
  Dim i As Long
  If m_bAddDetails_Toplevel Then
    i = m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet
  Else
    i = 1
  End If
  ReDim m_DiffLevel0(0 To i - 1)
  ReDim m_Diff(0 To i - 1)
  For i = LBound(m_arElementIndicesPredef) To UBound(m_arElementIndicesPredef)
    m_arElementIndicesPredef(i) = -1
  Next i
  For i = LBound(m_arColIndicesPredef) To UBound(m_arColIndicesPredef)
    m_arColIndicesPredef(i) = i
  Next i
  If m_nColIndexAddDetails < 0 Then
    m_arColIndicesPredef(NColAddDetailsFirst) = -1
  End If
  Dim nIndexPredef As Long
  For i = 0 To UBound(m_arColInfos)
    Select Case m_arColInfos(i).Name
      Case "WertLW"
        nIndexPredef = NColActValue
      Case "VWertLW"
        nIndexPredef = NColPrevValue
      Case "SHKnz"
        nIndexPredef = NColSHKnz
      Case "BilGuVKnz"
        nIndexPredef = NColBilGuVKnz
      Case "KtoKnz1"
        nIndexPredef = NColKtoKnz1
      Case "KtoKnz2"
        nIndexPredef = NColKtoKnz2
      Case Else
        nIndexPredef = -1
    End Select
    If nIndexPredef > 0 Then
      m_arElementIndicesPredef(nIndexPredef) = i
      m_arColIndicesPredef(nIndexPredef) = -1
      If m_arColInfos(i).StgType = EnStgType_Cell Then
        If m_arColInfos(i).Left >= 0 And m_arColInfos(i).Top >= 0 And m_arColInfos(i).Level <> NLevel_Static Then
          m_arColIndicesPredef(nIndexPredef) = m_arColInfos(i).Left + 1
        End If
      End If
    End If
  Next i
End Sub

Private Sub ReadKtoExistingSheet()
  Dim r As Range, rObjID As Range, rObjIDVector As Range
  Dim nRowLast As Long
  Dim nCountKtoAll As Long
  Dim nActLevel As Long
  Dim i As Long
  If m_ClassName = "" Then
    Exit Sub
  ElseIf m_ClassName = "KTOSAL" Then
    m_nListFieldEndRow = m_worksheet.Range("CheckLog").Row - 8
    Exit Sub
  End If
  m_arColInfos(0).nCount_Keys_BrowseSet = 0
  Set r = m_container.DataRange_Find("KTO", nCountKtoAll)
  If nCountKtoAll > 0 Then
    Set r = r.Cells(1, 1)
    Set r = r.Offset(0, -EnDataCols_ObjID)
  Else
    Set m_rListFieldStart = r
    Exit Sub
  End If
  Set m_rListFieldStart = r
  Set m_arColInfos(0).rMap_Keys_BrowseSet = Nothing
  Set rObjID = m_worksheet.Cells(m_Config.YSizeHeader + 1, NColObjID)
  If rObjID.Value <> "" Then
    If rObjID.Offset(1, 0) = "" Then
      Set rObjIDVector = rObjID
    Else
      Set rObjIDVector = m_worksheet.Range(rObjID, rObjID.End(xlDown))
    End If
  End If
  If Not rObjIDVector Is Nothing Then
    For Each rObjID In rObjIDVector
      If rObjID.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
        nActLevel = m_nCountYKeyLevels - 1
      Else
        nActLevel = rObjID.IndentLevel
      End If
      If nActLevel = 0 Then
        If m_arColInfos(0).rMap_Keys_BrowseSet Is Nothing Then
          Set m_arColInfos(0).rMap_Keys_BrowseSet = rObjID
        Else
          Set m_arColInfos(0).rMap_Keys_BrowseSet = Union(m_arColInfos(0).rMap_Keys_BrowseSet, rObjID)
        End If
        nRowLast = rObjID.Row
        m_arColInfos(0).nCount_Keys_BrowseSet = m_arColInfos(0).nCount_Keys_BrowseSet + 1
      ElseIf rObjID.Value <> "" Then
        nRowLast = rObjID.Row
      End If
    Next rObjID
    If nRowLast > 0 Then
      m_nListFieldEndRow = nRowLast + 1
    End If
  End If
End Sub

Private Sub LoadCellAttributes()
  Dim r As Range
  Set r = ObjIDVector
  If r Is Nothing Then
    Set m_collCellAttributes = New Collection
  Else
    Set m_collCellAttributes = CalculateFunctionObjects(ObjIDVector)
  End If
End Sub

Private Sub ReadDetailInfos()
  Dim nCount As Long
  Dim r As Range
  Dim strNameBrowsesetAddDetails As String
  Dim strTag As String
  Dim strName As String
  Dim i As Long
  Dim bAddDetails_CNT_UKV As Boolean
  Dim bAddIcGes As Boolean
  Dim nIndexIcGes As Long
  Dim strTypeName As String

#If CNTDIM_ENABLED Then
  Dim nIndexKst As Long
#End If

  
  strTypeName = TypeName
  
  If strTypeName = "KTOSAL" Then
    m_Config.MaintainQuickEditField = False
    m_Config.YSizeHeader = 7
    m_Config.Level0_AllignRight = True
    m_Config.AutoFilterEnabled = False
    m_Config.StandardReportFormat = True
  ElseIf strTypeName <> "" Then
    m_Config.MaintainQuickEditField = True
    m_Config.YSizeHeader = 9
    m_Config.AutoFilterEnabled = True
    m_Config.StandardReportFormat = True
  End If
  m_Config.YOffsetHeaderLine = m_Config.YSizeHeader - 2
#If CENTRALBUILD = 1 And VBIDE = 0 Then
  Dim pSafeArray_ColInfos As Long
  Dim pColInfo As Long
  Dim t As tagSAFEARRAY
  Dim pColInfoTemp As Long
  Dim colInfoTemp As TColInfo
  Dim nSizeCopy As Long
  Dim nIndexKeyLast As Long
  If m_container.Standalone And m_container.Version >= 9 And strTypeName <> "KTOSAL" Then
    pSafeArray_ColInfos = This_Decentral.ColInfosPtr
    If pSafeArray_ColInfos = 0 Then Err.Raise ERR_INVALIDARG
    CopyMemory VarPtr(t), pSafeArray_ColInfos, LenB(t)
    nSizeCopy = LenB(colInfoTemp)
    If nSizeCopy < t.cbElements Then Err.Raise ERR_INVALIDARG
    pColInfo = t.pvData
    nCount = t.rgsabound(0).cElements
    ReDim m_arColInfos(nCount - 1)
    pColInfoTemp = VarPtr(colInfoTemp)
    m_nCountYKeyLevels = 0
    For i = 0 To nCount - 1
      CopyMemory pColInfoTemp, pColInfo, t.cbElements
      m_arColInfos(i) = colInfoTemp
      If (colInfoTemp.uml_ex And EnUmlEx_KEY) <> 0 Then
        nIndexKeyLast = i
        m_nCountYKeyLevels = m_nCountYKeyLevels + 1
      End If
      pColInfo = pColInfo + t.cbElements
    Next i
    ZeroMemory pColInfoTemp, nSizeCopy
    m_nCountColInfos = nCount
    If strTypeName = "ICBEW" Then
      If m_nCountYKeyLevels = 4 Then
        m_nColIndexAddDetails = nIndexKeyLast
        m_nCountYKeyLevels = 3
      Else
        m_nColIndexAddDetails = -1
      End If
    Else
      If m_nCountYKeyLevels = 3 Then
        m_nColIndexAddDetails = nIndexKeyLast
        m_nCountYKeyLevels = 2
      Else
        m_nColIndexAddDetails = -1
      End If
    End If
    nCount = 0
    Set r = m_container.DataRange_Find("AddDetails", nCount)
    If nCount = 1 Then
      If r.Value = "BSL" Then
        If m_arColInfos(m_nCountYKeyLevels - 1).Name = "BuchSchl" Then
          m_nCountYKeyLevels = m_nCountYKeyLevels - 1
          m_nColIndexAddDetails = m_nCountYKeyLevels
        End If
      End If
    End If
    ReadKtoExistingSheet
    KtoLocatePredfinedColumns
    Exit Sub
  End If
#End If
  m_nColIndexAddDetails = -1
  m_nCountYKeyLevels = 2
  m_nCountColInfos = m_nCountYKeyLevels
  ReDim m_arColInfos(m_nCountColInfos - 1)
  If strTypeName = "KTOSAL" Then
    m_arColInfos(0).Name = "PosNr"
    m_arColInfos(0).VarType = vbString
    m_arColInfos(0).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    m_arColInfos(0).Length = 14
    m_arColInfos(0).IncludeInListField = True
  Else
    m_Config.MaintainQuickEditField = True
    m_arColInfos(0).Name = "KtoNr"
    m_arColInfos(0).VarType = vbString
    m_arColInfos(0).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    m_arColInfos(0).Length = 14
    Set m_arColInfos(0).oType = m_container.DataRange_Find("FIE__K010-KTOM")
    m_arColInfos(0).IncludeInListField = True
  End If
  ReadKtoExistingSheet
  nIndexIcGes = -1

#If CNTDIM_ENABLED Then
  nIndexKst = -1 'noch undefiniert
#End If

  Select Case strTypeName
    Case "KTOSAL"
      strTag = "FIE__K010-KTOM"
      strName = "KtoNr"
      i = 14
    Case "SPIBEW", "ANLBEW", "KAPBEW", "RUEBEW"
      strTag = "FIE__K037-BSLM"
      strName = "BuchSchl"
      i = 2
      bAddIcGes = True
    Case "ICKTOSAL", "ICBEW"
      strTag = "FIE__K010-K001-GES"
      strName = "IcGes"
      i = 6
      nIndexIcGes = 1
    Case "KSTSAL"
      strTag = "FIE__K063-KSTM"
      strName = "KstNr"

#If CNTDIM_ENABLED Then
      nIndexKst = 1
#End If

      i = 14
    Case Else
      strTag = ""
      strName = ""
  End Select
  If strTag <> "" Then
    Set m_arColInfos(1).oType = m_container.DataRange_Find(strTag)
  End If
  m_arColInfos(1).Name = strName
  m_arColInfos(1).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(1).IncludeInListField = True
  m_arColInfos(1).VarType = vbString
  m_arColInfos(1).Length = i
  Set m_arColInfos(1).rMap_Keys_BrowseSet = m_container.DataRange_Find("Details_" & m_ClassName & "_Enabled", m_arColInfos(1).nCount_Keys_BrowseSet)
  If m_arColInfos(1).rMap_Keys_BrowseSet Is Nothing Then
    Set m_arColInfos(1).rMap_Keys_BrowseSet = m_container.DataRange_Find("Details_" & m_ClassName, m_arColInfos(1).nCount_Keys_BrowseSet)
  End If
  If strTypeName = "ICKTOSAL" Or strTypeName = "ICBEW" Then
    If m_arColInfos(1).nCount_Keys_BrowseSet > 1 Then
      On Error Resume Next
      Set r = IDLVLookup(m_arColInfos(1).rMap_Keys_BrowseSet, m_container.Worksheet.Range("GES"))
      If Err = 0 Then
        ExcludesRowsOnRowMap m_arColInfos(1).rMap_Keys_BrowseSet, r.Row, 1
      End If
      On Error GoTo 0
    End If
  End If


#If CNTDIM_ENABLED Then
  If nIndexKst = 1 Then
    onInsertDetailInfoKst nIndexKst
  End If
  
  If strTypeName = "KTOSAL" Then
    'optional: Kostenstellen bei CDM auch auf Hauptblatt
    ReadKtoExistingSheet 'erneut lesen, da jetzt erst alle Informationen vollst|fffd|ndig
    'Beschriftung, wegen Kompat hier definiert
    Set m_arColInfos(0).oType = m_container.DataRange_Find("FIE__K022-AGGM")
    Set r = PropertiesBrowseset(Nothing, 0)
    If Not r Is Nothing Then
      Set m_arColInfos(0).rMap_Keys_BrowseSet = r
      m_arColInfos(0).nCount_Keys_BrowseSet = RangeMulti_Count(r)
    End If
    
    Set m_arColInfos(1).rMap_Keys_BrowseSet = m_container.DataRange_Find("KTO_BrowseSet", m_arColInfos(1).nCount_Keys_BrowseSet)
    
    
    'Konten sind abh|fffd|ngig von der Pos
    ReDim m_arColInfos(0).BrowseDependents(0)
    m_arColInfos(0).BrowseDependents(0) = 1
  End If
#End If


  If strTypeName = "ICBEW" Then
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    i = m_nCountColInfos
    m_arColInfos(i).Name = "Pro"
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim Or EnBrowseFlagsFunctional_CheckBrowseSet Or EnBrowseFlags_BrowseSet
    m_arColInfos(i).Length = 20
    m_arColInfos(i).IncludeInListField = True
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K059-PRO")
  #If CENTRALBUILD Then
    If m_container.Version <= 9 Then
      Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.DataRange_Find("Pro", m_arColInfos(i).nCount_Keys_BrowseSet)
    Else
  #End If
      ReDim m_arColInfos(0).BrowseDependents(0)
      m_arColInfos(0).BrowseDependents(0) = i
  #If CENTRALBUILD Then
    End If
  #End If
    m_nCountYKeyLevels = m_nCountYKeyLevels + 1
    m_nCountColInfos = m_nCountColInfos + 1
  End If
#If CENTRALBUILD Then
  If m_container.Version < 5 Then
    GoTo PostProcess
  End If
#End If
  nCount = 0
  Set r = m_container.DataRange_Find("AddDetails", nCount)
  If nCount = 1 Then
    If r.Value = "BSL" Then

      'Speziallfall: Zusatzaufriss f|fffd|r BSL nach rechts anstatt nach unten
            
      If m_arColInfos(m_nCountYKeyLevels - 1).Name = "BuchSchl" Then
        If Not bAddIcGes Then
          m_nCountYKeyLevels = m_nCountYKeyLevels - 1
          m_nColIndexAddDetails = m_nCountYKeyLevels
        Else
          'zus|fffd|tzlich ICGes nach unten
          nIndexIcGes = m_nCountYKeyLevels - 1
          m_nColIndexAddDetails = m_nCountYKeyLevels
          Debug.Assert m_nCountYKeyLevels = m_nCountColInfos
          
          'optionales Zusatzattribut als WerteFeld (nach Schl|fffd|sselblock): IcGes
          ReDim Preserve m_arColInfos(m_nCountColInfos)
          m_arColInfos(m_nCountColInfos) = m_arColInfos(m_nCountColInfos - 1) 'bisherigen Buchschl. als ZUsatzaufriss
          
          m_arColInfos(nIndexIcGes).Name = "IcGes"
          m_arColInfos(nIndexIcGes).IncludeInListField = True
          Set m_arColInfos(nIndexIcGes).rMap_Keys_BrowseSet = m_container.DataRange_Find("GES_LIST", m_arColInfos(nIndexIcGes).nCount_Keys_BrowseSet)
          m_arColInfos(nIndexIcGes).uml_ex = EnUmlEx_OPTIONAL
          m_arColInfos(nIndexIcGes).VarType = vbString
          m_arColInfos(nIndexIcGes).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
          m_arColInfos(nIndexIcGes).Length = 6
          m_arColInfos(nIndexIcGes).StgType = 0
          m_arColInfos(nIndexIcGes).Level = nIndexIcGes
          Set m_arColInfos(nIndexIcGes).oType = m_container.DataRange_Find("FIE__K010-K001-GES")
                  
          If m_arColInfos(nIndexIcGes).nCount_Keys_BrowseSet > 1 Then
            Set r = IDLVLookup(m_arColInfos(nIndexIcGes).rMap_Keys_BrowseSet, m_container.Worksheet.Range("GES"))
            ExcludesRowsOnRowMap m_arColInfos(nIndexIcGes).rMap_Keys_BrowseSet, r.Row, 1 'eigene Gesellschaft aus IC-Liste entfernen
          End If
          
          m_nCountColInfos = m_nCountColInfos + 1
          bAddIcGes = False 'muss nicht mehr zus|fffd|tzlich angelegt werden
         
        End If
        
        
        
      End If
      
      
      





    Else
      m_nColIndexAddDetails = m_nCountColInfos
      Set r = r.Offset(0, 1)
      strNameBrowsesetAddDetails = r.Value
      If strNameBrowsesetAddDetails = "AddDetails_UKV" Or strNameBrowsesetAddDetails = "AddDetails_CNT" Then

#If CNTDIM_ENABLED Then
        If nIndexKst >= 0 Then
          'Kostenstelle schon vergeben
          strNameBrowsesetAddDetails = "NullRange"
          m_nColIndexAddDetails = -1
        ElseIf strTypeName = "KTOSAL" Then
#Else
        If strTypeName = "KTOSAL" Then
#End If
          bAddDetails_CNT_UKV = (strNameBrowsesetAddDetails = "AddDetails_UKV")
          If Not bAddDetails_CNT_UKV Then
            strNameBrowsesetAddDetails = "NullRange"
            m_nColIndexAddDetails = -1
          End If
        ElseIf strTypeName = "ICKTOSAL" Then
          bAddDetails_CNT_UKV = True
        Else
          strNameBrowsesetAddDetails = "NullRange"
          m_nColIndexAddDetails = -1
        End If
      End If
    End If
  End If
  m_bAddDetails_Toplevel = (strNameBrowsesetAddDetails = "AddDetails_Periode")
  If m_nColIndexAddDetails >= 0 And strNameBrowsesetAddDetails <> "" Then
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    m_nCountColInfos = m_nCountColInfos + 1
    m_arColInfos(m_nColIndexAddDetails).VarType = vbString
    m_arColInfos(m_nColIndexAddDetails).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    If bAddDetails_CNT_UKV Then
      m_arColInfos(m_nColIndexAddDetails).Name = "KstNr"
      m_arColInfos(m_nColIndexAddDetails).Length = 14


#If CNTDIM_ENABLED Then
      nIndexKst = m_nColIndexAddDetails
#End If

    Else
      Select Case strNameBrowsesetAddDetails
        Case "AddDetails_UBR"
          m_arColInfos(m_nColIndexAddDetails).Name = "UBR"
          m_arColInfos(m_nColIndexAddDetails).Length = 6
        Case "AddDetails_Periode"
          m_arColInfos(m_nColIndexAddDetails).Name = "Periode"
          m_arColInfos(m_nColIndexAddDetails).VarType = vbDate
      End Select
    End If
    Set m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet = m_container.DataRange_Find(strNameBrowsesetAddDetails, m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet)
    m_arColInfos(m_nColIndexAddDetails).IncludeInListField = True
    Set m_arColInfos(m_nColIndexAddDetails).oType = m_container.DataRange_Find("AddDetails")
    If bAddDetails_CNT_UKV Then
      m_arColInfos(m_nColIndexAddDetails).uml_ex = EnUmlEx_OPTIONAL

#If CNTDIM_ENABLED Then
      onInsertDetailInfoKst nIndexKst
#End If

    End If
  End If


#If CNTDIM_ENABLED Then

  If nIndexKst < 0 And Not bAddDetails_CNT_UKV And strTypeName = "ICKTOSAL" And m_container.MitKstSal >= 1 Then
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    nIndexKst = m_nCountColInfos
    
    onInsertDetailInfoKst nIndexKst

  End If

#Else

  If Not bAddDetails_CNT_UKV And strTypeName = "ICKTOSAL" And m_container.MitKstSal >= 1 Then
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    i = m_nCountColInfos
    m_arColInfos(i).Name = "KstNr"
    m_arColInfos(i).Length = 14
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
    m_arColInfos(i).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    m_arColInfos(i).IncludeInListField = True
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K063-KSTM")
    Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.DataRange_Find("KST", m_arColInfos(i).nCount_Keys_BrowseSet)
    m_arColInfos(i).StgType = EnStgType_CellComment
    m_arColInfos(i).Level = NLevel_Max
    m_nCountColInfos = m_nCountColInfos + 1
  End If
#End If


  If bAddIcGes Then
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    m_arColInfos(m_nCountColInfos).Name = "IcGes"
    m_arColInfos(m_nCountColInfos).IncludeInListField = True
    Set m_arColInfos(m_nCountColInfos).rMap_Keys_BrowseSet = m_container.DataRange_Find("GES_LIST", m_arColInfos(m_nCountColInfos).nCount_Keys_BrowseSet)
    m_arColInfos(m_nCountColInfos).uml_ex = EnUmlEx_OPTIONAL
    m_arColInfos(m_nCountColInfos).VarType = vbString
    m_arColInfos(m_nCountColInfos).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    m_arColInfos(m_nCountColInfos).Length = 6
    m_arColInfos(m_nCountColInfos).StgType = EnStgType_CellComment
    m_arColInfos(m_nCountColInfos).Level = NLevel_Max
    Set m_arColInfos(m_nCountColInfos).oType = m_container.DataRange_Find("FIE__K010-K001-GES")
    If m_arColInfos(m_nCountColInfos).nCount_Keys_BrowseSet > 1 Then
      Set r = IDLVLookup(m_arColInfos(m_nCountColInfos).rMap_Keys_BrowseSet, m_container.Worksheet.Range("GES"))
      ExcludesRowsOnRowMap m_arColInfos(m_nCountColInfos).rMap_Keys_BrowseSet, r.Row, 1
    End If
    nIndexIcGes = m_nCountColInfos
    m_nCountColInfos = m_nCountColInfos + 1
  End If
  If (m_nColIndexAddDetails >= 0 And strNameBrowsesetAddDetails = "AddDetails_UBR" Or m_container.Worksheet.Range("UBR") <> "") And nIndexIcGes >= 0 Then
    i = m_nCountColInfos
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    m_arColInfos(i).Name = "IcUBR"
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K010-K005-UBR")
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim Or EnBrowseFlagsFunctional_CheckBrowseSet Or EnBrowseFlags_BrowseSet
    m_arColInfos(i).Length = 6
    If (m_arColInfos(nIndexIcGes).uml_ex And EnUmlEx_OPTIONAL) <> 0 Then
      m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
    End If
  #If CENTRALBUILD Then
    If m_container.Version <= 9 Then
      If m_nColIndexAddDetails >= 0 Then
        Set m_arColInfos(i).rMap_Keys_BrowseSet = m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet
        m_arColInfos(i).nCount_Keys_BrowseSet = m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet
      Else
        Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.DataRange_Find("UBR", m_arColInfos(i).nCount_Keys_BrowseSet)
      End If
    Else
  #End If
      ReDim m_arColInfos(nIndexIcGes).BrowseDependents(0)
      m_arColInfos(nIndexIcGes).BrowseDependents(0) = i
  #If CENTRALBUILD Then
    End If
  #End If
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).IncludeInListField = True
    m_arColInfos(i).StgType = EnStgType_CellComment
    m_arColInfos(i).Level = NLevel_Max
    m_nCountColInfos = m_nCountColInfos + 1
  End If
  If strTypeName = "ICBEW" Then
    i = m_nCountColInfos
    m_nCountColInfos = m_nCountColInfos + 3
    ReDim Preserve m_arColInfos(m_nCountColInfos - 1)
    m_arColInfos(i).Name = "ZuAbSatz"
    m_arColInfos(i).IncludeInContextMenu = True
    m_arColInfos(i).VarType = vbDouble
    m_arColInfos(i).Digits = 2
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K061-ZU-AB-SATZ")
    m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).StgType = EnStgType_CellComment
    m_arColInfos(i).Level = NLevel_Max
    i = i + 1
    m_arColInfos(i).Name = "ElimKtoNr"
    m_arColInfos(i).IncludeInContextMenu = True
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).Length = 14
    m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K061-K010-KTOM")
    Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.RangeMulti_Find("KTO_BrowseSet", nRows:=m_arColInfos(i).nCount_Keys_BrowseSet)
    m_arColInfos(i).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim Or EnBrowseFlagsFunctional_CheckBrowseSet Or EnBrowseFlags_BrowseSet
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).StgType = EnStgType_CellComment
    m_arColInfos(i).Level = NLevel_Max
    i = i + 1
    m_arColInfos(i).Name = "KstNr"
    m_arColInfos(i).IncludeInContextMenu = True
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim Or EnBrowseFlagsFunctional_CheckBrowseSet Or EnBrowseFlags_BrowseSet
    m_arColInfos(i).Length = 14
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K063-KSTM")
    Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.DataRange_Find("KST", m_arColInfos(i).nCount_Keys_BrowseSet)
    m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).StgType = EnStgType_CellComment
    m_arColInfos(i).Level = NLevel_Max

#If CNTDIM_ENABLED Then
    nIndexKst = i
    onInsertDetailInfoKst nIndexKst
#End If

  End If
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "WertLW"
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K003-WERT-LW")
  m_arColInfos(i).VarType = vbCurrency
  m_arColInfos(i).Digits = 2
  m_arColInfos(i).StgType = EnStgType_Cell
  m_arColInfos(i).Left = NColActValue - 1
  m_arColInfos(i).Top = 0
  m_arColInfos(i).IncludeInListField = True
  m_arColInfos(i).Level = NLevel_Max
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "Difference"
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__SVT.DIFFERENZ")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly
  m_arColInfos(i).VarType = vbCurrency
  m_arColInfos(i).Digits = 2
  m_arColInfos(i).Level = NLevel_Max
  m_arColInfos(i).uml_ex = EnUmlEx_NOTSERIALIZABLE
  m_arColInfos(i).Left = -1
  m_arColInfos(i).Top = -1
  m_arColInfos(i).IncludeInListField = True
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  i = m_nCountColInfos
  m_arColInfos(i).Name = "BuchgsText"
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Length = 35
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K034-BEMERK")
  m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
  m_arColInfos(i).Left = -1
  m_arColInfos(i).Top = -1
  m_arColInfos(i).Level = NLevel_Max
  m_arColInfos(i).StgType = EnStgType_CellComment
  m_arColInfos(i).IncludeInContextMenu = True
  m_nCountColInfos = m_nCountColInfos + 1
  If strTypeName = "ICKTOSAL" Then
    'drei Felder reservieren f|fffd|r WertTW, TWKZ und TW_AUTOINSERT
    i = m_nCountColInfos
    ReDim Preserve m_arColInfos(m_nCountColInfos + 2)

    m_nCountColInfos = m_nCountColInfos + 3


    m_arColInfos(i).Name = "WertTW"
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K039-WERT-TW")
    m_arColInfos(i).uml_ex = m_arColInfos(i).uml_ex Or EnUmlEx_OPTIONAL
    m_arColInfos(i).VarType = vbCurrency
    m_arColInfos(i).Digits = 2
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).Level = NLevel_Max
    m_arColInfos(i).StgType = EnStgType_CellComment
    If m_container.TCEnabled Then
      m_arColInfos(i).IncludeInListField = True
    End If
    i = i + 1
    m_arColInfos(i).Name = "TWKZ"
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K039-K006-WKZ")
    m_arColInfos(i).uml_ex = m_arColInfos(i).uml_ex Or EnUmlEx_OPTIONAL
    Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.DataRange_Find("WKZ_Enabled", m_arColInfos(i).nCount_Keys_BrowseSet)
    If m_arColInfos(i).rMap_Keys_BrowseSet Is Nothing Then
      Set m_arColInfos(i).rMap_Keys_BrowseSet = m_container.DataRange_Find("WKZ", m_arColInfos(i).nCount_Keys_BrowseSet)
    End If
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim Or EnBrowseFlagsFunctional_CheckBrowseSet Or EnBrowseFlags_BrowseSet
    m_arColInfos(i).Length = 3
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).Level = NLevel_Max
    m_arColInfos(i).StgType = EnStgType_CellComment
    If m_container.TCEnabled Then
      m_arColInfos(i).IncludeInListField = True
    End If


    'ww69
    i = i + 1
    'neues Feld AutoInsert f|fffd|r Transaktionsw|fffd|hrung
    m_arColInfos(i).Name = "FIE__TW_AUTOINSERT"
    Set m_arColInfos(i).oType = m_container.DataRange_Find(m_arColInfos(i).Name)
    m_arColInfos(i).VarType = vbBoolean
    m_arColInfos(i).Left = -1
    m_arColInfos(i).Top = -1
    m_arColInfos(i).Level = NLevel_Static
    m_arColInfos(i).StgType = EnStgType_Cell
    m_arColInfos(i).uml_ex = m_arColInfos(i).uml_ex Or EnUmlEx_OPTIONAL
    If m_container.TCEnabled Then
      m_arColInfos(i).IncludeInListField = True
    End If

  End If
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "VWertLW"
  m_arColInfos(i).VarType = vbCurrency
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly
  m_arColInfos(i).Digits = 2
  m_arColInfos(i).StgType = EnStgType_Cell
  m_arColInfos(i).Level = 0
  m_arColInfos(i).Top = 0
  m_arColInfos(i).Left = 5
  m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "BilGuVKnz"
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K010-BIL-GUV-KNZ")
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).Length = 1
  m_arColInfos(i).Level = 0
  m_arColInfos(i).StgType = EnStgType_Cell
  m_arColInfos(i).Top = 0
  m_arColInfos(i).Left = 2
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "KtoKnz1"
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K010-KTO-KNZ")
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
  m_arColInfos(i).Level = 0
  m_arColInfos(i).Length = 1
  m_arColInfos(i).StgType = EnStgType_Cell
  m_arColInfos(i).Top = 0
  m_arColInfos(i).Left = 3
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "KtoKnz2"
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K010-KTO-KNZ2")
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).uml_ex = EnUmlEx_OPTIONAL
  m_arColInfos(i).Level = 0
  m_arColInfos(i).Length = 1
  m_arColInfos(i).StgType = EnStgType_Cell
  m_arColInfos(i).Top = 0
  m_arColInfos(i).Left = 4
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "SHKnz"
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K003-SOLL-HAB-KNZ")
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Level = 1
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).Length = 1
  m_arColInfos(i).StgType = EnStgType_Cell
  If m_nColIndexAddDetails >= 1 Then
    If m_arColInfos(m_nColIndexAddDetails).Name = "BuchSchl" Then
      m_arColInfos(i).StgType = EnStgType_Bound
    End If
  End If
  m_arColInfos(i).Top = 0
  m_arColInfos(i).Left = 7
  If strTypeName = "KTOSAL" Then
#If CENTRALBUILD Then
    If m_container.Version >= 6 Then
#End If
      i = m_nCountColInfos
      ReDim Preserve m_arColInfos(m_nCountColInfos)
      m_nCountColInfos = m_nCountColInfos + 1
      m_arColInfos(i).Name = "DataFlags"
      m_arColInfos(i).VarType = vbLong
      m_arColInfos(i).Level = 1
      m_arColInfos(i).StgType = EnStgType_Bound
      m_arColInfos(i).Top = -1
      m_arColInfos(i).Left = -1
#If CENTRALBUILD Then
    End If
#End If
  End If
PostProcess:
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "KtoPlan"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K013-KTP")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Length = 6
  m_arColInfos(i).Left = 1
  m_arColInfos(i).Top = m_Config.YSizeHeader - 3
  If strTypeName = "KSTSAL" Then
    i = m_nCountColInfos
    ReDim Preserve m_arColInfos(m_nCountColInfos)
    m_nCountColInfos = m_nCountColInfos + 1
    m_arColInfos(i).Name = "KstPlan"
    m_arColInfos(i).Level = NLevel_Static
    m_arColInfos(i).StgType = EnStgType_Cell
    Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K063-K013-KTPM")
    m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    m_arColInfos(i).VarType = vbString
    m_arColInfos(i).Length = 6
    m_arColInfos(i).Left = 1
    m_arColInfos(i).Top = 4
  End If
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "Ges"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K001-GES")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Length = 6
  m_arColInfos(i).Left = 1
  m_arColInfos(i).Top = 1
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "Datenart"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K011-FAC")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Length = 2
  m_arColInfos(i).Left = 6
  m_arColInfos(i).Top = 3
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "Periode"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K002-ABR-MON-JAHR")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly
  m_arColInfos(i).VarType = vbDate
  m_arColInfos(i).Left = 6
  m_arColInfos(i).Top = m_Config.YSizeHeader - 3
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "WKZ"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K006-WKZ")
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).Length = 3
  m_arColInfos(i).Left = 6
  m_arColInfos(i).Top = 2
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "VPeriode"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K065-VGL-MON-JAHR")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly
  m_arColInfos(i).VarType = vbDate
  m_arColInfos(i).Left = 5
  m_arColInfos(i).Top = m_Config.YSizeHeader - 3
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "VDatenart"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("FIE__K065-K011-VFAC")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Length = 2
  m_arColInfos(i).Left = 5
  m_arColInfos(i).Top = 3
  i = m_nCountColInfos
  ReDim Preserve m_arColInfos(m_nCountColInfos)
  m_nCountColInfos = m_nCountColInfos + 1
  m_arColInfos(i).Name = "VWaehrung"
  m_arColInfos(i).Level = NLevel_Static
  m_arColInfos(i).StgType = EnStgType_Cell
  Set m_arColInfos(i).oType = m_container.DataRange_Find("CON__381")
  m_arColInfos(i).BrowseFlags = EnBrowseFlagsReadOnly Or EnBrowseFlags_UCase Or EnBrowseFlags_Trim
  m_arColInfos(i).VarType = vbString
  m_arColInfos(i).Length = 2
  m_arColInfos(i).Left = 5
  m_arColInfos(i).Top = 3
  For i = 0 To m_nCountColInfos - 1
    If i < m_nCountYKeyLevels Or i = m_nColIndexAddDetails Then
      m_arColInfos(i).uml_ex = m_arColInfos(i).uml_ex Or EnUmlEx_KEY
      m_arColInfos(i).StgType = EnStgType_Cell
      m_arColInfos(i).Level = i
      If i = m_nColIndexAddDetails Then
        m_arColInfos(i).Left = 0
      Else
        m_arColInfos(i).Left = NColObjID - 1
      End If
      m_arColInfos(i).Top = 0
    Else
      m_arColInfos(i).uml_ex = m_arColInfos(i).uml_ex And Not EnUmlEx_KEY
    End If
  Next i
  KtoLocatePredfinedColumns
End Sub



#If CNTDIM_ENABLED Then


'Implementation f|fffd|r ReadDetailInfos
'legt Kostenstellendimension inklusive optionaler Kostenstellendimension an (return true)
Private Function onInsertDetailInfoKst(ByVal nIndexKst As Long) As Long
  Dim j As Long
  Dim nCountCDM As Long
  Dim nIndexKto As Long
  Dim rCDM As Range
  Dim rObjID As Range
  Dim strKstPlan As String
  
  
  If nIndexKst < 0 Then
    nIndexKst = m_nCountColInfos
  End If
  
  
  Set rCDM = m_container.DataRange_Find("CDM_Enabled", nCountCDM)
  If rCDM Is Nothing Then
    nCountCDM = 1
  Else
  
    Debug.Assert nCountCDM > 1
    
    
    If nIndexKst = m_nColIndexAddDetails Then
      Debug.Assert m_nColIndexAddDetails = m_nCountYKeyLevels
      
      'Verwandlung der zus|fffd|tzlichen Levels in Y Aufriss
      m_nCountYKeyLevels = nIndexKst + nCountCDM - 1
      m_nColIndexAddDetails = m_nCountYKeyLevels
      
    ElseIf nIndexKst <= m_nCountYKeyLevels Then
      m_nCountYKeyLevels = nIndexKst + nCountCDM - 1
    End If
    
        
    m_Config.MaintainQuickEditField = True 'bei CDM ist Schnellerfassungszeile erforderlich
    

  End If
  
  If nIndexKst + nCountCDM > m_nCountColInfos Then
    ReDim Preserve m_arColInfos(nIndexKst + nCountCDM - 1)
    m_nCountColInfos = nIndexKst + nCountCDM
  End If
  
  If m_arColInfos(nIndexKst).oType Is Nothing Then
    'Default Vorbelegung, falls nicht vorhanden
    m_arColInfos(nIndexKst).Name = "KstNr"
    m_arColInfos(nIndexKst).Length = 14
    m_arColInfos(nIndexKst).VarType = vbString
    m_arColInfos(nIndexKst).uml_ex = EnUmlEx_OPTIONAL
    m_arColInfos(nIndexKst).BrowseFlags = EnBrowseFlags_UCase Or EnBrowseFlags_Trim
    m_arColInfos(nIndexKst).IncludeInListField = True

    If nCountCDM = 1 Then
      Set m_arColInfos(nIndexKst).oType = m_container.DataRange_Find("FIE__K063-KSTM")
      Set m_arColInfos(nIndexKst).rMap_Keys_BrowseSet = m_container.DataRange_Find_WithEnabled("KST", m_arColInfos(nIndexKst).nCount_Keys_BrowseSet)
    End If
    
    j = nIndexKst + nCountCDM - 1
    If j >= m_nCountYKeyLevels And j <> m_nColIndexAddDetails Then
      m_arColInfos(nIndexKst).StgType = EnStgType_CellComment
      m_arColInfos(nIndexKst).Level = NLevel_Max
    Else
      m_arColInfos(nIndexKst).StgType = EnStgType_Cell
      m_arColInfos(nIndexKst).Level = nIndexKst
    End If
    
    m_arColInfos(nIndexKst).Level = nIndexKst
  End If
    
  If nCountCDM > 1 Then
    'zu|fffd|tzliche Kostenstellendimensionen ausgeben
    j = nIndexKst
    For Each rObjID In rCDM
      'Defaultzuweisung
      If j <> nIndexKst Then
        m_arColInfos(j) = m_arColInfos(nIndexKst)
      End If
      
      Set m_arColInfos(j).oType = rObjID
      m_arColInfos(j).Level = j
      
      m_arColInfos(j).Name = "KstNr" & j - nIndexKst
      
      strKstPlan = rObjID.Offset(0, EnDataCols_Knz2) 'Kostenstellenplan
      
      Set m_arColInfos(j).rMap_Keys_BrowseSet = locateKstBrowseset(strKstPlan, m_arColInfos(j).nCount_Keys_BrowseSet)

      j = j + 1
    Next rObjID
  End If
  
  onInsertDetailInfoKst = nIndexKst
  
End Function


'sucht Kostenstellenbrowseset
'R|fffd|ckgabe Nothing, falls Name nicht gefunden
Friend Function locateKstBrowseset(ByVal strKstPlan As String, Optional ByRef nRows As Long) As Range

  If strKstPlan = "" Or strKstPlan = m_container.KstPlan Then
    'Default Browseset
    Set locateKstBrowseset = m_container.DataRange_Find_WithEnabled("KST", nRows)
  End If
  If locateKstBrowseset Is Nothing And strKstPlan <> "" Then
    Set locateKstBrowseset = m_container.DataRange_Find_WithEnabled("KST__" & strKstPlan, nRows)
  End If

End Function

#End If

Private Sub DuplicateRange(ByVal rSrc As Range, ByVal rDest As Range, Optional ByVal UseLockInfo As Boolean, Optional ByVal CopyOnly As Boolean, Optional ByVal WithCellExtent As Boolean)
   Dim r As Range
   Dim rSrcCell As Range
   Dim rDestStart As Range
   Dim strFormula As String
   Dim bCellLocked As Boolean
   Dim nSrcRowStart As Long, nSrcColStart As Long
   Dim nRowDiff As Long, nColDiff As Long
   Dim bStdCopy As Boolean
   Dim vntHasFormula As Variant
   Dim oFontSrc As Excel.Font
   Set rDestStart = rDest.Cells(1, 1)
   Set rSrcCell = rSrc.Cells(1, 1)
   nSrcRowStart = rSrcCell.Row
   nSrcColStart = rSrcCell.Column
   nRowDiff = rDestStart.Row - nSrcRowStart
   nColDiff = rDestStart.Column - nSrcColStart
    bStdCopy = True
    If CopyOnly Then
      vntHasFormula = rSrc.HasFormula
      If IsNull(vntHasFormula) Then
        bStdCopy = False
      Else
        bStdCopy = Not vntHasFormula
      End If
    End If
    If bStdCopy Then
      rSrc.Copy rDestStart
      Set r = rDestStart.Worksheet.Range(rSrc.Address).Offset(nRowDiff, nColDiff)
      r.ClearComments
    Else
      For Each rSrcCell In rSrc
         Set r = rDestStart(rSrcCell.Row - nSrcRowStart + 1, rSrcCell.Column - nSrcColStart + 1)
         If Not rSrcCell.HasFormula Then
           rSrcCell.Copy r
           r.ClearComments
         Else
           r.Value = rSrcCell.Value
           r.Interior.Color = rSrcCell.Interior.Color
           r.NumberFormat = rSrcCell.NumberFormat
           Set oFontSrc = rSrcCell.Font
           With r.Font
              .Color = oFontSrc.Color
              .Size = oFontSrc.Size
              .Name = oFontSrc.Name
              .Bold = oFontSrc.Bold
              .FontStyle = oFontSrc.FontStyle
           End With
         End If
      Next rSrcCell
    End If
    If Not CopyOnly Then
      strFormula = "='" & Replace(rSrc.Worksheet.Name, "'", "''") & "'!R[" & -nRowDiff & "]C[" & -nColDiff & "]"
      For Each rSrcCell In rSrc
        bCellLocked = rSrcCell.Locked
        If rSrcCell.HasFormula Or (Not IsEmpty(rSrcCell.Value) And Not UseLockInfo) Or (UseLockInfo And Not bCellLocked) Then
          Set r = rDestStart(rSrcCell.Row - nSrcRowStart + 1, rSrcCell.Column - nSrcColStart + 1)
          If r.NumberFormat = "@" Then
            r.NumberFormat = "General"
          End If
          r.FormulaR1C1 = strFormula
          If Not bCellLocked Then
            r.Locked = True
          End If
        End If
      Next rSrcCell
    End If
    If WithCellExtent Then
      Set r = rDestStart.Columns
      For Each rSrcCell In rSrc.Columns
        r.ColumnWidth = rSrcCell.ColumnWidth
        Set r = r.Offset(0, 1)
      Next rSrcCell
      Set r = rDestStart.Rows
      For Each rSrcCell In rSrc.Rows
        r.RowHeight = rSrcCell.RowHeight
        Set r = r.Offset(1, 0)
      Next rSrcCell
    End If
End Sub

Public Property Get Worksheet() As Excel.Worksheet
  Set Worksheet = m_worksheet
End Property

Private Property Get UseSHKnzDetails() As Boolean
  Select Case TypeName
    Case "RUEBEW", "ANLBEW", "KAPBEW", "SPIBEW"
      UseSHKnzDetails = True
    Case Else
      UseSHKnzDetails = False
  End Select
End Property

Public Property Get ObjIDVector() As Range
  Dim rObjID As Range
  If Not m_worksheet Is Nothing Then
    If m_nCountColInfos = 0 Then
      ReadDetailInfos
    End If
    If m_nListFieldEndRow > m_Config.YSizeHeader + 1 Then
      Set rObjID = m_worksheet.Cells(m_Config.YSizeHeader + 1, NColObjID)
      Set ObjIDVector = m_worksheet.Range(rObjID, rObjID.Offset(m_nListFieldEndRow - 1 - rObjID.Row, 0))
    End If
  End If
End Property

Public Sub Unprotect()
  m_container.VerifyNotMultiuserEditing
  m_worksheet.Unprotect WorkBook_Password
End Sub

Public Sub Protect()
  m_container.VerifyNotMultiuserEditing
  m_worksheet.Protect Password:=WorkBook_Password, UserInterfaceOnly:=True
  If m_Config.AutoFilterEnabled Then
    m_worksheet.EnableAutoFilter = True
  End If
End Sub

Public Sub ExcludesRowsOnRowMap(ByRef rMap As Range, ByVal nRow As Long, ByVal nCount As Long)
  Dim ws As Worksheet
  Dim rUpper As Range
  Dim rLower As Range
  Dim r As Range
  Dim rFirst As Range
  Dim rLast As Range
  Dim oAreas As Areas
  Dim rInserted As Range
  Dim nCol As Long
  If nCount < 1 Then Exit Sub
  nCol = rMap.Column
  Set ws = rMap.Worksheet
  If nCount = 1 Then
    Set rInserted = ws.Cells(nRow, nCol)
  Else
    Set r = ws.Cells(nRow, nCol)
    Set rInserted = ws.Range(r, r.Offset(nRow + nCount - 1, 0))
  End If
  Set r = Intersect(rMap, rInserted)
  If Not r Is Nothing Then
    Set oAreas = rMap.Areas
    Set rFirst = oAreas(1)(1, 1)
    Set r = oAreas(oAreas.count)
    Set rLast = r(r.count)
    If nRow > 1 Then
      Set r = ws.Cells(1, nCol)
      Set rUpper = ws.Range(r, r.Offset(nRow - 2, 0))
    End If
    If nRow + nCount < 65536 Then
      Set r = ws.Cells(nRow + nCount, nCol)
      Set rLower = ws.Range(r, r.Offset(65536 - r.Row, 0))
    End If
    If rUpper Is Nothing Then
      Set r = rLower
    ElseIf rLower Is Nothing Then
      Set r = rUpper
    Else
      Set r = Union(rUpper, rLower)
    End If
    If Not r Is Nothing Then
      Set rMap = Intersect(rMap, r)
    End If
  End If
End Sub

Private Function RangeMulti_Count(ByVal rVector As Range) As Long
  If Not rVector Is Nothing Then
    RangeMulti_Count = rVector.count
  End If
End Function

Private Function RangeMulti_Item(ByVal rVector As Range, ByVal Index As Long) As Range
  Dim r As Range
  Dim i As Long
  For Each r In rVector
    If i = Index Then
      Set RangeMulti_Item = r
      Exit Function
    End If
    i = i + 1
  Next r
End Function

Public Function LowerBound_RangeRowMulti(ByVal collRange As Range, ByVal KeyRow As Long, ByRef IndexResult As Variant, Optional ByRef IsExactResult As Boolean, Optional ByRef RangeNext As Variant) As Range
  Dim f As Long, M As Long
  Dim n As Long, N2 As Long
  Dim oAreas As Excel.Areas
  Dim r As Range, rTemp As Range
  Dim rNext As Range
  Dim nCount As Long
  Set oAreas = collRange.Areas
  nCount = oAreas.count
  f = 1
  If nCount > 1 Then
    n = nCount
    Do While n > 0
      N2 = n / 2
      M = f + N2
      Set r = oAreas(M)
      If r(r.count).Row < KeyRow Then
        f = M + 1
        n = n - N2 - 1
      Else
        n = N2
      End If
    Loop
  End If
  If f = nCount + 1 Then
    IsExactResult = False
    If Not IsMissing(IndexResult) Then
      IndexResult = collRange.count + 1
    End If
  Else
    Set r = oAreas(f)
    nCount = r.count
    If KeyRow >= r.Row And KeyRow < r.Row + nCount Then
      IsExactResult = True
      Set LowerBound_RangeRowMulti = r.Offset(KeyRow - r.Row, 0)(1, 1)
      n = KeyRow - r.Row + 1
      If Not IsMissing(RangeNext) Then
        If KeyRow + 1 < r.Row + nCount Then
          Set rNext = LowerBound_RangeRowMulti.Offset(1, 0)
        ElseIf f < oAreas.count Then
          Set rNext = oAreas(f + 1)(1, 1)
        Else
          Set rNext = Nothing
        End If
      End If
    ElseIf KeyRow >= r.Row + nCount Then
      n = nCount
      IsExactResult = False
      Set LowerBound_RangeRowMulti = r(nCount, 1)
    Else
      If Not IsMissing(RangeNext) Then
        Set rNext = r(1, 1)
      End If
      If f > 1 Then
        f = f - 1
        Set r = oAreas(f)
        n = r.count
        Set LowerBound_RangeRowMulti = r(n, 1)
      Else
        n = 0
      End If
      IsExactResult = False
    End If
    If Not IsMissing(RangeNext) Then
      Set RangeNext = rNext
    End If
    If Not IsMissing(IndexResult) Then
      If f > 1 Then
        If f = 2 Then
          n = n + oAreas(1).count
        Else
          Set rTemp = oAreas(f - 1)
          Set r = Intersect(r.Worksheet.Range(oAreas(1)(1, 1), rTemp(rTemp.count)), collRange)
          n = n + r.count
        End If
      End If
      IndexResult = n
    End If
  End If
End Function

Public Function LowerBound(ByVal coll As Object, ByRef Key As Variant, ByRef Index As Long, ByVal IndexEnd As Long, Optional ByRef IsExactResult As Boolean) As Object
  Dim vntSearch As Variant
  Dim o As Object
  Dim vt As Long
  Dim vntTemp As Variant
  Dim f As Long, M As Long
  Dim n As Long, N2 As Long
  Const base = 1
  vntSearch = Key
  n = IndexEnd - Index
  f = Index
  Do While n > 0
    N2 = n / 2
    M = f + N2
    Set o = coll(M + base)
    vntTemp = o
    If vntTemp < vntSearch Then
      f = M + 1
      n = n - N2 - 1
    Else
      n = N2
    End If
  Loop
  If f = IndexEnd Then
    IsExactResult = False
  Else
    Set o = coll(f + base)
    vntTemp = o
    IsExactResult = (vntTemp = vntSearch)
    If IsExactResult Then
      Set LowerBound = o
    End If
  End If
  Index = f
End Function

Private Function RLineFromNRow(ByVal nRow As Long) As Range
  Dim nLastUsedCol As Long
  Dim r As Range
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  nLastUsedCol = NColAddDetailsFirst - 1
  If m_nColIndexAddDetails >= 0 Then
    nLastUsedCol = nLastUsedCol + m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet
  End If
  Set r = m_worksheet.Cells(nRow, 1)
  Set RLineFromNRow = m_worksheet.Range(r, r.Offset(0, nLastUsedCol - 1))
End Function

Private Sub MergeMSColMap(ByRef rMap As Range)
  Set rMap = Intersect(rMap, m_worksheet.Columns(rMap.Column))
End Sub

Private Sub m_frmLog_cbOK_Click()
  m_frmLog.Visible = False
  Set m_frmLog_cbOK = Nothing
End Sub

Private Sub m_worksheet_SelectionChange(ByVal Target As Excel.Range)
#If CENTRALBUILD Then
  If m_container.Standalone Then Exit Sub
#End If
  If g_nSystemChangeCounter > 0 Then Exit Sub
  On Error GoTo ErrHandler
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  If m_Config.MaintainQuickEditField Then
    ActivateQuickEditFromCellSelection Target
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  If Err.Number <> ERR_USER_CANCEL Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
End Sub

Private Sub m_worksheet_Change(ByVal Target As Excel.Range)
#If CENTRALBUILD Then
  If m_container.Standalone Then Exit Sub
#End If
  If g_nSystemChangeCounter > 0 Then Exit Sub
  On Error GoTo ErrHandler
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  If m_Config.MaintainQuickEditField Then
    If Valid And m_nListFieldSelectedLevel >= 0 Then
      RefreshKtoDiff bInvalidateDiff:=True
      MoveDataToValueFields
    End If
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  If Err.Number <> ERR_USER_CANCEL Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
End Sub

Private Sub WriteDetailRow(ByVal nLevel As Long, ByVal nRow As Long, ByVal nIndexDetailInfo As Long)
    Dim r As Range
    Dim rData As Range
    Dim rObjIDDetail As Range
    Dim rLine As Range
    Dim strSHKnz As String
    Dim bAddDetailsThisLine As Boolean
    Dim nRowBeginParentBlock As Long
    Dim bEditableRow As Boolean

    Dim strTemp As String
    nRowBeginParentBlock = m_arColInfos(nLevel - 1).nListFieldSelectionBegin
    Set rLine = RLineFromNRow(nRow)
    Set r = rLine.Offset(-1, 0)
    r.Copy rLine
    rLine.ClearContents
    rLine.ClearComments


        On Error Resume Next
    r.Borders(xlEdgeBottom).LineStyle = xlLineStyleNone
        On Error GoTo 0

    rLine.Font.Bold = False
    rLine.Interior.Color = NColor_UnLockedField
    rLine.Font.Color = vbBlack
    Set r = rLine(1, NColBene)
    Set rObjIDDetail = RangeMulti_Item(m_arColInfos(nLevel).rMap_Keys_BrowseSet, nIndexDetailInfo)
    Set rData = rObjIDDetail.Offset(0, EnDataCols_Language + 1)
    r.HorizontalAlignment = xlHAlignLeft
    If nLevel > 1 Then
      r.IndentLevel = nLevel - 1
    Else
      r.IndentLevel = 0
    End If
    m_container.CreateIDLLocTextRangeDirect r, rData
    Set r = r.Offset(0, NColObjID - r.Column)
    r.NumberFormat = "@"
    r.Value = rObjIDDetail.Value
    r.HorizontalAlignment = xlHAlignRight
    If m_nCountYKeyLevels > 2 Then
      r.HorizontalAlignment = xlHAlignLeft
      r.IndentLevel = nLevel
    Else
      r.HorizontalAlignment = xlHAlignRight
    End If
    r.Font.Color = r.Offset(0, -1).Font.Color
    If nRow < 65536 Then
      If r.Offset(1, 0).Value = "" Then

                On Error Resume Next
        With rLine.Borders(xlEdgeBottom)
          .LineStyle = xlContinuous
          .Weight = xlThin
        End With
                On Error GoTo 0

      End If
    End If
    Set r = r.Offset(0, NColBilGuVKnz - r.Column)
    r.Value = r.Offset(-1, 0).Value
    Set r = r.Offset(0, 1)
    r.Value = r.Offset(-1, 0).Value
    Set r = r.Offset(0, 1)
    r.Value = r.Offset(-1, 0).Value
    If UseSHKnzDetails Then
      strSHKnz = rObjIDDetail.Offset(0, EnDataCols_SHKnz).Value

      If strSHKnz <> "S" And strSHKnz <> "H" Then
        strSHKnz = "" 'Hack: besserer Typisierung stattdessen verwenden
      End If

    End If
    If strSHKnz = "" Then
      Set rData = r.Offset(nRowBeginParentBlock - r.Row, NColSHKnz - r.Column)
      strSHKnz = rData.Offset(0, NColSHKnz - rData.Column).Value
    End If
    Set r = r.Offset(0, NColSHKnz - r.Column)
    r.Value = strSHKnz


    bEditableRow = (nLevel = m_nCountYKeyLevels - 1) 'nur innerster Level editierbar
    
    
    'Optionale Elemente ber|fffd|cksichtigen
    If Not bEditableRow And nLevel < m_nCountYKeyLevels - 1 Then
      If TColInfo_IsOptional(m_arColInfos(nLevel + 1)) Then
        bEditableRow = m_container.DetailSheet_IsAddDetail(Me, r.Offset(0, NColObjID - r.Column))
      End If
    End If


    Set r = r.Offset(0, NColActValue - r.Column)
    If m_nColIndexAddDetails >= 0 Then
      If TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails)) Then
        bAddDetailsThisLine = m_container.DetailSheet_IsAddDetail(Me, r.Offset(nRowBeginParentBlock - nRow, 0))
      Else
        bAddDetailsThisLine = True
      End If
      Set rData = r.Offset(0, NColAddDetailsFirst - r.Column)
      Set rData = m_worksheet.Range(rData, rData.Offset(0, m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet - 1))
      If bEditableRow Then
        rData.Locked = Not bAddDetailsThisLine
        r.Locked = bAddDetailsThisLine
      Else
        rData.Locked = True
        r.Locked = True
        r.Interior.Color = NColor_LockedInputField
      End If
      If TColInfo_IsOptional(m_arColInfos(nLevel)) Then
        'Annahme keine Summenformel bei Zusatzaufriss, wenn optionaler Level (aufgetreten bei ICGes Level)
      ElseIf bAddDetailsThisLine And bEditableRow Then

        If m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet > 0 Then
          strTemp = "RC" & NColAddDetailsFirst & ":RC" & NColAddDetailsFirst + m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet - 1
        Else
          strTemp = ""
        End If
        r.FormulaR1C1 = "=" & IIf(m_bAddDetails_Toplevel, "IDLLastValue(", "IDLSumCY(") & strTemp & ")"
        r.Interior.Color = NColor_LockedInputField
        
        If m_ClassName = "ICKTOSAL" Then
          r.Locked = False 'Test !!!! f|fffd|r ORGA
        End If

        Set r = m_container.DataRange_Find("StyleLocalCurrency")
        rData.NumberFormat = r.NumberFormat
      Else
        rData.Interior.Color = NColor_LockedInputField
      End If
    Else
      r.Locked = Not bEditableRow
    End If

End Sub

Public Function Check_BewSpiegelSpalte(ByVal strDetailClassName As String, ByVal strKtoKnz1 As String, ByVal strSpiegelSpalte As String) As Boolean
  Dim NColKtoKnz1 As Long
  Dim strCol As String
  Dim r As Range
  Dim rColKtoKnz1 As Range, rColValue As Range
  Dim sum() As Currency, sumDetail() As Currency, diff As Currency
  Dim nBilGuV As Long
  Dim nCount As Long
  Dim nRowFirst As Long
  Dim oDetailEditor As CRangeGrid
  Dim oLog As Object
  Dim bSubLogOpened As Boolean
  Dim bOK As Boolean
  Dim rObjIDCheck As Range
  Dim strBeneCheck As String
  Dim vntValue As Variant
  Dim bSollPlus As Boolean
  Dim bSoll As Boolean
  Dim oIterator As CRangeNode
  Dim nMemberBuchSchl As Long
  Dim nMemberSHKnz As Long
  Dim nMemberWertLW As Long
  Dim oBrowseSet_BSL As Range
  Dim nDiffCount As Long
  Dim i As Long
  Dim nColTopLevelStart As Long
  Const SEVERITY_WARNING = &H80000000
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  On Error Resume Next
  Set oLog = m_container.CallContext.Log
  On Error GoTo ErrHandler
  bSollPlus = (strDetailClassName = "ANLBEW")
  Set rObjIDCheck = m_container.DataRange_Find("Check__" & strDetailClassName & "__" & strKtoKnz1, nCount)
  If nCount <> 1 Then
    Check_BewSpiegelSpalte = True
    Exit Function
  End If
  strBeneCheck = SearchTextByRObjID(rObjIDCheck)
  nDiffCount = UBound(m_Diff) + 1
  If m_bAddDetails_Toplevel Then
    nColTopLevelStart = m_arColIndicesPredef(NColAddDetailsFirst)
  Else
    nColTopLevelStart = m_arColIndicesPredef(NColActValue)
  End If
  ReDim sum(nDiffCount - 1)
  ReDim sumDetail(nDiffCount - 1)
  NColKtoKnz1 = NColBilGuVKnz + 1
  Set rColKtoKnz1 = m_worksheet.Columns(NColKtoKnz1)
  bOK = True
  If WorksheetFunction.CountIf(rColKtoKnz1, strKtoKnz1) > 0 Then
    For nBilGuV = 1 To 4
      Set r = Nothing
      On Error Resume Next
      Set r = m_worksheet.Range("KTO_BILGUV_" & nBilGuV)
      On Error GoTo 0
      If Not r Is Nothing Then
        Set rColKtoKnz1 = IDL_MSColMap_Offset(r, NColKtoKnz1 - r.Column)
        Set r = rColKtoKnz1.Find(strKtoKnz1, LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByRows)
        If Not r Is Nothing Then
          nRowFirst = r.Row
          Do
            For i = 0 To UBound(sum)
              m_container.ConvertValueFromCell r.Offset(0, i + nColTopLevelStart - r.Column), vntValue
              If bSollPlus = (r.Offset(0, NColSHKnz - NColKtoKnz1) = "H") Then
                sum(i) = sum(i) - vntValue
              Else
                sum(i) = sum(i) + vntValue
              End If
            Next i
            Set r = rColKtoKnz1.FindNext(r)
            If r Is Nothing Then
              Exit Do
            ElseIf r.Row = nRowFirst Then
              Exit Do
            End If
          Loop
        End If
      End If
    Next nBilGuV

    For Each oDetailEditor In m_container.DetailSheets
      If StrComp(oDetailEditor.TypeName, strDetailClassName, vbTextCompare) = 0 Then
        If oDetailEditor.Valid Then

#If CNTDIM_ENABLED Then
          Set oIterator = oDetailEditor.CreateIterator(LevelEnd:=2)
#Else
          Set oIterator = oDetailEditor.CreateIterator()
#End If

          nMemberBuchSchl = oIterator.PropertiesNameToIndex("BuchSchl")
          nMemberSHKnz = oIterator.PropertiesNameToIndex("SHKnz")
          nMemberWertLW = oIterator.PropertiesNameToIndex("WertLW")
          Set oBrowseSet_BSL = oDetailEditor.PropertiesBrowseset(Nothing, nMemberBuchSchl)
          Do While Not oIterator.EOF
            bSoll = (oIterator.Default(nMemberSHKnz) = "S")
            Set r = IDLVLookup(oBrowseSet_BSL, oIterator.Default(nMemberBuchSchl), EnDataCols_Knz2 + 1 - EnDataCols_ObjID)
            If Not r Is Nothing Then
              If r.Value = strKtoKnz1 Then
              For i = 0 To nDiffCount - 1
                Set r = oIterator.TopLeft
                If m_bAddDetails_Toplevel Or nDiffCount > 1 Then
                  Set r = r.Offset(0, i + nColTopLevelStart - r.Column)
                  m_container.ConvertValueFromCell r, vntValue
                Else
                  vntValue = oIterator.Default(nMemberWertLW)
                End If
                If bSoll = bSollPlus Then
                  sumDetail(i) = sumDetail(i) - vntValue
                Else
                  sumDetail(i) = sumDetail(i) + vntValue
                End If
              Next i
              End If
            End If
            oIterator.MoveNext
          Loop
        End If
      End If
    Next oDetailEditor

    For i = 0 To UBound(sum)
      diff = sum(i) - sumDetail(i)
      If diff = 0 Then
        If Not oLog Is Nothing Then
         oLog.LogRecords__Add__AssignProperties text:=FormatStr(SearchTextInSPR(335), strBeneCheck), Scode:=335
        End If
      Else
        bOK = False
        If Not oLog Is Nothing Then
           oLog.LogRecords__Add__AssignProperties text:=FormatStr(SearchTextInSPR(337), strBeneCheck, Format$(diff, "##,##0.00")), Scode:=SEVERITY_WARNING Or 337
        End If
      End If
    Next i
  End If
  Check_BewSpiegelSpalte = bOK
  Exit Function
ErrHandler:
  Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Sub RefreshKtoDiff(Optional ByVal nLevelChange As Long = -1, Optional ByVal bInvalidateDiff As Boolean, Optional ByVal bValueChange As Boolean)
  Dim rKto As Range
  Dim r As Range
  Dim bProtect As Boolean
  Dim nError As Long, strSource As String, strError As String
  Dim nDiffCount As Long, nIndexDiff As Long, nIndexDiffActive As Long
  Dim nIndexDiffStart As Long, nIndexDiffEnd As Long
  Dim nRowKto As Long
  Dim rTopActive As Range
  Dim rTop As Range
  Dim rObjidVector_all As Range
  Dim i As Long
  Dim bTemp As Boolean, bDifference As Boolean
  Dim vntTemp As Variant
  Dim diffActValue As Currency, diffTemp As Currency
  Dim rObjIDActive As Range
  Dim nForeColorNeutral As Long, nBackColorNeutral As Long
  On Error GoTo ErrHandler
  nIndexDiffActive = -1
  nDiffCount = UBound(m_Diff) + 1
  If bInvalidateDiff Then
    For i = 0 To nDiffCount - 1
      m_Diff(i) = Empty
      m_DiffLevel0(i) = Empty
    Next i
    m_DiffActValue = 0
  End If
  If m_nListFieldSelectedLevel >= 0 Then
    If m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin >= 0 Then
      Set rObjIDActive = TopLeftSelected
      If Not m_bAddDetails_Toplevel Then
        If m_arColIndicesPredef(NColObjID) > 0 Then
          Set rObjIDActive = rObjIDActive.Offset(0, m_arColIndicesPredef(NColObjID) - rObjIDActive.Column)
        End If
      End If
      Set rTopActive = rObjIDActive.Offset(m_arColInfos(0).nListFieldSelectionBegin - rObjIDActive.Row, 0)
      If m_bAddDetails_Toplevel Then
        nIndexDiffActive = rTopActive.Column - m_arColIndicesPredef(NColAddDetailsFirst)
      Else
        nIndexDiffActive = 0
      End If
    End If
  End If
  If nLevelChange = 0 Then
    For i = 0 To nDiffCount - 1
      m_DiffLevel0(i) = Empty
    Next i
    nIndexDiffStart = 0
    nIndexDiffEnd = nDiffCount
  ElseIf nIndexDiffActive >= 0 And nLevelChange >= 0 Then
    nIndexDiffStart = nIndexDiffActive
    nIndexDiffEnd = nIndexDiffStart + 1
    m_DiffLevel0(nIndexDiffActive) = Empty
  ElseIf bValueChange And nIndexDiffActive >= 0 Then
    nIndexDiffStart = nIndexDiffActive
    nIndexDiffEnd = nIndexDiffStart + 1
  Else
    nIndexDiffStart = 0
    nIndexDiffEnd = nDiffCount
  End If
  For nIndexDiff = nIndexDiffStart To nIndexDiffEnd - 1
    Set rTop = Nothing
    If Not rTopActive Is Nothing Then
      If m_bAddDetails_Toplevel Then
        i = m_arColIndicesPredef(NColAddDetailsFirst) + nIndexDiff
        Set rTop = rTopActive.Offset(0, i - rTopActive.Column)
      Else
        Set rTop = rTopActive
      End If
    End If
    If bValueChange And nIndexDiff = nIndexDiffActive Then
      Set r = rObjIDActive
      diffActValue = CalcDiff(r)
      If IsEmpty(m_DiffActValue) Then
        m_DiffLevel0(nIndexDiff) = Empty
        m_Diff(nIndexDiff) = Empty
      Else
        diffTemp = diffActValue - m_DiffActValue
        m_Diff(nIndexDiff) = m_Diff(nIndexDiff) + diffTemp
        If m_nListFieldSelectedLevel = m_nCountYKeyLevels - 1 Then
          m_DiffLevel0(nIndexDiff) = m_DiffLevel0(nIndexDiff) + diffTemp
        End If
      End If
      m_DiffActValue = diffActValue
    Else
      m_DiffActValue = Empty
    End If
    If IsEmpty(m_Diff(nIndexDiff)) Then
      If rObjidVector_all Is Nothing Then
        Set rObjidVector_all = ObjIDVector
      End If
      If m_bAddDetails_Toplevel Then
        i = m_arColIndicesPredef(NColAddDetailsFirst) + nIndexDiff
        Set r = rObjidVector_all.Offset(0, i - rObjidVector_all.Column)
      Else
        Set r = rObjidVector_all
      End If
      If r Is Nothing Then
        m_Diff(nIndexDiff) = 0
      Else
        m_Diff(nIndexDiff) = CalcDiff(r)
      End If
    End If
    If IsEmpty(m_DiffLevel0(nIndexDiff)) Then
      If rTop Is Nothing Then
        m_DiffLevel0(nIndexDiff) = 0
      Else
        Set r = rTop.Resize(m_arColInfos(0).nListFieldSelectionEnd - m_arColInfos(0).nListFieldSelectionBegin, 1)
        m_DiffLevel0(nIndexDiff) = CalcDiff(r)
      End If
    End If
    If Not rTop Is Nothing Then
      If nForeColorNeutral = 0 And nBackColorNeutral = 0 Then
        Set r = rTop.Offset(0, m_arColIndicesPredef(NColKtoKnz1) - rTop.Column)
        nForeColorNeutral = r.Font.Color
        nBackColorNeutral = r.Interior.Color
      End If
      bTemp = (rTop.Font.Color <> nForeColorNeutral Or rTop.Interior.Color <> nBackColorNeutral)
      bDifference = (m_DiffLevel0(nIndexDiff) <> 0)
      If bTemp <> bDifference Then
        If m_worksheet.ProtectContents Then
          Unprotect
          bProtect = True
        End If
        If bDifference Then
          rTop.Interior.Color = vbRed
          rTop.Font.Color = vbWhite
        Else
          rTop.Interior.Color = nBackColorNeutral
          rTop.Font.Color = nForeColorNeutral
        End If
      End If
      If m_bAddDetails_Toplevel Then
        Set r = rTop.Offset(2 - rTop.Row, 0)
      Else
        Set r = rTop.Offset(2 - rTop.Row, m_arColIndicesPredef(NColActValue) - rTop.Column)
      End If
      vntTemp = r.Value
      bTemp = (VarType(vntTemp) <> vbDouble)
      If Not bTemp Then
        bTemp = (vntTemp <> m_Diff(nIndexDiff))
      End If
      If bTemp Then
        If m_worksheet.ProtectContents Then
          Unprotect
          bProtect = True
        End If
        r.Value = m_Diff(nIndexDiff)
      End If
    End If
    If nIndexDiff = nIndexDiffActive And Not m_lblValueDifference Is Nothing Then
      m_lblValueDifference.Caption = TColInfo_VntToText(m_arColInfos(PropertiesNameToIndex("Difference")), m_DiffLevel0(nIndexDiff))
    End If
  Next nIndexDiff
Cleanup:
  If bProtect Then
    Protect
  End If
  If nError <> 0 Then Err.Raise nError, strSource, strError
  Exit Sub
ErrHandler:
  nError = Err.Number
  strSource = Err.Source
  strError = Err.Description
  GoTo Cleanup
End Sub

Private Sub OnCmbValueChange(ByVal nCol As Long)
  Dim strThis As String
  Dim r As Range
  Dim bProtect As Boolean
  Dim nError As Long, strError As String, strSource As String
  Dim bScreenUpdating_prev As Boolean
  Dim i As Long
  Dim nSelectedRow As Long
  Dim nLevel As Long
  Dim nDetailInfo As Long
  Dim cmb As MSForms.ComboBox
  If g_nSystemChangeCounter > 0 Then Exit Sub
  On Error GoTo ErrHandler
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  bScreenUpdating_prev = Application.ScreenUpdating
  Application.ScreenUpdating = False
  Set cmb = m_arColInfos(nCol).cmb
  strThis = Trim$(cmb.text)
  If m_nListFieldSelectedLevel >= 0 Then
    nSelectedRow = m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin
    If m_bListFieldSelectedInsert And strThis <> "" And m_arColInfos(nCol).Level <> NLevel_Static Then
      For nLevel = 1 To m_nListFieldSelectedLevel
        nSelectedRow = m_arColInfos(nLevel).nListFieldSelectionBegin
        nDetailInfo = m_arColInfos(nLevel).cmb.ListIndex
        If TColInfo_IsOptional(m_arColInfos(nLevel)) Then
          nDetailInfo = nDetailInfo - 1
        End If
        If nDetailInfo >= 0 And nLevel < m_nListFieldSelectedLevel Then
          If m_arColInfos(nLevel).nListFieldSelectionBegin < m_arColInfos(nLevel).nListFieldSelectionEnd Then
            nDetailInfo = -1
          End If
        End If
        If nDetailInfo >= 0 Then
          Set r = m_worksheet.Rows(nSelectedRow)
          If m_worksheet.ProtectContents Then
            Unprotect
            bProtect = True
          End If
          r.Insert xlShiftDown
          m_nListFieldEndRow = m_nListFieldEndRow + 1
          For i = nLevel + 1 To m_nListFieldSelectedLevel
            m_arColInfos(i).nListFieldSelectionBegin = m_arColInfos(i).nListFieldSelectionBegin + 1
          Next i
          For i = 0 To m_nListFieldSelectedLevel
            m_arColInfos(i).nListFieldSelectionEnd = m_arColInfos(i).nListFieldSelectionEnd + 1
          Next i
          m_bListFieldSelectedInsert = False
          ExcludesRowsOnRowMap m_arColInfos(0).rMap_Keys_BrowseSet, nSelectedRow, 1
          WriteDetailRow nLevel, nSelectedRow, nDetailInfo
        End If
      Next nLevel
      RefreshKtoDiff nLevelChange:=nLevel
    End If
    If Not bProtect Then
      If m_worksheet.ProtectContents Then
         Unprotect
         bProtect = True
       End If
    End If
    On Error GoTo Cleanup
    MoveDataFromValueFields nCol
    UpdateBrowseDependents nCol
    On Error GoTo ErrHandler
    RefreshKtoDiff bValueChange:=True


    If m_ClassName = "ICKTOSAL" Then
      'speziell W|fffd|hrungskennzeichen automatisch vorbelegen
      If m_container.TCEnabled Then
        If Default("FIE__TW_AUTOINSERT") Then
          i = PropertiesNameToIndex("TWKZ")
          If i <> nCol Then
            If Default(i) = "" Then
              Default(i) = Default("WKZ")
              MoveDataToValueFields i
            End If
          End If
        End If
      End If
    End If

  End If
Cleanup:
  If bProtect Then
    Protect
  End If
  Application.ScreenUpdating = bScreenUpdating_prev
  If nError <> 0 And nError <> ERR_USER_CANCEL Then
    ShowErrDialog nError, strError, strSource
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  GoTo Cleanup
End Sub

Private Sub ActivateQuickEditFromCellSelection(ByVal rTarget As Excel.Range)
  Dim vntIndex As Long
  Dim rFound As Range, rNext As Range
  Dim r As Range
  Dim rObjID As Range
  Dim bIsExactResult As Boolean
  Dim nIndex As Long
  Dim bKtoChanged As Boolean
  Dim bFound As Boolean
  Dim bSumValue As Boolean
  Dim nLevel As Long
  Dim xPos As Long, yPos As Long
  If Not m_Config.MaintainQuickEditField Then Exit Sub
  If m_cmb0 Is Nothing Then Exit Sub
  xPos = rTarget.Column
  yPos = rTarget.Row
  m_nListFieldSelectedLevel = -1
  If Not m_arColInfos(0).rMap_Keys_BrowseSet Is Nothing And m_arColInfos(0).nCount_Keys_BrowseSet > 0 Then
    If yPos <= m_Config.YSizeHeader Then
      yPos = m_Config.YSizeHeader + 1
    ElseIf yPos >= m_nListFieldEndRow Then
      yPos = m_nListFieldEndRow - 1
    End If
    Set rFound = LowerBound_RangeRowMulti(m_arColInfos(0).rMap_Keys_BrowseSet, yPos, vntIndex, bIsExactResult, RangeNext:=rNext)
    If rFound Is Nothing Then
      bFound = (yPos > m_Config.YSizeHeader And yPos < m_nListFieldEndRow)
      If bFound Then
        nIndex = vntIndex - 1
        If nIndex >= m_arColInfos(0).rMap_Keys_BrowseSet.count Then
          nIndex = m_arColInfos(0).rMap_Keys_BrowseSet.count - 1
        End If
        Set rFound = RangeMulti_Item(m_arColInfos(0).rMap_Keys_BrowseSet, nIndex)
      End If
    Else
      bFound = rFound.Row < m_nListFieldEndRow
      nIndex = vntIndex - 1
    End If
    If bFound Then
      If nIndex <> m_cmb0.ListIndex Then
        m_cmb0.ListIndex = nIndex
        bKtoChanged = True
        UpdateBrowseDependents 0
      End If
      m_arColInfos(0).nListFieldSelectionBegin = rFound.Row
      m_nListFieldSelectedLevel = 0
      If rNext Is Nothing Then
        m_arColInfos(0).nListFieldSelectionEnd = m_nListFieldEndRow
      Else
        m_arColInfos(0).nListFieldSelectionEnd = rNext.Row
      End If
      For m_nListFieldSelectedLevel = 0 To m_nCountYKeyLevels - 1
        If bIsExactResult And m_nListFieldSelectedLevel > 0 Then

          bFound = TColInfo_IsOptional(m_arColInfos(m_nListFieldSelectedLevel))
          
          If bFound Then
            'spezialfall: leere Auswahl: dann gilt Level als exakt angenommen
            m_bListFieldSelectedInsert = False
            m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin = m_arColInfos(m_nListFieldSelectedLevel - 1).nListFieldSelectionBegin
            m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionEnd = m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin
            UpdateBrowseDependents m_nListFieldSelectedLevel
            
            If m_nListFieldSelectedLevel = m_nCountYKeyLevels - 1 Then
              GoTo InnerDataLevelFound
            End If
            
          Else
            'vorheriger Level (meist Konto) genau gew|fffd|hlt
            m_bListFieldSelectedInsert = True
            
            'Konten-Eintrag bereits festgelegt, jedoch aktuelle Combo-Auswahl f|fffd|r Aufriss-Elemente abgleichen
            'Hack f|fffd|r Office97  Fokus nicht auf aktives Control setzen, nach Behelfs-Aktivierung von Zelle
            ActivateQuickEditFromIndex nLevel:=m_nListFieldSelectedLevel 'Level0 bereits aktuell
            Exit For
          End If

        Else
          If m_nListFieldSelectedLevel = m_nCountYKeyLevels - 1 Then
            m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin = yPos
            m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionEnd = m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin + 1

'Einsprungspunkt: innerster Level gefunden, im Falle optionaler Level
InnerDataLevelFound:

            m_bListFieldSelectedInsert = False
            Set rObjID = rFound.Offset(m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin - rFound.Row, 0)
            If rObjID.Value <> "" Then
              On Error Resume Next
              m_arColInfos(m_nListFieldSelectedLevel).cmb.Value = rObjID.Value
              If Err <> 0 Then
                m_arColInfos(m_nListFieldSelectedLevel).cmb.ListIndex = -1
              End If
              On Error GoTo 0
              UpdateBrowseDependents m_nListFieldSelectedLevel
              If m_nColIndexAddDetails < 0 Then
                bSumValue = True
              Else
                bSumValue = False
                Set r = rObjID.Offset(0, xPos - rObjID.Column)
                If Not r.Locked Then
                  If r.Column >= NColAddDetailsFirst And r.Column < NColAddDetailsFirst + m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet Then
                    nIndex = xPos - NColAddDetailsFirst
                    If TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails)) Then nIndex = nIndex + 1
                    m_arColInfos(m_nColIndexAddDetails).cmb.ListIndex = nIndex
                    UpdateBrowseDependents m_nColIndexAddDetails
                  ElseIf r.Column = NColActValue And TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails)) Then
                    m_arColInfos(m_nColIndexAddDetails).cmb.ListIndex = 0
                    bSumValue = True
                    UpdateBrowseDependents m_nColIndexAddDetails
                  End If
                End If
              End If
              If bSumValue Then
                Set r = rObjID.Offset(0, NColActValue - rObjID.Column)
              End If
            End If
          ElseIf m_nListFieldSelectedLevel > 0 Then
            nIndex = m_arColInfos(m_nListFieldSelectedLevel - 1).nListFieldSelectionBegin + 1
            Set rObjID = m_worksheet.Cells(nIndex, NColObjID)
            bFound = False
            bIsExactResult = False
            Set rFound = Nothing
            Do While nIndex < m_arColInfos(m_nListFieldSelectedLevel - 1).nListFieldSelectionEnd
              If rObjID.HorizontalAlignment <> xlHAlignLeft Then
                If m_Config.Level0_AllignRight Then
                  nLevel = 0
                Else
                  nLevel = m_nCountYKeyLevels - 1
                End If
              Else
                nLevel = rObjID.IndentLevel
                If m_Config.Level0_AllignRight Then nLevel = nLevel + 1
              End If
              If nLevel < m_nListFieldSelectedLevel Then
                Exit Do
              ElseIf nLevel = m_nListFieldSelectedLevel Then
                If bFound Then
                  Exit Do
                Else
                  Set rFound = rObjID
                  If nIndex = yPos Then
                    bIsExactResult = True
                    bFound = True
                  End If
                End If
              ElseIf Not bFound And nIndex >= yPos And Not rFound Is Nothing Then
                bFound = True
              End If
              UpdateBrowseDependents nLevel
              Set rObjID = rObjID.Offset(1, 0)
              nIndex = nIndex + 1
            Loop
            If bFound Then
              m_arColInfos(m_nListFieldSelectedLevel).cmb.Value = rFound.Value
              m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin = rFound.Row
              m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionEnd = nIndex
              UpdateBrowseDependents m_nListFieldSelectedLevel
            Else
              m_nListFieldSelectedLevel = m_nListFieldSelectedLevel - 1
              ActivateQuickEditFromIndex m_nListFieldSelectedLevel + 1
              Exit For
            End If
          End If
        End If
      Next m_nListFieldSelectedLevel
      If m_nListFieldSelectedLevel >= m_nCountYKeyLevels Then
        m_nListFieldSelectedLevel = m_nCountYKeyLevels - 1
      End If
    End If
  End If
  ProcessAfterSelectionChange IIf(bKtoChanged, 0, 1)
End Sub

Private Sub ProcessAfterSelectionChange(Optional ByVal nLevelChange As Long)
  MoveDataToValueFields
  RefreshKtoDiff nLevelChange
#If CENTRALBUILD = 0 Then
  CheckSelectionStatusDecentral_Impl
#End If
End Sub

Public Function Begin() As Object
  Dim oRangeNode As New CRangeNode
  Dim rObjID As Range
#If CENTRALBUILD Then
  If m_container.Standalone Then
    Set Begin = This_Decentral.Begin
    Exit Function
  End If
#End If
  Set rObjID = ObjIDVector
  If Not rObjID Is Nothing Then
    Set rObjID = rObjID(1, 1)
  End If
  MoveNextImpl 0, NLevel_Max, rObjID, bInitFirst:=True
  oRangeNode.Init Me, Nothing, rObjID, 0, NLevel_Max, bEnableIteration:=True
  Set Begin = oRangeNode
End Function

Public Function CreateIterator(Optional ByVal LevelEnd As Integer = NLevel_Max) As Object
  Dim oRangeNode As New CRangeNode
  Dim rObjID As Range
  Set rObjID = ObjIDVector
  If Not rObjID Is Nothing Then
    Set rObjID = rObjID(1, 1)
  End If
  MoveNextImpl 0, LevelEnd, rObjID, bInitFirst:=True
  oRangeNode.Init Me, Nothing, rObjID, 0, LevelEnd, bEnableIteration:=True
  Set CreateIterator = oRangeNode
End Function

Public Function CreateCollection(Optional ByVal LevelEnd As Integer = NLevel_Max, Optional RangeLocked As Variant, Optional RangeEmpty As Variant) As Object
  Dim oRangeNode As New CRangeNode
  Dim rObjID As Range
#If CENTRALBUILD Then
  If m_container.Standalone Then
    Set CreateCollection = This_Decentral.CreateCollection(LevelEnd, RangeLocked, RangeEmpty)
    Exit Function
  End If
#End If
  Set rObjID = ObjIDVector
  If Not rObjID Is Nothing Then
    Set rObjID = rObjID(1, 1)
  End If
  MoveNextImpl 0, LevelEnd, rObjID, bInitFirst:=True
  oRangeNode.Init Me, Nothing, rObjID, 0, LevelEnd, bEnableIteration:=False
  Set CreateCollection = oRangeNode
End Function

Public Property Get Area() As Range
  Set Area = m_worksheet.Cells
End Property

Public Property Get TopLeft() As Range
  If Not m_worksheet Is Nothing Then
    Set TopLeft = m_worksheet.Cells(1, 1)
  End If
End Property

Private Property Get TopLeftSelected() As Range
  Dim r As Range
  Dim nSelectedRow As Long
  Dim i As Long
  If m_nListFieldSelectedLevel < 0 Then
    Set r = m_worksheet.Cells(1, 1)
  Else
    nSelectedRow = m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin
    If m_nColIndexAddDetails < 0 Then
      Set r = m_worksheet.Cells(nSelectedRow, 1)
    ElseIf m_nColIndexAddDetails >= 0 Then
      If m_arColInfos(m_nColIndexAddDetails).cmb Is Nothing Then
        i = 0
      Else
        i = m_arColInfos(m_nColIndexAddDetails).cmb.ListIndex
      End If
      If i >= 0 Then
        If TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails)) Then
          If i = 0 Then
            Set r = m_worksheet.Cells(nSelectedRow, 1)
          Else
            Set r = m_worksheet.Cells(nSelectedRow, NColAddDetailsFirst + i - 1)
          End If
        Else
          Set r = m_worksheet.Cells(nSelectedRow, NColAddDetailsFirst + i)
        End If
      End If
    End If
  End If
  Set TopLeftSelected = r
End Property

Private Sub MoveDataToValueFields(Optional ByVal nCol As Long = -1)
  Dim vntTemp As Variant
  Dim r As Range
  Dim nColAct As Long
  Dim cmb As MSForms.ComboBox
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  On Error GoTo ErrHandler
  If Not m_bListFieldSelectedInsert Then
    Set r = TopLeftSelected
  End If
  If Not r Is Nothing Then
    Set r = HitTestRange(nXLevel:=NLevel_Max, nYLevel:=NLevel_Max, Selection:=r)
  End If
  If nCol >= 0 Then
    nColAct = nCol
    GoTo EnterNoLoop
  End If
  For nColAct = IIf(m_nColIndexAddDetails >= 0, m_nColIndexAddDetails + 1, m_nCountYKeyLevels) To m_nCountColInfos - 1
EnterNoLoop:
    Set cmb = m_arColInfos(nColAct).cmb
    If m_arColInfos(nColAct).IncludeInListField And Not cmb Is Nothing Then
      If r Is Nothing And m_arColInfos(nColAct).Level <> NLevel_Static Then
        vntTemp = Empty
      Else
        vntTemp = Empty
        InvokeRange VbGet Or CallTypeEx_ReturnError, nColAct, vntTemp, r
      End If
      If VarType(vntTemp) = vbString Then
        If Trim(vntTemp) = "" Then
          vntTemp = Empty
        End If
      End If
      If cmb.style = fmStyleDropDownCombo And m_arColInfos(nColAct).rMap_Keys_BrowseSet Is Nothing Then
        cmb.Value = TColInfo_VntToText(m_arColInfos(nColAct), vntTemp, CallTypeEx_ReturnError)
      ElseIf cmb.ListCount = 0 Then
        cmb.ListIndex = -1
      ElseIf (m_arColInfos(nColAct).uml_ex And EnUmlEx_OPTIONAL) <> 0 And IsEmpty(vntTemp) Then
        cmb.ListIndex = 0
      Else
        On Error Resume Next
        cmb.Value = vntTemp
        On Error GoTo ErrHandler
      End If
      UpdateBrowseDependents nColAct
    End If
    If nCol >= 0 Then
      GoTo ExitNoLoop
    End If
  Next nColAct
ExitNoLoop:
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Private Sub MoveDataFromValueFields(Optional ByVal nCol As Long = -1)
  Dim vntTemp As Variant
  Dim r As Range
  Dim nColAct As Long
  Dim cmb As MSForms.ComboBox
  Set r = TopLeftSelected
  If Not r Is Nothing Then
    Set r = HitTestRange(nXLevel:=NLevel_Max, nYLevel:=NLevel_Max, Selection:=r)
  End If
  If Not r Is Nothing Then
    If nCol >= 0 Then
      nColAct = nCol
      GoTo EnterNoLoop
    End If
    For nColAct = IIf(m_nColIndexAddDetails >= 0, m_nColIndexAddDetails + 1, m_nCountYKeyLevels) To m_nCountColInfos - 1
EnterNoLoop:
      Set cmb = m_arColInfos(nColAct).cmb
      If m_arColInfos(nColAct).IncludeInListField And Not cmb Is Nothing Then
        vntTemp = cmb.Value
        InvokeRange VbLet, nColAct, vntTemp, r
      End If
      If nCol >= 0 Then
        GoTo ExitNoLoop
      End If
    Next nColAct
ExitNoLoop:
  End If
End Sub

Private Sub UpdateBrowseDependents(ByVal nLevel As Long)
  Dim i As Long
  Dim nIndexDependent As Long
  Dim oBrowseset_act As Range
  Dim cmb As MSForms.ComboBox
  On Error GoTo ErrHandler
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  If Not Array_IsNothing(ArrayPtr(m_arColInfos(nLevel).BrowseDependents)) Then
    For i = 0 To UBound(m_arColInfos(nLevel).BrowseDependents)
      nIndexDependent = m_arColInfos(nLevel).BrowseDependents(i)
      Set oBrowseset_act = PropertiesBrowseset(Nothing, nIndexDependent)
      Set cmb = m_arColInfos(nIndexDependent).cmb
      If Not cmb Is Nothing Then
        If cmb.style <> fmStyleDropDownList Then
          cmb.style = fmStyleDropDownList
        End If
        If Not m_container.IsEqualRange(oBrowseset_act, m_arColInfos(nIndexDependent).rMap_Keys_BrowseSet) Then
          Set m_arColInfos(nIndexDependent).rMap_Keys_BrowseSet = oBrowseset_act
          m_arColInfos(nIndexDependent).nCount_Keys_BrowseSet = RangeMulti_Count(oBrowseset_act)
          m_container.FillCombo cmb, m_arColInfos(nIndexDependent).rMap_Keys_BrowseSet, IncludeEmptyItem:=TColInfo_IsOptional(m_arColInfos(nIndexDependent))
          If cmb.ListIndex < 0 And cmb.style = fmStyleDropDownList Then
            m_arColInfos(nIndexDependent).cmb.Value = Empty
          End If
        End If
      End If
    Next i
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Private Function FillFromCmbIndex(ByVal nLevel As Long) As Boolean
  Dim i As Long, j As Long
  Dim nRow As Long
  Dim nFoundLevel As Long
  Dim rObjID As Range
  Dim vntObjIDSearch As Variant
  Dim bExact As Boolean
  Dim bSearchEnd As Boolean
  UpdateBrowseDependents nLevel
  i = m_arColInfos(nLevel).cmb.ListIndex
  If TColInfo_IsOptional(m_arColInfos(nLevel)) Then
    i = i - 1
  End If
  If i >= 0 Then
    vntObjIDSearch = RangeMulti_Item(m_arColInfos(nLevel).rMap_Keys_BrowseSet, i)
  Else
    Exit Function
  End If
  If m_arColInfos(nLevel - 1).nListFieldSelectionBegin < 0 Then
    m_arColInfos(nLevel - 1).nListFieldSelectionBegin = m_Config.YSizeHeader + 1
  End If
  m_arColInfos(nLevel).nListFieldSelectionBegin = -1
  m_arColInfos(nLevel).nListFieldSelectionEnd = m_arColInfos(nLevel - 1).nListFieldSelectionEnd
  Set rObjID = m_worksheet.Cells(m_arColInfos(nLevel - 1).nListFieldSelectionBegin + 1, NColObjID)
  If m_arColInfos(nLevel - 1).nListFieldSelectionBegin = m_arColInfos(nLevel - 1).nListFieldSelectionEnd Then
    nRow = m_arColInfos(nLevel - 1).nListFieldSelectionBegin
  Else
    For nRow = m_arColInfos(nLevel - 1).nListFieldSelectionBegin + 1 To m_arColInfos(nLevel - 1).nListFieldSelectionEnd - 1
      If rObjID.HorizontalAlignment <> xlHAlignLeft Then
        If m_Config.Level0_AllignRight Then
          nFoundLevel = 0
        Else
          nFoundLevel = m_nCountYKeyLevels - 1
        End If
      Else
        nFoundLevel = rObjID.IndentLevel
        If m_Config.Level0_AllignRight Then nFoundLevel = nFoundLevel + 1
      End If
      If bSearchEnd Then
        If nFoundLevel <= nLevel Then
          Exit For
        End If
      ElseIf nFoundLevel = nLevel Then
        If m_arColInfos(nLevel).nListFieldSelectionBegin < 0 Then
          m_arColInfos(nLevel).nListFieldSelectionBegin = nRow
        End If
        If vntObjIDSearch < rObjID.Value Then
          m_bListFieldSelectedInsert = True
          m_nListFieldSelectedLevel = nLevel
          m_arColInfos(nLevel).nListFieldSelectionBegin = nRow
          m_arColInfos(nLevel).nListFieldSelectionEnd = nRow
          For i = nLevel + 1 To m_nCountYKeyLevels - 1
            j = m_arColInfos(i).cmb.ListIndex
            If TColInfo_IsOptional(m_arColInfos(i)) Then j = j - 1
            If j < 0 Then Exit For
            m_nListFieldSelectedLevel = i
            m_arColInfos(i).nListFieldSelectionBegin = nRow
            m_arColInfos(i).nListFieldSelectionEnd = nRow
          Next i
          Exit For
        ElseIf vntObjIDSearch = rObjID.Value Then
          bSearchEnd = True
          bExact = True
          m_bListFieldSelectedInsert = False
          m_nListFieldSelectedLevel = nLevel
          m_arColInfos(nLevel).nListFieldSelectionBegin = nRow
        End If
      End If
      Set rObjID = rObjID.Offset(1, 0)
    Next nRow
  End If
  If bSearchEnd Then
    m_arColInfos(nLevel).nListFieldSelectionEnd = nRow
    If m_arColInfos(nLevel).nListFieldSelectionEnd - m_arColInfos(nLevel).nListFieldSelectionBegin > 0 Then
      If nLevel + 1 < m_nCountYKeyLevels Then
        FillFromCmbIndex nLevel + 1
        bExact = Not m_bListFieldSelectedInsert
      End If
    End If
  ElseIf m_arColInfos(nLevel).nListFieldSelectionBegin < 0 Or Not bExact Then
    For i = nLevel To m_nCountYKeyLevels - 1
      j = m_arColInfos(i).cmb.ListIndex
      If TColInfo_IsOptional(m_arColInfos(i)) Then j = j - 1
      If j < 0 Then Exit For
      bExact = False
      m_bListFieldSelectedInsert = True
      m_nListFieldSelectedLevel = i
      m_arColInfos(i).nListFieldSelectionBegin = nRow
      m_arColInfos(i).nListFieldSelectionEnd = nRow
    Next i
  End If
  FillFromCmbIndex = bExact
End Function

Private Sub ActivateQuickEditFromIndex(Optional ByVal nLevel As Long, Optional ByVal bSelectCell As Boolean, Optional ByVal bShowCell As Boolean)
  Dim r As Range, rNext As Range
  Dim rKto As Range
  Dim nIndex As Long
  Dim nCountDetails As Long
  Dim rToShow As Range
  nIndex = m_cmb0.ListIndex
  If nIndex < 0 Then Exit Sub
  If nLevel > 0 And m_nListFieldSelectedLevel >= 0 Then
    Set rKto = m_worksheet.Cells(m_arColInfos(0).nListFieldSelectionBegin, NColObjID)
    nCountDetails = m_arColInfos(0).nListFieldSelectionEnd - m_arColInfos(0).nListFieldSelectionBegin - 1
  Else
    Set rKto = RangeMulti_Item(m_arColInfos(0).rMap_Keys_BrowseSet, nIndex)
    m_arColInfos(0).nListFieldSelectionBegin = rKto.Row
    If nIndex + 1 < m_arColInfos(0).rMap_Keys_BrowseSet.count Then
      Set rNext = RangeMulti_Item(m_arColInfos(0).rMap_Keys_BrowseSet, nIndex + 1)
      nCountDetails = rNext.Row - m_arColInfos(0).nListFieldSelectionBegin - 1
    Else
      nCountDetails = m_nListFieldEndRow - m_arColInfos(0).nListFieldSelectionBegin - 1
    End If
    m_arColInfos(0).nListFieldSelectionEnd = m_arColInfos(0).nListFieldSelectionBegin + nCountDetails + 1
  End If
  UpdateBrowseDependents 0
  If m_nCountYKeyLevels >= 2 Then
    FillFromCmbIndex IIf(nLevel = 0, 1, nLevel)
  End If
  If bSelectCell Or bShowCell Then
    Set rToShow = TopLeftSelected
    If Not rToShow Is Nothing Then
      If bSelectCell Then
        rToShow.Select
      End If
      If Not IsOffice97 And bShowCell Then
        If m_ListFieldOleObject Is Nothing Then
          rToShow.Show
        Else
          rToShow.EntireRow.Show
        End If
      End If
    End If
  End If
  ProcessAfterSelectionChange nLevel
End Sub

Private Sub OnCmbClick(ByVal cmb As MSForms.ComboBox)
  Dim nCol As Long
  For nCol = 0 To m_nCountColInfos - 1
    If cmb Is m_arColInfos(nCol).cmb Then
      If nCol = m_nColIndexAddDetails Then
        OnCmbKeyClick nLevel:=m_nCountYKeyLevels - 1
        Exit For
      ElseIf nCol < m_nCountYKeyLevels Then
        OnCmbKeyClick nCol
        Exit For
      Else
        OnCmbValueChange nCol
        Exit For
      End If
    End If
  Next nCol
  Application.Cursor = xlDefault
End Sub

Private Sub OnCmbKeyClick(ByVal nLevel As Long)
  If g_nSystemChangeCounter > 0 Then Exit Sub
  On Error GoTo ErrHandler
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  ActivateQuickEditFromIndex nLevel, bShowCell:=True
Cleanup:
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  If Err.Number <> ERR_USER_CANCEL Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  GoTo Cleanup
End Sub

Private Sub m_cmb9_Change()
  OnCmbClick m_cmb9
End Sub

Private Sub m_cmb9_Click()
  OnCmbClick m_cmb9
End Sub

Private Sub m_cmb8_Change()
  OnCmbClick m_cmb8
End Sub

Private Sub m_cmb8_Click()
  OnCmbClick m_cmb8
End Sub

Private Sub m_cmb7_Change()
  OnCmbClick m_cmb7
End Sub

Private Sub m_cmb7_Click()
  OnCmbClick m_cmb7
End Sub

Private Sub m_cmb6_Change()
  OnCmbClick m_cmb6
End Sub

Private Sub m_cmb6_Click()
  OnCmbClick m_cmb6
End Sub

Private Sub m_cmb5_Change()
  OnCmbClick m_cmb5
End Sub

Private Sub m_cmb5_Click()
  OnCmbClick m_cmb5
End Sub

Private Sub m_cmb4_Change()
  OnCmbClick m_cmb4
End Sub

Private Sub m_cmb4_Click()
  OnCmbClick m_cmb4
End Sub

Private Sub m_cmb3_Change()
  OnCmbClick m_cmb3
End Sub

Private Sub m_cmb3_Click()
  OnCmbClick m_cmb3
End Sub

Private Sub m_cmb2_Change()
  OnCmbClick m_cmb2
End Sub

Private Sub m_cmb2_Click()
  OnCmbClick m_cmb2
End Sub

Private Sub m_cmb1_Change()
  OnCmbClick m_cmb1
End Sub

Private Sub m_cmb1_Click()
  OnCmbClick m_cmb1
End Sub

Private Sub m_cmb0_Change()
  OnCmbClick m_cmb0
End Sub

Private Sub m_cmb0_Click()
  OnCmbClick m_cmb0
End Sub

Private Sub Class_Initialize()
  TConfig_Initialize m_Config
#If CENTRALBUILD Then
  m_dispid_InvokeBound = DISPID_UNKNOWN
#End If
End Sub

Private Function CalcDiff_BSL_Right(ByVal rObjID As Range, ByVal bSollPlus As Boolean, ByVal bHaben_KTO As Boolean) As Currency
  Dim r As Range
  Dim i As Long
  Dim rData As Range
  Dim bHaben As Boolean
  Dim strTemp As String
  Dim vntValue As Variant
  Dim diff As Currency
  If Not m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet Is Nothing Then
    Set r = rObjID.Offset(0, NColAddDetailsFirst - rObjID.Column)
    For Each rData In m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet
      m_container.ConvertValueFromCell r, vntValue
      If Not IsEmpty(vntValue) Then
        strTemp = rData.Offset(0, EnDataCols_SHKnz - EnDataCols_ObjID).Value
        If strTemp = "" Then
          bHaben = bHaben_KTO
        Else
          bHaben = (strTemp = "H")
        End If
      End If
      If bSollPlus = bHaben Then
        diff = diff + vntValue
      Else
        diff = diff - vntValue
      End If
      Set r = r.Offset(0, 1)
    Next rData
  End If
  CalcDiff_BSL_Right = diff
End Function

Private Function CalcDiff(ByVal rObjIDVector As Range) As Currency
  Dim rObjID As Range, r As Range
  Dim rData As Range
  Dim bSollPlus As Boolean
  Dim bDiffVperiode As Boolean
  Dim diff As Currency
  Dim bHaben As Boolean
  Dim bKapBew As Boolean, bICKTOSAL As Boolean
  Dim vntTemp As Variant, vntValue As Variant
  Dim nActLevel As Long
  Dim nIndex As Long
  Dim nActColObjID As Long
  Dim strTypeName As String
  Dim bEnableDiffVPeriode As Boolean 'true, falls DiffVPeriode m|fffd|glich (abh|fffd|ngig von Datensatz)
  
  Const nLevel As Long = 0 'aktueller Level (Kto)
  
  
  If rObjIDVector Is Nothing Then Exit Function
  
  
  strTypeName = TypeName
  If strTypeName = "ICBEW" Then
    'keine Differenz auf Vorperiode bei Ic-Bewegungen
  ElseIf InStr(1, strTypeName, "BEW") > 0 Then
    bKapBew = (strTypeName = "KAPBEW")
    bSollPlus = (strTypeName = "ANLBEW")
    If strTypeName = "SPIBEW" Then
      bEnableDiffVPeriode = m_bSPIBEW_DiffVPeriode
    Else
      bEnableDiffVPeriode = True
    End If
  ElseIf strTypeName = "ICKTOSAL" Then
    bICKTOSAL = True
  End If
  
  For Each rObjID In rObjIDVector
    nActColObjID = rObjID.Column
    

    
    
    
    
    If bICKTOSAL Then
      'KtoKnz1 lesen
      nIndex = m_arColIndicesPredef(NColKtoKnz1)
      If nIndex > 0 Then
        vntTemp = rObjID.Offset(0, nIndex - nActColObjID).Value
      Else
        InvokeRange VbGet, m_arElementIndicesPredef(NColKtoKnz1), vntTemp, rObjID, bNoHitTest:=True
      End If
      If vntTemp = "J" Then
        'Kontokennzeichen1 = J nicht in Differenz ber|fffd|cksichtigen
        GoTo NextLine
      End If
    End If
    
    'Level von aktuellem rObjID bestimmen
    nIndex = m_arColIndicesPredef(NColObjID)
    If nIndex > 0 Then
      'Standardfall (schnell): ObjID als konstante Spalte verf|fffd|gbar (impliziert Level durch Einr|fffd|ckung)
      If nActColObjID = nIndex Then
        Set r = rObjID
      Else
        Set r = rObjID.Offset(0, nIndex - nActColObjID)
      End If
            
      If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
        nActLevel = m_nCountYKeyLevels - 1
      Else
        nActLevel = r.IndentLevel
      End If
      
    Else
      'langsamer: Level |fffd|ber HitTest bestimmen
      '!!!! implementieren
      'InvokeRange VbGet, m_arElementIndicesPredef(NColSHKnz), vntTemp, rObjID, bNoHitTest:=True
    End If



    
    If nActLevel = nLevel Or nActLevel = m_nCountYKeyLevels - 1 Then 'Level 0 / Konto
      'nActLevel = nLevel: Konto gefunden
      'ansonsten Unteraufriss
      
      'SHKnz lesen
      nIndex = m_arColIndicesPredef(NColSHKnz)
      If nIndex > 0 Then
        vntTemp = rObjID.Offset(0, nIndex - nActColObjID).Value
      Else
        InvokeRange VbGet, m_arElementIndicesPredef(NColSHKnz), vntTemp, rObjID, bNoHitTest:=True
      End If
      
      bHaben = (vntTemp = "H")
      
      'aktuellen Wert lesen
      nIndex = m_arColIndicesPredef(NColActValue)
      If nIndex > 0 Then
        If m_nColIndexAddDetails >= 0 Then
          If nActColObjID >= m_arColIndicesPredef(NColAddDetailsFirst) Then
            nIndex = nActColObjID
          End If
        End If
        Set r = rObjID.Offset(0, nIndex - nActColObjID)
        vntValue = r.Value
        If VarType(vntValue) = vbString Then
          m_container.ConvertValueFromCell r, vntValue
        End If
      Else
        InvokeRange VbGet, m_arElementIndicesPredef(NColActValue), vntValue, rObjID, bNoHitTest:=True
      End If
      
      If nActLevel = nLevel Then
        'Konto

        'ermitteln, ob Diff Vor Periode
        bDiffVperiode = False 'Default
        If bEnableDiffVPeriode Then
          bDiffVperiode = True 'Default
          If bKapBew Then
            'Kompatibilit|fffd|tshack
            'bei KAPBEW zus|fffd|tzlich
            'bDiffVPeriode TRUE, falls KontoKnz2 = "K" (Standard Modus / siehe altes CalcDiff)
            'bDiffVPeriode FALSE, falls KontoKnz2 = "L", Differenzbildung ohne Vorperiode
        
            'KtoKnz2 lesen
            nIndex = m_arColIndicesPredef(NColKtoKnz2)
            If nIndex > 0 Then
              vntTemp = rObjID.Offset(0, nIndex - nActColObjID).Value
            Else
              InvokeRange VbGet, m_arElementIndicesPredef(NColKtoKnz2), vntTemp, rObjID, bNoHitTest:=True
            End If
            Debug.Assert vntTemp <> ""
            
            If vntTemp = "L" Then
              bDiffVperiode = False
            End If
          End If
          'neue Spiegel: Lesen aus Flag VortragUMB pro Konto
          Set rData = m_container.EvalRefCell(rObjID)
          If Not rData Is Nothing Then
            Set rData = rData.Offset(0, EnDataCols_Flags - EnDataCols_ObjID)
            If ((rData.Value And EnDataFlags_NoDiffVPeriode) <> 0) Then
              bDiffVperiode = False
            End If
          End If
        End If

      
        If bDiffVperiode Then
          'Vorperiodenwert in vntTemp zwischenspeichern
          nIndex = m_arColIndicesPredef(NColPrevValue)
          If nIndex > 0 Then
            Set r = rObjID.Offset(0, nIndex - nActColObjID)
            m_container.ConvertValueFromCell r, vntTemp
          Else
            InvokeRange VbGet, m_arElementIndicesPredef(NColPrevValue), vntTemp, rObjID, bNoHitTest:=True
          End If
        End If
        
        If bSollPlus = bHaben Then
          diff = diff - vntValue
          If bDiffVperiode Then
            diff = diff + vntTemp 'Bewegung: Vorperioden-Wert von Differenz abziehen
          End If
        Else
          diff = diff + vntValue
          If bDiffVperiode Then
            diff = diff - vntTemp 'Bewegung: Vorperioden-Wert von Differenz abziehen
          End If
        End If
        
      Else
        'Unteraufriss
        If bSollPlus = bHaben Then
          diff = diff + vntValue
        Else
          diff = diff - vntValue
        End If
      End If

      'Standard-Aufriss nach rechts
      If m_nColIndexAddDetails = 1 Or m_nColIndexAddDetails > 1 And TColInfo_IsOptional(m_arColInfos(1)) Then
        Debug.Assert InStr(1, m_ClassName, "BEW") > 0 'nur Bewegung
        diff = diff + CalcDiff_BSL_Right(rObjID, bSollPlus, bHaben)
      End If


    End If
    
NextLine:
  Next rObjID
  
  CalcDiff = diff

  Exit Function
  Resume 'f|fffd|r Info Stack/Log
End Function


Public Sub ShowICTWArray_Patch()
  Dim oColl As Collection
  Dim vntResult As Variant
  Dim i As Long
  Dim rDest As Range
  Dim r As Range
  Dim rObjIDVector As Range
  Dim bProtect As Boolean
  Dim nError As Long, strError As String, strSource As String
  Dim vntNames As Variant
  On Error GoTo ErrHandler
  Set rObjIDVector = ObjIDVector
  If Worksheet.ProtectContents Then
    Unprotect
    bProtect = True
  End If
  With [I:J]
    .Clear
    .Font.Size = [F3].Font.Size
  End With
  If Not rObjIDVector Is Nothing Then
    Set rObjIDVector = HitTestRange(NLevel_Max, NLevel_Max, rObjIDVector)
  End If
  If Not rObjIDVector Is Nothing Then
    vntNames = Array("WertTW", "TWKZ")
    vntResult = Array(Empty, Empty)
    For Each r In rObjIDVector
      InvokeRange VbGet Or CallTypeEx_IgnoreError, vntNames, vntResult, r
      Set rDest = r.Offset(0, 7)
      rDest.NumberFormat = "#,##0.00"
      rDest = vntResult(0)
      rDest.Offset(0, 1) = vntResult(1)
    Next r
    m_worksheet.Range("I:J").EntireColumn.AutoFit
  End If
Cleanup:
  If bProtect Then
    Protect
    bProtect = False
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
End Sub

Public Sub AdjustDetails__Decentral()
    Dim nKto As Long
    Dim nKtoNew As Long
    Dim nLocalKtoNew As Long
    Dim rMapObjIDs As Range
    Dim nLocalKto_PrevSelected As Long
    Dim i As Long
    Dim j As Long
    Dim nCompare As Long
    Dim nRowAct As Long, nRowKtoAct As Long
    Dim r As Range, rData As Range, rTemp As Range
    Dim rKtoSaldenAct As Range
    Dim rKtoLine As Range
    Dim bUseSHKnz As Boolean
    Dim bIncludeEmptyAmount As Boolean
    Dim vntActValue As Variant, vntPrevValue As Variant
    Dim strKtoNr As String
    Dim strError As String, nError As Long
    Dim wb As Workbook
    Dim nRowHeight As Long
    Dim oCallContext_Common_Prev As Object
    Dim nCalculation_Prev As Long
    Dim bNextKto As Boolean, bNextKtoNew As Boolean
    Dim nCountGes As Long
    Dim oStatusBar As Object
    Dim bProgressOpened As Boolean
    Dim oLog As Object
    Dim bSubLogOpened As Boolean
    Dim bSubLogTextInserted As Boolean
    Dim bProtectWorkbook As Boolean
    Dim bScreenUpdating_prev As Boolean
    Dim nLastUsedCol As Long
    Dim bKtoSetChanged As Boolean
    Dim rKtoSalden As Range
    Dim diff_AddDetails As Currency
    Dim wsActive As Worksheet
    Dim bTemp As Boolean
    Dim nCountKtoAll As Long
    Dim nActLevel As Long
    Dim nKtoFlags As Long
    Dim strDetailKnz As String
    
    Dim strTypeName As String
    
    Dim oIterator_AddDetailsSrc As CRangeNode 'Iterator |fffd|ber Quellzeilen f|fffd|r Zusatzaufriss
    Dim oIteratorSrc As CRangeNode
    Dim strFormula As String
        Dim strSPIReduced As String 'reiner Spiegel (ohne Spiegelbereich)


    Set oCallContext_Common_Prev = Common.CallContext
    On Error Resume Next
    Set oStatusBar = CallContext.StatusBar
    Set oLog = CallContext.Log
    On Error GoTo ErrHandler
    bScreenUpdating_prev = Application.ScreenUpdating
    If bScreenUpdating_prev Then Application.ScreenUpdating = False
    nCalculation_Prev = Application.Calculation
    g_nSystemChangeCounter = g_nSystemChangeCounter + 1
    bTemp = Valid
    If IsOffice97 Then
      If Valid Then
        If m_worksheet.Visible Then
          If Not ActiveSheet Is m_worksheet Then
            m_worksheet.Activate
          End If
          Set wsActive = m_worksheet
        End If
      End If
      If wsActive Is Nothing Then
        Set wsActive = ActiveSheet
      End If
      If Not wsActive Is Nothing Then
        wsActive.Cells(1, 1).Select
      End If
    End If
    Set wb = m_container.Parent
    If wb.ProtectStructure Then
      m_container.VerifyNotMultiuserEditing
      wb.Unprotect WorkBook_Password
      bProtectWorkbook = True
    End If
    If nCalculation_Prev = xlCalculationManual Then
      Application.Calculation = xlCalculationAutomatic
    End If
    Application.Calculation = xlCalculationManual
    If m_worksheet Is Nothing Then
      CreateDetailSheet
      AttachToQuickEditField
      If IsOffice97 Then
        Set r = m_worksheet.Cells(1, 1)
        r.Select
      End If
      nLocalKto_PrevSelected = -1
    ElseIf Not m_cmb0 Is Nothing Then
      nLocalKto_PrevSelected = m_cmb0.ListIndex
    End If
    If m_worksheet.ProtectContents Then
      Unprotect
    End If
    bUseSHKnz = UseSHKnzDetails
    If bUseSHKnz Then
      bIncludeEmptyAmount = True
    End If
    If m_nCountColInfos = 0 Then
      ReadDetailInfos
    End If
    nLastUsedCol = NColAddDetailsFirst - 1
    If m_nColIndexAddDetails > 1 Then
      nLastUsedCol = nLastUsedCol + m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet


      'ww62
      'Beginn
      'Iterator |fffd|ber Quellinformationen des Zusatzaufrisses suchen
      If Not Me Is m_container.Grid Then
        Dim oDetailEditor As CRangeGrid
        'testweise hie erstmal Spezialfall f|fffd|r UKV
      
        Set oDetailEditor = m_container.DetailSheets_Find("KSTSAL")
        If Not oDetailEditor Is Nothing And m_ClassName = "ICKTOSAL" And m_arColInfos(m_nColIndexAddDetails).Name = "KstNr" Then
          If oDetailEditor.Valid Then
            Set oIterator_AddDetailsSrc = oDetailEditor.CreateIterator(LevelEnd:=1)
          End If
        End If

        'Hack: Auff|fffd|llen des Header Bereichs
        'TODO: via Deklaration
        If Not oIterator_AddDetailsSrc Is Nothing Then
          Set r = m_worksheet.Cells(1, NColAddDetailsFirst)
          Set rTemp = r.Resize(4, 1)
          r.AutoFill rTemp
          
          Set r = rTemp.Resize(ColumnSize:=m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet)
          rTemp.AutoFill r
        End If

      End If
      'ww62
      'End



    End If
    If Not oLog Is Nothing Then
      oLog.LogRecords__Add__AssignProperties text:=SearchTextInSPR(318), Scode:=318
      oLog.OpenSubLog
      bSubLogOpened = True
    End If
    nRowAct = m_Config.YSizeHeader + 1
    If m_nListFieldEndRow < nRowAct Then m_nListFieldEndRow = nRowAct
    m_container.DataRange_Find "KTO", nCountKtoAll
    If nCountKtoAll > 0 And Not oStatusBar Is Nothing Then
      oStatusBar.OpenProgress nCountKtoAll
      oStatusBar.StatusText = SearchTextInSPR(318)
      bProgressOpened = True
    End If
    
    strTypeName = TypeName
        strSPIReduced = m_container.SPIFromSBE(spi)
     
    m_nListFieldSelectedLevel = 0
    bNextKto = True
    bNextKtoNew = True
    nLocalKtoNew = -1
    Do
        If bProgressOpened Then
          oStatusBar.ProgressPosition = nKtoNew
        End If
        If bNextKto Then
          Set r = m_worksheet.Cells(nRowAct, NColObjID)
          Set r = m_container.EvalRefCell(r)
          If r Is Nothing Then
            nKto = nCountKtoAll
            bNextKto = False
          Else
            nKto = r.Row - m_rListFieldStart.Row
          End If
        End If
        If nKtoNew >= nCountKtoAll Then
          If Not bNextKto Then Exit Do
        ElseIf bNextKtoNew Then
          Set rData = m_rListFieldStart.Offset(nKtoNew, EnDataCols_BilGUVKnz)
          Set r = rData.Offset(0, EnDataCols_Flags - EnDataCols_BilGUVKnz)
          If IsNumeric(r.Value) Then
            nKtoFlags = CLng(r.Value)
          Else
            nKtoFlags = 0
          End If
          Set r = m_container.EvalRefCell(rData)
          Set rKtoSaldenAct = r
          If (strTypeName = "ICKTOSAL" Or strTypeName = "ICBEW") Then
            Set r = r.Offset(0, 1)
            bTemp = ((nKtoFlags And EnDataFlags_KtoKnz1_DetailDisabled) = 0)
          ElseIf strTypeName = "KSTSAL" Then
            bTemp = ((nKtoFlags And EnDataFlags_Kst_DetailDisabled) = 0)
          Else
            Set r = r.Offset(0, 2)
            bTemp = ((nKtoFlags And EnDataFlags_KtoKnz2_DetailDisabled) = 0)
          End If
          If bTemp Then
            strDetailKnz = r.Value
            Select Case strTypeName
              Case "KSTSAL"
                bTemp = m_container.DetailSheet_IsAddDetail(Me, r)
              Case "ICKTOSAL"
                bTemp = ((strDetailKnz = "I") Or (strDetailKnz = "J"))
              Case "ICBEW"
                bTemp = (strDetailKnz = "V")
                
              Case "SPIBEW", "ANLBEW", "RUEBEW"
                bTemp = (strDetailKnz = strSPIReduced)
              Case "KAPBEW"
                bTemp = (strDetailKnz = strSPIReduced)
                If Not bTemp Then
                  bTemp = (strDetailKnz = "L" And strSPIReduced = "K") 'Hack: Pseudo L Konto
                End If
            End Select
          End If
          If Not bTemp Then GoTo ContinueFor
          If r.EntireRow.Hidden Then GoTo ContinueFor
          Set r = r.Offset(0, NColActValue - r.Column)
          m_container.ConvertValueFromCell r, vntActValue
          Set r = r.Offset(0, NColPrevValue - r.Column)
          m_container.ConvertValueFromCell r, vntPrevValue
          If Not bIncludeEmptyAmount Then
            If IsEmpty(vntActValue) Then GoTo ContinueFor
          End If
          Set rKtoSalden = r
          nLocalKtoNew = nLocalKtoNew + 1
        End If
        Set rData = m_rListFieldStart.Offset(nKtoNew, EnDataCols_ObjID)
        strKtoNr = rData.Value
        nCompare = (nKtoNew - nKto)
        Select Case nCompare
            Case Is < 0
                If Not bKtoSetChanged Then
                  bKtoSetChanged = True
                End If
                If nLocalKto_PrevSelected >= nLocalKtoNew Then
                  nLocalKto_PrevSelected = nLocalKto_PrevSelected + 1
                End If
                nRowHeight = rKtoSaldenAct.RowHeight
                nRowKtoAct = nRowAct
                If nRowAct < m_nListFieldEndRow Then
                  Set r = m_worksheet.Rows(nRowAct)
                  r.Insert Shift:=xlDown
                End If
                m_nListFieldEndRow = m_nListFieldEndRow + 1
                Set rData = rKtoSaldenAct.Worksheet.Range(rKtoSaldenAct.Offset(0, 1 - rKtoSaldenAct.Column), rKtoSaldenAct.Offset(0, nLastUsedCol - rKtoSaldenAct.Column))
                Set r = m_worksheet.Cells(nRowKtoAct, 1)
                Set rKtoLine = m_worksheet.Range(r, r.Offset(0, nLastUsedCol - 1))
                rKtoLine.RowHeight = nRowHeight
                DuplicateRange rData, r, CopyOnly:=True


                                'zur Vereinfachung Blocktrenner anpassen
                Set rTemp = r.Resize(1, rData.Columns.count)

                                On Error Resume Next
                With rTemp.Borders(xlInsideVertical)
                                        .LineStyle = xlContinuous
                                        .Weight = xlThin
                                End With
                                On Error GoTo ErrHandler

                '|fffd|berpr|fffd|fen, ob spezieller Vortragsbereich
                Set rTemp = m_container.detectCarryForwardRange(rKtoSaldenAct.Offset(ColumnOffset:=NColObjID - rKtoSaldenAct.Column))
                If Not rTemp Is Nothing Then
                  'spezieller Bereich: Einsetzen von Vortragsformel auf Vorperiode
                  
                  strFormula = m_container.createFormulaCarryForward(rKtoSaldenAct.Offset(ColumnOffset:=NColActValue - rKtoSaldenAct.Column), rTemp.Offset(ColumnOffset:=NColPrevValue - rTemp.Column), rFormulaContext:=r.Offset(ColumnOffset:=NColPrevValue - r.Column))
                  strFormula = "=" & strFormula
                  Set rTemp = r.Offset(ColumnOffset:=NColPrevValue - r.Column)
                  rTemp.FormulaR1C1 = strFormula
                End If


                If m_nColIndexAddDetails >= 0 Then
                  rKtoLine.FormatConditions.Delete
                End If
                rKtoLine.Interior.Color = NColor_LockedField
                rKtoLine.Font.Bold = True
                rKtoLine.Locked = True


                Set rData = m_rListFieldStart.Offset(nKtoNew, EnDataCols_ObjID)
                Set r = r.Offset(0, NColBene - r.Column)
                m_container.CreateIDLLocTextRangeDirect r, rData.Offset(0, EnDataCols_Language + 1)
                Set r = r.Offset(0, NColObjID - r.Column)
                r.HorizontalAlignment = xlHAlignLeft
                r.NumberFormat = "General"
                r.Formula = "='" & rData.Worksheet.Name & "'!" & rData.Address
                r.FormulaHidden = False

                If m_nColIndexAddDetails = 1 Or m_nColIndexAddDetails > 1 And TColInfo_IsOptional(m_arColInfos(1)) Then
                  i = m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet
                  If i > 0 Then
                    Set r = r.Offset(0, NColAddDetailsFirst - r.Column)
                    r.Offset(0, NColActValue - r.Column).Copy r
                    r.ClearContents
                    If i > 1 Then
                      r.Resize(1, i).FillRight
                    End If
                    Set r = r.Resize(1, i)
                    r.Locked = False
                    r.Font.Bold = False
                    r.Interior.Color = NColor_UnLockedField
                    r.Font.Color = vbBlack
                  End If
                End If
                nRowAct = nRowAct + 1
                If bSubLogOpened Then
                  oLog.LogRecords__Add__AssignProperties text:=FormatStr(SearchTextInSPR(320), strKtoNr), Scode:=320
                  bSubLogTextInserted = True
                End If
                bNextKtoNew = True
            Case Is = 0
                Set r = m_worksheet.Cells(nRowAct, NColActValue)
                If r.Value <> vntActValue Then
                    r.Value = vntActValue
                End If
                Set r = r.Offset(0, NColPrevValue - r.Column)

                If Not r.HasFormula Then 'Formeln beibehalten (implementiert f|fffd|r Vortragsformel)
                  r.Value = vntPrevValue
                End If

                If m_nColIndexAddDetails > 1 And Not TColInfo_IsOptional(m_arColInfos(1)) Then  'ww29 'nur Zusatzaufrisse ausser direkt hinter Kontensalden (implementiert f|fffd|r BSL Aufriss, TODO allgemeiner)
                  Set rKtoSalden = rKtoSalden.Offset(0, NColAddDetailsFirst - rKtoSalden.Column)
                  Set r = r.Offset(0, NColAddDetailsFirst - r.Column)
                  For i = 0 To m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet - 1
                    r.Value = rKtoSalden.Value
                    Set rKtoSalden = rKtoSalden.Offset(0, 1)
                    Set r = r.Offset(0, 1)
                  Next i
                End If
                nRowKtoAct = nRowAct
                Do
                    nRowAct = nRowAct + 1
                    Set r = m_worksheet.Cells(nRowAct, NColObjID)
                    If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
                      nActLevel = m_nCountYKeyLevels - 1
                    Else
                      nActLevel = r.IndentLevel
                    End If
                Loop While nActLevel > 0 And nRowAct < m_nListFieldEndRow
                bNextKtoNew = True
            Case Is > 0
                If Not bKtoSetChanged Then
                  bKtoSetChanged = True
                End If
                If nLocalKto_PrevSelected > nLocalKtoNew Then
                  nLocalKto_PrevSelected = nLocalKto_PrevSelected - 1
                End If
                i = nRowAct
                Do
                    i = i + 1
                    Set r = m_worksheet.Cells(i, NColObjID)
                    If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
                      nActLevel = m_nCountYKeyLevels - 1
                    Else
                      nActLevel = r.IndentLevel
                    End If
                Loop While nActLevel > 0 And i < m_nListFieldEndRow
                Set r = m_worksheet.Range(nRowAct & ":" & i - 1)
                r.Delete
                m_nListFieldEndRow = m_nListFieldEndRow - (i - nRowAct)
                If bSubLogOpened Then
                  oLog.LogRecords__Add__AssignProperties text:=FormatStr(SearchTextInSPR(323), strKtoNr), Scode:=323
                  bSubLogTextInserted = True
                End If
                bNextKtoNew = False
        End Select


        'ww62
        If bNextKtoNew And Not oIterator_AddDetailsSrc Is Nothing Then
         'Werte Default-Init
          Set r = m_worksheet.Cells(nRowKtoAct, NColAddDetailsFirst)
          Set rTemp = r.Offset(0, NColActValue - r.Column)
          Set r = r.Resize(1, nLastUsedCol - NColAddDetailsFirst + 1)
          r.NumberFormat = m_container.DataRange_Find("StyleLocalCurrency").NumberFormat
          r.ClearContents
          r.Interior.Color = rTemp.Interior.Color
          r.Font.Color = rTemp.Font.Color

          'behelfsm|fffd|ssig: Quellinformationen f|fffd|r Kontenzeile nachziehen, falls Konte besteht oder hinzugef|fffd|gt wurde
          Dim strKtoNr_inner As String
          Dim strDetail As String, strDetail_inner As String

          Do While Not oIterator_AddDetailsSrc.EOF
            strKtoNr_inner = oIterator_AddDetailsSrc.Default(0)
            
            If StrComp(strKtoNr_inner, strKtoNr, vbTextCompare) >= 0 Then
              Exit Do
            End If
        
            oIterator_AddDetailsSrc.MoveNext
          Loop
        
          If StrComp(strKtoNr_inner, strKtoNr, vbTextCompare) = 0 Then
            'gefunden
            'Werte nach rechts antragen
            Set oIteratorSrc = oIterator_AddDetailsSrc.CreateSubIterator

            i = 0
            Set r = r.Resize(1, 1)
            Do While Not oIteratorSrc.EOF
              If oIteratorSrc.Default(0) = strKtoNr Then
                strDetail_inner = oIteratorSrc.Default(1)
              Else
                Exit Do
              End If
              strDetail = ""
              Do While i < m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet
                Set rTemp = RangeMulti_Item(m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet, i)
                strDetail = rTemp
                
                If StrComp(strDetail, strDetail_inner, vbTextCompare) >= 0 Then
                  Exit Do
                End If
                
                i = i + 1
                Set r = r.Offset(0, 1)
                
              Loop
              If StrComp(strDetail, strDetail_inner, vbTextCompare) = 0 Then
                'Werte |fffd|bertragen
                r.Value = oIteratorSrc.Default("WertLW")
                
              End If
            
              oIteratorSrc.MoveNext
            Loop
            
            
          End If
        End If
        'ende ww62

        If bNextKtoNew Then
          Set r = m_worksheet.Cells(nRowKtoAct, NColObjID)
          If rMapObjIDs Is Nothing Then
            Set rMapObjIDs = r
          Else
            Set rMapObjIDs = Union(rMapObjIDs, r)
          End If
          m_nListFieldSelectedLevel = 0
          m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionBegin = nRowKtoAct
          m_arColInfos(m_nListFieldSelectedLevel).nListFieldSelectionEnd = nRowAct
          RefreshKtoDiff nLevelChange:=0
          Dim vntWertLW As Variant
          Dim vntTemp As Variant, vntValue As Variant, vntError As Variant
          Dim nErrorTemp As Long
          Dim bCheckOK As Boolean
          i = nRowAct - nRowKtoAct - 1
          If i <= 0 Then
            vntTemp = Empty
          Else
            Set r = r.Offset(1, 0)
            Set r = r.Resize(i, 1).EntireRow
            InvokeRange VbGet Or CallTypeEx_IgnoreError, "WertLW", vntTemp, Selection:=r
          End If
          If Not IsEmpty(vntTemp) Then
            vntTemp = Empty
            InvokeRange CallTypeEx_IgnoreError, "WertLW", vntTemp, Selection:=r
            If IsObject(vntTemp) Then
              For Each r In vntTemp
                m_container.ConvertValueFromCell r, vntWertLW
                If Not IsEmpty(vntWertLW) Then
                  bCheckOK = True
                  For i = 0 To m_nCountColInfos - 1
                    If m_arColInfos(i).Level = NLevel_Max Then
                      vntValue = Empty
                      InvokeRange VbGet Or CallTypeEx_ReturnError, i, vntValue, Selection:=r
                      If IsError(vntValue) Then
                        vntError = vntValue
                      Else
                        TColInfo_Check m_arColInfos(i), vntValue, vntError, CallType:=CallTypeEx_ReturnError, oValue:=r
                      End If
                      If IsError(vntError) Then
                        bCheckOK = False
                        If bSubLogOpened Then
                          strError = ""
                          TColInfo_CreateErrorText m_arColInfos(i), CLng(vntError), strError, vntValue
                          strError = r.Address & ": " & strError
                          oLog.LogRecords__Add__AssignProperties text:=strError, Scode:=CLng(vntError)
                          bSubLogTextInserted = True
                        End If
                      End If
                    End If
                  Next i
                  If bCheckOK Then
                    If strTypeName = "ICBEW" Then
                      i = 2
                      vntValue = r.Offset(0, NColObjID - r.Column).Value
                      Set rTemp = IDLVLookup(PropertiesBrowseset(r, i), vntValue)
                      If rTemp Is Nothing Then
                        bCheckOK = False
                      Else
                        bCheckOK = (strKtoNr = rTemp.Offset(0, 1))
                      End If
                      If Not bCheckOK Then
                        strError = ""
                        nErrorTemp = EnCheckErrorInvalidValue Or IDL_ERROR_BASE
                        TColInfo_CreateErrorText m_arColInfos(i), nErrorTemp, strError, vntValue
                        If bSubLogOpened Then
                          strError = r.Address & ": " & strError
                          oLog.LogRecords__Add__AssignProperties text:=strError, Scode:=nErrorTemp
                          bSubLogTextInserted = True
                        End If
                      End If
                      Dim vntElimKtoNr As Variant
                      vntElimKtoNr = Empty
                      vntTemp = "ElimKtoNr"
                      InvokeRange VbGet Or CallTypeEx_IgnoreError, vntTemp, vntElimKtoNr, Selection:=r
                      i = vntTemp
                      If Not rTemp Is Nothing Then
                        If vntElimKtoNr = "" And rTemp.Offset(0, 2) = "" Then
                          strError = ""
                          TColInfo_CreateErrorText m_arColInfos(i), EnCheckErrorMissingValue Or IDL_ERROR_BASE, strError
                          If bSubLogOpened Then
                            strError = r.Address & ": " & strError
                            oLog.LogRecords__Add__AssignProperties text:=strError, Scode:=nErrorTemp
                            bSubLogTextInserted = True
                          End If
                        End If
                      End If
                      Dim vntZuAbSatz As Variant
                      vntZuAbSatz = Empty
                      vntTemp = "ZuAbSatz"
                      InvokeRange VbGet Or CallTypeEx_IgnoreError, vntTemp, vntZuAbSatz, Selection:=r
                      i = vntTemp
                      If Not IsEmpty(vntZuAbSatz) Then
                        If vntZuAbSatz <= -100# Or vntZuAbSatz >= 1000# Then
                          strError = ""
                          TColInfo_CreateErrorText m_arColInfos(i), EnCheckErrorInvalidValue Or IDL_ERROR_BASE, strError, vntZuAbSatz
                          If bSubLogOpened Then
                            strError = r.Address & ": " & strError
                            oLog.LogRecords__Add__AssignProperties text:=strError, Scode:=nErrorTemp
                            bSubLogTextInserted = True
                          End If
                        End If
                      End If
                    ElseIf strTypeName = "ICKTOSAL" Then
                      Dim vntWertTW As Variant, vntTWKZ As Variant
                      vntWertTW = Empty
                      vntTWKZ = Empty
                      vntTemp = "WertTW"
                      InvokeRange VbGet Or CallTypeEx_IgnoreError, vntTemp, vntWertTW, Selection:=r
                      i = vntTemp
                      vntTemp = "TWKZ"
                      InvokeRange VbGet Or CallTypeEx_IgnoreError, vntTemp, vntTWKZ, Selection:=r
                      j = vntTemp
                      If IsEmpty(vntWertTW) Then
                        If vntTWKZ <> "" Then
                          bCheckOK = False
                        End If
                      Else
                        If vntTWKZ = "" Then
                          i = j
                          bCheckOK = False
                        End If
                      End If
                      If Not bCheckOK Then
                        strError = ""
                        TColInfo_CreateErrorText m_arColInfos(i), EnCheckErrorMissingValue Or IDL_ERROR_BASE, strError
                        If bSubLogOpened Then
                          strError = r.Address & ": " & strError
                          oLog.LogRecords__Add__AssignProperties text:=strError, Scode:=nErrorTemp
                          bSubLogTextInserted = True
                        End If
                      End If
                    End If
                  End If
                End If
              Next r
            End If
          End If
          If Not m_bAddDetails_Toplevel And m_nColIndexAddDetails >= 0 And (strTypeName = "ICKTOSAL" Or strTypeName = "KSTSAL") Then
            Set r = m_worksheet.Cells(nRowKtoAct, m_arColIndicesPredef(NColAddDetailsFirst))

            If TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails)) Then
              bTemp = m_container.DetailSheet_IsAddDetail(Me, r)
              If bTemp Then
                'keine J Konten
                InvokeRange VbGet, m_arElementIndicesPredef(NColKtoKnz1), vntTemp, r, bNoHitTest:=True
                bTemp = (vntTemp <> "J")
              End If
            Else
              bTemp = True
            End If

            If bTemp Then
              Set rTemp = r.Offset(0, NColActValue - r.Column)
              Set rData = r.Resize(nRowAct - nRowKtoAct, 1)
              For i = 0 To m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet - 1
                diff_AddDetails = 0
                j = 0
                For Each r In rData
                  bTemp = (IsNumeric(r.Value) And r.Value <> "")
                  If bTemp Then
                    If j = 0 Then
                      diff_AddDetails = r.Value
                    Else
                      diff_AddDetails = diff_AddDetails - r.Value
                    End If
                  End If
                  j = j + 1
                Next r
                If diff_AddDetails = 0 Then
                  Set r = rData(1)
                  With r
                    .Interior.Color = rTemp.Interior.Color
                    .Font.Color = rTemp.Font.Color
                  End With
                Else
                  With rData(1)
                    .Interior.Color = vbRed
                    .Font.Color = vbWhite
                  End With
                End If
                Set rData = rData.Offset(0, 1)
              Next i
            End If
          End If
          If bSubLogOpened And nCompare = 0 Then
            For i = 0 To UBound(m_DiffLevel0)
              If m_DiffLevel0(i) <> 0 Then
                oLog.LogRecords__Add__AssignProperties text:=FormatStr(SearchTextInSPR(348), strKtoNr, m_DiffLevel0(i)), Scode:=348
                bSubLogTextInserted = True
              End If
            Next i
          End If
        End If
        bNextKto = True
ContinueFor:
      If nKtoNew < nCountKtoAll And bNextKtoNew Then
        nKtoNew = nKtoNew + 1
      End If
    Loop
    m_arColInfos(0).nCount_Keys_BrowseSet = nLocalKtoNew + 1
    Set m_arColInfos(0).rMap_Keys_BrowseSet = rMapObjIDs
    If m_arColInfos(0).nCount_Keys_BrowseSet = 0 Then
      m_worksheet.Visible = False
      If bSubLogOpened Then
        oLog.LogRecords__Add__AssignProperties text:=SearchTextInSPR(324), Scode:=324
        bSubLogTextInserted = True
      End If
    Else
      m_worksheet.Visible = True
      m_worksheet.Activate
      m_worksheet.AutoFilterMode = False
      Set r = m_worksheet.Cells
      Set r = m_worksheet.Range(r(m_Config.YSizeHeader, 1), r(m_nListFieldEndRow - 1, nLastUsedCol))
      r.Select
      r.AutoFilter
      Cells(m_Config.YSizeHeader + 1, IIf(m_nColIndexAddDetails >= 0 And VBA.TypeName(m_ListFieldOleObject) = "UserForm", NColAddDetailsFirst, 1)).Select
      With ActiveWindow
        .FreezePanes = True
        .DisplayGridlines = False
      End With
      RecalcLayout
      If m_cmb0 Is Nothing Then
        AttachToQuickEditField
      ElseIf bKtoSetChanged Then
        KtoFillCombo
      End If
      If nLocalKto_PrevSelected >= 0 And nLocalKto_PrevSelected < m_arColInfos(0).nCount_Keys_BrowseSet Then
        m_cmb0.ListIndex = nLocalKto_PrevSelected
      Else
        m_cmb0.ListIndex = 0
      End If
      If m_container.TCEnabled And m_nColIndexAddDetails < 0 And strTypeName = "ICKTOSAL" Then
        ShowICTWArray_Patch
      End If
      ActivateQuickEditFromIndex bSelectCell:=True, bShowCell:=True
      RefreshKtoDiff bInvalidateDiff:=True
    End If
Cleanup:
    m_container.OnActivationChange
    g_nSystemChangeCounter = g_nSystemChangeCounter - 1
    If IsOffice97 And Not m_worksheet Is Nothing Then
      If m_worksheet.Visible Then
        m_worksheet.Cells(m_Config.YSizeHeader + 1, 1).Activate
      End If
    End If
    If Not wb.MultiUserEditing And Not m_worksheet Is Nothing Then
      Protect
    End If
    If bProtectWorkbook And Not wb Is Nothing Then
      wb.Protect WorkBook_Password
    End If
    If bProgressOpened Then
      oStatusBar.CloseProgress
    End If
    If bSubLogOpened Then
      If Not bSubLogTextInserted And nError = 0 Then
        oLog.LogRecords__Add__AssignProperties text:=SearchTextInSPR(321), Scode:=321
      End If
      oLog.CloseSubLog
    End If
    If Not m_worksheet Is Nothing Then
      m_worksheet.Calculate
      m_container.Worksheet.Calculate
    End If
    Application.Calculation = nCalculation_Prev
    Set Common.CallContext = oCallContext_Common_Prev
    If bScreenUpdating_prev Then Application.ScreenUpdating = True
    If nError <> 0 Then
      Err.Raise nError, , strError
    End If
    Exit Sub
ErrHandler:
    strError = Err.Description
    nError = Err.Number
    GoTo Cleanup
End Sub

Public Sub AdjustDetails__ExcelUI()
#If CENTRALBUILD = 0 Then
  Dim oCallContext_Prev As Object
  Dim oDialog As Object
  Dim nError As Long, strError As String, strSource As String
  Set oCallContext_Prev = CallContext
  On Error GoTo ErrHandler
  Set ThisPlugin.LogActRange = Nothing
  Set CallContext = ThisPlugin
  
  'If m_frmLog Is Nothing Then
  If True Then
    Set oDialog = CreateLogWindow
    Set m_frmLog = oDialog
  Else
    Set oDialog = m_frmLog
  End If
  oDialog.Caption = SearchTextInSPR(325)
#End If
  AdjustDetails__Decentral
#If CENTRALBUILD = 0 Then
#If VBA6 = 1 Then
  Const vbModal = 1
#End If
  oDialog.Show vbModal, Nothing
  Set ThisPlugin.LogList = Nothing
#If DOTNETBUILD = 0 Then
  Set m_frmLog_cbOK = Nothing
  Set m_frmLog = Nothing
#End If
  CheckSelectionStatusDecentral_Impl
  Set CallContext = oCallContext_Prev
#If DOTNETBUILD = 0 Then
  ZeroMemory VarPtr(oDialog), 4 'Test !!!! 'wegen Vista
#End If
  Exit Sub
ErrHandler:
#If DOTNETBUILD = 0 Then
  ZeroMemory VarPtr(oDialog), 4 'Test !!!! 'wegen Vista
#End If
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  Set CallContext = oCallContext_Prev
  If nError <> ERR_USER_CANCEL Then
    ShowErrDialog nError, strError, strSource
  End If
#End If
End Sub

Private Sub KtoFillCombo()
  Dim i As Long
  Dim rObjID As Range
  Dim cmb As MSForms.ComboBox
  If m_nCountYKeyLevels > 0 Then
    Set cmb = m_arColInfos(0).cmb
    If Not cmb Is Nothing Then
      cmb.Clear
      If m_arColInfos(0).nCount_Keys_BrowseSet = 0 Then
        cmb.ShowDropButtonWhen = fmShowDropButtonWhenNever
      Else
        cmb.ColumnCount = 2
        i = 0
        For Each rObjID In m_arColInfos(0).rMap_Keys_BrowseSet
          cmb.AddItem rObjID.Value
          cmb.List(i, 1) = rObjID.Offset(0, NColBene - NColObjID).Value
          i = i + 1
        Next rObjID
        cmb.ListIndex = 0
        m_container.RecalcComboLayout cmb
        cmb.ShowDropButtonWhen = fmShowDropButtonWhenAlways
      End If
    End If
  End If
End Sub

Private Sub FillCombos()
  Dim i As Long
  Dim r As Range
  Dim Browseset As Object
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  On Error GoTo ErrHandler
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  If m_collCellAttributes Is Nothing Then
    LoadCellAttributes
  End If
  KtoFillCombo

   For i = 1 To m_nCountColInfos - 1
    Set Browseset = TColInfo_BrowseSetEffective(m_arColInfos(i))
    If Not m_arColInfos(i).cmb Is Nothing And Not Browseset Is Nothing Then
      m_container.FillCombo m_arColInfos(i).cmb, Browseset, IncludeEmptyItem:=TColInfo_IsOptional(m_arColInfos(i))
    End If
  Next i
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Err.Raise Err.Number, , Err.Description
End Sub

Private Function CreateLabel(ByVal Container As Object, Name As String) As Object 'MSForms.Control / AxControl
  Dim lbl As MSForms.Label
#If WINFORMSBUILD = 1 Then
  Dim lblExtended As Object 'AxControl
#Else
  Dim lblExtended As MSForms.Control
#End If

  Const PROGID_LABEL = "Forms.Label.1"
  Const TEXTCOLOR_FieLabel = &H8000&
#If WINFORMSBUILD = 1 Then
  Set lblExtended = Container.Controls_Add(PROGID_LABEL, Name)
#Else
  Set lblExtended = Container.Controls.Add(PROGID_LABEL, Name)
#End If
  
  lblExtended.Visible = True

#If WINFORMSBUILD = 1 Then
  Set lbl = lblExtended.GetOCX
#Else
  Set lbl = lblExtended
#End If
  
  
  lbl.ForeColor = TEXTCOLOR_FieLabel
  lbl.BackStyle = 0
  lbl.BorderStyle = 0
  Set CreateLabel = lblExtended
End Function

Private Function CreateCombo(ByVal Container As Object, Name As String) As Object 'MSForms.Control / AxControl
  Dim cmb As MSForms.ComboBox
#If WINFORMSBUILD = 1 Then
  Dim cmbExtended As Object 'AxControl
#Else
  Dim cmbExtended As MSForms.Control
#End If
  Const PROGID_COMBO = "Forms.ComboBox.1"
  Const BACKCOLOR_InputRequiredField = &H80FFFF
  Const TEXTCOLOR_FunctionalField = vbBlue
#If WINFORMSBUILD = 1 Then
  Set cmbExtended = Container.Controls_Add(PROGID_COMBO, Name)
#Else
  Set cmbExtended = Container.Controls.Add(PROGID_COMBO, Name)
#End If
  
  cmbExtended.Visible = True
  
#If WINFORMSBUILD = 1 Then
  Set cmb = cmbExtended.GetOCX
#Else
  Set cmb = cmbExtended
#End If


  cmb.ForeColor = TEXTCOLOR_FunctionalField
  cmb.BackColor = BACKCOLOR_InputRequiredField
  cmb.BackStyle = fmBackStyleOpaque
  cmb.BorderStyle = fmBorderStyleSingle
  cmb.ShowDropButtonWhen = fmShowDropButtonWhenAlways
  cmb.style = fmStyleDropDownList
  cmb.SelectionMargin = False
  cmb.FontBold = True
  Set CreateCombo = cmbExtended
End Function

Private Sub AttachToQuickEditField()
  Dim fr As Object
  Dim oListFieldOleObject As Object
  Dim bProtect As Boolean
  Dim nError As Long, strSource As String, strError As String
  Dim bCreate As Boolean
  Dim bReadOnly As Boolean
  Dim nCol As Long
  Dim cmb As MSForms.ComboBox
  Dim lbl As MSForms.Label
  
#If WINFORMSBUILD = 1 Then
  Dim lblExtended As Object 'AxControl
  Dim oControlExtended As Object 'AxControl
#Else
  Dim lblExtended As MSForms.Control
  Dim oControlExtended As MSForms.Control
#End If

  Dim nHeightLabel As Long, nHeightCombo As Long
  Dim nTopLabel As Long, nTopCombo As Long
  Dim nLeft As Long
  Dim strTag As String
  Dim strName As String
  Dim rAttachedRange As Range
  Dim arCmb(0 To N_COUNT_CMB_MAX - 1) As MSForms.ComboBox
  Dim nIndexCmbAct As Long

  Dim nHeight As Long, nWidth As Long
  Dim oControls As Object
#If CENTRALBUILD = 0 Then
  Const vbAlignTop = 1
#End If
  Const TEXTCOLOR_Field = vbBlack
  Const BACKCOLOR_Field = vbWhite
  Const N_WIDTH = 80
  Const N_MARGIN = 2
#If CENTRALBUILD Then
#End If
  On Error GoTo ErrHandler
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  If Not m_Config.MaintainQuickEditField Then Exit Sub
Retry:
  Set rAttachedRange = m_worksheet.Range("A5:H6")
  If Not rAttachedRange.EntireRow.Hidden Then
    If m_worksheet.ProtectContents Then
      Unprotect
      bProtect = True
    End If
    rAttachedRange.EntireRow.Hidden = True
  End If
  If Not m_ListFieldOleObject Is Nothing Then
    bCreate = False
    Set oListFieldOleObject = m_ListFieldOleObject
  Else
#If CENTRALBUILD = 0 Then
    nHeight = 37.5 * 4 / 3
    nWidth = 423 * 4 / 3

    Set oListFieldOleObject = ThisPlugin.CreateFrame(Width:=nWidth, Height:=nHeight, Align:=vbAlignTop)
#End If
    bCreate = True
  End If

  Set fr = oListFieldOleObject.Object
#If WINFORMSBUILD = 1 Then
  nHeightLabel = nHeight - N_MARGIN
#Else
  fr.Font.Bold = False
  nHeightLabel = fr.InsideHeight / 2 - N_MARGIN
#End If
  nHeightCombo = nHeightLabel
  nTopLabel = N_MARGIN
  nTopCombo = nHeightLabel + nTopLabel + N_MARGIN / 2
  nLeft = N_MARGIN

#If WINFORMSBUILD = 0 Then
  Set oControls = fr.Controls
#End If

  nIndexCmbAct = 0
  For nCol = 0 To m_nCountColInfos - 1
    If m_arColInfos(nCol).IncludeInListField And m_arColInfos(nCol).Name <> "" Then
      bReadOnly = TColInfo_ReadOnly(m_arColInfos(nCol))
      strName = m_arColInfos(nCol).Name
      If m_arColInfos(nCol).oType Is Nothing Then
         strTag = ""
      Else
        strTag = m_container.DataRange_Name(m_arColInfos(nCol).oType)
      End If
      If bCreate Then
        Set lblExtended = CreateLabel(fr, "lbl" & strName)
        lblExtended.Height = nHeightLabel
        lblExtended.Width = N_WIDTH
        lblExtended.Left = nLeft
        lblExtended.Top = nTopLabel
        lblExtended.tag = strTag
        If bReadOnly Then
          Set oControlExtended = CreateLabel(fr, strName)
        Else
          Set oControlExtended = CreateCombo(fr, strName)
        End If
        oControlExtended.Height = nHeightCombo
        oControlExtended.Width = N_WIDTH
        oControlExtended.Left = nLeft
        oControlExtended.Top = nTopCombo
      Else
        Set lblExtended = oControls.Item("lbl" & strName)
        Set oControlExtended = oControls.Item(strName)
      End If
      If bReadOnly Then
#If WINFORMSBUILD = 1 Then
        Set lbl = oControlExtended.GetOCX
#Else
        Set lbl = oControlExtended
#End If
        lbl.Caption = ""
        lbl.ForeColor = TEXTCOLOR_Field
      Else
      
#If WINFORMSBUILD = 1 Then
        Set cmb = oControlExtended.GetOCX
#Else
        Set cmb = oControlExtended
#End If
        Set m_arColInfos(nCol).cmb = cmb
        cmb.ListIndex = -1
        If TColInfo_IsOptional(m_arColInfos(nCol)) Then
          cmb.ForeColor = TEXTCOLOR_Field
          cmb.BackColor = BACKCOLOR_Field
        End If
        If m_arColInfos(nCol).nCount_Keys_BrowseSet = 0 Then
          cmb.ShowDropButtonWhen = fmShowDropButtonWhenNever
          cmb.style = fmStyleDropDownCombo
        End If
        Set arCmb(nIndexCmbAct) = cmb
        nIndexCmbAct = nIndexCmbAct + 1
      End If
      nLeft = nLeft + N_WIDTH + N_MARGIN
    End If
  Next nCol
  ReloadFormLabels fr
  If nIndexCmbAct >= 1 Then
    Set m_cmb0 = arCmb(0)
    If nIndexCmbAct >= 2 Then
      Set m_cmb1 = arCmb(1)
      If nIndexCmbAct >= 3 Then
        Set m_cmb2 = arCmb(2)
        If nIndexCmbAct >= 4 Then
          Set m_cmb3 = arCmb(3)
          If nIndexCmbAct >= 5 Then
            Set m_cmb4 = arCmb(4)
            If nIndexCmbAct >= 6 Then
              Set m_cmb5 = arCmb(5)
              If nIndexCmbAct >= 7 Then
                Set m_cmb6 = arCmb(6)
                If nIndexCmbAct >= 8 Then
                  Set m_cmb7 = arCmb(7)
                  If nIndexCmbAct >= 9 Then
                    Set m_cmb8 = arCmb(8)
                    If nIndexCmbAct >= 10 Then
                      Set m_cmb9 = arCmb(9)
                    End If
                  End If
                End If
              End If
            End If
          End If
        End If
      End If
    End If
  End If
  Set m_lblValueDifference = oControls!Difference
  If m_bActive Then
    oListFieldOleObject.Visible = True
  End If
  Set m_ListFieldOleObject = oListFieldOleObject
  FillCombos
Cleanup:
  If bProtect Then
    Protect
    bProtect = False
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Sub
  On Error GoTo ErrHandler
  If m_worksheet.ProtectContents Then
    Unprotect
    bProtect = True
  End If
  Set oListFieldOleObject = Nothing
  bCreate = True
  GoTo Retry
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  Set m_ListFieldOleObject = Nothing
  m_nColIndexAddDetails = -1
  Set m_lblValueDifference = Nothing
  If Not oListFieldOleObject Is Nothing Then
    oListFieldOleObject.Delete
  End If
  For nCol = 0 To m_nCountColInfos - 1
    Set m_arColInfos(nCol).cmb = Nothing
  Next nCol
  GoTo Cleanup
  Resume
End Sub

Private Sub RecalcLayout()
  Dim r As Range
  Dim i As Long
  Const STD_VALUE_COLWIDTH = 14
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  Set r = m_worksheet.Columns(NColBene)
  r.AutoFit
  Set r = r.Offset(0, NColObjID - r.Column)
  m_container.AutoFitMinColumnWidth 5 * m_nCountYKeyLevels, r
  Set r = r.Offset(0, NColBilGuVKnz - r.Column)
  r.AutoFit
  Set r = r.Offset(0, 1)
  r.AutoFit
  Set r = r.Offset(0, 1)
  r.AutoFit
  Set r = r.Offset(0, NColSHKnz - r.Column)
  r.AutoFit
  Set r = r.Offset(0, NColActValue - r.Column)
  m_container.AutoFitMinColumnWidth STD_VALUE_COLWIDTH, r
  Set r = r.Offset(0, NColPrevValue - r.Column)
  m_container.AutoFitMinColumnWidth STD_VALUE_COLWIDTH, r
  If m_nColIndexAddDetails >= 0 Then
    Set r = r.Offset(0, NColAddDetailsFirst - r.Column)
    For i = 0 To m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet - 1
      m_container.AutoFitMinColumnWidth STD_VALUE_COLWIDTH, r
      Set r = r.Offset(0, 1)
    Next i
  End If
End Sub

Private Sub ReloadFormLabels(ByVal oContainer As Object)
#If WINFORMSBUILD = 1 Then
  Dim cnt As Object 'AxControl
#Else
  Dim cnt As MSForms.Control
#End If
  Dim lbl As MSForms.Label
  Dim r As Range
  Dim wsData As Worksheet
  Dim strOnlineLanguage As String
  Dim strCaption As String
  Dim strTooltip As String
  Set wsData = m_container.DataSheet
  strOnlineLanguage = m_container.DataRange_Find("OnlineLanguage")
  For Each cnt In oContainer.Controls
    If TypeOf cnt Is MSForms.Label Then
      If cnt.tag <> "" Then
        Set lbl = cnt
        Set r = m_container.DataRange_Find(cnt.tag).Offset(0, EnDataCols_Language)
        strCaption = IDLLocText(r.Offset(0, 3), strOnlineLanguage)
        strTooltip = IDLLocText(r.Offset(0, 1), strOnlineLanguage)
        lbl.Caption = strCaption
        If strTooltip <> "" And strTooltip <> strCaption Then
          cnt.ControlTipText = strTooltip
        Else
          cnt.ControlTipText = ""
        End If
      End If
    End If
  Next cnt
End Sub

Public Function DeleteDetailLinesImpl(ByVal bCheckOnly As Boolean, Optional ByVal SelectedRange As Excel.Range) As Boolean
  Dim r As Range
  Dim rObjID As Range
  Dim rObjIDs As Range
  Dim bProtect As Boolean
  Dim nError As Long, strError As String, strSource As String
  Dim bLevel0 As Boolean
  Dim nCount As Long
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  On Error GoTo ErrHandler
  If SelectedRange Is Nothing Then
    Set SelectedRange = Selection
  End If

  Set rObjIDs = HitTestRange(nXLevel:=0, nYLevel:=1, Selection:=SelectedRange, bIncludeInnerYLevels:=True, NoSkipMissingLevels:=True) 'bei L|fffd|schen: nur Kontenzeilen zugelassen

  If Not rObjIDs Is Nothing Then
    If bCheckOnly Then
      DeleteDetailLinesImpl = True
    Else
      nCount = rObjIDs.count
      If Application.DisplayAlerts And nCount > 0 Then
        If MsgBox(FormatStr(SearchTextInSPR(397), nCount), vbOKCancel) = vbCancel Then
          GoTo Cleanup
        End If
      End If
      If Not bProtect Then
        If m_worksheet.ProtectContents Then
          Unprotect
          bProtect = True
        End If
      End If
      Dim bKtoChanged As Boolean
      For Each rObjID In rObjIDs
        If rObjID.Row >= m_arColInfos(0).nListFieldSelectionBegin And rObjID.Row < m_arColInfos(0).nListFieldSelectionEnd Then
          bKtoChanged = True
        End If
      Next rObjID
      Set rObjIDs = Intersect(rObjIDs.EntireRow, rObjIDs.Worksheet.Cells)
      rObjIDs.Delete
      m_nListFieldEndRow = m_nListFieldEndRow - nCount
      If bKtoChanged Then
        RefreshKtoDiff bInvalidateDiff:=True
      End If
      ActivateQuickEditFromIndex bShowCell:=True
    End If
  End If
Cleanup:
  If bProtect Then
    Protect
    bProtect = False
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
End Function

Public Property Get DeleteDetailLines__Enabled(Optional ByVal SelectedRange As Excel.Range) As Boolean
  DeleteDetailLines__Enabled = DeleteDetailLinesImpl(True, SelectedRange)
End Property

Public Sub DeleteDetailLines(Optional ByVal SelectedRange As Excel.Range)
  DeleteDetailLinesImpl False, SelectedRange
End Sub

Private Sub AdjustDetailsImpl(ByVal rCollSrc As Object, ByVal nLevel As Long, ByRef nListFieldSelectionBegin As Long, Optional ByVal nListFieldSelectionEnd As Long = -1, Optional ByVal bEnableInsert As Boolean = True, Optional ByVal bEnableDelete As Boolean = True)
  Dim vntObjID As Variant
  Dim rObjID As Range
  Dim r As Range
  Dim bSrcEOF As Boolean
  Dim vntObjIDWS As Variant
  Dim nIndexObjIDSrc As Long
  Dim nIndexObjIDWS As Long
  Dim bNextObjIDSrc As Boolean
  Dim bNextObjIDWS As Boolean
  Dim nLocalKtoNew As Long
  Dim nRowAct As Long
  Dim nCompare As Long
  Dim nRowObjIDAct As Long
  Dim nActLevel As Long
  Dim i As Long
    bNextObjIDWS = True
    bNextObjIDSrc = True
    nLocalKtoNew = -1
    nRowAct = nListFieldSelectionBegin
    If rCollSrc Is Nothing Then
      bSrcEOF = True
      GoTo NextLoop
    End If
    Do
      For Each vntObjID In rCollSrc
        Set rObjID = vntObjID
NextLoop:
        If bNextObjIDWS Then
          Do
            Set r = m_worksheet.Cells(nRowAct, NColObjID)
            If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
              nActLevel = m_nCountYKeyLevels - 1
            Else
              nActLevel = r.IndentLevel
            End If
            If nActLevel <= nLevel Then Exit Do
            If r = "" Then
              nActLevel = -1
              Exit Do
            End If
          Loop
          If nActLevel = nLevel Then
            vntObjIDWS = r.Value
            If vntObjIDWS = "" Then
              bNextObjIDWS = False
            End If
          ElseIf nActLevel < nLevel Then
            bNextObjIDWS = False
          End If
        End If
        If bSrcEOF Then
          If Not bNextObjIDWS Then Exit Do
        End If
        If Not bNextObjIDWS Then
          nCompare = -1
        ElseIf bSrcEOF Then
          nCompare = 1
        Else
          nCompare = StrComp(vntObjID, vntObjIDWS, vbTextCompare)
        End If
        Select Case nCompare
            Case Is < 0
                nRowObjIDAct = nRowAct
                If nRowAct < m_nListFieldEndRow Then
                  Set r = m_worksheet.Rows(nRowAct)
                  r.Insert Shift:=xlDown
                End If
                m_nListFieldEndRow = m_nListFieldEndRow + 1
                WriteDetailRow nLevel, nRowAct, nIndexObjIDSrc
                nRowAct = nRowAct + 1
                bNextObjIDSrc = True
            Case Is = 0
                nRowObjIDAct = nRowAct
                Do
                    nRowAct = nRowAct + 1
                    Set r = m_worksheet.Cells(nRowAct, NColObjID)
                    If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
                      nActLevel = m_nCountYKeyLevels - 1
                    Else
                      nActLevel = r.IndentLevel
                    End If
                Loop While nActLevel > nLevel And nRowAct < m_nListFieldEndRow
                bNextObjIDSrc = True
            Case Is > 0
                i = nRowAct
                Do
                    i = i + 1
                    Set r = m_worksheet.Cells(i, NColObjID)
                    If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
                      nActLevel = m_nCountYKeyLevels - 1
                    Else
                      nActLevel = r.IndentLevel
                    End If
                Loop While nActLevel > nLevel And i < m_nListFieldEndRow
                Set r = m_worksheet.Range(nRowAct & ":" & i - 1)
                If bEnableDelete Then
                  r.Delete
                  m_nListFieldEndRow = m_nListFieldEndRow - (i - nRowAct)
                Else
                  nRowAct = i
                End If
                bNextObjIDSrc = False
        End Select
        bNextObjIDWS = True
        If bSrcEOF Or Not bNextObjIDSrc Then
          GoTo NextLoop
        End If
        nIndexObjIDSrc = nIndexObjIDSrc + 1
      Next vntObjID
      bSrcEOF = True
    Loop
    nListFieldSelectionBegin = nRowAct
End Sub

Private Function InsertDetailLinesImpl_Full(ByVal bCheckOnly As Boolean, ByVal SelectedRange As Excel.Range) As Boolean
  Dim r As Range, rDest As Range
  Dim rObjID As Range
  Dim rObjIDs As Range
  Dim bProtect As Boolean
  Dim nError As Long, strError As String, strSource As String
  Dim newDiff As Currency
  Dim nRow As Long, nRowStart As Long
  Const nLevel As Long = 1
  Dim rCollSrc As Range
  Dim bScreenUpdatingChanged As Boolean
  Dim bEnableCalculationChanged As Boolean
  Dim oCollSelected As New Collection
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  On Error GoTo ErrHandler
  Set rObjIDs = HitTestRange(nYLevel:=0, Selection:=SelectedRange)
  If Not rObjIDs Is Nothing Then
     If bCheckOnly Then
      InsertDetailLinesImpl_Full = True
    Else
      If Not bProtect Then
        If m_worksheet.ProtectContents Then
          Unprotect
          bProtect = True
        End If
      End If
      If Application.ScreenUpdating Then
        Application.ScreenUpdating = False
        bScreenUpdatingChanged = True
      End If
      If m_worksheet.EnableCalculation Then
        m_worksheet.EnableCalculation = False
        bEnableCalculationChanged = True
      End If
      If m_arColInfos(nLevel).nCount_Keys_BrowseSet > 0 Then
        Set rCollSrc = m_arColInfos(nLevel).rMap_Keys_BrowseSet
      End If
      For Each rObjID In rObjIDs
        oCollSelected.Add rObjID
      Next rObjID
      For Each rObjID In oCollSelected
        nRowStart = rObjID.Row + 1
        nRow = nRowStart
        m_arColInfos(nLevel - 1).nListFieldSelectionBegin = nRowStart - 1
        AdjustDetailsImpl rCollSrc, nLevel, nRow, bEnableDelete:=False
        ExcludesRowsOnRowMap m_arColInfos(0).rMap_Keys_BrowseSet, nRowStart, nRow - nRowStart
      Next rObjID
      ActivateQuickEditFromIndex nLevel - 1, bShowCell:=True
    End If
  End If
Cleanup:
  If bProtect Then
    Protect
    bProtect = False
  End If
  If bScreenUpdatingChanged Then
    Application.ScreenUpdating = True
    bScreenUpdatingChanged = False
  End If
  If bEnableCalculationChanged Then
    m_worksheet.EnableCalculation = True
    bEnableCalculationChanged = False
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
End Function

Private Function InsertDetailLinesImpl(ByVal bCheckOnly As Boolean, Optional ByVal SelectedRange As Excel.Range) As Boolean
  Dim r As Range, rDest As Range
  Dim rObjID As Range
  Dim rObjIDs As Range
  Dim bProtect As Boolean
  Dim nError As Long, strError As String, strSource As String
  Dim nLevel As Long
  If m_nCountYKeyLevels < 2 Then
    Exit Function
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  On Error GoTo ErrHandler
  If SelectedRange Is Nothing Then
    Set SelectedRange = Selection
  End If
  For nLevel = 1 To m_nCountYKeyLevels - 1
    Set rObjIDs = HitTestRange(nYLevel:=nLevel, Selection:=SelectedRange, NoSkipMissingLevels:=True)
    If Not rObjIDs Is Nothing Then
      If rObjIDs.count > 1 Then
        Set rObjIDs = Nothing
      End If
    End If
    If Not rObjIDs Is Nothing Then
      If KeyLevelImpl(rObjIDs) = 0 Then
        Set rObjIDs = Nothing 'Level 0 (Konto) nicht verwenden
      End If
    End If

    If Not rObjIDs Is Nothing Then
      Exit For
    End If
  Next nLevel
  If rObjIDs Is Nothing Then
    InsertDetailLinesImpl = InsertDetailLinesImpl_Full(bCheckOnly, SelectedRange)
  Else
    If bCheckOnly Then
      InsertDetailLinesImpl = True
    Else
      If Not bProtect Then
        If m_worksheet.ProtectContents Then
          Unprotect
          bProtect = True
        End If
      End If
      Set rObjID = rObjIDs
      Set r = rObjID.EntireRow
      Set rDest = r.Offset(1, 0)
      rDest.Insert xlShiftDown
      Set rDest = r.Offset(1, 0)
      r.Copy rDest
      m_nListFieldEndRow = m_nListFieldEndRow + 1
      RefreshKtoDiff bInvalidateDiff:=True
      ActivateQuickEditFromCellSelection rObjID
    End If
  End If
Cleanup:
  If bProtect Then
    Protect
    bProtect = False
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
End Function

Public Property Get InsertDetailLines__Enabled(Optional ByVal SelectedRange As Excel.Range) As Boolean
  InsertDetailLines__Enabled = InsertDetailLinesImpl(True, SelectedRange)
End Property

Public Sub InsertDetailLines(Optional ByVal SelectedRange As Excel.Range)
  InsertDetailLinesImpl False, SelectedRange
End Sub

Private Sub CreateDetailSheet()
  Dim rDetails As Range, r As Range
  Dim rSheetRef As Range
  Dim rStart As Range
  Dim wsSalden As Worksheet
  Dim nLastUsedCol As Long
  Dim wb As Workbook
  Dim i As Long
  Dim bProtectDatasheet As Boolean
  Dim wsData As Worksheet
  Dim ws As Worksheet
  Dim nError As Long
  Dim strError As String
  Dim bTemp As Boolean
  Dim strTemp As String
  Dim strOnlineLanguage As String
  On Error GoTo ErrHandler
  Set wsSalden = m_container.Worksheet
  Set wb = wsSalden.Parent
  Set ws = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.count))
  Set m_worksheet = ws
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  Set rDetails = m_container.DataRange_Find("Detailsheets", i)
  If i > 0 Then
    For Each r In rDetails
      If r.Value = m_ClassName Then
        Set wsData = r.Worksheet

        'serialisierte Daten lesen
        DataRange_read r

        If wsData.ProtectContents Then
          wsData.Unprotect WorkBook_Password
          bProtectDatasheet = True
        End If
        Set rSheetRef = r
        Exit For
      End If
    Next r
  End If
  nLastUsedCol = NColAddDetailsFirst - 1
  If m_nColIndexAddDetails >= 0 Then
    nLastUsedCol = nLastUsedCol + m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet
  End If
  Set rStart = ws.Range("A1")
  Set r = wsSalden.Cells(1, 1)
  Set r = r.Resize(4, nLastUsedCol - r.Column + 1)
  DuplicateRange r, rStart, WithCellExtent:=True
  Set r = wsSalden.Cells(1, 7)
  Set r = r.Resize(1, nLastUsedCol - r.Column + 1)
  r.Copy rStart.Offset(0, 6)
  Set r = ws.Range("A5")
  Set rDetails = wsSalden.Range("A5")
  DuplicateRange rDetails.Resize(3, nLastUsedCol - rDetails.Column + 1), r, WithCellExtent:=True
  If m_nColIndexAddDetails >= 0 Then
    If m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet > 0 Then
      r.Offset(0, NColAddDetailsFirst - r.Column - 1).Resize(3, m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet + 1).FillRight
      Set r = r.Offset(1, NColAddDetailsFirst - r.Column)
      For Each rDetails In m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet
        m_container.CreateIDLLocTextRangeDirect r, rDetails.Offset(0, EnDataCols_Language + 3)
        Set r = r.Offset(0, 1)
      Next rDetails
    End If
  End If
  rStart.Formula = "=" & m_container.CreateIDLLocTextFormulaDecentral("FIE", "K066-K021-AGB", "Bene3") & " & "" : "" & " & m_container.CreateIDLLocTextFormulaDirect(rSheetRef.Offset(0, EnDataCols_Language + 1))
  strOnlineLanguage = m_container.DataRange_Find("OnlineLanguage")
  Set r = IDLLocText(rSheetRef.Offset(0, EnDataCols_Language + 1), strOnlineLanguage)
  strTemp = r.Value
  On Error Resume Next
  If Len(strTemp) > 31 Then
    strTemp = Left$(strTemp, 31)
  End If
  ws.Name = strTemp
  On Error GoTo ErrHandler
  Set r = rStart.Range("5:6")
  r.Insert xlShiftDown
  rStart.Range("5:6").RowHeight = 19
  rStart.Cells(m_Config.YSizeHeader, 1).RowHeight = 10
On Error GoTo NoPageSetup
  With ws.PageSetup
      .PrintTitleRows = "$1:$" & m_Config.YSizeHeader & ""
      .Orientation = IIf(m_nColIndexAddDetails >= 0, xlLandscape, xlPortrait)
      .PrintNotes = True
      .PrintComments = xlPrintInPlace
  End With
NoPageSetup:
  On Error GoTo ErrHandler
Cleanup:
  If nError = 0 Then
    If Not rSheetRef Is Nothing Then
      rSheetRef.Offset(0, 1).Formula = "='" & Replace(ws.Name, "'", "''") & "'!B1"
    End If
  Else
    If Not ws Is Nothing Then
      bTemp = Application.DisplayAlerts
      Application.DisplayAlerts = False
      ws.Delete
      Application.DisplayAlerts = bTemp
      Set m_worksheet = Nothing
    End If
  End If
  If bProtectDatasheet Then
    wsData.Protect Password:=WorkBook_Password
  End If
  If nError <> 0 Then
    Err.Raise nError, , strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  GoTo Cleanup
End Sub

Public Function CalculateFunctionObjects(ByVal rSelection As Range) As Collection
  Dim nError As Long, strError As String, strSource As String
  Dim nCalculation_Prev As Long
  nCalculation_Prev = Application.Calculation
  On Error GoTo ErrHandler
  If nCalculation_Prev <> xlCalculationManual Then
        If IsOffice97 Then
            On Error Resume Next
            Application.Calculation = xlCalculationManual
            If Err.Number <> 0 Then
              Range("B2").Activate
              Application.Calculation = xlCalculationManual
            End If
            On Error GoTo ErrHandler
        Else
          Application.Calculation = xlCalculationManual
        End If
  End If
  Set g_collCalculateFunctionObjects = New Collection
  On Error GoTo HandleCalculateBug
  rSelection.Calculate
  On Error GoTo ErrHandler
  Set CalculateFunctionObjects = g_collCalculateFunctionObjects
Cleanup:
  Set g_collCalculateFunctionObjects = Nothing
  If nCalculation_Prev <> xlCalculationManual Then
    If IsOffice97 Then
      On Error Resume Next
      Application.Calculation = nCalculation_Prev
      If Err.Number <> 0 Then
        Range("B2").Activate
        Application.Calculation = nCalculation_Prev
      End If
    Else
      Application.Calculation = nCalculation_Prev
    End If
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
ErrHandler:
  strError = Err.Description
  nError = Err.Number
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
HandleCalculateBug:
  On Error GoTo ErrHandler
  Application.Iteration = False
  Resume
End Function

Public Sub Ambients__PropertyChanged__LocaleID()
  Dim bProtect As Boolean
  Dim nKto_prev As Long, nDetail_prev As Long, nAddDetail_prev As Long
  On Error GoTo ErrHandler
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  m_CallContext_LocaleID_temp = 0
  m_CallContext_LocaleIDNumberSeparator_temp = 0


  Set m_collNameToIndex = Nothing
  If Not m_worksheet Is Nothing Then
    UpdateLocaleCommentAttributes bProtect, False
    If Not m_cmb0 Is Nothing Then
      nKto_prev = m_cmb0.ListIndex
      nDetail_prev = m_cmb1.ListIndex
      If m_nColIndexAddDetails >= 0 Then nAddDetail_prev = m_arColInfos(m_nColIndexAddDetails).cmb.ListIndex
      FillCombos
      m_cmb0.ListIndex = nKto_prev
      m_cmb1.ListIndex = nDetail_prev
      If m_nColIndexAddDetails >= 0 Then m_arColInfos(m_nColIndexAddDetails).cmb.ListIndex = nAddDetail_prev
      MoveDataToValueFields
      RefreshKtoDiff bInvalidateDiff:=True
    End If
    If m_worksheet.Visible Then
      If Not m_worksheet.Parent.MultiUserEditing Then
        If Not bProtect Then
          Unprotect
          bProtect = True
        End If
        RecalcLayout
      End If
    End If
  End If
  If Not m_ListFieldOleObject Is Nothing Then
    ReloadFormLabels m_ListFieldOleObject.Object
  End If
  If m_bContextMenuLoaded Then
    RefreshCellContextMenu bClear:=True
  End If
  If bProtect Then
    Protect
    bProtect = False
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  On Error Resume Next
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  If bProtect Then
    Protect
  End If
End Sub

Public Sub RefreshCellContextMenu(Optional ByVal bClear As Boolean)
  Dim vntTemp As Variant
  Dim vType As Variant
  Dim oControl As CommandBarControl
  Dim cmdBarTemp As CommandBar
  Dim nCol As Long
  Dim nCountColumns As Long
  Dim arColumns() As Variant
  Dim arValues() As Variant
  Dim i As Long
  Dim bVisible As Boolean
  Dim strTemp As String
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  For nCol = 0 To m_nCountColInfos - 1
    If m_arColInfos(nCol).IncludeInContextMenu And Not m_arColInfos(nCol).oType Is Nothing Then
      nCountColumns = nCountColumns + 1
    End If
  Next nCol
  If nCountColumns = 0 Then Exit Sub
  ReDim arColumns(nCountColumns - 1)
  ReDim arValues(nCountColumns - 1)
  i = 0
  For nCol = 0 To m_nCountColInfos - 1
    If m_arColInfos(nCol).IncludeInContextMenu And Not m_arColInfos(nCol).oType Is Nothing Then
      arColumns(i) = nCol
      i = i + 1
    End If
  Next nCol
  If Not bClear Then
    InvokeRange VbGet Or CallTypeEx_ReturnError, arColumns, arValues, Selection
  End If
  For Each vntTemp In Array("Cell", "Row", "Column")
    Set cmdBarTemp = Application.CommandBars(vntTemp)
    For i = 0 To nCountColumns - 1
      nCol = arColumns(i)
      If bClear Then
        m_container.OfficeMenu_RefreshControl CommandBar:=cmdBarTemp, vType:=vType, Handler:="OnContextMenuClick", Name:=m_arColInfos(nCol).Name, Clear:=True
      Else
        If Not m_arColInfos(nCol).oType Is Nothing Then
          Set vType = m_arColInfos(nCol).oType
        Else
          vType = m_arColInfos(nCol).VarType
        End If
        Set oControl = Nothing
        m_container.OfficeMenu_RefreshControl CommandBar:=cmdBarTemp, Control:=oControl, vType:=vType, Handler:="OnContextMenuClick", Name:=m_arColInfos(nCol).Name, Value:=arValues(i), Browseset:=m_arColInfos(nCol).rMap_Keys_BrowseSet, uml_ex:=m_arColInfos(nCol).uml_ex, BrowseFlags:=m_arColInfos(nCol).BrowseFlags, CallType:=m_arColInfos(nCol).CallType
        bVisible = Not IsError(arValues(i))
        oControl.Visible = bVisible
      End If
    Next i
  Next vntTemp
  m_bContextMenuLoaded = Not bClear
End Sub

Public Sub OnContextMenuClick()
  Dim strTag As String
  Dim r As Range
  Dim i As Long
  Dim nCol As Long
  Dim bFound As Boolean
  Dim oControl As CommandBarControl
  Dim vntText As Variant
  Dim nError As Long, strSource As String, strError   As String
  On Error GoTo ErrHandler
  nCol = -1
  Set oControl = Application.CommandBars.ActionControl
  strTag = oControl.tag
#If CENTRALBUILD Then
  If m_container.Standalone Then
    This_Decentral.OnContextMenuClick
    Exit Sub
  End If
#End If
  i = 0
  If strTag <> "" Then
    For nCol = 0 To m_nCountColInfos - 1
      If m_arColInfos(nCol).IncludeInContextMenu Then
        If StrComp(strTag, "IDL.Connector." & m_arColInfos(nCol).Name, vbTextCompare) = 0 Then
          bFound = True
          Exit For
        End If
      End If
    Next nCol
  End If
  If Not bFound Then
    nCol = -1
  Else
    vntText = Trim(oControl.text)
    If oControl.Type = msoControlComboBox Then
      i = InStr(1, vntText, " ")
      If i > 0 Then
        vntText = Trim(Left(vntText, i - 1))
        i = InStr(1, vntText, "_")
        Do While i > 0
          If Mid$(vntText, i + 1, 1) = "_" Then
            vntText = Left(vntText, i - 1) & Mid(vntText, i + 1)
          Else
            vntText = Left(vntText, i - 1) & " " & Mid(vntText, i + 1)
          End If
          i = i + 1
          i = InStr(i, vntText, "_")
        Loop
      End If
    End If
    InvokeRange VbLet, nCol, vntText, Selection
  End If
Cleanup:
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  If nCol >= 0 Then
    TColInfo_CreateErrorText m_arColInfos(nCol), nError, strError, vntText
  End If
  GoTo Cleanup
End Sub

Public Property Get IsActive() As Boolean
  IsActive = m_bActive
End Property

'Auflistung f|fffd|r Ja/Nein f|fffd|r Boolsche Auswahl
Private Property Get BrowsesetBool() As Object
  Set BrowsesetBool = Union(m_container.DataRange_Find("CON__355"), m_container.DataRange_Find("CON__356")) 'Ja/Nein
End Property

Public Sub OnActivationChange(ByVal bActivate As Boolean)
  If m_bActive = bActivate Then
    Exit Sub
  End If
  m_bActive = bActivate
  If Not m_ListFieldOleObject Is Nothing Then
    If Not TypeOf m_ListFieldOleObject Is OLEObject Then
      m_ListFieldOleObject.Visible = bActivate
    End If
  End If
#If CENTRALBUILD Then
  If m_container.Standalone Then
    If m_container.Version >= 9 Then
      This_Decentral.OnActivationChange bActivate
    End If
  Else
#End If
    If Valid And bActivate Then
      If m_cmb0 Is Nothing Then
        AttachToQuickEditField
        ActivateQuickEditFromCellSelection Selection
      End If
    End If
#If CENTRALBUILD Then
  End If
#End If
#If CENTRALBUILD = 0 Then
  If bActivate Then
    CheckSelectionStatusDecentral_Impl
  End If
#End If
  If Not bActivate And m_bContextMenuLoaded Then
    RefreshCellContextMenu bClear:=True
  End If
End Sub

Public Function PropertiesFindIndex(ByVal strName As String, Optional IndexResult As Long) As Boolean
  Dim i As Long
  Dim vntTemp As Variant
  Dim bFound As Boolean
  vntTemp = strName
  InvokeRange 0, vntTemp
  bFound = Not IsError(vntTemp)
  If bFound Then
    IndexResult = vntTemp
  End If
  PropertiesFindIndex = bFound
End Function

Public Function PropertiesNameToIndex(Optional ByVal strName As String) As Long
  If Not PropertiesFindIndex(strName, PropertiesNameToIndex) Then
    Err.Raise ERR_INVALIDARG
  End If
End Function

Public Property Get Default(Optional Name As Variant) As Variant
Attribute Default.VB_UserMemId = 0
  InvokeRange VbGet, Name, Default, bNoHitTest:=True
End Property

Public Property Let Default(Optional Name As Variant, vntParam As Variant)
  InvokeRange VbLet, Name, vntParam, bNoHitTest:=True
End Property


Private Sub InvokeBound(ByVal CallType As Long, ByVal rObjIDs As Range, ByRef Names As Variant, ByRef vntData As Variant, ByRef rbProtectWS As Boolean, ByRef bChanged As Boolean, ByVal bNoInternalStates As Boolean)
  Dim vntProperty As Variant
  Dim vntValue As Variant
  Dim nIndexName As Long
  Dim bArray As Boolean
  Dim rObjID As Range
  Dim rData As Range
  Dim bMultiSelection As Boolean
  Dim nLevelAct As Long
  Dim i As Long
  If m_collNameToIndex Is Nothing Then
    InitNamesMap
  End If
  bArray = IsArray(Names)
  bMultiSelection = (rObjIDs.count > 1)
  If Not bMultiSelection Then
    Set rObjID = rObjIDs
    GoTo EnterNoForEachRObjID
  End If
  For Each rObjID In rObjIDs
EnterNoForEachRObjID:
    If Not bArray Then
      vntProperty = Names
      GoTo EnterNoArray
    End If
    nIndexName = 0
    For Each vntProperty In Names
EnterNoArray:
      If m_arColInfos(vntProperty).StgType = EnStgType_Bound And (Not bNoInternalStates Or (m_arColInfos(vntProperty).StgType And &H7) = 0) Then
        If (CallType And VbGet) <> 0 Then
          If m_arColInfos(vntProperty).Formula = "" Then
            If StrComp(m_arColInfos(vntProperty).Name, "DataFlags", vbTextCompare) = 0 Then
              vntValue = Empty
              m_container.KTOSAL_InvokeBound CallType, rObjID, vntProperty, vntValue, rbProtectWS, bChanged
            End If
            If StrComp(m_arColInfos(vntProperty).Name, "SHKnz", vbTextCompare) = 0 Then
              vntValue = Empty
              i = rObjID.Column
              If i >= NColAddDetailsFirst Then
                i = i - NColAddDetailsFirst
                If i < m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet Then
                  Set rData = RangeMulti_Item(m_arColInfos(m_nColIndexAddDetails).rMap_Keys_BrowseSet, i)
                  If Not rData Is Nothing Then
                    vntValue = rData.Offset(0, EnDataCols_SHKnz - EnDataCols_ObjID).Value
                  End If
                End If
              Else
                vntValue = rObjID.Offset(0, NColSHKnz - rObjID.Column).Value
              End If
            End If
          Else
#If CENTRALBUILD = 0 Then
            ExcelEvaluate m_arColInfos(vntProperty).Formula, vntValue, rObjID
#End If
          End If
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          If bMultiSelection Then
            If bArray Then
              If IsEmpty(vntData(nIndexName)) Then
                vntData(nIndexName) = vntValue
              ElseIf Not IsArray(vntData(nIndexName)) Then
                If vntValue <> vntData(nIndexName) Then
                  vntData(nIndexName) = Array(vntData(nIndexName), vntValue)
                End If
              End If
            Else
              If IsEmpty(vntData) Then
                vntData = vntValue
              ElseIf Not IsArray(vntData) Then
                If vntValue <> vntData Then
                  vntData = Array(vntData, vntValue)
                End If
              End If
            End If
          Else
            If bArray Then
              vntData(nIndexName) = vntValue
            Else
              vntData = vntValue
            End If
          End If
        ElseIf (CallType And VbLet) <> 0 Then
          Err.Raise E_NOTIMPL
        Else
          Err.Raise E_NOTIMPL
        End If
      End If
      If Not bArray Then GoTo ExitFor
      nIndexName = nIndexName + 1
    Next vntProperty
ExitFor:
NextForEachRObjID:
    If Not bMultiSelection Then GoTo ExitForEachRObjID
  Next rObjID
ExitForEachRObjID:
End Sub

Private Sub InvokeCellAttributes(ByVal CallType As Long, ByVal rObjIDs As Range, ByRef Names As Variant, ByRef vntData As Variant, ByRef rbProtectWS As Boolean, Optional ByRef bChanged As Boolean)
  Dim nCol As Long
  Dim i As Long
  Dim vntProperty As Variant
  Dim strFormula As String
  Dim bChangedLocal As Boolean
  Dim bEmpty As Boolean
  Dim vntValue As Variant
  Dim nIndexName As Long
  Dim bArray As Boolean
  Dim rObjID As Range
  Dim bMultiSelection As Boolean
  Dim vntAttributesAct As Variant
  Dim rAttributeCell As Range
  Dim nAttributeIndex As Long
  Dim nIndexAttributeColl As Long
  Dim nCompare As Long
  Dim AttributeIndices As Variant
  Dim nStructSize As Long
  If m_collNameToIndex Is Nothing Then
    InitNamesMap
  End If
  bArray = IsArray(Names)
  If bArray Then
    ReDim AttributeIndices(UBound(Names))
  End If
  nStructSize = 0
  For nCol = 0 To m_nCountColInfos - 1
    If m_arColInfos(nCol).StgType = EnStgType_CellAttribute Then
      If Not bArray Then
        If nCol = Names Then
          AttributeIndices = nStructSize
        End If
      Else
        For i = 0 To UBound(Names)
          If nCol = Names(i) Then
            AttributeIndices(i) = nStructSize
            Exit For
          End If
        Next i
      End If
      nStructSize = nStructSize + 1
    End If
  Next nCol
  If nStructSize = 0 Then
    Exit Sub
  End If
  nIndexAttributeColl = 1
  bMultiSelection = (rObjIDs.count > 1)
  If Not bMultiSelection Then
    Set rObjID = rObjIDs
    GoTo EnterNoForEachRObjID
  End If
  For Each rObjID In rObjIDs
EnterNoForEachRObjID:
    nCompare = 1
    Do While nIndexAttributeColl <= m_collCellAttributes.count
      vntAttributesAct = m_collCellAttributes(nIndexAttributeColl)
      If Not IsEmpty(vntAttributesAct) Then
        Set rAttributeCell = vntAttributesAct(0)
        nCompare = rObjID.Row - rAttributeCell.Row
        If nCompare <= 0 Then Exit Do
      End If
      nIndexAttributeColl = nIndexAttributeColl + 1
    Loop
    If nCompare <> 0 Then
      vntAttributesAct = Empty
    End If
    bChangedLocal = False
    If Not bArray Then
      vntProperty = Names
      nAttributeIndex = AttributeIndices
      GoTo EnterNoArray
    End If
    bChangedLocal = False
    nIndexName = 0
    For Each vntProperty In Names
      nAttributeIndex = AttributeIndices(nIndexName)
EnterNoArray:
      If m_arColInfos(vntProperty).StgType = EnStgType_CellAttribute Then
        If (CallType And VbGet) <> 0 Then
          If Not IsArray(vntAttributesAct) Then
            vntValue = Empty
          ElseIf nAttributeIndex < UBound(vntAttributesAct) Then
            vntValue = vntAttributesAct(nAttributeIndex + 1)
          Else
            vntValue = Empty
          End If
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          If bMultiSelection Then
            If bArray Then
              If IsEmpty(vntData(nIndexName)) Then
                vntData(nIndexName) = vntValue
              Else
                If vntValue <> vntData(nIndexName) Then
                  vntData(nIndexName) = Array(vntData(nIndexName), vntValue)
                End If
              End If
            Else
              If IsEmpty(vntData) Then
                vntData = vntValue
              Else
                If vntValue <> vntData Then
                  vntData = Array(vntData, vntValue)
                End If
              End If
            End If
          Else
            If bArray Then
              vntData(nIndexName) = vntValue
            Else
              vntData = vntValue
            End If
          End If
        ElseIf (CallType And VbLet) <> 0 Then
          If bArray Then
            vntValue = vntData(nIndexName)
          Else
            vntValue = vntData
          End If
          If vntValue = "" Then
            vntValue = Empty
          End If
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          If IsArray(vntAttributesAct) Then
            If nAttributeIndex >= UBound(vntAttributesAct) Then
              ReDim Preserve vntAttributesAct(nAttributeIndex + 1)
            End If
          Else
            ReDim vntAttributesAct(nStructSize)
          End If
          If vntAttributesAct(nAttributeIndex + 1) <> vntValue Then
            vntAttributesAct(nAttributeIndex + 1) = vntValue
            bChangedLocal = True
          End If
        End If
      End If
      If Not bArray Then GoTo ExitFor
      nIndexName = nIndexName + 1
    Next vntProperty
ExitFor:
    If bChangedLocal Then
      bEmpty = True
      If IsArray(vntAttributesAct) Then
        For i = 1 To UBound(vntAttributesAct)
          If Not IsEmpty(vntAttributesAct(i)) Then
            bEmpty = False
            Exit For
          End If
        Next i
      End If
      If nCompare = 0 Then
        m_collCellAttributes.Remove nIndexAttributeColl
      End If
      If Not bEmpty Then
        Set vntAttributesAct(0) = rObjID
        If nIndexAttributeColl > m_collCellAttributes.count Then
          m_collCellAttributes.Add vntAttributesAct
        Else
          m_collCellAttributes.Add vntAttributesAct, Before:=nIndexAttributeColl
        End If
      End If
      If Not rbProtectWS Then
        If m_worksheet.ProtectContents Then
          Unprotect
          rbProtectWS = True
        End If
      End If
      If bEmpty Then
        If rObjID.HasFormula Then
          rObjID.Value = rObjID.Value
        Else
          bChangedLocal = False
        End If
      Else
        strFormula = "=IDLCellAttributes(""" & rObjID.Value & """"
        For i = 1 To UBound(vntAttributesAct)
          strFormula = strFormula & ",""" & vntAttributesAct(i) & """"
        Next i
        strFormula = strFormula & ")"
        If rObjID.Formula = strFormula Then
          bChangedLocal = False
        Else
          If rObjID.NumberFormat = "@" Then
            rObjID.NumberFormat = "General"
          End If
          rObjID.Formula = strFormula
        End If
      End If
      If bChangedLocal Then
        bChanged = True
      End If
    End If
NextForEachRObjID:
    If Not bMultiSelection Then GoTo ExitForEachRObjID
  Next rObjID
ExitForEachRObjID:
End Sub

Private Sub InvokeCell(ByVal CallType As Long, ByVal rObjIDs As Range, ByRef Names As Variant, ByRef vntData As Variant, ByRef rbProtectWS As Boolean, ByRef bChanged As Boolean)
  Dim nFound As Long
  Dim nCol As Long
  Dim vntkey As Variant
  Dim vntProperty As Variant
  Dim bFound As Boolean
  Dim vntValue As Variant
  Dim nIndexName As Long
  Dim bArray As Boolean
  Dim rObjID As Range
  Dim bMultiSelection As Boolean
  Dim xOffset As Long, yOffset As Long
  Dim nLevelAct As Long
  Dim rCell As Range
  Dim bExternalCell As Boolean 'true, falls Zelle ausserhalb dieses Reports (Strukturblatt)
  If m_collNameToIndex Is Nothing Then
    InitNamesMap
  End If
  bArray = IsArray(Names)
  bMultiSelection = (rObjIDs.count > 1)
  If Not bMultiSelection Then
    Set rObjID = rObjIDs
    GoTo EnterNoForEachRObjID
  End If
  For Each rObjID In rObjIDs
EnterNoForEachRObjID:
    If Not bArray Then
      vntProperty = Names
      GoTo EnterNoArray
    End If
    nIndexName = 0
    For Each vntProperty In Names
EnterNoArray:
      bFound = False
      If m_arColInfos(vntProperty).StgType = EnStgType_Cell Then
        If rObjID Is Nothing Then
          If m_arColInfos(vntProperty).Level <> NLevel_Static Then
            Err.Raise E_NOTIMPL
          End If
          Set rCell = TopLeft
          xOffset = 0
          If m_arColInfos(vntProperty).Left >= 0 Then
            xOffset = xOffset + m_arColInfos(vntProperty).Left
            bFound = True
          End If
        Else
          Set rCell = rObjID
          xOffset = rCell.Column
          If m_arColInfos(vntProperty).Level <> NLevel_Static And (m_arColInfos(vntProperty).Level = NLevel_Max Or m_arColInfos(vntProperty).Level = m_nCountYKeyLevels - 1 Or m_arColInfos(vntProperty).Level = m_nColIndexAddDetails) Then
            If xOffset >= NColAddDetailsFirst And m_arColInfos(vntProperty).Level <> NLevel_Static Then
              If m_arColInfos(vntProperty).Level = m_nColIndexAddDetails Then
                Set rCell = RangeMulti_Item(m_arColInfos(vntProperty).rMap_Keys_BrowseSet, xOffset - NColAddDetailsFirst)
                xOffset = 0
                bFound = True
              ElseIf m_arColInfos(vntProperty).Left = NColActValue - 1 Then
                xOffset = 0
                bFound = True
              Else
                GoTo StdCell
              End If
            Else
StdCell:
              xOffset = xOffset - 1
              If m_arColInfos(vntProperty).Left >= 0 Then
                xOffset = m_arColInfos(vntProperty).Left - xOffset
                bFound = True
              End If
            End If
          ElseIf m_arColInfos(vntProperty).Left >= 0 Then
            If m_arColInfos(vntProperty).Level = NLevel_Static Then
              Set rCell = TopLeft
              xOffset = 0
              bFound = True
            Else
              If m_nColIndexAddDetails >= 0 And xOffset >= NColAddDetailsFirst Then
                Set rCell = rCell.Offset(0, NColObjID - xOffset)
                xOffset = NColObjID - 1
              End If
              Do
                nLevelAct = KeyLevelImpl(rCell)
                If m_arColInfos(vntProperty).Level > nLevelAct Then
                  Err.Raise E_NOTIMPL
                End If
                If m_arColInfos(vntProperty).Level = nLevelAct Then
                  bFound = True
                  xOffset = rCell.Column - 1
                  Exit Do
                End If
                Set rCell = rCell.Offset(-1, 0)
              Loop
            End If
            If bFound Then
              xOffset = m_arColInfos(vntProperty).Left - xOffset
            End If
          End If
        End If
        If bFound Then
          If m_arColInfos(vntProperty).Top >= 0 Then
            yOffset = m_arColInfos(vntProperty).Top
            bFound = True
          Else
            yOffset = 0
          End If
        End If
        If bFound Then
          If xOffset <> 0 Or yOffset <> 0 Then
            Set rCell = rCell.Offset(yOffset, xOffset)
          End If
        End If


        bExternalCell = False

        If Not bFound Then
          'spezielle Singleton Zelle |fffd|ber oType definiert
          If m_arColInfos(vntProperty).Level = NLevel_Static And Not m_arColInfos(vntProperty).oType Is Nothing Then
            If TypeOf m_arColInfos(vntProperty).oType Is Range Then
              Set rCell = m_arColInfos(vntProperty).oType
              bFound = True
              If Not rCell.Worksheet Is m_worksheet Then
                bExternalCell = True
              End If
            End If
          End If
        End If
        
        If (CallType And VbGet) <> 0 Then
          If bFound Then
            vntValue = rCell.Value
          Else
            vntValue = Empty
          End If
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          If bMultiSelection Then
            If bArray Then
              If IsEmpty(vntData(nIndexName)) Then
                vntData(nIndexName) = vntValue
              ElseIf Not IsArray(vntData(nIndexName)) Then
                If vntValue <> vntData(nIndexName) Then
                  vntData(nIndexName) = Array(vntData(nIndexName), vntValue)
                End If
              End If
            Else
              If IsEmpty(vntData) Then
                vntData = vntValue
              ElseIf Not IsArray(vntData) Then
                If vntValue <> vntData Then
                  vntData = Array(vntData, vntValue)
                End If
              End If
            End If
          Else
            If bArray Then
              vntData(nIndexName) = vntValue
            Else
              vntData = vntValue
            End If
          End If
        ElseIf (CallType And VbLet) <> 0 Then
          If Not bFound Then
            Err.Raise E_NOTIMPL
          End If
          If bArray Then
            vntValue = vntData(nIndexName)
          Else
            vntValue = vntData
          End If
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          If rCell.Value <> vntValue Then
            If Not rbProtectWS And Not bExternalCell Then
              If m_worksheet.ProtectContents Then
                Unprotect
                rbProtectWS = True
              End If
            End If
            rCell.Value = vntValue
          End If
        Else
          If Not bFound Then
            Err.Raise E_NOTIMPL
          End If
          If bMultiSelection Then
            If bArray Then
              If IsEmpty(vntData(nIndexName)) Then
                Set vntData(nIndexName) = rCell
              ElseIf IsObject(vntData(nIndexName)) Then
                Set vntData(nIndexName) = Union(vntData(nIndexName), rCell)
              End If
            Else
              If IsEmpty(vntData) Then
                Set vntData = rCell
              ElseIf IsObject(vntData) Then
                Set vntData = Union(vntData, rCell)
              End If
            End If
          Else
            If bArray Then
              Set vntData(nIndexName) = rCell
            Else
              Set vntData = rCell
            End If
          End If
        End If
      End If
      If Not bArray Then GoTo ExitFor
      nIndexName = nIndexName + 1
    Next vntProperty
ExitFor:
NextForEachRObjID:
    If Not bMultiSelection Then GoTo ExitForEachRObjID
  Next rObjID
ExitForEachRObjID:
End Sub

Private Sub InvokeCommentAttributes(ByVal CallType As Long, ByVal rObjIDs As Range, ByRef Names As Variant, ByRef vntData As Variant, ByRef rbProtectWS As Boolean, ByRef bChanged As Boolean)
  Dim strText As String
  Dim arSplit As Variant
  Dim vntLine As Variant
  Dim nFound As Long
  Dim nCol As Long
  Dim nIndexSplit As Long
  Dim vntkey As Variant
  Dim vntProperty As Variant
  Dim bFound As Boolean
  Dim strCommentText As String
  Dim strCommentTextAdd As String
  Dim bChangedLocal As Boolean
  Dim strValue As String
  Dim vntValue As Variant
  Dim nIndexName As Long
  Dim oComment As Comment
  Dim oShape As Excel.Shape
  Dim oDrawingObject As Excel.TextBox
  Dim bArray As Boolean
  Dim rObjID As Range
  Dim bMultiSelection As Boolean
  Dim nIndexCommentValueProp As Long
  Dim bCommentValueProp As Boolean
  If m_collNameToIndex Is Nothing Then
    InitNamesMap
  End If
  bArray = IsArray(Names)
  bMultiSelection = (rObjIDs.count > 1)
  If Not bMultiSelection Then
    Set rObjID = rObjIDs
    GoTo EnterNoForEachRObjID
  End If
  For Each rObjID In rObjIDs
EnterNoForEachRObjID:
    bChangedLocal = False
    strCommentTextAdd = ""
    strCommentText = ""
    arSplit = Empty
    Set oComment = rObjID.Comment
    If Not oComment Is Nothing Then
      strCommentText = oComment.text
      arSplit = Split(strCommentText, vbLf)
    End If
    If Not bArray Then
      vntProperty = Names
      GoTo EnterNoArray
    End If
    nIndexName = 0
    For Each vntProperty In Names
EnterNoArray:
      bFound = False
      If m_arColInfos(vntProperty).StgType = EnStgType_CellComment Then
        nIndexSplit = 0
        bCommentValueProp = (m_arColInfos(vntProperty).Name = "BuchgsText")
        If bCommentValueProp Then
          bCommentValueProp = (Me Is m_container.Grid)
        End If
        If IsArray(arSplit) Then
          nIndexCommentValueProp = -1
          For Each vntLine In arSplit
            nFound = InStr(1, vntLine, ":")
            If nFound > 0 Then
              vntkey = UCase(Trim(Left(vntLine, nFound - 1)))
              If vntkey <> "" Then
                nCol = m_collNameToIndex(vntkey)
                If vntProperty = nCol Then
                  bFound = True
                  Exit For
                End If
              End If
            ElseIf nIndexCommentValueProp < 0 Then
              nIndexCommentValueProp = nIndexSplit
            End If
            nIndexSplit = nIndexSplit + 1
          Next vntLine
          If Not bFound And nIndexCommentValueProp >= 0 Then
            If bCommentValueProp Then
              nIndexSplit = nIndexCommentValueProp
              vntLine = arSplit(nIndexCommentValueProp)
              nFound = 0
              bFound = True
            End If
          End If
        End If
        If (CallType And VbGet) <> 0 Then
          If bFound Then
            strValue = Trim$(Mid(vntLine, nFound + 1))
          Else
            strValue = Empty
          End If
          vntValue = strValue
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          If bMultiSelection Then
            If bArray Then
              If IsEmpty(vntData(nIndexName)) Then
                vntData(nIndexName) = vntValue
              ElseIf Not IsArray(vntData(nIndexName)) Then
                If vntValue <> vntData(nIndexName) Then
                  vntData(nIndexName) = Array(vntData(nIndexName), vntValue)
                End If
              End If
            Else
              If IsEmpty(vntData) Then
                vntData = vntValue
              ElseIf Not IsArray(vntData) Then
                If vntValue <> vntData Then
                  vntData = Array(vntData, vntValue)
                End If
              End If
            End If
          Else
            If bArray Then
              vntData(nIndexName) = vntValue
            Else
              vntData = vntValue
            End If
          End If
        ElseIf (CallType And VbLet) <> 0 Then
          bChangedLocal = True
          If bArray Then
            vntValue = vntData(nIndexName)
          Else
            vntValue = vntData
          End If
          TColInfo_ConvertVariant m_arColInfos(vntProperty), vntValue, CallType
          strValue = TColInfo_VntToText(m_arColInfos(vntProperty), vntValue, CallType)
          vntkey = m_arColInfos(vntProperty).Bene3_CommentAttribute
          If vntkey = "" Then
            vntkey = m_arColInfos(vntProperty).Name
          End If
          If bFound Then
            If strValue = "" Then
              arSplit(nIndexSplit) = Empty
            ElseIf bCommentValueProp Then
              arSplit(nIndexSplit) = strValue
            Else
              arSplit(nIndexSplit) = vntkey & ": " & strValue
            End If
          ElseIf strValue <> "" Then
            If strCommentTextAdd <> "" Then
              strCommentTextAdd = strCommentTextAdd & vbLf
            End If
            If bCommentValueProp Then
              strCommentTextAdd = strCommentTextAdd & strValue
            Else
              strCommentTextAdd = strCommentTextAdd & vntkey & ": " & strValue
            End If
          End If
        End If
      End If
      If Not bArray Then GoTo ExitFor
      nIndexName = nIndexName + 1
    Next vntProperty
ExitFor:
    If bChangedLocal Then
      bChanged = True
      strCommentText = ""
      If IsArray(arSplit) Then
        For Each vntLine In arSplit
          If vntLine <> "" Then
            If strCommentText = "" Then
              strCommentText = vntLine
            Else
              strCommentText = strCommentText & vbLf & vntLine
            End If
          End If
        Next vntLine
      End If
      If strCommentText = "" Then
        strCommentText = strCommentTextAdd
      ElseIf strCommentTextAdd <> "" Then
        strCommentText = strCommentText & vbLf & strCommentTextAdd
      End If
      If Not rbProtectWS Then
        If m_worksheet.ProtectContents Then
          Unprotect
          rbProtectWS = True
        End If
      End If
      If oComment Is Nothing Then
        If strCommentText <> "" Then
          Set oComment = rObjID.AddComment(strCommentText)
          Set oShape = oComment.Shape
          Set oDrawingObject = oShape.DrawingObject
          oDrawingObject.Locked = False
          oDrawingObject.LockedText = True
          oDrawingObject.AutoSize = True
          oShape.Placement = xlMove
        End If
      ElseIf strCommentText = "" Then
        oComment.Delete
        Set oComment = Nothing
      Else
        oComment.text strCommentText
        oComment.Shape.DrawingObject.AutoSize = True
      End If
    End If
NextForEachRObjID:
    If Not bMultiSelection Then GoTo ExitForEachRObjID
  Next rObjID
ExitForEachRObjID:
End Sub



Private Sub UpdateLocaleCommentAttributes(ByRef rbProtectWS As Boolean, ByRef bChanged As Boolean)
  Dim arSplit As Variant
  Dim vntLine As Variant
  Dim nFound As Long
  Dim nCol As Long
  Dim vntkey As Variant
  Dim strCommentText As String
  Dim strCommentText_prev As String
  Dim strValue As String
  Dim vntValue As Variant
  Dim nIndexName As Long
  Dim oComment As Comment
  Dim rObjID As Range
  Dim i As Long
  Dim strChar As String
  Dim r As Range
  Dim strDecimalSeparator As String, strThousandsSeparator As String
  Dim strDecimalSeparator_Prev As String, strThousandsSeparator_Prev As String

  Dim rObjIDs As Range
  Dim bUpdateLocale As Boolean
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  nIndexName = 0
  For nCol = 0 To m_nCountColInfos - 1
    If m_arColInfos(nCol).StgType = EnStgType_CellComment Then
      nIndexName = nIndexName + 1
      Exit For
    End If
  Next nCol
  If nIndexName = 0 Then Exit Sub
  On Error Resume Next
  Set rObjIDs = Area.SpecialCells(xlCellTypeComments)
  On Error GoTo 0
  If Not rObjIDs Is Nothing Then
    Set rObjIDs = HitTestRange(NLevel_Max, NLevel_Max, rObjIDs)
  End If
  If rObjIDs Is Nothing Then Exit Sub
  If m_CallContext_LocaleID_temp = 0 Then
    m_CallContext_LocaleID_temp = LocaleID
   m_CallContext_LocaleIDNumberSeparator_temp = m_container.LocaleIDNumberSeparator
   End If
  m_container.getNumberSeparators m_CallContext_LocaleID_temp, strDecimalSeparator, strThousandsSeparator

  If m_collNameToIndex Is Nothing Then
    InitNamesMap
  End If

  
  '|fffd|berpr|fffd|fen, ob Separatoren direkt hinterlegt
  Set r = m_container.DataRange_Find("ThousandsSeparator")
  If Not r Is Nothing Then
    strThousandsSeparator_Prev = r.Value
  End If
  Set r = m_container.DataRange_Find("DecimalSeparator")
  If Not r Is Nothing Then
    strDecimalSeparator_Prev = r.Value
  End If
  
  For Each rObjID In rObjIDs
    Set oComment = rObjID.Comment
    If Not oComment Is Nothing Then
      strCommentText_prev = Trim(oComment.text)
      If strCommentText_prev <> "" Then
        strCommentText = ""
        arSplit = Split(strCommentText_prev, vbLf)
        For Each vntLine In arSplit
          nFound = InStr(1, vntLine, ":")
          If nFound > 0 Then
            vntkey = UCase(Trim(Left(vntLine, nFound - 1)))
            If vntkey = "" Then
              nCol = -1
            Else
              On Error Resume Next
              nCol = m_collNameToIndex(vntkey)
              On Error GoTo 0
              If Err.Number <> 0 Then
                nCol = -1
              End If
            End If
            If nCol >= 0 Then
              strValue = Trim$(Mid(vntLine, nFound + 1))
              vntkey = m_arColInfos(nCol).Bene3_CommentAttribute
              If vntkey = "" Then
                vntkey = m_arColInfos(nCol).Name
              End If
              If m_arColInfos(nCol).VarType = vbCurrency Or m_arColInfos(nCol).VarType = vbSingle Or m_arColInfos(nCol).VarType = vbDouble Then
                If m_arColInfos(nCol).Digits >= 0 Then
                  nFound = -1
                Else
                  nFound = 0
                End If
                For i = Len(strValue) To 1 Step -1
                  strChar = Mid$(strValue, i, 1)
                  If strChar = strDecimalSeparator_Prev Or strChar = strThousandsSeparator_Prev Or strChar = "." Or strChar = "," Or strChar = " " Or Asc(strChar) = 160 Then
                    'bekannt Trennzeichen der Standardsprachen

                    If nFound < 0 Then
                      nFound = i
                      If i = 0 Then
                        strValue = strDecimalSeparator & Mid$(strValue, i + 1)
                      Else
                        strValue = Left$(strValue, i - 1) & strDecimalSeparator & Mid$(strValue, i + 1)
                      End If
                    Else
                      If i = 0 Then
                        strValue = strThousandsSeparator & Mid$(strValue, i + 1)
                      Else
                        strValue = Left$(strValue, i - 1) & strThousandsSeparator & Mid$(strValue, i + 1)
                      End If
                    End If
                  End If
                Next i
              End If
              strValue = vntkey & " : " & strValue
              If strCommentText = "" Then
                strCommentText = strValue
              Else
                strCommentText = strCommentText & vbLf & strValue
              End If
            End If
          End If
        Next vntLine
        If strCommentText <> strCommentText_prev Then
          bChanged = True
          If Not rbProtectWS Then
            If m_worksheet.ProtectContents Then
              Unprotect
              rbProtectWS = True
            End If
          End If
          oComment.text strCommentText
          oComment.Shape.DrawingObject.AutoSize = True
        End If
      End If
    End If
  Next rObjID
End Sub

Private Sub InitNamesMap()
  Dim nCol As Long
  Dim vntkey As Variant
  Dim rType As Range
  Dim r As Range
  Set m_collNameToIndex = New Collection
  For nCol = 0 To m_nCountColInfos - 1
    vntkey = UCase(m_arColInfos(nCol).Name)
    If vntkey <> "" Then
      On Error Resume Next
      m_collNameToIndex.Add nCol, vntkey
      On Error GoTo 0
    End If
  Next nCol
  For nCol = 0 To m_nCountColInfos - 1
    If Not m_arColInfos(nCol).oType Is Nothing Then
      If TypeOf m_arColInfos(nCol).oType Is Range Then
        Set r = m_arColInfos(nCol).oType
        Set r = r.Offset(0, EnDataCols_Language)
        Do While r.Value <> ""
          vntkey = Trim(UCase(r.Offset(0, 3).Value))
          If vntkey <> "" Then
            On Error Resume Next
            m_collNameToIndex.Add nCol, vntkey
            On Error GoTo 0
          End If
          Set r = r.Offset(0, 4)
        Loop
        If m_arColInfos(nCol).StgType = EnStgType_CellComment Then
          m_arColInfos(nCol).Bene3_CommentAttribute = SearchTextByRObjID(m_arColInfos(nCol).oType, 3)
        End If
      End If
    End If
  Next nCol
End Sub

'ww10
'Range der ObjIDs der Aufrisszeilen suchen
'nXLevel/nYLevel gesuchte Aufrissstufe (Default alle)
'Optional k|fffd|nnen Suchzeilen angegeben werden, falls nur Werte in diesem Bereich verwendet werden sollen
'Optional bIncludeInnerYLevels: auch untergeordnete Zeilen mit einbeziehen
'NoSkipMissingLevels = false: optionale Level |fffd|berspringen und als angenommen betrachten
Friend Function HitTestRange(Optional ByVal nXLevel As Long = NLevel_Static, Optional ByVal nYLevel As Long = NLevel_Static, Optional ByVal Selection As Range, Optional bIncludeInnerYLevels As Boolean, Optional RangeLocked As Variant, Optional ByVal NoSkipMissingLevels As Boolean) As Range
  Dim rObjIDs As Range
  Dim rObjID As Range
  Dim rObjIDs_Main_all As Range
  Dim nXLevelAct As Long
  Dim nYLevelAct As Long
  Dim rRowsAll As Range
  Dim rRow As Range
  Dim r As Range
  Dim rTemp2 As Range
  Dim rTemp As Range
  Dim vntLocked As Variant
  Dim bMainDetail As Boolean 'true, falls Hauptaufriss (XLevel = 0)
  Dim rObjIDs_act As Range
  Dim bAddDetailsOptional As Boolean
  Dim i As Long, j As Long
  Dim bFound As Boolean
  
  If nYLevel = NLevel_Max Then
    nYLevel = m_nCountYKeyLevels - 1
  End If
  
  If nXLevel = NLevel_Max Then
    'obersten X Level direkt aufl|fffd|sen, falls m|fffd|glich (bei UKV ist dieser Level dynamisch)
    If m_nColIndexAddDetails >= 0 Then
      If Not TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails)) Then
        nXLevel = 1
      End If
    Else
      nXLevel = 0 'oberster XLevel, falls keine Zusatzaufrisse
    End If
  End If
  
  
  '!!! vereinfachte Implementation
  'besser w|fffd|re es den Code aus ObjIDVector hier unterzubringen
  Set rObjIDs = ObjIDVector
  If Not Selection Is Nothing And Not rObjIDs Is Nothing Then
    Set rObjIDs = Intersect(rObjIDs, Selection.EntireRow)
  End If
  If Not rObjIDs Is Nothing And nYLevel >= 0 Then
        'Aufrissdaten m|fffd|ssen vef|fffd|gbar sein
    If m_nCountColInfos = 0 Then
      ReadDetailInfos
    End If
    
    If m_nColIndexAddDetails >= 0 Then
      bAddDetailsOptional = TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails))
    End If
    

    For Each rObjID In rObjIDs
      If rObjID.Value = "" Then 'Leerzeilen ber|fffd|cksichtigen (im Moment wegen KTOSAL)
        nYLevelAct = -1
      Else
      
        If rObjID.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
          If m_Config.Level0_AllignRight Then '!!!!
            nYLevelAct = 0
          Else
            nYLevelAct = m_nCountYKeyLevels - 1
          End If
        Else
          nYLevelAct = rObjID.IndentLevel
          If m_Config.Level0_AllignRight Then nYLevelAct = nYLevelAct + 1
        End If
      
      End If
      
      'optionale Level |fffd|berspringen und als angenommen betrachten
      If Not NoSkipMissingLevels Then
        i = nYLevelAct
        Do While i < nYLevel
          i = i + 1
          
          If TColInfo_IsOptional(m_arColInfos(i)) Then
            nYLevelAct = i
          Else
            Exit Do
          End If
        Loop
      End If
      
      If nYLevelAct >= 0 Then
        'SperrKriterium ber|fffd|cksichtigen
        If Not IsMissing(RangeLocked) Then
          'Indikator f|fffd|r Sperre ist ActValue
          If RangeLocked <> rObjID.Offset(0, NColActValue - NColObjID).Locked Then
            nYLevelAct = -1 'Sperr Kriterium stimmt nicht
          End If
        End If
      End If
      
      bFound = (nYLevelAct = nYLevel Or (nYLevelAct >= 0 And nYLevel < 0) Or (bIncludeInnerYLevels And nYLevelAct >= nYLevel))
      If Not bFound And Not NoSkipMissingLevels Then
        'spezieller Fall Abfrage, ob Zusatzaufriss leer
        'ggf. allgemeiner
        If nYLevelAct < nYLevel Then
          Set r = rObjID.Offset(1, 0)
          If r.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
            If m_Config.Level0_AllignRight Then '!!!!
              j = 0
            Else
              j = m_nCountYKeyLevels - 1
            End If
          Else
            j = r.IndentLevel
            If m_Config.Level0_AllignRight Then j = j + 1
          End If
            
          bFound = (j <= nYLevelAct)

          If bFound Then
            For i = nYLevelAct + 1 To nYLevel
              If Not TColInfo_IsOptional(m_arColInfos(i)) Then
                bFound = False
                Exit For
              End If
            Next i
          End If
        End If
      End If
      
      'If nYLevelAct = nYLevel Or (nYLevelAct >= 0 And nYLevel < 0) Or (bIncludeInnerYLevels And nYLevelAct >= nYLevel) Then
      If bFound Then
      
        bMainDetail = True 'Default
        If m_nColIndexAddDetails >= 0 And Not Selection Is Nothing Then
        
          nXLevelAct = nXLevel
          If nXLevel = NLevel_Max Then
            'Dynamic hier nur falls UKV
            Debug.Assert TColInfo_IsOptional(m_arColInfos(m_nColIndexAddDetails))
            If m_container.DetailSheet_IsAddDetail(Me, rObjID) Then
              nXLevelAct = 1
            Else
              nXLevelAct = 0
            End If
          End If
        
        
          If nXLevelAct = 1 Then
            bMainDetail = False 'Hauptelement nicht ausw|fffd|hlbar
          Else
            'Bei Zusatzaufriss: Hauptelement nur gew|fffd|hlt, falls mindestens eine Zelle in Hauptteil
            Set rTemp = m_worksheet.Range(rObjID.Offset(0, 1 - NColObjID), rObjID.Offset(0, NColAddDetailsFirst - 1 - NColObjID))
            If Intersect(Selection, rTemp) Is Nothing Then
              bMainDetail = False
            End If
            
          End If
        End If
              
        Set rObjIDs_act = rObjID
        'innere Elemente erg|fffd|nzen, wenn |fffd|bergeordnetes Element selektiert
        If bIncludeInnerYLevels And nYLevelAct < m_nCountYKeyLevels - 1 Then
          Do
            If rObjID.Row = m_nListFieldEndRow - 1 Then Exit Do 'einfache Endebedingung
            Set rObjID = rObjID.Offset(1, 0)
            If rObjID.Value = "" Then
              nYLevelAct = -1
            ElseIf rObjID.HorizontalAlignment <> XlHAlign.xlHAlignLeft Then
              If m_Config.Level0_AllignRight Then '!!!!
                nYLevelAct = 0
              Else
                nYLevelAct = m_nCountYKeyLevels - 1
              End If
            Else
              nYLevelAct = rObjID.IndentLevel
              If m_Config.Level0_AllignRight Then nYLevelAct = nYLevelAct + 1 '!!!!
            End If
            If nYLevelAct > nYLevel Then
              If Not IsMissing(RangeLocked) Then
                'Indikator f|fffd|r Sperre ist ActValue
                If RangeLocked <> rObjID.Offset(0, NColActValue - NColObjID).Locked Then
                  nYLevelAct = -1 'Sperr Kriterium stimmt nicht
                End If
              End If
              If nYLevelAct >= 0 Then
                Set rObjIDs_act = Union(rObjIDs_act, rObjID)
              End If
            Else
              Exit Do
            End If
          Loop
        End If
        
        
        If bMainDetail Then
          If rObjIDs_Main_all Is Nothing Then
            Set rObjIDs_Main_all = rObjIDs_act
          Else
            Set rObjIDs_Main_all = Union(rObjIDs_Main_all, rObjIDs_act)
          End If
        End If
        
      Else
        nYLevelAct = -1 'Zeichen, dass kein Level zutrifft
      End If
      
      
      If m_nColIndexAddDetails >= 0 And nYLevelAct >= 0 And nXLevel <> 0 Then
        'Zeilen f|fffd|r Zusatzaufrisse aufzeichnen
        If bAddDetailsOptional Then
          If Not m_container.DetailSheet_IsAddDetail(Me, rObjID) Then
            nYLevelAct = -1 'kein Zusatzaufriss nach UKV
          End If
        End If
        If nYLevelAct >= 0 Then
          Set rRow = rObjIDs_act.EntireRow
          If rRowsAll Is Nothing Then
            Set rRowsAll = rRow
          Else
            Set rRowsAll = Union(rRowsAll, rRow)
          End If
        End If
        
      End If
      
      
      
    Next rObjID
    Set rObjIDs = rObjIDs_Main_all
  End If
  
  
  'Elemente der Zusatzaufrisse bestimmen
  If Not rRowsAll Is Nothing Then
    If Selection Is Nothing Then
      Set r = rRowsAll
    Else
      Set r = Intersect(rRowsAll, Selection)
    End If
    If Not r Is Nothing Then
      Set r = Intersect(r, m_worksheet.Range(m_worksheet.Columns(NColAddDetailsFirst), m_worksheet.Columns(NColAddDetailsFirst + m_arColInfos(m_nColIndexAddDetails).nCount_Keys_BrowseSet - 1)))
    End If
    If Not IsMissing(RangeLocked) And Not r Is Nothing Then
      'zus|fffd|tzlich: gesperrt Eigenschaft der gesuchten Zellen |fffd|berpr|fffd|fen
      vntLocked = r.Locked
      If Not IsNull(vntLocked) Then
        If vntLocked <> RangeLocked Then
          Set r = Nothing 'keine Zelle stimmt mit Eigenschaft |fffd|berein
        End If
      Else
        'gemischt: alle Zellen einzeln |fffd|berpr|fffd|fen
        Set rTemp2 = Nothing
        For Each rTemp In r
          If rTemp.Locked = RangeLocked Then
            If rTemp2 Is Nothing Then
              Set rTemp2 = rTemp
            Else
              Set rTemp2 = Union(rTemp2, rTemp)
            End If
          End If
        Next rTemp
        Set r = rTemp2
      End If
      
    End If
    If Not r Is Nothing Then
      If rObjIDs Is Nothing Then
        Set rObjIDs = r
      Else
        Set rObjIDs = Union(rObjIDs, r)
      End If
    End If
  End If
  
  
  Set HitTestRange = rObjIDs

  Exit Function
  Resume 'f|fffd|r Info Stack/Log
End Function


Public Sub InvokeRange(ByVal CallType As Long, ByRef Names As Variant, Optional ByRef Data As Variant, Optional ByVal Selection As Range, Optional ByVal bNoHitTest As Boolean)
  Dim vntProperty As Variant
  Dim rObjIDs As Range
  Dim bProtectWS As Boolean
  Dim nError As Long, strError As String, strSource As String
  Dim bChanged As Boolean
  Dim bSaved_Prev As Boolean
  Dim wb As Workbook
  Dim nStgTypeFound As Integer
  Dim bArray As Boolean
  Dim nNameAct As Long
  Dim vntColAct As Variant
  Dim i As Long
  Const DISP_E_UNKNOWNNAME = &H80020006
  On Error GoTo ErrHandler
#If CENTRALBUILD Then
  If m_container.Standalone Then
    If m_ClassName <> "" And m_container.Version >= 9 Then
      If m_ClassName = "KTOSAL" Then
        If m_container.Version >= 12 Then
          This_Decentral.Grid.InvokeRange CallType, Names, Data, Selection
          Exit Sub
        End If
      Else
        This_Decentral.InvokeRange CallType, Names, Data, Selection
        Exit Sub
      End If
      Exit Sub
    End If
  End If
#End If
  nNameAct = -1
  bSaved_Prev = False
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  If m_collCellAttributes Is Nothing Then
    LoadCellAttributes
  End If
  bArray = IsArray(Names)
  If Not bArray Then
    vntColAct = Names
    nNameAct = 0
    GoTo NamesNoArrayEntry
  End If
  For nNameAct = 0 To UBound(Names)
    vntColAct = Names(nNameAct)
NamesNoArrayEntry:
    If VarType(vntColAct) = vbString Then
      If m_collNameToIndex Is Nothing Then
        InitNamesMap
      End If
      On Error Resume Next
      vntColAct = m_collNameToIndex(UCase(vntColAct))
      nError = Err.Number
      On Error GoTo ErrHandler
      If nError <> 0 Then
        nError = DISP_E_UNKNOWNNAME
        If bArray And ((CallType And CallTypeEx_ReturnError) <> 0 Or (CallType And CallTypeEx_IgnoreError) <> 0) Then
          If (CallType And CallTypeEx_ReturnError) <> 0 Then
            If IsArray(Data) Then
              Data(nNameAct) = CVErrEx(nError)
            End If
            Names(nNameAct) = CVErrEx(nError)
          End If
        Else
          GoTo Cleanup
        End If
      ElseIf bArray Then
        Names(nNameAct) = vntColAct
      Else
        Names = vntColAct
      End If
    End If
    If Not bArray Then
      GoTo NamesNoArrayExit
    End If
  Next nNameAct
NamesNoArrayExit:
  nNameAct = -1
  If (CallType And &HF) = 0 Then
    If IsMissing(Data) Then
      GoTo Cleanup
    End If
  End If
  If Selection Is Nothing Then
    If m_nListFieldSelectedLevel < 0 Then Err.Raise ERR_INVALIDARG
    Set rObjIDs = TopLeftSelected
    If Not rObjIDs Is Nothing Then
      If rObjIDs.Column = 1 Then
        Set rObjIDs = rObjIDs.Offset(0, NColObjID - 1)
      End If
    End If
  ElseIf bNoHitTest Then
    Set rObjIDs = Selection
  Else
    Set rObjIDs = HitTestRange(nXLevel:=NLevel_Max, nYLevel:=NLevel_Max, Selection:=Selection)
  End If
  If rObjIDs Is Nothing Then
    nError = E_NOTIMPL
  Else
    If (CallType And VbLet) <> 0 Then
      Set wb = rObjIDs.Worksheet.Parent
      bSaved_Prev = wb.Saved
    End If
    If bArray Then
      For Each vntProperty In Names
        nStgTypeFound = nStgTypeFound Or m_arColInfos(vntProperty).StgType
      Next vntProperty
    Else
      nStgTypeFound = nStgTypeFound Or m_arColInfos(Names).StgType
    End If
    If (nStgTypeFound And EnStgType_Bound) <> 0 Then
      InvokeBound CallType, rObjIDs, Names, Data, bProtectWS, bChanged, bNoInternalStates:=True
    End If
    If (nStgTypeFound And EnStgType_Cell) <> 0 Then
      InvokeCell CallType, rObjIDs, Names, Data, bProtectWS, bChanged
    End If
    If (nStgTypeFound And EnStgType_CellComment) <> 0 Then
      InvokeCommentAttributes CallType, rObjIDs, Names, Data, bProtectWS, bChanged
    End If
    If (nStgTypeFound And EnStgType_CellAttribute) <> 0 Then
      InvokeCellAttributes CallType, rObjIDs, Names, Data, bProtectWS, bChanged
    End If
  End If
Cleanup:
  If bProtectWS Then
    Protect
    bProtectWS = False
  End If
  m_CallContext_LocaleID_temp = 0
  m_CallContext_LocaleIDNumberSeparator_temp = 0
  If bSaved_Prev And Not bChanged Then
    If Not wb Is Nothing Then
      If Not wb.Saved Then
        wb.Saved = True
      End If
    End If
  End If
  If nError <> 0 Then
    If (CallType And CallTypeEx_IgnoreError) <> 0 Then
    ElseIf (CallType And CallTypeEx_ReturnError) <> 0 Then
      If Not IsMissing(Data) Then
        If nNameAct < 0 Then
          If bArray And IsArray(Data) Then
            For i = 0 To UBound(Names)
              Data(i) = CVErrEx(nError)
            Next i
          Else
            Data = CVErrEx(nError)
          End If
        Else
          If bArray Then
            If IsArray(Data) Then
              Data(nNameAct) = CVErrEx(nError)
            End If
          Else
            Data = CVErrEx(nError)
          End If
        End If
      End If
    Else
      On Error GoTo 0
      If strError <> "" Then
        Err.Raise nError, strSource, strError
      Else
        Err.Raise nError
      End If
    End If
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
  Resume
End Sub

Public Property Get Valid() As Boolean
  On Error GoTo ErrHandler
  If m_worksheet Is Nothing Then
  ElseIf Not m_worksheet.Visible Then
  Else
    Valid = True
  End If
  Exit Property
ErrHandler:
  Set m_worksheet = Nothing
  m_nCountColInfos = 0
  m_nColIndexAddDetails = -1
  m_nCountYKeyLevels = 0
  m_nListFieldEndRow = -1
End Property

Public Sub Clear()
  Set m_worksheet = Nothing
  Set m_container = Nothing
End Sub

Public Sub Init(ByVal ws As Excel.Worksheet, ByVal Parent As CSaldenEditor, ByVal className As String)
  Set m_worksheet = ws
  Set m_container = Parent
  m_ClassName = className
  m_bListFieldSelectedInsert = False
  m_nListFieldSelectedLevel = -1
End Sub

Public Sub AdjustDetails()
#If CENTRALBUILD Then
  AdjustDetails__Central
#Else
  AdjustDetails__Decentral
#End If
End Sub

#If Win64 Then
Public Property Get ColInfosPtr() As LongPtr
  Dim pTemp As LongPtr
#Else
Public Property Get ColInfosPtr() As Long
  Dim pTemp As Long
#End If
  If m_nCountColInfos = 0 Then
    ReadDetailInfos
  End If
  pTemp = ArrayPtr(m_arColInfos)
  CopyMemory VarPtr(ColInfosPtr), pTemp, 4
End Property

Public Property Get className() As String
  className = m_ClassName
End Property

'Typename z.b. ANLBEW oder SPIBEW
Public Property Get TypeName() As String
  Dim i As Long
  
  'ggf. ObjID von Klassennamen entfernen
  i = InStr(1, m_ClassName, "_")
  If i > 0 Then
    TypeName = Left$(m_ClassName, i - 1)
  Else
    TypeName = m_ClassName
  End If
End Property

'Spiegel / ObjID hier Detail-Kennzeichen
'entspricht Eigenschaft "SPI"
'bei anderem Typ: Ersatzkennzeichen (identisch mit KtoKnz1)
Public Property Get spi() As String
  Dim i As Long
  
  'SPI aus Klassennamen extrahieren
  i = InStr(1, m_ClassName, "_")
  If i > 0 Then
    spi = Mid$(m_ClassName, i + 1)
  Else
    'Default-SPI erstellen
    Select Case m_ClassName
      Case "KSTSAL"
        spi = "C"
      Case "ICKTOSAL"
        spi = "I"
      Case "ICBEW"
        spi = "V"
      Case "ANLBEW"
        spi = "A"
      Case "KAPBEW"
        spi = "K"
      Case "RUEBEW"
        spi = "R"
    End Select
  End If

End Property


'Daten aus Range (Strukturblatte Zeile) lesen
Friend Sub DataRange_read(ByVal rData As Range)
  Dim r As Range

  Debug.Assert rData.Column = 1
  Debug.Assert rData.count = 1

  Set r = rData.Offset(0, EnDataCols_Knz2 + 1)

  'bei Spiegel: Attribut, dass Vorperiode
  m_bSPIBEW_DiffVPeriode = (r.Value <> 0)
End Sub

Private Function FormatLocal(vnt As Variant, ByVal strFormat As String, ByVal lcid As Long) As String
  Dim tokens(0 To 99) As Byte
  Dim nActual As Long
#If CENTRALBUILD Then
  VarTokenizeFormatString strFormat, tokens(0), 100, 0, 0, LCID_ENGLISH, nActual
  VarFormatFromTokens vnt, strFormat, tokens(0), 0, FormatLocal, lcid
#Else
  Dim hr As Long
  Dim strResult As String
  hr = VarTokenizeFormatStringVB(StrPtr(strFormat), tokens(0), 100, 0, 0, LCID_ENGLISH, nActual)
  If hr < 0 Then Err.Raise hr
  hr = VarFormatFromTokensVB(vnt, StrPtr(strFormat), tokens(0), 0, VarPtr(strResult), lcid)
  If hr < 0 Then Err.Raise hr
  FormatLocal = strResult
#End If
End Function

Public Function CVErrEx(ByVal hr As Long) As Variant
#If Win64 Then
  Dim pTemp As LongPtr
#Else
  Dim pTemp As Long
#End If
  Dim vt As Integer
  If (hr And &HFFFF0000) = 0 Then
    hr = hr Or &H800A0000
  End If
  pTemp = VarPtr(CVErrEx)
  vt = vbError
  CopyMemory pTemp, VarPtr(vt), sizeof_Short
  CopyMemory pTemp + 8, VarPtr(hr), sizeof_Long
End Function

Private Sub RoundPatched(ByRef Number As Variant, ByVal NumDigitsAfterDecimal As Long)
  Dim vt As Integer
  Dim i As Long
  Dim bNegative As Boolean
  vt = VarType(Number)
  If vt = vbString Then
    Number = CDbl(Number)
    vt = vbDouble
  End If
  If vt = vbSingle Or vt = vbDouble Then
    If Number < 0 Then
      Number = WorksheetFunction.Round(Number - 0.000000001, NumDigitsAfterDecimal)
    Else
      Number = WorksheetFunction.Round(Number + 0.000000001, NumDigitsAfterDecimal)
    End If
  ElseIf vt = vbCurrency Then
    If NumDigitsAfterDecimal < 4 Then
      Dim cur As Currency
      cur = Number
      If cur < 0 Then
        bNegative = True
        cur = -cur
      End If
      For i = 0 To NumDigitsAfterDecimal - 1
        cur = cur * 10
      Next i
        cur = Int(cur + 0.5)
      For i = 0 To NumDigitsAfterDecimal - 1
        cur = cur / 10
      Next i
      If bNegative Then
        Number = -cur
      Else
        Number = cur
      End If
    End If
  End If
End Sub

Private Sub TColInfo_CreateErrorText(colInfo As TColInfo, ByRef nError As Long, ByRef errText As String, Optional vntValue As Variant)
   On Error GoTo ErrHandler
   Dim nIDLError As Long
  If nError = 13 Or nError = 5 Or nError = &H80020005 Or nError = &H800A0005 Then
    If IsMissing(vntValue) Then
      nIDLError = EnCheckErrorInvalidType
    Else
      nIDLError = EnCheckErrorInvalidValue
    End If
    nError = IDL_ERROR_BASE Or nIDLError
  ElseIf (nError And &HFFFF0000) = IDL_ERROR_BASE Then
    CopyMemory VarPtr(nIDLError), VarPtr(nError), 2
  End If
  If nIDLError = 0 Then
    If errText = "" Then
      Err.Raise nError
    Else
      Exit Sub
    End If
  End If
      Dim strLabelName As String
      Dim strValue As String
        If Not colInfo.oType Is Nothing Then
          If TypeOf colInfo.oType Is Range Then
            strLabelName = SearchTextByRObjID(colInfo.oType, 3)
          End If
        End If
        If strLabelName = "" Then
          strLabelName = colInfo.Name
        End If
        If Not IsMissing(vntValue) Then
          If VarType(vntValue) = vbString Then
            strValue = vntValue
          Else
            strValue = TColInfo_VntToText(colInfo, vntValue, CallTypeEx:=CallTypeEx_IgnoreError)
          End If
        End If
        errText = SearchTextInSPR(nIDLError)
        errText = FormatStr(errText, strLabelName, colInfo.Length, , strValue)
   Exit Sub
ErrHandler:
   errText = Err.Description
   nError = Err.Number
End Sub

Private Sub TColInfo_Check(colInfo As TColInfo, ByRef vnt As Variant, ByRef vntResult As Variant, Optional ByVal CallType As Integer = 0, Optional ByVal oValue As Object)
    Dim BrowseFlags As Long
    Dim vntAct As Variant
    Dim vtAct As Integer
    Dim bFound As Boolean
    Dim bHasCheckableValue As Boolean
    Dim bNoWildcardsOnFunctionalField As Boolean
    Dim fieldType As Integer
    Dim bAlways As Boolean
    Dim nFunctional As Long
    Dim oTemp As Object
    Dim hr As Long, strError As String, strSource As String
    On Error GoTo ErrHandler
        bHasCheckableValue = False
        BrowseFlags = colInfo.BrowseFlags
        bAlways = ((BrowseFlags And EnBrowseFlagsNull) = 0) And ((BrowseFlags And EnBrowseFlagsNullable) = 0)
        If bAlways Then
          If (colInfo.uml_ex And EnUmlEx_OPTIONAL) <> 0 Then
            bAlways = False
          End If
        End If
        nFunctional = BrowseFlags And EnBrowseFlagsFunctional_Mask
        With colInfo
          fieldType = .VarType
          If fieldType = vbEmpty And ((BrowseFlags And EnBrowseFlagsNull) <> 0) Then
            vntAct = Empty
          Else
            vntAct = vnt
            vtAct = VarType(vntAct)
            If vtAct = vbObject Then
                vntAct = vntAct
                vtAct = VarType(vntAct)
            End If
          End If
          If vtAct = vbError Then
            hr = EnCheckErrorInvalidRef
            GoTo HRESULT_FAILED
          ElseIf (vtAct And vbArray) <> 0 Then
            vntResult = True
            Exit Sub
          End If
          If fieldType = vbString Then
            Dim strAct As String
            If vtAct = vbNull Then
              strAct = "*"
            ElseIf vtAct <> vbString Then
              strAct = CStr(vntAct)
            Else
              strAct = vntAct
            End If
            If bAlways And strAct = "" Then
                hr = IDL_ERROR_BASE Or EnCheckErrorMissingValue
                GoTo HRESULT_FAILED
            ElseIf bAlways And strAct = "*" Then
                hr = IDL_ERROR_BASE Or EnCheckErrorInvalidNull
                GoTo HRESULT_FAILED
            End If
            If nFunctional <> EnBrowseFlagsFunctional_NoCheck Then
              bNoWildcardsOnFunctionalField = (nFunctional = EnBrowseFlagsFunctional_CheckBrowseSet Or nFunctional = EnBrowseFlagsFunctional_NoWildcards)
              If ((CallType And VbLet) <> 0 And ((BrowseFlags And EnBrowseFlagsNull) = 0)) Or bNoWildcardsOnFunctionalField Then
                If (InStr(1, strAct, "_") > 0 And Not bNoWildcardsOnFunctionalField) Or InStr(1, strAct, "%") > 0 Or (InStr(1, strAct, "*") > 0 And (CallType And VbLet) = 0) Then
                   If bNoWildcardsOnFunctionalField Then
                     hr = IDL_ERROR_BASE Or EnCheckErrorFunctionalWildcards
                   Else
                     hr = IDL_ERROR_BASE Or EnCheckErrorExportWildcards
                   End If
                   Exit Sub
                End If
              End If
            End If
            If .Length > 0 Then
              If Len(strAct) > .Length Then
                hr = IDL_ERROR_BASE Or EnCheckErrorExceedsLen
                GoTo HRESULT_FAILED
              End If
            End If
            bHasCheckableValue = ((strAct <> "") And ((BrowseFlags And EnBrowseFlagsNull) = 0))
          ElseIf vtAct = vbNull Then
            If bAlways Then
              hr = IDL_ERROR_BASE Or EnCheckErrorInvalidNull
              GoTo HRESULT_FAILED
            End If
          ElseIf Trim$(vntAct) = "" Then
            If bAlways Then
              If fieldType = vbString Or (CallType And VbLet) <> 0 Then
                hr = IDL_ERROR_BASE Or EnCheckErrorMissingValue
                GoTo HRESULT_FAILED
              End If
            End If
          ElseIf ((BrowseFlags And EnBrowseFlagsNull) = 0) And vtAct <> fieldType And fieldType <> vbEmpty Then
            TColInfo_ConvertVariant colInfo, vntAct
            bHasCheckableValue = (BrowseFlags And EnBrowseFlagsNull = 0)
          End If
        End With
        If bHasCheckableValue And nFunctional = EnBrowseFlagsFunctional_CheckBrowseSet Then
          If (BrowseFlags And EnBrowseFlags_BrowseSet) <> 0 Then
            Dim collBrowse As Object
             Set collBrowse = PropertiesBrowseset(oValue, colInfo.Name)
             If Not collBrowse Is Nothing Then
                Set oTemp = IDLVLookup(collBrowse, vntAct)
                If Not oTemp Is Nothing Then
                  bFound = True
                End If
             End If
          Else
            bFound = True
          End If
          If Not bFound Then
            hr = IDL_ERROR_BASE Or EnCheckErrorInvalidValue
            GoTo HRESULT_FAILED
          End If
        End If
  vntResult = True
  Exit Sub
ErrHandler:
  If (CallType And CallTypeEx_IgnoreError) = 0 And (CallType And CallTypeEx_ReturnError) = 0 Then
    GoTo HRESULT_FAILED
  End If
  hr = Err.Number
  strSource = Err.Source
  strError = Err.Description
  TColInfo_CreateErrorText colInfo, hr, strError, vnt
  Err.Raise hr, strSource, strError
  Exit Sub
HRESULT_FAILED:
  If (CallType And CallTypeEx_IgnoreError) <> 0 Then
    vntResult = True
  ElseIf (CallType And CallTypeEx_ReturnError) <> 0 Then
    vntResult = CVErrEx(hr)
  Else
    TColInfo_CreateErrorText colInfo, hr, strError, vnt
    Err.Raise hr, , strError
    Resume
  End If
End Sub



'aus Common.TextToVnt
'eingeschr|fffd|nkte Funktionalit|fffd|t
'Implementation f|fffd|r Steuerelement, gem|fffd|ss Sprache und Typ: Wert einer Variant als Text formatieren
 Private Sub TColInfo_TextToVnt(colInfo As TColInfo, ByVal strText As String, ByRef vnt As Variant, Optional ByVal vt As Integer = vbEmpty, Optional ByVal CallTypeEx As Integer = 0)
     'Deklaration angegeben: nach dieser formatieren
     'Sprache f|fffd|r Datentypen via LocaleID
  Dim vntText As Variant
  Dim bHandled As Boolean
'  Dim oPropDef As CPropDef
  Dim nDigits As Long
  Dim iFound As Long, iFound_prev As Long
  Dim strSeparator As String
  Dim nCount As Long
  Dim hr As Long
  Dim nLCIDTemp As Long
'  Dim vntResult() As Variant

  On Error GoTo ErrHandler
  
'     'Array: Alle Elemente auflisten
'  strSeparator = IIf(OnlineLanguageIndex = 1, ";", ",")
'
'  iFound = InStr(1, strText, strSeparator)
'  If iFound > 0 Then
'    iFound_prev = 0
'    Do
'      ReDim Preserve vntResult(nCount)
'      If iFound > 0 Then
'        TextToVnt Mid$(strText, iFound_prev + 1, iFound - iFound_prev - 1), vntResult(nCount), PropDef, vt
'      Else
'        TextToVnt Mid$(strText, iFound_prev + 1), vntResult(nCount), PropDef, vt
'        Exit Do
'      End If
'      iFound_prev = iFound
'      iFound = InStr(iFound + 1, strText, strSeparator)
'      nCount = nCount + 1
'    Loop
'    vnt = vntResult
'    Exit Sub
'  End If
'
'  If Not IsMissing(PropDef) Then
'    If IsObject(PropDef) Then
'       Set oPropDef = PropDef
'       vt = oPropDef.TYP
'    ElseIf IsNumeric(PropDef) Then
'       If PropDef >= 0 Then
'         Set oPropDef = ConnRes.propDefs(PropDef)
'         vt = oPropDef.TYP
'       End If
'    End If
'  End If
    
    vt = colInfo.VarType
   
   
    If vt <> vbEmpty And vt <> vbString Then
      strText = Trim$(strText) 'Zieltyp nicht Text: vor/nachlaufende Leerzeichen geh|fffd|ren nicht zur Information
      If strText = "%" Then
        vnt = Empty 'Test !!!! um Probleme mit Laden von Ini zu verhindern, aber Problem mit Zellen, wenn % drinsteht
      ElseIf strText = "" Then
        vnt = Empty
      ElseIf strText = "*" Then
        vnt = Null
'      ElseIf vt = vbDate Then
'        HandleConvertTextToDate strText, vnt, oPropDef
      Else
       vntText = strText
       If m_CallContext_LocaleID_temp = 0 Then
         m_CallContext_LocaleID_temp = m_container.LocaleID
         m_CallContext_LocaleIDNumberSeparator_temp = m_container.LocaleIDNumberSeparator
       End If
       If vt = vbLong Or vt = vbInteger Then
         'bei Ganzzahl zuerst nach double, damit richtig gerundet wird
         nLCIDTemp = m_CallContext_LocaleIDNumberSeparator_temp
         If nLCIDTemp = 0 Then
            'spezieller Konvertierpatch, falls Trennzeichen von Excel
            TColInfo_PatchNumberSeparatorsToEnglish vntText
            nLCIDTemp = LCID_ENGLISH
         End If
         hr = VariantChangeTypeExVB(vnt, vntText, nLCIDTemp, 0, vbDouble)
         If hr < 0 Then GoTo HRESULT_FAILED
         RoundPatched vnt, 0
       Else
         nLCIDTemp = m_CallContext_LocaleIDNumberSeparator_temp
         If nLCIDTemp = 0 And (vt = vbDouble Or vt = vbCurrency) Then
            'spezieller Konvertierpatch, falls Trennzeichen von Excel
            TColInfo_PatchNumberSeparatorsToEnglish vntText
            nLCIDTemp = LCID_ENGLISH
         End If
         hr = VariantChangeTypeExVB(vnt, vntText, nLCIDTemp, 0, vt)
         If hr < 0 Then GoTo HRESULT_FAILED
        'If vt = vbDouble Or vt = vbCurrency And Not oPropDef Is Nothing Then
        If vt = vbDouble Or vt = vbCurrency Then
          nDigits = colInfo.Digits
          If nDigits >= 0 Then
            'auf vorgegebene Stellenzahl runden, falls erforderlich
            RoundPatched vnt, nDigits
          End If
        End If
       End If
       
       
       
      End If
      bHandled = True
    End If
   
   If Not bHandled Then
     vnt = strText
   End If
   Exit Sub
   
ErrHandler:
  If (CallTypeEx And CallTypeEx_IgnoreError) = 0 And (CallTypeEx And CallTypeEx_ReturnError) = 0 Then
    GoTo HRESULT_FAILED
  End If
  Err.Raise Err.Number, Err.Source, Err.Description
  Exit Sub
  
HRESULT_FAILED:
  If (CallTypeEx And CallTypeEx_IgnoreError) <> 0 Then
    vnt = Empty
  ElseIf (CallTypeEx And CallTypeEx_ReturnError) <> 0 Then
    vnt = CVErrEx(hr)
  Else
    Err.Raise hr
    Resume
  End If
   
   
 End Sub
 
 'spezieller Konvertierpatch, falls Trennzeichen von Excel
 Private Sub TColInfo_PatchNumberSeparatorsToEnglish(vntText As Variant)
  Dim strDecimalSeparator As String, strThousandsSeparator As String
  m_container.getNumberSeparators 0, strDecimalSeparator, strThousandsSeparator
  vntText = Replace(vntText, strDecimalSeparator, "@")
  vntText = Replace(vntText, strThousandsSeparator, "|fffd|")
  vntText = Replace(vntText, "@", ".")
  vntText = Replace(vntText, "|fffd|", ",")

 End Sub
 'spezieller Konvertierpatch, falls Trennzeichen von Excel
 Private Sub TColInfo_PatchNumberSeparatorsFromEnglish(vntText As Variant)
  Dim strDecimalSeparator As String, strThousandsSeparator As String
  m_container.getNumberSeparators 0, strDecimalSeparator, strThousandsSeparator
  vntText = Replace(vntText, ".", "@")
  vntText = Replace(vntText, ",", "|fffd|")
  vntText = Replace(vntText, "@", strDecimalSeparator)
  vntText = Replace(vntText, "|fffd|", strThousandsSeparator)

 End Sub


  'Implementation f|fffd|r Konvertierung auf propdef Basis, gem|fffd|ss Sprache und Typ: Wert einer Variant als Text formatieren
 'bIgnoreErrors True: falls Konvertierung nicht m|fffd|glich, Ausgabe als String (f|fffd|r Editierzwecke)
 'Sprache f|fffd|r Datentypen im Moment via. Systemsteuerung (User-Default)
 'Text ist so beschaffen, dass er r|fffd|ckkonvertiert werden kann (editierbar)
 'falls bExcelConvention = True, so werden diejenigen einfachen Datentypen (long etc.) belassen, die von Excel direkt unterst|fffd|tzt werden
Private Function TColInfo_VntToText(colInfo As TColInfo, ByRef vnt As Variant, Optional ByVal CallTypeEx As Integer = 0, Optional ByVal bExcelConvention As Boolean = False) As String
   Dim strText As Variant
   Dim vntVal As Variant
   Dim vtVal As Integer  'vbVarType 'wegen Office97
   Dim vntTemp As Variant
   Dim bFirst As Boolean
   Dim hr As Long
   Dim vt As Integer 'VbVarType
   Dim bPatchSeparator As Boolean
   Dim nLCIDTemp As Long
   Dim strFormat As String
   
   On Error GoTo ConvErrHandler
   'Dim oPropDef As CPropDef
   'Dim strSeparator As String
   
   
  
   vntVal = vnt 'Value Property ausf|fffd|hren (damit kein Objekt)
   vtVal = VarType(vntVal)
   If vtVal = vbObject Then
'     If TypeOf vntVal Is CError Then
'       TColInfo_VntToText = vntVal.errText
'       Exit Function
'     Else
       vntVal = vntVal
       vtVal = VarType(vntVal)
       
       If vtVal = vbObject Then
'         If TypeOf vntVal Is CError Then
'           TColInfo_VntToText = vntVal.errText
'           Exit Function
'         Else
           vntVal = vntVal
           vtVal = VarType(vntVal)
'           If TypeOf vntVal Is CError Then
'             TColInfo_VntToText = vntVal.errText
'             Exit Function
'           End If
'         End If
       End If
'     End If
   End If
'   If (vtVal And vbArray) <> 0 Then
'     'Array: Alle Elemente auflisten
'     strSeparator = IIf(OnlineLanguageIndex = 1, ";", ",")
'     bFirst = True
'     For Each vntTemp In vntVal
'
'        If bFirst Then
'          bFirst = False
'        Else
'          strText = strText & strSeparator
'          bFirst = False
'        End If
'        strText = strText & TColInfo_VntToText(colInfo, vntTemp, bIgnoreErrors, bExcelConvention, nBrowseFlags, vt)
'
'     Next vntTemp
'     TColInfo_VntToText = strText
'     Exit Function
'   End If
   
'  If Not IsMissing(PropDef) Then
'    If IsObject(PropDef) Then
'       Set oPropDef = PropDef
'       If Not oPropDef Is Nothing Then
'         vt = oPropDef.TYP
'       End If
'    ElseIf IsNumeric(PropDef) Then
'       If PropDef >= 0 Then
'         Set oPropDef = ConnRes.propDefs(PropDef)
'         vt = oPropDef.TYP
'       End If
'    End If
'  End If

   vt = colInfo.VarType

   
   
'   If Not oPropDef Is Nothing Or vt <> vbEmpty Then 'Deklaration angegeben: nach dieser formatieren
   If vt <> vbEmpty Then 'Deklaration angegeben: nach dieser formatieren
     Dim strTrimmed As String
     If vt = vbString Then
       If vtVal = vbNull Then
          strText = "*"
       Else
          If vtVal <> vbString Then
            If vtVal = vbError Then
              vntVal = CStr(vntVal)
            Else
              If m_CallContext_LocaleID_temp = 0 Then
                m_CallContext_LocaleID_temp = m_container.LocaleID
                m_CallContext_LocaleIDNumberSeparator_temp = m_container.LocaleIDNumberSeparator
              End If

              If (vtVal = vbLong Or vtVal = vbInteger Or vtVal = vbDouble Or vtVal = vbCurrency) Then
              
                If m_CallContext_LocaleIDNumberSeparator_temp = 0 Then
                  'speziell f|fffd|r Office Trennzeichen
                  hr = VariantChangeTypeExVB(vntVal, vntVal, LCID_ENGLISH, 0, vbString)
                  If hr < 0 Then GoTo HRESULT_FAILED
                  TColInfo_PatchNumberSeparatorsFromEnglish vntVal
                Else
                  hr = VariantChangeTypeExVB(vntVal, vntVal, m_CallContext_LocaleIDNumberSeparator_temp, 0, vbString)
                  If hr < 0 Then GoTo HRESULT_FAILED
                End If

              Else
                hr = VariantChangeTypeExVB(vntVal, vntVal, m_CallContext_LocaleID_temp, 0, vbString)
                If hr < 0 Then GoTo HRESULT_FAILED
              End If
            End If
            vtVal = vbString
          End If
'          If oPropDef Is Nothing Then
'            strText = vntVal
'          Else
'            If colInfo.Name = "Bene1" Or colInfo.Name = "Bene2" Or colInfo.Name = "Bene3" Or colInfo.Name = "Bene" Then
'              strTrimmed = vntVal
'              '!!!!! Test aus Meta-Def entnehmen
'            ElseIf colInfo.IsCompoundField Then
'              strTrimmed = RTrim$(vntVal)
'            Else
'              strTrimmed = Trim$(vntVal)
'            End If
            If (colInfo.BrowseFlags And EnBrowseFlags_Trim) <> 0 Then
              strTrimmed = Trim$(vntVal) 'Compound Field hier unber|fffd|cksichtigt
            End If
            Select Case colInfo.BrowseFlags And EnBrowseFlags_StringTypeMask
              Case EnBrowseFlags_UCase
                strText = UCase$(strTrimmed)
              Case EnBrowseFlags_LCase
                strText = UCase$(strTrimmed)
            End Select

'            If colInfo.UCase Then
'              strText = UCase$(strTrimmed)
'            Else
'              strText = strTrimmed
'            End If
'          End If
       End If
'     ElseIf vt = vbDate Then
'       'speziell: Datumskonvertierung
'       If vtVal = vbEmpty And (nBrowseFlags And EnBrowseFlagsNullable) = 0 Then
'          'Mussfelder mit Nicht-Stringtypen
'          'bei Empty immer % eintragen
'          strText = "%"
'       ElseIf HandleDateToText(vntVal, PropDef) Then
'         strText = vntVal
'       End If
     ElseIf vt <> vbEmpty And vt <> vbNull Then 'Leer wird nicht weiter gepr|fffd|ft, da dies keine Angabe bedeuted
      If vtVal <> vbEmpty And vtVal <> vbNull Then
        If m_CallContext_LocaleID_temp = 0 Then
          m_CallContext_LocaleID_temp = m_container.LocaleID
          m_CallContext_LocaleIDNumberSeparator_temp = m_container.LocaleIDNumberSeparator
        End If
      
        If vtVal = vbString Then
          vntVal = Trim$(vntVal)
          If vntVal <> "" Then
             hr = VariantChangeTypeExVB(vntTemp, vntVal, m_CallContext_LocaleID_temp, 0, vt)
             If hr < 0 Then GoTo HRESULT_FAILED
             vtVal = vt
          End If
        Else
           If vtVal = vbError Then
             vntTemp = CStr(vntVal)
           Else
             hr = VariantChangeTypeExVB(vntTemp, vntVal, m_CallContext_LocaleID_temp, 0, vt)
             If hr < 0 Then GoTo HRESULT_FAILED
           End If
           vtVal = vt
        End If
'        If Not oPropDef Is Nothing Then
          If Not IsEmpty(vntTemp) And Not bExcelConvention And colInfo.Digits >= 0 Then
             'Nach angegebener Stellenzahl formatieren
             If vt = vbCurrency Or vt = vbDouble Then
               If vt = vbDouble Then
                 strFormat = "#0." & String(colInfo.Digits, "0")
               Else
                 strFormat = "#,##0." & String(colInfo.Digits, "0")
               End If
               nLCIDTemp = m_CallContext_LocaleIDNumberSeparator_temp
               If nLCIDTemp = 0 Then
                 vntTemp = FormatLocal(vntTemp, strFormat, LCID_ENGLISH)
                 TColInfo_PatchNumberSeparatorsFromEnglish vntTemp
                             strText = vntTemp
               Else
                 strText = FormatLocal(vntTemp, strFormat, nLCIDTemp)
               End If

             End If
          End If
'        End If
      Else
        'If vtVal = vbEmpty And (nBrowseFlags And EnBrowseFlagsNullable) = 0 Then
        If vtVal = vbEmpty And Not TColInfo_IsOptional(colInfo) Then
          If (colInfo.BrowseFlags And EnBrowseFlagsFunctional_Mask) = EnBrowseFlagsFunctional_Wildcards Then
            'Mussfelder mit Nicht-Stringtypen
            'bei Empty immer % eintragen
            strText = "%"
          End If
        End If
      End If
     End If
   End If
   
   If IsEmpty(strText) Then
     If vtVal = vbNull Then
       TColInfo_VntToText = "*"
     ElseIf IsObject(vntVal) Then
       If vntVal Is Nothing Then
         TColInfo_VntToText = "*"
'       ElseIf TypeOf vntVal Is CError Then
'         TColInfo_VntToText = vntVal.errText
       Else
         TColInfo_VntToText = VBA.TypeName(vntVal)
       End If
     Else
       'TColInfo_VntToText = CStr(vntVal)
      If m_CallContext_LocaleID_temp = 0 Then
        m_CallContext_LocaleID_temp = m_container.LocaleID
        m_CallContext_LocaleIDNumberSeparator_temp = m_container.LocaleIDNumberSeparator
      End If
       
       hr = VariantChangeTypeExVB(vntVal, vntVal, m_CallContext_LocaleID_temp, 0, vbString)
       TColInfo_VntToText = vntVal
     End If
   Else
     TColInfo_VntToText = strText
   End If
   Exit Function
ConvErrHandler:
   'If bIgnoreErrors Then
  If (CallTypeEx And CallTypeEx_IgnoreError) <> 0 Then
  ElseIf (CallTypeEx And CallTypeEx_ReturnError) <> 0 Then
     If Not IsNull(vnt) Then
       'TColInfo_VntToText = CStr(vnt)
      If IsError(vnt) Then
        vntVal = CStr(vntVal)
      Else
      
        If m_CallContext_LocaleID_temp = 0 Then
          m_CallContext_LocaleID_temp = m_container.LocaleID
          m_CallContext_LocaleIDNumberSeparator_temp = m_container.LocaleIDNumberSeparator
        End If

        VariantChangeTypeExVB vntVal, vnt, m_CallContext_LocaleID_temp, 0, vbString
      End If
       TColInfo_VntToText = vntVal
     End If
   Else
     Err.Raise Err.Number, Err.Source, Err.Description
   End If
   Exit Function
   
HRESULT_FAILED:
  If (CallTypeEx And CallTypeEx_IgnoreError) <> 0 Then
    vnt = Empty
  ElseIf (CallTypeEx And CallTypeEx_ReturnError) <> 0 Then
    vnt = CVErrEx(hr)
  Else
    Err.Raise hr
    Resume
  End If
 End Function



Private Sub TColInfo_ConvertVariant(colInfo As TColInfo, ByRef vnt As Variant, Optional ByVal CallTypeEx As Integer = 0)
  Dim oType As Object
  Dim vtDest As Integer, vtSrc As Integer
  Dim strTemp As String
  Dim nDigits As Long
  Dim i As Long, nCount As Long
  Dim vntTemp As Variant, pVnt As Long, pVntDest As Long
  Dim hr As Long
  On Error GoTo ErrHandler
  vtSrc = VarType(vnt)
  vtDest = colInfo.VarType
  If vtSrc = vbString Then
    If vtDest <> vbString Then
      vnt = Trim$(vnt)
      If vnt = "" Then
        vnt = Empty
      Else
        TColInfo_TextToVnt colInfo, vnt, vnt, CallTypeEx:=CallTypeEx
      End If
    Else
      Select Case colInfo.BrowseFlags And EnBrowseFlags_StringTypeMask
        Case EnBrowseFlags_UCase
          vnt = UCase(vnt)
        Case EnBrowseFlags_LCase
          vnt = LCase(vnt)
      End Select
      If (colInfo.BrowseFlags And EnBrowseFlags_Trim) <> 0 Then
        vnt = Trim(vnt)
      End If
    End If
  ElseIf vtDest = vbString Then
    If vtSrc <> vbString Then
      vnt = TColInfo_VntToText(colInfo, vnt, CallTypeEx)
    End If
  ElseIf vtDest <> vtSrc And vtDest <> vbEmpty And vtSrc <> vbNull And vtSrc <> vbEmpty And vtDest <> vbVariant And vtSrc <> vbError Then
    hr = VariantChangeTypeExVB(vnt, vnt, LCID_ENGLISH, 0, vtDest)
    If hr < 0 Then GoTo HRESULT_FAILED
  End If
    If (vtDest = vbDouble Or vtDest = vbCurrency) And vtSrc <> vbNull And vtSrc <> vbEmpty Then
      nDigits = colInfo.Digits
      If nDigits >= 0 Then
        RoundPatched vnt, nDigits
      End If
    ElseIf vtDest = vbDate Then
      If VarType(vnt) = vbDate Then
        strTemp = colInfo.Name
        If strTemp = "Periode" Or strTemp = "VPeriode" Or strTemp = "ErsteinbezAb" Then
          vnt = DateSerial(Year(vnt), Month(vnt), 1)
        End If
      End If
    End If
  Exit Sub
ErrHandler:
  If (CallTypeEx And CallTypeEx_IgnoreError) = 0 And (CallTypeEx And CallTypeEx_ReturnError) = 0 Then
    GoTo HRESULT_FAILED
  End If
  Err.Raise Err.Number, Err.Source, Err.Description
  Exit Sub
HRESULT_FAILED:
  If (CallTypeEx And CallTypeEx_IgnoreError) <> 0 Then
    vnt = Empty
  ElseIf (CallTypeEx And CallTypeEx_ReturnError) <> 0 Then
    vnt = CVErrEx(hr)
  Else
    Err.Raise hr
    Resume
  End If
End Sub

Private Property Get TColInfo_ReadOnly(colInfo As TColInfo) As Boolean
  TColInfo_ReadOnly = ((colInfo.BrowseFlags And EnBrowseFlagsReadOnly) <> 0)
End Property

Private Property Get TColInfo_IsOptional(colInfo As TColInfo) As Boolean
  TColInfo_IsOptional = ((colInfo.uml_ex And EnUmlEx_OPTIONAL) <> 0 Or (colInfo.BrowseFlags And EnBrowseFlagsNullable) <> 0)
End Property

'effektives Browseset
'hier mit Einbeziehung dynamischer Browsesets f|fffd|r Boolean Type
Friend Function TColInfo_BrowseSetEffective(colInfo As TColInfo) As Object
  Dim Browseset As Object
  'spezielles Browseset f|fffd|r Boolean
  Set Browseset = colInfo.rMap_Keys_BrowseSet
  If Browseset Is Nothing And colInfo.VarType = vbBoolean Then
    Set Browseset = BrowsesetBool
  End If
  Set TColInfo_BrowseSetEffective = Browseset
End Function


Private Sub TConfig_Initialize(ByRef config As TConfig)
  config.YOffsetHeaderLine = -1
End Sub


Attribute VB_Name = "CRangeNode"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private m_oMoveNextParam As Object
Private m_dispid_MoveNext As Long
Private m_nMember As Long
Private m_oParentNode As CRangeNode
Private m_oContainer As CRangeGrid
Private m_bEnableIteration As Boolean
Private m_rObjID As Range
Private m_rObjID_Begin As Range
Private m_nLevelEnd As Integer
Private m_nLevelBegin As Integer

Public Function PropertiesFindIndex(ByVal strName As String, Optional IndexResult As Long) As Boolean
  Dim i As Long
  Dim vntTemp As Variant
  Dim bFound As Boolean
  If strName = "" Then
    IndexResult = m_nMember
    PropertiesFindIndex = True
    Exit Function
  End If
  vntTemp = strName
  m_oContainer.InvokeRange 0, vntTemp
  bFound = Not IsError(vntTemp)
  If bFound Then
    IndexResult = vntTemp
  End If
  PropertiesFindIndex = bFound
End Function

Public Function PropertiesNameToIndex(Optional ByVal strName As String) As Long
  If Not PropertiesFindIndex(strName, PropertiesNameToIndex) Then
    Err.Raise ERR_INVALIDARG
  End If
End Function

Public Property Get PropertiesTopLeft(Name As Variant) As Range
  Set PropertiesTopLeft = PropertiesArea(Name)
End Property

Public Property Get PropertiesArea(Name As Variant) As Range
  Dim vntMember As Variant
  Dim vntResult As Variant
  If m_nMember <> -1 Then Err.Raise E_NOTIMPL
  vntMember = Name
  m_oContainer.InvokeRange 0, vntMember, vntResult, Selection:=m_rObjID, bNoHitTest:=True
  If Not IsObject(vntResult) Then Err.Raise E_NOTIMPL
  Set PropertiesArea = vntResult
End Property

Public Property Get PropertiesObject(Name As Variant) As CRangeNode
  Dim vntMember As Variant
  Dim o As New CRangeNode
  If m_nMember <> -1 Then Err.Raise E_NOTIMPL
  If VarType(Name) = vbString Then
    vntMember = Name
    m_oContainer.InvokeRange 0, vntMember
  Else
    vntMember = Name
  End If
  o.Init m_oContainer, Me, m_rObjID, -1, -1, False, vntMember
  Set PropertiesObject = Me
End Property

Public Function Clone() As CRangeNode
  Dim o As New CRangeNode
  o.Init m_oContainer, m_oParentNode, m_rObjID, m_nLevelBegin, m_nLevelEnd, m_bEnableIteration
  Set Clone = o
End Function

Public Property Get Value() As Variant
  If m_nMember = -1 Then Err.Raise E_NOTIMPL
  m_oContainer.InvokeRange VbGet, m_nMember, Value, m_rObjID, bNoHitTest:=True
End Property

Private Sub Class_Initialize()
  m_nMember = -1
End Sub

Public Property Get KeyLevel() As Integer
  KeyLevel = m_oContainer.KeyLevelImpl(m_rObjID)
End Property

Public Property Get TopLeft() As Range
  If Not m_rObjID Is Nothing Then
    Set TopLeft = m_oContainer.TopLeftImpl(m_rObjID)
  End If
End Property

'inneren Iterator an aktueller Stelle generieren
Public Function CreateSubIterator() As CRangeNode
  Dim oRangeNode As New CRangeNode
  Dim rObjID As Range
  
  Set rObjID = m_rObjID
  
  'Start ist erstes Vorkommen von innerstem Level
  m_oContainer.MoveNextImpl m_nLevelBegin + 1, m_nLevelBegin + 2, rObjID, bInitFirst:=True
  
  oRangeNode.Init m_oContainer, Me, rObjID, m_nLevelBegin + 1, m_nLevelBegin + 2, bEnableIteration:=True
  Set CreateSubIterator = oRangeNode
  
End Function


Public Property Get Area() As Range
  If Not m_rObjID Is Nothing Then
  End If
End Property

Public Property Get Container() As CRangeGrid
  Set Container = m_oContainer
End Property

Public Property Get EOF() As Boolean
  If Not m_bEnableIteration Then Err.Raise E_NOTIMPL
  EOF = (m_rObjID Is Nothing)
End Property

Public Sub MoveNext()
  If Not m_bEnableIteration Then Err.Raise E_NOTIMPL
  m_oContainer.MoveNextImpl m_nLevelBegin, m_nLevelEnd, m_rObjID, bInitFirst:=False
End Sub

Public Sub Reset()
  If Not m_bEnableIteration Then Err.Raise E_NOTIMPL
  Set m_rObjID = m_rObjID_Begin
End Sub

Public Sub InvokeThis(ByVal CallType As Long, ByRef Names As Variant, Optional ByRef Data As Variant)
  If m_nMember <> -1 Then
    Err.Raise E_NOTIMPL
  End If
  m_oContainer.InvokeRange CallType, Names, Data, m_rObjID, bNoHitTest:=True
End Sub

Public Property Get Default(Optional Name As Variant) As Variant
Attribute Default.VB_UserMemId = 0
  If m_nMember = -1 Then
    m_oContainer.InvokeRange VbGet, Name, Default, m_rObjID, bNoHitTest:=True
  Else
    If Not IsMissing(Name) Then Err.Raise ERR_INVALIDARG
    m_oContainer.InvokeRange VbGet, m_nMember, Default, m_rObjID, bNoHitTest:=True
  End If
End Property

Public Sub Init(ByVal oContainer As CRangeGrid, ByVal oParentNode As CRangeNode, ByVal rObjID As Range, ByVal LevelBegin As Integer, ByVal LevelEnd As Integer, ByVal bEnableIteration As Boolean, Optional ByVal nMember As Long = -1)
  Set m_oContainer = oContainer
  Set m_oParentNode = oParentNode
  m_nLevelBegin = LevelBegin
  m_nLevelEnd = LevelEnd
  m_bEnableIteration = bEnableIteration
  Set m_rObjID_Begin = rObjID
  Set m_rObjID = rObjID
  m_nMember = nMember
End Sub
Attribute VB_Name = "CSaldenEditor"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit



#Const DOTNETBUILD = 1



#If Win64 Then
Private Declare PtrSafe Function DeleteDC Lib "GDI32" (ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function SelectObject Lib "GDI32" (ByVal hDC As LongPtr, ByVal HGDIOBJ As LongPtr) As LongPtr
Private Declare PtrSafe Function CreateICA Lib "GDI32" (ByVal lpszDriver As String, ByVal lpszDevice As String, ByVal lpszOutput As String, ByVal lpdvmInit As LongPtr) As LongPtr
Private Declare PtrSafe Function DrawTextA Lib "User32" (ByVal hDC As LongPtr, ByVal lpString As String, ByVal nCount As Long, ByVal lpRect As LongPtr, ByVal uFormat As Long) As Long

#Else
Private Declare Function DeleteDC Lib "GDI32" (ByVal hDC As Long) As Long
Private Declare Function SelectObject Lib "GDI32" (ByVal hDC As Long, ByVal HGDIOBJ As Long) As Long
Private Declare Function CreateICA Lib "GDI32" (ByVal lpszDriver As String, ByVal lpszDevice As String, ByVal lpszOutput As String, ByVal lpdvmInit As Long) As Long
Private Declare Function DrawTextA Lib "User32" (ByVal hDC As Long, ByVal lpString As String, ByVal nCount As Long, ByVal lpRect As Long, ByVal uFormat As Long) As Long
#End If

Private WithEvents m_datasheet As Excel.Worksheet
Attribute m_datasheet.VB_VarHelpID = -1
Private WithEvents m_worksheet As Excel.Worksheet
Attribute m_worksheet.VB_VarHelpID = -1
Private m_nMitKstSal As Integer
Private Const N_ROWS_HEADER = 7
Private m_oGridKTOSAL As CRangeGrid
Private m_collDetailSheets As New Collection
Public CallContext As Object
Private m_nCountAddDetailInfos As Long
Private m_AddDetailVector As Range
Private m_bCellDragAndDrop_prev As Boolean
Private m_oActiveGrid As CRangeGrid
Private m_bEditWorkbookActive As Boolean
Private m_NumberSeparatorsBak As Variant 'Backup f|fffd|r Dezimal und Tausendertrenner w|fffd|hrend aktiver Mappe



'Ermittle Mehrfachauswahl nach Name
'Name muss konform zu CSaldenEditor.RangeMulti_AssignName sein
Friend Function RangeMulti_Find(Name As String, Optional ByVal wsContext As Worksheet, Optional ByRef nRows As Long) As Range
  Dim r As Range, rResult As Range
  Dim nIndex As Long
  Dim vntName As Variant
  Dim nCount As Long
  
  
  On Error GoTo RangeNotFound
  
  If wsContext Is Nothing Then
    Set rResult = Range(Name)
  Else
    Set rResult = wsContext.Range(Name)
  End If
  If rResult.Row > 1 Then 'erste Zeile gilt hier als Nullzeile (zutreffend f|fffd|r Strukturblatt und Saldenblatt)
    
    nCount = RangeMulti_Count(rResult)
    
    If rResult.Areas.count >= N_AREAS_MAX Then
      'bei Maximalzahl von Areas evt. mehrfach definierte Bereiche
      nIndex = 1
      Do
        vntName = Name & "_" & nIndex
        Set r = Nothing
        On Error Resume Next
        If wsContext Is Nothing Then
          Set r = Range(vntName)
        Else
          Set r = wsContext.Range(vntName)
        End If
        On Error GoTo RangeNotFound
        If r Is Nothing Then Exit Do
        Set rResult = Union(rResult, r)

        nCount = nCount + RangeMulti_Count(r)

        nIndex = nIndex + 1
      Loop
    End If
    Set RangeMulti_Find = rResult
  End If

RangeNotFound:

  nRows = nCount
End Function

Public Function IDLSumKto_BilGuV_SH(ByVal nBilGuV As Long, ByVal rCalculateCol As Range) As Variant
  Dim rBilGuV As Range, r As Range
  Dim rKtoH As Range, rKtoS As Range
  Dim vntTemp As Variant
  Dim i As Long
  Set rBilGuV = RangeMulti_Find("KTO_BILGUV_" & nBilGuV, m_worksheet)
  If Not rBilGuV Is Nothing Then
    Set rKtoS = RangeMulti_Find("KTO_S", m_worksheet)
    Set rKtoH = RangeMulti_Find("KTO_H", m_worksheet)
    If Not rKtoS Is Nothing Then
      Set r = Intersect(rKtoS, rBilGuV)
      If Not r Is Nothing Then
        IDLSumKto_BilGuV_SH = WorksheetFunction.sum(IDL_MSColMap_Offset(r, rCalculateCol.Column - r.Column))
        If IsError(IDLSumKto_BilGuV_SH) Then Exit Function
      End If
    End If
    If Not rKtoH Is Nothing Then
      Set r = Intersect(rKtoH, rBilGuV)
      If Not r Is Nothing Then
        vntTemp = WorksheetFunction.sum(IDL_MSColMap_Offset(r, rCalculateCol.Column - r.Column))
        If IsError(vntTemp) Then
          IDLSumKto_BilGuV_SH = vntTemp
        Else
          IDLSumKto_BilGuV_SH = IDLSumKto_BilGuV_SH - vntTemp
        End If
      End If
    End If
  End If
  If nBilGuV = 2 Or nBilGuV = 3 Then
    IDLSumKto_BilGuV_SH = -IDLSumKto_BilGuV_SH
  End If
End Function

Private Sub CheckSelectionStatusDecentral_Impl()
  On Error GoTo ErrHandler
  If ThisPlugin.MenuEnabled Then
    Set CallContext = ThisPlugin
    ThisPlugin.StatusText = ""
    CheckSelectionStatus False
    If ThisPlugin.StatusText = "" Then
      Application.StatusBar = False
    Else
      Application.StatusBar = ThisPlugin.StatusText
      ThisPlugin.StatusText = ""
    End If
    Set CallContext = Nothing
  End If
  Exit Sub
ErrHandler:
  ThisPlugin.StatusText = ""
  Set CallContext = Nothing
End Sub

Public Function StatusDiffAddDetails(Optional ByVal rContext As Range) As Variant
  Dim oCaller As Range
  Dim ws As Worksheet
  Dim r As Range
  Dim nColDiff As Long
  Dim diff As Currency
  Dim oEditor As CSaldenEditor
  On Error GoTo ErrHandler
  If rContext Is Nothing Then
    If IsObject(Application.Caller) Then
      Set oCaller = Application.Caller
      Set rContext = oCaller
    End If
  End If
  If Not rContext Is Nothing Then
    Set ws = rContext.Worksheet
    nColDiff = NColAddDetailsFirst - rContext.Column
    Set r = ws.Range(rContext.Offset(0, nColDiff), rContext.Offset(0, nColDiff + 10))
    diff = rContext.Value - WorksheetFunction.sum(r)
    If oCaller Is Nothing Then
      If diff <> 0 Then
        StatusDiffAddDetails = SearchTextInKPOBJ("FIE", "SVT.DIFFERENZ") & ": " & Format$(diff, "##,##0.00")
      End If
    Else
      StatusDiffAddDetails = (diff <> 0)
    End If
  End If
  Exit Function
ErrHandler:
  If Not oCaller Is Nothing Then
    StatusDiffAddDetails = True
  Else
    Err.Raise Err.Number, Err.Source, Err.Description
  End If
End Function

Public Sub CheckSelectionStatus(ByVal bLeaveSelection As Boolean)
  Dim bSetStatus As Boolean
  Dim strStatus As String
  Dim oFormatCondition As FormatCondition
  Dim rObjID As Range
  Dim r As Range
  Dim rKST_Enabled As Range
  Dim Target As Range
  If Not bLeaveSelection Then
    Set Target = Selection
    If Not Target Is Nothing Then
      If Target.count = 1 Then
        If Target.Column = NColActValue Then
          For Each oFormatCondition In Target.FormatConditions
            If oFormatCondition.Type = xlExpression Then
                strStatus = StatusDiffAddDetails(Target)
                If strStatus <> "" Then
                  bSetStatus = True
                End If
                Exit For
            End If
          Next oFormatCondition
        End If
      End If
      If Not bSetStatus Then
        If RepOption = "C" Then
          Set rObjID = m_oGridKTOSAL.HitTestRange(nYLevel:=1, nXLevel:=0, Selection:=Target.EntireRow)
          If Not rObjID Is Nothing Then
            If rObjID.count = 1 Then
              Set r = DataRange_Find("KTO")
              Set r = IDLVLookup(r, rObjID, Sorted:=False)
              Do While EvalRefCell(r.Offset(0, EnDataCols_BilGUVKnz - EnDataCols_ObjID)).Offset(0, NColObjID - NColBilGuVKnz).Address <> rObjID.Address
                Set r = r.Offset(1, 0)
              Loop
              If Not r Is Nothing Then
                Set rKST_Enabled = DataRange_Find("KST_Enabled")
                Set r = IDLVLookup(rKST_Enabled, r.Offset(0, EnDataCols_Knz2 - EnDataCols_ObjID), 0, 1, False)
                If Not r Is Nothing Then
                  bSetStatus = True
                  strStatus = r.Value & " - " & SearchTextByRObjID(r, nBene:=1)
                End If
              End If
            End If
          End If
        End If
      End If
    End If
  End If
  If bSetStatus Then
    CallContext.StatusBar.StatusText = strStatus
  End If
End Sub

Private Sub m_worksheet_Change(ByVal Target As Excel.Range)
  If Target.count = 1 And ThisPlugin.MenuEnabled Then
    If IsEqualRange(Target, ActiveCell) Then
      CheckSelectionStatusDecentral_Impl
    End If
  End If
End Sub

Private Sub m_worksheet_SelectionChange(ByVal Target As Excel.Range)
  CheckSelectionStatusDecentral_Impl
End Sub

Public Property Get Grid() As CRangeGrid
  Set Grid = m_oGridKTOSAL
End Property

Public Function IsEqualRange(ByVal r1 As Range, ByVal r2 As Range) As Boolean
  If r1 Is Nothing Then
    IsEqualRange = r2 Is Nothing
  ElseIf r2 Is Nothing Then
    IsEqualRange = False
  ElseIf r1 Is r2 Then
    IsEqualRange = True
  ElseIf r1.Worksheet Is r2.Worksheet Then
    IsEqualRange = (r1.Address = r2.Address)
  End If
End Function

Public Property Get Valid() As Boolean
  On Error GoTo ErrHandler
  If m_worksheet Is Nothing Then
  Else
    Valid = True
  End If
  Exit Property
ErrHandler:
End Property


'true, falls logischer Spiegel aus Spiegelbereich gebildet
Friend Function isSPIFromSBE(spi As String) As Boolean
  isSPIFromSBE = (Len(spi) > 6)
End Function
Friend Function SPIFromSBE(spi As String) As String
  SPIFromSBE = Trim$(Left$(spi, 6))
End Function


Public Function EvalRefCell(ByVal rCell As Range, Optional ByVal bIgnoreErrors As Boolean) As Range
  Dim bReferenceStyleChanged As Boolean
  Dim nReferenceStyle_prev As Long
  Dim strFormula As String
  Dim ws As Worksheet
  Dim strError As String, nError As Long
  On Error GoTo ErrHandler
  Set ws = rCell.Worksheet
  If rCell.FormulaHidden And ws.ProtectContents Then
    strFormula = rCell.Formula
    If Left$(strFormula, 1) <> "=" Then strFormula = ""
  ElseIf rCell.HasFormula Then
    strFormula = rCell.Formula
  End If
  If strFormula <> "" Then
    If Application.ReferenceStyle <> xlA1 Then
      nReferenceStyle_prev = Application.ReferenceStyle
      Application.ReferenceStyle = xlA1
      bReferenceStyleChanged = True
    End If
    Set EvalRefCell = ws.Evaluate(strFormula)
  End If
Cleanup:
  If bReferenceStyleChanged Then
    Application.ReferenceStyle = nReferenceStyle_prev
    bReferenceStyleChanged = False
  End If
  If nError <> 0 Then
    If Not bIgnoreErrors Then
      Err.Raise nError, , strError
    End If
  End If
  Exit Function
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  GoTo Cleanup
End Function

Public Sub CreateIDLLocTextRangeDirect(ByVal r As Range, ByVal rBeneXField As Range)
  r.NumberFormat = "General"
  r.Formula = "=" & CreateIDLLocTextFormulaDirect(rBeneXField)
  r.FormulaHidden = True
End Sub

Public Function CreateIDLLocTextFormulaDirect(ByVal rBeneXField As Range) As String
  Dim r As Range
  Dim strName As String
  strName = "'" & rBeneXField.Worksheet.Name & "'!" & rBeneXField.Address
  Set r = rBeneXField.Offset(0, EnDataCols_Language + 4 - rBeneXField.Column + 1)
  If r.Value <> "" Then
    CreateIDLLocTextFormulaDirect = "IDLLocText(" & strName & ", OnlineLanguage)"
  Else
    CreateIDLLocTextFormulaDirect = strName
  End If
End Function

Public Sub CreateIDLLocTextRange(ByVal r As Range, objTyp As String, objID As String, Field As String)
#If CENTRALBUILD Then
  If Not m_Resultset Is Nothing Then
    CreateIDLLocTextRangeCentralResultset r, objTyp, objID, Field
    Exit Sub
  End If
#End If
  r.NumberFormat = "General"
  r.Formula = "=" & CreateIDLLocTextFormula(objTyp, objID, Field)
  r.FormulaHidden = True
End Sub

Public Function CreateIDLLocTextFormula(objTyp As String, objID As String, Field As String) As String
  #If CENTRALBUILD Then
    CreateIDLLocTextFormula = CreateIDLLocTextFormulaCentral(objTyp, objID, Field)
  #Else
    CreateIDLLocTextFormula = CreateIDLLocTextFormulaDecentral(objTyp, objID, Field)
  #End If
End Function

Public Function CreateIDLLocTextFormulaDecentral(objTyp As String, objID As String, Field As String) As String
  Dim r As Range
  Dim col As Long
  If Field = "Bene1" Then
    col = EnDataCols_Language + 1
  ElseIf Field = "Bene2" Then
    col = EnDataCols_Language + 2
  Else
    col = EnDataCols_Language + 3
  End If
  Set r = DataRange_Find(objTyp & "__" & objID)
  Set r = r.Offset(0, col)
  CreateIDLLocTextFormulaDecentral = CreateIDLLocTextFormulaDirect(r)
End Function

Private Sub Calculate_FeedbackState_Values(ByVal nValueCol As Long)
  Dim nRows As Long
  Dim r As Range, rStart As Range
  Dim i As Long
  Dim vntTemp() As Variant
  Dim wsDatasheet As Worksheet
  Set r = DataRange_Find("FeedbackState_Values", nRows)
  If nRows > 1 Then
    Set wsDatasheet = r.Worksheet
    nRows = nRows / 2
    Set rStart = r.Cells(1, nValueCol)
    Set r = rStart
    ReDim vntTemp(nRows - 1)
    For i = 0 To nRows - 1
      r.Value = 0
      Set r = r.Offset(1, 0)
      vntTemp(i) = r.Value
      Set r = r.Offset(1, 0)
    Next i
    Set r = rStart
    For i = 0 To nRows - 1
      r.Value = vntTemp(i)
      Set r = r.Offset(2, 0)
    Next i
  End If
  Exit Sub
ErrHandler:
  Dim nError As Long
  Dim strError As String
  nError = Err.Number
  strError = Err.Description
  Err.Raise nError, , strError
End Sub

Public Sub AutoFitMinColumnWidth(ByVal minWidth As Long, ByVal rColumn As Range)
  rColumn.AutoFit
  If rColumn.ColumnWidth < minWidth Then
    rColumn.ColumnWidth = minWidth
  End If
End Sub

Private Sub RecalcLayout()
  Dim r As Range
  Dim i As Long
  Const STD_VALUE_COLWIDTH = 14
  Const OBJID_COLWIDTH = 10
  Set r = m_worksheet.Columns(NColBene)
  r.AutoFit
  Set r = r.Offset(0, NColObjID - r.Column)
  AutoFitMinColumnWidth OBJID_COLWIDTH, r
  Set r = r.Offset(0, NColBilGuVKnz - r.Column)
  r.AutoFit
  Set r = r.Offset(0, 1)
  r.AutoFit
  Set r = r.Offset(0, 1)
  r.AutoFit
  Set r = r.Offset(0, NColSHKnz - r.Column)
  r.AutoFit
  Set r = r.Offset(0, NColActValue - r.Column)
  AutoFitMinColumnWidth STD_VALUE_COLWIDTH, r
  Set r = r.Offset(0, NColPrevValue - r.Column)
  AutoFitMinColumnWidth STD_VALUE_COLWIDTH, r
  If m_nCountAddDetailInfos > 0 Then
    Set r = r.Offset(0, NColAddDetailsFirst - r.Column)
    For i = 0 To m_nCountAddDetailInfos - 1
      AutoFitMinColumnWidth STD_VALUE_COLWIDTH, r
      Set r = r.Offset(0, 1)
    Next i
  End If
End Sub

Public Sub Ambients__PropertyChanged__LocaleID()
  Dim bProtect As Boolean
  Dim r As Range
  Dim oDetailEditor As CRangeGrid
  Dim vntTemp As Variant
  Dim bScreenUpdating_prev As Boolean
  Dim bScreenUpdating_Set As Boolean
  Dim nError As Long, strSource As String, strError As String
  On Error GoTo ErrHandler
  bScreenUpdating_prev = Application.ScreenUpdating
  If bScreenUpdating_prev Then
    Application.ScreenUpdating = False
    bScreenUpdating_Set = True
  End If
#If CENTRALBUILD = 0 Then
  If Not ThisPlugin.MenuBar Is Nothing Then
    UpdateMenuBarText ThisPlugin.MenuBar
    For Each vntTemp In Array("Cell", "Row", "Column", "Ply")
      UpdateMenuBarText Application.CommandBars(vntTemp)
    Next vntTemp
  End If
#End If

  If Not ThisWorkbook.MultiUserEditing Then

    Unprotect
    bProtect = True
    RecalcLayout
  End If
  For Each oDetailEditor In m_collDetailSheets
    oDetailEditor.Ambients__PropertyChanged__LocaleID
  Next oDetailEditor
  AdjustDetailsWSName
  AdjustNumberSeparator True 'Spracheinstellungen anpassen

Cleanup:
  If bProtect Then
    Protect
    bProtect = False
  End If
  If bScreenUpdating_Set Then
    Application.ScreenUpdating = bScreenUpdating_prev
    bScreenUpdating_Set = False
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  GoTo Cleanup
End Sub



Private Property Get UseBuiltinNumberSeparators() As Boolean
  Dim r As Range
  If ExcelVersionInt >= 10 Then 'ab Excel 2002
    Set r = DataRange_Find("UseBuiltinNumberSeparators")
    If Not r Is Nothing Then
      UseBuiltinNumberSeparators = r.Value
    End If
  End If
End Property


Public Property Get LocaleID() As Long
  If m_datasheet Is Nothing Then
    'LocaleID = ControlText.LocaleID
  Else
    LocaleID = StrLanguageToLCID(m_datasheet.[OnlineLanguage])
  End If
End Property

'liefert ggf. abweichende Lokale f|fffd|r Dezimaltrenner
'0 f|fffd|r Trenner von Excel oder LOCALE_USER_DEFAULT, falls Trenner von Betriebssysten
Public Property Get LocaleIDNumberSeparator() As Long
  Dim lcid As Long
  Dim oExcelApp As Object
  
  Const LOCALE_USER_DEFAULT = &H400

  If UseBuiltinNumberSeparators Then
    Set oExcelApp = Application.Application
    If oExcelApp.UseSystemSeparators Then
      lcid = LOCALE_USER_DEFAULT
    Else
      lcid = 0
    End If
  Else
    lcid = LocaleID
  End If

  LocaleIDNumberSeparator = lcid
End Property



Friend Sub getNumberSeparators(ByVal lcid As Long, ByRef strDecimalSeparator As String, ByRef strThousandsSeparator As String)
  Const LCID_FRENCH As Long = &H40C
  If lcid = LCID_FRENCH Then
    strDecimalSeparator = ","
    strThousandsSeparator = " "
  ElseIf lcid <> LCID_ENGLISH Then
    'DEU, SPA
    strDecimalSeparator = ","
    strThousandsSeparator = "."
  Else
    'Englisch
    strDecimalSeparator = "."
    strThousandsSeparator = ","
  End If

End Sub

'Hauptversionsnr von Excel
Private Property Get ExcelVersionInt() As Long
  Dim strVersion As String
  Dim i As Long

  strVersion = Application.Version
  i = InStr(1, strVersion, ".")
  If i > 0 Then
    strVersion = Left$(strVersion, i - 1)
  End If
  i = CLng(strVersion)
  ExcelVersionInt = i
End Property

'Abgleich der Excel Einstellung bei Aktivierung / Deaktivierung und Onlinesprachenwechsel der Erfassungsmappe
Private Sub AdjustNumberSeparator(ByVal bActivate)
  Dim oExcelApp As Object
  Dim strDecimalSeparator As String, strThousandsSeparator As String
  
  If ExcelVersionInt >= 10 Then 'ab Excel 2002
    Set oExcelApp = Application.Application
    If bActivate Then
      getNumberSeparators LocaleID, strDecimalSeparator, strThousandsSeparator
      
      If IsEmpty(m_NumberSeparatorsBak) Then
        If oExcelApp.UseSystemSeparators Then
          m_NumberSeparatorsBak = True
        Else
          m_NumberSeparatorsBak = Array(oExcelApp.DecimalSeparator, oExcelApp.ThousandsSeparator)
        End If
      End If

      oExcelApp.UseSystemSeparators = False
      oExcelApp.DecimalSeparator = strDecimalSeparator
      oExcelApp.ThousandsSeparator = strThousandsSeparator
    Else
      'Deaktivierung
      If Not IsEmpty(m_NumberSeparatorsBak) Then
        If IsArray(m_NumberSeparatorsBak) Then
          oExcelApp.UseSystemSeparators = False
          oExcelApp.DecimalSeparator = m_NumberSeparatorsBak(0)
          oExcelApp.ThousandsSeparator = m_NumberSeparatorsBak(1)
        ElseIf VarType(m_NumberSeparatorsBak) = vbBoolean Then
          If m_NumberSeparatorsBak Then
            oExcelApp.UseSystemSeparators = True
          End If
        End If
        m_NumberSeparatorsBak = Empty
      End If
    End If
  End If
End Sub


Private Sub m_datasheet_Calculate()
  Dim nCol As Long
  Dim bScreenUpdatingPrev As Boolean
  Dim nCalcPrev As Long
  Dim i As Long
#If CENTRALBUILD Then
  If m_bStandalone Then Exit Sub
#End If
  If g_nSystemChangeCounter > 0 Then Exit Sub
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  bScreenUpdatingPrev = Application.ScreenUpdating
  nCalcPrev = Application.Calculation
  On Error GoTo ErrHandler
  Application.ScreenUpdating = False
  If nCalcPrev <> xlCalculationAutomatic Then
    Application.Calculation = xlCalculationAutomatic
  End If
  Calculate_FeedbackState_Values NColActValue
  Calculate_FeedbackState_Values NColPrevValue
  For i = 0 To m_nCountAddDetailInfos - 1
    Calculate_FeedbackState_Values NColAddDetailsFirst + i
  Next i
Cleanup:
  If nCalcPrev <> Application.Calculation Then
    Application.Calculation = nCalcPrev
  End If
  Application.ScreenUpdating = bScreenUpdatingPrev
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  GoTo Cleanup
End Sub

Public Sub VerifyNotMultiuserEditing()
  Dim wb As Workbook
  Dim strText As String
  Set wb = m_worksheet.Parent
  If wb.MultiUserEditing Then
    strText = SearchTextInSPR(380)
    If Application.DisplayAlerts Then
      MsgBox strText, vbCritical
      Err.Raise ERR_USER_CANCEL, , strText
    Else
      Err.Raise ERR_NOTOK, , strText
    End If
  End If
End Sub

Public Sub UnprotectWB()
  Dim wb As Workbook
  Set wb = m_worksheet.Parent
  VerifyNotMultiuserEditing
  wb.Unprotect WorkBook_Password
End Sub

Public Sub ProtectWB()
  Dim wb As Workbook
  Set wb = m_worksheet.Parent
  VerifyNotMultiuserEditing
  wb.Protect Password:=WorkBook_Password
End Sub

Public Sub Unprotect()
  VerifyNotMultiuserEditing
  m_worksheet.Unprotect WorkBook_Password
End Sub

Public Sub Protect()
  VerifyNotMultiuserEditing
  m_worksheet.Protect Password:=WorkBook_Password
End Sub

Public Property Get TCEnabled() As Boolean
  Dim r As Range
  Dim i As Long
  Set r = DataRange_Find("TCEnabled", i)
  If i = 1 And Not r Is Nothing Then
    TCEnabled = r.Value
  Else
    TCEnabled = True
  End If
End Property

Public Property Get Worksheet() As Excel.Worksheet
  Set Worksheet = m_worksheet
End Property

Public Property Get RepOption() As String
  Dim r As Range
  Dim i As Long
#If CENTRALBUILD Then
  If Version < 8 Then Exit Property
#End If
  Set r = DataRange_Find("RepOption", i)
  If i = 1 And Not r Is Nothing Then
    RepOption = r.Value
  End If
End Property

Public Sub ConvertValueFromCell(ByVal rCell As Range, ByRef vntResult As Variant)
  Dim vntActValue As Variant
  vntActValue = rCell.Value
  If IsEmpty(vntActValue) Then
    vntResult = Empty
    Exit Sub
  ElseIf VarType(vntActValue) = vbString Then
    vntActValue = Trim(vntActValue)
    If vntActValue = "" Then
      vntResult = Empty
      Exit Sub
    End If
  End If
  If Not IsNumeric(vntActValue) Then
    On Error Resume Next
    If Application.DisplayAlerts Then
      rCell.Worksheet.Activate
      rCell.Activate
    End If
    On Error GoTo 0
    Err.Raise ERR_NOTOK, , rCell.Address & ": " & SearchTextInSPR(EnStdMsgErrorInputConvention)
  End If
  vntResult = CDbl(vntActValue)
End Sub

Public Sub RecalcComboLayout(ByVal cmb As MSForms.ComboBox)
  Dim nRow As Long, nCol As Long
  Dim nColCount As Long
  Dim vntVal As Variant
  Dim arWidth() As Long
  Dim f As stdole.IFont
#If Win64 Then
  Dim hdcTest As LongPtr
  Dim hFont As LongPtr, hFontOld As LongPtr
#Else
  Dim hdcTest As Long
  Dim hFont As Long, hFontOld As Long
#End If
#If CENTRALBUILD Then
  Dim rectTest As tagRECT
#Else
  Dim rectTest(0 To 3) As Long
#End If
  Dim colOffset As Long
  Dim i As Long
  Const DT_CALCRECT = &H400
  Const DT_SINGLELINE = &H20
  Dim strWidth As String
  Dim ptListWidth As Single
  Dim ptColWidth As Single
  
  Set f = cmb.Font
  hFont = f.hFont
  hdcTest = CreateICA("DISPLAY", vbNullString, vbNullString, 0)
  hFontOld = SelectObject(hdcTest, hFont)
#If CENTRALBUILD Then
  Call DrawTextA(hdcTest, "XX", -1, rectTest, DT_CALCRECT Or DT_SINGLELINE)
  colOffset = rectTest.Right
#Else
  Call DrawTextA(hdcTest, "XX", -1, VarPtr(rectTest(0)), DT_CALCRECT Or DT_SINGLELINE)
  colOffset = rectTest(2)
#End If
  nColCount = cmb.ColumnCount
  ReDim arWidth(nColCount - 1)
  cmb.ColumnCount = nColCount
  For nRow = 0 To cmb.ListCount - 1
    For nCol = 0 To nColCount - 1
      vntVal = cmb.List(nRow, nCol)
      If Not IsNull(vntVal) Then
#If CENTRALBUILD Then
        Call DrawTextA(hdcTest, vntVal, -1, rectTest, DT_CALCRECT Or DT_SINGLELINE)
        i = rectTest.Right
#Else
        Call DrawTextA(hdcTest, vntVal, -1, VarPtr(rectTest(0)), DT_CALCRECT Or DT_SINGLELINE)
        i = rectTest(2)
#End If
        If arWidth(nCol) < i Then arWidth(nCol) = i
      End If
    Next nCol
  Next nRow
  For i = 0 To nColCount - 1
    If i = nColCount - 1 Then
      arWidth(i) = arWidth(i) + colOffset
    End If
    ptColWidth = (arWidth(i) + colOffset) * 3 / 4
    If i > 0 Then strWidth = strWidth & ";"
    ptColWidth = WorksheetFunction.Round(ptColWidth + 0.5, 0)
    strWidth = strWidth & CStr(ptColWidth)
    ptListWidth = ptListWidth + ptColWidth
  Next i
  cmb.ColumnWidths = strWidth
  If ptListWidth < cmb.Width Then
    cmb.ListWidth = cmb.Width
  Else
    cmb.ListWidth = ptListWidth
  End If
  If hdcTest <> 0 Then
    SelectObject hdcTest, hFontOld
    DeleteDC hdcTest
  End If
End Sub

Public Sub FillCombo(ByVal cmb As MSForms.ComboBox, ByVal rObjIDVector As Range, Optional ByVal IncludeEmptyItem As Boolean)
  Dim r As Range
  Dim rObjID As Range
  Dim strOnlineLanguage As String
  Dim i As Long
  Dim nItem As Long
  cmb.Clear
  cmb.ColumnCount = 3
  strOnlineLanguage = DataRange_Find("OnlineLanguage")
  If IncludeEmptyItem Then
    cmb.AddItem ""
    nItem = 1
  End If
  If Not rObjIDVector Is Nothing Then
    For Each rObjID In rObjIDVector
      cmb.AddItem rObjID.Value
      Set r = IDLLocText(rObjID.Offset(0, EnDataCols_Language + 1), strOnlineLanguage)
      cmb.List(nItem, 1) = r.Value
      Set r = IDLLocText(rObjID.Offset(0, EnDataCols_Language + 3), strOnlineLanguage)
      cmb.List(nItem, 2) = r.Value
      nItem = nItem + 1
      i = i + 1
    Next rObjID
  End If
  If cmb.style = fmStyleDropDownList And nItem > 0 Then
    cmb.ListIndex = 0
  End If
  If nItem = 0 Then
    cmb.ShowDropButtonWhen = fmShowDropButtonWhenNever
  Else
    cmb.ShowDropButtonWhen = fmShowDropButtonWhenAlways
  End If
  RecalcComboLayout cmb
End Sub

'liefert Name zu Datenbereich
'liefert "", falls nicht gefunden, bei Return Default: Bereichsname
Public Property Get DataRange_Name(ByVal r As Range, Optional ByVal ReturnDefault As Boolean) As String
  'nur Namen in Strukturblatt/Datenblatt ber|fffd|cksichtigen
  Dim oNames As Names
  Dim oName As Name
  Dim rTest As Range
  Dim strRangeName As String
  Dim nFound As Long
  Dim strRangeNameDefault As String
  
  Set oNames = m_datasheet.Names
  strRangeNameDefault = "'" & r.Worksheet.Name & "'!" & r.Address
  On Error Resume Next
  For Each oName In oNames
    Set rTest = Nothing
    Set rTest = oName.RefersToRange
    If Not rTest Is Nothing Then
      If strRangeNameDefault = "'" & rTest.Worksheet.Name & "'!" & rTest.Address Then
        strRangeName = oName.Name
        nFound = InStr(1, strRangeName, "!")
        If nFound > 0 Then
          strRangeName = Mid$(strRangeName, nFound + 1)
        Else
          strRangeName = oName.Name
        End If
        Exit For
      End If
    End If
  Next oName
  If strRangeName = "" And ReturnDefault Then
    DataRange_Name = strRangeNameDefault
  Else
    DataRange_Name = strRangeName
  End If
End Property


Public Function EvaluteRefKeyList(ByVal rObjID_Start As Range, KeyList As String, Optional ByRef nRowsResult As Long) As Range
  Dim nLeft As Long, nRight As Long
  Dim nActPos As Long
  Dim strTemp As String
  Dim strChar As String
  Dim i As Long
  Dim nRows_Area As Long
  Dim nRows As Long
  Dim rResult As Range
  Dim rTemp As Range
  If KeyList = "" Then
    nRowsResult = 0
    Exit Function
  End If
  nLeft = -1
  nRight = -1
  For i = 1 To Len(KeyList)
    strChar = Mid$(KeyList, i, 1)
    Select Case strChar
      Case ":"
        nLeft = CLng(strTemp)
        strTemp = ""
      Case ","
        If nLeft >= 0 Then
          Set rTemp = rObjID_Start.Offset(nLeft, 0)
          nRight = CLng(strTemp)
          nRows_Area = nRight - nLeft + 1
          Set rTemp = rTemp.Resize(nRows_Area)
        Else
          nLeft = CLng(strTemp)
          Set rTemp = rObjID_Start.Offset(nLeft, 0)
          nRows_Area = 1
        End If
      Case "0" To "9"
        strTemp = strTemp & strChar
    End Select
    If Not rTemp Is Nothing Then
      If rResult Is Nothing Then
        Set rResult = rTemp
      Else
        Set rResult = Union(rResult, rTemp)
      End If
      nRows = nRows + nRows_Area
      strTemp = ""
      nLeft = -1
      nRight = -1
      Set rTemp = Nothing
    End If
  Next i
  If strTemp <> "" Then
    If nLeft >= 0 Then
      nRight = CLng(strTemp)
      nRows_Area = nRight - nLeft + 1
      Set rTemp = rObjID_Start.Offset(nLeft, 0).Resize(nRows_Area)
    Else
      nLeft = CLng(strTemp)
      Set rTemp = rObjID_Start.Offset(nLeft, 0)
      nRows_Area = 1
    End If
  End If
  If Not rTemp Is Nothing Then
    If rResult Is Nothing Then
      Set rResult = rTemp
    Else
      Set rResult = Union(rResult, rTemp)
    End If
    nRows = nRows + nRows_Area
  End If
  Set EvaluteRefKeyList = rResult
  nRowsResult = nRows
End Function

Public Function DataRange_Find(ByVal strName As String, Optional ByRef nRows As Long) As Range
 Dim rArea As Range

  strName = Replace(strName, "-", "_")
  strName = Replace(strName, " ", "x") 'spezielle Kennung f|fffd|r Space bei Namen

  On Error GoTo NameNotFound
  Set DataRange_Find = DataSheet.Range(strName)
  On Error GoTo 0
  For Each rArea In DataRange_Find.Rows.Areas
    nRows = nRows + rArea.Rows.count
  Next rArea
  If nRows = 1 Then
    If DataRange_Find.Row = 1 Then
      nRows = 0
    End If
  End If
  Exit Function
NameNotFound:
  nRows = 0
End Function


Public Function DataRange_Find_WithEnabled(ByVal strName As String, Optional ByRef nRows As Long) As Range
  Set DataRange_Find_WithEnabled = DataRange_Find(strName & "_Enabled", nRows)
  If DataRange_Find_WithEnabled Is Nothing Then
    Set DataRange_Find_WithEnabled = DataRange_Find(strName, nRows)
  End If
End Function



Public Property Get DataSheet() As Worksheet
  Set DataSheet = m_datasheet
End Property


Public Property Get KtoPlan() As Variant
  Set KtoPlan = DataSheet.Range("KtoPlan")
End Property

Public Property Get KstPlan() As Variant
  Set KstPlan = DataSheet.Range("KstPlan")
End Property


Public Sub Check__ExcelUI()
  Dim oCallContext_Prev As Object
  Dim r As Range, rStart As Range
  Dim nRow As Long
  Dim wnd As Excel.Window
  Dim bErrorsFound As Boolean
  Dim bProtect As Boolean
  Dim nError As Long, strError As String, strSource As String
  Set oCallContext_Prev = CallContext
  On Error GoTo ErrHandler
  m_worksheet.Activate
  g_nSystemChangeCounter = g_nSystemChangeCounter + 1
  Unprotect
  bProtect = True
  Set r = m_worksheet.Range("CheckLog")
  Set r = m_worksheet.Range(r, r.Offset(0, 1))
  r.Clear
  Set rStart = r.Cells(1, 1)
  Set r = rStart.Offset(-1, 0)
  r.Activate
  r.Show
  Set ThisPlugin.LogActRange = rStart
  Set CallContext = ThisPlugin
  Check
Cleanup:
  If Not ThisPlugin.LogActRange Is Nothing Then
    Set r = m_worksheet.Range(rStart, ThisPlugin.LogActRange)
    r.Name = "CheckLog"
  End If
  bErrorsFound = False
  If nError = 0 Then
    For Each r In r.Offset(0, 1)
      If r.Interior.Color = vbRed Then
        bErrorsFound = True
        Exit For
      End If
    Next r
    If bErrorsFound Then
      MsgBox SearchTextInSPR(318) & ": " & SearchTextInSPR(334), vbCritical
    Else
      MsgBox SearchTextInSPR(318) & ": " & SearchTextInSPR(331)
    End If
  End If
  If bProtect Then
    Protect
  End If
  Set CallContext = oCallContext_Prev
  Set ThisPlugin.LogActRange = Nothing
  If nError <> 0 And nError <> ERR_USER_CANCEL Then
    ShowErrDialog nError, strError, strSource
  End If
  g_nSystemChangeCounter = g_nSystemChangeCounter - 1
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  GoTo Cleanup
End Sub

Public Function Check_AccrualsAdditions() As Boolean
  Check_AccrualsAdditions = m_oGridKTOSAL.Check_BewSpiegelSpalte("RUEBEW", "Z", "04")
End Function

Public Function Check_AccrualsReleases() As Boolean
  Check_AccrualsReleases = m_oGridKTOSAL.Check_BewSpiegelSpalte("RUEBEW", "Y", "03")
End Function

Public Function Check_DeprActPer() As Boolean
  Check_DeprActPer = m_oGridKTOSAL.Check_BewSpiegelSpalte("ANLBEW", "D", "13")
End Function

Public Function Check() As Boolean
  Dim oStatusBar As Object
  Dim bProgressOpened As Boolean
  Dim oLog As Object
  Dim bSubLogOpened As Boolean
  Const NCOUNT_CHECKS = 3
  Dim oCallContext_Common_Prev As Object
  Dim bOK As Boolean
  Set oCallContext_Common_Prev = Common.CallContext
  On Error Resume Next
  Set oStatusBar = CallContext.StatusBar
  Set oLog = CallContext.Log
  On Error GoTo ErrHandler
  bOK = True
  If Not oStatusBar Is Nothing Then
    oStatusBar.StatusText = SearchTextInSPR(318)
    oStatusBar.OpenProgress NCOUNT_CHECKS
    bProgressOpened = True
  End If
  If Not Check_DeprActPer Then
    bOK = False
  End If
  If Not oStatusBar Is Nothing Then oStatusBar.ProgressNext
  If Not Check_AccrualsAdditions Then
    bOK = False
  End If
  If Not oStatusBar Is Nothing Then oStatusBar.ProgressNext
  If Not Check_AccrualsReleases Then
    bOK = False
  End If
  If Not oStatusBar Is Nothing Then oStatusBar.ProgressNext
  RecalcLayout
  If bProgressOpened Then
    oStatusBar.CloseProgress
  End If
  Set Common.CallContext = oCallContext_Common_Prev
  Check = bOK
  Exit Function
ErrHandler:
  Dim strError As String
  Dim nError As Long
  strError = Err.Description
  nError = Err.Number
  If bProgressOpened Then
    oStatusBar.CloseProgress
  End If
  If Not oLog Is Nothing Then
    oLog.LogRecords__Add__AssignProperties text:=strError, Scode:=IIf(nError < 0, nError, nError Or &HC0000000)
    oLog.CloseSubLog
  End If
  Set Common.CallContext = oCallContext_Common_Prev
  Err.Raise nError, , strError
End Function

Public Sub OfficeMenu_RecalcPopupLayout(ByVal cmdBar As CommandBar)
  Dim strText As String
  Dim oControl As CommandBarControl
  Dim collRecalcControls As New Collection
  Dim bFound As Boolean
  Dim nCaptionCharCount As Long
  Dim nWidth As Long
  nCaptionCharCount = 0
  For Each oControl In cmdBar.Controls
    bFound = oControl.Visible
    If bFound Then
      bFound = Not oControl.BuiltIn
    End If
    If bFound Then
      bFound = (InStr(1, oControl.tag, "IDL.Connector.") = 1)
    End If
    If bFound Then
      bFound = (oControl.Type = msoControlComboBox Or oControl.Type = msoControlEdit)
    End If
    If bFound Then
      strText = oControl.Caption
      If Len(strText) > nCaptionCharCount Then
        nCaptionCharCount = Len(strText)
      End If
      collRecalcControls.Add oControl
    End If
  Next oControl
  If collRecalcControls.count > 0 Then
    nWidth = 6 * (nCaptionCharCount + 35)
    For Each oControl In collRecalcControls
      oControl.Width = 250
      strText = oControl.Caption
      If Len(strText) < nCaptionCharCount Then
        oControl.Caption = strText & Space(nCaptionCharCount - Len(strText))
      End If
      oControl.Width = nWidth
    Next oControl
  End If
End Sub

Public Sub OfficeMenu_FillCombo(ByVal cmb As Office.CommandBarComboBox, ByVal rObjIDVector As Range, Optional ByVal IncludeEmptyItem As Boolean)
  Dim r As Range
  Dim rObjID As Range
  Dim strOnlineLanguage As String
  Dim nItem As Long
  Dim strText As String
  Dim strTemp As String
  cmb.Clear
  strOnlineLanguage = DataRange_Find("OnlineLanguage")
  If IncludeEmptyItem Then
    cmb.AddItem ""
    nItem = 1
  End If
  If Not rObjIDVector Is Nothing Then
    For Each rObjID In rObjIDVector
      strText = rObjID
      If InStr(1, strText, "_") > 0 Then
        strText = Replace(strText, "_", "__")
      End If
      If InStr(1, strText, " ") > 0 Then
        strText = Replace(strText, " ", "_")
      End If
      Set r = IDLLocText(rObjID.Offset(0, EnDataCols_Language + 1), strOnlineLanguage)
      strTemp = r.Value
      If strTemp <> "" Then
        strText = strText & " " & strTemp
      End If
      cmb.AddItem strText
      nItem = nItem + 1
    Next rObjID
  End If
  If nItem > 0 Then
    cmb.ListIndex = 0
  End If
End Sub

Public Sub OfficeMenu_RefreshControl(Optional ByVal CommandBar As Office.CommandBar, Optional ByRef Control As Office.CommandBarControl, Optional ByVal Name As String, Optional Value As Variant, Optional ByVal vType As Variant, Optional CallType As Variant, Optional Label As Variant, Optional uml_ex As Variant, Optional BrowseFlags As Variant, Optional ByVal Browseset As Object, Optional ControlType As Long, Optional Handler As Variant, Optional ByVal Clear As Boolean = False)
  Dim strText As String
  Dim oControl As CommandBarControl
  Dim VarType As Integer
  Dim strTag As String
  Dim strOnlineLanguage As String
  Dim bFound As Boolean
  Dim nRow As Long
  Dim strTemp As String
  Dim bOptional As Boolean
  Dim oType As Object
  Dim bRangeType As Boolean
  Dim strCaption As String
  If IsObject(vType) Then
    Set oType = vType
    If Not oType Is Nothing Then
      bRangeType = TypeOf oType Is Range
    End If
  Else
    VarType = vType
  End If
  If Name = "" Then
    If Not oType Is Nothing Then
      If TypeOf oType Is Range Then
        Name = DataRange_Name(oType)
      Else
        Name = oType.Name
      End If
    End If
  End If
  If Control Is Nothing Then
    strTag = "IDL.Connector." & Name
    Set oControl = CommandBar.FindControl(tag:=strTag)
  Else
    Set oControl = Control
    strTag = oControl.tag
    If InStr(1, strTag, "IDL.Connector.") <> 1 Then Err.Raise ERR_NOTOK
    If Not Clear Then
      strTemp = Mid$(strTag, 15)
      If strTemp = "" Then Err.Raise ERR_NOTOK
      If Name = "" Then
        Name = strTemp
      End If
    End If
  End If
  If CommandBar Is Nothing And Not oControl Is Nothing Then
    Set CommandBar = oControl.Parent
  End If
  If Clear Then
    If Not oControl Is Nothing Then
      oControl.Delete
    End If
    Set Control = Nothing
    Exit Sub
  End If
  If IsMissing(Handler) Then Err.Raise ERR_INVALIDARG
  If VBA.VarType(Handler) <> vbString Then Err.Raise E_NOTIMPL
  If Name = "" Then Err.Raise ERR_INVALIDARG
  If ControlType = 0 And Not oControl Is Nothing Then
    ControlType = oControl.Type
  End If
  If Not Browseset Is Nothing And ControlType = 0 Then
    If Browseset.count = 0 Then
      ControlType = msoControlEdit
    Else
      ControlType = msoControlComboBox
    End If
  End If
  If ControlType = 0 Then
    ControlType = msoControlEdit
  End If
  If oControl Is Nothing Then
    Set oControl = CommandBar.Controls.Add(Type:=ControlType, temporary:=True)
#If CENTRALBUILD Then
    oControl.OnAction = "KVM200_MenuOnClick"
    oControl.Parameter = "Plugins!DC.appObj.ActiveEditor." & Handler
#Else
    oControl.OnAction = Handler
#End If
  End If
  oControl.tag = strTag
  If Not IsMissing(uml_ex) Then
    If (uml_ex And EnUmlEx_OPTIONAL) <> 0 Then
      bOptional = True
    End If
  End If
  If Not IsMissing(BrowseFlags) Then
    If (BrowseFlags And EnBrowseFlagsNullable) <> 0 Then
      bOptional = True
    End If
  End If
  If Not IsMissing(Label) Then
    strCaption = Label
  End If
  If strCaption = "" Then
    If Not oType Is Nothing Then
      If bRangeType Then
        strOnlineLanguage = DataRange_Find("OnlineLanguage")
        strCaption = IDLLocText(oType.Offset(0, EnDataCols_Language + 1), strOnlineLanguage)
      Else
        strCaption = oType.BENE
      End If
    End If
    If strCaption = "" Then
      strCaption = Name
    End If
  End If
  If ControlType = msoControlComboBox Then
    OfficeMenu_FillCombo oControl, Browseset, IncludeEmptyItem:=bOptional
  End If
  oControl.Caption = strCaption
  If IsArray(Value) Then
    oControl.text = "<" & SearchTextInSPR(396) & ">"
  Else
    If IsMissing(Value) Then
      strText = ""
    Else
      strText = CStr(Value)
    End If
    bFound = False
    If ControlType = msoControlComboBox Then
      For nRow = 1 To oControl.ListCount
        strTemp = oControl.List(nRow)
        If InStr(1, strTemp, strText, vbTextCompare) = 1 Then
          strTemp = Mid$(strTemp, Len(strText) + 1, 1)
          If strTemp = "" Or strTemp = " " Then
            oControl.ListIndex = nRow
            bFound = True
            Exit For
          End If
        End If
      Next nRow
    End If
    If Not bFound Then
      oControl.text = strText
    End If
  End If
  Set Control = oControl
End Sub

Public Sub RefreshCellContextMenu()
  Dim vntData As Variant
  Dim oControl As CommandBarControl
  Dim vntTemp As Variant
  Dim cmdBarTemp As CommandBar
#If CENTRALBUILD = 0 Then
  Dim bVisible_InsertDetailLines As Boolean, bVisible_DeleteDetailLines As Boolean
  Dim strText As String
  bVisible_InsertDetailLines = InsertDeleteDetailLinesImpl(bCheckOnly:=True, bDelete:=False)
  bVisible_DeleteDetailLines = InsertDeleteDetailLinesImpl(bCheckOnly:=True, bDelete:=True)
  For Each vntTemp In Array("Cell", "Row", "Column")
    Set cmdBarTemp = Application.CommandBars(vntTemp)
    Set oControl = cmdBarTemp.FindControl(tag:="CON__372")
    If Not oControl Is Nothing Then
      oControl.Visible = bVisible_InsertDetailLines
    End If
    Set oControl = cmdBarTemp.FindControl(tag:="CON__373")
    If Not oControl Is Nothing Then
      oControl.Visible = bVisible_DeleteDetailLines
    End If
  Next vntTemp
#End If
  Dim oDetailEditor As CRangeGrid
  Dim o As Object
  Set o = EditorFromActiveSheet
  If Not o Is Nothing Then
    If TypeOf o Is CRangeGrid Then
      Set oDetailEditor = o
      oDetailEditor.RefreshCellContextMenu
    ElseIf o Is Me Then
#If CENTRALBUILD = 0 Then
      Set oDetailEditor = m_oGridKTOSAL
#End If
#If CENTRALBUILD Then
      If Version >= 8 Then
        If Version < 12 Then
          Dim bVisible_BemerkEdit As Boolean
          For Each vntTemp In Array("Cell", "Row", "Column")
            Set cmdBarTemp = Application.CommandBars(vntTemp)
            bVisible_BemerkEdit = OnBemerkEditImpl(True, vntData)
            Set oControl = Nothing
            OfficeMenu_RefreshControl CommandBar:=cmdBarTemp, Control:=oControl, vType:=DataRange_Find("FIE__K034-BEMERK"), Value:=vntData, Handler:="OnBemerkEdit"
            oControl.Visible = bVisible_BemerkEdit
          Next vntTemp
        Else
          Set oDetailEditor = m_oGridKTOSAL
        End If
      End If
#End If
    End If
  End If
  If Not oDetailEditor Is Nothing Then
    oDetailEditor.RefreshCellContextMenu
#If CENTRALBUILD = 0 Then
  For Each vntTemp In Array("Cell", "Row", "Column")
    Set cmdBarTemp = Application.CommandBars(vntTemp)
    OfficeMenu_RecalcPopupLayout cmdBarTemp
  Next vntTemp
#End If
  End If
End Sub

Public Function OnBemerkEditImpl_Range(ByVal oEditor As CRangeGrid, ByVal rObjIDs As Range, ByVal bCheckOnly As Boolean, ByRef vntData As Variant) As Boolean
  Dim r As Range
  Dim rObjID As Range
  Dim strText As String
  Dim strTextComment As String
  Dim bProtect As Boolean
  Dim oComment As Comment
  Dim oShape As Excel.Shape
  Dim oDrawingObject As Excel.TextBox
  Dim nError As Long, strError As String, strSource As String
  Dim i As Long
  Dim ws As Worksheet
  Dim bScreenUpdating_prev As Boolean
  Dim bScreenUpdatingChanged As Boolean
  On Error GoTo ErrHandler
  If bCheckOnly Then
    vntData = Empty
  Else
    strText = Trim(vntData)
    If Len(strText) > 35 Then
      strText = Left$(strText, 35)
    End If
    If Left$(strText, 1) = "=" Then
      strText = "_" & Mid$(strText, 2)
    End If
  End If
  For Each rObjID In rObjIDs
    If rObjID.EntireRow.Hidden Then GoTo NextValue
    If m_nCountAddDetailInfos > 0 And rObjID.Column >= NColAddDetailsFirst Then
      Set r = rObjID
    Else
      Set r = rObjID.Offset(0, NColActValue - rObjID.Column)
    End If
    Set oComment = r.Comment
    If oComment Is Nothing Then
      strTextComment = ""
    Else
      strTextComment = Trim(oComment.text)
      If Left$(strTextComment, 1) = "=" Then GoTo NextValue
    End If
    If bCheckOnly Then
      If IsEmpty(vntData) Then
        vntData = strTextComment
      ElseIf VarType(vntData) = vbString Then
        If strTextComment <> vntData Then
          vntData = Array(vntData, strTextComment)
          Exit For
        End If
      End If
    Else
      If Not bProtect Then
        Set ws = rObjID.Worksheet
        If ws.ProtectContents Then
          If oEditor Is Nothing Then
            Unprotect
          Else
            oEditor.Unprotect
          End If
          bProtect = True
        End If
      End If
      If Not bScreenUpdatingChanged Then
        bScreenUpdating_prev = Application.ScreenUpdating
        Application.ScreenUpdating = False
        bScreenUpdatingChanged = True
      End If
      If Not oComment Is Nothing Then
        r.ClearComments
      End If
      If strText <> "" Then
        Set oComment = r.AddComment(strText)
        Set oShape = oComment.Shape
        Set oDrawingObject = oShape.DrawingObject
        oDrawingObject.Locked = False
        oDrawingObject.LockedText = True
        oDrawingObject.AutoSize = True
        oShape.Placement = xlMove
      End If
    End If
NextValue:
  Next rObjID
  If bCheckOnly Then
    OnBemerkEditImpl_Range = Not IsEmpty(vntData)
  End If
Cleanup:
  If bScreenUpdatingChanged Then
    Application.ScreenUpdating = bScreenUpdating_prev
    bScreenUpdatingChanged = False
  End If
  If bProtect Then
    If oEditor Is Nothing Then
      Protect
    Else
      oEditor.Protect
    End If
    bProtect = False
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next
  GoTo Cleanup
End Function

Public Function EditorFromWorksheet(ByVal ws As Worksheet) As Object
  Dim oEditor As CRangeGrid
  If Not ws Is Nothing Then
    If ws.Name = m_worksheet.Name Then
      Set EditorFromWorksheet = Me
    Else
      For Each oEditor In DetailSheets
        If oEditor.Valid Then
          If oEditor.Worksheet.Name = ws.Name Then
            Set EditorFromWorksheet = oEditor
            Exit For
          End If
        End If
      Next oEditor
    End If
  End If
End Function

Private Function EditorFromActiveSheet() As Object
  Dim o As Object
  Dim ws As Worksheet
  Set o = ActiveSheet
  If Not o Is Nothing Then
    If TypeOf o Is Worksheet Then
      Set ws = o
    End If
  End If
  If Not ws Is Nothing Then
    Set EditorFromActiveSheet = EditorFromWorksheet(ws)
  End If
End Function

Public Sub KTOSAL_InvokeBound(ByVal CallType As Long, ByVal Bookmark As Range, ByVal Member As Long, ByRef vntData As Variant, ByRef rbProtectWS As Boolean, ByRef bChanged As Boolean)
  Dim rObjIdsData As Range
  Dim r As Range
  Dim nRow As Long
  Dim nRowEnd As Long
  Dim rTemp As Range
  Dim bFound As Boolean
    Set rObjIdsData = DataRange_Find("KTO")
    If Not rObjIdsData Is Nothing Then
      Set r = m_oGridKTOSAL.LowerBound(rObjIdsData, Bookmark.Value, 0, rObjIdsData.count, bFound)
      If Not r Is Nothing Then
        nRowEnd = rObjIdsData.Cells(1, 1).Row + rObjIdsData.count
        nRow = r.Row
        bFound = False
        Do While nRow < nRowEnd
          Set rTemp = EvalRefCell(r.Offset(0, EnDataCols_BilGUVKnz - EnDataCols_ObjID)).Offset(0, NColObjID - NColBilGuVKnz)
          If rTemp.Row = Bookmark.Row Then
            bFound = True
            Set r = r.Offset(0, EnDataCols_Flags - EnDataCols_ObjID)
            Exit Do
          End If
          If r.Value <> Bookmark.Value Then
            Exit Do
          End If
          Set r = r.Offset(1, 0)
          nRow = nRow + 1
        Loop
        If Not bFound Then
          Set r = Nothing
        End If
      End If
    End If
    If (CallType And VbLet) <> 0 Then
      If r Is Nothing Then
        Err.Raise E_NOTIMPL
      Else
        r.Value = vntData
      End If
    ElseIf (CallType And VbGet) <> 0 Then
      If Not r Is Nothing Then
        vntData = r.Value
      End If
    Else
      If Not r Is Nothing Then
        Set vntData = r
      End If
    End If
End Sub

Private Function InsertDeleteDetailLinesImpl(ByVal bCheckOnly As Boolean, ByVal bDelete As Boolean, Optional ByVal SelectedRange As Excel.Range) As Boolean
  Dim o As Object
  Dim oDetailEditor_Inner As Object
  Dim oDetailEditor As CRangeGrid
  Set o = EditorFromActiveSheet
  If Not o Is Nothing Then
    If o Is Me Then
#If CENTRALBUILD Then
      If m_bMasterMode Then
        If bCheckOnly Then
          InsertDeleteDetailLinesImpl = MasterMode
        Else
          InsertDeleteDetailLinesImpl_this bDelete, SelectedRange
        End If
      End If
#End If
    Else
      Set oDetailEditor = o
#If CENTRALBUILD Then
      Set oDetailEditor_Inner = oDetailEditor.This_Decentral
      If m_nVersion < 8 Then Exit Function
#Else
     Set oDetailEditor_Inner = oDetailEditor
#End If
      If bDelete Then
        If bCheckOnly Then
          InsertDeleteDetailLinesImpl = oDetailEditor_Inner.DeleteDetailLines__Enabled(SelectedRange)
        Else
          oDetailEditor_Inner.DeleteDetailLines SelectedRange
        End If
      Else
        If bCheckOnly Then
          InsertDeleteDetailLinesImpl = oDetailEditor_Inner.InsertDetailLines__Enabled(SelectedRange)
        Else
          oDetailEditor_Inner.InsertDetailLines SelectedRange
        End If
      End If
    End If
  End If
End Function

Public Property Get InsertDetailLines__Enabled(Optional ByVal SelectedRange As Excel.Range) As Boolean
  InsertDetailLines__Enabled = InsertDeleteDetailLinesImpl(bCheckOnly:=True, bDelete:=False, SelectedRange:=SelectedRange)
End Property

Public Sub InsertDetailLines(Optional ByVal SelectedRange As Excel.Range)
  InsertDeleteDetailLinesImpl bCheckOnly:=False, bDelete:=False, SelectedRange:=SelectedRange
End Sub

Public Property Get DeleteDetailLines__Enabled(Optional ByVal SelectedRange As Excel.Range) As Boolean
  DeleteDetailLines__Enabled = InsertDeleteDetailLinesImpl(bCheckOnly:=True, bDelete:=True, SelectedRange:=SelectedRange)
End Property

Public Sub DeleteDetailLines(Optional ByVal SelectedRange As Excel.Range)
  InsertDeleteDetailLinesImpl bCheckOnly:=False, bDelete:=True, SelectedRange:=SelectedRange
End Sub

Public Property Get MitKstSal() As Long
  MitKstSal = m_nMitKstSal
End Property

Private Sub ReloadCombo(ByVal cmb As ComboBox, tag As String)
  Dim r As Range
  Dim i As Long
  Set r = DataRange_Find(tag, i)
  FillCombo cmb, r
End Sub

Friend Function Combo_GetSelectedKey(ByVal cmb As MSForms.ComboBox, ByVal rObjIDVector As Range, Optional ByVal IncludeEmptyItem As Boolean) As Variant
  Dim i As Long
  Dim vntText As Variant
  
  i = cmb.ListIndex
  
  If IncludeEmptyItem Then
    If i = 0 Then
      i = i - 1
    End If
  End If
  If i >= 0 Then
    Combo_GetSelectedKey = RangeMulti_Item(rObjIDVector, i)
  End If

End Function

Private Sub RefreshWSControls(ByVal Sh As Worksheet)
  Dim o As OLEObject
  Dim obj As Object
  Dim cmb As Object
  Dim oComment As Comment
  Dim strTemp As String
  For Each o In Sh.OLEObjects
    Set obj = Nothing
    On Error Resume Next
    Set obj = o.Object
    On Error GoTo 0
    If Not obj Is Nothing Then
      If TypeOf obj Is ComboBox Then
        Set cmb = obj
        strTemp = cmb.LinkedCell
        If strTemp <> "" Then
          Set oComment = Sh.Range(strTemp).Comment
          If Not oComment Is Nothing Then
            ReloadCombo o.Object, oComment.text
          End If
        End If
      End If
    End If
  Next o
End Sub

Public Sub RefreshControls()
  Dim ws As Worksheet
  For Each ws In Parent.Worksheets
    RefreshWSControls ws
  Next ws
End Sub

Private Sub SetWSName_IgnoreErrors(ByVal ws As Worksheet, strName As String)
  On Error Resume Next
 If IsOffice97 Then
    Dim nCalcPrev As Long
    nCalcPrev = Application.Calculation
    Application.Calculation = xlCalculationManual
    ws.EnableCalculation = False
    ws.Name = strName
    Application.Calculation = nCalcPrev
    ws.EnableCalculation = True
  Else
    ws.Name = strName
  End If
End Sub

Private Sub AdjustDetailsWSName()
  Dim bProtectWB As Boolean
  Dim rDetails As Range, rDetail As Range
  Dim ws As Worksheet
  Dim r As Range
  Dim strName As String
  Dim nError As Long, strError As String
  Dim i As Long
  Dim strOnlineLanguage As String
  Dim wb As Workbook
  Set wb = m_worksheet.Parent
  Set rDetails = DataRange_Find("Detailsheets", i)
  strOnlineLanguage = DataRange_Find("OnlineLanguage")
  For Each rDetail In rDetails
    Set r = rDetail.Offset(0, 1)
    Set r = EvalRefCell(r, bIgnoreErrors:=True)
    If Not r Is Nothing Then
      Set ws = r.Worksheet
      Set r = IDLLocText(rDetail.Offset(0, EnDataCols_Language + 1), strOnlineLanguage)
      strName = r.Value
      If Len(strName) > 31 Then
        strName = Left$(strName, 31)
      End If
      If strName <> ws.Name Then
        If wb.ProtectStructure Then
          UnprotectWB
          bProtectWB = True
        End If
        SetWSName_IgnoreErrors ws, strName
      End If
    End If
  Next rDetail
Cleanup:
  If bProtectWB Then
    ProtectWB
    bProtectWB = False
  End If
  If nError <> 0 Then
    Err.Raise nError, , strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  GoTo Cleanup
End Sub

Public Sub AssignOnlineLanguage_Decentral(strSprache As String)
  Dim r As Range
  Set r = DataRange_Find("OnlineLanguage")
  If r.Value <> strSprache Then
    r.Value = strSprache
    Ambients__PropertyChanged__LocaleID
    RefreshControls
  End If
End Sub

Private Sub UpdateOfficeMenuText(ByVal oElement As Object, strLanguage As String)
  Dim strTag As String
  Dim oInnerElement As Object
  Dim r As Range
  Dim i As Long
  strTag = Trim$(oElement.tag)
  If strTag <> "" And Not oElement.BuiltIn Then
    Set r = DataRange_Find(strTag, i)
    If i = 1 Then
      oElement.Caption = IDLLocText(r.Offset(0, EnDataCols_Language + 1), strLanguage)
    End If
  End If
  If TypeOf oElement Is Office.CommandBarPopup Or TypeOf oElement Is Office.CommandBar Then
    For Each oInnerElement In oElement.Controls
      UpdateOfficeMenuText oInnerElement, strLanguage
    Next oInnerElement
  End If
End Sub

Private Sub UpdateMenuBarText(ByVal oMenuBar As CommandBar)
  Dim oControl As Office.CommandBarControl
  Dim rLng As Range
  Set rLng = DataRange_Find("OnlineLanguage")
  For Each oControl In oMenuBar.Controls
    UpdateOfficeMenuText oControl, rLng.Value
  Next oControl
End Sub

Private Function AddContextmenu(ByVal cmd As CommandBar, ByVal bWorksheetContext As Boolean, ByVal bRemove As Boolean) As Object
  Dim oControl As CommandBarControl
  Dim oButton As CommandBarButton
  Set oControl = cmd.FindControl(tag:="CON__372")
  If Not oControl Is Nothing Then
    oControl.Delete
  End If
  Set oControl = cmd.FindControl(tag:="CON__373")
  If Not oControl Is Nothing Then
    oControl.Delete
  End If
  If Not bRemove And Not bWorksheetContext Then
    Set AddContextmenu = cmd.Controls.Add(temporary:=True)
    With AddContextmenu
      .tag = "CON__372"
      .style = msoButtonIconAndCaption
      .OnAction = "InsertDetailLines"
    End With
    With cmd.Controls.Add(temporary:=True)
      .tag = "CON__373"
      .style = msoButtonIconAndCaption
      .OnAction = "DeleteDetailLines"
    End With
  End If
End Function

Public Sub MenuBarDecentral__Load(ByVal oMenuBar As CommandBar, ByVal bUnload As Boolean)
  Dim oPopup As CommandBarPopup
  Dim oPopupInner As CommandBarPopup
  Dim vntLanguage As Variant
  Dim nCountDetails As Long
  Dim rDetail As Range, rDetails As Range
  Dim vntTemp As Variant
  Dim cmdBarTemp As CommandBar
  Dim btnTemp As CommandBarControl
  If Not bUnload Then
    Set oPopup = oMenuBar.Controls.Add(Type:=msoControlPopup)
    oPopup.tag = "CON__305"
    Set rDetails = DataRange_Find("Detailsheets_Enabled", nCountDetails)
    If rDetails Is Nothing Then
      Set rDetails = DataRange_Find("DetailSheets", nCountDetails)
    End If
    If nCountDetails > 0 Then
      For Each rDetail In rDetails
        Set oPopupInner = oPopup.Controls.Add(Type:=msoControlPopup)
        oPopupInner.tag = "'" & rDetail.Worksheet.Name & "'!" & rDetail.Address
        With oPopupInner.Controls.Add
          .tag = "CON__307"
          .FaceId = 1561
          .style = msoButtonIconAndCaption
          .OnAction = "AdjustDetails__ExcelUI"
          .Parameter = rDetail.Value
        End With
      Next rDetail
    End If
    nCountDetails = 0
    Set rDetails = DataRange_Find("SPR_Enabled", nCountDetails)
    If rDetails Is Nothing Then
      Set rDetails = DataRange_Find("SPR", nCountDetails)
    End If
    If nCountDetails > 1 Then
      Set oPopup = oMenuBar.Controls.Add(Type:=msoControlPopup)
      oPopup.tag = "CON__71"
      For Each rDetail In rDetails
        vntLanguage = rDetail.Value
        With oPopup.Controls.Add
          .tag = "SPR__" & vntLanguage
          .OnAction = "AssignOnlineLanguage_MenuClick"
          .Parameter = vntLanguage
          .style = msoButtonIconAndCaption
        End With
      Next rDetail
    End If
    With oMenuBar.Controls.Add
      .tag = "CON__309"
      .FaceId = 488
      .OnAction = "InsertNoticeSheet"
      .style = msoButtonIconAndCaption
    End With
    UpdateMenuBarText oMenuBar
  End If
  For Each vntTemp In Array("Cell", "Row", "Column", "Ply")
    Set cmdBarTemp = Application.CommandBars(vntTemp)
    Set btnTemp = AddContextmenu(cmdBarTemp, bWorksheetContext:=(vntTemp = "Ply"), bRemove:=bUnload)
    If Not btnTemp Is Nothing Then
      btnTemp.BeginGroup = True
    End If
    If Not bUnload Then
      UpdateMenuBarText cmdBarTemp
    End If
  Next vntTemp
End Sub

Public Property Get DetailSheet_IsAddDetail(ByVal oDetailSheet As CRangeGrid, ByVal rObjID As Range) As Boolean
  Dim r As Range
  Dim nBilGuVKnz As Integer
  Dim bIsAddDetail As Boolean
  Dim vntDataFlags As Variant, vntName As Variant
  Set r = rObjID.Offset(0, NColBilGuVKnz - rObjID.Column)
  If m_nMitKstSal >= 0 Then
    nBilGuVKnz = CInt(r.Value)
    bIsAddDetail = (m_nMitKstSal <= 1 And (nBilGuVKnz = 1 Or nBilGuVKnz = 2 Or nBilGuVKnz = 3 Or nBilGuVKnz = 4 Or nBilGuVKnz = 5 Or nBilGuVKnz = 8 Or nBilGuVKnz = 9) Or m_nMitKstSal = 2 And nBilGuVKnz >= 1 And nBilGuVKnz <= 9)
    If bIsAddDetail Then
      If oDetailSheet Is m_oGridKTOSAL Then
        vntName = "DataFlags"
        m_oGridKTOSAL.InvokeRange VbGet, vntName, vntDataFlags, Selection:=rObjID, bNoHitTest:=True
      Else
        Set r = rObjID.Offset(0, NColObjID - rObjID.Column)
        Do While oDetailSheet.KeyLevelImpl(r) > 0
          Set r = r.Offset(-1, 0)
        Loop
        Set r = EvalRefCell(r)
        If r Is Nothing Then
          bIsAddDetail = False
        Else
          Set r = r.Offset(0, EnDataCols_Flags - EnDataCols_ObjID)
          vntDataFlags = r.Value
        End If
      End If
      bIsAddDetail = ((vntDataFlags And EnDataFlags_Kst_DetailDisabled) = 0)
    End If
    DetailSheet_IsAddDetail = bIsAddDetail
  Else
    Set r = r.Offset(0, 2)
    DetailSheet_IsAddDetail = (r.Value = "C")
  End If
End Property

Public Property Get Parent() As Object
  Set Parent = m_worksheet.Parent
End Property

Public Function Begin() As Object
  Set Begin = m_oGridKTOSAL.Begin
End Function

Public Function DetailSheets_Find(CodeName As String) As CRangeGrid
  On Error Resume Next
  Set DetailSheets_Find = m_collDetailSheets(CodeName)
End Function

Public Property Get DetailSheets() As Collection
  Set DetailSheets = m_collDetailSheets
End Property

Public Sub Clear()
  Dim oDetail As CRangeGrid
  Set m_worksheet = Nothing
  Set m_datasheet = Nothing
  If Not m_oGridKTOSAL Is Nothing Then
    m_oGridKTOSAL.Clear
    Set m_oGridKTOSAL = Nothing
  End If
  For Each oDetail In m_collDetailSheets
    oDetail.Clear
  Next oDetail
  Set m_collDetailSheets = Nothing
#If CENTRALBUILD Then
  Set m_oIDLAddin = Nothing
#End If
End Sub

Private Sub AttachDetails(ByVal wb As Workbook)
  Dim rDetails As Range
  Dim rObjID As Range
  Dim r As Range
  Dim nCountDetails As Long
  Dim strClassName As String
  Dim wsDetail As Worksheet
  Dim oDetailEditor As CRangeGrid

  Dim bSystemChange As Boolean
  Dim nError As Long, strError As String, strSource As String

  On Error GoTo ErrHandler

#If CENTRALBUILD Then
  If m_nVersion <= 4 Then
    AttachDetails__V1_4 wb
    Exit Sub
  End If
#End If
  Set r = DataRange_Find("AddDetails", nCountDetails)
  If nCountDetails = 1 Then
    Set r = r.Offset(0, 1)
    Set m_AddDetailVector = DataRange_Find(r.Value, m_nCountAddDetailInfos)
  Else
    Set m_AddDetailVector = DataRange_Find("NullRange", m_nCountAddDetailInfos)
  End If
  Set m_collDetailSheets = Nothing
  Set rDetails = DataRange_Find("Detailsheets_Enabled", nCountDetails)
  If rDetails Is Nothing Then
    Set rDetails = DataRange_Find("Detailsheets", nCountDetails)
  End If
  If nCountDetails > 0 Then
    For Each rObjID In rDetails
      strClassName = rObjID.Value
      If strClassName = "K066" Then strClassName = "KTOSAL"
      If strClassName <> "KTOSAL" Then
        Set r = EvalRefCell(rObjID.Offset(0, 1), bIgnoreErrors:=True)
        If r Is Nothing Then
          Set wsDetail = Nothing
        Else
          Set wsDetail = r.Worksheet
        End If
        Set oDetailEditor = New CRangeGrid
        oDetailEditor.Init wsDetail, Me, strClassName
        oDetailEditor.DataRange_read rObjID 'serialisierte Informationen einlesen


        If wsDetail Is ActiveSheet Then
          g_nSystemChangeCounter = g_nSystemChangeCounter + 1
          bSystemChange = True
          oDetailEditor.OnActivationChange True
          g_nSystemChangeCounter = g_nSystemChangeCounter - 1
          bSystemChange = False
        End If



        m_collDetailSheets.Add oDetailEditor, UCase(strClassName)
      End If
    Next rObjID
  End If

Cleanup:
  If bSystemChange Then
    g_nSystemChangeCounter = g_nSystemChangeCounter - 1
    bSystemChange = False
  End If
  
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Sub
ErrHandler:
  Debug.Assert False
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next

  GoTo Cleanup
  Resume
End Sub

Public Sub OnContextMenuClick()
  Dim o As Object
  Dim oDetailEditor As CRangeGrid
  On Error GoTo ErrHandler
#If CENTRALBUILD Then
  Dim oControl As CommandBarControl
  Set oControl = Application.CommandBars.ActionControl
  If m_nVersion <= 8 And Standalone Then
    If oControl.tag = "IDL.Connector.BuchgsText" Then
      This_Decentral.OnBemerkEdit
      Exit Sub
    End If
  End If
#End If
  Set o = EditorFromActiveSheet
  If Not o Is Nothing Then
    If TypeOf o Is CRangeGrid Then
      Set oDetailEditor = o
      oDetailEditor.OnContextMenuClick
    ElseIf o Is Me Then
      m_oGridKTOSAL.OnContextMenuClick
    End If
  End If
  Exit Sub
ErrHandler:
  ShowErrDialog Err.Number, Err.Description, Err.Source
End Sub

Public Sub OnUpdateUI()
  Dim oDetailEditor As CRangeGrid
  If g_nSystemChangeCounter > 0 Then
    Exit Sub
  End If
  CheckDragAndDropMode bUpdateOnly:=True
End Sub

Private Sub CheckDragAndDropMode(Optional ByVal bUpdateOnly As Boolean = False)
  Dim bAllowCut As Boolean
  Dim bDragAndDropAct As Boolean
  Exit Sub
  bAllowCut = False
#If CENTRALBUILD Then
  bAllowCut = m_bMasterMode
#End If
  bDragAndDropAct = Application.CellDragAndDrop
  If Not m_oActiveGrid Is Nothing Then
    If bDragAndDropAct <> bAllowCut Then
      Application.CellDragAndDrop = bAllowCut
    End If
    If Not bUpdateOnly Then
      If Not m_bCellDragAndDrop_prev Then
        m_bCellDragAndDrop_prev = bDragAndDropAct
      End If
    End If
  ElseIf bUpdateOnly Then
    If m_bCellDragAndDrop_prev Then
      Application.CellDragAndDrop = m_bCellDragAndDrop_prev
      m_bCellDragAndDrop_prev = False
    End If
  Else
    If m_bCellDragAndDrop_prev <> bDragAndDropAct Then
      Application.CellDragAndDrop = m_bCellDragAndDrop_prev
      m_bCellDragAndDrop_prev = False
    End If
  End If
  If Not m_oActiveGrid Is Nothing Then
    If Not bAllowCut Then
      If Application.CutCopyMode = xlCut Then
        On Error Resume Next
        Application.CutCopyMode = False
        On Error GoTo 0
      End If
    End If
  End If
End Sub

Public Property Get IsEditWorkbookActive() As Boolean
  IsEditWorkbookActive = m_bEditWorkbookActive
End Property

Private Sub OnActivationChange_Grid(ByVal Grid As CRangeGrid, ByVal bActivate As Boolean)
  Grid.OnActivationChange bActivate
  If bActivate Then
    Set m_oActiveGrid = Grid
  Else
    Set m_oActiveGrid = Nothing
  End If
  #If CENTRALBUILD Then
    OnActivationChange_Grid_Central Grid, bActivate
    CheckDragAndDropMode bUpdateOnly:=False
  #Else
    If ThisPlugin.MenuEnabled Then
      CheckDragAndDropMode bUpdateOnly:=False
    End If
  #End If
End Sub

Private Sub OnActivationChange_Workbook(ByVal bActivate As Boolean)
  m_bEditWorkbookActive = bActivate
   AdjustNumberSeparator bActivate
End Sub

Public Sub OnActivationChange(Optional ByVal bActivate As Boolean = True, Optional ByVal wsContext As Worksheet)
  Dim oEditor As Object
  Dim oDetailEditor As CRangeGrid, oDetailEditorTemp As CRangeGrid
  Dim wb As Workbook
  Dim vntTemp As Variant
  Dim bWorkbookIsActiveTemp As Boolean
  Dim ws As Worksheet

  If wsContext Is Nothing Then
    Set wb = m_worksheet.Parent
    Set ws = wb.ActiveSheet
  Else
    Set wb = m_worksheet.Parent
    Set ws = wsContext
  End If
  bWorkbookIsActiveTemp = (StrComp(ActiveWorkbook.FullName, wb.FullName, vbTextCompare) = 0)
  If bWorkbookIsActiveTemp Then
    Set oEditor = EditorFromWorksheet(ws)
  End If
  If Not oEditor Is Nothing Then
    If oEditor Is Me Then
      If Not bActivate Then
        For Each vntTemp In Array("Cell", "Row", "Column")
          OfficeMenu_RefreshControl CommandBar:=Application.CommandBars(vntTemp), vType:=DataRange_Find("FIE__K034-BEMERK"), Clear:=True
        Next vntTemp
      End If
#If CENTRALBUILD = 0 Then
      If bActivate Then
        CheckSelectionStatusDecentral_Impl
      End If
#End If
      Set oDetailEditor = m_oGridKTOSAL
    ElseIf TypeOf oEditor Is CRangeGrid Then
      Set oDetailEditor = oEditor
    End If
    If Not oDetailEditor Is Nothing Then
      If bActivate Then
        If Not m_oGridKTOSAL Is oDetailEditor Then
          If m_oGridKTOSAL.IsActive Then
            OnActivationChange_Grid m_oGridKTOSAL, False
          End If
        End If
        For Each oDetailEditorTemp In m_collDetailSheets
          If Not oDetailEditorTemp Is oDetailEditor Then
            If oDetailEditorTemp.IsActive Then
              OnActivationChange_Grid oDetailEditorTemp, False
            End If
          End If
        Next oDetailEditorTemp
      End If
      If oDetailEditor.IsActive <> bActivate Then
        OnActivationChange_Grid oDetailEditor, bActivate
      End If
    End If
  Else
    If Not m_oGridKTOSAL Is Nothing Then
      If m_oGridKTOSAL.IsActive Then
        OnActivationChange_Grid m_oGridKTOSAL, False
      End If
    End If
    For Each oDetailEditor In m_collDetailSheets
      If oDetailEditor.IsActive Then
        OnActivationChange_Grid oDetailEditor, False
      End If
    Next oDetailEditor
  End If
  If Not bActivate Then
    bWorkbookIsActiveTemp = False 'ggf. noch aktiv, daher Annahme, dass anschliessend inaktiv
  End If

  If bWorkbookIsActiveTemp <> m_bEditWorkbookActive Then
    If bActivate Or wsContext Is Nothing Then 'Blattdeaktivierung nicht beachten
      OnActivationChange_Workbook bWorkbookIsActiveTemp
    End If
  End If

End Sub

Public Sub Details_MoveNext(ByVal oRangeNode As CRangeNode, ByVal oParam As Object)
  Dim oDetailEdtor As CRangeGrid
  Dim strClassName As String
  Dim nMemberDetailKnz As Long
  Dim strDetailKnz As String
  Dim bFound As Boolean
  Dim vntActValue As Variant
  Dim r As Range
  Dim bIncludeEmptyAmount As Boolean
  Set oDetailEdtor = oParam
  strClassName = oDetailEdtor.TypeName
  If (strClassName = "ICKTOSAL" Or strClassName = "ICBEW") Then
    nMemberDetailKnz = oRangeNode.PropertiesNameToIndex("KtoKnz1")
  Else
    nMemberDetailKnz = oRangeNode.PropertiesNameToIndex("KtoKnz2")
  End If
  Do While Not oRangeNode.EOF
    strDetailKnz = oRangeNode(nMemberDetailKnz)
    bFound = False
    Select Case strClassName
      Case "KSTSAL"
        bFound = DetailSheet_IsAddDetail(m_oGridKTOSAL, oRangeNode.TopLeft)
      Case "ICKTOSAL"
        bFound = ((strDetailKnz = "I") Or (strDetailKnz = "J"))
      Case "ICBEW"
        bFound = (strDetailKnz = "V")
      Case "SPIBEW", "ANLBEW", "RUEBEW"
        bFound = (strDetailKnz = oDetailEdtor.spi)
      Case "KAPBEW"
        bFound = (strDetailKnz = oDetailEdtor.spi)
        If Not bFound Then
          bFound = (strDetailKnz = "L" And oDetailEdtor.spi = "K") 'Hack: Pseudo L Konto
        End If
    End Select
    If Not bFound Then GoTo ContinueFor
    If oRangeNode.TopLeft.EntireRow.Hidden Then GoTo ContinueFor
    If r.Locked And Not r.HasFormula Then GoTo ContinueFor
    If Not bIncludeEmptyAmount Then
      If IsEmpty(vntActValue) Then GoTo ContinueFor
    End If
    Exit Do
ContinueFor:
    oRangeNode.MoveNext
  Loop
End Sub

Public Property Get Password2() As String
  Password2 = WorkBook_Password
End Property

Public Sub Init(ByVal wb As Workbook)
    On Error GoTo ErrHandler
#If CENTRALBUILD Then
  If Not CheckSaldenWorkbook(wb, bInit:=True) Then
    Err.Raise ERR_INVALIDARG
  End If
#End If
#If CENTRALBUILD = 0 Or (CENTRALBUILD = 1 And SUPPORT_DESIGNMODE = 1) Then
  Dim wsDatasheet As Worksheet
  Dim r As Range
#If CENTRALBUILD Then
  If Standalone Then
    Set m_oGridKTOSAL = New CRangeGrid
    m_oGridKTOSAL.Init m_worksheet, Me, "KTOSAL"
    Exit Sub
  End If
#End If
  Set wsDatasheet = FindWSByName(wb, DATASHEET_NAME)
  If wsDatasheet Is Nothing Then Err.Raise ERR_NOTOK, "Data sheet not found - may be report file corrupt"
  Set r = wsDatasheet.Range("ClassSheet")
  Set r = EvalRefCell(r)
  Set m_worksheet = r.Worksheet
  Set m_datasheet = wsDatasheet
  Set m_oGridKTOSAL = New CRangeGrid
  m_oGridKTOSAL.Init m_worksheet, Me, "KTOSAL"
  Set r = DataRange_Find("MitKSTSAL")
  If r Is Nothing Then
    m_nMitKstSal = -1
  Else
    m_nMitKstSal = CInt(r.Value)
  End If
  AttachDetails wb
#End If
  Exit Sub
ErrHandler:
  Err.Raise Err.Number, , Err.Description
End Sub


Private Function FindWSByName(ByVal wb As Workbook, Name As String) As Worksheet
  Dim ws As Worksheet
  Dim strName As String
  strName = UCase$(Name)
  For Each ws In wb.Worksheets
    If UCase$(ws.Name) = strName Then
      Set FindWSByName = ws
      Exit Function
    End If
  Next ws
End Function





'liefert Summenformel aus QuellRanges mit Summierung in Zielbereich
'R|fffd|ckgabe: Formel in R1C1 Notation
'implementiert f|fffd|r DetailCreate.finishCarryForward und Aufrissblatt bei alternativem Ergebnisvortrag
Friend Function createFormulaCarryForward(ByVal rKtoDestination As Range, ByVal rKtoSource As Range, Optional ByVal rFormulaContext As Range) As String
  Dim nCollOffset As Long
  Dim nColSource As Long
  Dim strFormula As String
  Dim rObjID As Range
  Dim strPrefix As String
  'Application.ConvertFormula strFormulaAct, xlR1C1, xlA1, toAbsolute:=xlAbsolute, RelativeTo:=r
  
  Debug.Assert rKtoDestination.count = 1
  'Summierung |fffd|ber Ergebnisvortrag
  nColSource = rKtoSource.Column
  nCollOffset = nColSource - rKtoDestination.Column
  
  If Not rFormulaContext Is Nothing Then
    nCollOffset = nColSource - rFormulaContext.Column
    strPrefix = "'" & rKtoDestination.Worksheet.Name & "'!"
  End If
  
'  If nCollOffset <> 0 Then
    'Eigene Zelle bei Vortragssummierung hinzuf|fffd|gen
    Set rKtoDestination = rKtoDestination.Offset(ColumnOffset:=nCollOffset)
    Set rKtoSource = Application.Union(rKtoDestination, rKtoSource)
'  End If
  For Each rObjID In rKtoSource
    If rObjID.Offset(0, NColSHKnz - nColSource).Value = "S" Then
      strFormula = strFormula & "+"
    Else
      strFormula = strFormula & "-" 'Haben oder Leer bei Summenzeile
    End If
    strFormula = strFormula & strPrefix & "R" & rObjID.Row & "C[" & nCollOffset & "]"
  Next rObjID

  If rKtoDestination.Offset(0, NColSHKnz - rKtoDestination.Column).Value = "H" Then
    strFormula = "-(" & strFormula & ")"
  Else
    strFormula = strFormula
  End If

  createFormulaCarryForward = strFormula
End Function

'ermittelt, ob ObjID eine Formel f|fffd|r Ergebnisvortrag enth|fffd|lt
'falls zutreffend wird Bereich
Friend Function detectCarryForwardRange(ByVal rObjID As Range) As Range
  Dim strFormula As String
  Dim nBegin As Long, nEnd As Long
  Dim rCarryForward As Range
  Dim ws As Worksheet
  Dim bReferenceStyleChanged As Boolean
  Dim nReferenceStyle_prev As Long
  Dim nError As Long, strError As String, strSource As String
  Const strSearch As String = ",IDLEvaluate(""{CarryForward}"",("
  
  On Error GoTo ErrHandler
  
  If rObjID.HasFormula Then
    strFormula = rObjID.Formula
    nBegin = InStr(1, strFormula, strSearch)
    If nBegin > 0 Then
      nBegin = nBegin + Len(strSearch)
      nEnd = InStr(nBegin, strFormula, ")")
      strFormula = Mid$(strFormula, nBegin, nEnd - nBegin)
      Set ws = rObjID.Worksheet
      
      
      If Application.ReferenceStyle <> xlA1 Then
        nReferenceStyle_prev = Application.ReferenceStyle
        Application.ReferenceStyle = xlA1
        bReferenceStyleChanged = True
      End If
      Set rCarryForward = ws.Evaluate(strFormula) 'Zeiger in Datenblatt
      
      
    End If
  End If
  
  
  Set detectCarryForwardRange = rCarryForward
  
Cleanup:
  If bReferenceStyleChanged Then
    Application.ReferenceStyle = nReferenceStyle_prev
    bReferenceStyleChanged = False
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
ErrHandler:
  Debug.Assert False
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source

  On Error Resume Next

  'ErrHandler_preserveFrames
  'ModuleInternal.CallContext_LocaleID = 0 'Hack Ersatz f|fffd|r ErrHandler_preserveFrames, da TypeLib nicht |fffd|nderbar war

  GoTo Cleanup
  
End Function

Attribute VB_Name = "Common"
Option Explicit
Option Private Module



#Const DOTNETBUILD = 1


#If Win64 Then
Private Declare PtrSafe Function VariantCopy Lib "oleaut32" (ByRef pvargDest As Variant, ByRef pvargSrc As Variant) As Long
#Else
Private Declare Function VariantCopy Lib "oleaut32" (ByRef pvargDest As Variant, ByRef pvargSrc As Variant) As Long
#End If

Public mEvaluateCellContext As Excel.Range
Public Const EnStdMsgErrorInputConvention = 217
Public Const WorkBook_Password = "ab281uw"
Public g_collCalculateFunctionObjects As Collection
Public g_nSystemChangeCounter As Long
Public Const EnBrowseFlags_Trim = &H800
Public Const EnBrowseFlags_IgnoreCase = &HC000
Public Const EnBrowseFlags_LCase = &H4000
Public Const EnBrowseFlags_UCase = &H8000
Public Const EnBrowseFlags_StringTypeMask = &HC000
Public Const EnBrowseFlags_BrowseSet = &H2
Public Const EnBrowseFlagsFunctional_NoWildcards = &H40
Public Const EnBrowseFlagsFunctional_CheckBrowseSet = &H60
Public Const EnBrowseFlagsFunctional_NoCheck = &H0
Public Const EnBrowseFlagsNull = &H8
Public Const EnBrowseFlagsFunctional_Wildcards = &H20
Public Const EnBrowseFlagsFunctional_Mask = &H60
Public Const EnBrowseFlagsReadOnly = &H4
Public Const EnBrowseFlagsNullable = &H10
Public CallContext As Object
Public ThisPlugin As Plugin

#If DOTNETBUILD = 0 Then
Public ThisWorkbook As Excel.Workbook
#End If

Public Const NColor_UnLockedField = vbWhite
Public Const NColor_LockedInputField = &H99FFFF
Public Const NColor_LockedField = &H99CCFF
Public Const EnUmlEx_NOTSERIALIZABLE = &H80
Public Const EnUmlEx_KEY = &H20000
Public Const EnUmlEx_OPTIONAL = &H2000
Public Const ACT_VERSION As Long = 14
Public Const DATASHEET_NAME As String = "Struktur"
Public Const NColAddDetailsFirst = 9
Public Const NColSHKnz = 8
Public Const NColActValue = 7
Public Const NColPrevValue = 6
Public Const NColValueFirst = 6
Public Const NColKtoKnz2 = 5
Public Const NColKtoKnz1 = 4
Public Const NColBilGuVKnz = 3
Public Const NColObjID = 2
Public Const NColBene = 1
Public Const EnDataFlags_Kst_DetailDisabled = &H8
Public Const EnDataFlags_KtoKnz2_DetailDisabled = &H4
Public Const EnDataFlags_KtoKnz1_DetailDisabled = &H2
Public Const EnDataFlags_Locked = &H1
Public Const EnDataFlags_DisabledMask = &HF
Public Const EnDataFlags_NoDiffVPeriode = &H10 'Zeichen, dass Vortrag Umbuchung
Public Const EnDataCols_Language = 4
Public Const EnDataCols_Flags = 3
Public Const EnDataCols_Knz2 = 2
Public Const EnDataCols_WKZ = 1
Public Const EnDataCols_KstKZ1 = 1
Public Const EnDataCols_BilGUVKnz = 1
Public Const EnDataCols_SHKnz = 1
Public Const EnDataCols_Knz = 1
Public Const EnDataCols_ObjID = 0

Public Const N_AREAS_MAX = 100  'Erfahrungswert

Public Function RangeMulti_Count(ByVal rVector As Range) As Long
  If Not rVector Is Nothing Then
    RangeMulti_Count = rVector.count
  End If
End Function

Public Function RangeMulti_Item(ByVal rVector As Range, ByVal Index As Long) As Range
  Dim r As Range
  Dim i As Long
  For Each r In rVector
    If i = Index Then
      Set RangeMulti_Item = r
      Exit Function
    End If
    i = i + 1
  Next r
End Function

Public Function IDLEvaluate2(ParamArray params() As Variant) As Variant
  Dim nIndexParamFirst As Long
  Dim strExpression As String
  Dim oEditor As Object
  Dim ws As Worksheet
  Dim r As Range
  Const CallTypeEx_ReturnError = &H200
  On Error GoTo ErrHandler
  If IsObject(params(0)) Then
    Set r = params(0)
    nIndexParamFirst = 1
    strExpression = params(1)
  Else
    Set r = cellContext
    nIndexParamFirst = 2
    strExpression = params(0)
  End If
  Set ws = r.Worksheet
  Set oEditor = ws.Parent.ActiveEditor
  Set oEditor = oEditor.EditorFromWorksheet(ws)
  oEditor.InvokeRange VbGet Or CallTypeEx_ReturnError, strExpression, IDLEvaluate2, Selection:=r
  If IsEmpty(IDLEvaluate2) Then
    IDLEvaluate2 = ""
  ElseIf IsError(IDLEvaluate2) Then
    If CLng(IDLEvaluate2) = 445 Then
      IDLEvaluate2 = ""
    End If
  End If
  Exit Function
ErrHandler:
  IDLEvaluate2 = CVErr(xlErrValue)
End Function

Private Function AssignCellContext(ByVal r As Range) As Range
  Set AssignCellContext = mEvaluateCellContext
  Set mEvaluateCellContext = r
End Function

Public Sub ExcelEvaluate(strExpression As String, vntResult As Variant, Optional ByVal context_cell As Range)
  Dim oCellContext_prev As Range
  Dim nError As Long, strError As String
  Dim ws As Worksheet
  Dim r As Range
  If Not context_cell Is Nothing Then
    Set ws = context_cell.Worksheet
    Set oCellContext_prev = AssignCellContext(context_cell)
  End If
  On Error GoTo ErrHandler
  If ws Is Nothing Then
    Set r = context_cell
    If r Is Nothing Then
      Set ws = Worksheets(1)
    Else
      Set ws = r.Worksheet
    End If
  End If
  VariantCopy vntResult, ws.Evaluate(strExpression)
Cleanup:
  If Not context_cell Is Nothing Then
    AssignCellContext oCellContext_prev
  End If
  If nError <> 0 Then
    Err.Raise nError, , strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  GoTo Cleanup
End Sub

Public Property Get cellContext() As Excel.Range
  Dim vntTemp As Variant
  If mEvaluateCellContext Is Nothing Then
    VariantCopy vntTemp, Application.Caller
    If IsObject(vntTemp) Then
      If Not vntTemp Is Nothing Then
        If TypeOf vntTemp Is Excel.Range Then
          Set cellContext = vntTemp
        End If
      End If
    End If
  Else
    Set cellContext = mEvaluateCellContext
  End If
End Property

Public Property Get IsOffice97() As Boolean
   IsOffice97 = (Asc(Application.Version) = 56)
End Property

Public Function SearchTextByRObjID(ByVal rObjID As Range, Optional ByVal nBene As Integer = 1) As Range
  Dim strLanguage As String
  Dim lcid As Long
  Dim ws As Worksheet
  If Not CallContext Is Nothing Then
#If CENTRALBUILD = 0 Then
    If Not CallContext Is ThisPlugin Then
#End If
      On Error Resume Next
      lcid = CallContext.LocaleID
      On Error GoTo 0
      If lcid <> 0 Then
        strLanguage = LCIDToStrLanguage(lcid)
      End If
#If CENTRALBUILD = 0 Then
    End If
#End If
  End If
  If lcid = 0 Then
    Set ws = rObjID.Worksheet
    strLanguage = ws.Range("OnlineLanguage")
  End If
  Set SearchTextByRObjID = ThisPlugin.IDLLocText(rObjID.Offset(0, EnDataCols_Language - EnDataCols_ObjID + nBene), strLanguage)
End Function

Public Property Get LocaleID() As Long
  Dim lcid As Long
  If Not CallContext Is ThisWorkbook Then
    On Error Resume Next
    If Not CallContext Is Nothing Then
      lcid = CallContext.LocaleID
    End If
    On Error GoTo 0
  End If
  If lcid = 0 Then
    lcid = StrLanguageToLCID(ThisPlugin.ActiveEditor.DataSheet.[OnlineLanguage])
  End If
  LocaleID = lcid
End Property

Public Function SearchTextInKPOBJ(objTyp As String, objID As String) As String
  SearchTextInKPOBJ = SearchTextByRObjID(ThisPlugin.ActiveEditor.DataSheet.Range(objTyp & "__" & objID))
End Function

Public Function SearchTextInSPR(ByVal textID As Long) As String
  SearchTextInSPR = SearchTextByRObjID(ThisPlugin.ActiveEditor.DataSheet.Range("CON__" & textID))
End Function

Public Function StrLanguageToLCID(strLanguage As String) As Long
  Const LANG_GERMAN  As Long = 7
  Const LANG_SPANISH  As Long = 10
  Const LANG_FRENCH   As Long = 12
  Const LANG_ENGLISH   As Long = 9
  Const OFFSET_SUBLANG_DEFAULT As Long = &H400
  Const LCID_GERMAN As Long = OFFSET_SUBLANG_DEFAULT Or LANG_GERMAN
  Const LCID_ENGLISH As Long = OFFSET_SUBLANG_DEFAULT Or LANG_ENGLISH
  Select Case strLanguage
    Case "DEU"
      StrLanguageToLCID = OFFSET_SUBLANG_DEFAULT Or LANG_GERMAN
    Case "ENG", ""
      StrLanguageToLCID = OFFSET_SUBLANG_DEFAULT Or LANG_ENGLISH
    Case "FRA"
      StrLanguageToLCID = OFFSET_SUBLANG_DEFAULT Or LANG_FRENCH
    Case "SPA"
      StrLanguageToLCID = OFFSET_SUBLANG_DEFAULT Or LANG_SPANISH
    Case Else
      StrLanguageToLCID = OFFSET_SUBLANG_DEFAULT Or LANG_ENGLISH
  End Select
End Function

Private Function LCIDToStrLanguage(ByVal lcid As Long) As String
  Select Case lcid And &HFF
    Case 7
      LCIDToStrLanguage = "DEU"
    Case 10
      LCIDToStrLanguage = "SPA"
    Case 12
      LCIDToStrLanguage = "FRA"
    Case Else
      LCIDToStrLanguage = "ENG"
  End Select
End Function

Public Function FormatStr(ByVal msg As String, ParamArray args() As Variant) As String
  Dim vntArg As Variant
  Dim i As Long
  For Each vntArg In args
    i = i + 1
    msg = Replace(msg, "%" & i, CStr(vntArg))
  Next vntArg
  FormatStr = msg
End Function

Public Function IDL_MSColMap_Offset(ByVal r As Range, ByVal nOffset As Long) As Range
  Dim rArea As Range
  Dim rResult As Range
  If IsOffice97 Then
    For Each rArea In r.Areas
      If rResult Is Nothing Then
        Set rResult = rArea.Offset(0, nOffset)
      Else
        Set rResult = Union(rResult, rArea.Offset(0, nOffset))
      End If
    Next rArea
    Set IDL_MSColMap_Offset = rResult
  Else
    Set IDL_MSColMap_Offset = r.Offset(0, nOffset)
  End If
End Function


Public Sub ShowErrDialog(Error As Long, Description As String, Source As String)
  MsgBox Description, vbCritical Or vbOKOnly
End Sub


Public Function ThisWorkbook_New() As Plugin
  Set ThisWorkbook_New = New Plugin
End Function


Attribute VB_Name = "Formula"
Option Explicit



'externe Formeln f|fffd|r DOTNETBUILD
'ansonsten intern verwendet



Public Function IDLCellAttributes(ByRef Value As Variant, ParamArray attributes() As Variant) As Variant
  Dim r As Range
  Dim ar() As Variant
  Dim nSize As Long
  Dim i As Long
  Dim nSrc As Long, nDest As Long
  If IsObject(Application.Caller) And Not g_collCalculateFunctionObjects Is Nothing Then
    Set r = Application.Caller
    nSrc = LBound(attributes)
    nSize = 1 + UBound(attributes) - nSrc + 1
    ReDim ar(nSize - 1)
    For nDest = 1 To nSize - 1
      If IsObject(attributes(nSrc)) Then
        Set ar(nDest) = attributes(nSrc)
      Else
        ar(nDest) = attributes(nSrc)
      End If
      nSrc = nSrc + 1
    Next nDest
    Set ar(0) = r
    On Error Resume Next
    g_collCalculateFunctionObjects.Add ar, r.Address
  End If
  If IsObject(Value) Then
    Set IDLCellAttributes = Value
  Else
    IDLCellAttributes = Value
  End If
End Function

Public Function IDLAttributeV(Value As Variant, vType As Variant, Name As Variant, uml_ex As Variant, ParamArray attributes() As Variant) As Variant
  If IsObject(Value) Then
    Set IDLAttributeV = Value
  ElseIf IsMissing(Value) Then
    IDLAttributeV = CVErr(xlErrNA)
  Else
    IDLAttributeV = Value
  End If
End Function

Public Function IDLAttribute(Optional Value As Variant, Optional vType As Variant, Optional Name As String, Optional ByVal uml_ex As Long, Optional attributes As Variant) As Variant
  If IsObject(Value) Then
    Set IDLAttribute = Value
  ElseIf IsMissing(Value) Then
    IDLAttribute = CVErr(xlErrNA)
  Else
    IDLAttribute = Value
  End If
End Function

Public Function IDLSumKto_BilGuV_SH(ByVal nBilGuV As Long, ByVal rCalculateCol As Range) As Variant
  If ThisPlugin Is Nothing Then
    IDLSumKto_BilGuV_SH = CVErr(xlErrValue)
  Else
    IDLSumKto_BilGuV_SH = ThisPlugin.IDLSumKto_BilGuV_SH(nBilGuV, rCalculateCol)
  End If
End Function

Public Function IDLZeroFilter(arg As Variant) As Variant
  If IsError(arg) Then
    If arg = CVErr(xlErrNA) Then
      IDLZeroFilter = ""
    Else
      IDLZeroFilter = arg
    End If
  ElseIf IsEmpty(arg) Then
    IDLZeroFilter = ""
  ElseIf arg = 0 Then
    IDLZeroFilter = ""
  Else
    IDLZeroFilter = arg
  End If
End Function

Public Function IDLNullFilter(arg As Variant) As Variant
  If IsError(arg) Then
    If arg = CVErr(xlErrNA) Then
      IDLNullFilter = ""
    Else
      IDLNullFilter = arg
    End If
  ElseIf IsEmpty(arg) Then
    IDLNullFilter = ""
  Else
    IDLNullFilter = arg
  End If
End Function

Public Function IDLVLookup(ByVal PosVector As Range, val As Variant, Optional ByVal nOffsetResult As Long, Optional ByVal nOffsetSearch As Long, Optional ByVal Sorted As Boolean = True) As Range
  Dim f As Long, M As Long
  Dim n As Long, N2 As Long
  Dim oAreas As Excel.Areas
  Dim r As Range
  Dim nCount As Long
  If Not Sorted Then
    Set IDLVLookup = IDLVLookupUnsorted(PosVector, val, nOffsetResult, nOffsetSearch)
    Exit Function
  End If
  If nOffsetSearch <> 0 Then
    Set PosVector = IDL_MSColMap_Offset(PosVector, nOffsetSearch)
  End If
  Set oAreas = PosVector.Areas
  nCount = oAreas.count
  If nCount > 1 Then
    f = 1
    n = nCount
    Do While n > 0
      N2 = n / 2
      M = f + N2
      Set r = oAreas(M)
      If StrComp(r(r.count), val, vbTextCompare) < 0 Then
        f = M + 1
        n = n - N2 - 1
      Else
        n = N2
      End If
    Loop
    If f = nCount + 1 Then
      Exit Function
    End If
    Set PosVector = oAreas(f)
  End If
  On Error Resume Next
  Set r = PosVector(WorksheetFunction.Match(val, PosVector, 1))
  If Err = 0 Then
    On Error GoTo 0
    If StrComp(r.Value, val, vbTextCompare) = 0 Then
      nOffsetResult = nOffsetResult - nOffsetSearch
      If nOffsetResult = 0 Then
        Set IDLVLookup = r
      Else
        Set IDLVLookup = r.Offset(0, nOffsetResult)
      End If
    End If
  End If
End Function


Private Function IDLVLookupUnsorted(ByVal PosVector As Range, val As Variant, Optional ByVal nOffsetResult As Long, Optional ByVal nOffsetSearch As Long) As Range
  Dim r As Range
  If PosVector.Areas.count > 1 Then
    For Each r In PosVector
      If r.Offset(0, nOffsetSearch).Value = val Then
        Set IDLVLookupUnsorted = r.Offset(0, nOffsetResult)
        Exit Function
      End If
    Next r
  Else
    If nOffsetSearch = 0 Then
      Set r = PosVector
    Else
      Set r = PosVector.Offset(0, nOffsetSearch)
    End If
On Error GoTo MatchFailed
    Set r = r(WorksheetFunction.Match(val, r, 0))
On Error GoTo 0
    If r.Value = val Then
      Set IDLVLookupUnsorted = r.Offset(0, nOffsetResult - nOffsetSearch)
    End If
  End If
MatchFailed:
End Function




Public Function IDLLastValue(ByVal r As Range) As Variant
  Dim vntActValue As Variant
  Dim rCell As Range
  Dim vt As Integer
  On Error GoTo ErrHandler
  For Each rCell In r
    vntActValue = rCell.Value
    vt = VarType(vntActValue)
    If vt = vbEmpty Then
    ElseIf vt = vbError Then
      IDLLastValue = vntActValue
      Exit For
    ElseIf vt = vbString Then
      If Trim(vntActValue) <> "" Then
        IDLLastValue = vntActValue
      End If
    Else
      IDLLastValue = vntActValue
    End If
  Next rCell
  If IsEmpty(IDLLastValue) Then
    IDLLastValue = ""
  End If
  Exit Function
ErrHandler:
  IDLLastValue = CVErr(xlErrValue)
End Function

Public Function IDLSumCY(Optional ByVal r As Range, Optional ByVal NumDigitsAfterDecimal As Integer = -1) As Variant
  Dim vntActValue As Variant
  Dim bNonEmpty As Boolean
  Dim rCell As Range
  Dim cyResult As Currency
  Dim cy As Currency
  Dim bTemp As Boolean
  Dim vt As Integer
  Dim bNegative As Boolean
  Dim i As Long
  On Error GoTo ErrHandler
  If NumDigitsAfterDecimal > 4 Then Err.Raise 5
  If Not r Is Nothing Then
    For Each rCell In r
      vntActValue = rCell.Value
      vt = VarType(vntActValue)
      If vt = vbEmpty Then
        bTemp = False
      ElseIf vt = vbString Then
        vntActValue = Trim(vntActValue)
        bTemp = Not (vntActValue = "")
      ElseIf vt = vbError Then
        IDLSumCY = vntActValue
        Exit Function
      Else
        bTemp = True
      End If
      If bTemp Then
        cy = vntActValue
        If NumDigitsAfterDecimal >= 0 And NumDigitsAfterDecimal < 4 Then
          If cy < 0 Then
            bNegative = True
            cy = -cy
          Else
            bNegative = False
          End If
          For i = 0 To NumDigitsAfterDecimal - 1
            cy = cy * 10
          Next i
          cy = Int(cy + 0.5)
          For i = 0 To NumDigitsAfterDecimal - 1
            cy = cy / 10
          Next i
          If bNegative Then
            cy = -cy
          End If
        End If
        If bNonEmpty Then
          cyResult = cyResult + cy
        Else
          cyResult = cy
          bNonEmpty = True
        End If
      End If
    Next rCell
  End If
  If bNonEmpty Then
    IDLSumCY = cyResult
  Else
    IDLSumCY = ""
  End If
  Exit Function
ErrHandler:
  IDLSumCY = CVErr(xlErrValue)
End Function

Public Function IDLLocTextObjID(ByVal PosVector As Range, ByVal nBene As Long, ByVal objID As String, ByVal Language As String) As Range
  Set IDLLocTextObjID = IDLLocText(IDLVLookup(PosVector, UCase(Trim(objID)), EnDataCols_Language + nBene), Language)
End Function

Public Function IDLLocText(ByVal Pos As Range, ByVal Language As String) As Range
  Dim nColText As Long
  Dim r As Range
  Dim strLanguage As String
  Dim nColLanguageAct As Long, nColLanguagePrev As Long
  Dim nColLanguagePrev_ENG As Long
  #If 1 Then
    nColText = Asc(Mid$(Pos.Address, 2, 1)) - 65
  #Else
    nColText = Pos.Column - 1
  #End If
  nColLanguageAct = EnDataCols_Language
  Do
    Set r = Pos.Offset(0, nColLanguageAct - nColText)
    strLanguage = r
    If strLanguage = "" Then
      If nColLanguagePrev_ENG > 0 Then
        nColLanguageAct = nColLanguagePrev_ENG
      ElseIf nColLanguagePrev > 0 Then
        nColLanguageAct = nColLanguagePrev
      End If
      Exit Do
    ElseIf strLanguage = Language Then
      Exit Do
    End If
    nColLanguagePrev = nColLanguageAct
    If nColLanguagePrev_ENG = 0 Then
      If strLanguage = "ENG" Then
        nColLanguagePrev_ENG = nColLanguageAct
      End If
    End If
    nColLanguageAct = nColLanguageAct + 4
  Loop
  If nColLanguageAct = EnDataCols_Language Then
    Set IDLLocText = Pos
  Else
    Set IDLLocText = Pos.Offset(0, nColLanguageAct - EnDataCols_Language)
  End If
End Function


Public Sub AdjustDetails__ExcelUI(Optional ByVal strClassName As String)
  ThisPlugin.AdjustDetails__ExcelUI strClassName
End Sub

Public Sub AssignOnlineLanguage_MenuClick()
  ThisPlugin.AssignOnlineLanguage_MenuClick
End Sub


Public Sub OnContextMenuClick()
  ThisPlugin.OnContextMenuClick
End Sub

Public Sub InsertDetailLines()
  ThisPlugin.InsertDetailLines
End Sub

Public Sub DeleteDetailLines()
  ThisPlugin.DeleteDetailLines
End Sub

Public Sub InsertNoticeSheet()
  ThisPlugin.InsertNoticeSheet
End Sub


Attribute VB_Name = "IDLDecentralEntry"
'---------------------------
'IDL Begin
'Don't change or remove this code !!!
Option Explicit
Option Private Module



#Const DOTNETBUILD = 1
#Const CENTRALBUILD = 0

'immer m|fffd|glichst .Net 4 laden
Private Const CLR_VERSION = 40




'Internes Anwendungsobjekt / Wurzelobjekt
Private m_oIntApplication As Object

#If Win64 Then
Private Declare PtrSafe Function CorBindToRuntimeEx Lib "mscoree" (ByVal pwszVersion As LongPtr, ByVal pwszBuildFlavor As LongPtr, ByVal startupFlags As Long, ByRef rclsid As tagGUID, ByRef riid As tagGUID, ByVal ppv As LongPtr) As Long
#Else
Private Declare Function CorBindToRuntimeEx Lib "mscoree" (ByVal pwszVersion As Long, ByVal pwszBuildFlavor As Long, ByVal startupFlags As Long, ByRef rclsid As tagGUID, ByRef riid As tagGUID, ByVal ppv As Long) As Long
#End If
Private m_strProfileFullName As String


Private m_oAppDomain As Object 'AppDomain
Private m_oCorRuntimeHost As IUnknown 'ICorRuntimeHost



Private Const MAIN_ASSEMBLY = "ConnectorClient"
Private Const MAIN_ASSEMBLY_MODULE = MAIN_ASSEMBLY & ".exe"

Private Const APP_DOMAIN = "IDL.Connector.1" 'eindeutige Anwendungsdom|fffd|ne mit Versionsnummer, die bei Bedarf (wesentliche Inkompatibilit|fffd|ten zu Vorg|fffd|ngerversion) erh|fffd|ht werden kann
Private Const APP_CLASS_NAME = "de.idl.connector.ConnectorClient.ConnectorEntry" 'Einstiegsklasse

#If CENTRALBUILD Then
Private Const APP_CLASS_METHODNAME = "createAddin"
#Else
Private Const APP_CLASS_METHODNAME = "createAddinDecentral"
#End If

Private Const MAIN_MODULE_LEGACY = "KVD201.dll"


'Hauptmodul zur Erkennung der Installation
#If DOTNETBUILD = 1 And CENTRALBUILD = 0 Then

Private Const MAIN_MODULE = MAIN_ASSEMBLY_MODULE

#Else
Private Const MAIN_MODULE = MAIN_MODULE_LEGACY
#End If



#If Win64 Then

Private Declare PtrSafe Function GetFileAttributesW Lib "Kernel32" (ByVal lpFileName As LongPtr) As Long
Public Declare PtrSafe Function GetThreadLocale Lib "Kernel32" () As Long

Private Declare PtrSafe Function GetPrivateProfileStringW Lib "Kernel32" (ByVal lpAppName As LongPtr, ByVal lpKeyName As LongPtr, ByVal lpDefault As LongPtr, ByVal lpReturnedString As LongPtr, ByVal nSize As Long, ByVal lpFileName As LongPtr) As Long

Private Declare PtrSafe Function WritePrivateProfileStringW Lib "Kernel32" (ByVal lpAppName As LongPtr, ByVal lpKeyName As LongPtr, ByVal lpString As LongPtr, ByVal lpFileName As LongPtr) As Long


Public Declare PtrSafe Function CreateFileW Lib "Kernel32" (ByVal lpFileName As LongPtr, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, ByVal lpSecurityAttributes As LongPtr, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As LongPtr) As Long

Public Declare PtrSafe Function GetFileSize Lib "Kernel32" (ByVal hFile As LongPtr, ByVal lpFileSizeHigh As LongPtr) As Long

Public Declare PtrSafe Function ReadFile Lib "Kernel32" (ByVal hFile As LongPtr, ByVal lpBuffer As LongPtr, ByVal nNumberOfBytesToRead As Long, ByRef lpNumberOfBytesRead As Long, ByVal lpOverlapped As LongPtr) As Long

Public Declare PtrSafe Function CloseHandle Lib "Kernel32" (ByVal hObject As LongPtr) As Long

Private Declare PtrSafe Function CoGetClassObject Lib "ole32" (ByRef rclsid As tagGUID, ByVal dwClsContext As Long, ByVal pServerInfo As LongPtr, ByRef riid As tagGUID, ByVal ppv As LongPtr) As Long
Private Declare PtrSafe Function CoRegisterClassObject Lib "ole32" (ByRef rclsid As tagGUID, ByVal punk As IUnknown, ByVal dwClsContext As Long, ByVal Flags As Long, ByRef lpdwRegister As Long) As Long
Private Declare PtrSafe Function CoRevokeClassObject Lib "ole32" (ByVal dwRegister As Long) As Long

Private Declare PtrSafe Function GetCommandLineW Lib "Kernel32" () As LongPtr
Private Declare PtrSafe Function lstrlenW Lib "Kernel32" (ByVal Ptr As LongPtr) As Long


#Else

Private Declare Function GetFileAttributesW Lib "Kernel32" (ByVal lpFileName As Long) As Long
Public Declare Function GetThreadLocale Lib "Kernel32" () As Long

Private Declare Function GetPrivateProfileStringW Lib "Kernel32" (ByVal lpAppName As Long, ByVal lpKeyName As Long, ByVal lpDefault As Long, ByVal lpReturnedString As Long, ByVal nSize As Long, ByVal lpFileName As Long) As Long

Private Declare Function WritePrivateProfileStringW Lib "Kernel32" (ByVal lpAppName As Long, ByVal lpKeyName As Long, ByVal lpString As Long, ByVal lpFileName As Long) As Long


Public Declare Function CreateFileW Lib "Kernel32" (ByVal lpFileName As Long, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, ByVal lpSecurityAttributes As Long, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long

Public Declare Function GetFileSize Lib "Kernel32" (ByVal hFile As Long, ByVal lpFileSizeHigh As Long) As Long

Public Declare Function ReadFile Lib "Kernel32" (ByVal hFile As Long, ByVal lpBuffer As Long, ByVal nNumberOfBytesToRead As Long, ByRef lpNumberOfBytesRead As Long, ByVal lpOverlapped As Long) As Long
Public Declare Function CloseHandle Lib "Kernel32" (ByVal hObject As Long) As Long

Private Declare Function CoGetClassObject Lib "ole32" (ByRef rclsid As tagGUID, ByVal dwClsContext As Long, ByVal pServerInfo As Long, ByRef riid As tagGUID, ByVal ppv As Long) As Long
Private Declare Function CoRegisterClassObject Lib "ole32" (ByRef rclsid As tagGUID, ByVal punk As IUnknown, ByVal dwClsContext As Long, ByVal Flags As Long, ByRef lpdwRegister As Long) As Long
Private Declare Function CoRevokeClassObject Lib "ole32" (ByVal dwRegister As Long) As Long

Private Declare Function GetCommandLineW Lib "Kernel32" () As Long

Private Declare Function lstrlenW Lib "Kernel32" (ByVal Ptr As Long) As Long


#End If


Public Const LCID_GERMAN = &H407

Private m_bInitDone As Boolean
Private m_bProgrammaticStart As Boolean

#If CENTRALBUILD Then
Private m_oIDLAddinManager As IDLAddinManager 'verwaltet das Laden von Addins und Modulen
#End If 'CENTRALBUILD


Public Sub notifyProgrammaticStart()
  m_bProgrammaticStart = True
End Sub
'f|fffd|r Makro Einstiegspunkt zum Start eines Wurzelklasse
'l|fffd|dt Modul, darin eine  angegegbene Klasse (ComVisible !) und f|fffd|hrt eine statische create Methode mit der Signatur "Object(Object[] params)" auf
'Module kann der Name der Assembly relativ zu RootPath oder ein ByteArray aus den Assembly Daten darstellen
Public Function loadRootObjectImpl(ByVal AppDomain As String, ByVal RootPath As String, Module As Variant, ByVal TypeName As String, ByVal MethodName As String, params() As Variant) As Object
  Dim oUnknownRootType As IUnknown 'Type
  Dim oRootType As Object 'Type
  Dim oAssembly As Object 'Assembly
  Const BindingFlags_Static = &H8
  Const BindingFlags_Public = &H10
  Const BindingFlags_InvokeMethod = &H100
    
  If m_oAppDomain Is Nothing Then
    Set m_oAppDomain = loadAppDomain(AppDomain, RootPath)
  End If
   

  If IsArray(Module) Then
    Set oAssembly = m_oAppDomain.Load_3(Module)
  Else
    Set oAssembly = m_oAppDomain.Load_2(Module)
  End If


  Set oUnknownRootType = oAssembly.GetType_2(TypeName)

  CopyMemory VarPtr(oRootType), VarPtr(oUnknownRootType), sizeof_Ptr
  ZeroMemory VarPtr(oUnknownRootType), sizeof_Ptr

  Set loadRootObjectImpl = oRootType.InvokeMember_3(MethodName, BindingFlags_Static Or BindingFlags_Public Or BindingFlags_InvokeMethod, Nothing, Empty, params)



End Function


Private Function loadClrNoMetaHost(ByVal nVersion As Long) As IUnknown 'ICorRuntimeHost
  Dim CLSID_CorRuntimeHost As tagGUID
  Dim IID_ICorRuntimeHost As tagGUID
  Dim oCorRuntimeHost As IUnknown 'ICorRuntimeHost
  Dim hr As Long
  Dim strVersion As String
  
  CLSID_CorRuntimeHost.dw0 = &HCB2F6723
  CLSID_CorRuntimeHost.dw1 = &H11D2AB3A
  CLSID_CorRuntimeHost.dw2 = &HC000409C
  CLSID_CorRuntimeHost.dw3 = &H3E0AA34F

  IID_ICorRuntimeHost.dw0 = &HCB2F6722
  IID_ICorRuntimeHost.dw1 = &H11D2AB3A
  IID_ICorRuntimeHost.dw2 = &HC000409C
  IID_ICorRuntimeHost.dw3 = &H3E0AA34F
  

  If nVersion >= 40 Then
    strVersion = "v4.0.30319"
  Else
    strVersion = "v2.0.50727"
  End If
  
  hr = CorBindToRuntimeEx(StrPtr(strVersion), StrPtr("wks"), 0, CLSID_CorRuntimeHost, IID_ICorRuntimeHost, VarPtr(oCorRuntimeHost))

  If hr < 0 Then Err.Raise hr

  Set loadClrNoMetaHost = oCorRuntimeHost

End Function

'CLR laden
'nVersion Major * 10 + Minor (20, 35, 40 f|fffd|r .Net 2.0, 3.5 und 4.0)
'nVersionMin angegeben: versuchen nVersion zu laden, aber mindestens nVersionMin
Private Function loadClr(ByVal nVersion As Long, Optional ByVal nVersionMin As Long) As IUnknown 'ICorRuntimeHost
#If VBA7 Then
  Dim hMscoree As LongPtr
  Dim pfnCLRCreateInstance As LongPtr
#Else
  Dim hMscoree As Long
  Dim pfnCLRCreateInstance As Long
#End If

  Dim needMetaHost As Boolean
  Dim pMetaHost As IUnknown 'ICLRMetaHost
  Dim hr As Long
  Dim CLSID_CLRMetaHost As tagGUID
  Dim IID_ICLRMetaHost As tagGUID
  Dim nError As Long, strSource As String, strError As String

  
  On Error GoTo ErrHandler

  needMetaHost = (nVersion >= 40) 'f|fffd|r Dot Net 4 im Allgemeinen Meta Host Schnittstelle erforderlich (nicht erforderlich nur bei Win32 und noch nicht geladenem .Net 4, ist jedoch innerhalb Excel nicht sichergestellt)

  hMscoree = LoadLibraryW(StrPtr("mscoree"))
  If hMscoree = 0 Then
    RaiseWinError Err.LastDllError, "Dot Net Runtime required"
  End If
  
  If Not needMetaHost Then
    Set loadClr = loadClrNoMetaHost(nVersion)
  Else
  
    pfnCLRCreateInstance = GetProcAddress(hMscoree, "CLRCreateInstance")
    If pfnCLRCreateInstance = 0 Then
      GoTo tryLowerVersion
    End If
    
      
    '{0x9280188d, 0xe8e, 0x4867, {0xb3, 0xc, 0x7f, 0xa8, 0x38, 0x84, 0xe8, 0xde}};
    CLSID_CLRMetaHost.dw0 = &H9280188D
    CLSID_CLRMetaHost.dw1 = &H48670E8E
    CLSID_CLRMetaHost.dw2 = &HA87F0CB3
    CLSID_CLRMetaHost.dw3 = &HDEE88438
  
    '{0xD332DB9E, 0xB9B3, 0x4125, {0x82, 0x07, 0xA1, 0x48, 0x84, 0xF5, 0x32, 0x16}};
    IID_ICLRMetaHost.dw0 = &HD332DB9E
    IID_ICLRMetaHost.dw1 = &H4125B9B3
    IID_ICLRMetaHost.dw2 = &H48A10782
    IID_ICLRMetaHost.dw3 = &H1632F584
  
#If Win64 Then
    hr = PtrStub3AsLong(VarPtr(CLSID_CLRMetaHost), VarPtr(IID_ICLRMetaHost), VarPtr(pMetaHost), pFct:=pfnCLRCreateInstance)
#Else
    hr = PtrFct3(pfnCLRCreateInstance, VarPtr(CLSID_CLRMetaHost), VarPtr(IID_ICLRMetaHost), VarPtr(pMetaHost))
#End If
    If hr < 0 Then
      GoTo tryLowerVersion
    End If
    If Not pMetaHost Is Nothing Then
      'Meta Host Schnittstelle f|fffd|r .Net 4 verwenden
      Set loadClr = LoadClrMeta(nVersion, pMetaHost)
    End If
  End If
  
  If loadClr Is Nothing Then
    Set loadClr = LoadClrMeta(nVersion, pMetaHost)
  End If


  
Cleanup:
  If hMscoree <> 0 Then
    FreeLibrary hMscoree
    hMscoree = 0
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Function
  
tryLowerVersion:

  If nVersion = 40 And nVersionMin <> 20 Then
    Err.Raise hr, , ".Net 4.0 required"
  End If
  
  Set loadClr = loadClrNoMetaHost(nVersionMin)
  GoTo Cleanup
  
ErrHandler:
  nError = Err.Number
  strSource = Err.Source
  strError = Err.Description
  On Error Resume Next
  GoTo Cleanup
  
End Function

'pMetaHost as ICLRMetaHost
Private Function LoadClrMeta(ByVal nVersion As Long, ByVal pMetaHost As IUnknown) As IUnknown 'ICorRuntimeHost
  Dim hr As Long
  Dim pRuntimeInfo As IUnknown 'ICLRRuntimeInfo
  Dim strVersion As String
#If Win64 Then
  Dim pTemp As LongPtr
  
  Dim pParam2 As LongPtr
  Dim pParam1 As LongPtr
  Dim oOrig As LongPtr
#Else
  Dim pTemp As Long
  
  Dim oOrig As Long
#End If
  Const ICLRMetaHost_GetRuntime_VTBLINDEX = 3
  Const ICLRRuntimeInfo_GetInterface_VTBLINDEX = 9
  Dim CLSID_CorRuntimeHost As tagGUID
  Dim IID_ICorRuntimeHost As tagGUID

  Dim IID_ICLRRuntimeInfo As tagGUID
    
  oOrig = ObjPtr(pMetaHost)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICLRMetaHost_GetRuntime_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
  'BD39D1D2-BA2F-486a-89B0-B4B0CB466891
  '{0xBD39D1D2, 0xBA2F, 0x486a, {0x89, 0xB0, 0xB4, 0xB0, 0xCB, 0x46, 0x68, 0x91}};
  IID_ICLRRuntimeInfo.dw0 = &HBD39D1D2
  IID_ICLRRuntimeInfo.dw1 = &H486ABA2F
  IID_ICLRRuntimeInfo.dw2 = &HB0B4B089
  IID_ICLRRuntimeInfo.dw3 = &H916846CB
  
  If nVersion >= 40 Then
    strVersion = "v4.0.30319"
  Else
    strVersion = "v2.0.50727"
  End If
  
#If Win64 Then
  hr = PtrStub8AsLong(oOrig, StrPtr(strVersion), VarPtr(IID_ICLRRuntimeInfo), VarPtr(pRuntimeInfo), pFct:=pTemp)
#Else
  hr = PtrFct4(pTemp, oOrig, StrPtr(strVersion), VarPtr(IID_ICLRRuntimeInfo), VarPtr(pRuntimeInfo))
#End If

  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo
  
  
  oOrig = ObjPtr(pRuntimeInfo)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICLRRuntimeInfo_GetInterface_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
  
  
  CLSID_CorRuntimeHost.dw0 = &HCB2F6723
  CLSID_CorRuntimeHost.dw1 = &H11D2AB3A
  CLSID_CorRuntimeHost.dw2 = &HC000409C
  CLSID_CorRuntimeHost.dw3 = &H3E0AA34F

  IID_ICorRuntimeHost.dw0 = &HCB2F6722
  IID_ICorRuntimeHost.dw1 = &H11D2AB3A
  IID_ICorRuntimeHost.dw2 = &HC000409C
  IID_ICorRuntimeHost.dw3 = &H3E0AA34F


#If Win64 Then
  hr = PtrStub8AsLong(oOrig, VarPtr(CLSID_CorRuntimeHost), VarPtr(IID_ICorRuntimeHost), VarPtr(LoadClrMeta), pFct:=pTemp)
#Else
  hr = PtrFct4(pTemp, oOrig, VarPtr(CLSID_CorRuntimeHost), VarPtr(IID_ICorRuntimeHost), VarPtr(LoadClrMeta))
#End If
  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo

  

End Function


        
Public Sub verifySystemVersion()
  If Not isWin32Unicode Then
    Err.Raise vbObjectError, , "this program dows not run under windows 98"
  End If
End Sub


Private Function loadAppDomain(ByVal appDomainName As String, ByVal RootPath As String) As Object 'AppDomain
  Dim oAppDomainSetup As IUnknown 'IAppDomainSetup
  Dim oAppDomain As Object 'AppDomain

  If m_oCorRuntimeHost Is Nothing Then
    verifySystemVersion
    InitFctPtrStub
  
    Set m_oCorRuntimeHost = loadClr(CLR_VERSION)
  
    ICorRuntimeHost_Start m_oCorRuntimeHost
  End If

  '|fffd|berpr|fffd|fen, ob AppDomain bereits existiert, Erfassungsmappen Code pro Version nur einmal geladen werden muss
  If appDomainName = "" Then
    'keine Anwendungsdom|fffd|ne: Defaultdom|fffd|ne: RootPath kann nicht angegeben werden
    Set oAppDomain = ICorRuntimeHost_GetDefaultDomain(m_oCorRuntimeHost)
  Else
    Set oAppDomain = findAppDomain(m_oCorRuntimeHost, appDomainName)
    If oAppDomain Is Nothing Then
      Set oAppDomainSetup = ICorRuntimeHost_CreateDomainSetup(m_oCorRuntimeHost)
    
    
      IAppDomainSetup_setProperties oAppDomainSetup, ApplicationBase:=RootPath, ApplicationName:=appDomainName
      
    
      Set oAppDomain = ICorRuntimeHost_CreateDomainEx(m_oCorRuntimeHost, appDomainName, pSetup:=oAppDomainSetup)
    End If
  End If

  Set loadAppDomain = oAppDomain

End Function



Private Function ICorRuntimeHost_CreateDomainEx(ByVal oCorRuntimeHost As IUnknown, ByVal pwzFriendlyName As String, ByVal pSetup As IUnknown, Optional ByVal pEvidence As IUnknown) As Object 'AppDomain
  Dim hr As Long
  Dim oAppDomainUnk As IUnknown
  Dim o As Object
#If Win64 Then
  Dim pTemp As LongPtr, oOrig As LongPtr
#Else
  Dim pTemp As Long, oOrig As Long
#End If
  Const ICorRuntimeHost_CreateDomainEx_VTBLINDEX = 17
      
  oOrig = ObjPtr(oCorRuntimeHost)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_CreateDomainEx_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
#If Win64 Then

  hr = PtrStub8AsLong(oOrig, StrPtr(pwzFriendlyName), ObjPtr(pSetup), ObjPtr(pEvidence), VarPtr(oAppDomainUnk), pFct:=pTemp)
#Else
  
  hr = PtrFct5(pTemp, oOrig, StrPtr(pwzFriendlyName), ObjPtr(pSetup), ObjPtr(pEvidence), VarPtr(oAppDomainUnk))
#End If
  
  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo

  CopyMemory VarPtr(o), VarPtr(oAppDomainUnk), sizeof_Ptr
  ZeroMemory VarPtr(oAppDomainUnk), sizeof_Ptr

  Set ICorRuntimeHost_CreateDomainEx = o
End Function


Private Function ICorRuntimeHost_GetDefaultDomain(ByVal oCorRuntimeHost As IUnknown) As Object 'AppDomain
  Dim hr As Long
  Dim oAppDomainUnk As IUnknown
  Dim o As Object
#If Win64 Then
  Dim pTemp As LongPtr, oOrig As LongPtr
#Else
  Dim pTemp As Long, oOrig As Long
#End If
  Const ICorRuntimeHost_GetDefaultDomain_VTBLINDEX = 13
      
  oOrig = ObjPtr(oCorRuntimeHost)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_GetDefaultDomain_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
#If Win64 Then

  hr = PtrStub3AsLong(oOrig, VarPtr(oAppDomainUnk), pFct:=pTemp)
#Else
  
  hr = PtrFct2(pTemp, oOrig, VarPtr(oAppDomainUnk))
#End If
  
  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo

  CopyMemory VarPtr(o), VarPtr(oAppDomainUnk), sizeof_Ptr
  ZeroMemory VarPtr(oAppDomainUnk), sizeof_Ptr

  Set ICorRuntimeHost_GetDefaultDomain = o
End Function


Private Function ICorRuntimeHost_CreateDomainSetup(ByVal oCorRuntimeHost As IUnknown) As IUnknown 'IAppDomainSetup
  Dim hr As Long
#If Win64 Then
  Dim pTemp As LongPtr
  
  Dim oOrig As LongPtr
#Else
  Dim pTemp As Long
  
  Dim oOrig As Long
#End If
  Const ICorRuntimeHost_CreateDomainSetup_VTBLINDEX = 18
  Const IUnknown_QueryInterface_VTBLINDEX = 0
  Dim IID_IAppDomainSetup As tagGUID
  Dim oDomainSetupUnk As IUnknown
    
  oOrig = ObjPtr(oCorRuntimeHost)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_CreateDomainSetup_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
#If Win64 Then
  hr = PtrStub3AsLong(oOrig, VarPtr(oDomainSetupUnk), pFct:=pTemp)
#Else
  hr = PtrFct2(pTemp, oOrig, VarPtr(oDomainSetupUnk))
#End If

  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo

  IID_IAppDomainSetup.dw0 = &H27FFF232
  IID_IAppDomainSetup.dw1 = &H40DDA7A8
  IID_IAppDomainSetup.dw2 = &H4A734A8D
  IID_IAppDomainSetup.dw3 = &H41CD9FD5


  oOrig = ObjPtr(oDomainSetupUnk)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + IUnknown_QueryInterface_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
#If Win64 Then
    hr = PtrStub3AsLong(oOrig, VarPtr(IID_IAppDomainSetup), VarPtr(ICorRuntimeHost_CreateDomainSetup), pFct:=pTemp)
#Else
  hr = PtrFct3(pTemp, oOrig, VarPtr(IID_IAppDomainSetup), VarPtr(ICorRuntimeHost_CreateDomainSetup))
#End If

  If hr < 0 Then Err.Raise hr

End Function

        




Private Sub ICorRuntimeHost_Start(ByVal oCorRuntimeHost As IUnknown)
  Dim hr As Long
#If Win64 Then
  Dim pTemp As LongPtr, oOrig As LongPtr
#Else
  Dim pTemp As Long, oOrig As Long
#End If
  Const ICorRuntimeHost_Start_VTBLINDEX = 10
      
  oOrig = ObjPtr(oCorRuntimeHost)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_Start_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
#If Win64 Then
  hr = PtrStub3AsLong(oOrig, pFct:=pTemp)
#Else
  hr = PtrFct1(pTemp, oOrig)
#End If
  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo

End Sub


Private Sub IAppDomainSetup_setProperties(ByVal oAppDomainSetup As IUnknown, Optional ByVal ApplicationBase As String, Optional ByVal ApplicationName As String, Optional ByVal ConfigurationFile As String)
  Dim hr As Long
#If Win64 Then
  Dim pTemp As LongPtr, pVTBL As LongPtr
  Dim oOrig As LongPtr
#Else
  Dim pTemp As Long, oOrig As Long, pVTBL As Long
#End If
  Const IAppDomainSetup_ApplicationBase_Let_VTBLINDEX = 4
  Const IAppDomainSetup_ApplicationName_Let_VTBLINDEX = 6
  Const IAppDomainSetup_ConfigurationFile_Let_VTBLINDEX = 10
      
  oOrig = ObjPtr(oAppDomainSetup)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pVTBL), oOrig, sizeof_Ptr 'VTBL-Pointer

  If ApplicationBase <> "" Then
    CopyMemory VarPtr(pTemp), pVTBL + IAppDomainSetup_ApplicationBase_Let_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
#If Win64 Then
    hr = PtrStub3AsLong(oOrig, StrPtr(ApplicationBase), pFct:=pTemp)
#Else
    hr = PtrFct2(pTemp, oOrig, StrPtr(ApplicationBase))
#End If

    If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo
  End If

  If ApplicationName <> "" Then
    CopyMemory VarPtr(pTemp), pVTBL + IAppDomainSetup_ApplicationName_Let_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
#If Win64 Then
    hr = PtrStub3AsLong(oOrig, StrPtr(ApplicationName), pFct:=pTemp)
#Else
    hr = PtrFct2(pTemp, oOrig, StrPtr(ApplicationName))
#End If


    If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo
  End If

  If ConfigurationFile <> "" Then
    CopyMemory VarPtr(pTemp), pVTBL + IAppDomainSetup_ConfigurationFile_Let_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
#If Win64 Then
    hr = PtrStub3AsLong(oOrig, StrPtr(ConfigurationFile), pFct:=pTemp)
#Else
    hr = PtrFct2(pTemp, oOrig, StrPtr(ConfigurationFile))
#End If
    If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo
  End If
  
End Sub

Private Sub startRootAssembly(ByVal wb As Workbook, ByVal rBootStrap As Range, Optional ByVal bMemLoad As Boolean)
  Dim oUnknownRootType As IUnknown 'Type
  Dim oRootType As Object 'Type
  Dim oAssembly As Object 'Assembly
  Const BindingFlags_Static = &H8
  Const BindingFlags_Public = &H10
  Const BindingFlags_InvokeMethod = &H100
  Dim arData() As Byte
  Dim arResourceData() As Byte
  Dim strRootPath As String
  Dim strAppDomain As String
  Dim strAppClassName As String
  Dim strAppMethodName As String
  Dim strFullName As String
    
  strRootPath = locateInstallationPath
  

  strAppDomain = APP_DOMAIN
  strAppClassName = APP_CLASS_NAME
  strAppMethodName = APP_CLASS_METHODNAME

  If m_oAppDomain Is Nothing Then 'ggf. bereits geladen
      Set m_oAppDomain = loadAppDomain(strAppDomain, strRootPath)
  End If

  

  '|fffd|berpr|fffd|fen, ob Assembly bereits geladen
  Set oAssembly = findAssembly(MAIN_ASSEMBLY)
  
  If Not oAssembly Is Nothing Then
    bMemLoad = False 'bereits existent: kein weiteres MemLoad
  Else
    'Assembly neu laden
    strFullName = strRootPath & MAIN_ASSEMBLY_MODULE
    If FileExists(strFullName) Then
      If bMemLoad Then
        BinaryFileToByteAr strFullName, arData
        Set oAssembly = m_oAppDomain.Load_3(arData)
      Else
        Set oAssembly = m_oAppDomain.Load_2(MAIN_ASSEMBLY)
      End If
    ElseIf Not rBootStrap Is Nothing Then
      BytesFromRange rBootStrap, arData
      Set oAssembly = m_oAppDomain.Load_3(arData)
      bMemLoad = True
    Else
      Err.Raise ERR_INVALIDARG, , "Module '" & strFullName & "' not found"
    End If
  
  End If


  Set oUnknownRootType = oAssembly.GetType_2(strAppClassName)

  CopyMemory VarPtr(oRootType), VarPtr(oUnknownRootType), sizeof_Ptr
  ZeroMemory VarPtr(oUnknownRootType), sizeof_Ptr

  If bMemLoad Then
    'Annahme, dass Stream angeh|fffd|ngte Resourcendaten enth|fffd|lt
    extractAssemblyResourceData arData, arResourceData

    'zuerst Bekanntgabe der Resourcen
    oRootType.InvokeMember_3 "assignResourceLoaderData", BindingFlags_Static Or BindingFlags_Public Or BindingFlags_InvokeMethod, Nothing, Empty, Array(arResourceData)
  End If

  'dann Addin Hauptmethode aufrufen
  Set m_oIntApplication = oRootType.InvokeMember_3(strAppMethodName, BindingFlags_Static Or BindingFlags_Public Or BindingFlags_InvokeMethod, Nothing, Empty, Array(wb))


End Sub

Private Function findAssembly(ByVal Name As String) As Object 'Assembly
  Dim arAssemblies() As IUnknown
  Dim oAssembly As Object
  Dim i As Long
  Dim strName As String
  Dim nFound As Long
  
  arAssemblies = m_oAppDomain.GetAssemblies
  For i = 0 To UBound(arAssemblies)
    Set oAssembly = arAssemblies(i)
    strName = oAssembly.FullName
    nFound = InStr(1, strName, ",")
    If nFound > 0 Then
      strName = Left$(strName, nFound - 1)
    End If
    strName = Trim$(strName)
    If StrComp(strName, Name, vbTextCompare) = 0 Then
      Set findAssembly = oAssembly
      Exit Function
    End If
    
  Next i
  
End Function


Private Function findAppDomain(ByVal oCorRuntimeHost As IUnknown, ByVal Name As String) As Object 'AppDomain
  Dim hr As Long
  Dim oAppDomainUnk As IUnknown
  Dim oAppDomain As Object 'AppDomain
#If Win64 Then
  Dim pTemp As LongPtr, oOrig As LongPtr
  Dim hEnum As LongPtr
#Else
  Dim pTemp As Long, oOrig As Long
  Dim hEnum As Long
#End If
  Const ICorRuntimeHost_EnumDomains_VTBLINDEX = 14
  Const ICorRuntimeHost_NextDomain_VTBLINDEX = 15
  Const ICorRuntimeHost_CloseEnum_VTBLINDEX = 16
      
  oOrig = ObjPtr(oCorRuntimeHost)
  If oOrig = 0 Then Err.Raise vbObjectError
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_EnumDomains_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
#If Win64 Then
  hr = PtrStub3AsLong(oOrig, VarPtr(hEnum), pFct:=pTemp)
#Else
  
  hr = PtrFct2(pTemp, oOrig, VarPtr(hEnum))
#End If
  
  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo
  
  
  'nach Namen suchen
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_NextDomain_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
  
  Do
  
#If Win64 Then
    hr = PtrStub3AsLong(oOrig, hEnum, VarPtr(oAppDomainUnk), pFct:=pTemp)
#Else
    hr = PtrFct3(pTemp, oOrig, hEnum, VarPtr(oAppDomainUnk))
#End If
  
    If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo
    
    If oAppDomainUnk Is Nothing Then
      Exit Do
    End If
  
    CopyMemory VarPtr(oAppDomain), VarPtr(oAppDomainUnk), sizeof_Ptr
    ZeroMemory VarPtr(oAppDomainUnk), sizeof_Ptr
    
    If InStr(1, oAppDomain.toString, "Name:" & Name & vbCrLf, vbTextCompare) = 1 Then
      Exit Do 'gefunden
    Else
      Set oAppDomain = Nothing
    End If
  
  Loop
  
  
  CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
  CopyMemory VarPtr(pTemp), pTemp + ICorRuntimeHost_CloseEnum_VTBLINDEX * sizeof_Ptr, sizeof_Ptr
#If Win64 Then
  hr = PtrStub3AsLong(oOrig, hEnum, pFct:=pTemp)
#Else
  hr = PtrFct2(pTemp, oOrig, hEnum)
#End If

  If hr < 0 Then Err.Raise hr 'TODO: GetErrorInfo


  Set findAppDomain = oAppDomain
End Function


'Annahme, dass Stream arData angeh|fffd|ngte Resourcedaten enth|fffd|lt
'R|fffd|ckgabe der extrahierten Daten
Private Sub extractAssemblyResourceData(ByRef arData() As Byte, ByRef arResourceDataResult() As Byte)
  Dim nSizeResource As Long
  Dim nSize As Long
#If Win64 Then
  Dim p As LongPtr
#Else
  Dim p As Long
#End If

  nSize = UBound(arData) + 1

  If nSize < sizeof_Long Then
    Err.Raise ERR_INVALIDARG
  End If

  p = VarPtr(arData(0)) + nSize - sizeof_Long

  CopyMemory VarPtr(nSizeResource), p, sizeof_Long

  If nSizeResource > nSize Then
    Err.Raise ERR_INVALIDARG
  End If

  If nSizeResource > sizeof_Long Then

    nSizeResource = nSizeResource - sizeof_Long
    ReDim arResourceDataResult(nSizeResource - 1)

    p = p - nSizeResource
    CopyMemory VarPtr(arResourceDataResult(0)), p, nSizeResource
  Else
    Erase arResourceDataResult
  End If
  

  
End Sub


'Datei bin|fffd|r lesen und als Bytearray zur Verf|fffd|gung stellen
Private Sub BinaryFileToByteAr(ByVal FullName As String, ByRef arBytes() As Byte)
  Dim dwFileSize As Long, dwRead As Long
#If Win64 Then
  Dim pBytes As LongPtr
#Else
  Dim pBytes As Long
#End If
  Dim hFile As Long
  Dim nError As Long, strSource As String, strError As String
  Const ERROR_SHARING_VIOLATION = 32
  Const INVALID_HANDLE_VALUE = &HFFFFFFFF
  Const GENERIC_READ = &H80000000
  Const FILE_SHARE_READ = 1
  Const OPEN_EXISTING = 3
  Const FILE_SHARE_WRITE = 2


  
  hFile = INVALID_HANDLE_VALUE
  On Error GoTo ErrHandler
  Debug.Assert isWin32Unicode
  
    'wichtig: FILE_SHARE_READ, damit auch geladene Dll gelesen werden kann
  hFile = CreateFileW(StrPtr(FullName), GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0)
  If hFile = INVALID_HANDLE_VALUE Then
    If Err.LastDllError = ERROR_SHARING_VIOLATION Then
      'Speziell f|fffd|r bereits geladene Excel Verbunddateien (*.xls;*.xla)
      hFile = CreateFileW(StrPtr(FullName), GENERIC_READ, FILE_SHARE_READ Or FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0)
    End If
  End If
  If hFile = INVALID_HANDLE_VALUE Then
    RaiseWinError Err.LastDllError, FullName
  End If
  
  dwFileSize = GetFileSize(hFile, 0)
  If dwFileSize = 0 Then
    Erase arBytes
  Else
    ReDim arBytes(0 To dwFileSize - 1)
    pBytes = VarPtr(arBytes(0))
    
    If ReadFile(hFile, pBytes, dwFileSize, dwRead, 0) = 0 Then
      RaiseWinError Err.LastDllError
    End If
    If dwFileSize <> dwRead Then
      Err.Raise ERR_NOTOK
    End If
  End If
Cleanup:
  If hFile <> INVALID_HANDLE_VALUE Then
    CloseHandle hFile
    hFile = INVALID_HANDLE_VALUE
  End If
  If nError <> 0 Then
    On Error GoTo 0
    Err.Raise nError, strSource, strError
  End If
  Exit Sub

ErrHandler:
  Debug.Assert False
  nError = Err.Number
  strError = Err.Description
  strSource = Err.Source
  On Error Resume Next


  GoTo Cleanup
  Resume
End Sub




#If CENTRALBUILD = 0 Then


Public Function GetIDLAddin() As Object
  Set GetIDLAddin = m_oIntApplication
End Function

'Dezentral
'Einstiegspunkt f|fffd|r externen Lader
Private Sub InitConnectorApplicationImpl()
  Dim r As Range
  Dim rTest As Range
#If DOTNETBUILD Then
  Dim oPlugin As Plugin
#End If
  Dim oPluginCentral As Object
  Dim wb As Workbook
  Dim oConnctorApplication As Object
  Dim wsData As Worksheet
  Const STRCLSID_SINGLETON = "{B2952DE6-2A57-44DD-B1C3-47DB8BB0254D}"

  If m_oIntApplication Is Nothing Then

    On Error Resume Next
    'zuerst Dezentral antesten, sonst ggf. Probleme
    'an sich m|fffd|sste die Versionierung automatisch laufen
    'allerdings sind wegen Sicherheitserweiterungen die Ladezeiten teilweise so verschoben, dass es zu Konflikten kommt
    Set oConnctorApplication = Run("GetConnectorApplicationInternal")
    If Not oConnctorApplication Is Nothing Then
      Set oPluginCentral = oConnctorApplication.InternalApplication.Plugins("DC")
    End If
    If Not oPluginCentral Is Nothing Then
      Exit Sub
    End If


    Set wb = ThisWorkbook

    Set wb = Application.Workbooks(wb.Name) 'normalisieren

#If Win64 = 0 Then

    If m_oIntApplication Is Nothing Then
      'klassischer Modus nur 32 Bit
      On Error Resume Next
      Set wsData = wb.Worksheets!Struktur
      Set r = wsData.[IDL_START] 'kein Addin, falls IDL_START nicht verf|fffd|gbar (auch bei Vorlage ggf. der Fall)
          Set rTest = wsData.[IDL_START_NET]
      On Error GoTo 0
      If Not r Is Nothing Then
#If DOTNETBUILD Then
        'bei DOTNETBUILD: klassischen Starter vorl|fffd|ufig als Singleton, solange bis DotNet gut genug l|fffd|uft
      Dim strTemp As String
      Dim hr As Long
      Dim clsid As tagGUID
      Dim IID_IDispatch As tagGUID
      Dim oApplication As Application
      Const REGCLS_MULTIPLEUSE As Long = 1


      If ExcelVersionInt >= 12 And Not rTest Is Nothing Then
        Dim vntDotNetEnabled As Variant
        
        Profile_Read "Options.DotNetEnabled", vntDotNetEnabled
        If Trim(vntDotNetEnabled) = "1" Then
          GoTo DotNetExcel2013Start 'nur DotNet Explizit enablen
        End If
      End If



      strTemp = "{00020400-0000-0000-C000-000000000046}"
      IIDFromString StrPtr(strTemp), IID_IDispatch

      strTemp = STRCLSID_SINGLETON
      CLSIDFromString StrPtr(strTemp), clsid
      hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, 0, IID_IDispatch, VarPtr(m_oIntApplication))
      If hr < 0 Then
        Set oApplication = Application.Application
        Set m_oIntApplication = InitIntApplication(ObjPtr(oApplication), r)
        hr = CoRegisterClassObject(clsid, m_oIntApplication, CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, 0)
        Debug.Assert hr >= 0
      End If
      Set oPlugin = New Plugin
      oPlugin.InitAsPlugin wb

#Else
      Set m_oIntApplication = InitIntApplication(ObjPtr(wb), r)
#End If

      End If
    End If
#End If


#If DOTNETBUILD Then
    If m_oIntApplication Is Nothing Then

DotNetExcel2013Start:

      On Error Resume Next
      Set wsData = wb.Worksheets!Struktur
      Set r = wsData.[IDL_START_NET]
      On Error GoTo 0
  
      If Not r Is Nothing Then
        If ExcelVersionInt < 12 Then
          Err.Raise vbObjectError, , "This Plugin requires Office 2007 or higher"
        End If
    
    
    
        Set oPlugin = New Plugin
        startRootAssembly wb, r, bMemLoad:=isMemLoad
        oPlugin.InitAsPlugin wb
      End If
    End If
#End If

    If m_oIntApplication Is Nothing Then
#If Win64 = 1 Then
     Err.Raise vbObjectError, , "This Plugin can not run under 64 Bit Version of Excel"
#End If
      Err.Raise vbObjectError, , "Internal starter (IDL_START) is missing"
    End If

  End If

End Sub


#End If

'Hauptversionsnr von Excel
Public Property Get ExcelVersionInt() As Long
  Dim strVersion As String
  Dim i As Long

  strVersion = Application.Version
  i = InStr(1, strVersion, ".")
  If i > 0 Then
    strVersion = Left$(strVersion, i - 1)
  End If
  i = CLng(strVersion)
  ExcelVersionInt = i
End Property


#If Win64 = 0 Then





'ww56
'Public Function InitIntApplication(ByVal ContextPtr As long, ByVal r As Range, optional ByVal pData as long, Optional ByVal size as long) As Object
Public Function InitIntApplication(ByVal p10 As Long, ByVal p13 As Range, Optional ByVal p14 As Long, Optional ByVal p15 As Long) As Object
  Dim p0 As Long, p1 As Long, p2 As Long, p3 As Long, p4 As Long, p5 As Long, p6 As Long
  Dim p7(0 To 157) As Long
  Dim p8 As String
  Dim p9() As String
  'Dim p10 As Object, p11 As Object 'ww56
  Dim p11 As Object
  Dim p12 As Range ', p13 As Range

  verifySystemVersion

  InitFctPtrStub

  p7(0) = &H51EC8B55: p7(1) = &H530C4D8B: p7(2) = &HC18B5756: p7(3) = &H5F99046A: p7(4) = &HF708758B: p7(5) = &HFC4D89FF: p7(6) = &H850FD285: p7(7) = 457: p7(8) = &H7E144D3B: p7(9) = &H321B80A: p7(10) = &HF9E98009: p7(11) = &H33000001: p7(12) = &H4F983FF: p7(13) = &HA68E0F: p7(14) = &H8B660000: p7(15) = &HECE85006: p7(16) = &HF000001: p7(17) = &HF883C0B6: p7(18) = &H4589593F: p7(19) = &H968F0F0C: p7(20) = &H66000001: p7(21) = &H5002468B: p7(22) = &H1D2E8: p7(23) = &HC0B60F00: p7(24) = &H593FF883: p7(25) = &HF084589: p7(26) = &H17C8F: p7(27) = &H468B6600: p7(28) = &HB8E85004: p7(29) = &HF000001: p7(30) = &HFB83D8B6: p7(31) = &H8F0F593F
  p7(32) = 357: p7(33) = &H6468B66: p7(34) = &H1A1E850: p7(35) = &HB60F0000: p7(36) = &H3FF883C0: p7(37) = &H14458959: p7(38) = &H14B8F0F: p7(39) = &H4D8B0000: p7(40) = &HC458A08: p7(41) = &H6D83D18B: p7(42) = &HFAC104FC: p7(43) = &H2E0C004: p7(44) = &H458BD00A: p7(45) = &H4E1C010: p7(46) = &H8B071488: p7(47) = &H2FAC1D3: p7(48) = &HA06E3C0: p7(49) = &HD10A145D: p7(50) = &H1075488: p7(51) = &H8808C683: p7(52) = &H8302075C: p7(53) = &H7D8303C7: p7(54) = &H8F0F04FC: p7(55) = &HFFFFFF5A: p7(56) = &H47E8366: p7(57) = &H6641753D: p7(58) = &HE850068B: p7(59) = 319: p7(60) = &H83D8B60F: p7(61) = &HF593FFB: p7(62) = 60559: p7(63) = &H468B6600
  p7(64) = &H28E85002: p7(65) = &HF000001: p7(66) = &HF883C0B6: p7(67) = &H8F0F593F: p7(68) = 213: p7(69) = &HC1104D8B: p7(70) = &HE3C004F8: p7(71) = &H88C30A02: p7(72) = &HE9470F04: p7(73) = 249: p7(74) = &H66068B66: p7(75) = &H3D067E83: p7(76) = &HE8667550: p7(77) = 247: p7(78) = &H83C0B60F: p7(79) = &H89593FF8: p7(80) = &H8F0F0C45: p7(81) = 161: p7(82) = &H2468B66: p7(83) = &HDDE850: p7(84) = &HB60F0000: p7(85) = &H3FFB83D8: p7(86) = &H8A8F0F59: p7(87) = &H66000000: p7(88) = &H5004468B: p7(89) = 50920: p7(90) = &HB60F5900: p7(91) = &H3FF983C8: p7(92) = &H458B777F: p7(93) = &HC1D38B10: p7(94) = &H348D04FA: p7(95) = &HC458A07
  p7(96) = &HC102E0C0: p7(97) = &HE3C002F9: p7(98) = &HAD00A04: p7(99) = &H168847CB: p7(100) = &H47014E88: p7(101) = 35049: p7(102) = &H91E800: p7(103) = &HB60F0000: p7(104) = &H3FF883C0: p7(105) = &HC458959: p7(106) = &H8B663F7F: p7(107) = &HE8500246: p7(108) = 123: p7(109) = &H83C0B60F: p7(110) = &H89593FF8: p7(111) = &H297F0845: p7(112) = &H4468B66: p7(113) = &H65E850: p7(114) = &HB60F0000: p7(115) = &H3FFB83D8: p7(116) = &H66167F59: p7(117) = &H5006468B: p7(118) = 21224: p7(119) = &HC0B60F00: p7(120) = &H593FF883: p7(121) = &H7E144589: p7(122) = &H308B807: p7(123) = &H38EB8009: p7(124) = &H8A10458B: p7(125) = &HE1C00C4D: p7(126) = &H7348D02: p7(127) = &H8B08458B
  p7(128) = &H4FAC1D0: p7(129) = &HCB8BD10A: p7(130) = &HC002F9C1: p7(131) = &HE3C004E0: p7(132) = &H145D0A06: p7(133) = &H1688C80A: p7(134) = &H88014E88: p7(135) = &HC783025E: p7(136) = &H18458B03: p7(137) = &HC0333889: p7(138) = &HC95B5E5F: p7(139) = &H8B0014C2: p7(140) = &H66042444: p7(141) = &H7200413D: p7(142) = &H5A3D660A: p7(143) = &H83047700: p7(144) = &H66C3BFC0: p7(145) = &H7200613D: p7(146) = &H7A3D660A: p7(147) = &H83047700: p7(148) = &H66C3B9C0: p7(149) = &H7200303D: p7(150) = &H393D660A: p7(151) = &H83047700: p7(152) = &H66C304C0: p7(153) = &H75002B3D: p7(154) = &HC33EB003: p7(155) = &H2F3D66: p7(156) = &H83C0950F: p7(157) = &HC33FC0
  p1 = VirtualAlloc(0, 631, &H3000, &H40)
  If p1 = 0 Then
    RaiseWinError Err.LastDllError
  End If
  CopyMemory p1, VarPtr(p7(0)), 631
'#If DECENTRAL_TEMPLATE = 0 Then 'ww56
'  Set p13 = r 'Data.[IDL0]
'#End If
  ReDim p9(p13.count - 1)
  For Each p12 In p13
    p9(p5) = p12.Value
    p2 = p2 + Len(p9(p5))
    p5 = p5 + 1
  Next p12
  p4 = p2 * 3 / 4 + 1
  p6 = VirtualAlloc(0, p4, &H3000, &H40)
  If p6 = 0 Then
    RaiseWinError Err.LastDllError
  End If
  p3 = 0
  p4 = 0
  For p5 = 0 To UBound(p9)
    p0 = PtrFct5(p1, StrPtr(p9(p5)), Len(p9(p5)), p6 + p3, p2 - p3, VarPtr(p4))
    If p0 < 0 Then Err.Raise p0
    p3 = p3 + p4
  Next p5
  VirtualFree p1, 0, 32768

  'Set p10 = Context 'ww56
  p8 = "Kernel32" 'ww58
  p1 = GetModuleHandleW(StrPtr(p8))

  p8 = ""
  If p14 = 0 Then 'ww62
    p15 = p3
  End If
  p0 = PtrFct6(p6, p14, p15, p1, p10, VarPtr(p11), VarPtr(p8)) 'ww62
  VirtualFree p6, 0, 32768
  If p0 < 0 Then
    If p8 = "" Then
      Err.Raise p0
    Else
      Err.Raise p0, , p8
    End If
  End If
  
  Set InitIntApplication = p11
End Function





#End If


Private Function decode(ByVal c As Integer) As Integer
  Const ASC_A_U = 65
  Const ASC_Z_U = 90
  Const ASC_A = 97
  Const ASC_Z = 122
  Const ASC_0 = 48
  Const ASC_9 = 57
  Const ASC_Plus = 43
  Const ASC_Divide = 47
  
  If c >= ASC_A_U And c <= ASC_Z_U Then
    decode = c - ASC_A_U
  ElseIf c >= ASC_A And c <= ASC_Z Then
    decode = c - ASC_A + 26
  ElseIf c >= ASC_0 And c <= ASC_9 Then
    decode = c - ASC_0 + 52
  ElseIf c = ASC_Plus Then
    decode = 62
  ElseIf c = ASC_Divide Then
    decode = 63
  Else
    Err.Raise vbObjectError
  End If
End Function

Private Function shiftLeft(ByVal l As Long, ByVal count As Integer) As Long
  Do While count > 0
    l = l * &H2
    count = count - 1
  Loop
  shiftLeft = l
End Function


Private Function shiftRight(ByVal l As Long, ByVal count As Integer) As Long
  Do While count > 0
    l = l \ &H2
    count = count - 1
  Loop
  shiftRight = l

End Function


#If VBA7 Then
Public Sub decodeBase64(ByVal in_buf As LongPtr, ByVal in_len As Long, ByVal out_buf As LongPtr, ByVal max_len As Long, ByRef out_len As Long)
#Else
Public Sub decodeBase64(ByVal in_buf As Long, ByVal in_len As Long, ByVal out_buf As Long, ByVal max_len As Long, ByRef out_len As Long)
#End If
  Dim nLen As Long
#If VBA7 Then
  Dim d As LongPtr
#Else
  Dim d As Long
#End If
  Dim ip0 As Long, ip1 As Long, ip2 As Long, ip3 As Long
  Dim ipTemp As Long
  Dim c As Integer
  Dim nOutIndex As Long
  Const ASC_Equal = 61

  
  nLen = in_len
  d = in_buf

  If (in_len Mod 4) <> 0 Then
   Err.Raise vbObjectError
  End If


  If in_len > max_len Then
   Err.Raise vbObjectError
  End If
  nOutIndex = 0
  Do While nLen > 0
  
    CopyMemory VarPtr(c), d, sizeof_Short
    ip0 = decode(c)
    d = d + sizeof_Short
    
    CopyMemory VarPtr(c), d, sizeof_Short
    ip1 = decode(c)
    d = d + sizeof_Short
    
    CopyMemory VarPtr(c), d, sizeof_Short
    If c = ASC_Equal Then
      If nLen > 4 Then
        Err.Raise vbObjectError
      End If
      ip2 = -1
    Else

      ip2 = decode(c)
      d = d + sizeof_Short
    End If
    
    CopyMemory VarPtr(c), d, sizeof_Short
    If c = ASC_Equal Then
      If nLen > 4 Then
        Err.Raise vbObjectError
      End If
      ip3 = -1
    Else
      ip3 = decode(c)
      d = d + sizeof_Short
    End If
    
    If nOutIndex = max_len Then
      Err.Raise vbObjectError
    End If
    ipTemp = ((shiftLeft(ip0, 2)) Or (shiftRight(ip1, 4)))
    CopyMemory out_buf, VarPtr(ipTemp), 1
    out_buf = out_buf + 1
    nOutIndex = nOutIndex + 1

    If ip2 >= 0 Then
      If nOutIndex = max_len Then
        Err.Raise vbObjectError
      End If
      
      ipTemp = ((shiftLeft(ip1, 4)) Or (shiftRight(ip2, 2)))
      CopyMemory out_buf, VarPtr(ipTemp), 1
      out_buf = out_buf + 1
      nOutIndex = nOutIndex + 1
    End If

    If ip3 >= 0 Then
      If nOutIndex = max_len Then
        Err.Raise vbObjectError
      End If
      ipTemp = (shiftLeft(ip2, 6) Or ip3)
      CopyMemory out_buf, VarPtr(ipTemp), 1
      out_buf = out_buf + 1
      nOutIndex = nOutIndex + 1
    End If

'      out_buf[i + 0] = (ip0 << 2) | (ip1 >> 4);
'      out_buf[i + 1] = (ip1 << 4) | (ip2 >> 2);
'      out_buf[i + 2] = (ip2 << 6) |  ip3;
    nLen = nLen - 4
  Loop

'    if(d[2] == '=')
'    {
'        if((ip0 = decode(d[0])) > 63)
'            return SEC_E_INVALID_TOKEN;
'        if((ip1 = decode(d[1])) > 63)
'            return SEC_E_INVALID_TOKEN;
'
'        out_buf[i] = (ip0 << 2) | (ip1 >> 4);
'        i++;
'    }
'    else if(d[3] == '=')
'    {
'        if((ip0 = decode(d[0])) > 63)
'            return SEC_E_INVALID_TOKEN;
'        if((ip1 = decode(d[1])) > 63)
'            return SEC_E_INVALID_TOKEN;
'        if((ip2 = decode(d[2])) > 63)
'            return SEC_E_INVALID_TOKEN;
'
'        out_buf[i + 0] = (ip0 << 2) | (ip1 >> 4);
'        out_buf[i + 1] = (ip1 << 4) | (ip2 >> 2);
'        i += 2;
'    }
'    Else
'    {
'        if((ip0 = decode(d[0])) > 63)
'            return SEC_E_INVALID_TOKEN;
'        if((ip1 = decode(d[1])) > 63)
'            return SEC_E_INVALID_TOKEN;
'        if((ip2 = decode(d[2])) > 63)
'            return SEC_E_INVALID_TOKEN;
'        if((ip3 = decode(d[3])) > 63)
'            return SEC_E_INVALID_TOKEN;
'
'
'        out_buf[i + 0] = (ip0 << 2) | (ip1 >> 4);
'        out_buf[i + 1] = (ip1 << 4) | (ip2 >> 2);
'        out_buf[i + 2] = (ip2 << 6) |  ip3;
'        i += 3;
'    }
  out_len = nOutIndex
End Sub

Private Sub BytesFromRange(ByVal p13 As Excel.Range, ByRef arDataResult() As Byte)
  Dim p2 As Long, p3 As Long, p4 As Long, p5 As Long
#If VBA7 Then
  Dim p6 As LongPtr
#Else
  Dim p6 As Long
#End If
  Dim p9() As String
  Dim p12 As Excel.Range
  
  ReDim p9(p13.count - 1)
  For Each p12 In p13
    p9(p5) = p12.Value
    p2 = p2 + Len(p9(p5))
    p5 = p5 + 1
  Next p12
  p4 = p2 * 3 / 4 + 1
  
  
  ReDim arDataResult(0 To p4 - 1)
  p6 = VarPtr(arDataResult(0))
  
  p3 = 0
  p4 = 0
  For p5 = 0 To UBound(p9)
    decodeBase64 StrPtr(p9(p5)), Len(p9(p5)), p6 + p3, p2 - p3, p4
    p3 = p3 + p4
  Next p5

  If p3 < UBound(arDataResult) + 1 Then
    'genaue Obergrenze einhalten, damit keine F|fffd|llbytes
    ReDim Preserve arDataResult(p3 - 1)
  End If


  
End Sub




Public Sub Auto_Open()
    On Error GoTo ErrHandler
#If DEBUGBUILD Then
    Stop
#End If

  If Application.UserControl And m_oIntApplication Is Nothing Then
    'Default Laden nur wenn Excel unter Benutzerkontrolle
    'programmatischer Start: Steuerung muss explizit Ladevorgang anstossen bzw. alternativen Ladevorgang ausf|fffd|hren
    InitConnectorApplicationImpl
  End If

Exit Sub

ErrHandler:
  If Application.DisplayAlerts Then
    MsgBox Err.Description & vbLf & "ERROR=" & Hex(Err.Number) & vbLf & "SOURCE=" & Err.Source, vbCritical
  End If

End Sub


Public Property Get IntApplication() As Object
  If m_oIntApplication Is Nothing Then
    InitConnectorApplicationImpl
  End If
  Set IntApplication = m_oIntApplication
End Property

Public Property Set IntApplication(ByVal o As Object)
  Set m_oIntApplication = o
End Property


#If CENTRALBUILD Then



Public Property Get IDLAddinManager() As Object
  If m_oIDLAddinManager Is Nothing Then
    Set m_oIDLAddinManager = New IDLAddinManager
    If Not m_oIntApplication Is Nothing Then
      m_oIDLAddinManager.notifyInprocConnector
    End If
  End If
  Set IDLAddinManager = m_oIDLAddinManager
End Property



Public Property Get IDLAddinManagerDecentral() As Object
  If m_oIDLAddinManager Is Nothing Then
    Set m_oIDLAddinManager = New IDLAddinManager
  End If
  Set IDLAddinManagerDecentral = m_oIDLAddinManager
End Property



Private Function getCommandLineInternal() As String
  Dim strCommandLine As String
#If Win64 Then
  Dim pCommandLine As LongPtr
#Else
  Dim pCommandLine As Long
#End If
  Dim nLen As Long

  pCommandLine = GetCommandLineW
  nLen = lstrlenW(pCommandLine)

  strCommandLine = String$(nLen, 0)
  CopyMemory StrPtr(strCommandLine), pCommandLine, (nLen + 1) * 2
  getCommandLineInternal = strCommandLine
End Function

Private Function detectInplaceStart() As Boolean
  Dim wb As Excel.Workbook
  
  If Not m_bProgrammaticStart Then

    If InStr(1, getCommandLineInternal, "-Embedding", vbTextCompare) > 0 Then
      'interne Kommandozeile bevorzugen
      detectInplaceStart = True
      Exit Function
    End If
    
    For Each wb In ThisWorkbook.Application.Workbooks
    
      If wb.IsInplace Then
        detectInplaceStart = True
        Exit Function
      End If
    Next wb
  End If

End Function


Private Sub createDefaultMenu()
  Dim oCommandBar As CommandBar
  Dim oPopup As CommandBarPopup
  Dim strText As String

  Set oCommandBar = CommandBars.Add("IDL.Office.MenuShort", temporary:=True, Position:=MsoBarPosition.msoBarTop)
  With oCommandBar.Controls
    If GetThreadLocale = LCID_GERMAN Then
      strText = "Connector Mappe bearbeiten ..."
    Else
      strText = "edit connector workbook ..."
    End If
    
    With .Add
      .style = msoButtonCaption
      .Caption = strText
      .OnAction = ThisWorkbook.Name & "!OpenConnectorWorkbook"
    End With
  End With
  oCommandBar.Visible = True

End Sub

Public Sub OpenConnectorWorkbook()
  Dim wb As Workbook
  Dim strFullName As String
  Dim strError As String
  Dim oIDLAddinManager As New IDLAddinManager
  On Error GoTo ErrHandler

  If m_oIDLAddinManager Is Nothing Then
    Set m_oIDLAddinManager = New IDLAddinManager
    If Not m_oIntApplication Is Nothing Then
      m_oIDLAddinManager.notifyInprocConnector
    End If

  End If

  Set wb = ActiveWorkbook
  If wb Is Nothing Then
    Set wb = Application.Workbooks.Add 'neue Mappe als Moniker
  End If

  If Not wb Is Nothing Then
    strFullName = wb.FullName
  End If
  m_oIDLAddinManager.runSpreadApp strFullName

  Exit Sub

ErrHandler:
  MsgBox Err.Description, vbCritical

End Sub

Private Sub InitConnectorApplicationImpl()
  Dim strModuleFullName As String
  Dim strError As String
  Dim nError As Long
  Dim i As Long
  Dim oAddinKVM100 As AddIn
  Dim nAppIsolation As Long
  Dim strPath As String
  Const ERROR_FILE_NOT_FOUND = 2
  
  Dim bDotNetStart As Boolean
  Dim wbContext As Excel.Workbook

  If m_bInitDone Then
    Exit Sub
  End If
  m_bInitDone = True

  If m_oIDLAddinManager Is Nothing Then
    Set m_oIDLAddinManager = New IDLAddinManager 'sofort zuweisen, damit Addin Ladeereignisse auch w|fffd|hrend Addin-Startup registriert
  End If
  nAppIsolation = m_oIDLAddinManager.AppIsolation

#If Win64 = 0 Then
  'inplace vorl|fffd|ufig nicht starten, da Probleme
  'nicht bei App-Isolation, TODO: genauer
  If detectInplaceStart Then
    'vereinfachtes |fffd|ffnen Men|fffd|
    createDefaultMenu
    Exit Sub
  End If
#End If


  Set wbContext = Application.Workbooks(ThisWorkbook.Name) 'normalisieren

  
           
On Error Resume Next
  Set oAddinKVM100 = AddIns("KVM100")
On Error GoTo ErrHandler
  If Not oAddinKVM100 Is Nothing Then
    oAddinKVM100.Installed = False 'altes KVM100 de aktivieren
  End If
  If Not m_oIntApplication Is Nothing Then 'k|fffd|nnte bereits durch andere Addins geladen sein (GetConnectorApplication)
    Exit Sub
  End If

#If Win64 = 1 Then
  If nAppIsolation = 0 Then
    nAppIsolation = 2 'Default f|fffd|r Win64
  End If
  If nAppIsolation = 2 Then
    bDotNetStart = True 'bei Win64 f|fffd|r Isolationsmodus = 2, nur hier wird Modus 2 ausgewertet
  End If
#Else
  If nAppIsolation = 2 Then
    bDotNetStart = True 'bei Win32 f|fffd|r Isolationsmodus = 2, nur hier wird Modus 2 ausgewertet
  End If
#End If
  


If nAppIsolation = 3 Then
  'beste Isolation: separate SpreadApp
  m_oIDLAddinManager.initSpreadApp
  'vereinfachtes |fffd|ffnen Men|fffd|
  createDefaultMenu
  Exit Sub 'vorl|fffd|ufig kein Start, da nicht robust

Else

  Dim vntDotNetEnabled As Variant
  
  Profile_Read "Options.DotNetEnabled", vntDotNetEnabled
  If Trim(vntDotNetEnabled) = "0" Then
    GoTo LegacyStart
  End If

  i = IDLDecentralEntry.ExcelVersionInt
  If i >= 12 Then
    'XLSLink automatisch detektieren und als .Net Wurzelpfad eintragen, falls verf|fffd|gbar und nicht bereits automatisch geladen
    strPath = detectXLSLinkStart
    If strPath <> "" And m_oAppDomain Is Nothing Then
      bDotNetStart = True
      Set m_oAppDomain = loadAppDomain(APP_DOMAIN, strPath)
    End If
  End If

  i = IDLDecentralEntry.ExcelVersionInt
  If m_oAppDomain Is Nothing And i >= 12 And i <= 14 Then 'DOT Net ab Office2007 bis Office 2010 optional laden, ab Office2013 obligatorisch
    On Error Resume Next
    startRootAssembly wbContext, Nothing, bMemLoad:=isMemLoad

    On Error GoTo ErrHandler
    bDotNetStart = (Not m_oIntApplication Is Nothing)
  ElseIf i >= 15 Then
    bDotNetStart = True
  End If
End If
  
  If m_oIntApplication Is Nothing Then
    If bDotNetStart Then
      startRootAssembly wbContext, Nothing, bMemLoad:=isMemLoad
    Else
LegacyStart:
#If Win64 = 1 Then
        Debug.Assert False
#Else

          strModuleFullName = locateInstallationPath & MAIN_MODULE_LEGACY

      Set m_oIntApplication = m_oIDLAddinManager.LoadDllModule(strModuleFullName, wbContext)
#End If
    End If
  End If
  If Not m_oIntApplication Is Nothing And Not m_oIDLAddinManager Is Nothing Then
    m_oIDLAddinManager.notifyInprocConnector
  End If

  If Not m_oIDLAddinManager Is Nothing Then
    If Not m_oIDLAddinManager.isSpreadApp And m_oIDLAddinManager.isInprocConnector Then
      Set m_oIDLAddinManager = Nothing 'ab jetzt Addins Manager des Connectors
    End If
  End If

'  'vereinfachtes |fffd|ffnen Men|fffd|
'  createDefaultMenu
  
Cleanup:
  If nError <> 0 Then
    Set m_oIntApplication = Nothing
    On Error GoTo 0
    Err.Raise nError, , strError
  End If
  Exit Sub
ErrHandler:
  nError = Err.Number
  strError = Err.Description
  On Error Resume Next

  If bDotNetStart Then
    strModuleFullName = locateInstallationPath & MAIN_ASSEMBLY_MODULE
  ElseIf strModuleFullName = "" Then
    strModuleFullName = locateInstallationPath & MAIN_MODULE_LEGACY
  End If
  'Information |fffd|ber Komponente hinzuf|fffd|gen
  If strModuleFullName <> "" Then
    If GetThreadLocale = LCID_GERMAN Then
      strError = "Fehler beim Starten der Komponente " & strModuleFullName & vbLf & strError
    Else
      strError = "Error starting component " & strModuleFullName & vbLf & strError
    End If
  End If

  
  GoTo Cleanup
End Sub


'XLSLink dynamisch nachladen, falls erforderlich
Private Function detectXLSLinkStart() As String
  Dim oAddin As AddIn
  Dim strFullName As String
  Dim strPath As String
  Dim i As Long
  
  On Error Resume Next
  Dim vntAddinPath As Variant
  Dim bAutoDetect As Boolean
  Dim strPathDetected As String
  Dim bWriteProfile As Boolean
  
  Set oAddin = Application.AddIns("IDL_ExcelDna")
  
  
  Profile_Read "Options.AppDomainRootPath", vntAddinPath
  If vntAddinPath = "1" Then
    bAutoDetect = True
  ElseIf vntAddinPath = "0" Or vntAddinPath = "2" Then
  ElseIf vntAddinPath <> "" Then
    strPath = vntAddinPath
    If Right$(strPath, 1) <> "\" Then
      strPath = strPath & "\"
    End If
    strFullName = strPath & "IDL.XLSLINK.exe"
    If FileExists(strFullName) Then
      strPathDetected = strPath
    End If
  
  End If
  If bAutoDetect Then
  
    strPath = locateInstallationPath & "..\Components\XLSLink\"
#If Win64 Then
    strPath = strPath & "x64\"
#Else
    strPath = strPath & "x86\"
#End If

    strFullName = strPath & "IDL.XLSLINK.exe"
    
    If FileExists(strFullName) Then
      strPathDetected = strPath
    Else
      'Test !!!!!
      'XLSLink im eigenen Verzeichnis
      strPath = locateInstallationPath
      strFullName = strPath & "IDL.XLSLINK.exe"
      If FileExists(strFullName) Then
        strPathDetected = strPath
      End If
    End If
  
  End If
  
  If Not oAddin Is Nothing Then
    If oAddin.Installed Then
    
      Exit Function 'vorl|fffd|ufig keine Integration
    
      strFullName = oAddin.FullName
      strPath = oAddin.Path
      If Right$(strPath, 1) <> "\" Then
        strPath = strPath & "\"
      End If
      i = InStrRev(strPath, "IDLAddIn\", Compare:=vbTextCompare)
      If i > 0 Then
        strPath = Left$(strPath, i - 1)
      End If
      strFullName = strPath & "IDL.XLSLINK.exe"
      If FileExists(strFullName) Then
        strPathDetected = strPath
      End If
    
    
    
      If vntAddinPath = "2" Then
        'XLSLink nebeneinander
        strPathDetected = ""
      Else
        oAddin.Installed = False
        Application.StatusBar = Empty
        bWriteProfile = True
      End If
    End If
  End If
  
  If strPathDetected <> "" And bWriteProfile Then
    Profile_Write "Options.AppDomainRootPath", strPathDetected
  End If
  
  detectXLSLinkStart = strPathDetected
  
End Function


Public Property Get isMemLoadDll() As Boolean
  Dim vntMemLoad As Variant
  
  Profile_Read "Options.MemLoad", vntMemLoad
  If Trim(vntMemLoad) = "" Then
        'bei Excel 2013 wegen Datenausf|fffd|hrungskonflikt Default kein Mem Load f|fffd|r Dlls
        'isMemLoadDll = (ExcelVersionInt < 15)
        isMemLoadDll = False 'momentan: Default kein MemLoad
  Else
        isMemLoadDll = (vntMemLoad = "1")
  End If
End Property

#End If 'CENTRALBUILD


Public Property Get isMemLoad() As Boolean
  Dim vntMemLoad As Variant
  
  Profile_Read "Options.MemLoad", vntMemLoad
  isMemLoad = (vntMemLoad <> "0")
End Property


'Installationspfad gem|fffd|ss Regeln von ConnectorConfig.cls lokalisieren
Private Function locateInstallationPath() As String
  Dim strInstallationPath As String
  Dim vntPath As String
  Dim strFullNameContext As String

  


  If strInstallationPath = "" Then
    '|fffd|berpr|fffd|fen, ob Hauptmodul im eigenen Verzeichnis
    strInstallationPath = AddinPath

#If CENTRALBUILD Then
        'nur zentral ist Hauptmodul erforderlich
    vntPath = strInstallationPath & MAIN_MODULE
    If Not FileExists(vntPath) Then
      strInstallationPath = ""
    ElseIf strFullNameContext = "" Then
      strFullNameContext = vntPath
    End If
#End If
  End If

  If strInstallationPath = "" Then
    'ini Eintrag auf Verweise auf Hauptmodul |fffd|berpr|fffd|fen
    Profile_Read "Options.IDLConnectorPath", vntPath
    If vntPath <> "" Then
      If Right$(vntPath, 1) <> "\" Then
        vntPath = vntPath & "\"
      End If
      strFullNameContext = vntPath & MAIN_MODULE
      If FileExists(strFullNameContext) Then
        strInstallationPath = vntPath
      Else
        strInstallationPath = ""
      End If
    End If
  End If


  If strInstallationPath = "" Then
    If strFullNameContext = "" Then
      strFullNameContext = MAIN_MODULE
    End If
    Err.Raise vbObjectError, "IDL Connector", "Main module (" & strFullNameContext & ") not found"
  End If

  locateInstallationPath = strInstallationPath

End Function

Public Property Get InstallationPath() As String
  InstallationPath = locateInstallationPath
End Property


Public Sub Profile_Read(Name As String, ByRef vntResult As Variant)
  Dim strProfileFullName As String
  strProfileFullName = Profile_FullName

  If FileExists(strProfileFullName) Then
    Ini_Read strProfileFullName, Name, vntResult
  Else
    vntResult = Empty
  End If
End Sub

Public Property Get Profile_FullName() As String
  Dim strPath As String

  If m_strProfileFullName = "" Then
    m_strProfileFullName = AddinPath & "Connector.ini"
    If Not FileExists(m_strProfileFullName) Then
      strPath = VBA.Environ$("AppData")
      If strPath <> "" Then
        If Right$(strPath, 1) <> "\" Then
          strPath = strPath & "\"
        End If
        m_strProfileFullName = strPath & "IDL\Connector\Connector.ini"
      End If
      
    End If
  End If

  Profile_FullName = m_strProfileFullName
End Property

Public Sub Profile_Write(Name As String, ByRef vntValue As Variant)
  Dim strProfileFullName As String
  strProfileFullName = Profile_FullName
  Ini_Write strProfileFullName, Name, vntValue
End Sub

'Externe Funktion f|fffd|r Lesen aus Ini Datei
'in Path: Notation "." getrennt
'Subset aus ini.bas
Private Sub Ini_Read(strIniFullPath As String, Name As String, ByRef vntResult As Variant)
  Dim bEmpty As Boolean
  Dim i As Long
  Dim folder_ActSection As String
  Dim folder_actEntry As String
  Const IniNameSeparator = "_"   'Separator zur Bildung von Untereintr|fffd|gen in IniFile
  Const IniStringMAXLEN = 1024
  Dim strValue As String
  Dim nLen As Long
  Const EMPTY_STRING = "<EMPTY>"

  
  If strIniFullPath = "" Or Name = "" Then Err.Raise vbObjectError
  
  i = InStr(1, Name, ".")
  If i > 0 Then
    folder_ActSection = Left$(Name, i - 1)
    folder_actEntry = Replace$(Mid$(Name, i + 1), ".", IniNameSeparator)
  Else
    folder_ActSection = Name
  End If
  
  strValue = String$(IniStringMAXLEN, 0)
    
  'einfacher Wert
  nLen = GetPrivateProfileStringW(StrPtr(folder_ActSection), StrPtr(folder_actEntry), StrPtr(EMPTY_STRING), StrPtr(strValue), IniStringMAXLEN, StrPtr(strIniFullPath))

  If nLen >= 0 Then
    vntResult = Left$(strValue, nLen)
    If vntResult = EMPTY_STRING Then
      vntResult = Empty
    End If
  End If
    

End Sub

Private Sub Ini_Write(strIniFullPath As String, Name As String, ByRef vntValue As Variant)
  Dim bEmpty As Boolean
  Dim i As Long
  Dim folder_FullPath As String, folder_ActSection As String, folder_actEntry As String
  If strIniFullPath = "" Or Name = "" Then
    Err.Raise ERR_NOTOK
  End If
  folder_FullPath = strIniFullPath
  
  i = InStr(1, Name, ".")
  If i > 0 Then
    folder_ActSection = Left$(Name, i - 1)
    folder_actEntry = Replace$(Mid$(Name, i + 1), ".", "_")
  Else
    folder_ActSection = Name
  End If
  
  
  If IsObject(vntValue) Then
    If vntValue Is Nothing Then
      bEmpty = True
    End If
  End If
  If bEmpty Then
    Ini_WriteProperty folder_FullPath, folder_ActSection, folder_actEntry, "", ""
  Else
    Ini_WriteProperty folder_FullPath, folder_ActSection, folder_actEntry, "", vntValue
  End If
End Sub


Private Sub Ini_WriteProperty(ByVal folder_FullPath As String, ByVal folder_ActSection As String, ByVal folder_actEntry As String, ByVal Name As String, vntValue As Variant)
  Dim strEntryName As String
  Dim i As Long
  Dim strValue As String
  
  If folder_actEntry = "" Then
    strEntryName = Name
  ElseIf Name = "" Then
    strEntryName = folder_actEntry
  Else
    strEntryName = folder_actEntry & "_" & Name
  End If
  'If Not folder.UnicodeChecked Then
  '  DetectWriteUnicode folder
  'End If
  
  'einfacher Wert
  strValue = CStr(vntValue)
  i = WritePrivateProfileStringW(StrPtr(folder_ActSection), StrPtr(strEntryName), StrPtr(strValue), StrPtr(folder_FullPath))
  If i = 0 Then
    RaiseWinError Err.LastDllError, folder_FullPath
  End If
  
    
End Sub


Public Property Get AddinPath() As String
  AddinPath = ThisWorkbook.Path
  If Right$(AddinPath, 1) <> "\" Then
    AddinPath = AddinPath & "\" 'Pfad normalisieren
  End If
End Property




Private Function FileExists(ByVal szFileName As String) As Boolean
  Dim nAttr As Long

  nAttr = GetFileAttributesW(StrPtr(szFileName))

  If nAttr <> -1 Then
    FileExists = ((nAttr And vbDirectory) = 0) 'Verzeichnisse nicht zulassen
  End If
End Function




'IDL End
'---------------------------
Attribute VB_Name = "ObjHelper"
Option Explicit
Option Private Module

'Declares aus win32.tlb
Public Type tagGUID
  dw0 As Long
  dw1 As Long
  dw2 As Long
  dw3 As Long
End Type

#If Win64 Then

Public Type MULTI_QI_VB
  pIID As LongPtr  'IID*
  pItf As LongPtr 'IUnknown *
  hr As Long 'HRESULT
End Type

Public Type COSERVERINFO_VB
  dwReserved1 As Long
  pwszName As LongPtr 'LPWSTR
  pAuthInfo As LongPtr 'COAUTHINFO *
  dwReserved2 As Long
End Type

#Else

Private Type MULTI_QI_VB
  pIID As Long  'IID*
  pItf As Long 'IUnknown *
  hr As Long 'HRESULT
End Type

Private Type COSERVERINFO_VB
  dwReserved1 As Long
  pwszName As Long 'LPWSTR
  pAuthInfo As Long 'COAUTHINFO *
  dwReserved2 As Long
End Type

#End If

Const PAGE_READWRITE = 4
Const PAGE_EXECUTE_WRITECOPY = &H80
Const PAGE_EXECUTE_READWRITE = &H40
Private Const LOAD_WITH_ALTERED_SEARCH_PATH = 8
Public Const CLSCTX_INPROC_SERVER = &H1
Public Const CLSCTX_LOCAL_SERVER = &H4
Public Const CLSCTX_REMOTE_SERVER = &H10

Public Const ERR_USER_CANCEL = &H800704C7 'HRESULT_FROM_WIN32(ERROR_CANCELLED)
Public Const ERR_NOTOK = vbObjectError + 440 'Fehlerkonstante f|fffd|r bOK = false (R|fffd|ckgabewert) / allgemeiner Fehler: Automationsfehler, falls kein Fehlertext |fffd|bergeben
Public Const ERR_INVALIDARG = &H800A0005
Public Const E_NOTIMPL = &H80004001

Public Const LCID_ENGLISH As Long = &H409

Public Const sizeof_VARIANT = 16
Public Const sizeof_Short = 2
Public Const sizeof_Long = 4

Public Const sizeof_LongPtr = 8
Public Const sizeof_LongLong = 8



#If Win64 Then


#If False Then
'momentan nicht verwendet
'zwischengespeicherte Verbinder
Public Const PTRSTUBS_MAX_COUNT = 5
Public Const PTRSTUBS_COUNT_VARIABLE = 5 'Konstante f|fffd|r variablen STub (>= 5 Parameter)
Public PtrStubs(1 To PTRSTUBS_MAX_COUNT) As LongPtr
Private PtrStubsBuffer() As Byte 'Datenpuffer f|fffd|r PtrStubs

Public Declare PtrSafe Function PtrStubV Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As LongPtr, ByVal pArgs As LongPtr, ByVal argSize As LongPtr, ByVal pStub As LongPtr) As LongPtr
Public Declare PtrSafe Function PtrStubVAsLong Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As LongPtr, ByVal pArgs As LongPtr, ByVal argSize As LongPtr, ByVal pStub As LongPtr) As Long

Public DelegateStubImpl As DelegateStub
Public DelegateStub As DelegateStub

#End If

'generischer Stub f|fffd|r Win 64
'Funktionspointer als letzer Parameter (Verwendung als benannter Parameter)

'f|fffd|r 0 bis 3 Parameter (alle Parameter in Register rcx, rdx, r8 und r9)
Public Declare PtrSafe Function PtrStub3 Lib "oleaut32" Alias "DllUnregisterServer" (Optional ByVal p0 As LongPtr, Optional ByVal p1 As LongPtr, Optional ByVal p2 As LongPtr, Optional ByVal pFct As LongPtr) As LongPtr
Public Declare PtrSafe Function PtrStub3AsLong Lib "oleaut32" Alias "DllUnregisterServer" (Optional ByVal p0 As LongPtr, Optional ByVal p1 As LongPtr, Optional ByVal p2 As LongPtr, Optional ByVal pFct As LongPtr) As Long

'f|fffd|r 4 bis 8 Parameter
Public Declare PtrSafe Function PtrStub8 Lib "oleaut32" Alias "DllRegisterServer" (Optional ByVal p0 As LongPtr, Optional ByVal p1 As LongPtr, Optional ByVal p2 As LongPtr, Optional ByVal p3 As LongPtr, Optional ByVal p4 As LongPtr, Optional ByVal p5 As LongPtr, Optional ByVal p6 As LongPtr, Optional ByVal p7 As LongPtr, Optional ByVal pFct As LongPtr) As LongPtr
Public Declare PtrSafe Function PtrStub8AsLong Lib "oleaut32" Alias "DllRegisterServer" (Optional ByVal p0 As LongPtr, Optional ByVal p1 As LongPtr, Optional ByVal p2 As LongPtr, Optional ByVal p3 As LongPtr, Optional ByVal p4 As LongPtr, Optional ByVal p5 As LongPtr, Optional ByVal p6 As LongPtr, Optional ByVal p7 As LongPtr, Optional ByVal pFct As LongPtr) As Long


Public Declare PtrSafe Function VirtualAlloc Lib "Kernel32" (ByVal lpAddress As LongPtr, ByVal dwSize As LongPtr, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr


#End If



#If Win64 Then
Public Const sizeof_Ptr = 8

Public Declare PtrSafe Sub CopyMemory Lib "Kernel32" Alias "RtlMoveMemory" (ByVal pvDest As LongPtr, ByVal pvSrc As LongPtr, ByVal cbCopy As LongLong)
Public Declare PtrSafe Sub ZeroMemory Lib "Kernel32" Alias "RtlZeroMemory" (ByVal pvDest As LongPtr, ByVal cbCopy As LongLong)

Public Declare PtrSafe Function GetModuleHandle Lib "Kernel32" Alias "GetModuleHandleA" (ByVal lpModuleName As String) As LongPtr
Public Declare PtrSafe Function GetProcAddress Lib "Kernel32" (ByVal hModule As LongPtr, ByVal lpProcName As String) As LongPtr
Private Declare PtrSafe Function VirtualProtect Lib "Kernel32" (ByVal lpAddress As LongPtr, ByVal dwSize As LongLong, ByVal flNewProtect As Long, ByRef lpflOldProtect As Long) As Long
Public Declare PtrSafe Function LoadLibraryA Lib "Kernel32" (ByVal strPath As String) As LongPtr
Public Declare PtrSafe Function LoadLibraryW Lib "Kernel32" (ByVal strPath As LongPtr) As LongPtr
Public Declare PtrSafe Function FreeLibrary Lib "Kernel32" (ByVal hInst As LongPtr) As Integer

Private Declare PtrSafe Function FormatMessageW Lib "Kernel32" (ByVal dwFlags As Long, ByVal lpSource As LongPtr, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As LongPtr, ByVal nSize As Long, ByVal Arguments As LongPtr) As Long

Public Declare PtrSafe Function IIDFromString Lib "ole32" (ByVal lpsz As LongPtr, ByRef lpiid As tagGUID) As Long
Public Declare PtrSafe Function CLSIDFromString Lib "ole32" (ByVal lpsz As LongPtr, ByRef pclsid As tagGUID) As Long


Public Declare PtrSafe Function CoCreateInstanceExVB Lib "ole32" Alias "CoCreateInstanceEx" (ByRef clsid As tagGUID, ByVal punkOuter As IUnknown, ByVal dwClsCtx As Long, ByVal pServerInfo As LongPtr, ByVal dwCount As Long, ByVal pResults As LongPtr) As Long





#Else

'Win32

Public Const sizeof_Ptr = 4


Public Declare Sub CopyMemory Lib "Kernel32" Alias "RtlMoveMemory" (ByVal pvDest As Long, ByVal pvSrc As Long, ByVal cbCopy As Long)
Public Declare Sub ZeroMemory Lib "Kernel32" Alias "RtlZeroMemory" (ByVal pvDest As Long, ByVal cbCopy As Long)

Public Declare Function GetModuleHandle Lib "Kernel32" Alias "GetModuleHandleA" (ByVal lpModuleName As String) As Long
Public Declare Function GetModuleHandleW Lib "Kernel32" (ByVal lpModuleName As Long) As Long
Public Declare Function GetProcAddress Lib "Kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
Public Declare Function LoadLibraryA Lib "Kernel32" (ByVal strPath As String) As Long
Public Declare Function LoadLibraryW Lib "Kernel32" (ByVal strPath As Long) As Long

Private Declare Function LoadLibraryExA Lib "Kernel32" (ByVal strPath As String, ByVal hFile As Long, ByVal dwFlags As Long) As Long
Public Declare Function FreeLibrary Lib "Kernel32" (ByVal hInst As Long) As Integer

Public Declare Function VirtualProtect Lib "Kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal flNewProtect As Long, ByRef lpflOldProtect As Long) As Long
Public Declare Function VirtualAlloc Lib "Kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long
Public Declare Function VirtualFree Lib "Kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal dwFreeType As Long) As Long


Private Declare Function FormatMessageA Lib "Kernel32" (ByVal dwFlags As Long, ByVal lpSource As Long, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, ByVal Arguments As Long) As Long
Private Declare Function FormatMessageW Lib "Kernel32" (ByVal dwFlags As Long, ByVal lpSource As Long, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As Long, ByVal nSize As Long, ByVal Arguments As Long) As Long

Public Declare Function CoCreateInstance Lib "ole32" (ByRef rclsid As tagGUID, ByVal punkOuter As IUnknown, ByVal dwClsContext As Long, ByRef riid As tagGUID, ByVal ppv As Long) As Long
Public Declare Function CoLoadLibrary Lib "ole32" (ByVal lpszLibName As Long, ByVal bAutoFree As Boolean) As Long
Public Declare Function IIDFromString Lib "ole32" (ByVal lpsz As Long, ByRef lpiid As tagGUID) As Long
Public Declare Function CLSIDFromString Lib "ole32" (ByVal lpsz As Long, ByRef pclsid As tagGUID) As Long


'generische Vorlagen f|fffd|r stdcall Funktionen
Public Declare Function PtrFct0 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long) As Long
Public Declare Function PtrFct1 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long) As Long
Public Declare Function PtrFct2 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long) As Long
Public Declare Function PtrFct3 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long, ByVal p2 As Long) As Long
Public Declare Function PtrFct4 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long, ByVal p2 As Long, ByVal p3 As Long) As Long
Public Declare Function PtrFct5 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long, ByVal p2 As Long, ByVal p3 As Long, ByVal p4 As Long) As Long
Public Declare Function PtrFct6 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long, ByVal p2 As Long, ByVal p3 As Long, ByVal p4 As Long, ByVal p5 As Long) As Long
Public Declare Function PtrFct7 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long, ByVal p2 As Long, ByVal p3 As Long, ByVal p4 As Long, ByVal p5 As Long, ByVal p6 As Long) As Long
Public Declare Function PtrFct8 Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal p0 As Long, ByVal p1 As Long, ByVal p2 As Long, ByVal p3 As Long, ByVal p4 As Long, ByVal p5 As Long, ByVal p6 As Long, ByVal p7 As Long) As Long


Public Declare Function DllGetClassObjectPtr Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByRef rclsid As tagGUID, ByRef riid As tagGUID, ByVal ppv As Long) As Long
Private Declare Function IClassFactory_CreateInstancePtr Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ByVal This As Long, ByVal punkOuter As IUnknown, ByRef riid As tagGUID, ByVal ppvObject As Long) As Long

Private Declare Function CoCreateInstanceExVB Lib "ole32" Alias "CoCreateInstanceEx" (ByRef clsid As tagGUID, ByVal punkOuter As IUnknown, ByVal dwClsCtx As Long, ByVal pServerInfo As Long, ByVal dwCount As Long, ByVal pResults As Long) As Long

Private Declare Function GetVersion Lib "Kernel32" () As Long

#End If

#If Win64 = 1 Then

Public Declare PtrSafe Function ArrayPtr Lib "vbe7" Alias "VarPtr" (ByRef ar() As Any) As LongPtr

'zuerst nach VBA7 fragen, da unter Office 2013 VBA6 und VBA7 gesetzt ist
#ElseIf VBA7 Then
Public Declare Function ArrayPtr Lib "vbe7" Alias "VarPtr" (ByRef ar() As Any) As Long
#ElseIf VBA6 Then
Public Declare Function ArrayPtr Lib "vbe6" Alias "VarPtr" (ByRef ar() As Any) As Long
#Else
Public Declare Function ArrayPtr Lib "vba332" Alias "VarPtr" (ByRef ar() As Any) As Long
#End If


#If VBA6 = 0 Then
'CallType Enum existiert nicht unter VBA5
Public Const VbMethod = 1
Public Const VbGet = 2
Public Const VbLet = 4
Public Const VbSet = 8
#End If

'f|fffd|r CallByID
'Or Verkn|fffd|pfung mit CallType
'keine Enum wegen VBA5
Public Const CallTypeEx_Exception = 0 'Ausnahme wird ausgeworfen
Public Const CallTypeEx_IgnoreError = &H100 'Fehler wird ignoriert (R|fffd|ckgabewert Empty, falls Fehler)
Public Const CallTypeEx_ReturnError = &H200 'Fehler wird als Konstante vom Typ Error zur|fffd|ckgeliefert


'pr|fffd|ft, ob Array nicht zugewiesen
'Benutzung: Array_IsNothing(ArrayPtr(<ar>))
#If Win64 Then
Public Function Array_IsNothing(ByVal ppSafeArray As LongPtr) As Boolean
  Dim pTemp As LongPtr
#Else
Public Function Array_IsNothing(ByVal ppSafeArray As Long) As Boolean
  Dim pTemp As Long
#End If
  CopyMemory VarPtr(pTemp), ppSafeArray, 4
  If pTemp = 0 Then
    'noch nicht dimensioniert
    Array_IsNothing = True
  End If
End Function

'generischen Verbinder f|fffd|r Funktionspointer initialisieren (Prozessweit)
''Template f|fffd|r Anlegen eines neuen Funktionspointer typedef
'Win32:
'Private Declare Function XXXXXPtr Lib "oleaut32" Alias "DllUnregisterServer" (ByVal pFct As Long, ....) As Long

'Win64: siehe PtrStubXXX

Public Sub InitFctPtrStub()
  Dim b As Byte
  Dim l As Long
#If Win64 Then
  Dim pCodeStart As LongPtr, pCode As LongPtr
  Const CodeSize As Long = 3
  Const CodeSizeSub8 As Long = 7
  
#Else
  Dim pCodeStart As Long, pCode As Long
  Const CodeSize As Long = 5
#End If
  Dim nOldProtect As Long
  
  'Hier die Adresse der DummyFunction (DllUnregisterServer) ermitteln
  pCodeStart = GetModuleHandle("oleaut32")
  If pCodeStart = 0 Then RaiseWinError Err.LastDllError, "oleaut32"
  pCodeStart = GetProcAddress(pCodeStart, "DllUnregisterServer")

  If pCodeStart = 0 Then RaiseWinError Err.LastDllError, "oleaut32.DllUnregisterServer"
  
  'Schutz aufheben
  If VirtualProtect(pCodeStart, CodeSize, PAGE_READWRITE, nOldProtect) = 0 Then
    RaiseWinError Err.LastDllError, "VirtualProtect"
  End If
  
  pCode = pCodeStart
  
#If Win64 Then
  b = &H41 'jmp r9
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1

  b = &HFF
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1

  b = &HE1
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
#Else
  
    
  b = &H59 'pop ecx 'R|fffd|cksprungaddresse holen
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
  
  b = &H58 'pop eax  'Funktionspointer holen
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
    
  b = &H51 'push ecx  R|fffd|cksprungsaddresse zur|fffd|ckschreiben
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
  
  'Funktionspointer ausf|fffd|hren
  b = &HFF 'jmp eax
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
  b = &HE0
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
  
#End If

  
  Debug.Assert pCode - pCodeStart <= CodeSize
  'alten Schutz wiederherstellen
  VirtualProtect pCodeStart, CodeSize, nOldProtect, 0

#If Win64 Then
#If False Then 'momentan nicht implementiert
  Dim nArgCount As Long
  Const CodeSizeSubStubs As Long = 200
  

  'bei Win64 sind dynamische Stubs erforderlich
  ReDim PtrStubsBuffer(CodeSizeSubStubs - 1)
  pCodeStart = VarPtr(PtrStubsBuffer(0))
  
    'Schutz aufheben
  If VirtualProtect(pCodeStart, CodeSizeSubStubs, PAGE_EXECUTE_READWRITE, nOldProtect) = 0 Then
    RaiseWinError Err.LastDllError, "VirtualProtect"
  End If

  pCode = pCodeStart
  For nArgCount = 1 To PTRSTUBS_MAX_COUNT
    createStubImpl pCode, nArgCount
  Next nArgCount
  
  Debug.Assert pCode - pCodeStart <= CodeSizeSubStubs
#End If



  'variablen Stub bis 8 Parameter f|fffd|r Win64 einrichten

  'Hier die Adresse der DummyFunction (DllRegisterServer) ermitteln
  pCodeStart = GetModuleHandle("oleaut32")
  If pCodeStart = 0 Then RaiseWinError Err.LastDllError, "oleaut32"
  pCodeStart = GetProcAddress(pCodeStart, "DllRegisterServer")

  If pCodeStart = 0 Then RaiseWinError Err.LastDllError, "oleaut32.DllRegisterServer"
  
  'Schutz aufheben
  If VirtualProtect(pCodeStart, CodeSizeSub8, PAGE_READWRITE, nOldProtect) = 0 Then
    RaiseWinError Err.LastDllError, "VirtualProtect"
  End If
  
  pCode = pCodeStart
  
  
  
  l = &H24448B48 '48 8B 44 24      mov         rax,qword ptr [rsp+9 * sizeof_LongPtr]
  CopyMemory pCode, VarPtr(l), sizeof_Long
  pCode = pCode + sizeof_Long
  b = 9 * sizeof_LongPtr 'Funktionspointer adressieren
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
  
  l = &HE0FF 'FF E0                jmp         rax
  CopyMemory pCode, VarPtr(l), 2
  pCode = pCode + 2
  


  Debug.Assert pCode - pCodeStart <= CodeSizeSub8
  'alten Schutz wiederherstellen
  VirtualProtect pCodeStart, CodeSize, nOldProtect, 0




#End If

End Sub

'#If Win64 Then
#If False Then 'momentan nicht implementiert

Private Sub createStubImpl(ByRef pCodeStart As LongPtr, ByVal argCount As Long)
  Dim pCode As LongPtr
  Dim b As Byte
  Dim l As Long
  
  pCode = pCodeStart

  If argCount > 4 Then
    'dynamische Stackgenerierung
    '48 81 EC F0 02 00 00 sub         rsp,2F0h
    'im Moment nicht implementiert

  Else
    '48 83 EC 50          sub         rsp,50h
    
    '49 8B 48 10          mov         rcx,qword ptr [r8+10h]
    '48 8B 4F 08          mov         rcx,qword ptr [rdi+8]

    '48 8B 4D E8          mov         rcx,qword ptr [rbp-18h]
    '48 8B 01             mov         rax,qword ptr [rcx]
    '48 8B 4B 08          mov         rcx,qword ptr [rbx+8]
    '49 8B 00             mov         rax,qword ptr [r8]
    '49 8B C8             mov         rcx,r8
    '48 8B 41 20          mov         rax,qword ptr [rcx+20h]
    '48 8B 09             mov         rcx,qword ptr [rcx]
    '4C 8B 49 18          mov         r9,qword ptr [rcx+18h]
    '4C 8B 41 10          mov         r8,qword ptr [rcx+10h]
  
    
    
    '48 83 EC 50          sub         rsp,argCount * sizeof_LongPtr
    l = &HEC8348
    CopyMemory pCode, VarPtr(l), 3
    b = argCount * sizeof_LongPtr
    pCode = pCode + 3
    CopyMemory pCode, VarPtr(b), 1
    pCode = pCode + 1
    
    
    '49 8B C8             mov         rcx,r8
    l = &HC88B49
    CopyMemory pCode, VarPtr(l), 3
    pCode = pCode + 3
    
    
    '4C 8B 49 18          mov         r9,qword ptr [rcx+3 * sizeof_LongPtr]
    l = &H498B4C
    CopyMemory pCode, VarPtr(l), 3
    pCode = pCode + 3
    b = 3 * sizeof_LongPtr
    CopyMemory pCode, VarPtr(b), 1
    pCode = pCode + 1
    

    '4C 8B 41 10          mov         r8,qword ptr [rcx+2 * sizeof_LongPtr]
    l = &H418B4C
    CopyMemory pCode, VarPtr(l), 3
    pCode = pCode + 3
    b = 2 * sizeof_LongPtr
    CopyMemory pCode, VarPtr(b), 1
    pCode = pCode + 1

        
'    'mov rax,qword ptr [rcx+ 1 * 8]
'
'
'    '48 8B 41 20          mov         rax,qword ptr [rcx+ 1* sizeof_LongPtr]
'    l = &H418B48
'    CopyMemory pCode, VarPtr(l), 3
'    pCode = pCode + 3
'    b = 1 * sizeof_LongPtr
'    CopyMemory pCode, VarPtr(b), 1
'    pCode = pCode + 1
    
    'Funktionspointer sichern
    '48 8B C2             mov         rax,rdx
    l = &HC28B48
    CopyMemory pCode, VarPtr(l), 3
    pCode = pCode + 3

    
    'TODO: Adressierungsart
    '48 8B 91 60 08 00 00 mov         rdx,qword ptr [rcx+1* sizeof_LongPtr]
    l = &H918B48
    CopyMemory pCode, VarPtr(l), 3
    pCode = pCode + 3
    l = 1 * sizeof_LongPtr
    CopyMemory pCode, VarPtr(l), sizeof_Long
    pCode = pCode + sizeof_Long
    
    
    '48 8B 09             mov         rcx,qword ptr [rcx]
    l = &H98B48
    CopyMemory pCode, VarPtr(l), 3
    pCode = pCode + 3
    
    'Aufruf ausf|fffd|hren
    'FF D0                call        rax
    l = &HD0FF
    CopyMemory pCode, VarPtr(l), 2
    pCode = pCode + 2
    
    If argCount >= 16 Then
      '48 81 C4 80 00 00 00 add         rsp,argCount * sizeof_LongPtr
      l = &HC48148
      CopyMemory pCode, VarPtr(l), 3
      pCode = pCode + 3
      l = argCount * sizeof_LongPtr
      CopyMemory pCode, VarPtr(l), sizeof_Long
      pCode = pCode + sizeof_Long
    Else
 
      '48 83 C4 40          add         rsp,argCount * sizeof_LongPtr
      l = &HC48348
      CopyMemory pCode, VarPtr(l), 3
      pCode = pCode + 3
      b = argCount * sizeof_LongPtr
      CopyMemory pCode, VarPtr(b), 1
      pCode = pCode + 1
      
    End If
    

  End If
  
  'C3                   ret
  b = &HC3
  CopyMemory pCode, VarPtr(b), 1
  pCode = pCode + 1
    
    
  PtrStubs(argCount) = pCodeStart
  
  pCodeStart = pCode

End Sub


#End If



#If Win64 Then
Public Function DllGetClassObjectPtr(ByVal pFct As LongPtr, ByRef rclsid As tagGUID, ByRef riid As tagGUID, ByVal ppv As LongPtr) As Long
  DllGetClassObjectPtr = PtrStub3AsLong(VarPtr(rclsid), VarPtr(riid), ppv, pFct:=pFct)
End Function

#End If



'Anpassung zu VBA.CVErr
'akzeptiert direkt HRESULTs ohne interne Konvertierung (VB Fehler Nummern werden automatisch 800A0000 verkn|fffd|pft / Verhalten von VBA.CVErr)
Public Function CVErrEx(ByVal hr As Long) As Variant
#If Win64 Then
  Dim pTemp As LongPtr
#Else
  Dim pTemp As Long
#End If
  Dim vt As Integer
  'HRESULT direkt kopieren (CVErr vertr|fffd|gt nur konvertierte Fehler)
  If (hr And &HFFFF0000) = 0 Then
    hr = hr Or &H800A0000 'Standard VB Fehler
  End If
  pTemp = VarPtr(CVErrEx)
  vt = vbError
  CopyMemory pTemp, VarPtr(vt), 2
  CopyMemory pTemp + 8, VarPtr(hr), 4
End Function


Public Sub RaiseWinError(ByVal nError As Long, Optional ByVal addMessage As String)
  Dim nTemp As Integer
  Dim hr As Long
  Dim strDescription As String
  If nError <> 0 Then
    hr = nError
    'Testen, ob Win32 Fehler
    CopyMemory VarPtr(nTemp), VarPtr(nError) + sizeof_Short, sizeof_Short
    If nTemp = 0 Or nTemp = &H8007 Then
      'entspricht HRESULT_FROM_WIN32 Makro
      nTemp = &H8007
      CopyMemory VarPtr(hr) + sizeof_Short, VarPtr(nTemp), sizeof_Short
      
      nTemp = 0
      CopyMemory VarPtr(nError) + sizeof_Short, VarPtr(nTemp), sizeof_Short
    End If
    
    strDescription = WinErrorText(nError)
    If addMessage <> "" Then
      If strDescription = "" Then
        strDescription = addMessage
      Else
        strDescription = strDescription & vbLf & addMessage
      End If
    End If
    Err.Raise hr, , strDescription
  End If
End Sub

Public Property Get WinErrorText(ByVal nError As Long) As String
  Dim s As String, dwLen As Long
  Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
  Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
  Const nLen = 256
  s = Space$(nLen)

#If Win64 = 0 Then
  If isWin32Unicode Then
#End If
    dwLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS, 0, nError, 0, StrPtr(s), nLen, 0)
#If Win64 = 0 Then
  Else
    dwLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS, 0, nError, 0, s, nLen, 0)
  End If
#End If

  If dwLen > 0 Then
    WinErrorText = Left$(s, dwLen)
  End If
End Property

'true,wenn Unicode API verf|fffd|gar (NT-Linie)
Public Property Get isWin32Unicode() As Boolean
#If Win64 Then
  isWin32Unicode = True
#Else
  isWin32Unicode = (GetVersion() >= 0)
#End If
End Property


'gegeben: geladene Basic-Dll/Com-Dll,  nun aus Typelib der Dll die Klasseninfo heraussuchen und Instanz der Klasse erstellen
'wird gebraucht, um auf Dlls ohne Registrierung zuzugreifen (Client-Server F|fffd|higkeit bei Connector)
'hModule m|fffd|glichst via CoLoadLibrary erstellen, um Lebensdauer-Problematik korrekt zu handlen
#If Win64 Then
Public Function CreateInprocObjectByClsid(ByVal hModule As LongPtr, ByRef clsid As tagGUID) As Object
#Else
Public Function CreateInprocObjectByClsid(ByVal hModule As Long, ByRef clsid As tagGUID) As Object
#End If
    Const IClassFactory_CreateInstance_VTBLINDEX = 3
    Dim oCF As IUnknown
    Dim hr As Long
#If Win64 Then
    Dim pTemp As LongPtr, oOrig As LongPtr, ptrDllGetClassObject As LongPtr
#Else
    Dim pTemp As Long, oOrig As Long, ptrDllGetClassObject As Long
#End If
    Dim IID_IDispatch As tagGUID
    Dim IID_IClassFactory As tagGUID
    
    Dim strTemp As String
    strTemp = "{00020400-0000-0000-C000-000000000046}"
    IIDFromString StrPtr(strTemp), IID_IDispatch
    strTemp = "{00000001-0000-0000-C000-000000000046}"
    IIDFromString StrPtr(strTemp), IID_IClassFactory
    
    ptrDllGetClassObject = GetProcAddress(hModule, "DllGetClassObject")
    If ptrDllGetClassObject = 0 Then RaiseWinError Err.LastDllError, "DllGetClassObject"
    hr = DllGetClassObjectPtr(ptrDllGetClassObject, clsid, IID_IClassFactory, VarPtr(oCF))
    If hr < 0 Then Err.Raise hr
    
    oOrig = ObjPtr(oCF)
    If oOrig = 0 Then Err.Raise 5 'Invalid Arg
    
    CopyMemory VarPtr(pTemp), oOrig, sizeof_Ptr 'VTBL-Pointer
    CopyMemory VarPtr(pTemp), pTemp + IClassFactory_CreateInstance_VTBLINDEX * sizeof_Ptr, sizeof_Ptr  'GetIDsOfNames holen
    
#If Win64 Then
    'TODO
    Stop
#Else
    hr = IClassFactory_CreateInstancePtr(pTemp, oOrig, Nothing, IID_IDispatch, VarPtr(CreateInprocObjectByClsid))
#End If

    If hr < 0 Then Err.Raise hr

End Function



'analog VBA.CreateObject, statt Progid jedoch Angabe von CLSID in Stringform: Vorteil, Objekt braucht auf Client nicht registriert zu sein (Progid m|fffd|sste sonst auf Client registriert sein)
Public Function CreateObjectClsid(ByVal strCLSID As String, Optional ByVal ServerName As String) As Object
  Dim o As Object
  Dim clsid As tagGUID
  Dim IID_IDispatch As tagGUID
  Dim multiQI As MULTI_QI_VB
  Dim hr As Long
  Dim ServerInfo As COSERVERINFO_VB
#If Win64 Then
  Dim pServerInfo As LongPtr
#Else
  Dim pServerInfo As Long
#End If
  Dim strTemp As String
  
  hr = CLSIDFromString(StrPtr(strCLSID), clsid)
  If hr < 0 Then Err.Raise hr
  
  strTemp = "{00020400-0000-0000-C000-000000000046}"
  hr = IIDFromString(StrPtr(strTemp), IID_IDispatch)
  If hr < 0 Then Err.Raise hr
  
  multiQI.pIID = VarPtr(IID_IDispatch)
  If ServerName <> "" Then
    ServerInfo.pwszName = StrPtr(ServerName)
    pServerInfo = VarPtr(ServerInfo)
  End If
  
  hr = CoCreateInstanceExVB(clsid, Nothing, CLSCTX_LOCAL_SERVER Or CLSCTX_REMOTE_SERVER, pServerInfo, 1, VarPtr(multiQI))
  If hr < 0 Then Err.Raise hr
  
  CopyMemory VarPtr(o), VarPtr(multiQI.pItf), sizeof_Ptr
  Debug.Assert Not o Is Nothing
  
  Set CreateObjectClsid = o
End Function




Attribute VB_Name = "Plugin"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


#Const DOTNETBUILD = 1



Private WithEvents Workbook As Excel.Workbook
Attribute Workbook.VB_VarHelpID = -1
Public LogList As Object 'MSForms.ListBox oder Signaturkompatibel
Public LogActRange As Range
Private m_nLogIndentLevel As Long
 Public StatusText As String
 Private m_nProgressMax As Long
 Private m_nProgressPosition As Long
 Public OffsetNext As Long
Private m_oActiveEditor As CSaldenEditor
Private m_CommandBars As CommandBars
Public MenuEnabled As Boolean
Private m_CommandBar As CommandBar
Private Type xlOper
  Data(0 To 7) As Byte
  xltype As Integer
End Type

#If Win64 Then
Private Declare PtrSafe Function GetActiveWindow Lib "User32" () As LongPtr
Private Declare PtrSafe Function SetFocus Lib "User32" (ByVal HWND As LongPtr) As LongPtr
#Else
Private Declare Function GetActiveWindow Lib "User32" () As Long
Private Declare Function SetFocus Lib "User32" (ByVal HWND As Long) As Long
#End If

Private Sub AssignProgressPositionInternal(ByVal nPosInternal As Long)
  Dim strTemp As String
  If nPosInternal > m_nProgressMax Then
    nPosInternal = m_nProgressMax
  End If
  If m_nProgressPosition <> nPosInternal Then
    m_nProgressPosition = nPosInternal
    If m_nProgressMax > 0 Then
      strTemp = Int(CDbl(nPosInternal) / CDbl(m_nProgressMax) * 100 + 0.5) & " %"
    End If
    If StatusText <> "" Then
      strTemp = strTemp & " : " & StatusText
    End If
    Application.StatusBar = strTemp
  End If
End Sub

Public Sub InitAsPlugin(ByVal wb As Workbook)
  Set Workbook = wb
  Set Common.ThisPlugin = Me

#If DOTNETBUILD = 0 Then
  Set Common.ThisWorkbook = wb
#End If
  Decentral_Command_Entry
    CalculateImpl wb
End Sub




'neu Berechnen, der Formeln
Private Sub CalculateImpl(ByVal wb As Workbook)
  Dim oApplication As Object
  Dim bDefault As Boolean
  
  bDefault = True

  If ExcelVersionInt >= 12 Then
    Set oApplication = Application

    oApplication.CalculateFullRebuild
    bDefault = False
  End If
    
  If bDefault Then
    Application.Calculate
  End If

End Sub



Public Function CreateFrame(Optional ByVal OwnerForm As Object, Optional ByVal Left As Long = -1, Optional ByVal Top As Long = -1, Optional ByVal Width As Long = -1, Optional ByVal Height As Long = -1, Optional ByVal style As Long, Optional ByVal ExStyle As Long, Optional ByVal Align As Integer) As Object
#If DOTNETBUILD = 1 Then
  Dim oFrame As Object
  Set oFrame = IntApplication.CreateFrame(OwnerForm:=OwnerForm, Left:=Left, Top:=Top, Width:=Width, Height:=Height, style:=style, ExStyle:=ExStyle, Align:=Align)
  Set CreateFrame = oFrame
#Else
  Err.Raise E_NOTIMPL
#End If
End Function



Public Sub ProgressNext()
  ProgressPosition = m_nProgressPosition + 1
End Sub



Public Property Let ProgressPosition(ByVal nPos As Long)
  AssignProgressPositionInternal nPos
End Property

Public Sub CloseProgress()
  Application.StatusBar = False
  m_nProgressMax = 0
End Sub

Public Sub OpenProgress(ByVal nProgressMax As Long)
  Dim nNextPositionInternal As Long
  If nProgressMax <= 0 Then Err.Raise ERR_INVALIDARG
  m_nProgressMax = nProgressMax
  m_nProgressPosition = -1
  AssignProgressPositionInternal 0
  OffsetNext = 1
End Sub

Public Property Get Log() As Object
  Set Log = Me
End Property

Public Property Get StatusBar() As Object
  Set StatusBar = Me
End Property

Public Sub LogRecords__Add__AssignProperties(Optional ByVal text As String, Optional ByVal Scode As Long)
  Dim r As Range
  Dim oSaldenEditor As CSaldenEditor
  If Not LogActRange Is Nothing Then
    Set oSaldenEditor = m_oActiveEditor
    Set r = LogActRange
    r.EntireRow.Font.Size = 10
    r.NumberFormat = "@"
    r.WrapText = True
    r.Value = Space(m_nLogIndentLevel * 2) & text
    Set r = r.Offset(0, 1)
    If Scode < 0 Then
      oSaldenEditor.CreateIDLLocTextRange r, "CON", "332", "Bene1"
      r.Interior.Color = vbRed
    Else
      oSaldenEditor.CreateIDLLocTextRange r, "CON", "331", "Bene1"
      r.Interior.Color = vbGreen
    End If
    Set LogActRange = LogActRange.Offset(1, 0)
  ElseIf Not LogList Is Nothing Then
    LogList.AddItem Space(m_nLogIndentLevel * 2) & text
  End If
End Sub

Public Sub CloseSubLog()
  If m_nLogIndentLevel > 1 Then
    m_nLogIndentLevel = m_nLogIndentLevel - 1
  Else
    m_nLogIndentLevel = 0
  End If
End Sub

Public Sub OpenSubLog()
  m_nLogIndentLevel = m_nLogIndentLevel + 1
End Sub

Public Property Get Version() As Long
  Version = ACT_VERSION
End Property

Public Sub InsertNoticeSheet()
  Dim wb As Workbook
  Dim wsName As String
  Dim ws As Worksheet
  Dim bProtect As Boolean
  Dim oActiveEditor As CSaldenEditor
  On Error GoTo ErrHandler
  If m_oActiveEditor Is Nothing Then
    Set wb = ActiveWorkbook
    If wb Is Nothing Then Exit Sub
  Else
    Set oActiveEditor = m_oActiveEditor
    Set wb = oActiveEditor.Worksheet.Parent
    If wb.ProtectStructure Then
      oActiveEditor.UnprotectWB
      bProtect = True
    End If
  End If
  wsName = Trim$(InputBox(SearchTextInSPR(326)))
  If wsName <> "" Then
    If wb.Worksheets.count > 0 Then
      Set ws = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.count))
    Else
      Set ws = wb.Worksheets.Add
    End If
    ws.Name = wsName
  End If
  If bProtect Then
    oActiveEditor.ProtectWB
  End If
  Exit Sub
ErrHandler:
  If Err.Number <> ERR_USER_CANCEL Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  If Not ws Is Nothing Then
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
  End If
  If bProtect And Not oActiveEditor Is Nothing Then
    oActiveEditor.ProtectWB
  End If
End Sub

Public Sub Clear()
  If Not m_CommandBar Is Nothing Then
#If CENTRALBUILD = 0 Then
    m_CommandBar.Delete
#End If
    Set m_CommandBar = Nothing
  End If
  Set m_CommandBars = Nothing
  If Not m_oActiveEditor Is Nothing Then
    m_oActiveEditor.Clear
    Set m_oActiveEditor = Nothing
  End If
#If CENTRALBUILD Then
  Set m_collMapWorkbookToEditor = Nothing
  Set m_ExcelApplication = Nothing
On Error Resume Next
Set ConnectorDeclConvert.ExcelApplication = Nothing
Set KVD201Int.ModuleInternal = Nothing
#End If
End Sub

Public Sub Check_Details_KSTSAL()
  AdjustDetails__ExcelUI "KSTSAL"
End Sub

Public Sub Check_Details_ICKTOSAL()
  AdjustDetails__ExcelUI "ICKTOSAL"
End Sub

Public Sub Check_Details_ICBEW()
  AdjustDetails__ExcelUI "ICBEW"
End Sub

Public Sub Check_Details_KAPBEW()
  AdjustDetails__ExcelUI "KAPBEW"
End Sub

Public Sub Check_Details_RUEBEW()
  AdjustDetails__ExcelUI "RUEBEW"
End Sub

Public Sub Check_Details_ANLBEW()
  AdjustDetails__ExcelUI "ANLBEW"
End Sub

Public Sub Check_Details_KTOSAL()
  AdjustDetails__ExcelUI "KTOSAL"
End Sub

Public Sub AdjustDetails__ExcelUI(Optional ByVal strClassName As String)
  Dim oDetailEditor As CRangeGrid
  Dim strParam As String
  strParam = Application.CommandBars.ActionControl.Parameter
  If Decentral_Command_Entry(IsActive:=True) Then
    If strClassName = "" Then
      strClassName = strParam
    End If
    If strClassName = "KTOSAL" Then
      m_oActiveEditor.Check__ExcelUI
    Else
      Set oDetailEditor = m_oActiveEditor.DetailSheets_Find(strClassName)
      If Not oDetailEditor Is Nothing Then
        oDetailEditor.AdjustDetails__ExcelUI
      End If
    End If
  End If
End Sub

Public Sub AssignOnlineLanguage_MenuClick()
  Dim strParam As String
  strParam = Application.CommandBars.ActionControl.Parameter
  If Not Decentral_Command_Entry() Then Exit Sub
  AssignOnlineLanguage strParam
End Sub

Public Sub AssignOnlineLanguage(strSprache As String)
  m_oActiveEditor.AssignOnlineLanguage_Decentral strSprache
End Sub

Public Sub OnContextMenuClick()
  If Decentral_Command_Entry() Then
    m_oActiveEditor.OnContextMenuClick
  End If
End Sub

Public Sub DeleteDetailLines()
  If Decentral_Command_Entry() Then
    m_oActiveEditor.DeleteDetailLines
  End If
End Sub

Public Sub InsertDetailLines()
  If Decentral_Command_Entry() Then
    m_oActiveEditor.InsertDetailLines
  End If
End Sub

Public Property Get MenuBar() As Object
  Set MenuBar = m_CommandBar
End Property

Public Property Get ActiveEditor() As Object
#If CENTRALBUILD = 0 Then
  If m_oActiveEditor Is Nothing Then Load
#End If
  Set ActiveEditor = m_oActiveEditor
End Property

Private Sub m_CommandBars_OnUpdate()
  On Error GoTo ErrHandler
  Exit Sub
  If Not m_oActiveEditor Is Nothing Then
    m_oActiveEditor.OnUpdateUI
  End If
  Exit Sub
ErrHandler:
End Sub

Private Function LocateObjIDArray(ByVal rObjIDs As Range, ByRef rMerge As Range, ByRef vntArray As Variant)
  Dim vnt As Variant
  Dim r As Range
  Dim i As Long
  For Each vnt In vntArray
    Set r = IDLVLookup(rObjIDs, vnt, i)
    If i = 1 Then
      If rMerge Is Nothing Then
        Set rMerge = r
      Else
        Set rMerge = Union(rMerge, r)
      End If
    End If
  Next vnt
End Function

Public Function IDLEvaluate(Expression As Variant, ByRef params() As Variant) As Variant
  Dim rObjIDs As Range
  Dim rMerge As Range
  Dim r As Range
  Dim i As Long
  Dim j As Long
  Dim vnt As Variant
  If IsObject(Expression) Then
    If TypeOf Expression Is Range Then
      Set rObjIDs = Expression
    End If
  End If
  If rObjIDs Is Nothing Then
    If VarType(Expression) = vbString Then
      Set rObjIDs = m_oActiveEditor.DataRange_Find(Expression, i)
      If i = 0 Then Set rObjIDs = Nothing
    End If
  End If
  If Not rObjIDs Is Nothing Then
    For Each vnt In params
      If IsArray(vnt) Then
        LocateObjIDArray rObjIDs, rMerge, vnt
      Else
        Set r = IDLVLookup(rObjIDs, vnt)
        If Not r Is Nothing Then
          If rMerge Is Nothing Then
            Set rMerge = r
          Else
            Set rMerge = Union(rMerge, r)
          End If
        End If
      End If
    Next vnt
  End If
  If Not rMerge Is Nothing Then
    Set IDLEvaluate = rMerge
  End If
End Function

Public Function Decentral_Command_Entry(Optional IsActive As Variant) As Boolean
  Dim bIsActive As Boolean
  Dim bSystemChangeCounterSet As Boolean
  Dim wbActive As Excel.Workbook

  On Error GoTo ErrHandler
  If Not m_oActiveEditor Is Nothing Then
    If Not m_oActiveEditor.Valid Then
      m_oActiveEditor.Clear
      Set m_oActiveEditor = Nothing
    End If
  End If
  If IsMissing(IsActive) Then
        Set wbActive = ActiveWorkbook
        If Not wbActive Is Nothing Then
      bIsActive = (StrComp(wbActive.FullName, ThisWorkbook.FullName, vbTextCompare) = 0)
        End If
  Else
    bIsActive = IsActive
  End If
  If m_oActiveEditor Is Nothing And bIsActive Then
    LoadImpl
  End If
  If MenuEnabled And Not m_oActiveEditor Is Nothing Then
    If bIsActive Then
      Decentral_Command_Entry = True
    End If
    If bIsActive And m_CommandBar Is Nothing Then
      MenuBarDecentral_Create
      m_oActiveEditor.RefreshControls
      g_nSystemChangeCounter = 1
      bSystemChangeCounterSet = True
      m_oActiveEditor.OnActivationChange True
    ElseIf Not bIsActive And Not m_CommandBar Is Nothing Then
      m_oActiveEditor.MenuBarDecentral__Load m_CommandBar, bUnload:=True
      m_CommandBar.Delete
      Set m_CommandBar = Nothing
      If m_nProgressMax = 0 Then
        Application.StatusBar = False
      End If
      bSystemChangeCounterSet = True
      g_nSystemChangeCounter = 1
      m_oActiveEditor.OnActivationChange False
    End If
  End If
  If bSystemChangeCounterSet Then
    g_nSystemChangeCounter = 0
    bSystemChangeCounterSet = False
  End If
  Exit Function
ErrHandler:
  If bSystemChangeCounterSet Then
    g_nSystemChangeCounter = 0
  End If
  Err.Raise Err.Number, Err.Source, Err.Description
End Function

Private Sub MenuBarDecentral_Create()
    Dim strMenuName As String
    strMenuName = "Konsis-AddInMenu_V" & ACT_VERSION
    Set m_CommandBar = Nothing
    On Error Resume Next
    Set m_CommandBar = Application.CommandBars.Item(strMenuName)
    On Error GoTo ErrHandler
    If Not m_CommandBar Is Nothing Then
      m_CommandBar.Delete
      Set m_CommandBar = Nothing
    End If
    Set m_CommandBar = Application.CommandBars.Add(Name:=strMenuName, Position:=msoBarTop, temporary:=True)
     m_oActiveEditor.MenuBarDecentral__Load m_CommandBar, False
    m_CommandBar.Visible = True
    If Not IsOffice97 Then
      Set m_CommandBars = Application.CommandBars
    End If
    Exit Sub
ErrHandler:
End Sub

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
  On Error Resume Next
  'testweise Fokus setzen
  SetFocus GetActiveWindow
End Sub

Private Sub Workbook_SheetActivate(ByVal Sh As Object)
  Dim bSystemChangeCounterSet As Boolean
  On Error GoTo ErrHandler
  If g_nSystemChangeCounter = 0 And Not m_oActiveEditor Is Nothing And TypeOf Sh Is Worksheet Then
    g_nSystemChangeCounter = g_nSystemChangeCounter + 1
    bSystemChangeCounterSet = True
    m_oActiveEditor.OnActivationChange True, Sh
  End If
Cleanup:
 If bSystemChangeCounterSet Then
   g_nSystemChangeCounter = g_nSystemChangeCounter - 1
 End If
 Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  GoTo Cleanup
  Resume
End Sub

Private Sub Workbook_SheetDeactivate(ByVal Sh As Object)
  Dim bSystemChangeCounterSet As Boolean
  On Error GoTo ErrHandler
  If MenuEnabled And m_nProgressMax = 0 Then
    If Application.ScreenUpdating Then
      Application.StatusBar = False
    End If
  End If
  If g_nSystemChangeCounter = 0 And Not m_oActiveEditor Is Nothing And TypeOf Sh Is Worksheet Then
    g_nSystemChangeCounter = g_nSystemChangeCounter + 1
    bSystemChangeCounterSet = True
    m_oActiveEditor.OnActivationChange False, Sh
  End If
Cleanup:
 If bSystemChangeCounterSet Then
   g_nSystemChangeCounter = g_nSystemChangeCounter - 1
 End If
 Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  GoTo Cleanup
End Sub

Private Sub Workbook_Activate()
  Dim bSystemChangeCounterSet As Boolean
  On Error GoTo ErrHandler
  If MenuEnabled And Not m_oActiveEditor Is Nothing Then
     MenuBarDecentral_Create
  End If
  If Not m_oActiveEditor Is Nothing Then
    m_oActiveEditor.RefreshControls
  End If
 If g_nSystemChangeCounter > 0 Then Exit Sub
 If m_nProgressMax = 0 And Not m_oActiveEditor Is Nothing Then
   g_nSystemChangeCounter = g_nSystemChangeCounter + 1
   bSystemChangeCounterSet = True
   m_oActiveEditor.OnActivationChange True
 End If
Cleanup:
 If bSystemChangeCounterSet Then
   g_nSystemChangeCounter = g_nSystemChangeCounter - 1
 End If
 Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  GoTo Cleanup
End Sub

Private Sub Workbook_Deactivate()
  Dim bSystemChangeCounterSet As Boolean
  On Error GoTo ErrHandler
  If Not m_CommandBar Is Nothing Then
    If Not m_oActiveEditor Is Nothing Then
      m_oActiveEditor.MenuBarDecentral__Load m_CommandBar, bUnload:=True
    End If
    On Error Resume Next
    m_CommandBar.Delete
    On Error GoTo ErrHandler
    Set m_CommandBar = Nothing
  End If
  If g_nSystemChangeCounter > 0 Then Exit Sub
 If True Then
   g_nSystemChangeCounter = g_nSystemChangeCounter + 1
   bSystemChangeCounterSet = True
   If MenuEnabled And m_nProgressMax = 0 Then
     Application.StatusBar = False
   End If
   If Not m_oActiveEditor Is Nothing Then
     m_oActiveEditor.OnActivationChange False
   End If
 End If
Cleanup:
 If bSystemChangeCounterSet Then
   g_nSystemChangeCounter = g_nSystemChangeCounter - 1
 End If
 Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
  GoTo Cleanup
End Sub

Private Sub LoadImpl()
  Dim oAddinKVM100 As Excel.AddIn
  Dim oEditor As New CSaldenEditor
  Dim oConnectorApp As Object, oDecentralPlugin As Object
  Dim oTemp As Object
  Dim ws As Worksheet
  On Error Resume Next
  Clear
  For Each ws In ThisWorkbook.Worksheets
      If StrComp(ws.Name, DATASHEET_NAME, vbTextCompare) = 0 Then
        Set oTemp = ws.Range("DetailSheets")
        Exit For
      End If
  Next ws
  If oTemp Is Nothing Then
    Exit Sub
  End If
  On Error GoTo 0
  Set m_oActiveEditor = oEditor
  oEditor.Init Workbook
  MenuEnabled = True
On Error Resume Next
  Set oAddinKVM100 = AddIns("KVM100")
  Set oConnectorApp = Run("GetConnectorApplication")
  If Not oConnectorApp Is Nothing Then
    For Each oTemp In oConnectorApp.Plugins
      If oTemp.Name = "DC" Then
        Set oDecentralPlugin = oTemp.appObj
        Exit For
      End If
    Next oTemp
  End If
  If Not oDecentralPlugin Is Nothing Then
    MenuEnabled = False
    Set oTemp = Me
    oDecentralPlugin.NotifyEditWorkbookOpen oTemp
  End If
On Error GoTo 0
  If Not oAddinKVM100 Is Nothing Then
    If oAddinKVM100.Installed Then
      oAddinKVM100.Installed = False
    End If
  End If
End Sub

Public Sub Load()
  Decentral_Command_Entry
End Sub

Private Sub Workbook_SheetBeforeRightClick(ByVal Sh As Object, ByVal Target As Range, Cancel As Boolean)
  On Error GoTo ErrHandler
  If Decentral_Command_Entry() Then
    If MenuEnabled Then
      m_oActiveEditor.RefreshCellContextMenu
    End If
  End If
  Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
End Sub

Private Sub Workbook_Open()
  On Error GoTo ErrHandler
  Decentral_Command_Entry
 Exit Sub
ErrHandler:
  If Application.DisplayAlerts Then
    ShowErrDialog Err.Number, Err.Description, Err.Source
  End If
End Sub

Public Function IDLCellAttributes(ByRef Value As Variant, ParamArray attributes() As Variant) As Variant
  Dim r As Range
  Dim ar() As Variant
  Dim nSize As Long
  Dim i As Long
  Dim nSrc As Long, nDest As Long
  If IsObject(Application.Caller) And Not g_collCalculateFunctionObjects Is Nothing Then
    Set r = Application.Caller
    nSrc = LBound(attributes)
    nSize = 1 + UBound(attributes) - nSrc + 1
    ReDim ar(nSize - 1)
    For nDest = 1 To nSize - 1
      If IsObject(attributes(nSrc)) Then
        Set ar(nDest) = attributes(nSrc)
      Else
        ar(nDest) = attributes(nSrc)
      End If
      nSrc = nSrc + 1
    Next nDest
    Set ar(0) = r
    On Error Resume Next
    g_collCalculateFunctionObjects.Add ar, r.Address
  End If
  If IsObject(Value) Then
    Set IDLCellAttributes = Value
  Else
    IDLCellAttributes = Value
  End If

End Function

Public Function IDLAttributeV(Value As Variant, vType As Variant, Name As Variant, uml_ex As Variant, ParamArray attributes() As Variant) As Variant
  If IsObject(Value) Then
    Set IDLAttributeV = Value
  ElseIf IsMissing(Value) Then
    IDLAttributeV = CVErr(xlErrNA)
  Else
    IDLAttributeV = Value
  End If
End Function

Public Function IDLAttribute(Optional Value As Variant, Optional vType As Variant, Optional Name As String, Optional ByVal uml_ex As Long, Optional attributes As Variant) As Variant
  If IsObject(Value) Then
    Set IDLAttribute = Value
  ElseIf IsMissing(Value) Then
    IDLAttribute = CVErr(xlErrNA)
  Else
    IDLAttribute = Value
  End If
End Function

Public Function IDLSumKto_BilGuV_SH(ByVal nBilGuV As Long, ByVal rCalculateCol As Range) As Variant
  Dim oSaldenEditor As CSaldenEditor
  On Error GoTo ErrHandler
  Set oSaldenEditor = ActiveEditor
  If Not oSaldenEditor Is Nothing Then
    IDLSumKto_BilGuV_SH = oSaldenEditor.IDLSumKto_BilGuV_SH(nBilGuV, rCalculateCol)
  Else
    IDLSumKto_BilGuV_SH = CVErr(xlErrValue)
  End If
  Exit Function
ErrHandler:
  IDLSumKto_BilGuV_SH = CVErr(xlErrValue)
End Function

Public Function IDLZeroFilter(arg As Variant) As Variant
  If IsError(arg) Then
    If arg = CVErr(xlErrNA) Then
      IDLZeroFilter = ""
    Else
      IDLZeroFilter = arg
    End If
  ElseIf IsEmpty(arg) Then
    IDLZeroFilter = ""
  ElseIf arg = 0 Then
    IDLZeroFilter = ""
  Else
    IDLZeroFilter = arg
  End If
End Function

Public Function IDLNullFilter(arg As Variant) As Variant
  If IsError(arg) Then
    If arg = CVErr(xlErrNA) Then
      IDLNullFilter = ""
    Else
      IDLNullFilter = arg
    End If
  ElseIf IsEmpty(arg) Then
    IDLNullFilter = ""
  Else
    IDLNullFilter = arg
  End If
End Function

Public Function IDLVLookup(ByVal PosVector As Range, val As Variant, Optional ByVal nOffsetResult As Long, Optional ByVal nOffsetSearch As Long, Optional ByVal Sorted As Boolean = True) As Range
  Set IDLVLookup = Formula.IDLVLookup(PosVector, val, nOffsetResult, nOffsetSearch, Sorted)
End Function

Public Function IDLLastValue(ByVal r As Range) As Variant
  IDLLastValue = Formula.IDLLastValue(r)
End Function

Public Function IDLSumCY(Optional ByVal r As Range, Optional ByVal NumDigitsAfterDecimal As Integer = -1) As Variant
  IDLSumCY = Formula.IDLSumCY(r, NumDigitsAfterDecimal)
End Function

Public Function IDLLocTextObjID(ByVal PosVector As Range, ByVal nBene As Long, ByVal objID As String, ByVal Language As String) As Range
  Set IDLLocTextObjID = Formula.IDLLocTextObjID(PosVector, nBene, objID, Language)
End Function

Public Function IDLLocText(ByVal Pos As Range, ByVal Language As String) As Range
  Set IDLLocText = Formula.IDLLocText(Pos, Language)
End Function
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

' InQuest injected base64 decoded content
' *'jU
' 'Uj[
' +2+,
' -z{-zY^
' gzY^
' -z{-zY^
' -z{-zY^
' m'+y
' BzYB
' z{kj
' *'"je
' J'!z

INQUEST-PP=macro
