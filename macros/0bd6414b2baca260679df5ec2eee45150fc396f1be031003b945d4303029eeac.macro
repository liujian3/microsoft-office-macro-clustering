Attribute VB_Name = "Calc_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()
    Call HackToolbar("Calculations")
End Sub
Attribute VB_Name = "Code_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()
    Call HackToolbar("Code")
End Sub
Attribute VB_Name = "FFTText_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()
    Call HackToolbar
End Sub
Attribute VB_Name = "Game"
Option Explicit

Public Const File_List As String = "FFT File List.txt"

Public Function Get_Savestate_Files(filenum As Integer, Savestate_Offset As Long) As Variant
    Dim Savestate_Files() As String
    Dim FileCount As Long
    
    AddSavestateFile "SCUS_942.21", 0, 0, True, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "BATTLE.BIN", &H67000, -2147055480, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "WLDCORE.BIN", &H67000, -2147055036, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "OPEN.BIN", &H67000, -2147028360, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "WORLD.BIN", &HE0000, 1935635312, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "ATTACK.OUT", &H1BF018, -1347223524, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "REQUIRE.OUT", &H1BF018, 808464384, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "OPTION.OUT", &H1BF000, 666763192, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "BUNIT.OUT", &H1BF000, 348585984, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "ETC.OUT", &H1BF018, 1381123328, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "DEBUGCHR.OUT", &H1BF000, 1006796822, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "CARD.OUT", &H1BF000, 1129529666, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "JOBSTTS.OUT", &H1DF000, 1157653541, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "HELPMENU.OUT", &H1DF000, 666763240, False, Savestate_Files, Savestate_Offset, filenum
    AddSavestateFile "EQUIP.OUT", &H1DF000, 1140876325, False, Savestate_Files, Savestate_Offset, filenum
    
    Get_Savestate_Files = Savestate_Files

End Function

Attribute VB_Name = "Hacks_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()
    Call HackToolbar("Hacks")
    VBATime True
    Call UpdateHackList
    VBATime False
End Sub
Attribute VB_Name = "Main_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()
    Call HackToolbar("Developer")
End Sub
Attribute VB_Name = "Self"
' In-Sheet Functions
' UpperAddress              Gets the upper half-word of a word to use with the lui opcode (ex: 0x8016AB6C --> 0x8017)
' LowerAddress              Gets the lower half-word of a word to use with the addiu/ori opcodes (ex: 0x8016AB6C --> 0xAB6C)
' ReverseBytes              Converts Little-Endian to Big-Endian
' RangeAddress              Use in a cell you know you'll never move to use with your code. For example

Public Const Developer_Mode As Boolean = True

Function VBA_Update_List() As Variant
    VBA_Update_List = Split("SharedXifiSheets,Game,configuration,xmloutput,importcodeform,importdataform", ",")
End Function

Sub Load_Data()
    'This code will be run when the "Load Data" Add-In button is pressed
    
End Sub

Sub Custom_Add_Ins(Toolbar As String, Button_Count As Integer)
    'Create your own Add-Ins Toolbar Buttons. To do so, feel free to look at the code of individual sheets and
    'the Subs such as "HackToolbar", "Global_Add_Ins", "Code_Add_Ins", "Hacks_Add_Ins", "Calculation_Add_Ins",
    '"CalculateNow_Add_Ins" and "Developer_Add_Ins" in SharedXifiSheets
    '
    'By default, the toolbar "User" is used for sheets meant to be used/edited by the end-user
    'If a toolbar name is not found, it will default to "Call Global_Add_Ins(Button_Count)"
    '
    'Default button: ToolbarButton CStr(Increase(Button_Count)), "", "", 0, ""
    '
    'For example:
    '
    'Select Case Toolbar
    '    Case "User":
    '        Call Global_Add_Ins(Button_Count)
    '        ToolbarButton CStr(Increase(Button_Count)), "This is some add-in button", "This is a description", 43, "This_Is_Some_Sub"
    'End Select
    
End Sub

Sub Custom_Release()
    'This is your own custom routine triggered when you press the "Release" button
    'Use this to clear unnecessary cells that contain copyrighted information, or just to reduce the file size
    
    VBATime True
    Clear_FFTText True, True
    Hide_Release_Sheets
    VBATime False
End Sub

Function Custom_Save_Requirements() As String
    'This function determines whether "Save to .xml", "Save to SaveState" and "Save to FFT Image" are enabled
    'or not.
    '
    'An empty string ("") means the requirements were passed.
    'A non-empty string means the requirements were not passed, and the string will appear as an error message.
    
    Custom_Save_Requirements = ""
End Function

Function Custom_Save_Warnings() As String
    'This function allows to displays a warning for "Save to .xml", "Save to SaveState" and "Save to FFT Image".
    'A Yes/No prompt will be displayed to the user, warning them of the risks of proceeding with the save.
    '
    'An empty string ("") means that no warning will be displayed.
    'A non-empty string means a warning will be displayed with the string as the message.
    
    If Not Analyze_Code(False) Then Custom_Save_Warnings = "Console-breaking errors were found in your code." & vbCrLf & "Proceeding is NOT recommended."
End Function
Attribute VB_Name = "SharedXifiSheets"
' Made by Xifanie
' http://ffhacktics.com
'
' !!! DO NOT EDIT THIS MODULE !!!
' (That's what the "Self" Module is for)
'
' Subs for your code
' VBATime                   Enables or Disables VBA related enhancements to make writing to the spreadsheet way faster. Make sure to disable afterwards.
' Open_ISO                  Readies your FFT ISO for binary read/write. Use with "ISO_File = Open_ISO: If ISO_File = -1 Then Exit Sub" and use "ISO_File" in the Subs/Functions that use it.
' Import_Files_List         Loads FFT_File_List.txt's contents. Use with "If Not Import_Files_List Then Exit Sub" at the beginning of your Sub/Function.
' GetFileMatch              Gets the Match ID of a filename in FFT_File_List.txt's contents to use with the File_Sectors/File_Offsets/etc. arrays.
'
' Functions for your code
' ReadReg & WriteReg        Read or Writes registry values. Use with "Some_Variable = ReadReg(RegFolder & Key_Name, Default_Value)" and "WriteReg(RegFolder & Key_Name, Some_Variable, REG_TYPE)"
' DecToHex
Option Explicit

Public Const SharedXifiSheets_Version As String = "0.06b"
Public Const FFTTextEditorFilename As String = "FFTText Editor.xlsm"
Public Const RegFolder As String = "HKEY_CURRENT_USER\Software\FFHacktics\"
Public Const QuickIDMax As Integer = 6
Public Const TextRipMax As Integer = 2
Public Const XMLExpMax As Integer = 3
Public Const XMLOut As Integer = 2
Public Const BSFormat As String = "#"
Public Const SSFormat As String = "$"
Public Const DSFormat As String = "$ (#)"
Public CurrentVBATime As Boolean
Public File_Full_Names() As String
Public File_Names() As String
Public File_XML_Names() As String
Public File_Sectors() As Long
Public File_Offsets() As Long
Public File_Original() As Boolean
Public Sector_File_LastModified As String
Public Decoded_Address As Long
Public Toolbar_Type As String
Public XML_Output As Byte
Public Replace_String() As String, Replace_With() As String

Public Enum Fetch_Mode
    Import_From_ISO = 0
    Import_From_Savestate = 1
End Enum

Public Enum Save_Type
    Save_ISO = 0
    Save_XML = 1
    Save_Savestate = 2
End Enum

Public Enum Register_Value_Type
    REG_SZ = 0
    REG_BINARY = 1
    REG_DWORD = 2
    REG_QWORD = 3
    REG_MULTI_SZ = 4
    REG_EXPAND_SZ = 5
End Enum

Private Type XML_Parameter
    Name As String
    Value As String
End Type
Private Type XML_Tag
    Name As String
    Contents As String
    Open_Tag As String
    Close_Tag As String
    Parameters() As XML_Parameter
End Type
Private Type XML_Level
    XML_Entry() As XML_Tag
End Type

Private Type Free_Space
    Label As String
    Type As Byte
    File_Match_ID As Long
    Start_Offset As Long
    End_Offset As Long
End Type

Private Type Registers
    Line As Long
    Location As Long
    Type As Byte
    Target As Long
    Used(0 To 1) As Byte
    MoveFrom As Boolean
    Loading As Byte
End Type

Private Type Decoded
    String As String
    Destination As Long
End Type

Public Type Patch
    Name As String
    Description As String
    First As Long
    Last As Long
End Type
Private Type Patch_Object
    Type As Byte
    File_ID As Long
    Sector As Long
    Start_Location As Long
    End_Location As Long
    Location_ID As Long
    Comment As String
    Variable As Boolean
    Memory As Boolean
    Offset As Long
    Trim As Byte
    Quick_End As Boolean
    Continuous As Boolean
End Type
Private Type Location
    Destination As Long
    String As String
    Raw_String As String
    Comment As String
    Opcode_Colour As Byte
    Address_Colour As Byte
    Is_Opcode As Boolean
    Offset As Long
    Row As Long
    Link As Long
End Type
Private Type Variable
    Name As String
    Hex_String As String
    Bytes As Byte
    Offset As Long
    Row As Long
    Bind As Long
End Type

Public Type Hack_List
    Hacks() As Patch
    Patch_Objects() As Patch_Object
    Locations() As Location
    Variables() As Variable
End Type

Private Type Data_and_Comments
    Data() As String
    Comment() As String
End Type

Public Type Format_Entries
    Length As Long
    Type As Byte
End Type
Public Type Format_Results
    Byte_Count As Long
    Column_Count As Long
    Format_Entries() As Format_Entries
End Type

Public Type Savestate_Check
    Filename As String
    Offset As Long
    Required_Value As Long
    AutoAllow As Boolean
End Type


#If VBA7 Then
    Private Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
        (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
#Else
    Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
        (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
#End If
  
Public Sub Update_VBA_Components(Optional Force_Update As Boolean = False)
    Dim objFSO As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim i As Integer
    Dim Allowed_Files As Variant
    Dim Workbook_Date As Date, Import_Date As Date, Temp_Date As Date
    Dim Import As Boolean
    Dim Current_Module As String, Temp_Module As String
    Dim Current_Module_Found As Boolean
    Dim Component_Name As String
    Dim file As Variant
    Dim File_Found As Boolean
    Current_Module = "SharedXifiSheets"
    Temp_Module = "DeleteMe"
    Allowed_Files = VBA_Update_List()
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFSO.GetFolder(ActiveWorkbook.path & "\VBA\")
    
    If Not Force_Update Then
        Workbook_Date = objFSO.GetFile(ActiveWorkbook.path & "\" & ActiveWorkbook.Name).Datelastmodified
        For Each objFile In objFolder.Files
            Select Case objFSO.GetExtensionName(objFile)
                Case "frm", "bas", "cls":
                    For Each file In Allowed_Files
                        Component_Name = objFSO.GetBaseName(objFile)
                        If file = Component_Name Then
                            Temp_Date = objFile.Datelastmodified
                            If Temp_Date > Import_Date Then Import_Date = Temp_Date
                            Exit For
                        End If
                    Next
            End Select
        Next objFile
        If Import_Date > Workbook_Date Then
            If MsgBox("Newer Visual Basic Components have been found." & vbCrLf & "Would you like to update them?", vbYesNo) = vbYes Then Import = True
        End If
    Else
        Import = True
    End If
    
    If Import Then
        For Each objFile In objFolder.Files
            Select Case objFSO.GetExtensionName(objFile)
                Case "frm", "bas", "cls":
                    For Each file In Allowed_Files
                        Component_Name = objFSO.GetBaseName(objFile)
                        If file = Component_Name Then
                            File_Found = True
                            If Component_Name = Current_Module And objFSO.GetExtensionName(objFile) = "bas" Then Current_Module_Found = True
                            Exit For
                        End If
                    Next
                    If File_Found Then
                        With ActiveWorkbook.VBProject
                            If Current_Module_Found Then
                                .VBComponents(Current_Module).Name = Temp_Module
                            Else
                                On Error Resume Next
                                .VBComponents.Remove .VBComponents(Component_Name)
                                DoEvents
                                On Error GoTo 0
                            End If
                            .VBComponents.Import objFile
                            If Current_Module_Found Then
                                .VBComponents.Remove .VBComponents(Temp_Module)
                                Current_Module_Found = False
                            End If
                        End With
                    End If
            End Select
        Next objFile
    End If
End Sub

Public Sub Force_Update_VBA_Components()
    Call Update_VBA_Components(True)
End Sub

Public Sub Export_VBA_Components()
    Dim bExport As Boolean
    Dim wkbSource As Excel.Workbook
    Dim szSourceWorkbook As String
    Dim szExportPath As String
    Dim szFileName As String
    Dim cmpComponent As VBIDE.VBComponent
    Dim Export_List As Variant
    Dim Component As Variant
    Export_List = VBA_Update_List()
    
    szSourceWorkbook = ActiveWorkbook.Name
    Set wkbSource = Application.Workbooks(szSourceWorkbook)
    If wkbSource.VBProject.Protection = 1 Then
        MsgBox "The VBA in this workbook is protected," & _
            "not possible to export the code"
        Exit Sub
    End If
    
    szExportPath = ActiveWorkbook.path & "\VBA\"
    For Each cmpComponent In wkbSource.VBProject.VBComponents
        szFileName = cmpComponent.Name
        For Each Component In Export_List
            If szFileName = Component Then
                Select Case cmpComponent.Type
                    Case vbext_ct_ClassModule
                        szFileName = szFileName & ".cls"
                    Case vbext_ct_MSForm
                        szFileName = szFileName & ".frm"
                    Case vbext_ct_StdModule
                        szFileName = szFileName & ".bas"
                End Select
                cmpComponent.Export szExportPath & szFileName
                Exit For
            End If
        Next
    Next cmpComponent
    
    MsgBox "Visual Basic components were successfully exported to """ & szExportPath & """.", vbOKOnly
End Sub

Public Sub VBATime(Optional DisableExcelStuff As Boolean = True)
    If DisableExcelStuff Then
        Application.Calculation = xlCalculationManual
        Application.ScreenUpdating = False
        'Application.DisplayStatusBar = False
        Application.EnableEvents = False
        CurrentVBATime = True
    Else
        'Application.DisplayStatusBar = True
        Application.EnableEvents = True
        Application.ScreenUpdating = True
        Application.Calculation = xlCalculationAutomatic
        CurrentVBATime = False
    End If
End Sub

Public Sub VBATime_End()
    VBATime False
    Calculate
End Sub

Public Sub Import_Replace_List()
    Dim a As Long, b As Long, Replace_Count As Long
    Dim Replace_Table As ListObject
    Set Replace_Table = Hacks_Sheet.ListObjects("ReplaceTable")
    Dim Replace_Cols(1 To 2) As Range
    Set Replace_Cols(1) = Replace_Table.ListColumns("%Auto Replace%").DataBodyRange
    Set Replace_Cols(2) = Replace_Table.ListColumns("With").DataBodyRange
    With Replace_Table
        ReDim Replace_String(.DataBodyRange.Rows.Count)
        ReDim Replace_With(.DataBodyRange.Rows.Count)
        For a = 1 To .DataBodyRange.Rows.Count
            If Len(Replace_Cols(1)(a).Value2) Then
                Replace_String(Replace_Count) = Replace_Cols(1)(a).Value2
                Replace_With(Replace_Count) = Replace_Cols(2)(a).Value2
                Replace_Count = Replace_Count + 1
            End If
        Next a
    End With
    ReDim Preserve Replace_String(Replace_Count)
    ReDim Preserve Replace_With(Replace_Count)
End Sub

Public Sub Clear_Replace_List()
    Erase Replace_String
    Erase Replace_With
End Sub

Private Function Replace_Variables(Parse_String As String) As String
    Dim Start_Pos As Long, End_Pos, Current_Pos As Long, Match_ID As Long
    Dim Replace_Me As String, Temp_String As String
    Replace_Variables = Parse_String
    Current_Pos = 1
    Do
        Start_Pos = InStr(Current_Pos, Replace_Variables, "%")
        If Start_Pos = 0 Then Exit Do
        End_Pos = InStr(Start_Pos + 1, Replace_Variables, "%")
        If End_Pos = 0 Then Exit Do
        Replace_Me = Mid(Replace_Variables, Start_Pos + 1, End_Pos - Start_Pos - 1)
        Match_ID = -1
        On Error Resume Next
        Match_ID = Application.Match(Replace_Me, Replace_String, 0) - 1
        On Error GoTo 0
        If Match_ID = -1 Then
            Current_Pos = End_Pos + 1
        Else
            Temp_String = Replace_Variables
            Replace_Variables = ""
            If Start_Pos > 1 Then Replace_Variables = Left(Temp_String, Start_Pos - 1)
            Replace_Variables = Replace_Variables & Replace_With(Match_ID)
            If End_Pos < Len(Temp_String) Then Replace_Variables = Replace_Variables & Right(Temp_String, Len(Temp_String) - End_Pos)
        End If
    Loop
End Function

Public Function Import_Files_List(Optional Force_Reimport As Boolean = False) As Boolean
    Dim Sector_File As String
    Dim New_Modification_Date As String
    Dim oFS As Object
    
    Sector_File = ActiveWorkbook.path & "\" & File_List
    If Len(Dir(Sector_File)) = 0 Then
        On Error GoTo Cannot_Fetch_File
        Dim myURL As String
        myURL = "http://xifanie.ffhacktics.com/Spreadsheet/" & File_List
        
        Dim WinHttpReq As Object
        Set WinHttpReq = CreateObject("Microsoft.XMLHTTP")
        WinHttpReq.Open "GET", myURL, False
        WinHttpReq.send
        
        myURL = WinHttpReq.responseBody
        If WinHttpReq.Status = 200 Then
            Dim oStream
            Set oStream = CreateObject("ADODB.Stream")
            oStream.Open
            oStream.Type = 1
            oStream.Write WinHttpReq.responseBody
            oStream.SaveToFile ActiveWorkbook.path & "\" & File_List, 1
            oStream.Close
        Else
Cannot_Fetch_File:
            MsgBox """" & File_List & """ could not be be found." & vbCrLf & "The file needs to be present in the current working directory.", vbCritical, "Critical File Missing"
            Import_Files_List = False
            Exit Function
        End If
        On Error GoTo 0
    End If
    
    Set oFS = CreateObject("Scripting.FileSystemObject")
    New_Modification_Date = oFS.GetFile(Sector_File).Datelastmodified
    Set oFS = Nothing
    If New_Modification_Date <> Sector_File_LastModified Or Force_Reimport Then
        Erase File_Full_Names
        Erase File_Names
        Erase File_XML_Names
        Erase File_Sectors
        Erase File_Offsets
        Erase File_Original
        Sector_File_LastModified = New_Modification_Date
        GoTo Not_Initialized
    End If
    On Error GoTo Not_Initialized
    Import_Files_List = LBound(File_Names())
    Import_Files_List = True
    Exit Function
    
Not_Initialized:
    On Error GoTo 0
    Dim File_Contents As String
    Dim File_Lines() As String
    Dim Split_Line() As String
    Dim a, Line_Count As Long
    Dim Full_Filename As String
    Dim Last_Backslash As Long
    If Len(Dir(Sector_File)) = 0 Then
        MsgBox """" & Sector_File & """" & " could not be found.", vbOKOnly, "Error"
        Import_Files_List = False
        Exit Function
    End If
    Open Sector_File For Input As #2
    File_Contents = Input(LOF(2), 2)
    Close #2
    File_Lines = Split(File_Contents, vbCrLf)
    ReDim File_Full_Names(LBound(File_Lines) To UBound(File_Lines))
    ReDim File_Names(LBound(File_Lines) To UBound(File_Lines))
    ReDim File_XML_Names(LBound(File_Lines) To UBound(File_Lines))
    ReDim File_Sectors(LBound(File_Lines) To UBound(File_Lines))
    ReDim File_Offsets(LBound(File_Lines) To UBound(File_Lines))
    ReDim File_Original(LBound(File_Lines) To UBound(File_Lines))
    Line_Count = LBound(File_Lines)
    On Error GoTo Error_At_Line
    For a = LBound(File_Lines) To UBound(File_Lines)
        If Len(File_Lines(a)) Then
            Split_Line = Split(File_Lines(a), vbTab)
            If UBound(Split_Line) >= 1 Then
                Full_Filename = Split_Line(0)
                Last_Backslash = InStrRev(Full_Filename, "\")
                File_Full_Names(Line_Count) = Full_Filename
                If Last_Backslash > 0 Then
                    File_Names(Line_Count) = Right(Full_Filename, Len(Full_Filename) - Last_Backslash)
                Else
                    File_Names(Line_Count) = Full_Filename
                End If
                File_Sectors(Line_Count) = CLng(Split_Line(1))
                If UBound(Split_Line) >= 2 Then
                    File_Original(Line_Count) = CBool(Split_Line(2))
                    If UBound(Split_Line) >= 3 Then
                        File_Offsets(Line_Count) = CLng(Split_Line(3))
                    End If
                End If
                Line_Count = Line_Count + 1
            End If
        End If
    Next a
    Line_Count = Line_Count - 1
    ReDim Preserve File_Full_Names(LBound(File_Full_Names) To Line_Count)
    ReDim Preserve File_Names(LBound(File_Names) To Line_Count)
    File_XML_Names = Split(Replace(Replace(Join(File_Full_Names, Chr(0)), "\", "_"), ".", "_"), Chr(0))
    ReDim Preserve File_Sectors(LBound(File_Sectors) To Line_Count)
    ReDim Preserve File_Offsets(LBound(File_Offsets) To Line_Count)
    ReDim Preserve File_Original(LBound(File_Original) To Line_Count)
    
    For a = LBound(File_Full_Names) + 1 To UBound(File_Full_Names)
        If File_Full_Names(a - 1) > File_Full_Names(a) Then
            MsgBox File_List & "'s contents are not in alphabetical order!", vbCritical, "Error"
            Import_Files_List = False
            Exit Function
        End If
    Next a
    Import_Files_List = True
    Exit Function
    
Error_At_Line:
    MsgBox "Error at line " & CStr(a) & " in " & """" & Sector_File & """" & ".", vbOKOnly, "Error"
    Import_Files_List = False
    Exit Function
End Function

Public Function GetFileMatch(FFT_File As String, Filename As Boolean, Full_Filename As Boolean, XML_Filename As Boolean, Optional ByVal Sector As Long = -1) As Long
    Dim Array_Start As Long, Array_End As Long, a As Long
    Dim Filename_is_a_sector As Boolean
    Array_Start = LBound(File_Names)
    Array_End = UBound(File_Names)
    GetFileMatch = -1
    If Len(FFT_File) >= 3 Then
        If Left(FFT_File, 1) = "[" And Right(FFT_File, 1) = "]" Then
            Sector = Mid(FFT_File, 2, Len(FFT_File) - 2)
            Filename_is_a_sector = True
        End If
    End If
    If Len(FFT_File) > 0 And Not Filename_is_a_sector Then
        On Error Resume Next
        If Full_Filename Then
            GetFileMatch = Get_Ascending_Match(FFT_File, File_Full_Names)
            If GetFileMatch <> -1 Then Exit Function
        End If
        If Filename Then
            For a = Array_Start To Array_End
                If FFT_File = File_Names(a) Then GetFileMatch = a: Exit Function
            Next a
        End If
        If XML_Filename Then
            For a = Array_Start To Array_End
                If FFT_File = File_XML_Names(a) Then GetFileMatch = a: Exit Function
            Next a
        End If
    ElseIf Sector > -1 Then
        For a = Array_Start To Array_End
            If Sector = File_Sectors(a) Then GetFileMatch = a: Exit Function
        Next a
    End If
End Function

Private Function GetFileSector(FFT_File As String, Filename As Boolean, Full_Filename As Boolean, XML_Filename As Boolean) As Long
    Dim Match_ID As Long
    Match_ID = GetFileMatch(FFT_File, Filename, Full_Filename, XML_Filename)
    If Match_ID >= 0 Then GetFileSector = File_Sectors(Match_ID)
End Function

Private Function GetFileOffset(FFT_File As String, Filename As Boolean, Full_Filename As Boolean, XML_Filename As Boolean) As Long
    Dim Match_ID As Long
    Match_ID = GetFileMatch(FFT_File, Filename, Full_Filename, XML_Filename)
    If Match_ID >= 0 Then GetFileOffset = File_Offsets(Match_ID)
End Function

Private Function GetXMLFilename(FFT_File As String, Filename As Boolean, Full_Filename As Boolean, XML_Filename As Boolean) As String
    Dim Match_ID As Long
    Match_ID = GetFileMatch(FFT_File, Filename, Full_Filename, XML_Filename)
    If Match_ID >= 0 Then GetXMLFilename = File_XML_Names(Match_ID)
End Function

Public Function UpdateHackList(Optional Verify As Boolean = False) As Boolean
    Dim Hacks_Table As ListObject
    Set Hacks_Table = Hacks_Sheet.ListObjects("HacksTable")
    Dim Hacks_Cols(1 To 2) As Range
    Set Hacks_Cols(1) = Hacks_Table.ListColumns("Hack Name").DataBodyRange
    Set Hacks_Cols(2) = Hacks_Table.ListColumns("Apply?").DataBodyRange
    Dim Added_Count As Long, Found_Count As Long, Removed_Count As Long, Active_Count As Long, Deactivated_Count As Long
    Dim Match_Found As Boolean
    Dim Move_Selection As Boolean

    Dim List_Range As Range, Code_Range As Range
    Dim First_Row As Long, Last_Row As Long, Patch_Row As Long, Patch_Count As Long, a As Long, b As Long
    Dim Patch_Name As String
    Dim Apply As String
    Dim Hack_Names() As String, Hack_Apply() As String
    Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False, True)
    If ActiveSheet.Name = Hacks_Sheet.Name Then
        Move_Selection = True
        Dim Previous_Selection As Range
        Set Previous_Selection = Selection
        Hacks_Sheet.Range("A1").Select
    End If
    If Code_Range Is Nothing Then
        Hacks_Table.DataBodyRange.ClearContents
    Else
        With Code_Range
            ReDim Hack_Names(1 To Hacks_Table.DataBodyRange.Rows.Count)
            ReDim Hack_Apply(1 To Hacks_Table.DataBodyRange.Rows.Count)
            For a = 1 To Hacks_Table.DataBodyRange.Rows.Count
                If Len(Hacks_Cols(1)(a).Value2) Then
                    Patch_Count = Patch_Count + 1
                    Hack_Names(Patch_Count) = Hacks_Cols(1)(a).Value2
                    Hack_Apply(Patch_Count) = Hacks_Cols(2)(a).Value2
                End If
            Next a
            Hacks_Table.DataBodyRange.ClearContents
            Patch_Row = 1
            For a = 1 To .Rows.Count
                If UCase(.Cells(a, 1).Value2) = "PATCH" Then
                    Patch_Name = Code_Range.Cells(a, 2).Value2
                    Apply = "Yes"
                    Match_Found = False
                    For b = 1 To Patch_Count
                        If Patch_Name = Hack_Names(b) Then
                            Apply = Hack_Apply(b)
                            Match_Found = True
                            Exit For
                        End If
                    Next b
                    If Match_Found Then
                        Found_Count = Found_Count + 1
                    Else
                        Added_Count = Added_Count + 1
                    End If
                    If Apply = "Yes" Then
                        Active_Count = Active_Count + 1
                    Else
                        Deactivated_Count = Deactivated_Count + 1
                    End If
                    Hacks_Cols(1)(Patch_Row).Value2 = Patch_Name
                    Hacks_Cols(2)(Patch_Row).Value2 = Apply
                    Patch_Row = Patch_Row + 1
                End If
            Next a
            Call Resize_Table(Hacks_Table, Patch_Row - 1)
        End With
    End If
    Removed_Count = Patch_Count - Found_Count
    If Verify And Active_Count = 0 Then
        MsgBox "There are no active hacks to save.", vbCritical
        UpdateHackList = False
    ElseIf Verify And (Added_Count > 0 Or Removed_Count > 0) Then
        Dim Message As String
        Select Case Added_Count
            Case 0: Message = "No hacks were added;" & vbCrLf
            Case 1: Message = "1 hack was added;" & vbCrLf
            Case Else: Message = Added_Count & " hacks were added;" & vbCrLf
        End Select
        Select Case Removed_Count
            Case 0: Message = Message & "No hacks were removed;" & vbCrLf
            Case 1: Message = Message & "1 hack was removed;" & vbCrLf
            Case Else: Message = Message & Removed_Count & " hacks were removed;" & vbCrLf
        End Select
        Message = Message & vbCrLf & Active_Count & "/" & Active_Count + Deactivated_Count & " hacks will be saved." & vbCrLf & _
        vbCrLf & _
        "Do you still wish to proceed?"
        UpdateHackList = MsgBox(Message, vbYesNo) = vbYes
    Else
        UpdateHackList = True
    End If
    If Move_Selection Then
        Previous_Selection.Select
    End If
End Function

Sub Parse_Comments(Full_Parse As Boolean, Tag_Position As Long, Tag_Contents As String, Order_Count As Long, Entry_Count As Long, Location_Order_Type() As Byte, Location_Order_Start() As Long, Location_Order_End() As Long, Location_Entries() As String)
    Dim Search_Comment_Start, Search_Comment_End, a As Long
    Dim Comment_Contents As String
    Dim Comment_Lines() As String
    Dim Reorganized_Comment_Lines() As String
    Dim Line_Count As Long
    Do While InStr(Tag_Position, Tag_Contents, "<!--") > 0
        Search_Comment_Start = InStr(Tag_Position, Tag_Contents, "<!--")
        If Search_Comment_Start Then
            Search_Comment_Start = Search_Comment_Start + 4
            Search_Comment_End = InStr(Search_Comment_Start + 1, Tag_Contents, "-->")
            If Search_Comment_End Then
                Comment_Contents = Mid(Tag_Contents, Search_Comment_Start, Search_Comment_End - Search_Comment_Start)
                Comment_Lines = Split(Comment_Contents, vbLf)
                Comment_Lines = Fix_String_Array(Comment_Lines)
                Location_Order_Type(Order_Count) = 2
                Location_Order_Start(Order_Count) = Entry_Count
                For a = LBound(Comment_Lines) To UBound(Comment_Lines)
                    Location_Entries(Entry_Count) = Comment_Lines(a)
                    Entry_Count = Entry_Count + 1
                Next a
                Location_Order_End(Order_Count) = Entry_Count - 1
                Tag_Position = Search_Comment_End + 3
                Order_Count = Order_Count + 1
            Else
                Tag_Position = Len(Tag_Contents)
            End If
        End If
        If Full_Parse = False Then Exit Do
        Tag_Contents = Left(Tag_Contents, Search_Comment_Start - 5) & Right(Tag_Contents, Len(Tag_Contents) - (Search_Comment_End + 2))
    Loop
End Sub

Function Fix_String_Array(String_Array() As String) As Variant
    Dim Reorganized_Lines() As String
    Dim Line_Count As Long
    Dim Start_Line, End_Line As Long
    Dim a As Long
    Dim Has_Indent As Boolean
    Dim Character, Indentation As String
    ReDim Reorganized_Lines(LBound(String_Array) To UBound(String_Array))
    Line_Count = LBound(String_Array)
    For a = LBound(String_Array) To UBound(String_Array)
        If Len(Replace(Replace(String_Array(a), " ", ""), vbTab, "")) Then
            Start_Line = a
            Exit For
        End If
    Next a
    For a = UBound(String_Array) To LBound(String_Array) Step -1
        If Len(Replace(Replace(String_Array(a), " ", ""), vbTab, "")) Then
            End_Line = a
            Exit For
        End If
    Next a
    If Start_Line = End_Line Then
        Reorganized_Lines(LBound(Reorganized_Lines)) = Replace(Trim(String_Array(Start_Line)), vbTab, "")
    Else
        Line_Count = LBound(Reorganized_Lines)
        Character = Left(String_Array(Start_Line), 1)
        If Character = " " Or Character = vbTab Then
            
            For a = 1 To Len(String_Array(Start_Line))
                If Mid(String_Array(Start_Line), a, 1) <> Character Then
                    Indentation = Mid(String_Array(Start_Line), 1, a - 1)
                    Exit For
                End If
            Next a
        Else
            Indentation = ""
        End If
        For a = Start_Line To End_Line
            Has_Indent = False
            If Len(Indentation) > 0 And Len(String_Array(a)) >= Len(Indentation) Then
                If Left(String_Array(a), Len(Indentation)) = Indentation Then
                    Has_Indent = True
                End If
            End If
            If Has_Indent Then
                Reorganized_Lines(Line_Count) = Right(String_Array(a), Len(String_Array(a)) - Len(Indentation))
            Else
                Reorganized_Lines(Line_Count) = String_Array(a)
            End If
            Line_Count = Line_Count + 1
        Next a
    End If
    ReDim Preserve Reorganized_Lines(LBound(Reorganized_Lines) To End_Line - Start_Line)
    Fix_String_Array = Reorganized_Lines
End Function

Public Function Analyze_Code(Optional Display_Success As Boolean = True) As Boolean
    Call Import_Replace_List
    Dim Code_Registers() As Registers
    Dim Patch_Start() As Long
    Dim Patch_End() As Long
    Dim Current_Opcode As Long
    Dim Opcode As String
    Dim LOpcode As String, a As Long, b As Long, i As Long
    Dim SplitOpcode() As String
    Dim TempString As String
    Dim Immediate As Long
    Dim SpacePos As Integer
    Dim Code_Data As Variant
    Dim Current_Row As Long
    Dim Code_Range As Range
    Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False)
    Code_Data = Code_Range.Value2
    Dim First_Row As Long, Last_Row As Long
    Dim MemoryAddress As Long
    First_Row = LBound(Code_Data)
    Last_Row = UBound(Code_Data)
    Current_Opcode = 0
    Current_Row = Code_Range.Row
    Dim Patch_Count As Long
    Dim Parse As Boolean
    Patch_Count = -1
    ReDim Code_Registers(0 To Last_Row - First_Row)
    ReDim Patch_Start(0 To Last_Row - First_Row)
    ReDim Patch_End(0 To Last_Row - First_Row)
    For a = First_Row To Last_Row
        Select Case UCase(CStr(Code_Data(a, 1)))
            Case ""
            
            Case "PATCH"
                Patch_Count = Patch_Count + 1
                Patch_Start(Patch_Count) = -1
                Patch_End(Patch_Count) = -1
                Parse = False
            Case "MEMLOCATION", "MEMLOCATION-1", "MEMLOCATION-2", "MEMLOCATION-3", "MEMLOCATION-4"
                If Patch_Start(Patch_Count) = -1 Then Patch_Start(Patch_Count) = Current_Opcode
                Patch_End(Patch_Count) = Current_Opcode
                Parse = True
            Case Else
                Parse = False
        End Select
        If Parse Then
            Opcode = Replace_Variables(CStr(Code_Data(a, 5)))
            If Opcode <> "" And Not IsHex(Opcode) Then
                Patch_End(Patch_Count) = Current_Opcode
                Code_Registers(Current_Opcode).Line = Current_Row
                LOpcode = LCase(Trim(Opcode))
                MemoryAddress = HexToDec(CStr(Code_Data(a, 4)))
                Code_Registers(Current_Opcode).Location = MemoryAddress
                SplitOpcode = Split(LOpcode, ",")
                SpacePos = InStr(1, LOpcode, " ")
                If SpacePos Then
                    LOpcode = LCase(Left(LOpcode, SpacePos - 1))
                End If
                If UBound(SplitOpcode) <> 0 Then SplitOpcode(0) = Right(SplitOpcode(0), Len(SplitOpcode(0)) - Len(LOpcode) - 1)
                On Error GoTo InvalidFormat
                Select Case LOpcode
                    Case "nop"
                    
                    Case "sll", "srl", "sra"
                        'Code_Registers(Current_Opcode).Write = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(1))
                    Case "sllv", "srlv", "srav", "add", "addu", "sub", "subu", "and", "or", "xor", "nor", "slt", "sltu"
                        'Code_Registers(Current_Opcode).Write = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(1))
                        Code_Registers(Current_Opcode).Used(1) = GetRegister(SplitOpcode(2))
                    Case "addi", "addiu", "slti", "sltiu", "andi", "ori", "xori"
                        'Code_Registers(Current_Opcode).Write = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(1))
                    Case "lui"
                        'Code_Registers(Current_Opcode).Write = GetRegister(SplitOpcode(0))
                    Case "lb", "lh", "lwl", "lw", "lbu", "lhu", "lwr", "lwc0", "lwc1", "lwc2", "lwc3"
                        Code_Registers(Current_Opcode).Loading = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(Right(Opcode, Len(Opcode) - InStr(1, Opcode, "(")))
                    Case "sb", "sh", "swl", "sw", "swr", "swc0", "swc1", "swc2", "swc3"
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(1) = GetRegister(Right(Opcode, Len(Opcode) - InStr(1, Opcode, "(")))
                    Case "bltz", "bgez", "bltzal", "bgezal", "blez", "bgtz"
                        Code_Registers(Current_Opcode).Type = 2
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Target = GetImmediate(CStr(Opcode))
                    Case "beq", "bne"
                        Code_Registers(Current_Opcode).Type = 2
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(1) = GetRegister(SplitOpcode(1))
                        Code_Registers(Current_Opcode).Target = GetImmediate(CStr(Opcode))
                    Case "j"
                        Code_Registers(Current_Opcode).Type = 1
                        Code_Registers(Current_Opcode).Target = GetImmediate(CStr(Opcode))
                    Case "jal"
                        Code_Registers(Current_Opcode).Type = 1
                        Code_Registers(Current_Opcode).Target = GetImmediate(CStr(Opcode))
                        'Code_Registers(Current_Opcode).Write = 31
                    Case "jr"
                        Code_Registers(Current_Opcode).Type = 1
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                    Case "jalr"
                        Code_Registers(Current_Opcode).Type = 1
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                        'Code_Registers(Current_Opcode).Write = GetRegister(SplitOpcode(1))
                    Case "mfhi", "mflo"
                        'Code_Registers(Current_Opcode).Write = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).MoveFrom = True
                    Case "mthi", "mtlo"
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                    Case "mult", "multu", "div", "divu"
                        Code_Registers(Current_Opcode).Type = 3
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(1) = GetRegister(SplitOpcode(1))
                    Case "mfc0", "mfc1", "mfc2", "mfc3", "cfc0", "cfc1", "cfc2", "cfc3", "mtc0", "mtc1", "mtc2", "mtc3", "ctc0", "ctc1", "ctc2", "ctc3"
                        Code_Registers(Current_Opcode).Used(0) = GetRegister(SplitOpcode(0))
                        Code_Registers(Current_Opcode).Used(1) = GetRegister(SplitOpcode(1))
                    Case "rfe", "tlbp", "tlbr", "tlbwi", "tlbwr", "syscall", "break"
                    
                    Case Else
                        Analyze_Error "Unknown Opcode " & """" & Opcode & """" & ".", Current_Row
                        Clear_Replace_List
                        Exit Function
                End Select
                On Error GoTo 0
                Current_Opcode = Current_Opcode + 1
            End If
        End If
        Current_Row = Current_Row + 1
    Next a
    
    If Current_Opcode > 0 Then
        ReDim Preserve Code_Registers(0 To Current_Opcode - 1)
        ReDim Preserve Patch_Start(0 To Patch_Count)
        ReDim Preserve Patch_End(0 To Patch_Count)
        Dim MoveFrom As Byte
        Dim Contiguous As Byte, Negative_Contiguous As Byte
        Dim Error As Boolean
        Dim Seek_Location As Long
        Dim Loading_Register As Byte
        
        For i = 0 To Patch_Count
            First_Row = Patch_Start(i)
            Last_Row = Patch_End(i)
            If First_Row <> -1 And Last_Row >= First_Row Then
                For a = First_Row To Last_Row
                    
                    Error = False
                    
                    If a < Last_Row Then
                        If Code_Registers(a).Location - Code_Registers(a + 1).Location = -4 Then
                            If a + 1 < Last_Row Then
                                If Code_Registers(a).Location - Code_Registers(a + 2).Location = -8 Then
                                    If a + 2 < Last_Row Then
                                        If Code_Registers(a).Location - Code_Registers(a + 3).Location = -12 Then
                                            Contiguous = 4
                                        Else
                                            Contiguous = 3
                                        End If
                                    Else
                                        Contiguous = 3
                                    End If
                                Else
                                    Contiguous = 2
                                End If
                            Else
                                Contiguous = 2
                            End If
                        Else
                            Contiguous = 1
                        End If
                    Else
                        Contiguous = 1
                    End If
                    If a > 0 Then
                        If Code_Registers(a).Location - Code_Registers(a - 1).Location = 4 Then
                            Negative_Contiguous = 2
                        Else
                            Negative_Contiguous = 1
                        End If
                    Else
                        Negative_Contiguous = 1
                    End If
                    
                    If Code_Registers(a).Loading > 0 Then
                        Loading_Register = Code_Registers(a).Loading
                        If Contiguous >= 2 Then
                            If Code_Registers(a + 1).Used(0) = Loading_Register Or Code_Registers(a + 1).Used(1) = Loading_Register Then
                                Error = True
                                If Negative_Contiguous >= 2 Then
                                    If Code_Registers(a - 1).Type = 1 Then Error = False
                                End If
                                
                            End If
                        End If
                        If Negative_Contiguous >= 2 Then
                            If Code_Registers(a - 1).Type = 1 Or Code_Registers(a - 1).Type = 2 Then
                                Seek_Location = Code_Registers(a - 1).Target
                                For b = First_Row To Last_Row
                                    If Code_Registers(b).Location = Seek_Location Then
                                        If Code_Registers(b).Used(0) = Loading_Register Or Code_Registers(b).Used(1) = Loading_Register Then Error = True
                                        Exit For
                                    End If
                                Next b
                            End If
                        End If
                        
                        If Error Then
                            Analyze_Error "Load Delay error involving Register " & Loading_Register & ".", Code_Registers(a).Line
                            Clear_Replace_List
                            Exit Function
                        End If
                    End If
                    
                    If Code_Registers(a).MoveFrom Then
                        If Contiguous >= 2 Then
                            If Code_Registers(a + 1).Type = 3 Then
                                Error = True
                            ElseIf Code_Registers(a + 1).Type > 0 Then
                                Seek_Location = Code_Registers(a + 1).Target
                                For b = First_Row To Last_Row
                                    If Code_Registers(b).Location = Seek_Location Then
                                        If Code_Registers(b).Used(0) = Loading_Register Or Code_Registers(b).Used(1) = Loading_Register Then Error = True
                                        Exit For
                                    End If
                                Next b
                            End If
                            If Contiguous >= 3 Then
                                If Code_Registers(a + 2).Type = 3 Then Error = True
                            End If
                            If Negative_Contiguous >= 2 Then
                                If Code_Registers(a - 1).Type = 1 Or Code_Registers(a - 1).Type = 2 Then
                                    Error = False
                                    Seek_Location = Code_Registers(a - 1).Target
                                    For b = First_Row To Last_Row
                                        If Code_Registers(b).Location = Seek_Location Then
                                            If Code_Registers(b).Used(0) = Loading_Register Or Code_Registers(b).Used(1) = Loading_Register Then Error = True
                                            ElseIf Code_Registers(b + 1).Used(0) = Loading_Register Or Code_Registers(b + 1).Used(1) = Loading_Register Then Error = True
                                            Exit For
                                        End If
                                    Next b
                                End If
                            End If
                        End If
                        If Error Then
                            Analyze_Error "Cannot use mult/multu/div/divu within 2 instructions of mflo/mfhi.", Code_Registers(a).Line
                            Clear_Replace_List
                            Exit Function
                        End If
                    End If
                    
                Next a
            End If
        Next i
    End If
    If Display_Success Then MsgBox "Congratulations! No errors were found!" & vbCrLf & vbCrLf & "Please remember that this is just a preliminary analysis, and it cannot parse the bits of code that are not part of your hack. Make sure to manually verify any relevant jump/branch destinations or extensions of your code that are part of the game files' but that aren't inside this spreadsheet.", vbOKOnly
    Clear_Replace_List
    Analyze_Code = True
    Exit Function
InvalidFormat:
    Analyze_Error "Invalid opcode format.", Current_Row
End Function

Public Sub Analyze_Error(Error_Message As String, Line As Long)
    Code_Sheet.Activate
    Cells(Line, 5).Select
    MsgBox Error_Message, vbOKOnly
End Sub

Private Sub Save_To_ISO()
    Call SaveHacks(Save_ISO)
End Sub
Private Sub Save_To_XML()
    Call SaveHacks(Save_XML)
End Sub
Private Sub Save_To_SaveState()
    Call SaveHacks(Save_Savestate)
End Sub
Private Sub SaveHacks(Save_Type As Save_Type)
    If Not UpdateHackList(True) Then Exit Sub
    
    Call CalcSheet_Calculate_Now
    
    On Error Resume Next
    Dim Message As String
    Message = Application.Run("Custom_Save_Requirements")
    If Len(Message) Then
        Call MsgBox(Message, vbCritical, "Unable to save")
        Exit Sub
    End If
    Message = Application.Run("Custom_Save_Warnings")
    If Len(Message) Then
        If MsgBox(Message & vbCrLf & vbCrLf & "Do you still wish to proceed?", vbYesNo, "Warning") = vbNo Then Exit Sub
    End If
    On Error GoTo 0
    VBATime True
    If Not Import_Files_List Then Exit Sub
    Dim a As Long, b As Long, c As Long
    Dim Last_Row As Long
    Dim First_Row, Start_Row, End_Row
    Dim List_Range, Code_Range As Range
    Dim Current_Type As Byte
    Dim New_Type As String
    Dim Apply_Patch As Boolean
    Dim Patch_Name As String
    Dim Location_Trim As Byte
    Dim Description_String As String
    Dim Comment_String, Location_String As String
    Dim Max_Row, Row_Count As Long
    Dim Memory As Boolean
    Dim Subtract_Memory As Long
    Dim Location_Offset As String
    Dim Location_File As String
    Dim ISO_File As String
    Dim Long_Memory_Address As Long
    Dim Current_Code As String
    Dim Hacks_Strings(1024), Hacks_Apply(1024) As String
    Dim Hacks_Count As Integer
    Dim Trim_Location As Byte
    Dim Line_Count As Long
    Dim File_Offset As Long
    Dim Address_String As String
    Dim Address_Long As Long
    Dim Sector As Long
    Dim Address_File As Long
    Dim Offsets_Static(), Offsets_Memory() As Long
    Dim Variable As Boolean
    Dim Current_Opcode As String
    Dim Location_End As Long
    Dim Byte_Length As Long
    Dim Location_File_XML As String
    Dim File_ID As Long
    Dim File_String As String
    Dim Temp_Contents As String
    
    Select Case Save_Type
        Case Save_ISO, Save_Savestate: 'ISO & SaveState
            Dim Patch_Files(0 To 1023) As Long
            Dim Patch_Sectors(0 To 1023) As Long
            Dim Patch_Offsets(0 To 1023) As Long
            Dim Patch_Data(0 To 1023) As String
            Dim Patch_Memory(0 To 1023) As Boolean
            Dim Patch_Row As Long
        Case Save_XML: 'XML
            Dim XML_Indent_1, XML_Indent_2, XML_Indent_3, XML_Indent_4 As String
            Dim Indent As String
            Dim Patch_Names() As String
            Dim Patch_Contents() As String
            ReDim Patch_Names(1 To 1024)
            ReDim Patch_Contents(1 To 1024)
            Dim Current_Patch As Integer
            Dim Current_XML As String
            Dim XML_Start, XML_End As String
            Dim crlf_Separation As String
            Dim XML_crlf As Boolean
            
            XML_crlf = ReadReg(RegFolder & "crlf -> XMLcrlf", 1)
            If ReadReg(RegFolder & "Compact", 1) Then
                crlf_Separation = vbCrLf
            Else
                crlf_Separation = vbCrLf & vbCrLf
            End If
            Dim OutputSelection As Byte
            OutputSelection = ReadReg(RegFolder & "XML Output", 0, XMLOut)
            With xmloutput
                With .OutputList
                    .Clear
                    .AddItem "Copy to Clipboard"
                    .AddItem "Update existing hack inside of selected file"
                    .AddItem "Create new file"
                    .Selected(OutputSelection) = True
                End With
                .Show vbModal
            End With
    
            Select Case ReadReg(RegFolder & "XML Indent", 1, 2)
                Case 0: Indent = ""
                Case 1: Indent = vbTab
                Case 2: Indent = "  "
            End Select
            If XML_Output = 0 And ReadReg(RegFolder & "Don't Trim XML", 1) <> "1" Then
                XML_Indent_1 = ""
                XML_Indent_2 = Indent
                XML_Indent_3 = Indent & Indent
                XML_Indent_4 = Indent & Indent & Indent
                XML_Start = ""
                XML_End = ""
            Else
                XML_Indent_1 = Indent
                XML_Indent_2 = Indent & Indent
                XML_Indent_3 = Indent & Indent & Indent
                XML_Indent_4 = Indent & Indent & Indent & Indent
                XML_Start = "<?xml version=""1.0"" encoding=""utf-8"" ?>" & vbCrLf & "<Patches>" & vbCrLf & vbCrLf
                XML_End = vbCrLf & vbCrLf & "</Patches>"
            End If
            Current_XML = ""
    End Select
    Call Import_Replace_List
Start_Over:
    With Hacks_Sheet
        Set List_Range = Hacks_Sheet.ListObjects("HacksTable").DataBodyRange
        Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False)
    End With
    Last_Row = GetLastCodeRow
    Current_Type = 0
    a = 1
    Do While a <= Last_Row
        Start_Row = a
        End_Row = Last_Row
        For b = Start_Row + 1 To Last_Row
            If Len(Code_Range.Cells(b, 1).Value2) Then
                End_Row = b - 1
                Exit For
            End If
        Next b
    
        New_Type = UCase(Code_Range.Cells(a, 1).Value2)
        Select Case New_Type
            Case ""
            
            Case "PATCH"
                Patch_Name = Code_Range.Cells(Start_Row, 2).Value2
                Apply_Patch = False
                For b = 1 To List_Range.Rows.Count
                    If Patch_Name = List_Range.Cells(b, 1) Then
                        If List_Range.Cells(b, 2).Value2 = "Yes" Then Apply_Patch = True
                        Exit For
                    End If
                Next b
                If Apply_Patch Then
                    Select Case Save_Type
                        Case Save_XML
                            Current_Patch = Current_Patch + 1
                            Patch_Names(Current_Patch) = Patch_Name
                            Patch_Contents(Current_Patch) = ""
                    End Select
                Else
                    With Code_Range
                        End_Row = Last_Row
                        For b = a + 1 To Last_Row
                            If .Cells(b, 1).Value2 = "PATCH" Then
                                End_Row = b - 1
                                Exit For
                            End If
                        Next b
                    End With
                End If
            Case "DESCRIPTION"
                Select Case Save_Type
                    Case Save_XML
                        Description_String = Code_Range.Cells(a, 2).Value2
                        Row_Count = Code_String_Row_Length(Code_Range, a, Last_Row)
                        For b = a + 1 To a + Row_Count
                            Description_String = Description_String & vbCrLf & Code_Range.Cells(b, 2).Value2
                        Next b
                        Description_String = vbCrLf & XML_Indent_2 & "<Description>" & XMLize(Description_String, XML_crlf) & "</Description>"
                        Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & Description_String
                End Select
            Case "COMMENT"
                Select Case Save_Type
                    Case Save_XML
                        Row_Count = Code_String_Row_Length(Code_Range, a, Last_Row)
                        If Row_Count = 0 Then
                            Comment_String = crlf_Separation & XML_Indent_2 & "<!-- " & Code_Range.Cells(a, 2).Value2 & " -->"
                        Else
                            Comment_String = crlf_Separation & XML_Indent_2 & "<!--" & vbCrLf & XML_Indent_3 & Code_Range.Cells(a, 2).Value2
                            For b = a + 1 To a + Row_Count
                                Comment_String = Comment_String & vbCrLf & XML_Indent_3 & Code_Range.Cells(b, 2).Value2
                            Next b
                            Comment_String = Comment_String & vbCrLf & XML_Indent_2 & " -->"
                        End If
                        Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & Comment_String
                End Select
            Case "MEMLOCATION", "MEMLOCATION-1", "MEMLOCATION-2", "MEMLOCATION-3", "MEMLOCATION-4", "LOCATION", "MEMVARIABLE", "VARIABLE"
                Select Case New_Type
                    Case "MEMLOCATION", "MEMLOCATION-1", "MEMLOCATION-2", "LOCATION"
                        Select Case New_Type
                            Case "MEMLOCATION", "MEMLOCATION-1", "MEMLOCATION-2"
                                Select Case New_Type
                                    Case "MEMLOCATION": Memory = True: Trim_Location = 0
                                    Case "MEMLOCATION-1": Memory = True: Trim_Location = 1
                                    Case "MEMLOCATION-2": Memory = True: Trim_Location = 2
                                    Case "MEMLOCATION-3": Memory = True: Trim_Location = 3
                                    Case "MEMLOCATION-4": Memory = True: Trim_Location = 4
                                End Select
                                Patch_Memory(Patch_Row) = True
                            Case "LOCATION"
                                Memory = False: Trim_Location = 0
                        End Select
                        Location_End = Last_Row
                        With Code_Range
                            For b = a + 1 To Last_Row
                                If Len(.Cells(b, 1).Value2) Then
                                    Location_End = b - 1
                                    Exit For
                                End If
                            Next b
                            Line_Count = Location_End - Start_Row + 1
                            For b = a + Line_Count - 1 To a Step -1
                                If Len(.Cells(b, 5).Value2) = 0 Then
                                    Line_Count = Line_Count - 1
                                Else
                                    Exit For
                                End If
                            Next b
                        End With
                        Variable = False
                    Case "MEMVARIABLE", "VARIABLE"
                        Line_Count = 1
                        Trim_Location = 0
                        Select Case New_Type
                            Case "MEMVARIABLE"
                                Memory = True
                                Patch_Memory(Patch_Row) = True
                            Case "VARIABLE"
                                Memory = False
                        End Select
                        Variable = True
                End Select
                With Code_Range
                    Location_String = .Cells(Start_Row, 2).Value2
                    Location_File = .Cells(Start_Row, 3).Value2
                    File_ID = GetFileMatch(Location_File, True, True, True)
                    If File_ID = -1 Then
                        Sector = -1
                        If Len(Location_File) >= 3 Then
                            If Left(Location_File, 1) = "[" And Right(Location_File, 1) = "]" Then
                                Sector = Mid(Location_File, 2, Len(Location_File) - 2)
                            End If
                        End If
                        If Sector = -1 Then
                            Call MsgBox("Unknown file """ & Location_File & """.", vbCritical, "Fatal Error")
                            Exit Sub
                        End If
                    End If
                    If File_ID > -1 Then
                        File_String = "file=""" & File_XML_Names(File_ID) & """"
                        File_Offset = File_Offsets(File_ID)
                    Else
                        File_String = "sector=""" & Hex(Sector) & """"
                        File_Offset = 0
                    End If
                    Address_String = .Cells(Start_Row, 4).Value2
                    If Len(Address_String) Then
                        Address_Long = HexToDec(Right(Address_String, 6))
                        If Memory Then
                            Address_File = Address_Long - File_Offset
                        Else
                            Address_File = Address_Long
                        End If
                        Address_File = Address_File + Location_Trim
                    End If
                    If Variable Then
                        Select Case Save_Type
                            Case Save_ISO, Save_Savestate
                                If Memory Then
                                    Patch_Files(Patch_Row) = File_ID
                                    Patch_Sectors(Patch_Row) = Sector
                                    Patch_Offsets(Patch_Row) = Address_Long
                                    Patch_Data(Patch_Row) = ReverseBytes(.Cells(Start_Row, 5))
                                    Patch_Row = Patch_Row + 1
                                End If
                            Case Save_XML
                                Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & vbCrLf & XML_Indent_2 & "<Variable name=""" & Location_String & """ " & File_String & " offset=""" & Hex(Address_File) & """ default=""" & CStr(.Cells(a, 5).Value2) & """"
                                Byte_Length = Int(Len(.Cells(Start_Row, 5)) / 2)
                                If Byte_Length > 1 Then Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & " bytes=""" & CStr(Byte_Length) & """"
                                Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & " />"
                        End Select
                    Else
                        Select Case Save_Type
                            Case Save_ISO, Save_Savestate
                                If Not Memory And Save_Type = Save_Savestate Then GoTo DoNotParse
                                Patch_Files(Patch_Row) = File_ID
                                Patch_Sectors(Patch_Row) = Sector
                                Patch_Offsets(Patch_Row) = Address_Long + Trim_Location
                            Case Save_XML
                                Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & vbCrLf & XML_Indent_2 & "<Location "
                                If File_ID > -1 Then
                                    Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & "file=""" & File_XML_Names(File_ID) & """ offset="""
                                ElseIf Sector > -1 Then
                                    Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & "sector=""" & Hex(Sector) & """ offset="""
                                End If
                        End Select
                        Current_Opcode = Replace_Variables(CStr(.Cells(a, 5).Value2))
                        If Save_Type = Save_XML And Line_Count = 1 And Len(.Cells(b, 4).Value2) And IsHex(Current_Opcode) And Len(Replace(Current_Opcode, " ", "")) <= 32 Then
                            If Len(.Cells(b, 7).Value2) Then
                                Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & Hex(Address_File) & """>" & Current_Opcode & "<!--" & .Cells(b, 7).Value2 & "--></Location>"
                            Else
                                Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & Hex(Address_File) & """>" & Current_Opcode & "</Location>"
                            End If
                        Else
                            If Save_Type = Save_XML Then Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & Hex(Address_File + Trim_Location) & """>"
                            For b = a To a + Line_Count - 1
                                Address_String = .Cells(b, 4).Value2
                                If Len(Address_String) Then
                                    Current_Opcode = Replace_Variables(CStr(.Cells(b, 5).Value2))
                                    If IsHex(Current_Opcode) Then
                                        If Len(Current_Opcode) = Len(Replace(Current_Opcode, " ", "")) And Len(Current_Opcode) = 8 Then
                                            Current_Opcode = Mid(Current_Opcode, 1, 2) & " " & Mid(Current_Opcode, 3, 2) & " " & Mid(Current_Opcode, 5, 2) & " " & Mid(Current_Opcode, 7, 2)
                                        End If
                                    Else
                                        Address_Long = HexToDec(Right(Address_String, 6))
                                        Current_Opcode = Encode(Current_Opcode, Address_Long)
                                        If b = a And Trim_Location > 0 Then Current_Opcode = Mid(Current_Opcode, 1 + Trim_Location * 2)
                                    End If
                                    Select Case Save_Type
                                        Case Save_ISO, Save_Savestate
                                            Patch_Data(Patch_Row) = Patch_Data(Patch_Row) & Current_Opcode
                                        Case Save_XML
                                            Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & vbCrLf & XML_Indent_3 & Current_Opcode
                                            If Len(.Cells(b, 7).Value2) Then Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & XML_Indent_1 & "<!-- " & .Cells(b, 7).Value2 & " -->"
                                    End Select
                                End If
                            Next b
                            Select Case Save_Type
                                Case Save_XML: Patch_Contents(Current_Patch) = Patch_Contents(Current_Patch) & vbCrLf & XML_Indent_2 & "</Location>"
                                Case Save_ISO, Save_Savestate: Patch_Row = Patch_Row + 1
                            End Select
                        End If
DoNotParse:
                    End If
                End With
        End Select
        a = End_Row + 1
    Loop
    If Save_Type = Save_XML And Current_Patch = 0 Then
        If MsgBox("No hacks were found to save." & vbCrLf & "Would you like to run the routine ""Update Hack List"" and try again?", vbYesNo) = vbYes Then Call UpdateHackList: GoTo Start_Over
        VBATime False
        Exit Sub
    End If
    
    Dim fnum As Integer
    Select Case Save_Type
        Case Save_ISO
            fnum = Open_ISO
            If fnum = -1 Then Exit Sub
            Dim Match_ID As Long
            Dim Write_Bytes() As Byte
            Dim Byte_Count As Long
            Dim Write_Offset As Long
            For a = 0 To Patch_Row - 1
                If Patch_Files(a) > -1 Or Patch_Sectors(a) > -1 Then
                    Patch_Data(a) = Replace(Patch_Data(a), " ", "")
                    Byte_Count = Int(Len(Patch_Data(a)) / 2)
                    ReDim Write_Bytes(0 To Byte_Count - 1)
                    For b = 0 To Byte_Count - 1
                        Write_Bytes(b) = "&H0" & Mid(Patch_Data(a), 1 + b * 2, 2)
                    Next b
                    Write_Offset = Patch_Offsets(a)
                    If Patch_Files(a) > -1 Then
                        If Patch_Memory(a) Then Write_Offset = Write_Offset - File_Offsets(Patch_Files(a))
                        Call Save_File_Data(File_Sectors(Patch_Files(a)), Write_Offset, Write_Bytes, fnum)
                    Else
                        Call Save_File_Data(Patch_Sectors(a), Write_Offset, Write_Bytes, fnum)
                    End If
                End If
            Next a
            Close #fnum
        Case Save_XML
            For a = 1 To Current_Patch
                Patch_Contents(a) = XML_Indent_1 & "<Patch name=""" & XMLize(Patch_Names(a)) & """>" & Patch_Contents(a) & vbCrLf & XML_Indent_1 & "</Patch>"
            Next a
            ReDim Preserve Patch_Contents(1 To Current_Patch)
            ReDim Preserve Patch_Names(1 To Current_Patch)
            Select Case XML_Output
                Case 0: 'Copy xml to clipboard
                    Current_XML = XML_Start & Join(Patch_Contents, vbCrLf & vbCrLf & vbCrLf) & XML_End
                    Dim MSForms_DataObject As Object
                    Set MSForms_DataObject = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
                    MSForms_DataObject.SetText Current_XML
                    MSForms_DataObject.PutInClipboard
                    Set MSForms_DataObject = Nothing
                Case 1, 2: 'Update & Create new xml
                    Dim RegPath As String
                    Dim FilePath As String
                    Dim FolderFromPath As String
                    
                    RegPath = RegFolder & "Last XML"
                    FilePath = ReadReg(RegPath, ActiveWorkbook.path)
                    If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
                    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
                    If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
                    Select Case XML_Output
                        Case 1: FilePath = Application.GetOpenFilename(FileFilter:="FFTOrgASM File (*.xml), *.xml", Title:="Select an XML file", MultiSelect:=False)
                        Case 2: FilePath = Application.GetSaveAsFilename(FileFilter:="FFTOrgASM File (*.xml), *.xml", Title:="Choose a Filename")
                    End Select
                    If FilePath = "False" Then VBATime False: Exit Sub
                    Call WriteReg(RegPath, FilePath)
                    
                    Dim objStream
                    Set objStream = CreateObject("ADODB.Stream")
                    objStream.Charset = "utf-8"
                    objStream.Open
                    
                    Select Case XML_Output
                        Case 1:
                            Dim XML_Data As String
                            Dim Old_Patches() As String, New_Patches() As String, New_Contents() As String
                            Dim Patch_Count As Long, Total_Patch_Count As Long
                            Dim Patch_Start, Line_Start As Long
                            Dim Patch_Begins As Long
                            Dim Sort_Alphabetically As Boolean
                            Dim Patch_Found As Boolean
                            Dim Patch_Indent As String
                            If MsgBox("Do you wish to sort and insert the hacks alphabetically in this xml?", vbYesNo) = vbYes Then Sort_Alphabetically = True
                            objStream.LoadFromFile (FilePath)
                            XML_Data = objStream.ReadText()
                            Dim Patches As XML_Level, Patch As XML_Level
                            Patches = Get_XML_Tags(XML_Data)
                            For a = LBound(Patches.XML_Entry) To UBound(Patches.XML_Entry)
                                If LCase(Patches.XML_Entry(a).Name) = "patches" Then
                                    Patch = Get_XML_Tags(Patches.XML_Entry(a).Contents)
                                    ReDim Old_Patches(LBound(Patch.XML_Entry) To UBound(Patch.XML_Entry))
                                    For b = LBound(Patch.XML_Entry) To UBound(Patch.XML_Entry)
                                        If LCase(Patch.XML_Entry(b).Name) = "patch" Then
                                            Old_Patches(b) = Get_XML_Parameters(Patch.XML_Entry(b), "name")
                                            If Not Patch_Found Then
                                                Patch_Begins = InStr(1, XML_Data, Patch.XML_Entry(b).Open_Tag)
                                                For c = Patch_Begins - 1 To 1 Step -1
                                                    Select Case Mid(XML_Data, c, 1)
                                                        Case " ", vbTab
                                                            Patch_Indent = Mid(XML_Data, c, 1) & Patch_Indent
                                                        Case Else
                                                            Exit For
                                                    End Select
                                                Next c
                                                Patch_Found = True
                                            End If
                                        ElseIf Patch.XML_Entry(b).Name = "!==" Then
                                            Old_Patches(b) = Chr(0)
                                        End If
                                    Next b
                                End If
                            Next a
                            If Not Patch_Found Then Patch_Indent = XML_Indent_1
                            
                            Total_Patch_Count = UBound(Old_Patches) - LBound(Old_Patches) + 1 + UBound(Patch.XML_Entry) - LBound(Patch.XML_Entry) + 1
                            ReDim New_Patches(0 To Total_Patch_Count - 1)
                            ReDim New_Contents(0 To Total_Patch_Count - 1)
                            If Sort_Alphabetically Then
                                For a = LBound(Patch_Names) To UBound(Patch_Names)
                                    New_Patches(Patch_Count) = Patch_Names(a)
                                    New_Contents(Patch_Count) = Patch_Contents(a)
                                    Patch_Count = Patch_Count + 1
                                Next a
                                For a = LBound(Old_Patches) To UBound(Old_Patches)
                                    New_Patches(Patch_Count) = Old_Patches(a)
                                    New_Contents(Patch_Count) = Patch_Indent & Patch.XML_Entry(a).Open_Tag & Patch.XML_Entry(a).Contents & Patch.XML_Entry(a).Close_Tag
                                    Patch_Count = Patch_Count + 1
                                Next a
                                Dim Sort_Index As Variant
                                Sort_Index = Create_Sort_Index(New_Patches, 1, False, True, True)
                                New_Patches = Sort_Array(New_Patches, Sort_Index)
                                New_Contents = Sort_Array(New_Contents, Sort_Index)
                            Else
                                For a = LBound(Old_Patches) To UBound(Old_Patches)
                                    New_Patches(Patch_Count) = Old_Patches(a)
                                    New_Contents(Patch_Count) = Patch_Indent & Patch.XML_Entry(a).Open_Tag & Patch.XML_Entry(a).Contents & Patch.XML_Entry(a).Close_Tag
                                    Patch_Count = Patch_Count + 1
                                Next a
                                Dim Match_Found As Boolean
                                For a = LBound(Patch_Names) To UBound(Patch_Names)
                                    Match_Found = False
                                    For b = LBound(Old_Patches) To UBound(Old_Patches)
                                        If Old_Patches(b) = Patch_Names(a) Then
                                            New_Patches(b) = Patch_Names(a)
                                            New_Contents(b) = Patch_Contents(a)
                                            Match_Found = True
                                            Exit For
                                        End If
                                    Next b
                                    If Not Match_Found Then
                                        New_Patches(Patch_Count) = Patch_Names(a)
                                        New_Contents(Patch_Count) = Patch_Contents(a)
                                        Patch_Count = Patch_Count + 1
                                    End If
                                Next a
                                ReDim Preserve New_Patches(0 To Patch_Count - 1)
                                ReDim Preserve New_Contents(0 To Patch_Count - 1)
                            End If
                            Current_XML = "<?xml version=""1.0"" encoding=""utf-8"" ?>" & vbCrLf & vbCrLf & "<Patches>" & vbCrLf & vbCrLf & Join(New_Contents, vbCrLf & vbCrLf) & vbCrLf & vbCrLf & "</Patches>"
                            
                            Dim objStreamWrite
                            Set objStreamWrite = CreateObject("ADODB.Stream")
                            objStreamWrite.Charset = "utf-8"
                            objStreamWrite.Open
                            objStreamWrite.WriteText Current_XML
                            objStreamWrite.SaveToFile FilePath, 2
                            objStreamWrite.Close
                            objStream.Close
                        Case 2:
                            Current_XML = "<?xml version=""1.0"" encoding=""utf-8"" ?>" & vbCrLf & vbCrLf & "<Patches>" & vbCrLf & vbCrLf & Join(Patch_Contents, vbCrLf & vbCrLf) & vbCrLf & vbCrLf & "</Patches>"
                            objStream.WriteText Current_XML
                            objStream.SaveToFile FilePath, 2
                            objStream.Close
                    End Select
            End Select
        Case Save_Savestate
            Dim i As Integer
            Dim Loc67000 As Long, LocE0000 As Long, Loc1BF000 As Long, Loc1BF018 As Long, Loc1DF000 As Long, LocRAM As Long
            Dim FileCounter As Integer
            Dim FileTotal As Integer
            Dim Location As Integer
            Dim PasteFile As String
            Dim PasteAddress As Long
            Dim PasteRange As String
            Dim FileAllowed As Boolean
            Dim Element As Variant
            Dim Pos As Long
            Dim BytesArr(65536) As Byte
            Dim OutputArr() As Byte
            'Code here
            Dim ByteCell As Byte
            Dim ByteCellContent As String
            Dim ByteCellLen As Integer
            Dim CellPos As Integer
            Dim BytesPos As Long
            Dim PressKey As String
            Dim QuicksaveID As Byte
            Dim QuicksaveAuto As String
            Dim ByteString As String
            Dim ByteCount As Long
            Dim Savestate_Offset As Long
            Dim Savestate_Files As Variant
            Dim FileCount As Long
            Dim FileCheck As String
            Dim f As Long
            
            FilePath = ReadReg(RegFolder & "Last quicksave", "")
            If FilePath = "" Then
                MsgBox "Please select a Quicksave file first.", vbOKOnly, "Error"
                Exit Sub
            End If
            
            BytesPos = 0
            FileCounter = 0
            FileTotal = 0
            
            fnum = FreeFile
            Open FilePath For Binary As #fnum
            Savestate_Offset = Get_Savestate_Offset(fnum)
            If Savestate_Offset = 0 Then
                MsgBox "Unable to identify file offsets"
                Exit Sub
            End If
            
            Savestate_Files = Get_Savestate_Files(fnum, Savestate_Offset)
            FileCount = UBound(Savestate_Files)
        
            For Location = 0 To Patch_Row - 1
                FileAllowed = False
                FileTotal = FileTotal + 1
                FileCheck = File_Names(Patch_Files(Location))
                For f = 0 To FileCount
                    If FileCheck = Savestate_Files(f) Then
                        FileAllowed = True
                        Exit For
                    End If
                Next f
                If FileAllowed Then
                    FileCounter = FileCounter + 1
                    Erase OutputArr
                    BytesPos = 0
                    ByteString = Replace(Patch_Data(Location), " ", "")
                    ByteCount = Int((Len(ByteString) + 1) / 2)
                    If ByteCount Then
                        ReDim OutputArr(0 To ByteCount - 1)
                        For a = 0 To ByteCount - 1
                            OutputArr(a) = CInt("&H" & Mid(ByteString, 1 + 2 * a, 2))
                        Next a
                        Put #fnum, Patch_Offsets(Location) + Savestate_Offset + 1, OutputArr
                    End If
                End If
            Next Location
                If ReadReg(RegFolder & "Debug Quicksave", 0) Then
                MsgBox FileCounter & "/" & FileTotal & " sections saved to " & FilePath
            End If
            Close fnum
            If ReadReg(RegFolder & "pSX Focus", 1) Then
                If ReadReg(RegFolder & "Restore Debugger", 0) Then
                    On Error GoTo TrypSX
                    AppActivate "r3000 debugger", False
                    'Application.SendKeys "% ~", True
                End If
TrypSX:
                On Error GoTo SubEnd
                AppActivate "pSX v1.13", False
                'Application.SendKeys "% ~", True
                QuicksaveID = ReadReg(RegFolder & "Quicksave ID", 1, QuickIDMax)
                Select Case QuicksaveID
                    Case 0:
                        Exit Sub
                    Case 1:
                        QuicksaveAuto = Left(Right(FilePath, 5), 1)
                        Select Case QuicksaveAuto
                            Case "1", "2", "3", "4", "5":
                                PressKey = "{F" & QuicksaveAuto & "}"
                            Case Else:
                                Exit Sub
                        End Select
                    Case 2, 3, 4, 5, 6:
                        PressKey = "{F" & QuicksaveID - 1 & "}"
                End Select
                Application.SendKeys PressKey
            End If
SubEnd:
        Case 255:
    End Select
    Erase Patches.XML_Entry
    Erase Patch.XML_Entry
    VBATime False
End Sub

Public Function Get_Savestate_Offset(Quicksave_File As Integer) As Long
    Dim LocRAM(0 To 0) As Long
    Dim a As Long
    For a = &H2A4 To &H3B4 Step 16
        Get Quicksave_File, a + 1, LocRAM
        If LocRAM(0) = 5062994 Then
            Get_Savestate_Offset = a + 12
            Exit For
        End If
    Next a
End Function
Public Function Get_XML_Parameter(Tag_Parameters As String, Parameter_Name As String, Optional Start As Long = 1) As String
    Dim Start_Pos, End_Pos As Long
    Dim Search_Parameter As String
    Dim Temp_Parameters As String
    Temp_Parameters = Replace(Replace(Replace(Tag_Parameters, " =""", "="""), "= """, "="""), " =""", "=""")
    Get_XML_Parameter = ""
    Search_Parameter = Parameter_Name & "="""
    Start_Pos = InStr(Start, Temp_Parameters, Search_Parameter)
    If Start_Pos Then
        Start_Pos = Start_Pos + Len(Search_Parameter)
        End_Pos = InStr(Start_Pos, Temp_Parameters, """")
        If End_Pos Then Get_XML_Parameter = DeXMLize(Mid(Temp_Parameters, Start_Pos, End_Pos - Start_Pos))
    End If
End Function

Public Function Code_String_Row_Length(Code_Range As Range, Start_Row As Long, Last_Row As Long) As Long
    Dim Max_Row, a, b As Long
    Code_String_Row_Length = 0
    For a = Start_Row + 1 To Last_Row
        If Code_Range.Cells(a, 1).Value2 <> "" Then
            Max_Row = a - 1
            Exit For
        End If
    Next a
    For a = Start_Row To Max_Row
        If Code_Range.Cells(Max_Row - a + Start_Row, 2).Value2 <> "" Then
            Code_String_Row_Length = Max_Row - a
            Exit For
        End If
    Next a
End Function

Public Function XMLize(Some_String As String, Optional XMLcrlf As Boolean = False) As String
    XMLize = Replace(Replace(Replace(Replace(Some_String, "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), """", "&quot;")
    If XMLcrlf Then XMLize = Replace(XMLize, vbCrLf, "&#13;&#10;")
End Function

Public Function DeXMLize(Some_String As String) As String
    Dim String_Pos As Long
    Dim Char_Start, Char_End As Long
    Dim Char_String As String
    Dim Char_Value As Long
    If Len(Some_String) = 0 Then
        DeXMLize = ""
        Exit Function
    End If
    DeXMLize = Replace(Replace(Replace(Replace(Some_String, "&quot;", """"), "&lt;", "<"), "&gt;", ">"), "&amp;", "&")
    String_Pos = Len(DeXMLize)
    Do
        Char_Start = InStr(1, DeXMLize, "&#")
        Char_Start = InStrRev(DeXMLize, "&#", String_Pos)
        If Char_Start > 0 Then
            Char_End = InStr(Char_Start + 2, DeXMLize, ";")
            If Char_End > 0 Then
                Char_String = Mid(DeXMLize, Char_Start + 2, Char_End - Char_Start - 2)
                If Left(Char_String, 1) = "x" Then
                    Char_Value = HexToDec(Right(Char_String, Len(Char_String) - 1))
                Else
                    Char_Value = CLng(Char_String)
                End If
                DeXMLize = Left(DeXMLize, Char_Start - 1) & ChrW(Char_Value) & Right(DeXMLize, Len(DeXMLize) - Char_End)
                String_Pos = Char_Start
            Else
                String_Pos = String_Pos - 1
                If String_Pos = 0 Then Exit Do
            End If
        Else
            Exit Do
        End If
    Loop
    DeXMLize = Replace(DeXMLize, "&amp;", "&")
End Function

Public Function Open_ISO() As Integer
    Dim FilePath As String
    Dim RegPath As String
    Dim AutoSelect As Boolean
    Dim FolderFromPath As String
    Open_ISO = FreeFile
    RegPath = RegFolder & "Last ISO"
    FilePath = ReadReg(RegPath, "")
    AutoSelect = ReadReg(RegFolder & "Auto Select Last ISO", False)
    If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
    If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
    If AutoSelect And Not (FilePath = "False" Or FilePath = "0") Then GoTo Success
    FilePath = Application.GetOpenFilename(FileFilter:="M2/2352 PSX Image (*.bin;*.img;*.iso), *.bin;*.img;*.iso", Title:="Select a PSX Image", MultiSelect:=False)
    If FilePath = "False" Or FilePath = "0" Then GoTo Failure
    Call WriteReg(RegPath, FilePath)
Success:
    Open FilePath For Binary As #Open_ISO
    Exit Function
Failure:
    Open_ISO = -1
End Function

Public Function ReadReg(RegPath As String, Default As Variant, Optional HighestValue As Long = 1) As Variant
    Dim myWS As Object
    On Error GoTo ErrorHandler
    Set myWS = CreateObject("WScript.Shell")
    ReadReg = myWS.RegRead(RegPath)
    If IsNumeric(ReadReg) Then
        If ReadReg < 0 Or ReadReg > HighestValue Then
            GoTo ErrorHandler
        End If
    End If
    Exit Function
  
ErrorHandler:
    ReadReg = Default
End Function

Public Sub WriteReg(RegPath As String, RegVal As String, Optional RegType As Register_Value_Type = REG_SZ)
    Dim RegTypeString As String
    Dim myWS As Object
    Set myWS = CreateObject("WScript.Shell")
    If RegVal = "True" Then
        RegVal = "1"
    ElseIf RegVal = "False" Then
        RegVal = "0"
    End If
    Select Case RegType
        Case REG_SZ: RegTypeString = "REG_SZ"
        Case REG_BINARY: RegTypeString = "REG_BINARY"
        Case REG_DWORD: RegTypeString = "REG_DWORD"
        Case REG_QWORD: RegTypeString = "REG_QWORD"
        Case REG_MULTI_SZ: RegTypeString = "REG_MULTI_SZ"
        Case REG_EXPAND_SZ: RegTypeString = "REG_EXPAND_SZ"
    End Select
    myWS.RegWrite RegPath, RegVal, RegTypeString
End Sub

Public Sub Config()
    configuration.Show False
End Sub

Public Function GetXMLLastRow() As Integer
    Dim i As Integer
    GetXMLLastRow = 3
    With Worksheets(".xml")
        For i = .Range("M65535").End(xlUp).Row To 1 Step -1
            If Len(.Cells(i, 13)) Then
                GetXMLLastRow = i
                Exit For
            End If
        Next i
    End With
End Function

Public Function UpperAddress(BaseAddress As String) As String
    Dim Lower As Long
    Dim AddIt As Byte
    Lower = ("&H" & Right(BaseAddress, 4)) + 0
    If Lower >= 32768 Then
        AddIt = 1
    Else
        AddIt = 0
    End If
    UpperAddress = "0x80" & UCase(Right("00" & Hex(("&H" & Left(Right(BaseAddress, 6), 2)) + AddIt), 2))
End Function

Public Function LowerAddress(BaseAddress As String, Optional Signed As Boolean = False) As String
    Dim Hex As String
    If Signed Then
        Dim Dec As Long
        Dec = HexToDec(Right(BaseAddress, 4))
        If Dec > 32767 Then
            Hex = "-0x" & UCase(DecToHex(65536 - Dec, 4))
        Else
            Hex = "0x" & UCase(Right(BaseAddress, 4))
        End If
    Else
        Hex = "0x" & UCase(Right(BaseAddress, 4))
    End If
    LowerAddress = Hex
End Function

Public Function ReverseBytes(ByteString As String, Optional ByteLen As Long = 0) As String
    Dim RealByteLen As Long
    Dim PaddedString As String
    Dim i As Long
    RealByteLen = Application.WorksheetFunction.RoundUp(Len(ByteString) / 2, 0)
    If ByteLen > RealByteLen Then
        RealByteLen = ByteLen
    End If
    PaddedString = ByteString
    For i = Len(ByteString) + 1 To RealByteLen * 2
        PaddedString = "0" & PaddedString
    Next i
    ReverseBytes = ""
    For i = 0 To RealByteLen - 1
        ReverseBytes = Mid(PaddedString, i * 2 + 1, 2) & ReverseBytes
    Next i
End Function

Public Function ClosedWorkbookData(wbPath As String, wbName As String, RangeRef As String) As String
    Dim Ret As String
    Dim SplitString As Integer
    SplitString = InStr(1, RangeRef, "!")
    Ret = "'" & wbPath & "[" & wbName & "]" & _
          Replace(Left(RangeRef, SplitString - 1), "'", "") & "'!" & Range(Right(RangeRef, Len(RangeRef) - SplitString)).Address(True, True, -4150)

   ClosedWorkbookData = ExecuteExcel4Macro(Ret)
End Function

Public Sub GetWorkbookData(PasteRange As String, TargetPath As String, TargetWorkbook As String, TargetStartRow As Integer, TargetCol As Long, Optional IDRange As String = "")
    Dim EntryNum As Integer, StartRow As Integer, EndRow As Integer, StartCol As Integer
    Dim i As Integer, a As Integer, FindCount As Integer
    Dim BS As String, SS As String, DS As String, BE As Long, ParseString As String, CurrentEntry As String, LEntry As String
    Dim OriginalEntries() As Variant
    Dim EntryArray() As Variant
    BS = ReadReg(RegFolder & "Blank String Format", BSFormat)
    SS = ReadReg(RegFolder & "Single String Format", SSFormat)
    DS = ReadReg(RegFolder & "Duplicate String Format", DSFormat)
    BE = ReadReg(RegFolder & "Empty Blank", 1)
    EntryNum = Range(PasteRange).Rows.Count
    StartRow = Range(PasteRange).Row
    EndRow = StartRow + EntryNum - 1
    StartCol = Range(PasteRange).Column
    With Range(PasteRange)
        .NumberFormat = "General"
        .FormulaR1C1 = "='" & TargetPath & "[" & TargetWorkbook & "]" & "FFTText" & "'!" & "R[" & TargetStartRow + 16 - StartRow & "]C" & TargetCol
    End With
    ReDim EntryArray(EntryNum)
    With Range(PasteRange).Parent.Name
        For i = 0 To EntryNum - 1
            EntryArray(i) = Range(PasteRange).Cells(i + 1, 1).Text
        Next i
        OriginalEntries = EntryArray
        For i = 0 To EntryNum - 1
            With Range(PasteRange).Cells(i + 1, 1)
                If IDRange <> "" Then
                    CurrentEntry = OriginalEntries(i)
                    If Len(CurrentEntry) = 0 Then
                        'If BE = 1 And i = 0 And TargetStartRow = 0 Then
                        '    ParseString = ""
                        'Else
                            ParseString = BS
                        'End If
                    Else
                        FindCount = 0
                        LEntry = LCase(CurrentEntry)
                        For a = 0 To EntryNum - 1
                            If LCase(OriginalEntries(a)) = LEntry Then FindCount = FindCount + 1
                        Next a
                        If FindCount > 1 Then
                            ParseString = DS
                        Else
                            ParseString = SS
                        End If
                    End If
                    EntryArray(i) = Replace(Replace(ParseString, "$", CurrentEntry, , 1), "#", Range(IDRange).Cells(i + 1, 1).Text, , 1)
                End If
            End With
        Next i
        PasteStrings PasteRange, EntryArray
    End With
End Sub

Public Function GetFFTText() As String
    Dim SearchCurrent As Boolean, Prompt As Boolean
    Dim RegPath As String, FilePath As String, FolderFromPath As String
    Select Case ReadReg(RegFolder & "Text Ripping Method", 1, TextRipMax)
        Case 0
            SearchCurrent = True
            Prompt = False
        Case 1
            SearchCurrent = True
            Prompt = True
        Case 2
            SearchCurrent = False
            Prompt = True
    End Select
    If SearchCurrent Then
        GetFFTText = ActiveWorkbook.path & "\" & FFTTextEditorFilename
        If Len(Dir(GetFFTText)) Then Exit Function
        If Not Prompt Then
            MsgBox GetFFTText & " does not exist.", vbOKOnly, "Error"
        End If
    End If
    If Prompt Then
        RegPath = RegFolder & "Last FFTText Editor"
        FilePath = ReadReg(RegPath, "")
        If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
        FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
        If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
        GetFFTText = Application.GetOpenFilename(FileFilter:="FFTText Editor (*.xlsm), *.xlsm", Title:="Select a FFTText Editor Workbook", MultiSelect:=False)
        If GetFFTText = "0" Or GetFFTText = "False" Then
            GetFFTText = ""
            Exit Function
        End If
        Call WriteReg(RegPath, GetFFTText)
    End If
End Function

Public Sub InsertCodeLines()
    VBATime
    Dim CurrentRow As Long, RowNumber As Long, BottomRow As Long, test As Variant
    CurrentRow = Selection.Row
    RowNumber = Selection.Rows.Count
    
    If RowNumber = 1 Then
RetryInput:
        test = InputBox("How many lines would you like to insert above?", "Insert Lines", "1")
        If IsNumeric(test) Then
            RowNumber = test
        ElseIf test = "" Then
            Exit Sub
        Else
            If MsgBox("Not a number", vbRetryCancel, "Error") = vbRetry Then
                GoTo RetryInput
            Else
                Exit Sub
            End If
        End If
    End If
    BottomRow = CurrentRow + RowNumber - 1
    With Code_Sheet
        .Rows(CurrentRow & ":" & BottomRow).Insert Shift:=xlDown, _
          CopyOrigin:=xlFormatFromLeftOrAbove
        .Range(.Cells(CurrentRow, 1), .Cells(BottomRow, 1)).Formula = "=""0x80""&DEC2HEX(4+HEX2DEC(RIGHT(INDEX(A:A,ROW()-1),6)),6)"
        .Range(.Cells(CurrentRow, 2), .Cells(BottomRow, 2)).Value = "nop"
        .Range(.Cells(CurrentRow, 3), .Cells(BottomRow, 3)).Formula = "=INDEX('Compile Sheet'!$CF:$CF,ROW())"
        .Range(.Cells(CurrentRow, 1), .Cells(BottomRow, 2)).Interior.color = xlNone
    End With
    VBATime False
End Sub


Public Sub VBATimeButtonON()
    VBATime
End Sub

Public Sub VBATimeButtonOFF()
    VBATime False
End Sub

Public Sub PasteStrings(PasteRange As String, EntryArray As Variant)
    Dim i As Integer
    With Range(PasteRange)
        .NumberFormat = "@"
        For i = 0 To UBound(EntryArray) - 1
            .Cells(i + 1, 1).Value2 = EntryArray(i)
        Next i
        .Copy _
                Destination:=Range(PasteRange)
        .NumberFormat = "General"
    End With
End Sub

Public Function RangeAddress(ParamArray SelectRange() As Variant) As String
    Dim i As Integer
    RangeAddress = ""
    For i = LBound(SelectRange) To UBound(SelectRange)
        SelectRange(i) = "'" & SelectRange(i).Parent.Name & "'!" & SelectRange(i).Address(External:=False)
    Next i
    RangeAddress = Join(SelectRange, ",")
End Function

Public Sub LoadFFTText()
    VBATime
    Calculate
    Dim LastRow As Long
    Dim ArrayNames() As Variant
    Dim ArrayStrings() As Variant
    Dim GetIndexCount As Long
    Dim FetchColumn As Long
    Dim TargetPath As String, TargetFolder As String, TargetFile As String
    Dim rCell As Range, rRng As Range
    Dim ReturnSheet As String
    Dim Update As Boolean
    Dim DecimalArray() As String
    Dim PreviousSelection As Range
    Dim a As Long
    Dim FFTText_Table As ListObject
    Set FFTText_Table = FFTText_Sheet.ListObjects("FFTTextTable")
    Dim FFTText_Cols(1 To 5) As Range
    Set FFTText_Cols(1) = FFTText_Table.ListColumns("Function").DataBodyRange
    For a = 1 To 4
        Set FFTText_Cols(1 + a) = FFTText_Table.ListColumns("Parameter " & a).DataBodyRange
    Next a
    ReturnSheet = ActiveSheet.Name
    TargetPath = GetFFTText
    If TargetPath = "" Then GoTo SubEnd
    TargetFile = Right(TargetPath, Len(TargetPath) - InStrRev(TargetPath, "\"))
    TargetFolder = Left(TargetPath, InStrRev(TargetPath, "\"))
    If Len(Dir(TargetFolder & TargetFile)) Then
        Update = False
        GetIndexCount = 0
        Dim i As Long
        LastRow = FFTText_Table.ListRows.Count
        For i = 1 To LastRow
            Select Case FFTText_Cols(1)(i).Value2
                Case "GetIndex"
                    GetIndexCount = GetIndexCount + 1
                    ReDim Preserve ArrayNames(GetIndexCount)
                    ReDim Preserve ArrayStrings(GetIndexCount)
                    ArrayNames(GetIndexCount) = FFTText_Cols(3)(i).Value2
                    ArrayStrings(GetIndexCount) = Join(Application.Transpose(Range(FFTText_Cols(2)(i).Value2).Value2), Chr(20))
                Case "GetFFTText"
                    FetchColumn = ClosedWorkbookData(TargetFolder, TargetFile, FFTText_Cols(3)(i).Value2)
                    GetWorkbookData FFTText_Cols(2)(i).Value2, TargetFolder, TargetFile, ("&H0" & FFTText_Cols(4)(i).Value2), FetchColumn, FFTText_Cols(5)(i).Value2
                Case "CopyPasteText"
                    Range(FFTText_Cols(3)(i).Value2).NumberFormat = "@"
                    Range(FFTText_Cols(3)(i).Value2).Value = _
                        Range(FFTText_Cols(2)(i).Value2).Value
                    Range(FFTText_Cols(3)(i).Value2).NumberFormat = "General"
                Case "UpdatePrompt"
                    Application.ScreenUpdating = True
                    Range(FFTText_Cols(2)(i).Value2).Parent.Activate
                    Set PreviousSelection = Selection
                    Range(FFTText_Cols(2)(i).Value2).Select
                    If MsgBox("Do you wish to updates all the """ & FFTText_Cols(3)(i).Value2 & """ values?" & vbCrLf & vbCrLf & "This will affect all sheets in this workbook." & vbCrLf & "If the string has changed in your FFTText Editor, choosing Yes will update their string values. Otherwise, they will remain as they are.", vbYesNo, "Update Values") = vbYes Then
                        Update = True
                    Else
                        Update = False
                    End If
                    PreviousSelection.Select
                    Application.ScreenUpdating = False
                Case "UpdateValues"
                    If Update Then
                        For a = LBound(ArrayNames) To UBound(ArrayNames)
                            If ArrayNames(a) = FFTText_Cols(4)(i).Value2 Then
                                DecimalArray = Split(ArrayStrings(a), Chr(20))
                                Exit For
                            End If
                        Next a
                        Range(FFTText_Cols(2)(i).Value2).NumberFormat = "@"
                        For a = 1 To Range(FFTText_Cols(2)(i).Value2).Rows.Count
                            Range(FFTText_Cols(2)(i).Value2).Cells(a, 1).Value = Range(FFTText_Cols(3)(i).Value2).Cells(DecimalArray(a - 1) + 1, 1).Value
                        Next a
                        Range(FFTText_Cols(2)(i).Value2).NumberFormat = "General"
                    End If
                Case "CallSub"
                    Application.Run CStr(FFTText_Cols(2)(i).Value2), FFTText_Cols(3)(i).Value2, FFTText_Cols(4)(i).Value2, FFTText_Cols(5)(i).Value2
                    On Error GoTo SkipRun
                    
SkipRun:
                    On Error GoTo 0
            End Select
        Next i
    End If
SubEnd:
    VBATime False
    Worksheets(ReturnSheet).Activate
End Sub

Public Function DecToHex(Decimal_Value As Long, Optional Character_Length As Integer = -1) As String
    Dim a As Byte
    Dim Temp_Value As Long
    DecToHex = ""
    Temp_Value = Decimal_Value
    While Temp_Value > 0
        DecToHex = Hex(Temp_Value Mod 16) & DecToHex
        Temp_Value = Int(Temp_Value / 16)
    Wend
    If Character_Length >= 0 Then
        If Len(DecToHex) > Character_Length Then
            DecToHex = Right(DecToHex, Character_Length)
        ElseIf Len(DecToHex) < Character_Length Then
            For a = 1 To Character_Length - Len(DecToHex)
                DecToHex = "0" & DecToHex
            Next a
        End If
    End If
End Function

Public Function DecToBin(Decimal_Value As Long, Optional Bit_Length As Integer = -1) As String
    Dim a As Byte
    Dim Temp_Value As Long
    DecToBin = ""
    Temp_Value = Decimal_Value
    If Decimal_Value < 0 Then Temp_Value = Abs(Temp_Value) - 1
    If Decimal_Value <> 0 Then
        While Temp_Value > 0
            DecToBin = Temp_Value Mod 2 & DecToBin
            Temp_Value = Int(Temp_Value / 2)
        Wend
    End If
    If Bit_Length >= 0 Then
        If Len(DecToBin) > Bit_Length Then
            DecToBin = Right(DecToBin, Bit_Length)
        ElseIf Len(DecToBin) < Bit_Length Then
            For a = 1 To Bit_Length - Len(DecToBin)
                DecToBin = "0" & DecToBin
            Next a
        End If
    End If
    If Decimal_Value < 0 Then
        DecToBin = Replace(Replace(Replace(DecToBin, "0", "2"), "1", "0"), "2", "1")
    End If
    
End Function

Public Function HexToDec(Hexadecimal_Value As String, Optional Error_Value As Long = -1, Optional Signed As Boolean = False) As Long
    Dim Temp_String As String
    Temp_String = Replace(Hexadecimal_Value, " ", "")
    If Len(Hexadecimal_Value) > 2 Then
        If Left(Hexadecimal_Value, 2) = "0x" Then Temp_String = Mid(Temp_String, 3)
    End If
    On Error GoTo Not_Hex
    If "&H" & Left(Temp_String, 1) >= 8 Then
        If Len(Temp_String) >= 8 Then
            Temp_String = CStr(CLng("&H0" & Left(Temp_String, 1)) - 8) & Mid(Temp_String, 2)
            If Signed Then
                HexToDec = ("&H0" & Temp_String) - 16 ^ Len(Temp_String) / 2
            Else
                HexToDec = "&H0" & Temp_String
            End If
        Else
            If Signed Then
                HexToDec = ("&H0" & Temp_String) - 16 ^ Len(Temp_String)
            Else
                HexToDec = "&H0" & Temp_String
            End If
        End If
    Else
        HexToDec = "&H0" & Temp_String
    End If
    Exit Function
Not_Hex:
    HexToDec = Error_Value
End Function

Public Function HexToBin(Hexadecimal_Value As String, Optional Bit_Length As Integer = -1) As String
    Dim Bin As String
    Dim a As Byte
    Dim Hex_Length As Integer
    Dim Temp_String As String
    Temp_String = Replace(UCase(Hexadecimal_Value), " ", "")
    If Left(Hexadecimal_Value, 2) = "0x" Then Temp_String = Right(Temp_String, Len(Temp_String) - 2)
    Hex_Length = Len(Hexadecimal_Value)
    HexToBin = ""
    For a = 1 To Len(Hexadecimal_Value)
        Select Case Mid(Hexadecimal_Value, Hex_Length - a + 1, 1)
            Case "0": Bin = "0000"
            Case "1": Bin = "0001"
            Case "2": Bin = "0010"
            Case "3": Bin = "0011"
            Case "4": Bin = "0100"
            Case "5": Bin = "0101"
            Case "6": Bin = "0110"
            Case "7": Bin = "0111"
            Case "8": Bin = "1000"
            Case "9": Bin = "1001"
            Case "A", "a": Bin = "1010"
            Case "B", "b": Bin = "1011"
            Case "C", "c": Bin = "1100"
            Case "D", "d": Bin = "1101"
            Case "E", "e": Bin = "1110"
            Case "F", "f": Bin = "1111"
        End Select
        HexToBin = Bin & HexToBin
    Next a
    If Bit_Length >= 0 Then
        If Len(HexToBin) > Bit_Length Then
            HexToBin = Right(HexToBin, Bit_Length)
        ElseIf Len(HexToBin) < Bit_Length Then
            For a = 1 To Bit_Length - Len(HexToBin)
                HexToBin = "0" & HexToBin
            Next a
        End If
    End If
End Function

Public Function BinToDec(Binary_String As String, Optional To_Signed As Long = 0) As Long
    Dim a As Integer
    Dim Binary_Length As Integer
    Dim Multiplier As Long
    Multiplier = 1
    Binary_Length = Len(Binary_String)
    BinToDec = 0
    On Error Resume Next
    For a = 1 To Binary_Length
        BinToDec = BinToDec + Mid(Binary_String, Binary_Length - a + 1, 1) * Multiplier
        Multiplier = Multiplier * 2
    Next a
    If To_Signed > 0 Then
        If BinToDec >= Int(To_Signed / 2) Then BinToDec = (To_Signed - BinToDec) * -1
    End If
End Function

Public Function BinToHex(Binary_String As String, Optional Character_Length As Integer = -1) As String
    Dim a As Integer
    Dim Temp_String As String
    Temp_String = "000" & Binary_String
    For a = 1 To Int(Len(Temp_String) / 4)
        Select Case Mid(Temp_String, Len(Temp_String) - 4 * a + 1, 4)
            Case "0000": BinToHex = "0" & BinToHex
            Case "0001": BinToHex = "1" & BinToHex
            Case "0010": BinToHex = "2" & BinToHex
            Case "0011": BinToHex = "3" & BinToHex
            Case "0100": BinToHex = "4" & BinToHex
            Case "0101": BinToHex = "5" & BinToHex
            Case "0110": BinToHex = "6" & BinToHex
            Case "0111": BinToHex = "7" & BinToHex
            Case "1000": BinToHex = "8" & BinToHex
            Case "1001": BinToHex = "9" & BinToHex
            Case "1010": BinToHex = "A" & BinToHex
            Case "1011": BinToHex = "B" & BinToHex
            Case "1100": BinToHex = "C" & BinToHex
            Case "1101": BinToHex = "D" & BinToHex
            Case "1110": BinToHex = "E" & BinToHex
            Case "1111": BinToHex = "F" & BinToHex
        End Select
    Next a
    If Character_Length >= 0 Then
        If Len(BinToHex) > Character_Length Then BinToHex = Right(BinToHex, Character_Length)
        For a = Len(BinToHex) To Character_Length - 1
            BinToHex = "0" & BinToHex
        Next a
    End If
End Function

Public Function HexDecToDec(Value_String As String, Optional Error_Value As Long = -1, Optional Signed As Boolean = False) As Long
    Dim Temp_String As String
    Temp_String = Replace(Value_String, " ", "")
    If Len(Temp_String) > 3 Then
        If Left(Temp_String, 2) = "0x" Then HexDecToDec = HexToDec(Temp_String, Error_Value, Signed): Exit Function
    End If
    On Error GoTo Unknown_String
    HexDecToDec = CLng(Value_String)
    Exit Function
Unknown_String:
    HexDecToDec = Error_Value
End Function

Public Sub Concatenate_Cells_To_Clipboard()
    Dim Selected_Range As Range
    Dim Selection_Rows, Selection_Cols As Long
    Dim Column_Locked, Row_Locked As Boolean
    Dim r, c As Long
    Dim Copy_String As String
    Dim Separator As String
    Dim Has_Separator As Boolean
    Copy_String = "="
    Set Selected_Range = Selection
    Selection_Rows = Selected_Range.Rows.Count
    Selection_Cols = Selected_Range.Columns.Count
    Column_Locked = MsgBox("Lock Columns?", vbYesNo, "Concatenate cells to clipboard") = vbYes
    Row_Locked = MsgBox("Lock Rows?", vbYesNo, "Concatenate cells to clipboard") = vbYes
    Separator = InputBox("Please type in the separator you want. You can type in anything as long as it respects the formula format." & vbCrLf & "Remember to surround the string in ""double quotes"" if you wish to use a string." & vbCrLf & vbCrLf & "Leave as blank for no separator", "Concatenate cells to clipboard", "")
    If Len(Separator) Then Has_Separator = True
    For r = 1 To Selection_Rows
        For c = 1 To Selection_Cols
            Copy_String = Copy_String & Selected_Range.Cells(r, c).Address(Row_Locked, Column_Locked)
            If r <> Selection_Rows Or c <> Selection_Cols Then
                Copy_String = Copy_String & "&"
                If Has_Separator Then Copy_String = Copy_String & Separator & "&"
            End If
        Next c
    Next r
    With New MsForms.DataObject
        .SetText Copy_String
        .PutInClipboard
    End With
    MsgBox "You may now paste (ctrl+v) the formula into the cell of your choice.", vbOKOnly, "Concatenate cells to clipboard"
End Sub

Public Function IsHex(HexString As String, Optional Accept_Spaces As Boolean = False) As Boolean
    Dim i As Integer
    Dim Temp_Hex As String
    Temp_Hex = UCase(HexString)
    If Left(HexString, 2) = "0x" Then Temp_Hex = Right(Temp_Hex, Len(Temp_Hex) - 2)
    IsHex = True
    For i = 1 To Len(Temp_Hex)
        Select Case Mid(Temp_Hex, i, 1)
            Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F":
            Case Else:
                If Accept_Spaces Then
                    If Mid(Temp_Hex, i, 1) <> " " Then
                        IsHex = False
                        Exit Function
                    End If
                Else
                    IsHex = False
                    Exit Function
                End If
        End Select
    Next i
End Function

Public Function Encode(Opcode As Variant, MemoryAddress As Long) As String
    Dim LOpcode As String, i As Long
    Dim SplitOpcode() As String
    Dim TempString As String
    Dim Immediate As Long
    Dim SpacePos As Integer
    LOpcode = LCase(Trim(Opcode))
    SplitOpcode = Split(LOpcode, ",")
    SpacePos = InStr(1, LOpcode, " ")
    If SpacePos Then
        LOpcode = LCase(Left(LOpcode, SpacePos - 1))
    Else
        LOpcode = LCase(Opcode)
    End If
    If UBound(SplitOpcode) <> 0 Then SplitOpcode(0) = Right(SplitOpcode(0), Len(SplitOpcode(0)) - Len(LOpcode) - 1)
    Select Case LOpcode
        Case "nop": Encode = "00000000000000000000000000000000"
        Case "sll": Encode = "00000000000WQS000000"
        Case "srl": Encode = "00000000000WQS000010"
        Case "sra": Encode = "00000000000WQS000011"
        Case "sllv": Encode = "000000EWQ00000000100"
        Case "srlv": Encode = "000000EWQ00000000110"
        Case "srav": Encode = "000000EWQ00000000111"
        Case "add": Encode = "000000WEQ00000100000"
        Case "addu": Encode = "000000WEQ00000100001"
        Case "sub": Encode = "000000WEQ00000100010"
        Case "subu": Encode = "000000WEQ00000100011"
        Case "and": Encode = "000000WEQ00000100100"
        Case "or": Encode = "000000WEQ00000100101"
        Case "xor": Encode = "000000WEQ00000100110"
        Case "nor": Encode = "000000WEQ00000100111"
        Case "slt": Encode = "000000WEQ00000101010"
        Case "sltu": Encode = "000000WEQ00000101011"
        Case "bltz": Encode = "000001Q00000B"
        Case "bgez": Encode = "000001Q00001B"
        Case "bltzal": Encode = "000001Q10000B"
        Case "bgezal": Encode = "000001Q10001B"
        Case "j": Encode = "000010J"
        Case "jal": Encode = "000011J"
        Case "jr": Encode = "000000Q000000000000000001000"
        Case "jalr": Encode = "000000Q00000W00000001001"
        Case "beq": Encode = "000100QWB"
        Case "bne": Encode = "000101QWB"
        Case "blez": Encode = "000110Q00000B"
        Case "bgtz": Encode = "000111Q00000B"
        Case "addi": Encode = "001000WQL"
        Case "addiu": Encode = "001001WQL"
        Case "slti": Encode = "001010WQL"
        Case "sltiu": Encode = "001011WQL"
        Case "andi": Encode = "001100WQL"
        Case "ori": Encode = "001101WQL"
        Case "xori": Encode = "001110WQL"
        Case "lui": Encode = "00111100000QL"
        Case "lb": Encode = "100000RQL"
        Case "lh": Encode = "100001RQL"
        Case "lwl": Encode = "100010RQL"
        Case "lw": Encode = "100011RQL"
        Case "lbu": Encode = "100100RQL"
        Case "lhu": Encode = "100101RQL"
        Case "lwr": Encode = "100110RQL"
        Case "sb": Encode = "101000RQL"
        Case "sh": Encode = "101001RQL"
        Case "swl": Encode = "101010RQL"
        Case "sw": Encode = "101011RQL"
        Case "swr": Encode = "101110RQL"
        Case "mfhi": Encode = "0000000000000000Q00000010000"
        Case "mthi": Encode = "000000Q000000000000000010001"
        Case "mflo": Encode = "0000000000000000Q00000010010"
        Case "mtlo": Encode = "000000Q000000000000000010011"
        Case "mult": Encode = "000000QW0000000000011000"
        Case "multu": Encode = "000000QW0000000000011001"
        Case "div": Encode = "000000QW0000000000011010"
        Case "divu": Encode = "000000QW0000000000011011"
        Case "lwc0": Encode = "110000RQL"
        Case "lwc1": Encode = "110001RQL"
        Case "lwc2": Encode = "110010RQL"
        Case "lwc3": Encode = "110011RQL"
        Case "swc0": Encode = "111000RQL"
        Case "swc1": Encode = "111001RQL"
        Case "swc2": Encode = "111010RQL"
        Case "swc3": Encode = "111011RQL"
        Case "mfc0": Encode = "01000000000QW00000000000"
        Case "mfc1": Encode = "01000100000QW00000000000"
        Case "mfc2": Encode = "01001000000QW00000000000"
        Case "mfc3": Encode = "01001100000QW00000000000"
        Case "cfc0": Encode = "01000000010QW00000000000"
        Case "cfc1": Encode = "01000100010QW00000000000"
        Case "cfc2": Encode = "01001000010QW00000000000"
        Case "cfc3": Encode = "01001100010QW00000000000"
        Case "mtc0": Encode = "01000000100QW00000000000"
        Case "mtc1": Encode = "01000100100QW00000000000"
        Case "mtc2": Encode = "01001000100QW00000000000"
        Case "mtc3": Encode = "01001100100QW00000000000"
        Case "ctc0": Encode = "01000000110QW00000000000"
        Case "ctc1": Encode = "01000100110QW00000000000"
        Case "ctc2": Encode = "01001000110QW00000000000"
        Case "ctc3": Encode = "01001100110QW00000000000"
        Case "rfe": Encode = "01000010000000000000000000010000"
        Case "tlbp": Encode = "01000010000000000000000000001000"
        Case "tlbr": Encode = "01000010000000000000000000000001"
        Case "tlbwi": Encode = "01000010000000000000000000000010"
        Case "tlbwr": Encode = "01000010000000000000000000000011"
        Case "syscall": Encode = "000000F001100"
        Case "break": Encode = "000000F001101"
    End Select
    If InStr(1, Encode, "Q") Then Encode = Replace(Encode, "Q", DecToBin(GetRegister(SplitOpcode(0)), 5))
    If InStr(1, Encode, "W") Then Encode = Replace(Encode, "W", DecToBin(GetRegister(SplitOpcode(1)), 5))
    If InStr(1, Encode, "E") Then Encode = Replace(Encode, "E", DecToBin(GetRegister(SplitOpcode(2)), 5))
    If InStr(1, Encode, "R") Then Encode = Replace(Encode, "R", DecToBin(GetRegister(Right(Opcode, Len(Opcode) - InStr(1, Opcode, "("))), 5))
    If InStr(1, Encode, "B") Then Encode = Replace(Encode, "B", DecToBin(GetImmediate(CStr(Opcode), True, MemoryAddress), 16))
    If InStr(1, Encode, "J") Then Encode = Replace(Encode, "J", DecToBin(GetImmediate(CStr(Opcode), True), 26))
    If InStr(1, Encode, "S") Then Encode = Replace(Encode, "S", DecToBin(GetImmediate(CStr(Opcode)), 5))
    If InStr(1, Encode, "L") Then Encode = Replace(Encode, "L", DecToBin(GetImmediate(CStr(Opcode)), 16))
    If InStr(1, Encode, "F") Then
        
    End If

    Encode = ReverseBytes(BinToHex(Encode, 8))
End Function

Public Function Decode(HexString As String, Optional MemoryAddress As Long = 0, Optional PublicAddress As Boolean = False) As Decoded
    Dim Parameter As Integer
    Dim BinString, TempString As String
    Dim Address As Long
    'If PublicAddress Then Decode.Stringd_Decode.Destination = 0
    If Len(HexString) <> 8 Then
        Decode.String = HexString
        Exit Function
    End If
    TempString = UCase(Replace(ReverseBytes(HexString, 4), " ", ""))
    BinString = HexToBin(TempString, 32)
    Select Case BinToDec(Left(BinString, 6))
        Case 0:
            Select Case BinToDec(Mid(BinString, 27, 6))
                Case 0:
                    If TempString = "00000000" Then
                        Decode.String = "nop"
                    Else
                        Decode.String = "sll r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", 0x" & BinToHex(Mid(BinString, 22, 5), 2)
                    End If
                Case 2: Decode.String = "srl r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", 0x" & BinToHex(Mid(BinString, 22, 5), 2)
                Case 3: Decode.String = "sra r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", 0x" & BinToHex(Mid(BinString, 22, 5), 2)
                Case 4: Decode.String = "sllv r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5))
                Case 6: Decode.String = "srlv r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5))
                Case 7: Decode.String = "srav r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5))
                Case 8: Decode.String = "jr r" & BinToDec(Mid(BinString, 7, 5))
                Case 9: Decode.String = "jalr r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 17, 5))
                Case 12: Decode.String = "syscall " & GetFunction(Mid(BinString, 7, 20))
                Case 13: Decode.String = "break " & GetFunction(Mid(BinString, 7, 20))
                Case 16: Decode.String = "mfhi r" & BinToDec(Mid(BinString, 17, 5))
                Case 17: Decode.String = "mthi r" & BinToDec(Mid(BinString, 7, 5))
                Case 18: Decode.String = "mflo r" & BinToDec(Mid(BinString, 17, 5))
                Case 19: Decode.String = "mtlo r" & BinToDec(Mid(BinString, 7, 5))
                Case 24: Decode.String = "mult r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 25: Decode.String = "multu r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 26: Decode.String = "div r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 27: Decode.String = "divu r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 32: Decode.String = "add r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 33: Decode.String = "addu r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 34: Decode.String = "sub r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 35: Decode.String = "subu r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 36: Decode.String = "and r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 37: Decode.String = "or r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 38: Decode.String = "xor r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 39: Decode.String = "nor r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 42: Decode.String = "slt r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case 43: Decode.String = "sltu r" & BinToDec(Mid(BinString, 17, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5))
                Case Else:
                    Decode.String = HexString
                    Exit Function
            End Select
        Case 1:
            Select Case BinToDec(Mid(BinString, 12, 5))
                Case 0: Decode.String = "bltz r" & BinToDec(Mid(BinString, 7, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
                Case 1: Decode.String = "bgez r" & BinToDec(Mid(BinString, 7, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
                Case 16: Decode.String = "bltzal r" & BinToDec(Mid(BinString, 7, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
                Case 17: Decode.String = "bgezal r" & BinToDec(Mid(BinString, 7, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
                Case Else:
                    Decode.String = HexString
                    Exit Function
            End Select
        Case 2: Decode.String = "j ": Decode.Destination = BinToDec(Mid(BinString, 7, 26)) * 4
        Case 3: Decode.String = "jal ": Decode.Destination = BinToDec(Mid(BinString, 7, 26)) * 4
        Case 4: Decode.String = "beq r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
        Case 5: Decode.String = "bne r" & BinToDec(Mid(BinString, 7, 5)) & ", r" & BinToDec(Mid(BinString, 12, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
        Case 6: Decode.String = "blez r" & BinToDec(Mid(BinString, 7, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
        Case 7: Decode.String = "bgtz r" & BinToDec(Mid(BinString, 7, 5)) & ", ": Decode.Destination = BinToDec(Mid(BinString, 17, 16), 65536) * 4 + MemoryAddress + 4
        Case 8: Decode.String = "addi r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4)
        Case 9: Decode.String = "addiu r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4)
        Case 10: Decode.String = "slti r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4)
        Case 11: Decode.String = "sltiu r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4)
        Case 12: Decode.String = "andi r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", 0x" & BinToHex(Mid(BinString, 17, 16), 4)
        Case 13: Decode.String = "ori r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", 0x" & BinToHex(Mid(BinString, 17, 16), 4)
        Case 14: Decode.String = "xori r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 7, 5)) & ", 0x" & BinToHex(Mid(BinString, 17, 16), 4)
        Case 15: Decode.String = "lui r" & BinToDec(Mid(BinString, 12, 5)) & ", 0x" & BinToHex(Mid(BinString, 17, 16), 4)
        Case 16 To 19:
            Select Case Mid(BinString, 7, 5)
            Case "01000":
                Select Case Right(BinString, 6)
                    Case "010000": Decode.String = "RFE"
                    Case "001000": Decode.String = "TLBP"
                    Case "000001": Decode.String = "TLBR"
                    Case "000010": Decode.String = "TLBWI"
                    Case "000011": Decode.String = "TLBWR"
                    Case Else:
                        Decode.String = HexString
                        Exit Function
                End Select
            Case Else:
                Select Case Mid(BinString, 9, 1)
                    Case "0": Decode.String = "F"
                    Case "1": Decode.String = "T"
                End Select
                Select Case Mid(BinString, 10, 1)
                    Case "0": Decode.String = "M" & Decode.String
                    Case "1": Decode.String = "C" & Decode.String
                End Select
                Decode.String = Decode.String & "C" & BinToDec(Mid(BinString, 5, 2)) & " r" & BinToDec(Mid(BinString, 12, 5)) & ", r" & BinToDec(Mid(BinString, 17, 5))
            End Select
        Case 32: Decode.String = "lb r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 33: Decode.String = "lh r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 34: Decode.String = "lwl r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 35: Decode.String = "lw r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 36: Decode.String = "lbu r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 37: Decode.String = "lhu r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 38: Decode.String = "lwr r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 40: Decode.String = "sb r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 41: Decode.String = "sh r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 42: Decode.String = "swl r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 43: Decode.String = "sw r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 46: Decode.String = "swr r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 49: Decode.String = "LWC1 r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 50: Decode.String = "LWC2 r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 51: Decode.String = "LWC3 r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 57: Decode.String = "SWC1 r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 58: Decode.String = "SWC2 r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case 59: Decode.String = "SWC3 r" & BinToDec(Mid(BinString, 12, 5)) & ", " & BinToSignedHex(Mid(BinString, 17, 16), 4) & "(r" & BinToDec(Mid(BinString, 7, 5)) & ")"
        Case Else:
            Decode.String = HexString
            Exit Function
    End Select
    If Decode.Destination Then
        If Not PublicAddress Then
            Decode.String = Decode.String & "0x8" & DecToHex(Decode.Destination, 7)
        End If
    End If
End Function

Public Function BinToSignedHex(Binary_String As String, Character_Length As Integer) As String
    Dim Decimal_Value As Long
    Decimal_Value = BinToDec(Binary_String)
    If Decimal_Value >= (16 ^ Character_Length) / 2 Then
        BinToSignedHex = "-0x" & DecToHex(16 ^ Character_Length - Decimal_Value, 4)
    Else
        BinToSignedHex = "0x" & DecToHex(Decimal_Value, 4)
    End If
End Function

Public Function GetRegister(RegisterString As String) As Byte
    Dim NextCharacter As String * 1, Replaced As Boolean
    Dim i As Integer
    RegisterString = Trim(RegisterString)
    Replaced = True
    Select Case RegisterString
        Case "zero": GetRegister = 0
        Case "at": GetRegister = 1
        Case "v0": GetRegister = 2
        Case "v1": GetRegister = 3
        Case "a0": GetRegister = 4
        Case "a1": GetRegister = 5
        Case "a2": GetRegister = 6
        Case "a3": GetRegister = 7
        Case "t0": GetRegister = 8
        Case "t1": GetRegister = 9
        Case "t2": GetRegister = 10
        Case "t3": GetRegister = 11
        Case "t4": GetRegister = 12
        Case "t5": GetRegister = 13
        Case "t6": GetRegister = 14
        Case "t7": GetRegister = 15
        Case "s0": GetRegister = 16
        Case "s1": GetRegister = 17
        Case "s2": GetRegister = 18
        Case "s3": GetRegister = 19
        Case "s4": GetRegister = 20
        Case "s5": GetRegister = 21
        Case "s6": GetRegister = 22
        Case "s7": GetRegister = 23
        Case "t8": GetRegister = 24
        Case "t9": GetRegister = 25
        Case "k0": GetRegister = 26
        Case "k1": GetRegister = 27
        Case "gp": GetRegister = 28
        Case "sp": GetRegister = 29
        Case "fp": GetRegister = 30
        Case "ra": GetRegister = 31
        Case Else: Replaced = False
    End Select
    If Replaced Then Exit Function
    For i = 1 To Len(RegisterString)
        NextCharacter = Mid(RegisterString, i, 1)
        If IsNumeric(NextCharacter) Then
            GetRegister = GetRegister * 10 + CLng(NextCharacter)
        End If
    Next i
End Function

Public Function GetImmediate(Opcode As String, Optional DivideByFour As Boolean = False, Optional BranchOffset As Long = 0) As Long
    Dim Position As Integer, PositionEnd As Integer, LongImmediate As Long, i As Integer, Signed As Boolean, NextBit As Boolean
    Position = InStr(1, Opcode, "0x") + 1
    Signed = False
    If Position = 1 Then
        Position = InStr(1, Opcode, "$")
        If Position = 0 Then
            GetImmediate = 0
            Exit Function
        End If
        If Mid(Opcode, Position - 1, 1) = "-" Then Signed = True
    Else
        If Mid(Opcode, Position - 2, 1) = "-" Then Signed = True
    End If
    Opcode = Right(Opcode, Len(Opcode) - Position)
    Position = InStr(1, Opcode, "(")
    If Position = 0 Then
        Position = InStr(1, Opcode, ",")
        If Position = 0 Then
            Position = Len(Opcode) + 1
        End If
    End If
    Opcode = Left(Opcode, Position - 1)
    Opcode = Right(Opcode, 7)
    LongImmediate = ("&H" & Opcode) + 0
    If Signed Then
        If LongImmediate = 0 Then
            Signed = False
        Else
            LongImmediate = -LongImmediate
        End If
    End If
    If BranchOffset <> 0 Then
        LongImmediate = LongImmediate - BranchOffset - 4
    End If
    If DivideByFour Then LongImmediate = Int(LongImmediate / 4)
    GetImmediate = LongImmediate
End Function

Public Function GetFunction(BinString As String) As String
    GetFunction = "0x" & DecToHex(BinString, 8)
End Function

Public Function GetBranch(BinString As String, MemoryAddress As Long) As String
    GetBranch = "0x8" & DecToHex(MemoryAddress + (BinToDec(BinString) + 1) * 4, 7)
End Function

Public Function SetJump(BinString As String)
    Dim LongJump As Long
    LongJump = Int(BinToDec(BinString) * 4)
    SetJump = "0x8" & DecToHex(LongJump, 7)
End Function

Public Function Trim_Range(ByRef Range_to_Trim As Range, Optional Trim_Vertically As Boolean = True, Optional Trim_Horizontally As Boolean = True, Optional Cannot_Be_Identical As Boolean = False) As Range
    Dim a As Long
    Dim Result As Range
    Dim Top As Long, Bottom As Long, Left As Long, Right As Long
    Dim O_Top As Long, O_Bottom As Long, O_Left As Long, O_Right As Long
    Dim Empty_Row As Boolean
    Dim Parent_Sheet As Worksheet
    Set Parent_Sheet = Range_to_Trim.Parent
    With Range_to_Trim
        O_Top = .Row
        O_Bottom = O_Top + .Rows.Count - 1
        O_Left = .Column
        O_Right = O_Left + .Columns.Count - 1
    End With
    With Parent_Sheet
        If Trim_Vertically Then
            Top = 2147483647
            For a = O_Left To O_Right
                If .Cells(O_Top, a).Value2 <> vbEmpty Then
                    Top = O_Top
                    Exit For
                Else
                    Top = Application.Min(.Cells(O_Top, a).End(xlDown).Row, Top)
                End If
            Next a
            If Top > O_Bottom Then Exit Function
            
            Bottom = -2147483647
            For a = O_Left To O_Right
                If .Cells(O_Bottom, a).Value2 <> vbEmpty Then
                    Bottom = O_Bottom
                    Exit For
                Else
                    Bottom = Application.Max(.Cells(O_Bottom, a).End(xlUp).Row, Bottom)
                End If
            Next a
            If Bottom < O_Top Then Exit Function
        Else
            Top = O_Top
            Bottom = O_Bottom
        End If
        
        If Top > Bottom Then
            Top = Bottom
        End If
        
        If Trim_Horizontally Then
            Left = 2147483647
            For a = Top To Bottom
                If .Cells(a, O_Left).Value2 <> vbEmpty Then
                    Left = O_Left
                    Exit For
                Else
                    Left = Application.Min(.Cells(a, O_Left).End(xlToRight).Column, Left)
                End If
            Next a
            If Left > O_Right Then Exit Function
            
            Right = -2147483647
            For a = Top To Bottom
                If .Cells(a, O_Right).Value2 <> vbEmpty Then
                    Right = O_Right
                    Exit For
                Else
                    Right = Application.Max(.Cells(a, O_Right).End(xlToLeft).Column, Right)
                End If
            Next a
            If Right < O_Left Then Exit Function
        Else
            Left = O_Left
            Right = O_Right
        End If
        If Not Cannot_Be_Identical Or (Cannot_Be_Identical And (Top <> O_Top Or Bottom <> O_Bottom Or Left <> O_Left Or Right <> O_Right)) Then
            Set Trim_Range = .Range(.Cells(Top, Left), .Cells(Bottom, Right))
        End If
    End With
End Function

Public Sub Hide_Other_Hacks()
    Dim FirstRow, LastRow, PatchFirstRow, PatchLastRow, a As Long
    Dim Code_Range As Range
    Set Code_Range = Code_Sheet.Range("A:G")
    FirstRow = 1
    LastRow = GetLastCodeRow
    For a = Selection.Row To FirstRow Step -1
        If Code_Range.Cells(a, 1).Value2 = "PATCH" Then
            PatchFirstRow = a
            Exit For
        End If
    Next a
    For a = Selection.Row + 1 To LastRow
        If Code_Range.Cells(a, 1).Value2 = "PATCH" Then
            PatchLastRow = a - 1
            Exit For
        End If
    Next a
    Code_Range.Range(Code_Range.Cells(FirstRow, 1), Code_Range(LastRow, 5)).Rows.Hidden = True
    Code_Range.Range(Code_Range.Cells(PatchFirstRow, 1), Code_Range(PatchLastRow, 5)).Rows.Hidden = False
    ActiveWindow.ScrollRow = FirstRow
    ActiveWindow.ScrollColumn = 1
End Sub

Public Sub Reveal_All_Hacks()
    Dim Code_Range As Range
    Set Code_Range = Code_Sheet.Range("A:G")
    Code_Range.Rows.Hidden = False
    ActiveWindow.ScrollRow = Selection.Row
    ActiveWindow.ScrollColumn = 1
End Sub

Sub UpdateHackList_Button()
    VBATime True
    Call UpdateHackList
    VBATime False
End Sub

Public Sub Encode_Selection()
    VBATime True
    Dim Current_Offset As Long
    Dim cell As Variant
    Selection.NumberFormat = "@"
    For Each cell In Selection
        Current_Offset = HexToDec(Right(cell.Offset(0, -1).Value2, 6))
        If Not IsHex(Trim(cell.Value2)) Then cell.Value2 = Encode(Trim(cell.Value2), Current_Offset)
    Next
    Selection.NumberFormat = "General"
    VBATime False
End Sub

Public Sub Decode_Selection()
    VBATime True
    Dim Current_Offset As Long
    Dim Current_Value As String
    Dim cell As Variant
    Selection.NumberFormat = "@"
    For Each cell In Selection
        Current_Offset = HexToDec(Right(cell.Offset(0, -1).Value2, 6))
        cell.Value2 = Decode(Trim(cell.Value2), Current_Offset).String
    Next
    Selection.NumberFormat = "General"
    VBATime False
End Sub

Public Sub Clear_All_Hacks()
    VBATime True
    If MsgBox("This operation cannot be reverted." & vbCrLf & "Are you sure you wish to proceed?", vbOKCancel, "Clear All Hacks") = vbCancel Then Exit Sub
    Clear_Code 1, 1048576
    Call WipeHexBackup
    Call UpdateHackList
    VBATime False
End Sub

Public Sub CalcSheet_Calc_ON()
    Calc_Sheet.EnableCalculation = True
    Calc_Sheet.Calculate
End Sub

Public Sub CalcSheet_Calc_OFF()
    Calc_Sheet.EnableCalculation = False
End Sub

Public Sub Refresh_Current_Sheet()
    Dim WS_Count, a As Byte
    Dim Current_Sheet As String
    WS_Count = ActiveWorkbook.Worksheets.Count
    Current_Sheet = ActiveWorkbook.ActiveSheet.Name
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    For a = 1 To WS_Count
        If Current_Sheet <> ActiveWorkbook.Worksheets(a).Name And ActiveWorkbook.Worksheets(a).Visible = True Then
            ActiveWorkbook.Worksheets(a).Activate
            Exit For
        End If
    Next a
    Application.EnableEvents = True
    ActiveWorkbook.Worksheets(Current_Sheet).Activate
    Application.ScreenUpdating = True
End Sub

Sub HackToolbar(Optional Toolbar As String = "Global")
    If Toolbar_Type = Toolbar Then Exit Sub
    Toolbar_Type = Toolbar
    Dim Button_Count As Integer
    Button_Count = 0
    RemoveHackToolbar
    
    Select Case Toolbar
        Case "":
            Call Empty_Add_Ins(Button_Count)
        Case "Global":
            Call Global_Add_Ins(Button_Count)
        Case "Code":
            Call Global_Add_Ins(Button_Count)
            Call Code_Add_Ins(Button_Count)
            Call Developer_Add_Ins(Button_Count)
            Call CalculateNow_Add_Ins(Button_Count)
            Call Admin_Add_Ins(Button_Count)
        Case "Hacks":
            Call Global_Add_Ins(Button_Count)
            Call Hacks_Add_Ins(Button_Count)
        Case "Calculations":
            Call Global_Add_Ins(Button_Count)
            Call Developer_Add_Ins(Button_Count)
            Call Calculation_Add_Ins(Button_Count)
            Call CalculateNow_Add_Ins(Button_Count)
        Case "Developer":
            Call Global_Add_Ins(Button_Count)
            Call Developer_Add_Ins(Button_Count)
            Call Admin_Add_Ins(Button_Count)
        Case Else:
    End Select
    
    On Error GoTo Force_Global:
    Application.Run "Custom_Add_Ins", Toolbar, CStr(Button_Count)
    Exit Sub
    
Force_Global:
    Select Case Toolbar
        Case "", "Global", "Code", "Hacks", "Calculations", "Developer":
        Case Else: Call Global_Add_Ins(Button_Count)
    End Select
End Sub

Sub Global_Add_Ins(Button_Count As Integer)
    Call Config_Add_Ins(Button_Count)
    Call Save_Add_Ins(Button_Count)
End Sub
Sub Config_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "Configuration         ", "Configure the default settings of the many functions this spreadsheet offers", 610, "Config"
    ToolbarButton CStr(Increase(Button_Count)), "Load FFTText           ", "Imports/Updates text strings from FFTText Editor.xlsm", 1610, "LoadFFTText" '1610
    ToolbarButton CStr(Increase(Button_Count)), "Load Data                ", "Imports Data used by this spreadsheet from an FFT ISO", 159, "Load_Data"
End Sub
Sub Empty_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "", "", 0, ""
End Sub
Sub Save_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "Save to .xml             ", "Saves the hacks to an .xml file that can be used to patch with FFTOrgASM", 767, "Save_To_XML"
    ToolbarButton CStr(Increase(Button_Count)), "Save to SaveState    ", "Saves the hacks to a pSX SaveState", 2384, "Save_To_SaveState"
    ToolbarButton CStr(Increase(Button_Count)), "Save to PSX Image  ", "Saves the hacks directly to your PSX Image", 769, "Save_To_ISO"
End Sub
Sub Code_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "Import .xml              ", "Select an .xml file to import and reformat all of its hacks into this sheet", 3826, "Import_XML"
    ToolbarButton CStr(Increase(Button_Count)), "Opcode " & ChrW(8658) & " Hex        ", "Turns the selection of MIPS r3000 Opcodes into Little-Endian Hex Strings", 2476, "Encode_Selection"
    ToolbarButton CStr(Increase(Button_Count)), "Hex " & ChrW(8658) & " Opcode        ", "Turns the selection of Little-Endian Hex Strings into MIPS r3000 Opcodes", 2476, "Decode_Selection"
    ToolbarButton CStr(Increase(Button_Count)), "Hide Other Hacks    ", "Hides all rows that are not part of the currently selected Hack/'Patch'", 2991, "Hide_Other_Hacks"
    ToolbarButton CStr(Increase(Button_Count)), "Reveal All Hacks      ", "Reveals all Hacks/'Patches' that had their rows previously hidden", 2993, "Reveal_All_Hacks"
    ToolbarButton CStr(Increase(Button_Count)), "Clear All Hacks        ", "Wipes out all Hacks currently existing in the spreadsheet", 47, "Clear_All_Hacks"
    ToolbarButton CStr(Increase(Button_Count)), "Insert Line(s)            ", "Inserts lines with automatically calculated addresses; select the number of lines you wish to add or type it", 462, "Insert_Code_Lines"
    ToolbarButton CStr(Increase(Button_Count)), "Sort Alphabetically  ", "", 928, "Sort_Hacks_Alphabetically"
    ToolbarButton CStr(Increase(Button_Count)), "Group Free Space    ", "", 164, "Group_Free_Space"
    ToolbarButton CStr(Increase(Button_Count)), "Analyze Code          ", "Scans your MIPS r3000 code to detect console-breaking coding", 4099, "Analyze_Code"
    ToolbarButton CStr(Increase(Button_Count)), "Analyze Space         ", "Finds and displays free space to use for your hacks and conflicting hacks", 543, "Find_Free_Space"
    ToolbarButton CStr(Increase(Button_Count)), "Clear Hex Backup    ", "Empties out the 6th column which contains backup hex values from importing an xml file and hides it", 2046, "WipeHexBackup"
    ToolbarButton CStr(Increase(Button_Count)), "Reverse Signs         ", "Reverses positive and negative hex values for opcodes supporting signed values within the selected range", 2135, "Reverse_Signs_Selection" '625
    ToolbarButton CStr(Increase(Button_Count)), "Import Code           ", "Imports MIPS r3000 ASM Code from a specific file/offset in your PSX Image or from a Savestate", 159, "Import_Code"
End Sub
Sub Hacks_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "Update Hack List     ", "Patches in the Code sheet that were not previously found in the Hack List will be added to it", 1977, "UpdateHackList_Button"
    ToolbarButton CStr(Increase(Button_Count)), "Enable All Hacks      ", "Sets all hacks to Apply? = Yes", 1664, "EnableAllHacks"
    ToolbarButton CStr(Increase(Button_Count)), "Disable All Hacks     ", "Sets all hacks to Apply? = No", 1786, "DisableAllHacks"
End Sub
Sub Calculation_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "Calculation = ON    ", "", 2997, "CalcSheet_Calc_ON"
    ToolbarButton CStr(Increase(Button_Count)), "Calculation = OFF    ", "", 2998, "CalcSheet_Calc_OFF" '2988
End Sub
Sub CalculateNow_Add_Ins(Button_Count As Integer)
    ToolbarButton CStr(Increase(Button_Count)), "Calculate Now        ", "Calculates the 'Calculations' sheet", 960, "CalcSheet_Calculate_Now" '960
End Sub
Sub Developer_Add_Ins(Button_Count As Integer)
    If Developer_Mode Then
        ToolbarButton CStr(Increase(Button_Count)), "Import Data            ", "Imports Hex Data from a specific file/offset in your PSX Image or from a Savestate", 159, "Import_Data"
        ToolbarButton CStr(Increase(Button_Count)), "Concatenate Cells  ", "Creates a formula which includes all selected cells with the option to include separator", 2308, "Concatenate_Cells_To_Clipboard"
        ToolbarButton CStr(Increase(Button_Count)), "Release                    ", "Destroys the calculation results in the Calculations sheet to reduce the filesize before saving", 2173, "Release" '625
    End If
    ToolbarButton CStr(Increase(Button_Count)), "Fix VBA                   ", "Use this function if your spreadsheet stopped automatically calculating on all sheets", 1977, "VBATime_End"
End Sub
Sub Admin_Add_Ins(Button_Count As Integer)
    If ReadReg(RegFolder & "Admin", 0, 1) = 1 Then
        ToolbarButton CStr(Increase(Button_Count)), "Update VBA Code    ", "", 37, "Force_Update_VBA_Components"
        ToolbarButton CStr(Increase(Button_Count)), "Export VBA Code     ", "", 39, "Export_VBA_Components"
    End If
End Sub

Public Function Increase(Value As Integer) As Integer
    Value = Value + 1
    Increase = Value
End Function
  
Sub RemoveHackToolbar()
    Dim bar As CommandBar
    On Error Resume Next
    For Each bar In Application.CommandBars
        bar.Delete
    Next bar
End Sub

Sub ToolbarButton(Name As String, Caption As String, Tooltip As String, FaceID As Integer, Macro As String)
    With Application.CommandBars.Add(Name, , False, True)
        .Protection = msoBarNoCustomize
        .Position = msoBarBottom
        .Visible = True
        With .Controls.Add(msoControlButton)
            .Caption = Caption
            .TooltipText = Tooltip
            .FaceID = FaceID
            .OnAction = Macro
            .Style = msoButtonIconAndCaption
            .width = 300
        End With
    End With
End Sub

Sub EnableAllHacks()
    Call ToggleAllHacks("Yes")
End Sub

Sub DisableAllHacks()
    Call ToggleAllHacks("No")
End Sub

Sub ToggleAllHacks(Apply As String)
    VBATime True
    Dim Hacks_Table As ListObject
    Set Hacks_Table = Hacks_Sheet.ListObjects("HacksTable")
    Dim Hacks_Cols(1 To 2) As Range
    Set Hacks_Cols(1) = Hacks_Table.ListColumns("Hack Name").DataBodyRange
    Set Hacks_Cols(2) = Hacks_Table.ListColumns("Apply?").DataBodyRange
    Dim LastRow, a As Long
    LastRow = Hacks_Table.ListRows.Count
    For a = 1 To LastRow
        If Len(Hacks_Cols(1)(a).Value2) Then Hacks_Cols(2)(a).Value2 = Apply
    Next a
    VBATime False
End Sub

Sub CalcSheet_Calculate_Now()
    VBATime True
    Dim Calc As Boolean
    With Calc_Sheet
        Calc = .EnableCalculation
        .EnableCalculation = True
        Application.Calculate
        .EnableCalculation = Calc
    End With
    VBATime False
End Sub

Sub Insert_Code_Lines()
    If ActiveSheet.Name <> Code_Sheet.Name Then Exit Sub
    VBATime True
    Dim Rows_To_Add, Current_Row As Long
    Dim Previous_Opcode As String
    Dim Opcode_Rows As Boolean
    Dim Code_Range As Range
    Set Code_Range = Code_Sheet.Range("A:G")
    
    If Selection.Rows.Count = 1 Then
        Rows_To_Add = CLng("0" & InputBox("How many lines would you like to add?", "Insert Line(s)", "1"))
        If Rows_To_Add = 0 Then Exit Sub
        Selection.Resize(Rows_To_Add, Selection.Columns.Count).Select
    Else
        Rows_To_Add = Selection.Rows.Count
    End If
    Current_Row = Selection.Row
    If Current_Row > 1 Then
        Previous_Opcode = Code_Range.Cells(Current_Row - 1, 5)
        If Len(Previous_Opcode) = 0 Or IsHex(Previous_Opcode) = False Then
            Opcode_Rows = True
        Else
            Opcode_Rows = False
        End If
    Else
        Opcode_Rows = True
    End If
    If Rows_To_Add > 0 Then
        Selection.EntireRow.Insert
        With Code_Range
            With Range(.Cells(Current_Row, 1), .Cells(Current_Row + Rows_To_Add - 1, 5))
                .Interior.ColorIndex = 0
                .Font.ColorIndex = 0
            End With
            If Opcode_Rows Then
                Range(.Cells(Current_Row, 4), .Cells(Current_Row + Rows_To_Add - 1, 4)).FormulaR1C1 = "=""0x80""&DEC2HEX(4+HEX2DEC(RIGHT(INDEX(C,ROW()-1),6)),6)"
            Else
                Range(.Cells(Current_Row, 4), .Cells(Current_Row + Rows_To_Add - 1, 4)).FormulaR1C1 = "=""0x80""&DEC2HEX(INT(LEN(SUBSTITUTE(R[-1]C[1],"" "","""")))/2+HEX2DEC(RIGHT(INDEX(C,ROW()-1),6)),6)"
            End If
        End With
    End If
    VBATime False
End Sub

Sub Sort_Hacks_Alphabetically()
    Call Reveal_All_Hacks
    VBATime True
    Dim Code_Range As Range
    Dim Patch_Names() As String
    Dim Patch_Start() As Long
    Dim Patch_End() As Long
    Dim Sort_Index As Variant
    Dim Start_Row, End_Row, Current_Patch As Long
    Dim Last_Row As Long
    Dim a, b, c As Long
    Dim Temp_Patch As String
    Dim Current_Row As Long
    ReDim Patch_Names(1024)
    ReDim Patch_Start(1024)
    ReDim Patch_End(1024)
    Current_Patch = LBound(Patch_Names)
    Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False)
    With Code_Range
        For a = 1 To .Rows.Count
            If UCase(.Cells(a, 1).Value2) = "PATCH" Then
                Patch_Names(Current_Patch) = .Cells(a, 2).Value2
                Patch_Start(Current_Patch) = a
                If a > 1 Then Patch_End(Current_Patch - 1) = a - 1
                Current_Patch = Current_Patch + 1
            End If
        Next a
        Patch_End(Current_Patch - 1) = .Rows.Count + 2
        Sort_Index = Create_Sort_Index(Patch_Names, 1, False, False, False, LBound(Patch_Start), Current_Patch - 1)
        Dim Patch_Length As Long
        Start_Row = Code_Range.Row - 1
        Current_Row = Code_Range.Row
        For a = LBound(Sort_Index) To UBound(Sort_Index) - 1
            Patch_Length = Patch_End(Sort_Index(a)) - Patch_Start(Sort_Index(a)) + 1
            
            If Patch_Start(Sort_Index(a)) <> Current_Row Then
                Code_Sheet.Range(Code_Sheet.Cells(Patch_Start(Sort_Index(a)) + Start_Row, 1), Code_Sheet.Cells(Patch_End(Sort_Index(a)) + Start_Row, 1)).EntireRow.Cut
                Code_Sheet.Rows(Current_Row).Insert Shift:=xlDown
            End If
            Current_Row = Current_Row + Patch_Length
            For b = LBound(Sort_Index) To Sort_Index(a) - 1
                Patch_Start(b) = Patch_Start(b) + Patch_Length
                Patch_End(b) = Patch_End(b) + Patch_Length
            Next b
        Next a
    End With
    VBATime False
End Sub

Sub WipeHexBackup()
    VBATime True
    Dim Code_Range As Range
    Dim First_Row As Long, Last_Row As Long
    Dim a As Long
    Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False)
    First_Row = Code_Range.Row
    Last_Row = Code_Range.Rows.Count + First_Row - 1
    With Code_Range
        For a = First_Row To Last_Row
            If Len(.Cells(a, 6).Value2) Then .Cells(a, 6).ClearContents
        Next a
        .Columns(6).Hidden = True
    End With
    VBATime False
End Sub

Sub Release()
    If MsgBox("- All the formula results in the ""Calculations"" sheet will be discarded;" & vbCrLf & "- Anything under the Custom_Release() Sub will be performed." & vbCrLf & vbCrLf & "Proceed?", vbYesNo) = vbNo Then Exit Sub
    VBATime True
    Dim LastRow, FirstRow, LastCol, FirstCol As Long
    Dim Used_Range As Range
    With Calc_Sheet.Cells.SpecialCells(xlCellTypeLastCell)
        LastRow = .Row
        LastCol = .Column
    End With
    Set Used_Range = Range(Calc_Sheet.Cells(1, 1), Calc_Sheet.Cells(LastRow, LastCol))
    With Used_Range
        .Formula = .Formula
    End With
    On Error Resume Next
    Application.Run "Custom_Release"
    Tutorial_Sheet.Protect
    VBATime False
End Sub

Sub Find_Free_Space()
    If Not Import_Files_List Then Exit Sub
    
    Dim a As Long, b As Long, c As Long
    Dim Free_Space_Files(0 To 4) As Integer
    Dim Free_Space_Ranges(0 To 4, 0 To 1) As Long   'Start and End
    Dim Free_Space_Labels(0 To 4) As String
    Dim Kanji_Space(0 To 4) As Byte                 '0 = No Kanji / 1 = Kanji Graphics / 2 = Kanji Character Widths
    Dim Free_Space(0 To 4) As Free_Space
    'Dim Code_Range As Range
    'Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False)
    Dim Code_Data As Variant
    Code_Data = Trim_Range(Code_Sheet.Range("A:G"), True, False).Value2
    'Type 0 = Regular Data
    'Type 1 = Kanji Graphics
    'Type 2 = Kanji Widths
    With Free_Space(0)
        'SCUS_942.21 (0x8002705C to 0x8002873F)
        .Label = "SCUS Unused(?) Routines"
        .Type = 0
        .File_Match_ID = GetFileMatch("SCUS_942.21", False, True, False)
        .Start_Offset = 96348
        .End_Offset = 102208
    End With
    With Free_Space(1)
        'BATTLE.BIN  (0x8014E614 to 0x801612DB)
        .Label = "BATTLE.BIN Kanji Graphics"
        .Type = 1
        .File_Match_ID = GetFileMatch("BATTLE.BIN", False, True, False)
        .Start_Offset = 947732
        .End_Offset = 1024731
    End With
    With Free_Space(2)
        'BATTLE.BIN  (0x801660FC to 0x80166993)
        .Label = "BATTLE.BIN Kanji Widths (not recommended)"
        .Type = 2
        .File_Match_ID = GetFileMatch("BATTLE.BIN", False, True, False)
        .Start_Offset = 1044732
        .End_Offset = 1046931
    End With
    With Free_Space(3)
        'WORLD.BIN   (0x8013B8F8 to 0x8014E5BF)
        .Label = "WORLD.BIN Kanji Graphics"
        .Type = 1
        .File_Match_ID = GetFileMatch("WORLD\WORLD.BIN", False, True, False)
        .Start_Offset = 375032
        .End_Offset = 452031
    End With
    With Free_Space(4)
        'WORLD.BIN   (0x801533E0 to 0x80153C77)
        .Label = "WORLD.BIN Kanji Widths (not recommended)"
        .Type = 2
        .File_Match_ID = GetFileMatch("WORLD\WORLD.BIN", False, True, False)
        .Start_Offset = 472032
        .End_Offset = 474231
    End With
    
    Dim Free_Space_Characters(0 To 3, 0 To 1) As Integer
    Free_Space_Characters(0, 0) = 208:  Free_Space_Characters(0, 1) = 224   'Kanji
    Free_Space_Characters(1, 0) = 225:  Free_Space_Characters(1, 1) = 231   'Kanji
    Free_Space_Characters(2, 0) = 249:  Free_Space_Characters(2, 1) = 2053  'Kanji
    Free_Space_Characters(3, 0) = 2093: Free_Space_Characters(3, 1) = 2192  'Kanji
    
    Dim RFS_ID() As Integer, RFS_Ranges() As Long, UCount As Integer
    For a = LBound(Free_Space) To UBound(Free_Space)
        If Free_Space(a).Type > 0 Then
            UCount = UCount + UBound(Free_Space_Characters) - LBound(Free_Space_Characters) + 1
        Else
            UCount = UCount + 1
        End If
    Next a
    UCount = UCount - 1
    ReDim RFS_ID(LBound(Free_Space) To UCount)
    ReDim RFS_Ranges(LBound(Free_Space) To UCount, 0 To 1)
    Dim Current_R As Integer
    Dim Multiplier As Long
    Current_R = LBound(Free_Space)
    For a = LBound(Free_Space) To UBound(Free_Space)
        If Free_Space(a).Type > 0 Then
            Select Case Free_Space(a).Type
                Case 1: Multiplier = 35
                Case 2: Multiplier = 1
            End Select
            For b = LBound(Free_Space_Characters) To UBound(Free_Space_Characters)
                RFS_ID(Current_R) = a
                RFS_Ranges(Current_R, 0) = Free_Space(a).Start_Offset + Free_Space_Characters(b, 0) * Multiplier
                RFS_Ranges(Current_R, 1) = Free_Space(a).Start_Offset + Free_Space_Characters(b, 1) * Multiplier
                Current_R = Current_R + 1
            Next b
        Else
            RFS_ID(Current_R) = a
            RFS_Ranges(Current_R, 0) = Free_Space(a).Start_Offset
            RFS_Ranges(Current_R, 1) = Free_Space(a).End_Offset
            Current_R = Current_R + 1
        End If
    Next a

    Dim Free_File As Byte
    Dim Current_Row As Long, Location_Last_Row As Long
    Dim Current_Patch_Name As String, Current_Patch_File As String
    Dim Current_Offset As Long, Byte_Length As Long
    Dim Is_Data As Boolean, Character_Data As Boolean, Recognized_File As Boolean
    Dim Character_Data_Start As Long
    Dim Match_ID As Long
    Dim Current_Patch As Long, Current_Array As Long
    Dim Patch_ID(0 To 65535) As Integer, Patch_String(0 To 65535) As String
    Dim Patch_File(0 To 65535) As Integer
    Dim Patch_Memory(0 To 65535) As Boolean, Patch_Variable(0 To 65535) As Boolean
    Dim Patch_Start(0 To 65535) As Long, Patch_End(0 To 65535) As Long
    Dim Section_Type As String
    Dim Memory_Offset As Long
    Dim Used_Files() As Integer, Used_Files_Count As Integer
    Dim Verify_String As String
    Dim Last_Row As Long
    Current_Patch = -1
    Current_Array = -1
    
    Current_Row = LBound(Code_Data)
    Last_Row = UBound(Code_Data)
    
    Do While Current_Row < Last_Row
        Is_Data = False
        Section_Type = UCase(Code_Data(Current_Row, 1))
        Select Case Section_Type
            Case "PATCH":
                Current_Patch = Current_Patch + 1
                Patch_String(Current_Patch) = Code_Data(Current_Row, 2)
                Current_Row = Current_Row + 1
            Case "MEMLOCATION", "MEMLOCATION-1", "MEMLOCATION-2", "MEMLOCATION-3", "MEMLOCATION-4", "LOCATION":
                Is_Data = True
                Current_Patch_File = Code_Data(Current_Row, 3)
                Location_Last_Row = Last_Row
                For a = Current_Row + 1 To Last_Row
                    If Code_Data(a, 1) <> vbEmpty Then Location_Last_Row = a - 1: Exit For
                Next a
                Current_Offset = HexToDec(CStr(Code_Data(Current_Row, 4)))
                Byte_Length = 0
                For a = Current_Row To Location_Last_Row
                    Verify_String = CStr(Code_Data(a, 5))
                    If Verify_String <> "" Then
                        If IsHex(Verify_String) Then
                            Byte_Length = Byte_Length + Int((1 + Len(Replace(Verify_String, " ", ""))) / 2)
                        Else
                            Byte_Length = Byte_Length + 4
                        End If
                    End If
                Next a
                Current_Row = Location_Last_Row + 1
            Case "MEMVARIABLE":
                Is_Data = True
                Current_Patch_File = Code_Data(Current_Row, 3)
                Current_Offset = HexToDec(CStr(Code_Data(Current_Row, 4)))
                Byte_Length = Int((1 + Len(Replace(Code_Data(Current_Row, 5), " ", ""))) / 2)
                Current_Row = Current_Row + 1
            Case Else:
                For a = Current_Row + 1 To Last_Row
                    If Code_Data(a, 1) <> vbEmpty Then Current_Row = a: Exit For
                Next a
        End Select
        If Is_Data Then
            Current_Array = Current_Array + 1
            Select Case Section_Type
                Case "MEMLOCATION", "MEMLOCATION-1", "MEMLOCATION-2", "MEMLOCATION-3", "MEMLOCATION-4":
                    Patch_Memory(Current_Array) = True
                Case "MEMVARIABLE":
                    Patch_Memory(Current_Array) = True
                    Patch_Variable(Current_Array) = True
                Case "VARIABLE":
                    Patch_Variable(Current_Array) = True
            End Select
            Patch_ID(Current_Array) = Current_Patch
            Patch_File(Current_Array) = GetFileMatch(Current_Patch_File, True, True, True)
            If Patch_Memory(Current_Array) Then
                Memory_Offset = File_Offsets(Patch_File(Current_Array))
            Else
                Memory_Offset = 0
            End If
            Patch_Start(Current_Array) = Current_Offset - Memory_Offset
            Patch_End(Current_Array) = Current_Offset + Byte_Length - Memory_Offset
        End If
    Loop
    
    Is_Data = Is_Data
    'Used_Files = Sort_Array(Remove_Duplicates_From_Array(Patch_File, , , Current_Array))
    Used_Files = Sort_Array(Patch_File, Create_Sort_Index(Patch_File, 1, False, False, True, , Current_Array))

    Dim Free_Space_Start As Long, Free_Space_End As Long
    Dim File_ID As Variant
    Dim Data_End As Long
    Dim New_Index() As Integer, New_Patch_ID() As Integer, New_Patch_File() As Integer, Temp_Index() As Long, New_Patch_Start() As Long, New_Patch_End() As Long, Conflict() As Boolean, Temp_Patch_Start() As Long
    ReDim New_Index(Current_Array)
    ReDim New_Patch_ID(Current_Array)
    ReDim New_Patch_File(Current_Array)
    ReDim New_Patch_Start(Current_Array)
    ReDim New_Patch_End(Current_Array)
    ReDim Conflict(Current_Array)
    Dim Current_ID As Integer
    Dim ID_Start As Integer, ID_End As Integer, This_ID As Integer
    
    For Each File_ID In Used_Files
        ID_Start = Current_ID
        ID_End = Current_ID - 1
        For a = 0 To Current_Array
            If Patch_File(a) = File_ID Then
                ID_End = ID_End + 1
                New_Index(Current_ID) = a
                New_Patch_File(Current_ID) = File_ID
                Current_ID = Current_ID + 1
            End If
        Next a
        ReDim Temp_Patch_Start(ID_Start To ID_End)
        For a = ID_Start To ID_End
            Temp_Patch_Start(a) = Patch_Start(New_Index(a))
        Next a
        Temp_Index = Create_Sort_Index(Temp_Patch_Start, 1, False)
        For a = ID_Start To ID_End
            This_ID = New_Index(Temp_Index(a))
            New_Patch_ID(a) = Patch_ID(This_ID)
            New_Patch_File(a) = File_ID
            New_Patch_Start(a) = Patch_Start(This_ID)
            New_Patch_End(a) = Patch_End(This_ID)
        Next a
        For a = ID_Start To ID_End
            If New_Patch_ID(a) >= 0 Then
                For b = a + 1 To ID_End
                    If New_Patch_ID(b) = New_Patch_ID(a) Then
                        If New_Patch_Start(b) >= New_Patch_Start(a) And New_Patch_Start(b) <= New_Patch_End(a) Then
                            If New_Patch_End(b) > New_Patch_End(a) Then New_Patch_End(a) = New_Patch_End(b)
                            New_Patch_ID(b) = -1
                        Else
                            Exit For
                        End If
                    End If
                Next b
            End If
        Next a
    Next
    
    Dim Current_File_ID As Long
    For a = 0 To Current_Array - 1
        If New_Patch_ID(a) >= 0 Then
            Current_File_ID = New_Patch_File(a)
            For b = a + 1 To Current_Array
                If New_Patch_ID(b) >= 0 Then
                    If New_Patch_File(b) = Current_File_ID Then
                        If New_Patch_ID(a) <> New_Patch_ID(b) Then
                            If (New_Patch_Start(b) >= New_Patch_Start(a) And New_Patch_Start(b) < New_Patch_End(a)) Or (New_Patch_End(b) >= New_Patch_Start(a) And New_Patch_End(b) < New_Patch_End(a)) Then
                                Conflict(a) = True
                                Conflict(b) = True
                            Else
                                Exit For
                            End If
                        End If
                    Else
                        Exit For
                    End If
                End If
            Next b
        End If
    Next a

    Dim HTML_String As String
    Dim Current_File_String As String
    Dim Offset_Char As String, Offset_String As String
    Dim Free_Space_String As String: Free_Space_String = "~ Free Space ~"
    Dim Free_Space_Class As String: Free_Space_Class = "free"
    Dim Free_Space_Style As String: Free_Space_Style = ""
    Dim Conflict_Class As String: Conflict_Class = "conflict"
    Dim Conflict_Style As String: Conflict_Style = ""
    Dim Warning_Class As String: Warning_Class = "warning"
    Dim Warning_Style As String: Warning_Style = ""
    Dim CC As String, CS As String
    
    Dim Temp_Offset_1 As Long, Temp_Offset_2 As Long
    Current_File_ID = -1
    HTML_String = _
        "<html>" & vbCrLf & vbTab & "<head>" & vbCrLf & _
        vbTab & vbTab & "<title>" & ActiveWorkbook.Name & " Report</title>" & vbCrLf & _
        vbTab & vbTab & "<link rel=""stylesheet"" href=""http://xifanie.ffhacktics.com/Spreadsheet/Report.css"">" & vbCrLf & vbTab & "</head>" & vbCrLf & _
        vbTab & "<body>" & vbCrLf & _
        vbTab & vbTab & "<h1>" & ActiveWorkbook.Name & " Report</h1>" & vbCrLf & _
        vbTab & vbTab & "<hr />" & vbCrLf & _
        vbTab & vbTab & "<div id=""legend"">" & vbCrLf & _
        vbTab & vbTab & vbTab & "<div class=""free"">Free Space</div>" & vbCrLf & _
        vbTab & vbTab & vbTab & "<div class=""valid"">Valid</div>" & vbCrLf & _
        vbTab & vbTab & vbTab & "<div class=""conflict"">Conflicts with another hack</div>" & vbCrLf & _
        vbTab & vbTab & vbTab & "<div class=""warning"">Out of Bounds</div>" & vbCrLf & _
        vbTab & vbTab & "</div>" & vbCrLf & _
        vbTab & vbTab & "<h2>Free Space</h2>"
    HTML_String = HTML_String & ""
    Dim Start_Offset As Long, End_Offset As Long
    Dim Current_File As Integer
    Dim Current_RFS_ID As Integer
    Current_RFS_ID = -1
    For a = LBound(RFS_ID) To UBound(RFS_ID)
        Current_Offset = RFS_Ranges(a, 0)
        Start_Offset = RFS_Ranges(a, 0)
        End_Offset = RFS_Ranges(a, 1)
        Current_File_ID = Free_Space(RFS_ID(a)).File_Match_ID
        Memory_Offset = File_Offsets(Current_File_ID)
        If a > LBound(RFS_ID) Then HTML_String = HTML_String & vbCrLf & vbTab & vbTab & "</table>"
        If Current_RFS_ID <> RFS_ID(a) Then
            Current_RFS_ID = RFS_ID(a)
            HTML_String = HTML_String & vbCrLf & _
                vbTab & vbTab & "<div class=""section"">" & Free_Space(Current_RFS_ID).Label & "</div>"
        End If
        HTML_String = HTML_String & vbCrLf & _
            vbTab & vbTab & "<div class=""range"">0x8" & DecToHex(RFS_Ranges(a, 0) + Memory_Offset, 7) & " to 0x8" & DecToHex(RFS_Ranges(a, 1) + Memory_Offset - 1, 7) & "</div>" & vbCrLf & _
            vbTab & vbTab & "<table>"
        For b = 0 To Current_Array
            If New_Patch_ID(b) >= 0 And New_Patch_File(b) = Current_File_ID Then
                If (New_Patch_Start(b) >= Start_Offset And New_Patch_Start(b) <= End_Offset) Or (New_Patch_End(b) >= Start_Offset And New_Patch_End(b) <= End_Offset) Then
                    If Conflict(b) Then
                        CC = Conflict_Class
                        CS = Conflict_Style
                    ElseIf (New_Patch_Start(b) < Start_Offset Or New_Patch_End(b) > End_Offset) Then
                        CC = Warning_Class
                        CS = Warning_Style
                    Else
                        CC = ""
                        CS = ""
                    End If
                    If New_Patch_Start(b) > Current_Offset Then HTML_String = HTML_String & HTML_Table_Row(Current_Offset + Memory_Offset, New_Patch_Start(b) + Memory_Offset - 1, Free_Space_String, CBool(Memory_Offset), Free_Space_Class, Free_Space_Style)
                    HTML_String = HTML_String & HTML_Table_Row(New_Patch_Start(b) + Memory_Offset, New_Patch_End(b) + Memory_Offset - 1, Patch_String(New_Patch_ID(b)), CBool(Memory_Offset), CC, CS)
                    If New_Patch_End(b) > Current_Offset Then Current_Offset = New_Patch_End(b)
                End If
            End If
        Next b
        If End_Offset > Current_Offset Then HTML_String = HTML_String & HTML_Table_Row(Current_Offset + Memory_Offset, End_Offset + Memory_Offset - 1, Free_Space_String, CBool(Memory_Offset), Free_Space_Class, Free_Space_Style)
    Next a
    
    HTML_String = HTML_String & vbCrLf & _
        vbTab & vbTab & "</table>" & vbCrLf & vbCrLf & _
        vbTab & vbTab & "<h2>Used Space</h2>"
    
    Current_File_ID = -1
    For a = 0 To Current_Array
        If New_Patch_ID(a) >= 0 Then
            If New_Patch_File(a) <> Current_File_ID Then
                If a > 0 Then HTML_String = HTML_String & vbCrLf & vbTab & vbTab & "</table>"
                HTML_String = HTML_String & vbCrLf & _
                    vbTab & vbTab & "<div class=""section"">" & File_Full_Names(New_Patch_File(a)) & "</div>" & vbCrLf & _
                    vbTab & vbTab & "<table>"
                Current_File_ID = New_Patch_File(a)
                Memory_Offset = File_Offsets(Current_File_ID)
            End If
            If Conflict(a) Then
                CC = Conflict_Class
                CS = Conflict_Style
            Else
                CC = ""
                CS = ""
            End If
            HTML_String = HTML_String & HTML_Table_Row(New_Patch_Start(a) + Memory_Offset, New_Patch_End(a) + Memory_Offset - 1, Patch_String(New_Patch_ID(a)), CBool(Memory_Offset), CC, CS)
        End If
    Next a

    HTML_String = HTML_String & vbCrLf & _
        vbTab & vbTab & "</table>" & vbCrLf & _
        vbTab & "</body>" & vbCrLf & _
        "</html>"
    
    Dim objStream
    Set objStream = CreateObject("ADODB.Stream")
    objStream.Charset = "utf-8"
    objStream.Open
    objStream.WriteText HTML_String
    objStream.SaveToFile ActiveWorkbook.path & "\Report.html", 2
    objStream.Close
    Call ShellExecute(0, "Open", ActiveWorkbook.path & "\Report.html")

End Sub

Private Function HTML_Table_Row(Offset_Start As Long, Offset_End As Long, Offset_String As String, Optional Memory_Address As Boolean = False, Optional CSS_Class As String = "", Optional CSS_Style As String = "") As String
    HTML_Table_Row = vbCrLf & vbTab & vbTab & vbTab & "<tr"
    If Len(CSS_Class) Then HTML_Table_Row = HTML_Table_Row & " class=""" & CSS_Class & """"
    If Len(CSS_Style) Then HTML_Table_Row = HTML_Table_Row & " style=""" & CSS_Style & """"
    HTML_Table_Row = HTML_Table_Row & ">" & vbCrLf & _
        vbTab & vbTab & vbTab & vbTab & "<td>"
    If Memory_Address Then
        HTML_Table_Row = HTML_Table_Row & "0x8"
    Else
        HTML_Table_Row = HTML_Table_Row & "0x0"
    End If
    HTML_Table_Row = HTML_Table_Row & DecToHex(Offset_Start, 7)
    If Offset_End <> Offset_Start Then
        HTML_Table_Row = HTML_Table_Row & " - "
        If Memory_Address Then
            HTML_Table_Row = HTML_Table_Row & "0x8"
        Else
            HTML_Table_Row = HTML_Table_Row & "0x0"
        End If
        HTML_Table_Row = HTML_Table_Row & DecToHex(Offset_End, 7)
    End If
    Dim Plural As String
    If Offset_End <> Offset_Start Then Plural = "s"
    HTML_Table_Row = HTML_Table_Row & "</td>" & vbCrLf & _
    vbTab & vbTab & vbTab & vbTab & "<td>" & Offset_End - Offset_Start + 1 & " byte" & Plural & "</td>" & vbCrLf & _
    vbTab & vbTab & vbTab & vbTab & "<td>" & Offset_String & "</td>" & vbCrLf & _
    vbTab & vbTab & vbTab & "</tr>"
End Function

Public Function bAND(Variable_A As Long, Variable_B As Long) As Long
    Dim Temp_A As Long, Temp_B As Long
    Temp_A = Variable_A
    Temp_B = Variable_B
    Dim a As Long
    For a = 0 To 30
        If Temp_A Mod 2 = 1 And Temp_B Mod 2 = 1 Then bAND = bAND + 2 ^ a
        Temp_A = Int(Temp_A / 2)
        Temp_B = Int(Temp_B / 2)
    Next a
End Function

Public Function bOR(Variable_A As Long, Variable_B As Long) As Long
    Dim Temp_A As Long, Temp_B As Long
    Temp_A = Variable_A
    Temp_B = Variable_B
    Dim a As Long
    For a = 0 To 30
        If Temp_A Mod 2 = 1 Or Temp_B Mod 2 = 1 Then bOR = bOR + 2 ^ a
        Temp_A = Int(Temp_A / 2)
        Temp_B = Int(Temp_B / 2)
    Next a
End Function

Public Function bXOR(Variable_A As Long, Variable_B As Long) As Long
    Dim Temp_A As Long, Temp_B As Long
    Temp_A = Variable_A
    Temp_B = Variable_B
    Dim a As Long
    For a = 0 To 30
        If (Temp_A Mod 2 + Temp_B Mod 2) = 1 Then bXOR = bXOR + 2 ^ a
        Temp_A = Int(Temp_A / 2)
        Temp_B = Int(Temp_B / 2)
    Next a
End Function

Public Function bNOT(Variable_A As Long, Variable_B As Long) As Long
    Dim Temp_A As Long, Temp_B As Long
    Temp_A = Variable_A
    Temp_B = Variable_B
    Dim a As Long
    For a = 0 To 30
        If Temp_A Mod 2 = 0 And Temp_B Mod 2 = 0 Then bNOT = bNOT + 2 ^ a
        Temp_A = Int(Temp_A / 2)
        Temp_B = Int(Temp_B / 2)
    Next a
End Function

Public Sub Resize_Table(Table As ListObject, New_Row_Count As Long)
    If New_Row_Count < 1 Then New_Row_Count = 1
    Dim TableSheet As Worksheet
    Set TableSheet = Table.Parent
    TableSheet.Unprotect
    With Table
        If .ListRows.Count > New_Row_Count Then
            .DataBodyRange.Rows(New_Row_Count + 1 & ":" & .ListRows.Count).Delete
        ElseIf .ListRows.Count < New_Row_Count Then
            .Resize Range(Range(.Range.Cells(1, 1), .Range.Cells(New_Row_Count + .ListRows.Count - .DataBodyRange.Rows.Count, .DataBodyRange.Columns.Count)).Address)
        End If
    End With
End Sub

Public Function Reverse_Signs(Opcode As String) As String
    On Error GoTo FunctionFail
    Dim Space_Pos As Long
    Space_Pos = InStr(2, Opcode, " ")
    If Space_Pos = 0 Then GoTo FunctionFail
    Select Case Left(Opcode, Space_Pos - 1)
        Case "addi", "addiu", "slti", "sltiu", "lb", "lh", "lwl", "lw", "lbu", "lhu", "lwr", "sb", "sh", "swl", "sw", "swr", "LWC1", "LWC2", "LWC3", "SWC1", "SWC2", "SWC3"
            Dim Hex_Pos As Long
            Hex_Pos = InStr(Space_Pos, Opcode, "0x")
            If Hex_Pos = 0 Then GoTo FunctionFail
            Dim Hex_Length As Long
            Dim a As Long
            For a = Hex_Pos + 2 To Len(Opcode)
                Select Case UCase(Mid(Opcode, a, 1))
                    Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F":
                        Hex_Length = Hex_Length + 1
                    Case Else
                        Exit For
                End Select
            Next a
            Dim Hex_End As Long, Hex_Start As Long
            Hex_End = 2 + Hex_Length + Hex_Pos
            Dim Decimal_Value As Long
            Decimal_Value = "&H0" & Mid(Opcode, Hex_Pos + 2, Hex_Length)
            'Decimal_Value = 65536 - Decimal_Value
            Dim New_Sign As String
            Select Case Mid(Opcode, Hex_Pos - 1, 1)
                Case "-"
                    Hex_Start = Hex_Pos - 1
                    New_Sign = ""
                    Decimal_Value = 65536 - Decimal_Value
                Case "+"
                    Hex_Start = Hex_Pos - 1
                Case Else
                    Hex_Start = Hex_Pos
            End Select
            Select Case Mid(Opcode, Hex_Pos - 1, 1)
                Case "-"
                
                Case Else
                    If Decimal_Value >= 32768 Then
                        Decimal_Value = 65536 - Decimal_Value
                        New_Sign = "-"
                    Else
                        GoTo FunctionFail
                    End If
            End Select
            Reverse_Signs = Left(Opcode, Hex_Start - 1) & New_Sign & "0x" & DecToHex(Decimal_Value, 4) & Mid(Opcode, Hex_End)
            Exit Function
    End Select
    
FunctionFail:
    Reverse_Signs = Opcode
End Function

Public Sub Reverse_Signs_Selection()
    Dim New_String As String
    Dim cell
    For Each cell In Selection
        New_String = Reverse_Signs(cell.Value2)
        If New_String <> cell.Value2 Then cell.Value2 = New_String
    Next
End Sub

Public Sub Clear_Code(First_Row As Long, Last_Row As Long)
    Dim a As Long
    With Code_Sheet
        .Range(.Cells(First_Row, 1), .Cells(Last_Row, 7)).Clear
        With .Range("A:A")
            .HorizontalAlignment = xlLeft
            .IndentLevel = 1
            .FormatConditions.Delete
            With .FormatConditions _
                .Add(xlCellValue, xlEqual, "=""""")
            End With
            With .FormatConditions _
                .Add(xlCellValue, xlEqual, "PATCH")
                .Interior.ColorIndex = 37
                .Font.Bold = True
            End With
            With .FormatConditions _
                .Add(xlCellValue, xlEqual, "DESCRIPTION")
                .Interior.ColorIndex = 42
                .Font.Bold = True
            End With
            With .FormatConditions _
                .Add(xlCellValue, xlEqual, "COMMENT")
                .Interior.ColorIndex = 26
                .Font.Bold = True
            End With
            With .FormatConditions _
                .Add(xlTextString, String:="MEMLOCATION", TextOperator:=xlBeginsWith)
                .Interior.ColorIndex = 44
                .Font.Bold = True
            End With
            With .FormatConditions _
                .Add(xlTextString, String:="MEMVARIABLE", TextOperator:=xlBeginsWith)
                .Interior.ColorIndex = 45
                .Font.Bold = True
            End With
            With .FormatConditions _
                .Add(xlTextString, String:="LOCATION", TextOperator:=xlBeginsWith)
                .Interior.ColorIndex = 18
                .Font.Bold = True
            End With
            With .FormatConditions _
                .Add(xlTextString, String:="VARIABLE", TextOperator:=xlBeginsWith)
                .Interior.ColorIndex = 21
                .Font.Bold = True
            End With
        End With
        With .Range("A:G")
            .Columns(2).NumberFormat = "General"
            .Columns(3).Font.Bold = True
            .Columns(4).Font.Bold = True
            .Columns(3).HorizontalAlignment = xlCenter
            .Columns(4).HorizontalAlignment = xlCenter
            .Columns(6).Hidden = False
            .Range(.Cells(First_Row, 1), .Cells(Last_Row, 1)).RowHeight = 15
        End With
    End With
End Sub

Public Function Create_Sort_Index(Array_To_Sort As Variant, Optional Sort_Type As Integer = 0, Optional Case_Sensitive = True, Optional Ignore_Null As Boolean = False, Optional Ignore_Duplicates As Boolean = False, Optional Array_Start As Long = -1, Optional Array_End As Long = -1) As Variant
    Dim Result() As Long
    Dim Skip() As Boolean
    Dim Null_Value As Variant
    Dim Might_Be_String As Boolean
    Dim Is_String As Boolean
    Select Case VarType(Array_To_Sort)
        Case 8203, 8209, 8194, 8195, 8196, 8197, 8198, 8199 'Boolean, Byte, Integer, Long, Single, Double, Currency, Date
            Null_Value = CLng(0)
        Case 8200                                           'String
            Null_Value = CStr("")
            Is_String = True
        Case Else                                           'Variant and everything else
            Null_Value = CBool(False)
            Might_Be_String = True
    End Select
    Dim a As Long, b As Long, c As Long
    Dim OLBound As Long, OUBound As Long
    If Array_Start <> -1 Then
        OLBound = Array_Start
    Else
        OLBound = LBound(Array_To_Sort)
    End If
    If Array_End <> -1 Then
        OUBound = Array_End
    Else
        OUBound = UBound(Array_To_Sort)
    End If
    ReDim Skip(OLBound To OUBound)
    Dim Current_Result As Long
    Dim Instance_Count As Long
    Dim Current_Position As Long
    Dim Temp_Position As Long
    Dim Skip_Count As Long
    Dim Duplicate_Count As Long
    Current_Result = OLBound
    Temp_Position = OLBound
    Current_Position = OLBound
    Dim Check_Value As Variant, Current_Value As Variant
    If Ignore_Null Then
        For a = OLBound To OUBound
            If Array_To_Sort(a) = Null_Value Then Skip(a) = True: Skip_Count = Skip_Count + 1
        Next a
    End If
    If Ignore_Duplicates Then
        For a = OLBound To OUBound
            If Not Skip(a) Then
                Current_Value = Array_To_Sort(a)
                If Not Case_Sensitive And (Is_String Or (Might_Be_String And VarType(Check_Value) = 8)) Then Current_Value = LCase(Current_Value)
                For b = a + 1 To OUBound
                    Check_Value = Array_To_Sort(b)
                    If Not Case_Sensitive And (Is_String Or (Might_Be_String And VarType(Check_Value) = 8)) Then Check_Value = LCase(Check_Value)
                    If Current_Value = Check_Value Then Skip(b) = True: Skip_Count = Skip_Count + 1
                Next b
            End If
        Next a
    End If
    If Skip_Count > OUBound - OLBound Then Exit Function
    ReDim Result(OLBound To OUBound - Skip_Count)
    
    If Sort_Type = 0 Then
        Current_Position = OLBound
        For a = OLBound To OUBound
            If Not Skip(a) Then
                Result(Current_Position) = a
                Current_Position = Current_Position + 1
            End If
        Next a
    Else
        For a = OLBound To OUBound
            For b = OLBound To OUBound
                If Not Skip(b) Then
                    If Temp_Position = Current_Position Then Current_Result = b
                    Check_Value = Array_To_Sort(b)
                    Current_Value = Array_To_Sort(Current_Result)
                    If Not Case_Sensitive And (Is_String Or (Might_Be_String And VarType(Check_Value) = 8 And VarType(Current_Value) = 8)) Then
                        Check_Value = LCase(Check_Value)
                        Current_Value = LCase(Current_Value)
                    End If
                    If Sort_Type = 0 Or (Sort_Type = 1 And Check_Value < Current_Value) Or (Sort_Type = -1 And Check_Value > Current_Value) Then
                        Current_Result = b
                        Temp_Position = Current_Position
                        Result(Temp_Position) = b
                        Temp_Position = Temp_Position + 1
                    ElseIf Check_Value = Current_Value Then
                        Result(Temp_Position) = b
                        Temp_Position = Temp_Position + 1
                    End If
                End If
            Next b
            For b = Current_Position To Temp_Position - 1
                Skip(Result(b)) = True
            Next b
            Current_Position = Temp_Position
        Next a
    End If
    Create_Sort_Index = Result
End Function

Public Function Sort_Array(Array_To_Sort As Variant, Sort_Index As Variant) As Variant
    Dim Result As Variant
    Result = Array_To_Sort
    Dim a As Long, b As Long, c As Long
    Dim OLBound As Long, OUBound As Long
    OLBound = LBound(Sort_Index)
    OUBound = UBound(Sort_Index)
    For a = OLBound To OUBound
        Result(a) = Array_To_Sort(Sort_Index(a))
    Next a
    ReDim Preserve Result(LBound(Sort_Index) To UBound(Sort_Index))
    Sort_Array = Result
End Function

Public Function Get_Ascending_Match(Search_Value As Variant, Search_Array As Variant) As Long
    Dim Array_Length As Long
    Array_Length = UBound(Search_Array) - LBound(Search_Array) + 1
    Dim Dividend As Long, Divisor As Long
    Dim a As Long
    Dividend = 1
    Divisor = 2
    Dim Current_ID As Long
    
    Get_Ascending_Match = -1
    Do
        Current_ID = Int(Array_Length * Dividend / Divisor)
        If Search_Value < Search_Array(Current_ID) Then
            Dividend = Dividend * 2 - 1
            Divisor = Divisor * 2
        ElseIf Search_Value > Search_Array(Current_ID) Then
            Dividend = Dividend * 2 + 1
            Divisor = Divisor * 2
        Else
            Get_Ascending_Match = Current_ID
            Exit Do
        End If
        If Int(Array_Length * Dividend / Divisor) = Current_ID Then Exit Do
    Loop While True
End Function

Public Function Table_Intersect(Table As ListObject) As Range
    If Table.Parent.Name <> ActiveSheet.Name Then Exit Function
    Dim Selection_Range As Range
    Set Selection_Range = Selection
    Dim Table_Range As Range
    Set Table_Range = Range(Table.DataBodyRange.Address)
    Dim Top_Table As Long, Right_Table As Long, Bottom_Table As Long, Left_Table As Long
    Dim Top_Selection As Long, Right_Selection As Long, Bottom_Selection As Long, Left_Selection As Long
    Top_Table = Table_Range.Row
    Bottom_Table = Top_Table + Table_Range.Rows.Count - 1
    Left_Table = Table_Range.Column
    Right_Table = Left_Table + Table_Range.Columns.Count - 1
    Top_Selection = Selection.Row
    Bottom_Selection = Top_Selection + Selection.Rows.Count - 1
    Left_Selection = Selection.Column
    Right_Selection = Left_Selection + Selection.Columns.Count - 1
    If Top_Selection >= Top_Table And Top_Selection <= Bottom_Table Then
        If Bottom_Selection >= Top_Table And Bottom_Selection <= Bottom_Table Then
            If Left_Selection >= Left_Table And Left_Selection <= Right_Table Then
                If Right_Selection >= Left_Table And Right_Selection <= Right_Table Then
                    Set Table_Intersect = Range(Cells(Top_Selection - Top_Table + 1, Left_Selection - Left_Table + 1), Cells(Bottom_Selection - Top_Table + 1, Right_Selection - Left_Table + 1))
                End If
            End If
        End If
    End If
End Function

Public Function Remove_XML_Comments(XML_Data As String) As String
    Remove_XML_Comments = XML_Data
    Dim Last_Position As Long
    Dim Tag_Start As Long, Tag_End As Long
    Last_Position = 1
    Do
        Tag_Start = 0
        Tag_End = 0
        Tag_Start = InStr(Last_Position, Remove_XML_Comments, "<!--")
        Tag_End = InStr(Tag_Start + 4, Remove_XML_Comments, "-->")
        If Tag_Start > 0 Then
            If Tag_End > 0 Then
                Remove_XML_Comments = Left(Remove_XML_Comments, Tag_Start) & Space(Tag_End - Tag_Start + 3) & Mid(Remove_XML_Comments, Tag_End + 4)
            Else
                Remove_XML_Comments = Left(Remove_XML_Comments, Tag_Start) & Space(Len(XML_Data) - Tag_Start)
                Exit Do
            End If
        Else
            Exit Do
        End If
        Last_Position = Tag_End + 3
    Loop
End Function

Public Function Get_XML_Tags(XML_Data As String) As XML_Level
    ReDim Get_XML_Tags.XML_Entry(0 To 255)
    Dim Commentless_Data As String
    Dim Result() As String
    Dim Parameter_Names() As String
    Dim Parameter_Values() As String
    Dim Tag_Start As Long, Tag_Start2, Tag_End As Long
    Commentless_Data = Remove_XML_Comments(XML_Data)
    Dim Last_Position As Long
    Dim Array_Count As Long
    Last_Position = 1
    Array_Count = 0
    ReDim Result(0 To 63)
    ReDim Parameter_Names(0 To 63)
    ReDim Parameter_Values(0 To 63)
    Dim Opened_Quotes As Boolean
    Dim Quote_String As String
    Dim Parameter_Step As Byte
    Dim Parameter_Count As Long
    Dim Tag_String As String
    Dim Parameter_String As String
    Dim Current_Position As Long
    Current_Position = 1
    Dim Current_Tag As Long
    Dim Tag_Ended As Boolean
    Dim First_Tag_End As Long
    Current_Tag = 0
    Do
        Tag_Start = 0
        Tag_Start = InStr(Current_Position, XML_Data, "<")
        If Tag_Start = 0 Then Exit Do
        Opened_Quotes = False
        Parameter_Step = 0
        First_Tag_End = Tag_Start
        Current_Position = Tag_Start + 1
        Dim a As Long
Retry_Parsing:
        If Mid(XML_Data, Current_Position, 3) = "!--" Then
            Tag_End = InStr(Tag_Start, XML_Data, "-->")
            If Tag_End = 0 Then Exit Do
            Get_XML_Tags.XML_Entry(Current_Tag).Contents = Mid(XML_Data, Tag_Start + 4, Tag_End - Tag_Start - 4)
            Get_XML_Tags.XML_Entry(Current_Tag).Name = "!--"
            Current_Tag = Current_Tag + 1
            Current_Position = Tag_End + 3
            GoTo DontAddTag
        Else
            Select Case Mid(XML_Data, Current_Position, 1)
                Case "?"
                    Tag_End = InStr(Current_Position, XML_Data, ">")
                    If Tag_End = 0 Then
                        Current_Position = Len(XML_Data)
                    Else
                        Current_Position = Tag_End
                    End If
                    GoTo DontAddTag
                Case "/", ">"
                    Current_Position = Current_Position + 1
                    GoTo DontAddTag
            End Select
        End If
        Tag_String = ""
        Parameter_Count = 0
        Parameter_String = ""
        Tag_Ended = False
        Do
            If Opened_Quotes Then
                Select Case Mid(XML_Data, Current_Position, 1)
                    Case """"
                        Opened_Quotes = False
                        If Parameter_Step = 2 And Len(Parameter_String) Then
                            Parameter_Names(Parameter_Count) = Parameter_String
                            Parameter_Values(Parameter_Count) = Quote_String
                            Parameter_Count = Parameter_Count + 1
                            Parameter_String = ""
                            Parameter_Step = 0
                        End If
                    Case Else
                        Quote_String = Quote_String & Mid(XML_Data, Current_Position, 1)
                End Select
            Else
                Select Case Mid(XML_Data, Current_Position, 1)
                    Case " "
                        Parameter_Step = Application.Max(1, Parameter_Step)
                        Tag_Ended = True
                    Case "="
                        Parameter_Step = 2
                    Case ">"
                        Current_Position = Current_Position + 1
                        First_Tag_End = Current_Position
                        If Mid(XML_Data, Current_Position - 2, 1) = "/" Then GoTo Self_Close
                        Exit Do
                    Case "<"
                        Current_Position = Current_Position + 1
                        GoTo Retry_Parsing
                    Case """"
                        Opened_Quotes = True
                        Quote_String = ""
                    Case Else
                        If Parameter_Step = 0 Then
                            If Not Tag_Ended Then Tag_String = Tag_String & Mid(XML_Data, Current_Position, 1)
                        Else
                            Parameter_String = Parameter_String & Mid(XML_Data, Current_Position, 1)
                        End If
                End Select
            End If
            Current_Position = Current_Position + 1
            If Tag_String = "Variable" Then
                Tag_String = Tag_String
            End If
        Loop
        Tag_End = InStr(Current_Position, XML_Data, "</" & Tag_String & ">")
        If Tag_End = 0 Then Exit Do
        Get_XML_Tags.XML_Entry(Current_Tag).Contents = Mid(XML_Data, Current_Position, Tag_End - Current_Position)
        Get_XML_Tags.XML_Entry(Current_Tag).Close_Tag = Mid(XML_Data, Tag_End, Len(Tag_String) + 3)
        Current_Position = Tag_End + Len(Tag_String) + 3
Self_Close:
        Get_XML_Tags.XML_Entry(Current_Tag).Open_Tag = Mid(XML_Data, Tag_Start, First_Tag_End - Tag_Start)
        With Get_XML_Tags.XML_Entry(Current_Tag)
            .Name = Tag_String
            '.Contents = Mid(XML_Data, Current_Position, Tag_End - Current_Position)
            If Parameter_Count > 0 Then
                ReDim .Parameters(0 To Parameter_Count - 1)
                For a = 0 To Parameter_Count - 1
                    .Parameters(a).Name = Parameter_Names(a)
                    .Parameters(a).Value = Parameter_Values(a)
                Next a
            End If
        End With
        Current_Tag = Current_Tag + 1
DontAddTag:
    Loop
    If Current_Tag = 0 Then
        Erase Get_XML_Tags.XML_Entry
    Else
        ReDim Preserve Get_XML_Tags.XML_Entry(0 To Current_Tag - 1)
    End If
End Function

Public Function Get_XML_Parameters(XML_Tag As XML_Tag, Parameter_Name As String, Optional Default_Value As String = "") As String
    Get_XML_Parameters = Default_Value
    On Error GoTo Error
    Dim a As Long
    With XML_Tag
        For a = LBound(.Parameters) To UBound(.Parameters)
            If .Parameters(a).Name = Parameter_Name Then Get_XML_Parameters = .Parameters(a).Value: Exit For
        Next a
    End With
    Exit Function
Error:
    Get_XML_Parameters = Default_Value
End Function

Public Sub Import_XML()
    If Not Import_Files_List Then Exit Sub
    Dim XML_Files As Variant
    Dim RegPath As String
    Dim FilePath As String
    Dim FolderFromPath As String
    RegPath = RegFolder & "Last XML"
    FilePath = ReadReg(RegPath, ActiveWorkbook.path)
    If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
    If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
    VBATime True
    XML_Files = Application.GetOpenFilename(FileFilter:="FFTOrgASM Patch File (*.xml), *.xml", Title:="Select .xml file(s)", MultiSelect:=True)
    If VarType(XML_Files) <> 8204 Then Exit Sub
    Call WriteReg(RegPath, CStr(XML_Files(1)))
    Dim iFile As Integer: iFile = FreeFile
    Dim a As Long, b As Long, c As Long, d As Long, e As Long, f As Long
    If MsgBox("Would you like to clear all existing hacks before importing?", vbYesNo) = vbYes Then Clear_Code 1, 1048576
    
    Dim Hack_List As Hack_List
    Dim XML_File
    Dim XML_Contents As String
    Dim Patches As XML_Level
    Dim Patch As XML_Level
    Dim Patch_Entries As XML_Level
    Dim Location_Lines As Data_and_Comments
    Dim Opcode_Start As Long, Opcode_Length As Long
    Dim Comment_Start As Long
    Dim Comment_End As Long
    Dim Comment As Boolean
    Dim Parse_String As String
    Dim Memory_Offset As Long
    Dim Decoded_Opcode As Decoded
    Dim Comments() As String
    Dim String_Sector As String
    Dim Hack_Count As Long, Patch_Object_Count As Long, Comment_Count As Long, Location_Count As Long, Variable_Count As Long
    Hack_Count = -1: Patch_Object_Count = -1: Comment_Count = -1: Location_Count = -1: Variable_Count = -1
    With Hack_List
        ReDim .Hacks(0 To 65535)
        ReDim .Patch_Objects(0 To 65535)
        ReDim Comments(0 To 65535)
        ReDim .Locations(0 To 65535)
        ReDim .Variables(0 To 65535)
        For Each XML_File In XML_Files
            'XML_File = "C:\ISO\Final Fantasy Tactics\FFTPatcher .489\Choto.xml"
            Open CStr(XML_File) For Input As #iFile
            XML_Contents = Input(LOF(iFile), iFile)
            Patches = Get_XML_Tags(XML_Contents)
            On Error GoTo Next_File
            For a = LBound(Patches.XML_Entry) To UBound(Patches.XML_Entry)
                If LCase(Patches.XML_Entry(a).Name) = "patches" Then
                    Patch = Get_XML_Tags(Patches.XML_Entry(a).Contents)
                    On Error GoTo Next_a
                    For b = LBound(Patch.XML_Entry) To UBound(Patch.XML_Entry)
                        If LCase(Patch.XML_Entry(b).Name) = "patch" Then
                            Patch_Entries = Get_XML_Tags(Patch.XML_Entry(b).Contents)
                            On Error GoTo Next_b
                            Hack_Count = Hack_Count + 1
                            .Hacks(Hack_Count).Name = Get_XML_Parameters(Patch.XML_Entry(b), "name", "")
                            .Hacks(Hack_Count).First = Patch_Object_Count + 1
                            For c = LBound(Patch_Entries.XML_Entry) To UBound(Patch_Entries.XML_Entry)
                                Select Case LCase(Patch_Entries.XML_Entry(c).Name)
                                    Case "description"
                                        .Hacks(Hack_Count).Description = Patch_Entries.XML_Entry(c).Contents
                                    Case "variable"
                                        Patch_Object_Count = Patch_Object_Count + 1
                                        Variable_Count = Variable_Count + 1
                                        .Patch_Objects(Patch_Object_Count).Type = 2
                                        .Patch_Objects(Patch_Object_Count).File_ID = CLng(GetFileMatch(Get_XML_Parameters(Patch_Entries.XML_Entry(c), "file", "-1"), False, False, True))
                                        String_Sector = Get_XML_Parameters(Patch_Entries.XML_Entry(c), "sector")
                                        If String_Sector = "" Then
                                            .Patch_Objects(Patch_Object_Count).Sector = -1
                                        Else
                                            .Patch_Objects(Patch_Object_Count).Sector = "&H" & String_Sector
                                        End If
                                        .Patch_Objects(Patch_Object_Count).Variable = True
                                        .Patch_Objects(Patch_Object_Count).Start_Location = Variable_Count
                                        .Patch_Objects(Patch_Object_Count).End_Location = Variable_Count
                                        Memory_Offset = File_Offsets(.Patch_Objects(Patch_Object_Count).File_ID)
                                        If Memory_Offset > 0 Then .Patch_Objects(Patch_Object_Count).Memory = True
                                        Memory_Offset = Memory_Offset + CLng("&H" & Get_XML_Parameters(Patch_Entries.XML_Entry(c), "offset", "0"))
                                        .Variables(Variable_Count).Offset = Memory_Offset
                                        .Variables(Variable_Count).Bytes = CByte(Get_XML_Parameters(Patch_Entries.XML_Entry(c), "bytes", "1"))
                                        .Variables(Variable_Count).Hex_String = Right("00000000" & Get_XML_Parameters(Patch_Entries.XML_Entry(c), "default", DecToHex(0, .Variables(Variable_Count).Bytes * 2)), .Variables(Variable_Count).Bytes * 2)
                                        .Variables(Variable_Count).Name = Get_XML_Parameters(Patch_Entries.XML_Entry(c), "name", "???")
                                    Case "location"
                                        Patch_Object_Count = Patch_Object_Count + 1
                                        .Patch_Objects(Patch_Object_Count).Type = 1
                                        .Patch_Objects(Patch_Object_Count).File_ID = CLng(GetFileMatch(Get_XML_Parameters(Patch_Entries.XML_Entry(c), "file", "-1"), False, False, True))
                                        String_Sector = Get_XML_Parameters(Patch_Entries.XML_Entry(c), "sector")
                                        If String_Sector = "" Then
                                            .Patch_Objects(Patch_Object_Count).Sector = -1
                                        Else
                                            .Patch_Objects(Patch_Object_Count).Sector = "&H" & String_Sector
                                        End If
                                        If .Patch_Objects(Patch_Object_Count).File_ID = -1 Then .Patch_Objects(Patch_Object_Count).File_ID = GetFileMatch("", False, False, False, .Patch_Objects(Patch_Object_Count).Sector)
                                        If .Patch_Objects(Patch_Object_Count).File_ID > -1 Or .Patch_Objects(Patch_Object_Count).Sector > -1 Then
                                            Memory_Offset = 0
                                            If .Patch_Objects(Patch_Object_Count).File_ID > -1 Then
                                                Memory_Offset = File_Offsets(.Patch_Objects(Patch_Object_Count).File_ID)
                                                If Memory_Offset > 0 Then .Patch_Objects(Patch_Object_Count).Memory = True
                                            End If
                                            Memory_Offset = Memory_Offset + CLng("&H" & Get_XML_Parameters(Patch_Entries.XML_Entry(c), "offset", "0"))
                                            .Patch_Objects(Patch_Object_Count).Start_Location = Location_Count + 1
                                            Location_Lines = Trim_Array_Whites(Split(Patch_Entries.XML_Entry(c).Contents, vbLf))
                                            Comment = False
                                            For d = LBound(Location_Lines.Data) To UBound(Location_Lines.Data)
                                                Parse_String = Location_Lines.Data(d)
                                                
                                                If Len(Parse_String) Then
                                                    Opcode_Start = 0
                                                    Opcode_Length = 0
                                                    For e = 1 To Len(Location_Lines.Data(d))
                                                        Select Case Mid(Location_Lines.Data(d), e, 1)
                                                            Case vbTab, " "
                                                            
                                                            Case Else
                                                                Opcode_Start = e
                                                                For f = e To Len(Location_Lines.Data(d))
                                                                    Select Case Mid(Location_Lines.Data(d), f, 1)
                                                                        Case vbCr, vbTab
                                                                            Exit For
                                                                        Case Else
                                                                            Opcode_Length = Opcode_Length + 1
                                                                    End Select
                                                                Next f
                                                                Exit For
                                                        End Select
                                                    Next e
                                                Else
                                                    Opcode_Length = 0
                                                End If
                                                If Opcode_Length Then
                                                    Location_Count = Location_Count + 1
                                                    .Locations(Location_Count).Raw_String = Smart_Trim(Parse_String)
                                                    .Locations(Location_Count).Offset = Memory_Offset
                                                    Decoded_Opcode = Decode(.Locations(Location_Count).Raw_String, Memory_Offset)
                                                    .Locations(Location_Count).Destination = Decoded_Opcode.Destination
                                                    If Not IsHex(Decoded_Opcode.String) Then
                                                        '.Locations(Location_Count).String = Decoded_Opcode.String
                                                        Memory_Offset = Memory_Offset + 4
                                                    Else
                                                        Memory_Offset = Memory_Offset + Int((Len(Decoded_Opcode.String) + 1) / 2)
                                                    End If
                                                    .Locations(Location_Count).Comment = Location_Lines.Comment(d)
                                                End If
        
                                            Next d
                                            Location_Count = Location_Count + 1
                                            .Patch_Objects(Patch_Object_Count).End_Location = Location_Count
                                        End If
                                    Case "!--"
                                        Patch_Object_Count = Patch_Object_Count + 1
                                        .Patch_Objects(Patch_Object_Count).Type = 255
                                        .Patch_Objects(Patch_Object_Count).Comment = Patch_Entries.XML_Entry(c).Contents
                                    Case ""
                                    
                                End Select
                            Next c
                            .Hacks(Hack_Count).Last = Patch_Object_Count
                            'Debug.Print Get_XML_Parameters(Patch.XML_Entry(b), "name")
                        End If
Next_b:
                        On Error GoTo 0
                    Next b
                End If
Next_a:
                On Error GoTo 0
            Next a
Next_File:
            On Error GoTo 0
            Close #iFile
        Next
        ReDim Preserve .Hacks(0 To Hack_Count)
        ReDim Preserve .Patch_Objects(0 To Patch_Object_Count)
        If Location_Count > -1 Then
            ReDim Preserve .Locations(0 To Location_Count)
        Else
            Erase .Locations
        End If
        If Variable_Count > -1 Then
            ReDim Preserve .Variables(0 To Variable_Count)
        Else
            Erase .Variables
        End If
    End With
    VBATime True
    Insert_Hacks Hack_List, True
    Erase Patches.XML_Entry
    Erase Patch.XML_Entry
    Erase Patch_Entries.XML_Entry
    VBATime False
End Sub

Public Sub Insert_Hacks(Hack_List As Hack_List, Append As Boolean)
    VBATime True
    Dim Decoded_Opcode As Decoded
    Dim Current_Colour As Byte
    Dim Colours(1 To 24) As Long
    Colours(1) = 6349024: Colours(2) = 10510560: Colours(3) = 10543200: Colours(4) = 14737504: Colours(5) = 14737632: Colours(6) = 10510496: Colours(7) = 6332512: Colours(8) = 14721120: Colours(9) = 10543328: Colours(10) = 14721248: Colours(11) = 6348960: Colours(12) = 10526880: Colours(13) = 10526944: Colours(14) = 14704800: Colours(15) = 14737568: Colours(16) = 6332576: Colours(17) = 10543264: Colours(18) = 6316256: Colours(19) = 14704864: Colours(20) = 10526816: Colours(21) = 6332640: Colours(22) = 14721184: Colours(23) = 6348896: Colours(24) = 14704736
    Dim a As Long, b As Long, c As Long, d As Long, e As Long, f As Long
    Dim Current_Row As Long
    Dim Split_Description() As String, Split_Comments() As String
    Dim Memory_String As String
    Dim Memory_Address_Prefix As String
    Dim Hide_Long_Strings As Boolean
    Current_Row = 1
    Dim Memory_Address As Long
    Dim Search_Address As Long, Search_Address_Int As Long
    Dim Trim_String As String
    Dim Has_Loc As Boolean, Has_Var As Boolean
    Hide_Long_Strings = ReadReg(RegFolder & "Hide Long Strings", 1)
    
    With Hack_List
    
        'Negate all links
        On Error GoTo NoLocation
        For a = LBound(.Locations) To UBound(.Locations)
            .Locations(a).Link = -1
        Next a
        Has_Loc = True
NoLocation:
        On Error GoTo NoVariable
        For a = LBound(.Variables) To UBound(.Variables)
            .Variables(a).Bind = -1
        Next a
        Has_Var = True
NoVariable:
        On Error GoTo 0
    
        'Move Variables into Locations and add "-1"/"-2" trim
        Dim Var_Length As Byte
        For a = LBound(.Hacks) To UBound(.Hacks)
            For b = .Hacks(a).Last To .Hacks(a).First Step -1
                If .Patch_Objects(b).Type = 2 And .Patch_Objects(b).Memory Then
                    For c = .Patch_Objects(b).End_Location To .Patch_Objects(b).Start_Location Step -1
                            Search_Address_Int = Int(.Variables(.Patch_Objects(b).Start_Location).Offset / 4) * 4
                            Search_Address = .Variables(.Patch_Objects(b).Start_Location).Offset + .Variables(.Patch_Objects(b).Start_Location).Bytes
                            For d = .Hacks(a).First To .Hacks(a).Last
                                If .Patch_Objects(d).Type = 1 Then
                                    If .Locations(.Patch_Objects(d).Start_Location).Offset = Search_Address Then
                                        .Patch_Objects(d).Trim = .Variables(.Patch_Objects(b).Start_Location).Bytes + .Patch_Objects(d).Trim
                                        .Locations(.Patch_Objects(d).Start_Location).Raw_String = ReverseBytes(Right("00000000" & .Variables(.Patch_Objects(b).Start_Location).Hex_String, .Variables(.Patch_Objects(b).Start_Location).Bytes * 2)) & .Locations(.Patch_Objects(d).Start_Location).Raw_String
                                        .Locations(.Patch_Objects(d).Start_Location).Offset = Search_Address - .Variables(.Patch_Objects(b).Start_Location).Bytes
                                        If .Locations(.Patch_Objects(d).Start_Location).Offset = Search_Address_Int Then
                                            .Variables(.Patch_Objects(b).Start_Location).Bind = .Patch_Objects(d).Start_Location
                                        End If
                                    ElseIf .Locations(.Patch_Objects(d).Start_Location).Offset = Search_Address_Int Then
                                        Var_Length = .Variables(.Patch_Objects(b).Start_Location).Bytes
                                        .Patch_Objects(d).Trim = Var_Length + .Patch_Objects(d).Trim
                                        .Locations(.Patch_Objects(d).Start_Location).Raw_String = ReverseBytes(Right("00000000" & .Variables(.Patch_Objects(b).Start_Location).Hex_String, Var_Length * 2)) & Mid(.Locations(.Patch_Objects(d).Start_Location).Raw_String, 1 + Var_Length * 2)
                                        .Variables(.Patch_Objects(b).Start_Location).Bind = .Patch_Objects(d).Start_Location
                                    End If
                                End If
                            Next d
                    Next c
                End If
            Next b
        Next a
        
        'Calculate Memory Addresses of each instruction
        For a = LBound(.Hacks) To UBound(.Hacks)
            For b = .Hacks(a).First To .Hacks(a).Last
                If .Patch_Objects(b).Type = 1 And .Patch_Objects(b).Memory Then
                    For c = .Patch_Objects(b).Start_Location To .Patch_Objects(b).End_Location - 1
                        Decoded_Opcode = Decode(.Locations(c).Raw_String, .Locations(.Patch_Objects(b).Start_Location).Offset)
                        If Not IsHex(Decoded_Opcode.String, True) Then .Locations(c).Is_Opcode = True
                    Next c
                    .Locations(.Patch_Objects(b).End_Location).Is_Opcode = True
                    For c = .Patch_Objects(b).Start_Location + 1 To .Patch_Objects(b).End_Location
                        If .Locations(c).Is_Opcode Then
                            .Locations(c).Offset = .Locations(c - 1).Offset + 4
                        Else
                            .Locations(c).Offset = .Locations(c - 1).Offset + Len(Replace(.Locations(c - 1).Raw_String, " ", "")) / 2
                        End If
                    Next c
                End If
            Next b
        Next a
        
        'Trim continuous hack sections
        For a = LBound(.Hacks) To UBound(.Hacks)
            For b = .Hacks(a).First To .Hacks(a).Last - 1
                If .Patch_Objects(b).Type = 1 And .Patch_Objects(b + 1).Type = 1 And .Patch_Objects(b).Memory = .Patch_Objects(b + 1).Memory And .Patch_Objects(b).File_ID = .Patch_Objects(b + 1).File_ID Then
                    If .Locations(.Patch_Objects(b).End_Location).Offset = .Locations(.Patch_Objects(b + 1).Start_Location).Offset Then
                        .Patch_Objects(b).End_Location = .Patch_Objects(b).End_Location - 1
                        .Patch_Objects(b).Quick_End = True
                        .Patch_Objects(b + 1).Continuous = True
                    End If
                End If
            Next b
        Next a
        
        'Generate Opcode Strings and Cell Colours
        For a = LBound(.Hacks) To UBound(.Hacks)
            For b = .Hacks(a).First To .Hacks(a).Last
                If .Patch_Objects(b).Type = 1 And .Patch_Objects(b).Memory Then
                    For c = .Patch_Objects(b).Start_Location To .Patch_Objects(b).End_Location
                        If .Locations(c).Is_Opcode Then
                            Decoded_Opcode = Decode(.Locations(c).Raw_String, .Locations(c).Offset, True)
                            .Locations(c).String = Decoded_Opcode.String
                            .Locations(c).Destination = Decoded_Opcode.Destination
                            Search_Address = Decoded_Opcode.Destination
                            If Search_Address > 0 Then
                                For d = .Hacks(a).First To .Hacks(a).Last
                                    For e = .Patch_Objects(d).Start_Location To .Patch_Objects(d).End_Location
                                        If c <> e And Search_Address = .Locations(e).Offset Then
                                            .Locations(c).Link = e
                                            If .Locations(e).Address_Colour = 0 Then
                                                .Locations(e).Address_Colour = Current_Colour + 1
                                                .Locations(c).Opcode_Colour = Current_Colour + 1
                                                Current_Colour = (Current_Colour + 1) Mod 24
                                            Else
                                                .Locations(c).Opcode_Colour = .Locations(e).Address_Colour
                                            End If
                                        End If
                                    Next e
                                Next d
                            End If
                        Else
                            .Locations(c).String = "'" & .Locations(c).Raw_String
                        End If
                    Next c
                End If
            Next b
        Next a
        
        If Append Then
            If GetLastCodeRow() = 1 Then
                Current_Row = 1
            Else
                Current_Row = GetLastCodeRow() + 3
            End If
        Else
            Dim Empty_Count As Byte
            For a = Selection.Row To 1048576
                Empty_Count = 0
                For b = 1 To 7
                    If IsEmpty(Code_Sheet.Cells(a, b)) Then Empty_Count = Empty_Count + 1
                Next b
                If Empty_Count = 7 Then Current_Row = a: Exit For
            Next a
            Dim Expand_Range As Range
            Set Expand_Range = Code_Sheet.Range(Code_Sheet.Cells(Current_Row, 1), Code_Sheet.Cells(Current_Row + UBound(.Locations) - LBound(.Locations) + 2, 7))
            Expand_Range.EntireRow.Insert
            Expand_Range.Interior.ColorIndex = 0
            Current_Row = Current_Row + 1
        End If
        Code_Sheet.Cells(Current_Row, 1).Select
        ActiveWindow.ScrollRow = Selection.Row
        ActiveWindow.ScrollColumn = Selection.Column

        'Print everything to the Code Sheet
        For a = LBound(.Hacks) To UBound(.Hacks)
            If Append Then
                Code_Sheet.Cells(Current_Row, 1).Value2 = "PATCH"
                Code_Sheet.Cells(Current_Row, 2).Value2 = "'" & DeXMLize(.Hacks(a).Name)
                If Hide_Long_Strings Then Code_Sheet.Cells(Current_Row, 7).Value2 = "'"
                Current_Row = Current_Row + 2
            End If
            If Len(.Hacks(a).Description) And Append Then
                Code_Sheet.Cells(Current_Row, 1).Value2 = "DESCRIPTION"
                Split_Description = Trim_Array_Whites(Split(Replace(DeXMLize(.Hacks(a).Description), vbCr, ""), vbLf)).Data
                For b = LBound(Split_Description) To UBound(Split_Description)
                    Code_Sheet.Cells(Current_Row, 2).Value2 = "'" & Split_Description(b)
                    If Hide_Long_Strings Then Code_Sheet.Cells(Current_Row, 7).Value2 = "'"
                    Current_Row = Current_Row + 1
                Next b
                Current_Row = Current_Row + 1
            End If
            For b = .Hacks(a).First To .Hacks(a).Last
                If .Patch_Objects(b).Memory Then
                    Memory_String = "MEM"
                    Memory_Address_Prefix = "0x8"
                Else
                    Memory_String = ""
                    Memory_Address_Prefix = "0x0"
                End If
                Select Case .Patch_Objects(b).Type
                    Case 1
                        If .Patch_Objects(b).Trim Then
                            Trim_String = "-" & .Patch_Objects(b).Trim
                        Else
                            Trim_String = ""
                        End If
                        Code_Sheet.Cells(Current_Row, 1).Value2 = Memory_String & "LOCATION" & Trim_String
                        Code_Sheet.Cells(Current_Row, 3).Value2 = Code_File(.Patch_Objects(b).File_ID, .Patch_Objects(b).Sector)
                        If .Patch_Objects(b).Continuous Then
                            If .Locations(.Patch_Objects(b - 1).End_Location).Is_Opcode Then
                                Code_Sheet.Cells(Current_Row, 4).FormulaR1C1 = "=LEFT(INDEX(C,ROW()-1),3)&DEC2HEX(4+HEX2DEC(MID(INDEX(C,ROW()-1),4,7)),7)"
                            Else
                                Code_Sheet.Cells(Current_Row, 4).FormulaR1C1 = "=LEFT(INDEX(C,ROW()-1),3)&DEC2HEX(INT(LEN(SUBSTITUTE(R[-1]C[1],"" "","""")))/2+HEX2DEC(MID(INDEX(C,ROW()-1),4,7)),7)"
                            End If
                        Else
                            Code_Sheet.Cells(Current_Row, 4).Value2 = Memory_Address_Prefix & DecToHex(.Locations(.Patch_Objects(b).Start_Location).Offset, 7)
                        End If
                        For c = .Patch_Objects(b).Start_Location To .Patch_Objects(b).End_Location
                            If c <> .Patch_Objects(b).End_Location Then
                                If .Locations(c).Is_Opcode Then
                                    Code_Sheet.Cells(Current_Row + 1, 4).FormulaR1C1 = "=LEFT(INDEX(C,ROW()-1),3)&DEC2HEX(4+HEX2DEC(MID(INDEX(C,ROW()-1),4,7)),7)"
                                Else
                                    Code_Sheet.Cells(Current_Row + 1, 4).FormulaR1C1 = "=LEFT(INDEX(C,ROW()-1),3)&DEC2HEX(INT(LEN(SUBSTITUTE(R[-1]C[1],"" "","""")))/2+HEX2DEC(MID(INDEX(C,ROW()-1),4,7)),7)"
                                End If
                            End If
                            If .Locations(c).Address_Colour Then Code_Sheet.Cells(Current_Row, 4).Interior.color = Colours(.Locations(c).Address_Colour)
                            If .Locations(c).Opcode_Colour Then Code_Sheet.Cells(Current_Row, 5).Interior.color = Colours(.Locations(c).Opcode_Colour)
                            .Locations(c).Row = Current_Row
                            If .Locations(c).Destination = 0 Then
                                If .Locations(c).Is_Opcode Then
                                    Code_Sheet.Cells(Current_Row, 5).Value2 = .Locations(c).String
                                Else
                                    Code_Sheet.Cells(Current_Row, 5).Value2 = "'" & Replace(.Locations(c).Raw_String, " ", "")
                                End If
                            End If
                            Code_Sheet.Cells(Current_Row, 6).Value2 = "'" & .Locations(c).Raw_String
                            If Len(.Locations(c).Comment) Then
                                Code_Sheet.Cells(Current_Row, 7).Value2 = "'" & Smart_Trim(.Locations(c).Comment)
                                Code_Sheet.Cells(Current_Row, 7).Font.Italic = True
                            End If
                            Current_Row = Current_Row + 1
                        Next c
                        If Not .Patch_Objects(b).Quick_End Then Current_Row = Current_Row + 1
                    Case 2
                        Code_Sheet.Cells(Current_Row, 1).Value2 = Memory_String & "VARIABLE"
                        Code_Sheet.Cells(Current_Row, 3).Value2 = Code_File(.Patch_Objects(b).File_ID, .Patch_Objects(b).Sector)
                        With .Variables(.Patch_Objects(b).Start_Location)
                            Code_Sheet.Cells(Current_Row, 2).Value2 = .Name
                            Code_Sheet.Cells(Current_Row, 4).Value2 = Memory_Address_Prefix & DecToHex(.Offset, 7)
                            Code_Sheet.Cells(Current_Row, 5).Value2 = "'" & .Hex_String
                            .Row = Current_Row
                        End With
                        Current_Row = Current_Row + 2
                    Case 255
                        Code_Sheet.Cells(Current_Row, 1).Value2 = "COMMENT"
                        Split_Comments = Trim_Array_Whites(Split(Replace(DeXMLize(.Patch_Objects(b).Comment), vbCr, ""), vbLf)).Data
                        For c = LBound(Split_Comments) To UBound(Split_Comments)
                            Code_Sheet.Cells(Current_Row, 2).Value2 = "'" & Split_Comments(c)
                            If Hide_Long_Strings Then Code_Sheet.Cells(Current_Row, 7).Value2 = "'"
                            Code_Sheet.Cells(Current_Row, 2).Font.Italic = True
                            Current_Row = Current_Row + 1
                        Next c
                End Select
            Next b
            Current_Row = Current_Row + 1
        Next a
        
        'Update Branches and Jumps with proper links
        If Has_Loc Then
            For a = LBound(.Locations) To UBound(.Locations)
                If .Locations(a).Destination Then
                    If .Locations(a).Link > -1 Then
                        Code_Sheet.Cells(.Locations(a).Row, 5).Formula = "=""" & .Locations(a).String & """&D" & .Locations(.Locations(a).Link).Row
                    Else
                        Code_Sheet.Cells(.Locations(a).Row, 5).Value2 = .Locations(a).String & "0x8" & DecToHex(.Locations(a).Destination, 7)
                    End If
                End If
            Next a
        End If
        If Has_Var Then
            For a = LBound(.Variables) To UBound(.Variables)
                If .Variables(a).Bind Then
                    If .Variables(a).Bind > -1 Then
                        Code_Sheet.Cells(.Variables(a).Row, 4).Formula = "=D" & .Locations(.Variables(a).Bind).Row
                    End If
                End If
            Next a
        End If
    End With
    Call UpdateHackList
    VBATime False
End Sub

Public Function Code_File(File_ID As Long, Sector As Long) As String
    Dim Match_ID As Long
    If File_ID > -1 Then
        Code_File = File_Full_Names(File_ID)
    ElseIf Sector > -1 Then
        Match_ID = GetFileMatch("", False, False, False, Sector)
        If Match_ID > -1 Then
            Code_File = File_Full_Names(Match_ID)
        Else
            Code_File = "[" & Sector & "]"
        End If
    Else
        Code_File = "???"
    End If
End Function

Public Function Get_File_Data(Sector As Long, Offset As Long, Byte_Length As Long, ISO_File As Integer) As Variant
    If Byte_Length > 0 Then
        Dim a As Long, b As Long
        Dim Bytes_Left As Long
        Dim Current_Sector As Long, Current_Offset As Long, Current_Byte As Long
        Dim File_Bytes() As Byte, Temp_Bytes() As Byte
        ReDim File_Bytes(Byte_Length)
        Dim New_Sector_Offset As Variant
        New_Sector_Offset = Get_New_Sector_Offset(Sector, Offset, ISO_File)
        Current_Sector = New_Sector_Offset(1)
        Current_Offset = New_Sector_Offset(2)
        Dim Fetch_Count As Long
        Dim Sector_Length As Integer
        Bytes_Left = Byte_Length
        
        Do
            Sector_Length = Get_Sector_Length(Current_Sector, ISO_File)
            If Bytes_Left < (Sector_Length - Current_Offset) Then
                Fetch_Count = Bytes_Left
            Else
                Fetch_Count = Sector_Length - Current_Offset
            End If
            ReDim Temp_Bytes(Fetch_Count)
            Get ISO_File, Current_Sector * 2352 + 24 + 1 + Current_Offset, Temp_Bytes
            For b = 0 To Fetch_Count - 1
                File_Bytes(Current_Byte + b) = Temp_Bytes(b)
            Next b
            Current_Byte = Current_Byte + Fetch_Count
            Current_Offset = Current_Offset + Fetch_Count
            If Current_Offset = Sector_Length Then Current_Offset = 0: Current_Sector = Current_Sector + 1
            Bytes_Left = Bytes_Left - Fetch_Count
            
        Loop While Bytes_Left > 0
        
        Get_File_Data = File_Bytes
    End If
End Function

Public Sub Save_File_Data(Sector As Long, Offset As Long, Byte_Array As Variant, ISO_File As Integer, Optional Fill_Sectors As Boolean = False)
    Dim Byte_Length As Long
    Byte_Length = UBound(Byte_Array) - LBound(Byte_Array) + 1
    If Byte_Length > 0 Then
        Dim a As Long, b As Long
        Dim Array_Start As Long
        Dim Bytes_Left As Long
        Dim Current_Sector As Long, Current_Offset As Long, Current_Byte As Long
        Dim Temp_Bytes() As Byte
        ReDim File_Bytes(Byte_Length)
        Array_Start = LBound(Byte_Array)
        Dim Form_Byte(0 To 0) As Byte
        Dim Sector_Length As Integer
        Dim New_Sector_Offset As Variant
        New_Sector_Offset = Get_New_Sector_Offset(Sector, Offset, ISO_File)
        Current_Sector = New_Sector_Offset(1)
        Current_Offset = New_Sector_Offset(2)
        Dim Write_Count As Long
        Bytes_Left = Byte_Length
        Dim Read_Before_Writing As Boolean
        Dim Do_Write As Boolean
        Dim Read_Bytes() As Byte
        Dim Compare_Start As Long, Compare_End As Long
        
        If ReadReg(RegFolder & "SSD", 0) > 0 Then Read_Before_Writing = True

        Do
            Sector_Length = Get_Sector_Length(Current_Sector, ISO_File)
        
            If Bytes_Left < (Sector_Length - Current_Offset) Then
                Write_Count = Bytes_Left
            Else
                Write_Count = Sector_Length - Current_Offset
            End If
            If Fill_Sectors Then
                ReDim Temp_Bytes(0 To Sector_Length - 1)
            Else
                ReDim Temp_Bytes(0 To Write_Count - 1)
            End If
            For b = 0 To Write_Count - 1
                Temp_Bytes(b) = Byte_Array(Array_Start + Current_Byte + b)
            Next b
            
            If Read_Before_Writing Then
                Compare_Start = LBound(Temp_Bytes)
                Compare_End = UBound(Temp_Bytes)
                ReDim Read_Bytes(Compare_Start To Compare_End)
                Get ISO_File, Current_Sector * 2352 + 1, Read_Bytes
                For b = Compare_Start To Compare_End
                    If Read_Bytes(b) <> Temp_Bytes(b) Then Do_Write = True: Exit For
                Next b
            Else
                Do_Write = True
            End If
            Put ISO_File, Current_Sector * 2352 + 24 + 1 + Current_Offset, Temp_Bytes
            Current_Byte = Current_Byte + Write_Count
            Current_Offset = Current_Offset + Write_Count
            If Current_Offset = Sector_Length Then Current_Offset = 0: Current_Sector = Current_Sector + 1
            Bytes_Left = Bytes_Left - Write_Count
            
        Loop While Bytes_Left > 0
    End If
End Sub

Public Function Get_New_Sector_Offset(Sector As Long, Offset As Long, ISO_File As Integer) As Variant
    Dim Result(1 To 2) As Long
    Dim Form_Byte(0 To 0) As Byte
    Dim Sector_Length As Integer
    Dim Current_Sector As Long, Current_Offset As Long
    Current_Sector = Sector
    Current_Offset = Offset
    Do
        Sector_Length = Get_Sector_Length(Current_Sector, ISO_File)
        If Current_Offset >= Sector_Length Then
            Current_Sector = Current_Sector + 1
            Current_Offset = Current_Offset - Sector_Length
        Else
            Exit Do
        End If
    Loop
    Result(1) = Current_Sector
    Result(2) = Current_Offset
    Get_New_Sector_Offset = Result
End Function

Public Function Get_Sector_Length(Sector As Long, ISO_File As Integer) As Integer
    Dim Form_Byte(0 To 0) As Byte
    Get ISO_File, Sector * 2352 + 19, Form_Byte
    If bAND(CLng(Form_Byte(0)), 32) = 32 Then
        Get_Sector_Length = 2324
    Else
        Get_Sector_Length = 2048
    End If
End Function

Public Function Smart_Trim(Parse_String As String) As String
    Dim a As Long
    Dim String_Start As Long, String_End As Long
    If Len(Parse_String) Then
        For a = 1 To Len(Parse_String)
            Select Case Mid(Parse_String, a, 1)
                Case vbCr, vbTab, " "
                
                Case Else
                    String_Start = a
                    Exit For
            End Select
        Next a
        For a = Len(Parse_String) To 1 Step -1
            Select Case Mid(Parse_String, a, 1)
                Case vbCr, vbTab, " "
                
                Case Else
                    String_End = a
                    Exit For
            End Select
        Next a
        If String_End > String_Start Then Smart_Trim = Mid(Parse_String, String_Start, String_End - String_Start + 1)
    End If
End Function

Public Function Trim_Array_Whites(Parse_Array As Variant) As Data_and_Comments
    Dim Result As Data_and_Comments
    Dim Comments() As String
    Dim NullString() As Boolean
    Dim NotNull_ID As Long
    Dim Active_Count As Long
    Dim Valid_Count As Long
    Dim Character As String
    Dim a As Long
    Dim Comment_Skip As Boolean
    Dim Comment_Start As Long, Comment_End As Long
    Dim Array_Start As Long, Array_End As Long
    Array_Start = -1: Array_End = -1
    For a = LBound(Parse_Array) To UBound(Parse_Array)
        If Len(Replace(Replace(Replace(Parse_Array(a), vbCr, ""), vbTab, ""), " ", "")) Then Array_Start = a: Exit For
    Next a
    For a = UBound(Parse_Array) To LBound(Parse_Array) Step -1
        If Len(Replace(Replace(Replace(Parse_Array(a), vbCr, ""), vbTab, ""), " ", "")) Then Array_End = a: Exit For
    Next a
    ReDim Result.Data(0 To Array_End - Array_Start)
    ReDim Result.Comment(0 To Array_End - Array_Start)
    'ReDim Comments(0 To Array_End - Array_Start)
    ReDim NullString(0 To Array_End - Array_Start)
    NotNull_ID = -1
    For a = 0 To UBound(Result.Data)
        Result.Data(a) = Parse_Array(a + Array_Start)
        If Len(Replace(Replace(Replace(Remove_XML_Comments(Result.Data(a)), vbCr, ""), vbTab, ""), " ", "")) = 0 Then
            NullString(a) = True
        Else
            Active_Count = Active_Count + 1
            If NotNull_ID = -1 Then NotNull_ID = a
        End If
    Next a
    For a = 0 To UBound(Result.Data)
        If Comment_Skip Then
            Comment_End = InStr(1, Result.Data(a), "-->")
            If Comment_End Then
                Result.Data(a) = Mid(Result.Data(a), Comment_End + 3)
                Comment_Skip = False
            Else
                Result.Data(a) = ""
            End If
        End If
        Do
            Comment_Start = InStr(1, Result.Data(a), "<!--")
            If Comment_Start > 0 Then
                Comment_End = InStr(Comment_Start + 4, Result.Data(a), "-->")
                If Comment_End Then
                    Result.Comment(a) = Mid(Result.Data(a), Comment_Start + 4, Comment_End - Comment_Start - 4)
                    Result.Data(a) = Left(Result.Data(a), Comment_Start - 1) & Right(Result.Data(a), Len(Result.Data(a)) - Comment_End - 2)
                Else
                    Result.Comment(a) = Mid(Result.Data(a), Comment_Start + 4)
                    Result.Data(a) = Left(Result.Data(a), Comment_Start - 1)
                    Comment_Skip = True
                    Exit Do
                End If
            Else
                Exit Do
            End If
        Loop
    Next a
    If NotNull_ID = -1 Then Exit Function
    Dim Current_Position As Long
    Current_Position = 1
    Do
        If Current_Position > Len(Result.Data(NotNull_ID)) Then Exit Do
        Character = Mid(Result.Data(NotNull_ID), Current_Position, 1)
        Select Case Character
            Case vbCr, vbTab, " "
                Valid_Count = 0
                For a = 0 To UBound(Result.Data)
                    If Not NullString(a) Then
                        If Mid(Result.Data(a), Current_Position, 1) <> Character Then Exit For
                        Valid_Count = Valid_Count + 1
                    End If
                Next a
                If Valid_Count <> Active_Count Then Exit Do
            Case Else
                Exit Do
        End Select
        Current_Position = Current_Position + 1
    Loop
    For a = 0 To UBound(Result.Data)
        If NullString(a) Then
            Result.Data(a) = ""
        Else
            Result.Data(a) = Mid(Result.Data(a), Current_Position)
            If Right(Result.Data(a), 1) = vbCr Then Result.Data(a) = Left(Result.Data(a), Len(Result.Data(a)) - 1)
        End If
    Next a
    Trim_Array_Whites = Result
End Function

Public Function Table_Format(Format As String, Bytes_Per_Row As Long, Split_Into_Columns As Boolean) As Format_Results
    Dim a As Long, b As Long, c As Long
    Dim Value_Length As Long
    Dim Parameter_Pos As Long
    Dim Format_Lengths() As Long
    Dim Format_Types() As Byte
    Dim Format_Array() As String
    If Split_Into_Columns Then
        If Format = "" Then
            Table_Format.Byte_Count = Bytes_Per_Row
            Table_Format.Column_Count = Bytes_Per_Row
            ReDim Table_Format.Format_Entries(0 To Bytes_Per_Row - 1)
            For a = 0 To Bytes_Per_Row - 1
                Table_Format.Format_Entries(a).Length = 1
            Next a
        Else
            Format_Array = Split(Format, "/")
            ReDim Table_Format.Format_Entries(LBound(Format_Array) To UBound(Format_Array))
            For a = LBound(Format_Array) To UBound(Format_Array)
                Value_Length = 0
                Parameter_Pos = 0
                For b = 1 To Len(Format_Array(a))
                    If IsNumeric(Mid(Format_Array(a), b, 1)) Then
                        Value_Length = Value_Length * 10 + CLng(Mid(Format_Array(a), b, 1))
                    Else
                        Parameter_Pos = b
                        Exit For
                    End If
                Next b
                Table_Format.Format_Entries(a).Length = Value_Length
                Table_Format.Byte_Count = Table_Format.Byte_Count + Value_Length
                If Parameter_Pos = Len(Format_Array(a)) Then
                    Select Case Right(Format_Array(a), 1)
                        Case "h"
                            Table_Format.Format_Entries(a).Type = 0
                            Table_Format.Column_Count = Table_Format.Column_Count + 1
                        Case "b"
                            Table_Format.Format_Entries(a).Type = 1
                            Table_Format.Column_Count = Table_Format.Column_Count + 1
                        Case "B"
                            Table_Format.Format_Entries(a).Type = 2
                            Table_Format.Column_Count = Table_Format.Column_Count + 8
                        Case "a"
                            Table_Format.Format_Entries(a).Type = 3
                            Table_Format.Column_Count = Table_Format.Column_Count + 1
                        Case "u"
                            Table_Format.Format_Entries(a).Type = 4
                            Table_Format.Column_Count = Table_Format.Column_Count + 1
                        Case "s"
                            Table_Format.Format_Entries(a).Type = 5
                            Table_Format.Column_Count = Table_Format.Column_Count + 1
                        Case "i"
                            Table_Format.Format_Entries(a).Type = 255
                    End Select
                Else
                    Table_Format.Format_Entries(a).Type = 0
                    Table_Format.Column_Count = Table_Format.Column_Count + 1
                End If
            Next a
        End If
    Else
        Table_Format.Byte_Count = Bytes_Per_Row
        Table_Format.Column_Count = 1
        ReDim Table_Format.Format_Entries(0 To 0)
        Table_Format.Format_Entries(0).Length = Bytes_Per_Row
        Table_Format.Format_Entries(0).Type = 3
    End If
End Function

Public Sub Fetch_Data(Destination As Range, Mode As Fetch_Mode, Offset As Long, Bytes_Per_Row As Long, Rows As Long, Optional Filename As String = "", Optional Memory_Address As Boolean = True, Optional Split_Into_Columns As Boolean = False, Optional Format As String = "")
    Dim Format_Results As Format_Results
    Dim Match_ID As Long
    Match_ID = GetFileMatch(Filename, True, True, True)
    Format_Results = Table_Format(Format, Bytes_Per_Row, Split_Into_Columns)
    Fetch_Data_With_Table Destination, Mode, Offset, Rows, Format_Results, Match_ID, Memory_Address
End Sub

Public Sub Fetch_Data_With_Table(Destination As Range, Mode As Fetch_Mode, Offset As Long, Rows As Long, Format As Format_Results, Optional File_ID As Long = -1, Optional Memory_Address As Boolean = True)
    Dim Byte_Total As Long
    Dim fnum As Integer
    Dim Data_Bytes() As Byte
    Dim Match_ID As Long
    Dim a As Long, b As Long, c As Long, d As Long
    Dim Current_Byte As Long, Current_Column As Long
    Dim Binary_String As String
    Dim Hex_String As String
    Dim Decimal_Value As Long
    Dim Address As Long
    If File_ID > -1 And Memory_Address Then
        Address = Offset - File_Offsets(File_ID)
    Else
        Address = Offset
    End If
    Byte_Total = Format.Byte_Count * Rows
    fnum = FreeFile
    
    Select Case Mode
        Case Import_From_ISO
            fnum = Open_ISO
            If fnum = -1 Then Exit Sub
            Data_Bytes = Get_File_Data(File_Sectors(File_ID), Address, Byte_Total, fnum)
        Case Import_From_Savestate
            Open ReadReg(RegFolder & "Last Quicksave", "") For Binary As #fnum
            ReDim Data_Bytes(0 To Byte_Total - 1)
            Get #fnum, Address + Get_Savestate_Offset(fnum) + 1, Data_Bytes
    End Select
    Close #fnum
    
    Current_Byte = 0
    For a = 1 To Rows
        Current_Column = 1
        For b = LBound(Format.Format_Entries) To UBound(Format.Format_Entries)
            Select Case Format.Format_Entries(b).Type
                Case 0 'hexadecimal
                    Hex_String = ""
                    For c = 0 To Format.Format_Entries(b).Length - 1
                        Hex_String = DecToHex(CLng(Data_Bytes(Current_Byte + c)), 2) & Hex_String
                    Next c
                    Destination.Cells(a, Current_Column).Value2 = "'" & Hex_String
                    Current_Column = Current_Column + 1
                Case 1 'binary
                    Binary_String = ""
                    For c = 0 To Format.Format_Entries(b).Length - 1
                        Binary_String = Binary_String & DecToBin(CLng(Data_Bytes(Current_Byte + c)), 8)
                    Next c
                    Destination.Cells(a, Current_Column).Value2 = "'" & Binary_String
                    Current_Column = Current_Column + 1
                Case 2 'binary (separate columns)
                    For c = 0 To Format.Format_Entries(b).Length - 1
                        Binary_String = DecToBin(CLng(Data_Bytes(Current_Byte + c)), 8)
                        For d = 1 To 8
                            Destination.Cells(a, Current_Column).Value2 = CLng(Mid(Binary_String, d, 1))
                            Current_Column = Current_Column + 1
                        Next d
                    Next c
                Case 3 'array
                    Hex_String = ""
                    For c = 0 To Format.Format_Entries(b).Length - 1
                        Hex_String = Hex_String & DecToHex(CLng(Data_Bytes(Current_Byte + c)), 2)
                    Next c
                    Destination.Cells(a, Current_Column).Value2 = "'" & Hex_String
                    Current_Column = Current_Column + 1
                Case 4 'unsigned decimal
                    Hex_String = ""
                    For c = 0 To Format.Format_Entries(b).Length - 1
                        Hex_String = DecToHex(CLng(Data_Bytes(Current_Byte + c)), 2) & Hex_String
                    Next c
                    Decimal_Value = HexToDec(Hex_String)
                    Destination.Cells(a, Current_Column).Value2 = Decimal_Value
                    Current_Column = Current_Column + 1
                Case 5 'signed decimal
                    Hex_String = ""
                    For c = 0 To Format.Format_Entries(b).Length - 1
                        Hex_String = DecToHex(CLng(Data_Bytes(Current_Byte + c)), 2) & Hex_String
                    Next c
                    Decimal_Value = HexToDec(Hex_String, , True)
                    Destination.Cells(a, Current_Column).Value2 = Decimal_Value
                    Current_Column = Current_Column + 1
            End Select
            Current_Byte = Current_Byte + Format.Format_Entries(b).Length
        Next b
    Next a
    
End Sub

Public Sub Fetch_Code(Mode As Fetch_Mode, ByVal Code_Start As Long, ByVal Code_End As Long, Append As Boolean, Optional File_ID As Long = -1, Optional Memory_Address As Boolean = True)
    Dim Hack_List As Hack_List
    Dim Array_End As Long
    Dim Byte_Total As Long
    Dim Code_Bytes() As Byte
    Dim fnum As Integer
    Dim a As Long, b As Long
    Dim Description_String As String
    Dim Read_Offset As Long
    fnum = FreeFile
    Code_Start = Int((Code_Start + 3) / 4) * 4
    Code_End = Int((Code_End) / 4) * 4 + 3
    Array_End = Int((Code_End - Code_Start + 1) / 4) - 1
    Byte_Total = Code_End - Code_Start + 1
    
    With Hack_List
        ReDim .Hacks(0 To 0)
        ReDim .Locations(0 To Array_End + 1)
        ReDim .Patch_Objects(0 To 0)
        .Hacks(0).Name = "Patch generated on: " & Format(Now(), "yyyy/mm/dd hh:mm:ss")
        .Hacks(0).First = 0
        .Hacks(0).Last = 0
        .Patch_Objects(0).Start_Location = 0
        .Patch_Objects(0).End_Location = Array_End + 1
        .Patch_Objects(0).Type = 1
        .Patch_Objects(0).File_ID = File_ID
        
        Select Case Mode
            Case Import_From_ISO
                fnum = Open_ISO
                If fnum = -1 Then Exit Sub
                If Memory_Address And File_ID > -1 Then
                    Read_Offset = Code_Start - File_Offsets(File_ID)
                    .Patch_Objects(0).Memory = True
                Else
                    Read_Offset = Code_Start
                End If
                Code_Bytes = Get_File_Data(File_Sectors(File_ID), Read_Offset, Byte_Total, fnum)
                If File_ID > -1 Then
                    If File_Offsets(File_ID) > 0 And Not Memory_Address Then
                        Code_Start = Code_Start + File_Offsets(File_ID)
                        .Patch_Objects(0).Memory = True
                    End If
                End If
            Case Import_From_Savestate
                Open ReadReg(RegFolder & "Last Quicksave", "") For Binary As #fnum
                ReDim Code_Bytes(0 To Byte_Total - 1)
                Get #fnum, Code_Start + Get_Savestate_Offset(fnum) + 1, Code_Bytes
                .Patch_Objects(0).Memory = True
        End Select
        Close #fnum
        
        .Locations(0).Offset = Code_Start
        Select Case Mode
            Case Import_From_ISO: Description_String = "Ripped from """ & ReadReg(RegFolder & "Last ISO", "") & """"
            Case Import_From_Savestate: Description_String = "Ripped from """ & ReadReg(RegFolder & "Last Quicksave", "") & """"
        End Select
        
        .Hacks(0).Description = Description_String
    
        Dim Hex_String As String
        For a = 0 To Array_End
            Hex_String = ""
            For b = 0 To 3
                Hex_String = Hex_String & DecToHex(CLng(Code_Bytes(a * 4 + b)), 2)
            Next b
            .Locations(a).Raw_String = Hex_String
        Next a
    End With

    Insert_Hacks Hack_List, Append
End Sub

Public Sub Import_Data()
    importdataform.Show False
End Sub

Public Sub Import_Code()
    importcodeform.Show False
End Sub

Public Function GetLastCodeRow() As Long
    Dim Code_Range As Range
    Set Code_Range = Trim_Range(Code_Sheet.Range("A:G"), True, False)
    If Code_Range Is Nothing Or Code_Range.Rows.Count = 1048576 Then
        GetLastCodeRow = 1
    Else
        GetLastCodeRow = Code_Range.Row + Code_Range.Rows.Count - 1
    End If
End Function

Public Function Get_Filename_From_Path(File_Path As String)
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Get_Filename_From_Path = fso.GetFileName(File_Path)
End Function

Public Function Get_Directory_Path_From_Path(File_Path As String) As String
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Get_Directory_Path_From_Path = fso.GetParentFolderName(File_Path)
End Function

Public Sub Clear_FFTText(Clear_GetFFTText As Boolean, Clear_CopyPasteText As Boolean)
    Dim FFTText_Table As ListObject
    Set FFTText_Table = FFTText_Sheet.ListObjects("FFTTextTable")
    Dim FFTText_Cols(1 To 5) As Range
    Set FFTText_Cols(1) = FFTText_Table.ListColumns("Function").DataBodyRange
    Dim a As Long
    For a = 1 To 4
        Set FFTText_Cols(1 + a) = FFTText_Table.ListColumns("Parameter " & a).DataBodyRange
    Next a
    For a = 1 To FFTText_Table.DataBodyRange.Rows.Count
        Select Case FFTText_Cols(1)(a).Value2
            Case "GetFFTText"
                If Clear_GetFFTText Then
                    Range(FFTText_Cols(2)(a).Value2).ClearContents
                End If
            Case "CopyPasteText"
                If Clear_CopyPasteText Then
                    Range(FFTText_Cols(3)(a).Value2).ClearContents
                End If
        End Select
    Next a
End Sub

Public Sub Hide_Release_Sheets()
    Code_Sheet.Visible = xlSheetHidden
    Hacks_Sheet.Visible = xlSheetHidden
    Calc_Sheet.Visible = xlSheetHidden
    FFTText_Sheet.Visible = xlSheetHidden
End Sub

Public Sub AddSavestateFile(Filename As String, Offset As Long, Required_Value As Long, AutoAllow As Boolean, ByRef Savestate_Files As Variant, Savestate_Offset As Long, filenum As Integer)
    Dim Allow As Boolean
    Dim Offset_Value As Long
    
    If AutoAllow Then
        Allow = True
    Else
        Get #filenum, Savestate_Offset + Offset + 1, Offset_Value
        If Offset_Value = Required_Value Then Allow = True
    End If
    
    If Allow Then
        Dim LB As Long
        Dim UB As Long
        LB = 0
        UB = 0
        On Error Resume Next
        LB = LBound(Savestate_Files)
        UB = UBound(Savestate_Files) + 1
        ReDim Preserve Savestate_Files(LB To UB)
        Savestate_Files(UB) = Filename
    End If
End Sub

Public Sub WipeSheet()
    Columns("A:XFD").EntireColumn.Delete
End Sub

Public Function LEAddress(Address As String)
    Address = Trim(Address)
    If Left(Address, 2) = "0x" Then
        LEAddress = ReverseBytes(Mid(Address, 3), 4)
    Else
        LEAddress = ReverseBytes(Address, 4)
    End If
End Function
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()
    Calc_Sheet.EnableCalculation = False
    Application.CalculateBeforeSave = False
    Call Refresh_Current_Sheet
    If ReadReg(RegFolder & "Auto-Update", "0", 1) = 1 Then Update_VBA_Components
End Sub

Private Sub Workbook_Activate()
    Call Refresh_Current_Sheet
End Sub

Private Sub Workbook_Deactivate()
    Call HackToolbar("")
End Sub
Attribute VB_Name = "Tutorial_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()
    Call HackToolbar("Global")
End Sub
Attribute VB_Name = "configuration"
Attribute VB_Base = "0{3FC851DD-9165-4F99-B6AB-38B07AA332BB}{7CDB6269-4261-48A3-9937-BD5728374376}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Option Explicit

Private Sub FFTOrgASMList_Click()
    With configuration
        Select Case .FFTOrgASMList.ListIndex
            Case 0
                .FFTOrgASMFocus.Enabled = False
            Case 1
                .FFTOrgASMFocus.Enabled = True
            Case 2
                .FFTOrgASMFocus.Enabled = True
            Case 3
                .FFTOrgASMFocus.Enabled = False
        End Select
    End With
End Sub

Private Sub FocuspSX_Click()
    With configuration
        .RestoreDebugger.Enabled = .FocuspSX.Value
        .QuicksaveList.Enabled = .FocuspSX.Value
    End With
End Sub

Private Sub ISOButton_Click()
    Dim FilePath As String
    Dim FolderFromPath As String
    FilePath = ReadReg(RegFolder & "Last ISO", "")
    If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
    If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
    FilePath = Application.GetOpenFilename(FileFilter:="M2/2352 PSX Image (*.bin;*.img;*.iso), *.bin;*.img;*.iso", Title:="Select a PSX Image", MultiSelect:=False)
    If FilePath = "False" Then
        Exit Sub
    End If
    configuration.ISOString.Value = FilePath
End Sub

Private Sub OKButton_Click()
    SaveConfiguration
End Sub

Private Sub CancelButton_Click()
    Unload Me
End Sub

Private Sub cmdExit_Click()
    Unload Me
End Sub

Private Sub configuration_KeyPress(ByVal KeyAscii As MsForms.ReturnInteger)
    If KeyAscii = vbKeyEnter Then
        SaveConfiguration
    End If
    ElseIf KeyAscii = vbKeyEscape Then
        Unload Me
    End If
End Sub

Public Sub SaveConfiguration()
    Dim Indent_Value As Integer
    With configuration
        WriteReg RegFolder & "Last Quicksave", .QuicksaveString.Value, REG_SZ
        WriteReg RegFolder & "Debug Quicksave", .DebugQuicksave.Value, REG_DWORD
        WriteReg RegFolder & "pSX Focus", .FocuspSX.Value, REG_DWORD
        WriteReg RegFolder & "Quicksave ID", .QuicksaveList.ListIndex, REG_DWORD
        WriteReg RegFolder & "Don't Trim XML", .NoTrimXML.Value, REG_DWORD
        WriteReg RegFolder & "After XML Export", .FFTOrgASMList.ListIndex, REG_DWORD
        WriteReg RegFolder & "FFTOrgASM Focus", .FFTOrgASMFocus.Value, REG_DWORD
        WriteReg RegFolder & "Restore Debugger", .RestoreDebugger.Value, REG_DWORD
        WriteReg RegFolder & "Text Ripping Method", .FFTTextList.ListIndex, REG_DWORD
        WriteReg RegFolder & "Blank String Format", BSBox.Text, REG_SZ
        WriteReg RegFolder & "Single String Format", SSBox.Text, REG_SZ
        WriteReg RegFolder & "Duplicate String Format", DSBox.Text, REG_SZ
        WriteReg RegFolder & "Empty Blank", EmptyBlank.Value, REG_DWORD
        WriteReg RegFolder & "Last ISO", ISOString.Text, REG_SZ
        WriteReg RegFolder & "Auto Select Last ISO", .AutoloadISO.Value, REG_DWORD
        WriteReg RegFolder & "Hide Long Strings", .HideCodeTags.Value, REG_DWORD
        If .Indent0.Value Then
            Indent_Value = 0
        ElseIf .Indent1.Value Then
            Indent_Value = 1
        ElseIf .Indent2.Value Then
            Indent_Value = 2
        End If
        If .SSD0.Value Then
            WriteReg RegFolder & "SSD", 0, REG_DWORD
        Else
            WriteReg RegFolder & "SSD", 1, REG_DWORD
        End If
        WriteReg RegFolder & "XML Indent", CStr(Indent_Value), REG_DWORD
        WriteReg RegFolder & "crlf -> XMLcrlf", .XMLcrlf.Value, REG_DWORD
    End With
    Unload Me
End Sub

Private Sub QuicksaveButton_Click()
    Dim FilePath As String
    Dim FolderFromPath As String
    FilePath = ReadReg(RegFolder & "Last Quicksave", "")
    If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
    If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
    FilePath = Application.GetOpenFilename(FileFilter:="pSX Quicksave (*.psv), *.psv", Title:="Select a pSX Quicksave File", MultiSelect:=False)
    If FilePath = "False" Then
        Exit Sub
    End If
    configuration.QuicksaveString.Value = FilePath
End Sub

Private Sub DuplicateString_Change()
End Sub

Private Sub BSBox_Change()
    BSLabel.Caption = "Ex: """ & Replace(Replace(BSBox.Text, "$", "Cure"), "#", "001") & """"
End Sub

Private Sub SSBox_Change()
    SSLabel.Caption = "Ex: """ & Replace(Replace(SSBox.Text, "$", "Cure"), "#", "001") & """"
End Sub

Private Sub DSBox_Change()
    DSLabel.Caption = "Ex: """ & Replace(Replace(DSBox.Text, "$", "Cure"), "#", "001") & """"
End Sub

Private Sub UserForm_Initialize()
    With Me
        With .QuicksaveList
            .Clear
            .AddItem "Do nothing"
            .AddItem "Autodetect and load Quicksave (F1 to F5)"
            .AddItem "Load Quicksave #1 (F1)"
            .AddItem "Load Quicksave #2 (F2)"
            .AddItem "Load Quicksave #3 (F3)"
            .AddItem "Load Quicksave #4 (F4)"
            .AddItem "Load Quicksave #5 (F5)"
        End With
        With .FFTOrgASMList
            .Clear
            .AddItem "Do nothing"
            .AddItem "Prompt to open FFTOrgASM (yes/no)"
            .AddItem "Open FFTOrgASM"
            .AddItem "Change window focus to FFTOrgASM"
        End With
        With .FFTTextList
            .Clear
            .AddItem "Open ""FFTText Editor.xlsm"" if present in the same folder"
            .AddItem "Prompt to open ""FFTText Editor.xlsm"" if not found in the same folder"
            .AddItem "Always Prompt to open ""FFTText Editor.xlsm"""
        End With
        .QuicksaveString.Value = ReadReg(RegFolder & "Last Quicksave", "")
        .DebugQuicksave.Value = ReadReg(RegFolder & "Debug Quicksave", 0)
        .FocuspSX = ReadReg(RegFolder & "pSX Focus", 1)
        .QuicksaveList.ListIndex = ReadReg(RegFolder & "Quicksave ID", 1, QuickIDMax)
        .NoTrimXML.Value = ReadReg(RegFolder & "Don't Trim XML", 0)
        .FFTOrgASMList.ListIndex = ReadReg(RegFolder & "After XML Export", 1, XMLExpMax)
        .FFTOrgASMFocus.Value = ReadReg(RegFolder & "FFTOrgASM Focus", 0)
        .RestoreDebugger.Value = ReadReg(RegFolder & "Restore Debugger", 0)
        .FFTTextList.ListIndex = ReadReg(RegFolder & "Text Ripping Method", 1, TextRipMax)
        .BSBox.Text = ReadReg(RegFolder & "Blank String Format", BSFormat)
        .SSBox.Text = ReadReg(RegFolder & "Single String Format", SSFormat)
        .DSBox.Text = ReadReg(RegFolder & "Duplicate String Format", DSFormat)
        .BSLabel.Caption = "Ex: """ & Replace(Replace(.BSBox.Text, "$", "Cure"), "#", "001") & """"
        .SSLabel.Caption = "Ex: """ & Replace(Replace(.SSBox.Text, "$", "Cure"), "#", "001") & """"
        .DSLabel.Caption = "Ex: """ & Replace(Replace(.DSBox.Text, "$", "Cure"), "#", "001") & """"
        .EmptyBlank.Value = ReadReg(RegFolder & "Empty Blank", 1)
        .OKButton.SetFocus
        .RestoreDebugger.Enabled = .FocuspSX.Value
        .QuicksaveList.Enabled = .FocuspSX.Value
        If ReadReg(RegFolder & "SSD", 0) = 0 Then
            .SSD0.Value = True
        Else
            .SSD1.Value = True
        End If
        Select Case .FFTOrgASMList.ListIndex
            Case 0: .FFTOrgASMFocus.Enabled = False
            Case 1: .FFTOrgASMFocus.Enabled = True
            Case 2: .FFTOrgASMFocus.Enabled = True
            Case 3: .FFTOrgASMFocus.Enabled = False
        End Select
        .ISOString.Value = ReadReg(RegFolder & "Last ISO", "")
        .AutoloadISO.Value = ReadReg(RegFolder & "Auto Select Last ISO", 0)
        .HideCodeTags.Value = ReadReg(RegFolder & "Hide Long Strings", 1)
        .XMLcrlf.Value = ReadReg(RegFolder & "crlf -> XMLcrlf", 1)
        .VersionLabel.Caption = "v" & SharedXifiSheets_Version & " By Xifanie"

        Select Case ReadReg(RegFolder & "XML Indent", 1, 2)
            Case 0: .Indent0.Value = True
            Case 1: .Indent1.Value = True
            Case 2: .Indent2.Value = True
        End Select
    End With
End Sub
Attribute VB_Name = "importcodeform"
Attribute VB_Base = "0{BC26E04F-B1E6-452B-8B1F-CA863AA328B8}{35CB50D6-B33E-42AE-AA11-7251E9D49C86}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False








Option Explicit

Private Sub Toggle_File()
    If ISO.Value Then
        Filename.Enabled = True
        Filename.BackColor = &H80000005
    Else
        Filename.Enabled = False
        Filename.BackColor = &H8000000B
    End If
    If Clipboard.Value Then
        Start_Offset.Enabled = False
        Start_Offset.BackColor = &H8000000B
        End_Offset.Enabled = False
        End_Offset.BackColor = &H8000000B
    Else
        Start_Offset.Enabled = True
        Start_Offset.BackColor = &H80000005
        End_Offset.Enabled = True
        End_Offset.BackColor = &H80000005
    End If
End Sub

Private Sub ISO_Click()
    Call Toggle_File
End Sub
Private Sub Savestate_Click()
    Call Toggle_File
End Sub
Private Sub Clipboard_Click()
    Call Toggle_File
End Sub

Private Sub Create_Code(Append As Boolean)
    If Not Import_Files_List Then Exit Sub
    Dim S_Offset As Long, E_Offset As Long
    Dim Match_ID As Long
    Dim Mode As Fetch_Mode
    Match_ID = -1
    
    If Clipboard.Value Then
        Dim DataObj As MsForms.DataObject
        Set DataObj = New MsForms.DataObject
        
        On Error GoTo Clipboard_Error
        DataObj.GetFromClipboard
        On Error GoTo 0
        
        Dim Clipboard_Data As String
        Dim Clipboard_Lines() As String
        Dim Hex_Address As String, Hex_Opcode As String
        Dim a As Long
        Dim Old_Address As Long, New_Address As Long
        Dim Hack_List As Hack_List
        ReDim Hack_List.Hacks(0 To 0)
        ReDim Hack_List.Patch_Objects(0 To 255)
        ReDim Hack_List.Locations(0 To 65535)
        Dim Entry_Count As Long, Location_Count As Long, Comment_Start As Long
        Entry_Count = -1
        Location_Count = -1
        
        Clipboard_Data = Replace(DataObj.GetText(1), vbCr, "")
        Clipboard_Lines = Split(Clipboard_Data, vbLf)
        Old_Address = -2147483647
        For a = LBound(Clipboard_Lines) To UBound(Clipboard_Lines)
            If Len(Clipboard_Lines(a)) >= 18 Then
                Hex_Address = Left(Clipboard_Lines(a), 8)
                If IsHex(Hex_Address) Then
                    New_Address = "&H" & Hex_Address
                    If New_Address <> Old_Address + 4 Then
                        Entry_Count = Entry_Count + 1
                        Location_Count = Location_Count + 1
                        Hack_List.Patch_Objects(Entry_Count).Start_Location = Location_Count
                        Hack_List.Patch_Objects(Entry_Count).Offset = New_Address
                        Hack_List.Patch_Objects(Entry_Count).Memory = True
                        Hack_List.Patch_Objects(Entry_Count).Type = 1
                        Hack_List.Patch_Objects(Entry_Count).File_ID = -1
                        Hack_List.Patch_Objects(Entry_Count).Sector = -1
                    End If
                    Old_Address = New_Address
                    Hex_Opcode = ReverseBytes(Mid(Clipboard_Lines(a), 11, 8), 4)
                    If IsHex(Hex_Opcode) Then
                        Hack_List.Locations(Location_Count).Raw_String = Hex_Opcode
                        Hack_List.Locations(Location_Count).Offset = New_Address
                        Hack_List.Patch_Objects(Entry_Count).End_Location = Location_Count + 1
                        Comment_Start = InStr(18, Clipboard_Lines(a), "    ")
                        If Comment_Start = 0 Then Comment_Start = InStr(18, Clipboard_Lines(a), vbTab)
                        If Comment_Start > 0 Then
                            Hack_List.Locations(Location_Count).Comment = Smart_Trim(Mid(Clipboard_Lines(a), Comment_Start))
                        End If
                        Location_Count = Location_Count + 1
                    End If
                End If
            End If
        Next
        Location_Count = Location_Count + 1
        Hack_List.Hacks(0).First = 0
        Hack_List.Hacks(0).Last = Entry_Count
        Hack_List.Hacks(0).Name = "Patch generated on: " & Format(Now(), "yyyy/mm/dd hh:mm:ss")
        Hack_List.Hacks(0).Description = "Ripped from clipboard"
        
        On Error GoTo Clipboard_Error
        ReDim Preserve Hack_List.Patch_Objects(0 To Entry_Count)
        ReDim Preserve Hack_List.Locations(0 To Location_Count - 1)
        Insert_Hacks Hack_List, Append
        Exit Sub
Clipboard_Error:
        If Err <> 0 Then MsgBox "Data on clipboard is not text, is empty, or is not the right format."
    Else
        S_Offset = HexDecToDec(Start_Offset.Value)
        E_Offset = HexDecToDec(End_Offset.Value)
        If S_Offset < 0 Then MsgBox "Invalid Start Offset value", vbCritical, "Import Data": Exit Sub
        If E_Offset < 0 Then MsgBox "Invalid End Offset value", vbCritical, "Import Data": Exit Sub
        If ISO.Value Then
            Match_ID = GetFileMatch(Filename.Value, True, True, True)
            If Match_ID < 0 Then MsgBox "Invalid File """ & Filename.Value & """.", vbCritical, "Import Data": Exit Sub
        End If
        If Savestate.Value Then
            Mode = Import_From_Savestate
        Else
            Mode = Import_From_ISO
        End If
        VBATime True
        Fetch_Code Mode, S_Offset, E_Offset, Append, Match_ID, True
        VBATime False
    End If
End Sub

Private Sub Create_Patch_Click()
    Create_Code True
End Sub

Private Sub Insert_Click()
    Create_Code False
End Sub

Private Sub UserForm_Initialize()
    Me.StartUpPosition = 0
    Me.Left = CLng(ReadReg(RegFolder & "Import\Code\Window_X", CStr(Application.Left + Int((Application.width - Me.width) / 2)), 2147483647))
    Me.Top = CLng(ReadReg(RegFolder & "Import\Code\Window_Y", CStr(Application.Top + Int((Application.Height - Me.Height) / 2)), 2147483647))
    Dim File_Type As Byte
    File_Type = ReadReg(RegFolder & "Import\Type", 1, 2)
    Select Case File_Type
        Case 0: Savestate.Value = True
        Case 1: ISO.Value = True
        Case 2: Clipboard.Value = True
    End Select
    Call Toggle_File
    Filename.Value = ReadReg(RegFolder & "Import\Code\Filename", "")
    Start_Offset.Value = ReadReg(RegFolder & "Import\Code\Start_Offset", "0x80000000")
    End_Offset.Value = ReadReg(RegFolder & "Import\Code\End_Offset", "0x80000000")
    Memory.Value = True
    'Memory.Value = ReadReg(RegFolder & "Import\Code\Memory", "1", 1)
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call WriteReg(RegFolder & "Import\Code\Window_X", Me.Left - Application.Left)
    Call WriteReg(RegFolder & "Import\Code\Window_Y", Me.Top - Application.Top)
    Dim File_Type As Byte
    If Savestate.Value Then
        Call WriteReg(RegFolder & "Import\Type", 0)
    ElseIf Clipboard.Value Then
        Call WriteReg(RegFolder & "Import\Type", 2)
    Else
        Call WriteReg(RegFolder & "Import\Type", 1)
    End If
    Call WriteReg(RegFolder & "Import\Code\Filename", Filename.Value)
    Call WriteReg(RegFolder & "Import\Code\Start_Offset", Start_Offset.Value)
    Call WriteReg(RegFolder & "Import\Code\End_Offset", End_Offset.Value)
    'Call WriteReg(RegFolder & "Import\Code\Memory", Memory.Value)
End Sub

Attribute VB_Name = "importdataform"
Attribute VB_Base = "0{C8BAB536-6F5E-41B7-8003-1A23064BD9A1}{7AC28D39-3198-46B3-B1F0-1784814D4E7C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Option Explicit

Private Sub Toggle_File()
    If Savestate.Value Then
        Filename.Enabled = False
        Filename.BackColor = &H8000000B
    Else
        Filename.Enabled = True
        Filename.BackColor = &H80000005
    End If
End Sub
Private Sub ISO_Click()
    Call Toggle_File
End Sub
Private Sub Savestate_Click()
    Call Toggle_File
End Sub

Private Sub Format_Help_Click()
    MsgBox "Legend:" & vbCrLf & _
    "i = ignore (the entry will not be assigned a column)" & vbCrLf & _
    "h = hexadecimal (automatically flips bytes, default)" & vbCrLf & _
    "s = decimal signed" & vbCrLf & _
    "u = decimal unsigned" & vbCrLf & _
    "b = binary" & vbCrLf & _
    "B = binary (separate columns)" & vbCrLf & _
    "a = array of bytes" & vbCrLf & _
    vbCrLf & _
    "- Each column/entry must be separated by a ""/"";" & vbCrLf & _
    "- The sum of all numbers must add up to ""# Bytes per Row"";" & vbCrLf & _
    "- An empty string will return 1 byte (hex) per column." & vbCrLf & _
    vbCrLf & _
    "For example, the format ""1b/1i/4a/2u/2s/2h""" & vbCrLf & _
    "with row ""84 00 64 40 20 80 FF FF FE FF FE 01""," & vbCrLf & _
    "would return ""[10000100][64402080][65535][-2][01FE]""."
End Sub

Private Sub Update_Num_Rows()
    On Error GoTo Sub_End
    If ActiveControl.Name = End_Offset.Name Then
        On Error GoTo Default
        Dim New_Num_Rows As Long
        Dim S_Offset As Long
        Dim Row_Bytes As Long
        Row_Bytes = HexDecToDec(Bytes_Per_Row.Value)
        If Row_Bytes > 0 Then
            S_Offset = HexDecToDec(Start_Offset.Value)
            New_Num_Rows = Int((HexDecToDec(End_Offset.Value) + 1 - S_Offset) / HexDecToDec(Bytes_Per_Row.Value))
            Num_Rows.Value = New_Num_Rows
        End If
        Exit Sub
Default:
        Num_Rows.Value = 0
    End If
Sub_End:
End Sub

Private Sub Update_End_Offset()
    On Error GoTo Sub_End
    If ActiveControl.Name <> End_Offset.Name Then
        On Error GoTo Default
        Dim New_End_Offset As Long
        New_End_Offset = HexDecToDec(Start_Offset.Value) + HexDecToDec(Bytes_Per_Row.Value) * HexDecToDec(Num_Rows.Value) - 1
        If Left(Start_Offset.Value, 2) = "0x" Then
            Select Case Mid(Start_Offset.Value, 3, 1)
                Case "8"
                    End_Offset.Value = "0x8" & DecToHex(New_End_Offset, 7)
                Case Else
                    End_Offset.Value = "0x0" & DecToHex(New_End_Offset, 7)
            End Select
        Else
            End_Offset.Value = New_End_Offset
        End If
        Exit Sub
Default:
        End_Offset.Value = 0
    End If
Sub_End:
End Sub
Private Sub Num_Rows_Change()
    Call Update_End_Offset
End Sub

Private Sub Toggle_Split()
    If Split_Into_Columns.Value = True Then
        Format.Enabled = True
        Format.BackColor = &H80000005
    Else
        Format.Enabled = False
        Format.BackColor = &H8000000B
    End If
End Sub
Private Sub Split_Into_Columns_Click()
    Call Toggle_Split
End Sub

Private Sub Start_Offset_Change()
    Call Update_End_Offset
End Sub
Private Sub Bytes_Per_Row_Change()
    Call Update_End_Offset
End Sub
Private Sub End_Offset_Change()
    Call Update_Num_Rows
End Sub

Private Sub Preview_Click()
    Dim Format_Results As Format_Results
    Format_Results = Table_Format(Format.Value, HexDecToDec(Bytes_Per_Row.Value), Split_Into_Columns.Value)
    Range(Cells(Selection.Row, Selection.Column), Cells(Selection.Row + HexDecToDec(Num_Rows.Value, 1) - 1, Selection.Column + Format_Results.Column_Count - 1)).Select
End Sub

Private Sub Print_Data_Click()
    Dim S_Offset As Long, E_Offset As Long, Byte_Length As Long, Row_Count As Long
    S_Offset = HexDecToDec(Start_Offset.Value)
    E_Offset = HexDecToDec(End_Offset.Value)
    Byte_Length = HexDecToDec(Bytes_Per_Row.Value)
    Row_Count = HexDecToDec(Num_Rows.Value)
    If S_Offset < 0 Then MsgBox "Invalid Start Offset value", vbCritical, "Import Data": Exit Sub
    If E_Offset < 0 Then MsgBox "Invalid End Offset value", vbCritical, "Import Data": Exit Sub
    If Byte_Length < 1 Then MsgBox "Invalid # Bytes per Row value" & vbCrLf & "Must be at least 1.", vbCritical, "Import Data": Exit Sub
    If Row_Count < 1 Then MsgBox "Invalid # Rows value" & vbCrLf & "Must be at least 1.", vbCritical, "Import Data": Exit Sub
    Dim Format_Results As Format_Results
    Format_Results = Table_Format(Format.Value, HexDecToDec(Bytes_Per_Row.Value), Split_Into_Columns.Value)
    If Format_Results.Byte_Count <> Byte_Length Then MsgBox "Your Format entry lists " & Format_Results.Byte_Count & " while yout # Bytes per Row is " & Byte_Length & ".", vbCritical, "Import Data": Exit Sub
    
    Dim fnum As Integer
    fnum = FreeFile
    If Savestate.Value Then
        Open ReadReg(RegFolder & "Last Quicksave", "") For Binary As #fnum
        VBATime True
        Fetch_Data_With_Table Selection, Import_From_Savestate, S_Offset, Row_Count, Format_Results
    Else
        If Not Import_Files_List Then Exit Sub
        Dim Match_ID As Long
        Dim New_Offset As Long
        Match_ID = GetFileMatch(Filename.Value, True, True, True)
        If Match_ID < 0 Then MsgBox "Invalid File """ & Filename.Value & """.", vbCritical, "Import Data": Exit Sub
        If Open_ISO = -1 Then Exit Sub
        VBATime True
        Fetch_Data_With_Table Selection, Import_From_ISO, S_Offset, Row_Count, Format_Results, Match_ID, Memory.Value
    End If
    Call Preview_Click
    Close #fnum
    VBATime False
End Sub

Private Sub UserForm_Initialize()
    Me.StartUpPosition = 0
    Me.Left = CLng(ReadReg(RegFolder & "Import\Data\Window_X", CStr(Application.Left + Int((Application.width - Me.width) / 2)), 2147483647))
    Me.Top = CLng(ReadReg(RegFolder & "Import\Data\Window_Y", CStr(Application.Top + Int((Application.Height - Me.Height) / 2)), 2147483647))
    Dim File_Type As Byte
    File_Type = ReadReg(RegFolder & "Import\ISO", 1, 1)
    Select Case File_Type
        Case 0: Savestate.Value = True
        Case 1: ISO.Value = True
    End Select
    Call Toggle_File
    Filename.Value = ReadReg(RegFolder & "Import\Data\Filename", "")
    Start_Offset.Value = ReadReg(RegFolder & "Import\Data\Start_Offset", "0x80000000")
    End_Offset.Value = ReadReg(RegFolder & "Import\Data\End_Offset", "0x80000000")
    Memory.Value = ReadReg(RegFolder & "Import\Data\Memory", "1", 1)
    Bytes_Per_Row.Value = ReadReg(RegFolder & "Import\Data\Bytes_Per_Row", "0", 2147483647)
    Num_Rows.Value = ReadReg(RegFolder & "Import\Data\Num_Rows", "0", 2147483647)
    Split_Into_Columns.Value = ReadReg(RegFolder & "Import\Data\Split_Into_Columns", 1)
    Format.Value = ReadReg(RegFolder & "Import\Data\Format", "")
    Call Toggle_Split
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call WriteReg(RegFolder & "Import\Data\Window_X", Me.Left - Application.Left)
    Call WriteReg(RegFolder & "Import\Data\Window_Y", Me.Top - Application.Top)
    Dim File_Type As Byte
    If Savestate.Value Then
        Call WriteReg(RegFolder & "Import\ISO", 0)
    Else
        Call WriteReg(RegFolder & "Import\ISO", 1)
    End If
    Call WriteReg(RegFolder & "Import\Data\Filename", Filename.Value)
    Call WriteReg(RegFolder & "Import\Data\Start_Offset", Start_Offset.Value)
    Call WriteReg(RegFolder & "Import\Data\End_Offset", End_Offset.Value)
    Call WriteReg(RegFolder & "Import\Data\Memory", Memory.Value, REG_DWORD)
    Call WriteReg(RegFolder & "Import\Data\Bytes_Per_Row", Bytes_Per_Row.Value)
    Call WriteReg(RegFolder & "Import\Data\Num_Rows", Num_Rows.Value)
    Call WriteReg(RegFolder & "Import\Data\Split_Into_Columns", Split_Into_Columns.Value, REG_DWORD)
    Call WriteReg(RegFolder & "Import\Data\Format", Format.Value)
End Sub
Attribute VB_Name = "xmloutput"
Attribute VB_Base = "0{7DFBA8FA-0996-42C7-96C3-228852A2BA2B}{09951343-D0D4-4CFE-A33F-9B0F04AA36D4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


















Option Explicit


Private Sub OKButton_Click()
    Call Selected_Output
End Sub

Private Sub OutputList_DblClick(ByVal Cancel As MsForms.ReturnBoolean)
    Call Selected_Output
End Sub

Private Sub OutputList_KeyPress(ByVal KeyAscii As MsForms.ReturnInteger)
    If KeyAscii = vbKeyReturn Then
        Call Selected_Output
    End If
End Sub

Private Sub CancelButton_Click()
    XML_Output = 255
    Unload Me
End Sub

Private Sub cmdExit_Click()
    XML_Output = 255
    Unload Me
End Sub

Private Sub xmloutput_KeyPress(ByVal KeyAscii As MsForms.ReturnInteger)
    If KeyAscii = vbKeyEscape Then
        XML_Output = 255
        Unload Me
    End If
End Sub

Public Sub Selected_Output()
    XML_Output = xmloutput.OutputList.ListIndex
    WriteReg RegFolder & "XML Output", XML_Output & "", REG_DWORD
    Unload Me
End Sub

Public Sub SelectedOutput()
    Dim OutputSelection As Byte
    Dim OutputString As String
    Dim RegPath As String
    Dim i As Integer
    Dim FileString As String
    Dim UpdateXML As Boolean
    Dim StringStart As Integer
    Dim StringEnd As Integer
    Dim FullText As String
    Dim FileNameFromPath As String
    Dim FolderFromPath As String
    Dim FilePath As String
    Dim TrimmedString As String
    Dim XMLStart As Long
    Dim XMLEnd As Long
    Dim TrimmedChar As String
    Dim PatchString As String
    Dim FFTorgASM As String
    Dim PatchAtTheEnd As Boolean
    Dim objStream, strData
    OutputSelection = xmloutput.OutputList.ListIndex
    WriteReg RegFolder & "XML Output", OutputSelection & "", REG_DWORD

    With Worksheets(".xml")
        Select Case OutputSelection
            Case 0
                If ReadReg(RegFolder & "Don't Trim XML", ActiveWorkbook.path) = "1" Then
                    OptimizeMe
                    .Range(.Cells(1, 13), .Cells(GetXMLLastRow, 13)).Copy
                Else
                    OptimizeMe
                    .Range(.Cells(3, 13), .Cells(GetXMLLastRow - 1, 13)).Copy
                End If
                GoTo SubEnd
            Case 1
                UpdateXML = True
            Case 2
                UpdateXML = False
        End Select
    End With
    Unload Me

    RegPath = RegFolder & "Last XML"
    FilePath = ReadReg(RegPath, ActiveWorkbook.path)
    If Len(FilePath) < 5 Then FilePath = ActiveWorkbook.path & "\a"
    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
    If Len(Dir(FolderFromPath)) Then ChDir FolderFromPath
    
    If UpdateXML Then
        FilePath = Application.GetOpenFilename(FileFilter:="FFTOrgASM File (*.xml), *.xml", Title:="Select an XML file", MultiSelect:=False)
    Else
        FilePath = Application.GetSaveAsFilename(FileFilter:="FFTOrgASM File (*.xml), *.xml", Title:="Choose a Filename")
    End If
    If FilePath = "False" Then
        GoTo SubEnd
    End If
    WriteReg RegPath, FilePath
    OptimizeMe
    If UpdateXML Then
        StringStart = 3
        StringEnd = GetXMLLastRow - 1
    Else
        StringStart = 1
        StringEnd = GetXMLLastRow
    End If

    FileString = ""
    For i = StringStart To StringEnd
        FileString = FileString & Worksheets(".xml").Cells(i, 13) & vbCrLf
    Next i
    

    Set objStream = CreateObject("ADODB.Stream")
    objStream.Charset = "utf-8"
    objStream.Open

    If UpdateXML Then
        objStream.LoadFromFile (FilePath)
        FullText = objStream.ReadText()

        TrimmedString = FileString
        For i = 1 To Len(TrimmedString)
            If (Mid(TrimmedString, i, 1) <> " ") Then
                TrimmedString = Right(TrimmedString, Len(TrimmedString) - i + 1)
                Exit For
            End If
        Next i
        For i = Len(TrimmedString) - 2 To 1 Step -1
            TrimmedChar = Mid(TrimmedString, i, 1)
            If (TrimmedChar <> " ") And (TrimmedChar <> Chr(10)) And (TrimmedChar <> Chr(13)) Then
                TrimmedString = Left(TrimmedString, i)
                Exit For
            End If
        Next i
        PatchString = Left(TrimmedString, InStr(2, FileString, ">"))
        'Debug.Print PatchString
        XMLStart = InStr(1, FullText, PatchString)
        PatchAtTheEnd = True
        If XMLStart > 0 Then
            XMLEnd = InStr(XMLStart, FullText, "</Patch>") + 7
            If XMLEnd > 0 Then
                PatchAtTheEnd = False
            End If
        End If
        If Not PatchAtTheEnd Then
            FullText = Left(FullText, XMLStart - 1) & TrimmedString & Right(FullText, Len(FullText) - XMLEnd)
        Else
            XMLStart = InStr(1, FullText, "</Patches>")
            If XMLStart > 0 Then
                For i = XMLStart - 1 To 1 Step -1
                    If Mid(FullText, i, 1) <> " " Then
                        XMLStart = i
                        Exit For
                    End If
                Next i
                FullText = Left(FullText, XMLStart) & vbCrLf & FileString & Right(FullText, Len(FullText) - XMLStart)
                MsgBox "The patch tag containing this patch's name was not found." & vbCrLf & "Being unable to replace it, the patch was appended at the end of the file.", vbOKOnly, "Warning"
            Else
                MsgBox "</Patches> tag not found. Exiting Function.", vbOKOnly, "Error"
                GoTo SubEnd
            End If
        End If
        
        Dim objStreamWrite
        Set objStreamWrite = CreateObject("ADODB.Stream")
        objStreamWrite.Charset = "utf-8"
        objStreamWrite.Open
        objStreamWrite.WriteText FullText
        objStreamWrite.SaveToFile FilePath, 2
        objStreamWrite.Close
        objStream.Close
    Else
        objStream.WriteText FileString
        objStream.SaveToFile FilePath, 2
        objStream.Close
    End If
    Call WriteReg(RegPath, FilePath)

    FolderFromPath = Left(FilePath, InStrRev(FilePath, "\"))
    FFTorgASM = FolderFromPath & "\FFTorgASM.exe"
    
    Dim FFTorgASMExists As Integer
    Dim AfterExport As Byte
    
    
    FFTorgASMExists = Len(Dir(FFTorgASM))
    AfterExport = ReadReg(RegFolder & "After XML Export", 1, XMLExpMax)
    Select Case AfterExport
        Case 0
            GoTo SubEnd
        Case Else
            If ReadReg(RegFolder & "FFTOrgASM Focus", 0) Then
                On Error GoTo TryOpen
                AppActivate "FFTOrgASM", True
                Application.SendKeys "% ~", True
                GoTo SubEnd
            End If
    End Select
    
TryOpen:
    On Error Resume Next
    Select Case AfterExport
        Case 1
            If FFTorgASMExists Then
                If MsgBox("Open FFTorgASM?", vbYesNo, "FFTorgASM") Then
                    Shell FolderFromPath & "\FFTorgASM.exe", vbNormalFocus
                End If
            End If
        Case 2
            Shell FolderFromPath & "\FFTorgASM.exe", vbNormalFocus
    End Select
    
SubEnd:
    Unload Me
End Sub


' InQuest injected base64 decoded content
' M4[M4
' M4CM4
' M4CM4

INQUEST-PP=macro
