Attribute VB_Name = "CheckEK"
Sub CheckTrigramEK(trigram As String)
If Len(trigram) <> 3 Then
EKValid = False
End If

Sheets("Verif").Select
Cells(1, 3).Value = trigram

End Sub

Sub CheckVersionEK(Version As String)

    Dim splitVersion() As String
    Dim Increment As String
    splitVersion = Split(Version, ".")
    
    If UBound(splitVersion) <> 2 Then
        EKValid = False
        GoSub EndSub
    End If
    
    Increment = splitVersion(0)
    VersionMajeure = splitVersion(1)
    VersionMineure = splitVersion(2)
    
    'controle quer la chaine vaut Vx
    If Len(Increment) <> 2 Then
        EKValid = False
        GoSub EndSub
    End If
    
    If Mid(Increment, 1, 1) <> "V" Then
        EKValid = False
        GoSub EndSub
    End If
    
   If Int(Mid(Increment, 2, 1)) = 0 Then
        EKValid = False
        GoSub EndSub
   End If
    
    'controle que la chaine vaut x
    If (VersionMajeure <> "0") And Val(VersionMajeure) = 0 Then
        EKValid = False
        GoSub EndSub
   End If
   
   'controle que la chaine vaut xx
   If Len(VersionMineure) <> 2 Then
        EKValid = False
        GoSub EndSub
   End If
   
   If (VersionMineure <> "00") And Val(VersionMineure) = 0 Then
        EKValid = False
        GoSub EndSub
   End If
   
EndSub:

Sheets("Verif").Select
Cells(2, 3).Value = Version

End Sub


Attribute VB_Name = "Correctif"

Function CheckFTCor() As Integer

Dim ListFT() As String

    ListFT = getList("Correctifs", 2, 1)
    If UBound(ListFT) = 0 Then
        Erreur = "Pas de Correcion r|fffd|f|fffd|renc|fffd|e"
        CheckFTCor = 0
        GoTo EndFct
    End If
    
    
EndFct:
End Function
Attribute VB_Name = "CotsEditeur"
Attribute VB_Name = "CotsMoi"

Function CheckIsoMOI() As Boolean

Dim CheckIso As Integer

    CheckIsoMOI = True
    CheckIso = CheckIsoMOIFV()
    Select Case CheckIso
    Case 0:
        a = SetValueCom("Verif", 7, 3, Erreur)
        a = SetValueKO("Verif", 7, 2)
        CheckIsoMOI = False
        GoTo EndFct
    
    Case 1:
        a = SetValueCom("Verif", 7, 3, "")
        a = SetValueOK("Verif", 7, 2)
    
    Case 2:
        a = SetValueCom("Verif", 7, 3, Erreur)
        a = SetValueNA("Verif", 7, 2)
    
    End Select
    

' CheckIsoMOIEK

EndFct:
End Function

Function CheckIsoMOIFV() As Integer

Dim listCOTS() As String
Dim nomIso As String
Dim i As Integer
Dim repCotsMOI As String

    CheckIsoMOIFV = 1
    
    ' R|fffd|cup|fffd|ration de la liste des ISO de la fiche de version
    listCOTS = getList("COTS MOI", 2, 2)
    If UBound(listCOTS) = 0 Then
        Erreur = "Pas d'iso r|fffd|f|fffd|renc|fffd|"
        CheckIsoMOIFV = 2
        GoTo EndFct
    End If

    'V|fffd|rification de l'existence des ISO dans le r|fffd|pertoire logiciel
    repCotsMOI = Application.ActiveWorkbook.Path + "\" + "logiciels"

    Dim file() As String
    
    For i = 0 To UBound(listCOTS) - 1
    
        'Verification qu'il s'agit bien d'un iso
        file = Split(listCOTS(i), ".")
        If UBound(file) <> 1 Then
            Erreur = "Le fichier " + nomIso + "r|fffd|f|fffd|renc|fffd| dans la fiche de version n'est pas un ISO (" + listCOTS(i) + ")"
            CheckIsoMOIFV = 0
            GoTo EndFct
        End If
        
        
        Dim Ext As String
        Ext = file(1)
        If Ext <> "iso" Then
            Erreur = "Le fichier " + nomIso + "r|fffd|f|fffd|renc|fffd| dans la fiche de version n'est pas un ISO (" + Ext + ")"
            CheckIsoMOIFV = 0
            GoTo EndFct
        End If
        
        
        pathCotsMOI = repCotsMOI + "\" + listCOTS(i)
        nomIso = Dir(pathCotsMOI)
        If nomIso = "" Then
            Erreur = "Le fichier " + nomIso + "r|fffd|f|fffd|renc|fffd| dans la fiche de version n'existe pas"
            CheckIsoMOIFV = 0
            GoTo EndFct
        End If
    Next
    End
    
EndFct:
End Function
Function CheckIsoMOIEK()
End Function

Attribute VB_Name = "Feuil1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Public oldValue As String
Public listenerActivated As Boolean

Private Sub Worksheet_Activate()
oldValue = Range("B3")
listenerActivated = True
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
Dim i As Integer
If (listenerActivated) Then
    If (Target.Value <> oldValue) Then
        If (Target = Range("B3")) Then
            If (Target.Value = "Mono-onglet Installation") Then
                TransformationCapThales.convert
            Else
                TranformationThalesCap.convert
            End If
        End If
    End If
Else
    If (Target.Value = "Mono-onglet Installation") Then
        Sheets("Installation").Visible = True
        For i = 1 To 5
            Sheets("Gabarit" & i).Visible = False
        Next i
    Else
        Sheets("Installation").Visible = False
        For i = 1 To 5
            Sheets("Gabarit" & i).Visible = True
        Next i
    End If
End If
oldValue = Target.Value
End Sub


Attribute VB_Name = "Feuil4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Generation"
' Constantes
Public Const iColumnIndexOS As Integer = 1
Public Const iColumnIndexEtape As Integer = 2
Public Const iColumnIndexPhase As Integer = 3
Public Const iColumnIndexServeur As Integer = 4
Public Const iColumnIndexScript As Integer = 5
Public Const iColumnIndexCommentaire As Integer = 6
Public Const iColumnIndexAutomatique As Integer = 7
Public Const iColumnIndexNeedsReboot As Integer = 8
Public Const iColumnIndexTriesNumber As Integer = 9
Public repertoireGenerationScripts As String

Public fileDescriptor As Integer
Public objStream As Object
Public fileToCreate As String
Public fileType As String
Public trigrammeEK As String


Rem Fonction de g|fffd|n|fffd|ration des scripts
Function Genere() As Integer
Dim i As Integer
Sheets("Global").Visible = True
Sheets("Global").Select
repertoireGenerationScripts = Cells(1, 2)
trigrammeEK = Cells(2, 2)

If (Sheets("Global").Range("B3").Value = "Mono-onglet Installation") Then
    TranformationThalesCap.viderGabarits
    TranformationThalesCap.transform
End If

For i = 1 To Sheets.Count
    If (Sheets(i).Name <> "Installation") Then
            Sheets(i).Visible = True
            Sheets(i).Select
        If (Cells(1, 1) = "OS") Then
            GenerationLinux.Genere i
            GenerationWindows.Genere i
        End If
'        If (InStr(Sheets(i).Name, "Gabarit") = 1) Then
'            Sheets(i).Visible = False
'        End If
    End If
Next

If (Sheets("Global").Range("B3").Value = "Mono-onglet Installation") Then
    Sheets("Installation").Visible = True
    For i = 1 To 5
        Sheets("Gabarit" & i).Visible = False
    Next i
End If

End Function
Sub LancerGeneration()
Attribute LancerGeneration.VB_ProcData.VB_Invoke_Func = "N\n14"
'
' Macro3 Macro
'
' Touche de raccourci du clavier: Ctrl+Maj+N
'

Generation.Genere


End Sub

' Removes the Byte Order Mark - BOM from a text file with UTF-8 encoding
' The BOM defines that the file was stored with an UTF-8 encoding.

Public Function RemoveBOM(filePath)

    ' Create a reader and a writer
            Dim writer, reader, fileSize
            Set writer = CreateObject("Adodb.Stream")
            Set reader = CreateObject("Adodb.Stream")

    ' Load from the text file we just wrote
            reader.Open
            reader.LoadFromFile filePath

    ' Copy all data from reader to writer, except the BOM
            writer.Mode = 3
            writer.Type = 1
            writer.Open
            reader.Position = 5
            reader.CopyTo writer, -1

    ' Overwrite file
            writer.SaveToFile filePath, 2

    ' Return file name
            RemoveBOM = filePath

    ' Kill objects
            Set writer = Nothing
            Set reader = Nothing
    End Function

' Ouverture en |fffd|criture du fichier de sortie (script sh)
Function openFile(pGabaritName As String, pServerName As String, Extension As String)
fileDescriptor = FreeFile

Dim fileNameToCreate As String
Dim repNameToCreate As String
repToCreate = repertoireGenerationScripts + "\" + pGabaritName + "\" + pServerName
fileNameToCreate = repToCreate + "\" + "install_" + trigrammeEK + Extension

Dim Tableau() As String
Tableau = Split(repToCreate, "\")

' Cr|fffd|ation arbo si inexistant

Dim repTmp As String
repTmp = Tableau(0)
For i = 1 To UBound(Tableau)
    repTmp = repTmp + "\" + Tableau(i)
    If (Dir(repTmp, vbDirectory) = "") Then
        MkDir repTmp
    End If
Next i

If (Extension = ".sh") Then
    fileType = "Linux"
    Else
    fileType = "Windows"
End If


fileToCreate = fileNameToCreate
 
  'Create the stream
  Set objStream = CreateObject("ADODB.Stream")
  'Initialize the stream
  objStream.Open
  'Reset the position and indicate the charactor encoding
  objStream.Position = 0
  objStream.Charset = "UTF-8"

End Function


Function closeFile()
  'Save the stream to a file
  objStream.SaveToFile fileToCreate, 2
  If (fileType = "Linux") Then
    RemoveBOM fileToCreate
  End If
End Function

Function writeLineToFile(pString As String)
  'Write to the steam
  If (fileType = "Windows") Then
    objStream.WriteText pString & Chr(13) & Chr(10)
  Else
    objStream.WriteText pString & Chr(10)
  End If
  
  
End Function

Function Contient(pTab() As String, pChaine As String) As Boolean
    Contient = False
    For i = 1 To UBound(pTab)
        If pTab(i) = pChaine Then
            Contient = True
        End If
    Next i
End Function



Attribute VB_Name = "GenerationLinux"
Function QuestionEtapesRealisees(pServerName As String, pNumeroEtape As Integer)
    writeLineToFile "   echo ""L'etape " & pNumeroEtape & " a-t-elle d|fffd|j|fffd| |fffd|t|fffd| r|fffd|alis|fffd|e sur le serveur " + pServerName + " ?"""
    writeLineToFile "   unset mot"
    writeLineToFile "   set mot = """""
    writeLineToFile "   while [[ ""$mot"" != ""OUI"" ]]; do"
    writeLineToFile "      echo ""Tapez OUI lorsque la procedure a ete realisee correctement"""
    writeLineToFile "      read mot"
    writeLineToFile "   done"
    writeLineToFile ""
End Function
Function TerminerServeurs(pServerNames As String)
    writeLineToFile "   echo ""Veuillez poursuivre les scripts d'installation sur le(s) serveur(s) : " + pServerNames + """"
    writeLineToFile "   unset mot"
    writeLineToFile "   set mot = """""
    writeLineToFile "   while [[ ""$mot"" != ""OK"" ]]; do"
    writeLineToFile "      echo ""Tapez OK lorsqu'un script vous demandera de poursuivre sur cette machine ou que toutes les autres machines auront termin|fffd| leur script d'installation"""
    writeLineToFile "      read mot"
    writeLineToFile "   done"
    writeLineToFile ""
End Function

Function ExecuterScriptSurServeur(pServerName As String, LastStepIndexOnAnotherServer As Integer, LastOtherServer As String)
    writeLineToFile "   echo ""Veuillez lancer/poursuivre le script d'installation sur le serveur : " + pServerName + """"
    writeLineToFile "   unset mot"
    writeLineToFile "   set mot = """""
    writeLineToFile "   while [[ ""$mot"" != ""OK"" ]]; do"
    writeLineToFile "      echo ""Tapez OK pour continuer lorsque l'etape " & LastStepIndexOnAnotherServer & " a ete realisee sur le serveur " + LastOtherServer + """"
    writeLineToFile "      read mot"
    writeLineToFile "   done"
    writeLineToFile ""
End Function

Function EcrireCartouche(index As Integer, lNbEtapes As Integer, lEtapeCommentaire As String, lEtapePhase As String)
    writeLineToFile "# Etape " + Str(index) + " /" + Str(lNbEtapes) + " : " + lEtapeCommentaire + """"
    writeLineToFile "if (( $start_index <= " + Str(index) + " )); then"
    writeLineToFile "   echo ""#############################################################################################"""
    writeLineToFile "   echo ""  " + trigrammeEK + " - Phase " + lEtapePhase + " - Etape " & index & " /" + Str(lNbEtapes) + " : " + lEtapeCommentaire + """"
    writeLineToFile "   echo ""#############################################################################################"""
    writeLineToFile ""
End Function
' Fonction de g|fffd|n|fffd|ration des scripts
Function Genere(pSheetIndex As Integer) As Integer

' Initialisation des variables
Dim lEtapeIndex As Integer
Dim lEtapeScript As String
Dim lEtapeAutomatique As String
Dim lEtapePhase As String
Dim lServerName As String
Dim lEtapeCommentaire As String
Dim lEtapeNeedsReboot As String
Dim lEtapeTriesNumber As Integer
Dim lServerNames(50) As String
Dim lServerOS(50) As String
Dim lCell As String
Dim iRowIndex As Integer
iRowIndex = 2
Dim lNbEtapes As Integer
Dim lNbServers As Integer
Dim lIndexEtapeMax As Integer
Dim index As Integer
Dim Priorite_EK_Serveur(50) As Integer
lNbServers = 0

'Selection de l'onglet pass|fffd| en param|fffd|tres
Sheets(pSheetIndex).Select

' Recuperation du nom de l'EK
NomFichier = ActiveWorkbook.Name
TitreVersionExtension = Right(NomFichier, Len(NomFichier) - InStr(17, NomFichier, "_"))

' Calcul nombre d'|fffd|tapes et
' initialisation des fichiers correspondant |fffd| chaque serveur
Do While (Cells(iRowIndex, iColumnIndexServeur) <> "")
    lCell = Cells(iRowIndex, iColumnIndexServeur)
    
    If (Contient(lServerNames, lCell) = False) Then
        lNbServers = lNbServers + 1
        lServerNames(lNbServers) = lCell
        lServerOS(lNbServers) = Cells(iRowIndex, iColumnIndexOS)
    End If
    lIndexEtapeMax = Int(Cells(iRowIndex, iColumnIndexEtape))
    iRowIndex = iRowIndex + 1
    lNbEtapes = lNbEtapes + 1
Loop

For lindexserver = 1 To lNbServers
    If (LCase(lServerOS(lindexserver)) = "linux") Then
        
        openFile Sheets(pSheetIndex).Name, lServerNames(lindexserver), ".sh"

        writeLineToFile "#!/bin/bash"
        writeLineToFile ""
        
        writeLineToFile "start_index=0"
        writeLineToFile "script_name=`basename $0`"
        writeLineToFile "scriptAppelant=$1"
        writeLineToFile "stepFileName=`readlink -f $0`"".step"""
        


        writeLineToFile ""
        writeLineToFile "# Recuperation du script |fffd| appeler en cas de relance"
        writeLineToFile "if [[ $scriptAppelant != """" ]]; then"
        writeLineToFile "   pScriptPath=$scriptAppelant"
        writeLineToFile "else"
        writeLineToFile "   pScriptPath=`pwd`""/""$0"
        writeLineToFile "fi"
        writeLineToFile ""
        
        writeLineToFile "export LOGPATH=/opt/stcia/installation/install_" + trigrammeEK + ".log"
        
        writeLineToFile "export paramsODEFileName=""/opt/stcia/installation/params/allparametres/params.sh"""
        writeLineToFile "# Prise en compte des param|fffd|tres ODE sous forme de variables PS1"
        writeLineToFile "if [[ -f $paramsODEFileName ]]; then"
        writeLineToFile "   echo ""Lecture des param|fffd|tres ODE, veuillez patienter"""
        writeLineToFile "   source $paramsODEFileName"
        writeLineToFile "fi"
        writeLineToFile ""
        
        
        writeLineToFile "LIBRARY_SH=""/opt/stcia/installation/libs/library.sh"""
        writeLineToFile "if [[ -f $LIBRARY_SH ]]; then"
        writeLineToFile "   source $LIBRARY_SH"
        writeLineToFile "   if [ ! $? -eq 0 ]; then"
        writeLineToFile "       echo ""Echec chargement $LIBRARY_SH"""
        writeLineToFile "       exit 1"
        writeLineToFile "   fi"
        writeLineToFile "else"
        writeLineToFile "   echo ""Le script $LIBRARY_SH n'est pas pr|fffd|sent !!!"""
        writeLineToFile "   exit 1"
        writeLineToFile "fi"
        
        writeLineToFile ""
        writeLineToFile "# Recuperation du point d'arret de la derniere installation"
        writeLineToFile "if [[ -f $stepFileName ]]; then"
        writeLineToFile "   start_index=`cat $stepFileName`"
        writeLineToFile "fi"
        writeLineToFile ""
        
        If (lindexserver > 1) Then
            Dim NomServeur As String
            Dim NumeroEtape As Integer
            
            ' Calcul du numero d'|fffd|tape et du nom du serveur de la derni|fffd|re |fffd|tape
            iRowIndex = 1
            Do While (Cells(iRowIndex, iColumnIndexServeur) <> lServerNames(lindexserver))
                iRowIndex = iRowIndex + 1
            Loop
            NomServeur = Cells(iRowIndex - 1, iColumnIndexServeur)
            NumeroEtape = Int(Cells(iRowIndex - 1, iColumnIndexEtape))
                    
            writeLineToFile ""
            writeLineToFile "# Demande actions realisees sur serveurs precedent"
            writeLineToFile "if (( $start_index == 0 )); then"
            QuestionEtapesRealisees NomServeur, NumeroEtape
            writeLineToFile "fi"
            writeLineToFile ""
        End If

        For index = 1 To lNbEtapes
            lEtapeIndex = Int(Cells(index + 1, iColumnIndexEtape))
            lEtapeScript = Cells(index + 1, iColumnIndexScript)
            lEtapeAutomatique = Cells(index + 1, iColumnIndexAutomatique)
            lEtapePhase = Cells(index + 1, iColumnIndexPhase)
            lEtapeCommentaire = Cells(index + 1, iColumnIndexCommentaire)
            lEtapeNeedsReboot = Cells(index + 1, iColumnIndexNeedsReboot)
            lEtapeTriesNumber = Cells(index + 1, iColumnIndexTriesNumber)
        
            If (lServerNames(lindexserver) = Cells(index + 1, iColumnIndexServeur)) Then
        
                EcrireCartouche lEtapeIndex, lIndexEtapeMax, lEtapeCommentaire, lEtapePhase
                
                If (LCase(lEtapeAutomatique) = "oui") Then
                ' Lancement d'un script
                
                        writeLineToFile "   nb_tries=" & (lEtapeTriesNumber - 1)
                        writeLineToFile ""
                        writeLineToFile "   current_dir=`pwd`"
                        writeLineToFile "   " & lEtapeScript
                        writeLineToFile "   code_retour=$?"
                        writeLineToFile "   cd $current_dir"
                        writeLineToFile ""
                        writeLineToFile ""
                        writeLineToFile "   while (( $code_retour == 1 )) && (( $nb_tries > 0 )); do "
                        writeLineToFile "      current_dir=`pwd`"
                        writeLineToFile "      " & lEtapeScript
                        writeLineToFile "      code_retour=$?"
                        writeLineToFile "      cd $current_dir"
                        writeLineToFile "      nb_tries=$(($nb_tries - 1))"
                        writeLineToFile "   done"
                        writeLineToFile "   if (( $code_retour == 1 )); then"
                        writeLineToFile "      # Error"
                        writeLineToFile "      echo " + Str(index) + " > $stepFileName"
                        writeLineToFile "      exit 1"
                        writeLineToFile "   else"
                        writeLineToFile "       if (( $code_retour == 127 )); then"
                        writeLineToFile "           # Failed : command not found"
                        writeLineToFile "           echo " + Str(index) + " > $stepFileName"
                        writeLineToFile "           exit 1"
                        writeLineToFile "       else"
                        writeLineToFile "           if (( $code_retour == 2 )); then"
                        writeLineToFile "               # Failed"
                        writeLineToFile "               echo 0 > $stepFileName"
                        writeLineToFile "               exit 2"
                        writeLineToFile "           else"
                        writeLineToFile "               # Success"
                        writeLineToFile "               echo " + Str(index + 1) + " > $stepFileName"
                        writeLineToFile "           fi"
                        writeLineToFile "       fi"
                        writeLineToFile "   fi"
                        
                Else
                ' Demande d'execution d'une commande manuelle
                    writeLineToFile "   set mot = ""NON"""
                    writeLineToFile "   if (( $start_index == " + Str(index) + " )); then"
                    writeLineToFile "       echo ""L'etape manuelle : " + lEtapeScript + " a t'elle ete realisee ? (OUI/NON)"""
                    writeLineToFile "       unset mot"
                    writeLineToFile "       set mot = """""
                    writeLineToFile "       while [[ ""$mot"" != ""OUI"" -a ""$mot"" != ""NON"" ]]; do"
                    writeLineToFile "           echo ""Tapez ""OUI"" ou ""NON"" pour continuer"""
                    writeLineToFile "           read mot"
                    writeLineToFile "       done"
                    writeLineToFile "   fi"
                    writeLineToFile "   if (( $mot == ""OUI"" )); then "
                    writeLineToFile "       echo " + Str(index + 1) + " > $stepFileName"
                    writeLineToFile "   else"
                    writeLineToFile "       if (( $mot == ""NON"" )); then"
                    writeLineToFile "           echo ""Veuillez realiser manuellement l'etape suivante : " + lEtapeScript + " puis relancer le script $pScriptPath"""
                    writeLineToFile "           exit 999"
                    writeLineToFile "       fi"
                    writeLineToFile "   fi"
                End If
                          
                If (LCase(lEtapeNeedsReboot) = "oui") Then
                    writeLineToFile "# Cette etape demande le redemarrage de la machine"
                    writeLineToFile "echo ""bash ~/.install_stcia"" >> ~/.bashrc"
                    
                    writeLineToFile "echo ""#!/bin/bash"" > ~/.install_stcia"
                    
                    writeLineToFile "echo ""cp -rf ~/.bashrc ~/.bashrc.new"" >> ~/.install_stcia"
                    writeLineToFile "echo ""lineNumbers=\`grep -n stcia ~/.bashrc.new | cut -d : -f 1\`"" >> ~/.install_stcia"
                    writeLineToFile "echo ""for lineNumber in \$lineNumbers; do"" >> ~/.install_stcia"
                    writeLineToFile "echo ""   sed \${lineNumber}d ~/.bashrc.new > ~/.bashrc.new2"" >> ~/.install_stcia"
                    writeLineToFile "echo ""   mv -f ~/.bashrc.new2 ~/.bashrc.new"" >> ~/.install_stcia"
                    writeLineToFile "echo ""done"" >> ~/.install_stcia"
                    writeLineToFile "echo ""rm -f ~/.install_stcia"" >> ~/.install_stcia"
                    writeLineToFile "echo ""mv -f ~/.bashrc.new ~/.bashrc"" >> ~/.install_stcia"
                    
                    
                    writeLineToFile "echo ""cd `dirname $pScriptPath`"" >> ~/.install_stcia"
                    writeLineToFile "echo ""./`basename $pScriptPath`"" >> ~/.install_stcia"
                    writeLineToFile "chmod +x ~/.install_stcia"
                    writeLineToFile "sudo /sbin/reboot"
                    writeLineToFile "exit 0"
                    writeLineToFile ""
                End If
                writeLineToFile "fi"
                writeLineToFile ""
            Else
                If ((Cells(index, iColumnIndexServeur) = lServerNames(lindexserver) And (Cells(index + 1, iColumnIndexServeur) <> Cells(index, iColumnIndexServeur)))) Then
                    ' Demande d'execution d'une commande sur un autre serveur
                    EcrireCartouche lEtapeIndex, lIndexEtapeMax, lEtapeCommentaire, lEtapePhase
                    Dim newIndex As Integer
                    Dim LastStepIndexOnAnotherServer As Integer
                    Dim LastOtherServer As String
                    LastStepIndexOnAnotherServer = lIndexEtapeMax
                    For newIndex = index + 1 To lNbEtapes
                        If (Cells(newIndex, iColumnIndexServeur) = lServerNames(lindexserver)) Then
                            LastStepIndexOnAnotherServer = Cells(newIndex - 1, iColumnIndexEtape)
                            LastOtherServer = Cells(newIndex - 1, iColumnIndexServeur)
                            Exit For
                        End If
                    Next
                    
                    
                    
                    ExecuterScriptSurServeur Cells(index + 1, iColumnIndexServeur), LastStepIndexOnAnotherServer, LastOtherServer

                    writeLineToFile ""
                    writeLineToFile "   echo " + Str(index + 1) + " > $stepFileName"
                    writeLineToFile "fi"
                    writeLineToFile ""
                End If
            End If
            If (index = lNbEtapes) Then
                    ListeServeurs = ""
                    For i = 1 To lindexserver - 1
                        ListeServeurs = ListeServeurs + lServerNames(i) + " "
                    Next
                    TerminerServeurs (ListeServeurs)
            End If

        Next
        ' peut etre a deplacer au debut du script
        writeLineToFile "rm -f $stepFileName"
        closeFile
    End If
Next



End Function



Attribute VB_Name = "GenerationWindows"
Function QuestionEtapesRealisees(pServerNames As String)
    writeLineToFile "   echo ""Les etapes precedentes ont-elles deja ete realisees sur le(s) serveur(s) : " + pServerNames + "?"""
    writeLineToFile "   $mot = """""
    writeLineToFile "   while (""$mot"" -ne ""OUI"")"
    writeLineToFile "   {"
    writeLineToFile "      echo ""Tapez OUI lorsque l'action a |fffd|t|fffd| r|fffd|alis|fffd|e correctement"""
    writeLineToFile "      $mot=Read-Host"
    writeLineToFile "   }"
    writeLineToFile ""
End Function
Function TerminerServeurs(pServerNames As String)
    writeLineToFile "   echo ""Veuillez poursuivre les scripts d'installation sur le(s) serveur(s) : " + pServerNames + """"
    writeLineToFile "   $mot = """""
    writeLineToFile "   while (""$mot"" -ne ""OK"")"
    writeLineToFile "   {"
    writeLineToFile "      echo ""Tapez OK lorsqu'un script vous demandera de poursuivre sur cette machine ou que toutes les autres machines auront termin|fffd| leur script d'installation"""
    writeLineToFile "      $mot=Read-Host"
    writeLineToFile "   }"
    writeLineToFile ""
End Function
Function ExecuterScriptSurServeur(pServerName As String)
    writeLineToFile "   echo ""Veuillez lancer/poursuivre le script d'installation sur le serveur : " + pServerName + """"
    writeLineToFile "   $mot = """""
    writeLineToFile "   while (""$mot"" -ne ""OK"")"
    writeLineToFile "   {"
    writeLineToFile "      echo ""Tapez OK pour continuer lorsque l'action a |fffd|t|fffd| r|fffd|alis|fffd|e correctement"""
    writeLineToFile "      $mot=Read-Host"
    writeLineToFile "   }"
    writeLineToFile ""
End Function
Function EcrireCartouche(index As Integer, lNbEtapes As Integer, lEtapeCommentaire As String, lEtapePhase As String)
    writeLineToFile "# Etape " + Str(index) + " /" + Str(lNbEtapes) + " : " + lEtapeCommentaire
    writeLineToFile "if ($start_index -le " + Str(index) + ")"
    writeLineToFile "{"
    writeLineToFile "   echo ""#############################################################################################"""
    writeLineToFile "   echo ""  " + trigrammeEK + " - Phase " + lEtapePhase + " - Etape " + Str(index) + " /" + Str(lNbEtapes) + " : " + lEtapeCommentaire + """"
    writeLineToFile "   echo ""#############################################################################################"""
    writeLineToFile ""
End Function
' Fonction de g|fffd|n|fffd|ration des scripts
Function Genere(pSheetIndex As Integer) As Integer

' Initialisation des variables
Dim lEtapeScript As String
Dim lEtapeAutomatique As String
Dim lEtapePhase As String
Dim lServerName As String
Dim lEtapeCommentaire As String
Dim lEtapeNeedsReboot As String
Dim lEtapeTriesNumber As Integer
Dim lServerNames(50) As String
Dim lServerOS(50) As String
Dim lCell As String
Dim iRowIndex As Integer
iRowIndex = 2
Dim lNbEtapes As Integer
Dim lNbServers As Integer
Dim index As Integer
lNbServers = 0

'Selection de l'onglet pass|fffd| en param|fffd|tres
Sheets(pSheetIndex).Select

' Recuperation du nom de l'EK
NomFichier = ActiveWorkbook.Name
TitreVersionExtension = Right(NomFichier, Len(NomFichier) - InStr(17, NomFichier, "_"))

' Calcul nombre d'|fffd|tapes et
' initialisation des fichiers correspondant |fffd| chaque serveur
Do While (Cells(iRowIndex, iColumnIndexServeur) <> "")
    lCell = Cells(iRowIndex, iColumnIndexServeur)
    
    If (Contient(lServerNames, lCell) = False) Then
        lNbServers = lNbServers + 1
        lServerNames(lNbServers) = lCell
        lServerOS(lNbServers) = Cells(iRowIndex, iColumnIndexOS)
    End If
    iRowIndex = iRowIndex + 1
    lNbEtapes = lNbEtapes + 1
Loop

For lindexserver = 1 To lNbServers
    If (LCase(lServerOS(lindexserver)) = "windows") Then
        
        openFile Sheets(pSheetIndex).Name, lServerNames(lindexserver), ".ps1"
        
        writeLineToFile "param ([string]$scriptAppelant)"
        writeLineToFile "$code_retour=0"
        writeLineToFile "$LASTEXITCODE=0"
        writeLineToFile "$start_index=0"
        writeLineToFile "$script_name2=Split-Path |fffd|Leaf $MyInvocation.mycommand.Definition"
        writeLineToFile "$script_name=$script_name2.split(""."")[0]"
        writeLineToFile "$dir_name=Get-Location"
        writeLineToFile "$stepFileName= $MyInvocation.mycommand.Definition + "".step"""
        writeLineToFile "$paramsODEFileName=""D:\stcia\installation\params\allparametres\params.ps1"""
        writeLineToFile "# Prise en compte des param|fffd|tres ODE sous forme de variables PS1"
        writeLineToFile "if (Test-Path $paramsODEFileName)"
        writeLineToFile "{"
        writeLineToFile "   ""Lecture des param|fffd|tres ODE, veuillez patienter"""
        writeLineToFile "   . $paramsODEFileName"
        writeLineToFile "}"
        writeLineToFile ""
        
        writeLineToFile ""
        writeLineToFile "# Recuperation du script |fffd| appeler en cas de relance"
        writeLineToFile "if ($scriptAppelant -ne """" )"
        writeLineToFile "{"
        writeLineToFile "   $pScriptPath=$scriptAppelant"
        writeLineToFile "}"
        writeLineToFile "else"
        writeLineToFile "{"
        writeLineToFile "   $pScriptPath=$MyInvocation.mycommand.Definition"
        writeLineToFile "}"
        writeLineToFile ""

        
        writeLineToFile "$LIBRARY_SH=""D:\stcia\installation\libs\BibScripts.psm1"""
        writeLineToFile "if (Test-Path $LIBRARY_SH)"
        writeLineToFile "{"
        writeLineToFile "   Import-Module -Name $LIBRARY_SH -force"
'        writeLineToFile "   $code_retour=$LASTEXITCODE"
'        writeLineToFile "   if ($code_retour -ne 0)"
'        writeLineToFile "   {"
'        writeLineToFile "       echo ""Echec chargement $LIBRARY_SH"""
'        writeLineToFile "       exit 1"
'        writeLineToFile "   }"
        writeLineToFile "}"
        writeLineToFile "else"
        writeLineToFile "{"
        writeLineToFile "   echo ""Le script $LIBRARY_SH n'est pas pr|fffd|sent !!!"""
        writeLineToFile "   exit 1"
        writeLineToFile "}"
        writeLineToFile "$global:LOGPATH=""D:\stcia\installation\install_" + trigrammeEK + ".log"""
        writeLineToFile "cd $dir_name"

        
        ' retrait de la cl|fffd| de registre
        RemoveRunKey
        
        writeLineToFile ""
        writeLineToFile "# Recuperation du point d arret de la derniere installation"
        writeLineToFile "if (Test-Path $stepFileName)"
        writeLineToFile "{"
        writeLineToFile "   $start_index=Get-Content $stepFileName"
        writeLineToFile "}"
        writeLineToFile ""
        
        If (lindexserver > 1) Then
            Dim ListeServeurs As String
            ListeServeurs = ""
            For index = 1 To lindexserver - 1
                ListeServeurs = ListeServeurs + lServerNames(index) + " "
            Next
        
            writeLineToFile ""
            writeLineToFile "# Demande actions realisees sur serveurs precedent"
            writeLineToFile "if ( $start_index -eq 0 )"
            writeLineToFile "{"
            QuestionEtapesRealisees ListeServeurs
            writeLineToFile "}"
            writeLineToFile ""
        End If

        
        
        For index = 1 To lNbEtapes
                
            lEtapeScript = Cells(index + 1, iColumnIndexScript)
            lEtapeAutomatique = Cells(index + 1, iColumnIndexAutomatique)
            lEtapePhase = Cells(index + 1, iColumnIndexPhase)
            lEtapeCommentaire = Cells(index + 1, iColumnIndexCommentaire)
            lEtapeNeedsReboot = Cells(index + 1, iColumnIndexNeedsReboot)
            lEtapeTriesNumber = Cells(index + 1, iColumnIndexTriesNumber)
            
            
            If (lServerNames(lindexserver) = Cells(index + 1, iColumnIndexServeur)) Then
            
                EcrireCartouche index, lNbEtapes, lEtapeCommentaire, lEtapePhase

                If (LCase(lEtapeAutomatique) = "oui") Then
                ' Lancement d'un script
                
                        writeLineToFile "   $nb_tries = " + Str(lEtapeTriesNumber - 1)
                        writeLineToFile "   try {"
                        writeLineToFile "   $current_dir=$(get-location).path"
                        writeLineToFile "   " + lEtapeScript
                        writeLineToFile "   $code_retour=$LASTEXITCODE"
                        writeLineToFile "   cd $current_dir"
                        writeLineToFile "   }"
                        writeLineToFile "   catch [System.Management.Automation.CommandNotFoundException] {"
                        writeLineToFile "      echo " + Str(index) + " | Out-File $stepFileName"
                        writeLineToFile "      exit 1"
                        writeLineToFile "   }"
                        writeLineToFile ""
                        writeLineToFile "   while ($code_retour -eq 1 -And $nb_tries -gt 0)"
                        writeLineToFile "   {"
                        writeLineToFile "      Write-Host ""ERREUR : code retour =""$code_retour"" ==> Nouvel essai"""
                        writeLineToFile "      $current_dir=$(get-location).path"
                        writeLineToFile "      " + lEtapeScript
                        writeLineToFile "      $code_retour=$LASTEXITCODE"
                        writeLineToFile "      cd $current_dir"
                        writeLineToFile "      $nb_tries=$nb_tries - 1"
                        writeLineToFile "   }"
                        writeLineToFile "   if ($code_retour -eq 0)"
                        writeLineToFile "   {"
                        writeLineToFile "           # Success"
                        writeLineToFile "           echo " + Str(index + 1) + " | Out-File $stepFileName"
                        writeLineToFile "   }"
                        writeLineToFile "   else"
                        writeLineToFile "   {"
                        writeLineToFile "       if ($code_retour -eq 1)"
                        writeLineToFile "       {"
                        writeLineToFile "           # Error"
                        writeLineToFile "           echo " + Str(index) + " | Out-File $stepFileName"
                        writeLineToFile "           Write-Host ""ERREUR : code retour =""$code_retour"
                        writeLineToFile "           exit 1"
                        writeLineToFile "       }"
                        writeLineToFile "       else"
                        writeLineToFile "       {"
                        writeLineToFile "           # Failed"
                        writeLineToFile "           echo 0 > $stepFileName"
                        writeLineToFile "           Write-Host ""ERREUR : code retour =""$code_retour"
                        writeLineToFile "           exit 2"
                        writeLineToFile "       }"
                        writeLineToFile "   }"
                        
                Else
                    ' Demande d'execution d'une commande manuelle
                    writeLineToFile "   $mot = ""NON"""
                    writeLineToFile "   if ( $start_index -eq " + Str(index) + " )"
                    writeLineToFile "   {"
                    writeLineToFile "       echo ""L'etape manuelle : " + lEtapeScript + " a t'elle ete realisee ? (OUI/NON)"""
                    writeLineToFile "       $mot = """""
                    writeLineToFile "       while ( ""$mot"" -ne ""OUI"" -And ""$mot"" -ne ""NON"" )"
                    writeLineToFile "       {"
                    writeLineToFile "           echo ""Tapez ""OUI"" ou ""NON"" pour continuer"""
                    writeLineToFile "           $mot=Read-Host"
                    writeLineToFile "       }"
                    writeLineToFile "   }"
                    writeLineToFile "   if ( $mot -eq ""OUI"" )"
                    writeLineToFile "   {"
                    writeLineToFile "       echo " + Str(index + 1) + " | Out-File $stepFileName"
                    writeLineToFile "   }"
                    writeLineToFile "   else"
                    writeLineToFile "   {"
                    writeLineToFile "       if ( $mot -eq ""NON"" )"
                    writeLineToFile "       {"
                    writeLineToFile "           echo ""Veuillez realiser manuellement l'etape suivante : " + lEtapeScript + " puis relancer le script $pScriptPath"""
                    writeLineToFile "           exit 999"
                    writeLineToFile "       }"
                    writeLineToFile "   }"
            
                End If
                
                
                If (LCase(lEtapeNeedsReboot) = "oui") Then
                ' ajouter l'ex|fffd|cution de ce script dans le RunOnce
                    addRunKey "$dir_name", "$script_name2"
                    writeLineToFile "# Cette etape demande le redemarrage de la machine"
                    writeLineToFile "Restart-Computer"
                    writeLineToFile ""
                End If
                
                writeLineToFile "}"
                writeLineToFile ""

            Else
                If ((Cells(index, iColumnIndexServeur) = lServerNames(lindexserver) And (Cells(index + 1, iColumnIndexServeur) <> Cells(index, iColumnIndexServeur)))) Then

                    ' Demande d'execution d'une commande sur un autre serveur
                    EcrireCartouche index, lNbEtapes, lEtapeCommentaire, lEtapePhase
                    ExecuterScriptSurServeur (Cells(index + 1, iColumnIndexServeur))
                    writeLineToFile ""
                    writeLineToFile "   echo " + Str(index + 1) + " | Out-File $stepFileName"
                    writeLineToFile "}"
                    writeLineToFile ""
   
                End If
            End If
            
            If (index = lNbEtapes) Then
                    ListeServeurs = ""
                    For i = 1 To lindexserver - 1
                        ListeServeurs = ListeServeurs + lServerNames(i) + " "
                    Next
                    TerminerServeurs (ListeServeurs)
            End If
            
            
        Next
        
        writeLineToFile "Remove-Item -force $stepFileName"
        closeFile
    End If
Next


End Function


Function addRunKey(pDirName As String, pScriptToRun As String)
    writeLineToFile "$RegistryKey = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run'"
    writeLineToFile "$PoSh = ""C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe"""
    writeLineToFile "Write-Verbose ""Marking current location..."""
    writeLineToFile "Push-Location"
    writeLineToFile "Write-Verbose ""Moving to $RegistryKey..."""
    writeLineToFile "Set-Location -Path $RegistryKey"
    writeLineToFile "$dirname=Split-Path -Parent $pScriptPath"
    writeLineToFile "$basename=Split-Path -Leaf $pScriptPath"
    writeLineToFile "$FullPath = $PoSh +  ' ""' + ""cd $dirname ; .\$basename"" + '""'"
    writeLineToFile "Write-Verbose ""Setting RunOnce to use PowerShell..."""
    writeLineToFile "Set-ItemProperty -Path . -Name ""STC-IA Installation"" -Value $FullPath"
    writeLineToFile "Set-Location " + pDirName
End Function

Function RemoveRunKey()
    writeLineToFile "$RegistryKey = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run'"
    writeLineToFile "if ((Get-ItemProperty  -path $RegistryKey).""STC-IA Installation"" -ne $null)"
    writeLineToFile "{"
    writeLineToFile "   Remove-ItemProperty -Path $RegistryKey -Name ""STC-IA Installation"""
    writeLineToFile "}"
End Function



Attribute VB_Name = "Main"
Public EKValid As Boolean
Public Erreur As String
Attribute VB_Name = "Menage"
'Dans le haut d'un module standard : d|fffd|claration des API
Private Declare Function OpenClipboard Lib "user32" _
    (ByVal hwnd As Long) As Long
Private Declare Function EmptyClipboard Lib "user32" () As Long
Private Declare Function CloseClipboard Lib "user32" () As Long


Sub Nettoie()
Application.EnableEvents = False
Dim Sht As Worksheet, DCell As Range, Calc As Long, Rien As String, Avant As Double, plage As Range
On Error Resume Next
Calc = Application.Calculation ' ---- m|fffd|morisation de l'|fffd|tat de recalcul
'------------------------------------------------------------
'MsgBox "Pour le classeur actif : " _
'& Chr(10) & ActiveWorkbook.FullName _
'& Chr(10) & "dans chaque feuille de calcul" _
'& Chr(10) & "recherche la zone contenant des donn|fffd|es," _
'& Chr(10) & "r|fffd|initialise la derni|fffd|re cellule utilis|fffd|e" _
'& Chr(10) & "et optimise la taille du fichier Excel", _
'vbInformation, _
'"d'apr|fffd|s LL par GeeDee@m6net.fr"
'-------------------------------------------------------------
'MsgBox "Taille initiale de ce classeur en octets" _
'& Chr(10) & FileLen(ActiveWorkbook.FullName), _
'vbInformation, ActiveWorkbook.FullName
'------------------------------------------------------------
With Application
    .Calculation = xlCalculationManual
    .StatusBar = "Nettoyage en cours..."
    .EnableCancelKey = xlErrorHandler
    .ScreenUpdating = True
End With
'-------------------- le traitement
For Each Sht In Worksheets
    If (Sht.Name <> "Global") Then
        Avant = Sht.UsedRange.Cells.Count
        Application.StatusBar = Sht.Name & "-" & Sht.UsedRange.Address
        '-------------------Traitement de la zone trouv|fffd|e
        If Sht.UsedRange.Address <> "$A$1" Or Not IsEmpty(Sht.[A1]) Then
            Set DCell = Sht.Cells.Find("*", , , , xlByRows, xlPrevious)(2)
            '----------------Suppression des lignes inutilis|fffd|es
            If Not DCell Is Nothing Then
                Sht.Range(DCell, Sht.Cells([A:A].Count, 1)).EntireRow.Delete
                Set DCell = Nothing
                Set DCell = Sht.Cells.Find("*", , , , xlByColumns, xlPrevious)(, 2)
                '----------------Suppression des colonnes inutilis|fffd|es
                If Not DCell Is Nothing Then Sht.Range(DCell, Sht.[IV1]).EntireColumn.Delete
            End If
            Rien = Sht.UsedRange.Address
        End If
        ActiveWorkbook.Save
        '---------------------Message pour la feuille trait|fffd|e
        MsgBox "Nom de la feuille de calcul :" _
        & Chr(10) & Sht.Name _
        & Chr(10) & Format(Sht.UsedRange.Cells.Count / Avant, "0.00%") & " de la taille initiale", vbInformation, ActiveWorkbook.FullName
    End If
Next Sht
'--------------------Message fin de traitement
MsgBox "Taille optimis|fffd|e de ce classeur en octets " & Chr(10) & FileLen(ActiveWorkbook.FullName), vbInformation, ActiveWorkbook.FullNameActive
'--------------------
Application.StatusBar = False
Application.Calculation = Calc
Application.EnableEvents = True
End Sub



'---------------------------
Sub Vider_Presse_Papier()
        OpenClipboard 0
        EmptyClipboard
        CloseClipboard
End Sub
'---------------------------

Attribute VB_Name = "NC"

Function CheckFTNC() As Integer

Dim ListFT() As String

    ListFT = getList("NC", 2, 1)
    If UBound(ListFT) = 0 Then
        Erreur = "Pas de FT"
        CheckFTNC = 1
        GoTo EndFct
    End If
    
    
EndFct:
End Function
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "TranformationThalesCap"
Option Explicit

Public Sub transform()
Dim i As Integer
Dim Source As Range
Dim Destination As Range
Dim CellsStart As Range
Dim CellsEnd As Range
Sheets("Installation").Visible = True
For i = 1 To 5
        Sheets("Gabarit" & i).Visible = True
        Dim NumLigne As Integer
        Dim Ligne As Integer
        Ligne = 2
        While (Sheets("Installation").Cells(Ligne, 1) <> "")
            Ligne = Ligne + 1
        Wend


        Set CellsStart = Sheets("Installation").Range("A2")
        Set CellsEnd = Sheets("Installation").Range("N" & Ligne)
        Set Source = Sheets("Installation").Range(CellsStart, CellsEnd)
        Set Destination = Sheets("Gabarit" & i).Range(Sheets("Gabarit" & i).Cells(2, 1), Sheets("Gabarit" & i).Cells(Ligne, 14))
        Source.Copy Destination
        Ligne = 2
        
        While (Sheets("Gabarit" & i).Cells(Ligne, 1) <> "")
            ' si la colonne 9+i contient qqchose on garde la ligne sinon on efface
            If (Sheets("Gabarit" & i).Cells(Ligne, 9 + i) = "") Then
                Sheets("Gabarit" & i).Rows(Ligne).Delete
            Else
                Ligne = Ligne + 1
            End If
        Wend
        
        Sheets("Gabarit" & i).Range("J:N").Delete
Next i
Sheets("Installation").Visible = False
End Sub


Public Sub viderGabarits()
Dim i As Integer
For i = 1 To Sheets.Count
    If (InStr(Sheets(i).Name, "Gabarit") = 1) Then
        Sheets(i).Visible = True
        While Sheets(i).Range("A2").Value <> ""
            Sheets(i).Rows(2).Delete
        Wend
        Sheets(i).Visible = False
    End If
Next i
End Sub

Public Sub convert()
Attribute convert.VB_ProcData.VB_Invoke_Func = "C\n14"
Dim i As Integer
    viderGabarits
    transform
    Sheets("Installation").Visible = False
    For i = 1 To 5
        Sheets("Gabarit" & i).Visible = True
    Next i
End Sub


Attribute VB_Name = "TransformationCapThales"
Option Explicit

Public Function transform() As Boolean
Dim NumLigneDest As Integer
Dim Source As Range
Dim Destination As Range
Dim CellsStart As Range
Dim CellsEnd As Range
Dim i, j As Integer
Dim OldLigneDest As Integer
transform = False
NumLigneDest = 0
Sheets("Installation").Visible = True
For i = 1 To 5
    Sheets("Gabarit" & i).Visible = True
    Dim Ligne As Integer
    Ligne = 2
    
    Do While (Sheets("Gabarit" & i).Cells(Ligne, 1) <> "")
        NumLigneDest = Int(Sheets("Gabarit" & i).Cells(Ligne, 2)) + 1
        Set CellsStart = Sheets("Gabarit" & i).Range("A" & Ligne)
        Set CellsEnd = Sheets("Gabarit" & i).Range("I" & Ligne)
        Set Source = Sheets("Gabarit" & i).Range(CellsStart, CellsEnd)
        Set Destination = Sheets("Installation").Range(Sheets("Installation").Cells(NumLigneDest, 1), Sheets("Installation").Cells(NumLigneDest, 9))
        
'        If (i > 1) Then
            If (CompareRanges(Source, Destination) = False) Then
                MsgBox "Deux |fffd|tapes diff|fffd|rentes ont le m|fffd|me num|fffd|ro. Corrigez avant de convertir !!!!" & Chr(10) & "Source = " & Source.Cells(1, 1) & " " & Source.Cells(1, 2) & " " & Source.Cells(1, 3) & " " & Source.Cells(1, 4) & Chr(10) & "Destination = " & Destination.Cells(1, 1) & " " & Destination.Cells(1, 2) & " " & Destination.Cells(1, 3) & " " & Destination.Cells(1, 4)
                Feuil3.listenerActivated = False
                Sheets("Global").Range("B3").Value = "Multi-onglets Gabarits"
                Feuil3.listenerActivated = True
'                Sheets("Installation").Visible = False
'                For j = 1 To 5
'                    Sheets("Gabarit" & j).Visible = True
'                Next j
                Exit Function
            End If
'        End If
        
        Source.Copy Destination
        Sheets("Installation").Cells(NumLigneDest, 9 + i) = "X"
        Ligne = Ligne + 1
        OldLigneDest = NumLigneDest
    Loop
Next i
Sheets("Installation").Visible = False
Set CellsStart = Nothing
Set CellsEnd = Nothing
Set Source = Nothing
Set Destination = Nothing
transform = True
End Function

Function CompareRanges(Source As Range, Destination As Range) As Boolean
Dim i As Integer
Dim DestinationEmpty As Boolean
DestinationEmpty = True
CompareRanges = True

For i = 1 To 9
    If (Destination.Cells(1, i).Value <> "") Then
        DestinationEmpty = False
    End If
Next i
If (DestinationEmpty = False) Then
    For i = 1 To 9
        If (Source.Cells(1, i).Value <> Destination.Cells(1, i).Value) Then
            CompareRanges = False
        End If
    Next i
End If

End Function

Public Sub viderInstallation()
    Sheets("Installation").Visible = True
    While Sheets("Installation").Cells(2, 1).Value <> ""
        Sheets("Installation").Rows(2).Delete
    Wend
    Sheets("Installation").Visible = False
End Sub

Public Sub convert()
Attribute convert.VB_ProcData.VB_Invoke_Func = "T\n14"
Dim i As Integer
    viderInstallation
    If transform Then
        Sheets("Installation").Visible = True
        For i = 1 To 5
            Sheets("Gabarit" & i).Visible = False
        Next i
    End If
End Sub
Attribute VB_Name = "commun"
Function getList(sheet As String, indexLigne As Integer, indexColonne As Integer) As String()
Sheets(sheet).Select
Dim Tableau() As String
ReDim Tableau(0)
'Tableau(0) = "toto.txt"
'Tableau(1) = "titi.txt"
'Tableau(0) = ""
getList = Tableau
End Function

Function SetValueOK(sheet As String, indexLigne As Integer, indexColonne As Integer) As Boolean
Sheets(sheet).Select
With Cells(indexLigne, indexColonne).Font
    .ColorIndex = 10
    .Bold = True
    .Name = "WingDings"
    .Size = 12
    End With
    
With Cells(indexLigne, indexColonne)
    .VerticalAlignment = xlVAlignCenter
    .HorizontalAlignment = xlCenter
    .Value = "J"
End With
End Function
    
    
Function SetValueKO(sheet As String, indexLigne As Integer, indexColonne As Integer) As Boolean
Sheets(sheet).Select
With Cells(indexLigne, indexColonne).Font
    .ColorIndex = 3
    .Bold = True
    .Name = "WingDings"
    .Size = 12
    End With
    
With Cells(indexLigne, indexColonne)
    .VerticalAlignment = xlVAlignCenter
    .HorizontalAlignment = xlCenter
    .Value = "K"
End With

End Function

Function SetValueNA(sheet As String, indexLigne As Integer, indexColonne As Integer) As Boolean
Sheets(sheet).Select
With Cells(indexLigne, indexColonne).Font
    .ColorIndex = 46
    .Bold = True
    .Name = "Arial"
    .Size = 10
    End With
    
With Cells(indexLigne, indexColonne)
    .VerticalAlignment = xlVAlignCenter
    .HorizontalAlignment = xlCenter
    .Value = "N/A"
End With

End Function

Function SetValueCom(sheet As String, indexLigne As Integer, indexColonne As Integer, Com As String) As Boolean
Sheets(sheet).Select
With Cells(indexLigne, indexColonne).Font
    .ColorIndex = 0
    .Bold = False
    .Name = "Calibri"
    .Size = 10
    End With
    
With Cells(indexLigne, indexColonne)
    .VerticalAlignment = xlVAlignCenter
    .HorizontalAlignment = xlLeft
    .Value = Com
End With

End Function


' InQuest injected base64 decoded content
' {-jY

INQUEST-PP=macro
