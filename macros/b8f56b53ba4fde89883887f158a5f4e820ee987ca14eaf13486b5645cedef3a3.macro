Attribute VB_Name = "CallbackHandler"
'---------------------------------------------------------------------------------------
' Modul    : CallbackHandler
' Autor    : Todor Vachkov
' Datum    : 03.09.2013
' Zweck    : dient als Wrapper zum Aufrufen der Prozeduren in der Callback-Klasse zum IkolClientApp-Objekt im Modul
'---------------------------------------------------------------------------------------

Option Explicit

Public gobjIkolClientAppInCallbackHandler As TC_IkolClientApp


Public Sub Protokoll(strTag As String, strMessage As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "Protokoll", VbMethod, strTag, strMessage
End Sub

'23.06.2014 AL
Public Sub ProtokollOuter(strTag As String, strMessage As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "Protokoll", VbMethod, strTag, strMessage
End Sub

Public Sub WaehleDrucker(strNeuerDrucker As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "WaehleDrucker", VbMethod, strNeuerDrucker
End Sub

Public Sub HoleStandardDrucker(strStandardDrucker As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleStandardDrucker", VbMethod, strStandardDrucker
End Sub

Public Sub HoleIKOLTitel(strIKOLTitel As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleIKOLTitel", VbMethod, strIKOLTitel
End Sub

Public Sub HoleParameterValue(strParameterName As String, strParameterValue As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleParameterValue", VbMethod, strParameterName, strParameterValue
End Sub

Public Sub SetzeParameterValue(strParameterName As String, strParameterValue As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "SetzeParameterValue", VbMethod, strParameterName, strParameterValue
End Sub

Public Sub SetzeStandardDrucker(strStandardDrucker As String, intResult As Integer)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "SetzeStandardDrucker", VbMethod, strStandardDrucker, intResult
End Sub

Public Sub HoleAktuellesIKOLDokument(objWorkingDocument As Document)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleAktuellesIKOLDokument", VbMethod, objWorkingDocument
End Sub

Public Sub HoleArbeitsVerzeichnis(strWorkingDirectory As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleArbeitsVerzeichnis", VbMethod, strWorkingDirectory
End Sub

Public Sub HoleDokumentenVerzeichnis(strDocumentDirectory As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleDokumentenVerzeichnis", VbMethod, strDocumentDirectory
End Sub

Public Sub DokumentSpeichernUnter(strOldFileName As String, strNewFileName As _
                                                            String, intSaveAsMode As Integer, intResult As Integer)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "DokumentSpeichernUnter", VbMethod, strOldFileName, strNewFileName, intSaveAsMode, intResult
End Sub

'23.06.2014 AL
Public Sub DokumentSpeichernUnterOuter(strOldFileName As String, strNewFileName As _
                                                            String, intSaveAsMode As Integer, intResult As Integer, mitBeforeSave As Boolean)
10        gboolWithBeforeSave = mitBeforeSave
20        CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "DokumentSpeichernUnter", VbMethod, strOldFileName, strNewFileName, intSaveAsMode, intResult
30        gboolWithBeforeSave = True 'Standard ztur|fffd|cksetzen
End Sub

'25.04.2016 AL
Public Sub getSchalter_UPAD_FINAL_QUESTION(boolResult As Boolean)
10        CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "getSchalter_UPAD_FINAL_QUESTION", VbMethod, boolResult
End Sub

'19.04.2016 AL
Public Sub getSchalter_SIGNPAD(strResult As String)
10        CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "getSchalter_SIGNPAD", VbMethod, strResult
End Sub

'16.09.2014 AL
Public Sub getSchalter_RIBBON_MINIMIEREN(boolResult As Boolean)
10        CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "getSchalter_RIBBON_MINIMIEREN", VbMethod, boolResult
End Sub

'26.02.2018 AL
Public Sub getSchalter_DELTA_SCROLL(boolResult As Boolean)
10        CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "getSchalter_DELTA_SCROLL", VbMethod, boolResult
End Sub

'17.02.2015 AL
Public Sub getSchalter_SpeichernAlsSBentfernen(boolResult As Boolean)
10        CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "getSchalter_SPEICHERN_ALS_SB_ENTFERNEN", VbMethod, boolResult
End Sub

Public Sub HoleVerzeichnisEAkte(strArchivDirectory As String)
10    CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleVerzeichnisEAkte", VbMethod, strArchivDirectory
End Sub

Public Sub SetzeAnwendungsProzessID(longApplicationPID As Long)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "SetzeAnwendungsProzessID", VbMethod, longApplicationPID
End Sub

Public Sub SignupMessage(style As VbMsgBoxStyle, SecondCaption As String, msgText As String)
5   Call gobjIkolClientAppInCallbackHandler.SignUpHandler.DoSignupMsg(style, SecondCaption, msgText)
End Sub

'17.04.2014 AL
'hiermit kann der Name der aktuellen DO-Datei in kundeneigenen Makros bestimmt werden:
'  Application.Run "HoleDoFileName", retValue
Public Sub HoleDoFileName(strDoFileName As String)
5   CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "HoleDoFileName", VbMethod, strDoFileName
End Sub

'02.09.2014 AL
Public Sub SetzeIKOLButtonEigenschaften(controlId As String, _
                                newActionString As String, _
                                toolTip As String, _
                                intResult As Integer)
10  CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "SetzeIKOLButtonEigenschaften", VbMethod, controlId, newActionString, toolTip, intResult
End Sub

'02.09.2014 AL
Public Sub SetzeStandardIKOLCommandbar(intResult As Integer)
10  CallByName gobjIkolClientAppInCallbackHandler.CallbackHandler, "SetzeStandardIKOLCommandbar", VbMethod, intResult
End Sub

'14.07.2016
Public Sub AutoExit()
10      If gboolNormalDotSaved = True Then
          'MsgBox "AUTOEXEC: NormalDotSaved = AN"
20        Application.NormalTemplate.Saved = True
30      End If
End Sub
Attribute VB_Name = "DotCommonlErrorHanlder"
Option Explicit


'' bei Fehlern immer eine MsgBox anzeigen und in die Code-Zeile des Fehlers springen
Private mboolInDevelopmentModus As Boolean

' ######## Definitionen der Exit-Codes f|fffd|r Office2.exe ########
Public Const glongEXIT_CODE_TC_OITEMPLATE_DOT_ERROR As Long = 400
' Public Const glongEXIT_CODE_TC_OITEMPLATE_DOT_UNKNOWN_ERROR As Long = 401
Public Const glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS As Long = 200

' ######## Definitionen der Custom-Fehler ########
' der Start der Fehlernummernraum f|fffd|r die TC_OITEMPLATE.DOT
Public Const glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT As Long = vbObjectError + 50000

' die TC_OITEMPLATE.DOT kann keine Protokolldatei finden
Public Const glongCUSTOM_ERR_LOGFILE_NOT_FOUND_FOR_DOT As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 1

' unerwartet ist f|fffd|r das IkolClientApp-Objekt kein Standard-Drucker definiert
Public Const glongCUSTOM_ERR_DEFAULT_PRINTER_NOT_DEFINED As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 2

' es existiert bereits eine WE-Datei mit derselben PID und SID
Public Const glongCUSTOM_ERR_WE_PID_ALREADY_FOUND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 3

' die DOT konnte die DOC nicht schlie|fffd|en
Public Const glongCUSTOM_ERR_CAN_NOT_CLOSE_DOC As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 4

' es wird versucht, eine bereits gesetzte Klassen-Objektvariable zu setzten
Public Const glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 5

' die umzubenennede WE-Datei wurde nicht gefunden
Public Const glongCUSTOM_ERR_EXPECTED_WE_FILE_NOT_FOUND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 6

' das Parsen der WE-Datei ergab Fehler
Public Const glongCUSTOM_ERR_WE_FILE_ERRONEOUS As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 7

' Fehler in der WE-Angaben zur eAkte
Public Const glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 8

' Fehler in der Arbeit von der eAKTE
Public Const glongCUSTOM_ERR_EAKTE As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 9

' Fehler beim Drucken
Public Const glongCUSTOM_ERR_PRINT As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 10

' Der zuletzt erstellte Serienbrief konnte nicht ermittelt werden
Public Const glongCUSTOM_ERR_TC_STAMP_NOT_FOUND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 11

' das Dokument konnte nicht ge|fffd|ffnet werden
Public Const glongCUSTOM_ERR_DOC_NOT_FOUND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 12

' es existiert bereits eine Datei mit dem Namen unter dem das Dokument gespeichert werden muss
Public Const glongCUSTOM_ERR_DOC_ALREADY_EXISTS As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 13

' konnte das Arbeitsverzeichnis f|fffd|r MS Word nicht |fffd|ndern
Public Const glongCUSTOM_ERR_CHANGE_DIR As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 14

' beim Ersetzen wurde der zu ersetztende String nicht gefunden
Public Const glongCUSTOM_ERR_SEARCH_STRING_NOT_FOUND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 15

' beim das Ribbon-Objekt konnte nicht gecached werden
Public Const glongCUSTOM_ERR_COULD_NOT_CACHE_IRIBBONUI As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 16

' beim Mischen wird keine Datenquelle zum Hauptdokument entdeckt --> Verbinden ist vorhin fehlgeschalgen
Public Const glongCUSTOM_ERR_DATASOURCE_NOT_FOUND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 17

' unbekannter Befehl ist in der WE-Datei definiert
Public Const glongCUSTOM_ERR_UNKNOWN_WECOMMAND As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 18

' fehlerhafte Parameter zu einem Befehl in der WE-Datei
Public Const glongCUSTOM_ERR_COMMAND_PARAMETER_ERROR As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 19

' das Inititalisieren der Druckertabelle ist fehlgeschlagen
Public Const glongCUSTOM_ERR_PRINTERTABLE_INITIALIZATION As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 20

' die von der WE-Datei |fffd|bergebene Version von XXDRUC entspricht nicht der Version der TC_OITEMPLATE.DOT
Public Const glongCUSTOM_ERR_INSUFFICIENT_VERSION As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 21

' die von der WE-Datei |fffd|bergebene Version von XXDRUC entspricht nicht der Version der TC_OITEMPLATE.DOT
Public Const glongCUSTOM_ERR_CANNOT_RETRIEVE_ACTIVE_SESSION As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 22

' Fehler bei der Ausf|fffd|hrung einer Button-Aktion
Public Const glongCUSTOM_ERR_BUTTON_ACTION As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 23

' es ist kein zweites Fenster f|fffd|r die Unterschrifteneingabe ge|fffd|ffnet
Public Const glongCUSTOM_ERR_NO_SECOND_SIGN_SCREEN As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 24

' es wird versucht die Buttons f|fffd|r das Unterschriftenmodul zu aktivieren, die Mindestvoraussetzung MS Word 2003 ist aber nicht erf|fffd|llt
Public Const glongCUSTOM_ERR_SIGN_WORD_VERSION As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 25

' die WE-Datei enth|fffd|lt keinen OEFFNE-Befehl
Public Const glongCUSTOM_ERR_NO_OPEN_COMMAND_APPLIED As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 26

' das Installationspaket f|fffd|r das Modul eAkte ist nicht installiert
Public Const glongCUSTOM_ERR_EAKTE_NOT_INSTALLED As Long = glongCUSTOM_ERR_ERRNUMBASE_TC_OITEMPLATE_DOT + 27


'---------------------------------------------------------------------------------------
' Prozedur : DotCentralErrorHandler
' Autor    : Todor Vachkov
' Datum    : 26.06.2013
' Zweck    : der zentrale ErrorHandler der TC_OITEMPLATE.DOT, wo jeder vorgekommenen Fehler behandelt wird
'            das Err-Objekt existiert nur einmal - davon wird Gebrauch gemacht; in der Funktion selbst sind keine
'            weiteren Funktionsaufrufe mehr zul|fffd|ssig, damit keine weiteren Fehler entstehen k|fffd|nnen;
'            jede Meldung wird auch in einer MsgBox angezeigt, sobald die Variable f|fffd|r den Entwiklungsmodus gesetzt ist:
'            anhand des Fehlers wird entschieden, ob die Ausf|fffd|hrung auch abgebrochen wird und zum Verfahren zur|fffd|ckgekehrt wird
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: keine
'
' |fffd|bergabeparams:
' String      : der Name des Moduls
' String      : der Name der Prozedur
' Opt Boolean : wenn True wird auch eine MsgBox erzwingt; Standardwert: False
' Opt String  : zus|fffd|tzliche Informationen neben dem Fehler werden vom Aufrufer |fffd|bergeben; Standardwert: vbNullString
'---------------------------------------------------------------------------------------

Public Function DotCentralErrorHandler(objCurrentIkolClientApp As TC_IkolClientApp, _
                                       ByVal strModule As String, _
                                       ByVal strProc As String, _
                                       Optional ByVal boolWITHMSGBOX As Boolean = False, _
                                       Optional ByVal strExtraInfo As String = vbNullString, _
                                       Optional ByVal boolErrorIsInAnWeInstruction As Boolean = False) As Boolean

    Dim longErrNumber As Long                         '' hier wird die Nummer des Fehlers gespeichert
    Dim strErrDescr As String                         '' hier wird die Beschreibung des Fehlers gespeichert
    Dim strErrSource As String                        '' die immer wieder erweiterte Quelle des Fehler auf seinem weg zum ErrorHandler
    Dim longErrorLine As Long                         '' die Code-Zeile im Aufrufer, wo der Fehler zustandegekommen ist
    Dim strLogText As String                          '' die Zeile, die in das Protokoll eingeht
    Dim boolCurrentScreenUpdating As Boolean          '' vor dem Anzeigen der MsgBox den aktuellen Status speichern
    Dim boolExecutionStop As Boolean                  '' aufgrund der Fehlernummer die Office-Schnittstelle stoppen oder weiterlaufen lassen
    Dim longCurrentExitCode As Long
    Dim boolIsItACustomError As Boolean               ' ist der Fehler einer, der mit Raise geworfen wurde, oder ist unbekannt  - meistens VBA Runtime-Error
    Dim strErrorLabelForOutput As String              ' dynamisch die Ausgabe anpassen je nach Error - custom oder VBA-Runtime

    ' Umschalten zwischen Entwicklungs- und Produktivmodus
5   mboolInDevelopmentModus = False

10  boolExecutionStop = False
15  boolIsItACustomError = True

    ' die Fehlernummer aus dem Err-Objekt speichern, denn dieses wird in der Prozedur zur|fffd|ckgesetzt
20  longErrNumber = Err.Number
25  strErrSource = Err.Source
30  strErrDescr = Err.Description
35  longErrorLine = Erl

    ' keine weiteren Fehler in der Funktion mehr zulassen
    ' ab hier werden die Eigenschaften vom Err-Objekt geleert
40  On Error Resume Next

    ' einen Standard Exit-Code f|fffd|r Abbruch mit schwerwiegenden Fehlern
    ' kann in der Select-Anweisung |fffd|berschrieben werden
45  longCurrentExitCode = glongEXIT_CODE_TC_OITEMPLATE_DOT_ERROR

50  Select Case (longErrNumber)
            'schwerwiegende Fehler, die zum Abbruch f|fffd|hren sollen
        Case glongCUSTOM_ERR_LOGFILE_NOT_FOUND_FOR_DOT, _
             glongCUSTOM_ERR_CAN_NOT_CLOSE_DOC, _
             glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, _
             glongCUSTOM_ERR_EXPECTED_WE_FILE_NOT_FOUND, _
             glongCUSTOM_ERR_WE_PID_ALREADY_FOUND, _
             glongCUSTOM_ERR_WE_FILE_ERRONEOUS, _
             glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG, _
             glongCUSTOM_ERR_EAKTE, _
             glongCUSTOM_ERR_PRINT, _
             glongCUSTOM_ERR_TC_STAMP_NOT_FOUND, _
             glongCUSTOM_ERR_DOC_NOT_FOUND, _
             glongCUSTOM_ERR_DOC_ALREADY_EXISTS, _
             glongCUSTOM_ERR_CHANGE_DIR, _
             glongCUSTOM_ERR_COULD_NOT_CACHE_IRIBBONUI, _
             glongCUSTOM_ERR_DATASOURCE_NOT_FOUND, _
             glongCUSTOM_ERR_UNKNOWN_WECOMMAND, _
             glongCUSTOM_ERR_COMMAND_PARAMETER_ERROR, _
             glongCUSTOM_ERR_INSUFFICIENT_VERSION, _
             glongCUSTOM_ERR_CANNOT_RETRIEVE_ACTIVE_SESSION, _
             glongCUSTOM_ERR_BUTTON_ACTION, _
             glongCUSTOM_ERR_NO_SECOND_SIGN_SCREEN, _
             glongCUSTOM_ERR_SIGN_WORD_VERSION, _
             glongCUSTOM_ERR_NO_OPEN_COMMAND_APPLIED, _
             glongCUSTOM_ERR_EAKTE_NOT_INSTALLED

55          boolExecutionStop = True

60          boolIsItACustomError = True

            ' nicht kritische Fehler -> die Office-Schnittstelle setzt ihre Arbeit fort
65      Case glongCUSTOM_ERR_SEARCH_STRING_NOT_FOUND
70          boolExecutionStop = False
75          boolIsItACustomError = True
80      Case Else
            ' unbekannte Fehler als schwerwiegende behandeln
85          boolIsItACustomError = False
90          longCurrentExitCode = glongEXIT_CODE_TC_OITEMPLATE_DOT_ERROR
95          boolExecutionStop = True
100 End Select

    ' ### BEGIN Protokollierung oder/und Ausgabe einer MsgBox ###

    ' war der Fehler ein Custom-Error (mit Raise geworfen)
105 If boolIsItACustomError Then
110     strErrorLabelForOutput = "TC-Fehler"
115     longErrNumber = longErrNumber - vbObjectError - 50000
120 Else
125     strErrorLabelForOutput = "VBA-Fehler"
130 End If

135 If longErrorLine = 0 Then
        ' Codezeilen wurden NICHT nummeriert
140     strLogText = strErrorLabelForOutput & " [" & CStr(longErrNumber) & "] ('" & strErrDescr & "') in '" & _
                     strModule & "::" & strProc & "'" & vbCrLf & vbCrLf & "Ursprung: " & vbCrLf & strErrSource
145 Else
        ' Codezeilen wurden nummeriert, diese in die Meldung mit|fffd|bernehmen
150     strLogText = strErrorLabelForOutput & " [" & CStr(longErrNumber) & "] ('" & strErrDescr & "') in '" & _
                     strModule & "::" & strProc & "' in Code-Zeile '" & CStr(longErrorLine) & "'" & vbCrLf & vbCrLf & "Ursprung: " & vbCrLf & strErrSource
155 End If

    ' pr|fffd|fen ob zus|fffd|tzliche Hinweise |fffd|bergeben wurden
160 If strExtraInfo <> vbNullString Then
165     strLogText = "Hinweis: " & strExtraInfo & vbCrLf & strLogText
170 End If

    ' hier ins Protokoll schreiben, insoweit der TextStream initialisiert worden ist
    ' If Not objCurrentIkolClientApp.LogfileHandler Is Nothing Then
175 If Not ((objCurrentIkolClientApp Is Nothing) And (objCurrentIkolClientApp.LogfileHandler.DotProtokollDateiTextStream Is Nothing)) Then
180     objCurrentIkolClientApp.LogfileHandler.DotProtokollDateiTextStream.WriteLine (GetFormattedTime() & " * DOT * :   " & strLogText)
185 End If


    ' zus|fffd|tzlich eine MsgBox anzeigen wenn
    ' 1. dies im Aufruf angeordnet wurde
    ' 2. ODER der Entwicklungsmodus AN ist
    ' 3. ODER es existiert kein objCurrentIkolClientApp.LogfileHandler.DotProtokollDateiTextStream-Objekt (also passiert der Fehler vor seiner Initialisierung)
    ' 4. die Ausf|fffd|hrung der Office-Schnittstelle wird unterbrochen
190 If boolWITHMSGBOX _
       Or mboolInDevelopmentModus _
       Or objCurrentIkolClientApp.LogfileHandler.DotProtokollDateiTextStream Is Nothing _
       Or boolExecutionStop Then

        ' den aktuellen Status merken
195     boolCurrentScreenUpdating = Application.ScreenUpdating

200     If Not boolCurrentScreenUpdating Then
205         Application.ScreenUpdating = True
210     End If

215     MsgBox strLogText, 64, "Office-Schnittstelle 2.0 (" & gstrOS2_VERSION & ") - TC_OITEMPLATE.DOT"
        ' zur|fffd|cksetzen auf den vorherigen Status
220     Application.ScreenUpdating = boolCurrentScreenUpdating
225 End If

    ' ### END Protokollierung oder/und Ausgabe einer MsgBox ###


230 If boolExecutionStop Then

235     If CBool(IsWindow(objCurrentIkolClientApp.WinHandleOffice2)) Then
240         If Not objCurrentIkolClientApp.LogfileHandler.DotProtokollDateiTextStream Is Nothing Then
245             Call objCurrentIkolClientApp.LogfileHandler.ProtokollMsg("DotCommonlErrorHanlder:DotCentralErrorHandler: POST_MESSAGE an WinHnd [" & objCurrentIkolClientApp.WinHandleOffice2 & "] mit EXIT-CODE [" & longCurrentExitCode & "]")
250         End If
255         PostMessage CLng(objCurrentIkolClientApp.WinHandleOffice2), CLng(glongWM_CLOSE), CLng(longCurrentExitCode), 0
260         DoEvents
265     End If

270     If (Not boolErrorIsInAnWeInstruction) Then
275         Call objCurrentIkolClientApp.SessionsContainer.GetActiveSession.CloseAllSessionDocuments
280         If Not objCurrentIkolClientApp.ClientSessionAlreadyClosed Then
285             Call objCurrentIkolClientApp.CloseSession(objCurrentIkolClientApp.SessionsContainer.GetActiveSession, False, "DotCommonlErrorHanlder:DotCentralErrorHandler")
290             If Not objCurrentIkolClientApp.LogfileHandler.DotProtokollDateiTextStream Is Nothing Then
295                 Call objCurrentIkolClientApp.LogfileHandler.CloseLogfileTextStream
300             End If
305         End If
310     End If
315 End If
    ' der Error-Handler gibt False zur|fffd|ck, wenn die Ausf|fffd|hrung stoppen muss
320 DotCentralErrorHandler = Not boolExecutionStop

End Function
Attribute VB_Name = "Focus"
Option Explicit

Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long
Private Declare Function AttachThreadInput Lib "user32" (ByVal idAttach As Long, ByVal idAttachTo As Long, ByVal fAttach As Long) As Long
Private Declare Function GetForegroundWindow Lib "user32" () As Long
Private Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function IsIconic Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long

Private Const SW_SHOW = 5
Private Const SW_RESTORE = 9

Public Function ForceForegroundWindow(ByVal hwnd As Long) As Boolean
         Dim ThreadID1 As Long
         Dim ThreadID2 As Long
         Dim nRet As Long
         
         ' Alles okay, schon im Vordergrund
         '29.07.2014 AL (2)
         'If rausgenommen, da sonst wieder Probleme mit Focus
         'liegt an der anderen |fffd|nderung vom 29.07.2014
10       'If hwnd = GetForegroundWindow() Then
20       '   ForceForegroundWindow = True
30       'Else
            '    ThreadID vom aktuellen Vordergrundfenster
            'und ThreadID vom Fenster, das in den Vordergrund soll
40          ThreadID1 = GetWindowThreadProcessId(GetForegroundWindow, ByVal 0&)
50          ThreadID2 = GetWindowThreadProcessId(hwnd, ByVal 0&)
            
            'input state
60          If ThreadID1 <> ThreadID2 Then
70             Call AttachThreadInput(ThreadID1, ThreadID2, True)
80             nRet = SetForegroundWindow(hwnd)
90             Call AttachThreadInput(ThreadID1, ThreadID2, False)
100         Else
110            nRet = SetForegroundWindow(hwnd)
120         End If
            
            'Restore und repaint
130         If IsIconic(hwnd) Then
140            Call ShowWindow(hwnd, SW_RESTORE)
150         Else
160            Call ShowWindow(hwnd, SW_SHOW)
170         End If
            
180         ForceForegroundWindow = CBool(nRet)
190      'End If
End Function
Attribute VB_Name = "GlobalAPIDeclarations"
'---------------------------------------------------------------------------------------
' Modul    : GlobalAPIDeclarations
' Autor    : Todor Vachkov
' Datum    : 29.07.2013
' Zweck    : hier sind die Funktionen, die im Projekt |fffd|ber AddressOf aufgerufen werden und daher nur als
'          : Prozeduren von normalen Modulen existieren k|fffd|nnen
'---------------------------------------------------------------------------------------

Option Explicit

' Deklaration der ben|fffd|tigten Windows-API-Funktionen f|fffd|r die Task- und Windowslist Ausgaben
'Public Declare Function EnumWindows Lib "user32.dll" ( _
 '                                     ByVal lpEnumFunc As Long, _
 '                                     ByVal lParam As Long) As Long

' Konstanten
Private Const VER_PLATFORM_WIN32s As Long = 0&
Private Const VER_PLATFORM_WIN32_WINDOWS As Long = 1&
Private Const VER_PLATFORM_WIN32_NT As Long = 2&
Private Const VER_SUITE_PERSONAL As Long = &H200&

Private Const ERROR_NO_MORE_ITEMS = 259&
Private Const MAX_COMPUTERNAME_LENGTH = 15
Private Const WS_VERSION_REQD As Long = &H101&
Private Const MIN_SOCKETS_REQD As Long = 1&
Private Const SOCKET_ERROR As Long = -1&
Private Const WSADescription_Len As Long = 256&
Private Const WSASYS_Status_Len As Long = 128&
'' FormatMessage Konstanten
Private Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Private Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Private Const LANG_NEUTRAL = &H0
Private Const SUBLANG_DEFAULT = &H1

Private Const ERROR_SUCCESS = 0&
Private Const HKEY_CLASSES_ROOT = &H80000000
Private Const HKEY_CURRENT_USER = &H80000001
Private Const HKEY_LOCAL_MACHINE = &H80000002
Private Const HKEY_USERS = &H80000003
Private Const HKEY_PERFORMANCE_DATA = &H80000004
Private Const HKEY_CURRENT_CONFIG = &H80000005
Private Const HKEY_DYN_DATA = &H80000006

' RegCreateKeyEx samDesired - Konstanten
Private Const KEY_ALL_ACCESS = &HF003F                'Alle Arten von Zurgiffen
Private Const KEY_CREATE_LINK = &H20                  'Erlaubnis zum symbolischen Erstellen von Links
Private Const KEY_CREATE_SUB_KEY = &H4                'Erlaubnis zum Erstellen von Unterschl|fffd|sseln
Private Const KEY_ENUMERATE_SUB_KEYS = &H8            'Erlaubnis zum Enumerieren der Unterschl|fffd|ssel
Private Const KEY_NOTIFY = &H10                       'Erlaubnis |fffd|ber |fffd|nderungen benachrichtigt zu werden
Private Const KEY_QUERY_VALUE = &H1                   'Erlaubnis zum Auslesen von Unterschl|fffd|ssel Daten
Private Const KEY_READ = &H20019                      'Lesezugriff
Private Const KEY_SET_VALUE = &H2                     'Erlaubnis zum Schreiben von Werten in Unterschl|fffd|sseln
Private Const KEY_WRITE = &H20006                     'Schreibzugriff


'RegSetValueEx dwType-Konstanten
Private Const REG_BINARY = 3                          'Eine Bytefolge
Private Const REG_DWORD = 4                           'Ein 32-Bit Integer wert (Little Endian)
Private Const REG_DWORD_BIG_ENDIAN = 5                'Ein 32-Bit Integer (Big Endian)
Private Const REG_EXPAND_SZ = 2                       'Ein VBNullChar Terminierter String, der Umgebungsvariablen enth|fffd|lt
Private Const REG_LINK = 6                            'Ein Unicode symbolischer Link
Private Const REG_MULTI_SZ = 7                        'Eine Serie von Strings, jedes getrennt mit einem VBNullChar-Zeichen _
                                                      und das ende mit 2 VBNullChar-Zeichen
Private Const REG_NONE = 0                            'Keine Daten
Private Const REG_RESOURCE_LIST = 8                   'Eine Liste von Ressourcen in einer Ressourcen Map
Private Const REG_SZ = 1                              'Ein VBNullChar-Zeichen Terminierter String


' Einige FormatMessage Sprachkonstanten
Private Const LANG_GERMAN = &H7

' Einige FormatMessage Sub-Sprachkonstanten
Private Const SUBLANG_GERMAN = &H1

'Public Const SWP_NOMOVE = 2
'Public Const SWP_NOSIZE = 1


Public Const SWP_NOSIZE As Long = &H1
Public Const SWP_NOMOVE As Long = &H2
Public Const SWP_NOZORDER As Long = &H4
Public Const SWP_NOREDRAW As Long = &H8
Public Const SWP_NOACTIVATE As Long = &H10
Public Const SWP_FRAMECHANGED As Long = &H20
Public Const SWP_SHOWWINDOW As Long = &H40
Public Const SWP_HIDEWINDOW As Long = &H80
Public Const SWP_NOCOPYBITS As Long = &H100
Public Const SWP_NOOWNERZORDER As Long = &H200
Public Const SWP_NOSENDCHANGING As Long = &H400
Public Const SWP_DEFERERASE As Long = &H2000
Public Const SWP_ASYNCWINDOWPOS As Long = &H4000

Public Const flags = SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOSENDCHANGING

Public Const HWND_TOP = 0                             ' Places the window at the top of the Z order.
Public Const HWND_TOPMOST = -1                        ' Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.

' ========================================================================================
' Deklaration der ben|fffd|tigten globalen Variablen und Typen f|fffd|r die Task- und Windowslist Ausgaben

'22.07.2014 AL
Public Const SW_HIDE = 0
Public Const SW_RESTORE = 9
Public Const SW_MINIMIZE = 6
Public Const SW_SHOWNA = 8
'ENDE 22.07.2014 AL

Private Type tWindowsShortMeta
    WndText As String
    WndHwnd As Long
    WndPID As Long
    WndCreator As Long
End Type

Public WindowsListForID() As tWindowsShortMeta

Public Type CmdBarCntrl
    visible As Boolean
    enabled As Boolean
    cntrlID As String
    action As String
    toolTip As String
End Type

Public Type CommandControls
    controls(15) As CmdBarCntrl
End Type

Public Type SignatureNames
    realName As String
    showedName As String
    tc_sign As TC_Signature
End Type

Private Type WinSocketDataType
    wversion As Integer
    wHighVersion As Integer
    szDescription(0 To WSADescription_Len) As Byte
    szSystemStatus(0 To WSASYS_Status_Len) As Byte
    iMaxSockets As Integer
    iMaxUdpDg As Integer
    lpszVendorInfo As Long
End Type

Private Type MEMORYSTATUS
    dwLength As Long
    dwMemoryLoad As Long
    dwTotalPhys As Long
    dwAvailPhys As Long
    dwTotalPageFile As Long
    dwAvailPageFile As Long
    dwTotalVirtual As Long
    dwAvailVirtual As Long
End Type

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
End Type

Private Type OSVERSIONINFOEX
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
    wServicePackMajor As Integer
    wServicePackMinor As Integer
    wSuiteMask As Integer
    wProductType As Byte
    wReserved As Byte
End Type

Private Type SECURITY_ATTRIBUTES
    nLength As Long
    lpSecurityDescriptor As Long
    bInheritHandle As Long
End Type

Private Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay  As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type

Private Type tWindowsLongMeta
    WndText As String
    WndClass As String
    WndHwdn As Long
    visible As Boolean
    maxim As Boolean
    minim As Boolean
End Type

Public Enum PrinterSearchState
    ssNoPrinter
    ssOnePrinter
    ssMorePrinter
End Enum

Public Type ControlParameter
    identifier As String
    controlValue As TC_ParameterDescription
End Type

Public Type PRINTER_DEFAULTS
    pDatatype As Long
    pDevmode As Long
    DesiredAccess As Long
End Type

Public Type PRINTER_INFO_2
    pServerName As Long
    pPrinterName As Long
    pShareName As Long
    pPortName As Long
    pDriverName As Long
    pComment As Long
    pLocation As Long
    pDevmode As Long                                  ' Pointer to DEVMODE
    pSepFile As Long
    pPrintProcessor As Long
    pDatatype As Long
    pParameters As Long
    pSecurityDescriptor As Long                       ' Pointer to SECURITY_DESCRIPTOR
    Attributes As Long
    Priority As Long
    DefaultPriority As Long
    startTime As Long
    UntilTime As Long
    Status As Long
    cJobs As Long
    AveragePPM As Long
End Type

Public Type DEVMODE
    dmDeviceName As String * 32
    dmSpecVersion As Integer
    dmDriverVersion As Integer
    dmSize As Integer
    dmDriverExtra As Integer
    dmFields As Long
    dmOrientation As Integer
    dmPaperSize As Integer
    dmPaperLength As Integer
    dmPaperWidth As Integer
    dmScale As Integer
    dmCopies As Integer
    dmDefaultSource As Integer
    dmPrintQuality As Integer
    dmColor As Integer
    dmDuplex As Integer
    dmYResolution As Integer
    dmTTOption As Integer
    dmCollate As Integer
    dmFormName As String * 32
    dmUnusedPadding As Integer
    dmBitsPerPel As Integer
    dmPelsWidth As Long
    dmPelsHeight As Long
    dmDisplayFlags As Long
    dmDisplayFrequency As Long
    dmICMMethod As Long
    dmICMIntent As Long
    dmMediaType As Long
    dmDitherType As Long
    dmReserved1 As Long
    dmReserved2 As Long
End Type

Public WindowsListForProtokoll(1000) As tWindowsLongMeta

Private wndCnt As Integer
Private MaxWndTextLen As Long
Private MaxWndClassLen As Long

Private Const FORMAT_MESSAGE_MAX_WIDTH_MASK As Long = &HFF
Private Const LANG_USER_DEFAULT As Long = &H400&

Public Const TC_OS2_Section = "Software\Telecomputer\OS2.0\"
Public Const REG_SignatureSection = "Unterschrift"
Public Const wndKeyLeft = "Left"
Public Const wndKeyTop = "Top"
Public Const wndKeyHeight = "Height"
Public Const wndKeyState = "State"
Public Const wndKeyWidth = "Width"
Public Const wndKeyZoom = "ZoomFactor"
Public Const wndKeyZoomFactor = "ZoomPercent"
'07.10.2014 AL - auch Position des Hauptfensters speichern (wegen Windows 8.1)
Public Const wndKeyLeft_H = "H_Left"
Public Const wndKeyTop_H = "H_Top"
Public Const wndKeyHeight_H = "H_Height"
Public Const wndKeyState_H = "H_State"
Public Const wndKeyWidth_H = "H_Width"
Public Const wndKeyZoom_H = "H_ZoomFactor"
Public Const wndKeyZoomFactor_H = "H_ZoomPercent"
'ENDE 07.10.2014 AL - auch Position des Hauptfensters speichern (wegen Windows 8.1)

' DEVMODE dmFields-Konstanten
Public Const DM_ORIENTATION = &H1                     ' dmOrientation wird gef|fffd|llt / gelesen
Public Const DM_PAPERSIZE = &H2                       ' dmPaperSize wird gef|fffd|llt / gelesen
Public Const DM_PAPERLENGTH = &H4                     ' dmPaperLenght wird gef|fffd|llt / gelesen
Public Const DM_PAPERWIDTH = &H8                      ' dmPaperWidth wird gef|fffd|llt / gelesen
Public Const DM_SCALE = &H10                          ' dmScale wird gef|fffd|llt / gelesen
Public Const DM_COPIES = &H100                        ' dmCopies wird gef|fffd|llt / gelesen
Public Const DM_DEFAULTSOURCE = &H200                 ' dmDefaultSource wird gef|fffd|llt / gelesen
Public Const DM_PRINTQUALITY = &H400                  ' dmPrintQuality wird gef|fffd|llt / gelesen
Public Const DM_COLOR = &H800                         ' dmColor wird gef|fffd|llt / gelesen
Public Const DM_DUPLEX = &H1000                       ' dmDuplex wird gef|fffd|llt / gelesen
Public Const DM_YRESOLUTION = &H2000                  ' dmYResolution wird gef|fffd|llt / gelesen
Public Const DM_TTOPTION = &H4000                     ' dmTTOption wird gef|fffd|llt / gelesen
Public Const DM_COLLATE = &H8000                      ' dmCollate wird gef|fffd|llt / gelesen
Public Const DM_FORMNAME = &H10000                    ' dmFormName wird gef|fffd|llt / gelesen
Public Const DM_LOGPIXELS = &H20000                   ' dmLogPixels wird gef|fffd|llt / gelesen
Public Const DM_BITSPERPEL = &H40000                  ' dmBitsPerPixel wird gef|fffd|llt / gelesen
Public Const DM_PELSWIDTH = &H80000                   ' dmPelsWidth wird gef|fffd|llt / gelesen
Public Const DM_PELSHEIGHT = &H100000                 ' dmPelsHeight wird gef|fffd|llt / gelesen
Public Const DM_DISPLAYFLAGS = &H200000               ' dmDisplayFlags wird gef|fffd|llt / gelesen
Public Const DM_DISPLAYFREQUENCY = &H400000           ' dmDisplayFrequency wird gef|fffd|llt / gelesen
Public Const DM_ICMMETHOD = &H800000                  ' dmICMMethod wird gef|fffd|llt / gelesen
Public Const DM_ICMINTENT = &H1000000                 ' dmICMIntent wird gef|fffd|llt / gelesen
Public Const DM_MEDIATYPE = &H2000000                 ' dmMediaType wird gef|fffd|llt / gelesen
Public Const DM_DITHERTYPE = &H4000000                ' dmDitherType wird gef|fffd|llt / gelesen
Public Const DM_PANNINGWIDTH = &H20000000             ' dmPanningWidth wird gef|fffd|llt / gelesen
Public Const DM_PANNINGHEIGHT = &H40000000            ' dmPanningHeight wird gef|fffd|llt / gelesen

Public Const PRINTER_ENUM_CONNECTIONS = &H4
Public Const PRINTER_ENUM_LOCAL = &H2

' DEVMODE dmOrientation-Konstanten
Public Const DMORIENT_PORTRAIT = 1                    ' Portrait wurde gew|fffd|hlt (vertikal drucken)
Public Const DMORIENT_LANDSCAPE = 2                   ' Landscape wurde gew|fffd|hlt (horizontal drucken)

' DEVMODE dmPaperSize-Konstanten
Public Const DMPAPER_LETTER = 1                       ' Blatt 8,5 x 11 Inch
Public Const DMPAPER_LEGAL = 5                        ' Blatt 8,5 x 14 Inch
Public Const DMPAPER_10X11 = 45                       ' 10 x 11 Inch
Public Const DMPAPER_10X14 = 16                       ' 10 x 14 Inch
Public Const DMPAPER_11X17 = 17                       ' 11 x 17 Inch
Public Const DMPAPER_15X11 = 46                       ' 15 x 11 Inch
Public Const DMPAPER_9X11 = 44                        ' 9 x 11 Inch
Public Const DMPAPER_A_PLUS = 57                      ' A Plus Blatt
Public Const DMPAPER_A2 = 66                          ' DIN A2 Blatt
Public Const DMPAPER_A3 = 8                           ' DIN A3 Blatt
Public Const DMPAPER_A3_EXTRA = 63                    ' DIN A3 Extra Blatt
Public Const DMPAPER_A3_EXTRA_TRANSVERSE = 68         ' DIN A3 Extra Blatt querlaufend
Public Const DMPAPER_A3_TRANSVERSE = 67               ' DIN A3 Blatt querlaufend
Public Const DMPAPER_A4 = 9                           ' DIN A4 Blatt
Public Const DMPAPER_A4_EXTRA = 53                    ' DIN A4 Extra Blatt
Public Const DMPAPER_A4_PLUS = 60                     ' DIN A4 Plus Blatt
Public Const DMPAPER_A4_TRANSVERSE = 55               ' DIN A4 Querlaufend
Public Const DMPAPER_A4SMALL = 10                     ' DIN A4 klein (210 x 297 Millimeter) Blatt
Public Const DMPAPER_A5 = 11                          ' DIN A5 Blatt
Public Const DMPAPER_A5_EXTRA = 64                    ' DIN A5 Extra Blatt
Public Const DMPAPER_A5_TRANSVERSE = 61               ' DIN A5 querlaufend
Public Const DMPAPER_B_PLUS = 58                      ' B Plus Blatt
Public Const DMPAPER_B4 = 12                          ' B4 Blatt
Public Const DMPAPER_B5 = 13                          ' B5 Blatt
Public Const DMPAPER_B5_EXTRA = 65                    ' B5 Extra Blatt
Public Const DMPAPER_B5_TRANSVERSE = 62               ' B5 Blatt querlaufend
Public Const DMPAPER_CSHEET = 24                      ' C Blatt (17 x 22 Inch)
Public Const DMPAPER_DSHEET = 25                      ' D Blatt (22x34 Inch)
Public Const DMPAPER_ENV_10 = 20                      ' Briefumschlag 10 (4,125 x 9,5 Inch)
Public Const DMPAPER_ENV_11 = 21                      ' Briefumschlag 11 (4,5 x 10,375 Inch)
Public Const DMPAPER_ENV_12 = 22                      ' Briefumschlag 12 (4,75 x 11 Inch)
Public Const DMPAPER_ENV_14 = 23                      ' Briefumschlag 14 (5 x 11,5 Inch)
Public Const DMPAPER_ENV_9 = 19                       ' Briefumschlag 9 (3,875 x 8,875 Inch)
Public Const DMPAPER_ENV_B4 = 33                      ' Briefumschlag B4 (250 x 353 Millimeter)
Public Const DMPAPER_ENV_B5 = 34                      ' Briefumschlag B5 (176 x 250 Millimeter)
Public Const DMPAPER_ENV_B6 = 35                      ' Briefumschlag B6 (176 x 125 Millimeter)
Public Const DMPAPER_ENV_C3 = 29                      ' Briefumschlag C3 (324 x 458 Millimeter)
Public Const DMPAPER_ENV_C4 = 30                      ' Briefumschlag C4 (229 x 324 Millimeter)
Public Const DMPAPER_ENV_C5 = 28                      ' Briefumschlag C5 (162 x 229 Millimeter)
Public Const DMPAPER_ENV_C6 = 31                      ' Briefumschlag C6 (114 x 162 Millimeter)
Public Const DMPAPER_ENV_C65 = 32                     ' Briefumschlag 10 (4,125 x 9,5 Inch)
Public Const DMPAPER_ENV_DL = 27                      ' Briefumschlag 10 (4,125 x 9,5 Inch)
Public Const DMPAPER_ENV_INVITE = 47                  ' Einladungs-Briefumschlag
Public Const DMPAPER_ENV_ITALY = 36                   ' Italienischer Briefumschlag (110 x 230 Millimeter)
Public Const DMPAPER_ENV_MONARCH = 37                 ' Monarchischer Briefumschlag (3,875  x 7,5 Inch)
Public Const DMPAPER_ENV_PERSONAL = 38                ' Pers|fffd|nlicher Briefumschlag (3,625  x 6,5 Inch)
Public Const DMPAPER_ESHEET = 26                      ' E Blatt (34 x 44 Inch)
Public Const DMPAPER_EXECUTIVE = 7                    ' Executive Blatt (7.25 x 10,5 Inch)
Public Const DMPAPER_FANFOLD_LGL_GERMAN = 41          ' Deutscher rechtlicher Fanfold (8,5 x 13 Inch)
Public Const DMPAPER_FANFOLD_STD_GERMAN = 40          ' Deutscher Standard Fanfold (8,5 x 12 Inch)
Public Const DMPAPER_FANFOLD_US = 39                  ' US Standard Fanfold (14,875 + 11 Inch)
Public Const DMPAPER_FIRST = 1                        ' Blatt 8,5 x 11 Inch
Public Const DMPAPER_FOLIO = 14                       ' Folie 8,5 + 13 Inch
Public Const DMPAPER_ISO_B4 = 42                      ' ISO B4 Blatt
Public Const DMPAPER_JAPANESE_POSTCARD = 43           ' Japanische Postkarte
Public Const DMPAPER_LAST = 41                        ' Deutscher rechtlicher Fanfold (8,5 x 13 Inch)
Public Const DMPAPER_LEDGER = 4                       ' Ledger (17x11 Inch)
Public Const DMPAPER_LEGAL_EXTRA = 51                 ' Rechtlich Extra
Public Const DMPAPER_LETTER_EXTRA = 50                ' Blatt Extra
Public Const DMPAPER_LETTER_EXTRA_TRANSVERSE = 56     ' Blatt Extra Querlaufend
Public Const DMPAPER_LETTER_PLUS = 59                 ' Blatt Plus
Public Const DMPAPER_LETTER_TRANSVERSE = 54           ' Blatt querlaufend
Public Const DMPAPER_LETTERSMALL = 2                  ' Blatt klein (8,5 x 11 Inch)
Public Const DMPAPER_NOTE = 18                        ' Note Blatt (8,5 x 11 Inch)
Public Const DMPAPER_QUARTO = 15                      ' Quarto Blatt (215 x 275 Millimeter)
Public Const DMPAPER_STATEMENT = 6                    ' Statement Blatt (5,5 x 8,5 Inch)
Public Const DMPAPER_TABLOID = 3                      ' Tabloid Blatt (11 x 17 Inch)
Public Const DMPAPER_TABLOID_EXTRA = 52               ' Tabloid Extra Blatt
Public Const DMPAPER_USER = 256                       ' Benutzerdefinierte Gr|fffd||fffd|e

' DEVMODE dmDefaultSource-Konstanten
Public Const DMBIN_ONLYONE = 1                        ' Nur ein Blatt
Public Const DMBIN_UPPER = 1                          ' Beh|fffd|lter oben
Public Const DMBIN_LOWER = 2                          ' Beh|fffd|lter unten
Public Const DMBIN_MIDDLE = 3                         ' Beh|fffd|lter Mitte
Public Const DMBIN_MANUAL = 4                         ' Beh|fffd|lter mit manueller F|fffd|llung
Public Const DMBIN_ENVELOPE = 5                       ' Briefumschlag-Beh|fffd|lter
Public Const DMBIN_ENVMANUAL = 6                      ' Briefumschlag-Beh|fffd|lter mit manueller F|fffd|llung
Public Const DMBIN_AUTO = 7                           ' Automatisches f|fffd|llen
Public Const DMBIN_TRACTOR = 8                        ' Blatt Einzug
Public Const DMBIN_SMALLFMT = 9                       ' Kleines Format laden
Public Const DMBIN_LARGEFMT = 10                      ' Gro|fffd|es Format laden
Public Const DMBIN_LARGECAPACITY = 11                 ' Gro|fffd|e Kapazit|fffd|t
Public Const DMBIN_CASSETTE = 14                      ' Blatt Kassette
Public Const DMBIN_FORMSOURCE = 15                    ' Form Papier Quelle

' DEVMODE dmPrintQuality-Konstanten
Public Const DMRES_DRAFT = -1                         ' Entwurf
Public Const DMRES_LOW = -2                           ' Niedrig
Public Const DMRES_MEDIUM = -3                        ' Mittel
Public Const DMRES_HIGH = -4                          ' Hoch

' DEVMODE dmColor-Konstanten
Public Const DMCOLOR_MONOCHROME = 1                   ' Ger|fffd|t unterst|fffd|tzt keine Schwarzweiss-Ausgabe
Public Const DMCOLOR_COLOR = 2                        ' Ger|fffd|t unterst|fffd|tzt keine Farb-Ausgabe

' DEVMODE dmDuplex-Konstanten
Public Const DMDUP_SIMPLEX = 1                        ' Einseitiges drucken
Public Const DMDUP_VERTICAL = 2                       ' Beidseitig drucken bei vertikalem Seitenwechsel
Public Const DMDUP_HORIZONTAL = 3                     ' Beidseitig drucken bei horizontalem Seitenwechsel

' DEVMODE dmTTOption-Konstanten
Public Const DMTT_BITMAP = 1                          ' Druckt TrueType Fonts als Grafiken
Public Const DMTT_DOWNLOAD = 2                        ' Druckt Downloaded TrueType Fonts als Soft Fonts
Public Const DMTT_SUBDEV = 4                          ' Druckt Ger|fffd|te Fonts statt TrueType Fonts

' DEVMODE dmCollate-Konstanten
Public Const DMCOLLATE_FALSE = 0                      ' Drucker kann keine Seiten sortieren
Public Const DMCOLLATE_TRUE = 1                       ' Drucker kann Seiten sortieren

' DEVMODE dmDisplayFlags-Konstanten
Public Const DM_GRAYSCALE = 1                         ' Ger|fffd|t unterst|fffd|tzt keine Farben, Graut|fffd|ne werden unterst|fffd|tzt
Public Const DM_INTERLACED = 2                        ' Ger|fffd|t unterst|fffd|tzt Farben

' DEVMODE dmICMMethod-Konstanten
Public Const DMICMMETHOD_NONE = 1                     ' ICM ist abgeschaltet
Public Const DMICMMETHOD_SYSTEM = 2                   ' ICM wird von Windows gesteuert
Public Const DMICMMETHOD_DRIVER = 3                   ' ICM wird vom Treiber gesteuert
Public Const DMICMMETHOD_DEVICE = 4                   ' ICM wird vom Ger|fffd|t gesteuert

' DEVMODE dmICMIntent-Konstanten
Public Const DMICM_SATURATE = 1                       ' S|fffd|ttigung wird optimiert
Public Const DMICM_CONTRAST = 2                       ' Kontrast wird optimiert
Public Const DMICM_COLORMETRIC = 3                    ' Exakte Farben

' DEVMODE dmMediaType-Konstanten
Public Const DMMEDIA_STANDARD = 1                     ' Standard Papier
Public Const DMMEDIA_GLOSSY = 2                       ' Foto Papier
Public Const DMMEDIA_TRANSPARECNY = 3                 ' Folie

' DEVMODE dmDitherType-Konstanten
Public Const DMDITHER_NONE = 1                        ' Kein Dithering
Public Const DMDITHER_COARSE = 2                      ' Dithering mit groben Brush
Public Const DMDITHER_FINE = 3                        ' Dithering mit feinen Brush
Public Const DMDITHER_LINEART = 4                     ' Linien mit Schwarz, Wei|fffd| und Grau
Public Const DMDITHER_GRAYSCALE = 5                   ' Grauskala

Public Const DM_OUT_BUFFER = 2
Public Const DM_IN_BUFFER = 8

Public Const PRINTER_ACCESS_USE = &H8
Public Const STANDARD_RIGHTS_REQUIRED = &HF0000
Public Const PRINTER_NORMAL_ACCESS = (STANDARD_RIGHTS_REQUIRED Or _
                                      PRINTER_ACCESS_USE)


Public Declare Function SetTimer Lib "user32.dll" _
                                 (ByVal hwnd As Long, _
                                  ByVal nIDEvent As Long, _
                                  ByVal uElapse As Long, _
                                  ByVal lpTimerFunc As Long) As Long

Public Declare Function KillTimer Lib "user32.dll" _
                                  (ByVal hwnd As Long, _
                                   ByVal nIDEvent As Long) As Long

Public Declare Function GetEnvironmentVariable Lib "kernel32.dll" _
                                               Alias "GetEnvironmentVariableA" ( _
                                               ByVal lpName As String, _
                                               ByVal lpBuffer As String, _
                                               ByVal nSize As Long) As Long

Public Declare Function SetEnvironmentVariable Lib "kernel32.dll" _
                                               Alias "SetEnvironmentVariableA" ( _
                                               ByVal lpName As String, _
                                               ByVal lpValue As String) As Long


' ===========================================
' ben|fffd|tigt f|fffd|r Office2.exe und worddrv.exe

'18.07.2014 AL
'um Word zu beenden - beendet eigene Instanz.
Public Declare Sub ExitProcess Lib "kernel32" (ByVal uExitCode As Long)
'ENDE 18.07.2014 AL

Public Declare Function PostMessage Lib "user32.dll" _
                                    Alias "PostMessageA" ( _
                                    ByVal hwnd As Long, _
                                    ByVal msg As Long, _
                                    ByVal p1 As Long, _
                                    ByVal p2 As Long) As Long

Public Const glongWM_CLOSE As Long = &H10

Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Public Declare Function GetWindowTextLength Lib "user32.dll" _
                                            Alias "GetWindowTextLengthA" ( _
                                            ByVal hwnd As Long) As Long

Public Declare Function GetClassName Lib "user32.dll" _
                                     Alias "GetClassNameA" ( _
                                     ByVal hwnd As Long, _
                                     ByVal lpClassName As String, _
                                     ByVal nMaxCount As Long) As Long


Public Declare Function IsIconic Lib "user32.dll" ( _
                                 ByVal hwnd As Long) As Long

Public Declare Function IsZoomed Lib "user32.dll" ( _
                                 ByVal hwnd As Long) As Long

' Deklaration der ben|fffd|tigten Windows-API-Funktionen f|fffd|r die Fokus-Steuerung

Public Declare Function SetWindowPos Lib "user32.dll" _
                                     (ByVal hwnd As Long, _
                                      ByVal hWndInsertAfter As Long, _
                                      ByVal x As Long, _
                                      ByVal y As Long, _
                                      ByVal cx As Long, _
                                      ByVal cy As Long, _
                                      ByVal wFlags As Long) As Long


Public Declare Function GetParent Lib "user32.dll" ( _
                                  ByVal hwnd As Long) As Long

Public Declare Function GetActiveWindow Lib "user32.dll" () As Long

Public Declare Sub GetLocalTime Lib "kernel32.dll" (lpSystemTime As SYSTEMTIME)

Public Declare Function BringWindowToTop Lib "user32.dll" (ByVal lngHWnd As Long) As Long

Public Declare Function FormatMessage Lib "kernel32.dll" _
                                      Alias "FormatMessageA" _
                                      (ByVal dwFlags As Long, _
                                       ByRef lpSource As Any, _
                                       ByVal dwMessageId As Long, _
                                       ByVal dwLanguageId As Long, _
                                       ByVal lpBuffer As String, _
                                       ByVal nSize As Long, _
                                       ByRef Arguments As Long) As Long

'den handle vom Desktop-Window ermitteln
Public Declare Function GetDesktopWindow Lib "user32.dll" () As Long

'die Prozess-ID von dieser Word-Instanz ermitteln
Public Declare Function GetCurrentProcessId Lib "kernel32.dll" () As Long

' Deklaration der ben|fffd|tigten Windows-API-Funktionen f|fffd|r die Task- und Windowslist Ausgaben
Public Declare Function EnumWindows Lib "user32.dll" ( _
                                    ByVal lpEnumFunc As Long, _
                                    ByVal lParam As Long) As Long


' Deklaration der ben|fffd|tigten Windows-API-Funktionen f|fffd|r die Fokus-Steuerung
Public Declare Function GetWindowThreadProcessId Lib "user32.dll" ( _
                                                 ByVal hwnd As Long, _
                                                 lpdwProcessId As Long) As Long

Public Declare Function GetWindow Lib "user32.dll" ( _
                                  ByVal hwnd As Long, _
                                  ByVal wCmd As Long) As Long

Public Declare Function IsWindowVisible Lib "user32.dll" ( _
                                        ByVal hwnd As Long) As Long

Public Declare Function IsWindow Lib "user32.dll" ( _
                                 ByVal hwnd As Long) As Long

Public Declare Function GetWindowText Lib "user32.dll" _
                                      Alias "GetWindowTextA" ( _
                                      ByVal hwnd As Long, _
                                      ByVal lpString As String, _
                                      ByVal cch As Long) As Long

Public Declare Function GetLastError Lib "kernel32.dll" () As Long


Public Declare Function GetVersionEx1 Lib "kernel32.dll" Alias "GetVersionExA" _
                                      (ByRef lpVersionInformation As OSVERSIONINFO) _
                                      As Long

Public Declare Function GetVersionEx2 Lib "kernel32.dll" Alias "GetVersionExA" _
                                      (ByRef lpVersionInformation As OSVERSIONINFOEX) _
                                      As Long

Public Declare Function GetComputerName Lib "kernel32.dll" Alias "GetComputerNameA" _
                                        (ByVal lpBuffer As String, _
                                         nSize As Long) _
                                         As Long

Public Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
                                    (ByVal lpBuffer As String, _
                                     nSize As Long) _
                                     As Long

Public Declare Function RegCloseKey Lib "advapi32.dll" _
                                    (ByVal hKey As Long) _
                                    As Long

Public Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" _
                                   (ByVal hKey As Long, _
                                    ByVal lpSubKey As String, _
                                    phkResult As Long) _
                                    As Long

Public Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" _
                                     (ByVal hKey As Long, _
                                      ByVal dwIndex As Long, _
                                      ByVal lpName As String, _
                                      lpcbName As Long, _
                                      ByVal lpReserved As Long, _
                                      ByVal lpClass As String, _
                                      lpcbClass As Long, _
                                      lpftLastWriteTime As Any) _
                                      As Long

Public Declare Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" _
                                     (ByVal hKey As Long, _
                                      ByVal dwIndex As Long, _
                                      ByVal lpValueName As String, _
                                      lpcbValueName As Long, _
                                      ByVal lpReserved As Long, _
                                      lpType As Long, _
                                      lpData As Any, _
                                      lpcbData As Long) _
                                      As Long

Public Declare Sub GlobalMemoryStatus Lib "kernel32.dll" _
                                      (lpBuffer As MEMORYSTATUS)

Public Declare Function gethostname Lib "WSOCK32.DLL" _
                                    (ByVal HostName As String, _
                                     ByVal HostLen As Integer) _
                                     As Long

Public Declare Function gethostbyname Lib "WSOCK32.DLL" _
                                      (ByVal HostName As String) _
                                      As Long

Public Declare Function gethostbyaddr Lib "WSOCK32.DLL" _
                                      (ByVal addr As String, _
                                       ByVal laenge As Integer, _
                                       ByVal typ As Integer) _
                                       As Long

Public Declare Function WSAGetLastError Lib "WSOCK32.DLL" () _
                                        As Long

Public Declare Function WSAStartup Lib "WSOCK32.DLL" _
                                   (ByVal wVersionRequired As Long, _
                                    lpWSAData As WinSocketDataType) _
                                    As Long

Public Declare Function WSACleanup Lib "WSOCK32.DLL" () _
                                   As Long

Public Declare Sub RtlMoveMemory Lib "kernel32.dll" _
                                 (hpvDest As Any, _
                                  ByVal hpvSource As Long, _
                                  ByVal cbCopy As Long)

Public Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, _
                                                                               ByVal lpSubKey As String, _
                                                                               ByVal ulOptions As Long, _
                                                                               ByVal samDesired As Long, _
                                                                               phkResult As Long) As Long

Public Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, _
                                                                                   ByVal lpSubKey As String, _
                                                                                   ByVal Reserved As Long, _
                                                                                   ByVal lpClass As String, _
                                                                                   ByVal dwOptions As Long, _
                                                                                   ByVal samDesired As Long, _
                                                                                   lpSecurityAttributes As SECURITY_ATTRIBUTES, _
                                                                                   phkResult As Long, _
                                                                                   lpdwDisposition As Long) As Long

Public Declare Function RegSetValueEx_Str Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, _
                                                                                     ByVal lpValueName As String, _
                                                                                     ByVal Reserved As Long, _
                                                                                     ByVal dwType As Long, _
                                                                                     ByVal lpData As String, _
                                                                                     ByVal cbData As Long) As Long


Public Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, _
                                                                                     ByVal lpValueName As String, _
                                                                                     ByVal lpReserved As Long, _
                                                                                     lpType As Long, _
                                                                                     lpData As Any, _
                                                                                     lpcbData As Any) As Long


Public Declare Function GetTempPath Lib "kernel32.dll" Alias "GetTempPathA" _
                                    (ByVal nBufferLength As Long, _
                                     ByVal lpBuffer As String) As Long


Public Declare Function FindWindow Lib "user32.dll" Alias "FindWindowA" ( _
                                   ByVal lpClassName As String, _
                                   ByVal lpWindowName As String) As Long

Public Declare Function FindWindowEx Lib "user32.dll" Alias "FindWindowExA" ( _
                                     ByVal hWnd1 As Long, _
                                     ByVal hWnd2 As Long, _
                                     ByVal lpsz1 As String, _
                                     ByVal lpsz2 As String) As Long
                                     
'22.07.2014 AL
Public Declare Function ShowWindow Lib "user32" ( _
  ByVal hwnd As Long, _
  ByVal nCmdShow As Long) As Long
'ENDE 22.07.2014

Public Declare Function SetForegroundWindow Lib "user32.dll" (ByVal hwnd As Long) As Long

Public Declare Function SetFocus Lib "user32.dll" ( _
                                 ByVal hwnd As Long) As Long

Public Declare Function SetCurrentDirectory Lib "kernel32.dll" _
                                            Alias "SetCurrentDirectoryA" _
                                            (ByVal lpPathName As String) As Long

Public Declare Function ClosePrinter Lib "winspool.drv" _
                                     (ByVal hPrinter As Long) As Long

Public Declare Function DocumentProperties Lib "winspool.drv" _
                                           Alias "DocumentPropertiesA" _
                                           (ByVal hwnd As Long, _
                                            ByVal hPrinter As Long, _
                                            ByVal pDeviceName As String, _
                                            ByVal pDevModeOutput As Long, _
                                            ByVal pDevModeInput As Long, _
                                            ByVal fMode As Long) As Long

Public Declare Function GetPrinter Lib "winspool.drv" _
                                   Alias "GetPrinterA" _
                                   (ByVal hPrinter As Long, _
                                    ByVal Level As Long, _
                                    pPrinter As Byte, _
                                    ByVal cbBuf As Long, _
                                    pcbNeeded As Long) As Long

Public Declare Function OpenPrinter Lib "winspool.drv" _
                                    Alias "OpenPrinterA" _
                                    (ByVal pPrinterName As String, _
                                     phPrinter As Long, _
                                     pDefault As Any) As Long

Public Declare Function SetPrinter Lib "winspool.drv" _
                                   Alias "SetPrinterA" _
                                   (ByVal hPrinter As Long, _
                                    ByVal Level As Long, _
                                    pPrinter As Byte, _
                                    ByVal command As Long) As Long

Public Declare Function EnumPrinters Lib "winspool.drv" _
                                     Alias "EnumPrintersA" _
                                     (ByVal flags As Long, _
                                      ByVal name As String, _
                                      ByVal Level As Long, _
                                      pPrinterEnum As Long, _
                                      ByVal cdBuf As Long, _
                                      pcbNeeded As Long, _
                                      pcReturned As Long) As Long

Public Declare Function PtrToStr Lib "kernel32.dll" _
                                 Alias "lstrcpyA" _
                                 (ByVal RetVal As String, _
                                  ByVal Ptr As Long) As Long

Public Declare Function StrLen Lib "kernel32.dll" _
                               Alias "lstrlenA" _
                               (ByVal Ptr As Long) As Long

Public Declare Sub CopyMemory Lib "kernel32.dll" _
                              Alias "RtlMoveMemory" _
                              (pDest As Any, _
                               pSource As Any, _
                               ByVal cbLength As Long)

Public Declare Function DeviceCapabilities Lib "winspool.drv" _
                                           Alias "DeviceCapabilitiesA" _
                                           (ByVal lpDeviceName As String, _
                                            ByVal lpPort As String, _
                                            ByVal iIndex As Long, _
                                            lpOutput As Any, _
                                            ByVal dev As Long) As Long
Public Declare Function GetProfileString _
                         Lib "kernel32.dll" Alias "GetProfileStringA" _
                             (ByVal lpAppName As String, ByVal lpKeyName As String, _
                              ByVal lpDefault As String, ByVal lpReturnedString As String, _
                              ByVal nSize As Long) As Long

Public Declare Function GetProfileSection _
                         Lib "kernel32.dll" Alias "GetProfileSectionA" _
                             (ByVal lpAppName As String, ByVal lpReturnedString As String, _
                              ByVal lngSize As Long) As Long

' vorher in TC_LogfileHandler
Public Function LogFileEnumProc(ByVal hwnd As Long, ByVal lParam As Long) As Long
    Dim RetVal As Long
    Dim windowText As String
    Dim WindowClass As String



5   With WindowsListForProtokoll(wndCnt)
        ' Fenstertext ermitteln
10      .WndHwdn = hwnd
15      windowText = Space(GetWindowTextLength(hwnd) + 1)
20      RetVal = GetWindowText(hwnd, windowText, Len(windowText))
25      .WndText = Left(windowText, RetVal)
30      If MaxWndTextLen < RetVal Then MaxWndTextLen = RetVal

        ' Fensterklasse ermitteln
35      WindowClass = Space(256)
40      RetVal = GetClassName(hwnd, WindowClass, Len(WindowClass))
45      WindowClass = Left(WindowClass, RetVal)
50      .WndClass = Left(WindowClass, RetVal)
55      If MaxWndClassLen < RetVal Then MaxWndClassLen = RetVal
60      .visible = IsWindowVisible(.WndHwdn)
65      .maxim = IsZoomed(.WndHwdn)
70      .minim = IsIconic(.WndHwdn)

75  End With

80  wndCnt = wndCnt + 1

85  If wndCnt >= 1000 Then
90      WindowsListForProtokoll(wndCnt).WndText = "zuviele Fensterhandles"
95      wndCnt = wndCnt + 1
100     LogFileEnumProc = 0
105 Else
        ' Wert f|fffd|r die weitere Enumerierung zur|fffd|ckgeben
110     LogFileEnumProc = 1
115 End If

End Function

' vorher in TC_Tools
Public Function ToolsEnumProc(ByVal hwnd As Long, ByVal lParam As Long) As Long
    Dim RetVal As Long
    Dim wndCnt As Integer
    Dim windowText As String

    ' On Error GoTo ToLargeWindowClassText

5   If IsWindowVisible(hwnd) Then
10      wndCnt = UBound(WindowsListForID) + 1
15      ReDim Preserve WindowsListForID(wndCnt)

20      With WindowsListForID(wndCnt)
25          .WndHwnd = hwnd
30          windowText = Space(GetWindowTextLength(hwnd) + 1)
35          RetVal = GetWindowText(hwnd, windowText, Len(windowText))
40          .WndText = Left(windowText, RetVal)
            ' ProzessId ermitteln
45          .WndCreator = GetWindowThreadProcessId(hwnd, .WndPID)
50      End With
55  End If

60  ToolsEnumProc = 1
End Function

Public Function GetFormattedTime() As String
    Dim myTime As SYSTEMTIME
5   Call GetLocalTime(myTime)

10  With myTime
15      GetFormattedTime = Format(.wHour, "00") & ":" & _
                           Format(.wMinute, "00") & ":" & _
                           Format(.wSecond, "00") & ":" & _
                           Format(.wMilliseconds, "000")
20  End With
End Function

Public Function ErrorDescription(ByVal Number As Long) As String
    Dim lBuffer As String
    Dim lRet As Long

5   lBuffer = Space$(512)
10  lRet = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_MAX_WIDTH_MASK, _
                         ByVal 0&, _
                         Number, _
                         LANG_USER_DEFAULT, _
                         lBuffer, _
                         Len(lBuffer), _
                         ByVal 0)

15  If lRet > 0 Then
20      ErrorDescription = Left(lBuffer, lRet)
25  Else
30      ErrorDescription = "Fehlerbeschreibung nicht lesbar"
35  End If
End Function

Public Function GetRegEnumValue(hKey As Long, _
                                cnt As Long, _
                                nameString As String, _
                                valueString As String) As Boolean

    Const BUFFER_SIZE As Long = 255
    Dim sName As String
    Dim sData As String
    Dim Retour As Long
    Dim RetData As Long

5   sName = Space(BUFFER_SIZE)
10  Retour = BUFFER_SIZE
15  sData = Space(BUFFER_SIZE)
20  RetData = BUFFER_SIZE

25  If RegEnumValue(hKey, cnt, sName, Retour, 0, ByVal 0&, ByVal sData, RetData) <> ERROR_NO_MORE_ITEMS Then
30      nameString = Left(sName, Retour)
35      valueString = Left(sData, RetData - 1)
40      GetRegEnumValue = True
45  Else
50      nameString = vbNullString
55      valueString = vbNullString
60      GetRegEnumValue = False
65  End If
End Function

Public Function GetLocalKeyValue(valuePath As String, keyStr As String, subKeyStr As String) As String
    Dim hKey As Long
    Dim cnt As Long
    Dim keyValue As String
    Dim subKeyName As String
    Dim subKeyLen As Integer

5   cnt = 0
10  GetLocalKeyValue = vbNullString
15  subKeyLen = Len(subKeyStr)
20  If RegOpenKey(HKEY_LOCAL_MACHINE, valuePath & keyStr, hKey) = 0 Then
25      While GetRegEnumValue(hKey, cnt, subKeyName, keyValue)
30          If LCase(Left(subKeyName, subKeyLen)) = LCase(subKeyStr) Then
35              GetLocalKeyValue = GetLocalKeyValue & keyValue
40          End If
45          cnt = cnt + 1
50      Wend
55      RegCloseKey hKey
60  End If

End Function


Public Function GetCurrentUserRegValue(subSection As String, key As String) As String

    Dim hKey As Long
    Dim value As String
    Dim Length As Long
    Dim section As String

5   section = TC_OS2_Section & subSection

10  Length = 255
15  value = Space(Length)
20  GetCurrentUserRegValue = vbNullString

25  If RegOpenKeyEx(HKEY_CURRENT_USER, section, 0&, KEY_ALL_ACCESS, hKey) <> ERROR_SUCCESS Then
30      RegCloseKey (hKey)
35      Exit Function
40  Else
45      If RegQueryValueEx(hKey, key, 0&, 4, ByVal value, Length) <> ERROR_SUCCESS Then
50          RegCloseKey (hKey)
55          Exit Function
60      Else
65          GetCurrentUserRegValue = Left(value, Length - 1)
70          RegCloseKey (hKey)
75      End If
80  End If

End Function



Public Function WriteCurrentUserRegValue(subSection As String, key As String, value As Variant) As Boolean

    Dim result As Long
    Dim s As String
    Dim Back As Long
    Dim SA As SECURITY_ATTRIBUTES
    Dim hKey As Long
    Dim action As Long
    Dim section As String

5   section = TC_OS2_Section & subSection
10  With SA
15      .bInheritHandle = 1
20      .nLength = Len(SA)
25  End With

30  If RegOpenKeyEx(HKEY_CURRENT_USER, section, 0&, KEY_ALL_ACCESS, hKey) <> ERROR_SUCCESS Then
35      If RegCreateKeyEx(HKEY_CURRENT_USER, section, 0&, key, 0&, KEY_WRITE, SA, hKey, action) <> ERROR_SUCCESS Then
40          WriteCurrentUserRegValue = False
45          RegCloseKey (hKey)
50          Exit Function
55      End If
60  End If

65  s = CStr(value)

70  If RegSetValueEx_Str(hKey, key, 0, REG_SZ, s, Len(s) + 1) <> ERROR_SUCCESS Then
75      WriteCurrentUserRegValue = False
80      RegCloseKey (hKey)
85      Exit Function
90  Else
95      WriteCurrentUserRegValue = True
100     RegCloseKey (hKey)
105     Exit Function
110 End If

End Function


Public Sub Arbeitsspeicher(speicher As Long)
    Dim Memory As MEMORYSTATUS

5   Memory.dwLength = Len(Memory)
10  Call GlobalMemoryStatus(Memory)
15  speicher = Format((Memory.dwTotalPhys / 1048576), "0")
End Sub

Public Function GetOSVersion() As String
    Dim OsVersInfoEx As OSVERSIONINFOEX
    Dim OsVersInfo As OSVERSIONINFO
    Dim retString As String

    ' Zuerst nehmen wir nur die kleinere Struktur um sicherzugehen,
    ' dass Windows 95 und Konsorten auch damit klarkommen
5   OsVersInfo.dwOSVersionInfoSize = Len(OsVersInfo)

10  If GetVersionEx1(OsVersInfo) = 0 Then
15      GetOSVersion = "konnte Betriebssystem nicht ermitteln"
20      Exit Function
25  End If

    '   Ergebnis der aus dem Internet kopierten Prozedur
    '   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    '   Platform      Minor-Version   Major-Version
    '   0 - WIN_OLD
    '   1 - WIN32      0 - WIN_95
    '                 10 - WIN_98
    '                 90 - WIN_ME
    '   2 - WIN32_NT                  3 - WIN_NT_3x
    '                                 4 - WIN_NT_4x
    '                  0 - WIN_2K     5
    '                  2 - WIN_2003   5
    '                  1 - WIN_XP     5
    '                      Abfrage von OsVersionEx2 mi wSuiteMask -> Edition abfragen in sWuiteMask
    '  Microsoft:
    '  OS                      MajorVersion    MinorVersion  OsVersionInfoex
    '  Windows 7               6               1             wProductType == VER_NT_WORKSTATION
    '  Windows Server 2008 R2  6               1             wProductType != VER_NT_WORKSTATION
    '  Windows Server 2008     6               0             wProductType != VER_NT_WORKSTATION
    '  Windows Vista           6               0             wProductType == VER_NT_WORKSTATION
    '  Windows Server 2003 R2  5               2             GetSystemMetrics(SM_SERVERR2) != 0
    '  Windows Server 2003     5               2             GetSystemMetrics(SM_SERVERR2) == 0
    '  Windows XP              5               1             not applicable
    '  Windows 2000            5               0             not applicable
    '  Windows NT 4x           4               0             not applicable
    '  Windows NT 3x           3               0             not applicable

30  With OsVersInfo
35      retString = "(Plf.Maj.Min.Bld) - " & .dwPlatformId & _
                    "." & .dwMajorVersion & _
                    "." & .dwMinorVersion & _
                    "." & .dwBuildNumber

40      Select Case .dwMajorVersion
            Case 6
45              Select Case .dwMinorVersion
                    Case 1
50                      retString = retString & " (Windows 7 / Windows Server 2008 R2)"
55                  Case 0
60                      retString = retString & " (Windows Vista / Windows Server 2008)"
65                  Case Else
70                      retString = retString & " n.a."
75              End Select
80          Case 5
85              Select Case .dwMinorVersion
                    Case 2
90                      retString = retString & " (Windows Server 2003 (R2?))"
95                  Case 1
100                     retString = retString & " (Windows XP)"
105                 Case 0
110                     retString = retString & " (Windows 2000)"
115                 Case Else
120                     retString = retString & " n.a."
125             End Select
130         Case 4
135             retString = retString & " (Windows NT 4x)"
140         Case 3
145             retString = retString & " (Windows NT 3x)"
150         Case Else
155             retString = retString & " (n.a.)"
160     End Select
165 End With
170 GetOSVersion = retString
End Function


Public Function WriteTheSystemError() As String
    Dim LastError As Long
    Dim message As String
    Dim flags As String
    Dim Sprache As Long
    Dim RetVal As Long

5   LastError = GetLastError

10  flags = FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS
15  Sprache = LANG_NEUTRAL Or (SUBLANG_DEFAULT * 1024)
20  message = Space(256)                              ' Puffergr|fffd||fffd|e festlegen
25  WriteTheSystemError = "SystemFehler (" & LastError & "): "
30  RetVal = FormatMessage(flags, 0&, LastError, Sprache, message, Len(message), 0&)

35  If RetVal = 0 Then
40      WriteTheSystemError = WriteTheSystemError & "Ein Fehler ist bei dem ermitteln des Fehlertextes aufgetreten."
45  Else
50      WriteTheSystemError = WriteTheSystemError & Left$(message, RetVal)
55  End If
End Function
Attribute VB_Name = "MainModul"
Option Explicit

' der Name dieser Datei, wird als ENV-Variable von der DOC-Datei gesetzt und |fffd|bergeben
Public gstrTemplateFileName As String
Public glongWindowHandleOffice2Exe As Long

'Public Const gstrOS2_VERSION As String = "6.0.0" 'ausgelagert ins Modul Version
Public Const gintMIN_WORD_VERSION As Integer = 9
'Public Const gstrTC_TEMPLATE_DOT_BUILDVERSION As String = "2014.02.07:0002" 'ausgelagert ins Modul Version
Public Const gstrTC_OFFICE_MSGBOXTITLE As String = "Office-Schnittstelle 2.0"

'KonstantenNamen der f|fffd|r die Office-Schnittstelle notwendigen Dateien
' Public Const gstrLOGFILE_FILENAME As String = "tc_os2_prot.txt"

Public Const gstrTC_DEBUG_FILENAME As String = "tc_os2_debug.txt"    ' do not use! -> gibt jede Protokollzeile als MsgBox aus!
Public Const gstrTC_OS2_SYNTAXNAME As String = "tc_os2_syntax.txt"
Public Const gstrTC_OS2_DO_NOT_ENCRYPT_DOFILE_CONTENT As String = "tc_os2_klartext.txt"    ' diese Datei bewirkt das Auslassen der base64-Verschl|fffd|sselung der DO-Datei

Public Const gstrIKOL_CMDBARDOT As String = "tc_oicommandbar.dot"
Public Const gstrIKOL_RIBBONDOT As String = "tc_oiribbon.dotm"
Public Const gstrIKOL_GENERAL_COMMANDBAR_NAME2003 As String = "I K O L"

Public Const gstrTC_SIGN_UP_MODUL As String = "tc_oisignup.dot"
Public Const gstrTC_DEFAULT_SIGN_UP_INI_FILE As String = "config.ini"
Public Const gstrTC_OS_DEFAULT_SIGN_IMAGE_FILE As String = "TC_Sign_Cross.tif"

Public Const gstrTC_WE_INTERN_NAME As String = "WE_.txt"

' eAkte
Public Const gstrTC_ARCHIVENDE_NAME As String = "ENDE.txt"
Public Const gstrTC_ARCHIV_OK As String = "Fertig"
Public Const gstrTC_ARCHIV_ERROR As String = "Fehler!"

Public Const gstrTC_WE_MARKERSTRING As String = "#$~%~&#"
Public Const gstrTC_DO_MARKERSTRING As String = "%$~#~&%"


' z|fffd|hlt die Anzahl der instantiierten IkolClients-Objekte
' Public gintInitiatedIkolClientAppObjectsCounter As Integer

' falls Word 2013: wurde von mindestens einem Ikol-Client die Option
' "E-Mail-Anlagen und andere nicht bearbeitbare Dateien im Lesemodus |fffd|ffnen"
' abgew|fffd|hlt; wenn ja, muss der Lesemodus nach dem Schlie|fffd|en des jeweils letzen IkolClient-Objekt
' wiederhergestellt werden
' Public gboolAllowReadingModeHasBeingTurnedOff As Boolean

' benutzt um den abschliessenden Fokus |fffd|ber Bitvergleiche zu steuern
Public Const gintDOKUMENT_AKTIV As Integer = 1
Public Const gintLADE_AKTIV As Integer = 2
Public Const gintNO_APPLICATION_FOR_FOKUS As Integer = 4

'08.05.2014 AL
Public gboolSaveAsClicked As Boolean

'23.06.2014 AL
Public gboolWithBeforeSave As Boolean

'19.04.2016 AL
Public mboolDruckIntern As Boolean

'14.07.2016 AL
Public gboolNormalDotSaved As Boolean 'global, weil Session schon zerst|fffd|rt, wenn das gebraucht wird

'20.04.2017 AL
Public gstrWeCreateTime As String

'26.02.2018 AL
Public gboolDeltaScroll As Boolean

'f|fffd|r wordswvn
Public Sub getVersion(strOS2Version As String, strBUILDVersion As String)
  strOS2Version = gstrOS2_VERSION
  strBUILDVersion = gstrTC_TEMPLATE_DOT_BUILDVERSION
End Sub

Public Function GetEnvironmentVar(strName As String) As String
    Dim tempEnvVar As String
    Dim bufferLen As Integer

5   GetEnvironmentVar = vbNullString
10  tempEnvVar = String(1000, 0)
15  bufferLen = GetEnvironmentVariable(strName, tempEnvVar, Len(tempEnvVar))
20  If bufferLen > 0 Then
25      GetEnvironmentVar = Left(tempEnvVar, bufferLen)
30  End If
End Function

Private Sub StartTimer(longTime As Long)
    'notify the use 1 second are up
5   SetTimer 0&, 0&, longTime, AddressOf TimerTripped
End Sub

Private Sub TimerTripped _
        (ByVal hwnd As Long, _
         ByVal uMsg As Long, _
         ByVal idEvent As Long, _
         ByVal dwTime As Long)
    'stop and kill the timer, idEvent holds the timer id
    'this must be done before the program ends or it will throw an error
5   KillTimer 0&, idEvent
10  Call Main
End Sub

Private Function CompareFileName(savedName As String, compareName As String) As Boolean
5   CompareFileName = (UCase(savedName) = UCase(compareName))
End Function


Private Function GetDocumentObject(strFileName As String) As Document

5   On Error GoTo RaiseErrorHandler

    Dim objDoc As Document
    Dim objResultDocument As Document

10  Set objResultDocument = Nothing

15  If Not Documents Is Nothing Then
20      For Each objDoc In Documents
25          If CompareFileName(objDoc.FullName, strFileName) Then
30              Set objResultDocument = objDoc
35              GoTo ExitProc
40          End If
45      Next objDoc
50  End If

ExitProc:
55  Set GetDocumentObject = objResultDocument
60  Set objResultDocument = Nothing
65  Set objDoc = Nothing
70  Exit Function


RaiseErrorHandler:
75  Err.Raise Err.Number, "MainModul::GetDocumentObject", Err.Description & " -> Versuch, das Dokument '" & _
                                                          strFileName & "' unter den ge|fffd|ffneten Dokumenten zu finden."
80  Resume ExitProc
End Function


Private Sub CloseDocumentByFullName(strFileName As String)
    ' die Datei schlie|fffd|en, ohne sie abzuspeichern
    ' verwenden von der TC_OITEMPLATE.DOT, um die TC_OIRUN.DOC zu schlie|fffd|en

5   On Error GoTo RaiseErrorHandler

    Dim objDoc As Document

10  Set objDoc = GetDocumentObject(strFileName)
15  If Not (objDoc Is Nothing) Then
20      objDoc.Close savechanges:=wdDoNotSaveChanges

25  End If

ExitProc:
30  Set objDoc = Nothing
35  Exit Sub

RaiseErrorHandler:
40  Err.Raise Err.Number, Err.Source & "->" & "MainModul::CloseDocumentByFullName", Err.Description & " -> Versuch das Dokument zu schlie|fffd|en"
45  Resume ExitProc
End Sub

Public Sub StartTcOITemplate(longTime As Long, _
                             strVerfName As String, _
                             longClientPid As Long, _
                             longWinHandleOffice2 As Long, _
                             strClientWindowTitle As String, _
                             strCurrentLogfileFullName As String)


    ' als Erstes Umgebungsvariablen von der DOC hier an globale Variablen |fffd|bergeben
5   glongWindowHandleOffice2Exe = longWinHandleOffice2
10  gstrTemplateFileName = GetEnvironmentVar("WIKOL_TC_OITEMPLATE_DOT_FILENAME")

    ' f|fffd|r den Timer ein paar ENV_VARS setzen
15  Call SetEnvironmentVariable("WIKOL_VERFAHRENSNAME", strVerfName)
20  Call SetEnvironmentVariable("WIKOL_CLIENTPID", CStr(longClientPid))
25  Call SetEnvironmentVariable("WIKOL_WINHANDLEOFFICE2", CStr(longWinHandleOffice2))
30  Call SetEnvironmentVariable("WIKOL_CLIENTWINDOWTITLE", strClientWindowTitle)
35  Call SetEnvironmentVariable("WIKOL_CURRENTLOGFILE", strCurrentLogfileFullName)

    ' zum Entkoppeln der TC_OITEMPLATE.DOT von der TC_OIRUN.DOC, die DOT soll sp|fffd|ter die DOC schlie|fffd|en, nachdem die DOC die DOT geladen hat;
    ' damit beides nicht gleichzeitig passieren k|fffd|nnte => entkoppeln
40  Call StartTimer(longTime)
End Sub


'---------------------------------------------------------------------------------------
' Prozedur : Main
' Autor    : Todor Vachkov
' Datum    : 31.07.2013
' Zweck    : das zentrale IkolClientApp-Objekt wird initialisiert mit s|fffd|mtlichen zu ihm geh|fffd|renden
'            Objektvariablen, die die Kopplung mit den reslichen Klassen erm|fffd|glichen
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: keine
' |fffd|bergabeparams: keine
'---------------------------------------------------------------------------------------
Private Sub Main()

10    On Error GoTo ErrorHandler

    Dim eventuellErr01 As Boolean '19.04.2017 AL
    Dim tcrResult As TC_SessionResult
    Dim boolResult As Boolean
    Dim objTcDoc As TC_Document

    ' eine neue Session hinzuf|fffd|gen
    Dim objNewSession As TC_Session
    ' das zentrale IkolClientApp-Objekt
    Dim objIkolClientApp As TC_IkolClientApp

    Dim boolEarlyPostMessage As Boolean               ' kann das Verfahren auch bei einer Symbolleiste freigegeben werden

20    eventuellErr01 = False '19.04.2017

      '08.05.2014 AL
30    gboolSaveAsClicked = False

      '23.06.2014 AL
40    gboolWithBeforeSave = True

    ' die DOC schlie|fffd|en
50    Call CloseDocumentByFullName(GetEnvironmentVar("WIKOL_TC_OIRUN_DOC"))

    ' ein neues IkolClientApp-Objekt initialisieren
    ' und die in der TC_OIRUN.DOC |fffd|bergebenen Informationen an das Objekt weiterleiten
60    Set objIkolClientApp = New TC_IkolClientApp

    ' Metadaten setzen (erstmal ohne die dazugeh|fffd|rigen Objekteigenschaften zu setzen)
70    With objIkolClientApp
80      .VerfahrenName = GetEnvironmentVar("WIKOL_VERFAHRENSNAME")
90      .ClientPid = CLng(GetEnvironmentVar("WIKOL_CLIENTPID"))
100     .WinHandleOffice2 = glongWindowHandleOffice2Exe
110     .ClientWindowTitle = GetEnvironmentVar("WIKOL_CLIENTWINDOWTITLE")
120     .WeFilePrefixWithCurrentPid = "WE_pid" & CLng(GetEnvironmentVar("WIKOL_CLIENTPID")) & "_.txt"
130     .DefaultPrinterName = GetEnvironmentVar("WIKOL_STANDARDDRUCKER")
140     .WinworkPath = GetEnvironmentVar("WIKOL_CURRENTDIR")
150     .LogfileFullName = GetEnvironmentVar("WIKOL_CURRENTLOGFILE")
160     .MsgBoxTitle = gstrTC_OFFICE_MSGBOXTITLE & " - Version: " & gstrOS2_VERSION
170     .Os2Version = gstrOS2_VERSION
180     .BuildVersion = gstrTC_TEMPLATE_DOT_BUILDVERSION
190     .ContainingDotTemplateFile = ThisDocument.FullName
200   End With

    ' LogfileHandler initialisieren, mit dem Namen der generierten Protokolldatei aus TC_OIRUN.DOC
210   Call objIkolClientApp.Initialize_LogfileHandler(GetEnvironmentVar("WIKOL_CURRENTLOGFILE"))

    ' EventHandler initialisieren
220   Call objIkolClientApp.Initialize_EventHandler

    ' Tools initialisieren
230   Call objIkolClientApp.Initialize_Tools

    ' FileHandler initialisieren
240   Call objIkolClientApp.Initialize_FileHandler

    ' ApplicationHandler initialisieren
250   Call objIkolClientApp.Initialize_ApplicationHandler

    ' ControlHandler initialisieren
260   Call objIkolClientApp.Initialize_ControlHandler

    ' CallbackHandler initialisieren
270   Call objIkolClientApp.Initialize_CallbackHandler

    ' DocumentHandler initialisieren
280   Call objIkolClientApp.Initialize_DocumentHandler

    ' PrintHandler initialisieren
290   Call objIkolClientApp.Initialize_PrintHandler

    ' PrinterSetupHandler initialisieren
300   Call objIkolClientApp.Initialize_PrinterSetupHandler

    ' CommandBarCommands initialisieren
310   Call objIkolClientApp.Initialize_CommandBarCommands

    ' MailMergeHandler initialisieren
320   Call objIkolClientApp.Initialize_MailMergeHandler

    ' SignUpHandler initialisieren
330   Call objIkolClientApp.Initialize_SignUpHandler

    ' RibbonAndCommandbarRelated initialisieren
340   Call objIkolClientApp.Initialize_RibbonAndCommandbarRelated

350   Call objIkolClientApp.Initialize_UserFormAnsichtInfo

360   Call objIkolClientApp.Initialize_UserFormDruckerAuswahl

370   Call objIkolClientApp.Initialize_UserFormProgressbalken

      '08.05.2014 AL
380   Call objIkolClientApp.Initialize_UserFormSyncProgress

390   Call objIkolClientApp.Initialize_UserFormVorschau

400   Call objIkolClientApp.Initialize_UserFormEditSignUp

410   Call objIkolClientApp.Initialize_UserFormSignUp

420   Call objIkolClientApp.Initialize_UserFormSignUpSelsection

430   Call objIkolClientApp.Initialize_UserFormSignUpTypeQuestion

    'die Regeln der Syntax f|fffd|r die Auswertung der WE-Datei laden
440   Call objIkolClientApp.Initialize_SyntaxDescription
    ' der festgelegte Satz von zul|fffd|ssigen Makros und Buttonaktionen auf den Symbolleisten werden registriert
450   Call objIkolClientApp.SyntaxDescription.DefineOldMakroDescription(objIkolClientApp.WinworkPath)

    ' SessionContainer initialisieren
460   Call objIkolClientApp.Initialize_SessionsContainer

    ' initialisiere den Session-Z|fffd|hler im Container
470   Call objIkolClientApp.SessionsContainer.InitSessionCounter(objIkolClientApp.WinworkPath & _
                                                               Application.PathSeparator & objIkolClientApp.WeFilePrefixWithCurrentPid)

480   Set objNewSession = New TC_Session
490   Call objIkolClientApp.SessionsContainer.AddSession(objNewSession)

500   Call objNewSession.SetSessionEnvironment

'20.04.2017 AL
Dim weName As String 'diese WE-Datei ist vom IKOL soeben vor dem Start von MS-Office erzeugt worden
510   weName = objIkolClientApp.WinworkPath & Application.PathSeparator & "WE_pid" & CLng(GetEnvironmentVar("WIKOL_CLIENTPID")) & ".txt"
520   If objIkolClientApp.FileHandler.FileExist(weName) Then
530     gstrWeCreateTime = objIkolClientApp.FileHandler.FileCreateTime(weName)
  
'  Call objIkolClientApp.LogfileHandler.M_Protokoll("+++++", objNewSession)
'  Call objIkolClientApp.LogfileHandler.M_Protokoll("aufrufendes Verfahren erstellte die WE-Datei am: " & Date & " " & gstrWeCreateTime, objNewSession)
'  Call objIkolClientApp.LogfileHandler.M_Protokoll("+++++" & vbCrLf, objNewSession)
540   End If
'ENDE 20.04.2017 AL



    ' pr|fffd|fe, ob die WE-Datei mit der PID im Namen da ist, wenn ja - benenne den Dateinamen zus|fffd|tzlich mit SID um
550   Call objNewSession.RenameWeFile(objIkolClientApp.WinworkPath & Application.PathSeparator & objIkolClientApp.WeFilePrefixWithCurrentPid)

    ' verarbeite die Befehle in der WE-Datei (= ergeben in ihrer Gesamtheit die Session ) der Reihe nach
560   boolResult = objNewSession.ProcessWeFile

'20.04.2017 AL
'an dieser Stelle ist die WE abgearbeitet
'==> die Differenz von JETZT und gstrWeCreateTime (Erstellzeit der WE-Datei (vom IKOL erstellt)) ist die Laufzeit der OS2 nach Abarbeitung aller Befehle
Dim jetzt As Date
Dim weCreate As Date
Dim diff As String

570   jetzt = Now
580   weCreate = Date & " " & gstrWeCreateTime

590   'MsgBox "jetzt: " & jetzt
600   'MsgBox "weCreate: " & weCreate

610   diff = DateDiff("s", weCreate, jetzt)
620   'MsgBox "diff: " & diff

630     Call objIkolClientApp.LogfileHandler.M_Protokoll("+++++", objNewSession)
640     Call objIkolClientApp.LogfileHandler.M_Protokoll("Erstellungszeitpunkt der WE-Datei durch Verfahren: " & weCreate, objNewSession)
650     Call objIkolClientApp.LogfileHandler.M_Protokoll("Zeitpunkt Abarbeitungsende WE-Datei              : " & jetzt, objNewSession)
660     Call objIkolClientApp.LogfileHandler.M_Protokoll("Zeit vom Start der OS2 bis Ende Abarbeitung      : " & diff & " Sekunden", objNewSession)
670     Call objIkolClientApp.LogfileHandler.M_Protokoll("+++++" & vbCrLf, objNewSession)
'ENDE 20.04.2017 AL

680   If Not boolResult Then
        ' Fehler in der Abarbeitung der WE-Befehlsfolge

        ' wenn der Fensterhandler noch g|fffd|ltig ist, die Message abschicken (sollte aber bereits in objNewSession.ProcessWeFile geschehen sein - im ErrorHandler)
690     If CBool(IsWindow(objIkolClientApp.WinHandleOffice2)) Then
700         Call objIkolClientApp.LogfileHandler.ProtokollMsg("MainModul::Main: POST_MESSAGE an WinHnd [" & objIkolClientApp.WinHandleOffice2 & "] mit EXIT-CODE [" & glongEXIT_CODE_TC_OITEMPLATE_DOT_ERROR & "]")
710         PostMessage objIkolClientApp.WinHandleOffice2, glongWM_CLOSE, glongEXIT_CODE_TC_OITEMPLATE_DOT_ERROR, 0
720         DoEvents
730     End If

740     If Not objIkolClientApp.ClientSessionAlreadyClosed Then
750         Call objNewSession.CloseAllSessionDocuments
760         If Not objIkolClientApp.ClientSessionAlreadyClosed Then
770             Call objIkolClientApp.CloseSession(objNewSession, True, "MainModul:Main - Fehler in der Verarbeitung der WE-Datei")
780         End If
790     End If

800     Call objIkolClientApp.LogfileHandler.CloseLogfileTextStream

810     If Not objIkolClientApp Is Nothing Then
820         Set objIkolClientApp = Nothing
830     End If
840     GoTo ExitProc
850   End If


    ' hier pr|fffd|fen, ob das Verfahren freigegeben werden darf; Sesssion wird noch nicht geschlossen!
    ' Begin
860   boolEarlyPostMessage = objNewSession.CheckPermissionForPostMessage

870   If boolEarlyPostMessage Then
880     Call objIkolClientApp.LogfileHandler.ProtokollMsg("MainModul::Main: Bedingungen f|fffd|r eine fr|fffd|here Freigabe des Verfahrens GEGEBEN.")
890     Call objIkolClientApp.LogfileHandler.ProtokollMsg("MainModul::Main: POST_MESSAGE an WinHnd [" & objIkolClientApp.WinHandleOffice2 & "] mit EXIT-CODE [" & glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS & "]")
900     PostMessage objIkolClientApp.WinHandleOffice2, glongWM_CLOSE, glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS, 0
910     DoEvents
920     boolEarlyPostMessage = False
930   Else
940     Call objIkolClientApp.LogfileHandler.ProtokollMsg("MainModul::Main: Bedingungen f|fffd|r eine fr|fffd|here Freigabe des Verfahrens NICHT GEGEBEN.")
950   End If

    ' pr|fffd|fe, ob die Session geschlossen werden kann
960   tcrResult = objNewSession.CheckSymbolbarExistencePreventingSessionClosing

970   If tcrResult <> tcrNoEnd Then
        ' Session darf geschlossen werden
        
        ' aber nur soweit nicht bereits geschlossen in CheckSymbolbarExistencePreventingSessionClosing,
        ' wo das letzte TC-Dokument aus der Verwaltung h|fffd|tte entfernt sein m|fffd|ssen
980     If Not objIkolClientApp.ClientSessionAlreadyClosed Then
990         Call objNewSession.CloseAllSessionDocuments
1000        If Not objIkolClientApp.ClientSessionAlreadyClosed Then
1010            eventuellErr01 = True
1020            Call objIkolClientApp.CloseSession(objNewSession, True, "MainModul::Main - Nach Symbolbar-Auswertung - Session darf geschlossen werden")
1030            eventuellErr01 = False
1040        End If
1050    End If
1060    Call objIkolClientApp.LogfileHandler.CloseLogfileTextStream
1070    If Not objIkolClientApp Is Nothing Then
1080        Set objIkolClientApp = Nothing
1090    End If

1100  Else
        ' es gibt Gr|fffd|nde, die das Schlie|fffd|en der Session verhindern
1110    Call objIkolClientApp.LogfileHandler.M_Protokoll( _
             "Main: Status ist tcrNoEnd ==> Verbleibe in der Session wegen noch ge|fffd|ffneten TC-Dokumenten", objNewSession)

        ' ############## Unterschriftenmodul BEGIN ##############
1120    If objNewSession.SessionAssociatedCommandBarOrRibon.GetVisible("btn_UErf", objNewSession) Or _
           objNewSession.SessionAssociatedCommandBarOrRibon.GetVisible("btn_UDel", objNewSession) Then

1130        If objNewSession.SignSynchScreen = susNoValue Then
1140            objNewSession.SignSynchScreen = susSignSyncScreen
1150        End If

1160        objIkolClientApp.SignUpHandler.SignupStarted = False
1170        objIkolClientApp.SignUpHandler.MultiSignupStarted = False

1180        For Each objTcDoc In objNewSession.ManagedTCDocumentsContainer.ManagedDocumentsCollection
1190            objTcDoc.ManagedTCSignaturesContainer.UpdateSignaturesList
1200        Next objTcDoc

1210        If objNewSession.SignSynchScreen = susAllSyncScreen Then
1220            Call objNewSession.GetWorkingTcDocument.CreateSignUpWindow
1230        End If
1240    End If
        ' ############## Unterschriftenmodul END ##############

1250    If objNewSession.ActiveApplication <> vbNullString Then    ' ActiveApplication wurde festgelegt und muss Fokus erhalten
1260        tcrResult = objIkolClientApp.ApplicationHandler.ActivateApplication( _
                        objNewSession.ActiveApplication, objNewSession)
1270    End If

1280  End If

ExitProc:
1290  Set objTcDoc = Nothing
1300  Set objNewSession = Nothing
1310  Set objIkolClientApp = Nothing
1320  Exit Sub

ErrorHandler:
'04.08.2015 AL
'19.04.2017 AL nun auch sporadisch in Neum|fffd|nster, IKOL-KFZ
'Beim Kunden M|fffd|hldorf (IKOL-But) tritt hier ein Fehler auf.
'Grund daf|fffd|r ist: obige Do-While-Schleife wird zweimal durchlaufen (weil MS-Word anscheinend mit seiner Dokumentenstruktur nicht nachkommt),
'somit wird dann .CloseDocument zweimal aufgerufen, was dann zum Fehler 5825 f|fffd|hrt.
'Dies wurde bisher nur beim But-Kunden M|fffd|hldorf festgestellt - hier tritt der Fehler auch nur spoadisch auf
1330  If eventuellErr01 = True And Err.Number = 5825 Then
        'Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Fehler: TC_Session::CheckSymbolbarExistencePreventingSessionClosing Fehler 5825 |fffd|bersprungen", Me)
1340    If Not objIkolClientApp Is Nothing Then
1350      Call objIkolClientApp.LogfileHandler.CloseLogfileTextStream
1360    End If
1370    Resume ExitProc
1380  End If
'ENDE 04.08.2015 AL

1390  Call DotCentralErrorHandler(objIkolClientApp, "MainModul", "Main", , vbNullString)
1400  Resume ExitProc
End Sub
Attribute VB_Name = "RibbonCommunicator"
Option Explicit

'---------------------------------------------------------------------------------------
' Modul    : RibbonCommunicator
' Autor    : Todor Vachkov
' Datum    : 20.08.2013
' Zweck    : dient als Wrapper zum Aufrufen von Klassenmethoden aus dem Ribbon/der Symbolleiste heraus;
'          : auf die die Modul-Objektvariable 'gobjIkolClientApp' zeigt immer das jeweils aktuelle IkolClientObjekt
'          : somit ist gew|fffd|hrleistet, dass die aufgerufenen Makros eindeutig zugewiesen werden
'---------------------------------------------------------------------------------------

Public gobjIkolClientApp As TC_IkolClientApp

Public Sub SetRibbonLoaded(ByRef intResult As Integer)

5   Call gobjIkolClientApp.RibbonAndCommandbarRelatives.SetRibbonLoaded(intResult)
End Sub


Public Function DoRibbonButtonAction(ByRef controlId As String) As Boolean

5   DoRibbonButtonAction = gobjIkolClientApp.RibbonAndCommandbarRelatives.DoRibbonButtonAction(controlId)

10  If Not gobjIkolClientApp Is Nothing Then
15      If gobjIkolClientApp.LogfileSafeToClose Then
20          Call gobjIkolClientApp.LogfileHandler.CloseLogfileTextStream
25      End If
30  End If

End Function

Public Sub GetEnabledValue(ByRef controlId As String, ByRef enabled As Boolean)
5   Call gobjIkolClientApp.RibbonAndCommandbarRelatives.GetEnabledValue(controlId, enabled)
End Sub

Public Sub GetTabVisibleValue(ByRef visible As Boolean)
5   Call gobjIkolClientApp.RibbonAndCommandbarRelatives.GetTabVisibleValue(visible)
End Sub

Public Sub GetVisibleValue(ByRef controlId As String, ByRef visible As Boolean)
5   Call gobjIkolClientApp.RibbonAndCommandbarRelatives.GetVisibleValue(controlId, visible)
End Sub

Public Sub GetToolTipText(ByRef controlId As String, ByRef strToolTip As String)
5   Call gobjIkolClientApp.RibbonAndCommandbarRelatives.GetToolTipText(controlId, strToolTip)
End Sub

Public Sub Protokoll(ByRef strTag As String, ByRef strMessage As String)
5   Call gobjIkolClientApp.CallbackHandler.Protokoll(strTag, strMessage)
End Sub
Attribute VB_Name = "TC_ApplicationHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp


Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_ApplicationHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
'Public Sub SetWordModeAfterWork(boolLetWordMaximized As Boolean, session As TC_Session)
Public Sub SetWordModeAfterWork(boolLetWordMaximized As Integer, session As TC_Session)
10    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler:SetWordModeAfterWork: Soll MS Word laut OEFFNE-Befehl zum Schlu|fffd| maximiert bleiben? - " & boolLetWordMaximized, session)

20    If Me.ParentIkolClientApp.MaximizeWordAfterSessionClose Then
30      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler:SetWordModeAfterWork: Setze session.MaximizeWordAfterSessionClose auf True", session)
40      session.MaximizeWordAfterSessionClose = True
50    Else
60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler:SetWordModeAfterWork: Setze session.MaximizeWordAfterSessionClose auf " & boolLetWordMaximized, session)
70      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler:SetWordModeAfterWork: Setze Me.ParentIkolClientApp.MaximizeWordAfterSessionClose auf " & boolLetWordMaximized, session)

80      session.MaximizeWordAfterSessionClose = boolLetWordMaximized
90      Me.ParentIkolClientApp.MaximizeWordAfterSessionClose = boolLetWordMaximized
100   End If

End Sub

Public Sub HideShadowMergeField(Doc As Document, session As TC_Session)
5   On Error GoTo RaiseErrorHandler

    Dim fieldShadowButton As CommandBarControl

10  Set fieldShadowButton = Doc.CommandBars("Mail Merge").FindControl(msoControlButton, 6069)

15  If fieldShadowButton Is Nothing Then
20      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::HideShadowMergeField: shadowButton nicht gefunden", session)
25  Else
30      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::HideShadowMergeField: shadowButton gefunden", session)

35      If fieldShadowButton.State = msoButtonDown Then
40          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::HideShadowMergeField: shadowButton hat Wert msoButtonDown", session)
45          WordBasic.MailMergeShadeFields
50      Else
55          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::HideShadowMergeField: shadowButton hat Wert msoButtonUp", session)
60      End If
65  End If

ExitProc:
70  Set fieldShadowButton = Nothing
75  Exit Sub

RaiseErrorHandler:
80  Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::HideShadowMergeField" & " in Zeile:" & Erl & vbCrLf, Err.Description
85  Resume ExitProc
End Sub

Private Function SetForeGround(Anwendung As String) As Long
5   On Error GoTo RaiseErrorHandler

    Dim hwnd As Long
10  hwnd = FindWindow(vbNullString, Anwendung)
15  If hwnd Then
20      SetForeGround = SetForegroundWindow(hwnd)
25  End If

ExitProc:
30  Exit Function

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::SetForeGround" & " in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Function

Public Function ActivateApplicationByTitle(windowTitle As String, session As TC_Session) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    ' Vorraussetzung f|fffd|r diese Prozedur, der windowTitle ist nicht leer
    Dim retValue As Long
    Dim tcrResult As TC_SessionResult

10  tcrResult = tcrFokusError

15  If Tasks.Exists(windowTitle) Then
20      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByTitle: ActivateApplication Task existiert", session)
25      If Tasks(windowTitle).visible Then
30          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByTitle: ActivateApplication Task ist sichtbar", session)
35          Tasks(windowTitle).Activate
40          retValue = SetForeGround(windowTitle)
45          Call SetFocus(FindWindow(vbNullString, windowTitle))
50          tcrResult = tcrOK
55      Else
60          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByTitle: ActivateApplication Task ist nicht sichtbar", session)
65      End If
70  Else
75      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByTitle: ActivateApplication Task nicht gefunden", session)
80  End If

ExitProc:
85  ActivateApplicationByTitle = tcrResult
90  Exit Function

RaiseErrorHandler:

95  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_ApplicationHandler::ActivateApplicationByTitle: Fehler [" & _
         Err.Number & "] - '" & _
         Err.Description & "' in Zeile [" & _
         Erl & "] - Setzen Fokus |fffd|ber Fenstertitel nicht erfolgreich", session)

100 tcrResult = tcrFokusError
    '100 Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::ActivateApplicationByTitle" & " in Zeile:" & Erl & vbCrLf, Err.Description
105 Resume ExitProc

End Function

Public Function ActivateApplication(windowTitle As String, session As TC_Session) As TC_SessionResult
5     On Error GoTo RaiseErrorHandler
    Dim retValue As Long
    Dim tcrResult As TC_SessionResult

10    tcrResult = tcrFokusError

15    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplication: mit Fenstertitel " & Chr(34) & windowTitle & Chr(34), session)

20    If windowTitle <> vbNullString Then
25      If session.ApplicationPIDExist() Then
30          tcrResult = ActivateApplicationByPID(session.ApplicationPID, session)
35      Else
40          tcrResult = ActivateApplicationByTitle(windowTitle, session)
45      End If
50    Else
55      Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("TC_ApplicationHandler::ActivateApplication: Es wurde f|fffd|r die Anwendung ein leerer Fenstertitel |fffd|bergeben" & vbLf & _
                                                              "Bitte in der Konfigurationsdatei den Fenstertitel der Anwendung setzen", session)

60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplication: Es wurde f|fffd|r die Anwendung ein leerer Fenstertitel |fffd|bergeben" & vbLf & _
                                                               "Bitte in der Konfigurationsdatei den Fenstertitel der Anwendung setzen", session)
65      tcrResult = tcrWarning
70    End If

ExitProc:
75    ActivateApplication = tcrResult
80    Exit Function

RaiseErrorHandler:
85    tcrResult = tcrFokusError
90    Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::ActivateApplication" & " in Zeile:" & Erl & vbCrLf, Err.Description
95    Resume ExitProc

End Function


Public Function ActivateApplicationWindow(windowTitle As String, _
                                          makroName As String, _
                                          session As TC_Session) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim tcResult As TC_SessionResult

10  If windowTitle = vbNullString Then

15      Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Es wurde f|fffd|r die Anwendung ein leerer Fenstertitel |fffd|bergeben" & vbLf & _
                                                              "Bitte in der Konfigurationsdatei den Fenstertitel der Anwendung setzen", session)

20      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Es wurde f|fffd|r die Anwendung ein leerer Fenstertitel |fffd|bergeben" & vbLf & _
                                                               "Bitte in der Konfigurationsdatei den Fenstertitel der Anwendung setzen", session)
25      ActivateApplicationWindow = tcrWarning
30  Else
35      tcResult = ActivateApplication(windowTitle, session)
40      If Not ((tcResult = tcrOK) Or (tcResult = tcrWarning)) Then
45          Me.ParentIkolClientApp.LogfileHandler.WriteWindowHandlingLogfile windowTitle, makroName, session
50      Else
55          session.ActiveApplication = windowTitle
60      End If
65      ActivateApplicationWindow = tcResult
70  End If

ExitProc:
75  Exit Function

RaiseErrorHandler:
80  Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::ActivateApplicationWindow" & " in Zeile:" & Erl & vbCrLf, Err.Description
85  Resume ExitProc

End Function

Public Sub SetScreenUpdate(ByVal boolShow As Boolean)

5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_ApplicationHandler::SetScreenUpdate: setzte zu " & boolShow)

15  If Not boolShow Then                              ' wird ausgeschaltet, deswegen noch einmal ein refresh
20      Application.ScreenRefresh
25  End If

30  Application.ScreenUpdating = boolShow

35  If boolShow Then                                  ' refresh nach dem Einschalten des ScreenUpdating
40      Application.ScreenRefresh
45  End If

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::SetScreenUpdate" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Sub

Public Function ActivateApplicationByPID(intApplicationPID As Long, session As TC_Session) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    ' Vorraussetzung f|fffd|r diese Prozedur, der windowTitle ist nicht leer
    Dim retValue As Long
    Dim windowTitle As String
    Dim WndHwnd As Long
    Dim retHwnd As Long
    Dim intPID As Long
    Dim tcrResult As TC_SessionResult

10  tcrResult = tcrFokusError
15  tcrResult = Me.ParentIkolClientApp.Tools.GetInfoForPID(session, WndHwnd, windowTitle)
20  intPID = intApplicationPID

25  If tcrResult = tcrOK Then
30      If Me.ParentIkolClientApp.Tools.CompareWindowTitles(windowTitle, session.CallingApplName) Then
35          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByPID: Fenster mit PID und windowTitel gefunden", session)
40          AppActivate (intPID)
45          retHwnd = SetForegroundWindow(WndHwnd)
50          If retHwnd <> 0 Then
55              tcrResult = tcrOK
60              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByPID: Setzen Fokus |fffd|ber PID erfolgreich", session)
65              GoTo ExitProc
70          Else
75              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByPID: " & GlobalAPIDeclarations.WriteTheSystemError, session)
80          End If
85      Else
90          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByPID: Fenstertitel stimmen nicht |fffd|berein", session)
95      End If
100 End If

105 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_ApplicationHandler::ActivateApplicationByPID: Setzen Fokus |fffd|ber PID nicht erfolgreich, Versuch Setze Fokus |fffd|ber Fenstertitel", session)
110 tcrResult = Me.ActivateApplicationByTitle(session.CallingApplName, session)

ExitProc:
115 ActivateApplicationByPID = tcrResult
120 Exit Function

RaiseErrorHandler:
125 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_ApplicationHandler::ActivateApplicationByPID: Fehler [" & _
         Err.Number & "] - '" & _
         Err.Description & "' in Zeile [" & _
         Erl & "] - Setzen Fokus |fffd|ber PID nicht erfolgreich, Versuch Setze Fokus |fffd|ber Fenstertitel", session)

130 tcrResult = ActivateApplicationByTitle(session.CallingApplName, session)
    ' 135 Err.Raise Err.Number, Err.Source & "->" & "TC_ApplicationHandler::ActivateApplicationByPID" & " in Zeile:" & Erl & vbCrLf, Err.Description
    ' 140 Resume ExitProc
End Function
Attribute VB_Name = "TC_CallbackHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_LogfileHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property


Public Sub Protokoll(strTag As String, strMessage As String)

5   On Error GoTo RaiseErrorHandler
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)

15  If session Is Nothing Then
20      Call Me.ParentIkolClientApp.LogfileHandler.General_ProtokollMsg(strTag, strMessage)
25  Else
30      Call Me.ParentIkolClientApp.LogfileHandler.General_Protokoll(strTag, strMessage, session)
35  End If

ExitProc:
40  Set session = Nothing
45  Exit Sub

RaiseErrorHandler:
50  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::Protokoll" & " in Zeile:" & Erl & vbCrLf, Err.Description
55  Resume ExitProc
End Sub


Public Sub WaehleDrucker(strNeuerDrucker As String)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::WaehleDrucker: (" & Chr(34) & strNeuerDrucker & Chr(34) & ")")
15  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)

20  If session Is Nothing Then
25      Call MsgBox("Aufruf f|fffd|r Druckerauswahl an dieser Stelle nicht erlaubt", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::WaehleDrucker: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
35  Else
40      strNeuerDrucker = Me.ParentIkolClientApp.PrinterSetupHandler.SelectPrinter(session, strNeuerDrucker)
45      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::WaehleDrucker: ausgew|fffd|hlter Drucker ist " & Chr(34) & strNeuerDrucker & Chr(34))
50  End If
55  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::WaehleDrucker")


ExitProc:
60  Set session = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::WaehleDrucker" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc

End Sub

Public Sub HoleStandardDrucker(strStandardDrucker As String)

5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::HoleStandardDrucker")

15  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
20      Call MsgBox("Angabe des IKOL-Titels an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
25      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleStandardDrucker: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Sessions aktiv sind")
30      strStandardDrucker = vbNullString
35  Else
40      strStandardDrucker = Me.ParentIkolClientApp.DefaultPrinterName
45  End If
50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleStandardDrucker")

ExitProc:
55  Exit Sub

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleStandardDrucker" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc
End Sub

Public Sub HoleIKOLTitel(strIKOLTitel As String)

5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::HoleIKOLTitel")

15  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
20      Call MsgBox("Aufruf f|fffd|r Druckerauswahl an dieser Stelle nicht erlaubt", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
25      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleIKOLTitel: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Sessions aktiv sind")
30      strIKOLTitel = vbNullString
35  Else
40      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
45      If session Is Nothing Then
50          Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleIKOLTitel: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
55          strIKOLTitel = vbNullString
60      Else
65          strIKOLTitel = session.CallingApplName
70      End If
75  End If
80  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleIKOLTitel")

ExitProc:
85  Set session = Nothing
90  Exit Sub

RaiseErrorHandler:
95  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleIKOLTitel" & " in Zeile:" & Erl & vbCrLf, Err.Description
100 Resume ExitProc

End Sub

Public Sub HoleParameterValue(strParameterName As String, strParameterValue As String)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::HoleParameterValue")

15  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
20      Call MsgBox("Aufruf f|fffd|r Auslesen Parameter Value an dieser Stelle nicht erlaubt", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
25      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleParameterValue: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Sessions aktiv sind")
30      strParameterValue = vbNullString
35  Else
40      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
45      If session Is Nothing Then
50          Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleParameterValue: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
55      Else
60          strParameterValue = session.GetParameterValue(strParameterName)
65      End If
70  End If
75  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleParameterValue")

ExitProc:
80  Set session = Nothing
85  Exit Sub

RaiseErrorHandler:
90  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleParameterValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc
End Sub

Public Sub SetzeParameterValue(strParameterName As String, strParameterValue As String)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::SetzeParameterValue")
15  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
20      Call MsgBox("Aufruf f|fffd|r Setzen eines Parametervalues an dieser Stelle nicht erlaubt", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
25      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Sessions aktiv sind")
30  Else
35      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
40      If session Is Nothing Then
45          Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::SetzeParameterValue: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
50      Else
55          Call session.AddParmValue(strParameterName, strParameterValue)
60      End If
65  End If
70  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::SetzeParameterValue")

ExitProc:
75  Set session = Nothing
80  Exit Sub

RaiseErrorHandler:
85  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::SetzeParameterValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
90  Resume ExitProc
End Sub

Public Sub SetzeStandardDrucker(strStandardDrucker As String, intResult As Integer)

5   On Error GoTo RaiseErrorHandler

    ' intResult = 0 - Druckername ist eindeutig und existiert
    '          1 - Druckername ist im System nicht definiert
    '          2 - Druckername ist nicht eindeutig
    Dim sState As PrinterSearchState
    Dim dfltPrinter As String
    Dim normalizedPrinterName As String
    Dim msg As String

10  dfltPrinter = strStandardDrucker
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::SetzeStandardDrucker f|fffd|r Drucker(" & dfltPrinter & ")")
20  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
25      Call MsgBox("Aufruf f|fffd|r Druckersetzen an dieser Stelle nicht erlaubt", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::SetzeStandardDrucker: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Sessions aktiv sind")
35  Else
40      sState = Me.ParentIkolClientApp.PrinterSetupHandler.GetNormalizedPrinterName(dfltPrinter, normalizedPrinterName, False)
45      Select Case sState
            Case ssNoPrinter
50              msg = "Konnte den |fffd|ber Callback-Funktion zu setzenden Drucker " & Chr(34) & strStandardDrucker & Chr(34) & " nicht finden"
55              Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg(msg)
60              intResult = 1
65          Case ssOnePrinter
70              msg = "Session-Standarddrucker |fffd|ber Callback-Funktion zu " & Chr(34) & normalizedPrinterName & Chr(34) & " gesetzt"
75              Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg(msg)
80              Me.ParentIkolClientApp.DefaultPrinterName = normalizedPrinterName
85              intResult = 0
90          Case ssMorePrinter
95              msg = "der zu setzende Drucker " & Chr(34) & dfltPrinter & Chr(34) & " in der Callback-Funktion ist nicht eindeutig"
100             Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg(msg)
105             intResult = 2
110     End Select
115 End If
120 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::SetzeStandardDrucker")


ExitProc:
125 Exit Sub

RaiseErrorHandler:
130 Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::SetzeStandardDrucker" & " in Zeile:" & Erl & vbCrLf, Err.Description
135 Resume ExitProc
End Sub

Public Sub HoleAktuellesIKOLDokument(objWorkingDocument As Document)

5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::HoleAktuellesIKOLDokument")
15  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
20  If session Is Nothing Then
25      Call MsgBox("Angabe des Arbeits-Verzeichnis an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleAktuellesIKOLDokument: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
35  Else
40      Set objWorkingDocument = session.workingDocument
45  End If
50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleAktuellesIKOLDokument")

ExitProc:
55  Set session = Nothing
60  Exit Sub

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleAktuellesIKOLDokument" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Sub

Public Sub HoleArbeitsVerzeichnis(strWorkingDirectory As String)
5   On Error GoTo RaiseErrorHandler
    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::HoleArbeitsVerzeichnis")
15  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
20  If session Is Nothing Then
25      Call MsgBox("Angabe des Arbeits-Verzeichnis an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleArbeitsVerzeichnis: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
35  Else
40      strWorkingDirectory = session.WinworkPath
45  End If
50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleArbeitsVerzeichnis")

ExitProc:
55  Set session = Nothing
60  Exit Sub

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleArbeitsVerzeichnis" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc

End Sub

Public Sub HoleDokumentenVerzeichnis(strDocumentDirectory As String)
5   On Error GoTo RaiseErrorHandler
    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::HoleDokumentenVerzeichnis")
15  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)

20  If session Is Nothing Then
25      Call MsgBox("Angabe des Dokumenten-Verzeichnis an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleDokumentenVerzeichnis: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
35  Else
40      strDocumentDirectory = session.DocDirPath
45  End If
50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleDokumentenVerzeichnis")

ExitProc:
55  Set session = Nothing
60  Exit Sub

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleDokumentenVerzeichnis" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc

End Sub

Public Sub DokumentSpeichernUnter(strOldFileName As String, _
                                  strNewFileName As String, _
                                  intSaveAsMode As Integer, _
                                  intResult As Integer)

5   On Error GoTo RaiseErrorHandler

    'intSaveAsMode = 0 - existierende Dateien werden |fffd|berschrieben
    'intSaveAsMode = 1 - Abbruch bei existierenden Dateien mit Nachricht
    'intSaveAsMode = 2 - Dialogbox f|fffd|r das Speichern als wird angezeigt
    ' R|fffd|ckgabe erfolgt mit intResult:
    ' intResult = 0 Pozedur ohne Fehler beendet
    ' intResult = 1 Fehler beim Speichern aufgetreten
    ' intResult = 2 Document wurde nicht gefunden
    ' intResult = 3 Abbruch durch den Benutzer
    ' im Fall von intResult = 0 enth|fffd|lt strNewFileName den neuen Namen und Pfad des gespeicherten Dokumentes
    Dim saveDoc As TC_Document
    Dim tc_intResult As TC_SessionResult
    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion TC_CallbackHandler::DokumentSpeichernUnter - " & _
                                                          " alter Dateiname: " & Chr(34) & strOldFileName & Chr(34) & _
                                                          " / neuer Dateiname: " & Chr(34) & strNewFileName & Chr(34))
15  intResult = 0
20  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
25  If session Is Nothing Then
30      Call MsgBox("Dokument unter anderem Namen speichern an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
35      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleDokumentenVerzeichnis: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
40      intResult = 2
45  Else
50      Set saveDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(strOldFileName)
55      If saveDoc Is Nothing Then
60          Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleDokumentenVerzeichnis: Dokument " & Chr(34) & strOldFileName & Chr(34) & " wurde nicht gefunden")
65          tc_intResult = tcrFileNotFound
70      Else
75          tc_intResult = Me.ParentIkolClientApp.FileHandler.SaveDocumentAs(saveDoc.Document, strNewFileName, intSaveAsMode, session)
80          If tc_intResult = tcrOK Then
85              Call session.WorkingDocumentNameChanged(strOldFileName)
90          End If
95      End If
100     intResult = 1                                 ' f|fffd|r  alle nicht abgefangenen F|fffd|lle
105     If tc_intResult = tcrOK Then intResult = 0
110     If tc_intResult = tcrSaveError Then intResult = 1
115     If tc_intResult = tcrFileNotFound Then intResult = 2
120     If tc_intResult = tcrWarning Then intResult = 3
125 End If

130 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleDokumentenVerzeichnis")

ExitProc:
135 Set session = Nothing
140 Set saveDoc = Nothing
145 Exit Sub

RaiseErrorHandler:
150 Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::DokumentSpeichernUnter" & " in Zeile:" & Erl & vbCrLf, Err.Description
155 Resume ExitProc
End Sub


'25.04.2016 AL
Public Sub getSchalter_UPAD_FINAL_QUESTION(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.UPadFinalQuestion
ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_UPAD_FINAL_QUESTION" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub


'19.04.2016 AL
Public Sub getSchalter_SIGNPAD(strResult As String)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      strResult = session.SignPad
ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_SIGNPAD" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'16.09.2014 AL
Public Sub getSchalter_RIBBON_MINIMIEREN(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.RibbonMinimieren

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_RIBBON_MINIMIEREN" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'08.10.2014 AL
Public Sub getSchalter_CHECK_FIELDS(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.CheckFields

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_CHECK_FIELDS" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'14.11.2014 AL
Public Sub getSchalter_PRINT_HIDDEN(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.PrintHidden

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_PRINT_HIDDEN" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'14.11.2014 AL
Public Sub getSchalter_PRINT_HIDDEN_ARC(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.PrintHiddenArc

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_PRINT_HIDDEN_ARC" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'17.02.2015 AL
Public Sub getSchalter_SPEICHERN_ALS_SB_ENTFERNEN(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.SpeichernAlsSBentfernen

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_SPEICHERN_ALS_SB_ENTFERNEN" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'04.06.2015 AL
Public Sub getSchalter_SIGN_MULTSELECT(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.SignMultiSelect

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_SIGN_MULTSELECT" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub

'26.02.2018 AL
Public Sub getSchalter_DELTA_SCROLL(boolResult As Boolean)
        Dim session As TC_Session
10      On Error GoTo RaiseErrorHandler
20      Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
30      boolResult = session.DeltaScroll

ExitProc:
40    Set session = Nothing
50    Exit Sub
        
RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::getSchalter_DELTA_SCROLL" & " in Zeile:" & Erl & vbCrLf, Err.Description
70    Resume ExitProc
End Sub


Public Sub HoleVerzeichnisEAkte(strArchivDirectory As String)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion: TC_CallbackHandler::HoleVerzeichnisEAkte")
15  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
20  If session Is Nothing Then
25      Call MsgBox("Angabe des Verzeichnis f|fffd|r die EAkte an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleVerzeichnisEAkte: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")

35  Else
40      strArchivDirectory = session.ArchivDir
45
50  End If
55  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende Callback-Funktion TC_CallbackHandler::HoleVerzeichnisEAkte")

ExitProc:
60  Set session = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleVerzeichnisEAkte" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub

Public Sub SetzeAnwendungsProzessID(longApplicationPID As Long)
5   On Error GoTo RaiseErrorHandler
    Dim session As TC_Session

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion: TC_CallbackHandler::SetzeAnwendungsProzessID")

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Callbackfunktion: SetzeAnwendungsProzessID (" & longApplicationPID & ")")
20  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
25  If session Is Nothing Then
30      Call MsgBox("Setzen der Prozess ID an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
35      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::SetzeAnwendungsProzessID: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
40  Else
45      session.ApplicationPID = longApplicationPID
50  End If
55  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Callback-Funktion: TC_CallbackHandler::SetzeAnwendungsProzessID")

ExitProc:
60  Set session = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::SetzeAnwendungsProzessID" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub


Public Sub SignupMessage(style As VbMsgBoxStyle, SecondCaption As String, msgText As String)
5   Call Me.ParentIkolClientApp.SignUpHandler.DoSignupMsg(style, SecondCaption, msgText)
End Sub


'17.04.2014 AL
'hiermit kann der Name der aktuellen DO-Datei in kundeneigenen Makros bestimmt werden:
'  Application.Run "HoleDoFileName", retValue
Public Sub HoleDoFileName(strDoFileName As String)
5     On Error GoTo RaiseErrorHandler
      Dim session As TC_Session
  
10    strDoFileName = ""

15    Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
20    If session Is Nothing Then
25      Call MsgBox("Abfragen des Namens der DO-Datei an dieser Stelle nicht m|fffd|glich", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CallbackHandler::HoleDoFileName: Callbackfunktion an dieser Stelle nicht m|fffd|glich, da keine Session gefunden wurde")
35    Else
40      strDoFileName = session.DoFullFileName
45    End If

ExitProc:
50    Set session = Nothing
55    Exit Sub

RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_CallbackHandler::HoleDoFileName" & " in Zeile:" & Erl & vbCrLf, Err.Description
65    Resume ExitProc
End Sub

'02.09.2014 AL
Public Function getIndexFromControlId(controlId As String, cc As CommandControls) As Integer
  Dim i As Integer
  Dim idx As Integer

10    i = -1
20    For idx = LBound(cc.controls) To UBound(cc.controls)
30      If UCase(cc.controls(idx).cntrlID) = UCase(controlId) Then
40        i = idx
50      End If
60    Next idx

70    getIndexFromControlId = i
End Function

'02.09.2014 AL
Public Sub SetzeIKOLButtonEigenschaften(controlId As String, _
                                newActionString As String, _
                                toolTip As String, _
                                intResult As Integer)
   
   'MsgBox ("CallbackHandler: " & controlId & vbCr & newActionString & vbCr & toolTip)
   
   Dim session As TC_Session
   Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
   If session Is Nothing Then
     MsgBox ("TC_OITEMPLATE.DOC, Modul: TC_CallbackHandler::SetzeIKOLButtonEigenschaften" & vbCr & "Keine session. Abbruch.")
   Else
     'diese Funktion war wohl von Heiner/Todor vorgesehen - funzt aber nicht
     'Call Me.ParentIkolClientApp.RibbonAndCommandbarRelatives.SetzeIKOLButtonEigenschaften(controlId, newActionString, toolTip, intResult)
     
     'deshalb wie folgt:
     '1. momentane Definitionen der Symbolleiste nach cc
     Dim cc As CommandControls
     cc = session.SessionAssociatedCommandBarOrRibon.CommandControlsDefinitions

     '2. neue Eigenschaft in cc setzen
     'vorher aus controlId den Index bestimmen
     Dim idx As Integer
     idx = getIndexFromControlId(controlId, cc)
     If idx > -1 Then
       cc.controls(idx).action = newActionString
       cc.controls(idx).toolTip = toolTip 'hat keinerlei Auswirkungen - ging auch in OS2 Version 5.2 nicht
       'MsgBox ("ControlId/index/newAction/newTooltip: " & controlId & "/" & idx & "/" & newActionString & "/" & toolTip)
     End If

     '3. cc zur|fffd|ck in die aktuelle Symbolleiste
     session.SessionAssociatedCommandBarOrRibon.CommandControlsDefinitions = cc
   End If
End Sub

'02.09.2014 AL
Public Sub SetzeStandardIKOLCommandbar(intResult As Integer)
  Dim session As TC_Session
   
  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)
  If session Is Nothing Then
    MsgBox ("TC_OITEMPLATE.DOC, Modul: TC_CallbackHandler::SetzeStandardIKOLCommandbar" & vbCr & "Keine session. Abbruch.")
  Else
    Dim nameCommandBar As String
    nameCommandBar = session.SessionAssociatedCommandBarOrRibon.name
    Call session.SessionAssociatedCommandBarOrRibon.SetCommandBarWithDefaultSyntaxActionDefinitions(nameCommandBar, session)
    intResult = 0
  End If
End Sub
Attribute VB_Name = "TC_CommandBarCommands"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Set mobjParentIkolClientApp = Nothing
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_CommandBarCommands.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Sub UnderConstruction(action As String)
5   MsgBox Chr(34) & action & Chr(34) & " under C O N S T R U C T I O N", _
           vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle
End Sub

'---------------------------------------------------------------------------------------
' Prozedur : GetSignature
' Autor    : Todor Vachkov
' Datum    : 18.10.2013
' Zweck    : erfasst Unterschriften, wenn die Unt.felder im Dokument bereits hinterlegt sind --> vor dem Drucken
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: Boolean: Erfolg/Mi|fffd|erfolg
'
' |fffd|bergabeparams:
'
'---------------------------------------------------------------------------------------

Public Function GetSignature() As Boolean

    Dim boolResult As Boolean
    Dim objSession As TC_Session

10    On Error GoTo ErrorHandler

'25.07.2014 AL
20    If Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True Or Me.ParentIkolClientApp.SignUpHandler.MultiSignupStarted = True Then
30      MsgBox ("Das Unterschriften-Modul ist noch ge|fffd|ffnet.")
40      boolResult = False
50      Exit Function
60    End If
'ENDE 25.07.2014 AL

70    boolResult = True

80    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte des Schaltfl|fffd|chen-Makros TC_CommandBarCommands::GetSignature")

90    Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

100   If objSession Is Nothing Then
110     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands::GetSignature - keine aktuelle Session gefunden")
120   Else
130     objSession.tcResult = Me.ParentIkolClientApp.SignUpHandler.SignUp()
140   End If

150   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende des Schaltfl|fffd|chen-Makros TC_CommandBarCommands::GetSignature")

ExitProc:
160   Set objSession = Nothing
170   GetSignature = boolResult
180   Exit Function

ErrorHandler:
190   boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "GetSignature", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'GetSignature'")
200   Resume ExitProc
End Function


'---------------------------------------------------------------------------------------
' Prozedur : GetSignature
' Autor    : Todor Vachkov
' Datum    : 18.10.2013
' Zweck    : erfasst Unterschriften, wenn die Unt.felder im Dokument gerade hinterlegt werden --> beim Editieren
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: Boolean: Erfolg/Mi|fffd|erfolg
'
' |fffd|bergabeparams:
'
'---------------------------------------------------------------------------------------
Public Function GetSignature2() As Boolean

    Dim boolResult As Boolean
    Dim objSession As TC_Session

5   On Error GoTo ErrorHandler

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte des Schaltfl|fffd|chen-Makros TC_CommandBarCommands::GetSignature2")
20  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

25  If objSession Is Nothing Then
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands::GetSignature2 - keine aktuelle Session gefunden")
35  Else
40      Call Me.ParentIkolClientApp.SignUpHandler.EditSignUp
45  End If

50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende des Schaltfl|fffd|chen-Makros TC_CommandBarCommands::GetSignature2")

ExitProc:
55  Set objSession = Nothing
60  GetSignature2 = boolResult
65  Exit Function

ErrorHandler:
70  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "GetSignature2", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'GetSignature2'")
75  Resume ExitProc
End Function


Public Function DeleteSignature() As Boolean
    Dim boolResult As Boolean
    Dim objSession As TC_Session


5   On Error GoTo ErrorHandler
10  boolResult = True
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte des Schaltfl|fffd|chen-Makros - TC_CommandBarCommands::DeleteSignature")

20  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
25  If objSession Is Nothing Then
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands:DeleteSignature: - keine aktuelle Session gefunden")
35  Else
40      Call Me.ParentIkolClientApp.SignUpHandler.DeleteSignUp
45  End If
50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands::DeleteSignature: DeleteSignature under Construction")
55  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende des Schaltfl|fffd|chen-Makros - TC_CommandBarCommands::DeleteSignature")

ExitProc:
60  DeleteSignature = boolResult
65  Exit Function

ErrorHandler:
70  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "DeleteSignature", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'DeleteSignature'")
75  Resume ExitProc

End Function

Public Function SaveActiveDocumentAs() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler

    Dim objSession As TC_Session
    Dim objTcDoc As TC_Document
    Dim intDlgReturn As Integer
    Dim tcResult As TC_SessionResult
    Dim strNewFileName As String

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro - TC_CommandBarCommands::SaveActiveDocumentAs")
20  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

25  If objSession Is Nothing Then
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands::SaveActiveDocumentAs: keine aktuelle Session gefunden")
35  Else
        ' markieren, dass ein Save-Button der OSS2.0 gedr|fffd|ckt wurde und nicht einer der Word-eigenen
        ' => das DocumentBeforeSave-Event wird nicht versuchen das Dokument in die Verwaltung zu |fffd|bernehmen
40      objSession.SaveNotTriggeredByWordButtons = True

45      If Not objSession.workingDocument Is Nothing Then
50          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocumentAs: das Verzeichnis zum Speichern ist " & _
                                                                   Chr(34) & objSession.SaveAsDirectory & Chr(34), objSession)

            ' die Dialogbox zum Speichern unter ... anzeigen, die Benutzer-Dateinamen-Eingabe abfangen aber moch nicht speichern
55          With Dialogs(wdDialogFileSaveAs)
60              If objSession.SaveAsDirectory <> vbNullString Then
65                  If Me.ParentIkolClientApp.FileHandler.FolderExist(objSession.SaveAsDirectory) Then
70                      .name = objSession.SaveAsDirectory
75                  Else
80                      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocumentAs: voreingestelltes Verzeichnis zum Speichern kann nicht ausgew|fffd|hlt werden, da es nicht existiert", objSession)
85                  End If
90              End If
95              intDlgReturn = .Display
100             strNewFileName = .name
105         End With

110         If (strNewFileName) <> vbNullString And (intDlgReturn < 0) Then    '-1 OK, -2 Schlie|fffd|en
115             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocumentAs: Datei wird gespeichert unter " & _
                                                                       Chr(34) & strNewFileName & Chr(34), objSession)

120             Set objTcDoc = objSession.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(objSession.workingDocument.FullName)

125             objSession.tcResult = Me.ParentIkolClientApp.FileHandler.SaveAsForTC_Document(objTcDoc, strNewFileName, objSession)
130         Else
135             If strNewFileName = vbNullString Then
140                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocumentAs: Aufruf kam mit leerem Dateinamen zur|fffd|ck", objSession)
145             End If
150             If intDlgReturn >= 0 Then
155                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocumentAs: Dialog wurde abgebrochen, Returncode=" & intDlgReturn, objSession)
160             End If
165         End If
170     End If
175 End If

ExitProc:
180 SaveActiveDocumentAs = boolResult
185 Set objSession = Nothing
190 Set objTcDoc = Nothing
195 Exit Function

ErrorHandler:
200 boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "SaveActiveDocumentAs", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'SaveActiveDocumentAs'")
205 Resume ExitProc

End Function

Public Function SaveActiveDocument() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler

    Dim objSession As TC_Session
    Dim tcResult As TC_SessionResult
    Dim objTcDoc As TC_Document

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro SaveActiveDocument")

20  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

25  If objSession Is Nothing Then
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands::SaveActiveDocument: keine aktive Session gefunden")
35  Else

        ' markieren, dass ein Save-Button der OSS2.0 gedr|fffd|ckt wurde und nicht einer der Word-eigenen
        ' => das DocumentBeforeSave-Event wird nicht versuchen das Dokument in die Verwaltung zu |fffd|bernehmen
40      objSession.SaveNotTriggeredByWordButtons = True

45      Set objTcDoc = objSession.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(ActiveDocument.FullName)

50      If Not objTcDoc Is Nothing Then
55          If objTcDoc.openReadOnly Then
60              Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Das Dokument wurde durch die Befehlsfolge im Modus 'Nur Lesen' ge|fffd|ffnet und kann nicht gespeichert werden", objSession)
65          Else
70              With objTcDoc.Document
75                  Call Me.ParentIkolClientApp.DocumentHandler.RestoreIncludeFields(objTcDoc.Document, objTcDoc.OpenWithHeaderReplace, objSession)

80                  Me.ParentIkolClientApp.SignUpHandler.UpdateSignFields (False)

85                  tcResult = Me.ParentIkolClientApp.FileHandler.SaveDocumentAs(objTcDoc.Document, vbNullString, 0, objSession)    ' da die Serienbrieffunktion entfernt wird

90                  If objTcDoc.FullName <> objTcDoc.Document.FullName Then
95                      objTcDoc.FullName = objTcDoc.Document.FullName
100                     objTcDoc.DocumentName = objTcDoc.Document.name
105                     objTcDoc.IsMailMergeDoc = Not (objTcDoc.Document.MailMerge.MainDocumentType = wdNotAMergeDocument)
110                 End If

115                 If tcResult = tcrOK Then
120                     If objSession.ServerName <> vbNullString Then

125                         If MsgBox("Das Dokument wurde auf Ihrem PC gespeichert." & vbLf & _
                                      "Soll das Dokument auch auf dem Server aktualisiert werden ?", _
                                      vbYesNo + vbInformation, _
                                      .name) = vbYes Then
130                             Call Me.ParentIkolClientApp.FileHandler.UploadFileToServer("TC_CommandBarCommands::SaveActiveDocument", objTcDoc, objSession)
135                         End If
140                     Else
145                         If objSession.ShowWarnings Then
150                             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocument: Das Dokument wurde auf dem PC gespeichert", objSession)
155                             Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Das Dokument wurde auf Ihrem PC gespeichert", objSession)
160                         End If
165                     End If
                        ' Umleitung auf das Schaltfl|fffd|chenmakro des Buttons "Beenden"
170                     Call Me.DoCloseAndEnd(objSession)
175                 Else
180                     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::SaveActiveDocument: Abbruch des Speichervorgangs ", objSession)
185                 End If
190             End With
195         End If
200     End If
205 End If
210 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro - TC_CommandBarCommands::SaveActiveDocument")

ExitProc:
215 SaveActiveDocument = boolResult
220 Set objTcDoc = Nothing
225 Set objSession = Nothing
230 Exit Function

ErrorHandler:
235 boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "SaveActiveDocument", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'SaveActiveDocument'")
240 Resume ExitProc

End Function

Public Function DeleteActiveDocument() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler

    Dim objSession As TC_Session
    Dim strDocName As String
    Dim strDocPath As String
    Dim tcResult As TC_SessionResult
    Dim objTcDoc As TC_Document

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::DeleteActiveDocument")
20  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

25  If objSession Is Nothing Then
30      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_CommandBarCommands::DeleteActiveDocument: keine aktive Session gefunden")
35  Else
40      Set objTcDoc = objSession.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(ActiveDocument.FullName)

45      If Not objTcDoc Is Nothing Then
50          If objSession.ServerName <> vbNullString Then

55              If MsgBox("Soll das Dokument wirklich auf dem Server zum L|fffd|schen markiert werden ?" & vbLf & _
                          "Nach einer Neuanmeldung wird diese |fffd|nderung auf allen Clients wirksam", _
                          vbYesNo + vbQuestion, _
                          objTcDoc.Document.name) = vbYes Then

60                  strDocName = objTcDoc.Document.name
65                  strDocPath = objTcDoc.Document.Path

70                  objSession.InDeleteFile = True

                    ' Umleitung auf das Schaltfl|fffd|chenmakro des Buttons "Beenden"
75                  Call Me.DoCloseAndEnd(objSession)
80                  objSession.InDeleteFile = False
85                  Call Me.ParentIkolClientApp.FileHandler.DeleteFileOnServer("TC_CommandBarCommands::DeleteActiveDocument", strDocPath, strDocName, objSession)

90                  If Not objSession.WeStillInProcessing Then
95                      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::DeleteActiveDocument: Beende die Sesion mit TC_IkolClientApp::CloseSession", objSession)

100                     If Not objSession.SessionAssociatedCommandBarOrRibon Is Nothing Then
105                         Set objSession.SessionAssociatedCommandBarOrRibon = Nothing
110                         Me.ParentIkolClientApp.RibbonVisible = False
115                         Application.Run "Symbolbar.HideCommandBarOnSessionClose"
120                     End If

125                     objSession.MaximizeWordAfterSessionClose = False
130                     Call Me.ParentIkolClientApp.CloseSession(objSession, True, "TC_CommandBarCommands:DeleteActiveDocument")
135                 End If
140             Else
145                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::DeleteActiveDocument: Abbruch des L|fffd|schvorgangs ", objSession)
150             End If
155         Else
160             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::DeleteActiveDocument: Die Aktion '" & objSession.MacroAction & "' enth|fffd|lt keine Server-Definition", objSession)
165             Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Die Aktion '" & objSession.MacroAction & "' enth|fffd|lt keine Server-Definition", objSession)
170         End If
175     End If
180 End If

185 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::DeleteActiveDocument")

ExitProc:
190 DeleteActiveDocument = boolResult
195 Set objTcDoc = Nothing
200 Set objSession = Nothing
205 Exit Function

ErrorHandler:
210 boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "DeleteActiveDocument", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'DeleteActiveDocument'")
215 Resume ExitProc

End Function

' =============================================================================
' Prozeduren, die auf die Buttons der Symbolleiste reagieren
' =============================================================================
Public Function DoCloseAndEnd(objSession As TC_Session, Optional boolCalledByRedQuitButton As Boolean = False) As Boolean
10    On Error GoTo ErrorHandler
    Dim boolResult As Boolean

    Dim tcResult As TC_SessionResult
    Dim strDocName As String


'08.07.2014 AL
20    If Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True Or Me.ParentIkolClientApp.SignUpHandler.MultiSignupStarted = True Then
30      MsgBox ("Das Unterschriften-Modul ist noch ge|fffd|ffnet.")
40      boolResult = False
50      Exit Function
60    End If
'ENDE 08.07.2014 AL

70    boolResult = True

80    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Schaltfl|fffd|chen-Makro TC_CommandBarCommands::DoCloseAndEnd", objSession)

90    If Not objSession.workingDocument Is Nothing Then
100     strDocName = objSession.workingDocument.FullName
110     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_CommandBarCommands::DoCloseAndEnd schlie|fffd|e Dokument '" & strDocName & "'", objSession)
120     tcResult = Me.ParentIkolClientApp.FileHandler.CloseDocumentByName(strDocName, objSession, boolCalledByRedQuitButton)
130   End If
140   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Beende Schaltfl|fffd|chen-Makro TC_CommandBarCommands::DoCloseAndEnd", objSession)

'16.07.2014 AL
'drvword.exe ab Version 5.2.0.16 macht immer neue Word-Instanz auf
'Deshalb muss ab nun Word komplett geschlossen werden.
'Durch das if funktioniert es auch mit einer |fffd|lteren Version von drvword.exe
Dim anzDocs As Integer
anzDocs = Application.Documents.count
'MsgBox (anzDocs)
If anzDocs = 0 Then
  'Application.Quit SaveChanges:=False '18.07.2014 AL ersetzt durch winapi-Funktion ExitProcess
End If
'ENDE 16.07.2014 AL

ExitProc:
150   DoCloseAndEnd = boolResult
160   Exit Function

ErrorHandler:
170   boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "DoCloseAndEnd", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'DoCloseAndEnd'")
180   Resume ExitProc

End Function

Public Function GeneralPrintAndArc(intPrintCopiesCount As Integer, intEAkteCopiesCount As Integer, ByVal boolToClose As Boolean) As Boolean
    Dim boolResult As Boolean

10    On Error GoTo ErrorHandler


    Dim objSession As TC_Session
    Dim tcResult As TC_SessionResult
    Dim strPrinterName As String
    Dim MsgBoxResult As VbMsgBoxResult


20    boolResult = True

30    tcResult = tcrOK

40    Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
50    If Not objSession Is Nothing Then
60      If Not Me.ParentIkolClientApp.SignUpHandler.MissingSignUps() Then
70          If intPrintCopiesCount > 0 Then
80              If objSession.PrinterToUse = "?" Then
90                  strPrinterName = objSession.PrinterToUse
100                 tcResult = Me.ParentIkolClientApp.PrintHandler.SetPrinterToUse(strPrinterName, objSession)
110                 If tcResult <> tcrOK Then
120                     GoTo ExitProc
130                 End If
140             End If
                
150             tcResult = Me.ParentIkolClientApp.PrintHandler.PrintDocuments(intPrintCopiesCount, objSession.PrinterToUse, 0, 0, False, 2, objSession)
160         End If

170         If tcResult = tcrOK Then
180             If intEAkteCopiesCount > 0 Then
190                 If Me.ParentIkolClientApp.PrintHandler.TestArchivEnvironment(objSession, "TC_CommandBarCommands::GeneralPrintAndArc") Then

200                     If Not objSession.DocumentAlreadySentToeAkte Then
210                         objSession.DocumentAlreadySentToeAkte = True
220                     Else
                            'weil beim SignoTec ST_ALPHA zur Anzeige neu gedruckt wird, w|fffd|rde immer folgende MsgBox kommen
230                         If objSession.SignPad <> "ST_ALPHA" And objSession.SignPad <> "ST_DELTA" Then '19.04.2016 AL nur if neu
                            
240                           MsgBoxResult = Me.ParentIkolClientApp.LogfileHandler.DispayYNmsgBox( _
                                             "Sie haben dieses Dokument auf dem Archivdrucker bereits gedruckt. Es folgt keine Ablage in IKOL-eAkte." & _
                                             vbCrLf & "M|fffd|chten Sie fortfahren?")
250                           If MsgBoxResult = vbNo Then
260                               Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                                       "TC_CommandBarCommands::GeneralPrintAndArc: Dieses Dokument wurde auf dem Archivdrucker bereits gedruckt. Es folgt keine Ablage in IKOL-eAkte. Abbruch des Drucks auf dem Archivdrucker auf Wunsch vom Benutzer", objSession)
270                               GoTo ExitProc
280                           Else
290                               Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                                       "TC_CommandBarCommands::GeneralPrintAndArc: Dieses Dokument wurde auf dem Archivdrucker bereits gedruckt. Es folgt keine Ablage in IKOL-eAkte. Auf Wunsch vom Benutzer weitergedruckt.", objSession)
300                           End If

310                         End If '19.04.2016 AL nur if neu

320                     End If

330                     tcResult = Me.ParentIkolClientApp.PrintHandler.PrintDocuments(intEAkteCopiesCount, objSession.Printer_eAkte, 0, 0, True, 2, objSession)

340                     If tcResult = tcrOK Then
350                         tcResult = Me.ParentIkolClientApp.PrintHandler.SynchronisePrint_eAkte(objSession)
360                     End If
370                 Else
380                     tcResult = tcreAkteError
390                 End If
400             End If
410         End If

            ' nach dem Drucken beenden, sonst auf dem Dokument bleiben
420         If boolToClose Then
430             If tcResult = tcrOK Then
                    ' Umleitung auf das Schaltfl|fffd|chenmakro des Buttons "Beenden"
440                 Call Me.DoCloseAndEnd(objSession)
450             End If
460         End If
470     End If

480   End If

ExitProc:
490   GeneralPrintAndArc = boolResult
500   Set objSession = Nothing
510   Exit Function

ErrorHandler:
520   Err.Raise Err.Number, Err.Source & "->" & "TC_CommandBarCommands::GeneralPrintAndArc in Zeile:" & Erl & vbCrLf, Err.Description
530   Resume ExitProc
End Function


Public Function PrintActiveDocument() As Boolean
    ' Drucken mit Beenden der Office-Schnittstelle
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocument")
20  boolResult = Me.GeneralPrintAndArc(1, 0, True)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocument")

ExitProc:
30  PrintActiveDocument = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintActiveDocument", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintActiveDocument'")
45  Resume ExitProc

End Function

Public Function PrintActiveDocument2() As Boolean
    Dim boolResult As Boolean

    ' Drucken OHNE Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocument2")
20  boolResult = Me.GeneralPrintAndArc(1, 0, False)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocument2")

ExitProc:
30  PrintActiveDocument2 = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintActiveDocument2", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintActiveDocument2'")
45  Resume ExitProc
End Function


Public Function PrintActiveDocumentTwice() As Boolean
    Dim boolResult As Boolean

    ' Drucken mit Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocumentTwice")
20  boolResult = Me.GeneralPrintAndArc(2, 0, True)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocumentTwice")

ExitProc:
30  PrintActiveDocumentTwice = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintActiveDocumentTwice", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintActiveDocumentTwice'")
45  Resume ExitProc

End Function

Public Function PrintActiveDocumentTwice2() As Boolean
    Dim boolResult As Boolean

    ' Drucken OHNE Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocumentTwice2")
20  boolResult = Me.GeneralPrintAndArc(2, 0, False)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintActiveDocumentTwice2")

ExitProc:
30  PrintActiveDocumentTwice2 = boolResult
35  Exit Function

ErrorHandler:

40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintActiveDocumentTwice2", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintActiveDocumentTwice2'")
45  Resume ExitProc

End Function

Public Function PrintAndArcActiveDocument() As Boolean
    Dim boolResult As Boolean

    ' Drucken mit Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocument")
20  boolResult = Me.GeneralPrintAndArc(1, 1, True)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocument")

ExitProc:
30  PrintAndArcActiveDocument = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintAndArcActiveDocument", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintAndArcActiveDocument'")
45  Resume ExitProc

End Function

Public Function PrintAndArcActiveDocument2() As Boolean
    Dim boolResult As Boolean

    ' Drucken OHNE Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocument2")
20  boolResult = Me.GeneralPrintAndArc(1, 1, False)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocument2")

ExitProc:
30  PrintAndArcActiveDocument2 = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintAndArcActiveDocument2", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintAndArcActiveDocument2'")
45  Resume ExitProc

End Function


Public Function PrintAndArcActiveDocumentTwice() As Boolean
    Dim boolResult As Boolean

    ' Drucken mit Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocumentTwice")
20  boolResult = Me.GeneralPrintAndArc(2, 1, True)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocumentTwice")

ExitProc:
30  PrintAndArcActiveDocumentTwice = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintAndArcActiveDocumentTwice", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintAndArcActiveDocumentTwice'")
45  Resume ExitProc

End Function

Public Function PrintAndArcActiveDocumentTwice2() As Boolean
    Dim boolResult As Boolean

    ' Drucken OHNE Beenden der Office-Schnittstelle
5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocumentTwice2")
20  boolResult = Me.GeneralPrintAndArc(2, 1, False)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintAndArcActiveDocumentTwice2")

ExitProc:
30  PrintAndArcActiveDocumentTwice2 = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintAndArcActiveDocumentTwice2", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintAndArcActiveDocumentTwice2'")
45  Resume ExitProc

End Function


Public Function ArcActiveDocument() As Boolean
    Dim boolResult As Boolean

    ' Drucken mit Beenden der Office-Schnittstelle

5   On Error GoTo ErrorHandler
10  boolResult = True


15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::ArcActiveDocument")
20  boolResult = Me.GeneralPrintAndArc(0, 1, True)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::ArcActiveDocument")

ExitProc:
30  ArcActiveDocument = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "ArcActiveDocument", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'ArcActiveDocument'")
45  Resume ExitProc

End Function

Public Function ArcActiveDocument2() As Boolean
    Dim boolResult As Boolean

    ' Drucken OHNE Beenden der Office-Schnittstelle

5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::ArcActiveDocument2")
20  boolResult = Me.GeneralPrintAndArc(0, 1, False)
25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::ArcActiveDocument2")

ExitProc:
30  ArcActiveDocument2 = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "ArcActiveDocument2", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'ArcActiveDocument2'")
45  Resume ExitProc

End Function


Public Function TCInfo() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::TCInfo")
20  MsgBox "Version : " & Me.ParentIkolClientApp.Os2Version & vbLf & _
           "Build   : " & Me.ParentIkolClientApp.BuildVersion & vbLf & _
           "|fffd|Telecomputer GmbH " & Format(Now(), "yyyy"), _
           vbInformation, Me.ParentIkolClientApp.MsgBoxTitle

25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::TCInfo")

ExitProc:
30  TCInfo = boolResult
35  Exit Function

ErrorHandler:
40  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "TCInfo", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'TCInfo'")
45  Resume ExitProc

End Function

Public Function CloseActiveDocument() As Boolean
    Dim boolResult As Boolean
    Dim objSession As TC_Session
5   On Error GoTo ErrorHandler

10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CloseActiveDocument")
20  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
25  If Not objSession Is Nothing Then
30      Call Me.DoCloseAndEnd(objSession, True)
35  End If

40  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CloseActiveDocument")


ExitProc:
45  CloseActiveDocument = boolResult
50  Set objSession = Nothing
55  Exit Function

ErrorHandler:
60  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "CloseActiveDocument", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'CloseActiveDocument'")
65  Resume ExitProc

End Function

Public Function PrintWithSetup() As Boolean
    Dim boolResult As Boolean
    Dim objSession As TC_Session
    Dim tcResult As TC_SessionResult

5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintWithSetup")

20  tcResult = tcrOK
25  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
30  If Not objSession Is Nothing Then
35      tcResult = Me.ParentIkolClientApp.PrintHandler.PrintDocumentsWithSetup(objSession)
40      If tcResult = tcrOK Then
45          Call Me.DoCloseAndEnd(objSession)
50      End If
55  End If

60  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::PrintWithSetup")

ExitProc:
65  PrintWithSetup = boolResult
70  Set objSession = Nothing
75  Exit Function

ErrorHandler:
80  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "PrintWithSetup", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'PrintWithSetup'")
85  Resume ExitProc

End Function

Public Function CustomizeActionA() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler

10  boolResult = True
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CustomizeActionA")
20  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Msg-Box: Benutzerdefinierte Funktion 1 wurde nicht festgelegt")
25  Call Me.CustomizeActionError("1")
30  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CustomizeActionA")

ExitProc:
35  CustomizeActionA = boolResult
40  Exit Function

ErrorHandler:
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "CustomizeActionA", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'CustomizeActionA'")
50  Resume ExitProc

End Function

Public Function CustomizeActionB() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CustomizeActionB")
20  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Msg-Box: Benutzerdefinierte Funktion 2 wurde nicht festgelegt")
25  Call Me.CustomizeActionError("2")
30  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CustomizeActionB")

ExitProc:
35  CustomizeActionB = boolResult
40  Exit Function

ErrorHandler:
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "CustomizeActionB", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'CustomizeActionB'")
50  Resume ExitProc

End Function

Public Function CustomizeActionC() As Boolean
    Dim boolResult As Boolean

5   On Error GoTo ErrorHandler
10  boolResult = True

15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CustomizeActionC")
20  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Msg-Box: Benutzerdefinierte Funktion 3 wurde nicht festgelegt")
25  Call Me.CustomizeActionError("3")
30  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende das Schaltfl|fffd|chen-Makro TC_CommandBarCommands::CustomizeActionC")

ExitProc:
35  CustomizeActionC = boolResult
40  Exit Function

ErrorHandler:
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_CommandBarCommands", "CustomizeActionC", , _
                                        "Ausf|fffd|hrung vom Button-Makro: 'CustomizeActionC'")
50  Resume ExitProc

End Function

Public Sub CustomizeActionError(actionNumber As String)
5   MsgBox "Benutzerdefinierte Funktion " & actionNumber & " wurde nicht festgelegt", _
           vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle
End Sub
Attribute VB_Name = "TC_Commandbar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mstrCommandBarName As String
Private mtypeCommandBarDefinition As CommandControls
Private mobjParentSession As TC_Session

Public Property Get ParentSession() As TC_Session
5   Set ParentSession = mobjParentSession
End Property

Public Property Set ParentSession(objParentSession As TC_Session)
5   If mobjParentSession Is Nothing Then
10      Set mobjParentSession = objParentSession
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_Commandbar::ParentSession", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Private Sub Class_Initialize()
5   mstrCommandBarName = vbNullString
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   mstrCommandBarName = vbNullString

10  If Not mobjParentSession Is Nothing Then
15      Set mobjParentSession = Nothing
20  End If
End Sub

Public Property Get name() As String
5   name = mstrCommandBarName
End Property

Public Property Let name(strName As String)
5   mstrCommandBarName = strName
End Property

Public Property Get CommandControlsDefinitions() As CommandControls
5   CommandControlsDefinitions = mtypeCommandBarDefinition
End Property

Public Property Let CommandControlsDefinitions(typeCommandControls As CommandControls)
5   mtypeCommandBarDefinition = typeCommandControls
End Property

Public Sub SetCommandBarWithDefaultSyntaxActionDefinitions(strCommandBarName As String, session As TC_Session)

5   On Error GoTo RaiseErrorHandler
    ' die Aktionen hinter den Buttons werden zu den Standardwerten, so wie sie in session.Syntax.GetCommandBarDefinition
    ' definiert sind, gesetzt
    Dim idx As Integer

10  Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_Commandbar::SetCommandBarWithDefaultSyntaxActionDefinitions: Setzt die Symbolleiste zu '" & _
         strCommandBarName & "' mit den Standardaktionsdefinitionen laut Syntax", session)

15  Me.name = strCommandBarName
20  Me.CommandControlsDefinitions = session.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription.GetCommandBarDefinition(strCommandBarName)

25  Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll(Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedText("index", 7) & _
                                                                                                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedText("Visible", 9) & _
                                                                                                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedText("Enabled", 9) & _
                                                                                                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedText("Btn_ID", 20) & _
                                                                                                 "Action", session)

30  For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
35      With Me.CommandControlsDefinitions.controls(idx)

40          Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedText(vbNullString & idx, 7) & _
                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedYN(.visible, 9) & _
                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedYN(.enabled, 9) & _
                 Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.TabbedText(.cntrlID, 20) & _
                 .action, session)
45      End With
50  Next idx

ExitProc:
55  Exit Sub

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::SetCommandBarWithDefaultSyntaxActionDefinitions" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc
End Sub

Public Function SetAction(controlId As String, _
                          newActionString As String, _
                          session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
    Dim idx As Integer
10  boolResult = False
15  For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
20      With Me.CommandControlsDefinitions.controls(idx)
25          If UCase(.cntrlID) = UCase(controlId) Then
30              boolResult = True
35              .action = newActionString
40              GoTo ExitProc
45          End If
50      End With
55  Next idx

ExitProc:
60  SetAction = boolResult
65  Exit Function

RaiseErrorHandler:
70  boolResult = False
75  Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::SetAction" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc

End Function

Public Function SetToolTip(controlId As String, _
                           newToolTipString As String, _
                           session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
    Dim idx As Integer
10  boolResult = False
15  For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
20      With Me.CommandControlsDefinitions.controls(idx)
25          If UCase(.cntrlID) = UCase(controlId) Then
30              boolResult = True
35              .toolTip = newToolTipString
40              GoTo ExitProc
45          End If
50      End With
55  Next idx


ExitProc:
60  SetToolTip = boolResult
65  Exit Function

RaiseErrorHandler:
70  boolResult = False
75  Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::SetToolTip" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Function

Public Function GetVisible(controlId As String, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim idx As Integer
    Dim boolResult As Boolean

10  boolResult = True

15  For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
20      With Me.CommandControlsDefinitions.controls(idx)
25          If UCase(.cntrlID) = UCase(controlId) Then
30              boolResult = .visible
35              GoTo ExitProc
40          End If
45      End With
50  Next idx

ExitProc:
55  GetVisible = boolResult
60  Exit Function

RaiseErrorHandler:
65  boolResult = False
70  Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::GetVisible" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Function

Public Function GetEnabled(controlId As String, session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim idx As Integer
    Dim boolResult As Boolean

10  boolResult = True

15  For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
20      With Me.CommandControlsDefinitions.controls(idx)
25          If UCase(.cntrlID) = UCase(controlId) Then
30              boolResult = .enabled
35              GoTo ExitProc
40          End If
45      End With
50  Next idx

ExitProc:
55  GetEnabled = boolResult
60  Exit Function

RaiseErrorHandler:
65  boolResult = False
70  Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::GetEnabled" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc

End Function

Public Function GetToolTip(controlId As String, session As TC_Session) As String
5   On Error GoTo RaiseErrorHandler

    Dim strResult As String
    Dim idx As Integer

10  strResult = vbNullString

15  For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
20      With Me.CommandControlsDefinitions.controls(idx)
25          If UCase(.cntrlID) = UCase(controlId) Then
30              strResult = .toolTip
35              GoTo ExitProc
40          End If
45      End With
50  Next idx

ExitProc:
55  GetToolTip = strResult
60  Exit Function

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::GetToolTip" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc

End Function

Public Function DoAction(controlId As String, session As TC_Session) As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim idx As Integer
    Dim strButtonMacroToRun As String
    Dim callExtern As String '02.09.2014 AL
    Dim boolOnActionSuccess As Boolean
    Dim externCalled As Boolean '02.09.2014 AL
    
20    boolOnActionSuccess = False
30    externCalled = False '02.09.2014 AL
40    strButtonMacroToRun = vbNullString

50    Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start TC_Commandbar::DoAction f|fffd|r Button [" & controlId & "]", session)

60    For idx = LBound(Me.CommandControlsDefinitions.controls) To UBound(Me.CommandControlsDefinitions.controls)
70      With Me.CommandControlsDefinitions.controls(idx)
80          If UCase(.cntrlID) = UCase(controlId) Then
90              strButtonMacroToRun = .action
100             callExtern = .action
110             strButtonMacroToRun = Right(strButtonMacroToRun, Len(strButtonMacroToRun) - InStrRev(strButtonMacroToRun, "."))
120             Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC_Commandbar::DoAction f|fffd|r Button [" & controlId & "] ist die auszuf|fffd|hrende Aktion [TC_CommandBarCommands::" & strButtonMacroToRun & "]", session)
                
                '02.09.2014 AL
                'es kommt vor, dass die Aktionen auf den Buttons umgeschrieben wurden und somit ist eine Funktion aus owi.dot aufzurufen
                'in diesem Falle wird CallByName - womit die normalen Subs aus TC_OITEMPLATE gerufen werden - einen Fehler werfen
                'deshalb gehe wie folgt vor:
                '1. versuche CallByName(...)
                '2. wird durch 1. ein Fehler geworfen --> versuche Application.Run(.action)
                
130             On Error GoTo tryWithExternCall '02.09.2014 AL
            
                ' bei Fehler kommt nach der Ausf|fffd|hrung des hinterlegten Makros False zur|fffd|ck
140             boolOnActionSuccess = CallByName(Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.CommandBarCommands, strButtonMacroToRun, VbMethod)
Weiter: '02.09.2014 AL
150             On Error GoTo RaiseErrorHandler '02.09.2014 AL
160             If externCalled = False Then '02.09.2014 AL
170               If boolOnActionSuccess Then
180                   Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                           "Ende TC_Commandbar::DoAction: Aktion zum Button [" & controlId & "] erfolgreich durchgef|fffd|hrt", session)
190               Else
200                   Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                           "Ende TC_Commandbar::DoAction: Zum Button [" & controlId & "] ist ein Fehler aufgetreten", session)
210               End If
220             End If '02.09.2014 AL
                
                '02.09.2014 AL
230             If externCalled = True Then
240               Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                           "Ende TC_Commandbar::DoAction: Aktion zum Button [" & controlId & "] durchgef|fffd|hrt mit call von: " & callExtern, session)
250             End If

260             GoTo ExitProc
270         End If
280     End With
290   Next idx

300   Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende TC_Commandbar::DoAction: keine Aktion gefunden", session)
ExitProc:
310   Exit Function

RaiseErrorHandler:
320   Err.Raise Err.Number, Err.Source & "->" & "TC_Commandbar::DoAction" & " in Zeile:" & Erl & vbCrLf, Err.Description
330   Resume ExitProc

tryWithExternCall: '02.09.2014 AL
340     externCalled = True
350     Application.Run (callExtern)
360     Resume Weiter

End Function
Attribute VB_Name = "TC_ControlHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_LogfileHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub


Public Function CallPgmExtern(commandLine As String, session As TC_Session) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim wshshell
    Dim tcResult As TC_SessionResult

10  Set wshshell = CreateObject("WScript.Shell")
15  wshshell.Run (commandLine)
20  tcResult = tcrOK

ExitProc:
25  CallPgmExtern = tcResult
30  Exit Function

RaiseErrorHandler:
35  tcResult = tcrCallError
40  Err.Raise Err.Number, Err.Source & "->" & "TC_ControlHandler::CallPgmExtern" & " in Zeile:" & Erl & vbCrLf, Err.Description & _
                                                                                                                "->" & "Fehler beim Ausf|fffd|hren des externen Programms [" & commandLine & "] aufgetreten"
45  Resume ExitProc

End Function

Public Function CallMakroExtern(strVbaProject As String, _
                                strMakroName As String, _
                                boolUnload As Boolean, _
                                session As TC_Session) As TC_SessionResult
    Dim Addin As Addin
    Dim boolAlreadyInstalled As Boolean

5   On Error GoTo RaiseErrorHandler

10  If strVbaProject <> vbNullString Then
15      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Laden des VBA-Projektes " & Chr(34) & strVbaProject & Chr(34), session)

20      boolAlreadyInstalled = False

25      For Each Addin In AddIns
30          If UCase(Addin.Path & Application.PathSeparator & Addin.name) = UCase(strVbaProject) Then
35              If Addin.Installed = True Then
40                  boolAlreadyInstalled = True
45                  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("VBA-Projekt " & Chr(34) & strVbaProject & Chr(34) & " ist bereits geladen", session)
50                  Exit For
55              End If
60          End If
65      Next Addin

70      If Not boolAlreadyInstalled Then
75          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("VBA-Projekt " & Chr(34) & strVbaProject & Chr(34) & " wird geladen", session)
80          AddIns.Add strVbaProject
85          AddIns(strVbaProject).Installed = True
90      End If
95  Else
100     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Es wurde kein VBA-Projekt |fffd|bergeben, Office-Schnittstelle setzt ein geladenes Makroprojekt voraus.", session)
105 End If

110 If strMakroName <> vbNullString Then
115     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starten des Makros " & Chr(34) & strMakroName & Chr(34), session)

120     Application.Run macroName:=strMakroName

125     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Makro " & Chr(34) & strMakroName & Chr(34) & " ist beendet", session)
130 Else

135     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("da kein Makro definiert ist, wird auch kein Makro gerufen", session)

140 End If

145 If boolUnload Then
150     If strVbaProject <> vbNullString Then
155         AddIns(strVbaProject).Delete
160         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("VBA-Projekt " & Chr(34) & strVbaProject & Chr(34) & " wieder entladen", session)
165     End If
170 End If

ExitProc:
175 CallMakroExtern = tcrOK
180 Exit Function

RaiseErrorHandler:
185 CallMakroExtern = tcrCallError
190 Err.Raise Err.Number, Err.Source & "->" & "TC_ControlHandler::CallMakroExtern" & " in Zeile:" & Erl & vbCrLf, Err.Description & "->" & _
                                                                                                                  "Fehler beim Ausf|fffd|hren des gerufenden Makros " & Chr(34) & strMakroName & Chr(34) & " in der VBA-Projekt-Datei " & Chr(34) & strVbaProject & Chr(34)
195 Resume ExitProc
End Function

Public Sub ProtokollUebergabeDirectory(comment As String, _
                                       value As String, _
                                       isDir As Boolean, _
                                       session As TC_Session)
5   On Error GoTo RaiseErrorHandler

    Dim text As String
    Dim valuestr As String

10  text = Mid(comment & ":" & Space(28), 1, 28)
15  valuestr = value
20  If isDir Then
25      If value = Application.PathSeparator Or value = vbNullString Then
30          valuestr = Chr(34) & Chr(34) & "  (leerer Parameter)"
35      End If
40  End If
45  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(Space(7) & text & valuestr, session)

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_ControlHandler::ProtokollUebergabeDirectory" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Sub
Attribute VB_Name = "TC_Document"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentManagedTCDocumentsContainer As TC_DocumentsContainer
Private mobjManagedTCSignaturesContainer As TC_SignaturesContainer


Private mobjDocument As Document                      ' das Word-Dokument hinter dem TC_Dokument
Private mstrFullName As String                        ' Dokumentenpfad und - name
Private mstrDocName As String                         ' Dokumentenname
Private mstrDataFile As String                        ' die Datenquelle (DO-Datei)
Private mboolIsMailMergeDoc As Boolean                ' ist das TC_Dokument ein Serienbrief-Hauptdokument
Private mintNumInSession As Integer
Private menumDocProtectionType As WdProtectionType
Private mintOpenMode As Integer                       ' gibt den |fffd|bergebenen |fffd|ffne-Modus des Makros OEFFNE als Integerwert an.
Private mboolOpenReadOnly As Boolean                  ' read only, wenn dies ge|fffd|ndert wird, dann auch Let OpenMode |fffd|ndern
Private mboolOpenVisible As Boolean                   ' read only, wenn dies ge|fffd|ndert wird, dann auch Let OpenMode |fffd|ndern
Private mboolOpenWithRevert As Boolean                ' read only, wenn dies ge|fffd|ndert wird, dann auch Let OpenMode |fffd|ndern
Private mboolDoNotCloseDocument As Boolean            ' read only, wenn dies ge|fffd|ndert wird, dann auch Let OpenMode |fffd|ndern
Private mboolCloseOpenDocument As Boolean             ' read only, wenn dies ge|fffd|ndert wird, dann auch Let OpenMode |fffd|ndern
Private mboolMailMergeDocument As Boolean             ' read only, wenn dies ge|fffd|ndert wird, dann auch Let OpenMode |fffd|ndern
Private mboolOpenWithHeaderReplace As Boolean         ' read only, wenn dies ge|fffd|ndert wird, dann auch let OpenMode |fffd|ndern
'28.05.2014 AL
Private mboolOpenWithNotDeleteSB As Boolean           ' true, wenn SB-Verkn|fffd|pfung beim |fffd|ffnen (und nur beim |fffd|ffnen) nicht entfernt werden soll
                                                      ' zu steuern mit dem OEFFNE-Befehl, Parameter 'modus', ab 128
                                                      ' Bsp.: OEFFNE "abc.doc", 128 --> damit wird mboolOpenWithNotDeleteSB true
Private mboolPrinted As Boolean

Private mvarSignID As Integer
Private mvarGlobalSignID As Integer
Private mvarSignupWindow As Window
Private mvarMainWindow As Window



Public Sub TC_DocInitialize(newDoc As Document, session As TC_Session)

5   On Error GoTo RaiseErrorHandler

10  With Me
15      .Document = newDoc
20      .DocumentName = newDoc.name
25      .FullName = newDoc.FullName

30      .IsMailMergeDoc = (newDoc.MailMerge.MainDocumentType <> wdNotAMergeDocument)
35      .NumberInSession = session.ManagedTCDocumentsContainer.GetLastDocumentNumber + 1
40      menumDocProtectionType = newDoc.ProtectionType
45      .mainWindow = newDoc.Windows(1)
50  End With

ExitProc:
55  Exit Sub

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_Document::TC_DocInitialize" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc

End Sub

Public Sub RestoreDocProtection(session As TC_Session)

5   On Error GoTo RaiseErrorHandler


    Dim wordVersion As Integer


10  Call Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Dokumentenschutz f|fffd|r " & Chr(34) & Me.DocumentName & Chr(34) & _
                                                                                                                                 " soll zur|fffd|ckgesetzt werden auf: " & _
                                                                                                                                   Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtectDescription(menumDocProtectionType), session)

15  wordVersion = CInt(Mid(Application.Version, 1, 2))

20  If (menumDocProtectionType = 3) And (wordVersion < 10) Then
25      Call Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Dokumentenschutz-Typ f|fffd|r diese Word-Version nicht definiert", session)
30  Else
35      If Me.Document.ProtectionType <> menumDocProtectionType Then
40          Me.Document.Protect Type:=menumDocProtectionType, NoReset:=True
45          Call Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Dokumentenschutz f|fffd|r " & Chr(34) & Me.DocumentName & Chr(34) & _
                                                                                                                                         " zur|fffd|ckgesetzt", session)
50      Else
55          Call Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Dokumentenschutz braucht nicht zur|fffd|ckgesetzt werden", session)

60      End If
65  End If

ExitProc:
70  Exit Sub

RaiseErrorHandler:
75  Err.Raise Err.Number, Err.Source & "->" & "TC_Document::RestoreDocProtection" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Sub

Public Sub DocUnprotect(session As TC_Session)

5   On Error GoTo RaiseErrorHandler

10  If Me.Document.ProtectionType <> wdNoProtection Then
15      Call Me.Document.Unprotect
' 20      Call Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("unprotect das Dokument " & Chr(34) & Me.DocumentName & Chr(34) & " - der Schutz war: " & _
                                                                                                                                       Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtectDescription(menumDocProtectionType), session)
25  End If

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & "->" & "TC_Document::DocUnprotect" & " in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

Private Sub Class_Initialize()

5   Set mobjManagedTCSignaturesContainer = New TC_SignaturesContainer
10  Set mobjManagedTCSignaturesContainer.ParentTcDocument = Me

15  Set mobjDocument = Nothing
20  mstrFullName = vbNullString
25  mstrDocName = vbNullString
30  mboolIsMailMergeDoc = False
35  mboolOpenReadOnly = True
40  mboolOpenVisible = True
45  mboolOpenWithRevert = False
50  mboolDoNotCloseDocument = False
55  mboolMailMergeDocument = False
60  mboolOpenWithHeaderReplace = False
65  mintOpenMode = 3
70  mboolPrinted = False
75  mvarSignID = 0
80  mvarGlobalSignID = 0
85  menumDocProtectionType = wdNoProtection
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjDocument Is Nothing Then
10      Set mobjDocument = Nothing
15  End If

20  If Not mobjParentManagedTCDocumentsContainer Is Nothing Then
25      Set mobjParentManagedTCDocumentsContainer = Nothing
30  End If

35  If Not mobjManagedTCSignaturesContainer Is Nothing Then
40      Set mobjManagedTCSignaturesContainer = Nothing
45  End If

End Sub

Public Property Get ParentManagedTCDocumentsContainer() As TC_DocumentsContainer
5   Set ParentManagedTCDocumentsContainer = mobjParentManagedTCDocumentsContainer
End Property

Public Property Set ParentManagedTCDocumentsContainer(objParentManagedTCDocumentsContainer As TC_DocumentsContainer)
5   If mobjParentManagedTCDocumentsContainer Is Nothing Then
10      Set mobjParentManagedTCDocumentsContainer = objParentManagedTCDocumentsContainer
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_Document.ParentManagedTCDocumentsContainer", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get ManagedTCSignaturesContainer() As TC_SignaturesContainer
5   Set ManagedTCSignaturesContainer = mobjManagedTCSignaturesContainer
End Property

Public Function GetNextSignID() As Integer
5   mvarSignID = mvarSignID + 1
10  GetNextSignID = mvarSignID
End Function

Public Function GetNextGobalSignID() As Integer
5   mvarGlobalSignID = mvarGlobalSignID + 1
10  GetNextGobalSignID = mvarGlobalSignID
End Function

Public Sub ResetSignID()
5   mvarSignID = 0
End Sub

Public Property Get SignUpWindow() As Window
5   Set SignUpWindow = mvarSignupWindow
End Property

Public Property Let mainWindow(vWindow As Window)
5   Set mvarMainWindow = vWindow
End Property

Public Property Get mainWindow() As Window
5   Set mainWindow = mvarMainWindow
End Property

Public Function IsInSignUpMode() As Boolean
5   IsInSignUpMode = Not (mvarSignupWindow Is Nothing)
End Function


Public Property Let Document(ByVal vDocument As Document)
5   Set mobjDocument = vDocument
End Property

Public Property Get Document() As Document
5   Set Document = mobjDocument
End Property

Public Property Let FullName(ByVal vFullName As String)
5   mstrFullName = vFullName
End Property

Public Property Get FullName() As String
5   FullName = mstrFullName
End Property

Public Property Let DocumentName(ByVal vDocName As String)
5   mstrDocName = vDocName
End Property

Public Property Get DocumentName() As String
5   DocumentName = mstrDocName
End Property

Public Property Let DataFile(ByVal vdataFile As String)
5   mstrDataFile = vdataFile
End Property

Public Property Get DataFile() As String
5   DataFile = mstrDataFile
End Property

Public Property Let IsMailMergeDoc(ByVal vIsMailMerge As Boolean)
5   mboolIsMailMergeDoc = vIsMailMerge
End Property

Public Property Get IsMailMergeDoc() As Boolean
5   IsMailMergeDoc = mboolIsMailMergeDoc
End Property

Public Property Let Printed(ByVal vPrinted As Boolean)
5   mboolPrinted = vPrinted
End Property

Public Property Get Printed() As Boolean
5   Printed = mboolPrinted
End Property

Public Property Let NumberInSession(ByVal vNumber As Integer)
5   mintNumInSession = vNumber
End Property

Public Property Get NumberInSession() As Integer
5   NumberInSession = mintNumInSession
End Property

Public Property Let DocProtectionType(ByVal vDocProtectionType As WdProtectionType)
5   menumDocProtectionType = vDocProtectionType
End Property

Public Property Get DocProtectionType() As WdProtectionType
5   DocProtectionType = menumDocProtectionType
End Property

Public Property Get openReadOnly() As Boolean
5   openReadOnly = mboolOpenReadOnly
End Property

Public Property Get openVisible() As Boolean
5   openVisible = mboolOpenVisible
End Property

Public Property Get openWithRevert() As Boolean
5   openWithRevert = mboolOpenWithRevert
End Property

Public Property Get DoNotCloseDocument() As Boolean
5   DoNotCloseDocument = mboolDoNotCloseDocument
End Property

Public Property Get OpenWithHeaderReplace() As Boolean
5   OpenWithHeaderReplace = mboolOpenWithHeaderReplace
End Property

Public Property Get CloseDocBeforeOpen() As Boolean
5   CloseDocBeforeOpen = mboolCloseOpenDocument
End Property

Public Property Get OpenAsMailMerge() As Boolean
5   OpenAsMailMerge = mboolMailMergeDocument
End Property

'28.05.2014 AL
Public Property Get OpenWithNotDeleteSB() As Boolean
5   OpenWithNotDeleteSB = mboolOpenWithNotDeleteSB
End Property

Public Property Get openMode() As Integer
    ' diese Methode kann den augenblicklichen Wert nehmen, da die Variablen, welche diese Zahl
    ' repr|fffd|sentieren auf Read Only gesetzt sind.
    ' wird dies ge|fffd|ndert, dann bitte auch diese Prozedur |fffd|ndern
5   openMode = mintOpenMode
End Property

Public Property Let openMode(ByVal intOpenMode As Integer)

10    On Error GoTo RaiseErrorHandler

20    mintOpenMode = intOpenMode
30    mboolOpenReadOnly = ((intOpenMode And 1) <> 0)
40    mboolOpenVisible = Not ((intOpenMode And 2) <> 0)
    'mboolOpenWithRevert = False  'zu Testzwecken, ob es ben|fffd|tigt wird oder nicht
50    mboolOpenWithRevert = ((intOpenMode And 4) <> 0)
60    mboolDoNotCloseDocument = ((intOpenMode And 8) <> 0)
70    mboolCloseOpenDocument = ((intOpenMode And 16) <> 0)
80    mboolMailMergeDocument = ((intOpenMode And 32) <> 0)
90    mboolOpenWithHeaderReplace = ((intOpenMode And 64) <> 0)
'28.05.2014 AL
100   mboolOpenWithNotDeleteSB = ((intOpenMode And 128) <> 0)

ExitProc:
110   Exit Property

RaiseErrorHandler:
120   Err.Raise Err.Number, Err.Source & "->" & "TC_Document::openMode" & " in Zeile:" & Erl & vbCrLf, Err.Description
130   Resume ExitProc
End Property

Public Function CreateSignUpWindow() As Window
    Dim wordVersion As Integer

10    On Error GoTo RaiseErrorHandler

    ' 10  Set mvarSignupWindow = Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.SynchOn(mobjDocument, Me.ParentManagedTCDocumentsContainer.ParentSession)

20    Application.Run "SignUpAppHandler.SynchOn", mobjDocument, mvarSignupWindow, Me.ParentManagedTCDocumentsContainer.ParentSession.SignWithCommandbar

30    Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg ("Aktives Fenster Titel : " & ActiveWindow.Caption)
40    Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg ("Signup  Fenster Titel : " & mvarSignupWindow.Caption)

50    Set CreateSignUpWindow = mvarSignupWindow

'19.04.2016 AL und 06.11.2017 AL
60    If Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "ST_ALPHA" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "ST_DELTA" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU300" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU430" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU530" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU540" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU541" Then
70      Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.EventHandler.SetSignupMode (True)
80      Exit Function
90    End If
'ENDE 19.04.2016 AL

'08.07.2014 AL
'Fenster auf Pad muss aktiviert werden, damit IKOL-Leiste verschwindet
Dim merkWState As WdWindowState
100   merkWState = CreateSignUpWindow.WindowState
110   CreateSignUpWindow.WindowState = wdWindowStateMinimize
120   CreateSignUpWindow.WindowState = merkWState
'ENDE 08.07.2014 AL

130   Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.EventHandler.SetSignupMode (True)

ExitProc:
140   Exit Function

RaiseErrorHandler:
150   Err.Raise Err.Number, Err.Source & "->" & "TC_Document::CreateSignUpWindow" & " in Zeile:" & Erl & vbCrLf, Err.Description
160   Resume ExitProc

End Function

Public Sub DestroySignUpWindow(force As Boolean)
     '19.04.2016 AL und 06.11.2017 AL
10    If Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "ST_ALPHA" Or _
        Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "ST_DELTA" Or _
        Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU300" Or _
        Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU430" Or _
        Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU530" Or _
        Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU540" Or _
         Me.ParentManagedTCDocumentsContainer.ParentSession.SignPad = "WACOM_STU541" Then
       'Me.mainWindow.Activate
       'mobjDocument.Windows(1).Activate
       Dim merkState As WdWindowState
20     merkState = Application.WindowState
30     Application.WindowState = wdWindowStateMinimize
40     Application.WindowState = merkState
50     GoTo ExitProc
60    End If
     'ENDE 19.04.2016 AL

70    On Error GoTo RaiseErrorHandler

80    If Me.ParentManagedTCDocumentsContainer.ParentSession.SignSynchScreen = susSignSyncScreen Or force Then
90      If Not (mvarSignupWindow Is Nothing) Then

          '08.07.2014 AL
100       Me.mainWindow.Activate
          'ENDE 08.07.2014 AL

110       mvarSignupWindow.Close
120     End If
130   End If

140   mobjDocument.Windows(1).Activate
150   Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.EventHandler.SetSignupMode (False)

ExitProc:
160   mobjDocument.Windows(1).Activate
170   Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.EventHandler.SetSignupMode (False)
180   Set mvarSignupWindow = Nothing
190   Exit Sub

RaiseErrorHandler:
200   mobjDocument.Windows(1).Activate
210   Me.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.EventHandler.SetSignupMode (False)
220   Set mvarSignupWindow = Nothing
230   Err.Raise Err.Number, Err.Source & "->" & "TC_Document::DestroySignUpWindow" & " in Zeile:" & Erl & vbCrLf, Err.Description
240   Resume ExitProc
End Sub
Attribute VB_Name = "TC_DocumentHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_DocumentHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property


Public Function GetStoryTypeName(storyType As WdStoryType) As String
5   Select Case storyType
        Case wdMainTextStory: GetStoryTypeName = "1-Haupttext"
10      Case wdFootnotesStory: GetStoryTypeName = "2-Fu|fffd|noten"
15      Case wdEndnotesStory: GetStoryTypeName = "3-Endnoten"
20      Case wdCommentsStory: GetStoryTypeName = "4-Kommentar"
25      Case wdTextFrameStory: GetStoryTypeName = "5-Textrahmen"
30      Case wdEvenPagesHeaderStory: GetStoryTypeName = "6-Gerade Kopfzeile"
35      Case wdPrimaryHeaderStory: GetStoryTypeName = "7-Prim|fffd|re Kopfzeile"
40      Case wdEvenPagesFooterStory: GetStoryTypeName = "8-Gerade Fu|fffd|zeile"
45      Case wdPrimaryFooterStory: GetStoryTypeName = "9-Prim|fffd|re Fu|fffd|zeile"
50      Case wdFirstPageHeaderStory: GetStoryTypeName = "10-Erste Kopfzeile"
55      Case wdFirstPageFooterStory: GetStoryTypeName = "11-Erste Fu|fffd|zeile"
60      Case 12: GetStoryTypeName = "12-Fu|fffd|notentrennlinie"    'wdFootnoteSeparatorStory
65      Case 13: GetStoryTypeName = "13-Fu|fffd|noten-Fortsetzungstrennlinie"    'wdFootnoteContinuationSeparatorStory
70      Case 14: GetStoryTypeName = "14-Fu|fffd|noten-Fortsetzungshinweis"    'wdFootnoteContinuationNoticeStory
75      Case 15: GetStoryTypeName = "15-Endnotentrennlinie"    'wdEndnoteSeparatorStory
80      Case 16: GetStoryTypeName = "16-Endnoten-Fortsetzungstrennlinie"    'wdEndnoteContinuationSeparatorStory
85      Case 17: GetStoryTypeName = "17-Endnoten-Fortsetzungshinweis"    'wdEndnoteContinuationNoticeStory
90      Case Else: GetStoryTypeName = storyType & "-unbekannter StoryType"
95  End Select

End Function

Public Function ChangeAbsoluteToRelativePath(fld As Field, docDir As String) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim saveShowCodes As Boolean
    Dim codedDocDir As String
    Dim Pos As Integer
    Dim boolResult As Boolean


10  boolResult = False
15  codedDocDir = Replace(docDir, Application.PathSeparator, Application.PathSeparator & Application.PathSeparator)
20  saveShowCodes = fld.ShowCodes
25  fld.ShowCodes = True
30  Pos = InStr(1, UCase(fld.Code.text), UCase(codedDocDir), vbBinaryCompare)
35  If Pos > 0 Then
40      fld.Code.text = Mid(fld.Code.text, 1, Pos - 1) & _
                        Mid(fld.Code.text, Pos + Len(codedDocDir), Len(fld.Code.text))
45      boolResult = True
50  End If
55  fld.ShowCodes = saveShowCodes


ExitProc:
60  ChangeAbsoluteToRelativePath = boolResult
65  Exit Function

RaiseErrorHandler:
70  boolResult = False
75  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ChangeAbsoluteToRelativePath" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc

End Function

Public Function ChangeRelativToAbsolutePath(fld As Field, docDir As String) As Boolean
5   On Error GoTo RaiseErrorHandler


    Dim saveShowCodes As Boolean
    Dim codedDocDir As String
    Dim Pos As Integer
    Dim codeLen As Integer
    Dim boolResult As Boolean


10  boolResult = False
15  codedDocDir = Replace(docDir, Application.PathSeparator, Application.PathSeparator & Application.PathSeparator)
20  saveShowCodes = fld.ShowCodes
25  fld.ShowCodes = True
30  codeLen = Len(fld.Code.text)
35  Pos = InStr(1, UCase(fld.Code.text), "INCLUDETEXT", vbBinaryCompare) + Len("INCLUDETEXT") + 1

40  Do
45      If Pos > codeLen Then Exit Do
50      If Mid(fld.Code.text, Pos, 1) <> " " Then Exit Do
55      Pos = Pos + 1
60  Loop

65  If Pos <= codeLen Then
70      If Mid(fld.Code.text, Pos, 1) = Chr(34) Then
75          Pos = Pos + 1                             ' Dateiname in Anf|fffd|hrungszeichen
80      End If
85      If Pos < codeLen Then
90          If (Mid(fld.Code.text, Pos + 1, 1) <> ":") And _
               (Mid(fld.Code.text, Pos, 4) <> String(4, Application.PathSeparator)) Then    ' |fffd|berspringen des Laufwerkbuchstabens
                ' bzw. UNC-Pfaden
95              fld.Code.text = Mid(fld.Code.text, 1, Pos - 1) & _
                                codedDocDir & _
                                Mid(fld.Code.text, Pos, Len(fld.Code.text))
100             boolResult = True
105         End If
110     End If
115 End If
120 fld.ShowCodes = saveShowCodes

ExitProc:
125 ChangeRelativToAbsolutePath = boolResult
130 Exit Function

RaiseErrorHandler:
135 boolResult = False
140 Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ChangeRelativToAbsolutePath" & " in Zeile:" & Erl & vbCrLf, Err.Description
145 Resume ExitProc

End Function

'Public Sub UpdateIncludeTextFields(storyRange As Range, replaceHeader As Boolean, session As TC_Session)
Public Sub UpdateIncludeTextFields(storyRange As Range, replaceHeader As Boolean, doFillIns As Boolean, session As TC_Session) '09.04.2014 AL doFillIns
5     On Error GoTo RaiseErrorHandler

    Dim idx As Integer
    Dim storyMsgText As String
    Dim fieldMsgText As String
    Dim strField As Field
    Dim urString As String
10    idx = 1

15    For Each strField In storyRange.Fields
20      fieldMsgText = "[Update].Story{" & GetStoryTypeName(storyRange.storyType) & _
                       "}.Feld(" & idx & ") = "
25      storyMsgText = fieldMsgText & strField.Code.text
        'If strField.Type = wdFieldIncludeText Then
30      If strField.Type = wdFieldIncludeText Or strField.Type = wdFieldFillIn Then '09.04.2014 AL doFillIns
35          If replaceHeader Then
40              If ChangeRelativToAbsolutePath(strField, session.DocDirPath) Then
45                  storyMsgText = storyMsgText & vbCrLf & "changed to " & strField.Code.text
50              End If
55          End If
60          urString = "mit Fehler"
            'If strField.Update Then urString = "erfolgreich"
65          If doFillIns = True Or strField.Type = wdFieldIncludeText Then '09.04.2014 AL doFillIns
70            If strField.Update Then urString = "erfolgreich"
75          End If
80          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(storyMsgText & " (Update " & urString & ")", session)
85      Else
            '19.08.2014 AL Logging auskommentiert, sonst Absturz bei OWI
90          'Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(storyMsgText & " (kein Update)", session)
95      End If
100     idx = idx + 1
105   Next strField

ExitProc:
110   Set strField = Nothing
115   Exit Sub

RaiseErrorHandler:
120   Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::UpdateIncludeTextFields" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> Fehlerhafter Code in einem Feld"
125   Resume ExitProc

End Sub


Public Function CheckRangeFieldsForErrors(storyRange As Range, session As TC_Session) As String
5   On Error GoTo RaiseErrorHandler

    Dim strField As Field
    Dim strProtocolLine As String

10  strProtocolLine = vbNullString

15  For Each strField In storyRange.Fields
20      If strField.Type = wdFieldIncludeText Or strField.Type = wdFieldMergeField Or strField.Type = wdFieldRef Then
25          If strField.Update = False Then
30              strProtocolLine = strProtocolLine & strField.Code & " mit dem Fehler -> " & strField.result & vbCrLf
35          End If
40      End If
45  Next strField

ExitProc:
50  Set strField = Nothing
55  CheckRangeFieldsForErrors = strProtocolLine
60  Exit Function

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::CheckRangeFieldsForErrors" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Function


Public Sub RestoreIncludeTextFields(storyRange As Range, replaceHeader As Boolean, session As TC_Session)
    Dim idx As Integer
    Dim storyMsgText As String
    Dim strField As Field

5   On Error GoTo RaiseErrorHandler

10  idx = 1
15  For Each strField In storyRange.Fields
20      storyMsgText = "[Restore].Story{" & GetStoryTypeName(storyRange.storyType) & _
                       "}.Feld(" & idx & ") = " & strField.Code.text
25      If strField.Type = wdFieldIncludeText Then
30          storyMsgText = "[Restore].Story{" & GetStoryTypeName(storyRange.storyType) & _
                           "}.Feld(" & idx & ") = " & strField.Code.text
35          If replaceHeader Then
40              If ChangeAbsoluteToRelativePath(strField, session.DocDirPath) Then
45                  storyMsgText = storyMsgText & vbCrLf & "changed to " & strField.Code.text
50                  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(storyMsgText, session)
55              End If
60          End If
65      End If
70      idx = idx + 1
75  Next strField

ExitProc:
80  Set strField = Nothing
85  Exit Sub

RaiseErrorHandler:
90  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::RestoreIncludeTextFields" & " in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc

End Sub

'Public Sub UpdateIncludeFields(currentDoc As Document, replaceHeader As Boolean, session As TC_Session)
Public Sub UpdateIncludeFields(currentDoc As Document, replaceHeader As Boolean, doFillIns As Boolean, session As TC_Session) '09.04.2014 AL doFillIns

5     On Error GoTo RaiseErrorHandler

    ' wird beim Updaten von Feldern benutzt
    Dim storyRange As Word.Range

10    For Each storyRange In currentDoc.StoryRanges
        'Call UpdateIncludeTextFields(storyRange, replaceHeader, session)
15      Call UpdateIncludeTextFields(storyRange, replaceHeader, doFillIns, session) '09.04.2014 AL doFillIns
20      While Not (storyRange.NextStoryRange Is Nothing)
25          Set storyRange = storyRange.NextStoryRange
            'Call UpdateIncludeTextFields(storyRange, replaceHeader, session)
30          Call UpdateIncludeTextFields(storyRange, replaceHeader, doFillIns, session) '09.04.2014 AL doFillIns
35      Wend
40    Next storyRange
45    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Dokument: '" & currentDoc.name & "' Include-Felder aktualisiert", session)
ExitProc:
50    Set storyRange = Nothing
55    Exit Sub

RaiseErrorHandler:
60    Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::UpdateIncludeFields" & " in Zeile:" & Erl & vbCrLf, Err.Description
65    Resume ExitProc

End Sub


Public Function CheckDocumentFieldsForErrors(currentDoc As Document, session As TC_Session) As Boolean

10    On Error GoTo RaiseErrorHandler

    ' wird bei blo|fffd|em |fffd|berpr|fffd|fen nach Fehlern benutzt
    Dim storyRange As Word.Range
    Dim boolResult As Boolean
    Dim strAggregatedResultString As String
   
    ' 20.03.2014 AL
    ' wenn WinXP und Office 2002, wird unten stehende For Each Schleife nie beendet (warum auch immer)
    Dim intWordVersion As Integer
20  intWordVersion = CInt(Mid(Application.Version, 1, 2))
30  If intWordVersion < 11 Then ' wenn kleiner Office 2002
40    boolResult = False
50    GoTo ExitProc
60  End If
    ' ENDE 20.03.2014 AL
    
    ' 08.10.2014 AL
70    If session.CheckFields = False Then 'wird durch SETZE_PARAMETER CHECK_FIELDS=0 gesetzt
80      boolResult = False
90      GoTo ExitProc
100   End If
    ' ENDE 08.10.2014 AL
    

110   strAggregatedResultString = vbNullString

120   For Each storyRange In currentDoc.StoryRanges
130     strAggregatedResultString = strAggregatedResultString & CheckRangeFieldsForErrors(storyRange, session)
140     While Not (storyRange.NextStoryRange Is Nothing)
150         Set storyRange = storyRange.NextStoryRange
160         strAggregatedResultString = strAggregatedResultString & CheckRangeFieldsForErrors(storyRange, session)
170     Wend
180   Next storyRange

190   If strAggregatedResultString <> vbNullString Then
200     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Fehler beim Aktualisieren der Dokumentenfelder im Dokument '" & _
                                                               currentDoc.name & "': " & vbCrLf & strAggregatedResultString, session)
210     boolResult = True
220   Else
230     boolResult = False
240   End If

ExitProc:
250   CheckDocumentFieldsForErrors = boolResult
260   Set storyRange = Nothing
270   Exit Function

RaiseErrorHandler:
280   boolResult = False
290   Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::CheckDocumentFieldsForErrors" & " in Zeile:" & Erl & vbCrLf, Err.Description
300   Resume ExitProc
End Function


Public Sub RestoreIncludeFields(currentDoc As Document, replaceHeader As Boolean, session As TC_Session)

5   On Error GoTo RaiseErrorHandler

    Dim storyRange As Word.Range

10  For Each storyRange In currentDoc.StoryRanges
15      Call RestoreIncludeTextFields(storyRange, replaceHeader, session)
20      While Not (storyRange.NextStoryRange Is Nothing)
25          Set storyRange = storyRange.NextStoryRange
30          Call RestoreIncludeTextFields(storyRange, replaceHeader, session)
35      Wend
40  Next storyRange

ExitProc:
45  Set storyRange = Nothing
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::RestoreIncludeFields" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Sub

Public Function GetLastRecordNumber(ds As Word.MailMergeDataSource, session As TC_Session) As Integer
5   On Error GoTo RaiseErrorHandler

    ' gibt den letzten Satzindex zur|fffd|ck UND setzt den Datensatzzeiger auf den letzten Satz
    Dim idx As Integer
    Dim intResult As Integer

10  idx = 0
15  ds.ActiveRecord = wdLastRecord
20  idx = ds.ActiveRecord
25  intResult = idx

30  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::GetLastRecordNumber: lastRecord ist " & idx, session)

ExitProc:
35  GetLastRecordNumber = intResult
40  Exit Function

RaiseErrorHandler:
45  intResult = 1
50  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::GetLastRecordNumber" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> Fehler beim Ermitteln des letzten Records"
55  Resume ExitProc
End Function

Public Function MergeRecords(intFirstRec As Integer, _
                             intLastRec As Integer, _
                             boolSingleDocument As Boolean, _
                             session As TC_Session) As TC_SessionResult
    ' zeigt im Dokument die Datenfelder an. _
      werden mehr als 1 Record angezeigt, so wird f|fffd|r jedes weiteren Datensatz ein neues Dokumen angezeigt _
      diese Dokumente werden im Session-Objekt gespeichert und m|fffd|ssen beim Beenden mit wdDoNotSaveChanges _
      geschlossen werden. _
      Beschreibung Kapitel 7 Handbuch der word-Programmierung

    ' Testen, was passiert mit den Symbolleisten in den einzelnen Serienbriefdokumenten!!! - getestet:
    ' es gab den Fehler, dass wenn SYMBOLLEISTE nach MISCHE auftaucht nur auf dem jeweils letzten Dokument
    ' die Symbolleiste angezeigt wurde ( < Word 2007) - behoben

    Dim myDataSource As Word.MailMergeDataSource
    Dim objSaveActiveDoc As Document
    Dim objMailMergeDocument As Document
    Dim objNewMailMergeDoc As TC_Document
    Dim objCurrMailMergeDoc As TC_Document
    Dim idx As Integer
    Dim intOpenMode As Integer
    Dim intRecordCount As Integer
    Dim lngIdentificatorOfCommonDestinationFile As Long
    Dim lngIdentificatorOfDedicatedDestinationFile As Long
    Dim objDocLastMailMergeDestination As Document
    Dim boolMergeErrorsFound As Boolean

    Dim tcResult As TC_SessionResult

5     On Error GoTo RaiseErrorHandler

10    tcResult = tcrOK

15    If ActiveDocument = session.workingDocument Then
        ' wenn das Hauptdokument den Fokus hat
20      Set objSaveActiveDoc = Nothing
25    Else
        ' wenn das Hauptdokument den Fokus NICHT hat, merken welches es ist, um sp|fffd|ter zu ihme zur|fffd|ckzukehren
30      Set objSaveActiveDoc = ActiveDocument
35    End If

    ' aus dem Vorlagen-Dokument(Seriendruck-Hauptdokument) ein TC_Document proizieren
    ' => Seriendruck-Hauptdokument + Datenquelle gegen|fffd|bergestellt + SteuerVariablen f|fffd|r die Office-Schnittstelle

40    Set objCurrMailMergeDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)
45    intOpenMode = objCurrMailMergeDoc.openMode
50    boolMergeErrorsFound = False

    'session.workingDocument ist das Seriendruck-Hauptdokument
55    With session.workingDocument.MailMerge

60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: Beginn der Verarbeitung", session)

65      If .State <> wdMainAndDataSource Then
70          Err.Raise glongCUSTOM_ERR_DATASOURCE_NOT_FOUND, "TC_DocumentHandler::MergeRecords", "Mit dem Serienbrief-Hauptdokument ist keine Datenquelle verbunden"
75      Else
            ' es handelt sich bei dem aktiven Dokument um ein Hauptdokument mit einer verbundenen Datenquelle
80          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: .State ist weMainAndDataSource", session)

            ' die DO-Datei zuweisen, bei dieser Zuweisung macht Word die |fffd|berpr|fffd|fung,
            ' ob zu jedem Dokumentenfeld auch das Datenfeld in der Datenquelle existiert
85          Set myDataSource = .DataSource

            ' sicherheitshalber Serienbrief-Vorschau immer deaktivieren
90          .ViewMailMergeFieldCodes = False          'wdToggle

            ' gibt den letzten Satzindex zur|fffd|ck UND setzt den Datensatzzeiger auf den letzten Satz
95          intRecordCount = Me.GetLastRecordNumber(.DataSource, session)
100         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: Ermittlung von LastRec ergab: " & intRecordCount, session)

            ' ist der Wert 'von' oder 'bis' gr|fffd||fffd|er als die Anzahl der verf|fffd|gbaren Datens|fffd|tze
            ' => gleich der Anzahl der verf|fffd|gbaren Datens|fffd|tze setzen
105         If intLastRec > intRecordCount Then intLastRec = intRecordCount
110         If intFirstRec > intRecordCount Then intFirstRec = intRecordCount

            ' wenn 'von' gleich Null, dann 'von' dem ersten
115         If intFirstRec < 1 Then intFirstRec = 1

            ' wenn 'bis' gleich Null, dann 'bis' zum letzten
120         If intLastRec < 1 Then intLastRec = intRecordCount

            ' Ist der Wert des Parameters "von" gr|fffd||fffd|er als der Wert des Parameters "bis",
            ' wird der Parameter "von" auf den Wert des Parameters "bis" festgelegt und
            ' zur Anzeige kommt der so festgelegte Datensatz. Der Standardwert f|fffd|r beide Parameter ist 1
125         If intFirstRec > intLastRec Then intLastRec = intFirstRec

130         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: nach dem Setzen der Recordnummern - FirstRec=" & intFirstRec & " LastRec=" & intLastRec, session)

135         If boolSingleDocument Then
                ' alle Datens|fffd|tze in ein Zieldokument (hier =Hauptdokument) hineinschreiben

                ' hier eine ID f|fffd|r die gemeinsame Zieldatei (|fffd|bereinstimmend mit dem Hauptdokument, _
                  das in VERBINDE aufgemacht wurde) generieren
140             lngIdentificatorOfCommonDestinationFile = Me.ParentIkolClientApp.Tools.generateRandomNumber(1, 999999)

145             If Not session.workingDocument.Variables("referenceIDDocumentRecords") Is Nothing Then
150                 session.workingDocument.Variables("referenceIDDocumentRecords").value = "tcID_" & _
                                                                                            lngIdentificatorOfCommonDestinationFile
155             Else
160                 session.workingDocument.Variables.Add name:="referenceIDDocumentRecords", value:="tcID_" & _
                                                                                                     lngIdentificatorOfCommonDestinationFile
165             End If
170             .SuppressBlankLines = Not session.MergeEmptyLines
175             .DataSource.FirstRecord = intFirstRec
180             .DataSource.LastRecord = intLastRec

                ' das Dokument vor dem Mischen nach Fehlern untersuchen
185             boolMergeErrorsFound = Me.CheckDocumentFieldsForErrors(session.workingDocument, session)

                ' eine MessageBox erscheint im Fehlerfall (z.B. bei falschen Feldverkn|fffd|pfungen)
                ' ==> diese unterdr|fffd|cken, weil sie ohnehin protokolliert werden
190             Application.DisplayAlerts = False
195             .Execute True
200             Application.DisplayAlerts = True

205             Set objDocLastMailMergeDestination = Me.getLastMailMergeDestination("referenceIDDocumentRecords", _
                                                                                    "tcID_" & lngIdentificatorOfCommonDestinationFile, session)

210             If objDocLastMailMergeDestination Is Nothing Then
                    ' einen Fehler werfen - keine Datei von den ge|fffd|ffneten hat die gesuchte Variable
                    ' "referenceIDDocumentRecords" oder keine hatte den richtigen ID-Wert
215                 Err.Raise glongCUSTOM_ERR_TC_STAMP_NOT_FOUND, "TC_DocumentHandler::MergeRecords", "Der zuletzt erstellte Serienbrief konnte nicht ermittelt werden"
220             Else
                    ' den jeweils letzten (Ziel-)Serienbrief zuweisen
225                 Set objMailMergeDocument = objDocLastMailMergeDestination
230             End If

                ' Dokument in die Verwaltung |fffd|bernehmen
235             Set objNewMailMergeDoc = New TC_Document
240             objNewMailMergeDoc.openMode = objCurrMailMergeDoc.openMode

245             Call objNewMailMergeDoc.TC_DocInitialize(objMailMergeDocument, session)
250             Call session.ManagedTCDocumentsContainer.AddDocumentToSession(objNewMailMergeDoc)

                'Call Me.UpdateIncludeFields(objNewMailMergeDoc.Document, objNewMailMergeDoc.OpenWithHeaderReplace, session)
255             Call Me.UpdateIncludeFields(objNewMailMergeDoc.Document, objNewMailMergeDoc.OpenWithHeaderReplace, False, session) '09.04.2014 AL doFillIns

                ' altes TC_Dokument schliessen und damit auch die DO-Datei l|fffd|schen
260             objCurrMailMergeDoc.Document.Close

                ' das aktuelle Arbeitsdokument in der Session |fffd|ndern
265             Set session.workingDocument = objNewMailMergeDoc.Document

                '265             Call Me.UpdateIncludeFields(objNewMailMergeDoc.Document, objNewMailMergeDoc.OpenWithHeaderReplace, session)

270             Set objNewMailMergeDoc = Nothing
                ' DoEvents
275         Else
                ' jeder der Datens|fffd|tze wird in ein separates Zieldokument hineinschreiben

                ' ######## BEGIN f|fffd|r die Datens|fffd|tze ab dem 2. (insofern es diese gibt) ########
280             For idx = intFirstRec + 1 To intLastRec

                    ' hier eine ID f|fffd|r jede Zieldatei (Serienbrief) generieren + jeweils f|fffd|r jeden Datensatz
285                 lngIdentificatorOfDedicatedDestinationFile = Me.ParentIkolClientApp.Tools.generateRandomNumber(1, 999999)


290                 If Not session.workingDocument.Variables("referenceIDDocumentRecords") Is Nothing Then
                        ' die Variable ist bereits eingeplanzt worden (w|fffd|hrend der 1. Iteration)
295                     session.workingDocument.Variables("referenceIDDocumentRecords").value = "tcID_" & _
                                                                                                lngIdentificatorOfDedicatedDestinationFile
300                 Else
                        ' die Variable gibt es noch nicht
305                     session.workingDocument.Variables.Add name:="referenceIDDocumentRecords", value:="tcID_" & _
                                                                                                         lngIdentificatorOfDedicatedDestinationFile
310                 End If

315                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: Verbinde Datensatz " & idx, session)
320                 .SuppressBlankLines = Not session.MergeEmptyLines
325                 .DataSource.ActiveRecord = idx
330                 .DataSource.FirstRecord = idx
335                 .DataSource.LastRecord = idx
340                 .Destination = wdSendToNewDocument

                    ' das Dokument vor dem Mischen nach Fehlern untersuchen
345                 If Me.CheckDocumentFieldsForErrors(session.workingDocument, session) = True And boolMergeErrorsFound = False Then
                        ' schon beim ersten fehlerhaften Hauptdokument, festlegen, dass es Fehler gab
350                     boolMergeErrorsFound = True
355                 End If

                    ' eine MessageBox erscheint im Fehlerfall (z.B. bei falschen Feldverkn|fffd|pfungen)
                    ' und diese wird unterdr|fffd|ckt
360                 Application.DisplayAlerts = False
365                 .Execute True
370                 Application.DisplayAlerts = True

375                 Set objDocLastMailMergeDestination = Me.getLastMailMergeDestination("referenceIDDocumentRecords", _
                                                                                        "tcID_" & lngIdentificatorOfDedicatedDestinationFile, session)

380                 If objDocLastMailMergeDestination Is Nothing Then
                        ' einen Fehler werfen - keine Datei von den ge|fffd|ffneten hat die gesuchte Variable
385                     Err.Raise glongCUSTOM_ERR_TC_STAMP_NOT_FOUND, "TC_DocumentHandler::MergeRecords", "Der zuletzt erstellte Serienbrief konnte nicht ermittelt werden"
390                 Else
                        ' den jeweils letzten (Ziel-)Serienbrief zuweisen
395                     Set objMailMergeDocument = objDocLastMailMergeDestination
400                 End If

                    ' Dokument in die Verwaltung |fffd|bernehmen
405                 Set objNewMailMergeDoc = New TC_Document
410                 objNewMailMergeDoc.openMode = intOpenMode
415                 Call objNewMailMergeDoc.TC_DocInitialize(objMailMergeDocument, session)
                    'Call UpdateIncludeFields(objNewMailMergeDoc.Document, objNewMailMergeDoc.OpenWithHeaderReplace, session)
420                 Call UpdateIncludeFields(objNewMailMergeDoc.Document, objNewMailMergeDoc.OpenWithHeaderReplace, False, session) '09.04.2014 AL doFillIns

425                 Call session.ManagedTCDocumentsContainer.AddDocumentToSession(objNewMailMergeDoc)
430                 Set objNewMailMergeDoc = Nothing
                    ' DoEvents
435             Next idx
                ' ######## END f|fffd|r die Datens|fffd|tze ab dem 2. (insofern es diese gibt)  ########

                ' ab hier ist die Verarbeitung des Hauptdokuments, das als einziger Serienbrief angezeigt sein k|fffd|nnte
                ' => entsteht kein neues TC_Document! weil nicht gemischt wird - das Dokument ist ledeglich im Vorschaumodus
                ' <=> die Serienbrief-Variablen werden mit den Werten des 1.Datensatzes  belegt.

440             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: Mischen des ersten Records im Serienbrief-Hauptdokument, bis jetzt nur als Vorschau", session)

                ' das Dokument vor dem Mischen nach Fehlern untersuchen
445             If Me.CheckDocumentFieldsForErrors(session.workingDocument, session) = True And boolMergeErrorsFound = False Then
                    ' schon beim ersten fehlerhaften Hauptdokument, festlegen, dass es Fehler gab
450                 boolMergeErrorsFound = True
455             End If

                ' hier eine ID f|fffd|r jede Zieldatei (Serienbrief) generieren + jeweils f|fffd|r jeden Datensatz
460             lngIdentificatorOfDedicatedDestinationFile = Me.ParentIkolClientApp.Tools.generateRandomNumber(1, 999999)

465             If Not session.workingDocument.Variables("referenceIDDocumentRecords") Is Nothing Then
                    ' die Variable ist bereits eingeplanzt worden (w|fffd|hrend der 1. Iteration)
470                 session.workingDocument.Variables("referenceIDDocumentRecords").value = "tcID_" & _
                                                                                            lngIdentificatorOfDedicatedDestinationFile
475             Else
                    ' die Variable gibt es noch nicht
480                 session.workingDocument.Variables.Add name:="referenceIDDocumentRecords", value:="tcID_" & _
                                                                                                     lngIdentificatorOfDedicatedDestinationFile
485             End If

490             .SuppressBlankLines = Not session.MergeEmptyLines
495             .DataSource.ActiveRecord = intFirstRec

                'Call Me.UpdateIncludeFields(session.workingDocument, objCurrMailMergeDoc.OpenWithHeaderReplace, session)
500             Call Me.UpdateIncludeFields(session.workingDocument, objCurrMailMergeDoc.OpenWithHeaderReplace, False, session) '09.04.2014 AL doFillIns
505         End If

            ' DoEvents
510     End If

515     If boolMergeErrorsFound = True Then
520         Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("TC_DocumentHandler::MergeRecords: Feldberechnungsfehler im Hauptdokument gefunden", session)
525         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::MergeRecords: Feldberechnungsfehler im Hauptdokument gefunden", session)
530     End If
535   End With

540   If Not objSaveActiveDoc Is Nothing Then
        ' das zu Beginn der Funktion eventuell gemerkte Dokument wieder in den Vordergrund bringen
545     objSaveActiveDoc.Activate
550   End If

ExitProc:
555   MergeRecords = tcResult
560   Set objCurrMailMergeDoc = Nothing
565   Exit Function

RaiseErrorHandler:
570   tcResult = tcrMergeError

575   Select Case Err.Number
        Case 5174
580         If session.workingDocument Is Nothing Then
585             Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::MergeRecords" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> Kein aktuelles Arbeitsdokument definiert"
590         Else
595             Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::MergeRecords" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> Dokumentenname: " & session.workingDocument.name
600         End If
605     Case Else
610         Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::MergeRecords" & " in Zeile:" & Erl & vbCrLf, Err.Description
615   End Select
620   Resume ExitProc
End Function

Public Function InsertFile(insertFileName As String, atBegin As Boolean, session As TC_Session) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

10  With session.workingDocument

15      If atBegin Then
20          Selection.HomeKey Unit:=wdStory
25      Else
30          Selection.EndKey Unit:=wdStory
35      End If

40      Selection.InsertFile filename:=insertFileName, _
                             Range:=vbNullString, _
                             ConfirmConversions:=False, _
                             Link:=False, _
                             Attachment:=False
45  End With
ExitProc:
50  Exit Function

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::InsertFile" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Function

Public Function InsertText(textForInsert As String, atBegin As Boolean, session As TC_Session) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

10  With session.workingDocument
15      textForInsert = Replace(textForInsert, "~", "^l")
20      textForInsert = Replace(textForInsert, "^l", vbCrLf)
25      If atBegin Then
30          Selection.HomeKey Unit:=wdStory
35          Selection.InsertAfter text:=textForInsert
40      Else
45          Selection.EndKey Unit:=wdStory
50          Selection.InsertBefore text:=textForInsert
55      End If
60  End With

ExitProc:
65  Exit Function

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::InsertText" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Function

Public Function ReplaceTextInRange(strSearchText As String, _
                                   strTextToReplace As String, _
                                   currRange As Word.Range, _
                                   session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolFound As Boolean
10  boolFound = True

15  currRange.TextRetrievalMode.IncludeFieldCodes = False

20  With currRange.Find
25      .ClearFormatting
30      .Replacement.ClearFormatting
35      .text = strSearchText
40      .Replacement.text = strTextToReplace
45      .Forward = True
50      .MatchCase = True
55      .Wrap = wdFindContinue
60  End With

65  boolFound = currRange.Find.Execute(Replace:=wdReplaceAll)

70  If Not boolFound Then
75      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::ReplaceTextInRange: Die zu ersetzende Zeichenkette '" & strSearchText & "' wurde nicht gefunden und konnte mit '" & strTextToReplace & "' nicht ersetzt werden", session)
        '80      Err.Raise glongCUSTOM_ERR_SEARCH_STRING_NOT_FOUND, "TC_DocumentHandler::ReplaceTextInRange", "Die zu ersetzende Zeichenkette '" & strSearchText & _
         "' wurde nicht gefunden und konnte mit '" & strTextToReplace & "' nicht ersetzt werden."
80  End If

ExitProc:
85  ReplaceTextInRange = boolFound
90  Exit Function

RaiseErrorHandler:
95  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ReplaceTextInRange" & " in Zeile:" & Erl & vbCrLf, Err.Description
100 Resume ExitProc

End Function

Public Function ReplaceFieldsInNonHeaderRange(strSearchText As String, _
                                              strTextToReplace As String, _
                                              currRange As Word.Range, _
                                              session As TC_Session) As Boolean

    Dim objField As Field
    Dim idx As Integer
    Dim strStoryMsgText As String
    Dim boolResult As Boolean

5   On Error GoTo RaiseErrorHandler

10  idx = 1

15  For Each objField In currRange.Fields
20      strStoryMsgText = "[REPLACE].Story{" & GetStoryTypeName(currRange.storyType) & _
                          "}.Feld(" & idx & ") = " & objField.Code.text

25      If objField.Type = wdFieldIncludeText Or objField.Type = wdFieldIncludePicture Then

30          objField.Code.TextRetrievalMode.IncludeFieldCodes = True

35          With objField.Code.Find
40              .ClearFormatting
45              .Replacement.ClearFormatting
50              .text = strSearchText
55              .Replacement.text = strTextToReplace
60              .Forward = True
65              .MatchCase = True
70              .Wrap = wdFindContinue
75              boolResult = .Execute(Replace:=wdReplaceAll)
80          End With

85          If boolResult Then
90              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::ReplaceFieldsInNonHeaderRange: " & strStoryMsgText & vbLf & "ersetzt zu " & objField.Code.text, session)
95          Else
100             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::ReplaceFieldsInNonHeaderRange: Die zu ersetzende Zeichenkette '" & strSearchText & "' wurde nicht gefunden und konnte mit '" & strTextToReplace & "' nicht ersetzt werden", session)
                ' 105             Err.Raise glongCUSTOM_ERR_SEARCH_STRING_NOT_FOUND, "TC_DocumentHandler::ReplaceTextInRange", "Die zu ersetzende Zeichenkette '" & strSearchText & _
                  "' wurde nicht gefunden und konnte mit '" & strTextToReplace & "' nicht ersetzt werden."
105         End If

110     Else
            '19.08.2014 AL Logging auskommentiert, sonst Absturz bei OWI
115         'Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::ReplaceFieldsInNonHeaderRange: " & strStoryMsgText & " NOT REPLACED", session)
120     End If

125     idx = idx + 1
130 Next

135 currRange.Fields.Update

ExitProc:
140 ReplaceFieldsInNonHeaderRange = boolResult
145 Set objField = Nothing
150 Exit Function

RaiseErrorHandler:
155 boolResult = False
160 Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ReplaceFieldsInNonHeaderRange" & " in Zeile:" & Erl & vbCrLf, Err.Description & _
                                                                                                                               " -> Versuch, '" & strSearchText & "' mit '" & strTextToReplace & "' zu ersetzen"
165 Resume ExitProc

End Function

Public Function ReplaceFieldsInHeaderRange(strSearchText As String, _
                                           strTextToReplace As String, _
                                           currRange As Word.Range, _
                                           session As TC_Session) As Boolean

    Dim strField As Field
    Dim idx As Integer
    Dim strStoryMsgText As String
    Dim boolResult As Boolean

5   On Error GoTo RaiseErrorHandler

10  idx = 1

15  For Each strField In currRange.Fields
20      strStoryMsgText = "[replace].Story{" & GetStoryTypeName(currRange.storyType) & _
                          "}.Feld(" & idx & ") = " & strField.Code.text

25      If (strField.Type = wdFieldIncludeText) Or (strField.Type = wdFieldIncludePicture) Then
30          strField.Code.TextRetrievalMode.IncludeFieldCodes = True

35          boolResult = InStr(1, strField.Code.text, strSearchText) > 0

40          If boolResult Then
45              strField.Code.text = Replace(strField.Code.text, strSearchText, strTextToReplace)
50              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler::ReplaceFieldsInHeaderRange: " & strStoryMsgText & vbLf & "im Header/Footer ersetzt zu " & strField.Code.text, session)
55          Else
60              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC_DocumentHandler::ReplaceFieldsInHeaderRange: " & strStoryMsgText & _
                     vbLf & strTextToReplace & "wurde im Header/Footer Feld nicht gefunden und konnte mit '" & strTextToReplace & "' nicht ersetzt werden.", session)
                '60              Err.Raise glongCUSTOM_ERR_SEARCH_STRING_NOT_FOUND, "TC_DocumentHandler::ReplaceTextInRange", strStoryMsgText & _
                 vbLf & strTextToReplace & "wurde im Header/Footer Feld nicht gefunden und konnte mit '" & strTextToReplace & "' nicht ersetzt werden."
65          End If
70      Else
75          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_DocumentHandler:ReplaceFieldsInHeaderRange: " & strStoryMsgText & " NOT REPLACED", session)
80      End If
85      idx = idx + 1
90  Next strField

95  currRange.Fields.Update

ExitProc:
100 ReplaceFieldsInHeaderRange = boolResult
105 Set strField = Nothing
110 Exit Function

RaiseErrorHandler:
115 Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ReplaceFieldsInHeaderRange" & " in Zeile:" & Erl & vbCrLf, Err.Description & _
                                                                                                                            " -> Versuch, '" & strSearchText & "' mit '" & strTextToReplace & "' zu ersetzen"
120 Resume ExitProc
End Function

Public Function ReplaceFieldsInRange(strSearchText As String, _
                                     strTextToReplace As String, _
                                     currRange As Word.Range, _
                                     session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean

10  With currRange
15      If .storyType = wdEvenPagesHeaderStory Or _
           .storyType = wdPrimaryHeaderStory Or _
           .storyType = wdEvenPagesFooterStory Or _
           .storyType = wdPrimaryFooterStory Or _
           .storyType = wdFirstPageHeaderStory Or _
           .storyType = wdFirstPageFooterStory Then
20          boolResult = ReplaceFieldsInHeaderRange(strSearchText, strTextToReplace, currRange, session)
25      Else
30          boolResult = ReplaceFieldsInNonHeaderRange(strSearchText, strTextToReplace, currRange, session)
35      End If
40  End With

ExitProc:
45  ReplaceFieldsInRange = boolResult
50  Exit Function

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ReplaceFieldsInRange" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Function

Public Function ReplaceText(strSearchText As String, _
                            strTextToReplace As String, _
                            boolReplaceInText As Boolean, _
                            boolReplaceInFields As Boolean, _
                            boolReplaceInWholeDocument As Boolean, _
                            boolConvertDirectoryNames As Boolean, _
                            session As TC_Session) As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Dim myRange As Range
    Dim strReplaceString As String
    Dim strSearchString As String
    Dim strConvReplString As String
    Dim objResult As TC_SessionResult

    Dim boolResult1 As Boolean
    Dim boolResult2 As Boolean
    Dim boolResult3 As Boolean
    Dim boolResult4 As Boolean

10  objResult = tcrOK

15  If boolConvertDirectoryNames Then
20      strConvReplString = Replace(strTextToReplace, _
                                    Application.PathSeparator, _
                                    Application.PathSeparator & _
                                    Application.PathSeparator)
25  Else
30      strConvReplString = strTextToReplace
35  End If

40  strReplaceString = Replace(strTextToReplace, "~", "^l")
45  strSearchString = Replace(strSearchText, "~", "^l")

50  For Each myRange In session.workingDocument.StoryRanges
55      If boolReplaceInWholeDocument Or (myRange.storyType = wdMainTextStory) Then

60          If boolReplaceInText Then
65              boolResult1 = Me.ReplaceTextInRange(strSearchString, strReplaceString, myRange, session)
70              If boolResult1 = False And objResult = tcrOK Then
75                  objResult = tcrWarning
80              End If
85          End If

90          If boolReplaceInFields Then
95              boolResult2 = Me.ReplaceFieldsInRange(strSearchString, strConvReplString, myRange, session)
100             If boolResult2 = False And objResult = tcrOK Then
105                 objResult = tcrWarning
110             End If
115         End If

120         Do While Not (myRange.NextStoryRange Is Nothing)
125             Set myRange = myRange.NextStoryRange
130             If boolReplaceInText Then
135                 boolResult3 = Me.ReplaceTextInRange(strSearchString, strReplaceString, myRange, session)
140                 If boolResult3 = False And objResult = tcrOK Then
145                     objResult = tcrWarning
150                 End If
155             End If

160             If boolReplaceInFields Then
165                 boolResult4 = Me.ReplaceFieldsInRange(strSearchString, strConvReplString, myRange, session)
170                 If boolResult4 = False And objResult = tcrOK Then
175                     objResult = tcrWarning
180                 End If
185             End If
190         Loop
195     End If
200 Next myRange

ExitProc:
205 Set myRange = Nothing
210 ReplaceText = objResult
215 Exit Function

RaiseErrorHandler:
220 objResult = tcrEnd
225 Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::ReplaceText" & " in Zeile:" & Erl & vbCrLf, Err.Description
230 Resume ExitProc

End Function


Public Function getLastMailMergeDestination(strVarName As String, strVarValue As String, session As TC_Session) As Document

5   On Error GoTo RaiseErrorHandler

    ' hier eine Runde |fffd|ber alle ge|fffd|ffneten Dokumente machen und nach diesem mit der gesetzten
    ' ID lngIdentificatorOfCommonDestinationFile suchen

    Dim objReturnDocument As Document
    Dim objCurrentDocumentToCheck As Document
    Dim objVar As Variable
    Dim boolVarFound As Boolean

10  Set objReturnDocument = Nothing
15  boolVarFound = False

20  For Each objCurrentDocumentToCheck In Application.Documents
25      For Each objVar In objCurrentDocumentToCheck.Variables
30          If objVar.name = strVarName And objVar.value = strVarValue Then
35              Set objReturnDocument = objCurrentDocumentToCheck
40              boolVarFound = True
45              Exit For
50          End If
55      Next objVar
60      If boolVarFound = True Then Exit For
65  Next objCurrentDocumentToCheck

ExitProc:
70  Set getLastMailMergeDestination = objReturnDocument
75  Set objReturnDocument = Nothing
80  Set objCurrentDocumentToCheck = Nothing
85  Exit Function

RaiseErrorHandler:
90  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentHandler::getLastMailMergeDestination" & " in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc
End Function
Attribute VB_Name = "TC_DocumentsContainer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mcolManagedDocumentsInCurrentSession As Collection    ' enth|fffd|lt alle in dieser Session ge|fffd|ffneten Dokumente
Private mobjParentSession As TC_Session


Private Sub Class_Initialize()
5   Set mcolManagedDocumentsInCurrentSession = New Collection
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentSession Is Nothing Then
10      Set mobjParentSession = Nothing
15  End If

20  If Not mcolManagedDocumentsInCurrentSession Is Nothing Then
25      Set mcolManagedDocumentsInCurrentSession = Nothing
30  End If
End Sub

Public Property Get ParentSession() As TC_Session
5   Set ParentSession = mobjParentSession
End Property

Public Property Set ParentSession(objParentSession As TC_Session)
5   If mobjParentSession Is Nothing Then
10      Set mobjParentSession = objParentSession
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_DocumentsContainer.ParentSession", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get ManagedDocumentsCollection() As Collection
5   Set ManagedDocumentsCollection = mcolManagedDocumentsInCurrentSession
End Property


Public Sub AddDocumentToSession(tcDoc As TC_Document)    ' f|fffd|gt ein TC_Document zu den von der OS2 verwalteten Dokumenten

    Dim oldDoc As TC_Document
    Dim intCountOfManagedDocumentsInContainer As Integer


5   On Error GoTo RaiseErrorHandler

10  For Each oldDoc In mcolManagedDocumentsInCurrentSession
15      If oldDoc.FullName = tcDoc.FullName Then
20          Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg ( _
                                                                                                     "Das TC-Dokument '" & tcDoc.FullName & "' existiert bereits in der Verwaltung und wird nicht hinzugef|fffd|gt.")
25          GoTo ExitProc
30      End If
35  Next

40  mcolManagedDocumentsInCurrentSession.Add tcDoc
45  Set tcDoc.ParentManagedTCDocumentsContainer = Me

50  Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "Das TC-Dokument '" & tcDoc.FullName & "' wurde in die Verwaltung |fffd|bernommen.", Me.ParentSession)

55  intCountOfManagedDocumentsInContainer = Me.GetCountOfManagedTCDocumentsInContainer

60  Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Nach TC_DocumentsContainer::AddDocumentToSession - Anzahl verwalteter Dokumente = " & CStr(intCountOfManagedDocumentsInContainer), Me.ParentSession)

ExitProc:
65  Set oldDoc = Nothing
70  Exit Sub

RaiseErrorHandler:
75  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::AddDocumentToSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Sub

Public Function RemoveDocumentFromSession(objOldDoc As TC_Document) As TC_SessionResult
    ' das angegebene Dokument wird aus der Verwaltung entfernt
    ' gepr|fffd|ft wird auch, ob gerade das letzte Session-Dok entfernt wird => tcrEnd

    Dim objSavedDoc As TC_Document
    Dim idx As Integer
    Dim objTcDoc As TC_Document
    Dim objResult As TC_SessionResult

5   On Error GoTo ErrorHandling

10  Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_DocumentsContainer::RemoveDocumentFromSession wurde aufgerufen f|fffd|r '" & objOldDoc.FullName & _
         "'", Me.ParentSession)

    ' Standardwert
15  objResult = tcrFileNotFound

20  idx = 1

25  For Each objSavedDoc In mcolManagedDocumentsInCurrentSession
30      If objSavedDoc.FullName = objOldDoc.FullName Then
            ' das zu entfernende Dokument wurde in der Verwaltung gefunden
35          mcolManagedDocumentsInCurrentSession.Remove (idx)

40          Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg ( _
                                                                                                     "Das TC-Dokument '" & objSavedDoc.FullName & "' wurde aus der Verwaltung entfernt. ")
45          objResult = tcrOK

50          Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "Nach TC_DocumentsContainer::RemoveDocumentFromSession - Anzahl verwalteter Dokumente = " & _
                 Me.GetCountOfManagedTCDocumentsInContainer, Me.ParentSession)

55          If Me.GetCountOfManagedTCDocumentsInContainer = 0 Then
60              If Not Me.ParentSession.InDeleteFile Then
65                  objResult = tcrEnd
70              End If
75          Else
80              If Me.ParentSession.workingDocument Is Nothing Then
85                  Set objTcDoc = mcolManagedDocumentsInCurrentSession.Item( _
                                   Me.GetCountOfManagedTCDocumentsInContainer)
90                  Set Me.ParentSession.workingDocument = objTcDoc.Document
95              End If
100         End If
            ' die Schleife verlassen
105         GoTo ExitProc
110     End If

115     idx = idx + 1
120 Next objSavedDoc

ExitProc:
125 Set objSavedDoc = Nothing
130 Set objTcDoc = Nothing
135 RemoveDocumentFromSession = objResult
140 Exit Function

ErrorHandling:
145 objResult = tcrFileNotFound
150 Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::RemoveDocumentFromSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
155 Resume ExitProc

End Function

Public Sub RestoreDocProtections()
    Dim savedDoc As TC_Document

5   On Error GoTo RaiseErrorHandler

10  For Each savedDoc In mcolManagedDocumentsInCurrentSession
15      Call savedDoc.RestoreDocProtection(Me.ParentSession)
20  Next savedDoc

ExitProc:
25  Set savedDoc = Nothing
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::RestoreDocProtections" & " in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Function GetLastDocumentNumber() As Integer
5   On Error GoTo RaiseErrorHandler

    Dim lastNumber As Integer
    Dim tcDoc As TC_Document

10  lastNumber = 0
15  For Each tcDoc In mcolManagedDocumentsInCurrentSession
20      If lastNumber > tcDoc.NumberInSession Then
25          lastNumber = tcDoc.NumberInSession
30      End If
35  Next tcDoc

ExitProc:
40  GetLastDocumentNumber = lastNumber
45  Set tcDoc = Nothing
50  Exit Function

RaiseErrorHandler:

55  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::GetLastDocumentNumber" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc

End Function


Public Function GetDocumentRecByNumberInSession(intNumber As Integer) As TC_Document
5   On Error GoTo RaiseErrorHandler

    Dim objResultDocument As TC_Document
    Dim tcDoc As TC_Document

10  For Each tcDoc In mcolManagedDocumentsInCurrentSession
15      If tcDoc.NumberInSession = intNumber Then
20          Set objResultDocument = tcDoc
25          GoTo ExitProc
30      End If
35  Next tcDoc

ExitProc:
40  Set GetDocumentRecByNumberInSession = objResultDocument
45  Set objResultDocument = Nothing
50  Set tcDoc = Nothing
55  Exit Function

RaiseErrorHandler:
60  Set objResultDocument = Nothing
65  Err.Raise Err.intNumber, Err.Source & "->" & "TC_DocumentsContainer::GetDocumentRecByNumberInSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc

End Function


Public Function GetDocumentRecByFullFileName(strDocFullFilenameToSearch As String) As TC_Document
5   On Error GoTo RaiseErrorHandler

    Dim tcDoc As TC_Document
    Dim objResultDocument As TC_Document
    ' initialisieren
10  Set GetDocumentRecByFullFileName = Nothing

15  For Each tcDoc In mcolManagedDocumentsInCurrentSession

'02.09.2014 AL
'OWI benutzt im PYP "SCHLIESSE %DOCDIR%%FORMULARNAME%" --> dabei verliert %FORMULARNAME% das case-sensitive!!!
'deshalb: kein case-senitive mehr!!!
'ori: If tcDoc.FullName = strDocFullFilenameToSearch Then
20      If UCase(tcDoc.FullName) = UCase(strDocFullFilenameToSearch) Then
25          Set objResultDocument = tcDoc
30          GoTo ExitProc
35      End If
40  Next tcDoc

ExitProc:
45  Set GetDocumentRecByFullFileName = objResultDocument
50  Set tcDoc = Nothing
55  Set objResultDocument = Nothing
60  Exit Function

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::GetDocumentRecByFullFileName" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Function



Public Function GetCountOfManagedTCDocumentsInContainer() As Integer

5   On Error GoTo RaiseErrorHandler

    Dim intCountOfManagedDocumentsInContainer As Integer

10  If Not mcolManagedDocumentsInCurrentSession Is Nothing Then
15      intCountOfManagedDocumentsInContainer = mcolManagedDocumentsInCurrentSession.count
20  Else
25      intCountOfManagedDocumentsInContainer = 0
30  End If

35  GetCountOfManagedTCDocumentsInContainer = intCountOfManagedDocumentsInContainer

ExitProc:
40  Exit Function

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::GetCountOfManagedTCDocumentsInContainer" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc

End Function


Public Function ActivateSessionDocument() As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Dim objTCDocument As TC_Document
    Dim tcResult As TC_SessionResult

10  Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "Starte TC_DocumentsContainer::ActivateSessionDocument", Me.ParentSession)

15  If Me.ParentSession.workingDocument Is Nothing Then
20      Set objTCDocument = Nothing
25  Else
30      Set objTCDocument = GetDocumentRecByFullFileName(Me.ParentSession.workingDocument.FullName)
35  End If

40  If objTCDocument Is Nothing Then
45      Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "TC_DocumentsContainer::ActivateSessionDocument: WorkingDocument zur Session nicht gefunden", Me.ParentSession)

50      If Me.GetCountOfManagedTCDocumentsInContainer > 0 Then
55          Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "TC_DocumentsContainer::ActivateSessionDocument: Auswahl des vorletzten ge|fffd|ffneten Dokuments", Me.ParentSession)

60          Set objTCDocument = mcolManagedDocumentsInCurrentSession.Item(GetCountOfManagedTCDocumentsInContainer)

65          Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "TC_DocumentsContainer::ActivateSessionDocument: aktiviere Dokument '" & Me.ParentSession.workingDocument.FullName & "'", Me.ParentSession)
70      End If
75  End If


80  If Not objTCDocument Is Nothing Then
85      objTCDocument.Document.Activate
90      Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.ApplicationHandler.HideShadowMergeField(objTCDocument.Document, Me.ParentSession)

95      Me.ParentSession.WorkingDocumentNameChanged (Me.ParentSession.workingDocument.FullName)
100     tcResult = tcrNoEnd
105     Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "Ende TC_DocumentsContainer::ActivateSessionDocument: mit Dokument-Aktivierung - tcResult=" & _
             Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.RCDescription(tcResult), Me.ParentSession)
110 Else
115     tcResult = tcrEnd

120     Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende TC_DocumentsContainer::ActivateSessionDocument: mit tcResult=" & _
                                                                                                     Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.RCDescription(tcResult), Me.ParentSession)
125 End If


ExitProc:
130 ActivateSessionDocument = tcResult
135 Set objTCDocument = Nothing
140 Exit Function

RaiseErrorHandler:
145 tcResult = tcrEnd
150 Err.Raise Err.Number, Err.Source & "->" & "TC_DocumentsContainer::ActivateSessionDocument" & " in Zeile:" & Erl & vbCrLf, Err.Description
155 Resume ExitProc
End Function
Attribute VB_Name = "TC_EventHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents TC_App As Word.Application
Attribute TC_App.VB_VarHelpID = -1
Private mboolSignupMode As Boolean

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If

20  If Not TC_App Is Nothing Then
25      Set TC_App = Nothing
30  End If

End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_ApplicationHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

'---------------------------------------------------------------------------------------
' Prozedur : TC_App_DocumentBeforeClose
' Autor    : Todor Vachkov
' Datum    : 30.08.2013
' Zweck    :
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams: Document: das Word-Dokument auf dem das Schlie|fffd|en ausgef|fffd|hrt wird
'                 Boolean : False, wenn das Ereignis eintritt. Wenn die Ereignisprozedur dieses Argument
'                            auf True festlegt, wird das Dokument beim Beenden der Prozedur nicht geschlossen
'
'---------------------------------------------------------------------------------------
Private Sub TC_App_DocumentBeforeClose(ByVal objEventCallerDoc As Document, Cancel As Boolean)

10    On Error GoTo RaiseErrorHandler

    Dim tcResult As TC_SessionResult
    Dim objSession As TC_Session
    Dim objCorrespondingTcDoc As TC_Document
    Dim flagSync As Integer
    
    
    '16.06.2014 AL
20    If Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True Or Me.ParentIkolClientApp.SignUpHandler.MultiSignupStarted = True Then
30      MsgBox ("BeforeClose: Das Unterschriften-Modul ist noch ge|fffd|ffnet.")
40      Cancel = True
50      Exit Sub
60    End If
    'ENDE 16.06.2014 AL
    
    
70        flagSync = 0

80    Set objSession = Me.ParentIkolClientApp.SessionsContainer.FindSessionToDocument(objEventCallerDoc)

90    If Not objSession Is Nothing Then
        ' das Dokument geh|fffd|rt zu einer Session, ist also ein TC-Dokument => verarbeiten

100     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start: TC_EventHandler::TC_App_DocumentBeforeClose f|fffd|r Dokument '" & objEventCallerDoc.name & "'", objSession)
110     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeClose - aktuelles Verzeichnis = [" & CurDir & "]", objSession)
120     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeClose - CloseDocument f|fffd|r Dokument " & objEventCallerDoc.FullName, objSession)

130     Set objCorrespondingTcDoc = objSession.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(objEventCallerDoc.FullName)

140     If Not objCorrespondingTcDoc Is Nothing Then
150         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeClose - Dokument als ein TC_Document identifiziert", objSession)
            ' sicherstellen, dass beim Schlie|fffd|en keine Nachfrage kommt, ob das Dokument gespeichert werden soll
160         objEventCallerDoc.Saved = True
170         flagSync = 1

            ' hier drin wird auch |fffd|berpr|fffd|ft, ob mit dem Schlie|fffd|en auch gerade das letzte Session-Dok entfernt wurde
180         tcResult = objSession.RemoveFromSessionAndDeleteDatasourcefile(objCorrespondingTcDoc)

190         If tcResult = tcrEnd Then

200             If Not objSession.WeStillInProcessing Then
210                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeClose: Aufrufen von TC_IkolClientApp::CloseSession", objSession)
220                 objSession.MaximizeWordAfterSessionClose = False

230                 If Not objSession.SessionAssociatedCommandBarOrRibon Is Nothing Then
240                     Set objSession.SessionAssociatedCommandBarOrRibon = Nothing
250                     Me.ParentIkolClientApp.RibbonVisible = False
260                     Application.Run "Symbolbar.HideCommandBarOnSessionClose"
270                 End If

280                 If CBool(IsWindow(Me.ParentIkolClientApp.WinHandleOffice2)) Then
290                     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeClose: POST_MESSAGE an WinHnd [" & Me.ParentIkolClientApp.WinHandleOffice2 & "] mit EXIT-CODE [" & glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS & "]", objSession)
300                     PostMessage Me.ParentIkolClientApp.WinHandleOffice2, glongWM_CLOSE, glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS, 0
310                     DoEvents
320                 End If

330                 If Not Me.ParentIkolClientApp.ClientSessionAlreadyClosed Then
340                     Call Me.ParentIkolClientApp.CloseSession(objSession, True, "TC_EventHandler:TC_App_DocumentBeforeClose")
350                     Me.ParentIkolClientApp.LogfileSafeToClose = True
360                 End If
370             Else
380                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeClose: Die Session wird noch nicht geschlossen, weil die Abarbeitung der We-Befehlsfolge noch nicht beendet ist", objSession)
390             End If
400         End If
410     End If

420     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Ende: TC_EventHandler::TC_App_DocumentBeforeClose: Event wurde erfolgreich abgearbeitet f|fffd|r Dokument '" & objEventCallerDoc.name & "'")
430     Call objSession.PrintOutAllManagedDocumentsInSession

440     If flagSync = 1 Then
450       If Documents.count > 1 Then
            '  Dim WshShell
            '  Dim iReturn
            '  Set WshShell = CreateObject("WScript.Shell")
            '  iReturn = WshShell.Popup("sync", 1, "sync")
            '  Sleep 1500
            
            'nur wenn SaveAs der Ikol-Leiste geklickt wurde
460         If gboolSaveAsClicked = True Then
              'ohne diese Verz|fffd|gerung gibt es einen Fehler, wenn zuvor "Speichern unter" in der Ikol-Leiste geklickt wurde
470           Me.ParentIkolClientApp.frmSyncProgress.Show

              'Verfahren in den Vordergrund - nicht n|fffd|tig
              'tcResult = Me.ParentIkolClientApp.ApplicationHandler.ActivateApplication(Word.Application.Caption, objSession)
480         End If
490       End If
500
510     End If
        
        '08.05.2014 AL
        'wenn mind. 2 Sessions ge|fffd|ffnet, und dann in einer Session "Speichern unter" in der Ikol-Leiste gew|fffd|hlt wird,
        'gab es einen Fehler, der hiermit beseitigt wird
520     If Not objSession.SessionAssociatedCommandBarOrRibon Is Nothing Then
          ' Aktivieren des aktuellen Dokumentes oder des zuletzt ge|fffd|ffneten
530       tcResult = objSession.ManagedTCDocumentsContainer.ActivateSessionDocument()
540     End If
550   End If

ExitProc:
560   Set objSession = Nothing
570   Set objCorrespondingTcDoc = Nothing
580   Exit Sub

RaiseErrorHandler:
590   Call DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_EventHandler", "TC_App_DocumentBeforeClose", , _
                                "Eventabarbeitung: 'TC_App_DocumentBeforeClose' zum Dokument '" & objEventCallerDoc.name & "'")
600   Set objSession = Nothing
610   Set objCorrespondingTcDoc = Nothing
620   Resume ExitProc

End Sub


'---------------------------------------------------------------------------------------
' Prozedur : TC_App_DocumentBeforeSave
' Autor    : Todor Vachkov
' Datum    : 11.06.2013
' Zweck    : wird bei jedem Speichern ausgel|fffd|st
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams:
'
'---------------------------------------------------------------------------------------
'

Private Sub TC_App_DocumentBeforeSave(ByVal objEventCallerDoc As Document, SaveAsUI As _
                                                                           Boolean, Cancel As Boolean)

10    On Error GoTo RaiseErrorHandler

    Dim objCorrespondingTcDoc As TC_Document
    Dim objSession As TC_Session
    Dim objNewMailMergeDoc As TC_Document

    Dim strNewFileName As String
    Dim intDlgReturn As Integer


      '23.06.2014 AL
20    If gboolWithBeforeSave = False Then
30      Exit Sub
40    End If

50    Set objSession = Me.ParentIkolClientApp.SessionsContainer.FindSessionToDocument(objEventCallerDoc)

60    If Not objSession Is Nothing Then
        ' das Dokument geh|fffd|rt zu einer Session, ist also kein TC-Dokument => verarbeiten

        ' pr|fffd|fen zuerst, ob das Event von einem Save(As)-Button der Office-Schnittstelle ausgel|fffd|st wurde
70      If objSession.SaveNotTriggeredByWordButtons = False Then

80          If SaveAsUI Then                          ' nur wenn versucht wird ein Dokument umzubennen
                ' pr|fffd|fen ob das Dok, das gerade gespeichert wird, in der Verwaltung ist =>
90              Set objCorrespondingTcDoc = objSession.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(objEventCallerDoc.FullName)

100             If Not objCorrespondingTcDoc Is Nothing Then
                    ' das Dokument ist also ein TC-Dokument UND zu diesem Dokument wird durch das Bet|fffd|tigen
                    ' eines Word-eigenen Save-Buttons ein "Speichern unter ..." auszuf|fffd|hren => abfangen wie das
                    ' umbenannte Dokument heisst und dieses um dieses in die Verwaltung zu |fffd|bernehmen

110                 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte: TC_EventHandler::TC_App_DocumentBeforeSave: Es wurde 'Speichern als ...' NICHT |fffd|BER DIE OFFICE-SCHNITTSTELLE zum Dokument '" & objCorrespondingTcDoc.FullName & "' aufgerufen! -> Dialogbox erschienen")

                    ' die gerade erscheinende Dialog-Box unterdr|fffd|cken; unten wird sie zu Zwecke des Abfangens des neuen Dateinamens wieder aufgerufen durch .SaveAs
120                 Cancel = True

                    ' die Dialogbox zum 'Speichern unter ...' anzeigen, die Benutzer-Dateinamen-Eingabe abfangen aber moch nicht speichern
130                 With Dialogs(wdDialogFileSaveAs)
140                     If objSession.SaveAsDirectory <> vbNullString Then
150                         If Me.ParentIkolClientApp.FileHandler.FolderExist(objSession.SaveAsDirectory) Then
160                             .name = objSession.SaveAsDirectory
170                         Else
180                             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_EventHandler::TC_App_DocumentBeforeSave: - voreingestelltes Verzeichnis kann nicht ausgew|fffd|hlt werden, da es nicht existiert", objSession)
190                         End If
200                     End If

210                     intDlgReturn = .Display
220                     strNewFileName = .name
230                 End With

240                 If intDlgReturn < 0 Then          ''' -1 OK, -2 Schlie|fffd|en
250                     objEventCallerDoc.SaveAs filename:=strNewFileName
260                     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_EventHandler::TC_App_DocumentBeforeSave: Das Dokument wurde |fffd|ber Word als:" & "'" & strNewFileName & "' gespeichert.")

270                     Set objNewMailMergeDoc = New TC_Document
280                     objNewMailMergeDoc.openMode = objCorrespondingTcDoc.openMode
                        ' das Quell-Dokument aus der Verwaltung entfernen
290                     Call objSession.ManagedTCDocumentsContainer.RemoveDocumentFromSession(objCorrespondingTcDoc)

300                     Call objNewMailMergeDoc.TC_DocInitialize(objEventCallerDoc, objSession)
                        ' das neue Dokument in die Verwaltung |fffd|bernehmen
310                     Call objSession.ManagedTCDocumentsContainer.AddDocumentToSession(objNewMailMergeDoc)
320                 End If
330                 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende: TC_EventHandler::TC_App_DocumentBeforeSave: Event wurde erfolgreich abgearbeitet f|fffd|r Dokument '" & objEventCallerDoc.name & "'")
340             End If
350         End If
360     Else
            ' den Session-weiten Schalter zur|fffd|cksetzen
370         objSession.SaveNotTriggeredByWordButtons = False
380     End If                                        ''' objSession.SaveNotTriggeredByWordButtons
390   End If                                            ''' If objSession Is Nothing

ExitProc:

400   Set objCorrespondingTcDoc = Nothing
410   Set objSession = Nothing
420   Set objNewMailMergeDoc = Nothing
430   Exit Sub

RaiseErrorHandler:
440   Call DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_EventHandler", "TC_App_DocumentBeforeSave", , _
                                "Eventabarbeitung: 'TC_App_DocumentBeforeSave' zum Dokument '" & objEventCallerDoc.name & "'")
450   Resume ExitProc
End Sub


Private Sub TC_App_WindowActivate(ByVal objEventCallerDoc As Document, ByVal Wn As Window)
    Dim objSession As TC_Session
    Dim objCorrespondingTcDoc As TC_Document

10    On Error GoTo RaiseErrorHandler

'08.07.2014 AL
      Dim wordVersion As Integer
20    wordVersion = CInt(Mid(Application.Version, 1, 2))
'ENDE 08.07.2014 AL

30    Set objSession = Me.ParentIkolClientApp.SessionsContainer.FindSessionToDocument(objEventCallerDoc)

40    If Not objSession Is Nothing Then
        ' das Dokument geh|fffd|rt zu einer Session, ist also ein TC-Dokument => verarbeiten

        ' die Titelleiste von MS Word mit dem Verfahrensnamen aktualisieren
50      Me.TC_App.ActiveWindow.Caption = Me.TC_App.ActiveDocument.name & " - " & Me.ParentIkolClientApp.VerfahrenName

60      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Start: TC_EventHandler::TC_App_WindowActivate: Event gestartet zum Dokument '" & objEventCallerDoc.name & "'")

70      Set objSession.workingDocument = objEventCallerDoc
80      If Not objSession.SessionAssociatedCommandBarOrRibon Is Nothing Then
            'die Beziehung der Symbolleiste zu ParentIkolClientApp-Objekt herstellen
90          Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_EventHandler::TC_App_WindowActivate: Eine Symbolleiste is REGISTRIERT")

100         Set RibbonCommunicator.gobjIkolClientApp = Me.ParentIkolClientApp
110         objSession.ParentSessionsContainer.ParentIkolClientApp.DisplaySymbolBar (True)
120     Else
130         Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_EventHandler::TC_App_WindowActivate: Eine Symbolleiste is NICHT REGISTRIERT")

140     End If
150     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Ende: TC_EventHandler::TC_App_WindowActivate: Event wurde erfolgreich abgearbeitet zum Dokument '" & objEventCallerDoc.name & "'")

      '03.07.2014 AL
      'else-Zweig neu
      'hiermit bekommen die Dokumente die richtige Symbolleiste, bzw. keine OS2-Dokumente keine Symbolleiste
160   Else
        'muss f|fffd|r alle Word-Versionen so sein
170     Me.ParentIkolClientApp.RibbonVisible = False

        '08.07.2014 AL
        'nur f|fffd|r Word 2007
180     If wordVersion = 12 Then
190       If Me.ParentIkolClientApp.RibbonInstalled Then
            'MsgBox ("starte Displaybar")
200         Application.Run "DisplayBar", False
210       End If
220     End If 'ENDE f|fffd|r Word 2007
        'ENDE 08.07.2014 AL

        'xxx was ist mit Word < 2007 ???
230   End If

'09.07.2014 AL
'Sonst Absturz, wenn anderes Word-Dokument zuvor ge|fffd|ffnet und dann in IKOL-Leitse: eAKTE
240   DoEvents


ExitProc:
250   Set objSession = Nothing
260   Set objCorrespondingTcDoc = Nothing
270   Exit Sub

RaiseErrorHandler:
280   Call DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_EventHandler", "TC_App_WindowActivate", , _
                                "Eventabarbeitung: 'TC_App_WindowActivate' zum Dokument '" & objEventCallerDoc.name & "'")

290   Resume ExitProc
End Sub


Public Sub SetSignupMode(boolModeValue As Boolean)
5   mboolSignupMode = boolModeValue
10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Setze Unterschriftenmodus f|fffd|rs WindowsActivate-Event auf " & mboolSignupMode)
End Sub
Attribute VB_Name = "TC_FileHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_FileHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property


Public Function NormalizeFileName(strOldFileName As String) As String
    'behandelt zur Zeit die Fehler der Fachverfahren durch Weglassen der Endung der Dateien oder _
     durch Anf|fffd|gen der Endung Doc ohne Test, ob der Dateinamen eventuell vollst|fffd|ndig ist _
     Der Test wird zur Zeit f|fffd|r die Endungen docx, doc, rtf, und txt durchgef|fffd|hrt, _
     andere Endungen w|fffd|rden zur einem Fehler f|fffd|hren.

10    On Error GoTo RaiseErrorHandler

    Dim strTempFileName As String
    Dim idx As Integer
    Dim strWrongExtension As String
    Dim strRealFileName As String
    'Dim Extensions(3) As String
    Dim Extensions(4) As String  '20.11.2014 AL "dot" hinzugef|fffd|gt

20    Extensions(0) = "docx"
30    Extensions(1) = "doc"
40    Extensions(2) = "rtf"
50    Extensions(3) = "txt"
60    Extensions(4) = "dot" '20.11.2014 AL "dot" hinzugef|fffd|gt
70    strTempFileName = vbNullString

'AL 22.01.2016
'OEFFNE mit Dialog, wenn erstes Zeichen ein ? ist
'in diesem Falle keine Normalisierung
 If Mid(strOldFileName, 1, 1) = "?" Then
   NormalizeFileName = strOldFileName
   Exit Function
 End If
'ENDE AL 22.01.2016


    'Kommentar 16.09.2014 AL
    'Fehlerbehandlung von TV
    'KFZ hat bei "PFO" -> F2 -> F2 einen Bug: es wird immer .DOC an den Formularnamen geh|fffd|ngt (auch unabh|fffd|ngig von "STANDARD-DOKUMENT-ENDUNG" aus der cblconfig)
    'Bsp: GV "PFO": SYSTEM.DOC a17.doc BEARBEITEN  --> hier kommt an: a17.doc.DOC
    '     GV "PFO": SYSTEM.DOC a17.docx BEARBEITEN --> hier kommt an: a17.docx.DOC
    '     GV "PFO": SYSTEM.DOC a17 BEARBEITEN      --> hier kommt an: a17.DOC
    'verantwortliches Programm (bei PFO -> F2 -> F2): TXTTSD
    'verantwortliches Programm (bei DFO): FUDDSD
    'Mit folgender Schleife wird dieses zus|fffd|tzliche/falsche .DOC weggeschnitten
'80    For idx = 0 To 3
80    For idx = 0 To 4 '20.11.2014 AL "dot" hinzugef|fffd|gt
90      strWrongExtension = "." & Extensions(idx) & ".doc"
100     If UCase(strWrongExtension) = UCase(Right(strOldFileName, Len(strWrongExtension))) Then
110         strTempFileName = Left(strOldFileName, Len(strOldFileName) - Len(strWrongExtension)) & "." & Extensions(idx)
120         Exit For
130     End If
140   Next idx

    'Kommentar 16.09.2014 AL
    'diese Behandlung ist genau genaugenommen falsch
    'diese Behandlung soll anscheinend greifen, wenn im GV "PFO" keine Endung angegeben wurde
    'wenn bspw. .docx UND .doc physisch vorhanden sind, wird .docx genommen - egal was in "STANDARD-DOKUMENT-ENDUNG" (aus der cblconfig) steht
'150   For idx = 0 To 3
150   For idx = 0 To 4 '20.11.2014 AL "dot" hinzugef|fffd|gt
160     If FileExist(strOldFileName & "." & Extensions(idx)) Then
170         strTempFileName = strOldFileName & "." & Extensions(idx)
180         Exit For
190     End If
200   Next idx

210   If strTempFileName = vbNullString Then
220     strTempFileName = strOldFileName
230   End If

240   strRealFileName = Dir(strTempFileName)
250   If strRealFileName <> vbNullString Then
260     strTempFileName = Left(strTempFileName, Len(strTempFileName) - Len(strRealFileName))
270     strTempFileName = strTempFileName & strRealFileName
280   End If

ExitProc:
290   NormalizeFileName = strTempFileName
300   Exit Function

RaiseErrorHandler:
310   strTempFileName = vbNullString
320   Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::NormalizeFileName in Zeile:" & Erl & vbCrLf, Err.Description
330   Resume ExitProc
End Function


Public Function OpenDocument(strOpenFilename As String, _
                             intOpenMode As Integer, _
                             session As TC_Session) As TC_SessionResult

    Dim objCurrentDoc As Document
    Dim objSaveActiveDoc As Document
    Dim lenTestFileName As Integer
    Dim objTcDoc As TC_Document
    Dim intAlertsSave As Integer
    Dim boolOpenWithRevert As Boolean
    Dim boolOpenVisible As Boolean
    Dim boolOpenReadOnly As Boolean
    Dim longChCurrPathResult As Long
    Dim strDocumentTitle As String
    Dim longHwnd As Long
    Dim longSetAsForegroundWindowResult As Long

    Dim objResult As TC_SessionResult

10    On Error GoTo RaiseErrorHandler

'03.07.2014 AL
'|fffd|nderungen vom 06.05.2014 wieder auskommentiert, weil nicht n|fffd|tig und bei BUT/WG (besch1.doc, besch3.doc) sogar falsch

      '06.05.2014 AL
      'Wenn dasselbe (genau dasselbe!) Dokument bereits ge|fffd|ffnet wurde, w|fffd|rde es einfach durch das momentane Dokument ausgetauscht - demnach w|fffd|ren die Daten des zuerst ge|fffd|ffneten
      'Dokuments verloren.
      'Abhilfe w|fffd|rde hier eine Umbenennung des Dokuments mit Anh|fffd|ngen der PID schaffen - dies f|fffd|hrt aber zu weiterer Mehrarbeit bzw. zu Konflikten beim Befehl Speichern.
      'Deshalb hier einfach eine Meldung und Abbruch des Druckvorgangs.
'20    If Me.IsFileOpen(strOpenFilename) Then
'30      MsgBox ("Das Dokument: " & vbCr & _
'            strOpenFilename & vbCr & _
'            "ist bereits ge|fffd|ffnet von: " & vbCr & _
'            session.CallingApplName & vbCr & vbCr & _
'            "Bitte beenden Sie zuerst diese Sitzung.")
'
'40      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument - das Dokument [" & strOpenFilename & "]" & vbCr & _
'                                                               "war bereits ge|fffd|ffnet durch " & session.CallingApplName, session)
'
'50      objResult = tcrFileNotFound
'60      GoTo ExitProc
'70    End If
      'ENDE 06.05.2014 AL


20    objResult = tcrOK

30    Set objSaveActiveDoc = Nothing
40    If Documents.count > 0 Then
50      Set objSaveActiveDoc = ActiveDocument
60    End If

70    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument - aktuelles Verzeichnis = [" & CurDir & "]", session)
80    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument - |fffd|ndere das aktuelle Verzeichnis auf [" & session.DocDirPath & "]", session)
90    longChCurrPathResult = SetCurrentDirectory(session.DocDirPath)

100   If longChCurrPathResult = 0 Then
110     Err.Raise glongCUSTOM_ERR_CHANGE_DIR, "TC_FileHandler::OpenDocument", "Konnte das Arbeitsverzeichnis f|fffd|r MS Word auf '" & session.DocDirPath & _
                                                                              "' nicht |fffd|ndern"
120   Else
130     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument - das aktuelles Verzeichnis wurde erfolgreich gesetzt", session)
140   End If

150   Set objTcDoc = New TC_Document
160   objTcDoc.openMode = intOpenMode

170   strOpenFilename = Me.NormalizeFileName(strOpenFilename)

180   intAlertsSave = Application.DisplayAlerts

    ' Workaround f|fffd|r Fehler von Word:
    ' Fehlerbeschreibung:
    ' beim mehrfachen |fffd|ffnen derselben Dateien kommt Word nicht hinterher, seine interne
    ' Documents-Struktur zu aktualisieren.
    ' Beispiel: Documents.count gibt 3 an,
    ' For Each Document in Documents ergibt jedoch 4 Objekte, wobei ein Objekt doppelt vorkommt.
    ' es kann sogar sein, dass ein ge|fffd|ffnetes Dokument in dieser Struktur nicht erscheint.
    ' Deswegen wird CloseDocBeforeOpen mit boolOpenWithRevert gleichgesetzt, bis eine neue L|fffd|sung gefunden ist.

190   boolOpenWithRevert = objTcDoc.openWithRevert

200   If objTcDoc.CloseDocBeforeOpen Then
210     boolOpenWithRevert = True
220   End If

230   If Not objTcDoc.OpenAsMailMerge Then
240     Application.DisplayAlerts = wdAlertsNone
250   End If

260   boolOpenVisible = objTcDoc.openVisible
270   boolOpenReadOnly = objTcDoc.openReadOnly

280   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument - |fffd|ffne Dokument" & strOpenFilename & vbLf & _
                                                           "ReadOnly = " & boolOpenReadOnly & vbLf & _
                                                           "Revert   = " & boolOpenWithRevert & vbLf & _
                                                           "visible  = " & boolOpenVisible _
       , session)

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
290   If session.Wordmodus = 2 Then
        'derzeit deaktiviert - vielleicht ist Mettmann auch so zufrieden
        'Call Me.ParentIkolClientApp.Tools.HideTray
300   End If
'ENDE 22.07.2014 AL

      '28.10.2014 AL
      'OEFFNE schl|fffd|gt fehl, wenn Spaces im Dateinamen sind (Umlaute im Dateinamen funktionieren auch so)
      'deshalb einschliessen in Anf|fffd|hrungszeichen
      'MsgBox (strOpenFilename)
310   If InStr(strOpenFilename, " ") > 0 Then
320     strOpenFilename = """" & strOpenFilename & """"
330   End If
      'MsgBox (strOpenFilename)
      'ENDE 28.10.2014 AL

'AL 22.01.2016
'OEFFNE mit Dialog, wenn erstes Zeichen ein ? ist
If Mid(strOpenFilename, 1, 1) = "?" Then
  Dim DlgOpen    As FileDialog
  Dim strDatei    As String

  Set DlgOpen = Application.FileDialog(msoFileDialogOpen)

  With DlgOpen
    .AllowMultiSelect = False
    .InitialView = msoFileDialogViewList
    .title = "Word-Dokument ausw|fffd|hlen"
    .Filters.Clear
    .Filters.Add "Alle Dateien", "*.*"
    .Filters.Add "MS-Word Dateien", "*.docx; *.docm; *.dotx; *.dotm; *.doc; *.dot; *.odt; *.rtf"
    .FilterIndex = 2 'MS-Word Dateien
    
    If Len(strOpenFilename) > 1 Then
      'MsgBox "Environ (abc): " & Environ("abc"), vbCritical
      .InitialFileName = Mid(strOpenFilename, 2)
      If Mid(strOpenFilename, 2, 1) = "%" Then 'Umgebungsvariable
        'MsgBox "strOpenFilename: " & strOpenFilename
        Dim umgVar As String
        umgVar = Mid(strOpenFilename, 2)
        umgVar = Replace(umgVar, "%", "") 'ohne %
        'MsgBox "%" & umgVar & "% : " & Environ(umgVar), vbCritical
        .InitialFileName = Environ(umgVar)
      End If
    End If
    
    .Show
    
    If .SelectedItems.count = 0 Then
      'MsgBox "Der Benutzer hat abgebrochen.", vbCritical
      'Beenden simulieren
      objResult = tcrFileNotFound
      GoTo ExitProc
    Else
      strDatei = .SelectedItems(1)   'Ergebnis der Auswahl
      'MsgBox "Die Datei '" & strDatei & "' soll ge|fffd|ffnet werden."
      strOpenFilename = strDatei
    End If
  End With
End If
'ENDE AL 22.01.2016

340   Set objCurrentDoc = Documents.Open( _
                        filename:=strOpenFilename, _
                        ConfirmConversions:=False, _
                        ReadOnly:=boolOpenReadOnly, _
                        AddToRecentFiles:=False, _
                        Revert:=boolOpenWithRevert, _
                        visible:=boolOpenVisible)

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
350   If session.Wordmodus = 2 Then
        'Damit wird Taskleiste leider sichtbar, d.h. sie bleibt nicht ausgeblendet
        'derzeit deaktiviert - vielleicht ist Mettmann auch so zufrieden
        'Call Me.ParentIkolClientApp.Tools.ShowTray
360   End If
'ENDE 22.07.2014 AL

370   Application.DisplayAlerts = intAlertsSave

'03.07.2014 AL
'hier wird minimiert, danach wird in TC_SyntaxDescription::OEFFNE maximiert oder normal dargestellt
'somit klappt es mit dem Fokus
'objCurrentDoc.ActiveWindow.WindowState = wdWindowStateMinimize '09.07.2014 AL verschoben nach TC_SyntaxDescription::OEFFNE
'07.07.2014 AL
'bei Office 2013 ist ansonsten Symbolleiste nicht sofrt da, sondern erst nach nochmaligem activate

'03.07.2014 AL Spielerei auskommentiert
    ' Spielerei um den Fokus in Griff zu bekommen
'370   objCurrentDoc.Activate
'380   objCurrentDoc.ActiveWindow.visible = False
'390   objCurrentDoc.ActiveWindow.visible = True
'400   Application.Activate

    ' Wenn die Einstellungen besagen, dass Feldfunktionen anstelle von Werten anzeigt werden => umschalten
380   If objCurrentDoc.ActiveWindow.View.ShowFieldCodes Then
390     objCurrentDoc.ActiveWindow.View.ShowFieldCodes = False
400   End If

410   strDocumentTitle = objCurrentDoc.ActiveWindow.Caption & " - " & Word.Application.Caption
420   longHwnd = Me.ParentIkolClientApp.Tools.FindOurWindow("OpusApp", strDocumentTitle)
'04.07.2014 AL wieder raus, weil bessere L|fffd|sung gefunden (Modul Focus)
'longSetAsForegroundWindowResult = SetForegroundWindow(longHwnd)
'04.07.2014 AL so funktioniert Focus

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
'if hinzugef|fffd|gt
430   If session.Wordmodus < 2 Then
440     Call Focus.ForceForegroundWindow(longHwnd)
450   End If

460   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_FileHandler::OpenDocument: Setze dieses Dokument als Vordergrundfenster mit Erfolg? - [" & CBool(longSetAsForegroundWindowResult) & "]", session)

#If VBA7 Then
    ' in MS Word 2013: vermeiden, dass das Dokument im Lesemodus aufgemacht wird
      'If CInt(Mid(Application.Version, 1, 2)) = 15 And objCurrentDoc.ActiveWindow.View.ReadingLayout Then
      
      '22.02.2016 AL
      'Anpassungen f|fffd|r MS-Word 2016
470   If (CInt(Mid(Application.Version, 1, 2)) = 15 Or CInt(Mid(Application.Version, 1, 2)) = 16) And objCurrentDoc.ActiveWindow.View.ReadingLayout Then
480     objCurrentDoc.ActiveWindow.View.ReadingLayout = False
490     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument: Word 2013 - LESEMODUS war an - wurde ausgeschaltet", session)
500   End If
#End If

    ' sicherstellen, dass im zu |fffd|ffnenden Dokument nicht eine alte Datenquelle aus DDE-Zeiten |fffd|brig geblieben ist
    ' sollte nach Anwendung von SB_entfernen eigentlich nich vorkommen, denn alle Datenquellen sollen bereits entfernt
    ' worden sein

510   If Not objTcDoc.OpenAsMailMerge Then
520     If objTcDoc.OpenWithNotDeleteSB = False Then '28.05.2014 AL Serienbrief-Verkn|fffd|pfung nur entfernen, wenn OPEN-Befehl < 128 ist
530       objCurrentDoc.MailMerge.MainDocumentType = wdNotAMergeDocument
540     End If
550   End If

560   If Not objCurrentDoc Is Nothing Then
570     Call objTcDoc.TC_DocInitialize(objCurrentDoc, session)
580     Call objTcDoc.DocUnprotect(session)

590     session.ManagedTCDocumentsContainer.AddDocumentToSession objTcDoc

600     Set session.workingDocument = objCurrentDoc

610     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::OpenDocument - Dokument mit dem Namen: " & objCurrentDoc.FullName & " ge|fffd|ffnet", session)

        ' auslesen, die eventuell im Dokument vorhandenen Textmarken und nach einer TC-Unterschrift suchen
620     objTcDoc.ManagedTCSignaturesContainer.UpdateSignaturesList
630     Call Me.ParentIkolClientApp.SignUpHandler.DeleteSignUp

        ' setzten auf die HauptAnsicht unterhalb der HeaderZeile
        'Call Me.ParentIkolClientApp.DocumentHandler.UpdateIncludeFields(objCurrentDoc, objTcDoc.OpenWithHeaderReplace, session)
640     Call Me.ParentIkolClientApp.DocumentHandler.UpdateIncludeFields(objCurrentDoc, objTcDoc.OpenWithHeaderReplace, True, session) '09.04.2014 AL doFillIns

650   Else
660     objResult = tcrFileNotFound

670     Err.Raise glongCUSTOM_ERR_DOC_NOT_FOUND, "TC_FileHandler::OpenDocument", "Das Dokument konnte nicht ge|fffd|ffnet werden"

680   End If

690   If (objTcDoc Is Nothing) Or (Not objTcDoc.openVisible) Then
700     If Not objSaveActiveDoc Is Nothing Then objSaveActiveDoc.Activate
710   End If

ExitProc:
720   Set objTcDoc = Nothing
730   Set objCurrentDoc = Nothing
740   OpenDocument = objResult
750   Exit Function

RaiseErrorHandler:
760   objResult = tcrOpenError

770   Err.Raise Err.Number, Err.Source & "->TC_FileHandler::OpenDocument" & " in Zeile:" & _
                          Erl & vbCrLf, Err.Description & "-> Versuch das Dokument '" & strOpenFilename & "' zu |fffd|ffnen"
780   Resume ExitProc

End Function


Public Function CloseDocument(objTcDocumentToClose As TC_Document, _
                              session As TC_Session, Optional boolCalledByRedQuitButton As Boolean = False) As TC_SessionResult

    Dim objResult As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

10  objResult = tcrOK

15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "Start: TC_FileHandler::CloseDocument - f|fffd|r TC-Dokument '" & objTcDocumentToClose.FullName & "'", session)

20  With objTcDocumentToClose
25      If .DoNotCloseDocument Then

            ' wenn das Schlie|fffd|en druch den Button Beenden der Symbolleiste
30          If boolCalledByRedQuitButton Then
35              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC_FileHandler:CloseDocument: Der Wert von boolCalledByRedQuitButton ist " & boolCalledByRedQuitButton, session)
                'bleibt offen, muss jedoch aus dem TC_DocumentsContainer entfernt werden, nur wenn der Aufruf durch den Beenden-Button ausgel|fffd|st wurde
                '45              objResult = session.RemoveFromSessionAndDeleteDatasourcefile(objTcDocumentToClose)

40              If .IsMailMergeDoc Then
                    ' wenn das Dokument ein Serienbrief-Hauptdokument ist
45                  .Document.Close savechanges:=wdDoNotSaveChanges    'nicht sicher, ob erzeugte Serienbriefe nicht gespeichert werden sollen
50              Else
                    ' wenn das Dokument KEIN Serienbrief-Hauptdokument ist
55                  .Document.Close savechanges:=wdDoNotSaveChanges
60              End If
65              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC_FileHandler::CloseDocument - Das TC-Dokument '" & _
                     objTcDocumentToClose.FullName & "' wurde geschlossen", session)
70          Else
                ' das Dokument soll offen bleiben
75              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC_FileHandler::CloseDocument - Das TC-Dokument '" & objTcDocumentToClose.FullName & _
                     "' wird nicht geschlossen, da es offen bleiben soll, sondern wird aus der Verwaltung entfernt", session)

80              If session.SessionAssociatedCommandBarOrRibon Is Nothing Then
85                  objResult = session.RemoveFromSessionAndDeleteDatasourcefile(objTcDocumentToClose)
90              End If

95          End If
100     Else
            ' das Dokument muss geschlossen aber aus der internen Verwaltung nicht entfernt werden
105         If .IsMailMergeDoc Then
                ' wenn das Dokument ein Serienbrief-Hauptdokument ist
110             .Document.Close savechanges:=wdDoNotSaveChanges    'nicht sicher, ob erzeugte Serienbriefe nicht gespeichert werden sollen
115         Else
                ' wenn das Dokument KEIN Serienbrief-Hauptdokument ist
120             .Document.Close savechanges:=wdDoNotSaveChanges
125         End If
130         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "TC_FileHandler::CloseDocument - Das TC-Dokument '" & _
                 objTcDocumentToClose.FullName & "' wurde geschlossen", session)
135     End If
140 End With

145 Call Me.ParentIkolClientApp.LogfileHandler.ListAllOpenedWordDocuments("TC_FileHandler::CloseDocument")
150 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende: TC_FileHandler::CloseDocument", session)


ExitProc:
155 CloseDocument = objResult
160 Exit Function

RaiseErrorHandler:
165 objResult = tcrEnd
170 Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::CloseDocument" & " in Zeile:" & Erl & vbCrLf, Err.Description
175 Resume ExitProc
End Function

Public Function CloseDocumentByName(strFullFileNameToClose As String, _
                                    session As TC_Session, Optional boolCalledByRedQuitButton As Boolean = False) As TC_SessionResult

    Dim objTcDocumentToClose As TC_Document
    Dim objResult As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

10  objResult = tcrOK

15  If strFullFileNameToClose = vbNullString Then
20      strFullFileNameToClose = session.workingDocument.FullName
25  End If

30  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::CloseDocumentByName - Start f|fffd|r Document " & strFullFileNameToClose, session)

35  Set objTcDocumentToClose = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(strFullFileNameToClose)

40  If Not objTcDocumentToClose Is Nothing Then
45      objResult = Me.CloseDocument(objTcDocumentToClose, session, boolCalledByRedQuitButton)
50  Else
55      objResult = tcrFileNotFound

60      Err.Raise glongCUSTOM_ERR_DOC_NOT_FOUND, "TC_FileHandler::CloseDocumentByName", "Das zu schlie|fffd|ende Dokument wurde nicht gefunden"

65  End If
70  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::CloseDocumentByName - Ende", session)

ExitProc:
75  Set objTcDocumentToClose = Nothing
80  CloseDocumentByName = objResult
85  Exit Function

RaiseErrorHandler:
90  objResult = tcrEnd
95  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::CloseDocumentByName" & " in Zeile:" & Erl & vbCrLf, Err.Description
100 Resume ExitProc
End Function


'---------------------------------------------------------------------------------------
' Prozedur : GetLastSessionIDFromWEname
' Autor    : Todor Vachkov
' Datum    : 28.06.2013
' Zweck    : aufgrund der letzten vorhandenen Nummer einer WE-Datei ('WE_pid_####') wird die Nummer der lettzen Session ermittelt
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
' Integer       : die letzte bekannte SID
'
' |fffd|bergabeparams: keine
'---------------------------------------------------------------------------------------
Public Function GetLastSessionIDFromWEname(strFullFileNameToSearch As String) As Integer
    Dim intSearchLen As Integer
    Dim strFoundFileName As String
    Dim strCompareFileName As String
    Dim strOldFileNames As String
    Dim intTestId As Integer
    Dim intReturnId As Integer
    Dim intPositionSeparator As Integer
    Dim intPositionExtension As Integer

5   On Error GoTo RaiseErrorHandler

    ' die Position des letzten letzten Zeichens vom Pfad in dem vollen Dateinamen (also der letzte '\')
10  intPositionSeparator = InStrRev(strFullFileNameToSearch, Application.PathSeparator, Len(strFullFileNameToSearch), vbTextCompare)

    ' die Position des Punktes, also wo f|fffd|ngt die Datei-Erweiterung an
15  intPositionExtension = InStrRev(strFullFileNameToSearch, ".", Len(strFullFileNameToSearch), vbTextCompare)

20  If intPositionSeparator > 0 Then                  'falls im Verzeichnisname ein Punkt existiert
25      If intPositionExtension < intPositionSeparator Then
30          intPositionExtension = 0
35      End If
40  End If

45  If intPositionExtension > 0 Then
50      strCompareFileName = Mid(strFullFileNameToSearch, intPositionSeparator + 1, intPositionExtension - intPositionSeparator)
55  Else
60      If intPositionSeparator > 0 Then
65          strCompareFileName = Mid(strFullFileNameToSearch, intPositionSeparator + 1, Len(strFullFileNameToSearch))
70      Else
75          strCompareFileName = strFullFileNameToSearch
80      End If
85  End If

90  intSearchLen = Len(strCompareFileName)

95  If intPositionExtension = 0 Then
100     strOldFileNames = strFullFileNameToSearch & "*"
105 Else
110     strOldFileNames = BuildNewFileNameWithString(strFullFileNameToSearch, "*")
115 End If

120 intReturnId = 0
125 strFoundFileName = Dir(strOldFileNames)

130 Do While strFoundFileName <> vbNullString         ' Wiederholen bis foundFileName="", strFoundFileName ohne Pfadangabe
135     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("GetLastSessionIDFromWEname - gefunden: " & strFoundFileName)

140     strFoundFileName = Mid(strFoundFileName, intSearchLen)
145     intPositionExtension = InStrRev(strFoundFileName, ".", Len(strFoundFileName), vbTextCompare) - 1
150     If intPositionExtension > 0 Then
155         strFoundFileName = Mid(strFoundFileName, 1, intPositionExtension)    ' entfernen von .txt
160     Else
165         strFoundFileName = Mid(strFoundFileName, 2)    ' |fffd|berspringen der Betrachtung, dass . existierte
170     End If
175     If strFoundFileName <> vbNullString Then
180         If IsNumeric(strFoundFileName) Then
185             intTestId = CInt(strFoundFileName)
190             If intTestId > intReturnId Then intReturnId = intTestId
195         End If
200     End If
        ' DoEvents
205     strFoundFileName = Dir                        ' Aufruf der Funktion ohne Parameter und damit holen des n|fffd|chsten Parameters
210 Loop

ExitProc:
215 GetLastSessionIDFromWEname = intReturnId
220 Exit Function

RaiseErrorHandler:
225 intReturnId = 0
230 Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::GetLastSessionIDFromWEname in Zeile:" & Erl & vbCrLf, Err.Description
235 Resume ExitProc
End Function


'---------------------------------------------------------------------------------------
' Prozedur : BuildNewFileNameWithString
' Autor    : Todor Vachkov
' Datum    : 30.06.2013
' Zweck    : aus einem Dateinamen WE_pid1234_.txt wird z.B. WE_pid1234_00001.txt
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
' String   : der Dateiname mit der Endung .txt, erweitert um die 5-stellige SID
'
' |fffd|bergabeparams:
' String   : der Dateiname zum Erweitern
' String   : der String (SID) um den erweitert wird
'---------------------------------------------------------------------------------------
Private Function BuildNewFileNameWithString(strFileName As String, strToBeInserted As String) As String
    Dim intPointPosition As Integer
    Dim strResult As String

5   On Error GoTo RaiseErrorHandler

10  intPointPosition = InStrRev(strFileName, ".", Len(strFileName), vbTextCompare)

15  If intPointPosition > 0 Then
20      strResult = Left(strFileName, intPointPosition - 1) & strToBeInserted & Mid(strFileName, intPointPosition)
25  Else
30      strResult = strFileName & strToBeInserted
35  End If

ExitProc:
40  BuildNewFileNameWithString = strResult
45  Exit Function

RaiseErrorHandler:
50  strResult = vbNullString
55  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::BuildNewFileNameWithString in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc

End Function

'---------------------------------------------------------------------------------------
' Prozedur : BuildNewFileNameWithID
' Autor    : Todor Vachkov
' Datum    : 30.06.2013
' Zweck    : erzeugt mit der |fffd|bergebenen SID einen Zusatz f|fffd|r den Namen der WE-Datei
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
' String        : ein 5-stelliger String der die |fffd|bergebene SID um f|fffd|hrende Nullen erweitert
'
' |fffd|bergabeparams:
' String        : voller Name der WE-Datei; wird blo|fffd| weitergereicht
' Integer       : die aktuelle SID
' Boolean       : soll die Dateierweiterung hinzugef|fffd|gt werden
'---------------------------------------------------------------------------------------
Public Function BuildNewFileNameWithID(strFileName As String, intID As Integer, boolWithExtension As Boolean) As String
    Dim strId As String
    Dim intIdLength As Integer
    Dim strResult As String

5   On Error GoTo RaiseErrorHandler

    ' den Stringzusatz zur SID 5-stellig machen
10  intIdLength = 5

15  strId = String(intIdLength, "0") & intID
20  strId = Right(strId, intIdLength)

25  If boolWithExtension Then
30      strResult = BuildNewFileNameWithString(strFileName, strId)
35  Else
40      strResult = strFileName & strId
45  End If

ExitProc:
50  BuildNewFileNameWithID = strResult
55  Exit Function

RaiseErrorHandler:
60  strResult = vbNullString
65  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::BuildNewFileNameWithID in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Function

Public Function JoinData(strDataFileName As String, _
                         boolSpecVarsAllowed As Boolean, _
                         session As TC_Session) As TC_SessionResult

    Dim strNewDoFileName As String
    Dim strTempFileName As String
    Dim objTcDoc As TC_Document
    Dim intIdCounter As Integer
    Dim objResult As TC_SessionResult
    Dim intPos As Integer                             ' die Position des letzten Punktes
    Dim strDatNameWithoutFileExtension As String      ' der Originalname ohne die Erweiterung
5   Dim strNewNameAsDatFile As String                 ' in FS: der Name der DAT-Datei, die gebildet werden muss, weil urspr|fffd|nglich als .DOC geliefert wurde
    Dim boolDoToBeEncrypted As Boolean                ' soll der Inhalt der DO vor der |fffd|bernahme ins Protokoll base64-verschl|fffd|ss|fffd|et werden oder nicht

10  On Error GoTo RaiseErrorHandler

15  objResult = tcrOK

20  session.workingDocument.MailMerge.MainDocumentType = wdNotAMergeDocument

    ' nur f|fffd|r IKOL-FS
25  If InStr(UCase(strDataFileName), ".DOC") <> 0 Then
30      intPos = 0

        ' die Erweiterung .doc/.DOC entfernen, um zu dem reienen Namen die .DAT-Erweiterung hinzuzuf|fffd|gen
35      For intPos = Len(strDataFileName) To 1 Step -1
40          If Mid(strDataFileName, intPos, 1) = "." Then
                ' mit diesem Namen die DAT-Datei benennen
45              strDatNameWithoutFileExtension = Left(strDataFileName, intPos - 1)
50              Exit For
55          End If
60      Next intPos

65      strNewNameAsDatFile = strDatNameWithoutFileExtension & ".DAT"

        ' benennen der Datei z.B. DO_pid1234.doc in DO_pid1234.dat
70      Name strDataFileName As strNewNameAsDatFile
75      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::JoinData - Die DOC-Datendatei '" & _
                                                               strDataFileName & "' wurde in eine DAT-Datendatei '" & strNewNameAsDatFile & "' umbenannt.", session)

        ' den neuen Namenstring dem alten zuweisen, wegen der Verarbeitung die folgt
80      strDataFileName = strNewNameAsDatFile
85  End If

90  strTempFileName = BuildNewFileNameWithString(strDataFileName, "_")
95  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::JoinData - Nach BuildNewFileNameWithString", session)

100 intIdCounter = GetLastSessionIDFromWEname(strTempFileName) + 1
105 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::JoinData - Nach GetLastSessionIDFromWEname", session)

110 strNewDoFileName = BuildNewFileNameWithID(strTempFileName, intIdCounter, True)
115 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::JoinData - Nach BuildNewFileNameWithID: Umbenennen in '" & _
                                                           strNewDoFileName & "' gestartet ...", session)

120 Name strDataFileName As strNewDoFileName
125 Me.ParentIkolClientApp.OriginalDoFileMoved = True
130 session.DoFullFileName = strNewDoFileName

135 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Datendatei " & strDataFileName & " umbenannt in " & strNewDoFileName, session)

    ' hier ermitteln ob die Datei tc_os2_klartext.txt vorliegt, wenn ja: nicht verschl|fffd|sseln, nein: verschl|fffd|sseln

140 boolDoToBeEncrypted = Not Me.FileExist(Me.ParentIkolClientApp.WinworkPath & Application.PathSeparator & gstrTC_OS2_DO_NOT_ENCRYPT_DOFILE_CONTENT)

145 If boolDoToBeEncrypted Then
150     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler:JoinData: Der Inhalt der Datendatei wird verschl|fffd|sselt ins Protokoll |fffd|bernommen", session)
155 Else
160     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler:JoinData: Der Inhalt der Datendatei wird unverschl|fffd|sselt ins Protokoll |fffd|bernommen", session)
165 End If

170 Call Me.ParentIkolClientApp.LogfileHandler.CopyFileToProtokoll(strNewDoFileName, gstrTC_DO_MARKERSTRING, session, boolDoToBeEncrypted)

175 Set objTcDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)
180 objTcDoc.DataFile = strNewDoFileName

185 With session.workingDocument.MailMerge
190     If .DataSource.name <> vbNullString Then
195         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler:JoinData: Dokument noch mit : " & .DataSource.name & " verbunden", session)
200         .MainDocumentType = wdNotAMergeDocument
205     End If

210     Application.DisplayAlerts = False

215     .MainDocumentType = wdFormLetters
220     .OpenDataSource name:=strNewDoFileName, _
                        Format:=wdOpenFormatAuto, _
                        ConfirmConversions:=False, _
                        ReadOnly:=False, _
                        LinkToSource:=True, _
                        AddToRecentFiles:=False, _
                        PasswordDocument:=vbNullString, _
                        PasswordTemplate:=vbNullString, _
                        Revert:=False, _
                        WritePasswordDocument:=vbNullString, _
                        WritePasswordTemplate:=vbNullString, _
                        Connection:=vbNullString, _
                        SQLStatement:=vbNullString, _
                        SQLStatement1:=vbNullString

225     Application.DisplayAlerts = True

230 End With
235 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Dokument mit : " & strNewDoFileName & " verbunden", session)

ExitProc:
240 Set objTcDoc = Nothing
245 JoinData = objResult
250 Exit Function

RaiseErrorHandler:
255 objResult = tcrEnd
260 Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::JoinData" & " in Zeile:" & Erl & vbCrLf, Err.Description & _
                                                                                                      " -> Verbinde mit der Datenquelle '" & strNewDoFileName & "'"
265 Resume ExitProc
End Function

Public Function SaveAsForTC_Document(objTcDoc As TC_Document, _
                                     strFileNameToSave As String, _
                                     session As TC_Session) As TC_SessionResult
    ' darf nur gerufen werden, wenn es ein TC-verwaltetes Dokument ist.

    ' ein TC-verwaltetes Dokument kann einerseits ein Seriendruck-Hauptdokument (mit MergeFields) sein
    ' - wenn in nur einem Zieldokument gemischt wird,
    '
    ' oder andererseits k|fffd|nnen zus|fffd|tzlich "normale" und keine Seriendruck-Hauptdokumente
    ' - (mit ehemaligen MergeFields, die bereits aufgel|fffd|st sind) i.d.R. "Serienbrief1", "Serienbrief2" usw. - entstehen,
    ' also wenn jeder Datensatz in einem separaten Dokument gemischt wird

    ' der Dialog f|fffd|r den neuen Speicherort muss bereits gelaufen sein, deshalb ist der neue Name schon bekannt.

10    On Error GoTo RaiseErrorHandler


    Dim myDataSource As Word.MailMergeDataSource
    Dim objNewMailMergeDoc As TC_Document
    Dim intOpenMode As Integer
    Dim objFinalDocumentToSave As Document
    Dim objFileNameToRemoveFromMgmt As TC_Document
    Dim tcResult As TC_SessionResult

20    tcResult = tcrOK

30    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveAsForTC_Document:  Dokument '" & objTcDoc.FullName & "' soll unter dem neuen Namen " & _
                                                           Chr(34) & strFileNameToSave & Chr(34) & " abgespeichert werden", session)

40    If objTcDoc.Document.MailMerge.MainDocumentType <> wdNotAMergeDocument Then
        ' es ist das Seriendruck-Hauptdokument, zun|fffd|chst benannt i.d.R. Formularname.doc

50      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Das zu speichernde Dokument ist ein MailMerge-Hauptdokument.")

        ' ersten Datensatz in ein neues Dokument Serienbrief speichern,
60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveAsForTC_Document: Verbinde Datensatz 1 in ein neues Dokument", session)
70      With objTcDoc.Document.MailMerge
80          .SuppressBlankLines = Not session.MergeEmptyLines
90          .ViewMailMergeFieldCodes = wdToggle
100         .DataSource.ActiveRecord = 1
110         .Destination = wdSendToNewDocument
120         .Execute
130     End With
        ' wechsel zu dem neuen Dokument
140     Set objFinalDocumentToSave = ActiveDocument
150     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveAsForTC_Document: Name des entstandenen Serienbriefes: " & _
                                                               Chr(34) & objFinalDocumentToSave.name & Chr(34), session)

        ' Dokument dann unter neuem Namen speichern
160     objFinalDocumentToSave.SaveAs filename:=strFileNameToSave

170     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveAsForTC_Document: Entstandene Serienbriefe gespeichert als: " & _
                                                               Chr(34) & objFinalDocumentToSave.name & Chr(34), session)

        ' das neue Dokument in die Verwaltung |fffd|bernehmen
180     Set objNewMailMergeDoc = New TC_Document
190     objNewMailMergeDoc.openMode = objTcDoc.openMode

200     Call objNewMailMergeDoc.TC_DocInitialize(objFinalDocumentToSave, session)
        'Call Me.ParentIkolClientApp.DocumentHandler.UpdateIncludeFields(objFinalDocumentToSave, False, session)
210     Call Me.ParentIkolClientApp.DocumentHandler.UpdateIncludeFields(objFinalDocumentToSave, False, False, session) '09.04.2014 AL doFillIns
220     Call session.ManagedTCDocumentsContainer.AddDocumentToSession(objNewMailMergeDoc)

230     If CInt(Mid(Application.Version, 1, 2)) <= 11 Then
240         If Me.ParentIkolClientApp.RibbonVisible Then
250             Me.ParentIkolClientApp.DisplaySymbolBar (True)
260         End If
270     End If

      '08.05.2014 AL
280   gboolSaveAsClicked = True

        ' DoEvents
        ' altes Dokument schliessen und damit im BeforeClose-Event auch die DO-Datei l|fffd|schen
290     objTcDoc.Document.Close

      '08.05.2014 AL
300   gboolSaveAsClicked = False

310   Else
        ' es ist ein normales Dokument, und kein MailMerge, also sind alle MergeFields bereits aufgel|fffd|st
        ' zun|fffd|chst benannt i.d.R. Serienbriefe1, Serienbriefe2 usw. oder aber auch Name.doc, wenn das Dok zum
        ' 2. Mal mit "Speichern unter ..." umbenannt werden soll

320     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Das zu speichernde Dokument ist kein MailMerge-Hauptdokument.")


        ' wechsel zu dem neuen Dokument
330     Set objFinalDocumentToSave = ActiveDocument
340     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveAsForTC_Document: Name des entstandenen Serienbriefes: " & _
                                                               Chr(34) & objFinalDocumentToSave.name & Chr(34), session)

        ' ein gleichnamiges Dokument (=saveAsDocument.Name) ist bereits w|fffd|hrend des Mischens zur Verw. hinzugef|fffd|gt worden;
        ' hier wird ein Zwilling von ihm erzeugt, um somit es zum Schlu|fffd| mit RemoveDocumentFromSession entfernt zu werden

350     Set objFileNameToRemoveFromMgmt = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(objFinalDocumentToSave.FullName)
360     Call session.ManagedTCDocumentsContainer.RemoveDocumentFromSession(objFileNameToRemoveFromMgmt)

       ' Dokument dann unter neuem Namen speichern
        '23.05.2018 AL
        'Absturz bei IKOL-But: speichern von .doc als .docx bei Nicht-MailMerge-Dokumenten
370     If LCase(Right(strFileNameToSave, 4)) = ".doc" Then
380       objFinalDocumentToSave.SaveAs filename:=strFileNameToSave, FileFormat:=wdFormatDocument 'wdFormatDocument is .doc   wdFormatXMLDocument is .docx
390     Else 'alles andere ist unter wdFormatXMLDocument erlaubt
400       objFinalDocumentToSave.SaveAs filename:=strFileNameToSave, FileFormat:=wdFormatXMLDocument 'wdFormatDocument is .doc   wdFormatXMLDocument is .docx
410     End If
        'ENDE Absturz bei IKOL-But: speichern von .doc als .docx bei Nicht-MailMerge-Dokumenten
        'ENDE 23.05.2018

        ' Dokument dann unter neuem Namen speichern
        'ori: objFinalDocumentToSave.SaveAs filename:=strFileNameToSave

420     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveAsForTC_Document: Entstandene Serienbriefe gespeichert als: " & _
                                                               Chr(34) & objFinalDocumentToSave.name & Chr(34), session)

        ' das neue Dokument in die Verwaltung |fffd|bernehmen
430     Set objNewMailMergeDoc = New TC_Document
440     objNewMailMergeDoc.openMode = objTcDoc.openMode
450     Call objNewMailMergeDoc.TC_DocInitialize(objFinalDocumentToSave, session)
460     Call session.ManagedTCDocumentsContainer.AddDocumentToSession(objNewMailMergeDoc)

470     If CInt(Mid(Application.Version, 1, 2)) <= 11 Then
480         If Me.ParentIkolClientApp.RibbonVisible Then
490             Me.ParentIkolClientApp.DisplaySymbolBar (True)
500         End If
510     End If
        ' DoEvents
520   End If

ExitProc:
530   SaveAsForTC_Document = tcResult
540   Set objNewMailMergeDoc = Nothing
550   Set objFinalDocumentToSave = Nothing
560   Set objFileNameToRemoveFromMgmt = Nothing
570   Exit Function

RaiseErrorHandler:
580   tcResult = tcrSaveError
590   Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::SaveAsForTC_Document" & " in Zeile:" & Erl & vbCrLf, Err.Description
600   Resume ExitProc

End Function

Public Function SaveDocumentAs(objDocToSave As Document, _
                               strNewFileName As String, _
                               intSaveAsMode As Integer, _
                               session As TC_Session) As TC_SessionResult
    'intSaveAsMode = 0 - existierende Dateien werden |fffd|berschrieben
    'intSaveAsMode = 1 - Abbruch bei existierenden Dateien mit Nachricht
    'intSaveAsMode = 2 - Dialogbox f|fffd|r das Speichern als wird angezeigt

    Dim intOldMailMerge As Integer
    Dim longDlgReturn As Long
    Dim boolScrUpdate As Boolean

    Dim objReturn As TC_SessionResult

10    On Error GoTo RaiseErrorHandler

    ' die Einstellung merken
20    boolScrUpdate = Application.ScreenUpdating

30    If objDocToSave Is Nothing Then
40      objReturn = tcrFileNotFound
50      Err.Raise glongCUSTOM_ERR_DOC_NOT_FOUND, "TC_FileHandler::SaveDocumentAs", "Das zu speichernde Dokument konnte nicht gefunden werden"
60    Else
70      With objDocToSave
80          intOldMailMerge = .MailMerge.MainDocumentType
            
            '17.02.2015 AL if eingef|fffd|gt
90          If session.SpeichernAlsSBentfernen = True Then
100           .MailMerge.MainDocumentType = wdNotAMergeDocument
110         End If
120         Select Case intSaveAsMode
                Case 0                                ' existierende Dateien werden |fffd|berschrieben
130                 If strNewFileName <> vbNullString Then
140                     .SaveAs filename:=strNewFileName
150                 Else
160                     .Save
170                 End If

180                 objReturn = tcrOK

190             Case 1                                ' Abbruch bei existierenden Dateien mit Nachricht
200                 If FileExist(strNewFileName) Then

210                     objReturn = tcrSaveError

220                     Err.Raise glongCUSTOM_ERR_DOC_ALREADY_EXISTS, "TC_FileHandler::SaveDocumentAs", "Es existiert bereits eine Datei mit dem Namen '" & _
                                                                                                        strNewFileName & "'. Bitte die Konfiguration |fffd|ndern "
230                 Else
240                     If strNewFileName <> vbNullString Then
250                         .SaveAs filename:=strNewFileName
260                     Else
270                         .Save
280                     End If
290                     objReturn = tcrOK
300                 End If

310             Case 2                                ' Dialogbox f|fffd|r das 'Speichern als' wird angezeigt
320                 Application.ScreenUpdating = True

330                 With Dialogs(wdDialogFileSaveAs)
340                     .name = strNewFileName
                        '20.10.2014 AL, auskommentiert: longDlgReturn = .Display      ' ist noch nicht ausgef|fffd|hrt, .Show h|fffd|tte es schon ausgef|fffd|hrt
350                     longDlgReturn = .Show  '20.10.2014 AL stattdessen so
360                     If longDlgReturn < 0 Then     '-1 OK, -2 Schlie|fffd|en
370                         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveDocumentAs:  Dokument wird abgespeichert unter dem neuen Namen " & Chr(34) & .name & Chr(34), session)
                            '.Execute '20.10.2014 AL auskommentiert
380                     End If
390                 End With

400                 If longDlgReturn = 0 Then         '0 Abbrechen
410                     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveDocumentAs: Vorgang 'Speichern unter' wurde durch Benutzer abgebrochen.", session)
420                     .MailMerge.MainDocumentType = intOldMailMerge
430                     objReturn = tcrWarning
440                 Else
450                     objReturn = tcrOK
460                 End If

470             Case Else
480                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SaveDocumentAs:  Parameter zur Steuerung des Save-Modes hat einen nicht definierten Wert " & intSaveAsMode, session)
490                 objReturn = tcrWarning
500         End Select
510     End With
520   End If

ExitProc:
530   Application.ScreenUpdating = boolScrUpdate
540   SaveDocumentAs = objReturn
550   Exit Function

RaiseErrorHandler:
560   objReturn = tcrSaveError
570   Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::SaveDocumentAs" & " in Zeile:" & Erl & vbCrLf, Err.Description & _
                                                                                                            " -> Speichern des Dokuments unter dem Namen '" & strNewFileName & "'"
580   Resume ExitProc

End Function

Private Sub TC_UPD32_Command(strCommand As String, _
                             strActionName As String, _
                             strDocPath As String, _
                             strDocName As String, _
                             session As TC_Session)

5   On Error GoTo RaiseErrorHandler

    Dim strDocDir As String
    Dim strUploadServerCmd As String
    Dim strTmpDocName As String

10  strDocDir = session.DocDirPath
    'entfernen des PathSeparators am Ende des DocDirs
15  Do While InStrRev(strDocDir, Application.PathSeparator) = Len(strDocDir)
20      strDocDir = Mid(strDocDir, 1, Len(strDocDir) - 1)
25  Loop

30  strTmpDocName = strDocName
35  If strActionName <> "DELETE_FILE" Then
40      strTmpDocName = LCase(strDocName)
45  End If

50  strUploadServerCmd = Chr(34) & session.ClientDirPath & "tc_upd32.exe" & Chr(34) & " " & _
                         session.ServerName & " " & _
                         Chr(34) & strDocPath & Application.PathSeparator & strTmpDocName & Chr(34) & " " & _
                         Chr(34) & strDocDir & Chr(34) & " " & _
                         strCommand & " " & _
                         session.PortNumber
55  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(strActionName & " - " & "tc_upd32-Commando" & vbLf & strUploadServerCmd, session)

    ' den zusammengef|fffd|gten Commando-Aufruf ausf|fffd|hren
60  Shell strUploadServerCmd
65  DoEvents

ExitProc:
70  Exit Sub

RaiseErrorHandler:
75  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::TC_UPD32_Command" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc

End Sub

Public Sub UploadFileToServer(actionName As String, tcDoc As TC_Document, session As TC_Session)

5   On Error GoTo RaiseErrorHandler

10  Call TC_UPD32_Command("UPLOAD_FILE", actionName, tcDoc.Document.Path, tcDoc.Document.name, session)

ExitProc:
15  Exit Sub

RaiseErrorHandler:
20  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::UploadFileToServer" & " in Zeile:" & Erl & vbCrLf, Err.Description
25  Resume ExitProc

End Sub

Public Sub DeleteFileOnServer(actionName As String, pathName As String, docName As String, session As TC_Session)
5   On Error GoTo RaiseErrorHandler

10  Call TC_UPD32_Command("DELETE_FILE", actionName, pathName, docName, session)

ExitProc:
15  Exit Sub

RaiseErrorHandler:
20  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::DeleteFileOnServer" & " in Zeile:" & Erl & vbCrLf, Err.Description
25  Resume ExitProc
End Sub

Public Function FileExist(filename As String) As Boolean
    Dim FSO As New FileSystemObject

5   FileExist = FSO.FileExists(filename)
10  Set FSO = Nothing

End Function

'20.04.2017 AL
Public Function FileCreateTime(filename As String) As String
    Dim FSO As New FileSystemObject
    Dim createDate As Date
    
10    createDate = FSO.GetFile(filename).DateCreated

20    FileCreateTime = Format(createDate, "Long Time")

30    Set FSO = Nothing

End Function
'ENDE 20.04.2017 AL

Public Function FolderExist(directoryName As String) As Boolean
    Dim FSO As New FileSystemObject

5   FolderExist = FSO.FolderExists(directoryName)
10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("FolderExist: f|fffd|r Folder " & directoryName & " - Resultat: " & FolderExist)

15  Set FSO = Nothing

End Function

Public Function FileDelete(strFileName As String) As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim FSO As New FileSystemObject
    Dim objFullFileNameToDelete As file
    Dim boolReturn As Boolean

20    boolReturn = False

30    Set objFullFileNameToDelete = FSO.GetFile(strFileName)

40    If Not objFullFileNameToDelete Is Nothing Then
50      If Not objFullFileNameToDelete.Attributes = ReadOnly Then
60          On Error Resume Next '22.07.2014 AL
70          FSO.DeleteFile (strFileName)
80          boolReturn = True
90          On Error GoTo 0      '22.07.2014 AL
100     Else
110         Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg ("TC_FileHandler::FileDelete: Die Datei '" & strFileName & "' ist schreibgesch|fffd|tzt oder bereits in Zugriff und kann nicht gel|fffd|scht werden.")
120         boolReturn = False
130     End If
140   Else
150     Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg ("TC_FileHandler::FileDelete: Die Datei '" & strFileName & "' existiert nicht.")
160     boolReturn = False
170   End If

ExitProc:
180   FileDelete = boolReturn
190   Set objFullFileNameToDelete = Nothing
200   Set FSO = Nothing
210   Exit Function

RaiseErrorHandler:
220   boolReturn = False
230   Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::FileDelete" & " in Zeile:" & Erl & _
                          vbCrLf, Err.Description & " -> Dateiname:'" & strFileName & "'"
240   Resume ExitProc
End Function

Public Sub DeleteFile(strFileName As String, session As TC_Session)

5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::DeleteFile: L|fffd|sche " & strFileName, session)

15  If Me.FileDelete(strFileName) Then
20      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::DeleteFile: zu l|fffd|schende Datei '" & strFileName & "' gefunden und gel|fffd|scht", session)
25  End If

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::DeleteFile" & " in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

Public Sub SetSaveAsDirectory(strControlValue As String, objSession As TC_Session)
5   On Error GoTo RaiseErrorHandler

    Dim wshshell As Object
    Dim strExpandedDirectoryName As String

10  Set wshshell = CreateObject("WScript.Shell")
15  strExpandedDirectoryName = wshshell.ExpandEnvironmentStrings(strControlValue)
20  Set wshshell = Nothing
25  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SetSaveAsDirectory: |fffd|bergebendes Verzeichnis ist " & strControlValue, objSession)
30  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SetSaveAsDirectory: erweitertes Verzeichnis ist  " & strExpandedDirectoryName, objSession)

35  objSession.SaveAsDirectory = Me.ParentIkolClientApp.Tools.NormalizedPathWithSeparator(strExpandedDirectoryName)
40  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_FileHandler::SetSaveAsDirectory: gespeichertes Verzeichnis ist  " & objSession.SaveAsDirectory, objSession)

ExitProc:
45  Exit Sub

RaiseErrorHandler:
50  Err.Raise Err.Number, Err.Source & "->" & "TC_FileHandler::SetSaveAsDirectory in Zeile:" & Erl & vbCrLf, Err.Description
55  Resume ExitProc
End Sub


'06.05.2014 AL
Function IsFileOpen(filename As String)
          Dim filenum As Integer, errnum As Integer

5         On Error Resume Next
10        filenum = FreeFile()
15        Open filename For Input Lock Read As #filenum
20        Close filenum
25        errnum = Err
30        On Error GoTo 0

35        Select Case errnum
              Case 0
40             IsFileOpen = False

45            Case 70
50                IsFileOpen = True
55        End Select
End Function
'ENDE 06.05.2014 AL
Attribute VB_Name = "TC_IkolClientApp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private mstrVerfahrenName As String
Private mlongClientPid As Long
Private mlonglWinHandleOffice2 As Long
Private mstrClientWindowTitle As String
Private mstrWeFilePrefixWithCurrentPid As String
Private mboolIsAPrinterInstalled As Boolean
Private mstrDefaultPrinterName As String
Private mstrWinworkPath As String
Private mstrLogfileFullName As String
Private mstrOs2Version As String
Private mstrContainingDotTemplateFile As String
Private mstrBuildVersion As String
Private mboolClientSessionAlreadyClosed As Boolean    ' wird benutzt um evtl. wiederholtes Schlie|fffd|en der Session auszuschlie|fffd|en

' Schalter, deren Werte ein fr|fffd|hzeitiges Senden von PostMessage in Main kontrollieren
Private mboolOriginalDoFileMoved As Boolean           ' DO-Datei von IKOL umbenannt
Private mboolOriginalWeFileMoved As Boolean           ' WE-Datei von IKOL umbenannt
Private mboolIsArcDirSet As Boolean                   ' in XXDRUCK ist ARC-DIR bekannt (ausgelesen aus den Konfigdateien)
Private mboolIsArcPrinterSet As Boolean               ' in der WE-Datei ist durch den Befehl ARCPRINTER ein eAkte-Drucker definiert
Private mboolAtLeastOneEakteButton As Boolean         ' es gibt eine Symbolleiste und auf ihr ist mindestens eins der Buttons mit eAkte definiert

Private mstrMsgBoxTitle As String

Private mstrTimeCreate As String                      ' aus TC_SessionsContainer hergeholt
Private mboolWordMustStayOpen As Boolean              ' aus TC_SessionsContainer hergeholt
Private mstrLastCallingApplication As String          ' aus TC_SessionsContainer hergeholt
Private mboolSymbolbarInstalled As Boolean            ' aus TC_SessionsContainer hergeholt
Private mboolRibbonVisible As Boolean                 ' aus TC_SessionsContainer hergeholt

' der Wert zeigt an, ob das Ikol-App-Objekt aus dem RAM entfernt werden kann (von Interesse in CloseSession())
Private mboolIkolClientAppObjectTerminationAllowed As Boolean

Private mobjCurrentPcPrinterSetup As TC_PrinterSetupHandler

' Instanz des TC_LogfileHandler, wo die Protokollausschriften gesteuert werden
Private mobjLogfileHandler As TC_LogfileHandler

' der Container f|fffd|r alle Druckauftr|fffd|ge(=Sessions), die vom einem und demselben Client initiiert worden sind
Private mobjSessionsContainer As TC_SessionsContainer

' Instanz des TC_EventHandlers, wo einige Ereignisse |fffd|berschrieben werden
Private mobjEventHandler As TC_EventHandler

' Instanz des TC_ApplicationHandler
Private mobjApplicationHandler As TC_ApplicationHandler

' Instanz des TC_ApplicationHandler
Private mobjFileHandler As TC_FileHandler

' Instanz des TC_SyntaxDescription wo die Zuweisungen Befehl => Ort & Definition des zugrundeliegenden Makros
Private mobjSyntaxDescription As TC_SyntaxDescription

' Instanz des TC_CommandbarCommands wo die Implementationen der obiegen Makros enthalten sind
Private mobjCommandbarCommands As TC_CommandBarCommands

' Instanz des TC_ParameterDescription
Private mobjParameterDescription As TC_ParameterDescription

' Instanz von TC_Tools
Private mobjTools As TC_Tools

' Instanz von TC_RibbonAndCommandbarRelated
Private mobjRibbonAndCommandbarRelatives As TC_RibbonAndCommandbarRelated

' Instanz von TC_DocumentHandler
Private mobjDocumentHandler As TC_DocumentHandler

' Instanz des TC_ApplicationHandler
Private mobjMailMergeHandler As TC_MailMergeHandler

' Instanz des TC_ControlHandler
Private mobjControlHandler As TC_ControlHandler

' Instanz des TC_CallbackHandler
Private mobjCallbackHandler As TC_CallbackHandler

' Instanz des TC_PrintHandler
Private mobjPrintHandler As TC_PrintHandler

' Instanz des TC_PrinterSetupHandler
Private mobjPrinterSetupHandler As TC_PrinterSetupHandler

' Instanz des TC_SignUpHandler
Private mobjSignUpHandler As TC_SignUpHandler

' ======== die UserForms zum IkolClientApp-Objekt ========
Private mfrmAnsichtInfo As frmTC_AnsichtInfo
Private mfrmDruckerAuswahl As frmTC_DruckerAuswahl
Private mfrmProgressbalken As frmTC_Progressbalken
Private mfrmVorschau As frmTC_Vorschau
Private mfrmSyncProgress As frmTC_SyncProgress '08.05.2014 AL

' ======== die UserForms zum IkolClientApp-Objekt im UNTERSCHRIFTENMODUL ========
Private mfrmSignUpSelsectionDlg As frmTC_SignUpSelection
Private mfrmSignUpApplyDlg As frmTC_Signup
Private mfrmSignUpTypeQuestionDlg As frmTC_SignTypeQuestion
Private mfrmSignUpEditDlg As frmTC_EditSignup

Private Sub Class_Initialize()
    ' erfassen wann das Objekt erzeugt wurde
5   mstrTimeCreate = time()
    '10  gintInitiatedIkolClientAppObjectsCounter = gintInitiatedIkolClientAppObjectsCounter + 1    ' zur Nuzung in kommenden Versionen
10  mboolClientSessionAlreadyClosed = False

15  mboolOriginalDoFileMoved = False
20  mboolOriginalWeFileMoved = False
25  mboolIsArcDirSet = False
30  mboolIsArcPrinterSet = False
35  mboolAtLeastOneEakteButton = False
End Sub

Private Sub Class_Terminate()
    '5   If gintInitiatedIkolClientAppObjectsCounter > 0 Then
    '10      gintInitiatedIkolClientAppObjectsCounter = gintInitiatedIkolClientAppObjectsCounter - 1    ' zur Nuzung in kommenden Versionen
    '15  End If
5   Call Me.CleanUp
End Sub


Public Sub CleanUp()

5   If Not mobjSessionsContainer Is Nothing Then
10      Set mobjSessionsContainer = Nothing
15  End If

20  If Not mobjEventHandler Is Nothing Then
25      Set mobjEventHandler = Nothing
30  End If

35  If Not mobjLogfileHandler Is Nothing Then
40      Set mobjLogfileHandler = Nothing
45  End If

50  If Not mobjCurrentPcPrinterSetup Is Nothing Then
55      Set mobjCurrentPcPrinterSetup = Nothing
60  End If

65  If Not mobjApplicationHandler Is Nothing Then
70      Set mobjApplicationHandler = Nothing
75  End If

80  If Not mobjFileHandler Is Nothing Then
85      Set mobjFileHandler = Nothing
90  End If

95  If Not mobjSyntaxDescription Is Nothing Then
100     Set mobjSyntaxDescription = Nothing
105 End If

110 If Not mobjCommandbarCommands Is Nothing Then
115     Set mobjCommandbarCommands = Nothing
120 End If

125 If Not mobjParameterDescription Is Nothing Then
130     Set mobjParameterDescription = Nothing
135 End If

140 If Not mobjTools Is Nothing Then
145     Set mobjTools = Nothing
150 End If

155 If Not mobjRibbonAndCommandbarRelatives Is Nothing Then
160     Set mobjRibbonAndCommandbarRelatives = Nothing
165 End If

170 If Not mobjDocumentHandler Is Nothing Then
175     Set mobjDocumentHandler = Nothing
180 End If

185 If Not mobjMailMergeHandler Is Nothing Then
190     Set mobjMailMergeHandler = Nothing
195 End If

200 If Not mobjControlHandler Is Nothing Then
205     Set mobjControlHandler = Nothing
210 End If

215 If Not mobjCallbackHandler Is Nothing Then
220     Set mobjCallbackHandler = Nothing
225 End If

230 If Not mobjPrintHandler Is Nothing Then
235     Set mobjPrintHandler = Nothing
240 End If

245 If Not mobjPrinterSetupHandler Is Nothing Then
250     Set mobjPrinterSetupHandler = Nothing
255 End If

260 If Not mobjSignUpHandler Is Nothing Then
265     Set mobjSignUpHandler = Nothing
270 End If

275 If Not mfrmAnsichtInfo Is Nothing Then
280     Set mfrmAnsichtInfo = Nothing
285 End If

290 If Not mfrmDruckerAuswahl Is Nothing Then
295     Set mfrmDruckerAuswahl = Nothing
300 End If

305 If Not mfrmProgressbalken Is Nothing Then
310     Set mfrmProgressbalken = Nothing
315 End If

320 If Not mfrmVorschau Is Nothing Then
325     Set mfrmVorschau = Nothing
330 End If

335 If Not gobjIkolClientAppInCallbackHandler Is Nothing Then
340     Set gobjIkolClientAppInCallbackHandler = Nothing
345 End If

350 If Not mfrmSignUpSelsectionDlg Is Nothing Then
355     Set mfrmSignUpSelsectionDlg = Nothing
360 End If

365 If Not mfrmSignUpApplyDlg Is Nothing Then
370     Set mfrmSignUpApplyDlg = Nothing
375 End If

380 If Not mfrmSignUpTypeQuestionDlg Is Nothing Then
385     Set mfrmSignUpTypeQuestionDlg = Nothing
390 End If

395 If Not mfrmSignUpEditDlg Is Nothing Then
400     Set mfrmSignUpEditDlg = Nothing
405 End If

End Sub

' Prozeduren zum stufenweise Initialisieren der Kinderobjekte

Public Sub Initialize_UserFormAnsichtInfo()
    ' initialisiere die read-only UserForm AnsichtInfo f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmAnsichtInfo = New frmTC_AnsichtInfo
15  Load mfrmAnsichtInfo
20  Set mfrmAnsichtInfo.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm AnsichtInfo wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormAnsichtInfo in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Sub Initialize_UserFormDruckerAuswahl()
    ' initialisiere die read-only UserForm DruckerAuswahl f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmDruckerAuswahl = New frmTC_DruckerAuswahl
15  Load mfrmDruckerAuswahl
20  Set mfrmDruckerAuswahl.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm DruckerAuswahl wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormDruckerAuswahl in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

Public Sub Initialize_UserFormProgressbalken()
    ' initialisiere die read-only UserForm Progressbalken f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmProgressbalken = New frmTC_Progressbalken
15  Load mfrmProgressbalken
20  Set mfrmProgressbalken.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm Progressbalken wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormProgressbalken in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

'08.05.2014 AL
Public Sub Initialize_UserFormSyncProgress()
    ' initialisiere die read-only UserForm SyncProgress f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmSyncProgress = New frmTC_SyncProgress
15  Load mfrmSyncProgress
20  Set mfrmSyncProgress.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm SyncProgress wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormSyncProgress in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub



Public Sub Initialize_UserFormVorschau()
    ' initialisiere die read-only UserForm Vorschau f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmVorschau = New frmTC_Vorschau
15  Load mfrmVorschau
20  Set mfrmVorschau.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm Vorschau wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::UserFormVorschau in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

Public Sub Initialize_UserFormSignUpSelsection()
    ' initialisiere die read-only UserForm Vorschau f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmSignUpSelsectionDlg = New frmTC_SignUpSelection
15  Load mfrmSignUpSelsectionDlg
20  Set mfrmSignUpSelsectionDlg.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm SignUpSelection wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormSignUpSelsection in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Sub Initialize_UserFormSignUp()
    ' initialisiere die read-only UserForm Vorschau f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmSignUpApplyDlg = New frmTC_Signup
15  Load mfrmSignUpApplyDlg
20  Set mfrmSignUpApplyDlg.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm SignUp wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormSignUp in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Sub Initialize_UserFormSignUpTypeQuestion()
    ' initialisiere die read-only UserForm Vorschau f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmSignUpTypeQuestionDlg = New frmTC_SignTypeQuestion
15  Load mfrmSignUpTypeQuestionDlg
20  Set mfrmSignUpTypeQuestionDlg.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm SignUpTypeQuestion wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormSignUpTypeQuestion in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Sub Initialize_UserFormEditSignUp()
    ' initialisiere die read-only UserForm Vorschau f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mfrmSignUpEditDlg = New frmTC_EditSignup
15  Load mfrmSignUpEditDlg
20  Set mfrmSignUpEditDlg.ParentIkolClientApp = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die UserForm EditSignUp wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_UserFormEditSignUp in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Sub Initialize_LogfileHandler(strLogfileName As String)
    ' initialisiere den read-only LogfileHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjLogfileHandler = New TC_LogfileHandler
15  Set mobjLogfileHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.OpenExistingLogfileForWriting(strLogfileName)


ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_LogfileHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub

Public Sub Initialize_SessionsContainer()
    ' initialisiere den read-only SessionsContainer f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjSessionsContainer = New TC_SessionsContainer
15  Set mobjSessionsContainer.ParentIkolClientApp = Me
20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der Sessions-Container wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_SessionsContainer in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_EventHandler()
    ' initialisiere den read-only EventHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjEventHandler = New TC_EventHandler
15  Set mobjEventHandler.ParentIkolClientApp = Me
    ' sp|fffd|ter zum |fffd|berschreiben der Eventes Save und Close
20  Set mobjEventHandler.TC_App = Word.Application

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der EventHandler wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_EventHandler in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub


Public Sub Initialize_FileHandler()
    ' initialisiere den read-only FileHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjFileHandler = New TC_FileHandler
15  Set mobjFileHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der FileHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_FileHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_ApplicationHandler()
    ' initialisiere den read-only ApplicationHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjApplicationHandler = New TC_ApplicationHandler
15  Set mobjApplicationHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der ApplicationHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_ApplicationHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub

Public Sub Initialize_ControlHandler()
    ' initialisiere den read-only ControlHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjControlHandler = New TC_ControlHandler
15  Set mobjControlHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der ControlHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_ControlHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub

Public Sub Initialize_DocumentHandler()
    ' initialisiere den read-only DocumentHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjDocumentHandler = New TC_DocumentHandler
15  Set mobjDocumentHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der DocumentHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_DocumentHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_PrintHandler()
    ' initialisiere den read-only PrintHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjPrintHandler = New TC_PrintHandler
15  Set mobjPrintHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der PrintHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_PrintHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_SignUpHandler()
    ' initialisiere den read-only SignUpHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjSignUpHandler = New TC_SignUpHandler
15  Set mobjSignUpHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der SignUpHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_SignUpHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub



Public Sub Initialize_PrinterSetupHandler()
    ' initialisiere den read-only PrinterSetupHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjPrinterSetupHandler = New TC_PrinterSetupHandler
15  Set mobjPrinterSetupHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der PrinterSetupHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_PrinterSetupHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_CommandBarCommands()
    ' initialisiere den read-only CommandBarCommands f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjCommandbarCommands = New TC_CommandBarCommands
15  Set mobjCommandbarCommands.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die CommandBarCommands wurden erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_CommandBarCommands in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_MailMergeHandler()
    ' initialisiere den read-only MailMergeHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjMailMergeHandler = New TC_MailMergeHandler
15  Set mobjMailMergeHandler.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der MailMergeHandler wurde erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_MailMergeHandler in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_SyntaxDescription()
    ' initialisiere die read-only SyntaxDescription f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjSyntaxDescription = New TC_SyntaxDescription
15  Set mobjSyntaxDescription.ParentIkolClientApp = Me

20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die Regeln der Syntaxbeschreibung wurden erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_SyntaxDescription in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_Tools()
    ' initialisiere die read-only Tools f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjTools = New TC_Tools
15  Set mobjTools.ParentIkolClientApp = Me
20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die Tools wurden erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_Tools in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub


Public Sub Initialize_RibbonAndCommandbarRelated()
    ' initialisiere die read-only TC_RibbonAndCommandbarRelated f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

10  Set mobjRibbonAndCommandbarRelatives = New TC_RibbonAndCommandbarRelated
15  Set mobjRibbonAndCommandbarRelatives.ParentIkolClientApp = Me
20  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Die RibbonAndCommandbarRelated wurden erfolgreich initialisiert")

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_RibbonAndCommandbarRelated in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Sub

Public Sub Initialize_CallbackHandler()
    ' initialisiere die read-only TC_CallbackHandler f|fffd|r diesen IKOL-Client

5   On Error GoTo RaiseErrorHandler

    ' das CallbackHadnler-Objekt des aktuellen IkolClientApp-Objekts
10  Set mobjCallbackHandler = New TC_CallbackHandler
15  Set mobjCallbackHandler.ParentIkolClientApp = Me

    ' das IkolClientApp-Objekt der Modulvariable im Standard-Modul "CallbackHandler" zuweisen
20  Set gobjIkolClientAppInCallbackHandler = Me

25  Call Me.LogfileHandler.General_ProtokollMsg("DOT", "Der CallbackHandler wurde erfolgreich initialisiert")

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & " -> " & "TC_IkolClientApp::Initialize_CallbackHandler in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

' ===========================================================
' nur die read-only Properties, i. d. R. die Instanzen der Klassenvariablen
' ===========================================================

Public Property Get SessionsContainer() As TC_SessionsContainer
5   Set SessionsContainer = mobjSessionsContainer
End Property

Public Property Get LogfileHandler() As TC_LogfileHandler
5   Set LogfileHandler = mobjLogfileHandler
End Property

Public Property Get CurrentPcPrinterSetup() As TC_PrinterSetupHandler
5   Set CurrentPcPrinterSetup = mobjCurrentPcPrinterSetup
End Property

Public Property Get EventHandler() As TC_EventHandler
5   Set EventHandler = mobjEventHandler
End Property

Public Property Get ApplicationHandler() As TC_ApplicationHandler
5   Set ApplicationHandler = mobjApplicationHandler
End Property

Public Property Get FileHandler() As TC_FileHandler
5   Set FileHandler = mobjFileHandler
End Property

Public Property Get SyntaxDescription() As TC_SyntaxDescription
5   Set SyntaxDescription = mobjSyntaxDescription
End Property

Public Property Get CommandBarCommands() As TC_CommandBarCommands
5   Set CommandBarCommands = mobjCommandbarCommands
End Property

Public Property Get ParameterDescription() As TC_ParameterDescription
5   Set ParameterDescription = mobjParameterDescription
End Property

Public Property Get Tools() As TC_Tools
5   Set Tools = mobjTools
End Property

Public Property Get RibbonAndCommandbarRelatives() As TC_RibbonAndCommandbarRelated
5   Set RibbonAndCommandbarRelatives = mobjRibbonAndCommandbarRelatives
End Property

Public Property Get DocumentHandler() As TC_DocumentHandler
5   Set DocumentHandler = mobjDocumentHandler
End Property

Public Property Get MailMergeHandler() As TC_MailMergeHandler
5   Set MailMergeHandler = mobjMailMergeHandler
End Property

Public Property Get ControlHandler() As TC_ControlHandler
5   Set ControlHandler = mobjControlHandler
End Property

Public Property Get CallbackHandler() As TC_CallbackHandler
5   Set CallbackHandler = mobjCallbackHandler
End Property

Public Property Get PrintHandler() As TC_PrintHandler
5   Set PrintHandler = mobjPrintHandler
End Property

Public Property Get PrinterSetupHandler() As TC_PrinterSetupHandler
5   Set PrinterSetupHandler = mobjPrinterSetupHandler
End Property

Public Property Get SignUpHandler() As TC_SignUpHandler
5   Set SignUpHandler = mobjSignUpHandler
End Property

Public Property Get frmAnsichtInfo() As frmTC_AnsichtInfo
5   Set frmAnsichtInfo = mfrmAnsichtInfo
End Property

Public Property Get frmDruckerAuswahl() As frmTC_DruckerAuswahl
5   Set frmDruckerAuswahl = mfrmDruckerAuswahl
End Property

Public Property Get frmProgressBalken() As frmTC_Progressbalken
5   Set frmProgressBalken = mfrmProgressbalken
End Property
'08.05.2014 AL
Public Property Get frmSyncProgress() As frmTC_SyncProgress
5   Set frmSyncProgress = mfrmSyncProgress
End Property

Public Property Get frmVorschau() As frmTC_Vorschau
5   Set frmVorschau = mfrmVorschau
End Property

Public Property Get frmSignUpSelection() As frmTC_SignUpSelection
5   Set frmSignUpSelection = mfrmSignUpSelsectionDlg
End Property

Public Property Get frmSignup() As frmTC_Signup
5   Set frmSignup = mfrmSignUpApplyDlg
End Property

Public Property Get frmSignTypeQuestion() As frmTC_SignTypeQuestion
5   Set frmSignTypeQuestion = mfrmSignUpTypeQuestionDlg
End Property

Public Property Get frmEditSignup() As frmTC_EditSignup
5   Set frmEditSignup = mfrmSignUpEditDlg
End Property

' ===========================================================
' read/write Properties
' ===========================================================

Public Property Get ContainingDotTemplateFile() As String
5   ContainingDotTemplateFile = mstrContainingDotTemplateFile
End Property

Public Property Let ContainingDotTemplateFile(ByVal strContainingDotTemplateFile As String)
5   mstrContainingDotTemplateFile = strContainingDotTemplateFile
End Property

Public Property Get BuildVersion() As String
5   BuildVersion = mstrBuildVersion
End Property

Public Property Let BuildVersion(ByVal strBUILDVersion As String)
5   mstrBuildVersion = strBUILDVersion
End Property

Public Property Get MsgBoxTitle() As String
5   MsgBoxTitle = mstrMsgBoxTitle
End Property

Public Property Let MsgBoxTitle(ByVal strMsgBoxTitle As String)
5   mstrMsgBoxTitle = strMsgBoxTitle
End Property

Public Property Get Os2Version() As String
5   Os2Version = mstrOs2Version
End Property

Public Property Let Os2Version(ByVal strOS2Version As String)
5   mstrOs2Version = strOS2Version
End Property

Public Property Get VerfahrenName() As String
5   VerfahrenName = mstrVerfahrenName
End Property

Public Property Let VerfahrenName(ByVal strVerfahrenName As String)
5   mstrVerfahrenName = strVerfahrenName
End Property

Public Property Get ClientPid() As Long
5   ClientPid = mlongClientPid
End Property

Public Property Let ClientPid(ByVal longClientPid As Long)
5   mlongClientPid = longClientPid
End Property

Public Property Get WinHandleOffice2() As Long
5   WinHandleOffice2 = mlonglWinHandleOffice2
End Property

Public Property Let WinHandleOffice2(ByVal longWinHandleOffice2 As Long)
5   mlonglWinHandleOffice2 = longWinHandleOffice2
End Property

Public Property Get ClientWindowTitle() As String
5   ClientWindowTitle = mstrClientWindowTitle
End Property

Public Property Let ClientWindowTitle(ByVal strClientWindowTitle As String)
5   mstrClientWindowTitle = strClientWindowTitle
End Property

Public Property Get WeFilePrefixWithCurrentPid() As String
5   WeFilePrefixWithCurrentPid = mstrWeFilePrefixWithCurrentPid
End Property

Public Property Let WeFilePrefixWithCurrentPid(ByVal strWeFilePrefixWithCurrentPid As String)
5   mstrWeFilePrefixWithCurrentPid = strWeFilePrefixWithCurrentPid
End Property

Public Property Get IsAPrinterInstalled() As Boolean
5   IsAPrinterInstalled = mboolIsAPrinterInstalled
End Property

Public Property Let IsAPrinterInstalled(ByVal boolIsAPrinterInstalled As Boolean)
5   mboolIsAPrinterInstalled = boolIsAPrinterInstalled
End Property

Public Property Get DefaultPrinterName() As String
5   DefaultPrinterName = mstrDefaultPrinterName
End Property

Public Property Let DefaultPrinterName(ByVal strDefaultPrinterName As String)
5   mstrDefaultPrinterName = strDefaultPrinterName
End Property

Public Property Get WinworkPath() As String
5   WinworkPath = mstrWinworkPath
End Property

Public Property Let WinworkPath(ByVal strWinworkPath As String)
5   mstrWinworkPath = strWinworkPath
End Property

Public Property Get LogfileFullName() As String
5   LogfileFullName = mstrLogfileFullName
End Property

Public Property Let LogfileFullName(ByVal strLogfileFullName As String)
5   mstrLogfileFullName = strLogfileFullName
End Property

Public Property Get MaximizeWordAfterSessionClose() As Boolean
5   MaximizeWordAfterSessionClose = mboolWordMustStayOpen
End Property

Public Property Let MaximizeWordAfterSessionClose(ByVal vWordStayOpen As Boolean)
5   mboolWordMustStayOpen = vWordStayOpen
End Property

Public Property Get LastCallingApplication() As String
5   LastCallingApplication = mstrLastCallingApplication
End Property

Public Property Let LastCallingApplication(ByVal vApplication As String)
5   mstrLastCallingApplication = vApplication
End Property

Public Property Let RibbonInstalled(ByVal vRibbonInstalled As Boolean)
5   mboolSymbolbarInstalled = vRibbonInstalled
End Property

Public Property Get RibbonInstalled() As Boolean
5   RibbonInstalled = mboolSymbolbarInstalled
End Property

Public Property Get RibbonVisible() As Boolean
5   RibbonVisible = mboolRibbonVisible
End Property

Public Property Let RibbonVisible(ByVal vRibbonVisible As Boolean)
5   mboolRibbonVisible = vRibbonVisible
End Property

Public Property Get LogfileSafeToClose() As Boolean
5   LogfileSafeToClose = mboolIkolClientAppObjectTerminationAllowed
End Property

Public Property Let LogfileSafeToClose(ByVal boolSafeToTerminate As Boolean)
5   mboolIkolClientAppObjectTerminationAllowed = boolSafeToTerminate
End Property

Public Property Get ClientSessionAlreadyClosed() As Boolean
5   ClientSessionAlreadyClosed = mboolClientSessionAlreadyClosed
End Property

Public Property Let ClientSessionAlreadyClosed(ByVal boolClientSessionAlreadyClosed As Boolean)
5   mboolClientSessionAlreadyClosed = boolClientSessionAlreadyClosed
End Property

Public Property Get OriginalDoFileMoved() As Boolean
5   OriginalDoFileMoved = mboolOriginalDoFileMoved
End Property

Public Property Let OriginalDoFileMoved(ByVal boolOriginalDoFileMoved As Boolean)
5   mboolOriginalDoFileMoved = boolOriginalDoFileMoved
End Property

Public Property Get OriginalWeFileMoved() As Boolean
5   OriginalWeFileMoved = mboolOriginalWeFileMoved
End Property

Public Property Let OriginalWeFileMoved(ByVal boolOriginalWeFileMoved As Boolean)
5   mboolOriginalWeFileMoved = boolOriginalWeFileMoved
End Property

Public Property Get IsArcDirSet() As Boolean
5   IsArcDirSet = mboolIsArcDirSet
End Property

Public Property Let IsArcDirSet(ByVal boolIsArcDirSet As Boolean)
5   mboolIsArcDirSet = boolIsArcDirSet
End Property

Public Property Get IsArcPrinterSet() As Boolean
5   IsArcPrinterSet = mboolIsArcPrinterSet
End Property

Public Property Let IsArcPrinterSet(ByVal boolIsArcPrinterSet As Boolean)
5   mboolIsArcPrinterSet = boolIsArcPrinterSet
End Property

Public Property Get AtLeastOneEakteButton() As Boolean
5   AtLeastOneEakteButton = mboolAtLeastOneEakteButton
End Property

Public Property Let AtLeastOneEakteButton(ByVal boolAtLeastOneEakteButton As Boolean)
5   mboolAtLeastOneEakteButton = boolAtLeastOneEakteButton
End Property


' read-only
Public Property Get TimeCreate() As String
5   TimeCreate = mstrTimeCreate
End Property


'---------------------------------------------------------------------------------------
' Prozedur : DisplaySymbolBar
' Autor    : Todor Vachkov
' Datum    : 19.08.2013
' Zweck    :
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:   keine
'
' |fffd|bergabeparams:   Boolean: ein- oder ausblenden
'---------------------------------------------------------------------------------------
Public Sub DisplaySymbolBar(boolVisible As Boolean)
5   On Error GoTo RaiseErrorHandler

10  Me.RibbonVisible = boolVisible

15  If boolVisible Then
20      Call Me.LogfileHandler.M_Protokoll("TC_IkolClientApp::DisplaySymbolBar: Aufrufen von Symbolbar::Show", Me.SessionsContainer.GetActiveSession)
25      Application.Run "Symbolbar.Show"
30  Else
35      Call Me.LogfileHandler.M_Protokoll("TC_IkolClientApp::DisplaySymbolBar: Aufrufen von Symbolbar::Hide", Me.SessionsContainer.GetActiveSession)
40      Application.Run "Symbolbar.Hide"
45  End If

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_IkolClientApp::DisplaySymbolBar" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Sub

Public Sub CloseSession(session As TC_Session, boolCallerIsAnEvent As Boolean, strCallerProc As String)
    ' Aufruf nur beim letzten Schliessen eines TC_Dokuments, Vorraussetzung Symbolbar ist nicht aktiv
    ' wird nur durch den EventHandler gerufen

    Dim tcResult As TC_SessionResult
    Dim boolMinimizeWord As Boolean                   ' wird MS Word zum Schlu|fffd| maximiert od. nicht
    Dim intFokusOnWord As Integer
    Dim intDocumentsCountForCompareWith As Integer

5   On Error GoTo RaiseErrorHandler

10  Me.ClientSessionAlreadyClosed = False
15  intDocumentsCountForCompareWith = 0

20  If boolCallerIsAnEvent Then
25      intDocumentsCountForCompareWith = 1
30  End If

35  Call Me.LogfileHandler.M_Protokoll("Start TC_IkolClientApp::CloseSession in " & strCallerProc, session)
40  Call Me.LogfileHandler.M_Protokoll("TC_IkolClientApp::CloseSession - aktuelles Verzeichnis = [" & CurDir & "]", session)

    ' sicherheitshalber die WE und DO zur Session bereinigen
45  If Me.FileHandler.FileExist(session.WeFullFileName) And session.WeFullFileName <> vbNullString Then
50      Call Me.LogfileHandler.M_Protokoll("TC_IkolClientApp::CloseSession: BEREINIGUNG - Entferne die WE-Datei zur Session", session)
55      Me.FileHandler.DeleteFile session.WeFullFileName, session
60  End If

65  If Me.FileHandler.FileExist(session.DoFullFileName) And session.DoFullFileName <> vbNullString Then
70      Call Me.LogfileHandler.M_Protokoll("TC_IkolClientApp::CloseSession: BEREINIGUNG - Entferne die DO-Datei zur Session", session)
75      Me.FileHandler.DeleteFile session.DoFullFileName, session
80  End If

85  boolMinimizeWord = Not session.MaximizeWordAfterSessionClose

90  Call session.ManagedTCDocumentsContainer.RestoreDocProtections

95  Call Me.SessionsContainer.RemoveSession(session)

    ' hier sicherstellen, dass die Eigenschaften belegt sind
100 If session.CallingApplName = vbNullString Then
105     session.CallingApplName = Me.ClientWindowTitle
110 End If

115 If session.ApplicationPID = 0 Then
120     session.ApplicationPID = Me.ClientPid
125 End If

130 If Not session.fokusOnWord Then
        ' wenn nicht MS Word, sondern die rufende Anwendung aktiviert werden muss

135     tcResult = Me.ApplicationHandler.ActivateApplication(session.CallingApplName, session)

        ' wenn das Aktivieren der rufenden Anwenung fehlgeschlagen hat, aktiviere Word selbst
140     If tcResult <> tcrOK Then
            ' aktivieren von Word und nicht minimieren
145         tcResult = Me.ApplicationHandler.ActivateApplication(Word.Application.Caption, session)
150         session.fokusOnWord = session.fokusOnWord Or gintNO_APPLICATION_FOR_FOKUS
155         Call Me.LogfileHandler.ProtokollMsg("konnte Applikation nicht aktivieren: session.fokusOnWord: " & session.fokusOnWord)
160         boolMinimizeWord = False
165     End If
170 End If

175 intFokusOnWord = session.fokusOnWord
180 If Me.SessionsContainer.CheckAllSessionsDeleted = tcrEnd Then
        ' sicherstellen, dass alle Sessions entfernt worden sind

185     intFokusOnWord = intFokusOnWord And Not gintLADE_AKTIV

190     Me.LogfileHandler.ProtokollMsg ("TC_IkolClientApp::CloseSession -->" & _
                                      " Fokushandling: MS Word im Vordergrund=" & intFokusOnWord & _
                                        ", MS Word minimieren=" & boolMinimizeWord & _
                                        ", Documents.count=" & Documents.count)
195     If intFokusOnWord = 0 And _
           boolMinimizeWord And _
           Documents.count <= intDocumentsCountForCompareWith Then
200         Call Me.LogfileHandler.ProtokollMsg("TC_IkolClientApp:CloseSession: Setze Application.WindowState auf wdWindowStateMinimize")
205         Application.WindowState = wdWindowStateMinimize
210     End If
215 End If

ExitProc:
220 Call Me.LogfileHandler.ProtokollMsg("Beende TC_IkolClientApp::CloseSession in " & strCallerProc)
225 Me.ClientSessionAlreadyClosed = True
230 Me.LogfileSafeToClose = True
235 If CBool(IsWindow(Me.WinHandleOffice2)) Then
240     Call Me.LogfileHandler.ProtokollMsg("TC_IkolClientApp:CloseSessionCloseSession: POST_MESSAGE an WinHnd [" & Me.WinHandleOffice2 & "] mit EXIT-CODE [" & glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS & "]")
245     PostMessage CLng(Me.WinHandleOffice2), CLng(glongWM_CLOSE), CLng(glongEXIT_CODE_IKOL_CLIENTAPP_CLOSE_SUCCESS), 0
250 End If
255 DoEvents
260 Exit Sub

RaiseErrorHandler:
265 Err.Raise Err.Number, Err.Source & "->" & "TC_IkolClientApp::CloseSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
270 Resume ExitProc
End Sub


Attribute VB_Name = "TC_LogfileHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' ========================================================================================
' Deklaration der ben|fffd|tigten globalen Variablen und Typen f|fffd|r die Task- und Windowslist Ausgaben

Private Type tWindows
    WndText As String
    WndClass As String
    WndHwdn As Long
    visible As Boolean
    maxim As Boolean
    minim As Boolean
End Type

Private mobjParentIkolClientApp As TC_IkolClientApp

Private mobjDotProtokollDateiTextStream As TextStream
Private mobjSavedProtokollDateiTextStream As TextStream

Private WindowsListForProtokoll(1000) As tWindows

' der Iterator f|fffd|r das Durchlaufen der Fenster
Private wndCnt As Integer

Private MaxWndTextLen As Long
Private MaxWndClassLen As Long

Private Const generalIndent As Integer = 28

' Workaround, damit auf vormals als konstant definierte Werte zugegriffen werden kann (s. auskommentierten Block oben)

' read-only Abfrage der Konstanten
Public Property Get phNoMsgBox() As Boolean
5   phNoMsgBox = False
End Property

Public Property Get phWithMsgBox() As Boolean
5   phWithMsgBox = True
End Property

Public Property Get phMakroCancel() As Boolean
5   phMakroCancel = False
End Property

Public Property Get phMakroContinue() As Boolean
5   phMakroContinue = True
End Property

Private Sub Class_Initialize()
5   Set mobjSavedProtokollDateiTextStream = Nothing
10  Set mobjDotProtokollDateiTextStream = Nothing
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjSavedProtokollDateiTextStream Is Nothing Then
10      Set mobjSavedProtokollDateiTextStream = Nothing
15  End If

20  If Not mobjDotProtokollDateiTextStream Is Nothing Then
25      Set mobjDotProtokollDateiTextStream = Nothing
30  End If

35  If Not mobjParentIkolClientApp Is Nothing Then
40      Set mobjParentIkolClientApp = Nothing
45  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_LogfileHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get DotProtokollDateiTextStream() As TextStream
5   Set DotProtokollDateiTextStream = mobjDotProtokollDateiTextStream
End Property

Public Property Get SavedProtokollDatei() As TextStream
5   Set SavedProtokollDatei = mobjSavedProtokollDateiTextStream
End Property

Public Function IsLoggingActive() As Boolean
5   IsLoggingActive = Not Me.DotProtokollDateiTextStream Is Nothing
End Function


Public Sub MyWriteLine(lineText As String)
5   If Not Me.DotProtokollDateiTextStream Is Nothing Then
10      Call Me.DotProtokollDateiTextStream.WriteLine(lineText)
15  End If

20  If Not (Me.SavedProtokollDatei Is Nothing) Then
25      Call Me.SavedProtokollDatei.WriteLine(lineText)
30  End If

End Sub


Public Function RCDescription(tc_rcode As TC_SessionResult) As String
    Dim msgStr As String

5   Select Case tc_rcode
        Case tcrOK
10          msgStr = "OK"
15      Case tcrWarning
20          msgStr = "Warnung"
25      Case tcrEnd
30          msgStr = "Session kann beendet werden"
35      Case tcrNoEnd
40          msgStr = "Session kann noch nicht beendet werden"
45      Case tcrNoCommand
50          msgStr = "kein Befehl vorhanden"
55      Case tcrWrongCommand
60          msgStr = "falscher Befehl"
65      Case tcrParameterErr
70          msgStr = "Fehler im Parameter"
75      Case tcrParameterWarning
80          msgStr = "Warnung: fehlerhafter Parameter"
85      Case tcrWrongVersionFormat
90          msgStr = "falsches Versionsformat"
95      Case tcrWrongVersion
100         msgStr = "falsche Schnittstellenversion"
105     Case tcrOpenError
110         msgStr = "Fehler beim |fffd|ffnen"
115     Case tcrJoinError
120         msgStr = "Fehler beim Verbinden"
125     Case tcrMergeError
130         msgStr = "Fehler beim Mischen"
135     Case tcrPrintError
140         msgStr = "Fehler beim Drucken"
145     Case tcrFileNotFound
150         msgStr = "Datei nicht gefunden"
155     Case tcrCallError
160         msgStr = "Fehler beim Aufruf des Befehls"
165     Case tcrSaveError
170         msgStr = "Fehler beim Speichern"
175     Case tcrFokusError
180         msgStr = "Fehler beim Setzen des Fokus"
185     Case tcreAkteError
190         msgStr = "Fehler beim Behandeln der eAkte"
195     Case Else
200         msgStr = "unbekannter TC-Fehler"
205 End Select

210 RCDescription = "'" & msgStr & "'[Code: " & tc_rcode & "]"

End Function

Public Function ProtectDescription(wdpr As WdProtectionType) As String

5   Select Case wdpr
        Case wdNoProtection                           ' -1
10          ProtectDescription = "kein Schutz"
15      Case wdAllowOnlyRevisions                     ' 0
20          ProtectDescription = "nur |fffd|nderungen verfolgen"
25      Case wdAllowOnlyComments                      ' 1
30          ProtectDescription = "nur Kommentare"
35      Case wdAllowOnlyFormFields                    ' 2
40          ProtectDescription = "nur Formulareingabe"
45      Case 3                                        ' wdAllowOnlyReading
50          ProtectDescription = "nur lesbar"
55      Case Else
60          ProtectDescription = wdpr & "(unbekannter ProtectionTyp)"
65  End Select

End Function

Public Function PrintOutPagesDescr(wdPrOP As WdPrintOutPages) As String

5   Select Case wdPrOP
        Case wdPrintAllPages
10          PrintOutPagesDescr = "Alle Seiten des Dokuments"
15      Case wdPrintEvenPagesOnly
20          PrintOutPagesDescr = "nur gerade Seiten des Dokuments"
25      Case wdPrintOddPagesOnly
30          PrintOutPagesDescr = "nur ungerade Seiten des Dokuments"
35      Case Else
40          PrintOutPagesDescr = wdPrOP & "(unbekannter PrintOutPages-Typ)"
45  End Select

End Function

Public Function PrintOutItemDescr(wdPrOI As WdPrintOutItem) As String

5   Select Case wdPrOI
        Case wdPrintAutoTextEntries
10          PrintOutItemDescr = "Drucke AutoText-Eintr|fffd|ge"
15      Case wdPrintComments
20          PrintOutItemDescr = "Drucke Kommentare"
25      Case wdPrintDocumentContent
30          PrintOutItemDescr = "Drucke nur Dokument"
35      Case wdPrintEnvelope
40          PrintOutItemDescr = "Drucke Briefumschl|fffd|ge"
45      Case wdPrintKeyAssignments
50          PrintOutItemDescr = "Drucke Tastenbelegungen"
55      Case wdPrintProperties
60          PrintOutItemDescr = "Drucke Dokumenteigenschaften"
65      Case wdPrintStyles
70          PrintOutItemDescr = "Drucke Formatvorlagen"
75      Case 7                                        'wdPrintDocumentWithMarkup  f|fffd|r Word 2000
80          PrintOutItemDescr = "Drucke Dokument mit Bearbeitungen"
85      Case 2                                        'wdPrintMarkup                f|fffd|r Word 2000
90          PrintOutItemDescr = "Drucke Markup-Liste"
95      Case Else
100         PrintOutItemDescr = wdPrOI & "(unbekannter PrintOutItem-Typ)"
105 End Select

End Function

Public Function PrintOutRangeDescr(wdPrOR As WdPrintOutRange) As String

5   Select Case wdPrOR
        Case wdPrintAllDocument
10          PrintOutRangeDescr = "gesamtes Dokument"
15      Case wdPrintCurrentPage
20          PrintOutRangeDescr = "aktuelle Seite"
25      Case wdPrintFromTo
30          PrintOutRangeDescr = "Drucke von - bis"
35      Case wdPrintRangeOfPages
40          PrintOutRangeDescr = "Drucke benutzerdefinierten Bereich"
45      Case wdPrintSelection
50          PrintOutRangeDescr = "Drucke Markierung"
55      Case Else
60          PrintOutRangeDescr = wdPrOR & "(unbekannter PrintOutRange-Typ)"
65  End Select

End Function


Public Sub AppendFileToProtokoll(filename As String, session As TC_Session, boolEncrypt As Boolean)
    Dim objFSO As New FileSystemObject
    Dim copyFile As TextStream
    Dim strReadBuffer As String
    ' Dim strEncryptedReadBuffer As String ' soll der Inhalt der DO-Datei base64-verschl|fffd|sselt in die Protokolldatei |fffd|bernommen werden

5   On Error GoTo RaiseErrorHandler

10  If objFSO.FileExists(filename) Then
15      Set copyFile = objFSO.OpenTextFile(filename, ForReading, False)
20      strReadBuffer = copyFile.ReadAll

25      copyFile.Close
30      Set copyFile = Nothing

35      If Not Me.DotProtokollDateiTextStream Is Nothing Then

40          If boolEncrypt Then
45              strReadBuffer = Me.ParentIkolClientApp.Tools.dhXORText(Me.ParentIkolClientApp.Tools.Encode64(strReadBuffer))
50          End If

55          Call Me.DotProtokollDateiTextStream.Write(strReadBuffer)

60          If Not ((Right(strReadBuffer, 1) = vbLf) Or (Right(strReadBuffer, 2) = vbCrLf)) Then
65              Call Me.DotProtokollDateiTextStream.Write(vbCrLf)
70          End If
75      End If

80      If Not (Me.SavedProtokollDatei Is Nothing) Then
85          Call Me.SavedProtokollDatei.WriteLine(strReadBuffer)
90      End If

95  Else
100     Call Me.M_Protokoll("zu kopierende Datei " & filename & " kann nicht ge|fffd|ffnet werden", session)
105 End If

ExitProc:
110 Set objFSO = Nothing
115 Exit Sub

RaiseErrorHandler:
120 Err.Raise Err.Number, Err.Source & "->" & "TC_LogfileHandler::AppendFileToProtokoll in Zeile:" & Erl & vbCrLf, Err.Description
125 Resume ExitProc
End Sub


Public Function FileOpenError(filename As String, ignoreMsg As String) As VbMsgBoxResult
    Dim errMsg As String
    Dim title As String

5   errMsg = "Fehler beim |fffd|ffnen der Datei " & Chr(34) & filename & Chr(34) & vbLf & _
             "Error(" & Err.Number & "): " & Err.Description & vbLf & _
             "'Ignorieren' - " & ignoreMsg
10  title = gstrTC_OFFICE_MSGBOXTITLE
15  FileOpenError = MsgBox(errMsg, vbAbortRetryIgnore, title)

End Function

Public Function CreateFileForWriting(filename As String, ignoreMsg As String) As VbMsgBoxResult
    Dim FSO As New FileSystemObject
    Dim openFile As TextStream
    On Error GoTo openFileError:

5   Set openFile = FSO.CreateTextFile(filename, True)
10  openFile.Close
15  Set FSO = Nothing
20  Set openFile = Nothing
25  CreateFileForWriting = vbOK

30  Exit Function

openFileError:
35  CreateFileForWriting = FileOpenError(filename, ignoreMsg)
40  Set FSO = Nothing
45  Exit Function

End Function

Public Function OpenExistingFileForWriting(filename As String, _
                                           ignoreMsg As String, _
                                           openFile As TextStream) As VbMsgBoxResult
    Dim FSO As New FileSystemObject
    On Error GoTo openError:

5   Set openFile = FSO.OpenTextFile(filename, ForAppending)
10  Set FSO = Nothing
15  OpenExistingFileForWriting = vbOK

20  Exit Function

openError:
25  Set openFile = Nothing
30  Set FSO = Nothing
35  OpenExistingFileForWriting = Me.FileOpenError(filename, ignoreMsg)
40  Exit Function

End Function

Public Function OpenFileForWriting(filename As String, _
                                   append As Boolean, _
                                   ignoreMsg As String, _
                                   openFile As TextStream) As Boolean
    'vollst|fffd|ndige Dateinamen der Protokolldatei muss angegeben werden
    Dim FSO As New FileSystemObject
    Dim rc As VbMsgBoxResult

5   rc = vbOK
10  Set openFile = Nothing

15  If Not (FSO.FileExists(filename) And append) Then    'Datei leeren oder erzeugen
20      Do
25          rc = CreateFileForWriting(filename, ignoreMsg)
30      Loop While rc = vbRetry
35  End If
40  Set FSO = Nothing

45  If rc = vbOK Then
50      Do
55          rc = OpenExistingFileForWriting(filename, ignoreMsg, openFile)
60      Loop While rc = vbRetry
65  End If
70  OpenFileForWriting = (rc <> vbAbort)


End Function


Public Sub OpenExistingLogfileForWriting(strLogfileName As String)

5   On Error GoTo RaiseErrorHandler

    Dim FSO As New FileSystemObject
    Dim enumUserResponse As VbMsgBoxResult

    ' pr|fffd|fen, ob die angebene Datei da ist
10  If Not FSO.FileExists(strLogfileName) Then
        ' den Benutzer fragen ist es OK f|fffd|r ihn, ohne Protokoll fortzufahren
15      enumUserResponse = MsgBox("Es gab Probleme mit dem Auffinden der Protokoll-Datei." & vbCrLf & " Ohne Protokoll-Datei fortfahren?", vbOKCancel, "Office-Schnittstelle 2.0 (" & gstrOS2_VERSION & ") - " & gstrTemplateFileName)
20      If enumUserResponse = vbCancel Then
25          Err.Raise glongCUSTOM_ERR_LOGFILE_NOT_FOUND_FOR_DOT, "TC_LogfileHandler.OpenExistingLogfileForWriting", "Die " & gstrTemplateFileName & " findet nicht die '" & strLogfileName & "'-Protokolldatei zum Schreiben." & vbCrLf & _
                                                                                                                    "Abbruch auf Wunsch des Benutzers"
30      End If
35  Else
40      Set mobjDotProtokollDateiTextStream = FSO.OpenTextFile(strLogfileName, ForAppending)
45      Call Me.WriteEmptyProtokollLine
50      Call Me.General_ProtokollMsg("DOT", "Der Protokoll-TextStream wurde erfolgreich initialisiert.")
55      Call Me.General_ProtokollMsg("DOT", "Die aktuelle Schnittstellen-Version:  " & Me.ParentIkolClientApp.Os2Version)
60      Call Me.General_ProtokollMsg("DOT", "Build:                   " & Me.ParentIkolClientApp.BuildVersion)
65      Call Me.WriteEmptyProtokollLine

70  End If

ExitProc:
75  Set FSO = Nothing
80  Exit Sub

RaiseErrorHandler:
85  Err.Raise Err.Number, "TC_LogfileHandler::OpenExistingLogfileForWriting" & " in Zeile:" & Erl & vbCrLf, Err.Description
90  Resume ExitProc
End Sub

Public Sub CloseLogfileTextStream()

10    On Error GoTo RaiseErrorHandler

20    If Not Me.DotProtokollDateiTextStream Is Nothing Then
30      Me.ProtokollMsg ("TC_LogfileHandler::CloseLogfileTextStream: Protokolldatei '" & Me.ParentIkolClientApp.LogfileFullName & "' wird geschlossen")
40      Me.DotProtokollDateiTextStream.Close

50      If Not Me.SavedProtokollDatei Is Nothing Then
60          Me.SavedProtokollDatei.Close
70      End If

        '18.07.2014 AL
        'drvword.exe ab Version 5.2.0.16 macht immer neue Word-Instanz auf
        'Deshalb muss ab nun Word komplett geschlossen werden.
        'Durch das if funktioniert es auch mit einer |fffd|lteren Version von drvword.exe
        'Application.quit funktioniert nicht zuverl|fffd|ssig - st|fffd|rzt ab. Deshalb die winapi Funktion.
        Dim anzDocs As Integer
        Dim session As TC_Session
        
80      anzDocs = Application.Documents.count
        'MsgBox (anzDocs)
90      If anzDocs = 0 Then
          
          '14.07.2016
100       If gboolNormalDotSaved = True Then
110         'MsgBox "CloseLogfileTextStream: NormalDotSaved = AN"
120         Application.NormalTemplate.Saved = True
130       End If

        
          '29.01.2016 AL
          
          '04.02.2016 AL
          'auskommentiert, da nicht n|fffd|tig
          'Prozess-ID von dieser Word-Instanz ermitteln
          'Dim hProcThis As Long
          'hProcThis = GetCurrentProcessId
          'ENDE '04.02.2016 AL
  
          'Fenstertitel
          Dim strDocumentTitle As String
140       strDocumentTitle = Word.Application.Caption 'objCurrentDoc.ActiveWindow.Caption & " - " & Word.Application.Caption
          'auskommentiert am 04.02.2016 AL, verursacht Absturz in Mettmann: AppActivate strDocumentTitle
          'MsgBox strDocumentTitle
  
          'Fensterhandle
          Dim longHwnd As Long
150       longHwnd = Me.ParentIkolClientApp.Tools.FindOurWindow("OpusApp", strDocumentTitle)
          'MsgBox longHwnd
           
          'Word-Instanz schliessen
160       Call PostMessage(longHwnd&, glongWM_CLOSE, 0&, 0&)
  
          'dies klappt nicht mehr, seit Word in einer eigenen Instanz gestartet wird
          'Application.Quit SaveChanges:=False
          
          'dies f|fffd|hrte dazu, dass tempor|fffd|re Dateien nicht gel|fffd|scht werden in:
          '"%localappdata%\Microsoft\Windows\Temporary Internet Files\Content.Word\
          'ExitProcess (0)
          'ENDE '29.01.2016 AL
170     End If
        'ENDE 18.07.2014 AL

180   End If

ExitProc:
190   Exit Sub

RaiseErrorHandler:
200   Err.Raise Err.Number, Err.Source & "->" & "TC_LogfileHandler::CloseLogfileTextStream" & " in Zeile:" & Erl & vbCrLf, Err.Description
210   Resume ExitProc
End Sub

Public Sub WriteEmptyProtokollLine()
5   Call MyWriteLine(vbNullString)
End Sub


Public Sub General_ProtokollMsg(tag As String, ByVal msg As String)
    Dim beginMarker As String
    Dim endMarker As String

5   beginMarker = "<<<<<  "
10  endMarker = "  >>>>>"
15  If Not Me.DotProtokollDateiTextStream Is Nothing Then
20      msg = Replace(msg, vbCrLf, vbLf)
25      msg = Replace(msg, vbLf, vbCrLf & Space(generalIndent + Len(beginMarker)))
30      Me.MyWriteLine GetFormattedTime() & " * " & tag & " *     " & Space(10) & beginMarker & msg & endMarker
35  End If

End Sub

Public Sub ProtokollMsg(ByVal msg As String)
5   Call Me.General_ProtokollMsg("DOT", msg)
End Sub

Public Sub General_Protokoll(tag As String, ByVal msg As String, session As TC_Session)
5   If session.withProtokoll Then
10      If Not Me.DotProtokollDateiTextStream Is Nothing Then
15          msg = Replace(msg, vbCrLf, vbLf)
20          msg = Replace(msg, vbLf, vbCrLf & Space(generalIndent))
25          Me.MyWriteLine GetFormattedTime() & " * " & tag & " * - " & session.SessionID & ": " & session.indent & msg
30      End If
35  End If
End Sub

Public Sub M_Protokoll(ByVal msg As String, session As TC_Session)
5   Call Me.General_Protokoll("DOT", msg, session)
End Sub

Public Sub CopyFileToProtokoll(filename As String, markerString As String, session As TC_Session, boolEncrypt As Boolean)
5   On Error GoTo RaiseErrorHandler

10  Call Me.WriteEmptyProtokollLine
15  Call Me.MyWriteLine("======================= Kopie der Datei " & filename)

20  Call Me.MyWriteLine(markerString)
25  Call Me.AppendFileToProtokoll(filename, session, boolEncrypt)
30  Call Me.MyWriteLine(markerString)

35  Call Me.MyWriteLine("======================= Ende der Kopie ")
40  Call Me.WriteEmptyProtokollLine

ExitProc:
45  Exit Sub

RaiseErrorHandler:
50  Err.Raise Err.Number, Err.Source & "->" & "TC_LogfileHandler::CopyFileToProtokoll in Zeile:" & Erl & vbCrLf, Err.Description
55  Resume ExitProc
End Sub

Public Sub myError_Msg(subName As String, session As TC_Session)
    Dim errMsg As String

5   errMsg = "FEHLER in " & subName & "Fehler (" & Err.Number & "): " & Err.Description
10  Call Me.M_Protokoll(errMsg, session)

End Sub

Public Sub ViewGeneralMsgBox(msg As String)
    Dim curScreenUpdating As Boolean

5   curScreenUpdating = Application.ScreenUpdating
10  If Not curScreenUpdating Then
15      Application.ScreenUpdating = True
20  End If

25  Call MsgBox(msg, vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30  Application.ScreenUpdating = curScreenUpdating
End Sub

Public Sub ViewMsgbox(msg As String, session As TC_Session)
    Dim curScreenUpdating As Boolean

5   curScreenUpdating = Application.ScreenUpdating
10  If Not curScreenUpdating Then
15      Application.ScreenUpdating = True
20  End If

25  Call MsgBox(msg, vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
30  Application.ScreenUpdating = curScreenUpdating
End Sub

Public Function DispayYNmsgBox(strMsg As String) As VbMsgBoxResult

    Dim curScreenUpdating As Boolean
    Dim retMsgBoxResult As VbMsgBoxResult

5   curScreenUpdating = Application.ScreenUpdating
10  If Not curScreenUpdating Then
15      Application.ScreenUpdating = True
20  End If

25  retMsgBoxResult = MsgBox(strMsg, vbYesNo, Me.ParentIkolClientApp.MsgBoxTitle)
30  Application.ScreenUpdating = curScreenUpdating

35  DispayYNmsgBox = retMsgBoxResult

End Function

Public Sub ViewMsgboxWithProtokoll(msg As String, session As TC_Session)
5   Call Me.M_Protokoll(msg, session)
10  Call Me.ViewMsgbox(msg, session)
End Sub


Public Sub DoSimpleErrorMessage(makroName As String, _
                                errorMsg As String, _
                                continueMakro As Boolean, _
                                withMsgBox As Boolean)
5   If Len(errorMsg) = 0 Then
10      errorMsg = "Fehler in " & makroName & " - Fehlermeldung:" & vbLf & _
                   "Error(" & Err.Number & "): " & Err.Description
15  End If

20  If Not continueMakro Then
25      errorMsg = errorMsg & vbLf & "Die Befehlsfolge wird abgebrochen."
30  End If

35  Call Me.ProtokollMsg(errorMsg)

40  If withMsgBox Then
45      Me.ViewGeneralMsgBox errorMsg
50  End If

End Sub

'Public Sub DoErrorHandling(session As TC_Session, _
 '                           makroName As String, _
 '                           errorMsg As String, _
 '                           continueMakro As Boolean, _
 '                           withMsgBox As Boolean)
'
'5   If Len(errorMsg) = 0 Then
'
'10      If Err.Number = -2147352573 Then
'            ' dieser Fehler kommt, wenn das erwartete Makro nicht gefunden wurde
'15          If session.workingDocument Is Nothing Then
'20              errorMsg = "Fehler in " & makroName & " - Fehlermeldung:" & vbLf & _
 '                           "Error(" & Err.Number & "): " & Err.Description & _
 '                         " |fffd|berpr|fffd|fen Sie bitte, ob dieser zu dem Button zugewiesene Makro vorhanden ist."
'25          Else
'30              errorMsg = "Fehler in " & makroName & " bei Dokument " & session.workingDocument.name & " " & vbLf & _
 '                           "Error(" & Err.Number & "): " & Err.Description & _
 '                         " |fffd|berpr|fffd|fen Sie bitte, ob dieser zu dem Button zugewiesene Makro vorhanden ist."
'35          End If
'
'40      Else
'45          If session.workingDocument Is Nothing Then
'50              errorMsg = "Fehler in " & makroName & " - Fehlermeldung:" & vbLf & _
 '                           "Error(" & Err.Number & "): " & Err.Description
'55          Else
'60              errorMsg = "Fehler in " & makroName & " bei Dokument " & session.workingDocument.name & " " & vbLf & _
 '                           "Error(" & Err.Number & "): " & Err.Description
'65          End If
'70      End If
'
'75  End If
'
'80  If Not continueMakro Then
'85      errorMsg = errorMsg & vbCrLf & "Die Befehlsfolge wird abgebrochen."
'90  End If
'
'95  Call Me.M_Protokoll(errorMsg, session)
'
'100 If withMsgBox Then
'105     Me.ViewMsgbox errorMsg, session
'110 End If
'
'End Sub

Public Sub DoSystemErrorHandling(session As TC_Session, _
                                 makroName As String, _
                                 continueMakro As Boolean, _
                                 withMsgBox As Boolean)
    Dim errorMsg As String

5   If session.workingDocument Is Nothing Then
10      errorMsg = "Fehler in " & makroName & " - Fehlermeldung:" & vbLf & _
                   "Error(" & Err.LastDllError & "): " & ErrorDescription(Err.LastDllError)
15  Else
20      errorMsg = "Fehler in " & makroName & " bei Dokument " & session.workingDocument.name & " " & vbLf & _
                   "Error(" & Err.LastDllError & "): " & ErrorDescription(Err.LastDllError)
25  End If
30  If Not continueMakro Then
35      errorMsg = errorMsg & vbCrLf & "Die Befehlsfolge wird abgebrochen."
40  End If
45  Call Me.M_Protokoll(errorMsg, session)
50  If withMsgBox Then
55      Me.ViewMsgbox errorMsg, session
60  End If

End Sub

'Public Sub HandleError5174(session As TC_Session, _
 '                           makroName As String, _
 '                           fileName As String, _
 '                           continueMakro As Boolean, _
 '                           withMsgBox As Boolean)
'    Dim errorMsg As String
'
'5   errorMsg = fileName & " nicht gefunden." & vbLf & _
 '               "Error(" & Err.Number & "): " & Err.Description
'
'10  Call Me.DoErrorHandling(session, makroName, errorMsg, continueMakro, withMsgBox)
'15  Exit Sub
'End Sub

Public Sub WriteWindowHandlingLogfile(windowTitle As String, makroName As String, session As TC_Session)
    Dim oTask As Task
    Dim errorMsg As String
    Dim returnVal As Long
    Dim i As Integer

5   If session.withProtokoll Then

10      errorMsg = "Das Ansteuern/Aufrufen eines anderen Fensters/Anwendung ist fehlgeschlagen!" & vbLf & _
                   "Es wurden Informationen zu dieser Aktion in die Protokoll-Datei geschrieben" & vbLf & _
                   "Bitte senden Sie die Protokolldatei zu Analysezwecken an die Telecomputer GmbH!"
15      errorMsg = "Fehler in " & makroName & " bei Dokument " & session.workingDocument.name & vbLf & errorMsg

20      Call Me.ViewMsgbox(errorMsg, session)
25      Call Me.M_Protokoll(errorMsg, session)
30      Call Me.M_Protokoll(vbNullString, session)
35      Call Me.M_Protokoll("gesuchte Task nicht gefunden, Ausgabe der Windowliste", session)
40      Call Me.M_Protokoll("gesucht wurde: " & Chr(34) & windowTitle & Chr(34), session)
45      Call Me.M_Protokoll(vbNullString, session)
50      Call Me.M_Protokoll("~~~~~~ Liste der augenblicklichen Fenster mit Titel und Eigenschaften ~~~~~~", session)
55      Call Me.M_Protokoll(vbNullString, session)

        ' Anzeige |fffd|ber Enumeration der Windows
60      wndCnt = 0                                    'wird Global durch die Call-Back-Prozedur EnumProc in EnumWindows gesetzt.
65      MaxWndTextLen = 0
70      MaxWndClassLen = 0
75      returnVal = EnumWindows(AddressOf LogFileEnumProc, 0)    'Deklaration von EnumProc und der globalen Typen und Variablen am Anfang
80      MaxWndClassLen = MaxWndClassLen + 2
85      MaxWndTextLen = MaxWndTextLen + 2
90      Call Me.M_Protokoll(Me.ParentIkolClientApp.Tools.TabbedText("Hwnd", 10) & _
                            Me.ParentIkolClientApp.Tools.TabbedText("sichtbar", 10) & _
                            Me.ParentIkolClientApp.Tools.TabbedText("maximiert", 11) & _
                            Me.ParentIkolClientApp.Tools.TabbedText("minimiert", 11) & _
                            Me.ParentIkolClientApp.Tools.TabbedText("WindowClass", MaxWndClassLen) & _
                            Me.ParentIkolClientApp.Tools.TabbedText("WindowsText", MaxWndTextLen), session)

95      For i = 0 To wndCnt - 1
100         With WindowsListForProtokoll(i)
105             Call Me.M_Protokoll(Me.ParentIkolClientApp.Tools.TabbedText(vbNullString & .WndHwdn, 10) & _
                                    Me.ParentIkolClientApp.Tools.TabbedYN(.visible, 10) & _
                                    Me.ParentIkolClientApp.Tools.TabbedYN(.maxim, 11) & _
                                    Me.ParentIkolClientApp.Tools.TabbedYN(.minim, 11) & _
                                    Me.ParentIkolClientApp.Tools.TabbedText(.WndClass, MaxWndClassLen) & _
                                    Me.ParentIkolClientApp.Tools.TabbedText(.WndText, MaxWndTextLen), session)
110         End With
115     Next i
120 End If

End Sub

Public Sub ListAllOpenedWordDocuments(strProcedureName As String)

    ' gibt die Anzahl der ge|fffd|ffneten WORD-Dokumente (TC-Doks und andere insgesamt) zur|fffd|ck
    Dim currDoc As Document
    Dim indentString As String
    Dim cnt As Integer
    Dim cntStr As String

5   indentString = Space(Len(strProcedureName))

10  Call Me.ProtokollMsg(strProcedureName & " - Anzahl ge|fffd|ffneter Word-Dokumente:   " & Documents.count)

15  If Application.Documents.count > 0 Then
20      Call Me.ProtokollMsg(indentString & " - Die folgenden Word-Dokumente sind ge|fffd|ffnet:")

25      cnt = 1

30      For Each currDoc In Application.Documents
35          cntStr = Right("   " & cnt, 3)
40          Call Me.ProtokollMsg(indentString & cntStr & ": " & Chr(34) & currDoc.FullName & Chr(34))
45          cnt = cnt + 1
50      Next currDoc

55  End If

End Sub
Attribute VB_Name = "TC_MailMergeHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp


Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_MailMergeHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Function ChangeFormDataToMailMergeFields(objDoc As Document, session As TC_Session) As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Const LIST_DELIMITER As String = "|"

    Dim intCounter As Integer
    Dim fld As Field
    Dim ffld As FormField
    Dim dfld As MailMergeDataField
    Dim aBookmark As Bookmark
    Dim strMailMergeFieldList As String
    Dim strReferenz As String
    Dim arrstrReferenz_tmp() As String

10  If objDoc.Bookmarks.count < objDoc.FormFields.count Then
15      For Each ffld In objDoc.FormFields
20          With ffld.TextInput
                ' Der Typ des Feldes wird auf seinen eigenen bisherigen Typ gesetzt.
                ' Macht keinen Sinn, funktioniert aber einwandfrei...
25              .EditType .Type
30          End With
35      Next ffld
40  End If

    ' Sind |fffd|berhaupt Textfelder vorhanden? Sonst gleich raus.
45  If objDoc.Bookmarks.count < 1 Then
50      GoTo ExitProc
55  End If

    ' Pr|fffd|fung ob Dokument ein Serienbrief ist, da f|fffd|r die Ausf|fffd|hrung des Makros eine verkn|fffd|pfte Datenquelle ben|fffd|tigt wird
60  If objDoc.MailMerge.MainDocumentType = wdNotAMergeDocument Then
65      Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Der Befehl UMW_FORMULAR_SERIENBRIEF kann nicht ausgef|fffd|hrt werden." & vbLf & _
                                                              "Zum Austauschen von Textformularfeldern in Seriendruckfelder " & _
                                                              "muss das Dokument bereits mit einer Datenquelle verbunden sein!", session)
70      GoTo ExitProc
75  End If

    ' Zur sp|fffd|teren Pr|fffd|fung der Seriendruckfelder alle in der DO enthaltenen Namen zusammen ketten,
    ' so kann sp|fffd|ter mit InsStr() das Vorhandensein des Eintrages in der DO |fffd|berpr|fffd|ft werden

80  strMailMergeFieldList = LIST_DELIMITER

85  For Each dfld In objDoc.MailMerge.DataSource.DataFields
90      strMailMergeFieldList = strMailMergeFieldList + UCase(dfld.name) + LIST_DELIMITER
95  Next dfld

    ' Alle Felder durchgehen, sie k|fffd|nnten eine strReferenz auf ein Textformularfelder beinhalten
100 For Each fld In objDoc.Fields
        ' Ist das Feld eine strReferenz auf ein anderes Feld?
105     If fld.Type = wdFieldRef Then
            ' Name des Referenzfelds suchen
110         strReferenz = Trim(fld.Code.text)
            ' 1. Doppelte Leerzeichen entfernen
115         For intCounter = 4 To Len(strReferenz) Step 1
120             If Mid(strReferenz, intCounter, 2) = "  " Then
125                 strReferenz = Left(strReferenz, intCounter) + Mid(strReferenz, intCounter + 3)
130             End If
135         Next intCounter
            ' 2. Auftrennen in Einzelteile, (der zweite Wert ist interessant)
140         arrstrReferenz_tmp = Split(strReferenz, " ", 3)
145         strReferenz = arrstrReferenz_tmp(1)

            ' Bei allen Textformularfelder schauen, ob ein passender Eintrag in der DO vorhanden ist
150         If InStr(strMailMergeFieldList, LIST_DELIMITER + UCase(strReferenz) + LIST_DELIMITER) > 0 Then
                ' Falls vorhanden: Textformularfeld markieren und Seriendruckfeld einf|fffd|gen _
                  ' (das markierte Textformularfeld wird dadurch ersetzt)
155             fld.Select
160             objDoc.Fields.Add Range:=Selection.Range, _
                                  Type:=wdFieldMergeField, _
                                  text:=Chr(34) + UCase(strReferenz) + Chr(34)
165         Else
                ' Falls kein Eintrag in DO vorhanden: Meldung ausgeben, dass Eintrag fehlt und Textfeld stehen lassen
170             Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Die strReferenz auf " & Chr(34) & strReferenz & Chr(34) & _
                                                                    " kann nicht ausgetauscht werden," & vbLf & _
                                                                      "da es kein entsprechendes Feld in der Datenquelle gibt.", session)
175         End If
180     End If
185 Next

    ' Alle Textformularfelder durchgehen
190 For Each aBookmark In objDoc.Bookmarks
        ' Bei allen Textformularfeldern schauen, ob ein passender Eintrag in der DO vorhanden ist
195     If InStr(strMailMergeFieldList, LIST_DELIMITER + UCase(aBookmark.name) + LIST_DELIMITER) > 0 Then
            ' Falls vorhanden: Textformularfeld markieren und Seriendruckfeld einf|fffd|gen (das markierte Textformularfeld wird dadurch ersetzt)
200         aBookmark.Select
205         objDoc.Fields.Add Range:=Selection.Range, _
                              Type:=wdFieldMergeField, _
                              text:=Chr(34) & UCase(aBookmark.name) & Chr(34)
210     Else
            ' Falls kein Eintrag in DO vorhanden: Meldung ausgeben, dass Eintrag fehlt und Textformularfeld stehen lassen
215         Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Das Textformularfeld " & Chr(34) & aBookmark.name & Chr(34) & _
                                                                " kann nicht ausgetauscht werden," & vbLf & _
                                                                  "da es kein entsprechendes Feld in der Datenquelle gibt.", session)
220     End If
225 Next aBookmark


ExitProc:
230 Exit Function

RaiseErrorHandler:
235 Err.Raise Err.Number, Err.Source & "->" & "TC_MailMergeHandler::ChangeFormDataToMailMergeFields" & " in Zeile:" & Erl & vbCrLf, Err.Description
240 Resume ExitProc
End Function
Attribute VB_Name = "TC_Parameter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mstrParameterName As String
Private mstrParameterValue As String

Private Sub Class_Initialize()
5   mstrParameterName = vbNullString
10  mstrParameterValue = vbNullString
End Sub

Public Property Let ParameterName(ByVal vParameterName As String)
5   mstrParameterName = vParameterName
End Property

Public Property Get ParameterName() As String
5   ParameterName = mstrParameterName
End Property

Public Property Let ParameterValue(ByVal vParameterValue As String)
5   mstrParameterValue = vParameterValue
End Property

Public Property Get ParameterValue() As String
5   ParameterValue = mstrParameterValue
End Property

Attribute VB_Name = "TC_ParameterDescription"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Beschreibungsger|fffd|st f|fffd|r die Parameter eines jeden Makros, das laut WE.txt auszuf|fffd|hren ist

Public Enum EParameterType
    eptBoolean
    eptFileName
    eptWordText
    eptMakroName
    eptWindowTitle
    eptPrinterName
    eptCardinal
    eptControl
    eptConstantSet
    eptCommandBars
    eptDirName
    eptServerName
    eptPort
    eptEndOfLine
    eptVBAStyle
    eptText
    eptFreeParameter
    eptControlParameter
End Enum

Private mstrParameterName As String
Private menumParameterType As EParameterType
Private mstrParameterText As String
Private mboolOptionalParam As Boolean
Private mstrDefaultValue As String
Private mobjParentIkolClientApp As TC_IkolClientApp
Private mcolConstantSet As Collection

Private Sub Class_Initialize()
5   Set mcolConstantSet = Nothing
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If

20  If Not mcolConstantSet Is Nothing Then
25      Set mcolConstantSet = Nothing
30  End If

End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_ParameterDescription.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Let ParameterName(ByVal vParameterName As String)
5   mstrParameterName = vParameterName
End Property

Public Property Get ParameterName() As String
5   ParameterName = mstrParameterName
End Property

Public Property Let defaultValue(ByVal vDefaultValue As String)
5   mstrDefaultValue = vDefaultValue
End Property

Public Property Get defaultValue() As String
5   defaultValue = mstrDefaultValue
End Property

Public Property Let parameterType(ByVal vparamType As EParameterType)
5   menumParameterType = vparamType
End Property

Public Property Get parameterType() As EParameterType
5   parameterType = menumParameterType
End Property

Public Property Let ParameterText(ByVal paramText As String)
5   mstrParameterText = paramText
End Property

Public Property Get ParameterText() As String
5   ParameterText = mstrParameterText
End Property

Public Property Let OptionalParameter(ByVal vOptional As Boolean)
5   mboolOptionalParam = vOptional
End Property

Public Property Get OptionalParameter() As Boolean
5   OptionalParameter = mboolOptionalParam
End Property

Public Property Let ParameterConstants(ByVal vConstants As Collection)
5   Set mcolConstantSet = vConstants
End Property

Public Property Get ParameterConstants() As Collection
5   If mcolConstantSet Is Nothing Then
10      Set ParameterConstants = Nothing
15  Else
20      Set ParameterConstants = mcolConstantSet
25  End If
End Property

Private Function CreateConstantSetString() As String
    Dim i As Integer

5   CreateConstantSetString = "{"
10  For i = 1 To mcolConstantSet.count
15      If i > 1 Then
20          CreateConstantSetString = CreateConstantSetString & " | "
25      End If
30      CreateConstantSetString = CreateConstantSetString & "'" & mcolConstantSet.Item(i) & "'"
35  Next i
40  CreateConstantSetString = CreateConstantSetString & "}"

End Function

Public Function GetParameterDescription() As String

5   Select Case menumParameterType
        Case eptBoolean
10          GetParameterDescription = "0|1"
15      Case eptFileName
20          GetParameterDescription = "[Pfad/]DateiName"
25      Case eptMakroName
30          GetParameterDescription = "Zeichenkette ohne Leerzeichen"
35      Case eptWordText
40          GetParameterDescription = "Textfolge nach Word-Konventionen"
45      Case eptWindowTitle
50          GetParameterDescription = "Fenstertitel"
55      Case eptPrinterName
60          GetParameterDescription = "Druckername"
65      Case eptCardinal
70          GetParameterDescription = "positive ganze Zahl"
75      Case eptControl
80          GetParameterDescription = "bitgesteuert"
85      Case eptConstantSet
90          GetParameterDescription = CreateConstantSetString
95      Case eptCommandBars
100         GetParameterDescription = CreateConstantSetString
105         GetParameterDescription = GetParameterDescription & _
                                    " oder positionsbezogene Definition mit 0 und 1"
110     Case eptDirName
115         GetParameterDescription = "Verzeichnisname"
120     Case eptServerName
125         GetParameterDescription = "ServerName"
130     Case eptPort
135         GetParameterDescription = "Portnummer"
140     Case eptVBAStyle
145         GetParameterDescription = "vba-Msgbox-Style"
150     Case eptControlParameter
155         GetParameterDescription = "Steuerungsparameter"
160     Case eptFreeParameter
165         GetParameterDescription = "freier Text"
170     Case eptText
175         GetParameterDescription = "einfacher Text"
180     Case Else
185         GetParameterDescription = "!!!! Parametertyp nicht beschrieben !!!!"
190 End Select
End Function

' Die folgenden Funktionen gehen davon aus, dass die Richtigkeit der parameterStrings bereits
' abgetestet ist.
Public Function GetBooleanValue(parmStr As String) As Boolean
5   If parmStr = vbNullString Then
10      GetBooleanValue = False
15  Else
20      GetBooleanValue = parmStr = "1"
25  End If
End Function

Public Function GetTextValue(parmStr As String) As String
5   GetTextValue = parmStr
End Function

Public Function GetIntegerValue(parmStr As String) As Long
5   If parmStr = vbNullString Then
10      GetIntegerValue = 0
15  Else
20      GetIntegerValue = CLng(parmStr)
25  End If
End Function

Public Function GetControlValue(parmStr As String) As Integer
    Dim modus As Integer
5   modus = CInt(parmStr)
10  GetControlValue = modus

End Function

Public Function GetVbaValue(parmStr As String) As VbMsgBoxStyle
    ' Beschreibung der vbaValues auf http://www.functionx.com/vbaccess/topics/msgbox.htm
5   Select Case CInt(parmStr)
        Case 0
10          GetVbaValue = vbInformation
15      Case 1
20          GetVbaValue = vbQuestion
25      Case 2
30          GetVbaValue = vbExclamation
35      Case 3
40          GetVbaValue = vbCritical
45      Case Else
50          GetVbaValue = vbInformation
55  End Select
End Function
Attribute VB_Name = "TC_PrintHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp
Private mobjSessionEAkte As TC_Session
Private mboolSynchOK As Boolean

Private Sub Class_Terminate()
5   Call Me.CleanUp
10  Set mobjSessionEAkte = Nothing
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_LogfileHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get SessionEAkte() As TC_Session
5   Set SessionEAkte = mobjSessionEAkte
End Property

Public Property Set SessionEAkte(objSessionEAkte As TC_Session)
5   Set mobjSessionEAkte = objSessionEAkte
End Property

Public Property Get SynchOK() As Boolean
5   SynchOK = mboolSynchOK
End Property

Public Property Let SynchOK(ByVal boolSynchOK As Boolean)
5   mboolSynchOK = boolSynchOK
End Property

Private Function GetLockedState(session As TC_Session) As Collection
5   On Error GoTo RaiseErrorHandler

    Dim colSaveCollection As Collection
    Dim objField As Field

10  Set colSaveCollection = New Collection

15  For Each objField In session.workingDocument.Fields
20      colSaveCollection.Add objField.Locked
25  Next objField

ExitProc:
30  Set GetLockedState = colSaveCollection
35  Set colSaveCollection = Nothing
40  Set objField = Nothing
45  Exit Function

RaiseErrorHandler:
50  Set GetLockedState = Nothing
55  Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::GetLockedState" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Function

Private Sub RestoreLockedState(session As TC_Session, savedFields As Collection)
    Dim fld As Field
    Dim idx As Integer
5   idx = 1
10  For Each fld In session.workingDocument.Fields
15      fld.Locked = savedFields(idx)
20      idx = idx + 1
25  Next
End Sub

Public Function ChangePrinterOldWay(objSession As TC_Session, strNewPrinterName As String) As Boolean
    Dim strSavedActivePrinter As String
    Dim intCount As Integer
    Dim boolReturn As Boolean

5   On Error GoTo RaiseErrorHandler

10  Call objSession.IncIndent
15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler:ChangePrinterOldWay: |fffd|bergebener Drucker [" & strNewPrinterName & "]", objSession)

20  strSavedActivePrinter = ActivePrinter
25  intCount = 0

30  Do
35      ActivePrinter = strNewPrinterName
40      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler:ChangePrinterOldWay: Versuch Nummer " & intCount & " zum Setzen des Druckers", objSession)
45      DoEvents
50      Sleep (100)
55      If ActivePrinter = strSavedActivePrinter Then
60          intCount = intCount + 1
65          If intCount > 5 Then
                ' Fehlermitteilung und Behandlung in rufender Prozedur
70              boolReturn = False
75              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler:ChangePrinterOldWay: Printer konnte nicht gesetzt werden, Drucker ist weiterhin [" & ActivePrinter & "]", objSession)
80              Exit Do
85          End If
90      Else
95          boolReturn = True
100         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler:ChangePrinterOldWay: Printer systemweit auf [" & ActivePrinter & "] gesetzt", objSession)
105         Exit Do
110     End If
115 Loop

ExitProc:
120 ChangePrinterOldWay = boolReturn
125 Call objSession.DecIndent
130 Exit Function

RaiseErrorHandler:
135 boolReturn = False
140 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::ChangePrinterOldWay" & " in Zeile:" & Erl & vbCrLf, Err.Description
145 Resume ExitProc

End Function

Public Function ChangePrinterTo(objSession As TC_Session, strNewPrinterName As String) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean

10  Call objSession.IncIndent
15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ChangePrinterTo: |fffd|bergebener Drucker [" & strNewPrinterName & "]", objSession)
20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                 aktiver Drucker [" & ActivePrinter & "]", objSession)

25  boolResult = True
30  If Not Me.ParentIkolClientApp.Tools.SamePrinter(strNewPrinterName, ActivePrinter, True) Then

35      If strNewPrinterName <> vbNullString Then


40          If objSession.OldWayPrint Then
45              boolResult = Me.ChangePrinterOldWay(objSession, strNewPrinterName)
50          Else
55              With Dialogs(wdDialogFilePrintSetup)
60                  .printer = strNewPrinterName
65                  .DoNotSetAsSysDefault = True
70                  .Execute
75              End With

80              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ChangePrinterTo: Der Drucker f|fffd|r den Ausdruck wurde auf [" & ActivePrinter & "] gesetzt", objSession)
85          End If
90      Else
95          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ChangePrinterTo: Kein Name f|fffd|r den neuen Drucker |fffd|bergeben. Der Drucker wurde nicht neu gesetzt," & vbLf & _
                                                                   "Ausdruck auf aktiven Drucker [" & ActivePrinter & "]", objSession)
100     End If
105 Else
110     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ChangePrinterTo: Drucker brauchte nicht gesetzt zu werden", objSession)
115 End If

ExitProc:
120 Call objSession.DecIndent
125 ChangePrinterTo = boolResult
130 Exit Function

RaiseErrorHandler:
135 Call objSession.DecIndent
140 boolResult = False
145 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::ChangePrinterTo" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> " & "Fehler beim Wechsel des Druckers zu [" & strNewPrinterName & "]"
150 Resume ExitProc
End Function

Public Function PrintDocumentsWithSetup(objSession As TC_Session) As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Dim objTcDoc As TC_Document
    Dim strSavedPrinter As String
    Dim strPrinter As String
    Dim rRange As WdPrintOutRange                     ' Druckbereich (alles, aktuelle seite, from-to, Seitenbereich, Selection
    Dim strPages As String                            ' Zeichenkette, welche Seiten gedruckt werden
    Dim intCopies As Integer                          ' Anzahl der Kopien
    Dim boolCollate As Boolean                        ' Sortierung.
    Dim rPageType As WdPrintOutPages                  ' gibt an, ob alle, gerade oder ungerade Seiten gedruckt werden sollen
    Dim rItem As WdPrintOutItem                       ' wird durch MS-Word falsch zur|fffd|ckgegeben (Type existiert auch im |fffd|bergeordneten Dialog)
    Dim tcResult As TC_SessionResult

10  Call objSession.IncIndent
15  tcResult = tcrOK

20  Set objTcDoc = objSession.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(objSession.workingDocument.FullName)

25  strSavedPrinter = Application.ActivePrinter

30  If (objSession.PrinterToUse <> vbNullString) And (objSession.PrinterToUse <> ActivePrinter) Then
35      strPrinter = objSession.PrinterToUse
40  Else
45      strPrinter = vbNullString
50  End If

55  If Me.ParentIkolClientApp.PrinterSetupHandler.DruckerauswahlDateiDrucken(strPrinter, _
                                                                             rPageType, _
                                                                             rItem, _
                                                                             strPages, _
                                                                             rRange, _
                                                                             intCopies, _
                                                                             boolCollate) Then
60      If Me.ChangePrinterTo(objSession, strPrinter) Then
65          With objSession.workingDocument
70              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::PrintDocumentsWithSetup: mit folgenden Parametern ausgef|fffd|hrt", objSession)
75              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         Range =      " & Me.ParentIkolClientApp.LogfileHandler.PrintOutRangeDescr(rRange), objSession)
80              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         Pages =      " & Chr(34) & strPages & Chr(34), objSession)
85              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         Copies =     " & intCopies, objSession)
90              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         Collate =    " & boolCollate, objSession)
95              Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         pageType =   " & Me.ParentIkolClientApp.LogfileHandler.PrintOutPagesDescr(rPageType), objSession)
100             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         Item =       " & Me.ParentIkolClientApp.LogfileHandler.PrintOutItemDescr(rItem), objSession)
105             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                         Background = " & objSession.IKOLPrintMode, objSession)

110             Call Me.SetTrayInfo(objSession.workingDocument, objSession)
115             .PrintOut Pages:=strPages, _
                          Range:=rRange, _
                          PrintToFile:=False, _
                          OutputFileName:=vbNullString, _
                          PageType:=rPageType, _
                          Item:=rItem, _
                          Background:=objSession.IKOLPrintMode, _
                          Copies:=intCopies, _
                          Collate:=boolCollate
120         End With
125         Call Me.ChangePrinterTo(objSession, strSavedPrinter)
130     End If
135 Else
140     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::PrintDocumentsWithSetup: Dialog abgebrochen", objSession)
145     tcResult = tcrWarning
150 End If

155 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::PrintDocumentsWithSetup: nach dem Druck", objSession)


ExitProc:
160 Set objTcDoc = Nothing
165 Call objSession.DecIndent
170 PrintDocumentsWithSetup = tcResult
175 Exit Function

RaiseErrorHandler:
180 Call objSession.DecIndent
185 tcResult = tcrPrintError
190 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::PrintDocumentsWithSetup" & " in Zeile:" & Erl & vbCrLf, Err.Description
195 Resume ExitProc

End Function


Public Function PrintDocuments(intQuantity As Integer, _
                               strPrinterName As String, _
                               intFirstPage As Integer, _
                               intLastPage As Integer, _
                               boolIsEAkte As Boolean, _
                               intPrinterControl As Integer, _
                               session As TC_Session) As TC_SessionResult

    Dim prRange As WdPrintOutRange
    Dim boolCurrScreenUpdating As Boolean
    Dim strRange As String
    Dim colSavedLockedState As Collection
    Dim strSavedPrinter As String
    Dim boolSaveLockedValue As Boolean
    Dim objTcDoc As TC_Document
    Dim prField As Field
    Dim boolFieldUpdate As Boolean
    Dim boolAvoidAlerts As Boolean
    Dim dispAlert As WdAlertLevel

10    On Error GoTo RaiseErrorHandler

20    Call session.IncIndent

30    strSavedPrinter = ActivePrinter
40    PrintDocuments = tcrOK

50    boolAvoidAlerts = ((intPrinterControl And 1) <> 0)
60    boolFieldUpdate = ((intPrinterControl And 2) = 0)
70    boolCurrScreenUpdating = Application.ScreenUpdating

80    Application.ScreenUpdating = True
    ' DoEvents
90    Application.ScreenRefresh
    ' DoEvents

100   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("PrintDocuments: mit folgender Steuerung", session)
110   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                     Unterdr|fffd|ckung von Warnungen          = " & boolAvoidAlerts, session)
120   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                     Aktualisierung von Feldern vor Druck = " & boolFieldUpdate, session)

130   If ChangePrinterTo(session, strPrinterName) Then

140     If boolAvoidAlerts Then
150         dispAlert = Application.DisplayAlerts
160         Application.DisplayAlerts = wdAlertsNone
170     End If

180     If intFirstPage = 0 Or (intFirstPage = 1 And intLastPage = 0) Then
190         prRange = wdPrintAllDocument
200         strRange = vbNullString
210     Else
220         prRange = wdPrintRangeOfPages
230         strRange = intFirstPage & "-"
240         If intLastPage > 0 Then strRange = strRange & intLastPage
250     End If

260     Set objTcDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)

270     With session.workingDocument
280         If .ProtectionType = wdNoProtection Then
290             Set colSavedLockedState = GetLockedState(session)
300             boolSaveLockedValue = .Fields.Locked
310         End If

320         If .ProtectionType = wdNoProtection Then
330             If Not objTcDoc.Printed Then
340                 If boolFieldUpdate Then
350                     .Fields.Update
360                 Else
                         '09.04.2014 AL doFillIns auskommentiert, sonst Absturz
'185                     For Each prField In .Fields
'190                         If prField.Type = wdFieldFillIn Then
'195                             prField.Update
'200                         End If
'205                     Next
370                 End If
380                 If Not boolIsEAkte Then objTcDoc.Printed = True
390             End If
400         End If

410         If .ProtectionType = wdNoProtection Then
420             .Fields.Locked = True
430         End If

440         Call Me.ParentIkolClientApp.ApplicationHandler.HideShadowMergeField(session.workingDocument, session)
450         Call Me.ParentIkolClientApp.PrinterSetupHandler.PrintPropertiesToProtokoll(strPrinterName, session)
460         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("PrintDocuments: mit folgenden Parametern", session)
470         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                Pages =      " & Chr(34) & strRange & Chr(34), session)
480         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                Range =      " & Me.ParentIkolClientApp.LogfileHandler.PrintOutRangeDescr(prRange), session)
490         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                Copies =     " & intQuantity, session)
500         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("                Background = " & session.IKOLPrintMode, session)

510         Call Me.SetTrayInfo(session.workingDocument, session)

                '14.11.2014 AL
                'Drucken von Hidden-Text
                'MsgBox ("Drucker: " & strPrinterName & vbCr & _
                '"ArcPrinter:" & session.Printer_eAkte & vbCr & _
                '"Print_Hidden: " & session.PrintHidden & vbCr & _
                '"Print_Hidden_ARC: " & session.PrintHiddenArc)
                
                '23.01.2015 AL hier nur das if eingef|fffd|hrt, da z.B. in Grafschaft Bentheim hier unerkl|fffd|rlicher Absturz
520             If session.ParamPrintHidden = True Then 'es ist entweder in SETZE_PARAMETER PRINT_HIDDEN oder PRINT_HIDDEN_ARC gesetzt
530               Options.PrintHiddenText = False 'Standard
540               If UCase(strPrinterName) = UCase(session.Printer_eAkte) Then 'Archiv-Druck
550                 If session.PrintHiddenArc = True Then
560                   Options.PrintHiddenText = True
570                 End If
580               Else                                                         'normaler Druck
590                 If session.PrintHidden = True Then
600                   Options.PrintHiddenText = True
610                 End If
620               End If
                  'ENDE 14.11.2014 AL
630             End If '23.01.2015 AL

640         If session.OldWayPrint Then
650             Application.PrintOut filename:=session.workingDocument.FullName, _
                                     Range:=wdPrintAllDocument, _
                                     Item:=wdPrintDocumentContent, _
                                     Copies:=intQuantity, _
                                     Pages:=strRange, _
                                     PageType:=wdPrintAllPages, _
                                     Collate:=True, _
                                     Background:=session.IKOLPrintMode, _
                                     PrintToFile:=False

660         Else
670             .PrintOut Pages:=strRange, _
                          Range:=prRange, _
                          PrintToFile:=False, _
                          OutputFileName:=vbNullString, _
                          PageType:=wdPrintAllPages, _
                          Item:=wdPrintDocumentContent, _
                          Background:=session.IKOLPrintMode, _
                          Copies:=intQuantity, _
                          Collate:=True               ' Exemplare werden zusammenh|fffd|ngend gedruckt
                ' die erste Zahl ist die Prozentanzahl
                '                PrintZoomPaperWidth:=1 * (8.5 * 1440), _
                                 '                PrintZoomPaperHeight:=1 * (11 * 1440),
680         End If
690         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("PrintDocuments: nach dem Druck", session)

700         If .ProtectionType = wdNoProtection Then
710             .Fields.Locked = boolSaveLockedValue
720             Call RestoreLockedState(session, colSavedLockedState)
730         End If
740     End With

750     If boolAvoidAlerts Then
760         Application.DisplayAlerts = dispAlert
770     End If

780     Set objTcDoc = Nothing
790     If Not ChangePrinterTo(session, strSavedPrinter) Then

800         PrintDocuments = tcrPrintError

810         Err.Raise glongCUSTOM_ERR_PRINT, "TC_PrintHandler::PrintDocuments", "Kann den Standarddrucker nicht zur|fffd|cksetzen"

820     End If
830   Else
840     PrintDocuments = tcrPrintError

850     Err.Raise glongCUSTOM_ERR_PRINT, "TC_PrintHandler::PrintDocuments", "Konnte den angegebenen Drucker nicht setzen"
860   End If

ExitProc:
870   Call session.DecIndent
880   Application.ScreenUpdating = boolCurrScreenUpdating
890   Exit Function

RaiseErrorHandler:
900   Call ChangePrinterTo(session, strSavedPrinter)
910   PrintDocuments = tcrPrintError
920   Call session.DecIndent
930   Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::PrintDocuments" & " in Zeile:" & Erl & vbCrLf, Err.Description
940   Resume ExitProc
End Function


Public Function SetPrinter_eAkte(PrinterName As String, session As TC_Session) As TC_SessionResult
    Dim dummyState As PrinterSearchState
    Dim normalizedPrinter As String

5   On Error GoTo RaiseErrorHandler

10  dummyState = Me.ParentIkolClientApp.PrinterSetupHandler.GetNormalizedPrinterName(PrinterName, normalizedPrinter, False)
15  session.Printer_eAkte = normalizedPrinter

20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Drucker f|fffd|r die eAkte mit normalisierten Namen <" & session.Printer_eAkte & "> gesetzt", session)

ExitProc:
25  Exit Function

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::SetPrinter_eAkte" & " in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Function


Public Function SetPrinterToUse(strPrinterName As String, objSession As TC_Session) As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Dim strNormalizedPrinter As String
    Dim psState As PrinterSearchState
    Dim tcResult As TC_SessionResult

10  tcResult = tcrOK

15  strNormalizedPrinter = "?"
20  If (strPrinterName <> "?") Then
25      If strPrinterName = vbNullString Then
30          strNormalizedPrinter = vbNullString
35      Else
40          psState = Me.ParentIkolClientApp.PrinterSetupHandler.GetNormalizedPrinterName(strPrinterName, strNormalizedPrinter, False)
45          If psState <> ssOnePrinter Then           'Drucker nicht gefunden oder mehrdeutig
50              strNormalizedPrinter = "?"
55          End If
60      End If
65  End If
70  If strNormalizedPrinter = "?" Then                'Anzeige Druckerauswahlbox
75      strNormalizedPrinter = Me.ParentIkolClientApp.PrinterSetupHandler.SelectPrinter(objSession, strPrinterName)
80      If strNormalizedPrinter = vbNullString Then   ' Abbruch
85          tcResult = tcrPrintError
90      End If
95  Else
100     If strNormalizedPrinter = vbNullString Then   ' kein Drucker definiert, dann Standarddrucker nehmen
105         psState = Me.ParentIkolClientApp.PrinterSetupHandler.GetNormalizedPrinterName( _
                      Me.ParentIkolClientApp.DefaultPrinterName, strNormalizedPrinter, False)
110     End If
115 End If
120 If tcResult = tcrOK Then
125     objSession.PrinterToUse = strNormalizedPrinter
130     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Druckername zum normalisierten Namen <" & _
                                                               strNormalizedPrinter & "> gesetzt", objSession)
135 End If


ExitProc:
140 SetPrinterToUse = tcResult
145 Exit Function

RaiseErrorHandler:
150 tcResult = tcrPrintError
155 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::SetPrinterToUse" & " in Zeile:" & Erl & vbCrLf, Err.Description
160 Resume ExitProc

End Function


Public Sub ControlProgressbar()

5   On Error GoTo RaiseErrorHandler

    Dim strEAkteSynchFile As String
    Dim intSchrittanzahl As Long
    Dim dblSchritt As Double
    Dim dblLaenge As Double
    Dim MsgBoxResult As VbMsgBoxResult


10  intSchrittanzahl = 180
15  dblLaenge = 0

20  Me.ParentIkolClientApp.frmProgressBalken.Caption = Me.ParentIkolClientApp.MsgBoxTitle
25  dblSchritt = Me.ParentIkolClientApp.frmProgressBalken.Label1.width / intSchrittanzahl    'Schrittbreite pro Aktualisierung
30  strEAkteSynchFile = Me.SessionEAkte.ArchivDir & gstrTC_ARCHIVENDE_NAME

35  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Synchronisation des Vorgangs 'eAkte' - Warten auf die Datei: " & strEAkteSynchFile, Me.SessionEAkte)
40  Me.ParentIkolClientApp.frmProgressBalken.ProgressLabel.Caption = "Drucker: " & Chr(34) & Me.SessionEAkte.Printer_eAkte & Chr(34)

45  Do                                                ' Warten auf ENDE.TXT
50      If Me.ParentIkolClientApp.FileHandler.FileExist(strEAkteSynchFile) Then Exit Do
55      DoEvents

60      dblLaenge = dblLaenge + dblSchritt
65      If Me.ParentIkolClientApp.frmProgressBalken.Label1.width = dblLaenge Then    'rund eine Minute ist vergangen
70          Application.ScreenRefresh
75          MsgBoxResult = MsgBox("Es liegt noch keine Meldung |fffd|ber das Ende des Vorgangs 'eAkte' vor" & vbLf & _
                                  "Soll der Vorgang abgebrochen werden?", vbRetryCancel, Me.ParentIkolClientApp.MsgBoxTitle())
80          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Synchronisation des Vorgangs 'eAkte' - Meldung |fffd|ber Zeit|fffd|berschreitung!", Me.SessionEAkte)
85          If MsgBoxResult = vbCancel Then
90              Me.SynchOK = False
95              Exit Do
100         End If
105         dblLaenge = 0
110     End If
115     Me.ParentIkolClientApp.frmProgressBalken.Label2.width = dblLaenge
120     Sleep 300
125 Loop

ExitProc:
130 Exit Sub

RaiseErrorHandler:
135 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::ControlProgressbar" & " in Zeile:" & Erl & vbCrLf, Err.Description
140 Resume ExitProc
End Sub


Public Function SynchronisePrint_eAkte(session As TC_Session) As TC_SessionResult
    Dim savedScreenUpdate As Boolean
    Dim endeTxtContent As String
    Dim errorTxt As String
    Dim result As TC_SessionResult

5   On Error GoTo RaiseErrorHandler


10  SynchronisePrint_eAkte = tcrOK
15  Me.SynchOK = True
20  savedScreenUpdate = Application.ScreenUpdating
25  Application.ScreenUpdating = True
30  Application.ScreenRefresh

35  Set Me.SessionEAkte = session

40  Load Me.ParentIkolClientApp.frmProgressBalken
45  Me.ParentIkolClientApp.frmProgressBalken.Show     ' ruft callback-Prozedur ControlProgressbar, diese setzt mboolSynchOK

50  endeTxtContent = Me.GetContentFromEndeTxt(Me.SessionEAkte.ArchivDir & gstrTC_ARCHIVENDE_NAME, session)

55  Set Me.SessionEAkte = Nothing

60  If Me.SynchOK Then
65      If UCase(endeTxtContent) = UCase(gstrTC_ARCHIV_ERROR) Then
70          SynchronisePrint_eAkte = tcreAkteError
75          Err.Raise glongCUSTOM_ERR_EAKTE, "TC_PrintHandler::SynchronisePrint_eAkte", "Der Druckjob des " & session.Printer_eAkte & " konnte nicht erfolgreich durchgef|fffd|hrt werden." & vbCrLf & "Ermitteln / Pr|fffd|fen Sie folgende LOG-Datei:" & vbCrLf & session.ArchivDir & session.Printer_eAkte & ".log"
80      Else
85          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Synchronisieren des Vorgangs 'eAkte' erfolgreich beendet!", session)
90      End If
95  Else
100     SynchronisePrint_eAkte = tcreAkteError
        ' 105     Err.Raise glongCUSTOM_ERR_EAKTE, "TC_PrintHandler::SynchronisePrint_eAkte", "Synchronisation des Vorgangs 'eAkte' durch Benutzer abgebrochen!"
105     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::SynchronisePrint_eAkte: Synchronisation des Vorgangs 'eAkte' durch Benutzer abgebrochen!", session)

110 End If

ExitProc:
115 Application.ScreenUpdating = savedScreenUpdate
120 Exit Function

RaiseErrorHandler:
125 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::SynchronisePrint_eAkte" & " in Zeile:" & Erl & vbCrLf, Err.Description
130 Resume ExitProc
End Function


Public Function GetContentFromEndeTxt(strFileName As String, objSession As TC_Session) As String

5   On Error GoTo RaiseErrorHandler

    Dim FSO As New FileSystemObject
    Dim copyFile As TextStream
    Dim strResult As String

10  strResult = vbNullString

15  If FSO.FileExists(strFileName) Then
20      Set copyFile = FSO.OpenTextFile(strFileName, ForReading, False)
25      GetContentFromEndeTxt = copyFile.ReadLine
30      copyFile.Close
35      Set copyFile = Nothing
40      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "TC_PrintHandler::GetContentFromEndeTxt " & strFileName & " Inhalt: " & GetContentFromEndeTxt, objSession)
45  Else
50      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "TC_PrintHandler::GetContentFromEndeTxt " & strFileName & " kann nicht ge|fffd|ffnet werden", objSession)
55  End If

ExitProc:
60  Set FSO = Nothing
65  GetContentFromEndeTxt = strResult
70  Exit Function

RaiseErrorHandler:
75  strResult = vbNullString
80  Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::GetContentFromEndeTxt" & " in Zeile:" & Erl & vbCrLf, Err.Description
85  Resume ExitProc

End Function


Private Function ArchivDirCreated(strArchivDirName As String, objSession As TC_Session) As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim FSO As New FileSystemObject
    Dim SubFolders() As String
    Dim idx As Integer
    Dim strSubFolder As String
    Dim boolResult As Boolean

20    boolResult = True

30    If Not FSO.FolderExists(strArchivDirName) Then
40      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ArchivDirCreated: Verzeichnis f|fffd|r die eAkte " & _
                                                               Chr(34) & strArchivDirName & Chr(34) & " muss erzeugt werden", objSession)
50      SubFolders = Split(strArchivDirName, Application.PathSeparator)
60      strSubFolder = SubFolders(LBound(SubFolders))
70      For idx = LBound(SubFolders) + 1 To UBound(SubFolders)
80          strSubFolder = strSubFolder & Application.PathSeparator & SubFolders(idx)
90          If Not FSO.FolderExists(strSubFolder) Then
100             FSO.CreateFolder (strSubFolder)
110         End If
120     Next idx
130   End If

ExitProc:
150   ArchivDirCreated = boolResult
160   Set FSO = Nothing
170   Exit Function

RaiseErrorHandler:
180   objSession.tcResult = tcreAkteError
190   boolResult = False
200   Set FSO = Nothing
210   Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::ArchivDirCreated" & " in Zeile:" & Erl & vbCrLf, Err.Description
220   Resume ExitProc
End Function


Private Function ArchivDirCleared(strArchivDirName As String, objSession As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim FSO As New FileSystemObject
    Dim objFolder As Folder
    Dim objFile As file
    Dim strFileName As String
    Dim boolResult As Boolean

10  boolResult = True

15  Set objFolder = FSO.GetFolder(strArchivDirName)

20  If objFolder.Files.count > 0 Then
25      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ArchivDirCleared: Verzeichnis f|fffd|r die eAkte " & _
                                                               Chr(34) & strArchivDirName & Chr(34) & " ist nicht leer und wird als Vorbereitung geleert", objSession)
30      For Each objFile In objFolder.Files
35          strFileName = strArchivDirName & objFile.name
40          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("    gel|fffd|schte Datei: " & Chr(34) & strFileName & Chr(34), objSession)
45          FSO.DeleteFile (strFileName)
50      Next objFile
55  Else
60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler::ArchivDirCleared: Verzeichnis f|fffd|r die eAkte " & _
                                                               Chr(34) & strArchivDirName & Chr(34) & " ist leer und bereit f|fffd|r die eAkte", objSession)
65  End If

ExitProc:
70  objSession.tcResult = tcreAkteError
75  ArchivDirCleared = boolResult
80  Set FSO = Nothing
85  Exit Function

RaiseErrorHandler:
90  boolResult = False
95  Set FSO = Nothing
100 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::ArchivDirCleared" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> " & " Die Datei " & vbLf & _
                                                                                                                 Chr(34) & strFileName & Chr(34) & vbLf & _
                                                                                                                 "konnte im Archivordner nicht gel|fffd|scht werden"
105 Resume ExitProc
End Function


Public Function TestArchivEnvironment(session As TC_Session, makroName As String) As Boolean
    Dim FSO As New FileSystemObject
    Dim arcDir As String

5   On Error GoTo RaiseErrorHandler

10  TestArchivEnvironment = False
15  arcDir = session.ArchivDir

20  If Right(arcDir, 1) = Application.PathSeparator Then
25      arcDir = Mid(arcDir, 1, Len(arcDir) - 1)
30  End If

35  With session
40      If .Printer_eAkte = vbNullString Then
45          session.tcResult = tcreAkteError

50          Err.Raise glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG, "TC_PrintHandler::TestArchivEnvironment", "F|fffd|r den Druck der eAkte ist kein Drucker definiert!" & vbLf & "Bitte die Einstellungen |fffd|ndern"

55      Else
60          If Me.ParentIkolClientApp.Tools.SamePrinter(.Printer_eAkte, .PrinterToUse, True) Then
65              session.tcResult = tcreAkteError

70              Err.Raise glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG, "TC_PrintHandler::TestArchivEnvironment", "F|fffd|r den Druck von Dokumenten und dem Druck der eAkte d|fffd|rfen nicht dieselben Drucker verwendet werden!" & vbLf & "Bitte die Einstellungen |fffd|ndern"


75          Else
80              If session.ArchivDir = vbNullString Or session.ArchivDir = "\" Then
85                  session.tcResult = tcreAkteError


90                  Err.Raise glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG, "TC_PrintHandler::TestArchivEnvironment", "F|fffd|r den Druck der eAkte wurde kein Verzeichnis konfiguriert!" & vbLf & "Bitte die Konfiguration |fffd|ndern"


95              Else
100                 If Not FSO.FolderExists(session.ArchivDir) Then
105                     If ArchivDirCreated(session.ArchivDir, session) Then    ' damit ist das Archiv-Verzeichnis auch leer
110                         If session.ShowWarnings Then

115                             Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox( _
                                     "Da das f|fffd|r den Druck der eAkte konfigurierte Verzeichnis " & vbLf & _
                                     Chr(34) & arcDir & Chr(34) & vbLf & _
                                     "nicht existierte, wurde es erzeugt!", session)
120                         End If
125                         TestArchivEnvironment = True
130                     Else
135                         Err.Raise glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG, "TC_PrintHandler::TestArchivEnvironment", "Das konfigurierte Verzeichnis f|fffd|r den Druck der eAkte " & vbLf & Chr(34) & arcDir & Chr(34) & vbLf & "konnte nicht erstellt werden!" & vbLf & "Bitte die Konfiguration |fffd|ndern"

140                     End If                        ' Archivdir kann erstellt werden
145                 Else
150                     If ArchivDirCleared(session.ArchivDir, session) Then
155                         TestArchivEnvironment = True
160                     Else
165                         Err.Raise glongCUSTOM_ERR_EAKTE_ERR_WE_CONFIG, "TC_PrintHandler::TestArchivEnvironment", "Das Verzeichnis f|fffd|r den Druck der eAkte" & vbLf & Chr(34) & arcDir & Chr(34) & vbLf & "konnte nicht geleert werden! Bitte die Konfiguration entsprechend |fffd|ndern"

170                     End If                        ' ArchivDir konnt geleert werden
175                 End If                            ' ArchivDir existiert oder muss erstellt werden
180             End If                                ' ArchivDir wurde angegeben ?
185         End If                                    ' Test Printer_eAkte ungleich PrinterToUse
190     End If                                        ' Printer_eAkte definiert (? = "")
195 End With

ExitProc:
200 Set FSO = Nothing
205 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TestArchivEnvironment endet mit " & TestArchivEnvironment, session)
210 Exit Function

RaiseErrorHandler:
215 Set FSO = Nothing
220 Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::TestArchivEnvironment" & " in Zeile:" & Erl & vbCrLf, Err.Description
225 Resume ExitProc
End Function


Public Function GetTrayValue(strParameter As String, _
                             intTrayValue As Integer, _
                             session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim strValue As String
    Dim boolReturn As Boolean

10  strValue = session.GetParameterValue(strParameter)
15  If strValue <> "" Then
20      boolReturn = IsNumeric(strValue)
25      If boolReturn Then
30          intTrayValue = CInt(strValue)
35      End If
40  Else
45      boolReturn = False
50  End If


ExitProc:
55  GetTrayValue = boolReturn
60  Exit Function

RaiseErrorHandler:
65  boolReturn = False
70  Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::GetTrayValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Function

Public Sub SetTrayInfo(objDoc As Document, session As TC_Session)
5   On Error GoTo RaiseErrorHandler

    Dim intFirstTrayValue As Integer
    Dim intOtherTrayValue As Integer

10  With objDoc.PageSetup
15      If Me.GetTrayValue("FIRSTTRAY", intFirstTrayValue, session) Then
20          .FirstPageTray = intFirstTrayValue
25          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler:SetTrayInfo: Schacht f|fffd|r 1. Seite gesetzt auf " & intFirstTrayValue, session)
30      End If
35      If Me.GetTrayValue("OTHERTRAY", intOtherTrayValue, session) Then
40          .OtherPagesTray = intOtherTrayValue
45          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrintHandler:SetTrayInfo: Schacht f|fffd|r anderen Seite gesetzt auf " & intOtherTrayValue, session)
50      End If
55  End With

ExitProc:
60  Exit Sub

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_PrintHandler::SetTrayInfo" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Sub
Attribute VB_Name = "TC_PrinterSetupHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mstrLookForPrinterName As String
Private mstrPrinterName As String
Private mboolSelectCanceled As Boolean
Private mobjSessionForSelect As TC_Session
Private mstrPrinterDialogLabel As String
Private mstrarrInstalledPrinter() As String
Private mboolIsAPrinterInstalled As Boolean
Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Initialize()
    ' starte mit der Annahme, dass keine Drucker installiert sind
5   mboolIsAPrinterInstalled = False
10  Set mobjSessionForSelect = Nothing
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If

20  If Not mobjSessionForSelect Is Nothing Then
25      Set mobjSessionForSelect = Nothing
30  End If

End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_PrinterSetupHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get PrinterDialogLabel() As String
5   PrinterDialogLabel = mstrPrinterDialogLabel
End Property

Public Property Let PrinterDialogLabel(ByVal strPrinterDialogLabel As String)
5   mstrPrinterDialogLabel = strPrinterDialogLabel
End Property

Public Property Get IsAPrinterInstalled() As Boolean
5   IsAPrinterInstalled = mboolIsAPrinterInstalled
End Property

Public Property Let IsAPrinterInstalled(ByVal boolIsAPrinterInstalled As Boolean)
5   mboolIsAPrinterInstalled = boolIsAPrinterInstalled
End Property

Public Property Set SessionForSelect(ByRef objSessionForSelect As TC_Session)
5   Set mobjSessionForSelect = objSessionForSelect
End Property

Public Property Get SessionForSelect() As TC_Session
5   Set SessionForSelect = mobjSessionForSelect
End Property
Public Property Get LookForPrinterName() As String
5   LookForPrinterName = mstrLookForPrinterName
End Property

Public Property Let LookForPrinterName(ByVal strLookForPrinterName As String)
5   mstrLookForPrinterName = strLookForPrinterName
End Property

Public Property Get PrinterName() As String
5   PrinterName = mstrPrinterName
End Property

Public Property Let PrinterName(ByVal strPrinterName As String)
5   mstrPrinterName = strPrinterName
End Property

Public Property Get SelectCanceled() As Boolean
5   SelectCanceled = mboolSelectCanceled
End Property

Public Property Let SelectCanceled(ByVal boolSelectCanceled As Boolean)
5   mboolSelectCanceled = boolSelectCanceled
End Property

Public Function PrintPropertiesToProtokoll(strPrinterName As String, objSession As TC_Session) As Boolean
    'Code adapted from Microsoft KB article Q230743

5   On Error GoTo RaiseErrorHandler

    Dim hPrinter As Long
    Dim pd As PRINTER_DEFAULTS
    Dim dm As DEVMODE
    Dim mstrPrinterName As String
    Dim yDevModeData() As Byte
    Dim iRet As Long

    Dim boolResult As Boolean

10  hPrinter = 0
15  boolResult = False

20  mstrPrinterName = Trim$(Left$(strPrinterName, InStr(strPrinterName, " on ")))    ' Get the name of the current printer
25  pd.DesiredAccess = PRINTER_NORMAL_ACCESS

30  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::PrintPropertiesToProtokoll: Eigenschaften des gegenw|fffd|rtigen Printers " & strPrinterName, objSession)
35  iRet = OpenPrinter(strPrinterName, hPrinter, ByVal CLng(0))    ' Get the printer handle
40  If (iRet = 0) Or (hPrinter = 0) Then              ' Couldn't access the printer
45      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::PrintPropertiesToProtokoll: Kann auf den Drucker " & strPrinterName & " nicht zugreifen", objSession)
50      If iRet = 0 Then
55          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(GlobalAPIDeclarations.WriteTheSystemError, objSession)
60      End If
65      GoTo ExitProc
70  End If

    'Find out how many bytes needed for the printer properties
75  iRet = DocumentProperties(0, hPrinter, mstrPrinterName, 0, 0, 0)
80  If (iRet >= 0) Then                               ' can access the printer properties
        'Make sure the byte array is large enough, including the 100 bytes extra in case the printer driver is lying.
85      ReDim yDevModeData(0 To iRet + 100) As Byte

        'Load the printer properties into the byte array
90      iRet = DocumentProperties(0, hPrinter, mstrPrinterName, VarPtr(yDevModeData(0)), 0, DM_OUT_BUFFER)
95      If (iRet >= 0) Then                           ' Can access printer properties
100         Call CopyMemory(dm, yDevModeData(0), Len(dm))    ' Copy the byte array to the DEVMODE structure
105         If dm.dmFields Then                       ' properties available on this printer.
110             With dm
115                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          DeviceName:       " & Me.ParentIkolClientApp.Tools.RealString(.dmDeviceName), objSession)
120                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          SpecVersion:      " & .dmSpecVersion, objSession)
125                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          DriverVersion:    " & .dmDriverVersion, objSession)
130                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Size:             " & .dmSize, objSession)
135                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          DriverExtra:      " & .dmDriverExtra, objSession)
140                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          FormName:         " & Me.ParentIkolClientApp.Tools.RealString(.dmFormName), objSession)
145                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Orientation:      " & .dmOrientation, objSession)
150                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          PaperSize:        " & .dmPaperSize, objSession)
155                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          PaperLength:      " & .dmPaperLength, objSession)
160                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          PaperWidth:       " & .dmPaperWidth, objSession)
165                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Scale:            " & .dmScale, objSession)
170                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Copies:           " & .dmCopies, objSession)
175                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          DefaultSource:    " & .dmDefaultSource, objSession)
180                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          PrintQuality:     " & .dmPrintQuality, objSession)
185                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Duplex:           " & .dmDuplex, objSession)
190                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Color:            " & .dmColor, objSession)
195             End With
200         Else
205             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::PrintPropertiesToProtokoll: dmFields sind 0 f|fffd|r den Drucker " & strPrinterName, objSession)
210         End If
215     Else
220         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::PrintPropertiesToProtokoll: Auf die Datenstruktur der Eigenschaften kann nicht zugegriffen werden", objSession)
225     End If
230 Else
235     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::PrintPropertiesToProtokoll: Auf die Eigenschaften des gegenw|fffd|rtigen Druckers kann nicht zugegriffen werden", objSession)
240 End If

245 boolResult = True

ExitProc:
    'Release the printer handle
250 If (hPrinter <> 0) Then Call ClosePrinter(hPrinter)
255 PrintPropertiesToProtokoll = boolResult
260 Exit Function

RaiseErrorHandler:
    'Release the printer handle
265 If (hPrinter <> 0) Then Call ClosePrinter(hPrinter)
270 boolResult = False
275 Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::PrintPropertiesToProtokoll" & " in Zeile:" & Erl & vbCrLf, Err.Description
280 Resume ExitProc

End Function

Public Sub SetColorMode(iColorMode As Long)
5   SetPrinterProperty DM_COLOR, iColorMode
End Sub

Public Sub SetDuplex(iDuplex As Long)
5   SetPrinterProperty DM_DUPLEX, iDuplex
End Sub

Public Sub SetPrintQuality(iQuality As Long)
5   SetPrinterProperty DM_PRINTQUALITY, iQuality
End Sub

Public Function SetPrinterProperty(ByVal iPropertyType As Long, _
                                   ByVal iPropertyValue As Long) As Boolean

    'Code adapted from Microsoft KB article Q230743

    Dim hPrinter As Long                              'handle for the current printer
    Dim pd As PRINTER_DEFAULTS
    Dim pinfo As PRINTER_INFO_2
    Dim dm As DEVMODE
    Dim mstrPrinterName As String

    Dim yDevModeData() As Byte                        'Byte array to hold contents
    'of DEVMODE structure
    Dim yPInfoMemory() As Byte                        'Byte array to hold contents
    'of PRINTER_INFO_2 structure
    Dim iBytesNeeded As Long
    Dim iRet As Long
    Dim iJunk As Long
    Dim iCount As Long

5   On Error GoTo CleanUp

    'Get the name of the current printer
10  mstrPrinterName = Trim$(Left$(ActivePrinter, _
                                  InStr(ActivePrinter, " on ")))

15  pd.DesiredAccess = PRINTER_NORMAL_ACCESS
20  iRet = OpenPrinter(mstrPrinterName, hPrinter, pd)
25  If (iRet = 0) Or (hPrinter = 0) Then
        'Can't access current printer. Bail out doing nothing
30      Exit Function
35  End If

    'Get the size of the DEVMODE structure to be loaded
40  iRet = DocumentProperties(0, hPrinter, mstrPrinterName, 0, 0, 0)
45  If (iRet < 0) Then
        'Can't access printer properties.
50      GoTo CleanUp
55  End If

    'Make sure the byte array is large enough
    'Some printer drivers lie about the size of the DEVMODE structure they
    'return, so an extra 100 bytes is provided just in case!
60  ReDim yDevModeData(0 To iRet + 100) As Byte

    'Load the byte array
65  iRet = DocumentProperties(0, hPrinter, mstrPrinterName, _
                              VarPtr(yDevModeData(0)), 0, DM_OUT_BUFFER)
70  If (iRet < 0) Then
75      GoTo CleanUp
80  End If

    'Copy the byte array into a structure so it can be manipulated
85  Call CopyMemory(dm, yDevModeData(0), Len(dm))

90  If dm.dmFields And iPropertyType = 0 Then
        'Wanted property not available. Bail out.
95      GoTo CleanUp
100 End If

    'Set the property to the appropriate value
105 Select Case iPropertyType
        Case DM_ORIENTATION
110         dm.dmOrientation = iPropertyValue
115     Case DM_PAPERSIZE
120         dm.dmPaperSize = iPropertyValue
125     Case DM_PAPERLENGTH
130         dm.dmPaperLength = iPropertyValue
135     Case DM_PAPERWIDTH
140         dm.dmPaperWidth = iPropertyValue
145     Case DM_DEFAULTSOURCE
150         dm.dmDefaultSource = iPropertyValue
155     Case DM_PRINTQUALITY
160         dm.dmPrintQuality = iPropertyValue
165     Case DM_COLOR
170         dm.dmColor = iPropertyValue
175     Case DM_DUPLEX
180         dm.dmDuplex = iPropertyValue
185 End Select

    'Load the structure back into the byte array
190 Call CopyMemory(yDevModeData(0), dm, Len(dm))

    'Tell the printer about the new property
195 iRet = DocumentProperties(0, hPrinter, mstrPrinterName, _
                              VarPtr(yDevModeData(0)), VarPtr(yDevModeData(0)), _
                              DM_IN_BUFFER Or DM_OUT_BUFFER)

200 If (iRet < 0) Then
205     GoTo CleanUp
210 End If

    'The code above *ought* to be sufficient to set the property
    'correctly. Unfortunately some brands of Postscript printer don't
    'seem to respond correctly. The following code is used to make
    'sure they also respond correctly.
215 Call GetPrinter(hPrinter, 2, 0, 0, iBytesNeeded)
220 If (iBytesNeeded = 0) Then
        'Couldn't access shared printer settings
225     GoTo CleanUp
230 End If

    'Set byte array large enough for PRINTER_INFO_2 structure
235 ReDim yPInfoMemory(0 To iBytesNeeded + 100) As Byte

    'Load the PRINTER_INFO_2 structure into byte array
240 iRet = GetPrinter(hPrinter, 2, yPInfoMemory(0), iBytesNeeded, iJunk)
245 If (iRet = 0) Then
        'Couldn't access shared printer settings
250     GoTo CleanUp
255 End If

    'Copy byte array into the structured type
260 Call CopyMemory(pinfo, yPInfoMemory(0), Len(pinfo))

    'Load the DEVMODE structure with byte array containing
    'the new property value
265 pinfo.pDevmode = VarPtr(yDevModeData(0))

    'Set security descriptor to null
270 pinfo.pSecurityDescriptor = 0

    'Copy the PRINTER_INFO_2 structure back into byte array
275 Call CopyMemory(yPInfoMemory(0), pinfo, Len(pinfo))

    'Send the new details to the printer
280 iRet = SetPrinter(hPrinter, 2, yPInfoMemory(0), 0)

    'Indicate whether it all worked or not!
285 SetPrinterProperty = CBool(iRet)

CleanUp:
    'Release the printer handle
290 If (hPrinter <> 0) Then Call ClosePrinter(hPrinter)

    'Flush the message queue. If you don't do this,
    'you can get page fault errors when you try to
    'print a document immediately after setting a printer property.
295 For iCount = 1 To 20
300     DoEvents
305 Next iCount


End Function

Public Function SelectPrinter(objSession As TC_Session, strLookForPrinterName As String) As String

5   On Error GoTo RaiseErrorHandler

    ' Dim dlg As fdlgDruckerAuswahl
    Dim boolSavedScrUpdateState As Boolean
    Dim strResult As String

10  strResult = vbNullString

15  boolSavedScrUpdateState = Application.ScreenUpdating

20  Application.ScreenUpdating = True
25  Application.ScreenRefresh
    ' DoEvents

30  Set Me.SessionForSelect = objSession


35  Me.LookForPrinterName = strLookForPrinterName


40  Me.PrinterDialogLabel = "Bitte einen Drucker aus der Liste ausw|fffd|hlen oder Abbruch der Aktion mit " & _
                            Chr(34) & "Abbrechen" & Chr(34)

45  Call Me.ParentIkolClientApp.frmDruckerAuswahl.CustomShowUserForm

50  If Not Me.SelectCanceled Then
55      strResult = Me.PrinterName
60  End If

65  Application.ScreenRefresh
70  Application.ScreenUpdating = boolSavedScrUpdateState

ExitProc:
75  SelectPrinter = strResult
80  Exit Function

RaiseErrorHandler:
85  strResult = vbNullString
90  Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::SelectPrinter" & " in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc
End Function

Private Sub QuickSort(vSort() As String, _
                      ByVal idxStart As Integer, _
                      ByVal idxEnd As Variant)
    Dim i As Integer
    Dim j As Integer
    Dim h As String
    Dim x As String

5   i = idxStart: j = idxEnd
10  x = vSort((idxStart + idxEnd) / 2)

15  Do
20      While (vSort(i) < x): i = i + 1: Wend
25      While (vSort(j) > x): j = j - 1: Wend

30      If (i <= j) Then
35          h = vSort(i)
40          vSort(i) = vSort(j)
45          vSort(j) = h
50          i = i + 1: j = j - 1
55      End If
60  Loop Until (i > j)

65  If (idxStart < j) Then QuickSort vSort, idxStart, j
70  If (i < idxEnd) Then QuickSort vSort, i, idxEnd

End Sub

Public Function GetAllPrinters(session As TC_Session, _
                               idxDefault As Integer, _
                               LookForPrinterName As String, _
                               withProtokoll As Boolean) As String()

5   On Error GoTo RaiseErrorHandler

    Dim idx As Integer
    Dim idxStd As Integer
    Dim iniIdx As Integer
    Dim idxLookFor As Integer
    Dim defaultPrinter As String
    Dim allPrinters() As String
    Dim printerMsg As String
    Dim maxNameLen As Integer
    Dim printerIndend As Integer
    Dim lookForPrinter As Boolean

10  Call InitAllPrintersNew
15  ReDim allPrinters(UBound(mstrarrInstalledPrinter) - LBound(mstrarrInstalledPrinter))
20  lookForPrinter = LookForPrinterName <> vbNullString
25  idxLookFor = -1
30  If withProtokoll Then
35      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::GetAllPrinters: Aufruf von GetAllPrinters mit lookForPrintername = " & Chr(34) & _
                                                               LookForPrinterName & Chr(34), session)
40      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::GetAllPrinters: Die folgenden Drucker sind im System installiert:", session)
45  End If

50  maxNameLen = 0
55  printerIndend = 20
60  If withProtokoll Then
65      For idx = LBound(mstrarrInstalledPrinter) To UBound(mstrarrInstalledPrinter)
70          If Len(mstrarrInstalledPrinter(idx)) > maxNameLen Then
75              maxNameLen = Len(mstrarrInstalledPrinter(idx))
80          End If
85      Next idx
90  End If

    ' defaultPrinter = session.SessionColl.defaultPrinter
95  defaultPrinter = ParentIkolClientApp.DefaultPrinterName

100 iniIdx = LBound(mstrarrInstalledPrinter)
105 For idx = LBound(allPrinters) To UBound(allPrinters)
110     allPrinters(idx) = mstrarrInstalledPrinter(iniIdx)
115     If withProtokoll Then
120         printerMsg = Space(printerIndend) & allPrinters(idx)
125     End If

130     If lookForPrinter Then
135         If Me.ParentIkolClientApp.Tools.SamePrinter(allPrinters(idx), LookForPrinterName, False) Then
140             idxLookFor = idx
145             lookForPrinter = False
150         End If
155     End If
160     If Me.ParentIkolClientApp.Tools.SamePrinter(allPrinters(idx), defaultPrinter, False) Then
165         idxStd = idx
170         If withProtokoll Then
175             printerMsg = Mid(printerMsg & Space(maxNameLen), 1, maxNameLen + printerIndend) & "  (Standarddrucker)"
180         End If
185     End If
190     If withProtokoll Then
195         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::GetAllPrinters: " & printerMsg, session)
200     End If
205     iniIdx = iniIdx + 1
210 Next idx
215 If idxLookFor <> -1 Then
220     idxDefault = idxLookFor
225 Else
230     idxDefault = idxStd
235 End If
240 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_PrinterSetupHandler::GetAllPrinters: Ergebnis der Suche: idxStandard: " & idxStd & " idxLookFor " & idxLookFor, session)

ExitProc:
245 GetAllPrinters = allPrinters
250 Exit Function

RaiseErrorHandler:
255 Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::GetAllPrinters" & " in Zeile:" & Erl & vbCrLf, Err.Description
260 Resume ExitProc
End Function

Public Function GetNormalizedPrinterName(strPrinterName As String, _
                                         ByRef strNormalizedPrinterName As String, _
                                         boolTestIfDefault As Boolean) As PrinterSearchState

5   On Error GoTo RaiseErrorHandler

    Dim intIndex As Integer
    Dim intNormIndex As Integer
    Dim strMseg As String


    Dim enumResult As PrinterSearchState


10  enumResult = ssNoPrinter

15  If boolTestIfDefault Then
20      strNormalizedPrinterName = strPrinterName
25      enumResult = ssOnePrinter
30      GoTo ExitProc
35  End If

40  Call Me.InitAllPrintersNew

45  intNormIndex = LBound(mstrarrInstalledPrinter)

50  For intIndex = LBound(mstrarrInstalledPrinter) To UBound(mstrarrInstalledPrinter)
55      If Me.ParentIkolClientApp.Tools.SamePrinter(strPrinterName, mstrarrInstalledPrinter(intIndex), False) Then
60          If enumResult = ssNoPrinter Then
65              intNormIndex = intIndex
70              enumResult = ssOnePrinter
75          Else
80              If enumResult = ssOnePrinter Then
85                  enumResult = ssMorePrinter
90              End If
95          End If
100     End If
105 Next intIndex

110 If enumResult = ssMorePrinter Then
115     enumResult = ssNoPrinter
120     For intIndex = LBound(mstrarrInstalledPrinter) To UBound(mstrarrInstalledPrinter)
125         If strPrinterName = mstrarrInstalledPrinter(intIndex) Then
130             If enumResult = ssNoPrinter Then
135                 intNormIndex = intIndex
140                 enumResult = ssOnePrinter
145             Else
150                 If enumResult = ssOnePrinter Then
155                     enumResult = ssMorePrinter
160                 End If
165             End If
170         End If
175     Next intIndex
180     If enumResult = ssNoPrinter Then
185         enumResult = ssMorePrinter
190     End If
195 End If

200 Select Case enumResult
        Case ssNoPrinter
205         strNormalizedPrinterName = vbNullString
210         strMseg = "Normalisierung Druckername - konnte keinen normalisierten Namen finden"
215     Case ssOnePrinter
220         strNormalizedPrinterName = mstrarrInstalledPrinter(intNormIndex)
225         strMseg = vbNullString
230     Case ssMorePrinter
235         strNormalizedPrinterName = vbNullString
240         strMseg = "Normalisierung Druckername - Druckername ist mehrdeutig, konnte keinen normalisierten Namen finden"
245 End Select

250 If strMseg <> vbNullString Then
255     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg(strMseg)
260     If enumResult = ssMorePrinter Then
265         Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_PrinterSetupHandler::GetNormalizedPrinterName: Die folgenden Drucker sind installiert")
270         For intIndex = LBound(mstrarrInstalledPrinter) To UBound(mstrarrInstalledPrinter)
275             Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg(Me.ParentIkolClientApp.Tools.RightTabbedText(" " & intIndex, 7) & " - " & mstrarrInstalledPrinter(intIndex))
280         Next intIndex
285     End If
290 End If

ExitProc:
295 GetNormalizedPrinterName = enumResult
300 Exit Function

RaiseErrorHandler:
305 enumResult = ssNoPrinter
310 Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::GetNormalizedPrinterName" & " in Zeile:" & Erl & vbCrLf, Err.Description
315 Resume ExitProc

End Function

Public Sub InitAllPrintersNew()

5   On Error GoTo RaiseErrorHandler

    Dim boolSuccess As Boolean
    Dim longBufferRequired As Long
    Dim longBufferSize As Long
    Dim iBuffer() As Long
    Dim longEntries As Long
    Dim longIndex As Long
    Dim strPrinterName As String
    Dim longDummy As Long

    ' man kennt schon, ob ein Drucker installiert ist oder nicht => sofort verslassen
10  If Me.IsAPrinterInstalled Then
15      GoTo ExitProc
20  End If

25  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_PrinterSetupHandler::InitAllPrintersNew: Initialisierung der Druckertabelle")
30  longBufferSize = 3072

35  ReDim iBuffer((longBufferSize \ 4) - 1) As Long

    'EnumPrinters will return a value False if the buffer is not big enough
40  boolSuccess = EnumPrinters(PRINTER_ENUM_CONNECTIONS Or PRINTER_ENUM_LOCAL, _
                               vbNullString, _
                               1, _
                               iBuffer(0), _
                               longBufferSize, _
                               longBufferRequired, _
                               longEntries)

45  If Not boolSuccess Then
50      If longBufferRequired > longBufferSize Then
55          longBufferSize = longBufferRequired
60          ReDim iBuffer(longBufferSize \ 4) As Long
65      End If
        'Try again with new buffer
70      boolSuccess = EnumPrinters(PRINTER_ENUM_CONNECTIONS Or PRINTER_ENUM_LOCAL, _
                                   vbNullString, _
                                   1, _
                                   iBuffer(0), _
                                   longBufferSize, _
                                   longBufferRequired, _
                                   longEntries)
75  End If

80  If Not boolSuccess Then
        'Enumprinters returned False
85      Err.Raise glongCUSTOM_ERR_PRINTERTABLE_INITIALIZATION, "TC_PrinterSetupHandler::InitAllPrintersNew", "Das Initialisieren der Druckertabelle ist fehlgeschlagen"
90  End If

    'Enumprinters returned True, use found printers to fill the array
95  ReDim mstrarrInstalledPrinter(longEntries - 1)

100 For longIndex = 0 To longEntries - 1
        'Get the printername
105     strPrinterName = Space$(StrLen(iBuffer(longIndex * 4 + 2)))
110     longDummy = PtrToStr(strPrinterName, iBuffer(longIndex * 4 + 2))
115     mstrarrInstalledPrinter(longIndex) = strPrinterName
120 Next longIndex

125 Call QuickSort(mstrarrInstalledPrinter, LBound(mstrarrInstalledPrinter), UBound(mstrarrInstalledPrinter))

130 Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_PrinterSetupHandler::InitAllPrintersNew: Die folgenden Drucker sind installiert")

135 For longIndex = LBound(mstrarrInstalledPrinter) To UBound(mstrarrInstalledPrinter)
140     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg(Me.ParentIkolClientApp.Tools.RightTabbedText(" " & longIndex, 7) & " - " & mstrarrInstalledPrinter(longIndex))
145 Next longIndex
    ' man hat gerade ermittelt , dass ein Drucker installiert ist
150 Me.IsAPrinterInstalled = True


ExitProc:
155 Exit Sub

RaiseErrorHandler:
160 Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::InitAllPrintersNew" & " in Zeile:" & Erl & vbCrLf, Err.Description
165 Resume ExitProc

End Sub

Public Function DruckerauswahlDateiDrucken(retPrinter As String, _
                                           retPageType As WdPrintOutPages, _
                                           retItem As WdPrintOutItem, _
                                           retPages As String, _
                                           retRange As WdPrintOutRange, _
                                           retCopies As Integer, _
                                           retCollate As Boolean) As Boolean

5   On Error GoTo RaiseErrorHandler

    '|fffd|ffnet den Datei|Drucken-Dialog, und |fffd|bergibt
    'den eingestellten Drucker an die Variable strDrucker
    'Der voreingestellte Drucker wird dabei nicht(!) ge|fffd|ndert!
    ' retRange    Druckbereich (alles, aktuelle seite, from-to, Seitenbereich, Selection
    ' retPages    Zeichenkette, welche Seiten gedruckt werden
    ' retCopies   Anzahl der Kopien
    ' retCollate  Sortierung.
    ' retPageType gibt an, ob alle, gerade oder ungerade Seiten gedruckt werden sollen
    ' retItem     wird durch MS-Word falsch zur|fffd|ckgegeben (Type existiert auch im |fffd|bergeordneten Dialog)
    ' weitere Dialogfelder:
    '   Background,
    '   AppendPrFile,
    '   PrToFileName,
    '   From,
    '   To,
    '   PrintToFile
    '   FileName,
    '   OutputPrinter,
    '   DuplexPrint,
    '   PrintZoomColumn,
    '   PrintZoomRow,
    '   PrintZoomPaperWidth,
    '   PrintZoomPaperHeight,
    '   ZoomPaper

    Dim intRetValue As Integer                        ' gibt gedr|fffd|ckte Taste des dialogs zur|fffd|ck
    Dim strCurrentPrinter As String
    Dim boolResult As Boolean

10  If retPrinter <> vbNullString Then
15      strCurrentPrinter = Application.ActivePrinter
20      Application.ActivePrinter = retPrinter
25  Else
30      strCurrentPrinter = vbNullString
35  End If

40  With Dialogs(wdDialogFilePrint)
45      intRetValue = .Display
50      If intRetValue = -1 Then
55          retPrinter = .printer
60          retRange = .Range
65          retPages = .Pages
70          retCopies = .NumCopies
75          retCollate = .Collate
80          retPageType = .Order
85          retItem = wdPrintDocumentContent
90      End If
95  End With

100 If strCurrentPrinter <> vbNullString Then
105     Application.ActivePrinter = strCurrentPrinter
110 End If

115 boolResult = (intRetValue = -1)                   'ok

ExitProc:
120 DruckerauswahlDateiDrucken = boolResult
125 Exit Function

RaiseErrorHandler:
130 boolResult = False
135 Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::DruckerauswahlDateiDrucken" & " in Zeile:" & Erl & vbCrLf, Err.Description
140 Resume ExitProc
End Function


Public Sub DetermineDefaultPrinterForIkolClientApp()

    Dim enumPrinterSearchState As PrinterSearchState
    Dim strNormalizedPrinter As String

5   If Me.ParentIkolClientApp.DefaultPrinterName = vbNullString Then
10      Err.Raise glongCUSTOM_ERR_DEFAULT_PRINTER_NOT_DEFINED, "TC_PrinterSetupHandler.DetermineDefaultPrinterForIkolClientApp", _
                  "ParentIkolClientApp.DefaultPrinterName ist nicht definiert."
15  Else
        ' abfragen wieviele Drucker installiert sind
20      enumPrinterSearchState = GetNormalizedPrinterName(Me.ParentIkolClientApp.DefaultPrinterName, strNormalizedPrinter, True)
25  End If

    ' wenn kein oder mehr als ein Drucker installiert sind, fahre ohne Standarddrucker fort
30  If enumPrinterSearchState <> ssOnePrinter Then
35      Me.ParentIkolClientApp.DefaultPrinterName = vbNullString
40  Else
45      Me.ParentIkolClientApp.DefaultPrinterName = strNormalizedPrinter
50  End If

ExitProc:
55  Exit Sub

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_PrinterSetupHandler::DetermineDefaultPrinterForIkolClientApp", Err.Description
65  Resume ExitProc
End Sub

Attribute VB_Name = "TC_RibbonAndCommandbarRelated"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_RibbonAndCommandbarRelated.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Sub GetEnabledValue(ByRef controlId As String, ByRef enabled)

5   On Error GoTo RaiseErrorHandler
    Dim session As TC_Session

10  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
15      enabled = False
20  Else
25      Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
30      If session Is Nothing Then
35          enabled = False
40      Else
45          enabled = session.SessionAssociatedCommandBarOrRibon.GetEnabled(controlId, session)
50      End If
55  End If

ExitProc:
60  Set session = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::GetEnabledValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub

Public Sub GetTabVisibleValue(ByRef visible)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session
    Dim objTcDoc As TC_Document

10  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
15      visible = False
20  Else
25      If Me.ParentIkolClientApp.SessionsContainer.GetCountOfSessionsInContainer > 0 Then
30          Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

35          If session Is Nothing Then
40              visible = False
45          Else


50              Set objTcDoc = session.GetWorkingTcDocument
55              If objTcDoc Is Nothing Then
60                  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("GetTabVisibleValue: Session aktiv, aber kein Dokument, Commandbar visible = " & Me.ParentIkolClientApp.RibbonVisible)
65                  visible = Me.ParentIkolClientApp.RibbonVisible
70              Else
75                  If objTcDoc.SignUpWindow Is Nothing Then
80                      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("GetTabVisibleValue: Session aktiv, f|fffd|r Commandbar ist visible = " & Me.ParentIkolClientApp.RibbonVisible)
85                      visible = Me.ParentIkolClientApp.RibbonVisible
90                  Else
95                      If objTcDoc.SignUpWindow = Application.ActiveWindow Then
100                         Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("GetTabVisibleValue: Session aktiv, f|fffd|r ist aber das Unterschriftenfenster -> Ribbonvisible = false")
105                         visible = False
110                     Else
115                         Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("GetTabVisibleValue: Session aktiv, f|fffd|r Commandbar ist visible = " & Me.ParentIkolClientApp.RibbonVisible)
120                         visible = Me.ParentIkolClientApp.RibbonVisible
125                     End If
130                 End If
135             End If
140         End If

145     Else
150         visible = False
155     End If
160 End If

ExitProc:
165 Set session = Nothing
170 Exit Sub

RaiseErrorHandler:
175 Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::GetTabVisibleValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
180 Resume ExitProc
End Sub

Public Sub GetVisibleValue(ByRef controlId As String, ByRef visible)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
15      visible = False
20  Else
25      If controlId = "tab1" Then
30          visible = Me.ParentIkolClientApp.RibbonVisible
35      ElseIf controlId = "grp0" Then
40          visible = Me.ParentIkolClientApp.RibbonVisible
45      Else
50          Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
55          If session Is Nothing Then
60              visible = False
65          Else
70              visible = session.SessionAssociatedCommandBarOrRibon.GetVisible(controlId, session)
75          End If
80      End If
85  End If

ExitProc:
90  Set session = Nothing
95  Exit Sub

RaiseErrorHandler:
100 Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::GetVisibleValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
105 Resume ExitProc
End Sub

Public Sub GetToolTipText(ByRef controlId As String, ByRef toolTipText)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
15      toolTipText = vbNullString
20  Else
25      Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
30      If session Is Nothing Then
35          toolTipText = vbNullString
40      Else
45          toolTipText = session.SessionAssociatedCommandBarOrRibon.GetToolTip(controlId, session)
50      End If
55  End If

ExitProc:
60  Set session = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::GetToolTipText" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub

Public Function DoRibbonButtonAction(ByRef controlId As String) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim session As TC_Session
    Dim boolResult As Boolean

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte TC_RibbonAndCommandbarRelated::DoRibbonButtonAction f|fffd|r (" & controlId & ")")
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Aktives Fenster ist: " & ActiveWindow.Caption & " Aktives Dokuments ist: " & ActiveDocument.name)
20  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

25  If Not session Is Nothing Then
30      boolResult = session.SessionAssociatedCommandBarOrRibon.DoAction(controlId, session)
35  Else
40      Err.Raise glongCUSTOM_ERR_CANNOT_RETRIEVE_ACTIVE_SESSION, "TC_RibbonAndCommandbarRelated::DoRibbonButtonAction", "Keine aktive Session gefunden -> der Button " & controlId & " kann nicht mehr angesprochen werden"
45  End If
50  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Beende TC_RibbonAndCommandbarRelated::DoRibbonButtonAction gestartet f|fffd|r [" & controlId & "]")

ExitProc:
55  DoRibbonButtonAction = boolResult
60  Set session = Nothing
65  Exit Function

RaiseErrorHandler:
70  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_RibbonAndCommandbarRelated", "DoRibbonButtonAction", , vbNullString, True)
75  Resume ExitProc
End Function

Public Function IsCommandBarDotFileAlreadyLoaded(strRibbonFileNameToCheck As String) As Boolean
    'durch die Addins gehen und suchen ob schon geladen.....

    Dim objAddInCounter As Addin
    Dim boolFound As Boolean

5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start Ausf|fffd|hrung TC_RibbonAndCommandbarRelated::IsCommandBarDotFileAlreadyLoaded()", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

15  boolFound = False

20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Suche nach Ribbon Add-Inn-Vorlagendatei: '" & strRibbonFileNameToCheck & "'", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

25  On Error Resume Next

30  For Each objAddInCounter In Application.AddIns
35      If (UCase(objAddInCounter.name) = _
            UCase(strRibbonFileNameToCheck)) And objAddInCounter.Installed Then
40          boolFound = True
45          GoTo ExitProc
50      End If
55  Next objAddInCounter

60  On Error GoTo RaiseErrorHandler

ExitProc:

65  If boolFound Then
70      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Eine Ribbon-AddInn-Vorlagendatei wurde gefunden und ist installiert.", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
75  Else
80      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Keine Ribbon-AddInn-Vorlagendatei ist bereits installiert.", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
85  End If

90  Set objAddInCounter = Nothing
95  IsCommandBarDotFileAlreadyLoaded = boolFound
100 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_RibbonAndCommandbarRelated::IsCommandBarDotFileAlreadyLoaded", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
105 Exit Function

RaiseErrorHandler:
110 boolFound = False
115 Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::IsCommandBarDotFileAlreadyLoaded" & " in Zeile:" & Erl & vbCrLf, Err.Description
120 Resume ExitProc
End Function


Public Sub LoadSymbolBar2007AddIn(strSymbolBarName As String, objSession As TC_Session)
    Dim strCommandBarDotFileFullName As String
    Dim myAddIn As Addin
    Dim boolRibbonInstallNeeded As Boolean

5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start Ausf|fffd|hrung TC_RibbonAndCommandbarRelated::LoadSymbolBar2007AddIn()", objSession)

15  Call objSession.AddRibbonOrCommandbarToSession(strSymbolBarName)
20  strCommandBarDotFileFullName = objSession.WinworkPath & gstrIKOL_RIBBONDOT

25  If Not Me.IsCommandBarDotFileAlreadyLoaded(gstrIKOL_RIBBONDOT) Then
        ' if die ikol-ribbon.dot-Datei noch nicht geladen ist, lade sei
        ' die Sichtbarkeit der einzelnen Controls laut |fffd|bergebenen Definitionsnamen ermitteln und zur Session hinzuf|fffd|gen

30      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Installiere die beiliegende Ribbon-AddInn-Vorlagendatei '" & _
                                                               strCommandBarDotFileFullName & "'", objSession)

        '!!!! somit werden die Callbacks in der ikol-ribbon.dotm ausgel|fffd|st -> TC_IKOL_OnRibbonLoad wird da ausgef|fffd|hrt
35      Set RibbonCommunicator.gobjIkolClientApp = Me.ParentIkolClientApp
40      Set myAddIn = Application.AddIns.Add(strCommandBarDotFileFullName, True)
45      myAddIn.Installed = True
50  End If
55  Set RibbonCommunicator.gobjIkolClientApp = Me.ParentIkolClientApp
60  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadSymbolBar2007AddIn: Das IRibbonUI-Objekt ist geladen ==> Aufrufen von TC_IkolClientApp::DisplaySymbolBar()", objSession)
65  Call Me.ParentIkolClientApp.DisplaySymbolBar(True)

ExitProc:
70  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_RibbonAndCommandbarRelated::LoadSymbolBar2007AddIn()", objSession)
75  Exit Sub

RaiseErrorHandler:
80  Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::LoadSymbolBar2007AddIn" & " in Zeile:" & Erl & vbCrLf, Err.Description
85  Resume ExitProc
End Sub


Public Sub LoadCommandBar2003AddIn(strSymbolBarName As String, objSession As TC_Session)
5   On Error GoTo RaiseErrorHandler

    Dim strCommandBarDot As String
    Dim myAddIn As Addin
    Dim boolAddinFoundAndAlreadyInstalled As Boolean

10  boolAddinFoundAndAlreadyInstalled = False

15  strCommandBarDot = objSession.WinworkPath & gstrIKOL_CMDBARDOT
20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn: Starte Laden vom Add-Inn '" & gstrIKOL_CMDBARDOT & "'", objSession)



25  On Error Resume Next
30  For Each myAddIn In AddIns
35      If UCase(myAddIn.name) = UCase(gstrIKOL_CMDBARDOT) Then

40          If myAddIn.Installed Then
45              boolAddinFoundAndAlreadyInstalled = True
50              Exit For
55          End If
60      End If
65  Next myAddIn

70  On Error GoTo RaiseErrorHandler

75  If boolAddinFoundAndAlreadyInstalled Then
80      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn: Ein Add-In '" & gstrIKOL_CMDBARDOT & "' ist bereits installiert. Kein Nachinstallieren notwendig", objSession)
85  Else
90      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn: Kein Add-In '" & gstrIKOL_CMDBARDOT & "' ist bereits installiert.", objSession)
95      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn: Das beiliegende Add-In '" & strCommandBarDot & "' installieren.", objSession)
100     Call Application.AddIns.Add(strCommandBarDot, True)
105     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn: Das beiliegende Add-In '" & strCommandBarDot & "' erfolgreich installiert.", objSession)
110 End If

115 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn: Beende das Laden vom Add-Inn '" & gstrIKOL_CMDBARDOT & "'", objSession)

    ' die Sichtbarkeit der einzelnen Controls laut |fffd|bergebenen Definitionsnamen ermitteln und zur Session hinzuf|fffd|gen
120 Call objSession.AddRibbonOrCommandbarToSession(strSymbolBarName)

    'die Beziehung der Symbolleiste zu ParentIkolClientApp-Objekt herstellen
125 Set RibbonCommunicator.gobjIkolClientApp = Me.ParentIkolClientApp

130 Call Me.ParentIkolClientApp.DisplaySymbolBar(True)

ExitProc:
135 Set myAddIn = Nothing
140 Exit Sub

RaiseErrorHandler:
145 Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::LoadCommandBar2003AddIn" & " in Zeile:" & Erl & vbCrLf, Err.Description
150 Resume ExitProc
End Sub

Public Sub LoadCommandBarAccordingToWordVersion(strSymbolBar As String, session As TC_Session)

10    On Error GoTo RaiseErrorHandler
    Dim intWordVersion As Integer

20    intWordVersion = CInt(Mid(Application.Version, 1, 2))

'04.07.2014 AL (1)
'Wenn bereits ein anderes Dokument ge|fffd|ffnet ist, kam es zum Absturz (Fehler [4605]).
'Deshalb kurzzeitig ein solches Dukument entsperren und danach Schutz wieder herstellen
Dim actDoc As Document
Dim actProt As WdProtectionType
Dim actProtChanged As Boolean

30    actProtChanged = False

40    If Application.Documents.count > 0 Then
50      Set actDoc = Application.ActiveDocument
60      actProt = actDoc.ProtectionType
  
70      If actDoc.ProtectionType <> wdNoProtection Then
80        actDoc.Unprotect
90        actProtChanged = True
100     End If
110   End If
'ENDE 04.07.2014 AL (1)

120   If intWordVersion < 12 Then
        ' MS Word bis 2003 einschl.
130     Call Me.LoadCommandBar2003AddIn(strSymbolBar, session)
140   Else
        ' MS Word ab 2007 einschl.
150     Call Me.LoadSymbolBar2007AddIn(strSymbolBar, session)
160   End If

'04.07.2014 AL (2)
'Schutz wieder herstellen
170   If actProtChanged = True Then
180     actDoc.Protect Type:=actProt, NoReset:=True
190     actDoc.Saved = True
200   End If
210   If Not actDoc Is Nothing Then
220     Set actDoc = Nothing
230   End If
'ENDE 04.07.2014 AL (2)

ExitProc:
240   Exit Sub

RaiseErrorHandler:
250   Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::LoadCommandBarAccordingToWordVersion" & " in Zeile:" & Erl & vbCrLf, Err.Description
260   Resume ExitProc
End Sub

' wird von TC_IKOL_OnRibbonLoad in der ikol_ribbon.dotm aufgerufen
Public Sub SetRibbonLoaded(intResult As Integer)
5   On Error GoTo RaiseErrorHandler

10  intResult = 0
15  If Me.ParentIkolClientApp.SessionsContainer Is Nothing Then
20      Call MsgBox("Set RibbonLoaded findet keine aktive Sessions", vbExclamation, Me.ParentIkolClientApp.MsgBoxTitle)
25      intResult = 1
30  Else
35      Me.ParentIkolClientApp.RibbonInstalled = True
40      intResult = 0
45  End If

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::SetRibbonLoaded" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Sub

Public Sub SetzeIKOLButtonEigenschaften(strControlId As String, _
                                        strNewAction As String, _
                                        strToolTip As String, _
                                        intResult As Integer)
5   On Error GoTo RaiseErrorHandler

    ' die Benutzerdefinierten Buttons 1,2 und 3

    ' intResult = 0 - alles in Ordnung
    '          1 - keine Sessions aktiv
    '          2 - Session hat keine Symbolleiste
    '          3 - Aktion und ToolTip konnte nicht gesetzt werden
    '          4 - ToolTip konnte nicht gesetzt werden

    Dim session As TC_Session
    Dim commandBarName As String
    Dim msgText As String

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Callbackfunktion: SetzeIKOLButtonEigenschaften")
15  Set session = Me.ParentIkolClientApp.SessionsContainer.GetSessionFromID(1)

20  If session Is Nothing Then
25      msgText = "Setzen der Controls in einer Symbolleiste f|fffd|r eine Session zu diesem Zeitpunkt nicht m|fffd|glich"
30      Call Me.ParentIkolClientApp.LogfileHandler.ViewGeneralMsgBox(msgText)
35      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(msgText & " (Result = 1)", session)
40      intResult = 1
45  Else
50      If session.SessionAssociatedCommandBarOrRibon Is Nothing Then
55          msgText = "Setzen der Controls in der Symbolleiste zu diesem Zeitpunkt nicht m|fffd|glich"
60          Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox(msgText, session)
65          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Setzen der Controls in der Symbolleiste " & _
                                                                   Chr(34) & commandBarName & Chr(34) & _
                                                                 " zu diesem Zeitpunkt nicht m|fffd|glich (Result = 2)", session)
70          intResult = 2
75      Else
80          commandBarName = session.SessionAssociatedCommandBarOrRibon.name
85          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Setzen des Controls '" & strControlId & _
                                                                   "' in der Symbolleiste " & Chr(34) & commandBarName & Chr(34) & " mit: " & vbLf & _
                                                                 " Aktion  = " & Chr(34) & strNewAction & Chr(34) & vbLf & _
                                                                 " strToolTip = " & Chr(34) & strToolTip & Chr(34), session)
90          If session.SessionAssociatedCommandBarOrRibon.SetAction(strControlId, strNewAction, session) Then
95              If session.SessionAssociatedCommandBarOrRibon.SetToolTip(strControlId, strToolTip, session) Then
100                 intResult = 0
105             Else
110                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Setzen der Tooltips '" & strToolTip & "' f|fffd|r Control '" & strControlId & _
                                                                           "' in der Symbolleiste " & Chr(34) & commandBarName & Chr(34) & "' nicht m|fffd|glich (Result = 4)", session)
115                 intResult = 4
120             End If
125         Else
130             Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Kann Control in der Symbolleiste nicht setzen", session)
135             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Setzen der Aktion '" & strNewAction & "' f|fffd|r Control '" & strControlId & _
                                                                       "' in der Symbolleiste " & Chr(34) & commandBarName & Chr(34) & "' nicht m|fffd|glich (Result = 3)", session)
140             intResult = 3
145         End If
150     End If
155 End If

ExitProc:
160 Set session = Nothing
165 Exit Sub

RaiseErrorHandler:
170 Err.Raise Err.Number, Err.Source & "->" & "TC_RibbonAndCommandbarRelated::SetzeIKOLButtonEigenschaften" & " in Zeile:" & Erl & vbCrLf, Err.Description
175 Resume ExitProc
End Sub
Attribute VB_Name = "TC_Session"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Diese Klasse beschreibt das Arbeiten einer Session die durch den Aufruf von
' SYSTEM.DOC gestartet wird.
' Ein Objekt der Klasse endet entweder beim Aufruf von BEENDE, Ausgang oder Beenden von Word.
' die Klasse enth|fffd|lt die Analyse der WE.Txt, die Abarbeitung der Makrofolge und
' die Steuerung der Synchronisation.

Private Const mstrWE_DELIMITER As String = ",()= "
Private Const mintLINE_INDENT_WIDTH As Integer = 2
Private Const mlongAPPLICATION_PID_NOT_APPLIED As Long = -1

Public Enum TC_SaveMode
    tcsNoSave
    tcsSave
    tcsSaveAs
End Enum

Public Enum TC_VersionPart
    tMajor
    tMinor
    tBuild
End Enum

Private Type Version
    major As Integer
    minor As Integer
    build As Integer
End Type

Private Type welnWeLine
    part() As String
End Type

' folgende Eigenschaften werden durch die Umgebung und WE-Datei gesetzt
Private mboolShowDebugMsgBoxes As Boolean             ' sollen gegenw|fffd|rtig Debug-Msg-Boxes angezeigt werden?
Private mboolWithProtocol As Boolean                  ' wird gegenw|fffd|rtig ein Protokoll geschrieben oder nicht?
Private mboolShouldWordStayOpen As Boolean            ' soll Word nach Beenden der Makrofolge offen bleiben?
Private mstrClientDirPath As String                   ' gibt den aktuellen Pfad der Anwendung an
Private mstrWinworkPath As String                     ' gibt den aktuellen Pfad der SYSTEM.DOC an
Private mstrDocDirPath As String                      ' gibt den aktuellen Pfad des Dokumentenverzeichnisses an
Private mstrCallingApplWindowTitle As String          ' gibt den Fenstertitel der rufenden (IKOL-) Anwendung an
Private mstrArchivDir As String                       ' gibt den aktuellen Pfad des Pfades f|fffd|r eAkte an
Private mstrCallingProgramName As String              ' gibt den Namen des rufenden IKOL-Programmteils an (XXDRUC)
Private mstrFormularActionName As String              ' gibt den Namen der aufgerufenen Makro-Aktionsfolge an
Private mstrEAktePrinter As String                    ' f|fffd|r den Vorgang eAkte benutzte Drucker
Private mstrWordDocumentPrinter As String             ' f|fffd|r den Druck der Dokumente augenblicklich benutzte Drucker
Private mboolCommandBarActiv As Boolean               ' gibt an, ob eine Symbolleiste aktiviert wurde
Private mobjTcCommandBar As TC_Commandbar             ' gibt das CommandBar-Objekt ab Office 2007 an
Private mstrApplicationToActivate As String           ' gibt die Anwendung an, die nach dem Beenden der Makrofolge
' aktiv sein soll
Private mstrServerName As String
Private mintPortNumber As Long
Private mintFokusOnWord As Integer                    ' Bit 0 gesetzt durch ANWENDUNG_D_AKTIVIEREN
' Bit 1 gesetzt durch LADE
' Bit 2 gesetzt durch Ende Behandlung wenn keine Application aktiv
Private mboolIsWeProcessingRunning As Boolean
Private mlongCallbackCallerApplicationPID As Long     ' ProcessID der rufenden Anwendung, wenn durch Callback-Funktion gesetzt wurde
Private mcolControlParameter As Collection

Private mobjWorkingDoc As Document                    ' enth|fffd|lt das aktuelle Dokument, das ge|fffd|ffnet und auf dem gearbeitet wird
Private mstrTcOs2Version As String                    ' enth|fffd|lt die Versionsnummer des aktuellen Session-Objektes
Private mintId As Integer                             ' enth|fffd|lt eine ID, die durch TC_SessionsContainer gesetzt wird
Private mstrWeFileCurrentName As String               ' gibt den aktuellen Namen der verwendetene WE-Datei an
Private mstrDoFileCurrentName As String               ' gibt den aktuellen Namen der verwendetene DO-Datei an

Private mstrDirectoryNameForSaveAs As String          ' gibt den Namen des Verzeichnisses an, in das standardm|fffd||fffd|ig bei Speichern unter
' gespeichert wird. Initialisierung mit dem Doc-Dir-Verzeichnis
Private mboolFileToBeDeletedAfterClose As Boolean     ' wird gesetzt, wenn Dokument geschlossen wird, um es anschliessend zu l|fffd|schen
Private mboolShowWarnings As Boolean                  ' wird durch SETZE_PARAMETER gesetzt.
Private mintProtocolLineIndent As Integer             ' gibt den Einzug f|fffd|r Protokollausschriften innerhalb eines Makros an
Private menumTcSessionResult As TC_SessionResult      ' enth|fffd|lt das Resultat des letzten ausgef|fffd|hrten Makros
Private mboolMergeEmptyLines As Boolean               ' soll beim Mischen mit den Daten leere Felder durch Leerzeilen ersetzt werden?
Private mboolIkolPrintMode As Boolean                 ' gibt den Druckmodus an, True wenn im Hintergrund gedruckt wird, _
                                                      False, wenn erst auf das Ende des Druckes gewartet wird.
Private mintOpenedDocumentsInCurrentSessionCounter As Integer    ' Z|fffd|hler der ge|fffd|ffneten Dokumente in dieser Session
Private mlongPidCallerOfOffice2ExeApplication As Long    ' die ID des Ikol-Clients, der Office2.exe aufgerufen hat
Private mboolSaveNotTriggeredByWordButtons As Boolean    ' die Variable merkt sich, ob das letzte Speichern durch ein TC-Save_Button ausgel|fffd|st wurde
Private mobjParentSessionsContainer As TC_SessionsContainer
Private mobjWEInstruction As TC_WEInstruction
Private mobjWEInstructionMacrosContainer As TC_WEInstructionMacrosContainer    ' Sammlung der durch die WE |fffd|bergebenen Makros
Private mobjManagedTCDocumentsContainer As TC_DocumentsContainer
Private mstrSignDefaultFile As String                 ' Pfad und Name des Tif-Files f|fffd|r das Kreuz
Private mstrSignTempDir As String                     ' Pfad des Verzeichnisses, wo die geleisteten Unterschriften gespeichert werden
Private mintSignScaleFactor As Integer                ' Skalierungsfaktor f|fffd|r die Anzeige des Unterschriftenpads.
Private menumSignSynchScreen As suSyncScreen
Private mboolSignWithCommandbar As Boolean
Private mstrTcSignIniFullFileName As String           ' Ini-File f|fffd|r das Unterschriftenmodul, wenn aktiv
Private mboolOldWayPrint As Boolean                   ' wird durch SETZE_PARAMETER gesetzt

Private mboolCommandOEFFNEAppliedInWe As Boolean      ' enth|fffd|lt Info, ob nach der Analyse der Befehlsfolge in WE der Befehl OEFFNE gefunden wurde
Private mboolDocumentAlreadySentToeAkte As Boolean    ' wird gesetzt sobald das Dokument auf dem eAkte-Drucker gedruckt wurde

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
Private mintWordmodus As Integer

'25.04.2016 AL
Private mboolUPadFinalQuestion As Boolean             'wird durch SETZE_PARAMETER gesetzt

'19.04.2016 AL
Private mstrSignPad As String                         'wird durch SETZE_PARAMETER gesetzt

'16.09.2014 AL
Private mboolRibbonMinimieren As Boolean              'wird durch SETZE_PARAMETER gesetzt

'08.10.2014 AL
Private mboolCheckFields As Boolean                   'wird durch SETZE_PARAMETER gesetzt

'14.11.2014 AL
Private mboolPrintHidden As Boolean                   'wird durch SETZE_PARAMETER gesetzt

'14.11.2014 AL
Private mboolPrintHiddenARC As Boolean                'wird durch SETZE_PARAMETER gesetzt

'23.01.2015 AL
Private mboolParamPrintHidden As Boolean              'ist wahr, wenn SETZE_PARAMETER PRINT_HIDDEN oder PRINT_HIDDEN_ARC in PYP vorkommt

'17.02.2015 AL
Private mboolSpeichernAlsSBentfernen As Boolean       'wird durch SETZE_PARAMETER gesetzt

'04.06.2015 AL
Private mboolSignMultiSelect As Boolean               'wird durch SETZE_PARAMETER gesetzt

'26.02.2018 AL
Private mboolDeltaScroll As Boolean                   'wird durch SETZE_PARAMETER gesetzt



Private Sub Class_Initialize()
10    Set mobjWEInstructionMacrosContainer = New TC_WEInstructionMacrosContainer
20    Set mobjWEInstructionMacrosContainer.ParentSession = Me
30    Set mobjManagedTCDocumentsContainer = New TC_DocumentsContainer
40    Set mobjManagedTCDocumentsContainer.ParentSession = Me
50    Set mcolControlParameter = New Collection
60    Set mobjTcCommandBar = Nothing

70    mintProtocolLineIndent = 0
80    mboolIkolPrintMode = False
90    mstrWordDocumentPrinter = ActivePrinter
100   mstrEAktePrinter = vbNullString
110   mstrWeFileCurrentName = vbNullString
120   mlongPidCallerOfOffice2ExeApplication = 0
130   mstrApplicationToActivate = vbNullString
140   mstrServerName = vbNullString
150   mintPortNumber = 0
160   mintFokusOnWord = 0
170   mboolIsWeProcessingRunning = False
180   mlongCallbackCallerApplicationPID = mlongAPPLICATION_PID_NOT_APPLIED
190   mstrDocDirPath = vbNullString
200   mstrClientDirPath = vbNullString
210   mstrWinworkPath = vbNullString
220   mstrDirectoryNameForSaveAs = vbNullString
230   mboolShowWarnings = True
240   mboolSaveNotTriggeredByWordButtons = False
250   mboolOldWayPrint = False
260   mstrSignDefaultFile = vbNullString
270   mintSignScaleFactor = 1
280   mstrTcSignIniFullFileName = vbNullString
290   menumSignSynchScreen = susNoValue
300   mboolSignWithCommandbar = True
310   mboolCommandOEFFNEAppliedInWe = False
320   mboolDocumentAlreadySentToeAkte = False

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
330   mintWordmodus = 0

'19.04.2016
340   mboolDruckIntern = False

'25.04.2016 AL
350   mboolUPadFinalQuestion = False

'19.04.2016 AL
360   mstrSignPad = "DESKTOP"

'16.09.2014 AL
370   mboolRibbonMinimieren = False

'08.10.2014 AL
380   mboolCheckFields = True

'14.11.2014 AL
390   mboolPrintHidden = False
400   mboolPrintHiddenARC = False

'23.01.2015 AL
410   mboolParamPrintHidden = False

'17.02.2015 AL
420   mboolSpeichernAlsSBentfernen = True

'04.06.2015 AL
430   mboolSignMultiSelect = False

'14.07.2016 AL
440   gboolNormalDotSaved = False 'gobal, weil Session schon zerst|fffd|rt, wenn das gebraucht wird

'26.02.2018 AL
450   mboolDeltaScroll = False

End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjWEInstructionMacrosContainer Is Nothing Then
10      Set mobjWEInstructionMacrosContainer = Nothing
15  End If

20  If Not mobjManagedTCDocumentsContainer Is Nothing Then
25      Set mobjManagedTCDocumentsContainer = Nothing
30  End If

35  If Not mcolControlParameter Is Nothing Then
40      Set mcolControlParameter = Nothing
45  End If

50  If Not mobjTcCommandBar Is Nothing Then
55      Set mobjTcCommandBar = Nothing
60  End If

65  If Not mobjParentSessionsContainer Is Nothing Then
70      Set mobjParentSessionsContainer = Nothing
75  End If

80  If Not mobjWEInstruction Is Nothing Then
85      Set mobjWEInstruction = Nothing
90  End If

End Sub

Public Property Get ParentSessionsContainer() As TC_SessionsContainer
5   On Error GoTo RaiseErrorHandler
10  Set ParentSessionsContainer = mobjParentSessionsContainer
ExitProc:
15  Exit Property

RaiseErrorHandler:
20  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::ParentSessionsContainer in Zeile:" & Erl & vbCrLf, Err.Description
25  Resume ExitProc
End Property

Public Property Set ParentSessionsContainer(objParentSessionsContainer As TC_SessionsContainer)
5   If mobjParentSessionsContainer Is Nothing Then
10      Set mobjParentSessionsContainer = objParentSessionsContainer
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_Session.ParentSessionsContainer", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get WEInstructionMacrosContainer() As TC_WEInstructionMacrosContainer
5   Set WEInstructionMacrosContainer = mobjWEInstructionMacrosContainer
End Property

Public Property Get ManagedTCDocumentsContainer() As TC_DocumentsContainer
5   Set ManagedTCDocumentsContainer = mobjManagedTCDocumentsContainer
End Property

Public Property Get PidCallerOfOffice2ExeApplication() As Long
5   PidCallerOfOffice2ExeApplication = mlongPidCallerOfOffice2ExeApplication
End Property

Public Property Let PidCallerOfOffice2ExeApplication(ByVal longPID As Long)
5   mlongPidCallerOfOffice2ExeApplication = longPID
End Property

Public Property Get WEInstruction() As TC_WEInstruction
5   Set WEInstruction = mobjWEInstruction
End Property

Public Property Set WEInstruction(objWeInstruction As TC_WEInstruction)
5   Set mobjWEInstruction = objWeInstruction
End Property

Public Property Get indent() As String
5   indent = Space(mintProtocolLineIndent)
End Property

Public Property Let SessionCommandBarActivated(ByVal vcommandBar As Boolean)
5   mboolCommandBarActiv = vcommandBar
End Property

Public Property Get SessionCommandBarActivated() As Boolean
5   SessionCommandBarActivated = mboolCommandBarActiv
End Property

Public Property Let ApplicationPID(ByVal vApplicationPID As Long)
5   mlongCallbackCallerApplicationPID = vApplicationPID
End Property

Public Property Get ApplicationPID() As Long
5   ApplicationPID = mlongCallbackCallerApplicationPID
End Property

Public Property Let SessionID(ByVal vID As Integer)
5   mintId = vID
End Property

Public Property Get SessionID() As Integer
5   SessionID = mintId
End Property

Public Property Let PrinterToUse(ByVal vPrinterToUse As String)
5   mstrWordDocumentPrinter = vPrinterToUse
End Property

Public Property Get PrinterToUse() As String
5   PrinterToUse = mstrWordDocumentPrinter
End Property

Public Property Let Printer_eAkte(ByVal vPrinter_eAkte As String)
5   mstrEAktePrinter = vPrinter_eAkte
End Property

Public Property Get Printer_eAkte() As String
5   Printer_eAkte = mstrEAktePrinter
End Property

Public Property Let ClientDirPath(ByVal vClientDirPath As String)
5   mstrClientDirPath = vClientDirPath
End Property

Public Property Get ClientDirPath() As String
5   ClientDirPath = mstrClientDirPath
End Property

Public Property Let WinworkPath(ByVal vWinworkPath As String)
5   mstrWinworkPath = vWinworkPath
End Property

Public Property Get WinworkPath() As String
5   WinworkPath = mstrWinworkPath
End Property

Public Property Let SaveAsDirectory(ByVal vSaveAsDirectory As String)
5   mstrDirectoryNameForSaveAs = vSaveAsDirectory
End Property

Public Property Get SaveAsDirectory() As String
5   SaveAsDirectory = mstrDirectoryNameForSaveAs
End Property

Public Property Let DocDirPath(ByVal vDocDirPath As String)
5   mstrDocDirPath = vDocDirPath
End Property

Public Property Get DocDirPath() As String
5   DocDirPath = mstrDocDirPath
End Property

Public Property Let CallingApplName(ByVal vCallingApplName As String)
5   mstrCallingApplWindowTitle = vCallingApplName
End Property

Public Property Get CallingApplName() As String
5   CallingApplName = mstrCallingApplWindowTitle
End Property

Public Property Let ArchivDir(ByVal vArchivDir As String)
5   mstrArchivDir = vArchivDir
End Property

Public Property Get ArchivDir() As String
5   ArchivDir = mstrArchivDir
End Property

Public Property Let CallingPgmName(ByVal vCallingPgmName As String)
5   mstrCallingProgramName = vCallingPgmName
End Property

Public Property Get CallingPgmName() As String
5   CallingPgmName = mstrCallingProgramName
End Property

Public Property Let ShowWarnings(ByVal vShowWarnings As Boolean)
5   mboolShowWarnings = vShowWarnings
End Property

Public Property Get ShowWarnings() As Boolean
5   ShowWarnings = mboolShowWarnings
End Property

Public Property Let MacroAction(ByVal vMacroAction As String)
5   mstrFormularActionName = vMacroAction
End Property

Public Property Get MacroAction() As String
5   MacroAction = mstrFormularActionName
End Property

Public Property Let IKOLPrintMode(ByVal vPrintMode As Boolean)
5   mboolIkolPrintMode = vPrintMode
End Property

Public Property Get IKOLPrintMode() As Boolean
5   IKOLPrintMode = mboolIkolPrintMode
End Property

Public Property Get MaximizeWordAfterSessionClose() As Boolean
5   MaximizeWordAfterSessionClose = mboolShouldWordStayOpen
End Property

Public Property Let MaximizeWordAfterSessionClose(ByVal vWordStayOpen As Boolean)
5   mboolShouldWordStayOpen = vWordStayOpen
End Property

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
Public Property Get Wordmodus() As Integer
5   Wordmodus = mintWordmodus
End Property

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
Public Property Let Wordmodus(ByVal wert As Integer)
5   mintWordmodus = wert
End Property


'25.04.2016 AL
Public Property Let UPadFinalQuestion(ByVal vUPadFinalQuestion As Boolean)
5   mboolUPadFinalQuestion = vUPadFinalQuestion
End Property

'25.04.2016 AL
Public Property Get UPadFinalQuestion() As Boolean
5   UPadFinalQuestion = mboolUPadFinalQuestion
End Property

'19.04.2016 AL
Public Property Let SignPad(ByVal vSignPad As String)
5   mstrSignPad = vSignPad
End Property

'19.04.2016 AL
Public Property Get SignPad() As String
5   SignPad = mstrSignPad
End Property

'16.09.2014 AL
Public Property Let RibbonMinimieren(ByVal vRibbonMinimieren As Boolean)
5   mboolRibbonMinimieren = vRibbonMinimieren
End Property

'16.09.2014 AL
Public Property Get RibbonMinimieren() As Boolean
5   RibbonMinimieren = mboolRibbonMinimieren
End Property

'08.10.2014 AL
Public Property Let CheckFields(ByVal vCheckFields As Boolean)
5   mboolCheckFields = vCheckFields
End Property

'08.10.2014 AL
Public Property Get CheckFields() As Boolean
5   CheckFields = mboolCheckFields
End Property

'14.11.2014 AL
Public Property Let PrintHidden(ByVal vPrintHidden As Boolean)
5   mboolPrintHidden = vPrintHidden
End Property

'14.11.2014 AL
Public Property Get PrintHidden() As Boolean
5   PrintHidden = mboolPrintHidden
End Property
'14.11.2014 AL
Public Property Let PrintHiddenArc(ByVal vPrintHiddenArc As Boolean)
5   mboolPrintHiddenARC = vPrintHiddenArc
End Property

'14.11.2014 AL
Public Property Get PrintHiddenArc() As Boolean
5   PrintHiddenArc = mboolPrintHiddenARC
End Property

'23.01.2015 AL
Public Property Let ParamPrintHidden(ByVal vParamPrintHidden As Boolean)
5   mboolParamPrintHidden = vParamPrintHidden
End Property

'23.01.2015 AL
Public Property Get ParamPrintHidden() As Boolean
5   ParamPrintHidden = mboolParamPrintHidden
End Property

'17.02.2015 AL
Public Property Let SpeichernAlsSBentfernen(ByVal vSpeichernAlsSBentfernen As Boolean)
5   mboolSpeichernAlsSBentfernen = vSpeichernAlsSBentfernen
End Property

'17.02.2015 AL
Public Property Get SpeichernAlsSBentfernen() As Boolean
5   SpeichernAlsSBentfernen = mboolSpeichernAlsSBentfernen
End Property

'04.06.2015 AL
Public Property Let SignMultiSelect(ByVal vSignMultiSelect As Boolean)
5   mboolSignMultiSelect = vSignMultiSelect
End Property
'04.06.2015 AL
Public Property Get SignMultiSelect() As Boolean
5   SignMultiSelect = mboolSignMultiSelect
End Property

'26.02.2018 AL
Public Property Let DeltaScroll(ByVal vDeltaScroll As Boolean)
5   mboolDeltaScroll = vDeltaScroll
End Property
'26.02.2018 AL
Public Property Get DeltaScroll() As Boolean
5   DeltaScroll = mboolDeltaScroll
End Property

Public Property Get fokusOnWord() As Integer
5   fokusOnWord = mintFokusOnWord
End Property

Public Property Let fokusOnWord(ByVal vFokusOnWord As Integer)
5   mintFokusOnWord = vFokusOnWord
End Property

Public Property Get WeStillInProcessing() As Boolean
5   WeStillInProcessing = mboolIsWeProcessingRunning
End Property

Public Property Let WeStillInProcessing(ByVal vWeIsRunning As Boolean)
5   mboolIsWeProcessingRunning = vWeIsRunning
End Property

Public Property Get InDeleteFile() As Boolean
5   InDeleteFile = mboolFileToBeDeletedAfterClose
End Property

Public Property Let InDeleteFile(ByVal vInDeleteFile As Boolean)
5   mboolFileToBeDeletedAfterClose = vInDeleteFile
End Property

Public Property Get MergeEmptyLines() As Boolean
5   MergeEmptyLines = mboolMergeEmptyLines
End Property

Public Property Let MergeEmptyLines(ByVal vMergeEmptyLines As Boolean)
5   mboolMergeEmptyLines = vMergeEmptyLines
End Property

Public Property Get tcResult() As TC_SessionResult
5   tcResult = menumTcSessionResult
End Property

Public Property Let tcResult(ByVal vTcResult As TC_SessionResult)
5   menumTcSessionResult = vTcResult
End Property

Public Property Get withDebugMsg() As Boolean
5   withDebugMsg = mboolShowDebugMsgBoxes
End Property

Public Property Let withDebugMsg(ByVal vwithDebug As Boolean)
5   mboolShowDebugMsgBoxes = vwithDebug
End Property

Public Property Get withProtokoll() As Boolean
5   withProtokoll = mboolWithProtocol
End Property

Public Property Set workingDocument(vWorkDoc As Document)
5   Set mobjWorkingDoc = vWorkDoc
End Property

Public Property Get workingDocument() As Document
5   Set workingDocument = mobjWorkingDoc
End Property

Public Property Let WeFullFileName(ByVal vWeFile As String)
5   mstrWeFileCurrentName = vWeFile
End Property

Public Property Get WeFullFileName() As String
5   WeFullFileName = mstrWeFileCurrentName
End Property

Public Property Let DoFullFileName(ByVal vDoFile As String)
5   mstrDoFileCurrentName = vDoFile
End Property

Public Property Get DoFullFileName() As String
5   DoFullFileName = mstrDoFileCurrentName
End Property

Public Property Get SessionAssociatedCommandBarOrRibon() As TC_Commandbar
5   Set SessionAssociatedCommandBarOrRibon = mobjTcCommandBar
End Property

Public Property Set SessionAssociatedCommandBarOrRibon(objCommandBar As TC_Commandbar)
5   Set mobjTcCommandBar = objCommandBar
End Property

Public Property Let ServerName(ByVal vServer As String)
5   mstrServerName = vServer
End Property

Public Property Get ServerName() As String
5   ServerName = mstrServerName
End Property

Public Property Let PortNumber(ByVal vPort As Long)
5   mintPortNumber = vPort
End Property

Public Property Get PortNumber() As Long
5   PortNumber = mintPortNumber
End Property

Public Property Let ActiveApplication(ByVal vActiveApplication As String)
5   mstrApplicationToActivate = vActiveApplication
End Property

Public Property Get ActiveApplication() As String
5   ActiveApplication = mstrApplicationToActivate
End Property

Public Property Get SaveNotTriggeredByWordButtons() As Boolean
5   SaveNotTriggeredByWordButtons = mboolSaveNotTriggeredByWordButtons
End Property

Public Property Let SaveNotTriggeredByWordButtons(ByVal boolTc_triggered As Boolean)
5   mboolSaveNotTriggeredByWordButtons = boolTc_triggered
End Property

Public Property Let SignTempDirectory(ByVal vSignTempDirectory As String)
5   mstrSignTempDir = vSignTempDirectory
End Property

Public Property Get SignTempDirectory() As String
5   SignTempDirectory = mstrSignTempDir
End Property

Public Property Let SignDefaultFile(ByVal vSignDefaultFile As String)
5   mstrSignDefaultFile = vSignDefaultFile
End Property

Public Property Get SignDefaultFile() As String
5   SignDefaultFile = mstrSignDefaultFile
End Property

Public Property Let SignScaleFactor(ByVal vSignScaleFactor As Integer)
5   mintSignScaleFactor = vSignScaleFactor
End Property

Public Property Get SignScaleFactor() As Integer
5   SignScaleFactor = mintSignScaleFactor
End Property

Public Property Let SignSynchScreen(ByVal vSignSynchScreen As suSyncScreen)
5   menumSignSynchScreen = vSignSynchScreen
End Property

Public Property Get SignSynchScreen() As suSyncScreen
5   SignSynchScreen = menumSignSynchScreen
End Property

Public Property Let SignWithCommandbar(ByVal vSignWithCommandbar As Boolean)
5   mboolSignWithCommandbar = vSignWithCommandbar
End Property

Public Property Get SignWithCommandbar() As Boolean
5   SignWithCommandbar = mboolSignWithCommandbar
End Property

Public Property Get IniFile() As String
5   IniFile = mstrTcSignIniFullFileName
End Property

Public Property Let IniFile(ByVal strIniFile As String)
5   mstrTcSignIniFullFileName = strIniFile
End Property

Public Sub IncIndent()
5   mintProtocolLineIndent = mintProtocolLineIndent + mintLINE_INDENT_WIDTH
End Sub

Public Sub DecIndent()
5   mintProtocolLineIndent = mintProtocolLineIndent - mintLINE_INDENT_WIDTH
10  If mintProtocolLineIndent < 0 Then mintProtocolLineIndent = 0
End Sub

Public Property Let OldWayPrint(ByVal vOldWayPrint As Boolean)
5   mboolOldWayPrint = vOldWayPrint
End Property

Public Property Get OldWayPrint() As Boolean
5   OldWayPrint = mboolOldWayPrint
End Property

Public Property Get CommandOEFFNEAppliedInWe() As Boolean
5   CommandOEFFNEAppliedInWe = mboolCommandOEFFNEAppliedInWe
End Property

Public Property Let CommandOEFFNEAppliedInWe(ByVal boolCommandOEFFNEAppliedInWe As Boolean)
5   mboolCommandOEFFNEAppliedInWe = boolCommandOEFFNEAppliedInWe
End Property

Public Property Get DocumentAlreadySentToeAkte() As Boolean
5   DocumentAlreadySentToeAkte = mboolDocumentAlreadySentToeAkte
End Property

Public Property Let DocumentAlreadySentToeAkte(ByVal boolDocumentAlreadySentToeAkte As Boolean)
5   mboolDocumentAlreadySentToeAkte = boolDocumentAlreadySentToeAkte
End Property


'############# Prozeduren #############

Public Function ApplicationPIDExist() As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
10  boolReturn = False

    ' zun|fffd|chst |fffd|berpr|fffd|fen, ob |fffd|ber Callback-Handler eine PID gesetzt wurde
15  boolReturn = Not (mlongCallbackCallerApplicationPID = mlongAPPLICATION_PID_NOT_APPLIED)

20  If Not boolReturn Then
        ' PID |fffd|ber Callback nicht gesetzt
        ' mit der von XXDRUC |fffd|bergebene PID belegen
25      Me.ApplicationPID = Me.ParentSessionsContainer.ParentIkolClientApp.ClientPid
        ' erneut |fffd|berpr|fffd|fen, ob gerade eine PID gesetzt wurde
30      boolReturn = Not (mlongCallbackCallerApplicationPID = mlongAPPLICATION_PID_NOT_APPLIED)
35  End If

ExitProc:
40  ApplicationPIDExist = boolReturn
45  Exit Function

RaiseErrorHandler:
50  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::ApplicationPIDExist" & " in Zeile:" & Erl & vbCrLf, Err.Description
55  Resume ExitProc
End Function

Public Sub AddRibbonOrCommandbarToSession(strCommandBarName As String)
    ' die Session bekommt eine Symbolleiste mit der |fffd|bergebenen Definition

5   On Error GoTo RaiseErrorHandler
    Dim objCommandBarToAdd As TC_Commandbar
10  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start TC_Session::AddRibbonOrCommandbarToSession() mit der Kennzeichnung '" & strCommandBarName & "' aus der WE-Datei", Me)
15  Set objCommandBarToAdd = New TC_Commandbar
20  Set objCommandBarToAdd.ParentSession = Me

25  If strCommandBarName <> vbNullString Then
30      Call objCommandBarToAdd.SetCommandBarWithDefaultSyntaxActionDefinitions(strCommandBarName, Me)
35  End If

40  Set Me.SessionAssociatedCommandBarOrRibon = objCommandBarToAdd
45  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende TC_Session::AddRibbonOrCommandbarToSession()", Me)

ExitProc:
50  Set objCommandBarToAdd = Nothing
55  Exit Sub

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::AddRibbonOrCommandbarToSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc

End Sub


Public Sub AddParmValue(parmStr As String, valuestr As String)

5   On Error GoTo RaiseErrorHandler

    Dim tcParm As TC_Parameter
    Dim tmpParm As String

10  tmpParm = UCase(parmStr)

15  For Each tcParm In mcolControlParameter
20      If tcParm.ParameterName = tmpParm Then
25          tcParm.ParameterValue = valuestr
30          GoTo ExitProc
35      End If
40  Next

45  Set tcParm = New TC_Parameter
50  tcParm.ParameterName = tmpParm
55  tcParm.ParameterValue = valuestr
60  mcolControlParameter.Add tcParm

ExitProc:
65  Set tcParm = Nothing
70  Exit Sub

RaiseErrorHandler:
75  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::AddParmValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Sub


Public Function GetParameterValue(parmName As String) As String
5   On Error GoTo RaiseErrorHandler

    Dim tcParm As TC_Parameter
    Dim strResult As String

10  For Each tcParm In mcolControlParameter
15      If tcParm.ParameterName = parmName Then
20          strResult = tcParm.ParameterValue
25          Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("GetParameterValue f|fffd|r Parameter " & parmName & _
                                                                                         " mit Wert " & tcParm.ParameterValue, Me)
30          GoTo ExitProc
35      End If
40  Next tcParm

45  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("GetParameterValue hat Parameter " & parmName & " nicht gefunden", Me)

ExitProc:
50  Set tcParm = Nothing
55  GetParameterValue = strResult
60  Exit Function

RaiseErrorHandler:
65  strResult = vbNullString
70  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::GetParameterValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Function

Public Sub WorkingDocumentNameChanged(strOldFileName As String)
5   On Error GoTo RaiseErrorHandler

    Dim objTcDoc As TC_Document

10  If Me.workingDocument.FullName <> strOldFileName Then
15      Set objTcDoc = Me.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(strOldFileName)

20      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("SaveActiveDocumentAs: neuer Dateiname ist " & Me.workingDocument.FullName, Me)
25      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("                      alter Dateiname ist " & strOldFileName, Me)

30      objTcDoc.DocumentName = Me.workingDocument.name
35      objTcDoc.FullName = Me.workingDocument.FullName
40      objTcDoc.IsMailMergeDoc = Me.workingDocument.MailMerge.MainDocumentType <> wdNotAMergeDocument
45  Else
50      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("SaveActiveDocumentAs: workingDocument hat keinen neuen Namen", Me)
55  End If

ExitProc:
60  Set objTcDoc = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::WorkingDocumentNameChanged" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub

'---------------------------------------------------------------------------------------
' Prozedur : RenameWeFile
' Autor    : Todor Vachkov
' Datum    : 28.06.2013
' Zweck    : die |fffd|bergebene WE-Datei wird entsprechend der SID der aktuellen Session umbenannt
'          : => aus WE_pid718517_.txt wird z.B. WE_pid718517_00001.txt
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
' Boolean       : keine
'
' |fffd|bergabeparams:
' String        : die gefundene WE-Datei mit PID , die als Basis f|fffd|r den neuen Namen benutzt wird, z.B. WE_pid718517_.txt
'---------------------------------------------------------------------------------------
Public Sub RenameWeFile(ByVal strWeFileName As String)
5   On Error GoTo RaiseErrorHandler

    Dim strNewFileName As String
    Dim strOldFileName As String
    Dim intPointPosition As Integer                   '' die Position des Punktes im alten Dateinamen (mit dem Unterstrich am Ende)

    ' z.B. WE_pid718517_.txt
10  strOldFileName = strWeFileName

    ' daraus wird z.B. WE_pid718517_00001.txt
15  strNewFileName = Me.ParentSessionsContainer.ParentIkolClientApp.FileHandler.BuildNewFileNameWithID(strOldFileName, Me.SessionID, True)

20  intPointPosition = InStrRev(strOldFileName, ".", Len(strOldFileName), vbTextCompare)

25  If intPointPosition > 0 Then
        ' der Unterstrich am Ende des alten Namens wird entfernt, z.B. WE_pid718517.txt
30      strOldFileName = Left(strOldFileName, intPointPosition - 2) & Mid(strOldFileName, intPointPosition)
35  End If

    ' existiert die WE-Datei (so wie sie von XXDRUC erzeugt wurde)
40  If Not Me.ParentSessionsContainer.ParentIkolClientApp.FileHandler.FileExist(strOldFileName) Then
45      Err.Raise glongCUSTOM_ERR_EXPECTED_WE_FILE_NOT_FOUND, "TC_Session::RenameWeFile", "Kann die umzubenennede Datei '" & strOldFileName & "' nicht finden"
50  Else
        ' die bestehende WE-Datei umbenennen
        ' => aus WE_pid718517.txt wird WE_pid718517_00001.txt
        ' pr|fffd|fen, ob sie nicht bereits existiert, da sonst ein Fehler geworfen wird

55      If Not Me.ParentSessionsContainer.ParentIkolClientApp.FileHandler.FileExist(strNewFileName) Then
60          Name strOldFileName As strNewFileName
65          Me.ParentSessionsContainer.ParentIkolClientApp.OriginalWeFileMoved = True
70          Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Die WE-Datei '" & strOldFileName & "' wurde in '" & _
                                                                                           strNewFileName & "' umbenannt", Me)

            ' die umbenannte Datei zu der WE-Datei der Session machen
75          Me.WeFullFileName = strNewFileName
80      Else
85          Err.Raise glongCUSTOM_ERR_WE_PID_ALREADY_FOUND, "TC_Session::RenameWeFile", "Es existiert bereits eine WE-Datei mit dem Namen '" & _
                                                                                        strNewFileName & "'. Die Umbenennung kann nicht durchgef|fffd|hrt werden."
90      End If
95  End If

ExitProc:
100 Exit Sub

RaiseErrorHandler:
105 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::RenameWeFile in Zeile:" & Erl & vbCrLf, Err.Description & "->" & _
                                                                                                   ": Versuch, die WE-Datei '" & strWeFileName & "' mit der SID '" & Me.SessionID & "' zu versehen."
110 Resume ExitProc

End Sub

Public Function RemoveFromSessionAndDeleteDatasourcefile(objTcDocumentToClose As TC_Document) As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Dim tcResult As TC_SessionResult
    Const valueIndent As Integer = 23

10  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_Session::RemoveFromSessionAndDeleteDatasourcefile - Start", Me)

15  With objTcDocumentToClose
20      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "TC_Session::RemoveFromSessionAndDeleteDatasourcefile - TC-Dokumenten-Eigenschaften " & _
             ".DocumentName          = " & .DocumentName & vbLf & _
             Space(valueIndent) & ".FullName              = " & .FullName & vbLf & _
             Space(valueIndent) & ".NumberInSession       = " & .NumberInSession & vbLf & _
             Space(valueIndent) & ".OpenReadOnly          = " & .openReadOnly & vbLf & _
             Space(valueIndent) & ".OpenVisible           = " & .openVisible & vbLf & _
             Space(valueIndent) & ".OpenWithRevert        = " & .openWithRevert & vbLf & _
             Space(valueIndent) & ".DoNotCloseDocument    = " & .DoNotCloseDocument & vbLf & _
             Space(valueIndent) & ".IsMailMergeDoc        = " & .IsMailMergeDoc & vbLf & _
             Space(valueIndent) & ".OpenWithHeaderReplace = " & .OpenWithHeaderReplace & vbLf & _
             Space(valueIndent) & ".DataFile              = " & .DataFile, _
             Me)

        '25      If .DoNotCloseDocument Then
        '30          Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_Session::RemoveFromSessionAndDeleteDatasourcefile - Das TC-Dokument '" & _
         objTcDocumentToClose.FullName & "' wurde nicht geschlossen, da es offen bleiben soll", Me)
        '35      Else

25      .Document.MailMerge.MainDocumentType = wdNotAMergeDocument
30      .Document.Saved = True

        ' die DO-Datei schliessen, soweit vorhanden, also nur bei Serienbrief-Hauptdokumenten
35      If .DataFile <> vbNullString Then
40          Call Me.ParentSessionsContainer.ParentIkolClientApp.FileHandler.DeleteFile(objTcDocumentToClose.DataFile, Me)
45      End If

50      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_Session:RemoveFromSessionAndDeleteDatasourcefile: Schliessen zweites Fenster und Dialog", Me)
55      If objTcDocumentToClose.IsInSignUpMode() Then
60          Call Me.ParentSessionsContainer.ParentIkolClientApp.SignUpHandler.CloseSignupHandling
65      End If
70      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_Session:RemoveFromSessionAndDeleteDatasourcefile: L|fffd|schen der Unterschriftendateien", Me)
75      Call objTcDocumentToClose.ManagedTCSignaturesContainer.DeleteTempSignFiles(Me)
80      If Not (ActiveDocument Is Nothing) Then
            ' wenn das TC-Dokument zugelich das aktive Dokument ist
85          If ActiveDocument.FullName = .FullName Then
90              Me.fokusOnWord = Me.fokusOnWord And Not gintDOKUMENT_AKTIV
95          End If
100     End If
        ' 120     End If
105 End With

    ' das TC-Dokument aus der Verwaltung entfernen; Ergebnis gem. der Anzahl der danach in der Verwaltung verblienen Dokumente
110 tcResult = Me.ManagedTCDocumentsContainer.RemoveDocumentFromSession(objTcDocumentToClose)

115 Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_Session::RemoveFromSessionAndDeleteDatasourcefile - Ende - tcResult=" & _
         Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.RCDescription(tcResult), Me)

ExitProc:
120 RemoveFromSessionAndDeleteDatasourcefile = tcResult
125 Exit Function

RaiseErrorHandler:
130 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::RemoveFromSessionAndDeleteDatasourcefile" & " in Zeile:" & Erl & vbCrLf, Err.Description
135 Resume ExitProc
End Function

Private Function Convert(versionStr As String, versionType As Version, msg As String) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim tcResult As TC_SessionResult
    Dim versArr() As String

10  tcResult = tcrOK

15  If versionStr = vbNullString Then
20      tcResult = tcrWrongVersionFormat
25      msg = "Die |fffd|bergebene Versionsnummer ist leer. " & vbLf & _
              "Das Format der Versionsnummer ist: Format Major.Minor.Build"
30      GoTo ExitProc
35  End If

40  versArr = Split(versionStr, ".", , vbTextCompare)
45  If UBound(versArr) - LBound(versArr) <> 2 Then
50      tcResult = tcrWrongVersionFormat
55      msg = "Version " & versionStr & " hat eine falsche Anzahl von Bestandteilen. Format Major.Minor.Build"
60      GoTo ExitProc
65  Else
70      With versionType
75          .major = CInt(versArr(LBound(versArr)))
80          .minor = CInt(versArr(LBound(versArr) + 1))
85          .build = CInt(versArr(LBound(versArr) + 2))
90      End With
95  End If

ExitProc:
100 Convert = tcResult
105 Exit Function

RaiseErrorHandler:
110 tcResult = tcrWrongVersionFormat
115 msg = "Version " & versionStr & " hat falsches Format. Bestandteile m|fffd|ssen Zahlen sein."
120 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::Convert" & " in Zeile:" & Erl & vbCrLf, Err.Description
125 Resume ExitProc

End Function

Private Function VersComp(sollVers As Integer, weVers As Integer, testTyp As TC_VersionPart, msg As String) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim versionPart As String
    Dim tcResult As TC_SessionResult

10  Select Case testTyp
        Case tMajor
15          versionPart = "der Hauptnummer"
20      Case tMinor
25          versionPart = "der Unternummer"
30      Case tBuild
35          versionPart = "der Build-Nummer"
40      Case Else
45          versionPart = "unbekannter Teil der Version"
50  End Select

55  If sollVers < weVers Then
60      tcResult = tcrWrongVersion
65      msg = "Die Schnittstelle erwartet eine kleinere Version in " & versionPart
70  ElseIf sollVers > weVers Then
75      tcResult = tcrWrongVersion
80      msg = "Die Schnittstelle erwartet eine gr|fffd||fffd|ere Version in " & versionPart
85  Else
90      tcResult = tcrOK
95  End If

ExitProc:
100 VersComp = tcResult
105 Exit Function

RaiseErrorHandler:
110 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::VersComp" & " in Zeile:" & Erl & vbCrLf, Err.Description
115 Resume ExitProc

End Function

Public Function VersionTest(objSession As TC_Session, strWeVersionNumber As String) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim sVersion As Version
    Dim weVersion As Version
    Dim strMsg As String
    Dim tcResult As TC_SessionResult

    Dim strVersionDotFile As String

10  strMsg = vbNullString
15  strVersionDotFile = objSession.ParentSessionsContainer.ParentIkolClientApp.Os2Version


20  tcResult = Convert(strVersionDotFile, sVersion, strMsg)
25  If tcResult = tcrOK Then tcResult = Convert(strWeVersionNumber, weVersion, strMsg)

30  If tcResult = tcrOK Then
35      tcResult = VersComp(sVersion.major, weVersion.major, tMajor, strMsg)
40      If tcResult = tcrOK Then
45          tcResult = VersComp(sVersion.minor, weVersion.minor, tMinor, strMsg)
50          If tcResult = tcrOK Then
55              tcResult = VersComp(sVersion.build, weVersion.build, tBuild, strMsg)
60          End If
65      End If
70  End If

75  If tcResult <> tcrOK Then
80      Err.Raise glongCUSTOM_ERR_INSUFFICIENT_VERSION, "TC_Session::VersionTest", "Schnittstellenversion der TC_OITEMPLATE.DOT-Datei[" & _
                                                                                   strVersionDotFile & "] <--> Schnittstellenversion XXDRUC [" & strWeVersionNumber & "]"
85  End If

ExitProc:
90  VersionTest = tcResult
95  Exit Function

RaiseErrorHandler:
100 tcResult = tcrEnd
105 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::VersionTest" & " in Zeile:" & Erl & vbCrLf, Err.Description
110 Resume ExitProc
End Function

Private Function SkipDelimiter(strLineBuffer As String, ByRef intIndex As Integer) As Integer
5   On Error GoTo RaiseErrorHandler

    Dim strChar As String
    Dim boolCommaDelim As Boolean

10  boolCommaDelim = False

15  Do
20      If intIndex > Len(strLineBuffer) Then
25          Exit Do
30      End If

35      strChar = Mid(strLineBuffer, intIndex, 1)

40      If InStr(mstrWE_DELIMITER, strChar) = 0 Then
45          Exit Do
50      End If

55      If strChar = "," Then
60          If boolCommaDelim Then
65              Exit Do
70          End If
75          boolCommaDelim = True
80      End If

85      intIndex = intIndex + 1
90  Loop

ExitProc:
95  SkipDelimiter = intIndex
100 Exit Function

RaiseErrorHandler:
105 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::SkipDelimiter" & " in Zeile:" & Erl & vbCrLf, Err.Description
110 Resume ExitProc

End Function

Private Function GetNextToken(strLineBuffer As String, ByRef intIndex As Integer) As String
5   On Error GoTo RaiseErrorHandler

    ' Vorraussetzung: vorhergehende Delimiter sind |fffd|bergangen und intIndex steht am Beginn des n|fffd|chsten zu
    ' erwartenden Tokens.

    Dim strResult As String
    Dim strChar As String
    Dim strNextChar As String
    Dim boolInDoubleQuotes As Boolean

10  strResult = vbNullString

15  boolInDoubleQuotes = Mid(strLineBuffer, intIndex, 1) = Chr(34)

20  If boolInDoubleQuotes Then
25      intIndex = intIndex + 1
30  Else                                              'Skip Blanks
35      Do
40          If Mid(strLineBuffer, intIndex, 1) <> " " Then
45              Exit Do
50          End If
55          If intIndex > Len(strLineBuffer) Then
60              Exit Do
65          End If
70          intIndex = intIndex + 1
75      Loop
80  End If

85  Do
90      If intIndex > Len(strLineBuffer) Then
95          Exit Do
100     End If
105     strChar = Mid(strLineBuffer, intIndex, 1)
110     If intIndex < Len(strLineBuffer) Then
115         strNextChar = Mid(strLineBuffer, intIndex + 1, 1)
120     Else
125         strNextChar = vbNullString
130     End If

135     If Not boolInDoubleQuotes Then
140         If InStr(mstrWE_DELIMITER, strChar) > 0 Then
145             Exit Do
150         Else
155             strResult = strResult & strChar
160             intIndex = intIndex + 1
165         End If
170     Else                                          'boolInDoubleQuotes
175         If strChar = Chr(34) Then
180             If strNextChar = Chr(34) Then
185                 strResult = strResult & strChar
190                 intIndex = intIndex + 2           '|fffd|berspringen des doppelten Hochkommas
195             Else
200                 intIndex = intIndex + 1           'Ende der Zeichenkette in Hochkommas erreicht
205                 Exit Do
210             End If
215         Else
220             strResult = strResult & strChar
225             intIndex = intIndex + 1
230         End If
235     End If
240 Loop

245 strResult = RTrim(strResult)
250 strResult = LTrim(strResult)

255 If boolInDoubleQuotes Then
260     strResult = Chr(34) & strResult & Chr(34)
265 End If

ExitProc:
270 GetNextToken = strResult
275 Exit Function

RaiseErrorHandler:
280 strResult = vbNullString
285 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::GetNextToken" & " in Zeile:" & Erl & vbCrLf, Err.Description
290 Resume ExitProc

End Function

'---------------------------------------------------------------------------------------
' Prozedur : SplitWeLine
' Autor    : Todor Vachkov
' Datum    : 27.06.2013
' Zweck    : macht aus einer WE-Testzeile einen Array, der den Namen des auszuf|fffd|hrenden Makros beinhaltet
'          : und die dem Makro zu |fffd|bergebenden Parameter
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
' Array         : einen Array, der den Namen des auszuf|fffd|hrenden Makros beinhaltet
'                 und die dem Makro zu |fffd|bergebenden Parameter
'
'
' |fffd|bergabeparams:
' String        : eine Textzeile aus der WE-Datei
'---------------------------------------------------------------------------------------
Private Function SplitWeLine(strLineBuffer As String) As welnWeLine
    Dim welnSplittedLine As welnWeLine
    Dim intPart As Integer
    Dim strPart As String
    Dim intIndex As Integer

5   On Error GoTo RaiseErrorHandler

10  intPart = 0
15  intIndex = 1
20  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Analysiere Zeile: " & Chr(34) & strLineBuffer & Chr(34), Me)
25  Do
30      intIndex = SkipDelimiter(strLineBuffer, intIndex)

        ' das Ende der Zeile wurde erreicht, Schleife verlassen
35      If intIndex > Len(strLineBuffer) Then
40          Exit Do
45      End If

50      strPart = GetNextToken(strLineBuffer, intIndex)
55      ReDim Preserve welnSplittedLine.part(intPart)
60      welnSplittedLine.part(intPart) = strPart
65      intPart = intPart + 1
70  Loop


ExitProc:
75  SplitWeLine = welnSplittedLine
80  Exit Function

RaiseErrorHandler:

85  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::SplitWeLine in Zeile:" & Erl & vbCrLf, Err.Description
90  Resume ExitProc

End Function

'---------------------------------------------------------------------------------------
' Prozedur : SaveWeLine
' Autor    : Todor Vachkov
' Datum    : 27.06.2013
' Zweck    :
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: ... (wird |fffd|berarbeitet)
'
' |fffd|bergabeparams:
' Array         : Array von Tokens, die dem Inhalt der |fffd|bergebenen WE-Zeile entsprechen
'---------------------------------------------------------------------------------------
Private Function SaveWeLine(welnMyWeLine As welnWeLine) As TC_SessionResult
    Dim objCommandDescription As TC_WEInstruction
    Dim objMakroCommand As TC_WEInstructionMacro

    Dim tcrResult As TC_SessionResult
    Dim intIndex As Integer

5   On Error GoTo RaiseErrorHandler

    ' hier erstmal ein paar Pr|fffd|fungen

    ' merken, dass OEFFNE gefunden wurde; die Befehlsfolge w|fffd|rde ohne OEFFNE gar keinen Sinn machen, deswegen zur sp|fffd|teren Pr|fffd|fung hier merken
10  If welnMyWeLine.part(LBound(welnMyWeLine.part)) = "OEFFNE" And _
       Not Me.CommandOEFFNEAppliedInWe Then
15      Me.CommandOEFFNEAppliedInWe = True
20  End If

    ' SYMBOLLEISTE_RIBBON ignorieren
25  If welnMyWeLine.part(LBound(welnMyWeLine.part)) = "SYMBOLLEISTE_RIBBON" Then
30      tcrResult = tcrOK
35      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_Session:SaveWeLine:: Befehl SYMBOLLEISTE_RIBBON gefunden ==> ignorieren!", Me)
40      GoTo ExitProc
45  End If

50  Set objCommandDescription = New TC_WEInstruction
55  Set objCommandDescription = Me.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription.FindSyntaxDescription _
                                (welnMyWeLine.part(LBound(welnMyWeLine.part)))

60  If objCommandDescription Is Nothing Then
65      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll _
             ("    Befehlsname unbekannt: " & Chr(34) & welnMyWeLine.part(LBound(welnMyWeLine.part)) & Chr(34), Me)

70      tcrResult = tcrWrongCommand

75      Err.Raise glongCUSTOM_ERR_UNKNOWN_WECOMMAND, "TC_Session::SaveWeLine", "Der Befehl '" & _
                                                                               welnMyWeLine.part(LBound(welnMyWeLine.part)) & "' in der WE-Datei ist unbekannt"
80  Else
        ' sollte es sich um einen Befehl handeln, der schon mal in der WE-Befehlsfolge gefunden wurde,
        ' so hat dieses Objekt bereits die Zuweisung zu der Session
85      If objCommandDescription.ParentSession Is Nothing Then
90          Set objCommandDescription.ParentSession = Me
95      End If

        ' die syntaktische Korrektheit der Befehlsparameter |fffd|berpr|fffd|fen
100     tcrResult = objCommandDescription.AnalyzeCommand(welnMyWeLine.part, Me)

105     If tcrResult = tcrOK Then
110         Set objMakroCommand = New TC_WEInstructionMacro

115         With objMakroCommand
120             .makroName = objCommandDescription.makroName
125             For intIndex = LBound(welnMyWeLine.part) + 1 To UBound(welnMyWeLine.part)
130                 Call .AddParameterValue(objCommandDescription.GetParameter(intIndex), welnMyWeLine.part(intIndex), Me)
135             Next intIndex
140         End With

145         mobjWEInstructionMacrosContainer.AddWECommand objMakroCommand

150         Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("        Ergebnis: " & objMakroCommand.GetCommandString(), Me)
155     Else
160         Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("    Aufbau des Befehls" & vbLf & objCommandDescription.GetCommandoDescriptonAsText, Me)
165     End If
170 End If

ExitProc:
175 Set objCommandDescription = Nothing
180 Set objMakroCommand = Nothing
185 SaveWeLine = tcrResult
190 Exit Function

RaiseErrorHandler:
195 tcrResult = tcrEnd
200 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::SaveWeLine in Zeile:" & Erl & vbCrLf, Err.Description
205 Resume ExitProc
End Function

'---------------------------------------------------------------------------------------
' Prozedur : ReadWeFile
' Autor    : Todor Vachkov
' Datum    : 27.06.2013
' Zweck    : der Inhalt der zur Session geh|fffd|renden WE-Datei wird ins Protokoll kopiert;
'          : die zur Session geh|fffd|rende WE-Datei wird Zeile f|fffd|r Zeile ausgelesen und jede einzelne Zeile geparst;
'          : abschlie|fffd|end wird die WE-Datei gel|fffd|scht
'
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams: die zur Session geh|fffd|rende WE-Datei
'
'---------------------------------------------------------------------------------------
Public Function ReadWeFile(strParameterFile As String) As TC_SessionResult

    Dim FSO As New FileSystemObject
    Dim objReadWeTextStream As TextStream
    Dim strLineBuffer As String

    Dim tcrResult As TC_SessionResult
    Dim tcrResultReturnFromSaveWeLine As TC_SessionResult

    Dim welnCurrentWeLine As welnWeLine               '' ist ein Array!
10    On Error GoTo RaiseErrorHandler

20    tcResult = tcrOK

    ' der Inhalt der zur Session geh|fffd|renden WE-Datei wird ins Protokoll kopiert;
30    Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.CopyFileToProtokoll(strParameterFile, gstrTC_WE_MARKERSTRING, Me, False)
    ' DoEvents

    ' ein neuer TextStream wird zum Auslesen der WE-Datei aufgemacht
40    Set objReadWeTextStream = FSO.OpenTextFile(strParameterFile, ForReading)

    ' Zeile f|fffd|r Zeile aus der WE-Datei lesen
50    Do While Not objReadWeTextStream.AtEndOfStream
60      strLineBuffer = objReadWeTextStream.ReadLine
70      If strLineBuffer <> vbNullString Then

            ' nur auf nicht leeren Zeilen arbeiten
80          welnCurrentWeLine = SplitWeLine(strLineBuffer)

90          tcrResultReturnFromSaveWeLine = SaveWeLine(welnCurrentWeLine)

100         If tcrResultReturnFromSaveWeLine > tcResult Then
110             tcResult = tcrResultReturnFromSaveWeLine
120         End If

130     End If
140   Loop

150   objReadWeTextStream.Close
'22.07.2014 AL
160   Set objReadWeTextStream = Nothing
170   Set FSO = Nothing
'ENDE 22.07.2014 AL

    ' WE-Datei l|fffd|schen
180   Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine
190   Call Me.ParentSessionsContainer.ParentIkolClientApp.FileHandler.DeleteFile(strParameterFile, Me)
    ' Schalter setzen, dass die WE um



200   Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("WE-Datei gel|fffd|scht", Me)
210   Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine

ExitProc:
220   Set FSO = Nothing
230   ReadWeFile = tcResult
240   Exit Function

RaiseErrorHandler:
250   tcResult = tcrEnd
260   Err.Raise Err.Number, Err.Source & "->" & "TC_Session::ReadWeFile in Zeile:" & Erl & vbCrLf, Err.Description
270   Resume ExitProc
End Function

'---------------------------------------------------------------------------------------
' Prozedur : ProcessWeFile
' Autor    : Todor Vachkov
' Datum    : 27.06.2013
' Zweck    : es wird die Prozedur ReadWeFile aufgerufen, in der die WE-Datei geparst
'          : und auch die Collection mit den auzuf|fffd|hrenden Kommandos gef|fffd|llt wird
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: TC_SessionResult
'
' |fffd|bergabeparams:
'
'---------------------------------------------------------------------------------------
Public Function ProcessWeFile() As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

    Dim tcResult As TC_SessionResult
    Dim boolResult As Boolean
10  boolResult = False

15  Application.ScreenUpdating = False

    ' die WE-Datei wird geparst und nach Fehlern |fffd|berpr|fffd|ft
20  tcResult = Me.ReadWeFile(Me.WeFullFileName)

25  If Not Me.CommandOEFFNEAppliedInWe Then
30      Err.Raise glongCUSTOM_ERR_NO_OPEN_COMMAND_APPLIED, "TC_Session::ProcessWeFile", _
                  "Die Befehlsfolge zur Aktion enth|fffd|lt nicht den obligatorischen Befehl OEFFNE."
35  End If

40  Me.WeStillInProcessing = True

    ' hier im Container in RunMacroCommands() werden die zu den WE-Befehlen geh|fffd|renden Makros abgearbeitet
45  If tcResult = tcrOK Or tcResult = tcrParameterWarning Then
        ' die Analyse der WE-Datei ist erfolgreich abgeschlossen worden, fahre mit er Ausf|fffd|hrung fort
50      boolResult = mobjWEInstructionMacrosContainer.RunMacroCommands(Me)
55  Else
60      Err.Raise glongCUSTOM_ERR_WE_FILE_ERRONEOUS, "TC_Session::ProcessWeFile", "Die Befehlsfolge zur Aktion ist fehlerhaft"
65  End If

ExitProc:
70  ProcessWeFile = boolResult
75  Me.WeStillInProcessing = False
80  Application.ScreenUpdating = True
85  Application.ScreenRefresh
90  DoEvents
95  Exit Function

RaiseErrorHandler:
100 boolResult = False
105 Err.Raise Err.Number, Err.Source & "->" & "TC_Session::ProcessWeFile in Zeile:" & Erl & vbCrLf, Err.Description
110 Resume ExitProc
End Function

Public Function GetWorkingTcDocument() As TC_Document
5   If Me.workingDocument Is Nothing Then
10      Set GetWorkingTcDocument = Nothing
15  Else
20      Set GetWorkingTcDocument = Me.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(Me.workingDocument.FullName)
25  End If
End Function

Public Sub SetSessionEnvironment()
5   On Error GoTo RaiseErrorHandler


    Dim FSO As New FileSystemObject
    Dim strLogfileName As String
    Dim strDebugFileName As String

10  strDebugFileName = Me.ParentSessionsContainer.ParentIkolClientApp.WinworkPath & Application.PathSeparator & gstrTC_DEBUG_FILENAME

15  mboolWithProtocol = Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.IsLoggingActive()
20  mboolShowDebugMsgBoxes = FSO.FileExists(strDebugFileName)

    ' hier den Kopf f|fffd|r das Protokoll entstehen lassen
25  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine
30  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg(" ============================================================= ")
35  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg(" ===================== Start neue Session ==================== ")
40  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.ProtokollMsg(" ============================================================= ")
45  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine
50  Call Me.ParentSessionsContainer.ParentIkolClientApp.Tools.WriteSystemInformationToLogfile
55  Call Me.ParentSessionsContainer.ParentIkolClientApp.PrinterSetupHandler.InitAllPrintersNew

ExitProc:
60  Set FSO = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::SetSessionEnvironment in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub


Public Function CheckPermissionForPostMessage() As Boolean
    ' das Verfahren mit PostMessage freigeben wenn:
    ' 1) DO wurde umbenannt
    ' 2) WE wurde umbenannt
    ' 3) ARC-DIR ist nicht gesetzt
    ' 4) Befehl ARCPRINTER nicht eingetragen
    ' 5) auf der Symbolleiste gibt es keinen Button, der die eAkte ansprechen soll
    ' 1-5 sind Eigenschaften vom IkolClientApp-Objekt

5   On Error GoTo RaiseErrorHandler

    Dim boolEndResult As Boolean

10  boolEndResult = False

    'Me.ParentSessionsContainer.ParentIkolClientApp.OriginalDoFileMoved
    'Me.ParentSessionsContainer.ParentIkolClientApp.OriginalWeFileMoved
    'Me.ParentSessionsContainer.ParentIkolClientApp.AtLeastOneEakteButton

    ' momentan au|fffd|er Acht gelassen, w|fffd|rde durchaus Sinn machen auch das zu |fffd|berpr|fffd|fen
    ' um noch fr|fffd|her das Verfahren freigeben zu k|fffd|nnen
    'Me.ParentSessionsContainer.ParentIkolClientApp.IsArcDirSet
    'Me.ParentSessionsContainer.ParentIkolClientApp.IsArcPrinterSet

15  If Me.ParentSessionsContainer.ParentIkolClientApp.OriginalDoFileMoved And _
       Me.ParentSessionsContainer.ParentIkolClientApp.OriginalWeFileMoved And Not _
       Me.ParentSessionsContainer.ParentIkolClientApp.AtLeastOneEakteButton Then
20      boolEndResult = True
25  End If

ExitProc:
30  CheckPermissionForPostMessage = boolEndResult
35  Exit Function

RaiseErrorHandler:
40  boolEndResult = False
45  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::CheckPermissionForPostMessage" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc
End Function


Public Function CheckSymbolbarExistencePreventingSessionClosing() As TC_SessionResult
    '1) Wenn Symbolleiste aktiv ist, dann aktivieren des aktuellen Dokumentes oder des zuletzt ge|fffd|ffneten.

    '2) Ansonsten werden alle durch die Session ge|fffd|ffnneten Dokumente geschlossen.
    ' die Session selbst muss von ausserhalb geschlossen werden.

10    On Error GoTo RaiseErrorHandler

    Dim objTCDocument As TC_Document
    Dim tcResult As TC_SessionResult

20    Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start: TC_Session::CheckSymbolbarExistencePreventingSessionClosing", Me)

30    tcResult = tcrEnd

40    If Not Me.SessionAssociatedCommandBarOrRibon Is Nothing Then
50      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_Session::CheckSymbolbarExistencePreventingSessionClosing: Aktive Symbolleiste in der Session registriert", Me)

        ' Aktivieren des aktuellen Dokumentes oder des zuletzt ge|fffd|ffneten
60      tcResult = Me.ManagedTCDocumentsContainer.ActivateSessionDocument()
70    Else
        ' Symbolleiste/Ribbon ist nicht sichtbar
        ' alle durch die Session ge|fffd|ffnneten Dokumente, die noch nicht geschlossen sind, werden geschlossen
80      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "TC_Session::CheckSymbolbarExistencePreventingSessionClosing: Keine aktive Symbolleiste in der Session registriert", Me)

90      Call Me.PrintOutAllManagedDocumentsInSession

100     Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "TC_Session::CheckSymbolbarExistencePreventingSessionClosing: Starte Schliessen aller Session-Dokumente - Anzahl:" & _
             Me.ManagedTCDocumentsContainer.GetCountOfManagedTCDocumentsInContainer, Me)

        ' |fffd|ber die TC-Dokumente im Dokumenten-Container iterieren und versuchen diese zu schliessen
110     Do While Me.ManagedTCDocumentsContainer.GetCountOfManagedTCDocumentsInContainer > 0
120         Set objTCDocument = Me.ManagedTCDocumentsContainer.ManagedDocumentsCollection(1)

130         Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "TC_Session::CheckSymbolbarExistencePreventingSessionClosing: Vor FileHandler::CloseDocument schliesse das TC-Dokument: " & _
                 objTCDocument.DocumentName, Me)

140         tcResult = Me.ParentSessionsContainer.ParentIkolClientApp.FileHandler.CloseDocument(objTCDocument, Me)

150         Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "TC_Session::CheckSymbolbarExistencePreventingSessionClosing: nach FileHandler::CloseDocument f|fffd|r '" & _
                 objTCDocument.DocumentName & "'", Me)

160         If tcResult = tcrFileNotFound Then
170             Exit Do
180         End If
190     Loop

200     Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_Session::CheckSymbolbarExistencePreventingSessionClosing: Ende Schliessen aller Session-Dokumente", Me)

210   End If

220   Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende: TC_Session::CheckSymbolbarExistencePreventingSessionClosing - tcResult=" & _
                                                                                   Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.RCDescription(tcResult), Me)
ExitProc:
230   Set objTCDocument = Nothing
240   CheckSymbolbarExistencePreventingSessionClosing = tcResult
250   Exit Function

RaiseErrorHandler:
260   tcResult = tcrEnd
'04.08.2015 AL
'Beim Kunden M|fffd|hldorf (IKOL-But) tritt hier ein Fehler auf.
'Grund daf|fffd|r ist: obige Do-While-Schleife wird zweimal durchlaufen (weil MS-Word anscheinend mit seiner Dokumentenstruktur nicht nachkommt),
'somit wird dann .CloseDocument zweimal aufgerufen, was dann zum Fehler 5825 f|fffd|hrt.
'Dies wurde bisher nur beim But-Kunden M|fffd|hldorf festgestellt - hier tritt der Fehler auch nur spoadisch auf
280   If Err.Number = 5825 Then
290     Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Fehler: TC_Session::CheckSymbolbarExistencePreventingSessionClosing Fehler 5825 |fffd|bersprungen", Me)
300     Resume ExitProc
310   Else
'ENDE 04.08.2015 AL
320     Err.Raise Err.Number, Err.Source & "->" & "TC_Session::CheckSymbolbarExistencePreventingSessionClosing" & " in Zeile:" & Erl & vbCrLf, Err.Description
330   End If
340   Resume ExitProc
End Function


Public Sub PrintOutAllManagedDocumentsInSession()
    Dim tcDoc As TC_Document
5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_Session::PrintOutAllManagedDocumentsInSession: Die in der Session verwalteten TC-Dokumente werden ermittelt...", _
         Me)

15  If Me.ManagedTCDocumentsContainer.ManagedDocumentsCollection Is Nothing Then

20      Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
             "Der TC-Dokumenten-Container existiert nicht. Die in der Session verwalteten TC-Dokumente k|fffd|nnen nicht ermittelt werden", _
             Me)
25  Else

30      If Me.ManagedTCDocumentsContainer.GetCountOfManagedTCDocumentsInContainer > 0 Then
35          Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "Anzahl der TC-Dokumenten im Container: " & Me.ManagedTCDocumentsContainer.GetCountOfManagedTCDocumentsInContainer, Me)

40          For Each tcDoc In Me.ManagedTCDocumentsContainer.ManagedDocumentsCollection

45              Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC-Dokument: " & tcDoc.FullName, Me)
50          Next tcDoc
55      Else
60          Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 "Keine TC-Dokumente im Container gefunden", Me)
65      End If


70  End If
75  Call Me.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
         "TC_Session::PrintOutAllManagedDocumentsInSession: Die Anzahl der in der Session verwalteten TC-Dokumenten wurde ermittelt", Me)

ExitProc:
80  Set tcDoc = Nothing
85  Exit Sub

RaiseErrorHandler:
90  Err.Raise Err.Number, Err.Source & "->" & "TC_Session::PrintOutAllManagedDocumentsInSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc
End Sub


Public Sub CloseAllSessionDocuments()
    Dim objWordDocument As Document
    Dim objTCDocument As TC_Document

    ' s|fffd|mtliche Dokumente, die zur Session geh|fffd|ren schlie|fffd|en
5   For Each objWordDocument In Documents
10      Set objTCDocument = Me.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(objWordDocument.FullName)
15      If Not objTCDocument Is Nothing Then
20          objWordDocument.Close savechanges:=False
25      End If
30  Next objWordDocument

35  Set objWordDocument = Nothing
40  Set objTCDocument = Nothing
End Sub
Attribute VB_Name = "TC_SessionsContainer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' verf|fffd|gbare Eigenschaften:
' ~~~~~~~~~~~~~~~~~~~~~~~~~
'
' LastCallingApplication - Write/Read
'      enth|fffd|lt die Anwendung, die nach dem Beenden der letzten Session den Fokus erhalten muss
'
' wordStayOpen - Write/Read
'      enth|fffd|lt die Zusammenfassung aller Sessions, ob Word anschlie|fffd|end offen bleibt
'
' TCOS2_Version - Read Only
'      enth|fffd|lt die Versionsnummer der Schnittstelle und damit der aktuellen Session-Objekte
'
' DefaultPrinter - Write/Read
'      enth|fffd|lt den Standarddrucker beim Start s|fffd|mtlicher Sessions
'
'
'
'
' verf|fffd|gbare Klassen-Methoden:
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
' Add(session as TC_Session)
'      f|fffd|gt die angegebene Session zum Speicher der sessions hinzu
'      gleichzeitig erh|fffd|lt die Session eine interne ID, die im Programmablauf zur Identifizierung benutzt werden kann
'      sowie einen Verweis auf das TC_SessionsContainer-Objekt
'
' Remove(session as TC_Session)
'      entfernt die angegeben Session aus dem Speicher der sessions
'      das session-Objekt wird jedoch nicht gel|fffd|scht, daf|fffd|r ist das rufende Programm verantwortlich
'
' ? CheckAllSessionsDeleted() As TC_SessionResult
'
' ? ClearAllSessions()
'      Beendet alle Sessions im Speicher, setzt den Speicher auf Nothing und
'      setzt den Wert von wordStayOpen in Abh|fffd|ngigkeit von der aktuellen Situation
'      (kein weiteres Word-Dokument offen und keine WE-Datei hat wordStayOpen auf TRUE gesetzt)
'
' FindSessionToDocument(doc As Document) As TC_Session
'      gibt das Session-Objekt, welches zum angegebenen Dokument geh|fffd|rt, zur|fffd|ck.
'      gibt Nothing zur|fffd|ck, wenn das es ein Dokument ist, welches nicht durch die SYSTEM.DOT verwaltet wird
'
' GetActiveSession() As TC_Session
'      gibt das Session-Objekt, welches zum aktiven Dokument geh|fffd|rt, zur|fffd|ck.
'      Nothing, wenn das aktive Dokument ein Dokument ist, welches nicht durch die SYSTEM.DOT verwaltet wird
'
' ==================================================================================================================

Public Enum TC_SessionResult
    tcrOK
    tcrWarning
    tcrParameterWarning
    tcrEnd
    tcrNoEnd
    tcrNoCommand
    tcrWrongCommand
    tcrParameterErr
    tcrWrongVersionFormat
    tcrWrongVersion
    tcrOpenError
    tcrJoinError
    tcrMergeError
    tcrPrintError
    tcrFileNotFound
    tcrCallError
    tcrSaveError
    tcrFokusError
    tcreAkteError
End Enum

Private mintNextFreeSessionIDToAssign As Integer      '                        - Hidden
Private mstrTcOs2Version As String                    ' TCOS2_Version          - ReadOnly
Private mcolSessionsCollection As Collection          ' Collection mit Add und Remove _
                                                      ist der Speicher aller offenen Sessions (k|fffd|nnen mehrere werden, _
                                                      wenn die Synchronisation nur |fffd|ber den Zeitraum des Abarbeiten der WE-Datei erfolgt
Private mstrClientDir As String
Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Initialize()
5   Set mcolSessionsCollection = New Collection
End Sub

Private Sub Class_Terminate()
5   Call CleanUp
End Sub


Public Sub CleanUp()
5   If Not mcolSessionsCollection Is Nothing Then
10      Set mcolSessionsCollection = Nothing
15  End If

20  If Not mobjParentIkolClientApp Is Nothing Then
25      Set mobjParentIkolClientApp = Nothing
30  End If
End Sub


'---------------------------------------------------------------------------------------
' Prozedur : Add
' Autor    : Todor Vachkov
' Datum    : 28.06.2013
' Zweck    :
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams:
'
'---------------------------------------------------------------------------------------

Public Sub AddSession(session As TC_Session)
5   On Error GoTo RaiseErrorHandler
    ' siehe obige Beschreibung

10  Set session.ParentSessionsContainer = Me
15  session.SignTempDirectory = Me.ParentIkolClientApp.Tools.GetTemporaryFolder()

    ' die n|fffd|chste h|fffd|here freie ID im Sessions-Container bestimmen
20  mintNextFreeSessionIDToAssign = mintNextFreeSessionIDToAssign + 1

    ' die ID der Session zuweisen
25  session.SessionID = mintNextFreeSessionIDToAssign

    ' hinzuf|fffd|gen
30  mcolSessionsCollection.Add session

35  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_SessionsContainer::AddSession: Zum Sessions-Container wurde eine neue Session mit SID = [" & mintNextFreeSessionIDToAssign & "] hinzugef|fffd|gt")

ExitProc:
40  Exit Sub

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::AddSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc
End Sub

Public Sub RemoveSession(session As TC_Session)
    ' siehe obige Beschreibung
5   On Error GoTo RaiseErrorHandler

    Dim idx As Integer
    Dim tmpSession As TC_Session

10  idx = 1

15  For Each tmpSession In mcolSessionsCollection
20      If tmpSession.SessionID = session.SessionID Then
25          mcolSessionsCollection.Remove (idx)
30          Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_SessionsContainer::RemoveSession: Die Session mit der ID [" & session.SessionID & "] wurde aus dem Sessions-Container entfernt")
35          GoTo ExitProc
40      End If
45      idx = idx + 1
50  Next tmpSession

ExitProc:
55  Set tmpSession = Nothing
60  Exit Sub

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::RemoveSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Sub


Public Function GetCountOfSessionsInContainer() As Integer
5   On Error GoTo RaiseErrorHandler

    Dim intResult As Integer

10  If mcolSessionsCollection Is Nothing Then
15      intResult = 0
20  Else
25      intResult = mcolSessionsCollection.count
30  End If


ExitProc:
35  GetCountOfSessionsInContainer = intResult
40  Exit Function

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::GetCountOfSessionsInContainer" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc

End Function


Public Function CheckAllSessionsDeleted() As TC_SessionResult
    ' siehe obige Beschreibung
5   On Error GoTo RaiseErrorHandler
    Dim tcrResult As TC_SessionResult

10  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_SessionsContainer::CheckAllSessionsDeleted ergab Anzahl aktiver Sessions = " & mcolSessionsCollection.count)

15  If mcolSessionsCollection.count > 0 Then
20      tcrResult = tcrOK
25  Else
30      tcrResult = tcrEnd
35  End If

40  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_SessionsContainer::CheckAllSessionsDeleted ergab tcrResult = " & _
                                                            Me.ParentIkolClientApp.LogfileHandler.RCDescription(tcrResult))
ExitProc:
45  CheckAllSessionsDeleted = tcrResult
50  Exit Function

RaiseErrorHandler:
55  tcrResult = tcrEnd
60  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::CheckAllSessionsDeleted" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc
End Function


Public Sub ClearAllSessions()
    ' siehe obige Beschreibung

5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session

10  Do While mcolSessionsCollection.count > 0
15      Set session = mcolSessionsCollection(1)

20      If session.MaximizeWordAfterSessionClose Then
25          Me.ParentIkolClientApp.MaximizeWordAfterSessionClose = True
30      End If

35      mcolSessionsCollection.Remove (1)
40  Loop

45  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_SessionsContainer::ClearAllSessions: der Sessions-Container wurde geleert")

ExitProc:
50  Set session = Nothing
55  Exit Sub

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::ClearAllSessions" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc
End Sub

'---------------------------------------------------------------------------------------
' Prozedur : AtLeastOneSessionStillInProcessing
' Autor    : Todor Vachkov
' Datum    : 23.08.2013
' Zweck    : |fffd|berpr|fffd|ft, ob mindestens eine Session noch nicht beendet werden kann, weil sie noch abgearbeitet wird
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams: Boolean
'
' |fffd|bergabeparams: keine
'
'---------------------------------------------------------------------------------------
Public Function AtLeastOneSessionStillInProcessing() As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim objSession As TC_Session
    Dim boolOneWeRun As Boolean

10  boolOneWeRun = False

15  For Each objSession In mcolSessionsCollection
20      boolOneWeRun = boolOneWeRun Or objSession.WeStillInProcessing
25  Next objSession

ExitProc:
30  AtLeastOneSessionStillInProcessing = boolOneWeRun
35  Exit Function

RaiseErrorHandler:
40  boolOneWeRun = False
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::AtLeastOneSessionStillInProcessing" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc

End Function


Public Function GetSessionFromID(intSearchID As Integer) As TC_Session
5   On Error GoTo RaiseErrorHandler


    ' siehe obige Beschreibung
    Dim objSession As TC_Session
    Dim objResult As TC_Session

10  For Each objSession In mcolSessionsCollection
15      If intSearchID = objSession.SessionID Then
20          Set objResult = objSession
25          GoTo ExitProc
30      End If
35  Next objSession

ExitProc:
40  Set GetSessionFromID = objResult
45  Set objSession = Nothing
50  Exit Function

RaiseErrorHandler:
55  Set objResult = Nothing
60  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::GetSessionFromID" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc
End Function

Public Function FindSessionToDocument(Doc As Document) As TC_Session
5   On Error GoTo RaiseErrorHandler

    ' siehe obige Beschreibung
    Dim session As TC_Session
    Dim tmpDoc As TC_Document

    Dim objResult As TC_Session


10  For Each session In mcolSessionsCollection
15      Set tmpDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(Doc.FullName)
20      If Not (tmpDoc Is Nothing) Then
25          Set objResult = session
30          GoTo ExitProc
35      End If
40  Next session

ExitProc:
45  Set FindSessionToDocument = objResult
50  Set tmpDoc = Nothing
55  Exit Function

RaiseErrorHandler:
60  Set objResult = Nothing
65  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::FindSessionToDocument" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Function

Public Function GetActiveSession() As TC_Session
5   On Error GoTo RaiseErrorHandler

    ' siehe obige Beschreibung
    Dim objMyDoc As Document
    Dim objActiveSession As TC_Session


10  Set objActiveSession = Nothing
15  If mcolSessionsCollection.count > 0 Then
20      Set objActiveSession = mcolSessionsCollection.Item(1)
25  End If

30  If objActiveSession Is Nothing Then
35      Set objActiveSession.workingDocument = objMyDoc
40      Err.Raise glongCUSTOM_ERR_CANNOT_RETRIEVE_ACTIVE_SESSION, "TC_SessionsContainer::GetActiveSession", "Kann die aktive Session nicht ermitteln"
45  End If

ExitProc:
50  Set GetActiveSession = objActiveSession
55  Set objMyDoc = Nothing
60  Set objActiveSession = Nothing
65  Exit Function

RaiseErrorHandler:
70  Set objActiveSession = Nothing
75  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::GetActiveSession" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc

End Function

'---------------------------------------------------------------------------------------
' Prozedur : InitSessionCounter
' Autor    : Todor Vachkov
' Datum    : 28.06.2013
' Zweck    :
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams:
' String        : der volle Pfad zu einer WE_.txt Datei
'---------------------------------------------------------------------------------------
Public Sub InitSessionCounter(strFileName As String)

5   On Error GoTo RaiseErrorHandler

10  mintNextFreeSessionIDToAssign = Me.ParentIkolClientApp.FileHandler.GetLastSessionIDFromWEname(strFileName)

ExitProc:
15  Exit Sub

RaiseErrorHandler:
20  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::InitSessionCounter in Zeile:" & Erl & vbCrLf, Err.Description
25  Resume ExitProc
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   On Error GoTo RaiseErrorHandler

10  Set ParentIkolClientApp = mobjParentIkolClientApp

ExitProc:
15  Exit Property

RaiseErrorHandler:
20  Err.Raise Err.Number, Err.Source & "->" & "TC_SessionsContainer::ParentIkolClientApp in Zeile:" & Erl & vbCrLf, Err.Description
25  Resume ExitProc
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_SessionsContainer.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden"
25  End If
End Property
Attribute VB_Name = "TC_SignUpHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const mstr_EMPTY_SIGN As String = "      "
Private Const mstr_FILLED_SIGN As String = "(x) "
Private Const mstr_OPTIONAL_SIGN As String = " (K)"
Private Const mstr_MANDATORY_SIGN As String = " (M)"

Public Enum SutSignUpType
    sutNothing
    sutEdit
    sutSingle
    sutMulti
End Enum

Public Enum suSyncScreen
    susNoValue
    susNoSyncScreen
    susSignSyncScreen
    susAllSyncScreen
End Enum

Private mboolRetEditDlg As Boolean
Private mboolRetQuestionDlg As Boolean
Private marrAllSignNames() As SignatureNames
Private mstrSignName As String
Private mboolSignupStarted As Boolean
Private mboolMultiSignupStarted As Boolean
Private mintSignIndex As Integer
Private mboolSignReturn As Boolean
Private menumSignUpType As SutSignUpType
Private mobjParentIkolClientApp As TC_IkolClientApp

'16.07.2014 AL
'damit geht Schliessen-Button (Kreuz) beim Fenster, was im Pad angezeigt wird, weg
Private Const MF_BYPOSITION = &H400
Private Const MF_REMOVE = &H1000

Private Declare Function DrawMenuBar Lib "user32" _
(ByVal hwnd As Long) As Long

Private Declare Function GetMenuItemCount Lib "user32" _
(ByVal hMenu As Long) As Long

Private Declare Function GetSystemMenu Lib "user32" _
(ByVal hwnd As Long, ByVal bRevert As Long) As Long

Private Declare Function RemoveMenu Lib "user32" _
(ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

Private Declare Function ModifyMenu Lib "user32" Alias "ModifyMenuA" _
(ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, _
ByVal lpString As Any) As Long


Private Declare Function FindWindow Lib "user32" _
Alias "FindWindowA" (ByVal lpClassName As String, _
    ByVal lpWindowName As String) As Long

Private hwnd        As Long
'ENDE 16.07.2014 AL



Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_SignUpHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Get RetEditDlg() As Boolean
5   RetEditDlg = mboolRetEditDlg
End Property

Public Property Let RetEditDlg(ByVal boolRetEditDlg As Boolean)
5   mboolRetEditDlg = boolRetEditDlg
End Property

Public Property Get RetQuestionDlg() As Boolean
5   RetQuestionDlg = mboolRetQuestionDlg
End Property

Public Property Let RetQuestionDlg(ByVal boolRetQuestionDlg As Boolean)
5   mboolRetQuestionDlg = boolRetQuestionDlg
End Property

Public Property Get SignName() As String
5   SignName = mstrSignName
End Property

Public Property Let SignName(ByVal strSignName As String)
5   mstrSignName = strSignName
End Property

Public Property Get SignupStarted() As Boolean
5   SignupStarted = mboolSignupStarted
End Property

Public Property Let SignupStarted(ByVal boolSignupStarted As Boolean)
5   mboolSignupStarted = boolSignupStarted
End Property

Public Property Get MultiSignupStarted() As Boolean
5   MultiSignupStarted = mboolMultiSignupStarted
End Property

Public Property Let MultiSignupStarted(ByVal boolMultiSignupStarted As Boolean)
5   mboolMultiSignupStarted = boolMultiSignupStarted
End Property

Public Property Get SignIndex() As Integer
5   SignIndex = mintSignIndex
End Property

Public Property Let SignIndex(ByVal intSignIndex As Integer)
5   mintSignIndex = intSignIndex
End Property

Public Property Get SignReturn() As Boolean
5   SignReturn = mboolSignReturn
End Property

Public Property Let SignReturn(ByVal boolSignReturn As Boolean)
5   mboolSignReturn = boolSignReturn
End Property

Public Property Get SignUpType() As SutSignUpType
5   SignUpType = menumSignUpType
End Property

Public Property Let SignUpType(ByVal enumSignUpType As SutSignUpType)
5   menumSignUpType = enumSignUpType
End Property

Public Function SignTypMandatory() As Boolean

5   On Error GoTo RaiseErrorHandler
10  Me.RetQuestionDlg = False
15  With Me.ParentIkolClientApp.frmSignTypeQuestion
20      .Top = Me.ParentIkolClientApp.Tools.CenterDlgVertical(.Top, .height)
25      .Left = Me.ParentIkolClientApp.Tools.CenterDlgHorizontal(.Left, .width)
30  End With

35  Call Me.ParentIkolClientApp.frmSignTypeQuestion.Show

ExitProc:
40  SignTypMandatory = Me.RetQuestionDlg
45  Exit Function

RaiseErrorHandler:
50  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::SignTypMandatory" & " in Zeile:" & Erl & vbCrLf, Err.Description
55  Resume ExitProc

End Function

' ======================================================================
'   Interface-Proceduren f|fffd|r SignUpAppHandler
' ======================================================================
Public Function AppCancel() As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
10  Application.Run "SignUpAppHandler.CancelSignUp", boolReturn

ExitProc:
15  AppCancel = boolReturn
20  Exit Function

RaiseErrorHandler:
25  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::AppCancel" & " in Zeile:" & Erl & vbCrLf, Err.Description
30  Resume ExitProc
End Function


Public Function AppSaveSign() As Boolean
    Dim boolReturn As Boolean
5   On Error GoTo RaiseErrorHandler

10  Application.Run "SignUpAppHandler.saveSignature", boolReturn

ExitProc:
15  AppSaveSign = boolReturn
20  Exit Function

RaiseErrorHandler:
25  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::AppSaveSign" & " in Zeile:" & Erl & vbCrLf, Err.Description
30  Resume ExitProc

End Function

Public Function AppClear() As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
10  Application.Run "SignUpAppHandler.Clear", boolReturn

ExitProc:
15  AppClear = boolReturn
20  Exit Function

RaiseErrorHandler:
25  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::AppClear" & " in Zeile:" & Erl & vbCrLf, Err.Description
30  Resume ExitProc

End Function

Public Function AppInit(strConfigFile As String) As Boolean
5   On Error GoTo RaiseErrorHandler
    Dim boolReturn As Boolean

10  Application.Run "SignUpAppHandler.InitSignUpApp", strConfigFile, boolReturn

ExitProc:
15  AppInit = boolReturn
20  Exit Function

RaiseErrorHandler:

25  If Err.Number = 438 Then
30      Err.Raise glongCUSTOM_ERR_EAKTE_NOT_INSTALLED, "TC_SignUpHandler:AppInit", "Zur Nutzung vom Unterschriftmodul bitte das Installationspaket installieren"
35  Else
40      Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::AppInit" & " in Zeile:" & Erl & vbCrLf, Err.Description
45  End If

50  Resume ExitProc

End Function

Public Function AppStart(strSignName As String, _
                         strDocName As String, _
                         strTiffFile As String, _
                         strConfigFile As String, _
                         intWidth As Integer, _
                         intHeight As Integer, _
                         intScaleFactor As Integer) As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim intAppHeight As Integer
    Dim intAppWidth As Integer
    Dim session As TC_Session

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    intAppHeight = PointsToPixels(intHeight)
40    intAppWidth = PointsToPixels(intWidth)

50    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::AppStart - Start Unterschriftenmodul mit: ", session)
60    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - Unterschrift:      " & strSignName, session)
70    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - in Dokument:       " & strDocName, session)
80    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - Konfigdatei:       " & strConfigFile, session)
90    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - Ergebnisdatei:     " & strTiffFile, session)
100   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - H|fffd|he Unterschr.:   " & intHeight, session)
110   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - L|fffd|nge Unterschr.:  " & intWidth, session)
120   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - H|fffd|he in Pixels:    " & intAppHeight, session)
130   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - L|fffd|nge in Pixels:   " & intAppWidth, session)
140   Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("         - Skalierungsfaktor: " & intScaleFactor, session)

      '19.04.2016 AL
      Dim strPDFfromArcDir As String
150   If session.SignPad = "ST_ALPHA" Then
160     strPDFfromArcDir = session.ArchivDir + Dir(session.ArchivDir + "*.pdf")
        'MsgBox "PDF: " + strPDFfromArcDir
170     Application.Run "SignUpAppHandler.StartApp_ST_ALPHA", strDocName, strTiffFile, strConfigFile, intAppWidth, _
                    intAppHeight, intScaleFactor, boolReturn, strPDFfromArcDir
     'ENDE 19.04.2016 AL
180   End If
190   If session.SignPad = "ST_DELTA" Then
200     strPDFfromArcDir = session.ArchivDir + Dir(session.ArchivDir + "*.pdf")
        'MsgBox "PDF: " + strPDFfromArcDir
210     Application.Run "SignUpAppHandler.StartApp_ST_DELTA", strDocName, strTiffFile, strConfigFile, intAppWidth, _
                    intAppHeight, intScaleFactor, boolReturn, strPDFfromArcDir
220   End If
     
230   If session.SignPad <> "ST_ALPHA" And session.SignPad <> "ST_DELTA" Then
240     Application.Run "SignUpAppHandler.StartApp", strDocName, strTiffFile, strConfigFile, intAppWidth, _
                      intAppHeight, intScaleFactor, boolReturn

250   End If '19.04.2016 AL

ExitProc:
260   Set session = Nothing
270   AppStart = boolReturn
280   Exit Function

RaiseErrorHandler:
290   boolReturn = False
300   Set session = Nothing
310   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::AppStart" & " in Zeile:" & Erl & vbCrLf, Err.Description
320   Resume ExitProc

End Function

' ======================================================================
'   callback-Funktionen f|fffd|r die Steuerung des Unterschriftenmoduls
' ======================================================================
Public Function CancelSignUp() As Boolean
    ' Unterschriftenpad wird deaktiviert

5   On Error GoTo RaiseErrorHandler
    Dim boolReturn As Boolean

10  If Me.AppCancel Then
15      boolReturn = True
20  End If

ExitProc:
25  Me.SignupStarted = False
30  CancelSignUp = boolReturn
35  Exit Function

RaiseErrorHandler:
40  Me.SignupStarted = False
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::CancelSignUp" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc
End Function

Public Function GetSignCancel() As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
10  If Me.SignupStarted Then
15      boolReturn = Me.AppCancel
20  Else
25      boolReturn = True
30  End If

ExitProc:
35  GetSignCancel = boolReturn
40  Exit Function

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetSignCancel" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc

End Function

Public Function EndOfSignUp() As Boolean
    ' Unterschriftenpad wird deaktiviert und der Dialog geschlossen, f|fffd|r einzelne Unterschriften
10    On Error GoTo RaiseErrorHandler
    Dim boolReturn As Boolean

    Dim session As TC_Session
20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    If Me.AppCancel Then
40      boolReturn = True
50    End If

60    Me.SignupStarted = False
70    If Me.SignUpType = sutSingle Then
80      session.GetWorkingTcDocument.DestroySignUpWindow (False)
90      Me.ParentIkolClientApp.frmSignup.hide
100   End If

'16.07.2014 AL
'hiermit den Schliessen-Button (Kreuz) beim Hauptfenster wieder sichtbar machen
Dim capt As String
110   capt = session.workingDocument.ActiveWindow.Caption & " - " & Word.Application.Caption
120   Call EnableCloseButton(capt)
'ENDE 16.07.2014 AL

'16.09.2014 AL
'hiermit Ribbon-Leiste wiederherstellen
130   If session.RibbonMinimieren = True Then 'wird durch SETZE_PARAMETER RIBBON_MINIMIEREN=EIN gesetzt
        Dim wordVersion As Integer
140     wordVersion = CInt(Mid(Application.Version, 1, 2))
150     If wordVersion > 11 Then 'ab Word 2007
          Dim ribbonWasMaximezed As Boolean
          Dim ribbonIsMaximezed As Boolean
160       Application.Run "getRibbonWasMaximezed", ribbonWasMaximezed
          'MsgBox ("getRibbonWasMaximezed: " & ribbonWasMaximezed)

170       ribbonIsMaximezed = False
180       If (CommandBars("Ribbon").controls(1).height < 100) = 0 Then
190         ribbonIsMaximezed = True
200       End If

210       If ribbonWasMaximezed <> ribbonIsMaximezed Then
            'MsgBox ("ribbonWasMaximezed: " & ribbonWasMaximezed & " ribbonIsMaximezed: " & ribbonIsMaximezed)
220         CommandBars.ExecuteMso "MinimizeRibbon"
230       End If
240     End If
250   End If
'ENDE 16.09.2014 AL

ExitProc:
260   Set session = Nothing
270   EndOfSignUp = boolReturn
280   Exit Function

RaiseErrorHandler:
290   Me.SignupStarted = False
300   If Me.SignUpType = sutSingle Then
310     session.GetWorkingTcDocument.DestroySignUpWindow (False)
320     Me.SignUpType = sutNothing
330   End If
340   Set session = Nothing
350   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::EndOfSignUp" & " in Zeile:" & Erl & vbCrLf, Err.Description
360   Resume ExitProc
End Function

Public Function saveSignature() As Boolean

10    On Error GoTo RaiseErrorHandler
    Dim boolReturn As Boolean
    Dim session As TC_Session

30    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
40    If Me.AppSaveSign Then
50      boolReturn = True
70      Call Me.UpdateSignField(True, Me.SignIndex)
180   End If

190   Me.SignupStarted = False

ExitProc:
200   Set session = Nothing
210   saveSignature = boolReturn
220   Exit Function

RaiseErrorHandler:
240   Me.SignupStarted = False
250   If Me.SignUpType = sutSingle Then
260     session.GetWorkingTcDocument.DestroySignUpWindow (False)
270     Me.SignUpType = sutNothing
280   End If
300   Set session = Nothing
310   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::saveSignature" & " in Zeile:" & Erl & vbCrLf, Err.Description
320   Resume ExitProc
End Function

Public Function Clear() As Boolean
10    On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim session As TC_Session

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    boolReturn = Me.AppClear

'13.02.2015 AL
'Focus auf das kleine Unterschriftenfenster f|fffd|r den Kunden
  Dim longHwnd As Long
40    longHwnd = FindWindow(vbNullString, "Bitte unterzeichnen Sie hier")
50    Call Focus.ForceForegroundWindow(longHwnd)
'ENDE 13.02.2015 AL

'19.04.2016 AL und 06.11.2017 AL
60    If session.SignPad = "ST_ALPHA" Or _
   session.SignPad = "ST_DELTA" Or _
   session.SignPad = "WACOM_STU300" Or _
   session.SignPad = "WACOM_STU430" Or _
   session.SignPad = "WACOM_STU530" Or _
   session.SignPad = "WACOM_STU540" Or _
   session.SignPad = "WACOM_STU541" Then
70      longHwnd = FindWindow(vbNullString, "Kontrollfenster")
80      Call Focus.ForceForegroundWindow(longHwnd)
90    End If
'ENDE 19.04.2016 AL

ExitProc:
100   Set session = Nothing
110   Clear = boolReturn
120   Exit Function

RaiseErrorHandler:
130   Me.SignupStarted = False
140   If Me.SignUpType = sutSingle Then
150     session.GetWorkingTcDocument.DestroySignUpWindow (False)
160     Me.SignUpType = sutNothing
170   End If
180   Set session = Nothing

190   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::Clear" & " in Zeile:" & Erl & vbCrLf, Err.Description
200   Resume ExitProc
End Function

Public Function IsSignUpDotFileAlreadyLoaded(strSignUpFileNameToCheck As String) As Boolean
    'durch die Addins gehen und suchen ob schon geladen.....

    Dim objAddInCounter As Addin
    Dim boolFound As Boolean

5   On Error GoTo RaiseErrorHandler
10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Start Ausf|fffd|hrung TC_SignUpHandler::IsSignUpDotFileAlreadyLoaded()", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

15  boolFound = False

20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Suche nach der Unterschriftenmodul-Add-Inn-Vorlagendatei: '" & strSignUpFileNameToCheck & "'", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

25  On Error Resume Next

30  For Each objAddInCounter In Application.AddIns
35      If (UCase(objAddInCounter.name) = _
            UCase(strSignUpFileNameToCheck)) And objAddInCounter.Installed Then
40          boolFound = True
45          GoTo ExitProc
50      End If
55  Next objAddInCounter

60  On Error GoTo RaiseErrorHandler

ExitProc:
65  If boolFound Then
70      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Eine Unterschriftenmodul-Add-Inn-Vorlagendatei wurde gefunden und ist installiert.", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
75  Else
80      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Keine Unterschriftenmodul-Add-Inn-Vorlagendatei ist bereits installiert.", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
85  End If

90  Set objAddInCounter = Nothing
95  IsSignUpDotFileAlreadyLoaded = boolFound
100 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::IsSignUpDotFileAlreadyLoaded", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
105 Exit Function

RaiseErrorHandler:
110 boolFound = False
115 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::IsSignUpDotFileAlreadyLoaded" & " in Zeile:" & Erl & vbCrLf, Err.Description
120 Resume ExitProc
End Function

Public Function LoadSignUpAppHandler() As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim myAddIn As Addin
    Dim strSignUpModulDotFullFileName As String
    Dim tcResult As TC_SessionResult
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::LoadSignUpAppHandler: Laden des Unterschriftenmoduls", session)

20  strSignUpModulDotFullFileName = session.WinworkPath & gstrTC_SIGN_UP_MODUL

25  If Not Me.IsSignUpDotFileAlreadyLoaded(gstrTC_SIGN_UP_MODUL) Then
30      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::LoadSignUpAppHandler: Installiere die beiliegende Unterschriftenmodul-AddInn-Vorlagendatei '" & _
                                                               strSignUpModulDotFullFileName & "'", session)

35      Set myAddIn = Application.AddIns.Add(strSignUpModulDotFullFileName, True)
40      myAddIn.Installed = True
45  End If

50  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::LoadSignUpAppHandler: Starte die Initialisierung des Unerschriftenmoduls ...", session)

55  If Me.AppInit(session.IniFile) Then
60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::LoadSignUpAppHandler: Die Unterschriften-Applikation kann angesprochen werden", session)
65      tcResult = tcrOK
70  Else
75      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::LoadSignUpAppHandler: Die Unterschriften-Applikation kann nicht angesprochen werden", session)
80      tcResult = tcrCallError
85  End If

ExitProc:
90  LoadSignUpAppHandler = tcResult
95  Set session = Nothing
100 Exit Function

RaiseErrorHandler:
105 tcResult = tcrCallError
110 Set session = Nothing
115 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::LoadSignUpAppHandler" & " in Zeile:" & Erl & vbCrLf, Err.Description
120 Resume ExitProc
End Function

' ======================================================================
'   callback-Funktionen f|fffd|r die Steuerung der Auswahlbox des Unterschriftenmoduls
' ======================================================================
Public Function SignupSelectedItem(idx As Integer) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession


15  If Not Me.SignupStarted Then
20      Me.SignupStarted = True
25      Me.SignIndex = idx
30      Call Me.GotoTCSign(marrAllSignNames(idx).tc_sign)
35      boolReturn = Me.StartApp(session.GetWorkingTcDocument)
40  End If

ExitProc:
45  SignupSelectedItem = boolReturn
50  Set session = Nothing
55  Exit Function

RaiseErrorHandler:
60  Set session = Nothing
65  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::SignupSelectedItem" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc

End Function

Public Sub DeleteSelectedItem(idx As Integer)
5   On Error GoTo RaiseErrorHandler
    Dim intWordVersion As Integer

10  intWordVersion = CInt(Mid(Word.Application.Version, 1, 2))
15  Call Me.GotoTCSign(marrAllSignNames(idx).tc_sign)
20  Call Me.UpdateSignField(False, idx)
25  If intWordVersion = 12 Then
        ' an dieser Stelle ist Word nicht zu verstehen.
        ' die Darstellung des gel|fffd|schten Feldes wird erst nach zweimaligen Bet|fffd|tigen des Delete-Buttons
        ' richtig dargestellt
30      Call Me.UpdateSignField(False, idx)
35  End If

ExitProc:
40  Exit Sub

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::DeleteSelectedItem" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc

End Sub

'16.07.2014 AL
'hiermit den Schliessen-Button (Kreuz) beim Fenster mit der Caption capt sichtbar machen
Public Sub EnableCloseButton(capt As String)
  Dim hMenu           As Long
  Dim menuItemCount   As Long
  
10      hwnd = FindWindow(vbNullString, capt)

  'Obtain the handle to the form's system menu
20      hMenu = GetSystemMenu(hwnd, 1) 'ori , 0

30      If hMenu Then

    'Obtain the number of items in the menu
40        menuItemCount = GetMenuItemCount(hMenu)

    'Remove the system menu Close menu item.
    'The menu item is 0-based, so the last
    'item on the menu is menuItemCount - 1
50        'Call AddMenu(hMenu, menuItemCount - 1, _
        'MF_REMOVE Or MF_BYPOSITION)

    'Remove the system menu separator line
60        'Call AddMenu(hMenu, menuItemCount - 2, _
        'MF_REMOVE Or MF_BYPOSITION)

    'Force a redraw of the menu. This
    'refreshes the titlebar, dimming the X
70        Call DrawMenuBar(hwnd)
80       End If
End Sub
'ENDE 16.07.2014 AL

Public Sub CancelMultiSignUp()

10    On Error GoTo RaiseErrorHandler

    Dim session As TC_Session
20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    If Me.SignUpType = sutMulti Then
40      Me.MultiSignupStarted = False
50      session.GetWorkingTcDocument.DestroySignUpWindow (False)
60      Me.SignUpType = sutNothing
70    End If

'16.07.2014 AL
'hiermit den Schliessen-Button (Kreuz) beim Hauptfenster wieder sichtbar machen
Dim capt As String
80    capt = session.workingDocument.ActiveWindow.Caption & " - " & Word.Application.Caption
90    Call EnableCloseButton(capt)
'ENDE 16.07.2014 AL

'16.09.2014 AL
'hiermit Ribbon-Leiste wiederherstellen
100   If session.RibbonMinimieren = True Then 'wird durch SETZE_PARAMETER RIBBON_MINIMIEREN=EIN gesetzt
        Dim wordVersion As Integer
110     wordVersion = CInt(Mid(Application.Version, 1, 2))
120     If wordVersion > 11 Then 'ab Word 2007
          Dim ribbonWasMaximezed As Boolean
          Dim ribbonIsMaximezed As Boolean
130       Application.Run "getRibbonWasMaximezed", ribbonWasMaximezed
          'MsgBox ("getRibbonWasMaximezed: " & ribbonWasMaximezed)

140       ribbonIsMaximezed = False
150       If (CommandBars("Ribbon").controls(1).height < 100) = 0 Then
160         ribbonIsMaximezed = True
170       End If

180       If ribbonWasMaximezed <> ribbonIsMaximezed Then
            'MsgBox ("ribbonWasMaximezed: " & ribbonWasMaximezed & " ribbonIsMaximezed: " & ribbonIsMaximezed)
190         CommandBars.ExecuteMso "MinimizeRibbon"
200       End If
210     End If
220   End If
'ENDE 16.09.2014 AL

ExitProc:
230   Set session = Nothing
240   Exit Sub

RaiseErrorHandler:
250   Set session = Nothing
260   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::CancelMultiSignUp" & " in Zeile:" & Erl & vbCrLf, Err.Description
270   Resume ExitProc

End Sub

Public Function StartApp(tcDoc As TC_Document) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler:StartApp", session)

    Dim boolReturn As Boolean
    Dim objSignature As TC_Signature
    Dim intHeight As Integer
    Dim intWidth As Integer
    Dim objInlineShape As InlineShape

20  boolReturn = False
25  Set objSignature = marrAllSignNames(mintSignIndex).tc_sign
30  Set objInlineShape = objSignature.SignBookmark.Range.InlineShapes(1)
35  Call Me.ParentIkolClientApp.Tools.SetHeightAndWidthFromInlineShape(objInlineShape, intHeight, intWidth)

40  boolReturn = AppStart(marrAllSignNames(mintSignIndex).showedName, _
                          session.workingDocument.name, _
                          session.SignTempDirectory & objSignature.SignBookmark & ".tif", _
                          session.IniFile, _
                          intWidth, _
                          intHeight, _
                          session.SignScaleFactor)

ExitProc:
45  Set session = Nothing
50  Set objSignature = Nothing
55  Set objInlineShape = Nothing
60  StartApp = boolReturn
65  Exit Function

RaiseErrorHandler:
70  boolReturn = False
75  Set objSignature = Nothing
80  Set objInlineShape = Nothing
85  Set session = Nothing
90  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::StartApp" & " in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc
End Function

Public Function ChangeSignupFieldcode(strCode As String, strFileName As String) As String

5   On Error GoTo RaiseErrorHandler

    Dim strReturn As String
    Dim strMerge As String
    Dim strPictureLink As String
    Dim strDoubleSeparator As String
    Dim strTmpFileName As String

10  strMerge = vbNullString
15  strPictureLink = vbNullString

20  If InStr(1, UCase(strCode), " \* MERGEFORMAT") > 0 Then strMerge = " \* MERGEFORMAT"
25  If InStr(1, UCase(strCode), " \D") > 0 Then strPictureLink = " \d"
30  strDoubleSeparator = Application.PathSeparator & Application.PathSeparator

35  strTmpFileName = strFileName
40  strTmpFileName = Replace(strTmpFileName, Application.PathSeparator, strDoubleSeparator)
45  strTmpFileName = Replace(strTmpFileName, strDoubleSeparator & strDoubleSeparator, strDoubleSeparator)

50  strReturn = "INCLUDEPICTURE " & Chr(34) & strTmpFileName & Chr(34) & strMerge & strPictureLink

ExitProc:
55  ChangeSignupFieldcode = strReturn
60  Exit Function

RaiseErrorHandler:
65  strReturn = vbNullString
70  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::ChangeSignupFieldcode" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Function

Public Sub UpdateSingleSignfield(objSignature As TC_Signature, _
                                 boolIsSignSet As Boolean)

5   On Error GoTo RaiseErrorHandler

    Dim strNewFile As String
    Dim boolResult As Boolean
    Dim strNewCodeText As String
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  If boolIsSignSet Then
20      strNewFile = session.SignTempDirectory & objSignature.SignBookmark & ".tif"
25  Else
30      strNewFile = session.SignDefaultFile
35  End If

40  strNewCodeText = Me.ChangeSignupFieldcode(objSignature.signField.Code.text, strNewFile)
45  objSignature.SignFile = strNewFile
50  objSignature.signField.Code.text = strNewCodeText
55  With objSignature.SignBookmark.Range
60      Call Me.ParentIkolClientApp.Tools.SetInlineShapeProperties(objSignature, .InlineShapes(1), session.SignScaleFactor, boolIsSignSet)
65  End With

70  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("UpdateSingelSingField aktualisiert das Feld " & objSignature.SignBookmark.name, session)
75  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("      neuer FeldCode:        " & objSignature.signField.Code.text, session)
80  boolResult = objSignature.signField.Update

ExitProc:
85  Set session = Nothing
90  Exit Sub

RaiseErrorHandler:
95  Set session = Nothing
100 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::UpdateSingleSignfield" & " in Zeile:" & Erl & vbCrLf, Err.Description
105 Resume ExitProc
End Sub

Public Sub UpdateSignField(boolIsSignSet As Boolean, idx As Integer)
5   On Error GoTo RaiseErrorHandler

    Dim objSignature As TC_Signature
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler::UpdateSignField", session)
20  Set objSignature = marrAllSignNames(idx).tc_sign
25  Call Me.UpdateSingleSignfield(objSignature, boolIsSignSet)
30  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::UpdateSignField", session)

ExitProc:
35  Set session = Nothing
40  Set objSignature = Nothing
45  Exit Sub

RaiseErrorHandler:
50  Set objSignature = Nothing
55  Set session = Nothing
60  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::UpdateSignField" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc
End Sub

Public Sub UpdateSignFields(boolIsSignSet As Boolean)
5   On Error GoTo RaiseErrorHandler

    Dim objSignature As TC_Signature
    Dim idx As Integer
    Dim objSignaturesContainer As TC_SignaturesContainer
    Dim session As TC_Session
    Dim intFirstArrayIndex As Integer


10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler::UpdateSignFields", session)
20  Set objSignaturesContainer = session.GetWorkingTcDocument.ManagedTCSignaturesContainer

25  If Not (objSignaturesContainer Is Nothing) Then
30      If objSignaturesContainer.Counter > 0 Then
35          marrAllSignNames = objSignaturesContainer.GetSignatureNames

            ' abfangen, ob das Array leer ist
40          intFirstArrayIndex = LBound(marrAllSignNames)

45          For idx = intFirstArrayIndex To UBound(marrAllSignNames)
50              Set objSignature = marrAllSignNames(idx).tc_sign
55              Call Me.UpdateSingleSignfield(objSignature, boolIsSignSet)
60          Next idx
65      End If
70  End If

75  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Beende Ausf|fffd|hrung TC_SignUpHandler::UpdateSignFields", session)

ExitProc:
80  Set objSignature = Nothing
85  Set objSignaturesContainer = Nothing
90  Set session = Nothing
95  Exit Sub

RaiseErrorHandler:
100 Set objSignature = Nothing
105 Set objSignaturesContainer = Nothing
110 Set session = Nothing

115 If Err.Number = 9 Then
120     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("TC_SignUpHandler:UpdateSignFields: Auf dem Dokument wurden keine physischen Unterschriften gefunden. Anscheinend wurden sie h|fffd|ndisch aus dem Dokument entfernt.")
125 Else
130     Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::UpdateSignFields" & " in Zeile:" & Erl & vbCrLf, Err.Description
135 End If
140 Resume ExitProc
End Sub

Public Function GetSignName() As String
5   On Error GoTo RaiseErrorHandler

    Dim strReturn As String
10  strReturn = marrAllSignNames(Me.SignIndex).showedName

ExitProc:
15  GetSignName = strReturn
20  Exit Function

RaiseErrorHandler:
25  strReturn = vbNullString
30  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetSignName" & " in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc
End Function

Private Function GetMarkedName(strName As String, objSignature As TC_Signature) As String
5   On Error GoTo RaiseErrorHandler
    Dim strReturn As String

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  strReturn = strName

20  If Not (session Is Nothing) Then
25      If InStr(1, objSignature.signField.Code, session.SignDefaultFile) <> 0 Then
30          If Not (Me.SignUpType = sutEdit) Then
35              strReturn = mstr_EMPTY_SIGN & strReturn
40          End If
45      Else
50          strReturn = mstr_FILLED_SIGN & strReturn
55      End If
60      If objSignature.SignOptional Then
65          strReturn = strReturn & mstr_OPTIONAL_SIGN
70      Else
75          strReturn = strReturn & mstr_MANDATORY_SIGN
80      End If
85  End If

ExitProc:
90  Set session = Nothing
95  GetMarkedName = strReturn
100 Exit Function

RaiseErrorHandler:
105 strReturn = vbNullString
110 Set session = Nothing
115 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetMarkedName" & " in Zeile:" & Erl & vbCrLf, Err.Description
120 Resume ExitProc
End Function

Public Function RestoreMarkedName(strName As String) As String
5   On Error GoTo RaiseErrorHandler

    Dim strReturn As String
    Dim intBegPos As Integer
    Dim intAnhpos As Integer
    Dim tmpEmptySignStr As String

10  strReturn = strName
15  tmpEmptySignStr = mstr_EMPTY_SIGN
20  If Me.SignUpType = sutEdit Then
25      tmpEmptySignStr = vbNullString
30  End If

35  intBegPos = 0
40  If Mid(strReturn, 1, Len(tmpEmptySignStr)) = tmpEmptySignStr Then
45      intBegPos = Len(tmpEmptySignStr)
50  Else
55      If Mid(strReturn, 1, Len(mstr_FILLED_SIGN)) = mstr_FILLED_SIGN Then
60          intBegPos = Len(mstr_FILLED_SIGN)
65      End If
70  End If
75  strReturn = Mid(strReturn, intBegPos + 1)

80  intAnhpos = InStr(1, strReturn, mstr_OPTIONAL_SIGN)

85  If intAnhpos = 0 Then
90      intAnhpos = InStr(1, strReturn, mstr_MANDATORY_SIGN)
95  End If

100 If intAnhpos <> 0 Then
105     strReturn = Mid(strReturn, 1, intAnhpos - 1)
110 End If

ExitProc:
115 RestoreMarkedName = strReturn
120 Exit Function

RaiseErrorHandler:
125 strReturn = vbNullString
130 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::RestoreMarkedName" & " in Zeile:" & Erl & vbCrLf, Err.Description
135 Resume ExitProc
End Function

Public Function FillListWithSignNames(lbSignNames As ListBox) As Integer
5   On Error GoTo RaiseErrorHandler

    Dim intReturn As Integer
    Dim intCount As Integer
    Dim idx As Integer
    Dim objTcDoc As TC_Document
    Dim entryStr As String

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  lbSignNames.Clear
20  Set objTcDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)

25  If objTcDoc.ManagedTCSignaturesContainer.Counter > 0 Then
30      marrAllSignNames = objTcDoc.ManagedTCSignaturesContainer.GetSignatureNames
35      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler::FillListWithSignNames: Inhalt der Listbox ist", session)

40      For idx = LBound(marrAllSignNames) To UBound(marrAllSignNames)
45          entryStr = GetMarkedName(marrAllSignNames(idx).showedName, marrAllSignNames(idx).tc_sign)
50          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("          Eintrag (" & idx & "): " & entryStr, session)
55          lbSignNames.AddItem entryStr
60          intCount = intCount + 1
65      Next idx

70      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::FillListWithSignNames", session)
75  End If

80  intReturn = intCount

ExitProc:
85  Set session = Nothing
90  Set objTcDoc = Nothing
95  FillListWithSignNames = intReturn
100 Exit Function

RaiseErrorHandler:
105 Set session = Nothing
110 intReturn = 0
115 Set objTcDoc = Nothing
120 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::FillListWithSignNames" & " in Zeile:" & Erl & vbCrLf, Err.Description
125 Resume ExitProc
End Function

Public Sub GetSingleSignatureWithForm(idx As Integer)
10    On Error GoTo RaiseErrorHandler


    Dim boolReturn As Boolean
    Dim objDocWindow As Window
    Dim session As TC_Session

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    Me.SignupStarted = True
40    Me.SignIndex = idx

    ' aus frmTC_Signup: UserForm_Initialize |fffd|bertragen
50    Me.ParentIkolClientApp.frmSignup.T_SignLabel.Caption = Me.GetSignName
60    Me.ParentIkolClientApp.frmSignup.DoAction (True)

    ' Zentrieren des Dialogs
70    Set objDocWindow = session.GetWorkingTcDocument.Document.Windows(1)

80    objDocWindow.Activate 'funzt nicht zuverl|fffd|ssig (zumindest nicht in Ansbach), deshalb noch folgendes:
      '29.07.2014 AL
      Dim objTcDoc As TC_Document
90    Set objTcDoc = session.GetWorkingTcDocument
100   objTcDoc.mainWindow.Activate
      'objTcDoc.SignUpWindow.Activate --> dies w|fffd|re das Fenster auf dem Pad
      'ENDE 29.07.2014 AL

110   With Me.ParentIkolClientApp.frmSignup             'signDlg
120     .Top = Me.ParentIkolClientApp.Tools.CenterDlgVertical(.Top, .height)
130     .Left = Me.ParentIkolClientApp.Tools.CenterDlgHorizontal(.Left, .width)
140   End With

150   Me.ParentIkolClientApp.frmSignup.Show
160   boolReturn = Me.StartApp(session.GetWorkingTcDocument)

ExitProc:
170   Set session = Nothing
180   Set objDocWindow = Nothing
190   Set objTcDoc = Nothing '29.07.2014 AL
200   Exit Sub

RaiseErrorHandler:
210   Set session = Nothing
220   Set objDocWindow = Nothing
230   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetSingleSignatureWithForm" & " in Zeile:" & Erl & vbCrLf, Err.Description
240   Resume ExitProc


End Sub

Public Sub GetMultisignature()
10    On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim objDocWindow As Window
    Dim session As TC_Session

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    Me.MultiSignupStarted = True
40    Me.ParentIkolClientApp.frmSignUpSelection.FillListbox

50    Set objDocWindow = session.GetWorkingTcDocument.Document.Windows(1)
60    objDocWindow.Activate 'funzt nicht zuverl|fffd|ssig (zumindest nicht in Ansbach), deshalb noch folgendes:
      '29.07.2014 AL
      Dim objTcDoc As TC_Document
70    Set objTcDoc = session.GetWorkingTcDocument
80    objTcDoc.mainWindow.Activate
      'objTcDoc.SignUpWindow.Activate --> dies w|fffd|re das Fenster auf dem Pad
      'ENDE 29.07.2014 AL

90    With Me.ParentIkolClientApp.frmSignUpSelection
100     .Top = Me.ParentIkolClientApp.Tools.CenterDlgVertical(.Top, .height)
110     .Left = Me.ParentIkolClientApp.Tools.CenterDlgHorizontal(.Left, .width)
120   End With
130   Me.ParentIkolClientApp.frmSignUpSelection.Show

ExitProc:
140   Set session = Nothing
150   Set objDocWindow = Nothing
160   Set objTcDoc = Nothing '29.07.2014 AL
170   Exit Sub

RaiseErrorHandler:
180   Set session = Nothing
190   Set objDocWindow = Nothing
200   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetMultisignature" & " in Zeile:" & Erl & vbCrLf, Err.Description
210   Resume ExitProc
End Sub

Public Function SignUp() As TC_SessionResult

10    On Error GoTo RaiseErrorHandler

    Dim objTcDoc As TC_Document
    Dim boolReturn As Boolean
    Dim tcrSessionResult As TC_SessionResult
    Dim session As TC_Session

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    tcrSessionResult = tcrOK

40    If Me.SignupStarted Then
50      Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Es ist bereits die Eingabe einer Unterschrift gestartet", session)
60      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::SignUp: Es ist bereits die Eingabe einer Unterschrift gestartet", session)
70    Else
80      Set objTcDoc = session.GetWorkingTcDocument

'25.04.2016 AL
110   If session.UPadFinalQuestion = True Then
120     'MsgBox "UPadFinalQuestion ist an"
130   End If
'ENDE 25.04.2016 AL

140     If objTcDoc.ManagedTCSignaturesContainer.Counter > 0 Then
150         marrAllSignNames = objTcDoc.ManagedTCSignaturesContainer.GetSignatureNames
160         boolReturn = False

            '19.06.2014 AL
            'if auskommentiert, da ansonsten Unterschrift nur einmal erfassbar war,
            'd.h. wurde die Unterschrift mit dem IKOL-Button gel|fffd|scht, passiert beim Klick auf den IKOL-Button "Unterschrift erfassen" nix mehr
            'das betraf allerdings nur Dokumente mit einem einzigen Unterschriftenfeld - Dokumente mit zwei Unterschriftfeldern waren davon nicht betroffen
            'If Me.SignUpType = sutNothing Then
170             If session.SignSynchScreen = susSignSyncScreen Then
180                 boolReturn = Not (objTcDoc.CreateSignUpWindow Is Nothing)
190             Else
200                 boolReturn = True
210             End If
            'End If 'ENDE 19.06.2014 AL

220         If boolReturn Then
                ' 105             Set Me.Session = Session
                
                '04.06.2015 AL
                'ORI: If objTcDoc.ManagedTCSignaturesContainer.Counter = 1 Then
230             If (objTcDoc.ManagedTCSignaturesContainer.Counter = 1 And session.SignMultiSelect = False) Then
                    '115                 errorStep = 4
240                 Me.SignUpType = sutSingle
250                 Call Me.GetSingleSignatureWithForm(0)
260             Else
                    '135                 errorStep = 5
270                 Me.SignUpType = sutMulti
280                 Call Me.GetMultisignature
290             End If

                '09.07.2014 AL
                'sonst ist Symbolleiste wieder im Pad-Fenster (Word 2010)
300             objTcDoc.Document.Windows(1).Activate 'Hauptdokument
310             If session.SignPad <> "ST_ALPHA" And _
                   session.SignPad <> "ST_DELTA" And _
                   session.SignPad <> "WACOM_STU300" And _
                   session.SignPad <> "WACOM_STU430" And _
                   session.SignPad <> "WACOM_STU530" And _
                   session.SignPad <> "WACOM_STU540" And _
                   session.SignPad <> "WACOM_STU541" Then 'das if am 19.04.2016 AL und 06.11.2017 AL
320               objTcDoc.Document.Windows(2).Activate 'Unterschriftenfenster
330             End If
                'ENDE 09.07.2014 AL
340         End If
350     Else
360         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::SignUp: Es wurden keine festgelegten Unterschriften im Dokument gefunden", session)
370         Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Es wurden keine festgelegten Unterschriften im Dokument gefunden", session)
380     End If
390   End If

ExitProc:
400   Set session = Nothing
410   Set objTcDoc = Nothing
420   SignUp = tcrSessionResult
430   Exit Function

RaiseErrorHandler:
440   Set session = Nothing
450   Set objTcDoc = Nothing
460   tcrSessionResult = tcrCallError
470   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::SignUp" & " in Zeile:" & Erl & vbCrLf, Err.Description
480   Resume ExitProc
End Function

Public Sub EditSignUp()

5   On Error GoTo RaiseErrorHandler
    Dim objDocWindow As Window
    Dim objTcDoc As TC_Document
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler::EditSignUp", session)
20  Me.SignUpType = sutEdit
25  Set objTcDoc = session.GetWorkingTcDocument

30  Set Me.ParentIkolClientApp.frmEditSignup.SignaturesContainer = objTcDoc.ManagedTCSignaturesContainer
35  If objTcDoc.ManagedTCSignaturesContainer.Counter > 0 Then

40      Me.ParentIkolClientApp.frmEditSignup.FillEditListbox

45  End If

50  Set objDocWindow = session.GetWorkingTcDocument.Document.Windows(1)

55  With Me.ParentIkolClientApp.frmEditSignup
60      .Top = Me.ParentIkolClientApp.Tools.CenterDlgVertical(.Top, .height)
65      .Left = Me.ParentIkolClientApp.Tools.CenterDlgHorizontal(.Left, .width)
70      .B_DeleteSignUp.enabled = False
75      .B_GoToSignUp.enabled = False
80  End With


85  Me.RetEditDlg = False
90  Me.ParentIkolClientApp.frmEditSignup.Show
95  Me.ParentIkolClientApp.frmEditSignup.TB_Description.SetFocus

100 If Me.RetEditDlg Then
105     objTcDoc.ManagedTCSignaturesContainer.UpdateSignaturesList
110 End If

115 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::EditSignUp", session)

ExitProc:
120 Set session = Nothing
125 Set objDocWindow = Nothing
130 Set objTcDoc = Nothing
135 Exit Sub

RaiseErrorHandler:
140 Set session = Nothing
145 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::EditSignUp" & " in Zeile:" & Erl & vbCrLf, Err.Description
150 Resume ExitProc
End Sub

Public Function DeleteSignUp() As TC_SessionResult
    ' setzt das Dokument zur|fffd|ck und blendet das Ausgangsbild ein

5   On Error GoTo RaiseErrorHandler

    Dim objSessionResult As TC_SessionResult

    Dim idx As Integer
    Dim objTcDoc As TC_Document
    Dim arrTmpSignNames() As SignatureNames

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  objSessionResult = tcrOK


20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler::DeleteSignUp", session)
25  Set objTcDoc = session.GetWorkingTcDocument

30  If objTcDoc.ManagedTCSignaturesContainer.Counter > 0 Then
35      arrTmpSignNames = objTcDoc.ManagedTCSignaturesContainer.GetSignatureNames
40      For idx = LBound(arrTmpSignNames) To UBound(arrTmpSignNames)
45          Call Me.UpdateSingleSignfield(arrTmpSignNames(idx).tc_sign, False)
50      Next idx
55  End If

60  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::DeleteSignUp", session)

ExitProc:
65  DeleteSignUp = objSessionResult
70  Set objTcDoc = Nothing
75  Set session = Nothing
80  Exit Function

RaiseErrorHandler:
85  objSessionResult = tcrCallError
90  Set objTcDoc = Nothing
95  Set session = Nothing
100 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::DeleteSignUp" & " in Zeile:" & Erl & vbCrLf, Err.Description
105 Resume ExitProc
End Function

Public Function WriteWindowsPosition()
10    On Error GoTo RaiseErrorHandler

    Dim objTcDoc As TC_Document
    Dim session As TC_Session
    Dim strSection As String    '07.10.2014 AL
    Dim boolRetValue As Boolean '07.10.2014 AL

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
30    Set objTcDoc = session.GetWorkingTcDocument

40    If objTcDoc.SignUpWindow Is Nothing Then
50      Err.Raise glongCUSTOM_ERR_NO_SECOND_SIGN_SCREEN, "TC_SignUpHandler::WriteWindowsPosition", "Es ist kein zweites Fenster f|fffd|r die Unterschrifteneingabe ge|fffd|ffnet"
60    Else
        '07.10.2014 AL - auch Position des Hauptfensters speichern (wegen Windows 8.1)
70      strSection = REG_SignatureSection & "\" & objTcDoc.Document.name
80      boolRetValue = WriteCurrentUserRegValue(strSection, wndKeyLeft_H, CStr(objTcDoc.mainWindow.Left)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyTop_H, CStr(objTcDoc.mainWindow.Top)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyHeight_H, CStr(objTcDoc.mainWindow.height)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyWidth_H, CStr(objTcDoc.mainWindow.width)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyState_H, CStr(objTcDoc.mainWindow.WindowState)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyZoom_H, CStr(objTcDoc.mainWindow.Panes(1).View.Zoom.PageFit)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyZoomFactor_H, CStr(objTcDoc.mainWindow.Panes(1).View.Zoom.Percentage))
        'ENDE 07.10.2014 AL - auch Position des Hauptfensters speichern (wegen Windows 8.1)


90      If Me.ParentIkolClientApp.Tools.SaveUserWindowPosition(objTcDoc.SignUpWindow, objTcDoc.Document.name) Then
100         objTcDoc.mainWindow.Activate
110         Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Position wurde gespeichert", session)
120         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::WriteWindowsPosition: Position wurde gespeichert", session)
130     Else
140         Call Me.ParentIkolClientApp.LogfileHandler.ViewMsgbox("Fehler beim Speichern der Position", session)
150         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::WriteWindowsPosition: Fehler beim Speichern der Position", session)
160     End If
170   End If

ExitProc:
180   Set session = Nothing
190   Set objTcDoc = Nothing
200   Exit Function

RaiseErrorHandler:
210   Set session = Nothing
220   Set objTcDoc = Nothing
230   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::WriteWindowsPosition" & " in Zeile:" & Erl & vbCrLf, Err.Description
240   Resume ExitProc

End Function

Public Function CreateDefaultSignature(strDescription As String, _
                                       boolMandantory As Boolean) As Boolean


5   On Error GoTo RaiseErrorHandler

    Dim objField As Field
    Dim objRange As Range
    Dim objTcDoc As TC_Document
    Dim strTmpDescr As String
    Dim objBookmark As Bookmark
    Dim strMarker As String
    Dim boolReturn As Boolean
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  boolReturn = True
20  Set objTcDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)
25  strTmpDescr = Replace(strDescription, " ", "_")

30  If Me.SignTypMandatory() Then
35      strMarker = "TCSM_"
40  Else
45      strMarker = "TCSK_"
50  End If

55  strMarker = strMarker & (objTcDoc.GetNextGobalSignID) & "_"
60  strTmpDescr = strMarker & strTmpDescr

65  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::CreateDefaultSignature: - Hinzuf|fffd|gen Unterschrift: " & strTmpDescr, session)

    '17.02.2015 AL
    'von
    '  "INCLUDEPICTURE " & Chr(34) & session.SignDefaultFile & Chr(34) & " \d ",
    'ge|fffd|ndert in
    '  "INCLUDEPICTURE " & Chr(34) & session.SignDefaultFile & Chr(34) & " ",
    '
    'D.h. OHNE "\d", was bewirkt, dass Daten IM Dokument gespeichert werden und somit auch im Archiv landen
70  Set objField = Selection.Fields.Add(Selection.Range, _
                                        wdFieldEmpty, _
                                        "INCLUDEPICTURE " & Chr(34) & session.SignDefaultFile & Chr(34) & " ", _
                                        True)
75  objField.Locked = False

80  Selection.MoveLeft Unit:=wdCharacter, count:=1, Extend:=wdExtend

85  Set objRange = Selection.Range

90  If objRange.InlineShapes.count > 0 Then
95      With objRange.InlineShapes(1)
100         .LockAspectRatio = msoFalse
105         .height = CentimetersToPoints(1.5)
110         .width = CentimetersToPoints(7)
115     End With
120 End If

125 Set objBookmark = objRange.Bookmarks.Add(strTmpDescr)
130 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Beende Ausf|fffd|hrung TC_SignUpHandler::CreateDefaultSignature", session)

ExitProc:
135 CreateDefaultSignature = boolReturn
140 Set objRange = Nothing
145 Set objTcDoc = Nothing
150 Set objField = Nothing
155 Set objBookmark = Nothing
160 Set session = Nothing
165 Exit Function

RaiseErrorHandler:
170 boolReturn = False
175 Set objRange = Nothing
180 Set objTcDoc = Nothing
185 Set objField = Nothing
190 Set objBookmark = Nothing
195 Set session = Nothing

200 If Err.Number = 5828 Then
205     Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::CreateDefaultSignature" & " in Zeile:" & Erl & vbCrLf, Err.Description & " -> Der Name f|fffd|r die Unterschrift darf nur Buchstaben, Zahlen und Leerzeichen enthalten"
210     objField.Delete
215 Else
220     Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::CreateDefaultSignature" & " in Zeile:" & Erl & vbCrLf, Err.Description
225 End If
230 Resume ExitProc

End Function

Public Function GetSignFromDescr(strSignName As String) As TC_Signature
5   On Error GoTo RaiseErrorHandler

    Dim objResultSignature As TC_Signature
    Dim idx As Integer
    Dim strRestName As String
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  strRestName = Me.RestoreMarkedName(strSignName)
20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Starte Ausf|fffd|hrung TC_SignUpHandler::GetSignFromDescr", session)
25  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("strSignName = [" & strSignName & _
                                                           "], restaurierter Name = [" & strRestName & "]", _
                                                           session)

30  For idx = LBound(marrAllSignNames) To UBound(marrAllSignNames)
35      If UCase(strRestName) = UCase(marrAllSignNames(idx).showedName) Then
40          Set objResultSignature = marrAllSignNames(idx).tc_sign
45          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::GetSignFromDescr: - Textmarke gefunden, realer Name: " & marrAllSignNames(idx).realName, session)
50          GoTo ExitProc
55      End If
60  Next idx

65  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung TC_SignUpHandler::GetSignFromDescr: - keine Textmarke gefunden", session)

ExitProc:
70  Set GetSignFromDescr = objResultSignature
75  Set objResultSignature = Nothing
80  Set session = Nothing
85  Exit Function

RaiseErrorHandler:
90  Set session = Nothing
95  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetSignFromDescr" & " in Zeile:" & Erl & vbCrLf, Err.Description
100 Resume ExitProc
End Function

'26.04.2016 AL
Public Function GetSignIDXFromDescr(strSignName As String) As Integer
10    On Error GoTo RaiseErrorHandler

    Dim resultIDX As Integer
    Dim idx As Integer
    Dim strRestName As String
    Dim session As TC_Session

20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    strRestName = Me.RestoreMarkedName(strSignName)
40    resultIDX = -1
50    For idx = LBound(marrAllSignNames) To UBound(marrAllSignNames)
60      If UCase(strRestName) = UCase(marrAllSignNames(idx).showedName) Then
70          resultIDX = idx + 1
80          GoTo ExitProc
90      End If
100   Next idx

ExitProc:
110   GetSignIDXFromDescr = resultIDX
120   Set session = Nothing
130   Exit Function

RaiseErrorHandler:
140   Set session = Nothing
150   resultIDX = -1
160   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetSignIDXFromDescr" & " in Zeile:" & Erl & vbCrLf, Err.Description
170   Resume ExitProc
End Function

Public Function BookmarkInRange(bm As Bookmark, rng As Range) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim tstBkmark As Bookmark

10  boolReturn = False

15  For Each tstBkmark In rng.Bookmarks
20      If tstBkmark.name = bm.name Then
25          tstBkmark.Select
30          boolReturn = True
35          Exit For
40      End If
45  Next tstBkmark

ExitProc:
50  Set tstBkmark = Nothing
55  BookmarkInRange = boolReturn
60  Exit Function

RaiseErrorHandler:
65  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::BookmarkInRange" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Function

Public Function GotoTCSign(objTcSignature As TC_Signature) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim storyRange As Range
    Dim objWordDoc As Document
    Dim boolReturn As Boolean
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  Set objWordDoc = session.GetWorkingTcDocument.Document

20  For Each storyRange In objWordDoc.StoryRanges
25      If BookmarkInRange(objTcSignature.SignBookmark, storyRange) Then
30          boolReturn = True
35          Exit For
40      End If

45      While Not (storyRange.NextStoryRange Is Nothing)
50          Set storyRange = storyRange.NextStoryRange
55          If BookmarkInRange(objTcSignature.SignBookmark, storyRange) Then
60              boolReturn = True
65              Exit For
70          End If
75      Wend

80  Next storyRange

ExitProc:
85  Set session = Nothing
90  Set objWordDoc = Nothing
95  Set storyRange = Nothing
100 GotoTCSign = boolReturn
105 Exit Function

RaiseErrorHandler:
110 Set session = Nothing
115 boolReturn = False
120 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GotoTCSign" & " in Zeile:" & Erl & vbCrLf, Err.Description
125 Resume ExitProc
End Function

Public Function DeleteTCSign(objTcSignature As TC_Signature, idx As Integer) As Boolean

10    On Error GoTo RaiseErrorHandler
    Dim boolReturn As Boolean

    Dim session As TC_Session
20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    boolReturn = False

40    If Me.GotoTCSign(objTcSignature) Then

50      Selection.Delete Unit:=wdCharacter, count:=1
60      boolReturn = True

'26.04.2016 AL
70      Call session.GetWorkingTcDocument.ManagedTCSignaturesContainer.RemoveSignature(idx)
'ENDE 26.04.2016 AL

80      session.GetWorkingTcDocument.ManagedTCSignaturesContainer.UpdateSignaturesList
90    End If

ExitProc:
100   Set session = Nothing
110   DeleteTCSign = boolReturn
120   Exit Function

RaiseErrorHandler:
130   Set session = Nothing
140   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::DeleteTCSign" & " in Zeile:" & Erl & vbCrLf, Err.Description
150   Resume ExitProc
End Function

Public Function GetMissingSignUpsValue(boolMandantory As Boolean) As Integer

5   On Error GoTo RaiseErrorHandler
    Dim intReturnedCount As Integer
    Dim idx As Integer
    Dim tcDoc As TC_Document
    Dim tmpSignNames() As SignatureNames
    Dim session As TC_Session

10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  intReturnedCount = 0

20  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::GetMissingSignUpsValue: Start mit Mussfeld = " & _
                                                           boolMandantory, session)

25  Set tcDoc = session.GetWorkingTcDocument

30  Call tcDoc.ManagedTCSignaturesContainer.UpdateSignaturesList

35  If tcDoc.ManagedTCSignaturesContainer.Counter > 0 Then
40      tmpSignNames = tcDoc.ManagedTCSignaturesContainer.GetSignatureNames

45      For idx = LBound(tmpSignNames) To UBound(tmpSignNames)
50          If InStr(1, tmpSignNames(idx).tc_sign.signField.Code, session.SignDefaultFile) <> 0 Then
55              If boolMandantory Then
60                  If Not tmpSignNames(idx).tc_sign.SignOptional Then intReturnedCount = intReturnedCount + 1
65              Else
70                  If tmpSignNames(idx).tc_sign.SignOptional Then intReturnedCount = intReturnedCount + 1
75              End If
80          End If
85      Next idx
90  End If

95  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler::GetMissingSignUpsValue: Ende mit " & intReturnedCount, session)

ExitProc:
100 Set session = Nothing
105 Set tcDoc = Nothing
110 GetMissingSignUpsValue = intReturnedCount
115 Exit Function

RaiseErrorHandler:
120 Set session = Nothing
125 intReturnedCount = -1
130 Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::GetMissingSignUpsValue" & " in Zeile:" & Erl & vbCrLf, Err.Description
135 Resume ExitProc
End Function

' neue Fassung von der Funktion MissingSignUps --> Zweck: Vereinheitlichung der Dialogbox bei jedem Typ von Druck
' (Papier-, eAkte- und beides); Vernachl|fffd|ssigung bei fehlenden optionalen Unterschriften

Public Function MissingSignUps() As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim cntMandantory As Integer
    Dim boolReturn As Boolean
10  cntMandantory = Me.GetMissingSignUpsValue(True)
15  boolReturn = False
20  If cntMandantory > 0 Then
25      boolReturn = Me.CancelProcess()
30  End If

ExitProc:
35  MissingSignUps = boolReturn
40  Exit Function

RaiseErrorHandler:
45  boolReturn = True
50  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::MissingSignUps" & " in Zeile:" & Erl & vbCrLf, Err.Description
55  Resume ExitProc
End Function


' neue Fassung von der Funktion CancelProcess --> Zweck: Vereinheitlichung der Dialogbox bei jedem Typ von Druck
' (Papier-, eAkte- und beides); Vernachl|fffd|ssigung bei fehlenden optionalen Unterschriften

Public Function CancelProcess() As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim mBoxRet As VbMsgBoxResult
    Dim msgStyle As VbMsgBoxStyle

    Dim strProtText As String
    Dim strMsgBoxText As String

    Dim session As TC_Session
20    Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

30    strProtText = "Ausgabe MessageBox mit dem Text: "

40    strMsgBoxText = "Mindestens 1 notwendige Unterschrift wurde nicht geleistet." & vbCrLf _
                  & "Wollen Sie trotzdem fortfahren?"

50    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(strProtText & strMsgBoxText, session)
60    msgStyle = vbExclamation + vbYesNo

      'folgendes If weil:
      '  Beim SignoTec ST_ALPHA wird vor der Anzeige auf dem ARC-Printer gedruckt.
      '  Deshalb darf hier diese Meldung beim ST_ALPHA nicht kommen, wenn gerade ein 'interner' Druck erfolgt.
      '  Dazu dient die globale Variable mboolDruckIntern, die initial auf False gesetzt ist.
      '    mboolDruckIntern wird nur ge|fffd|ndert
      '      wenn ST_ALPHA gesetzt ist UND
      '      der Button 'Unterschrift' der Form frmTC_SignUpSelection geklickt wird
'70    If session.SignPad <> "ST_ALPHA" Or mboolDruckIntern = False Then '19.04.2016 AL nur das if ist neu
      '24.02.2017 AL nur das if ist neu
70    If (session.SignPad <> "ST_ALPHA" And session.SignPad <> "ST_DELTA") Or mboolDruckIntern = False Then
80      mBoxRet = MsgBox(strMsgBoxText, msgStyle, Me.ParentIkolClientApp.MsgBoxTitle)
90      boolReturn = (mBoxRet = vbNo)

100     If mBoxRet = vbNo Then
110       Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("es wurde 'Nein' gew|fffd|hlt", session)
120     Else
130       Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("es wurde 'Ja' gew|fffd|hlt", session)
140     End If
150   End If '19.04.2016 AL nur das if ist neu

ExitProc:
160   Set session = Nothing
170   CancelProcess = boolReturn
180   Exit Function

RaiseErrorHandler:
190   Set session = Nothing
200   boolReturn = True
210   Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::CancelProcess" & " in Zeile:" & Erl & vbCrLf, Err.Description
220   Resume ExitProc
End Function


Public Sub DeleteSignFile(filename As String)
5   On Error GoTo RaiseErrorHandler

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  If filename <> session.SignDefaultFile Then
20      Call Me.ParentIkolClientApp.FileHandler.DeleteFile(filename, session)
25  End If

ExitProc:
30  Set session = Nothing
35  Exit Sub

RaiseErrorHandler:
40  Set session = Nothing

45  If Err.Number = 5 Then
        ' w|fffd|rde bedeuten "Ung|fffd|ltiger Prozeduraufruf oder ung|fffd|ltiges Argument", hervorgerufen durch Me.ParentIkolClientApp.FileHandler.DeleteFile, weil
        ' die zu l|fffd|schende Datei nicht existiert; wurde in der 5.3.0 auch ignoriert --> ToDo!
50  Else
55      Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::DeleteSignFile" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  End If

65  Resume ExitProc

End Sub

Public Sub DoSignupMsg(style As VbMsgBoxStyle, strSecCaption As String, msgText As String)
5   On Error GoTo RaiseErrorHandler

    Dim objSession As TC_Session
    Dim tcDoc As TC_Document

10  Set objSession = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  If Not (objSession Is Nothing) Then
20      Set tcDoc = objSession.GetWorkingTcDocument
25      If Not (tcDoc Is Nothing) Then
30          tcDoc.Document.Windows(1).Activate
35          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignUpHandler:DoSignupMsg: Unterschriftenmodul (" & strSecCaption & ") - " & msgText, objSession)
40          Call MsgBox(msgText, style, Me.ParentIkolClientApp.Os2Version & " - " & strSecCaption)
45      End If
50  End If

ExitProc:
55  Set objSession = Nothing
60  Set tcDoc = Nothing
65  Exit Sub

RaiseErrorHandler:
70  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::DoSignupMsg" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub

Public Sub CloseSignupHandling()
5   On Error GoTo RaiseErrorHandler

10  If Me.SignUpType = sutMulti Then
15      Me.ParentIkolClientApp.frmSignup.hide

20  ElseIf Me.SignUpType = sutSingle Then
25      Me.ParentIkolClientApp.frmSignup.hide
30  End If

ExitProc:
35  Me.SignUpType = sutNothing
40  Exit Sub

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::CloseSignupHandling" & " in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc
End Sub

Public Function ResetSignupWindow() As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim tcDoc As TC_Document
    Dim boolReturn As Boolean

    Dim session As TC_Session
10  Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession

15  boolReturn = False

20  If Me.SignUpType = sutMulti Or Me.SignUpType = sutSingle Then
25      Set tcDoc = session.GetWorkingTcDocument
30      If Not (tcDoc Is Nothing) Then
35          tcDoc.DestroySignUpWindow (True)
40          boolReturn = Not (tcDoc.CreateSignUpWindow Is Nothing)
45      End If
50  End If

ExitProc:
55  Set session = Nothing
60  ResetSignupWindow = boolReturn
65  Exit Function

RaiseErrorHandler:
70  Set session = Nothing
75  Err.Raise Err.Number, Err.Source & "->" & "TC_SignUpHandler::ResetSignupWindow" & " in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Function
Attribute VB_Name = "TC_Signature"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
' Diese Klasse beschreibt die Textmarken im aktuellen Dokument, die f|fffd|r die
' Eingabe von Unterschriften vorgesehen sind.
'
' Als Eigenschaften sind vorhanden:
' SignBookmark  Verweis auf die Textmarke im aktuellen Dokument, die die Unterschrift aufnimmt
' SignComment   Text, mit dem die Textmarke in der Unterschriftenverwaltung angezeigt wird.
' SignFile      Dateiname und Pfad f|fffd|r das Unterschriftenbild
' SignHigh      H|fffd|he des Bildes f|fffd|r die Unterschrift
' SignWidth     L|fffd|nge des Bildes f|fffd|r die Unterschrift

'


Private mobjParentSignaturesContainer As TC_SignaturesContainer

Private mvarSignBookmark As Bookmark
Private mvarSignField As Field
Private mvarSignComment As String
Private mvarSignFile As String
Private mvarSignHeight As Integer
Private mvarSignWidth As Integer
Private mvarSignOriginScaleHeight As Integer
Private mvarSignOriginScaleWidth As Integer
Private mvarSignOptional As Boolean

Private Sub Class_Initialize()
5   Set mvarSignBookmark = Nothing
10  Set mvarSignField = Nothing
15  mvarSignComment = vbNullString
20  mvarSignFile = vbNullString
25  mvarSignHeight = 0
30  mvarSignWidth = 0
35  mvarSignOriginScaleHeight = 1
40  mvarSignOriginScaleWidth = 1
45  mvarSignOptional = False
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub


Public Sub CleanUp()

5   Set mvarSignBookmark = Nothing
10  Set mvarSignField = Nothing

15  If Not mobjParentSignaturesContainer Is Nothing Then
20      Set mobjParentSignaturesContainer = Nothing
25  End If
End Sub


Public Property Get ParentSignaturesContainer() As TC_SignaturesContainer
5   On Error GoTo RaiseErrorHandler
10  Set ParentSignaturesContainer = mobjParentSignaturesContainer
ExitProc:
15  Exit Property

RaiseErrorHandler:
20  Err.Raise Err.Number, Err.Source & "->" & "TC_Signature::ParentSignaturesContainer in Zeile:" & Erl & vbCrLf, Err.Description
25  Resume ExitProc
End Property

Public Property Set ParentSignaturesContainer(objParentSignaturesContainer As TC_SignaturesContainer)
5   If mobjParentSignaturesContainer Is Nothing Then
10      Set mobjParentSignaturesContainer = objParentSignaturesContainer
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_Signature.ParentSignaturesContainer", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property


Public Property Get SignBookmark() As Bookmark
5   Set SignBookmark = mvarSignBookmark
End Property

Public Property Let SignBookmark(ByVal vSignBookmark As Bookmark)
5   Set mvarSignBookmark = vSignBookmark
End Property

Public Property Get signField() As Field
5   Set signField = mvarSignField
End Property

Public Property Let signField(ByVal vSignField As Field)
5   Set mvarSignField = vSignField
End Property

Public Property Get SignComment() As String
5   SignComment = mvarSignComment
End Property

Public Property Let SignComment(ByVal vSignComment As String)
5   mvarSignComment = vSignComment
End Property

Public Property Get SignFile() As String
5   SignFile = mvarSignFile
End Property

Public Property Let SignFile(ByVal vSignFile As String)
5   mvarSignFile = vSignFile
End Property

Public Property Let SignHeight(ByVal vSignHeight As Integer)
5   mvarSignHeight = vSignHeight
End Property

Public Property Get SignHeight() As Integer
5   SignHeight = mvarSignHeight
End Property

Public Property Let SignWidth(ByVal vSignWidth As Integer)
5   mvarSignWidth = vSignWidth
End Property

Public Property Get SignWidth() As Integer
5   SignWidth = mvarSignWidth
End Property

Public Property Let SignOriginScaleHeight(ByVal vSignOriginScaleHeight As Integer)
5   mvarSignOriginScaleHeight = vSignOriginScaleHeight
End Property

Public Property Get SignOriginScaleHeight() As Integer
5   SignOriginScaleHeight = mvarSignOriginScaleHeight
End Property

Public Property Let SignOriginScaleWidth(ByVal vSignOriginScaleWidth As Integer)
5   mvarSignOriginScaleWidth = vSignOriginScaleWidth
End Property

Public Property Get SignOriginScaleWidth() As Integer
5   SignOriginScaleWidth = mvarSignOriginScaleWidth
End Property

Public Property Get SignOptional() As Boolean
5   SignOptional = mvarSignOptional
End Property

Public Property Let SignOptional(ByVal vSignOptional As Boolean)
5   mvarSignOptional = vSignOptional
End Property

Public Function SignOptionalToStr() As String
5   If Not mvarSignOptional Then
10      SignOptionalToStr = "Pflichtfeld"
15  Else
20      SignOptionalToStr = "Kannfeld"
25  End If
End Function
Attribute VB_Name = "TC_SignaturesContainer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mvarCounter As Integer                        ' Anzahl der verwalteten Unterschriften
Private mcolManagedSignatures As Collection           ' Collection mit Add und Remove _
                                                      Sammlung der verwalteten Unterschriften
Private mobjParentTcDocument As TC_Document

Public Property Get Counter() As Integer
5   Counter = mvarCounter
End Property

Public Property Get ParentTcDocument() As TC_Document
5   Set ParentTcDocument = mobjParentTcDocument
End Property

Public Property Set ParentTcDocument(objParentDoc As TC_Document)
5   If mobjParentTcDocument Is Nothing Then
10      Set mobjParentTcDocument = objParentDoc
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_SignaturesContainer.ParentTcDocument", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()

    Dim objSign As TC_Signature
    Dim idx As Integer

5   For idx = 1 To mvarCounter
10      mcolManagedSignatures.Remove (1)
15  Next idx

20  Set objSign = Nothing

25  If Not mcolManagedSignatures Is Nothing Then
30      Set mcolManagedSignatures = Nothing
35  End If

40  If Not mobjParentTcDocument Is Nothing Then
45      Set mobjParentTcDocument = Nothing
50  End If

End Sub

Public Property Get ManagedSignaturesCollection() As Collection
5   Set ManagedSignaturesCollection = mcolManagedSignatures
End Property

Private Sub Class_Initialize()
5   Set mcolManagedSignatures = New Collection
End Sub

Public Function AddSignature(objSignature As TC_Signature) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean

10  With Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler

15      If Not IsSignatureInCollection(objSignature) Then
20          mvarCounter = mvarCounter + 1
25          Set objSignature.ParentSignaturesContainer = Me
30          mcolManagedSignatures.Add Item:=objSignature

35          Call .M_Protokoll("AddSignature: aktuelle UnterschriftenAnzahl = " & mvarCounter, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
40          Call .M_Protokoll("AddSignature - Add Signature mit:", Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
45          Call .M_Protokoll("             - Kommentar:           " & objSignature.SignComment, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
50          Call .M_Protokoll("             - Feldtext:            " & objSignature.signField.Code, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
55          Call .M_Protokoll("             - Textmarke:           " & objSignature.SignBookmark.name, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
60          Call .M_Protokoll("             - Unterschriftenart:   " & objSignature.SignOptionalToStr, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
65          Call .M_Protokoll("             - H|fffd|he des Bildes:     " & objSignature.SignHeight, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
70          Call .M_Protokoll("             - L|fffd|nge des Bildes:    " & objSignature.SignWidth, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
75          Call .M_Protokoll("             - Skalierung H|fffd|he:     " & objSignature.SignOriginScaleHeight, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
80          Call .M_Protokoll("             - Skalierung L|fffd|nge:    " & objSignature.SignOriginScaleWidth, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
85          boolReturn = True
90      Else
95          boolReturn = False
100     End If
105 End With

ExitProc:
110 AddSignature = boolReturn
115 Exit Function

RaiseErrorHandler:
120 boolReturn = False
125 Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::AddSignature" & " in Zeile:" & Erl & vbCrLf, Err.Description
130 Resume ExitProc
End Function

Public Sub Obsolete_Clear()
    Dim idx As Integer

5   For idx = mvarCounter To 1 Step -1
10      mcolManagedSignatures.Remove (idx)
15      mvarCounter = mvarCounter - 1
20  Next idx

25  mobjParentTcDocument.ResetSignID
End Sub

Public Function GetSignatureNames() As SignatureNames()
5   On Error GoTo RaiseErrorHandler

    Dim allSignatures() As SignatureNames
    Dim tmpSign As TC_Signature
    Dim idx As Integer

10  Call Me.UpdateSignaturesList

15  If mvarCounter > 0 Then
20      ReDim allSignatures(mvarCounter - 1)
25      idx = 0

30      For Each tmpSign In mcolManagedSignatures
35          allSignatures(idx).realName = tmpSign.SignBookmark
40          allSignatures(idx).showedName = tmpSign.SignComment
45          Set allSignatures(idx).tc_sign = tmpSign
50          idx = idx + 1
55      Next tmpSign

60  End If

ExitProc:
65  Set tmpSign = Nothing
70  GetSignatureNames = allSignatures
75  Exit Function

RaiseErrorHandler:
80  Set tmpSign = Nothing
85  Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::GetSignatureNames" & " in Zeile:" & Erl & vbCrLf, Err.Description
90  Resume ExitProc
End Function

Public Sub UpdateSignaturesListFromStory(storyRange As Word.Range)
5   On Error GoTo RaiseErrorHandler

    Dim objSignature As TC_Signature
    Dim objRange As Range
    Dim objField As Field
    Dim objDocBookmarks As Bookmark
    Dim strTmpText As String
    Dim strNewCodeText As String
    Dim boolResult As Boolean

10  For Each objDocBookmarks In storyRange.Bookmarks
15      strTmpText = objDocBookmarks.name
20      If UCase(Mid(strTmpText, 1, 5)) = "TCSK_" Or _
           UCase(Mid(strTmpText, 1, 5)) = "TCSM_" Then
25          Set objRange = objDocBookmarks.Range
30          For Each objField In objDocBookmarks.Range.Fields
35              If objField.Type = wdFieldIncludePicture Then
40                  strTmpText = Mid(strTmpText, InStr(6, strTmpText, "_") + 1)
45                  strTmpText = Replace(strTmpText, "_", " ")

50                  Set objSignature = New TC_Signature
55                  With objSignature
60                      .SignBookmark = objDocBookmarks
65                      .SignComment = strTmpText

70                      .SignWidth = objRange.InlineShapes(1).width
75                      .SignHeight = objRange.InlineShapes(1).height
                        
                        '18.09.2014 AL
                        'hier kommt gelegentlich Fehler - warum auch immer
                        On Error GoTo ScaleError
80                      .SignOriginScaleHeight = objRange.InlineShapes(1).ScaleHeight
85                      .SignOriginScaleWidth = objRange.InlineShapes(1).ScaleWidth
Weiter:
                        On Error GoTo RaiseErrorHandler

90                      .signField = objField
95                      .SignOptional = (Mid(objDocBookmarks.name, 4, 1) = "K")
100                 End With

105                 If Me.AddSignature(objSignature) Then
110                     If InStr(1, UCase(objField.Code.text), gstrTC_OS_DEFAULT_SIGN_IMAGE_FILE) > 0 Then
115                         strNewCodeText = Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.SignUpHandler.ChangeSignupFieldcode(objField.Code.text, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.SignDefaultFile)
120                         objSignature.SignFile = Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.SignDefaultFile
125                         objField.Code.text = strNewCodeText
130                         boolResult = objField.Update
135                     End If
140                 End If

145             End If
150         Next objField
155     End If
160 Next objDocBookmarks

ExitProc:
165 Set objSignature = Nothing
170 Set objRange = Nothing
175 Set objField = Nothing
180 Set objDocBookmarks = Nothing
185 Exit Sub

'18.09.2014 AL
ScaleError:
objSignature.SignOriginScaleHeight = 100
objSignature.SignOriginScaleWidth = 100
Resume Weiter

RaiseErrorHandler:
190 Set objSignature = Nothing
195 Set objRange = Nothing
200 Set objField = Nothing
205 Set objDocBookmarks = Nothing
210 Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::UpdateSignaturesListFromStory" & " in Zeile:" & Erl & vbCrLf, Err.Description
215 Resume ExitProc

End Sub

Public Sub UpdateSignaturesList()
5   On Error GoTo RaiseErrorHandler

    Dim storyRange As Word.Range
    Dim saveSelection As Word.Range
    Dim objTcSignature As TC_Signature
    Dim protLine As String
    Dim errStp As Integer
10  Set saveSelection = Selection.Range

15  Call Me.RemoveDestroyedSignatures

20  For Each storyRange In mobjParentTcDocument.Document.StoryRanges
25      Call Me.UpdateSignaturesListFromStory(storyRange)
30      While Not (storyRange.NextStoryRange Is Nothing)
35          Set storyRange = storyRange.NextStoryRange
40          Call Me.UpdateSignaturesListFromStory(storyRange)
45      Wend
50  Next storyRange

55  If mcolManagedSignatures.count > 0 Then
60      Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("Liste der verwalteten Unterschriften", Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
65      For Each objTcSignature In mcolManagedSignatures
70          protLine = "        " & objTcSignature.SignBookmark.name & " - " & Chr(34) & _
                       objTcSignature.SignComment & Chr(34) & "(H:" & _
                       objTcSignature.SignHeight & ", L:" & _
                       objTcSignature.SignWidth & " " & _
                       objTcSignature.SignOptionalToStr() & ")"
75          Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll(protLine, Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
80      Next objTcSignature
85  Else
90      Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("UpdateSignaturesList - Keine Unterschriftenfelder vorhanden", Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
95  End If

100 saveSelection.Select

ExitProc:
105 Set storyRange = Nothing
110 Set saveSelection = Nothing
115 Set objTcSignature = Nothing
120 Exit Sub

RaiseErrorHandler:
125 Set storyRange = Nothing
130 Set saveSelection = Nothing
135 Set objTcSignature = Nothing
140 Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::UpdateSignaturesList" & " in Zeile:" & Erl & vbCrLf, Err.Description
145 Resume ExitProc
End Sub

Public Sub RemoveDestroyedSignatures()
5   On Error GoTo RaiseErrorHandler

    Dim objTcSignature As TC_Signature
    Dim strDelFileName As String
    Dim idx As Integer

10  If mvarCounter > 0 Then
15      For idx = mvarCounter To 1 Step -1
20          Set objTcSignature = mcolManagedSignatures(idx)
25          If Not Me.SignatureExists(objTcSignature) Then
30              strDelFileName = objTcSignature.SignFile
35              Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                     "TC_SignaturesContainer::RemoveDestroyedSignatures: L|fffd|schen von '" & strDelFileName & "'", Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)

40              Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.SignUpHandler.DeleteSignFile(strDelFileName)
45              mcolManagedSignatures.Remove (idx)
50              mvarCounter = mvarCounter - 1
55          End If
60      Next idx
65  End If

ExitProc:
70  Set objTcSignature = Nothing
75  Exit Sub

RaiseErrorHandler:
80  Set objTcSignature = Nothing
85  Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::RemoveDestroyedSignatures" & " in Zeile:" & Erl & vbCrLf, Err.Description
90  Resume ExitProc
End Sub

'26.04.2016 AL
Public Sub RemoveSignature(idx As Integer)
10  If idx > 0 And idx <= mvarCounter Then
20    mcolManagedSignatures.Remove (idx)
30    mvarCounter = mvarCounter - 1
40  End If
End Sub


Public Sub DeleteTempSignFiles(session As TC_Session)
5   On Error GoTo RaiseErrorHandler

    Dim tmpSign As TC_Signature
    Dim filename As String

10  For Each tmpSign In mcolManagedSignatures
15      filename = tmpSign.SignFile
20      If InStr(1, filename, gstrTC_OS_DEFAULT_SIGN_IMAGE_FILE) = 0 Then
25          filename = Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.NormalizedFileNameWithSeparator(filename)
30          If Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.FileHandler.FileExist(filename) Then
35              Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.FileHandler.DeleteFile(filename, session)
40          End If
45      End If
50  Next tmpSign

ExitProc:
55  Set tmpSign = Nothing
60  Exit Sub

RaiseErrorHandler:
65  Set tmpSign = Nothing
70  Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::DeleteTempSignFiles" & " in Zeile:" & Erl & vbCrLf, Err.Description
75  Resume ExitProc
End Sub

Public Function SignatureExists(objTcSignature As TC_Signature) As Boolean
10    On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim stepCnt As Integer
20    boolReturn = True
30    stepCnt = 1
40    If objTcSignature.signField Is Nothing Then
50      boolReturn = False
60    Else
70      stepCnt = 2
80      If objTcSignature.signField.Code = vbNullString Then
90          boolReturn = False
100     Else
110         stepCnt = 3
120         If objTcSignature.SignBookmark Is Nothing Then
130             boolReturn = False
140         Else
150             stepCnt = 4
160             If objTcSignature.SignBookmark.name = vbNullString Then
170                 boolReturn = False
180             End If
190         End If
200     End If
210   End If

fertsch:
220   If Not boolReturn Then
230     Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll("TC_SignaturesContainer:SignatureExistsSignatureExists: Das Objekt(" & objTcSignature.SignBookmark & ") wurde gel|fffd|scht", _
                                                                                                                                                        Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
240   End If

ExitProc:
250   SignatureExists = boolReturn
260   Exit Function

RaiseErrorHandler:
270   boolReturn = False

280   If Err.Number = 5891 Then
290     Call Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll _
             ("Test, ob die Unterschrift noch existiert schl|fffd|gt fehl bei Test-Nr. [" & stepCnt & "]", _
              Me.ParentTcDocument.ParentManagedTCDocumentsContainer.ParentSession)
300   Else
310     Err.Raise Err.Number, Err.Source & "->" & _
                              "TC_SignaturesContainer::SignatureExists" & " in Zeile:" & Erl & vbCrLf, Err.Description
320   End If

330   Resume ExitProc
End Function

Public Function IsSignatureInCollection(tcsign As TC_Signature) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean
    Dim tmpSign As TC_Signature

10  boolReturn = False

15  For Each tmpSign In mcolManagedSignatures
20      If tmpSign.SignBookmark = tcsign.SignBookmark Then
25          boolReturn = True
30          GoTo ExitProc
35      End If
40  Next tmpSign

ExitProc:
45  IsSignatureInCollection = boolReturn
50  Exit Function

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_SignaturesContainer::IsSignatureInCollection" & " in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Function
Attribute VB_Name = "TC_SyntaxDescription"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const boolNOT_OPTIONAL As Boolean = False
Private Const boolOPTIONAL As Boolean = True
Private Const intCOMMANDBAR_BUTTONS_COUNT As Integer = 16

'28.04.2016 AL
Private Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" _
(ByVal lpBuffer As String, ByRef nSize As Long) As Long
'28.04.2016 AL

Private Enum menumButtonId
    Id_btnSave
    Id_btnSaveAs
    Id_btnDelete
    Id_btnPrintSetup
    Id_btnPrint01
    Id_btnPrint02
    Id_btnArcAndPrint01
    Id_btnArcAndPrint02
    Id_btnOnlyArc
    Id_btn1
    Id_btn2
    Id_btn3
    Id_btnUErf
    Id_btnUDel
    Id_btnClose
    Id_btnInfo
End Enum

Private mcolCommandSyntaxCollection As Collection
Private mcolCommandControlsOnTheBar As CommandControls
Private mobjParentIkolClientApp As TC_IkolClientApp

'28.04.2016 AL
Private Function ComputerName() As String
    Dim stBuff As String * 255, lAPIResult As Long
    Dim lBuffLen As Long
    
    lBuffLen = 255
    lAPIResult = GetComputerName(stBuff, lBuffLen)
    If lBuffLen > 0 Then ComputerName = Left(stBuff, lBuffLen)

End Function
'28.04.2016 AL

'28.04.2016 AL
Public Function extractSignPadFromConfigIni(session As TC_Session) As String
  Dim arrZeilen
  Dim confIni
  Dim FSO
  Dim z As Integer
  Dim tmp As Variant
  Dim i As Integer
  Dim anzZeilen As Integer
  Dim strComplete As String
  Dim sectionFound As Boolean
  Dim compName As String
  Dim strSignPad As String

  compName = ComputerName
  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("extractSignPadFromConfigIni: " & _
       "Computername: " & compName, session)
  
  strSignPad = ""

  'Textdatei auslesen
  Set FSO = CreateObject("Scripting.FilesystemObject")
  If FSO.FileExists(session.IniFile) = False Then
    MsgBox "extractSignPadFromConfigIni:" & vbNewLine & "config.ini nicht gefunden!" & vbNewLine & _
           "(" & session.IniFile & ")", vbCritical
    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("extractSignPadFromConfigIni: " & _
       "config.ini nicht gefunden! (" & session.IniFile & ")", session)
  End If
  Set confIni = FSO.OpenTextFile(session.IniFile)
  strComplete = confIni.ReadAll
  confIni.Close
  
  arrZeilen = Split(strComplete, vbCrLf) 'Nach Zeilen splitten
  
  sectionFound = False
  anzZeilen = UBound(arrZeilen)
  For z = 0 To anzZeilen                 'f|fffd|r alle Zeilen
    'Section [SPECIAL DEVICES] suchen
    If InStr(1, arrZeilen(z), "[SPECIAL DEVICES]") = 1 Then
      sectionFound = True
      If z < anzZeilen Then z = z + 1    ' n|fffd|chste Zeile
    End If
    
    If sectionFound Then                 'nur in Section [SPECIAL DEVICES] suchen
      'andere Section hat begonnen --> Suche komplett abbrechen
      If InStr(1, arrZeilen(z), "[") = 1 Then
        Exit For 'Abbruch
      End If
      
      'Zeile beginnt mit Computernamen und danach folgt "=" oder " ="
      'z.B.: ALI-PC=ST_ALPHA,USB
      '      --> gesucht ist hier ST_ALPHA
      If InStr(1, arrZeilen(z), compName & "=") = 1 Or _
         InStr(1, arrZeilen(z), compName & " =") = 1 Then
        tmp = Split(arrZeilen(z), "=")   'nach "=" splitten
        tmp = tmp(1)                     'der rechte Teil
        If Len(tmp) > 0 Then             'nur wenn rechter Teil vorhanden ist
          tmp = Split(tmp, ",")          'rechten Teil nach "," splitten
          strSignPad = Trim(tmp(0))      'der linke Teil
        End If
        Exit For 'Abbruch
      End If
      
    End If
  Next
  
  If strSignPad = "" Then
    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("extractSignPadFromConfigIni: " & _
       "kein passender Eintrag in der Section [SPECIAL DEVICES] gefunden! ", session)
  End If
  
  extractSignPadFromConfigIni = strSignPad
End Function
'ENDE 28.04.2016 AL




Private Sub Class_Initialize()
5   Set mcolCommandSyntaxCollection = New Collection
End Sub


Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_SyntaxDescription.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Sub CleanUp()
5   If Not mcolCommandSyntaxCollection Is Nothing Then
10      Set mcolCommandSyntaxCollection = Nothing
15  End If

20  If Not mobjParentIkolClientApp Is Nothing Then
25      Set mobjParentIkolClientApp = Nothing
30  End If

End Sub



'---------------------------------------------------------------------------------------
' Prozedur : SetButtonDefinition
' Autor    : Todor Vachkov
' Datum    : 27.06.2013
' Zweck    : zu der Button-Leiste wird ein Button hinzugef|fffd|gt
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams:
' Integer       : die ID des Buttons auf der Leiste
' String        : interner Name des Buttons auf der Leiste
' String        : das Makro, das beim Klicken auf dem Button ausgef|fffd|hrt wird
' String        : ein ToolTip zum Button
'---------------------------------------------------------------------------------------
Private Sub SetButtonDefinition(intNumber As Integer, _
                                intControlId As String, _
                                strAction As String, _
                                strToolTip As String)

5   On Error GoTo RaiseErrorHandler

    Dim strObjectNameCommandBarCommands As String
10  strObjectNameCommandBarCommands = "Me.ParentIkolClientApp.CommandBarCommands"

15  With mcolCommandControlsOnTheBar.controls(intNumber)
20      .cntrlID = intControlId
25      .visible = True
30      .enabled = True
35      .action = strObjectNameCommandBarCommands & "." & strAction
40      .toolTip = strToolTip
45  End With

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_SyntaxDescription::SetButtonDefinition in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc
End Sub


Public Function GetCommandBarDefinition(strCmdBarName As String) As CommandControls

5   On Error GoTo RaiseErrorHandler

    Dim strCmdBarDefinitionName As String
    Dim enumButtonId As menumButtonId
    Dim strSetChar As String
    Dim idx As Integer
    Dim strButtonBar As String

    Dim intWordVersion As Integer

    ' wenn der Wert als True ermittelt wird -> muss das Unterschriftenmodul installiert sein; sp|fffd|ter danach pr|fffd|fen
    Dim boolUDelwApp As Boolean
    Dim boolUErfwApp As Boolean

10  If Left(strCmdBarName, 4) = "IKOL" Then
        '          Sv SvAs Del PrSet Pr1 Pr2 APr1 APr2 OArc UErf UDel _1 _2 _3 Cls Inf
15      Select Case strCmdBarName
            Case "IKOL"
20              strCmdBarDefinitionName = "11001111100"
25          Case "IKOL-S1"
30              strCmdBarDefinitionName = "00001000000"
35          Case "IKOL-S2"
40              strCmdBarDefinitionName = "00001000100"
45          Case "IKOL-SP"
50              strCmdBarDefinitionName = "11000000000"
55          Case "IKOL-V1"
60              strCmdBarDefinitionName = "00001111100"
65          Case "IKOL-V2"
70              strCmdBarDefinitionName = "00001100000"
75          Case "IKOL-V3"
80              strCmdBarDefinitionName = "10001000000"
85          Case "IKOL-V4"
90              strCmdBarDefinitionName = "01001100000"
95      End Select
100 Else
105     strCmdBarDefinitionName = strCmdBarName
110 End If

115 strCmdBarDefinitionName = Left(strCmdBarDefinitionName & _
                                   String(intCOMMANDBAR_BUTTONS_COUNT, "0"), intCOMMANDBAR_BUTTONS_COUNT - 2) & _
                                   "11"

120 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Button-Definition der zu installierenden Symbolleiste: " & strCmdBarDefinitionName, Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
125 idx = 1

130 strButtonBar = vbNullString


135 boolUDelwApp = False
140 boolUErfwApp = False

145 With mcolCommandControlsOnTheBar
150     For enumButtonId = Id_btnSave To Id_btnInfo
155         strSetChar = Mid(strCmdBarDefinitionName, idx, 1)

160         If strSetChar = "0" Then
                ' den Button ausblenden, kein Makro zuweisen
165             .controls(enumButtonId).visible = False
170         Else

175             If strButtonBar <> vbNullString Then
180                 strButtonBar = strButtonBar & ", "
185             End If
190             strButtonBar = strButtonBar & Chr(34) & _
                               Mid(.controls(enumButtonId).cntrlID, 5, Len(.controls(enumButtonId).cntrlID)) & _
                               Chr(34)

195         End If
200         If strSetChar <> "1" Then
                ' dem Button ein Makro entsprechend des Indizies strSetChar zuweisen, das jedenfalls von dem Standardmakro abweicht
205             .controls(enumButtonId).action = .controls(enumButtonId).action & strSetChar
210         End If

            ' hier schonmal |fffd|berpr|fffd|fen , ob das Unterschriftenmodul als Voraussetzung gesetzt wird
215         If enumButtonId = Id_btnUDel And strSetChar = "1" Then
220             boolUDelwApp = True
225         End If
230         If enumButtonId = Id_btnUErf And strSetChar = "1" Then
235             boolUErfwApp = True
240         End If

            ' hier nach der Aktivierung von den eAkte-Buttons pr|fffd|fen, um vielleicht auch mit
            ' angezeigter Symbolleiste das Verfahren freigeben zu k|fffd|nnen
245         If ((enumButtonId = Id_btnArcAndPrint01 And strSetChar = "1") _
                Or (enumButtonId = Id_btnArcAndPrint02 And strSetChar = "1") _
                Or (enumButtonId = Id_btnOnlyArc And strSetChar = "1")) _
                And (Me.ParentIkolClientApp.AtLeastOneEakteButton = False) Then
250             Me.ParentIkolClientApp.AtLeastOneEakteButton = True
255         End If

260         idx = idx + 1
265     Next enumButtonId

        ' laut Symbolleiste-Definition soll mit dem Unterschriftenmodul gearbeitet haben
270     If boolUDelwApp Or boolUErfwApp Then
275         intWordVersion = CInt(Mid(Application.Version, 1, 2))
            ' das Unterschriftenmodul wird erst ab MS Word 2003 unterst|fffd|tzt
280         If intWordVersion >= 11 Then
285             If Me.ParentIkolClientApp.SignUpHandler.LoadSignUpAppHandler() <> tcrOK Then
290                 If boolUDelwApp Then .controls(Id_btnUDel).enabled = False
295                 If boolUErfwApp Then .controls(Id_btnUErf).enabled = False
300             End If
305         Else
310             Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Das Unterschriftenmodul wird erst ab MS Word 2003 unterst|fffd|tzt!", Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

315             Err.Raise glongCUSTOM_ERR_SIGN_WORD_VERSION, _
                          "TC_SyntaxDescription::GetCommandBarDefinition", _
                          "Das Unterschriftenmodul ist mit dieser MS Word-Version inkompatibel." & vbCrLf & _
                          "Erforderlich ist mind. MS Word 2003"


320         End If
325     End If
330 End With

335 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Mit den Buttons: " & strButtonBar, Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

ExitProc:
340 GetCommandBarDefinition = mcolCommandControlsOnTheBar
345 Exit Function

RaiseErrorHandler:
350 Err.Raise Err.Number, Err.Source & "->" & "TC_SyntaxDescription::GetCommandBarDefinition" & " in Zeile:" & Erl & vbCrLf, Err.Description
355 Resume ExitProc
End Function


Public Sub WriteSyntaxDescription(file As TextStream)
    Dim objCurrentWeInstruction As TC_WEInstruction
    Dim strWeInstructionsDescription As String

5   Call file.WriteLine("Syntax-Beschreibung Office-Schnittstelle 2.0 Version " & mobjParentIkolClientApp.Os2Version)
10  Call file.WriteLine(vbNullString)
15  Call file.WriteLine("Erl|fffd|uterung der Beschreibung:")
20  Call file.WriteLine("=============================")
25  Call file.WriteLine("   Parameter die in eckigen Klammern [] angegeben werden sind optional.")
30  Call file.WriteLine("   Bei der Erl|fffd|uterung der Parameter wird nach dem Parameternamen in Klammern der Parametertyp angegeben.")
35  Call file.WriteLine("   D|fffd|rfen Parameter nur Werte aus einer Liste enthalten, dann ist diese Liste in geschweiften Klammern angegeben")
40  Call file.WriteLine("   Bsp.: {'AN' | 'AUS'}")
45  Call file.WriteLine(vbNullString)
50  Call file.WriteLine("Implementierte Befehle:")
55  Call file.WriteLine("=======================")
60  Call file.WriteLine(vbNullString)

65  For Each objCurrentWeInstruction In mcolCommandSyntaxCollection
70      strWeInstructionsDescription = objCurrentWeInstruction.GetCommandoDescriptonAsText
75      Call file.WriteLine(strWeInstructionsDescription)
80  Next objCurrentWeInstruction

End Sub

Public Function FindSyntaxDescription(makroName As String) As TC_WEInstruction
    Dim objCurrentWeInstruction As TC_WEInstruction
    Dim objReturnWeInstruction As TC_WEInstruction

5   On Error GoTo RaiseErrorHandler

10  For Each objCurrentWeInstruction In mcolCommandSyntaxCollection
15      If objCurrentWeInstruction.makroName = makroName Then
20          Set objReturnWeInstruction = objCurrentWeInstruction
25          Exit For
30      End If
35  Next objCurrentWeInstruction

ExitProc:
40  Set FindSyntaxDescription = objReturnWeInstruction
45  Set objCurrentWeInstruction = Nothing
50  Set objReturnWeInstruction = Nothing
55  Exit Function

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_SyntaxDescription::FindSyntaxDescription in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc

End Function

Public Function GetParameterValueset(makroName As String, paramNumber As Integer) As Collection
    Dim objCurrentWeInstruction As TC_WEInstruction

5   For Each objCurrentWeInstruction In mcolCommandSyntaxCollection
10      With objCurrentWeInstruction
15          If .makroName = makroName Then
20              Set GetParameterValueset = objCurrentWeInstruction.GetParameter(paramNumber).ParameterConstants
25              Exit Function
30          End If
35      End With
40  Next objCurrentWeInstruction
End Function

'---------------------------------------------------------------------------------------
' Prozedur : DefineOldMakroDescription
' Autor    : Todor Vachkov
' Datum    : 27.06.2013
' Zweck    : hier sind alle Befehle, die die OSS2.0 kennt, festgehalten
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
'
' |fffd|bergabeparams:
' String        : das Verzeichnis, wo die TC_OITEMPLATE.DOT liegt
'---------------------------------------------------------------------------------------
Public Sub DefineOldMakroDescription(currentWorkDir As String)

    'es werden s|fffd|mtliche der OSS2.0 bekannte Buttons registriert
5   On Error GoTo RaiseErrorHandler

10  SetButtonDefinition Id_btnSave, "btn_Save", "SaveActiveDocument", "Dokument Speichern"
15  SetButtonDefinition Id_btnSaveAs, "btn_SaveAs", "SaveActiveDocumentAs", "Kopie des Dokuments speichern"
20  SetButtonDefinition Id_btnDelete, "btn_Delete", "DeleteActiveDocument", "L|fffd|schen des Dokuments auf dem Server"
25  SetButtonDefinition Id_btnPrintSetup, "btn_PrintSetup", "PrintWithSetup", "Drucken im Dialog"
30  SetButtonDefinition Id_btnPrint01, "btn_Print01", "PrintActiveDocument", "1 x Drucken"
35  SetButtonDefinition Id_btnPrint02, "btn_Print02", "PrintActiveDocumentTwice", "2 x Drucken"
40  SetButtonDefinition Id_btnArcAndPrint01, "btn_ArcAndPrint01", "PrintAndArcActiveDocument", "1 x Drucken und in der eAKTE ablegen"
45  SetButtonDefinition Id_btnArcAndPrint02, "btn_ArcAndPrint02", "PrintAndArcActiveDocumentTwice", "2 x Drucken und in der eAKTE ablegen"
50  SetButtonDefinition Id_btnOnlyArc, "btn_OnlyArc", "ArcActiveDocument", "in der eAKTE ablegen"
55  SetButtonDefinition Id_btn1, "btn_1", "CustomizeActionA", "Benutzerdefinierte Aktion 1"
60  SetButtonDefinition Id_btn2, "btn_2", "CustomizeActionB", "Benutzerdefinierte Aktion 2"
65  SetButtonDefinition Id_btn3, "btn_3", "CustomizeActionC", "Benutzerdefinierte Aktion 3"
70  SetButtonDefinition Id_btnUErf, "btn_UErf", "GetSignature", "Unterschrift vom Pad erfassen"
75  SetButtonDefinition Id_btnUDel, "btn_UDel", "DeleteSignature", "Unterschrift l|fffd|schen"
80  SetButtonDefinition Id_btnClose, "btn_IKOL", "CloseActiveDocument", "aktiviert IKOL"
85  SetButtonDefinition Id_btnInfo, "btn_Info", "TCInfo", "Info"

    'es werden s|fffd|mtliche der OSS2.0 bekannte WE-Befehle und die dazugeh|fffd|renden Makros registriert
90  mcolCommandSyntaxCollection.Add AddMakro_ANSICHT()
95  mcolCommandSyntaxCollection.Add AddMakro_ANWENDUNG_AKTIVIEREN()
100 mcolCommandSyntaxCollection.Add AddMakro_ANWENDUNG_D_AKTIVIEREN()
105 mcolCommandSyntaxCollection.Add AddMakro_ANWENDUNG_VERSTECKEN_SYS()
110 mcolCommandSyntaxCollection.Add AddMakro_ANZEIGE_AKTUALISIEREN_AN()
115 mcolCommandSyntaxCollection.Add AddMakro_ANZEIGE_AKTUALISIEREN_AUS()
120 mcolCommandSyntaxCollection.Add AddMakro_ARCHIVDRUCK()
125 mcolCommandSyntaxCollection.Add AddMakro_ARCPRINTER()
130 mcolCommandSyntaxCollection.Add AddMakro_BEENDE()
135 mcolCommandSyntaxCollection.Add AddMakro_DRUCKE()
140 mcolCommandSyntaxCollection.Add AddMakro_ENDE()
145 mcolCommandSyntaxCollection.Add AddMakro_ERSETZE()
150 mcolCommandSyntaxCollection.Add AddMakro_FUEHRE_AUS()
155 mcolCommandSyntaxCollection.Add AddMakro_INSERT_E()
160 mcolCommandSyntaxCollection.Add AddMakro_INSERT_TEXT_E()
165 mcolCommandSyntaxCollection.Add AddMakro_KOMMENTAR()
170 mcolCommandSyntaxCollection.Add AddMakro_LADE()
175 mcolCommandSyntaxCollection.Add AddMakro_MELDUNG()
180 mcolCommandSyntaxCollection.Add AddMakro_MISCHE()
185 mcolCommandSyntaxCollection.Add AddMakro_OEFFNE()
190 mcolCommandSyntaxCollection.Add AddMakro_SCHLIESSE()
195 mcolCommandSyntaxCollection.Add AddMakro_SPEICHERN_ALS()
200 mcolCommandSyntaxCollection.Add AddMakro_SETZE_PARAMETER()
205 mcolCommandSyntaxCollection.Add AddMakro_SYMBOLLEISTE()
210 mcolCommandSyntaxCollection.Add AddMakro_SYMBOLLEISTE_RIBBON()
215 mcolCommandSyntaxCollection.Add AddMakro_SYNTAX_BESCHREIBUNG(currentWorkDir)
220 mcolCommandSyntaxCollection.Add AddMakro_UEBERGABE_SYSTEM()
225 mcolCommandSyntaxCollection.Add AddMakro_UMW_FORMULAR_SERIENBRIEF()
230 mcolCommandSyntaxCollection.Add AddMakro_VERBINDE()

ExitProc:
235 Exit Sub

RaiseErrorHandler:
240 Err.Raise Err.Number, Err.Source & "->" & "TC_SyntaxDescription::DefineOldMakroDescription in Zeile:" & Erl & vbCrLf, Err.Description
245 Resume ExitProc

End Sub

Private Function DefineParameter(parmName As String, _
                                 ParmType As EParameterType, _
                                 ParmText As String, _
                                 defaultVal As String, _
                                 optionalParm As Boolean) As TC_ParameterDescription
    Dim parameter As TC_ParameterDescription
5   Set parameter = New TC_ParameterDescription

10  With parameter
15      .ParameterName = parmName
20      .parameterType = ParmType
25      .ParameterText = ParmText
30      .OptionalParameter = optionalParm
35      .defaultValue = defaultVal
40  End With

45  Set DefineParameter = parameter
50  Set parameter = Nothing
End Function

Private Function DefineParameterWithValueSet(parmName As String, _
                                             ParmType As EParameterType, _
                                             ParmText As String, _
                                             optionalParm As Boolean, _
                                             defaultVal As String, _
                                             valueSet As Collection) As TC_ParameterDescription
    Dim parameter As TC_ParameterDescription

5   Set parameter = DefineParameter(parmName, ParmType, ParmText, defaultVal, optionalParm)
10  parameter.ParameterConstants = valueSet
15  Set DefineParameterWithValueSet = parameter
20  Set parameter = Nothing
End Function

Private Function AddMakro_ANSICHT() As TC_WEInstruction
    '  ANSICHT

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ANSICHT"
20      .CommandoText = "zeigt das Dokument an und |fffd|bernimmt f|fffd|r die Anzeige die Steuerung selbst"
25  End With
30  Set AddMakro_ANSICHT = objWeInstruction
35  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ANWENDUNG_AKTIVIEREN() As TC_WEInstruction
    '  ANWENDUNG_AKTIVIEREN  "Anwendungstitel"

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ANWENDUNG_AKTIVIEREN"
20      .CommandoText = "Aktiviert das Fenster mit dem |fffd|bergebenen Anwendungstitel"
25      .AddParameter DefineParameter("Anwendungstitel", _
                                      eptWindowTitle, _
                                      "Fenstertitel der zu aktivierenden Anwendung", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30  End With
35  Set AddMakro_ANWENDUNG_AKTIVIEREN = objWeInstruction
40  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ANWENDUNG_D_AKTIVIEREN() As TC_WEInstruction
    '  ANWENDUNG_D_AKTIVIEREN

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ANWENDUNG_D_AKTIVIEREN"
20      .CommandoText = "Setzt den Fokus auf das zuletzt ge|fffd|ffnete Dokument"
25  End With
30  Set AddMakro_ANWENDUNG_D_AKTIVIEREN = objWeInstruction
35  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ANWENDUNG_VERSTECKEN_SYS() As TC_WEInstruction
    '  ANWENDUNG_VERSTECKEN_SYS

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ANWENDUNG_VERSTECKEN_SYS"
20      .CommandoText = "Versteckt die ge|fffd|ffnete SYSTEM.DOC"
25  End With
30  Set AddMakro_ANWENDUNG_VERSTECKEN_SYS = objWeInstruction
35  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ANZEIGE_AKTUALISIEREN_AN() As TC_WEInstruction
    '  ANZEIGE_AKTUALISIEREN_AN  ["Anwendungstitel"]

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ANZEIGE_AKTUALISIEREN_AN"
20      .CommandoText = "Die durch ANZEIGE_AKTUALISIEREN_AUS tempor|fffd|r ausgeschaltete Anzeige der Bearbeitung " & vbLf & _
                        "wird wieder angeschaltet."
25  End With
30  Set AddMakro_ANZEIGE_AKTUALISIEREN_AN = objWeInstruction
35  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ANZEIGE_AKTUALISIEREN_AUS() As TC_WEInstruction
    '  ANZEIGE_AKTUALISIEREN_AUS  ["Anwendungstitel"]

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ANZEIGE_AKTUALISIEREN_AUS"
20      .CommandoText = "Die Anzeige der Bearbeitung wird tempor|fffd|r ausgeschaltet und sollte durch " & vbLf & _
                        "ANZEIGE_AKTUALISIEREN_AN wieder angeschaltet werden."
25  End With
30  Set AddMakro_ANZEIGE_AKTUALISIEREN_AUS = objWeInstruction
35  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ARCHIVDRUCK() As TC_WEInstruction
    '  ARCHIVDRUCK
    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ARCHIVDRUCK"
20      .CommandoText = "Es erfolgt der Ausdruck des Dokumentes auf dem durch ARCPRINTER festgelegtem Drucker"
25  End With
30  Set AddMakro_ARCHIVDRUCK = objWeInstruction
35  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_ARCPRINTER() As TC_WEInstruction
    '  ARCPRINTER "Archivdrucker"

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ARCPRINTER"
20      .CommandoText = "Mit diesem Befehl wird der zu verwendende Drucker f|fffd|r die eAkte festgelegt"
25      .AddParameter DefineParameter("Druckername", _
                                      eptPrinterName, _
                                      "Name des zu verwendenen Drucker f|fffd|r die eAkte", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30  End With
35  Set AddMakro_ARCPRINTER = objWeInstruction
40  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_BEENDE() As TC_WEInstruction
    '  BEENDE  "Pfad und Name der Protokolldatei

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "BEENDE"
20      .CommandoText = "Mit diesem Befehl wird die Befehlsfolge beendet. Ist im Parameter ein Dateinamen angegeben" & vbLf & _
                        "wird das geschriebene Protokoll in diese Datei geschrieben"
25      .AddParameter DefineParameter("Protokolldatei", _
                                      eptFileName, _
                                      "Pfad und Name der Protokolldatei. Fehlt der Pfad, wir die Protokolldatei " & vbLf & _
                                      "auf dem Client im Arbeitsverzeichnis und auf dem Server im user-Verzeichnis " & vbLf & _
                                      "angelegt", _
                                      vbNullString, _
                                      boolOPTIONAL)
30  End With
35  Set AddMakro_BEENDE = objWeInstruction
40  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_DRUCKE() As TC_WEInstruction
    '  DRUCKE  [Anzahl [ ,{Druckername} [, {Seite von} [, {Seite bis}]]][

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "DRUCKE"
20      .CommandoText = "Druckt die angegebene Anzahl (Standard 1) auf dem Standarddrucker oder " & vbLf & _
                        "dem angegebenen Drucker aus. Als Drucker darf nicht der TIFF-Drucker angegeben" & vbLf & _
                        "werden. Bei nicht vorhandenem Drucker wird eine Druckerauswahlbox angezeigt"
25      .AddParameter DefineParameter("Anzahl", _
                                      eptCardinal, _
                                      "Anzahl der zu druckenden Kopien", _
                                      "1", _
                                      boolOPTIONAL)
30      .AddParameter DefineParameter("Druckername", _
                                      eptPrinterName, _
                                      "Name des Druckers. Fehlt der Drucker wird der Standarddrucker angenommen ", _
                                      vbNullString, _
                                      boolOPTIONAL)
35      .AddParameter DefineParameter("Seite von", _
                                      eptCardinal, _
                                      "von welcher Seit an soll gedruckt werden, Standard: Seite 1 ", _
                                      "1", _
                                      boolOPTIONAL)
40      .AddParameter DefineParameter("Seite bis", _
                                      eptCardinal, _
                                      "bis zu welcher Seite soll gedruckt werden, Standard: letzte Seite ", _
                                      "0", _
                                      boolOPTIONAL)
45      .AddParameter DefineParameter("Drucksteuerung", _
                                      eptCardinal, _
                                      "steuert das Verhalten des Druckens: " & vbLf & _
                                      "gesetztes Bit 0: Warnungen vom Drucker werden unterdr|fffd|ckt," & vbLf & _
                                      "gesetztes Bit 1: keine Feldaktualisierung vor dem Drucken", _
                                      "0", _
                                      boolOPTIONAL)
50  End With
55  Set AddMakro_DRUCKE = objWeInstruction
60  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_ENDE() As TC_WEInstruction
    '  ENDE

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ENDE"
20      .CommandoText = "Zeigt das Ende der WE-Datei und damit der Befehlsfolge an"
25  End With
30  Set AddMakro_ENDE = objWeInstruction
35  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_ERSETZE() As TC_WEInstruction
    '  ERSETZE   ("Suchtext", "Tauschtext")

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "ERSETZE"
20      .CommandoText = "Tauscht im Dokument die Zeichenfolge Suchtext gegen Tauschtext aus." & vbLf & _
                        "Wenn im Tauschtext ein Zeilenwechsel erzeugt werden muss, ist an der entsprechenden" & vbLf & _
                        "Stelle ein '~' zu schreiben, " & vbLf & _
                        "es sind jedoch auch die Zeichen entsprechend der Konventionen f|fffd|r Suchen und Ersetzen in " & vbLf & _
                        "Word m|fffd|glich"
25      .AddParameter DefineParameter("Suchtext", _
                                      eptWordText, _
                                      "der zu suchende Text", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30      .AddParameter DefineParameter("Tauschtext", _
                                      eptWordText, _
                                      "Text, mit dem der gefundene Text ersetzt werden soll", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
35      .AddParameter DefineParameter("ErsetzungsMode", _
                                      eptCardinal, _
                                      "gibt den Modus f|fffd|r das Ersetzen im Dokument an: " & vbLf & _
                                      "gesetztes Bit 0: Ersetzen im normalen Text," & vbLf & _
                                      "gesetztes Bit 1: Ersetzen in Feldfunktionen, " & vbLf & _
                                      "gesetztes Bit 2: Ersetzen in verstecktem Text (zur Zeit nicht implementiert)" & vbLf & _
                                      "gesetztes Bit 3: Verzeichnisnamen. Im Tauschtext vor dem Ersetzen '\' durch '\\' ersetzen" & vbLf & _
                                      "gesetztes Bit 4: Ersetzt den Text im gesamten Dokument, nicht nur im Haupttext", _
                                      "1", _
                                      boolOPTIONAL)

40  End With
45  Set AddMakro_ERSETZE = objWeInstruction
50  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_FUEHRE_AUS() As TC_WEInstruction
    ' FUEHRE_AUS    Kommando par2 par3 ....

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "FUEHRE_AUS"
20      .CommandoText = "Ausf|fffd|hren einer externen Anwendung. Die Parameter werden Komma- oder Leerzeichengetrennt |fffd|bergeben"
25      .AddParameter DefineParameter("Kommando mit Parametern", _
                                      eptFreeParameter, _
                                      "Kommando mit s|fffd|mtlichen Parametern, welches ausgef|fffd|hrt werden soll" & vbLf & _
                                      "Der Text ist wie bei einem Aufruf von der Shell aus zu notieren", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30  End With
35  Set AddMakro_FUEHRE_AUS = objWeInstruction
40  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_INSERT_E() As TC_WEInstruction
    '  INSERT_E    "Dateiname"

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "INSERT_E"
20      .CommandoText = "F|fffd|gt am Ende des aktuellen Dokumentes die angegebe Datei ein"
25      .AddParameter DefineParameter("Dateiname", _
                                      eptFileName, _
                                      "Pfad und Name der Datei, die am Ende des aktuellen Dokumentes eingef|fffd|gt werden soll", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30  End With
35  Set AddMakro_INSERT_E = objWeInstruction
40  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_INSERT_TEXT_E() As TC_WEInstruction
    '  INSERT_TEXT_E    ("Textfolge")

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "INSERT_TEXT_E"
20      .CommandoText = "F|fffd|gt am Ende des aktuellen Dokumentes den Inhalt des Textes 'Textfolge' ein." & vbLf & _
                        "Wenn in der Textfolge ein Zeilenwechsel erzeugt werden muss, ist an der entsprechenden" & vbLf & _
                        "Stelle ein '~' zu schreiben" & vbLf & _
                        "es sind jedoch auch die Zeichen entsprechend der Konventionen f|fffd|r Suchen und Ersetzen in " & vbLf & _
                        "Word m|fffd|glich"
25      .AddParameter DefineParameter("Textfolge", _
                                      eptWordText, _
                                      "der am Ende einzuf|fffd|gende Text", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30  End With
35  Set AddMakro_INSERT_TEXT_E = objWeInstruction
40  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_KOMMENTAR() As TC_WEInstruction
    '  KOMMENTAR   irgend ein Text

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "KOMMENTAR"
20      .CommandoText = "dient zum Kommentieren der Befehlsfolge"
25      .AddParameter DefineParameter("Kommentar-Text", _
                                      eptFreeParameter, _
                                      "ein Text zur Kommentierung der Befehlsfolge", _
                                      vbNullString, _
                                      boolOPTIONAL)
30  End With
35  Set AddMakro_KOMMENTAR = objWeInstruction
40  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_LADE() As TC_WEInstruction
    '  LADE   "Makrodatei", ["Makroprojekt-Element" [,entladen]]

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "LADE"
20      .CommandoText = "Dient zum Nachladen eigener Makroprojekte. Die auszuf|fffd|hrenden Makros m|fffd|ssen signiert sein."
25      .AddParameter DefineParameter("Makrodatei", _
                                      eptFileName, _
                                      "Name der Datei, die das Makroprojekt enth|fffd|lt", _
                                      vbNullString, _
                                      boolOPTIONAL)
30      .AddParameter DefineParameter("Makroprojekt-Element", _
                                      eptMakroName, _
                                      "das auszuf|fffd|hrende Makro im geladenen Makroprojekt", _
                                      vbNullString, _
                                      boolOPTIONAL)
35      .AddParameter DefineParameter("wieder entladen", _
                                      eptBoolean, _
                                      "= 1: das Projekt bleibt nach Beendigung der Makrofolge noch geladen", _
                                      "0", _
                                      boolOPTIONAL)
40      .AddParameter DefineParameter("Verhalten von Word", _
                                      eptBoolean, _
                                      "= 1: Word beh|fffd|lt anschlie|fffd|end den Fokus", _
                                      "0", _
                                      boolOPTIONAL)
45  End With
50  Set AddMakro_LADE = objWeInstruction
55  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_MELDUNG() As TC_WEInstruction
    '  MELDUNG  "Pfad und Name der Protokolldatei

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "MELDUNG"
20      .CommandoText = "Mit diesem Befehl wird eine Meldung an den Nutzer ausgegeben"
25      .AddParameter DefineParameter("Meldungstext", _
                                      eptText, _
                                      "Meldungstext der ausgegeben werden soll", _
                                      "Meldung", _
                                      boolNOT_OPTIONAL)
30      .AddParameter DefineParameter("Style", _
                                      eptVBAStyle, _
                                      "Zeichen auf der angezeigten Meldungsbox" & vbLf & _
                                      "0 - Informations-Icon" & vbLf & _
                                      "1 - Frage-Icon" & vbLf & _
                                      "2 - Achtungs-Icon" & vbLf & _
                                      "3 - Fehler-Icon", _
                                      "0", _
                                      boolOPTIONAL)
35  End With
40  Set AddMakro_MELDUNG = objWeInstruction
45  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_MISCHE() As TC_WEInstruction
    '  MISCHE   [von [, [bis] [, ["Leerzeilen"]]]]

    Dim objWeInstruction As TC_WEInstruction
    Dim valueSet As Collection
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "MISCHE"
20      .CommandoText = "Mischt das aktuelle Dokument, um es anschlie|fffd|end ausdrucken oder bearbeiten zu k|fffd|nnen " & vbLf & _
                        "Standard ist der erste Datensatz"
25      .AddParameter DefineParameter("von", _
                                      eptCardinal, _
                                      "Nummer des ersten Datensatzes", _
                                      "1", _
                                      boolOPTIONAL)
30      .AddParameter DefineParameter("bis", _
                                      eptCardinal, _
                                      "Nummer des letzten Datensatzes", _
                                      "1", _
                                      boolOPTIONAL)

35      Set valueSet = New Collection
40      valueSet.Add "Leerzeilen"
45      valueSet.Add vbNullString
50      .AddParameter DefineParameterWithValueSet("Leerzeilen", _
                                                  eptConstantSet, _
                                                  "Falls aus leeren Seriendruckfeldern Leerzeilen erzeugt werden sollen" & vbLf & _
                                                  "ist als dritter Parameter 'Leerzeilen' anzugeben", _
                                                  boolOPTIONAL, _
                                                  vbNullString, _
                                                  valueSet)

55      .AddParameter DefineParameter("GesamtDokument", _
                                      eptBoolean, _
                                      "Datens|fffd|tze in ein Dokument mischen", _
                                      "0", _
                                      boolOPTIONAL)

60  End With
65  Set AddMakro_MISCHE = objWeInstruction
70  Set objWeInstruction = Nothing
75  Set valueSet = Nothing

End Function

Private Function AddMakro_OEFFNE() As TC_WEInstruction
    '  OEFFNE    ("Formular" [,[S] [, [P]])

    Dim objWeInstruction As TC_WEInstruction
10    Set objWeInstruction = New TC_WEInstruction

20    With objWeInstruction
30      .makroName = "OEFFNE"
40      .CommandoText = "das Formular wird zum Bearbeiten ge|fffd|ffnet"
50      .AddParameter DefineParameter("OpenFormular", _
                                      eptFileName, _
                                      "die zu |fffd|ffnende Datei", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
60      .AddParameter DefineParameter("OpenMode", _
                                      eptControl, _
                                      "gibt den Modus der zu |fffd|ffnenden Datei an: " & vbLf & _
                                      "gesetztes Bit 0( 1): Lese/Schreibmodus," & vbLf & _
                                      "gesetztes Bit 1( 2): Datei mit revert |fffd|ffnen, " & vbLf & _
                                      "gesetztes Bit 2( 4): Datei im Hintergrund (nicht sichtbar) |fffd|ffnen, " & vbLf & _
                                      "gesetztes Bit 3( 8): Datei bleibt am Ende der Bearbeitung offen, " & vbLf & _
                                      "gesetztes Bit 4(16): Ist die Datei schon ge|fffd|ffnet, dann wird sie erneut ge|fffd|ffnet, " & vbLf & _
                                      "gesetztes Bit 5(32): Datei wird als Serienbrief mit verbundener Datenquelle ge|fffd|ffnet" & vbLf & _
                                      "gesetztes Bit 6(64): Beim |fffd|ffnen der Datei werden in INCLUDETEXT-Feldern relative durch absolute Pfade ersetzt ", _
                                      "0", _
                                      boolOPTIONAL)
'35      .AddParameter DefineParameter("Verhalten von Word", _
'                                      eptBoolean, _
'                                      "= 1: Word bleibt anschlie|fffd|end maximiert", _
'                                      "0", _
'                                      boolOPTIONAL)

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
70      .AddParameter DefineParameter("Verhalten von Word", _
                                      eptControl, _
                                      "1: Word maximiert |fffd|ffnen" & vbLf & _
                                      "0: Word normal |fffd|ffnen" & vbLf & _
                                      "2: Word bleibt minimiert und bekommt nie den Focus", _
                                      "0", _
                                      boolOPTIONAL)

80    End With
90    Set AddMakro_OEFFNE = objWeInstruction
100   Set objWeInstruction = Nothing
End Function

Private Function AddMakro_SCHLIESSE() As TC_WEInstruction
    '  SCHLIESSE    ["Dateiname"]

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "SCHLIESSE"
20      .CommandoText = "das angegebene Dokument wird geschlossen, fehlt der Parameter, wird das aktuell " & vbLf & _
                        "angezeigte Dokument geschlossen"
25      .AddParameter DefineParameter("CloseDatei", _
                                      eptFileName, _
                                      "die zu schliessende Datei", _
                                      vbNullString, _
                                      boolOPTIONAL)

30  End With
35  Set AddMakro_SCHLIESSE = objWeInstruction
40  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_SPEICHERN_ALS() As TC_WEInstruction
    '  SPEICHERN_ALS    ("newFileName")

    Dim parmValueSet As Collection
    Dim objWeInstruction As TC_WEInstruction

5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "SPEICHERN_ALS"
20      .CommandoText = "speichert das aktuelle Dokument unter einem neuen Namen und entfernt ggf. die Serienbrieffunktion in diesem Dokument"
25      .AddParameter DefineParameter("newFileName", _
                                      eptFileName, _
                                      "Name unter dem das Dokument gespeichert werden soll", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30      Set parmValueSet = New Collection

35      parmValueSet.Add "0"
40      parmValueSet.Add "1"
45      parmValueSet.Add "2"
50      .AddParameter DefineParameterWithValueSet("Steuerungsparameter", _
                                                  eptConstantSet, _
                                                  "gibt an, wie SPEICHENR_ALS im Fehlerfall arbeiten soll, Standard ist 0" & vbLf & _
                                                " 0 - existierende Datei wird immer |fffd|berschrieben" & vbLf & _
                                                " 1 - existierende Datei wird nicht |fffd|berschrieben, Fehlermeldung erfolgt" & vbLf & _
                                                " 2 - Dialogbox mit Nachfrage wird angezeigt, als Voreinstellung wird Parameter 1 angeboten", _
                                                  boolOPTIONAL, _
                                                  "0", _
                                                  parmValueSet)
55      Set parmValueSet = Nothing

60  End With
65  Set AddMakro_SPEICHERN_ALS = objWeInstruction
70  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_SETZE_PARAMETER() As TC_WEInstruction
    '  SETZE_PARAMETER  (BUTTON1|BUTTON2|BUTTON3|SAVEASDIR|PRINTER|SYMBOLBAR|WORDMODE), parmValue
    Dim objWeInstruction As TC_WEInstruction

5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "SETZE_PARAMETER"
20      .CommandoText = "Dieser Befehl dient zur Steuerung der Abarbeitung der Aktion." & vbLf & _
                        "Mit ihm k|fffd|nnen Umgebungswerte oder Abarbeitungseigenschaften eingerichtet werden"

25      .AddParameter DefineParameter("ParameterName", _
                                      eptText, _
                                      "Name des Parameters, dessen Wert gesetz werden soll." & vbLf & _
                                      "vordefinierte Parameter sind: BUTTON1, BUTTON2, BUTTON3, SAVEASDIR, PRINTER, FIRSTTRAY, OTHERTRAY", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)

30      .AddParameter DefineParameter("Parameterwert", _
                                      eptText, _
                                      "Wert f|fffd|r diesen Parameter. Dieser h|fffd|ngt vom Parameter selbst ab." & vbLf & _
                                      "F|fffd|r genauere Beschreibung sehen Sie bitte in der Befehlsbeschreibung nach", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
35  End With

40  Set AddMakro_SETZE_PARAMETER = objWeInstruction
45  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_SYMBOLLEISTE() As TC_WEInstruction
    '  SYMBOLLEISTE    "Symbolleistenname", (AN|AUS) [,Server,Docdir,Port]
5   Set AddMakro_SYMBOLLEISTE = DoDefineCommandbar("SYMBOLLEISTE")
End Function

Private Function AddMakro_SYMBOLLEISTE_RIBBON() As TC_WEInstruction
    '  SYMBOLLEISTE_RIBBON    "Symbolleistenname", (AN|AUS) [,Server,Docdir,Port]

    ' aus Kompatibilit|fffd|tsgr|fffd|nden noch da, wird sowieso wie SYMBOLLEISTE abgearbeitet
5   Set AddMakro_SYMBOLLEISTE_RIBBON = DoDefineCommandbar("SYMBOLLEISTE_RIBBON")
End Function

Private Function DoDefineCommandbar(vMakroName As String) As TC_WEInstruction
    '  SYMBOLLEISTE_(RIBBON)    "Symbolleistenname", (AN|AUS) [,Server,Docdir,Port]

    Dim objWeInstruction As TC_WEInstruction
    Dim valueSet As Collection
    Dim cmdBarSet As Collection

5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = vMakroName
20      .CommandoText = "das Formular wird zum Bearbeiten ge|fffd|ffnet"

25      Set cmdBarSet = New Collection
30      cmdBarSet.Add "IKOL"
35      cmdBarSet.Add "IKOL-S1"
40      cmdBarSet.Add "IKOL-S2"
45      cmdBarSet.Add "IKOL-SP"
50      cmdBarSet.Add "IKOL-V1"
55      cmdBarSet.Add "IKOL-V2"
60      cmdBarSet.Add "IKOL-V3"
65      cmdBarSet.Add "IKOL-V4"
70      .AddParameter DefineParameterWithValueSet("Symbolleistenname", _
                                                  eptCommandBars, _
                                                  vbLf & "Name oder Definition der anzuzeigenden Symbolleiste", _
                                                  boolNOT_OPTIONAL, _
                                                  "IKOL", _
                                                  cmdBarSet)

75      Set cmdBarSet = Nothing

80      Set valueSet = New Collection
85      valueSet.Add "AN"
90      valueSet.Add "AUS"

95      .AddParameter DefineParameterWithValueSet("Sichtbarkeit", _
                                                  eptConstantSet, _
                                                  "gibt an, ob die Symbolleiste an- oder ausgeschaltet werden soll", _
                                                  boolNOT_OPTIONAL, _
                                                  "AN", _
                                                  valueSet)
100     .AddParameter DefineParameter("Server", _
                                      eptServerName, _
                                      "Servername f|fffd|r den Dokumentenupload", _
                                      vbNullString, _
                                      boolOPTIONAL)
105     .AddParameter DefineParameter("DokumentDir", _
                                      eptDirName, _
                                      "Name des Dokumentenverzeichnis auf dem Server", _
                                      vbNullString, _
                                      boolOPTIONAL)
110     .AddParameter DefineParameter("Portnummer", _
                                      eptPort, _
                                      "Portnummer des Servers", _
                                      vbNullString, _
                                      boolOPTIONAL)
115     Set valueSet = Nothing
120 End With

125 Set DoDefineCommandbar = objWeInstruction
130 Set objWeInstruction = Nothing

End Function

Private Function AddMakro_SYNTAX_BESCHREIBUNG(currentDir As String) As TC_WEInstruction
    '  SYNTAX_BESCHREIBUNG

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "SYNTAX_BESCHREIBUNG"
20      .CommandoText = "Gibt in die angegebene Datei (Standard " & gstrTC_OS2_SYNTAXNAME & ") die aktuelle Syntaxdefinition und - Beschreibung aus"

25      .AddParameter DefineParameter("SyntaxDatei", _
                                      eptFileName, _
                                      "Datei, in die die Syntaxdefinition geschrieben werden soll", _
                                      currentDir & Application.PathSeparator & gstrTC_OS2_SYNTAXNAME, _
                                      boolOPTIONAL)

30  End With
35  Set AddMakro_SYNTAX_BESCHREIBUNG = objWeInstruction
40  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_UEBERGABE_SYSTEM() As TC_WEInstruction
    '  UEBERGABE_SYSTEM  "Root-Pfad", "Winwork-Pfad", "DocDir-Pfad", "Anwendungsname", "ArchivDir", "Programmname", "Aktionsname", "Versionsnr"

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "UEBERGABE_SYSTEM"
20      .CommandoText = "|fffd|bergabeparameter zur Steuerung der Arbeit der SYSTEM.DOT"
25      .AddParameter DefineParameter("RootPath", _
                                      eptDirName, _
                                      "User-Verzeichnis Name", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30      .AddParameter DefineParameter("WinworkPath", _
                                      eptDirName, _
                                      "Winwork-Verzeichnis", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
35      .AddParameter DefineParameter("DocDirPath", _
                                      eptDirName, _
                                      "Dokumenten-Verzeichnis", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
40      .AddParameter DefineParameter("ApplicationName", _
                                      eptWindowTitle, _
                                      "Fenstertitel der rufenden Anwendung", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
45      .AddParameter DefineParameter("ArchivDir", _
                                      eptDirName, _
                                      "Verzeichnis f|fffd|r eAkte", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
50      .AddParameter DefineParameter("ProgramName", _
                                      eptText, _
                                      "Name des Programms, das die WE.TXT erzeugt hat", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
55      .AddParameter DefineParameter("Action", _
                                      eptText, _
                                      "Name der ausgef|fffd|hrten Befehlsfolge(Aktion)", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
60      .AddParameter DefineParameter("OfficeInterfaceVersion", _
                                      eptText, _
                                      "Versionsnummer der Office-Schnittstelle", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
65  End With
70  Set AddMakro_UEBERGABE_SYSTEM = objWeInstruction
75  Set objWeInstruction = Nothing
End Function

Private Function AddMakro_UMW_FORMULAR_SERIENBRIEF() As TC_WEInstruction
    '  UMW_FORMULAR_SERIENBRIEF

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "UMW_FORMULAR_SERIENBRIEF"
20      .CommandoText = "Wandelt Textformularfelder in Seriendruckfelder um"
25  End With
30  Set AddMakro_UMW_FORMULAR_SERIENBRIEF = objWeInstruction
35  Set objWeInstruction = Nothing

End Function

Private Function AddMakro_VERBINDE() As TC_WEInstruction
    '  VERBINDE   "Dateiname" [,S]

    Dim objWeInstruction As TC_WEInstruction
5   Set objWeInstruction = New TC_WEInstruction

10  With objWeInstruction
15      .makroName = "VERBINDE"
20      .CommandoText = "die aktuelle Datei wird mit der Datenquelle Dateiname verbunden."
25      .AddParameter DefineParameter("Dateiname", _
                                      eptFileName, _
                                      "die zum Verbinden zu |fffd|ffnende Datei", _
                                      vbNullString, _
                                      boolNOT_OPTIONAL)
30      .AddParameter DefineParameter("Sondervariablen", _
                                      eptBoolean, _
                                      "= 1: in der DO.TXT sind Sondervariablen zugelassen", _
                                      "0", _
                                      boolOPTIONAL)
35  End With
40  Set AddMakro_VERBINDE = objWeInstruction
45  Set objWeInstruction = Nothing

End Function


' ============ ab hier die Codes der Makros
' (zusammengef|fffd|hrt aus Application-,  Print-,  Control-, Dokument-, File, Logfile- und MailMergeHandler)


Public Function ANSICHT(session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
10  boolResult = True

    Dim savedWindowState As WdWindowState
    Dim savedScreenUpdating As Boolean

15  savedWindowState = Application.WindowState
20  savedScreenUpdating = Application.ScreenUpdating

25  Application.ScreenUpdating = True
30  Application.WindowState = wdWindowStateMaximize

35  Application.PrintPreview = True

40  Me.ParentIkolClientApp.frmVorschau.CustomShowUserForm

45  Application.WindowState = savedWindowState
50  Application.ScreenUpdating = savedScreenUpdating

55  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
60  On Error Resume Next
65  ANSICHT = boolResult
70  Exit Function

RaiseErrorHandler:
75  session.tcResult = tcrEnd
80  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ANSICHT", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ANSICHT'", True)
85  Resume ExitProc


End Function


Public Function ANWENDUNG_AKTIVIEREN(applicationTitle As String, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True


15  If applicationTitle = vbNullString Then
20      applicationTitle = session.CallingApplName
25  End If

30  session.tcResult = Me.ParentIkolClientApp.ApplicationHandler.ActivateApplicationWindow(applicationTitle, "ANWENDUNG_AKTIVIEREN", session)

35  If session.tcResult <> tcrOK Then
40      session.fokusOnWord = session.fokusOnWord Or gintNO_APPLICATION_FOR_FOKUS
45  End If
50  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
55  On Error Resume Next
60  ANWENDUNG_AKTIVIEREN = boolResult
65  Exit Function

RaiseErrorHandler:
70  session.tcResult = tcrEnd
75  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ANWENDUNG_AKTIVIEREN", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ANWENDUNG_AKTIVIEREN'", True)
80  Resume ExitProc

End Function

Public Function ANWENDUNG_D_AKTIVIEREN(session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
10  boolResult = True

    Dim lastNumber As Integer
    Dim tcDoc As TC_Document

15  session.fokusOnWord = session.fokusOnWord Or gintDOKUMENT_AKTIV
20  lastNumber = session.ManagedTCDocumentsContainer.GetLastDocumentNumber()
25  If lastNumber > 0 Then
30      Set tcDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByNumberInSession(lastNumber)
35      tcDoc.Document.Activate
40      Set tcDoc = Nothing
45  End If

50  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
55  On Error Resume Next
60  ANWENDUNG_D_AKTIVIEREN = boolResult
65  Set tcDoc = Nothing
70  Exit Function

RaiseErrorHandler:
75  session.tcResult = tcrEnd
80  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ANWENDUNG_D_AKTIVIEREN", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ANWENDUNG_D_AKTIVIEREN'", True)
85  Resume ExitProc

End Function

Public Function ANWENDUNG_VERSTECKEN_SYS(session As TC_Session) As Boolean
    Dim boolResult As Boolean

5   boolResult = True
10  session.tcResult = tcrOK

15  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
20  ANWENDUNG_VERSTECKEN_SYS = boolResult
    ' obsolet, da die TC_OIRUN.DOC schon l|fffd|ngst geschlossen ist.
End Function

Public Function ANZEIGE_AKTUALISIEREN_AN(session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  Me.ParentIkolClientApp.ApplicationHandler.SetScreenUpdate (True)
20  session.tcResult = tcrOK

25  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
30  On Error Resume Next
35  ANZEIGE_AKTUALISIEREN_AN = boolResult
40  Exit Function

RaiseErrorHandler:
45  session.tcResult = tcrEnd
50  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ANZEIGE_AKTUALISIEREN_AN", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ANZEIGE_AKTUALISIEREN_AN'", True)
55  Resume ExitProc
End Function

Public Function ANZEIGE_AKTUALISIEREN_AUS(session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True


15  Me.ParentIkolClientApp.ApplicationHandler.SetScreenUpdate (False)
20  session.tcResult = tcrOK

25  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
30  On Error Resume Next
35  ANZEIGE_AKTUALISIEREN_AUS = boolResult
40  Exit Function

RaiseErrorHandler:
45  session.tcResult = tcrEnd
50  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ANZEIGE_AKTUALISIEREN_AUS", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ANZEIGE_AKTUALISIEREN_AUS'", True)
55  Resume ExitProc

End Function

Public Function SYMBOLLEISTE(strSymbolBarName As String, _
                             strVisible As String, _
                             strServerName As String, _
                             strDocDirName As String, _
                             intPortNumber As Long, _
                             session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  session.ServerName = strServerName
20  session.PortNumber = intPortNumber

25  Call Me.ParentIkolClientApp.RibbonAndCommandbarRelatives.LoadCommandBarAccordingToWordVersion(strSymbolBarName, session)

30  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
35  On Error Resume Next
40  SYMBOLLEISTE = boolResult
45  Exit Function

RaiseErrorHandler:
50  session.tcResult = tcrEnd
55  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "SYMBOLLEISTE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'SYMBOLLEISTE'", True)
60  Resume ExitProc

End Function

Public Function ARCHIVDRUCK(session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

    Dim tcResult As TC_SessionResult

15  tcResult = tcrOK
20  If Me.ParentIkolClientApp.PrintHandler.TestArchivEnvironment(session, "ARCHIVDRUCK") Then
25      tcResult = Me.ParentIkolClientApp.PrintHandler.PrintDocuments(1, session.Printer_eAkte, 0, 0, True, 2, session)
30      If tcResult = tcrOK Then
35          tcResult = Me.ParentIkolClientApp.PrintHandler.SynchronisePrint_eAkte(session)
40      End If
45      session.tcResult = tcResult
50  End If

55  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
60  On Error Resume Next
65  ARCHIVDRUCK = boolResult
70  Exit Function

RaiseErrorHandler:
75  session.tcResult = tcrEnd
80  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ARCHIVDRUCK", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ARCHIVDRUCK'", True)
85  Resume ExitProc
End Function

Public Function ARCPRINTER(PrinterName As String, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  session.tcResult = Me.ParentIkolClientApp.PrintHandler.SetPrinter_eAkte(PrinterName, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
25  On Error Resume Next
30  ARCPRINTER = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ARCPRINTER", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'ARCPRINTER'", True)

50  Resume ExitProc

End Function

Public Function TIFFPRINTER(PrinterName As String, session As TC_Session) As Boolean
    ' nur aus Kompatibilit|fffd|tsgr|fffd|nden noch enthalten
5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
10  boolResult = True

15  session.tcResult = Me.ParentIkolClientApp.PrintHandler.SetPrinter_eAkte(PrinterName, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
25  On Error Resume Next
30  TIFFPRINTER = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "TIFFPRINTER", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'TIFFPRINTER'", True)
50  Resume ExitProc
End Function

Public Function PDFAPRINTER(PrinterName As String, session As TC_Session) As Boolean
    ' nur aus Kompatibilit|fffd|tsgr|fffd|nden noch enthalten
5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  session.tcResult = Me.ParentIkolClientApp.PrintHandler.SetPrinter_eAkte(PrinterName, session)
20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
25  On Error Resume Next
30  PDFAPRINTER = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "PDFAPRINTER", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'PDFAPRINTER'", True)
50  Resume ExitProc
End Function

Public Function DRUCKE(quantity As Integer, _
                       strPrinterName As String, _
                       firstPage As Integer, _
                       lastPage As Integer, _
                       printerControl As Integer, _
                       session As TC_Session) As Boolean


    Dim tcDoc As TC_Document
    Dim strSavePrinter As String

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  strSavePrinter = session.PrinterToUse

20  If (session.PrinterToUse = vbNullString) Or (strPrinterName <> vbNullString) Then
25      session.tcResult = Me.ParentIkolClientApp.PrintHandler.SetPrinterToUse(strPrinterName, session)
30  End If

35  If session.tcResult = tcrOK Then
40      With session
45          If session.workingDocument Is Nothing Then
50              Err.Raise glongCUSTOM_ERR_PRINT, "TC_SyntaxDescription::DRUCKE", "Es ist kein Dokument zum Drucken ge|fffd|ffnet"
55              session.tcResult = tcrFileNotFound
60          Else
65              Set tcDoc = session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)
70              tcDoc.Printed = False
75              session.tcResult = Me.ParentIkolClientApp.PrintHandler.PrintDocuments( _
                                   quantity, _
                                   session.PrinterToUse, _
                                   firstPage, _
                                   lastPage, _
                                   False, _
                                   printerControl, _
                                   session)
80          End If
85      End With
90  Else
95      Err.Raise glongCUSTOM_ERR_PRINT, "TC_SyntaxDescription::DRUCKE", "Konnte Drucker nicht setzen"
100 End If


105 boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
110 On Error Resume Next
115 DRUCKE = boolResult
120 session.PrinterToUse = strSavePrinter
125 Set tcDoc = Nothing
130 Exit Function

RaiseErrorHandler:
135 session.tcResult = tcrEnd
140 boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "DRUCKE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'DRUCKE'", True)

145 Resume ExitProc
End Function

Public Function BEENDE(protocollFileName As String, session As TC_Session) As Boolean

    Dim boolResult As Boolean
5   boolResult = True
    ' Beende macht nichts mehr, da
    ' Protokoll-Datei wird immer geschrieben und der Server k|fffd|mmert sich um das Abholen
    ' Jede Makrofolge enth|fffd|lt den Befehl ENDE und f|fffd|r diesen Befehl wird die Entscheidung getroffen,
    ' ob Dokumente geschlossen werden m|fffd|ssen, und wenn ja welche,
    ' ob die Session beendet wird, oder auch die SYSTEM.DOT, und/oder Word
10  session.tcResult = tcrOK

15  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
20  BEENDE = boolResult
End Function

Public Function KOMMENTAR(comment As String, session As TC_Session) As Boolean
    ' Kommentar macht nichts
    Dim boolResult As Boolean
5   boolResult = True

10  session.tcResult = tcrOK

15  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
20  KOMMENTAR = boolResult
End Function

Public Function MELDUNG(message As String, style As VbMsgBoxStyle, session As TC_Session) As Boolean
    Dim savedScreenUpdate As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  savedScreenUpdate = Application.ScreenUpdating
20  Application.ScreenUpdating = True
25  Application.ScreenRefresh
30  Call MsgBox(message, style, Me.ParentIkolClientApp.MsgBoxTitle)
35  Application.ScreenRefresh
40  Application.ScreenUpdating = savedScreenUpdate
45  session.tcResult = tcrOK

50  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
55  On Error Resume Next
60  MELDUNG = boolResult
65  Exit Function

RaiseErrorHandler:
70  session.tcResult = tcrEnd

75  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "MELDUNG", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'MELDUNG'", True)

80  Resume ExitProc
End Function

Public Function Ende(session As TC_Session) As Boolean
    Dim boolResult As Boolean
5     boolResult = True
      
      '29.04.2014 AL
      'wenn eine Befehlsfolge abgearbeitet wurde (automatisch zugef|fffd|gter Befehl 'ENDE'), m|fffd|ssen die Schreib/Leserechte wieder hergestellt werden
10    Call session.ManagedTCDocumentsContainer.RestoreDocProtections
      'ENDE 29.04.2014 AL
      
    ' setzt das tcResult auf tcrEnd, so dass das rufende Programm die Ende-Behandlung der Makrofolge vornehmen kann
15    session.tcResult = tcrEnd
20    Ende = boolResult
End Function

Public Function FUEHRE_AUS(strCommandLine As String, session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True


15  session.tcResult = Me.ParentIkolClientApp.ControlHandler.CallPgmExtern(strCommandLine, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
25  On Error Resume Next
30  FUEHRE_AUS = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "FUEHRE_AUS", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'FUEHRE_AUS'", True)

50  Resume ExitProc
End Function

Public Function LADE(macroFileName As String, _
                     macroName As String, _
                     boolNoUnload As Boolean, _
                     boolFokusOnWord As Boolean, _
                     session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
10  boolResult = True

15  If boolFokusOnWord Then
20      session.fokusOnWord = session.fokusOnWord Or gintLADE_AKTIV
25  End If

30  session.tcResult = Me.ParentIkolClientApp.ControlHandler.CallMakroExtern(macroFileName, macroName, Not boolNoUnload, session)

35  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
40  On Error Resume Next
45  LADE = boolResult
50  Exit Function

RaiseErrorHandler:
55  session.tcResult = tcrEnd
60  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "LADE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'LADE'", True)
65  Resume ExitProc
End Function

Public Function SETZE_PARAMETER(strControlParm As String, _
                                strControlValue As String, _
                                session As TC_Session) As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
20    boolResult = True

    Dim strTempParm As String
    Dim intResult As Integer
    Dim sState As PrinterSearchState
    Dim strNormalizedPrinterName As String

30    Call session.AddParmValue(strControlParm, strControlValue)

40    strTempParm = strControlParm

50    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("f|fffd|r den Parameter " & Chr(34) & strTempParm & Chr(34) & _
                                                         " wird der Wert " & Chr(34) & strControlValue & Chr(34) & _
                                                         " gesetzt", session)
60    If strTempParm = "PRINTER" Then
70      If strControlValue = "?" Then
80          session.PrinterToUse = strControlValue
90          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Session-Drucker auf '?' gesetzt, " & _
                                                                   "so dass beim Druck eine Druckerauswahlbox angezeigt wird", session)
100     Else

110         sState = Me.ParentIkolClientApp.PrinterSetupHandler.GetNormalizedPrinterName(strControlValue, strNormalizedPrinterName, False)

120         Select Case sState
                Case ssOnePrinter
130                 session.PrinterToUse = strNormalizedPrinterName
140                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Session-Drucker ist gesetzt auf : " & _
                                                                           Chr(34) & strNormalizedPrinterName & Chr(34), session)
150             Case ssNoPrinter
160                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Session-Drucker konnte nicht gefunden werden", session)
170             Case ssMorePrinter
180                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Session-Druckername ist nicht eindeutig", session)
190         End Select
200     End If

210   ElseIf strTempParm = "BUTTON1" Then
220     Call Me.ParentIkolClientApp.RibbonAndCommandbarRelatives.SetzeIKOLButtonEigenschaften("btn_1", strControlValue, _
                                                                                              "vom User gesetzte Funktion 01", intResult)

230   ElseIf strTempParm = "BUTTON2" Then
240     Call Me.ParentIkolClientApp.RibbonAndCommandbarRelatives.SetzeIKOLButtonEigenschaften("btn_2", strControlValue, _
                                                                                              "vom User gesetzte Funktion 02", intResult)

250   ElseIf strTempParm = "BUTTON3" Then
260     Call Me.ParentIkolClientApp.RibbonAndCommandbarRelatives.SetzeIKOLButtonEigenschaften("btn_3", strControlValue, _
                                                                                              "vom User gesetzte Funktion 03", intResult)

270   ElseIf strTempParm = "SAVEASDIR" Then
280     Call Me.ParentIkolClientApp.FileHandler.SetSaveAsDirectory(strControlValue, session)

290   ElseIf strTempParm = "SYMBOLBAR" Then
300     Call Me.ParentIkolClientApp.RibbonAndCommandbarRelatives.LoadCommandBarAccordingToWordVersion(strControlValue, session)

310   ElseIf strTempParm = "WORDMODE" Then
320     If strControlValue = "0" Or _
           strControlValue = "1" Then
330         Call Me.ParentIkolClientApp.ApplicationHandler.SetWordModeAfterWork(CBool(strControlValue), session)
340     Else
350         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("f|fffd|r den Parameter " & Chr(34) & strTempParm & Chr(34) & _
                                                                 " kann die Aktion nicht ausgef|fffd|hrt werden, da der |fffd|bergebene Wert " & _
                                                                   Chr(34) & strControlValue & Chr(34) & " nicht 0 oder 1 ist", session)
360     End If

370   ElseIf strTempParm = "PRINTOLDWAY" Then

380     If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Then
390         session.OldWayPrint = True
400     Else
410         session.OldWayPrint = False
420     End If
430     Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Parameter OldWayPrint auf " & session.OldWayPrint & " gesetzt", session)

'15.04.2014 AL
'wird in PYP SETZE_PARAMETER auf SHOWWARNINGS="AUS" gesetzt, erfolgt die Meldung "nicht existierte, wurde es erzeugt" beim Archivdruck nicht
440   ElseIf strTempParm = "SHOWWARNINGS" Then
450     If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Then
460        session.ShowWarnings = True
470      Else
480        session.ShowWarnings = False
490      End If
500      Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Parameter ShowWarnings auf " & session.ShowWarnings & " gesetzt", session)
'15.04.2014 AL ENDE

        ' ++++++++++++++++++++ Parameter f|fffd|r das Unterschriftenmodul ++++++++++++++++++++++++++++++++

510   ElseIf strTempParm = "SIGNINIFILE" Then
520     session.IniFile = strControlValue

530   ElseIf strTempParm = "SCALEFACTOR" Then
540     session.SignScaleFactor = CInt(strControlValue)

550   ElseIf strTempParm = "SIGNSCREEN" Then
560     If UCase(strControlValue) = "B" Then
570         session.SignSynchScreen = susAllSyncScreen
580     ElseIf UCase(strControlValue) = "U" Then
590         session.SignSynchScreen = susSignSyncScreen
600     ElseIf UCase(strControlValue) = "N" Then
610         session.SignSynchScreen = susNoSyncScreen
620     Else
630         Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("f|fffd|r den Parameter " & Chr(34) & strTempParm & Chr(34) & _
                                                                 " kann der Befehl nicht ausgef|fffd|hrt werden." & vbLf & _
                                                                   "Zul|fffd|ssige Werte f|fffd|r die Anzeige des synchronisierten Bildschirms sind: " & _
                                                                   "'B' - sofort bei der Anzeige des Dokuments zum Bearbeiten," & vbLf & _
                                                                   "'U' - erst bei der Unterschriftenabfrage oder" & vbLf & _
                                                                   "'N' - es wird kein synchronisierter Bildschirm angezeigt", session)
640     End If

650   ElseIf strTempParm = "SIGNCMDBAR" Then
660     If UCase(strControlValue) = "AUS" Or _
           UCase(strControlValue) = "0" Then
670         session.SignWithCommandbar = False
680     Else
690         session.SignWithCommandbar = True
700     End If

'16.09.2014 AL
710   ElseIf strTempParm = "RIBBON_MINIMIEREN" Then
720   If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
730         session.RibbonMinimieren = True
740     Else
750         session.RibbonMinimieren = False
760     End If

'25.04.2016 AL
770   ElseIf strTempParm = "UPAD_FINAL_QUESTION" Then
780   If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
790         session.UPadFinalQuestion = True
800     Else
810         session.UPadFinalQuestion = False
820     End If

'19.04.2016 AL
830   ElseIf strTempParm = "SIGNPAD" Then
        Dim merkInitWert As String
840     merkInitWert = session.SignPad 'wurde mit "DESKTOP" initialisiert
850     session.SignPad = UCase(strControlValue)
        
        '28.04.2016 AL
860     If session.SignPad = "CONFIG.INI" Then

          '09.05.2016
          'dies wird durch eine neue Vlado-Function ersetzt, weil es dynamische Umgebungen und zus|fffd|tzliche Schalter in der config.ini
          'geben wird (in Schweinfurt)
          'ist an dieser Stelle aber egal - was z|fffd|hlt ist der SIGNPAD-TYP, also (bisher) ST_ALPHA oder WACOM_STU300 oder WACOM_STU430 oder WACOM_STU530 oder WACOM_STU540 oder WACOM_STU541
          '
          'session.SignPad = extractSignPadFromConfigIni(session)
          '
          
          Dim strSignPad As String
870       Application.Run "SignUpAppHandler.getPadName", session.IniFile, strSignPad
          'MsgBox "in SyntaxDes: " & strSignPad
    
          'es kann sein, dass Vlados Function zus|fffd|tzlich die IP-Adresse des PADs zur|fffd|ckgibt, z.B.:
          '  ST_ALPHA,192.168.10.2
          '  oder
          '  ST_ALPHA,USB
          'in diesem Falle, ist die IP-Adresse nicht zu beachten (also mit split wegzuschmeissen)
880       If strSignPad <> "" Then
            Dim tmp As Variant
890         tmp = Split(strSignPad, ",")          'nach "," splitten
900         strSignPad = Trim(tmp(0))             'der linke Teil, also vorm Komma
910       End If
          
920       session.SignPad = strSignPad
          'ENDE 09.05.2016
          
930       If session.SignPad = "" Then session.SignPad = merkInitWert
          'MsgBox session.SignPad
940       Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("der Parameter " & Chr(34) & strTempParm & Chr(34) & _
                                                             " wird auf " & session.SignPad & " gesetzt", session)
950     End If
        'ENDE 28.04.2016 AL
        
'08.10.2014 AL
960   ElseIf strTempParm = "CHECK_FIELDS" Then
970   If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
980         session.CheckFields = True
990     Else
1000        session.CheckFields = False
1010    End If

'14.11.2014 AL
1020  ElseIf strTempParm = "PRINT_HIDDEN" Then
      '23.01.2015 AL
1030  session.ParamPrintHidden = True
1040  If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
1050        session.PrintHidden = True
1060    Else
1070        session.PrintHidden = False
1080    End If

'14.11.2014 AL
1090  ElseIf strTempParm = "PRINT_HIDDEN_ARC" Then
      '23.01.2015 AL
1100  session.ParamPrintHidden = True
1110  If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
1120        session.PrintHiddenArc = True
1130    Else
1140        session.PrintHiddenArc = False
1150    End If

'17.02.2015 AL
1160  ElseIf strTempParm = "SPEICHERN_ALS_SB_ENTFERNEN" Then
1170  If UCase(strControlValue) = "AUS" Or _
           UCase(strControlValue) = "0" Or _
           UCase(strControlValue) = "NEIN" Then
1180        session.SpeichernAlsSBentfernen = False
1190    Else
1200        session.SpeichernAlsSBentfernen = True
1210    End If

'04.06.2015 AL
1220  ElseIf strTempParm = "SIGN_MULTSELECT" Or strTempParm = "SIGN_MULTISELECT" Then '10.05.2016 AL nun auch SIGN_MULTISELECT
1230  If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
1240        session.SignMultiSelect = True
1250    Else
1260        session.SignMultiSelect = False
1270    End If

'26.02.2018 AL
'session.DeltaScroll ist initial auf FALSE gesetzt
1280  ElseIf strTempParm = "DELTA_SCROLL" And session.SignPad = "ST_DELTA" Then
1290  If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
1300        session.DeltaScroll = True
1310    Else
1320        session.DeltaScroll = False
1330    End If

'14.07.2016 AL
1340  ElseIf strTempParm = "NORMAL_DOT_SAVED" Then
1350  If UCase(strControlValue) = "AN" Or _
           UCase(strControlValue) = "1" Or _
           UCase(strControlValue) = "EIN" Or _
           UCase(strControlValue) = "JA" Then
1360        gboolNormalDotSaved = True  'gobal, weil Session schon zerst|fffd|rt, wenn das gebraucht wird
1370        Application.NormalTemplate.Saved = True 'dies muss auch hier stehen, weil:
                                                    '  - bei AutoExit() ist Normal.dot schon neu geschrieben!
                                                    '  - CloseLogfileTextStream() wird nicht gerufen, wenn x im Word-Fenster geklickt wird
            'zum Testen:
            '  - meine Normal.dotm steht in: C:\Users\andreasl\AppData\Roaming\Microsoft\Templates
            '  - vor dem Aufruf von OS2 bzw. vor h|fffd|ndischem MS-WORD-Aufruf: Normal.dotm umbenennen
            '  - wenn obiger Schalter gesetzt, sollte Normal.dotm NICHT neu geschrieben werden
            
1380    Else
1390        gboolNormalDotSaved = False 'global, weil Session schon zerst|fffd|rt, wenn das gebraucht wird
1400    End If


1410  Else
1420    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("der Parameter " & Chr(34) & strTempParm & Chr(34) & _
                                                             " ist ein benutzerdefinierter Parameter und wird nur gespeichert", session)
1430  End If

1440  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
1450  On Error Resume Next
1460  SETZE_PARAMETER = boolResult
1470  Exit Function

RaiseErrorHandler:
1480  session.tcResult = tcrEnd
1490  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "SETZE_PARAMETER", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'SETZE_PARAMETER'", True)
1500  Resume ExitProc

End Function

Public Function UEBERGABE_SYSTEM(RootPath As String, _
                                 WinworkPath As String, _
                                 DocDirPath As String, _
                                 applicationName As String, _
                                 ArchivDir As String, _
                                 programName As String, _
                                 makroAktion As String, _
                                 tc_os2_version As String, _
                                 session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler


    Dim strCrossSignPictureFullFileName As String
    Dim strDoublePathSeparator As String
    Dim boolResult As Boolean

10  strDoublePathSeparator = Application.PathSeparator & Application.PathSeparator
15  boolResult = True

20  With session
25      .DocDirPath = Me.ParentIkolClientApp.Tools.NormalizedPathWithSeparator(DocDirPath)
30      .SaveAsDirectory = .DocDirPath
35      .CallingApplName = applicationName
40      .ArchivDir = Me.ParentIkolClientApp.Tools.NormalizedPathWithSeparator(ArchivDir)
45      .CallingPgmName = programName
50      .MacroAction = makroAktion
55      .ClientDirPath = Me.ParentIkolClientApp.Tools.NormalizedPathWithSeparator(RootPath)
60      .WinworkPath = Me.ParentIkolClientApp.Tools.NormalizedPathWithSeparator(WinworkPath)

65      strCrossSignPictureFullFileName = .WinworkPath & Application.PathSeparator & gstrTC_OS_DEFAULT_SIGN_IMAGE_FILE
70      strCrossSignPictureFullFileName = Replace(strCrossSignPictureFullFileName, Application.PathSeparator, strDoublePathSeparator)
75      strCrossSignPictureFullFileName = Replace(strCrossSignPictureFullFileName, strDoublePathSeparator & strDoublePathSeparator, strDoublePathSeparator)
80      .SignDefaultFile = strCrossSignPictureFullFileName
85      .IniFile = .WinworkPath & gstrTC_DEFAULT_SIGN_UP_INI_FILE


90      Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("Client-Verzeichnis", .ClientDirPath, True, session)
95      Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("WinWork-Verzeichnis", .WinworkPath, True, session)
100     Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("Dokumenten-Verzeichnis", .DocDirPath, True, session)
105     Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("Archiv-Verzeichnis", .ArchivDir, True, session)
110     Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("Schnittstellenversion IKOL", tc_os2_version, False, session)
115     Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("aufrufendes IKOL-Programm", .CallingApplName, False, session)
120     Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("IKOL-Unter-Programm", .CallingPgmName, False, session)
125     Call Me.ParentIkolClientApp.ControlHandler.ProtokollUebergabeDirectory("Auszuf|fffd|hrende Aktion", .MacroAction, False, session)
130 End With

135 Me.ParentIkolClientApp.IsArcDirSet = (session.ArchivDir <> vbNullString)

140 If Me.ParentIkolClientApp.Os2Version <> tc_os2_version Then
145     session.tcResult = session.VersionTest(session, tc_os2_version)
150 End If

155 If applicationName = vbNullString Then
160     If session.tcResult = tcrOK Then
165         session.tcResult = tcrWarning
170     End If
175     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("In UEBERGABE_SYSTEM wurde kein Titel der Anwendung |fffd|bergeben, bitte die Konfiguration des aufrufenden Programms |fffd|ndern")
180 End If

185 boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
190 On Error Resume Next
195 UEBERGABE_SYSTEM = boolResult
200 Exit Function

RaiseErrorHandler:

205 session.tcResult = tcrEnd

210 boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "UEBERGABE_SYSTEM", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'UEBERGABE_SYSTEM'", True)
215 Resume ExitProc

End Function


Public Function INSERT_E(insertFileName As String, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  session.tcResult = Me.ParentIkolClientApp.DocumentHandler.InsertFile(insertFileName, False, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
25  On Error Resume Next
30  INSERT_E = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "INSERT_E", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'INSERT_E'", True)
50  Resume ExitProc
End Function

Public Function INSERT_TEXT_E(textForInsert As String, session As TC_Session) As Boolean

    Dim boolResult As Boolean
5   boolResult = True

10  On Error GoTo RaiseErrorHandler

15  session.tcResult = Me.ParentIkolClientApp.DocumentHandler.InsertText(textForInsert, False, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
25  On Error Resume Next
30  INSERT_TEXT_E = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "INSERT_TEXT_E", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'INSERT_TEXT_E'", True)
50  Resume ExitProc

End Function

Public Function MISCHE(FirstRec As Integer, _
                       lastRec As Integer, _
                       emptyLines As String, _
                       oneDocument As Boolean, _
                       session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  session.MergeEmptyLines = UCase(emptyLines) = UCase("Leerzeilen")
20  session.tcResult = Me.ParentIkolClientApp.DocumentHandler.MergeRecords(FirstRec, lastRec, oneDocument, session)

25  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
30  On Error Resume Next
35  MISCHE = boolResult
40  Exit Function

RaiseErrorHandler:
45  session.tcResult = tcrEnd
50  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "MISCHE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'MISCHE'", True)
55  Resume ExitProc
End Function

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2

'Public Function OEFFNE(strFilenameToOpen As String, _
'                       intDocumentOpenMode As Integer, _
'                       boolWordMaximizedAfterSessionClose As Boolean, _
'                       session As TC_Session) As Boolean
Public Function OEFFNE(strFilenameToOpen As String, _
                       intDocumentOpenMode As Integer, _
                       boolWordMaximizedAfterSessionClose As Integer, _
                       session As TC_Session) As Boolean
                       
10    On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
20    boolResult = True
30    Call Me.ParentIkolClientApp.ApplicationHandler.SetWordModeAfterWork(boolWordMaximizedAfterSessionClose, session)

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
40    session.Wordmodus = boolWordMaximizedAfterSessionClose

50    session.tcResult = Me.ParentIkolClientApp.FileHandler.OpenDocument(strFilenameToOpen, intDocumentOpenMode, session)
60    boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

'02.05.2014 AL
'in Abh|fffd|ngigkeit des 3. Parameters von "OEFFNE" (Wordmodus) wird maximiert oder normal dargestellt

'09.07.2014 AL
'statt application sollte doch wohl nur das TC-Dokument den window-state erhalten!
'window-state so |fffd|ndern:
  'ActiveDocument.ActiveWindow.WindowState = wdWindowStateMinimize
  'ActiveDocument.ActiveWindow.WindowState = wdWindowStateNormal
'das funktioniert, aber IKOLLeiste kommt nicht - nur mit Application.WindowState geht alles
70    Application.WindowState = wdWindowStateMinimize 'daf|fffd|r aus TC_FileHandler::OpenDucument entfernt
'ENDE 09.07.2014 AL

'80    If boolWordMaximizedAfterSessionClose = True Then
'90      Application.WindowState = wdWindowStateMaximize
'100   Else
'110     Application.WindowState = wdWindowStateNormal
'120   End If

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
80    Select Case (boolWordMaximizedAfterSessionClose)
        Case 0:
90        Application.WindowState = wdWindowStateNormal
100     Case 1:
110       Application.WindowState = wdWindowStateMaximize
120     Case 2:
130       Application.WindowState = wdWindowStateMinimize
140     Case Else:
150       Application.WindowState = wdWindowStateMinimize
160   End Select
'ENDE 22.07.2014 AL
'ENDE 02.05.2014 AL

ExitProc:
170   On Error Resume Next
180   OEFFNE = boolResult
190   Exit Function

RaiseErrorHandler:

200   session.tcResult = tcrEnd
210   boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "OEFFNE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'OEFFNE'", True)
220   Resume ExitProc
End Function

Public Function SCHLIESSE(closeFileName As String, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

15  session.tcResult = Me.ParentIkolClientApp.FileHandler.CloseDocumentByName(closeFileName, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
25  On Error Resume Next
30  SCHLIESSE = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "SCHLIESSE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'SCHLIESSE'", True)
50  Resume ExitProc
End Function

Public Function SPEICHERN_ALS(strNewFileName As String, _
                              strSaveAsControl As String, _
                              session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

    Dim strOldFileName As String

15  session.SaveNotTriggeredByWordButtons = True

20  With session
25      strOldFileName = .workingDocument.FullName
30      .tcResult = Me.ParentIkolClientApp.FileHandler.SaveDocumentAs(.workingDocument, strNewFileName, CInt(strSaveAsControl), session)
35      If .tcResult = tcrOK Then
40          Call session.WorkingDocumentNameChanged(strOldFileName)
45      End If
50  End With


55  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
60  On Error Resume Next
65  SPEICHERN_ALS = boolResult
70  Exit Function

RaiseErrorHandler:

75  session.tcResult = tcrEnd

80  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "SPEICHERN_ALS", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'SPEICHERN_ALS'", True)
85  Resume ExitProc
End Function

Public Function VERBINDE(strDataFileName As String, _
                         boolSpecVarsAllowed As Boolean, _
                         session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
10  boolResult = True

15  session.tcResult = Me.ParentIkolClientApp.FileHandler.JoinData(strDataFileName, boolSpecVarsAllowed, session)

20  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
25  On Error Resume Next
30  VERBINDE = boolResult
35  Exit Function

RaiseErrorHandler:
40  session.tcResult = tcrEnd
45  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "VERBINDE", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'VERBINDE'", True)
50  Resume ExitProc
End Function

Public Function SYNTAX_BESCHREIBUNG(strFileName As String, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler

    Dim boolResult As Boolean
10  boolResult = True

    Dim txtstreamSyntaxFile As TextStream

15  If Me.ParentIkolClientApp.LogfileHandler.OpenFileForWriting(strFileName, False, "Syntaxdatei wird nicht geschrieben", txtstreamSyntaxFile) Then
20      Call session.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription.WriteSyntaxDescription(txtstreamSyntaxFile)
25  End If
30  txtstreamSyntaxFile.Close

35  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
40  On Error Resume Next
45  SYNTAX_BESCHREIBUNG = boolResult
50  Set txtstreamSyntaxFile = Nothing
55  Exit Function

RaiseErrorHandler:
60  session.tcResult = tcrEnd

65  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "SYNTAX_BESCHREIBUNG", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'SYNTAX_BESCHREIBUNG'", True)
70  Resume ExitProc

End Function

Public Function UMW_FORMULAR_SERIENBRIEF(session As TC_Session) As Boolean
5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True

    Dim objTcDoc As TC_Document

15  objTcDoc = _
    session.ManagedTCDocumentsContainer.GetDocumentRecByFullFileName(session.workingDocument.FullName)
20  If Not objTcDoc Is Nothing Then
25      session.tcResult = _
        Me.ParentIkolClientApp.MailMergeHandler.ChangeFormDataToMailMergeFields(objTcDoc.Document, _
                                                                                session)
30  End If
35  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)

ExitProc:
40  On Error Resume Next
45  UMW_FORMULAR_SERIENBRIEF = boolResult
50  Set objTcDoc = Nothing
55  Exit Function

RaiseErrorHandler:
60  session.tcResult = tcrEnd
65  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", _
                                        "UMW_FORMULAR_SERIENBRIEF", , _
                                        "Ausf|fffd|hrung vom Befehls-Makro: 'UMW_FORMULAR_SERIENBRIEF'", True)

70  Resume ExitProc
End Function

Public Function ERSETZE(strSearchText As String, strTextToReplace As String, _
                        intReplaceMode As Integer, session As TC_Session) As Boolean

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
10  boolResult = True


    Dim boolReplaceInText As Boolean
    Dim boolReplaceInFields As Boolean
    Dim boolReplaceInWholeDocument As Boolean
    Dim boolConvertDirectoryNames As Boolean

    '    gesetztes Bit 0: Ersetzen im normalen Text,
    '    gesetztes Bit 1: Ersetzen in Feldfunktionen,
    '    gesetztes Bit 2: Ersetzen in allen Dokumentbereichen durchf|fffd|hren
    '    gesetztes Bit 3: Verzeichnisnamen. In der ersetzenden Zeichenkette vorher '\' durch '\\' ersetzen

15  boolReplaceInText = ((intReplaceMode And 1) <> 0)
20  boolReplaceInFields = ((intReplaceMode And 2) <> 0)
25  boolConvertDirectoryNames = ((intReplaceMode And 8) <> 0)
30  boolReplaceInWholeDocument = ((intReplaceMode And 16) <> 0)

35  session.tcResult = _
    Me.ParentIkolClientApp.DocumentHandler.ReplaceText(strSearchText, _
                                                       strTextToReplace, _
                                                       boolReplaceInText, _
                                                       boolReplaceInFields, _
                                                       boolReplaceInWholeDocument, _
                                                       boolConvertDirectoryNames, _
                                                       session)

40  boolResult = (session.tcResult = tcrOK Or session.tcResult = tcrWarning)
ExitProc:
45  On Error Resume Next
50  ERSETZE = boolResult
55  Exit Function

RaiseErrorHandler:
60  session.tcResult = tcrEnd
65  boolResult = DotCentralErrorHandler(Me.ParentIkolClientApp, "TC_SyntaxDescription", "ERSETZE", , "Ausf|fffd|hrung vom Befehls-Makro: 'ERSETZE'", True)
70  Resume ExitProc
End Function
Attribute VB_Name = "TC_Tools"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' zur Base64-Verschl|fffd|sselung
Private Const clOneMask = 16515072                    '000000 111111 111111 111111
Private Const clTwoMask = 258048                      '111111 000000 111111 111111
Private Const clThreeMask = 4032                      '111111 111111 000000 111111
Private Const clFourMask = 63                         '111111 111111 111111 000000

Private Const clHighMask = 16711680                   '11111111 00000000 00000000
Private Const clMidMask = 65280                       '00000000 11111111 00000000
Private Const clLowMask = 255                         '00000000 00000000 11111111

Private Const cl2Exp18 = 262144                       '2 to the 18th power
Private Const cl2Exp12 = 4096                         '2 to the 12th
Private Const cl2Exp6 = 64                            '2 to the 6th
Private Const cl2Exp8 = 256                           '2 to the 8th
Private Const cl2Exp16 = 65536                        '2 to the 16th

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_LogfileHandler.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Function CompareWindowTitles(title1 As String, title2 As String) As Boolean
    Dim lenTitle1 As Integer
    Dim lenTitle2 As Integer
    Dim minLength As Integer

5   lenTitle1 = Len(title1)
10  lenTitle2 = Len(title2)
15  minLength = lenTitle1
20  If minLength > lenTitle2 Then minLength = lenTitle2
25  If minLength > 0 Then
30      CompareWindowTitles = (Left(UCase(title1), minLength) = Left(UCase(title2), minLength))
35  Else
40      CompareWindowTitles = False
45  End If

End Function

' Public Sub WriteSystemInformationToLogfile(currDir As String, defaultPrinter As String, startTime As Double)
Public Sub WriteSystemInformationToLogfile()
    Dim currTimeStr As String
    Dim intWordVersion As Integer
    Dim versionStr As String
    Dim hardwareStr As String
    Dim MemorySize As Long
    Dim startTime As String

10    currTimeStr = time()
20    startTime = Hour(currTimeStr) * 60
30    startTime = (startTime + Minute(currTimeStr)) * 60
40    startTime = startTime + Second(currTimeStr)

50    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("StartDatum:                    " & Date)
60    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Startzeit:                     " & currTimeStr & " [" & startTime & "]")
70    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Aktuelles Arbeitsverzeichnis:  " & ThisDocument.Path)
80    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Aktueller Standarddrucker:     " & Me.ParentIkolClientApp.DefaultPrinterName)

90    intWordVersion = CInt(Mid(Application.Version, 1, 2))

100   Select Case intWordVersion
        Case 9
110         versionStr = "Word 2000"
120     Case 10
130         versionStr = "Word 2002/Word XP"
140     Case 11
150         versionStr = "Word 2003"
160     Case 12
170         versionStr = "Word 2007"
180     Case 13
190         versionStr = "bringt Ungl|fffd|ck-Version"
200     Case 14
210         versionStr = "Word 2010"
220     Case 15
230         versionStr = "Word 2013"
'22.02.2016 AL
'Anpassungen f|fffd|r MS-Word 2016
240     Case 16
250         versionStr = "Word 2016"
260     Case Else
270         versionStr = "nicht unterst|fffd|tze Version"
280   End Select

290   versionStr = versionStr & " (" & Application.Version & ")"
300   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Benutzte Word-Version:         " & versionStr & " Build:" & Application.build)
310   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Computername:                  " & Chr(34) & Environ("COMPUTERNAME") & Chr(34))
320   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Client Name:                   " & Chr(34) & Environ("CLIENTNAME") & Chr(34))
330   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Benutztes Betriebssystem:      " & GetOSVersion())

340   hardwareStr = GetLocalKeyValue("HARDWARE\DESCRIPTION\System\", "CentralProcessor\0\", "processorname")
350   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Prozessorname:                 " & hardwareStr)
360   hardwareStr = GetLocalKeyValue("HARDWARE\DESCRIPTION\System\", "CentralProcessor\0\", "identifier")

370   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Prozessorfamilie:              " & hardwareStr)
380   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Sessionname:                   " & Chr(34) & Environ("SESSIONNAME") & Chr(34))
390   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Nutzername:                    " & Chr(34) & Environ("USERNAME") & Chr(34))
400   Call Me.ParentIkolClientApp.LogfileHandler.ListAllOpenedWordDocuments(vbNullString)
410   Call Me.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine
End Sub

Public Function SamePrinter(strPrinterName1 As String, _
                            strPrinterName2 As String, _
                            boolWithLogging As Boolean) As Boolean

10    On Error GoTo RaiseErrorHandler

    Dim compLen As Integer
    Dim tmpPrinter1 As String
    Dim tmpPrinter2 As String
    Dim boolResult As Boolean

20    boolResult = False
30    tmpPrinter1 = UCase(strPrinterName1) 'strNewPrinterName 'PDFCreator_1 'dies ist der Drucker, der in der PYP angegeben wurde
40    tmpPrinter2 = UCase(strPrinterName2) 'ActivePrinter     'PDFCreator   'dies ist der Drucker, den das System sieht
50    compLen = Len(strPrinterName1)       'PDFCreator_1 = 12

'13.06.2016 AL
'Wenn strPrinterName1 als letzte Stelle ein '*' enth|fffd|lt, gilt folgender Ablauf.
'Somit ist gew|fffd|hrleistet, dass der Ablauf bei anderen Kunden gleich bleibt
'Betroffene Kunden:
'  1. Memmingen (Hr. Schwarz) - f|fffd|r diesen Kunden ist Fixing am 19.02.2016 gemacht worden, siehe unten
'  2. Zwickau (Hr. Hochmuth)  - f|fffd|r diesen Kunden ist Fixing am 13.06.2016 gemacht worden
'  3. Kreis-SLK (Fr. Fischer) - f|fffd|r diesen Kunden ist Fixing am 13.06.2016 gemacht worden
Dim lastChar As String
60    lastChar = Mid(strPrinterName1, Len(strPrinterName1), 1)
70    If lastChar = "*" And Len(strPrinterName1) > 1 Then
        'MsgBox "lastChar ist *"
80      compLen = Len(strPrinterName1) - 1
90      boolResult = (Mid(tmpPrinter1, 1, compLen) = Mid(tmpPrinter2, 1, compLen))
100     If boolResult Then
110       GoTo ExitProc
120     End If
130   End If
'ENDE 13.06.2016 AL


'19.02.2016 AL
'Drucker wurde NICHT gewechselt, wenn der Druckername des einen Druckers komplett im zweiten Druckernamen enthalten ist
140   If compLen > Len(strPrinterName2) Then compLen = Len(strPrinterName2) 'JA: --> 10!!!!
150   If boolWithLogging Then
'alt:       Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("SamePrinter:    Vergleich von Printer1 [" & strPrinterName1 & "]-(" & Mid(tmpPrinter1, 1, compLen) & ")")
'alt:       Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("                          mit Printer2 [" & strPrinterName2 & "]-(" & Mid(tmpPrinter2, 1, compLen) & ")")
160     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("SamePrinter:    Vergleich von Printer1 [" & strPrinterName1 & "]-(" & tmpPrinter1 & ")")
170     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("                          mit Printer2 [" & strPrinterName2 & "]-(" & tmpPrinter2 & ")")
180   End If
190   If compLen = 0 Then
200     boolResult = (tmpPrinter1 = tmpPrinter2)
210   Else
'alt:       boolResult = (Mid(tmpPrinter1, 1, compLen) = Mid(tmpPrinter2, 1, compLen))
220   boolResult = (tmpPrinter1 = tmpPrinter2)
230   End If

ExitProc:
240   SamePrinter = boolResult
250   Exit Function

RaiseErrorHandler:
260   boolResult = False
270   Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::SamePrinter in Zeile:" & Erl & vbCrLf, Err.Description
280   Resume ExitProc
End Function

Public Function TabbedYN(value As Boolean, Length As Long) As String
    Dim tmpStr As String
5   If value Then
10      tmpStr = "Ja"
15  Else
20      tmpStr = "Nein"
25  End If
30  TabbedYN = Me.TabbedText(tmpStr, Length)
End Function

Public Function BoolToStr(val As Boolean) As String
5   If val Then
10      BoolToStr = "True"
15  Else
20      BoolToStr = "False"
25  End If
End Function

Public Function TabbedText(str As String, Length As Long) As String
5   TabbedText = Left(str & Space(Length), Length)
End Function

Public Function RightTabbedText(str As String, Length As Long) As String
5   RightTabbedText = Right(Space(Length) & str, Length)
End Function

Public Function NormalizedPathWithSeparator(dirName As String) As String
    Dim tmpString As String
    Dim sepStr As String

5   sepStr = Application.PathSeparator
10  tmpString = dirName & sepStr
15  NormalizedPathWithSeparator = Me.NormalizedFileNameWithSeparator(tmpString)
End Function

Public Function NormalizedFileNameWithSeparator(filename As String) As String
    Dim tmpString As String
    Dim replStr As String
    Dim searchStr As String
    Dim isUNCPath As Boolean

5   On Error GoTo RaiseErrorHandler


10  searchStr = Application.PathSeparator & Application.PathSeparator
15  replStr = Application.PathSeparator
20  isUNCPath = (Left(filename, 2) = searchStr) And (Len(filename) > 2)
25  tmpString = filename
30  Do While InStr(1, tmpString, searchStr, vbTextCompare) > 0
35      tmpString = Replace(tmpString, searchStr, replStr, , , vbTextCompare)
40  Loop
45  If isUNCPath Then
50      tmpString = Application.PathSeparator & tmpString
55  End If

ExitProc:
60  NormalizedFileNameWithSeparator = tmpString
65  Exit Function

RaiseErrorHandler:
70  tmpString = vbNullString
75  Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::NormalizedFileNameWithSeparator in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc

End Function

Public Function RealString(zeroDelimitedStr As String) As String

5   On Error GoTo RaiseErrorHandler

    Dim Pos As Integer

10  Pos = InStr(1, zeroDelimitedStr, Chr(0))
15  If Pos > 0 Then
20      RealString = Left(zeroDelimitedStr, Pos - 1)
25  Else
30      RealString = zeroDelimitedStr
35  End If

ExitProc:
40  Exit Function

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::RealString in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc

End Function

Public Function RemoveQuotes(ByVal parm As String) As String

5   On Error GoTo RaiseErrorHandler

10  If Mid(parm, 1, 1) = Chr(34) Then
15      If Mid(parm, Len(parm), 1) = Chr(34) Then
20          parm = Mid(parm, 2, Len(parm) - 2)
25      End If
30  End If
35  RemoveQuotes = parm

ExitProc:
40  Exit Function

RaiseErrorHandler:
45  Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::RemoveQuotes in Zeile:" & Erl & vbCrLf, Err.Description
50  Resume ExitProc


End Function

Public Function GetInfoForPID(objSession As TC_Session, WndHwnd As Long, title As String) As TC_SessionResult
5   On Error GoTo RaiseErrorHandler

    Dim i As Integer
    Dim returnVal As Long
    Dim tcResult As TC_SessionResult

10  ReDim WindowsListForID(0)

15  tcResult = tcrFokusError

20  returnVal = EnumWindows(AddressOf ToolsEnumProc, 0)

25  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Suche nach ProcessId " & objSession.ApplicationPID, objSession)
30  Call Me.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine
35  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("Liste der gefundenen Prozesse:", objSession)
40  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("==============================", objSession)
45  Call Me.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine
50  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll(TabbedText("PID", 6) & _
                                                           TabbedText("Hwnd", 10) & _
                                                           TabbedText("Creator", 9) & _
                                                           "Fenstertitel", objSession)

55  For i = LBound(WindowsListForID) To UBound(WindowsListForID)
60      With WindowsListForID(i)
65          Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll( _
                 Me.ParentIkolClientApp.Tools.TabbedText(vbNullString & .WndPID, 6) & _
                 Me.ParentIkolClientApp.Tools.TabbedText(vbNullString & .WndHwnd, 10) & _
                 Me.ParentIkolClientApp.Tools.TabbedText(vbNullString & .WndCreator, 9) & _
                 .WndText, objSession)
70      End With
75  Next i

80  Call Me.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine

85  For i = LBound(WindowsListForID) To UBound(WindowsListForID)
90      With WindowsListForID(i)
95          If objSession.ApplicationPID = .WndPID Then
100             If Me.ParentIkolClientApp.Tools.CompareWindowTitles(.WndText, objSession.CallingApplName) Then
105                 WndHwnd = .WndHwnd
110                 title = .WndText
115                 tcResult = tcrOK
120                 Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("gesuchte ProcessId " & objSession.ApplicationPID & _
                                                                         " gefunden zugeh|fffd|riges Fensterhandle ist " & WndHwnd & _
                                                                         " mit dem Fenstertitel " & Chr(34) & .WndText & Chr(34) & vbCrLf, _
                                                                           objSession)
125                 GoTo ExitProc
130             End If
135         End If
140     End With
145 Next i

ExitProc:
150 GetInfoForPID = tcResult
155 Exit Function

RaiseErrorHandler:
160 GetInfoForPID = tcrFokusError
165 Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::GetInfoForPID in Zeile:" & Erl & vbCrLf, Err.Description
170 Resume ExitProc
End Function

Public Function GetTemporaryFolder()

    Dim sFolder As String                             ' Name of the folder
    Dim lRet As Long                                  ' Return Value
    Const MAX_PATH = 1024

5   sFolder = String(MAX_PATH, 0)
10  lRet = GetTempPath(MAX_PATH, sFolder)

15  If lRet <> 0 Then
20      GetTemporaryFolder = Left(sFolder, InStr(sFolder, Chr(0)) - 1)
25  Else
30      GetTemporaryFolder = vbNullString
35  End If

End Function

Public Function generateRandomNumber(ByVal lngLowerBound As Long, ByVal lngUpperBound As Long) As Long
5   generateRandomNumber = CLng(((lngUpperBound - lngLowerBound + 1) * Rnd) + lngLowerBound)
End Function

Public Function boolDoesDocumentVariableExist(ByVal objDoc As Document, ByVal strVariableName As String) As Boolean
    ' |fffd|berpr|fffd|ft, ob eine Variable im Dokument gespeichert ist,
    ' am meisten bei der Identifizierung eines Dokuments als ein TC_Doc

5   On Error GoTo RaiseErrorHandler
    Dim boolResult As Boolean
    Dim strFoobar As String

10  boolResult = True
    ' einfach gleichsetzen , um auf die Variable zugreifen zu k|fffd|nnen
15  strFoobar = objDoc.Variables(strVariableName).value

ExitProc:
20  boolDoesDocumentVariableExist = boolResult
25  Exit Function

RaiseErrorHandler:
30  boolResult = False
35  Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::boolDoesDocumentVariableExist in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc

End Function

Public Function SaveUserWindowPosition(userWindow As Window, strDocName As String) As Boolean
    Dim boolRetValue As Boolean
    Dim strSection As String
    Dim boolReturn As Boolean

5   On Error GoTo RaiseErrorHandler

10  boolReturn = False

15  strSection = REG_SignatureSection & "\" & strDocName
20  boolRetValue = WriteCurrentUserRegValue(strSection, wndKeyLeft, CStr(userWindow.Left)) And _
                   WriteCurrentUserRegValue(strSection, wndKeyTop, CStr(userWindow.Top)) And _
                   WriteCurrentUserRegValue(strSection, wndKeyHeight, CStr(userWindow.height)) And _
                   WriteCurrentUserRegValue(strSection, wndKeyWidth, CStr(userWindow.width)) And _
                   WriteCurrentUserRegValue(strSection, wndKeyState, CStr(userWindow.WindowState)) And _
                   WriteCurrentUserRegValue(strSection, wndKeyZoom, CStr(userWindow.Panes(1).View.Zoom.PageFit)) And _
                   WriteCurrentUserRegValue(strSection, wndKeyZoomFactor, CStr(userWindow.Panes(1).View.Zoom.Percentage))

25  If boolRetValue Then
30      strSection = REG_SignatureSection
35      boolRetValue = WriteCurrentUserRegValue(strSection, wndKeyLeft, CStr(userWindow.Left)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyTop, CStr(userWindow.Top)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyHeight, CStr(userWindow.height)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyWidth, CStr(userWindow.width)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyState, CStr(userWindow.WindowState)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyZoom, CStr(userWindow.Panes(1).View.Zoom.PageFit)) And _
                       WriteCurrentUserRegValue(strSection, wndKeyZoomFactor, CStr(userWindow.Panes(1).View.Zoom.Percentage))
40      boolReturn = True
45  End If

ExitProc:
50  SaveUserWindowPosition = boolReturn
55  Exit Function

RaiseErrorHandler:
60  boolReturn = False
65  Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::SaveUserWindowPosition" & " in Zeile:" & Erl & vbCrLf, Err.Description
70  Resume ExitProc
End Function

Public Function CenterDlgVertical(Top As Integer, height As Integer)
    Dim wnd As Window

5   Set wnd = Application.ActiveWindow
10  CenterDlgVertical = wnd.Top + (wnd.height - height) / 2
15  Set wnd = Nothing
End Function

Public Function CenterDlgHorizontal(Left As Integer, width As Integer)
    Dim wnd As Window

5   Set wnd = Application.ActiveWindow
10  CenterDlgHorizontal = wnd.Left + (wnd.width - width) / 2
15  Set wnd = Nothing
End Function

Public Sub SetHeightAndWidthFromInlineShape(ish As InlineShape, _
                                            height As Integer, _
                                            width As Integer)
10    On Error GoTo RaiseErrorHandler

    Dim wordVersion As Integer

    ' zur|fffd|ckgegeben wird die H|fffd|he und Breite des Inlineshapes in points
    ' in Word 2003 werden die H|fffd|he und die Breite des Bildes direkt gespeichert
    ' in Word 2010 werden die H|fffd|he und die Breite des Bildes als Anzeigegr|fffd||fffd|e gespeichert und der
    ' Scalefactor kann zum Ausrechnen der wahren Bildgr|fffd||fffd|e benutzt werden.
    ' die L|fffd|ngen werden in Points, d.h. Bildschirmpunkten zur|fffd|ckgegeben.

20    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Ausf|fffd|hrung TC_Tools:SetHeightAndWidthFromInlineShapeSetHeightAndWidthFromInlineShape")

30    With ish
'15.09.2014 AL auskommentiert, da hier aus unverst|fffd|ndlichen Gr|fffd|nden bei CH Absturz
        'Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.height = " & .height)
        'Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.width = " & .width)
        'Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.ScaleHeight = " & .ScaleHeight)
        'Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.ScaleWidth = " & .ScaleWidth)
40    End With

50    wordVersion = CInt(Mid(Application.Version, 1, 2))
60    Select Case wordVersion
        Case 9                                        ' Word 2000
70          height = ish.height
80          width = ish.width
90      Case 10                                       ' Word 2002/Word XP"
100         height = ish.height
110         width = ish.width
120     Case 11                                       ' Word 2003"
130         height = ish.height
140         width = ish.width
150     Case 12                                       ' Word 2007"
160         height = ish.height
170         width = ish.width
180     Case 13                                       ' bringt Ungl|fffd|ck-Version"
190         height = ish.height
200         width = ish.width
210     Case 14                                       ' Word 2010"
220         height = ish.height
230         width = ish.width
240     Case 15                                       ' Word 2013"
250         height = ish.height
260         width = ish.width
'22.02.2016 AL
'Anpassungen f|fffd|r MS-Word 2016
270     Case 16                                       ' Word 2016"
280         height = ish.height
290         width = ish.width
300     Case Else                                     ' nicht unterst|fffd|tze Version"
310         height = ish.height
320         width = ish.width
330   End Select

340   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("SetHeightAndWidthFromInlineShape gibt zur|fffd|ck")
350   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    Height = " & height)
360   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    Width = " & width)

ExitProc:
370   Exit Sub

RaiseErrorHandler:
380   Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::SetHeightAndWidthFromInlineShape" & " in Zeile:" & Erl & vbCrLf, Err.Description
390   Resume ExitProc
End Sub

Public Sub SetInlineShapeProperties(sign As TC_Signature, _
                                    ish As InlineShape, _
                                    scaleFactor As Integer, _
                                    setSign As Boolean)
    Dim wordVersion As Integer
10    On Error GoTo RaiseErrorHandler


20    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("Starte Ausf|fffd|hrung TC_Tools:SetInlineShapeProperties")
30    With ish
40      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    Sign.Signheight         = " & sign.SignHeight)
50      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    Sing.Signwidth          = " & sign.SignWidth)
60      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.height      = " & .height)
70      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.width       = " & .width)
80      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.ScaleHeight = " & .ScaleHeight)
90      Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.ScaleWidth  = " & .ScaleWidth)
100     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    SetSign                 = " & setSign)
110     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    scaleFactor             = " & scaleFactor)
120   End With

130   wordVersion = CInt(Mid(Application.Version, 1, 2))

140   If setSign Then
150     Select Case wordVersion
            Case 9                                    ' Word 2000
160             ish.height = sign.SignHeight
170             ish.width = sign.SignWidth
180             ish.ScaleHeight = 100
190             ish.ScaleWidth = 100
200         Case 10                                   ' Word 2002/Word XP"
210             ish.height = sign.SignHeight
220             ish.width = sign.SignWidth
230             ish.ScaleHeight = 100
240             ish.ScaleWidth = 100
250         Case 11                                   ' Word 2003"
                '           ish.height = Round((sign.SignHeight * sign.SignOriginScaleHeight) / 100)
                '           ish.width = Round((sign.SignWidth * sign.SignOriginScaleWidth) / 100)
260             ish.ScaleHeight = 100 / scaleFactor
270             ish.ScaleWidth = 100 / scaleFactor
280         Case 12                                   ' Word 2007"
290             ish.height = sign.SignHeight
300             ish.width = sign.SignWidth
                'scale-Werte sind immer 0 oder irgendein Wert |fffd|hnlich 0
                '           ish.ScaleHeight = sign.SignOriginScaleHeight
                '           ish.ScaleWidth = sign.SignOriginScaleWidth
310             ish.ScaleHeight = 100 / scaleFactor
320             ish.ScaleWidth = 100 / scaleFactor
330         Case 13                                   ' bringt Ungl|fffd|ck-Version"
340             ish.height = sign.SignHeight
350             ish.width = sign.SignWidth
360             ish.ScaleHeight = 100
370             ish.ScaleWidth = 100
380         Case 14                                   ' Word 2010"
390             ish.height = sign.SignHeight
400             ish.width = sign.SignWidth
                '           ish.ScaleHeight = 100
                '           ish.ScaleWidth = 100
410         Case 15                                   ' Word 2013"
420             ish.height = sign.SignHeight
430             ish.width = sign.SignWidth
'22.02.2016 AL
'Anpassungen f|fffd|r MS-Word 2016
440         Case 16                                   ' Word 2016"
450             ish.height = sign.SignHeight
460             ish.width = sign.SignWidth
470         Case Else                                 ' nicht unterst|fffd|tze Version"
480             ish.height = sign.SignHeight
490             ish.width = sign.SignWidth
500             ish.ScaleHeight = 100
510             ish.ScaleWidth = 100
520     End Select
530   Else
540     Select Case wordVersion
            Case 9                                    ' Word 2000
550         Case 10                                   ' Word 2002/Word XP"
560         Case 11                                   ' Word 2003"
570             ish.ScaleHeight = sign.SignOriginScaleHeight
580             ish.ScaleWidth = sign.SignOriginScaleWidth
590         Case 12                                   ' Word 2007"
600             ish.height = sign.SignHeight
610             ish.width = sign.SignWidth
                '           ish.ScaleHeight = sign.SignOriginScaleHeight
                '           ish.ScaleWidth = sign.SignOriginScaleWidth
620         Case 13                                   ' bringt Ungl|fffd|ck-Version"
630         Case 14                                   ' Word 2010"
640             ish.height = sign.SignHeight
650             ish.width = sign.SignWidth
                '           ish.ScaleHeight = 100
                '           ish.ScaleWidth = 100
660         Case 15                                   ' Word 2013"
670         Case Else                                 ' nicht unterst|fffd|tze Version"
680     End Select
690   End If

700   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("SetInlineShapeProperties hat folgende Werte gesetzt")
710   With ish
720     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.height      = " & .height)
730     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.width       = " & .width)
740     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.ScaleHeight = " & .ScaleHeight)
750     Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("    InlineShape.ScaleWidth  = " & .ScaleWidth)
760   End With

ExitProc:
770   Exit Sub

RaiseErrorHandler:
780   Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::SetInlineShapeProperties" & " in Zeile:" & Erl & vbCrLf, Err.Description
790   Resume ExitProc

End Sub

'findet ein Top-level-window der gegebenen Class und Caption
'der zu dieser Word-Instanz geh|fffd|rt, indem die Prozess-ID gegen|fffd|bergestellt werden

Public Function FindOurWindow( _
       Optional sClass As String = vbNullString, _
       Optional sCaption As String = vbNullString)

    Dim hWndDesktop As Long
    Dim hwnd As Long
    Dim hProcThis As Long
    Dim hProcWindow As Long

    'die Prozess-ID von dieser Word-Instanz ermitteln
5   hProcThis = GetCurrentProcessId

    ' alle Top-level-windows sind Kinder vom Desktop, also nehme diesen Handle zuerst
10  hWndDesktop = GetDesktopWindow
15  Do
        ' finde das n|fffd|chste Kinder-Window vom Desktop, das die gesuchten Class und/oder Caption hat
        ' beim ersten Durchlauf wird hWnd Null sein, sodass wir das erste passende Window nehmen;
        ' jede Iteration |fffd|bergibt der Window-Handle, den wir in der vorhergehenden Iteration gefunden haben,
        ' und schnappt sich den n|fffd|chsten (wenn es den gibt)

20      hwnd = FindWindowEx(hWndDesktop, hwnd, sClass, _
                            sCaption)

        ' die Prozess-ID, die das Window steuert, ermitteln
25      GetWindowThreadProcessId hwnd, hProcWindow

        ' iteriere solange der Window-Prozess mit diesem Prozess
        ' |fffd|bereinstimmt oder wir konnten kein Window finden
30  Loop Until hProcWindow = hProcThis Or hwnd = 0

    'Zur|fffd|ckgeben vom gedundenen Handle
35  FindOurWindow = hwnd
End Function


Public Function dhXORText(strText As String) As String

5   On Error GoTo RaiseErrorHandler

    ' verschl|fffd|sseln und entschl|fffd|sseln von Strings
    Dim byteText() As Byte
    Dim bytePWD() As Byte
    '    Dim intPWDPos As Integer
    '    Dim intPWDLen As Integer
    '    Dim intChar As Integer
    Dim longPWDPos As Long
    Dim longPWDLen As Long
    Dim longChar As Long
    Dim strPWD As String

10  strPWD = CStr(CLng(Rnd * (2 ^ 31)))

15  byteText = strText
20  bytePWD = strPWD
25  longPWDLen = LenB(strPWD)

30  For longChar = 0 To LenB(strText) - 1
        ' die n|fffd|chste Zahl zwischen 0 and longPWDLen - 1
35      longPWDPos = (longChar Mod longPWDLen)
40      byteText(longChar) = byteText(longChar) Xor _
                             bytePWD(longPWDPos)
45  Next longChar

50  dhXORText = byteText

ExitProc:
55  Exit Function

RaiseErrorHandler:
60  Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::dhXORText" & " in Zeile:" & Erl & vbCrLf, Err.Description
65  Resume ExitProc

End Function

Public Function Encode64(sString As String) As String

5   On Error GoTo RaiseErrorHandler

    Dim bTrans(63) As Byte, lPowers8(255) As Long, lPowers16(255) As Long, bOut() As Byte, bIn() As Byte
    Dim lChar As Long, lTrip As Long, iPad As Integer, lLen As Long, lTemp As Long, lPos As Long, lOutSize As Long

10  For lTemp = 0 To 63                               'Fill the translation table.
15      Select Case lTemp
            Case 0 To 25
20              bTrans(lTemp) = 65 + lTemp            'A - Z
25          Case 26 To 51
30              bTrans(lTemp) = 71 + lTemp            'a - z
35          Case 52 To 61
40              bTrans(lTemp) = lTemp - 4             '1 - 0
45          Case 62
50              bTrans(lTemp) = 43                    'Chr(43) = "+"
55          Case 63
60              bTrans(lTemp) = 47                    'Chr(47) = "/"
65      End Select
70  Next lTemp

75  For lTemp = 0 To 255                              'Fill the 2^8 and 2^16 lookup tables.
80      lPowers8(lTemp) = lTemp * cl2Exp8
85      lPowers16(lTemp) = lTemp * cl2Exp16
90  Next lTemp

95  iPad = Len(sString) Mod 3                         'See if the length is divisible by 3
100 If iPad Then                                      'If not, figure out the end pad and resize the input.
105     iPad = 3 - iPad
110     sString = sString & String(iPad, Chr(0))
115 End If

120 bIn = StrConv(sString, vbFromUnicode)             'Load the input string.
125 lLen = ((UBound(bIn) + 1) \ 3) * 4                'Length of resulting string.
130 lTemp = lLen \ 72                                 'Added space for vbCrLfs.
135 lOutSize = ((lTemp * 2) + lLen) - 1               'Calculate the size of the output buffer.
140 ReDim bOut(lOutSize)                              'Make the output buffer.

145 lLen = 0                                          'Reusing this one, so reset it.

150 For lChar = LBound(bIn) To UBound(bIn) Step 3
155     lTrip = lPowers16(bIn(lChar)) + lPowers8(bIn(lChar + 1)) + bIn(lChar + 2)    'Combine the 3 bytes
160     lTemp = lTrip And clOneMask                   'Mask for the first 6 bits
165     bOut(lPos) = bTrans(lTemp \ cl2Exp18)         'Shift it down to the low 6 bits and get the value
170     lTemp = lTrip And clTwoMask                   'Mask for the second set.
175     bOut(lPos + 1) = bTrans(lTemp \ cl2Exp12)     'Shift it down and translate.
180     lTemp = lTrip And clThreeMask                 'Mask for the third set.
185     bOut(lPos + 2) = bTrans(lTemp \ cl2Exp6)      'Shift it down and translate.
190     bOut(lPos + 3) = bTrans(lTrip And clFourMask)    'Mask for the low set.
195     If lLen = 68 Then                             'Ready for a newline
200         bOut(lPos + 4) = 13                       'Chr(13) = vbCr
205         bOut(lPos + 5) = 10                       'Chr(10) = vbLf
210         lLen = 0                                  'Reset the counter
215         lPos = lPos + 6
220     Else
225         lLen = lLen + 4
230         lPos = lPos + 4
235     End If
240 Next lChar

245 If bOut(lOutSize) = 10 Then lOutSize = lOutSize - 2    'Shift the padding chars down if it ends with CrLf.

250 If iPad = 1 Then                                  'Add the padding chars if any.
255     bOut(lOutSize) = 61                           'Chr(61) = "="
260 ElseIf iPad = 2 Then
265     bOut(lOutSize) = 61
270     bOut(lOutSize - 1) = 61
275 End If

280 Encode64 = StrConv(bOut, vbUnicode)               'Convert back to a string and return it.

ExitProc:
285 Exit Function

RaiseErrorHandler:
290 Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::Encode64" & " in Zeile:" & Erl & vbCrLf, Err.Description
295 Resume ExitProc
End Function

Public Function Decode64(sString As String) As String

10    On Error GoTo RaiseErrorHandler

    Dim bOut() As Byte, bIn() As Byte, bTrans(255) As Byte, lPowers6(63) As Long, lPowers12(63) As Long
    Dim lPowers18(63) As Long, lQuad As Long, iPad As Integer, lChar As Long, lPos As Long, sOut As String
    Dim lTemp As Long

20    sString = Replace(sString, vbCr, vbNullString)    'Get rid of the vbCrLfs.  These could be in...
30    sString = Replace(sString, vbLf, vbNullString)    'either order.

40    lTemp = Len(sString) Mod 4                        'Test for valid input.
50    If lTemp Then
60      Call Err.Raise(vbObjectError, "MyDecode", "Input string is not valid Base64.")
70    End If

80    If InStrRev(sString, "==") Then                   'InStrRev is faster when you know it's at the end.
90      iPad = 2                                      'Note:  These translate to 0, so you can leave them...
100   ElseIf InStrRev(sString, "=") Then                'in the string and just resize the output.
110     iPad = 1
120   End If

130   For lTemp = 0 To 255                              'Fill the translation table.
140     Select Case lTemp
            Case 65 To 90
150             bTrans(lTemp) = lTemp - 65            'A - Z
160         Case 97 To 122
170             bTrans(lTemp) = lTemp - 71            'a - z
180         Case 48 To 57
190             bTrans(lTemp) = lTemp + 4             '1 - 0
200         Case 43
210             bTrans(lTemp) = 62                    'Chr(43) = "+"
220         Case 47
230             bTrans(lTemp) = 63                    'Chr(47) = "/"
240     End Select
250   Next lTemp

260   For lTemp = 0 To 63                               'Fill the 2^6, 2^12, and 2^18 lookup tables.
270     lPowers6(lTemp) = lTemp * cl2Exp6
280     lPowers12(lTemp) = lTemp * cl2Exp12
290     lPowers18(lTemp) = lTemp * cl2Exp18
300   Next lTemp

310   bIn = StrConv(sString, vbFromUnicode)             'Load the input byte array.
320   ReDim bOut((((UBound(bIn) + 1) \ 4) * 3) - 1)     'Prepare the output buffer.

330   For lChar = 0 To UBound(bIn) Step 4
340     lQuad = lPowers18(bTrans(bIn(lChar))) + lPowers12(bTrans(bIn(lChar + 1))) + _
                lPowers6(bTrans(bIn(lChar + 2))) + bTrans(bIn(lChar + 3))    'Rebuild the bits.
350     lTemp = lQuad And clHighMask                  'Mask for the first byte
360     bOut(lPos) = lTemp \ cl2Exp16                 'Shift it down
370     lTemp = lQuad And clMidMask                   'Mask for the second byte
380     bOut(lPos + 1) = lTemp \ cl2Exp8              'Shift it down
390     bOut(lPos + 2) = lQuad And clLowMask          'Mask for the third byte
400     lPos = lPos + 3
410   Next lChar

420   sOut = StrConv(bOut, vbUnicode)                   'Convert back to a string.
430   If iPad Then sOut = Left$(sOut, Len(sOut) - iPad)    'Chop off any extra bytes.
440   Decode64 = sOut

ExitProc:
450   Exit Function

RaiseErrorHandler:
460   Err.Raise Err.Number, Err.Source & "->" & "TC_Tools::Decode64" & " in Zeile:" & Erl & vbCrLf, Err.Description
470   Resume ExitProc
End Function

'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
Public Function HideTray()
        Dim hwnd, startButton As Long

10      hwnd = FindWindow("Shell_TrayWnd", "")
20      startButton = FindWindow("Button", "Start")
30      SetWindowPos hwnd, 0&, 0&, 0&, 0&, 0&, SWP_HIDEWINDOW 'Taskleiste verstecken
40      ShowWindow startButton, SW_HIDE                       'Start-Button verstecken

End Function
 
'22.07.2014 AL
'neuer Wert f|fffd|r 3. Parameter beim OEFFNE-Befehl: OEFFNE file,1,2 --> neu ist hier der Wert 2
Public Function ShowTray()
        Dim hwnd, startButton As Long

'Taskleiste einblenden
  hwnd = FindWindow("Shell_TrayWnd", "")
  startButton = FindWindow("Button", "Start")
  
  'hiermit kommt Taskleiste kurz hoch
  'SetWindowPos hwnd, 0&, 0&, 0&, 0&, 0&, SWP_SHOWWINDOW 'Taskleiste anzeigen
  'ShowWindow startButton, SW_RESTORE                    'Start-Button anzeigen
  
  'hiermit Taskleiste wieder minimiert
  ShowWindow hwnd, SW_SHOWNA                           'Taskleiste anzeigen
  ShowWindow startButton, SW_SHOWNA                    'Start-Button anzeigen
End Function
Attribute VB_Name = "TC_WEInstruction"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Dieses Klassenmodul verwaltet die Beschreibung eines einzelnen Makros der Office-Schnittstelle 2.0
' in der WE-Datei und entspricht einer Zeile in ihr

' Eigenschaften eines Objektes TC_WEInstruction
'    .MakroName as String               : enth|fffd|lt den Namen des Makros in der WE-Datei, nicht caseSensitiv
'    .WEInstructionMacro as String      : enth|fffd|lt den Aufrufnamen mit Modul und Makronamen des aufzurufenden Makros
'    .CommandoText as String            : enth|fffd|lt eine Beschreibung des Makros
'    .ParameterCount as Integer         : enth|fffd|lt die Anzahl der Parameter f|fffd|r diesen Befehl an.
'
'Methoden f|fffd|r dieses Objekt
'    .AddParameter(parameterObjekt)     : f|fffd|t einen Parameter zur Kommandobeschreibung hinzu
'    .GetParameterByName(ParameterName) : ist der Name des Parameters bekannt, so kann er |fffd|ber den Namen gefunden tcrden
'    .GetParameter(index)               : gibt die Parameterbeschreibung des i-ten Parameters an.
'
Private mstrMakroName As String
Private mcolParameters As Collection
Private mstrCommandText As String
Private mobjParentSession As TC_Session

Private Sub Class_Initialize()
5   Set mcolParameters = New Collection
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Property Get ParentSession() As TC_Session
5   Set ParentSession = mobjParentSession
End Property

Public Property Set ParentSession(objParentSession As TC_Session)
5   If mobjParentSession Is Nothing Then
10      Set mobjParentSession = objParentSession
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_WEInstruction.ParentSession", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Sub CleanUp()
5   If Not mcolParameters Is Nothing Then
10      Set mcolParameters = Nothing
15  End If

20  If Not mobjParentSession Is Nothing Then
25      Set mobjParentSession = Nothing
30  End If
End Sub

Public Property Let makroName(ByVal vMakroName As String)
5   mstrMakroName = vMakroName
End Property

Public Property Get makroName() As String
5   makroName = mstrMakroName
End Property

Public Property Let CommandoText(ByVal cmdText As String)
5   mstrCommandText = cmdText
End Property

Public Property Get CommandoText() As String
5   CommandoText = mstrCommandText
End Property

Public Property Get ParameterCount() As Integer
5   ParameterCount = mcolParameters.count
End Property

Public Sub AddParameter(ByVal parameter As TC_ParameterDescription)
    ' Diese Prozedur muss in der Reihenfolge der auftretenden Parameter erfolgen
5   mcolParameters.Add parameter
End Sub


Public Function GetParameterByName(ParameterName As String) As TC_ParameterDescription

5   On Error GoTo RaiseErrorHandler

    Dim i As Integer
10  i = 1
15  Do
20      If mcolParameters(i).makroName = UCase(ParameterName) Then
25          Exit Do
30      End If
35      i = i + 1
40  Loop Until i > mcolParameters.count

45  If i > mcolParameters.count Then
50      GetParameterByName = Nothing
55  Else
60      GetParameterByName = mcolParameters(i)
65  End If

ExitProc:
70  Exit Function

RaiseErrorHandler:
75  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::GetParameterByName in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Function


Public Function GetParameter(index As Integer) As TC_ParameterDescription

5   On Error GoTo RaiseErrorHandler

10  If index > mcolParameters.count Then
15      GetParameter = Nothing
20  Else
25      Set GetParameter = mcolParameters.Item(index)
30  End If

ExitProc:
35  Exit Function

RaiseErrorHandler:
40  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::GetParameter in Zeile:" & Erl & vbCrLf, Err.Description
45  Resume ExitProc

End Function


Public Function GetCommandoDescriptonAsText() As String
    Dim tmpStr As String
    Dim parmDescr As TC_ParameterDescription
    Dim endStr As String
    Dim parmStr As String
    Dim kommaStr As String
    Dim tabStr As String
    Dim strResult As String

5   On Error GoTo RaiseErrorHandler


10  kommaStr = vbNullString
15  endStr = vbNullString
20  parmStr = vbNullString

25  strResult = vbNullString
30  If mcolParameters.count > 0 Then
35      For Each parmDescr In mcolParameters
40          tmpStr = parmDescr.ParameterName
45          If parmDescr.OptionalParameter Then
50              kommaStr = "[" & kommaStr
55              endStr = endStr & "]"
60          End If
65          parmStr = parmStr & kommaStr & tmpStr
70          kommaStr = ", "
75      Next parmDescr
80      parmStr = " ( " & parmStr & endStr & " )"
85  End If

90  tmpStr = Replace(mstrCommandText, vbLf, vbLf & "                  ")
95  strResult = mstrMakroName & parmStr & vbLf & _
              "    " & "Beschreibung: " & tmpStr

100 If mcolParameters.count > 0 Then
105     strResult = strResult & vbLf & "    " & "Parameter:   "
110     tabStr = " "
115     For Each parmDescr In mcolParameters
120         tmpStr = Replace(parmDescr.ParameterText, vbLf, vbLf & "                       ")
125         strResult = strResult & tabStr & _
                        parmDescr.ParameterName & "(" & _
                        parmDescr.GetParameterDescription & ") - " & tmpStr & vbLf
130         tabStr = "                  "
135     Next parmDescr
140 Else
145     strResult = strResult & vbLf
150 End If

ExitProc:
155 GetCommandoDescriptonAsText = strResult
160 Set parmDescr = Nothing
165 Exit Function

RaiseErrorHandler:
170 Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::GetCommandoDescriptonAsText in Zeile:" & Erl & vbCrLf, Err.Description
175 Resume ExitProc

End Function


Private Sub AnalyzeBooleanString(parm As String, _
                                 idx As Integer, _
                                 currParm As TC_ParameterDescription, _
                                 parmOk As Boolean, _
                                 errorMsg As String)

5   On Error GoTo RaiseErrorHandler

10  errorMsg = vbNullString
15  parmOk = (parm = "0") Or (parm = "1")

20  If Not parmOk Then
25      errorMsg = "  Fehler bei Befehl " & Chr(34) & mstrMakroName & Chr(34) & vbLf & _
                 "    Parameter(" & idx & ")=[" & parm & "] darf nur die Werte 0 und 1 annehmen"
30  End If


ExitProc:
35  Exit Sub

RaiseErrorHandler:
40  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeBooleanString in Zeile:" & Erl & vbCrLf, Err.Description
45  Resume ExitProc
End Sub


Private Sub AnalyzeValueSetParameter(parm As String, _
                                     idx As Integer, _
                                     currParm As TC_ParameterDescription, _
                                     valueSet As Collection, _
                                     parmOk As Boolean, _
                                     errorMsg As String)

5   On Error GoTo RaiseErrorHandler

    Dim i As Integer
    Dim tempParm As String

10  parmOk = False
15  tempParm = parm
20  parm = Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.RemoveQuotes(tempParm)
25  i = 1
30  Do
35      If UCase(valueSet(i)) = UCase(parm) Then
40          parmOk = True
45          GoTo ExitProc
50      End If
55      i = i + 1
60      If i > valueSet.count Then
65          Exit Do
70      End If
75  Loop

80  errorMsg = "  Fehler bei Befehl " & Chr(34) & mstrMakroName & Chr(34) & vbLf & _
             "    Parameter(" & idx & ")=[" & parm & "] ist f|fffd|r diesen Parameter nicht erlaubt"



ExitProc:
85  Exit Sub

RaiseErrorHandler:
90  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeValueSetParameter in Zeile:" & Erl & vbCrLf, Err.Description
95  Resume ExitProc
End Sub


Private Sub AnalyzeVbaValueSetParameter(parm As String, _
                                        idx As Integer, _
                                        currParm As TC_ParameterDescription, _
                                        parmOk As Boolean, _
                                        errorMsg As String)

5   Call AnalyzeCardinalParameter(parm, idx, currParm, parmOk, errorMsg)
End Sub


Private Sub AnalyzeCardinalParameter(parm As String, _
                                     idx As Integer, _
                                     currParm As TC_ParameterDescription, _
                                     parmOk As Boolean, _
                                     errorMsg As String)
    Dim longParam As Long
5   On Error GoTo RaiseErrorHandler

10  If parm = vbNullString Then
15      If currParm.OptionalParameter Then
20          parm = currParm.defaultValue
25      End If
30  End If

35  If Not IsNumeric(parm) Then
40      GoTo RaiseErrorHandler
45  Else

50      longParam = CLng(parm)
55      parmOk = longParam >= 0

60      If Not parmOk Then
65          errorMsg = "  Fehler bei Befehl " & Chr(34) & mstrMakroName & Chr(34) & vbLf & _
                     "    Parameter(" & idx & ")=[" & parm & "] muss gr|fffd||fffd|er 0 sein"
70      End If
75  End If

ExitProc:
80  Exit Sub

RaiseErrorHandler:
85  parmOk = False
90  errorMsg = "  Fehler bei Befehl " & Chr(34) & mstrMakroName & Chr(34) & _
               ":    Parameter(" & idx & ")=[" & parm & "] enth|fffd|lt keine Zahl"

95  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeCardinalParameter in Zeile:" & Erl & vbCrLf, Err.Description & vbCrLf & _
                                                                                                                     "->" & errorMsg
100 Resume ExitProc
End Sub


Private Sub AnalyzeTextParameter(parm As String, _
                                 idx As Integer, _
                                 currParm As TC_ParameterDescription, _
                                 parmOk As Boolean, _
                                 errorMsg As String)

5   On Error GoTo RaiseErrorHandler

    ' da split die "" nicht entfernt hat, muss in TextParameter wenn Hochkommas existieren, diese entfernt werden.

10  parm = Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.RemoveQuotes(parm)
15  errorMsg = vbNullString
20  parmOk = True

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeTextParameter in Zeile:" & Erl & vbCrLf, Err.Description
35  Resume ExitProc


End Sub


Private Sub AnalyzeFileName(parm As String, _
                            idx As Integer, _
                            currParm As TC_ParameterDescription, _
                            parmOk As Boolean, _
                            errorMsg As String)

5   On Error GoTo RaiseErrorHandler

10  parm = Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.RemoveQuotes(parm)
15  parm = Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.NormalizedFileNameWithSeparator(parm)
20  errorMsg = vbNullString
25  parmOk = True

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeFileName in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc

End Sub


Private Sub AnalyzeDirName(parm As String, _
                           idx As Integer, _
                           currParm As TC_ParameterDescription, _
                           parmOk As Boolean, _
                           errorMsg As String)

5   On Error GoTo RaiseErrorHandler

10  parm = Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.RemoveQuotes(parm)
15  parm = Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.Tools.NormalizedPathWithSeparator(parm)
20  errorMsg = vbNullString
25  parmOk = True

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeDirName in Zeile:" & Erl & vbCrLf, Err.Description
40  Resume ExitProc
End Sub

Private Sub AnalyzeMakroNameParameter(parm As String, _
                                      idx As Integer, _
                                      currParm As TC_ParameterDescription, _
                                      parmOk As Boolean, _
                                      errorMsg As String)
    ' |fffd|berpr|fffd|fen, ob nicht erlaubte Zeichen vorhanden sind
5   Call AnalyzeTextParameter(parm, idx, currParm, parmOk, errorMsg)

End Sub


Private Sub AnalyzeFreeParameter(part() As String, _
                                 idx As Integer, _
                                 currParm As TC_ParameterDescription, _
                                 parmOk As Boolean, _
                                 errorMsg As String)

5   On Error GoTo RaiseErrorHandler

    ' alle weiteren Parameter werden zusammengefasst
    Dim i As Integer
    Dim parmStr As String

10  parmStr = part(idx)

15  For i = idx + 1 To UBound(part)
20      parmStr = parmStr & " " & part(i)
25  Next i

30  ReDim Preserve part(idx)
35  part(idx) = parmStr
40  errorMsg = vbNullString
45  parmOk = True

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeFreeParameter in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc

End Sub


Private Sub AnalyzeControlParameter(part() As String, _
                                    idx As Integer, _
                                    currParm As TC_ParameterDescription, _
                                    parmOk As Boolean, _
                                    errorMsg As String)

5   On Error GoTo RaiseErrorHandler

    ' String wird gesplittet am ersten "=", erste Wert muss bestimmte Werte enthalten, _
      zweite Wert hat bestimmte Eigenschaften und muss dementsprechend analysiert werden. _
      part wird um eins erweitert und der zweite Wert in das freigewordene eingetragen
    Dim i As Integer
    Dim parmStr As String

10  parmStr = part(idx)

15  For i = idx + 1 To UBound(part)
20      parmStr = parmStr & " " & part(i)
25  Next i

30  ReDim Preserve part(idx)
35  part(idx) = parmStr
40  errorMsg = vbNullString
45  parmOk = True

ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeControlParameter in Zeile:" & Erl & vbCrLf, Err.Description
60  Resume ExitProc

End Sub


Private Sub AnalyzeCommandBarParameter(parm As String, _
                                       idx As Integer, _
                                       currParm As TC_ParameterDescription, _
                                       valueSet As Collection, _
                                       parmOk As Boolean, _
                                       errorMsg As String)
5   On Error GoTo RaiseErrorHandler

    Dim i As Integer
    Dim tmpParm As String

10  Call AnalyzeValueSetParameter(parm, idx, currParm, valueSet, parmOk, errorMsg)
15  If Not parmOk Then
        'currParm darf nur aus Ziffern bestehen
20      tmpParm = parm
25      tmpParm = Replace(tmpParm, " ", "?")
30      tmpParm = Replace(tmpParm, "0", " ")
35      tmpParm = Replace(tmpParm, "1", " ")
40      If Len(tmpParm) > 14 Then
45          tmpParm = Left(tmpParm, 14) & "?"
50      End If
55      tmpParm = Trim(tmpParm)
60      parmOk = (tmpParm = vbNullString)
65  End If
70  errorMsg = vbNullString
75  parmOk = True

ExitProc:
80  Exit Sub

RaiseErrorHandler:
85  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeCommandBarParameter in Zeile:" & Erl & vbCrLf, Err.Description
90  Resume ExitProc

End Sub


Public Function AnalyzeCommand(part() As String, session As TC_Session) As TC_SessionResult
    Dim idx As Integer
    Dim strMsgForLogfile As String
    Dim boolIsParmOk As Boolean
    Dim objParameterDescriptionCounter As TC_ParameterDescription
    ' wenn mehr Parameter als erlaubt -> Warnung f|fffd|r unterdr|fffd|cken
    ' Fehlerprotokoll schreiben

    Dim tcsrResult As TC_SessionResult

5   On Error GoTo RaiseErrorHandler

10  tcsrResult = tcrOK


15  idx = LBound(part)                                ' entspricht dem Kommandonamen

20  For Each objParameterDescriptionCounter In mcolParameters
25      idx = idx + 1
30      With objParameterDescriptionCounter
35          If idx > UBound(part) Then
40              boolIsParmOk = .OptionalParameter

45              If Not boolIsParmOk Then
50                  strMsgForLogfile = "  Fehler bei Befehl " & Chr(34) & Me.makroName & Chr(34) & vbLf & _
                                     "    Parameter(" & idx & ") ist nicht optional und muss angegeben werden"
55              End If

60              ReDim Preserve part(idx)
65              part(idx) = .defaultValue
70          Else
75              Select Case .parameterType
                    Case eptBoolean
80                      Call AnalyzeBooleanString(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
85                  Case eptFileName
90                      Call AnalyzeFileName(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
95                  Case eptWordText
100                     Call AnalyzeTextParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
105                 Case eptMakroName
110                     Call AnalyzeMakroNameParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
115                 Case eptWindowTitle
120                     Call AnalyzeTextParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
125                 Case eptPrinterName
130                     Call AnalyzeTextParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
135                 Case eptCardinal
140                     Call AnalyzeCardinalParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
145                 Case eptControl
150                     Call AnalyzeCardinalParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
155                 Case eptConstantSet
160                     Call AnalyzeValueSetParameter(part(idx), idx, objParameterDescriptionCounter, .ParameterConstants, boolIsParmOk, strMsgForLogfile)
165                 Case eptCommandBars
170                     Call AnalyzeCommandBarParameter(part(idx), idx, objParameterDescriptionCounter, .ParameterConstants, boolIsParmOk, strMsgForLogfile)
175                 Case eptDirName
180                     Call AnalyzeDirName(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
185                 Case eptServerName
190                     Call AnalyzeTextParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
195                 Case eptPort
200                     Call AnalyzeCardinalParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
205                 Case eptEndOfLine
210                     Call AnalyzeTextParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
215                 Case eptVBAStyle
220                     Call AnalyzeVbaValueSetParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
225                 Case eptText
230                     Call AnalyzeTextParameter(part(idx), idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
235                 Case eptFreeParameter
240                     Call AnalyzeFreeParameter(part, idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
245                 Case eptControlParameter
250                     Call AnalyzeControlParameter(part, idx, objParameterDescriptionCounter, boolIsParmOk, strMsgForLogfile)
255                 Case Else
260                     boolIsParmOk = False
265                     strMsgForLogfile = "f|fffd|r Parameter " & idx & " ist die Typ-Analyse nicht implementiert"
270             End Select
275         End If

280         If Not boolIsParmOk Then
285             Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll(strMsgForLogfile, session)

290             Err.Raise glongCUSTOM_ERR_COMMAND_PARAMETER_ERROR, "TC_WEInstruction::AnalyzeCommand", "Fehler bei der Definition vom Befehl '" & Me.makroName & "' in GV 'PYP'. Einzelheiten bitte dem Protokoll entnehmen"

295             tcsrResult = tcrParameterErr
300         End If

305     End With

310 Next objParameterDescriptionCounter

315 If idx < UBound(part) Then
320     If mstrMakroName <> "KOMMENTAR" Then
325         strMsgForLogfile = "  Fehler bei Befehl " & Chr(34) & Me.makroName & Chr(34) & vbLf & _
                             "    die Parameter ab Parameter(" & idx & ") werden nicht unterst|fffd|tzt"

330         Call Me.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll(strMsgForLogfile, session)
335         Err.Raise glongCUSTOM_ERR_COMMAND_PARAMETER_ERROR, "TC_WEInstruction::AnalyzeCommand", "Fehler bei der Definition vom Befehl '" & Me.makroName & "' in GV 'PYP'. Einzelheiten bitte dem Protokoll entnehmen"

340         If tcsrResult = tcrOK Then
345             tcsrResult = tcrParameterWarning
350         End If
355     End If
360 End If


ExitProc:
365 Set objParameterDescriptionCounter = Nothing
370 AnalyzeCommand = tcsrResult
375 Exit Function

RaiseErrorHandler:
380 Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstruction::AnalyzeCommand in Zeile:" & Erl & vbCrLf, Err.Description
385 Resume ExitProc

End Function


Attribute VB_Name = "TC_WEInstructionMacro"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' ***************************************************************************
' Error Numbers in der Klasse TC_WEInstructionMacrosContainer
' Private Const mlongHANDLED_ERROR_NUMBER_PROPERTY_ALREADY_SET As Long = 18001
' ***************************************************************************

' der Name des Befehls in der WE-Datei
Private mstrMakroName As String
Private mcolParameterValues As Collection
Private mstrParameterString As String
Private mobjParentWEInstructionMacrosContainer As TC_WEInstructionMacrosContainer


Private Sub Class_Initialize()
5   Set mcolParameterValues = New Collection
10  mstrParameterString = vbNullString
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mcolParameterValues Is Nothing Then
10      Set mcolParameterValues = Nothing
15  End If

20  If Not mobjParentWEInstructionMacrosContainer Is Nothing Then
25      Set mobjParentWEInstructionMacrosContainer = Nothing
30  End If

End Sub

Public Property Get ParentWEInstructionMacrosContainer() As TC_WEInstructionMacrosContainer
5   Set ParentWEInstructionMacrosContainer = mobjParentWEInstructionMacrosContainer
End Property

Public Property Set ParentWEInstructionMacrosContainer(objParentWEInstructionMacrosContainer As TC_WEInstructionMacrosContainer)
5   If mobjParentWEInstructionMacrosContainer Is Nothing Then
10      Set mobjParentWEInstructionMacrosContainer = objParentWEInstructionMacrosContainer
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_WEInstructionMacro.ParentWEInstructionMacrosContainer", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Property Let makroName(ByVal vMakroName As String)
5   mstrMakroName = vMakroName
End Property

Public Property Get makroName() As String
5   makroName = mstrMakroName
End Property

Public Property Get ParameterCount() As Integer
5   ParameterCount = mcolParameterValues.count
End Property

Public Sub AddParameterValue(parmDescr As TC_ParameterDescription, ByVal parameterStr As String, session As TC_Session)
    ' Diese Prozedur muss in der Reihenfolge der auftretenden Parameter erfolgen
5   On Error GoTo RaiseErrorHandler

    Dim inQuotes As Boolean
    Dim idx As Integer

10  inQuotes = True
15  With parmDescr
20      Select Case .parameterType
            Case eptBoolean
25              mcolParameterValues.Add .GetBooleanValue(parameterStr)
30              inQuotes = False
35          Case eptFileName
40              mcolParameterValues.Add .GetTextValue(parameterStr)
45          Case eptWordText
50              mcolParameterValues.Add .GetTextValue(parameterStr)
55          Case eptMakroName
60              mcolParameterValues.Add .GetTextValue(parameterStr)
65          Case eptWindowTitle
70              mcolParameterValues.Add .GetTextValue(parameterStr)
75          Case eptPrinterName
80              mcolParameterValues.Add .GetTextValue(parameterStr)
85          Case eptCardinal
90              mcolParameterValues.Add .GetIntegerValue(parameterStr)
95              inQuotes = False
100         Case eptControl
105             mcolParameterValues.Add .GetControlValue(parameterStr)
110             inQuotes = False
115         Case eptConstantSet
120             mcolParameterValues.Add .GetTextValue(parameterStr)
125         Case eptCommandBars
130             mcolParameterValues.Add .GetTextValue(parameterStr)
135         Case eptDirName
140             mcolParameterValues.Add .GetTextValue(parameterStr)
145         Case eptServerName
150             mcolParameterValues.Add .GetTextValue(parameterStr)
155         Case eptPort
160             mcolParameterValues.Add .GetIntegerValue(parameterStr)
165             inQuotes = False
170         Case eptEndOfLine
175             mcolParameterValues.Add .GetTextValue(parameterStr)
180         Case eptVBAStyle
185             mcolParameterValues.Add .GetVbaValue(parameterStr)
190             inQuotes = False
195         Case eptText
200             mcolParameterValues.Add .GetTextValue(parameterStr)
205         Case eptFreeParameter
210             mcolParameterValues.Add .GetTextValue(parameterStr)
215         Case eptControlParameter
220             mcolParameterValues.Add .GetTextValue(parameterStr)
225         Case Else
230             MsgBox "in AddParameterValue fehlt ein Case f|fffd|r den ParameterTyp", vbExclamation, _
                       Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.MsgBoxTitle

235     End Select
240 End With

245 idx = mcolParameterValues.count
250 If idx > 1 Then
255     mstrParameterString = mstrParameterString & "; "
260 End If
265 If inQuotes Then
270     mstrParameterString = mstrParameterString & Chr(34)
275 End If
280 mstrParameterString = mstrParameterString & mcolParameterValues.Item(idx)
285 If inQuotes Then
290     mstrParameterString = mstrParameterString & Chr(34)
295 End If

ExitProc:
300 Exit Sub

RaiseErrorHandler:
305 Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstructionMacro::AddParameterValue in Zeile:" & Erl & vbCrLf, Err.Description
310 Resume ExitProc

End Sub

Private Function GetParameterString() As String
5   GetParameterString = mstrParameterString
End Function

Public Function GetCommandString() As String
    Dim parmString As String

5   parmString = GetParameterString()
10  GetCommandString = Me.makroName
15  If Len(parmString) > 0 Then
20      GetCommandString = GetCommandString & " (" & parmString & ")"
25  End If

End Function

Public Function RunMakro(session As TC_Session) As Boolean
    Dim protokollStr As String
    Dim result As VbMsgBoxResult
    Dim boolResult As Boolean

5   On Error GoTo RaiseErrorHandler

10  If Me.makroName = "ARCPRINTER" Then
15      Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.IsArcPrinterSet = True
20  End If

25  boolResult = False
30  protokollStr = "Starte Ausf|fffd|hrung vom Befehlsmakro: " & Me.GetCommandString()

35  If session.withDebugMsg Then
40      MsgBox protokollStr, vbExclamation, Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.MsgBoxTitle
45  End If

50  Call Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.M_Protokoll(protokollStr, session)
55  Call session.IncIndent

    ' |fffd|ber CallByName entsprechend dem Makronamen des aktuellen TC_WEInstructionMacro-Objekts dynamisch das Makro in der SyntaxDescription ausf|fffd|hren
    ' die Anzahl der Parameter erh|fffd|ht sich um 1 mit jedem weiteren Zweig
60  Select Case mcolParameterValues.count
        Case 0
65          boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    session)
70      Case 1

75          boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    session)
80      Case 2
85          boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    session)
90      Case 3
95          boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    session)
100     Case 4
105         boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    mcolParameterValues(4), _
                                    session)
110     Case 5
115         boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    mcolParameterValues(4), _
                                    mcolParameterValues(5), _
                                    session)
120     Case 6
125         boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    mcolParameterValues(4), _
                                    mcolParameterValues(5), _
                                    mcolParameterValues(6), _
                                    session)
130     Case 7
135         boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    mcolParameterValues(4), _
                                    mcolParameterValues(5), _
                                    mcolParameterValues(6), _
                                    mcolParameterValues(7), _
                                    session)
140     Case 8
145         boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    mcolParameterValues(4), _
                                    mcolParameterValues(5), _
                                    mcolParameterValues(6), _
                                    mcolParameterValues(7), _
                                    mcolParameterValues(8), _
                                    session)
150     Case 9
155         boolResult = CallByName(Me.ParentWEInstructionMacrosContainer _
                                    .ParentSession.ParentSessionsContainer.ParentIkolClientApp.SyntaxDescription, _
                                    Me.makroName, VbMethod, _
                                    mcolParameterValues(1), _
                                    mcolParameterValues(2), _
                                    mcolParameterValues(3), _
                                    mcolParameterValues(4), _
                                    mcolParameterValues(5), _
                                    mcolParameterValues(6), _
                                    mcolParameterValues(7), _
                                    mcolParameterValues(8), _
                                    mcolParameterValues(9), _
                                    session)
160     Case Else
165 End Select

170 If session.withDebugMsg Then
175     result = MsgBox("Ende:  " & Me.makroName & vbLf & " Debug-Modus durch Abbruch beenden", _
                        vbExclamation, Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.MsgBoxTitle)

180     If result = vbCancel Then
185         session.withDebugMsg = False
190     End If

195 End If

200 Call session.DecIndent

205 Call Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp _
         .LogfileHandler.M_Protokoll("Ende Ausf|fffd|hrung vom Befehlsmakro:  " & Me.makroName & _
                                   " mit tcResult=" & Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.RCDescription(session.tcResult) & _
                                     vbCrLf & "--------------------------------------------------------------------", session)

210 Call Me.ParentWEInstructionMacrosContainer.ParentSession.ParentSessionsContainer.ParentIkolClientApp.LogfileHandler.WriteEmptyProtokollLine


ExitProc:
215 RunMakro = boolResult
220 Exit Function

RaiseErrorHandler:
225 boolResult = False
230 Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstructionMacro::RunMakro in Zeile:" & Erl & vbCrLf, Err.Description
235 Resume ExitProc
End Function
Attribute VB_Name = "TC_WEInstructionMacrosContainer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' das Herz der Office-Schnittstelle - eine Collection von den Makrokommandos/Befehlen in der WE-Datei
Private mcolMakroCommands As Collection

' eine Collection von den Makrokommandos in der WE-Datei, wo aber das Makrokommando/der Befehl
' SYMBOLLEISTE ganz zu Beginn (an max. 3. Position) steht --> zwecks fr|fffd|hes Einbledens der Symbolleiste
' und somit Anzeige auf jedem Dokument
Private mcolMakroCommandsReordered As Collection

Private mobjParentSession As TC_Session

Private Sub Class_Initialize()
5   Set mcolMakroCommands = New Collection
10  Set mcolMakroCommandsReordered = New Collection
End Sub

Private Sub Class_Terminate()
5   Call Me.CleanUp
End Sub


Public Sub CleanUp()
5   If Not mcolMakroCommands Is Nothing Then
10      Set mcolMakroCommands = Nothing
15  End If

20  If Not mcolMakroCommandsReordered Is Nothing Then
25      Set mcolMakroCommandsReordered = Nothing
30  End If

35  If Not mobjParentSession Is Nothing Then
40      Set mobjParentSession = Nothing
45  End If

End Sub

Public Property Get ParentSession() As TC_Session
5   Set ParentSession = mobjParentSession
End Property

Public Property Set ParentSession(objParentSession As TC_Session)
5   If mobjParentSession Is Nothing Then
10      Set mobjParentSession = objParentSession
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "TC_WEInstructionMacrosContainer.ParentSession", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Sub AddWECommand(ByVal objCommand As TC_WEInstructionMacro)
5   On Error GoTo RaiseErrorHandler

    ' Diese Prozedur muss in der Reihenfolge der Zeilen in der WE-Datei erfolgen
10  Set objCommand.ParentWEInstructionMacrosContainer = Me
15  mcolMakroCommands.Add objCommand

ExitProc:
20  Exit Sub

RaiseErrorHandler:
25  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstructionMacrosContainer::AddWECommand in Zeile:" & Erl & vbCrLf, Err.Description
30  Resume ExitProc
End Sub

'---------------------------------------------------------------------------------------
' Prozedur : intIsMacroCommandInSequence
' Autor    : Todor Vachkov
' Datum    : 10.06.2013
' Zweck    : |fffd|berpr|fffd|fung ob SYMBOLLEISTE in der Befehlfolge geparst wurde
'---------------------------------------------------------------------------------------
' R|fffd|ckgabeparams:
' Integer       :  gr|fffd||fffd|er 1 --> Makrokommando wurde an dieser Position gefunden;
'                          0 --> Kommando ist nicht in der Folge
'
' |fffd|bergabeparams:
' String        :  der Name des gesuchten Makros
'
Public Function intIsMacroCommandInSequence(ByVal strSearchCommand As String) As Integer

5   On Error GoTo RaiseErrorHandler

    Dim intResult As Integer
    Dim intCounter As Integer
    Dim makroCmd As TC_WEInstructionMacro

10  intResult = 0
15  intCounter = 0
20  strSearchCommand = Trim(strSearchCommand)

25  For Each makroCmd In mcolMakroCommands
30      intCounter = intCounter + 1
35      If makroCmd.makroName = strSearchCommand Then
40          intResult = intCounter
45          Exit For
50      End If
55  Next makroCmd

60  intIsMacroCommandInSequence = intResult

ExitProc:
65  Set makroCmd = Nothing
70  Exit Function

RaiseErrorHandler:
75  Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstructionMacrosContainer::intIsMacroCommandInSequence in Zeile:" & Erl & vbCrLf, Err.Description
80  Resume ExitProc
End Function

Public Function RunMacroCommands(ByVal session As TC_Session) As Boolean

    ' die aus der WE-Datei geparste Befehlsfolge der Reiehe nach abarbeiten
    ' ACHTUNG: damit jedes erzeugte Dokument die Symbolleiste aktiviert bekommt
    ' wird hier die Reihenfolge ggf. ge|fffd|ndert, so dass auch wenn der Befehl SYMBOLLEISTE
    ' vorkommt, dieser an als 2.Befehl in der Folge aufgerufen wird

    Dim makroCmd As TC_WEInstructionMacro
    Dim makroCounterCmd As TC_WEInstructionMacro

    Dim tcResult As TC_SessionResult
    Dim objmvarMakroCommandsReordered As Collection
    Dim intCounterInCollection As Integer
    Dim intPositionCommandbarInCommandosSequence As Integer
    Dim boolResult As Boolean

5   On Error GoTo RaiseErrorHandler
10  boolResult = True

    ' pr|fffd|fen, ob in der Befehlsfolge SYMBOLLEISTE enthalten ist, gibt zur|fffd|ck 0 - nicht gefunden oder die Position
15  intPositionCommandbarInCommandosSequence = intIsMacroCommandInSequence("SYMBOLLEISTE")

20  If intPositionCommandbarInCommandosSequence > 3 Then
        ' SYMBOLLEISTE wurde gefunden und taucht als  mind. 4. Befehl auf, die Befehlsfolge muss umgeordnet werden

25      intCounterInCollection = 0

30      For Each makroCmd In mcolMakroCommands
35          intCounterInCollection = intCounterInCollection + 1

40          If intCounterInCollection = intPositionCommandbarInCommandosSequence Then
                ' makroCmd ist SYMBOLLEISTE, hinzuf|fffd|gen an 3. Stelle
45              mcolMakroCommandsReordered.Add makroCmd, After:=2
50          Else
                ' makroCmd ist anders als SYMBOLLEISTE, normal am Ende der sortierten Collection
55              mcolMakroCommandsReordered.Add makroCmd
60          End If
65      Next makroCmd

70      For Each makroCounterCmd In mcolMakroCommandsReordered
75          boolResult = makroCounterCmd.RunMakro(session)
80          If Not boolResult Then
85              Exit For
90          End If
            ' DoEvents
95      Next makroCounterCmd

100 Else
        ' ganz normal mit der urspr|fffd|nglichen Befehlsfolge, weil SYMBOLLEISTE entweder gar nicht gegeben, oder wird fr|fffd|h genug aufgerufen
105     For Each makroCmd In mcolMakroCommands
110         boolResult = makroCmd.RunMakro(session)
115         If Not boolResult Then
120             Exit For
125         End If
            ' DoEvents
130     Next makroCmd
135 End If

ExitProc:
140 RunMacroCommands = boolResult
145 Set makroCounterCmd = Nothing
150 Set makroCmd = Nothing
155 Exit Function

RaiseErrorHandler:
160 boolResult = False
165 Err.Raise Err.Number, Err.Source & "->" & "TC_WEInstructionMacrosContainer::RunMacroCommands in Zeile:" & Erl & vbCrLf, Err.Description
170 Resume ExitProc
End Function
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Version"
Option Explicit

'f|fffd|r wordswvn
Public Const gstrOS2_VERSION As String = "6.0.0"
Public Const gstrTC_TEMPLATE_DOT_BUILDVERSION As String = "2018.11.26:0001"

Public Sub getVersion(strOS2Version As String, strBUILDVersion As String)
  strOS2Version = gstrOS2_VERSION
  strBUILDVersion = gstrTC_TEMPLATE_DOT_BUILDVERSION
End Sub
Attribute VB_Name = "frmTC_AnsichtInfo"
Attribute VB_Base = "0{798F3AE9-6325-4949-A92E-672CA5A4137E}{2F1C5278-55A1-4380-9FEA-1513F61C0B74}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub shut_Click()
5   Me.hide
End Sub

Private Sub UserForm_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmTC_AnsichtInfo.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property
Attribute VB_Name = "frmTC_DruckerAuswahl"
Attribute VB_Base = "0{56B868EF-1733-4C25-9BBE-7AA1B2E55C47}{EC0646D5-2B20-44DA-BD9B-257B1B26015F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp


Private Sub cmdDrucken_Click()
5   On Error GoTo ErrorHandler
10  Me.ParentIkolClientApp.PrinterSetupHandler.PrinterName = Me.lbPrinters.text
15  Me.ParentIkolClientApp.PrinterSetupHandler.SelectCanceled = False
20  Me.hide

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_DruckerAuswahl", "cmdDrucken_Click", , vbNullString)
40  Resume ExitProc

End Sub

Private Sub cmdAbbrechen_Click()
5   On Error GoTo ErrorHandler
10  Me.ParentIkolClientApp.PrinterSetupHandler.PrinterName = vbNullString
15  Me.ParentIkolClientApp.PrinterSetupHandler.SelectCanceled = True
20  Me.hide

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_DruckerAuswahl", "cmdAbbrechen_Click", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub lbPrinters_Click()
5   On Error GoTo ErrorHandler
10  Me.selPrinter.Caption = Me.lbPrinters.text

ExitProc:
15  On Error Resume Next
20  Exit Sub

ErrorHandler:
25  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_DruckerAuswahl", "lbPrinters_Click", , vbNullString)
30  Resume ExitProc

End Sub

Private Sub lbPrinters_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
5   On Error GoTo ErrorHandler

10  Cancel = False
15  Call cmdDrucken_Click

ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_DruckerAuswahl", "lbPrinters_DblClick", , vbNullString)
35  Resume ExitProc
End Sub

Public Sub CustomShowUserForm()
5   On Error GoTo ErrorHandler

    Dim allPrinters() As String
    Dim iSelect As Integer
    Dim idx As Integer

10  Me.lbPrinters.Clear

15  allPrinters = _
    Me.ParentIkolClientApp.PrinterSetupHandler.GetAllPrinters(Me.ParentIkolClientApp.PrinterSetupHandler.SessionForSelect, _
                                                              iSelect, Me.ParentIkolClientApp.PrinterSetupHandler.LookForPrinterName, True)

20  For idx = LBound(allPrinters) To UBound(allPrinters)
25      Me.lbPrinters.AddItem allPrinters(idx)
30  Next idx
35  Me.lbPrinters.ListIndex = iSelect
40  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("vorselektierter Drucker ist Nr. " & iSelect & " (" & Chr(34) & allPrinters(iSelect) & Chr(34) & ")")
45  Me.lblDrucker.Caption = Me.ParentIkolClientApp.PrinterSetupHandler.PrinterDialogLabel
50  Me.Show


ExitProc:
55  On Error Resume Next
60  Exit Sub

ErrorHandler:
65  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_DruckerAuswahl", "UserForm_Initialize", , vbNullString)
70  Resume ExitProc
End Sub

Private Sub UserForm_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmTC_DruckerAuswahl.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property
Attribute VB_Name = "frmTC_EditSignup"
Attribute VB_Base = "0{02E16B79-0C87-494D-A7EA-EA90BEAF2B8D}{17047BEA-FB05-4E5C-B811-2949C8EE7E2A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




Option Explicit

Public SignaturesContainer As TC_SignaturesContainer

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub TB_Description_Change()
    Dim strLastChar As String
    Dim strCurrentChar As String
    Dim intCounter As Integer
5   If Len(TB_Description) > 0 Then
        ' 10      strLastChar = Right(TB_Description.text, 1)

10      For intCounter = 1 To Len(TB_Description.text)
15          strCurrentChar = Mid(TB_Description.text, intCounter, 1)

20          If Not (strCurrentChar Like "[A-Za-z]" Or strCurrentChar Like "#" Or asc(strCurrentChar) = 32) Then
25              Me.ParentIkolClientApp.LogfileHandler.ViewGeneralMsgBox ( _
                                                                        "Der Name f|fffd|r die Unterschrift darf nur Buchstaben, Zahlen und Leerzeichen enthalten." & vbCrLf & _
                                                                        "Das zuletzt eingegebene Zeichen [" & strCurrentChar & "] ist nicht zul|fffd|ssig.")
                ' den kompletten Text l|fffd|schen
30              TB_Description.text = vbNullString
35              Exit For
40          End If
45      Next intCounter

        ' wenn das zuletzt eingegebene Zeichen kein Buchstabe, Zahl oder Leerzeichen
        '15      If Not (strLastChar Like "[A-Za-z]" Or strLastChar Like "#" Or asc(strLastChar) = 32) Then
        '20          Me.ParentIkolClientApp.LogfileHandler.ViewGeneralMsgBox ( _
         '                "Der Name f|fffd|r die Unterschrift darf nur Buchstaben, Zahlen und Leerzeichen enthalten." & vbCrLf & _
         '                "Das zuletzt eingegebene Zeichen [" & strLastChar & "] ist nicht zul|fffd|ssig.")
        '                ' das letzte Zeichen l|fffd|schen, weil ja falsch
        '                TB_Description.text = left(TB_Description.text, Len(TB_Description.text) - 1)
        '25      End If
50  End If
End Sub

Private Sub UserForm_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmEditSignup.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Public Function DoAddSignature() As Boolean
5   On Error GoTo RaiseErrorHandler

    Dim boolReturn As Boolean


10  boolReturn = False

15  If TB_Description.text <> vbNullString Then
20      Call Me.ParentIkolClientApp.SignUpHandler.CreateDefaultSignature(Me.TB_Description.text, True)
25      boolReturn = True
30  End If

35  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("frmTC_EditSignup::DoAddSignature endet mit " & boolReturn, Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

ExitProc:
40  DoAddSignature = boolReturn
45  Exit Function

RaiseErrorHandler:
50  boolReturn = False
55  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "DoAddSignature", , vbNullString)
60  Resume ExitProc
End Function

Public Sub B_AddSignUp_Enter()
5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("frmTC_EditSignup::B_AddSignUp_Enter: Unterschriften-Verwaltung: Button(Hinzuf|fffd|gen einer Unterschrift)", _
                                                           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
15  If Me.DoAddSignature Then
20      Me.ParentIkolClientApp.SignUpHandler.RetEditDlg = True
25      Me.hide

30  End If

ExitProc:
35  Exit Sub

RaiseErrorHandler:
40  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "B_AddSignUp_Enter", , vbNullString)
45  Resume ExitProc
End Sub

Public Sub B_CancelButton_Enter()
5   On Error GoTo RaiseErrorHandler

10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("frmTC_EditSignup: B_CancelButton_Enter: Unterschriften-Verwaltung: Button(Abbruch)", _
                                                           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)
15  Me.hide
ExitProc:
20  Exit Sub

RaiseErrorHandler:
25  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "B_CancelButton_Enter", , vbNullString)
30  Resume ExitProc

End Sub

Public Sub B_DeleteSignUp_Enter()

10    On Error GoTo RaiseErrorHandler

    Dim objTcSignature As TC_Signature
    Dim boolReturn As Boolean

20    Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("frmTC_EditSignup:B_DeleteSignUp_Enter: Unterschriften-Verwaltung: Button(L|fffd|schen einer Unterschrift)", _
                                                           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

30    Set objTcSignature = Me.ParentIkolClientApp.SignUpHandler.GetSignFromDescr(Me.LB_Description.text)
40    If Not (objTcSignature Is Nothing) Then

        '26.04.2016 AL
        Dim idx As Integer
50      idx = Me.ParentIkolClientApp.SignUpHandler.GetSignIDXFromDescr(Me.LB_Description.text)
        'ENDE 26.04.20|fffd|16 AL
        
60      boolReturn = Me.ParentIkolClientApp.SignUpHandler.DeleteTCSign(objTcSignature, idx) '26.04.2016 AL idx |fffd|bergeben
70    End If

80    TB_Description.text = vbNullString
90    Call Me.FillEditListbox
100   Me.B_DeleteSignUp.enabled = False
110   Me.B_GoToSignUp.enabled = False
120   Me.B_AddSignUp.enabled = True

ExitProc:
130   Set objTcSignature = Nothing
140   Exit Sub

RaiseErrorHandler:
150   Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "B_DeleteSignUp_Enter", , vbNullString)
160   Resume ExitProc
End Sub


Public Sub B_GoToSignUp_Enter()
5   On Error GoTo RaiseErrorHandler

    Dim objTcSignature As TC_Signature
    Dim boolReturn As Boolean

10  Call Me.ParentIkolClientApp.LogfileHandler.M_Protokoll("frmTC_EditSignup:B_GoToSignUp_Enter: Unterschriften-Verwaltung: Button(gehe zu Unterschrift)", _
                                                           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession)

15  Set objTcSignature = Me.ParentIkolClientApp.SignUpHandler.GetSignFromDescr(Me.LB_Description.text)

20  If Not (objTcSignature Is Nothing) Then
25      boolReturn = Me.ParentIkolClientApp.SignUpHandler.GotoTCSign(objTcSignature)
30  End If

ExitProc:
35  Set objTcSignature = Nothing
40  Exit Sub

RaiseErrorHandler:
45  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "B_GoToSignUp_Enter", , vbNullString)
50  Resume ExitProc
End Sub

Public Sub FillEditListbox()
5   On Error GoTo RaiseErrorHandler

    Dim intCount As Integer
10  intCount = Me.ParentIkolClientApp.SignUpHandler.FillListWithSignNames(Me.LB_Description)
15  Me.TB_Description.text = vbNullString
20  Me.B_DeleteSignUp.enabled = False
25  Me.B_GoToSignUp.enabled = False

ExitProc:
30  Exit Sub

RaiseErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "FillEditListbox", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub LB_Description_Click()

5   On Error GoTo RaiseErrorHandler

    ' 10  Me.TB_Description.text = Me.LB_Description.text
10  Me.B_DeleteSignUp.enabled = True
15  Me.B_GoToSignUp.enabled = True
20  Me.B_AddSignUp.enabled = False

ExitProc:
25  Exit Sub

RaiseErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "LB_Description_Click", , vbNullString)
35  Resume ExitProc
End Sub

Public Sub TB_Description_Exit(ByVal Cancel As MSForms.ReturnBoolean)

5   On Error GoTo RaiseErrorHandler

10  If Me.B_AddSignUp.enabled Then
15      If Me.DoAddSignature Then
20          Me.ParentIkolClientApp.SignUpHandler.RetEditDlg = True
25          Me.TB_Description.text = vbNullString
30          Cancel = True
35          Me.hide
40      End If
45  End If


ExitProc:
50  Exit Sub

RaiseErrorHandler:
55  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_EditSignup", "TB_Description_Exit", , vbNullString)
60  Resume ExitProc
End Sub

'29.01.2016 AL
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    ' verhindern, dass |fffd|ber (x) geschlossen wird
5   If CloseMode = 0 Then
10      Cancel = 1
15  End If
End Sub
'ENDE 29.01.2016 AL
Attribute VB_Name = "frmTC_Progressbalken"
Attribute VB_Base = "0{BF1DCD61-230F-47C0-83AB-542FE67EF4E2}{268CE779-F0AB-4EF9-92EE-46599E80D659}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub UserForm_Activate()
5   On Error GoTo ErrorHandler

10  Me.Label2.width = 1
15  Call Me.ParentIkolClientApp.PrintHandler.ControlProgressbar
20  Me.hide

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Progressbalken", "UserForm_Activate", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
5   On Error GoTo ErrorHandler

    ' verhindern, dass |fffd|ber (x) der Progressbalken geschlossen wird
10  If CloseMode = 0 Then
15      Cancel = 1
20  End If

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Progressbalken", "UserForm_QueryClose", , vbNullString)
40  Resume ExitProc

End Sub

Private Sub UserForm_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub


Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmTC_Progressbalken.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property
Attribute VB_Name = "frmTC_SignTypeQuestion"
Attribute VB_Base = "0{1C386785-281E-492A-9649-AEC46FD36999}{4658261A-32FF-4A83-8B5D-0155FF1F8E3D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub UserForm_Terminate()
5   Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmSignTypeQuestion.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Private Sub B_Mandatory_Click()
5   Me.ParentIkolClientApp.SignUpHandler.RetQuestionDlg = True
10  Me.hide
End Sub

Private Sub B_Optional_Click()
5   Me.ParentIkolClientApp.SignUpHandler.RetQuestionDlg = False
10  Me.hide
End Sub

Attribute VB_Name = "frmTC_SignUpSelection"
Attribute VB_Base = "0{727D998A-06CA-4C52-9338-EC8959DE0AE6}{C06D79E0-2131-424D-94F7-3DDDB27986EF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub UserForm_Terminate()
5   Call Me.ParentIkolClientApp.SignUpHandler.GetSignCancel
10  Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmSignUpSelection.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property


Public Sub DoAction(value As Boolean)

5   B_SignUp.enabled = Not value
10  B_End.enabled = Not value
15  B_DeleteSign.enabled = Not value
20  If value Then
25      B_GetSign.TakeFocusOnClick = value
30  End If
35  B_Cancel.enabled = value
40  B_GetSign.enabled = value
45  B_Clear.enabled = value
50  G_SignGroup.enabled = value
55  If Not value Then
60      B_GetSign.TakeFocusOnClick = Not value
65  End If

End Sub

' ==========================================================================
'  Buttons zur Verwaltung der Unterschriften (Eingabe, L|fffd|schen, Ende)
' ==========================================================================
'Button Unterschrift
Private Sub B_SignUp_Click()
      
      '19.04.2016 AL
      If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Or _
         Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Then
        mboolDruckIntern = True
      End If
      'ENDE 19.04.2016 AL
      
      '19.04.2016 AL
      'Unterschrift l|fffd|schen und Listbox aktualisieren
      Dim merk As Integer
20    merk = LB_Description.ListIndex
30    Call Me.ParentIkolClientApp.SignUpHandler.DeleteSelectedItem(LB_Description.ListIndex)
40    Call Me.FillListbox
50    LB_Description.ListIndex = merk

      'drucken und auf Pad darstellen
60    If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Or _
         Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Then
70      Call Me.ParentIkolClientApp.CommandBarCommands.ArcActiveDocument2
80    End If
      'ENDE 19.04.2016 AL
      
      '19.04.2016 AL
      If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Or _
         Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Then
        mboolDruckIntern = False
      End If
      
100   Call Me.DoAction(True)
110   Call Me.ParentIkolClientApp.SignUpHandler.SignupSelectedItem(LB_Description.ListIndex)
End Sub

Private Sub B_DeleteSign_Click()
10    Call Me.ParentIkolClientApp.SignUpHandler.DeleteSelectedItem(LB_Description.ListIndex)
20    Call FillListbox
End Sub

'Button ENDE
Private Sub B_End_Click()
10    Call Me.ParentIkolClientApp.SignUpHandler.CancelMultiSignUp
20    Me.hide
     
      '25.04.2016 AL
      'finale Frage
      '19.04.2016 AL
30    If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Or _
         Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Then
40      If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.UPadFinalQuestion = True Then
          Dim session As TC_Session
50        Set session = Me.ParentIkolClientApp.SessionsContainer.GetActiveSession
60        Call Me.ParentIkolClientApp.CommandBarCommands.ArcActiveDocument2
          Dim intHeight As Integer
          Dim intWidth As Integer
          Dim boolReturn As Boolean
          Dim strPDFfromArcDir As String
70        strPDFfromArcDir = session.ArchivDir + Dir(session.ArchivDir + "*.pdf")
          'MsgBox "PDF: " + strPDFfromArcDir
          
          '19.04.2016 AL
80        If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Then
90          Application.Run "SignUpAppHandler.StartApp_ST_ALPHA", session.workingDocument.name, _
                             "", session.IniFile, intWidth, intHeight, _
                             session.SignScaleFactor, boolReturn, strPDFfromArcDir
100       End If
         
          '19.04.2016 AL
110       If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Then
120         Application.Run "SignUpAppHandler.StartApp_ST_DELTA", session.workingDocument.name, _
                             "", session.IniFile, intWidth, intHeight, _
                             session.SignScaleFactor, boolReturn, strPDFfromArcDir
130       End If
         
          'Kontrollfenster in den Vordergrund
          'Kontrolfenster wegmachen geht nicht
          Dim longHwnd As Long
140       longHwnd = FindWindow(vbNullString, "Kontrollfenster")
150       Call Focus.ForceForegroundWindow(longHwnd)
         
          Dim MsgBoxResult As VbMsgBoxResult
          'vbCrLf
160       MsgBoxResult = Me.ParentIkolClientApp.LogfileHandler.DispayYNmsgBox( _
                                             "Unterschrift(en) korrekt?")
          'Ja: App beenden
          'Nein: neu starten
170       If MsgBoxResult = vbYes Then
180         B_Cancel_Click
190         Call Me.ParentIkolClientApp.SignUpHandler.CancelMultiSignUp
200         Me.hide
210       End If

220       If MsgBoxResult = vbNo Then
230         B_Cancel_Click
240         Call Me.ParentIkolClientApp.SignUpHandler.CancelMultiSignUp
250         Me.hide
260         Call Me.ParentIkolClientApp.CommandBarCommands.GetSignature
270       End If
          
280     End If
290   End If
      'ENDE 25.04.2016 AL
      
End Sub

' ==========================================================================
'  Buttons zur Steuerung der Unterschrifteneingabe (|fffd|bnernehmen, clear, Abbruch)
' ==========================================================================
'|fffd|bernehmen, erweiteretes Controlfenster
Private Sub B_GetSign_Click()
    Dim retBool As Boolean

10    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_GetSign gestartet")
20    retBool = Me.ParentIkolClientApp.SignUpHandler.saveSignature

      '14.07.2014 AL
      'tritt auf, wenn Unterschrift leer (|fffd|bernehmen, obwohl noch nix unterschrieben)
30    If retBool = False Then
        '19.04.2016 AL und 06.11.2017 AL
40      If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU300" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU430" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU530" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU540" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU541" Then
50        B_Cancel_Click
60        Exit Sub
70      End If
        'ENDE 19.04.2016 AL
        
80      Call Me.DoAction(True)
90      Call Me.FillListbox
100     Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True
110     Me.ParentIkolClientApp.SignUpHandler.MultiSignupStarted = True '24.07.2014 AL hat gefehlt
120     Exit Sub
130   End If
      'ENDE 14.07.2014 AL

140   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_GetSign endet mit " & Me.ParentIkolClientApp.Tools.BoolToStr(retBool))
150   Call Me.DoAction(False)
160   Call Me.FillListbox
End Sub

Private Sub B_Clear_Click()
    Dim retBool As Boolean

10    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_SignClear gestartet")
20    retBool = Me.ParentIkolClientApp.SignUpHandler.Clear
40    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_SignClear endet mit " & Me.ParentIkolClientApp.Tools.BoolToStr(retBool))
End Sub

Private Sub B_Cancel_Click()
    Dim retBool As Boolean

10    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_CancelButton gestartet")
20    retBool = Me.ParentIkolClientApp.SignUpHandler.CancelSignUp
30    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_CancelButton endet mit " & Me.ParentIkolClientApp.Tools.BoolToStr(retBool))
40    Call Me.DoAction(False)
End Sub

Private Sub B_RefreshSynchScreen_Click()
5   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_RefreshSynchScreen gestartet")
10  Call Me.ParentIkolClientApp.SignUpHandler.ResetSignupWindow
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_RefreshSynchScreen Ende")
End Sub

Private Sub LB_Description_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
5   Call Me.DoAction(True)
10  Call Me.ParentIkolClientApp.SignUpHandler.SignupSelectedItem(LB_Description.ListIndex)
15  Cancel = True
End Sub

' ==========================================================================
'   Merken der Position der zweiten Ansicht
' ==========================================================================
Private Sub B_Position_Click()
    Dim retBool As Boolean

5   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_Position gestartet")
10  Me.ParentIkolClientApp.SignUpHandler.WriteWindowsPosition
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_Position Ende")

End Sub

' ==========================================================================
'   Initialisierung
' ==========================================================================
Private Sub UserForm_Initialize()
5   Me.DoAction (False)
End Sub

Public Sub FillListbox()
    Dim count As Integer

5   count = Me.ParentIkolClientApp.SignUpHandler.FillListWithSignNames(LB_Description)
10  If count > 0 Then
15      LB_Description.ListIndex = 0
20      TB_Description.text = LB_Description.text
25  End If

End Sub

Private Sub LB_Description_Click()
5   TB_Description.text = LB_Description.text
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    ' verhindern, dass |fffd|ber (x) der Progressbalken geschlossen wird
5   If CloseMode = 0 Then
10      Cancel = 1
15  End If
End Sub
Attribute VB_Name = "frmTC_Signup"
Attribute VB_Base = "0{EDBF80BC-C9D8-4F6B-A49E-176ED8F93CD8}{B6833C6D-5196-479C-B5C1-624102240DCF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Private Sub UserForm_Terminate()
5   Call Me.ParentIkolClientApp.SignUpHandler.GetSignCancel
10  Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmSignup.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property


Public Sub DoAction(value As Boolean)

5   B_SignUp1.enabled = Not value
10  B_SignDelete.enabled = Not value

15  If value Then
20      B_GetSign.TakeFocusOnClick = value
25  End If

30  B_GetSign.enabled = value
35  B_SignClear.enabled = value

40  If Not value Then
45      B_GetSign.TakeFocusOnClick = Not value
50  End If

End Sub

Private Sub B_CancelButton_Click()
    Dim retBool As Boolean

5   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_CancelButton gestartet")
10  retBool = Me.ParentIkolClientApp.SignUpHandler.EndOfSignUp
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_CancelButton endet mit " & retBool)
20  Me.ParentIkolClientApp.SignUpHandler.SignReturn = False
25  Me.hide
End Sub

'|fffd|bernehmen, einfaches Controlfenster
Private Sub B_GetSign_Click()
    Dim retBool As Boolean

10    Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_GetSign gestartet")
20    retBool = Me.ParentIkolClientApp.SignUpHandler.saveSignature

      '14.07.2014 AL
      'tritt auf, wenn Unterschrift leer (|fffd|bernehmen, obwohl noch nix unterschrieben)
30    If retBool = False Then
        
        '19.04.2016 AL und 06.11.2017 AL
40      If Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_ALPHA" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "ST_DELTA" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU300" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU430" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU530" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU540" Or _
           Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.SignPad = "WACOM_STU541" Then
50        Call Me.DoAction(False)
60        Me.ParentIkolClientApp.SignUpHandler.SignReturn = True
70        Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True
80        Exit Sub
90      End If
        'ENDE 19.04.2016 AL

100     Call Me.DoAction(True)
110     Me.ParentIkolClientApp.SignUpHandler.SignReturn = True '24.07.2014 AL muss nach DoAction
120     Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True '24.07.2014 AL hat gefehlt
130     Exit Sub
140   End If
      'ENDE 14.07.2014 AL
150   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_GetSign endet mit " & retBool)
160   Me.ParentIkolClientApp.SignUpHandler.SignReturn = True
170   Me.ParentIkolClientApp.SignUpHandler.SignupStarted = True '25.07.2014 AL hat gefehlt
180   Call Me.DoAction(False)
End Sub

Private Sub B_Position_Click()
    Dim retBool As Boolean

5   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_Position gestartet")
10  Me.ParentIkolClientApp.SignUpHandler.WriteWindowsPosition
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_Position Ende")

End Sub

Private Sub B_RefreshSynchScreen_Click()
5   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_RefreshSynchScreen gestartet")
10  Call Me.ParentIkolClientApp.SignUpHandler.ResetSignupWindow
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_RefreshSynchScreen Ende")
End Sub

Private Sub B_SignClear_Click()
    Dim retBool As Boolean

5   Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_SignClear gestartet")
10  retBool = Me.ParentIkolClientApp.SignUpHandler.Clear
15  Call Me.ParentIkolClientApp.LogfileHandler.ProtokollMsg("B_SignClear endet mit " & retBool)

End Sub

Private Sub B_SignDelete_Click()
5   Call Me.ParentIkolClientApp.SignUpHandler.DeleteSelectedItem(0)
End Sub

Private Sub B_SignUp1_Click()
10    Call Me.DoAction(True)
20    Me.ParentIkolClientApp.SignUpHandler.SignupStarted = False '25.07.2014 AL hat gefehlt
30    Call Me.ParentIkolClientApp.SignUpHandler.SignupSelectedItem(0)
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    ' verhindern, dass |fffd|ber (x) der Progressbalken geschlossen wird
5   If CloseMode = 0 Then
10      Cancel = 1
15  End If
End Sub
Attribute VB_Name = "frmTC_SyncProgress"
Attribute VB_Base = "0{5F638A7C-D3D4-4F07-9C97-C181B62B2460}{9BAB9FC1-28D3-442D-BD41-5F05E89D4432}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

' SyncForm - Fortschrittsanzeige
Private Sub UserForm_Activate()
  Dim i As Integer
  
  Me.Repaint

  For i = 1 To 10
    Label1.width = i * 20
    Frame1.Repaint
    Sleep 50
  Next i

  Unload Me
End Sub


Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmTC_SyncProgress.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property
Attribute VB_Name = "frmTC_Vorschau"
Attribute VB_Base = "0{5057C401-F111-4DE7-99AE-ED41E226F88C}{685620C7-A502-4F8D-ACD7-7E0BD5A1059F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private mobjParentIkolClientApp As TC_IkolClientApp

Public Property Get ParentIkolClientApp() As TC_IkolClientApp
5   Set ParentIkolClientApp = mobjParentIkolClientApp
End Property

Public Property Set ParentIkolClientApp(objParentIkolClientApp As TC_IkolClientApp)
5   If mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = objParentIkolClientApp
15  Else
20      Err.Raise glongCUSTOM_ERR_CLASS_PROPERTY_ALREADY_SET, "frmTC_Vorschau.ParentIkolClientApp", "Diese Eigenschaft ist bereits gesetzt worden."
25  End If
End Property

Private Sub DoHotKeyAction(KeyCode As Integer, Modification As Integer, Focus As String)

5   On Error GoTo ErrorHandler

    Dim Character As String
    Dim Shift As Boolean
    Dim Strg As Boolean
    Dim Alt As Boolean
    Dim msg As String

10  Character = Chr(KeyCode)
15  Shift = Modification And 1
20  Strg = Modification And 2
25  Alt = Modification And 4

30  If Character = "D" And Not Shift And Not Strg And Not Alt Then    ' d
35      Call cmdDruck_Click
40  ElseIf Character = "X" And Not Shift And Not Strg And Not Alt Then    ' x
45      Call cmdSchlie|fffd|en_Click
50  ElseIf Character = "R" And Not Shift And Not Strg And Not Alt Then    ' r
55      Call cmdAb_Click
60  ElseIf Character = "R" And Shift And Not Strg And Not Alt Then    ' R
65      Call cmdBildAb_Click
70  ElseIf Character = "R" And Not Shift And Not Strg And Alt Then    ' Alt+r
75      Call cmdSeiteAb_Click
80  ElseIf Character = "H" And Not Shift And Not Strg And Not Alt Then    ' h
85      Call cmdAuf_Click
90  ElseIf Character = "H" And Shift And Not Strg And Not Alt Then    ' H
95      Call cmdBildAuf_Click
100 ElseIf Character = "H" And Not Shift And Not Strg And Alt Then    ' Alt+h
105     Call cmdSeiteAuf_Click
110 ElseIf Character = "G" And Not Shift And Not Strg And Not Alt Then    ' g
115     Call cmdGanzeSeite_Click
120 ElseIf Character = "S" And Not Shift And Not Strg And Not Alt Then    ' s
125     Call cmdSeitenbreite_Click
130 ElseIf Character = "I" And Not Shift And Not Strg And Not Alt Then    ' i
135     Call help_Click
140 ElseIf Character = "1" And Not Shift And Not Strg And Not Alt Then    ' 1
145     Call ganzoben_Click
150 ElseIf Character = "E" And Not Shift And Not Strg And Not Alt Then    ' e
155     Call ganzunten_Click
160 ElseIf KeyCode = 226 And Not Shift And Not Strg And Not Alt Then    ' <
165     Call cmdLinks_Click
170 ElseIf KeyCode = 226 And Shift And Not Strg And Not Alt Then    ' >
175     Call cmdRechts_Click
180 Else
185 End If

ExitProc:
190 On Error Resume Next
195 Exit Sub

ErrorHandler:
200 Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "DoHotKeyAction", , vbNullString)
205 Resume ExitProc

End Sub

Public Sub CustomShowUserForm()

5   On Error GoTo ErrorHandler

10  cmdSeitenbreite_Click

15  cboZoom.AddItem "500%"
20  cboZoom.AddItem "200%"
25  cboZoom.AddItem "150%"
30  cboZoom.AddItem "100%"
35  cboZoom.AddItem "75%"
40  cboZoom.AddItem "50%"
45  cboZoom.AddItem "25%"
50  cboZoom.AddItem "10%"
55  cboZoom.text = str(Selection.Information(wdZoomPercentage)) + "%"

60  help.Accelerator = "i"
65  cmdSchlie|fffd|en.SetFocus

    ' bei mehreren Sitzungen (offenen Dokumenten) wird die UserForm auf einem falschen Dokument positioniert
    ' daher das richtige in den Vordergrund holen

70  Me.ParentIkolClientApp.SessionsContainer.GetActiveSession.workingDocument.Activate

75  Me.Show

ExitProc:
80  On Error Resume Next
85  Exit Sub

ErrorHandler:
90  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "CustomShowUserForm", , vbNullString)
95  Resume ExitProc

End Sub

Private Sub UserForm_Terminate()
5   PrintPreview = False
10  Call Me.CleanUp
End Sub

Public Sub CleanUp()
5   If Not mobjParentIkolClientApp Is Nothing Then
10      Set mobjParentIkolClientApp = Nothing
15  End If
End Sub

Private Sub cmdSchlie|fffd|en_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdSchlie|fffd|en"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdSchlie|fffd|en_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdSchlie|fffd|en_Click()

5   On Error GoTo ErrorHandler

10  PrintPreview = False
15  Me.hide

ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdSchlie|fffd|en_KeyDown", , vbNullString)
35  Resume ExitProc
End Sub

Private Sub cmdDruck_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)

5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdDruck"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdDruck_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdDruck_Click()
5   On Error GoTo ErrorHandler
10  ActiveDocument.PrintOut
15  PrintPreview = False
20  Me.hide

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdDruck_Click", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub cmdLinks_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler


    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdLinks"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdLinks_KeyDown", , vbNullString)
40  Resume ExitProc

End Sub

Sub cmdLinks_Click()
5   On Error GoTo ErrorHandler
10  Call ActiveWindow.ActivePane.SmallScroll(0, 0, 0, 1)

ExitProc:
15  On Error Resume Next
20  Exit Sub

ErrorHandler:
25  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdLinks_Click", , vbNullString)
30  Resume ExitProc

End Sub

Private Sub cmdRechts_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdRechts"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdRechts_KeyDown", , vbNullString)
40  Resume ExitProc

End Sub

Sub cmdRechts_Click()
5   Call ActiveWindow.ActivePane.SmallScroll(0, 0, 1, 0)
End Sub

Private Sub cmdAuf_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer

10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdAuf"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdAuf_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdAuf_Click()
5   On Error GoTo ErrorHandler

10  Call ActiveWindow.ActivePane.SmallScroll(0, 3, 0, 0)
15  Application.ScreenRefresh

ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdAuf_KeyDown", , vbNullString)
35  Resume ExitProc
End Sub

Private Sub cmdAb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdAb"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdAb_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdAb_Click()
5   On Error GoTo ErrorHandler

10  Call ActiveWindow.ActivePane.SmallScroll(3, 0, 0, 0)
15  Application.ScreenRefresh

ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdAb_Click", , vbNullString)
35  Resume ExitProc
End Sub

Private Sub cmdBildAuf_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdBildAuf"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdBildAuf_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdBildAuf_Click()
5   On Error Resume Next

10  ActiveWindow.ActivePane.LargeScroll up:=1
15  Application.ScreenRefresh

End Sub

Private Sub cmdBildAb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdBildAb"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdBildAb_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdBildAb_Click()

5   On Error Resume Next

10  ActiveWindow.ActivePane.LargeScroll down:=1
15  Application.ScreenRefresh
End Sub

Private Sub cmdSeiteAuf_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler
    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdSeiteAuf"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdBildAb_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub cmdSeiteAuf_Click()
5   On Error Resume Next

10  ActiveWindow.ActivePane.PageScroll up:=1
15  Application.ScreenRefresh
End Sub

Private Sub cmdSeiteAb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler
    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdSeiteAb"
ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdSeiteAb_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub cmdSeiteAb_Click()
5   On Error Resume Next

10  ActiveWindow.ActivePane.PageScroll down:=1
15  Application.ScreenRefresh
End Sub

Private Sub ganzunten_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler
    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "ganzunten"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "ganzunten_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub ganzunten_Click()
5   On Error GoTo ErrorHandler
10  Selection.EndKey Unit:=wdStory, Extend:=wdMove
15  Application.ScreenRefresh
ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "ganzunten_Click", , vbNullString)
35  Resume ExitProc
End Sub

Private Sub ganzoben_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler
    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "ganzoben"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "ganzunten_Click", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub ganzoben_Click()
5   On Error GoTo ErrorHandler
10  Selection.HomeKey Unit:=wdStory, Extend:=wdMove
15  Application.ScreenRefresh
ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "ganzoben_Click", , vbNullString)
35  Resume ExitProc
End Sub

Private Sub cmdGanzeSeite_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler
    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdGanzeSeite"
ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdGanzeSeite_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdGanzeSeite_Click()
5   On Error GoTo ErrorHandler
10  ActiveWindow.ActivePane.View.Zoom.PageFit = wdPageFitFullPage
15  cboZoom.text = CStr(Selection.Information(wdZoomPercentage)) & "%"

ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdGanzeSeite_Click", , vbNullString)
35  Resume ExitProc
End Sub

Private Sub cmdSeitenbreite_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler
    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "cmdSeitenbreite"
ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdSeitenbreite_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Sub cmdSeitenbreite_Click()
5   On Error GoTo ErrorHandler
10  ActiveWindow.ActivePane.View.Zoom.PageFit = wdPageFitBestFit
15  cboZoom.text = CStr(Selection.Information(wdZoomPercentage)) & "%"

ExitProc:
20  On Error Resume Next
25  Exit Sub

ErrorHandler:
30  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cmdSeitenbreite_Click", , vbNullString)
35  Resume ExitProc
End Sub

Sub cboZoom_Click()
5   On Error GoTo ErrorHandler
10  ActiveWindow.ActivePane.View.Zoom.Percentage = val(cboZoom.text)
ExitProc:
15  On Error Resume Next
20  Exit Sub

ErrorHandler:
25  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cboZoom_Click", , vbNullString)
30  Resume ExitProc
End Sub

Private Sub cboZoom_Exit(ByVal Cancel As MSForms.ReturnBoolean)
5   On Error GoTo ErrorHandler

    Dim percent As Long


10  percent = val(cboZoom.text)

15  If percent >= 10 And percent <= 500 Then
20      ActiveWindow.ActivePane.View.Zoom.Percentage = percent
25      ActiveWindow.ActivePane.View.Zoom.PageFit = wdPageFitNone
30      ActiveWindow.ActivePane.DisplayRulers = True
35      cboZoom.text = CStr(percent) & "%"
40  End If

ExitProc:
45  On Error Resume Next
50  Exit Sub

ErrorHandler:
55  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "cboZoom_Exit", , vbNullString)
60  Resume ExitProc
End Sub

' Exit(ByVal Cancel As MSForms.ReturnBoolean)
' Nachteil, Anzeige|fffd|nderung immer wenn das Feld verlassen wird, auch wenn nichts ge|fffd|ndert wurde.
' Change |fffd|ndert sofort den Text. Effekt: eingabe von 10 -> |fffd|ndern auf 4
' -> Zeichen l|fffd|schen, l|fffd|scht dann aber die interne 0 und zeigt dann die 1 an
' Enter |fffd|ndert die Ansicht in unkontorllierterte Weise
' AfterUpdate trifft es am besten

Private Sub txtSpalte_AfterUpdate()
5   On Error GoTo ErrorHandler
10  If val(txtSpalte.text) < 1 Then txtSpalte.text = 1
15  If val(txtSpalte.text) > 10 Then txtSpalte.text = 10

20  ActiveWindow.ActivePane.View.Zoom.PageColumns = val(txtSpalte.text)
25  cboZoom.text = CStr(Selection.Information(wdZoomPercentage)) & "%"
30  Application.ScreenRefresh
ExitProc:
35  On Error Resume Next
40  Exit Sub

ErrorHandler:
45  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "txtSpalte_AfterUpdate", , vbNullString)
50  Resume ExitProc

End Sub

Private Sub txtZeile_AfterUpdate()
5   On Error GoTo ErrorHandler

10  If val(txtZeile.text) < 1 Then txtZeile.text = 1
15  If val(txtZeile.text) > 4 Then txtZeile.text = 4

20  ActiveWindow.ActivePane.View.Zoom.PageRows = val(txtZeile.text)
25  cboZoom.text = CStr(Selection.Information(wdZoomPercentage)) & "%"
30  Application.ScreenRefresh

ExitProc:
35  On Error Resume Next
40  Exit Sub

ErrorHandler:
45  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "txtZeile_AfterUpdate", , vbNullString)
50  Resume ExitProc
End Sub

Private Sub help_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
5   On Error GoTo ErrorHandler

    Dim myKeyCode As Integer
    Dim myShift As Integer
10  myKeyCode = KeyCode
15  myShift = Shift
20  DoHotKeyAction myKeyCode, myShift, "help"

ExitProc:
25  On Error Resume Next
30  Exit Sub

ErrorHandler:
35  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "help_KeyDown", , vbNullString)
40  Resume ExitProc
End Sub

Private Sub help_Click()
5   On Error GoTo ErrorHandler

10  Me.ParentIkolClientApp.frmAnsichtInfo.Show

ExitProc:
15  On Error Resume Next
20  Exit Sub

ErrorHandler:
25  Call DotCentralErrorHandler(Me.ParentIkolClientApp, "frmTC_Vorschau", "help_Click", , vbNullString)
30  Resume ExitProc
End Sub

' InQuest injected base64 decoded content
' jY[i
' jwez
' sy+Z
' jy]z
' Bz{kjQ+
' jwez
' Z,x	eI
'  ~)^M
' jwex
' )bz{@
' Z,x:
' YMjg
' p't*&
' J('R
' J('R
' ^t*&
' p't*&
' )bz{@
' z{Qy
' z{Mjg
' jwAj
' 'vz-y'
' 'vz-x*'
' 'vz-x*'
' bzWl
' z{Qy
' Lj)Lz
' z{l"p
' z{l"p
' z{Qy
' YLjv
' uj+t:
' Z+aJ
' Z+a 
' xLmz{"
' )bz{Rz
' )bz{@
' jwez
' jw[j
' p't*&
' J('R
' Z,y'
' Z,y'
' zu)u
' u'+R
' jwAj
' jwAj
' j+uW
' +jcZ
' xZ+I
' jT.z
' >'BjY^
' {a1x
' Gz(!
' x%y(
' J(':
' J('j
' ,J('>'-
' Gz(!
' Gz(!

INQUEST-PP=macro
