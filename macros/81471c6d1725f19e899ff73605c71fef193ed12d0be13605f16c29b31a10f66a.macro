Attribute VB_Name = "ErrorLog"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "CommandButton1, 1, 0, MSForms, CommandButton"
Option Explicit

Private Sub CommandButton1_Click()
Call Module1.clearErrorLog
End Sub
Attribute VB_Name = "Exchange"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Module1"
Option Explicit

'---BEWARE WITH REMOTE WORK - IF REFRESH IS SLOW ONE CAN CHANGE CODE WITHOUT REALIZING IT - LEADS TO SUBTLE VBA ERRORS

'---DOCUMENTATION - REG - 04/04/16
'---UPDATE   - REG - 03/28/16 - FIXED MARKIT ISSUE - ADD ON MAX/MIN WAS COMPARING AS STRING (TEXT OF CELL) - REPLACED WITH NUMBER IN CELL (VALUE)
'---UPDATE   - REG - 03/29/16 - FIXED MARKIT ISSUES - SAME CONDITIONS FOR BROK AMOUNT NOW ENFORCE FOR BAND, VOL DISC ETC
'---UPDATE   - REG - 04/04/16 - FIXED ELINS  ISSUE - ADDED SPECIAL BAND NUMERIC FORMATTING PER RATE TYPE - INTEGER/DECIMAL START/END - AT ENDOF SUB FORMATNUMERICCOLUMNS
'                             - ALSO ADDED CASE TO SELECTION CHANGE TO FORMAT ADDON AND MIN MAX AMOUNTS
'---UPDATE   - REG - 04/09/16 - FIXED BUG WHERE IF VD/BD DID NOT FLAG MISSING REGION->PROD
'---UPDATE   - REG - 04/22/16 - ALLOW BROK AMT AND MIN AMT AS ZERO, PQT ITEMS, ROW SHADING FIXED, COMPILE ERROR 64-BUT FIXED
                              
'---GENERAL VARIABLES AND SUBS IN THIS MODULE

'---Note: THERE ARE MANY KEY ITEMS IN THE:

'---1) eModule (workbook level - workbook open etc) and the
'---2) ModuleSheet (eModule tab) - such as Worksheet_SelectionChange (where we react to all cell movements by column)

'--- The main and larger subs are (in order of normal operation):
'---0) Workbook_Open on the workbook level eModule excel obj which starts the eModule cboxes, sorts etc
'---2) When doing inputs are Worksheet_SelectionChange on ModuleSheet
'---3) User performed validation in module2 - PerformValidation sub, and many other aux subs there

'--- There are also large codes under the forms for the PQT AND GKS in module3, the RIBBON CALLBACKS are in module4

'---TECH NOTE: This program, specially on validation proc depends a lot on detecting input errors.
'---In vba when we have a multiple conditions boolean statement - ALL (logical) conditions will be validated
'---this is true even for 'or' statements where the 1st is false. IF some condition such as CDBL, CLNG, CINT is given
'---a non numeric value a vba error will result. In the validation proc has a trap for these error (handler).
'---to detect a non num value place the isnumeric in an external loop of it;s own - not mixed with cdbl etc
'---We aim that validation will be performed for all rows - so that no vba error stops it - so we check isnumeric 1st if needed

'--- IMPORTANT: FOR ERROR HANDLING TO WORK MUST SET VBA OPTION - TOOLS OPTIONS GENERAL - BREAK ON UNHANDLED ERRORS

Public Const eModuleVersion = "eModule 3.5.1.20160422" '-- must be the same as the label on the spreadsheet

Public Const showSheetsBln As Boolean = False '--testing - HIDE /UNHIDE ALL TABS-----

Public Const debugStatus = False
Public Const debugStatusMsg = False

Public Const eModProdName = "eModule"
Public Const saveResultsTab = "eModule"
Public userLastPQTzoom As Integer
Public PQTlogical As String

'---SUPPORT FOR PRECALC VALUES FOR VOL DISC / BANDS
Public lastRateType1 As String '-- needs to sruvive amoung calls to wks sel chg

'--- these are use mostly in band rates - depend on type of rate (intger or decimal)- emod 3.5 reg - 3/1/16
Public Const maxRateValue = 99999.99999 '--- non of bps or number of contracts
Public Const minRateValue = 0.00001 '--- non of bps or number of contracts
Public Const maxRateValueInteger = 999999999 '-- of bps and number of contracts

'---3/22/16-REG-RATE CODES FOR BROK AMT LIMITS OF 9999.999999 OR 999.99999 (5 and 3 digits) USE INVALIDATION - EXACT MATCHES
Public Const maxRateAmtList99999 = "Per Contract,BTU,TONNES,Barrels,Per Trade,MWH,BPS,Metric Tons,MBTU"
Public Const maxRateAmtList999 = "%Notional,%Premium,Vega"
Public Const max3digits = 999.99999
Public Const max5digits = 99999.99999

Public Const maxAddOn = max5digits
Public Const maxMinMaxDigits = max5digits

Public Const cellCommentsWidth = 200 '---3/22/16-REG-ERROR COMMENT BOX LARGER

'--- NAMES FOR THE THREE USER FORMS
Public Const NP = "frmNavigationPanel"
Public Const CP = "frmControlPanel"
Public Const PQT = "frmProdQueryTool"

'--- THESE ARE COLS FOR THE **STATIC DATA SHEET** (NOT THE EMODULE) - they have been changed to contiguous
Public Const StaticDataCurrencyColumn = "B"
Public Const StaticDataTradeTypeColumn = "C"
Public Const StaticDataSpreadTypeColumn = "D"
Public Const StaticDataRateTypeColumn = "E"
Public Const StaticDataExecutionTypeColumn = "F"

Public Const StaticDataAddOnApplyColumn = "G"

Public Const StaticDataMMApplyColumn = "H"
Public Const StaticDataMMDefineColumn = "I" '--EMOD 3.5

Public Const StaticDataTierDefinedBasedColumn = "J"
Public Const StaticDataTierApplyToColumn = "K"
Public Const StaticDataTiersValueTypeColumn = "L"  '--EMOD 3.5

Public Const StaticDataBandApply = "M" '--EMOD 3.5
Public Const StaticDataBandValueType = "N" '--EMOD 3.5
Public Const StaticDataBandRateType = "O" '--EMOD 3.5

Public Const StaticDataDirectBillColumn = "P"
Public Const StaticDataDefaultExecutionTypeColumn = "Q"


'--- THESE ARE COLS FOR THE REF DATA TO LOAD ARRAYS/CBOXES (NOT THE EMODULE)

Public Const RefDataRegionColumn As String = "A"
Public Const RefDataExchangeColumn As String = "B"
Public Const RefDataProductGroupCodeColumn As String = "C"
Public Const RefDataProductColumn As String = "D"
Public Const RefDataProductTypeColumn As String = "E"
Public Const RefDataProductDefaultCurrencyColumn As String = "F"

Public Const RefDataRegionColumnSorted As String = "D"
Public Const RefDataExchangeColumnSorted As String = "C"

'--- THESE ARE COLS FOR THE ERROR LOG TAB

Public Const ErrorLogTimeStampColumn As String = "A"
Public Const ErrorLogRowNumberColumn As String = "B"
Public Const ErrorLogColumnNameColumn As String = "C"
Public Const ErrorLogMessageColumn As String = "D"

Public Const emailFIA = "ewiklund@fia-tech.org" '-- keep current
Public Const eModuleErrorMsgToUser = "Please report this error and the related details (send error image and the the eModule) to FIA Tech Email: " + emailFIA

Public eModNewLineFlag As Boolean
Public invalidRowFlag As Boolean
Public workbookOpenIsRunning As Boolean '--emod 3.5
Public currentCurrencyRow As Long

Public cBoxCollectionNames(40) As String

'--- emod 3.5 - reg - for usability keep last selected cell after operations, keep global to enable live with other sub calls
Public saveCurrCell1 As Range
Public saveCurrCell2 As Range
Public saveCurrCell3 As Range
Public saveCurrCell4 As Range

Public prodTypeEquivalents As String '-- the currently selected prod type in drop down
Public prodTypeRelations(1 To 6, 1 To 2) As String
Public cboxList(1 To 20, 1 To 2) As String '--- emod 3.5 need to know the cboxes and info about them
Public cboxListGroups(1 To 5, 1 To 3) As Integer


Public eModShadeTurnedOn As Boolean
Public eModLastCellrng As Range
Public cboxesUserDefListRows As Integer
Public Const cboxesUserDefListRowsDefault = 10 '-- 3/8/16-reg-reduced from 20 - problem displays with cboxes if disp does not fit below
Public disableWorksheetSelectionChange As Boolean
Public productTypeMessageFlag As Boolean

Public Const title1 As String = "eModule"
Public Const title2 As String = title1 + " Validation"

Public lastActiveCellValue As String
Public PQTselProdFirstTime As Boolean
Public PQTnotMsgDisplayed As Boolean
Public PQTinUseDisableCboxes As Boolean

Public NPdataEntryModeStatus As Boolean

'==== CONSTANTS AND VARIABLES
Public currentCboName As String '-- the current cbo per selection change column
Public currentCboColumn As String

Public sortOnFlag As Boolean

Public Const ModuleSheetNumberOfColumns As Long = 32 '--- REL 3.5 HAS 32 COLS VS 24 BEFORE - REG - 6/6/15
Public Const StaticDataSheetNumberOfColumns As Long = 17 '--- REL 3.5 ELIM BLANK COLUMNS - NEW FIELDS & COLUMN DATA - REG - 6/9/15




Public eModuleColumnsInfoArray(1 To 35, 1 To 3) As String
Public eModuleColumnsNames(1 To 35) As String

Public cBoxCollection As New Collection

Public Const ModuleSheetCodeName As String = "ModuleSheet"
Public Const RegionSheetCodeName As String = "Region"
Public Const ExchangeSheetCodeName As String = "Exchange"
Public Const ProductGroupCodeSheetCodeName As String = "ProductGroupCode"
Public Const ProductSheetCodeName As String = "Product"
Public Const StaticDataSheetCodeName As String = "StaticData"
Public Const ErrorLogSheetCodeName As String = "ErrorLog"

Public Const ModuleSheetName As String = "eModule"
Public Const StaticDataSheetName As String = "Static Data"

Public Const RegionHeader As String = "Region_Desc"
Public Const ExchangeHeader As String = "Exchange_Desc"

Public SheetMissing As Boolean
Public NoDataRows As Boolean

Public RegionLastRow As Long
Public ExchangeLastRow As Long
Public ProductGroupCodeLastRow As Long
Public ProductLastRow As Long

'--- DYNAMIC ARRAYS FOR REGION-EXCHANGE-PROD GROUP AND PRODUCTS
Public RegionArray() As String
Public ExchangeArray() As String
Public ProductGroupCodeArray() As String
Public ProductArray() As String

'--- DYNAMIC ARRAYS UPPER BOUNDS FOR REGION-EXCHANGE-PROD GROUP AND PRODUCTS
Public RegionArrayUBound As Long
Public ExchangeArrayUBound As Long
Public ProductGroupCodeArrayUBound As Long
Public ProductArrayUBound As Long

Public ModuleLastRow As Long

Public ModuleLastRowRegion As Long
Public ModuleLastRowExchange As Long
Public ModuleLastRowProductGrp As Long
Public ModuleLastRowProductCount As Long
Public ModuleLastRateTypeCount As Long
Public ModuleLastRowAmountCount As Long
Public ModuleLastRowTierRateCount As Long
Public ModuleLastRowBandRateCount As Long
Public ModuleLastRowTierNumberCount As Long
Public ModuleLastRowBandNumberCount As Long


Public Const ModuleFirstRow As Long = 4 '-- used in all the program for cell addr (first row->last), < 3 etc

Public Const LastSheetRow As Long = 1048576
Public Const LastSheetColumn As String = "XFD"
Public Const LastSheetColumnNumber As Long = 16384
Public Const SheetTopRow As Long = 1

Public Const ModuleMaxRows As Long = 20000
Public Const HeaderRowOffset As Long = 2
Public Const StaticDataRowOffset As Long = 2
Public Const NumberOfDigits As Long = 10

Public Const RegionSheetNumberOfColumns As Long = 1
'Public productTypeValidation(ModuleMaxRows) As String

Public Const ExchangeSheetNumberOfColumns As Long = 4
Public Const ProductGroupCodeSheetNumberOfColumns As Long = 3
Public Const ProductSheetNumberOfColumns As Long = 6 '--emod 3.5 has the new def currency

Public stdMsgIsNumericNonNegative '-- to be loaded in numeric check function - IsNumericNonNegative in module2

'": INVALID Number - Missing value, is Spaces, Non-Numeric, Negative, invalid Decimal places or over 5 decimal places."

'-- usage after calling bool function 'not IsNumericNonNegative(field)' then use the error message: field + stdMsgIsNumericNonNegative
'Public Const CutRange As Range

'--- THESE WILL BE LOADED UPON STARTUP PER DATA ON COL Z-AA-AB ON STATICDATA TAB

Public FirstColumn As String
Public LastColumn As String

Public DirectBillColumn As String
Public RegionColumn As String
Public ExchangeColumn As String
Public ProductGroupCodeColumn As String
Public ProductColumn As String
Public ProductTypeColumn As String
Public CurrencyColumn As String
Public TradeTypeColumn As String
Public SpreadTypeColumn As String
Public RateTypeColumn As String
Public ExecutionTypeColumn As String
Public DefaultExecutionTypeColumn As String
Public AmountColumn As String

Public MMMinAmountColumn As String
Public MMMaxAmountColumn As String
Public MMApplyColumn As String

Public AddOnAmountColumn As String
Public AddOnApplyColumn As String

Public TierDefinedBasedColumn As String
Public TierApplyToColumn As String
Public TierValueTypeColumn As String
Public TiersColumn As String
Public TierStartNumberAmountColumn As String
Public TierVolDiscRateColumn As String

'--- NEW FIELDS - REG - EMOD 3.5 - 6/9/15

Public MMDefineColumn As String


Public BandApplyColumn As String
Public BandValueTypeColumn As String
Public BandTierNoColumn As String
Public BandStartColumn As String
Public BandEndColumn As String
Public BandRateTypeColumn As String
Public BandRateColumn As String

'--- THE COLUMN NUMBERS HERE

Public DirectBillColumnNumber As Integer
Public RegionColumnNumber As Integer
Public ExchangeColumnNumber As Integer
Public ProductGroupCodeColumnNumber As Integer
Public ProductColumnNumber As Integer
Public ProductTypeColumnNumber As Integer
Public CurrencyColumnNumber As Integer
Public TradeTypeColumnNumber As Integer
Public SpreadTypeColumnNumber As Integer
Public RateTypeColumnNumber As Integer
Public ExecutionTypeColumnNumber As Integer
Public DefaultExecutionTypeColumnNumber As Integer
Public AmountColumnNumber As String

Public MMApplyColumnNumber As Integer
Public MMMinAmountColumnNumber As String
Public MMMaxAmountColumnNumber As String

Public AddOnAmountColumnNumber As String
Public AddOnApplyColumnNumber As String

Public TierDefinedBasedColumnNumber As String
Public TierApplyToColumnNumber As String
Public TierValueTypeColumnNumber As String
Public TiersColumnNumber As String
Public TierStartNumberAmountColumnNumber As String
Public TierVolDiscRateColumnNumber As String


'--- NEW FIELDS - REG - EMOD 3.5 - 6/9/15

Public MMDefineColumnNumber As Integer

Public BandApplyColumnNumber As Integer
Public BandValueTypeColumnNumber As Integer
Public BandTierNoColumnNumber As Integer
Public BandStartColumnNumber As Integer
Public BandEndColumnNumber As Integer
Public BandRateTypeColumnNumber As Integer
Public BandRateColumnNumber As Integer

Public MinCol As Integer
Public MaxCol As Integer

Public ComboBoxChange As Boolean
Const cBoxBackgColor = 34 '---light blue
Public ComboBoxRow As Long ' remove ???

Public RegionComboBoxRow As Long
Public ExchangeComboBoxRow As Long
Public ProductGroupCodeComboBoxRow As Long
Public ProductComboBoxRow As Long

Public ComboBoxTop As Long

Public RegionComboBoxTop As Long
Public ExchangeComboBoxTop As Long
Public ProductGroupCodeComboBoxTop As Long
Public ProductComboBoxTop As Long

Public AutoFillRegion As String
Public BandValueType_Current As String '-- for sel change when band types

Public Const ReturnKeyValue As Long = 13 ' ASCII code for carriage return (enter key)

Public StaticDataComboBoxRow As Long
Public StaticDataComboBoxTop As Long

Public Const InvalidRedValue As Long = 255
Public Const InvalidGreenValue As Long = 0
Public Const InvalidBlueValue As Long = 0

Public Const ValidRedValue As Long = 255
Public Const ValidGreenValue As Long = 255
Public Const ValidBlueValue As Long = 255
'--- BLACK - FOREGROUND
Public Const ComboBoxForeColorRedValue As Long = 0
Public Const ComboBoxForeColorGreenValue As Long = 0 ' 102
Public Const ComboBoxForeColorBlueValue As Long = 0 '255
'--- LIGHT CREAM - BACKG
Public Const ComboBoxBackgColorRedValue As Long = 255
Public Const ComboBoxBackgColorGreenValue As Long = 255
Public Const ComboBoxBackgColorBlueValue As Long = 204



Public Const ValidColorIndexValue As Long = xlNone 'cBoxBackgColor 'xlNone 'No Fill
Public Const InvalidColorIndexValue As Long = 15 'Light Gray
Public Const InvalidPatternValue As Long = xlPatternGrid
Public Const InvalidPatternColorIndexValue As Long = 38 'Pink
Public Const WarningColorIndexValue As Long = 6 'Yellow

Public Const EnableCutCopy As Boolean = True

Public Const EnableComments As Boolean = True
Public Const EnableErrorLog As Boolean = True
Public Const ErrorLogFirstRow As Long = 2
Public Const PW As String = "emodule"
Public ErrorLogRowCounter As Long

Public Const EnableDefaultProductGroupCode As Boolean = True
Public Const EnableValidationOnWorbookClose As Boolean = True
Public Const EnableCleanUpRoutine As Boolean = False

'--- VOL DISC AND BAND DISC - BAND EMOD 3.5

'--- THESE VALUES BELOW MUST AGREE WITH THE STATIC TAB OR DROPDOWNS - Col E, BAND VALUE TYPE ETC - RATE TYPE ETC.

Public Const BandingDiscountRateType As String = "Band" '-- emod 3.5 new - FIXED REG - PER MARKIT MEETING 11/30/15 TO BE IN AGREEMENT WITH BAND IN EGUS
Public Const VolumeDiscountRateType As String = "Vol Disc"

Public Const PercentNotionRateType As String = "%Notional" '-- emod 3.5 upd
Public Const PercentPremiumRateType As String = "%Premium" '-- emod 3.5 upd

Public Const VolumeDiscountStartTypeAmountValue As String = "Number of Contracts"
Public Const VolumeDiscountStartTypeNumberValue As String = "Number of Trades"


Public Const BandStartEndIntegerTypes As String = "Number of Contracts, BPS" '--- COLUMN N - STATIC TAB - BAND VALUE TYPES (not the BAND RATE TYPE)
'--- current band types are: BPS,Notional,Number of Contracts,Premium,Trade Price

Public Const FirstVolumeDiscountTier As Long = 1
Public Const FirstVolumeDiscountTierDefaultExecution As String = "Y"

Public Const FirstBandingDiscountTier As Long = 1
Public Const FirstbandingDiscountTierDefaultExecution As String = "Y"

'--- END OF VOL DISC AND BAND DISC

Public DecimalSeparator As String

Public Const NumberOfIntegerPlaces As Long = 10
Public Const NumberOfDecimalPlaces As Long = 5 '--- was 10 - 3/21/16 - markit asked for a max of 5 dec places
Public Const PercentRateTypeNumberOfIntegerPlaces As Long = 10

Public Const StartTypeNumberNumberOfIntegerPlaces = 10
Public Const StartTypeAmountNumberOfIntegerPlaces = 10
Public Const StartTypeAmountNumberOfDecimalPlaces = 10

Public Const PixelsToPointsFactor As Double = 0.75
Public Const ComboBoxWidthAdjustment As Double = 2
Public Const ComboBoxHeightAdjustment As Double = 3

Public Const cBoxType = "Forms.ComboBox.1"

Public Const decimalFormat0 = "###,###,##0" '--integer - reg 2/18/16 -
Public Const decimalFormat1 = "#,##0.00000" '--- reg - store common values
Public Const decimalFormat2 = "#,###.00000###"

Public eModuleWorksheetChangedFlag As Boolean
Public performValidationFlag As Boolean
Public performValidationTime As Date

'--- REG - 4/22/16 - REMOVED TO AVOID COMPILATION ERROR - 64 BIT SYS -PER ELIN EMAIL - USE ENVIRON USERNAE
'--- DECLARES MUST BE FIRST
'Declare Function WNetGetUser Lib "mpr.dll" _
'        Alias "WNetGetUserA" (ByVal lpName As String, _
'        ByVal lpUserName As String, lpnLength As Long) As Long




Public Sub deleteAndReportAlmostEmptyRows()

'-- to clean up the emod before validation or ribbon command or via clear formatting
'-- the pqt will leave blank lines between appended groups, or the case of Asia on region and no data
'-- note that if there is data in region, but no data in exchange - then there can be no data in prod group or product->empty
'---note too we do the delete of rows in reverse from down up
'---reg - 9/9/15 - per David finds needed to verify there was no data in the voldisc or band disc to avoid erasing data

ModuleSheet.Activate

disableWorksheetSelectionChange = True

Dim foundEmptyRows As Boolean
foundEmptyRows = False
Dim msg As String
Dim addr As String

Dim rx As Long
Module1.ModuleLastRow = Module1.getModuleLastRow + 10 '-- DELETE THE LAST 10 ROWS BELOW THE LAST COUNT DUE TO POSSIBLE JUNK, COMMENTS BELOW

For rx = Module1.ModuleLastRow To Module1.ModuleFirstRow Step -1 '-- REVERSE ORDER FOR DELETES!
       
     addr = Module1.ExchangeColumn + CStr(rx) + ":" + Module1.ExchangeColumn + CStr(rx)
     '--if there is no exchange is almost empty
               
         '-- precent erasing vol disc or band disc data even with possible incorrect type
         
         If Trim(Range(addr).Value) = "" And (Not foundVolDisc(rx)) And (Not foundBndDisc(rx)) Then
         
           '--- bottom 10 are not part of the emod
           If rx <= Module1.ModuleLastRow - 10 Then
             foundEmptyRows = True
             msg = msg + "  " + CStr(rx)
           End If
           
           Rows(CStr(rx) + ":" + CStr(rx)).Select
           
           Selection.Delete Shift:=xlUp
        End If
    


Next

If foundEmptyRows Then
   MsgBox "Deleted the followng " + eModProdName + " EMPTY rows or Almost EMPTY rows: " + vbLf + vbLf + _
           msg + vbLf + vbLf + _
          "Almost empty rows are " + eModProdName + " rows with NO Exchange and Product," + vbLf + _
          "and with NO data on the Volume Discount or the Band Discount Columns.", , title1 + " Cleanup"
End If


disableWorksheetSelectionChange = False

Call Module1.SelectFirstCell(True)

End Sub


Public Sub selectCopyInsertCurrentRow()

'--- button SCICR  - called via ribbon or NP

ModuleSheet.Activate

Dim col1 As String
col1 = "A"

Dim col2 As String
col2 = Module1.LastColumn '-- REGION IS MORE USED

Dim currCell As Range

Set currCell = ActiveCell
If currCell.Cells.Count <> 1 Then
   MsgBox "Use this option when you have ONE eModule cell SELECTED.", vbExclamation, title1
   Exit Sub
End If

Dim row As Long
row = currCell.row

Dim addr1 As String
addr1 = col1 + CStr(row) + ":" + col2 + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

ModuleSheet.Activate
rng1.Select
Selection.Copy
Selection.Insert Shift:=xlDown


Set rng1 = Nothing

Application.cutCopyMode = False
Application.DisplayAlerts = False


MsgBox "The row# " + CStr(row) + " has been copied just below.", , "Range copied: " + addr1

End Sub

Public Sub formOpenNavigationPanel()

If isUserFormLoaded(CP) Then
   frmControlPanel.hide
End If
If isUserFormLoaded(PQT) Then
   frmProdQueryTool.hide
End If

'--- avoid the use of pqt zoom
frmNavigationPanel.Zoom = 100
frmNavigationPanel.Show

End Sub


Public Sub formOpenControlPanel()

If isUserFormLoaded(PQT) Then
   frmProdQueryTool.hide
End If
If isUserFormLoaded(NP) Then
   frmNavigationPanel.hide
End If

'--- avoid the use of pqt zoom
frmControlPanel.Zoom = 100
frmControlPanel.Show

End Sub
Public Sub formOpenProductQueryTool()


If isUserFormLoaded(CP) Then
   frmControlPanel.hide
End If
If isUserFormLoaded(NP) Then
   frmNavigationPanel.hide
End If

Call openPQTform

End Sub

Public Sub openPQTform()

Const title = "PQT Zoom Option - Depends on Video Attributes"

Module1.eModShadeTurnedOn = False '-- turn shading off

Const defZoomValue = 95
Const minZoom = 70
Const maxZoom = 120
'---- CENTRALIZED PLACE TO CALL THE PQT ---
Dim defZoom As Integer

Dim pqtZoom As Integer
Dim pqtZoomstr As String

If Module1.userLastPQTzoom <> 0 Then
   '--- WE KNOW THE ZOOM - NO NEED TO PROMPT AGAIN
    pqtZoom = Module1.userLastPQTzoom
    '--- CLOSE CP
    If isUserFormLoaded(CP) Then
       frmControlPanel.hide
    End If
    '--- not the two forms at the same tiem
   
    frmProdQueryTool.Zoom = pqtZoom
    frmProdQueryTool.Show
    '-- must exit - when they exit pqt can not repeate stuff below
    Exit Sub
    
  Else
   defZoom = defZoomValue
End If


Dim zoomRange As String
zoomRange = CStr(minZoom) + "-" + CStr(maxZoom)

pqtZoomstr = InputBox("Please enter the PQT zoom percent (as integer) (" + zoomRange + "): ", title, defZoom)

If pqtZoomstr = vbNullString Then
   MsgBox "User canceled - exiting PQT." + vbLf + vbLf + _
          "Note: The zoom value needs to be determined by some experimentation." + vbLf + vbLf + _
          "Try with the default first of: " + CStr(defZoom) + vbLf + vbLf + _
          "If the PQT form is not fully visible - then reduce this value by 5 until all the form is visible." + vbLf + vbLf + _
          "If the PQT form is too small - then try increasing the current value by 5 until is acceptable." + vbLf + vbLf + _
          "If the range allowed of: " + zoomRange + " is not enought contact FIA Tech.", , title
   Exit Sub
End If

pqtZoomstr = Trim(pqtZoomstr)
If pqtZoomstr = "" Then
   pqtZoomstr = defZoom
End If

Dim pos As Integer
pos = InStr(1, pqtZoomstr, "%")

If pos > 0 Then
   pqtZoomstr = Mid(pqtZoomstr, 1, pos - 1)
End If


If Not IsNumeric(pqtZoomstr) Then
   MsgBox "Invalid value - please enter an integer value: " + zoomRange, , title
   Exit Sub
End If

pqtZoom = CLng(pqtZoomstr)

If pqtZoom < minZoom Or pqtZoom > maxZoom Then
   MsgBox "Invalid value - please enter an integer value: " + zoomRange, , title
   Exit Sub
End If

'Module1.disableWorksheetSelectionChange = True

'--- CLOSE CP
 If isUserFormLoaded(CP) Then
    frmControlPanel.hide
 End If '--- not the two forms at the same tiem

Module1.userLastPQTzoom = pqtZoom '-- store las used value as his default

frmProdQueryTool.Zoom = pqtZoom
frmProdQueryTool.Show


End Sub



Public Function eModHeadingsRangeAddr() As String

eModHeadingsRangeAddr = ""
Dim addr As String
addr = Module1.FirstColumn + "2:" + Module1.LastColumn + "2"
eModHeadingsRangeAddr = addr

End Function

Public Function eModRangeAddr() As String

eModRangeAddr = ""
Dim addr As String
Dim lastRow As Long
lastRow = Module1.getModuleLastRow
addr = Module1.FirstColumn + CStr(ModuleFirstRow) + ":" + Module1.LastColumn + CStr(lastRow)
eModRangeAddr = addr

End Function


Public Function cleanUpDate(dt As Date) As String

Dim dts As String
dts = CStr(dt)
Dim newDts As String

newDts = Replace(dts, ":", "-")
newDts = Replace(newDts, "/", "-")

cleanUpDate = newDts

End Function





Public Function eModuleLineIsEmpty(row As Integer) As Boolean

 eModuleLineIsEmpty = True

Dim Rng As Range
Dim cel As Range

Set Rng = ModuleSheet.Range("A" + CStr(row) + ":" + Module1.LastSheetColumn + CStr(row))

For Each cel In Rng

    If Trim(cel.Value) > "" Then
       eModuleLineIsEmpty = False
       Exit Function
    End If
    
Next


End Function

Public Function getModuleLastRow() As Long

'--- EMOD 3.5 - COMPUTE THE LAST ROW VIA SEVERAL NEW & OLD COLUMN TYPES

'--- LOGIC: THE ITEMS LIKE VOL DISC OR BAND RATE CAN RESULT IN ALL COLUMNS BEING EMPTY EXCEPT THESE RESPECTIVE COLUMNS
'--- THUS IF BY CHANCE ONE OF THESE IS THE LAST ITEM - WE NEED TO COUNT THESE AMOUNTS - VOL DISC OR BAND DISC
'--- ALL OTHER COLUMNS CAN ONLY HAVE 1 ROW.


disableWorksheetSelectionChange = True

getModuleLastRow = 0
'@@@@ MAY NEED REVISION FOR 3.5 - WHAT ABOUT IF BANDS ARE AT THE END??? - 6/16/15 - reg

If RegionColumn = "" Then
   Call Module1.loadColumnVariables
End If

Dim maxEmodRows As String

maxEmodRows = CStr(Module1.ModuleMaxRows + 1)

Dim rngRC_LSR As Range
Set rngRC_LSR = ModuleSheet.Range(RegionColumn & maxEmodRows)

Dim rngEXC_LSR As Range
Set rngEXC_LSR = ModuleSheet.Range(ExchangeColumn & maxEmodRows)

Dim rngPGP_LSR As Range
Set rngPGP_LSR = ModuleSheet.Range(ProductGroupCodeColumn & maxEmodRows)

Dim rngPC_LSR As Range
Set rngPC_LSR = ModuleSheet.Range(ProductColumn & maxEmodRows)

Dim rngRTC_LSR As Range
Set rngRTC_LSR = ModuleSheet.Range(RateTypeColumn & maxEmodRows)

Dim rngAC_LSR As Range
Set rngAC_LSR = ModuleSheet.Range(AmountColumn & maxEmodRows)

Dim rngTC_LSR As Range
Set rngTC_LSR = ModuleSheet.Range(TierVolDiscRateColumn & maxEmodRows)

Dim rngBC_LSR As Range
Set rngBC_LSR = ModuleSheet.Range(BandRateColumn & maxEmodRows)

Dim rngTT_LSR As Range
Set rngTT_LSR = ModuleSheet.Range(Module1.TiersColumn & maxEmodRows)

Dim rngBT_LSR As Range
Set rngBT_LSR = ModuleSheet.Range(Module1.BandTierNoColumn & maxEmodRows)


Dim regionCount As Long
Dim exchangeCount As Long
Dim productGrpCount As Long
Dim productCount As Long
Dim rateTypeCount As Long '-- added per Andrew 8/3/15
Dim amountCount As Long
'--- reg - 2/19/16 - added check of vol disc and band tiers in case of incomplete last rows
Dim tierRateCount As Long
Dim bandRateCount As Long
Dim tierNumberCount As Long
Dim bandNumberCount As Long

'--- note count is not a correct name - these are row numbers

 regionCount = rngRC_LSR.End(xlUp).row
 
 '--- 3/13/16-added exch and prod group - copy/paste may added these indep
 exchangeCount = rngEXC_LSR.End(xlUp).row
 productGrpCount = rngPGP_LSR.End(xlUp).row
  
 productCount = rngPC_LSR.End(xlUp).row
 rateTypeCount = rngRTC_LSR.End(xlUp).row
 amountCount = rngAC_LSR.End(xlUp).row
 tierRateCount = rngTC_LSR.End(xlUp).row
 bandRateCount = rngBC_LSR.End(xlUp).row
 tierNumberCount = rngTT_LSR.End(xlUp).row
 bandNumberCount = rngBT_LSR.End(xlUp).row

 '-- store as global vars
 ModuleLastRowRegion = regionCount
 ModuleLastRowExchange = productCount
 ModuleLastRowProductGrp = productCount
 ModuleLastRowProductCount = productCount
 ModuleLastRateTypeCount = rateTypeCount
 ModuleLastRowAmountCount = amountCount
 ModuleLastRowTierRateCount = tierRateCount
 ModuleLastRowBandRateCount = bandRateCount
 ModuleLastRowTierNumberCount = tierNumberCount
 ModuleLastRowBandNumberCount = bandNumberCount


Dim tmp As Long

'--- can not be below row 4

getModuleLastRow = Application.Max(4, regionCount, exchangeCount, productGrpCount, productCount, rateTypeCount, amountCount, tierRateCount, bandRateCount, tierNumberCount, bandNumberCount)
'
'--- this deletes the unused portion of the sheet and restes the used range and scroll down bar
disableWorksheetSelectionChange = False

'Call Module1.SelectFirstCell(False)

'--- verified - reg - 10/26/16

End Function


Public Function getCurrentRateType(rngCel As Range) As String '-- we pass the current activecell

'--- reg - added 2/23/14 - improved band/vol disc

getCurrentRateType = ""

If rngCel.Cells.Count > 1 Then
   Exit Function
End If

Dim currCel As Range, currRow As Long
Dim tmpVal As String
Dim row1 As Long
row1 = rngCel.row

Dim addr1 As String
addr1 = Module1.RateTypeColumn + CStr(row1) '--addr of curr row rate type

Dim currRowRateRng As Range
Set currRowRateRng = Range(addr1)
Dim currRowRate As String
currRowRate = Trim(currRowRateRng.Value)

'-- if there is a rate type we are done
If currRowRate <> "" Then
   getCurrentRateType = currRowRate
   Exit Function
End If

'-- the rate col is blank - then we have vol disc or band - go up the rate col until find rate
'
Dim rws As Integer
rws = 0
tmpVal = ""
currRow = row1

Do While (tmpVal = "" And currRow >= 4)
   rws = rws - 1
   Set currCel = currRowRateRng.Offset(rws, 0) '-- go up one in the rate type col from start pos (current row)
   currRow = currCel.row
   tmpVal = Trim(currCel.Value)
Loop

'-- the 1st non empty rate is the desired one

getCurrentRateType = tmpVal


End Function


Public Function getCurrentBandRateType(rngCel As Range) As String '-- we pass the current activecell

'--- reg - added 2/23/14 - improved band/vol disc

getCurrentBandRateType = ""

If rngCel.Cells.Count > 1 Then
   Exit Function
End If

Dim currCel As Range, currRow As Long
Dim tmpVal As String
Dim row1 As Long
row1 = rngCel.row

Dim addr1 As String
addr1 = Module1.BandValueTypeColumn + CStr(row1) '--addr of curr row BAND rate type - BPS ETC

Dim currRowRateRng As Range
Set currRowRateRng = Range(addr1)
Dim currRowRate As String
currRowRate = Trim(currRowRateRng.Value)

'-- if there is a rate type we are done
If currRowRate <> "" Then
   getCurrentBandRateType = currRowRate
   Exit Function
End If

'-- the rate col is blank - then we have vol disc or band - go up the rate col until find rate
'
Dim rws As Integer
rws = 0
tmpVal = ""
currRow = row1

Do While (tmpVal = "" And currRow >= 4)
   rws = rws - 1
   Set currCel = currRowRateRng.Offset(rws, 0) '-- go up one in the rate type col from start pos (current row)
   currRow = currCel.row
   tmpVal = Trim(currCel.Value)
Loop

'-- the 1st non empty BAND rate TYPE is the desired one

getCurrentBandRateType = tmpVal


End Function






Public Sub eModResetEOF()

'--- EMOD 3.5 - ISSUE - SOME ACTIONS OF VALIDATION MADE THE END OF FILE VERY LARGE AND THE SCROLL BAR BECAME TOO SMALL/FAST
'--- HERE WE DELETE ALL ROWS AFTER THE LAST ROW IN THE EMOD AND THAT RESETS THE EOF AND THE SCROOL BAR GETS NORMAL
Application.ScreenUpdating = False

Dim addr As String
addr = "A" + CStr(getModuleLastRow() + 1)
Range(addr).Select
Range(Selection, Selection.End(xlDown)).Select
Selection.EntireRow.Delete

Application.ScreenUpdating = True

'Call Module1.SelectFirstCell - confuses user

End Sub




Public Sub AddValidationComment(ColumnName As String, RowNumber As Long, message As String)

Dim columnTitle As String

Dim rngCR As Range
Set rngCR = Range(ColumnName & RowNumber)

If EnableComments = True Then
    
    If (rngCR.Comment Is Nothing) Then
        rngCR.AddComment message
    ElseIf InStr(rngCR.Comment.Text, message) = 0 Then
        rngCR.Comment.Text Text:=rngCR.Comment.Text & vbLf & message
    End If
    
    rngCR.Comment.Shape.Width = cellCommentsWidth '--new let autisize the comment - reg - 3/21/16
    rngCR.Comment.Shape.Height = cellCommentsWidth / 3
End If

If EnableErrorLog = False Then Exit Sub

Dim rng1 As Range
Dim rng2 As Range
Dim rng3 As Range
Dim rng4 As Range
Dim rng5 As Range

Set rng1 = ModuleSheet.Range(ColumnName & HeaderRowOffset)
Set rng2 = ErrorLog.Range(ErrorLogTimeStampColumn & ErrorLogRowCounter)
Set rng3 = ErrorLog.Range(ErrorLogRowNumberColumn & ErrorLogRowCounter)
Set rng4 = ErrorLog.Range(ErrorLogColumnNameColumn & ErrorLogRowCounter)
Set rng5 = ErrorLog.Range(ErrorLogMessageColumn & ErrorLogRowCounter)

columnTitle = rng1.Value

rng2 = Now()
rng3 = "Row " & RowNumber
rng4 = "Column " & ColumnName & " - " & columnTitle
rng5 = message

ErrorLogRowCounter = ErrorLogRowCounter + 1

Set rng5 = Nothing
Set rng4 = Nothing
Set rng3 = Nothing
Set rng2 = Nothing
Set rng1 = Nothing

End Sub

Public Sub WriteToErrorLog(ColumnName As String, RowNumber As Long, message As String)

Dim columnTitle As String

If EnableErrorLog = False Then Exit Sub

columnTitle = ModuleSheet.Range(ColumnName & HeaderRowOffset).Value

ErrorLog.Range(ErrorLogTimeStampColumn & ErrorLogRowCounter) = Now()
ErrorLog.Range(ErrorLogRowNumberColumn & ErrorLogRowCounter) = "Row " & RowNumber
ErrorLog.Range(ErrorLogColumnNameColumn & ErrorLogRowCounter) = "Column " & ColumnName & " - " & columnTitle
ErrorLog.Range(ErrorLogMessageColumn & ErrorLogRowCounter) = message

ErrorLogRowCounter = ErrorLogRowCounter + 1
 
End Sub

Public Function CheckForSheet(SheetToCheck As String) As Boolean

Dim SheetName As Worksheet
Dim SheetExists As Boolean

SheetExists = False

For Each SheetName In eModule.Sheets

    If SheetName.CodeName = SheetToCheck Then

        SheetExists = True
        Exit For

    End If

Next SheetName

If SheetExists Then

    CheckForSheet = SheetExists
    
Else

    MsgBox "Sheet " & SheetToCheck & " Does Not Exist - Closing", vbCritical, title2
    SheetMissing = True
    eModule.Close

End If

End Function

Public Function CheckNumberOfColumns(SheetToCheck As String, NumberOfColumns As Long, RowToCheck As Long) As Boolean

Dim LastColumn As Long
Dim SheetName As Worksheet
Dim SheetTabName As String

'SheetTabName = eModule.VBProject.VBComponents(SheetToCheck).Properties("Name").Value

For Each SheetName In eModule.Sheets

    If SheetName.CodeName = SheetToCheck Then
    
        SheetTabName = SheetName.name

        Exit For

    End If

Next SheetName

LastColumn = Sheets(SheetTabName).Range(LastSheetColumn & RowToCheck).End(xlToLeft).Column

If LastColumn = NumberOfColumns Then

    CheckNumberOfColumns = True

Else

    MsgBox "Sheet " & SheetToCheck & " - Number of Columns: " & LastColumn & " Incorrect - Closing", vbCritical, title2
    SheetMissing = True
    eModule.Close

End If
    
End Function

Public Sub ProtectSheet(SheetToProtect)

SheetToProtect.Protect Password:=PW, DrawingObjects:=False, _
                                     AllowFormattingCells:=True, _
                                     AllowInsertingRows:=True, _
                                     AllowDeletingRows:=True

End Sub

Public Sub SetInvalidCell(ColumnName As String, RowNumber As Long)

    Dim rngCR As Range
    Set rngCR = Range(ColumnName & RowNumber)

    rngCR.Interior.ColorIndex = InvalidColorIndexValue
    rngCR.Interior.Pattern = InvalidPatternValue
    rngCR.Interior.PatternColorIndex = InvalidPatternColorIndexValue
    
    Set rngCR = Nothing

End Sub

Public Function CheckNumberOfRows(SheetToCheck As String, NumberOfRows As Long, ColumnToCheck As String) As Boolean

Dim lastRow As Long
Dim SheetName As Worksheet
Dim SheetTabName As String

'SheetTabName = eModule.VBProject.VBComponents(SheetToCheck).Properties("Name").Value

For Each SheetName In eModule.Sheets

    If SheetName.CodeName = SheetToCheck Then
    
        SheetTabName = SheetName.name

        Exit For

    End If

Next SheetName

lastRow = Sheets(SheetTabName).Range(ColumnToCheck & LastSheetRow).End(xlUp).row

If lastRow > NumberOfRows Then

    CheckNumberOfRows = True

Else

    'MsgBox "Sheet " & SheetToCheck & " - Number of Rows: " & LastRow & " No Data - Exiting Sub", vbCritical, title2

    NoDataRows = True

End If
    
End Function

Public Sub clearAllFormats(msg As Boolean)

 Call Module1.clearModFormattingComments(msg)
  
 Cells.FormatConditions.Delete '--cond formats
  
 Call Module1.clearErrorLog
 
 Call Module1.formatNumericColumns
    
 Call Module1.deleteAndReportAlmostEmptyRows
 
 Module1.eModShadeTurnedOn = False '-- turn shading off
 
 Application.Cursor = xlNormal
 
 Application.StatusBar = ""
 
 Call Module1.SelectFirstCell(True) ' -
 
End Sub

Public Sub clearAllFormattingComments()
   
  Call Module1.clearAllFormats(True)
   
End Sub


Public Sub clearModFormattingComments(msg As Boolean)

'--- remove validation stuff

Application.ScreenUpdating = False

ModuleSheet.Activate

Dim ModuleLastRow As Long

ModuleLastRow = Module1.getModuleLastRow '--- emod 3.5 - 6/16/15 - reg
 
'If ModuleLastRow < ModuleFirstRow Then

 '   If msg Then
  '     MsgBox "Nothing to Select", vbCritical, title1
   ' End If
    
If (ModuleLastRow >= Module1.ModuleFirstRow) Then

    Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleLastRow + 1000).Select
    Selection.ClearFormats
    Selection.ClearComments
    
    If msg Then
       MsgBox "All formats and validation comments are being cleared.", , Module1.title1
    End If
End If

Call Module1.SelectFirstCell(False)

Application.ScreenUpdating = True

End Sub



'==============================
'========== COMBO BOX FUNCTIONS
'==============================

Public Sub LoadcBoxCollection()
'--- reg - mod 3.5 new idea- store all the cbox on startup - they are fixed

Dim ix As Integer
Dim OleObj As OLEObject
'Dim cBoxCollectionNames2(30) As String
For Each OleObj In ActiveSheet.OLEObjects
    ix = ix + 1
    If (OleObj.progID = cBoxType) Then  '--- reg - emod 3.5 wip
       cBoxCollection.Add OleObj
       cBoxCollectionNames(ix) = OleObj.name
       
       
      ' cBoxCollectionNames2(ix) = CStr(OleObj.BottomRightCell.Column)
    End If
    
Next OleObj

End Sub


Public Sub HideComboBoxesFast()
  '--- NEW FAST HIDE CBOXES - REG - EMOD 3.5 - DEPENDS ON  Module1.LoadcBoxCollection DONE ON WORKBOO OPEN TO LOAD ALL CBOXES ONCE

  Dim OleObj As OLEObject

  For Each OleObj In cBoxCollection
 
           OleObj.Visible = False
  Next
        

End Sub


Public Sub HideComboBoxes()

Dim OleObj As OLEObject

For Each OleObj In ActiveSheet.OLEObjects

    If (OleObj.progID = cBoxType) And (OleObj.Visible = True) Then '--- reg - only do if IS visible
        
        OleObj.Visible = False
   
    End If
        
Next OleObj

End Sub


Public Sub FormatComboBox(ComboBoxName As String, ComboBoxColumn As String)

Application.ScreenUpdating = False

'--- updated 3/8/16 - reg - the 20 long cbox causes problems when it did not fit and went sideways
'--- now we compute the size of the vsible screen in rows and give it the rows that fit below up to 4 rows
'--- then we use the new default of 10 (was 20) items max per cbox

On Error Resume Next

Dim optimalRows As Long
optimalRows = Module1.cboxesUserDefListRowsDefault

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

Dim cboTempStaticData As ComboBox

Set cboTempStaticData = ModuleSheet.OLEObjects(ComboBoxName).Object

Dim addrCBC_MFRow As String
addrCBC_MFRow = ComboBoxColumn & ModuleFirstRow '--- reg - store common values, such as font
Dim rngModSht As Range
Set rngModSht = ModuleSheet.Range(addrCBC_MFRow)
 

With cboTempStaticData
        
    If (Trim(.Text) = "" Or IsEmpty(.Text) Or _
       Trim(.Value) = "" Or IsEmpty(.Value)) And _
       (Trim(ActiveCell.Value) = "") Then
    .Style = 2
    Else
    .Style = 0
    End If
    
    .Left = rngModSht.Left
    .Height = rngModSht.Height + ComboBoxHeightAdjustment
    .Width = rngModSht.Width + ComboBoxWidthAdjustment
    
    .Font.Size = rngModSht.Font.Size
    .Font.name = rngModSht.Font.name

    .ForeColor = RGB(ComboBoxForeColorRedValue, ComboBoxForeColorGreenValue, ComboBoxForeColorBlueValue)
    .backColor = RGB(ComboBoxBackgColorRedValue, ComboBoxBackgColorGreenValue, ComboBoxBackgColorBlueValue)
    
     optimalRows = Module1.getOptimalCboxRows()
     If optimalRows < 4 Then
        optimalRows = Module1.cboxesUserDefListRowsDefault '--- REG - NEW DEFAULT OF 10 PER CBOX
     End If
     
    .ListRows = optimalRows

End With

'If Module1.debugStatus And (ComboBoxColumn = "B" Or ComboBoxColumn = "C" Or ComboBoxColumn = "D" Or ComboBoxColumn = "E") Then

'MsgBox "FormatComboBox: Name=" + ComboBoxName + ", Colm: " + CStr(ComboBoxColumn) + ", Style = " + CStr(cboTempStaticData.Style) + vbLf + vbLf + _
 '      "Text:  " + CStr(cboTempStaticData.Text) + vbLf + vbLf + _
  '     "Value: " + CStr(cboTempStaticData.Text), , ComboBoxName

'End If

Set rngModSht = Nothing
Set cboTempStaticData = Nothing

Application.ScreenUpdating = True

End Sub



Public Function eModNewLine(rw As Long, startColLetter As String) As Boolean
'-- THIS FUNCTION CHECK THE ENTIRE EMOD LINE FOR EMPTY FOR PASSED ROW - RW AND ALL EMOD CELLS AFTER IT - TO AZ

eModNewLine = False
ModuleSheet.Activate

Dim addr As String
Dim cel As Range
Dim rngRow As Range

If rw < 4 Then
   Exit Function
End If
 
addr = startColLetter + CStr(rw) + ":AZ" + CStr(rw) '-- DONT DEPEND ON VARS

Set rngRow = ModuleSheet.Range(addr)

For Each cel In rngRow
    If Trim(cel.Value) <> "" Then
       eModNewLine = False '--ONE CELL WITH DATA WE RETURN FALSE
       Exit Function
    End If
Next

eModNewLine = True

Set rngRow = Nothing
Set cel = Nothing

End Function

Public Sub ActivateComboBox()

Dim OleObj As OLEObject
     
For Each OleObj In ActiveSheet.OLEObjects '--- reg - combined if's

    If (OleObj.progID = cBoxType) And (OleObj.Visible = True) Then
        
            OleObj.Activate
            
            Exit For
       
    End If
        
Next OleObj

End Sub


'Public Sub currencyCboSelectStaticDataColumn(SelectedRow As Range)
'
'Call HideComboBoxesFast
'
'If Selection.Count > 1 Then
'   Exit Sub
'End If
'
'Const ComboBoxName = "cboCurrency"
'
'Dim cboTempStaticData As ComboBox
'Set cboTempStaticData = ModuleSheet.OLEObjects(ComboBoxName).Object
'
'Dim isSameRow As Boolean
'Dim cellCurr As String
'Dim cellRow As Long
'
'cellRow = SelectedRow.row
'
'If cboTempStaticData <> "" Then
'   cellCurr = cboTempStaticData
'  Else
'   cellCurr = SelectedRow.Value
'End If
'
'cboTempStaticData.Style = 0
'
'If Module1.currentCurrencyRow <> cellRow Then
'   cboTempStaticData.Text = cboTempStaticData
'End If
'
'
'If (cellCurr <> "") And (cboTempStaticData.Text <> "") Then
'
'       '-- user has selected a new currency
'
'        ActiveCell.Value = cboTempStaticData.Text   '-- the def currency is already in the cell
'
'ElseIf (ActiveCell.Value <> "") Then
'        '--- load the current currency into the cbox
'        cboTempStaticData.Style = 0
'        cboTempStaticData.Text = ActiveCell.Value
'
'End If
'
'
'
'Dim rngCBox_SRow As Range
'Set rngCBox_SRow = ModuleSheet.Range(CurrencyColumn & SelectedRow.row)
'
'StaticDataComboBoxRow = SelectedRow.row
'
'With cboTempStaticData
'
'    .Top = rngCBox_SRow.Top
'    .Style = 0
'    Call currencyCboFormatComboBox
'
'    '.LinkedCell = rngCBox_SRow.Address
'    '.Value = rngCBox_SRow.Value
'    .Visible = True
'
'End With
'
'
'Set rngCBox_SRow = Nothing
'Set cboTempStaticData = Nothing
'
'End Sub
'
'Public Sub currencyCboFormatComboBox()
'
'Const ComboBoxName = "cboCurrency"
'Dim cboCurr As ComboBox
'
'Set cboCurr = ModuleSheet.OLEObjects(ComboBoxName).Object
'
'Dim addrCBC_MFRow As String
'addrCBC_MFRow = CurrencyColumn & ModuleFirstRow '--- reg - store common values, such as font
'Dim rngModSht As Range
'Set rngModSht = ModuleSheet.Range(addrCBC_MFRow)
'
'
'
'With cboCurr
'
'    If Trim(cboCurr.Text) = "" Then
'    '-- NOTE: WE NEED TO SET .STYLE TO 0 IF WE ARE SETTING THIS TO SOME VALUE IN THE CODE
'    .Style = 2
'    Else
'    .Style = 0
'    End If
'
'    .Left = rngModSht.Left
'    .Height = rngModSht.Height + ComboBoxHeightAdjustment
'    .Width = rngModSht.Width + ComboBoxWidthAdjustment
'    .Font.Size = rngModSht.Font.Size
'    .Font.name = rngModSht.Font.name
'
'    .ForeColor = RGB(ComboBoxForeColorRedValue, ComboBoxForeColorGreenValue, ComboBoxForeColorBlueValue)
'    .backColor = RGB(ComboBoxBackgColorRedValue, ComboBoxBackgColorGreenValue, ComboBoxBackgColorBlueValue)
'
'
'    .ListRows = Module1.cboxesUserDefListRowsDefault '--- REG - NEW DEFAULT OF 20 PER CBOX
'
'End With
'
'Set rngModSht = Nothing
'Set cboCurr = Nothing
'
'End Sub
'
'Public Sub currencyCboStaticDataComboBox_Change() ', ComboBoxHeight As Long, ComboBoxWidth As Long)
'
''MsgBox "In StaticDataComboBox_Change"
'Const ComboBoxName = "cboCurrency"
'Dim cboCurr As ComboBox
'
'Set cboCurr = ModuleSheet.OLEObjects(ComboBoxName).Object
'
'If ComboBoxChange = False Then Exit Sub
'
'Dim cboTempStaticData As ComboBox
'
'Set cboTempStaticData = ModuleSheet.OLEObjects(ComboBoxName).Object
'
'Dim isSameRow As Boolean
'Dim cellCurr As String
'
'cellCurr = ActiveCell.Value
'Module1.currentCurrencyRow = ActiveCell.row
'
'If (Not workbookOpenIsRunning) And (Module1.currentCurrencyRow <> 0) Then
'
'    If (Module1.currentCurrencyRow = ActiveCell.row) Then
'        isSameRow = True
'       Else
'        isSameRow = False
'     End If
'
'     If isSameRow And (cellCurr <> "") And (cboTempStaticData.Text <> "") And (cboTempStaticData.Text <> cellCurr) Then
'
'       '-- user has selected a new currency
'
'        cboTempStaticData.Style = 0
'
'        ActiveCell.Value = cboTempStaticData.Text   '-- the def currency is already in the cell
'
'    End If
'
'
'    If (Not isSameRow) Then
'       cboTempStaticData.Style = 0
'       cboTempStaticData.Text = "" '-- the def currency is already in the cell
'     '--- clear previous curr val if used changed row
'    End If
'
'End If
'
'
'    'Call currencyCboFormatComboBox'---
'
'
'    Call HideComboBoxesFast
'
'Set cboTempStaticData = Nothing
'
'End Sub
'



Public Sub FillStaticDataComboBox(ComboBoxName As String, StaticDataComboBoxColumn As String, ComboBoxColumn As String) ', ComboBoxHeight As Long, ComboBoxWidth As Long)

Application.ScreenUpdating = False

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If
   

Dim cboCurr As ComboBox

Set cboCurr = ModuleSheet.OLEObjects(ComboBoxName).Object

With cboCurr

       .ListFillRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                     & ":$" & StaticDataComboBoxColumn & "$" & _
                     StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row).Address(External:=True)
    
    Call FormatComboBox(ComboBoxName, ComboBoxColumn)
    
    .Visible = False
   
End With

Set cboCurr = Nothing

Application.ScreenUpdating = True

End Sub

Public Sub SelectStaticDataColumn(SelectedRow As Range, ComboBoxName As String, ComboBoxColumn As String) ', ComboBoxHeight As Long, ComboBoxWidth As Long)
'MsgBox "test SelectStaticDataColumn"

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

If ComboBoxName = "cboCurrency" Then
'   Exit Sub
End If

Dim cboTempStaticData As ComboBox

Call HideComboBoxesFast

Dim rngCBox_SRow As Range
Set rngCBox_SRow = ModuleSheet.Range(ComboBoxColumn & SelectedRow.row)

Set cboTempStaticData = ModuleSheet.OLEObjects(ComboBoxName).Object
        

        
        
        StaticDataComboBoxRow = SelectedRow.row
        
        With cboTempStaticData
    
            .Top = rngCBox_SRow.Top
            
            Call FormatComboBox(ComboBoxName, ComboBoxColumn)
                     
            .LinkedCell = rngCBox_SRow.Address
            .Value = rngCBox_SRow.Value
            .Visible = True

        End With
  
 
Set rngCBox_SRow = Nothing
Set cboTempStaticData = Nothing

End Sub
Public Sub StaticDataComboBox_Change(ComboBoxName As String, ComboBoxColumn As String) ', ComboBoxHeight As Long, ComboBoxWidth As Long)

'MsgBox "In StaticDataComboBox_Change"

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

If ComboBoxName = "cboCurrency" Then
  ' Exit Sub
End If

If ComboBoxChange = False Then Exit Sub

Dim cboTempStaticData As ComboBox

Set cboTempStaticData = ModuleSheet.OLEObjects(ComboBoxName).Object

    With cboTempStaticData
   
        Call FormatComboBox(ComboBoxName, ComboBoxColumn)
    
        
    End With
      
    Call HideComboBoxesFast
   
Set cboTempStaticData = Nothing

End Sub






'==============================
'================ RESET GLOBALS
'==============================


Public Sub SetLastRow()

    RegionLastRow = Region.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
    ExchangeLastRow = Exchange.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
    ProductGroupCodeLastRow = ProductGroupCode.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
    ProductLastRow = Product.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
    
    
    RegionArrayUBound = RegionLastRow - HeaderRowOffset
    ExchangeArrayUBound = ExchangeLastRow - HeaderRowOffset
    ProductGroupCodeArrayUBound = ProductGroupCodeLastRow - HeaderRowOffset
    ProductArrayUBound = ProductLastRow - HeaderRowOffset


End Sub


Public Sub BuildArrays()

Call SetLastRow
Dim I As Integer
Dim Istr As String


ReDim RegionArray(0 To RegionArrayUBound)

For I = 0 To RegionArrayUBound
    Istr = CStr(I) + CStr(HeaderRowOffset)
    RegionArray(I) = Region.Range("$" & RefDataRegionColumn & Istr).Value

Next I

ReDim ExchangeArray(0 To ExchangeArrayUBound, 1)

For I = 0 To ExchangeArrayUBound
    Istr = CStr(I) + CStr(HeaderRowOffset)
    ExchangeArray(I, 0) = Exchange.Range("$" & RefDataRegionColumn & Istr).Value
    ExchangeArray(I, 1) = Exchange.Range("$" & RefDataExchangeColumn & Istr).Value

Next I

ReDim ProductGroupCodeArray(0 To ProductGroupCodeArrayUBound, 2)

For I = 0 To ProductGroupCodeArrayUBound
    Istr = CStr(I) + CStr(HeaderRowOffset)
    ProductGroupCodeArray(I, 0) = ProductGroupCode.Range("$" & RefDataRegionColumn & Istr).Value
    ProductGroupCodeArray(I, 1) = ProductGroupCode.Range("$" & RefDataExchangeColumn & Istr).Value
    ProductGroupCodeArray(I, 2) = ProductGroupCode.Range("$" & RefDataProductGroupCodeColumn & Istr).Value

Next I

ReDim ProductArray(0 To ProductArrayUBound, 5)

For I = 0 To ProductArrayUBound

    Istr = CStr(I) + CStr(HeaderRowOffset)
    ProductArray(I, 0) = Product.Range("$" & RefDataRegionColumn & Istr).Value
    ProductArray(I, 1) = Product.Range("$" & RefDataExchangeColumn & Istr).Value
    ProductArray(I, 2) = Product.Range("$" & RefDataProductGroupCodeColumn & Istr).Value
    ProductArray(I, 3) = Product.Range("$" & RefDataProductColumn & Istr).Value
    ProductArray(I, 4) = Product.Range("$" & RefDataProductTypeColumn & Istr).Value
    ProductArray(I, 5) = Product.Range("$" & RefDataProductDefaultCurrencyColumn & Istr).Value '--- eMod 3.5 - default currency
    
Next I


End Sub

'================================
'============= CUT COPY AND PASTE
'================================


Sub ClearCutCopy() '-- for esc

    'ModuleSheet.cmdSheetMode.Caption = "Normal"
        
    Application.cutCopyMode = False

End Sub

Sub PasteDisableEvents() '--not used - reg
    
    Application.EnableEvents = False

End Sub


'===========================================
'============= RIBBON CALLBACKS & SELECT ALL
'===========================================


Public Sub RunValidation(control As IRibbonControl)

    Call PerformValidation

End Sub
Public Sub RunSelectAll(control As IRibbonControl)

  Call SelectAll

End Sub

Public Sub SelectAll_Click()

Call SelectAll

End Sub

Public Sub SelectAll()

Dim ModuleLastRow As Long

ModuleLastRow = Module1.getModuleLastRow() '-- eMod 3.5 - reg - 6/16/15

If ModuleLastRow < ModuleFirstRow Then

    MsgBox "Nothing to Select", vbCritical, title1
    
Else

    'Range(FirstColumn & SheetTopRow, LastColumn & ModuleLastRow).Select
    Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleLastRow).Select

End If


End Sub

Public Sub SelectFirstCell(optional1 As Boolean)

'--- LOGIC: THIS WILL CALLED AT THE END OF MANY FUNCTIONS THAT CHANGE SOMETHING IN THE EMOD
'--- IF IT'S A REGION SELECT, OR IF THERE IS NO CELL SELECTED WE SELECT A4
'--- IF WE PASS PARM OF TRUE AND THERE IS A CELL SELECTED WE LEAV IT THERE, IF PASS FALSE THEN WE SELECT A4

disableWorksheetSelectionChange = False

Dim cel As Range
Set cel = Selection '--is there a cell/region selected?

If cel.Count > 1 Then '--region

   Range("A" + CStr(ModuleFirstRow)).Select

   Set cel = Nothing

   Exit Sub

End If



If optional1 Then
   
   If (cel Is Nothing) Then
   '--- no selection
   '--- reg - 3/10/16 - do only if no cell is selected
   
      Range("A" + CStr(ModuleFirstRow)).Select
      
      Set cel = Nothing
      
      Exit Sub
      
  Else
    
     '--- already have an active selected cell
  
     Set cel = Nothing
   
     Exit Sub
     
   End If
   
End If

'-- false for optional

Range("A" + CStr(ModuleFirstRow)).Select

Set cel = Nothing


End Sub

Public Sub SelectLastCell()

 Dim lastRow As Long
 lastRow = Module1.getModuleLastRow + 1
 Range(FirstColumn & CStr(lastRow), FirstColumn & CStr(lastRow)).Select

End Sub

'==============================
'================== POP UP MENU
'==============================



'Public Const Mname As String = "MyPopUpMenu"

'Sub DeletePopUpMenu()
'
'    On Error Resume Next
'    Application.CommandBars(EMoudlePopUpMenu).Delete
'    On Error GoTo 0
'
'End Sub
'
'Sub CreateDisplayPopUpMenu()
'
'    Call DeletePopUpMenu
'    Call CreatePopUpMenu
'
'    On Error Resume Next
'    Application.CommandBars(EMoudlePopUpMenu).ShowPopup
'    On Error GoTo 0
'
'End Sub


'==============================
'=========== HIDE/UNHIDE SHEETS
'==============================


Sub HideAllSheets()

Application.ScreenUpdating = False

Dim ws As Worksheet
 
 '--- reg - allow for debug status to show all wks
 
 For Each ws In ActiveWorkbook.Worksheets
 
    If (ws.name = Module1.ModuleSheetName Or ws.name = Module1.ErrorLogSheetCodeName) Then
        
        ws.Visible = xlSheetVisible
    Else
        ws.Visible = xlSheetVeryHidden '-- ### uncomment bef release
        'ws.Visible = xlSheetVisible
        
     End If
     
     '@@@ -MUST REMOVE ABOVE & UNCOMMENT BELOW BEFORE RELEASE 3.5 - REG
     'ws.Visible = xlSheetVeryHidden
 
  
Next ws

Application.ScreenUpdating = True

End Sub



Sub unHideAllSheets()

Dim ws As Worksheet

For Each ws In ActiveWorkbook.Worksheets
 
     ws.Visible = xlSheetVisible
     
Next ws

End Sub


'------------- MISC FUNCTIONS

Function getColumnNumber(ByVal sColLetter As String) As Long
' Convert column letter to numeric

    getColumnNumber = ActiveWorkbook.Worksheets(1).Columns(sColLetter).Column
End Function



Public Function getColumnLetter(addr As String) As String
    '-- input must be an excel cell address
    getColumnLetter = ""
    
    If Left(addr, 1) <> "$" Then
       Exit Function
    End If
    
    Dim pos1 As Integer
    pos1 = 0
    pos1 = InStr(2, addr, "$") '-- find 2nd $
    
    
    If pos1 = 0 Then
       Exit Function
    End If
    
    Dim len1 As Integer
    len1 = pos1 - 2 '-- minus $ x 2
    
    If len1 > 2 Then
       Exit Function
    End If
    
    getColumnLetter = Mid(addr, 2, len1)
    
    End Function

Public Function getColumnRow(addr As String) As String
    '-- input must be an excel cell address
    getColumnRow = ""
    
    If Left(addr, 1) <> "$" Then
       Exit Function
    End If
    
    Dim pos1 As Integer
    pos1 = 0
    pos1 = InStr(2, addr, "$") '-- find 2nd $
    
    
    If pos1 = 0 Then
       Exit Function
    End If
    
    getColumnRow = Mid(addr, pos1 + 1)
    
    End Function



Public Function ConvertToExcelColumnLetter(iCol As Integer) As String
'--- column num to letter

   Dim iAlpha As Integer
   Dim iRemainder As Integer
   iAlpha = Int(iCol / 27)
   iRemainder = iCol - (iAlpha * 26)
   If iAlpha > 0 Then
      ConvertToExcelColumnLetter = Chr(iAlpha + 64)
   End If
   If iRemainder > 0 Then
      ConvertToExcelColumnLetter = ConvertToExcelColumnLetter & Chr(iRemainder + 64)
   End If
   
End Function

Public Sub clearEmodEscapeCharacters(msgOn As Boolean)

    Dim CellToCheck As Range
    ModuleSheet.Activate
    
    ModuleLastRow = Module1.getModuleLastRow() '--?? ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row
    
    '*** 4/3/14
    Dim rngFCLC As Range
    Set rngFCLC = Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleLastRow)
    
    Dim ix As Long
    
    For Each CellToCheck In rngFCLC
        If Len(CellToCheck) = 0 Then
            ix = ix + 1
           CellToCheck.ClearContents
        End If
        
    Next
    
    
    '--- @@@@@@ REG - 6/10/15 - TESTING - DO WE NEED THIS - CLEAN EACH ROW AS IT'S USED INSTEAD?
  
    StaticData.Activate
    For Each CellToCheck In StaticData.usedRange
        If Len(CellToCheck) = 0 Then
           ix = ix + 1
           CellToCheck.ClearContents
        End If
        
    Next
    
    '-- return to emod
    ModuleSheet.Activate
    
    Set rngFCLC = Nothing
    Set CellToCheck = Nothing
      
    If msgOn Then
      
    MsgBox "Cleared: " + CStr(ix) + " empty cells." + vbLf + vbLf + _
           "This procedure removed any control characters" + vbLf + _
           "that may cause problems on EGUS uploads.", , Module1.title1
    End If

End Sub

Public Function LastSaveTime() As String
    Application.Volatile
    LastSaveTime = ThisWorkbook.BuiltinDocumentProperties("Last Save Time")
 End Function

 Public Function lastAuthor() As String
    Application.Volatile
    lastAuthor = ThisWorkbook.BuiltinDocumentProperties("Last Author")
 End Function

Public Sub deleteRowsForExecutionType(executionType As String)

executionType = Trim(executionType)

If (Len(executionType) <= 1) Then '-- disallow one  letter codes
   Exit Sub
End If

Dim lRow As Long
'FORMAT - MUST START FROM THE END TO AVOID DELETING ALL
'lRow = 100
'Do While lRow >= 1
'If Cells(lRow, 1) Mod 3 = 0 Then Rows(lRow).Delete
'lRow = lRow - 1
'Loop

'MsgBox "test - exec type del"

ModuleSheet.Activate

Application.ScreenUpdating = False

Dim rowDel As Integer
Dim dx As Integer

Dim lastRow As Long
lastRow = Module1.getModuleLastRow
Dim firstRow As Long
firstRow = Module1.ModuleFirstRow
Dim tmpData As String
Dim Rng As Range

'--- DELETE DOWN UP TO AVOID MESSING THE CURRENT CEL
'MsgBox "TEST"
lRow = lastRow

Do While lRow >= firstRow
    
    Set Rng = Cells(lRow, Module1.ExecutionTypeColumn)
    Rng.Select '-- SLOW BUT MAKES PROCESS VISIBLE
    
    tmpData = Cells(lRow, Module1.ExecutionTypeColumn)
    
    If (tmpData = executionType) Then
       '--- we are in a bad row
       dx = dx + 1
       rowDel = lRow
       Rows(rowDel).Delete
       DoEvents
    End If
    
    '--- reduce in either case
    lRow = lRow - 1

Loop

Set Rng = Nothing


Application.ScreenUpdating = True

MsgBox "Rows deletion finished." + vbLf + vbLf + _
       "Deleted: " + CStr(dx) + " rows." + vbLf + vbLf + _
       "Deletion Condition - values on column: " + ExecutionTypeColumn + "  Of:  " + executionType, , title1


End Sub

Public Sub copyInsertRowsForExecutionType(executionType1 As String, executionType2 As String, defaultYN As Integer, copyAmount As Integer) '-- OLD NEW (TO COPY TO) EXEC TYPE

executionType1 = Trim(executionType1)
executionType2 = Trim(executionType2)

If (Len(executionType1) <= 1) Then  '-- disallow one  letter codes
   Exit Sub
End If
If (Len(executionType2) <= 1) Then '-- disallow one  letter codes
   Exit Sub
End If

If (executionType1 = executionType2) Then  '-- disallow same exec
   MsgBox "Error - the copy/insert of new execution type has the same source execution type of: " + executionType2, vbCritical, title1
   Exit Sub
End If

Dim msgDefault As String
Dim msgAmount As String

If defaultYN = vbYes Then
   msgDefault = "SET Default Y/N to Y"
  Else
   msgDefault = "SET Default Y/N to N (blank)"
End If

If copyAmount = vbYes Then
   msgAmount = "COPY the Amount"
  Else
   msgAmount = "SET the Amount to blank (user must fill in)"
End If

ModuleSheet.Activate

Application.ScreenUpdating = False

Dim wks As Worksheet
Set wks = ActiveSheet

Dim addr1 As String '-- THE EXEC TYPE COLUMN
addr1 = Module1.ExecutionTypeColumn + CStr(ModuleFirstRow) + ":" + Module1.ExecutionTypeColumn + CStr(Module1.getModuleLastRow)

Dim Rng As Range
Set Rng = wks.Range(addr1)
Dim cel As Range
Dim ix As Integer

Dim lastRow As Long
lastRow = Module1.getModuleLastRow
Dim firstRow As Long
firstRow = Module1.ModuleFirstRow
Dim tmpData As String
Dim rng2 As Range
Dim addr2 As String
'--- DELETE DOWN UP TO AVOID MESSING THE CURRENT CEL
'MsgBox "TEST"

MsgBox "COPY PROCESSING:" + vbLf + vbLf + _
       "Copy Execution type: " + executionType1 + " To: " + executionType2 + vbLf + vbLf + _
       "Each COPIED ROW will be copied just BELOW the source row.", , title1

Application.ScreenUpdating = False
Application.EnableEvents = False '-- AVOID MESS COMBO CHECKS
Dim rngAC As Range

For Each cel In Rng
    
    
    tmpData = cel.Value
    
    If (tmpData = executionType1) Then
       '--- we are in a bad row
       ix = ix + 1
       
       addr2 = "A" + CStr(cel.row) + ":" + Module1.LastColumn + CStr(cel.row)
       Set rng2 = Range(addr2)
       rng2.Select
       
         
       Selection.Copy
       Selection.Insert Shift:=xlDown
       'ActiveCell.Offset(1).EntireRow.Insert blank row
       cel.Select
       Set rngAC = ActiveCell '-- the copied cell becomes active
       rngAC.FormulaR1C1 = executionType2  '-- fix the exec type
       
     
       '-- default y/n and amount options
       
       
       If (defaultYN = vbYes) Then
           rngAC.Offset(, 1) = "Y" '--column offsets
          Else
           rngAC.Offset(, 1) = " "
       End If
       
        If (copyAmount = vbNo) Then
           rngAC.Offset(, 2) = " " '--column offsets
           'else leave amt the same
        End If
       
     Set rngAC = Nothing
     Application.StatusBar = "Copy processing row# " + CStr(rng2.row)
     DoEvents
    
    End If
    
Next


Set Rng = Nothing
Set wks = Nothing
Set cel = Nothing


Application.EnableEvents = True
Application.ScreenUpdating = True

MsgBox "Copy/Insert by EXECUTION TYPE has finished -- inserted: " + CStr(ix) + " matching rows." + vbLf + vbLf + _
       "Condition: With values on column: " + executionType1 + " set to a value of:  " + executionType2 + vbLf + vbLf + _
        "Setting #1: " + msgDefault + vbLf + vbLf + _
        "Setting #2: " + msgAmount, , title1


End Sub


Sub Select_File_Or_Files_eModules()
'https://msdn.microsoft.com/en-us/library/office/hh710200(v=office.14).aspx#odc_xl4_ta_ProgrammaticallySelectFileforMac_IntroducingGetOpenFileNameMethod

    Dim SaveDriveDir As String
    Dim MyPath As String
    Dim Fname As Variant
    Dim N As Long
    Dim FnameInLoop As String
    Dim mybook As Workbook

    ' Save the current directory.
    SaveDriveDir = CurDir

    ' Set the path to the folder that you want to open.
    MyPath = Application.DefaultFilePath

    ' You can also use a fixed path.
    'MyPath = "C:\Users\Ron de Bruin\Test"

    ' Change drive/directory to MyPath.
    ChDrive MyPath
    ChDir MyPath

    ' Open GetOpenFilename with the file filters.
    Fname = Application.GetOpenFilename( _
            FileFilter:="Excel eModule Files (*.xlsm), *.xlsm", _
            title:="Select a eMoldule file or files", _
            MultiSelect:=True)

    ' Perform some action with the files you selected.
    If IsArray(Fname) Then
        
        With Application
            .ScreenUpdating = False
            .EnableEvents = False
        End With

        For N = LBound(Fname) To UBound(Fname)

            ' Get only the file name and test to see if it is open.
            FnameInLoop = Right(Fname(N), Len(Fname(N)) - InStrRev(Fname(N), Application.PathSeparator, , 1))
            
            If bIsBookOpen(FnameInLoop) = False Then

                Set mybook = Nothing
                
                On Error Resume Next
                Set mybook = Workbooks.Open(Fname(N))
                On Error GoTo 0

                If Not mybook Is Nothing Then
                    MsgBox "You opened this file : " & Fname(N) & vbNewLine & _
                           "And after you press OK, it will be closed" & vbNewLine & _
                           "without saving. "
                    mybook.Close SaveChanges:=False
                End If
            Else
                MsgBox "We skipped this file : " & Fname(N) & " because it is already open."
            End If
        Next N
        
        With Application
            .ScreenUpdating = True
            .EnableEvents = True
        End With
        
    End If

    ' Change drive/directory back to SaveDriveDir.
    ChDrive SaveDriveDir
    ChDir SaveDriveDir
End Sub


Function bIsBookOpen(ByRef szBookName As String) As Boolean
' Contributed by Rob Bovey
    On Error Resume Next
    bIsBookOpen = Not (Application.Workbooks(szBookName) Is Nothing)
    On Error GoTo 0
End Function




'Public Function getUserName() As String
'
'      getUserName = ""
'
'      Const NoError = 0
'      ' Buffer size for the return string.
'      Const lpnLength As Integer = 255
'
'      ' Get return buffer space.
'      Dim status As Integer
'
'      ' For getting user information.
'      Dim lpName, lpUserName As String
'
'      ' Assign the buffer size constant to lpUserName.
'      lpUserName = Space$(lpnLength + 1)
'
'      ' Get the log-on name of the person using product.
'      status = WNetGetUser(lpName, lpUserName, lpnLength)
'
'      ' See whether error occurred.
'      If status = NoError Then
'
'         lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
'
'      End If
'
'      getUserName = lpUserName
'
'      ' Display the name of the person logged on to the machine.
'      'MsgBox "The person logged on this machine is: " & lpUserName
'
'End Function

Public Function eModuleWithRateType(rateType As String) As Boolean

eModuleWithRateType = False

Dim Rng As Range
Dim cel As Range
Dim lastRow As Long
lastRow = Module1.getModuleLastRow
Dim tmpVal As String

Dim addr As String
addr = Module1.RateTypeColumn + CStr(ModuleFirstRow) + ":" + Module1.RateTypeColumn + CStr(lastRow)

Set Rng = ModuleSheet.Range(addr)

'-- rate column - passed value must be in Rate Type static data & dropdown
'Vol Disc
'Band Rate

For Each cel In Rng
    
    tmpVal = Trim(cel.Value)
    If UCase(tmpVal) = UCase(rateType) Then
       eModuleWithRateType = True
       Exit For
    End If
Next

Set Rng = Nothing
Set cel = Nothing

End Function



Public Sub sortEmoduleStandard()

'--- only works if there are no spaces after a row --> no tiers, bands etc

If eModuleWithRateType(BandingDiscountRateType) Or eModuleWithRateType(BandingDiscountRateType) Then
    MsgBox "Sorting does not work properly for eModules with Bands or Volume Discounts." + vbLf + vbLf + _
           "This is due to the empty cells on rows before the Bands or Discounts.", , title1
           Exit Sub
End If

Module1.sortOnFlag = True '-AVOID ROW2 ERROR

Dim lastRow As Long
lastRow = Module1.getModuleLastRow

Dim retVal As Integer
retVal = MsgBox("This STANDARD sort will sort the entire eModule in this order:" + vbLf + vbLf + _
                "1-REGION and EXCHANGE" + vbLf + _
                "2-PRODUCT GRP and NAME" + vbLf + _
                "3-Currency, Execution Type and amount last." + vbLf + vbLf + _
                "This sort will organize the eModule by region, exchange, product," + vbLf + _
                "currency, execution type and amount descending." + vbLf + vbLf + _
                "Please select OK to proceed, Cancel to stop the sorting.", , title1)

If retVal <> vbOK Then
   MsgBox "Standard sort cancelled.", , title1
   Exit Sub
End If

ActiveWorkbook.Save
MsgBox "The workbook has been SAVED previous to sorting.", , title1

If lastRow <= Module1.ModuleFirstRow Then
   MsgBox "No data to sort.", , title1
   Exit Sub
End If

Dim lsr As String
lsr = CStr(lastRow)
Dim sortRangeAddr As String
sortRangeAddr = "A4:" + Module1.AmountColumn + lsr


  ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Clear
  
    Range(sortRangeAddr).Select '--- macro:    Range("A2:M60").Select
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Clear
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("B3:B" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("C3:C" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("D3:D" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("E3:E" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("G3:G" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("K3:K" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("L3:L" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("M3:M" + lsr _
        ), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    With ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort
        .SetRange Range(sortRangeAddr)
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With
    
MsgBox "The eModule has been sorted from on Region to Amount - Range: " + sortRangeAddr, , title1
    
Module1.sortOnFlag = False

Call Module1.SelectFirstCell(False)
    
End Sub


Public Sub sortEmoduleCustom1()


If eModuleWithRateType("Band") Or eModuleWithRateType("Vol Disc") Then
    MsgBox "Sorting does not work properly for eModules with Bands or Volume Discounts." + vbLf + vbLf + _
           "This is due to the empty cells on rows before the Bands or Discounts.", , title1
           Exit Sub
End If

Module1.sortOnFlag = True

Dim lastRow As Long
lastRow = Module1.getModuleLastRow

Dim retVal As Integer
retVal = MsgBox("This CUSTOM sort will sort the entire eModule in this order:" + vbLf + vbLf + _
                "1-CURRENCY, 2-EXECUTION Types" + vbLf + _
                "2-REGION and EXCHANGE" + vbLf + _
                "3-Product TYPE, Product GROUP and Product NAME" + vbLf + _
                "4-Default Y/N for execution type" + vbLf + _
                "7-AMOUNT." + vbLf + vbLf + _
                "This custom sort is designed to verify Amount pricing by currency and execution." + vbLf + vbLf + _
                "Please select OK to proceed, Cancel to stop the sorting.", , title1)

If retVal <> vbOK Then
   MsgBox "Custom sort cancelled.", , title1
   Exit Sub
End If

ActiveWorkbook.Save
MsgBox "The workbook has been SAVED previous to sorting.", , title1

If lastRow <= Module1.ModuleFirstRow Then
   MsgBox "No data to sort.", , title1
   Exit Sub
End If

Dim lsr As String
lsr = CStr(lastRow)
Dim sortRangeAddr As String
sortRangeAddr = "A4:" + Module1.AmountColumn + lsr

 
  ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Clear
  
  Range(sortRangeAddr).Select
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("G3:G" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("K3:K" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("B3:B" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("C3:C" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("F3:F" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("D3:D" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("E3:E" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("L3:L" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort.SortFields.Add Key:=Range("M3:M" + lsr) _
        , SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    With ActiveWorkbook.Worksheets(Module1.ModuleSheetName).Sort
        .SetRange Range(sortRangeAddr)
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With

MsgBox "The eModule has been sorted by Currency, Execution, Product and Amount - Range: " + sortRangeAddr, , title1

Module1.sortOnFlag = False

Call Module1.SelectFirstCell(False)

End Sub

Function isUserFormLoaded(ByVal UFName As String) As Boolean
'-- THIS IS FOR THE EXCEL FORMS -  VBA.UserForms COLLECTION
    Dim UForm As Object
     
    isUserFormLoaded = False
    For Each UForm In VBA.UserForms
    
        If UCase(UForm.name) = UCase(UFName) Then
            isUserFormLoaded = True
            Exit For
        End If
    
    Next
End Function 'IsUserFormLoaded

Public Sub eModReset()

 Application.ScreenUpdating = False
 Module1.workbookOpenIsRunning = True
  
 '--- 3/1/16-usability - keep current sel cel
 
 disableWorksheetSelectionChange = True
 
 Set saveCurrCell1 = Selection
  
 ' MsgBox "WORKBOOK OPEN", , "TEST"
  Call eModule.WorkbookOpen1

 disableWorksheetSelectionChange = True
 On Error Resume Next
 saveCurrCell1.Select
 On Error GoTo 0
 Set saveCurrCell1 = Nothing
 
 disableWorksheetSelectionChange = False
  
 Module1.workbookOpenIsRunning = False
 Application.ScreenUpdating = True

End Sub

Public Sub eModInfo()

Dim numRows As String
Dim lastSave As String
Dim eModVer As String
Dim lastEmodColumn As String
Dim lastAuthor As String
Dim lastRow As String
Dim usedRange As String
Dim excelver As String
Dim userName As String

userName = (Environ$("Username"))

ModuleLastRow = Module1.getModuleLastRow()

Dim timeMinsElapsed As String
excelver = "The Version/Build of Excel is:  " + CStr(Application.Version) + "-" + CStr(Application.Build)

lastSave = "Last Save of eModule: " + CStr(Module1.LastSaveTime)
timeMinsElapsed = CStr(DateDiff("n", Module1.LastSaveTime, Now())) + " minutes ago."
lastSave = lastSave + " -- " + timeMinsElapsed

eModVer = "Version of eModule:   " + Module1.eModuleVersion
numRows = "Number of used Rows in eModule:   " + CStr(ModuleLastRow - ModuleFirstRow + 1)

If ModuleLastRow < 4 Then
   lastRow = "Last used excel row:  NONE"
  Else
    lastRow = "Last used excel row:   " + CStr(ModuleLastRow)
End If

lastEmodColumn = "Last Column of eModule:   " + LastColumn
lastAuthor = "Last author of spreadsheet:   " + Module1.lastAuthor
usedRange = "The Excel 'used range' is:   " + CStr(ModuleSheet.usedRange.Address)

Dim msg As String
msg = _
"1) The eModule reference data and variables have been reset." + vbLf + vbLf + _
"2) " + lastSave + vbLf + vbLf + _
"3) " + eModVer + vbLf + vbLf + _
"4) " + numRows + vbLf + vbLf + _
"5) " + lastRow + ",  User Name: " + userName + vbLf + vbLf + _
"6) " + lastEmodColumn + vbLf + vbLf + _
"7) " + lastAuthor + vbLf + vbLf + _
"8) " + usedRange + vbLf + vbLf + _
"9) " + excelver + vbLf + vbLf + _
"Empty rows cleanup: All Rows after the last in the eModule have " + vbLf + _
"been deleted - this helps when the scroll bar goes too fast."

MsgBox msg, , "eModule Info and Reset"


End Sub


Public Sub eBak()
'--- ThisWorkbook is the one that has the code
Application.EnableEvents = False

ActiveWorkbook.Save

MsgBox "Current workbook saved.", , "eBak"

Dim timeStamp As String
timeStamp = Module1.cleanUpDate(Now())

Dim name As String
name = ThisWorkbook.name
Dim path As String
path = ThisWorkbook.path + "\"
Dim fullName As String
fullName = path + name

Dim wkbSrc As Workbook
Set wkbSrc = ThisWorkbook

'Important to know this because SaveAs requires you to provide both the FileFormatparameter and the correct file extension.
Const xlsmFormat = 52
Const xlsm = "xlsm"
'--- THIS CODE MAY NEED ADJUSTMENT FOR VER OF EXCEL > 2010

Dim newName As String
newName = Mid(name, 1, Len(name) - 5) + " - BAK AT - " + timeStamp '-- remove '.xlsm'
Dim newFullName As String
newFullName = path + newName + "." + xlsm

Dim wkbDest As Workbook

wkbSrc.Save
wkbSrc.SaveAs newFullName, xlsmFormat

MsgBox "The backup process CLOSES the current excel file and the control panel  - you need to RELOAD the eModule file if needed." + vbLf + vbLf + _
       "The saved file is: " + vbLf + vbLf + _
       name + vbLf + vbLf + _
       "The saved file has been saved with the NEW name: " + vbLf + vbLf + _
       newName + "." + xlsm + vbLf + vbLf + _
       "The current PATH is: " + vbLf + vbLf + _
       path, , title1


'--- CLOSE THE SAVED BAK
Workbooks(newName).Activate
Set wkbDest = ActiveWorkbook
wkbDest.Close False

Application.EnableEvents = True

End Sub

Public Sub emodVersionAndReset()
Application.ScreenUpdating = False

ModuleSheet.Activate

Call Module1.eModReset

Module1.disableWorksheetSelectionChange = False '--- important to enable cboxes on emod
Application.EnableEvents = True

End Sub

Public Sub formatNumericColumns()


'-- needed because the clear formatting button removes all formats - also called from ribbon
'-- 3/3/16-UPDATE-REG-REMOVED BAND START/END SINCE THE FORMAT DEPENDS ON THE BAND TYPE

Application.ScreenUpdating = False
disableWorksheetSelectionChange = True
 
Dim ix As Integer
Dim Rng As Range
Dim cel As Range
Dim addr(1 To 9) As String
Dim lastRow As Long
lastRow = Module1.getModuleLastRow
Dim lastRowStr As String
lastRowStr = CStr(lastRow)

addr(1) = Module1.AmountColumn + CStr(ModuleFirstRow) + ":" + Module1.AmountColumn + lastRowStr
addr(2) = Module1.MMMinAmountColumn + CStr(ModuleFirstRow) + ":" + Module1.MMMinAmountColumn + lastRowStr
addr(3) = Module1.MMMaxAmountColumn + CStr(ModuleFirstRow) + ":" + Module1.MMMaxAmountColumn + lastRowStr
addr(4) = Module1.AddOnAmountColumn + CStr(ModuleFirstRow) + ":" + Module1.AddOnAmountColumn + lastRowStr
addr(5) = Module1.TierVolDiscRateColumn + CStr(ModuleFirstRow) + ":" + Module1.TierVolDiscRateColumn + lastRowStr
addr(6) = Module1.BandRateColumn + CStr(ModuleFirstRow) + ":" + Module1.BandRateColumn + lastRowStr

'--- 2/18/16 - do not format TierStartNumberAmountColumn as decimal

addr(7) = Module1.TierStartNumberAmountColumn + CStr(ModuleFirstRow) + ":" + Module1.TierStartNumberAmountColumn + lastRowStr
addr(8) = Module1.TiersColumn + CStr(ModuleFirstRow) + ":" + Module1.TiersColumn + lastRowStr
addr(9) = Module1.BandTierNoColumn + CStr(ModuleFirstRow) + ":" + Module1.BandTierNoColumn + lastRowStr

For ix = 1 To 6

    Set Rng = ModuleSheet.Range(addr(ix))
    Rng.NumberFormat = Module1.decimalFormat2
Next

For ix = 7 To 9

    Set Rng = ModuleSheet.Range(addr(ix)) '-- INTEGER COUNT VALUES
    Rng.NumberFormat = Module1.decimalFormat0 'General"
  
Next

Dim rateTypeAddr As String
rateTypeAddr = Module1.RateTypeColumn + CStr(ModuleFirstRow) + ":" + Module1.RateTypeColumn + lastRowStr
Dim rateTypeRng As Range
Dim tierRng As Range

Dim cel1 As Range
Dim cel2 As Range
Dim BandValueType_Current As String
Dim startRow As Integer
Const bandRateRelPos = 17
Dim tierAddr As String
Dim tierCount As Integer
Dim tierRow As Long


Set rateTypeRng = Range(rateTypeAddr)

For Each cel1 In rateTypeRng
'----------------------------

    If (cel1.Value = Module1.BandingDiscountRateType) Then

          BandValueType_Current = Trim(cel1.Offset(0, bandRateRelPos))
         
          If BandValueType_Current <> "" Then
            
            startRow = cel1.row
            tierCount = 0
            
            tierAddr = Module1.BandTierNoColumn + CStr(startRow) + ":" + Module1.BandTierNoColumn + "100" '-- assume up to 100 tiers
            Set tierRng = Range(tierAddr)
              
              For Each cel2 In tierRng
              '-------------------------
                   tierCount = tierCount + 1
                   tierRow = cel2.row
                                      
                  '--verify tier makes sense
                  If tierCount <> cel2.Value Then
                     'Ok- it's another tpe of row
                     'MsgBox "Error in numeric format for Band Start/End for Type: " + BandValueType_Current + " in start row# " + CStr(tierRow) + " Tier# " + CStr(cel2.Value)
                     Exit For
                  End If
                  
             If InStr(BandStartEndIntegerTypes, BandValueType_Current) > 0 Then '-- BPS, NUMN CONT'S
                  
                  If IsNumeric(cel2.Offset(0, 1)) Then
                     cel2.Offset(0, 1).NumberFormat = Module1.decimalFormat0
                  End If
                  If IsNumeric(cel1.Offset(0, 2)) Then
                     cel2.Offset(0, 2).NumberFormat = Module1.decimalFormat0
                  End If
                  
                 
                Else
                
                  If IsNumeric(cel2.Offset(0, 1)) Then
                     cel2.Offset(0, 1).NumberFormat = Module1.decimalFormat2
                  End If
                  If IsNumeric(cel2.Offset(0, 2)) Then
                     cel2.Offset(0, 2).NumberFormat = Module1.decimalFormat2
                  End If
                 
               End If
          
          Next
             
        End If '-- has rate type code
           
          

    End If
    

Next


Set rateTypeRng = Nothing
Set tierRng = Nothing
Set cel1 = Nothing
Set cel2 = Nothing


Application.StatusBar = "Numeric formatting completed."
disableWorksheetSelectionChange = False
Application.ScreenUpdating = True

Call Module1.SelectFirstCell(True)

End Sub

Public Sub loadColumnVariables()

'--- EMOD 3.5 NEW CODE - THIS CODE MUST RUN AS ONE OF THE FIRST BEFORE OTHER PROGRAMS - THEY ALL NEED THE COLUMN VARIABLES

'-------------- IMPORTANT - ANY CHANGES TO THE EMODULE MAIN TAB COLUMN HEADINS MUST BE REFLECTED IN THE SELECT CASE BELOW, WITH IDENTICAL SPELLING & CASE OF ROW 2
'-------------- ELIMINATED MAPPING SINCE WE DECIDED TO USE EGUS COMPATIBLE NAMES FOR COLUMN NAMES ON ROW 2 AND TOO MANY REPATE (SUCH AS RATE) MAKING THE CODE TOO COMPLEX FOR MAINT
  
'-------------- INSTRUCTIONS: PLACE ANY NEW FIELDS IN THE CORRECT ORDER AND THE COLUMNS NUMBER AND LETTER WILL BE CALCULATED CORRECTLY
  
'---  BELOW WE INCREASE THE COL NUMBER SEQUENTIALLY SINCE ALL COLUMNS ARE IN SEQUENCE - PLACE ANY NEW COLUMNS BELOW IN THE CORRECT POSITION (SAME AS EMODULE) SO ALL VALUES ARE COMPUTED CORRECTLY

'---  UPDATE FOR ANY NEW COL ADDED OR CHANGED IN RELATIVE POSITION, LAST COLUMN STORED AT END
  
'INITIAL VALUES:
Dim counter As Integer
counter = 0
  
 '--- COLUMN:  "Direct Bill"
        counter = counter + 1
        DirectBillColumn = Module1.ConvertToExcelColumnLetter(counter)
        DirectBillColumnNumber = counter
        eModuleColumnsNames(counter) = "Direct Bill"
               
 '--- COLUMN:  "Region"
        counter = counter + 1
        RegionColumn = Module1.ConvertToExcelColumnLetter(counter)
        RegionColumnNumber = counter
        eModuleColumnsNames(counter) = "Region"
        
 '--- COLUMN:  "Exchange Code
        counter = counter + 1
        ExchangeColumn = Module1.ConvertToExcelColumnLetter(counter)
        ExchangeColumnNumber = counter
        eModuleColumnsNames(counter) = "Exchange Code"
        
 '--- COLUMN:  "Product Group Name"
        counter = counter + 1
        ProductGroupCodeColumn = Module1.ConvertToExcelColumnLetter(counter)
        ProductGroupCodeColumnNumber = counter
        eModuleColumnsNames(counter) = "Product Group"
  
 '--- COLUMN:  "Product Name"
        counter = counter + 1
        ProductColumn = Module1.ConvertToExcelColumnLetter(counter)
        ProductColumnNumber = counter
        eModuleColumnsNames(counter) = "Product Name"
  
 '--- COLUMN:  "Product Type"
        counter = counter + 1
        ProductTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        ProductTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Product Type"
  
 '--- COLUMN:  "Currency"
        counter = counter + 1
        CurrencyColumn = Module1.ConvertToExcelColumnLetter(counter)
        CurrencyColumnNumber = counter
        eModuleColumnsNames(counter) = "Currency"
  
 '--- COLUMN:  "Trade Type"
        counter = counter + 1
        TradeTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        TradeTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Trade Type"
  
 '--- COLUMN:  "Spread Type"
        counter = counter + 1
        SpreadTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        SpreadTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Spread Type"
  
 '--- COLUMN:  "Amount Rate Type"
        counter = counter + 1
        RateTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        RateTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Amount Rate Type"
  
 '--- COLUMN:  "Execution Type"
        counter = counter + 1
        ExecutionTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        ExecutionTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Execution Type"
  
 '--- COLUMN:  "Default Y/N"
        counter = counter + 1
        DefaultExecutionTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        DefaultExecutionTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Default Y/N"
  
 '--- COLUMN:  "Brokerage Amount"
        counter = counter + 1
        AmountColumn = Module1.ConvertToExcelColumnLetter(counter)
        AmountColumnNumber = counter
        eModuleColumnsNames(counter) = "Brokerage Amount"
  
 '--- COLUMN:  "MM Min"
        counter = counter + 1
        MMMinAmountColumn = Module1.ConvertToExcelColumnLetter(counter)
        MMMinAmountColumnNumber = counter
        eModuleColumnsNames(counter) = "MM Min"
  
 '--- COLUMN:  "MM Max"
        counter = counter + 1
        MMMaxAmountColumn = Module1.ConvertToExcelColumnLetter(counter)
        MMMaxAmountColumnNumber = counter
        eModuleColumnsNames(counter) = "MM Max"
        
 '--- COLUMN:  "MM Define"
        counter = counter + 1
        MMDefineColumn = Module1.ConvertToExcelColumnLetter(counter)
        MMDefineColumnNumber = counter
        eModuleColumnsNames(counter) = "MM Define"
  
 '--- COLUMN:  "MM Apply"
        counter = counter + 1
        MMApplyColumn = Module1.ConvertToExcelColumnLetter(counter)
        MMApplyColumnNumber = counter
        eModuleColumnsNames(counter) = "MM Apply"
   
 '--- COLUMN:  "Add-On"
        counter = counter + 1
        AddOnAmountColumn = Module1.ConvertToExcelColumnLetter(counter)
        AddOnAmountColumnNumber = counter
        eModuleColumnsNames(counter) = "Add-On"
   
 '--- COLUMN:  "Add-On Apply"
        counter = counter + 1
        AddOnApplyColumn = Module1.ConvertToExcelColumnLetter(counter)
        AddOnApplyColumnNumber = counter
        eModuleColumnsNames(counter) = "Add-On Apply"
  
 '--- COLUMN:  "Vol Disc Based On"
        counter = counter + 1
        TierDefinedBasedColumn = Module1.ConvertToExcelColumnLetter(counter)
        TierDefinedBasedColumnNumber = counter
        eModuleColumnsNames(counter) = "Vol Disc Based On"
   
 '--- COLUMN:  "Vol Disc Apply To"
        counter = counter + 1
        TierApplyToColumn = Module1.ConvertToExcelColumnLetter(counter)
        TierApplyToColumnNumber = counter
        eModuleColumnsNames(counter) = "Vol Disc Apply To"
  
 '--- COLUMN:  "Vol Disc Tier Value Type"
        counter = counter + 1
        TierValueTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        TierValueTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Vol Disc Tier Value Type"
  
 '--- COLUMN:  "Vol Disc Tier #"
        counter = counter + 1
        TiersColumn = Module1.ConvertToExcelColumnLetter(counter)
        TiersColumnNumber = counter
        eModuleColumnsNames(counter) = "Vol Disc Tier #"

 '--- COLUMN:  "Vol Disc Tier Start Value"
        counter = counter + 1
        TierStartNumberAmountColumn = Module1.ConvertToExcelColumnLetter(counter)
        TierStartNumberAmountColumnNumber = counter
        eModuleColumnsNames(counter) = "Vol Disc Tier Start Value"
    
 '--- COLUMN:  "Vol Disc Rate"
        counter = counter + 1
        TierVolDiscRateColumn = Module1.ConvertToExcelColumnLetter(counter)
        TierVolDiscRateColumnNumber = counter
        eModuleColumnsNames(counter) = "Vol Disc Rate"
   
 '--- COLUMN:  "Band Apply"
        counter = counter + 1
        BandApplyColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandApplyColumnNumber = counter
        eModuleColumnsNames(counter) = "Band Apply"
        
 '--- COLUMN:  "Band Value Type"
        counter = counter + 1
        BandValueTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandValueTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Band Value Type"

 '--- COLUMN:  "Band #"
        counter = counter + 1
        BandTierNoColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandTierNoColumnNumber = counter
        eModuleColumnsNames(counter) = "Band #"

 '--- COLUMN:  "Band Start"
        counter = counter + 1
        BandStartColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandStartColumnNumber = counter
        eModuleColumnsNames(counter) = "Band Start"

 '--- COLUMN:  "Band End"
        counter = counter + 1
        BandEndColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandEndColumnNumber = counter
        eModuleColumnsNames(counter) = "Band End"

 '--- COLUMN:  "Band Rate Type"
        counter = counter + 1
        BandRateTypeColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandRateTypeColumnNumber = counter
        eModuleColumnsNames(counter) = "Band Rate Type"

 '--- COLUMN:  "Band Rate"
        counter = counter + 1
        BandRateColumn = Module1.ConvertToExcelColumnLetter(counter)
        BandRateColumnNumber = counter
        eModuleColumnsNames(counter) = "Band Rate"

'--- all variables are loaded - UPDATE WITH NEW RELEASES!

FirstColumn = DirectBillColumn
LastColumn = BandRateColumn '--- UPDATE 3.5 - REG - 6/15/15 - UPDATE FOR ANY NEW COL ADDED

'-- verified correct - 2/26/16 - reg

End Sub

Public Sub errorVbaHandlderMsg(errorContext As String, errorNumber As String, errorDesc As String, errorSrc As String, stage1 As String, stage2 As String, stage3 As String, stage4 As String, notes As String, Log As Boolean)

'--REG - 4/22/16- REMOVED GETUSER - 64 BIT COMPILE ISSUE

Application.DisplayStatusBar = True
Application.Cursor = xlNormal

If stage1 = "" Then stage1 = "N/A"
If stage2 = "" Then stage2 = "N/A"
If stage3 = "" Then stage2 = "N/A"
If stage4 = "" Then stage4 = "N/A"
If notes = "" Then notes = "N/A"


Dim title As String
title = Module1.eModuleVersion + " VBA Error During: " + errorContext
Dim message As String

message = "eModule Program Error During " + errorContext + ":  " + vbLf + _
       "On Date: " + CStr(Now()) + vbLf + _
       "eModule Version: " + Module1.eModuleVersion + vbLf + _
       "Error number:  " + errorNumber + vbLf + _
       "Error Description: " + errorDesc + vbLf + _
       "Error Source: " + errorSrc + vbLf + vbLf + _
       "Number of eModule rows: " + CStr(Module1.ModuleLastRow) + vbLf + _
       "Excel Version: " + CStr(Application.Version) + vbLf + _
       "eModule Stages: " + "1: " + stage1 + ", 2: " + stage2 + ", 3: " + stage3 + ", 4: " + stage4
       
If errorNumber = 13 Then
   
MsgBox "There is a type conversion error #13." + vbLf + vbLf + _
       "This usually means some REQUIRED NUMERIC DATA is missing." + vbLf + vbLf + _
       "For example some numeric data cells has text or is empty and when converted to numeric it fails." + vbLf + vbLf + _
       "Review all data on the row with a validation error, check the rate type used too." + vbLf + vbLf + _
       "We provide more details next. Validation processing has been stopped at the row with the error.", vbQuestion, "MISSING DATA - VALIDATION STOPPED"

End If

MsgBox message + vbLf + notes + vbLf + Module1.eModuleErrorMsgToUser, vbCritical, title
  
 If Log Then
    
    Dim rng2 As Range
    Dim rng3 As Range
    Dim rng4 As Range
    Dim rng5 As Range
    
    Set rng2 = ErrorLog.Range(ErrorLogTimeStampColumn & ErrorLogRowCounter)
    Set rng3 = ErrorLog.Range(ErrorLogRowNumberColumn & ErrorLogRowCounter)
    Set rng4 = ErrorLog.Range(ErrorLogColumnNameColumn & ErrorLogRowCounter)
    Set rng5 = ErrorLog.Range(ErrorLogMessageColumn & ErrorLogRowCounter)
    
    rng2 = Now()
    rng3 = "FOR FIA TECH"
    rng4 = "VBA ERROR HANDLER ERROR - Notes: " + notes
    rng5 = message
    
    ErrorLogRowCounter = ErrorLogRowCounter + 1
    
    Set rng5 = Nothing
    Set rng4 = Nothing
    Set rng3 = Nothing
    Set rng2 = Nothing
  
 End If
 

End Sub


Public Sub clearErrorLog()


Dim ModuleLastRow As Long
Dim ErrorLogLastRow As Long

ErrorLogLastRow = ErrorLog.Range(Module1.ErrorLogTimeStampColumn & Module1.LastSheetRow).End(xlUp).row

If ErrorLogLastRow >= ErrorLogFirstRow Then

    ErrorLog.Range(Module1.ErrorLogTimeStampColumn & Module1.ErrorLogFirstRow, Module1.ErrorLogMessageColumn & ErrorLogLastRow).ClearContents

End If

Call freezeRows

'ErrorLog.Application.ActiveWindow.SplitRow = Module1.ErrorLogFirstRow - 1
'ErrorLog.Application.ActiveWindow.FreezePanes = True

End Sub




Public Sub cellCopyDown()

Dim valueToCopy As String

Dim cel As Range
Dim rng1 As Range
Dim rng2 As Range
Set rng1 = Selection
'--- the cell above has the value to copy down
Dim rw1 As Long
Dim rw2 As Long

Dim col1 As Integer


If rng1.Columns.Count <> 1 Then
   MsgBox "This button needs a column range of one column. Selected range:  " + rng1.Address + vbLf + _
           "It will read the value above the range and copy it down the range", , title1
   Exit Sub
End If

col1 = rng1.Column
rw1 = rng1.row '-- cell above the range
rw2 = rw1 - 1
If rw2 < 4 Then
   Exit Sub '--headings
End If

Dim col2 As String
col2 = ConvertToExcelColumnLetter(col1)

Dim addr As String
addr = col2 + CStr(rw2) + ":" + col2 + CStr(rw2)
Set rng2 = Range(addr)    '-- one row above

valueToCopy = Trim(rng2.Value)

If valueToCopy = "" Then
   MsgBox "There is no value to copy down in: " + rng2.Address + vbLf + vbLf + _
          "You need to have some data in the cell above the selected region", , title1
   Exit Sub
End If

'--- copydown

For Each cel In rng1
    
    If Trim(cel.Value) = "" Then
       cel.Value = valueToCopy
    End If
Next

End Sub

Public Sub freezeRows()

Application.ScreenUpdating = False

disableWorksheetSelectionChange = True

Dim addr As String

'--- error log
ErrorLog.Activate

addr = CStr(Module1.ErrorLogFirstRow) + ":" + CStr(Module1.ErrorLogFirstRow)
ErrorLog.Rows(addr).Select '"1:1"

ErrorLog.Application.ActiveWindow.SplitRow = Module1.ErrorLogFirstRow - 1
ErrorLog.Application.ActiveWindow.FreezePanes = True


'-- emodule
ModuleSheet.Activate

addr = CStr(Module1.ModuleFirstRow) + ":" + CStr(Module1.ModuleFirstRow)
ModuleSheet.Rows(addr).Select '"4:4"

ModuleSheet.Application.ActiveWindow.SplitRow = Module1.ModuleFirstRow - 1
ModuleSheet.Application.ActiveWindow.FreezePanes = True

Call Module1.SelectFirstCell(True)

disableWorksheetSelectionChange = False

Application.ScreenUpdating = True

End Sub

Public Function getNumberVisibleScreenRows() As Long

    Dim lngNumRows As Long ' number of visible rows

    lngNumRows = ActiveWindow.VisibleRange.Rows.Count
    'MsgBox "count of vis rows in screen: " + CStr(lngNumRows)
    
    getNumberVisibleScreenRows = lngNumRows
    
End Function


Public Function getTopVisibleScreenRow() As Long

    Dim lngTopRow As Long ' number of visible rows

    lngTopRow = ActiveWindow.VisibleRange.row
    'MsgBox "top vis row#: " + CStr(lngTopRow)
     
    getTopVisibleScreenRow = lngTopRow
    
End Function


Public Function getOptimalCboxRows() As Long

getOptimalCboxRows = 0
Dim currcelRow As Long

If ActiveCell.row > 0 Then
   currcelRow = ActiveCell.row
End If

Dim lastVisibleRowsScreen As Long
 lastVisibleRowsScreen = getTopVisibleScreenRow + getNumberVisibleScreenRows

'-- compute from current cell the rows left below

getOptimalCboxRows = lastVisibleRowsScreen - currcelRow

End Function
Attribute VB_Name = "Module2"
Option Explicit
Public lastActiveRow As Long
Public lastActiveColumn As String


'--- VALIDATION DONE IN THIS MODULE 2 - BELOW




Private Sub staticCboxValidations(Irow As Long)

Dim I As Long
I = Irow

lastActiveRow = I


            '--- THESE COLUMNS ARE VALIDATED VS THE STATIC DATA ONLY
            '--- REGION, EXCHANGE ETC ARE DYNAMIC DATA - SINCE EACH ONE DEPENDS ON THE OTHER PREV VALUES FOR VALIDATION
            
            '--- 3/11/16 - SPLIT THE ValidateStaticDataColumn INTO 3 CASES: REQUIRED FOR LINE1 ANY RATE TYPE
            '--- CASE 2: ADD ON AND MM CAN BE THERE OR NOT
            '--- CASE 3: VOL DISC OR BAND DISC - FIRST LINE REQUIRED TOO (CASE 1) AND VOL DISC/BAND FIELDS, SPECIAL CASES FOR BLANK LINES
            
            '--- REQUIRED VALUES FOR LINE-1 FOR ALL RATE TYPES ARE CURRENCY, RATE TYPE, EXEC TYPE - APPLIES TO ALL RATE TYPES
            Dim VOL_TierLine1_Found_bln As Boolean
            Dim BND_TierLine1_Found_bln As Boolean
            
            VOL_TierLine1_Found_bln = foundVolDisc(I)
            BND_TierLine1_Found_bln = foundBndDisc(I)
           
            
            '-- THESE VALUES NOT REQUIRED (FALSE)
            
            Call ValidateStaticDataColumn(StaticDataDirectBillColumn, DirectBillColumn, I, False)
            Call ValidateStaticDataColumn(StaticDataTradeTypeColumn, TradeTypeColumn, I, False)
            Call ValidateStaticDataColumn(StaticDataSpreadTypeColumn, SpreadTypeColumn, I, False)
            
            '-- NEW Emod 3.5 - multiple ValidateStaticDataColumnxxx needed
            
            '--- NOT REQUIRED SINCE IT PRELOADED CURRENCY
            Call ValidateStaticDataColumn(StaticDataDefaultExecutionTypeColumn, DefaultExecutionTypeColumn, I, False)
            
            '--- FROM HERE ON VALUE IS REQUIRED - IT'S EMPTY CELL OR A VALID VALUE (EMPTY FOR BAND OR VOL DISC LINE>1)
        
            Call ValidateStaticDataColumn2(StaticDataRateTypeColumn, RateTypeColumn, I, True)
            Call ValidateStaticDataColumn2(StaticDataExecutionTypeColumn, ExecutionTypeColumn, I, True)
            
            Call ValidateStaticDataColumn2(StaticDataCurrencyColumn, CurrencyColumn, I, True)
            
            '--- NEXT ALL 'REQUIRED' FLAGS ONLY FORCE SPECIALIZED SUBS TO EXECUTE AT THE END OF THE ValidateStaticDataColumnXXX
                       
            Call ValidateStaticDataColumn2MAX(StaticDataMMDefineColumn, MMDefineColumn, I, True) '-- required if any MM data is loaded
            Call ValidateStaticDataColumn2MAX(StaticDataMMApplyColumn, MMApplyColumn, I, True) '-- required if any MM data is loaded
            
            Call ValidateStaticDataColumn2ADD(StaticDataAddOnApplyColumn, AddOnApplyColumn, I, True) '-- required if any addon data is loaded
            
            '--- FOR VOL DISC (VD) TWO CASES - TIER 1 THEN WE REQUIRED THE FIELDS BELOW, ELSE IF TIER >1 WE REQUIRE THEM TO BE EMPTY
             
            '--- 2/25/16 - reg - set all the checks below to true = required and mod the code to do it.
            
            Call ValidateStaticDataColumnVD(StaticDataTierDefinedBasedColumn, TierDefinedBasedColumn, I, True)
            Call ValidateStaticDataColumnVD(StaticDataTierApplyToColumn, TierApplyToColumn, I, True)
            Call ValidateStaticDataColumnVD(StaticDataTiersValueTypeColumn, TierValueTypeColumn, I, True)
       
          '--- FOR BND DISC (BD) TWO CASES - TIER 1 THEN WE REQUIRED THE FIELDS BELOW, ELSE IF TIER >1 WE REQUIRE THEM TO BE EMPTY
       
            '-- new emod 3.5-banding - these are the 3 cboxes we need to verify contents
            Call ValidateStaticDataColumnBD(Module1.StaticDataBandApply, BandApplyColumn, I, True)
            Call ValidateStaticDataColumnBD(Module1.StaticDataBandValueType, BandValueTypeColumn, I, True)
            Call ValidateStaticDataColumnBD(Module1.StaticDataBandRateType, BandRateTypeColumn, I, True)


End Sub

Public Sub ValidateStaticDataColumn(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

'---Docn: reg - this makes a lookup for the valid values for the current cbox in the static data tab
'---this works mostly for non-numeric fields with a given set of possible values in some column of the static tab and that have a cbox
'---so we pass the cbox column in static data tab, the emod cbox column, the row, required flag,
'---ComboBoxColumn & RowNumber is the current cell address, IF there is an input value and is not in the list we get a validation error
'---emod 3.5 had new requirements and needed to split it into several similar subs, with the required part customized
'---in the case here the required detects an empty input as error - missing value, else for non required it's ignored

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

  
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

If CBC_R_Value <> "" Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO DATA INPUTED - SPACES - IF REQUIRED WE MAY HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY - THESE CELLS REQUIRE A VALUE
    
          Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
          Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Value")
            
        Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
            
      End If
            
    End If

'Next I

End Sub


Public Sub ValidateStaticDataColumn2(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

  
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

'--- 3/11/16 - REG - SPLIT CHECKS FOR REQUIRED LINE 1 VALUES VS OPTIONAL LINE 1 VALUES (CAN BE SPACES) -ADD on amd MM

'--- IF IT'S A  VOL DISC OR BAND DISC LINE>1 must be SPACES (no rate type etc)
  '(foundBndDisc(RowNumber) And (Range(BandApplyColumn & RowNumber).Value = "")) Or _
  '(foundVolDisc(RowNumber) And (Range(TierApplyToColumn & RowNumber).Value = "")) Then
 

If (CBC_R_Value = "") And _
   (foundBndDisc(RowNumber) Or foundVolDisc(RowNumber)) Then
    
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue '--- SPACES IS OK
   Exit Sub
End If


If CBC_R_Value <> "" Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO VALID DATA INPUTED -  IF REQUIRED WE  HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY - THESE CELLS REQUIRE A VALUE
    
          Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
          Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Value")
            
        Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
            
      End If
            
    End If

'Next I

End Sub





Public Sub ValidateStaticDataColumn2CUR(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

  
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

'--- 3/11/16 - REG - SPLIT CHECKS FOR REQUIRED LINE 1 VALUES VS OPTIONAL LINE 1 VALUES (CAN BE SPACES) -ADD on amd MM

'--- IF IT'S A NON VOL DISC OR BAND DISC LINE>1 CAN HAVE SPACES
If (CBC_R_Value = "") And _
   (foundBndDisc(RowNumber) And (Range(BandTierNoColumn & RowNumber).Value <> FirstBandingDiscountTier)) Or _
   (foundVolDisc(RowNumber) And (Range(TiersColumn & RowNumber).Value <> FirstVolumeDiscountTier)) Then
    
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue '--- SPACES IS OK
   Exit Sub
End If


If CBC_R_Value <> "" Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO VALID DATA INPUTED -  IF REQUIRED WE  HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY - THESE CELLS REQUIRE A VALUE
    
          Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
          Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Value")
            
        Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
            
      End If
            
    End If

'Next I

End Sub

Public Sub ValidateStaticDataColumn2ADD(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

  
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

'--- 3/11/16 - REG - SPLIT CHECKS FOR REQUIRED LINE 1 VALUES VS OPTIONAL LINE 1 VALUES (CAN BE SPACES) -ADD on amd MM

'--- IF IT'S A NON VOL DISC OR BAND DISC LINE>1 CAN HAVE SPACES
If (CBC_R_Value = "") And _
   (foundBndDisc(RowNumber) And (Range(BandTierNoColumn & RowNumber).Value <> FirstBandingDiscountTier)) Or _
   (foundVolDisc(RowNumber) And (Range(TiersColumn & RowNumber).Value <> FirstVolumeDiscountTier)) Then
    
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue '--- SPACES IS OK
   Exit Sub
End If

If (CBC_R_Value = "") And (Not foundAddOn(RowNumber)) Then 'NOT FOUND ADD ON
    
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue '--- SPACES IS OK
   Exit Sub
End If


If CBC_R_Value <> "" Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO VALID DATA INPUTED -  IF REQUIRED WE  HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY - THESE CELLS REQUIRE A VALUE
    
          Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
          Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Value")
            
        Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
            
      End If
            
    End If

'Next I

End Sub


Public Sub ValidateStaticDataColumn2MAX(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

  
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

'--- 3/11/16 - REG - SPLIT CHECKS FOR REQUIRED LINE 1 VALUES VS OPTIONAL LINE 1 VALUES (CAN BE SPACES) -ADD on amd MM

'--- IF IT'S A NON VOL DISC OR BAND DISC LINE>1 CAN HAVE SPACES
If (CBC_R_Value = "") And _
   (foundBndDisc(RowNumber) And (Range(BandTierNoColumn & RowNumber).Value <> FirstBandingDiscountTier)) Or _
   (foundVolDisc(RowNumber) And (Range(TiersColumn & RowNumber).Value <> FirstVolumeDiscountTier)) Then
    
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue '--- SPACES IS OK
   Exit Sub
End If

If (CBC_R_Value = "") And (Not foundMinMax(RowNumber)) Then '--NOT FOUND MIN MAX
    
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue '--- SPACES IS OK
   Exit Sub
End If


If CBC_R_Value <> "" Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO VALID DATA INPUTED -  IF REQUIRED WE  HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY - THESE CELLS REQUIRE A VALUE
    
          Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
          Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Value")
            
        Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
            
      End If
            
    End If

'Next I

End Sub




'--SPECIAL FOR VOL DISC

Public Sub ValidateStaticDataColumnVD(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

Dim firstTierVolDiscRow As Boolean
firstTierVolDiscRow = True

Dim col1 As Integer
col1 = getColumnNumber(ComboBoxColumn)

If (col1 >= TierDefinedBasedColumnNumber And col1 <= TierVolDiscRateColumnNumber) And _
   (Range(TiersColumn & RowNumber).Value <> FirstVolumeDiscountTier) Then
     firstTierVolDiscRow = False
End If
         
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

'--- 3/11/16 - REG - SPLIT CHECKS FOR REQUIRED LINE 1 VALUES VS OPTIONAL LINE 1 VALUES (CAN BE SPACES)

If CBC_R_Value = "" Then
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
   Exit Sub
End If


If CBC_R_Value <> "" And (firstTierVolDiscRow) Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO DATA INPUTED - SPACES - IF REQUIRED WE MAY HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY
                 
        '--- need to limit this logic for required if the cbox is on the vol disc or band disc region - else get error for mmdefine (required)
                 
           '--- ORIGINAL CODE - EMOD 3.4 - HAD ONLY VOL DISC - MARKS AS INVALID EMPTY REQUIRED VALS
           ' If (((Range(TiersColumn & RowNumber).Value = "") And _
                 (Range(StartNumberAmountColumn & RowNumber).Value = "") And _
                 (Range(VolDiscAmountColumn & RowNumber).Value = "")) Or _
                 (Range(TiersColumn & RowNumber).Value = FirstVolumeDiscountTier) Or _
                 (Range(RateTypeColumn & RowNumber).Value = VolumeDiscountRateType)) Then
                 
         '-- EMOD 3.5 CREATE NEW CASES FOR BANDING AND SEPARATE THE ERROR MESSAGES - ONLY FOR REQUIRED STATIC VALUES (CURRENCY ETC) - BUT FOR THE 1ST LINE OF THE DISC/BAND
         
            '--- ORIGINAL CODE - EMOD 3.4 - HAD ONLY VOL DISC - MARKS AS INVALID EMPTY REQUIRED VALS
             
            '--- FOR ROW 1 WITH RATE TYPE WE MUST HAVE REQUIRED VALUE, ELSE IF TIER IS 1 OR WE HAVE A VOL DISC/BAND RATE TYPE
            '--- PART 1 BELOW: NO TIERS#, NO START NUMBER AND RATE TYPE - MISSING VALUE -- OR
            '--- PART 2 BELOW: 1ST TIER VOL DISC OR BAND RATE TYPE (ANOTHER COLUMN IS REQUIRED)
           
            If (((Range(TiersColumn & RowNumber).Value = "") And _
                 (Range(TierStartNumberAmountColumn & RowNumber).Value = "") And _
                 (Range(RateTypeColumn & RowNumber).Value = "")) Or _
                 (Range(TiersColumn & RowNumber).Value = FirstVolumeDiscountTier) Or _
                 (Range(RateTypeColumn & RowNumber).Value = VolumeDiscountRateType)) Then
                 
                Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
                Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Value")
                
                '*** 11/20/13
                
            End If
            
                     
         
         '--- if the tier 1 is missing then we fail below unless we use OR
         
         If (col1 >= Module1.TierDefinedBasedColumnNumber And col1 <= Module1.TierVolDiscRateColumnNumber) Then
                 
            If (Range(RateTypeColumn & RowNumber).Value = VolumeDiscountRateType) Or firstTierVolDiscRow Then
   
                           
                If (Range(TierDefinedBasedColumn & RowNumber).Value = "") And (TierDefinedBasedColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Missing Based On")
                End If
                
                If (Range(TierApplyToColumn & RowNumber).Value = "") And (TierApplyToColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Missing Apply To")
                End If
                
                If (Range(TierValueTypeColumn & RowNumber).Value = "") And (TierDefinedBasedColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Missing Value Type")
                End If
                  
                
                
                
            End If
         
        
         
         '--- we must have EMPTY the text values for tier 2 on
         
         
         
            If (Not firstTierVolDiscRow) Then
                           
                If (Range(TierDefinedBasedColumn & RowNumber).Value <> "") And (TierDefinedBasedColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Based On must be empty on Tier>1")
                End If
                
                If (Range(TierApplyToColumn & RowNumber).Value <> "") And (TierApplyToColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Apply To must be empty on Tier>1")
                End If
                
                If (Range(TierValueTypeColumn & RowNumber).Value <> "") And (TierValueTypeColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Value Type must be empty on Tier>1")
                End If
                     
            End If
            
             Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
         
         End If
        
     End If
     
 End If
        
         
'
'            If Range(RateTypeColumn & RowNumber).Value = VolumeDiscountRateType Then
'
'                If (((Range(TiersColumn & RowNumber).Value = "") And _
'                     (Range(TierStartNumberAmountColumn & RowNumber).Value = "") And _
'                     (Range(TierVolDiscRateColumn & RowNumber).Value = "")) Or _
'                     (Range(TiersColumn & RowNumber).Value = FirstVolumeDiscountTier)) Then
'
'                    Call SetInvalidRange(rngCBC_R)
'                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Vol Disc - Missing Value")
'                    Exit Sub
'                End If
'
'            End If
'
         
 

'Next I

End Sub


'--SPECIAL FOR BAND DISC

Public Sub ValidateStaticDataColumnBD(StaticDataComboBoxColumn As String, ComboBoxColumn As String, RowNumber As Long, RequiredValue As Boolean)

lastActiveColumn = StaticDataComboBoxColumn

Dim I As Long
Dim J As Long

Dim ValidationRange As Range

If Module1.PQTinUseDisableCboxes = True Then
   Exit Sub
End If

'RegionLastRow = ModuleSheet.Range(RegionColumn & LastSheetRow).End(xlUp).Row

Set ValidationRange = StaticData.Range("$" & StaticDataComboBoxColumn & "$" & StaticDataRowOffset _
                      & ":$" & StaticDataComboBoxColumn & "$" & _
                      StaticData.Range(StaticDataComboBoxColumn & LastSheetRow).End(xlUp).row)
Dim cntVRng As Long
cntVRng = ValidationRange.Count '--NUMBER OF ITEMS IN THE VALIDATION COLUMN - THE STATIC DATA FOR THE FIELD

Dim firstTierBandDiscRow As Boolean
firstTierBandDiscRow = True

Dim col1 As Integer
col1 = getColumnNumber(ComboBoxColumn)

If (col1 >= BandApplyColumnNumber And col1 <= BandRateColumnNumber) And _
   (Range(BandTierNoColumn & RowNumber).Value <> FirstBandingDiscountTier) Then
     firstTierBandDiscRow = False
     
End If
                 
Dim addrCBC_R As String
addrCBC_R = ComboBoxColumn & RowNumber '--- reg - store common values
Dim rngCBC_R As Range
Set rngCBC_R = Range(addrCBC_R)
'For I = ModuleFirstRow To RegionLastRow
Dim CBC_R_Value As String
CBC_R_Value = Trim(rngCBC_R.Value)

'--- 3/11/16 - REG - SPLIT CHECKS FOR REQUIRED LINE 1 VALUES VS OPTIONAL LINE 1 VALUES (CAN BE SPACES)

If CBC_R_Value = "" Then
   rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
   Exit Sub
End If


If CBC_R_Value <> "" And (firstTierBandDiscRow) Then

    For J = 1 To cntVRng
    
        If CBC_R_Value = ValidationRange.Cells(J, 1).Value Then

            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue

            Exit For

        End If

    Next J
    
    If J > cntVRng Then
   
        Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
        Call AddValidationComment(ComboBoxColumn, RowNumber, "Invalid Value")

    End If
    
Else
 
    '-- THERE IS NO DATA INPUTED - SPACES - IF REQUIRED WE MAY HAVE AN ERROR
   
    
    If RequiredValue = True Then  '-- PASSED PARM - RequiredValue
    '================================================================= MERE MEANS THE CELL WAS EMPTY
         
'            If (Range(RateTypeColumn & RowNumber).Value = BandingDiscountRateType) Then
'
'                If (((Range(BandTierNoColumn & RowNumber).Value = "") And _
'                     (Range(BandStartColumn & RowNumber).Value = "") And _
'                     (Range(BandRateColumn & RowNumber).Value = "")) Or _
'                     (Range(Module1.BandTierNoColumn & RowNumber).Value = FirstBandingDiscountTier)) Then
'
'                    Call SetInvalidRange(rngCBC_R)
'                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding Discount - Missing Value")
'                    Exit Sub
'                End If
'
'            End If
'
'--- below we match only for the 1st line since the band rate rate type appears only in the 1st line, when tier=1
            
            
         If (col1 >= Module1.BandApplyColumnNumber And col1 <= Module1.BandRateColumnNumber) Then
                 
            
            If (Range(RateTypeColumn & RowNumber).Value = BandingDiscountRateType) Or firstTierBandDiscRow Then
                                                            
                If (Range(BandApplyColumn & RowNumber).Value = "") And (BandApplyColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding - Missing Band Apply")
                End If
                       
                If (Range(BandValueTypeColumn & RowNumber).Value = "") And (BandValueTypeColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding - Missing Value Type")
                End If
              
                                       
                If (Range(BandRateTypeColumn & RowNumber).Value = "") And (BandRateTypeColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding - Missing Rate Type")
                End If
                
            End If
        
                
           
            If (Not firstTierBandDiscRow) Then
                           
                 If (Range(BandApplyColumn & RowNumber).Value <> "") And (BandApplyColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding - Band Apply must be empty on Tier>1")
                End If
                
                 If (Range(BandValueTypeColumn & RowNumber).Value <> "") And (BandValueTypeColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding - Band Value Type must be empty on Tier>1")
                End If
                                     
                If (Range(BandRateTypeColumn & RowNumber).Value <> "") And (BandRateTypeColumn = ComboBoxColumn) Then
                    Call SetInvalidRange(rngCBC_R)
                    Call AddValidationComment(ComboBoxColumn, RowNumber, "Banding - Band Rate Type must be empty on Tier>1")
                End If
         
           End If
            
         End If
            
        Else
    
            rngCBC_R.Interior.ColorIndex = ValidColorIndexValue
            
      End If
            
    End If

'Next I

End Sub





Public Function IsNumericNonNegative(numDataStr As Variant, okZero As Boolean) As Boolean

'--- emod 3.5 new function that replaces numerous checks on 3.4 (>8 separate blocks of code) with a single function

'-- true means passed, in some cases must use 'not IsNumericNonNegative' since we are checking is number is not valid

'---3/30/16-reg-loaded specific message for each error - not the generic error below, since each error exits the function at once

'--- old std msg is now custom per case below:
'": INVALID Number - Missing value, is Spaces, Non-Numeric, Negative, invalid Decimal places or over 5 decimal places."

'--- 4/21/16 - Per Elin request allow brok amt and min max - min to be zero - added the new parm okZero

Dim numDataDbl As Double
numDataDbl = 0

IsNumericNonNegative = True

If IsEmpty(numDataStr) Then

   stdMsgIsNumericNonNegative = ": Invalid Number - Missing value"
   IsNumericNonNegative = False
   Exit Function
End If

numDataStr = Trim(numDataStr)

If (numDataStr = "") Then

   stdMsgIsNumericNonNegative = ": Invalid Number - Missing value"
   IsNumericNonNegative = False
   Exit Function
End If

If Not IsNumeric(numDataStr) Then

   stdMsgIsNumericNonNegative = ": Invalid Number - Non-numeric value"
   IsNumericNonNegative = False
   Exit Function
End If


'--- now is numeric and non empty

numDataDbl = CDbl(numDataStr)

If numDataDbl < 0 Then
   stdMsgIsNumericNonNegative = ": Invalid Number - Negative value"
   IsNumericNonNegative = False
   Exit Function
End If

'--- 4/21/16 - Per Elin request allow brok amt and min max - min to be zero - added the new parm okZero
If (Not okZero) And numDataDbl = 0 Then
   stdMsgIsNumericNonNegative = ": Invalid Number - Zero value"
   IsNumericNonNegative = False
   Exit Function
End If

Dim posDec As Integer
posDec = InStr(numDataStr, DecimalSeparator)


'--- 3/21/16-need to detetc more than 5 decimal places as error - Egus truncas 5 decimals - Markit Graham, integerplaces is 5, decimalplaces is 10
If (posDec = 0) And (Len(numDataStr) > NumberOfIntegerPlaces) Then

   stdMsgIsNumericNonNegative = ": Invalid Number - integer number exceeds max number of " + CStr(NumberOfIntegerPlaces) + " digits"
   IsNumericNonNegative = False
   Exit Function
End If

If ((numDataDbl <> 0) And (posDec <> 0) And ((posDec - 1) > NumberOfDecimalPlaces)) Then

   stdMsgIsNumericNonNegative = ": Invalid Number - decimal number exceeds max number of " + CStr(NumberOfDecimalPlaces) + " digits"
   IsNumericNonNegative = False
   Exit Function
End If


If (posDec > 0) And (numDataDbl <> 0) And ((Len(numDataStr) - posDec) > NumberOfDecimalPlaces) Then '--now NumberOfDecimalPlaces=5

   stdMsgIsNumericNonNegative = ": Invalid Number - decimal number, fractional part exceeds max number of " + CStr(NumberOfDecimalPlaces) + " digits"
   IsNumericNonNegative = False
   Exit Function
End If

'--- it's true

'If (((AddOn_Amount < 0)) Or _
'(Not IsNumeric(AddOn_Amount)) Or _
'((AddOn_Amount <> 0) And _
'((InStr(AddOn_Amount, DecimalSeparator) = 0) And (Len(AddOn_Amount) > NumberOfIntegerPlaces))) Or _
'((AddOn_Amount <> 0) And _
'((InStr(AddOn_Amount, DecimalSeparator) <> 0) And _
'(Len(AddOn_Amount) - (Len(AddOn_Amount) - (InStr(AddOn_Amount, DecimalSeparator) - 1))) > NumberOfIntegerPlaces)) Or _
'((AddOn_Amount <> 0) And _
'((InStr(AddOn_Amount, DecimalSeparator) <> 0) And _
'(Len(AddOn_Amount) - InStr(AddOn_Amount, DecimalSeparator)) > NumberOfDecimalPlaces))) Then

'If (((Range(Module1.MMMinAmountColumn & I).Value < 0)) Or _
 (Not IsNumeric(Range(MMMinAmountColumn & I).Value)) Or _
((Range(MMMinAmountColumn & I).Value <> 0) And _
((InStr(Range(MMMinAmountColumn & I).Value, DecimalSeparator) = 0) And _
 (Len(Range(MMMinAmountColumn & I).Value) > NumberOfIntegerPlaces))) Or _
((Range(MMMinAmountColumn & I).Value <> 0) And _
((InStr(Range(MMMinAmountColumn & I).Value, DecimalSeparator) <> 0) And _
 (Len(Range(MMMinAmountColumn & I).Value) - _
 (Len(Range(MMMinAmountColumn & I).Value) - (InStr(Range(MMMinAmountColumn & I).Value, DecimalSeparator) - 1))) > NumberOfIntegerPlaces)) Or _
((Range(MMMinAmountColumn & I).Value <> 0) And _
((InStr(Range(MMMinAmountColumn & I).Value, DecimalSeparator) <> 0) And _
 (Len(Range(MMMinAmountColumn & I).Value) - InStr(Range(MMMinAmountColumn & I).Value, DecimalSeparator)) > NumberOfDecimalPlaces)) Or _
((Range(MMMinAmountColumn & I).Value <> 0) And _
 (Range(MMMaxAmountColumn & I).Value <> 0) And _
 (Range(MMMinAmountColumn & I).Value >= Range(MMMaxAmountColumn & I).Value))) Then




End Function



'--- EMOD 3.5 foundxxx NEW true/false functions TO HELP - ALL CHECK IF THERE IS DATA ON THEIR RESPECTIVE COLUMNS - BUT DO NO CHECK THE RATE TYPES


Public Function foundAddOn(Irow As Long) As Boolean

foundAddOn = False

Dim tmpCel As Range
Dim rngAddonCells As Range
Dim Istr As String
Istr = CStr(Irow)
Dim addr As String

addr = Module1.AddOnAmountColumn & Istr & ":" & Module1.AddOnApplyColumn & Istr

Set rngAddonCells = Range(addr)

For Each tmpCel In rngAddonCells '-- not this does not cover the rate type of Vol Disc
 
 If Trim(tmpCel.Value) <> "" Then
    foundAddOn = True
    Exit For
 End If
 
Next

Set tmpCel = Nothing
Set rngAddonCells = Nothing

End Function


Public Function foundMinMax(Irow As Long) As Boolean

'

foundMinMax = False

Dim tmpCel As Range
Dim rngMMCells As Range
Dim Istr As String
Istr = CStr(Irow)
Dim addr As String

addr = Module1.MMMinAmountColumn & Istr & ":" & Module1.MMApplyColumn & Istr

Set rngMMCells = Range(addr)

For Each tmpCel In rngMMCells '-- not this does not cover the rate type of Vol Disc
 
 If Trim(tmpCel.Value) <> "" Then
    foundMinMax = True
    Exit For
 End If
 
Next

Set tmpCel = Nothing
Set rngMMCells = Nothing

End Function


Public Function foundMissingMinMax(Irow As Long) As Boolean

'

foundMissingMinMax = False

Dim tmpCel As Range
Dim rngMMCells As Range
Dim Istr As String
Istr = CStr(Irow)
Dim addr As String

addr = Module1.MMMinAmountColumn & Istr & ":" & Module1.MMApplyColumn & Istr

Set rngMMCells = Range(addr)

For Each tmpCel In rngMMCells '-- not this does not cover the rate type of Vol Disc
 
 If Trim(tmpCel.Value) = "" Then
    foundMissingMinMax = True
    Exit For
 End If
 
Next

Set tmpCel = Nothing
Set rngMMCells = Nothing



End Function


Public Function foundVolDisc(Irow As Long) As Boolean

'--- THIS SETS, FOR THE PASSED ROW, THESE TWO VARIABLES: BND_Disc_Data_Found_bln

foundVolDisc = False

Dim tmpCel As Range
Dim rngVolDiscCells As Range
Dim Istr As String
Istr = CStr(Irow)
Dim addr As String

addr = Module1.TierDefinedBasedColumn & Istr & ":" & Module1.TierVolDiscRateColumn & Istr

Set rngVolDiscCells = Range(addr)

For Each tmpCel In rngVolDiscCells '-- not this does not cover the rate type of Vol Disc
 
 If Trim(tmpCel.Value) <> "" Then
    foundVolDisc = True
    Exit For
 End If
 
Next

Set tmpCel = Nothing
Set rngVolDiscCells = Nothing



End Function

Public Function foundBndDisc(Irow As Long) As Boolean

'--- THIS SETS, FOR THE PASSED ROW, THESE TWO VARIABLES: BND_Disc_Data_Found_bln

foundBndDisc = False

Dim tmpCel As Range
Dim rngBndDiscCells As Range
Dim Istr As String
Istr = CStr(Irow)
Dim addr As String

addr = Module1.BandApplyColumn & Istr & ":" & Module1.BandRateColumn & Istr

Set rngBndDiscCells = Range(addr)

For Each tmpCel In rngBndDiscCells '-- not this does not cover the rate type of Band Rate
 
 If Trim(tmpCel.Value) <> "" Then
    foundBndDisc = True
    Exit For
 End If
 
Next

Set tmpCel = Nothing
Set rngBndDiscCells = Nothing

End Function



Public Sub PerformValidation()
'-----------------------------

On Error GoTo VBAErrorHandler:

'--- DISABLE ALL UNNECESSARY EMOD PROCESSING HERE
'--- 1-SELETION CHANGE AND 2-STATIC BOXES CHECKS
ComboBoxChange = False

'--- 3/10/16-be sure col vars are loaded
If RegionColumn = "" Then
   Call Module1.loadColumnVariables
End If

'--- reg - 3/1/16 - usability - if a cell is selected save it and return to it at the end

Set saveCurrCell3 = Selection

'--- 100 ASTERKISK FOR 100%
Const validationBar = "****************************************************************************************************" '-- 100 asterisks or percent/2 long

If isUserFormLoaded(CP) Then
   frmControlPanel.validationDateTime = "** Processing **"
End If

Call Module1.HideAllSheets

performValidationFlag = False

Application.ScreenUpdating = False

Call clearEmodEscapeCharacters(False) '-- makes cells with empty strins become 'Empty' type

Dim I As Long
Dim J As Long
Dim K As Long
Dim L As Long
'--- for a fixed value use a converted number to string to avoid num-str conversions
Dim Istr As String
Dim Jstr As String


'--- log below and important stage of the program for error reporting
Dim errorStage(1 To 4) As String
Dim ModuleLastRow As Long
Dim VolumeDiscountStartRow As Long
Dim BandingDiscountStartRow As Long 'emod 3.5
Dim DefaultExecutionArray() As String
Dim Bnd_Value_Type_Saved As String
Dim Bnd_Rate_Type_Saved As String

Dim ValidationRange_I As Range
Dim ValidationRange_J As Range

Dim CellComment As Comment

Dim ErrorLogLastRow As Long

Dim NumberOfIntegers As Long
Dim NumberOfDecimals As Long
Dim retVal As Integer

'--- 2/23/16 - validation of new band rules

Dim firstBandLineBln As Boolean
Dim bandStartEndInt As Boolean
Dim bandTier_Current As Integer
Dim Rate_Type_Current As String

'retVal = MsgBox("Perform eModule Validation", vbQuestion + vbYesNo, title2)
'retVal = vbYes
'If retVal <> vbYes Then
 '  Exit Sub
'End If

Application.ScreenUpdating = False

'==================
ModuleSheet.Activate
'=================== key - we are on an active eModule (1st) sheet

'--- COMPILER ERROR CORRECTED - 6/7/15-REG - LESSON - STORE THE MODULE WITH THE SET COMMAND

'--- new checks for empty rows - reg - 6/25/15
Call Module1.deleteAndReportAlmostEmptyRows

'If Selection.Range.Count > 1 Then
'End If

'--- PENDING - check for non existent EXCHANGES and flag theM


ModuleLastRow = getModuleLastRow() '--- need to centralize the last cell values

Call Module1.clearErrorLog

If ModuleLastRow < ModuleFirstRow Then
    MsgBox "No Rows in Rate Schedule - Exiting", vbInformation, title2
    ModuleSheet.Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleMaxRows + (ModuleFirstRow - 1)).Interior.ColorIndex = ValidColorIndexValue
    ModuleSheet.Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleMaxRows + (ModuleFirstRow - 1)).ClearComments
    Call HideComboBoxesFast
    On Error GoTo 0
    Exit Sub
    '------
End If

Dim rngAmt1 As Range
Set rngAmt1 = Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleLastRow)
rngAmt1.Interior.ColorIndex = ValidColorIndexValue
rngAmt1.ClearComments

Call Module1.formatNumericColumns

VolumeDiscountStartRow = 0
BandingDiscountStartRow = 0

ErrorLogRowCounter = ErrorLogFirstRow

Application.DisplayStatusBar = True
'Application.Cursor = xlWait  ---testing

Dim statusMsg As String
Dim statusPct As Double

'ReDim productTypeValidation(ModuleFirstRow To ModuleLastRow)
ReDim DefaultExecutionArray(ModuleFirstRow To ModuleLastRow)

Application.ScreenUpdating = False '--be sure

Dim rowCount As Single
rowCount = 0
Dim numOfRows As Single
numOfRows = ModuleLastRow - ModuleFirstRow + 1

'--- EMOD 3.5 WILL USE THESE TMP VALUES TO DETECT SPACES (WILL BE ZERO) ETC
Dim VOL_Disc_Data_Found_bln As Boolean
Dim BND_Disc_Data_Found_bln As Boolean
Dim bandingStartNumber As Integer '1 or 0

Dim bolTest As Boolean
Dim tmpTierNo As Double
Dim tmpBandNo  As Double
Dim tmpStartNo As Double
Dim tmpEndNo As Double
Dim tmpRateNo As Double

Dim tmpAddr As String
Dim tmpAddr1 As String
Dim tmpAddr2 As String
Dim tmpCel As Range
Dim msg As String
Dim lastRateType As String '-- emod 3.5
Dim Validation_I_Count As Long
errorStage(1) = "Before Main for loop: For I = ModuleFirstRow To ModuleLastRow"
        
'--- best way to know if we have a vol disc/band disc is to look at the last rate - since if so the next rows rate will be empty


'-- 1st last columns
Dim addrFC_I As String '--- reduce string manip loop
Dim addrLC_I As String '--- reduce string manip loop
'-- eMod 3.5 order
Dim addrDirectBill_I As String
Dim addrRC_I As String '--- reduce string manip loop
Dim addrExchange_I As String '--- reduce string manip loop
Dim addrPGCC_I As String '--- reduce string manip loop
Dim addrPC_I As String '--- reduce string manip loop
Dim addrRTC_I As String '--- reduce string manip loop
Dim addrDEC_I As String '--- reduce string manip loop
'-- MM min/max
Dim addrMAXAC_I As String
Dim addrMINAC_I As String
Dim addrAOAC_I As String
Dim rngMMax_I  As Range
Dim MM_Max_Amount_I As String
Dim rngMMin_I As Range
Dim MM_Min_Amount_I As String
Dim rngAddrAOAC_I As Range
Dim AddOn_Amount As String
'--- Vol Disc - need to repeat after Else for other I values
Dim rngSTC_I As Range
Dim VolDisc_Tiers As String
Dim addrNAC_I As String '--- reduce string manip loop
Dim rngVolDisc_TierStartNumber_I As Range
Dim VolDisc_TierStartNumber_I As String
Dim addrTC_I As String '--- reduce string manip loop
Dim rngVolDisc_TierNo_I As Range
Dim VolDisc_TierNo_I As String
Dim addrVDAC_I As String '--- reduce string manip loop
Dim rngVolume_Disc_Rate_I As Range
Dim Volume_Disc_Rate_I As String
Dim rngDTC_I As Range
Dim VolDisc_TierDefinedBased_I As String
Dim rngATC_I As Range
Dim VolDisc_TierApplyTo_I As String
Dim rngVTC_I As Range '-- column renamed from start type to tier value type emod 3.5
Dim VolDisc_TierValueType_I As String
Dim rngTDC_I_VDAC_I As Range
'--- end vol disc
 
'--- RATE TYE
Dim rngAddrRTC_I As Range
Dim Rate_Type As String

'--- EMOD 3.5 THE BANDING DISCOUNT COLUMNS
'--- Apply   Band Value Type Band #  Start   End Rate Type   Rate
Dim rngBandingRow As Range
'--- BAND APPLY
Dim rngBA_I As Range
Dim Bnd_Apply_I As String
'--- BAND VALUE TYPE
Dim rngBVT_I As Range
Dim Bnd_Value_Type_I As String
'--- BAND NUMBER (NO)
Dim rngBnd_TierNo_I As Range
Dim Bnd_TierNo_I As String '--?? int
'--- BAND START/END VALUES FOR CURRENT ROW I
Dim rngBnd_START_No_I As Range
Dim Bnd_START_No_I As String
Dim rngBnd_END_No_I As Range
Dim Bnd_END_No_I As String
'--- BAND START/END VALUES FOR PREV ROW I-1
Dim rngBnd_START_No_I_1 As Range
Dim Bnd_START_No_I_1 As String
Dim rngBnd_END_No_I_1 As Range
Dim Bnd_END_No_I_1 As String
'--- BAND RATE TYPE
Dim rngBRT_I As Range
Dim Bnd_Rate_Type_I As String
'--- BAND RATE
Dim rngBRATE_I As Range
Dim Bnd_RATE_I As String
Dim rngBandingRow2 As Range
'--- product validations or exchanges

Dim rngAddrRC_I As Range
Dim Region_I As String
Dim rngAddrEC_I As Range
Dim Exchange_I As String
Dim rngRegion_Exch_Code_I As Range
Dim rngAddrPGCC_I As Range
Dim ProductGroupCode_I As String
Dim rngAddrPC_I As Range
Dim Product_I As String

'--- general vars
Dim rngFirst_Last_Column_I As Range

'--- boolean flags to simplify condtions or validations groups
Dim VOL_Disc_and_Amount_Error_bln As Boolean
Dim BND_Disc_and_Amount_Error_bln As Boolean
Dim Brokerage_Amount_Error_bln As Boolean

    
Dim STD_Rate_Line_Found_bln As Boolean '--non band and non vol disc - rate type can be empty
Dim VOL_TierLine1_Found_bln As Boolean
Dim BND_TierLine1_Found_bln As Boolean
            
'---
Dim rngAmountColumn As Range
Dim Brokerage_Amount_I As String

'--- these vars have the other inner index J (from 1 to index I)
'--- remove .count in loops/if (we are inside loops) to insure it is not calculated each time
Dim addrRC_J As String
Dim Exchange_J_Addr As String
Dim Exchange_J As Range
Dim DirectBill_J_Addr As String
Dim DirectBill_I As String
Dim DirectBill_J As String

Dim addr3J As String
Dim rng3J As Range
Dim rngDEC_I As Range
Dim count1 As Long
Dim ct1 As Long
Dim ct2 As Long
'Dim ct3 As Long
   
 
VolumeDiscountStartRow = 0
BandingDiscountStartRow = 0
               

'------------------------------------------- MAIN FOR LOOP FOR ALL EMOD ROWS
For I = ModuleFirstRow To ModuleLastRow
'------------------------------------------- VALIDATION STARTS FOR EACH ROW - INDEX I

        lastActiveRow = I

'-------- LATER INDEX J IS INSIDE THIS LOOP TO COMPARE WITH ALL PREVIOUS VALUES J IN: ModuleFirstRow TO I

'-------- Thus we need to sufix all variables inside each loop with _I or _J to know where they are defined

        Istr = CStr(I)
        
        rowCount = rowCount + 1
        
        errorStage(1) = "After Main for loop at row# " + Istr
        
        If (I Mod 2 = 0) Then '--- reg - report every 2 rows
        
           statusPct = rowCount / numOfRows
           '-- one status is on the form - the other below is on the appn message bar
           statusMsg = "Validation Progress:  Row# " & Istr & " of " & CStr(ModuleLastRow) & ":  " & format(statusPct, "0%")
           
           If isUserFormLoaded(CP) Then
              frmControlPanel.validationDateTime = statusMsg
           End If
           '-- add the bar line
           statusMsg = statusMsg & "  " + Mid(validationBar, 1, statusPct * 100)
           Application.StatusBar = statusMsg
           DoEvents '-- DONT BLANK THE FORMS
        End If
       
     
       
        '-- 1st last columns
        addrFC_I = FirstColumn & Istr
        addrLC_I = LastColumn & Istr
        
        '-- eMod 3.5 order
                  
        addrDirectBill_I = DirectBillColumn & Istr
        addrRC_I = RegionColumn & Istr '--- reduce string manip loop
        addrExchange_I = ExchangeColumn & Istr
        addrPGCC_I = ProductGroupCodeColumn & Istr
        addrPC_I = ProductColumn & Istr
        addrRTC_I = RateTypeColumn & Istr
        addrDEC_I = DefaultExecutionTypeColumn & Istr
        '-- MM min/max
        addrMAXAC_I = MMMaxAmountColumn & Istr
        addrMINAC_I = MMMinAmountColumn & Istr
        addrAOAC_I = AddOnAmountColumn & Istr
        '--- Vol Disc - need to repeat after Else for other I values
        addrNAC_I = TierStartNumberAmountColumn & Istr
        addrTC_I = TiersColumn & Istr
        addrVDAC_I = TierVolDiscRateColumn & Istr
        
        'Note:  vol disc and banding are treated separately (1st line and other lines) if if-BLOCKS later below
          
        Set rngAddrRTC_I = Range(addrRTC_I)
        Rate_Type = Trim(rngAddrRTC_I.Value)
        
        '-- reset rate type - if the current rate is non empty - note for vol disc/band rate_type and other items to the left are only defined in the 1st row
        If Trim(Rate_Type) <> "" And (lastRateType <> Rate_Type) Then
           lastRateType = Rate_Type
        End If
     
            
        '--- EMOD 3.5 THE BANDING DISCOUNT COLUMNS
        '--- Apply   Band Value Type Band #  Start   End Rate Type   Rate
        '--- remove .count in loops/if (we are inside loops) to insure it is not calculated each time
           
        '--- 1st CHECK - BLANK ROWS
        
     
        Set rngFirst_Last_Column_I = Range(addrFC_I, addrLC_I)
              
        Set ValidationRange_I = Range(addrFC_I, addrLC_I)
        Validation_I_Count = ValidationRange_I.Count
        
        For K = 1 To Validation_I_Count
        
            If ValidationRange_I(1, K) <> "" Then
               Exit For
            End If
            
        Next K
                            
        If (K > Validation_I_Count) Then
        
        '===================================== BLANK ROW CHECK - IF#1
            
            Call SetInvalidRange(ValidationRange_I)
            Call AddValidationComment(FirstColumn, I, "Blank Row")
        
        Else '======================== NON BLANK ROW
            
            
            Call staticCboxValidations(I)
            '=========================== important - checks all static cells per cbox contents
                    
                    
             '--- EMOD 3.5 BANDING ADDED
         
            
            VOL_TierLine1_Found_bln = foundVolDisc(I)
            BND_TierLine1_Found_bln = foundBndDisc(I)
            
          
            STD_Rate_Line_Found_bln = (lastRateType <> VolumeDiscountRateType) And (lastRateType <> BandingDiscountRateType)
            '-- need rate type <> "" since for vol disc or band disc the non one lines have empty rates
            
                
            '--- CHECK FOR POSSIBLE ERROR ON BANDING AND VOL DISC
            If (VOL_TierLine1_Found_bln And BND_TierLine1_Found_bln) Then
                 '--- NEW ERROR EMOD 3.5 - BOTH OF BAND AND VOL DISC USED
                Call SetInvalidRange(Range(TierDefinedBasedColumn & I, TierVolDiscRateColumn & I))
                Call AddValidationComment(TierDefinedBasedColumn, I, "Vol Disc and Banding Together is Invalid")
             
            End If
            
            
            If (lastRateType <> VolumeDiscountRateType) And VOL_TierLine1_Found_bln Then
                 '--- NEW ERROR EMOD 3.5 - BOTH OF BAND AND VOL DISC USED
                Call SetInvalidRange(Range(TierDefinedBasedColumn & I, TierVolDiscRateColumn & I))
                Call AddValidationComment(TierDefinedBasedColumn, I, "Vol Disc Data without Vol Disc Rate is Invalid")
             
            End If
            
            If (lastRateType <> BandingDiscountRateType) And BND_TierLine1_Found_bln Then
                 '--- NEW ERROR EMOD 3.5 - BOTH OF BAND AND VOL DISC USED
                Call SetInvalidRange(Range(BandApplyColumn & I, BandRateColumn & I))
                Call AddValidationComment(BandApplyColumn, I, "Banding Data without Band Rate is Invalid")
             
            End If
            
            
            VOL_TierLine1_Found_bln = False
            BND_TierLine1_Found_bln = False
            '--- VOL DISC
            
            '--- allow the use of tier data to detect vol disc
            
           Set rngVolDisc_TierNo_I = Range(addrTC_I)
           If (rngVolDisc_TierNo_I.Value = FirstVolumeDiscountTier) Or _
              (Rate_Type = VolumeDiscountRateType) Then
               '-- do it since its a 1st line or no vol disc
               VOL_TierLine1_Found_bln = True
           End If
           
            '--- BANDING
           Set rngBnd_TierNo_I = Range(Module1.BandTierNoColumn & Istr)
           If (rngBnd_TierNo_I.Value = FirstVolumeDiscountTier) Or _
              (Rate_Type = BandingDiscountRateType) Then
               '-- do it since its a 1st line or no vol disc
               BND_TierLine1_Found_bln = True
           End If
            
          'original logic - the vol disc basic data empty or line 1 of tier and vol disc rate
          '  If (((IsEmpty(Range(TiersColumn & I).Value)) And _
         (IsEmpty(Range(StartNumberAmountColumn & I).Value)) And _
         (IsEmpty(Range(VolDiscAmountColumn & I).Value))) Or _
         (Range(TiersColumn & I).Value = FirstVolumeDiscountTier) Or _
         (Range(RateTypeColumn & I).Value = VolumeDiscountRateType)) Then
              
                    '--- THREE CASES TO PASS THRU HERE 1-A STD RATE LINE 2-STD RATE LINE + VOL DISC OR 3-STD RATE LINE WITH BAND DISC
            
             '============== 2ND CHECK - ROW WITHOUT VOLDISC/BANDS OF 1ST ROW IF IT HAS VOLDISC/BANDS (SINCE TIER/BAND=1)
            
          If STD_Rate_Line_Found_bln Or VOL_TierLine1_Found_bln Or BND_TierLine1_Found_bln Then
          
         '===================================== 1ST TIER VOL DISC/BAND# CHECK - IF#2
           
            
            errorStage(2) = "Main if check has std, vol, bnd as: " + CStr(STD_Rate_Line_Found_bln) + ", " + CStr(VOL_TierLine1_Found_bln) + ", " + CStr(BND_TierLine1_Found_bln)
         
         
             If VOL_TierLine1_Found_bln Then
                VolumeDiscountStartRow = I
             End If
             
             If BND_TierLine1_Found_bln Then
                BandingDiscountStartRow = I
             End If
           ' MsgBox "Row " & I & " Volume/Banding DiscountStartRow = " & VolumeDiscountStartRow & "," & BandingDiscountStartRow
           
            DefaultExecutionArray(I) = Trim(Range(addrDEC_I).Value)
            
            If STD_Rate_Line_Found_bln Then
               Range(addrDEC_I).Value = "Y"
            End If
            
            Set rngAddrRC_I = Range(addrRC_I)
            
            Region_I = Trim(rngAddrRC_I.Value)
         
            For J = 0 To RegionArrayUBound

                If UCase(Region_I) = UCase(RegionArray(J)) Then
                    rngAddrRC_I.Interior.ColorIndex = ValidColorIndexValue
                    Exit For
        
                End If
        
            Next J
            
           Set rngAddrEC_I = Range(addrExchange_I)
           
           Exchange_I = Trim(rngAddrEC_I.Value)
           
           Set rngRegion_Exch_Code_I = Range(addrRC_I, addrPC_I)
           Set rngAddrPGCC_I = Range(addrPGCC_I)
           ProductGroupCode_I = Trim(rngAddrPGCC_I.Value)
           
           Set rngAddrPC_I = Range(addrPC_I)
           Product_I = Trim(rngAddrPC_I.Value)
          ' MsgBox "Invalid or Missing Region"
           
           
        If STD_Rate_Line_Found_bln Or VOL_TierLine1_Found_bln Or BND_TierLine1_Found_bln Then
        '------------------------------------------------------------------------------------ ANY STD LINE OR VD/BD TIER 1 MUST HAVE ALL REQUIRED CODES
        '---4/9/16-reg-fixed bug for vd/bd if region-prod was missing did not mark them
        
        If J > RegionArrayUBound Then
          
        '===================================== REGION CHECK - IF#3
               
               lastActiveColumn = RegionColumn
                Call SetInvalidRange(rngRegion_Exch_Code_I)
                Call AddValidationComment(RegionColumn, I, "Invalid or Missing Region")
                
            Else
            
            '===================================== VALID REGION
                For J = 0 To ExchangeArrayUBound
      
                    If ((UCase(Region_I) = UCase(ExchangeArray(J, 0))) And _
                        (UCase(Exchange_I) = UCase(ExchangeArray(J, 1)))) Then
            
                        Range(addrRC_I, addrExchange_I).Interior.ColorIndex = ValidColorIndexValue
            
                        Exit For
            
                    End If
        
                Next J
                
              
                
                If J > ExchangeArrayUBound Then
                
                    lastActiveColumn = RegionColumn
                    Call SetInvalidRange(rngRegion_Exch_Code_I)
                    Call AddValidationComment(RegionColumn, I, "Invalid or Missing Region/Exchange Code")
                        
                Else
                
                    For J = 0 To ProductGroupCodeArrayUBound
        
                        If ((UCase(Region_I) = UCase(ProductGroupCodeArray(J, 0))) And _
                            (UCase(Exchange_I) = UCase(ProductGroupCodeArray(J, 1))) And _
                            (UCase(ProductGroupCode_I) = UCase(ProductGroupCodeArray(J, 2)))) Then
                
                            Range(addrRC_I, addrPGCC_I & Istr).Interior.ColorIndex = ValidColorIndexValue
                
                            Exit For
                
                        End If
        
                    Next J
                    
                    If J > ProductGroupCodeArrayUBound Then
                    
                        lastActiveColumn = RegionColumn
                        Call SetInvalidRange(rngRegion_Exch_Code_I)
                        Call AddValidationComment(RegionColumn, I, "Invalid or Missing Region/Exchange Code/Product Group Name")
                    
                    Else
                    
                        For J = 0 To ProductArrayUBound
        
                            If ((UCase(Region_I) = UCase(ProductArray(J, 0))) And _
                                (UCase(Exchange_I) = UCase(ProductArray(J, 1))) And _
                                (UCase(ProductGroupCode_I) = UCase(ProductArray(J, 2))) And _
                                (UCase(Product_I) = UCase(ProductArray(J, 3)))) Then
                    
                                rngRegion_Exch_Code_I.Interior.ColorIndex = ValidColorIndexValue
                    
                                Exit For
                    
                            End If
        
                        Next J
        
                        If J > ProductArrayUBound Then
                            lastActiveColumn = RegionColumn
                            Call SetInvalidRange(rngRegion_Exch_Code_I)
                            Call AddValidationComment(RegionColumn, I, "Invalid or Missing Region/Exchange Code/Product Group Name/Product Name")
                        
                        End If
                    
                    End If '-- VALID PRODUCT CHECK
        
                End If '-- VALID PRODUCT GRP CHECK
        
            End If '-- VALID EXHANGE CHECK
         
        End If '-- If STD_Rate_Line_Found_bln Then
        
           
                   
            If ((Rate_Type = PercentNotionRateType) Or _
                (Rate_Type = PercentPremiumRateType)) Then
                 
                NumberOfIntegers = PercentRateTypeNumberOfIntegerPlaces
                NumberOfDecimals = NumberOfDecimalPlaces
                    
            Else
                
                NumberOfIntegers = NumberOfIntegerPlaces
                NumberOfDecimals = NumberOfDecimalPlaces
                 
            End If
        
       
            Set rngAmountColumn = Range(AmountColumn & Istr)
            Brokerage_Amount_I = Trim(rngAmountColumn.Value)
            
            '--- 3/21/16-reg-new checks for brk amt - max value per list of rate types - Graham markit
            
            If (Rate_Type <> BandingDiscountRateType) And (Rate_Type <> VolumeDiscountRateType) And IsNumeric(Brokerage_Amount_I) And (Brokerage_Amount_I <> "") Then
                
                If InStr(Module1.maxRateAmtList999, Rate_Type) > 0 And (Brokerage_Amount_I > max3digits) Then
                    
                    Call SetInvalidRange(rngAmountColumn)
                    Call AddValidationComment(AmountColumn, I, "Invalid Brokerage Amount - exceeded Max value of " + CStr(max3digits) + " (three digits) for rate type: " + Rate_Type)
                
                End If
                
                 If InStr(Module1.maxRateAmtList99999, Rate_Type) > 0 And (Brokerage_Amount_I > max5digits) Then
                    
                    Call SetInvalidRange(rngAmountColumn)
                    Call AddValidationComment(AmountColumn, I, "Invalid Brokerage Amount - exceeded Max value of " + CStr(max5digits) + "  (5 digits) for rate type: " + Rate_Type)
                
                End If
            
            End If
            
            '
            
            
            '--- EMOD 3.5 ADDED BANDING CHECKS - IF BAND THEN BROKER AMOUNT MUST BE EMPTY
            
         
            tmpTierNo = 0
            '-- there can only be one rate type
            If VolDisc_TierNo_I <> "" And IsNumeric(VolDisc_TierNo_I) Then
               tmpTierNo = CLng(VolDisc_TierNo_I)
            End If
            
            If (Brokerage_Amount_I <> "") And ((Rate_Type = VolumeDiscountRateType) Or (tmpTierNo = FirstVolumeDiscountTier)) Then
                VOL_Disc_and_Amount_Error_bln = True
               Else
                VOL_Disc_and_Amount_Error_bln = False
             End If
             
                         
             If (Brokerage_Amount_I <> "") And ((Rate_Type = BandingDiscountRateType) Or (rngBnd_TierNo_I.Value = FirstBandingDiscountTier)) Then
                BND_Disc_and_Amount_Error_bln = True
               Else
                BND_Disc_and_Amount_Error_bln = False
             End If
             
             bolTest = IsNumericNonNegative(Brokerage_Amount_I, True)
             
             '--- 3/21/16-need to detect >5 dec places
             If (Rate_Type <> "") And (Rate_Type <> BandingDiscountRateType) And (Rate_Type <> VolumeDiscountRateType) And (Not IsNumericNonNegative(Brokerage_Amount_I, True)) Then
                 Call SetInvalidRange(rngAmountColumn)
                 Call AddValidationComment(AmountColumn, I, "Brokerage Amount" + stdMsgIsNumericNonNegative)
             End If
             
             
             Rate_Type_Current = Module1.getCurrentRateType(rngAmountColumn)
                        
             If (IsNumericNonNegative(Brokerage_Amount_I, True) And (Rate_Type_Current <> BandingDiscountRateType) And (Rate_Type_Current <> VolumeDiscountRateType)) Or _
                 ((Brokerage_Amount_I = "") And ((Rate_Type_Current = BandingDiscountRateType) Or (Rate_Type_Current = VolumeDiscountRateType))) Then
                 '========================================= KEY VALIDATION OF BROKERAGE AMOUNT (MUST BE EMPTY FOR BANDING OR VOL DISC, ELSE MUST BE NUMERIC)
                 Brokerage_Amount_Error_bln = False
                Else
                 Brokerage_Amount_Error_bln = True
             End If
              
        
            '-- EMOD 3.5 BANDING - SUMMARIZED ALL LOGICAL CHECKS IN THE ABOVE 3 BOOLEANS

            If (VOL_Disc_and_Amount_Error_bln Or _
                BND_Disc_and_Amount_Error_bln Or _
                Brokerage_Amount_Error_bln) Then
                
                rngAmountColumn.NumberFormat = decimalFormat2
                lastActiveColumn = AmountColumn
                
                Call SetInvalidRange(rngAmountColumn)
                
                '--- IMPROVE ERROR MSG - EMOD 3.5
                msg = ""
                If VOL_Disc_and_Amount_Error_bln Then
                   msg = " with VOL DISCOUNT (Brokerage Amount must be empty)" '--- made msg more clear - reg - 3/3/16
                End If
                If BND_Disc_and_Amount_Error_bln Then
                   msg = " with BAND DISCOUNT (Brokerage Amount must be empty)"
                End If
                Call AddValidationComment(AmountColumn, I, "Invalid Brokerage Amount" + msg)
             
            End If
        
            
            Set rngMMax_I = Range(addrMAXAC_I)
            MM_Max_Amount_I = Trim(rngMMax_I.Value)
            
            Set rngMMin_I = Range(addrMINAC_I)
            MM_Min_Amount_I = Trim(rngMMin_I.Value)
        
        
            '-- TECH NOTES: VBA DOES *NOT* SHORT CIRCUIT AND STATEMENTS (THUS: FALSE AND XXX WILL STILL EVALUATE XXXX)
            '-- BELOW IF THE CELL IS NOT USED THE rngMMin_I.Value <> 0 EVALUATES AS Empty <> 0 OR FALSE AND NO ERROR
            '-- BUT IF WE USE MM_Min_Amount_I <>0 WE GET AN ERROR SINCE IT EVALUATES AS ""<>0 AND THEY ARE INCOMPATIBLE TYPES
            '-- SUMMARY: MUST USE rangeVar.Value to VERIFY BEFORE WE CHECK VALUES
            'If (((Range(MMMinAmountColumn & I).Value <> 0) And _  - emod 3.4
            '(Range(MMMaxAmountColumn & I).Value <> 0) And _

            lastActiveColumn = MMMinAmountColumn

            If foundMinMax(I) And foundMissingMinMax(I) Then
                
            '-- per David specs if there is some min max data we need all the data filled
                                 
                
                Dim tmpRng As Range
                Dim colx As Integer
                colx = 0
                
                tmpAddr = Module1.MMMinAmountColumn & Istr & ":" & Module1.MMApplyColumn & Istr
                
                Set tmpRng = Range(tmpAddr)
                
                For Each tmpCel In tmpRng '-- not this does not cover the rate type of Vol Disc
                 
                    If Trim(tmpCel.Value) = "" Then
                                                     
                       Call SetInvalidRange(tmpCel)
                       Call AddValidationComment(MMMinAmountColumn, I, "Some Min/Max data is missing - must fill all values")
                       Exit For
                                                     
                    End If
                    
                    colx = colx + 1
                     
                Next
                
                Set tmpCel = Nothing
                Set tmpRng = Nothing

            
            End If

                

            If (MM_Min_Amount_I <> "" And MM_Max_Amount_I <> "") And _
                 IsNumericNonNegative(MM_Min_Amount_I, True) And _
                ((rngMMin_I.Value <> 0) And _
                 (rngMMax_I.Value <> 0) And _
                 (rngMMin_I.Value >= rngMMax_I.Value)) Then
                
                rngMMin_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngMMin_I)
                Call AddValidationComment(MMMinAmountColumn, I, "Invalid Min or (Min >= Max)")
            
            End If
            
            '--- 3/19/16 - reg - Graham requires min max fields not over 5 digits before decimal pt
            
            If (MM_Min_Amount_I <> "") And _
                 IsNumeric(MM_Min_Amount_I) And _
                (rngMMin_I.Value <> 0) And _
                (rngMMin_I.Value > Module1.maxMinMaxDigits) Then
                
                rngMMin_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngMMin_I)
                Call AddValidationComment(MMMinAmountColumn, I, "Invalid Min - over 5 digits.")
            
            End If
            
            If (MM_Max_Amount_I <> "") And _
                 IsNumeric(MM_Max_Amount_I) And _
                (rngMMax_I.Value <> 0) And _
                (rngMMax_I.Value > Module1.maxMinMaxDigits) Then
                
                rngMMax_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngMMax_I)
                Call AddValidationComment(MMMaxAmountColumn, I, "Invalid Max - over 5 digits.")
            
            End If
            
            bolTest = IsNumericNonNegative(MM_Max_Amount_I, False)
            
            '--- 3/21/16-reg-detect minmax over5 dec places
            
            If Not IsNumericNonNegative(MM_Max_Amount_I, False) And foundMinMax(I) Then
               rngMMax_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngMMax_I)
                Call AddValidationComment(MMMaxAmountColumn, I, "MM Max Amount" + stdMsgIsNumericNonNegative)
            
            End If
            
             If Not IsNumericNonNegative(MM_Min_Amount_I, True) And foundMinMax(I) Then
               rngMMin_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngMMin_I)
                Call AddValidationComment(MMMinAmountColumn, I, "MM Min Amount" + stdMsgIsNumericNonNegative)
            
            End If
            
            
            If (MM_Min_Amount_I <> "" And MM_Max_Amount_I <> "") And _
                 IsNumericNonNegative(MM_Max_Amount_I, False) And _
                ((rngMMin_I.Value >= 0) And _
                 (rngMMax_I.Value <> 0) And _
               (rngMMin_I.Value >= rngMMax_I.Value)) Then
          
                rngMMax_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngMMax_I)
                Call AddValidationComment(MMMaxAmountColumn, I, "Invalid Max or (Max <= Min)")
                
            End If
                 
            If (((rngMMin_I.Value <> 0) And (rngMMax_I.Value = 0)) Or _
                ((IsEmpty(rngMMin_I.Value)) And (rngMMax_I.Value <> 0)) Or _
                ((Range(MMApplyColumn & Istr).Value <> "") And ((rngMMin_I.Value = 0) And (rngMMax_I.Value = 0)))) Then
                 
                Call SetInvalidRange(Range(MMMinAmountColumn & Istr, MMApplyColumn & Istr))
                
                Const msgMinMax = "Min and/or Max Values Missing"
                Call AddValidationComment(MMMinAmountColumn, I, msgMinMax)
                Call AddValidationComment(MMMaxAmountColumn, I, msgMinMax)
                Call AddValidationComment(MMApplyColumn, I, msgMinMax)
                Call AddValidationComment(MMDefineColumn, I, msgMinMax) '-- emod 3.5
                               
            End If
            
                         
            'If Module2.foundMissingMinMax(RowNumber) Then
             '--- EMOD 3.5 NEW CASE - WHEN A REQUIRED FIELD DEPENDS ON OTHER'S BEING PRESENT
             'Call SetInvalidRange(Range(ComboBoxColumn & RowNumber))
             'Call AddValidationComment(ComboBoxColumn, RowNumber, "Missing Required Value")
           ' End If
            
         
            Set rngAddrAOAC_I = Range(addrAOAC_I)
            AddOn_Amount = Trim(rngAddrAOAC_I.Value)
            
            lastActiveColumn = AddOnAmountColumn
            
            '--- 3/21/15-per markit - addon has a max
            
            If AddOn_Amount <> "" And IsNumeric(AddOn_Amount) Then
            
               If (AddOn_Amount > Module1.maxAddOn) Then
                rngAddrAOAC_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngAddrAOAC_I)
                Call AddValidationComment(AddOnAmountColumn, I, "AddOn Amount exceeds Max value of:  " + CStr(Module1.maxAddOn))
               End If
            
            End If
            
            
            If Not IsNumericNonNegative(AddOn_Amount, False) And (Range(AddOnApplyColumn & Istr).Value <> "") Then
                
                rngAddrAOAC_I.NumberFormat = decimalFormat2
                Call SetInvalidRange(rngAddrAOAC_I)
                Call AddValidationComment(AddOnAmountColumn, I, "AddOn Amount" + stdMsgIsNumericNonNegative)
            
            End If
        
            If ((IsEmpty(AddOn_Amount)) And (Range(AddOnApplyColumn & Istr).Value <> "")) Then
                 
                Call SetInvalidRange(Range(addrAOAC_I, AddOnApplyColumn & Istr))
                Call AddValidationComment(AddOnAmountColumn, I, "One or More AddOn Values Missing")
                Call AddValidationComment(AddOnApplyColumn, I, "One or More AddOn Values Missing")
               
            End If

            

            
            Const msg1 = "Inconsistent Direct Bill Values - Blank is Equivalent to No"
            
            Const msg3a = "Duplicate Default Execution Values"
            Const msg3b = "No Default Execution Method Selected by User - Please Review"
            
            
            '=========================== CHECK FOR DUPLICATE LINES
            
            '=========================== J LOOP STARTS - START TO I-1
            
            For J = ModuleFirstRow To I - 1
            '------------------------------- 2nd loop after I
                
                '--- reg  I x J permutations - a lot of string manip
                
                errorStage(3) = "Inner J loop at:  " + CStr(J)
                
                Jstr = CStr(J)
                
                addrRC_J = RegionColumn & Jstr
                Exchange_J_Addr = ExchangeColumn & Jstr
                Set Exchange_J = Range(Exchange_J_Addr)
                DirectBill_J_Addr = DirectBillColumn & Jstr
                DirectBill_I = Trim(Range(addrDirectBill_I).Value)
                DirectBill_J = Trim(Range(DirectBill_J_Addr).Value)
                
                If ((Exchange_I <> "") And _
                    (Exchange_I = Exchange_J) And _
                    (Trim(DirectBill_I) <> Trim(DirectBill_J))) Then
            
                        Call SetInvalidRange(Range(addrDirectBill_I))
                        Call SetInvalidRange(Range(ExchangeColumn & I))
                        
                        Call AddValidationComment(DirectBillColumn, I, msg1)
                        Call AddValidationComment(ExchangeColumn, I, msg1)
                        
                        Call SetInvalidRange(Range(DirectBill_J_Addr))
                        Call SetInvalidRange(Range(Exchange_J_Addr))
                        
                        Call AddValidationComment(DirectBillColumn, J, msg1)
                        Call AddValidationComment(ExchangeColumn, J, msg1)
               
                    End If
                                          
                    '--- reg - were are in a loop - building string values
                 
                    addr3J = DefaultExecutionTypeColumn & Jstr
                    Set rng3J = Range(addr3J)
                    Set rngDEC_I = Range(addrDEC_I)
                    
                    Set ValidationRange_I = Range(addrRC_I, addrRTC_I)
                    Set ValidationRange_J = Range(addrRC_J, RateTypeColumn & Jstr)
                    
                    
                    count1 = Range(addrRC_I, addrRTC_I).Count
                    
                    For K = 1 To count1
                    
                        If Trim(ValidationRange_I(1, K).Value) <> Trim(ValidationRange_J(1, K).Value) Then
                           Exit For '--- reg - avoid single line if's because the debugger can not evaluate them
                        End If
                        
                    Next K
                 
                    If (K > count1) Then
                    
                        If ((DefaultExecutionArray(I) = "Y") And _
                            (DefaultExecutionArray(J) = "Y")) Then
                                
                            Call SetInvalidRange(Range(addrRC_I, addrDEC_I))
                            Call SetInvalidRange(Range(addrRC_J, addr3J))
                            Call AddValidationComment(DefaultExecutionTypeColumn, I, msg3a)
                            Call AddValidationComment(DefaultExecutionTypeColumn, J, msg3a)
                            
                         ElseIf ((DefaultExecutionArray(I) = "") And _
                                 (DefaultExecutionArray(J) = "")) Then
                                    
                            rng3J.Value = ""
                            rng3J.Interior.ColorIndex = ValidColorIndexValue
                            rng3J.ClearComments
            
                            If rngDEC_I.Value = "Y" Then
            
                                rngDEC_I.Interior.ColorIndex = WarningColorIndexValue
                                Call WriteToErrorLog(DefaultExecutionTypeColumn, I, "Warning - " + msg3b)
                                
                                rngDEC_I.Value = ""
                   
                                If rngDEC_I.Comment Is Nothing Then
                                    rngDEC_I.AddComment msg3b
                                Else
                                    rngDEC_I.ClearComments
                                    rngDEC_I.AddComment msg3b
                                End If
                            
                            End If
                   
                            ElseIf ((DefaultExecutionArray(I) = "Y") And _
                                    (DefaultExecutionArray(J) = "")) Then
                                
                            rng3J.Value = ""
                            rng3J.Interior.ColorIndex = ValidColorIndexValue
                            rng3J.ClearComments
            
                            For K = ErrorLogFirstRow To ErrorLogFirstRow + ErrorLogRowCounter
                            
                                If ((ErrorLog.Range(ErrorLogRowNumberColumn & K).Value = "Row " & Jstr) And _
                                    (ErrorLog.Range(ErrorLogMessageColumn & K).Value = "Warning - " + msg3b)) Then
                                
                                    ErrorLog.Rows(K).Delete
                                    ErrorLogRowCounter = ErrorLogRowCounter - 1
                                
                                End If
                                
                            Next K
                        
                    ElseIf ((DefaultExecutionArray(I) = "") And _
                            (DefaultExecutionArray(J) = "Y")) Then
                            
                        rngDEC_I.Value = ""
                        rngDEC_I.Interior.ColorIndex = ValidColorIndexValue
                        rngDEC_I.ClearComments
        
                        For K = ErrorLogFirstRow To ErrorLogFirstRow + ErrorLogRowCounter
                        
                            If ((ErrorLog.Range(ErrorLogRowNumberColumn & K).Value = "Row " & Istr) And _
                                (ErrorLog.Range(ErrorLogMessageColumn & K).Value = "Warning - " + msg3b)) Then
                            
                                ErrorLog.Rows(K).Delete
                                ErrorLogRowCounter = ErrorLogRowCounter - 1
                            
                            End If
                            
                        Next K
           
                        '*** 5/7/14
                        
                    End If
        
                End If
                
                lastActiveColumn = AddOnAmountColumn
                
                Set ValidationRange_I = Range(addrRC_I, ExecutionTypeColumn & Istr)
                Set ValidationRange_J = Range(addrRC_J, ExecutionTypeColumn & Jstr)
                
                ct1 = Range(addrRC_I, ExecutionTypeColumn & Istr).Count
                                
                For K = 1 To ct1
                
                    If (Trim(ValidationRange_I(1, K).Value) <> Trim(ValidationRange_J(1, K).Value)) Then
                       Exit For
                    End If
            
                Next K
                
                ct2 = Range(addrRC_I, ExecutionTypeColumn & Istr).Count
            
                If (K > ct2) Then
                    'MsgBox "DUPLICATE ROW - TEST", vbCritical '--- @@@@ TEST CODE - REG
                    Call SetInvalidRange(Range(addrRC_I, ExecutionTypeColumn & Istr))
                    Call SetInvalidRange(Range(addrRC_J, ExecutionTypeColumn & Jstr))
                    
                    Call AddValidationComment(RegionColumn, I, "Duplicate Row")
                    Call AddValidationComment(RegionColumn, J, "Duplicate Row")
                    
                    Exit For
            
                End If
            
                Set ValidationRange_J = Nothing
        
            Next J
            '=========================== INNER J LOOP ENDS
            
            '=========================== EMOD 3.5 TO SEPARATE VOL DISC AND BAND DISC -
            
            
            
         '======================================== VOL DISC LINE 1 OF GROUP - TIER IS 1
        If Rate_Type = VolumeDiscountRateType Then
         '========================================
         
         '------------------ VOL  DISC - AFTER 1ST LINE ADDED, ONLY FOR THE 1ST LINE IS Rate_Type DEFINED
            
            
          errorStage(3) = "Rate type 1st line = " + Rate_Type
       
            lastActiveColumn = TierDefinedBasedColumn
            
            Set rngDTC_I = Range(TierDefinedBasedColumn & VolumeDiscountStartRow)
            VolDisc_TierDefinedBased_I = Trim(rngDTC_I.Value)
             
            addrTC_I = TiersColumn & Istr
            Set rngVolDisc_TierNo_I = Range(addrTC_I)
            VolDisc_TierNo_I = rngVolDisc_TierNo_I.Value
             
            addrNAC_I = TierStartNumberAmountColumn & Istr
            Set rngVolDisc_TierStartNumber_I = Range(addrNAC_I)
            VolDisc_TierStartNumber_I = rngVolDisc_TierStartNumber_I.Value
                   
           
          
            addrVDAC_I = TierVolDiscRateColumn & Istr
            Set rngVolume_Disc_Rate_I = Range(addrVDAC_I)
            Volume_Disc_Rate_I = rngVolume_Disc_Rate_I.Value
          
            Set rngSTC_I = Range(TiersColumn & Istr)
            VolDisc_Tiers = rngSTC_I.Value
          
            Dim rngTC_VDSR As Range
            Set rngTC_VDSR = Range(TiersColumn & VolumeDiscountStartRow) '-- vol disc on start row
            Dim Tiers_VolDisc_StartRow As String
            Tiers_VolDisc_StartRow = rngTC_VDSR.Value
          
             Set rngTDC_I_VDAC_I = Range(TierDefinedBasedColumn & Istr, addrVDAC_I)
        
          '------------ TIER 1 VOL DISC
         
          '--- verify 1st we can convert to numeric the tier# - spaces give errors
                      
          '--- det default decimals formats
            rngVolDisc_TierNo_I.NumberFormat = Module1.decimalFormat0 '--integer
            rngVolume_Disc_Rate_I.NumberFormat = Module1.decimalFormat2 '--decimal
                      
                      
                      
             If VolDisc_TierNo_I = "" Then
                VolDisc_TierNo_I = "0"
             End If
             
             lastActiveColumn = TiersColumn
         
             If (VolDisc_TierNo_I <> FirstVolumeDiscountTier) Then
        
                    Call SetInvalidRange(rngTDC_I_VDAC_I)
                    Call AddValidationComment(TiersColumn, I, "Vol Disc - Invalid Tier - Must start with Tier# 1 (and no decimal)")
                   
             End If
            
            lastActiveColumn = TierDefinedBasedColumn
            
            If IsNumeric(VolDisc_TierNo_I) Then
            
            If (CLng(VolDisc_TierNo_I) = FirstVolumeDiscountTier) Then '-- we have correct Tier#1 and Rate type of Vol Disc
                
                VolumeDiscountStartRow = I
                 '--- important to save this
                
                    If CLng(VolDisc_TierNo_I) <> VolDisc_TierNo_I Then '-- IF IT'S AN INTEGER
                    
                        rngVolDisc_TierNo_I.NumberFormat = Module1.decimalFormat2 '---"General"
                        
                        Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                        Call AddValidationComment(TiersColumn, I, "Vol Disc - Tiers Must Be a Whole Numbers")
                    
                    End If
            End If
            
                lastActiveColumn = TierDefinedBasedColumn
            
                If Not IsNumeric(VolDisc_TierStartNumber_I) Then
        
                    Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                    Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Tier - a Non numeric value")
                    
                End If
                   
                If IsNumeric(VolDisc_TierStartNumber_I) And IsNumeric(VolDisc_TierStartNumber_I) Then
                If (VolDisc_TierNo_I = 1) And (rngVolDisc_TierStartNumber_I <> 1) Then
        
                    Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                    Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Start Number/Amount - Must be 1 for Tier#1")
                    
                End If
                End If
                
                 If IsNumeric(VolDisc_TierStartNumber_I) Then
                 
                    If (rngVolDisc_TierStartNumber_I.Value < 0) Then
         
                       Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                       Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Start Number/Amount - a negative number")
                    End If
                    
                End If
                
                     
                '--- REG - 2016 - 2/17/16 ELIN SPECS
                'a.|fffd|The Tier Start Value field for Volume discount should only allow whole numbers. No decimals are allowed.

                lastActiveColumn = TierStartNumberAmountColumn

                If IsNumeric(VolDisc_TierStartNumber_I) Then

                If CLng(rngVolDisc_TierStartNumber_I.Value) <> rngVolDisc_TierStartNumber_I.Value Then
                    
                    Call SetInvalidRange(rngTDC_I_VDAC_I)
                    Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Tier Start - decimal found - must be a whole number")
                    rngVolDisc_TierStartNumber_I.NumberFormat = decimalFormat2
                End If
                
                End If
                
                lastActiveColumn = TierVolDiscRateColumn
                
                If Not IsNumericNonNegative(Volume_Disc_Rate_I, False) Then
                 
                    rngVolume_Disc_Rate_I.NumberFormat = decimalFormat2
                    Call SetInvalidRange(rngTDC_I_VDAC_I)
                    Call AddValidationComment(TierVolDiscRateColumn, I, "Vol Disc Amount" + stdMsgIsNumericNonNegative)
                    
                End If
                
                If (Volume_Disc_Rate_I <> "" And Volume_Disc_Rate_I > max5digits) Then
                    Call SetInvalidRange(rngVolume_Disc_Rate_I)
                    Call AddValidationComment(TierVolDiscRateColumn, I, "Vol Disc - can not exceed " + CStr(max5digits) + "  (5 digits)")
                 End If
                
'                Set ValidationRange_I = rngTDC_I_VDAC_I
'                Validation_I_Count = ValidationRange_I.Count
'
'
'                For K = 1 To Validation_I_Count
'
'                    If Trim(ValidationRange_I(1, K).Value) = "" Then
'                       Exit For
'                    End If
'
'                Next K
'
'                Const msgMVDV = "One or More Missing Volume Discount Values"
'
'                If (K <= Validation_I_Count) Then
'
'                    Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
'                    Call AddValidationComment(TiersColumn, I, msgMVDV)
'                    Call AddValidationComment(TierDefinedBasedColumn, I, msgMVDV)
'                    Call AddValidationComment(TierApplyToColumn, I, msgMVDV)
'                    Call AddValidationComment(TiersColumn, I, msgMVDV)
'                    Call AddValidationComment(TierStartNumberAmountColumn, I, msgMVDV)
'                    Call AddValidationComment(TierVolDiscRateColumn, I, msgMVDV)
'
'                End If
               
              
             End If '--- valid tier
             
            End If '--- vol disc
            
            
            '========================================
            If Rate_Type = BandingDiscountRateType Then '-- '------------------ BANDING -  1ST LINE
            '========================================
             
            'fields: Apply   Band Value Type Band #  Start   End Rate Type   Rate
             
            errorStage(3) = "Rate type 1st line = " + Rate_Type
              
            lastActiveColumn = BandApplyColumn
              
            'TierDefinedBasedColumn = BandApplyColumn error
              
            Set rngBA_I = Range(Module1.BandApplyColumn & Istr)
            Bnd_Apply_I = Trim(rngBA_I.Value)
            
            Set rngBRATE_I = Range(Module1.BandRateColumn & Istr)
            Bnd_RATE_I = rngBRATE_I.Value
            
            Set rngBandingRow = Range(rngBA_I.Address, rngBRATE_I.Address)

          
            
            '--- BAND VALUE TYPE
            
            Set rngBVT_I = Range(Module1.BandValueTypeColumn & Istr)
            Bnd_Value_Type_I = Trim(rngBVT_I.Value)
            
            '--- save when the lines are blank up to numbers
            Bnd_Value_Type_Saved = Bnd_Value_Type_I
            
            '--- BAND NUMBER (NO)
         
            Set rngBnd_TierNo_I = Range(Module1.BandTierNoColumn & Istr)
            Bnd_TierNo_I = rngBnd_TierNo_I.Value
            
            '--- BAND START/END VALUES FOR CURRENT ROW I
            
            Set rngBnd_START_No_I = Range(Module1.BandStartColumn & Istr)
            Bnd_START_No_I = rngBnd_START_No_I.Value
            
           
            Set rngBnd_END_No_I = Range(Module1.BandEndColumn & Istr)
            Bnd_END_No_I = rngBnd_END_No_I.Value
          
             '--- BAND RATE TYPE
            
            Set rngBRT_I = Range(Module1.BandRateTypeColumn & Istr)
            Bnd_Rate_Type_I = rngBRT_I.Value
            
            '-- emod 3.5 - 3/31/16-check rate limit per band rate type,need for tiers>1
            Bnd_Rate_Type_Saved = Bnd_Rate_Type_I
             '--- BAND RATE
                       
            'Public Const BandStartEndIntegerTypes As String = "Number of Contracts, BPS" -- THESE MUST HAVE INTEGER START/END
            If InStr(BandStartEndIntegerTypes, Bnd_Value_Type_I) > 0 Then
               
               bandingStartNumber = 1
              Else
               bandingStartNumber = 0
            End If
            
    
            If (bandingStartNumber = 0) Then
              
                   rngBnd_START_No_I.NumberFormat = Module1.decimalFormat2 '--decimal
                   rngBnd_END_No_I.NumberFormat = Module1.decimalFormat2 '--decimal
                  
            End If
            If (bandingStartNumber = 1) Then
              
                   rngBnd_START_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                   rngBnd_END_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                  
            End If
             
            lastActiveColumn = BandRateColumn
            
            '--- keep band value type for messages
            Bnd_Value_Type_Saved = Bnd_Value_Type_I
            
            If Not IsNumericNonNegative(Bnd_RATE_I, False) Then
                  Call SetInvalidRange(rngBRATE_I)
                  Call AddValidationComment(Module1.BandRateColumn, I, "Band RATE" + stdMsgIsNumericNonNegative)
            End If
            
            lastActiveColumn = BandStartColumn
            
            If IsNumeric(Bnd_START_No_I) And Bnd_START_No_I <> "" Then
            
              If (CLng(Bnd_START_No_I) < 0) Then
                  Call SetInvalidRange(rngBnd_START_No_I)
                  Call AddValidationComment(Module1.BandStartColumn, I, "Band START" + stdMsgIsNumericNonNegative)
               End If
               
            End If
            
             lastActiveColumn = BandEndColumn
            
             If Not IsNumericNonNegative(Bnd_END_No_I, False) Then
                  Call SetInvalidRange(rngBnd_END_No_I)
                  Call AddValidationComment(Module1.BandEndColumn, I, "Band END" + stdMsgIsNumericNonNegative)
            End If
            
            lastActiveColumn = BandStartColumn
                   
            If IsNumeric(Bnd_START_No_I) And Bnd_START_No_I <> "" And (bandingStartNumber = 1) Then
                
                    '--- reg - 3/2/16 - band must start with a 1
                    If Bnd_START_No_I <> 1 Then
                    
                        rngBnd_START_No_I.NumberFormat = "General"
                        
                         Call SetInvalidRange(rngBnd_START_No_I)
                         Call AddValidationComment(Module1.BandStartColumn, I, "Band START invalid - Must be 1 for Band Tier# 1 " + Bnd_Value_Type_Saved)
                        
                     End If
                    
            End If
            
            lastActiveColumn = BandStartColumn
            
            If (bandingStartNumber = 1) Then  '--- MATCHES BPS ETC - INTEGER TYPES
                          
                'SET INT FORMAT INITIALLY
                rngBnd_START_No_I.NumberFormat = Module1.decimalFormat0 '--INT
                rngBnd_END_No_I.NumberFormat = Module1.decimalFormat0 '--INT
                 
                          
                If IsNumeric(Bnd_START_No_I) And Bnd_START_No_I <> "" Then
                    
                        '--- REMOVED 11/30/15 - PER DAVIDS FINDING
                        If CLng(Bnd_START_No_I) <> Bnd_START_No_I Then '-- IF IT'S AN INTEGER
                        
                            rngBnd_START_No_I.NumberFormat = "General"
                            
                             Call SetInvalidRange(rngBnd_START_No_I)
                             Call AddValidationComment(Module1.BandStartColumn, I, "Band START invalid - must be a whole number for Band type: " + Bnd_Value_Type_Saved)
                            
                         End If
                        
                End If
                   
                lastActiveColumn = BandEndColumn
                   
                If IsNumeric(Bnd_END_No_I) Then  '-- BPS ETC
                    
                        If CLng(Bnd_END_No_I) <> Bnd_END_No_I Then '-- IF IT'S not AN INTEGER
                        
                           rngBnd_END_No_I.NumberFormat = "General"
                            
                             Call SetInvalidRange(rngBnd_END_No_I)
                             Call AddValidationComment(Module1.BandEndColumn, I, "Band END - invalid - must be a whole number for Band type: " + Bnd_Value_Type_Saved)
                        End If
                        
                End If
            
           End If
           
           lastActiveColumn = BandStartColumn
           
           If (bandingStartNumber = 0) Then  '--- NO MATCHES FOR BPS ETC - NON-INTEGER TYPES
                          
                'SET INT FORMAT INITIALLY
                rngBnd_START_No_I.NumberFormat = Module1.decimalFormat2 '--INT
                rngBnd_END_No_I.NumberFormat = Module1.decimalFormat2 '--INT
                 
                          
                If Not IsNumeric(Bnd_START_No_I) Then
                    
                     Call SetInvalidRange(rngBnd_START_No_I)
                     Call AddValidationComment(Module1.BandStartColumn, I, "Band START invalid - must be A NUMERIC value")
        
                End If
                   
                lastActiveColumn = BandEndColumn
                   
                If Not IsNumeric(Bnd_END_No_I) Then  '-- BPS ETC
            
                     Call SetInvalidRange(rngBnd_END_No_I)
                     Call AddValidationComment(Module1.BandEndColumn, I, "Band END - invalid - must be a NUMERIC value")
                
                End If
            
           End If
                      
             ' -- the whole band apply range
           
             
              If IsNumeric(Bnd_START_No_I) And IsNumeric(Bnd_END_No_I) Then
                
                    If (Bnd_START_No_I > Bnd_END_No_I) Then  '-- 3/29/16-Graham - allow equal
                      
                         Call SetInvalidRange(rngBnd_START_No_I)
                         Call AddValidationComment(Module1.BandStartColumn, I, "Invalid - Band START > Band END")
                         
                         Call SetInvalidRange(rngBnd_END_No_I)
                         Call AddValidationComment(Module1.BandEndColumn, I, "Invalid - Band START > Band END")
                         
                    End If
                    
              End If
               
            '------------ TIER 1 BAND DISC (HAVE THE FULL LINE FILLED)
            
             lastActiveColumn = BandTierNoColumn
                    
             If Not IsNumeric(rngBnd_TierNo_I.Value) Then
               
                 Call SetInvalidRange(rngBnd_TierNo_I)
                 Call AddValidationComment(BandTierNoColumn, I, "Band Tier# - Invalid band Tier - Must be a NUMERIC value")
                
             End If
         
             If IsNumeric(rngBnd_TierNo_I.Value) And (rngBnd_TierNo_I.Value <> "") Then
         
             If (rngBnd_TierNo_I.Value < 0) Then
    
                 Call SetInvalidRange(Range(BandTierNoColumn & Istr, rngBnd_TierNo_I))
                 Call AddValidationComment(BandTierNoColumn, I, "Band Tier# - Invalid negative number")
                
              End If
              
              End If
              
              If (Not IsNumeric(rngBnd_TierNo_I.Value)) Then
    
                 Call SetInvalidRange(Range(BandTierNoColumn & Istr, rngBnd_TierNo_I))
                 Call AddValidationComment(BandTierNoColumn, I, "Band Tier# - Invalid non-numeric value")
                
              End If
         
               
              If IsNumeric(Bnd_TierNo_I) And Bnd_TierNo_I <> "" Then
                
                    If CLng(Bnd_TierNo_I) <> Bnd_TierNo_I Then
                    
                        rngBnd_TierNo_I.NumberFormat = "General"
                        
                        Call SetInvalidRange(Range(BandTierNoColumn & Istr, rngBnd_TierNo_I))
                        Call AddValidationComment(BandTierNoColumn, I, "Band Tier# - Tier Must Be a Whole Number")
                    
                    End If
                    
              End If
                    
                    
             If (Rate_Type = BandingDiscountRateType) Then
                BandingDiscountStartRow = I '--SAVE 1ST LINE FOR BAND
             End If
              
             '--- 3/12/16 - reg - Elin found bug where the validation in banding 1st row depends on the band type (integer vs dec)
              
'             If (InStr(BandStartEndIntegerTypes, Bnd_Value_Type_I) = 0) And (Bnd_TierNo_I <> 0) And (BandingDiscountStartRow = I) Then      '--- THIS IS THE 1ST LINE OF THIS BAND,
'
'                        rngBnd_TierNo_I.NumberFormat = "General"
'
'
'                        Call SetInvalidRange(Range(BandTierNoColumn & Istr, rngBnd_TierNo_I))
'                        Call AddValidationComment(BandTierNoColumn, I, "Band Tier# - FIRST Tier# Must be 0 for Band Type: " + Bnd_Value_Type_Saved)
''
'              End If
              If (Bnd_TierNo_I <> 1) And (BandingDiscountStartRow = I) Then       '--- THIS IS THE 1ST LINE OF THIS BAND,
                        
                        rngBnd_TierNo_I.NumberFormat = "General"
                        
                       
                        Call SetInvalidRange(Range(BandTierNoColumn & Istr, rngBnd_TierNo_I))
                        Call AddValidationComment(BandTierNoColumn, I, "Band Tier# - FIRST Tier# Must be 1") ' for Band Type: " + Bnd_Value_Type_Saved)
'
              End If
              
            '--- 3/29/16-reg - Graham adds conditions too for band/vol disc
            '--- 3/29/16-reg-new checks for band amt - max value per list of rate types - Graham markit
            
            '--- note: since the 1st rate type is Band - then we use the band rate type for this validation
            
            If (Rate_Type = BandingDiscountRateType) And IsNumeric(Bnd_RATE_I) And (Bnd_RATE_I <> "") And (Bnd_Rate_Type_I <> "") Then
                
                If InStr(Module1.maxRateAmtList999, Bnd_Rate_Type_I) > 0 And (Bnd_RATE_I > max3digits) Then
                    
                    Call SetInvalidRange(rngBRATE_I)
                    Call AddValidationComment(BandRateColumn, I, "Invalid Band Rate - exceeded Max value of " + CStr(max3digits) + " (3 digits) for Band rate type: " + Bnd_Rate_Type_I)
                
                End If
                
                 If InStr(Module1.maxRateAmtList99999, Bnd_Rate_Type_I) > 0 And (Bnd_RATE_I > max5digits) Then
                    
                    Call SetInvalidRange(rngBRATE_I)
                    Call AddValidationComment(BandRateColumn, I, "Invalid Band Rate - exceeded Max value of " + CStr(max5digits) + "  (5 digits) for Band rate type: " + Bnd_Rate_Type_I)
                
                End If
            
            End If
              
             
'
'              Set ValidationRange_I = rngBandingRow
'
'              Validation_I_Count = ValidationRange_I.Count
'
'              For K = 1 To Validation_I_Count
'                  If IsEmpty(ValidationRange_I(1, K).Value) Then
'                     Exit For
'                  End If
'              Next K
'
'              Const msgMBDV = "One or More Missing Banding Discount Values"
'
'
'
'              If (K <= Validation_I_Count) Then
'                  Call SetInvalidRange(Range(Module1.BandApplyColumn & Istr, rngBRATE_I))
'
'                  Call AddValidationComment(Module1.BandApplyColumn, I, msgMBDV)
'                  Call AddValidationComment(Module1.BandValueTypeColumn, I, msgMBDV)
'                  Call AddValidationComment(Module1.BandTierNoColumn, I, msgMBDV)
'                  Call AddValidationComment(Module1.BandStartColumn, I, msgMBDV)
'                  Call AddValidationComment(Module1.BandEndColumn, I, msgMBDV)
'                  Call AddValidationComment(Module1.BandRateColumn, I, msgMBDV)
'              End If
                 
              'End If
                              
                      
          End If '--- band disc if - 1st line
            
      '===============
       Else '---------- Volume discount schedule validations for rows 2 thru N of volume discount schedule ??? - EMOD 3.5 ADDED BANDING
      '===============
        
         '--- EMOD 3.5 SEPARATE VOLD DISC AND BANDING
        
        
        If lastRateType = VolumeDiscountRateType Then '------------------ VOL DISC - AFTER 1ST LINE
        '======================================
        
        '---------------------------------------------------------------- HERE IS AFTER THE 1ST LINE for vol disc or band (Blank for other fields)
        
        
            '--- Vol Disc - need to repeat after Else for other I values
                   
            '--- vol disc fields: Based On,    Apply To,    Tier Value Type, Tier #,  Tier Start Value,    Rate
       
            
            Set rngDTC_I = Range(TierDefinedBasedColumn & VolumeDiscountStartRow)
            VolDisc_TierDefinedBased_I = Trim(rngDTC_I.Value)
             
            addrTC_I = TiersColumn & Istr
            Set rngVolDisc_TierNo_I = Range(addrTC_I)
            VolDisc_TierNo_I = rngVolDisc_TierNo_I.Value
             
            addrNAC_I = TierStartNumberAmountColumn & Istr
            Set rngVolDisc_TierStartNumber_I = Range(addrNAC_I)
            VolDisc_TierStartNumber_I = rngVolDisc_TierStartNumber_I.Value
                   
            Set rngTDC_I_VDAC_I = Range(TierDefinedBasedColumn & Istr, addrVDAC_I)
          
            addrVDAC_I = TierVolDiscRateColumn & Istr
            Set rngVolume_Disc_Rate_I = Range(addrVDAC_I)
            Volume_Disc_Rate_I = rngVolume_Disc_Rate_I.Value
          
            Set rngSTC_I = Range(TiersColumn & Istr)
            VolDisc_Tiers = rngSTC_I.Value
          
         
            Set rngTC_VDSR = Range(TiersColumn & VolumeDiscountStartRow) '-- vol disc on start row
            Tiers_VolDisc_StartRow = rngTC_VDSR.Value
            
            '--- det default decimals formats
            rngVolDisc_TierNo_I.NumberFormat = Module1.decimalFormat0 '--integer
            rngVolDisc_TierStartNumber_I.NumberFormat = Module1.decimalFormat0 '--integer
            rngVolume_Disc_Rate_I.NumberFormat = Module1.decimalFormat2 '--decimal
            
            errorStage(3) = "Rate type - other lines: " + Istr + " = " + lastRateType
        
            lastActiveColumn = TiersColumn
            
            If (((VolDisc_TierNo_I <> "") And _
                 (Range(TiersColumn & I).Value <> FirstVolumeDiscountTier)) Or _
                 (VolDisc_TierStartNumber_I <> "") Or _
                 (Volume_Disc_Rate_I <> "")) Then
                
                'MsgBox "Vol Disc Not First Row - Row " & Istr & " VolumeDiscountStartRow = " & VolumeDiscountStartRow '-- remove release 3.5
                
                    
                    
                    
                    Dim VolDisc_TierNo_I_1 As String
                    VolDisc_TierNo_I_1 = Trim(Range(TiersColumn & (I - 1)).Value)
                        
                    If ((IsNumeric(VolDisc_TierNo_I)) And (IsNumeric(VolDisc_TierNo_I_1))) Then
                    
                        If VolDisc_TierNo_I <> (VolDisc_TierNo_I_1 + 1) Then
                    
                            Call SetInvalidRange(rngTDC_I_VDAC_I)
                            Call AddValidationComment(TiersColumn, I, "Vol Disc - Tiers Must Be in Ascending Sequential Order (plus 1)")
                            
                        End If
                       
                    End If
                    
                    lastActiveColumn = TiersColumn
                    
                    If IsNumeric(VolDisc_TierNo_I) Then
                
                        If CLng(VolDisc_TierNo_I) <> VolDisc_TierNo_I Then
                    
                            rngVolDisc_TierNo_I.NumberFormat = "General"
                        
                            Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                            Call AddValidationComment(TiersColumn, I, "Vol Disc - Tier Must Be a Whole Number")
                    
                        End If
                    
                    End If
                    
                    
                    If Not IsNumeric(VolDisc_TierNo_I) Then
                
                            Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                            Call AddValidationComment(TiersColumn, I, "Vol Disc - NON-NUMERIC Value - Tier Must Be a Whole Number")
                                      
                    End If
                    
                     '--- REG - 2016 - 2/17/16 ELIN SPECS
                     'a.|fffd|The Tier Start Value field for Volume discount should only allow whole numbers. No decimals are allowed.
                  
                    lastActiveColumn = TierStartNumberAmountColumn
                  
                    If CLng(rngVolDisc_TierStartNumber_I.Value) <> rngVolDisc_TierStartNumber_I.Value Then
                        
                        Call SetInvalidRange(rngTDC_I_VDAC_I)
                        Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Tier Start - decimal found - must be a whole number")
                        rngTDC_I_VDAC_I.NumberFormat = Module1.decimalFormat2
                    End If
                    
                    
                    '-- COMPARES THE 1ST LINE STATIC ELEMENTS VALUE WITH ANY (OPTIONAL) SUBSEQUENT SELECTIONS - ALL MUST BE THE SAME OR EMPTY
                                 
                    Const msgIncValue = "Vol Disc - Inconsistent Value"
                                                   
                       lastActiveColumn = TierDefinedBasedColumn
                                                   
                       If (((Trim(Range(TierDefinedBasedColumn & I).Value) <> "") And _
                         (Range(TierDefinedBasedColumn & I).Value <> _
                          Range(TierDefinedBasedColumn & VolumeDiscountStartRow).Value)) Or _
                        ((Trim(Range(TierApplyToColumn & I).Value) <> "") And _
                         (Range(TierApplyToColumn & I).Value <> _
                          Range(TierApplyToColumn & VolumeDiscountStartRow).Value)) Or _
                        ((Trim(Range(TierValueTypeColumn & I).Value) <> "") And _
                         (Range(TierValueTypeColumn & I).Value <> _
                          Range(TierValueTypeColumn & VolumeDiscountStartRow).Value))) Then
                                               
                        Call SetInvalidRange(rngTDC_I_VDAC_I)
                        
                        Call AddValidationComment(TierDefinedBasedColumn, I, msgIncValue)
                        Call AddValidationComment(TierApplyToColumn, I, msgIncValue)
                                               
                        '*** 11/20/13
                        
                    End If
                    
                    lastActiveColumn = TierStartNumberAmountColumn
                    
                    If (Not IsNumeric(VolDisc_TierStartNumber_I)) Then
                       'MsgBox "TEST1"
                       Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                       Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid (NON NUMERIC) Start Number/Amount.")
                       'Exit Sub
                    End If
                                          
                    '-- IF IT'S NOT NUMERIC WE GET CONV ERROR WITH CDBL
                                       
                    If IsNumeric(VolDisc_TierStartNumber_I) Then
                    
                    If (Not IsEmpty(VolDisc_TierStartNumber_I)) And _
                        (CDbl(VolDisc_TierStartNumber_I) < 0) Or _
                        (CDbl(VolDisc_TierStartNumber_I) <= (Range(TierStartNumberAmountColumn & (I - 1)).Value)) Then
                        
                        Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                        Call SetInvalidRange(Range(TierDefinedBasedColumn & (I - 1), TierVolDiscRateColumn & (I - 1)))
                        
                        Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Tier Start Value")
                        Call AddValidationComment(TierStartNumberAmountColumn, I - 1, "Vol Disc - Invalid Tier Start Value")
                        
                    End If
                    
                   End If
                    
                    'emod 3.4
                   'Public Const VolumeDiscountStartTypeAmountValue As String = "Amount"
                   'Public Const VolumeDiscountStartTypeNumberValue As String = "Number"
                   'emod 3.5
                   'Public Const VolumeDiscountStartTypeAmountValue As String = "Number of Contracts"
                   'Public Const VolumeDiscountStartTypeNumberValue As String = "Number of Trades"
                  
                   '--- assume for vol disc tier number and tier start num are integers no dec point - for all vol disc types

                  
                    If IsNumeric(VolDisc_TierStartNumber_I) Then
        
                         If CLng(Range(TierStartNumberAmountColumn & I).Value) <> Range(TierStartNumberAmountColumn & I).Value Then

                             rngVolDisc_TierStartNumber_I.NumberFormat = decimalFormat2
                            
                            Call SetInvalidRange(rngVolDisc_TierNo_I)
                            Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Values for Start Type Number Must Be a Whole Numbers")
                        
                        End If
                        
                        If ((Tiers_VolDisc_StartRow = VolumeDiscountStartTypeNumberValue) And _
                            (InStr(VolDisc_TierStartNumber_I, DecimalSeparator) = 0) And _
                            (Len(VolDisc_TierStartNumber_I) > StartTypeNumberNumberOfIntegerPlaces)) Then
                    
                            rngVolDisc_TierStartNumber_I.NumberFormat = decimalFormat2
                            
                            Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                            Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc - Invalid Start Type Number")
                            
                        End If
                        
                    End If
                                            
                     lastActiveColumn = TierStartNumberAmountColumn
                         
                   If (Not IsNumericNonNegative(VolDisc_TierStartNumber_I, False)) And (Tiers_VolDisc_StartRow = VolumeDiscountStartTypeAmountValue) Then
                   
                    rngVolDisc_TierStartNumber_I.NumberFormat = decimalFormat2
                    
                    Call SetInvalidRange(rngTDC_I_VDAC_I)
                    Call AddValidationComment(TierStartNumberAmountColumn, I, "Vol Disc Tier" + stdMsgIsNumericNonNegative + ", or Invalid Start Type Amount for: " + VolumeDiscountStartTypeAmountValue)
           
                   End If
                        
                   lastActiveColumn = TierVolDiscRateColumn
                
                   If Not IsNumericNonNegative(Volume_Disc_Rate_I, False) Then
                   
                    rngVolume_Disc_Rate_I.NumberFormat = decimalFormat2
                    Call SetInvalidRange(Range(TierDefinedBasedColumn & Istr, addrVDAC_I))
                    Call AddValidationComment(TierVolDiscRateColumn, I, "Vol Disc Rate" + stdMsgIsNumericNonNegative)
                    
                    
                   End If
                
                    Set ValidationRange_I = Range(addrFC_I, AmountColumn & Istr)
                    Validation_I_Count = ValidationRange_I.Count
                    
                    For K = 1 To Validation_I_Count
        
                        If Trim(ValidationRange_I(1, K).Value) <> "" Then
                           Exit For
                        End If
                        
                    Next K
                
                    If (K <= Validation_I_Count) Then
                    
                        Call SetInvalidRange(ValidationRange_I)
                        Call AddValidationComment(FirstColumn, I, "Invalid with Volume Discount Amount")
                        
                    End If
                    
                    '--- 3/29/16-Graham - vol disc rate not over 5 digits
            
                 If (rngVolume_Disc_Rate_I <> "" And rngVolume_Disc_Rate_I > max5digits) Then
                    Call SetInvalidRange(rngVolume_Disc_Rate_I)
                    Call AddValidationComment(TierVolDiscRateColumn, I, "Vol Disc - can not exceed " + CStr(max5digits) + "  (5 digits) for vol disc rate")
                 End If
                    
                End If ' VOL DISC TIER 1 OR ELSE 2 OR MORE
         
                  
            End If '--- VOL DISC FIRST ROW OR ELSE
    
          
      '--- BANDING VALIDATIONS
      
      '========================================
      If lastRateType = BandingDiscountRateType Then '------------------ BAND DISC - AFTER 1ST LINE
      '========================================
         '--- EMOD 3.5 NEW FIELDS AND CHECKS
                  
            Set rngBA_I = Range(Module1.BandApplyColumn & Istr)
            Bnd_Apply_I = Trim(rngBA_I.Value)
            
                 '--- BAND RATE
           
            Set rngBRATE_I = Range(Module1.BandRateColumn & Istr)
            Bnd_RATE_I = rngBRATE_I.Value
            
            Set rngBandingRow2 = Range(rngBA_I.Address, rngBRATE_I.Address)
                  
            '--- BAND VALUE TYPE
            
            Set rngBVT_I = Range(Module1.BandValueTypeColumn & Istr)
            Bnd_Value_Type_I = Trim(rngBVT_I.Value)
            
            '--- BAND NUMBER (NO)
         
            Set rngBnd_TierNo_I = Range(Module1.BandTierNoColumn & Istr)
            Bnd_TierNo_I = rngBnd_TierNo_I.Value
            
            '--- BAND START/END VALUES FOR CURRENT ROW I
            
            Set rngBnd_START_No_I = Range(Module1.BandStartColumn & Istr)
            Bnd_START_No_I = rngBnd_START_No_I.Value
            
           
            Set rngBnd_END_No_I = Range(Module1.BandEndColumn & Istr)
            Bnd_END_No_I = rngBnd_END_No_I.Value
          
          '--- BAND START/END VALUES FOR PREV ROW I-1 '-- recall - this is after the 1st line - these are defined
         
            Set rngBnd_START_No_I_1 = Range(Module1.BandStartColumn & (I - 1)) '-- prev value
            Bnd_START_No_I_1 = rngBnd_START_No_I_1.Value
            
           
            Set rngBnd_END_No_I_1 = Range(Module1.BandEndColumn & (I - 1)) '-- prev value
            Bnd_END_No_I_1 = rngBnd_END_No_I_1.Value
          
             '--- BAND RATE TYPE
            
            Set rngBRT_I = Range(Module1.BandRateTypeColumn & Istr)
            Bnd_Rate_Type_I = rngBRT_I.Value
           
           
           '--- CHECKS - VALID NUMERIC AND NON-NEGATIVE
        
             lastActiveColumn = BandTierNoColumn
        
             If Not IsNumericNonNegative(Bnd_TierNo_I, False) Then
                  Call SetInvalidRange(rngBnd_TierNo_I)
                  Call AddValidationComment(Module1.BandTierNoColumn, I, "Band#" + stdMsgIsNumericNonNegative)
             End If
        
             lastActiveColumn = BandStartColumn
            
             If Not IsNumericNonNegative(Bnd_START_No_I, False) Then
                  Call SetInvalidRange(rngBnd_START_No_I)
                  Call AddValidationComment(Module1.BandStartColumn, I, "Band START" + stdMsgIsNumericNonNegative)
             End If
             
             lastActiveColumn = BandEndColumn
            
             If Not IsNumericNonNegative(Bnd_END_No_I, False) Then
                  Call SetInvalidRange(rngBnd_END_No_I)
                  Call AddValidationComment(Module1.BandEndColumn, I, "Band END" + stdMsgIsNumericNonNegative)
             End If
             
              lastActiveColumn = BandRateColumn
            
             If Not IsNumericNonNegative(Bnd_RATE_I, False) Then
                  Call SetInvalidRange(rngBRATE_I)
                  Call AddValidationComment(Module1.BandRateColumn, I, "Band RATE" + stdMsgIsNumericNonNegative)
             End If
            
             errorStage(3) = "Rate type other lines = " + lastRateType
        
            '------------ TIER 2-n BAND DISC
                    
             '--- INTEGER CHECKS
             
             lastActiveColumn = BandTierNoColumn
               
             If IsNumeric(Bnd_TierNo_I) And Bnd_TierNo_I <> "" Then
                
                    If (CLng(Bnd_TierNo_I) <> Bnd_TierNo_I) Then '-- IF IT'S AN INTEGER
                    
                        rngBnd_TierNo_I.NumberFormat = "General"
                        
                        Call SetInvalidRange(Range(BandTierNoColumn & Istr, rngBnd_TierNo_I))
                        Call AddValidationComment(BandTierNoColumn, I, "Invalid Band Tier# - Must Be a Whole Number")
                    
                    End If
                    
             End If
           
              '--- SPECIAL CASES - THE START/END VALUES WHEN 'BAND VALUE TYPE' IS OF INTEGER TYPE (BPS, NO OF CONTRACTS ETC)
              
              lastActiveColumn = BandStartColumn
             
              
               
                    If IsNumeric(Bnd_START_No_I) And (bandingStartNumber = 1) Then
                      
                           '--- REMOVED 11/30/15 - PER DAVIDS FINDING
                          If CLng(Bnd_START_No_I) <> Bnd_START_No_I Then '-- IF IT'S AN INTEGER
                          
                              rngBnd_START_No_I.NumberFormat = "General"
                              
                               Call SetInvalidRange(rngBnd_START_No_I)
                               Call AddValidationComment(Module1.BandStartColumn, I, "Band START invalid - must be a whole number  for Band type: " + Bnd_Value_Type_I)
                          
                             Else
                                rngBnd_START_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                          
                          End If
                          
                          
                    End If
                    
                                      
                    
                    If (bandingStartNumber = 0) Then
                      
                           rngBnd_START_No_I.NumberFormat = Module1.decimalFormat2 '--decimal
                           rngBnd_END_No_I.NumberFormat = Module1.decimalFormat2 '--decimal
                          
                    End If
                    If (bandingStartNumber = 1) Then
                      
                           rngBnd_START_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                           rngBnd_END_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                          
                    End If
                     
                    lastActiveColumn = BandEndColumn
                     
                     
                    If IsNumeric(Bnd_END_No_I) And (bandingStartNumber = 1) Then
                      
                          If CLng(Bnd_END_No_I) <> Bnd_END_No_I Then '-- IF IT'S AN INTEGER
                          
                              rngBnd_END_No_I.NumberFormat = "General"
                              
                               Call SetInvalidRange(rngBnd_END_No_I)
                               Call AddValidationComment(Module1.BandEndColumn, I, "Band END - invalid - must be a whole number")
                                                    
                          End If
                          
                    End If
                 
                
               '--- INTEGER/FLOAT CONTINUITY CHECKS - BAND START AND END SPECIFIC
               
               '--- SPECIAL CASES - THE START/END VALUES WHEN 'BAND VALUE TYPE' IS OF INTEGER TYPE (BPS, NO OF CONTRACTS ETC)
               
               lastActiveColumn = BandStartColumn
               
               If bandingStartNumber Then '-- value set on line 1
               
                    Bnd_END_No_I_1 = Range(BandEndColumn & (I - 1)).Value '-- PREVIOUS LINE END VALUE
                        
                    If ((IsNumeric(Bnd_END_No_I_1)) And (IsNumeric(Bnd_END_No_I))) Then
                    
                        If (Bnd_END_No_I_1 + 1 <> Bnd_START_No_I) Then
                    
                            Call SetInvalidRange(rngBnd_START_No_I)
                            Call AddValidationComment(BandStartColumn, I, "Band START must equal Band END +1 for value type: " + Bnd_Value_Type_Saved)
                            
                           
                        End If
                       
                    End If
                    
                Else  '--- SPECIAL CASES - THE START/END VALUES WHEN 'BAND VALUE TYPE' IS OF NON INTEGER TYPE - ASSUME 5 DECIMAL FLOAT
                  
                    Bnd_END_No_I_1 = Range(BandEndColumn & (I - 1)).Value '-- PREVIOUS LINE END VALUE
                        
                    If ((IsNumeric(Bnd_END_No_I_1)) And (IsNumeric(Bnd_END_No_I))) Then
                    
                        If (Bnd_END_No_I_1 + minRateValue <> Bnd_START_No_I) Then
                    
                            Call SetInvalidRange(rngBnd_START_No_I)
                            Call AddValidationComment(BandStartColumn, I, "Band START must equal Band END (of previous line) plus " + CStr(minRateValue) + " for value type: " + Bnd_Value_Type_I)
                            
                           
                        End If
                       
                    End If
               
               
               End If
        ' -- the whole band apply range
                     
               lastActiveColumn = BandTierNoColumn
         
              '--- INCREASING VALUE CHECKS - TIER SPECIFIC
              
                    Dim Bnd_TierNo_I_1 As String
               
                    Bnd_TierNo_I_1 = Range(BandTierNoColumn & (I - 1)).Value
                        
                    If ((IsNumeric(Bnd_TierNo_I)) And (IsNumeric(Bnd_TierNo_I_1))) Then
                    
                        If Bnd_TierNo_I <> (Bnd_TierNo_I_1 + 1) Then
                    
                            Call SetInvalidRange(rngBnd_TierNo_I)
                            Call AddValidationComment(BandTierNoColumn, I, "Band Tier# Tiers Must Be in Ascending Sequential Order")
                            
                        End If
                       
                    End If
             
                    lastActiveColumn = BandEndColumn
             
                    If IsNumeric(Bnd_START_No_I) And IsNumeric(Bnd_END_No_I) Then
                
                    If (CDbl(Bnd_START_No_I) > CDbl(Bnd_END_No_I)) Then  '--3/29/16-Graham-allow equal
                      
                         Call SetInvalidRange(rngBnd_START_No_I)
                         Call AddValidationComment(Module1.BandStartColumn, I, "Invalid - Band START > Band END")
                         
                         Call SetInvalidRange(rngBnd_END_No_I)
                         Call AddValidationComment(Module1.BandEndColumn, I, "Invalid - Band START > Band END")
                         
                    End If
                    
              End If
'
'               If InStr(BandStartEndIntegerTypes, Bnd_Value_Type_I) > 0 Then
'                  bandingStartNumber = 1
'              Else
'                  bandingStartNumber = 0
'              End If
'
'
            If (bandingStartNumber = 0) Then
              
                   rngBnd_START_No_I.NumberFormat = Module1.decimalFormat2 '--decimal
                   rngBnd_END_No_I.NumberFormat = Module1.decimalFormat2 '--decimal
                  
            End If
            If (bandingStartNumber = 1) Then
              
                   rngBnd_START_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                   rngBnd_END_No_I.NumberFormat = Module1.decimalFormat0 '--integer
                  
            End If
            
               
            '--- 3/19/18-reg - Graham adds conditions too for band/vol disc
            '--- 3/21/16-reg-new checks for brk amt - max value per list of rate types - Graham markit
            
            '--- note: since the 1st rate type is Band - then we use the band rate type for this validation
            
            
            If (Rate_Type = "") And IsNumeric(Bnd_RATE_I) And (Bnd_RATE_I <> "") And (Bnd_Rate_Type_Saved <> "") Then
                
                If InStr(Module1.maxRateAmtList999, Bnd_Rate_Type_Saved) > 0 And (Bnd_RATE_I > max3digits) Then
                    
                    Call SetInvalidRange(rngBRATE_I)
                    Call AddValidationComment(BandRateColumn, I, "Invalid Band Rate - exceeded Max value of " + CStr(max3digits) + " (three digits) for Band rate type: " + Bnd_Rate_Type_Saved)
                
                End If
                
                 If InStr(Module1.maxRateAmtList99999, Bnd_Rate_Type_Saved) > 0 And (Bnd_RATE_I > max5digits) Then
                    
                    Call SetInvalidRange(rngBRATE_I)
                    Call AddValidationComment(BandRateColumn, I, "Invalid Band Rate - exceeded Max value of " + CStr(max5digits) + "  (5 digits) for Band rate type: " + Bnd_Rate_Type_Saved)
                
                End If
            
            End If
                     
            '----- HAVE FULL BANDING DATA TO CHECK - AFTER BAND# 1
                
            If (((Bnd_TierNo_I <> "") And _
                 (rngBnd_TierNo_I.Value <> FirstBandingDiscountTier)) Or _
                 (Bnd_START_No_I <> "") Or _
                 (Bnd_END_No_I <> "") Or _
                 (Bnd_RATE_I <> "")) Then
                
                ' MsgBox "Band Disc Not First Row - Row " & Istr & " BandingDiscountStartRow = " & BandingDiscountStartRow '-- remove release 3.5
                
                    
                                            
                   'Public Const VolumeDiscountStartTypeAmountValue As String = "Amount"
                   'Public Const VolumeDiscountStartTypeNumberValue As String = "Number"
                                
                                     
                                  
                    '--- it must be empty all the way up to band# (for line >=2 of band) or up to band value, FC = first colm
                
                    Set ValidationRange_I = Range(addrFC_I, Module1.TierVolDiscRateColumn & Istr) '-- must be empty up to the last vold disc
                     Validation_I_Count = ValidationRange_I.Count
                    
                    For K = 1 To Validation_I_Count
        
                        If Trim(ValidationRange_I(1, K).Value) <> "" Then
                           Exit For
                        End If
                        
                    Next K
                                                         
                    If (K <= Validation_I_Count) Then
                    
                        Call SetInvalidRange(ValidationRange_I)
                        Call AddValidationComment(FirstColumn, I, "Some data is outside Banding region for Band Tier# > 1  -- Invalid with Banding Rates")
                        
                    End If
                    
                End If '---BANDING LOOP
         
            End If  '--- MORE LINES (BLANK 1ST PART) - FOR VOL DIS/BANDING
      
       End If '--- LAST CHECK FOR BAND DISC OF 2ND LINE OR MORE
      
     End If '--- 2ND ROW CHECK FOR TIERS/BAND - ELSE OF 1ST LINE CHECK IF VOL DISC/BANDING (ELSE IS 2ND TIER OR MORE)
      
   ' End If '--- NON BLANK VALID REGION CHECK (EXCH, PROD GRP, PROD ALL CHECKED THEN - BUT ERROR MSG COMMENT IF BAD)
        
    'End If '--- NON BLANK ROW (END OF ELSE)
        
    Set ValidationRange_I = Nothing
        
   
Next I
'------- end of main for loop

'-- verify we have at least two tiers - and other misc band/vol disc checks
'-- if there are vol disc or bands it does nothing, depends on relativer tiers position
Call validateBandingRows
Call validateVolDiscountRows

Application.ScreenUpdating = True

statusPct = (I - 1) / ModuleLastRow
statusMsg = "Validation Completed:  Row# " & ModuleFirstRow & " to " & CStr(ModuleLastRow)

If isUserFormLoaded(CP) Then
   frmControlPanel.validationDateTime = statusMsg
End If

Application.StatusBar = statusMsg

Application.Cursor = xlDefault

'-- close CP bef message next
If isUserFormLoaded(CP) Then
   frmControlPanel.validationDateTime = CStr(performValidationTime)
   frmControlPanel.hide
End If

Dim numErrorsLog As Integer
numErrorsLog = ErrorLogRowCounter - ErrorLogFirstRow

'--- markit: Validations Complete-7 Errors Found - Please Review Error log
'--- reg - 3/21/15 - the error count is incorrect - it's a count of rows in errorlog, some may be the same error

If numErrorsLog = 0 Then

   MsgBox "Validations Complete - No Errors Found", vbOKOnly, "eModule Validation"
            
Else

   MsgBox "Validations Complete." + vbLf + vbLf + _
          "The count of Rows in ErrorLog is:    " + CStr(numErrorsLog) + vbLf + vbLf + _
          "Please Review the Error Log.", vbCritical, "eModule Validation"
End If



performValidationFlag = True
performValidationTime = Now()




'-- relase range vars


Set rngVolDisc_TierStartNumber_I = Nothing
Set ValidationRange_I = Nothing
Set rngAddrRTC_I = Nothing
Set rngVolDisc_TierNo_I = Nothing
Set rngAddrEC_I = Nothing

'Set rngAddrPT_I = Nothing '-- not used
Set rngDTC_I = Nothing
Set rngATC_I = Nothing
Set rngSTC_I = Nothing
Set rngTC_VDSR = Nothing
Set rngTDC_I_VDAC_I = Nothing
Set rng3J = Nothing
Set rngDEC_I = Nothing
Set rngMMax_I = Nothing
Set rngMMin_I = Nothing
Set rngRegion_Exch_Code_I = Nothing
Set rngAddrPGCC_I = Nothing
Set rngAddrPC_I = Nothing

On Error GoTo 0

'--- return to the last active cell - 3/1/16- reg

disableWorksheetSelectionChange = True

On Error Resume Next
saveCurrCell3.Select
On Error GoTo 0
Set saveCurrCell3 = Nothing


Application.Cursor = xlNormal

disableWorksheetSelectionChange = False

Application.ScreenUpdating = True

Exit Sub
'===================
'=================== ERROR HANDLERS


VBAErrorHandler:

 Select Case Err.Number

         Case 9:    ' Error 9 - SUBSCRIPT OUT OF RANGE - THE ARRAYS FOR PRODUCTS, GRP AND REGIONS
                       
                         
            MsgBox "Products internal list is empty - will reinitialize next.", , title2
            Call eModule.WorkbookOpen1
         
      
         Case Else:      ' An error other than 68, 75 or 76 has occurred.
            ' Display the error number and the error text.
            MsgBox "Error # " & CStr(Err.Number) & ": " & Err.Description, vbCritical, title1 + "-" + Err.Description

 End Select

On Error GoTo 0





'--- LOGS IN THE ERROR LOG A VBA ERROR DURING VALIDATION

'--- 3/21/16-REG-RELEASE TO MARKIT
'--- NEED QUICK FIX TO NOT GIVE NASTY ERROR MSG TO USER - SO DOA VALIDATION ON CELL MESG

Dim notes As String
notes = "Activecell=" + CStr(ActiveCell.Value) + ", Row# " + CStr(ActiveCell.row) + ", Col: " + CStr(ActiveCell.Column)

Dim vbaErrMsg1 As String
Dim vbaErrMsg2 As String
vbaErrMsg2 = ""

If Err.Number = 6 Then
    vbaErrMsg2 = "Number is too large,"
ElseIf Err.Number = 13 Then
    vbaErrMsg2 = "Possible invalid numeric value,"
End If

vbaErrMsg1 = "VALIDATION Run-Time Error# " + CStr(Err.Number) + ", Desc: " + Err.Description + ", " + vbaErrMsg2 + " Src: " + Err.Source + " - Validation stopped."
'-- LATER -WRITE THE DATA BELOW TO LOG
'-- Call Module1.errorVbaHandlderMsg("VALIDATION", CStr(Err.Number), Err.Description, Err.Source, errorStage(1), errorStage(2), errorStage(3), errorStage(4), notes, True)
 
'--ADDED REG - 3/21/16
Dim vbaErrAddr As String
Dim vbaErrRng As Range
Dim colName As String
Dim rowNum As Long

If lastActiveColumn <> "" Then
   colName = lastActiveColumn
Else
   colName = ConvertToExcelColumnLetter(ActiveCell.Column)
End If

If lastActiveRow >= 4 Then
   rowNum = lastActiveRow
  Else
   rowNum = ActiveCell.row
End If

vbaErrAddr = colName + CStr(rowNum) + ":" + colName + CStr(rowNum)
Set vbaErrRng = Range(vbaErrAddr)

If lastActiveColumn > "" And rowNum >= 4 Then

   Call SetInvalidRange(vbaErrRng)
   Call AddValidationComment(colName, rowNum, vbaErrMsg1)
  Else
   MsgBox "Validation stopped due to excel error: " + vbaErrMsg1, vbCritical, "Validation error"
 End If
 
Application.Cursor = xlNormal
 
Application.StatusBar = "Validation completed - error(s) found."
On Error GoTo 0


End Sub
'------- end of main validation sub


Public Sub AddValidationComment(ColumnName As String, RowNumber As Long, message As String)

Dim columnTitle As String

Dim rngCR As Range
Set rngCR = Range(ColumnName & RowNumber)

If EnableComments = True Then
    
    If (rngCR.Comment Is Nothing) Then
        rngCR.AddComment message
    ElseIf InStr(rngCR.Comment.Text, message) = 0 Then
        rngCR.Comment.Text Text:=rngCR.Comment.Text & vbLf & message '-- not it can add another message if it has one
    End If
    
    rngCR.Comment.Shape.Width = cellCommentsWidth '--- 3/21/16-reg - let comment grow
    rngCR.Comment.Shape.Height = cellCommentsWidth / 3

End If

If EnableErrorLog = False Then Exit Sub

Dim rng1 As Range
Dim rng2 As Range
Dim rng3 As Range
Dim rng4 As Range
Dim rng5 As Range

Set rng1 = ModuleSheet.Range(ColumnName & HeaderRowOffset)
Set rng2 = ErrorLog.Range(ErrorLogTimeStampColumn & ErrorLogRowCounter)
Set rng3 = ErrorLog.Range(ErrorLogRowNumberColumn & ErrorLogRowCounter)
Set rng4 = ErrorLog.Range(ErrorLogColumnNameColumn & ErrorLogRowCounter)
Set rng5 = ErrorLog.Range(ErrorLogMessageColumn & ErrorLogRowCounter)

columnTitle = rng1.Value

rng2.Value = Now()
rng3.Value = "Row " & RowNumber
rng4.Value = "Column " & ColumnName & " - " & columnTitle
rng5.Value = message

ErrorLogRowCounter = ErrorLogRowCounter + 1

Set rng5 = Nothing
Set rng4 = Nothing
Set rng3 = Nothing
Set rng2 = Nothing
Set rng1 = Nothing

End Sub

Public Sub SetInvalidRange(InvalidRange As Range)

    InvalidRange.Interior.ColorIndex = InvalidColorIndexValue
    InvalidRange.Interior.Pattern = InvalidPatternValue
    InvalidRange.Interior.PatternColorIndex = InvalidPatternColorIndexValue

End Sub


Public Sub validateBandingRows()
'--- 3/22/16-reg-verify we have at least two tiers for rates

Dim rateType As String
rateType = Module1.BandingDiscountRateType

Dim addr As String
addr = Module1.RateTypeColumn + CStr(Module1.ModuleFirstRow) + ":" + Module1.RateTypeColumn + CStr(Module1.ModuleLastRow)

Dim cel As Range
Dim Rng As Range
Set Rng = Range(addr)
Dim cel2 As Range

For Each cel In Rng

    If cel = rateType Then
    
       Application.StatusBar = "Validation of Tiers for rate type: " + rateType + " on row#" + CStr(cel.row)
    
       Set cel2 = cel.Offset(1, 18) '-- 1 row down and 18 to left to tier# col banding
    
       If cel2.Value <> 2 Then
          
           Call SetInvalidRange(cel2)
           Call AddValidationComment(ConvertToExcelColumnLetter(cel2.Column), cel2.row, "The Tier# 2 is missing for Rate Type of: " + rateType)
          
       End If
    
    End If

Next

End Sub


Public Sub validateVolDiscountRows()
'--- 3/22/16-reg-verify we have at least two tiers for rates

Dim rateType As String
rateType = Module1.VolumeDiscountRateType

Dim addr As String
addr = Module1.RateTypeColumn + CStr(Module1.ModuleFirstRow) + ":" + Module1.RateTypeColumn + CStr(Module1.ModuleLastRow)

Dim cel As Range
Dim Rng As Range
Set Rng = Range(addr)
Dim cel2 As Range

For Each cel In Rng

    If cel = rateType Then
    
       Application.StatusBar = "Validation of Tiers for rate type: " + rateType + " on row#" + CStr(cel.row)
    
       Set cel2 = cel.Offset(1, 13) '-- 1 row down and 14 to left to tier# col banding
    
       If cel2.Value <> 2 Then
          
           Call SetInvalidRange(cel2)
           Call AddValidationComment(ConvertToExcelColumnLetter(cel2.Column), cel2.row, "The Tier# 2 is missing for Rate Type of: " + rateType)
          
       End If
    
    End If

Next

End Sub

Attribute VB_Name = "Module3"
Option Explicit

'--- product query tool (PQT) - the Global Keyw search (GKS)
'--- can search up to 3 keyw with and/or in the entire product tab (prod, exch, region etc)

Public Sub PQT_GKS_searchAllProductsExchGrpKeywords(logical As String)

Application.ScreenUpdating = False

Module1.disableWorksheetSelectionChange = True

Module1.PQTnotMsgDisplayed = True

Const title = "PQT - Global Keyword Search"

Const rowLimit = 15000
Dim rowSource(rowLimit) As Integer
'-----so that it's released on end

Dim ix As Integer
Dim fx As Integer


Dim wks1 As Worksheet
Set wks1 = Worksheets("Product") '---source
Dim wks2 As Worksheet
Set wks2 = Worksheets(saveResultsTab) '---dest

wks1.Activate
wks1.Range("A2").Select

Dim prodLastRow As Integer
prodLastRow = Product.Range("E50000").End(xlUp).row

If prodLastRow < 5000 Then
   MsgBox "GKS - The count of product is too low:  " + CStr(prodLastRow), vbCritical, title
   ModuleSheet.Select
   Exit Sub
End If

Dim retVal As Integer



Dim search(3) As String
Dim searchDef(3) As String

'--- load defaults from the 1st three keywords
On Error Resume Next
If (frmProdQueryTool.ListBoxKeywords.List(0) > "") Then
   searchDef(1) = frmProdQueryTool.ListBoxKeywords.List(0)
End If
On Error Resume Next
If (frmProdQueryTool.ListBoxKeywords.List(1) > "") Then
   searchDef(2) = frmProdQueryTool.ListBoxKeywords.List(1)
End If
On Error Resume Next
If (frmProdQueryTool.ListBoxKeywords.List(2) > "") Then
   searchDef(3) = frmProdQueryTool.ListBoxKeywords.List(2)
End If
On Error GoTo 0

Call frmProdQueryTool.clearQuery '-- erase prev searches - confuses inputs

Dim searchRange As Range
Dim addrSource As String

Dim cntKeyw As Integer
cntKeyw = 0

For ix = 1 To 3
    search(ix) = InputBox("Enter a search word# " + CStr(ix) + ":", "PQT Logical is: " + logical, searchDef(ix))
    search(ix) = UCase(Trim(search(ix)))
    
    If (search(ix) = "") And (ix = 1) Then
       MsgBox "There are no keywords - return to the eModule.", , title
       ModuleSheet.Select
       Exit Sub
    End If
    
    If search(ix) = "" Then
       Exit For
    End If
Next
cntKeyw = ix - 1
  
If cntKeyw = 1 Then
   logical = "OR"
End If
  
Dim cel As Range
Dim found As Boolean
Dim strCel As String

Dim foundCnt As Integer
Dim currRow As Integer
fx = 0
Dim celCnt As Long
Dim status As String

'--- remember - we are in the Products (hidden) tab
If Module1.ProductLastRow = 0 Then
   Call Module1.eModReset
End If

'--- or logic - since it's one match we can search each cell separately

addrSource = "A2:F" + CStr(Module1.ProductLastRow) '-- GLOBAL RANGE - ALL THE TAB CONTENTS, INCLUDING THE NEW DEF CURRENCY
Set searchRange = Range(addrSource)
Dim keywordsFound As Integer

If logical = "OR" Then
 
   For Each cel In searchRange
        '--- find the matches
            celCnt = celCnt + 1
            
            For ix = 1 To cntKeyw
                
                strCel = UCase(Trim(CStr(cel.Value)))
                
                If InStr(strCel, search(ix)) > 0 Then
                
                   If fx > rowLimit Then
                      MsgBox "GKS: The Array Limit of:  " + CStr(rowLimit) + " matching products has been reached.", vbCritical, title1
                      ModuleSheet.Select
                      Exit Sub
                   End If
                   
                   fx = fx + 1
                      
                   If fx > 2 And (rowSource(fx - 1) <> cel.row) Then
                   
                      rowSource(fx) = cel.row
                                      
                   End If
                                      
                   frmProdQueryTool.lblProductSearchMessage.Caption = CStr(fx) + ": " + strCel
                   
                   DoEvents
                End If
                
            Next
        
      DoEvents
   Next



End If

'--- and logic - since it's and we need to search each row separately (1-3 matches in each row)

If logical = "AND" Then

   Dim rw As Long
   Dim keywFound(1 To 3) As Boolean
   
   '--- we detect AND by after each pass in the current row we find each keyword - for AND the count is the same as the count of keyw

   For rw = 2 To ProductLastRow
   '-- NEED TO MOVE ROW BY ROW AND SEARCH IN EACH ROW FOR ALL THE KEYWORDS

       keywFound(1) = False
       keywFound(2) = False
       keywFound(3) = False

       addrSource = "A" + CStr(rw) + ":E" + CStr(rw) '-- ROW RANGE
    
       Set searchRange = Range(addrSource)
       
       
       For ix = 1 To cntKeyw
   
           For Each cel In searchRange
        '--- find the matches
                strCel = UCase(Trim(CStr(cel)))
                
                If InStr(strCel, search(ix)) > 0 Then
                
                   frmProdQueryTool.lblProductSearchMessage.Caption = CStr(ix) + ": " + strCel
                                      
                   DoEvents
                   keywFound(ix) = True
                   
                   Exit For ' need to seach again the entire row with new keyw
                End If
           Next
        
        Next '--CELL IN ROW
    
  
        
        '--- for 1 keyw we use or
        
        If (cntKeyw = 2 And keywFound(1) And keywFound(2)) Or _
           (cntKeyw = 3 And keywFound(1) And keywFound(2) And keywFound(3)) Then  '-- found all keywords in the same row
        
           If fx > rowLimit Then
              MsgBox "GKS: The Array Limit of:  " + CStr(rowLimit) + " matching products has been reached.", vbCritical, title1
              ModuleSheet.Select
              Exit Sub
           End If
        
           fx = fx + 1
                      
           If fx > 2 And (rowSource(fx - 1) <> cel.row) Then
            
               rowSource(fx) = cel.row
               
           End If
               
         End If '-- ROW
     
            DoEvents
        Next '--- row
  
End If

foundCnt = fx

Dim rngRowSource As Range
Dim rngRowToCopy As Range


Dim addr1 As String
Dim addr2 As String

Dim rowDestFirstRow As Integer
Dim rowDestRow As Integer
rowDestRow = Module1.getModuleLastRow() + 2 '-- append skip 1 row
rowDestFirstRow = rowDestRow '-- save value

'If Not eModuleLineIsEmpty(rowDestRow) Then
     
'   If rowDestRow > 4 Then
 '     rowDestRow = rowDestRow + 1 '-- skio a line if not the 1st row
 '  End If
   
'End If

If rowDestRow < ModuleFirstRow Then
   rowDestRow = ModuleFirstRow
End If
     
Dim copyRowsCount As Integer
copyRowsCount = 0
wks2.Activate

For fx = 1 To foundCnt

'--- select the rows of the matches, avoid repeated rows
    If (currRow <> rowSource(fx)) Then
        
        currRow = rowSource(fx)
        
        If currRow > 1 Then '-- valid row - CAN BE ZERO
     
            addr1 = "A" + CStr(currRow) + ":" + "F" + CStr(currRow)
            addr2 = "B" + CStr(rowDestRow) + ":" + "G" + CStr(rowDestRow)
            
            Set rngRowSource = wks1.Range(addr1)
            Set rngRowToCopy = wks2.Range(addr2)
            
            rngRowSource.Copy
            rngRowToCopy.PasteSpecial xlPasteAll
               
            rowDestRow = rowDestRow + 1 '-- add later
            
            copyRowsCount = copyRowsCount + 1
            
        End If
        
     End If
     
Next

Application.StatusBar = "PQT finished."

If copyRowsCount = 0 Then
   MsgBox "No matching records found.", , title1

  Else
   MsgBox "Found  " + CStr(copyRowsCount) + "  matching products and copied them." + vbLf + vbLf + _
          "The first eModule row copied is ROW# " + CStr(rowDestFirstRow) + vbLf + vbLf + _
          "The Last eModule row copied is  ROW# " + CStr(rowDestRow - 1) + vbLf + vbLf + _
          "Next the PQT will close and the eModule will be visible.", , title

End If

Module1.PQTinUseDisableCboxes = False
'-- close form
frmProdQueryTool.hide
'-- reset env

Application.cutCopyMode = False '-- release clipboard mem

Application.ScreenUpdating = True

Module1.disableWorksheetSelectionChange = False '--- important to enable cboxes on emod

Module1.PQTnotMsgDisplayed = False


wks2.Select
wks2.Activate

'Call Module1.eModReset '-- so that all combo boxes are loaded

Set wks1 = Nothing
Set wks2 = Nothing

Set rngRowSource = Nothing
Set rngRowToCopy = Nothing

Set searchRange = Nothing

DoEvents

Range("A" + CStr(rowDestFirstRow) + ":G" + CStr(rowDestFirstRow)).Select '-- same as PQT - select 1st copied row


End Sub


Attribute VB_Name = "Module4"
Option Explicit

'--- MACRO CALLBACKs FOR RIBBON EMOD 3.5


'===========================================
'============= RIBBON CALLBACKS
'===========================================

'Callback for eBackup onAction
Sub ribbonCallback_eBak(control As IRibbonControl)
  Call Module1.eBak
End Sub

'Callback for emodClearFormatting onAction
Sub ribbonCallback_ClearFormatting(control As IRibbonControl)
 Call Module1.clearAllFormats(True)
End Sub


'Callback for DeleteAlmostEmptyRows onAction
Sub ribbonCallback_DeleteAlmostEmptyRows(control As IRibbonControl)
  Call Module1.deleteAndReportAlmostEmptyRows
End Sub


'Callback for emodSelectAll onAction
Sub ribbonCallback_SelectAll(control As IRibbonControl)
  Call Module1.SelectAll 'leaves emod all rows selected
End Sub

'Callback for PQT onAction
Sub ribbonCallback_PQT(control As IRibbonControl)
  Call Module1.formOpenProductQueryTool '-- a form, sam as icon in excel
End Sub

'Callback for PQT onAction
Sub ribbonCallback_CP(control As IRibbonControl)
  Call Module1.formOpenControlPanel '-- a form, sam as icon in excel
End Sub


'Callback for NP onAction
Sub ribbonCallback_NP(control As IRibbonControl)
  Call Module1.formOpenNavigationPanel '-- a form, sam as icon in excel
End Sub

'Callback for AltLinesYellow onAction
Sub ribbonCallback_AltLinesYellow(control As IRibbonControl)
  Call ModuleSheet.eModAlternateRowColors(19)
End Sub

'Callback for AltLinesBlue onAction
Sub ribbonCallback_AltLinesBlue(control As IRibbonControl)
  Call ModuleSheet.eModAlternateRowColors(20)
End Sub

'Callback for SelectCopyDown onAction - SelectCopyDown on NP
Sub ribbonCallback_SelectCopyDown(control As IRibbonControl)
  Call Module1.selectCopyInsertCurrentRow
End Sub

'Callback for cellCopyDown onAction - copy downn button on NP
Sub ribbonCallback_CellCopyDown(control As IRibbonControl)
  Call Module1.cellCopyDown
End Sub

'Callback for formatNumericColumns onAction
Sub ribbonCallback_formatNumericColumns(control As IRibbonControl)
  Call Module1.formatNumericColumns
End Sub

'Callback for resetEmodule onAction - excel button with ver id
Sub ribbonCallback_emodVersionAndReset(control As IRibbonControl)
  Call Module1.emodVersionAndReset
End Sub


'Callback for emodValidation onAction
Sub ribbonCallback_Validation(control As IRibbonControl)
  Call Module2.PerformValidation
End Sub

'--- END MOD 3.5 RIBBON CODE
Attribute VB_Name = "ModuleSheet"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "tglTopBot, 23895, 4, MSForms, ToggleButton"
Attribute VB_Control = "btnNavigationPanel, 23870, 5, MSForms, CommandButton"
Attribute VB_Control = "btnOpenControlPanel, 23868, 6, MSForms, CommandButton"
Attribute VB_Control = "cboDirectBill, 23841, 7, MSForms, ComboBox"
Attribute VB_Control = "cboDefaultExecutionType, 39, 8, MSForms, ComboBox"
Attribute VB_Control = "cboApplyTo, 36, 9, MSForms, ComboBox"
Attribute VB_Control = "cboDefinedTiersBased, 34, 10, MSForms, ComboBox"
Attribute VB_Control = "cboMMApply, 33, 11, MSForms, ComboBox"
Attribute VB_Control = "cboAddOnApply, 32, 12, MSForms, ComboBox"
Attribute VB_Control = "cboExecutionType, 31, 13, MSForms, ComboBox"
Attribute VB_Control = "cboRateType, 30, 14, MSForms, ComboBox"
Attribute VB_Control = "cboSpreadType, 29, 15, MSForms, ComboBox"
Attribute VB_Control = "cboTradeType, 28, 16, MSForms, ComboBox"
Attribute VB_Control = "cboProductGroupCode, 22, 17, MSForms, ComboBox"
Attribute VB_Control = "cboProduct, 21, 18, MSForms, ComboBox"
Attribute VB_Control = "cboRegion, 18, 19, MSForms, ComboBox"
Attribute VB_Control = "cboExchange, 20, 20, MSForms, ComboBox"
Attribute VB_Control = "cboCurrency, 24, 21, MSForms, ComboBox"
Attribute VB_Control = "cboBandApply, 23848, 22, MSForms, ComboBox"
Attribute VB_Control = "cboBandValueType, 23849, 23, MSForms, ComboBox"
Attribute VB_Control = "cboBandRateType, 23850, 24, MSForms, ComboBox"
Attribute VB_Control = "cboMMDefine, 23851, 25, MSForms, ComboBox"
Attribute VB_Control = "cboTierValueType, 23900, 26, MSForms, ComboBox"
Attribute VB_Control = "btnlblEmodVersionAndReset, 23902, 27, MSForms, CommandButton"
Option Explicit
Const title1 = "eModule Validation"
Const title2 = "eModule"

Private Sub CommandButton1_Click() '--

'--- this shows how to rename a sheet - USE IN CASE OF TAB CORRUPTION - EXCEPT FOR THE EMODULE TAB

'ThisWorkbook.VBProject.VBComponents("Sheetxx").name = "tabnamexxx"


'MsgBox "Sheet tabs renamed"
End Sub


Public Sub eModFilterOn()
      
    Dim addr As String
    addr = Module1.eModHeadingsRangeAddr
    Range(addr).Select
    Selection.AutoFilter

End Sub

Private Sub btnControlpanel_Click()
frmControlPanel.Zoom = 100
frmControlPanel.Show
End Sub



Public Sub btnlblEmodVersionAndReset_Click()
Call emodVersionAndReset
End Sub

Public Sub emodVersionAndReset()

Application.ScreenUpdating = False
Call Module1.emodVersionAndReset
Application.ScreenUpdating = True

End Sub



Public Sub btnNavigationPanel_Click()

Call Module1.formOpenNavigationPanel

End Sub

Private Sub btnTop_Click()
Call Module1.SelectFirstCell(False)
End Sub



Private Sub cboExchange_DropButtonClick()
ComboBoxChange = True
End Sub

Private Sub CommandButton2_Click()

Application.ScreenUpdating = False
Call Module1.emodVersionAndReset
Application.ScreenUpdating = True

End Sub

Private Sub CommandButton3_Click()
Call eModuleTestingSetup
End Sub





Private Sub tglTopBot_Click()

If tglTopBot Then
   Call Module1.SelectLastCell
   tglTopBot.Caption = "Top Row"
Else
   Call Module1.SelectFirstCell(False)
   tglTopBot.Caption = "Last Row"
End If

End Sub

Public Sub eModAlternateRowColors(coloridx As Integer)

Dim lastRow As Long

lastRow = Module1.getModuleLastRow + 500 '-- future lines to add

Dim Rng As Range
Dim addr As String
addr = "A4:" + LastColumn + CStr(lastRow)
Set Rng = ModuleSheet.Range(addr)
Dim cel As Range

For Each cel In Rng
    
    If (cel.row Mod 2) = 1 Then
        cel.Interior.ColorIndex = coloridx
    Else
        cel.Interior.ColorIndex = xlNone
    End If
    
Next cel

Set cel = Nothing
Set Rng = Nothing

End Sub





Public Sub eModCurrentRowShade()

'MsgBox "Test eModCurrentRowShade"

ModuleLastRow = getModuleLastRow()

    If Not Module1.eModShadeTurnedOn Then
       Exit Sub
    End If
           
    Dim Rng As Range
    Set Rng = ActiveCell
    
    If Rng Is Nothing Then
       Exit Sub
    End If
       
    If Rng.row < ModuleFirstRow Then  '--allow shade new row
       MsgBox "Invalid row.", , title1
       Exit Sub
    End If
    
    Dim beginShading As Boolean
    
    beginShading = (Module1.eModLastCellrng Is Nothing)
  '     Set Module1.eModLastCellrng = Range("A4:A4")
  '     Call eModCurrentRowUnshade(Module1.eModLastCellrng)
  '  End If
    
      If beginShading Then
      
           Set Module1.eModLastCellrng = Rng
       
      ElseIf (Rng.row <> Module1.eModLastCellrng.row) Then
          '-- we have a row to unshade
          Call eModCurrentRowUnshade(Module1.eModLastCellrng)
          '--- SET NOW THE LAST CELL USED
          Set Module1.eModLastCellrng = Rng '-- once we send above the curr cel to clear we set the curr cell range  variable
      End If
    
    Dim rw As Long
    rw = Rng.row
    Dim rws As String
    rws = CStr(rw)
    Dim addr As String
    
    Module1.disableWorksheetSelectionChange = True
    
    addr = "A" + rws + ":" + LastColumn + rws
    Range(addr).Select
     
    Dim backColor As Long
    backColor = RGB(204, 255, 255) '--light blue

    With Selection
       ' .Pattern = xlSolid
       ' .PatternColorIndex = xlAutomatic
        .Interior.Color = backColor
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
        
       ' .TintAndShade = 0
       ' .PatternTintAndShade = 0
    End With
    
    Rng.Select '-- LEAVE CELL AS IT WAS
    Set Rng = Nothing
    
    Module1.disableWorksheetSelectionChange = False
    
    frmControlPanel.hide
   
End Sub

Public Sub eModCurrentRowUnshade(rngLast As Range)
    
    If rngLast Is Nothing Then
       Exit Sub
    End If
    
    Dim Rng As Range
    Set Rng = rngLast
    Dim rw As Long
    rw = Rng.row
    
    Dim rws As String
    rws = CStr(rw)
    Dim addr As String
    
    Module1.disableWorksheetSelectionChange = True
    
    addr = "A" + rws + ":" + LastColumn + rws
    Range(addr).Select
    
    Dim backColor As Long
    backColor = RGB(255, 255, 255) '--white
    
    Selection.ClearFormats
    
    Module1.disableWorksheetSelectionChange = False
    
    Set Rng = Nothing
    'With Selection
      
     '   .Interior.Color = backColor
      '  .Borders.LineStyle = xlContinuous
       ' .Borders.Weight = xlThin
        
    'End With
    
    
End Sub

Private Sub btnOpenControlPanel_Click()

Call Module1.formOpenControlPanel
 
 '--- control panel form - emod 3.5

End Sub


Public Sub eModuleTestingSetup()

Call eModule.WorkbookOpen1
Call Module2.PerformValidation

End Sub

Private Sub Validate_Click()
 
 Call PerformValidation '--- reg - replaced form button (image) with active x button - with more properties

End Sub

Private Sub cboAddOnApply_Change()

    Call StaticDataComboBox_Change("cboAddOnApply", AddOnApplyColumn) ', AddOnApplyComboBoxHeight, AddOnApplyComboBoxWidth)

End Sub


Private Sub cboApplyTo_Change()

    Call StaticDataComboBox_Change("cboApplyTo", TierApplyToColumn) ', ApplyToComboBoxHeight, ApplyToComboBoxWidth)

End Sub

Private Sub cboCurrency_Change()

    'Call currencyCboStaticDataComboBox_Change   '
     Call StaticDataComboBox_Change("cboCurrency", CurrencyColumn)
End Sub


Private Sub cboDefaultExecutionType_Change()

End Sub

Private Sub cboDefinedTiersBased_Change()

    Call StaticDataComboBox_Change("cboDefinedTiersBased", TierDefinedBasedColumn) ', DefinedTiersBasedComboBoxHeight, DefinedTiersBasedComboBoxWidth)

End Sub

Private Sub cboDirectBill_Change()
    
    Call StaticDataComboBox_Change("cboDirectBill", DirectBillColumn) ', DirectBillComboBoxHeight, DirectBillComboBoxWidth)
 
End Sub

Private Sub cboExchange_Change()

'MsgBox "In cboExchange_Change " & ComboBoxChange

'If debugStatusMsg Then MsgBox "ComboBoxChange=" & CStr(ComboBoxChange) + vbLf + _
               "Range: " + Me.cboExchange.ListFillRange + vbLf + _
               "Text: " + Me.cboExchange.Text + vbLf + _
               "Value: " + Me.cboExchange.Value + vbLf + _
               "Style: " + CStr(Me.cboExchange.Style) + vbLf + _
               "Activecell addr: " + CStr(ActiveCell.Address) + vbLf + _
               "Activecell value: " + CStr(ActiveCell.Value), , "cboExchange_Change"

 Module1.eModNewLineFlag = Module1.eModNewLine(ExchangeComboBoxRow, ExchangeColumn) '-register id the current row is a new line (empty)
        
If eModNewLineFlag Then
   '--- FOR A NEW LINE - EMPTY ALL CBOXES - EMOD 3.5 KEY CODE TO ENABLE DROP DOWNS STYLE 2 ON ALL MAJOR DATA ITEMS - REGION TO PROD, ONLY FOR NEW OR EMPTY CELLS
 
   Me.cboExchange.Style = 2
   Me.cboProductGroupCode.Style = 2
   Me.cboProduct.Style = 2
   Me.cboCurrency.Style = 2
   
   'Me.cboProductGroupCode.Value = ""
  ' Me.cboProduct.Value = ""
   'Me.cboCurrency.Value = ""
   
End If



If ComboBoxChange = False Then Exit Sub

Dim I As Long

'*** 11/28/13

With Me.cboExchange

    Call FormatComboBox("cboExchange", ExchangeColumn)

End With


If Me.cboExchange.Value = "" Then
    
    ComboBoxChange = True

    If Range(ExchangeColumn & ExchangeComboBoxRow).Value <> "" Then
    
     
        Call SetInvalidRange(Range(ExchangeColumn & ExchangeComboBoxRow, ProductColumn & ExchangeComboBoxRow))
     
        
    End If
    
    Range(ExchangeColumn & ExchangeComboBoxRow).Value = ""
    
    Me.cboProductGroupCode.ListFillRange = ""
   
    Me.cboProduct.ListFillRange = ""
    
Else

    Call ProcessExchangeChange

End If

End Sub

Private Sub cboExchange_Click()

If ComboBoxChange = False Then Exit Sub

Call ProcessExchangeChange
      
End Sub


Private Sub cboExecutionType_Change()

    Call StaticDataComboBox_Change("cboExecutionType", ExecutionTypeColumn) ', ExecutionTypeComboBoxHeight, ExecutionTypeComboBoxWidth)

End Sub
Private Sub cboMMApply_Change()

    Call StaticDataComboBox_Change("cboMMApply", MMApplyColumn) ', MMApplyComboBoxHeight, MMApplyComboBoxWidth)

End Sub


Private Sub cboMMDefine_Change()
  '--- emod 3.5
  
  Call StaticDataComboBox_Change("cboMMDefine", MMDefineColumn)

End Sub


Private Sub cboBandApply_Change()
  '--- emod 3.5
  
  Call StaticDataComboBox_Change("cboBandApply", BandApplyColumn)

End Sub

Private Sub cboBandValueType_Change()
  '--- emod 3.5
  
  Call StaticDataComboBox_Change("cboBandValueType", BandValueTypeColumn)

End Sub


Private Sub cboBandRateType_Change()
  '--- emod 3.5
  
  Call StaticDataComboBox_Change("cboBandRateType", BandRateTypeColumn)

End Sub






Private Sub cboProduct_Change()

On Error GoTo VBAErrorHandler

'MsgBox "In cboProduct_Change " & ComboBoxChange

'If debugStatusMsg Then MsgBox "ComboBoxChange=" & CStr(ComboBoxChange) + vbLf + _
               "Range: " + Me.cboProduct.ListFillRange + vbLf + _
               "Text: " + Me.cboProduct.Text + vbLf + _
               "Value: " + Me.cboProduct.Value + vbLf + _
               "Activecell addr: " + CStr(ActiveCell.Address) + vbLf + _
               "Activecell value: " + CStr(ActiveCell.Value), , "cboProduct_Change"

If ComboBoxChange = False Then Exit Sub

Dim I As Long
Dim ListFillRangeStart As String
Dim ListFillRangeEnd As String
Module1.currentCurrencyRow = ActiveCell.row
 
Dim MinCol As Long
Dim MaxCol As Long

ComboBoxChange = False

Dim rngPC_PCBOXR As Range
Set rngPC_PCBOXR = Range(ProductColumn & ProductComboBoxRow)

Dim rngPTC_PGBOXR As Range
Set rngPTC_PGBOXR = Range(ProductTypeColumn & ProductGroupCodeComboBoxRow)

Dim rngPGC_PBOXR As Range
Set rngPGC_PBOXR = Range(ProductGroupCodeColumn & ProductComboBoxRow)

Dim rngPTC_PBOXR As Range
Set rngPTC_PBOXR = Range(ProductTypeColumn & ProductComboBoxRow)

Dim rngPCC_PBOXR As Range
Set rngPCC_PBOXR = Range(CurrencyColumn & ProductComboBoxRow) '--- eMod 3.5 - default currency - from Markit download, product tab column E

Call FormatComboBox("cboProduct", ProductColumn)

ProductComboBoxRow = ProductGroupCodeComboBoxRow


If Me.cboProduct.Value = "" Then
   
    ComboBoxChange = True
    
    rngPC_PCBOXR.Value = ""
    rngPTC_PGBOXR.Value = ""
    
Else
    
    rngPC_PCBOXR.Interior.ColorIndex = ValidColorIndexValue

    rngPC_PCBOXR.Value = Me.cboProduct.Value
        
    Call HideComboBoxesFast
    
    With Me.cboProduct
            
        Call FormatComboBox("cboProduct", ProductColumn)
        
        .Visible = True
    
    End With
    
    Dim rw As Integer
  
    If Me.cboProduct.ListFillRange <> "" Then

        If InStr(Me.cboProduct.ListFillRange, ":") = 0 Then ' Only one row in Listfillrange
      
            ListFillRangeStart = Right(Me.cboProduct.ListFillRange, Len(Me.cboProduct.ListFillRange) - InStrRev(Me.cboProduct.ListFillRange, "$"))
            ListFillRangeEnd = ListFillRangeStart
        
        Else
        
            ListFillRangeStart = Left(Me.cboProduct.ListFillRange, InStr(Me.cboProduct.ListFillRange, ":") - 1)
            ListFillRangeStart = Right(ListFillRangeStart, Len(ListFillRangeStart) - InStrRev(ListFillRangeStart, "$"))
            ListFillRangeEnd = Right(Me.cboProduct.ListFillRange, Len(Me.cboProduct.ListFillRange) - InStrRev(Me.cboProduct.ListFillRange, "$"))
    
        End If
        
        For I = CLng(ListFillRangeStart) - HeaderRowOffset To CLng(ListFillRangeEnd) - HeaderRowOffset
        
            If ((rngPGC_PBOXR = ProductArray(I, 2)) And _
                (rngPC_PCBOXR = ProductArray(I, 3))) Then
                
                 rngPTC_PBOXR.Value = ProductArray(I, 4) '--- prod type - NOT A cbox
                 
                 rw = rngPTC_PBOXR.row
                 
                 rngPCC_PBOXR.Value = ProductArray(I, 5) '--- default prod currency code eMod 3.5
                 
                 Module1.currentCurrencyRow = rw '--- the currency is valid only for this row in the cbocurrency
                 
                 '---reg-to fix the mess of the non-editable prod type we save the computed values here and validate in valiation
                 
                 'Module1.productTypeValidation(rw) = Trim(ProductArray(i, 4))
                 
                 Exit For
                 
            End If
            
        Next I
    
    End If

    ComboBoxChange = True
    
End If

On Error Resume Next
Set rngPC_PCBOXR = Nothing
Set rngPTC_PGBOXR = Nothing
Set rngPGC_PBOXR = Nothing
Set rngPTC_PBOXR = Nothing
On Error GoTo 0


Exit Sub
'========================== normal end of sub

VBAErrorHandler:

 Select Case Err.Number

         Case 9:    ' Error 9 - SUBSCRIPT OUT OF RANGE - THE ARRAYS FOR PRODUCTS, GRP AND REGIONS
                       
                         
            MsgBox "The Products internal list is empty - we will reinitialize it next.", vbExclamation, title2
            Call eModule.WorkbookOpen1
            
         
         Case Else:      ' An error other 9 has occurred.
            ' Display the error number and the error text.
            MsgBox "Error # " & CStr(Err.Number) & " : " & Err.Description, vbCritical, title1 + "-" + Err.Description

 End Select

On Error GoTo 0

End Sub

Private Sub cboProductGroupCode_Change()

On Error GoTo VBAErrorHandler
 

'MsgBox "In cboProductGroupCode_Change " & ComboBoxChange

'If debugStatusMsg Then MsgBox "ComboBoxChange=" & CStr(ComboBoxChange) + vbLf + _
               "Range: " + Me.cboProductGroupCode.ListFillRange + vbLf + _
               "Text: " + Me.cboProductGroupCode.Text + vbLf + _
               "Value: " + Me.cboProductGroupCode.Value + vbLf + _
               "Style: " + CStr(Me.cboProductGroupCode.Style) + vbLf + _
               "Activecell addr: " + CStr(ActiveCell.Address) + vbLf + _
               "Activecell value: " + CStr(ActiveCell.Value), , "cboProductGroupCode_Change"


If ComboBoxChange = False Then Exit Sub

Dim I As Long

Dim rngPGC_PGBOXR As Range
Set rngPGC_PGBOXR = Range(ProductGroupCodeColumn & ProductGroupCodeComboBoxRow)

Dim rngRC_PGBOXR As Range
Set rngRC_PGBOXR = Range(RegionColumn & ProductGroupCodeComboBoxRow)

Dim rngEC_PGBOXR As Range
Set rngEC_PGBOXR = Range(ExchangeColumn & ProductGroupCodeComboBoxRow)

Dim rngPGC_PC_PBOXR As Range
Set rngPGC_PC_PBOXR = Range(ProductGroupCodeColumn & ProductGroupCodeComboBoxRow, ProductColumn & ProductGroupCodeComboBoxRow)

'*** 11/28/13

Range(CurrencyColumn & ProductGroupCodeComboBoxRow).Value = "" '-- EMOD 3.5

Call FormatComboBox("cboProductGroupCode", ProductGroupCodeColumn)

ProductGroupCodeComboBoxRow = ExchangeComboBoxRow

   
If Me.cboProductGroupCode.Value = "" Then

    ComboBoxChange = True
    
    If rngPGC_PGBOXR.Value <> "" Then
           
        Call SetInvalidRange(rngPGC_PC_PBOXR)
     
    End If

    rngPGC_PGBOXR.Value = ""

    Me.cboProduct.ListFillRange = ""
    
    Range(ProductTypeColumn & ProductGroupCodeComboBoxRow).Value = ""

Else
    
    rngPGC_PGBOXR.Interior.ColorIndex = ValidColorIndexValue

    rngPGC_PGBOXR.Value = Me.cboProductGroupCode.Value
    
    Call HideComboBoxesFast
    
    ProductComboBoxRow = ProductGroupCodeComboBoxRow
    
    With Me.cboProduct
    
        .Top = Me.cboProductGroupCode.Top
        
        .Visible = True
    
    End With
    
    ComboBoxChange = True

    For I = 0 To ProductArrayUBound
            
        If ((ProductArray(I, 0) = rngRC_PGBOXR.Value) And _
            (ProductArray(I, 1) = rngEC_PGBOXR.Value) And _
            (ProductArray(I, 2) = rngPGC_PGBOXR.Value)) Then

            MinCol = I + HeaderRowOffset

            Exit For

        End If

    Next I

    If I <= ProductArrayUBound Then

        If MinCol - 2 = ProductArrayUBound Then ' Blanket Exchange is last row and only one occurence

            MaxCol = MinCol

        Else

            For I = MinCol - 1 To ProductArrayUBound
                    
                If ((ProductArray(I, 0) <> rngRC_PGBOXR.Value) Or _
                    (ProductArray(I, 1) <> rngEC_PGBOXR.Value) Or _
                    (ProductArray(I, 2) <> rngPGC_PGBOXR.Value)) Then

                    MaxCol = I + (HeaderRowOffset - 1)

                    Exit For

                End If

            Next I

            If I > ProductArrayUBound Then
               MaxCol = ProductArrayUBound + 2
            End If

        End If

    Me.cboProduct.ListFillRange = Product.Range("$" & RefDataProductColumn & "$" & MinCol _
                                  & ":$" & RefDataProductColumn & "$" & MaxCol).Address(External:=True)

    '*** 10/30/13 'Autofill Product if only one occurence
    
    If MinCol = MaxCol Then
        
        Me.cboProduct.Value = ""
    
        ComboBoxChange = True
    
        Me.cboProduct.ListIndex = 0
        Me.cboProduct.Value = Product.Range("$" & RefDataProductColumn & "$" & MinCol).Value
        
    Else
        
        Me.cboProduct.Value = ""
        Range(ProductColumn & ProductGroupCodeComboBoxRow).Value = ""
        Range(ProductTypeColumn & ProductGroupCodeComboBoxRow).Value = ""
     
      
    End If
    
    Range(ProductColumn & ProductComboBoxRow) = Me.cboProduct.Value
    
    '*** 10/30/13 'Autofill Product if only one occurence
    
    ComboBoxChange = True

    Else

        ComboBoxChange = True

        Me.cboProduct.ListFillRange = ""

        Range(ProductColumn & ProductComboBoxRow) = Me.cboProduct.Value

        Me.cboProduct.Value = ""

      

      End If

End If

On Error Resume Next
Set rngPGC_PGBOXR = Nothing
Set rngRC_PGBOXR = Nothing
Set rngEC_PGBOXR = Nothing
Set rngPGC_PC_PBOXR = Nothing
On Error GoTo 0

Exit Sub
'--------------- normal end sub

VBAErrorHandler:

 Select Case Err.Number

         Case 9:    ' Error 9 - SUBSCRIPT OUT OF RANGE - THE ARRAYS FOR PRODUCTS, GRP AND REGIONS
                       
                         
            MsgBox "Products internal list is empty - will reinitialize next.", , title2
            Call eModule.WorkbookOpen1
         
        
         
         Case Else:      ' An error other than 68, 75 or 76 has occurred.
            ' Display the error number and the error text.
            MsgBox "Error # " & CStr(Err.Number) & ": " & Err.Description, vbCritical, title1 + "-" + Err.Description

 End Select

On Error GoTo 0

End Sub
Private Sub cboRateType_Change()

    
    Call StaticDataComboBox_Change("cboRateType", RateTypeColumn) ', RateTypeComboBoxHeight, RateTypeComboBoxWidth)
    
    Dim cboxRateType As ComboBox
    Set cboxRateType = ModuleSheet.OLEObjects("cboRateType").Object

    If Trim(cboxRateType.Text) <> "" Then
       Module1.lastRateType1 = cboxRateType.Text
    End If
    
   
     
End Sub

Private Sub cboRegion_Change()
'-----------------------------

On Error GoTo VBAErrorHandler


'If debugStatusMsg Then MsgBox "ComboBoxChange=" & CStr(ComboBoxChange) + vbLf + _
               "Range: " + Me.cboRegion.ListFillRange + vbLf + _
               "Text:  " + Me.cboRegion.Text + vbLf + _
               "Value: " + Me.cboRegion.Value + vbLf + _
               "Style: " + CStr(Me.cboRegion.Style) + vbLf + _
               "Activecell addr: " + CStr(ActiveCell.Address) + vbLf + _
               "Activecell value: " + CStr(ActiveCell.Value), , "cboRegion_Change"



If ComboBoxChange = False Then
   Exit Sub
End If

Dim I As Long

If RegionComboBoxRow < Module1.ModuleFirstRow Then '-- stop from writing heading rows
    Call Module1.SelectFirstCell(False)
    RegionComboBoxRow = Module1.ModuleFirstRow
End If

With Me.cboRegion

    Call FormatComboBox("cboRegion", RegionColumn)

End With



'--- THE REGION IS RELATED TO THE EXCH, PROD GRP AND PRODUCT
'--- TWO WAYS:
'--- GOING FORWARD IN THE ROW - THE REGION SELECTED DETERMINES THE CHOICES FOR EXCH ETC
'--- GOING BACKWARDS - IF WE CHANGE THE REGION - ALL OTHER CHOICES ARE INVALID

Dim rngRC_PC_RBOXR As Range
Set rngRC_PC_RBOXR = Range(RegionColumn & RegionComboBoxRow, ProductColumn & RegionComboBoxRow)

Dim rngRC_RBOXR As Range
Set rngRC_RBOXR = Range(RegionColumn & RegionComboBoxRow)

Dim rngEC_PGBOXR As Range
Set rngEC_PGBOXR = Range(ExchangeColumn & RegionComboBoxRow)

Dim rngPGC_RCBOXR As Range
Set rngPGC_RCBOXR = Range(ProductGroupCodeColumn & RegionComboBoxRow)
            
Dim rngPC_RCBOXR As Range
Set rngPC_RCBOXR = Range(ProductColumn & RegionComboBoxRow)
            
Dim rngPTC_RCBOXR As Range
Set rngPTC_RCBOXR = Range(ProductTypeColumn & RegionComboBoxRow)

Dim rngCURR_RCBOXR As Range '-- EMOD 3.5 CURRENCY
Set rngCURR_RCBOXR = Range(CurrencyColumn & RegionComboBoxRow)

'----------------- REGION


If Me.cboRegion.Value = "" Then

    ComboBoxChange = False
    
    rngRC_RBOXR.Value = ""

    Me.cboProductGroupCode.ListFillRange = ""
    Me.cboProduct.ListFillRange = ""
    
    Me.cboExchange.ListFillRange = ""
  
    
    Call SetInvalidRange(rngRC_PC_RBOXR)
   
    ComboBoxChange = True
     
        MinCol = HeaderRowOffset
        MaxCol = ExchangeArrayUBound + HeaderRowOffset
    
        Me.cboExchange.ListFillRange = Exchange.Range("$" & RefDataExchangeColumn & "$" & MinCol _
                                       & ":$" & RefDataExchangeColumn & "$" & MaxCol).Address(External:=True)
       ComboBoxChange = True
Else
 
    ComboBoxChange = False
    
    rngRC_RBOXR.Value = Me.cboRegion.Value
    rngRC_RBOXR.Interior.ColorIndex = ValidColorIndexValue
    
    Call HideComboBoxesFast
    
    ExchangeComboBoxRow = RegionComboBoxRow
    'ActiveSheet.Range(ExchangeColumn & ExchangeComboBoxRow).Select '<<-check reg
    
    With Me.cboExchange
      
        .Top = Me.cboRegion.Top
      
        Call FormatComboBox("cboExchange", ExchangeColumn)
        
        .Visible = True
        
    End With

    For I = 0 To ExchangeArrayUBound
    
        If ExchangeArray(I, 0) = rngRC_RBOXR.Value Then
    
            MinCol = I + HeaderRowOffset
    
            Exit For
    
        End If
    
    Next I
    
    If I <= ExchangeArrayUBound Then
    
        If MinCol - 2 = ExchangeArrayUBound Then ' Blanket Region is last row and only one occurence
    
            MaxCol = MinCol
            
        Else

            For I = MinCol - 1 To ExchangeArrayUBound
            
                If ExchangeArray(I, 0) <> rngRC_RBOXR Then
            
                    MaxCol = I + (HeaderRowOffset - 1)
            
                    Exit For
            
                End If
            
            Next I
            
        End If
        
        '*** 11/18/13 'last region in table
        
        If I > ExchangeArrayUBound Then MaxCol = ExchangeArrayUBound + 2
        
        Me.cboExchange.ListFillRange = Exchange.Range("$" & RefDataExchangeColumn & "$" & MinCol _
                                       & ":$" & RefDataExchangeColumn & "$" & MaxCol).Address(External:=True)
        
        '*** 10/30/13 'Autofill Exchange if only one occurence
    
        If MinCol = MaxCol Then

            ComboBoxChange = True
             
            rngEC_PGBOXR = Exchange.Range("$" & RefDataExchangeColumn & "$" & MinCol).Value
            Me.cboExchange.Value = Exchange.Range("$" & RefDataExchangeColumn & "$" & MinCol).Value
            Me.cboExchange.ListIndex = 0
      
            Call HideComboBoxesFast
            
            '--- THIS IS HOW IT MOVES TO THE NEXT CBOX WITHOUT ANY ACTION IN SELECTION CHANGE OR CBOXES
            '--- IT SIMPLY HIDES ALL CBOXES (INCLUDING THE CURRENT ONE - REGION) AND THEN UNHIDES THE NEXT - EXCHANGE BELOW
            
            Dim rngPGC_Cbox As Range
            Set rngPGC_Cbox = Range(ProductGroupCodeColumn & ProductGroupCodeComboBoxRow)
            
            ProductGroupCodeComboBoxRow = ExchangeComboBoxRow
            
            With Me.cboProductGroupCode
           
               .Top = Me.cboExchange.Top
                
               Call FormatComboBox("cboProductGroupCode", ProductGroupCodeColumn)
               
               .Visible = True
            
               .Value = rngPGC_Cbox.Value
            
            End With

        
        Else
        
            '*** 11/5/13 If Region is changed set all dependent columns and comboboxs to blank
            
            If Me.cboRegion.Value = AutoFillRegion Then
            
                AutoFillRegion = ""
                
            Else
            
                Me.cboExchange.Value = ""
                
            End If
            
            Me.cboProductGroupCode.Value = ""
            Me.cboProduct.Value = ""
            
            'Me.cboExchange.ListFillRange = ""
            Me.cboProductGroupCode.ListFillRange = ""
            Me.cboProduct.ListFillRange = ""
            
            rngEC_PGBOXR.Value = ""
            rngPGC_RCBOXR.Value = ""
            rngPC_RCBOXR.Value = ""
            rngPTC_RCBOXR.Value = ""
            rngCURR_RCBOXR.Value = "" '--- EMOD 3.5
            
            '*** 11/5/13
            
        End If
    
        '*** 10/30/13 'Autofill Exchange if only one occurence
        
        rngRC_RBOXR = Me.cboRegion.Value
        
        ComboBoxChange = True
        
    Else
        
        ComboBoxChange = True

        Me.cboExchange.ListFillRange = ""

        rngRC_RBOXR = Me.cboRegion.Value

        Me.cboRegion.Value = ""
      
    End If

End If


On Error Resume Next
Set rngRC_PC_RBOXR = Nothing
Set rngRC_RBOXR = Nothing
Set rngEC_PGBOXR = Nothing
Set rngPGC_RCBOXR = Nothing
Set rngPC_RCBOXR = Nothing
Set rngPTC_RCBOXR = Nothing
Set rngCURR_RCBOXR = Nothing
On Error GoTo 0
 ' MsgBox "Error on cbox setup in selection change for target: " + Target.Address, vbCritical

Exit Sub
'============ normal exit

VBAErrorHandler:

 Select Case Err.Number

         Case 9:    ' Error 9 - SUBSCRIPT OUT OF RANGE - THE ARRAYS FOR PRODUCTS, GRP AND REGIONS
                       
                         
            MsgBox "Products internal list is empty - will reinitialize next.", , title2
            Call eModule.WorkbookOpen1
         
                 
         Case Else:      ' An error other than 68, 75 or 76 has occurred.
            ' Display the error number and the error text.
            MsgBox "Error # " & CStr(Err.Number) & ": " & Err.Description, vbCritical, title1 + "-" + Err.Description

 End Select

On Error GoTo 0




End Sub


Private Sub cboSpreadType_Change()

    Call StaticDataComboBox_Change("cboSpreadType", SpreadTypeColumn) ', SpreadTypeComboBoxHeight, SpreadTypeComboBoxWidth)
    
End Sub

Private Sub cboTierValueType_Change()

    Call StaticDataComboBox_Change("cboTierValueType", TierValueTypeColumn) ', StartTypeComboBoxHeight, StartTypeComboBoxWidth)

End Sub

Private Sub cboTradeType_Change()

    Call StaticDataComboBox_Change("cboTradeType", TradeTypeColumn) ', TradeTypeComboBoxHeight, TradeTypeComboBoxWidth)

End Sub


'--- END OF CBOX CHANGES


Public Sub NPcellContentsDisplay(targ As Range)  '-- receives target from selection change
   '-- navigation panel cell contents & coord display
   
   Dim celMsg As String
   Dim colNumber As Long
   Dim celColumn As String
   Dim celRow As String
   Dim celAddr As String
   Dim celData As String
   
   
   If Selection.Count > 1 Then
     celMsg = "Range of cells selected: " + Selection.Address
     frmNavigationPanel.txtMsg = celMsg
     Exit Sub
   End If
      
   
   celAddr = targ.Address
   frmNavigationPanel.TxtRange = celAddr '--show the current cells range in the nav form
   '-- what column name
 
   celColumn = Module1.getColumnLetter(celAddr)
   
   celRow = Module1.getColumnRow(celAddr)
 
   colNumber = ModuleSheet.Range(celColumn & 1).Column
   
  
   If IsNumeric(ActiveCell.Value) Then
      celData = format(ActiveCell.Value, Module1.decimalFormat1)
     Else
      celData = CStr(ActiveCell.Value)
   End If
   
   If Trim(celData) = "" Then
      celData = "(empty)"
   End If
   
   celMsg = eModuleColumnsNames(colNumber) + "@Row " + celRow + vbLf + celData
   frmNavigationPanel.txtMsg = celMsg
   
 End Sub



'-------------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Range)
'------------------------------------------------------------------- MAYBE THE MOST IMPORTANT CODE IN THE EMOD

On Error GoTo VBAErrorHandler

Dim cel As Range
Dim addr As String
Dim tmpVal As String

Application.StatusBar = ""
Dim celColumn As String
Dim celRow As String
Dim colNumber As Long
Dim celData As String
Dim celAddr As String

Dim debugMsg As String
'debugMsg = "Worksheet Selection Status 1-TARGET:  " + CStr(Target.Address) + _
           ", 2-CELVAL:  " + Mid(CStr(ActiveCell.Value), 1, 15) + ", 3-CUTCOPY: " + CStr(cutCopyMode) + _
           ", 4-PQTDISCBOX: " + CStr(Module1.PQTinUseDisableCboxes) + ", 5-DISWKSELCH=" + CStr(Module1.disableWorksheetSelectionChange) + ", 6-LRATE: " + lastRateType1
        
'Application.StatusBar = debugMsg

'-- NOTE - THE ORDER OF EXIT SUBS BELOW MATTERS - ALL EXIT THE SUB SINCE WE DONT WANT OR NEED SEL CHG

If disableWorksheetSelectionChange Then
   '--- avoid circular calls to SelectionChange -> stack overflow or slow code or undesired updates
   Exit Sub
End If

'--- 3/7/16 - move to top Target.row < 4, else if we choose merge headings there is no protection

If Target.row = (Module1.ModuleFirstRow - 1) Then

   '--- 3/11/16 - REG - LET USER NAVIGATE TO ICONS FASTER FROM ALL PLACES - PRESS ON EMPTY ROW3

   addr = "A" + CStr(Module1.ModuleFirstRow) '-- move to same col row 4
   Range(addr).Select
  '--- select the CP icon
   btnOpenControlPanel.Activate
   Exit Sub
   
ElseIf Target.row < (Module1.ModuleFirstRow - 1) Then  '-- no need for headings
     
   '--- this action protects the headings without using frozen cols etc which limit the use of excel
   '--- use this to quickly navigate to icons near a4
   
   addr = Module1.ConvertToExcelColumnLetter(Target.Column) + CStr(ModuleFirstRow) '-- move to same col row 4
   Range(addr).Select
   '--- 3/7/16-reg - removed anoying action - move to the col below 1st row (same col) not to first cell which is confusing
  
   Exit Sub
End If

'--- merged celle or regions
If Selection.Cells.Count > 1 Then  '-- not a cell
   Exit Sub
End If

'--- REG - LOGIC - NOTE THE TARGET RANGE IS PASSED (ADDR OF THE CELL) - THUS IT IS FIXED FOR THE ENTIRE SUB AFTER A CALL

Dim cutCopyMode As Boolean
'cutCopyMode = Application.cutCopyMode = xlCopy Or Application.cutCopyMode = xlCut

If cutCopyMode Then
   '-- this simply bypasses the sel change when we have copy or cut
   'Exit Sub
   '--- commented out - reg - 3-9-16 - we need to enable cboxes to pasted data
End If


'--- if the NP is open we display the status there, else on the excel status bar

If isUserFormLoaded(NP) Then
   
   Call NPcellContentsDisplay(Target)
   
   '--- emod 3.5 Navigation panel updates with cell column name and row and contents in txt box message
 Else
   
   '--- 3/11/16-reg -code from NP, show status when no NP on - excel status bar
   celAddr = Target.Address
   celColumn = Module1.getColumnLetter(celAddr)
   celRow = Module1.getColumnRow(celAddr)
   colNumber = ModuleSheet.Range(celColumn & 1).Column
   
   If IsNumeric(ActiveCell.Value) Then
      celData = format(ActiveCell.Value, Module1.decimalFormat1)
     Else
      celData = CStr(ActiveCell.Value)
   End If
   
   If Trim(celData) = "" Then
      celData = "(empty)"
   End If
   
   Application.StatusBar = eModuleColumnsNames(colNumber) + "@Row " + celRow + " -- " + celData
 
End If



'Application.StatusBar = "Worksheet_SelectionChange: TARGET - " + Target.Address

'=========== IMPORTANT: IF GLOBAL FLAG disableWorksheetSelectionChange IS TRUE WE DO NOT DO  Worksheet_SelectionChange



'@@@@@@ - REG - TEST /DEV PHASE -REMOVE AT END - 6/9/15


'--- NEW EMOD 3.5 SHADING OPTION
If Module1.eModShadeTurnedOn Then
   
   Call ModuleSheet.eModCurrentRowShade

End If

Dim I As Long

MinCol = 0
MaxCol = 0

Call Module1.SetLastRow '--- need the array limits

   
'--- reg - keep out of the select loop variables we can inti once
Dim trow As Long
trow = Target.row
Dim ttop As Long
ttop = Target.Top


RegionComboBoxRow = trow
ExchangeComboBoxRow = trow
ProductGroupCodeComboBoxRow = trow
ProductComboBoxRow = trow
ComboBoxTop = ttop

'--- EMOD 3.5 NEED THE RATE TYPE TO HANDLE ALL LINES OF VOL DIS OR BANDS (FORMULAS ETC)


If RegionColumn = "" Then '-- a kind of reset to avoid common debug errors
    Call Module1.loadColumnVariables
End If

Dim rngRC_RCB As Range
Dim rngEC_RCB As Range
Dim rngPGC_RCB As Range
Dim rngPC_RCB As Range
Dim rngRC_TROW As Range
Dim rngEC_TROW As Range
Dim rngPGC_TROW As Range
Dim rngPC_TROW As Range
'--- 2/23/16-need vars for banding
Dim firstBandLineBln As Boolean
Dim bandStartEndInt As Boolean
Dim bandTier_Current As Integer


If trow < ModuleFirstRow Then

    If (Not Module1.sortOnFlag) And (Not Module1.invalidRowFlag) Then '--avoid these messages
       invalidRowFlag = True
       MsgBox "Invalid Row - Please Select Row " & ModuleFirstRow & " or Greater", vbCritical, title1
    End If
    
    'Call Module1.SelectFirstCell '-- SINCE WE ALLOW THEM TO CLICK ON ROWS 1-4 WE GIVE
    'A MESSAGE THE 1ST TIME, BUT AT ANY TIME WE MOVE THEM TO THE 1ST CELL SO THAT THEY CAN
    'NOT ERASE ANYTHING THER
    
    '@@@ - REG FOR DEVE - TESTING - REMOVE EMOD 3.5
    
  ElseIf ((Target.Column > ModuleSheetNumberOfColumns) And (Target.Count < LastSheetColumnNumber)) Then

    MsgBox "Invalid Column - Please Select Column " & LastColumn & " or to the Left", vbCritical, title1
 

 Else
'============== valid row

   '--- NOTE ONE SET IS WITH THE REGION CBOX ROW
      
   Set rngRC_RCB = Range(RegionColumn & RegionComboBoxRow)
   Set rngEC_RCB = Range(ExchangeColumn & RegionComboBoxRow)
   Set rngPGC_RCB = Range(ProductGroupCodeColumn & RegionComboBoxRow)
   Set rngPC_RCB = Range(ProductColumn & RegionComboBoxRow)
   
   '--- NOTE ONE SET IS WITH THE TARGET ROW - THE CURRENT CELLS ROW
   
   Set rngRC_TROW = Range(RegionColumn & trow)
   Set rngEC_TROW = Range(ExchangeColumn & trow)
   Set rngPGC_TROW = Range(ProductGroupCodeColumn & trow)
   Set rngPC_TROW = Range(ProductColumn & trow)
 
   '----- SELECT CASE - WILL JUMP ACCORDING TO THE VALUE IN THE - Target.Column - THE COLUMN NUMBER OF THE CURRENT CELL THE USER SELECTED
   '----- Conditions that are evaluated in the order listed.
   '----- Once a condition is found to be true, it will execute the corresponding code and not evaluate the conditions any further.
   
   '----- HOW THE MODULE WORKS - REG - IMPORTANT KEY OBSERVATION:
   '----- WHEN THE USER CLICKS ON AN EXCEL CELL (EMODULE) - ALL THE CBOXES ARE HIDDEN - THUS THE Worksheet_SelectionChange EVENT ACTIVATES
   '----- THEN WE PASS VIA THIS EVENT THE INFO TO THE CORRESPONDING (COLUMN - Target.Column) CBOX  PER THE CODE BELOW AND THE CBOX BECOMES VISIBLE WITH THE CONTENTS (IF ANY) OF THE CELL
   '----- NOTE THAT SINCE THE CBOX IS SIZED AS THE CELL (FormatComboBox) - IT WILL COVER THE CONTENTS. ALSO IF ONE CLICKS ON A CBOX - THE SelectionChange IS *NOT* TRIGERRED.
   '----- IT IS BASICALLY AN OPTICAL ILLUSION - THE USER CLICKS ON THE CELL - BUT SINCE THE CBOX COMES UP FAST - THE IMPRESSION IS THAT ONE CLICKED ON THE CBOX
   '----- REGARDING CBOXES - STYLE 0 WILL NOT SHOW THE DROP DOWN UNTIL ONE CLICKS ON THE ARROW, STYLE 2 SHOWS THE CONTENTS WHEN CLICKING IN THE CBOX CONTENTS
   '----- WHEN THE USER CLICKS ON ANOTHER CELL - THE CBOX THAT WAS OPEN IS CLOSED SINCE - HideComboBoxesFast - HIDES ALL CBOXES IN THE SPREADSHEET.
 
   '------------------------
   Select Case Target.Column
   '------------------------ main case loop for each column
     
     Case RegionColumnNumber
     '------------------------- REGION
           
        ComboBoxChange = False
     
        Module1.currentCboName = "cboRegion"
        Module1.currentCboColumn = RegionColumnNumber
        
        If debugStatusMsg Then MsgBox debugMsg, , "Region: " + CStr(RegionColumnNumber)
        
        
        '--- NEW EMOD 3.5 LOGIC - REMOVE THE DEFAULTS FROM ASIA...
        
        
         Module1.eModNewLineFlag = Module1.eModNewLine(Target.row, RegionColumn) '-register id the current row is a new line (empty)
        
        If eModNewLineFlag Then
           '--- FOR A NEW LINE - EMPTY ALL CBOXES - EMOD 3.5 KEY CODE TO ENABLE DROP DOWNS STYLE 2 ON ALL MAJOR DATA ITEMS - REGION TO PROD, ONLY FOR NEW OR EMPTY CELLS
           Me.cboRegion.Style = 2
           Me.cboExchange.Style = 2
           Me.cboProductGroupCode.Style = 2
           Me.cboProduct.Style = 2
           Me.cboCurrency.Style = 2
           
           'Me.cboRegion.Value = ""
          ' Me.cboExchange.Value = ""
           'Me.cboProductGroupCode.Value = ""
           'Me.cboProduct.Value = ""
           'Me.cboCurrency.Value = ""
           
            'debugMsg = debugMsg + ", 5-REGN-NEWL: " + CStr(Module1.eModNewLineFlag) + " Style#2"
          Else
            'debugMsg = debugMsg + ", 5-REGN-NEWL: " + CStr(Module1.eModNewLineFlag) + " Style#0"
        End If
        'Application.StatusBar = debugMsg
        
        'If (IsEmpty(ActiveCell.Value) Or Trim(ActiveCell.Value) = "") And rngRC_TROW.Value = "" Then
        '   Me.cboRegion.Style = 2 '-- calls cboRegion_change
        '   Me.cboRegion.Value = ""
        '  Else
        '   Me.cboRegion.Style = 0
       ' End If
        
        
        If rngRC_RCB.Value <> "" Then
        
            If rngEC_RCB.Value = "" Then
              
              Call SetInvalidRange(rngEC_RCB)
  
            End If
            
            If rngPGC_RCB.Value = "" Then
    
                Call SetInvalidRange(rngPGC_RCB)
   
            End If
            
            If rngPC_RCB.Value = "" Then
    
                Call SetInvalidRange(rngPC_RCB)
                
            End If
        
        End If
         
            
         Call HideComboBoxesFast
         
         With Me.cboRegion
            
            .Top = ttop
            
            Call FormatComboBox("cboRegion", RegionColumn)
           
            .Value = rngRC_TROW.Value
            
            .Visible = True
           
        End With
        
        RegionComboBoxRow = trow
        ComboBoxTop = ttop
      
        rngRC_TROW.Value = Me.cboRegion.Value
      
        ComboBoxChange = True
   
    
     Case ExchangeColumnNumber
     '------------------------------- EXCHANGE (UNDER REGION)
   
        ComboBoxChange = False
        
        Module1.currentCboName = "cboExchange"
        Module1.currentCboColumn = ExchangeColumnNumber
        
         Module1.eModNewLineFlag = Module1.eModNewLine(Target.row, ExchangeColumn) '-register id the current row is a new line (empty)
        
        If eModNewLineFlag Then
           '--- FOR A NEW LINE - EMPTY ALL CBOXES - EMOD 3.5 KEY CODE TO ENABLE DROP DOWNS STYLE 2 ON ALL MAJOR DATA ITEMS - REGION TO PROD, ONLY FOR NEW OR EMPTY CELLS
        
           Me.cboExchange.Style = 2
           Me.cboProductGroupCode.Style = 2
           Me.cboProduct.Style = 2
           Me.cboCurrency.Style = 2
           
        
           'Me.cboExchange.Value = ""
           'Me.cboProductGroupCode.Value = ""
           'Me.cboProduct.Value = ""
           'Me.cboCurrency.Value = ""
           
           'debugMsg = debugMsg + ", 6-EXCH-NEWL: " + CStr(Module1.eModNewLineFlag) + " Style#2"
          Else
           'debugMsg = debugMsg + ", 6-EXCH-NEWL: " + CStr(Module1.eModNewLineFlag) + " Style#0"
           
        End If
        'Application.StatusBar = debugMsg
        
        If rngRC_RCB.Value <> "" Then
        
            If rngEC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngEC_RCB)
                
            End If
            
            If rngPGC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngPGC_RCB)
            
            End If
            
            If rngPC_RCB.Value = "" Then
                            
                Call SetInvalidRange(rngPC_RCB)
                
            End If
        
        End If
        
              
        Call HideComboBoxesFast
        
           'MsgBox "TEST Case ExchangeColumnNumber"
        
        With Me.cboExchange
            
            .Top = ttop
            
            Call FormatComboBox("cboExchange", ExchangeColumn)
         
            If rngEC_TROW.Value <> "" Then
               .Style = 0
            End If
         
            .Value = rngEC_TROW.Value
         
            .Visible = True
         
        End With
        
        ExchangeComboBoxRow = trow
        ComboBoxTop = ttop
    
        If rngRC_TROW.Value = "" Then
            
            MinCol = HeaderRowOffset
            MaxCol = ExchangeArrayUBound + HeaderRowOffset
                     
            Me.cboExchange.ListFillRange = Exchange.Range("$" & RefDataExchangeColumnSorted & "$" & MinCol _
                                           & ":$" & RefDataExchangeColumnSorted & "$" & MaxCol).Address(External:=True)
          
        Else
          
            For I = 0 To ExchangeArrayUBound

                If ExchangeArray(I, 0) = rngRC_TROW.Value Then
            
                    MinCol = I + HeaderRowOffset
            
                    Exit For
            
                End If
            
            Next I
            
            If I <= ExchangeArrayUBound Then
    
                If MinCol - 2 = ExchangeArrayUBound Then ' Blanket Region is last row and only one occurence
            
                    MaxCol = MinCol
                    
                Else
        
                    For I = MinCol - 1 To ExchangeArrayUBound
                    
                        If ExchangeArray(I, 0) <> rngRC_TROW.Value Then
                    
                            MaxCol = I + (HeaderRowOffset - 1)
                    
                            Exit For
                    
                        End If
                    
                    Next I
                    
                End If
                
        
                If I > ExchangeArrayUBound Then
                   MaxCol = ExchangeArrayUBound + 2
                End If
                
                Me.cboExchange.ListFillRange = Exchange.Range("$" & RefDataExchangeColumn & "$" & MinCol _
                                               & ":$" & RefDataExchangeColumn & "$" & MaxCol).Address(External:=True)

                ComboBoxChange = True
                
                If rngEC_TROW.Value = "" Then

                    Me.cboExchange.Value = ""
                Else
                    'Me.cboExchange.Style = 0 '--- EMOD 3.5
                    Me.cboExchange.Value = rngEC_TROW.Value
                    
                End If
                
                rngEC_TROW.Value = Me.cboExchange.Value
                
            Else
            
                ComboBoxChange = True
                    
                Me.cboExchange.ListFillRange = ""
                  
                rngRC_TROW.Value = Me.cboExchange.Value
                
                Me.cboExchange.Value = ""
                
            End If

        End If
        
    Case ProductGroupCodeColumnNumber
    '---------------------------------------- PRODUCT GROUP (UNDER REGION AND EXCHANGE)
    
        ComboBoxChange = False
     
        If debugStatusMsg Then MsgBox debugMsg, , "ProductGroupCode: " + CStr(ProductGroupCodeColumnNumber)
            
        Module1.currentCboName = "cboProductGroupCode"
        Module1.currentCboColumn = ProductGroupCodeColumnNumber
        
        If rngRC_RCB.Value <> "" Then
        
            If rngEC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngEC_RCB)
            
            End If
            
            If rngPGC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngPGC_RCB)
                
            End If
            
            If rngPC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngPC_RCB)
                
            End If
        
        End If
        
        Call HideComboBoxesFast
        
        With Me.cboProductGroupCode
            
            .Top = ttop
            
            Call FormatComboBox("cboProductGroupCode", ProductGroupCodeColumn)
          
            .Style = 0 '-- EMOD 3.5
            
            .Value = rngPGC_TROW.Value
           
            .Visible = True
          
        End With

    
        If ((rngRC_TROW.Value = "") Or _
            (rngEC_TROW.Value = "")) Then
                       
            Me.cboProductGroupCode.ListFillRange = ""
        
            ComboBoxChange = True

        Else
            
            For I = 0 To ProductGroupCodeArrayUBound
  
                If ((ProductGroupCodeArray(I, 0) = rngRC_TROW.Value) And _
                    (ProductGroupCodeArray(I, 1) = rngEC_TROW.Value)) Then
            
                    MinCol = I + HeaderRowOffset
            
                   Exit For
            
                End If
            
            Next I
            
            If I <= ProductGroupCodeArrayUBound Then
    
                If MinCol - 2 = ProductGroupCodeArrayUBound Then ' Blanket Exchange is last row and only one occurence
    
                    MaxCol = MinCol
                         
                Else

                    For I = MinCol - 1 To ProductGroupCodeArrayUBound
                            
                        If ((ProductGroupCodeArray(I, 0) <> rngRC_TROW.Value) Or _
                            (ProductGroupCodeArray(I, 1) <> rngEC_TROW.Value)) Then
                    
                            MaxCol = I + (HeaderRowOffset - 1)
                    
                            Exit For
                    
                        End If
                    
                    Next I
                
                    If I > ProductGroupCodeArrayUBound Then
                    
                        MaxCol = ProductGroupCodeArrayUBound + 2
                        
                    End If
            
                End If

               Me.cboProductGroupCode.ListFillRange = ProductGroupCode.Range("$" & RefDataProductGroupCodeColumn & "$" & MinCol _
                                                      & ":$" & RefDataProductGroupCodeColumn & "$" & MaxCol).Address(External:=True)
        
               If rngPGC_TROW.Value = "" Then

                   Me.cboProductGroupCode.Value = ""
                   
               Else
                   Me.cboProductGroupCode.Style = 0 '-- EMOD 3.5
                   Me.cboProductGroupCode.Value = rngPGC_TROW.Value
                   
               End If
               
               rngPGC_TROW.Value = Me.cboProductGroupCode.Value
               
            Else
            
                ComboBoxChange = True
                    
                Me.cboProductGroupCode.ListFillRange = ""
                  
                rngPGC_TROW.Value = Me.cboProductGroupCode.Value
                
                Me.cboProductGroupCode.Value = ""
                
            End If
  
            ComboBoxChange = True
  
        End If
                   
    Case ProductColumnNumber
    '------------------------------ PRODUCT (UNDER REGION AND EXCHANGE AND PROD GRP)
    
        ComboBoxChange = False
    
        If debugStatusMsg Then MsgBox debugMsg, , "ProductColumnNumber: " + CStr(ProductColumnNumber)
      
        Module1.currentCboName = "cboProduct"
        Module1.currentCboColumn = ProductColumnNumber
        
            
        If rngRC_RCB.Value <> "" Then
        
            If rngEC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngEC_RCB)
                
            End If
            
            If rngPGC_RCB.Value = "" Then
            
                Call SetInvalidRange(rngPGC_RCB)
                
            End If
            
            If rngPC_RCB.Value = "" Then
                
                Call SetInvalidRange(rngPC_RCB)
                
            End If
        
        End If
        
        '*** 11/19/13
        
        Call HideComboBoxesFast
            
        With Me.cboProduct
         
          
            .Top = ttop
            
            Call FormatComboBox("cboProduct", ProductColumn)
            
            .Style = 0 '-- EMOD 3.5
            
            .Value = Range(ProductColumn & trow).Value
                     
            .Visible = True
            
        End With
     
        ProductComboBoxRow = trow
        ComboBoxTop = ttop
    
        If ((rngRC_TROW.Value = "") Or _
            (rngEC_TROW.Value = "") Or _
            (rngPGC_TROW.Value = "")) Then
            
            Me.cboProduct.ListFillRange = ""
        
            ComboBoxChange = True
            
        Else
            
                    
            For I = 0 To ProductArrayUBound
  
                If ((ProductArray(I, 0) = rngRC_TROW.Value) And _
                    (ProductArray(I, 1) = rngEC_TROW.Value) And _
                    (ProductArray(I, 2) = rngPGC_TROW.Value)) Then
            
                    MinCol = I + HeaderRowOffset
            
                    Exit For
            
                End If
            
            Next I
            
            If I <= ProductArrayUBound Then
        
                If MinCol - 2 = ProductArrayUBound Then ' Blanket Exchange is last row and only one occurence
            
                    MaxCol = MinCol
                    
                Else
        
                    For I = MinCol - 1 To ProductArrayUBound
                            
                        If ((ProductArray(I, 0) <> rngRC_TROW.Value) Or _
                            (ProductArray(I, 1) <> rngEC_TROW.Value) Or _
                            (ProductArray(I, 2) <> rngPGC_TROW.Value)) Then
                    
                            MaxCol = I + (HeaderRowOffset - 1)
                    
                            Exit For
                    
                        End If
                    
                    Next I
         
                    If I > ProductArrayUBound Then
                       MaxCol = ProductArrayUBound + 2
                    End If
                    
                    
                End If
        
                Me.cboProduct.ListFillRange = Product.Range("$" & RefDataProductColumn & "$" & MinCol _
                                              & ":$" & RefDataProductColumn & "$" & MaxCol).Address(External:=True)
                                
                If rngPC_TROW.Value = "" Then

                   Me.cboProduct.Value = ""
                   
                Else
                    Me.cboProduct.Style = 0 '-- EMOD 3.5
                    Me.cboProduct.Value = rngPC_TROW.Value
                   
                End If
               
                rngPC_TROW.Value = Me.cboProduct.Value
                                 
            Else
                
                ComboBoxChange = True
                    
                Me.cboProduct.ListFillRange = ""
                
                rngPC_TROW.Value = Me.cboProduct.Value
                
                Me.cboProduct.Value = ""
                
            End If
                  
            ComboBoxChange = True
  
        End If
        
        
   '---- SPECIAL CASES
   
     
     Case ProductTypeColumnNumber '-- READ ONLY FIELD - CAN NOT CHANGE
     
          ActiveCell.Cells.Offset(0, 2).Select '- FORCE A SKIP TO THE NEXT NON-CURRENCY MAIN FIELD - 2 CELLS TO THE RIGHT - (0,2)
          
          If Not productTypeMessageFlag Then
             productTypeMessageFlag = True
             MsgBox "The Product TYPE column is READ ONLY -- it can not be changed.", vbExclamation, title1
          End If
   
     Case CurrencyColumnNumber
    
        If debugStatusMsg Then MsgBox debugMsg, , "CurrencyColumnNumber: " + CStr(CurrencyColumnNumber)
    
         Call SelectStaticDataColumn(Target, "cboCurrency", CurrencyColumn)
 
    Case DirectBillColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboDirectBill", DirectBillColumn) ', DirectBillComboBoxHeight, DirectBillComboBoxWidth) <-- COMMENTED OUT-REG-NOT USED ANYMORE
      
    Case TradeTypeColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboTradeType", TradeTypeColumn) ', TradeTypeComboBoxHeight, TradeTypeComboBoxWidth)
    
    Case SpreadTypeColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboSpreadType", SpreadTypeColumn) ', SpreadTypeComboBoxHeight, SpreadTypeComboBoxWidth)
        
    Case RateTypeColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboRateType", RateTypeColumn) ', RateTypeComboBoxHeight, RateTypeComboBoxWidth)
         
        '--- EMOD 3.5 NEED TO GET INFO ON WHERE IS THE 1ST ROW FOR VOL DIS OR BAND TO FIND THE RATE TYPE FOR A EMO WITH EXISTING VOL DISC/BAND LINES
         
        If Trim(Target.Value) <> "" Then
          lastRateType1 = Target.Value '-- only 1st line for vol disc/band has the rate type
        End If
       
        
    Case ExecutionTypeColumnNumber
    
        'If debugStatusMsg Then MsgBox debugMsg, , "ExecutionTypeColumnNumber: " + CStr(ExecutionTypeColumnNumber)
         
        Call SelectStaticDataColumn(Target, "cboExecutionType", ExecutionTypeColumn) ', ExecutionTypeComboBoxHeight, ExecutionTypeComboBoxWidth)
        
    Case DefaultExecutionTypeColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboDefaultExecutionType", DefaultExecutionTypeColumn) ', DefaultExecutionTypeComboBoxHeight, DefaultExecutionTypeComboBoxWidth)
    
    Case MMApplyColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboMMApply", MMApplyColumn) ', MMApplyComboBoxHeight, MMApplyComboBoxWidth)
    
    Case MMDefineColumnNumber '--- eMod 3.5
    
        Call SelectStaticDataColumn(Target, "cboMMDefine", MMDefineColumn)
    
    Case AddOnApplyColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboAddOnApply", AddOnApplyColumn) ', AddOnApplyComboBoxHeight, AddOnApplyComboBoxWidth)
     
    Case TierDefinedBasedColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboDefinedTiersBased", TierDefinedBasedColumn) ', DefinedTiersBasedComboBoxHeight, DefinedTiersBasedComboBoxWidth)
        
    Case TierApplyToColumnNumber
    
        Call SelectStaticDataColumn(Target, "cboApplyTo", TierApplyToColumn) ', ApplyToComboBoxHeight, ApplyToComboBoxWidth)
         
    '--- EMOD 3.5 NEW FIELDS - NOTE WE USE THE COLUMN NUMBER
    
    Case TierValueTypeColumnNumber '--- eMod 3.5
    
        Call SelectStaticDataColumn(Target, "cboTierValueType", TierValueTypeColumn)
     
         
    Case BandApplyColumnNumber '--- eMod 3.5
    
        Call SelectStaticDataColumn(Target, "cboBandApply", BandApplyColumn)
        
    Case BandValueTypeColumnNumber '--- eMod 3.5
    
        Call SelectStaticDataColumn(Target, "cboBandValueType", BandValueTypeColumn)
        
         Set cel = Target
         tmpVal = Trim(cel.Value)
            
         If (tmpVal <> "") Then '-- got a value, BPS, Num cont as integer start/end
        
            BandValueType_Current = tmpVal
         End If
         
    
    Case BandRateTypeColumnNumber '--- eMod 3.5
    
        Call SelectStaticDataColumn(Target, "cboBandRateType", BandRateTypeColumn)
     
    '-- BIG CHANGE FROM EMO 3.4 - NOW WE ALSO CHECK/PRELOAD OR DO NUJMERIC FORMATS FOR NUMERIC CELLS
    
    '-- EMOD 3.5 NEW SPECIAL CASES - NEED TO PRELOAD VALUES FOR BANDING
    
    '-- ALSO WE NEED TO FORMAT PROPERLY INTEGER VS DECIMAL AT DATA ENTRY

    Case MMMinAmountColumnNumber
          
          Set cel = ActiveCell
          If IsNumeric(cel.Value) Then
             cel.NumberFormat = Module1.decimalFormat2 '--decimal
          End If
          Set cel = Nothing
    
    
     Case MMMaxAmountColumnNumber
          
          Set cel = ActiveCell
          If IsNumeric(cel.Value) Then
             cel.NumberFormat = Module1.decimalFormat2 '--decimal
          End If
          Set cel = Nothing
    
     Case AddOnAmountColumnNumber
          
          Set cel = ActiveCell
          If IsNumeric(cel.Value) Then
             cel.NumberFormat = Module1.decimalFormat2 '--decimal
          End If
          Set cel = Nothing
    

    
    Case TiersColumnNumber '--  "Vol Disc Tier #" - integer
    
       lastRateType1 = Module1.getCurrentRateType(ActiveCell)
    
       If lastRateType1 = VolumeDiscountRateType Then
       '--- need to be careful no to erase existing data
            
            '--- for tier simply increase the number above (if cell is empty)
            Set cel = ActiveCell
            If cel.Offset(0, -1).Value <> "" Then
                tmpVal = "0" '-- first line has data on the left side
               Else
                tmpVal = Trim(cel.Offset(-1, 0).Value)
            End If
            
            If IsNumeric(tmpVal) And cel.Value = "" Then '-if no input and cel above is numeric
               cel.Value = CLng(tmpVal) + 1
               cel.NumberFormat = Module1.decimalFormat0 '--INTEGER
            End If
            Set cel = Nothing
        
        End If
    
     Case AmountColumnNumber  '--- NOW BROKERAGE AMOUNT (EMPTY FOR BAND OR VOL DISC)
          
          Set cel = ActiveCell
          If IsNumeric(cel.Value) And cel.Value <> "" Then
             cel.NumberFormat = Module1.decimalFormat2 '--decimal
          End If
          Set cel = Nothing
    
     Case TierStartNumberAmountColumnNumber '--  "Vol Disc Tier START" - integer, MUST BE 1 FOR TIER 1
    
       lastRateType1 = Module1.getCurrentRateType(ActiveCell)
    
       If lastRateType1 = VolumeDiscountRateType Then
       '--- need to be careful no to erase existing data
            
            '--- for tier simply increase the number above (if cell is empty)
            Set cel = ActiveCell
            If cel.Offset(0, -1).Value = 1 Then '--ONLY FOR TIER#1
                cel.Value = 1 '-- first line has data on the left side
                cel.NumberFormat = Module1.decimalFormat0
            End If
         
            Set cel = Nothing
        
        End If
    
    
    
'--band columns
'Public BandApplyColumnNumber As Integer
'Public BandValueTypeColumnNumber As Integer
'Public BandTierNoColumnNumber As Integer
'Public BandStartColumnNumber As Integer
'Public BandEndColumnNumber As Integer
'Public BandRateTypeColumnNumber As Integer
'Public BandRateColumnNumber As Integer

    
    
    Case BandTierNoColumnNumber '-- integer
       '--- need to be careful no to erase existing data
       '--- offset doc: The number of rows (positive, negative, or 0 (zero)) by which the range is to be offset. Positive values are offset downward, and negative values are offset upward
       
       lastRateType1 = Module1.getCurrentRateType(ActiveCell)
       
       If lastRateType1 = BandingDiscountRateType Then
            
            Set cel = ActiveCell
            
            If Trim(cel.Offset(0, -1).Value) <> "" Then '-- band value type must be filled for tier 1
               firstBandLineBln = True
              Else
               firstBandLineBln = False
            End If
            
            BandValueType_Current = Module1.getCurrentBandRateType(ActiveCell)
         
            
            If InStr(BandStartEndIntegerTypes, BandValueType_Current) > 0 Then '-- BPS, NUMN CONT'S
               bandStartEndInt = True
              Else
               bandStartEndInt = False
            End If
            
            '--- for tier simply increase the number above (if cell is empty)
       
           
            If firstBandLineBln Then
            
               tmpVal = "0" '-- so it starts at 1
                           
             Else
             
               If IsNumeric(cel.Offset(-1, 0).Value) Then
                   tmpVal = cel.Offset(-1, 0).Value '--up above
               End If
               
            End If
            
            If IsNumeric(tmpVal) And cel.Value = "" Then '-if no input and cel above is numeric
            
               cel.Value = CLng(tmpVal) + 1
               cel.NumberFormat = Module1.decimalFormat0 '--INTEGER
               
            End If
            
            bandTier_Current = cel.Value
            
            Set cel = Nothing
            
        End If
        
      Case Module1.BandStartColumnNumber '-- same as prev row end + fixed value (1 or 0.00001)
     
  
       '--- need to be careful no to erase existing data
       
      lastRateType1 = Module1.getCurrentRateType(ActiveCell)
       
       If lastRateType1 = BandingDiscountRateType Then
       
       '--- for band start range - increase band end of prev line  and set the band end to 9999999 - user can overrride
            Set cel = ActiveCell
            '-- if we have data to the left side same row we are line 1 of band
           
            If cel.Offset(0, -1) <> "" Then '-- band start makes sense after we have a tier#,else ignore
              
              If Trim(cel.Offset(0, -2).Value) <> "" Then '-- band value type must be filled for tier 1
                 firstBandLineBln = True
                Else
                 firstBandLineBln = False
              End If
              
              '-- find it
              If Not firstBandLineBln Then
                 tmpVal = Trim(cel.Offset(-1, 1).Value) '-- note row above to right - only if line 2 or more
              Else
                 tmpVal = ""
              End If
            
              If BandValueType_Current = "" Then
                 BandValueType_Current = Module1.getCurrentBandRateType(ActiveCell)
              End If
              
              If InStr(BandStartEndIntegerTypes, BandValueType_Current) > 0 Then '-- BPS, NUMN CONT'S
                 bandStartEndInt = True
                Else
                 bandStartEndInt = False
              End If
               
              If (tmpVal = "") Then
                 tmpVal = "0"
              End If
              
              If IsNumeric(tmpVal) And bandStartEndInt Then
              '--- integer type
                If firstBandLineBln Then
                    If cel.Value = "" Then
                       cel.Value = 1 '-- start 1
                    End If
                    If cel.Offset(0, 1).Value = "" Then '--place value if cell is empty (dont erase)
                       cel.Offset(0, 1).Value = maxRateValueInteger
                    End If
                 Else
                    If cel.Value = "" Then
                       cel.Value = CDbl(tmpVal) + 1
                    End If
                    If cel.Offset(0, 1).Value = "" Then '--place value if cell is empty (dont erase)
                       cel.Offset(0, 1).Value = maxRateValueInteger
                    End If
                    
                End If
                
                 cel.NumberFormat = Module1.decimalFormat0 '--integer start
                 cel.Offset(0, 1).NumberFormat = Module1.decimalFormat0  '--integer end
                  
              End If
              
              If IsNumeric(tmpVal) And (Not bandStartEndInt) Then
               '--decimal type
                 If firstBandLineBln Then
                    If cel.Value = "" Then
                       cel.Value = 0 '-- start 0
                    End If
                    If cel.Offset(0, 1).Value = "" Then '--place value if cell is empty (dont erase)
                       cel.Offset(0, 1).Value = maxRateValue
                    End If
                 Else
                    If cel.Value = "" Then
                       cel.Value = CDbl(tmpVal) + Module1.minRateValue
                    End If
                    If cel.Offset(0, 1).Value = "" Then '--place value if cell is empty (dont erase)
                       cel.Offset(0, 1).Value = maxRateValue
                    End If
                 End If
                 
                 cel.NumberFormat = Module1.decimalFormat2 '--with decimal start
                 cel.Offset(0, 1).NumberFormat = Module1.decimalFormat2 '--with decimal end
             End If
            
           End If
           
            
            Set cel = Nothing
       
       
       End If
        
   
    Case Module1.BandRateColumnNumber
    
     Set cel = ActiveCell
     cel.NumberFormat = Module1.decimalFormat2 '--with decimal start
     Set cel = Nothing
         
    Case Else
    
        Call HideComboBoxesFast

   
End Select
'-------- ENDS CASE, IF




End If


On Error Resume Next
Set rngRC_RCB = Nothing
Set rngEC_RCB = Nothing
Set rngPGC_RCB = Nothing
Set rngPC_RCB = Nothing

Set rngRC_TROW = Nothing
Set rngEC_TROW = Nothing
Set rngPGC_TROW = Nothing
Set rngPC_TROW = Nothing
On Error GoTo 0 '-- reset errors

Application.EnableEvents = True



Exit Sub
'------------- normal processing
  
 ' MsgBox "Error on cbox setup in selection change for target: " + Target.Address, vbCritical
 
VBAErrorHandler:

 Select Case Err.Number

         Case 9:    ' Error 9 - SUBSCRIPT OUT OF RANGE - THE ARRAYS FOR PRODUCTS, GRP AND REGIONS
                       
                         
            MsgBox "Products internal list is empty - will reinitialize next.", , title2
            Call eModule.WorkbookOpen1
         
                
         Case Else:      ' An error other than 68, 75 or 76 has occurred.
            ' Display the error number and the error text.
            MsgBox "Error # " & CStr(Err.Number) & ": " & Err.Description, vbCritical, title1 + "-" + Err.Description

 End Select

On Error GoTo 0 '--

End Sub


Sub ProcessExchangeChange()
'-------------------------

Dim I As Long

Dim AllFlag As Boolean
AllFlag = False

'--- BELOW ARE ALL THE PREVIOUS FIELDS RELATED TO THE EXCH IN THE SAME ROW

Dim rngRC_ECBOXR As Range
Set rngRC_ECBOXR = Range(RegionColumn & ExchangeComboBoxRow)

Dim rngEC_ECBOXR As Range
Set rngEC_ECBOXR = Range(ExchangeColumn & ExchangeComboBoxRow)

Dim rngPGC_ECBOXR As Range
Set rngPGC_ECBOXR = Range(ProductGroupCodeColumn & ExchangeComboBoxRow)

Dim rngPC_ECBOXR As Range
Set rngPC_ECBOXR = Range(ProductColumn & ExchangeComboBoxRow)

Dim rngPTC_ECBOXR As Range
Set rngPTC_ECBOXR = Range(ProductTypeColumn & ExchangeComboBoxRow)

Dim rngCURR_ECBOXR As Range
Set rngCURR_ECBOXR = Range(CurrencyColumn & ExchangeComboBoxRow)



If (rngRC_ECBOXR = "") Then

    For I = 0 To ExchangeArrayUBound
    
        If Me.cboExchange.Value = ExchangeArray(I, 1) Then
            
            rngRC_ECBOXR = ExchangeArray(I, 0)
            AutoFillRegion = ExchangeArray(I, 0)
            
            rngEC_ECBOXR = ExchangeArray(I, 1)
            
            Me.cboRegion.Top = Me.cboExchange.Top
            RegionComboBoxRow = ExchangeComboBoxRow
            
            ComboBoxChange = False
            
            Me.cboRegion.Value = ""
            
            ComboBoxChange = True
            
            Me.cboRegion.Style = 0 '-- EMOD 3.5
            
            Me.cboRegion.Value = ExchangeArray(I, 0) '??? --- the user can skip the region and  load the unique exchange and this loads the region - ExchangeArray(I, 0)
            
            rngRC_ECBOXR.Interior.ColorIndex = ValidColorIndexValue
            
            ComboBoxChange = True
            
            Exit For
            
        End If
        
    Next I
    
End If

rngEC_ECBOXR.Interior.ColorIndex = ValidColorIndexValue

rngEC_ECBOXR.Value = Me.cboExchange.Value

'*** 11/19/13

Call HideComboBoxesFast

ProductGroupCodeComboBoxRow = ExchangeComboBoxRow

With Me.cboProductGroupCode

    .Top = Me.cboExchange.Top
    
    Call FormatComboBox("cboProductGroupCode", ProductGroupCodeColumn)
    
    .Visible = True

End With

ComboBoxChange = True
'-regcheck
'Me.cboProductGroupCode.Value = Range(ProductGroupCodeColumn & ProductGroupCodeComboBoxRow).Value
Me.cboProductGroupCode.Style = 2
Me.cboProductGroupCode.Value = ""

For I = 0 To ProductGroupCodeArrayUBound
        
    If ((ProductGroupCodeArray(I, 0) = rngRC_ECBOXR) And _
        (ProductGroupCodeArray(I, 1) = rngEC_ECBOXR)) Then
        
        
        If ((EnableDefaultProductGroupCode) And (ProductGroupCodeArray(I, 2) = "All")) Then

            'AllFlag = True
                
        End If

        MinCol = I + HeaderRowOffset

        Exit For

    End If
    
Next I

If I <= ProductGroupCodeArrayUBound Then

    If MinCol - 2 = ProductGroupCodeArrayUBound Then ' Blanket Exchange is last row and only one occurence

        MaxCol = MinCol
        
    Else

        For I = MinCol - 1 To ProductGroupCodeArrayUBound
            
            If ((EnableDefaultProductGroupCode) And (ProductGroupCodeArray(I, 2) = "All")) Then

               ' AllFlag = True
                
            End If
                
            If ((ProductGroupCodeArray(I, 0) <> rngRC_ECBOXR) Or _
                (ProductGroupCodeArray(I, 1) <> rngEC_ECBOXR)) Then
        
                MaxCol = I + (HeaderRowOffset - 1)
        
                Exit For
        
            End If
        
        Next I
        
        'Last exchange in ProductGroupCode table
        
        If I > ProductGroupCodeArrayUBound Then
            MaxCol = ProductGroupCodeArrayUBound + 2
        End If
        
    End If
      
    Me.cboProductGroupCode.ListFillRange = ProductGroupCode.Range("$" & RefDataProductGroupCodeColumn & "$" & MinCol _
                                           & ":$" & RefDataProductGroupCodeColumn & "$" & MaxCol).Address(External:=True)
    
    ComboBoxChange = True
    
    If EnableDefaultProductGroupCode And AllFlag Then
    
        'Me.cboProductGroupCode.Value = "All"
        AllFlag = False
        
    Else
    
        '*** 11/5/13 If Exchange is changed set all dependent columns and comboboxs to blank
    
        Me.cboProductGroupCode.Value = ""
        Me.cboProduct.Value = ""
               
        Me.cboProduct.ListFillRange = ""
    
        rngPGC_ECBOXR.Value = ""
        rngPC_ECBOXR.Value = ""
        rngPTC_ECBOXR.Value = ""
        rngCURR_ECBOXR = ""
    
    End If
            
Else

    ComboBoxChange = True
        
    Me.cboProductGroupCode.ListFillRange = ""
    
    rngEC_ECBOXR = Me.cboExchange.Value
    
    Me.cboExchange.Value = ""

End If

Set rngRC_ECBOXR = Nothing
Set rngEC_ECBOXR = Nothing
Set rngPGC_ECBOXR = Nothing
Set rngPC_ECBOXR = Nothing
Set rngPTC_ECBOXR = Nothing
Set rngCURR_ECBOXR = Nothing


End Sub

Attribute VB_Name = "Product"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "ProductGroupCode"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Region"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "StaticData"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "eModule"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Public Sub setColumnsNumberFormatInteger()

'--- new sub - reg - 2/19/16 - set as integer format on startup for columns where all values must be integers with no decimals

Dim ix As Integer
Dim colRng As Range
Dim intColsArray(1 To 2) As String

'--vol disc - true for all cases
intColsArray(1) = Module1.TiersColumn '--vol disc tier num #
intColsArray(2) = Module1.TierStartNumberAmountColumn '--vol disc start value #

For ix = 1 To 2

 Set colRng = Range(intColsArray(ix) + ":" + intColsArray(ix))
 colRng.NumberFormat = "0"
Next


Set colRng = Nothing
End Sub

Private Sub Workbook_Activate()
'--- REG CHANGES
Call SetLastRow
Call Module1.HideComboBoxesFast

 If Module1.eModuleVersion <> ModuleSheet.btnlblEmodVersionAndReset.Caption Then
 
     MsgBox "Warning - the internal program's eModule version of: " + Module1.eModuleVersion + vbLf + _
            "is NOT equal to the external spreadsheet version of: " + ModuleSheet.btnlblEmodVersionAndReset.Caption + vbLf + vbLf + _
            "Please contact FIA Tech eModule support.", vbCritical, title1
 End If
  
Application.StatusBar = "Welcome to the eMODULE 3.5"
  
End Sub

Private Sub Workbook_BeforeClose(Cancel As Boolean)

'--- @@@@@ reg - removed for testing
On Error GoTo VBAErrorHandler

Application.Cursor = xlNormal

ModuleSheet.Activate '-- be sure you are here
'MsgBox "Bef close", , "testing"

Call Module1.HideComboBoxesFast '-- save with cboxes hidden

ActiveSheet.AutoFilterMode = False
'-- REMOVE FILTER BEF SAVE

'*** 7/1/14

Dim ModuleLastRow As Long
ModuleLastRow = Module1.getModuleLastRow
'Dim ClearRange As Range

'*** 1/18/14

NoDataRows = False

Call CheckNumberOfRows(StaticDataSheetCodeName, HeaderRowOffset - 1, StaticDataCurrencyColumn)
Call CheckNumberOfRows(RegionSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)
Call CheckNumberOfRows(ExchangeSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)
Call CheckNumberOfRows(ProductGroupCodeSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)
Call CheckNumberOfRows(ProductSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn) '--- eMod 3.5 one more col for def currency

If NoDataRows Then

    MsgBox "One or More Reference Sheets Have No Data - Exiting Sub", vbCritical, title2
    Exit Sub
    
End If

If SheetMissing Then

    SheetMissing = False
    Exit Sub
End If

'--- eMod 3.5 - reg - per Andrew no more validation before close

'ElseIf EnableValidationOnWorbookClose Then

 '   If (eModuleWorksheetChangedFlag = True) Or (performValidationFlag = False) Then
       
        '--- reg - main change - call on close validation IF either - the spreadsheet has changed or no validation (button) has been done
        'MsgBox "VALIDATION SKIPPED", , "TESTING"
        'Call PerformValidation
        '--------------------- runs validation on closing
        
   '     performValidationFlag = True
  '
   ' End If
    
'End If
    
If EnableCleanUpRoutine Then '-- set to false - reg?

    ModuleSheet.Range(Cells(ModuleFirstRow, ModuleSheetNumberOfColumns + 1), LastSheetColumn & (ModuleMaxRows + (ModuleFirstRow - 1))).ClearContents
    ModuleSheet.Range(Cells(ModuleFirstRow, ModuleSheetNumberOfColumns + 1), LastSheetColumn & (ModuleMaxRows + (ModuleFirstRow - 1))).Interior.ColorIndex = ValidColorIndexValue
    
    ModuleLastRow = Module1.getModuleLastRow '--- emod 3.5 - 6/16/15 - reg
    
    If ModuleLastRow >= ModuleFirstRow Then
  
        ModuleSheet.Range(FirstColumn & (ModuleLastRow + 1), LastColumn & (ModuleMaxRows + (ModuleFirstRow - 1))).ClearContents
        ModuleSheet.Range(FirstColumn & (ModuleLastRow + 1), LastColumn & (ModuleMaxRows + (ModuleFirstRow - 1))).ClearComments
        ModuleSheet.Range(FirstColumn & (ModuleLastRow + 1), LastColumn & (ModuleMaxRows + (ModuleFirstRow - 1))).Interior.ColorIndex = ValidColorIndexValue

     End If
     

End If

Call Module1.SelectFirstCell(False) ' <<-- error 1004

On Error GoTo 0
'---- @@@@ reg - removed error code below for now

Exit Sub
'-------------- normal termination of sub

VBAErrorHandler:

If Err.Number = 1004 Then

   Call SetLastRow
    
   On Error GoTo 0
    
   Resume
    
End If

On Error GoTo 0

End Sub

Private Sub WorkbookOpen2()

'--- reg - move all code from workbook_open to here for statability

Application.ScreenUpdating = False
'--- FIRST STOP SHOWING CHANGES TO THE USER
'MsgBox "test startup"

If showSheetsBln Then
   Call Module1.unHideAllSheets
  Else
   Call Module1.HideAllSheets
End If

'ModuleSheet.cmdSheetMode.Caption = "Normal"
Call Module1.freezeRows

Application.OnKey "{ESCAPE}", "ClearCutCopy"

'Application.OnKey "^v", "PasteDisableEvents"
'Application.OnKey "^{Insert}", "PasteDisableEvents"
'Application.OnKey "+{Insert}", "PasteDisableEvents"
'Application.OnKey "~", "PasteDisableEvents"
'Application.OnKey "{Enter}", "PasteDisableEvents"

'*** 7/2/14
Module1.sortOnFlag = False

DecimalSeparator = Application.International(xlDecimalSeparator)


'ModuleSheet.Application.ActiveWindow.SplitRow = ModuleFirstRow - 1
'ModuleSheet.Application.ActiveWindow.FreezePanes = True


SheetMissing = False
NoDataRows = False

Exchange.Range(RefDataExchangeColumnSorted & SheetTopRow).Value = ExchangeHeader
Exchange.Range(RefDataRegionColumnSorted & SheetTopRow).Value = RegionHeader


Call CheckForSheet(ModuleSheetCodeName)
Call CheckForSheet(StaticDataSheetCodeName)
Call CheckForSheet(RegionSheetCodeName)
Call CheckForSheet(ExchangeSheetCodeName)
Call CheckForSheet(ProductGroupCodeSheetCodeName)
Call CheckForSheet(ProductSheetCodeName)
Call CheckForSheet(ErrorLogSheetCodeName)

Call CheckNumberOfColumns(ModuleSheetCodeName, ModuleSheetNumberOfColumns, HeaderRowOffset)
Call CheckNumberOfColumns(StaticDataSheetCodeName, StaticDataSheetNumberOfColumns, HeaderRowOffset - 1)
Call CheckNumberOfColumns(RegionSheetCodeName, RegionSheetNumberOfColumns, HeaderRowOffset - 1)
Call CheckNumberOfColumns(ExchangeSheetCodeName, ExchangeSheetNumberOfColumns, HeaderRowOffset - 1)
Call CheckNumberOfColumns(ProductGroupCodeSheetCodeName, ProductGroupCodeSheetNumberOfColumns, HeaderRowOffset - 1)
Call CheckNumberOfColumns(ProductSheetCodeName, ProductSheetNumberOfColumns, HeaderRowOffset - 1)

'*** 1/18/14

Call CheckNumberOfRows(StaticDataSheetCodeName, HeaderRowOffset - 1, StaticDataCurrencyColumn)
Call CheckNumberOfRows(RegionSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)
Call CheckNumberOfRows(ExchangeSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)
Call CheckNumberOfRows(ProductGroupCodeSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)
Call CheckNumberOfRows(ProductSheetCodeName, HeaderRowOffset - 1, RefDataRegionColumn)

If NoDataRows Then

    ComboBoxChange = False 'Disable all combobox change event handlers on workbook open
    
'    MsgBox "One or More Reference Sheets Have No Data - Exiting Sub", vbCritical, title2

    Exit Sub
    
End If

'--- 2/18/15 - reg - NEW FUNCTION - CALL TO SET COLUMNS FOR INTEGER TYPES (FOR ALL VALUES)
Call setColumnsNumberFormatInteger

Dim I As Long

Dim cboTempRegion As ComboBox
Dim cboTempExchange As ComboBox
Dim cboTempProductGroupCode As ComboBox
Dim cboTempProduct As ComboBox

Dim CellToCheck As Range

ModuleLastRow = Module1.getModuleLastRow '--- emod 3.5 - 6/16/15 - reg

'*** 4/3/14
Dim rngFCLC As Range
Set rngFCLC = Range(FirstColumn & ModuleFirstRow, LastColumn & ModuleLastRow)

'-- WE STILL CHECK FOR CONTROL CHARS IN EMPTY CELLS IN THE EMODULE
For Each CellToCheck In rngFCLC
    If Len(CellToCheck.Value) = 0 Then
     CellToCheck.ClearContents
    End If
Next

'--- @@@@@@ REG - 6/10/15 - TESTING - DO WE NEED THIS - CLEAN EACH ROW AS IT'S USED INSTEAD?
'--- NOTE: PER ANDREW - DUE TO ISSUES WITH MARKIT DOWNLOADS - MAY HAVE CONTROL CHARS

'MsgBox "CellToCheck In rngFCLC: ix1,ix2: " + CStr(ix2) + "," + CStr(ix2)

For Each CellToCheck In StaticData.usedRange
    If Len(CellToCheck.Value) = 0 Then
       CellToCheck.ClearContents
    End If
Next

Set CellToCheck = Nothing

'MsgBox "CellToCheck In StaticData.UsedRange: ix1,ix2: " + CStr(ix2) + "," + CStr(ix2)

'Call workBookOpenSort
'done before
'test reg

'*** 4/4/14

'--- done before
'Call HideAllSheets

'*** 4/4/14

'Application.ScreenUpdating = True

ModuleSheet.Activate
'---------------------------- THE eModule

Set cboTempRegion = ModuleSheet.OLEObjects("cboRegion").Object

ComboBoxChange = False 'Disable all combobox change event handlers on workbook open

With cboTempRegion

    .ListFillRange = Region.Range("$" & RefDataRegionColumn & "$" & HeaderRowOffset & ":$" & RefDataRegionColumn & "$" & RegionLastRow).Address(External:=True)

    .ListIndex = 0
    .LinkedCell = ""
    .backColor = RGB(ValidRedValue, ValidGreenValue, ValidBlueValue)
    
    Call FormatComboBox("cboRegion", RegionColumn)
    
    .Visible = False
 
End With

Call SetLastRow '---reg-set arrays-for debugging-become zero on workbook open is stopped due to debug

ReDim RegionArray(0 To RegionArrayUBound)

Dim Istr As String '-- pre-convert int to string in all loops

For I = 0 To RegionArrayUBound

    Istr = CStr(I)
    RegionArray(I) = Region.Range("$" & RefDataRegionColumn & Istr + HeaderRowOffset).Value

Next I


ReDim ExchangeArray(0 To ExchangeArrayUBound, 1)

For I = 0 To ExchangeArrayUBound

    Istr = CStr(I)
    ExchangeArray(I, 0) = Exchange.Range("$" & RefDataRegionColumn & Istr + HeaderRowOffset).Value
    ExchangeArray(I, 1) = Exchange.Range("$" & RefDataExchangeColumn & Istr + HeaderRowOffset).Value

Next I

For I = 0 To UBound(ExchangeArray)

    If ExchangeArray(I, 0) = cboTempRegion.Value Then
    
        MinCol = I + HeaderRowOffset
        
        Exit For
        
    End If
    
Next I

For I = MinCol - 1 To UBound(ExchangeArray)

    If ExchangeArray(I, 0) <> cboTempRegion.Value Then
        
        MaxCol = I + (HeaderRowOffset - 1)
        
        Exit For
        
    End If
    
Next I

'*** 1/13/14

If I > ExchangeArrayUBound Then MaxCol = ExchangeArrayUBound + 2

'*** 1/13/14

Set cboTempExchange = ModuleSheet.OLEObjects("cboExchange").Object

With cboTempExchange

    .ListFillRange = Exchange.Range("$" & RefDataExchangeColumn & "$" & MinCol & ":$" & RefDataExchangeColumn & "$" & MaxCol).Address(External:=True)
    
    .ListIndex = 0
    .LinkedCell = ""
    .backColor = RGB(ValidRedValue, ValidGreenValue, ValidBlueValue)
    
    '*** 11/28/13
    
    Call FormatComboBox("cboExchange", ExchangeColumn)
 
    
    .Visible = False
 
End With

ProductGroupCodeArrayUBound = ProductGroupCodeLastRow - HeaderRowOffset

ReDim ProductGroupCodeArray(0 To ProductGroupCodeArrayUBound, 2)

For I = 0 To ProductGroupCodeArrayUBound

    Istr = CStr(I)
    ProductGroupCodeArray(I, 0) = ProductGroupCode.Range("$" & RefDataRegionColumn & Istr + HeaderRowOffset).Value
    ProductGroupCodeArray(I, 1) = ProductGroupCode.Range("$" & RefDataExchangeColumn & Istr + HeaderRowOffset).Value
    ProductGroupCodeArray(I, 2) = ProductGroupCode.Range("$" & RefDataProductGroupCodeColumn & Istr + HeaderRowOffset).Value

Next I

For I = 0 To UBound(ProductGroupCodeArray)

    If ((ProductGroupCodeArray(I, 0) = cboTempRegion.Value) And _
        (ProductGroupCodeArray(I, 1) = cboTempExchange.Value)) Then

        MinCol = I + HeaderRowOffset

        Exit For

    End If

Next I

For I = MinCol - 1 To UBound(ProductGroupCodeArray)

    If ((ProductGroupCodeArray(I, 0) <> cboTempRegion.Value) Or _
        (ProductGroupCodeArray(I, 1) <> cboTempExchange.Value)) Then

        MaxCol = I + (HeaderRowOffset - 1)

        Exit For

    End If

Next I

'*** 1/13/14

If I > ProductGroupCodeArrayUBound Then MaxCol = ProductGroupCodeArrayUBound + 2

'*** 1/13/14

Set cboTempProductGroupCode = ModuleSheet.OLEObjects("cboProductGroupCode").Object

With cboTempProductGroupCode

    .ListFillRange = ProductGroupCode.Range("$" & RefDataProductGroupCodeColumn & "$" & MinCol _
                     & ":$" & RefDataProductGroupCodeColumn & "$" & MaxCol).Address(External:=True)
    
    .ListIndex = 0
    .LinkedCell = ""
    .backColor = RGB(ValidRedValue, ValidGreenValue, ValidBlueValue)
    
    '*** 11/28/13
    
    Call FormatComboBox("cboProductGroupCode", ProductGroupCodeColumn)

    
    .Visible = False
    
End With

ProductArrayUBound = ProductLastRow - HeaderRowOffset

ReDim ProductArray(0 To ProductArrayUBound, 5)

For I = 0 To ProductArrayUBound

    Istr = CStr(I)
    ProductArray(I, 0) = Product.Range("$" & RefDataRegionColumn & Istr + HeaderRowOffset).Value
    ProductArray(I, 1) = Product.Range("$" & RefDataExchangeColumn & Istr + HeaderRowOffset).Value
    ProductArray(I, 2) = Product.Range("$" & RefDataProductGroupCodeColumn & Istr + HeaderRowOffset).Value
    ProductArray(I, 3) = Product.Range("$" & RefDataProductColumn & Istr + HeaderRowOffset).Value
    ProductArray(I, 4) = Product.Range("$" & RefDataProductTypeColumn & Istr + HeaderRowOffset).Value
    ProductArray(I, 5) = Product.Range("$" & RefDataProductDefaultCurrencyColumn & Istr + HeaderRowOffset).Value '--- eMod 3.5 - default currency
    
Next I

For I = 0 To UBound(ProductArray)

    If ((ProductArray(I, 0) = cboTempRegion.Value) And _
        (ProductArray(I, 1) = cboTempExchange.Value) And _
        (ProductArray(I, 2) = cboTempProductGroupCode.Value)) Then

        MinCol = I + HeaderRowOffset

        Exit For

    End If

Next I

For I = MinCol - 1 To UBound(ProductArray)

    If ((ProductArray(I, 0) <> cboTempRegion.Value) Or _
        (ProductArray(I, 1) <> cboTempExchange.Value) Or _
        (ProductArray(I, 2) <> cboTempProductGroupCode.Value)) Then

        MaxCol = I + (HeaderRowOffset - 1)

        Exit For

    End If

Next I

'*** 1/13/14

If I > ProductArrayUBound Then
   MaxCol = ProductArrayUBound + 2
End If

'*** 1/13/14

Set cboTempProduct = ModuleSheet.OLEObjects("cboProduct").Object

With cboTempProduct

    .ListFillRange = Product.Range("$" & RefDataProductColumn & "$" & MinCol _
                     & ":$" & RefDataProductColumn & "$" & MaxCol).Address(External:=True)
    
    .ListIndex = 0
    .LinkedCell = ""
    .backColor = RGB(ValidRedValue, ValidGreenValue, ValidBlueValue)
    
    '*** 11/28/13
    
    Call FormatComboBox("cboProduct", ProductColumn)
    
    .Visible = False
    

End With

Call FillStaticDataComboBoxValues

'-- FREEZE - EMODULE AND ERROR LOG



Set cboTempRegion = Nothing
Set cboTempExchange = Nothing
Set cboTempProductGroupCode = Nothing
Set cboTempProduct = Nothing

Application.ScreenUpdating = True

ComboBoxChange = True 'Enable all combobox change event handlers on workbook open completion

End Sub

Private Sub FillStaticDataComboBoxValues()

'---- PART OF WORKBOOK OPEN - RUNS AT THE END
'---- CHANGE VALUES IN CBOX IN THE STATIC DATA TABS UNDER CORRESP COLUMNS

'---- THIS IS ONLY FOR EXCEL COLUMNS IN THE EMOD THAT HAVE A COMBO BOX VALIDATION THAT IS FIXED (STATIC) DEFINED IN THE STATIC DATA TAB,
'---- FOR EXAMPLE THE REGION-EXCHANGE-GRP-PROD ARE DYNAMIC CBOXES - ARE ALL RELATED AND THEIR VALUES ARE DEFINED IN THE PROGRAM WAS EACH PRIOR VALUE CHANGES

'--- TECH NOTE - ANY NEW COMBO BOX MUST BE ADDED TO THE SPREADHSEET, A NAME DEFINED USING STD: cboXXXXX WHERE XXXXX IS THE STD NAME FOR THE DATA ITEM, WE ADD IT'S POSSIBLE VALUES TO A NEW COLUMN IN STATIC TAB
'--- THEN DEFINE THAT COLUMN AS: StaticDataXXXXXColumn, WHERE XXXXX IS THE SAME AS IN cboXXXXX, AND THE LAST PARM IS XXXXXColumn.
'--- KEY IDEAS: THE STATIC DATA COLUMN IS THE COLUMN IN THE STATIC DATA TAB TO LOOK FOR DROP DOWN DATA
'--- THE XXXXXCOLUMN IS THE COLUMN WHERE THE CBOXXXXX IS TO BE DISPLAYED - USING THE CURRENT ROW THE USER CLICKED (SELECTION_CHANGE FIGURES THE COLUMN AND CREATES THE CORRESP. CBOX PER A SELECT CASE STATEMENT

Call FillStaticDataComboBox("cboDirectBill", StaticDataDirectBillColumn, DirectBillColumn)
Call FillStaticDataComboBox("cboCurrency", StaticDataCurrencyColumn, CurrencyColumn)
Call FillStaticDataComboBox("cboTradeType", StaticDataTradeTypeColumn, TradeTypeColumn)
Call FillStaticDataComboBox("cboSpreadType", StaticDataSpreadTypeColumn, SpreadTypeColumn)
Call FillStaticDataComboBox("cboRateType", StaticDataRateTypeColumn, RateTypeColumn)
Call FillStaticDataComboBox("cboExecutionType", StaticDataExecutionTypeColumn, ExecutionTypeColumn)
Call FillStaticDataComboBox("cboDefaultExecutionType", StaticDataDefaultExecutionTypeColumn, DefaultExecutionTypeColumn)

Call FillStaticDataComboBox("cboMMApply", StaticDataMMApplyColumn, MMApplyColumn)
Call FillStaticDataComboBox("cboMMDefine", StaticDataMMDefineColumn, MMDefineColumn) '--- ADDED EMOD 3.5

Call FillStaticDataComboBox("cboAddOnApply", StaticDataAddOnApplyColumn, AddOnApplyColumn)

'-- vol disc
Call FillStaticDataComboBox("cboDefinedTiersBased", StaticDataTierDefinedBasedColumn, TierDefinedBasedColumn)
Call FillStaticDataComboBox("cboApplyTo", StaticDataTierApplyToColumn, TierApplyToColumn)
Call FillStaticDataComboBox("cboTierValueType", StaticDataTiersValueTypeColumn, TierValueTypeColumn) '--- ADDED EMOD 3.5

'-- bands
Call FillStaticDataComboBox("cboBandApply", StaticDataBandApply, BandApplyColumn) '--- ADDED EMOD 3.5
Call FillStaticDataComboBox("cboBandValueType", StaticDataBandValueType, BandValueTypeColumn) '--- ADDED EMOD 3.5
Call FillStaticDataComboBox("cboBandRateType", StaticDataBandRateType, BandRateTypeColumn) '--- ADDED EMOD 3.5

End Sub


Private Sub workBookOpenSort()

Application.ScreenUpdating = False

Module1.ComboBoxChange = False
Module1.disableWorksheetSelectionChange = True

Dim refCol As String
refCol = RefDataRegionColumn & LastSheetRow

RegionLastRow = Region.Range(refCol).End(xlUp).row
ExchangeLastRow = Exchange.Range(refCol).End(xlUp).row
ProductGroupCodeLastRow = ProductGroupCode.Range(refCol).End(xlUp).row
ProductLastRow = Product.Range(refCol).End(xlUp).row


With Region
   
    .Sort.SortFields.Clear
    .Sort.SortFields.Add Key:=Range(RefDataRegionColumn & HeaderRowOffset, RefDataRegionColumn & RegionLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SetRange Range(RefDataRegionColumn & HeaderRowOffset, RefDataRegionColumn & RegionLastRow)
    .Sort.Header = xlNo
    .Sort.Apply
     
End With

  
With Exchange
   
    .Sort.SortFields.Clear
    .Sort.SortFields.Add Key:=Range(RefDataRegionColumn & HeaderRowOffset, RefDataRegionColumn & ExchangeLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SortFields.Add Key:=Range(RefDataExchangeColumn & HeaderRowOffset, RefDataExchangeColumn & ExchangeLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SetRange Range(RefDataRegionColumn & HeaderRowOffset, RefDataExchangeColumn & ExchangeLastRow)
    .Sort.Header = xlNo
    .Sort.Apply
     
End With
    
With ProductGroupCode
   
    .Sort.SortFields.Clear
    .Sort.SortFields.Add Key:=Range(RefDataRegionColumn & HeaderRowOffset, RefDataRegionColumn & ProductGroupCodeLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SortFields.Add Key:=Range(RefDataExchangeColumn & HeaderRowOffset, RefDataExchangeColumn & ProductGroupCodeLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SortFields.Add Key:=Range(RefDataProductGroupCodeColumn & HeaderRowOffset, RefDataProductGroupCodeColumn & ProductGroupCodeLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SetRange Range(RefDataRegionColumn & HeaderRowOffset, RefDataProductGroupCodeColumn & ProductGroupCodeLastRow)
    .Sort.Header = xlNo
    .Sort.Apply
     
End With

With Product
   
    .Sort.SortFields.Clear
    .Sort.SortFields.Add Key:=Range(RefDataRegionColumn & HeaderRowOffset, RefDataRegionColumn & ProductLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SortFields.Add Key:=Range(RefDataExchangeColumn & HeaderRowOffset, RefDataExchangeColumn & ProductLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SortFields.Add Key:=Range(RefDataProductGroupCodeColumn & HeaderRowOffset, RefDataProductGroupCodeColumn & ProductLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SortFields.Add Key:=Range(RefDataProductColumn & HeaderRowOffset, RefDataProductColumn & ProductLastRow), _
        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
    .Sort.SetRange Range(RefDataRegionColumn & HeaderRowOffset, RefDataProductTypeColumn & ProductLastRow)
    .Sort.Header = xlNo
    .Sort.Apply
     
End With

Module1.disableWorksheetSelectionChange = False

'*** 2/25/14 Disabled code - Markit will create

'Create alphabetized list of exchanges for region autofill feature

'Exchange.Range(RefDataExchangeColumnSorted & HeaderRowOffset - 1, RefDataExchangeColumnSorted & ExchangeLastRow).Value = _
'Exchange.Range(RefDataExchangeColumn & HeaderRowOffset - 1, RefDataExchangeColumn & ExchangeLastRow).Value
'
'Exchange.Range(RefDataRegionColumnSorted & HeaderRowOffset - 1, RefDataRegionColumnSorted & ExchangeLastRow).Value = _
'Exchange.Range(RefDataRegionColumn & HeaderRowOffset - 1, RefDataRegionColumn & ExchangeLastRow).Value
'
'With Exchange
'
'    .Sort.SortFields.Clear
'    .Sort.SortFields.Add Key:=Range(RefDataExchangeColumnSorted & HeaderRowOffset, RefDataExchangeColumnSorted & ExchangeLastRow), _
'        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
'    .Sort.SortFields.Add Key:=Range(RefDataRegionColumnSorted & HeaderRowOffset, RefDataRegionColumnSorted & ExchangeLastRow), _
'        SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
'    .Sort.SetRange Range(RefDataExchangeColumnSorted & HeaderRowOffset, RefDataRegionColumnSorted & ExchangeLastRow)
'    .Sort.Header = xlNo
'    .Sort.Apply
'
'End With

'*** 2/25/14 Disabled code - Markit will create


Module1.ComboBoxChange = True '--RESET BEFORE LEAVING

Application.ScreenUpdating = True

End Sub



Private Sub Workbook_BeforeXmlExport(ByVal Map As XmlMap, ByVal Url As String, Cancel As Boolean)

End Sub

Private Sub Workbook_Open()
'msgBox "testing - Workbook_Open", , "Workbook_Open"

  '--- reg - moved code for stability -
  '---programs that gave compiler errors onload worked with this chanage
  Application.Cursor = xlDefault
  '--- eMod 3.5 - reg - more flexible approach by using column map on static data col z to get col letter and numbers
  
  Module1.workbookOpenIsRunning = True

  Set saveCurrCell2 = Selection

  'MsgBox "WORKBOOK OPEN", , "TEST"
  Call WorkbookOpen1

  '--- return to the last active cell - 3/1/16- reg
  On Error Resume Next
  saveCurrCell2.Select
  On Error GoTo 0
  Set saveCurrCell2 = Nothing
   

  Module1.workbookOpenIsRunning = False
  
End Sub

Public Sub WorkbookOpen1()
 
  '--- REG - 2/29/16
  '--- DOCUMENTATION ON CODE TO START EMOD:
  '--- THESE ARE ORDER-DEPENDENT - DO NOT CHANGE ORDER
  
  '-- EMOD START UP PROBLEMS:
  'PRELIM - THE EMOD 3.4 CALLED ALL OF THE STARTUP CODE INSIDE THE WORKBOOK_OPEN SUB - WHICH INIT EXCELS
  'THIS CAUSED BLOATED CODE ON EXCEL STARTUP WHICH LEAD TO PROBLEMS AND CRASHES TO RANDOM USERS - MEMORY MGT ISSUES
  'THIS KEY ISSUE THAT AFFECTED LARGE CLIENTS WAS SOLVED BY REMOVING ALL CODE FROM WORKBOOK_OPEN INTO SEVERAL SEPARATE SUBS
  'IN THIS WAY WORKBOOK_OPEN IS SMALL SINCE IT ONLY HAS ONE SUB CALL (WorkbookOpen1) WHICH CALLS THE OTHERS
  'IN PARTICULAR SORTS WHICH ARE MEMORY INTENSIVE ARE SEPARATED INTO THEIR OWN SUBS
  'THIS SOLVED THE CLIENTS ISSUE - WHICH MADE THEM UNABLE TO START THE EMOD
  
  '1-HIDE ALL WORKSHEETS EXCEPT EMOD AND ERROR LOG
  '2-LOAD COMBO BOXES - THESE MUST EXIST FOR EACH EMO COL THAT HAS TEXT TO VERIFY - OBJECTS IN ActiveSheet.OLEObjects
  '3-HIDE ALL COMBO BOXES, ONLY ONE CAB BE ACTIVE IF CLICKED ON, THEN IT'S HIDDEN BY THE REPEATED USE OF HideComboBoxesFast
  'REMOVED - 4-JUST IN CASE UNHIDEL COLS
  '5-SORT ITEMS FOR COMBO BOXES PROD RELATED: REGION, EXCH, PROD GRP, PROD (IN RESPECTIVE TABS) - workBookOpenSort
  '6-SEQUENTIAL LOAD OF KEY COLUMN VARIABLES IN - loadColumnVariables (NUMBER AND EXCEL LETTER), ALSO ARRAY OF NAMES
  'The names convention is stdNameColumn for excel col letter and stdNameColumnNumber for col number, as in RegionColumn, RegionColumnNumber
  '7-BRANCH TO WorkbookOpen2 - WHICH CALLS CHECKS AND THEN PRELOADS NEEDED INTERNAL ARRAYS TO FIL REGION-EXCH-PROD GRP-PROD (RELATED IN SEQUENCE)
  'NOTE: THESE ARRAY ARE LOADED AGAIN IF FOUND EMPTY - BY RESET BUTTONS OR AUTOMATICALLY BY THE PROGRAM (GIVE VBA ERROR 9)
  
  'MISC ACTIONS ARE 1ST TURN ScreenUpdating OFF, CLOSE THE TABS AND LOAD COMBO BOXES ETC, GET THE LAST ROW INTO lastRow
  
  Application.ScreenUpdating = False
 
  Dim lastRow As Long
  
  '--- first - hide cboxes and hide tabs

  Call HideAllSheets
  Call Module1.LoadcBoxCollection
  Call HideComboBoxesFast
   
  '--- next close the screen updates
  
  Module1.productTypeMessageFlag = False
     
  Call workBookOpenSort
     
   '--- loads the cboxes into a collection only once - for HideComboBoxesFast
   
  '--- loads columns letters - essential to the rest of the program
   Module1.loadColumnVariables
   
  Call Module1.SetLastRow '-- SETS DIM FOR DATA ARRAYS
  lastRow = Module1.getModuleLastRow '
  
  '-- now call work book open, no validation is run
  Call WorkbookOpen2

  Application.ScreenUpdating = True
  Application.EnableEvents = True
  Application.Cursor = xlNormal
   
End Sub


Attribute VB_Name = "frmControlPanel"
Attribute VB_Base = "0{DA7F844D-75A0-439E-A134-C388D6A9879D}{4D9CED83-8C58-4EE9-B353-406201AAA7C1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'-- for delete
Public optionSelectedExecutionType As String
'--- for insert
Public optionSelectedExecutionType1 As String
Public optionSelectedExecutionType2 As String
'--- button class
Public optionType As String
Public condFormattingActive As Boolean
Public excelStyleCounter As Integer
Public commentCounter As Integer

Public Sub btnCboxListRowsMax_Click()
 
 MsgBox "This allows you to set the MAXIMUM number of rows displayed" + vbLf + vbLf + _
       "by ALL the eModule Combo Boxes. Note that if the box has less items" + vbLf + vbLf + _
       "than the number specified then it will display all the items. The larger the max" + vbLf + vbLf + _
       "the LESS scrolling you need to do to find for example a product. It must be > 5." + vbLf + vbLf + _
       "Note that this change is active for the current session.", , title1
       
 Dim tmp As Integer
 tmp = 0
 tmp = InputBox("Please enter the MAX number of rows to display in combo boxes: ", "eModule Combo Boxes Setup", 20)
 If IsNull(tmp) Or tmp < 6 Or Not IsNumeric(tmp) Then
    tmp = 20
 End If
 
 Module1.cboxesUserDefListRows = tmp
 
 frmControlPanel.hide
End Sub

Private Sub btnClearAllFormattingComments_Click()
           
Call Module1.clearAllFormats(True)

frmControlPanel.hide

End Sub



Private Sub btnClearEscapeChars_Click()

  Call Module1.clearEmodEscapeCharacters(True)
  
  frmControlPanel.hide
  
End Sub

Private Sub loadExecTypeCbox1()
  
   
  Me.FrameOptions.Visible = True

  Me.optionCboxLabel2.Visible = False
  Me.optionCbox2.Visible = False
  
  Me.optionCboxLabel1.Visible = True
  Me.optionCbox1.Visible = True

  Me.optionCboxLabel1 = "Execution Type#1"
  
  Me.optionsButton.Visible = True
  
  Dim ValidationRange As Range
  Const dataColumn = Module1.StaticDataExecutionTypeColumn

  Set ValidationRange = StaticData.Range("$" & dataColumn & "$" & Module1.StaticDataRowOffset _
                      & ":$" & dataColumn & "$" & _
                      StaticData.Range(dataColumn & Module1.LastSheetRow).End(xlUp).row)

 Dim cnt As Long
 cnt = ValidationRange.Count

 Dim ix As Integer
 
 For ix = 1 To cnt
     Me.optionCbox1.AddItem ValidationRange.Cells(ix)
 Next

End Sub

Private Sub loadExecTypeCbox2()
  
   
  Me.FrameOptions.Visible = True

  Me.optionCboxLabel2.Visible = True
  Me.optionCbox2.Visible = True

  Me.optionCboxLabel2 = "Execution Type#2"
  
  Dim ValidationRange As Range
  Const dataColumn = Module1.StaticDataExecutionTypeColumn

  Set ValidationRange = StaticData.Range("$" & dataColumn & "$" & Module1.StaticDataRowOffset _
                      & ":$" & dataColumn & "$" & _
                      StaticData.Range(dataColumn & Module1.LastSheetRow).End(xlUp).row)

 Dim cnt As Long
 cnt = ValidationRange.Count

 Dim ix As Integer
 
 For ix = 1 To cnt
     Me.optionCbox2.AddItem ValidationRange.Cells(ix)
 Next

End Sub



Private Sub btnCondFormatColorAmount_Click()

    Module1.eModShadeTurnedOn = False '-- turn shading off
    Me.tglShadeCurrentRow = False

    Dim lastRow As Long
    lastRow = Module1.getModuleLastRow
    Dim wks As Worksheet
    Set wks = ActiveSheet
    Dim addr As String
    addr = Module1.AmountColumn + CStr(ModuleFirstRow) + ":" + Module1.AmountColumn + CStr(lastRow)

    wks.Range(addr).Select
    
    Selection.FormatConditions.AddColorScale ColorScaleType:=3
    Selection.FormatConditions(Selection.FormatConditions.Count).SetFirstPriority
    Selection.FormatConditions(1).ColorScaleCriteria(1).Type = _
        xlConditionValueLowestValue
    With Selection.FormatConditions(1).ColorScaleCriteria(1).FormatColor
        .Color = 7039480
        .TintAndShade = 0
    End With
    Selection.FormatConditions(1).ColorScaleCriteria(2).Type = _
        xlConditionValuePercentile
    Selection.FormatConditions(1).ColorScaleCriteria(2).Value = 50
    With Selection.FormatConditions(1).ColorScaleCriteria(2).FormatColor
        .Color = 8711167
        .TintAndShade = 0
    End With
    Selection.FormatConditions(1).ColorScaleCriteria(3).Type = _
        xlConditionValueHighestValue
    With Selection.FormatConditions(1).ColorScaleCriteria(3).FormatColor
        .Color = 8109667
        .TintAndShade = 0
    End With
    
    '-- reset selection - else the select clouds the formatting
    
     addr = Module1.AmountColumn + CStr(ModuleFirstRow) + ":" + Module1.AmountColumn + CStr(ModuleFirstRow)
     wks.Range(addr).Select
     
    frmControlPanel.hide
    
End Sub

Private Sub btnCondFormattingText_Click()

   
    Module1.eModShadeTurnedOn = False '-- turn shading off
    Me.tglShadeCurrentRow = False
    
    condFormattingActive = True
    
    Dim currCell As String
    If Not IsNull(ActiveCell) Then
       currCell = ActiveCell.Value
    End If
    
    Dim lastRow As Long
    lastRow = Module1.getModuleLastRow
    Dim addr As String
    addr = "A4:" + Module1.LastColumn + CStr(lastRow)
    
    Range(addr).Select
     
    Dim condFormatInput As String
    condFormatInput = InputBox("Please ENTER WORD(s) for conditional formatting: ", "Range used: " + addr, currCell)
    condFormatInput = Trim(condFormatInput)
    If condFormatInput = "" Then
       Exit Sub
    End If

 
    Selection.FormatConditions.Add Type:=xlTextString, String:= _
       condFormatInput, TextOperator:=xlContains
    Selection.FormatConditions(Selection.FormatConditions.Count).SetFirstPriority
    With Selection.FormatConditions(1).Font
        .Color = -16383844
        .TintAndShade = 0
    End With
    With Selection.FormatConditions(1).Interior
        .PatternColorIndex = xlAutomatic
        .Color = 13551615
        .TintAndShade = 0
    End With
    Selection.FormatConditions(1).StopIfTrue = False
    
     '-- reset selection - else the select clouds the formatting
       
    Call Module1.SelectFirstCell(True)
    
    frmControlPanel.hide
    
End Sub

Private Sub btnCopyEmodule_Click()

Application.EnableEvents = False '-- avoid workbook open

Const maxRows = 20000
Dim addrCopy As String
addrCopy = "A4" + ":" + Module1.LastColumn + CStr(maxRows + 3)
Dim addrPaste As String

Dim rngCopy As Range

Dim wkb1 As Workbook
Dim wks1Dest As Worksheet

Set wkb1 = ActiveWorkbook
Set wks1Dest = wkb1.Sheets(1)
  
Dim lastUsedRow As Long '-- will increase as we copy more rows into emod - if more than 1 file to copy
  
Dim wksCopy As Worksheet
  
    Dim Fname As Variant
    Dim N As Long
    Dim FnameInLoop As String
    Dim eModule As Workbook
    Dim FilesPath As String
    Dim userName As String
    userName = (Environ$("Username"))

    
    If userName <> "" Then
    
       FilesPath = "C:\Users\" + userName + "\Documents"
      Else
       FilesPath = Application.DefaultFilePath
    End If
    
    Dim retVal As Variant
    
    retVal = MsgBox("The file browser will look for files in:  " + FilesPath + vbLf + vbLf + _
           "Please navigate to the directory the eModule file you need is placed." + vbLf + vbLf + _
           "In case you need to copy/paste MORE than ONE file - ALL such files must be located" + _
           "in the SAME directory to be able to multi-select them next." + vbLf + vbLf + _
           "If you are not ready for multi-select reply NO below and get the eModules files in the same directory first.", vbYesNo, title1)
    'C:\Users\rgarcia\Documents\eModules
   
    ' Change drive/directory to MyPath.
    ChDrive FilesPath
    ChDir FilesPath

    ' Open GetOpenFilename with the file filters.
    Fname = Application.GetOpenFilename( _
            FileFilter:="Excel eModule Files (*.xlsm), *.xlsm", _
            title:="Select one or more eModules to copy/paste into the current eModule", _
            MultiSelect:=True)

    ' Perform some action with the files you selected.
    If IsArray(Fname) Then
        
        With Application
            .ScreenUpdating = False
            .EnableEvents = False
        End With

        For N = LBound(Fname) To UBound(Fname)

            ' Get only the file name and test to see if it is open.
            FnameInLoop = Right(Fname(N), Len(Fname(N)) - InStrRev(Fname(N), Application.PathSeparator, , 1))
            
            If bIsBookOpen(FnameInLoop) = False Then

                Set eModule = Nothing
                On Error Resume Next
                
                Set eModule = Workbooks.Open(Fname(N))
                On Error GoTo 0

                If Not eModule Is Nothing Then
                
                     Application.EnableEvents = False
                         
                    '--- now copy/paste the region needed
                     lastUsedRow = Module1.getModuleLastRow  '-- recompute each loop
                     
                     
                     'If lastUsedRow < 4 Then '-- EMPTY
                     '   lastUsedRow = 4
                    ' End If
                     
                     addrPaste = "A" + CStr(lastUsedRow + 1) + ":" + Module1.LastColumn + CStr(maxRows + lastUsedRow)
                   
                     MsgBox "You opened this file to copy from: " & Fname(N) & vbNewLine & _
                            "This file will be closed after copy/paste." + vbLf + vbLf + _
                            "The row where eModule rows are to be copied is:  " + CStr(lastUsedRow + 1) + vbLf + vbLf + _
                            "The source range is: " + addrCopy + vbLf + _
                            "The destination range is: " + addrPaste, , title1
                   
                     Set wksCopy = eModule.Sheets(1)

                     Application.EnableEvents = False
                     
                     wksCopy.Range(addrCopy).Copy Destination:=wks1Dest.Range(addrPaste)
                           
                     eModule.Close SaveChanges:=False
                     
                     MsgBox "File closed: " + Fname(N), , title1
                End If
            Else
                MsgBox "Warning: Skipped this file : " & Fname(N) & " because it is already open.", , title1
            End If
        Next N
        
        With Application
            .ScreenUpdating = True
            .EnableEvents = True
        End With
        
    End If
    
    lastUsedRow = Module1.getModuleLastRow

    MsgBox "The copy/paste operations has finished." + vbLf + vbLf + _
           "The current file has NOT been saved." + vbLf + vbLf + _
           "Please VERIFY the results of the copy/paste operation(s) before saving." + vbLf + vbLf + _
           "The last used rows now is: " + CStr(lastUsedRow), , title1
 'wksSrc.Range(copyAddr).Copy Destination:=wksDest.Range(pasteAddr)
 
 Application.EnableEvents = True
 
 Call Module1.SelectFirstCell(False)
 
End Sub

Private Sub btnDefineUserRange_Click()

Dim Rng As Range
Dim actRng As Range


End Sub


Private Sub btnCustomSort_Click()
Call Module1.sortEmoduleCustom1
End Sub

Private Sub btnCycleStyles_Click()


   Module1.eModShadeTurnedOn = False '-- turn shading off
    Me.tglShadeCurrentRow = False

excelStyleCounter = excelStyleCounter + 1

If excelStyleCounter > 8 Then
   excelStyleCounter = 1
End If

Call Module1.clearModFormattingComments(False)
Call Module1.SelectAll
 
Select Case excelStyleCounter
       
       Case 1
       Call ModuleSheet.eModAlternateRowColors(19) '-- light yellow alternate lines
       
       Case 2
       Call ModuleSheet.eModAlternateRowColors(20) '-- light blue alternate lines
       
       Case 3
       Selection.Style = "Heading 3"
       
       Case 4
       Selection.Style = "Check Cell"
       
       Case 5
       Selection.Style = "Input"
       
       Case 6
       Selection.Style = "Output"
       
       Case 7
       Selection.Style = "Note"
       
       Case 8
       Selection.Style = "Normal"
       
       
       
       Case Else:
       Selection.Style = "Normal"
       
End Select

Call Module1.SelectFirstCell(False)


'MsgBox "To reset the style to normal press several times."
Application.StatusBar = "The current style is: " + Selection.Style


End Sub

Private Sub btnDeleteRowsOption_Click()
  

Module1.eModShadeTurnedOn = False '-- turn shading off
Me.tglShadeCurrentRow = False

  
  '-- elim the other fields
  optionType = "ExecutionTypeDeletion"
  
  Call loadExecTypeCbox1
  
  Me.optionsButton.Caption = "Press to DELETE the selected " + optionCboxLabel1 + " - " + optionSelectedExecutionType
  MsgBox "The Combo box below #1 now has the EXECUTION TYPES - please choose one.", , title1
  
  Me.optionCbox1.SetFocus
End Sub

Private Sub btnEmodBak_Click()
 
End Sub

Private Sub btneBak_Click()
Call Module1.eBak
End Sub

Private Sub btnHelp_Click()
   
Const titleCP = "Introduction to the Control Panel"

MsgBox "Control Panel (CP) Description: " + vbLf + vbLf + _
       "Note: The RIBBON eMODULE: Is an  Excel toolbar on top that has the main commands on the CP/NP forms." + vbLf + vbLf + _
       "1) To CLOSE the forms - Click on the form title or the forms EMPTY space." + vbLf + vbLf + _
       "2) VALIDATE the eModule via the green button. Includes deletion of (almost empty) and blank rows." + vbLf + vbLf + _
       "3) CLEAR formats - clears all comments, formatting, cond. formatting & error log." + vbLf + vbLf + _
       "4) PRODUCT QUERY TOOL (PQT) allows fast building of an eModule via QUERIES on products." + _
       "The results will be appended one line after the LAST row of the eModule." + vbLf + vbLf + _
       "There are two forms of use - one searches the entire Region to Product list (GKS) " + _
       "and the other only a specific list for a given Exchange and Product group. Both allow the " + _
       "use of keywords with AND/OR logical connectors to select matching products." + vbLf + vbLf + _
       "5) SELECT ALL - selects ALL filled rows in the eModule tab." + vbLf + _
       "Pressing the DEL key after SELECT ALL deletes all rows in the eModule." + vbLf + vbLf + _
       "6) EXCEL STYLES - styles/custom formats to make reading eModule lines easier.", , titleCP

MsgBox "7) EXECUTION type: These allow multiple ins/del of an exec. type." + vbLf + vbLf + _
       "This will copy/insert below all rows that match the selected exec. type. " + vbLf + vbLf + _
       "An example of the use of this: First enter rows for a single exec. type and then " + _
       "you can copy all those rows to a different execution type at once." + vbLf + vbLf + _
       "8) CONDITIONAL FORMATTING: Highlights a text in the entire eModule. " + _
       "Color-scales formats the BROKERAGE AMOUNT column for easy inspection and corrections." + vbLf + vbLf + _
       "9) ROW shading - the CURRENT row is shaded light blue - can turn on/off." + vbLf + vbLf + _
       "10) eBak saves the eModule, then a date/time in a SEPARATE COPY of the current eModule in the same dir. - then closes it." + vbLf + vbLf + _
       "11) The eModule VERSION (top left side) gives eMod INFO of the last save date, num rows, author, etc. " + _
       "It also RESETS the reference data (restarts the eModule) and removes empty rows. " + _
       "This can be used to RESTART the eModule after an error - there is NO need to close/open the file.", , titleCP
       
 MsgBox "SUMMARY:" + vbLf + vbLf + _
        "1) We now have a greatly improved eMODULE in version 3.5 with default currency and bands." + vbLf + vbLf + _
        "2) Combo Boxes expand to fill the screen and most will open with a click on the box." + vbLf + vbLf + _
        "3) Quick NAVIGATION via the NP or to return near (cell A4) the main icons for validation click in ROW 3 below the column headings." + vbLf + vbLf + _
        "4) Tools to QUERY the product reference data and add multiple products at once (PQT/GKS)." + vbLf + vbLf + _
        "5) Tools to copy/paste data in the eMODULE and quickly complete a large eMODULE." + vbLf + vbLf + _
        "6) Multiple ways to REVIEW the data before a validation, text cond. format, check amounts with color scales etc. " + vbLf + vbLf + _
        "7) Since all PQT or GKS appends leave a BLANK LINE in between, each block can be reviewed separately." + vbLf + vbLf + _
        "8) We now have alternate color lines, custom sorts, excel filters, clear formats and hide columns." + vbLf + vbLf + _
        "9) VALIDATION will remove empty lines and will not report these as validation errors." + vbLf + vbLf + _
        "10) The RIBBON gives quick access to the CP/NP/PQT, tools and VALIDATION fron anywhere in the eModule.", vbExclamation, "SUMMARY - New Features"


End Sub

Private Sub btnInsertRowsExecutionType_Click()

 Module1.eModShadeTurnedOn = False '-- turn shading off
 Me.tglShadeCurrentRow = False

'-- need to gather the two execution types
optionType = "ExecutionCopyInsert"
Me.optionsButton.Caption = "Please SELECT in combo boxes 1 and 2 the EXECUTION TYPES to MATCH/COPY."

Call loadExecTypeCbox1
Call loadExecTypeCbox2

MsgBox "Please SELECT the Execution types 1-2 below and press the BUTTON BELOW to proceed.", , title1

Me.optionCbox1.SetFocus

End Sub


Private Sub btnNavigationPanel_Click()

Module1.eModShadeTurnedOn = False '-- turn shading off
Me.tglShadeCurrentRow = False
  
 
 frmNavigationPanel.Show
  frmControlPanel.hide
End Sub

Private Sub btnPerformValidation_Click()

  Call Module2.PerformValidation
 
 disableWorksheetSelectionChange = False
 
End Sub

Private Sub btnSelectAll_Click()
 
 Call Module1.SelectAll
 frmControlPanel.hide

End Sub

Private Sub btnSelectCopyInsertCurrentRow_Click()

Call selectCopyInsertCurrentRow

End Sub
Private Sub btnSortEmodule_Click()

Module1.disableWorksheetSelectionChange = True

Module1.eModShadeTurnedOn = False '-- turn shading off
Me.tglShadeCurrentRow = False


Call Module1.sortEmoduleStandard

Module1.disableWorksheetSelectionChange = False
End Sub


Private Sub eModInfo_Click()

Application.ScreenUpdating = False

Call Module1.eModInfo
Call Module1.clearEmodEscapeCharacters(True)
Call clearAllFormattingComments
Call emodVersionAndReset

Application.ScreenUpdating = True
frmControlPanel.hide
End Sub

Private Sub lblTitle_Click()

   Module1.disableWorksheetSelectionChange = False
   frmControlPanel.hide


End Sub

Private Sub optionCbox1_Change()

If optionType = "ExecutionCopyInsert" Then

   optionSelectedExecutionType1 = Me.optionCbox1.Text
   Me.optionsButton.Caption = "Press to confirm: Match=" + optionSelectedExecutionType1 + " Copy=" + optionSelectedExecutionType2
   Exit Sub
   
End If


If optionType = "ExecutionTypeDeletion" Then
   
   optionSelectedExecutionType = Me.optionCbox1.Text
   Me.optionsButton.Caption = "Press to DELETE ALL ROWS with the selected " + optionCboxLabel1 + " - " + optionSelectedExecutionType
   Exit Sub
End If


End Sub

Private Sub optionCbox2_Change()

If optionType = "ExecutionCopyInsert" Then

   optionSelectedExecutionType2 = Me.optionCbox2.Text
   Me.optionsButton.Caption = "Press to confirm: Match=" + optionSelectedExecutionType1 + " Copy=" + optionSelectedExecutionType2
   Exit Sub
   
End If




End Sub

Private Sub optionsButton_Click()


If Me.optionCbox1.Text = "" Then
   MsgBox "Combo box#1 is empty - Operation cancelled.", , title1
   Call formInit
   Exit Sub
End If

 Dim retVal As Variant

If optionType = "ExecutionTypeDeletion" Then

    optionSelectedExecutionType = Me.optionCbox1.Text
   
    retVal = MsgBox("Press YES to: " + vbLf + vbLf + _
                    Mid(Me.optionsButton.Caption, 9) + vbLf + vbLf + _
                    "Press NO to cancel operation.", vbYesNo, title1)
    
    If (retVal = vbYes) Then
    
        Call Module1.deleteRowsForExecutionType(optionSelectedExecutionType)
      Else
       MsgBox "Operation cancelled.", , title1
       Call formInit
    End If


End If


If optionType = "ExecutionCopyInsert" Then

    '--- this is more tricky than deletes
    '--- next to the exec type we have a 'default y/n' column which designates this exec is the default one, so we need to know if
    '--- this is the case to set it when adding a new exec type
    '--- also we have two options for amt - copy it or leave it blank - to force the user to fill it

    If (Me.optionCbox2.Value = "") Then
       MsgBox "Execution Type#2 has NOT been selected - Operation cancelled.", vbQuestion, title1
       Call formInit
       Exit Sub
    End If
    
     If (Me.optionCbox1.Value = Me.optionCbox2.Value) Then
       MsgBox "Both execution types are EQUAL - Operation cancelled.", vbQuestion, title1
       Call formInit
       Exit Sub
    End If
    

    retVal = MsgBox("Press YES - to proceed with the copy/insert operation.", vbYesNo, title1)
    
    If (retVal <> vbYes) Then
        MsgBox "Operation cancelled.", , title1
        Call formInit
        Exit Sub
        
    End If
    
   
    
    Dim defaultYN As Integer
    Dim copyAmount As Integer
    Const title = "EXECUTION TYPE - Copy Options"

    MsgBox "To COPY a row and INSERT it with a new EXECUTION TYPE  we have two options:" + vbLf + vbLf + _
           "1) DEFAULT Y/N:" + vbLf + _
           "Specify if the Execution Type will have 'DEFAULT Y/N' next to it set to Y or set to Blank (N)." + vbLf + vbLf + _
           "If the source execution type is set to 'Y' you DO NOT WANT to copy it since validation will flag a duplicate default." + vbLf + _
           "If the source execution type is set to 'N' or blank - you may want the new execution set to Y." + vbLf + vbLf + _
           "2) AMOUNT COPY/BLANK: Specify if the AMOUNT is to be copied over from the source row or if we leave the AMOUNT blank." + vbLf + vbLf + _
           "If the amount is NOT COPIED the USER has to fill the amounts to pass validations, anyway copied amounts need revision.", , "New Type: " + optionSelectedExecutionType2

    defaultYN = _
    MsgBox("1) DEFAULT Y/N:" + vbLf + _
           "Specify if the NEW Execution ROW Type will have 'DEFAULT Y/N' next to it set to Y." + vbLf + vbLf + _
           "Please select 'YES' to set the 'DEFAULT Y/N' to 'Y'" + vbLf + vbLf + _
           "Please select 'NO'  to set the 'DEFAULT Y/N' to ' '" + vbLf + vbLf + _
           "Choose Cancel to exit the updates.", vbYesNoCancel, "New Type: " + optionSelectedExecutionType2)
          
    If defaultYN = vbCancel Then
       MsgBox "EXECUTION TYPE inserts cancelled", , title
       Exit Sub
    End If
          
    copyAmount = _
    MsgBox("1) AMOUNT:" + vbLf + _
           "Specify if the NEW Execution Type ROW will have the SAME amount or an EMPTY amount." + vbLf + vbLf + _
           "Please select 'YES' to copy the 'AMOUNT' from the source row - AMOUNT needs to be REVISED by the user." + vbLf + vbLf + _
           "Please select 'NO'   to set the 'AMOUNT' to blanks to be filled by the user." + vbLf + vbLf + _
           "Choose Cancel to exit the updates.", vbYesNoCancel, "New Type: " + optionSelectedExecutionType2)
  
    If copyAmount = vbCancel Then
       MsgBox "EXECUTION TYPE inserts cancelled", , title
       Exit Sub
    End If
  

    If optionSelectedExecutionType1 > "" And optionSelectedExecutionType2 > "" And optionSelectedExecutionType1 <> optionSelectedExecutionType2 Then
      Call Module1.copyInsertRowsForExecutionType(optionSelectedExecutionType1, optionSelectedExecutionType2, defaultYN, copyAmount)
    End If

Call formInit

End If

Application.ScreenUpdating = True

Application.cutCopyMode = False

Application.DisplayAlerts = False

Call clearOptionData

End Sub


Private Sub tglFilter_Click()

Dim addr As String
addr = Module1.eModHeadingsRangeAddr
If tglFilter Then
  Range(addr).Select
  Selection.AutoFilter
  tglFilter.Caption = "Filter Off"
 Else
  Range(addr).Select
  Selection.AutoFilter
  tglFilter.Caption = "Filter On"
 End If
 
End Sub

Private Sub tglShadeCurrentRow_Click()

Call Module1.clearAllFormats(False)
'-- NEED TO KNOW WE HAVE A CLEAN SPREADSHEET

   Module1.eModShadeTurnedOn = tglShadeCurrentRow.Value
     
   If tglShadeCurrentRow.Value Then
   
      If ActiveCell.row >= ModuleFirstRow Then
         MsgBox "Row SHADING has been turned ON. Press again to turn OFF." + vbLf + vbLf + "The Current row is row#  " + CStr(ActiveCell.row) + " With address: " + ActiveCell.Address, , title2
         Call ModuleSheet.eModCurrentRowShade
       '  Call Module1.clearAllFormats(True)
         frmControlPanel.hide
      End If
      
     Else
     
     
     
      If Module1.eModLastCellrng Is Nothing Then
          Call Module1.formatNumericColumns '--issue lost num formats
         Exit Sub
      End If
           
      Call ModuleSheet.eModCurrentRowUnshade(eModLastCellrng)
      Call Module1.clearAllFormats(True)
       
      MsgBox "Row SHADING has been turned OFF.", , title2
      
      Set Module1.eModLastCellrng = Nothing
      
   End If
   
  Call Module1.formatNumericColumns '--issue lost num formats
   frmControlPanel.hide
   
End Sub

'------------- CENTEAL SUB TO CALL PQT

Public Sub prodQuery_Click()
'MsgBox "WIP!", , title1
  Call Module1.openPQTform
  
End Sub




Private Sub UserForm_Activate()

Call formInit

End Sub

Private Sub UserForm_Click()

Module1.disableWorksheetSelectionChange = False
frmControlPanel.hide

End Sub

Private Sub UserForm_Deactivate()
Module1.disableWorksheetSelectionChange = False
End Sub

Private Sub UserForm_Error(ByVal Number As Integer, ByVal Description As MSForms.ReturnString, ByVal SCode As Long, ByVal Source As String, ByVal HelpFile As String, ByVal HelpContext As Long, ByVal CancelDisplay As MSForms.ReturnBoolean)
Module1.disableWorksheetSelectionChange = False
End Sub

Private Sub UserForm_Initialize()

Module1.disableWorksheetSelectionChange = True

Call formInit
'-- avoid whiteout
Application.ScreenUpdating = True
DoEvents

End Sub

Private Sub formInit()


Module1.disableWorksheetSelectionChange = True

If performValidationTime > Date - 1 Then

   frmControlPanel.validationDateTime = CStr(performValidationTime)

End If

 
'   - clean up options
Call clearOptionData

End Sub

Private Sub clearOptionData()

Me.optionCbox1.Clear
Me.optionCboxLabel1 = ""
Me.optionCbox2.Clear
Me.optionCboxLabel2 = ""

Me.optionTxtBox.Value = ""
Me.optionTxtBoxLabel = ""

Me.FrameOptions.Visible = False

End Sub

Public Sub selectCopyInsertCurrentRow()

'--- button SCICR

Dim col1 As String
col1 = "A"

Dim col2 As String
col2 = Module1.LastColumn '-- REGION IS MORE USED

Dim currCell As Range

Set currCell = ActiveCell
If currCell.Cells.Count <> 1 Then
   MsgBox "Use this button when you have one eModule cell selected.", , title1
   Exit Sub
End If

Dim row As Long
row = currCell.row

Dim addr1 As String
addr1 = col1 + CStr(row) + ":" + col2 + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

ModuleSheet.Activate
rng1.Select
Selection.Copy
Selection.Insert Shift:=xlDown

Application.cutCopyMode = False '-- esc the select mode
Set rng1 = Nothing

Application.DisplayAlerts = False


MsgBox "The row# " + CStr(row) + " has been copied just below.", , "Range copied: " + addr1

End Sub




Private Sub UserForm_Terminate()
Module1.disableWorksheetSelectionChange = False
End Sub
Attribute VB_Name = "frmNavigationPanel"
Attribute VB_Base = "0{54B2D6A3-23CF-4921-8C58-B306BD8F409A}{9FD0E18B-4A21-4F70-AB78-EA690EB8F569}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private Sub btnControlpanel_Click()
frmControlPanel.Show
frmNavigationPanel.hide
End Sub

Private Sub btnCopyDown_Click()
Call Module1.cellCopyDown

End Sub

Private Sub btnDeleteRow_Click()

ModuleSheet.Activate
'
Dim currCell As Range
Set currCell = ActiveCell
'
Dim row As Long
row = currCell.row

If row < 4 Then
 MsgBox "Use this button when you have ONE eModule cell selected below row 3.", , title1
Exit Sub
End If
'
Dim addr1 As String
addr1 = CStr(row) + ":" + CStr(row)
'
Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)
rng1.Select

Dim retVal As Variant
retVal = MsgBox("Confirm deletion of selected row# " + CStr(row), vbQuestion + vbYesNo, "Please confirm deletion")
retVal = vbYes
If retVal <> vbYes Then
   Exit Sub
End If

rng1.Delete
'
Set rng1 = Nothing
End Sub

Private Sub btnFirstCell_Click()
ModuleSheet.Range("A4:A4").Select
End Sub


Private Sub btnFirstCol_Click()
Call gotoColumn(Module1.RegionColumn)
End Sub

Private Sub btnGotoBanding_Click()
Call gotoColumn(Module1.BandApplyColumn)
End Sub

Private Sub btnGotoBrokAmt_Click()
Call gotoColumn(Module1.AmountColumn)
End Sub

Private Sub btnGotoProduct_Click()
Call gotoColumn(Module1.ProductColumn)
End Sub

Private Sub btnGotoRegion_Click()
Call gotoColumn(Module1.RegionColumn)
End Sub

Private Sub btnGotoVolDisc_Click()
Call gotoColumn(Module1.TierDefinedBasedColumn)
End Sub

Private Sub btnHelp_Click()

Const titleNP = "Introduction to the Navigation Panel (NP)"

MsgBox "The Navigation/Copy Panel (or NP) is designed to stay open to assist the user." + vbLf + vbLf + _
       "ACCESS: The RIBBON eMODULE on top has an icon to open the NP form. Also the NP form can be opened via the 1st ICON above the Product column E." + vbLf + vbLf + _
       "The NP Form ALLOWS THE USER TO TYPE on the eModule and will REMAIN OPEN in the position the user chooses." + vbLf + vbLf + _
       "To close the NP click on the forms TITLE or any empty space in the form." + vbLf + vbLf + _
       "The 'Addr:' cell displays the active CELL Excel address next to it." + vbLf + vbLf + _
       "COPY/PASTE TOOLS:" + vbLf + _
       "The 'SELECT ROW - COPY INSERT DOWN' allows the user to select the current row and copy it below. " + _
       "This allows the user - for example - to copy a full row and then change the execution type etc." + vbLf + vbLf + _
       "The 'COPY DOWN' works if you select a (column) range BELOW a given non-empty cell and THEN click the COPY-DOWN button - " + _
       "it will then save the cells value and copy it DOWN into all cells below, SKIPPING any cell with a value." + vbLf + vbLf + _
       "Note: The NP uses the currently selected cell/row where the cursor is located as the basis row.", , titleNP
   

MsgBox "THE NAVIGATION BUTTONS: " + vbLf + _
       "The 'GO TO' buttons will move in the CURRENT ROW to the main columns: Region, Product Name, Brokerage Amount, VolDisc and Banding." + vbLf + vbLf + _
       "THE SELECT/INSERT/DELETE BUTTONS: " + vbLf + _
       "The 'SELECT ROW' selects the current row based on the currently active cell." + vbLf + _
       "The 'INSERT ROW' inserts a new (empty) row below the current one." + vbLf + _
       "The 'DELETE ROW' will remove the currently selected row (or the row of the CURRENT cell)." + vbLf + vbLf + _
       "THE STATUS BAR/SAVE EMOD: " + vbLf + _
       "There is a STATUS bar on the bottom which will display the column name@row and the CURRENT value." + vbLf + vbLf + _
       "When the NP form is CLOSED, the status will appear in the EXCEL STATUS bar at the bottom." + vbLf + vbLf + _
       "The 'Save eMod' button saves the current file of the eModule with the SAME name." + vbLf + vbLf + _
       "Note: Clicking on a COMBO BOX does NOT select the cell, please select another cell and then select the cell again.", , titleNP
       
End Sub

Private Sub btnInsertRow_Click()

Call insertRow

End Sub

Public Sub insertRow()

Dim rw As Long
Dim currCell As Range
Set currCell = ActiveCell

If currCell.Rows.Count <> 1 Then
   MsgBox "Now selected cell (row) or More than one row is selected", , title1
   Exit Sub
End If

rw = currCell.row

If rw < 5 Then
   MsgBox "Please use for rows after row 4", , title1
   Exit Sub
End If

Dim addr As String
addr = CStr(rw) + ":" + CStr(rw)

Rows(addr).Select
Selection.Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove

addr = "A" + CStr(rw) + ":A" + CStr(rw)
Range(addr).Select


End Sub

Private Sub btnLastRow_Click()
Call gotoLastRow
End Sub


Private Sub btnRegionColmn_Click()
gotoColumn (Module1.RegionColumn)
End Sub

Private Sub btnSaveEmod_Click()
ActiveWorkbook.Save
Dim msg As String
msg = "The eModule has been saved with name: " + vbLf + vbLf + ActiveWorkbook.name
Application.StatusBar = msg
MsgBox msg, , "eModule Saved"
End Sub

Private Sub btnSelectCurrentRow_Click()

Call selectCurrentRow

End Sub
Public Sub selectCurrentRow()

Dim col1 As String
col1 = "A"

ModuleSheet.Activate
Dim col2 As String
col2 = Module1.LastColumn '-- REGION IS MORE USED

Dim currCell As Range
Set currCell = ActiveCell
If currCell.Cells.Count <> 1 Then
   MsgBox "Use this button when you have one eModule cell selected.", , title1
   Exit Sub
End If

Dim row As Long
row = currCell.row

Dim addr1 As String
addr1 = col1 + CStr(row) + ":" + col2 + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)


rng1.Select
TxtRange.Value = rng1.Address

Set rng1 = Nothing
 
End Sub

Private Sub btnTopRow_Click()
Call gotoTopRow
End Sub



Private Sub UserForm_Activate()

Call formInit

End Sub

Private Sub formInit()
'Call cboxOptionsLoad
TxtRange.Value = ""
End Sub

Private Sub UserForm_Click()
frmNavigationPanel.hide
End Sub

Private Sub UserForm_Initialize()
Call formInit
'-- avoid whiteout
Application.ScreenUpdating = True
DoEvents

End Sub
Private Sub lblTitle_Click()

   Module1.disableWorksheetSelectionChange = False
   frmNavigationPanel.hide
 
End Sub

Private Sub btnLastColmn_Click()

Call gotoLastColumn

End Sub

Private Sub btnSelectCopyInsertCurrentRow_Click()

Module1.eModShadeTurnedOn = False '-- turn shading off
'Call Module1.clearAllFormats(False)

Call selectCopyInsertCurrentRow

End Sub


Private Sub prodQuery_Click()

Call openPQTform

End Sub

Public Sub selectCopyInsertCurrentRow()

'--- button SCICR
Module1.eModShadeTurnedOn = False '-- turn shading off



Dim col1 As String
col1 = "A"

ModuleSheet.Activate
Dim col2 As String
col2 = Module1.LastColumn '-- REGION IS MORE USED

Dim currCell As Range
Set currCell = ActiveCell
If currCell.Cells.Count <> 1 Then
   MsgBox "Use this button when you have one eModule cell selected.", , title1
   Exit Sub
  Else
   TxtRange.Value = ActiveCell.Address
End If

Dim row As Long
row = currCell.row

Dim addr1 As String
addr1 = col1 + CStr(row) + ":" + col2 + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)
Dim cel As Range
Dim foundData As Boolean
foundData = False

For Each cel In rng1
    If Trim(cel.Value) <> "" Then
      foundData = True
      Exit For
    End If
    
Next

If Not foundData Then
   MsgBox "No Data in row: " + CStr(row) + " to copy.", , title1
   Exit Sub
End If

   
rng1.Select
Selection.Copy
Selection.Insert Shift:=xlDown

Application.cutCopyMode = False '-- esc the select mode

TxtRange.Value = rng1.Address
Set cel = Nothing
Set rng1 = Nothing

End Sub

Public Sub gotoColumn(colum As String) '-- of the current cell

'--- 3/14/16-REG-Replace problematic hide/unhide cols with goto columns for main ones

Dim col As String
col = colum

If Trim(col) = "" Then
  Exit Sub
End If


ModuleSheet.Activate
Dim currCell As Range
Set currCell = ActiveCell

If currCell.Cells.Count <> 1 Then
    MsgBox "Use this button when you have ONE eModule cell selected.", , title1
    Exit Sub
   Else
    TxtRange.Value = ActiveCell.Address
End If
'----------------
Dim row As Long
row = currCell.row

If row < 4 Then
 MsgBox "Use this button when you have ONE eModule cell selected below row 3.", , title1
Exit Sub
End If

Dim addr1 As String
addr1 = col + CStr(row) + ":" + col + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

rng1.Select
TxtRange.Value = rng1.Address
Set rng1 = Nothing

End Sub




Public Sub gotoLastColumn() '-- of the current cell

Dim col As String
col = Module1.LastColumn

ModuleSheet.Activate
Dim currCell As Range
Set currCell = ActiveCell
If currCell.Cells.Count <> 1 Then
    MsgBox "Use this button when you have one eModule cell selected.", , title1
    Exit Sub
   Else
    TxtRange.Value = ActiveCell.Address
End If
'----------------
Dim row As Long
row = currCell.row

Dim addr1 As String
addr1 = col + CStr(row) + ":" + col + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

rng1.Select
TxtRange.Value = rng1.Address
Set rng1 = Nothing

End Sub


Public Sub gotoLastRow()

Dim lastRow As Long
lastRow = Module1.getModuleLastRow

ModuleSheet.Activate

Dim col As String
col = Module1.RegionColumn

Dim addr1 As String
addr1 = col + CStr(lastRow + 1) + ":" + col + CStr(lastRow + 1)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

rng1.Select
TxtRange.Value = rng1.Address
Set rng1 = Nothing

End Sub

Public Sub gotoRegionColumn() '-- of the current cell

Dim col As String
col = Module1.RegionColumn '-- REGION IS MORE USED

ModuleSheet.Activate
Dim currCell As Range
Set currCell = ActiveCell
If currCell.Cells.Count <> 1 Then
    MsgBox "Use this button when you have one eModule cell selected.", , title1
    Exit Sub
   Else
    TxtRange.Value = ActiveCell.Address
End If

Dim row As Long
row = currCell.row

Dim addr1 As String
addr1 = col + CStr(row) + ":" + col + CStr(row)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

rng1.Select
TxtRange.Value = rng1.Address
Set rng1 = Nothing

End Sub



Public Sub gotoTopRow()

Dim topRow As Long
topRow = Module1.ModuleFirstRow '-- REGION IS MORE USED

ModuleSheet.Activate

Dim col As String
col = Module1.RegionColumn

Dim addr1 As String
addr1 = col + CStr(topRow) + ":" + col + CStr(topRow)

Dim rng1 As Range
Set rng1 = Worksheets(ModuleSheetName).Range(addr1)

rng1.Select
TxtRange.Value = rng1.Address
Set rng1 = Nothing

End Sub


Attribute VB_Name = "frmProdQueryTool"
Attribute VB_Base = "0{901F48F2-8B38-4B20-B9C9-BF79929BCCE1}{7942D5D1-5CC8-4632-A129-E7DBD2F3F1FA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim ix As Integer
Const title = "eModule Product Query Tool"
Const saveResultsTab = "eModule" '-- 6/23/15-REG-DECIDED WITH ANDREW THE BEST IS TO POST TO THE EMOD
Dim cel As Range
Const lastRow = 10000 ''--- @@@ TO FIX - LAST ROW OF PROD TAB

Dim RegionLastRow As Long
Dim ExchangeLastRow As Long
Dim ProductGroupCodeLastRow As Long
Dim ProductLastRow As Long

Dim RegionSelect As String
Dim ExchangeSelect As String
Dim ProductGroupSelect As String
Const maxProdSelect = 2000
Dim ProductSelect(1 To maxProdSelect) As String
Dim ProductKeywords(1 To 12) As String
Dim ProductKeywordUsed(1 To 12) As Boolean
Dim firstMsg As Boolean

Const numberVisibleProductsInList = 33 '-- NEEDED TO TELL IN STATUS HOW MANY SELECTED ARE NOT VISIBLE
'-- DEPENDS ON FONT SIZE, TAHOMA FONT 10 - TESTED - 98% OF PRODS MAIN EXCH VISIBLE, ALSO CHANGED THE PROD GROUP MANY WHERE NOT FULLY VISIBLE

Dim firstWarnOnSelected As Boolean
Dim firstKeywSelectListMsg As Boolean
Dim keywcnt As Integer
Dim appendLastRow1 As Integer
Dim appendLastRow2 As Integer
Dim commonKeywords(1 To 80) As String



Private Sub btnLoadKeywFromProduct_Click()

End Sub



Private Sub closePQT_Click()
 Module1.disableWorksheetSelectionChange = False
 Unload Me
End Sub

Private Sub gkwHelp_Click()

Const titlepqt = "PQT - GLOBAL KEYWORD SEARCH (GKS)"

MsgBox "The GLOBAL Keyword Search (GKS) allows you to search the entire product reference data for up to three specific keywords." + vbLf + vbLf + _
       "The tool searches the Region, Exchange, Product Group, Product and Currency fields for the selected keywords." + vbLf + vbLf + _
       "Since the product reference data contains several thousand unique products, please be advised that the search may take up to a few minutes to complete." + vbLf + vbLf + _
       "Please be patient and do not close the program while the search is underway." + vbLf + vbLf + _
       "If more than one keyword is used in the search, a logical connector of OR or AND is applied." + vbLf + vbLf + _
       "The PQT form default is OR. To search for products that contain ALL the selected keywords, choose AND." + vbLf + vbLf + _
       "To search for products that contain one or another of the selected keywords, choose OR." + vbLf + vbLf + _
       "The logical connector must be chosen before pressing the GLOBAL Keyword Search button.", , titlepqt

MsgBox "EXAMPLES:" + vbLf + vbLf + _
       "Example 1: To find products in ALL exchanges for 'WHEAT' enter 'WHEAT' in keyword# 1 and press return for keyword prompt# 2." + vbLf + vbLf + _
       "Example 2: To find products for the CBOT exchange enter 'North America' (region) in keyword#1, 'CBOT' (exchange) in keyword#2 and use the 'AND' logical connector." + vbLf + vbLf + _
       "Example 3: To find products for the CBOT and prod groups with 'EqIdx-USD...' do like example 2 and for keyword#3 enter 'EqIdx-USD'." + vbLf + vbLf + _
       "In most cases you need to do some cleanup in the " + saveResultsTab + " to eliminate unwanted results." + vbLf + vbLf + _
       "The default currency of the product can also be used as a search term. Currencies are all abbreviated to their three letter ISO-code." + vbLf + vbLf + _
       "The search results are appended in the " + saveResultsTab + " tab for review.", , titlepqt
       
MsgBox "COMPARISON WITH KEYWORD SEARCH:" + vbLf + vbLf + _
       "The other structured searches are LIMITED to the currently selected " + _
       "Region + Exchange + Product Group - which give a limited list of products to choose from (in the list box)." + vbLf + vbLf + _
       "The GKS does not give a preview - but writes the results IMMEDIATELY to the " + saveResultsTab + "." + vbLf + vbLf + _
       "Since the GKS searches for matches in the ENTIRE product reference it can result in many unneded matches, specially for OR statements, or keywords that are too short or generic." + vbLf + vbLf + _
       "Then the user must inspect the results and remove all unneeded results or clear the results and refine the keywords, and repeat the process. In some cases using AND is needed." + vbLf + vbLf + _
       "Note that you do not need to gather all needed results in one search with GKS. You can do several and each will be appended after the last with a blank line in between." + vbLf + vbLf + _
       "You can combine search results from the standard 1-12 keyword search by exchange/prod group and the GKS." + vbLf + vbLf + _
       "To review/clean up results conditional formatting can be a great help.", , titlepqt


End Sub

Private Sub keywHelp_Click()


Const keywTitle = "Product Selection via KEYWORDS"

MsgBox "We now explain how product selection works when a Product KEYWORD is specified." + vbLf + vbLf + _
       "The three ways products are selected is by: " + vbLf + vbLf + _
       "1) MANUAL Selection by the user (user clicks on the product)." + vbLf + vbLf + _
       "2) The user ADDS KEYWORDS and this may select more products" + vbLf + _
       "   and may depend on the logical and/or connector if more than one keyword." + vbLf + vbLf + _
       "3) The user selects a Product TYPE - like Futures or Options." + vbLf + vbLf + _
       "Note that the USER always has a choice to select/unselect products MANUALLY.", , keywTitle
       
MsgBox "KEYWORDS allow the user to search a given list or globally the entire reference data." + vbLf + vbLf + _
       "For the list of products we have a list to the right of up to 12 keywords." + vbLf + vbLf + _
       "For the global keyword search (GKS) up to 3 keywords are prompted for separately." + vbLf + vbLf + _
       "For the global search you can skip a prompt to stop asking for keywords." + vbLf + vbLf + _
       "In GKS if there are keywords in the list (up to 3) we will use them as defaults in the prompts." + vbLf + vbLf + _
       "Both will use the logical connector AND/OR when we have more than one keyword.", , keywTitle
       

MsgBox "For the standard (non-global) search of a given list the keywords have extra support: " + vbLf + vbLf + _
       "You can ENTER A KEYWORD manually next to the ADD button and press the ADD button to add it to the list." + vbLf + vbLf + _
       "If a keyword contains spaces etc. the entire keyword will need a match to work properly." + vbLf + vbLf + _
       "Make keywords as SHORT as possible - long keywords will have LESS matches." + vbLf + vbLf + _
       "You can always unselect products that have been selected via keywords." + vbLf + vbLf + _
       "You can select a keyword and press the:  " + Me.btnDeleteSelectedItems.Caption + "  button to remove it.", , keywTitle
       
MsgBox "USING PRODUCTS TO GET KEYWORDS:" + vbLf + vbLf + _
       "You can CLICK on a PRODUCT in the list and press the button: " + Me.btnKeywFromProduct.Caption + _
       " - this will extract ALL words (separated by spaces) from the product name and add EACH WORD as a keyword." + vbLf + vbLf + _
       "Note that the product TYPE (in parenthesis) will NOT be added to the list." + vbLf + vbLf + _
       "Next you can ADD or REMOVE keywords. Then decide if you want the OR/AND logical connector." + vbLf + vbLf + _
       "Note: if you select AND - the products with the same keywords in different ORDER are selected.", , keywTitle

MsgBox "The KEYWORDS LIST has buttons for it's maintenance above:" + vbLf + vbLf + _
       "You can clear all keywords in the list via: " + Me.btnClearKeywords.Caption + vbLf + vbLf + _
       "You can clear all keywords and products selections in both lists via: " + Me.btnClearSelProdsKeyw.Caption + vbLf + vbLf + _
       "A keyword that has not been added (and is in the ADD text box) does not count." + vbLf + vbLf + _
       "The limit will be up to 12 keywords.", , keywTitle

MsgBox "Another option to make keywords entry even easier is based on a list (hidden by default) " + _
       "of all the most COMMON KEYWORDS in the product reference list. To activate this list press " + _
       "the on/off button named: " + Me.tglKeywList.Caption + vbLf + vbLf + _
       "You can press this button again to hide the common keywords list and associated buttons." + vbLf + vbLf + _
       "This list has two forms - sorted by FREQUENCY (in the reference list) or ALPHA sort." + vbLf + vbLf + _
       "You can SELECT ONE OR MORE keywords from it and then press ADD KEYWORDS to add them to the Keywords LIST.", , keywTitle

End Sub

Private Sub miscHelp_Click()

Const miscTitle = "Introducing the Misc Data Fields"


MsgBox "There are a number of items you can specify BEFORE you press the APPEND button." + vbLf + vbLf + _
       "You can specify: " + vbLf + vbLf + _
       "1) EXECUTION TYPE" + vbLf + vbLf + _
       "2) RATE TYPE" + vbLf + vbLf + _
       "3) BROKERAGE AMOUNT" + vbLf + vbLf + _
       "Each works independently of the other and applies to the current search results." + vbLf + vbLf + _
       "NOTE: This will remain active after they are selected - please be sure to reset" + vbLf + _
       "them to blank when they are not needed.", , miscTitle

 MsgBox "EXAMPLE - EXECUTION TYPES:" + vbLf + vbLf + _
        "For example if you need several execution types for the current search results " + _
        "you can do the append with a SPECIFIC execution type and AFTER the results " + _
        "are in the eModule you can use the CP - the MASS COPY BY EXECUTION TYPE tool." + vbLf + vbLf + _
        "Since it's only one execution type maybe you can also specify the brokerage amount and rate type too?" + vbLf + vbLf + _
        "Then copy the entire block of rows from one execution type to another!." + vbLf + vbLf + _
        "The same process can be repeated for each execution type wanted." + vbLf + vbLf + _
        "Next you need to specify the brokerage amounts for each line - in some cases you can " + _
        "use COPY DOWN to copy some prices, and at the end use COLOR SCALES to inspect the results.", , miscTitle
        
 MsgBox "PRODUCT TYPE: When you specify a product type (Futures etc) - you also need " + _
        "to reset this value after a search - just select the 1st empty value." + vbLf + vbLf + _
        "STATUS BAR: Note that on the bottom of the form just below the product list " + _
        "There is a status bar that has all the relevant info on the selected items, " + _
        "including items below the last visible line and the product TYPE (if any) and the LOGICAL connector in use.", , miscTitle

       



End Sub

Private Sub prodTypeInfo_Click()

Const prodTitle = "Introducing Product TYPE Selection"

MsgBox "We now explain how product selection works when a Product TYPE is specified." + vbLf + vbLf + _
       "All products have a TYPE - like Futures or Options." + vbLf + vbLf + _
       "The three ways products are selected is by: " + vbLf + vbLf + _
       "1) MANUAL Selection by the user (user clicks on the product)." + vbLf + vbLf + _
       "2) The user ADDS KEYWORDS and this may select more products" + vbLf + _
       "   and may depend on the logical and/or connector if more than one keyword." + vbLf + vbLf + _
       "3) The user selects a Product TYPE - like Futures or Options." + vbLf + vbLf + _
       "ALL products are coded with a type at the end of their description as in (FUT)." + vbLf + vbLf + _
       "Note that the USER always has a choice to select/unselect products MANUALLY.", , prodTitle
       
MsgBox "There are two cases of selection by Product TYPE: " + vbLf + vbLf + _
       "Case 1 - when there are NO products selected and NO keywords." + vbLf + vbLf + _
       "Case 2 - when there ARE products selected or there ARE keyword(s).", , prodTitle
       
MsgBox "Case 1 - if there NO products selected or Keywords: " + vbLf + vbLf + _
       "In this case we select ALL products that match the Product TYPE." + vbLf + vbLf + _
       "That is that at the end of the product description it has in" + vbLf + vbLf + _
       "parenthesis a code that is equivalent to the product type selected." + vbLf + vbLf + _
       "The USER now has a choice to select/unselect products MANUALLY.", , prodTitle
       
MsgBox "Case 2 - if there ARE products Selected or Keywords: " + vbLf + vbLf + _
       "In this case we assume the user wants to select only" + vbLf + vbLf + _
       "those products selected that also have the specified Product TYPE." + vbLf + vbLf + _
       "For this we proceed by first adding to the selected products (if any)" + vbLf + vbLf + _
       "other product that MATCHES the keyword(s) according to the logical connector." + vbLf + vbLf + _
       "Then we take all those now selected and see if they match the Product TYPE." + vbLf + vbLf + _
       "If a selected product does NOT match the Product Type it is unselected." + vbLf + vbLf + _
       "If a selected product matches the Product Type it is kept as selected.", , prodTitle

       
MsgBox "Both cases below are processed AFTER keyword(s) are processed: " + vbLf + vbLf + _
       "Case 1 - when there are NO products selected and NO keywords." + vbLf + vbLf + _
       "Case 2 - when there ARE products selected OR there ARE keyword(s)." + vbLf + vbLf + _
       "Keyword(s) processing always leaves alone all previously selected products." + vbLf + vbLf + _
       "At any stage the user can clear all the keywords, clear all selected products," + vbLf + vbLf + _
       "clear the product type, select or unselect any products etc. Some selected " + vbLf + vbLf + _
       "products may not be visible in the list - see that STATUS BAR for details.", , prodTitle
       
       
End Sub

'Private Sub lblKeyList_Click()
'Call enableKeywordList
'End Sub

Private Sub tglKeywList_Click()

Dim keyw As Boolean
keyw = Me.tglKeywList

Call enableKeywordList(keyw)
   

End Sub


Sub loadCommonKeywordsListByFreq()

'--- COMMODITIES
commonKeywords(1) = "FUTURE"
commonKeywords(2) = "OPTION"
commonKeywords(3) = "CORN"
commonKeywords(4) = "SWAP"
commonKeywords(5) = "INDEX"
commonKeywords(6) = "GAS"
commonKeywords(7) = "NATURAL"
commonKeywords(8) = "WHEAT"
commonKeywords(9) = "SEASONAL"

commonKeywords(10) = "OIL"
commonKeywords(11) = "WEEKLY"
commonKeywords(12) = "MONTHLY"
commonKeywords(13) = "STRIP"
commonKeywords(14) = "PRICE"
commonKeywords(15) = "SUGAR"
commonKeywords(16) = "EURO"
commonKeywords(17) = "EURODOLLAR"
commonKeywords(18) = "CRUDE"
commonKeywords(19) = "POWER"

commonKeywords(20) = "MONTH"
commonKeywords(21) = "CBOE"
commonKeywords(22) = "HEATING"
commonKeywords(23) = "YEAR"
commonKeywords(24) = "FIXED"
commonKeywords(25) = "ELECTRICITY"
commonKeywords(26) = "DOW JONES"
commonKeywords(27) = "CALENDAR"
commonKeywords(28) = "PETROLEUM"
commonKeywords(29) = "BASIS"

commonKeywords(30) = "GASOIL"
commonKeywords(31) = "FUEL"
commonKeywords(32) = "MINI"
commonKeywords(33) = "BRENT"
commonKeywords(34) = "FINANCIAL"
commonKeywords(35) = "DOLLAR"
commonKeywords(36) = "USD"
commonKeywords(37) = "CURRENCY"
commonKeywords(38) = "CHICAGO"
commonKeywords(39) = "SINGAPORE"

commonKeywords(40) = "EUROPEAN"
commonKeywords(41) = "TREASURY NOTE"
commonKeywords(42) = "COFFEE"
commonKeywords(43) = "COAL"
commonKeywords(44) = "COTTON"
commonKeywords(45) = "CATTLE"
commonKeywords(46) = "LEAN HOGS"
commonKeywords(47) = "SOYBEAN"
commonKeywords(48) = "SOY OIL"
commonKeywords(49) = "COPPER"

commonKeywords(50) = "PLATINUM"
commonKeywords(51) = "COCOA"
commonKeywords(52) = "SOYBEAN MEAL"
commonKeywords(53) = "U.S. DOLLAR"
commonKeywords(54) = "DOLLAR"
commonKeywords(55) = "AUSTRALIAN DOLLAR"
commonKeywords(56) = "CANADIAN DOLLAR"
commonKeywords(57) = "NEW ZEALAND DOLLAR"
commonKeywords(58) = "NORWEGIAN KRONE"
commonKeywords(59) = "SWEDISH KRONA"

commonKeywords(62) = "SWISS FRANC"
commonKeywords(63) = "CROSS-RATE"
commonKeywords(64) = "STOXX"
commonKeywords(65) = "STOCK"
commonKeywords(67) = "LIGHT ENDS"
commonKeywords(68) = "MIDDLE DISTILLATES"
commonKeywords(69) = "UNLEADED"

commonKeywords(70) = "PROPANE,"
commonKeywords(71) = "DIESEL"
commonKeywords(72) = "JET KERO"

Me.lstCommonKeyw.Clear

Const lastIndex = 72

For ix = 1 To lastIndex

 If (commonKeywords(ix) <> "") Then
    Me.lstCommonKeyw.AddItem (commonKeywords(ix))
 End If
    
Next

End Sub

Public Sub loadCommonKeywordsListByAlpha()


commonKeywords(1) = "AUSTRALIAN DOLLAR"
commonKeywords(2) = "BASIS"
commonKeywords(3) = "BRENT"
commonKeywords(5) = "CALENDAR"
commonKeywords(6) = "CANADIAN DOLLAR"
commonKeywords(7) = "CATTLE"
commonKeywords(8) = "CBOE"
commonKeywords(9) = "CHICAGO"
commonKeywords(10) = "COAL"
commonKeywords(11) = "COCOA"
commonKeywords(12) = "COFFEE"
commonKeywords(14) = "COPPER"
commonKeywords(15) = "CORN"
commonKeywords(16) = "COTTON"
commonKeywords(17) = "CROSS"
commonKeywords(18) = "CRUDE"
commonKeywords(19) = "CURRENCY"
commonKeywords(20) = "DIESEL"
commonKeywords(21) = "DOLLAR"
commonKeywords(22) = "Dollar"
commonKeywords(23) = "DOW JONES"
commonKeywords(24) = "ELECTRICITY"
commonKeywords(25) = "EURO"
commonKeywords(26) = "EURODOLLAR"
commonKeywords(27) = "EUROPEAN"
commonKeywords(28) = "FINANCIAL"
commonKeywords(29) = "FIXED"
commonKeywords(30) = "FUEL"
commonKeywords(31) = "FUTURE"
commonKeywords(32) = "GAS"
commonKeywords(33) = "GASOIL"
commonKeywords(34) = "HEATING"
commonKeywords(35) = "INDEX"
commonKeywords(36) = "JET KERO"
commonKeywords(37) = "LEAN HOGS"
commonKeywords(38) = "LIGHT ENDS"
commonKeywords(39) = "MIDDLE DISTILLATES"
commonKeywords(40) = "MINI"
commonKeywords(41) = "MONTH"
commonKeywords(42) = "MONTHLY"
commonKeywords(43) = "NATURAL"
commonKeywords(44) = "NEW ZEALAND DOLLAR"
commonKeywords(45) = "NORWEGIAN KRONE"
commonKeywords(46) = "OIL"
commonKeywords(47) = "OPTION"
commonKeywords(48) = "PETROLEUM"
commonKeywords(49) = "PLATINUM"
commonKeywords(51) = "POWER"
commonKeywords(52) = "PRICE"
commonKeywords(53) = "PROPANE"
commonKeywords(54) = "SEASONAL"
commonKeywords(55) = "SINGAPORE"
commonKeywords(56) = "SOY OIL"
commonKeywords(57) = "SOYBEAN"
commonKeywords(58) = "SOYBEAN MEAL"
commonKeywords(59) = "STOCK"
commonKeywords(60) = "STOXX"
commonKeywords(61) = "STRIP"
commonKeywords(62) = "SUGAR"
commonKeywords(63) = "SWAP"
commonKeywords(64) = "SWEDISH KRONA"
commonKeywords(65) = "SWISS FRANC"
commonKeywords(66) = "TREASURY NOTE"
commonKeywords(67) = "U.S.Dollar"
commonKeywords(68) = "UNLEADED"
commonKeywords(69) = "USD"
commonKeywords(70) = "WEEKLY"
commonKeywords(71) = "WHEAT"
commonKeywords(72) = "YEAR"


Me.lstCommonKeyw.Clear

Const lastIndex = 72

For ix = 1 To lastIndex

 If (commonKeywords(ix) <> "") Then
    Me.lstCommonKeyw.AddItem (commonKeywords(ix))
 End If
    
Next




End Sub




Private Sub addFutures_Click()

addKeyword ("FUTURES")

End Sub

Private Sub addOptions_Click()

addKeyword ("OPTIONS")
 
End Sub




Private Sub addKeyword(keyword As String)

If Me.ListBoxKeywords.ListCount = 12 Then
   MsgBox "The list has reached the limit of 12 keywords.", , title1
   Exit Sub
End If

keyword = UCase(Trim(keyword))
If keyword = "" Then
   Exit Sub
End If

Me.ListBoxKeywords.AddItem keyword

End Sub


Private Sub btnAddKeyword_Click()
btnSelectProductsByKeywords.Enabled = True
addKeyword (Me.txtBoxProdKeywordToAdd.Value)
Me.txtBoxProdKeywordToAdd.Value = ""
Call updateProdStatus
End Sub

Private Sub btnClearKeywList_Click()

Call clearAllKeywords

End Sub


Public Sub clearAllKeywords()
Me.ListBoxKeywords.Clear
Me.txtBoxProdKeywordToAdd.Value = ""
Call updateProdStatus
End Sub

Private Sub appendSelectedProdsEmodule(appendOk As Boolean)

appendOk = False '-- return true to exit the PQT since the append was done
'------------------- all exit sub will pass the false appendOk

'--- MAIN PROCESSING OF THE PQT - APPENDS TO THE EMODULE - AFTER BOOLEAN LOGIC OR USER  HAS SELECTED PRODS

'called by btnAppendSelectedProdsEmodule_Click()

Dim px As Integer
px = 0
Dim pselCnt As Integer
pselCnt = 0


Dim logical As String
If IsNull(Me.lboxLogic.Value) Then
   MsgBox "Please select a LOGICAL AND/OR first.", , title1
   Me.lboxLogic.SetFocus
   Exit Sub
End If

If lboxProduct.ListCount = 0 Then
   MsgBox "No products available in list box to search.", , title
   Exit Sub
End If

For ix = 0 To lboxProduct.ListCount - 1

     If lboxProduct.Selected(ix) Then
         px = px + 1
         ProductSelect(px) = lboxProduct.List(ix)
    End If
    
Next
pselCnt = px

If px = 0 Then
   MsgBox "No products have been selected in the list box.", vbExclamation, title
   Exit Sub
End If
   
 
logical = Me.lboxLogic.Value

Dim msgDefaults As String

Dim executionType As String
executionType = Me.cboxExecutionType.Value
If (executionType > "") Then
   msgDefaults = "Execution Type: " + executionType
End If

Dim retVal As Integer


Dim rateType As String
rateType = Me.cboxRateType.Value
If (rateType > "") Then
   msgDefaults = msgDefaults + vbLf + "Rate Type: " + rateType
End If

Dim userAmount As Single
Dim userAmountInput As String
userAmountInput = ""
userAmount = 0

userAmountInput = Trim(Me.txtBrokerageAmount.Value)

If userAmountInput <> "" Then '-- spaces are ok - no amt

    If IsNumeric(userAmountInput) Then
       
       userAmount = CSng(userAmountInput)
       txtBrokerageAmount.Value = format(userAmountInput, Module1.decimalFormat1)
   Else
       MsgBox "Invalid NON-Numeric amount of:  " + userAmountInput + " - Brokerage amount will NOT be updated." + vbLf + vbLf + _
              "Stopping processing. Please correct or clear the amount.", , title1
       userAmount = 0
       userAmountInput = ""
       Exit Sub
    End If
    
    If userAmount < 0 Then
       MsgBox "Invalid amount of:  " + userAmountInput + " - Negative amount - Brokerage amount will NOT be updated." + vbLf + vbLf + _
              "Stopping processing. Please correct or clear the amount.", , title1
       userAmount = 0
       userAmountInput = ""
       Exit Sub
    End If

End If

If (userAmount > 0) Then
   msgDefaults = msgDefaults + vbLf + "Amount of: " + CStr(userAmount)
End If



Dim wks As Worksheet
Set wks = Worksheets(saveResultsTab)
wks.Activate


Dim rngProduct As Range
Dim tmp0 As String
Dim tmp1 As String
Dim tmp2 As String
Dim tmp3 As String
Dim tmp4 As String
Dim tmp5 As String
Dim tmp6 As String
Dim tmp7 As String
Dim tmp8 As String
Dim tmp9 As String

Dim addrtmp As String
Dim addr1 As String

If Module1.ProductLastRow = 0 Then
   Call Module1.SetLastRow
End If

   

'------------- important - note the search range is the entire product ref table
addr1 = "$" & RefDataRegionColumn & "$" & HeaderRowOffset & ":$" & RefDataRegionColumn & "$" & Module1.ProductLastRow

Set rngProduct = Product.Range(addr1)

Dim msgExecType As String

If Trim(executionType) = "" Then
      msgExecType = "No EXECUTION TYPE has been selected." + vbLf + vbLf + "Cancel to specify an execution type and other optional values."
     Else
      msgExecType = ""
End If




Dim addr2 As String
Dim rowLine As Integer
Dim rowLines As String
Dim insertCnt As Integer
Dim rowDestFirstRow As Long
insertCnt = 0
Dim initialLastRow As Integer

initialLastRow = Module1.getModuleLastRow

rowLine = initialLastRow + 2 '-- skip a line after each add

Me.lbleModuleMsg.Caption = "Append will start on Row# " + CStr(rowLine)

Dim exchangeMsg As String
exchangeMsg = "Current EXCHANGE and Product GROUP are:  " + ExchangeSelect + "  --  " + ProductGroupSelect


Dim appendMsg As String

If msgDefaults <> "" Then
   
  appendMsg = "SUMMARY of results to append to the eModule: " + vbLf + vbLf + _
              "1) COUNT: Append the  " + CStr(pselCnt) + "  selected products on Row# " + CStr(rowLine) + "." + vbLf + vbLf + _
              "2) " + exchangeMsg + vbLf + vbLf + _
              "3) OPTIONAL VALUES:" + vbLf + vbLf + msgDefaults + vbLf + vbLf + _
              "If any of these optional values are not correct, " + _
              "cancel the append now and correct or clear them, then press append again."

  Else
 
  appendMsg = "SUMMARY of results to append to the eModule: " + vbLf + vbLf + _
              "1) COUNT: Append the  " + CStr(pselCnt) + "  selected products on eModule Row# " + CStr(rowLine) + "." + vbLf + vbLf + _
              "2) " + exchangeMsg + vbLf + vbLf + _
              "3) OPTIONAL VALUES: If any optional values are missing, like the execution type, " + _
              "cancel the append now and select them, then press append again."
 
 
End If
 

retVal = MsgBox(appendMsg, vbInformation + vbOKCancel, "Reply OK to APPEND query results, cancel to make changes")

If retVal <> vbOK Then
  MsgBox "Append of query results to the eModule has been Cancelled.", vbExclamation, title
  Exit Sub
End If

rowDestFirstRow = rowLine

For Each cel In rngProduct
      
    rowLines = CStr(rowLine)
      
    If insertCnt = 0 Then
      addrtmp = Module1.FirstColumn + rowLines + ":" + Module1.AmountColumn + rowLines
    
    End If
     
    tmp0 = Trim(cel.Offset.Value) '--region
    tmp1 = Trim(cel.Offset(, 1).Value) '---exch
    tmp2 = Trim(cel.Offset(, 2).Value) '--- pro grp
  
    
    If (tmp0 = RegionSelect) And (tmp1 = ExchangeSelect) And (tmp2 = ProductGroupSelect) Then
       
       For px = 1 To pselCnt
              
            tmp3 = Trim(cel.Offset(, 3).Value)
            tmp9 = Trim(cel.Offset(, 5).Value) '---def currency
            tmp6 = tmp3 + " (" + Trim(cel.Offset(, 4).Value) + ")" '-- space before (, added (type) to prod desc
              
           If (ProductSelect(px) = tmp6) Then
           '----------------- if the product was selected
           '-- IMPORTANT - RESTRICT TO ROW, ELSE IF SPACES -> ALL COLUMN
            
              rowLines = CStr(rowLine)
           
              tmp4 = Trim(cel.Offset(, 4).Value)
             
              tmp6 = Trim(rateType) '-- user specified, else spaces
              tmp7 = Trim(executionType) '-- user specified, else spaces
         
              If userAmount = 0 Then
                 tmp8 = "" '-- user specified, else spaces
                Else
                 tmp8 = userAmount '-- NUMERIC VALUE
              End If
              
              addr2 = Module1.RegionColumn + rowLines + ":" + Module1.RegionColumn + rowLines
              wks.Range(addr2).Value = tmp0
              
              addr2 = Module1.ExchangeColumn + rowLines + ":" + Module1.ExchangeColumn + rowLines
              wks.Range(addr2).Value = tmp1
              
              addr2 = Module1.ProductGroupCodeColumn + rowLines + ":" + Module1.ProductGroupCodeColumn + rowLines
              wks.Range(addr2).Value = tmp2
              
              addr2 = Module1.ProductColumn + rowLines + ":" + Module1.ProductColumn + rowLines
              wks.Range(addr2).Value = tmp3
              
              addr2 = Module1.ProductTypeColumn + rowLines + ":" + Module1.ProductTypeColumn + rowLines
              wks.Range(addr2).Value = tmp4
              
              addr2 = Module1.CurrencyColumn + rowLines + ":" + Module1.CurrencyColumn + rowLines
              wks.Range(addr2).Value = tmp9
              
              addr2 = Module1.RateTypeColumn + rowLines + ":" + Module1.RateTypeColumn + rowLines
              wks.Range(addr2).Value = tmp6
              
              addr2 = Module1.ExecutionTypeColumn + rowLines + ":" + Module1.ExecutionTypeColumn + rowLines
              wks.Range(addr2).Value = tmp7
              
              addr2 = Module1.AmountColumn + rowLines + ":" + Module1.AmountColumn + rowLines
              wks.Range(addr2).Value = tmp8
              wks.Range(addr2).NumberFormat = Module1.decimalFormat1
              
              insertCnt = insertCnt + 1
              
              rowLine = rowLine + 1 '-- careful where you post results
                
           End If
           
       Next
       
    End If
    
Next


If insertCnt > 0 Then
    
    appendOk = True
    
    Call Module1.eModReset '-- so that all combo boxes are loaded

End If


'--- RESET VALUES THAT SHOULD BE SET BY USER

If Me.cboxExecutionType.Text <> "" Then

    retVal = MsgBox("Do you want to CLEAR the Execution type and other optional values for any later searches.", vbQuestion + vbYesNo, title1)

    If retVal = vbYes Then
       Me.cboxExecutionType.Text = ""
       Me.cboxRateType.Text = ""
       Me.txtBrokerageAmount = ""
    End If

End If

Dim retValue As Variant

'--- ver 02 pqt - 3/22/16-add option to presever selection for mult exec types etc - see docn

retValue = _
MsgBox("Press 'YES' to CLEAR all selected products, 'NO' to KEEP the currently selected products." + vbLf + vbLf + _
       "Application Notes: If you select NO you need to clear them manually or via 'Clear Selections' button to avoid DUPLICATE rows." + vbLf + vbLf + _
       "You may select 'NO' too (keep selection) if you intend to append these SAME products with another Execution Price, Rate Type etc." + vbLf + vbLf + _
       "With the last method you can append the SAME list of selected products with specific Execution Type, Rates and Amounts.", vbYesNo + vbQuestion, "CLEAR SELECTED PRODUCTS?")
                           
                           
If retValue = vbYes Then
   Call clearProdKeywStatus '-- clear all to avoid duplicate searches
End If

Application.ScreenUpdating = True
Module1.disableWorksheetSelectionChange = False
 
Range("A" + CStr(rowDestFirstRow) + ":G" + CStr(rowDestFirstRow)).Select '-- same as GKS - select 1st copied row
 
End Sub


Private Sub btnAppendSelectedProdsEmodule_Click()

Module1.ComboBoxChange = False '-- avoid this adding asia etc

Application.ScreenUpdating = False

Module1.disableWorksheetSelectionChange = True

Dim appendOk As Boolean
appendOk = False

Call appendSelectedProdsEmodule(appendOk) '-- sub above
'---------------------------- main program

Application.cutCopyMode = False '-- release clipboard mem


If appendOk Then

    Module1.PQTinUseDisableCboxes = False

    Module1.PQTnotMsgDisplayed = True
    
    Application.EnableEvents = True
    
    Application.ScreenUpdating = True
    
    Module1.disableWorksheetSelectionChange = False '--- important to enable cboxes on emod
    
    Application.DisplayAlerts = True
    
    frmProdQueryTool.hide '-- no unload

End If

'-- ELSE LEAVE PQT OPEN

End Sub

Private Sub btnClearKeywords_Click()
Me.ListBoxKeywords.Clear
btnSelectProductsByKeywords.Enabled = False
Call updateProdStatus
End Sub

Private Sub btnClearProductsSelected_Click()
Call clearProductsSelected
Call updateProdStatus
End Sub

Public Sub clearProductsSelected()

For ix = 0 To lboxProduct.ListCount - 1
    lboxProduct.Selected(ix) = False
Next
Call updateProdStatus
End Sub

Private Sub btnClearSelection_Click()
Call clearProductsSelection
End Sub

Public Sub clearProductsSelection()

Dim ix As Integer
For ix = 0 To Me.lstCommonKeyw.ListCount - 1
     
    Me.lstCommonKeyw.Selected(ix) = False
Next

End Sub

Private Sub btnClose_Click()
frmProdQueryTool.hide
End Sub


Private Sub clearDataStored()

RegionSelect = ""
ExchangeSelect = ""
ProductGroupSelect = ""

For ix = 1 To maxProdSelect
    ProductSelect(ix) = ""
Next

'--- ATTEMP TO CLEAR A STACK ERROR - OUT OF MEM
Call clearDataSelectedSet

End Sub

Private Sub clearDataSelectedSet()


For ix = 0 To lboxRegion.ListCount - 1
    lboxRegion.Selected(ix) = False
Next

For ix = 0 To lboxExchange.ListCount - 1
    lboxExchange.Selected(ix) = False
Next

For ix = 0 To lboxProdGroup.ListCount - 1
    lboxProdGroup.Selected(ix) = False
Next

For ix = 0 To lboxProduct.ListCount - 1
    lboxProduct.Selected(ix) = False
Next

End Sub



Private Sub btnCloseForm_Click()
frmProdQueryTool.hide
End Sub

Private Sub btnClearSelProdsKeyw_Click()

Call clearProdKeywStatus

End Sub

Public Sub clearProdKeywStatus()

Me.btnSelectProductsByKeywords.Enabled = False
Me.btnAppendSelectedProdsEmodule.Enabled = False


Call clearProductsSelected
Call clearAllKeywords
Call updateProdStatus
End Sub


Private Sub btnDeleteSelectedItems_Click()

For ix = ListBoxKeywords.ListCount - 1 To 0 Step -1 '-- step back or else get error
    If ListBoxKeywords.Selected(ix) Then
       ListBoxKeywords.RemoveItem (ix)
    End If
Next
Call updateProdStatus
End Sub




Private Sub btnIntroPQT_Click()

Const titlepqt = "Introduction to the Product Query Tool (PQT)"
Const titlegks = "Introduction to the Global Keyword Search (GKS)"

MsgBox "The PQT is a tool to APPEND into the eModule the items: The Region - Exchange - Prod Group - Products by " + _
       "BLOCKS according to data you have SELECTED. These will be appended AFTER the LAST blank line." + vbLf + vbLf + _
       "The data used is the REFERENCE DATA of the eModule - thus it will pass PRODUCT validation." + vbLf + vbLf + _
       "The LOGICAL connectors:" + vbLf + _
       "The KEY item to understand FIRST is the use of the LOGICAL connectors - AND/OR." + vbLf + vbLf + _
       "1)When you have ONE keyword the logical connector AND/OR do not matter." + vbLf + vbLf + _
       "2)Use 'AND' when you want a PRODUCT to have ALL the keywords in it's name." + vbLf + vbLf + _
       "3)Use 'OR'  when you want a PRODUCT to have ONE of the keywords in it's name." + vbLf + vbLf + _
       "KEYWORDS:" + vbLf + _
       "4)The KEYWORDS can be typed in, from selected products, or from the common words list." + vbLf + vbLf + _
       "5)The products in the list can be SELECTED/DESELECTED by you MANUALLY via clicks on them. " + vbLf + vbLf + _
       "This is very important - it gives YOU the power in the FINAL selection.", , titlepqt
       
MsgBox "Note: The PQT and VALIDATION can be accessed more quickly via the eMODULE RIBBON." + vbLf + vbLf + _
       "PRODUCTS:" + vbLf + _
       "If there are many products there will be a scroll bar to see them." + vbLf + vbLf + _
       "The selection of Region + Exchange + Prod Group determines the products shown." + vbLf + vbLf + _
       "OPTIONAL VALUES: " + vbLf + _
       "If most of the products have the same EXECUTION type - select that value too." + vbLf + vbLf + _
       "THE APPEND BUTTON:" + vbLf + _
       "When the list is what you need - press the append button to append the selection in the eModule." + vbLf + vbLf + _
       "PQT and the CP/NP and RIBBON: " + vbLf + _
       "The results in the eModule can be further improved via the CP/NP and RIBBON via: " + vbLf + vbLf + _
       "Copy DOWN - fills a column with data on top and skips any existing values." + vbLf + _
       "Select INSERT COPY - copies the row above, Copy EXECUTION type - allows MASS copy of execution type." + vbLf + vbLf + _
       "DATA REVIEW:" + vbLf + _
       "To help review the data you have sorting, conditional formatting and number scales, Excel styles etc.", , titlepqt
       
MsgBox "GLOBAL KEYWORD SEARCH (GKS):" + vbLf + _
       "The GLOBAL KEYWORD SEARCH finds matches of up to 3 keywords in the ENTIRE >9K Region-Exchange-Products-Type-Currency list. " + vbLf + vbLf + _
       "In this type of search all results will be APPENDED to the eModule immediately - there is no manual selection." + vbLf + vbLf + _
       "For example if you just type 'CORN' all products (in all exchanges) that contain the word 'CORN' will be included. " + vbLf + vbLf + _
       "LOGICAL AND/OR:" + vbLf + _
       "The underlying logical AND/OR is used for more than one keyword. For example if you have the AND logical active, " + _
       "and then input 'SOY' and 'OIL' in the two prompts, and skip the 3rd prompt - it will look for all matches for BOTH keywords " + _
       "- such as SOYOIL or SOYBEAN OIL etc." + vbLf + vbLf + _
       "Example1: If you want ALL products for 'ASIA' exchanges (as a reference list) just enter Asia in the 1st keyword. " + _
       "All exchanges in the Asia region will be selected as well a products that have 'asia' in their names." + vbLf + vbLf + _
       "Example2: If you want the list of products for the CBOT exchange then use the AND and enter the keywords 'North America' and 'CBOT'.", , titlegks

MsgBox "When the GKS starts all current selections in the PQT form are cleared (these are not relevant)." + vbLf + vbLf + _
       "Like all other PQT results a blank line is added before the results of the GKS." + vbLf + vbLf + _
       "The product type selection (in the PQT form) does NOT apply for the GKS option." + vbLf + vbLf + _
       "Next we describe the use of the PRODUCT TYPE option.", , titlegks

Call prodTypeInfo_Click
       
End Sub

Private Sub btnKeywFromProduct_Click()

Dim selectedProd As String
Dim currProdTokens() As String

Dim ix1 As Integer
Dim ix2 As Integer
Dim prodKeywCnt As Integer
Dim addedKeywCnt As Integer
Dim keywInList As Integer

Dim currProdToken As String
Dim currProd As String
Dim currProdToken2 As String

keywInList = Me.ListBoxKeywords.ListCount - 1

For ix1 = 0 To lboxProduct.ListCount - 1

    If lboxProduct.Selected(ix1) Then
       
       selectedProd = lboxProduct.List(ix1)
       
       currProdTokens = Split(selectedProd, " ", 12) '-- an array - max size 12, delim space
       '---
       prodKeywCnt = UBound(currProdTokens) - 1 '-- skip the last one - the prod code - picks too much
           
        For ix2 = 0 To prodKeywCnt
            
            If Len(currProdTokens(ix2)) > 2 Then '-- only add larger words
                
               addedKeywCnt = addedKeywCnt + 1
               currProdToken = currProdTokens(ix2)
               
               If (keywInList + addedKeywCnt) < 12 Then '-- consider existing keywords in list
                    addKeyword (currProdToken)
                  Else
                    MsgBox "The total number of keywords exceed the limit of 12.", , title1
                    Call updateProdStatus
                    Exit Sub
                End If
            
            End If
            
        Next
    
    End If
    
Next

Call updateProdStatus


End Sub

Private Sub btnLoadCommodities_Click()


Dim ix As Integer
Dim cntComm As Integer
cntComm = lstCommonKeyw.ListCount

If cntComm = 0 Then
   MsgBox "No items in commodities list.", , title
   Exit Sub
End If

For ix = 0 To cntComm - 1
    
    If lstCommonKeyw.Selected(ix) Then
    
       addKeyword (lstCommonKeyw.List(ix))
       lstCommonKeyw.Selected(ix) = False
       btnSelectProductsByKeywords.Enabled = True
    End If

Next
  
    
End Sub

Public Sub enableKeywordList(stat As Boolean)

If stat Then

Me.lstCommonKeyw.Visible = True
Me.btnClearSelection.Visible = True
Me.tglKeywListSort.Visible = True
Me.btnLoadCommodities.Visible = True

    If Not firstKeywSelectListMsg Then
    
    MsgBox "You can multi-select common product terms in the list." + vbLf + vbLf + _
           "It is sorted by FREQUENCY of words in the 9,000 products list." + vbLf + vbLf + _
           "To switch sort by frquency vs alphabetically press the icon above." + vbLf + vbLf + _
           "Use the 'Add Selected Keywords' button to copy keywords to the keywords list." + vbLf + vbLf + _
           "Use the clear selection to unselect any previous choices.", , title
          
           firstKeywSelectListMsg = True
    End If

Else
  
Me.lstCommonKeyw.Visible = False
Me.btnClearSelection.Visible = False
Me.tglKeywListSort.Visible = False
Me.btnLoadCommodities.Visible = False

End If

End Sub

Private Sub btnReset_Click()

Call clearQuery

End Sub


Public Sub clearQuery()

Call clearDataStored

Call clearDataSelectedSet
Call updateProdStatus


End Sub

Private Sub btnSelectAllProducts_Click()
Call selectAllProducts
Call updateProdStatus
End Sub

Public Sub selectAllProducts()
For ix = 0 To lboxProduct.ListCount - 1
    lboxProduct.Selected(ix) = True
Next
Call updateProdStatus
End Sub

Private Sub loadKeywords()

Dim ix As Integer

For ix = 0 To Me.ListBoxKeywords.ListCount - 1
    ProductKeywords(ix + 1) = Me.ListBoxKeywords.List(ix)
Next
'--- NOTE - THEY CAN BE USED OUT OF ORDER?
Call updateProdStatus
End Sub

Public Function areProductsSelected() As Boolean

areProductsSelected = False

For ix = 0 To lboxProduct.ListCount - 1

    If lboxProduct.Selected(ix) Then
       areProductsSelected = True
       Exit Function
    End If
Next

End Function

Private Sub btnSelectProductsByKeywords_Click()

'--- LOGIC NOTES:
'--- We have a complex relation with these three items:
'--- SELECTED PRODUCTS - these may be selected by the user first (click on product), or below by a keyw or prod type match
'--- KEYWORD MATCH - according to or/and logic we select a record if some/all keywords match it's contents (keyw is contained in it)
'--- PRODUCT TYPE - here we selected or deselect a product based on the prod codes group for the prod type (futures, options etc)
'--- this last has a complex logic - if there is no match we select all products of the same prod type
'--- if there are some selected by the user or matches or both we unselect them if they are not the same prod type wanted

Call updateProdStatus

'--- this will leave any prod selected already
Dim retVal As Integer
Dim ix As Integer
Dim match As Integer

Dim logical As String
Dim PKM(1 To 12) As Boolean
'--- set to false all matches
logical = Me.lboxLogic.Value

Dim currProduct As String
Dim titleExchange As String
titleExchange = "Current Exchange:  " + ExchangeSelect

Dim ix1 As Integer
Dim ix2 As Integer
Dim kx As Integer


'--- keywords
Dim foundProduct As Boolean
foundProduct = False
Dim foundCount As Integer
foundCount = 0

Dim prodCount As Integer


Dim OrProdMatchBool As Boolean
Dim AndProdMatchBool As Boolean
OrProdMatchBool = False
AndProdMatchBool = False
Dim prodTypesArray() As String
Dim prodTypeTmp As String
Dim prodTypes() As String

If lboxProduct.ListCount = 0 Then
   MsgBox "No products available to search from.", , titleExchange
   Me.txtBoxProdKeywordToAdd.SetFocus
   Exit Sub
End If

'-- special case - prod types need to load the keywords for them
'---thus we do no need a special case - it will be treated as user inputed these values such as (FUT) etc

Dim prodSelected As Integer
prodSelected = getNumberSelectedProducts()
   
'--- NEED TO CALL THIS AFTER WE GOT ALL THE KEYWORDS ON THE LISTBOX
Call loadKeywords '-- now they are in ProductKeywords()

keywcnt = Me.ListBoxKeywords.ListCount

If (keywcnt = 0 And cboxProdType.Text = "" And prodSelected > 0) Then
   MsgBox "Products already selected:  " + CStr(prodSelected) + vbLf + vbLf + _
          "No keywords have been specified - no more matches are possible.", vbInformation, titleExchange
   Me.txtBoxProdKeywordToAdd.SetFocus
   Exit Sub
End If



If (keywcnt = 0 And Me.txtBoxProdKeywordToAdd = "" And cboxProdType.Text = "" And prodSelected = 0) Then
   MsgBox "There are NO Keywords in the keywords list and no products selected." + vbLf + vbLf + _
          "You can either select products manually by clicking on them and/or" + vbLf + vbLf + _
          "Enter a keyword then add it to the keyword list, then press Select Products." + vbLf + vbLf + _
          "NOTE: If you have selected products manually any new matches will be added to them.", , titleExchange
   Me.txtBoxProdKeywordToAdd.SetFocus
   Exit Sub
End If


If (keywcnt <> 0 And Me.txtBoxProdKeywordToAdd.Text <> "") Then
   MsgBox "NOTE: This keyword has not been added yet:  " + UCase(Me.txtBoxProdKeywordToAdd.Text), vbQuestion, titleExchange
  
End If


If (keywcnt = 0 And txtBoxProdKeywordToAdd <> "") Then
   MsgBox "There are NO Keywords in the keywords list," + vbLf + vbLf + _
   "you need to add the Keyword: " + UCase(txtBoxProdKeywordToAdd.Text) + " to the listbox first.", , titleExchange
   Exit Sub
End If


If keywcnt > 1 And (Not Me.lboxLogic.Selected(0)) And (Not Me.lboxLogic.Selected(1)) Then
   MsgBox "You Must select And/Or LOGICAL connector 1st when there are TWO or MORE Keywords", , titleExchange
   Exit Sub
End If


If cboxProdType.Text <> "" Then

     MsgBox "Selecting by Product Type class:  " + cboxProdType.Text + vbLf + vbLf + _
          "The product types appear after the product name in parenthesis." + vbLf + vbLf + _
          "We will search for the group of products that match the product type" + vbLf + _
          "AFTER we find matches to the keywords listed. If there are no keywords" + vbLf + _
          "then we find all the products that are of the type selected." + vbLf + vbLf + _
          "The Product types codes are:  " + Module1.prodTypeEquivalents, vbInformation, "Search for: " + cboxProdType.Text
    

    
End If

prodCount = lboxProduct.ListCount

'------------ OR LOGICAL - THE KEYW CAN BE IN ONE OF THE PRODUCTS

  
If (logical = "OR") Then

For ix1 = 0 To prodCount - 1

  
        '-- initialize logical match results for each product
        
     For ix = 1 To 12
         PKM(ix) = False
     Next

     
    currProduct = UCase(lboxProduct.List(ix1))
    
    For ix2 = 1 To keywcnt '= 12 max keywords
    
       ProductKeywords(ix2) = Trim(ProductKeywords(ix2))
    
       If (ProductKeywords(ix2) > "") Then
       
          match = InStr(1, currProduct, ProductKeywords(ix2)) '--- KEY - SIMPLE STRING MATCHING FOR NOW
          
          If (match > 0) Then '--- if instr find the keyw in the currrprod then it's >0 and its true
       
             PKM(ix2) = True
           Else
             PKM(ix2) = False
             
          End If
         
        End If
 
       For kx = 1 To 12
      '--- the OR boolean needs all non used key set to false - to be ignored
          If (ProductKeywords(kx) = "") Then
             PKM(kx) = False
          End If
        Next
    
       OrProdMatchBool = PKM(1) Or PKM(2) Or PKM(3) Or PKM(4) Or PKM(5) Or PKM(6) Or PKM(7) Or PKM(8) Or PKM(9) Or PKM(10) Or PKM(11) Or PKM(12)
        '--- we need for the OR the set to false if no data selected
       
       If OrProdMatchBool Then
          lboxProduct.Selected(ix1) = True
          foundProduct = True
          foundCount = foundCount + 1
       End If
               
   Next '--- KEYWORDS


Next '--- prod on list

End If

'-------------- AND LOGICAL - SEPARATE

  
If (logical = "AND") Then

'-------------- THE KEYWORDS MUST ALL BE IN A SINGLE PRODUCT

For ix1 = 0 To prodCount - 1

         
    For ix = 1 To 12
        PKM(ix) = True
    Next
         
   currProduct = UCase(lboxProduct.List(ix1))
    
    For ix2 = 1 To keywcnt '= 12 max keywords
    
       ProductKeywords(ix2) = Trim(ProductKeywords(ix2))
    
       If (ProductKeywords(ix2) > "") Then
       
          match = InStr(1, currProduct, ProductKeywords(ix2))
          
          If (match > 0) Then 'if instr find the keyw in the currrprod then it's >0 and its true
       
             PKM(ix2) = True
            Else
             PKM(ix2) = False
          End If
         
        End If
        
      '--- this loop is for a single product - all keyw must match this product (and)
     Next
   

     For kx = 1 To 12
     '--- the AND boolean needs all non used key set to true - to be ignored
         If (ProductKeywords(kx) = "") Then
            PKM(kx) = True
         End If
     Next
         
     AndProdMatchBool = PKM(1) And PKM(2) And PKM(3) And PKM(4) And PKM(5) And PKM(6) And PKM(7) And PKM(8) And PKM(9) And PKM(10) And PKM(11) And PKM(12)
     '--- we need for the AND the set to true if no data selected
    
     If AndProdMatchBool Then
        lboxProduct.Selected(ix1) = True
        foundProduct = True
        foundCount = foundCount + 1
       
     End If
      

Next '--- prod on list

End If '--- AND

'--- RECALCULATE HOW MANY ARE NOW SELECTED (MANUAL OR VIA KEYW)
prodSelected = getNumberSelectedProducts()

'--------------------- prod type is a separate logic - which depends on the results above

'--- PRODUCT TYPE - and then must also be prod type selected
Dim matchProdType As Boolean



If (cboxProdType.Text <> "") Then '-- prod type cbox

     prodTypes = Split(Module1.prodTypeEquivalents, " ") '-- loaded on cbox prod type change
          
     If (prodSelected > 0) Then '-- there is a prod type (futures etc) - and some have been selected
             
       For ix1 = 0 To prodCount - 1
    
          If lboxProduct.Selected(ix1) Then
    
             currProduct = UCase(lboxProduct.List(ix1))
            
             lboxProduct.Selected(ix1) = False '--- here means it's selected - keep if matches prod type - assume the worst
             foundCount = foundCount - 1
            
             For kx = 0 To UBound(prodTypes) '-- each prod type code
                 
                 matchProdType = InStrRev(currProduct, "(" + prodTypes(kx) + ")") > 0
                 
                   If matchProdType Then
                       lboxProduct.Selected(ix1) = True
                       foundCount = foundCount + 1
                    Exit For
                   End If
                 
             Next
           
           End If '-- selected
           
        Next
             
      End If
      
    
     '--- now if no product was selected we select by prod type all matches
    
     If (prodSelected = 0) Then '-- there is a prod type (futures etc) - none selected
             
       foundCount = 0
    
       For ix1 = 0 To prodCount - 1
       
             currProduct = UCase(lboxProduct.List(ix1))
            
             For kx = 0 To UBound(prodTypes) '-- each prod type code
                 
                 matchProdType = InStrRev(currProduct, "(" + prodTypes(kx) + ")") > 0
                 
                 If matchProdType Then
                    lboxProduct.Selected(ix1) = True '--- only deselect if already selected
                    foundCount = foundCount + 1
                    Exit For
                 End If
                 
             Next
        Next
             
             
     End If

'--- there is a prod type selected
End If


Call updateProdStatus


'--- now count have many are selected:
Dim selectedProductsCount As Integer

selectedProductsCount = getNumberSelectedProducts()

Const noMatchOptions = _
"Some options to find matching products are: " + vbLf + vbLf + _
"1) Start with ONE keyword and increase one keyword at a time." + vbLf + _
"2) For OR  conditions INCREASE the number of keywords." + vbLf + _
"3) For AND conditions REDUCE   the number of keywords." + vbLf + _
"4) Truncate a keyword - it may result in more matches." + vbLf + _
"5) EXTRACT the keywords from a product name and remove keywords as needed." + vbLf + _
"6) You can select products MANUALLY by clicking on them." + vbLf + vbLf + _
"NOTE: You do not need to find ALL wanted products in ONE search." + vbLf + _
"You can do multiple separate searches and each can be APPENDED to the" + vbLf + _
"results in the eModule. There will be a blank line between to mark each group."


Dim prodTypeMsg As String
If cboxProdType.Text <> "" Then
   prodTypeMsg = cboxProdType.Text
  Else
   prodTypeMsg = "(none)"
End If

If txtBoxProdKeywordToAdd.Value <> "" Then
   MsgBox "Keywords Section: The following word has not been added:  " + txtBoxProdKeywordToAdd.Value + vbLf + vbLf + _
          "If a word is not ADDED it does NOT count as a KEYWORD.", vbQuestion, title1
End If

If cboxProdType.Text = "" Then

'--- MESSAGES WHEN NO PROD TYPE
    
    If (keywcnt >= 1) And (Not foundProduct) And (selectedProductsCount = 0) Then
    
        MsgBox "NO product MATCH for the current KEYWORD(s) list" + vbLf + _
        "and NO product has been SELECTED (manually or in previous searches)." + vbLf + vbLf + _
        "Count of keywords: " + CStr(keywcnt) + vbLf + vbLf + _
        "Number of currently selected products: " + CStr(selectedProductsCount) + vbLf + vbLf + _
        "Specified Product Type: " + prodTypeMsg + vbLf + vbLf + _
        "The logical connector is: " + logical, vbQuestion, titleExchange
       
        If Not firstMsg Then
           MsgBox noMatchOptions, , "The logical connector is:  " + logical
           firstMsg = True
        End If
              
    End If
    
    If keywcnt >= 1 And (Not foundProduct) And (selectedProductsCount > 0) Then
    
       MsgBox "NO product MATCH for the current KEYWORD(s) list." + vbLf + vbLf + _
       "Count of keywords: " + CStr(keywcnt) + vbLf + vbLf + _
       "Number of currently selected products: " + CStr(selectedProductsCount) + vbLf + vbLf + _
       "Specified Product Type: " + prodTypeMsg + vbLf + vbLf + _
       "The logical connector is: " + logical, vbExclamation, titleExchange
      
    End If
    
    
    If keywcnt >= 1 And (foundProduct) And (selectedProductsCount > 0) Then
    
       MsgBox "There are " + CStr(foundCount) + " MATCHES for the current KEYWORD(s) list." + vbLf + vbLf + _
       "Count of keywords: " + CStr(keywcnt) + vbLf + vbLf + _
       "Number of currently selected products: " + CStr(selectedProductsCount) + vbLf + vbLf + _
       "Specified Product Type: " + prodTypeMsg + vbLf + vbLf + _
       "The logical connector is: " + logical, vbExclamation, titleExchange
     
    End If

End If


If cboxProdType.Text <> "" Then

'--- MESSAGES WHEN NO PROD TYPE
    
    If (keywcnt >= 1) And (Not foundProduct) And (selectedProductsCount = 0) Then
    
        MsgBox "NO product MATCH for the current KEYWORD(s) list AND Product TYPE." + vbLf + _
        "Count of keywords: " + CStr(keywcnt) + vbLf + vbLf + _
        "Number of currently selected products: " + CStr(selectedProductsCount) + vbLf + vbLf + _
        "Specified Product Type: " + prodTypeMsg + vbLf + vbLf + _
        "The logical connector is: " + logical, vbQuestion, titleExchange
    End If
    
    If keywcnt >= 1 And (selectedProductsCount > 0) Then
    
       MsgBox CStr(selectedProductsCount) + " MATCHES for the current KEYWORD(s) list AND Product TYPE." + vbLf + vbLf + _
       "Count of keywords: " + CStr(keywcnt) + vbLf + vbLf + _
       "Number of currently selected products: " + CStr(selectedProductsCount) + vbLf + vbLf + _
       "Specified Product Type: " + prodTypeMsg + vbLf + vbLf + _
       "The logical connector is: " + logical, vbExclamation, titleExchange
    
    End If
    
    '-- special case when there are no keywords
    
    If (keywcnt = 0) And (selectedProductsCount > 0) Then
    
       MsgBox "There are " + CStr(selectedProductsCount) + " MATCHES for the PRODUCT TYPE." + vbLf + vbLf + _
       "Keywords - NONE - we use product type matches only." + vbLf + vbLf + _
       "Number of selected products: " + CStr(selectedProductsCount) + vbLf + vbLf + _
       "Specified Product Type: " + prodTypeMsg, vbExclamation, titleExchange
       Exit Sub
    End If

End If





End Sub

Public Sub updateProdStatus()

Dim totList As Integer
Dim totSel As Integer
Dim notVisibleSel As Integer
Dim totProdList As Integer
Dim totKeywList As Integer

totList = Me.lboxProduct.ListCount
totSel = getNumberSelectedProducts()
notVisibleSel = getNumberSelectedProductsNotVisibleInList()
totKeywList = Me.ListBoxKeywords.ListCount

If (totKeywList > 0) Or (Me.cboxProdType.Text <> "") Then '-- CAN SEARCH IF ONLY HAVE PROD TYPE
   Me.btnSelectProductsByKeywords.Enabled = True
  Else
   Me.btnSelectProductsByKeywords.Enabled = False
End If

If Me.cboxProdType.Text = "" Then

   Me.lblProductSearchMessage = "Product Count: " + CStr(totList) + ", Selected: " + CStr(totSel) + " (Not visible: " + CStr(notVisibleSel) + _
                                "), Keywords: " + CStr(totKeywList) + ", Logical: " + Me.lboxLogic.Text
 Else
   Me.lblProductSearchMessage = "Product Count: " + CStr(totList) + ", Selected: " + CStr(totSel) + " (Not visible: " + CStr(notVisibleSel) + _
                                "), Prod Type: " + Me.cboxProdType.Text
 End If

End Sub

Public Function getNumberSelectedProducts() As Integer

getNumberSelectedProducts = 0
Dim ix As Integer
Dim selectedProductsCount As Integer
selectedProductsCount = 0

For ix = 0 To lboxProduct.ListCount - 1
    
    If lboxProduct.Selected(ix) Then
       selectedProductsCount = selectedProductsCount + 1
    End If

Next

getNumberSelectedProducts = selectedProductsCount

If getNumberSelectedProducts > 0 Then
   Me.btnAppendSelectedProdsEmodule.Enabled = True
  Else
   Me.btnAppendSelectedProdsEmodule.Enabled = False
End If

End Function

Public Function getNumberSelectedProductsNotVisibleInList() As Integer

getNumberSelectedProductsNotVisibleInList = 0
Dim ix As Integer
Dim selectedProductsCount As Integer
selectedProductsCount = 0

For ix = numberVisibleProductsInList To lboxProduct.ListCount - 1
    
    If lboxProduct.Selected(ix) Then
       selectedProductsCount = selectedProductsCount + 1
    End If

Next

getNumberSelectedProductsNotVisibleInList = selectedProductsCount

End Function


Private Sub btnViewResults_Click()

Module1.disableWorksheetSelectionChange = False

Dim wks As Worksheet
Set wks = Worksheets(saveResultsTab)
wks.Activate
frmProdQueryTool.hide
End Sub

Private Sub btnQuickKeywSearchAll_Click()

Application.StatusBar = "PQT - Global keyword processing..."

Me.btnAppendSelectedProdsEmodule.Enabled = False
Me.btnClearSelProdsKeyw.Enabled = False


Dim logical As String
If IsNull(Me.lboxLogic.Value) Then
   MsgBox "Please select a LOGICAL AND/OR first.", , title1
   Me.lboxLogic.SetFocus
   Exit Sub
End If

Dim retVal As Integer
retVal = _
MsgBox("PQT - GLOBAL KEYWORD SEARCH" + vbLf + vbLf + _
       "The active Logical connector is: " + Me.lboxLogic.Value + vbLf + vbLf + "Select OK to continue." + vbLf + vbLf + _
       "Select Cancel if you need to change the logical connector.", vbOKCancel, title1 + " GLOBAL KEYWORD SEARCH")

If retVal <> vbOK Then
   Me.lboxLogic.SetFocus
   Exit Sub
End If


'Call clearQuery

'Module1.ComboBoxChange = False '-- avoid this adding asia etc

Application.ScreenUpdating = False

'Module1.disableWorksheetSelectionChange = True

Module1.PQTnotMsgDisplayed = True


logical = Me.lboxLogic.Value


Call Module3.PQT_GKS_searchAllProductsExchGrpKeywords(logical)
'------------------------ main program global query


End Sub


Private Sub searchAllProductsExchGrpKeywords()

Application.ScreenUpdating = False

Const rowLimit = 10000
Dim rowSource(rowLimit) As String
'-----so that it's released on end

Dim ix As Integer
Dim fx As Integer

Dim logical As String
If IsNull(Me.lboxLogic.Value) Then
   MsgBox "Please select a LOGICAL AND/OR first.", , title1
   Me.lboxLogic.SetFocus
   Exit Sub
End If

logical = Me.lboxLogic.Value

Dim wks1 As Worksheet
Set wks1 = Worksheets("Product") '---source
Dim wks2 As Worksheet
Set wks2 = Worksheets(saveResultsTab) '---dest

wks1.Activate
wks1.Range("a2").Select

Dim search(3) As String
Dim searchDef(3) As String

'--- load defaults from the 1st three keywords
On Error Resume Next
If (Me.ListBoxKeywords.List(0) > "") Then
   searchDef(1) = Me.ListBoxKeywords.List(0)
End If
On Error Resume Next
If (Me.ListBoxKeywords.List(1) > "") Then
   searchDef(2) = Me.ListBoxKeywords.List(1)
End If
On Error Resume Next
If (Me.ListBoxKeywords.List(2) > "") Then
   searchDef(3) = Me.ListBoxKeywords.List(2)
End If
On Error GoTo 0

Dim searchRange As Range
Dim addrSource As String

Dim cntKeyw As Integer
cntKeyw = 0

For ix = 1 To 3
    search(ix) = InputBox("Enter a search word# " + CStr(ix) + ":", "PQT Logical is: " + logical, searchDef(ix))
    search(ix) = UCase(Trim(search(ix)))
    
    If (search(ix) = "") And (ix = 1) Then
       Exit Sub
    End If
    
    If search(ix) = "" Then
       Exit For
    End If
Next
cntKeyw = ix - 1
  
If cntKeyw = 1 Then
   logical = "OR"
End If
  
Dim cel As Range
Dim found As Boolean
Dim strCel As String

Dim foundCnt As Integer
Dim currRow As String
fx = 0
Dim celCnt As Long
Dim status As String

'--- remember - we are in the Products (hidden) tab

'--- or logic - since it's one match we can search each cell separately

addrSource = "A2:E" + CStr(ProductLastRow) '-- GLOBAL RANGE - ALL THE TAB CONTENTS
Set searchRange = Range(addrSource)
Dim keywordsFound As Integer

If logical = "OR" Then
 
   For Each cel In searchRange
        '--- find the matches
            celCnt = celCnt + 1
            
            For ix = 1 To cntKeyw
                
                strCel = UCase(Trim(CStr(cel.Value)))
                
                If InStr(strCel, search(ix)) > 0 Then
                
                   fx = fx + 1
                   If fx > rowLimit Then
                      MsgBox "The Limit of:  " + CStr(rowLimit) + " matching products has been reached.", vbCritical, title1
                      Exit Sub
                   End If
                   
                   lblProductSearchMessage.Caption = CStr(fx) + ": " + strCel
                   rowSource(fx) = CStr(cel.row)
                   DoEvents
                End If
                
            Next
        
    
    Application.StatusBar = "GKS Logical OR - Processing cell: " + cel.Address
   Next



End If

'--- and logic - since it's and we need to search each row separately (1-3 matches in each row)

If logical = "AND" Then

   Dim rw As Long
   Dim keywFound(1 To 3) As Boolean
   
   '--- we detect AND by after each pass in the current row we find each keyword - for AND the count is the same as the count of keyw

   For rw = 2 To ProductLastRow
   '-- NEED TO MOVE ROW BY ROW AND SEARCH IN EACH ROW FOR ALL THE KEYWORDS

       keywFound(1) = False
       keywFound(2) = False
       keywFound(3) = False

       addrSource = "A" + CStr(rw) + ":E" + CStr(rw) '-- ROW RANGE
    
       Set searchRange = Range(addrSource)
       
       
       For ix = 1 To cntKeyw
   
           For Each cel In searchRange
        '--- find the matches
                strCel = UCase(Trim(CStr(cel)))
                
                If InStr(strCel, search(ix)) > 0 Then
                
                   lblProductSearchMessage.Caption = CStr(ix) + ": " + strCel
                   DoEvents
                   keywFound(ix) = True
                   Exit For ' need to seach again the entire row with new keyw
                End If
           Next
        
        Next '--CELL IN ROW
    
  
        
        '--- for 1 keyw we use or
        
        If (cntKeyw = 2 And keywFound(1) And keywFound(2)) Or _
           (cntKeyw = 3 And keywFound(1) And keywFound(2) And keywFound(3)) Then  '-- found all keywords in the same row
        
           fx = fx + 1
           If fx > rowLimit Then
              MsgBox "The Limit of:  " + CStr(rowLimit) + " matching products has been reached.", vbCritical, title1
              Exit Sub
           End If
          
           rowSource(fx) = CStr(searchRange.row)
               
         End If '-- ROW
     
     
      Application.StatusBar = "GKS Logical AND - Processing row: " + CStr(cel.row)
    Next '--- row
  
End If

foundCnt = fx

Dim rngRowSource As Range
Dim rngRowToCopy As Range


Dim addr1 As String
Dim addr2 As String

Dim rowDestRow As Integer
rowDestRow = Module1.getModuleLastRow() + 2 '-- append skip 1 row

'If Not eModuleLineIsEmpty(rowDestRow) Then
     
'   If rowDestRow > 4 Then
 '     rowDestRow = rowDestRow + 1 '-- skio a line if not the 1st row
 '  End If
   
'End If

If rowDestRow < ModuleFirstRow Then
   rowDestRow = ModuleFirstRow
End If
     

wks2.Activate

For fx = 1 To foundCnt

'--- select the rows of the matches, avoid repeated rows
    If (currRow <> rowSource(fx)) Then
        currRow = rowSource(fx)
        
     
        addr1 = "A" + currRow + ":" + "F" + currRow
        addr2 = "B" + CStr(rowDestRow) + ":" + "G" + CStr(rowDestRow)
        
        Set rngRowSource = wks1.Range(addr1)
        Set rngRowToCopy = wks2.Range(addr2)
        
        rngRowSource.Copy
        rngRowToCopy.PasteSpecial xlPasteAll
           
        rowDestRow = rowDestRow + 1 '-- add later
        
     End If
     
Next

Application.StatusBar = "PQT finished."

If currRow = "" Then
   MsgBox "No matching records found.", , title1

End If


wks2.Activate

Call Module1.eModReset '-- so that all combo boxes are loaded

Set wks1 = Nothing
Set wks2 = Nothing

Set rngRowSource = Nothing
Set rngRowToCopy = Nothing

Set searchRange = Nothing


Application.ScreenUpdating = True

End Sub



Private Sub cboxProdType_Change()

Dim prodTypeVal As String

prodTypeVal = cboxProdType.Text
If prodTypeVal = "" Then
   cboxProdType.backColor = &HFFFFFF
   Module1.prodTypeEquivalents = ""
   Exit Sub
  Else
    cboxProdType.backColor = &HC0FFFF
End If

Me.btnSelectProductsByKeywords.Enabled = True

Dim ix As Integer
Dim prodTypesArray() As String
Dim kx As Integer
Dim prodTypeTmp As String

For ix = 1 To 6

    If Module1.prodTypeRelations(ix, 1) = prodTypeVal Then
       Module1.prodTypeEquivalents = prodTypeRelations(ix, 2)
    End If
    
Next


Call updateProdStatus

End Sub

Private Sub help1_Click()
MsgBox _
      "1) Select a REGION -> EXCHANGE -> PROD GROUP -> the product list is populated." + vbLf + vbLf + _
      "2) DEFINITIONS:" + vbLf + _
       "A 'MATCH' means a keyword is found in any substring in a product name." + vbLf + _
       "LOGICAL: Choose AND/OR - if more than ONE keyword is used." + vbLf + _
       "Use 'AND' when ALL keywords have to match in a given product." + vbLf + _
       "Use 'OR'  when ONE keyword matches in a given product." + vbLf + vbLf + _
       "3) MANUALLY SELECT/UNSELECT products in the list by a mouse CLICK on the product. " + _
       "You always have the FINAL word on which products are selected by manual selection. " + _
       "You can keep adding selected items or de-select selected items at any time before a search." + vbLf + vbLf + _
       "5) KEYWORDS: A keyword can be ONE OR MORE words together." + vbLf + vbLf + _
       "ADD keywords by typing them next to the ADD button and press ADD - the max is 12 keywords. " + _
       "Or EXTRACT them from a PRODUCT NAME, or using the commodities keyword LIST (by alpha/frequency)." + vbLf + vbLf + _
       "6) OPTIONAL: Select Execution type, Rate type, brok. amount can be specified now." + vbLf + vbLf + _
       "Press APPEND SELECTED button to append to the " + saveResultsTab + " one line after the last used row.", , "Help for Non-Global searches"
      
MsgBox "A powerful tool when you want the SAME GROUP of products you select " + _
       "in the eModule but for a different Exec Type, Rate and/or Brok. Amount." + vbLf + vbLf + _
       "First  select the REGION -> EXCHANGE -> PROD GROUP " + _
       "and then use any combination of keywords, manual selection or prod type to select products." + vbLf + vbLf + _
       "Then for that set of products specify in the PQT also the Execution Type, Rate Type and Amount. " + _
       "Now when we press the 'APPEND selected products' button you will have the choice " + _
       "of CLEAR/SAVE the SELECTED PRODUCTS. Do NOT clear them. Then when you return to the PQT AGAIN you can " + _
       "modify the selected Execution Type, Rate Type and Amount to create a new BLOCK in the eModule." + vbLf + vbLf + _
       "Since these blocks are separated by a BLANK ROW you can easily modify them. For example you can use " + _
       "the COPY DOWN in the NP to add needed data before Validation, separately for each block." + vbLf + vbLf + _
       "Do all block-level changes BEFORE VALIDATION since it will remove all empty rows." + vbLf + vbLf + _
       "To mark products for Default Y/N use COPY DOWN.", , "Help for Non-Global searches"
      
End Sub





Private Sub lblLogic_Click()

MsgBox "It's convenient to understand how the logical connectors work: " + vbLf + vbLf + _
       "1) When we have only ONE keyword - both AND/OR give the same results." + vbLf + vbLf + _
       "2) For logical 'OR'  we need ONLY ONE KEYWORD MATCH for a product to be selected." + vbLf + vbLf + _
       "3) For logical 'AND' we need ALL KEYWORDS TO MATCH for a product to be selected." + vbLf + vbLf + _
       "Therefore 'OR' logicals join results - 'AND' logicals reduce the results." + vbLf + _
       "If you get unexpected results try changing the logical, or adding/removing keywords." + vbLf + vbLf + _
       "4) The keywords match when they are contained in the product name." + vbLf + _
       "5) All keywords and product data is converted to uppercase before matching." + vbLf + _
       "6) You can selected or deselect products from the list." + vbLf + _
       "7) You can also combine searches by NOT clearing the previous one.", , "The logical connector is: " + Me.lblLogic
       

End Sub



Private Sub lblTitle_Click()
frmProdQueryTool.hide
End Sub

Private Sub lboxExchange_Click()
If RegionSelect = "" Then
   MsgBox "Please select first the REGION", , title
   Exit Sub
End If

End Sub

Private Sub lboxLogic_Click()
If Me.lboxLogic.Text = "OR" Then
   Me.lblQuerInfo = "OR: Matches if ANY keyword appears in ANY product record."
  Else
   Me.lblQuerInfo = "AND: Matches if ALL keywords appear in a SINGLE product record."
End If

Module1.PQTlogical = Me.lboxLogic.Text

Call updateProdStatus
End Sub

Private Sub lboxProdGroup_Click()
If RegionSelect = "" Then
   MsgBox "Please select first the REGION and EXCHANGE", , title
   Exit Sub
End If
If ExchangeSelect = "" Then
   MsgBox "Please select first the EXCHANGE", , title
   Exit Sub
End If

End Sub



Private Sub lboxProduct_Change()
Call updateProdStatus
Me.btnSelectProductsByKeywords.Enabled = True
End Sub

Private Sub lboxRegion_Change()

Dim cnt As Integer

lboxExchange.Clear
lboxProdGroup.Clear
lboxProduct.Clear

RegionSelect = ""
For ix = 0 To lboxRegion.ListCount - 1

    If lboxRegion.Selected(ix) Then
       RegionSelect = lboxRegion.List(ix)
       cnt = cnt + 1
       Exit For
    End If
    
Next



Call loadListExchange


End Sub
 

Private Sub loadListExchange()

lboxExchange.Clear

Dim rngRegionExchange As Range

Dim addr As String
addr = "$" & RefDataRegionColumn & "$" & HeaderRowOffset & ":$" & RefDataRegionColumn & "$" & ExchangeLastRow

Set rngRegionExchange = Exchange.Range(addr)

For Each cel In rngRegionExchange
    
    cel = Trim(cel)
    If cel = RegionSelect Then
       Me.lboxExchange.AddItem (cel.Offset(, 1).Value)
    End If
    
Next


End Sub




Private Sub lboxExchange_Change()

Dim cnt As Integer


Me.lboxProdGroup.Clear
Me.lboxProduct.Clear


ExchangeSelect = ""
For ix = 0 To lboxExchange.ListCount - 1

    If lboxExchange.Selected(ix) Then
       ExchangeSelect = lboxExchange.List(ix)
       cnt = cnt + 1
       Exit For
    End If
    
Next


loadListProdGrp

End Sub


Private Sub loadListProdGrp()

lboxProdGroup.Clear



Dim rngProdGrp As Range
Dim tmp As String

Dim addr As String
addr = "$" & RefDataRegionColumn & "$" & HeaderRowOffset & ":$" & RefDataRegionColumn & "$" & ProductGroupCodeLastRow

Set rngProdGrp = ProductGroupCode.Range(addr)

For Each cel In rngProdGrp
    
    tmp = Trim(cel.Offset(, 1).Value)
    
    If (cel = RegionSelect) And (tmp = ExchangeSelect) Then
       Me.lboxProdGroup.AddItem (Trim(cel.Offset(, 2).Value))
    End If
    
Next


End Sub

Private Sub lboxProdGroup_Change()

Dim cnt As Integer

If RegionSelect = "" Then
  ' MsgBox "Please select first the REGION", , title
   Exit Sub
End If
If ExchangeSelect = "" Then
   MsgBox "Please select first the EXCHANGE", , title
   Exit Sub
End If
ProductGroupSelect = ""

If lboxProdGroup.ListCount = 0 Then
   'MsgBox "No products in list.", , title1
   Exit Sub
End If


For ix = 0 To lboxProdGroup.ListCount - 1

    If lboxProdGroup.Selected(ix) Then
       
       ProductGroupSelect = lboxProdGroup.List(ix)
       cnt = cnt + 1
       
    End If
    
Next

Call loadProducts


End Sub






Private Sub loadProducts()


lboxProduct.Clear

Dim rngProduct As Range
Dim tmp0 As String
Dim tmp1 As String
Dim tmp2 As String
Dim tmpp As String

Dim prodCount As Integer

Dim addr As String
addr = "$" & RefDataRegionColumn & "$" & HeaderRowOffset & ":$" & RefDataRegionColumn & "$" & ProductLastRow

Set rngProduct = Product.Range(addr)

For Each cel In rngProduct
    
    tmp0 = Trim(cel.Offset.Value) '--region
    tmp1 = Trim(cel.Offset(, 1).Value)
    tmp2 = Trim(cel.Offset(, 2).Value)
    
    If (tmp0 = RegionSelect) And (tmp1 = ExchangeSelect) And (tmp2 = ProductGroupSelect) Then
    
        tmpp = Trim(cel.Offset(, 3).Value) + " (" + Trim(cel.Offset(, 4).Value) + ")"
        Me.lboxProduct.AddItem (tmpp)
        prodCount = prodCount + 1
    End If
    
Next

Me.lblProductSearchMessage = "Loaded " + CStr(prodCount) + " products into the list."

End Sub









Private Sub txtBoxProdSearch1_Change()
'txtBoxProdSearch1.Value = UCase(txtBoxProdSearch1.Value)
End Sub

Private Sub txtBoxProdSearch2_Change()
'txtBoxProdSearch2.Value = UCase(txtBoxProdSearch2.Value)
End Sub

Private Sub txtBoxProdSearch3_Change()
'txtBoxProdSearch3.Value = UCase(txtBoxProdSearch3.Value)
End Sub








Private Sub lstCommonKeyw_Click()
Call loadCommonKeywordsListByAlpha
End Sub


Private Sub tglKeywListSort_Click()
Dim sortSel As Boolean
sortSel = Me.tglKeywListSort.Value

If sortSel Then
   Call Me.loadCommonKeywordsListByAlpha
   Me.tglKeywListSort.Caption = "Sort KW Freq"
  Else
   Call Me.loadCommonKeywordsListByFreq
   Me.tglKeywListSort.Caption = "Sort KW Alpha"
End If

End Sub





Private Sub UserForm_Activate()
lboxLogic.SetFocus
Me.lbleModuleMsg.Caption = "Last used eModule row# " + CStr(Module1.getModuleLastRow)

'With Application
'    Me.Top = .Top
  '  Me.Left = .Left
 '   Me.Height = .Height
   ' Me.Width = .Width
'End With


Module1.PQTlogical = Me.lboxLogic.Text

End Sub

Private Sub UserForm_Initialize()

 
 '-- form size issues
 'Application.WindowState = xlMaximized
 'Me.Width = Application.Width
 'Me.Height = Application.Height




'Call Module1.unHideAllSheets
Me.btnAppendSelectedProdsEmodule.Enabled = False
Me.btnSelectProductsByKeywords.Enabled = False
'--- THESE ACTIVATE AFTER THERE IS DATA FOR THEM

Module1.PQTinUseDisableCboxes = True
Module1.PQTselProdFirstTime = True
firstKeywSelectListMsg = False
'--- add all known list box code here
Me.lboxLogic.AddItem ("OR")
Me.lboxLogic.AddItem ("AND")
Me.lboxLogic.Value = lboxLogic.List(0)

Me.lbleModuleMsg.Caption = "Last Emodule row# " + CStr(Module1.getModuleLastRow)

Call loadCommonKeywordsListByFreq

RegionLastRow = Region.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
ExchangeLastRow = Exchange.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
ProductGroupCodeLastRow = ProductGroupCode.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row
ProductLastRow = Product.Range(RefDataRegionColumn & LastSheetRow).End(xlUp).row

Dim cel As Range

Dim rngRegion As Range
Dim rngExch As Range
Dim rngProdGrp As Range
Dim rngProd As Range

Dim addr(3) As String
addr(1) = "$" & RefDataRegionColumn & "$" & HeaderRowOffset & ":$" & RefDataRegionColumn & "$" & RegionLastRow
'addr(2) = "$" & RefDataExchangeColumn & "$" & HeaderRowOffset & ":$" & RefDataExchangeColumn & "$" & ExchangeLastRow
'addr(3) = "$" & RefDataProductGroupCodeColumn & "$" & HeaderRowOffset & ":$" & RefDataProductGroupCodeColumn & "$" & ProductGroupCodeLastRow

Set rngRegion = Region.Range(addr(1))

For Each cel In rngRegion
    
    cel = Trim(cel)
    If cel <> "" Then
       Me.lboxRegion.AddItem (cel.Value)
    End If
    
Next

Call loadExecTypeCbox
'Call loadCurrencyCbox
Call loadRateTypeCbox
Call loadProdTypeCbox
'Set rngExch = Exchange.Range(addr(2))

'For Each cel In rngExch
    
 '   cel = Trim(cel)
   ' If cel <> "" Then
  '     Me.lboxExchange.AddItem (cel.Value)
  '  End If
    
'Next

'Set rngProdGrp = ProductGroupCode.Range(addr(3))
  
'For Each cel In rngProdGrp
    
 '   cel = Trim(cel)
 '   If cel <> "" Then
 '      Me.lboxProdGroup.AddItem (cel.Value)
  '  End If
    
'Next


End Sub

Private Sub loadExecTypeCbox()
  
  Dim ValidationRange As Range
  Const dataColumn = Module1.StaticDataExecutionTypeColumn

  Set ValidationRange = StaticData.Range("$" & dataColumn & "$" & Module1.StaticDataRowOffset _
                      & ":$" & dataColumn & "$" & _
                      StaticData.Range(dataColumn & Module1.LastSheetRow).End(xlUp).row)

 Dim cnt As Long
 cnt = ValidationRange.Count

 Dim ix As Integer
 Me.cboxExecutionType.Clear
 
 For ix = 1 To cnt
     Me.cboxExecutionType.AddItem ValidationRange.Cells(ix)
 Next

End Sub

'Private Sub loadCurrencyCbox()
  
 ' Dim ValidationRange As Range
 ' Const dataColumn = Module1.StaticDataCurrencyColumn

  'Set ValidationRange = StaticData.Range("$" & dataColumn & "$" & Module1.StaticDataRowOffset _
                      & ":$" & dataColumn & "$" & _
                      StaticData.Range(dataColumn & Module1.LastSheetRow).End(xlUp).row)

 'Dim cnt As Long
 'cnt = ValidationRange.Count

 'Dim ix As Integer
 'Me.cboxCurrency.Clear
 
' Me.cboxCurrency.AddItem ("DEFAULT")
  
 'For ix = 1 To cnt
  '   Me.cboxCurrency.AddItem ValidationRange.Cells(ix)
 'Next

'End Sub

Private Sub loadRateTypeCbox()
  
  Dim ValidationRange As Range
  Const dataColumn = Module1.StaticDataRateTypeColumn

  Set ValidationRange = StaticData.Range("$" & dataColumn & "$" & Module1.StaticDataRowOffset _
                      & ":$" & dataColumn & "$" & _
                      StaticData.Range(dataColumn & Module1.LastSheetRow).End(xlUp).row)

 Dim cnt As Long
 cnt = ValidationRange.Count
 Me.cboxRateType.Clear

 Dim ix As Integer
 
 For ix = 1 To cnt
     Me.cboxRateType.AddItem ValidationRange.Cells(ix)
 Next

End Sub


Private Sub loadProdTypeCbox()

'PROD TYPE   CLASS
'FUTURE FUTURE
'MIXED MIXED
'Option  OPTION
'SWAP SWAP
'Swaps SWAP
'Forwrd FORWARD
'SPOT SPOT
'OOC OPTION
'FUT FUTURE
'OOF OPTION
'OPT OPTION

cboxProdType.Clear
cboxProdType.AddItem ("") '-- allow to cancel selection
cboxProdType.AddItem ("FUTURE")
cboxProdType.AddItem ("OPTION")
cboxProdType.AddItem ("MIXED")
cboxProdType.AddItem ("SWAP")
cboxProdType.AddItem ("FORWARD")
cboxProdType.AddItem ("SPOT")



prodTypeRelations(1, 1) = "FUTURE"
prodTypeRelations(1, 2) = "FUTURE FUTURES FUT"

prodTypeRelations(2, 1) = "OPTION"
prodTypeRelations(2, 2) = "OPTION OPTIONS OOC OOF OPT"


prodTypeRelations(3, 1) = "MIXED"
prodTypeRelations(3, 2) = "MIXED"


prodTypeRelations(4, 1) = "SWAP"
prodTypeRelations(4, 2) = "SWAP SWAPS"


prodTypeRelations(5, 1) = "FORWARD"
prodTypeRelations(5, 2) = "FORWRD FORWARD FORWARDS"

prodTypeRelations(6, 1) = "SPOT"
prodTypeRelations(6, 2) = "SPOT SPOTS"




End Sub

Private Sub lblProdTypeInfo_Click()
MsgBox "PRODUCT TYPE:" + vbLf + _
       "We have several codes for the same product types as follows: " + vbLf + _
       "These groups group Product Types in the following way: " + vbLf + vbLf + _
       "FUTURE - FUTURE(s) and FUT" + vbLf + vbLf + _
       "OPTION - OPTION(s) and OOC, OOF, OPT" + vbLf + vbLf + _
       "Product types are in parenthesis after the product name" + vbLf + vbLf + _
       "The rest of product types classes are the same as the code.", , title1
       
End Sub

Private Sub UserForm_Terminate()
Module1.PQTinUseDisableCboxes = False
On Error Resume Next
ModuleSheet.Activate
On Error GoTo 0
End Sub

' InQuest injected base64 decoded content
' *'O*^
' *'O*^
' ^O*^
' Z+"w^
' Z+"w^
' *':u
' z{Qj
' 1Z'm
' L\zP
' jYrI
' y'+y
' t*&n
' t*&n
' x*&n
' x*&n
' ^O*^
' x*&n
' x*&n
' x*&n
' x*&n
' *'O*^

INQUEST-PP=macro
