Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_BeforeClose(Cancel As Boolean)
    Dim lRetVal As Long
    Dim bRetVal As Boolean
    Dim bOffice2016Workaround As Boolean

    If IsDatevDmsDokument(ThisWorkbook.Path) Then
        Exit Sub
    End If
    
    If Not ThisWorkbook.Saved Then
        bOffice2016Workaround = (Val(Application.Version) = 16 And Application.Workbooks.count = 1)
        lRetVal = MsgBox(TOOL_ID + "103" + vbCrLf + vbCrLf + _
            "Die Datei '" & ThisWorkbook.Name & "' wurde noch nicht gespeichert." + vbCrLf + vbCrLf + _
            "Soll die Datei jetzt gespeichert werden?", _
            vbInformation + IIf(bOffice2016Workaround, vbYesNo, vbYesNoCancel), TOOLHEADER)
        Select Case lRetVal
            Case vbYes
                bRetVal = Not DoSaveThisFile(False)
                Cancel = IIf(bOffice2016Workaround, False, bRetVal)
            Case vbNo
                ThisWorkbook.Saved = True
            Case vbCancel
                ' Kann nur als R|fffd|ckgabewert kommen, wenn Cancel in der MsgBox angegeben wurde
                Cancel = True
        End Select
    End If
End Sub

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
    ' |fffd|ber Cancel wird gesteuert, ob die Aktion hier beendet ist oder nicht:
    '   Cancel = true: In dieser Funktion ist bereits alles erledigt worden
    '   Cancel = false: Mit den Standardaktionen weitermachen...
    If SaveAsUI Then
        Cancel = DoSaveThisFile(True)
    End If
End Sub
Attribute VB_Name = "Tabelle10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle15"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle16"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle17"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = True Then
        bRetVal = EingabeKontrolle(Target)
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    SetFocusBorder Target
End Sub
Attribute VB_Name = "Tabelle18"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle19"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle20"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle21"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle22"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "modAuto"
Option Explicit

Sub Auto_Open()

  Application.EnableEvents = True
  Application.DisplayStatusBar = True
  Application.Calculation = xlCalculationAutomatic
  Application.ScreenUpdating = True
  
  Call SetDocumentAttributes
  
  If IsEmpty(Range("FirstRun").Value) Then
    Call ResetLastSaveTime
    Call SetSaveFormat
    Range("FirstRun").Value = Format(Now, "DD/MM/YYYY")
  End If
  
  ThisWorkbook.Saved = True
  
End Sub
Attribute VB_Name = "modEingabe"
Option Explicit

Private mNotValid As Boolean

Public Function EingabeKontrolleNotValid() As Boolean
    EingabeKontrolleNotValid = mNotValid
    mNotValid = False
End Function

Public Sub EingabeKontrolleEinAus()
  If ThisWorkbook.Worksheets("Stammdaten").Range("Eingabekontrolle").Value = False Then
    MsgBox TOOL_ID & "403" & vbCrLf & vbCrLf & _
      "Die Eingabekontrolle wurde soeben deaktiviert!" & vbCrLf & vbCrLf & _
      "Bei ausgeschalteter Eingabekontrolle werden Benutzereingaben ohne " & vbCrLf & _
      "weitere Pr|fffd|fung |fffd|bernommen. Fehleingaben werden nicht korrigiert!", _
      vbInformation, "Eingabekontrolle"
  End If
End Sub

Public Function EingabeKontrolle(rngTarget As Range) As Boolean
    Dim szRange As String
    Dim szNameNum As String
    Dim szName As String
    Dim szNameAll As String
    Dim szLangname As String
    Dim objRange As Object
    Dim objDate As Date
    Dim szMsg As String
    Dim i As Integer
    Dim vk As Double                  'Vorkommaanteil bei gesplitteter Zahl
    Dim nk As Integer                   'Nachkommaanteil
    Dim bScreenUpdate As Boolean
    Dim bProtected As Boolean
    Dim intZ|fffd|hler As Integer
    
    On Error GoTo ErrEingabeKontrolle                   ' Fehlerroutine aufsetzen
    szRange = rngTarget.Cells(1).Address                ' Adresse der Zelle ermitteln
    szName = GetName(szRange)                           ' Namen der Zelle ermitteln
    szNameAll = szName
    szLangname = szName
    If Left(szName, 4) <> "ein_" Then                   ' Kein Eingabe-relevanter Name vergeben
        Exit Function
    End If
    Set objRange = Range(szRange).Cells(1)   ' Inhalt der Zelle ermitteln
    ' Initialen Text der Fehlermeldung bei falscher Eingabe festlegen
    szMsg = TOOL_ID & "107" & vbCrLf & vbCrLf & "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" & vbCrLf & vbCrLf & Chr(187) & " "

    Dim lngPos As Long
    Dim strArray(10) As String

    lngPos = InStr(szName, "_")
    Do While lngPos <> 0    ' Feldname an den Unterstrichen aufsplitten
        strArray(i) = Left$(szName, lngPos - 1)
        szName = Mid$(szName, lngPos + 1)
        i = i + 1
        lngPos = InStr(szName, "_")
    Loop
    strArray(i) = szName
    If strArray(0) <> "ein" Then    ' kein Eingabefeld
        Exit Function
    Else
        bScreenUpdate = Application.ScreenUpdating
        Application.ScreenUpdating = False
        bProtected = Blattschutz_Aufheben(ActiveSheet) ' Blattschutz aufheben, um Zellformate |fffd|ndern zu k|fffd|nnen
    End If
   
    ' Objektreferenz auf das Eingabefeld holen
    Set objRange = Range(szRange)
    ' Initialen Text der Fehlermeldung bei falscher Eingabe festlegen
    szMsg = TOOL_ID & "107" & vbCrLf & vbCrLf & _
        "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" & vbCrLf & vbCrLf & _
        Chr(187) & " "

    ' Select |fffd|ber alle Basistypen
    Select Case strArray(1) ' Feldtyp
        
        ' --- Textfeld mit Maximall|fffd|nge ---
        Case "t"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If Len(objRange.Value) > Val(strArray(2)) Then
                    szMsg = szMsg & "Geben Sie maximal " & CStr(strArray(2)) & " Zeichen ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If
             
        ' --- Zahlenfeld mit Minimum- und/oder Maximum-Wert ---
        Case "zg"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If Not IsNumeric(objRange.Value) Or objRange.Value < strArray(2) Or objRange.Value > strArray(3) Then
                    szMsg = szMsg & "Geben Sie eine Zahl zwischen " & strArray(2) & " und " & strArray(3) & " ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If

        ' --- Datumsfeld ---
        Case "d"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If Not IsDate(objRange.Value) Then
                    szMsg = szMsg & "Geben Sie ein g|fffd|ltiges Datum ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If

        ' --- Zahlenfeld mit Maximall|fffd|nge ---
        Case "z"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If Not IsNumeric(objRange.Value) Or (Val(strArray(2)) > 0 And InStr(objRange.Value, ",") <> 0 And Len(objRange.Value) > Val(strArray(2)) + 3) Or (Val(strArray(2)) > 0 And InStr(objRange.Value, ",") = 0 And Len(objRange.Value) > Val(strArray(2))) Then
                    szMsg = szMsg & "Geben Sie eine g|fffd|ltige, maximal " & CStr(strArray(2)) & "-stellige Zahl ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If
            
        ' --- Sonderfall: positives Ganzzahlenfeld mit Maximall|fffd|nge  ---
        Case "pgz"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If Not IsNumeric(objRange.Value) Or Val(objRange.Value) < 0 Or InStr(objRange.Value, ",") <> 0 Or (Val(strArray(2)) > 0 And Len(objRange.Value) > Val(strArray(2))) Then
                    szMsg = szMsg & "Geben Sie eine positive, maximal " & CStr(strArray(2)) & "-stellige ganze Zahl ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If
            
        ' --- Zahlenfeld mit Maximall|fffd|nge und zur|fffd|ck wird eine 0 eingetragen---
        Case "z0"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If Not IsNumeric(objRange.Value) Or (Val(strArray(2)) > 0 And Len(objRange.Value) > Val(strArray(2))) Then
                    szMsg = szMsg & "Geben Sie eine g|fffd|ltige, maximal " & CStr(strArray(2)) & "-stellige Zahl ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                ElseIf IsNumeric(objRange.Cells(1).Value) And objRange.Cells(1).Value = 0 Then
                    Application.EnableEvents = False
                    
                    'objRange.Cells(1) = Format$(objRange.Cells(1).Value, "#,##0;[Red]-#,##0")
                    objRange.Cells(1).Value = "0" & "     "
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                
                
                ElseIf IsNumeric(objRange.Cells(1).Value) Then
                    ' Application.EnableEvents = False
                    ' objRange.Cells(1) = Format$(objRange.Cells(1).Value, "#,##0     ;[Red]-#,##0     ")
                    ' Application.EnableEvents = True
                
                End If
            End If
             
             
        ' --- Zahlenfeld mit Maximall|fffd|nge, immer auf- bzw. abrunden ---
        Case "zh", "zr"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                If IsNumeric(objRange.Value) Then
                    Application.EnableEvents = False
                    If strArray(1) = "zh" Then
                        objRange.Value = Int(objRange.Value * (-1)) * (-1) 'aufrunden
                    Else
                        objRange.Value = Int(objRange.Value) 'abrunden
                    End If
                    Application.EnableEvents = True
                    If (Val(strArray(2)) > 0 And Len(Int(objRange.Value)) > Val(strArray(2))) Then
                        szMsg = szMsg & "Geben Sie eine g|fffd|ltige, maximal " & CStr(strArray(2)) & "-stellige Zahl ein."
                        MsgBox szMsg, vbInformation, TOOLHEADER
                        Application.EnableEvents = False
                        objRange.Cells(1).Value = ""
                        objRange.Select
                        mNotValid = True
                        Application.EnableEvents = True
                    End If
                Else
                    szMsg = szMsg & "Geben Sie eine g|fffd|ltige, maximal " & CStr(strArray(2)) & "-stellige Zahl ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If
             
        ' --- gesplittetes Zahlenfeld:
        '     Vorkomma: (max. 10 Stellen) mit Tausenderpunkt ohne Dezimalstellen in dieses Feld
        '     Nachkomma: 2 Stellen in "Dieses Feld" & "_nk"
        Case "zs"
            If strArray(3) <> "nk" Then
                If Len(objRange.Cells(1).Value) > 13 Then
                    szMsg = szMsg & "Geben Sie eine g|fffd|ltige Zahl mit maximal 10 Vorkomma- und 2 Nachkommastellen ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    Range(rngTarget.Cells(1).Name.Name & "_nk").Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                Else
                    If IsNumeric(objRange.Cells(1).Value) Then
                         vk = Fix(objRange.Cells(1).Value)
                         nk = CInt(Abs(objRange.Cells(1).Value - vk) * 100)
                         If Len(CStr(vk)) > 10 Or (CInt(Abs(objRange.Value - vk) * 100) * 10 <> CInt(Abs(objRange.Value - vk) * 1000)) Then
                            szMsg = szMsg & "Geben Sie eine g|fffd|ltige Zahl mit maximal 10 Vorkomma- und 2 Nachkommastellen ein."
                            MsgBox szMsg, vbInformation, TOOLHEADER
                            Application.EnableEvents = False
                            objRange.Cells(1).Value = ""
                            Range(rngTarget.Cells(1).Name.Name & "_nk").Value = ""
                            objRange.Select
                            mNotValid = True
                            Application.EnableEvents = True
                         Else
                            Application.EnableEvents = False
                            If objRange.Cells(1).Value < 0 And objRange.Cells(1).Value > -1 Then
                                Range(rngTarget.Cells(1).Name.Name).Value = "'-0"
                            Else
                                If objRange.Cells(1).Value > 0 And objRange.Cells(1).Value < 1 Then
                                    Range(rngTarget.Cells(1).Name.Name).Value = "'0"
                                Else
                                    Range(rngTarget.Cells(1).Name.Name).Value = vk
                                End If
                            End If
                            If vk <> 0 And nk = 0 Then
                                Range(rngTarget.Cells(1).Name.Name & "_nk").Value = "'00"
                            Else
                                Range(rngTarget.Cells(1).Name.Name & "_nk").Value = nk
                            End If
                            Application.EnableEvents = True
                         End If
                     Else
                         szMsg = szMsg & "Geben Sie eine g|fffd|ltige Zahl mit maximal 10 Vorkomma- und 2 Nachkommastellen ein."
                         MsgBox szMsg, vbInformation, TOOLHEADER
                         Application.EnableEvents = False
                         objRange.Cells(1).Value = "0"
                         Range(rngTarget.Cells(1).Name.Name & "_nk").Value = "0"
                         Application.EnableEvents = True
                     End If
                End If
            Else    ' Nachkommafeld
                If Len(objRange.Cells(1).Value) < 3 And IsNumeric(objRange.Cells(1).Value) Then
                    If Range(Left(objRange.Cells(1).Name.Name, Len(objRange.Cells(1).Name.Name) - 3)).Value <> 0 Then
                        Application.EnableEvents = False
                        If objRange.Cells(1).Value <> "" Then
                            objRange.Cells(1).Value = Fix(objRange.Cells(1).Value)
                            If objRange.Cells(1).Value = 0 Then
                                objRange.Cells(1).Value = "'00"
                            End If
                        End If
                        Application.EnableEvents = True
                    End If
                Else
                    szMsg = szMsg & "Geben Sie eine g|fffd|ltige Zahl mit maximal 2 Stellen ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If

        ' --- Ankreuzfeld (leer oder X) ---
        Case "x"
            If Not IsEmpty(objRange.Cells(1).Value) Then
                Application.EnableEvents = False
                objRange.Cells(1).Value = "X"
                Application.EnableEvents = True
            End If
                         
        ' --- Ankreuzfeld (leer oder X) ---
        Case "tx"
            If Not IsEmpty(objRange.Cells(1).Value) Then
                Application.EnableEvents = False
                objRange.Cells(1).Value = "X"
                ' Da nur ein angekreuzt sein soll, m|fffd|ssen dann alle anderen geleert werden
                For intZ|fffd|hler = 1 To 17
                    If intZ|fffd|hler <> CInt(Mid$(rngTarget.Cells(1).Name.Name, 8)) Then
                        Range("ein_tx_" & CStr(intZ|fffd|hler)).Value = ""
                    End If
                Next
                Application.EnableEvents = True
            End If
        
        ' --- Ankreuzfeld (leer oder 1) ---
        Case "1"
            If Not IsEmpty(objRange.Cells(1).Value) Then
                Application.EnableEvents = False
                objRange.Cells(1).Value = "1"
                Application.EnableEvents = True
            End If
             
        ' --- Kontonummer ---
        Case "kto"
            If Not IsEmpty(objRange.Cells(1).Value) And Trim(objRange.Cells(1).Value) <> "" Then
                For i = 1 To Len(objRange.Cells(1).Value)
                    If Asc(Mid$(objRange.Cells(1).Value, i, 1)) < 48 Or Asc(Mid$(objRange.Cells(1).Value, i, 1)) > 57 Then
                        If Not (Asc(Mid$(objRange.Cells(1).Value, i, 1)) = 32 Or Asc(Mid$(objRange.Cells(1).Value, i, 1)) = 45) Then
                            szMsg = szMsg & "Geben Sie eine g|fffd|ltige Kontonummer ein."
                            MsgBox szMsg, vbInformation, TOOLHEADER
                            Application.EnableEvents = False
                            objRange.Cells(1).Value = ""
                            objRange.Select
                            mNotValid = True
                            Application.EnableEvents = True
                            GoTo ende ' weitere Bearbeitung abbrechen, da sonst auf ein nicht mehr
                                      ' existierendes Feld gesprungen wird.
                        End If
                    End If
                Next i
            End If

        ' --- internationale Telefonnummer ---
        Case "tel"
            If Not IsEmpty(objRange.Cells(1).Value) And Trim(objRange.Cells(1).Value) <> "" Then
                For i = 1 To Len(objRange.Cells(1).Value)
                    If Asc(Mid$(objRange.Cells(1).Value, i, 1)) < 48 Or Asc(Mid$(objRange.Cells(1).Value, i, 1)) > 57 Then
                        If Not (Asc(Mid$(objRange.Cells(1).Value, i, 1)) = 32 Or Asc(Mid$(objRange.Cells(1).Value, i, 1)) = 43 Or Asc(Mid$(objRange.Value, i, 1)) = 45) Then
                            szMsg = szMsg & "Geben Sie eine g|fffd|ltige Telefonnummer ein." & vbCrLf & "Eine g|fffd|ltige Telefonnummer besteht nur aus Ziffern, Leerzeichen sowie den Zeichen "" + "" und "" - ""."
                            MsgBox szMsg, vbInformation, TOOLHEADER
                            Application.EnableEvents = False
                            objRange.Cells(1).Value = ""
                            objRange.Select
                            mNotValid = True
                            Application.EnableEvents = True
                            GoTo ende ' weitere Bearbeitung abbrechen, da sonst auf ein nicht mehr
                                      ' existierendes Feld gesprungen wird.
                        End If
                    End If
                Next i
            End If

        ' --- Steuernummernfeld ---
        Case "stnr"
            If Not IsEmpty(objRange.Cells(1).Value) And Trim(objRange.Cells(1).Value) <> "" Then
                For i = 1 To Len(objRange.Cells(1).Value)
                    If Asc(Mid$(objRange.Cells(1).Value, i, 1)) < 47 Or Asc(Mid$(objRange.Cells(1).Value, i, 1)) > 57 Then
                        szMsg = szMsg & "Geben Sie eine g|fffd|ltige Steuernummer ein."
                        MsgBox szMsg, vbInformation, TOOLHEADER
                        Application.EnableEvents = False
                        objRange.Cells(1).Value = ""
                        objRange.Select
                        mNotValid = True
                        Application.EnableEvents = True
                        GoTo ende ' weitere Bearbeitung abbrechen, da sonst auf ein nicht mehr
                                  ' existierendes Feld gesprungen wird.
                    End If
                Next i
            End If
        
        ' --- Bankleitzahlenfeld ---
        Case "blz"
            If Not IsEmpty(objRange.Cells(1).Value) And Trim(objRange.Cells(1).Value) <> "" Then
                If Val(objRange.Cells(1).Value) < 10000000 Or Val(objRange.Cells(1).Value) > 99999999 Then
                    szMsg = szMsg & "Geben Sie eine g|fffd|ltige (8-stellige) Bankleitzahl ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                    Application.EnableEvents = False
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    Application.EnableEvents = True
                End If
            End If
             
        ' --- Radiofelder (es kann immmer nur ein Feld selektiert werden) ---
        Case "r"
            If Not IsEmpty(objRange.Cells(1).Value) And Trim(objRange.Cells(1).Value) <> "" Then
            i = 1
            Do
                If i <> strArray(3) Then
                    If existiert(strArray(0) & "_" & strArray(1) & "_" & strArray(2) & "_" & CStr(i)) Then
                        Application.EnableEvents = False
                        Range(strArray(0) & "_" & strArray(1) & "_" & strArray(2) & "_" & CStr(i)).Value = ""
                        Application.EnableEvents = True
                    Else
                        GoTo ende:
                    End If
                End If
                i = i + 1
            Loop
            End If

        ' --- Radiofelder (es kann immmer nur ein Feld selektiert werden), der Inhalt wird immer in "X" umgewandelt ---
        Case "rx"
            If Not IsEmpty(objRange.Cells(1).Value) Then
                Application.EnableEvents = False
                objRange.Cells(1).Value = "X"
                Application.EnableEvents = True
                                
'                If szNameAll = "ein_rx_2_1" Then
'                  Application.EnableEvents = False
'                  Worksheets("Seite 2").Range("ZStBNameAnschrift").Value = ""
'                  Worksheets("Seite 2").Range("ZStBTel").Value = ""
'                  Worksheets("Seite 2").Range("ZStBFax").Value = ""
'                  Worksheets("Seite 2").Range("ZStBEmail").Value = ""
'                  Application.EnableEvents = True
'                End If
'                If szNameAll = "ein_rx_2_2" Then
'                  Application.EnableEvents = False
'                  Worksheets("Seite 2").Range("ZStBNameAnschrift").Value = _
'                  Worksheets("Seite 2").Range("ZStBNameAnschriftCOPY").Value
'                  Worksheets("Seite 2").Range("ZStBTel").Value = _
'                  Worksheets("Seite 2").Range("ZStBTelCOPY").Value
'                  Worksheets("Seite 2").Range("ZStBFax").Value = _
'                  Worksheets("Seite 2").Range("ZStBFaxCopy").Value
'                  Worksheets("Seite 2").Range("ZStBEmail").Value = _
'                  Worksheets("Seite 2").Range("ZStBEmailCopy").Value
'                  Application.EnableEvents = True
'                End If
'                If szNameAll = "ein_rx_5_1" Then
'                  Application.EnableEvents = False
'                  Worksheets("Seite 2").Range("ZBsAnschrift1").Value = ""
'                  Worksheets("Seite 2").Range("ZBsTelefon1").Value = ""
'                  Worksheets("Seite 2").Range("ZBsAnschrift2").Value = ""
'                  Worksheets("Seite 2").Range("ZBsTelefon2").Value = ""
'                  Application.EnableEvents = True
'                End If
'                If szNameAll = "ein_rx_5_2" Then
'                  Application.EnableEvents = False
'                  Worksheets("Seite 2").Range("ZBsAnschrift1").Value = _
'                  Worksheets("Seite 2").Range("ZBsAnschrift1COPY").Value
'                  Worksheets("Seite 2").Range("ZBsTelefon1").Value = _
'                  Worksheets("Seite 2").Range("ZBsTelefon1COPY").Value
'                  Worksheets("Seite 2").Range("ZBsAnschrift2").Value = _
'                  Worksheets("Seite 2").Range("ZBsAnschrift2COPY").Value
'                  Worksheets("Seite 2").Range("ZBsTelefon2").Value = _
'                  Worksheets("Seite 2").Range("ZBsTelefon2COPY").Value
'                  Application.EnableEvents = True
'                End If

                i = 1
                Do
                    If i <> strArray(3) Then
                        If existiert(strArray(0) & "_" & strArray(1) & "_" & strArray(2) & "_" & CStr(i)) Then
                            Application.EnableEvents = False
                            Range(strArray(0) & "_" & strArray(1) & "_" & strArray(2) & "_" & CStr(i)).Value = ""
                            Application.EnableEvents = True
                        Else
                            GoTo ende:
                        End If
                    End If
                    i = i + 1
                Loop
            End If

        ' --- Datumsfelder (Datum steht in einem Feld) ---
        Case "ein_da"
            If Not IsEmpty(objRange.Value) And Trim(objRange.Value) <> "" Then
                ' objRange.NumberFormat = "@"
                If InStr(objRange.Cells(1).Value, ".") = 0 And (Len(objRange.Cells(1).Value) > 2 And Len(objRange.Cells(1).Value) < 9) Then
                    ' Datumseingabe der Form ddmmyy[yy] (ohne Trennzeichen)
                    objDate = ConvertDate(objRange.Cells(1).Value)
                    If objDate = 0 Then
                        objRange.Cells(1).Value = ""
                    Else
                        objRange.Value = Format(objDate, "dd.mm.yyyy")
                    End If
                    objRange.NumberFormat = "dd.mm.yyyy"
                ElseIf MyIsDate(objRange.Cells(1).Value) Then
                    objRange = Format(CDate(objRange.Cells(1).Value), "dd.mm.yyyy")
                    objRange.NumberFormat = "dd.mm.yyyy"
                Else
                    objRange.Cells(1).Value = ""
                    objRange.NumberFormat = "dd.mm.yyyy"
                    objRange.Select
                    mNotValid = True
                    szMsg = szMsg & "Bitte geben Sie ein g|fffd|ltiges Datum ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                End If
            End If
            
        ' --- Datumsfelder (Datum wird gesplittet und auf mehrere Felder verteilt) ---
        Case "ein_dx"
            If Not IsEmpty(objRange.Cells(1).Value) And Trim(objRange.Cells(1).Value) <> "" Then
                ' objRange.NumberFormat = "@"
                If InStr(objRange.Cells(1).Value, ".") = 0 And (Len(objRange.Cells(1).Value) > 2 And Len(objRange.Cells(1).Value) < 9) Then
                    objDate = ConvertDate(objRange.Value)
                    If objDate = 0 Then
                        objRange.Cells(1).Value = ""
                    Else
                        objRange.Cells(1).Value = Format(objDate, "dd.mm.yyyy")
                    End If
                    ' objRange.NumberFormat = "dd.mm.yyyy"
                End If
                If Not MyIsDate(objRange.Cells(1).Value) Then
                    objRange.Cells(1).Value = ""
                    objRange.Select
                    mNotValid = True
                    szMsg = szMsg & "Bitte geben Sie ein g|fffd|ltiges Datum ein."
                    MsgBox szMsg, vbInformation, TOOLHEADER
                End If
            End If
                    
    End Select
    ' Sonderbehandlung f|fffd|r
    ' * Typen, die nur f|fffd|r das aktuelle Workbook gelten und
    ' * f|fffd|r nachgeschaltete Pr|fffd|fungen
    ' DoSpecialType szType, szName, szNameNum, szRange
    
    ' Objektreferenz freigeben
    Set objRange = Nothing
    ' Blattschutz wieder einschalten
    Call Blattschutz_Vergeben(ActiveSheet)
    Application.ScreenUpdating = bScreenUpdate
    On Error GoTo 0
    ' Exit Sub
    GoTo ende

ErrEingabeKontrolle:
    ' Meldet bei einem Fehler die entsprechende Fehlernummer
    If Err <> 6 And Err <> 1000 And Err <> 1004 And Err <> 1005 And Err <> 1006 Then
        MsgBox TOOL_ID & "108" & vbCrLf & vbCrLf & _
            "W|fffd|hrend der Eingabekontrolle ist ein Fehler aufgetreten." & vbCrLf & vbCrLf & _
            vbTab & Err.Description & "(" & Err.number & ")", vbInformation, TOOLHEADER
    End If
    Application.EnableEvents = True
    ' Objektreferenz freigeben
    Set objRange = Nothing
    
ende:
    ' Blattschutz wieder einschalten
    Call Blattschutz_Vergeben(ActiveSheet)
    Application.ScreenUpdating = bScreenUpdate
    On Error GoTo 0
End Function

Private Function existiert(Feldname As String) As Boolean
    On Error GoTo ErrBehandlung     ' Fehlerroutine aufsetzen
    Dim test As String
    test = Range(Feldname).Cells(1).Value
    existiert = True
    Exit Function
ErrBehandlung:
    existiert = False
End Function

' ConvertDate()
' Konvertiert einen Datumsstring der Form "[d]dmmjj[jj]" in ein g|fffd|ltiges Datum
' Die Funktion liefert 0, wenn eine Konvertierung nicht m|fffd|glich war (somit ist
' 0 als Datum nicht erlaubt)
Function ConvertDate(szDateIn As String) As Date
    Dim szDateOut As String
    Dim szConv As String
    Dim i As Integer
    
    ConvertDate = 0
    szConv = szDateIn
    ' Fehlende f|fffd|hrende 0 und fehlendes Jahr erg|fffd|nzen
    i = Len(szDateIn)
    Select Case i
        Case 3, 4
            If i = 3 Then szConv = "0" & szDateIn
            szConv = szConv & Format(Date, "YYYY")
        Case 5, 7
            szConv = "0" & szDateIn
    End Select
    ' Datumsstring pr|fffd|fen (keine Pr|fffd|fung auf Datumskonsistenz (28., 29., 30. oder 31.)
    On Error GoTo ErrConvertDate
    ' Tag
    i = Val(Left(szConv, 2))
    If i < 1 Or i > 31 Then GoTo ErrConvertDate
    szDateOut = Left(szConv, 2) & "."
    ' Monat
    i = Val(Mid(szConv, 3, 2))
    If i < 1 Or i > 12 Then GoTo ErrConvertDate
    szDateOut = szDateOut & Mid(szConv, 3, 2) & "."
    ' Jahr
    szDateOut = szDateOut & Mid(szConv, 5)
    On Error GoTo 0
    ConvertDate = CDate(szDateOut)
    Exit Function
    
ErrConvertDate:
    On Error GoTo 0
End Function

' MyIsDate()
' |fffd|hnlich wie IsDate(), erwartet aber immer ein Datum in der Form "[d]d.[m]m.[yy[yy]]"
Function MyIsDate(szDate As String) As Boolean
    Dim szConv As String
    Dim da As Date
    Dim i As Integer
    Dim j As Integer
    Dim iDay As Integer
    Dim iMonth As Integer
    Dim iYear As Integer
    Dim szmatch As String
    
    MyIsDate = False
    On Error GoTo ErrMyIsDate
    
    ' Ersten Teil herausl|fffd|sen
    i = InStr2(szDate, ".-/", szmatch)
    If i = 0 Then Exit Function
    iDay = Val(Left(szDate, i - 1))
    szConv = Mid(szDate, i + 1)
    
    ' Zweiten Teil holen
    i = InStr2(szConv, ".-/", szmatch)
    
    ' Wenn i <> 0, dann erwarten wir d.m.y
    ' Wenn i = 0, dann erwarten wir m.y
    If i = 0 Then
        iMonth = iDay
        iDay = 1
        iYear = Val(szConv)
    Else
        iMonth = Val(Left(szConv, i - 1))
        szConv = Mid(szConv, i + 1)
        If szConv <> "" Then
            iYear = Val(szConv)
        Else
            iYear = Year(Now)
        End If
    End If
    
    ' Ok, und jetzt die Pr|fffd|fungen...
    If iMonth < 1 Or iMonth > 12 Then Exit Function
    Select Case iMonth
        Case 4, 6, 9, 11
            If iDay < 1 Or iDay > 30 Then Exit Function
        Case 2
            If iDay < 1 Or iDay > 29 Then Exit Function
        Case Else
            If iDay < 1 Or iDay > 31 Then Exit Function
    End Select
    If iYear < 0 Or iYear > 2999 Then Exit Function
    
    ' Validieren
    szConv = Format(iDay, "00") & szmatch & Format(iMonth, "00") & szmatch & CStr(iYear)
    If Not IsDate(szConv) Then Exit Function
    MyIsDate = True
    ' Fall through
    
ErrMyIsDate:
    On Error GoTo 0
End Function

Public Function GetName(szRange As String) As String
    Dim szName As String
    Dim i As Integer
    
    GetName = ""
    On Error GoTo errGetname
    szName = Range(szRange).Name.NameLocal
    If InStr(szName, "ein_") = 1 Then
        ' Sofort gefunden
        GetName = szName
        Exit Function
    End If
    ' Pech, die Names-Auflistung durchsuchen...
    With ThisWorkbook.Names
        For i = 1 To .count
            'If InStr(.Item(i).RefersTo, "Seite") Then Debug.Print .Item(i).RefersTo & ", " & .Item(i).RefersToLocal
            If InStr(.Item(i).RefersToLocal, "=" & ActiveSheet.Name & "!" & szRange) > 0 And InStr(.Item(i).NameLocal, "ein_") = 1 Then
                ' Passenden Eintrag gefunden (mehrere ein_-Namen werden nicht unterst|fffd|tzt!)
                GetName = .Item(i).NameLocal
                On Error GoTo 0
                Exit Function
            End If
        Next
    End With
    
errGetname:
    On Error GoTo 0
End Function

Function InStr2(szIn As String, szWhat As String, szmatch As String) As Long
    Dim i As Long
    Dim j As Long
    Dim szC As String
    
    InStr2 = 0
    For i = 1 To Len(szIn)
        For j = 1 To Len(szWhat)
            szmatch = Mid(szWhat, j, 1)
            If Mid(szIn, i, 1) = szmatch Then
                InStr2 = i
                Exit Function
            End If
        Next j
    Next i
        
End Function
Attribute VB_Name = "modEintragung"
Option Explicit

Public Sub ClearStammdatenfelder()
    Call ClearEintragung
    Call CopyEintragung
    Range("AktiveBankPers").Value = 0
    Range("AktiveBankUnt").Value = 0
    Range("AktiveBankAlle").Value = 0
    Range("BetriebStaetten").Value = 0
    Call FillDropDown("Seite 2", "BankenAuswahl1", "AktiveBankAlle")
    Call FillDropDown("Seite 2", "BankenAuswahl2", "AktiveBankPers")
    Call FillDropDown("Seite 2", "BankenAuswahl3", "AktiveBankUnt")
    Call FillDropDown("Seite 6", "BetriebAuswahl", "BetriebStaetten")
End Sub

Public Sub CopyStammdatenfelder()
    Call BankenVerdichten
    Call ErmittleHauptbankPers
    Call ErmittleHauptbankUnt
    Call FillDropDown("Seite 2", "BankenAuswahl1", "AktiveBankAlle")
    Call AktivenEintragSetzen(4, "AktiveBankAlle")
    Call FillDropDown("Seite 2", "BankenAuswahl2", "AktiveBankPers")
    Call AktivenEintragSetzen(4, "AktiveBankPers")
    Call FillDropDown("Seite 2", "BankenAuswahl3", "AktiveBankUnt")
    Call AktivenEintragSetzen(4, "AktiveBankUnt")
    Call FillDropDown("Seite 6", "BetriebAuswahl", "BetriebStaetten")
    Call AktivenEintragSetzen(5, "BetriebStaetten")
    Call CopyEintragung
End Sub

Public Sub ClearEintragung()
   Dim ws As Worksheet
   Dim i As Integer
   Dim j As Integer
   Dim lAnzahl As Long
   
   Set ws = ThisWorkbook.Worksheets("Eintragung")
   
   j = 2
   While Not IsEmpty(ws.Cells(j, 1))
        If ws.Cells(j, 1).Value = "ZMSD" Then
            lAnzahl = Val(ws.Cells(j, GCOLUMN_VFelder))
            If lAnzahl <> 0 Then
              ' Vielfachfelder
                ws.Range(ws.Cells(j, GCOLUMN_VFelderBeginn), ws.Cells(j, ws.Columns.count)).ClearContents
            End If
            ws.Cells(j, GCOLUMN_Wert) = ""
        End If
        j = j + 1
    Wend
End Sub

Public Sub CopyEintragung(Optional sTyp As String = "COPY")
    
    Dim ws As Worksheet
    Dim j As Long
    Dim sQuelle As String
    Dim sZiel As String
    
    Set ws = ThisWorkbook.Worksheets("Eintragung")

    Application.StatusBar = "Stammdaten kopieren"
    Application.ScreenUpdating = False
    Application.EnableEvents = False
      
    j = 2
    While Not IsEmpty(ws.Cells(j, 1))
        If UCase$(ws.Cells(j, 1).Value) = sTyp Then
            sQuelle = ws.Cells(j, GCOLUMN_Wert)
            sZiel = ws.Cells(j, GCOLUMN_Name)
            Application.Range(sZiel).Value = sQuelle
        End If
        j = j + 1
    Wend
    
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
End Sub
Attribute VB_Name = "modEintragungBS"
Option Explicit

Public Sub BSAuswahl()
  
  SelektierteBSSetzen 5, "BetriebStaetten"
  CopyFeld ("ZBsName")
  CopyFeld ("ZBsStrasse")
  CopyFeld ("ZBsPLZ")
  CopyFeld ("ZBsOrt")
End Sub

Public Sub FillBSDropDown(strSheetName As String, strDropDownName As String, strBSZelle As String)
   Dim intBSSpalte As Integer
   Dim intBSZeile As Integer
   Dim intZ|fffd|hler As Integer
   Dim wkEinzug As Worksheet
   Dim strBSName As String, strBSStrasse As String, strBSPLZ As String, strBSOrt As String
   Dim intAnzahl As Integer

          
   Set wkEinzug = ActiveWorkbook.Worksheets(strSheetName)
   wkEinzug.DropDowns(strDropDownName).RemoveAllItems
   intBSSpalte = Sheets("Eintragung").Range(strBSZelle).Column
   intBSZeile = Sheets("Eintragung").Range(strBSZelle).Row
   intAnzahl = Sheets("Eintragung").Cells(intBSZeile, GCOLUMN_VFelder).Value

   intZ|fffd|hler = 1
   While intZ|fffd|hler <= intAnzahl
         strBSName = Sheets("Eintragung").Cells(intBSZeile, intBSSpalte + intZ|fffd|hler).Value
         strBSStrasse = Sheets("Eintragung").Cells(intBSZeile + 1, intBSSpalte + intZ|fffd|hler).Value
         strBSPLZ = Sheets("Eintragung").Cells(intBSZeile + 2, intBSSpalte + intZ|fffd|hler).Value
         strBSOrt = Sheets("Eintragung").Cells(intBSZeile + 3, intBSSpalte + intZ|fffd|hler).Value
         If strBSName = "" And strBSStrasse = "" And strBSPLZ = "" And strBSOrt = "" Then
           wkEinzug.DropDowns(strDropDownName).AddItem Text:=intZ|fffd|hler & ".) "
         Else
           wkEinzug.DropDowns(strDropDownName).AddItem Text:=intZ|fffd|hler & ".) " & strBSName & ", " & strBSStrasse & ", " & strBSPLZ & " " & strBSOrt
         End If
      intZ|fffd|hler = intZ|fffd|hler + 1
   Wend
   
   wkEinzug.DropDowns(strDropDownName).ListIndex = 0
End Sub

Public Sub SelektierteBSSetzen(intAnzahlEintr|fffd|ge As Integer, strBSZelle As String)
    Dim intColumnAktiv As Integer
    Dim wkEintragung As Worksheet
    Dim intColumnPlus As Integer
    Dim intBSSpalte As Integer
    Dim intBSZeile As Integer
    Dim intZ|fffd|hler As Integer
    Dim strQuelle As String
    Dim strZiel As String
    intColumnPlus = 1
    
    Set wkEintragung = ActiveWorkbook.Worksheets("Eintragung")
    intColumnAktiv = wkEintragung.Range(strBSZelle).Value
    intBSSpalte = Range(strBSZelle).Column
    intBSZeile = Range(strBSZelle).Row
    
    intAnzahlEintr|fffd|ge = intAnzahlEintr|fffd|ge - 1
    For intZ|fffd|hler = 0 To intAnzahlEintr|fffd|ge
        strQuelle = wkEintragung.Cells(intBSZeile + intZ|fffd|hler, intBSSpalte + intColumnAktiv)
        strZiel = wkEintragung.Cells(intBSZeile + intZ|fffd|hler, intBSSpalte - 2).Value
        wkEintragung.Range(strZiel).Value = strQuelle
    Next
End Sub
Attribute VB_Name = "modEintragungVielfach"
Option Explicit

Public Sub FillDropDown(strSheetName As String, strDropDownName As String, strAktiveZelle As String)
    Dim intSpalte As Long
    Dim intZeile As Long
    Dim intSpaltenOffset As Long
    Dim intLetzteSpalte As Long
    Dim wsSeite As Worksheet
    Dim wsEintragung As Worksheet
    
    ' DropDown leeren
    Set wsSeite = ThisWorkbook.Worksheets(strSheetName)
    wsSeite.DropDowns(strDropDownName).RemoveAllItems
    
    ' Position ermitteln
    Set wsEintragung = ThisWorkbook.Worksheets("Eintragung")
    intSpalte = wsEintragung.Range(strAktiveZelle).Column + 1
    intZeile = wsEintragung.Range(strAktiveZelle).Row
    intLetzteSpalte = wsEintragung.Range(wsEintragung.Cells(intZeile, 1), wsEintragung.Cells(intZeile, wsEintragung.Columns.count)).Find(What:="*", After:=wsEintragung.Cells(intZeile, wsEintragung.Columns.count), LookIn:=xlValues, SearchOrder:=xlByColumns, SearchDirection:=xlPrevious).Column
    
    ' DropDown f|fffd|llen
    If intLetzteSpalte >= intSpalte Then
        For intSpaltenOffset = 0 To intLetzteSpalte - intSpalte
            wsSeite.DropDowns(strDropDownName).AddItem Text:=intSpaltenOffset + 1 & ".) " & wsEintragung.Cells(intZeile, intSpalte + intSpaltenOffset)
        Next
        ' DropDown einstellen
        wsSeite.DropDowns(strDropDownName).ListIndex = wsEintragung.Range(strAktiveZelle).Value
    End If

    Set wsSeite = Nothing
    Set wsEintragung = Nothing
End Sub

Public Sub AktivenEintragSetzen(lAnzahlZeilen As Long, szAktiveZelle As String)
    Dim ws As Worksheet
    Dim intAktiv As Integer
    Dim intSpalte As Integer
    Dim intZeile As Integer
    Dim intCount As Integer

    Set ws = ThisWorkbook.Worksheets("Eintragung")
    ' Wert und Position ermitteln
    intAktiv = Val(ws.Range(szAktiveZelle))
    intSpalte = ws.Range(szAktiveZelle).Column
    intZeile = ws.Range(szAktiveZelle).Row
    If intAktiv <> 0 Then
        For intCount = intZeile To intZeile + lAnzahlZeilen - 1
            ws.Cells(intCount, intSpalte - 1) = ws.Cells(intCount, intSpalte + intAktiv)
        Next
    End If
    Set ws = Nothing
End Sub

Public Sub VVUebernehmen1()
   Application.EnableEvents = False
   Call AktivenEintragSetzen(4, "AktiveBankAlle")
   Call CopyFeld("ZAlleIBAN1")
   Call CopyFeld("ZAlleIBAN2")
   Call CopyFeld("ZAlleBIC")
   Call CopyFeld("ZAlleAbweicher")
   Application.EnableEvents = True
End Sub

Public Sub VVUebernehmen2()
   Application.EnableEvents = False
   Call AktivenEintragSetzen(4, "AktiveBankPers")
   Call CopyFeld("ZPersonIBAN1")
   Call CopyFeld("ZPersonIBAN2")
   Call CopyFeld("ZPersonBIC")
   Call CopyFeld("ZPersonAbweicher")
   Application.EnableEvents = True
End Sub

Public Sub VVUebernehmen3()
   Application.EnableEvents = False
   Call AktivenEintragSetzen(4, "AktiveBankUnt")
   Call CopyFeld("ZBetriebIBAN1")
   Call CopyFeld("ZBetriebIBAN2")
   Call CopyFeld("ZBetriebBIC")
   Call CopyFeld("ZBetriebAbweicher")
   Application.EnableEvents = True
End Sub

Public Sub BankenVerdichten()
    ' Verdichtet die ermittelten Banken (Privat und Unternehmen) f|fffd|r die Dropdown-Felder
    Dim iZeileQuelle As Integer
    Dim iSpalteQuelle As Integer
    Dim iZeileZiel As Integer
    Dim iSpalteZiel As Integer
    Dim iSchleifeZeile As Integer
    Dim iSchleifeSpalte As Integer
    Dim wsEintragung As Worksheet
    Dim lFirstRow As Long
    Dim lLastUsedRow As Long
    Dim lLastBankSpalte As Long
    Dim lPos As Long
    Dim lLastRow As Long
    Dim lSpalte As Long
    Dim lZeile As Long
    Dim lLastCol As Long
    '
    Const COL_FIRST = 8
    Const COL_OFFSET = 4
    '
    On Error GoTo ERR_BankenVerdichten
    
    Set wsEintragung = ThisWorkbook.Worksheets("Eintragung")
    Call Blattschutz_Aufheben(wsEintragung)
    
    ' 1. Letzte Zeile im Sheet ermitteln und Spalten|fffd|berschriften schreiben --> dort werden die Banken hinkopiert
    lFirstRow = GetLastUsedRow(wsEintragung, GCOLUMN_ART, GCOLUMN_Name) + 1
    For lPos = 0 To 2
        wsEintragung.Cells(lFirstRow, COL_FIRST + (lPos * COL_OFFSET) + 0) = "Bezeichnung"
        wsEintragung.Cells(lFirstRow, COL_FIRST + (lPos * COL_OFFSET) + 1) = "IBAN"
        wsEintragung.Cells(lFirstRow, COL_FIRST + (lPos * COL_OFFSET) + 2) = "BIC"
        wsEintragung.Cells(lFirstRow, COL_FIRST + (lPos * COL_OFFSET) + 3) = "AbwName"
    Next
    
    ' 2. Letzte Bank der Person bestimmen und umkopieren mit transponieren
    lLastRow = GetLastUsedRow(wsEintragung, COL_FIRST, COL_FIRST + COL_OFFSET - 1)
    lSpalte = wsEintragung.Range("AktiveBankPers").Column + 1
    lZeile = wsEintragung.Range("AktiveBankPers").Row
    lLastCol = wsEintragung.Range(wsEintragung.Cells(lZeile, 1), wsEintragung.Cells(lZeile, wsEintragung.Columns.count)).Find(What:="*", After:=wsEintragung.Cells(lZeile, wsEintragung.Columns.count), LookIn:=xlValues, SearchOrder:=xlByColumns, SearchDirection:=xlPrevious).Column
    wsEintragung.Range(wsEintragung.Cells(lZeile, lSpalte), wsEintragung.Cells(lZeile + COL_OFFSET - 1, lLastCol)).Copy
    wsEintragung.Cells(lLastRow + 1, COL_FIRST).PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=True, Transpose:=True
    
    ' 3. Letzte Bank des Unternehmens bestimmen und umkopieren mit transponieren
    lLastRow = GetLastUsedRow(wsEintragung, COL_FIRST, COL_FIRST + COL_OFFSET - 1)
    lSpalte = wsEintragung.Range("AktiveBankUnt").Column + 1
    lZeile = wsEintragung.Range("AktiveBankUnt").Row
    lLastCol = wsEintragung.Range(wsEintragung.Cells(lZeile, 1), wsEintragung.Cells(lZeile, wsEintragung.Columns.count)).Find(What:="*", After:=wsEintragung.Cells(lZeile, wsEintragung.Columns.count), LookIn:=xlValues, SearchOrder:=xlByColumns, SearchDirection:=xlPrevious).Column
    wsEintragung.Range(wsEintragung.Cells(lZeile, lSpalte), wsEintragung.Cells(lZeile + COL_OFFSET - 1, lLastCol)).Copy
    wsEintragung.Cells(lLastRow + 1, COL_FIRST).PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=True, Transpose:=True
    
    ' 4. Filter definieren
    wsEintragung.Cells(lFirstRow + 1, COL_FIRST + COL_OFFSET + 1).FormulaR1C1 = "<>"    '"=""<>"""
    ' 5. Erweiterten Filter anwenden
    lLastRow = GetLastUsedRow(wsEintragung, COL_FIRST, COL_FIRST + COL_OFFSET - 1)
    ' 5a. Murks wegen nicht leerer leerer Zellen
    For lPos = lFirstRow + 1 To lLastRow
        If LenB(wsEintragung.Cells(lPos, COL_FIRST + 1)) = 0 Then wsEintragung.Cells(lPos, COL_FIRST + 1).ClearContents
    Next
    ' 5b. Filtern...
    wsEintragung.Range(wsEintragung.Cells(lFirstRow, COL_FIRST), wsEintragung.Cells(lLastRow, COL_FIRST + COL_OFFSET - 1)).AdvancedFilter _
        Action:=xlFilterCopy, _
        CriteriaRange:=wsEintragung.Range(wsEintragung.Cells(lFirstRow, COL_FIRST + COL_OFFSET), wsEintragung.Cells(lFirstRow + 1, COL_FIRST + COL_OFFSET + COL_OFFSET - 1)), _
        CopyToRange:=wsEintragung.Range(wsEintragung.Cells(lFirstRow, COL_FIRST + (COL_OFFSET * 2)), wsEintragung.Cells(lFirstRow, COL_FIRST + (COL_OFFSET * 2) + COL_OFFSET - 1)), _
        Unique:=True
        
    ' 6. Ergebnis zur|fffd|ck kopieren mit transponieren
    lLastRow = GetLastUsedRow(wsEintragung, COL_FIRST + (COL_OFFSET * 2), COL_FIRST + (COL_OFFSET * 2) + COL_OFFSET - 1)
    wsEintragung.Range(wsEintragung.Cells(lFirstRow + 1, COL_FIRST + (COL_OFFSET * 2)), wsEintragung.Cells(lLastRow, COL_FIRST + (COL_OFFSET * 2) + COL_OFFSET - 1)).Copy
    wsEintragung.Range("BankZielStart").PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=True, Transpose:=True
    
    ' 7. Aufr|fffd|umen
    lLastRow = GetLastUsedRow(wsEintragung, COL_FIRST, COL_FIRST + COL_OFFSET - 1)
    wsEintragung.Range(wsEintragung.Cells(lFirstRow, COL_FIRST), wsEintragung.Cells(lLastRow, COL_FIRST + (COL_OFFSET * 2) + COL_OFFSET - 1)).ClearContents
    On Error GoTo 0
    Exit Sub
    
ERR_BankenVerdichten:
    Debug.Print "BankenVersichten(): Err=" & Err.number & "; " & Err.Description
    Resume Next
End Sub

Public Sub ErmittleHauptbankPers()
    Dim ws As Worksheet
  
    Set ws = ThisWorkbook.Worksheets("Eintragung")
    If ws.Range("PersIBANVergleich") <> 0 Then
        ws.Range("AktiveBankPers") = ws.Range("PersIBANVergleich")
        If ws.Range("UntIBANVergleich") = 0 Then ws.Range("AktiveBankAlle") = ws.Range("AllePersIBANVergleich")
    End If
    Set ws = Nothing
    
End Sub

Public Sub ErmittleHauptbankUnt()
    Dim ws As Worksheet
  
    Set ws = ThisWorkbook.Worksheets("Eintragung")
    If ws.Range("UntIBANVergleich") <> 0 Then
        ws.Range("AktiveBankUnt") = ws.Range("UntIBANVergleich")
        ws.Range("AktiveBankAlle") = ws.Range("AlleUntIBANVergleich")
    End If
    Set ws = Nothing
End Sub

Private Function GetLastUsedRow(ws As Worksheet, ByVal lColFirst As Long, ByVal lColLast As Long) As Long
    GetLastUsedRow = ws.Range(ws.Cells(1, lColFirst), ws.Cells(ws.Rows.count, lColLast)).Find(What:="*", After:=ws.Cells(ws.Rows.count, lColFirst), SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row
End Function

Attribute VB_Name = "modFocus"
Option Explicit

Public Sub SetFocusBorder(Target As Range)
    Dim ws As Worksheet
    Dim objShape As shape
    Dim bProtected As Boolean
    
    On Error Resume Next
    
    If EingabeKontrolleNotValid Then
        Exit Sub
    End If
    
    Set ws = Target.Worksheet
    Set objShape = GetShape(ws)
       
    If Not objShape Is Nothing Then
        If Selection Is Nothing Then
            objShape.Visible = False
            GoTo END_SetFocusBorder
        End If
        If Selection.Style Is Nothing Then
            objShape.Visible = False
            GoTo END_SetFocusBorder
        End If
        bProtected = Blattschutz_Aufheben(ws)
        If Left(Selection.Style, 10) = "TB_Eingabe" Then
            If Target.Left > objShape.Left Then
                objShape.Width = Selection.Width
                objShape.Height = Selection.Height
                objShape.Top = Target.Top
                objShape.Left = Target.Left
            Else
                objShape.Top = Target.Top
                objShape.Left = Target.Left
                objShape.Width = Selection.Width
                objShape.Height = Selection.Height
            End If
            objShape.Visible = True
        Else
            objShape.Visible = False
        End If
        If bProtected Then Call Blattschutz_Vergeben(ws)
    End If

END_SetFocusBorder:
    On Error GoTo 0
    Set objShape = Nothing
    Set ws = Nothing
End Sub

Private Function GetShape(ws As Worksheet) As shape
    On Error Resume Next
    Set GetShape = ws.Shapes("Border_TB")
    On Error GoTo 0
End Function
Attribute VB_Name = "modGlobals"
Option Explicit

Public Const TOOL_ID = "#TB23"
Public Const TOOLHEADER = "Tool Neuanlage eines Mandats"
Public Const TOOLHELPFILE = "T0000023.chm"
Public Const TOOLCOMPID = "T0000023"

Public Const GCOLUMN_ART = 1
Public Const GCOLUMN_Person = 2
Public Const GCOLUMN_Betrieb = 3
Public Const GCOLUMN_VFelder = 4
Public Const GCOLUMN_Name = 5
Public Const GCOLUMN_Wert = 6
Public Const GCOLUMN_VFelderBeginn = 8
Attribute VB_Name = "modHelp"
Option Explicit

Public Const HELP_CONTEXT = &H1
Public Const HELP_CONTEXTPOPUP = &H8&
Public Const HELP_FINDER = &HB
Public Const HELP_QUIT = &H2

Public Sub Bedienung()
    Call HilfeAufruf(6205)
End Sub

Public Sub HilfeAufruf(lContextID As Long, Optional lWinHlpCommand As Long = HELP_CONTEXT)
    Dim tbHilfe As Object
    
    Set tbHilfe = ToolboxServer32("CToolbox")
    If Not tbHilfe Is Nothing Then
        Call tbHilfe.ToolHilfe(TOOLHELPFILE, lContextID, lWinHlpCommand)
    Else
        MsgBox TOOL_ID & "303" & vbCrLf & vbCrLf & _
            "Die angeforderte Hilfedatei konnte nicht aufgerufen werden." & vbCrLf & vbCrLf & _
            Chr(187) & " Pr|fffd|fen Sie die Installation von " & TOOLHEADER & vbCrLf & _
            "   und installieren Sie das Tool gegebenenfalls erneut.", _
            vbInformation, TOOLHEADER
    End If
End Sub
Attribute VB_Name = "modKanzleidaten"
Option Explicit

Private Enum enRetVal
    Success = 0
    NoData = 1
    Abort = 2
    Fatal = 3
End Enum

Public Sub KanzleidatenEintragenStB()
    KanzleidatenL|fffd|schen
    If KanzleidatenEintragen(True) Then
        Call ClearBerater
        Call KanzleidatenKopieren("CopyStB")
        If Range("ZStBName").Value <> "" Then
            Application.EnableEvents = False
            Range("ein_rx_2_2").Value = "X"
            Range("ein_rx_2_1").Value = ""
            Application.EnableEvents = True
        End If
    End If
End Sub

Public Sub KanzleidatenEintragenEmpf()
    KanzleidatenL|fffd|schen
    If KanzleidatenEintragen(True) Then
        Call ClearEmpfang
        Call KanzleidatenKopieren("CopyEmpf")
    End If
End Sub

Private Function KanzleidatenEintragen(bSilent As Boolean) As Boolean
    Dim eRetVal As enRetVal
    Dim bRetVal As Boolean
    
    bRetVal = False
    Select Case KanzleidatenHolen(bSilent)
        Case enRetVal.Success
            bRetVal = True
        Case enRetVal.NoData
            If Not bSilent Then
                MsgBox TOOL_ID + "101" + vbCrLf + vbCrLf + _
                    "In der Toolbox-Umgebung wurden noch keine Kanzleidaten hinterlegt." + vbCrLf + vbCrLf + _
                    Chr(187) + " Hinterlegen Sie Kanzleidaten in der Toolbox-Umgebung.", _
                    vbInformation, TOOLHEADER
            End If
        Case enRetVal.Abort
            ' Abbruch durch den Benutzer --> Keine Meldung
        Case enRetVal.Fatal
            ' Fehler bei der Initialisierung --> Meldung kam schon, abh|fffd|ngig von bSilent
    End Select
    KanzleidatenEintragen = bRetVal
End Function

Private Sub KanzleidatenL|fffd|schen()
    With ThisWorkbook.Worksheets("Kanzleidaten")
        On Error Resume Next
        .Range("KDBezeichnung1") = ""
        .Range("KDBezeichnung2") = ""
        .Range("KDStrasse") = ""
        .Range("KDHausnummer") = ""
        .Range("KDHausnummerZusatz") = ""
        .Range("KDPLZ") = ""
        .Range("KDOrt") = ""
        .Range("KDTel") = ""
        .Range("KDFax") = ""
        .Range("KDMobil") = ""
        .Range("KDEmail") = ""
        .Range("KDInternet") = ""
        On Error GoTo 0
    End With
End Sub

Private Function KanzleidatenHolen(bSilent As Boolean) As enRetVal
    Dim tb As Object
    
    Set tb = ToolboxServer32("TBKanzleidaten", bSilent)
    
    If tb Is Nothing Then
        KanzleidatenHolen = enRetVal.Fatal
        Exit Function
    End If
    
    If Not tb.Datenvorhanden Then
        KanzleidatenHolen = enRetVal.NoData
        Exit Function
    End If
    
    If tb.count > 1 Then
        If Not tb.ShowDialog Then
            KanzleidatenHolen = enRetVal.Abort
            Exit Function
        End If
    End If
        
  With ThisWorkbook.Worksheets("Kanzleidaten")
    On Error Resume Next
    .Range("KDBezeichnung1") = tb.Bezeichnung
    .Range("KDBezeichnung2") = tb.Bezeichnung1
    .Range("KDStrasse") = tb.Stra|fffd|e2
    .Range("KDHausnummer") = tb.Hausnummer
    .Range("KDHausnummerZusatz") = tb.HausnummerZusatz
    .Range("KDPLZ") = tb.PLZ
    .Range("KDOrt") = tb.Ort
    .Range("KDTel") = tb.Tel
    .Range("KDFax") = tb.Fax
    .Range("KDMobil") = tb.Mobil
    .Range("KDEmail") = tb.Email
    .Range("KDInternet") = tb.InternetURL
    On Error GoTo 0
  End With
  Set tb = Nothing
  
End Function

Private Sub KanzleidatenKopieren(strBereich As String)
    Dim bScreenUpdate As Boolean
    Dim ws As Worksheet
    Dim i As Integer
    
    bScreenUpdate = Application.ScreenUpdating
    Application.ScreenUpdating = False
    Set ws = ThisWorkbook.Worksheets("Kanzleidaten")
    i = 1
    ws.Calculate
    ThisWorkbook.Activate
    While ws.Cells(i, 1) <> ""
        If CStr(ws.Cells(i, 1).Value) = strBereich Then
            Application.EnableEvents = False
            Range(ws.Cells(i, 2).Value).Value = ws.Cells(i, 3).Value
            Application.EnableEvents = True
        End If
        i = i + 1
    Wend
    If bScreenUpdate Then Application.ScreenUpdating = bScreenUpdate
End Sub

' L|fffd|scht nicht aus den Stammdaten eingelesene Felder
Private Sub ClearEmpfang()
    With ThisWorkbook.Worksheets("Seite 3")
        On Error Resume Next
        .Range("ZEmpfName") = ""
        .Range("ZEmpfVorname") = ""
        .Range("ZEmpfAdressergaenzung") = ""
        .Range("ZEmpfPLZPostfach") = ""
        .Range("ZEmpfOrtPostfach") = ""
        .Range("ZEmpfPostfach") = ""
        .Range("ZEmpfVorwahlInt") = ""
        .Range("ZEmpfVorwahlNat") = ""
        On Error GoTo 0
    End With
End Sub

Private Sub ClearBerater()
    With ThisWorkbook.Worksheets("Seite 2")
        On Error Resume Next
        .Range("ZStBName") = ""
        .Range("ZStBVorname") = ""
        .Range("ZStBAdressergaenzung") = ""
        .Range("ZStBPLZPostfach") = ""
        .Range("ZStBOrtPostfach") = ""
        .Range("ZStBPostfach") = ""
        .Range("ZStBVorwahlInt") = ""
        .Range("ZStBVorwahlNat") = ""
        On Error GoTo 0
    End With
End Sub

Attribute VB_Name = "modPrintNew"
Option Explicit

'Konstanten die im Druck verwendet werden
Public Const PAGEPRINT = "Drucken"
Public Const PAGE1 = "Seite 1"
Public Const PAGE2 = "Seite 2"
Public Const PAGE3 = "Seite 3"
Public Const PAGE4 = "Seite 4"
Public Const PAGE5 = "Seite 5"
Public Const PAGE6 = "Seite 6"
Public Const PAGE7 = "Seite 7"
Public Const PAGE8 = "Seite 8"
Public Const PAGE9 = "Seite 9"

Public Const GRAU As Integer = 37
Public Const WEISS As Integer = 2

'***********************************************
'Pr|fffd|ft Printer und ruft Service auf
'
'***********************************************
Public Sub PrintDocument()
Dim szPara(1) As String
Dim strPrinter As String
Dim intResult As String
    
   On Error GoTo fehler
    strPrinter = Application.ActivePrinter
   On Error GoTo 0
    If strPrinter <> "" Then
            Call Blattschutz_Aufheben(Worksheets(PAGEPRINT))
            Worksheets(PAGEPRINT).Cells(2, 10) = strPrinter
           
            szPara(0) = ActiveWorkbook.FullName
            szPara(1) = Application.ActivePrinter
            Application.DisplayAlerts = False
            intResult = Execute(DispIdDrucken, szPara)
            Application.DisplayAlerts = True
            If intResult >= 0 Then
                   getReadyForPrint
            ElseIf intResult = -1 Then
                   If MsgBox(TOOL_ID + "401" & vbCrLf & vbCrLf & "M|fffd|chten Sie mit Standardeinstellungen drucken?" & vbCrLf & _
                      vbCrLf, vbQuestion + vbYesNo, TOOLHEADER) = vbYes Then
                       
                       Call Blattschutz_Aufheben(Worksheets(PAGEPRINT))
                       getReadyForPrint
                End If
            End If
        
    Else
fehler:
            MsgBox TOOL_ID + "401" & vbCrLf & vbCrLf & "Bitte beachten Sie, dass dieses Formular " & vbCrLf & _
                "nur gedruckt werden kann, wenn ein Drucker installiert ist!" & vbCrLf, vbCritical, TOOLHEADER
    End If

End Sub




'***********************************************
'Liest die Einstellungen des Benutzers aus dem Sheet Drucken
'und Ruft Druck auf
'***********************************************
Function getReadyForPrint() As Boolean
     Dim bHeader As Boolean
     Dim bSeite(7) As Boolean
     Dim i As Integer
     Dim bDuplex As Boolean
     Dim count As Integer
     Dim strPrinter As String
     
     With Worksheets(PAGEPRINT)
        bHeader = .Cells(2, 11)
        
        For i = 0 To 7
            bSeite(i) = .Cells(2 + i, 5)
        Next
        bDuplex = .Cells(2, 12)
        count = .Cells(2, 9)
        strPrinter = .Cells(2, 10)
       
     End With
     getReadyForPrint = printEX(bHeader, bSeite, count, strPrinter, bDuplex)
End Function
  
'*************************************************
'Druck f|fffd|r das Dokument
'*************************************************
Function printEX(bHeader As Boolean, bSeite As Variant, count As Integer, strPrinter As String, bDuplex As Boolean) As Boolean
    Dim fvBackGround As Object
    Dim strActiveSheet As String
    Dim blnSheetSelected As Boolean
    Dim sHeader As String
    Dim ws As Worksheet
    Dim iZaehler As Integer
    Dim strOldPrinter As String
    Dim bDoPrint As Boolean
    Dim sheetsArray() As String
    Dim SEITEN As Variant
    
    SEITEN = Array(PAGE1, PAGE2, PAGE3, PAGE4, PAGE5, PAGE6, PAGE7, PAGE8, PAGE9)
    
    On Error GoTo ERR_printEX
    printEX = False
    
    If IsArray(bSeite) Then
        For iZaehler = 0 To UBound(bSeite)
            If bSeite(iZaehler) Then
                bDoPrint = True
                Exit For
            End If
        Next
    Else
        ' Es wurde kein Array() |fffd|bergeben
        Debug.Print "printEx(): Fehlerhafte Parameter|fffd|bergabe"
        On Error GoTo 0
        Exit Function
    End If
        
    strOldPrinter = Application.ActivePrinter
    Application.ActivePrinter = strPrinter
    
    Application.ScreenUpdating = True
    
    If bDoPrint Then
        Set fvBackGround = ThisWorkbook.Styles("TB_BackgroundLight").Interior
        
        strActiveSheet = ActiveSheet.Name
        Application.ScreenUpdating = False
        
        For Each ws In ThisWorkbook.Worksheets
            Call Blattschutz_Aufheben(ws)
        Next ws
        
        On Error Resume Next
        sHeader = Range("Header").Value
        If bHeader And Trim(sHeader) <> "/" Then       ' Ausdruck mit Mandantenname und -nummer
            Application.EnableEvents = False
                
            For iZaehler = 0 To UBound(bSeite)
                If ExistsWorksheet(ThisWorkbook, CStr(SEITEN(iZaehler))) Then
                    ThisWorkbook.Worksheets(CStr(SEITEN(iZaehler))).Range("Header" + CStr(iZaehler + 1)).Value = sHeader
                End If
            Next
            
            Application.EnableEvents = True
        End If
        On Error GoTo ERR_printEX
        
        fvBackGround.ColorIndex = WEISS
                
        blnSheetSelected = False
        For iZaehler = 0 To UBound(bSeite)
            If bSeite(iZaehler) Then
                If blnSheetSelected Then
                    ReDim Preserve sheetsArray(UBound(sheetsArray) + 1)
                Else
                    ReDim sheetsArray(0)
                    blnSheetSelected = True
                End If
                sheetsArray(UBound(sheetsArray)) = CStr(SEITEN(iZaehler))
            End If
        Next
        
        If blnSheetSelected Then
            ThisWorkbook.Worksheets(sheetsArray).Select
        End If
      
        On Error Resume Next
        Range("Ausdruck0").Font.Bold = True
        Range("Ausdruck1").Font.Size = 10
        Call BlanksFontSize("Ausdruck1", 5)
        Range("Ausdruck2").Font.Size = 10
        Range("Ausdruck3").Font.Size = 8
        Range("Ausdruck4").Font.Size = 10
        Range("Ausdruck5").Font.Size = 10
        Range("Ausdruck6").Font.Size = 10
        Range("Ausdruck7").Font.Size = 10
        Range("Ausdruck8").Font.Size = 8
        Range("Ausdruck10").Font.Size = 8
        Range("Ausdruck11").Font.Size = 10
        Range("Ausdruck13").Font.Size = 8
        Range("Ausdruck16").Font.Size = 8
        
        On Error Resume Next
        ActiveWindow.SelectedSheets.PrintOut copies:=count, collate:=True ' Ausdruck
        If Err.number <> 0 Then
            Debug.Print "printEx(): PrintOut; Err=" & Err.number & "; " & Err.Description
        Else
            printEX = True
        End If
        On Error GoTo ERR_printEX
        
        Range("Ausdruck0").Font.Bold = False
        Range("Ausdruck1").Font.Size = 9
        Call BlanksFontSize("Ausdruck2", 7)
        Call BlanksFontSize("Ausdruck3", 5)
        Call BlanksFontSize("Ausdruck4", 7)
        Call BlanksFontSize("Ausdruck5", 7)
        Call BlanksFontSize("Ausdruck6", 7)
        Call BlanksFontSize("Ausdruck7", 7)
        Call BlanksFontSize("Ausdruck8", 7)
        Call BlanksFontSize("Ausdruck10", 6)
        Call BlanksFontSize("Ausdruck11", 6)
        Call BlanksFontSize("Ausdruck13", 7)
        Range("Ausdruck16").Font.Size = 7
        
        fvBackGround.ColorIndex = GRAU
        ThisWorkbook.Worksheets(PAGE1).Select
        For Each ws In ThisWorkbook.Worksheets
          ws.Activate
          Application.EnableEvents = False
          Select Case ws.Name
            Case PAGE1
              ws.Range("ZFaBezeichnung").Select
            Case PAGE2
              ws.Range("ZAlleIBAN1").Select
              ws.Range("Header2").Value = ""
            Case PAGE3
              ws.Range("ein_x_1").Select
              ws.Range("Header3").Value = ""
            Case PAGE4
              ws.Range("ein_d_21").Select
              ws.Range("Header4").Value = ""
            Case PAGE5
              ws.Range("ein_rx_9_1").Select
              ws.Range("Header5").Value = ""
            Case PAGE6
              ws.Range("ZBsName").Select
              ws.Range("Header6").Value = ""
            Case PAGE7
              ws.Range("ein_rx_15_1").Select
              ws.Range("Header7").Value = ""
            Case PAGE8
              ws.Range("ein_x_14").Select
              ws.Range("Header8").Value = ""
            Case Else
              ws.Range("A1").Select
          End Select
          Application.EnableEvents = True
          If ws.Visible = xlSheetVisible Then Blattschutz_Vergeben ws
          ActiveWindow.ScrollRow = 1
          ActiveWindow.ScrollColumn = 1
        Next ws
        ThisWorkbook.Worksheets(strActiveSheet).Activate
    Else
        printEX = True
    End If
    Application.ScreenUpdating = True
    On Error GoTo 0
    Exit Function
    
ERR_printEX:
    Debug.Print "printEx(): Err=" & Err.number & "; " & Err.Description
    Resume Next
End Function

Private Function ExistsWorksheet(wb As Workbook, szName As String) As Boolean
    ExistsWorksheet = False
    On Error GoTo ErrExistsWorksheet
    If wb.Worksheets(szName).Name = szName Then ExistsWorksheet = True
    On Error GoTo 0
    Exit Function
    
ErrExistsWorksheet:
    On Error GoTo 0
End Function

'**************************************************
'Zur|fffd|cksetzen der Druckparameter
'**************************************************
Sub resetPrinterFkt()
Dim i As Integer

     With Worksheets(PAGEPRINT)
         .Cells(2, 11) = ""
              
            For i = 0 To 7
                .Cells(2 + i, 5) = ""
            Next
         .Cells(2, 12) = ""
         .Cells(2, 9) = ""
         .Cells(2, 10) = ""
     End With
End Sub
Attribute VB_Name = "modSpecialFolder"
Option Explicit

Public Declare Function SHGetFolderPath Lib "shfolder" Alias "SHGetFolderPathA" (ByVal hwndOwner As Long, ByVal nFolder As Long, ByVal hToken As Long, ByVal dwFlags As Long, ByVal pszPath As String) As Long
Public Declare Function GetCurrentProcess Lib "kernel32" () As Long
Public Declare Function GetCurrentThread Lib "kernel32" () As Long
Public Declare Function OpenProcessToken Lib "Advapi32" (ByVal ProcessHandle As Long, ByVal DesiredAccess As Long, TokenHandle As Long) As Long
Public Declare Function OpenThreadToken Lib "Advapi32" (ByVal ThreadHandle As Long, ByVal DesiredAccess As Long, ByVal OpenAsSelf As Long, TokenHandle As Long) As Long

Private Const TOKEN_QUERY = &H8
Private Const S_OK = &H0                ' Success
Private Const S_FALSE = &H1             ' The Folder is valid, but does not exist
Private Const E_INVALIDARG = &H80070057 ' Invalid CSIDL Value
Private Const SHGFP_TYPE_CURRENT = 0
Private Const MAX_PATH As Long = 260

Public Enum ShellFolder
    CSIDL_DESKTOP = &H0&    ' <desktop>
    CSIDL_INTERNET = &H1&   ' Internet Explorer (icon on desktop)
    CSIDL_PROGRAMS = &H2&   ' Start Menu\Programs
    CSIDL_CONTROLS = &H3&   ' My Computer\Control Panel
    CSIDL_PRINTERS = &H4&   ' My Computer\Printers
    CSIDL_PERSONAL = &H5&   ' My Documents
    CSIDL_FAVORITES = &H6&  ' <user name>\Favorites
    CSIDL_STARTUP = &H7&    ' Start Menu\Programs\Startup
    CSIDL_RECENT = &H8&     ' <user name>\Recent
    CSIDL_SENDTO = &H9&     ' <user name>\SendTo
    CSIDL_BITBUCKET = &HA&  ' <desktop>\Recycle Bin
    CSIDL_STARTMENU = &HB&  ' <user name>\Start Menu
    CSIDL_MYDOCUMENTS = CSIDL_PERSONAL ' Personal was just a silly name for My Documents
    CSIDL_MYMUSIC = &HD&    ' "My Music" folder
    CSIDL_MYVIDEO = &HE&    ' "My Videos" folder
    CSIDL_DESKTOPDIRECTORY = &H10& ' <user name>\Desktop
    CSIDL_DRIVES = &H11&    ' My Computer
    CSIDL_NETWORK = &H12&   ' Network Neighborhood (My Network Places)
    CSIDL_NETHOOD = &H13&   ' <user name>\nethood
    CSIDL_FONTS = &H14&     ' windows\fonts
    CSIDL_TEMPLATES = &H15&
    CSIDL_COMMON_STARTMENU = &H16& ' All Users\Start Menu
    CSIDL_COMMON_PROGRAMS = &H17& ' All Users\Start Menu\Programs
    CSIDL_COMMON_STARTUP = &H18& ' All Users\Startup
    CSIDL_COMMON_DESKTOPDIRECTORY = &H19& ' All Users\Desktop
    CSIDL_APPDATA = &H1A& ' <user name>\Application Data
    CSIDL_PRINTHOOD = &H1B& ' <user name>\PrintHood
    CSIDL_LOCAL_APPDATA = &H1C& ' <user name>\Local Settings\Applicaiton Data (non roaming)
    CSIDL_ALTSTARTUP = &H1D& ' non localized startup
    CSIDL_COMMON_ALTSTARTUP = &H1E& ' non localized common startup
    CSIDL_COMMON_FAVORITES = &H1F&
    CSIDL_INTERNET_CACHE = &H20&
    CSIDL_COOKIES = &H21&
    CSIDL_HISTORY = &H22&
    CSIDL_COMMON_APPDATA = &H23& ' All Users\Application Data
    CSIDL_WINDOWS = &H24& ' GetWindowsDirectory()
    CSIDL_SYSTEM = &H25& ' GetSystemDirectory()
    CSIDL_PROGRAM_FILES = &H26& ' C:\Program Files
    CSIDL_MYPICTURES = &H27& ' C:\Program Files\My Pictures
    CSIDL_PROFILE = &H28& ' USERPROFILE
    CSIDL_SYSTEMX86 = &H29& ' x86 system directory on RISC
    CSIDL_PROGRAM_FILESX86 = &H2A& ' x86 C:\Program Files on RISC
    CSIDL_PROGRAM_FILES_COMMON = &H2B& ' C:\Program Files\Common
    CSIDL_PROGRAM_FILES_COMMONX86 = &H2C& ' x86 Program Files\Common on RISC
    CSIDL_COMMON_TEMPLATES = &H2D& ' All Users\Templates
    CSIDL_COMMON_DOCUMENTS = &H2E& ' All Users\Documents
    CSIDL_COMMON_ADMINTOOLS = &H2F& ' All Users\Start Menu\Programs\Administrative Tools
    CSIDL_ADMINTOOLS = &H30& ' <user name>\Start Menu\Programs\Administrative Tools
    CSIDL_CONNECTIONS = &H31& ' Network and Dial-up Connections
    CSIDL_COMMON_MUSIC = &H35& ' All Users\My Music
    CSIDL_COMMON_PICTURES = &H36& ' All Users\My Pictures
    CSIDL_COMMON_VIDEO = &H37& ' All Users\My Video
    CSIDL_RESOURCES = &H38& ' Resource Direcotry
    CSIDL_RESOURCES_LOCALIZED = &H39& ' Localized Resource Direcotry
    CSIDL_COMMON_OEM_LINKS = &H3A& ' Links to All Users OEM specific apps
    CSIDL_CDBURN_AREA = &H3B& ' USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning
    CSIDL_COMPUTERSNEARME = &H3D& ' Computers Near Me (computered from Workgroup membership)
End Enum

Public Function GetSpecialFolder(number As Long) As String
    Dim sPath As String
    Dim RetVal As Long
    Dim hToken As Long

    GetSpecialFolder = ""

    ' Fill our string buffer
    sPath = String(MAX_PATH, 0)
    ' This parameter is usually set to NULL, but you might need to assign a non-NULL value to hToken
    ' for those folders that can have multiple users but are treated as belonging to a single user.
    ' The most commonly used folder of this type is Documents.
    hToken = GetCurrentToken    '
    RetVal = SHGetFolderPath(0, number, hToken, SHGFP_TYPE_CURRENT, sPath)

    Select Case RetVal
        Case S_OK
            ' We retrieved the folder successfully

            ' All C strings are null terminated
            ' So we need to return the string up to the first null character
            sPath = Left(sPath, InStr(1, sPath, Chr(0)) - 1)
            GetSpecialFolder = sPath
        Case S_FALSE
            ' The CSIDL in nFolder is valid, but the folder does not exist.
            ' Use CSIDL_FLAG_CREATE to have it created automatically
            'GetSpecialFolder = "The folder does not exist"
        Case E_INVALIDARG
            ' nFolder is invalid
            'GetSpecialFolder = "An invalid folder ID was specified"
    End Select
End Function

Private Function GetCurrentToken() As Long
    Dim hProcessToken As Long
    
    If Not OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, True, hProcessToken) Then
        Call OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, hProcessToken)
    End If
    GetCurrentToken = hProcessToken
End Function

Attribute VB_Name = "modToolbox"
Option Explicit

Public Function ToolboxServer32(strKlasse As String, Optional boolMsg As Boolean) As Object
    Set ToolboxServer32 = Nothing
    On Error GoTo KeinToolboxServer32
    Set ToolboxServer32 = CreateObject("ToolboxServer32." & strKlasse)
    On Error GoTo 0
     Exit Function
KeinToolboxServer32:
    If Not boolMsg Then
        MsgBox TOOL_ID & "201" & vbCrLf & vbCrLf & "Es konnte keine Verbindung zum ToolboxServer32 hergestellt werden!" & _
        vbCrLf & vbCrLf & "(Fehler " & Err & ")." & Chr(13) & Chr(13) & Chr$(187) & " Bitte f|fffd|hren Sie auf diesem System die Arbeitsplatzinstallation der Toolbox-Umgebung durch.", vbCritical, "Toolboxserver32 nicht gefunden"
    End If
    Set ToolboxServer32 = Nothing
End Function

Public Function GetTbBasisServer(Optional bSilent As Boolean) As Object
    Set GetTbBasisServer = Nothing
    On Error GoTo KeinBasisServer
    Set GetTbBasisServer = CreateObject("DvTbBasisServer.cKonfigDB")
    On Error GoTo 0
    Exit Function
    
KeinBasisServer:
    If Not bSilent Then
        MsgBox TOOL_ID & "202" & vbCrLf & vbCrLf & "Es konnte keine Verbindung zum DvTvBasisServer hergestellt werden!" & _
        vbCrLf & vbCrLf & "(Fehler " & Err & ")." & Chr(13) & Chr(13) & Chr$(187) & " Bitte f|fffd|hren Sie auf diesem System die Arbeitsplatzinstallation der Toolbox-Umgebung durch.", vbCritical, "Toolboxserver32 nicht gefunden"
    End If
    Set GetTbBasisServer = Nothing
End Function
Attribute VB_Name = "modpro"
Option Explicit

Public Const DispIdSetMetaData = 0
Public Const DispIdSetSingleMetaData = 1
Public Const DispIdEinstellungen = 2
Public Const DispIdDrucken = 3
Public Const DispIdStammdaten = 4
Public Const DispIdSetSaveFormat = 5
Public Const DispIdSetSaveFormatXlsm = 9

Public Const SddIdsBrowsingDialog = 0
Public Const SddIdsSchnellzugriffDialog = 1
Public Const SddIdsMandantennummer = 2

Public Const TOOLBOX_BASIS_KOMPID As String = "T0000094"
Public Const TOOLBOX_BASIS_KOMPVERS As String = "1.0"

Public Sub SetDocumentAttributes()
    Dim szPara(1) As String ' ! F|fffd|r die Metadaten muss die L|fffd|nge immer ein Vielfaches von 2 sein
    Dim ws As Worksheet
    Dim l As Long
    Dim lRetVal As Long

    Set ws = ThisWorkbook.Worksheets("Attribute")
    l = 2   ' In der ersten Zeile steht die |fffd|berschrift
    Do While LenB(ws.Cells(l, 1)) <> 0
        If LenB(ws.Cells(l, 2)) <> 0 Then
            ' Von den KAW-Variablen wird nur die Nummer mit f|fffd|hrenden Nullen |fffd|bergeben
            szPara(0) = Replace(ws.Cells(l, 1), "KAW", "")
            szPara(1) = ws.Cells(l, 2)
            lRetVal = Execute(DispIdSetMetaData, szPara, True)
        End If
        l = l + 1
    Loop
    Set ws = Nothing
End Sub

Public Sub SetSaveFormat()
    Dim szPara(0) As String
    Dim lRetVal As Long
    
    lRetVal = -2
    lRetVal = Execute(DispIdSetSaveFormatXlsm, szPara)
End Sub

Public Sub Einstellungen()
    Dim szPara(0) As String

    szPara(0) = ActiveWorkbook.FullName
    
    Application.DisplayAlerts = False
    Call Execute(DispIdEinstellungen, szPara)
    Application.DisplayAlerts = True
End Sub

Public Sub GetStammdaten(ByVal strMandantennr As String)
    Dim szPara(4) As String
    
    szPara(0) = SddIdsMandantennummer
    szPara(1) = ""
    szPara(2) = strMandantennr
    szPara(3) = "Eintragung"
    szPara(4) = "3"
    
    Application.DisplayAlerts = False
    Call ClearStammdatenfelder
    If Execute(DispIdStammdaten, szPara) >= 0 Then
        Call CopyStammdatenfelder
        Call SetDocumentAttributes
    End If
    Application.DisplayAlerts = True
End Sub

Public Sub GetStammdaten2(ByVal strMandantennr As String, ByVal strTyp As String)
    Dim szPara(4) As String
    
    szPara(0) = SddIdsMandantennummer
    szPara(1) = ""
    szPara(2) = strMandantennr
    szPara(3) = "Eintragung"
    szPara(4) = strTyp
    
    Application.DisplayAlerts = False
    Call ClearStammdatenfelder
    If Execute(DispIdStammdaten, szPara) >= 0 Then
        Call CopyStammdatenfelder
        Call SetDocumentAttributes
    End If
    Application.DisplayAlerts = True
End Sub

Public Sub ShowSchnellzugriff()
    Dim szPara(4) As String
    
    szPara(0) = SddIdsSchnellzugriffDialog
    szPara(1) = ""
    szPara(2) = "0"
    szPara(3) = "Eintragung"
    szPara(4) = "3"
    
    Application.DisplayAlerts = False
    Call ClearStammdatenfelder
    If Execute(DispIdStammdaten, szPara) >= 0 Then
        Call CopyStammdatenfelder
        Call SetDocumentAttributes
    End If
    Application.DisplayAlerts = True
End Sub

Public Sub ShowStammdaten()
    Dim szPara(4) As String
    
    szPara(0) = SddIdsBrowsingDialog
    szPara(1) = ""
    szPara(2) = "0"
    szPara(3) = "Eintragung"
    szPara(4) = "3"
    
    Application.DisplayAlerts = False
    Call ClearStammdatenfelder
    If Execute(DispIdStammdaten, szPara) >= 0 Then
        Call CopyStammdatenfelder
        Call SetDocumentAttributes
    End If
    Application.DisplayAlerts = True
End Sub

Public Function Execute(dispId As Integer, params() As String, Optional bSilent = False) As Integer
Dim basisServer As Object
Dim o As Object
Dim extension As Object
Dim strFilename As String
    
    Set o = ProvideGoalExtensionLoader
    If o Is Nothing And Not bSilent Then
        MsgBox TOOL_ID & "203" & vbCrLf & vbCrLf & "Es konnte keine Verbindung zum ToolboxExtension hergestellt werden.", vbCritical, "ToolboxExtension nicht gefunden"
        Execute = -1
        Exit Function
     ElseIf o Is Nothing And bSilent Then
        Execute = -1
        Exit Function
    End If
    Set basisServer = GetTbBasisServer
    If basisServer Is Nothing Then
        Execute = -1
        Exit Function
    End If
    
    strFilename = basisServer.GetProgrammpfad("T0000094", "1.0") + "\Datev.Toolbox.ToolExtension"
    If Not ExistsFile(strFilename & ".dll") Then
       Set extension = Nothing
    Else
       Set extension = o.LoadFile(strFilename, 0)
    End If
    If extension Is Nothing Then
        If Not bSilent Then
            MsgBox TOOL_ID & "701" & vbCrLf & vbCrLf & "Es konnte keine Verbindung zum Office-Plugin hergestellt werden." & _
                Chr(13) & Chr(13) & Chr$(187) & " Installieren Sie die aktuelle Version der Toolbox-Umgebung.", vbCritical, "Office-Plugin nicht gefunden"
        End If
        Execute = -1
        Exit Function
    End If
    Execute = extension.Execute(dispId, params)
End Function

Private Function ProvideGoalExtensionLoader() As Object

    On Error GoTo TryHookConnection
    
    Dim componentProvider As Object
    Dim newCai As COMAddIn
    Set newCai = Application.COMAddIns("HookCairo.Connect")
    
    If newCai.Connect Then
        Set componentProvider = newCai.Object.componentProvider
        If Not componentProvider Is Nothing Then
            Set ProvideGoalExtensionLoader = componentProvider.GetComponentFromName("IGoalExtensionLoader")
            Set componentProvider = Nothing
            Exit Function
        End If
    End If
     
TryHookConnection:
Dim objExtLoader As Object
    If HookConnection(objExtLoader) Then
      Set ProvideGoalExtensionLoader = objExtLoader
    End If
       
ErrProvideGoalExtensionLoader:
    'MsgBox Err.Description
End Function

Function HookConnection(objExtLoader As Object) As Boolean
    
    Dim aCai As COMAddIn                    'Verbindung zum CAI aufbauen
    
    On Error GoTo fehler
    Set aCai = Application.COMAddIns("DATEV.Goal.StartupJob.1")

    Dim extLoader As Object                 'den Loader holen
    Set extLoader = aCai.Object.GetComponentFromName("IGoalExtensionLoader")
    
    Set objExtLoader = extLoader
    HookConnection = True
    Exit Function
    
fehler:
HookConnection = False

End Function
Attribute VB_Name = "modutils"
Option Explicit

Private Const INVALID_FILE_ATTRIBUTES = &HFFFFFFFF
Private Const FILE_ATTRIBUTE_READONLY = &H1
Private Const FILE_ATTRIBUTE_HIDDEN = &H2
Private Const FILE_ATTRIBUTE_SYSTEM = &H4
Private Const FILE_ATTRIBUTE_DIRECTORY = &H10
Private Const FILE_ATTRIBUTE_ARCHIVE = &H20
Private Const FILE_ATTRIBUTE_NORMAL = &H80
Private Const FILE_ATTRIBUTE_TEMPORARY = &H100
Private Const FILE_ATTRIBUTE_COMPRESSED = &H800
Public Const XLFMT_OpenXMLWorkbookMacroEnabled = 52
Private Declare Function CreateDirectory Lib "kernel32" Alias "CreateDirectoryA" (ByVal lpPathName As String, lpSecurityAttributes As SECURITY_ATTRIBUTES) As Long
Private Declare Function GetLastError Lib "kernel32" () As Long
Public Type SECURITY_ATTRIBUTES
    nLength As Long
    lpSecurityDescriptor As Long
    bInheritHandle As Long
End Type
Private Declare Function GetFileAttributes Lib "kernel32" Alias "GetFileAttributesA" (ByVal lpFileName As String) As Long

Public Function IsDatevDmsDokument(szPfad As String)
    Dim sTemp As String
    
    sTemp = LCase(szPfad)
    IsDatevDmsDokument = (sTemp Like "*\datevdms\checkout\*" Or sTemp Like "*\dokorg\checkout\*")
End Function

Public Function Datumkonvert(strDate As String) As Variant
    
    Datumkonvert = ""
    If strDate <> "" Then
        If InStr(strDate, ".") > 0 Then ' Pro-Welt: "01.01.1995 00:00:00"
            Datumkonvert = Left$(strDate, 10)
        Else ' Alte Welt: "19850201"
            Datumkonvert = Right$(strDate, 2) & "." & Mid$(strDate, 5, 2) & "." & Left$(strDate, 4)
        End If
    End If
    
End Function

Public Function Familienstand()
   Dim wkEintragung As Worksheet
   Dim wkFormular As Worksheet
   
   
   Set wkFormular = ActiveWorkbook.Worksheets("Seite 1")
   Set wkEintragung = ActiveWorkbook.Worksheets("Eintragung")
   
   wkFormular.Range("Z_VhDatum").Value = ""
   wkFormular.Range("Z_VwDatum").Value = ""
   wkFormular.Range("Z_GsDatum").Value = ""
   wkFormular.Range("Z_GtDatum").Value = ""

   Select Case wkEintragung.Range("FamStand")
      Case "VH"
         wkFormular.Range("Z_VhDatum").Value = Datumkonvert(wkEintragung.Range("FamStandseit").Value)
      Case "VW"
         wkFormular.Range("Z_VwDatum").Value = Datumkonvert(wkEintragung.Range("FamStandseit").Value)
      Case "GS"
         wkFormular.Range("Z_GsDatum").Value = Datumkonvert(wkEintragung.Range("FamStandseit").Value)
      Case "GT"
         wkFormular.Range("Z_GtDatum").Value = Datumkonvert(wkEintragung.Range("FamStandseit").Value)
   End Select

End Function

Public Sub BlanksFontSize(sName As String, snFontsize As Single)
   Dim i, j As Long

   j = Len(Range(sName).Text)
   For i = 1 To j
      If Range(sName).Characters(i, 1).Text = " " Then
         Range(sName).Characters(i, 1).Font.Size = snFontsize
         Range(sName).Characters(i, 1).Font.Bold = False
      End If
   Next
End Sub

Public Sub BlanksFontSizeShape(sSheet As String, sName As String, snFontsize As Single)
   Dim i, j As Long
   
   j = ThisWorkbook.Worksheets(sSheet).Shapes(sName).TextFrame.Characters.count
   For i = 1 To j
      If ThisWorkbook.Worksheets(sSheet).Shapes(sName).TextFrame.Characters(i, 1).Text = " " Then
         ThisWorkbook.Worksheets(sSheet).Shapes(sName).TextFrame.Characters(i, 1).Font.Size = snFontsize
         ThisWorkbook.Worksheets(sSheet).Shapes(sName).TextFrame.Characters(i, 1).Font.Bold = False
      End If
   Next
      
End Sub

'f|fffd|llt eine einzelne Variable mit der Wertspalte im Eintragungsblatt
Public Sub CopyFeld(strZelle As String)
   Dim wkEintragung As Worksheet
   Dim strQuelle As String
   Dim j As Integer
   Dim s As String
   Dim bFound As Boolean
   
   Set wkEintragung = ActiveWorkbook.Worksheets("Eintragung")
   j = 2
   bFound = False
   While Not IsEmpty(wkEintragung.Cells(j, 1)) And bFound = False
      s = wkEintragung.Cells(j, GCOLUMN_Name).Value
      If s = strZelle Then
         strQuelle = wkEintragung.Cells(j, GCOLUMN_Wert)
         Application.Range(strZelle).Value = strQuelle
         bFound = True
      End If
      j = j + 1
   Wend
End Sub

Public Function Blattschutz_Aufheben(wsBlatt As Worksheet) As Boolean
    Blattschutz_Aufheben = wsBlatt.ProtectContents
    wsBlatt.Unprotect
End Function

Public Sub Blattschutz_Vergeben(wsBlatt As Worksheet)
    If Not wsBlatt.ProtectContents Then
        wsBlatt.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    End If
End Sub

Public Function DoSaveThisFile(bSaveAs As Boolean, Optional bDoAsk As Boolean = False) As Boolean
    Dim oSrv As Object
    Dim lRetVal As Long
    Dim lMandNr As Long
    Dim lBerater As Long
    Dim lMandant As Long
    Dim lJahr As Long
    Dim szName As String
    Dim szPath As String
    Dim szError As String
    Dim vRetVal As Variant
    Dim bEnableEvents As Boolean
    
    DoSaveThisFile = False
    
    If ExistsDir(ThisWorkbook.Path) And Not bSaveAs Then
        On Error Resume Next
        lRetVal = vbYes
        If bDoAsk Then
            lRetVal = MsgBox(TOOL_ID + "18" + vbCrLf + vbCrLf + "|fffd|nderungen in der Datei jetzt speichern?", vbYesNoCancel, TOOLHEADER)
        End If
        If lRetVal = vbYes Then
            bEnableEvents = Application.EnableEvents
            Application.EnableEvents = False
            ThisWorkbook.Save
            If Err.number <> 0 Then
                MsgBox TOOL_ID + "34" + vbCrLf + vbCrLf + _
                    "Beim Speichern ist ein Fehler aufgetreten." + vbCrLf + _
                    "Fehler " + CStr(Err.number) + vbCrLf + Err.Description, _
                    vbExclamation, TOOLHEADER
                DoSaveThisFile = False
            Else
                DoSaveThisFile = True
            End If
            Application.EnableEvents = bEnableEvents
        End If
        Exit Function
    End If
    
    ' Security: bevorzugt sollte ein Pfad im Userdir ausgew|fffd|hlt werden
    
    ' 1. Wenn das Workbook schon einen Pfad hat, dann diesen nehmen
    If LenB(ThisWorkbook.Path) <> 0 Then
        szPath = ThisWorkbook.Path
    Else
    ' 2. Privaten Pfad holen
        szPath = GetUserPath
    End If
    ' Dateiname ohne Extension
    szName = ThisWorkbook.Name
    
    ' Dateiauswahl anzeigen
    vRetVal = Application.GetSaveAsFilename(BackslashDran(szPath) & szName, "Excel-Arbeitsmappe mit Makros (*.xlsm), *.xlsm")
    If vRetVal <> False Then
        ' Prima, dann speichern wir selbst
        If Right(vRetVal, 1) = "." Then vRetVal = Left(vRetVal, Len(vRetVal) - 1)
        Application.EnableEvents = False
        On Error Resume Next
        ThisWorkbook.SaveAs vRetVal, 52             ' = XlFileFormat.xlOpenXMLWorkbookMacroEnabled
        Call SetSaveFormat
        On Error GoTo 0
        ' Workbook ist gespeichert
        DoSaveThisFile = True
        Application.EnableEvents = True
    Else
        DoSaveThisFile = IIf(bSaveAs, True, False)
    End If
    
End Function

Public Function GetUserPath() As String
    Dim szPath As String
    
    GetUserPath = ""
    
    szPath = GetSpecialFolder(CSIDL_MYDOCUMENTS)
    If LenB(szPath) = 0 Then Exit Function
    
    szPath = BackslashDran(szPath) & "DATEV\" & TOOLCOMPID
    If Not CreatePath(szPath) Then Exit Function
    
    GetUserPath = szPath
End Function

Public Function CreatePath(ByVal szPath As String) As Boolean
    Dim aPath() As String
    Dim szSubPath As String
    Dim lCounter As Long
    Dim pSecurityAttrib As SECURITY_ATTRIBUTES
    Dim lOffset As Long

    CreatePath = False

    If LenB(szPath) = 0 Then Exit Function

    ' Security Attributes
    pSecurityAttrib.bInheritHandle = 0
    pSecurityAttrib.nLength = Len(pSecurityAttrib)

    ' Pfad zerlegen
    szPath = RemoveTrailingBackslash(szPath)
    aPath = Split(szPath, "\")
    ' 29.05.2012, tt: Neu ab Version 2.5
    ' Pr|fffd|fen, ob wir nicht zuf|fffd|llig einen Pfad mit UNC-Notation haben...
    If Left$(szPath, 2) = "\\" Then
        ' UNC-Notation
        szSubPath = "\\" + aPath(LBound(aPath) + 2)
        lOffset = 3
    Else
        szSubPath = aPath(LBound(aPath))
        lOffset = 1
    End If

    ' Verzeichnis anlegen
    On Error GoTo ERR_CreatePath
    For lCounter = LBound(aPath) + lOffset To UBound(aPath)
        szSubPath = szSubPath + "\" + aPath(lCounter)
        If Not ExistsDir(szSubPath) Then
            If CreateDirectory(szSubPath, pSecurityAttrib) = 0 Then
                Debug.Print "CreatePath(): Verzeichnis = '" + szPath + "'; Unterverzeichnis = '" + szSubPath + "'; Err=" + CStr(GetLastError)
                GoTo END_CreatePath
            End If
        End If
    Next lCounter

    CreatePath = True

END_CreatePath:
    On Error GoTo 0
    Exit Function

ERR_CreatePath:
    Debug.Print TOOLCOMPID & ".CreatePath(): Path=" & szPath & "; Err=" & Err.number & "; "; Err.Description
    On Error GoTo 0
End Function

Public Function ExistsDir(ByVal szDir As String) As Boolean
    Dim lRetVal As Long
    Dim szTemp As String
    
    ExistsDir = False
    
    szTemp = RemoveTrailingBackslash(szDir)
    lRetVal = GetFileAttributes(szTemp)
    
    If (lRetVal <> INVALID_FILE_ATTRIBUTES) And ((lRetVal And FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY) Then
        ExistsDir = True
    End If
End Function

Public Function RemoveTrailingBackslash(ByVal szPfad As String) As String
    If Right(szPfad, 1) = "\" Then
        RemoveTrailingBackslash = Left(szPfad, Len(szPfad) - 1)
    Else
        RemoveTrailingBackslash = szPfad
    End If
End Function

Public Function ExistsFile(szFile As String) As Boolean
    ExistsFile = False
    If szFile = "" Then Exit Function
    On Error GoTo ErrExistsFile
    If Dir(szFile) <> "" Then ExistsFile = True
    On Error GoTo 0
    Exit Function
ErrExistsFile:
    On Error GoTo 0
End Function

Public Sub ResetLastSaveTime()
    Dim vDate As Variant
    
    ' Excel Bug oder Feature?
    ' Wurde das Workbook neu |fffd|ber ein Template ge|fffd|ffnet, dann ist die Property "Last Save Time"
    ' bereits gesetzt und entspricht der des Templates
    ' --
    ' Die DDMA pr|fffd|ft, ob die BuiltinDocumentProperty "Last Save Time" gesetzt ist
    ' und falls ja, dann tut sie auch nichts...
    ' --
    
    ' Nur aktiv werden, wenn das Workbook noch nicht gespeichert wurde
    If LenB(ThisWorkbook.Path) = 0 And Not ThisWorkbook.ReadOnly Then
        ' Versuch, die Property auszulesen.
        ' Existiert sie nicht, dann kommt ein LFZ 5 und wir m|fffd|ssen nicht aktiv werden.
        On Error Resume Next
        vDate = ThisWorkbook.BuiltinDocumentProperties("Last Save Time")
        If Err.number = 0 Then
            ' Jetzt sollte noch ein g|fffd|ltiges Datum drinstehen (k|fffd|nnte n|fffd|mlich leer sein)
            If IsDate(vDate) Then
                ' Datum ist gesetzt, dann l|fffd|schen wir es hier wieder
                ThisWorkbook.BuiltinDocumentProperties("Last Save Time") = Empty
            End If
        End If
        On Error GoTo 0
    End If
End Sub

Public Function BackslashDran(strPfad As String) As String
    If Right$(strPfad, 1) <> "\" Then
        strPfad = strPfad & "\"
    End If
    BackslashDran = strPfad
End Function

' InQuest injected base64 decoded content
' {-jYZ
' ZrK%j

INQUEST-PP=macro
