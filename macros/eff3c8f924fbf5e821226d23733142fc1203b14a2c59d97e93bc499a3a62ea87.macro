Attribute VB_Name = "Module1"
Sub BBmailTest()

    Dim wksDisplay As Worksheet
    Set wksDisplay = Sheet3
    
    Dim rngSelection As Range
    Set rngSelection = Selection.EntireRow

    Dim wksEmail As Worksheet
    
    Dim intStartDisplayRow_Abs As Integer
    Dim intEndDisplayRow_Abs As Integer
    Dim intDisplayRowCount As Integer
    Dim intEmailRow As Integer
    
    Dim vntMaturity As Variant
    Dim vntTBill As Variant
    Dim vntTNote As Variant
    Dim vntFNMA As Variant
    Dim vntFHLB As Variant
    Dim vntFHLMC As Variant
    Dim vntFarm As Variant
    Dim vntHigh As Variant
    Dim vnt1ML As Variant
    Dim vnt3ML As Variant
    Dim vntFF As Variant
    
    
    
    Dim strLine As String
    Dim intColWidth As Integer
    Dim intRow As Integer
    Const cintBBLineLength = 80
    
    Set wksEmail = ThisWorkbook.Sheets("Email")
    
    intStartDisplayRow_Abs = rngSelection.Row
    intEndDisplayRow_Abs = rngSelection.Cells(rngSelection.Rows.Count, 1).Row

    Application.ScreenUpdating = False
    
For intRow = intStartDisplayRow_Abs To intEndDisplayRow_Abs

  ' get security data
        
        wksDisplay.Select
        
        With wksDisplay
        
        vntMaturity = .Cells(intRow, .Range("MaturitySortHeader").Column)
        vntDiscount = .Cells(intRow, .Range("OfferSortHeader").Column)
        vntTicker = .Cells(intRow, .Range("TickerSortHeader").Column)
        vntEDSF = .Cells(intRow, .Range("EDSFSortHeader").Column)
        vntAmount = .Cells(intRow, .Range("AmountSortHeader").Column)
        
        vntEDSFSpread = .Cells(intRow, .Range("SpreadSortHeader").Column)
        vntDealer = .Cells(intRow, .Range("DealerSortHeader").Column)
       ' vntOIS = .Cells(intRow, .Range("OISHeader").Column)
       ' vntOISSpread = .Cells(intRow, .Range("OISSpreadHeader").Column)
       ' vnt1ML = .Cells(intRow, .Range("OneMLHeader").Column)
       ' vnt3ML = .Cells(intRow, .Range("ThreeMLHeader").Column)
       ' vntFF = .Cells(intRow, .Range("FFHeader").Column)
       
        
        End With
       strLine = ""
      
        strLine = strLine + RightPadToWidth(Format(vntMaturity, "mm/dd/yyyy"), 8) & " | "
      
        strLine = strLine + RightPadToWidth(Format(vntTicker, "0.0"), 5) & " | "
               
        strLine = strLine + LeftPadToWidth(Format(vntEDSFSpread, "0.00"), 5) & " | "
        
        strLine = strLine + LeftPadToWidth(Format(vntDiscount, "0.000"), 5) & " | "
        
        strLine = strLine + LeftPadToWidth(Format(vntAmount, "0,0"), 9) & " | "
        
        strLine = strLine + LeftPadToWidth(Format(vntDealer, "0,0"), 5) & " | "

      '  strLine = strLine + "| "
        
      '  strLine = strLine + LeftPadToWidth(Format(vnt1ML, "0"), 3) & "   "
         
      '  strLine = strLine + LeftPadToWidth(Format(vnt3ML, "0"), 3) & "    "
        
      '  strLine = strLine + RightPadToWidth(Format(vntFF, "0"), 3) & "    "
          
      '  strLine = strLine & BBNewLine(strLine, cintBBLineLength)
            
' write data to email sheet
        
        strLine = strLine & BBNewLine(strLine, cintBBLineLength)
        
        wksEmail.Select
        
        Range("DataTableLabelRowADNs").Offset(2000, 0).Select
        Selection.End(xlUp).Select
        
        ActiveCell.Offset(1, 0).Cells(1, 1).Select
        Selection.Value = strLine
    
    Next intRow
    



End Sub
Sub ClearMailListTest()

Dim rw As Integer

If Sheets("Email").Range("DataTableLabelRowADNs").Offset(2, 0).Value <> "" Then
    
    Sheets("Email").Select
    GetDataSection(Range("DataTableLabelRowADNs"), 2, 0).Select
    ExtendSelectionDown 1
    
    Selection.ClearContents
    
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    Selection.Borders(xlInsideVertical).LineStyle = xlNone
    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
        
End If

Dim actWks As String
actWks = ActiveSheet.Name
 

If actWks = "Email" Then
    Range("DataTableLabelRowADNs").Select
Else
End If

End Sub

Sub BBEmailTest()

    Dim strLine As String
    Dim strText As String
    Dim wksEmail As Worksheet
    Dim WaitTime1 As Variant
    Dim intRow As Integer
    Dim intColWidth As Integer
    
    Dim vntDataLine As Variant
    
    Dim strSalutation As String
    Dim strSubject As String
    
    Const cstrSubjectRangename = "EmailSubjectLineADNs"
    Const cstrSalutationRangename = "EmailSalutationLineADNs"
    
    Const cintBBLineLength = 80
    
    Set wksEmail = ThisWorkbook.Sheets("Email")
    
    Dim rngCopy As Range
    Set rngCopy = Worksheets("Email").Range("DataTableLabelRowADNs")
    Set rngCopy = rngCopy.End(xlDown)
    Set rngCopy = Range(rngCopy, Range("DataTableLabelRowADNs"))
    
    rngCopy.Copy
    
    Application.ScreenUpdating = False
    wksEmail.Select
    
    strSubject = Range(cstrSubjectRangename)
    strSalutation = Range(cstrSalutationRangename)
    
   AppActivate ("2-BLOOMBERG")
    WaitTime1 = Now + TimeValue("0:00:01")
    Application.Wait WaitTime1
    
   SendKeys "MSGE~"
    'SendKeys "{ENTER}"
    
    'WaitTime1 = Now + TimeValue("0:00:03")
   ' Application.Wait WaitTime1
    
    SendKeys "{TAB}"
    SendKeys strSubject
   SendKeys "{TAB}"
   
    'WaitTime1 = Now + TimeValue("0:00:03")
    'Application.Wait WaitTime1
    
    SendKeys ("^(V)")
End Sub

Attribute VB_Name = "Module2"
Option Explicit

Sub UpdateDNs()

    Dim wbkOrig As Workbook
    Dim wksOrig As Worksheet
    
    Dim wbkGrid As Workbook
    
    On Error GoTo ErrorHandler
    
    ' record original location so that we can go back
    
    Set wbkOrig = ThisWorkbook
    Set wksOrig = ThisWorkbook.ActiveSheet
    
    Application.CutCopyMode = True
    
    ' clear existing data
    
    Sheets("data").Select
    Range("a2:N2").Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.ClearContents
    
    ' copy search results file data to data sheet
    
    Set wbkGrid = GetWorkbook(gstrDataFN, gstrDataPath)
    
    If Range("A1").Value = "" Then
        Range("A1").EntireColumn.Delete
    End If
    
    DeleteBlankRowsFromColumn "f:f"   ' f column = dsc/cpn column
    DeleteBlankRowsFromColumn "g:g"   ' g column = yield column
    
    Range("A2:N2").Select
    Range(Selection, Selection.End(xlDown)).Select
    Selection.Copy
    
    wbkOrig.Activate
    Sheets("data").Select
    Range("a2").Select
    ActiveSheet.Paste
    
    ' close the results file
    
    Application.DisplayAlerts = False
    wbkGrid.Close
    Application.DisplayAlerts = True
    
    wbkOrig.Activate
    
    ' format and populate the DN tab data area
    
    Call reset_todatapage
    'Call Smaturity
    
    
    'Call SaveDNWorkbook
    DeleteBBExportFiles
    
    GoToSheet wbkOrig, wksOrig
    
    Sheet3.Range("LastUpdateMessage").Value = "Updated on " & Now
    
    MsgBox "Done!"

    Exit Sub
    
ErrorHandler:

    MsgBox Err.Description & " (" & Err.Number & ")", vbOKOnly, "Oops!"
    GoToSheet wbkOrig, wksOrig
    
End Sub

Sub DeleteBBExportFiles()

    Dim intAnswer As Integer

    On Error Resume Next

'    intAnswer = MsgBox("Remove old grid files?", vbYesNo)
'    If intAnswer = vbYes Then
'        Kill gstrDataPath & Application.PathSeparator & "*.xls"
'    End If
    
    Kill gstrDataPath & Application.PathSeparator & "*.xls"
    
End Sub

Sub SaveDNWorkbook()

    Sheets("UPDATE").Select
    Sheet3.Range("LastUpdateMessage").Value = "Updated on " & Now
    
    Application.DisplayAlerts = False
    Sheet3.Select
    ActiveWorkbook.Protect gstrPassword
    Application.DisplayAlerts = True
    
End Sub

Sub MakeClientCopy()

    ' this routine creates a copy of the workbook and streamlines
    ' the copy to make it appropriate to e-mail to clients
    
    Dim strOrigPath As String
    Dim strOrigFN As String
    Dim strOrigExt As String
    Dim strOrigPathFN As String
    Dim lngPeriodPos As Long
    
    Dim vntNewPathFn As Variant
    Dim strNewPath As String
    Dim strNewFN As String
    Dim lngFNSeparatorPos As Long
    
    Dim wksClientDN As Worksheet
    Dim wks As Worksheet
    
    Dim colHiddenColumns As Collection
    Dim i As Integer
    Dim vnt As Variant
    
    Dim afFilter As AutoFilter
    
    Application.DisplayStatusBar = True
    Application.StatusBar = "Initializing..."
    
    ' get the name for the copy
    
    strOrigPathFN = ThisWorkbook.FullName
    ExplodePathFN strOrigPathFN, strOrigPath, strOrigFN
        
    ' store the last suffix
    
    lngPeriodPos = InStrRev(strOrigFN, ".")
    If lngPeriodPos > 0 Then
        strOrigExt = Right(strOrigFN, Len(strOrigFN) - lngPeriodPos)
        strOrigFN = Left(strOrigFN, lngPeriodPos - 1)
    End If
    
    ' remove any intermediate suffixes (like ".client.0612", for instance)
    
    lngPeriodPos = InStr(1, strOrigFN, ".")
    If lngPeriodPos > 0 Then
        strOrigFN = Left(strOrigFN, lngPeriodPos - 1)
    End If
    
    ' add client and date suffixes and tack the extension back on
    
    vntNewPathFn = strOrigPath & Application.PathSeparator & _
                   strOrigFN & ".client." & Format(Date, "mmdd") & "." & strOrigExt _
                   
    
    vntNewPathFn = Application.GetSaveAsFilename(vntNewPathFn, , , "Name for Client Copy")
    
    If vntNewPathFn = False Then
    
        ' user clicked cancel; we're not going to copy anything
        
        MsgBox "Aborted.", vbOKOnly, "Client Copy"
        Application.StatusBar = False
    
    ElseIf vntNewPathFn = strOrigPathFN Then
        
        MsgBox "You entered the following path and filename for the client copy of the workbook: " & vbCrLf & vbCrLf & vntNewPathFn & vbCrLf & vbCrLf & _
               "This is the same as the path and filename for the main copy of the workbook." & vbCrLf & _
               "The client copy must have a different name.", vbOKOnly, "Error"
        Application.StatusBar = False
    
    Else
        
        ' create the copy
        
        Application.StatusBar = "Making copy of main spreadsheet"
        
        ThisWorkbook.SaveAs vntNewPathFn
        ExplodePathFN CStr(vntNewPathFn), strNewPath, strNewFN
        
        ' convert formulas on the DN tab to values
        
        Application.StatusBar = "Removing background calculations"
        Set wksClientDN = ActiveWorkbook.Sheets("Discount Notes")
        GoToSheet ThisWorkbook, wksClientDN
        
        Range("DataTableTopRow").Select
        Range(Selection, Selection.End(xlDown)).Select
        
        ' show hidden columns and turn off filtering
        
        Set colHiddenColumns = New Collection
        For i = 1 To Selection.Columns.Count
            If Selection.Columns(i).Hidden = True Then
                colHiddenColumns.Add i
                Selection.Columns(i).Hidden = False
            End If
        Next i
        
        Set afFilter = wksClientDN.AutoFilter
        If Not afFilter Is Nothing Then
            afFilter.Range.AutoFilter
        End If
        Set afFilter = Nothing
        
        Selection.Copy
        Selection.Cells(1, 1).Select
        Selection.PasteSpecial xlPasteValues
        Application.Calculate
        
        ' re-hide and re-filter
        
        For i = colHiddenColumns.Count To 1 Step -1
            Selection.Columns(colHiddenColumns(i)).EntireColumn.Delete
        Next i
        
       ' Filter
        
        ' hide the 'Add to Email' button
        
        Dim shp As Shape
        For Each shp In wksClientDN.Shapes
            If shp.Type = msoFormControl Then
                If shp.FormControlType = xlButtonControl Then
                    If InStr(1, UCase(shp.TextFrame.Characters.Text), "EMAIL") > 0 Then
                        shp.Visible = msoFalse
                    End If
                End If
            End If
        Next shp
        
        ' remove the rest of the tabs
        
        Application.StatusBar = "Removing non-client tabs"
        
        Application.DisplayAlerts = False
        ThisWorkbook.Unprotect gstrPassword
        For Each wks In ThisWorkbook.Worksheets
            If wks.Name <> "Discount Notes" Then
                wks.Delete
            End If
        Next wks
        ThisWorkbook.Protect gstrPassword
        Application.DisplayAlerts = True
        
        ' the logo displays at the wrong size until we switch
        ' to another zoom level and back (it's just a weirdness
        ' with the display; the size of the logo really is
        ' correct)
        
        Dim vntZoom As Variant
        
        vntZoom = Application.ActiveWindow.Zoom
        Application.ActiveWindow.Zoom = CInt(vntZoom * 0.75)
        Application.ActiveWindow.Zoom = vntZoom
        
        Application.StatusBar = "Saving client copy"
        ThisWorkbook.Save
        
        ' save and close the copy
                    
        Application.StatusBar = "Save complete"
        MsgBox "Done!", vbOKOnly, "Client Copy"
        Application.StatusBar = False
        
    End If
    
End Sub
Attribute VB_Name = "Module4"
Public Sub ShowAllTabs()
Attribute ShowAllTabs.VB_ProcData.VB_Invoke_Func = "i\n14"
    
    Dim wks As Worksheet
    
    On Error Resume Next
    
    ThisWorkbook.Unprotect gstrPassword
    For Each wks In Worksheets
        wks.Visible = True
    Next wks
    
End Sub

Public Sub HideUpdateTabs()
    ThisWorkbook.Unprotect gstrPassword
    Sheets(Array("edsf", "Update", "edsf by", "libordata", "data")).Visible = False
    ThisWorkbook.Protect gstrPassword
End Sub
Attribute VB_Name = "Module5"
Option Explicit
'Dim blnSort As Boolean
Dim VarUpDown As Boolean

Sub calc()
Calculate
End Sub

Sub autofilterselect()
Attribute autofilterselect.VB_Description = "Macro recorded 5/9/2006 by johnd"
Attribute autofilterselect.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Macro4 Macro
' Macro recorded 5/9/2006 by johnd
'

'
    Range("DataTableLabelRow").EntireRow.Select
    Selection.AutoFilter
    Selection.EntireRow.Hidden = True
    Range("DataTableTopRow").Cells(1, 1).Select
    
End Sub

Sub Filter()
Attribute Filter.VB_Description = "Macro recorded 5/9/2006 by johnd"
Attribute Filter.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Macro7 Macro
' Macro recorded 5/9/2006 by johnd
'

    Range("DataTableLabelRow").Select
    Range(Selection, Selection.End(xlDown)).Select

    Selection.AutoFilter Field:=1, Criteria1:=">0"
    Selection.AutoFilter Field:=4, Criteria1:=">1"
    
    Range("DataTableLabelRow").Select
    Selection.EntireRow.Hidden = True

End Sub

Sub Syield()
Attribute Syield.VB_Description = "Macro recorded 5/9/2006 by johnd"
Attribute Syield.VB_ProcData.VB_Invoke_Func = " \n14"
If VarUpDown = True Then
SortByColumn GetRange(Sheet3, "OfferYieldSortHeader"), xlAscending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = False
ElseIf VarUpDown = False Then
     SortByColumn GetRange(Sheet3, "OfferYieldSortHeader"), xlDescending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = True
End If
Calculate
End Sub

Sub Smaturity()

If VarUpDown = True Then
    SortByColumn GetRange(Sheet3, "MaturitySortHeader"), xlAscending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = False
ElseIf VarUpDown = False Then
     SortByColumn GetRange(Sheet3, "MaturitySortHeader"), xlDescending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = True
End If
Calculate

End Sub

Sub Sedsfspread()
If VarUpDown = True Then
    SortByColumn GetRange(Sheet3, "SpreadSortHeader"), xlAscending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = False
ElseIf VarUpDown = False Then
     SortByColumn GetRange(Sheet3, "SpreadSortHeader"), xlDescending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = True
End If
Calculate
End Sub

Sub Samount()
If VarUpDown = True Then
    SortByColumn GetRange(Sheet3, "AmountSortHeader"), xlAscending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = False
ElseIf VarUpDown = False Then
     SortByColumn GetRange(Sheet3, "AmountSortHeader"), xlDescending, _
         GetRange(Sheet3, "IssuerSortHeader"), xlAscending
    VarUpDown = True
End If
Calculate
End Sub

Sub Sissuer()
If VarUpDown = True Then
    SortByColumn GetRange(Sheet3, "IssuerSortHeader"), xlAscending, _
         GetRange(Sheet3, "MaturitySortHeader"), xlAscending
    VarUpDown = False
ElseIf VarUpDown = False Then
     SortByColumn GetRange(Sheet3, "IssuerSortHeader"), xlDescending, _
         GetRange(Sheet3, "MaturitySortHeader"), xlAscending
    VarUpDown = True
End If
Calculate
End Sub
Sub Sdealer()
If VarUpDown = True Then
    SortByColumn GetRange(Sheet3, "DealerSortHeader"), xlAscending, _
         GetRange(Sheet3, "MaturitySortHeader"), xlAscending
    VarUpDown = False
ElseIf VarUpDown = False Then
     SortByColumn GetRange(Sheet3, "DealerSortHeader"), xlDescending, _
         GetRange(Sheet3, "MaturitySortHeader"), xlAscending
    VarUpDown = True
End If
Calculate
End Sub

Sub SortDataTable(strSortHeaderRangename As String, _
                  XsoOrder As XlSortOrder, _
                  Optional XdoDataOption As XlSortDataOption = xlSortNormal)
    
    Range("DataTableLabelRow").Select
    Range(Selection, Selection.End(xlDown)).Select
    
    Selection.Sort Key1:=Range(strSortHeaderRangename), Order1:=XsoOrder, Header:=xlYes, _
        MatchCase:=False, Orientation:=xlTopToBottom, DataOption1:=XdoDataOption
    
    Call Filter
    
    Range("DataTableTopRow").Cells(1, 1).Select

End Sub


Attribute VB_Name = "Module7"
Sub reset_todatapage()
Attribute reset_todatapage.VB_Description = "Macro recorded 5/12/2006 by johnd"
Attribute reset_todatapage.VB_ProcData.VB_Invoke_Func = " \n14"
'
' reset_todatapage Macro
' Macro recorded 5/12/2006 by johnd
'

    Dim wks As Worksheet
    
    Set wks = Sheet3
    wks.Select
    On Error Resume Next
    wks.ShowAllData
    On Error GoTo 0
    
    Dim strDNMaturityCell As String
    Dim strDNEDSFCell As String
    
    Dim strEDSFLookupTableRange As String
    Dim strLIBORLookupTableRange As String

    
    strDNMaturityCell = Range("MaturitySortHeader").Offset(1, 0).Address(False, False)
    strDNEDSFCell = Range("EDSFSortHeader").Offset(1, 0).Address(False, False)
    
    strEDSFLookupTableRange = "EDSFLookupTable"
    strLIBORLookupTableRange = "LIBORLookupTable"
    
    'Clear Sheet for new input from Data Tab
    
    Sheet3.Range("DataTableLabelRow").Offset(1).Resize(Range("DataTableLabelRow").CurrentRegion.Rows.Count).ClearContents
    
    Range("AmountSortHeader").Offset(1, 0).Select
    ActiveCell.Value = "=Data!" & "A2"
    
    Range("TickerSortHeader").Offset(1, 0).Select
    ActiveCell.Value = "=Data!" & "I2"
    
    Range("IssuerSortHeader").Offset(1, 0).Select
     ActiveCell.Value = "=Data!" & "B2"
    
    Range("DaysToMaturitySortHeader").Offset(1, 0).Select
     ActiveCell.Value = "=Data!" & "J2"
    
    Range("MaturitySortHeader").Offset(1, 0).Select
     ActiveCell.Value = "=today()+F14"
    
    Range("SpreadSortHeader").Offset(1, 0).Select
    ActiveCell.FormulaR1C1 = "=IF(OR(RC[3]=0,RC[3]="""",RC[1]=0,RC[1]=""""),""N/A"",(RC[3]-RC[1])*100)"
    
    Range("EDSFSortHeader").Offset(1, 0).Select
    ActiveCell.Formula = "=IF(VLOOKUP(" & strDNMaturityCell & "," & strEDSFLookupTableRange & ",2,FALSE)=0," & _
                             "VLOOKUP(" & strDNMaturityCell & "," & strLIBORLookupTableRange & ",3,FALSE)," & _
                             "VLOOKUP(" & strDNMaturityCell & "," & strEDSFLookupTableRange & ",2,FALSE))"
    
    Range("OfferSortHeader").Offset(1, 0).Select
    ActiveCell.Value = "=Data!" & "E2"
    
    Range("OfferYieldSortHeader").Offset(1, 0).Select
    ActiveCell.Value = "=Data!" & "F2"
    
    Range("DealerSortHeader").Offset(1, 0).Select
    ActiveCell.Value = "=Data!" & "G2"
    
    Range("RawDaysToMaturitySortHeader").Offset(1, 0).Select
    ActiveCell.FormulaR1C1 = "=IF(ISERROR(RC[-6]-today())=TRUE,-1,RC[-6]-today())"
    
    'copy formulas down to the rest of the table
    
    Dim rng As Range
    
    Set rng = Range("DataTableTopRow")
    rng.Copy
    
    Set rng = rng.Offset(1, 0)
    Set rng = rng.Resize(Sheet2.Range("A1").CurrentRegion.Rows.Count - 2)
    'Range(Selection, Selection.End(xlDown)).Select
    
    rng.Select
    Selection.PasteSpecial xlPasteAll
    
    Calculate
    
End Sub
Attribute VB_Name = "Module8"
Sub DES()

    Dim strText As String
    Dim rw As Long
    
    On Error GoTo ErrorHandler
    
    AppActivate ("1-BLOOMBERG"), 2
    rw = ActiveCell.Row
    
    strText = Cells(rw, Range("TickerSortHeader").Column).Value & " " & _
              Cells(rw, Range("MaturitySortHeader").Column).Value
    SendKeys strText
    SendKeys "{F2}"
    SendKeys ("DES~")
    
    Exit Sub
    
ErrorHandler:

    If Err.Number = 5 Then
        MsgBox "Couldn't open DES page." & vbCrLf & vbCrLf & _
               "Please open Bloomberg if it isn't already running.", _
               vbOKOnly, _
               "Oops"
    Else
        MsgBox "DES failed." & vbCrLf & vbCrLf & _
               Err.Number & " - " & Err.Description, _
               vbOKOnly, _
               "Oops"
    End If

End Sub

Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Public Sub AddDNToEmail()
    AddToEmail Me, ActiveCell
End Sub
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_BeforeClose(Cancel As Boolean)
With Application
        .Calculation = xlAutomatic
        .MaxChange = 0.001
    End With
    ActiveWorkbook.PrecisionAsDisplayed = False
End Sub

Private Sub Workbook_Open()

    With Application
            .Calculation = xlManual
            .MaxChange = 0.001
    End With
    ActiveWorkbook.PrecisionAsDisplayed = False
    
    DeleteBBExportFiles
    Calculate

End Sub


Attribute VB_Name = "modDNMatrix"
Option Explicit

Public Const gstrPassword = "CUCP10119"
Public Const gstrDataFN = "grid1.xls"
Public Const gstrDataPath = "C:\BLP\Data"

Attribute VB_Name = "modEMail"
Option Explicit

' 1.0.0 (7/6/2007)  Initial version.

Function BBNewLine(strLineText As String, _
                   Optional intLineLength As Integer = 80) As String

    ' this routine figures out what character string is needed to move
    ' to the next line in the BB mail text editor;  BB doesn't actually
    ' have new lines; it just pads a line with spaces until the cursor
    ' winds up on the next line; accordingly, what this routine
    ' actually returns is a string of spaces of the appropriate length
    ' given the length of the text string that needs a newline
    
    Dim intTextLength As Integer
    
    If intLineLength = 0 Then
        BBNewLine = ""
        Exit Function
    End If
    
    intTextLength = Len(strLineText)
    If intTextLength > intLineLength Then
        intTextLength = intTextLength - (Int(intTextLength / intLineLength) * intLineLength)
    End If
    
    BBNewLine = String(intLineLength - intTextLength, " ")
    
End Function

Sub Email()

    Dim rng As Range
    Dim rw As Integer
    Dim rngSource As Range
    Dim wbkDest As Workbook
    Dim OutApp As Outlook.Application
    Dim OutMail As Outlook.MailItem
    Dim strHTML As String

    Dim strSubject As String
    Const cstrSubjectRangename = "EmailSubjectLine"
    
    If Sheets("email").Range("DataTableTopRow").Cells(1, 1).Value = "" Then
        GoTo ender:
    Else
        Sheets("email").Select
        strSubject = Range(cstrSubjectRangename)
        GetDataSection(Range("DataTableTopRow"), 0, 0).Select
        ExtendSelectionDown 1
    End If


    Set rngSource = Nothing
    On Error Resume Next
    Set rngSource = Selection.SpecialCells(xlCellTypeVisible)
    On Error GoTo 0
    If rngSource Is Nothing Then
        MsgBox "The selection is not a range or the sheet is protect" & _
               vbNewLine & "please correct and try again.", vbOKOnly
        
    End If

    If ActiveWindow.SelectedSheets.Count > 1 Or _
       Selection.Cells.Count = 1 Or _
       Selection.Areas.Count > 1 Then
        MsgBox "An Error occurred :" & vbNewLine & vbNewLine & _
               "You have more than one sheet selected." & vbNewLine & _
               "You only selected one cell." & vbNewLine & _
               "You selected more than one area." & vbNewLine & vbNewLine & _
               "Please correct and try again.", vbOKOnly
        
    End If

    Application.ScreenUpdating = False
    rngSource.Copy
    Set wbkDest = Workbooks.Add(xlWBATWorksheet)
    With wbkDest.Sheets(1)
        
        On Error Resume Next
        .Cells(1).PasteSpecial Paste:=xlPasteColumnWidths
        ' Paste:=8 will copy the column width in Excel 2000 and higher
        On Error GoTo 0
        
        .Cells(1).PasteSpecial xlPasteValues
        .Cells(1).PasteSpecial xlPasteFormats
        .Cells(1).Select
        Application.CutCopyMode = False
    End With

    strHTML = RangeToHTML
    
    If strHTML <> "" Then
        Set OutApp = CreateObject("Outlook.Application")
        Set OutMail = OutApp.CreateItem(olMailItem)
        With OutMail
            .To = ""
            .CC = ""
            .BCC = ""
            .Subject = strSubject
            '.Text = "The sales credit data is accurate through the previous business day"
            .HTMLBody = RangeToHTML
            .Display
        End With
    
        Set OutMail = Nothing
        Set OutApp = Nothing
    End If
    
    wbkDest.Close False
    Set wbkDest = Nothing

ender:
Range("DataTableTopRow").Cells(1, 1).Select

Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic

End Sub

Sub ClearEmailList()

Dim rw As Integer

If Sheets("email").Range("DataTableTopRow").Cells(1, 1).Value <> "" Then
    
    Sheets("email").Select
    GetDataSection(Range("DataTableTopRow"), 1, 0).Select
    ExtendSelectionDown 1
    
    Selection.ClearContents
    
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    Selection.Borders(xlInsideVertical).LineStyle = xlNone
    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
        
End If

Range("DataTableTopRow").Cells(1, 1).Select

End Sub

Attribute VB_Name = "modEmail_DNMatrix"
Option Explicit

' 1.0.0 (7/6/2007)  Initial version.

Sub AddToEmail(wksDisplay As Worksheet, rngSelectedCell As Range)
    
    Dim wksEmail As Worksheet
    
    Dim intDisplayRow_Abs As Integer
    Dim intEmailRow As Integer
    
    Dim vntAmount As Variant
    Dim vntTicker As Variant
    Dim vntIssuer As Variant
    Dim vntMaturity As Variant
    Dim vntSpread As Variant
    Dim vntEDSF As Variant
    Dim vntOffer As Variant
    Dim vntOfferYield As Variant
    Dim vntDealer As Variant

    Set wksEmail = ThisWorkbook.Sheets("Email")
    
    intDisplayRow_Abs = rngSelectedCell.Row
    
    If intDisplayRow_Abs < Range("DataTableTopRow").Row Then
        MsgBox "No CUSIP selected.", vbOKOnly, "Add to Email"
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    
    With wksDisplay
    
        vntAmount = .Cells(intDisplayRow_Abs, .Range("AmountSortHeader").Column)
        vntTicker = .Cells(intDisplayRow_Abs, .Range("TickerSortHeader").Column)
        vntIssuer = .Cells(intDisplayRow_Abs, .Range("IssuerSortHeader").Column)
        vntMaturity = .Cells(intDisplayRow_Abs, .Range("MaturitySortHeader").Column)
        vntSpread = .Cells(intDisplayRow_Abs, .Range("SpreadSortHeader").Column)
        vntEDSF = .Cells(intDisplayRow_Abs, .Range("EDSFSortHeader").Column)
        vntOffer = .Cells(intDisplayRow_Abs, .Range("OfferSortHeader").Column)
        vntOfferYield = .Cells(intDisplayRow_Abs, .Range("OfferYieldSortHeader").Column)
        vntDealer = .Cells(intDisplayRow_Abs, .Range("DealerSortHeader").Column)
    
    End With
    
    wksEmail.Select
    Range("a2000").Select
    Selection.End(xlUp).Select
    ActiveCell.Offset(1, 0).Select
    
    intEmailRow = ActiveCell.Row - Range("DataTableLabelRow").Row
    
    With wksEmail
        
        Dim rngDataTableRow As Range
        Dim intStartCol As Integer
        Dim vntArray() As Variant
        
        Set rngDataTableRow = .Range("DataTableTopRow") _
                              .Offset(intEmailRow - 1, 0)
                              
        ReDim vntArray(1 To 1, 1 To rngDataTableRow.Columns.Count) As Variant
        intStartCol = rngDataTableRow.Column
        
        vntArray(1, Range("AmountHeader").Column - intStartCol + 1) = vntAmount
        vntArray(1, Range("TickerHeader").Column - intStartCol + 1) = vntTicker
        vntArray(1, Range("IssuerHeader").Column - intStartCol + 1) = vntIssuer
        vntArray(1, Range("MaturityHeader").Column - intStartCol + 1) = vntMaturity
        vntArray(1, Range("SpreadHeader").Column - intStartCol + 1) = vntSpread
        vntArray(1, Range("EDSFHeader").Column - intStartCol + 1) = vntEDSF
        vntArray(1, Range("OfferHeader").Column - intStartCol + 1) = vntOffer
        vntArray(1, Range("OfferYieldHeader").Column - intStartCol + 1) = vntOfferYield
        vntArray(1, Range("DealerHeader").Column - intStartCol + 1) = vntDealer
        
        rngDataTableRow = vntArray
    
    End With
    
    GoToSheet ThisWorkbook, wksDisplay
    
    Application.ScreenUpdating = True
    Application.StatusBar = "Added to email:  Amount " & vntAmount & "   Ticker " & vntTicker & "   Maturity " & vntMaturity

End Sub

Sub BBEmail()

    Dim strLine As String
    Dim strText As String
    Dim wksEmail As Worksheet
    Dim WaitTime1 As Variant
    Dim rw As Integer
    Dim intColWidth As Integer
    
    Dim vntAmount As Variant
    Dim vntTicker As Variant
    Dim vntIssuer As Variant
    Dim vntMaturity As Variant
    Dim vntSpread As Variant
    Dim vntEDSF As Variant
    Dim vntOffer As Variant
    Dim vntOfferYield As Variant
    Dim vntDealer As Variant
    
    Dim strSubject As String
    Dim strSalutation As String
    Dim strHeaderLine1 As String
    Dim strHeaderLine2 As String
    
    Const cstrSubjectRangename = "EmailSubjectLine"
    Const cstrSalutationRangename = "EmailSalutationLine"
    
    Const cintBBLineLength = 80
    
    'MsgBox "This function will copy the data from the table into " & vbCrLf & _
    '       "the body of an e-mail, but you will most likely need " & vbCrLf & _
    '       "to edit the spacing.  Give the routine 10 seconds " & vbCrLf & _
    '       "to run.  If there is no message in the body of your" & vbCrLf & _
    '       "email, the macro hasn't run correctly.  Please try again."
    
    Set wksEmail = ThisWorkbook.Sheets("Email")
    Application.ScreenUpdating = False
    wksEmail.Select
    
    strSubject = Range(cstrSubjectRangename)
    strSalutation = Range(cstrSalutationRangename)
    
    strHeaderLine1 = _
        "Amount   |Ticker|Issuer          |Maturity|Spread |EDSF  |Offer |Yield |Dealer"
        '12345678901234567890123456789012345678901234567890123456789012345678901234567890
    strHeaderLine2 = _
        "         |      |                |        |To EDSF|      |      |      |"
    
    AppActivate ("2-BLOOMBERG"), 2
    SendKeys "{ESC}"
    SendKeys "MSGE~"
    
    WaitTime1 = Now + TimeValue("0:00:03")
    Application.Wait WaitTime1
    
    SendKeys "{TAB}"
    SendKeys strSubject
    SendKeys "{TAB}"
    
    WaitTime1 = Now + TimeValue("0:00:01")
    Application.Wait WaitTime1
    
    strLine = strSalutation
    strLine = strLine & BBNewLine(strLine, cintBBLineLength)
    SendKeys strLine
    WaitTime1 = Now + TimeValue("0:00:01")
    Application.Wait WaitTime1
    
    strLine = strHeaderLine1
    strLine = strLine & BBNewLine(strLine, cintBBLineLength)
    SendKeys strLine
    
    strLine = strHeaderLine2
    strLine = strLine & BBNewLine(strLine, cintBBLineLength)
    SendKeys strLine
    
    Dim intEmailRow As Integer
    
    Range("DataTableTopRow").Cells(1, 1).Select
    
    Do While ActiveCell <> ""
    
        intEmailRow = ActiveCell.Row - Range("DataTableTopRow").Cells(1, 1).Row + 1
        
        With wksEmail
            vntAmount = .Range("AmountHeader").Offset(intEmailRow)
            vntTicker = .Range("TickerHeader").Offset(intEmailRow)
            vntIssuer = .Range("IssuerHeader").Offset(intEmailRow)
            vntMaturity = .Range("MaturityHeader").Offset(intEmailRow)
            vntSpread = .Range("SpreadHeader").Offset(intEmailRow)
            vntEDSF = .Range("EDSFHeader").Offset(intEmailRow)
            vntOffer = .Range("OfferHeader").Offset(intEmailRow)
            vntOfferYield = .Range("OfferYieldHeader").Offset(intEmailRow)
            vntDealer = .Range("DealerHeader").Offset(intEmailRow)
        End With

        strLine = IIf(IsNumeric(vntAmount) = True, _
                      RightPadToWidth(Round(vntAmount, 0) / 1000 & "mm", 9), _
                      RightPadToWidth(CStr(vntAmount), 9)) & "|"
        
        strLine = strLine + RightPadToWidth(CStr(vntTicker), 6) & "|"
        strLine = strLine + RightPadToWidth(CStr(vntIssuer), 16) & "|"
        strLine = strLine + RightPadToWidth(Format(vntMaturity, "MM/DD/YY"), 8) & "|"
        
        strLine = strLine + IIf(IsNumeric(vntSpread) = True, _
                                RightPadToWidth(Round(vntSpread, 1), 7), _
                                RightPadToWidth(CStr(vntSpread), 7)) & "|"

        strLine = strLine + IIf(IsNumeric(vntEDSF) = True, _
                                RightPadToWidth(Round(vntEDSF, 2), 6), _
                                RightPadToWidth(CStr(vntEDSF), 6)) & "|"

        strLine = strLine + IIf(IsNumeric(vntOffer) = True, _
                                RightPadToWidth(Round(vntOffer, 2), 6), _
                                RightPadToWidth(CStr(vntOffer), 6)) & "|"

        strLine = strLine + IIf(IsNumeric(vntOfferYield) = True, _
                                RightPadToWidth(Round(vntOfferYield, 2), 6), _
                                RightPadToWidth(CStr(vntOfferYield), 6)) & "|"

        strLine = strLine + RightPadToWidth(Left(CStr(vntDealer), 6), 6) & " "
        
        strLine = strLine + BBNewLine(strLine, cintBBLineLength)
        
        SendKeys strLine
        
        ActiveCell.Offset(1, 0).Select

    Loop
    
End Sub
Attribute VB_Name = "modUtilities"
Option Explicit

' 1.0.5 (8/27/2007) Added 'ExplodePathFN' function.

' 1.0.4 (7/6/2007)  Added 'ExtendSelectionDown' function, which was
'                   previously located in the email-related modules.
'                   Also added 'GetWorkbook' function and the
'                   'DeleteBlankRowsFromColumn' and 'DeleteBlankColumnsFromRow'
'                   subroutines.

' 1.0.3 (6/25/2007) Added separate error codes for fatal portfolio update
'                   errors and fatal record update errors.  Added variable
'                   standard overflow error code.

' 1.0.1 (6/18/2007) Removed protection-handling code from the SortByColumn
'                   routine.  Corrected some of the error message text
'                   for that function.  Added new SheetHasRangename function.
'                   Added constants for a few standard VB error codes.

' 1.0.0 (6/15/2007) Initial Version

' this module contains a set of general utility routines

' this module is meant to contain only functions and data generic enough
' to be used in any workbook without modification

Public Const mclngInvalidProcedureCallErrIdx = 5&
Public Const mclngOverflowErrIdx = 6&
Public Const mclngSubscriptOutOfRangeErrIdx = 9&
Public Const mclngTypeMismatchErrIdx = 13&
Public Const mclngKeyAlreadyUsedErrIdx = 457&
Public Const mclngNoMethodCallFailedErrIdx = 1004&

Public Const mclngGenericErrIdx = 1004&
Public Const mclngWorksheetNotFoundErrIdx = 1050&
Public Const mclngMissingDataErrIdx = 1051&
Public Const mclngBadDataErrIdx = 1052&

Public Function GetRange(wksWithRange As Worksheet, _
                         strRangename As String) As Range
                         
    ' returns a range object for the specified range name;
    
    Dim wksOrig As Worksheet
    Dim blnWksNotSame As Boolean
    
    On Error GoTo ErrorHandler
    
    ' change to sheet containing range, if we're not already there
    
    Set wksOrig = ThisWorkbook.ActiveSheet
    blnWksNotSame = IIf(wksOrig.Name <> wksWithRange.Name, True, False)
    
    If blnWksNotSame Then
        GoToSheet ThisWorkbook, wksWithRange
    End If
    
    ' get the range
    
    Set GetRange = wksWithRange.Range(strRangename)
    
    ' change back to original sheet, if we moved away from it
    
    If blnWksNotSame Then
        GoToSheet ThisWorkbook, wksOrig
    End If
    
    Exit Function
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrSource As String
    Dim strErrDesc As String
    
    lngErrNum = Err.Number
    strErrSource = IIf(Err.Source = "", "modUtilities!GetRange", Err.Source)
    strErrDesc = "Couldn't get range '" & strRangename & "' on worksheet '" & wksWithRange.Name & "'."
    
    Err.Clear
    Err.Raise lngErrNum, strErrSource, strErrDesc

End Function

Public Function GetWorksheet(wbk As Workbook, strName As String) As Worksheet
    
    ' returns the first worksheet with a name that matches the requested
    ' name; returns a 'nothing' worksheet if the name isn't found
    
    Dim wks As Worksheet
    Dim wksFound As Worksheet
    
    On Error GoTo ErrorHandler
    
    For Each wks In wbk.Worksheets
        If wks.Name = strName Then
            Set wksFound = wks
            Exit For
        End If
    Next wks
    
    Set GetWorksheet = wksFound

    Exit Function
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrSource As String
    Dim strErrDesc As String
    
    lngErrNum = Err.Number
    strErrSource = IIf(Err.Source = "", "modUtilities!GetWorksheet", Err.Source)
    strErrDesc = "Couldn't get worksheet '" & wks.Name & "'."
    
    Err.Clear
    Err.Raise lngErrNum, strErrSource, strErrDesc

End Function

Public Function CheckColumnHeader(wbk As Workbook, _
                                  wks As Worksheet, _
                                  intColumn As Integer, _
                                  strExpectedHeader As String) As Boolean

    ' returns true if the column header for the specified
    ' column matches the specified value; false otherwise
    
    Dim rng As Range
    
    GoToSheet wbk, wks
    wks.Activate
    Set rng = wks.Range(1, intColumn)
    CheckColumnHeader = IIf(rng.Value = strExpectedHeader, True, False)

End Function

Public Function GetDataSection(rngTablePoint As Range, intHeaderRows, intHeaderColumns) As Range

    ' returns a range containing the data section (i.e. everything
    ' but the header row(s) and column(s)) of the table
    ' that the range (or cell) in rngTablePoint is a part of
    
    Dim rng As Range
    Dim intRows As Integer
    Dim intColumns As Integer
    
    On Error GoTo ErrorHandler
    
    rngTablePoint.CurrentRegion.Select
    intRows = Selection.Rows.Count
    intColumns = Selection.Columns.Count
    
    Set rng = Selection
    Set rng = rng.Offset(intHeaderRows, intHeaderColumns)
    If intRows - intHeaderRows >= 1 And intColumns - intHeaderColumns >= 1 Then
        Set rng = rng.Resize(intRows - intHeaderRows, intColumns - intHeaderColumns)
        rng.Select
    Else
        Set rng = Nothing
    End If
    
    Set GetDataSection = rng
    
    Exit Function
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrSource As String
    Dim strErrDesc As String
    
    lngErrNum = Err.Number
    strErrSource = IIf(Err.Source = "", "modUtilities!GetDataSection", Err.Source)
    strErrDesc = "Couldn't get data section for table at " & rngTablePoint.Address
    
    Err.Clear
    Err.Raise lngErrNum, strErrSource, strErrDesc


End Function

Public Function GetDataSectionColumn(rngTablePoint As Range, _
                                     intHeaderRows, _
                                     intHeaderColumns) As Range
    
    ' returns a range reference to the column of data the requested range
    ' is a part of; returns 'nothing' if there is an error
        
    Dim rngData As Range
    Dim strPos As String
    Dim intRows As Integer
    Dim intCol As Integer
    
    ' get the data section that the requested range is a part of; the data section
    ' will give us the upper and lower boundaries of the column we're looking for
    
    Set rngData = GetDataSection(rngTablePoint, 1, 0)
    intRows = rngData.Rows.Count
    
    ' find out what column the requested range is in within the data section
    
    strPos = rngTablePoint.Address(False, False, xlR1C1, False, rngData.Cells(1, 1))
    intCol = R1C1Column(strPos)
    
    ' resize the data section to include just the requested column
    
    If intCol > 0 Then
        Set rngData = rngData.Cells(1, intCol)
        Set rngData = rngData.Resize(intRows, 1)
    Else
        Set rngData = Nothing
    End If
    
    ' return the result
    
    Set GetDataSectionColumn = rngData
    
End Function
        
Public Function R1C1Row(strR1C1Address As String) As Integer

    ' returns the row number from an R1C1-style address; returns
    ' 0 if it encounters an error

    Dim intRPos As Integer
    Dim intCPos As Integer
    Dim strR As String
        
    intRPos = InStr(1, strR1C1Address, "R")
    If intRPos < 1 Then
        R1C1Row = 0
    Else
        intCPos = InStr(intRPos + 1, strR1C1Address)
        strR = Mid(strR1C1Address, intRPos, IIf(intCPos < intRPos + 1, Len(strR1C1Address) - intRPos - 1, intCPos - 1))
        
        If Len(strR) = 1 Or Left(strR, 2) <> "R[" Then
            R1C1Row = 1
        Else
            R1C1Row = CInt(Mid(strR, 3, Len(strR) - 2 - IIf(Right(strR, 1) = "]", 1, 0))) + 1
        End If
    End If

End Function

Public Function R1C1Column(strR1C1Address As String) As Integer

    ' returns the column number from an R1C1-style address; returns
    ' 0 if it encounters an error

    Dim intCPos As Integer
    Dim strC As String
        
    intCPos = InStr(1, strR1C1Address, "C")
    If intCPos < 1 Then
        R1C1Column = 0
    Else
        strC = Mid(strR1C1Address, intCPos, Len(strR1C1Address))
        If Len(strC) = 1 Or Left(strC, 2) <> "C[" Then
            R1C1Column = 1
        Else
            R1C1Column = CInt(Mid(strC, 3, Len(strC) - 2 - IIf(Right(strC, 1) = "]", 1, 0))) + 1
        End If
    End If

End Function

Public Sub GoToSheet(wbk As Workbook, wks As Worksheet)

    On Error GoTo ErrorHandler
    
    wbk.Activate
    wks.Activate
    If wks.Visible = True Then
        wks.Select
    End If
    
    Exit Sub
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrSource As String
    Dim strErrDesc As String
    
    lngErrNum = Err.Number
    strErrSource = IIf(Err.Source = "", "modUtilities!GoToSheet", Err.Source)
    strErrDesc = "Couldn't move to worksheet '" & wks.Name & "'."
    
    Err.Clear
    Err.Raise lngErrNum, strErrSource, strErrDesc

End Sub

Public Sub SetAlternateRowShading(rngTable As Range, lngShade As XlColorIndex)

    ' applies background shading to every other row within the
    ' specified table
    
    Dim intRows As Integer
    Dim rng As Range
    Dim i As Integer

    intRows = rngTable.Rows.Count
    Set rng = rngTable.Resize(1)
        
    For i = 1 To rngTable.Rows.Count
        With rng.Interior
            If i Mod 2 = 0 Then
                .ColorIndex = lngShade
                .Pattern = xlSolid
            Else
                .ColorIndex = xlNone
            End If
            Set rng = rng.Offset(1)
        End With
    Next i

End Sub

Public Function WorksheetName(rng As Range) As String

    WorksheetName = rng.Worksheet.Name
    
End Function

Public Function GetCustomProperty(wks As Worksheet, strName As String) As CustomProperty
    
    Dim cp As CustomProperty
    Dim cpFound As CustomProperty
    
    On Error GoTo ErrorHandler
    
    For Each cp In wks.CustomProperties
        If cp.Name = strName Then
            Set cpFound = cp
            Exit For
        End If
    Next cp

    ' if the sheet has more than one custom property with the same name
    ' (assuming that's even possible) this function will ignore all but
    ' the first
    
    ' if there are no matches, this function returns 'nothing'
    
    Set GetCustomProperty = cpFound

    Exit Function
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrSource As String
    Dim strErrDesc As String
    
    lngErrNum = Err.Number
    strErrSource = IIf(Err.Source = "", "modUtilities!GetCustomProperty", Err.Source)
    strErrDesc = "Error while getting custom property '" & strName & "' for worksheet '" & wks.Name & "'"
    
    Err.Clear
    Err.Raise lngErrNum, strErrSource, strErrDesc

    
End Function

Public Sub ListAllCustomProperties()
    
    Dim wks As Worksheet
    Dim cp As CustomProperty
    Dim str As String
    
    For Each wks In ThisWorkbook.Worksheets
    
        For Each cp In wks.CustomProperties
    
            str = str & wks.Name & ": " & cp.Name & ", " & cp.Value & vbCrLf
    
        Next cp
        
    Next wks
    
    MsgBox str, vbOKOnly, "Custom Properties"
    
End Sub

Public Function GetArrayRowCount(vntArray As Variant) As Long

    GetArrayRowCount = UBound(vntArray) - LBound(vntArray) + 1
    
End Function

Public Function GetDimCount(vntArray As Variant) As Integer

    ' this function determines the number of dimensions in an
    ' array; it returns 0 if the variable is not an array
    
    Dim intUBound As Integer
    Dim intDim As Integer
    Dim blnGotValidDim As Boolean
            
    On Error GoTo ErrorHandler
    
    If VarType(vntArray) < vbArray Then
        GetDimCount = 0
    Else
        
        intDim = 1
        blnGotValidDim = True
        
        intUBound = UBound(vntArray, intDim)
        Do While blnGotValidDim = True
            intDim = intDim + 1
            intUBound = UBound(vntArray, intDim)
        Loop
        
        GetDimCount = intDim - 1
    
    End If
    
    Exit Function

ErrorHandler:

    If Err.Number = mclngSubscriptOutOfRangeErrIdx Then
    
        blnGotValidDim = False
        Err.Clear
        Resume Next
    
    Else
        
        Dim lngErrNum As Long
        Dim strErrSource As String
        Dim strErrDesc As String
        
        lngErrNum = Err.Number
        strErrSource = IIf(Err.Source = "", "modUtilities!GetDimCount", Err.Source)
        strErrDesc = Err.Description
        
        Err.Clear
        Err.Raise lngErrNum, strErrSource, strErrDesc
    
    End If
    
End Function

Public Function DaysInMonth(dtDate As Date) As Integer

    Dim dtBOMDate As Date
    Dim dtEOMDate As Date
    
    dtBOMDate = DateSerial(Year(dtDate), Month(dtDate), 1)
    dtEOMDate = DateSerial(Year(dtDate), Month(dtDate) + 1, 1 - 1)

    DaysInMonth = DateDiff("d", dtBOMDate, dtEOMDate)

End Function

Public Function MinVal(vnt1, vnt2) As Variant
    MinVal = IIf(vnt1 < vnt2, vnt1, vnt2)
End Function

Public Function SheetHasRangename(wksToCheck As Worksheet, strRangename As String) As Boolean
    
    Dim blnFound As Boolean
    Dim i As Integer
    
    blnFound = False
    
    For i = 1 To wksToCheck.Names.Count
        If wksToCheck.Names(i).Name = strRangename Then
            blnFound = True
        End If
    Next i
    
    SheetHasRangename = blnFound
    
End Function

Sub ExtendSelectionDown(intRowsToExtend As Integer)
    
    Dim rng As Range
    
    Set rng = Selection
    Set rng = rng.Resize(rng.Rows.Count + intRowsToExtend)
    rng.Select

End Sub

Function LeftPadToWidth(str As String, intWidth As Integer) As String

    Dim intPadWidth As Integer
    
    intPadWidth = intWidth - Len(str)
    If intPadWidth < 1 Then
        LeftPadToWidth = str
    Else
        LeftPadToWidth = String(intPadWidth, " ") & str
    End If

End Function

Function RightPadToWidth(str As String, intWidth As Integer) As String

    Dim intPadWidth As Integer
    
    intPadWidth = intWidth - Len(str)
    If intPadWidth < 1 Then
        RightPadToWidth = str
    Else
        RightPadToWidth = str & String(intPadWidth, " ")
    End If

End Function

Function GetExcelMajorVersion()

    Dim strExcelVersion As String
    Dim intSepPosition As Integer
    Dim intMajorVersion As Integer
    
    strExcelVersion = Application.Version
    intSepPosition = InStr(1, strExcelVersion, ".")
    If intSepPosition > 0 Then
        intMajorVersion = Left(strExcelVersion, intSepPosition - 1)
    ElseIf IsNumeric(strExcelVersion) Then
        intMajorVersion = strExcelVersion
    End If
    
    GetExcelMajorVersion = intMajorVersion
    
End Function

Public Function RangeToHTML() As String

    ' Note: function uses features not available in Excel 97
    
    Dim fso As Object
    Dim ts As Object
    Dim TempFile As String
    
    If GetExcelMajorVersion < 9 Then     ' excel 97 was version 8
        MsgBox "Can't convert spreadsheet range to HTML." & vbCrLf & _
               "This feature requires Excel 2000 or later.", vbOK
        RangeToHTML = ""
        Exit Function
    End If
    
    TempFile = Environ$("temp") & "/" & Format(Now, "dd-mm-yy h-mm-ss") & ".htm"
    
    With ActiveWorkbook.PublishObjects.Add( _
         SourceType:=xlSourceRange, _
         Filename:=TempFile, _
         Sheet:=ActiveSheet.Name, _
         Source:=ActiveSheet.UsedRange.Address, _
         HtmlType:=xlHtmlStatic)
         
        .Publish (True)
    
    End With
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set ts = fso.GetFile(TempFile).OpenAsTextStream(1, -2)
    
    RangeToHTML = ts.ReadAll
    
    ts.Close
    Set ts = Nothing
    Set fso = Nothing
    
    Kill TempFile
    
End Function

Public Function GetWorkbook(strFN As String, strPath As String) As Workbook

    ' this function finds the requested workbook, looking first among the open
    ' workbooks and then out on the drive; if it finds the workbook, it gives
    ' it the focus and also returns a workbook object which points to it

    Dim wbk As Workbook
    
    On Error GoTo ErrorHandler
    
    ' if the workbook is already open, find it
    
    On Error Resume Next
    Set wbk = Workbooks.Item(strFN)
    On Error GoTo ErrorHandler
        
    ' if it isn't, open it
    
    If wbk Is Nothing Then
        Workbooks.Open Filename:=strPath & Application.PathSeparator & strFN
        Set wbk = Application.ActiveWorkbook
        Application.CutCopyMode = True
    Else
        wbk.Activate
    End If
    
    Set GetWorkbook = wbk
    
    Exit Function
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrDesc As String
    Dim strErrSource As String
    
    If Err.Number = mclngNoMethodCallFailedErrIdx Then
        lngErrNum = Err.Number
        Err.Raise lngErrNum, _
                  "GetWorkbook", _
                  "Couldn't open workbook '" & strPath & Application.PathSeparator & strFN & "'."
    Else
        lngErrNum = Err.Number
        strErrSource = Err.Source
        strErrDesc = Err.Description
        
        Err.Raise lngErrNum, strErrSource, strErrDesc
    End If

End Function

Sub DeleteBlankRowsFromColumn(strAddressOfColumnWithBlanks As String)
    
    Dim rng As Range, rngBlank As Range
    
    Set rng = ActiveSheet.Range(strAddressOfColumnWithBlanks)
    rng.Select
   
    'get blank cells from rng
    On Error Resume Next
    Set rngBlank = rng.SpecialCells(xlCellTypeBlanks)
    rngBlank.Select
    On Error GoTo 0
    
    If Not rngBlank Is Nothing Then
        rngBlank.EntireRow.Delete
    End If

End Sub

Sub DeleteBlankColumnsFromRow(strAddressOfRowWithBlanks As String)
    
    Dim rng As Range, rngBlank As Range
    
    Set rng = ActiveSheet.Range(strAddressOfRowWithBlanks)
    rng.Select
   
    'get blank cells from rng
    On Error Resume Next
    Set rngBlank = rng.SpecialCells(xlCellTypeBlanks)
    rngBlank.Select
    On Error GoTo 0
    
    If Not rngBlank Is Nothing Then
        rngBlank.EntireColumn.Delete
    End If

End Sub

Public Sub ExplodePathFN(strPathFN As String, _
                         strPath_Return As String, _
                         strFN_Return As String)
            
    Dim lngFNSeparatorPos As Long
    
    lngFNSeparatorPos = InStrRev(strPathFN, Application.PathSeparator)
        
    If lngFNSeparatorPos > 0 Then
            strFN_Return = Right(strPathFN, Len(strPathFN) - lngFNSeparatorPos)
            strPath_Return = Left(strPathFN, lngFNSeparatorPos - 1)
    Else
        strFN_Return = ""
        strPath_Return = strPathFN
    End If

End Sub


Public Sub SortByColumn(rngColumnHeader1 As Range, _
                        sortOrder1 As XlSortOrder, _
                        Optional rngColumnHeader2 As Range, _
                        Optional sortOrder2 As XlSortOrder = xlAscending)
    
    ' sorts by the specified column; subroutine assumes that the
    ' applicable workbook and worksheet have already been selected
    
    Dim rng As Range
    Dim wks As Worksheet
    
   On Error GoTo ErrorHandler
    
    Set wks = ThisWorkbook.ActiveSheet
   ' OverrideSheetProtection wks, ProtectionPassword
    
    rngColumnHeader1.Select
    If rngColumnHeader2 Is Nothing Then
        Selection.Sort Key1:=rngColumnHeader1, _
                       Order1:=sortOrder1, _
                       Header:=xlYes, _
                       OrderCustom:=1, _
                       MatchCase:=False, _
                       Orientation:=xlTopToBottom
    Else
        Selection.Sort Key1:=rngColumnHeader1, _
                       Order1:=sortOrder1, _
                       Key2:=rngColumnHeader2, _
                       Order2:=sortOrder2, _
                       Header:=xlYes, _
                       OrderCustom:=1, _
                       MatchCase:=False, _
                       Orientation:=xlTopToBottom
    End If
    
    rngColumnHeader1.Select
    
    'RestoreSheetProtection wks
    
    Exit Sub
    
ErrorHandler:

    Dim lngErrNum As Long
    Dim strErrSource As String
    Dim strErrDesc As String
    
    lngErrNum = Err.Number
    strErrSource = IIf(Err.Source = "", "SortByColumn", Err.Source)
    strErrDesc = "Could not sort the data." & _
                 IIf(Err.Description <> "", vbCrLf & Err.Description, "")
    
    Err.Clear
   ''' Err.Raise lngErrNum, strErrSource, strErrDesc

End Sub



' InQuest injected base64 decoded content
' ejy,

INQUEST-PP=macro
