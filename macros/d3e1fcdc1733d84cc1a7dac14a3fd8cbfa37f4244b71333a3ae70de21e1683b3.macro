Attribute VB_Name = "Foglio1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio21"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Foglio46"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "cmdGO, 1, 0, MSForms, CommandButton"
Option Explicit

Const DEBUGGING = False
Const VERSION = "1.8.19-316.B" 'format(now(), "yy-y.x")

Public bDoing As Boolean
Public bAutoSaved As Boolean

Private Sub cmdGo_Click()
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2019
    
    Const ThisProcedureName = "cmdGo_Click"
    On Error GoTo ErrHandler
    FirstTime False
    
    Err.Clear
ErrHandler:
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
End Sub

Private Sub smoothOperator()
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2019
    
    Const ThisProcedureName = "smoothOperator"
    On Error GoTo ErrHandler
    
    FirstTime True
    
    Err.Clear
ErrHandler:
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Sub FirstTime(bSkipDialogs As Boolean)
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014, Luglio 2016, Ottobre 2019
    
    Const ThisProcedureName = "cmdGo_Click"
    On Error GoTo ErrHandler
    
    Application.ScreenUpdating = True
    If bDoing Then
        If Not bSkipDialogs Then MsgBox "Forbidden. Please wait end of operations."
    Else
        bDoing = True
        bAutoSaved = False
        Cells(23, 23) = IIf(DEBUGGING, vbNullString, "'" & VERSION)
        cmdGO.Enabled = Not PropagaFormati(True, True, bSkipDialogs) 'se PropagaFormati() fallisce, il pulsante resta abilitato
        cmdGO.Visible = cmdGO.Enabled
        ActiveWorkbook.Worksheets("rules").Visible = cmdGO.Enabled
        ActiveWorkbook.Worksheets("kernel").Visible = cmdGO.Enabled
        If bAutoSaved Then ActiveWorkbook.Save            'per evitare richiesta da Excel
        bDoing = False
    End If
    
    Err.Clear
ErrHandler:
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
End Sub

Public Sub Refresh()
'Paolo Bettazzi
'ADP ESI Italy - Agosto 2014.
    
    Const ThisProcedureName = "Refresh"
    On Error GoTo ErrHandler
    
    Dim j
    
    If bDoing Then
        MsgBox "Forbidden. Please wait end of operations."
    ElseIf Cells(23, 23) = vbNullString Then
        MsgBox "shriek !!!" 'you shouldn't be there
    Else
        bDoing = True
        Cells(23, 23) = IIf(DEBUGGING, vbNullString, "'" & VERSION)
        j = MsgBox("Trasformo le Formule in Valori ?" & vbCrLf & "(le operazioni saranno pi|fffd| veloci)", vbYesNoCancel, ThisProcedureName)
        Select Case j
         Case vbCancel
            'do nothing
         Case Else
            cmdGO.Enabled = Not PropagaFormati(False, (j = vbYes)) ' PaB 16.10.2019 : no robots here, so bSkipDialogs is always false
            cmdGO.Visible = cmdGO.Enabled
            ActiveWorkbook.Worksheets("rules").Visible = cmdGO.Enabled
            ActiveWorkbook.Worksheets("kernel").Visible = cmdGO.Enabled
        End Select
        bDoing = False
    End If
    
    Err.Clear
ErrHandler:
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
End Sub

Private Function PropagaFormati(bFirstTime As Boolean, bRazeFormulas As Boolean, Optional bSkipDialogs As Boolean) As Boolean
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "PropagaFormati"
    On Error GoTo ErrHandler
    
    PropagaFormati = False

    Dim myWrkb As Workbook
    Dim myWrks As Worksheet
    
    Dim srcWrkb As Workbook
    Dim srcWrks As Worksheet
    
    Dim wRules As Worksheet
    Dim wKernl As Worksheet
    
    Dim nRighe, nStart, nRiga, nStep
    
    Dim offset
    Dim sCaption
    
    Dim a() 'array
    Dim b, c, g, h 'booleans
    Dim d, e 'dates
    Dim i, j, k, l, m, n, o, p, q 'indexes and counters
    Dim r, s, t, u, v, w 'strings
    
    '------------------------------------------
    ' Housekeeping
    '------------------------------------------
    Application.Calculation = xlManual
    Application.CalculateBeforeSave = True
    
    Debug.Assert Not DEBUGGING
    
    Set wRules = ActiveWorkbook.Worksheets("rules")
    Set wKernl = ActiveWorkbook.Worksheets("kernel")
    offset = 0 'le regole iniziano a colonna A
    
    '----------------------------------------------
    ' siphon
    '----------------------------------------------
    wKernl.Activate
    sCaption = cmdGO.Caption
    cmdGO.Caption = "Uploading ..."
    DoEvents
    
    If Not DEBUGGING Then
        Application.ScreenUpdating = False
    End If
    
    i = 2
    'PaB 08.02.2016, 29.06.2016, 07.07.2016
    ' wholly restructured.
    ' reverted cycles
    ' outer cycle now opens workbooks, inner cycle gathers multiple sheet data.
    ' draft management of Zadig outputs
    '
    ' TODO : manage payroll@adp outputs !
    
    c = False ' siphon flag
    q = 0 'Zadig sheet pointer
    While wRules.Cells(i, offset + 1) <> vbNullString And bFirstTime
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "siphon" Then
            c = True
            If Trim(LCase(wRules.Cells(i, offset + 6))) Like "z[a-z][a-z][a-z]*" Then
                q = i
            End If
        End If
        i = i + 1
    Wend
    
    If c Then ' siphon requested
        Debug.Assert Not DEBUGGING
        
        ' gather names of Adempimenti XLS data workbooks in array a()
        ' ATTENTION POINT : => conventions are replicated in autoSave Function() !!!
        
        ' PaB 18.09.2019 naming convention
        If ActiveWorkbook.Name Like "P_*_FILE_NOE_CTR-*" Then ' SHIELD naming convention is active !
            l = InStrRev(ActiveWorkbook.Name, "-") ' var l = position of sequence number
            If l = 0 Then k = 0 Else k = InStrRev(Left(ActiveWorkbook.Name, l - 1), "--") ' var k = right limit of company code
            If k = 0 Then j = 0 Else j = InStrRev(Left(ActiveWorkbook.Name, k - 1), "-") ' var j = left limit of company code
        Else
            l = InStrRev(ActiveWorkbook.Name, "_") ' var l = position of sequence number
            If l = 0 Then k = 0 Else k = InStrRev(Left(ActiveWorkbook.Name, l - 1), "-") ' var k = right limit of company code
            If k = 0 Then j = 0 Else j = InStrRev(Left(ActiveWorkbook.Name, k - 1), "-") ' var j = left limit of company code
        End If
        
        If (j > 0 And k > j And l > k) Then
        ' pattern was recognized -> it's an Adempimenti macro control
            s = Dir(ActiveWorkbook.Path & "\" _
              & Left(ActiveWorkbook.Name, j) & "*" _
              & Mid(ActiveWorkbook.Name, k, l - k - 0) & "*.xls")
            
            k = 0
            While Len(s) > 0
                If Not s Like "*xlsm" Then
                    k = k + 1
                    ReDim Preserve a(1 To k)
                    a(k) = ActiveWorkbook.Path & "\" & s
                End If
                s = Dir
            Wend
            
            'notfound : only for DEBUGGING mode
            'fileselect() multipla (last shore)
            If k < 1 And DEBUGGING Then
                On Error Resume Next
                With Application.FileDialog(msoFileDialogFilePicker)
                    .InitialFileName = GetSetting("ControlliAD", "Settings", "myPath", ThisWorkbook.Path & "\")
                    .Title = "Selezionare i files XLS da processare (multiselect ammessa)"
                    .AllowMultiSelect = True
                    .InitialView = msoFileDialogViewDetails
                    .ButtonName = "Seleziona"
                    .Show
                    If .SelectedItems.Count > 0 Then
                        For k = 1 To .SelectedItems.Count
                            ReDim Preserve a(1 To k)
                            a(k) = .SelectedItems(k)
                        Next
                        SaveSetting "ControlliAD", "Settings", "myPath", Left(a(1), InStrRev(a(1), "\"))
                    End If
                End With
            End If
        Else
            k = 0
        End If
            
    End If
    
    '----------------------------------------------
    ' siphon from Adempimenti XLS workbooks
    '----------------------------------------------
    If c And k > 0 Then ' (siphon requested( And (at least one Adempimenti XLS was found)
            
        'Debug.Assert Not DEBUGGING
        Set myWrkb = ActiveWorkbook
        t = myWrkb.Path & "\" & myWrkb.Name
        On Error Resume Next
        For k = 1 To UBound(a)
            DoEvents
            If LCase(a(k)) <> LCase(t) Then 'skip self
                On Error Resume Next
                Set srcWrkb = Application.Workbooks.Open(a(k))
                If Err.Number = 0 Then
                    On Error GoTo ErrHandler
                    i = 2
                    While wRules.Cells(i, offset + 1) <> vbNullString And bFirstTime
                        If Trim(LCase(wRules.Cells(i, offset + 1))) = "siphon" Then
                            For Each myWrks In myWrkb.Worksheets
                                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                                    myWrks.Activate
                                    Debug.Assert Not DEBUGGING
                                    For Each srcWrks In srcWrkb.Worksheets
                                        If LCase(srcWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                                            j = Siphon(srcWrks, wRules.Cells(i, offset + 3), wRules.Cells(i, offset + 4), wRules.Cells(i, offset + 5), wRules.Cells(i, offset + 4), myWrks, CLng(j), IIf(Trim(LCase(wRules.Cells(i, offset + 7))) = "all", xlPasteAll, xlPasteValues), IIf(Trim(LCase(wRules.Cells(i, offset + 7))) = "single", True, False))
                                        End If
                                    Next
                                End If
                            Next
                        End If
                        i = i + 1
                    Wend
                End If
                srcWrkb.Close False
            End If
        Next
    End If
    
    '----------------------------------------------
    ' siphon from CSV ZADIG (accesso manuale)
    '----------------------------------------------
    If c And k = 0 And q > 0 Then ' (siphon requested) And (no Adempimenti XLSes found) and (template is suitable for Zadig macro)
    'give a try to Zadig
        Set myWrkb = ActiveWorkbook
        On Error GoTo ErrHandler
            
        l = InStrRev(LCase(ActiveWorkbook.Name), ".xls")
        s = Dir(ActiveWorkbook.Path & "\" _
          & Left(ActiveWorkbook.Name, l) & "csv")
        
        If Len(s) > 0 Then
            ' a CSV file with same name exists in same directory. It's our thing.
            ReDim Preserve a(1 To 1)
            a(1) = ActiveWorkbook.Path & "\" & s
        End If
        
        'input loop
        Do While True
            
            If s = vbNullString Then
                ' ask user to find the CSV file somewhere.
                ' abort if she refuses.
            
                With Application.FileDialog(msoFileDialogFilePicker)
                    .InitialFileName = GetSetting("ControlliZAD", "Settings", "myPath", ThisWorkbook.Path & "\")
                    .Title = "Selezionare il file CSV da processare (multiselect non ammessa)"
                    .AllowMultiSelect = False
                    .InitialView = msoFileDialogViewDetails
                    .ButtonName = "Seleziona"
                    .Show
                    If .SelectedItems.Count > 0 Then
                        For k = 1 To .SelectedItems.Count ' 1-cycle loop ! (ready for .AllowMultiSelect = True)
                            ReDim Preserve a(1 To k)
                            a(k) = .SelectedItems(k)
                            SaveSetting "ControlliZAD", "Settings", "myPath", .SelectedItems(k)
                        Next
                    Else
                        myWrkb.Close False
                    End If
                End With
            
            End If
            
            On Error GoTo ErrHandler
            
            r = myWrkb.Path & "\" & myWrkb.Name
            For k = 1 To UBound(a)
                If LCase(r) <> LCase(a(k)) And LCase(a(k)) Like "*.csv" Then
                    
                    l = FreeFile()
                    b = False
                    Open a(k) For Input As l
                    Do Until EOF(l)
                        DoEvents
                        Line Input #l, s
                        u = Split(s & vbLf, vbLf)
                        For o = 0 To UBound(u) - 1
                            t = Split(u(o), ";")
                            If UBound(t) > 8 Then 'it's a Zadig CSV file
                                If Not b Then
                                    If Trim(UCase(t(0))) = Trim(UCase(wRules.Cells(q, offset + 6))) Then
                                        b = True
                                        'Periodo
                                        Set myWrks = myWrkb.Sheets("Periodo")
                                        For m = 1 To 8
                                            ' date format is mean !
                                            If IsDate(t(m)) And Len(t(m)) = 10 Then
                                                myWrks.Cells(2, m) = DateSerial( _
                                                    Val(Mid(t(m), 7, 4)), _
                                                    Val(Mid(t(m), 4, 2)), _
                                                    Val(Mid(t(m), 1, 2)))
                                            Else
                                                myWrks.Cells(2, m) = t(m)
                                            End If
                                        Next
                                        'PaB 05.11.2016 indicatore Z
                                        myWrks.Cells(2, m) = "Z"
                                        
                                        Set myWrks = myWrkb.Sheets(CStr(wRules.Cells(q, offset + 2)))
                                        m = wRules.Cells(q, offset + 4)
                                    Else
                                        Exit Do
                                    End If
                                End If
                                    
                                On Error Resume Next
                                p = 9
                                For n = Col2Num(wRules.Cells(q, offset + 3)) To Col2Num(wRules.Cells(q, offset + 5))
                                    ' date format is mean ! all dates come in dd/mm/yyyy format
                                    If IsDate(t(p)) And Len(t(p)) = 10 Then
                                        myWrks.Cells(m, n) = DateSerial( _
                                            Val(Mid(t(p), 7, 4)), _
                                            Val(Mid(t(p), 4, 2)), _
                                            Val(Mid(t(p), 1, 2)))
                                    ' numeric format is tricky !
                                    ElseIf IsNumeric(t(p)) And Len(Trim(t(p))) < 20 And (Left(t(p), 1) <> "0" Or t(p) Like "*[.,]*") Then
                                        myWrks.Cells(m, n) = ValEx(t(p))
                                    ' everything else is treated as an alphanumeric value / code
                                    Else
                                        myWrks.Cells(m, n) = "'" & t(p)
                                    End If
                                    p = p + 1
                                Next
                                On Error GoTo ErrHandler
                            End If
                        
                            m = m + 1
                        Next
                    Loop
                    Close #l
                    If b Then
                        Exit Do
                    Else
                        MsgBox a(k) & " does not match with this macro container (" & Trim(UCase(wRules.Cells(q, offset + 6))) & ") ..."
                        s = vbNullString
                    End If
                End If
            Next
        Loop
    End If
    
    Debug.Assert Not DEBUGGING
    
    '----------------------------------------------
    ' copia valori dal foglio "data" (ADP Q&R Reporting)
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString And bFirstTime
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "copiacelle" Then
            If True Then
            'new version
                j = Siphon(ActiveWorkbook.Worksheets("data"), wRules.Cells(i, offset + 3), wRules.Cells(i, offset + 4), wRules.Cells(i, offset + 5), wRules.Cells(i, offset + 6), myWrks, wRules.Cells(i, offset + 3), IIf(Trim(LCase(wRules.Cells(i, offset + 7))) = "all", xlPasteAll, xlPasteValues), False)
            Else
            'old version
                CopiaCelle "data", wRules.Cells(i, offset + 2), wRules.Cells(i, offset + 3), wRules.Cells(i, offset + 4), wRules.Cells(i, offset + 5), wRules.Cells(i, offset + 6), IIf(Trim(LCase(wRules.Cells(i, offset + 7))) = "all", xlPasteAll, xlPasteValues)
            End If
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' PaB 15.09.2016
    ' hook to prepare aggregate values
    '----------------------------------------------
    On Error Resume Next
    b = CallByName(ThisWorkbook, "ApplicationContext", VbMethod, "start")
    On Error GoTo ErrHandler
    
    Application.ScreenUpdating = True
    wKernl.Activate
    cmdGO.Caption = sCaption
    DoEvents
    
    '----------------------------------------------
    ' formatting
    '----------------------------------------------
    wKernl.Activate
    sCaption = cmdGO.Caption
    cmdGO.Caption = "Formatting ..."
    DoEvents
    
    If Not DEBUGGING Then
        Application.ScreenUpdating = False
    End If
    
    '----------------------------------------------
    ' mettiOggi
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "mettioggi" Then
        
            'PaB 04.11.2015 get date from execution prms
            Dim dRif As Date
            dRif = Now()
            For Each myWrks In ActiveWorkbook.Worksheets
                If myWrks.Name = "Periodo" Then
                    If IsDate(myWrks.Cells(2, 5)) Then
                        dRif = myWrks.Cells(2, 5)
                    End If
                End If
            Next
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                    
                    Debug.Assert Not DEBUGGING
                    
                    Select Case wRules.Cells(i, offset + 7).Value
                     Case "iMC"
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif), Month(dRif), 1) 'inizio mese corrente
                     Case "fMC"
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif), Month(dRif) + 1, 0) 'fine mese corrente
                     Case "iMP"
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif), Month(dRif) - 1, 1) 'inizio mese precedente
                     Case "fMP"
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif), Month(dRif), 0) 'fine mese precedente
                     Case "fAP"
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif) - 1, 12, 31) 'fine anno precedente
                     Case "iAC"
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif), 1, 1) 'inizio anno corrente
                     Case Else
                        Selection.Cells(1, 1).Value = DateSerial(Year(dRif), Month(dRif), 1) 'default
                    End Select
                    If Selection.NumberFormat = "General" Then Selection.NumberFormat = "dd/mm/yy"
                    myWrks.Range("A1").Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' mettiZero, mettiSpazi, mettiDate
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "mettizero" Or _
           Trim(LCase(wRules.Cells(i, offset + 1))) = "mettispazi" Or _
           Trim(LCase(wRules.Cells(i, offset + 1))) = "mettidate" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    
                    Debug.Assert Not DEBUGGING
                    
                    t = Split(wRules.Cells(i, offset + 7), ",")
                    For k = 0 To UBound(t)
                        CaricaCelle wRules.Cells(i, offset + 2), CStr(t(k)), wRules.Cells(i, offset + 4), Trim(LCase(wRules.Cells(i, offset + 1)))
                    Next
                    'myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                    myWrks.Range("A1").Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' copia formule e formati
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "replicacelle" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    Debug.Assert Not DEBUGGING
                    ReplicaCelle wRules.Cells(i, offset + 2), wRules.Cells(i, offset + 3), wRules.Cells(i, offset + 4), wRules.Cells(i, offset + 5), wRules.Cells(i, offset + 6), IIf(Trim(LCase(wRules.Cells(i, offset + 7))) = "all", xlPasteAll, xlPasteFormats)
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' elimina righe
    '----------------------------------------------
    i = 2
    'PaB 29.08.2014
    'While wRules.Cells(i, offset + 1) <> vbNullString
    While wRules.Cells(i, offset + 1) <> vbNullString And bFirstTime
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "cancellarighe" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    myWrks.Rows(wRules.Cells(i, offset + 4) & ":" & wRules.Cells(i, offset + 6)).Select
                    Debug.Assert Not DEBUGGING
                    If Not DEBUGGING Then
                        Selection.Delete Shift:=xlUp
                    End If
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' mettiNome
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "mettinome" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    Debug.Assert Not DEBUGGING
                    myWrks.AutoFilterMode = False
                    On Error Resume Next
                    ActiveWorkbook.Names(wRules.Cells(i, offset + 7)).Delete
                    On Error GoTo ErrHandler
                    myWrks.Range(wRules.Cells(i, offset + 3) & ":" & wRules.Cells(i, offset + 4)).Select
                    j = ActiveCell.Row 'must be selection.currentrow
                    myWrks.Range(Selection, Selection.End(xlDown)).Select
                    k = ActiveCell.SpecialCells(xlLastCell).Row '- 1 added
                    If k < j Then k = j
                    ActiveWorkbook.Names.Add Name:=wRules.Cells(i, offset + 7), RefersTo:="=" & myWrks.Name & "!$" & wRules.Cells(i, offset + 5) & "$" & j & ":$" & wRules.Cells(i, offset + 6) & "$" & k
                    myWrks.Range("A1").Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    Application.ScreenUpdating = True
    wKernl.Activate
    cmdGO.Caption = sCaption
    DoEvents
    
    '----------------------------------------------
    ' calcolo
    '----------------------------------------------
    wKernl.Activate
    sCaption = cmdGO.Caption
    cmdGO.Caption = "Calculating ..."
    DoEvents
    
    Application.CalculateFullRebuild
    Do While Application.CalculationState <> xlDone
     DoEvents
    Loop
    'Application.Calculation = xlAutomatic
    Application.CalculateBeforeSave = False
    
    cmdGO.Caption = sCaption
    DoEvents
    
    '----------------------------------------------
    ' operazioni finali
    '----------------------------------------------
    wKernl.Activate
    sCaption = cmdGO.Caption
    cmdGO.Caption = "Final step ..."
    DoEvents
    
    If Not DEBUGGING Then
        Application.ScreenUpdating = False
    End If
        
    '----------------------------------------------
    ' sort
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "ordina" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    Debug.Assert Not DEBUGGING
                    myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                    If Not DEBUGGING Then
                        Selection.CurrentRegion.Select
                        'myWrks.Range(Selection, ActiveCell.SpecialCells(xlLastCell)).Select
                        'Selection.Sort Key1:=myWrks.Range(wRules.Cells(i, offset + 7)), Order1:=xlAscending, _
                        '    Header:=False, MatchCase:=False, Orientation:=xlTopToBottom
                        With ActiveWorkbook.Worksheets(ActiveSheet.Name).Sort
                            .SortFields.Clear
                            t = Split(wRules.Cells(i, offset + 7), ",")
                            For k = 0 To UBound(t)
                                'PBI 05.08.2013 - la variabile xlSortOnValues non |fffd| riconosciuta da Excel 97
                                '.SortFields.Add Key:=Range(t(k)), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortTextAsNumbers
                                'PaB 05.12.2016 - introdotto sort discendente
                                If t(k) Like "[A-Z]*-" Then
                                    .SortFields.Add Key:=Range(Left(t(k), Len(t(k)) - 1)), SortOn:=0, Order:=xlDescending, DataOption:=xlSortTextAsNumbers
                                Else
                                    .SortFields.Add Key:=Range(t(k)), SortOn:=0, Order:=xlAscending, DataOption:=xlSortTextAsNumbers
                                End If
                            Next
                            .SetRange Selection
                            .Header = xlYes
                            .MatchCase = False
                            .Orientation = xlTopToBottom
                            .SortMethod = xlPinYin
                            .Apply
                        End With
                    End If
                    myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    Application.CalculateFullRebuild
    Do While Application.CalculationState <> xlDone
     DoEvents
    Loop
    
    '----------------------------------------------
    ' copiaValori
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString And bRazeFormulas
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "copiavalori" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    'PaB 16.11.2014, problems with autofilters !!! Must be all exterminated, otherwise automatic selections will get wrong areas
                    If Not bFirstTime Then
                        myWrks.AutoFilterMode = False
                    End If
                    Debug.Assert Not DEBUGGING
                    myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4) & ":" & wRules.Cells(i, offset + 5) & wRules.Cells(i, offset + 6)).Select
                    myWrks.Range(Selection, Selection.End(xlDown)).Copy
                    myWrks.Range(Selection, Selection.End(xlDown)).PasteSpecial xlPasteValues
                    myWrks.Range("A1").Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' pivot
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "creapivot" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    Debug.Assert Not DEBUGGING
                    On Error Resume Next
                    t = Split(wRules.Cells(i, offset + 7), ";")
                    If UBound(t) >= 4 Then 'Let's start ...
                        
                        On Error GoTo ErrHandler
                        For l = 0 To UBound(t)
                            u = Split(Trim(t(l)), ",")
                            Select Case l
                             Case 0 'foglio destinazione
                                'pulizia pivot preesistenti
                                Dim xWs As Worksheet
                                Dim xPT As PivotTable
                                Dim xSH As Shape
                                For Each xWs In Application.ActiveWorkbook.Worksheets
                                    If xWs.Name = Trim(t(l)) Then
                                        
                                        'PaB 29.11.2016
                                        'avoids crashes when target sheet is hidden ...
                                        xWs.Visible = xlSheetVisible
                                        
                                        For Each xPT In xWs.PivotTables
                                            xWs.Range(xPT.TableRange2.Address).Delete Shift:=xlUp
                                        Next
                                        
                                        For Each xSH In xWs.Shapes
                                            xWs.Shapes.Range(Array(xSH.Name)).Delete
                                        Next
                                    End If
                                Next
                                'PaB 26.11.2017 : activate sheet to ease up following select
                                myWrks.Activate
                                myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4) & ":" & wRules.Cells(i, offset + 5) & wRules.Cells(i, offset + 6)).Select
                                j = ActiveCell.Row 'must be selection.currentrow
                                myWrks.Range(Selection, Selection.End(xlDown)).Select
                                k = ActiveCell.SpecialCells(xlLastCell).Row '- 1 added
                                If k < j Then k = j
                                ActiveWorkbook.PivotCaches.Create(SourceType:=xlDatabase, _
                                SourceData:=(myWrks.Name & "!$" & wRules.Cells(i, offset + 3) & "$" & j & ":$" & wRules.Cells(i, offset + 5) & "$" & k), _
                                VERSION:=xlPivotTableVersion14).CreatePivotTable _
                                TableDestination:=Trim(t(l)) & "!R" & IIf(UCase(wRules.Cells(i, offset + 7)) Like "*;SLICER*", "15", "2") & "C1", TableName:=Trim(t(l))
                                Worksheets(Trim(t(l))).Activate
                                ActiveWorkbook.ShowPivotTableFieldList = False
                                ActiveWindow.DisplayZeros = False
                                ActiveSheet.PivotTables(Trim(t(0))).RowAxisLayout xlTabularRow
                                
                             Case 1, 2, 3 'pagine, righe, colonne
                                If UBound(u) > 0 Then
                                    n = 0
                                    For j = 0 To UBound(u) Step 2
                                        For m = 1 To ActiveSheet.PivotTables(Trim(t(0))).PivotFields.Count
                                            With ActiveSheet.PivotTables(Trim(t(0))).PivotFields(m)
                                                If .Name = myWrks.Cells(wRules.Cells(i, offset + 4), u(j)) Then
                                                    .Orientation = IIf(l = 1, xlPageField, IIf(l = 2, xlRowField, xlColumnField))
                                                    'PaB 26.11.2017 - added subtotal, on 3rd dimension only (columnField)
                                                    '(suggested : only one 3rd dimension i.e. columnField)
                                                    .Subtotals = Array((l = 3), False, False, False, False, False, False, False, False, False, False, False)
                                                    .EnableMultiplePageItems = True
                                                    n = n + 1
                                                    .Position = n
                                                    If u(j + 1) <> vbNullString Then
                                                        .Caption = u(j + 1)
                                                    End If
                                                    m = ActiveSheet.PivotTables(Trim(t(0))).PivotFields.Count
                                                End If
                                            End With
                                        Next
                                    Next
                                End If
                             
                             Case 4 'dati
                                If UBound(u) > 0 Then
                                    n = 0
                                    For j = 0 To UBound(u) Step 2
                                        For m = 1 To ActiveSheet.PivotTables(Trim(t(0))).PivotFields.Count
                                            If ActiveSheet.PivotTables(Trim(t(0))).PivotFields(m).Name = myWrks.Cells(wRules.Cells(i, offset + 4), u(j)) Then
                                                If u(j + 1) <> vbNullString Then
                                                    If Right(u(j + 1), 1) = "*" Then
                                                        'PaB 26.11.2017 - added count* cells !!!
                                                        n = n + 1
                                                        ActiveSheet.PivotTables(Trim(t(0))).AddDataField ActiveSheet.PivotTables(Trim(t(0))).PivotFields(m), Left(u(j + 1), Len(u(j + 1)) - 1), xlCount
                                                    Else
                                                        ActiveSheet.PivotTables(Trim(t(0))).AddDataField ActiveSheet.PivotTables(Trim(t(0))).PivotFields(m), u(j + 1), xlSum
                                                    End If
                                                End If
                                                m = ActiveSheet.PivotTables(Trim(t(0))).PivotFields.Count
                                            End If
                                        Next
                                    Next
                                    On Error Resume Next 'not always works, don't know why.
                                    ActiveSheet.PivotTables(Trim(t(0))).DataPivotField.Orientation = xlColumnField
                                    On Error GoTo ErrHandler
                                    ActiveSheet.PivotTables(Trim(t(0))).RowGrand = (n > 0)
                                End If
                             
                             Case Else
                                On Error Resume Next
                                
                                Select Case (UCase(Trim(u(0))))
                                 
                                 Case "LABEL"
                                    If Trim(u(1)) = "vert" Then
                                        v = Split(ActiveSheet.PivotTables(Trim(t(0))).DataBodyRange.Address, "$")
                                        w = Split(ActiveSheet.PivotTables(Trim(t(0))).ColumnRange.Address, "$")
                                        ActiveSheet.Range(v(1) & w(4) & ":" & v(3) & w(4)).Select
                                        'Range(Selection, Selection.End(xlToRight)).Select
                                        With Selection
                                            .HorizontalAlignment = xlGeneral
                                            .VerticalAlignment = xlBottom
                                            .WrapText = False
                                            .Orientation = 90
                                            .AddIndent = False
                                            .IndentLevel = 0
                                            .ShrinkToFit = False
                                            .ReadingOrder = xlContext
                                            .MergeCells = False
                                            .ColumnWidth = IIf(Val(u(2)) > 0, u(2), 5)
                                        End With
                                        
                                    End If
                                 
                                 Case "WIDTH"
                                    For j = 1 To UBound(u) Step 2
                                        ActiveSheet.Range(u(j) & ":" & u(j)).Select
                                        If (Val(u(j + 1))) > 0 Then
                                            Selection.ColumnWidth = Val(u(j + 1))
                                        Else
                                            Selection.EntireColumn.AutoFit
                                        End If
                                    Next
                                    
                                 Case "STYLE"
                                    ActiveSheet.PivotTables(Trim(t(0))).ShowTableStyleRowStripes = True
                                    ActiveSheet.PivotTables(Trim(t(0))).ShowTableStyleColumnStripes = True
                                    ActiveSheet.PivotTables(Trim(t(0))).ShowTableStyleRowHeaders = True
                                    ActiveSheet.PivotTables(Trim(t(0))).ShowTableStyleColumnHeaders = True
                                    ActiveSheet.PivotTables(Trim(t(0))).TableStyle2 = "PivotStyleMedium9"
                                    If u(1) <> vbNullString Then
                                        ActiveSheet.PivotTables(Trim(t(0))).TableStyle2 = u(1)
                                    End If
                                 
                                 Case "FREEZE"
                                    ActiveWindow.FreezePanes = False
                                    v = Split(ActiveSheet.PivotTables(Trim(t(0))).DataBodyRange.Address, "$")
                                    ActiveSheet.Range(v(1) & v(2) & v(3) & v(4)).Select 'cannot fail
                                    w = Split(ActiveSheet.PivotTables(Trim(t(0))).ColumnRange.Address, "$")
                                    ActiveSheet.Range(v(1) & w(4) + 1).Select 'can fail
                                    ActiveWindow.FreezePanes = True ' in any case FREEZE is granted
                                 
                                 Case "FONT"
                                    v = Split(ActiveSheet.PivotTables(Trim(t(0))).DataBodyRange.Address, "$")
                                    w = Split(ActiveSheet.PivotTables(Trim(t(0))).ColumnRange.Address, "$")
                                    ActiveSheet.Range(v(1) & w(4)).Select
                                    Selection.CurrentRegion.Select
                                    With Selection.Font
                                        .Name = "DINOT"
                                        .Size = 10
                                        '.Name = Trim(u(1))
                                        '.Size = Val(Trim(u(2)))
                                        .Strikethrough = False
                                        .Superscript = False
                                        .Subscript = False
                                        .OutlineFont = False
                                        .Shadow = False
                                        .Underline = xlUnderlineStyleNone
                                        .ColorIndex = xlAutomatic
                                        .TintAndShade = 0
                                        .ThemeFont = xlThemeFontNone
                                    End With
                                    ActiveSheet.Range(v(1) & w(4) + 1).Select

                                 Case "NONULL"
                                    Dim pD As PivotItem
                                    Dim pE As PivotField
                                    For j = 1 To UBound(u) Step 2
                                        Set pE = ActiveSheet.PivotTables(Trim(t(0))).PivotFields(u(j))
                                        If Err.Number = 0 Then
                                            For Each pD In pE.PivotItems
                                                Debug.Print pD.Value
                                                Select Case pD.Value
                                                    Case "0", "(blank)", "(vuoto)"
                                                        pD.Visible = False
                                                End Select
                                            Next
                                        End If
                                    Next
                                 
                                 Case "FORMAT"
                                    Dim pF As PivotField
                                    For j = 1 To UBound(u) Step 2
                                        'Set pF = ActiveSheet.PivotTables(Trim(t(0))).PivotFields(u(j))
                                        Set pF = ActiveSheet.PivotTables(Trim(t(0))).DataFields(u(j))
                                        If Err.Number = 0 Then
                                            Select Case LCase(u(j + 1))
                                             Case "c"
                                                pF.NumberFormat = "0;[Red]0"
                                             Case "n"
                                                pF.NumberFormat = "0.00;[Red]0.00"
                                            End Select
                                        End If
                                    Next
                                 
                                 Case "SLICERS"
                                    Dim pSC As SlicerCache
                                    Dim pSL As Slicer
                                    v = Split(ActiveSheet.PivotTables(Trim(t(0))).DataBodyRange.Address, "$")
                                    w = Split(ActiveSheet.PivotTables(Trim(t(0))).ColumnRange.Address, "$")
                                    ActiveSheet.Range(v(1) & w(4) + 1).Select
                                    'Dim pS As Slicer
                                    For j = 1 To UBound(u)
                                        'On Error GoTo ErrHandler
                                        ActiveWorkbook.SlicerCaches.Add(ActiveSheet.PivotTables(Trim(t(0))), _
                                           ActiveSheet.PivotTables(Trim(t(0))).PivotFields((u(j)))).Slicers.Add ActiveSheet, , _
                                           (u(j)), (u(j)), _
                                           12, 64 * (j * 2 + 1), 104, 162
                                        For Each pSC In ActiveWorkbook.SlicerCaches
                                            For Each pSL In pSC.Slicers
                                                If pSL.Name = u(j) Then
                                                    pSL.Style = "SlicerStyleLight" & j Mod 6 + 1
                                                End If
                                            Next
                                        Next
                                    Next

                                End Select
                            
                            End Select
                        Next
                        'si posiziona in cima
                        ActiveWindow.ScrollRow = 1
                        ActiveWindow.ScrollColumn = 1
                        ActiveWindow.ActivePane.VisibleRange.Cells(1, 1).Select
                    End If
                    
                    On Error GoTo ErrHandler
                    myWrks.Activate
                    ActiveWindow.ActivePane.VisibleRange.Cells(1, 1).Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' riep (PaB 02.11.2016)
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "creariep" Then
            i = 999 'only once
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = "riepilogo" Then
                    j = dynaRiep(wRules, myWrks)
                End If
            Next
        End If
        i = i + 1
    Wend
    
    'From now On ScreenUpdating must be True
    ' (last sheet acted upon becomes current sheet).
    '
    Application.ScreenUpdating = True
    wKernl.Activate
    cmdGO.Caption = sCaption
    DoEvents
    
    '----------------------------------------------
    ' filtro (last one becomes the current one)
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "filtro" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    Debug.Assert Not DEBUGGING
                    'test filtro attivo
                    b = myWrks.AutoFilterMode
                    If Not b Then 'imposta filtro default
                        myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                        'PaB 17.1.2016 - procedure would always put Filter on 1st row.
                        '                try this.
                        Selection.End(xlToLeft).Select
                        myWrks.Range(Selection, Selection.End(xlToRight)).Select
                        'PaB 17.1.2016 - end
                        Selection.AutoFilter Field:=Col2Num(wRules.Cells(i, offset + 3)), Criteria1:="<>" 'riaccende
                    End If
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '------------------------------------------
    ' autofit (last one becomes the current one)
    '------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "autofit" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    Debug.Assert Not DEBUGGING
                    myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                    Selection.CurrentRegion.Select
                    If bFirstTime Or _
                       Trim(LCase(wRules.Cells(i, offset + 7))) Like "*always*" Then
                        myWrks.Columns.EntireColumn.AutoFit
                    End If
                    If Trim(LCase(wRules.Cells(i, offset + 7))) Like "*autofilter*" Then
                        If Not myWrks.AutoFilterMode Then
                            Selection.AutoFilter
                        End If
                    End If
                    myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                End If
            Next
        End If
        i = i + 1
    Wend
    
    '----------------------------------------------
    ' nascondiColonne (last one becomes the current one)
    ' must be last, otherwise AutoFit shows them again.
    ' Hide entire sheet when Column List says "H,i,d,d,e,n"
    '----------------------------------------------
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "nascondicolonne" Then
            For Each myWrks In ActiveWorkbook.Worksheets
                If LCase(myWrks.Name) = LCase(wRules.Cells(i, offset + 2)) Then
                    myWrks.Activate
                    On Error Resume Next
                    Debug.Assert Not DEBUGGING
                    For Each o In myWrks.Shapes
                        o.Placement = xlMoveAndSize
                    Next
                    On Error GoTo ErrHandler
                    If UCase(Trim(wRules.Cells(i, offset + 7))) = "H,I,D,D,E,N" Then
                        myWrks.Visible = xlSheetHidden
                    Else
                        t = Split(wRules.Cells(i, offset + 7), ",")
                        For k = 0 To UBound(t)
                            myWrks.Range(Trim(t(k)) & "1").Select
                            Selection.EntireColumn.Hidden = True
                        Next
                        'myWrks.Range(wRules.Cells(i, offset + 3) & wRules.Cells(i, offset + 4)).Select
                        myWrks.Range("A1").Select
                    End If
                End If
            Next
        End If
        i = i + 1
    Wend
    
    Application.ScreenUpdating = True
    Application.Calculation = xlAutomatic
    On Error GoTo ErrHandler
    
    '----------------------------------------------
    ' operazioni specifiche del workbook.
    ' la function ApplicationContext() deve restituire un booleano e pu|fffd| esistere o meno nel workbook
    ' uso il metodo CallByName per non avere errori in compilazione
    '----------------------------------------------
    On Error Resume Next
    b = CallByName(ThisWorkbook, "ApplicationContext", VbMethod, "goOn")
    On Error GoTo ErrHandler
    
    '----------------------------------------------
    ' autoSave
    '----------------------------------------------
    If bFirstTime Then
        bAutoSaved = autoSave(wRules, bSkipDialogs)
    End If
    
    Debug.Assert Not DEBUGGING
    PropagaFormati = True
    
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Function

Private Function Siphon(heWrks As Worksheet, startCol As String, startRow As Long, endCol As String, endRow As Long, sheWrks As Worksheet, nStart As Long, Optional tRepl As Variant, Optional bSingle As Variant) As Long
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "Siphon"
    On Error GoTo ErrHandler
    
    Dim nRighe, nStep
    Dim i, j, k, l, m, n, p, q, r, s, t
    
    If IsNull(tRepl) Then tRepl = xlPasteAll
    
    On Error GoTo ErrHandler
    
    'sheWrks.Activate
    
    'set last non-empty row in origin
    'WAS:
    'nRighe = startRow - 1
    'While heWrks.Cells(nRighe + 1, Col2Num(startCol)) <> vbNullString Or _
    '      heWrks.Cells(nRighe + 2, Col2Num(startCol)) <> vbNullString
    '    nRighe = nRighe + 1
    'Wend
    'NOW IS (better) :
    nRighe = heWrks.Cells(heWrks.Rows.Count, Col2Num(startCol)).End(xlUp).Row
    
    Siphon = 0
    
    If nRighe > 0 Then
    
        '------------- set first empty row in destination -----------------------------
        nStart = sheWrks.Cells(sheWrks.Rows.Count, Col2Num(startCol)).End(xlUp).Row + 1
        
        '------------- skip sheet if "single" destination has been already filled -----
        If bSingle And nStart > startRow Then nRighe = 0

        '------------- reposition start row if destination is partially filled --------
        If nStart < startRow Then nStart = startRow
        
        '------------- copy data ------------------------------------------------------
        nStep = 2357
        
        'position (i) on first origin row
        i = startRow
        While i <= nRighe
            If (i + nStep) > (nRighe + 1) Then 'last chunk
                nStep = nRighe - i + 1
            End If
            
            heWrks.Range(Num2Col(Col2Num(startCol)) & CStr(i) & ":" & Num2Col(Col2Num(endCol) - Col2Num(startCol) + 1) & CStr(i + nStep - 1)).Copy Destination:=sheWrks.Range(startCol & CStr(nStart)) 'xlPasteAll
            
            i = i + nStep
            nStart = nStart + nStep
            Application.StatusBar = "collecting ... (" & nStart & ")"
            DoEvents
            If Not DEBUGGING Then Application.ScreenUpdating = False

        Wend
    
    End If
    
    Siphon = nStart
    
    Debug.Assert Not DEBUGGING
    
    Application.StatusBar = False
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Function

Private Sub CopiaCelle(orgWrks As String, dstWrks As String, startCol As String, startRow As Long, endCol As String, endRow As Long, Optional tRepl As Variant)
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
'TODO : obsoleta, dirottare su Siphon()
    
    Const ThisProcedureName = "CopiaCelle"
    On Error GoTo ErrHandler
    
    Dim heWrks As Worksheet 'origine
    Dim sheWrks As Worksheet 'destinazione
    
    Dim nRighe, nStart, nRiga, nStep
    Dim i, j, k, l, m, n, p, q, r, s, t
    
    If IsNull(tRepl) Then tRepl = xlPasteAll
    
    On Error Resume Next
    
    Set heWrks = Worksheets(orgWrks)
    If Err.Number <> 0 Then
        Err.Clear
        GoTo ErrHandler
    End If
    
    Set sheWrks = Worksheets(dstWrks)
    If Err.Number <> 0 Then
        Err.Clear
        GoTo ErrHandler
    End If
    
    On Error GoTo ErrHandler
    
    sheWrks.Activate
    nRighe = 0
    nStart = 1 'fixed : WAS 'nStart = endRow + 1
    
    While heWrks.Cells(nStart + nRighe + 0, 1) <> vbNullString Or _
          heWrks.Cells(nStart + nRighe + 1, 1) <> vbNullString Or _
          heWrks.Cells(nStart + nRighe + 0, 2) <> vbNullString Or _
          heWrks.Cells(nStart + nRighe + 1, 2) <> vbNullString
        nRighe = nRighe + 1
    Wend

    If nRighe > 0 Then
        '------------- Copia dati ------------------------------
        nStep = 573
        
        i = nStart
        While i < (nStart + nRighe)
            If (i + nStep) > (nStart + nRighe) Then 'fuori target
                nStep = nStart + nRighe - i
            End If
            
            Application.StatusBar = "wait ... (" & i + nStep - 1 & ")"
            DoEvents
            If Not DEBUGGING Then Application.ScreenUpdating = False
            
            heWrks.Range(Num2Col(1) & CStr(i) & ":" & Num2Col(Col2Num(endCol) - Col2Num(startCol) + 1) & CStr(i + nStep - 1)).Copy Destination:=sheWrks.Range(startCol & CStr(i + endRow - 1)) 'xlPasteAll
            
            i = i + nStep
        Wend
    
    End If
        
    'si posiziona in cima
    ActiveWindow.ScrollRow = 1
    ActiveWindow.ScrollColumn = 1
    ActiveWindow.ActivePane.VisibleRange.Cells(1, 1).Select

    Application.StatusBar = False
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Sub ReplicaCelle(dstWrks As String, startCol As String, startRow As Long, endCol As String, endRow As Long, Optional tRepl As Variant)
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "ReplicaCelle"
    On Error GoTo ErrHandler
    
    Dim myWrks As Worksheet 'destinazione
    
    Dim nRighe, nStart, nRiga, nStep
    Dim i, j, k, l, m, n, p, q, r, s, t
    
    If IsNull(tRepl) Then tRepl = xlPasteAll
    
    Set myWrks = Worksheets(dstWrks)
    myWrks.Activate
    nRighe = 0
    nStart = endRow + 1
    
    While myWrks.Cells(nStart + nRighe + 0, 1) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 1, 1) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 0, 2) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 1, 2) <> vbNullString
        nRighe = nRighe + 1
    Wend

    If nRighe > 0 Then
        '------------- Copia formule ------------------------------
        nStep = 573
        
        myWrks.Range(startCol & CStr(startRow) & ":" & endCol & CStr(endRow)).Copy
        i = nStart
        While i < (nStart + nRighe)
            If (i + nStep) > (nStart + nRighe) Then 'fuori target
                nStep = nStart + nRighe - i
            End If
            Application.StatusBar = "wait ... (" & i + nStep - 1 & ")"
            DoEvents
            If Not DEBUGGING Then Application.ScreenUpdating = False
            myWrks.Range(startCol & CStr(i) & ":" & endCol & CStr(i + nStep - 1)).PasteSpecial tRepl
            i = i + nStep
        Wend
        
        'DoEvents
    
    End If
        
    'si posiziona in cima
    ActiveWindow.ScrollRow = 1
    ActiveWindow.ScrollColumn = 1
    ActiveWindow.ActivePane.VisibleRange.Cells(1, 1).Select

    Application.StatusBar = False
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Sub CaricaCelle(Wrks As String, startCol As String, Optional startRow As Variant, Optional tDato As Variant)
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "CaricaCelle"
    On Error GoTo ErrHandler
    
    Dim myWrks As Worksheet
    Dim nRighe, nStart, nRiga, nStep
    Dim i, j, k, l, m, n, p, q, r, s, t
    
    Set myWrks = Worksheets(Wrks)
    myWrks.Activate
    nRighe = 0
    'nStart = 2
    If IsNull(startRow) Then
        nStart = 2
    Else
        nStart = CLng(startRow)
        If nStart < 1 Then nStart = 2
    End If
    
    If IsNull(tDato) Then tDato = "boh"
    
    While myWrks.Cells(nStart + nRighe + 0, 1) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 1, 1) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 2, 1) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 0, 2) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 1, 2) <> vbNullString Or _
          myWrks.Cells(nStart + nRighe + 2, 2) <> vbNullString
        If nRighe Mod 2573 = 0 Then
            Application.StatusBar = "wait ... formatting (" & startCol & ", " & nRighe & ")"
            DoEvents
            If Not DEBUGGING Then Application.ScreenUpdating = False
        End If
        Select Case tDato
         Case "mettizero"
            myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "#"
            If myWrks.Cells(nStart + nRighe, startCol) = vbNullString Then
                myWrks.Cells(nStart + nRighe, startCol) = 0
            End If
         Case "mettispazi"
            On Error Resume Next
            If Val(myWrks.Cells(nStart + nRighe, startCol)) = 0 Then
                myWrks.Cells(nStart + nRighe, startCol) = vbNullString
            End If
            On Error GoTo ErrHandler
         Case "mettidate"
            If myWrks.Cells(nStart + nRighe, startCol) = vbNullString Then
                'myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "@" 'plain text
            ElseIf myWrks.Cells(nStart + nRighe, startCol) = 0 Then
                myWrks.Cells(nStart + nRighe, startCol).Clear
                'myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "@" 'plain text
            'PaB 03.05.2017 : checking Periodo in SQL Server dialect
            ElseIf Left(myWrks.Cells(nStart + nRighe, startCol), 10) Like "20[0-1][0-9]?[0-1][0-9]?[0-3][0-9]" Then
                l = CStr(Left(myWrks.Cells(nStart + nRighe, startCol), 10))
                q = DateSerial(Val(Mid(l, 1, 4)), Val(Mid(l, 6, 2)), Val(Mid(l, 9, 2)))
                If q > DateSerial(1900, 1, 1) Then
                    myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "yyyy/mm/dd"
                    myWrks.Cells(nStart + nRighe, startCol) = q
                Else
                    myWrks.Cells(nStart + nRighe, startCol) = vbNullString
                End If
            Else
                myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "yyyy/mm/dd"
                If IsDate(myWrks.Cells(nStart + nRighe, startCol)) Then
                    q = myWrks.Cells(nStart + nRighe, startCol)
                Else
                    myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "@" 'plain text
                    l = CLng("0" & myWrks.Cells(nStart + nRighe, startCol))
                    q = DateSerial(1900, 1, 1)
                    If (l Mod 10000) > 1899 And (l Mod 10000) < 2100 And _
                       Int((l Mod 1000000) / 10000) > 0 And Int((l Mod 1000000) / 10000) < 13 And _
                       Int(l / 1000000) > 0 And Int(l / 1000000) < 32 Then
                    'GGMMAAAA
                        q = DateSerial(l Mod 10000, Int((l Mod 1000000) / 10000), Int(l / 1000000))
                    ElseIf Int(l / 10000) > 1899 And Int(l / 10000) < 2100 And _
                       Int((l Mod 10000) / 100) > 0 And Int((l Mod 10000) / 100) < 13 And _
                       (l Mod 100) > 0 And l Mod 100 < 32 Then
                    'AAAAMMGG
                        q = DateSerial(Int(l / 10000), Int((l Mod 10000) / 100), l Mod 100)
                    ElseIf Int((l Mod 10000) / 100) > 0 And Int((l Mod 10000) / 100) < 13 And _
                           Int(l / 10000) > 0 And Int(l / 10000) < 32 Then
                    'GGMMAA
                        q = DateSerial(l Mod 100, Int((l Mod 10000) / 100), Int(l / 10000))
                    ElseIf Int((l Mod 10000) / 100) > 0 And Int((l Mod 10000) / 100) < 13 And _
                           l Mod 100 > 0 And l Mod 100 < 32 And Int(l / 10000) > 0 Then
                    'AAMMGG
                        q = DateSerial(Int(l / 10000), Int((l Mod 10000) / 100), l Mod 100)
                    End If
                    If q > DateSerial(1900, 1, 1) Then
                        myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "yyyy/mm/dd"
                        myWrks.Cells(nStart + nRighe, startCol) = q
                    Else
                        myWrks.Cells(nStart + nRighe, startCol) = vbNullString
                    End If
                End If
                myWrks.Cells(nStart + nRighe, startCol).NumberFormat = "dd/mm/yy"
            End If
        End Select
        nRighe = nRighe + 1
    Wend

    Application.StatusBar = False
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Function dynaRiep(ws As Worksheet, myWrks As Worksheet) As Boolean
' Paolo Bettazzi
' ADP ESI Italy - Ottobre 2016
    
    Const ThisProcedureName = "dynaRiep"
    On Error GoTo ErrHandler

    Debug.Assert Not DEBUGGING
    
    Dim i, j, k, l, m, vOffset, hOffset, bOffset
    Dim s, t, u, v
    Dim heWrks As Worksheet
    
    Dim btn As Button
    Dim rng As Range
    
    'Debug.Assert 1 = 0
'------------------------------------------------------------------------
'   ws |fffd| il foglio contenente le "rules".
'   myWrks |fffd| il foglio contenente i KPI.
'------------------------------------------------------------------------
    vOffset = 9     ' numero delle righe di testata in myWrks.
    bOffset = 7     ' numero della colonna contenente i button verticali)
'--------------------------------------------------------------
'   determinazione bOffset reale
'--------------------------------------------------------------
    i = 2
    While ws.Cells(i, 1) <> vbNullString And k < 18
        If LCase(ws.Cells(i, 1)) = "creariep" Then
            v = Split(ws.Cells(i, 6) & ";", ";")
            hOffset = 6 + UBound(v)
            If hOffset > bOffset Then bOffset = hOffset
        End If
        i = i + 1
    Wend
'--------------------------------------------------------------
'   pulizia dei pulsanti preesistenti
'--------------------------------------------------------------
    myWrks.Activate
    For i = ActiveSheet.Buttons.Count To 1 Step -1
        ActiveSheet.Buttons(i).Delete
    Next
'--------------------------------------------------------------
'   pulizia delle formule preesistenti
'--------------------------------------------------------------
    For k = 1 To 18
        For i = 3 To bOffset ' was 7
            myWrks.Cells(vOffset + k, i) = vbNullString
            myWrks.Cells(vOffset + k, i).FormulaR1C1 = vbNullString
        Next
    Next
'--------------------------------------------------------------
'   inserimento pulsanti + formule + range names
'--------------------------------------------------------------
'------------------------------------------------------------------------
'   ws |fffd| il foglio contenente le "rules". Analizzo la direttiva "creariep".
'------------------------------------------------------------------------
    k = 0
    i = 2
    While ws.Cells(i, 1) <> vbNullString And k < 18
        If LCase(ws.Cells(i, 1)) = "creariep" Then
            'Debug.Assert 1 = 0
            k = k + 1
            If ws.Cells(i, 5) <> vbNullString Then
                t = Split(ws.Cells(i, 5) & ",", ",")
'--------------------------------------------------------------
'   creazione range names nel foglio "bersaglio"
'--------------------------------------------------------------
                On Error Resume Next
                ActiveWorkbook.Names("chkRng" & Format(i, "000")).Delete
                Set heWrks = ActiveWorkbook.Sheets(CStr(ws.Cells(i, 2)))
                heWrks.Activate
                heWrks.Range(ws.Cells(i, 3) & ":" & ws.Cells(i, 4)).Select
                j = ActiveCell.Row 'must be selection.currentrow
                heWrks.Range(Selection, Selection.End(xlDown)).Select
                l = ActiveCell.SpecialCells(xlLastCell).Row '- 1 added
                If l < j Then l = j
                ActiveWorkbook.Names.Add Name:="chkRng" & Format(i, "000"), RefersTo:="=" & heWrks.Name & "!$" & t(0) & "$" & j & ":$" & t(0) & "$" & l
                heWrks.Range("A1").Select
'--------------------------------------------------------------
'   formule nel foglio "Riepilogo"
'--------------------------------------------------------------
                On Error GoTo ErrHandler
                myWrks.Activate
'--------------------------------------------------------------------------------------
'   formula colonna D - segnalazione - richiama target!X1                   (Col2:1)
'--------------------------------------------------------------------------------------
                myWrks.Cells(vOffset + k, 4).FormulaR1C1 = "=INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & "1" & Chr(34) & ")"
'--------------------------------------------------------------------------------------
'   formula colonna E - conteggio - CONTA.SE(target!X:X = colonna D)        (Col2:1)
'                                   CONTA.VALORI(target!Y:Y)-1              (Col2:2)
'--------------------------------------------------------------------------------------
                Select Case UBound(t)
                 Case 1
                    myWrks.Cells(vOffset + k, 5).FormulaR1C1 = "=COUNTIF(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & "), RC[-1])-1"
                 Case 2
                    myWrks.Cells(vOffset + k, 5).FormulaR1C1 = "=COUNTA(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(1) & ":" & t(1) & Chr(34) & "))-1"
                 Case 3
                    myWrks.Cells(vOffset + k, 5).FormulaR1C1 = "=COUNTIF(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & "), " & Chr(34) & t(2) & Chr(34) & ")"
                End Select
                u = "=HYPERLINK(" & Chr(34) & "#'" & ws.Cells(i, 2) & "'!" & t(0) & "1" & Chr(34) & ",IF(RC[-" & bOffset - 5 & "]=0,100," & IIf(LCase(ws.Cells(i, 7)) Like "*warn*", 50, 0) & "))"
                
                'PaB 04.09.2019 - okkio modificato indentamento delle If.
                ' il lavoro su ws.Cells(i, 6) e ws.Cells(i, 7) ora |fffd| subordinato al test su ws.Cells(i, 5)
                
                If ws.Cells(i, 6) <> vbNullString Then
                    hOffset = 5
                    v = Split(ws.Cells(i, 6) & ";", ";")
                    For m = 1 To UBound(v)
                        hOffset = hOffset + 1
                        If v(m - 1) <> vbNullString Then
                            t = Split(v(m - 1) & ",", ",")
'--------------------------------------------------------------------------------------
'   formula colonne F segg - valori - SOMMA(target!X:X)                          (Row2:1)
'                                     SOMMA.SE(target!X:X == val2)               (Row2:2)
'                                     SOMMA.SE(target!Y:Y == colD, target!X:X)   (Row2:2)
'--------------------------------------------------------------------------------------
                            Select Case UBound(t)
                             Case 1
                                'myWrks.Cells(vOffset + k, hOffset).FormulaR1C1 = "=SUM(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & "))"
                                myWrks.Cells(vOffset + k, hOffset).FormulaR1C1 = "=HYPERLINK(" & Chr(34) & "#'" & ws.Cells(i, 2) & "'!" & t(0) & "1" & Chr(34) & ",SUM(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & ")))"
                             Case 2
                                'myWrks.Cells(vOffset + k, hOffset).FormulaR1C1 = "=SUMIF(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & ")," & Chr(34) & t(1) & Chr(34) & ")"
                                myWrks.Cells(vOffset + k, hOffset).FormulaR1C1 = "=HYPERLINK(" & Chr(34) & "#'" & ws.Cells(i, 2) & "'!" & t(0) & "1" & Chr(34) & ",SUMIF(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & ")," & Chr(34) & t(1) & Chr(34) & "))"
                             Case 3
                                'myWrks.Cells(vOffset + k, hOffset).FormulaR1C1 = "=SUMIF(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(2) & ":" & t(2) & Chr(34) & "),RC[-2],INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & "))"
                                myWrks.Cells(vOffset + k, hOffset).FormulaR1C1 = "=HYPERLINK(" & Chr(34) & "#'" & ws.Cells(i, 2) & "'!" & t(0) & "1" & Chr(34) & ",SUMIF(INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(2) & ":" & t(2) & Chr(34) & "),RC[-2],INDIRECT(" & Chr(34) & ws.Cells(i, 2) & "!" & t(0) & ":" & t(0) & Chr(34) & ")))"
                            End Select
                            
                            'PaB 04.09.2019 - formati per hyperlinks
                            Application.CutCopyMode = False
                            myWrks.Cells(vOffset + k, 5).Select
                            Selection.Copy
                            myWrks.Cells(vOffset + k, hOffset).Select
                            Selection.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _
                                SkipBlanks:=False, Transpose:=False
                            Application.CutCopyMode = False
                            Selection.NumberFormat = "#,##0.00_ ;[Red]-#,##0.00 "

                        End If
                    Next
                End If
                If ws.Cells(i, 7) <> vbNullString Then
                    t = Split(ws.Cells(i, 7) & ",", ",")
                    myWrks.Cells(vOffset + k, 3) = t(0)
                    If UBound(t) > 1 Then
                        myWrks.Cells(vOffset + k, bOffset).FormulaR1C1 = u
'--------------------------------------------------------------
'   pulsanti nel foglio "Riepilogo"
'--------------------------------------------------------------
                        Set rng = myWrks.Range(myWrks.Cells(vOffset + k, bOffset), myWrks.Cells(vOffset + k, bOffset))
                        Set btn = myWrks.Buttons.Add(rng.Left + rng.Width - 10, rng.Top + 2, 8, rng.Height - 4)
                        With btn
                            .Caption = ""
                            .Name = "chkBtn_" & Format(i, "000")
                        End With
                        btn.Select
                        Selection.OnAction = "dynaFilter"
                    End If
            End If
            End If
        End If
        i = i + 1
    Wend
    
'--------------------------------------------------------------
'   pulsante di reset nel foglio "Riepilogo"
'--------------------------------------------------------------
    myWrks.Activate
    
    If k > 0 Then
        Set rng = ActiveSheet.Range(myWrks.Cells(vOffset - 2, bOffset), myWrks.Cells(vOffset - 2, bOffset))
        Set btn = ActiveSheet.Buttons.Add(rng.Left + 1, rng.Top + 1, rng.Width - 2, rng.Height - 2)
        With btn
            .Caption = ""
            .Name = "chkBtn_000"
        End With
        btn.Select
        Selection.OnAction = "dynaFilter"
    End If
    
    ActiveSheet.Cells(1, 1).Select
    
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
        
End Function

Private Function autoSave(wRules As Worksheet, Optional bSkipDialogs As Boolean) As Boolean
'Paolo Bettazzi
'ADP ESI Italy - Luglio 2016
    
    Const ThisProcedureName = "autoSave"
    On Error GoTo ErrHandler

    Dim myWrks As Worksheet
    Dim offset
    
    ' PaB 23.09.2019 trs80-basic variable names :
    Dim a() 'array
    Dim b, c, g, h 'boolean
    Dim i, j, k, l 'indexes
    Dim m, n, o, p 'values
    Dim q, r, s, t, u, v 'strings
    Dim w, x, y, z 'values
    
    autoSave = False
    offset = 0
    
    'PaB 23.09.2019
    g = False ' True when autosave can be done (but still leaving the final decision to the user)
    h = False ' True when autosave happens inside CSContainer
    r = vbNullString ' output disk
    v = vbNullString ' name of the control to be saved
    
    i = 2
    While wRules.Cells(i, offset + 1) <> vbNullString
        If Trim(LCase(wRules.Cells(i, offset + 1))) = "myname" Then
            
            'PaB 23.09.2019 - sauvegarde of folder name ..
            If wRules.Cells(i, offset + 3) = vbNullString Then
                wRules.Cells(i, offset + 3) = wRules.Cells(i, offset + 2)
            End If
            
            'PaB 23.09.2019 - managing personalized names.
            If LCase(wRules.Cells(i, offset + 6)) = "local" Then
                ' f24mese, CUD-xxx etc. stay confined to c:\controlli
            Else
                ' PaB 2016 - trick.
                ' When the input name contains "MGC "
                ' then the "myName" rule is overriden with the string included between "MGC " and "-".
                ' "MGC " can be put into the name by the user at launch, or can be configured in ERR002.
                If LCase(ActiveWorkbook.Name) Like "*ctr*mgc *-*-*.xlsm" Then ' (new NC-aware pattern)
                    l = InStrRev(LCase(ActiveWorkbook.Name), "mgc ")
                    m = InStr(l + 4, LCase(ActiveWorkbook.Name), "-")
                    If l > 0 And m > l Then
                        wRules.Cells(i, offset + 2) = Mid(LCase(ActiveWorkbook.Name), l + 4, m - l - 4)
                    End If
                End If
                
                'PaB 23.09.2019, managing candidate path + name for autosave into CSContainer
                If UCase(ActiveWorkbook.Name) Like "P_*_FILE_NOE_CTR-*" And _
                   LCase(ActiveWorkbook.Path) Like "*cscontainer*payroll*" Then
                    h = True ' naming convention is on.
                    j = FreeFile()
                    s = ActiveWorkbook.Path & "\$$$dummy$$$" & Format(Now, "yyyhsy") & ".txt"
                    ' the truth moment
                    On Error Resume Next
                    Open s For Append As j
                    If Err.Number = 0 Then
                        Close #j
                        Kill s
                        g = True ' CSContainer is enabled (first check)
                    Else
                        Err.Clear
                    End If
                    On Error GoTo ErrHandler
                    If g Then
                        g = False
                        For Each myWrks In ActiveWorkbook.Worksheets
                            If LCase(myWrks.Name) = "periodo" And Not g Then
                                l = InStr(ActiveWorkbook.Name, "_FILE_NOE_CTR")
                                v = ActiveWorkbook.Path & "\" _
                                  & Left(ActiveWorkbook.Name, l + 13) _
                                  & Format(myWrks.Cells(2, "B"), "0000") _
                                  & "-" & LCase(wRules.Cells(i, offset + 2)) _
                                  & ".xlsm"
                                g = True ' CSContainer is enabled (double check) - end of cycling thru sheets.
                            End If
                        Next
                    End If
                End If
            End If
            
            If Not g Then
            'PaB 23.09.2019 : prepare legacy naming convention (i.e. autoSave into c:\controlli)
                
                'PaB 17.02.2018, multiple disk tries (Allianz)
                b = False
                For Each r In Split("c,d,e,f,g", ",")
                    If Not b Then
                        j = FreeFile()
                        On Error Resume Next
                        Open r & ":\controlli\$$$dummy$$$.txt" For Append As j
                        If Err.Number = 0 Then
                            b = True
                            s = r & ":\controlli\"
                            Close #j
                            Kill r & ":\controlli\$$$dummy$$$.txt"
                        Else
                            Err.Clear
                        End If
                        On Error GoTo ErrHandler
                    End If
                Next
            
                'PaB 27.08.2016 - path & name composition
                If b Then
                ' can write
                    For Each myWrks In ActiveWorkbook.Worksheets
                        If LCase(myWrks.Name) = "periodo" And Not g Then
                            Debug.Assert Not DEBUGGING
                            t = Trim(LCase(myWrks.Cells(2, "A")))
                            If Len(t) > 3 And (t Like "*[ax]es") Then
                            'ADP internal USER, strip 3 chr queue
                                s = s & Left(t, Len(t) - 3) & "\"
                            ElseIf t Like "[0-9]*" Then
                            'ZADIG / ZXP USER, build Client name
                                s = s & "PAC " & Format(t, "000") & "\"
                            Else
                            'Delivery USER, build Client name
                                s = s & t & "\"
                            End If
                            t = myWrks.Cells(2, "E")
                            'PERIODO_A must be not empty and must be a true date (or whatever)
                            If Len(t) = 10 Then
                                s = s & Right(t, 4) & "\" 'year
                                If Trim(LCase(wRules.Cells(i, offset + 3))) > vbNullString Then
                                    s = s & Trim(LCase(wRules.Cells(i, offset + 3))) & "\" 'directory name
                                Else
                                    s = s & Trim(LCase(wRules.Cells(i, offset + 2))) & "\" 'directory name same as sheet name
                                End If
                                j = InStrRev(LCase(ActiveWorkbook.Name), ".xls")
                                
                                'PaB 27.08.2016 nomenclatura ad hoc per F24 MESE ...
                                If LCase(wRules.Cells(i, offset + 2)) = "f24mese" Then
                                    s = s & Left(myWrks.Cells(2, "A"), Len(myWrks.Cells(2, "A")) - 3) & "_F24MESE_" 'group & ctl name
                                    s = s & Format(myWrks.Cells(2, 2), "0000") & "_" 'company ID
                                    s = s & Format(myWrks.Cells(2, 5), "yyyymm") & "_" 'ending analysis period
                                    s = s & ".xlsm" 'desinenza
                                Else
                                ' nomenclatura default per tutti gli altri controlli
                                    ' PaB 23.09.2019 WAS :
                                    'If LCase(ActiveWorkbook.Name) Like "???_mgc *-*-*.xlsm" Then ' old AD pattern
                                    '    t = Split(LCase(ActiveWorkbook.Name), "-")
                                    '    wRules.Cells(i, offset + 2) = Mid(t(0), 9, 99)
                                    'End If
                                    ' PaB 23.09.2019 NOW IS :
                                    If LCase(ActiveWorkbook.Name) Like "*ctr*mgc *-*-*.xlsm" Then ' new NC-aware pattern
                                        l = InStrRev(LCase(ActiveWorkbook.Name), "mgc ")
                                        m = InStr(l + 4, LCase(ActiveWorkbook.Name), "-")
                                        If l > 0 And m > l Then
                                            wRules.Cells(i, offset + 2) = Mid(LCase(ActiveWorkbook.Name), l + 4, m - l - 4)
                                        End If
                                    End If
                                    ' PaB 23.09.2019 - FINE
                                    s = s & Format(myWrks.Cells(2, "B"), "0000") & "-" 'company ID
                                    s = s & Format(myWrks.Cells(2, "E"), "yyyymm") & "-" 'ending analysis period
                                    s = s & Trim(LCase(wRules.Cells(i, offset + 2))) 'control name
                                    s = s & Mid(ActiveWorkbook.Name, j, 99) 'desinenza
                                End If
                                ' the truth moment
                                g = True
                                v = s
                            End If
                        End If
                    Next
                End If
            End If
            ' no more cycling thru sheets
            i = 11235
        End If
        i = i + 1
    Wend
                        
    ' PaB 23.09.2019
    
    ' g boolean says that I have prepared a valid candidate filename (be it in CSContainer or c:\controlli)
    ' v string contains the valid candidate filename (be it in CSContainer or c:\controlli)
    ' h boolean says that I am in CSContainer context.
    
    If g And v <> vbNullString Then
    ' Can suggest autosave ...
    ' PaB 16.10.2019 robot tweak
        If h Or bSkipDialogs Then
            ' don't ask
            b = True
        Else
            ' ask
            b = (MsgBox("Salvare il controllo in " & v & " ?", vbYesNo, ThisProcedureName) = vbYes)
        End If
        
        If b Then
        
            ' prepare deletion list
            ' using original naming convention of Adempimenti
            ' ATTENTION POINT : => conventions here are a reply of above logic ("Siphon" function).
            ' TODO : in "Siphon" function we should prepare an in-memory map of input filenames,
            ' maybe we could persist the map in some place in "rules" sheet
            ' and then we should navigate it here without doubling the logic.
            
            ' PaB 18.09.2019 naming convention : no "_" only "-" and "_"
            If ActiveWorkbook.Name Like "P_*_FILE_NOE_CTR-*" Then 'naming convention
                l = InStrRev(ActiveWorkbook.Name, "-") ' var l = position of sequence number
                If l = 0 Then k = 0 Else k = InStrRev(Left(ActiveWorkbook.Name, l - 1), "--") ' var k = right limit of company code
                If k = 0 Then j = 0 Else j = InStrRev(Left(ActiveWorkbook.Name, k - 1), "-") ' var j = left limit of company code
            Else
                l = InStrRev(ActiveWorkbook.Name, "_") ' var l = position of sequence number
                If l = 0 Then k = 0 Else k = InStrRev(Left(ActiveWorkbook.Name, l - 1), "-") ' var k = right limit of company code
                If k = 0 Then j = 0 Else j = InStrRev(Left(ActiveWorkbook.Name, k - 1), "-") ' var j = left limit of company code
            End If

            t = vbNullString
            If (j > 0 And k > j And l > k) Then
                t = Dir(ActiveWorkbook.Path & "\" _
                  & Left(ActiveWorkbook.Name, j) & "*" _
                  & Mid(ActiveWorkbook.Name, k, l - k - 0) & "*")
            End If
            k = 0
            ReDim a(1 To 1)
            While Len(t) > 0
                If Not LCase(t) Like "*chk*.xlsm" Then
                    k = k + 1
                    ReDim Preserve a(1 To k)
                    a(k) = ActiveWorkbook.Path & "\" & t
                End If
                t = Dir
            Wend
            
            'PaB 23.09.2019
            ' verificaCartella creates folders if they do not exist !!!
            ' it works only outside of CSContainer.
            If Not h Then
                j = InStrRev(v, "\")
                verificaCartella CStr(Left(v, j))
            End If
            
            ' rename current Workbook
            On Error Resume Next
            ActiveWorkbook.SaveAs v
            
            If Err.Number = 0 Then 'save successful (not aborted by user)
                
                If LCase(ActiveWorkbook.Path & "\" & ActiveWorkbook.Name) = LCase(v) Then
                    autoSave = True
                    'swipe away input files ...
                    For k = 1 To UBound(a)
                        Kill a(k)
                    Next
                End If
                
            End If
            
            Err.Clear
            On Error GoTo ErrHandler
        
        End If
    End If
    
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
    
End Function

Private Sub verificaCartella(sCartella As String)
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "verificaCartella"
    On Error GoTo ErrHandler
    'Debug.Assert Not DEBUGGING

    Dim sDrive As String
    Dim nPos As Integer
    Dim livello(5) As String
    Dim xPath As String
    Dim i As Integer
    Dim nFine As Integer
    
    sDrive = Left(sCartella, 2)
    nPos = 1
    ChDir sDrive & "\"
    
    For i = 1 To 5
        nPos = InStr(nPos, sCartella, "\")
        If nPos = 0 Then Exit For
        nFine = InStr(nPos + 1, sCartella, "\")
        If nFine = 0 Then nFine = Len(sCartella) + 1
        livello(i) = Mid(sCartella, nPos + 1, nFine - nPos - 1)
        nPos = nFine
    Next i
    
    xPath = sDrive
    For i = 1 To 5
        If livello(i) = "" Then Exit For
        On Error Resume Next
        xPath = xPath & "\" & livello(i)
        ChDir xPath
        If Err.Number <> 0 Then
            MkDir livello(i)
            ChDir xPath
        End If
        On Error GoTo 0
    Next i

    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
    
End Sub


Private Function Num2Col(nC As Integer) As String
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "Num2Col"
    On Error GoTo ErrHandler
    'Debug.Assert Not DEBUGGING
    
    Dim i, j, s, t
    
    If nC < 1 Then nC = 1
    If nC > 256 Then nC = 256
    
    j = nC: s = vbNullString
    i = (nC - 1) \ 26
    j = nC Mod 26
    s = IIf(i > 0, Chr(Asc("A") + i - 1), vbNullString)
    t = IIf(j = 0, "Z", Chr(Asc("A") + j - 1))
        
    Num2Col = s & t

    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
    
End Function

Private Function Col2Num(sC As String) As Variant
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "Col2Num"
    On Error GoTo ErrHandler
    'Debug.Assert Not DEBUGGING
    
    Dim i, j, s, t
    
    i = 1 'default
    
    t = UCase(Right(sC, 1))
    If t >= "A" And t <= "Z" Then
        i = Asc(t) - Asc("A") + 1
    End If
        
    If Len(sC) > 1 Then
        t = UCase(Left(sC, 1))
        If t >= "A" And t <= "Z" Then
            j = (Asc(t) - Asc("A") + 1) * 26
            i = i + j
        End If
    End If
    
    If i < 1 Then i = 1
    If i > 256 Then i = 256
    
    Col2Num = i

    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If
    
End Function

Public Sub zPropagate()
'Paolo Bettazzi
'ADP ESI Italy - Giugno 2016
    
    Const ThisProcedureName = "Propagate"
    On Error GoTo ErrHandler
    
    zBuild False ' prima fa tutti gli altri
    zBuild True  ' poi fa s|fffd| stesso
    
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Public Sub zPromote()
'Paolo Bettazzi
'ADP ESI Italy - Giugno 2016
    
    Const ThisProcedureName = "Promote"
    On Error GoTo ErrHandler
    
    zBuild True ' fa solo s|fffd| stesso
    
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Sub zBuild(Optional bSingle As Boolean = False)
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014, Giugno 2016, Febbraio 2017
    
    Const ThisProcedureName = "zBuild"
    On Error GoTo ErrHandler

    Dim b
    Dim c
    Dim h, i, j, k, l
    Dim m As Long, n As Long, o As Long, p As Long, q As Long
    Dim s, t, u, v, w, ws
    Dim meWrkb As New Workbook
    Dim heWrkb As New Workbook
    Dim wRules As New Worksheet
    Dim wForm As New Worksheet
    
    Dim nF, sOutputFile
    
    Debug.Assert DEBUGGING And Not DEBUGGING
    
    MsgBox "Not authorized. Sorry."
    Exit Sub
    
    Set meWrkb = Application.ActiveWorkbook
    t = ActiveWorkbook.Name
    u = ActiveWorkbook.Path & "\"
    
    'PaB 05.08.2016
    ' protect mass make from wrong source.
    ' collective make should start ONLY from chkCKK.xlsm
    ' and chkCKK.xlsm workbook must not have in it any local Range Names.
    If bSingle Or LCase(t) = "chkckk.xlsm" Then
        'good
    Else
        MsgBox "Wrong workbook to begin with. Sorry."
        Exit Sub
    End If
    
    'PaB 27.06.2016
    ' begin setting working directory and checking its existence
    ' TODO : pass work directory as an optional parameter
    Const buildDirectory = "!build\"
    On Error Resume Next
    ChDir u & buildDirectory
    If Err.Number <> 0 Then
        MsgBox "Non hai creato la cartella " & u & buildDirectory
        Err.Clear
        GoTo ErrHandler
    Else
        ' mass make : cleanup build directory
        If Not bSingle Then
            s = Dir(u & buildDirectory)
            While s <> vbNullString
                Kill u & buildDirectory & s
                s = Dir()
            Wend
        End If
    End If
    Err.Clear
    On Error GoTo ErrHandler
    ChDir u
    
    Application.ScreenUpdating = False
    
    ' prepare trace / resource file
    sOutputFile = u & buildDirectory & Format(Now(), "yyyymmdd") & ".make_CHK.txt"
    nF = FreeFile()
    Open sOutputFile For Append As nF
    
    Print #nF, vbCrLf
    Print #nF, "-----------------------"
    Print #nF, "Build del " & Format(Now(), "dd/mm/yyyy hh:mm:ss")
    Print #nF, "-----------------------"
    Print #nF, vbCrLf
    
    ' prepare list of macro workbooks to be built
    ' TODO : maybe I could implement some kind of variable naming
    s = Dir(u & "chk?????.xlsm")
    
    m = 0 ' formula tally
    n = 0 ' range names tally
    o = 0 ' pivot, riep tally
    p = 0 ' workbook tally
    q = 0 ' column tally
    
    While s <> vbNullString
        'input : only new-style XLSM
        If LCase(Mid(s, InStrRev(s, ".") + 1)) Like "xlsm" Then
            ' exclude self when doing mass make.
            ' include ONLY self when doing single make.
            If (bSingle And UCase(s) = UCase(t)) Or _
               (Not bSingle And UCase(s) <> UCase(t)) Then
                
                Application.DisplayAlerts = True
                Application.ScreenUpdating = True
                Application.StatusBar = u & s
                DoEvents
                Application.ScreenUpdating = False
                Application.DisplayAlerts = False
                
                If bSingle Then
                    Set heWrkb = meWrkb
                Else
                    ' check workbook appropriateness :
                    ' must have "kernel" folder,
                    ' must have "rules" folder.
                    Set heWrkb = Application.Workbooks.Open(u & s, False)
                    On Error Resume Next
                    Set wRules = heWrkb.Worksheets("kernel")
                    If Err.Number = 0 Then Set wRules = heWrkb.Worksheets("rules")
                    If Err.Number > 0 Then
                        ' not a proper workbook
                        Err.Clear
                        GoTo ItsAShame
                    End If
                    On Error GoTo ErrHandler
                End If
                
                p = p + 1
                
                Print #nF, "File " & heWrkb.Name
                
                Print #nF, "-----------------------"
                
                ' Housekeeping : standardize contents of "rules" folder
                ' show warnings in debug window
                j = 2: b = False: v = vbNullString
                Set wRules = heWrkb.Worksheets("rules")
                While wRules.Cells(j, 1) <> vbNullString
                    DoEvents
                    'rename syphon to siphon
                    If Trim(LCase(wRules.Cells(j, 1))) = "syphon" Then
                        wRules.Cells(j, 1) = "siphon"
                    End If
                    ' prepare siphon map in v (a string containing comma separated sheet names)
                    If Trim(LCase(wRules.Cells(j, 1))) = "siphon" Then
                        v = v & "<" & Trim(wRules.Cells(j, 2)) & ">,"
                    End If
                    ' put "my name" in 2nd col
                    If Trim(LCase(wRules.Cells(j, 1))) = "myself" Then
                        wRules.Cells(j, 2) = s
                        b = True
                    End If
                    ' warning on 'mettiOggi' directive
                    If Trim(LCase(wRules.Cells(j, 1))) = "mettioggi" Then
                        Print #nF, "***" & heWrkb.Name & ":" & wRules.Cells(j, 1) & ":" & wRules.Cells(j, 2), _
                                   wRules.Cells(j, 3), wRules.Cells(j, 4), wRules.Cells(j, 7)
                    End If
                    ' warning on 'mettiDate' directive
                    If Trim(LCase(wRules.Cells(j, 1))) = "mettidate" Then
                        If wRules.Cells(j, 4) = vbNullString Then
                            Print #nF, "***" & heWrkb.Name & ":" & wRules.Cells(j, 1) & ":" & wRules.Cells(j, 2), _
                                       wRules.Cells(j, 3), wRules.Cells(j, 4), wRules.Cells(j, 7)
                        End If
                    End If
                    ' tally + print columns
                    If Trim(LCase(wRules.Cells(j, 1))) = "replicacelle" Then
                        If Trim(LCase(wRules.Cells(j, 7))) Like "*all*" Then
                            ' tally formulas
                            m = m + Col2Num(wRules.Cells(j, 5)) - Col2Num(wRules.Cells(j, 3)) + 1
                            ' print formulas
                            On Error Resume Next
                            Set wForm = heWrkb.Sheets(CStr(wRules.Cells(j, 2)))
                            If Err.Number = 0 Then ' sheet exists
                                On Error GoTo ErrHandler
                                For h = Col2Num(wRules.Cells(j, 3)) To Col2Num(wRules.Cells(j, 5))
                                    Print #nF, heWrkb.Name & ":" & wForm.Name & ":" _
                                             & Num2Col(CInt(h)) & ":(" & Trim(wForm.Cells(wRules.Cells(j, 4) - 1, h).Text) _
                                             & "):" & Trim(wForm.Cells(wRules.Cells(j, 4), h).FormulaR1C1)
                                Next
                            End If
                            Err.Clear
                            On Error GoTo ErrHandler
                        Else
                            ' tally columns
                            q = q + Col2Num(wRules.Cells(j, 5)) - Col2Num(wRules.Cells(j, 3)) + 1
                        End If
                    End If
                    ' tally range names in sheets
                    If Trim(LCase(wRules.Cells(j, 1))) = "mettinome" Then
                        n = n + 1
                    End If
                    ' tally strange operations in sheets
                    If Trim(LCase(wRules.Cells(j, 1))) Like "crea*" Then
                        o = o + 1
                    End If
                    
                    j = j + 1
                Wend
                If Not b Then
                ' "myself" tag not found : add it
                    wRules.Cells(j, 1) = "mySelf"
                    wRules.Cells(j, 2) = s
                End If
                
                Print #nF, "-----------------------"
                
                ' Check residual anomalies in names list, rules folder, etc.
                For Each l In heWrkb.Names
                    If LCase(l.RefersTo) Like "*c:\*" Then
                        Print #nF, heWrkb.Name, l.Name, l.RefersTo, ": removed"
                        l.Delete
                    ElseIf l.Name = "quickGuide" Then
                        l.RefersTo = "=rules!$R$2:$Z$30"
                    ElseIf LCase(l.RefersTo) Like "*rules*" Then
                        'fix quickGuide
                        If Right(l.RefersTo, 2) <> "20" Then
                            'Print #nF, heWrkb.Name, l.RefersTo, ": wrong!"
                        End If
                    End If
                Next
                
                ' List riepilogo folders (TODO : comment it out)
                For Each l In heWrkb.Worksheets
                    If LCase(l.Name) Like "*riepilogo*" Then
                        Print #nF, heWrkb.Name, "contains", l.Name
                    End If
                Next
                
                If Not bSingle Then
                ' copy legend
                    heWrkb.Sheets("rules").Range("R1:Z30").UnMerge
                    meWrkb.Sheets("rules").Range("R1:Z30").Copy
                    heWrkb.Sheets("rules").Range("R1").PasteSpecial xlPasteAll
                ' copy kernel folder to target workbook
                    heWrkb.Sheets("kernel").Delete
                    meWrkb.Sheets("kernel").Copy Before:=heWrkb.Sheets("rules")
                    heWrkb.Sheets("kernel").Activate
                'save target worksheet in original (dev) directory
                    heWrkb.Save
                End If
                
                ' copy target worksheet in XLSM format in build directory
                heWrkb.SaveAs _
                  Filename:=u & buildDirectory & s, _
                  FileFormat:=xlOpenXMLWorkbookMacroEnabled, _
                  CreateBackup:=False, _
                  ConflictResolution:=xlLocalSessionChanges
                
                ' clean target XLS format : remove names
                ' 1st round - not necessary - falsified
                ' (next purge takes care of all names)
                Set wRules = heWrkb.Worksheets("rules")
                i = 2
                While wRules.Cells(i, 1) <> vbNullString And False
                    DoEvents
                    If Trim(LCase(wRules.Cells(i, 1))) = "mettinome" Then
                        On Error Resume Next
                        heWrkb.Names(Trim(wRules.Cells(i, 7))).Delete
                        On Error GoTo ErrHandler
                    End If
                    i = i + 1
                Wend
                ' clean target worksheet for XLS format : residual names
                For Each ws In heWrkb.Names
                    'Print #nF, ws.Name
                    If Not ws.Name Like "_xl*" Then ws.Delete
                Next
                
                ' clean target XLS format : remove sheets
                If Len(v) > 0 Then
                    For Each ws In heWrkb.Worksheets
                        If bSingle And ws.Name = "kernel" Then
                            'cannot shoot himself !
                        ElseIf v Like "*<" & Trim(ws.Name) & ">,*" Then
                            'preserve data sheets
                            'remove all FormulaR1C1 text
                            On Error Resume Next
                            If ws.Cells.SpecialCells(xlCellTypeFormulas).Count > 0 Then
                                If Err.Number = 0 Then
                                    For Each c In ws.Cells.SpecialCells(xlCellTypeFormulas).Cells
                                        c.FormulaR1C1 = vbNullString
                                    Next c
                                End If
                            End If
                            On Error GoTo ErrHandler
                        Else
                            'kill any other sheet
                            ws.Delete
                        End If
                    Next
                End If
                
                Print #nF, "-----------------------"
                ' list remaining sheets (useful to check ERR003 compilation)
                For Each ws In heWrkb.Worksheets
                    Print #nF, "datasheet - " & heWrkb.Name & ":" & ws.Name
                Next
                
                ' save clean XLS worksheet in build directory
                heWrkb.SaveAs _
                  Filename:=u & buildDirectory & Left(s, Len(s) - 1), _
                  FileFormat:=xlExcel8, _
                  CreateBackup:=False, _
                ReadOnlyRecommended:=False
                
                ' put out warning
                If bSingle Then
                    MsgBox "warn - you're now using the stripped down, build directory version - don't work on THIS !!! Close. "
                Else
                    heWrkb.Close True
                End If
                
                Application.DisplayAlerts = True
                
                Set wRules = meWrkb.Worksheets("kernel")
                wRules.Activate
                
                Print #nF, "-----------------------"
                
            End If
        End If
ItsAShame:
        s = Dir()
    Wend
    
    Print #nF, vbCrLf
    Print #nF, "-----------------------"
    Print #nF, "  Workbook   Tally : " & p & vbCrLf _
             & "  Column     Tally : " & q & vbCrLf _
             & "  Formula    Tally : " & m & vbCrLf _
             & "  RangeNames Tally : " & n & vbCrLf _
             & "  Pivot,Riep Tally : " & o
    Print #nF, "-----------------------"
    Print #nF, vbCrLf
    Print #nF, "Build end " & Format(Now(), "dd/mm/yyyy hh:mm:ss")
    Print #nF, "-----------------------"
    
    Close #nF
    
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    Err.Clear

ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Sub DoMG()
'Paolo Bettazzi
'ADP ESI Italy - Ottobre 2010, Marzo 2014
    
    Const ThisProcedureName = "DoMG"
    
    If DEBUGGING Then
        cmdGO.Enabled = True
        cmdGO.Visible = True
        ActiveWorkbook.Worksheets("rules").Visible = True
        ActiveWorkbook.Worksheets("kernel").Visible = True
        ActiveWorkbook.Worksheets("kernel").Cells(23, 23) = vbNullString
    End If
    
    Err.Clear
ErrHandler:
    
    If Err.Number <> 0 Then
        Debug.Assert Not DEBUGGING
        If MsgBox("Errore : Err=" & Err.Number & " - " & Err.Description, vbAbortRetryIgnore, ThisProcedureName) <> vbAbort Then
            Resume Next
        End If
    End If

End Sub

Private Function ValEx(theString As Variant) As Variant

'GF: Versione estesa della funzione Val
'    Rende la funzione indipendente dal separatore decimale

Const C_COMMA = ","
Const C_PERIOD = "."

Dim posDecSep As Long

    'PAB per eliminare errore 'Invalid use of NULL'
    ValEx = 0
    On Error Resume Next
    ValEx = Val(theString)
    
    If ValEx <> Int(ValEx) Then Exit Function
    
    posDecSep = InStr(theString, C_PERIOD)
    If posDecSep > 0 Then
        Mid(theString, posDecSep, 1) = C_COMMA
        ValEx = Val(theString)
    Else
        posDecSep = InStr(theString, C_COMMA)
        If posDecSep > 0 Then
            Mid(theString, posDecSep, 1) = C_PERIOD
            ValEx = Val(theString)
        End If
    End If

End Function








Attribute VB_Name = "Foglio8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Questa_cartella_di_lavoro"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Sub workbook_open()

Dim myWrkb As Workbook

Dim appo As String
Dim ws5 As Worksheet
Dim ws6 As Worksheet

Set myWrkb = ActiveWorkbook

Exit Sub

'TODO : throw away all this bad crap

Set ws5 = Sheets("database")
Set ws6 = Sheets("Istat")
    
i = 2

ws5.Activate
'    Selection.ClearContents

    If ws5.Range("A3") <> "" And ws5.Range("AH3").Value = "" Then
        xriga = ws5.Cells(Rows.Count, "A").End(xlUp).Row + 1
        ws5.Range("AH2:CU2").Select
        Selection.Copy
        StepRighedaCopiare = 100
        riga = 2
        'Do While riga < xriga
            'If riga + StepRighedaCopiare > xriga Then
            '    StepRighedaCopiare = xriga - riga
            'End If
            ws5.Range("AH" & CStr(riga) & ":CU" & CStr(xriga)).PasteSpecial xlPasteAll
            'riga = riga + StepRighedaCopiare
        'Loop
        
        riga = 2
        Do While riga < xriga
            'If riga + StepRighedaCopiare > xriga Then
            '    StepRighedaCopiare = xriga - riga
            'End If
            If Trim(ws5.Range("G" & CStr(riga))) <> "" Then
                ws5.Range("G" & CStr(riga)) = Trim(ws5.Range("G" & CStr(riga))) * 1
            End If
            riga = riga + 1
        Loop
        
        MsgBox "Agiornamento Formule Terminato!"
    End If
    Application.CalculateFullRebuild
    ws6.Activate
End Sub




' InQuest injected base64 decoded content
' bzWK

INQUEST-PP=macro
