Attribute VB_Name = "C_Selection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'' Class trims the range selected to within the used range when whole columns or rows are selected
'' Developed by Peter Tscherne - all rights reserved |fffd|
'' You are free to reuse or distribute any part of this code, as long as you reference and give credit to the originator

Private Cols As Integer
Private lngRows As Long
Private blnXs As Boolean
Private NewRng As Range
Public Property Let RngIn(rng As Range)
    Set NewRng = rng
End Property
Public Property Get RngIn() As Range
    Set RngIn = NewRng
End Property
Public Property Let RowsIn(RowsSelected As Long)
    lngRows = RowsSelected
End Property
Public Property Get RowsIn() As Long
    RowsIn = lngRows
End Property
Public Property Let ColsIn(colsSelected As Integer)
    Cols = colsSelected
End Property
Public Property Get ColsIn() As Integer
    ColsIn = Cols
End Property
Public Function RowCheck() As Boolean
Dim blnOver As Boolean
    If RowsIn > 65500 Then
        blnXs = True
         Else
        blnXs = False
    End If
    RowCheck = blnXs
End Function

Public Function rngOut_Address() As String
'Determine the range
Dim rng As Range
Dim lRows As Long
Dim iCols As Integer
Dim lTopRow As Long
Dim lBtmRow As Long
Dim iFCol As Integer
Dim iLCol As Integer

Set rng = ActiveSheet.UsedRange
lRows = rng.Rows.Count
iCols = rng.Columns.Count


'suggest range
If ColsIn < 256 And RowCheck = True Then
    'Trim the row range to the used range
    lTopRow = RngIn.Cells(1, 1).Row
    lBtmRow = rng.SpecialCells(xlCellTypeLastCell).Row
    iFCol = RngIn.Cells(1, 1).Column
    iLCol = iFCol + ColsIn - 1
    rngOut_Address = Range(Cells(lTopRow, iFCol), Cells(lBtmRow, iLCol)).Address
   ElseIf ColsIn < 256 And RowCheck = False Then
   'Use the selected range
    rngOut_Address = RngIn.Address
   ElseIf ColsIn > 256 And RowCheck = True Then
   'Trim the row and column range selected
    lTopRow = RngIn.Cells(1, 1).Row
    lBtmRow = rng.SpecialCells(xlCellTypeLastCell).Row
    iFCol = RngIn.Cells(1, 1).Column
    iLCol = rng.SpecialCells(xlCellTypeLastCell).Column
    rngOut_Address = Range(Cells(lTopRow, iFCol), Cells(lBtmRow, iLCol)).Address
   ElseIf ColsIn > 256 And RowCheck = False Then
   'Trim the column range selected
    lTopRow = RngIn.Cells(1, 1).Row
    lBtmRow = lTopRow + RowsIn - 1
    iFCol = RngIn.Cells(1, 1).Column
    iLCol = rng.SpecialCells(xlCellTypeLastCell).Column
    rngOut_Address = Range(Cells(lTopRow, iFCol), Cells(lBtmRow, iLCol)).Address
End If
End Function

Attribute VB_Name = "M_Dates"
Option Explicit

Sub findWeekends()

'''Procedure Finds weekend dates and changes their colour to red
On Error GoTo errorHandler
Dim rng As Range
Dim response
Dim intWeekday As Long
Dim Cell As Range
Dim i As Long

    Set rng = Range(strRange_Ref)

        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must make a Selection" _
                    & vbCrLf & "for 'routine' to work!"
                Exit Sub
                End If
    
        
                For Each Cell In rng
                     intWeekday = Weekday(Cell.Value)
                     If intWeekday = 1 Or intWeekday = 7 Then
                        ' Selected day is Sunday or Saturday [based on settings in Excel
                        'and on machine] so set text colour to red
                        Cell.Font.ColorIndex = 3
                     End If
                 Next Cell
 
 Exit Sub
errorHandler:
    If Err.Number = 13 Then
        MsgBox "Format selection is incorrect!" & vbCrLf & "Select Date Formats Only", vbExclamation, "Weekend Dates"
        Else:
        MsgBox Err.Description, vbCritical, "Error"
    End If
End Sub

Private Sub findWeekNo()
Dim rng As Range
Dim Cell As Range
Dim i As Long, response As Long

On Error GoTo errorHandler

response = MsgBox("Warning there is no undo for this operation" _
& vbCrLf & "Do you want to continue...?", vbExclamation + vbYesNo + vbDefaultButton2)
    If response = vbNo Then Exit Sub

    Set rng = Range(strRange_Ref)
        
         ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must make a Selection" _
                    & vbCrLf & "for 'routine' to work!"
                Exit Sub
                End If
    '' convert any formula derived dates into dates
    Application.ScreenUpdating = False
        For Each Cell In rng
            If IsDate(Cell.Value) Then
                Cell.Select
                Selection.Copy
                Selection.PasteSpecial Paste:=xlPasteValues
            End If
        Next Cell
    Application.ScreenUpdating = True
    
    '' convert date format to weeks
    For Each Cell In rng
        If IsDate(Cell.Value) Then
            Cell.Value = Format(Cell.Value, "ww")
            Cell.NumberFormat = "0"
        End If
    Next Cell
        
Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical
End Sub
Private Sub convertDate()
'' Convert Date to String
Dim rng As Range, Cell As Range
Dim strDate As String

    Set rng = Application.Selection
    
    For Each Cell In rng
        If VBA.IsDate(Cell.Value) Then
            strDate = Format(Cell.Value, "mmm-yy")
            Cell.NumberFormat = "@"
            Cell.Value = CStr(strDate)
        End If
    Next Cell

End Sub
Private Sub checkIfDates()
'''Converts Selected range to text and Cleans data
On Error GoTo errorHandler
Dim rng As Range
Dim strFormat As String
Dim Cell As Range
Dim i As Long
Dim response As Integer
            
            
    response = MsgBox("If selected item is not a date then cell will be highlighted", vbOKCancel + vbExclamation)
    
    If response = vbCancel Then Exit Sub
    
            ''' Send user mesage if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
            
        
        For Each Cell In rng
            If Cell.Value <> "" And Not VBA.IsDate(Cell.Value) Then
                Cell.Interior.ColorIndex = 22
            End If
        Next Cell
        
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"

End Sub

Private Sub convertMonth()
'''Converts Selected range to text and Cleans data

Dim rng As Range
Dim Cell As Range
Dim i As Long, response As Integer
Dim strDate As String
            
 On Error GoTo errorHandler
 
  response = MsgBox("Warning there is no undo for this operation" _
    & vbCrLf & "Date is converted to a text value in format 'mmm-yy'" & vbCrLf & "Do you want to continue...?", vbExclamation + vbYesNo + vbDefaultButton2)
    If response = vbNo Then Exit Sub
   
            ''' Send user message if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
            
        
        For Each Cell In rng
            If VBA.IsDate(Cell.Value) Then
                strDate = Format(Cell.Value, "mmm-yy")
                Cell.NumberFormat = "@"
                Cell.Value = CStr(strDate)
            End If
        Next Cell
        
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"

End Sub

Private Sub ConvertToDate()
Dim rng As Range
Dim Cell As Range
Dim strItem As String
Dim i As Long, response As Integer

On Error GoTo errorHandler

response = MsgBox("Warning there is no undo for this operation" _
& vbCrLf & "Do you want to continue...?", vbExclamation + vbYesNo + vbDefaultButton2)
    If response = vbNo Then Exit Sub
    
    ''' Send user message if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
    
    For Each Cell In rng
        strItem = Trim(Cell.Value)
        '' Convert String date to date Format
        
          If blndDate(strItem) = True Then
             If InStr(1, strItem, "/", vbTextCompare) = 3 _
                Or InStr(1, strItem, "-", vbTextCompare) = 3 Then
                On Error Resume Next 'Fool Excels American date format
                    Cell.Cut
                    Cell.NumberFormat = "dd/mm/yyyy"
                    Cell.Value = CDate(Cell.Value)
                    Cell.PasteSpecial xlPasteValues
                On Error GoTo 0
                '' If date format is "mmm-yy" then add "01-" to front
               ElseIf InStr(1, strItem, "-", vbTextCompare) = 4 Then
                    strItem = "01-" & strItem
                    Cell.Value = CStr(strItem)
                    Cell.NumberFormat = "dd/mm/yyyy"
                    Cell.Value = CDate(strItem)
               Else
                   MsgBox "Sorry, Macro does not recognise this text as a Date", vbExclamation
               End If
          End If
    Next Cell
 Exit Sub
errorHandler:
 MsgBox Err.Description
End Sub

Private Sub ReformatDate()
Dim rng As Range
Dim Cell As Range
Dim strItem As String
Dim i As Long, response As Integer

On Error GoTo errorHandler
    ''' Reformat 'yyyymmdd" to dd/mm/yyyy
   response = MsgBox("Warning there is no undo for this operation" _
& vbCrLf & "Do you want to continue...?", vbExclamation + vbYesNo + vbDefaultButton2)
    If response = vbNo Then Exit Sub
    
    ''' Send user message if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
    
    For Each Cell In rng
        strItem = Cell.Value
        strItem = Mid(strItem, 5, 2) & "/" & Right(strItem, 2) _
               & "/" & Left(strItem, 4)
        If VBA.IsDate(strItem) Then
            Cell.Value = strItem
        End If
    Next Cell
 Exit Sub
errorHandler:
 MsgBox Err.Description, vbExclamation, "Error Converting to Date"
 
End Sub
Private Sub ReformatNumDate()
Dim rng As Range
Dim Cell As Range
Dim strItem As String
Dim i As Long

On Error GoTo errorHandler
    ''' Reformat 'ddmmyy" or "dmmyy"to dd/mm/yy
    
    ''' Send user message if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
    
    For Each Cell In rng
        strItem = Cell.Value
            If Len(strItem) = 5 Then
                strItem = Left(strItem, 1) & "/" & _
                    Mid(strItem, 2, 2) & "/" & Right(strItem, 2)
              ElseIf Len(strItem) = 6 Then
                strItem = Left(strItem, 2) & "/" & Mid(strItem, 3, 2) _
                    & "/" & Right(strItem, 2)
            End If
                    Cell.Value = CStr(strItem)
                    Cell.NumberFormat = "dd/mm/yyyy"
                    Cell.Value = CDate(strItem)
    Next Cell
 Exit Sub
errorHandler:
 MsgBox Err.Description, vbExclamation, "Error Converting to Date"
End Sub
Public Function blndDate(strvalue As String) As Boolean
''' determines if a date exists in any format
   If VBA.IsDate(strvalue) Then
        blndDate = True
   End If
End Function

Private Sub convertAmerican()
'''Converts American date string from mm/dd/yy to dd/mm/yy

Dim rng As Range
Dim Cell As Range
Dim i As Long, response As Integer
Dim strDate As String
Dim c_Date As c_Ref
            
 On Error GoTo errorHandler
 
  response = MsgBox("Warning there is no undo for this operation" _
    & vbCrLf & "Convert mm/dd/yy to dd/mm/yy" & vbCrLf & "Do you want to continue...?", vbExclamation + vbYesNo + vbDefaultButton2)
    If response = vbNo Then Exit Sub
   
            ''' Send user message if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
            
         Set c_Date = New c_Ref
        
        For Each Cell In rng
                strDate = c_Date.USDate(Cell.Value)
            If VBA.IsDate(strDate) Then
                Cell.Value = CDate(strDate)
            End If
        Next Cell
        
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"

End Sub


Private Sub convertDateString()
'''Converts string from dd.mm.yy to dd/mm/yy

Dim rng As Range
Dim Cell As Range
Dim i As Long, response As Integer
Dim strDate As String
Dim c_String As c_Ref
            
 On Error GoTo errorHandler
 
  response = MsgBox("Warning there is no undo for this operation" _
    & vbCrLf & "Convert string date to date" & vbCrLf & "Do you want to continue...?", vbExclamation + vbYesNo + vbDefaultButton2)
    If response = vbNo Then Exit Sub
   
            ''' Send user message if more than one area is selected
            Set rng = Range(strRange_Ref)
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with values" _
                    & vbCrLf & "for 'routine' to work!"
                 Exit Sub
                End If
            
         Set c_String = New c_Ref
        
        For Each Cell In rng
            
                strDate = c_String.AUDate(Cell.Value)
           If VBA.IsDate(strDate) Then
                Cell.Value = CDate(strDate)
            End If
        Next Cell
        
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"

End Sub
Attribute VB_Name = "M_Duplicates"
Option Explicit

Private Sub RemoveTheDupes()
''' Finds Duplicates in first column
Dim rng As Range
Dim Cell As Range
Dim strCode() As String
Dim i As Long
Dim k As Long
Dim r As Long
Dim strAdd As String
Dim response As Long
Dim blnCase As Boolean


On Error GoTo errorHandler
''' Turn off screen updating to speed up process
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

    

        ''' To prevent program crash determine whether sheet is protected
        If ActiveSheet.ProtectContents = True Then MsgBox "Sheet is Protected": Exit Sub
        Set rng = Range(strRange_Ref)

            ''' Detrmine number of rows/Cells in range
            r = rng.Rows.Count
            
            
            ReDim strCode(r) ''' Redimension the array
            
            ''Prompt for a case sensitve search
            response = MsgBox("Ignore Case...", vbYesNo + vbExclamation)
            If response = vbYes Then
                blnCase = True
               Else: blnCase = False
            End If
            
            ''' Load Cell values into array and memory
            i = 0
                For Each Cell In rng
                    i = i + 1
                    If blnCase = False Then
                         strCode(i) = Cell.Value
                       Else
                         strCode(i) = UCase(Cell.Value)
                     End If
                Next Cell
                
                    ''' for each value in array compare cell values
                    ''' assign variable 'k' to value
                    ''' if same value occurs more than once then K > 1
                    ''' if so then remove row
                        For i = 1 To r
                            k = 0  ''' reset K once value has been compared with each cell
                            For Each Cell In rng
                                If blnCase = False Then
                                    If Cell.Value = strCode(i) Then
                                        k = k + 1
                                            If k > 1 Then Cell.EntireRow.Delete
                                    End If
                                   ElseIf blnCase = True Then
                                    If UCase(Cell.Value) = strCode(i) Then
                                        k = k + 1
                                            If k > 1 Then Cell.EntireRow.Delete
                                    End If
                                End If
                            Next Cell
                                Application.StatusBar = "Comparing Cell: " & i & " of " & r
                        Next i
        
''' Reset Screen updating and status bar
Application.StatusBar = ""
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic

Exit Sub

errorHandler:
    If Err.Number = 9 Then
        MsgBox "Selection single column range only", vbInformation
    Else
      MsgBox "Error Description:" & Err.Description & vbCrLf & "Error Number: " _
        & Err.Number, vbCritical, "Error"
    End If
End Sub
Private Sub ColourDupes()
''' Finds Duplicates in first column
Dim rng As Range
Dim Cell As Range
Dim strCode() As String
Dim i As Long
Dim k As Long
Dim r As Long
Dim strAdd As String
Dim response As Long
Dim blnCase As Boolean
Dim NewRange As Range
Dim cSel As C_Selection
On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    

''' Turn off screen updating to speed up process
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual
        
        
            
        ''Prompt for a case sensitve search
        response = MsgBox("Ignore Case...", vbYesNo + vbExclamation)
            If response = vbYes Then
                blnCase = True
               Else: blnCase = False
            End If
            
            ''' Load Cell values into array and memory
            i = 0
                For Each Cell In NewRange
                    If blnCase = False And Cell.Value <> "" Then
                        i = i + 1
                        ReDim Preserve strCode(i) ''' Redimension the array
                        strCode(i) = Cell.Value
                       ElseIf blnCase = True And Cell.Value <> "" Then
                        i = i + 1
                        ReDim Preserve strCode(i) ''' Redimension the array
                        strCode(i) = UCase(Cell.Value)
                     End If
                Next Cell
                
                ''' Detrmine number of rows/Cells in range
                r = UBound(strCode)
                    
                    ''' for each value in array compare cell values
                    ''' assign variable 'k' to value
                    ''' if same value occurs more than once then K > 1
                    ''' if so then remove row
                        For i = 1 To r
                            k = 0  ''' reset K once value has been compared with each cell
                            For Each Cell In NewRange
                                If blnCase = False Then
                                    If Cell.Value = strCode(i) And Cell.Value <> "" Then
                                        k = k + 1
                                            If k > 1 Then Cell.Interior.ColorIndex = 4
                                    End If
                                  ElseIf blnCase = True Then
                                    If UCase(Cell.Value) = strCode(i) And Cell.Value <> "" Then
                                        k = k + 1
                                            If k > 1 Then Cell.Interior.ColorIndex = 4
                                    End If
                                 End If
                            Next Cell
                                Application.StatusBar = "Comparing Cell: " & i & " of " & r
                        Next i

''' Reset Screen updating and status bar
Application.StatusBar = ""
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Exit Sub

errorHandler:
    If Err.Number = 9 Then
        MsgBox "Select a single column range and try again...", vbInformation
    Else
      MsgBox "Error Description:" & Err.Description & vbCrLf & "Error Number: " _
        & Err.Number, vbCritical, "Error"
    End If
End Sub
Private Sub FastRepeats()
' use Excels countif formula to to highlight all repeats
''' Finds Duplicates in first column
Dim rng As Range
Dim Cell As Range
Dim strItem As String
Dim NewRange As Range
Dim cSel As C_Selection

On Error GoTo errorHandler

''' Turn off screen updating to speed up process
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    
    For Each Cell In NewRange
        If Excel.WorksheetFunction.CountIf(NewRange, Cell.Value) > 1 Then
         Cell.Interior.ColorIndex = 4
        End If
    Next Cell
    

''' Turn off screen updating to speed up process
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

Exit Sub
errorHandler:
    If Err.Number = 9 Then
        MsgBox "Select a single column range and try again...", vbInformation
    Else
      MsgBox "Error Description:" & Err.Description & vbCrLf & "Error Number: " _
        & Err.Number, vbCritical, "Error"
    End If

End Sub

Private Sub ShowALLRepeatingValues()
    ''' Module highlights all duplicates including the first instance
    ''' of the recurring value
''' Finds Duplicates in first column
Dim rng As Range
Dim Cell As Range, rngDupe As Range
Dim i As Long, n As Long
Dim k As Long
Dim r As Long
Dim strAdd As String
Dim response As Long
Dim cSel As C_Selection
Dim NewRange As Range
Dim Coll As New Collection
Dim CollDupe As New Collection


On Error GoTo Error_Handler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)


''' Turn off screen updating to speed up process
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual
    ''Prompt for a case sensitve search
    response = MsgBox("Ignore Case...", vbYesNo + vbExclamation)
            If response = vbYes Then
                blnCaseRepeats = True
               Else: blnCaseRepeats = False
            End If
        ''' To prevent program crash determine whether sheet is protected
        If ActiveSheet.ProtectContents = True Then MsgBox "Sheet is Protected": Exit Sub
           
        '' Add range items to a collection removing duplicates
        On Error Resume Next
                    For Each Cell In NewRange
                           Coll.Add Cell.Value, CStr(Cell.Value)
                    Next Cell
        ''Search for items in collection and get count
        '' If count is > 1 then add to new collection of duplicates
                        r = NewRange.Rows.Count

                        For i = 1 To Coll.Count

                        k = 0  ''' reset K once value has been compared with each cell
                            For Each Cell In NewRange
                            
                                 If blnCaseRepeats = False Then
                                    If Cell.Value = Coll.item(i) Then ''' Determine duplicate values
                                        k = k + 1
                                            If k > 1 Then 'Cell.Interior.ColorIndex = 3
                                               n = n + 1 ' assign count of duplicates
                                               CollDupe.Add Cell.Value, CStr(Cell.Value)
                                            End If
                                    End If
                                  ElseIf blnCaseRepeats = True Then
                                    If UCase(Cell.Value) = UCase(Coll.item(i)) Then ''' Determine duplicate values
                                        k = k + 1
                                            If k > 1 Then 'Cell.Interior.ColorIndex = 3
                                               n = n + 1 ' assign count of duplicates
                                               CollDupe.Add Cell.Value, (CStr(Cell.Value))
                                            End If
                                    End If
                                  End If
                         Next Cell

                        Application.StatusBar = "Comparing items: " & i & " of " & Coll.Count
                       Next i
                       On Error GoTo 0
                       
            If n = 0 Then MsgBox "No Repeats found", vbExclamation: GoTo Exit_Handler
            
            '' Locate the repeats and colour the cells
            For i = 1 To CollDupe.Count
                For Each Cell In NewRange
                        ''For i = LBound(strDupe) To UBound(strDupe)
                          If blnCaseRepeats = False Then
                            If Cell.Value = CollDupe.item(i) And Cell.Value <> "" Then
                               Cell.Interior.ColorIndex = 4
                            End If
                           ElseIf blnCaseRepeats = True Then
                             If UCase(Cell.Value) = UCase(CollDupe.item(i)) And Cell.Value <> "" Then
                               Cell.Interior.ColorIndex = 4
                            End If
                          End If
                Next Cell
            Next i
            
        frmRepeats.Show 0
        
Exit_Handler:
''' Reset Screen updating and status bar
Application.StatusBar = ""
Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Exit Sub

Error_Handler:
    If Err.Number = 9 Then
        MsgBox "Select a single column range and try again...", vbInformation
    Else
      MsgBox "Error Description:" & Err.Description & vbCrLf & "Error Number: " _
        & Err.Number, vbCritical, "Error"
    End If
    
    
End Sub
Attribute VB_Name = "M_Fix"
Option Explicit
'Thanks to Jan Karel Pieterse to fix Excel
'http://www.jkp-ads.com/articles/keepuserformontop02.asp

Global Const GWL_HWNDPARENT As Long = -8 'Object variable to trigger application events

#If VBA7 Then
    Public mXLHwnd As LongPtr    'Excel's window handle
    Public mhwndForm As LongPtr  'The userform's window handle
    Public Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    #If Win64 Then
        Public Declare PtrSafe Function SetWindowLongA Lib "user32" Alias "SetWindowLongPtrA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
    #Else
        Public Declare PtrSafe Function SetWindowLongA Lib "user32" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
    #End If
    Public Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
#Else
    Public mXLHwnd As Long    'Excel's window handle
    Public mhwndForm As Long  'The userform's window handle

    Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

    Public Declare Function SetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

    Public Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
#End If



Attribute VB_Name = "M_Globals"
Option Explicit
Public strRange_Ref As String ' Value assigned from Form 'frmRange'
Public intMenuSelection As Integer 'Menu selection for form 'frmRange'
Public blnGuide As Boolean
Public intGroupIndex As Integer
Public sList() As Variant
Public iList As Integer
Public sHList() As Variant
Public iHList As Integer
Public iGColor As Integer
Public iGTop As Integer
Public iGBtm As Integer
Public cInst As New c_Install
Public Const ADDIN_NAME = "mightymacros..."
Public blnProtectme As Boolean
Public iClickColor As Integer
Public iClickDirection As Integer
Public iClicks As Integer
Public iTransRowOffset As Long 'Number of rows to  copy
Public iTransColumnOffset As Long 'First Column to transpose values to
Public blnTransSel As Boolean
Public blnTransClear As Boolean
Public blnTransReverse As Boolean
Public blnCaseRepeats As Boolean
Public sRun As String ' program name selection for frmSelectRange
Public blnCopyNew As Boolean ' used by class c_sheet

Attribute VB_Name = "M_Menus"
Option Explicit
Dim clsRow As New c_Sheet


Private Sub showGuide()
    Set clsRow.SheetApp = Application
    blnGuide = True
    CommandBars("Row").Controls("Guide Off...").Visible = True
    CommandBars("Row").Controls("Guide On...").Visible = False
End Sub
Private Sub HideGuide()
    
    blnGuide = False
  
    Call clearGuide
    CommandBars("Row").Controls("Guide Off...").Visible = False
    CommandBars("Row").Controls("Guide On...").Visible = True
    Set clsRow.SheetApp = Nothing
End Sub
Private Sub clearGuide()

    blnGuide = False
    
            On Error Resume Next
                ActiveSheet.Shapes("TopLine").Delete
                ActiveSheet.Shapes("BtmLine").Delete
            On Error GoTo 0
            
End Sub

 Private Sub ShowRxfrmFilter(control As IRibbonControl)
    frmFilter.Show 0
End Sub
   '' Shortcuts
Private Sub showRxfrmShortCuts(control As IRibbonControl)
    frmShortCuts.Show 0
End Sub
    ''Protect Sheets
Private Sub showRxfrmProtect(control As IRibbonControl)
    frmProtectSheets.Show 0
End Sub
    ''Multifind
Private Sub showRxfrmFind(control As IRibbonControl)
    frmFind.Show 0
End Sub
    '' MultiLookup
Private Sub showRxfrmLookup(control As IRibbonControl)
    frmMLookup.Show 0
End Sub
   '' Insert Rows
Private Sub showRxfrmInsert(control As IRibbonControl)
    frmInsert.Show 0
End Sub

Private Sub showRxfrmInsertText(control As IRibbonControl)
    '' MultiLookup
    frmInsertText.Show 0
End Sub
   '' Show Repeating Values
Private Sub showRxfrmGoToSheet(control As IRibbonControl)
    frmGoToSheet.Show 0
End Sub
Private Sub showRxfrmCase(control As IRibbonControl)
    frmCase.Show 0
End Sub
Private Sub showRxCleanText(control As IRibbonControl)
''    intMenuSelection = 4
''    frmRange.Show
Call CleanData
End Sub

Private Sub showRxRemoveGaps(control As IRibbonControl)
    intMenuSelection = 5
    frmRange.Show
End Sub
Private Sub showRxColourDuplicates(control As IRibbonControl)
    Application.Run ("ColourDupes")
End Sub

Private Sub showRxfrmRepeats(control As IRibbonControl)
Application.Run ("ShowALLRepeatingValues")
   '' Application.Run ("FastRepeats")
End Sub

Private Sub docSummary()
    Debug.Print ThisWorkbook.BuiltinDocumentProperties.item("comments")
End Sub
Private Sub ShowWeekends()
    intMenuSelection = 8
    frmRange.Show
End Sub
Private Sub ShowWeekNo()
    intMenuSelection = 9
    frmRange.Show
End Sub
Private Sub checkDates()
    intMenuSelection = 10
    frmRange.Show
End Sub
Private Sub conMonth()
    intMenuSelection = 11
    frmRange.Show
End Sub
Private Sub convStrDate()
    intMenuSelection = 12
    frmRange.Show
End Sub
Private Sub RefDate()
    intMenuSelection = 13
    frmRange.Show
End Sub
Private Sub ConvAmerican()
    intMenuSelection = 14
    frmRange.Show
End Sub
''ConvDateString
Private Sub ConvDateString()
    intMenuSelection = 15
    frmRange.Show
End Sub
Private Sub RemoveRx_Hyperlinks(control As IRibbonControl)
    Call removeLinks
End Sub
Private Sub CreateRx_Hyperlinks(control As IRibbonControl)
    intMenuSelection = 17
    frmRange.Show
End Sub
Private Sub showRxfrmPasteVisible(control As IRibbonControl)
    frmPasteVisible.Show 0
End Sub
Private Sub showRxfrmCellEdit(control As IRibbonControl)
    frmNewEditCells.Show 0
End Sub
Private Sub showRxfrmRounding(control As IRibbonControl)
    frmRounding.Show 0
End Sub
Private Sub showRxfrmFindReplace(control As IRibbonControl)
    frmfindReplace.Show 0
End Sub
Private Sub showRxfrmFindHdr(control As IRibbonControl)
    frmNavigator.Show 0
End Sub
Private Sub showRxfrmCellHide(control As IRibbonControl)
    frmCellHide.Show
End Sub
Private Sub showRxfrmMCol(control As IRibbonControl)
    frmMColumn.Show 0
End Sub
Private Sub showRxfrmColorClick(control As IRibbonControl)
    frmColorClick.Show 0
End Sub
Private Sub showRxfrmBookMark(control As IRibbonControl)
    frmBookMark.Show 0
End Sub
Private Sub showRxfrmDates(control As IRibbonControl)
    frmDate.Show 0
End Sub
Private Sub showRxfrmDelRows(control As IRibbonControl)
    frmDelRows.Show 0
End Sub
Private Sub showRxfrmRemoveSpaces(control As IRibbonControl)
    frmRemoveSpaces.Show 0
End Sub

Private Sub showRxfrmTranspose(control As IRibbonControl)
    frm_Transpose.Show 0
End Sub
Private Sub showRxfrmTrim(control As IRibbonControl)
    Application.Run ("CleanRange")
End Sub


Private Sub mightymacrosRx(control As IRibbonControl)

    Dim str As String
    '' Open mightymacros web page
    str = "https://www.mightymacros.net/"
    ThisWorkbook.FollowHyperlink Address:=str
   
End Sub
'frmCompareTables
Private Sub showRxfrmCompareTables(control As IRibbonControl)
    frmCompareTables.Show 0
End Sub
Private Sub showRxfrmSelectDown(control As IRibbonControl)
    frmSelectDown.Show 0
End Sub

Private Sub delInsertRows()
    CommandBars("Row").Controls("Insert_Row").Delete
End Sub

Private Sub showRxfrmRowCut(control As IRibbonControl)
    frmRowCut.Show 0
End Sub
Private Sub showRxfrmRowCopy(control As IRibbonControl)
    frmRowCopy.Show 0
End Sub

Private Sub showRxfrmRowPaste(control As IRibbonControl)
    frmRowPaste.Show 0
End Sub

Private Sub SaveRx_Copy(control As IRibbonControl)
    Call Save_Copy
End Sub

Private Sub CreateRxNewLink(control As IRibbonControl)
    Call CreateNewLink
End Sub

Private Sub RemoveRxLink(control As IRibbonControl)
    Call removeLinks
End Sub

Private Sub CleanRxRange(control As IRibbonControl)
    Call CleanRange
End Sub

Private Sub CleanRxData(control As IRibbonControl)
    Call CleanData
End Sub

Private Sub ProperRx_Con(control As IRibbonControl)
    Call Proper_Con
End Sub
Private Sub ClearRxFilters(control As IRibbonControl)
    Call ClearFilters
End Sub

Private Sub DeleteRxEmptyRows(control As IRibbonControl)
    Call DeleteEmptyRows
End Sub
Private Sub removeRx_Gaps(control As IRibbonControl)
    Call remove_Gaps
End Sub

Private Sub CapsRx_Con(control As IRibbonControl)
    Call Caps_Con
End Sub

Private Sub LCaseRx_Con(control As IRibbonControl)
    Call LCase_Con
End Sub
Private Sub RemoveRxSingleQuotes(control As IRibbonControl)
    Call RemoveSingleQuotes
End Sub
Private Sub DeleteRxNamedRanges(control As IRibbonControl)
    Call DeleteNamedRanges
End Sub

Private Sub RemoveRxDoubleQuotes(control As IRibbonControl)
    Call RemoveDoubleQuotes
End Sub

Private Sub HideRxColumns(control As IRibbonControl)
    Call HideColumns
End Sub

Private Sub showRxColumns(control As IRibbonControl)
    Call showColumns
End Sub

Private Sub ShowRxCreateTabs(control As IRibbonControl)
    Call CreateTabs
End Sub
Attribute VB_Name = "M_Misc"
Option Explicit
Sub Save_Copy()
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
Dim strFile As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If
    
    strFile = ActiveWorkbook.Name
    '' Check if workbook only
    If InStr(1, strFile, ".", vbTextCompare) = 0 Then
        MsgBox "Save and name file before saving copy", vbExclamation
    End If
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then ActiveWorkbook.SaveCopyAs .SelectedItems(1)
            End If
   End With

Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical
End Sub

Sub DeleteEmptyRows()
''' Delete empty rows on a worksheet
Dim lastRow As Long, r As Long
Dim response As Integer
On Error GoTo errorHandler
        
        
        response = MsgBox("Delete Empty Rows...", vbOKCancel + vbExclamation)
        
        If response = vbCancel Then Exit Sub
        MsgBox "Save a backup copy of your work"
        Call Save_Copy
        lastRow = ActiveSheet.UsedRange.Rows.Count
        lastRow = lastRow + ActiveSheet.UsedRange.Row - 1
        Application.ScreenUpdating = False
        
            For r = lastRow To 1 Step -1
                If WorksheetFunction.CountA(Rows(r)) = 0 Then Rows(r).Delete
            Next r
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub

Sub remove_Gaps()
''' Code removes all Spaces in Selection
    Dim rng As Range, Cell As Range
    
        Set rng = Range(strRange_Ref)
            
            For Each Cell In rng
                Cell.Replace What:=" ", Replacement:="", lookat:=xlPart
            Next Cell
        
End Sub
Sub Caps_Con()
'''Converts Text to Upper Case
Dim rng As Range
Dim strCase As String
Dim Cell As Range
Dim i As Long
Dim RngIn As Range

On Error GoTo errorHandler

        Set rng = Range(strRange_Ref)
    
        ''' Send user a message if more than one area is selected
            
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
         For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with text" _
                    & vbCrLf & "for 'routine' to work!"
                Exit Sub
                End If
    
    For Each Cell In rng
        strCase = UCase(Cell.Value)
        Cell.Value = strCase
    Next Cell
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"
End Sub
Sub LCase_Con()
'''Converts Text to Lower Case
Dim rng As Range
Dim strCase As String
Dim Cell As Range
Dim i As Long
On Error GoTo errorHandler

    Set rng = Range(strRange_Ref)
        ''' Send user mesage if more than one area is selected
          
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
     ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with text" _
                    & vbCrLf & "for 'routine' to work!"
                Exit Sub
                End If
    
    For Each Cell In rng
        strCase = LCase(Cell.Value)
        Cell.Value = strCase
    Next Cell
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"
End Sub
Sub Proper_Con()
'''Converts Text to Proper Case

Dim rng As Range
Dim strCase As String
Dim Cell As Range
Dim i As Long

On Error GoTo errorHandler
        ''' Set the range equal to the selection
            Set rng = Range(strRange_Ref)
        ''' Send user mesage if more than one area is selected
            
            If rng.Areas.Count > 1 Then
                MsgBox "Select only one area"
                Range("a1").Select
                Exit Sub
            End If
     
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        For Each Cell In rng
              If IsEmpty(Cell) Then i = i + 1
         Next Cell
         
        ''' If count of empty cells = cell count then
        ''' send message to make a selection
                If i = rng.Cells.Count Then
                 MsgBox "You must select cells with text" _
                    & vbCrLf & "for 'routine' to work!"
                Exit Sub
                End If
            
    For Each Cell In rng
        strCase = Application.WorksheetFunction.Proper(Cell.Value)
        Cell.Value = strCase
    Next Cell
    
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"
End Sub
Sub CleanData()
'''Converts Selected range to text and Cleans data
On Error GoTo errorHandler
Dim rng As Range
Dim Cell As Range
Dim cSel As C_Selection
Dim NewRange As Range

On Error GoTo errorHandler


    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
    
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
        
        For Each Cell In NewRange
           ' if not a date
          If VBA.IsDate(Trim(Cell.Value)) Then Exit Sub
             Cell.NumberFormat = "@"
             Cell.Value = Application.WorksheetFunction.Clean(Cell.Value)
             Cell.Value = Trim(Cell.Value)
        
        Next Cell
        
   Set cSel = Nothing
Exit Sub
errorHandler:
 MsgBox Err.Description, vbCritical, "Error"

End Sub

Sub InsertNew()
    SendKeys Chr(27), True
    Selection.Rows.Insert
End Sub
Sub removeLinks()
Dim rng As Range
Dim Cell As Range
Dim cSel As C_Selection
Dim NewRange As Range
Dim lColor As Long

On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
    
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    
    For Each Cell In NewRange
            If Cell.Interior.Color = -4142 Then 'blank
            Cell.Hyperlinks.Delete
        Else
            lColor = Cell.Interior.Color
            Cell.Hyperlinks.Delete
            Cell.Interior.Color = lColor
        End If
    Next Cell
 Exit Sub
errorHandler:
 MsgBox Err.Description
End Sub

Sub CreateNewLink()
Dim Cell As Range, rng As Range
''Create multiple Hyperlinks
On Error GoTo errorHandler
    Set rng = Range(strRange_Ref)
    For Each Cell In rng
        If Cell.Value <> "" Then
            Cell.Hyperlinks.Add Anchor:=Cell, Address:= _
            Cell.Value, TextToDisplay:=Cell.Value
        End If
    Next Cell
 Exit Sub
errorHandler:
 MsgBox Err.Description
End Sub


Sub CleanRange()
'Clears spaces around text
Dim rng As Range
Dim Cell As Range
Dim cSel As C_Selection
Dim cDat As c_Date
Dim NewRange As Range
Dim sDate As String

On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    Set cDat = New c_Date
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    
    For Each Cell In NewRange
        If IsDate(Cell.Value) Then
          sDate = Trim(Cell.Value)
          Cell.Value = cDat.GetDate(sDate)
        Else
          Cell.Value = WorksheetFunction.Clean(Trim(Cell.Value))
        End If
    Next Cell
    
    Set cSel = Nothing
    Set cDat = Nothing

Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation

End Sub

Sub ClearFilters()
Dim rng As Range
Dim i As Long

On Error GoTo errorHandler
' Sets or unsets filters on top row of used range
Dim iCol As Integer
Dim lRow As Long

iCol = ActiveSheet.UsedRange.SpecialCells(xlCellTypeLastCell).Column
lRow = ActiveSheet.UsedRange.Cells(1, 1).Row

    With ActiveSheet
        Set rng = Range(Cells(lRow, 1), Cells(lRow, iCol))
    End With
    
    'Set or unset Filter
     rng.AutoFilter

    
Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
    
End Sub

Sub RemoveSingleQuotes()
Dim rng As Range
Dim Cell As Range
Dim cSel As C_Selection
Dim NewRange As Range

On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    
    For Each Cell In NewRange
        Cell.Replace What:="'", Replacement:="", lookat:=xlPart
    Next Cell

Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
End Sub

Sub DeleteNamedRanges()
Dim nName As Name
Dim response As Integer
On Error GoTo errorHandler
    ' Deletes all named ranges in the activeWorkbook
    response = MsgBox("Remove all named ranges in workbook..", vbOKCancel + vbExclamation)
    If response = vbCancel Then Exit Sub
    
    For Each nName In Names
        ActiveWorkbook.Names(nName.Name).Delete
    Next
    
Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
End Sub
Sub RemoveDoubleQuotes()
' Uses Excel's subtitute function to remove Double Quotes
Dim rng As Range
Dim Cell As Range
   Dim cSel As C_Selection
Dim NewRange As Range

On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    
    For Each Cell In NewRange
            Cell.Value = WorksheetFunction.Substitute(Cell.Value, Chr(34), "")
        Next Cell
Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
End Sub

Sub HideColumns()
Dim rng As Range
Dim iCol As Long
Dim i As Long
Dim blnColored As Boolean
' Hide columns with unhighlighted cells in top row
On Error GoTo errorHandler

    Set rng = ActiveSheet.UsedRange
    iCol = rng.Columns.Count
    
    blnColored = False
    
    Application.ScreenUpdating = False
        'Check if any of the top row cells are highlighted
        For i = 1 To iCol
            If Cells(1, i).Interior.ColorIndex <> -4142 Then
              blnColored = True
              Exit For
            End If
        Next i
        
        ' Exit sub if there are no cells highlighted
        If blnColored = False Then Exit Sub
        
        For i = 1 To iCol
            If Cells(1, i).Interior.ColorIndex = -4142 Then
              Columns(i).Hidden = True
            End If
        Next i
    Application.ScreenUpdating = True
    
Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
End Sub

Sub showColumns()
Dim rng As Range
Dim iCol As Long
Dim i As Long
' Unhide columns with unhighlighted cells in top row
On Error GoTo errorHandler
    Set rng = ActiveSheet.UsedRange
    iCol = rng.Columns.Count
    
    Application.ScreenUpdating = False
        For i = 1 To iCol
            If Cells(1, i).Interior.ColorIndex = -4142 Then
              Columns(i).Hidden = False
            End If
        Next i
    Application.ScreenUpdating = True

Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
End Sub

Sub CreateTabs()
''' Create tabs based on selected column row values
Dim rng As Range
Dim Cell As Range
Dim response As Long
Dim NewRange As Range
Dim iCol As Integer
Dim cSel As C_Selection
Dim Coll As New Collection
Dim sName As String
Dim item As Variant
Dim i As Integer
Dim StrSheets() As String

On Error GoTo errorHandler
    Application.ScreenUpdating = False
    'Name of worksheet
    sName = ActiveSheet.Name
    'Determine the selected range
    Set rng = Application.Selection
    'Exit sub if more than one column is selected
    If rng.Columns.Count > 1 Then
            MsgBox "Please select a single column"
        Exit Sub
    ElseIf rng.Cells.Count <= 1 Then
            MsgBox "Please select a single column"
        Exit Sub
    End If
    
    'Update the range to the used range of visible cells
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    iCol = NewRange.Column
    
    
    ' Add Column values to an array
    Cells(2, iCol).Select
    ' Get a list of workbook tab names
    For i = 1 To ActiveWorkbook.Sheets.Count
        ReDim Preserve StrSheets(i)
        StrSheets(i) = ActiveWorkbook.Sheets(i).Name
    Next i
    
    ' Add items to the collection and check if sheet tab name exists, if so abort
    On Error Resume Next
        For Each Cell In NewRange
            If Cell.Row <> 1 Then
                If Cell.Value <> "" Then
                      Coll.Add Cell.Value, CStr(Cell.Value)
                    For i = LBound(StrSheets) To UBound(StrSheets)
                        If Cell.Value = StrSheets(i) Then
                            MsgBox "Operation terminated..." & vbCrLf & "Sheet name: " & StrSheets(i) & " Already Exist as a sheet tab name", vbExclamation
                        Exit Sub
                        End If
                    Next i
                End If
            End If
        Next Cell
    On Error GoTo 0
    'Throw warning if tabs > 50
    If Coll.Count > 30 And Coll.Count < 250 Then
            response = MsgBox("Do you really want to create: '" & Coll.Count & "' Sheet tabs", vbOKCancel + vbExclamation)
            If response = vbCancel Then Exit Sub
        ElseIf Coll.Count > 250 Then
             MsgBox "Sorry, the request exceeds the limit of sheets that can be created in a workbook"
            Exit Sub
    End If
    'Do not proceed if no duplicates were found
    If Coll.Count < 1 Then
        MsgBox "Not Duplicates Found", vbExclamation
        Exit Sub
    End If
        
        ' Provide a message on tabs numbers to create
        response = MsgBox("Create: '" & Coll.Count & "' Sheet tabs", vbOKCancel + vbExclamation)
            If response = vbCancel Then Exit Sub
      Sheets(sName).UsedRange.Select
      Selection.AutoFilter
    ' Create a new sheet for each purch Grp
    For Each item In Coll
        ' Filter duplicate sheet by Purch Grp
        ActiveSheet.UsedRange.AutoFilter Field:=iCol, Criteria1:=item
        ' Copy filtered items to a new worksheet
        Selection.Copy
        Sheets.Add After:=ActiveSheet
        ActiveSheet.Name = item
        ActiveSheet.Paste
        Columns("A:A").Select
        ' Auto fit and apply filters
        Range(Selection, Selection.End(xlToRight)).Select
        Selection.EntireColumn.AutoFit
        Selection.AutoFilter
        'Freeze top row
        Range("A2").Select
        With ActiveWindow
          .SplitColumn = 0
          .SplitRow = 1
        End With
        ActiveWindow.FreezePanes = True
        ' return to duplicate sheet and clear filters
        Sheets(sName).Select
        ActiveSheet.ShowAllData
    Next item
    
    Sheets(sName).Select
    Range("A1").Select
    
    Application.ScreenUpdating = True
    
    Exit Sub
errorHandler:
MsgBox "Error: " & Err.Description & vbCrLf _
& "Error Number: " & Err.Number, vbExclamation
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet15"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'' Developed by Peter Tscherne - all rights reserved |fffd|
'' You are free to reuse any of this code, but credit must be referenced to the originator
Option Explicit
Dim lStart As Long, lEnd As Long
Const START_SHEET = "Key"
Dim blnInstall As Boolean
Private Sub Workbook_AddinInstall()
On Error GoTo errorHandler
Dim rngAccept As Range
        Call Protectme
        With ThisWorkbook.Sheets("Lic")
             Set rngAccept = .Cells(1, 2)
             rngAccept.Value = ""
        End With
    frmFreeLic.Show
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub Workbook_AddinUninstall()
   
End Sub

Private Sub Workbook_BeforeClose(Cancel As Boolean)
   
End Sub

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
 ' ThisWorkbook.IsAddin = True
End Sub

Private Sub Workbook_Open()
    Dim rngAccept As Range
On Error GoTo errorHandler

    If blnProtectme = False Then Call Protectme
    With ThisWorkbook.Sheets("Lic")
      Set rngAccept = .Cells(1, 2)
    End With
    
    If rngAccept.Value = "No" Or rngAccept.Value = "" Then
        ' uninstall addin
      
        MsgBox "Open Add-Ins Menu and uninstall" & vbCrLf _
        & "From File menu or Office button select Options>Add-Ins>GO...)" & vbCrLf _
        & "Uncheck box next to 'Mightymacros_Utilities'" & vbCrLf _
        & "Refer uninstall instructions at site http://www.mightymacros.tools"
        ThisWorkbook.Close
     ElseIf cInst.Check_Install = False Then
          
    End If
 Exit Sub
 
 Set cInst = Nothing
errorHandler:
    MsgBox Err.Description
End Sub




Private Sub Protectme()
Dim i As Long
On Error GoTo errorHandler

If ThisWorkbook.VBProject.Protection = False Then
    '' Close all vbe windows enter shutdown mode
    For i = 1 To Application.VBE.Windows.Count
        Application.VBE.Windows(1).Close
    Next i
        Application.VBE.MainWindow.Visible = False
        blnProtectme = True
        frmProtect.Show
 End If
Exit Sub
errorHandler:
If Err.Number = 1004 Then
    MsgBox "Access to Visual Basic Project is not Trusted" & vbCrLf & _
    "For Excel 2003 go to the Tools menu then Security and then to Trusted Publishers" & vbCrLf & _
       "For later versions, open the Trust Centre>Trust Centre Settings from Options menu" & vbCrLf & _
       "Select Macro Settings and check option to trust access to (VBA)visual basic project" & vbCrLf & _
       "Close Excel and then re-open it with the new settings", vbExclamation
       ThisWorkbook.Close
     Else
    MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description
  End If
End Sub

Attribute VB_Name = "cPath"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Function GetPath() As String
    '''Open the file dialog Picker
Dim rng As Range
Dim strPath As String

On Error GoTo errorHandler
If val(Application.Version) < 10 Then
MsgBox "Excel 2002 or Later Required"
Exit Function
End If

    With Application.FileDialog(msoFileDialogFilePicker)
        .InitialFileName = Application.DefaultFilePath & "\"
        .Show
            If .SelectedItems.Count = 0 Then
                MsgBox "Cancelled"
            Else
                MsgBox .SelectedItems(1)
                
                GetPath = .SelectedItems(1)
            End If
    End With
Exit Function
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Function

Function GetFolder() As String
    '''Open the file dialog Picker
Dim rng As Range
Dim strPath As String

On Error GoTo errorHandler
If val(Application.Version) < 10 Then
MsgBox "Excel 2002 or Later Required"
Exit Function
End If

    With Application.FileDialog(msoFileDialogFolderPicker)
        .InitialFileName = Application.DefaultFilePath & "\"
        .Show
            If .SelectedItems.Count = 0 Then
                MsgBox "Cancelled"
            Else
                MsgBox .SelectedItems(1)
                
                GetFolder = .SelectedItems(1)
            End If
    End With
Exit Function
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Function


Attribute VB_Name = "c_Date"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function GetDate(ByVal strDate As String) As Long
''Convert String Date to standard date Format
Dim iDays As Integer, iMonths As Integer, iYears As Integer
Dim iPos1 As Integer, iPos2 As Integer, iLen As Integer
Dim dtArray As Variant
Dim strVar As String
Dim i As Integer

On Error GoTo errorHandler

    dtArray = Array(".", "/", "-")
    
    For i = 0 To UBound(dtArray)
        If InStr(1, strDate, dtArray(i), vbTextCompare) > 0 Then
            strVar = dtArray(i)
            Exit For
        End If
    Next i
    
    
    iPos1 = InStr(1, strDate, strVar, vbTextCompare)
    iLen = Len(strDate)
    iPos2 = iLen - InStr(1, StrReverse(strDate), strVar, vbTextCompare)
    
  If Application.International(xlDateOrder) = 0 Then
    '  mm/dd/yyyy
    iMonths = Left(strDate, iPos1 - 1)
    iDays = Mid(strDate, iPos1 + 1, iPos2 - iPos1)
    iYears = Right(strDate, iLen - iPos2 - 1)
  ElseIf Application.International(xlDateOrder) = 1 Then
    'dd/mm/yyyy
    iDays = Left(strDate, iPos1 - 1)
    iMonths = Mid(strDate, iPos1 + 1, iPos2 - iPos1)
    iYears = Right(strDate, iLen - iPos2 - 1)
  ElseIf Application.International(xlDateOrder) = 2 Then
    'yyyy/mm/dd
    iDays = Right(strDate, iLen - iPos2 - 1)
    iMonths = Mid(strDate, iPos1 + 1, iPos2 - iPos1)
    iYears = Left(strDate, iPos1 - 1)
  End If
    
    GetDate = DateSerial(iYears, iMonths, iDays)
    
Exit Function
errorHandler:
    MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description, vbCritical, "Error"
End Function

Attribute VB_Name = "c_Filter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public WithEvents SheetFilter As Application
Attribute SheetFilter.VB_VarHelpID = -1

Private Sub SheetFilter_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)
'' Apply visible cell to sheet selection
On Error GoTo errorHandler
  If Target.Cells.Count = 1 Then
        Target.Select
       Else
        Target.SpecialCells(xlCellTypeVisible).Select
   End If
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub
Attribute VB_Name = "c_Install"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public Function Check_Install() As Boolean
    Dim ctl As CommandBarControl
    Dim i As Long
    Dim cMenu As CommandBar
    Check_Install = False ''initialize
    Set cMenu = CommandBars("Cell")
        '' load control/macro names into drop-box
        For i = 1 To cMenu.Controls.Count
           If InStr(1, cMenu.Controls(i).Caption, ADDIN_NAME, vbTextCompare) > 0 Then
                Check_Install = True
            End If
        Next i
End Function
Public Function Check_Count() As Long
    Dim ctl As CommandBarControl
    Dim i As Long, n As Long
    Dim cMenu As CommandBar
    Check_Count = False ''initialize
    n = 0
    Set cMenu = CommandBars("Cell")
        '' load control/macro names into drop-box
        For i = 1 To cMenu.Controls.Count
           If InStr(1, cMenu.Controls(i).Caption, ADDIN_NAME, vbTextCompare) > 0 Then
                n = 1
            End If
        Next i
        Check_Count = n
End Function
Attribute VB_Name = "c_Ref"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public blnEnd As Boolean
Public Function blnR1C1(ByRef strStyle As String) As Boolean
''' Functions blnR1C1 & RefStyle to be  used in conjunction with RefEdit controls
''' to prevent runtime errors when R1C1 cell referencing is in use
Dim intPos As Integer

    intPos = InStr(1, strStyle, "!", vbTextCompare)
    intPos = intPos + 1
    
    ''' Determine if R1C1 reference style is in use
    If Mid(strStyle, intPos, 1) = "R" And InStr(intPos, strStyle, "C", vbTextCompare) > intPos + 1 Then
        blnR1C1 = True 'Convert R1C1 to A1)
       Else
        blnR1C1 = False
    End If

End Function

Public Function RefStyle(ByRef strStyle As String) As String
Dim intPos As Integer

    intPos = InStr(1, strStyle, "!", vbTextCompare)
    intPos = intPos + 1
    
    ''' Return xlA1 Reference address if R1C1 is in use
    If Mid(strStyle, intPos, 1) = "R" And InStr(intPos, strStyle, "C", vbTextCompare) > intPos + 1 Then
       RefStyle = Application.ConvertFormula(strStyle, xlR1C1, xlA1) 'Convert R1C1 to A1)
    End If
End Function

Public Function USDate(ByVal strDate As String) As Long
''Convert String Date avoiding American date Format
Dim iDays As Integer, iMonths As Integer, iYears As Integer
Dim iPos1 As Integer, iPos2 As Integer, iLen As Integer
Dim dtArray As Variant
Dim strVar As String
Dim i As Integer

On Error GoTo errorHandler
    blnEnd = False
    dtArray = Array(".", "/", "-")
    
    For i = 0 To UBound(dtArray)
        If InStr(1, strDate, dtArray(i), vbTextCompare) > 0 Then
            strVar = dtArray(i)
            Exit For
        End If
    Next i
    
    iPos1 = InStr(1, strDate, strVar, vbTextCompare)
    iLen = Len(strDate)
    iPos2 = iLen - InStr(1, StrReverse(strDate), strVar, vbTextCompare)
    iMonths = Left(strDate, iPos1 - 1)
    iDays = Mid(strDate, iPos1 + 1, iPos2 - iPos1)
    iYears = Right(strDate, iLen - iPos2 - 1)
   
    ''Debug.Print iYears & " - " & iMonths & " - " & iDays
    USDate = DateSerial(iYears, iMonths, iDays)

   
Exit Function
errorHandler:
        If Err.Number = 13 Then blnEnd = True
        MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description, vbCritical, "Error"
End Function

Public Function AUDate(ByVal strDate As String) As Long
''Convert String Date with standard date Format
Dim iDays As Integer, iMonths As Integer, iYears As Integer
Dim iPos1 As Integer, iPos2 As Integer, iLen As Integer
Dim dtArray As Variant
Dim strVar As String
Dim i As Integer

On Error GoTo errorHandler
    blnEnd = False
    dtArray = Array(".", "/", "-")
    
    For i = 0 To UBound(dtArray)
        If InStr(1, strDate, dtArray(i), vbTextCompare) > 0 Then
            strVar = dtArray(i)
            Exit For
        End If
    Next i
    
    iPos1 = InStr(1, strDate, strVar, vbTextCompare)
    iLen = Len(strDate)
    iPos2 = iLen - InStr(1, StrReverse(strDate), strVar, vbTextCompare)
    iDays = Left(strDate, iPos1 - 1)
    iMonths = Mid(strDate, iPos1 + 1, iPos2 - iPos1)
    iYears = Right(strDate, iLen - iPos2 - 1)
    
    
    AUDate = DateSerial(iYears, iMonths, iDays)
    
Exit Function
errorHandler:
    If Err.Number = 13 Then blnEnd = True
    MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description, vbCritical, "Error"
End Function

Attribute VB_Name = "c_Sheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public WithEvents SheetApp As Application
Attribute SheetApp.VB_VarHelpID = -1
Public WithEvents SheetColor As Application
Attribute SheetColor.VB_VarHelpID = -1
Dim intlast As Long
''' Application produces a border guide to guide row navigation
''' in the active sheet, like having a ruler for each row
Private Sub SheetApp_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Excel.Range)
Dim dblTop As Double
Dim dblBtm As Double
Dim dblLast As Double
Dim lngRow As Long
Dim r As Long
Dim rng As Range
Dim dblZoom As Double
   
Application.ScreenUpdating = False
    If iGBtm < 1 Or iGTop < 1 Then
        iGBtm = 2
        iGTop = 1
        iGColor = 10
    End If
    
    If blnGuide = False Then Exit Sub ' blnguide is a global variable
        Set rng = ActiveCell                              ' its value is given by the toolbar button selected
        r = Target.Row
        dblZoom = ActiveWindow.Zoom
        dblTop = ActiveCell.Top
        dblBtm = dblTop + (ActiveCell.Height) * 0.98
        
         If dblZoom <> 100 Then
            ActiveWindow.Zoom = 100
        End If
    
        If lngRow <> r Then 'if procedure has run befeore then intlast will not be 0
                     ' so clear the last guide when a new selection is made
               On Error Resume Next
                ActiveSheet.Shapes("TopLine").Delete
                ActiveSheet.Shapes("BtmLine").Delete
               On Error GoTo 0
         End If
               '' create a new border guide based on the newly selected row
     On Error GoTo errorHandler
     
        ActiveSheet.Shapes.AddLine(0, dblTop, 20000, dblTop).Select
        Selection.Name = "TopLine"
        Selection.ShapeRange.Line.Weight = iGTop
        Selection.ShapeRange.Line.ForeColor.SchemeColor = iGColor
        ActiveSheet.Shapes.AddLine(0, dblBtm, 20000, dblBtm).Select
        Selection.Name = "BtmLine"
        Selection.ShapeRange.Line.Weight = iGBtm
        Selection.ShapeRange.Line.ForeColor.SchemeColor = iGColor
        
        lngRow = r   ''' assign the row number to the last selection made
        rng.Select
        ActiveWindow.Zoom = dblZoom
        Application.ScreenUpdating = True
    Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Cannot run macro, Sheet may be protected...", vbExclamation
       Else
        MsgBox Err.Description, vbCritical
    End If
End Sub

Private Sub lineRuler()
Dim dblTop As Double
Dim dblBtm As Double
Dim dblZoom As Double

        Application.ScreenUpdating = False
        dblZoom = ActiveWindow.Zoom
        
        If dblZoom <> 100 Then
            ActiveWindow.Zoom = 100
        End If
        
        dblTop = ActiveCell.Top
        dblBtm = dblTop + ActiveCell.Height
        If iGBtm < 1 Or iGTop < 1 Then
            iGBtm = 2
            iGTop = 1
            iGColor = 10
        End If
        
        ActiveSheet.Shapes.AddLine(0, dblTop, 20000, dblTop).Select
        Selection.Name = "TopLine"
        Selection.ShapeRange.Line.Weight = iGTop
        Selection.ShapeRange.Line.ForeColor.SchemeColor = iGColor
        ActiveSheet.Shapes.AddLine(0, dblBtm, 20000, dblBtm).Select
        Selection.Name = "BtmLine"
        Selection.ShapeRange.Line.Weight = iGBtm
        Selection.ShapeRange.Line.ForeColor.SchemeColor = iGColor
        
        ActiveWindow.Zoom = dblZoom
        
        Application.ScreenUpdating = True
End Sub

Private Sub SheetApp_WorkbookBeforeSave(ByVal Wb As Workbook, ByVal SaveAsUI As Boolean, Cancel As Boolean)
            On Error Resume Next
                ActiveSheet.Shapes("TopLine").Delete
                ActiveSheet.Shapes("BtmLine").Delete
            On Error GoTo 0
End Sub
Private Sub SheetColor_SheetBeforeDoubleClick(ByVal Sh As Object, ByVal Target As Range, Cancel As Boolean)
'' Double click cell to change cell background
Dim iColor As Long
Dim i As Long
Dim r As Long, c As Long
Dim lRow As Long

On Error GoTo errorHandler
    lRow = ActiveSheet.Rows.Count
    Target.Interior.ColorIndex = iClickColor
    c = Target.Column
    r = Target.Row
    
    Select Case iClickDirection
    Case 0
        For i = 1 To lRow
            If ActiveSheet.Rows(r + i).Hidden = False Then
                Target.Offset(i, 0).Select
                Exit For
            End If
        Next i
    Case 1
       For i = 1 To lRow
            If ActiveSheet.Rows(r - i).Hidden = False Then
                Target.Offset(-i, 0).Select
                Exit For
            End If
        Next i
    Case 2
        For i = 1 To lRow
            If ActiveSheet.Columns(c - i).Hidden = False Then
                Target.Offset(0, -i).Select
                Exit For
            End If
         Next i
    Case 3
         For i = 1 To lRow
            If ActiveSheet.Columns(c + i).Hidden = False Then
                Target.Offset(0, i).Select
                Exit For
            End If
        Next i
    End Select
    
    If blnCopyNew = True Then Selection.Copy
        
Exit Sub
errorHandler:
If Err.Number = 1004 Then
        MsgBox "Limit of range...", vbExclamation
    Else
        MsgBox "Error: " & Err.Number & Err.Description
    End If
End Sub
Attribute VB_Name = "c_Trans"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents CellTranspose As Application
Attribute CellTranspose.VB_VarHelpID = -1
Private Sub CellTranspose_SheetBeforeDoubleClick(ByVal Sh As Object, ByVal Target As Range, Cancel As Boolean)
'' Double click cell to change cell background

Dim iTargetRow As Long ' The selected row
Dim ilastRow As Long
Dim i As Long
Dim iColumns As Long

On Error GoTo errorHandler

If blnTransSel = False Then Exit Sub
iTargetRow = Target.Row
ilastRow = iTransRowOffset
iColumns = iTransColumnOffset

 iColumns = iColumns - Target.Column
 
 If blnTransReverse = False Then
    For i = 0 To ilastRow - 1
        If Target.Offset(0, iColumns + i).Value = "" Then
            Target.Offset(0, iColumns + i).Value = Target.Offset(i, 0).Value
                If blnTransClear = True Then
                    Target.Offset(i, 0).Value = ""
                End If
           Else
            MsgBox "Abort.. Cannot Overwrite Target Cell...  ", vbExclamation
            Exit For
        End If
    Next i
   ElseIf blnTransReverse = True Then
   For i = 0 To ilastRow - 1
        If Target.Offset(i + 1, 0).Value = "" Then
             Target.Offset(i + 1, 0).Value = Target.Offset(0, iColumns + i).Value
                If blnTransClear = True Then
                    Target.Offset(0, iColumns + i).Value = ""
                End If
           Else
            MsgBox "Abort.. Cannot Overwrite Target Cell...  ", vbExclamation
            Exit For
        End If
    Next i
   
 End If
 
 Target.Offset(i + 1, 0).Select
 
    
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Attribute VB_Name = "frmBookMark"
Attribute VB_Base = "0{93EF8D45-AE40-4C7B-8C84-DBF4F2D4CDF0}{F416DBF1-6420-48A0-8F71-5C9C965541AB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Function Check_Overwrite() As Boolean
Dim i As Integer
Dim strSheet As String

    With Me.lstSheets
        For i = 0 To .ListCount - 1
              If .Selected(i) = True And Sheets(.List(i)).Range("A1").Value <> "" Then
                    Check_Overwrite = True
                    Exit Function
               End If
         Next i
    End With

    Check_Overwrite = False
        
End Function

Private Sub cmdAll_Click()
Dim i As Integer
Dim strSheet As String
On Error GoTo errorHandler
    With Me.lstSheets
        For i = 0 To .ListCount - 1
            .Selected(i) = True
         Next i
    End With

 Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
        
End Sub

Private Sub cmdCreate_Click()
Dim i As Long, n As Long
Dim rng As Range
Dim strStart As String
Dim iResp As Long
Dim iCount As Integer

''Insert Contents Table

On Error GoTo errorHandler
Application.ScreenUpdating = False

iCount = 0
    With Me.lstSheets
        For i = 0 To .ListCount - 1
              If .Selected(i) = True Then
                    iCount = iCount + 1
               End If
         Next i
    End With
    
    If iCount = 0 Then
        MsgBox "No list items were selected...", vbExclamation
        Exit Sub
    End If
    
    For i = 1 To ActiveWorkbook.Sheets.Count
        If Sheets(i).Name = "Index" Then
            MsgBox "Sorry, cannot create contents list..." & vbCrLf & "Sheet named 'Index' already exists.", vbExclamation
            Exit Sub
        End If
    Next i

    '' check for data in A1
    n = 0
    i = 0
    
    Sheets.Add before:=Sheets(1)
    ActiveSheet.Name = "Index"
    strStart = ActiveSheet.Name
    
    With Sheets(strStart).Range("A1")
        .Value = "Table of Contents:"
        .Font.Bold = True
        .Font.Underline = xlUnderlineStyleSingle
    End With
    Set rng = Sheets(strStart).Range("A2")
        
    With Me.lstSheets
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                n = n + 1
                ActiveSheet.Hyperlinks.Add Anchor:=rng.Cells(n, 1), Address:="", SubAddress:= _
               "'" & .List(i) & "'" & "!A1", TextToDisplay:=.List(i)
            End If
        Next i
    End With
    
    '' Create link back
        If Check_Overwrite = True Then
            With Me.lstSheets
                For i = 0 To .ListCount - 1
                    If .Selected(i) = True And Sheets(.List(i)).Visible = True Then
                        Sheets(.List(i)).Select
                        Sheets(.List(i)).Rows("1:1").Select
                        Selection.Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove
                        Range("A1").Select
                        Sheets(.List(i)).Hyperlinks.Add Anchor:=Range("A1"), Address:="", SubAddress:= _
                        "'" & strStart & "'" & "!A1", TextToDisplay:=strStart
                     End If
                Next i
            End With
            
            ElseIf Check_Overwrite = False Then
                With Me.lstSheets
                For i = 0 To .ListCount - 1
                      If .Selected(i) = True And Sheets(.List(i)).Visible = True Then
                        Sheets(.List(i)).Select
                        If Sheets(.List(i)).Range("A1").Value <> "" Then GoTo iNext
                        Sheets(.List(i)).Hyperlinks.Add Anchor:=Range("A1"), Address:="", SubAddress:= _
                        "'" & strStart & "'" & "!A1", TextToDisplay:=strStart
                     End If
iNext:
                Next i
            End With
        End If
        
        With Sheets(strStart)
            .Select
            .Columns("A:A").EntireColumn.AutoFit
            .Range("A1").Select
        End With
        
 Application.ScreenUpdating = False
Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub

Private Sub cmdDrop_Click()
Dim i As Long

On Error GoTo errorHandler

    '' Remove items
Newitem:
        With Me.lstSheets
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
                GoTo Newitem
            End If
        Next i
        End With
        
Exit Sub
errorHandler:
    MsgBox Err.Description

End Sub

Private Sub cmdRefresh_Click()
Dim i As Long
Dim j As Long

On Error GoTo errorHandler

     ''' Count all sheets in Objwb and add names of sheets to list box
  With Me.lstSheets
    .Clear
    For j = 1 To Sheets.Count
        If Sheets(j).Type = xlWorksheet Then
            .additem Sheets(j).Name
        End If
    Next j
  End With
  Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub

Private Sub cmdSortList_Click()
' Sort listbox
    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
On Error GoTo errorHandler
    'Store the list in an array for sorting
    LbList = Me.lstSheets.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If UCase(LbList(i, 0)) > UCase(LbList(j, 0)) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstSheets.Clear
    
    'Repopulate with the sorted list
    Me.lstSheets.List = LbList
Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub

Private Sub cmdSortSheets_Click()
Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList() As String
On Error GoTo errorHandler
    i = ActiveWorkbook.Sheets.Count
    ReDim Preserve LbList(i)
    
    With ActiveWorkbook
        For i = 1 To .Sheets.Count
            LbList(i) = .Sheets(i).Name
        Next i
    End With
    
    'Bubble sort the array on the first value
    For i = LBound(LbList) To UBound(LbList) - 1
        For j = i + 1 To UBound(LbList)
            If UCase(LbList(i)) > UCase(LbList(j)) Then
                sTemp = LbList(i)
                LbList(i) = LbList(j)
                LbList(j) = sTemp
               sTemp = ""
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = False
        ''re-order the worksheets
        For i = 1 To UBound(LbList)
          For j = 1 To Sheets.Count
            Sheets(LbList(i)).Move After:=Sheets(j) ' move the sheet
          Next j
        Next i
    Application.ScreenUpdating = True

Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Cannot Sort Sheets..." & vbCrLf & " One or more may be hidden..." _
        & vbCrLf & "Try unhiding all sheets before sorting ", vbExclamation
        Else
        MsgBox Err.Description, vbCritical, "Error Message"
    End If
End Sub

Private Sub lstSheets_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
Dim j As Long

On Error GoTo errorHandler
  With Me.lstSheets
    For j = 0 To .ListCount - 1
        If .Selected(j) = True Then
            Sheets(.List(j)).Activate
            Range("A1").Select
        End If
    Next j
  End With
  
  Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Cannot Got to Sheet" & vbCrLf & "It may be hidden..."
        Else
        MsgBox Err.Description, vbCritical, "Error Message"
    End If
End Sub

Private Sub UserForm_Initialize()
Dim i As Long
Dim j As Long

On Error GoTo errorHandler

     ''' Count all sheets in Objwb and add names of sheets to list box
    For j = 1 To Sheets.Count
        If Sheets(j).Type = xlWorksheet Then
            Me.lstSheets.additem Sheets(j).Name
        End If
    Next j

  Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub
Private Sub SpinButton1_SpinDown()
    Dim i As Long
    Dim strSelect As String
    Dim strNext As String
    
    On Error GoTo errorHandler
    
    Application.ScreenUpdating = False
    With Me.lstSheets
            
        For i = 0 To .ListCount - 2
           If .Selected(i) = True Then ' find the selected item on the list
                 strSelect = .List(i) 'Store Selected item as a string variable
                 strNext = .List(i + 1) 'store the string value below the selected item
                .List(i) = strNext ' Swap the values so that the selected value
                .List(i + 1) = strSelect ' moves below the next value on the list
                .Selected(i) = False
                .Selected(i + 1) = True
                Worksheets(strSelect).Move After:=Worksheets(strNext) ' move the sheet
                
                Exit For
            End If
        Next i
    
    Application.ScreenUpdating = True
    End With
    
Exit Sub
errorHandler:

    If Err.Number = 1004 Then
        MsgBox "Cannot move sheet..." & vbCrLf & "Workbook might be Protected", vbExclamation
      Else
       MsgBox Err.Description & vbCrLf & "Number: " & Err.Number, vbExclamation
       
    End If

End Sub

Private Sub SpinButton1_SpinUp()

    Dim i As Long
    Dim strSelect As String
    Dim strNext As String
    
    On Error GoTo errorHandler
    
    Application.ScreenUpdating = False
    With Me.lstSheets
            
        For i = 1 To .ListCount
           If .Selected(i) = True Then
                strSelect = .List(i)
                strNext = .List(i - 1)
               .List(i) = strNext
               .List(i - 1) = strSelect
               .Selected(i) = False
               .Selected(i - 1) = True
               Worksheets(strSelect).Move before:=Worksheets(strNext)
               Exit For
            End If
        Next i
    Application.ScreenUpdating = True
    End With
 Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Cannot move sheet..." & vbCrLf & "Workbook might be Protected", vbExclamation
      Else
       MsgBox Err.Description & vbCrLf & "Number: " & Err.Number, vbExclamation
       
    End If
End Sub

Attribute VB_Name = "frmCase"
Attribute VB_Base = "0{F6DC8D62-AF5A-46BC-998E-B5097E89A3DE}{0FDACA67-7A28-4FBF-88F8-FA4FF7EFA311}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub Change_Case()
Dim Cell As Range, rng As Range
Dim strCase As String
Dim cSel As C_Selection
Dim NewRange As Range

 On Error GoTo errorHandler
 
  Set rng = Application.Selection
  Set cSel = New C_Selection
  
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
    
    Set NewRange = Range(cSel.rngOut_Address)
     Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
        
  
 With Me.fm_Case
        If .Controls(0).Value = -1 Then
             For Each Cell In NewRange
                strCase = UCase(Cell.Value)
                Cell.Value = strCase
              Next Cell
        ElseIf .Controls(1).Value = -1 Then
            For Each Cell In NewRange
                strCase = LCase(Cell.Value)
                Cell.Value = strCase
              Next Cell
        ElseIf .Controls(2).Value = -1 Then
            For Each Cell In NewRange
                strCase = Application.WorksheetFunction.Proper(Cell.Value)
                Cell.Value = strCase
              Next Cell
        End If
  End With
    
    Set cSel = Nothing
    
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdOK_Click()
    Call Change_Case
End Sub

Private Sub UserForm_Initialize()
On Error GoTo errorHandler
  Me.fm_Case.Controls(0) = 1
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub
Attribute VB_Name = "frmCellHide"
Attribute VB_Base = "0{6C4F5E2E-7288-4327-B871-7689B8E4F6A9}{557182B6-5A82-454A-A410-ACD3D79BC869}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Sub HideCellsValues()
Dim Cell As Range

    For Each Cell In Selection
      Cell.NumberFormat = ";;;"
    Next Cell

End Sub

Sub unHideCellsValues()
Dim Cell As Range

    For Each Cell In Selection
      Cell.NumberFormat = "General"
    Next Cell

End Sub

Private Sub btnFBar_Click()
On Error GoTo errorHandler
    With Me.btnFBar
            If .Value = -1 Then
                    Application.DisplayFormulaBar = False
                Else
                    Application.DisplayFormulaBar = True
            End If
        End With
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub btnHide_Click()
Dim RngIn As Range
Dim rng As Range
Dim clsRef As c_Ref
Dim strRange As String

On Error GoTo errorHandler
' Create instance of class object
Set clsRef = New c_Ref
    If Me.RefEdit1 = "" Then
        MsgBox "Please Select a Range", vbExclamation
        Me.RefEdit1.SetFocus
        Exit Sub
    End If
    
    strRange = Me.RefEdit1.Value
        
        '' Check for R1C1 reference style in RefEdit range
        '' convert to xlA1 if R1C1 is in use
        If clsRef.blnR1C1(strRange) = True Then
                strRange_Ref = clsRef.RefStyle(strRange)
           Else
                strRange_Ref = strRange
        End If
    
        Set rng = Range(strRange_Ref)
        
        
        With Me.btnHide
            If .Value = -1 Then
                .Caption = "Unhide Cell contents"
                .ForeColor = RGB(0, 0, 255)
                rng.NumberFormat = ";;;"
             Else
                .Caption = "Hide Cell contents"
                .ForeColor = RGB(0, 0, 0)
                rng.NumberFormat = "General"
            End If
        End With
        
    Exit Sub
errorHandler:
    MsgBox Err.Description
        
End Sub


Attribute VB_Name = "frmColorClick"
Attribute VB_Base = "0{2A1A7523-A162-4CBF-B47A-B4CA38DEC6DE}{8A5206F2-0E85-44E1-B76F-581A0FD5BD21}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim clsColor As New c_Sheet
Private Sub btnClickColor_Click()
''instantiate double click color app
With Me.btnClickColor
    If .Value = -1 Then
        Set clsColor.SheetColor = Application
        .Caption = "On"
        .ForeColor = RGB(0, 120, 0)
        .Font.Bold = True
       Else
        Set clsColor.SheetColor = Nothing
        .Caption = "Off"
        .ForeColor = RGB(255, 0, 0)
        .Font.Bold = True
    End If
End With
End Sub

Private Sub btnCopy_Click()
    If Me.btnCopy.Value = 0 Then
        blnCopyNew = False
       ElseIf Me.btnCopy.Value = -1 Then
        blnCopyNew = True
    End If
End Sub

Private Sub cboColour_Change()
Dim rng As Range
On Error Resume Next
Set rng = ThisWorkbook.Sheets(1).Range("A65536")

    If IsNumeric(Me.cboColour) Then
        '' convert colorindex to label background
         rng.Interior.ColorIndex = Me.cboColour.Value
         Me.lblColour.BackStyle = fmBackStyleOpaque
         Me.lblColour.BackColor = rng.Interior.Color
    End If
    
    iClickColor = Me.cboColour.Value
End Sub

Private Sub cboDirection_Change()
    iClickDirection = Me.cboDirection.ListIndex
End Sub

Private Sub UserForm_Initialize()
Dim i As Integer
Dim rng As Range
    With Me.cboColour
        For i = 1 To 56
           .additem (i)
        Next i
        .Value = 6
    End With
    
        
    With Me.cboDirection
        .additem ("Down")
        .additem ("Up")
        .additem ("Left")
        .additem ("Right")
        .Value = "Down"
    End With
    
    Set rng = ThisWorkbook.Sheets(1).Range("A65536")

     
    If IsNumeric(Me.cboColour) Then
        '' convert colorindex to label background
         rng.Interior.ColorIndex = Me.cboColour.Value
         Me.lblColour.BackStyle = fmBackStyleOpaque
         Me.lblColour.BackColor = rng.Interior.Color
    End If
    Me.btnCopy.Value = 1
    blnCopyNew = True
End Sub

Private Sub UserForm_Terminate()
Set clsColor.SheetColor = Nothing
End Sub
Attribute VB_Name = "frmCompareTables"
Attribute VB_Base = "0{B3C5018C-9995-4BFD-ACBC-80E59D4F5CF7}{5A354648-6719-4DCA-B7E1-25D7A6D79FA2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim strSh_1 As String
Dim strSh_2 As String
Dim lngRows_1 As Long
Dim lngRows_2 As Long
Dim intCols_1 As Long
Dim intCols_2 As Long
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1

Private Sub UserForm_Initialize()
  'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If
End Sub

Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------

Private Sub btn1_Click()
Dim rng_1 As Range

Set rng_1 = Application.Selection

strSh_1 = "'[" & ActiveWorkbook.Name & "]" & ActiveSheet.Name & "'!" & rng_1.Address
lngRows_1 = rng_1.Rows.Count
intCols_1 = rng_1.Columns.Count

End Sub


Private Sub Btn2_Click()
Dim rng_2 As Range

Set rng_2 = Application.Selection

strSh_2 = "'[" & ActiveWorkbook.Name & "]" & ActiveSheet.Name & "'!" & rng_2.Address
lngRows_2 = rng_2.Rows.Count
intCols_2 = rng_2.Columns.Count

End Sub

Private Sub btnCompare_Click()
'' Make a rough comparision between two tables
'' by identifying the values and addresses where cell values
'' differ from those in the other table, not necessarially at the same address
'' but simply verifying the first occurrence of the
'' same item or value within the other table

Dim lngCells_1 As Long, lngCells_2 As Long
Dim blnNo As Boolean
Dim i As Long, j As Long, k As Long
Dim str_1() As String, str_2() As String
Dim strDiff_1() As String, strDiff_2() As String
Dim strAdd_1() As String, strAdd_2() As String
Dim strLoc_1() As String, strLoc_2() As String
Dim rng_1 As Range, rng_2 As Range
Dim rng As Range, Cell As Range

On Error GoTo errorHandler
Application.ScreenUpdating = False
Set rng_1 = Range(strSh_1)
Set rng_2 = Range(strSh_2)

lngCells_1 = lngRows_1 * intCols_1
lngCells_2 = lngRows_2 * intCols_2

    If lngCells_1 > 100000 Or lngCells_2 > 100000 Then
        MsgBox "Selection is too large", vbExclamation
        Exit Sub
    End If

ReDim str_1(lngCells_1)
ReDim strAdd_1(lngCells_1)
ReDim str_2(lngCells_2)
ReDim strAdd_2(lngCells_2)

    '' put values from table 1 into array variable str_1()
    i = 0
    For Each Cell In rng_1
        i = i + 1
        str_1(i) = Cell.Value
        strAdd_1(i) = Cell.Address(RowAbsolute:=False, ColumnAbsolute:=False)
    Next Cell
    

    '' put values from table 2 into array variable str_2()
    i = 0
    For Each Cell In rng_2
        i = i + 1
        str_2(i) = Cell.Value
        strAdd_2(i) = Cell.Address(RowAbsolute:=False, ColumnAbsolute:=False)
    Next Cell
    
            ''' Determine which is greater
            If lngCells_1 > lngCells_2 Or lngCells_1 = lngCells_2 Then
                blnNo = True
              ElseIf lngCells_1 < lngCells_2 Then
                blnNo = False
            End If
        
    
            If blnNo = True Then
                With rng_1
                    j = 1
                    For i = 1 To lngCells_2
                          Set rng = .Find(str_2(i), LookIn:=xlValues, lookat:=xlWhole)
                            If rng Is Nothing Then
                                
                                ReDim Preserve strDiff_1(j)
                                ReDim Preserve strLoc_1(j)
                                    strDiff_1(j) = str_2(i)
                                    strLoc_1(j) = strAdd_2(i)
                                    'Debug.Print "R1-blnTrue " & str_2(i)
                                    j = j + 1
                            End If
                     Next i
                  End With
                  
                  With rng_2
                        j = 1
                        For i = 1 To lngCells_1
                          Set rng = .Find(str_1(i), LookIn:=xlValues, lookat:=xlWhole)
                            If rng Is Nothing Then
                                
                                ReDim Preserve strDiff_2(j)
                                ReDim Preserve strLoc_2(j)
                                    strDiff_2(j) = str_1(i)
                                    strLoc_2(j) = strAdd_1(i)
                                    'Debug.Print "R2-blnTrue " & str_1(i)
                                    j = j + 1
                            End If
                        Next i
                    End With
                    
                ElseIf blnNo = False Then
                   With rng_1
                       j = 1
                        For i = 1 To lngCells_2
                              Set rng = .Find(str_2(i), LookIn:=xlValues, lookat:=xlWhole)
                               If rng Is Nothing Then
                                   ReDim Preserve strDiff_1(j)
                                   ReDim Preserve strLoc_1(j)
                                       strDiff_1(j) = str_2(i)
                                       strLoc_1(j) = strAdd_2(i)
                                       'Debug.Print "R1-blnFalse " & str_2(i)
                                       j = j + 1
                               End If
                         Next i
                
                   End With
            
                    With rng_2
                        j = 1
                         For i = 1 To lngCells_1
                               Set rng = .Find(str_1(i), LookIn:=xlValues, lookat:=xlWhole)
                                If rng Is Nothing Then
                                    ReDim Preserve strDiff_2(j)
                                    ReDim Preserve strLoc_2(j)
                                        strDiff_2(j) = str_1(i)
                                        strLoc_2(j) = strAdd_1(i)
                                        'Debug.Print "R2-blnFalse " & str_1(i)
                                         j = j + 1
                                End If
                          Next i
                End With
            End If
    
    Workbooks.Add
    Range("A1").Select
        
        
           ''' SMALL TO LARGE
            On Error Resume Next
                
            For i = LBound(strLoc_1) To UBound(strLoc_1)
                Range("B2").Cells(i + 1, 1).Value = strDiff_1(i)
                Range("A2").Cells(i + 1, 1).Value = strLoc_1(i)
            Next i
       
           
            For j = LBound(strLoc_2) To UBound(strLoc_2)
                Range("D2").Cells(j + 1, 1).Value = strDiff_2(j)
                Range("C2").Cells(j + 1, 1).Value = strLoc_2(j)
            Next j
     
        On Error GoTo 0
    
        With Range("A1")
            .Value = Mid(strSh_1, 3, InStr(1, strSh_1, "]") - 3) & " - " _
                    & Mid(strSh_1, InStr(1, strSh_1, "]") + 1, InStr(2, strSh_1, "'") - (InStr(1, strSh_1, "]") + 1))
                    
            .Font.Bold = True
            .Font.Underline = True
            .Offset(1, 0).Value = "Range:"
            .Offset(1, 1).Value = "Cell Value:"
        End With
        
        With Range("C1")
            .Value = Mid(strSh_2, 3, InStr(1, strSh_2, "]") - 3) & " - " _
                    & Mid(strSh_2, InStr(1, strSh_2, "]") + 1, InStr(2, strSh_2, "'") - (InStr(1, strSh_2, "]") + 1))
            .Font.Bold = True
            .Font.Underline = True
            .Offset(1, 0).Value = "Range:"
            .Offset(1, 1).Value = "Cell Value:"
        End With
    'Format output
    Columns("A:D").EntireColumn.AutoFit
    Columns("B:B").HorizontalAlignment = xlLeft
    Columns("D:D").HorizontalAlignment = xlLeft
    Rows("2:2").Font.Bold = True

    Application.ScreenUpdating = True
  Exit Sub
errorHandler:
  MsgBox "Roor Number: " & Err.Number _
  & vbCrLf & Err.Description
End Sub


Private Sub btnDims_Click()
    MsgBox vbTab & "Rows" & vbTab & "Columns" _
        & vbCrLf & "Table 1:" & vbTab & lngRows_1 & vbTab & intCols_1 _
        & vbCrLf & "Table 2:" & vbTab & lngRows_2 & vbTab & intCols_2
End Sub
    

Attribute VB_Name = "frmDate"
Attribute VB_Base = "0{14FE2267-ACE9-419F-95E8-C8E1DC73C472}{06819364-CDC3-47B3-8CB1-692BAB70E2B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim strCellValues() As Variant
Dim NewRange As Range
Dim blnSaved As Boolean
Dim blnSaveFile As Boolean
Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then ActiveWorkbook.SaveCopyAs .SelectedItems(1)
            End If
   End With
    
        With Me.btnBackup
            blnSaved = True
            .Value = 0
            .Caption = "Backup Saved"
        End With
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub
Private Sub btnBackup_Click()
With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B7").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B7").Value = 1
        End If
        ThisWorkbook.Save
  End With
End Sub

Private Sub btnCheck_Click()
 iClicks = 0
End Sub

Private Sub btnConNum_Click()
iClicks = 0
End Sub

Private Sub btnConvUS_Click()
iClicks = 0
End Sub

Private Sub btnQtr_Click()
iClicks = 0
End Sub

Private Sub btnSAPDate_Click()
iClicks = 0
End Sub

Private Sub btnTxtMth_Click()
iClicks = 0
End Sub

Private Sub btnTxtMth_Rev_Click()
iClicks = 0
End Sub

Private Sub btnWE_Click()
iClicks = 0
End Sub

Private Sub btnWNum_Click()
iClicks = 0
End Sub

Private Sub cmdUndo_Click()
Dim i As Long
Dim Cell As Range


On Error GoTo errorHandler

If Me.btnTxtMth_Rev.Value = -1 Then
    MsgBox "Undo not available, please try other option"
    Exit Sub
End If
 i = 1
 

    For Each Cell In NewRange
       If Cell.Row <> 1 Then
        If strCellValues(i) <> "" Then
            
          If InStr(1, strCellValues(i), ".", vbTextCompare) > 0 And Not IsDate(strCellValues(i)) Then
                Cell.NumberFormat = "@"
                Cell.Value = strCellValues(i)
               ElseIf InStr(1, strCellValues(i), ".", vbTextCompare) > 0 And IsDate(strCellValues(i)) Then
                If Application.International(xlDateOrder) = 1 Then
                   Cell.NumberFormat = "dd/mm/yyyy;@"
                  ElseIf Application.International(xlDateOrder) = 0 Then
                   Cell.NumberFormat = "mm/dd/yyyy;@"
                   ElseIf Application.International(xlDateOrder) = 2 Then
                   Cell.NumberFormat = "yyyy/mm/dd;@"
                 End If
                 If Cell.Value <> 0 Then Cell.Value = strCellValues(i)
                 
               ElseIf (strCellValues(i)) > 1 And InStr(1, Cell.Value, "-", vbTextCompare) > 0 And Not IsDate(strCellValues(i)) Then
                 Cell.NumberFormat = "@"
                 Cell.Value = strCellValues(i)
               Else
                
                If Application.International(xlDateOrder) = 1 Then
                   Cell.NumberFormat = "dd/mm/yyyy;@"
                  ElseIf Application.International(xlDateOrder) = 0 Then
                   Cell.NumberFormat = "mm/dd/yyyy;@"
                   ElseIf Application.International(xlDateOrder) = 2 Then
                   Cell.NumberFormat = "yyyy/mm/dd;@"
                 End If
                 If Cell.Value <> 0 Then Cell.Value = strCellValues(i)
                 If Me.btnConNum.Value = -1 Then Cell.NumberFormat = "General"
             End If
             

           Else
            MsgBox "Undo No longer avalable", vbExclamation
            Exit Sub
         End If
         i = i + 1
         End If
    Next Cell

    
    iClicks = 0
Exit Sub
errorHandler:
    If Err.Number = 13 Then
        MsgBox "Try another option...", vbInformation
       Else
        MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
     End If
End Sub

Private Sub UserForm_Initialize()
Me.btnCheck.Value = 1
' Defaults
      blnSaveFile = False
      If ThisWorkbook.Sheets("BupFlag").Range("B7").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B7").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
iClicks = 0
End Sub

Private Sub cmdOK_Click()
Dim iResp As Integer
Dim intWeekday As Long
Dim Cell As Range
Dim i As Long, intcells As Long
Dim sFile As String, strItem As String
Dim strDate As String
Dim c_Date As c_Ref
Dim dblDate As Double
Dim yr As Integer, day As Integer, mth As Integer
Dim dt As Date
Dim rngCell As Range
Dim cSel As C_Selection
Dim cDat As c_Date

 On Error GoTo errorHandler
    '' Check undos
    iClicks = iClicks + 1
    
    If iClicks > 1 Then
        iResp = MsgBox("Undo will be cleared, Do you want to continue...", vbYesNo + vbExclamation)
            If iResp = vbNo Then Exit Sub
    End If
     
    '' Auto-Backup
            
           If Me.btnBackup = -1 Then
               
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B7").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If

    'Here is the range spec
    '-----------------------------------------------------------

    Set rngCell = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rngCell
    cSel.RowsIn = rngCell.Rows.Count
    cSel.ColsIn = rngCell.Columns.Count
    Set NewRange = Range(cSel.rngOut_Address)
    Set cDat = New c_Date
    
    If NewRange.Cells.Count > 1 Then
        Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
    End If
     ''Re-size array based on selection
     intcells = NewRange.Cells.Count
     ReDim strCellValues(intcells)
     Set c_Date = New c_Ref
 
    intcells = 0
    For Each Cell In NewRange
      If Cell.Row <> 1 Then
        intcells = intcells + 1
        If VBA.IsNumeric(Cell.Value) Then
            strCellValues(intcells) = CLng(Cell.Value)
          Else
            strCellValues(intcells) = Cell.Value
        End If
                '---------------------------
                'Show weekends - mark in red
                '---------------------------
            If Me.btnWE.Value = -1 Then
                intWeekday = Weekday(Cell.Value)
                    If intWeekday = 1 Or intWeekday = 7 Then
                        ' Selected day is Sunday or Saturday [based on settings in Excel
                        'and on machine] so set text colour to red
                        Cell.Font.ColorIndex = 3
                    End If
                    '-----------------
                    ''Check if is Date
                    '-----------------
                ElseIf Me.btnCheck.Value = -1 Then
                    If Cell.Value <> "" And Not VBA.IsDate(Cell.Value) Then
                        Cell.Interior.ColorIndex = 22
                    End If
                    '-----------------------------
                    'Convert date to text 'mmm-yy'
                    '-----------------------------
                 ElseIf Me.btnTxtMth.Value = -1 Then
                    If VBA.IsDate(Cell.Value) Then
                        strDate = Format(Cell.Value, "mmm-yy")
                        Cell.NumberFormat = "@"
                        Cell.Value = CStr(strDate)
                    End If
                    '----------------------------------
                    'Convert text date 'mmm-yy' to date
                    '----------------------------------
                 ElseIf Me.btnTxtMth_Rev.Value = -1 And InStr(1, Trim(Cell.Value), "-", vbTextCompare) = 4 Then
            
'                    '' Convert String date to date Format
                    If blndDate(Cell.Value) = True Then
                             mth = Month(Cell.Value)
                             day = 1
                             yr = Right(Cell.Value, 2)
                             dblDate = DateSerial(yr, mth, day)
                             Cell.NumberFormat = "general"
                             Cell.Value = CDate(dblDate)
                         Else
                             MsgBox "Abort...due to invalid selection", vbExclamation
                             Exit For
                    End If
                    '--------------------------------------
                    'Convert 'yyyymmdd' to date
                    '--------------------------------------
                ElseIf Me.btnConNum.Value = -1 Then
                    If c_Date.blnEnd = True Then Exit For
                        strItem = VBA.val(Trim(Cell.Value))
                        mth = Mid(strItem, 5, 2)
                        day = Right(strItem, 2)
                        yr = Left(strItem, 4)
                        dblDate = DateSerial(yr, mth, day)
                        Cell.NumberFormat = "general"
                        Cell.Value = CDate(dblDate)
    
                        
                    '--------------------------------------
                    'Convert date to week number
                    '--------------------------------------
                 ElseIf Me.btnWNum.Value = -1 Then
                    If c_Date.blnEnd = True Then Exit For
                      If IsDate(Cell.Value) Then
                         Cell.NumberFormat = "@"
                         Cell.Value = Format(Cell.Value, "YY") & "-W" & Format(Format(Cell.Value, "ww"), "00")
                         
                      End If
                    '--------------------------------------
                    'Convert text format dd.mm.yyyy to date
                    '--------------------------------------
                ElseIf Me.btnSAPDate.Value = -1 Then
                    If c_Date.blnEnd = True Then Exit For
                       If InStr(1, Cell.Value, ".", vbTextCompare) > 0 Then
                        strItem = Trim(Cell.Value)
                        Cell.NumberFormat = "General"
                        Cell.Value = CDate(cDat.GetDate(strItem))
                       End If
                    '--------------------------------------
                    'Convert date to Quarter
                    '--------------------------------------
                ElseIf Me.btnQtr.Value = -1 Then
                    If IsDate(Cell.Value) Then
                        Cell.NumberFormat = "@"
                        Cell.Value = Format(Cell.Value, "YY") & "-Q" & Format(Cell.Value, "Q")
                        
                    End If
                    
            End If
         End If
    Next Cell
 
 Exit Sub
errorHandler:
    If Err.Number = 13 Then
        MsgBox "Format selection is incorrect!" & vbCrLf & "Select Date Formats Only", vbExclamation, "Weekend Dates"
        Else:
        MsgBox Err.Description, vbCritical, "Error"
    End If
End Sub

Attribute VB_Name = "frmDelRows"
Attribute VB_Base = "0{41EACFD1-A9E9-436D-BCFA-92D11F6710AD}{6B96156A-F98E-4EE0-BA94-682411019ED0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim blnBup As Boolean
Dim blnSaveFile As Boolean
Private Sub btnBackup_Click()

  With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B2").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B2").Value = 1
        End If
        ThisWorkbook.Save
  End With
End Sub

Private Sub cmdDeleteRows_Click()
''' Delete empty rows on a worksheet
Dim lastRow As Long, r As Long
Dim iResp As Integer
Dim sFile As String
On Error GoTo errorHandler
        
        

     '' Auto-Backup
            blnBup = False
           If Me.btnBackup = -1 Then
                blnBup = True
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B2").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If
        
        lastRow = ActiveSheet.UsedRange.Rows.Count
        lastRow = lastRow + ActiveSheet.UsedRange.Row - 1
        Application.ScreenUpdating = False
        
            For r = lastRow To 1 Step -1
                If WorksheetFunction.CountA(Rows(r)) = 0 Then Rows(r).Delete
            Next r
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub

Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then
                    ActiveWorkbook.SaveCopyAs .SelectedItems(1)
                    blnBup = True
                    Me.btnBackup.Value = 0
                    Me.btnBackup.Caption = "Backup saved"
                   Else
                    blnBup = False
                End If
            End If
   End With

Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub
Private Sub UserForm_Initialize()
    ' Defaults
      blnSaveFile = False
      If ThisWorkbook.Sheets("BupFlag").Range("B2").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B2").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
End Sub
Attribute VB_Name = "frmFilter"
Attribute VB_Base = "0{12496907-9856-4814-9877-AA307B9C4973}{93854545-CA78-4160-AB17-7ECF2A1E3B60}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
''-------------------------------------------------------------------------------
'' Muliti-Filter for Stored Lists written by Peter Tscherne for mightymacros |fffd|
'' Requested by Abe Garfey to filter Vendors in a list
'' Version 1.0 28.08.2012
'' Version 1.01 29.12.2012 add exclude button & Case btn to filter
'' Version 2.0 12.05.13 allows for multi select filtering and by double click
'' Modified 2019.09.26 added paste option
''===============================================================================
Dim MyData As DataObject
Dim strDefaultCol As String
Dim blnDefaultPaste As Boolean
Dim blnExclude As Boolean
Dim blnCase As Boolean
Dim iOriginal As Long
Dim iCcol As Long
Dim iProg As Long
Dim iMove As Single
Dim clsVis As New c_Filter
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1

Private Sub btnPaste_Click()
    If Me.btnPaste.Value = 0 Then
        Me.btnPaste.Caption = "Use selection"
        blnDefaultPaste = False
        ThisWorkbook.Sheets("MFilter").Range("B3").Value = 0
       ElseIf Me.btnPaste.Value = -1 Then
        Me.btnPaste.Caption = "Use Paste"
        blnDefaultPaste = True
        ThisWorkbook.Sheets("MFilter").Range("B3").Value = -1
    End If
    
    ThisWorkbook.Save
End Sub

Private Sub cboRet_1_Change()
 strDefaultCol = Me.cboRet_1.Value
 ThisWorkbook.Sheets("MFilter").Range("B2").Value = strDefaultCol
 ThisWorkbook.Save
End Sub

Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------


Private Sub btnCase_Click()
     '' Clear
       ' ActiveSheet.UsedRange.EntireRow.Hidden = False
    If Me.btnCase.Value = -1 Then
        Me.btnCase.Caption = " Case sensitive filter"
        blnCase = True
        ThisWorkbook.Sheets("MFilter").Range("B4").Value = -1
       ElseIf Me.btnCase.Value = 0 Then
        Me.btnCase.Caption = " Non-case sensitive filter"
        blnCase = False
        ThisWorkbook.Sheets("MFilter").Range("B4").Value = 0
    End If
    ThisWorkbook.Save
End Sub

Private Sub btnExclude_Click()
     '' Clear
     ' ActiveSheet.UsedRange.EntireRow.Hidden = False
    If Me.btnExclude.Value = -1 Then
        Me.btnExclude.Caption = " Include list items in filter"
        blnExclude = False
       ElseIf Me.btnExclude.Value = 0 Then
        Me.btnExclude.Caption = " Exclude list items in filter"
        blnExclude = True
    End If
       
End Sub


Private Sub cmdAdd_Click()
Dim clsRef As c_Ref
Dim strRange As String
Dim RngIn As Range
Dim rng As Range, Cell As Range
Dim blnSelection As Boolean
Dim i As Long, j As Long
Dim iCol As Long
Dim lRow As Long, lLast As Long
Dim strItem() As String, strTemp As String
Dim blnItem() As Boolean
Dim str As Variant
Dim strvalue As String


On Error GoTo errorHandler

If Me.btnPaste.Value = 0 Then
    
    Application.ScreenUpdating = False
    Application.StatusBar = ""
    '' SET SEARCH RANGE
        
        If Application.Selection.Cells.Count = 1 Then
            Set rng = Selection
           Else
            Set rng = Application.Selection.SpecialCells(xlCellTypeVisible)
        End If
        
    ''' Determine if whole sheetis selected if so exit procedure
        
            If Selection.Columns.Count >= 256 And Right(ActiveWorkbook.Name, 3) = "xls" Then
                MsgBox "you may have selected the whole column", vbInformation
                Exit Sub
               ElseIf Selection.Columns.Count >= 16384 And Application.Version <= 14 Then
                MsgBox "you may have selected the whole sheet, cancelling operation...", vbInformation
            End If
        blnSelection = False
    
       
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        i = 0
         For Each Cell In rng
              If Not IsEmpty(Cell) Then i = i + 1
              If i > 0 Then
                blnSelection = True
                Exit For
              End If
         Next Cell
         
        ''' provide message if no selection is made:
                If blnSelection = False Then
                    MsgBox "No data selected...", vbExclamation
                    Unload Me
                    Exit Sub
                End If
        '' add selection to collection
        strTemp = ""
        On Error Resume Next
            For Each Cell In rng
               If Cell.Value <> "" Then
                  i = i + 1
                  ReDim Preserve strItem(i)
                  strTemp = Cell.Value
                    For j = 1 To UBound(strItem)
                        If strTemp = strItem(j) Then
                            i = i - 1
                            GoTo NextValue
                         Else
                          strTemp = Cell.Value
                        End If
                    Next j
                        strItem(i) = strTemp
               End If
NextValue:
            Next Cell
        
        
        '' populate List
        With Me.lstItems
           '' Check if item is already listed
           '' If not then add to list
                For i = 1 To UBound(strItem)
                    ReDim Preserve blnItem(i)
                    blnItem(i) = False
                    If blnCase = False And strItem(i) <> "" Then
                            '' remove duplicates from list for non-case sensitve items
                            For j = 0 To .ListCount - 1
                                If UCase(strItem(i)) = UCase(.List(j)) Then blnItem(i) = True
                            Next j
                     ElseIf blnCase = True And strItem(i) <> "" Then
                         '' remove duplicates from list for non-case sensitve items
                            For j = 0 To .ListCount - 1
                                If strItem(i) = .List(j) Then blnItem(i) = True
                            Next j
                    End If
                    If blnItem(i) = False And strItem(i) <> "" Then .additem strItem(i)
                Next i
        End With
        
    ElseIf Me.btnPaste = -1 Then
    
       Set MyData = New DataObject
        With MyData
            .GetFromClipboard
            str = .GetText(1)
            strvalue = .GetText(1)
        End With
        With Me.lstItems
        
                    ''Carriage return or line feed
            If InStr(1, strvalue, Chr(13), vbTextCompare) > 0 Then
                    str = VBA.Split(strvalue, vbLf)

                For i = LBound(str) To UBound(str)

                    If Len(str(i)) > 0 And InStr(1, str(i), Chr(13), vbTextCompare) > 0 And InStr(1, str(i), Chr(9), vbTextCompare) = 0 Then
                        'strTemp = Left(str(i), Len(str(i)) - 1)
                        strTemp = Replace(str(i), Chr(13), "", 1, -1, vbTextCompare)
                        ReDim Preserve blnItem(i)
                        blnItem(i) = False
                        If blnCase = False Then
                                '' remove duplicates from list for non-case sensitve items
                                For j = 0 To .ListCount - 1
                                    If UCase(strTemp) = UCase(.List(j)) Then blnItem(i) = True
                                Next j
                            ElseIf blnCase = True Then
                            '' remove duplicates from list for non-case sensitve items
                               For j = 0 To .ListCount - 1
                                   If strTemp = .List(j) Then blnItem(i) = True
                               Next j
                        End If
                            If blnItem(i) = False Then .additem Trim(strTemp)
                        
                    End If
                Next i
 
            End If
            
        End With
      
      End If

  
  Exit Sub
errorHandler:
If Err.Number = -2147221404 Then
   MsgBox "Clipboard is empty", vbExclamation
   Else
  MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description
 End If
End Sub
Private Sub cmdApply_Click()
 Dim i As Long, j As Long

On Error GoTo errorHandler
 ''instantiate guide
    Set clsVis.SheetFilter = Nothing
    With Me.lstItems
       For i = .ListCount - 1 To 0 Step -1
           If .Selected(i) = True Then
               j = j + 1
           End If
       Next i
    End With

    If j > 1 Then
            Call cFilter
          Else
            Call ApplyFilter
    End If
    
     ''instantiate guide
        Set clsVis.SheetFilter = Application
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub
Private Sub ApplyFilter()
Dim i As Long, j As Long
Dim strname() As String, strCol As String
Dim rng As Range
Dim Cell As Range
Dim lngRow() As Long
Dim rw As Long
Dim lHeader As Long
On Error GoTo errorHandler

Application.ScreenUpdating = False

lHeader = (Me.cboRet_2.Value) + 1

            '' Clear
            ActiveSheet.UsedRange.EntireRow.Hidden = False
            
            strCol = Me.cboRet_1.Value
            
            If strCol = "" Then
                MsgBox "Please select a Column from drop-down", vbExclamation
                Me.cboRet_1.SetFocus
                Exit Sub
            End If
            
           With ActiveSheet
            Set rng = .Range(.Range(strCol & lHeader), .Range(strCol & 65536).End(xlUp))
           End With
           
          
        j = 0
        With Me.lstItems
          ReDim strname(.ListCount)
            For i = 0 To .ListCount - 1
                ''' If individual items are selected in listbox
                ''' Find the row where items are found
                        If blnCase = True Then
                            For Each Cell In rng
                                '' allow for filtering additional columns
                                    If CStr(Cell.Value) = .List(i) And Cell.Rows.Hidden = False Then
                                        j = j + 1
                                       ReDim Preserve lngRow(j)
                                       lngRow(j) = Cell.Row '' assign row number to array
                                       rw = j  ' then number of rows found
                                     End If
                            Next Cell
                        Else
                          For Each Cell In rng
                                '' allow for filtering additional columns
                                    If UCase(CStr(Cell.Value)) = UCase(.List(i)) And Cell.Rows.Hidden = False Then
                                        j = j + 1
                                       ReDim Preserve lngRow(j)
                                       lngRow(j) = Cell.Row '' assign row number to array
                                       rw = j  ' then number of rows found
                                     End If
                            Next Cell
                      End If
             Next i
             
              
        End With
        
        ''' loop through the range and hide the row
        ''' that matches the rw row
         
        If blnExclude = False Then
            '' make sure items are found before hiding rows
                If rw > 0 Then
                        rng.EntireRow.Hidden = True
                    Else
                        MsgBox "List items not found in column selected", vbExclamation
                End If
            For i = 1 To rng.Rows.Count
                rng.Cells(i, 1).Select
                    For j = 1 To rw
                      If ActiveCell.Row = lngRow(j) Then
                         ActiveCell.EntireRow.Hidden = False
                      End If
                    Next j
            Next i
          ElseIf blnExclude = True Then
                '' make sure items are found before hiding rows
                '' make sure items are found before hiding rows
                If rw > 0 Then
                        rng.EntireRow.Hidden = False
                        ActiveSheet.UsedRange.EntireRow.Hidden = False
                    Else
                        MsgBox "List items not found in column selected", vbExclamation
                End If
                 For i = 1 To rng.Rows.Count
                    rng.Cells(i, 1).Select
                    For j = 1 To rw
                      If ActiveCell.Row = lngRow(j) Then
                         ActiveCell.EntireRow.Hidden = True
                      End If
                    Next j
                Next i
      End If
      
      
      Application.ScreenUpdating = True
        
       Range("a1").Select
       
Exit Sub
errorHandler:

        MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number
End Sub

Private Sub cmdClear_Click()
    Me.lstItems.Clear
End Sub

Private Sub cmdDrop_Click()
Dim i As Long
On Error GoTo errorHandler

    '' Remove items
Newitem:
        With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
                GoTo Newitem
            End If
        Next i
        End With
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdManage_Click()
Dim i As Long


   With Me.lstItems
    iList = .ListCount
    For i = 0 To iList - 1
    ReDim Preserve sList(i)
        sList(i) = .List(i)
    Next i
   End With
   
    Unload Me
    frmLists.Show 0
    
End Sub
Private Sub cmdPaste_Click()
Dim Sh As Worksheet
Dim i As Long
Dim strname As String

On Error GoTo errorHandler
Set Sh = Worksheets.Add

    With Sh
        strname = .Name
    End With

    Sheets(strname).Activate
    With Me.lstItems
        For i = 0 To .ListCount - 1
            Cells(i + 1, 1).Value = .List(i)
        Next i
    End With
    
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdSel_Click()
'' Clear list box selection
Dim i As Long
    With Me.lstItems
        For i = 0 To .ListCount - 1
           If .Selected(i) = True Then
            .Selected(i) = False
            End If
        Next i
    End With
End Sub

Private Sub cmdSort_Click()
' Sort listbox
    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
    On Error GoTo errorHandler
    'Store the list in an array for sorting
    LbList = Me.lstItems.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If LbList(i, 0) > LbList(j, 0) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstItems.Clear
    
    'Repopulate with the sorted list
    Me.lstItems.List = LbList
    
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdUndo_Click()
Dim i As Long
     On Error GoTo errorHandler
        
        With ActiveSheet
            ''Unhide Cells
            .UsedRange.EntireRow.Hidden = False
            ''Check if Excel's filter is active
            With .UsedRange
                For i = 1 To .Rows.Count
                    If .EntireRow(i).Hidden = True Then
                        'Try
                        ActiveSheet.ShowAllData
                        Exit For
                    End If
                Next i
                
            End With
        End With

Exit Sub
errorHandler:
        MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number
End Sub

Private Sub cmdVisible_Click()
On Error GoTo errorHandler
    Dim rng As Range
        With ActiveSheet
            Set rng = Application.Selection.SpecialCells(xlCellTypeVisible)
        End With
        rng.Select
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub

Private Sub lblLink_Click()
    Dim str As String
    str = "http://www.mightymacros.com.au"
    ThisWorkbook.FollowHyperlink (str)
End Sub

Private Sub lstItems_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call cFilter
End Sub
Private Sub cFilter()
Dim i As Long, j As Long, n As Long
Dim strname() As String, strCol As String
Dim rng As Range
Dim Cell As Range
Dim lngRow() As Long
Dim rw As Long
Dim lHeader As Long

 On Error GoTo errorHandler
Application.ScreenUpdating = False

    lHeader = (Me.cboRet_2.Value) + 1
    '' Remove items
        With Me.lstItems
        For i = .ListCount - 1 To 0 Step -1
            If .Selected(i) = True Then
                j = j + 1
                ReDim Preserve strname(j)
                strname(j) = .List(i)
            End If
        Next i
        End With
        
         '' Clear
            ActiveSheet.UsedRange.EntireRow.Hidden = False
            
            strCol = Me.cboRet_1.Value
            
            If strCol = "" Then
                MsgBox "Please select a Column from drop-down", vbExclamation
                Me.cboRet_1.SetFocus
                Exit Sub
            End If
            
           With ActiveSheet
            Set rng = .Range(.Range(strCol & lHeader), .Range(strCol & 65536).End(xlUp))
           End With
           
          
       
        For j = 1 To UBound(strname)
        If blnCase = True Then
                           For Each Cell In rng
                               '' allow for filtering additional columns
                                   If Cell.Value = strname(j) And Cell.Rows.Hidden = False Then
                                      n = n + 1
                                      ReDim Preserve lngRow(n)
                                      lngRow(n) = Cell.Row '' assign row number to array
                                      rw = n  ' then number of rows found
                                    End If
                           Next Cell
                       Else
                         For Each Cell In rng
                               '' allow for filtering additional columns
                                   If UCase(Cell.Value) = UCase(strname(j)) And Cell.Rows.Hidden = False Then
                                       n = n + 1
                                      ReDim Preserve lngRow(n)
                                      lngRow(n) = Cell.Row '' assign row number to array
                                      rw = n  ' then number of rows found
                                    End If
                           Next Cell
                    End If
            Next j
             
        
        ''' loop through the range and hide the row
        ''' that matches the rw row
         
        If blnExclude = False Then
            '' make sure items are found before hiding rows
                If rw > 0 Then
                        rng.EntireRow.Hidden = True
                    Else
                        MsgBox "List items not found in column selected", vbExclamation
                End If
            For i = 1 To rng.Rows.Count
                rng.Cells(i, 1).Select
                    For n = 1 To rw
                      If ActiveCell.Row = lngRow(n) Then
                         ActiveCell.EntireRow.Hidden = False
                      End If
                    Next n
            Next i
          ElseIf blnExclude = True Then
                '' make sure items are found before hiding rows
                '' make sure items are found before hiding rows
                If rw > 0 Then
                        rng.EntireRow.Hidden = False
                        ActiveSheet.UsedRange.EntireRow.Hidden = False
                    Else
                        MsgBox "List items not found in column selected", vbExclamation
                End If
                 For i = 1 To rng.Rows.Count
                    rng.Cells(i, 1).Select
                    For n = 1 To rw
                      If ActiveCell.Row = lngRow(n) Then
                         ActiveCell.EntireRow.Hidden = True
                      End If
                    Next n
                Next i
      End If
      
      
      Application.ScreenUpdating = True
        
       Range("a1").Select
        
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub



Private Sub UserForm_Activate()
   ' MsgBox "Leave open, for visible cell selection if editing filtered cells", vbExclamation, "WARNING..."
End Sub

Private Sub UserForm_Initialize()
'' populate column combos
Dim i As Long
Dim j As Long

On Error GoTo errorHandler


      'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If
    
    Me.cboRet_1.Clear
   
         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + i)
    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
    Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
    For i = 259 To 256 Step -1
        Me.cboRet_1.RemoveItem (i)
    Next i
    
    '' Load Stored List
        
        For i = 0 To iList - 1
            If sList(i) <> "" Then
                Me.lstItems.additem sList(i)
            End If
        Next i
            
    For i = 1 To 9999
        Me.cboRet_2.additem (i)
    Next i
      ''Defaults
     Me.btnExclude = 1
     
     
     ' Retrieve default value for column filter
     strDefaultCol = ThisWorkbook.Sheets("MFilter").Range("B2").Value
     If strDefaultCol <> "" Then
        Me.cboRet_1.Value = strDefaultCol
     Else
        Me.cboRet_1.Value = "A"
     End If
     
     'Retrieve stored value for Paste
     If ThisWorkbook.Sheets("MFilter").Range("B3").Value = -1 Then
        blnDefaultPaste = True
        Me.btnPaste.Value = "1"
        
        Me.btnPaste.Caption = "Use Paste"
     Else
        blnDefaultPaste = False
        Me.btnPaste.Value = 0
        Me.btnPaste.Caption = "Use Selection"
     End If
     
     'Retrieve stored value for Case
     If ThisWorkbook.Sheets("MFilter").Range("B4").Value = -1 Then
        blnCase = True
        Me.btnCase.Value = "1"
        Me.btnCase.Caption = " Case sensitive filter"
     Else
        blnCase = False
        Me.btnCase.Value = 0
        Me.btnCase.Caption = " Non-case sensitive filter"
     End If
     
     ' Set default row
     Me.cboRet_2.Value = "1"
     
     
     
  Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical
End Sub


Private Sub UserForm_Terminate()
''Turn off sheet tool
    Set clsVis.SheetFilter = Nothing
End Sub
Attribute VB_Name = "frmFind"
Attribute VB_Base = "0{D1B3E23C-C735-41C3-B51F-7FD16A40E7CA}{08E598E7-81F6-4EEA-9A57-53FB7D523907}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
''=========================================================================================================
'' Multi-find dialog
'' Select any items on a sheet and search for any listed items on any sheet in any open workbook
'' Highligh or scroll through items faound
'' Developed by mightymacros
'' www.mightymacros.com.au
'' 26.05.2011
'' Updated 20.05.2012 Changed add to list for single item in filtered list
'' fixed bug in selecting all items in a filtered list
'' Version 1.04 Partial search with sort and locking column selection 11.06.2012
'' Version 1.05 prevent wide searches
'' Version 1.06 refining searches and preventing colour over-write
'' Version 1.09 restricting and quantifying search range
'' Version 1.11 Added Drp Item and Dump button 16.08.1
'' Version 1.13 clean up range code
'' Version 1.14 Dump items converted to text output, issue with numerical format containing letter 'E'
'' Version 1.17 Extend range and fix (Clear) and (None) options
'' =========================================================================================================
Dim MyData As DataObject
Dim iCcol As Long
Dim iProg As Long
Dim iMove As Single
Dim blnDefaultPaste As Boolean
' ---------------------------------------------------------------------------------------------------------
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1



Private Sub btnPaste_Click()
If Me.btnPaste.Value = 0 Then
        Me.btnPaste.Caption = "Use selection"
        blnDefaultPaste = False
        ThisWorkbook.Sheets("MFilter").Range("E3").Value = 0
       ElseIf Me.btnPaste.Value = -1 Then
        Me.btnPaste.Caption = "Use Paste"
        blnDefaultPaste = True
        ThisWorkbook.Sheets("MFilter").Range("E3").Value = -1
    End If
    
    ThisWorkbook.Save
End Sub

Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------

Private Sub cboColour_Change()
Dim rng As Range
On Error Resume Next
Set rng = ThisWorkbook.Sheets(1).Range("A65536")

 
     If Me.cboColour = "(Clear)" Or Me.cboColour = "(None)" Then
        Me.lblColour.BackStyle = fmBackStyleTransparent
      ElseIf IsNumeric(Me.cboColour) Then
        '' convert colorindex to label background
         rng.Interior.ColorIndex = Me.cboColour.Value
         Me.lblColour.BackStyle = fmBackStyleOpaque
         Me.lblColour.BackColor = rng.Interior.Color
    End If

End Sub


Private Sub cmdAdd_Click()

Dim clsRef As c_Ref
Dim strRange As String
Dim RngIn As Range
Dim rng As Range, Cell As Range
Dim blnSelection As Boolean
Dim i As Long, j As Long
Dim iCol As Long
Dim lRow As Long, lLast As Long
Dim collItem As New Collection
Dim item As Variant
Dim blnExists As Boolean
Dim NewRange As Range
Dim cSel As C_Selection
Dim cSelNew As C_Selection
Dim str As Variant
Dim strvalue As String, strTemp As String
Dim blnItem() As Boolean
    
On Error GoTo errorHandler
    
    Application.ScreenUpdating = False
    Application.StatusBar = ""
    
    If Me.btnPaste = 0 Then
    Me.lblCells.Caption = ""
    Me.lblCount.Caption = ""
    Me.lblFound.Caption = ""
    '' SET SEARCH RANGE
        

             Set rng = Application.Selection
             
             Set cSel = New C_Selection
             cSel.RngIn = rng
             cSel.RowsIn = rng.Rows.Count
             cSel.ColsIn = rng.Columns.Count
             Set NewRange = Range(cSel.rngOut_Address)
             Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
        
             If NewRange.Cells.Count > 2000 Then
                MsgBox "More than 2000 items selected..." & vbCrLf & "Reduce the number of items to add and try again ", vbExclamation + vbOKOnly, "Overload..."
                Exit Sub
             End If


             blnSelection = False
    
       
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        i = 0
    
         For Each Cell In NewRange
              If Not IsEmpty(Cell) Then i = i + 1
              If i > 0 Then
                blnSelection = True
                Exit For
              End If
         Next Cell
         
        ''' provide message if no selection is made:
                If blnSelection = False Then
                    MsgBox "No data selected...", vbExclamation
                    Exit Sub
                End If
        '' add selection to collection
        On Error Resume Next
            For Each Cell In NewRange
               If Cell.Value <> "" Then
                  collItem.Add Cell.Value, CStr(Cell.Value)
               End If
            Next Cell
        On Error GoTo 0
        
        
        '' populate List
        With Me.lstItems
           '' Check if item is already listed
           '' If not then add to list
            For Each item In collItem
                blnExists = False
                For i = 0 To .ListCount - 1
                  If UCase(item) = .List(i) Then
                    blnExists = True
                    Exit For
                  End If
                Next i
                
               If blnExists = False Then
                    .additem UCase(item)
               End If
            Next item
        End With
        
ElseIf Me.btnPaste = -1 Then
    
       Set MyData = New DataObject
        With MyData
            .GetFromClipboard
            str = .GetText(1)
            strvalue = .GetText(1)
        End With
        With Me.lstItems
        
                    ''Carriage return or line feed
            If InStr(1, strvalue, Chr(13), vbTextCompare) > 0 Then
                    str = VBA.Split(strvalue, vbLf)

                For i = LBound(str) To UBound(str)

                    If Len(str(i)) > 0 And InStr(1, str(i), Chr(13), vbTextCompare) > 0 And InStr(1, str(i), Chr(9), vbTextCompare) = 0 Then
                        'strTemp = Left(str(i), Len(str(i)) - 1)
                        strTemp = Replace(str(i), Chr(13), "", 1, -1, vbTextCompare)
                        ReDim Preserve blnItem(i)
                        blnItem(i) = False
                      
                                '' remove duplicates from list for non-case sensitve items
                                For j = 0 To .ListCount - 1
                                    If UCase(strTemp) = UCase(.List(j)) Then blnItem(i) = True
                                Next j
                          
                       
                            If blnItem(i) = False Then .additem Trim(strTemp)
                        
                    End If
                Next i
 
            End If
            
        End With
      
      End If


        
        Me.lblCount.Caption = "Items Listed:= " & Me.lstItems.ListCount
        
  
  Exit Sub
errorHandler:
  If Err.Number = -2147221404 Then
   MsgBox "Clipboard is empty", vbExclamation
   Else
  MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description
 End If
End Sub

Private Sub cmdAll_Click()
    Dim rng As Range, Cell As Range
    Dim strCol As String, strCcol As String
    Dim strItem() As String
    Dim iCcolor As Long
    Dim strCell As String
    Dim irow As Long, i As Long, n As Long, iList As Long
    Dim blnPartial As Boolean
    Dim lCells As Long, lCount As Long, lTotal As Long
    Dim response As Integer
    Dim NewRange As Range
    Dim cSel As C_Selection
    Dim cSelNew As C_Selection
    
   On Error GoTo errorHandler

    Set rng = Application.Selection
   

   '' Select highlight colour
   If Me.cboColour = "(Clear)" Then
        iCcolor = xlNone
       ElseIf Me.cboColour = "(None)" Then
        iCcolor = 5000
       Else
        iCcolor = Me.cboColour.Value
    End If

    '' Clear address list
    Me.lstAdd.Clear
    With ActiveSheet
      If Me.cboRet_1.Value <> "" Then
       '' Search the designaed column selected in the drop-box
        strCol = Me.cboRet_1.Value
            'Set rng = .Range(.Range(strCol & 1), .Range(strCol & 65536).End(xlUp)).SpecialCells(xlCellTypeVisible)
            Set rng = Range(strCol & ":" & strCol)
             Set cSel = New C_Selection
             cSel.RngIn = rng
             cSel.RowsIn = rng.Rows.Count
             cSel.ColsIn = rng.Columns.Count
             Set NewRange = Range(cSel.rngOut_Address)
             Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
           Else
             Set cSel = New C_Selection
             cSel.RngIn = rng
             cSel.RowsIn = rng.Rows.Count
             cSel.ColsIn = rng.Columns.Count
             Set NewRange = Range(cSel.rngOut_Address)
             Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
        End If
    End With
    
    
    lCells = NewRange.Cells.Count
    Me.lblCells.Caption = "Cells Searched:= " & lCells
    Me.Repaint
    
    lCount = Me.lstItems.ListCount
    lTotal = lCount * lCells
    '' If more than 500 items are searched the advise caution
    If lCount > 10 And lCells > 200000 Then
        response = MsgBox("You are searching for " & lCount & " items in " & lCells & " cells" & vbCrLf & _
        "Searching too many items, Excel might crash... " & vbCrLf & _
        "Try narrowing search...Search for fewer items" & vbCrLf & _
        "Do you want to continue ? ", vbOKCancel + vbExclamation + vbDefaultButton2)
       ElseIf lCount > 50 And lCells > 100000 Then
        response = MsgBox("You are searching for " & lCount & " items in " & lCells & " cells" & vbCrLf & _
        "Searching too many items, Excel might crash... " & vbCrLf & _
        "Try narrowing search...Search for fewer items" & vbCrLf & _
        "Do you want to continue ? ", vbOKCancel + vbExclamation + vbDefaultButton2)
       ElseIf lCount > 5 And lCells > 400000 Then
        response = MsgBox("You are searching for " & lCount & " items in " & lCells & " cells" & vbCrLf & _
        "Searching too many items, Excel might crash... " & vbCrLf & _
        "Try narrowing search...Search for fewer items" & vbCrLf & _
        "Do you want to continue ? ", vbOKCancel + vbExclamation + vbDefaultButton2)
       ElseIf lCount > 200 And lCells > 50000 Then
        response = MsgBox("You are searching for " & lCount & " items in " & lCells & " cells" & vbCrLf & _
        "Searching too many items, Excel might crash... " & vbCrLf & _
        "Try narrowing search...Search for fewer items" & vbCrLf & _
        "Do you want to continue ? ", vbOKCancel + vbExclamation + vbDefaultButton2)
       ElseIf lCount > 400 And lCells > 25000 Then
        response = MsgBox("You are searching for " & lCount & " items in " & lCells & " cells" & vbCrLf & _
        "Searching too many items, Excel might crash... " & vbCrLf & _
        "Try narrowing search...Search for fewer items" & vbCrLf & _
        "Do you want to continue ? ", vbOKCancel + vbExclamation + vbDefaultButton2)
        
    End If
    
    If response = vbCancel Then Exit Sub
        
    
    Application.ScreenUpdating = False
    '' determine column to colour cell
    iCcol = 0
    If Me.cboRet_2.Value <> "" Then
        strCcol = Me.cboRet_2.Value
        iCcol = Range(strCcol & 1).Column
     End If
     
     ' Check for Partial Search
        If Me.btnPartial = -1 Then
            blnPartial = True
           Else
            blnPartial = False
        End If
     
     '' Determine number of select items
     n = 0
     With Me.lstItems
        iList = .ListCount
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                n = n + 1
            End If
        Next i
        
        If n > 1 Then
            'MsgBox "Multi " & n
             n = 0 ''re-initialize
            For i = 0 To .ListCount - 1
                 If .Selected(i) = True Then
                    n = n + 1
                    ReDim Preserve strItem(n)
                     strItem(n) = .List(i)
                  '' add addresses to listbox
                        For Each Cell In NewRange
                           If blnPartial = False Then
                                If UCase(CStr(Cell.Value)) = strItem(n) And iCcol < 1 Then
                                        If iCcolor = xlNone And iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = iCcolor
                                         End If

                                    strCell = Cell.Address ' last cell found
                                    With Me.lstAdd
                                        .additem strCell
                                    End With
                                ElseIf UCase(CStr(Cell.Value)) = strItem(n) And iCcol > 0 Then
                                    irow = Cell.Row
                                         If iCcolor = xlNone And iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = iCcolor
                                         End If
                                    strCell = Cell.Address ' last cell found
                                    With Me.lstAdd
                                        .additem strCell
                                    End With
                                End If
                              ElseIf blnPartial = True Then
                                If InStr(1, UCase(CStr(Cell.Value)), strItem(n)) And iCcol < 1 Then
                                        If iCcolor = xlNone And iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = iCcolor
                                         End If
                                    strCell = Cell.Address ' last cell found
                                    With Me.lstAdd
                                        .additem strCell
                                    End With
                                  ElseIf InStr(1, UCase(CStr(Cell.Value)), strItem(n)) And iCcol > 0 Then
                                    irow = Cell.Row
                                         If iCcolor = xlNone And iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = iCcolor
                                         End If
                                    strCell = Cell.Address ' last cell found
                                    With Me.lstAdd
                                        .additem strCell
                                    End With
                                End If
                              End If
                            
                         Next Cell
                    End If
                    '' Show Status
                        
                        Application.StatusBar = "Searching for: " & i + 1 & " of " & iList & " items: " & Format((i + 1) / iList, "0%") & " complete..."
                Next i
            ElseIf n <= 1 Then
                   '' Colour cells of  all list items found
                For i = 0 To .ListCount - 1
                    ReDim Preserve strItem(i)
                    strItem(i) = .List(i)
                   For Each Cell In NewRange
                       If blnPartial = False Then
                            If UCase(CStr(Cell.Value)) = strItem(i) And iCcol < 1 Then
                                     If iCcolor = xlNone And iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = iCcolor
                                         End If
                                  strCell = Cell.Address ' last cell found
                                  With Me.lstAdd
                                      .additem strCell
                                  End With
                              ElseIf UCase(CStr(Cell.Value)) = strItem(i) And iCcol > 0 Then
                                  irow = Cell.Row
                                       If iCcolor = xlNone And iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = iCcolor
                                         End If
                                  strCell = Cell.Address ' last cell found
                                  With Me.lstAdd
                                      .additem strCell
                                  End With
                              End If
                          ElseIf blnPartial = True Then
                            If InStr(1, UCase(CStr(Cell.Value)), strItem(i)) And iCcol < 1 Then
                                      If iCcolor = xlNone And iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                            Cell.Interior.ColorIndex = iCcolor
                                         End If
                                  strCell = Cell.Address ' last cell found
                                  With Me.lstAdd
                                      .additem strCell
                                  End With
                              ElseIf InStr(1, UCase(CStr(Cell.Value)), strItem(i)) And iCcol > 0 Then
                                  irow = Cell.Row
                                       If iCcolor = xlNone And iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = -4142
                                         ElseIf iCcolor <> 5000 Then
                                             Cells(irow, iCcol).Interior.ColorIndex = iCcolor
                                         End If
                                  strCell = Cell.Address ' last cell found
                                  With Me.lstAdd
                                      .additem strCell
                                  End With
                              End If
                          End If
                    Next Cell
                        '' Show Status
                             Application.StatusBar = "Searching for: " & i + 1 & " of " & iList & " items: " & Format((i + 1) / iList, "0%") & " complete..."
                             
                Next i
           End If
        End With
        
        
        If strCell <> "" Then
            Range(strCell).Select
        End If

    Me.lblFound.Caption = "Items Found:= " & Me.lstAdd.ListCount
    Application.StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
errorHandler:
    MsgBox "Highlight_All: " & Err.Description
    
End Sub

Private Sub cmdClear_Click()
    Application.StatusBar = ""
    Me.lblCells.Caption = ""
    Me.lblCount.Caption = ""
    Me.lblFound.Caption = ""
    Me.lstItems.Clear
    Me.lstAdd.Clear
End Sub
Private Sub cmdCopy_Click()
Dim i As Long, n As Long, x As Long
Dim rng As Range
Dim strVal() As String
On Error GoTo errorHandler
    With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                n = n + 1
                ReDim Preserve strVal(n)
                strVal(n) = .List(i)
                x = n
            End If
        Next i
    End With
    
    With ThisWorkbook.Sheets("misc")
        .Columns(1).Clear
        For n = 1 To UBound(strVal)
            .Cells(n, 1).Value = strVal(n)
        Next n
        Set rng = .Range(.Cells(1, 1), .Cells(x, 1))
    End With
    rng.Copy
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub

Private Sub cmdDrop_Click()
Dim i As Long

On Error GoTo errorHandler

    '' Remove items
Newitem:
        With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
                GoTo Newitem
            End If
        Next i
        End With
        '' count list items
        Me.lblCount.Caption = "Items Listed:= " & Me.lstItems.ListCount
        
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdHelp_Click()
    frmHelp.Show 0
End Sub
Private Sub cmdPaste_Click()
Dim Sh As Worksheet
Dim i As Long
Dim strname As String

On Error GoTo errorHandler
Set Sh = Worksheets.Add

    With Sh
        strname = .Name
    End With

    Sheets(strname).Activate
    With Me.lstItems
        For i = 0 To .ListCount - 1
            Cells(i + 1, 1).NumberFormat = "@"
            Cells(i + 1, 1).Value = .List(i)
        Next i
    End With
    
Exit Sub
errorHandler:
    MsgBox Err.Description

End Sub

Private Sub cmdSort_Click()
On Error GoTo errorHandler
    Call SortList
Exit Sub
errorHandler:
    If Err.Number = 13 Then
        MsgBox "List-box may be empty", vbInformation
       Else
        MsgBox "Error Number: " & Err.Number & vbCrLf & _
        Err.Description, vbExclamation
      End If
End Sub



Private Sub lstAdd_Click()
    Dim strAddress As String
    Dim strItem As String
    Dim i As Long
    
    strAddress = Me.lstAdd.Value
    '' Used range selection option due to scrolling to locate cell
    '' could have scroll option
    If Me.btnScroll = -1 Then
        Application.GoTo Reference:=ActiveSheet.Range(strAddress), _
        Scroll:=True
     Else
        Range(strAddress).Select
        strItem = Selection.Value
    End If
    
        With Me.lstItems
            For i = 0 To .ListCount - 1
                    .Selected(i) = False
            Next i
            
            For i = 0 To .ListCount - 1
                If strItem = .List(i) Then
                    .Selected(i) = True
                End If
            Next i
        End With
        
        
    
End Sub

Private Sub lstItems_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim rng As Range, Cell As Range
    Dim strCol As String, strCcol As String
    Dim strListItem As String
    Dim iCcolor As Long
    Dim strCell As String
    Dim irow As Long, i As Long, lRows As Long
    Dim blnPartial As Boolean
    Dim NewRange As Range
    Dim cSel As C_Selection
    Dim cSelNew As C_Selection
    
    On Error GoTo errorHandler

    Set rng = Application.Selection
    

   '' Select highlight colour
   If Me.cboColour = "(Clear)" Then
        iCcolor = xlNone
       ElseIf Me.cboColour = "(None)" Then
        iCcolor = 5000
       Else
        iCcolor = Me.cboColour.Value
    End If

    '' Clear address list
    Me.lstAdd.Clear
    With ActiveSheet
      If Me.cboRet_1.Value <> "" Then
       '' Search the designaed column selected in the drop-box
             strCol = Me.cboRet_1.Value
            'Set rng = .Range(.Range(strCol & 1), .Range(strCol & 65536).End(xlUp)).SpecialCells(xlCellTypeVisible)
             Set rng = Range(strCol & ":" & strCol)
             Set cSel = New C_Selection
             cSel.RngIn = rng
             cSel.RowsIn = rng.Rows.Count
             cSel.ColsIn = rng.Columns.Count
             Set NewRange = Range(cSel.rngOut_Address)
             Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
           ElseIf Me.cboRet_1.Value = "" Then
             Set cSel = New C_Selection
             cSel.RngIn = rng
             cSel.RowsIn = rng.Rows.Count
             cSel.ColsIn = rng.Columns.Count
             Set NewRange = Range(cSel.rngOut_Address)
             Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)
             If NewRange.Cells.Count = 1 Then
                MsgBox "Enter a Search column...", vbExclamation
                Me.cboRet_1.SetFocus
                Exit Sub
             End If
             
        End If
    End With
  
    Application.StatusBar = ""

    '' Clear address list
    Me.lstAdd.Clear
    
     lRows = rng.Cells.Count
     
    
    '' determine column to colour cell
    iCcol = 0
    If Me.cboRet_2.Value <> "" Then
        strCcol = Me.cboRet_2.Value
        iCcol = Range(strCcol & 1).Column
     End If
     
    '' Colour cells found
        With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                strListItem = .List(i)
            End If
        Next i
       
     ' Check for Partial Search
        If Me.btnPartial = -1 Then
            blnPartial = True
           Else
            blnPartial = False
        End If
        
        End With
        
        ''add address to listbox list lstAdd and highlight cells
       For Each Cell In NewRange
          If blnPartial = False Then
                If UCase(CStr(Cell.Value)) = strListItem And iCcol < 1 Then
                       If iCcolor = xlNone And iCcolor <> 5000 Then
                            Cell.Interior.ColorIndex = -4142
                          ElseIf iCcolor <> 5000 Then
                            Cell.Interior.ColorIndex = iCcolor
                        End If
                    strCell = Cell.Address ' last cell found
                    With Me.lstAdd
                        .additem strCell
                    End With
                ElseIf UCase(CStr(Cell.Value)) = strListItem And iCcol > 0 Then
                    irow = Cell.Row
                        If iCcolor = xlNone And iCcolor <> 5000 Then
                            Cells(irow, iCcol).Interior.ColorIndex = -4142
                          ElseIf iCcolor <> 5000 Then
                            Cells(irow, iCcol).Interior.ColorIndex = iCcolor
                        End If
                    strCell = Cell.Address ' last cell found
                    With Me.lstAdd
                        .additem strCell
                    End With
                End If
            Else
                '' Find Partial Match
                If InStr(1, UCase(CStr(Cell.Value)), strListItem) And iCcol < 1 Then
                        If iCcolor = xlNone And iCcolor <> 5000 Then
                            Cell.Interior.ColorIndex = -4142
                          ElseIf iCcolor <> 5000 Then
                            Cell.Interior.ColorIndex = iCcolor
                        End If
                    strCell = Cell.Address ' last cell found
                    With Me.lstAdd
                        .additem strCell
                    End With
                ElseIf InStr(1, UCase(CStr(Cell.Value)), strListItem) > 0 Then
                    irow = Cell.Row
                      If iCcolor = xlNone And iCcolor <> 5000 Then
                            Cells(irow, iCcol).Interior.ColorIndex = -4142
                          ElseIf iCcolor <> 5000 Then
                            Cells(irow, iCcol).Interior.ColorIndex = iCcolor
                        End If
                    strCell = Cell.Address ' last cell found
                    With Me.lstAdd
                        .additem strCell
                    End With
                End If
             End If
        Next Cell
        
        If strCell <> "" Then
        
            Range(strCell).Select
        End If
    Exit Sub
errorHandler:
    MsgBox Err.Description
    
End Sub

Private Sub UserForm_Deactivate()
    Application.StatusBar = ""
End Sub

Private Sub UserForm_Initialize()
'' populate column combos
Dim i As Long
Dim j As Long

On Error GoTo errorHandler
    'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If


    Me.cboRet_1.Clear
    Me.cboRet_2.Clear

         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + i)
        Me.cboRet_2.additem Chr$(64 + i)
    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + j) & Chr$(64 + i)
        Me.cboRet_2.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
    Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
    For i = 259 To 256 Step -1
        Me.cboRet_1.RemoveItem (i)
        Me.cboRet_2.RemoveItem (i)
    Next i
    
    ''' Colour indexes
        
        Me.cboColour.additem "(Clear)"
        Me.cboColour.additem "(None)"
        For i = 1 To 56
            Me.cboColour.additem (i)
        Next i
            ''set default
            Me.cboColour.Value = "(None)"
            Me.lblCells.Caption = ""
            Me.lblCount.Caption = ""
            Me.lblFound.Caption = ""
            
    'Retrieve stored value for Paste
     If ThisWorkbook.Sheets("MFilter").Range("E3").Value = -1 Then
        blnDefaultPaste = True
        Me.btnPaste.Value = "1"
        
        Me.btnPaste.Caption = "Use Paste"
     Else
        blnDefaultPaste = False
        Me.btnPaste.Value = 0
        Me.btnPaste.Caption = "Use Selection"
     End If
     
  Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical

    
End Sub

Private Sub SortList()
' Sort listbox

    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
    'Store the list in an array for sorting
    LbList = Me.lstItems.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If LbList(i, 0) > LbList(j, 0) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstItems.Clear
    
    'Repopulate with the sorted list
    Me.lstItems.List = LbList


End Sub


Private Sub UserForm_Terminate()
    Application.StatusBar = ""
End Sub
Attribute VB_Name = "frmFolder"
Attribute VB_Base = "0{7B3110D6-724A-4F16-8C4B-31F0C35DDFB5}{6132ADCF-ECCD-483F-BCF7-3F65C9BE75A4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Dim blnChange

Private Sub cmdCancel_Click()
Unload Me
frmShortCuts.Show 0
End Sub

Private Sub cmdOpen_Click()
Dim cFldr As cPath
Dim response As Integer
Dim strTxt As String

    Set cFldr = New cPath
    strTxt = cFldr.GetFolder
    
    response = MsgBox("Save Folder Path", vbOKCancel + vbExclamation, "Save short-cut...")
            If response = vbOK Then
                Call additem(strTxt)
            End If
End Sub

Private Sub additem(sTxt As String)
Dim rngFldrs As Range, rngAdd As Range, Cell As Range
Dim strFldrName As String, i As Long
Dim iIndex As Long, iTemp As Long, iMax As Long
    With ThisWorkbook.Sheets("sFolders")
        Set rngAdd = .Cells(65536, 1).End(xlUp).Offset(1, 0)
        Set rngFldrs = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
    End With
    strFldrName = Right(sTxt, InStr(StrReverse(sTxt), "\") - 1)
        
    If rngAdd.Offset(-1, 0).Value <> "Index" Then
           For Each Cell In rngFldrs
             If Cell.Value > iTemp Then
                iMax = Cell.Value
             End If
                iTemp = Cell.Value
             Next Cell
             
                iIndex = iMax + 1
        Else
                iIndex = 1
    End If
        
    '' add folder and path
    rngAdd.Value = iIndex
    rngAdd.Offset(0, 1) = strFldrName
    rngAdd.Offset(0, 2).Value = sTxt
  

    Me.lstFldrs.Clear
    With ThisWorkbook.Sheets("sFolders")
        Set rngFldrs = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
    End With
   i = 0
        With Me.lstFldrs
           '' Check if item is already listed
           '' If not then add to list
            For Each Cell In rngFldrs
                If Cell.Row <> 1 Then
                    .additem Cell.Value
                    .List(i, 1) = Cell.Offset(0, 1).Value
                    .List(i, 2) = Cell.Offset(0, 2).Value
                    i = i + 1
                End If
            Next Cell
        End With
        
        blnChange = True
        Call SortFldrs

End Sub

Private Sub cmdRemove_Click()
Dim rngFldrs As Range, Cell As Range
Dim i As Long
Dim iIndex As Long

    With Me.lstFldrs
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                iIndex = .List(i)
                Exit For
            End If
        Next i
        
    End With
    With ThisWorkbook.Sheets("sFolders")
        Set rngFldrs = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
    End With
    
    For Each Cell In rngFldrs
        If Cell.Value = iIndex Then
            Cell.EntireRow.Delete
            Exit For
        End If
    Next Cell
    
    With ThisWorkbook.Sheets("sFolders")
        Set rngFldrs = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
    End With

    Me.lstFldrs.Clear
    i = 0
        With Me.lstFldrs
           '' Check if item is already listed
           '' If not then add to list
            For Each Cell In rngFldrs
                If Cell.Row <> 1 Then
                    .additem Cell.Value
                    .List(i, 1) = Cell.Offset(0, 1).Value
                    .List(i, 2) = Cell.Offset(0, 2).Value
                    i = i + 1
                End If
            Next Cell
        End With
    blnChange = True
    Call SortFldrs
End Sub

Private Sub lstFldrs_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
Dim strFldr As String, strPath As String
Dim strFile
Dim i As Long
Dim blnOpen As Boolean

blnOpen = False

 On Error GoTo errorHandler
    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
    Exit Sub
    End If
    
    With Me.lstFldrs
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                strFldr = .List(i, 2)
                Exit For
            End If
        Next i
    End With


    With Application.FileDialog(msoFileDialogFilePicker)
        .InitialFileName = strFldr & "\"
        .Show
         strPath = .SelectedItems(1)
    End With
    
    
    strFile = Right(strPath, InStr(StrReverse(strPath), "\") - 1)
    
    ''' Check for open files
            For i = 1 To Workbooks.Count
                    If UCase(Workbooks(i).Name) = UCase(strFile) Then
                            MsgBox "File is Aready Open", vbExclamation
                            Workbooks(i).Activate
                            blnOpen = True
                                Exit For
                    End If
            Next i

            
            ''' Open the workbook if it isn't already open
            If strPath <> "" And blnOpen = False Then Workbooks.Open (strPath)
    
            Me.Hide
    
Exit Sub
errorHandler:
    If Err.Number = 5 Then
        MsgBox "Cancelled..."
       Else
        MsgBox Err.Description
     End If
End Sub



Private Sub UserForm_Initialize()
Dim rngFldrs As Range, Cell As Range
Dim i As Long
    
    blnChange = False
    With ThisWorkbook.Sheets("sFolders")
        Set rngFldrs = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
    End With

    Me.lstFldrs.Clear

     i = 0
        With Me.lstFldrs
           '' Check if item is already listed
           '' If not then add to list
            For Each Cell In rngFldrs
                If Cell.Row <> 1 Then
                    .additem Cell.Value
                    .List(i, 1) = Cell.Offset(0, 1).Value
                    .List(i, 2) = Cell.Offset(0, 2).Value
                    i = i + 1
                End If
            Next Cell
        End With
    
    Call SortFldrs
End Sub

Private Sub SortFldrs()
' Sort listbox

    Dim i As Long
    Dim j As Long
    Dim sTemp1 As String, sTemp0 As String, sTemp2 As String
    Dim LbList As Variant
    On Error GoTo errorHandler
        'Store the list in an array for sorting
        LbList = Me.lstFldrs.List
        
        'Bubble sort the array on the first value
        For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
            For j = i + 1 To UBound(LbList)
                If LbList(i, 1) > LbList(j, 1) Then
                    'Swap the first value
                    sTemp0 = LbList(i, 0)
                    sTemp1 = LbList(i, 1)
                    sTemp2 = LbList(i, 2)
                    LbList(i, 0) = LbList(j, 0)
                    LbList(i, 1) = LbList(j, 1)
                    LbList(i, 2) = LbList(j, 2)
                    LbList(j, 0) = sTemp0
                    LbList(j, 1) = sTemp1
                    LbList(j, 2) = sTemp2
                   sTemp0 = ""
                   sTemp1 = ""
                   sTemp2 = ""
                End If
            Next j
        Next i
    'Remove the contents of the listbox
        Me.lstFldrs.Clear
        
        'Repopulate with the sorted list
        Me.lstFldrs.List = LbList
  Exit Sub
  
errorHandler:
If Err.Number = 13 Then
    MsgBox "No items listed....." & vbCrLf & _
        "Please Enter a 'Group Name'", vbExclamation
    Else
  MsgBox Err.Description, vbCritical, "Error"
End If

End Sub

Private Sub UserForm_Terminate()
Dim response As Long


If blnChange = True Then
        response = MsgBox("Save changes to Short-cuts...", vbInformation + vbOKCancel)
            If response = vbOK Then ThisWorkbook.Save
 End If
End Sub
Attribute VB_Name = "frmFreeLic"
Attribute VB_Base = "0{DDEFACCF-647F-4B1B-B2C1-6211F86FBC42}{44AC3D67-F7C1-44C8-B971-8005BC427377}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub cmdExit_Click()
Dim rngAccept As Range

On Error GoTo errorHandler
    With ThisWorkbook.Sheets("Lic")
        Set rngAccept = .Cells(1, 2)
    End With
    
     rngAccept.Value = "No"
     ThisWorkbook.Save
    
     On Error Resume Next
        Application.Run "removeFromCell"
    On Error GoTo 0
    Unload Me
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdGo_Click()
Dim rngAccept As Range

On Error GoTo errorHandler

    On Error Resume Next
        Application.Run "removeFromCell"
    On Error GoTo 0
    
    With ThisWorkbook.Sheets("Lic")
        Set rngAccept = .Cells(1, 2)
    End With
    
    If Me.btnAcceptLic.Value = -1 And cInst.Check_Install = False Then
        rngAccept.Value = "Yes"
        Application.Cursor = xlWait
        ThisWorkbook.Save
        Application.Cursor = xlDefault
        Unload Me
    ElseIf Me.btnAcceptLic <> -1 Then
            MsgBox "To Continue you must Accept terms of Licence Aggreement"
    End If
    
     Set cInst = Nothing
Exit Sub
errorHandler:
    MsgBox Err.Description
    Application.Cursor = xlDefault
    
End Sub

Private Sub UserForm_Initialize()
Dim rngLic As Range, Cell As Range
    
    With ThisWorkbook.Sheets("Lic")
        Set rngLic = .Range(.Range("A1"), .Range("A65536").End(xlUp))
    End With

    With Me.lstLic
        For Each Cell In rngLic
            .additem Cell.Value
        Next Cell
        
    End With
   
End Sub


Attribute VB_Name = "frmGoToSheet"
Attribute VB_Base = "0{33EDBDE6-5517-49D8-A717-13BAF95E582F}{170C0F0F-F911-48B6-A595-67075EED9D0E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1
Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------

Private Sub CmdClose_Click()
''' Close the form
    Unload Me
    frmGoToSheet.Hide
End Sub

Private Sub Refresh()
''' Refresh and re-initilalize controls on Goto sheet form
    Me.lstSheets.Clear
    Me.lstWkBook.Clear
    UserForm_Initialize
End Sub

Private Sub cmdRefesh_Click()
''' Refresh and resort list boxes
    Call Refresh
    'Call SortList
    Call SortWbs
End Sub

Private Sub lstSheets_Click()
''' Some sheets may be hidden and produce an error when Selected
''' A run time error will occur if a sheet is hidden

Dim strSheet As String
    
    On Error GoTo errorHandler
        strSheet = Me.lstSheets.Text
        Sheets(strSheet).Select
    Exit Sub
    
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Cannot Got to Sheet" & vbCrLf & "It may be hidden..."
        Else
        MsgBox Err.Description, vbCritical, "Error Message"
    End If
End Sub

Private Sub lstWKBook_Click()
Dim strWkBook As String
   ''' On Action got to the workbook
    On Error GoTo errorHandler
        strWkBook = Me.lstWkBook.Text
        Workbooks(strWkBook).Activate
        Call Refresh
    Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub

Private Sub SpinButton1_SpinDown()
    Dim i As Integer
    Dim strSelect As String
    Dim strNext As String
    
    On Error GoTo errorHandler
    
    Application.ScreenUpdating = False
    With Me.lstSheets
            
        For i = 0 To .ListCount - 2
           If .Selected(i) = True Then ' find the selected item on the list
                 strSelect = .List(i) 'Store Selected item as a string variable
                 strNext = .List(i + 1) 'store the string value below the selected item
                .List(i) = strNext ' Swap the values so that the selected value
                .List(i + 1) = strSelect ' moves below the next value on the list
                .ListIndex = (i + 1) ' select the next item on the list
                Worksheets(strSelect).Move After:=Worksheets(strNext) ' move the sheet

                Exit For
            End If
        Next i
    
    Application.ScreenUpdating = True
    End With
    
Exit Sub
errorHandler:

    If Err.Number = 1004 Then
        MsgBox "Cannot move sheet..." & vbCrLf & "Workbook might be Protected", vbExclamation
      Else
       MsgBox Err.Description & vbCrLf & "Number: " & Err.Number, vbCritical
    End If

End Sub

Private Sub SpinButton1_SpinUp()

    Dim i As Long
    Dim strSelect As String
    Dim strNext As String
    
    On Error GoTo errorHandler
    
    Application.ScreenUpdating = False
    With Me.lstSheets
            
        For i = 1 To .ListCount
           If .Selected(i) = True Then
                strSelect = .List(i)
                strNext = .List(i - 1)
               .List(i) = strNext
               .List(i - 1) = strSelect
               .ListIndex = (i - 1)
               Worksheets(strSelect).Move before:=Worksheets(strNext)
               Exit For
            End If
        Next i
    Application.ScreenUpdating = True
    End With
 Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Cannot move sheet..." & vbCrLf & "Workbook might be Protected", vbExclamation
      Else
       MsgBox Err.Description & vbCrLf & "Number: " & Err.Number, vbCritical
    End If
End Sub

Private Sub UserForm_Activate()
    Call Refresh
End Sub

Private Sub UserForm_Initialize()
Dim i As Long
Dim j As Long
Dim ObjWb As Object

On Error GoTo errorHandler

  'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If

Set ObjWb = Application.Workbooks

''' Count all open workbooks and add names to list box
        For i = 1 To ObjWb.Count
                Me.lstWkBook.additem ObjWb(i).Name
        Next i
             ''' Count all sheets in Objwb and add names of sheets to list box
            For j = 1 To Sheets.Count
                If Sheets(j).Type = xlWorksheet Then
                    Me.lstSheets.additem Sheets(j).Name
                End If
            Next j

  Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub

Private Sub SortList()
' Sort listbox

    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
    'Store the list in an array for sorting
    LbList = Me.lstSheets.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If LbList(i, 0) > LbList(j, 0) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstSheets.Clear
    
    'Repopulate with the sorted list
    Me.lstSheets.List = LbList


End Sub

Private Sub SortWbs()
' Sort listbox

    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
    'Store the list in an array for sorting
    LbList = Me.lstWkBook.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If LbList(i, 0) > LbList(j, 0) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstWkBook.Clear
    
    'Repopulate with the sorted list
    Me.lstWkBook.List = LbList


End Sub
Attribute VB_Name = "frmGroupList"
Attribute VB_Base = "0{F3F65E08-5FD7-483B-97BC-B1F49AA67095}{3371D4C2-CF5B-4B7D-8465-A5601ADBE048}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Option Base 1
Dim strAddress As String
Dim NewRng As Range
Dim BlnCancelGrp As Boolean
Dim blnClose As Boolean

Private Sub OptionSelect()
''' Retrieve Values into form listbox for Group Selected
''' and select the 2nd item on the list
On Error Resume Next
    Call SelectList
    With lstName
        .SetFocus
        .ListIndex = 1
    End With

End Sub
Private Sub btn1_Click()
    Call OptionSelect
End Sub

Private Sub Btn2_Click()
    Call OptionSelect
End Sub

Private Sub Btn3_Click()
    Call OptionSelect
End Sub

Private Sub Btn4_Click()
    Call OptionSelect
End Sub

Private Sub Btn5_Click()
    Call OptionSelect
End Sub

Private Sub Btn6_Click()
    Call OptionSelect
End Sub
Private Sub Btn7_Click()
    Call OptionSelect
End Sub
Private Sub Btn8_Click()
    Call OptionSelect
End Sub
Private Sub Btn9_Click()
    Call OptionSelect
End Sub
Private Sub Btn10_Click()
    Call OptionSelect
End Sub
Private Sub Btn11_Click()
    Call OptionSelect
End Sub
Private Sub Btn12_Click()
    Call OptionSelect
End Sub

Private Sub Btn13_Click()
    Call OptionSelect
End Sub
Private Sub Btn14_Click()
    Call OptionSelect
End Sub
Private Sub Btn15_Click()
    Call OptionSelect
End Sub
Private Sub Btn16_Click()
    Call OptionSelect
End Sub
Private Sub Btn17_Click()
    Call OptionSelect
End Sub
Private Sub Btn18_Click()
    Call OptionSelect
End Sub
Private Sub Btn19_Click()
    Call OptionSelect
End Sub
Private Sub Btn20_Click()
    Call OptionSelect
End Sub
Private Sub Btn21_Click()
    Call OptionSelect
End Sub
Private Sub Btn22_Click()
    Call OptionSelect
End Sub
Private Sub Btn23_Click()
    Call OptionSelect
End Sub
Private Sub Btn24_Click()
    Call OptionSelect
End Sub

Private Sub btnClose_Click()
    Unload Me
End Sub
Private Sub btnDelete_Click()
''' Delete item from table then refreshnthe list box by reloading the form
Dim lRow As Long
Dim rcRange As Range
Dim strRC As String, strItem As String
Dim i As Long
Dim response
 On Error GoTo errorHandler
 Set rcRange = ThisWorkbook.Sheets("sCuts").Range(strAddress)
''' Get the address of the record to be removed
strRC = rcRange.Address(ReferenceStyle:=xlR1C1)   ' Z1S1
strRC = Right(strRC, Len(strRC) - 1)
i = InStr(1, strRC, "C") - 1
lRow = Left(strRC, i)

'''Get list item name
With Me.lstName
        For i = 1 To .ListCount - 1
            If .Selected(i) = True Then
                strItem = .List(i)
            Exit For
            End If
        Next i
        
End With
''' Display option to remove or cancel removal of record
response = MsgBox("Delete Short-cut item: " & "'" & strItem & "'", vbOKCancel + vbExclamation, "Delete Record")
    If response = vbOK Then
        ThisWorkbook.Sheets("sCuts").Rows(lRow).Delete  ''' Remove record
    End If
'''Update the listboxes
On Error Resume Next
    Call btnSort_Click
    Call UserForm_Initialize
On Error GoTo 0
 ''' Clear the textboxes
    Me.txtName.Text = ""
    Me.txtFilePath.Text = ""

Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub

Private Sub BtnGroups_Click()
    Unload Me
    frmGroups.Show
End Sub

Private Sub btnLocate_Click()
Dim clsPath As cPath
Dim response As Integer

    Set clsPath = New cPath
    Me.txtFilePath.Text = clsPath.GetPath
    
    response = MsgBox("Save Short-cut Path", vbOKCancel + vbExclamation, "Save short-cut...")
            If response = vbOK Then Call btnUpdate_Click
End Sub

Private Sub NewRecord()
Dim rng As Range
Dim i As Long
Dim Stri As String
Dim response

''Locate the range for new record
Set rng = ThisWorkbook.Sheets("sCuts").Range("File_Name")
  i = rng.Rows.Count + 2
  Stri = "A" & i
  Set NewRng = ThisWorkbook.Sheets("sCuts").Range(Stri)
            
End Sub

Private Sub btnSort_Click()
''' Sort items in table
Dim rngName As Range
Dim Cell As Range
On Error GoTo errorHandler

Set rngName = ThisWorkbook.Sheets("sCuts").Range("File_Name")

    With rngName.CurrentRegion
        .Sort Key1:=.Range("A2"), _
        Order1:=xlAscending, _
        Header:=xlYes, _
        OrderCustom:=1, _
        MatchCase:=False, _
        Orientation:=xlTopToBottom, _
        DataOption1:=xlSortNormal
End With
 ''' Reset Listbox
Call SelectList
Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub

Private Sub btnUpdate_Click()
''' Adding a new item or updating an existing one
Dim rng As Range
Dim strText As String
Dim strAdd As String
Dim i As Long, n As Long

On Error GoTo errorHandler
n = 0
With Me.lstName
    strText = .Text
        For i = 1 To .ListCount - 1
            If .Selected(i) = True Then
                n = i
            Exit For
            End If
        Next i
        
End With
        ''' Adding a new product Newrng represents the bottom of the list
        If strText = "(New)" Then
            NewRng.Value = Me.txtName.Text
            NewRng.Offset(0, 1).Value = Me.txtFilePath.Text
            NewRng.Offset(0, 2).Value = GroupSelected
         ''' Update an existing record in the table
          Else ''' Find the text value and get the address
             With ThisWorkbook.Sheets("sCuts").Range("File_Name")
                    Set rng = .Find(strText, lookat:=xlWhole, LookIn:=xlValues)
                     If Not rng Is Nothing Then
                         strAdd = rng.Address
                       Else
                         Exit Sub
                     End If
            End With
            ''' Update the table values
            Set rng = ThisWorkbook.Sheets("sCuts").Range(strAdd)
            rng.Value = Me.txtName.Text
            rng.Offset(0, 1).Value = Me.txtFilePath.Text
            rng.Offset(0, 2).Value = Me.cboGroupID.Value
        End If
            
    
   Call SelectGroupList
   
    If n > 0 Then  '' ie item other than(new) is selected in list box
        With Me.lstName
            .SetFocus ' select the list box
            ''.List(n) = Me.txtName.Text (channge list value to saved value
            On Error Resume Next ''if list index = 0
                .ListIndex = n '' select the item in the list
            On Error GoTo 0
        End With
    End If
   
Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, vbExclamation, "Error updating..."
End Sub


Private Sub cmdBup_Click()
Dim clsFldr As cPath
Dim strFolder As String
Dim strBook As String, strFile As String
Dim strBup As String
Dim newWb As Workbook

On Error GoTo errorHandler
    Application.ScreenUpdating = False
    ''Backupfile name
    
        strFile = "ShortCuts_Backup.xls"
    '' Add a new workbook
   Set newWb = Workbooks.Add
        
        '' Activate the workbook and get the workbpoo name
        newWb.Activate
        strBook = ActiveWorkbook.Name
            
          '' copy the sheets from the addin to the new workbook
        ThisWorkbook.Sheets("sFolders").Copy before:=Workbooks(strBook).Sheets(1)
        ThisWorkbook.Sheets("sGroup").Copy before:=Workbooks(strBook).Sheets(1)
        ThisWorkbook.Sheets("sCuts").Copy before:=Workbooks(strBook).Sheets(1)
        
        
        ''Create instance of folder picker class
        Set clsFldr = New cPath
        strFolder = clsFldr.GetFolder
        
        '' save the workbook as a .xls file and close it
        ChDir strFolder
        If Application.Version > 11 Then
           ActiveWorkbook.SaveAs Filename:= _
           strFolder & "\" & strFile, FileFormat:=xlExcel5, _
           Password:="", WriteResPassword:="", ReadOnlyRecommended:=False, _
           CreateBackup:=False
          Else
           ActiveWorkbook.SaveAs Filename:= _
           strFolder & "\" & strFile, _
           Password:="", WriteResPassword:="", ReadOnlyRecommended:=False, _
           CreateBackup:=False
        End If
        ActiveWorkbook.Close
       Application.ScreenUpdating = True
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdMove_Click()
Dim msg As String
Dim strCtl(24) As String
Dim strCap(24) As String
Dim ctl(24) As control
Dim i As Long
    BlnCancelGrp = False
    msg = "To move between groups, select the file then Edit the Group ID... " & Chr(13) & Chr(13)
        For i = 1 To 24
                strCtl(i) = "Btn" & i
                Set ctl(i) = Me.Controls(strCtl(i))
                strCap(i) = Left(ctl(i).Caption, 8)
                msg = msg & strCap(i) & vbTab & vbTab & "Group ID: " & i & vbCrLf
            Next i
            
    Me.cboGroupID.BackStyle = fmBackStyleOpaque
    Me.cboGroupID.Enabled = True
    MsgBox msg & vbCrLf & "Then Click 'Update Button'", vbInformation
    Me.cboGroupID.SetFocus
    
End Sub

Private Sub cmdUpload_Click()
'' Appends records to internal file
Dim clsFile As cPath
Dim strFile As String, strfName As String
Dim strRev As String
Dim rngGrp As Range, rngCuts As Range, Cell As Range, rng As Range
Dim rngFldr As Range
Dim ArrayGrp() As Variant, ArrayCuts() As Variant, ArrayFldr() As Variant
Dim i As Long, j As Long, irow As Long
Dim iCuts As Long, iGrp As Long, iFldr As Long
Dim blnSkip As Boolean

 On Error GoTo errorHandler
    Application.ScreenUpdating = False
     MsgBox "Process appends backup file. Re-open and cleanup when done", vbExclamation
    ''Create instance of folder picker class
        Set clsFile = New cPath
        ''Backup File Name
        strFile = clsFile.GetPath
    
        
       '' Open the Backup file
          Workbooks.Open (strFile)
          '' extract file name from path
          strRev = StrReverse(strFile)
          strfName = Trim(Right(strFile, InStr(1, strRev, "\") - 1))
          blnSkip = False
          Workbooks(strfName).Activate
          '' set ranges in active workbook
          With ActiveWorkbook
                '' Check if sFolders is in backup
                    For i = 1 To .Sheets.Count
                        .Sheets(i).Activate
                        If ActiveSheet.Name = "sFolders" Then Exit For
                        If i = .Sheets.Count And ActiveSheet.Name <> "sFolders" Then
                                .Sheets.Add
                                With ActiveSheet
                                    .Name = "sFolders"
                                    .Cells(1, 1).Value = "Index"
                                    .Cells(1, 2).Value = "Folder Name"
                                    .Cells(1, 3).Value = "Folder Path"
                                    .Range("A1:C1").Font.Bold = True
                                 End With
                                Exit For
                        End If
                    Next i
                '' define backup ranges
                .Sheets("sCuts").Activate
                With ActiveSheet
                    Set rngCuts = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
                End With
                .Sheets("sGroup").Activate
                With ActiveSheet
                    Set rngGrp = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
                End With
                .Sheets("sFolders").Activate
                With ActiveSheet
                    '' don't define range when records are empty
                    If .Cells(2, 1).Value <> "" Then
                        Set rngFldr = .Range(.Cells(2, 1), .Cells(65536, 1).End(xlUp))
                       Else
                        Set rngFldr = .Range(.Cells(1, 1), .Cells(1, 3)) '' top row
                        blnSkip = True
                     End If
                End With
          End With
        
        ''load values from upload sheet into array
        i = 0
        For Each Cell In rngCuts
            i = i + 1
                ReDim Preserve ArrayCuts(3, i)
                    If Cell.Value <> "" Then
                        ArrayCuts(1, i) = Cell.Value
                        ArrayCuts(2, i) = Cell.Offset(0, 1).Value
                        ArrayCuts(3, i) = Cell.Offset(0, 2).Value
                        iCuts = i
                       Else
                        Exit For
                    End If
        Next Cell
                
        i = 0
        For Each Cell In rngGrp
            i = i + 1
                ReDim Preserve ArrayGrp(3, i)
                    If Cell.Value <> "" Then
                        ArrayGrp(1, i) = Cell.Value
                        ArrayGrp(2, i) = Cell.Offset(0, 1).Value
                        ArrayGrp(3, i) = Cell.Offset(0, 2).Value
                        iGrp = i
                       Else
                        Exit For
                    End If
        Next Cell
        If blnSkip = False Then
            i = 0
                For Each Cell In rngFldr
                    i = i + 1
                        ReDim Preserve ArrayFldr(3, i)
                            If Cell.Value <> "" Then
                                ArrayFldr(1, i) = Cell.Value
                                ArrayFldr(2, i) = Cell.Offset(0, 1).Value
                                ArrayFldr(3, i) = Cell.Offset(0, 2).Value
                                iFldr = i
                               Else
                                Exit For
                            End If
                Next Cell
            Else
                   With rngFldr
                        ReDim Preserve ArrayFldr(3, 1)
                            ArrayFldr(1, 1) = .Cells(1, 1).Value
                            ArrayFldr(2, 1) = .Cells(1, 2).Value
                            ArrayFldr(3, 1) = .Cells(1, 3).Value
                    End With
                
        End If
        
        With ThisWorkbook.Sheets("sCuts")
            Set rng = .Range("A1") '' last cell containing a value
            irow = rng.Row
            '' Append values to addin sheet
            For i = 1 To iCuts
                .Cells(irow + i, 1).Value = ArrayCuts(1, i)
                .Cells(irow + i, 2).Value = ArrayCuts(2, i)
                .Cells(irow + i, 3).Value = ArrayCuts(3, i)
            Next i
        End With
        
        
        
        With ThisWorkbook.Sheets("sGroup")
            Set rng = .Range("A1") '' First cell
            irow = rng.Row
            ''Replace values to addin sheet
            For i = 1 To iGrp
            .Cells(irow + i, 1).Value = ArrayGrp(1, i)
            .Cells(irow + i, 2).Value = ArrayGrp(2, i)
            .Cells(irow + i, 3).Value = ArrayGrp(3, i)
            Next i
        
        End With
        
        With ThisWorkbook.Sheets("sFolders")
            Set rng = .Range("A1") '' First cell
            irow = rng.Row
            ''Replace values to addin sheet
            For i = 1 To iFldr
            .Cells(irow + i, 1).Value = ArrayFldr(1, i)
            .Cells(irow + i, 2).Value = ArrayFldr(2, i)
            .Cells(irow + i, 3).Value = ArrayFldr(3, i)
            Next i
        
        End With
    
        '' save the Thisworkbook
        ThisWorkbook.Save
        ActiveWorkbook.Close
       Application.ScreenUpdating = True
       MsgBox "Backup restored...", vbInformation
Exit Sub
errorHandler:
    MsgBox Err.Description

End Sub

Private Sub fm_Group_Click()
    Me.txtFilePath = ""
    Me.txtName = ""
   Call OptionSelect
End Sub



Private Sub lstName_Click()
''' Click the form list and retrive the record from the table
Dim strText As String
Dim strAdd As String
Dim rng As Range

On Error GoTo errorHandler
    Me.cboGroupID.BackStyle = fmBackStyleTransparent
    Me.cboGroupID.Enabled = False

strText = Me.lstName

        ''' Selecting a New item to add to table
        If strText = "(New)" Then
                     Me.txtName.Text = ""
                     Me.txtFilePath.Text = ""
                     Me.txtName.SetFocus
                     Call NewRecord
            Else  ''' Selecting an existing item to edit
                With ThisWorkbook.Sheets("sCuts").Range("File_Name")
                    Set rng = .Find(strText, lookat:=xlWhole, LookIn:=xlValues)
                            If Not rng Is Nothing Then
                                 strAdd = rng.Address
                                 strAddress = strAdd ''' Reset variable string address based on List selection
                              Else
                                Exit Sub
                            End If
                End With
                ''' Retrieve values
                Me.txtName.Text = rng.Value
                Me.txtFilePath.Text = rng.Offset(0, 1).Value
                Me.cboGroupID.Value = rng.Offset(0, 2).Value
    
        End If
Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub

Private Sub cboGroupID_Change()
Dim response As Integer
Dim iGrp As Integer
Dim ctl As control
Dim strCtl As String, strCap As String

    iGrp = Me.cboGroupID
    Set ctl = Controls("btn" & iGrp)
    strCtl = ctl.Name
    strCap = Controls(strCtl).Caption
    ''' Check that for valid entry
                If BlnCancelGrp = False Then
                    response = MsgBox("Move record to: " & strCap, vbOKCancel + vbExclamation)
                        If response = vbOK Then
                            Call btnUpdate_Click
                            Me.cboGroupID.BackStyle = fmBackStyleTransparent
                            Me.cboGroupID.Enabled = False
                        End If
                        BlnCancelGrp = True
                End If
End Sub
Private Sub UserForm_Activate()
On Error Resume Next
    Call ButtonCaptions
    Me.btn1 = 1
    Call SelectList
    lstName.ListIndex = 1
    
End Sub

Private Sub UserForm_Initialize()
Dim rngStart As Range
Dim i As Long
On Error GoTo errorHandler

Set rngStart = ThisWorkbook.Sheets("sCuts").Range("A2")

    ''' On initial entry, load some defaults into the form
    BlnCancelGrp = True
    
    If rngStart.Value = "" Then
        rngStart.Value = "MyFile"
        Me.txtName.Text = rngStart.Value
        rngStart.Offset(0, 1).Value = "C:\Data\MyFile_Name.xls"
    End If
    
    ''' Otherwise load the first record
            Me.txtName.Text = rngStart.Value
            Me.txtFilePath.Text = rngStart.Offset(0, 1).Value
            strAddress = rngStart.Address
    ''' File List
    With Me.cboGroupID
        For i = 1 To 24
            .additem (i)
        Next i
            .BackStyle = fmBackStyleTransparent
            .Enabled = False
        
    End With
   Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
        
End Sub


Private Function GroupSelected()
''' Function gets the button number selected
''' This number is used to assign a group number to the records in the table
    Dim intGroup As Integer
    Dim ctl(24) As control
    Dim strCtl(24) As String
    Dim i As Integer
    
  On Error GoTo errorHandler
    ''' Put Control names into array string 'strCtl'
    ''' Then put the option button controls into the 'ctl' array
            
            For i = 1 To 24
                strCtl(i) = "Btn" & i
                Set ctl(i) = Me.Controls(strCtl(i))
            Next i
             ''' assign intGroup integer to the control selected
            For i = 1 To 24
                If ctl(i) = -1 Then intGroup = i
            Next i

        GroupSelected = intGroup
        
Exit Function
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Function

Private Sub SelectList()
''' Populate list box based on the option selected on the form
Dim rngName As Range
Dim Cell As Range
Dim i As Long


Set rngName = ThisWorkbook.Sheets("sCuts").Range("File_Name")
  ''' Reset List box
        On Error Resume Next
             Me.lstName.Clear
        On Error GoTo 0
     Me.lstName.additem "(New)"
     
                For i = 1 To 24
                    If GroupSelected = i Then
                        For Each Cell In rngName.Cells
                            If Cell.Offset(0, 2).Value = i Then
                                Me.lstName.additem Cell.Value   ' Add the codes to list
                            End If
                        Next Cell
                    End If
                Next i

 
End Sub
Private Sub ButtonCaptions()
    Dim rngList As Range
    Dim ctl(24) As control
    Dim strCtl(24) As String
    Dim i As Integer
    
 On Error GoTo errorHandler
    ''' Put Control names into array string 'strCtl'
    ''' Then put the option button controls into the 'ctl' array
            
            For i = 1 To 24
                strCtl(i) = "Btn" & i
                Set ctl(i) = Me.Controls(strCtl(i))
            Next i
                
    ''' Change caption based on index(position) values retieved
    ''' from the worksheet table in range 'GroupList'
    
    Set rngList = ThisWorkbook.Sheets("sGroup").Range("GroupList")
        For i = 1 To 24
            ctl(i).Caption = Application.WorksheetFunction.Index(rngList, i)
        Next i
 
 Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub

Private Sub SelectGroupList()
''' Populate list box based on the option selected on the form
Dim rngName As Range
Dim Cell As Range
Dim ctl(24) As control
Dim strCtl(24) As String
Dim i As Integer


Set rngName = ThisWorkbook.Sheets("sCuts").Range("File_Name")
  ''' Reset List box
        On Error Resume Next
             Me.lstName.Clear
        On Error GoTo 0
     Me.lstName.additem "(New)"
     
                For i = 1 To 24
                    If Me.cboGroupID = i Then
                        For Each Cell In rngName.Cells
                            If Cell.Offset(0, 2).Value = i Then
                                Me.lstName.additem Cell.Value   ' Add the codes to list
                            End If
                        Next Cell
                    End If
                Next i
        
        
    ''' Put Control names into array string 'strCtl'
    ''' Then put the option button controls into the 'ctl' array
            
            For i = 1 To 24
                strCtl(i) = "Btn" & i
                Set ctl(i) = Me.Controls(strCtl(i))
                    If Me.cboGroupID = i Then
                       ctl(i).Value = 1
                       Exit For
                    End If
            Next i
 
End Sub

Private Sub UserForm_Terminate()
Dim iResp As Integer
   iResp = MsgBox("Save short-cut changes", vbYesNo + vbExclamation)
        If iResp = vbYes Then ThisWorkbook.Save
        frmShortCuts.Show 0
End Sub
Attribute VB_Name = "frmGroups"
Attribute VB_Base = "0{289F505F-92D2-47DD-8DB1-44BEB5B46784}{5E805B1B-75D5-4E5B-814F-48E651642CDB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub cmdUpdate_Click()
    Dim rngList As Range
    Dim ctl(24) As control
    Dim strCtl(24) As String
    Dim i As Long
    
    On Error GoTo errorHandler
    
    ''' Put Control names into array string 'strCtl'
    ''' Then put the text box controls into the 'ctl' array
            
            For i = 1 To 24
                strCtl(i) = "txtGroup" & i
                Set ctl(i) = Me.Controls(strCtl(i))
            Next i
    
    Set rngList = ThisWorkbook.Sheets("sGroup").Range("A1") ''' List range header
    
        For i = 1 To 24
            rngList.Offset(i, 0).Value = ctl(i).Value
        Next i
        
    'Call btnForm
    Call CmdClose_Click
Exit Sub
errorHandler:

        MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub
Private Sub CmdClose_Click()
    frmGroups.Hide
    frmGroupList.Show
    
End Sub



Private Sub txtGroupNo_AfterUpdate()
       ''' Check entry of groups required
    ''' if error is determined then send a message,reset the original value
    ''' set focus back to the control and Highlight the value
    ''' in the control with the sendkeys command
    
On Error GoTo errorHandler

     If Me.txtGroupNo.Value > 24 Or Me.txtGroupNo.Value < 1 Then
        MsgBox "There are only 24 options", vbExclamation
        Me.txtGroupNo = intGroupIndex
        Me.txtGroupNo.SetFocus
        SendKeys "+" & "{Home}"
     ElseIf Not IsNumeric(Me.txtGroupNo) Then
        MsgBox "Please enter a number between 1 and 24 "
        Me.txtGroupNo = intGroupIndex
        Me.txtGroupNo.SetFocus
        SendKeys "+" & "{Home}"
    End If
        ''' then accept value in control textbox
        ThisWorkbook.Sheets("sGroup").Range("C2") = Me.txtGroupNo
        
Exit Sub
errorHandler:

        MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub


Private Sub UserForm_Initialize()
    Dim rngList As Range
    Dim ctl(24) As control
    Dim strCtl(24) As String
    Dim i As Long
    
   On Error GoTo errorHandler
   
    ''' Put Control names into array string 'strCtl'
    ''' Then put the text box controls into the 'ctl' array
            
            For i = 1 To 24
                strCtl(i) = "txtGroup" & i
                Set ctl(i) = Me.Controls(strCtl(i))
            Next i
    
    Set rngList = ThisWorkbook.Sheets("sGroup").Range("A1")
    
        For i = 1 To 24
             ctl(i).Value = rngList.Offset(i, 0).Value
             'Debug.Print ctl(i).Value
        Next i
       ''' Assign the Global variable 'intGroupIndex' to its value in the workbook
      intGroupIndex = ThisWorkbook.Sheets("sGroup").Range("C2")
      ''' Set the control value to the variable
      Me.txtGroupNo.Value = intGroupIndex
      
Exit Sub
errorHandler:
  MsgBox "Description: " & Err.Description & vbCrLf & vbCrLf & "Error Number: " & Err.Number, _
        vbCritical, "Error..."
End Sub

Private Sub UserForm_Terminate()
    Call CmdClose_Click
End Sub
Attribute VB_Name = "frmHelp"
Attribute VB_Base = "0{4882E7BD-8572-4058-B3D5-5785575833BE}{1607AD7F-936A-4A3B-9CC8-E999D28538F1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cmdOK_Click()
    Me.Hide
End Sub


Private Sub UserForm_Initialize()
''Me.Label1.Caption = _
''" Select multiple items, then Click 'Add to List'  To locate items on the sheet, select a search range or entire column or select the search column on the form.  Select a highlight colour and optionally a highlight column if different from the search column.  Select the 'Find' button to activate the search.  Double click any list item to locate it on the sheet.  Please note: Multi-Find will ignore case locating all matching items regardless of their case."
End Sub
Attribute VB_Name = "frmHelpSC"
Attribute VB_Base = "0{047CA8E6-C0A5-48F0-B8D9-35669951430F}{52EC1F46-A717-40E5-BB90-389BE136B0C3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub cmdOK_Click()
    Me.Hide
End Sub

Attribute VB_Name = "frmHide"
Attribute VB_Base = "0{6B155D3E-2903-4286-86A6-89132FEB9C2C}{81C36552-B6F0-471D-A997-6E416BC8253C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Function shtHidden(TargetSheet As Worksheet) As Integer
     
If TargetSheet.Visible = xlSheetHidden Then
        shtHidden = 1
     ElseIf TargetSheet.Visible = xlSheetVeryHidden Then
        shtHidden = 2
    ElseIf TargetSheet.Visible = xlSheetVisible Then
        shtHidden = 0
End If
     
End Function

Private Sub CmdClose_Click()
    Unload Me
    frmProtectSheets.Show
End Sub

Private Sub cmdOK_Click()
Dim i As Long, k As Long
Dim intSheets As Long
Dim strname() As String
Dim strMsg As String



On Error GoTo errorHandler
    
    If ActiveWorkbook.ProtectStructure = True Then
             MsgBox "This Workbook is Password Protected" & vbCrLf & _
            "Unprotect the workbook to enable this Menu", vbExclamation
        Exit Sub
    End If
    
    
   With ActiveWorkbook
        intSheets = .Sheets.Count
    End With
    
    
    
    If Me.btnUnhide = -1 Then
       Me.btnHide = 0
       Me.btnVeryHidden = 0
       
                   
                    With Me.lstHidden
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) And i > 0 Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Visible = xlSheetVisible
                                     
                                 ''' If "(All Sheets)" is selected listbox
                                 ElseIf .Selected(i) And i = 0 Then
                                        For k = 1 To intSheets
                                            With ActiveWorkbook
                                                    Sheets(k).Visible = xlSheetVisible
                                            End With
                                        Next k
                             End If
                           
                         Next i
                        End With
                    With Me.lstVeryHidden
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) And i > 0 Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Visible = xlSheetVisible
                                     
                                 ''' If "(All Sheets)" is selected listbox
                                 ElseIf .Selected(i) And i = 0 Then
                                        For k = 1 To intSheets
                                            With ActiveWorkbook
                                                    Sheets(k).Visible = xlSheetVisible
                                            End With
                                        Next k
                             End If
                           
                         Next i
                        End With
                 
        ElseIf Me.btnVeryHidden = -1 Then
            Me.btnHide = 0
            Me.btnUnhide = 0
       
                   
                    With Me.lstHidden
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) And i > 0 Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Visible = xlSheetVeryHidden
                                     
                                 ''' If "(All Sheets)" is selected listbox
                                 ElseIf .Selected(i) And i = 0 Then
                                        For k = 1 To intSheets
                                            With ActiveWorkbook
                                                    Sheets(k).Visible = xlSheetVeryHidden
                                            End With
                                        Next k
                             End If
                           
                         Next i
                        End With
                    With Me.lstVisible
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) Then  ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Visible = xlSheetVeryHidden
                             End If
                           
                         Next i
                        End With


        ElseIf Me.btnHide = -1 Then
            Me.btnVeryHidden = 0
            Me.btnUnhide = 0
       
                   
                    With Me.lstVeryHidden
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) And i > 0 Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Visible = xlSheetHidden
                                     
                                 ''' If "(All Sheets)" is selected listbox
                                 ElseIf .Selected(i) And i = 0 Then
                                        For k = 1 To intSheets
                                            With ActiveWorkbook
                                                    Sheets(k).Visible = xlSheetHidden
                                            End With
                                        Next k
                             End If
                           
                         Next i
                        End With
                    With Me.lstVisible
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Visible = xlSheetHidden
                             End If
                           
                         Next i
                        End With

    End If
                
                ''' Unload and reload form when done
                ''' to display changes
                Unload Me
                frmHide.Show 0


 Exit Sub
errorHandler:
If Err.Number = 1004 Then
  MsgBox "Workbook must contain at least 'ONE Visible Sheet'", vbExclamation
  Else
        MsgBox "Description: " & Err.Description & vbCrLf _
        & "Number: " & Err.Number, vbCritical, "Error"
End If
        Me.btnHide = 0
        Me.btnUnhide = 1
        Me.btnVeryHidden = 0
End Sub

Private Sub cmdProtWB_Click()
Dim rng As Range
Dim strPassword As String
Dim response As Integer

On Error GoTo errorHandler

Set rng = ThisWorkbook.Sheets(1).Range("IV1")
    strPassword = rng.Value
    
    If strPassword = "" Then
          Application.Dialogs(xlDialogWorkbookProtect).Show
        Else
          response = MsgBox("Use Stored Password", vbExclamation + vbYesNo)
              If response = vbYes Then
                    If ActiveWorkbook.ProtectStructure = True Then
                              ActiveWorkbook.Unprotect (strPassword)
                              MsgBox "Workbook Unprotected"
                          Else
                              ActiveWorkbook.Protect (strPassword)
                              MsgBox "Workbook Protected"
                    End If
                  Else
                Application.Dialogs(xlDialogWorkbookProtect).Show
              End If
        End If
                
                
Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Workbook remains protected" & vbCrLf & "Please Check Password and try again"
    Else
        MsgBox Err.Description
    End If
End Sub










Private Sub cmdStorePW_Click()
    Me.Hide
    frmPassword.Show
End Sub

Private Sub lstHidden_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
 Dim i As Long
    ''' Deselect items in other lists
    For i = 0 To Me.lstVisible.ListCount - 1
        Me.lstVisible.Selected(i) = False
    Next i
    
    For i = 0 To Me.lstVeryHidden.ListCount - 1
        Me.lstVeryHidden.Selected(i) = False
    Next i
End Sub


Private Sub lstVeryHidden_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
     Dim i As Long
    ''' Deselect items in other lists
    For i = 0 To Me.lstVisible.ListCount - 1
        Me.lstVisible.Selected(i) = False
    Next i
    
    For i = 0 To Me.lstHidden.ListCount - 1
        Me.lstHidden.Selected(i) = False
    Next i
End Sub



Private Sub lstVisible_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
     Dim i As Long
    ''' Deselect items in other lists
    For i = 0 To Me.lstHidden.ListCount - 1
        Me.lstHidden.Selected(i) = False
    Next i
    
    For i = 0 To Me.lstVeryHidden.ListCount - 1
        Me.lstVeryHidden.Selected(i) = False
    Next i
End Sub

Private Sub UserForm_Initialize()
    Dim i As Long

    On Error Resume Next
        Me.lstVisible.Clear
        Me.lstHidden.Clear
        Me.lstVeryHidden.Clear
    On Error GoTo 0

             ''' Count all sheets in Objwb and add names of sheets to list box
    With Me.lstVisible
            For i = 1 To Sheets.Count
                If Sheets(i).Type = xlWorksheet Then
                    If shtHidden(Sheets(i)) = 0 Then
                        .additem Sheets(i).Name
                    End If
                End If
            Next i
    End With
    
    With Me.lstHidden
            .additem "( All Sheets )"
            For i = 1 To Sheets.Count
                If Sheets(i).Type = xlWorksheet Then
                    If shtHidden(Sheets(i)) = 1 Then
                        .additem Sheets(i).Name
                    End If
                End If
            Next i
    End With
    
    With Me.lstVeryHidden
            .additem "( All Sheets )"
            For i = 1 To Sheets.Count
                If Sheets(i).Type = xlWorksheet Then
                    If shtHidden(Sheets(i)) = 2 Then
                        .additem Sheets(i).Name
                    End If
                End If
            Next i
    End With
            Me.btnUnhide = 1
End Sub
Attribute VB_Name = "frmInsert"
Attribute VB_Base = "0{B4FCA9B2-36DC-4E76-9C75-848F6F151E21}{F0A858A9-7980-4E54-BDBB-54CE5EF9C8D0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub btnOK_Click()
Dim rng As Range, Cell As Range
Dim strCol As String, strPrev As String, strItem As String
Dim i As Long, irows As Long, lRowCell As Long, j As Long, iMax As Long, iCount As Long
Dim blnInsert As Boolean, iColor As Long, iCol As Long
Dim strHeader As String
Dim pct As Double
Dim lHdrow As Long


    On Error GoTo errorHandler
        '' clear clipboard
        On Error Resume Next
            Application.CutCopyMode = xlNone
        On Error GoTo 0
    
    strCol = Me.cboRet_1.Value
    irows = Me.cboRet_2.Value
    strHeader = CStr(Me.CboHrow.Value)
    lHdrow = Me.CboHrow.Value '' row immediately below the header
    
    If strCol = "" Then
            MsgBox "Please Select the crteria Column for insering rows", vbExclamation
        Exit Sub
    End If
    Set rng = Range(Range(strCol & strHeader), Range(strCol & strHeader).End(xlDown))
    
   ' rng.Select
    Application.ScreenUpdating = False
    strPrev = ""
    iMax = rng.Cells.Count
        If Me.cboColour.Value = "(None)" Then
            iColor = xlNone
          Else
            iColor = Me.cboColour.Value
        End If
    iCol = ActiveSheet.UsedRange.Columns.Count
    
    
    ''Row height
    pct = CDbl(Left(Me.cboRH.Value, Len(Me.cboRH.Value) - 1)) / 100
    
    '' Count the differences
    For j = 2 To iMax
            strItem = rng.Cells(j).Value
             ''Prevent addition rows being inserted
             
            If strPrev <> strItem Then
                iCount = iCount + (1 * irows)
            End If
            
                strPrev = strItem
    Next j
            '' Get the maximium number of rows
            iMax = iCount + iMax
    
    For j = 2 To iMax
            strItem = rng.Cells(j).Value
             ''Prevent addition rows being inserted
            If strPrev <> "" And strPrev <> strItem Then
                For i = 1 To irows
                    lRowCell = rng.Cells(j).Row
                    
                    If Me.cboColour = "(None)" And lRowCell <> lHdrow Then
                        Rows(lRowCell).Insert
                        Range(Cells(lRowCell, 1), Cells(lRowCell, iCol)).Interior.ColorIndex = xlNone
                        Rows(lRowCell).RowHeight = pct * Rows(lRowCell).RowHeight
                       ElseIf Me.cboColour <> "(None)" And lRowCell <> lHdrow Then
                        Rows(lRowCell).Insert
                        Range(Cells(lRowCell, 1), Cells(lRowCell, iCol)).Interior.ColorIndex = iColor
                        Rows(lRowCell).RowHeight = pct * Rows(lRowCell).RowHeight
                    End If
                        
                    blnInsert = True
                Next i
               Else: blnInsert = False
             End If
             
            If blnInsert = True Then
                strPrev = ""
                Else
                    strPrev = rng.Cells(j).Value
             End If
    Next j
    
    Application.ScreenUpdating = True
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cboColour_Change()
Dim rng As Range
On Error Resume Next
Set rng = ThisWorkbook.Sheets(1).Range("A65536")

     If Me.cboColour = "(Clear)" Or Me.cboColour = "(None)" Then
        Me.lblColour.BackStyle = fmBackStyleTransparent
      ElseIf IsNumeric(Me.cboColour) Then
        '' convert colorindex to label background
         rng.Interior.ColorIndex = Me.cboColour.Value
         Me.lblColour.BackStyle = fmBackStyleOpaque
         Me.lblColour.BackColor = rng.Interior.Color
    End If

End Sub

Private Sub UserForm_Initialize()
'' populate column combos
Dim i As Long
Dim j As Long
Dim pct As Double

On Error GoTo errorHandler

    Me.cboRet_1.Clear
    Me.cboRet_2.Clear
    Me.CboHrow.Clear
    Me.cboColour.Clear
    Me.cboRH.Clear
    
         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + i)
        Me.cboRet_2.additem i
    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
    Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
    For i = 259 To 256 Step -1
        Me.cboRet_1.RemoveItem (i)
    Next i
    
        '' Header row number
        For i = 1 To 500
            Me.CboHrow.additem (i)
        Next i
    
    ''' Colour indexes
        Me.cboColour.additem "(None)"
        For i = 1 To 56
            Me.cboColour.additem (i)
        Next i
    
        ''Row height
        For pct = 1 To 0.1 Step -0.1
            Me.cboRH.additem Format((pct), "0%")
        Next pct
            ''set default
            Me.cboColour.Value = "(None)"
            Me.CboHrow.Value = 1
            Me.cboRet_2.Value = 1
            Me.cboRH.Value = Format(1, "0%")
Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical
    
End Sub

Attribute VB_Name = "frmInsertText"
Attribute VB_Base = "0{FBFF51D5-5984-4CC4-989E-53201B3D4BDD}{CB16670B-13B1-4216-A07C-5FF7A1E77804}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

''====================================================================================
'' Written by Peter Tscherne
'' www.Sustainableoutcomes.com.au
''======================================================================================
Option Explicit
Option Base 1
Private Sub CmdClose_Click()
    Me.Hide
End Sub

Private Sub cmdStore_Click()
    Unload Me
    frmStoreText.Show 0
End Sub

Private Sub lstText_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim rng As Range, rngFind As Range
    Dim strvalue As String
    Dim strLine(5) As String
    Dim i As Long
    Dim lngRow As Long
    Dim dblTop As Double
    Dim dblLeft As Double
    Dim dblHeight As Double, dblWidth As Double
    
On Error GoTo errorHandler
    strvalue = Me.lstText.Value

    With ThisWorkbook.Sheets("SC")
            Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
    End With
    ''' Find the selected value and its text values
    With rng
        Set rngFind = .Find(strvalue, LookIn:=xlValues, lookat:=xlWhole)
        '' Retrieve the text
           If Not rngFind Is Nothing Then
                 lngRow = rngFind.Row
                If rngFind.Offset(0, 13).Value = 1 Then
                    For i = 1 To 5
                        If rngFind.Offset(0, i).Value <> "" Then
                            strLine(i) = rngFind.Offset(0, i).Value
                        End If
                    Next i
                   Else
                     strLine(1) = rngFind.Offset(0, 1).Value
                End If
           End If
    End With
       '' Retrieve the stored text
With ActiveSheet
     '''Applies to 1st Text Box
    If rngFind.Offset(0, 13) = 0 Then '' No additional lines
            If rngFind.Offset(0, 12).Value = "TextBox" Then  'Text box is selected
                dblTop = ActiveCell.Top ' Find Postion of selection
                dblLeft = ActiveCell.Left  ' for both top & bottom
                
                 ActiveSheet.Shapes.AddTextbox(msoTextOrientationHorizontal, _
                 dblLeft, dblTop, 288#, 64.5).Select
                  Selection.Characters.Text = strLine(1)
                  If rngFind.Offset(0, 14).Value <> -4142 Then
                    Selection.Interior.ColorIndex = rngFind.Offset(0, 14).Value
                  End If
                  With Selection.Characters.Font
                         If rngFind.Offset(0, 6).Value = "Bold" Then
                            .Bold = True
                           ElseIf rngFind.Offset(0, 6).Value = "Italic" Then
                            .Italic = True
                           ElseIf rngFind.Offset(0, 6).Value = "Bold Italic" Then
                             .Italic = True
                             .Bold = True
                           ElseIf rngFind.Offset(0, 6).Value = "Regular" Then
                             .Italic = False
                             .Bold = False
                         End If
                        .Name = rngFind.Offset(0, 7).Value
                        .Size = rngFind.Offset(0, 8).Value
                        .ColorIndex = rngFind.Offset(0, 9).Value
                  End With
                        '' text box size
                            If IsNumeric(rngFind.Offset(0, 16).Value) Then
                                dblHeight = (rngFind.Offset(0, 16).Value)
                                Selection.ShapeRange.ScaleHeight dblHeight, msoFalse, msoScaleFromTopLeft
                            End If
                            If IsNumeric(rngFind.Offset(0, 17).Value) Then
                                dblWidth = (rngFind.Offset(0, 17).Value)
                                Selection.ShapeRange.ScaleWidth dblWidth, msoFalse, msoScaleFromTopLeft
                            End If
                             
                            
                Else 'Cell object is selected
                        Selection.Value = strLine(1)
                        If rngFind.Offset(0, 6).Value = "Bold" Then
                            Selection.Font.Bold = True
                           ElseIf rngFind.Offset(0, 6).Value = "Italic" Then
                            Selection.Font.Italic = True
                           ElseIf rngFind.Offset(0, 6).Value = "Bold Italic" Then
                            Selection.Font.Italic = True
                            Selection.Font.Bold = True
                           ElseIf rngFind.Offset(0, 6).Value = "Regular" Then
                            Selection.Font.Italic = False
                            Selection.Font.Bold = False
                         End If
                         
                        Selection.Font.Name = rngFind.Offset(0, 7).Value
                        Selection.Font.Size = rngFind.Offset(0, 8).Value
                        Selection.Font.ColorIndex = rngFind.Offset(0, 9).Value
                        Selection.WrapText = rngFind.Offset(0, 10).Value
                        
                        If rngFind.Offset(0, 14).Value <> -4142 Then
                            Selection.Interior.ColorIndex = rngFind.Offset(0, 14).Value
                        End If
                        
                        If rngFind.Offset(0, 15).Value = 1 Then
                            Selection.EntireColumn.AutoFit
                        End If
                       
            End If
            'alignment is common
            If rngFind.Offset(0, 11).Value = "Centre" Then
                 Selection.HorizontalAlignment = xlCenter
                ElseIf rngFind.Offset(0, 11).Value = "Left" Then
                 Selection.HorizontalAlignment = xlLeft
                ElseIf rngFind.Offset(0, 11).Value = "Right" Then
                 Selection.HorizontalAlignment = xlRight
             End If
      
            '''Applies when there is more than one text box
    ElseIf rngFind.Offset(0, 13) = 1 Then
               For i = 1 To 5
                    Selection.Cells(i, 1).Value = strLine(i)
                    If rngFind.Offset(0, 6).Value = "Bold" Then
                            Selection.Cells(i, 1).Font.Bold = True
                           ElseIf rngFind.Offset(0, 6).Value = "Italic" Then
                            Selection.Cells(i, 1).Font.Italic = True
                           ElseIf rngFind.Offset(0, 6).Value = "BoldItalic" Then
                            Selection.Cells(i, 1).Font.Italic = True
                            Selection.Cells(i, 1).Font.Bold = True
                           ElseIf rngFind.Offset(0, 6).Value = "Regular" Then
                            Selection.Cells(i, 1).Font.Italic = False
                            Selection.Cells(i, 1).Font.Bold = False
                         End If
        
                    Selection.Cells(i, 1).Font.Name = rngFind.Offset(0, 7).Value
                    Selection.Cells(i, 1).Font.Size = rngFind.Offset(0, 8).Value
                    Selection.Cells(i, 1).Font.ColorIndex = rngFind.Offset(0, 9).Value
                    Selection.Cells(i, 1).WrapText = rngFind.Offset(0, 10).Value
                    If rngFind.Offset(0, 11).Value = "Centre" Then
                        Selection.Cells(i, 1).HorizontalAlignment = xlCenter
                       ElseIf rngFind.Offset(0, 11).Value = "Right" Then
                        Selection.Cells(i, 1).HorizontalAlignment = xlRight
                       ElseIf rngFind.Offset(0, 11).Value = "Left" Then
                        Selection.Cells(i, 1).HorizontalAlignment = xlLeft
                    End If
                    If rngFind.Offset(0, 14).Value <> -4142 Then
                        Selection.Cells(i, 1).Interior.ColorIndex = rngFind.Offset(0, 14).Value
                    End If
                Next i
                If rngFind.Offset(0, 15).Value = 1 Then
                    Selection.EntireColumn.AutoFit
                End If
    End If
End With
 
   Exit Sub
errorHandler:
   MsgBox Err.Description, vbExclamation
End Sub

Private Sub UserForm_Initialize()
Dim rng As Range, Cell As Range
   
On Error GoTo errorHandler
    '' If there is no data in the first record then use alternate range
    '' this will prevent the Column headers from appearing in the list box
    With ThisWorkbook.Sheets("SC")
            If .Range("A2").Value <> "" Then
                Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
              Else
                Set rng = .Range(.Range("A2"), .Range("A2").End(xlDown))
            End If
    End With
    
    For Each Cell In rng
        If Cell.Value = "" Then
            MsgBox " Null Values, Check Entries", vbExclamation
            Exit For
        End If
        Me.lstText.additem Cell.Value
    Next Cell
    '' If List is empty then don't bother sorting list
    If Me.lstText.ListCount = 0 Then Exit Sub
Call SortList

Exit Sub
errorHandler:
   MsgBox Err.Description, vbExclamation
End Sub

Private Sub SortList()
' Sort listbox

    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
    On Error GoTo errorHandler
    'Store the list in an array for sorting
    LbList = Me.lstText.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If LbList(i, 0) > LbList(j, 0) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstText.Clear
    
    'Repopulate with the sorted list
    Me.lstText.List = LbList

Exit Sub
errorHandler:
   MsgBox Err.Description, vbExclamation
   
End Sub
Attribute VB_Name = "frmLists"
Attribute VB_Base = "0{E27FFE99-E8C4-494E-A98D-5FA39FA9AE39}{19CDEB57-82FC-41C2-A4D0-252BA8170969}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim strTemp As String
Private Sub cmdDelete_Click()
Dim strList As String
Dim rng As Range, Cell As Range
Dim irow() As Long, i As Long
Dim blnAuto As Boolean
On Error GoTo errorHandler

blnAuto = False ''initialize
If Application.Calculation = xlCalculationAutomatic Then
    blnAuto = True
    Application.Calculation = xlCalculationManual
End If

strList = Me.txtList.Value
 With ThisWorkbook.Sheets("Items")
        Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
    End With
    ''Get the row numbers
    For Each Cell In rng
        If Cell.Value = strList Then
            i = i + 1
            ReDim Preserve irow(i)
            irow(i) = Cell.Row
        End If
    Next Cell
    
    ''Remove the rows
    For i = UBound(irow) To 1 Step -1
        rng.Rows(irow(i) - 1).EntireRow.Delete
    Next i
        
       
    With Me.lstLists
        .Clear
        .additem "(Save New List...)"
        .additem "(View Stored Lists...)"
    End With
    
        ''Clear Lists
        Me.lstComponents.Clear
       
        Call removeEmptyRows
        
       ThisWorkbook.Save
       MsgBox "Add-in Updated..."
       
    If blnAuto = True Then
       Application.Calculation = xlCalculationAutomatic
    End If
    

       
 Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdLoad_Click()
Dim i As Long
        
        '' clear array
        For i = 0 To iList - 1
            sList(i) = ""
        Next i
        
        iList = Me.lstComponents.ListCount

    With Me.lstComponents
        For i = 0 To iList - 1
            ReDim Preserve sList(i)
                sList(i) = .List(i)
        Next i
    End With
    
    Unload Me
    frmFilter.Show 0
End Sub
Private Sub lstLists_Change()
Dim i As Long
Dim strSelection As String

On Error GoTo errorHandler

With Me.lstLists
    For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                If .List(i) = "(View Stored Lists...)" Then
                    strSelection = ""
                 Else
                    strSelection = .List(i)
                  Exit For
                End If
            End If
    Next i
End With
    If strSelection <> "(Save New List...)" Then
        Me.txtList.Value = strSelection
    End If
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub lstLists_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
Dim rng As Range, Cell As Range
Dim i As Long, j As Long
Dim irow As Long
Dim blnExists As Boolean
Dim blnAuto As Boolean
On Error GoTo errorHandler

blnAuto = False ''initialize
If Application.Calculation = xlCalculationAutomatic Then
    blnAuto = True
    Application.Calculation = xlCalculationManual
End If

    With ThisWorkbook.Sheets("Items")
        Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
    End With
   
With Me.lstLists
    For i = 0 To .ListCount - 1
        If .Selected(i) = True Then
            If .List(i) = "(View Stored Lists...)" Then
                ' Refresh List
                  strTemp = ""
                With Me.lstLists
                    .Clear
                    .additem "(Save New List...)"
                    .additem "(View Stored Lists...)"
                End With
                For Each Cell In rng
                    If Cell.Value <> strTemp Then
                         For j = 0 To Me.lstLists.ListCount - 1
                            If Cell.Value = .List(j) Then
                                GoTo newCell
                            End If
                         Next j
                          .additem Cell.Value
                      End If
                    strTemp = Cell.Value
                Next Cell
newCell:
              Exit For
            ElseIf .List(i) = "(Save New List...)" Then
                blnExists = False
                If Me.txtList.Value = "" Then
                    '' exist sub if no name entry for list
                    MsgBox "Please enter a 'Name' for this list...", vbExclamation
                    Me.txtList.SetFocus
                    Exit Sub
                     '' Check if name already exists
                   ElseIf Me.txtList.Value <> "" Then
                    For Each Cell In rng
                        If Cell.Value = Me.txtList.Value Then
                            blnExists = True
                            Exit For
                        End If
                    Next Cell
                    If blnExists = True Then
                        MsgBox "This name already listed, Please enter a new name", vbExclamation
                        Me.txtList.SetFocus
                        Exit Sub
                        '' Get the last row and append the new list
                       Else
                            '' find last cell and append
                            irow = rng.SpecialCells(xlCellTypeLastCell).Row + 1
                                For j = 0 To Me.lstComponents.ListCount - 1
                                    With ThisWorkbook.Sheets("Items")
                                        If Me.lstComponents.List(j) <> "" Then
                                            .Cells(irow + j, 1).Value = Me.txtList.Value
                                            .Cells(irow + j, 2).Value = Me.lstComponents.List(j)
                                        End If
                                    End With
                                Next j
                        ThisWorkbook.Save
                        MsgBox "Add-in Saved"
                    End If
                End If
                
            ElseIf .List(i) <> "(View Stored Lists...)" Or .List(i) <> "(Save New List...)" Then
                strTemp = .List(i)
                    With Me.lstComponents
                        .Clear
                        For Each Cell In rng
                            If Cell.Value = Me.txtList.Value Then
                                .additem Cell.Offset(0, 1).Value
                            End If
                        Next Cell
                    End With
                    Me.txtList.Value = .List(i)
            End If
        End If
    Next i
End With

If blnAuto = True Then
    Application.Calculation = xlCalculationAutomatic
End If


Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub UserForm_Initialize()
Dim i As Long
    With Me.lstLists
        .additem "(Save New List...)"
        .additem "(View Stored Lists...)"
    End With
    
    With Me.lstComponents
        For i = 0 To iList - 1
        .additem sList(i)
        Next i
    End With
End Sub

Private Sub removeEmptyRows()
''' Delete empty rows on a worksheet
Dim lastRow As Long, r As Long
Dim response As Integer
On Error GoTo errorHandler
        
    With ThisWorkbook.Sheets("Items")
        
        lastRow = .UsedRange.Rows.Count
        lastRow = lastRow + .UsedRange.Row - 1
        
            For r = lastRow To 1 Step -1
                If WorksheetFunction.CountA(.Rows(r)) = 0 Then .Rows(r).Delete
            Next r
            
    End With
    
    
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub
Attribute VB_Name = "frmMColumn"
Attribute VB_Base = "0{A90702A6-DC28-4507-8320-01B149E44437}{6B4CFE21-F8BB-4897-97C5-8BE59E38DAC2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim blnOverwrite As Boolean
Dim iMove As Single
Dim blnFormat As Boolean
Dim blnBup As Boolean
Dim blnRefresh As Boolean
Dim blnSaveFile As Boolean
' ---------------------------------------------------------------------------------------------------------
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1

Private Sub btnOverwrite_Click()
     If Me.btnOverwrite = -1 Then
        MsgBox "Warning: Overwrite is turned on. Data will be replaced" _
        & vbCrLf & "There is no undo.", vbExclamation _
        , "Backup before continuing..."
        Me.btnOverwrite.Caption = "Data Overwrite is On"
        Me.btnOverwrite.ForeColor = RGB(255, 0, 0)
        Me.btnOverwrite.Font.Bold = True
        blnOverwrite = True
       ElseIf Me.btnOverwrite = 0 Then
        MsgBox "Overwrite turned off"
        Me.btnOverwrite.Caption = "Data Overwrite ls Off"
        Me.btnOverwrite.ForeColor = RGB(0, 0, 0)
        Me.btnOverwrite.Font.Bold = False
        blnOverwrite = False
     End If
End Sub

Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------
Private Sub CmdClose_Click()
    Me.Hide
End Sub

Private Sub btnBackup_Click()
With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B5").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B5").Value = 1
        End If
        ThisWorkbook.Save
  End With
End Sub



Private Sub cmdOK_Click()
    Dim rngRet_Col As Range '' Return sheet - common values column
    Dim rngRet_Row As Range '' Return sheet -  Header Row
    Dim rngSrch_Col As Range '' Search sheet - common values column
    Dim rngSrch_Row As Range '' Search sheet -  Header Row
    Dim rCell As Range
    Dim Cell As Range, rngFind As Range
    Dim strBook_1 As String, strSht_1 As String
    Dim strBook_2 As String, StrSht_2 As String
    Dim sCol_1R As String, sCol_1S As String ' Columns on the sheets of
    Dim iRow_2R As Long, iRow_2S As Long ' List R will get values
    Dim strRtn() As String   ' Common values in the return sheet
    Dim strSrch() As String  ' Values to to search for in range rngSrch_Col
    Dim strvalue() As String
    Dim iColRtn() As Long, iColSrch() As Long
    Dim i As Long, j As Long, iColRtnCommon As Long, icolSrchCommon As Long
    Dim lRows_wb1 As Long, lRows_wb2 As Long, lRows As Long
    Dim strItem As String
    Dim iCells As Long, iProg As Long
    Dim blnSel As Boolean, blnItem As Boolean
    Dim sFile As String
    Dim iResponse As Integer, iResp As Integer
    Dim lcol_wb1 As Long, lcol_wb2 As Long
    Dim blnOverwrite As Boolean
  
On Error GoTo errorHandler

  Application.ScreenUpdating = False
  Application.StatusBar = ""
    
  'Overwrite
    blnOverwrite = False
    If Me.btnOverwrite.Value = -1 Then blnOverwrite = True
        
  
 'Retrieve the WorkBook Names selected
    strBook_1 = Me.cboShtReturn.Value
    strBook_1 = Right(strBook_1, Len(strBook_1) - InStr(1, strBook_1, ">", vbTextCompare))
    strBook_2 = Me.cboShtFound.Value
    strBook_2 = Right(strBook_2, Len(strBook_2) - InStr(1, strBook_2, ">", vbTextCompare))
 'Retrieve the sheet names selected
    strSht_1 = Me.cboShtReturn.Value
    strSht_1 = Mid(strSht_1, 2, InStr(1, strSht_1, ">", vbTextCompare) - 2)
    StrSht_2 = Me.cboShtFound.Value
    StrSht_2 = Mid(StrSht_2, 2, InStr(1, StrSht_2, ">", vbTextCompare) - 2)

 
    '' Auto-Backup
            blnBup = False
           If Me.btnBackup = -1 Then
                blnBup = True
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run lookup?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B5").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If
    
   ' Assign Column Values to variables
      sCol_1R = Me.cboRet_1.Value
      sCol_1S = Me.cboVal_1.Value
      
      ''Assign row numbers
      iRow_2R = Me.cboRet_2.Value
      iRow_2S = Me.cboVal_2.Value
      
    
    '' Get the min number of workbook rows
        lRows_wb1 = Workbooks(strBook_1).Sheets(1).Rows.Count
        lRows_wb2 = Workbooks(strBook_2).Sheets(1).Rows.Count
        lcol_wb1 = Workbooks(strBook_1).Sheets(1).Columns.Count
        lcol_wb2 = Workbooks(strBook_2).Sheets(1).Columns.Count
        
        '' Get the total number of columns in the workbook
        Dim rngC1 As Range, rngC2 As Range
        Dim sCol_wb1 As String, sCol_wb2 As String
        
        Set rngC1 = Cells(1, lcol_wb1)
        Set rngC2 = Cells(1, lcol_wb2)
        '' Determine sheet column size and get last column from the range address
        If lcol_wb1 < 703 Then
            sCol_wb1 = Mid(rngC1.Address, 2, 2)
           ElseIf lcol_wb1 >= 703 Then
             sCol_wb1 = Mid(rngC1.Address, 2, 2)
        End If
        If lcol_wb2 < 703 Then
            sCol_wb2 = Mid(rngC1.Address, 2, 3)
           ElseIf lcol_wb2 >= 703 Then
             sCol_wb2 = Mid(rngC1.Address, 2, 3)
        End If
        
        'Get then minimun number of rows in the workbooks
        If lRows_wb1 <= lRows_wb2 Then
            lRows = lRows_wb1
           Else
            lRows = lRows_wb2
        End If
        

   '' Using the workbook/Sheet Names, Define the column ranges
   '' Determine the column offset to maintain consistent range sizes
   '' then establish the 2nd range
   
   With Workbooks(strBook_1).Sheets(strSht_1)
        Set rngRet_Col = .Range(.Range(sCol_1R & iRow_2R), .Range(sCol_1R & lRows).End(xlUp))
        Set rngRet_Row = .Range(.Range(sCol_1R & iRow_2R), .Range(sCol_wb1 & iRow_2R).End(xlToLeft))
   End With

   With Workbooks(strBook_2).Sheets(StrSht_2)
        Set rngSrch_Col = .Range(.Range(sCol_1S & iRow_2S), .Range(sCol_1S & lRows).End(xlUp))
        Set rngSrch_Row = .Range(.Range(sCol_1S & iRow_2S), .Range(sCol_wb2 & iRow_2S).End(xlToLeft))
   End With
   
    '' find column where common values are found on return sheet before
    '' establishing return offset column number
     iColRtnCommon = rngRet_Col.Column
  ''Add each header name on the return sheet as well as the column number

    i = 0
    For Each Cell In rngRet_Row
        If Cell.Value <> "" Then
            ReDim Preserve strRtn(i)
            ReDim Preserve iColRtn(i)
            strRtn(i) = Cell.Value
            iColRtn(i) = Cell.Column - rngRet_Col.Column '' to obtain offset value
            i = i + 1
         End If
         
        
    Next Cell
    icolSrchCommon = rngSrch_Col.Column
   ''Add each header name on the search sheet as well as the column number
   i = 0
    For Each Cell In rngSrch_Row
        If Cell.Value <> "" Then
            ReDim Preserve strSrch(i)
            ReDim Preserve iColSrch(i)
           
                strSrch(i) = Cell.Value
                iColSrch(i) = Cell.Column - icolSrchCommon '' -1 to obtain offset value
                i = i + 1

        End If
    Next Cell
    
    
    

      iCells = rngRet_Col.Cells.Count  '' use for status
    '' Find Multiple Matching Values in rngSrch_Col
        j = 0
        For Each Cell In rngRet_Col
            iProg = iProg + 1
                strItem = Cell.Value
                     
                        With rngSrch_Col
                            Set rngFind = .Find(strItem, LookIn:=xlValues, lookat:=xlWhole)
                            blnItem = False
                                If Not rngFind Is Nothing Then
                                    For i = 1 To UBound(strSrch)
                                      ReDim Preserve strvalue(i)
                                       strvalue(i) = rngFind.Offset(0, iColSrch(i)).Value
                                       blnItem = True
                                     Next i
                                  End If
                            End With
                       
                        ''only output items if item exists
                        If blnItem = True Then
                            For i = 1 To UBound(strSrch)
                                For j = 1 To UBound(strRtn)
                                    
                                    If UCase(strSrch(i)) = UCase(strRtn(j)) Then
                                        If Cell.Row <> rngRet_Row.Row Then
                                            If blnOverwrite = True Then
                                                Cell.Offset(0, iColRtn(j)).Value = "'" & strvalue(i)
                                               ElseIf blnOverwrite = False Then
                                                 If Cell.Offset(0, iColRtn(j)).Value = "" Then
                                                   Cell.Offset(0, iColRtn(j)).Value = "'" & strvalue(i)
                                                 End If
                                            End If
                                        End If
                                    End If
                                Next j
                            Next i
                        End If
                Application.StatusBar = "Processing Cells:  " & j & " of " & rngSrch_Col.Rows.Count _
                    & "  " & Format((j / rngSrch_Col.Rows.Count), "0%") & " Complete..."
        Next Cell
        

   ''' Reset Screen updating and status bar
    Application.StatusBar = ""
    Application.ScreenUpdating = True
  Exit Sub
errorHandler:
  ''' Reset Screen updating and status bar
    Application.StatusBar = ""
    Application.ScreenUpdating = True
   If Err.Number = 5 Or Err.Number = 9 Then
        MsgBox "Invalid Option, Please check your selection criteria...", vbExclamation
    Else
        MsgBox "Error Number: " & Err.Number & vbCrLf & _
        Err.Description, vbCritical, "MultiLookup-Form"
    End If
End Sub



Private Sub cmdRefresh_Click()
'' Re-initialize controls on form
Me.cboShtFound.Clear
Me.cboShtReturn.Clear
blnRefresh = True
UserForm_Initialize

End Sub
Private Sub UserForm_Initialize()
Dim i As Long
Dim j As Long
Dim intWbks As Long  ' number of workbooks
Dim strWbName() As String  ' WorkBook Names
Dim ws As Worksheet

On Error GoTo errorHandler
    
    'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If


    cboShtReturn.Clear
    cboShtFound.Clear
    Me.cboRet_1.Clear
 If blnRefresh = False Then
    Me.cboRet_2.Clear
    Me.cboVal_1.Clear
    Me.cboVal_1.Clear
  End If
    '' Determine the number of open workbooks
    intWbks = Application.Workbooks.Count
            
    '' Dimension array to hold the workbook names
   ReDim strWbName(intWbks)
        
    '' Populate sheet / workbook address combos
    For i = 1 To intWbks
        strWbName(i) = Application.Workbooks(i).Name
            With Workbooks(strWbName(i))
                    For j = 1 To .Sheets.Count
                        Me.cboShtReturn.additem "<" & .Sheets(j).Name & ">" & .Name
                        Me.cboShtFound.additem "<" & .Sheets(j).Name & ">" & .Name
                   Next j
            End With
                    
    Next i
    
         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + i)
        Me.cboVal_1.additem Chr$(64 + i)
    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + j) & Chr$(64 + i)
        Me.cboVal_1.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
     Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
   For i = 259 To 256 Step -1
        Me.cboRet_1.RemoveItem (i)
        Me.cboVal_1.RemoveItem (i)
    Next i
    
    For i = 1 To 5000
        Me.cboRet_2.additem (i)
        Me.cboVal_2.additem (i)
    Next i
    blnRefresh = False
    
    ' Defaults
      blnSaveFile = False
      If ThisWorkbook.Sheets("BupFlag").Range("B5").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B5").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical
    
End Sub

Private Sub UserForm_Terminate()
    Me.Hide
    Application.StatusBar = ""
End Sub
Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then
                    ActiveWorkbook.SaveCopyAs .SelectedItems(1)
                    blnBup = True
                    Me.btnBackup.Value = 0
                    Me.btnBackup.Caption = "Backup saved"
                   Else
                    blnBup = False
                End If
            End If
   End With

Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub
Attribute VB_Name = "frmMLookup"
Attribute VB_Base = "0{885C1B64-0C18-4784-9EDC-4FF26074C7F9}{6E57B54D-B770-47E9-B962-44A8FEF2FBF8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim blnOverwrite As Boolean
Dim iMove As Single
Dim blnFormat As Boolean
Dim blnBup As Boolean
Dim blnSaveFile As Boolean
' ---------------------------------------------------------------------------------------------------------
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1
Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------
Private Sub CmdClose_Click()
    Me.Hide
End Sub


Private Sub btnBackup_Click()
   With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B4").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B4").Value = 1
        End If
        ThisWorkbook.Save
  End With
    
End Sub

Private Sub btnFormat_Click()
    With Me.btnFormat
        If .Value = -1 Then
                .Caption = "Copy format on"
                .ForeColor = RGB(255, 0, 0)
                 blnFormat = True
            Else
                .Caption = "Copy format off"
                .ForeColor = RGB(0, 0, 255)
                 blnFormat = False
        End If
    End With
End Sub

Private Sub btnOverwrite_Click()

    If Me.btnOverwrite = -1 Then
        MsgBox "Warning: Overwrite is turned on. Data will be replaced" _
        & vbCrLf & "There is no undo.", vbExclamation _
        , "Backup before continuing..."
        Me.btnOverwrite.Caption = "Data Overwrite is On"
        Me.btnOverwrite.ForeColor = RGB(255, 0, 0)
        Me.btnOverwrite.Font.Bold = True
        blnOverwrite = True
       ElseIf Me.btnOverwrite = 0 Then
        MsgBox "Overwrite turned off"
        Me.btnOverwrite.Caption = "Data Overwrite ls Off"
        Me.btnOverwrite.ForeColor = RGB(0, 0, 0)
        Me.btnOverwrite.Font.Bold = False
        blnOverwrite = False
     End If
End Sub



Private Sub cmdOK_Click()
    Dim rngRet_1 As Range
    Dim rngRet_2 As Range
    Dim rngVal_1 As Range
    Dim rngVal_2 As Range, rCell As Range
    Dim Cell As Range, rngFind As Range
    Dim strBook_1 As String, strSht_1 As String
    Dim strBook_2 As String, StrSht_2 As String
    Dim sCol_1R As String, sCol_1V As String ' Columns on the sheets of
    Dim sCol_2R As String, sCol_2V As String ' List R will get values
    Dim intColR As Long, intColV As Long ' From list V
    Dim intRet As Long  ' Determine the row numbers or items to search for
    Dim strRet() As String  ' Values to to search for in range rngVal_1
    Dim strvalue() As String
    Dim i As Long, j As Long, lHeader As Long, lRows As Long
    Dim lRows_wb1 As Long, lRows_wb2 As Long
    Dim sRet As String, sFile As String
    Dim iColor() As Long ' Font Colour
    Dim blnMany As Boolean
    Dim iIntCol() As Long ' Cell interior colour
    Dim blnBold() As Boolean  ' Cell font bold
    Dim response As Integer, iResp As Integer
    Dim blnNotEmpty As Boolean
  
  On Error GoTo errorHandler
  Application.ScreenUpdating = False
  
 'Retrieve the WorkBook Names selected
    strBook_1 = Me.cboShtReturn.Value
    strBook_1 = Right(strBook_1, Len(strBook_1) - InStr(1, strBook_1, ">", vbTextCompare))
    strBook_2 = Me.cboShtFound.Value
    strBook_2 = Right(strBook_2, Len(strBook_2) - InStr(1, strBook_2, ">", vbTextCompare))
 'Retrieve the sheet names selected
    strSht_1 = Me.cboShtReturn.Value
    strSht_1 = Mid(strSht_1, 2, InStr(1, strSht_1, ">", vbTextCompare) - 2)
    StrSht_2 = Me.cboShtFound.Value
    StrSht_2 = Mid(StrSht_2, 2, InStr(1, StrSht_2, ">", vbTextCompare) - 2)

   ' Assign Column Values to variables
      sCol_1R = Me.cboRet_1.Value
      sCol_1V = Me.cboVal_1.Value
      sCol_2R = Me.cboRet_2.Value
      sCol_2V = Me.cboVal_2.Value
      
    ' Get the Header row then offset by 1 on return values so header is not replaced
        lHeader = Me.cboRet_3.Value + 1
    
    '' Get the min number of workbook rows
        lRows_wb1 = Workbooks(strBook_1).Sheets(1).Rows.Count
        lRows_wb2 = Workbooks(strBook_2).Sheets(1).Rows.Count
        If lRows_wb1 <= lRows_wb2 Then
            lRows = lRows_wb1
           Else
            lRows = lRows_wb2
        End If
        
      ''determine type of lookup
      If Me.btnMany.Value = -1 Then
        blnMany = True
       Else
        blnMany = False
    End If
    
    '' Auto-Backup
            blnBup = False
           If Me.btnBackup = -1 Then
                blnBup = True
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run lookup?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B4").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If

    
    
    
   '' Using the workbook/Sheet Names, Define the column ranges
   '' Determine the column offset to maintain consistent range sizes
   '' then establish the 2nd range
   
   With Workbooks(strBook_1).Sheets(strSht_1)
        Set rngRet_1 = .Range(.Range(sCol_1R & lHeader), .Range(sCol_1R & lRows).End(xlUp))
        intColR = .Columns(sCol_2R).Column - .Columns(sCol_1R).Column ' convert Column Alpha to a Column number
        Set rngRet_2 = rngRet_1.Offset(0, intColR)                    ' Then subtract the difference to get an offset value
   End With
 
    '' check that data will not be overridden
     blnNotEmpty = False
     
    For Each Cell In rngRet_2
       If Cell.Value <> "" Then blnNotEmpty = True
       If InStr(1, Trim(Cell.Value), ",") > 0 Then
            MsgBox "Warning... Comma separators found in <" & strBook_1 & "><" & strSht_1 & ">Column:" & "'" & sCol_2R & "'" _
            & vbCrLf & "Choose a another return column for the data...", vbExclamation
            Exit Sub
        End If
        
    Next Cell
    
    If blnOverwrite = False And blnNotEmpty = True Then
        MsgBox "Warning... Data may be over-written in <" & strBook_1 & "><" & strSht_1 & ">Column: " & "'" & sCol_2R & "'" _
        & vbCrLf & "To replace data, turn overwrite on, there is no undo...", vbExclamation
        Exit Sub
    End If
    
        
        
   With Workbooks(strBook_2).Sheets(StrSht_2)
        Set rngVal_1 = .Range(.Range(sCol_1V & 2), .Range(sCol_1V & 65536).End(xlUp))
        intColV = .Columns(sCol_2V).Column - .Columns(sCol_1V).Column
        Set rngVal_2 = rngVal_1.Offset(0, intColV)
   End With
   
  
   
   ''' store the Values from List R into an array, Then search for those values
   ''' in List V and return them to List R
    
    
        i = 0
        For Each Cell In rngRet_1
           If Cell.Value <> "" Then
               i = i + 1
                ReDim Preserve strRet(i)
                strRet(i) = Cell.Value
                intRet = i
           End If
        Next Cell
            
    '' Find Multiple Matching Values in rngVal_1
        j = 0
        For Each Cell In rngVal_1
            For i = 1 To intRet
                If Trim(LCase(Cell.Value)) = Trim(LCase(strRet(i))) Then
                    ReDim Preserve strvalue(i)
                    ReDim Preserve iColor(i)
                    ReDim Preserve iIntCol(i)
                    ReDim Preserve blnBold(i)
                    strvalue(i) = Cell.Offset(0, intColV).Value
                    iColor(i) = Cell.Offset(0, intColV).Font.ColorIndex
                    iIntCol(i) = Cell.Offset(0, intColV).Interior.ColorIndex
                        If Cell.Offset(0, intColV).Font.Bold = True Then
                            blnBold(i) = True
                           Else
                            blnBold(i) = False
                        End If
                            If blnMany = False Then
                                With rngRet_1
                                    Set rngFind = .Find(strRet(i), LookIn:=xlValues, lookat:=xlWhole)
                                        If Not rngFind Is Nothing Then
                                            If rngFind.Offset(0, intColR).Value = "" Or (Not InStr(1, Trim(rngFind.Offset(0, intColR).Value), ",") > 0 And _
                                               rngFind.Offset(0, intColR).Value <> strvalue(i)) Then
                                                rngFind.Offset(0, intColR).Value = "," & strvalue(i)
                                                If blnFormat = True Then
                                                    rngFind.Offset(0, intColR).Font.ColorIndex = iColor(i)
                                                    rngFind.Offset(0, intColR).Interior.ColorIndex = iIntCol(i)
                                                    rngFind.Offset(0, intColR).Font.Bold = blnBold(i)
                                                    'rngfind.Offset(0, intColR).WrapText = True
                                                End If
                                                rngFind.Offset(0, intColR).HorizontalAlignment = xlLeft
                                            ElseIf Not InStr(1, Trim(rngFind.Offset(0, intColR).Value), Trim(strvalue(i))) > 0 Then
                                                rngFind.Offset(0, intColR).Value = rngFind.Offset(0, intColR).Value & "," & strvalue(i)
                                                'rngFind.Offset(0, intColR).WrapText = True
                                                rngFind.Offset(0, intColR).HorizontalAlignment = xlLeft
                                                
                                                'Keep original data and do not replace original data
                                                '(if below statment is included as an 'or' option above with intColR=0 it will replace the initial value)
''                                            ElseIf Not InStr(1, Trim(rngFind.Offset(0, intColR).Value), ",") > 0 And _
''                                                rngFind.Offset(0, intColR).Value <> strValue(i) Then
''                                                rngFind.Offset(0, intColR).Value = rngFind.Offset(0, intColR).Value & "," & strValue(i)
''                                                'rngFind.Offset(0, intColR).WrapText = True
''                                                rngFind.Offset(0, intColR).HorizontalAlignment = xlLeft
                                           
                                           End If
                                        End If
                                End With
                            ElseIf blnMany = True Then
                                For Each rCell In rngRet_1
                                    If strRet(i) = rCell.Value Then
                                            If rCell.Offset(0, intColR).Value = "" Or _
                                                (Not InStr(1, Trim(rCell.Offset(0, intColR).Value), ",") > 0 _
                                                And rCell.Offset(0, intColR).Value <> strvalue(i)) Then
                                                    rCell.Offset(0, intColR).Value = "," & strvalue(i)
                                                    If blnFormat = True Then
                                                        rCell.Offset(0, intColR).Font.ColorIndex = iColor(i)
                                                        rCell.Offset(0, intColR).Interior.ColorIndex = iIntCol(i)
                                                        rCell.Offset(0, intColR).Font.Bold = blnBold(i)
                                                        'rCell..Offset(0, intColR).WrapText = True
                                                    End If
                                                rCell.Offset(0, intColR).HorizontalAlignment = xlLeft
                                            ElseIf Not InStr(1, Trim(rCell.Offset(0, intColR).Value), Trim(strvalue(i))) > 0 Then
                                                rCell.Offset(0, intColR).Value = rCell.Offset(0, intColR).Value & "," & strvalue(i)
                                                'rngFind.Offset(0, intColR).WrapText = True
                                                rCell.Offset(0, intColR).HorizontalAlignment = xlLeft
                                                
                                                'Keep original data and do not replace original data
                                                '(if below statment is included as an 'or' option above with intColR=0 it will replace the initial value)
''                                            ElseIf Not InStr(1, Trim(rCell.Offset(0, intColR).Value), ",") > 0 _
''                                                And rCell.Offset(0, intColR).Value <> strValue(i) Then
''                                                rCell.Offset(0, intColR).Value = rCell.Offset(0, intColR).Value & "," & strValue(i)
''                                                'rngFind.Offset(0, intColR).WrapText = True
''                                                rCell.Offset(0, intColR).HorizontalAlignment = xlLeft
                                           End If
                                        End If
                                Next rCell
                            End If
                End If
                    
            Next i
                j = j + 1
                Application.StatusBar = "Processing Cells:  " & j & " of " & rngVal_1.Rows.Count _
                    & "  " & Format((j / rngVal_1.Rows.Count), "0%") & " Complete..."
        Next Cell
        
        '' Remove last comma from return values
        On Error Resume Next
            For Each Cell In rngRet_2
                Cell.NumberFormat = "@" ' Convert values to text
                sRet = CStr(Cell.Value)
                If Left(sRet, 1) = "," Then
                    Cell.Value = Trim((Right(sRet, Len(sRet) - 1)))
                End If
            Next Cell
        On Error GoTo 0
   ''' Reset Screen updating and status bar
    Application.StatusBar = ""
    Application.ScreenUpdating = True
    
    'release arrays from memory
    Erase strvalue
    Erase iColor
    Erase iIntCol
    Erase blnBold
    Erase strRet
  Exit Sub
errorHandler:
  ''' Reset Screen updating and status bar
    Application.StatusBar = ""
    Application.ScreenUpdating = True
    MsgBox Err.Description, vbCritical, "MultiLookup-Form"
  
   
End Sub

Private Sub UserForm_Initialize()
Dim i As Integer
Dim j As Integer
Dim intWbks As Integer  ' number of workbooks
Dim strWbName() As String  ' WorkBook Names
Dim ws As Worksheet

On Error GoTo errorHandler

    blnSaveFile = False
    'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If


    cboShtReturn.Clear
    cboShtFound.Clear
    Me.cboRet_1.Clear
    Me.cboRet_2.Clear
    Me.cboVal_1.Clear
    Me.cboVal_1.Clear
    Me.cboRet_3.Clear

    '' Determine the number of open workbooks
    intWbks = Application.Workbooks.Count
            
    '' Dimension array to hold the workbook names
   ReDim strWbName(intWbks)
        
    '' Populate sheet / workbook address combos
    For i = 1 To intWbks
        strWbName(i) = Application.Workbooks(i).Name
            With Workbooks(strWbName(i))
                    For j = 1 To .Sheets.Count
                        Me.cboShtReturn.additem "<" & .Sheets(j).Name & ">" & .Name
                        Me.cboShtFound.additem "<" & .Sheets(j).Name & ">" & .Name
                   Next j
            End With
                    
    Next i
    
                 
    
         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + i)
        Me.cboRet_2.additem Chr$(64 + i)
        Me.cboVal_1.additem Chr$(64 + i)
        Me.cboVal_2.additem Chr$(64 + i)
    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + j) & Chr$(64 + i)
        Me.cboRet_2.additem Chr$(64 + j) & Chr$(64 + i)
        Me.cboVal_1.additem Chr$(64 + j) & Chr$(64 + i)
        Me.cboVal_2.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
     Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
   For i = 259 To 256 Step -1
        Me.cboRet_1.RemoveItem (i)
        Me.cboRet_2.RemoveItem (i)
        Me.cboVal_1.RemoveItem (i)
        Me.cboVal_2.RemoveItem (i)
    Next i
    '' Populate row header combo
        For i = 1 To 999
        Me.cboRet_3.additem (i)
    Next i
    
    '' Defaults
    Me.cboRet_3.Value = 1
    Me.btnMany.Value = 1
    If ThisWorkbook.Sheets("BupFlag").Range("B4").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B4").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical
    
End Sub

Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then
                    ActiveWorkbook.SaveCopyAs .SelectedItems(1)
                    blnBup = True
                    Me.btnBackup.Value = 0
                    Me.btnBackup.Caption = "Backup saved"
                   Else
                    blnBup = False
                End If
            End If
   End With

Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub


Attribute VB_Name = "frmNLists"
Attribute VB_Base = "0{C6F8E1F2-BEA0-4946-BD6B-80C4C0607E7E}{2DE2C803-2A58-4030-BDAB-361BCE9CAF79}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim strTemp As String
Private Sub cmdDelete_Click()
Dim strList As String
Dim rng As Range, Cell As Range
Dim irow() As Long, i As Long
Dim blnAuto As Boolean

On Error GoTo errorHandler
blnAuto = False ''initialize
If Application.Calculation = xlCalculationAutomatic Then
    blnAuto = True
    Application.Calculation = xlCalculationManual
End If

strList = Me.txtList.Value
 With ThisWorkbook.Sheets("HdrList")
        Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
    End With
    ''Get the row numbers
    For Each Cell In rng
        If Cell.Value = strList Then
            i = i + 1
            ReDim Preserve irow(i)
            irow(i) = Cell.Row
        End If
    Next Cell
    
    ''Remove the rows
    For i = UBound(irow) To 1 Step -1
        rng.Rows(irow(i) - 1).EntireRow.Delete
    Next i
        
       
    With Me.lstLists
        .Clear
        .additem "(Save New List...)"
        .additem "(View Stored Lists...)"
    End With
    
        ''Clear Lists
        Me.lstComponents.Clear
       
        Call removeEmptyRows
        
       ThisWorkbook.Save
       MsgBox "Add-in Updated..."
       
        If blnAuto = True Then
            Application.Calculation = xlCalculationAutomatic
        End If
 Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdLoad_Click()
Dim i As Long
        
        '' clear array
        For i = 0 To iHList - 1
            sHList(i) = ""
        Next i
        
        iHList = Me.lstComponents.ListCount

    With Me.lstComponents
        For i = 0 To iHList - 1
            ReDim Preserve sHList(i)
                sHList(i) = .List(i)
        Next i
    End With
    
    Unload Me
    frmNavigator.Show 0
End Sub

Private Sub cmdPaste_Click()
Dim Sh As Worksheet
Dim i As Long
Dim strname As String

On Error GoTo errorHandler
Set Sh = Worksheets.Add

    With Sh
        strname = .Name
    End With

    Sheets(strname).Activate
    With Me.lstComponents
        For i = 0 To .ListCount - 1
            Cells(i + 1, 1).NumberFormat = "@"
            Cells(i + 1, 1).Value = .List(i)
        Next i
    End With
    
Exit Sub
errorHandler:
    MsgBox Err.Description

End Sub


Private Sub lstLists_Change()
Dim i As Long
Dim strSelection As String

On Error GoTo errorHandler

With Me.lstLists
    For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                If .List(i) = "(View Stored Lists...)" Then
                    strSelection = ""
                 Else
                    strSelection = .List(i)
                  Exit For
                End If
            End If
    Next i
End With
    If strSelection <> "(Save New List...)" Then
        Me.txtList.Value = strSelection
    End If
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub lstLists_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
Dim rng As Range, Cell As Range
Dim i As Long, j As Long
Dim irow As Long
Dim blnExists As Boolean
Dim blnAuto As Boolean

On Error GoTo errorHandler
blnAuto = False ''initialize
If Application.Calculation = xlCalculationAutomatic Then
    blnAuto = True
    Application.Calculation = xlCalculationManual
End If

    With ThisWorkbook.Sheets("HdrList")
        Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
    End With
   
With Me.lstLists
    For i = 0 To .ListCount - 1
        If .Selected(i) = True Then
            If .List(i) = "(View Stored Lists...)" Then
                ' Refresh List
                  strTemp = ""
                With Me.lstLists
                    .Clear
                    .additem "(Save New List...)"
                    .additem "(View Stored Lists...)"
                End With
                For Each Cell In rng
                    If Cell.Value <> strTemp Then
                         For j = 0 To Me.lstLists.ListCount - 1
                            If Cell.Value = .List(j) Then
                                GoTo newCell
                            End If
                         Next j
                          .additem Cell.Value
                      End If
                    strTemp = Cell.Value
                Next Cell
newCell:
              Exit For
            ElseIf .List(i) = "(Save New List...)" Then
                blnExists = False
                If Me.txtList.Value = "" Then
                    '' exist sub if no name entry for list
                    MsgBox "Please enter a 'Name' for this list...", vbExclamation
                    Me.txtList.SetFocus
                    Exit Sub
                     '' Check if name already exists
                   ElseIf Me.txtList.Value <> "" Then
                    For Each Cell In rng
                        If Cell.Value = Me.txtList.Value Then
                            blnExists = True
                            Exit For
                        End If
                    Next Cell
                    If blnExists = True Then
                        MsgBox "This name already listed, Please enter a new name", vbExclamation
                        Me.txtList.SetFocus
                        Exit Sub
                        '' Get the last row and append the new list
                       Else
                            '' find last cell and append
                            irow = rng.SpecialCells(xlCellTypeLastCell).Row + 1
                                For j = 0 To Me.lstComponents.ListCount - 1
                                    With ThisWorkbook.Sheets("HdrList")
                                        If Me.lstComponents.List(j) <> "" Then
                                            .Cells(irow + j, 1).Value = Me.txtList.Value
                                            .Cells(irow + j, 2).Value = Me.lstComponents.List(j)
                                        End If
                                    End With
                                Next j
                        ThisWorkbook.Save
                        MsgBox "Add-in Saved"
                    End If
                End If
                
            ElseIf .List(i) <> "(View Stored Lists...)" Or .List(i) <> "(Save New List...)" Then
                strTemp = .List(i)
                    With Me.lstComponents
                        .Clear
                        For Each Cell In rng
                            If Cell.Value = Me.txtList.Value Then
                                .additem Cell.Offset(0, 1).Value
                            End If
                        Next Cell
                    End With
                    Me.txtList.Value = .List(i)
            End If
        End If
    Next i
End With

If blnAuto = True Then
    Application.Calculation = xlCalculationAutomatic
End If

Exit Sub
errorHandler:
    MsgBox Err.Description

End Sub

Private Sub UserForm_Initialize()
Dim i As Long
    With Me.lstLists
        .additem "(Save New List...)"
        .additem "(View Stored Lists...)"
    End With
    
    With Me.lstComponents
        For i = 0 To iHList - 1
        .additem sHList(i)
        Next i
    End With
End Sub

Private Sub removeEmptyRows()
''' Delete empty rows on a worksheet
Dim lastRow As Long, r As Long
Dim response As Integer
On Error GoTo errorHandler
        
    With ThisWorkbook.Sheets("HdrList")
        
        lastRow = .UsedRange.Rows.Count
        lastRow = lastRow + .UsedRange.Row - 1
        
            For r = lastRow To 1 Step -1
                If WorksheetFunction.CountA(.Rows(r)) = 0 Then .Rows(r).Delete
            Next r
            
    End With
    
    
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub
Attribute VB_Name = "frmNavigator"
Attribute VB_Base = "0{9D9F53A8-30C0-4B0E-B8C6-B8DC54D049B3}{BB60E4AE-A405-497B-90F4-A6C0E4E96C38}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'' Navigator V1.01 Freeware version 28/9/13
'' Version 1.02 29/9/13 fixed save stored list prevent auto calculation  on save
'' Latest version 2.0
Option Explicit
Dim iMove As Single
Dim clsGuide As New c_Sheet
Dim blnOn As Boolean
Dim lngGuideRow As Long

Private Sub btnFreeze_Click()
On Error GoTo errorHandler
Application.ScreenUpdating = False

   With Me.btnFreeze
        If .Value = -1 Then
            .Caption = "Unfreeze"

             ActiveWindow.FreezePanes = True
            Else
             .Caption = "Freeze"
             ActiveWindow.FreezePanes = False
         End If
    End With
Exit Sub
Application.ScreenUpdating = True

errorHandler:
    MsgBox Err.Description
End Sub

Private Sub btnGuide_Click()

    ''instantiate guide
    Set clsGuide.SheetApp = Application
    
    If Me.btnGuide.Value = -1 Then
            Me.btnGuide.Caption = " Turn Guide Off"
            Me.lblOn.BackColor = RGB(255, 0, 0)
            Me.btnStatic.Value = 0
            blnGuide = True ''turns guide on
            blnOn = True  '' Indicates guide is on
       ElseIf Me.btnGuide.Value = 0 Then
            Me.btnGuide.Caption = " Turn Guide On"
            Me.lblOn.BackColor = RGB(0, 255, 0)
            Me.btnStatic.Value = 0
            blnGuide = False ''turns guide off
            blnOn = False ' Indicates guide is off
            Set clsGuide = Nothing
            Call clearGuide
    End If
       
End Sub
Private Sub clearGuide()
    blnGuide = False
    
            On Error Resume Next
                ActiveSheet.Shapes("TopLine").Delete
                ActiveSheet.Shapes("BtmLine").Delete
            On Error GoTo 0
End Sub

Private Sub btnHide_Click()
Dim rngItems As Range, Cell As Range
Dim rngFind As Range
Dim lRow As Long, lCol As Long, i As Long
Dim lColumn() As Long, n As Long
Dim j As Long, k As Long
Dim strItem As String, iItems As Long
Dim blnHide As Boolean, blnSkip As Boolean



On Error GoTo errorHandler
  Application.ScreenUpdating = False
    '' Determine and set caption for Hide/Unhide
    With Me.btnHide
        If .Value = -1 Then
            .Caption = "Unhide"
            blnHide = True
         ElseIf .Value = 0 Then
            .Caption = "Hide"
            blnHide = False
          End If
    End With
    
    ''Ensure Header row has been selected
    If Me.cboRet_1 = "" Then
        MsgBox "Please select  header row", vbInformation
        Me.cboRet_1.SetFocus
        Exit Sub
    End If
    
    '' Check for items in Listbox
    If Me.lstItems.ListCount = 0 Then
        MsgBox "There are no column headers in list" _
        & vbCrLf & "Please select Headers to display", vbInformation
        Exit Sub
    End If
    '' obtain scope of range
    lRow = Me.cboRet_1.Value
    lCol = ActiveSheet.Columns.Count
    

    '' set the header range
    With ActiveSheet
        Set rngItems = .Range(.Cells(lRow, 1), .Cells(lRow, lCol))
    End With
    
    ''Check if items are in Header row
        blnSkip = False
        For Each Cell In rngItems
          With Me.lstItems
            For i = 0 To .ListCount - 1
                If UCase(Cell.Value) = .List(i) Then
                    blnSkip = True
                    Exit For
                   Else
                    iItems = iItems + 1
                End If
             Next i
            End With
        Next Cell
        
        If iItems > 1 And blnSkip = False Then
            MsgBox "Selected items not found in Header row...", vbInformation
            Exit Sub
        End If
    
   ''Reset or unhide all columns and get hall header names and the column
        For i = 1 To lCol
            If Columns(i).Hidden = True Then Columns(i).Hidden = False
        Next i

  If blnHide = True Then
            For i = 1 To lCol
            If Columns(i).Hidden = True Then Columns(i).Hidden = False
              k = 0
              strItem = Cells(lRow, i).Value
              For j = 0 To Me.lstItems.ListCount - 1
                If Me.lstItems.List(j) <> UCase(strItem) Then
                    k = k + 1
                End If
               Next j
                If strItem <> "" And k = Me.lstItems.ListCount Then
                    n = n + 1
                    ReDim Preserve lColumn(n)
                    lColumn(n) = Columns(i).Column
                End If
            Next i

    '' Unhide/Unhide all columns
                For n = 1 To UBound(lColumn)
                    Columns(lColumn(n)).Hidden = True
                Next n
     End If
                
  
   Application.ScreenUpdating = True
 Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub btnStatic_Click()
On Error GoTo errorHandler
    Set clsGuide.SheetApp = Application
    Dim blnStatic As Boolean
    '' Set static mode to scroll and maintain guide
    If Me.btnStatic.Value = -1 And blnOn = True Then
        blnStatic = True
        Me.btnStatic.Caption = "Static Guide"
       ElseIf Me.btnStatic.Value = 0 And blnOn = True Then
        Me.btnStatic.Caption = "Dynamic Guide"
        blnStatic = False
       Else
        Exit Sub
    End If
    
    If blnStatic = True Then
        blnGuide = False ''turns guide off without clearing
        Set clsGuide = Nothing
       ElseIf blnStatic = False Then
        blnGuide = True ''turns guide back on
     End If
     
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cboRet_2_Change()
    iGTop = Me.cboRet_2.Value
End Sub

Private Sub cboRet_3_Change()
    iGBtm = Me.cboRet_3.Value
End Sub

Private Sub cmdAdd_Click()

Dim clsRef As c_Ref
Dim strRange As String
Dim RngIn As Range
Dim rng As Range, Cell As Range
Dim blnSelection As Boolean
Dim i As Long
Dim iCol As Long
Dim lRow As Long, lLast As Long
Dim collItem As New Collection
Dim item As Variant
Dim blnExists As Boolean

On Error GoTo errorHandler
    
    Application.ScreenUpdating = False

    '' SET SEARCH RANGE
        
        If Application.Selection.Cells.Count = 1 Then
            Set rng = Selection
           Else
            Set rng = Application.Selection.SpecialCells(xlCellTypeVisible)
        End If
        
    ''' Determine if whole sheetis selected if so exit procedure
        
            If Selection.Columns.Count >= 256 And Right(ActiveWorkbook.Name, 3) = "xls" Then
                MsgBox "you may have selected the whole column", vbInformation
                Exit Sub
               ElseIf Selection.Columns.Count >= 16384 And Application.Version <= 14 Then
                MsgBox "you may have selected the whole sheet, cancelling operation...", vbInformation
            End If
        blnSelection = False
    
       
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        i = 0
         For Each Cell In rng
              If Not IsEmpty(Cell) Then i = i + 1
              If i > 0 Then
                blnSelection = True
                Exit For
              End If
         Next Cell
         
        ''' provide message if no selection is made:
                If blnSelection = False Then
                    MsgBox "No data selected...", vbExclamation
                    Unload Me
                    Exit Sub
                End If
        '' add selection to collection
        On Error Resume Next
            For Each Cell In rng
               If Cell.Value <> "" Then
                  collItem.Add Cell.Value, CStr(Cell.Value)
               End If
            Next Cell
        On Error GoTo 0
        
        
        '' populate List
        With Me.lstItems
           '' Check if item is already listed
           '' If not then add to list
            For Each item In collItem
                blnExists = False
                For i = 0 To .ListCount - 1
                  If item = .List(i) Then
                    blnExists = True
                    Exit For
                  End If
                Next i
                
               If blnExists = False Then
                    .additem UCase(item)
               End If
            Next item
        End With
        
        
  
  Exit Sub
errorHandler:
  MsgBox Err.Description
End Sub

Private Sub cmdClear_Click()
    Me.lstItems.Clear
End Sub
Private Sub cmdDrop_Click()
Dim i As Long
On Error GoTo errorHandler

    '' Remove items
        With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
            End If
        Next i
        End With
        
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub

Private Sub cmdSort_Click()
' Sort listbox
    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    
    On Error GoTo errorHandler
    'Store the list in an array for sorting
    LbList = Me.lstItems.List
    
    'Bubble sort the array on the first value
    For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
        For j = i + 1 To UBound(LbList)
            If LbList(i, 0) > LbList(j, 0) Then
                'Swap the first value
                sTemp = LbList(i, 0)
                LbList(i, 0) = LbList(j, 0)
                LbList(j, 0) = sTemp
               sTemp = ""
               
            End If
        Next j
    Next i
'Remove the contents of the listbox
    Me.lstItems.Clear
    
    'Repopulate with the sorted list
    Me.lstItems.List = LbList
    
Exit Sub
errorHandler:
    MsgBox Err.Description
End Sub


Private Sub lblLink_Click()
    Dim str As String
    str = "http://www.mightymacros.tools"
    ThisWorkbook.FollowHyperlink (str)
End Sub



Private Sub lstItems_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim lngColumn As Long
    Dim rngFind As Range, rngItems As Range
    Dim lRow As Long, lCol As Long, i As Long
    Dim strItem As String
    
   On Error GoTo errorHandler
    If Me.cboRet_1 = "" Then
        MsgBox "Please select  header row", vbInformation
        Me.cboRet_1.SetFocus
        Exit Sub
    End If
    ''Get the row position before moving
    lngGuideRow = ActiveCell.Row
    
    lRow = Me.cboRet_1.Value
    lCol = ActiveSheet.Columns.Count
    
    With ActiveSheet
        Set rngItems = .Range(.Cells(lRow, 1), .Cells(lRow, lCol))
    End With
    
    With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                strItem = .List(i)
                With rngItems
                    Set rngFind = .Find(strItem, LookIn:=xlValues, lookat:=xlWhole)
                    If Not rngFind Is Nothing Then
                        lngColumn = rngFind.Column
                    End If
                End With
                Exit For
            End If
        Next i
    End With
        'Application.GoTo Reference:=ActiveSheet.Cells(lngGuideRow, lngColumn), _
       ' Scroll:=True
       
        Cells(lngGuideRow, lngColumn).Select
Exit Sub
errorHandler:
    If Err.Number = 1004 Then
        MsgBox "Item not found in selected row"
       Else
        MsgBox Err.Description
    End If
End Sub

Private Sub cboColour_Change()
Dim rng As Range
On Error Resume Next
Set rng = ThisWorkbook.Sheets(1).Range("A65536")

        '' convert colorindex to label background
         rng.Interior.ColorIndex = Me.cboColour.Value
         Me.lblColour.BackStyle = fmBackStyleOpaque
         Me.lblColour.BackColor = rng.Interior.Color
         iGColor = rng.Interior.ColorIndex + 7

End Sub

Private Sub UserForm_Activate()
    If ActiveWindow.FreezePanes = True Then
        Me.btnFreeze.Caption = "Unfreeze"
        Me.btnFreeze = 1
    End If
End Sub

Private Sub UserForm_Initialize()
'' populate column combos
Dim i As Long
Dim j As Long

On Error GoTo errorHandler
    '' Clear combos
    Me.cboRet_1.Clear
    Me.cboColour.Clear
    Me.cboRet_2.Clear
    Me.cboRet_3.Clear
    
   
         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 5000
        Me.cboRet_1.additem (i)
    Next i
    
    '' Load Stored List
        
        For i = 0 To iHList - 1
            If sHList(i) <> "" Then
                Me.lstItems.additem sHList(i)
            End If
        Next i
        
        For i = 1 To 5
            Me.cboRet_2.additem (i)
            Me.cboRet_3.additem (i)
        Next i
        
        For i = 1 To 56
            Me.cboColour.additem (i)
        Next i
            ''set default
            Me.cboColour.Value = "3"
            Me.cboRet_2.Value = 1
            Me.cboRet_3.Value = 2
            Me.cboRet_1.Value = 1
        
  Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical
End Sub
Private Sub cmdManage_Click()
Dim i As Long

   With Me.lstItems
    iHList = .ListCount
    For i = 0 To iHList - 1
    ReDim Preserve sHList(i)
        sHList(i) = .List(i)
    Next i
   End With
    Unload Me
    frmNLists.Show 0
End Sub



Private Sub UserForm_Terminate()
    On Error Resume Next
        blnGuide = False ''turns guide off
        blnOn = False ' Indicates guide is off
        Set clsGuide = Nothing
        Call clearGuide
    On Error GoTo 0
End Sub
Attribute VB_Name = "frmNewEditCells"
Attribute VB_Base = "0{83A683BD-69AF-439C-B4DA-0640EF599848}{9A967630-92EB-418F-9AFE-BED24CDC37E2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Option Base 1
Dim strCellValues() As Variant
Dim rngCell As Range
Dim blnSaved As Boolean
Dim blnSaveFile As Boolean
'======================================================================================
'This form is designed to manipulate strings and numbers
'It provides the ability to delete and insert characters within a selected range
'It also provides the ability to rearrange numbers and strings
'and can be used to convert numbers into dates being formated
'as either strings or dates
'Form was produced by Peter Tscherne on 12/09/2007
'Updated 27.10.13 with new functions
'Revised 19.05.14
'======================================================================================
Private Sub CmdClose_Click()
    Unload Me
End Sub

Private Sub cmdDate_Click()
'Convert string date value to medium date format
Dim Cell As Range
Dim strDate As String

    For Each Cell In Selection
       strDate = Format(Cell.Value, "medium date")
       Cell.Value = strDate
    Next Cell
End Sub

Private Sub btn_Move_Click()
With Me.btn_Move
    If .Value = -1 Then
        .Caption = "Move to Left"
       Else
        .Caption = "Move to Right"
    End If
 End With
End Sub

Private Sub btnApp_Click()
    With Me.btnApp
    If .Value = -1 Then
        .Caption = "Append to Front"
       Else
        .Caption = "Append at End"
    End If
 End With
End Sub


Private Sub btnBackup_Click()
    With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B3").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B3").Value = 1
        End If
        ThisWorkbook.Save
  End With
End Sub

Private Sub btnD_From_Click()
With Me.btnD_From
    If .Value = -1 Then
        .Caption = "Delete String on Left"
       Else
        .Caption = "Delete String to Right"
    End If
 End With
End Sub

Private Sub btnDchar_Click()

With Me.btnDchar
    If .Value = -1 Then
        .Caption = "From End"
       Else
        .Caption = "From Front"
    End If
End With
        
End Sub

Private Sub btnEX_Click()
    With Me.btnEX
    If .Value = -1 Then
        .Caption = "Delete Find Text"
       Else
        .Caption = "Keep Find Text"
    End If
 End With
End Sub

Private Sub btnInsertMethod_Click()
    With Me.btnInsertMethod
        If .Value = -1 Then
            .Caption = "Find text and Insert:"
             Me.cboStartInsert.BackStyle = fmBackStyleTransparent
             Me.cboStartInsert.Enabled = False
             Me.txtI_Find.BackStyle = fmBackStyleOpaque
             Me.txtI_Find.Enabled = True
             Me.txtI_Find.SetFocus
             Me.btnInsertType.Enabled = True
            Else
             .Caption = "Insert after position:"
             Me.cboStartInsert.BackStyle = fmBackStyleOpaque
             Me.cboStartInsert.Enabled = True
             Me.cboStartInsert.SetFocus
             Me.txtI_Find.BackStyle = fmBackStyleTransparent
             Me.txtI_Find.Enabled = False
             Me.btnInsertType.Enabled = False
        End If
    End With
End Sub

Private Sub btnInsertType_Click()
     With Me.btnInsertType
    If .Value = -1 Then
        .Caption = "Insert before cell text:"
       Else
        .Caption = "Insert after cell text:"
    End If
    Me.txtI_Find.SetFocus
 End With
End Sub

Private Sub cmdOK_Click()
    Dim Cell As Range
    Dim intStMove As Long, intCharMove As Long
    Dim intDel As Long, iStDel As Long
    Dim strDel As String
    Dim intStInsert As Long, intLength As String
    Dim strInsert As String, strNewString As String
    Dim strLeft As String, strRight As String, strSection As String
    Dim strInsFind As String
    Dim intcells As Long, iLth As Long
    Dim iMove As Long, iResp As Long
    Dim sFile As String
    Dim sReverse As String, strAppend As String

    
    'Establish the array size based on number of cells selected
    'then redim the array strCellValues
    'the array will store original values for the purpose
    'of providing the ability to undo a single change
    'strCellValues & rngCell to be passed onto cmdUndo_Click procedure
    
  On Error GoTo errorHandler
   '' Check undos
    iClicks = iClicks + 1
    
    If iClicks > 1 Then
        iResp = MsgBox("Undo will be cleared, Do you want to continue...", vbYesNo + vbExclamation)
            If iResp = vbNo Then Exit Sub
    End If
     
    '' Auto-Backup
        
           If Me.btnBackup = -1 Then
              
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B3").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If

    
    Set rngCell = Application.Selection
    
    If rngCell.Cells.Count > 1 Then
        Set rngCell = rngCell.SpecialCells(xlCellTypeVisible)
    End If
     ''Re-size array based on selection
     intcells = rngCell.Cells.Count
     ReDim strCellValues(intcells)
    
    
    ''' Assign variables to textbox values
    ''' Prevent break on error when values are null
On Error Resume Next
        ''Move variables
        If Me.fm_Move.Enabled = False Then GoTo Next_Insert
        intStMove = Me.cboStartMove.Value '' Position for left
        iMove = Me.cboNoMove.Value '' Number of places to move
        intCharMove = Me.cboCharMove.Value '' Number of Characters to Move
        ''Insert variable
Next_Insert:
    With Me.fm_Insert
        If .Enabled = False Then GoTo Next_Delete
            With .Controls("cboStartInsert")
                If .Enabled = True Then
                    intStInsert = .Value
                End If
            End With
        iLth = Len(.Controls("txtI_Find"))
        strInsFind = .Controls("txtI_Find").Value
        strInsert = .Controls("txtValuesInsert").Value
    End With
        '' Delete variables
Next_Delete:
    With Me.fm_Delete
        With .Controls("cboDelPosition")
            If .Enabled = True Then intDel = .Value
        End With
        
        With .Controls("txtD_Find")
            If .Enabled = True Then
                iLth = Len(Me.txtD_Find)
                strDel = .Value
            End If
        End With
    End With
   On Error GoTo 0
     '' check for empty cells
        For Each Cell In rngCell
            If Cell.Value = "" Then
                MsgBox "All selected cells must contain a value" _
                & vbCrLf & "Null Value in Cell address: " & Cell.Address, vbExclamation, "Aborting operation...."
                Exit Sub
            End If
        Next Cell
    On Error GoTo errorHandler
    ''' Move
        If Me.Opt1.Value = -1 And intStMove <> 0 Then ' move strings/numbers
               intcells = 0
                For Each Cell In rngCell
                    intcells = intcells + 1
                    strCellValues(intcells) = Cell.Value
                    intLength = Len(Cell.Value)
                   '' first get the section or the string to move
                    strSection = Mid(Cell.Value, intStMove, intCharMove) ''replace intNoMove with intCharMove
                   '' Get left and right of new string to form new string
                   '' is String with section removed
                    strRight = Right(Cell.Value, intLength - (intStMove + intCharMove - 1))
                    strLeft = Left(Cell.Value, intStMove - 1)
                    strNewString = strLeft & strRight
                    'MsgBox strNewString
                       If Me.btn_Move = 0 Then '' move to right
                                strRight = Right(strNewString, Len(strNewString) - (intStMove + iMove - 1))
                                strLeft = Left(strNewString, (intStMove + iMove) - 1)
                           ElseIf Me.btn_Move = -1 Then '' move to Left
                                strRight = Right(strNewString, Len(strNewString) - (intStMove - iMove - 1))
                                strLeft = Left(strNewString, (intStMove - iMove) - 1)
                        End If
                      Cell.Value = strLeft & strSection & strRight
                Next Cell
                '' Insert
             ElseIf Me.Opt2.Value = -1 And Me.btnInsertMethod.Value = 0 Then
                intcells = 1
                    For Each Cell In rngCell
                        Selection.NumberFormat = "@" ' insert text value
                        strCellValues(intcells) = Cell.Value
                        intLength = Len(Cell.Value)
                        strRight = Right(Cell.Value, intLength - intStInsert)
                        strLeft = Left(Cell.Value, intLength - Len(strRight))
                        Cell.Value = strLeft & strInsert & strRight
                        intcells = intcells + 1
                    Next Cell
                ElseIf Me.Opt2.Value = -1 And Me.btnInsertMethod.Value = -1 Then
                   '' insert After
                   If Me.btnInsertType.Value = 0 Then
                    intcells = 1
                        For Each Cell In rngCell
                            Selection.NumberFormat = "@" ' insert text value
                            strCellValues(intcells) = Cell.Value
                            intLength = Len(Cell.Value)
                            intStInsert = InStr(1, strCellValues(intcells), strInsFind, vbTextCompare) + iLth
                            strRight = Right(Cell.Value, intLength - intStInsert + 1)
                            strLeft = Left(Cell.Value, intLength - Len(strRight))
                            '' Guard against inserting when item is not found
                            If InStr(1, strCellValues(intcells), strInsFind, vbTextCompare) > 0 Then
                                Cell.Value = strLeft & strInsert & strRight
                            End If
                            intcells = intcells + 1
                        Next Cell
                      ElseIf Me.btnInsertType.Value = -1 Then
                          ''insert before
                          intcells = 1
                        For Each Cell In rngCell
                            Selection.NumberFormat = "@" ' insert text value
                            strCellValues(intcells) = Cell.Value
                            intLength = Len(Cell.Value)
                            intStInsert = InStr(1, strCellValues(intcells), strInsFind, vbTextCompare)
                            strRight = Right(Cell.Value, intLength - intStInsert + 1)
                            strLeft = Left(Cell.Value, intLength - Len(strRight))
                            '' Guard against inserting when item is not found
                            If InStr(1, strCellValues(intcells), strInsFind, vbTextCompare) > 0 Then
                                Cell.Value = strLeft & strInsert & strRight
                            End If
                            intcells = intcells + 1
                        Next Cell
                    End If
                '' Delete Char from Left
                ElseIf Me.Opt3.Value = -1 And Me.btnDchar.Value = 0 Then
                    intcells = 1
                        For Each Cell In rngCell
                        strCellValues(intcells) = Cell.Value  ' delete single character
                        intLength = Len(Cell.Value)
                        sReverse = StrReverse(Cell.Value)
                        strRight = Left(sReverse, intLength - intDel)
                        Cell.NumberFormat = "@"
                        Cell.Value = CStr(StrReverse(strRight))
                        intcells = intcells + 1
                    Next Cell
                '' Delete Char from Right
                ElseIf Me.Opt3.Value = -1 And Me.btnDchar.Value = -1 Then
                    intcells = 1
                        For Each Cell In rngCell
                        strCellValues(intcells) = Cell.Value  ' delete single character
                        intLength = Len(Cell.Value)
                        strLeft = Left(Cell.Value, intLength - intDel)
                        Cell.Value = strLeft
                        intcells = intcells + 1
                    Next Cell
                    '' Delete Other
                ElseIf Me.Opt4.Value = -1 Then
                    intcells = 1
                        For Each Cell In rngCell
                        strCellValues(intcells) = Cell.Value  ' delete single character
                        intLength = Len(Cell.Value)
                        iStDel = InStr(1, strCellValues(intcells), strDel, vbTextCompare)
                        
                        If InStr(1, strCellValues(intcells), strDel, vbTextCompare) > 0 Then
                            '' delete left string
                            If Me.btnD_From.Value = -1 And Me.btnEX.Value = 0 Then
                                    strRight = Right(Cell.Value, intLength - (iStDel - 1))
                                    Cell.Value = Trim(strRight)
                                ElseIf Me.btnD_From.Value = -1 And Me.btnEX.Value = -1 Then
                                    strRight = Right(Cell.Value, intLength - (iStDel + iLth - 1))
                                    Cell.Value = Trim(strRight)
                                 '' delete right string
                                ElseIf Me.btnD_From.Value = 0 And Me.btnEX.Value = 0 Then
                                    strRight = Right(Cell.Value, intLength - iStDel - iLth + 1)
                                    strLeft = Left(Cell.Value, intLength - (Len(strRight)))
                                    Cell.Value = Trim(strLeft)
                                ElseIf Me.btnD_From.Value = 0 And Me.btnEX.Value = -1 Then
                                    strRight = Right(Cell.Value, intLength - iStDel + 1)
                                    strLeft = Left(Cell.Value, intLength - (Len(strRight)))
                                    Cell.Value = Trim(strLeft)
                            End If
                        End If
                        intcells = intcells + 1
                    Next Cell
                    ' Append to left of string
                    ElseIf Me.Opt5.Value = -1 And Me.btnApp = 0 Then
                            intcells = 1
                            strAppend = Me.txtAppend.Value
                                For Each Cell In rngCell
                                strCellValues(intcells) = Cell.Value
                                Cell.Value = Cell.Value & strAppend
                                intcells = intcells + 1
                            Next Cell
                    ' Append to left of string
                    ElseIf Me.Opt5.Value = -1 And Me.btnApp = -1 Then
                            intcells = 1
                            strAppend = Me.txtAppend.Value
                                For Each Cell In rngCell
                                strCellValues(intcells) = Cell.Value
                                Cell.Value = strAppend & Cell.Value
                                intcells = intcells + 1
                            Next Cell

                End If
            
            
Exit Sub
errorHandler:
    If Err.Number = 5 Then
        MsgBox "Invalid selection criteria..." & vbCrLf & "re-check and try again", vbExclamation
      Else
        MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
    End If
End Sub

Private Sub cmdUndo_Click()
Dim i As Long
Dim Cell As Range
On Error GoTo errorHandler

 i = 1
    For Each Cell In rngCell
        If strCellValues(i) <> "" Then
            Cell.Value = strCellValues(i)
           Else
            MsgBox "Undo No longer avalable", vbExclamation
            Exit Sub
         End If
         i = i + 1
    Next Cell
    iClicks = 0
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
End Sub

Private Sub Opt1_Click()
''Move
Dim i As Long
    With Me.fm_Move
     .Enabled = True
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleOpaque
           .Controls(i).Enabled = True
        Next i
        .Controls("cboStartMove").SetFocus
    End With
    
    With Me.fm_Insert
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
          .Controls(i).Enabled = False
        Next i
    End With

    With Me.fm_Delete
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False

        Next i
    End With
    With Me.fm_Append
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    iClicks = 0
End Sub

Private Sub opt2_Click()
''Insert
    Dim i As Long
    With Me.fm_Move
     .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    
    With Me.fm_Insert
        .Enabled = True
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleOpaque
           .Controls(i).Enabled = True
        Next i
        .Controls("cboStartInsert").Enabled = False
        .Controls("cboStartInsert").BackStyle = fmBackStyleTransparent
        .Controls("btnInsertMethod").Value = 1
        .Controls("txtI_Find").SetFocus
        
    End With

    
    With Me.fm_Delete
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    With Me.fm_Append
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    iClicks = 0
End Sub

Private Sub Opt3_Click()
''Delete Char
    Dim i As Long
    With Me.fm_Move
     .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    
    With Me.fm_Insert
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With

    
    With Me.fm_Delete
        .Enabled = True
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
            .Controls("btnDchar").Enabled = True
            .Controls("lblD_CharHd").Enabled = True
            .Controls("cboDelPosition").Enabled = True
            .Controls("cboDelPosition").BackStyle = fmBackStyleOpaque
            .Controls("cboDelPosition").SetFocus
    End With
    With Me.fm_Append
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    iClicks = 0
End Sub

Private Sub Opt4_Click()
'' Delete Other
     Dim i As Long
    With Me.fm_Move
     .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    
    With Me.fm_Insert
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With

    
    With Me.fm_Delete
        .Enabled = True
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleOpaque
           .Controls(i).Enabled = True
        Next i
            .Controls("btnDchar").Enabled = False
            .Controls("lblD_CharHd").Enabled = False
            .Controls("cboDelPosition").Enabled = False
            .Controls("cboDelPosition").BackStyle = fmBackStyleTransparent
            .Controls("txtD_Find").SetFocus
    End With
    
    With Me.fm_Append
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    iClicks = 0
End Sub

Private Sub Opt5_Click()
'' Append
     Dim i As Long
    With Me.fm_Move
     .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With
    
    With Me.fm_Insert
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
    End With

    
    With Me.fm_Delete
        .Enabled = False
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleTransparent
           .Controls(i).Enabled = False
        Next i
            .Controls("btnDchar").Enabled = False
            .Controls("lblD_CharHd").Enabled = False
            .Controls("cboDelPosition").Enabled = False
            .Controls("cboDelPosition").BackStyle = fmBackStyleTransparent
    End With
    
    With Me.fm_Append
        .Enabled = True
        For i = 0 To .Controls.Count - 1
           .Controls(i).BackStyle = fmBackStyleOpaque
           .Controls(i).Enabled = True
        Next i
        .Controls("txtAppend").SetFocus
    End With
    iClicks = 0
End Sub

Private Sub UserForm_Activate()
    Me.Opt1 = 1
    Me.Controls("cboStartMove").SetFocus
End Sub



Private Sub UserForm_Initialize()

On Error GoTo errorHandler
    Dim i As Integer
    '' Populate Move combos
    With Me.cboCharMove
        For i = 1 To 100
            .additem i
        Next i
            .Value = 1
    End With
     With Me.cboNoMove
        For i = 1 To 500
            .additem i
        Next i
        .Value = 1
    End With
    With Me.cboStartMove
        For i = 0 To 500
            .additem i
        Next i
        .Value = 1
    End With
    '' Populate Inset combos
    With Me.cboStartInsert
        For i = 0 To 500
            .additem i
        Next i
        .Value = 0
    End With
    '' Populate Delete combos
    With Me.cboDelPosition
        For i = 1 To 500
            .additem i
        Next i
        .Value = 1
    End With
    
    Me.btnEX.Value = 0
    iClicks = 0
    
    
 ' Defaults
      blnSaveFile = False
      If ThisWorkbook.Sheets("BupFlag").Range("B3").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B3").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
     
     Exit Sub
errorHandler:
     
     MsgBox Err.Description
    
End Sub
Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then ActiveWorkbook.SaveCopyAs .SelectedItems(1)
            End If
   End With
    
        With Me.btnBackup
            blnSaved = True
            .Value = 0
            .Caption = "Backup Saved"
        End With
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub

Attribute VB_Name = "frmPassword"
Attribute VB_Base = "0{674695A0-3D59-4723-AC42-C7B2F9492287}{F529CEA6-03F3-498B-8623-6866565E058B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub cmdDisplay_Click()
Dim strPW As String

strPW = ThisWorkbook.Sheets(1).Range("IV1").Value

MsgBox strPW

End Sub

Private Sub cmdOK_Click()
Dim response As Integer

On Error Resume Next

    If Me.txtPassword.Value <> Me.txtConfirm.Value Then
            MsgBox "Enties dxo not match" & vbCrLf & _
            "Please re-enter", vbExclamation
            Me.txtPassword.Value = ""
            Me.txtConfirm.Value = ""
            Me.txtPassword.SetFocus
       ElseIf Me.txtPassword.Value = Me.txtConfirm.Value _
            And Me.txtPassword <> "" Then
            ThisWorkbook.Sheets(1).Range("IV1").Value = Me.txtPassword.Value
            Unload Me
            ThisWorkbook.Save
            frmHide.Show 0
       ElseIf Me.txtPassword.Value = Me.txtConfirm.Value _
            And Me.txtPassword = "" Then
            response = MsgBox("Password is Blank..." & vbCrLf _
                & "Action may overwrite a stored password", vbOKCancel + vbExclamation)
                    If response = vbOK Then
                        ThisWorkbook.Sheets(1).Range("IV1").Value = Me.txtPassword.Value
                        Unload Me
                        ThisWorkbook.Save
                        frmHide.Show 0
                    End If
    End If
         
    
End Sub

Private Sub UserForm_Activate()
    Me.txtPassword.PasswordChar = "#"
    Me.txtConfirm.PasswordChar = "#"
End Sub


Attribute VB_Name = "frmPasteVisible"
Attribute VB_Base = "0{3450D9F1-AC4A-452A-9A8C-FA8C808CE9A8}{739EF0CC-3850-4A27-BB7D-2F8211437028}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 1
Dim vCellValues() As Variant
Dim rngCell As Range
Dim blnSaved As Boolean
Dim blnCopy As Boolean
Dim rngCopy As Range
Dim r As Long, c As Long
Dim lMax As Long
Dim strFontStyle() As String
Dim lngFontColor() As Long
Dim iFontSize() As Long
Dim lngInterior() As Long
Dim strFontName() As String
Dim strFormula() As String
Dim strFormat() As String
Dim blnTest As Boolean
Dim lngColor() As Long
Dim blnSingle As Boolean

Private Sub btnBackup_Click()
With Me.btnBackup
    If .Value = 0 And blnSaved = False Then
        .Caption = "Backup reminder is off"
        .ForeColor = RGB(255, 0, 0)
        .Font.Bold = True
       Else
         .Caption = "Backup reminder is on"
        .ForeColor = RGB(0, 102, 0)
        .Font.Bold = True
    End If
  End With
End Sub

Private Sub cmdCopy_Click()
Dim Cell As Range
Dim intcells As Long
Dim iResp As Integer
Dim sFile As String
Dim i As Long

On Error GoTo errorHandler

Application.ScreenUpdating = False
    
   If Selection.Rows.Count > 1000 Then
    MsgBox "Too many rows selected..." & vbCrLf & _
            "Try narrowing copy range", vbExclamation
            Exit Sub
  End If

  If Selection.Rows.Count = 1 Then
    blnSingle = True
    MsgBox "Single cell /row selection not allowed...", vbExclamation
        Exit Sub
  End If
  
  Set rngCopy = Application.Selection
  Set rngCopy = rngCopy.SpecialCells(xlCellTypeVisible)
  
  If rngCopy.Cells.Count > 0 Then
    blnCopy = True
   Else
    MsgBox "Please make a selection", vbExclamation
    Exit Sub
   End If
    

  c = rngCopy.Columns.Count
  
  If c > 1 Then
    MsgBox "Macro designed to copy values in single column only", vbExclamation
  Exit Sub
  End If

 
  
    ''Store Values ,Formats,Formulas
   rngCopy.Select
    i = 0
   For Each Cell In rngCopy
       Cell.Select
        i = i + 1
        ReDim Preserve vCellValues(i)
        ReDim Preserve strFontStyle(i)
        ReDim Preserve lngFontColor(i)
        ReDim Preserve iFontSize(i)
        ReDim Preserve lngInterior(i)
        ReDim Preserve lngColor(i)
        ReDim Preserve strFontName(i)
        ReDim Preserve strFormula(i)
        ReDim Preserve strFormat(i)
        vCellValues(i) = Cell.Value
        strFontStyle(i) = Cell.Font.FontStyle
        lngFontColor(i) = Cell.Font.Color
        iFontSize(i) = Cell.Font.Size
        strFontName(i) = Cell.Font.Name
        lngInterior(i) = Cell.Interior.Color
        lngColor(i) = Cell.Interior.ColorIndex
        strFormula(i) = Cell.FormulaR1C1
        strFormat(i) = Cell.NumberFormat
        lMax = i
   Next Cell
   
   rngCopy.Select
   blnSingle = False
Application.ScreenUpdating = True

Exit Sub
errorHandler:
    If Err.Number = 5 Then
        MsgBox "Invalid selection criteria..." & vbCrLf & "re-check and try again", vbExclamation
      Else
        MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
    End If

End Sub

Private Sub cmdPaste_Click()
    Dim rngOut As Range, Cell As Range
    Dim irow As Long, iCol As Long
    Dim sFile As String
    Dim iResp As Integer
    Dim intcells As Long
    Dim ilastRow As Long, ilastCol As Long
    Dim i As Long
    
    
 On Error GoTo errorHandler
   '' Check undos
   
   ''Paste range is defined by intial output cell
   '' need number of output rows and columns from copy range
   '' make sure paste range does not contain data - provide message
   
   If blnTest = False Then
    MsgBox "Test range before proceeding...", vbExclamation
    Exit Sub
    End If
    
    If blnSingle = True Then
    MsgBox "Single cell copy is not supported...", vbExclamation
    Exit Sub
    End If
    '' Auto-Backup
        If Me.btnBackup = -1 Then
            blnSaved = False
            sFile = "Backup_" & ActiveWorkbook.Name
            If InStr(1, sFile, ".", vbTextCompare) = 0 Then
                iResp = MsgBox("Reminder: Save work before continuing...", vbExclamation + vbYesNo)
                    If iResp = vbNo Then
                        iClicks = 0
                        Exit Sub
                       Else
                        iClicks = 0
                        Me.btnBackup.Value = 0
                        Exit Sub
                    End If
               Else
                 iResp = MsgBox("Auto-Backup is enabled...", vbExclamation + vbOKCancel)
                 If iResp = vbCancel Then
                        iClicks = 0
                        Me.btnBackup.Value = 0
                        Exit Sub
                    Else
                        iClicks = 0
                        Call SaveMyCopy(sFile)
                        Exit Sub
                  End If
             End If
        End If

    
    Set rngCell = Application.Selection ' output cell
    Set rngCell = rngCell.SpecialCells(xlCellTypeVisible)
 If Me.btnFormats.Value <> -1 Then
    i = 0
    For Each Cell In rngCell
            If Cell.Value = "" Then
                i = i + 1
                If Me.btnAll = -1 Then
                    Cell.Value = vCellValues(i)
                    If lngColor(i) <> -4142 Then
                        Cell.Interior.Color = lngInterior(i)
                    End If
                    Cell.Font.FontStyle = strFontStyle(i)
                    Cell.Font.Color = lngFontColor(i)
                    Cell.Font.Size = iFontSize(i)
                    Cell.Font.Name = strFontName(i)
                    Cell.NumberFormat = strFormat(i)
                   ElseIf Me.btnValues = -1 Then
                    Cell.Value = vCellValues(i)
                   ElseIf Me.btnFormulas = -1 Then
                    Cell.FormulaR1C1 = strFormula(i)
                End If
            End If
    Next Cell
End If
    If Me.btnFormats = -1 Then
        i = 0
            For Each Cell In rngCell
                i = i + 1
                Cell.Font.FontStyle = strFontStyle(i)
                Cell.Font.Color = lngFontColor(i)
                Cell.Font.Size = iFontSize(i)
                Cell.Font.Name = strFontName(i)
                Cell.NumberFormat = strFormat(i)
                If lngColor(i) <> -4142 Then
                    Cell.Interior.Color = lngInterior(i)
                End If
            Next Cell
    End If
  
    blnTest = False
Exit Sub
errorHandler:
    If Err.Number = 5 Then
        MsgBox "Invalid selection criteria..." & vbCrLf & "re-check and try again", vbExclamation
      Else
        MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
    End If
End Sub

Private Sub cmdUndo_Click()
Dim i As Long
Dim Cell As Range
On Error GoTo errorHandler

 i = 1
    For Each Cell In rngCell
        If vCellValues(i) <> "" Then
            Cell.Value = vCellValues(i)
           Else
            MsgBox "Undo No longer avalable", vbExclamation
            Exit Sub
         End If
         i = i + 1
    Next Cell
    iClicks = 0
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
End Sub

Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then ActiveWorkbook.SaveCopyAs .SelectedItems(1)
            End If
   End With
    
        With Me.btnBackup
            blnSaved = True
            .Value = 0
            .Caption = "Backup Saved"
        End With
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub

Private Sub cmdTest_Click()
Dim r() As Long 'number of visible empty cells
Dim rngDown As Range, Cell As Range
Dim lRow As Long
Dim lCol As Long
Dim i As Long
Dim strStart As String, strEnd As String

On Error GoTo errorHandler
    blnTest = True
    
    If blnSingle = True Then
    MsgBox "Single cell copy is not supported...", vbExclamation
    Exit Sub
    End If
    
    lRow = ActiveCell.Row
    lCol = ActiveCell.Column
    
    With ActiveSheet
        Set rngDown = .Range(.Cells(lRow, lCol), .Cells(65536, lCol).End(xlDown))
        Set rngDown = rngDown.SpecialCells(xlCellTypeVisible)
    End With
    
    If Me.btnFormats.Value <> -1 Then
      i = 0
      For Each Cell In rngDown
        If Cell.Value = "" Then
           i = i + 1
            If i = 1 Then
                strStart = Cell.Address
            End If
            If i = lMax Then
               strEnd = Cell.Address
             Exit For
            End If
        End If
      Next Cell
    ElseIf Me.btnFormats.Value = -1 Then
      i = 0
      For Each Cell In rngDown
           i = i + 1
            If i = 1 Then
                strStart = Cell.Address
            End If
            If i = lMax Then
               strEnd = Cell.Address
             Exit For
            End If
      Next Cell
    End If

      
      
      
      
      
       Range(strStart & ":" & strEnd).Select
      Selection.SpecialCells(xlCellTypeVisible).Select
   Exit Sub
errorHandler:
   MsgBox Err.Description
End Sub



Attribute VB_Name = "frmProtect"
Attribute VB_Base = "0{CF6F4985-5415-447C-9BB5-796FD1C4809F}{B732E85B-21B6-4CDC-B534-08FF8C77CC88}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Dim blnPWOK As Boolean
Private Sub cmdOK_Click()
Dim strPW As String
    strPW = Me.txtPW.Value
    blnPWOK = False
    If strPW <> "silky123" Then
        ThisWorkbook.Close
       Else
        blnPWOK = True
    End If
    Me.Hide
End Sub


Private Sub UserForm_Initialize()
  Application.EnableCancelKey = xlDisabled
End Sub

Private Sub UserForm_Terminate()
    If blnPWOK = False Then ThisWorkbook.Close
End Sub
Attribute VB_Name = "frmProtectSheets"
Attribute VB_Base = "0{1382A11B-E627-4B17-A608-C5622549B004}{1EC590F9-499A-4C46-8479-6527E5A8E6F9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Dim blnsht As Boolean

Private Sub btnProtect_Click()
    ''' Change textbox Background colour
    ''' so that it appears enabled
    Me.txtConfirm.BackStyle = fmBackStyleOpaque
    Me.txtConfirm.Enabled = True
    Me.txtPassword.BackStyle = fmBackStyleOpaque
    Me.txtPassword.Enabled = True
End Sub

Private Sub btnUnprotect_Click()
    ''' Change textbox Background colour on passord
    ''' confirmation to be greyed-out, only password is required
    
    Me.txtPassword.Enabled = True
    Me.txtPassword.BackStyle = fmBackStyleOpaque
    Me.txtConfirm.Enabled = False
    Me.txtConfirm.BackStyle = fmBackStyleTransparent
End Sub

Private Sub CmdClose_Click()
    Unload Me
End Sub

Private Sub cmdHide_Click()
    frmProtectSheets.Hide
    frmHide.Show 0
End Sub

Private Sub cmdOK_Click()
Dim strPassword As String
Dim strConfirm As String
Dim i As Long, j As Long, k As Long
Dim intSheets As Long, intProtected As Long
Dim intUnProtected As Long
Dim intProtect As Long
Dim strname() As String
Dim strMsg As String



On Error GoTo errorHandler
    ''' assign passwords to string variables
    strPassword = Me.txtPassword
    strConfirm = Me.txtConfirm
    
   
        intSheets = Sheets.Count
        ''' Capture the initial number of Protected sheets
        intProtected = 0
        For j = 1 To intSheets
          If Sheets(j).Type = xlWorksheet Then
            If shtProtected(Sheets(j)) Then
                    intProtected = intProtected + 1
            End If
           End If
        Next j
    
    
    
    
    If Me.btnProtect = -1 Then
       Me.btnUnprotect = 0
       
            If strPassword = strConfirm Then
                   
                    With lstunprotectedSheets
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1
                            ''' If individual sheets are selected in listbox
                        
                             If .Selected(i) And i > 0 Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Protect (strPassword)
                                     
                                 ''' If "(All Sheets)" is selected listbox
                                 ElseIf .Selected(i) And i = 0 Then
                                        For k = 1 To intSheets
                                            With ActiveWorkbook
                                                    Sheets(k).Protect (strPassword)
                                            End With
                                        Next k
                             End If
                           
                         Next i
                        End With
    
                 
                ElseIf Me.txtConfirm = "" Then
                    MsgBox "Please Confirm your Password", vbExclamation, "Protect Sheets"
                ElseIf Me.txtConfirm And Me.txtPassword = "" Then
                    MsgBox "Please Enter and Confirm a Password", vbExclamation, "Protect Sheets"
                    
            End If
                        ''' Recapture number of sheets protected
                        For j = 1 To intSheets
                             If Sheets(j).Type = xlWorksheet Then
                                If shtProtected(Sheets(j)) Then
                                        intProtect = intProtect + 1
                                End If
                              End If
                        Next j
                          ''' send message to user that sheets are now protected
                        MsgBox "Sheet(s) Protected: = " & Abs(intProtected - intProtect), vbInformation
                        
                        ''' UnLoad form and reset variables
                        Unload Me
                        frmProtectSheets.Show
                        
                        
    ElseIf Me.btnUnprotect = -1 Then
           Me.btnProtect = 0
        
                    With lstprotectedSheets
                        ReDim strname(.ListCount)
                         For i = 0 To .ListCount - 1 '''List count is 4 but because index starts at 0
                                                     ''' can only go up to 3
                                
                                If .Selected(i) And i > 0 Then ''' Selected (i) determines the item selected
                                     strname(i) = .List(i) ''' List(i) Returns the string name of the sheet
                                     Sheets(strname(i)).Unprotect (strPassword)
                                     
                                 ''' If "(All Sheets)" is selected listbox
                                 ElseIf .Selected(i) And i = 0 Then
                                        For k = 1 To intSheets
                                            With ActiveWorkbook
                                                    Sheets(k).Unprotect (strPassword)
                                            End With
                                        Next k
                             End If
                        Next i
                    End With
                              
                            ''' Recapture number of sheets protected
                            For j = 1 To intSheets
                                If Sheets(j).Type = xlWorksheet Then
                                    If shtProtected(Sheets(j)) Then
                                            intUnProtected = intUnProtected + 1
                                    End If
                                 End If
                            Next j
                ''' send message to user that sheets that were unprotected
                If intProtected - intUnProtected > 0 Then
                    MsgBox "Sheet(s) Unprotected: = " & intProtected - intUnProtected, vbInformation
                 ElseIf intProtected - intUnProtected = 0 And intUnProtected > 0 Then
                    MsgBox "Sheet(s) Unprotected: = " & intProtected - intUnProtected & vbCrLf _
                    & "Your Password is Incorrect", vbExclamation
                End If
                
                ''' UnLoad form and reset variables
                Unload Me
                frmProtectSheets.Show

    
    End If

 Exit Sub
errorHandler:

        MsgBox "Description: " & Err.Description & vbCrLf _
        & "Number: " & Err.Number, vbCritical, "Error"
        Me.btnProtect = 0
        Me.btnUnprotect = 0

End Sub

Private Sub cmdStoredPW_Click()
Dim strPW As String

strPW = ThisWorkbook.Sheets(1).Range("IV1").Value

    If Me.btnProtect = -1 Then
        Me.txtPassword.Value = strPW
        Me.txtConfirm.Value = strPW
       ElseIf Me.btnUnprotect = -1 Then
        Me.txtPassword.Value = strPW
    End If
        
End Sub

Private Sub UserForm_Initialize()
Dim i As Long

On Error GoTo errorHandler

    On Error Resume Next
        Me.lstprotectedSheets.Clear
        Me.lstunprotectedSheets.Clear
    On Error GoTo 0

             ''' Count all sheets in Objwb and add names of sheets to list box
    With Me.lstunprotectedSheets
            .additem "( All Sheets )"
            For i = 1 To Sheets.Count
             If Sheets(i).Type = xlWorksheet Then
                If Not shtProtected(Sheets(i)) Then
                    .additem Sheets(i).Name
                End If
              End If
            Next i
    End With
    
    With Me.lstprotectedSheets
            .additem "( All Sheets )"
            For i = 1 To Sheets.Count
            If Sheets(i).Type = xlWorksheet Then
                If shtProtected(Sheets(i)) Then
                    .additem Sheets(i).Name
                End If
            End If
            Next i
    End With
    Me.txtConfirm.Enabled = False
    Me.txtConfirm.BackStyle = fmBackStyleTransparent
    Me.txtPassword.Enabled = False
    Me.txtPassword.BackStyle = fmBackStyleTransparent

  Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical, "Error Message"
End Sub



Private Function shtProtected(TargetSheet As Worksheet) As Boolean
     'From http://www.vbaexpress.com/kb/getarticle.php?kb_id=239
     'Function purpose:  To evaluate if a worksheet is protected
   
   If TargetSheet.Type = xlWorksheet Then
        If TargetSheet.ProtectContents = True Then
            shtProtected = True
         Else
            shtProtected = False
        End If
    End If
End Function
Attribute VB_Name = "frmRange"
Attribute VB_Base = "0{A101AE0D-EEE9-4BDC-946D-5D68601F3F06}{269AC15F-8471-4A00-9E49-2B85F29A0935}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cmdOK_Click()
Dim RngIn As Range
Dim rng As Range
Dim clsRef As c_Ref
Dim strRange As String

' Create instance of class object
Set clsRef = New c_Ref
    If Me.RefEdit1 = "" Then
        MsgBox "Please Select a Range", vbExclamation
        Me.RefEdit1.SetFocus
        Exit Sub
    End If
    
    strRange = Me.RefEdit1.Value
        
        '' Check for R1C1 reference style in RefEdit range
        '' convert to xlA1 if R1C1 is in use
        If clsRef.blnR1C1(strRange) = True Then
                strRange_Ref = clsRef.RefStyle(strRange)
           Else
                strRange_Ref = strRange
        End If
    
        Set rng = Range(strRange_Ref)
    
    ''' Determine if whole column is selected if so exit procedure
        Set RngIn = Application.Intersect(Range(strRange_Ref), ActiveSheet.Rows(65536))
            If Not RngIn Is Nothing Then
                MsgBox "Do not select the whole column" & vbCrLf _
                & "Select only the data required", vbInformation
                Me.RefEdit1.Value = ""
                Exit Sub
            End If
    
    Unload Me
    
        Select Case intMenuSelection
            Case 1
               Application.Run "LCase_Con"
            Case 2
               Application.Run "Proper_Con"
            Case 3
               Application.Run "Caps_Con"
            Case 4
               Application.Run "CleanData"
            Case 5
               Application.Run "remove_Gaps"
            Case 6
               Application.Run "ShowALLRepeatingValues"
            Case 7
               Application.Run "colourDupes"
            Case 8
               Application.Run "findWeekends"
            Case 9
               Application.Run "findWeekNo"
             Case 10
               Application.Run "checkIfDates"
            Case 11
               Application.Run "convertMonth"
            Case 12
               Application.Run "convertToDate"
            Case 13
                Application.Run "ReformatDate"
            Case 14
                Application.Run "convertAmerican"
            Case 15
                Application.Run "convertDateString"
            Case 16
               Application.Run "removeLinks"
            Case 17
               Application.Run "CreateNewLink"
         
          End Select
End Sub

Private Sub UserForm_Initialize()
    Select Case intMenuSelection
            Case 1
               Me.lblCaption = "Lower Case"
            Case 2
               Me.lblCaption = "Proper Case"
            Case 3
               Me.lblCaption = "Upper Case"
            Case 4
               Me.lblCaption = "Clean Text"
            Case 5
               Me.lblCaption = "Remove spaces"
            Case 6
               Me.lblCaption = "Find repeating values..." _
                                & vbCrLf & "Result cells are colored green."
            Case 7
               Me.lblCaption = "Show Duplicates"
               
            Case 8
               Me.lblCaption = "Weekends will be displayed in red"
            Case 9
               Me.lblCaption = "Replaces date with Week No"
            Case 10
               Me.lblCaption = "Check date format and highlight incorrect values"
            Case 11
               Me.lblCaption = "Convert date to month in text 'mmm-yy' format"
            Case 12
               Me.lblCaption = "Converts text date from format 'mmm-yy' to 01/mm/yyyy'"
            Case 13
               Me.lblCaption = "Reformat 'yyyymmdd' to date format 'dd/mm/yyyy'"
             Case 14
               Me.lblCaption = "Change Date format from 'mm/dd/yy' to 'dd/mm/yy'"
            Case 15
               Me.lblCaption = "Convert string Date 'dd.mm.yy' to date format"
            Case 16
               Me.lblCaption = "Remove Hyperlinks"
            Case 17
               Me.lblCaption = "Create Hyperlinks"
               
          End Select
End Sub
Attribute VB_Name = "frmRemoveSpaces"
Attribute VB_Base = "0{E7F1CB9D-02BC-4736-8EF5-6778EB067501}{E9A8D911-2D98-418D-96F2-5BB615C09069}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim blnBup As Boolean
Dim strCellValues() As Variant
Dim rngCell As Range
Private Sub btnBackup_Click()
With Me.btnBackup
    If .Value = 0 And blnBup = False Then
        .Caption = "Backup reminder is off"
        .ForeColor = RGB(255, 0, 0)
        .Font.Bold = True
       Else
         .Caption = "Backup reminder is on"
        .ForeColor = RGB(0, 102, 0)
        .Font.Bold = True
    End If
  End With
End Sub

Private Sub cmdRemove_Click()
''' Delete empty rows on a worksheet
Dim Cell As Range
Dim iResp As Integer, intcells As Long
Dim sFile As String

'On Error GoTo errorHandler
        
   '' Check undos
    iClicks = iClicks + 1
    
    If iClicks > 1 Then
        iResp = MsgBox("Undo will be cleared, Do you want to continue...", vbYesNo + vbExclamation)
            If iResp = vbNo Then Exit Sub
    End If
     
    '' Auto-Backup
        If Me.btnBackup = -1 Then
            blnBup = False
            sFile = "Backup_" & ActiveWorkbook.Name
            If InStr(1, sFile, ".", vbTextCompare) = 0 Then
                iResp = MsgBox("Reminder: Save work before continuing...", vbExclamation + vbYesNo)
                    If iResp = vbNo Then
                        iClicks = 0
                        Exit Sub
                       Else
                        iClicks = 0
                        Me.btnBackup.Value = 0
                        Exit Sub
                    End If
               Else
                 iResp = MsgBox("Auto-Backup is enabled...", vbExclamation + vbOKCancel)
                 If iResp = vbCancel Then
                        iClicks = 0
                        Me.btnBackup.Value = 0
                        Exit Sub
                    Else
                        iClicks = 0
                        Call SaveMyCopy(sFile)
                        Exit Sub
                  End If
             End If
        End If

    
    Set rngCell = Application.Selection
    
    If rngCell.Cells.Count > 1 Then
        Set rngCell = rngCell.SpecialCells(xlCellTypeVisible)
    End If
     ''Re-size array based on selection
     intcells = rngCell.Cells.Count
     ReDim strCellValues(intcells)
            intcells = 0
           For Each Cell In rngCell
                intcells = intcells + 1
                strCellValues(intcells) = Cell.Value
                Cell.Replace What:=" ", Replacement:="", lookat:=xlPart
            Next Cell
Exit Sub
errorHandler:
MsgBox Err.Description
End Sub

Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then
                    ActiveWorkbook.SaveCopyAs .SelectedItems(1)
                    blnBup = True
                    Me.btnBackup.Value = 0
                    Me.btnBackup.Caption = "Backup saved"
                   Else
                    blnBup = False
                End If
            End If
   End With

Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub
Private Sub UserForm_Initialize()
    Me.btnBackup.Value = 1
End Sub

Private Sub cmdUndo_Click()
Dim i As Long
Dim Cell As Range
On Error GoTo errorHandler

 i = 1
    For Each Cell In rngCell
        If strCellValues(i) <> "" Then
            Cell.Value = strCellValues(i)
           Else
            MsgBox "Undo No longer avalable", vbExclamation
            Exit Sub
         End If
         i = i + 1
    Next Cell
    iClicks = 0
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "ErrorNumber: " & Err.Number, vbExclamation
End Sub
Attribute VB_Name = "frmRepeats"
Attribute VB_Base = "0{D2642E95-9F50-439B-B118-9767FC6BFD04}{DEB56553-83B4-44C8-AD50-73FFC15CE65C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim strAdd() As String
Dim intFind As Long
Dim SelAddress As String
Private Sub btnFind_Click()
    Static intcells As Long

    If intcells < intFind Then ''' when button count = number of found addresses then stop
     ActiveSheet.Range(strAdd(intFind - intcells)).Activate
     '''' MsgBox intCells
    End If
    If intFind > intcells Then intcells = intcells + 1 ''' initialize static integer variable
       
    Me.btnFind.Caption = "Find Next: " & intcells & " of " & intFind
    
    If intcells >= intFind Then intcells = 0  ''' re-initialize
End Sub

Private Sub cmdinfo_Click()
    MsgBox "To Locate repeating values " & vbCrLf & " Select list item and click the [Find] button.", vbInformation
End Sub

Private Sub lstRepeats_Click()
  Dim strList As Variant
    Dim Cell As Range
    Dim rngSht As Range
    Dim i As Long
     
    On Error GoTo errorHandler
        With ActiveSheet
            Set rngSht = ActiveSheet.Range(SelAddress)
        End With
        
        
        strList = Me.lstRepeats.Value
                
        i = 0
       For Each Cell In rngSht
        If Not IsError(Cell.Value) Then
           If blnCaseRepeats = True Then
                ' Ignore Case
                If UCase(CStr(Cell.Value)) = UCase(strList) Then
                        i = i + 1
                        ReDim Preserve strAdd(i)
                        strAdd(i) = Cell.Address
                        '''Debug.Print strAdd(i)
                End If
               ElseIf blnCaseRepeats = False Then
                If StrComp(strList, Cell.Value, 0) = 0 Then
                        i = i + 1
                        ReDim Preserve strAdd(i)
                        strAdd(i) = Cell.Address
                        'Debug.Print strAdd(i)
                End If
            End If
          End If
        Next Cell
      
      intFind = i
      Me.btnFind.Caption = "Locate: " & intFind & " item(s)"
      
   Exit Sub
errorHandler:
   MsgBox Err.Number & " " & Err.Description
End Sub

Private Sub UserForm_Initialize()
Dim Cell As Range
Dim rng As Range
Dim item As Variant
Dim ThisCollection As Collection
Dim cSel As C_Selection
Dim NewRange As Range

On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    
    

     Set ThisCollection = New Collection
     
     On Error Resume Next
        For Each Cell In NewRange
            If Cell.Interior.ColorIndex = 4 Then
                ThisCollection.Add Cell.Value, CStr(Cell.Value)
            End If
        Next Cell
     On Error GoTo 0
     
    For Each item In ThisCollection
        Me.lstRepeats.additem CStr(item)
    Next item
    
    SelAddress = NewRange.Address
 Exit Sub
errorHandler:
   MsgBox Err.Number & " " & Err.Description
End Sub

Attribute VB_Name = "frmRnd"
Attribute VB_Base = "0{EC354A4C-0CDF-41E2-A7FE-0E45D88A973E}{890775F5-60F3-4053-8B68-AA8A7601F71E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim strRange As String
Dim intRounding As Long

Private Sub btnClear_Click()
    If Me.btnClear.Value = -1 Then intRounding = 4
End Sub

Private Sub btnDown_Click()
   If Me.btnDown.Value = -1 Then intRounding = 2
End Sub

Private Sub btnRnd_Click()
    If Me.btnRnd.Value = -1 Then intRounding = 3
End Sub
Private Sub btnUp_Click()
    If Me.btnUp.Value = -1 Then intRounding = 1
End Sub

Private Sub cmdOK_Click()
Dim rng As Range, Cell As Range
Dim clsRef As c_Ref
Dim intplaces As Long
Dim dblRounding() As Double
Dim i As Long
Dim strvalue As String
Dim intStart As Long, intEnd As Long, intLth As Long
Dim blnRnd As Boolean

On Error GoTo errorHandler:

    Application.ScreenUpdating = False
        
        blnRnd = False
    ' Create instance of class object
        Set clsRef = New c_Ref
        
        '' Check for R1C1 reference style in RefEdit range
        '' convert to xlA1 if R1C1 is in use
         If clsRef.blnR1C1(Me.RefEdit1.Value) = True Then
                strRange = clsRef.RefStyle(Me.RefEdit1.Value)
           Else
                strRange = Me.RefEdit1.Value
        End If
    '' Get Decmal places
        intplaces = Me.cboDec.Value
    '' Determine rounding selection
    '' Perform rounding or remove formula
    
    
          
    If intRounding < 4 Then
            
            Set rng = Range(strRange)
            
        i = 0
        For Each Cell In rng
            If InStr(1, Cell.Formula, "(", vbTextCompare) Then
                MsgBox "Cell contains formula bracket '('... at: " & Cell.Address _
                & vbCrLf & "Try clearing rounding formula if present", vbExclamation
                Exit Sub
            End If
            If Cell.Value <> "" Then
                i = i + 1
                Else: GoTo NextCell
            End If
            ReDim Preserve dblRounding(i)
            dblRounding(i) = Cell.Value
            
                Select Case intRounding
                    Case 1
                        Cell.FormulaR1C1 = "=roundup(" & dblRounding(i) & "," & intplaces & ")"
                    Case 2
                        Cell.FormulaR1C1 = "=rounddown(" & dblRounding(i) & "," & intplaces & ")"
                    Case 3
                        Cell.FormulaR1C1 = "=round(" & dblRounding(i) & "," & intplaces & ")"
                End Select
NextCell:
        Next Cell

            
            
     End If
             
''Clear Rounding Formula
        If intRounding = 4 Then
            
            Set rng = Range(strRange)
                For Each Cell In rng
                    
                    If InStr(1, Cell.Formula, "ROUND", vbTextCompare) Then
                        strvalue = Cell.FormulaR1C1
                        intStart = InStr(1, strvalue, "(", vbTextCompare) + 1
                        intEnd = InStr(intStart, strvalue, ",", vbTextCompare)
                        intLth = intEnd - intStart
                        Cell.Value = Mid(strvalue, intStart, intLth)
                        blnRnd = True
                       ElseIf Cell.Value = "" Then GoTo nextItem
                       ElseIf Cell.Value <> "" Then
                         MsgBox "Selected cell does not contain rounding formula" _
                         & vbCrLf & "Cannot update cell address: " & Cell.Address, vbExclamation
                         Unload Me
                         Exit Sub
                    End If
nextItem:
                Next Cell
        End If
    
    Application.ScreenUpdating = True
    If blnRnd = False Then Unload Me
    
Exit Sub
errorHandler:
         
    If Err.Number = 1004 And intRounding < 4 Then
            MsgBox "Please select data...", vbExclamation
        ElseIf Err.Number = 1004 And intRounding = 4 Then
            MsgBox "Please select data...", vbExclamation
        Else
         MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description
    End If
End Sub

Private Sub UserForm_Initialize()
 Dim i As Long
 Dim rngStore As Range
        
            '' Clear stored values
            On Error Resume Next
            With ThisWorkbook.Sheets("Store")
                    Set rngStore = .Range(.Cells(2, 2), .Cells(65536, 2).End(xlUp))
                    rngStore.Clear
                    .Range("A2").Value = ""
            End With
            On Error GoTo 0
            
    With Me.cboDec
        .Clear
        For i = 0 To 5
            .additem i
        Next i
        .Value = 0
    End With
    Me.btnRnd.Value = 1
End Sub
Attribute VB_Name = "frmRounding"
Attribute VB_Base = "0{F1A42E44-8FE5-49E7-AB06-97796E3B8881}{9207D6F6-B73A-47D8-B3D0-CA2DBFDB01BD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim intRounding As Long
Dim blnSaved As Boolean
Dim blnSaveFile As Boolean

Private Sub btnBackup_Click()
  With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B8").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B8").Value = 1
        End If
        ThisWorkbook.Save
  End With
End Sub

Private Sub btnClear_Click()
    If Me.btnClear.Value = -1 Then intRounding = 4
End Sub

Private Sub btnDown_Click()
   If Me.btnDown.Value = -1 Then intRounding = 2
End Sub

Private Sub btnRnd_Click()
    If Me.btnRnd.Value = -1 Then intRounding = 3
End Sub
Private Sub btnUp_Click()
    If Me.btnUp.Value = -1 Then intRounding = 1
End Sub

Private Sub cmdOK_Click()
Dim rng As Range, Cell As Range
Dim rngStore As Range, sCell As Range
Dim intplaces As Long
Dim dblRounding() As Double
Dim i As Long
Dim strvalue As String
Dim intStart As Long, intEnd As Long, intLth As Long
Dim strAddress() As String, strSheet As String
Dim dblValue As Double
Dim rngFirst As Range
Dim iRng As Range
Dim strAdd As String
Dim blnSkip As Boolean
Dim sFile As String
Dim iResp As Integer
Dim NewRange As Range
Dim cSel As C_Selection


On Error GoTo errorHandler

    Set rng = Application.Selection
    Set cSel = New C_Selection
    cSel.RngIn = rng
    cSel.RowsIn = rng.Rows.Count
    cSel.ColsIn = rng.Columns.Count
  
    Set NewRange = Range(cSel.rngOut_Address)
    Set NewRange = NewRange.SpecialCells(xlCellTypeVisible)

'' Auto-Backup
        
           If Me.btnBackup = -1 Then
         
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B8").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If

Application.ScreenUpdating = False
        blnSkip = False
        With ThisWorkbook.Sheets("Store")
            Set rngStore = .Range(.Cells(2, 2), .Cells(65536, 2).End(xlUp))
            Set rngFirst = .Cells(2, 4)
        End With
            ' if undo is not checked then clear undo
            If Me.btnClear.Value <> -1 Then
              rngStore.Clear
              rngStore.Offset(0, 1).Clear
              rngFirst.Value = ""
            End If
  
            With ThisWorkbook.Sheets("Store")
                strAdd = .Cells(2, 4).Value
            End With
            
            ''Restore
            If strAdd <> "" Then
                On Error Resume Next
                     ThisWorkbook.Sheets("Store").Cells(2, 4).Value = NewRange.Address
                       
                  For Each sCell In rngStore
                        With ActiveSheet
                            .Range(sCell.Offset(0, 1).Value) = sCell.Value
                       End With
                    Next sCell
    
            End If

    strSheet = ActiveSheet.Name
    intplaces = Me.cboDec.Value
        i = 0
        For Each Cell In NewRange
            If IsNumeric(Cell.Value) And Cell.Value <> "" Then
            i = i + 1
            ReDim Preserve dblRounding(i)
            ReDim Preserve strAddress(i)
            dblRounding(i) = Cell.Value
            strAddress(i) = Cell.Address
            On Error Resume Next
                dblValue = Cell.Value
                    Select Case intRounding
                        Case 1
                            Cell.Value = Application.WorksheetFunction.RoundUp(dblValue, intplaces)
                        Case 2
                            Cell.Value = Application.WorksheetFunction.RoundDown(dblValue, intplaces)
                        Case 3
                            Cell.Value = Application.WorksheetFunction.Round(dblValue, intplaces)
                       
                    End Select
            On Error GoTo 0
            With rngStore
               If blnSkip = True Then GoTo cNext
                ''else store values
                .Cells(i + 1, 1).Value = dblRounding(i)
                .Cells(i + 1, 2).Value = strAddress(i)
                rngFirst.Value = NewRange.Address
            End With
cNext:
        End If
        Next Cell

    'Dispose of objects and erase array values

    Set cSel = Nothing
    Erase dblRounding
    Erase strAddress
    
    Application.ScreenUpdating = True
    
    
Exit Sub
errorHandler:
         MsgBox "Error Number: " & Err.Number & vbCrLf & Err.Description
End Sub

Private Sub UserForm_Initialize()
 Dim i As Long
 Dim rngStore As Range
 
            On Error Resume Next
            With ThisWorkbook.Sheets("Store")
                Set rngStore = .Range(.Cells(2, 2), .Cells(65536, 2).End(xlUp))
                rngStore.Clear
                .Range("A2").Value = ""
                .Cells(2, 4).Value = ""
            End With
            On Error GoTo 0
            
    With Me.cboDec
        .Clear
        For i = 0 To 5
            .additem i
        Next i
        .Value = 0
    End With
    
    Me.btnRnd = 1
    ' Defaults
      blnSaveFile = False
      If ThisWorkbook.Sheets("BupFlag").Range("B8").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B8").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
  
               
End Sub
Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then ActiveWorkbook.SaveCopyAs .SelectedItems(1)
            End If
   End With
    
        With Me.btnBackup
            blnSaved = True
            .Value = 0
            .Caption = "Backup Saved"
        End With
        
Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub

Attribute VB_Name = "frmRowCopy"
Attribute VB_Base = "0{1F71AF2E-A2D2-427A-A404-D9A791A7FB9D}{78AA3CE1-074D-47CE-A576-27647AC1825B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cmdOK_Click()
     ' address common error when data is imported
    Dim rng As Range
    Dim r As Long, c As Long, lCol As Long
    Dim rLast As Long
    
    On Error GoTo errorHandler
    
    r = Selection.Row
    c = Selection.Column
    rLast = Selection.Rows.Count + r - 1
    lCol = ActiveSheet.UsedRange.Columns.Count
       
    With ActiveSheet
        Set rng = .Range(.Cells(r, c), .Cells(rLast, lCol))
    End With
    
    rng.Select
    Selection.Copy
    
    Exit Sub
errorHandler:
    MsgBox Err.Description, vbExclamation
End Sub
Attribute VB_Name = "frmRowCut"
Attribute VB_Base = "0{74658D6C-8C1A-4F4A-9672-6FB9C138400A}{3B401A44-386E-4993-830E-907E9D187C36}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cmdOK_Click()
    ' address common error when data is imported

    Dim rng As Range
    Dim r As Long, c As Long, lCol As Long
    Dim rLast As Long
    
    On Error GoTo errorHandler
    
    r = Selection.Row
    c = Selection.Column
    rLast = Selection.Rows.Count + r - 1
    lCol = ActiveSheet.UsedRange.Columns.Count
       
    With ActiveSheet
        Set rng = .Range(.Cells(r, c), .Cells(rLast, lCol))
    End With
    
    rng.Select
    Selection.Cut
    
    Exit Sub
errorHandler:
    MsgBox Err.Description, vbExclamation
End Sub

Attribute VB_Name = "frmRowPaste"
Attribute VB_Base = "0{000D2511-859F-4CD2-812E-C0F3D416BD3E}{6CC044B0-500F-48B1-9C3C-E69606366EBD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cmdOK_Click()
    Dim rng As Range
    Set rng = Selection
    On Error Resume Next
        ActiveSheet.Paste
        rng.Select
    On Error GoTo 0
End Sub
Attribute VB_Name = "frmSelectDown"
Attribute VB_Base = "0{C3E23465-B638-4A0A-950A-EC043137C057}{81D1CA26-A653-4567-945F-2E7620E8E407}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdOK_Click()

''On Error GoTo errorHandler
' highlight a used column range based on cell selection
    Dim rng As Range, Cell As Range, rngSel As Range
    Dim rngUp As Range
    Dim c As Long, r As Long, l As Long
    Dim lRows As Long, lr As Long
    
    
    Set rngSel = Application.Selection
        If rngSel.Rows.Count > 1 Then
            MsgBox "select only cells in a single row"
            Exit Sub
        End If
         If rngSel.Row = 1 Then
            MsgBox "Please make another selection.Top Row No.1 Excluded..."
            Exit Sub
        End If
    
    lRows = ActiveSheet.Rows.Count
    r = rngSel.Row
    ' start column
    c = rngSel.Column
    'last column
    l = c + rngSel.Cells.Count - 1
    
    Set rng = Range(Cells(r, c), Cells(lRows, l).End(xlUp))
    '' Provide option to use the adjacent left and right column range
    If rng.Row < r And rng.Column <> 1 Then
            Set rngUp = Cells(lRows, c - 1).End(xlUp)
            lr = rngUp.Row
            Set rng = Range(Cells(r, c), Cells(lr, l))
            rng.Select
       ElseIf rng.Row <= r And rng.Column = 1 Then
            Set rngUp = Cells(lRows, c + 1).End(xlUp)
            lr = rngUp.Row
            Set rng = Range(Cells(r, c), Cells(lr, l))
            rng.Select
        ElseIf rng.Row >= r And rng.Column <> 1 And rng.Row <> 1 Then
            rng.Select
    End If

   '' Me.Hide
Exit Sub
errorHandler:
    MsgBox (Err.Description)
End Sub


Attribute VB_Name = "frmShortCuts"
Attribute VB_Base = "0{83F1BB9B-CC51-40F8-AF24-4AB840BBB785}{B6E03248-F98F-4DB5-9E01-55B6EEE755A0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim iMove As Single
Private Sub CommandButton1_Click()

End Sub

Private Sub btnEdit_Click()
    Unload Me
    frmGroupList.Show
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdFldr_Click()
    Me.Hide
    frmFolder.Show 0
End Sub

Private Sub cmdHelp_Click()
    frmHelpSC.Show 0
End Sub

Private Sub lblLink_Click()
    Dim str As String
    str = "http://www.mightymacros.com.au"
    ThisWorkbook.FollowHyperlink (str)
End Sub



Private Sub lstFiles_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim rngFile As Range
    Dim rng As Range
    Dim strFile As String
    Dim strPath As String
    Dim strFileName As String
    Dim i As Long
    Dim wbOpen As Boolean
    
    On Error GoTo errorHandler
    
    strFile = Me.lstFiles.Value
    
    Set rngFile = ThisWorkbook.Sheets("sCuts").Range("File_Name")
    
        With rngFile
            Set rng = .Find(strFile, LookIn:=xlValues, lookat:=xlWhole)
                If Not rng Is Nothing Then
                    strPath = rng.Offset(0, 1).Value
                End If
        End With
        
     ''' Get the file name from the path
        strFileName = Right(strPath, Len(strPath) - InStrRev(strPath, "\"))
    
     ''' Check for open files
            For i = 1 To Workbooks.Count
                    If UCase(Workbooks(i).Name) = UCase(strFileName) Then
                            MsgBox "File is Aready Open", vbExclamation
                            Workbooks(i).Activate
                            wbOpen = True
                                Exit For
                    End If
            Next i
            
            ''' Open the workbook if it isn't already open
            If strFileName <> "" And wbOpen = False Then Workbooks.Open (strPath)
            On Error Resume Next
             Me.Hide
            On Error GoTo 0
    Exit Sub
errorHandler:
    
    MsgBox Err.Description, vbCritical, "Error - ShortCut Selection"
    
End Sub

Private Sub lstGroups_Click()
    Dim rngGroup As Range, rngID As Range
    Dim rngFileID As Range
    Dim Cell As Range
    Dim strGroup As String
    Dim intID As Integer
    
    strGroup = Me.lstGroups.Value
    Me.lstFiles.Clear
    ''' Groups limited to max of 24
    Set rngGroup = ThisWorkbook.Sheets("sGroup").Range("GroupList")
    
    With rngGroup
      Set rngID = .Find(strGroup, LookIn:=xlValues, lookat:=xlWhole)
        If Not rngID Is Nothing Then
            intID = rngID.Offset(0, 1).Value
        End If
      End With
    
    Set rngFileID = ThisWorkbook.Sheets("sCuts").Range("Group_Name")
    
    For Each Cell In rngFileID
        If intID = Cell.Value Then
            Me.lstFiles.additem Cell.Offset(0, -2).Value
        End If
    Next Cell
End Sub

Private Sub UserForm_Initialize()
Dim rngList As Range, Cell As Range

    Set rngList = ThisWorkbook.Sheets("sGroup").Range("GroupList") ''' List range header
    
        For Each Cell In rngList
            If Left(Cell.Value, 6) <> "Group:" Then
                Me.lstGroups.additem Cell.Value
            End If
        Next Cell
        
        Call SortGroups
End Sub

Private Sub SortGroups()
' Sort listbox

    Dim i As Long
    Dim j As Long
    Dim sTemp As String
    Dim LbList As Variant
    On Error GoTo errorHandler
        'Store the list in an array for sorting
        LbList = Me.lstGroups.List
        
        'Bubble sort the array on the first value
        For i = LBound(LbList, 1) To UBound(LbList, 1) - 1
            For j = i + 1 To UBound(LbList)
                If LbList(i, 0) > LbList(j, 0) Then
                    'Swap the first value
                    sTemp = LbList(i, 0)
                    LbList(i, 0) = LbList(j, 0)
                    LbList(j, 0) = sTemp
                   sTemp = ""
                   
                End If
            Next j
        Next i
    'Remove the contents of the listbox
        Me.lstGroups.Clear
        
        'Repopulate with the sorted list
        Me.lstGroups.List = LbList
  Exit Sub
  
errorHandler:
If Err.Number = 13 Then
    MsgBox "No items listed....." & vbCrLf & _
        "Please Enter a 'Group Name'", vbExclamation
    Else
  MsgBox Err.Description, vbCritical, "Error"
End If

End Sub
Attribute VB_Name = "frmStoreText"
Attribute VB_Base = "0{7534F563-4732-4272-8C95-7E676B488864}{41F2FC9F-9FEA-4C65-B17E-83F2AC186FAF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim intIndex As Long ' Use variable to locate record


Private Sub cboBack_Change()
Dim rng As Range

On Error Resume Next
Set rng = ThisWorkbook.Sheets("SC").Range("B65536")
     If Me.cboBack = "(None)" Then
        Me.lblBack.BackStyle = fmBackStyleTransparent
      ElseIf IsNumeric(Me.cboBack) Then
        '' convert colorindex to label background
         rng.Interior.ColorIndex = Me.cboBack.Value
         Me.lblBack.BackStyle = fmBackStyleOpaque
         Me.lblBack.BackColor = rng.Interior.Color
    End If
    
On Error GoTo 0
End Sub

Private Sub cboObject_Change()
    If Me.cboObject.Value = "TextBox" Then
            Me.btnLines.Value = 0
            Me.cboHeight.Value = "100%"
            Me.cboWidth.Value = "100%"
            Me.txt2.Value = ""
            Me.txt3.Value = ""
            Me.txt4.Value = ""
            Me.txt5.Value = ""
         Call DisableCell
             
     ElseIf Me.cboObject.Value = "Cell" Then
         Call EnableCell
    End If
End Sub
Private Sub EnableCell()
        Me.btnFit.Enabled = True
        Me.btnLines.Enabled = True
        Me.txt2.Enabled = True
        Me.txt3.Enabled = True
        Me.txt4.Enabled = True
        Me.txt5.Enabled = True
        Me.cboHeight.Value = ""
        Me.cboHeight.Enabled = False
        Me.cboWidth.Value = ""
        Me.cboWidth.Enabled = False
End Sub
Private Sub DisableCell()
         Me.btnFit.Enabled = False
        Me.btnLines.Enabled = False
        Me.txt2.Enabled = False
        Me.txt3.Enabled = False
        Me.txt4.Enabled = False
        Me.txt5.Enabled = False
        Me.cboHeight.Enabled = True
        Me.cboWidth.Enabled = True
End Sub
Private Sub CmdClose_Click()
    Unload Me
    frmInsertText.Show 0
End Sub

Private Sub cmdDelete_Click()
Dim rng As Range
Dim iResp As Integer
    
 On Error GoTo errorHandler
 
    '' Provide warning before deletion
        iResp = MsgBox("Confirm deletion", vbExclamation + vbOKCancel)
            If iResp = vbCancel Then Exit Sub
    '' Determine if first record is empty
    '' If it is empty use alternate range to prevent deletion of header row
    With ThisWorkbook.Sheets("SC")
            If .Range("A2").Value <> "" Then
                Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
              Else
                Set rng = .Range(.Range("A2"), .Range("A2").End(xlDown))
            End If
    End With
    
    rng.Cells(intIndex, 1).EntireRow.Delete
    Call UserForm_Initialize
    Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical
End Sub

Private Sub cmdSave_Click()
Dim rng As Range
Dim iPct As Long, nPct As Long
Dim strHeight As String, strWidth As String
On Error GoTo errorHandler
    '' Determine if first record is empty
    '' If it is empty use alternate range to prevent deletion of header row
    With ThisWorkbook.Sheets("SC")
            If .Range("A2").Value <> "" Then
                Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
              Else
                Set rng = .Range(.Range("A2"), .Range("A2").End(xlDown))
            End If
    End With
        'exit if name is not entered
        If Me.txtShort.Value = "" Then
            MsgBox "Shortcut name is required", vbExclamation
            Exit Sub
        End If
        
    
        '' Return Values from form to addin workbook
        rng.Cells(intIndex, 1).Value = Me.txtShort.Text
        rng.Cells(intIndex, 2).Value = Me.txt1.Text
        rng.Cells(intIndex, 3).Value = Me.txt2.Text
        rng.Cells(intIndex, 4).Value = Me.txt3.Text
        rng.Cells(intIndex, 5).Value = Me.txt4.Text
        rng.Cells(intIndex, 6).Value = Me.txt5.Text
        rng.Cells(intIndex, 7).Value = Me.cboStyle.Value 'Font Style
        rng.Cells(intIndex, 8).Value = Me.cboFont.Value 'Font Type
        rng.Cells(intIndex, 9).Value = Me.cboSize.Value 'Font Size
        rng.Cells(intIndex, 10).Value = Me.cboColour.Value 'Font Colour
            If Me.btnWrap.Value = 0 Then 'text Wrap
                rng.Cells(intIndex, 11).Value = 0
               ElseIf Me.btnWrap.Value = -1 Then
                rng.Cells(intIndex, 11).Value = 1
            End If
        rng.Cells(intIndex, 12).Value = Me.cboAlign.Value 'text Align
        rng.Cells(intIndex, 13).Value = Me.cboObject.Value 'Object Type
        If Me.cboObject.Value = "TextBox" Then
            '' text box height and width
            strHeight = Me.cboHeight.Value
            strWidth = cboWidth.Value
            iPct = Len(strHeight) - 1
            nPct = Len(strWidth) - 1
            rng.Cells(intIndex, 17).Value = CDbl(Left(strHeight, iPct) / 100)
            rng.Cells(intIndex, 18).Value = CDbl(Left(strWidth, nPct) / 100)
        End If
        
            If Me.btnLines.Value = 0 Then
                rng.Cells(intIndex, 14).Value = 0
               ElseIf Me.btnLines.Value = -1 Then
                rng.Cells(intIndex, 14).Value = 1
            End If
        If Me.cboBack.Value = "(None)" Then
            rng.Cells(intIndex, 15).Value = -4142
        Else
            rng.Cells(intIndex, 15).Value = Me.cboBack.Value 'Back colour
        End If
        
        If Me.btnFit.Value = 0 Then
            rng.Cells(intIndex, 16).Value = 0
           ElseIf Me.btnLines.Value = -1 Then
            rng.Cells(intIndex, 16).Value = 1
        End If
        
        ThisWorkbook.Save
        
     Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical
End Sub

Private Sub defaultValues()
        Me.cboStyle.Value = "Regular"
        Me.cboFont.Value = "Arial" '' Font Type
        Me.cboSize.Value = 8 'Font Size
        Me.cboColour.Value = 1 'Font Colour
        Me.btnWrap.Value = 0
        Me.cboAlign.Value = "Centre" 'Alignmemt
        Me.cboObject.Value = "TextBox" 'Object Type
        Me.btnLines.Value = 0
        Me.cboBack.Value = "(None)"
        Me.btnFit.Value = 0
        Me.txtShort.Text = ""
        Me.txt1.Text = ""
        Me.txt2.Text = ""
        Me.txt3.Text = ""
        Me.txt4.Text = ""
        Me.txt5.Text = ""
        Me.cboHeight.Value = "100%"
        Me.cboWidth.Value = "100%"
        Call DisableCell
     Exit Sub


End Sub

Private Sub SpinButton1_SpinDown()
Dim rng As Range, Cell As Range

On Error GoTo errorHandler
    '' Determine if first record is empty
    '' If it is empty use alternate range to prevent showing the header row
    With ThisWorkbook.Sheets("SC")
        If .Range("A2").Value <> "" Then
            Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
           Else
            Set rng = .Range(.Range("A2"), .Range("A2").End(xlDown))
         End If
    End With
        
        
        If rng.Cells(intIndex, 1).Value = "" Then Exit Sub
        
        intIndex = intIndex + 1
        If rng.Cells(intIndex, 1).Value = "" Then
            Call defaultValues
            Exit Sub
        End If
        Me.txtShort.Text = rng.Cells(intIndex, 1).Value
        Me.txt1.Text = rng.Cells(intIndex, 2).Value
        Me.txt2.Text = rng.Cells(intIndex, 3).Value
        Me.txt3.Text = rng.Cells(intIndex, 4).Value
        Me.txt4.Text = rng.Cells(intIndex, 5).Value
        Me.txt5.Text = rng.Cells(intIndex, 6).Value
        Me.cboStyle.Value = rng.Cells(intIndex, 7).Value 'Font Style
        Me.cboFont.Value = rng.Cells(intIndex, 8).Value '' Font Type
        Me.cboSize.Value = rng.Cells(intIndex, 9).Value 'Font Size
        Me.cboColour.Value = rng.Cells(intIndex, 10).Value 'Font Colour
        Me.btnWrap.Value = rng.Cells(intIndex, 11).Value
        Me.cboAlign.Value = rng.Cells(intIndex, 12).Value 'Alignmemt
        Me.cboObject.Value = rng.Cells(intIndex, 13).Value 'Object Type
        '' Textbox height and Width
        If rng.Cells(intIndex, 13).Value = "TextBox" Then
            Me.cboHeight.Value = Format(rng.Cells(intIndex, 17).Value, "0%")
            Me.cboWidth.Value = Format(rng.Cells(intIndex, 18).Value, "0%")
        End If
        Me.btnLines.Value = rng.Cells(intIndex, 14).Value
         If rng.Cells(intIndex, 15).Value = -4142 Then
                Me.cboBack.Value = "(None)"
            Else
                Me.cboBack.Value = rng.Cells(intIndex, 15).Value
        End If
        If rng.Cells(intIndex, 13).Value = "Cell" Then
                Call EnableCell
                Me.btnFit.Value = rng.Cells(intIndex, 16).Value
           Else
            Call DisableCell
        End If
     Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical
End Sub

Private Sub SpinButton1_SpinUp()
Dim rng As Range, Cell As Range

On Error GoTo errorHandler
    '' Determine if first record is empty
    '' If it is empty use alternate range to prevent showing the header row
    
    With ThisWorkbook.Sheets("SC")
            If .Range("A2").Value <> "" Then
                Set rng = .Range(.Range("A2"), .Range("A65536").End(xlUp))
              Else
                Set rng = .Range(.Range("A2"), .Range("A2").End(xlDown))
            End If
    End With
             If intIndex = 1 Then
                MsgBox "This is the first record", vbExclamation
      
         ElseIf intIndex > 1 Then
                
                intIndex = intIndex - 1
                Me.txtShort.Text = rng.Cells(intIndex, 1).Value
                Me.txt1.Text = rng.Cells(intIndex, 2).Value
                Me.txt2.Text = rng.Cells(intIndex, 3).Value
                Me.txt3.Text = rng.Cells(intIndex, 4).Value
                Me.txt4.Text = rng.Cells(intIndex, 5).Value
                Me.txt5.Text = rng.Cells(intIndex, 6).Value
                Me.cboStyle.Value = rng.Cells(intIndex, 7).Value 'Style
                Me.cboFont.Value = rng.Cells(intIndex, 8).Value
                Me.cboSize.Value = rng.Cells(intIndex, 9).Value
                Me.cboColour.Value = rng.Cells(intIndex, 10).Value
                Me.btnWrap.Value = rng.Cells(intIndex, 11).Value
                Me.cboAlign.Value = rng.Cells(intIndex, 12).Value
                Me.cboObject.Value = rng.Cells(intIndex, 13).Value
                 '' Textbox height and Width
                If rng.Cells(intIndex, 13).Value = "TextBox" Then
                    Me.cboHeight.Value = Format(rng.Cells(intIndex, 17).Value, "0%")
                    Me.cboWidth.Value = Format(rng.Cells(intIndex, 18).Value, "0%")
                End If
                Me.btnLines.Value = rng.Cells(intIndex, 14).Value
                
                If rng.Cells(intIndex, 15).Value = -4142 Then
                    Me.cboBack.Value = "(None)"
                   Else
                    Me.cboBack.Value = rng.Cells(intIndex, 15).Value
               End If
               If rng.Cells(intIndex, 13).Value = "Cell" Then
                    Call EnableCell
                    Me.btnFit.Value = rng.Cells(intIndex, 16).Value
                   Else
                    Call DisableCell
                End If
        End If
 Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical
End Sub

Private Sub UserForm_Initialize()
Dim i As Long, n As Double
Dim rng As Range, Cell As Range

On Error GoTo errorHandler
Me.cboColour.Clear
Me.cboSize.Clear
Me.cboFont.Clear
Me.cboAlign.Clear
Me.cboObject.Clear
Me.cboBack.Clear
Me.cboStyle.Clear

    ''' Colour indexes
            For i = 1 To 56
                Me.cboColour.additem (i)
            Next i
            
    ''' Font Size
            For i = 8 To 72
                Me.cboSize.additem (i)
            Next i
     '''Back Colour
     
        Me.cboBack.additem "(None)"
        For i = 1 To 56
            Me.cboBack.additem (i)
        Next i
         Me.cboBack.Value = "(None)"
     ''' Font Type
        With ThisWorkbook.Sheets("Fonts")
            Set rng = .Range(.Range("A1"), .Range("A65536").End(xlUp))
        End With
        
        With Me.cboHeight
            For n = 0.1 To 5 Step 0.05
                Me.cboHeight.additem Format(n, "0%")
            Next n
            
        End With
        With Me.cboWidth
            For n = 0.1 To 5 Step 0.05
                Me.cboWidth.additem Format(n, "0%")
            Next n
            
        End With
     ''' Alighnment
     With Me.cboAlign
        .additem "Centre"
        .additem "Left"
        .additem "Right"
        .Value = "Centre"
     End With
     
      ''' Cell or Textbox
     With Me.cboObject
        .additem "Cell"
        .additem "TextBox"
        .Value = "Cell"
     End With
        
      For Each Cell In rng
        Me.cboFont.additem Cell.Value
      Next Cell
      
      'Font Style
      With Me.cboStyle
        .additem "Regular"
        .additem "Italic"
        .additem "Bold"
        .additem "Bold Italic"
        .Value = "Regular"
      End With
      
      '' Populate textbox Values on Open
      With ThisWorkbook.Sheets("SC")
            Me.txtShort.Text = .Range("A2").Value
            Me.txt1.Text = .Range("A2").Offset(0, 1).Value
            Me.txt2.Text = .Range("A2").Offset(0, 2).Value
            Me.txt3.Text = .Range("A2").Offset(0, 3).Value
            Me.txt4.Text = .Range("A2").Offset(0, 4).Value
            Me.txt5.Text = .Range("A2").Offset(0, 5).Value
            Me.cboStyle.Value = .Range("A2").Offset(0, 6).Value
            Me.cboFont.Value = .Range("A2").Offset(0, 7).Value
            Me.cboSize.Value = .Range("A2").Offset(0, 8).Value
            Me.cboColour.Value = .Range("A2").Offset(0, 9).Value
            Me.btnWrap.Value = .Range("A2").Offset(0, 10).Value
            Me.cboAlign.Value = .Range("A2").Offset(0, 11).Value
            Me.cboObject.Value = .Range("A2").Offset(0, 12).Value
            '' Textbox height and width
            If .Range("A2").Offset(0, 12).Value = "TextBox" Then
                 Me.cboHeight.Value = .Range("A2").Offset(0, 16).Value
                 Me.cboWidth.Value = .Range("A2").Offset(0, 17).Value
            End If
            
            Me.btnLines.Value = .Range("A2").Offset(0, 13).Value
            If .Range("A2").Offset(0, 14).Value = -4142 Then
                Me.cboBack.Value = "(None)"
               Else
                Me.cboBack.Value = .Range("A2").Offset(0, 14).Value
            End If
             If .Range("A2").Offset(0, 12).Value = "Cell" Then
                Call EnableCell
                Me.btnFit.Value = .Range("A2").Offset(0, 15).Value
               Else
                Call DisableCell
            End If
             
    End With
            intIndex = 1
            

    Exit Sub
errorHandler:
    MsgBox Err.Description, vbCritical
End Sub

Private Sub cboColour_Change()
Dim rng As Range
On Error Resume Next
Set rng = ThisWorkbook.Sheets("SC").Range("A65536")

    If Me.cboColour <> "" Then
        rng.Interior.ColorIndex = Me.cboColour.Value
        Me.lblColour.BackStyle = fmBackStyleOpaque
        Me.lblColour.BackColor = rng.Interior.Color
     Else
        Me.lblColour.BackStyle = fmBackStyleTransparent
    End If
On Error GoTo 0
End Sub

Attribute VB_Name = "frmTranspose"
Attribute VB_Base = "0{66D16C82-45BE-4BCB-87AD-48D962A7C57E}{58A9CF67-4957-4143-B6F0-0CEEF7105F46}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim clsCopy As New c_Trans

Private Sub btnClear_Click()
With Me.btnClear
    If .Value = -1 Then
         blnTransClear = True
        .Caption = "Clear copy rows"
       Else
         blnTransClear = False
        .Caption = "Keep copy rows"
    End If
End With
End Sub

Private Sub btnCopy_Click()
On Error GoTo errorHandler
With Me.btnCopy
    If .Value = -1 Then
        If Me.cbo_1.Value <> "" And Me.cbo_2.Value <> "" Then blnTransSel = True
        Set clsCopy.CellTranspose = Application
        .Caption = "On"
        .ForeColor = RGB(0, 120, 0)
        .Font.Bold = True
        iTransColumnOffset = Range(Me.cbo_1.Value & 1).Column
        iTransRowOffset = Me.cbo_2.Value
       Else
        Set clsCopy.CellTranspose = Nothing
        .Caption = "Off"
        .ForeColor = RGB(255, 0, 0)
        .Font.Bold = True
    End If
End With

Exit Sub
errorHandler:
MsgBox Err.Description

End Sub

Private Sub btnReverse_Click()
With Me.btnReverse
    If .Value = -1 Then
         blnTransReverse = True
        .Caption = "Reverse Transpose"
       Else
         blnTransReverse = False
        .Caption = "Transpose rows"
    End If
End With
End Sub

Private Sub cbo_1_Change()
    iTransColumnOffset = Range(Me.cbo_1.Value & 1).Column
End Sub

Private Sub cbo_2_Change()
    iTransRowOffset = Me.cbo_2.Value
End Sub

Private Sub UserForm_Initialize()
Dim i As Long
Dim j As Long
Dim intWbks As Integer  ' number of workbooks
Dim strWbName() As String  ' WorkBook Names
Dim ws As Worksheet

On Error GoTo errorHandler
blnTransSel = False
blnTransClear = False
    Me.cbo_1.Clear
    Me.cbo_2.Clear
    
         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cbo_1.additem Chr$(64 + i)
    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cbo_1.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
     Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
   For i = 259 To 256 Step -1
        Me.cbo_1.RemoveItem (i)
    Next i
    '' Populate row header combo
        For i = 1 To 999
        Me.cbo_2.additem (i)
    Next i
    
    '' Defaults
    Me.cbo_1.Value = "A"
    Me.cbo_2.Value = 1
    Me.btnClear = 0
Exit Sub
errorHandler:
MsgBox Err.Description, vbCritical
End Sub

Private Sub UserForm_Terminate()
Set clsCopy.CellTranspose = Nothing
End Sub
Attribute VB_Name = "frm_Transpose"
Attribute VB_Base = "0{2ADC50DC-6737-4A39-9B79-A8A9C2C014DF}{8CD3F296-7802-40C6-9E46-D4E23F28E776}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private strSheet As String
Private Sub cmdInput_Click()
    Dim rng As Range
    Set rng = Application.Selection
    strSheet = ActiveSheet.Name
    
    Me.lblRange.Caption = "'" & rng.Worksheet.Name & "'!" & rng.Address
    
End Sub

Private Sub cmdTranspose_Click()
Dim rngInput As Range
Dim r As Long, lRows As Long
Dim c As Integer, iCol As Integer
Dim strAddress As String
Dim strNew As String

On Error GoTo errorHandler

If Me.lblRange.Caption = "" Then Exit Sub

strAddress = Me.lblRange.Caption
Set rngInput = Range(strAddress)
lRows = rngInput.Rows.Count
iCol = rngInput.Columns.Count

' Add new sheet
 Sheets.Add before:=Sheets(1)
 strNew = ActiveSheet.Name
 'Transpose cells
 For r = 1 To lRows
    For c = 1 To iCol
        Sheets(strNew).Cells(c, r).Value = rngInput.Cells(r, c).Value
    Next c
 Next r
 
 'autofit columns
With Sheets(strNew).UsedRange
    .Select
    Selection.Columns.AutoFit
    .Range("A1").Select
End With

Exit Sub
errorHandler:

MsgBox Err.Description, vbExclamation

End Sub


Attribute VB_Name = "frmfindReplace"
Attribute VB_Base = "0{41F22E27-895B-439D-9AF7-4824B5ACC480}{FEC9145E-8603-4E7F-B12B-D8C8EEB89327}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Dim blnReverse As Boolean
Dim blnBup As Boolean
Dim blnSaveFile As Boolean
'Thanks to Jan Karel Pieterse to fix Excel SDI hiding user forms
'http://www.jkp-ads.com/articles/keepuserformontop02.asp
Private WithEvents XLApp As Excel.Application
Attribute XLApp.VB_VarHelpID = -1

Private Sub cmdDrop_Click()
Dim i As Long

On Error GoTo errorHandler

    '' Remove items
        With Me.lstItems
        For i = 0 To .ListCount - 1
            If .Selected(i) = True Then
                .RemoveItem (i)
            End If
        Next i
        End With

        
Exit Sub
errorHandler:
    MsgBox Err.Descriptio
End Sub

Private Sub XLApp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
    If val(Application.Version) >= 15 And mhwndForm <> 0 Then
        mXLHwnd = Application.hwnd    'Each SDI has its own window handle.
        SetWindowLongA mhwndForm, GWL_HWNDPARENT, mXLHwnd
        SetForegroundWindow mhwndForm
    End If
End Sub

Private Sub XLApp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub XLApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
    SetWindowLongA mhwndForm, GWL_HWNDPARENT, 0&
End Sub
'------------------------------------------------------------------------------------------------------------

Private Sub btnBackup_Click()
With Me.btnBackup
        If .Value = 0 Then
            .Caption = "Backup reminder is off..."
            .ForeColor = RGB(255, 0, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B6").Value = 0
           ElseIf .Value = -1 Then
             .Caption = "Backup reminder is on..."
            .ForeColor = RGB(0, 102, 0)
            .Font.Bold = True
            If blnSaveFile = True Then Exit Sub
            ThisWorkbook.Sheets("BupFlag").Range("B6").Value = 1
        End If
        ThisWorkbook.Save
  End With
End Sub

Private Sub btnRev_Click()
    If Me.btnRev = -1 Then
        Me.lblLeft.Caption = "Replace"
        Me.lblLeft.ForeColor = RGB(255, 0, 0)
        Me.LblRight.Caption = "Find"
        Me.LblRight.ForeColor = RGB(255, 0, 0)
        blnReverse = True
       Else
        Me.lblLeft.Caption = "Find"
        Me.lblLeft.ForeColor = RGB(0, 0, 0)
        Me.LblRight.Caption = "Replace"
        Me.LblRight.ForeColor = RGB(0, 0, 0)
        blnReverse = False
    End If
End Sub

Private Sub cmdAdd_Click()

Dim clsRef As c_Ref
Dim strRange As String
Dim RngIn As Range
Dim rng As Range, Cell As Range
Dim blnSelection As Boolean
Dim i As Long, n As Long
Dim iCol As Long
Dim lRow As Long, lLast As Long
Dim blnMatch As Boolean

On Error GoTo errorHandler
    
    Application.ScreenUpdating = False
    '' SET SEARCH RANGE
        
        If Selection.Columns.Count = 1 And Selection.Cells.Count <= 100 Then
            Set rng = Application.Selection.SpecialCells(xlCellTypeVisible)
           ElseIf Selection.Columns.Count > 1 Then
            MsgBox "Please select cells within a single column containing values you want to find" & vbCrLf _
            & "The adjacent column should contain the values you want to replace"
            Exit Sub
            
            ElseIf Selection.Cells.Count > 100 Then
                MsgBox "Maximum replacements of 100 items exceeded...", vbExclamation
            Exit Sub
        End If

    
       
        ''' Determine if a selection is made
        ''' Count the number of empty cells in the selection
        i = 0
         For Each Cell In rng
              If Not IsEmpty(Cell) Then i = i + 1
              If i > 0 Then
                blnSelection = True
                Exit For
              End If
         Next Cell
         
        ''' provide message if no selection is made:
                If blnSelection = False Then
                    MsgBox "No data selected...", vbExclamation
                    Unload Me
                    Exit Sub
                End If

       
    
        '' populate List
        i = 0
        
        With Me.lstItems
           '' Check if item is already listed
           '' If not then add to list
            For Each Cell In rng
            blnMatch = False
                For n = 0 To .ListCount - 1
                    If UCase(Cell.Value) = UCase(.List(n)) Then
                    blnMatch = True
                        Exit For
                    End If
                Next n
                If blnMatch = False Then
                    .additem Cell.Value
                    .List(n, 1) = Cell.Offset(0, 1).Value
                 End If
            Next Cell
        End With
       
  
  Exit Sub
errorHandler:
  MsgBox Err.Description
End Sub

Private Sub cmdApply_Click()
  Dim rng As Range, Cell As Range
    Dim strCol As String
    Dim strItem() As String
    Dim strReplace() As String, sFile As String
    Dim strBook As String
    Dim irow As Long, i As Long, n As Long, iList As Long
    Dim lCells As Long, lCount As Long, lTotal As Long
    Dim response As Integer
    Dim lFound As Long
    Dim iResp As Integer
 On Error GoTo errorHandler


    With ActiveSheet
     '' if no column is selected then asssume to search used range
        If Me.cboRet_1.Value = "" Then
            MsgBox "Please select Search column"
                Me.cboRet_1.SetFocus
                Exit Sub
       ElseIf Me.cboRet_1.Value <> "" Then
       '' Search the designaed column selected in the drop-box
            strCol = Me.cboRet_1.Value
            Set rng = .Range(.Range(strCol & 2), .Range(strCol & 65536).End(xlUp)).SpecialCells(xlCellTypeVisible)
        End If
    End With
    
       '' Auto-Backup
            blnBup = False
           If Me.btnBackup = -1 Then
                blnBup = True
                sFile = "Backup_" & ActiveWorkbook.Name
                iResp = MsgBox("Auto-Backup is enabled..." & vbCrLf & "Turn off 'Backup Reminder' and run?", vbQuestion + vbOKCancel + vbDefaultButton2)
                
                     If iResp = vbCancel Then
                            blnSaveFile = True
                            Call SaveMyCopy(sFile)
                            Me.btnBackup.Value = 0
                        Exit Sub
                            
                        ElseIf iResp = vbOK Then
                        Me.btnBackup.Value = 0
                        ThisWorkbook.Sheets("BupFlag").Range("B4").Value = 0
                        ThisWorkbook.Save
                    End If
                    
            End If
    
    
    lCells = rng.Cells.Count
    
    lCount = Me.lstItems.ListCount
    lTotal = lCount * lCells
    '' If more than 500 items are searched the advise caution
    If lCount > 500 Then
        response = MsgBox("You are searching for " & lCount & " items in " & lCells & " cells" & vbCrLf & _
        "Please be patient and wait for program to respond" & vbCrLf & _
        "It will take time to complete this task..." & vbCrLf & _
        "Do you want to continue ? ", vbOKCancel + vbExclamation + vbDefaultButton2)
    End If
    
    If response = vbCancel Then Exit Sub
        
    '' If column number is blank then restrict number of cells to search
    If Me.cboRet_1.Value = "" And lCells > 65536 Then
                MsgBox "Please narrow your search area by selecting a column from the drop-box... " & vbCrLf & _
                "Search the sheet clear the column selection and double click the items in list", vbExclamation
            Me.cboRet_1.SetFocus
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
     
     '' Find values in listbox and replce with values in adjacent column
     n = 0
     lFound = 0
     With Me.lstItems
        For i = 0 To .ListCount - 1
                    ReDim Preserve strItem(n)
                    ReDim Preserve strReplace(n)
                     strItem(n) = .List(i)
                     strReplace(n) = .List(i, 1)
                  '' Find / Replace
                        For Each Cell In rng
                            If blnReverse = False And _
                                Trim(UCase(CStr(Cell.Value))) = Trim(UCase(strItem(n))) Then
                                    Cell.Value = strReplace(n)
                                    lFound = lFound + 1
                                ElseIf blnReverse = True And _
                                   Trim(UCase(CStr(Cell.Value))) = Trim(UCase(strReplace(n))) Then
                                    Cell.Value = strItem(n) ' last cell found
                                    lFound = lFound + 1
                              End If
                         Next Cell
                Next i
           
        End With
        
    If lFound = 0 Then MsgBox "No values found to replace in selected column: " & "'" & _
    Me.cboRet_1.Value & "'", vbExclamation
    Application.ScreenUpdating = True

    Exit Sub
errorHandler:
    MsgBox Err.Description
    
End Sub

Private Sub cmdClear_Click()
    Me.lstItems.Clear
End Sub

Private Sub UserForm_Initialize()
'' populate column combos
Dim i As Long
Dim j As Long

On Error GoTo errorHandler

    'Get the user forms window handle
    'Excel 2013 and up
    If val(Application.Version) >= 15 Then
        Set XLApp = Application
        mhwndForm = FindWindowA("ThunderDFrame", Caption)
    End If


    blnReverse = False
    Me.cboRet_1.Clear


         ''' Populate combo Column Numbers
         ' A TO Z
    For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + i)

    Next i

    'AA to IZ
    For j = 1 To 9
     For i = 1 To 26
        Me.cboRet_1.additem Chr$(64 + j) & Chr$(64 + i)
      Next i
    Next j
     
    '' Trim to 256 columns
    '' Remove IW, IX, IY and IZ
    For i = 259 To 256 Step -1
        Me.cboRet_1.RemoveItem (i)

    Next i

   ' Defaults
      blnSaveFile = False
      If ThisWorkbook.Sheets("BupFlag").Range("B6").Value = 0 Then
        With Me.btnBackup
           .Value = 0
           .Caption = "Backup Reminder is off..."
           .ForeColor = RGB(255, 0, 0)
           .Font.Bold = True
        End With
     ElseIf ThisWorkbook.Sheets("BupFlag").Range("B6").Value = 1 Then
         With Me.btnBackup
           .Value = 1
           .Caption = "Backup Reminder is on..."
           .ForeColor = RGB(0, 102, 0)
           .Font.Bold = True
        End With
     End If
     
  Exit Sub
  
errorHandler:
MsgBox Err.Description, vbCritical
End Sub
Private Sub SaveMyCopy(strFile As String)
'' Save As without Swapping workbooks
'' Use SaveCopy as to produce a Copy of current
'' workbook without swapping to the copy

Dim response As Integer
Dim i As Long
Dim strItem As String
'Declare a variable as a FileDialogFilters collection.
    Dim fdfs As FileDialogFilters
 
    'Declare a variable as a FileDialogFilter object.
    Dim fdf As FileDialogFilter
    Dim fd As FileDialog

Dim sfilter As String, sExtention As String
On Error GoTo errorHandler

    If val(Application.Version) < 10 Then
        MsgBox "Excel 2002 or Later Required"
      Exit Sub
    End If

    
    'Set the FileDialogFilters collection variable to
    'the FileDialogFilters collection of the SaveAs dialog box.
    Set fdfs = Application.FileDialog(msoFileDialogSaveAs).Filters

 
    'Iterate through the description and extensions of each
    'default filter in the SaveAs dialog box.
    For Each fdf In fdfs
        'Display the description of filters that include
        'Microsoft Excel files
        If Right(fdf.Extensions, 3) = Right(strFile, 3) Then
           strItem = fdf.Description
           Exit For
        End If
    Next fdf
    Set fd = Application.FileDialog(msoFileDialogSaveAs)
    With fd
        For i = 1 To .Filters.Count
            If .Filters(i).Description = strItem Then
            .FilterIndex = i '' write to dialog and set filter number
            .InitialFileName = Application.DefaultFilePath & "\" & strFile
            .Title = "Select the path to save your backup copy..."
            .Show
             Exit For
             End If
        Next i
        
            If .SelectedItems.Count <> 0 Then
               response = MsgBox("Save Copy As: " & vbCrLf & vbCrLf & _
                        .SelectedItems(1), vbOKCancel + vbExclamation)
                        
                If response = vbOK Then
                    ActiveWorkbook.SaveCopyAs .SelectedItems(1)
                    blnBup = True
                    Me.btnBackup.Value = 0
                    Me.btnBackup.Caption = "Backup saved"
                   Else
                    blnBup = False
                End If
            End If
   End With

Exit Sub
errorHandler:
    MsgBox Err.Description & vbCrLf & "Error Number: " & Err.Number, vbCritical

End Sub


' InQuest injected base64 decoded content
' x)br
' )^J)
' ~`ZrD
' jZ Z

INQUEST-PP=macro
