Attribute VB_Name = "Auswertung"
Option Explicit
Option Private Module

'===================================================================
'Modul fuer die Auswertungen
'Sub auswerten ausgeloest durch Schaltflaeche "Auswertung starten" auf data_form
' - Anzahl ausgefuellte Datensaetze bestimmen
' - Formeln fuer Auswertung erzeugen
' - Daten auf hlp_data_regr1 und hlp_data_regr2 sortieren
' - letzten gueltigen Datensatz herausfinden
' - Namen fuer Regression anpassen
' - Auswertungsblaetter anzeigen


'*******************************************************************
'Passt einen Namen mit dem in A1-Schreibweise uebergebenen Range an
'Achtung: funktioniert nur mit absoluten Bezuegen
'z.B. call namen_anpassen("data_x_1", "$C$4:$H$20")
'Blattname wird nicht veraendert, sondern uebernommen
Sub namen_anpassen(ByVal strName As String, ByVal strrange As String)
  Call updateActiveProc("Auswertung.namen_anpassen")
  Dim strSheetName As String

  'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
  strSheetName = ThisWorkbook.Names(strName).RefersToRange.Worksheet.name
  ThisWorkbook.Names.Add name:=strName, RefersTo:= _
    "=" & strSheetName & "!" & strrange
End Sub


'*******************************************************************
'Liefert fuer hlp_data_regr1 und hlp_data_regr2 die Zeile mit dem letzten gueltigen Datensatz zurueck
'Notwendig fuer die Anpassung der Namen
Function funlnglastvalidrow(ByVal strblattname As String, ByVal strName As String, _
  ByVal lnganzdatensaetze As Long) As Long
  'Achtung updateActiveProc fuehrt dazu, dass lngfoundrow falsch berechnet wird!!
  'Call updateActiveProc("Auswertung.funlnglastvalidrow")
  straktiveprozedur = "Auswertung.funlnglastvalidrow"
  
  Dim bytstartrow As Byte
  Dim lngendrow As Long
  Dim lngfoundrow As Long
  Dim objstartcell As Range
  Dim objfound As Variant
  Dim strcolfilter As String
  
  bytstartrow = ThisWorkbook.Names(strName).RefersToRange.Row
  lngendrow = bytstartrow + lnganzdatensaetze
  strcolfilter = funstrcol_byname(strName)
  lngfoundrow = lngendrow
  
  'Set objstartcell = ThisWorkbook.Names(strname).RefersToRange
  Set objfound = ThisWorkbook.Sheets(strblattname).Range(strcolfilter & bytstartrow & ":" & strcolfilter & lngendrow).Find( _
    what:="0", LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByColumns, _
    SearchDirection:=xlNext, MatchCase:=False)
  If Not objfound Is Nothing Then
    lngfoundrow = objfound.Row - 1
  End If
  funlnglastvalidrow = lngfoundrow
End Function
        
        
'*******************************************************************
'Testroutine fuer funlnglastvalidrow
Private Sub testfunlnglastvalidrow()
  MsgBox funlnglastvalidrow("hlp_data_regr1", "hlp_data_regr1_col_filter", 30)
End Sub

 
'*******************************************************************
'Blendet Basisregression auf Blatt rpt_fazit ein und aus
'Eventhandler fuer Klick auf btnbasisregression
'Aber auch nach Auswertung aufgerufen, weil Basisregression
'nur ausgeblendet ist, wenn die Anzahl gueltige Datensaetze fuer
'Basis- und Standardregression identisch ist
Sub showhidecolbasisregression(Optional varhide As Variant)
  Dim blnProtected As Boolean
  blnProtected = ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Unprotect Password:=changeToNumberString("s")
  
  If IsMissing(varhide) Then
    ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).Columns(STR_RPT_FAZIT_COLADDR).EntireColumn.Hidden = _
      Not ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).Columns(STR_RPT_FAZIT_COLADDR).EntireColumn.Hidden
  Else
    ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).Columns(STR_RPT_FAZIT_COLADDR).EntireColumn.Hidden = varhide
  End If
  Call translatebtnbasisregression
  
  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(STR_SH_RPT_FAZIT, blnProtected)
End Sub


'*******************************************************************
'Hilfsmakro fuer die Formeln auf den Regressionsblaettern
' - str_data_form: Name der Spalte auf data_form (nur Kurzform, z.B. gebjahr)
' - str_regr: Name der Spalte auf Regressionsblaettern (nur Kurzform, z.B. alter)
' - lnganzdatensaetze: Anzahl Datensaetze insgesamt (inkl. falsche)
' - lngrow_data_form: 1. Zeilennr des Datenbereichs im data_form
' - lngrow_hlp_data_regr1: 1. Zeilennr des Datenbereichs in data_regr1
' - lngrow_hlp_data_regr2: 1. Zeilennr des Datenbereichs in data_regr2
' - objsheet_regr1: Sheet fuer die Basisregression
' - objsheet_regr2: Sheet fuer die erweiterte Regression
' z.B.   Call spalten_regr_fuellen("gebjahr", "alter", lnganzdatensaetze, lngrow_data_form,
'    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)

Sub spalten_regr_fuellen(ByVal str_data_form As String, ByVal str_regr As String, _
  ByVal lnganzdatensaetze As Long, ByVal lngrow_data_form As Long, _
  ByVal lngrow_hlp_data_regr1 As Long, ByVal lngrow_hlp_data_regr2 As Long, _
  ByRef objsheet_regr1 As Worksheet, ByRef objsheet_regr2 As Worksheet)
  
  Call updateActiveProc("Auswertung.spalten_regr_fuellen")
  Const BYT_ABZUG_BERJA As Byte = 6
  Dim strcol_hlp_data_form As String
  Dim strcol_hlp_data_regr1 As String
  Dim strcol_hlp_data_regr2 As String
  Dim strcol_hlp_data_regr2_end As String 'wenn mehr als eine Spalte gefuellt wird
  Dim strformel1 As String 'Formel fuer hlp_data_regr1
  Dim strformel2 As String 'Formel fuer hlp_data_regr2
  Dim strSpalte As Variant 'muss Variant wegen for each ueber Array
  Dim strColBgrad, strcolBezStunden, strColJahresarbeitszeit
  
  Static byt_regr1_hlprow As Byte 'Hilfzeile fuer die Formeln in hlp_data_regr1 fuer mbls_0 etc
  Static byt_regr2_hlprow As Byte 'Hilfzeile fuer die Formeln in hlp_data_regr2 fuer anf und bst
  
  'Fuer die Spalten ml, vz auf hlp_data_regr2
  strColBgrad = funstrcol_byname("data_form_col_bgrad") 'K
  strcolBezStunden = funstrcol_byname("data_form_col_bezstunden") 'L
  strColJahresarbeitszeit = funstrcol_byname("data_form_col_jahresarbeitszeit") 'R
  
  If byt_regr1_hlprow <= 0 Then
    byt_regr1_hlprow = ThisWorkbook.Names("hlp_data_regr1_row_hlpanf").RefersToRange.Row
  End If
  
  If byt_regr2_hlprow <= 0 Then
    byt_regr2_hlprow = ThisWorkbook.Names("hlp_data_regr2_row_hlpanf").RefersToRange.Row
  End If
  
  'Spaltenbezeichnungen definieren
  'dienstjahre existieren in data_form nicht, werden errechnet
  If funblnexistsname("data_form_col_" & str_data_form) Then
    strcol_hlp_data_form = funstrcol_byname("data_form_col_" & str_data_form)
  Else
    strcol_hlp_data_form = ""
  End If
  
  'In der Basisregression existieren viel weniger Spalten als in der erweiterten Regression
  If funblnexistsname("hlp_data_regr1_col_" & str_regr) Then
    strcol_hlp_data_regr1 = funstrcol_byname("hlp_data_regr1_col_" & str_regr)
  Else
    strcol_hlp_data_regr1 = ""
  End If
  strcol_hlp_data_regr2 = funstrcol_byname("hlp_data_regr2_col_" & str_regr)

  Select Case str_regr
    'Filter: ab 23.03.2016 V3 nehmen regr1 und regr2 die Filterspalte data_form_col_filter_erw
    Case "filter"
      strformel1 = "=" & STR_SH_DATA_FORM & "!" & _
          funstrcol_byname("data_form_col_filter_erw") & lngrow_data_form
      strformel2 = strformel1
    
    Case "laufnr", "dienstja", "ausbildung", "anf", "bst"
      strformel1 = "=" & STR_SH_DATA_FORM & "!" & strcol_hlp_data_form & lngrow_data_form
      strformel2 = strformel1
    
    Case "alter"
      'SR 12.9.2006 Alter bezieht sich auf eingegebenes Jahr, nicht auf aktuelles Datum
      strformel1 = "=data_head_c_jahr-" & STR_SH_DATA_FORM & "!" & strcol_hlp_data_form & lngrow_data_form
      strformel2 = strformel1
    
    'SR 26.05.2016 abfangen von Werten ausserhalb Range
    Case "ausbja"
      strformel1 = "=IF(ISERROR(VLOOKUP(" & STR_SH_DATA_FORM & "!" & strcol_hlp_data_form & lngrow_data_form & ",hlp_const_lst_ausbja,2,0)),0," _
        & "VLOOKUP(" & STR_SH_DATA_FORM & "!" & strcol_hlp_data_form & lngrow_data_form & ",hlp_const_lst_ausbja,2,0))"
      strformel2 = strformel1
    
    Case "berja" '=max(C6-D6-6,0), d.h. alter - ausbja - 6
      strformel1 = "=MAX(" & funstrcol_byname("hlp_data_regr1_col_alter") & _
        lngrow_hlp_data_regr1 & "-" & _
        funstrcol_byname("hlp_data_regr1_col_ausbja") & _
        lngrow_hlp_data_regr1 & "-" & BYT_ABZUG_BERJA & ",0)"
      strformel2 = "=MAX(" & funstrcol_byname("hlp_data_regr2_col_alter") & _
        lngrow_hlp_data_regr2 & "-" & _
        funstrcol_byname("hlp_data_regr2_col_ausbja") & _
        lngrow_hlp_data_regr2 & "-" & BYT_ABZUG_BERJA & ",0)"
    
    Case "berja2" '=berja^2
      '21.9.2005 Angleichung an Methodenbeschrieb Silvia Strub nach Tagung vom 20.9.2005
      strformel1 = "=" & funstrcol_byname("hlp_data_regr1_col_berja") & _
        lngrow_hlp_data_regr1 & "^2"
      strformel2 = "=" & funstrcol_byname("hlp_data_regr2_col_berja") & _
        lngrow_hlp_data_regr2 & "^2"
    
    Case "frau_d"
      strformel1 = "=" & STR_SH_DATA_FORM & "!" & strcol_hlp_data_form & lngrow_data_form & "-1"
      strformel2 = strformel1
    
    Case "lnlohn" '=LN(data_form!U16)
      strformel1 = "=LN(" & STR_SH_DATA_FORM & "!" & _
        funstrcol_byname("data_form_col_gesverdienst") & lngrow_data_form & ")"
      strformel2 = strformel1
    
    Case "mbls"
      strformel1 = "=" & STR_SH_DATA_FORM & "!" & _
        funstrcol_byname("data_form_col_gesverdienst") & lngrow_data_form
      strformel2 = strformel1
    
    Case "mbls_prog"
      strformel1 = ""
      
      strformel2 = "=EXP(koeff2_b"
      For Each strSpalte In Array("ausbja", "dienstja", "berja", "berja2", "anf1_d", "anf2_d", "anf3_d", "anf4_d", _
        "bst1_d", "bst2_d", "bst3_d", "bst4_d", "bst5_d", "frau_d")
        strformel2 = strformel2 & "+" & funstrcol_byname("hlp_data_regr2_col_" & strSpalte) & lngrow_hlp_data_regr2 _
          & "*koeff2_" & strSpalte
      Next
      strformel2 = strformel2 & ")"
    
    'Ab 3.1.0 mit geschlechtsneutraler Regression
    Case "mbls_prog_gn"
      strformel1 = ""
      
      strformel2 = "=EXP(koeff3_b"
      For Each strSpalte In Array("ausbja", "dienstja", "berja", "berja2", "anf1_d", "anf2_d", "anf3_d", "anf4_d", _
        "bst1_d", "bst2_d", "bst3_d", "bst4_d", "bst5_d")
        strformel2 = strformel2 & "+" & funstrcol_byname("hlp_data_regr2_col_" & strSpalte) & lngrow_hlp_data_regr2 _
          & "*koeff3_" & strSpalte
      Next
      strformel2 = strformel2 & ")"
    
    Case "anf1_d", "bst1_d"  '=IF(data_lse!$I26=H$4,1,0)
      If str_regr = "anf1_d" Then
        strcol_hlp_data_regr2_end = funstrcol(ThisWorkbook.Names("hlp_data_regr2_col_anf1_d").RefersToRange.Column + 3)
      Else
        strcol_hlp_data_regr2_end = funstrcol(ThisWorkbook.Names("hlp_data_regr2_col_bst1_d").RefersToRange.Column + 4)
      End If
      strformel1 = ""
      strformel2 = "=IF(" & STR_SH_DATA_FORM & "!$" & strcol_hlp_data_form & lngrow_data_form & "=" & _
        strcol_hlp_data_regr2 & "$" & byt_regr2_hlprow & ",1,0)"
    
    'SR 21.11.2008
    Case "mbls_0", "mbls_1"
      '=WENN($J11=M$8;$L11;NV())
      strformel1 = "=IF(" & funstrcol_byname("hlp_data_regr1_col_frau_d") & _
        lngrow_hlp_data_regr1 & "=" & strcol_hlp_data_regr1 & "$" & byt_regr1_hlprow & ",$" & _
        funstrcol_byname("hlp_data_regr1_col_mbls") & lngrow_hlp_data_regr1 & ",NA())"
        
      '=WENN($S11=Z$8;$U11;NV())
      strformel2 = "=IF(" & funstrcol_byname("hlp_data_regr2_col_frau_d") & _
        lngrow_hlp_data_regr2 & "=" & strcol_hlp_data_regr2 & "$" & byt_regr2_hlprow & ",$" & _
        funstrcol_byname("hlp_data_regr2_col_mbls") & lngrow_hlp_data_regr2 & ",NA())"

    Case "ml" 'ab 14.02.2019 Im Monatslohn %%%%
      '=IF(data_form!K14>0,1,0)
      strformel1 = ""
      strformel2 = "=IF(" & STR_SH_DATA_FORM & "!" & strColBgrad & lngrow_data_form & ">0,1,0)"
    
    Case "vollzeit" 'ab 14.02.2019
      '=IF(data_form!K14>0,data_form!K14/100,IF(data_form!L14>0,(data_form!L14*12/data_form!R14),0))
      strformel1 = ""
      strformel2 = "=IF(" & STR_SH_DATA_FORM & "!" & strColBgrad & lngrow_data_form & ">0," & _
        STR_SH_DATA_FORM & "!" & strColBgrad & lngrow_data_form & "/100,IF(" & _
        STR_SH_DATA_FORM & "!" & strcolBezStunden & lngrow_data_form & ">0," & STR_SH_DATA_FORM & "!" & _
        strcolBezStunden & lngrow_data_form & _
        "*12/" & STR_SH_DATA_FORM & "!" & strColJahresarbeitszeit & lngrow_data_form & ",0))"
    
    'Ab 14.02.2019 standardisierte Lohnbestandteile
    Case "bruttolohn_standard", "zulagen_standard", "13monatslohn_standard", "sonderz_standard"
      strformel1 = ""
      strformel2 = "=" & STR_SH_DATA_FORM & "!" & _
        funstrcol_byname("data_form_col_" & str_regr) & lngrow_data_form
        
    Case Else
      strformel1 = ""
      strformel2 = ""
  End Select
  
  'Blatt hlp_data_regr1
  If strcol_hlp_data_regr1 <> "" And strformel1 <> "" And lnganzdatensaetze > 0 Then
    objsheet_regr1.Range(strcol_hlp_data_regr1 & lngrow_hlp_data_regr1 & _
      ":" & strcol_hlp_data_regr1 & (lngrow_hlp_data_regr1 + lnganzdatensaetze - 1)).Formula = strformel1
  End If
  
  'Blatt hlp_data_regr2
  If strcol_hlp_data_regr2 <> "" And strformel2 <> "" Then
    'fuer anf.. und bst.. werden mehrere Spalten gefuellt
    Select Case str_regr
    Case "anf1_d", "bst1_d"
      objsheet_regr2.Range(strcol_hlp_data_regr2 & lngrow_hlp_data_regr2 & _
        ":" & strcol_hlp_data_regr2_end & (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).Formula = strformel2
    
    Case Else
      objsheet_regr2.Range(strcol_hlp_data_regr2 & lngrow_hlp_data_regr2 & _
        ":" & strcol_hlp_data_regr2 & (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).Formula = strformel2
    End Select
  End If
  
  'Debug.Print Timer & ": auswerten nach " & str_regr
End Sub


'*******************************************************************
'Hilfsmakro fuer bedingte Formatierung auf hlp_data_regr1 und hlp_data_regr2
Sub regr_bedingteformatierung(ByRef objRange As Range, ByVal intstartrow As Integer, _
  ByVal strcolfilter As String, ByVal strcolgeschlecht As String)
  
  Call updateActiveProc("Auswertung.regr_bedingteformatierung")
  
  Dim intbordercolor As Integer
  intbordercolor = funvarvalue_byname("hlp_const_c_bordercolor")
  Dim blneingeblendet
  blneingeblendet = False
  
  If objRange.Parent.Visible = False Then
    'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
    Call blatt_einblenden(objRange.Worksheet.name, changeToNumberString("m"), True)
    blneingeblendet = True
  End If
  
  objRange.Parent.Activate
  objRange.Select
  objRange.FormatConditions.delete
  
  objRange.FormatConditions.Add Type:=xlExpression, _
    Formula1:="=$" & strcolfilter & intstartrow & "=0"
  With objRange.FormatConditions(objRange.FormatConditions.Count)
    .Font.ColorIndex = xlAutomatic
    
    .Borders(xlLeft).LineStyle = xlContinuous
    .Borders(xlLeft).Weight = xlThin
    .Borders(xlLeft).Color = intbordercolor
    
    .Borders(xlRight).LineStyle = xlContinuous
    .Borders(xlRight).Weight = xlThin
    .Borders(xlRight).Color = intbordercolor
    
    .Borders(xlTop).LineStyle = xlContinuous
    .Borders(xlTop).Weight = xlThin
    .Borders(xlTop).Color = intbordercolor
    
    .Borders(xlBottom).LineStyle = xlContinuous
    .Borders(xlBottom).Weight = xlThin
    .Borders(xlBottom).Color = intbordercolor
    
    .Interior.Color = funvarvalue_byname("hlp_const_c_data_filter0")
  End With
  
  objRange.FormatConditions.Add Type:=xlExpression, _
    Formula1:="=$" & strcolgeschlecht & intstartrow & "=1"
  With objRange.FormatConditions(objRange.FormatConditions.Count)
    .Font.ColorIndex = xlAutomatic
    
    .Borders(xlLeft).LineStyle = xlContinuous
    .Borders(xlLeft).Weight = xlThin
    .Borders(xlLeft).Color = intbordercolor
    
    .Borders(xlRight).LineStyle = xlContinuous
    .Borders(xlRight).Weight = xlThin
    .Borders(xlRight).Color = intbordercolor
    
    .Borders(xlTop).LineStyle = xlContinuous
    .Borders(xlTop).Weight = xlThin
    .Borders(xlTop).Color = intbordercolor
    
    .Borders(xlBottom).LineStyle = xlContinuous
    .Borders(xlBottom).Weight = xlThin
    .Borders(xlBottom).Color = intbordercolor
    
    .Interior.Color = funvarvalue_byname("hlp_const_c_data_female")
  End With
  
  If blneingeblendet = True Then
    'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
    Call blatt_ausblenden(objRange.Worksheet.name, changeToNumberString("m"))
  End If
  
End Sub


'*******************************************************************
'Hilfsmakro, das auf hlp_data_regr1 und hlp_data_regr2 das normale Gitternetz zeichnet
Sub regr_borderlines(ByRef objRange As Range)
  
  Call updateActiveProc("Auswertung.regr_borderlines")
  
  Dim intbordercolor As Integer
  
  intbordercolor = funvarvalue_byname("hlp_const_c_bordercolor")
  
  With objRange
    .Borders(xlEdgeTop).LineStyle = xlContinuous
    .Borders(xlEdgeTop).Weight = xlMedium
    .Borders(xlEdgeTop).Color = intbordercolor
        
    .Borders(xlEdgeBottom).LineStyle = xlContinuous
    .Borders(xlEdgeBottom).Weight = xlMedium
    .Borders(xlEdgeBottom).Color = intbordercolor
        
    .Borders(xlEdgeLeft).LineStyle = xlContinuous
    .Borders(xlEdgeLeft).Weight = xlThin
    .Borders(xlEdgeLeft).Color = intbordercolor
    
    .Borders(xlEdgeRight).LineStyle = xlContinuous
    .Borders(xlEdgeRight).Weight = xlThin
    .Borders(xlEdgeRight).Color = intbordercolor
    
    .Borders(xlInsideVertical).LineStyle = xlContinuous
    .Borders(xlInsideVertical).Weight = xlThin
    .Borders(xlInsideVertical).Color = intbordercolor
    
    .Borders(xlInsideHorizontal).LineStyle = xlContinuous
    .Borders(xlInsideHorizontal).Weight = xlThin
    .Borders(xlInsideHorizontal).Color = intbordercolor
  End With

End Sub
 
    
'*******************************************************************
'Hauptmakro fuer den Schritt "Auswertung"
Sub auswerten()
  'On Error GoTo fehler
  Call updateActiveProc("Auswertung.auswerten")
  
  'Debug.Print Timer & ": auswerten Start"
  
  Dim blnregr2einblenden As Boolean
  Dim blnbezstundentesten As Boolean
  Dim blnbezstundeninkonsistent As Boolean
  
  Dim objCell As Range
  Dim objrange_data_form_sd As Range
  Dim objrange_hlp_data_regr1_sd As Range
  Dim objrange_hlp_data_regr2_sd As Range
  Dim objrange_regr1_data As Range 'Gesamter Datenrange inkl. ungueltige Datensaetze
  Dim objrange_regr2_data As Range 'Gesamter Datenrange inkl. ungueltige Datensaetze
  Dim objsheet_regr1 As Worksheet
  Dim objsheet_regr2 As Worksheet
  Dim objstartcell As Range
   
  Dim lnganzdatensaetze As Long
  Dim lng_data_form_lastrow As Long 'Letzte mit Daten gefuellte Zeile in data_form
  Dim lng_regr1_lastvalidrow As Long
  Dim lng_regr2_lastvalidrow As Long
  Dim lngrow_data_form As Long 'Startzeile in data_form
  Dim lngrow_hlp_data_regr1 As Long 'Startzeile in hlp_data_regr1
  Dim lngrow_hlp_data_regr2 As Long 'Startzeile in hlp_data_regr2
  Dim lngRowFirst As Long
  Dim lngRowLast As Long
  Dim strcol_bezstunden As String
  Dim strcol_hlp_data_regr1 As String
  Dim strcol_hlp_data_regr2 As String
  Dim strcol_x_start As String
  Dim strcol_x_end, strcol_x3_end As String
  Dim strcol_y As String
  Dim strdataformformel As String
  Dim varcolbez As Variant
  
  'Initialisierung einiger Variablen
  Set objsheet_regr1 = ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR1)
  Set objsheet_regr2 = ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2)
  Set objrange_data_form_sd = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD)
  Set objrange_hlp_data_regr1_sd = ThisWorkbook.Names("hlp_data_regr1_sd").RefersToRange
  Set objrange_hlp_data_regr2_sd = ThisWorkbook.Names("hlp_data_regr2_sd").RefersToRange
  
  Set objstartcell = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD)
  lngRowFirst = objstartcell.Row
  lngRowLast = lngRowFirst + funanzmitarb() + INT_MARGE - 1
  
  'Anzahl ausgefuellte Datensaetze bestimmen
  lnganzdatensaetze = funLngLastRowEvenIfFiltered(ThisWorkbook.name, STR_SH_DATA_FORM) _
    - ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row + 1
  'Debug.Print Timer & ": auswerten nach Bestimmung Anzahl Datensaetze: " & lnganzdatensaetze

  'Ab 3.1.0 testen, ob data_head_c_jahrarbzeitabw leer wenn data_head_c_stundenlohn_jn = Ja
  If Left(funvarvalue_byname("data_head_c_stundenlohn_jn"), 1) = "2" And funvarvalue_byname("data_head_c_jahrarbzeitabw") = 0 Then
    If MsgBox(strtranslate("msgbox_data_form.jahrarbzeitabw"), vbOKOnly + vbCritical) = vbOK Then
      Exit Sub
    End If
  End If
  
  'Ab 3.0.7 testen, ob bezstunden erfasst ohne data_head_c_stundenlohn_jn
  blnbezstundentesten = False
  blnbezstundeninkonsistent = False
  'ist die Jahresstundenzahl nicht numerisch, d.h. ungueltig
  If Not IsNumeric(funvarvalue_byname("data_head_c_stundenlohn_anzstunden")) Then
    blnbezstundentesten = True
  Else
    'Ist die Jahresstundenzahl <= 0
    If funvarvalue_byname("data_head_c_stundenlohn_anzstunden") <= 0 Then
      blnbezstundentesten = True
    End If
  End If
  'Wurde 1 Nein in data_head_c_stundenlohn_jn eingegeben
  If Left(funvarvalue_byname("data_head_c_stundenlohn_jn"), 1) = "1" Then
    blnbezstundentesten = True
  End If
  
  If blnbezstundentesten = True Then
    strcol_bezstunden = funstrcol_byname("data_form_col_bezstunden")
    For Each objCell In ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(strcol_bezstunden & lngRowFirst & ":" & strcol_bezstunden & lngRowLast)
      If IsNumeric(objCell.Value) Then
        If objCell.Value > 0 Then
          blnbezstundeninkonsistent = True
          Exit For
        End If
      End If
    Next
  End If
  
  If blnbezstundeninkonsistent Then
    If MsgBox(strtranslate("msgbox_data_form.bezstunden"), vbOKOnly + vbCritical) = vbOK Then
      Exit Sub
    End If
  End If
  
  'Hinweis auf Anzahl gueltige Datensaetze mit Moeglichkeit zum Abbruch
  Application.EnableEvents = False
  ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value = lnganzdatensaetze
  Application.EnableEvents = True
  'Gefragt wird nur, wenn Anzahl Datensaetze fuer Erweiterte Regression < Gesamtanzahl
  If lnganzdatensaetze > CLng(funvarvalue_byname("data_form_c_anzerw")) Then
    Dim strmeldung As String
    strmeldung = Replace(strtranslate("msgbox_startausw.text"), "|data_head_c_anzmitarb|", lnganzdatensaetze)
    'Spalte data_form_c_anzbasis geloescht ab 23.03.2016 V3
    strmeldung = Replace(strmeldung, "|data_form_c_anzerw|", funvarvalue_byname("data_form_c_anzerw"))
    If MsgBox(strmeldung, vbOKCancel) = vbCancel Then
      Exit Sub
    End If
  End If
   
  'Fortschrittsanzeige
  frmfortschrittsanzeige.btnok.Visible = False
  frmfortschrittsanzeige.Caption = strtranslate("frmfortschrittsanzeige.caption")
  frmfortschrittsanzeige.lblerklaerung = strtranslate("frmfortschrittsanzeige.lblerkauswertungstart")
  frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllaufausw")
  frmfortschrittsanzeige.txtrahmen.Visible = False
  frmfortschrittsanzeige.lblbalken.Visible = False
  
  'Mac kennt vbModeless nicht und unterbricht Macro!!!
  If Not Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.Show (vbModeless)
    frmfortschrittsanzeige.Repaint
  Else
    'Mac -> kein vbModeless -> Anzeige im StatusBar
    Call updatestatusbar_mac(strtranslate("frmfortschrittsanzeige.lblerkauswertungstart"))
  End If
  If Not Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.Show (vbModeless)
    frmfortschrittsanzeige.Repaint
  Else
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext1mac")
    'frmfortschrittsanzeige.show 'zeitbasierte Anzeige
    Call showFrmfortschrittsanzeigeMac
  End If
  Application.ScreenUpdating = False
  
  'Blattschutz ausschalten
  ThisWorkbook.Worksheets(STR_SH_HLP_DATA_REGR1).Unprotect Password:=changeToNumberString("s")
  ThisWorkbook.Worksheets(STR_SH_HLP_DATA_REGR2).Unprotect Password:=changeToNumberString("s")
  
  '1. Zeilennummer des Quelldatenbereichs
  lngrow_data_form = objrange_data_form_sd.Row
  lngrow_hlp_data_regr1 = objrange_hlp_data_regr1_sd.Row
  lngrow_hlp_data_regr2 = objrange_hlp_data_regr2_sd.Row
  
  'Keine Berechnungen waehrend Formeleingabe
  Call berechnung_ausschalten
  
  'Datenbereich loeschen
  strcol_hlp_data_regr1 = funstrcol_byname("hlp_data_regr1_sd")
  strcol_hlp_data_regr2 = funstrcol_byname("hlp_data_regr2_sd")
  ThisWorkbook.Worksheets(STR_SH_HLP_DATA_REGR1).Range(strcol_hlp_data_regr1 & _
    lngrow_hlp_data_regr1 & ":" & funstrcol_byname("hlp_data_regr1_col_mbls") & _
    (lngrow_hlp_data_regr1 + lnganzdatensaetze - 1)).Clear
  
  ThisWorkbook.Worksheets(STR_SH_HLP_DATA_REGR2).Range(strcol_hlp_data_regr2 & _
    lngrow_hlp_data_regr2 & ":" & funstrcol_byname("hlp_data_regr2_col_mbls") & _
    (lngrow_hlp_data_regr2 + lnganzdatensaetze - 2)).Clear
  
  
  '--------------------------------------------------------------
  'Formeln fuer Auswertung erzeugen
  
  'Laufnummer -> =data_form!A16
  Call spalten_regr_fuellen("laufnr", "laufnr", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)

  'Filter -> =data_form!U16 bzw =data_form!V16
  Call spalten_regr_fuellen("filter", "filter", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Ausbildungsjahre (nur fuer Berichte noetig)
  Call spalten_regr_fuellen("ausbildung", "ausbildung", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Alter -> =data_head_c_jahr-data_form!B16
  Call spalten_regr_fuellen("gebjahr", "alter", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Ausbildungsjahre -> =VLOOKUP(data_form!H16,hlp_const_lst_ausbja,2,0)
  Call spalten_regr_fuellen("ausbildung", "ausbja", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Dienstjahre -> =data_form!E45
  Call spalten_regr_fuellen("dienstjahre", "dienstja", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Potentielle Berufsjahre berja -> =C6-D6-6
  'Achtung dienstjahre existieren auf data_form nicht
  Call spalten_regr_fuellen("", "berja", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Potentielle Berufsjahre berja2 " '=F6^2/100"
  Call spalten_regr_fuellen("", "berja2", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Geschlecht, d.h. frau_d
  Call spalten_regr_fuellen("geschlecht", "frau_d", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Spalten fuer erweiterte Regression
  'Skill Level, vor 2.5 Anforderungsniveau V2.5
  Call spalten_regr_fuellen("skillcalculated", "anf1_d", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Berufliche Stellung
  Call spalten_regr_fuellen("berstellung", "bst1_d", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  
  'Logarithmierter Lohn lnlohn
  Call spalten_regr_fuellen("bruttolohn", "lnlohn", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Lohn mbls
  Call spalten_regr_fuellen("bruttolohn", "mbls", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
    
  'Lohnprognosen
  Call spalten_regr_fuellen("", "mbls_prog", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Ab 3.1.0 geschlechtsneutrale Lohnprognosen
  Call spalten_regr_fuellen("", "mbls_prog_gn", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Neue Spalten fuer Punktdiagramme
  'mbls_0
  Call spalten_regr_fuellen("bruttolohn", "mbls_0", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'mbls_1
  Call spalten_regr_fuellen("bruttolohn", "mbls_1", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Anforderungsniveau V2.5
  Call spalten_regr_fuellen("skillcalculated", "anf", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Berufliche Stellung
  Call spalten_regr_fuellen("berstellung", "bst", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Im Monatslohn -> ml
  Call spalten_regr_fuellen("bgrad", "ml", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Vollzeit|fffd|quivalente
  Call spalten_regr_fuellen("bgrad", "vollzeit", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  'Standardisierte Lohnbestandteile
  Call spalten_regr_fuellen("bruttolohn_standard", "bruttolohn_standard", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  Call spalten_regr_fuellen("zulagen_standard", "zulagen_standard", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  Call spalten_regr_fuellen("13monatslohn_standard", "13monatslohn_standard", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  Call spalten_regr_fuellen("sonderz_standard", "sonderz_standard", lnganzdatensaetze, lngrow_data_form, _
    lngrow_hlp_data_regr1, lngrow_hlp_data_regr2, objsheet_regr1, objsheet_regr2)
  
  
  '--------------------------------------------------------------
  'Daten auf hlp_data_regr1 und hlp_data_regr2 sortieren
  Application.Calculate
  ThisWorkbook.Names("hlp_data_regr1_col_filter").RefersToRange.Sort _
    Key1:=ThisWorkbook.Names("hlp_data_regr1_col_filter").RefersToRange, _
    Order1:=xlDescending, Header:=xlGuess, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
  
  'regr2 sortieren
  ThisWorkbook.Names("hlp_data_regr2_col_filter").RefersToRange.Sort _
    Key1:=ThisWorkbook.Names("hlp_data_regr2_col_filter").RefersToRange, _
    Order1:=xlDescending, Header:=xlGuess, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
  
  
  '--------------------------------------------------------------
  'Bedingte Formatierung
  Set objrange_regr1_data = ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR1).Range( _
    funstrcol_byname("hlp_data_regr1_sd") & lngrow_hlp_data_regr1 & ":" & _
    funstrcol_byname("hlp_data_regr1_col_mbls_1") & (lngrow_hlp_data_regr1 + lnganzdatensaetze - 1))

  Call regr_bedingteformatierung(objrange_regr1_data, lngrow_hlp_data_regr1, _
    funstrcol_byname("hlp_data_regr1_col_filter"), funstrcol_byname("hlp_data_regr1_col_frau_d"))
  
  'Ab 14.02.2019 neue Spalten
  Set objrange_regr2_data = ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).Range( _
    funstrcol_byname("hlp_data_regr2_sd") & lngrow_hlp_data_regr2 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_sonderz_standard") & (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1))

  Call regr_bedingteformatierung(objrange_regr2_data, lngrow_hlp_data_regr2, _
    funstrcol_byname("hlp_data_regr2_col_filter"), funstrcol_byname("hlp_data_regr2_col_frau_d"))
    
  '--------------------------------------------------------------
  'Gitternetz fuer ganzen Bereich
  Call regr_borderlines(objrange_regr1_data)
  Call regr_borderlines(objrange_regr2_data)
  
  '--------------------------------------------------------------
  'Zahlenformate fuer einzelne Spalten
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR1).Range( _
    funstrcol_byname("hlp_data_regr1_col_berja2") & lngrow_hlp_data_regr1 & ":" & _
    funstrcol_byname("hlp_data_regr1_col_berja2") & _
    (lngrow_hlp_data_regr1 + lnganzdatensaetze - 1)).NumberFormat = "#,##0.00"
    
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR1).Range( _
    funstrcol_byname("hlp_data_regr1_col_lnlohn") & lngrow_hlp_data_regr1 & ":" & _
    funstrcol_byname("hlp_data_regr1_col_lnlohn") & _
    (lngrow_hlp_data_regr1 + lnganzdatensaetze - 1)).NumberFormat = "#,##0.000"
    
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR1).Range( _
    funstrcol_byname("hlp_data_regr1_col_mbls") & lngrow_hlp_data_regr1 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_mbls_1") & _
    (lngrow_hlp_data_regr1 + lnganzdatensaetze - 1)).NumberFormat = "#,##0"
    
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).Range( _
    funstrcol_byname("hlp_data_regr2_col_berja2") & lngrow_hlp_data_regr2 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_berja2") & _
    (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).NumberFormat = "#,##0.00"
    
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).Range( _
    funstrcol_byname("hlp_data_regr2_col_lnlohn") & lngrow_hlp_data_regr2 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_lnlohn") & _
    (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).NumberFormat = "#,##0.000"
    
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).Range( _
    funstrcol_byname("hlp_data_regr2_col_mbls") & lngrow_hlp_data_regr2 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_mbls_1") & _
    (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).NumberFormat = "#,##0"
  
  'Ab 14.02.2019 Vollzeit|fffd|quivalente
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).Range( _
    funstrcol_byname("hlp_data_regr2_col_vollzeit") & lngrow_hlp_data_regr2 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_vollzeit") & _
    (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).NumberFormat = "#,##0.000"
  
  'Ab 14.02.2019 Lohnbestandteile
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).Range( _
    funstrcol_byname("hlp_data_regr2_col_bruttolohn_standard") & lngrow_hlp_data_regr2 & ":" & _
    funstrcol_byname("hlp_data_regr2_col_sonderz_standard") & _
    (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1)).NumberFormat = "#,##0"
  
  '--------------------------------------------------------------
  'letzten gueltigen Datensatz herausfinden und Namen fuer Regression anpassen
  Application.Calculate
  lng_regr1_lastvalidrow = funlnglastvalidrow(STR_SH_HLP_DATA_REGR1, "hlp_data_regr1_col_filter", lnganzdatensaetze)
  lng_regr2_lastvalidrow = funlnglastvalidrow(STR_SH_HLP_DATA_REGR2, "hlp_data_regr2_col_filter", lnganzdatensaetze)
  
  'z.B. call namen_anpassen("data_x_1", "$D$4:$H$20")
  strcol_x_start = funstrcol_byname("hlp_data_regr1_col_ausbja")
  strcol_x_end = funstrcol_byname("hlp_data_regr1_col_frau_d")
  strcol_y = funstrcol_byname("hlp_data_regr1_col_lnlohn")
  
  Call namen_anpassen("data_x_1", "$" & strcol_x_start & "$" & _
    ThisWorkbook.Names("hlp_data_regr1_sd").RefersToRange.Row & ":$" & strcol_x_end & "$" & lng_regr1_lastvalidrow)
  Call namen_anpassen("data_y_1", "$" & strcol_y & "$" & _
    ThisWorkbook.Names("hlp_data_regr1_sd").RefersToRange.Row & ":$" & strcol_y & "$" & lng_regr1_lastvalidrow)
  
  'Namen anpassen fuer die Spalten, die auf rpt-Blaettern verwendet werden
  'Achtung: mbls_prog existiert nur in erweiterter Regression
  For Each varcolbez In Array("ausbildung", "alter", "ausbja", "dienstja", "berja", "berja2", "frau_d", "mbls", "mbls_0", "mbls_1")
    Call namen_anpassen("hlp_data_regr1_vec_" & varcolbez, "$" & _
      funstrcol_byname("hlp_data_regr1_col_" & varcolbez) & "$" & _
      ThisWorkbook.Names("hlp_data_regr1_sd").RefersToRange.Row & ":$" & _
      funstrcol_byname("hlp_data_regr1_col_" & varcolbez) & "$" & lng_regr1_lastvalidrow)
  Next

  'regr2
  strcol_x_start = funstrcol_byname("hlp_data_regr2_col_ausbja")
  strcol_x_end = funstrcol_byname("hlp_data_regr2_col_frau_d")
  'Ab 3.1.0 gibt es noch eine geschlechtsneutrale Regression
  strcol_x3_end = funstrcol_byname("hlp_data_regr2_col_bst5_d")
  strcol_y = funstrcol_byname("hlp_data_regr2_col_lnlohn")
  
  Call namen_anpassen("data_x_2", "$" & strcol_x_start & "$" & _
    ThisWorkbook.Names("hlp_data_regr2_sd").RefersToRange.Row & ":$" & strcol_x_end & "$" & lng_regr2_lastvalidrow)
  'Ab 3.1.0 gibt es noch eine geschlechtsneutrale Regression
  Call namen_anpassen("data_x_3", "$" & strcol_x_start & "$" & _
    ThisWorkbook.Names("hlp_data_regr2_sd").RefersToRange.Row & ":$" & strcol_x3_end & "$" & lng_regr2_lastvalidrow)
  Call namen_anpassen("data_y_2", "$" & strcol_y & "$" & _
    ThisWorkbook.Names("hlp_data_regr2_sd").RefersToRange.Row & ":$" & strcol_y & "$" & lng_regr2_lastvalidrow)
  
   'Namen anpassen fuer die Spalten, die auf rpt-Blaettern verwendet werden
  For Each varcolbez In Array("ausbildung", "alter", "ausbja", "dienstja", "berja", "berja2", "anf1_d", _
    "anf2_d", "anf3_d", "anf4_d", "bst1_d", "bst2_d", "bst3_d", "bst4_d", "bst5_d", "frau_d", "mbls", _
    "mbls_prog", "mbls_prog_gn", "mbls_0", "mbls_1", "anf", "bst", "ml", "vollzeit", _
    "bruttolohn_standard", "zulagen_standard", "13monatslohn_standard", "sonderz_standard")
    Call namen_anpassen("hlp_data_regr2_vec_" & varcolbez, "$" & _
      funstrcol_byname("hlp_data_regr2_col_" & varcolbez) & "$" & _
      ThisWorkbook.Names("hlp_data_regr2_sd").RefersToRange.Row & ":$" & _
      funstrcol_byname("hlp_data_regr2_col_" & varcolbez) & "$" & lng_regr2_lastvalidrow)
  Next
 
  
  'Lohnprognosenformel auf Blatt data_form (basiert auf erweiterter Regression)
  Application.Calculate
  If funblnregr2gueltig() Then
    
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
    
    'Ab V3.2.0 23.07.2019 zuerst Filter zuruecksetzen -> sonst werden Spalten AB bis AE nicht richtig ausgefuellt
    If ThisWorkbook.Sheets(STR_SH_DATA_FORM).FilterMode Then
      ThisWorkbook.Sheets(STR_SH_DATA_FORM).ShowAllData
    End If
  
    'einblenden nur fuer Tests
    'Call blaetter_einblenden_praefix(STR_SH_HLP_DATA_REGR2)
    lng_data_form_lastrow = lngrow_data_form + lnganzdatensaetze - 1
    
    'Achtung: In diesen Formeln englischen Funktionsnamen und , verwenden!!!
    
    'Logib 3.1.0 Berechneter geschlechtsneutraler Gesamtverdienst, Filter <> 1 ausgenommen
    '=IF(AA14=1,INDIRECT("hlp_data_regr2!W"&MATCH(A14,hlp_data_regr2!B$1:B$148,0)),"")
    strdataformformel = "=IF(" & funstrcol_byname("data_form_col_filter_erw") & _
      lngrow_data_form & "=1,INDIRECT(""" & STR_SH_HLP_DATA_REGR2 & "!" & _
      funstrcol_byname("hlp_data_regr2_col_mbls_prog_gn") & """&MATCH(" & _
      funstrcol_byname("data_form_col_laufnr") & lngrow_data_form & "," & _
      STR_SH_HLP_DATA_REGR2 & "!" & _
      funstrcol_byname("hlp_data_regr2_col_laufnr") & "$1:" & _
      funstrcol_byname("hlp_data_regr2_col_laufnr") & "$" & (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1) & ",0)),"""")"
    
    Application.EnableEvents = False
    With ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
      funstrcol_byname("data_form_col_mbls_prog_gn") & lngrow_data_form & ":" & _
      funstrcol_byname("data_form_col_mbls_prog_gn") & (lng_data_form_lastrow))
      .Value = strdataformformel
      
      'Tausendertrennzeichen fuer prognostizierten Lohn
      .NumberFormat = "#,##0"
    End With
    
    'Logib 3.1.0 Spalte Unwahrscheinlich geschlechtsneutral, Filter <> 1 ausgenommen
    'Formel am 20.10.2010 umgedreht, neu "Abweichung effektiv von berechnet"
    '=IF(AA14=1,Z14/AB14-1,"")
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
      funstrcol_byname("data_form_col_filterunwahrsch_gn") & lngrow_data_form & ":" & _
      funstrcol_byname("data_form_col_filterunwahrsch_gn") & (lng_data_form_lastrow)).Value = _
      "=IF(" & funstrcol_byname("data_form_col_filter_erw") & _
      lngrow_data_form & "=1," & funstrcol_byname("data_form_col_gesverdienst") & lngrow_data_form & "/" & _
      funstrcol_byname("data_form_col_mbls_prog_gn") & lngrow_data_form & "-1,"""")"
    Application.EnableEvents = True
      
    'Notwendig wegen Select spaeter
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Activate
      
    'Zahlenformat und bedingte Formatierung fuer Spalte data_form_col_filterunwahrsch
    With ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
      funstrcol_byname("data_form_col_filterunwahrsch_gn") & lngrow_data_form & ":" & _
      funstrcol_byname("data_form_col_filterunwahrsch_gn") & lng_data_form_lastrow)
      
      .Select
      .FormatConditions.delete
      
      'Erste Regel "" nicht formatieren
      .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="="""""
      .FormatConditions(.FormatConditions.Count).Interior.Pattern = xlNone
      .FormatConditions(.FormatConditions.Count).Interior.TintAndShade = 0
      
      'Zweite Regel hohe Abweichungen hervorheben
      .FormatConditions.Add Type:=xlCellValue, Operator:=xlNotBetween, _
          Formula1:="-" & funvarvalue_byname("hlp_const_c_limite_prog"), Formula2:=funvarvalue_byname("hlp_const_c_limite_prog")
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_blank")
      .NumberFormat = "0.0%"
    End With
     
    'Achtung: In diesen Formeln englischen Funktionsnamen und , verwenden!!!
    'Berechneter Gesamtverdienst data_form_col_mbls_prog, Filter <> 1 ausgenommen
    strdataformformel = "=IF(" & funstrcol_byname("data_form_col_filter_erw") & _
      lngrow_data_form & "=1,INDIRECT(""" & STR_SH_HLP_DATA_REGR2 & "!" & _
        funstrcol_byname("hlp_data_regr2_col_mbls_prog") & """&MATCH(" & _
        funstrcol_byname("data_form_col_laufnr") & lngrow_data_form & "," & _
        STR_SH_HLP_DATA_REGR2 & "!" & _
        funstrcol_byname("hlp_data_regr2_col_laufnr") & "$1:" & _
        funstrcol_byname("hlp_data_regr2_col_laufnr") & "$" & (lngrow_hlp_data_regr2 + lnganzdatensaetze - 1) & ",0)),"""")"
    
    Application.EnableEvents = False
    With ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
      funstrcol_byname("data_form_col_mbls_prog") & lngrow_data_form & ":" & _
      funstrcol_byname("data_form_col_mbls_prog") & (lng_data_form_lastrow))
      .Value = strdataformformel
      
      'Tausendertrennzeichen fuer prognostizierten Lohn
      .NumberFormat = "#,##0"
    End With
    

    'Spalte Unwahrscheinlich
    'Formel am 20.10.2010 umgedreht, neu "Abweichung effektiv von berechnet"
    '=IF(AA14=1,Z14/AD14-1,"")
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
      funstrcol_byname("data_form_col_filterunwahrsch") & lngrow_data_form & ":" & _
      funstrcol_byname("data_form_col_filterunwahrsch") & (lng_data_form_lastrow)).Value = _
      "=IF(" & funstrcol_byname("data_form_col_filter_erw") & _
      lngrow_data_form & "=1," & funstrcol_byname("data_form_col_gesverdienst") & lngrow_data_form & "/" & _
      funstrcol_byname("data_form_col_mbls_prog") & lngrow_data_form & "-1,"""")"
    Application.EnableEvents = True
      
    'Notwendig wegen Select spaeter
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Activate
      
    'Zahlenformat und bedingte Formatierung fuer Spalte data_form_col_filterunwahrsch
    With ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
      funstrcol_byname("data_form_col_filterunwahrsch") & lngrow_data_form & ":" & _
      funstrcol_byname("data_form_col_filterunwahrsch") & lng_data_form_lastrow)
      
      .Select
      .FormatConditions.delete
      
      'Erste Regel "" nicht formatieren
      .FormatConditions.Add Type:=xlCellValue, Operator:=xlEqual, Formula1:="="""""
      .FormatConditions(.FormatConditions.Count).Interior.Pattern = xlNone
      .FormatConditions(.FormatConditions.Count).Interior.TintAndShade = 0
      
      'Zweite Regel hohe Abweichungen hervorheben
      .FormatConditions.Add Type:=xlCellValue, Operator:=xlNotBetween, _
          Formula1:="-" & funvarvalue_byname("hlp_const_c_limite_prog"), Formula2:=funvarvalue_byname("hlp_const_c_limite_prog")
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_blank")
      .NumberFormat = "0.0%"
    End With
  
     
    Call protectSheet(STR_SH_DATA_FORM, True)
  End If
  
  '--------------------------------------------------------------
  'Auswertung und Regressionsblaetter einblenden
  Call blatt_einblenden(STR_SH_SUMMARY, changeToNumberString("m"), True)
  Call blatt_einblenden(STR_SH_COCKPIT, changeToNumberString("m"), True)

  Call blaetter_einblenden_praefix("rpt_fazit")
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Unprotect Password:=changeToNumberString("s")
  'ThisWorkbook.Worksheets(STR_SH_SUMMARY).Unprotect Password:=changeToNumberString("s")
  'ThisWorkbook.Worksheets(STR_SH_COCKPIT).Unprotect Password:=changeToNumberString("s")
  
  Application.Calculate
  
  'Wann werden Auswertungsblaetter zu welcher Regression eingeblendet
  blnregr2einblenden = False
  
  'Nur einblenden, wenn erweiterte Regression gueltig ist
  If funblnregr2gueltig() Then
    blnregr2einblenden = True
  End If
  
  'Basisregression ausgeblendet
  Call showhidecolbasisregression(True)
  
  If blnregr2einblenden Then
    Call blaetter_einblenden_praefix("rpt_regr2")
    'Links einblenden
    Call rpt_fazit_links_erw_sethidden(False)
  Else
    'Links ausblenden
    Call rpt_fazit_links_erw_sethidden(True)
  End If
  
  'Neu werden Blatt rpt_regr2_6 und rpt_regr2_6 auch bei kollinearen Spalten eingeblendet
  Call blaetter_einblenden_praefix("rpt_regr2_6")
  Call blaetter_einblenden_praefix("rpt_regr2_7")
  'Links einblenden
  Call rpt_fazit_links_nurerw_sethidden(False)

  
  'Gemaess Besprechung mit Silvia Strub am 8.9.2005
  'Anzeige dieser Blaetter ueberfordert Laien
  'Call blaetter_einblenden_praefix("hlp_data")
  'Call blaetter_einblenden_praefix("hlp_regr")
 
  'Zelle hlp_const_c_ausgewertet auf True setzen
  ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value = True
  'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
  blnausgewertet = True
  ThisWorkbook.Names("hlp_const_c_auswertversion").RefersToRange.Value = Application.Version
  
  'Achse fuer Diagramm setzen (Achtung, das Diagramm ist ausgeblendet)
  Application.Calculate
  
  If IsNumeric(funvarvalue_byname("rpt_rgr2_1_c_minachse")) Then
    ThisWorkbook.Worksheets(STR_SH_RPT_REGR2_1).Unprotect Password:=changeToNumberString("s")
    ThisWorkbook.Sheets(STR_SH_RPT_REGR2_1).ChartObjects(1).Chart.Axes(xlValue).MinimumScale = _
      funvarvalue_byname("rpt_rgr2_1_c_minachse")
    Call protectSheet(STR_SH_RPT_REGR2_1, True)
  End If
  
  'SR ab 29.10.2015 Achsen zuruecksetzen
  Call togglechartaxes
  
  'nach Auswertung ausgeblendete Buttons wieder einblenden
  Call togglebuttonsauswertung
  
  'Formeln auf rpt_fazit fuer gewisse Zellen werden sonst aus unbekannten Gruenden nicht aktualisiert
  ThisWorkbook.Names("rpt_fazit_c_titeltabellen").RefersToRange.Formula = _
    ThisWorkbook.Names("rpt_fazit_c_titeltabellen").RefersToRange.Formula
  ThisWorkbook.Names("rpt_fazit_c_regr1gueltig").RefersToRange.Formula = _
    ThisWorkbook.Names("rpt_fazit_c_regr1gueltig").RefersToRange.Formula
  ThisWorkbook.Names("rpt_fazit_c_regr2gueltig").RefersToRange.Formula = _
    ThisWorkbook.Names("rpt_fazit_c_regr2gueltig").RefersToRange.Formula

  'Berechnung zuruecksetzen
  Call berechnung_einschalten
  Application.Calculate
  
  'Druckbereich auf setzen
  Call druckbereich_hlp_data
  
  'Uebersetzungen fuer Trendlinien, die vorher nicht existieren
  Call translatecontrolsoptional
  
  'data_head sperren
  ThisWorkbook.Worksheets(STR_SH_DATA_HEAD).Unprotect Password:=changeToNumberString("s")
  Call toggleLockInNamedRange("data_head_cells_entry", True)
  
  'data_form sperren
  ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD & ":" & funstrcol_byname("data_form_col_anfniveau") & lngRowLast & "," _
    & funstrcol_byname("data_form_col_berstellung") & lngRowFirst & ":" _
    & funstrcol_byname("data_form_col_grundgesamtheit") & lngRowLast).Locked = True
  
  'joblist sperren
  ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")
  Call toggleLockInNamedRange("joblist_lst", True)
  
  'Blattschutz einschalten fuer sichtbare Blaetter
  Call blattschutz_ein
  'Blattschutz einschalten fuer unsichtbare Blaetter
  Call blattschutz_ein_drawing_and_hidden(STR_SH_HLP_DATA_REGR1, True, True)
  Call blattschutz_ein_drawing_and_hidden(STR_SH_HLP_DATA_REGR2, True, True)
  
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Select
  
  'Arbeitsmappe schuetzen
  Call mappenschutz_ein 'arbeitsmappenschutz_einschalten
    
  'Automatisches Speichern %%%% SR 24.03.2019 hier passiert Fehler
  'On Error Resume Next
  'Application.DisplayAlerts = False
  ThisWorkbook.Save

  'Bildschirmanzeige wieder aktivieren
  Application.ScreenUpdating = True

  'Fortschrittsanzeige
  frmfortschrittsanzeige.lblerklaerung = strtranslate("frmfortschrittsanzeige.lblerkauswertungend")
  frmfortschrittsanzeige.lbllauftext = ""
  frmfortschrittsanzeige.btnok.Visible = True
  If Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.Show
    'Mac -> kein vbModeless -> StatusBar zuruecksetzen
    Call updatestatusbar_mac("")
  Else
    frmfortschrittsanzeige.Repaint
  End If
  Application.Calculate
  
  'Debug.Print Timer & ": auswerten beendet"

  Exit Sub
  
fehler:
  Resume Next
  Application.EnableEvents = True
  Application.ScreenUpdating = True
  Call senderrormail(straktiveprozedur)
End Sub


'*******************************************************************
'Loescht bei Ueberarbeitung des data_sheet die Auswertungen
Sub data_sheet_update()
  Call updateActiveProc("Auswertung.data_sheet_update")
  'Debug.Print "data_sheet_update gestartet"
  
  Dim lnglastexistingrow As Long
  
  'Das scheint nicht zu funktionieren, wenn aus Ereignisprozedur aufgerufen
  'Call berechnung_ausschalten
  'Application.ScreenUpdating = False
  
  'Beim naechsten Befehl wurde Fehler ausgeloest, aber nur, wenn Geschlecht oder Geburtsjahr geaendert wird
  '-> September 2005 Workaround: Nach Auswertung wird Berechnungsmodus nicht mehr gesetzt
  'Debug.Print "Application.Calculation = xlCalculationManual: " & (Application.Calculation = xlCalculationManual)
  Call rpt_blaetter_ausblenden
  
  'Debug.Print "Fehler? " & Err.Number
  Call blatt_einblenden(STR_SH_HLP_CONST, changeToNumberString("m"), True)

  'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
  blnausgewertet = False
  'Bei diesem Befehl passiert Fehler %%%
  ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Formula = False
  Call blatt_ausblenden(STR_SH_HLP_CONST, changeToNumberString("m"))

  lnglastexistingrow = funlnglastexistingrow
  Call blattschutz_aus
  Call range_allesloeschen(STR_SH_HLP_DATA_REGR1, funstraddr_byname("hlp_data_regr1_sd"), _
    funstrcol_byname("hlp_data_regr1_col_mbls_1") & lnglastexistingrow, True)
  Call range_allesloeschen(STR_SH_HLP_DATA_REGR2, funstraddr_byname("hlp_data_regr2_sd"), _
    funstrcol_byname("hlp_data_regr2_col_bst") & lnglastexistingrow, True)
  
  Call range_allesloeschen(STR_SH_DATA_FORM, _
    funstrcol_byname("data_form_col_mbls_prog") & Mid(STR_DATA_FORM_SD, 2), _
    funstrcol_byname("data_form_col_filterunwahrsch") & lnglastexistingrow, True)
  
  'schuetzt nur sichtbare Blaetter
  Call blattschutz_ein
  'Call hilfsblaetter_ausblenden
  Call berechnung_einschalten
  'ThisWorkbook.Sheets(STR_SH_INTRO).Activate
  Application.ScreenUpdating = True
  'debug.print straktiveprozedur & " abgeschlossen"

End Sub


'*******************************************************************
'Setzt den Druckbereich fuer die Blaetter hlp_data_regr1 und 2
Sub druckbereich_hlp_data()
  Dim lnglastrow As Long
  'Blatt 1
  lnglastrow = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_HLP_DATA_REGR1, funstrcol_byname("hlp_data_regr1_col_laufnr"))
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR1).PageSetup.PrintArea = "$B$1:$N$" & lnglastrow
  
  'Blatt 2
  lnglastrow = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_HLP_DATA_REGR2, funstrcol_byname("hlp_data_regr2_col_laufnr"))
  ThisWorkbook.Sheets(STR_SH_HLP_DATA_REGR2).PageSetup.PrintArea = "$B$1:$AC$" & lnglastrow

End Sub


'*******************************************************************
'von togglechartaxes mehrfach aufgerufen, um Achse und Button zu aendern
Sub setchartaxesandbtn(ByVal strSheetName As String, ByVal blnbtnvisible As Boolean, _
  ByVal strbtntext As String, ByVal lngmaximumscale As Long)
  
  'Button setzen
  ThisWorkbook.Sheets(strSheetName).Shapes("btntogglechartaxes").Visible = True
  'Logib 3.1.1 23.03.2018 keine Shapes in Excel 2016
  ThisWorkbook.Sheets(strSheetName).Buttons("btntogglechartaxes").Caption = strbtntext
'  ThisWorkbook.Sheets(strSheetName).Shapes("btntogglechartaxes").TextFrame _
'    .Characters.Text = strbtntext
  ThisWorkbook.Sheets(strSheetName).Shapes("btntogglechartaxes").Visible = blnbtnvisible
  
  'Achsen setzen
  ThisWorkbook.Sheets(strSheetName).ChartObjects("chartlohnprog").Chart.Axes(xlValue).maximumscale = lngmaximumscale
  ThisWorkbook.Sheets(strSheetName).ChartObjects("chartlohnprog").Chart.Axes(xlCategory).maximumscale = lngmaximumscale

End Sub

'*******************************************************************
'Skaliert die Achsen von rpt_regr2_1 wegen Loehnen ueber 25000
'Faelle
'0) data_form_c_maxsalaryaxes = 0 (keine Daten vorhanden)
'   -> Achse = hlp_const_c_maxsalaryaxes_limited
'   -> Button nicht sichtbar
'1) data_form_c_maxsalaryaxes <= 25000
'   -> Achsen immer data_form_c_maxsalaryaxes
'   -> Button nicht sichtbar
'2) data_form_c_maxsalaryaxes > 25000, Achse = data_form_c_maxsalaryaxes
'   -> Button mit "Nur Loehne bis 25'000 anzeigen" beschriftet
'   -> Klick auf Button
'      + Text wechselt
'      + Achsen auf hlp_const_c_maxsalaryaxes_limited setzen
'3) data_form_c_maxsalaryaxes > 25000, Achse = hlp_const_c_maxsalaryaxes_limited
'   -> Button mit "Alle Loehne anzeigen" beschriftet
'   -> Klick auf Button
'      + Text wechselt
'      + Achsen auf data_form_c_maxsalaryaxes setzen
'Aufrufe
'- beim Ausfuehren der Auswertung
'- beim Klick auf Button
'- beim Zuruecksetzen der Daten
'Achtung bei Sprachwechsel
Sub togglechartaxes()
  Call updateActiveProc("togglechartaxes")
  
  Dim blnbtnvisible As Boolean
  Dim strbtntextalle, strbtntextlimite As String
  Dim lngmaximumscale, lngmaximumscalelimited, lngmaximumscalebefore As Long
  Dim strSheetName As String
  strSheetName = STR_SH_RPT_REGR & "2_1"
  
  'Schutz wird am Schluss nur gesetzt, wenn er schon vorhanden war
  Dim blnProtected As Boolean
  blnProtected = ThisWorkbook.Sheets(strSheetName).ProtectContents
  
  If blnProtected Then
    ThisWorkbook.Worksheets(strSheetName).Unprotect Password:=changeToNumberString("s")
  End If
  
  'Werte fuer Achsen-Skalierung aus Zellen holen
  lngmaximumscale = funvarvalue_byname("data_form_c_maxsalaryaxes")
  lngmaximumscalelimited = funvarvalue_byname("hlp_const_c_maxsalaryaxes_limited")
  
  blnbtnvisible = True
  strbtntextlimite = Replace(strtranslate(strSheetName & ".btntogglechartaxes.bis"), _
    "|hlp_const_c_maxsalaryaxes_limited|", Format(lngmaximumscalelimited, "#,##0"))
  strbtntextalle = strtranslate(strSheetName & ".btntogglechartaxes.alle")
  
  'aktuellen Achsenwert holen
  lngmaximumscalebefore = ThisWorkbook.Sheets(strSheetName).ChartObjects("chartlohnprog").Chart.Axes(xlValue).maximumscale
  
  'Noch keine Werte vorhanden -> Achse auf Limite, Button "Alle..."
  If lngmaximumscale <= 0 Then
    Call setchartaxesandbtn(strSheetName, False, strbtntextalle, lngmaximumscalelimited)
  'Maximallohn liegt unter Limite -> Achse auf Maximallohn, Button ausblenden
  ElseIf lngmaximumscale <= lngmaximumscalelimited Then
    Call setchartaxesandbtn(strSheetName, False, strbtntextalle, lngmaximumscale)
  'Achsenwert = Limite
  ElseIf lngmaximumscalebefore = lngmaximumscalelimited Then
    Call setchartaxesandbtn(strSheetName, True, strbtntextlimite, lngmaximumscale)
  Else
    Call setchartaxesandbtn(strSheetName, True, strbtntextalle, lngmaximumscalelimited)
  End If
  
  Call protectSheet(strSheetName, blnProtected)
End Sub

Attribute VB_Name = "ByName"
Option Explicit
Option Private Module

'===================================================================
'Prozeduren, die Daten mit Hilfe von Namen aus Mappen und Blaettern lesen
'  oder sonstige Verarbeitungen aufgrund von Namen vornehmen


'*******************************************************************
'Funktionen und Prozeduren, die ganz bestimmte Werte auslesen


'*******************************************************************
'Liest die Anzahl Wochenstunden aus Daten ein
Function funsngwochenstunden() As Single
  funsngwochenstunden = ThisWorkbook.Names("data_head_c_buwaz").RefersToRange.Value
End Function


'*******************************************************************
'Liest die Anzahl Mitarbeiter ein -> gibt bei falschen Angaben 0 aus
Function funanzmitarb() As Long
  Dim varanzmitarb As Variant
  Dim lnganzmitarb As Long
  
  lnganzmitarb = 0
  varanzmitarb = ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value
  If IsNumeric(varanzmitarb) Then
    If varanzmitarb > 0 Then
      'Int(..) liefert auch Long zurueck
      lnganzmitarb = Int(varanzmitarb)
    End If
  End If
  funanzmitarb = lnganzmitarb
End Function



'*******************************************************************
'Funktionen und Prozeduren, die allgemeine Werte auslesen


'*******************************************************************
'Existiert ein Name im Workbook
Function funblnexistsname(ByVal strName As String)
  On Error Resume Next
  Dim strNamesName As String
  
  strNamesName = ThisWorkbook.Names(strName).name
  If strNamesName = "" Then
    err.Clear
    funblnexistsname = False
    Exit Function
  End If
  funblnexistsname = True

End Function

'*******************************************************************
'Existiert ein Name in ThisWorkbook und definiert er einen gueltigen Range
Function funIsNameARange(ByVal strName As String)
  Dim result As Boolean
  Dim objRange As Range
  Dim strNamesName As String
  result = True
  On Error Resume Next
  
  'pruefen, ob Name existiert
  strNamesName = ThisWorkbook.Names(strName).name
  If strNamesName = "" Then
    result = False
    err.Clear
  Else
    'pruefen, ob es einen gueltigen Range gibt
    Set objRange = ThisWorkbook.Names(strName).RefersToRange
    If objRange Is Nothing Then
      result = False
      err.Clear
      'Debug.Print err.Description
    End If
  End If
  funIsNameARange = result
End Function

'*******************************************************************
'Gibt den Wert der ersten Zelle eines benannten Bereiches aus
Function funvarvalue_byname(ByVal strName As String) As Variant
  funvarvalue_byname = ThisWorkbook.Names(strName).RefersToRange.Range("A1").Value
End Function


'*******************************************************************
'Gibt die relative Adresse der ersten Zelle eines benannten Ranges an in Form "C4"
Function funstraddr_byname(ByVal strName As String) As String
  If funblnexistsname(strName) Then
    funstraddr_byname = ThisWorkbook.Names(strName).RefersToRange.Range("A1").Address(False, False)
  Else
    funstraddr_byname = ""
  End If
End Function

'*******************************************************************
'Gibt den Namen einer benannten Zelle an
Function funstrname_bycolumn(ByVal strSheetName As String, ByVal lngRow As Long, ByVal lngCol As Long) As String
  On Error Resume Next
  Dim result As String
  result = ""
  result = ThisWorkbook.Sheets(strSheetName).Cells(lngRow, lngCol).name.name
  funstrname_bycolumn = result
End Function

'*******************************************************************
'Gibt die Buchstabenbezeichnung der ersten Spalte eines benannten Ranges an
'Falls Bereich statt Zelle, dann wird erste Zelle oben links genommen
Function funstrcol_byname(ByVal strName As String) As String
  On Error Resume Next
  Dim lngCol As Long
  If ThisWorkbook.Names(strName).RefersToRange.Cells.Count = 1 Then
    lngCol = ThisWorkbook.Names(strName).RefersToRange.Column
  Else
    lngCol = ThisWorkbook.Names(strName).RefersToRange.Range("A1").Column
  End If
  If err.Number > 0 Then
    Debug.Print err.Number & " " & err.Description & ": Name " & strName & " in ByName.funstrcol_byname"
    err.Clear
    Exit Function
  End If
  
  funstrcol_byname = Left(Cells(1, lngCol).Address(True, False), InStr(Cells(1, lngCol).Address(True, False), "$") - 1)
End Function


'*******************************************************************
'Gibt die Buchstabenbezeichnung der ersten Spalte eines Ranges an
Function funstrfirstcol_byrange(ByVal objRange As Range) As String
  On Error Resume Next
  
  Dim result As String
  result = ""
  'versuchen, ob mehrere Zellen enthalten
  result = Split(objRange.Address, "$")(1)
  funstrfirstcol_byrange = result
End Function


'*******************************************************************
'Gibt die Buchstabenbezeichnung der letzten Spalte eines Ranges an
Function funstrlastcol_byrange(ByVal objRange As Range) As String
  On Error Resume Next
  
  Dim result As String
  result = ""
  'versuchen, ob mehrere Zellen enthalten
  result = Split(objRange.Address, "$")(3)
  If result = "" Then
    result = Split(objRange.Address, "$")(1)
  End If
  funstrlastcol_byrange = result
End Function


'*******************************************************************
'Hilfsroutine, die aus Zahl einen Zeilenbezug wie 25:25 macht
'neu ab 06.11.2014
Function rowstring(ByVal rownum As Integer)
  rowstring = "" & rownum & ":" & rownum
End Function


'*******************************************************************
'Versteckt die Zeilen mit Links auf rpt_fazit_erw oder zeigt sie wieder an
'Ab 06.11.2014 robust gegenueber oberhalb eingefuegten Zeilen und Blattschutz
Sub rpt_fazit_links_erw_sethidden(ByVal blnhidden)
  Dim start As Integer
  start = ThisWorkbook.Names("rpt_fazit_c_titeltabellen").RefersToRange.Row
  
  Dim blnProtected As Boolean
  blnProtected = ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Unprotect Password:=changeToNumberString("s")
  
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 1)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 2)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 3)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 4)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 5)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 6)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 7)).EntireRow.Hidden = blnhidden

  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(STR_SH_RPT_FAZIT, blnProtected)
End Sub


'*******************************************************************
'Versteckt die Zeilen mit Links auf rpt_fazit_erw oder zeigt sie wieder an fuer
' - rpt_regr2_6
' - rpt_regr2_7
' werden trotz kollinearen Spalten angezeigt
'Ab 06.11.2014 robust gegenueber oberhalb eingefuegten Zeilen und Blattschutz
Sub rpt_fazit_links_nurerw_sethidden(ByVal blnhidden)
  Dim start As Integer
  start = ThisWorkbook.Names("rpt_fazit_c_titeltabellen").RefersToRange.Row
  Dim blnProtected As Boolean
  blnProtected = ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Unprotect Password:=changeToNumberString("s")
  
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 6)).EntireRow.Hidden = blnhidden
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Rows(rowstring(start + 7)).EntireRow.Hidden = blnhidden
  
  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(STR_SH_RPT_FAZIT, blnProtected)
End Sub



'*******************************************************************
'Versteckt die Zeilen eines benannten Bereiches oder zeigt sie wieder an
'Besonderheit: funktioniert auch mit nichtzusammenhaengenden Bereichen, aber nur mit absoluten Bezuegen
'Achtung laeuft nur mit Fehlern
Sub hideorshowrows_byname(ByVal strName As String, ByVal blnhidden As Boolean)
  Dim arr
  Dim strSheet As String
  
  'Achtung: Die Methode mit Parent geht nicht fuer nichtzusammenhaengende Ranges!
  arr = Split(ThisWorkbook.Names(strName).RefersTo, ",")
  strSheet = Mid(ThisWorkbook.Names(strName).RefersTo, 2, InStr(ThisWorkbook.Names(strName).RefersTo, "!") - 2)
  If ThisWorkbook.Names(strName).RefersToRange.EntireRow.Hidden <> blnhidden Then
    ThisWorkbook.Worksheets(strSheet).Range( _
      ThisWorkbook.Names(strName).RefersTo).EntireRow.Hidden = blnhidden
  End If
End Sub



'*******************************************************************
'Funktionen, die aus einem Bereich erste und letzte Zeile oder Spalte auslesen
'Achtung: Funktioniert nicht mit Mehrfachmarkierungen


'*******************************************************************
'Gibt Zeilennummer der ersten Zeile in Bereich aus
Function FirstRowInRange(ByVal objRange As Range)
  FirstRowInRange = objRange.Cells(1).Row
End Function


'*******************************************************************
'Gibt Spaltennummer der ersten Spalte in Bereich aus
Function FirstColumnInRange(ByVal objRange As Range)
  FirstColumnInRange = objRange.Cells(1).Column
End Function


'*******************************************************************
'Gibt Zeilennummer der letzten Zeile in Bereich aus
Function LastRowInRange(ByVal objRange As Range)
  LastRowInRange = objRange.Cells(objRange.Count).Row
End Function


'*******************************************************************
'Gibt Spaltennummer der letzten Spalte in Bereich aus
Function LastColumnInRange(ByVal objRange As Range)
  LastColumnInRange = objRange.Cells(objRange.Count).Column
End Function




Attribute VB_Name = "ConstVarPublic"
Option Explicit

'===================================================================
'Oeffentliche Konstanten und Variablen sowie Makros fuer User

'*******************************************************************
' Konstanten

'Zur Unterdrueckung von debug.print
Public Const ISTEST As Boolean = False

'Sheets
Public Const STR_SH_DATA_FORM As String = "data_form"
Public Const STR_SH_DATA_HEAD As String = "data_head"
Public Const STR_SH_JOBLIST As String = "joblist"
Public Const STR_SH_INTRO As String = "intro"
Public Const STR_SH_TRANSLAT As String = "hlp_translations"
Public Const STR_SH_HLP_CONST = "hlp_const"
Public Const STR_SH_HLP_DATA_REGR1 = "hlp_data_regr1"
Public Const STR_SH_HLP_DATA_REGR2 = "hlp_data_regr2"
Public Const STR_SH_HLP_LSE = "hlp_lse"
Public Const STR_SH_HLP_REGR1 = "hlp_regr1"
Public Const STR_SH_HLP_REGR2 = "hlp_regr2"
Public Const STR_SH_LICENSE = "license"
Public Const STR_SH_RPT_FAZIT = "rpt_fazit"
Public Const STR_SH_RPT_REGR2_1 = "rpt_regr2_1"
Public Const STR_SH_RPT_REGR = "rpt_regr"
Public Const STR_SH_TITLE As String = "title"
Public Const STR_SH_HLP_EXPORT = "hlp_export" 'ab V3 2016 nur noch 1 Exportblatt
Public Const STR_SH_HLP_EXPORT_LOGOS = "hlp_export_logos" 'ab V3 2016 nur noch 1 Exportblatt
Public Const STR_SH_COCKPIT = "cockpit"
Public Const STR_SH_SUMMARY = "summary"
Public Const STR_SH_HLP_SUMMARY_COCKPIT = "hlp_summary_cockpit"

'Namen
Public Const STR_NA_CELSPRACHCOL As String = "hlp_translations_c_sprachspalte"
Public Const STR_NA_LSE As String = "hlp_lse_lst_lse"
Public Const STR_NA_RANTRANSLAT As String = "hlp_translations_lst_trans"

'Datenbereiche
'Achtung: Normalerweise mit benannten Bereichen arbeiten,
'weil automatisch angepasst bei eingefuegten Zeilen/Spalten
'Fuer die folgenden Zellen aus Performancegruenden verzichtet
Public Const STR_TRANSLATIONS_SD As String = "A6" 'Start des Datenbereichs auf hlp_translations ohne Kopfzeile
Public Const STR_DATA_FORM_SD As String = "A14" 'Start des Datenbereichs auf data_form ohne Kopfzeile
Public Const STR_HLP_EXPORT_CD As String = "B38" 'Start des Zielbereiches zum Kopieren der Formel, d.h. ab 2. Zeile
Public Const STR_HLP_EXPORT_CD_VORVERSION As String = "B37" 'Vor Version 3.1.0
Public Const STR_RPT_FAZIT_COLADDR = "C:D" 'ein- und ausblendbare Spalten der Basisregression
Public Const STR_IMPORT_KONTROLLFORM_ANZCOLS = 0 'Anzahl zusaetzliche Spalten im Kontrollformular
Public Const STR_IMPORT_COLBEFORECALC = "G"
Public Const STR_EXPORT_JOBLIST_START_HEADER = "A3"
Public Const STR_EXPORT_JOBLIST_START_LIST = "A7"
Public Const STR_EXPORT_JOBLIST_START_LIST_VORVERSION = "A3"
'Werte
Public Const INT_ZUSATZSPALTEN As Integer = 8 'Ab 3.1.0 ohne graue Spalten data_form_col_skilllist, data_form_col_skillcalculated und ab data_form_col_gesverdienst
Public Const INT_SPALTENDIFF_VORVERSION = -5
Public Const INT_MARGE As Integer = 0 'Anzahl Datensaetze ueber der eingegebenen Anzahl MitarbeiterInnen
Public Const STR_PW_MAPPENSCHUTZ = "loh2005ebg" 'zum Ein- und ausblenden der Blaetter
Public Const STR_PW_BLATTSCHUTZ = "20loh05ebg" 'zum Ein- und ausblenden der Blaetter
Public Const STR_JOBLIST_CHAR = "x"

'Technische Werte, z.B. Maximallaengen fuer Inputtexte bei Gueltigkeitspruefungen
Public Const BYT_MAXLENGTH_TITLE = 32
Public Const BYT_MAXLENGTH_INPMSG = 254
Public Const BYT_MAXLENGTH_ERRMSG = 220
Public Const INT_MAX_ANZAHL_ROWS = 1048576

'Import LSE 2004 etc -> in Blatt hlp_lse ausgelagert

Public Const STR_MAILSUPPORT = "lohntool@bluewin.ch"

'Man kann ab 11.11.2014 umschalten ob bedingte Formatierung aus Formel oder aus benutzerdefinierter Funktion stammt
Public Const BLN_FORMATCONDITIONS_FORMULA As Boolean = True


'*******************************************************************
' Variablen
Public blnImportabbruch As Boolean 'Wurde der Import aus Datei abgebrochen?
Public straktiveprozedur As String 'Namen der im Fehlerfall aktiven Prozedur oder Funktion
Public strprozedurstack As String
'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
Public blnausgewertet As Boolean 'Damit Meldung nur einmal kommt


'*******************************************************************
'Mail, das mit Tastenkombination oder mit Schaltflaeche auf Fazit geschickt werden kann
'Muss in Modul stehen, dass nicht "Option private" hat
Public Sub supportmail()
Attribute supportmail.VB_Description = "creates mail to the development team with important configuration data for support cases, the mail is not automatically sent!"
Attribute supportmail.VB_ProcData.VB_Invoke_Func = "m\n14"
  If Not ISTEST Then
    On Error GoTo fehler
  End If

  Call updateActiveProc("ConstVarPublic.prototypmail")
  
  Dim objOutlook
  Dim objMail 'As MailItem
  Dim strtxt As String
  
  If Not Application.OperatingSystem Like "*Mac*" Then
    
    strtxt = strtranslate("msgbox_supportmail")
      
    If MsgBox(strtxt, vbOKCancel) <> vbOK Then
      Exit Sub
    End If
    
    Set objOutlook = CreateObject("Outlook.Application")
    Set objMail = objOutlook.CreateItem(0)
    
    With objMail
        .To = STR_MAILSUPPORT
        .Subject = strtranslate("supportmail_subject")
        .Body = strtranslate("supportmail_subject") & vbCrLf & funstrgenerell() & _
          funstrlanguageversions() & funstrexcel() & funstrdata() _
          & vbCrLf '& vbCrLf & "Stack" & vbCrLf & "-----" & vbCrLf & strprozedurstack
        .display
    End With
    
    Set objMail = Nothing
    Set objOutlook = Nothing
  Else
    Call MsgBox(strtranslate("supportmail_mac"), vbOKCancel)
  End If

  Exit Sub
  
fehler:
    Call MsgBox(strtranslate("supportmail_mac"), vbOKCancel)
End Sub



'*******************************************************************
'Screen, Berechnung und Events wiederherstellen (bei Abbruechen)
'Das Gegenstueck silentCode ist im Modul Entwicklung, da nicht oeffentlich
Sub restore()
Attribute restore.VB_Description = "restores the screen and the event mode after a crash"
Attribute restore.VB_ProcData.VB_Invoke_Func = "r\n14"
  Call restoreForExternalWorkbook(ThisWorkbook)
End Sub



'*******************************************************************
'Blendet Regressionsblaetter ein
Sub statistikdateneinblenden()
Attribute statistikdateneinblenden.VB_Description = "hides the technical sheets for the regression calculation"
Attribute statistikdateneinblenden.VB_ProcData.VB_Invoke_Func = "e\n14"
  If blnIsControlForm() Then
    MsgBox strtranslate("msgbox_makro.form.Control"), vbCritical, vbOKOnly
  Else
    Call blaetter_einblenden_praefix("hlp_regr")
    Call blaetter_einblenden_praefix("hlp_data_regr")
    'Ab 3.1.0 werden auch die letzten 2 Spalten eingeblendet
    Call hideData_sheetLastTwoCols(False)
  End If
End Sub


'*******************************************************************
'Blendet Regressionsblaetter aus
Sub statistikdatenausblenden()
Attribute statistikdatenausblenden.VB_Description = "shows the technical sheets for the regression calculation"
Attribute statistikdatenausblenden.VB_ProcData.VB_Invoke_Func = "a\n14"
  If blnIsControlForm() Then
    MsgBox strtranslate("msgbox_makro.form.Control"), vbCritical, vbOKOnly
  Else
    Call blaetter_ausblenden_praefix("hlp_regr")
    Call blaetter_ausblenden_praefix("hlp_data_regr")
    Call hideData_sheetLastTwoCols(True)
  End If
End Sub


'*******************************************************************
'leert die Mappe vollstaendig fuer Neubeginn
Sub mappe_leeren()
Attribute mappe_leeren.VB_Description = "initializes the workbook to it's empty state \nAttention: all data and calculations are lost!"
Attribute mappe_leeren.VB_ProcData.VB_Invoke_Func = " \n14"
  If blnIsControlForm() Then
    MsgBox strtranslate("msgbox_makro.form.Control"), vbCritical, vbOKOnly
  Else
    If MsgBox(strtranslate("msgbox_makro.allesloeschen"), vbOKCancel) = vbOK Then
      Call set_userview
    End If
  End If
End Sub

Attribute VB_Name = "DatenAusMappe"
Option Explicit
Option Private Module

'===================================================================
'Prozeduren, die Daten aus Mappen und Blaettern lesen
' ohne jene mit Namen -> siehe Modul ByName


'*******************************************************************
'Funktionen und Prozeduren, die allgemeine Werte auslesen

'*******************************************************************
'Liefert fuer eine Arbeitsmappe, ein Blatt und einen Spaltenbuchstaben die 1. Zeile
'mit Zahlen
'lnganzloop gibt an, wie viele Zeilen durchsucht werden sollen
'verwendet u.a. in ImportExport.import_exceltext
Function lngrowfirstnumber(ByVal strworkbook As String, ByVal intsheetnum As Integer, _
  ByVal strCol As String, ByVal lnganzloop As Long) As Long
    Dim lngRow As Long

    For lngRow = 1 To lnganzloop
      If IsNumeric(Application.Workbooks(strworkbook).Sheets(intsheetnum).Range(strCol & lngRow).Value) And _
        Not IsEmpty(Application.Workbooks(strworkbook).Sheets(intsheetnum).Range(strCol & lngRow).Value) Then
        lngrowfirstnumber = lngRow
        Exit Function
      End If
    Next
    
  lngrowfirstnumber = 0
End Function

Function lngrowfirsttext(ByVal strworkbook As String, ByVal intsheetnum As Integer, _
  ByVal strCol As String, ByVal lnganzloop As Long) As Long
    Dim lngRow As Long
    'in erster Zeile sind Labels
    For lngRow = 2 To lnganzloop
      If Not IsEmpty(Application.Workbooks(strworkbook).Sheets(intsheetnum).Range(strCol & lngRow).Value) Then
        lngrowfirsttext = lngRow
        Exit Function
      End If
    Next
  lngrowfirsttext = 0
End Function
'*******************************************************************
'Liest die letzte existierende Zeile einer Arbeitsmappe aus, d.h. 65536 (abhaengig von Version)
'Wichtig: kein geschuetztes Blatt (aber verborgenes geht)
Function funlnglastexistingrow() As Long
  funlnglastexistingrow = ThisWorkbook.Sheets(STR_SH_HLP_CONST) _
    .Cells.SpecialCells(xlCellTypeLastCell).End(xlDown).Row
End Function


'*******************************************************************
'Gibt die Spaltennummer einer Buchstabenbezeichnung fuer Spalte an
Function funintcol(ByVal strCol As String) As Integer
  funintcol = Columns(strCol).Column
End Function


'*******************************************************************
'Gibt die Buchstabenbezeichnung einer Spaltenzahl an
Function funstrcol(ByVal intCol As Integer) As String
  funstrcol = Left(Cells(1, intCol).Address(True, False), InStr(Cells(1, intCol).Address(True, False), "$") - 1)
End Function


'*******************************************************************
'Gibt die Zeile der letzten ausgefuellten Zelle in einer bestimmten Spalte an
'funlnglastfilledrowincol(ThisWorkbook.Name, STR_SH_DATA_FORM,"Q")
Function funlnglastfilledrowincol(ByVal strWorkbookName As String, _
  ByVal strSheetName As String, ByVal strCol As String) As Long
  Call updateActiveProc("DatenAusMappe.funlnglastfilledrowincol")
  funlnglastfilledrowincol = Workbooks(strWorkbookName).Sheets(strSheetName) _
    .Cells(funlnglastexistingrow(), funintcol(strCol)).End(xlUp).Row
End Function


'*******************************************************************
'Gibt die letzte ausgefuellte Zeile in der ersten Spalte eines benannten Ranges an
Function funlnglastfilledrowinnamedcol(ByVal strName As String) As Long
  Dim strSheetName As String
  Dim lngCol As Long
  'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
  strSheetName = ThisWorkbook.Names(strName).RefersToRange.Worksheet.name
  lngCol = ThisWorkbook.Names(strName).RefersToRange.Column
  funlnglastfilledrowinnamedcol = ThisWorkbook.Sheets(strSheetName) _
    .Cells(funlnglastexistingrow(), lngCol).End(xlUp).Row
End Function

'*******************************************************************
'Ueberprueft, ob irgendwo in einer Tabelle mit Autofilter ein Filter gesetzt ist
'und setzt alle gesetzten Filter zurueck, falls moeglich
'liefert true, wenn alle Filter zurueckgesetzt werden konnten oder gar kein Filter vorhanden ist
'Ab Logib 3.1.1 23.03.2018
Function isResetAllFiltersOk(ByVal strWorkbookName As String, ByVal strSheetName As String) As Boolean
  'On Error GoTo fehler
  Dim result As Boolean
  result = False

  Dim objSheet As Worksheet
  Set objSheet = Application.Workbooks(strWorkbookName).Sheets(strSheetName)
  If objSheet.AutoFilterMode Then
    If funIsAnyFilterOn(strWorkbookName, strSheetName) Then
      objSheet.ShowAllData
    End If
    result = True
  Else
    result = True
  End If
  
fehler:
  isResetAllFiltersOk = result
End Function

'*******************************************************************
'Ueberprueft, ob irgendwo in einer Tabelle mit Autofilter ein Filter gesetzt ist
'Ab Logib 3.1.1 23.03.2018
Function funIsAnyFilterOn(ByVal strWorkbookName As String, ByVal strSheetName As String) As Boolean
 
  Dim intCounter As Integer
  intCounter = 0
  Dim result As Boolean
  result = False
  Dim objSheet As Worksheet
  Set objSheet = Application.Workbooks(strWorkbookName).Sheets(strSheetName)
  If objSheet.AutoFilterMode Then
    For intCounter = 1 To objSheet.AutoFilter.Filters.Count
      If objSheet.AutoFilter.Filters(intCounter).On Then
        result = True
        Exit For
      End If
    Next
  Else
    result = False
  End If
  funIsAnyFilterOn = result
End Function

'*******************************************************************
'Findet die letzte Reihe auch in gefilterter Tabelle
'Ab Logib 3.1.1
Public Function funLngLastRowEvenIfFiltered(ByVal strWorkbookName As String, ByVal strSheetName As String) As Long
  Dim strCol As String
  Dim lngCol As Long
  Dim lngRow As Long
  
  'hlp_regr1 11
  'data_head
  Dim result As Long
  result = 0
  
  On Error Resume Next
  
  'AutofilterMode: es gibt einen Autofilter
  'FilterMode: der Autofilter ist gesetzt
  If Application.Workbooks(strWorkbookName).Sheets(strSheetName).FilterMode Then
    Debug.Print "AutofilterRange: " & Application.Workbooks(strWorkbookName).Sheets(strSheetName).AutoFilter.Range.Address
    result = Application.Workbooks(strWorkbookName).Sheets(strSheetName).AutoFilter.Range.Row _
      + Application.Workbooks(strWorkbookName).Sheets(strSheetName).AutoFilter.Range.Rows.Count - 1
  Else
    Call lastcolandrow(strWorkbookName, strSheetName, strCol, lngCol, lngRow)
    result = lngRow
  End If
  Debug.Print "funLngLastRowEvenIfFiltered last row : " & result
  funLngLastRowEvenIfFiltered = result
End Function

'*******************************************************************
'Gibt die Zeile und Spalte der letzten Zelle mit Eingaben an
'Umgeschrieben am 06.01.2015 wegen UsedRange bei Import mit leeren, aber formatierten Spalten
'Problem in 3.1.0 funktioniert nicht mit hidden Rows
Sub lastcolandrow(ByVal strWorkbookName As String, ByVal strSheetName As String, _
  ByRef strCol As String, ByRef lngCol As Long, ByRef lngRow As Long)
  
  Dim stradress As String
  Dim strlastcell As String
  Dim intpos1 As Integer
  
  'Funktioniert auf Mac, solange nicht in userdefined function vorkommend
  lngCol = Application.Workbooks(strWorkbookName).Sheets(strSheetName) _
    .Cells.Find("*", [A1], , , xlByColumns, xlPrevious).Column
  lngRow = Application.Workbooks(strWorkbookName).Sheets(strSheetName) _
    .Cells.Find("*", [A1], , , xlByRows, xlPrevious).Row
  
  stradress = Application.Workbooks(strWorkbookName).Sheets(strSheetName).Cells(lngRow, lngCol).Address
  
  intpos1 = InStr(2, stradress, "$")
  strCol = Mid(stradress, 2, intpos1 - 2)

End Sub

'*******************************************************************
'Testet Prozedur lastcolandrow xlCellTypeVisible
Sub testLastColandrow()
  Dim strCol As String
  Dim lngCol As Long
  Dim lngRow As Long
  
  Debug.Print ThisWorkbook.name & " data_form"
  Call lastcolandrow(ThisWorkbook.name, "data_form", _
    strCol, lngCol, lngRow)
  Debug.Print "Spalte " & strCol & " bzw " & lngCol
  Debug.Print "Zeile " & lngRow
  
  Debug.Print ThisWorkbook.name & " joblist"
  Call lastcolandrow(ThisWorkbook.name, "joblist", _
    strCol, lngCol, lngRow)
  Debug.Print "Spalte " & strCol & " bzw " & lngCol
  Debug.Print "Zeile " & lngRow
  
'  Call lastcolandrow("2016.01.06 Fall Logib.xlsx", "Lohngleichheit ohne IT15", strCol, lngcol, lngrow)
'  Debug.Print "2016.01.06 Fall Logib.xlsx"
'  Debug.Print "Spalte " & strCol & " bzw " & lngcol
'  Debug.Print "Zeile " & lngrow
  
End Sub

'*******************************************************************
'Weiterer Test zu lastcolandrow
Sub test_last()
  Dim strCol As String
  Dim lngRow As Long
  Dim intCol As Integer
  
  Call lastcolandrow(ActiveWorkbook.name, ActiveSheet.name, _
    strCol, intCol, lngRow)
  MsgBox "col " & strCol & " " & intCol & vbCrLf & "row " & lngRow
End Sub


'*******************************************************************
'Funktionen und Prozeduren, die Daten aus Tabellenblaettern der Mappe lesen

'*******************************************************************
'Liest die letzte Laufnummer der Daten ein
Function funlngnextlaufnr() As Long
  Dim lnglastlaufnr As Long
  If IsNumeric(Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
    .Range(STR_DATA_FORM_SD).End(xlDown).Value) _
    And Not IsEmpty(Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
    .Range(STR_DATA_FORM_SD).End(xlDown).Value) Then
    
    lnglastlaufnr = Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
      .Range(STR_DATA_FORM_SD).End(xlDown).Value + 1
  Else
    lnglastlaufnr = 1
  End If
  funlngnextlaufnr = lnglastlaufnr
End Function


'*******************************************************************
'Liest die Zeile der letzten ausgefuellten Datensaetze aus anhand
'data_form_col_bgrad oder data_form_col_bezstunden
Function funlnglastfilledrow() As Long
  Dim lngrowbgrad As Long
  Dim lngrowbezstunden As Long
  Dim lnglastfilledrow
  lngrowbgrad = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_DATA_FORM, funstrcol_byname("data_form_col_bgrad"))
  lngrowbezstunden = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_DATA_FORM, funstrcol_byname("data_form_col_bezstunden"))
  funlnglastfilledrow = Application.WorksheetFunction.Max(lngrowbgrad, lngrowbezstunden)
End Function


'*******************************************************************
'Liest die Anzahl Daten-Spalten in data_form ein (inklusive Hilfsspalten fuer Filter, etc.)
Function funintanzdatacol() As Integer
  Const LAST_COLUMN_NAME As String = "data_form_col_filterunwahrsch"
  
  Dim result As Integer
  'Ab 3.1.0 direkt aus letzter Spalte berechnet
  result = LastColumnInRange(ThisWorkbook.Names(LAST_COLUMN_NAME).RefersToRange)
  funintanzdatacol = result
End Function


'*******************************************************************
'Test Dateiname auslesen
Sub testausmappe()
  'Debug.Print funintanzdatacol
  Debug.Print ThisWorkbook.name
End Sub
Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
'===================================================================
'VBA-Code zu Ereignissen der Arbeitsmappe,
'd.h. beim Oeffnen, Drucken etc.



'*******************************************************************
'Event-Handler beim Start der Applikation
'Setzt wegen Problemen mit Eventhandling in Excel 2007 das Flag "Ausgewertet"
'Ruft changelanguagefromapplication zum automatischen Setzen der Sprache auf,
'sofern das Sprachwahlfeld im Blatt title noch leer ist
'Code zu Excel 2003 (geaenderter Algorithmus Regressionsberechnung)
'und Vorversion ist in xlsm-Format (Logib 2.4) nicht mehr noetig (alter Code siehe Logib 2.3)
Private Sub Workbook_Open()
  On Error GoTo fehler
  Call updateActiveProc("DieseArbeitsmappe.Workbook_Open")
  
  Dim varCalculation
  Dim varCalculationBeforeSafe
  
  'Debug.Assert False
  'Berechnungseinstellungen speichern
  varCalculation = Application.Calculation
  varCalculationBeforeSafe = Application.CalculateBeforeSave
  ThisWorkbook.Names("hlp_const_c_proz_format").RefersToRange().Value = "'0" & Application.International(3) & "0%"
  ThisWorkbook.Names("hlp_const_c_date_format").RefersToRange().Value = "'" & ThisWorkbook.Names("hlp_const_c_tooldatum").RefersToRange.NumberFormatLocal
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  'Auswertungen vorhanden?
  'Debug.Print "Ausgewertet: " & ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value
  If ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value Then
    'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
    blnausgewertet = True
    'debug.print "Ausgewertete Arbeitsmappe"
  End If
  
  Call enable_all_calculations
  
  'siehe Berechnungseinstellungen speichern
  ThisWorkbook.Names("hlp_const_c_calculation").RefersToRange.Value = varCalculation
  ThisWorkbook.Names("hlp_const_c_calculationbeforesave").RefersToRange.Value = varCalculationBeforeSafe
  'debug.print "Berechnungseinstellungen speichern"
  
  Application.EnableEvents = True
  'Beim 1. Oeffnen Sprache automatisch setzen
  Call changelanguagefromapplication 'Modul translations
  Application.ScreenUpdating = False
  Call translatecontrols 'Modul translations
  Application.ScreenUpdating = True
  Exit Sub
  
fehler:
  'Call senderrormail(straktiveprozedur)
  
  'Im Fehlerfall Calculation-Einstellungen zurueckstellen (betrifft ganzes Excel)
  Application.Calculation = varCalculation
  Application.CalculateBeforeSave = varCalculationBeforeSafe
  Application.EnableEvents = True
  Application.ScreenUpdating = True

  Resume Next
End Sub


'*******************************************************************
'Achtung: Im Gegensatz zu Argib gibt es hier kein erstes verstecktes Blatt mit einer Makro-Warnung,
'das beim Oeffnen als erstes ausgeblendet und bei Schliessen als letztes eingeblendet wird,
'sofern die Makros aktiviert sind
Private Sub Workbook_BeforeClose(Cancel As Boolean)
  On Error GoTo fehler
  Call updateActiveProc("DieseArbeitsmappe.Workbook_BeforeClose")
  
  'Application.DisplayFullScreen = False
  'ThisWorkbook.Sheets(STR_SH_INTRO).Activate
  'ActiveWindow.DisplayHeadings = True
  Application.Calculation = ThisWorkbook.Names("hlp_const_c_calculation").RefersToRange.Value
  Application.CalculateBeforeSave = _
    ThisWorkbook.Names("hlp_const_c_calculationbeforesave").RefersToRange.Value
  'Wenn eine Auswertung besteht, werden alle Berechnungen abgestellt
  If ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value Then
    Call disable_all_calculations 'UpdateManagement
    Call updateActiveProc("DieseArbeitsmappe.Workbook_BeforeClose after disable_all_calculations")
  End If
  'Um eventuell geoeffnete Diagramme wieder zu schuetzen
  Call blattschutz_ein
  Exit Sub
fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next
End Sub


'*******************************************************************
'automatisches Erstellen von Fusszeilen vor dem Druck eines beliebigen Blattes
'Ab Version 2.4 von EBG gewuenscht: Fusszeile mit Firmenname, Monat und Jahr, Logib-Version
Private Sub Workbook_BeforePrint(Cancel As Boolean)
  Dim objSheet
  Dim fusszeile As String
  Dim umbruch As String
  'wegen Mac: fuer Umbruch in Zelle vbCr statt vbLf auf PC
  Dim strnewline
  strnewline = funStrNewline
  
  'Ab 3.1.0 keine Version mehr in Fusszeile
  'fusszeile = funvarvalue_byname("data_head_c_firma") & ", " & funvarvalue_byname("data_head_c_monat") _
  '  & "/" & funvarvalue_byname("data_head_c_jahr") & ", logib " & Replace(funvarvalue_byname("intro_c_version"), strnewline, " ")
  fusszeile = funvarvalue_byname("data_head_c_firma") & ", " & funvarvalue_byname("data_head_c_monat") _
    & "/" & funvarvalue_byname("data_head_c_jahr")

  For Each objSheet In ThisWorkbook.Sheets
    With objSheet.PageSetup
      .LeftFooter = fusszeile
      'Auf data_form mit Seitenzahl
      If objSheet.name = "data_form" Then
        .RightFooter = "&D &T &P/&N"
      Else
        .RightFooter = "&D &T"
      End If
    End With
  Next

End Sub


'*******************************************************************
Private Sub Workbook_SheetCalculate(ByVal Sh As Object)
  'Debug.Print Sh.Name & " berechnet"
End Sub
Attribute VB_Name = "Entwicklung"
Option Explicit
Option Private Module


'===================================================================
'Hilfsmakros waehrend der Entwicklung
'z.B. Mappe in leeren Anfangszustand setzen mit set_userview
'oder fuer Entwicklung oeffnen mit set_developerview
'Achtung: set_userview inzwischen auch in oeffentlichem Makro verwendet

'*******************************************************************
'Oeffnet Blatt- und Arbeitsmappenschutz, zeigt alle Blaetter an
'fuer Weiterentwicklung des Tools
Sub set_developerview()
  On Error Resume Next
  Call updateActiveProc("Entwicklung.set_developerview")
  ThisWorkbook.Names("hlp_const_c_usersicht").RefersToRange.Value = False
  Call mappenschutz_aus 'arbeitsmappenschutz_ausschalten
  Call alle_sheets_einblenden
  Call blattschutz_aus

  Call rpt_fazit_links_erw_sethidden(False)
  Call togglebuttonsvisible(True)
  ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btndeletedata").Visible = True
  Call blattschutz_aus
  Call berechnung_einschalten
  Exit Sub
  
fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next
End Sub


'*******************************************************************
'Setzt Blatt- und Arbeitsmappenschutz fuer die Ausgangslage der User
'nicht nur fuer Entwicklung,
'kann via Makro vom User aufgerufen werden
Sub set_userview()
  If Not ISTEST Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("Entwicklung.set_userview")
  
  Dim lnglastexistingrow As Long
  Dim blndata_headloeschen As Boolean
  lnglastexistingrow = funlnglastexistingrow
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  Call alle_sheets_einblenden
  
  blndata_headloeschen = MsgBox(strtranslate("msgbox_data_head.deldatahead"), vbYesNo) = vbYes
  
  'Sprachfeld zuruecksetzen (Sprache wird nur beim 1. Mal automatisch aus Excelsprachversion gesetzt)
  'Achtung: setzt den Blattschutz von data_head, deshalb vor blattschutz_aus
  If blndata_headloeschen Then
    ThisWorkbook.Names("title_c_sprachauswahl").RefersToRange.ClearContents
  End If
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
 
  Call blattschutz_aus
  
  'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
  blnausgewertet = False
  ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value = False
  ThisWorkbook.Names("hlp_const_c_usersicht").RefersToRange.Value = True
  Application.EnableEvents = False
  
  'Ab 3.1.0 evtl. gesetzte Filter zuruecksetzen
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).FilterMode Then
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).ShowAllData
  End If
  
  'Ab 3.1.0 Sortierfelder zuruecksetzen
  ThisWorkbook.Names("data_form_c_sortierfeld").RefersToRange.Value = ""
  ThisWorkbook.Names("data_form_c_sortierreihenfolge").RefersToRange.Value = ""
  
  'Ab 3.1.0 versteckte Zusatzspalten anzeigen
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Columns(ThisWorkbook.Names("data_form_col_zusatz1").RefersToRange.Column).Resize(, 5).Hidden Then
    btntogglezusatz_click
  End If
  
  'Ab 3.1.0 letzte zwei Spalten verstecken
  Call hideData_sheetLastTwoCols(True)

  'SR 26.05.2016 hier erweitert bis hlp_data_regr2_col_bst
  Call range_allesloeschen(STR_SH_DATA_FORM, STR_DATA_FORM_SD, _
    funstrcol_byname("data_form_col_filterunwahrsch") & lnglastexistingrow, True)
  
  'SR 18.08.2018 AutoFilter aus- und einschalten, um AutoFilter.Range zurueckzusetzen
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).AutoFilterMode Then
    ThisWorkbook.Names("data_form_col_laufnr").RefersToRange.Range("A1").AutoFilter
  End If
  ThisWorkbook.Names("data_form_col_laufnr").RefersToRange.Range("A1").AutoFilter
  Debug.Print "AutoFilterRange: " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).AutoFilter.Range.Address
  
  Call range_allesloeschen(STR_SH_HLP_DATA_REGR1, funstraddr_byname("hlp_data_regr1_sd"), _
    funstrcol_byname("hlp_data_regr1_col_mbls_1") & lnglastexistingrow, True)
  Call range_allesloeschen(STR_SH_HLP_DATA_REGR2, funstraddr_byname("hlp_data_regr2_sd"), _
    funstrcol_byname("hlp_data_regr2_col_bst") & lnglastexistingrow, True)
    
  'Zellen wieder entsperren
  Call toggleLockDataHead(False)
  If blndata_headloeschen Then
    'Zellinhalt loeschen
    Call ungesperrte_zellen_loeschen(ThisWorkbook.Worksheets(STR_SH_DATA_HEAD))
  End If
  'Dateiname auf jeden Fall loeschen
  ThisWorkbook.Names("data_head_c_dateiname").RefersToRange.Value = ""

  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  'SR ab 29.10.2015 Achsen zuruecksetzen
  Call togglechartaxes
  'vorher
  'ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value = False
  Call spaltenzeilenkoepfe_ausblenden
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  Call togglebuttonsvisible(True)
  'nach Auswertung ausgeblendete Buttons wieder einblenden
  Call togglebuttonsauswertung
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  Call hide_selection
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  Call blattschutz_ein
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  Call folgeblaetter_ausblenden
  'Ab 15.10.2015 Blatt joblist putzen
  Call clearJoblist(False)
  Call Alles_enablen
  'Call berechnung_einschalten
  
  'falls data_head loeschen = true, Fokus auf 1. Blatt setzen
  If blndata_headloeschen Then
    ThisWorkbook.Sheets(STR_SH_TITLE).Activate
    ThisWorkbook.Worksheets(STR_SH_TITLE).Range("A1").Select
  Else
    'Damit 1. Blatt sichtbar ist
    ThisWorkbook.Sheets(STR_SH_TITLE).Activate
    ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Activate
    ThisWorkbook.Names("data_head_c_buwaz").RefersToRange.Select
  End If

  Exit Sub
  
fehler:
  Call senderrormail(straktiveprozedur)
  Debug.Print err.Number & " " & err.Description
  Resume Next
End Sub


'*******************************************************************
'Screen, Berechnung und Events abstellen waehrend Code laeuft
'Das Gegenstueck restore ist im Modul ConstVarPublic, da oeffentlich
Sub silentCode()
  Application.ScreenUpdating = False
  ThisWorkbook.Worksheets("data_form").EnableCalculation = False
  Application.EnableEvents = False
  Application.Cursor = xlWait
End Sub


'*******************************************************************
'Screen, Berechnung und Events nicht nur in ThisWorkbook abstellen waehrend Code laeuft
'Verwendet ab V3 fuer Export EBG-Formular
'Das Gegenstueck restoreForExternalWorkbook ist ebenfalls in diesem Modul
Sub silentCodeForExternalWorkbook(ByRef objWorkbook As Workbook)
  Dim objSheet As Worksheet
  Application.ScreenUpdating = False
  For Each objSheet In objWorkbook.Worksheets
    objSheet.EnableCalculation = False
  Next
  Application.EnableEvents = False
  Application.Cursor = xlWait
End Sub


'*******************************************************************
'Screen, Berechnung und Events wiederherstellen nicht nur in ThisWorkbook (bei Abbruechen)
'Verwendet ab V3 fuer Export EBG-Formular
'Das Gegenstueck silentCodeForExternalWorkbook im gleichen Modul
Sub restoreForExternalWorkbook(ByRef objWorkbook As Workbook)
  Dim objSheet As Worksheet
  
  Application.ScreenUpdating = True
  For Each objSheet In objWorkbook.Worksheets
    objSheet.EnableCalculation = True
  Next
  Application.EnableEvents = True
  Application.Cursor = xlDefault
  Application.Calculation = xlCalculationAutomatic
  Application.StatusBar = False
End Sub

'*******************************************************************
'Alle Zeilen aus Blatt joblist loeschen
Sub clearJoblist(Optional ByVal isVisible As Boolean = True)
  Dim strColStartTarget As String
  Dim lngLastFilledRowTarget As Long
  Dim introwdatastarttarget As Integer
  Dim blnProtected As Boolean
  Dim blnvisible As Boolean
      
  'Mappe entsperren, Blatt anzeigen
  Call mappenschutz_aus
  ThisWorkbook.Sheets(STR_SH_JOBLIST).Visible = True
  Call mappenschutz_ein

  'Blatt entsperren
  blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")
  
  introwdatastarttarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Row + 1
  lngLastFilledRowTarget = funlnglastfilledrowincol(ThisWorkbook.name, _
      STR_SH_JOBLIST, funstrcol_byname("joblist_col_job"))
  If introwdatastarttarget <= lngLastFilledRowTarget Then
    ThisWorkbook.Sheets(STR_SH_JOBLIST).Rows(introwdatastarttarget & ":" & lngLastFilledRowTarget).delete Shift:=xlUp
  End If
  
  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(STR_SH_JOBLIST, blnProtected)
  
  If Not isVisible Then
    Call mappenschutz_aus
    ThisWorkbook.Sheets(STR_SH_JOBLIST).Visible = False
    Call mappenschutz_ein
  End If
End Sub


'*******************************************************************
'Fuer data_form Blattschutz aufheben
Sub data_form_unprotect()
  ThisWorkbook.Worksheets("data_form").Unprotect Password:=changeToNumberString("s")
End Sub


'*******************************************************************
'Fuer data_form Blattschutz setzen
Sub data_form_protect()
  Call protectSheet(STR_SH_DATA_FORM, True)
End Sub


'*******************************************************************
'Alle Blaetter einblenden
Sub Alles_einblenden()
  Call alle_sheets_einblenden
End Sub


'*******************************************************************
'Setzt die Auswahlmarke, so dass sie nicht im sichtbaren Bereich ist
Sub setSelectionInvisible()
    ActiveSheet.Range("AZ100").Select
    ActiveWindow.ScrollRow = 1
    ActiveWindow.ScrollColumn = 1
End Sub


'*******************************************************************
'Markierung ausserhalb sichtbaren Bereich legen
'aufgerufen in set_userview
Sub hide_selection()
  Dim blnscreenupdating As Boolean
  Dim lngRow As Long
  Dim intColumn As Integer
  Dim objSheet As Worksheet
  
  Dim objActiveSheet As Worksheet
  Set objActiveSheet = ActiveSheet
  
  blnscreenupdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
 
  For Each objSheet In ThisWorkbook.Worksheets
  
    If objSheet.Visible Then
      objSheet.Select
      Range("A1").Select
      'Application.ScreenUpdating = False
      
      If objSheet.name = STR_SH_TRANSLAT Or objSheet.name = STR_SH_HLP_LSE Then
        ActiveWindow.ScrollRow = 1
        ActiveWindow.ScrollColumn = 1
      
      'Fokus auf 1. Eingabefeld setzen
      ElseIf objSheet.name = STR_SH_DATA_HEAD Then
        ActiveWindow.ScrollRow = 1
        ActiveWindow.ScrollColumn = 1
        ThisWorkbook.Names("data_head_c_monat").RefersToRange.Select
        
      'Fokus auf 1. Eingabefeld setzen
      ElseIf objSheet.name = STR_SH_DATA_FORM Then
        ActiveWindow.ScrollRow = 1
        ActiveWindow.ScrollColumn = 1
        ThisWorkbook.Names("data_form_row_obligatorisch").RefersToRange.Offset(4, 0).Select
        
      'Auf allen andern Blaettern wird Markierung versteckt, d.h. ausserhalb sichtbaren Bereich gesetzt
      Else
        ActiveWindow.ScrollRow = 1
        ActiveWindow.ScrollColumn = 1
        lngRow = LastRowInRange(ActiveWindow.VisibleRange) + 1
        intColumn = LastColumnInRange(ActiveWindow.VisibleRange) + 1
        Range(Cells(lngRow, intColumn), Cells(lngRow, intColumn)).Select
        'ActiveWindow.ScrollIntoView 0, 0, 1, 1
        ActiveWindow.ScrollRow = 1
        ActiveWindow.ScrollColumn = 1

      End If
    End If
  Next
  objActiveSheet.Select
  'Screenupdating wird auf Zustand zu Beginn der Prozedur zurueckgesetzt
  Application.ScreenUpdating = blnscreenupdating
End Sub


'*******************************************************************
'Blatt mit Uebersetzungen hlp_translations einblenden
Sub translations_einblenden()
  Call blatt_einblenden(STR_SH_TRANSLAT, changeToNumberString("m"))
  'Nur vorsichtshalber, hat eigentlich keinen Schutz
  ThisWorkbook.Worksheets(STR_SH_TRANSLAT).Unprotect Password:=changeToNumberString("s")
End Sub


'*******************************************************************
'Blatt mit Uebersetzungen hlp_translations ausblenden
Sub translations_ausblenden()
  'Achtung Blatt nicht schuetzen!
  Call blatt_ausblenden(STR_SH_TRANSLAT, changeToNumberString("m"))
End Sub


'*******************************************************************
'Blatt mit Konstanten hlp_const einblenden
Sub const_einblenden()
  Call blatt_einblenden(STR_SH_HLP_CONST, changeToNumberString("m"))
  'ThisWorkbook.Worksheets(STR_SH_TRANSLAT).Unprotect Password:=changeToNumberString("s")
End Sub


'*******************************************************************
'Blatt mit Konstanten hlp_const ausblenden
Sub const_ausblenden()
  Call blatt_ausblenden(STR_SH_HLP_CONST, changeToNumberString("m"))
End Sub


'*******************************************************************
'Wert fuer das benannte Feld hlp_const_c_ausgewertet false setzen
'nur fuer Tests, nirgendwo aufgerufen
Sub ausgewertet_false_setzen()
  'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
  blnausgewertet = False
  ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value = False
End Sub


'*******************************************************************
'Wert fuer das benannte Feld hlp_const_c_ausgewertet true setzen
'nur fuer Tests, nirgendwo aufgerufen
Sub ausgewertet_true_setzen()
  'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
  blnausgewertet = True
  ThisWorkbook.Names("hlp_const_c_ausgewertet").RefersToRange.Value = True
End Sub


'*******************************************************************
'Setzt fuer Druck in Fusszeile links Datei und Blatt und rechts Datum und Zeit
'nur fuer Tests, nirgendwo aufgerufen
Sub tmp_Fusszeile()
    With ActiveSheet.PageSetup
        .LeftFooter = "&F &A"
        .RightFooter = "&D &T"
    End With
End Sub


'*******************************************************************
'Alles enablen, d.h. Events, ScreenUpdating, Calculation
'aufgerufen von set_userview()
Sub Alles_enablen()
  Dim objSheet As Worksheet

  'Events enablen
  Application.EnableEvents = True

  'Berechnungsmodus Automatisch
  Application.Calculation = Excel.XlCalculation.xlCalculationAutomatic

  'Bildschirm wieder updaten
  Application.ScreenUpdating = True
  
  'Berechnung auf jedem Sheet einzeln enablen
  For Each objSheet In ThisWorkbook.Worksheets
     objSheet.EnableCalculation = True
  Next
End Sub
  
  
'*******************************************************************
'passt im aktiven Blatt fuer rpt-Blaetter die Druckeinstellungen an
'nur fuer Wiederherstellung von Blaettern, nirgendwo aufgerufen
Sub report_druck_anpassen()

    With ActiveSheet.PageSetup
      'Druckrand links und rechts 1cm
        .LeftMargin = Application.InchesToPoints(0.393700787401575)
        .RightMargin = Application.InchesToPoints(0.393700787401575)
        .Orientation = xlPortrait
        .FitToPagesWide = 1
        .FitToPagesTall = 1
    End With
    ActiveWindow.SelectedSheets.PrintPreview
End Sub


'*******************************************************************
'passt im Blatt data_form die Druckeinstellungen an
'nur fuer Wiederherstellung von Blaettern, nirgendwo aufgerufen
Sub data_form_druck_anpassen()

    With ThisWorkbook.Worksheets(STR_SH_DATA_FORM).PageSetup
        .AlignMarginsHeaderFooter = True
        .Orientation = xlLandscape
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).PrintPreview
End Sub


'*******************************************************************
'gibt die Namen der vorhandenen Druckbereiche aus
'zur Ueberpruefung bei Problemen mit internationalen Versionen und Druckbereichen
'siehe Abschnitt zu Print_Area in Modul a_programmierkonventionen
Sub namen_lesen()
  Dim N As name
  For Each N In ThisWorkbook.Names
    If N.name Like "*Print_Area" Then
      Debug.Print N.name
    End If
  Next
End Sub


'*******************************************************************
'Sucht auf aktivem Blatt nach Font Calibri
'gemaess EBG muss alles in Arial formatiert sein
Sub selectFontCalibri()
  Dim objGefundeneZellen As Range
  Dim objZelle As Range
  
  For Each objZelle In ActiveSheet.UsedRange
  
    If objZelle.Font.name = "Calibri" Then
      If objGefundeneZellen Is Nothing Then
        Set objGefundeneZellen = objZelle
      Else
        Set objGefundeneZellen = Union(objGefundeneZellen, objZelle)
      End If
    End If
  Next objZelle
  
  If objGefundeneZellen Is Nothing Then
    MsgBox "Kein Font Calibri vorhanden"
  Else
    objGefundeneZellen.Select
  End If
End Sub


'*******************************************************************
'ueberprueft ungesperrte Zellen auf einem Blatt
'nur fuer Entwicklung, nirgendwo aufgerufen
Sub selectunlockedcells()
  Dim objGefundeneZellen As Range
  Dim objZelle As Range
  
  For Each objZelle In ActiveSheet.UsedRange
    If Not objZelle.Locked Then
      'Debug.Print "Ungesperrt: " & objZelle.Address
      If objGefundeneZellen Is Nothing Then
        Set objGefundeneZellen = objZelle
      Else
        Set objGefundeneZellen = Union(objGefundeneZellen, objZelle)
      End If
    End If 'Not objZelle.Locked
  Next objZelle
  
  If objGefundeneZellen Is Nothing Then
    MsgBox "Alle Zellen sind gesperrt."
  Else
    objGefundeneZellen.Select
  End If
End Sub

Function toggleText(ByVal strText As String)
  Dim result As String
  
  'for
End Function

'*******************************************************************
'selektiert auf aktivem Blatt die ungesperrten Zellen
'nur fuer Entwicklung, nirgendwo aufgerufen
Sub ungesperrte_zellen_auswaehlen()
  Call updateActiveProc("Hilfsmakros.ungesperrte_zellen_auswaehlen")
  Dim objGefundeneZellen As Range
  Dim objZelle As Range
  Dim strSheetName As String
  Dim objSheet As Worksheet
  
  'strsheetname = ActiveSheet.Name
  'objsheet.Activate
  Set objSheet = ActiveSheet
  For Each objZelle In objSheet.UsedRange
    If Not objZelle.Locked Then
      If objGefundeneZellen Is Nothing Then
        Set objGefundeneZellen = objZelle
      Else
        Set objGefundeneZellen = Union(objGefundeneZellen, objZelle)
      End If
    End If 'Not objZelle.Locked
  Next objZelle
  
  If Not objGefundeneZellen Is Nothing Then
    'Direktes Loeschen eines Range hat Problem mit verbundenen Zellen
    objGefundeneZellen.Select
    'Selection.ClearContents
  End If
  'Sheets(strsheetname).Activate
  
End Sub


'*******************************************************************
'Hilfsfunktion ab 2.5 2016
'sperrt oder entsperrt die mit data_head_cells_entry benannten Eingabefelder
'Achtung: bei verbundenen Feldern muss im Namen der ganze Range angegeben sein,
'und zwar mit absoluten Bezuegen
'z.B. $C$6:$O$6
Sub toggleLockDataHead(ByVal blnLocked)
  Dim objRange As Range
  Application.GoTo reference:="data_head_cells_entry"
  'Debug.Print Selection.Areas.Count
  For Each objRange In Selection.Areas
    'Debug.Print myrange.Address
    objRange.Locked = blnLocked
  Next
  Application.GoTo reference:="data_head_c_monat"
End Sub

'*******************************************************************
'Hilfsfunktion ab 2.5 2016
'sperrt oder entsperrt die mit data_head_cells_entry benannten Eingabefelder
'Achtung: bei verbundenen Feldern muss im Namen der ganze Range angegeben sein,
'und zwar mit absoluten Bezuegen
'z.B. $C$6:$O$6
'Aufruf: call toggleLockInNamedRange("data_head_cells_entry", true)
Sub toggleLockInNamedRange(ByVal strName As String, ByVal blnLocked As Boolean)
  'On Error Resume Next
  
  Dim objRange As Range
  Application.GoTo reference:=strName
  'Debug.Print Selection.Areas.Count
  For Each objRange In Selection.Areas
    'Debug.Print myrange.Address
    objRange.Locked = blnLocked
  Next
End Sub


'*******************************************************************
'gibt in MsgBox aus, ob das aktive Blatt geschuetzt ist
'nur fuer Entwicklung, nirgendwo aufgerufen
Sub testsheetprotection()
 MsgBox ("Blatt " & ActiveSheet.name & " geschuetzt? " & ActiveSheet.ProtectContents)
End Sub


'*******************************************************************
'gibt die Blattnamen aller Blaetter der Mappe aus (auch geschuetzte und versteckte)
'nur fuer Entwicklung, nirgendwo aufgerufen
Sub printsheetnames()
  Dim objSheet
  For Each objSheet In ThisWorkbook.Sheets
    Debug.Print objSheet.name
  Next
End Sub

Sub printBezAndColumn()
  Dim objZelle As Range
  Dim strString
  For Each objZelle In ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Range("A11:W11")
    strString = objZelle.Column & " " & funstrcol(objZelle.Column) & " " & objZelle.Value
    
    On Error Resume Next
    strString = strString & "; Name: " & objZelle.name.name
    Debug.Print strString
    If objZelle.Offset(5, 0).HasFormula Then
      Debug.Print objZelle.Offset(5, 0).Formula
    End If
    Debug.Print
  Next

End Sub
Attribute VB_Name = "Errormanagement"
Option Explicit
Option Private Module

'===================================================================
'Dieses Blatt enthaelt die Routinen zum Errormanagement
'Achtung:
'Ab November 2014 Version Logib 2.4 erfolgt keine automatische
'Erstellung des Errormails mehr, weil das auf dem Mac wahrscheinlich
'nicht funktioniert und weil die Informationen im Mail fuer die Fehleranalyse
'in einem Supportfall meist nicht weiterhelfen
'das Mail laesst sich aber immer noch bei Bedarf mit dem Makro erzeugen

'Verfahren:
' 1) In der globalen Variablen straktiveprozedur wird am Anfang jeder Prozedur oder Funktion
'     der Name von Modul und Prozedur gespeichert,
'     z.B. call updateActiveProc("Errormanagement.testerrormail")
' 2) In den Startprozeduren stehen gleich nach Prozedurkopf folgende Zeilen
'     On Error GoTo fehler
'     call updateActiveProc("Modul.Prozedurname")
' 3) Am Ende der Startprozeduren stehen folgende Zeilen
'       Exit Sub
'     fehler:
'       Call senderrormail(straktiveprozedur)
'        Resume Next
' 4) senderrormail erstellt ein Mail mit wichtigen Daten, adressiert an mich


'*******************************************************************
'Uebersetzt den Sprachcode in einen verstaendlichen Text
'aufgerufen von Errormanagement.funstrlanguageversions
Function funstrlanguageidtotext(ByVal lngsprache As Long) As String
  Dim strhlp As String
  Dim objlcid
  
  'For Each objlcid In Office.MsoLanguageID
  '  Debug.Print objlcid
  'Next
  
  Select Case lngsprache
    Case 1031 'msoLanguageIDGerman '1031
      strhlp = "Deutsch"
    Case 1033 'msoLanguageIDEnglishUS  '1033
      strhlp = "Englisch USA"
    Case 1036 'msoLanguageIDFrench '1036
      strhlp = "Franzoesisch"
    Case 1040 'msoLanguageIDItalian  '1040
      strhlp = "Italienisch"
    Case 2055 'msoLanguageIDSwissGerman '2055
      strhlp = "Deutsch Schweiz"
    Case 2057 'msoLanguageIDEnglishUK  '2057
      strhlp = "Englisch UK"
    Case 2064 'msoLanguageIDSwissItalian  '2064
      strhlp = "Italienisch Schweiz"
    Case 3079 'msoLanguageIDGermanAustria '3079
      strhlp = "Deutsch Oesterreich"
    Case 4108 'msoLanguageIDSwissFrench '4108
      strhlp = "Franzoesisch Schweiz"
    Case 5127 'msoLanguageIDGermanLiechtenstein '5127
      strhlp = "Deutsch Liechtenstein"
    Case Else
      strhlp = "Andere Sprache, Code : " & lngsprache
  End Select
  funstrlanguageidtotext = strhlp
End Function


'*******************************************************************
'Generelle Informationen zu Excel- und Windowsversionen
Function funstrgenerell()
  Dim strhlp As String
  
  strhlp = vbCrLf & strtranslate("supportmail_lblprogramm") & ": " & _
    Application.name & " " & Application.Version & "; Build: " & Application.Build & vbCrLf & strtranslate("supportmail_lblos") & ": " & _
    Application.OperatingSystem & _
    vbCrLf & "Logib " & Replace(funvarvalue_byname("hlp_const_c_toolversion"), funStrNewline, ", ") & vbCrLf
  funstrgenerell = strhlp
End Function


'*******************************************************************
'Liefert betriebssystemspezifisches Zeichen fuer Umbruch in Zelle oder Fusszeile
'Unter Windows und Excel2016 Mac vbLf, unter Excel11 Mac vbCr
'SR 06.03.2018
Function funStrNewline()
  Dim result As String
  result = vbLf
  
  If Application.OperatingSystem Like "*Mac*" Then
    If Val(Application.Version) < 15 Then
      result = vbCr
    End If
  End If
  
  funStrNewline = result
End Function


'*******************************************************************
'Sprachen: Achtung bedingt Modul
Function funstrlanguageversions()
  Dim strhlp As String
  
  strhlp = _
    strtranslate("supportmail_lbllanginst") & ": " & _
      funstrlanguageidtotext(Application.LanguageSettings.LanguageID(msoLanguageIDInstall)) & vbCrLf _
    & strtranslate("supportmail_lbllangui") & ": " & _
      funstrlanguageidtotext(Application.LanguageSettings.LanguageID(msoLanguageIDUI)) & vbCrLf _
    & strtranslate("supportmail_lbllanghlp") & ": " & _
      funstrlanguageidtotext(Application.LanguageSettings.LanguageID(msoLanguageIDHelp)) & vbCrLf _
    & strtranslate("supportmail_lbldrucker") & ": " & Application.ActivePrinter & vbCrLf
  funstrlanguageversions = strhlp
End Function


'*******************************************************************
'Spezifische Informationen zu Exceleinstellungen
Function funstrexcel()
  Dim strhlp As String
  'wegen Mac
  Dim msoFeatureInstallNone
  msoFeatureInstallNone = 0
  'wegen Mac, kann nicht mit "..& (Application.FeatureInstall = msoFeatureInstallNone) &.. " umgehen
  Dim strnachinsttab As String
  If Application.FeatureInstall = msoFeatureInstallNone Then
    strnachinsttab = "true"
  Else
    strnachinsttab = "false"
  End If
  strhlp = vbCrLf & strtranslate("supportmail_lblexceleinst") & vbCrLf & _
    strtranslate("supportmail_lblstandardpfad") & ": " & Application.DefaultFilePath & vbCrLf & _
    strtranslate("supportmail_lblnachinstab") & ": " & strnachinsttab & vbCrLf & _
    strtranslate("supportmail_lbldezimaltrennzeichen") & ": " & Application.International(xlDecimalSeparator) & vbCrLf & _
    strtranslate("supportmail_lbltausendertrenn") & ": " & Application.International(xlThousandsSeparator) & vbCrLf & _
    strtranslate("supportmail_lbllistentrenn") & ": " & Application.International(xlListSeparator) & vbCrLf
  
  funstrexcel = strhlp
End Function


'*******************************************************************
'Informationen zu den Resultaten und Daten
Function funstrdata()
  On Error Resume Next
  Dim strhlp As String
  
  strhlp = vbCrLf & vbCrLf & strtranslate("supportmail_lbldatenresultate") & vbCrLf _
    & strtranslate("supportmail_lblanzahldaten") & ": " & funvarvalue_byname("data_head_c_anzmitarb") & vbCrLf _
    & strtranslate("supportmail_lblvorgehen") & ": " & funvarvalue_byname("hlp_const_c_vorgehen") & vbCrLf _
    & vbCrLf & strtranslate("supportmail_lblbasisregr") & vbCrLf _
    & strtranslate("supportmail_lbldatengueltig") & ": " & funvarvalue_byname("data_form_c_anzerw") & vbCrLf _
    & strtranslate("supportmail_lbldatengueltigfrauen") & ": " & funvarvalue_byname("rpt_fazit_c_anzbasisf") & vbCrLf _
    & strtranslate("supportmail_lblbasissignifikant") & ": " & funvarvalue_byname("rpt_fazit_c_signifikanzbasis") & vbCrLf _
    & vbCrLf & strtranslate("supportmail_lblerwregr") & vbCrLf _
    & strtranslate("supportmail_lbldatengueltig") & ": " & funvarvalue_byname("data_form_c_anzerw") & vbCrLf _
    & strtranslate("supportmail_lbldatengueltigfrauen") & ": " & funvarvalue_byname("rpt_fazit_c_anzerwf") & vbCrLf _
    & strtranslate("supportmail_lblerwsignifikant") & ": " & funvarvalue_byname("rpt_fazit_c_signifikanzerw")
  
  funstrdata = strhlp
End Function


'*******************************************************************
'liest fuer senderrormail Daten wie Naem des Workbooks aus
Function funstrsystemdaten(ByVal strprocname As String) As String
  Dim strhlp As String
  Dim strerr As String
  
  'ev noch interessant:
  ' - application.mailsystem
  
  strhlp = strtranslate("errormail_txtfehlerinproz") & " " & strprocname & " " & Now & vbCrLf & vbCrLf & _
    strtranslate("errormail_generell") & " " & funstrgenerell() & funstrlanguageversions()

  strerr = vbCrLf & strtranslate("errormail_info") & vbCrLf & _
    strtranslate("errormail_aktmappe") & ": " & Application.ActiveWorkbook.name & vbCrLf & _
    strtranslate("errormail_aktblatt") & ": " & Application.ActiveSheet.name & vbCrLf & _
    strtranslate("errormail_aktzelle") & ": " & Application.ActiveCell.Address(False, False) & vbCrLf & _
    strtranslate("errormail_fehlernr") & ": " & err.Number & vbCrLf & _
    strtranslate("errormail_quelle") & ": " & err.Source & vbCrLf & _
    strtranslate("errormail_beschreibung") & ": " & err.Description & vbCrLf
  
  funstrsystemdaten = strhlp & funstrexcel() & strerr
  
End Function


'*******************************************************************
'Errormail erzeugen
'Mail wird nicht mehr automatisch verschickt, da nicht kompatibel mit Mac
Sub senderrormail(ByVal strprocname As String)
  On Error Resume Next
  Const BLNMAIL = False
  
  Dim objOutlook
  Dim objMail 'As MailItem
  
  Debug.Print err.Number & " " & err.Description & " " & err.Source
  If BLNMAIL Then
    Set objOutlook = CreateObject("Outlook.Application")
    Set objMail = objOutlook.CreateItem(0)
    
    With objMail
        .To = STR_MAILSUPPORT
        .Subject = strtranslate("errormail_subject")
        .Body = funstrsystemdaten(strprocname)
        .display
    End With
    
    Set objMail = Nothing
    Set objOutlook = Nothing
  Else
    Debug.Print "Fehler in " & strprocname
  End If
End Sub


'*******************************************************************
'Uebersetzt Klartext-Prozedurnamen in Kuerzel
'aufgerufen in updateActiveProc
'z.Z. bedeutungslos, da Prozedurstack nicht ins Supportmail kommt
Function translate_procname(ByVal procname As String) As String
  On Error GoTo err
  translate_procname = strtranslate("procname." & procname)
  Exit Function
err:
  translate_procname = procname
End Function


'*******************************************************************
'Prozedur aktualisiert den Namen der letzten Prozedur
'und fuellt ihn in Stack, falls anders als letzer
Sub updateActiveProc(ByVal procname As String)
  On Error Resume Next
  Static lastprocname As String

  'Gewisse Prozeduren fuehren zu Neustart des Stack
  If InStr(procname, "ImportExport.export_ebgsheet") > 0 _
    Or InStr(procname, "Auswertung.auswerten") > 0 _
    Or InStr(procname, "ImportExport.import_lse2004") > 0 _
    Or InStr(procname, "ImportExport.import_exceltext") > 0 _
    Or InStr(procname, "ImportExport.import_openfile") > 0 _
    Or InStr(procname, "ImportExport.export_ebgsheet") Then

    strprozedurstack = ""
  End If
  procname = translate_procname(procname)
  If InStr(procname, "Excelfunktionen") = 0 _
  And procname <> lastprocname Then
    strprozedurstack = strprozedurstack & procname & vbCrLf
    straktiveprozedur = procname
  End If
  lastprocname = procname
End Sub

Attribute VB_Name = "Hauptmodul"
Option Explicit
Option Private Module

'===================================================================
'Zentrale Makros fuer die Verarbeitung

'*******************************************************************
'Auslagerung von Blattschutz in Methode, damit Blattschutz fuer ein
'bestimmtes Blatt immer gleich ist
'nur anwendbar auf ThisWorkbook, nicht fuer Exportmappen etc.
'SR Ab Logib 3.1.0 wegen Filter in data_form
Sub protectSheet(ByVal strSheetName, ByVal blnprotectcontents)
  If blnprotectcontents Then
    If strSheetName = STR_SH_DATA_FORM Then
        ThisWorkbook.Sheets(strSheetName).Protect Password:=changeToNumberString("s"), _
          DrawingObjects:=True, Contents:=True, Scenarios:=True, AllowFiltering:=True
    Else
      'Standardfall Diagramme und Zeichenobjekte immer geschuetzt, kein Autofilter
      ThisWorkbook.Sheets(strSheetName).Protect Password:=changeToNumberString("s"), _
        DrawingObjects:=True, Contents:=True, Scenarios:=True
    End If
  End If
 
End Sub

'Auf Blatt data_form btntogglezusatz -> Ein- oder Ausblenden Zusatzspalten
Sub btntogglezusatz_click()
  Dim blnProtected As Boolean
  
  blnProtected = ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  
  
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Columns(ThisWorkbook.Names("data_form_col_zusatz1").RefersToRange.Column).Resize(, 5).Hidden _
    = Not ThisWorkbook.Sheets(STR_SH_DATA_FORM).Columns(ThisWorkbook.Names("data_form_col_zusatz1").RefersToRange.Column).Resize(, 5).Hidden
  
  'Beschriftung von + zu - wechseln
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Columns(ThisWorkbook.Names("data_form_col_zusatz1").RefersToRange.Column).Resize(, 5).Hidden Then
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Buttons("btntogglezusatz").Caption = "+"
    'ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btntogglezusatz").TextFrame.Characters.Text = "+"
  Else
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Buttons("btntogglezusatz").Caption = "-"
    'ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btntogglezusatz").TextFrame.Characters.Text = "-"
  End If
  Call protectSheet(STR_SH_DATA_FORM, blnProtected)
End Sub


Sub hideData_sheetLastTwoCols(ByVal isHidden As Boolean)
  Dim blnProtected As Boolean
  
  blnProtected = ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  
  
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Columns(ThisWorkbook.Names("data_form_col_mbls_prog").RefersToRange.Column).Resize(, 2).Hidden _
    = isHidden

  Call protectSheet(STR_SH_DATA_FORM, blnProtected)
End Sub

'*******************************************************************
'Initialisiert die Laufnummern auf Tabellenblatt
'Wird nur aufgerufen, wenn Dateneingabe direkt auf Blatt erfolgt
Sub init_laufnr()
  Call updateActiveProc("Hauptmodul.init_laufnr")

  Dim lnglaufnr As Long
  Dim objstartcell As Range
  
  Call blatt_einblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  
  'Startzelle bestimmen
  If IsNumeric(ThisWorkbook.Sheets(STR_SH_DATA_FORM) _
    .Range(STR_DATA_FORM_SD).End(xlDown).Value) _
    And Not IsEmpty(Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
    .Range(STR_DATA_FORM_SD).End(xlDown).Value) Then
    
    Set objstartcell = Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
      .Range(STR_DATA_FORM_SD).End(xlDown).Offset(1, 0)
  Else
    Set objstartcell = Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
      .Range(STR_DATA_FORM_SD)
  End If
  
  'Debug.Print Timer & ": init_laufnr vor Schlaufe"
  For lnglaufnr = funlngnextlaufnr() To funanzmitarb()
    objstartcell.Value = lnglaufnr
    Set objstartcell = objstartcell.Offset(1, 0)
  Next
  'Debug.Print Timer & ": init_laufnr nach Schlaufe"
  
End Sub


'*******************************************************************
'Generiert Teil von Formel in init_data_form
Function funZahlGroesserNull(ByVal celladdress As String) As String
  funZahlGroesserNull = "IF(ISNUMBER(" & celladdress & ")," & celladdress & ">0,FALSE)"
End Function


'*******************************************************************
'Initialisiert das data_form
' - Bedingte Formatierung
' - Gueltigkeitspruefung
' - Flag
' ab Version 2.5 via Parameter mitgeben, ob data_form_col_buwaz und data_form_col_jahresarbeitszeit
'   bei Import nicht ueberschrieben wird
' -> nur nichtleere Felder fuellen
' Aufgerufen von
' - btnimporttext_Click
' - btnimportlse_Click
' - btninputtable_Click
Sub init_data_form(Optional ByVal isImport As Boolean = False)
  'Debug.Print Timer & ": init_data_form gestartet"
  Call updateActiveProc("Hauptmodul.init_data_form")
  
  Dim bytrowobligatorisch As Byte 'Zeilennummer der Zeile obligatorisch (aus Name)
  Dim lnganzdatarow As Long 'Anzahl zu initialisierende Datenreihen
  Dim lngRowFirst As Long 'neu
  Dim lngRowLast As Long
  Dim strbedcolu As String 'Bedingung fuer Gueltigkeit in Spalte U
  Dim strcolanfniveau As String 'data_form_col_anfniveau ab V2.5 Spalte J
  Dim strColBgrad As String
  Dim strcolbuwaz As String
  Dim strcolfilter As String 'Spaltenbuchstabe fuer Spalte Filter (aus benanntem Bereich)
  Dim strcolfirst As String 'Spaltenbuchstabe der letzten auszufuellenden Spalte
  Dim strcolbruttolohn As String
  Dim strcolgrundgesamtheit As String
  Dim strcolgesverdienst As String
  Dim strcoljobmanual As String 'data_form_col_jobmanual ab V2.5 Spalte I
  Dim strcolskill As String 'fuer die 3 berechneten Skillspalten
  Dim strcolskilllist As String 'data_form_col_skilllist ab V2.5 Spalte U
  Dim strcolskillcalculated As String 'data_form_col_skillcalculated ab V2.5 Spalte V
  Dim strisblank As String
  Dim strlohninkl As String
  Dim strrangehlp As String 'Hilfsvariable zum Zwischenspeichern eines Range, z.B. A1:C3
  
  Dim objCell As Range
  Dim objstartcell As Range
  Dim objsheetdata As Worksheet
  
  Dim strlocalfunctionabs As String
  Dim strlocalfunctionand As String
  Dim strStundenlohnAnzstunden As String
  Dim strlistseparator As String
  
  '--------------------------------------------------------------
  ' Initialisierungen
  Set objsheetdata = ThisWorkbook.Sheets(STR_SH_DATA_FORM)
  Call blatt_einblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  
  objsheetdata.Activate
  'Blattschutz aufheben
  objsheetdata.Unprotect Password:=changeToNumberString("s")
    
  Set objstartcell = objsheetdata.Range(STR_DATA_FORM_SD)
  lnganzdatarow = funanzmitarb() + INT_MARGE
  
  'ab V2.5 letzte blaue Spalte, Buwaz, Skilllevel und gesverdienst separat behandelt
  strcolfirst = Left(STR_DATA_FORM_SD, 1)
  lngRowFirst = objstartcell.Row
  lngRowLast = lngRowFirst + funanzmitarb() + INT_MARGE - 1
  
  '--------------------------------------------------------------
  ' Bedingte Formatierung
  
  'Select ist noetig, damit die Zellbezuege in Bedingter Formatierung stimmen
  objstartcell.Select
  'Achtung: Funktionsnamen muessen lokalisiert werden!
  bytrowobligatorisch = ThisWorkbook.Names("data_form_row_obligatorisch").RefersToRange.Row
  strisblank = strlocalfunction("isblank", "A1")
  
  'V2.5
  'Ab 3.0.7 obligatorische Spalten ohne Wert dunkelorange ausser Verdienstspalten
  With objsheetdata.Range(STR_DATA_FORM_SD & ":" & funstrcol_byname("data_form_col_bemerkungen") & lngRowLast & "," _
    & funstrcol_byname("data_form_col_skillcalculated") & lngRowFirst & ":" & funstrcol_byname("data_form_col_gesverdienst") & lngRowLast)
    .FormatConditions.delete
    'Formel 1: Obligatorische Zelle leer (d.h. * in Zeile 11) ? -> Formel: =(ISTLEER(A$11)*1=0)*ISTLEER(A15)
    'Formel mit *1 damit Lokalisierung von True, False, UND vermieden wird
    'Ab 3.0.7 dunkelorange
    .FormatConditions.Add Type:=xlExpression, Formula1:="=(" _
      & strisblank & "(" & strcolfirst & "$" & bytrowobligatorisch & ")*1=0)*" & _
      strisblank & "(" & STR_DATA_FORM_SD & ")+" & strlocalfunction("iserror", "A1") & "(" & STR_DATA_FORM_SD & ")<>0"
    .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
    
    'neue Formatierung fuer nichtobligatorische leere Zellen, z.B. Spalte Grundgesamtheit
    If BLN_FORMATCONDITIONS_FORMULA Then
      .FormatConditions.Add Type:=xlExpression, Formula1:="=(" _
        & strisblank & "(" & strcolfirst & "$" & bytrowobligatorisch & ")*1=1)*" & _
        strisblank & "(" & STR_DATA_FORM_SD & ")"
    End If
    
    'Formel 2: =datengueltig(A15) nicht mehr verwenden
    If Not BLN_FORMATCONDITIONS_FORMULA Then
      .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=(datengueltig(" & STR_DATA_FORM_SD & ")*1)=0"
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
    End If
  End With
  
  'Ab 3.0.7 Verdienstspalten ohne Wert hellorange
  'Wie oben, aber mit hlp_const_c_data_blank
  strcolbruttolohn = funstrcol_byname("data_form_col_bruttolohn")
  With objsheetdata.Range(funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst _
      & ":" & funstrcol_byname("data_form_col_sonderz") & lngRowLast)
    .FormatConditions.delete
    'Formel 1: Obligatorische Zelle leer (d.h. * in Zeile 11) ? -> Formel: =(ISTLEER(A$11)*1=0)*ISTLEER(A15)
    'Formel mit *1 damit Lokalisierung von True, False, UND vermieden wird
    'Ab 3.0.7 dunkelorange
    .FormatConditions.Add Type:=xlExpression, Formula1:="=(" _
      & strisblank & "(" & strcolbruttolohn & "$" & bytrowobligatorisch & ")*1=0)*" & _
      strisblank & "(" & strcolbruttolohn & lngRowFirst & ")+" & strlocalfunction("iserror", "A1") & "(" & strcolbruttolohn & lngRowFirst & ")<>0"
    .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_blank")
    
    'neue Formatierung fuer nichtobligatorische leere Zellen, z.B. Spalte Grundgesamtheit
    If BLN_FORMATCONDITIONS_FORMULA Then
      .FormatConditions.Add Type:=xlExpression, Formula1:="=(" _
        & strisblank & "(" & strcolbruttolohn & "$" & bytrowobligatorisch & ")*1=1)*" & _
        strisblank & "(" & strcolbruttolohn & lngRowFirst & ")"
    End If
    
    'Formel 2: =datengueltig(A15) nicht mehr verwenden
    If Not BLN_FORMATCONDITIONS_FORMULA Then
      .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=(datengueltig(" & strcolbruttolohn & lngRowFirst & ")*1)=0"
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_blank")
    End If
  End With
  
  'Bedingte Formatierung fuer Spalte gesverdienst
  'alte Formatierung vor 11/2014
  strcolgesverdienst = funstrcol_byname("data_form_col_gesverdienst") 'Spaeter noch fuer Formel verwendet!
  If Not BLN_FORMATCONDITIONS_FORMULA Then
    With objsheetdata.Range(strcolgesverdienst & lngRowFirst & ":" & strcolgesverdienst & lngRowLast)
      .Select
      .FormatConditions.delete
      'Formel 1: =datengueltig(A15)
      'ev. hier Formel, die Absturz bewirkt
      .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=(datengueltig(" & strcolgesverdienst & lngRowFirst & ")*1)=0"
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
    End With
  End If
  
  '--------------------------------------------------------------
  ' V2.5 Mehrfach verwendete Variablen
  strcoljobmanual = funstrcol_byname("data_form_col_jobmanual") 'F
  strcolanfniveau = funstrcol_byname("data_form_col_anfniveau") 'G ab 2.5 Kompetenzniveau
  strcolskilllist = funstrcol_byname("data_form_col_skilllist") 'H
  strcolskillcalculated = funstrcol_byname("data_form_col_skillcalculated") 'I
  
  'Bedingte Formatierung fuer Spalte skillcalculated ab V2.5 ((((
  '=UND($U16>0;$V16>0;ABS($U16-$V16)>1)
  strlocalfunctionabs = strlocalfunction("abs", "A1")
  strlocalfunctionand = strlocalfunction("and", "A1")
  strlistseparator = Application.International(xlListSeparator)
  'Logib 3.1.1 27.03.2018 ohne Select funktioniert der Code nicht in Excel 2016 Mac, mit Select nicht in Excel 2007 Win
  If Application.OperatingSystem Like "*Mac*" And Val(Application.Version) >= 16 Then
    objsheetdata.Range(strcolskillcalculated & lngRowFirst & ":" & strcolskillcalculated & lngRowLast).Select
    'With objsheetdata.Range(strcolskillcalculated & lngRowFirst & ":" & strcolskillcalculated & lngRowLast)
    With Selection
      'SR 18.12.2018 ; mit strlistseparator ersetzt
      .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=" & strlocalfunctionand & "($" & strcolskilllist & lngRowFirst & _
            ">0" & strlistseparator & "$" & strcolskillcalculated & lngRowFirst & ">0" & strlistseparator & strlocalfunctionabs & "($" & strcolskilllist & _
            lngRowFirst & "-$" & strcolskillcalculated & lngRowFirst & ")>0)"
      
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_blank")
    End With
  Else
    With objsheetdata.Range(strcolskillcalculated & lngRowFirst & ":" & strcolskillcalculated & lngRowLast)
      'On Error Resume Next
      'SR 18.12.2018 ; mit strlistseparator ersetzt
      .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=" & strlocalfunctionand & "($" & strcolskilllist & lngRowFirst & _
            ">0" & strlistseparator & "$" & strcolskillcalculated & lngRowFirst & ">0" & strlistseparator & strlocalfunctionabs & "($" & strcolskilllist & _
            lngRowFirst & "-$" & strcolskillcalculated & lngRowFirst & ")>0)"
      'Debug.Print err.Number
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_blank")
    End With
  End If
  'Bedingte Formatierung fuer data_form_col_bgrad und data_form_col_bezstunden
  'Anforderung ab dem 8.10.2013 Mail von Christine Masserey
  'nicht umgesetzt, gefaehrdet Stabilitaet
  '=NICHT(ODER(UND(M16>0;M16<=hlp_const_c_bezstundenmax);L16>0))
  '=NOT(OR(AND(M16>0,M16<=hlp_const_c_bezstundenmax),L16>0))
  'Ab 3.0.7 ungueltig, wenn bgrad und bezstunden ausgefuellt
  Dim strcolBezStunden
  strcolBezStunden = funstrcol_byname("data_form_col_bezstunden")
  strColBgrad = funstrcol_byname("data_form_col_bgrad")
  With objsheetdata.Range(strColBgrad & lngRowFirst & ":" & strColBgrad & lngRowLast)
    .FormatConditions.Add Type:=xlExpression, Formula1:= _
        "=" & strcolBezStunden & lngRowFirst & "*" & strColBgrad & lngRowFirst & "<>0"
    .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
  End With
  With objsheetdata.Range(strcolBezStunden & lngRowFirst & ":" & strcolBezStunden & lngRowLast)
    .FormatConditions.Add Type:=xlExpression, Formula1:= _
        "=" & strcolBezStunden & lngRowFirst & "*" & strColBgrad & lngRowFirst & "<>0"
    .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
  End With
  
  'Debug.Print Timer & ": init_data_form nach bedingter Formatierung"
  
  
  '--------------------------------------------------------------
  'Gesperrte Zellen aufheben inkl. Spalte BUWAZ V2.5
  'Ab Logib 2.5 ohne berechnete Spalten H und I
  'Ab Logib 3.1.0 5 Spalten Zusatz1 - 5
  objsheetdata.Range(STR_DATA_FORM_SD & ":" _
    & funstrcol_byname("data_form_col_anfniveau") & lngRowLast & "," _
    & funstrcol_byname("data_form_col_berstellung") & lngRowFirst & ":" _
    & funstrcol_byname("data_form_col_zusatz5") & lngRowLast).Locked = False
  
  '--------------------------------------------------------------
  'Formatierung
  
  'Dezimalzahl einstellig fuer Spalte dienstjahre
  objsheetdata.Range(funstrcol_byname("data_form_col_dienstjahre") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_dienstjahre") & lngRowLast).NumberFormat = "#,##0.0"
  
  'Zahlen zweistellig fuer Spalte bgrad und bezstunden
  objsheetdata.Range(funstrcol_byname("data_form_col_bgrad") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_bezstunden") & lngRowLast).NumberFormat = "#,##0.00"
  
  'Tausendertrennzeichen fuer alle Lohndaten
  objsheetdata.Range(funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_sonderz") & lngRowLast).NumberFormat = "#,##0"
  
  'Zahlen einstellig und Tausendertrennzeichen fuer buwaz und Jahresarbeitszeit
  objsheetdata.Range(funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_jahresarbeitszeit") & lngRowLast).NumberFormat = "#,##0.0"
  
  '--------------------------------------------------------------
  ' Gueltigkeitspruefung
  'Achtung: fuer Gueltigkeitspruefung muss Blatt aktiviert sein
  
  Call set_all_validations(objsheetdata, lngRowFirst, lngRowLast)
  'Debug.Print Timer & ": init_data_form nach Gueltigkeitspruefung"
  
    
  '--------------------------------------------------------------
  ' V2.5 Formel fuer skilllist, d.h. in Liste nachgeschlagenen Skill Level
  ' =IF(ISBLANK(F16),0,VLOOKUP(F16,joblist_lst,2,FALSE))
  ' am 13.01.2016 nach Spaltenaenderung ueberarbeitet
  strcolskill = funstrcol_byname("data_form_col_skilllist")
  objsheetdata.Range(strcolskill & lngRowFirst & ":" & strcolskill & lngRowLast).Value = _
    "=IF(ISBLANK(" & strcoljobmanual & lngRowFirst & "),0,VLOOKUP(" _
    & strcoljobmanual & lngRowFirst & ",joblist_lst,2,FALSE))"
    
  '--------------------------------------------------------------
  ' V2.5 Formel fuer skillcalculated, d.h. manueller oder nachgeschlagener Skill Level
  ' =IF(OR(ISBLANK(G13),NOT(ISNUMBER(G13))),IF(ISNUMBER(H13),H13,0),G13)*1
  ' =IF(OR(ISBLANK(G16),NOT(ISNUMBER(G16))),H16,G16)*1
  ' am 13.01.2016 nach Spaltenaenderung ueberarbeitet
  strcolskill = funstrcol_byname("data_form_col_skillcalculated")
  objsheetdata.Range(strcolskill & lngRowFirst & ":" & strcolskill & lngRowLast).Value = _
    "=IF(OR(ISBLANK(" & strcolanfniveau & lngRowFirst & "),NOT(ISNUMBER(" & strcolanfniveau & lngRowFirst _
    & "))),IF(ISNUMBER(" & funstrcol_byname("data_form_col_skilllist") & lngRowFirst _
    & ")," & funstrcol_byname("data_form_col_skilllist") & lngRowFirst & ",0)," & strcolanfniveau & lngRowFirst & ")*1"
  
  '--------------------------------------------------------------
  ' Werte fuer Spalte buwaz
  ' am 13.01.2016 nach Spaltenaenderung ueberarbeitet
  ' ab Logib 2.5 bei Import nur leere Zellen mit diesem Wert fuellen
  strcolbuwaz = funstrcol_byname("data_form_col_buwaz")
  If isImport Then
    For Each objCell In objsheetdata.Range(strcolbuwaz & lngRowFirst & ":" & strcolbuwaz & lngRowLast)
      If (IsEmpty(objCell)) Then
        objCell.Value = funvarvalue_byname("data_head_c_buwaz")
      End If
    Next
  Else
    objsheetdata.Range( _
      strcolbuwaz & lngRowFirst & ":" & strcolbuwaz & lngRowLast).Value = funvarvalue_byname("data_head_c_buwaz")
  End If
  
  '--------------------------------------------------------------
  ' Werte fuer Spalte jahresarbeitszeit
  ' am 13.01.2016 nach Spaltenaenderung neu hinzugefuegt
  ' ab Logib 2.5 bei Import nur leere Zellen mit diesem Wert fuellen
  strcolbuwaz = funstrcol_byname("data_form_col_jahresarbeitszeit")
  If isImport Then
    For Each objCell In objsheetdata.Range(strcolbuwaz & lngRowFirst & ":" & strcolbuwaz & lngRowLast)
      If (IsEmpty(objCell)) Then
        objCell.Value = funvarvalue_byname("data_head_c_stundenlohn_anzstunden")
      End If
    Next
  Else
    objsheetdata.Range( _
      strcolbuwaz & lngRowFirst & ":" & strcolbuwaz & lngRowLast).Value = funvarvalue_byname("data_head_c_stundenlohn_anzstunden")
  End If
  
  '--------------------------------------------------------------
  ' Formel fuer Gesamtverdienst
  '=IF(AND(IF(ISNUMBER(K16),K16>0,FALSE),ISNUMBER(M16*1),ISNUMBER(N16*1),ISNUMBER(O16*1),
  'ISNUMBER(P16*1),IF(ISNUMBER(Q16),Q16>0,FALSE)),
  'SUM(M16:P16)*100*hlp_const_c_defaulthours/(K16*Q16),
  'IF(AND(IF(ISNUMBER(L16),L16>0,FALSE),
  'ISNUMBER(M16*1),ISNUMBER(N16*1),ISNUMBER(O16*1),ISNUMBER(P16*1),IF(ISNUMBER(R16),R16>0,FALSE)),
  'SUM(M16:P16)*hlp_const_c_defaulthours*R16/(data_head_c_buwaz*L16*12),0))
  ' am 13.01.2016 nach Spaltenaenderung ueberarbeitet
  
  'bereits oben definiert strcolbgrad = funstrcol_byname("data_form_col_bgrad")
  strlohninkl = "SUM(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & ":" & _
        funstrcol_byname("data_form_col_sonderzahlungen") & lngRowFirst & ")"
  
  'Formel fuer Jahresarbeitsstd aus R14 oder data_head
  'IF(LEFT(data_head_c_jahrarbzeitabw,1)="2",R14,data_head_c_stundenlohn_anzstunden)
  strStundenlohnAnzstunden = "IF(LEFT(data_head_c_jahrarbzeitabw,1)=""2""," _
    & funstrcol_byname("data_form_col_jahresarbeitszeit") & lngRowFirst & ",data_head_c_stundenlohn_anzstunden)"
  
  'Anpassung 27.05.2015 und 21.10.2015 ISNUMBER, falls Zahl mit falschem Dezimalzeichen daherkommt
  'Anpassung 25.01.2019 Standardisierung auf data_head_c_buwaz statt hlp_const_c_defaulthours
'  objsheetdata.Range(strcolgesverdienst & lngRowFirst & ":" & strcolgesverdienst & lngRowLast).Value = _
'    "=IF(AND(" & funZahlGroesserNull(strcolbgrad & lngRowFirst) & "," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*1)," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*1)," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*1)," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*1)," & _
'    funZahlGroesserNull(funstrcol_byname("data_form_col_buwaz") & lngRowFirst) & ")," & _
'    strlohninkl & "*100*hlp_const_c_defaulthours/(" & strcolbgrad & lngRowFirst & _
'    "*" & funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ")," & _
'    "IF(AND(" & funZahlGroesserNull(funstrcol_byname("data_form_col_bezstunden") & lngRowFirst) & "," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*1)," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*1)," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*1)," & _
'    "ISNUMBER(" & funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*1)," & _
'    funZahlGroesserNull(strStundenlohnAnzstunden) & ")," & _
'    strlohninkl & "*hlp_const_c_defaulthours*" & strStundenlohnAnzstunden & "/" & _
'    "(data_head_c_buwaz*" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & "*12),0))"

  objsheetdata.Range(strcolgesverdienst & lngRowFirst & ":" & strcolgesverdienst & lngRowLast).Value = _
    "=IF(AND(" & funZahlGroesserNull(strColBgrad & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*1)," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*1)," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*1)," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(funstrcol_byname("data_form_col_buwaz") & lngRowFirst) & ")," & _
    strlohninkl & "*100*IF(LEFT(data_head_c_jahrarbzeitabw,1)=""2""," & _
    funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ",data_head_c_buwaz)/(" & strColBgrad & lngRowFirst & _
    "*" & funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ")," & _
    "IF(AND(" & funZahlGroesserNull(funstrcol_byname("data_form_col_bezstunden") & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*1)," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*1)," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*1)," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(strStundenlohnAnzstunden) & ")," & _
    strlohninkl & "*" & strStundenlohnAnzstunden & "/" & _
    "(" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & "*12),0))"
  
  objsheetdata.Range(strcolgesverdienst & lngRowFirst & ":" & _
    strcolgesverdienst & lngRowLast).NumberFormat = "#,##0"

  'Standardisierte Lohnbestandteile %%%%
  '=IF(AND(IF(ISNUMBER($K14),$K14>0,FALSE),ISNUMBER(M14*1),IF(ISNUMBER($Q14),$Q14>0,FALSE)),
  'M14*100*IF(LEFT(data_head_c_jahrarbzeitabw,1)="2", $Q14, data_head_c_buwaz)/($K14*$Q14),
  'IF(AND(IF(ISNUMBER($L14),$L14>0,FALSE),ISNUMBER(M14*1),
  'IF(ISNUMBER(IF(LEFT(data_head_c_jahrarbzeitabw,1)="2",$R14,data_head_c_stundenlohn_anzstunden)),
  'IF(LEFT(data_head_c_jahrarbzeitabw,1)="2",$R14,data_head_c_stundenlohn_anzstunden)>0,FALSE)),
  'M14*IF(LEFT(data_head_c_jahrarbzeitabw,1)="2",$R14,data_head_c_stundenlohn_anzstunden)/($L14*12),0))

  objsheetdata.Range(funstrcol_byname("data_form_col_bruttolohn_standard") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_bruttolohn_standard") & lngRowLast).Value = _
    "=IF(AND(" & funZahlGroesserNull(strColBgrad & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(funstrcol_byname("data_form_col_buwaz") & lngRowFirst) & ")," & _
    funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*100*IF(LEFT(data_head_c_jahrarbzeitabw,1)=""2""," & _
    funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ",data_head_c_buwaz)/(" & strColBgrad & lngRowFirst & _
    "*" & funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ")," & _
    "IF(AND(" & funZahlGroesserNull(funstrcol_byname("data_form_col_bezstunden") & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(strStundenlohnAnzstunden) & ")," & _
    funstrcol_byname("data_form_col_bruttolohn") & lngRowFirst & "*" & strStundenlohnAnzstunden & "/" & _
    "(" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & "*12),0))"

  'Standardisierte Zulagen
  objsheetdata.Range(funstrcol_byname("data_form_col_zulagen_standard") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_zulagen_standard") & lngRowLast).Value = _
    "=IF(AND(" & funZahlGroesserNull(strColBgrad & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(funstrcol_byname("data_form_col_buwaz") & lngRowFirst) & ")," & _
    funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*100*IF(LEFT(data_head_c_jahrarbzeitabw,1)=""2""," & _
    funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ",data_head_c_buwaz)/(" & strColBgrad & lngRowFirst & _
    "*" & funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ")," & _
    "IF(AND(" & funZahlGroesserNull(funstrcol_byname("data_form_col_bezstunden") & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(strStundenlohnAnzstunden) & ")," & _
    funstrcol_byname("data_form_col_zulagen") & lngRowFirst & "*" & strStundenlohnAnzstunden & "/" & _
    "(" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & "*12),0))"

  'Standardisierter 13. Monatslohn
  objsheetdata.Range(funstrcol_byname("data_form_col_13monatslohn_standard") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_13monatslohn_standard") & lngRowLast).Value = _
    "=IF(AND(" & funZahlGroesserNull(strColBgrad & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(funstrcol_byname("data_form_col_buwaz") & lngRowFirst) & ")," & _
    funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*100*IF(LEFT(data_head_c_jahrarbzeitabw,1)=""2""," & _
    funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ",data_head_c_buwaz)/(" & strColBgrad & lngRowFirst & _
    "*" & funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ")," & _
    "IF(AND(" & funZahlGroesserNull(funstrcol_byname("data_form_col_bezstunden") & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(strStundenlohnAnzstunden) & ")," & _
    funstrcol_byname("data_form_col_13monatslohn") & lngRowFirst & "*" & strStundenlohnAnzstunden & "/" & _
    "(" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & "*12),0))"

  'Sonderzahlungen
  objsheetdata.Range(funstrcol_byname("data_form_col_sonderz_standard") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_sonderz_standard") & lngRowLast).Value = _
    "=IF(AND(" & funZahlGroesserNull(strColBgrad & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(funstrcol_byname("data_form_col_buwaz") & lngRowFirst) & ")," & _
    funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*100*IF(LEFT(data_head_c_jahrarbzeitabw,1)=""2""," & _
    funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ",data_head_c_buwaz)/(" & strColBgrad & lngRowFirst & _
    "*" & funstrcol_byname("data_form_col_buwaz") & lngRowFirst & ")," & _
    "IF(AND(" & funZahlGroesserNull(funstrcol_byname("data_form_col_bezstunden") & lngRowFirst) & "," & _
    "ISNUMBER(" & funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*1)," & _
    funZahlGroesserNull(strStundenlohnAnzstunden) & ")," & _
    funstrcol_byname("data_form_col_sonderz") & lngRowFirst & "*" & strStundenlohnAnzstunden & "/" & _
    "(" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & "*12),0))"


  '--------------------------------------------------------------
  ' Formeln fuer Filtervariable regr2
  
 
  'Spalte fuer Filter erweitert fuer regr2
  '=allezellengueltig(A16:E16,I16:L16)*
  'IF(AND(S16>=hlp_const_c_gesverdienstmin,S16<=hlp_const_c_bruttolohnmax),1,0)
  strcolfilter = funstrcol_byname("data_form_col_filter_erw")
  strrangehlp = strcolfilter & lngRowFirst & ":" & strcolfilter & lngRowLast
  
  '01.12.2017 ab 3.0.7 darf nur entweder bgrad oder bezstunden ausgefuellt sein, nicht beides
  'ausserdem darf dienstjahre nicht mehr leer bleiben
'  strbedcolu = "IF(AND(OR(ISBLANK(" & funstrcol_byname("data_form_col_grundgesamtheit") & lngRowFirst & _
'    ")," & funstrcol_byname("data_form_col_grundgesamtheit") & lngRowFirst & "=1)," & _
'    funstrcol_byname("data_form_col_gesverdienst") & lngRowFirst & _
'    ">=hlp_const_c_gesverdienstmin," & funstrcol_byname("data_form_col_gesverdienst") & lngRowFirst & _
'    "<=hlp_const_c_bruttolohnmax," & _
'    "NOT(ISBLANK(" & funstrcol_byname("data_form_col_dienstjahre") & lngRowFirst & "))," & _
'    funstrcol_byname("data_form_col_bgrad") & lngRowFirst & "*" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst _
'    & "= 0),1,0)"
  strbedcolu = "IF(AND(OR(ISBLANK(" & funstrcol_byname("data_form_col_grundgesamtheit") & lngRowFirst & _
    ")," & funstrcol_byname("data_form_col_grundgesamtheit") & lngRowFirst & "=1)," & _
    funstrcol_byname("data_form_col_gesverdienst") & lngRowFirst & ">0," & _
    "NOT(ISBLANK(" & funstrcol_byname("data_form_col_dienstjahre") & lngRowFirst & "))," & _
    funstrcol_byname("data_form_col_bgrad") & lngRowFirst & "*" & funstrcol_byname("data_form_col_bezstunden") & lngRowFirst _
    & "= 0),1,0)"
  objsheetdata.Range(strrangehlp).Formula = _
    "=allezellengueltig(" & STR_DATA_FORM_SD & ":" & _
    funstrcol_byname("data_form_col_ausbildung") & lngRowFirst & "," & _
    funstrcol_byname("data_form_col_skillcalculated") & lngRowFirst & ":" & _
    funstrcol_byname("data_form_col_bezstunden") & lngRowFirst & ")*" & strbedcolu
    
  'Filterspalte bedingte Formatierung
  objsheetdata.Range(strrangehlp).Font.Bold = True
  objsheetdata.Range(strrangehlp).FormatConditions.delete
  
  'Ab 3.0.7 grau, wenn Grundgesamtheit zwischen 2 und 5 =UND(S14>=2;S14<=5)
  strcolgrundgesamtheit = funstrcol_byname("data_form_col_grundgesamtheit")
  'SR 18.12.2018 ; mit strlistseparator ersetzt
  objsheetdata.Range(strrangehlp).FormatConditions.Add Type:=xlExpression, _
    Operator:=xlEqual, Formula1:="=" & strlocalfunctionand & "(" & strcolgrundgesamtheit & lngRowFirst & ">=" _
    & Application.WorksheetFunction.Min(ThisWorkbook.Names("hlp_const_vec_grundgesamtheit").RefersToRange) + 1 _
    & strlistseparator & strcolgrundgesamtheit & lngRowFirst & "<=" _
    & Application.WorksheetFunction.Max(ThisWorkbook.Names("hlp_const_vec_grundgesamtheit").RefersToRange) & ")"
  objsheetdata.Range(strrangehlp).FormatConditions(objsheetdata.Range(strrangehlp).FormatConditions.Count).Interior.Color = _
    funvarvalue_byname("hlp_const_c_valid_exclusion")
  
  'Filterspalte rot falls 0
  objsheetdata.Range(strrangehlp).FormatConditions.Add Type:=xlCellValue, _
    Operator:=xlEqual, Formula1:="0"
  objsheetdata.Range(strrangehlp).FormatConditions(objsheetdata.Range(strrangehlp).FormatConditions.Count).Interior.Color = _
    funvarvalue_byname("hlp_const_c_data_filter0")
    
  '--------------------------------------------------------------
  'Schaltflaechen fuer Import ausblenden (funktioniert auch bei geschuetztem Blatt)
  ' funktioniert nicht fuer die aufrufende Schaltflaeche, weil das ganze mit Onclick gestartet wird!!!
  ' Workaround: aufrufende Schaltflaeche disablen
  Call togglebuttonsvisible(False)
    
  'Ersetzt 2. Bedingung in bedingter Formatierung
  If Not BLN_FORMATCONDITIONS_FORMULA Then
    Call format_all_invalid_cells
  End If
  
  'Schutz wieder einschalten
  Call protectSheet(STR_SH_DATA_FORM, True)
End Sub


'*******************************************************************
'Initialisiert das Formular fuer Importeinstellungen
Sub frmimport_initfields()
  Call updateActiveProc("Hauptmodul.frmimport_initfields")
  Dim intCounter
  Dim objcontrol As Control
  Dim strSprache As String
  
  frmimport.Caption = strtranslate("frmimport.caption")
  For Each objcontrol In frmimport.Controls
    'Felder loeschen
    'Debug.Print objcontrol.Name
    If TypeName(objcontrol) = "TextBox" Then
      'ab Version 2.4 auf Wunsch des EBG Geschlecht mit 1 und 2 vorbelegt
      If objcontrol.name = "txtgeschlecht_0" Then
        frmimport.Controls(objcontrol.name).Value = "1"
      ElseIf objcontrol.name = "txtgeschlecht_1" Then
        frmimport.Controls(objcontrol.name).Value = "2"
      Else
        frmimport.Controls(objcontrol.name).Value = Null
      End If
    ElseIf TypeName(objcontrol) = "ComboBox" Then
      frmimport.Controls(objcontrol.name).Clear
    End If
    
    'Labels und Buttons initialisieren
    If InStr(objcontrol.name, "lbl") > 0 Or InStr(objcontrol.name, "btn") > 0 _
      Or InStr(objcontrol.name, "frm") > 0 Or InStr(objcontrol.name, "opt") > 0 Then
      frmimport.Controls(objcontrol.name).Caption = _
        strtranslate("frmimport." & objcontrol.name)
    End If
  Next
      
End Sub


'*******************************************************************
'Formular fuer Importeinstellungen anzeigen
Sub frmimport_anzeigen()
  Call updateActiveProc("Hauptmodul.frmimport_anzeigen")
  Call frmimport_initfields
  frmimport.Show (vbModal)
End Sub


Attribute VB_Name = "Hilfsmakros"
Option Explicit
Option Private Module
  
'===================================================================
'Kleine Makros mit mehrfach verwendeten Routinen, z.B. Blatt einblenden


'*******************************************************************
'Ueberprueft, ob Arbeitsmappe freigegeben ist. Die meisten Makros funktionieren nicht,
'weil die Freigabe z.B. dem Blattschutz in die Quere kommt
Function blnNichtFreigegeben() As Boolean
  Dim blnresult
  blnresult = True
  If ThisWorkbook.MultiUserEditing = True Then
    blnresult = False
    MsgBox strtranslate("msgbox_freigabe"), vbOKOnly + vbCritical
  End If
  blnNichtFreigegeben = blnresult
End Function


'*******************************************************************
'Hilfsfunktion zum Ein- und Ausblenden mehrerer Buttons auf data_head
Sub togglebuttonsvisible(ByVal isVisible As Boolean)
  Dim blnProtecteddh, blnProtecteddf As Boolean
  
  blnProtecteddh = ThisWorkbook.Sheets(STR_SH_DATA_HEAD).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_DATA_HEAD).Unprotect Password:=changeToNumberString("s")

  blnProtecteddf = ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")

  'Enabled existiert nicht fuer Formularsteuerelemente nicht, ist aber auch nicht noetig
  ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btnimporttext").Visible = isVisible
  ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btnimportlse").Visible = isVisible
  'ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btninputtable").Visible = isvisible
  If blnIsControlForm() Then
    'Im Kontrollformular nie sichtbar
    ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btndeletedata").Visible = False
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btndeletedatadf").Visible = False
  Else
    ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btndeletedata").Visible = Not isVisible
    'Immer sichtbar, ausser im Kontrollformular
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btndeletedatadf").Visible = True
  End If
  
  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(STR_SH_DATA_HEAD, blnProtecteddh)
  
  Call protectSheet(STR_SH_DATA_FORM, blnProtecteddf)
End Sub

'*******************************************************************
'Hilfsfunktion zum Ein- und Ausblenden mehrerer Buttons
Sub toggleArrayOfButtons(ByVal strSheet As String, ByRef objArray() As String, ByVal isVisible As Boolean)
  On Error Resume Next 'noetig, weil Button oder Translation fehlen koennte
  Dim blnProtected As Boolean
  Dim strButton 'As String
  
  blnProtected = ThisWorkbook.Sheets(strSheet).ProtectContents
  ThisWorkbook.Worksheets(strSheet).Unprotect Password:=changeToNumberString("s")
  
  'Schaltflaechen ein- oder ausblenden
  For Each strButton In objArray()
    ThisWorkbook.Sheets(strSheet).Shapes(strButton).Visible = isVisible
    ThisWorkbook.Sheets(strSheet).Shapes(strButton).TextFrame _
      .Characters.Text = strtranslate(strSheet & ".lbl" & strButton)
  Next
 
  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(strSheet, blnProtected)

End Sub

'*******************************************************************
'Hilfsfunktion zum Ein- und Ausblenden eines einzelnen Buttons
'Erstellt:         04.02.2016
'Letzte Aenderung: 04.02.2016
Sub toggleSingleButton(ByVal strSheet As String, ByVal strButton As String, ByVal blnIsVisible As Boolean)
  Dim objArray(1 To 1) As String
  objArray(1) = strButton
  Call toggleArrayOfButtons(strSheet, objArray(), blnIsVisible)
End Sub

'*******************************************************************
'Hilfsfunktion zum Ein- und Ausblenden von Buttons abhaengig davon, ob bereits ausgewertet
'Ab 04.02.2016
Sub togglebuttonsauswertung()
  Dim isVisible As Boolean
  isVisible = Not funvarvalue_byname("hlp_const_c_ausgewertet")
  
  'Blatt data_form
  If blnIsControlForm() Then
    'Im Kontrollformular immer ausgeblendet
    Call toggleSingleButton(STR_SH_DATA_FORM, "btnauswertung", False)
  Else
    Call toggleSingleButton(STR_SH_DATA_FORM, "btnauswertung", isVisible)
  End If
  
  'Blatt joblist
  Dim objArray2(1 To 3) As String
  objArray2(1) = "btnjoblist"
  objArray2(2) = "btnjoblistimport"
  objArray2(3) = "btnjoblistdelete"
  Call toggleArrayOfButtons(STR_SH_JOBLIST, objArray2, isVisible)

End Sub


'*******************************************************************
'Ergaenzt einen String mit Trennstring, wenn nicht leer, z.B. Komma
Function funstringmittrenn(ByVal strteststring As String, ByVal strtrennstring As String) As String
  Call updateActiveProc("Hilfsmakros.funstringmittrenn")
  If strteststring <> "" Then
    funstringmittrenn = strteststring & strtrennstring
  Else
    funstringmittrenn = ""
  End If
End Function


'*******************************************************************
'Schaltet automatische Berechnung aus
Sub berechnung_ausschalten()
  Call updateActiveProc("Hilfsmakros.berechnung_ausschalten")
  Application.Calculation = xlCalculationManual
  Application.CalculateBeforeSave = False
End Sub


'*******************************************************************
'Schaltet automatische Berechnung ein
Sub berechnung_einschalten()
  Call updateActiveProc("Hilfsmakros.berechnung_einschalten")
  'debug.print straktiveprozedur
  Application.Calculate
  Application.Calculation = Excel.XlCalculation.xlCalculationAutomatic
  'debug.print "Error in Hilfsmakros.berechnung_einschalten? " & Err.Number
  
  'Application.CalculateBeforeSave = True
End Sub


'*******************************************************************
'Arbeitsmappenschutz einschalten
Sub mappenschutz_ein()
  ThisWorkbook.Protect changeToNumberString("m"), True, False
End Sub


'*******************************************************************
'Arbeitsmappenschutz einschalten
Sub mappenschutz_aus()
  On Error Resume Next
  ThisWorkbook.Unprotect changeToNumberString("m")
End Sub

'*******************************************************************
'Blaetter in einem Array von Namen gleichzeitig ein- oder ausblenden
Sub blaetterEinAusblenden(ByRef objArray() As String, ByVal blnIsVisible As Boolean)
  Dim strSheetName
  Call updateActiveProc("Hilfsmakros.blaetterEinAusblenden")
  'debug.print straktiveprozedur & " Sheet " & strsheetname
  mappenschutz_aus
  For Each strSheetName In objArray()
    ThisWorkbook.Sheets(strSheetName).Visible = blnIsVisible
  Next
  mappenschutz_ein

End Sub

Sub testBlaetterEinAusblenden()
  Dim objArray(1 To 3) As String
  objArray(1) = "title"
  objArray(2) = "intro"
  objArray(3) = "license"
  Call blaetterEinAusblenden(objArray, False)
End Sub

'*******************************************************************
'Blendet ein Blatt aus und schuetzt Arbeitsmappe
Sub blatt_ausblenden(ByVal strSheetName As String, ByVal strpw As String)
  Call updateActiveProc("Hilfsmakros.blatt_ausblenden")
  'debug.print straktiveprozedur & " Sheet " & strsheetname
  mappenschutz_aus 'ThisWorkbook.Unprotect strpw
  ThisWorkbook.Sheets(strSheetName).Visible = False
  mappenschutz_ein
End Sub


'*******************************************************************
'Blendet ein Blatt ein und schuetzt Arbeitsmappe
Sub blatt_einblenden(ByVal strSheetName As String, ByVal strpw As String, _
  Optional ByVal blnnichtschuetzen As Boolean)
  Call updateActiveProc("Hilfsmakros.blatt_einblenden")
  mappenschutz_aus 'ThisWorkbook.Unprotect strpw
  ThisWorkbook.Sheets(strSheetName).Visible = True
  If Not blnnichtschuetzen Then
    mappenschutz_ein
  End If
End Sub


'*******************************************************************
'Setzt den Blattschutz aller sichtbaren Blaetter
Sub blattschutz_ein()
  Call blattschutz_ein_drawing(True)
End Sub


'*******************************************************************
'Setzt den Blattschutz aller sichtbaren Blaetter
'sollen Grafikobjekte auch geschuetzt werden
Sub blattschutz_ein_drawing(ByVal blnDrawingObjects As Boolean)
  Call updateActiveProc("Hilfsmakros.blattschutz_ein_drawing")
  Dim objSheet As Worksheet
  'Debug.Print straktiveprozedur
  For Each objSheet In ThisWorkbook.Worksheets
    If objSheet.Visible And objSheet.name <> STR_SH_HLP_CONST Then
      Call protectSheet(objSheet.name, True)
    End If
  Next

End Sub

'*******************************************************************
'Setzt den Blattschutz fuer ein uebergebenes Blatt, das auch versteckt sein kann
'setzt den Mappenschutz, falls er vorher vorhanden war
'sollen Grafikobjekte auch geschuetzt werden
Sub blattschutz_ein_drawing_and_hidden(ByVal strSheetName, ByVal blnDrawingObjects As Boolean, _
  ByVal isHiddenToProtect As Boolean)
  
  Call updateActiveProc("Hilfsmakros.blattschutz_ein_drawing_and_hidden")
  Dim objSheet As Worksheet
  Dim blnIsWorkbookStructureProtected As Boolean
  blnIsWorkbookStructureProtected = ActiveWorkbook.ProtectStructure
  Dim blnIsSheetVisible As Boolean
  'Debug.Print straktiveprozedur
  Set objSheet = ThisWorkbook.Worksheets(strSheetName)
  blnIsSheetVisible = objSheet.Visible
  If isHiddenToProtect And blnIsWorkbookStructureProtected And blnIsSheetVisible = False Then
    Call mappenschutz_aus
    objSheet.Visible = True
  End If
  If objSheet.Visible And objSheet.name <> STR_SH_HLP_CONST Then
    Call protectSheet(objSheet.name, True)
  End If
  If isHiddenToProtect And blnIsWorkbookStructureProtected And blnIsSheetVisible = False Then
    objSheet.Visible = False
    Call mappenschutz_ein
  End If
End Sub


'*******************************************************************
'Entfernt den Blattschutz aller sichtbaren Blaetter
Sub blattschutz_aus()
  Call updateActiveProc("Hilfsmakros.blattschutz_aus")
  Dim objSheet As Worksheet
  'Debug.Print straktiveprozedur
  For Each objSheet In ThisWorkbook.Worksheets
    If objSheet.Visible Then
      objSheet.Unprotect Password:=changeToNumberString("s")
    End If
  Next

End Sub


'*******************************************************************
'Blendet alle Blaetter mit einem bestimmten Praefix aus
Sub blaetter_ausblenden_praefix(ByVal strpraefix As String)
  Call updateActiveProc("Hilfsmakros.blaetter_ausblenden_praefix")
  Dim objSheet As Worksheet
  
  'debug.print straktiveprozedur
  For Each objSheet In ThisWorkbook.Worksheets
    If objSheet.Visible Then
      If LCase(Left(objSheet.name, Len(strpraefix))) = LCase(strpraefix) Then
        Call blatt_ausblenden(objSheet.name, changeToNumberString("m"))
      End If
    End If
  Next
End Sub


'*******************************************************************
'Blendet alle Blaetter mit einem bestimmten Praefix ein
Sub blaetter_einblenden_praefix(ByVal strpraefix As String)
  Call updateActiveProc("Hilfsmakros.blaetter_einblenden_praefix")
  Dim objSheet As Worksheet
  
  For Each objSheet In ThisWorkbook.Worksheets
    If LCase(Left(objSheet.name, Len(strpraefix))) = LCase(strpraefix) Then
      Call blatt_einblenden(objSheet.name, changeToNumberString("m"))
    End If
  Next
End Sub


'*******************************************************************
'Blendet alle Hilfsblaetter aus
Sub hilfsblaetter_ausblenden()
  Call updateActiveProc("Hilfsmakros.hilfsblaetter_ausblenden")
  Call blaetter_ausblenden_praefix("hlp")
End Sub


'*******************************************************************
'Blendet alle Berichtsblaetter aus
Sub rpt_blaetter_ausblenden()
  Call updateActiveProc("Hilfsmakros.rpt_blaetter_ausblenden")
  'Debug.Print straktiveprozedur
  Call blaetter_ausblenden_praefix("rpt")
End Sub


'*******************************************************************
'Blendet alle Berichtsblaetter ein
Sub rpt_blaetter_einblenden()
  Call updateActiveProc("Hilfsmakros.rpt_blaetter_einblenden")
  Call blaetter_einblenden_praefix("rpt")
End Sub


'*******************************************************************
'Blendet alle am Anfang nicht sichtbaren Blaetter aus
Sub folgeblaetter_ausblenden()
  Call updateActiveProc("Hilfsmakros.folgeblaetter_ausblenden")
  Call blatt_ausblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  Call blatt_ausblenden(STR_SH_SUMMARY, changeToNumberString("m"))
  Call blatt_ausblenden(STR_SH_COCKPIT, changeToNumberString("m"))
  Call hilfsblaetter_ausblenden
  Call rpt_blaetter_ausblenden
End Sub

'*******************************************************************
' Aufruf mit getunlockedcellsasrange("data_form")
Function getUnlockedCellsAsRange(ByVal strSheet As String) As Range
  Dim objGefundeneZellen As Range
  Dim objZelle As Range
  
  For Each objZelle In ThisWorkbook.Sheets(strSheet).UsedRange
    If Not objZelle.Locked Then
      'Debug.Print "Ungesperrt: " & objZelle.Address
      If objGefundeneZellen Is Nothing Then
        Set objGefundeneZellen = objZelle
      Else
        Set objGefundeneZellen = Union(objGefundeneZellen, objZelle)
      End If
    End If 'Not objZelle.Locked
  Next objZelle
  Set getUnlockedCellsAsRange = objGefundeneZellen
End Function


'*******************************************************************
'loescht den Inhalt nicht gesperrter Zellen
'Achtung: langsam bei grossen ungesperrten Bereichen
Sub ungesperrte_zellen_loeschen(ByRef objSheet As Worksheet)
  Call updateActiveProc("Hilfsmakros.ungesperrte_zellen_loeschen")
  Dim objGefundeneZellen As Range
  Dim objZelle As Range
  Dim strSheetName As String
  
  strSheetName = ActiveSheet.name
  objSheet.Activate
  For Each objZelle In objSheet.UsedRange
    If Not objZelle.Locked Then
      If objGefundeneZellen Is Nothing Then
        Set objGefundeneZellen = objZelle
      Else
        Set objGefundeneZellen = Union(objGefundeneZellen, objZelle)
      End If
    End If 'Not objZelle.Locked
  Next objZelle
  
  If Not objGefundeneZellen Is Nothing Then
    'Direktes Loeschen eines Range hat Problem mit verbundenen Zellen
    objGefundeneZellen.Select
    Selection.ClearContents
  End If
  Sheets(strSheetName).Activate
End Sub


'*******************************************************************
'loescht alles in den Zellen des angegebenen Ranges
Sub range_allesloeschen(ByVal strSheet As String, ByVal strstartcell As String, ByVal strendcell As String, _
  Optional ByVal blnungefragt As Boolean)
  
  Call updateActiveProc("Hilfsmakros.range_allesloeschen")

  Dim objSheet As Worksheet
  Dim strrange As String
  
  'Debug.Print straktiveprozedur & " Sheet " & strsheet

  Set objSheet = ThisWorkbook.Worksheets(strSheet)
  strrange = strstartcell & ":" & strendcell
  If blnungefragt Then
    'Clear loescht alles, d.h. Werte, Formatierungen etc.
    objSheet.Range(strrange).Clear
  Else
    'scheint in keinem oeffentlichen Makro vorzukommen
    If MsgBox("Wollen sie im Bereich " & strrange & " auf Blatt " & strSheet & " alles loeschen?", vbOKCancel) = vbOK Then
      objSheet.Range(strrange).Clear
    End If
  End If
End Sub


'*******************************************************************
'loescht alles in den Zellen des mit Zeilen und Spalten angegebenen Ranges
Sub range_allesloeschen_rc(ByVal strSheet As String, ByVal strstartcol As String, _
  ByVal lngstartrow As Long, ByVal strendcol As String, ByVal lngendrow As Long)
  Call updateActiveProc("Hilfsmakros.range_allesloeschen_rc")
  
  Call range_allesloeschen(strSheet, strstartcol & lngstartrow, strendcol & lngendrow)
End Sub

'*******************************************************************
'Umwandlung DEZINHEX fuer Seed
Sub toggleSeed(ByVal strSource)
  Application.WorksheetFunction.Dec2Hex (funvarvalue_byname(strSource))
End Sub

'*******************************************************************
'Uebergabeparameter fuer entsprechenden Seed
Function changeToNumberString(ByVal strString As String)
  Dim intCounter As Integer
  Dim strResult As String
  Dim strSeed As String
  
  strSeed = ThisWorkbook.Names("hlp_const_c_seed_" & LCase(strString)).RefersToRange.Offset(0, 1).Value
  
  For intCounter = 1 To Len(strSeed)
    If Asc(LCase(Mid(strSeed, intCounter, 1))) >= 97 Then
      strResult = strResult & Chr(Asc(Mid(strSeed, intCounter, 1)) + 1)
    Else
      strResult = strResult & Application.WorksheetFunction.Dec2Hex(Asc(Mid(strSeed, intCounter, 1)))
    End If
  Next
  changeToNumberString = strResult
End Function

'*******************************************************************
'Testprozedur zu changeToNumberString
Sub testChangeToNumberString()
  Debug.Print
End Sub
'*******************************************************************
'blendet alle Blaetter der Mappe ein
Sub alle_sheets_einblenden()
  Call updateActiveProc("Hilfsmakros.alle_sheets_einblenden")
  Dim objSheet As Worksheet
  
  For Each objSheet In ThisWorkbook.Sheets
    'Call blatt_einblenden(objsheet.Name, changeToNumberString("m"), True)
    blatt_einblenden objSheet.name, changeToNumberString("m"), True
  Next
End Sub


'*******************************************************************
'zeigt die Zeilen- und Spaltenkoepfe an oder blendet sie aus
'von den sichtbaren Blaettern sollen sie nur in data_form und hlp_regr1, hlp_data_regr1 sowie 2 angezeigt werden
Private Sub spaltenzeilenkoepfe_sheet_anzeigen(ByVal sheetname As String, ByVal anzeigen As Boolean)
  ThisWorkbook.Sheets(sheetname).Activate
  ActiveWindow.DisplayHeadings = anzeigen
  If anzeigen = False Then
    ActiveWindow.DisplayGridlines = anzeigen
  End If
End Sub


'*******************************************************************
'zeigt die Zeilen- und Spaltenkoepfe an oder blendet sie aus
'fuer die sichtbaren Blaetter der Mappe
'ab Version 3.0.3 Blaetter fuer Basisregression geloescht (rpt_regr_1_1, rpt_regr_1_2 etc)
Private Sub spaltenzeilenkoepfe_anzeigen(ByVal anzeigen)
  Dim counter2
  
  Call spaltenzeilenkoepfe_sheet_anzeigen(STR_SH_TITLE, anzeigen)
  Call spaltenzeilenkoepfe_sheet_anzeigen(STR_SH_INTRO, anzeigen)
  Call spaltenzeilenkoepfe_sheet_anzeigen(STR_SH_DATA_HEAD, anzeigen)
  Call spaltenzeilenkoepfe_sheet_anzeigen(STR_SH_RPT_FAZIT, anzeigen)
  Call spaltenzeilenkoepfe_sheet_anzeigen(STR_SH_LICENSE, anzeigen)
   
  'Ab Version 3.0.3 nur noch Blaetter regr2..., Blaetter Basisregression geloescht
  For counter2 = 1 To 7
    Call spaltenzeilenkoepfe_sheet_anzeigen(STR_SH_RPT_REGR & "2_" & counter2, anzeigen)
  Next
End Sub


'*******************************************************************
'Blendet auf allen sichtbaren Blaettern ausser data_form
'die Spalten- und Zeilenkoepfe ein
Sub spaltenzeilenkoepfe_einblenden()
  spaltenzeilenkoepfe_anzeigen (True)
End Sub


'*******************************************************************
'Blendet auf allen sichtbaren Blaettern ausser data_form
'die Spalten- und Zeilenkoepfe aus
Sub spaltenzeilenkoepfe_ausblenden()
  spaltenzeilenkoepfe_anzeigen (False)
End Sub


'*******************************************************************
'Testprozedur Mappenschutz
Private Sub testschutz()
  Call updateActiveProc("Hilfsmakros.testschutz")
  'Call blatt_ausblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  'Call blatt_einblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  Call mappenschutz_aus
End Sub


'*******************************************************************
'Gibt Feldwerte einer Auswahl in umgekehrter Reihenfolge aus
Sub invertselection()
  Dim intarrlength
  intarrlength = Selection.Count
  Dim objCell As Range
  Dim intCounter
  intCounter = Selection.Count - 1
  Dim arr()
  ReDim arr(intarrlength)
  For Each objCell In Selection
    arr(intCounter) = objCell.Value
    intCounter = intCounter - 1
  Next
  
  Workbooks.Add
  For intCounter = 0 To intarrlength - 1
    'Debug.Print intcounter & ": " & Round(arr(intcounter), 5)
    If IsNumeric(arr(intCounter)) Then
      ActiveCell.Value = Round(arr(intCounter), 3)
    Else
      ActiveCell.Value = arr(intCounter)
    End If
    ActiveCell.Offset(0, 1).Select
  Next
End Sub


'*******************************************************************
'Markiert alle Zellen mit bedingten Formaten auf aktivem Blatt
Sub selectFormatConditions()
  Dim objGefundeneZellen As Range
  Dim objZelle As Range
  
  For Each objZelle In ActiveSheet.UsedRange
    If objZelle.FormatConditions.Count > 0 Then
      If objGefundeneZellen Is Nothing Then
        Set objGefundeneZellen = objZelle
      Else
        Set objGefundeneZellen = Union(objGefundeneZellen, objZelle)
      End If
    End If 'objZelle.FormatConditions.Count > 0
  Next objZelle
  
  If objGefundeneZellen Is Nothing Then
    MsgBox "Keine bedingten Formate vorhanden"
  Else
    objGefundeneZellen.Select
  End If
End Sub
Attribute VB_Name = "ImportExport"
Option Explicit
Option Private Module

'===================================================================
'Importroutinen fuer externe Daten, z.B. EBG-Formular, Excel, Text

'Local existiert nicht in Excel fuer Mac
Sub windowsOnlyImportCsv(ByVal strFilename As String)
  Application.Workbooks.Open Filename:=strFilename, Local:=True
End Sub

'*******************************************************************
'Hilfsfunktion liefert Dateiendung der aktuellen Mappe
Function fungetfileextension() As String
  fungetfileextension = Mid(ThisWorkbook.name, InStrRev(ThisWorkbook.name, ".") + 1)
End Function

'*******************************************************************
'Hilfsfunktion zum Schliessen der Importdatei auch unter Excel 2016 Mac
'ab 24.10.2017 Version 3.0.6
Sub closeImportWorkbook(ByVal strWorkbookName As String)
  'Quelle: https://answers.microsoft.com/en-us/msoffice/forum/msoffice_excel-mso_mac-mso_mac2011/run-time-error-1004-from-workbooksclose-on-excel/b3c4022c-080d-4b2f-bc52-03494e7df759?auth=1
  ThisWorkbook.Activate
  Application.Workbooks(strWorkbookName).Activate
  Application.Workbooks(strWorkbookName).Close SaveChanges:=False
  ThisWorkbook.Activate
End Sub

'*******************************************************************
'Hilfsfunktion mit Dialogfenster "Datei oeffnen"
'Mac-kompatible Version vom 27.03.2014
Function import_openfile(ByVal strimportfilter As String) As String
  Call updateActiveProc("ImportExport.import_openfile")
  Dim blncancel As Boolean
  Dim strFilename As String
  
  blncancel = False
  Do
    If Not Application.OperatingSystem Like "*Mac*" Then
      'Windows
      strFilename = Application.GetOpenFilename(strimportfilter)
    Else
      'Mac 2011 und 2016
      strFilename = Application.GetOpenFilename
      'strFilename = openfilename_mac
    End If
    
    If strFilename = "" Or strFilename = CStr(False) Then
      If MsgBox(strtranslate("import.cancel"), vbRetryCancel) = vbCancel Then
        blncancel = True
      End If
    End If
  Loop While (strFilename = "" Or strFilename = CStr(False)) And Not blncancel
  
  If blncancel Then
    import_openfile = ""
  Else
    import_openfile = strFilename
  End If

End Function


'*******************************************************************
'Holt mit Column-String (A, B, C ...), Column-Zahl oder Namen
'aus Blatt hlp_lse die Anzahl Stellen fuer die Rundung
'liefert 0 als Default oder bei Fehlern
'Nicht fuer die Anzeige!
'Ab Version 3.0.7
Function getNumDigitsFromHlp_lse(ByVal varCol As Variant)
  On Error Resume Next
  
  Dim intResult As Integer
  Dim strCol As String
  
  If IsNumeric(varCol) Then
    strCol = funstrcol(varCol)
  Else
    'Laenger als 3 Stellen -> keine Spalte -> Name
    If Len(varCol) > 3 Then
      strCol = funstrcol_byname(varCol)
    Else
      strCol = varCol
    End If
  End If
  intResult = Application.WorksheetFunction.VLookup(strCol, _
        ThisWorkbook.Names(STR_NA_LSE).RefersToRange, 3, 0)
  'Defaultwert, falls nicht festgelegt
  If IsEmpty(intResult) Then
    intResult = 0
  End If
  getNumDigitsFromHlp_lse = intResult
End Function


'*******************************************************************
'Rundet in externer Importdatei Liste einen Wert oder setzt ihn eventuell 0
'beruecksichtigt, dass zwei Spalten fehlen
Sub roundValueOrSet0(ByVal strWorkbookName As String, ByVal intWorksheet As Integer, _
  ByVal lngRowFirst, lngRowLast As Long, ByVal strDataformName As String, ByVal blnSet0 As Boolean)
  
  Dim strCol As String
  Dim lngCounter As Long
  Dim varTmpWert As Variant
  Dim intAnzahlStellen As Integer

  'Ab data_form_col_berstellung fehlen in Importformular 2 Spalten
  'strCol bezieht sich auf die zu importierende Tabelle
  If ThisWorkbook.Names(strDataformName).RefersToRange.Range("A1").Column >= _
    ThisWorkbook.Names("data_form_col_berstellung").RefersToRange.Range("A1").Column Then
    
    strCol = funstrcol(ThisWorkbook.Names(strDataformName).RefersToRange.Offset(0, -2).Column)
  Else
    strCol = funstrcol_byname(strDataformName)
  End If
  
  intAnzahlStellen = getNumDigitsFromHlp_lse(strDataformName)
  For lngCounter = lngRowFirst To lngRowLast
    varTmpWert = Application.Workbooks(strWorkbookName).Sheets(intWorksheet).Range( _
      strCol & lngCounter).Value
    If IsEmpty(varTmpWert) Then
      If blnSet0 Then
        Application.Workbooks(strWorkbookName).Sheets(intWorksheet).Range(strCol & lngCounter).Value = 0
      End If
    ElseIf IsNumeric(varTmpWert) Then
      Application.Workbooks(strWorkbookName).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
        Round(varTmpWert, intAnzahlStellen)
    End If
  Next
End Sub

'*******************************************************************
'zeigt das Formular frmfortschrittsanzeige an
'umgeht den Bug in Excel 2016 Mac, dass UserForm_activate nicht ausgefuehrt wird
Sub showFrmfortschrittsanzeigeMac()
    If Val(Application.Version) >= 15 Then 'excel 2016 support
      frmfortschrittsanzeige.btnok.Visible = True
    Else
      'Application.Wait in Excel 2011 Mac laesst sich nicht unterbrechen
      frmfortschrittsanzeige.btnok.Visible = False
    End If
    frmfortschrittsanzeige.Show
End Sub

'*******************************************************************
'Import Datenimport aus EBG-Formular
'Lohnstrukturerhebung LSE 2004 - 2010 ab Version 2.5 nicht mehr unterstuetzt

'Um flexibel aus Verschiebungen der Spalten in LSE reagieren zu koennen
'ist im Blatt "hlp_lse" unter dem Namen "lstlse" eine mit SVERWEIS abfragbare Liste der Spalten vorhanden
'In der Zusatzspalte sind eventuelle Formeln fuer die Umrechnung enthalten
'aufgerufen von sheet_data_head.btnimportlse_Click
Sub import_lse2004(ByVal intwidthtotal As Integer)
  Call updateActiveProc("ImportExport.import_lse2004")
  If ISTEST Then
    Debug.Print Timer & ": import_lse2004 gestartet"
  End If
  
  Dim bytanzdatacol As Byte 'Anzahl Spalten mit Daten
  Dim intcollse As Integer
  Dim intcountercol As Integer
  Dim lsecol As Integer 'Spalte fuer SVERWEIS im Blatt hlp_lse je nach Jahresversion LSE oder EBG-Form, ab 2016 nur noch 1
  Dim intsr As Integer 'Startzeile des Datenbereichs
  Dim intsrlse As Integer 'Startzeile des Datenbereichs der LSE
  Dim lnganzdaten As Long
  Dim lngcounterrow As Long
  Dim lngRowLastSource As Long
  Dim lngRowFirstSource As Long
  Dim objstartcell As Range
  Dim objstartcelllse As Range
  Dim sng04buwaz As Single 'betriebsuebliche Wochenarb.zeit in Stunden in LSE (bereits auf Stunden umgerechnet)
  Dim stradresse As String
  Dim strcolbuwaz As String
  Dim strfilenamelse As String
  Dim strFormula As String
  Dim strformularow As String 'String der Formel mit ersetzten Zeilenbezuegen
  Dim strl04sd As String 'Adresse der Startzelle des Datenbereiches in zu importierender Datei
  Dim strsuchstring As String
  Dim strtelefon As String
  Dim strtmp As String 'wiederverwendbare, temporaere Variable
  Dim strWorkbookName As String
  Dim varzellwert As Variant
  Dim dblvorher As Double
  Dim intNumDigits As Integer
  Dim blnIsImportVor_V3_1_0 As Boolean
    
  Call updateActiveProc("Import.import_lse2004")
  
  'Ab Excel 2007 kann in xlsm auch xlsx importiert werden
  If Val(Application.Version) >= 12 And fungetfileextension() = "xlsm" Then
    strfilenamelse = import_openfile(strtranslate("import.dateityp") & ", *.xlsx")
  Else
    strfilenamelse = import_openfile(strtranslate("import.dateityp") & ", *.xls")
  End If
  
  dblvorher = Timer
  'Debug.Print strfilenamelse
  If ISTEST Then
    Debug.Print Timer & ": import_lse2004 nach Dialog Dateiauswahl -> " & strfilenamelse
  End If
  blnImportabbruch = False
  
  If strfilenamelse = "" Then
    MsgBox strtranslate("import.abgebrochen")
    ThisWorkbook.Worksheets(STR_SH_DATA_HEAD).Select
    blnImportabbruch = True
    Exit Sub
  End If
  
  'Fortschrittsanzeige
  If Not Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.lblbalken.Visible = True
    frmfortschrittsanzeige.txtrahmen.Visible = True
    frmfortschrittsanzeige.lblbalken.Width = 1 * Int(intwidthtotal / 3)
    frmfortschrittsanzeige.Repaint
  Else 'Auf dem Mac ohne Fortschrittsbalken aber mit OK-Button
    frmfortschrittsanzeige.lblbalken.Visible = False
    frmfortschrittsanzeige.txtrahmen.Visible = False
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext1mac")
    '24.10.2017 UserForm_Activate scheint unter Excel2016 Mac gar nie aufgerufen zu werden
'    If CInt(Split(Application.Version, ".")(0)) >= 15 Then 'excel 2016 support
'      frmfortschrittsanzeige.btnok.Visible = True
'    Else
'      'Application.Wait in Excel 2011 Mac laesst sich nicht unterbrechen
'      frmfortschrittsanzeige.btnok.Visible = False
'    End If
'    frmfortschrittsanzeige.show
    Call showFrmfortschrittsanzeigeMac
  End If
  
  
  'Importdatei oeffnen
  Application.Workbooks.Open Filename:=strfilenamelse
  
  strWorkbookName = Application.ActiveWorkbook.name
  
  'Ist es ueberhaupt EBG Vorlage?
  ' A1 ist bei EBG Formular leer
  ' EBG     : Range("C1").Value = "EBG Vorlage 2013"
  If Not IsEmpty(Application.Workbooks(strWorkbookName).Worksheets(1).Range("A1").Value) _
    Or Application.Workbooks(strWorkbookName).Worksheets(1).Range("C1").Value <> "EBG Vorlage 2016" Then
    
    MsgBox (strtranslate("msgbox_import.keinlse") & vbCrLf & _
      strtranslate("msgbox_import.ueberpruefen") & vbCrLf & _
      strtranslate("msgbox_import.abbruch"))
    blnImportabbruch = True
    Exit Sub
  Else
    'Ab Januar 2016 gibt es nur noch EBG-Vorlage
    lsecol = 2
  End If
  blnImportabbruch = False
  
  'Wird Formular der Vorversion vor 3.1.0 importiert
  blnIsImportVor_V3_1_0 = False
  If Not IsEmpty(Workbooks(strWorkbookName).Worksheets(1).Range("B33")) _
    And IsEmpty(Workbooks(strWorkbookName).Worksheets(1).Range("Z36")) Then
    
    blnIsImportVor_V3_1_0 = True
  End If
  
  If Not Application.OperatingSystem Like "*Mac*" And Not ISTEST Then
    frmfortschrittsanzeige.Show (vbModeless)
    frmfortschrittsanzeige.Repaint
  End If
  If Not ISTEST Then
      Application.Cursor = xlWait
  End If
  Application.EnableEvents = False
  
  intsr = Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
    .Range(STR_DATA_FORM_SD).Row - 1

  strl04sd = Application.WorksheetFunction.VLookup("strsd", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)
  'Import von Formular vor 3.1.0
  If blnIsImportVor_V3_1_0 Then
    strl04sd = Range(Application.WorksheetFunction.VLookup("strsd", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Offset(-1, 0).Address(False, False)
  End If
  'Startzeile des Datenbereichs der LSE
  intsrlse = Workbooks(strWorkbookName).Sheets(1).Range(strl04sd).Row - 1
  
  'Anzahl Datensaetze in der LSE-Datei, zuerst mit Spalte Geschlecht
  lngRowLastSource = funlnglastfilledrowincol(strWorkbookName, _
    Application.Workbooks(strWorkbookName).Sheets(1).name, Application.WorksheetFunction.VLookup("strcolgeschlecht", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0))
  
  lngRowFirstSource = Application.Workbooks(strWorkbookName).Sheets(1).Range(strl04sd).Row
  
  
  lnganzdaten = lngRowLastSource - lngRowFirstSource + 1
  'Spalte Geschlecht ist leer -> Versuche mit 1. Spalte
  If lnganzdaten <= 0 Then
    lngRowLastSource = funlnglastfilledrowincol(strWorkbookName, _
      Application.Workbooks(strWorkbookName).Sheets(1).name, _
      funstrfirstcol_byrange(Workbooks(strWorkbookName).Sheets(1).Range(strl04sd)))
    lnganzdaten = lngRowLastSource - lngRowFirstSource + 1
  End If
  
  If lnganzdaten <= 0 Then
      MsgBox (strtranslate("msgbox_import.anzrowfalsch") & vbCrLf & _
      strtranslate("msgbox_import.ueberpruefen") & vbCrLf & _
      strtranslate("msgbox_import.abbruch"))
    blnImportabbruch = True
    Exit Sub
  End If
  
  'Joblist aus Spalte Kompetenzniveau aus Liste importieren
  Call joblistimport_from_form(Application.Workbooks(strWorkbookName), blnIsImportVor_V3_1_0)
  
  'betriebsuebliche Wochenarb.zeit in Stunden in LSE (bereits auf Stunden umgerechnet)
  'Position der buwaz wird auf Blatt hlp_lse geholt
  '%%% Exception abfangen falls nicht ausgefuellt
  'sng04buwaz = 40
  sng04buwaz = Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strbuwaz", _
        ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value

  'Spalte buwaz wird neu in init_data_form (Hauptmodul) eingetragen
  
  'falsche Dezimalkomma und Tausendertrennzeichen in zu importierender Datei korrigieren
  With Application.Workbooks(strWorkbookName).Sheets(1)
    Call change_decimal_separator(.Range("C" & lngRowFirstSource & ":" & "C" & lngRowLastSource))
    Call change_decimal_separator(.Range("E" & lngRowFirstSource & ":" & "E" & lngRowLastSource))
    Call change_decimal_separator(.Range("L" & lngRowFirstSource & ":" & "S" & lngRowLastSource))
  End With
  
  'Felder in Blatt data_head abfuellen mit Hilfe von Blatt hlp_lse
  'Firma
  ThisWorkbook.Names("data_head_c_firma").RefersToRange.Value = _
      Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("stradr1", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
      
  'UID nur ab Importdatei 3.1.0
  If Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("struid", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).MergeArea.Columns.Count < 10 Then
    ThisWorkbook.Names("data_head_c_uid").RefersToRange.Value = _
        Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("struid", _
        ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  End If
  'Vorlage EBG hat 1 Feld fuer Adresse
  stradresse = funstringmittrenn(Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("stradr2", _
        ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value, ", ")
  
  'letztes Komma abtrennen
  If Trim(stradresse) <> "" Then
    ThisWorkbook.Names("data_head_c_adresse").RefersToRange.Value = Left(stradresse, Len(stradresse) - 2)
  End If
  
  ThisWorkbook.Names("data_head_c_kontaktperson").RefersToRange.Value = _
    Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strsachbearbeiter", _
    ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  
  'Telefon ' Damit vorangestellte 0 erhalten bleibt
  strtelefon = Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strtelefon", _
    ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  If Left(strtelefon, 1) <> "0" Then
    strtelefon = "'0" & strtelefon
  Else
    strtelefon = "'" & strtelefon
  End If
  'Stellen formatieren
  If Len(strtelefon) = 11 Then
    strtelefon = Left(strtelefon, 4) & " " & Mid(strtelefon, 5, 3) & " " & Mid(strtelefon, 8, 2) & " " & Right(strtelefon, 2)
  End If
  ThisWorkbook.Names("data_head_c_tel").RefersToRange.Value = strtelefon

  'Email
  ThisWorkbook.Names("data_head_c_email").RefersToRange.Value = _
      Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("stremail", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  
  'Monat und Jahr
  ThisWorkbook.Names("data_head_c_monat").RefersToRange.Value = _
    Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strmonat", _
    ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Value = _
    Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strjahr", _
    ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
 
  '3 neue Felder ab 2016
  ThisWorkbook.Names("data_head_c_stundenlohn_jn").RefersToRange.Value = _
    Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strstundenlohn_jn", _
    ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  
  ThisWorkbook.Names("data_head_c_stundenlohn_anzstunden").RefersToRange.Value = _
    Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strstundenlohn_anzstunden", _
    ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  
  If Not blnIsImportVor_V3_1_0 Then
    'Ab 3.1.0 neues Feld
    ThisWorkbook.Names("data_head_c_jahrarbzeitabw").RefersToRange.Value = _
      Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strjahrarbzeitabw_jn", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  End If
  
  If blnIsImportVor_V3_1_0 Then
    ThisWorkbook.Names("data_head_c_stundenlohn_bruttonetto").RefersToRange.Value = _
      Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strstundenlohn_bruttonetto", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Offset(-1, 0).Value
  Else
    ThisWorkbook.Names("data_head_c_stundenlohn_bruttonetto").RefersToRange.Value = _
      Workbooks(strWorkbookName).Sheets(1).Range(Application.WorksheetFunction.VLookup("strstundenlohn_bruttonetto", _
      ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0)).Value
  End If
  
  'Anzahl MitarbeiterInnen
  ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value = lnganzdaten
  
  'Betriebsuebliche Wochenarbeitszeit buwaz
  ThisWorkbook.Names("data_head_c_buwaz").RefersToRange.Value = sng04buwaz
  
  'Dateiname auf Blatt data_head schreiben
  ThisWorkbook.Names("data_head_c_dateiname").RefersToRange.Value = strWorkbookName
 
  If ISTEST Then
    Debug.Print Timer & ": import_lse2004 Vor Schleife Daten umrechnen"
  End If
  
  'Aus Performance-Gruenden wird zuerst nach unten und dann nach rechts gefuellt
  'Counter ueber unsere Anzahl Spalten laufen lassen, denn diese bleibt stabil!
  bytanzdatacol = funintanzdatacol() - INT_ZUSATZSPALTEN
  
  'nur fuer Test
  'ThisWorkbook.Sheets("data_form").Select
  
  'Tausch Dezimalkomma ist bereits mit change_decimal_separator passiert
  
  'Ab Logib 2.5 2016 2 berechnete Spalten dazwischen, naemlich 8 und 9
  For intcountercol = 1 To bytanzdatacol + 2
    'debug.print Timer & ": import_lse2004 Beginn Schleife Spalte " & intcountercol
    
    If ThisWorkbook.Names("data_form_col_skilllist").RefersToRange.Column <> intcountercol _
      And ThisWorkbook.Names("data_form_col_skillcalculated").RefersToRange.Column <> intcountercol Then
      '%%% ab 21 (Zusatzspalten) Exception
      intcollse = funintcol(Application.WorksheetFunction.VLookup(funstrcol(intcountercol), _
        ThisWorkbook.Names(STR_NA_LSE).RefersToRange, lsecol, 0))
      'Dezimalstellen aus hlp_lse Spalte 3 holen
      intNumDigits = getNumDigitsFromHlp_lse(intcountercol)

      For lngcounterrow = 1 To lnganzdaten
        'Debug.Print Timer & ": import_lse2004 Beginn Schleife Zeile " & lngcounterrow
        
        varzellwert = Application.Workbooks(strWorkbookName).Sheets(1).Cells(intsrlse + lngcounterrow, intcollse).Value
        
        'Spalten mit 0-Werten werden ausgelassen, ausser bei Dienstjahren, bgrad, bezstunden und den 4 Lohnspalten
        If intcountercol = ThisWorkbook.Names("data_form_col_dienstjahre").RefersToRange.Column Or _
          intcountercol = ThisWorkbook.Names("data_form_col_bgrad").RefersToRange.Column Or _
          intcountercol = ThisWorkbook.Names("data_form_col_bezstunden").RefersToRange.Column Or _
          (intcountercol >= ThisWorkbook.Names("data_form_col_bruttolohn").RefersToRange.Column And _
          intcountercol <= ThisWorkbook.Names("data_form_col_sonderz").RefersToRange.Column) Or _
          CStr(Application.Workbooks(strWorkbookName).Sheets(1).Cells(intsrlse + lngcounterrow, intcollse).Value) <> "0" Then
          
          If ((intcountercol >= ThisWorkbook.Names("data_form_col_bgrad").RefersToRange.Column And _
            intcountercol <= ThisWorkbook.Names("data_form_col_sonderz").RefersToRange.Column) _
            Or (intcountercol = ThisWorkbook.Names("data_form_col_dienstjahre").RefersToRange.Column)) Then
            'Ab Version 3.0.7
            If IsEmpty(varzellwert) Then
              varzellwert = 0
            Else
              If IsNumeric(varzellwert) Then
                varzellwert = Round(varzellwert, intNumDigits)
              End If
            End If
          End If
          ThisWorkbook.Sheets(STR_SH_DATA_FORM).Cells(intsr + lngcounterrow, intcountercol).Value = varzellwert
        End If
      Next
    End If
  Next
  
  '24.10.2017 Version 3.0.6
  Application.ScreenUpdating = True
  Application.EnableEvents = True
  Call closeImportWorkbook(strWorkbookName)
  Application.Cursor = xlDefault
  
  If ISTEST Then
    Debug.Print "Zeit " & (Timer - dblvorher)
    Debug.Print Timer & ": import_lse2004 Nach Schleife Daten umrechnen"
  End If
End Sub


'*******************************************************************
'Import Excel oder Text
'Achtung: Die Spaltenstruktur muss identisch sein mit Blatt data_form
'Vorgehen fuer diese Importdateien:
'  - Datei wird in Excel geoeffnet
'  - ev. Umrechnungen werden in der Importdatei ersetzt
'  - der Datenbereich wird kopiert und mit PasteSpecial in Lohntool eingefuegt
'  - die Importdatei wird geschlossen, ohne sie zu speichern -> urspruenglicher Zustand
Sub import_exceltext(ByVal intwidthtotal As Integer)
  Call updateActiveProc("ImportExport.import_exceltext")
  Dim intAnzahlStellen As Integer
  Dim intWorksheet As Integer
  Dim lngcollast As Long
  Dim intJahr, intMonat As Integer 'Erfassungsjahr und Monat
  Dim varErfassungsdatum '1. des Folgemonats von Erfassungsjahr und Monat
  Dim lngCounter As Long
  Dim lngRowFirst As Long
  Dim lngRowLast As Long
  Dim strCol As String
  Dim strcollast As String
  Dim strColNext As String
  Dim strFilename As String
  Dim strWorkbookNameImportFile As String
  Dim varTmpWert As Variant
  Dim intNumDigits As Integer
  Dim sngTmp As Single
  Dim blnIsImportVor_V3_1_0 As Boolean
  
  If ISTEST Then
    Debug.Print Timer & ": import_excel vor Dialog Dateiauswahl"
  End If
  blnImportabbruch = False

  'Achtung: Im Text ist Syntax mit ; zwingend
  '  z.B. Excel- oder Textdatei (*.xls; *.txt; *.csv)
  strFilename = import_openfile(strtranslate("import.dateitypen.2007") & ", *.xlsx;*.xls;*.txt;*.csv")

  If strFilename = "" Then
    MsgBox strtranslate("import.abgebrochen")
    ThisWorkbook.Worksheets(STR_SH_DATA_HEAD).Select
    blnImportabbruch = True
    Exit Sub
  End If
  
  If ISTEST Then
    'Debug.Print strfilenamelse
    Debug.Print Timer & ": import_excel nach Dialog Dateiauswahl -> " & strFilename
  End If
  If LCase(Right(strFilename, 3)) = "xls" Or LCase(Right(strFilename, 4)) = "xlsx" Then
    'Excel -> Absturz
    Application.Workbooks.Open Filename:=strFilename
  'Ab 3.0.7 neu csv separat importiert (wegen ; als Trennzeichen, immer ohne Import-Assistent)
  ElseIf LCase(Right(strFilename, 3)) = "csv" Then
    'Excel 2011 und 2015 Mac steigt wegen local aus
    If Application.OperatingSystem Like "*Mac*" Then
      MsgBox strtranslate("supportmail_mac")
      blnImportabbruch = True
      Exit Sub
    Else
      Call windowsOnlyImportCsv(strFilename)
    End If
  Else
    If MsgBox(strtranslate("import.assistent"), vbYesNo) = vbYes Then
      'Assistent starten
      Dim objdlg As Dialog
      Set objdlg = Application.Dialogs(xlDialogOpen)
      objdlg.Show arg1:=strFilename
    Else
      Application.Workbooks.Open Filename:=strFilename
    End If
  End If
  strWorkbookNameImportFile = Application.ActiveWorkbook.name
  'debug.print Timer & ": import_exceltext nach Import -> " & strworkbooknameImportFile
  
  'ev. noch Auswahl Blatt moeglich machen
  intWorksheet = 1
  
  'Ist Zelle A1 ausgefuellt
  If IsEmpty(Application.Workbooks(strWorkbookNameImportFile).Worksheets(intWorksheet).Range("A1").Value) Then
    MsgBox (strtranslate("msgbox_import.a1leer") & vbCrLf & _
      strtranslate("msgbox_import.ueberpruefen") & vbCrLf & _
      strtranslate("msgbox_import.abbruch"))
    blnImportabbruch = True
    Exit Sub
  End If
  
  Dim anzimportcol As Integer
  anzimportcol = funintanzdatacol() - INT_ZUSATZSPALTEN
  Call lastcolandrow(strWorkbookNameImportFile, Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).name, _
    strcollast, lngcollast, lngRowLast)
  'ab Logib 2.4 neues Kontrollformular mit 3 Zusatzspalten
  'evtl. zusaetzliche Spalten des Kontrollformulars loeschen
  If lngcollast = anzimportcol + STR_IMPORT_KONTROLLFORM_ANZCOLS Then
    Call lastcolandrow(strWorkbookNameImportFile, Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).name, _
      strcollast, lngcollast, lngRowLast)
  End If
  
  'SR ab V3.1 erste Datenzeile suchen anhand der Spalte Geschlecht (vorher Ausbildung)
  strCol = funstrcol_byname("data_form_col_geschlecht")
  lngRowFirst = lngrowfirsttext(strWorkbookNameImportFile, intWorksheet, strCol, 50)
  'if Application.Workbooks(strworkbooknameImportFile).Sheets(intworksheet).usedrange.end(xlToRight).column <>
    
  'Abbruch wenn keine Zeilen oder falsche Anzahl Zeilen vorhanden
  If lngRowLast < 10 Or lngRowFirst < 1 Then
    MsgBox (strtranslate("msgbox_import.anzrowfalsch") & vbCrLf & _
      strtranslate("msgbox_import.ueberpruefen") & vbCrLf & _
      strtranslate("msgbox_import.abbruch"))
    blnImportabbruch = True
    Exit Sub
  End If
  
  'Ist richtige Anzahl zu importierender Spalten vorhanden
  If lngcollast <> anzimportcol And lngcollast <> anzimportcol + INT_SPALTENDIFF_VORVERSION Then
    MsgBox (strtranslate("msgbox_import.anzcolfalsch") & vbCrLf & _
      strtranslate("msgbox_import.ueberpruefen") & vbCrLf & _
      strtranslate("msgbox_import.abbruch"))
    blnImportabbruch = True
    Exit Sub
  End If
  
  'Hier die numerischen Spalten testen?
  
  blnImportabbruch = False
  
  'Fortschrittsanzeige
  If Not Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.txtrahmen.Visible = True
    frmfortschrittsanzeige.lblbalken.Visible = True
    frmfortschrittsanzeige.Show (vbModeless)
    frmfortschrittsanzeige.lblbalken.Width = 1 * Int(intwidthtotal / 3)
    frmfortschrittsanzeige.Repaint
  Else 'Auf dem Mac ohne Fortschrittsbalken aber mit OK-Button
    frmfortschrittsanzeige.lblbalken.Visible = False
    frmfortschrittsanzeige.txtrahmen.Visible = False
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext1mac")
    'Application.Wait laesst sich nicht unterbrechen
    'frmfortschrittsanzeige.btnok.Visible = False
    'frmfortschrittsanzeige.show
    Call showFrmfortschrittsanzeigeMac
  End If
  
  'Erfassungsjahr berechnen -> wird mehrfach verwendet
  intJahr = funvarvalue_byname("data_head_c_jahr")
  intMonat = funvarvalue_byname("data_head_c_monat")
  
  varErfassungsdatum = DateAdd("m", 1, DateSerial(intJahr, intMonat, 1))
  
  'Application.Workbooks(strworkbooknameImportFile).Sheets(intworksheet).Activate
  'Spalte B, Geburtsjahr umrechnen
  strCol = funstrcol_byname("data_form_col_gebjahr")
  Select Case funvarvalue_byname("hlp_const_c_gebjahr")
    Case 0 ' Jahr
      'Nichts machen, entspricht Standard
    Case 1 'Datum
      For lngCounter = lngRowFirst To lngRowLast
        varTmpWert = Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value
        If IsDate(varTmpWert) Then
          'Application.Workbooks(strworkbooknameImportFile).Sheets(intworksheet).Range(strcol & lngcounter).Select
          Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
            Year(varTmpWert)
        End If
      Next
    Case 2 'Alter
      For lngCounter = lngRowFirst To lngRowLast
        varTmpWert = Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value
        If IsNumeric(varTmpWert) Then
          If varTmpWert > 0 Then
            Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
              CInt(intJahr) - CInt(varTmpWert)
          End If
        End If
      Next
  End Select
  
  'Spalte C Geschlecht umrechnen
  strCol = funstrcol_byname("data_form_col_geschlecht")
  For lngCounter = lngRowFirst To lngRowLast
    varTmpWert = Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value
    If Trim(varTmpWert) = Trim(funvarvalue_byname("hlp_const_c_geschlecht_0")) Then
      Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = 1
    End If
  
    If Trim(varTmpWert) = Trim(funvarvalue_byname("hlp_const_c_geschlecht_1")) Then
      Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = 2
    End If
  Next
  
  'Spalte E, Dienstjahre umrechnen
  strCol = funstrcol_byname("data_form_col_dienstjahre")
  intAnzahlStellen = getNumDigitsFromHlp_lse(strCol)
  Select Case funvarvalue_byname("hlp_const_c_dienstjahre")
    Case 0 ' Eintrittsjahr
      For lngCounter = lngRowFirst To lngRowLast
        varTmpWert = Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range( _
          strCol & lngCounter).Value
        If IsNumeric(varTmpWert) Then
          If varTmpWert > 0 Then
            'Ab Version 3.0.7 auf 1 Dezimalstelle gerundet, sollte hier nicht noetig sein %%%%
            Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
              Round(CInt(intJahr) - CInt(varTmpWert), intAnzahlStellen)
          End If
        End If
      Next
    Case 1 ' Eintrittsdatum ab 3.0.7 anders berechnet, da neu Dezimalzahl
      For lngCounter = lngRowFirst To lngRowLast
        varTmpWert = Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value
        Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).NumberFormat = "#,##0.0"
        If IsDate(varTmpWert) Then
          If IsDate(varErfassungsdatum) Then
            'SR 30.07.2018 Anpassung mit CDate f|fffd|r "Pseudodatumswerte" aus SAP
            'YearFrac liefert auch fuer Einstellungsdatum gt Erfassungsdatum eine positive Zahl
            If varErfassungsdatum > CDate(varTmpWert) Then
              'Ab Version 3.0.7 Dezimalzahl mit 1 Dezimalstelle
              sngTmp = Round(Application.WorksheetFunction.YearFrac(CDate(varTmpWert), varErfassungsdatum, 1), intAnzahlStellen)
              'Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).NumberFormat = "#,##0.0"
              Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
                Round(Application.WorksheetFunction.YearFrac(CDate(varTmpWert), varErfassungsdatum, 1), intAnzahlStellen)
                'Round(varErfassungsdatum - varTmpWert, intAnzahlStellen)
            Else
              Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).ClearContents
            End If
          Else
            Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
              CInt(intJahr) - CInt(Year(varTmpWert))
          End If
        End If
      Next
    Case 2 'Anzahl Dienstjahre
      'Ab Version 3.0.7 auf eine Dezimalstelle runden
      For lngCounter = lngRowFirst To lngRowLast
        varTmpWert = Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value
        If IsNumeric(varTmpWert) And _
          Not IsEmpty(Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter)) Then
          
          Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strCol & lngCounter).Value = _
            Round(varTmpWert, intAnzahlStellen)
        End If
      Next
  End Select
  
  'Dezimalkomma und Tausendertrennzeichen in Zahlen ersetzen
  With Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet)
    Call change_decimal_separator(.Range("B" & lngRowFirst & ":" & "B" & lngRowLast))
    Call change_decimal_separator(.Range("D" & lngRowFirst & ":" & "D" & lngRowLast))
    Call change_decimal_separator(.Range("I" & lngRowFirst & ":" & "P" & lngRowLast))
  End With
  
  'Standardformat (wegen Umwandlung Datum zu Jahr und SAP-Textformat)
  With Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet). _
    Range("A" & lngRowFirst & ":" & strcollast & lngRowLast)
    .NumberFormat = "General"
    .Value = .Value
  End With
  
  'Spalte Beschaeftigungsgrad data_form_col_bgrad: Runden und 0 setzen
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_bgrad", True)

  'Spalte bezahlte Stunden data_form_col_bezstunden: Runden und 0 setzen
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_bezstunden", True)
  
  'Neu ab 3.0.7, kostet ziemlich Performance
  'Spalten Grundlohn bis data_form_col_bruttolohn
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_bruttolohn", True)
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_zulagen", True)
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_13monatslohn", True)
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_sonderz", True)
  
  'SR Neu ab 3.2.2 03.09.2019 Buwaz und Jahresarbeitszeit ebenfalls gerundet wegen Import-Fehler bei Import ohne Assistent
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_buwaz", True)
  Call roundValueOrSet0(strWorkbookNameImportFile, intWorksheet, lngRowFirst, lngRowLast, "data_form_col_jahresarbeitszeit", True)
 
  'Datenbereich kopieren
  'Neu ab Version 2.5 in zwei Schritten kopieren wegen berechneter Spalten
  Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range("A" & lngRowFirst & ":" & STR_IMPORT_COLBEFORECALC & lngRowLast).Copy

  'nur Werte einfuegen
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).PasteSpecial _
    Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
  
  '2. Teil kopieren und einfuegen
  strColNext = funstrfirstcol_byrange( _
    Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(STR_IMPORT_COLBEFORECALC & lngRowFirst).Offset(0, 1))
  Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(strColNext & lngRowFirst & ":" & strcollast & lngRowLast).Copy

  'nur Werte einfuegen
  strColNext = funstrfirstcol_byrange( _
    Application.Workbooks(strWorkbookNameImportFile).Sheets(intWorksheet).Range(STR_IMPORT_COLBEFORECALC & lngRowFirst).Offset(0, 3))
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
    strColNext & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row).PasteSpecial _
    Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
    
  'Damit beim Schliessen Frage nach Clipboard nicht kommt
  Application.CutCopyMode = False
  
  'Anzahl Mitarbeiter anpassen
  ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value = lngRowLast - lngRowFirst + 1
  ThisWorkbook.Names("data_head_c_dateiname").RefersToRange.Value = strWorkbookNameImportFile
  
  'Importdatei schliessen
  '24.10.2017 Version 3.0.6
  Call closeImportWorkbook(strWorkbookNameImportFile)
End Sub


'*******************************************************************
'setzt Blattschutz fuer verstecktes Export-Blatt
'aufgerufen von ImportExport.hlp_export_ausblenden
Sub hlp_protectexportsheet(ByRef objSheet As Worksheet)
  objSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True _
        , AllowFormattingCells:=True, AllowFormattingColumns:=True, _
        AllowFormattingRows:=True, AllowInsertingRows:=True, AllowDeletingRows:= _
        True, AllowFiltering:=True
  objSheet.EnableSelection = xlNoRestrictions
End Sub


'*******************************************************************
'Blendet alle Export-Sheets ein und hebt den Schutz auf
'nur fuer Entwicklung, nirgendwo aufgerufen
Sub hlp_export_einblendenUndBlattschutzEntfernen()
  Dim sheetname As String
  sheetname = STR_SH_HLP_EXPORT
  Call blatt_einblenden(sheetname, changeToNumberString("m"))
  ThisWorkbook.Sheets(sheetname).Unprotect
  ThisWorkbook.Sheets(sheetname).Select
  ThisWorkbook.Sheets(sheetname).Unprotect Password:=changeToNumberString("s")
End Sub


'*******************************************************************
'Blendet ein einzelnes der Export-Sheets ein und hebt den Schutz auf
Sub hlp_export_ausblendenUndBlattschutzsetzen()
  Dim sheetname As String
  sheetname = STR_SH_HLP_EXPORT
  Call hlp_protectexportsheet(ThisWorkbook.Sheets(sheetname))
  Call blatt_ausblenden(sheetname, changeToNumberString("m"))
End Sub


Sub AlleVerknuepfungenLoeschen()
'
' AlleVerknuepfungenLoeschen Makro
' Makro am 24.01.2006 von Silvia Rothen aufgezeichnet
  Dim aLinks
  Dim intCounter As Integer
  
  aLinks = ActiveWorkbook.LinkSources(Type:=xlLinkTypeExcelLinks)
  
  For intCounter = 1 To UBound(aLinks)
    ActiveWorkbook.BreakLink _
        name:=aLinks(intCounter), _
        Type:=xlLinkTypeExcelLinks
  Next
End Sub

'*******************************************************************
'Hilfsfunktion fuer Exporte
' - export_ebgsheet
' Logib 3.1.1 Weiche fuer Excel 2016 Mac eingebaut
Sub get_fileformat_extension(ByRef newfileformat, ByRef extension As String)
  'FileFormat abhaengig vom aktuellen Format
  'xlOpenXMLWorkbookMacroEnabled = 52
  If Application.OperatingSystem Like "*Mac*" Then
    'Logib 3.1.1 Unterscheidung fuer Excel 2016 Mac
    If Val(Application.Version) >= 16 Then
      newfileformat = 51 'xlOpenXMLWorkbook '51
      extension = ".xlsx"
    Else
      'In Excel 11 52 = xlsx und 53 = xlsm
      newfileformat = 52
      extension = ".xlsx"
    End If
  Else
    newfileformat = 51 'xlOpenXMLWorkbook '51
    extension = ".xlsx"
  End If

End Sub

'*******************************************************************
'Datenblatt exportieren
'Achtung: Nach der Auswertung wird diese Prozedur auf Excel 2010 und 2013
'extrem langsam. Dies ist ein Excel-Bug, der mit dem Loeschen der Namen zusammenhaengt
Sub export_ebgsheet()

  If Not ISTEST Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("ImportExport.export_ebgsheet")
  
  Const COL_LAST_EXPORT As String = "Z"
  Const FILENAME_EXPORT As String = "Exportform_"

  Dim newfileformat ' As String
  Dim extension As String
  Dim language As String
  Dim sheetname As String
  Dim filenameSaveAs, filenameTarget As String
  Dim strcolfirst As String
  Dim lngRowFirst As Long
  Dim lnganzdatensaetze As Long
  Dim intCounter As Integer
  Dim aLinks
  Dim intLast As Integer
  Dim objName As name
  
  'Auf Mac Meldung, da es lang dauern kann
  If Application.OperatingSystem Like "*Mac*" Or funvarvalue_byname("hlp_const_c_ausgewertet") = True Then
    If MsgBox(strtranslate("frmfortschrittsanzeige.lbllauftext1mac"), vbOKCancel) = vbCancel Then
      Exit Sub
    End If
  End If
  
  'If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet gestartet"
  'End If
  
  Application.EnableEvents = False
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  'Sprache aus eingestellter Sprache holen
  language = LCase(ThisWorkbook.Names("hlp_const_c_sprache").RefersToRange.Value)
  
  
  'FileFormat abhaengig vom aktuellen Format
  'xlOpenXMLWorkbookMacroEnabled = 52
  'bis Excel 2003 ist Version immer xls, Konstante xlExcel8 existiert nicht in Excel 2003
  Call get_fileformat_extension(newfileformat, extension)
  
  'sheetname = "hlp_export_" & language
  sheetname = "hlp_export"
  Call blatt_einblenden(sheetname, changeToNumberString("m"))
  
  'Schutz aufheben und Daten kopieren
  ThisWorkbook.Sheets(sheetname).Unprotect Password:=changeToNumberString("s")
  Call range_allesloeschen(sheetname, STR_HLP_EXPORT_CD, _
    COL_LAST_EXPORT & funlnglastexistingrow, True)
    
  'in Zeile 36 sind die Formeln
  strcolfirst = funstrfirstcol_byrange(ThisWorkbook.Sheets(sheetname).Range(STR_HLP_EXPORT_CD))
  lngRowFirst = ThisWorkbook.Sheets(sheetname).Range(STR_HLP_EXPORT_CD).Row
  'Ab 3.1.0 wegen moeglicher Filterung neue Methode
  lnganzdatensaetze = funLngLastRowEvenIfFiltered(ThisWorkbook.name, STR_SH_DATA_FORM) _
    - ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row + 1
'  lnganzdatensaetze = funlnglastfilledrowincol(ThisWorkbook.Name, STR_SH_DATA_FORM, _
'    funstrcol_byname("data_form_col_laufnr")) - _
'    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row + 1
  ThisWorkbook.Sheets(sheetname) _
    .Range(STR_HLP_EXPORT_CD & ":" & COL_LAST_EXPORT & lngRowFirst).Offset(-1, 0).Copy
  
  ThisWorkbook.Sheets(sheetname).Paste _
    Destination:=ThisWorkbook.Sheets(sheetname).Range(STR_HLP_EXPORT_CD _
    & ":" & COL_LAST_EXPORT & (lngRowFirst + lnganzdatensaetze - 2))
    
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor logo kopieren"
  End If
  'logo kopieren
  Call blatt_einblenden(STR_SH_HLP_EXPORT_LOGOS, changeToNumberString("m"))
  Call setLogoForhlp_export
  
  'Sheets(sheetname).Copy ohne After:=... erzeugt immer neue Arbeitsmappe
  'Achtung, dafuer darf Blatt nicht ausgeblendet sein
  ThisWorkbook.Sheets(sheetname).Copy
  filenameTarget = ActiveWorkbook.name
  
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Aufraeumen"
  End If
  'Quellblaetter aufraeumen und verstecken
  ThisWorkbook.Activate
  Call deleteLogoForhlp_export
  Call hlp_protectexportsheet(ThisWorkbook.Sheets(sheetname))
  Call blatt_ausblenden(sheetname, changeToNumberString("m"))
  Call blatt_ausblenden(STR_SH_HLP_EXPORT_LOGOS, changeToNumberString("m"))
  
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Activate
  Application.Workbooks(filenameTarget).Activate
  'Formeln durch Werte ersetzen
  Cells.Select
  Selection.Copy
  
  Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _
      :=False, Transpose:=False
  
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Formel setzen"
  End If
  'Formel setzen I/E
  Dim celladdress, celladdressOffset As String
  celladdress = funstraddr_byname("hlp_export_c_zuschlaginklexkl")
  celladdressOffset = ThisWorkbook.Sheets(sheetname).Range(celladdress).Offset(-1, 0).Address(False, False)
  Application.Workbooks(filenameTarget).Sheets(sheetname).Range(celladdress).Formula = _
    "=IF(ISBLANK(" & celladdressOffset & "),"""",IF(LEFT(" & celladdressOffset & _
    ",1)=""2"",hlp_export_c_text_inkl,hlp_export_c_text_exkl))"
  
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Formel hlp_export_col_skillcalculated"
  End If
  'Formel setzen Spalte hlp_export_col_skillcalculated
  celladdress = funstrcol_byname("hlp_export_col_skillcalculated")
  celladdressOffset = Application.Workbooks(filenameTarget).Sheets(sheetname).Range(celladdress & lngRowFirst).Offset(-1, -2).Address(False, False)

  Application.Workbooks(filenameTarget).Sheets(sheetname).Range(celladdress & (lngRowFirst - 1) & _
    ":" & celladdress & lngRowFirst + lnganzdatensaetze - 2).Formula = _
    "=IF(OR(ISBLANK(" & celladdressOffset & "),NOT(ISNUMBER(" & celladdressOffset & ")))," & _
    Application.Workbooks(filenameTarget).Sheets(sheetname).Range(celladdress & lngRowFirst).Offset(-1, -1).Address(False, False) & _
    "," & celladdressOffset & ")*1"
  
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Namen loeschen"
  End If
  'Alle Namen mit Bezuegen auf andere Blaetter loeschen wegen externer Bezuege auf Ursprungsdatei
  intLast = Application.Workbooks(filenameTarget).Names.Count
  'Application.Workbooks(filenameTarget).Sheets(1).EnableCalculation = False
  'Application.ScreenUpdating = False
  Call silentCodeForExternalWorkbook(Application.Workbooks(filenameTarget))
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet Anzahl zu loeschende Namen " & Application.Workbooks(filenameTarget).Names.Count
    'Debug.Print "Events " & Application.EnableEvents & ", Screen " & Application.ScreenUpdating & " Calculation " & Application.Calculation
  End If
  'Hier geht die Zeit verloren, laesst sich auch nicht mit SilentCode beheben!
  'Das Performance-Problem tritt nur nach der Auswertung auf.
  'intCounter nicht durch foreach mit Collection ersetzen, ist etwas langsamer!
  'Es scheint sich um Bug zu handeln, der in Excel 2010 und evtl. in Excel 2013 auftritt, aber nicht in Excel 2007!
  'Quelle: http://answers.microsoft.com/en-us/office/forum/office_2010-excel/bug-excel-2010-deleting-range-names-with-vba-is/5b467e10-515a-46d7-9a52-06821856ae10?auth=1
  If intLast > 0 Then
    For intCounter = intLast To 1 Step -1
      If InStr(Application.Workbooks(filenameTarget).Names(intCounter).name, sheetname) = 0 _
        And InStr(Application.Workbooks(filenameTarget).Names(intCounter).name, "_xlfn") = 0 Then
        Application.Workbooks(filenameTarget).Names(intCounter).delete
  '        If ISTEST Then
  '          Debug.Print Timer & ": export_ebgsheet " & Application.Workbooks(filenameTarget).Names(intCounter).Name & " geloescht"
  '        End If
      End If
    Next
  End If
  
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Verknuepfungen loeschen"
  End If
  'Alle Verknuepfungen loeschen
  aLinks = Application.Workbooks(filenameTarget).LinkSources(Type:=xlExcelLinks)
  
  If Not IsEmpty(aLinks) Then
    intLast = UBound(aLinks)
    For intCounter = intLast To 1 Step -1
      Application.Workbooks(filenameTarget).BreakLink _
          name:=aLinks(intCounter), _
          Type:=xlLinkTypeExcelLinks
    Next
  End If
  
  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Speichern"
  End If
  'Exportierte Datei speichern
  filenameSaveAs = FILENAME_EXPORT & language & "_" & Format(Now, "yyyymmdd_hhMMss") & extension
  'funktioniert auch auf Mac
  Application.Workbooks(filenameTarget).SaveAs Filename:= _
    ThisWorkbook.Path & Application.PathSeparator & filenameSaveAs, FileFormat:= _
    newfileformat, CreateBackup:=False

  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet vor Endverarbeitung"
  End If
  Call restoreForExternalWorkbook(Application.Workbooks(filenameSaveAs))
  'Endverarbeitung: Sheet schuetzen
  Windows(filenameSaveAs).Activate
  Call hlp_protectexportsheet(Application.Workbooks(filenameSaveAs).Sheets(sheetname))
  Application.Workbooks(filenameSaveAs).Sheets(sheetname).Range("E8").Select
  
  'In Excel11 auf Mac wird Datei nicht in Vordergrund geholt -> Meldung
  If Application.OperatingSystem Like "*Mac*" Then
    Call MsgBox(strtranslate("msgbox_data_form.export.mac"), vbOKOnly)
  ElseIf funvarvalue_byname("hlp_const_c_ausgewertet") = True Then
    Call MsgBox(strtranslate("frmfortschrittsanzeige.lblerklaerung.export"), vbOKOnly)
  End If

  If ISTEST Then
    Debug.Print Timer & ": export_ebgsheet Ende"
    Debug.Print "Events " & Application.EnableEvents & ", Screen " & Application.ScreenUpdating & " Calculation " & Application.Calculation
  End If
  
  Exit Sub
  
fehler:
  'Call senderrormail(straktiveprozedur)
  Debug.Print err.Description
  Resume Next

End Sub

'*******************************************************************
'Wechselt in Range das Dezimaltrennzeichen von , zu . oder umgekehrt
'Achtung:  funktioniert nicht bei Zahlen mit vielen Stellen
'SR 11.12.2018 nur bei CH Version angewendet
Sub change_decimal_separator(ByVal Target As Range)
  Dim localwhat As String
  Dim localreplacement As String
  If funvarvalue_byname("hlp_const_c_laenderversion") = "ch" Then
    'SR 13.04.2016 Ersetzt Leerschlag als Tausendertrennzeichen
    Target.Replace what:=" ", replacement:="", LookAt:=xlPart, _
          SearchOrder:=xlByColumns, MatchCase:=False
    
    'SR 13.04.2016 Ersetzt Apostroph als Tausendertrennzeichen
    Target.Replace what:="'", replacement:="", LookAt:=xlPart, _
          SearchOrder:=xlByColumns, MatchCase:=False
    
    localwhat = ","
    localreplacement = "."
    If Application.International(xlDecimalSeparator) = "," Then
      localwhat = "."
      localreplacement = ","
    End If
    'ReplaceFormat und SearchFormat sind nicht Mac-tauglich
    Target.Replace what:=localwhat, replacement:=localreplacement, LookAt:=xlPart, _
          SearchOrder:=xlByColumns, MatchCase:=False ', SearchFormat:=False, _
          'ReplaceFormat:=False
  End If
End Sub


'*******************************************************************
'Soll bei sprachunabhaengigem hlp_export das richtige Logo setzen
Sub setLogoForhlp_export()
  'Tschechische Version ohne Logos
  If getLaenderversion = "ch" Then
    'Sprache aus Konstante holen
    Dim language As String
    language = funvarvalue_byname("hlp_const_c_sprache")
    language = LCase(language)
    Dim blnProtected As Boolean
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT_LOGOS).Visible = True
    
    'nur ausfuehren, wenn Blatt sichtbar und jobliste vorhanden
    If ThisWorkbook.Sheets(STR_SH_HLP_EXPORT_LOGOS).Visible Then
      'Blatt entsperren
      'blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
      ThisWorkbook.Worksheets(STR_SH_HLP_EXPORT_LOGOS).Unprotect Password:=changeToNumberString("s")
    End If
    
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT_LOGOS).Select
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT_LOGOS).Shapes.Range(Array("export_logo_" & getLaenderversion & "_" & language)).Select
     
    Selection.Copy
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT_LOGOS).Range("a1").Select
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Select
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Range("B1").Select
    ActiveSheet.Paste
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Range("C1").Select
    
    If Not ISTEST Then
      ThisWorkbook.Sheets(STR_SH_HLP_EXPORT_LOGOS).Visible = False
    End If
  End If
End Sub

'Zum Testen von setLogoForhlp_export
Sub testSetLogoForhlp_export()
  Dim language As String
  language = "D"
  Call setLogoForhlp_export(language)
End Sub

'*******************************************************************
'Loescht Logo auf Vorlage nach dem Export
Sub deleteLogoForhlp_export()
  Dim counter As Integer
  ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Select
  If ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Shapes.Count > 0 Then
    ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Range("a1").Select
    For counter = ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Shapes.Count To 1 Step 1
      ThisWorkbook.Sheets(STR_SH_HLP_EXPORT).Shapes.Range(Array(counter)).delete
    Next
  End If
End Sub


'*******************************************************************
'joblist exportieren
Private Sub btnjoblistexport_Click()
  On Error GoTo fehler
  Call updateActiveProc("ImportExport.btnjoblistexport_Click")
  
  Dim lnglastfilledrowsource As Long
  Dim newfileformat
  Dim objWorkbook As Workbook
  Dim objSheet As Worksheet
  Dim strcolstartsource As String
  Dim strcolendsource As String
  Dim strstartrangesource As String
  Dim strFilename As String
  Dim strextension As String
  Dim strlanguage As String
  
  Const STR_PREFIX_FILENAME As String = "Joblist_"
  
  'Spalten der Jobliste bestimmen und kopieren
  'Ab 3.0.7 inklusive Headertexte exportieren
  'strstartrangesource = funstraddr_byname("joblist_col_job")
  strstartrangesource = funstraddr_byname("joblist_lst_header")
   
  strcolendsource = funstrfirstcol_byrange(ThisWorkbook.Names("joblist_lst").RefersToRange.Offset(0, 1))
  strcolstartsource = funstrcol_byname("joblist_col_job")
  lnglastfilledrowsource = funlnglastfilledrowincol(ThisWorkbook.name, _
    STR_SH_JOBLIST, strcolstartsource)
  ThisWorkbook.Sheets(STR_SH_JOBLIST).Range(strstartrangesource & ":" _
    & strcolendsource & lnglastfilledrowsource).Copy
    
    
  'Neue Arbeitsmappe erstellen
  Set objWorkbook = Workbooks.Add
  'Kopierten Bereich als Werte einfuegen
  'funktioniert auch auf Mac, getestet
  objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER) _
    .PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
  
  'Formatierung Labels
  objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER) _
    .PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _
    SkipBlanks:=False, Transpose:=False
      
  'Ab 3.0.7 ganzen Header kopieren
  ThisWorkbook.Names("joblist_lst_header").RefersToRange.Copy
  objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER) _
    .PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
  'Formatierung Header
  objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER) _
    .PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
  'Spaltenbreite anpassen
  objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER) _
    .PasteSpecial Paste:=xlPasteColumnWidths, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
  'Zeilenhoehe des Headers anpassen
  objWorkbook.Worksheets(1).Range(objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER).Row & _
    ":" & objWorkbook.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER).Row + 2).Rows.AutoFit
    
  'Titel uebernehmen
  objWorkbook.Worksheets(1).Range("A1").Value = ThisWorkbook.Sheets(STR_SH_JOBLIST).Range("B1").Value
  
  'Stand einfuegen
  objWorkbook.Worksheets(1).Range("B1").Value = strtranslate("joblist.export.stand") & " " & Now
  
  'zusaetzliche Erklaerung einfuegen
  objWorkbook.Worksheets(1).Range("A2").Value = strtranslate("joblist.export.untertitel")
  With objWorkbook.Worksheets(1).Range("A2:B2")
      .HorizontalAlignment = xlLeft
      .MergeCells = True
  End With
  
  'Formatierung Titel
  With objWorkbook.Worksheets(1).Range("A1:A1").Font
    .Bold = True
    .name = "Arial"
    .Size = 14
  End With
  
  'Spaltenbreite anpassen
  objWorkbook.Worksheets(1).Columns("A:B").EntireColumn.AutoFit
  
  'Blatt benennen
  objWorkbook.Worksheets(1).name = "joblist"
  
  'Silent Mode: Prompts mit Warnungen unterdruecken
  Application.DisplayAlerts = False
  'Ueberfluessige Sheets loeschen
  For Each objSheet In objWorkbook.Sheets
    If objSheet.Index > 1 Then
      objSheet.delete
    End If
  Next
  Application.DisplayAlerts = True
  
  'Exportierte Datei speichern
  Call get_fileformat_extension(newfileformat, strextension)
  strlanguage = LCase(ThisWorkbook.Names("hlp_const_c_sprache").RefersToRange.Value)
  strFilename = STR_PREFIX_FILENAME & strlanguage & "_" & Format(Now, "yyyymmdd_hhMMss") & strextension
  'funktioniert auch auf Mac
  objWorkbook.SaveAs Filename:= _
    ThisWorkbook.Path & Application.PathSeparator & strFilename, FileFormat:= _
    newfileformat, CreateBackup:=False
  
  'In Excel11 auf Mac wird Datei nicht in Vordergrund geholt -> Meldung
  If Application.OperatingSystem Like "*Mac*" Then
    Call MsgBox(strtranslate("msgbox_data_form.export.mac"), vbOKOnly)
  End If
  
  Exit Sub
fehler:
  Application.DisplayAlerts = True
  Call senderrormail(straktiveprozedur)
  Debug.Print err.Description
  Resume Next
  
End Sub

'*******************************************************************
'Sortiert die Joblist
'Aufgerufen von
' - sheet_data_form.btnjoblistsort_Click
' - ImportExport.btnjoblistimport_Click
Sub sortJoblistClick()
  Dim blnProtected As Boolean
  Dim strNameColToSort As String
  strNameColToSort = "joblist_col_job"
  
  'nur ausfuehren, wenn Blatt sichtbar und jobliste vorhanden
  If ThisWorkbook.Sheets(STR_SH_JOBLIST).Visible And funIsNameARange("joblist_lst") Then
    'Blatt entsperren
    blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")
  
    If ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields.Count >= 1 Then
      If ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields(1).Key.Column = _
        ThisWorkbook.Names("joblist_col_job").RefersToRange.Column Then
        strNameColToSort = "joblist_col_anfniveau"
      End If
    End If
    Call sortJoblist(strNameColToSort)
    
    'Buttontext von btnjoblistsort wechseln
    If strNameColToSort = "joblist_col_job" Then
      Call translateButton(STR_SH_JOBLIST, "btnjoblistsort", "joblist.lblbtnjoblistsort.anfniveau")
    Else
      Call translateButton(STR_SH_JOBLIST, "btnjoblistsort", "joblist.lblbtnjoblistsort.job")
    End If
    
    'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
    Call protectSheet(STR_SH_JOBLIST, blnProtected)
  End If
End Sub

'*******************************************************************
'joblist importieren aus Datei joblist
Private Sub btnjoblistimport_Click()
  If Not ISTEST Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("ImportExport.btnjoblistimport_Click")
  
  Dim blnProtected As Boolean
  Dim blnoverwrite As Boolean
  Dim blnImportabbruch As Boolean
  Dim intFirstRowDataSource, intFirstRowDataTarget As Integer
  Dim lngColTmp As Long
  Dim lngLastRowDataSource As Long
  Dim lngLastRowFilledTarget As Long
  Dim objCellTarget As Range
  Dim objCellSource As Range
  Dim objSourceRangeStart As Range
  Dim objWorkbookSource As Workbook
  Dim strFilename As String
  Dim strColJobSource As String
  Dim strColStartTarget As String
  Dim strColTmp As String
  Dim intColStartTarget As Integer
  Dim strTargetColAnfniveau
  
  'Importdatei holen
  strFilename = import_openfile(strtranslate("import.dateityp") & ", *.xlsx")
  blnImportabbruch = False
  
  If strFilename = "" Then
    MsgBox strtranslate("import.abgebrochen")
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Select
    blnImportabbruch = True
    Exit Sub
  End If
  
  'Importdatei oeffnen
  Set objWorkbookSource = Application.Workbooks.Open(Filename:=strFilename)
  'strWorkbookName = Application.ActiveWorkbook.Name
  
  'Startzelle der Liste in Zeile mit Labels setzen
  Set objSourceRangeStart = objWorkbookSource.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_LIST_VORVERSION)
  If Not IsNumeric(objSourceRangeStart.Offset(1, 1)) Or IsEmpty(objSourceRangeStart.Offset(1, 1)) Then
    Set objSourceRangeStart = objWorkbookSource.Worksheets(1).Range(STR_EXPORT_JOBLIST_START_LIST)
  End If
  'Datenbereich uberpruefen
  If IsEmpty(objSourceRangeStart) Or TypeName(objSourceRangeStart.Value) <> "String" _
    Or IsEmpty(objSourceRangeStart.Offset(0, 1)) Or TypeName(objSourceRangeStart.Offset(0, 1).Value) <> "String" _
    Or IsEmpty(objSourceRangeStart.Offset(1, 0)) Or TypeName(objSourceRangeStart.Offset(1, 0).Value) <> "String" _
    Or IsEmpty(objSourceRangeStart.Offset(1, 1)) Or Not IsNumeric(objSourceRangeStart.Offset(1, 1).Value) _
    Or Not IsEmpty(objSourceRangeStart.Offset(0, 2)) Then
    Call MsgBox(strtranslate("joblist.msg.import.error"), vbOKCancel)
    objWorkbookSource.Close False
    Exit Sub
  End If
  
  'Testen ob bereits Kompetenzniveaus vorhanden (SUMME)
  strTargetColAnfniveau = funstrfirstcol_byrange(ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange)
  intFirstRowDataTarget = FirstRowInRange(ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange.Offset(1, 0))
  blnoverwrite = True
  If funIsNameARange("joblist_lst") Then
    'Gibt es Zahlen in versteckter Spalte Kompetenzniveau
    'ThisWorkbook.Names("joblist_lst").RefersToRange.Range("A1").Offset(0,1)
    lngLastRowFilledTarget = LastRowInRange(ThisWorkbook.Names("joblist_lst").RefersToRange)
    For Each objCellTarget In ThisWorkbook.Worksheets(STR_SH_JOBLIST).Range( _
      strTargetColAnfniveau & intFirstRowDataTarget & ":" & strTargetColAnfniveau & lngLastRowFilledTarget)
      
      If IsNumeric(objCellTarget.Value) Then
        'Importvariante abfragen: Overwrite oder nicht
        blnoverwrite = (MsgBox(strtranslate("joblist.msg.import"), vbYesNo) = vbYes)
        Exit For
      End If
    Next
  Else
    lngLastRowFilledTarget = intFirstRowDataTarget - 1
  End If
  

  'joblist importieren
  Call lastcolandrow(objWorkbookSource.name, objWorkbookSource.Worksheets(1).name, _
    strColTmp, lngColTmp, lngLastRowDataSource)
  
  
  'Range Target
  intFirstRowDataTarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Row + 1
  strColStartTarget = funstrcol_byname("joblist_col_job")
  lngLastRowFilledTarget = funlnglastfilledrowincol(ThisWorkbook.name, _
    STR_SH_JOBLIST, strColStartTarget)
  
  'Source
  strColJobSource = Left(STR_EXPORT_JOBLIST_START_HEADER, 1)

  'Start- und Endzeile des Datenbereichs Source bestimmen
  intFirstRowDataSource = _
    objWorkbookSource.Sheets(1).Range(STR_EXPORT_JOBLIST_START_HEADER).Row + 1
  lngLastRowDataSource = funlnglastfilledrowincol(objWorkbookSource.name, _
    objWorkbookSource.Sheets(1).name, strColJobSource)
    
  'Sind ueberhaupt Daten in Source-Datei vorhanden?
  If lngLastRowDataSource >= intFirstRowDataSource Then
  
    'Event-Handler
    Call silentCode
    Application.Calculation = xlCalculationManual
    
    'Blatt entsperren
    blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")
    Set objCellTarget = ThisWorkbook.Sheets(STR_SH_JOBLIST).Range(strColStartTarget & (lngLastRowFilledTarget + 1))
    
    For Each objCellSource In objWorkbookSource.Sheets(1).Range( _
      objSourceRangeStart.Offset(1, 0).Address(False, False) & ":" & _
      funstrfirstcol_byrange(objSourceRangeStart) & lngLastRowDataSource)
      
      Call updateJoblist(objCellTarget, lngLastRowFilledTarget, objCellSource, strColStartTarget, _
        intFirstRowDataTarget, blnoverwrite)
    Next
    
    lngLastRowFilledTarget = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_JOBLIST, _
      funstrcol_byname("joblist_col_job"))
    'benannten Bereich anpassen (Achtung, ohne erste Spalte wegen SVerweis)
    intColStartTarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Column
    ThisWorkbook.Names("joblist_lst").RefersToR1C1 = "=joblist!R" & intFirstRowDataTarget _
      & "C" & intColStartTarget & ":R" & lngLastRowFilledTarget & "C" & (intColStartTarget + 5)

    'Entstandene Liste sortieren
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields.Clear
    Call sortJoblistClick
   
    'Blatt wird nur geschuetzt, wenn man nicht im Testmode ist
    
    Call protectSheet(STR_SH_JOBLIST, Not ISTEST)
    
    objWorkbookSource.Close False
    
    'Restore Events etc
    Call restore
    Application.Calculation = xlCalculationAutomatic
  End If
  
  Exit Sub
fehler:
  Call senderrormail(straktiveprozedur)
  Debug.Print err.Description
  Resume Next
  
End Sub

'*******************************************************************
'joblist importieren aus EBG Form
'Vorbedingung: kein Mappenschutz
Private Sub joblistimport_from_form(ByRef objWorkbookSource As Workbook, ByVal blnIsImportVor_V3_1_0 As Boolean)
  If Not ISTEST Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("ImportExport.joblistimport_from_form")
  
  Dim intSourceColOffset As Integer
  intSourceColOffset = 2 'Offset von Spalte Funktion zu Kompetenzniveau aus Liste
  Dim blnProtected As Boolean
  Dim blnoverwrite As Boolean
  Dim blnImportabbruch As Boolean
  Dim intFirstRowDataSource, intFirstRowDataTarget As Integer
  Dim lngColTmp As Long
  Dim lngLastRowDataSource As Long
  Dim lngLastRowFilledTarget As Long
  Dim objCellTarget As Range
  Dim objCellSource As Range
  Dim objSourceRangeStart As Range
  'Dim objWorkbookSource As Workbook
  Dim strFilename As String
  Dim strColJobSource As String
  Dim strColStartTarget As String
  Dim strColTmp As String
  Dim intColStartTarget As Integer
  Dim strTargetColAnfniveau
  
  If Not ThisWorkbook.Sheets(STR_SH_JOBLIST).Visible Then
    Call blatt_einblenden(STR_SH_JOBLIST, changeToNumberString("m"))
  End If
    
  
  'Startzelle der Liste in Zeile mit Labels setzen
  Set objSourceRangeStart = objWorkbookSource.Worksheets(1) _
    .Range(STR_HLP_EXPORT_CD).Offset(-2, ThisWorkbook.Names("data_form_col_jobmanual").RefersToRange.Column - 1)
  If blnIsImportVor_V3_1_0 Then
    Set objSourceRangeStart = objWorkbookSource.Worksheets(1) _
      .Range(STR_HLP_EXPORT_CD).Offset(-3, ThisWorkbook.Names("data_form_col_jobmanual").RefersToRange.Column - 1)
  End If
  'STR_HLP_EXPORT_CD
  'Datenbereich uberpruefen
  'SR 20.03.2018 auf erste 2 Datenzeilen erweitert
  If IsEmpty(objSourceRangeStart) Or TypeName(objSourceRangeStart.Value) <> "String" _
    Or IsEmpty(objSourceRangeStart.Offset(0, intSourceColOffset)) _
    Or TypeName(objSourceRangeStart.Offset(0, intSourceColOffset).Value) <> "String" _
    Or IsEmpty(objSourceRangeStart.Offset(1, 0)) Or TypeName(objSourceRangeStart.Offset(1, 0).Value) <> "String" _
    Or (IsEmpty(objSourceRangeStart.Offset(1, intSourceColOffset)) _
      And IsEmpty(objSourceRangeStart.Offset(2, intSourceColOffset))) _
    Or (Not IsNumeric(objSourceRangeStart.Offset(1, intSourceColOffset).Value) _
      And Not IsNumeric(objSourceRangeStart.Offset(2, intSourceColOffset).Value)) Then _

    'Fehlermeldung
    Call MsgBox(strtranslate("joblist.msg.ebg.error"), vbOKCancel)
    Exit Sub
  End If
  
  'Testen ob bereits Kompetenzniveaus vorhanden (SUMME)
  strTargetColAnfniveau = funstrfirstcol_byrange(ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange)
  intFirstRowDataTarget = FirstRowInRange(ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange.Offset(1, 0))
  blnoverwrite = True 'Joblist wird immer aus Formular neu erstellt
  If Not funIsNameARange("joblist_lst") Then
    lngLastRowFilledTarget = intFirstRowDataTarget - 1
  End If
  

  'Dim strColTmp, lngColTmp 'nicht verwendet
  Call lastcolandrow(objWorkbookSource.name, objWorkbookSource.Worksheets(1).name, _
    strColTmp, lngColTmp, lngLastRowDataSource)
  
  
  'Range Target
  intFirstRowDataTarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Row + 1
  strColStartTarget = funstrcol_byname("joblist_col_job")
  lngLastRowFilledTarget = funlnglastfilledrowincol(ThisWorkbook.name, _
    STR_SH_JOBLIST, strColStartTarget)
  
  'Source
  strColJobSource = funstrfirstcol_byrange(objSourceRangeStart)

  'Start- und Endzeile des Datenbereichs Source bestimmen
  intFirstRowDataSource = objSourceRangeStart.Row + 1
  lngLastRowDataSource = funlnglastfilledrowincol(objWorkbookSource.name, _
    objWorkbookSource.Sheets(1).name, strColJobSource)
    
  'Sind ueberhaupt Daten in Source-Datei vorhanden?
  If lngLastRowDataSource >= intFirstRowDataSource Then
  
    'Event-Handler
'    If Not ISTEST Then
'      Call silentCode
'      Application.Calculation = xlCalculationManual
'    End If
    
    'Blatt entsperren
    blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")
    Set objCellTarget = ThisWorkbook.Sheets(STR_SH_JOBLIST).Range(strColStartTarget & (lngLastRowFilledTarget + 1))
    
    For Each objCellSource In objWorkbookSource.Sheets(1).Range( _
      objSourceRangeStart.Offset(1, 0).Address(False, False) & ":" & _
      funstrfirstcol_byrange(objSourceRangeStart) & lngLastRowDataSource)
      
      Call updateJoblist(objCellTarget, lngLastRowFilledTarget, objCellSource, strColStartTarget, _
        intFirstRowDataTarget, blnoverwrite, intSourceColOffset)
    Next
    
    lngLastRowFilledTarget = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_JOBLIST, _
      funstrcol_byname("joblist_col_job"))
    'benannten Bereich anpassen (Achtung, ohne erste Spalte wegen SVerweis)
    intColStartTarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Column
    ThisWorkbook.Names("joblist_lst").RefersToR1C1 = "=joblist!R" & intFirstRowDataTarget _
      & "C" & intColStartTarget & ":R" & lngLastRowFilledTarget & "C" & (intColStartTarget + 5)

    'Entstandene Liste sortieren
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields.Clear
    Call sortJoblistClick
   
    'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war  Call protectSheet(STR_SH_DATA_FORM, true)
    Call protectSheet(STR_SH_JOBLIST, blnProtected)
  End If
  
  Exit Sub
fehler:
  Call senderrormail(straktiveprozedur)
  Debug.Print err.Description
  Resume Next
  
End Sub

'*******************************************************************
'Liste mit Berufen auf Blatt joblist erstellen
'Optimierung: Formatierungen nicht zeilenweise machen %%%%%
Sub btnJoblist_Click()
  'On Error GoTo fehler
  Call updateActiveProc("sheet_data_form.btnJoblist_Click")
  
  Dim intFirstRowDataSource, intFirstRowDataTarget As Integer
  Dim lngLastRowDataSource As Long
  Dim objCellSource As Range
  Dim objCellTarget As Range
  Dim lngLastRowFilledTarget As Long
  Dim strColJobSource As String
  Dim strColStartTarget As String
  Dim intColStartTarget As Integer
  Dim blnProtected As Boolean
  
  'Ist Blatt data_form sichtbar
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Visible Then
    Call silentCode
    If Not ThisWorkbook.Sheets(STR_SH_JOBLIST).Visible Then
      'Mappe entsperren, Blatt anzeigen
      Call mappenschutz_aus
      ThisWorkbook.Sheets(STR_SH_JOBLIST).Visible = True
      Call mappenschutz_ein
    End If
    
    'Blatt entsperren
    blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")
    
    intFirstRowDataTarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Row + 1
    strColStartTarget = funstrcol_byname("joblist_col_job")
    lngLastRowFilledTarget = funlnglastfilledrowincol(ThisWorkbook.name, _
      STR_SH_JOBLIST, strColStartTarget)
    strColJobSource = funstrcol_byname("data_form_col_jobmanual")
  
    'Start- und Endzeile des Datenbereichs bestimmen
    intFirstRowDataSource = _
      ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
    lngLastRowDataSource = funlnglastfilledrowincol(ThisWorkbook.name, _
      STR_SH_DATA_FORM, strColJobSource)
    
    If intFirstRowDataSource <= lngLastRowDataSource Then
      Set objCellTarget = ThisWorkbook.Sheets(STR_SH_JOBLIST).Range(strColStartTarget & (lngLastRowFilledTarget + 1))
      'Verschiedene Berufe aus Liste ziehen
      For Each objCellSource In ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
        strColJobSource & intFirstRowDataSource & ":" & strColJobSource & lngLastRowDataSource)
        
        Call updateJoblist(objCellTarget, lngLastRowFilledTarget, objCellSource, strColStartTarget, _
          intFirstRowDataTarget, False)
      Next
    Else
      MsgBox (strtranslate("msgbox_joblist.keine.daten"))
      Call restore
      Exit Sub
    End If

    'letzte ausgefuellte Zeile finden
    lngLastRowFilledTarget = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_JOBLIST, _
      funstrcol_byname("joblist_col_job"))
    'benannten Bereich anpassen (Achtung, ohne erste Spalte wegen SVerweis)
    intColStartTarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Column
    ThisWorkbook.Names("joblist_lst").RefersToR1C1 = "=joblist!R" & intFirstRowDataTarget _
      & "C" & intColStartTarget & ":R" & lngLastRowFilledTarget & "C" & (intColStartTarget + 5)

    'Entstandene Liste sortieren
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields.Clear
    Call sortJoblistClick

    'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
    Call protectSheet(STR_SH_JOBLIST, blnProtected)

    'Liste auswaehlen
    ThisWorkbook.Sheets(STR_SH_JOBLIST).Select
    
  End If
  Call restore
  Exit Sub
  
fehler:
  Debug.Print "Fehler in btnJoblist_Click"

  Call protectSheet(STR_SH_JOBLIST, True)
  'Debug.Print "Prozedur " & straktiveprozedur & " " & strmeldung & vbCrLf & _
  '  "Fehler-Nr.: " & Err.Number & vbCrLf & Err.Description & vbCrLf & "Quelle: " & Err.Source
  Call mappenschutz_ein
  Call restore
End Sub

'*******************************************************************
'joblist loeschen
Sub btnjoblistdelete_Click()
  Call updateActiveProc("ImportExport.btnjoblistdelete_Click")
  If MsgBox(strtranslate("joblist.msg.delete"), vbYesNo) = vbYes Then
    Call clearJoblist(True)
  End If
End Sub

'*******************************************************************
'Hilfsmakros zum Kopieren der Diagramme
'Jedes Chart braucht eigenen Makro fuer Aufruf
Sub copy_chart(ByVal sheetname As String, ByVal chartname As String)
  If MsgBox(strtranslate("rpt_regr.copychartquestion"), vbYesNo) = vbYes Then
    'Hier wird temporaer Schutz fuer Diagramme aufgehoben mit DrawingObjects:=False
    ThisWorkbook.Sheets(sheetname).Protect Password:=changeToNumberString("s"), DrawingObjects:=False, Contents:=True, Scenarios:=True
    ThisWorkbook.Sheets(sheetname).ChartObjects(chartname).Chart.ChartArea.Copy
    'muss bis zum Paste offen bleiben!
    'ThisWorkbook.Sheets(sheetname).Protect Password:=changeToNumberString("s"), DrawingObjects:=True, Contents:=True, Scenarios:=True
    MsgBox (strtranslate("rpt_regr.copychartmessage"))
  End If
End Sub

Private Sub rpt_regr2_1_chartlohnprog_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_1", "chartlohnprog")
End Sub

Private Sub rpt_regr2_2_chart1_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_2", "Chart 1")
End Sub

Private Sub rpt_regr2_2_chart2_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_2", "Chart 2")
End Sub

Private Sub rpt_regr2_3_chart1_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_3", "Chart 1")
End Sub

Private Sub rpt_regr2_3_chart2_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_3", "Chart 2")
End Sub

Private Sub rpt_regr2_4_chart1_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_4", "Chart 1")
End Sub

Private Sub rpt_regr2_4_chart3_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_4", "Chart 3")
End Sub

Private Sub rpt_regr2_5_chart1_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_5", "Chart 1")
End Sub

Private Sub rpt_regr2_5_chart3_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_5", "Chart 4")
End Sub

Private Sub rpt_regr2_6_chart1_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_6", "Chart 1")
End Sub

Private Sub rpt_regr2_6_chart2_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_6", "Chart 2")
End Sub

Private Sub rpt_regr2_7_chart1_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_7", "Chart 1")
End Sub

Private Sub rpt_regr2_7_chart2_onclick()
   Call copy_chart(STR_SH_RPT_REGR & "2_7", "Chart 2")
End Sub

Private Sub cockpit_chartquartile_onclick()
  Call copy_chart(STR_SH_COCKPIT, "cockpit_chart_quartile")
End Sub

Private Sub cockpit_chartlohnsumme_onclick()
  Call copy_chart(STR_SH_COCKPIT, "cockpit_chart_lohnsumme")
End Sub

Private Sub cockpit_chartlohnbestandteile_onclick()
  Call copy_chart(STR_SH_COCKPIT, "cockpit_chart_lohnbestandteile")
End Sub
Attribute VB_Name = "Superlogib"
Option Explicit
Option Private Module

'*******************************************************************
'Modul enthaelt alles zur Steuerung von Superlogib
'- Erzeugung Kontrollformular
'- spaeter Pivot-Tabellen fuer EBG
'Steuerung laeuft immer ueber Funktion blnIsControlForm
'am 04.02.2016 reagiert diese Funktion darauf, ob das Titelblatt ausgeblendet ist

'*******************************************************************
'liefert zurueck, ob Logib im Kontrollformularmodus ist
'Erstellt:         04.02.2016
'Letzte Aenderung: 04.02.2016
Function blnIsControlForm() As Boolean
  blnIsControlForm = Not ThisWorkbook.Sheets(STR_SH_TITLE).Visible
End Function


'*******************************************************************
'ueberprueft, ob genuegend gueltige Daten vorhanden sind
'und gibt andernfalls Meldung aus
Function blnIsAnzahlGueltigeDatenGenuegend() As Boolean
  Dim result As Boolean
  result = False
  If IsNumeric(funvarvalue_byname("data_form_c_anzerw")) Then
    If funvarvalue_byname("data_form_c_anzerw") >= funvarvalue_byname("hlp_const_c_minanzerw") Then
      result = True
    End If
  End If
  If result = False Then
      MsgBox strtranslate("msgbox_data_form.ueberpruefen"), vbOKOnly + vbCritical
  End If
  blnIsAnzahlGueltigeDatenGenuegend = result
End Function


'*******************************************************************
'blendet die Sheets fuer Kontrollformular ein- oder aus
'Erstellt:         04.02.2016
'Letzte Aenderung: 04.02.2016
Sub toggleSheetsControlForm(ByVal blnIsVisible As Boolean)
  Dim objArray(1 To 3) As String
  objArray(1) = "title"
  objArray(2) = "intro"
  objArray(3) = "license"
  Call blaetterEinAusblenden(objArray, blnIsVisible)

End Sub


'*******************************************************************
'Blendet Spalten auf einem Blatt ein- oder aus
'Erstellt:         20.04.2016
Sub toggleColumns(ByRef objSheet As Worksheet, ByVal objArray As Variant, ByVal blnIsHidden As Boolean)
  Dim strColumn As Variant
  objSheet.Unprotect Password:=changeToNumberString("s")
  For Each strColumn In objArray
    objSheet.Range(strColumn & "1").EntireColumn.Hidden = blnIsHidden
  Next
  Call protectSheet(STR_SH_JOBLIST, True)
End Sub


'*******************************************************************
'erzeugt Kontrollformulare fuer alle Sprachen in hlp_const_vec_sprachen_ch
'Erstellt:         04.02.2016
'Letzte Aenderung: 04.02.2016
'Ab Version 3.0.3 macht der Makro alle notwendigen Schritte inkl. zuruecksetzen des Sprachfeldes
Sub saveControlForm()
  Dim strPathAndFilename As String
  Dim objZelle
  '"D:\dateienmitback\dateien\auftraege\logib_ch_2010\_kontrollformular\"
  strPathAndFilename = ThisWorkbook.Path & Application.PathSeparator & "_kontrollformular" _
    & Application.PathSeparator _
    & Replace(Replace(ThisWorkbook.name, "logib", "Kontrollformular"), ".xlsm", "") _
    
    
  Call set_userview
  
  'SaveAs funktioniert nur am Schluss des Makros, nach dem Befehl wird abgebrochen
'  ThisWorkbook.SaveAs filename:= _
'      strPathAndFilename _
'      , FileFormat:=xlOpenXMLWorkbookMacroEnabled, CreateBackup:=False
  
  Call toggleSingleButton("data_head", "btndeletedata", False)
  
  Dim objArray(1 To 2) As String
  objArray(1) = "btnauswertung"
  objArray(2) = "btndeletedatadf"
  Call toggleArrayOfButtons("data_form", objArray(), False)
  'Call toggleSingleButton("data_form", "btnauswertung", False)
  'Call toggleSingleButton("data_form", "btndeletedatadf", False)
  
  'Auswertungsspalten auf Data werden im Kontrollformular ausgeblendet
  'Ab 3.1.0 6 statt 4 Spalten und andere Spalten -> via Name
  Dim objArrayColumns As Variant
  objArrayColumns = Array( _
    funstrcol_byname("data_form_col_gesverdienst"), funstrcol_byname("data_form_col_filter_erw"), _
    funstrcol_byname("data_form_col_mbls_prog_gn"), funstrcol_byname("data_form_col_filterunwahrsch_gn"), _
    funstrcol_byname("data_form_col_mbls_prog"), funstrcol_byname("data_form_col_filterunwahrsch"))
  Call toggleColumns(ThisWorkbook.Sheets("data_form"), objArrayColumns, True)
  
  'Blaetter ausblenden
  Call toggleSheetsControlForm(False)
  
  'Dieses Workbook wird nicht geoeffnet
  For Each objZelle In ThisWorkbook.Names("hlp_const_vec_sprachen_ch").RefersToRange
    ThisWorkbook.Names("title_c_sprachauswahl").RefersToRange.Value = objZelle.Value
    ActiveWorkbook.SaveCopyAs strPathAndFilename & "_" & funvarvalue_byname("hlp_const_c_sprache") & ".xlsm"
  Next
  
  'Alles wieder zuruecksetzen
  Call toggleSingleButton("data_head", "btndeletedata", True)
  
  Call toggleArrayOfButtons("data_form", objArray(), True)
  'Call toggleSingleButton("data_form", "btndeletedatadf", True)
  
  'Blaetter einblenden
  Call toggleSheetsControlForm(True)
  
  'Spalten wieder einblenden
  Call toggleColumns(ThisWorkbook.Sheets("data_form"), objArrayColumns, False)

  ThisWorkbook.Names("title_c_sprachauswahl").RefersToRange.Cells(1, 1).Value = ""
  Call MsgBox(ThisWorkbook.Names("hlp_const_vec_sprachen_ch").RefersToRange.Count _
    & " Kontrollformulare unter " & strPathAndFilename & "... gespeichert", vbOKOnly)
  
End Sub

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'Sortierung data_form nach beliebiger Spalte
Private Sub Worksheet_Change(ByVal Target As Range)
  Dim objRange As Range
  
  If Target.Address = ThisWorkbook.Names("data_form_c_sortierfeld").RefersToRange.Address Then
    Call sortData_form("")
  ElseIf Target.Address = ThisWorkbook.Names("data_form_c_sortierreihenfolge").RefersToRange.Address Then
    Call sortData_form("")
  End If
End Sub

Attribute VB_Name = "Tabelle13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle15"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle16"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle17"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle18"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle19"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'===================================================================
'VBA-Code zu Ereignissen auf Blatt Uebersetzung
'nur Sprachwahl, dieses Feld ist als einziges ungeschuetzt

'*******************************************************************
'Reagiert auf Sprachwahlfeld und wechselt Uebersetzung
'Ab 2014 Logib 2.4.0 auf Blatt title statt intro
Private Sub Worksheet_Change(ByVal Target As Range)
  If Not ISTEST Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("title.Worksheet_Change")
  
  Application.ScreenUpdating = False
  Call translatecontrols
  Call changevalidationlang 'Modul Validierung
  Dim sprachauswahl As String
  'sprachauswahl = Left(funvarvalue_byname("title_c_sprachauswahl"), 1)
  sprachauswahl = funvarvalue_byname("hlp_const_c_sprache")
'  If sprachauswahl = "" Then
'    sprachauswahl = "D"
'  End If
  Dim laenderversion As String
  laenderversion = funvarvalue_byname("hlp_const_c_laenderversion")
  Call settitleForCountryVersion(sprachauswahl, laenderversion)
  Call sethyperlink(sprachauswahl)

  Application.Calculate
  Application.ScreenUpdating = True
  Exit Sub
fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next
End Sub
Attribute VB_Name = "Tabelle22"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle25"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle27"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle28"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle29"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle30"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle31"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle32"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'Weil SelectionChange nicht auf mehrmaligen Klick hintereinander reagiert
Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)
  Call changeJoblist(Target)
  Cancel = True
End Sub

Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
  Dim lngStartInsertColumn, lngStartInsertRow As Long
  
  'Im Eingabebereich wird Rechtsklick unterdrueckt
  If Target.Cells.Count = 1 Then
    lngStartInsertRow = ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange.Row + 1
    lngStartInsertColumn = ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange.Column + 1
    If Target.Cells.Column >= lngStartInsertColumn And Target.Cells.Column < lngStartInsertColumn + 4 _
      And Target.Cells.Row >= lngStartInsertRow Then
      'Call changeJoblist(Target)
      Cancel = True
    End If
  End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
  Call changeJoblist(Target)
End Sub

Private Sub changeJoblist(ByVal Target As Range)
  'Debug.Print Target.Address
  
  'das bringt keinen Performance-Gewinn
  'Call silentCode
  Dim lngStartInsertColumn, lngStartInsertRow As Long
  Dim strMsgBox As String
  lngStartInsertRow = ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange.Row + 1
  lngStartInsertColumn = ThisWorkbook.Names("joblist_col_anfniveau").RefersToRange.Column + 1
  
  If Target.Cells.Count = 1 And funvarvalue_byname("hlp_const_c_ausgewertet") = False Then
    If Target.Cells.Column >= lngStartInsertColumn And Target.Cells.Column < lngStartInsertColumn + 4 _
      And Target.Cells.Row >= lngStartInsertRow Then
      'Nur reagieren, wenn Beruf existiert
      If Not IsEmpty(Cells(Target.Row, lngStartInsertColumn - 2).Value) Then
        If IsEmpty(Target.Cells.Value) Then
          If IsNumeric(Cells(Target.Row, lngStartInsertColumn - 1)) Then
            strMsgBox = strtranslate("joblist.msgbox.change")
            strMsgBox = Replace(strMsgBox, "|funktion|", Cells(Target.Row, lngStartInsertColumn - 2).Value)
            strMsgBox = Replace(strMsgBox, "|zeile|", Target.Row)
            strMsgBox = Replace(strMsgBox, "|vorher|", Cells(Target.Row, lngStartInsertColumn - 1).Value)
            strMsgBox = Replace(strMsgBox, "|nachher|", Target.Column - lngStartInsertColumn + 1)
            
            'Nachfragen, falls anderswo Wert vorhanden
            If MsgBox(strMsgBox, vbYesNo) = vbYes Then
              Range(Cells(Target.Row, lngStartInsertColumn), Cells(Target.Row, lngStartInsertColumn + 3)).ClearContents
              Target.Cells.Value = STR_JOBLIST_CHAR
            End If
          Else
            Target.Cells.Value = STR_JOBLIST_CHAR
          End If
        Else
          If MsgBox(strtranslate("joblist.msgbox.delete"), vbYesNo) = vbYes Then
            'Zellwert loeschen
            Target.ClearContents
          End If
        End If
      End If
      Cancel = True
    End If
  End If
  'Call restore
End Sub



Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Translations"
Option Private Module
Option Explicit

'===================================================================
'Funktionen und Prozeduren fuer die Uebersetzung



'*******************************************************************
'Sprachspezifisches Titelblatt setzen (neue Version mit Laenderversion)
'  strlanguage: Sprache als einzelner Buchstabe (Grosskleinschreibung ist egal)
'  Application.ScreenUpdating passiert in aufrufenden Methoden
' Hilfe fuer Direktfenster
'   ThisWorkbook.Worksheets("title").Shapes("title_img_cz_c").ZOrder msoBringToFronttitle_img_cz_e
'   Print ThisWorkbook.Worksheets(STR_SH_TITLE).Count
'   Print ThisWorkbook.Worksheets(STR_SH_TITLE).Shapes(1).Name

Sub settitleForCountryVersion(ByVal strlanguage As String, ByVal strcountry As String)
  On Error Resume Next
  
  Call updateActiveProc("Translations.settitleForCountryVersion")
  Dim title
  title = "title_img_" & LCase(strcountry) & "_" & LCase(strlanguage)
  'Debug.Print title
  'Titelbild wechseln
  'Ab Excel 2010 geht dies nur mit entsperrten Blaettern
  ThisWorkbook.Worksheets(STR_SH_TITLE).Unprotect Password:=changeToNumberString("s")
  ThisWorkbook.Worksheets(STR_SH_TITLE).Shapes(title).ZOrder msoBringToFront
  'Ab 07.12.2018 mit Default, falls Kombination nicht gefunden wird
  If err.Number <> 0 Then
    If strcountry = "ch" Then
      title = "title_img_ch_d"
    Else
      title = "title_img_en_e"
    End If
  End If
  ThisWorkbook.Worksheets(STR_SH_TITLE).Shapes(title).ZOrder msoBringToFront
  Call protectSheet(STR_SH_TITLE, True)
  
End Sub


'*******************************************************************
'Hyperlink auf Seite Intro aendern
'  Application.ScreenUpdating passiert in aufrufenden Methoden
Sub sethyperlink(ByVal strlanguage As String)
  Call updateActiveProc("Translations.sethyperlink")
    
  Const intNr As Integer = 5
  
  'Blatt entsperren
  ThisWorkbook.Worksheets(STR_SH_INTRO).Unprotect Password:=changeToNumberString("s")
  
  'Steuerelement fuer Sprachauswahl setzen
  If LCase(strlanguage) = "f" Then
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr - 1).Address = "https://www.ebg.admin.ch/ebg/fr/home.html"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).Address = "https://www.ebg.admin.ch/dam/ebg/fr/dokumente/logib/dienstleistungen/logib_sfs.pdf.download.pdf/Logib_SFS_f.pdf"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).TextToDisplay = "www.logib-etape-par-etape.ch"
  ElseIf LCase(strlanguage) = "i" Then
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr - 1).Address = "https://www.ebg.admin.ch/ebg/it/home.html"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).Address = "https://www.ebg.admin.ch/dam/ebg/it/dokumente/logib/dienstleistungen/logib_sfs.pdf.download.pdf/Logib_SFS_i.pdf"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).TextToDisplay = "www.logib-passo-per-passo.ch"
  'Fuer Tschechisch englischen Hyperlink
  ElseIf LCase(strlanguage) = "e" Or LCase(strlanguage) = "c" Then
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr - 1).Address = "https://www.ebg.admin.ch/ebg/en/home.html"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).Address = "https://www.ebg.admin.ch/dam/ebg/en/dokumente/logib/dienstleistungen/logib_sfs.pdf.download.pdf/Logib_SFS_e.pdf"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).TextToDisplay = "www.logib-step-by-step.ch"
  Else
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr - 1).Address = "https://www.ebg.admin.ch/ebg/de/home.html"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).Address = "https://www.ebg.admin.ch/dam/ebg/de/dokumente/logib/dienstleistungen/logib_sfs.pdf.download.pdf/Logib_SFS_d.pdf"
    ThisWorkbook.Sheets("Intro").Hyperlinks(intNr).TextToDisplay = "www.logib-schritt-fuer-schritt.ch"
  End If
    
  Call protectSheet(STR_SH_INTRO, True)

End Sub


'*******************************************************************
'Nur fuer Entwicklung: Zum Test der Methode sethyperlinks
Sub testHyperlinks()
  Call sethyperlink("i")
End Sub


'*******************************************************************
'V2.5
Sub changeHyperlinksHlpExportForSheet(ByVal strSheet As String, ByVal strUrlOld As String, ByVal strUrlNew As String)
  Dim mylink As Hyperlink
  
  For Each mylink In ThisWorkbook.Sheets(strSheet).Hyperlinks
    If mylink.Parent.Address <> "$R$22" And mylink.Address = strUrlOld Then
       mylink.Address = strUrlNew
    End If
    'Debug.Print mylink.Parent.Address & " " & mylink.Address & "#" & mylink.SubAddress
  Next
  
End Sub



'*******************************************************************
'Nur fuer Entwicklung: Zur Kontrolle, ob Grafiken der Titelblaetter korrekt benannt sind
Sub testTitles()
  Dim myshape
  For Each myshape In ThisWorkbook.Worksheets(STR_SH_TITLE).Shapes
    Debug.Print myshape.name
  Next
End Sub

'*******************************************************************
'Liefert ab dem 02.11.2016 die Laenderversion, damit von Schweiz auf Tschechien umgeschaltet werden kann
Function getLaenderversion()
  On Error Resume Next
  Dim laenderversion As String
  laenderversion = "ch"
  laenderversion = funvarvalue_byname("hlp_const_c_laenderversion")
  getLaenderversion = laenderversion
End Function

'*******************************************************************
'Liefert anhand der installierten Excel-Sprachversion ein
'Einbuchstabenkuerzel fuer die automatische Sprachwahl beim ersten Oeffnen
Function getlanguageasletterfromapplication() As String
  Dim strlanguage As String
  Dim msoLanguageIDUI, _
    msoLanguageIDGerman, msoLanguageIDSwissGerman, msoLanguageIDGermanAustria, msoLanguageIDGermanLiechtenstein, msoLanguageIDGermanLuxembourg, _
    msoLanguageIDFrench, msoLanguageIDFrenchCanadian, msoLanguageIDFrenchLuxembourg, msoLanguageIDFrenchMonaco, _
    msoLanguageIDItalian, msoLanguageIDSwissItalian, _
    msoLanguageIDEnglishAUS, _
    msoLanguageIDEnglishUK, msoLanguageIDEnglishUS, msoLanguageIDEnglishCanadian, _
    msoLanguageIDCzech
  'Auf dem Macintosh gibt es diese Konstanten nicht, deshalb muessen sie explizit definiert werden
  msoLanguageIDUI = 2
  msoLanguageIDGerman = 1031
  msoLanguageIDSwissGerman = 2055
  msoLanguageIDGermanAustria = 3079
  msoLanguageIDGermanLuxembourg = 4103
  msoLanguageIDGermanLiechtenstein = 5127
  msoLanguageIDFrench = 1036
  msoLanguageIDFrenchCanadian = 3084
  msoLanguageIDFrenchLuxembourg = 5132
  msoLanguageIDFrenchMonaco = 6156
  msoLanguageIDItalian = 1040
  msoLanguageIDSwissItalian = 2064
  msoLanguageIDEnglishAUS = 3081
  msoLanguageIDEnglishCanadian = 4105
  msoLanguageIDEnglishUK = 2057
  msoLanguageIDEnglishUS = 1033
  msoLanguageIDCzech = 1029
  
  'Beim 1. Oeffnen ist das Feld auf Blatt hlp_const leer
  If getLaenderversion = "cz" Then
    If Application.OperatingSystem Like "*Mac*" Then
      If funGetLanguageMac = msoLanguageIDCzech Then
        strlanguage = "C"
      Else
        strlanguage = "E"
      End If
    Else
      'Czech 1029
      If Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDCzech Then
        strlanguage = "C"
      Else
        strlanguage = "E"
      End If
    End If
  ElseIf getLaenderversion = "en" Then
    If Application.OperatingSystem Like "*Mac*" Then
        strlanguage = "E"
    Else
      'French 1036
      If Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrench _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrenchCanadian _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrenchLuxembourg _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrenchMonaco _
      Then
        strlanguage = "F"
      'Italian 1040
      ElseIf Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDItalian _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDSwissItalian _
      Then
        strlanguage = "I"
      'German
      ElseIf Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDGerman _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDSwissGerman _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDGermanAustria _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDGermanLiechtenstein _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDGermanLuxembourg _
      Then
        strlanguage = "D"
      Else
        strlanguage = "E"
      End If
    End If
  Else
    If Application.OperatingSystem Like "*Mac*" Then
      If funGetLanguageMac = msoLanguageIDFrench Then
        strlanguage = "F"
      Else
        strlanguage = "D"
      End If
    Else
      'French 1036
      If Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrench _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrenchCanadian _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrenchLuxembourg _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDFrenchMonaco _
      Then
        strlanguage = "F"
      'Italian 1040
      ElseIf Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDItalian _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDSwissItalian _
      Then
        strlanguage = "I"
      ElseIf Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDEnglishAUS _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDEnglishCanadian _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDEnglishUK _
        Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = msoLanguageIDEnglishUS _
      Then
        strlanguage = "E"
      Else
        strlanguage = "D"
      End If
    End If
  End If
  getlanguageasletterfromapplication = strlanguage
End Function


'*******************************************************************
'Hilfsfunktion, welche den Einbuchstaben-Sprachcode (D, F, I, E)
'wieder in einen Volltext zurueckverwandelt
Function getlanguageasstring(Optional ByVal strlanguage As String) As String
  On Error Resume Next
  Dim strResult As String
  If strlanguage <> "" Then
    strResult = WorksheetFunction.VLookup(UCase(strlanguage), ThisWorkbook.Names("hlp_const_lst_sprachen_alle").RefersToRange.Value, 2, 0)
  End If
  If strResult = "" Then
    If ThisWorkbook.Names("hlp_const_c_laenderversion").RefersToRange.Value = "ch" Then
      strResult = WorksheetFunction.VLookup("D", ThisWorkbook.Names("hlp_const_lst_sprachen_alle").RefersToRange.Value, 2, 0)
    Else
      strResult = WorksheetFunction.VLookup("E", ThisWorkbook.Names("hlp_const_lst_sprachen_alle").RefersToRange.Value, 2, 0)
    End If
  End If
  'getlanguageasstring = funvarvalue_byname("hlp_const_c_sprache_lang")
  getlanguageasstring = strResult
End Function


'*******************************************************************
'Automatischer Wechsel auf die Sprache
'  Sprache wird nur beim 1. Mal automatisch aus Excelsprachversion gesetzt
Sub changelanguagefromapplication()
  Dim strlanguage As String
  
  'leere Zelle entspricht 0!
  If funvarvalue_byname("title_c_sprachauswahl") = 0 Then
    strlanguage = getlanguageasletterfromapplication()
    ThisWorkbook.Names("title_c_sprachauswahl").RefersToRange.Value = getlanguageasstring(strlanguage)
    If Not blnIsControlForm() Then
      If MsgBox(strtranslate("msgbox_haftung1") & strtranslate("msgbox_haftung2") & vbCrLf & vbCrLf & strtranslate("msgbox_haftung3"), _
        vbOKCancel) = vbCancel Then
        ThisWorkbook.Close (False)
      End If
    End If
  End If
End Sub


'*******************************************************************
'Trendlinien in Diagrammen koennen nicht mit Bezuegen auf Zellen
'beschriftet werden, deshalb Uebersetzung im VBA-Code
Sub translatecharttrends(ByVal sheetsuffix As String)
  On Error Resume Next
  ThisWorkbook.Worksheets(STR_SH_RPT_REGR & sheetsuffix).Unprotect Password:=changeToNumberString("s")
  With ThisWorkbook.Sheets(STR_SH_RPT_REGR & sheetsuffix).ChartObjects(2).Chart
    .SeriesCollection(1).Trendlines(1).name = strtranslate("dia.trend") & " " & strtranslate("allg.maenner")
    .SeriesCollection(2).Trendlines(1).name = strtranslate("dia.trend") & " " & strtranslate("allg.frauen")
    'nur temporaer: Trendlinien dunkler als Datenpunkte damit bei grosser Anzahl sichtbar
    '.SeriesCollection(1).Trendlines(1).Format.Line.ForeColor.RGB = RGB(51, 102, 204)
    '.SeriesCollection(2).Trendlines(1).Format.Line.ForeColor.RGB = RGB(102, 0, 51)
  End With
  Call protectSheet(STR_SH_RPT_REGR & sheetsuffix, True)
End Sub


'*******************************************************************
'Uebersetzt die Trendlinien in den Diagrammen der Auswertungsblaetter
Sub translatecontrolsoptional()
  'Beschriftung der polynomischen Trendlinie (neu ab 28.08.2013)
  On Error Resume Next
  
  'Diese Trendlinie gibt es erst, wenn Auswertung stattgefunden hat
  translatecharttrends ("2_2")
  translatecharttrends ("2_3")
  translatecharttrends ("2_4")
  translatecharttrends ("2_5")
  translatecharttrends ("2_6")
  translatecharttrends ("2_7")
  
  'Beschriftung der Trendlinie (neu ab 21.10.2010)
  'Achtung ChartObjects(2) -> es gibt noch ein verstecktes 1
  ThisWorkbook.Worksheets(STR_SH_RPT_REGR2_1).Unprotect Password:=changeToNumberString("s")
  Workbooks(ThisWorkbook.name).Sheets(STR_SH_RPT_REGR2_1) _
    .ChartObjects(2).Chart.SeriesCollection(3).Trendlines(1).name = _
    strtranslate("rpt_regr1_2.dialbltrend")
  Call protectSheet(STR_SH_RPT_REGR2_1, True)

  'btnbasisregression neu ab 06.11.2014
  ThisWorkbook.Worksheets(STR_SH_RPT_FAZIT).Unprotect Password:=changeToNumberString("s")
  translatebtnbasisregression
  Call protectSheet(STR_SH_RPT_FAZIT, True)
End Sub

Sub translateButton(ByVal mysheet As String, ByVal btnName As String, ByVal strTextKey As String)
  On Error Resume Next
  'Logib 3.1.1 23.03.2018 Excel 2016 Mac unterstuetzt .Shapes.. nicht mehr
  ThisWorkbook.Sheets(mysheet).Buttons(btnName).Caption = strtranslate(strTextKey)
  'ThisWorkbook.Sheets(mysheet).Shapes(btnName).TextFrame _
  '  .Characters.Text = strtranslate(strTextKey)
End Sub

'*******************************************************************
'Uebersetzt Controls auf den Worksheets mit Ausnahme der Trendlinien
'in Diagrammen
Sub translatecontrols()
  'Damit ein fehlendes Element nicht Uebersetzung aller nachfolgenden blockiert
  If Not ISTEST Then
    On Error Resume Next
  End If
  
  Dim mysheet As String
  mysheet = STR_SH_DATA_HEAD
  Dim strNameColToSort
 
  Dim blnProtectStructure As Boolean 'Logib 3.1.1 fuer Sheet visible
  blnProtectStructure = False
  
  '--------------------------------------------------------------
  'Blatt data_head
  ThisWorkbook.Worksheets(mysheet).Unprotect Password:=changeToNumberString("s")
  
  ThisWorkbook.Sheets(mysheet).Buttons("btnimporttext").Caption = strtranslate("data_head.lblbtnimporttext")
  'ThisWorkbook.Sheets(mysheet).Shapes("btnimporttext").TextFrame _
  '  .Characters.Text = strtranslate("data_head.lblbtnimporttext")
    
  ThisWorkbook.Sheets(mysheet).Buttons("btnimportlse").Caption = strtranslate("data_head.lblbtnimportlse")
  'thisWorkbook.Sheets(mysheet).Shapes("btnimportlse").TextFrame _
  '  .Characters.Text = strtranslate("data_head.lblbtnimportlse")
    
  ThisWorkbook.Sheets(mysheet).Buttons("btndeletedata").Caption = strtranslate("data_head.lblbtndeletedata")
  'ThisWorkbook.Sheets(mysheet).Shapes("btndeletedata").TextFrame _
  '  .Characters.Text = strtranslate("data_head.lblbtndeletedata")

  Call protectSheet(mysheet, True)
  
  '--------------------------------------------------------------
  'Blatt data_form
  mysheet = STR_SH_DATA_FORM
  ThisWorkbook.Worksheets(mysheet).Unprotect Password:=changeToNumberString("s")
  
  ThisWorkbook.Sheets(mysheet).Buttons("btnauswertung").Caption = strtranslate(mysheet & ".lblbtnauswertung")
  'ThisWorkbook.Sheets(mysheet).Shapes("btnauswertung").TextFrame _
  '  .Characters.Text = strtranslate("data_form.lblbtnauswertung")
  
  'Ab 04.02.2016 Schaltflaeche statt Hyperlink
  ThisWorkbook.Sheets(mysheet).Buttons("btndeletedatadf").Caption = strtranslate(mysheet & ".lblbtndeletedatadf")
  'ThisWorkbook.Sheets(mysheet).Shapes("btndeletedatadf").TextFrame _
  '  .Characters.Text = strtranslate("data_form.lblbtndeletedatadf")
  
  ThisWorkbook.Sheets(mysheet).Buttons("btnexportdata").Caption = strtranslate(mysheet & ".lblbtnexportdata")
  'ThisWorkbook.Sheets(mysheet).Shapes("btnexportdata").TextFrame _
  '  .Characters.Text = strtranslate("data_form.lblbtnexportdata")
    
  'Logib 3.1.1 btndata_formsort existiert nicht mehr
'  strNameColToSort = "data_form_col_jobmanual"
'  If ThisWorkbook.Worksheets(mysheet).Sort.SortFields.Count >= 1 Then
'    If ThisWorkbook.Worksheets(mysheet).Sort.SortFields(1).Key.Column = _
'      ThisWorkbook.Names("data_form_col_jobmanual").RefersToRange.Column Then
'      strNameColToSort = "data_form_col_laufnr"
'    End If
'  End If
'  If strNameColToSort = "data_form_col_jobmanual" Then
'    Call translateButton(mysheet, "btndata_formsort", "joblist.lblbtnjoblistsort.job")
'  Else
'    Call translateButton(mysheet, "btndata_formsort", "dataform.lblbtndata_formsort.laufnr")
'  End If
    
  Call protectSheet(STR_SH_DATA_FORM, True)
  
  Call translatecontrolsoptional

  '--------------------------------------------------------------
  'Blatt joblist
  mysheet = STR_SH_JOBLIST
  ThisWorkbook.Worksheets(mysheet).Unprotect Password:=changeToNumberString("s")
  
  'btnjoblist
  ThisWorkbook.Sheets(mysheet).Buttons("btnjoblist").Caption = strtranslate("data_head.lblbtnjoblist")
'  ThisWorkbook.Sheets(mysheet).Shapes("btnjoblist").TextFrame _
'    .Characters.Text = strtranslate("joblist.lblbtnjoblist")
      
  'Buttontext von btnjoblistsort wechseln
  strNameColToSort = "joblist_col_job"
  If ThisWorkbook.Worksheets(mysheet).Sort.SortFields.Count >= 1 Then
    If ThisWorkbook.Worksheets(mysheet).Sort.SortFields(1).Key.Column = _
      ThisWorkbook.Names("joblist_col_job").RefersToRange.Column Then
      strNameColToSort = "joblist_col_anfniveau"
    End If
  End If
  If strNameColToSort = "joblist_col_job" Then
    Call translateButton(mysheet, "btnjoblistsort", "joblist.lblbtnjoblistsort.job")
  Else
    Call translateButton(mysheet, "btnjoblistsort", "joblist.lblbtnjoblistsort.anfniveau")
  End If
  
  'Buttontext von btntogglehelp wechseln %%%%
  If ThisWorkbook.Worksheets(mysheet).Rows( _
    ThisWorkbook.Names("joblist_col_job").RefersToRange.Row - 3 & ":" _
    & ThisWorkbook.Names("joblist_col_job").RefersToRange.Row - 2).EntireRow.Hidden Then
    
    Call translateButton(mysheet, "btntogglehelp", "joblist.hilfe.ein")
  Else
    Call translateButton(mysheet, "btntogglehelp", "joblist.hilfe.aus")
  End If
 
  'Buttons joblistexport und joblistimport
  Call translateButton(mysheet, "btnjoblistexport", "joblist.lblbtnjoblistexport")
  'ThisWorkbook.Sheets(mysheet).Shapes("btnjoblistexport").TextFrame _
  '  .Characters.Text = strtranslate("joblist.lblbtnjoblistexport")
 
  Call translateButton(mysheet, "btnjoblistimport", "joblist.lblbtnjoblistimport")
  'ThisWorkbook.Sheets(mysheet).Shapes("btnjoblistimport").TextFrame _
  '  .Characters.Text = strtranslate("joblist.lblbtnjoblistimport")
 
  Call translateButton(mysheet, "btnjoblistdelete", "joblist.lblbtnjoblistdelete")
  'ThisWorkbook.Sheets(mysheet).Shapes("btnjoblistdelete").TextFrame _
  '  .Characters.Text = strtranslate("joblist.lblbtnjoblistdelete")
  
  Call protectSheet(mysheet, True)
  
  '--------------------------------------------------------------
  'Blatt rpt_regr2_1
  Dim blnsheetvisible As Boolean
  Dim blnbtnvisible As Boolean
  
  mysheet = STR_SH_RPT_REGR & "2_1"
  ThisWorkbook.Worksheets(mysheet).Unprotect Password:=changeToNumberString("s")
  
  blnsheetvisible = ThisWorkbook.Sheets(mysheet).Visible
  'Logib 3.1.1 23.03.2018
  blnProtectStructure = ThisWorkbook.ProtectStructure
  If blnProtectStructure Then
     mappenschutz_aus
  End If
  ThisWorkbook.Sheets(mysheet).Visible = True
  
  'Dieser Button wird nur angezeigt, wenn es ganz hohe Loehne gibt
  blnbtnvisible = ThisWorkbook.Sheets(mysheet).Shapes("btntogglechartaxes").Visible
  ThisWorkbook.Sheets(mysheet).Shapes("btntogglechartaxes").Visible = True
  
  If ThisWorkbook.Sheets(mysheet).ChartObjects("chartlohnprog").Chart.Axes(xlValue).maximumscale _
    = funvarvalue_byname("hlp_const_c_maxsalaryaxes_limited") Then
    Call translateButton(mysheet, "btntogglechartaxes", mysheet & ".btntogglechartaxes.alle")
    'ThisWorkbook.Sheets(mysheet).Shapes("btntogglechartaxes").TextFrame _
    '  .Characters.Text = strtranslate(mysheet & ".btntogglechartaxes.alle")
  Else
'    ThisWorkbook.Sheets(mysheet).Shapes("btntogglechartaxes").TextFrame _
'      .Characters.Text = Replace(strtranslate(mysheet & ".btntogglechartaxes.bis"), _
'      "|hlp_const_c_maxsalaryaxes_limited|", Format( _
'      funvarvalue_byname("hlp_const_c_maxsalaryaxes_limited"), "#,##0"))
    ThisWorkbook.Sheets(mysheet).Buttons("btntogglechartaxes").Caption = _
      Replace(strtranslate(mysheet & ".btntogglechartaxes.bis"), _
      "|hlp_const_c_maxsalaryaxes_limited|", Format( _
      funvarvalue_byname("hlp_const_c_maxsalaryaxes_limited"), "#,##0"))
  End If
  
  'Button und Sheet visible auf urspruenglichen Zustand zuruecksetzen
  ThisWorkbook.Sheets(mysheet).Shapes("btntogglechartaxes").Visible = blnbtnvisible
  ThisWorkbook.Sheets(mysheet).Visible = blnsheetvisible
  If blnProtectStructure Then
     mappenschutz_aus
  End If
  
  Call protectSheet(mysheet, True)
  
End Sub


'*******************************************************************
'Holt die Uebersetzungen fuer Strings aus dem benannten Bereich mit den Uebersetzungen
Function strtranslate(ByVal strsuchstring As String)
  strtranslate = Application.WorksheetFunction.VLookup(strsuchstring, _
    ThisWorkbook.Names(STR_NA_RANTRANSLAT).RefersToRange, _
    ThisWorkbook.Names(STR_NA_CELSPRACHCOL).RefersToRange, 0) 'hlp_translations_c_sprachspalte
End Function

'*******************************************************************
'Holt die Uebersetzungen fuer Strings aus dem benannten Bereich mit den Uebersetzungen
'Sprache uebergeben in Form D, F, E, I
Function strtranslateWithLanguage(ByVal strsuchstring As String, ByVal strlanguage As String)
  On Error Resume Next
  Dim col As Integer
  col = Application.WorksheetFunction.Match(strlanguage, _
    ThisWorkbook.Names("hlp_translations_vec_languages").RefersToRange, 0) + 1
  strtranslateWithLanguage = Application.WorksheetFunction.VLookup(strsuchstring, _
    ThisWorkbook.Names(STR_NA_RANTRANSLAT).RefersToRange, col, 0)
End Function


'*******************************************************************
'Gibt den lokalen Namen einer Excel-Funktion zurueck
'Notwendig, weil bedingte Formatierung anscheinend nur mit lokalen Namen funktioniert
Function strlocalfunction(ByVal strenglishfunction As String, Optional ByVal strarguments As String)
  Dim strfunctionname As String
  With ThisWorkbook.Names("hlp_const_c_translatefunction").RefersToRange
    .Formula = "=" & strenglishfunction & "(" & strarguments & ")"
    strfunctionname = .FormulaLocal
  End With
  strfunctionname = Left(strfunctionname, InStr(strfunctionname, "(") - 1)
  strfunctionname = Right(strfunctionname, Len(strfunctionname) - 1)
  strlocalfunction = strfunctionname
End Function


'*******************************************************************
'Gibt die lokale Fassung einer Excel-Funktion zurueck
'Notwendig, weil bedingte Formatierung anscheinend nur mit lokalen Namen funktioniert
Function strlocalfunctionganz(ByVal strenglishfunction As String)
  Dim strfunctionname As String
  With ThisWorkbook.Names("hlp_const_c_translatefunction").RefersToRange
    If Left(strenglishfunction, 1) = "=" Then
      .Formula = strenglishfunction
    Else
      .Formula = "=" & strenglishfunction
    End If
    strfunctionname = .FormulaLocal
  End With
  strlocalfunctionganz = strfunctionname
End Function


'*******************************************************************
'Uebersetzt den Button Basisregression
'neu ab Oktober 2014
Sub translatebtnbasisregression()
  Dim sign As String
  sign = "-"
  If ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).Columns(STR_RPT_FAZIT_COLADDR).EntireColumn.Hidden Then
    sign = "+"
  End If
  ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).Buttons("btnbasisregression").Caption = _
    sign & " " & strtranslate("rpt_fazit.lblbtnbasisregression")
'  ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).Shapes("btnbasisregression").TextFrame _
'    .Characters.Text = sign & " " & strtranslate("rpt_fazit.lblbtnbasisregression")
End Sub

'*******************************************************************
'Zum Testen der vorhandenen Hyperlinks auf einem Blatt
Sub printAllHyperlinks()
  Dim objLink
  Dim intCounter
  intCounter = 1
  For Each objLink In ActiveSheet.Hyperlinks
    Debug.Print intCounter & " " & objLink.Parent.Address & " " & objLink.Parent.Range("A1").Value & " " & objLink.Address
    intCounter = intCounter + 1
  Next
End Sub


'*******************************************************************
' Auslesen der internationalen Einstellungen
' Quelle: https://docs.microsoft.com/de-DE/office/vba/api/Excel.Application.International
Function funStrInternationalization()
  Dim strSpalte As Variant
  Dim strResult As String
  Dim strDatumsreihenfolge As String
  Dim strJahresformat, strMonatsformat, strTagesformat As String
  Dim strDatumsformat As String
  Dim strDateSeparator As String
  strDateSeparator = Application.International(xlDateSeparator)
  
  If Application.International(xl4DigitYears) Then
    strJahresformat = String$(4, Application.International(xlYearCode))
  Else
    strJahresformat = String$(4, Application.International(xlYearCode))
  End If
  
  If Application.International(xlMonthLeadingZero) Then
    strMonatsformat = String$(2, Application.International(xlMonthCode))
  Else
    strMonatsformat = Application.International(xlMonthCode)
  End If
  
  If Application.International(xlDayLeadingZero) Then
    strTagesformat = String$(2, Application.International(xlDayCode))
  Else
    strTagesformat = Application.International(xlDayCode)
  End If
  
  '0 = Monat-Tag-Jahr
  If Application.International(xlDateOrder) = 0 Then
    strDatumsformat = strMonatsformat & strDateSeparator _
      & strTagesformat & strDateSeparator _
      & strJahresformat
  '1 = Tag-Monat-Jahr
  ElseIf Application.International(xlDateOrder) = 1 Then
    strDatumsformat = strTagesformat & strDateSeparator _
      & strMonatsformat & strDateSeparator _
      & strJahresformat
  '2 = Jahr-Monat-Tag
  Else
    strDatumsformat = strJahresformat & strDateSeparator _
      & strMonatsformat & strDateSeparator _
      & strTagesformat & strDateSeparator
  End If
  strResult = "Date Format: " & strDatumsformat & vbNewLine
  For Each strSpalte In Array(Array("xlCountryCode", xlCountryCode, 1), Array("xlCountrySetting", xlCountrySetting, 2), Array("xlDecimalSeparator", xlDecimalSeparator, 3), _
    Array("xlThousandsSeparator", xlThousandsSeparator, 4), Array("xlListSeparator", xlListSeparator, 5), Array("xlUpperCaseRowLetter", xlUpperCaseRowLetter, 6), Array("xlUpperCaseColumnLetter", xlUpperCaseColumnLetter, 7), Array("xlLowerCaseRowLetter", xlLowerCaseRowLetter, 8), Array("xlLowerCaseColumnLetter", xlLowerCaseColumnLetter, 9), Array("xlLeftBracket", xlLeftBracket, 10), Array("xlRightBracket", xlRightBracket, 11), Array("xlLeftBrace", xlLeftBrace, 12), Array("xlRightBrace", xlRightBrace, 13), Array("xlColumnSeparator", xlColumnSeparator, 14), Array("xlRowSeparator", xlRowSeparator, 15), Array("xlAlternateArraySeparator", xlAlternateArraySeparator, 16), Array("xlDateSeparator", xlDateSeparator, 17), Array("xlTimeSeparator", xlTimeSeparator, 18), Array("xlYearCode", xlYearCode, 19), Array("xlMonthCode", xlMonthCode, 20), Array("xlDayCode", xlDayCode, 21), _
    Array("xlHourCode", xlHourCode, 22), Array("xlMinuteCode", xlMinuteCode, 23), Array("xlSecondCode", xlSecondCode, 24), Array("xlCurrencyCode", xlCurrencyCode, 25), _
    Array("xlGeneralFormatName", xlGeneralFormatName, 26), Array("xlCurrencyDigits", xlCurrencyDigits, 27), _
    Array("xlCurrencyNegative", xlCurrencyNegative, 28), Array("xlNoncurrencyDigits", xlNoncurrencyDigits, 29), _
    Array("xlMonthNameChars", xlMonthNameChars, 30), Array("xlWeekdayNameChars", xlWeekdayNameChars, 31), _
    Array("xlDateOrder", xlDateOrder, 32), Array("xl24HourClock", xl24HourClock, 33), Array("xlNonEnglishFunctions", xlNonEnglishFunctions, 34), _
    Array("xlMetric", xlMetric, 35), Array("xlCurrencySpaceBefore", xlCurrencySpaceBefore, 36), Array("xlCurrencyBefore", xlCurrencyBefore, 37), _
    Array("xlCurrencyMinusSign", xlCurrencyMinusSign, 38), Array("xlCurrencyTrailingZeros", xlCurrencyTrailingZeros, 39), _
    Array("xlCurrencyLeadingZeros", xlCurrencyLeadingZeros, 40), Array("xlMonthLeadingZero", xlMonthLeadingZero, 41), _
    Array("xlDayLeadingZero", xlDayLeadingZero, 42), Array("xl4DigitYears", xl4DigitYears, 43), Array("xlMDY", xlMDY, 44), _
    Array("xlTimeLeadingZero", xlTimeLeadingZero, 45))
        
    strResult = strResult & strSpalte(0) & ": " & Application.International(strSpalte(1)) & vbNewLine
  Next
  
  funStrInternationalization = strResult
End Function

Private Function showApplicationInternational(name As XlApplicationInternational)
  showApplicationInternational = Application.International(name)
End Function

Public Function getDecimalSeparator()
  getDecimalSeparator = Application.International(3)
End Function
  

Attribute VB_Name = "UpdateManagement"
Option Explicit
Option Private Module

'===================================================================
'Routinen mit Workarounds, die durch verschiedene Excel-Versionen entstanden
'in Logib 2.4 Nov. 2013 nicht noetig, Versionen vor 2007 nicht unterstuetzt
'Problem: Eine Mappe, die unter Excel 2003 ausgewertet wurde,
'liefert u.U. einen Kollinearitaetsfehler zurueck, wenn sie in einer
'Vorversion geoeffnet wird
' -> wenn ThisWorkbook.CalculationVersion >= 11 und Application.CalculationVersion < 11
'     dann wird Neuberechnung und Bearbeitung unterbunden



'*******************************************************************
'Berechnungen auf allen Blaettern werden enabled
Sub enable_all_calculations()
  Dim objSheet As Worksheet

  For Each objSheet In ThisWorkbook.Worksheets
     objSheet.EnableCalculation = True
     objSheet.Calculate
  Next

End Sub


'*******************************************************************
'Berechnungen auf allen Blaettern werden disabled
Sub disable_all_calculations()
  Dim objSheet As Worksheet

  For Each objSheet In ThisWorkbook.Worksheets
     objSheet.EnableCalculation = False
  Next

End Sub


'*******************************************************************
'Mit welcher Version wurde Blatt berechnet
Function intWBCalculationVersion() As Integer
  Dim strversion
  
  strversion = "" & ThisWorkbook.CalculationVersion
  intWBCalculationVersion = Left(strversion, Len(strversion) - 4)

End Function


'*******************************************************************
'Berechnungsversion des vorliegenden Excels
Function intAppCalculationVersion() As Integer
  Dim strversion
  
  strversion = "" & Application.CalculationVersion
  intAppCalculationVersion = Left(strversion, Len(strversion) - 4)

End Function

Attribute VB_Name = "Wartung"
Option Explicit
Option Private Module

'*******************************************************************
'Modul enthaelt Makros zur Anpassung und Vereinheitlichung der Darstellung
'z.B. Hoehe von Buttons aendern oder Schriften anpassen
'Dieser Code wird nicht innerhalb der Logib-Applikation aufgerufen

'*******************************************************************
'setzt alle Buttons in Blatt data_head auf eine bestimmte Hoehe
Sub btnAnpassen()
  Dim hoehe As Integer
  hoehe = 19
  'Logib 3.1.1 das funktioniert auch unter Excel 2016 Mac
  ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btnimporttext").Height = hoehe
  ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btnimportlse").Height = hoehe
  'ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes("btninputtable").Height = hoehe
End Sub

Sub btnTesten()
  Dim counter As Integer
  Debug.Print ThisWorkbook.name
  For counter = 1 To ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes.Count
    Debug.Print "Button-Name: " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).name
    Debug.Print "Label:       " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).TextFrame.Characters.Text
    Debug.Print "Visible:     " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Visible
    Debug.Print "Left:        " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Left
    Debug.Print "Top:         " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Top
    Debug.Print "Width:       " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Width
    Debug.Print "Height:      " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Height
  Next
  Debug.Print
End Sub

Sub btnCodeErstellen()
  Dim counter As Integer
  Debug.Print ThisWorkbook.name
  For counter = 1 To ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes.Count
    Debug.Print "ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(""" & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).name _
      & """).Left = " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Left
      
    Debug.Print "ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(""" & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).name _
      & """).Top = " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Top
      
    Debug.Print "ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(""" & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).name _
      & """).Width = " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Width
      
    Debug.Print "ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(""" & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).name _
      & """).Height = " & ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes(counter).Height
  Next
  Debug.Print
End Sub

Sub btnDataFormReplace()
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnauswertung").Left = 10.8
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnauswertung").Top = 99
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnauswertung").Width = 118.8
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnauswertung").Height = 21
  
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnexportdata").Left = 303.6
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnexportdata").Top = 98.4
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnexportdata").Width = 159.6
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btnexportdata").Height = 21
    
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btndeletedatadf").Left = 159.6
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btndeletedatadf").Top = 99
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btndeletedatadf").Width = 117.6
  ThisWorkbook.Sheets(STR_SH_DATA_FORM).Shapes("btndeletedatadf").Height = 21
End Sub

'*******************************************************************
'aendert die Beschriftungen innerhalb der Diagramme
'Erstellt:         04.02.2016
'Letzte Aenderung: 04.02.2016
Sub changeChartLabels()
  On Error Resume Next
  Dim mysheet As Worksheet
  Const intFontsize As Integer = 7
  For Each mysheet In ThisWorkbook.Sheets
    mysheet.Activate
    If ActiveSheet.ChartObjects > 1 Then
      ActiveSheet.ChartObjects("Chart 1").Activate
      ActiveChart.ChartArea.Select
      ActiveChart.SeriesCollection(1).DataLabels.Select
      Selection.Format.TextFrame2.TextRange.Font.Size = intFontsize
      ActiveChart.SeriesCollection(2).DataLabels.Select
      Selection.Format.TextFrame2.TextRange.Font.Size = intFontsize
    End If
  Next
End Sub

'*******************************************************************
'erstellt Backup-Datei mit Datum und Uhrzeit und evtl. Zusatz
'Erstellt:         04.02.2016
'Letzte Aenderung: 04.02.2016
Sub saveBackup()
  Dim strPathAndFilename As String
  Dim strDate As String
  strDate = Format(Now, "yyyyMMdd_hhmm")
  Dim strZusatz As String
  strZusatz = InputBox("Zusatz zum Dateinamen")
  If strZusatz <> "" Then
    strZusatz = "_" & strZusatz
  End If
  strPathAndFilename = "D:\dateienmitback\dateien\auftraege\logib_ch_2010\" _
    & Replace(ThisWorkbook.name, ".xlsm", "_" & strDate & strZusatz & ".xlsm")
    
  'Das funktioniert, aber dann muss man das Workbook aufmachen
  ThisWorkbook.SaveCopyAs strPathAndFilename

End Sub

Sub testFormatconditions()
  Dim strFormula, strFormula2 As String
  strFormula = "=ISEVEN(CELL(""Row""," & Selection.Address(False, True) & "))"
  strFormula2 = "=ISTGERADE(ZELLE(""Row"";" & Selection.Address(False, True) & "))"
  strFormula2 = "=ISEVEN(CELL(""Row"";" & Selection.Address(False, True) & "))"
   Selection.FormatConditions.Add Type:=xlExpression, _
                Formula1:=strFormula2
  Selection.FormatConditions(Selection.FormatConditions.Count).Interior.ColorIndex = 15
End Sub

'*******************************************************************
'gibt alle im Arbeitsblatt vorhandenen Namen aus
'Erstellt:         16.09.2016
'Version:          3.0.1
Sub showAllNames()
  Dim myName As name
  Dim strResult As String
  On Error Resume Next
  strResult = ""
  For Each myName In ThisWorkbook.Names
    'Debug.Print
    strResult = strResult & myName.name & " " & myName
    
    strResult = strResult & " Wert: " & ThisWorkbook.Names(myName.name).RefersToRange.Range("A1").Value
    strResult = strResult & vbCrLf
  Next
  Call procWriteTextfile("D:\dateienmitback\dateien\auftraege\logib_ch_2010\Logib3.0_Variablen.txt", strResult)
End Sub

'*******************************************************************
'Schreibt Textdatei mit uebergebenen Text und Dateipfad (Unicode und Ueberschreiben)
Sub procWriteTextfile(ByVal strFilenameAndPath As String, ByVal strContent As String)
  Dim objtextfile
  Dim objfs

  'FileSystemObject erzeugen
  Set objfs = CreateObject("Scripting.FileSystemObject")
  
  'Textdatei-Objekt erzeugen mit Ueberschreiben und mit Unicode
  Set objtextfile = _
    objfs.CreateTextFile(strFilenameAndPath, True, True)
  objtextfile.write (strContent)
  objtextfile.Close
End Sub

'*******************************************************************
'Liest Anzahl Lines of Code
'Achtung: fuer diesen Code muss im Sicherheitscenter Haekchen
'Einstellungen fuer Makros - Zugriff auf das VBA-Projektmodell vertrauen gesetzt sein
Sub showModuleNames()
  Dim myModule 'As vbcomponent
  Const TRENNZEICHEN As String = vbTab '";"
  Dim strText As String
  strText = "Modulname" & vbTab & "Typ" & vbTab & "Anzahl Lines of Code" & vbCrLf
  For Each myModule In ActiveWorkbook.VBProject.VBComponents
    'Type 100 Tabelle, 1 VBA Modul, 3 Formular
    'If myModule.Type = 1 Then
    If myModule.CodeModule.CountOfLines > 0 Then
      strText = strText & myModule.name & TRENNZEICHEN & myModule.Type _
        & TRENNZEICHEN & myModule.CodeModule.CountOfLines & vbCrLf
    End If
  Next
  Call procWriteTextfile("D:\dateienmitback\dateien\auftraege\logib_ch_2010\__LinesOfCode.csv", strText)
End Sub
Attribute VB_Name = "a_Test"
Option Explicit
Option Private Module

'===================================================================
'Modul fuer Tests

'*******************************************************************
'Zuruecksetzen auf jungfraeulichen Zustand
Sub setback()
  Call set_userview
End Sub

'*******************************************************************
'Zuruecksetzen: title_c_sprachauswahl loeschen
'  zum Testen der automatischen Spracheinstellung
'  Vorgehen:
'  - Sprache wechseln (in andere Sprache als Excel)
'  - ueberpruefen, ob Sprache in Oberflaeche gewechselt ist (title, validation)
'  - setbacksprache
'  - DieseArbeitsmappe.Workbook_Open
'  -> Sprache muss wieder jener der Excel-Version entsprechen
Sub setbacksprache()
  ThisWorkbook.Names("title_c_sprachauswahl").RefersToRange.ClearContents
End Sub


Attribute VB_Name = "a_programmierkonventionen"
Option Explicit

'===================================================================
'Dieses Modul enthaelt als Kommentare die Programmier- und Namenskonventionen

'*******************************************************************
'Namenskonventionen

'--------------------------------------------------------------
'Namen (Excel-Namen, d.h. was unter Einfuegen - Namen erscheint

'Blattname voranstellen, dann _ und Bezeichnung, z.B. hlp_data_regr1_sd

' - data_form_col_.. fuer die Spalten im Blatt data_form
'      keine _ in Spaltenbezeichnung, definiert auf Zeile mit den Bezeichnungen
' - hlp_const_vec_geschlecht...
'     + fuer einspaltige Listen fuer die Gueltigkeitspruefung auf Blatt help_const
'     + fuer Datenspalten in hlp_data_regr1 und 2
' - hlp_const_lst_.. fuer mehrspaltige Listen fuer SVERWEIS
' - hlp_const_c_.. fuer Einzelzellen
' - ..._ran_.. fuer einen Zellbereich (range) z.B. rpt_fazit_ran_basis

'Achtung: auf rpt_regr1_1 und rpt_regr1_2 sind benannte Zellen unter dem Diagramm versteckt

'--------------------------------------------------------------
'Steuerelemente

'--------------------------------------------------------------
'VBA-Konstanten, Variablen etc.
'generell
' - Konstanten in Grossschrift
' - alles andere in Kleinschrift, ev. mit _ zur Unterteilung


'*******************************************************************
'Programmierkonventionen

'--------------------------------------------------------------
'Aufteilung des Codes

'Normalerweise steckt der Code in Modulen, nicht hinter Blaettern.
'Ausnahmen siehe Dokumentation in Word

'--------------------------------------------------------------
'Adressierung in Blaettern

'ThisWorkbook.Name gibt Dateinamen der aktuellen Datei zurueck, in der Makro laeuft
' -> resistent gegen Umbenennung

'Um resistent gegen eingefuegte Zeilen etc. zu sein,
'wird die Adressierung v.a. via benannte Zellen und Zellbereiche vorgenommen
'Eine Ausnahme aus Performance-Gruenden sind die Konstanten
' - STR_DATA_FORM_SD mit dem Beginn des Datenbereichs
' - STR_TRANSLATIONS_SD mit dem Beginn der Uebersetzungstexte
'siehe Modul ConstVarPublic, Abschnitt Datenbereiche

'--------------------------------------------------------------
'globale Variablen
'keine globalen Variablen, sondern in Blatt hlp_const in Zellen abgelegt
'Zugriff ueber Namen

'--------------------------------------------------------------
'Speicherung von urspruenglichen Einstellungen
'Die urspruenglichen Einstellungen, z.B. fuer Berechnungsmodus, werden in Zellen auf hlp_const
'im Absatz "Anfangseinstellungen gespeichert
'Gespeichert werden sie beim Oeffnen in der Prozedur DieseArbeitsmappe.Workbook_Open
'und wieder zurueckgesetzt im Gegenstueck DieseArbeitsmappe.Workbook_BeforeClose

'--------------------------------------------------------------
'Uebersetzung
'Was wurde fuer neue Sprach- und Laenderversion am 02.11.2016 angepasst?
' + Eingabefeld fuer Laenderversion auf Blatt hlp_const
' + diverse Formeln auf Blatt hlp_const (siehe Word-Dokumentation)
' + auf Blatt hlp_translations
'   * neue Spalte im Blatt hlp_translations (vor Spalte MaxLaenge)
'   * Formel in D3 entsprechend anpassen
'   * Name hlp_translations_lst_trans um die neue Spalte vergroessern
' + Titelbild title_img_.. in der entsprechenden Sprache einbinden
'   Wechsel passiert in Routine Translation.settitle automatisch,
'   vorausgesetzt es gibt ein Blatt mit dem entsprechenden Namen, z.B. title_img_e
' + in Blatt hlp_const im Block "Sprache" die neue Sprache anhaengen
'   Namen "hlp_const_vec_sprachen" dazu erweitern
' + Sprache im if von Translations.changelanguage hinzufuegen
' + Sprache im if von Translations.settitle hinzufuegen
' + intro: cbosprachauswahl_Change?
' + manuelle "bedingte Formatierung"?

' Was gehoert sonst noch zur Mehrsprachigkeit
' + Laenderversion CH -> wegen Import und Dezimalkomma!
'   -> Tschechien hat gleiches Zahlenformat wie wir!
' + Ganzes Modul Translations
' + Validierung.changevalidationlang und change_all_validations

' Labels fuer Diagramme in rpt_regr2_6 und rpt_regr2_7
' Achtung, die Labels stecken in den Zellen, die vom Diagramm verdeckt werden

'--------------------------------------------------------------
'Verweise
'Ich verzichte auf Verweise auf andere Mikrosoft-Applikationen, um Probleme zu vermeiden
'Dies gilt insbesondere auch fuer die Unterstuetzung von 64Bit-Versionen!
'Ausnahme: Outlook fuer Testversion
'Der urspruenglich fuer Uebersetzungen verwendete Dictionary verlangt Verweis auf "Microsoft Scripting Runtime"
'  -> 28.6.05 ersetzt


'*******************************************************************
'Technische Stolpersteine

'--------------------------------------------------------------
'Lokalisierung von Formeln
'Excel-Funktionen werden auf Tabellenblaettern automatisch uebersetzt (falls nicht aus AddIn Analysefunktionen)
'Bei der Zuweisung von Formeln zu Zellen in VBA wird die englische Version der Funktion verwendet
'Fuer die Gueltigkeitspruefung gilt dasselbe
'Bei der bedingten Formatierung funktioniert das nicht (vermutlich Bug)
'  -> Funktionen mit strlocalfunction im Modul translation lokalisieren
'  -> Recherchen in Google (aber nicht auf Microsoft-Site) haben zum gleichen Ergebnis gefuehrt

'--------------------------------------------------------------
'Bedingte Formatierung
'  Select ist noetig, damit die Zellbezuege in Bedingter Formatierung stimmen

'--------------------------------------------------------------
'Eigene Funktion alledatengueltig
'Diese Funktion enthaelt eine Schleife ueber den uebergebenen Bereich
'In Excel XP und 2000 fuehrt dies bei mehrfacher Verwendung in Spalte filter zu einem Absturz!

'--------------------------------------------------------------
'Die Laenge der Texte fuer Gueltigkeitspruefungen sind begrenzt und zwar
'Inputtexte: 255 Zeichen
'Fehlertexte: 220 Zeichen

'--------------------------------------------------------------
'Excel-Versionen
'Tool laeuft nicht auf Excel97, wenn nichtmodale Fenster angezeigt werden d.h. frm.show(vbModeless)
'Standard fuer die Anzeige von Formularen ist vbmodal

'--------------------------------------------------------------
'Gueltigkeitspruefung
'Mit VBA lassen sich auch falsche Werte in mit Gueltigkeitspruefung geschuetzte Zellen schreiben
'Einblenden von Fehlern via Detektiv laesst sich nicht aufzeichnen -> fuer VBA zugaenglich?

'--------------------------------------------------------------
'Verweise
'Probleme mit Verweisen kann es u.a. geben, wenn Office XP und Outlook 2000 installiert ist
'Dynamisches Laden von Verweisen geht unter XP und 2003 nur mit Einstellung
'Extras - Makro - Sicherheit - Register Vertrauenswuerdige Quellen - Zugriff auf Visual Basic Projekt vertrauen
'Notwendig sind folgende Verweise fuer Microsoft Excel 9.0 (fuer andere Excel-Versionen automatisch angepasst)
' - Visual Basic For Applications
' -  Microsoft Excel 9.0 Object Library
' -  Microsoft Forms 2.0 Object Library
' -  Microsoft Office 9.0 Object Library
'Es ist kein Verweis auf Microsoft Outlook oder auf OLE notwendig!

'--------------------------------------------------------------
'Fehlermeldung "Name Conflict ... Print_Area" in internationaler Version
'Dieses Problem habe ich kurz gegoogelt, das hat nichts mit Firewall, Sicherheitseinstellungen oder Macros
'zu tun, sondern schlicht damit, dass eine in einer nichtenglischen Excel-Version erstellte Datei in einer
'englischen Version von Excel geoeffnet wird. So wie es aussieht, ist das eher ein Bug von Microsoft.
'Ohne englische Excel-Version kann ich da vermutlich nicht viel machen.
'Quelle: http://www.herber.de/forum/archiv/468to472/470564_Namenskonflikt_bei_englischer_Version.html
'Print_area ist der Druckbereich, da wir ja Druckbereiche voreinstellen, laesst sich diese Meldung beim
'Start kaum vermeiden. Der User kann hoechstens den im Artikel angegebenen Workaround versuchen,
'd.h. etwas beliebiges in das Namensfeld eintippen. Nach meiner Erfahrung mit anderen solchen Meldungen
'muss man nicht einmal tippen, sondern kann die Meldung schlicht wegklicken.

'*******************************************************************
'Applikatorische Hinweise

'--------------------------------------------------------------
'Speichern
'Sowohl nach dem Import wie nach der Auswertung erfolgt ein automatisches Speichern

'--------------------------------------------------------------
'Kein Fenster fixieren
'keine Fixierung auf data_form, weil mit 800x600 Daten nicht mehr sichtbar sind

'--------------------------------------------------------------
'Verborgene Zeilen
'die verborgenen Zeilen auf data_form sind notwendig, damit es beim Sortieren die Beispielzeile nicht mitsortiert
'generell soll auf data_form aber nicht sortiert werden,
'Sortierung erfolgt auf den versteckten Blaettern hlp_data_regr1 und hlp_data_regr1


'*******************************************************************
'Tagebuch der Korrekturen nach Publikation der Version 1

'Achtung, wird nicht mehr nachgefuehrt, externes Dokument

'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'Version:    2.3.0

'Wann:      25.07.2013
'Was        Diverse Aenderungen
'Wo:
'Ausloeser   Offerte vom Juli 2013, Anfrage EBG

'Done 25.07.2013
' - Vorlagendatei erstellt
' - Import der Vorlagendatei erstellt und oberflaechlich getestet
'   inkl. Verschiebung Spalten auf hlp_lse


'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'Version:    1.1.0

'Wann:       06.12.2006
'Was         Datenbereich erweitern
'Wo:         Tabelle12.btndatenbereicherweitern_Click(), DatenAusMappe.funlnglastfilledrow
'Ausloeser   Muendliches Feedback von Ornella
'Erklaerung


'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'Version:    1.0.2

'Wann:       12.09.2006
'Was         Altersberechnung geht nicht mehr auf aktuelles Datum sondern auf eingegebenes Jahr
'Wo:         Modul Auswertung, Prozedur spalten_regr_fuellen
'Ausloeser   Mail von Silvia Strub
'Erklaerung  Ermoeglicht auch Auswertung aelterer Daten


'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'Version:    1.0.1

'Wann:       23.08.2006
'Was         Versionsnummer angepasst
'Wo:         Grafiken title_img_d, title_img_f, title_img_i auf Blatt title, hlp_const (B35)
'Ausloeser   Publikation der neuen Version
'Erklaerung  Texte in Photoshop aus jpg-Originalen von Frau Spettig entfernt

'--------------------------------------------------------------
'Wann:       23.08.2006
'Was         Diagramm mit Anteilen an Diskriminierung nicht mehr angezeigt
'Wo:         Blatt rpt_regr1_1, rpt_regr2_1
'Ausloeser   Publikation der neuen Version
'Erklaerung  Fuer Diagramm quick and dirty geloest
'              d.h. Zeilen mit Diagramm und Werten dahinter ausgeblendet

'--------------------------------------------------------------
'Wann:       08.07.2006
'Version:    1.0.1
'Was         Vorzeichenfehler in Formel korrigiert
'Wo:         auf Blatt rpt_regr1_1 C22 und C23 und rpt_regr2_1 C33 und C34
'Ausloeser   Supportmail von Frau Mojon am 08.07.2006
'Erklaerung

'--------------------------------------------------------------
'Wann:       28.06.2006
'Version:    1.0.1
'Was         Weitere Sprachcodes fuer Swissgerman etc. ersetzt
'Wo:         Errormanagement.funstrlanguageidtotext
'Ausloeser   Supportmail von melchior.bendel@fin.be.ch am 13.6.2006
'Erklaerung

Attribute VB_Name = "a_progtemp"
'Ueberarbeitung des Codes und der Kommentare im Nov 2014
'To Do
' - Modulheader einfuegen
' - Prozedurheader einfuegen oder kontrollieren und anpassen
' - %%% und &&& ersetzen/loeschen
' - Umlaute ersetzen wegen Mac

'Ueberarbeitung Kommentare im Code
'Blaetter/Module erledigt
' - DieseArbeitsmappe
' - 2 title: Code Sprachwechsel
' - 12 data_form
' - 17 data_head

'Module erledigt
' - Auswertung
' - ByName
' - ConstVarPublic
' - DatenAusMappe
' - Entwicklung
' - Errormanagement
' - Excelfunktionen
' - Hauptmodul
' - Hilfsmakros
' - ImportExport
' - Mac
' - sheet_data_form
' - sheet_data_head
' - Translations
' - UpdateManagement
' - Validierung
' - Verweismanagement
' - zzz_snippets


'Blaetter ohne Code
' - 1 intro
' - 10 hlp_export_d
' - 11 rpt_regr1_1
' - 13 rpt_fazit
' - 14 hlp_export_f
' - 15 rpt_regr2_2
' - 16 rpt_regr2_1
' - 18 hlp_export_i
' - 19 hlp_lse
' - 20 rpt_regr1_2
' - 21 rpt_regr1_3
' - 22 rpt_regr2_3
' - 23 hlp_export_e
' - 24 rpt_regr1_4
' - 25 rpt_regr2_4
' - 26 rpt_regr1_5
' - 27 rpt_regr2_5
' - 28 rpt_regr2_6
' - 29 rpt_regr2_7
' - 3 hlp_const
' - 4 hlp_translations
' - 5 hlp_data_regr1
' - 6 hlp_regr1
' - 7 hlp_data_regr2
' - 8 hlp_regr2
' - 9 license
Attribute VB_Name = "excelfunktionen"
Option Explicit

'===================================================================
'Blatt enthaelt Funktionen, die wie Excel-Funktionen verwendet werden koennen


'*******************************************************************
'enthaelt ein Zellwert vom Typ String einen Zeilenumbruch
'verwendet auf Blatt hlp_translations in Spalte K
'dient zur Ueberpruefung, ob bei Uebersetzung die Zeilenumbrueche
'erhalten geblieben sind
Function funblnumbruch(ByVal objRange As Range)
  On Error Resume Next
  If InStr(objRange.Value, funStrNewline) > 0 Then
    funblnumbruch = True
  Else
    funblnumbruch = False
  End If
End Function


'*******************************************************************
'Ist die Basisregression gueltig
' -> steuert Einblenden der Berichtsblaetter und der Links -> ab Version 3.0.3 unnoetig?
'Verwendet in Blatt rpt_fazit (auch ab Version 3.0.3

Function funblnregr1gueltig()
  On Error Resume Next
  
  Call updateActiveProc("Excelfunktionen.funblnregr1gueltig")
  funblnregr1gueltig = False
  
  If Not Application.WorksheetFunction.IsError(ThisWorkbook.Names("koeff1_frau_d").RefersToRange) Then
    'Ab 23.03.2016 V3 werden beide Regressionen auf derselben Datenbasis berechnet
    If funvarvalue_byname("data_form_c_anzerw") >= funvarvalue_byname("hlp_const_c_minanzbasis") Then
      funblnregr1gueltig = True
    End If
  End If

End Function


'*******************************************************************
'Ist die erweiterte Regression gueltig
' -> steuert Einblenden der Berichtsblaetter und der Links
'Verwendet in Blatt rpt_fazit und im Modul Auswertung
Function funblnregr2gueltig()
  On Error Resume Next
  
  Call updateActiveProc("Excelfunktionen.funblnregr2gueltig")
  
  funblnregr2gueltig = False
  
  If Not IsError(ThisWorkbook.Names("koeff2_frau_d").RefersToRange) Then
    If funvarvalue_byname("data_form_c_anzerw") >= funvarvalue_byname("hlp_const_c_minanzerw") Then
      If IsNumeric(funvarvalue_byname("hlp_regr2_c_r2")) Then
        If funvarvalue_byname("hlp_regr2_c_r2") >= 0 And funvarvalue_byname("hlp_regr2_c_r2") <= 1 Then
          funblnregr2gueltig = True
        End If
      End If
    End If
  End If
End Function


'*******************************************************************
'liegt bei der erweiterten Regression ein Problem mit kollinearen Spalten vor
' -> steuert Einblenden der Berichtsblaetter und der Links
'Verwendet in Blatt rpt_fazit und im Modul Auswertung
Function funblnregr2kollproblem()
  On Error Resume Next
  
  Call updateActiveProc("Excelfunktionen.funblnregr2kollproblem")
  
  funblnregr2kollproblem = True
  
  If IsNumeric(funvarvalue_byname("hlp_regr2_c_r2")) Then
    If funvarvalue_byname("hlp_regr2_c_r2") >= 0 And funvarvalue_byname("hlp_regr2_c_r2") <= 1 Then
      funblnregr2kollproblem = False
    End If
  End If
End Function


'*******************************************************************
'Vor Version 2.4 verwendet in der bedingten Formatierung auf data_form
'gesetzt in Hauptmodul.init_data_form, wenn BLN_FORMATCONDITIONS_FORMULA = false ist
Function datengueltig(ByVal objRange As Range)
  On Error Resume Next
  
  'call updateActiveProc("Excelfunktionen.datengueltig")
  datengueltig = objRange.Range("A1").Validation.Value
  
End Function


'*******************************************************************
'Zeigt die lokale Version einer Formel mit lokalen Funktionsnamen
'nur fuer Testzwecke, nirgendwo verwendet
Function zeigformellocal(ByVal objRange As Range) As String
  On Error Resume Next
  'call updateActiveProc("Excelfunktionen.zeigformellocal")
  zeigformellocal = objRange.Range("A1").FormulaLocal
End Function


'*******************************************************************
'Zeigt die internationale Version einer Formel mit englischen Funktionsnamen
'Verwendet in Blatt hlp_data_regr1 in versteckter Zelle N7
Function zeigformel(ByVal objRange As Range) As String
  On Error Resume Next
  'call updateActiveProc("Excelfunktionen.zeigformel")
  zeigformel = objRange.Range("A1").Formula
End Function


'*******************************************************************
'ueberprueft fuer die uebergebenen Zellen, ob die Gueltigkeitspruefung
'ueberall erfuellt ist
'Eingabe einzelner Zellen
'Wird im data_form in den 2 Filterspalten verwendet
'SR: neue Fassung am 03.10.2013, da die Variante mit
'Gueltigkeitspruefung immer wieder zu Fehlern gefuehrt hat
'SR 12.07.2019 angepasst fuer neue Gueltigkeitspruefungen
Function allezellengueltig(ParamArray varrange() As Variant)
  On Error Resume Next
  
  Call updateActiveProc("Excelfunktionen.allezellengueltig")
  
  Dim lngCounter As Long
  Dim objCell As Range
  Dim activecol As String
  
  For lngCounter = 0 To UBound(varrange())
    For Each objCell In varrange(lngCounter).Cells
    activecol = funstrcol(objCell.Column)
      'Spalte Alter
      If activecol = funstrcol_byname("data_form_col_gebjahr") Then
        'zu jung
        'Ab 3.0.7 ohne -1
        If objCell.Value < funvarvalue_byname("data_head_c_jahr") - funvarvalue_byname("hlp_const_c_altermax") Then
          allezellengueltig = False
          Exit Function
        End If
        'zu alt
        'Ab 3.0.7 ohne +1
        If objCell.Value > funvarvalue_byname("data_head_c_jahr") - funvarvalue_byname("hlp_const_c_altermin") Then
          allezellengueltig = False
          Exit Function
        End If
      End If
      
      'Spalte Geschlecht
      If activecol = funstrcol_byname("data_form_col_geschlecht") Then
        If objCell.Value <> 1 And objCell.Value <> 2 Then
          allezellengueltig = False
          Exit Function
        End If
      End If
    
      'Spalte Dienstjahre, ab 3.0.7 Dezimal- statt Ganzzahl
      If activecol = funstrcol_byname("data_form_col_dienstjahre") Then
        'If Round(objCell.Value, 0) <> objCell.Value Or objCell.Value < 0 _
        'Or objCell.Value > funvarvalue_byname("hlp_const_c_altermax") - funvarvalue_byname("hlp_const_c_altermin") Then
        If objCell.Value < 0 _
          Or objCell.Value > funvarvalue_byname("hlp_const_c_altermax") - funvarvalue_byname("hlp_const_c_altermin") Then
          
          allezellengueltig = False
          Exit Function
        End If
      End If
    
      'Spalte Ausbildung
      If activecol = funstrcol_byname("data_form_col_ausbildung") Then
        If objCell.Value <> 1 And objCell.Value <> 2 And objCell.Value <> 3 And objCell.Value <> 4 _
        And objCell.Value <> 5 And objCell.Value <> 6 And objCell.Value <> 7 And objCell.Value <> 8 Then
          allezellengueltig = False
          Exit Function
        End If
      End If

      'Spalte data_form_col_skillcalculated V2.5
      If activecol = funstrcol_byname("data_form_col_skillcalculated") Then
        If objCell.Value <> 1 And objCell.Value <> 2 And objCell.Value <> 3 And objCell.Value <> 4 Then
          allezellengueltig = False
          Exit Function
        End If
      End If
      
      'Spalte Berufliche Stellung
      If activecol = funstrcol_byname("data_form_col_berstellung") Then
        If objCell.Value <> 1 And objCell.Value <> 2 And objCell.Value <> 3 And objCell.Value <> 4 _
        And objCell.Value <> 5 Then
          allezellengueltig = False
          Exit Function
        End If
      End If
      
      'Spalte Beschaeftigungsgrad
      If activecol = funstrcol_byname("data_form_col_bgrad") Then
        If objCell.Value > funvarvalue_byname("hlp_const_c_bgradmax") Or objCell.Value < 0 Then
          allezellengueltig = False
          Exit Function
        End If
      End If
      
      '
      'Spalte bezahlte Stunden
      If activecol = funstrcol_byname("data_form_col_bezstunden") Then
        If objCell.Value > funvarvalue_byname("hlp_const_c_bezstundenmax") Or objCell.Value < 0 Then
          allezellengueltig = False
          Exit Function
        End If
      End If
    Next
  Next
  allezellengueltig = True
End Function




Attribute VB_Name = "frmfortschrittsanzeige"
Attribute VB_Base = "0{A4A286F6-501F-471C-B0C4-08EAD5EEFA2B}{789B470F-83E1-4EE3-B151-01FEE7CEA2CB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub btnok_Click()
  frmfortschrittsanzeige.Hide
End Sub

'Achtung: Am 24.10.2017 wurde dieser Code unter Excel 2016 Mac nie aufgerufen
Private Sub UserForm_Activate()
  'Mac kann vbModeless nicht interpretieren und stoppt den Macro
  '-> beim Start einer Aktion Fenster zeitbasiert anzeigen
  If Application.OperatingSystem Like "*Mac*" And frmfortschrittsanzeige.btnok.Visible = False Then
    Application.Wait (Now + TimeValue("0:0:5"))
    frmfortschrittsanzeige.Hide
  End If
End Sub


Attribute VB_Name = "frmimport"
Attribute VB_Base = "0{89467C6E-3E14-4331-BA3D-5D480F499EAF}{DEEA5393-C265-4AC6-862E-8D0F62C5B888}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub btncancel_Click()
  frmimport.Hide
  blnImportabbruch = True
End Sub


Private Sub btnok_Click()
  If frmimport.txtgeschlecht_0 <> "" And frmimport.txtgeschlecht_1 <> "" And _
    (frmimport.optgebjahr_jahr Or frmimport.optgebjahr_datum Or frmimport.optgebjahr_alter) And _
    (frmimport.txtgeschlecht_0 <> frmimport.txtgeschlecht_1) Then
    
    'Geschlecht
    ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_geschlecht_0")).Value = _
      frmimport.txtgeschlecht_0
    
    ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_geschlecht_1")).Value = _
      frmimport.txtgeschlecht_1
    
    'Geburtsjahr
    If frmimport.optgebjahr_jahr Then
      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_gebjahr")).Value = 0
    ElseIf frmimport.optgebjahr_datum Then
      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_gebjahr")).Value = 1
    ElseIf frmimport.optgebjahr_alter Then
      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_gebjahr")).Value = 2
    End If
          
    'Dienstjahre
    If frmimport.optdienstjahre_jahr Then
      'Erfassungsjahr - Eintrittsjahr
      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_dienstjahre")).Value = 0
    ElseIf frmimport.optdienstjahre_datum Then
      'Erfassungsjahr - Jahr(Eintrittsdatum)
      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_dienstjahre")).Value = 1
    ElseIf frmimport.optdienstjahre_anzjahre Then
      'nichts machen
      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_dienstjahre")).Value = 2
    End If
    
    'Kompetenzniveau (13.01.2016 Skala wird doch nicht gedreht)
'    ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_kompetenzniveau")).Value = -1
'    If frmimport.optkompetenzniveau_a Then
'      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_kompetenzniveau")).Value = 0
'    ElseIf optkompetenzniveau_k Then
'      ThisWorkbook.Sheets(STR_SH_HLP_CONST).Range(funstraddr_byname("hlp_const_c_kompetenzniveau")).Value = 1
'    End If
    
    'MsgBox ("Datum?" & frmimport.optgebjahr_datum)
    frmimport.Hide
    blnImportabbruch = False
  Else
    MsgBox strtranslate("msgbox_import.eingabefehlt"), vbOK
  End If
End Sub


Attribute VB_Name = "mac"
'===================================================================
'Modul mit macspezifischem Code sowie Hilfsroutinen

'Unterscheidung Mac / PC
'    If Not Application.OperatingSystem Like "*Mac*" Then
'       'Windows
'       strfilename = Application.GetOpenFilename(strimportfilter)
'    Else
'       'Mac
'       strfilename = openfilename_mac
'    End If

'Zeit mit
' - enableEvents = false fuer import LSE: 0.7109375
' - enableEvents = true fuer import LSE: Zeit 88.765625!!!

'Probleme / Fehlermeldungen
'bei importLSE
' - 1004 Fehler der Methode "Column" des Objekts "Range".: Name data_form_col_gebjahr in ByName.funstrcol
' - 438 Das Objekt unterstuetzt diese Eigenschaft oder Methode nicht.


'*******************************************************************
'Datenimport auf dem Macintosh
'verwendet im Modul ImportExport
'SR 24.10.2017 scheint nicht mehr noetig zu sein, auch nicht in Excel 2011
Function openfilename_mac()
    Dim MyPath As String
    Dim MyScript As String
    Dim MyFiles As String
    Dim MySplit As Variant
    Dim counter As Long
    Dim result As Variant

    On Error Resume Next
    MyPath = MacScript("return (path to documents folder) as String")

    ' If you want to filter for multiple files, change
    ' {""com.microsoft.Excel.xls""} to
    ' {""com.microsoft.excel.xls"",""public.comma-separated-values-text""}
    ' if you want to filter on xls and csv files, for example.
    ' SR 16.10.2014 mit CSV klappt es nicht wirklich -> weggelassen
    MyScript = _
    "set applescript's text item delimiters to "","" " & vbNewLine & _
      "set theFiles to (choose file of type " & _
      " {""org.openxmlformats.spreadsheetml.sheet"", ""txt""} " & _
      "with prompt """ & strtranslate("data_head.lblbtnimporttext") & """ default location alias """ & _
      MyPath & """ multiple selections allowed false) as string" & vbNewLine & _
      "set applescript's text item delimiters to """" " & vbNewLine & _
      "return theFiles"

    MyFiles = MacScript(MyScript)
    On Error GoTo 0

    If MyFiles <> "" Then
      With Application
        .ScreenUpdating = False
        .EnableEvents = False
      End With

      MySplit = Split(MyFiles, ",")
      For counter = LBound(MySplit) To UBound(MySplit)
        result = MySplit(counter)
      Next counter
      ' SR 04.10.2017 auf Mac testen
      ' Dateipfad Excel 2011 Macintosh HD:Users:EBG:Exportform_d_20170105_172133.xlsx
      ' Dateipfad Excel 2016 /Users/EBG/Exportform_d_20170105_172133.xlsx
      If Val(Application.Version) >= 15 Then 'excel 2016 support
        Debug.Print "Excel 2016 Path before transformation: " & result
        result = Replace(result, ":", "/")
        result = Replace(result, "Macintosh HD", "", Count:=1)
        Debug.Print "Excel 2016 Path after transformation: " & result
      End If
      With Application
        .ScreenUpdating = True
        .EnableEvents = True
      End With
    End If
    openfilename_mac = result
End Function


'*******************************************************************
'Aktualisiert Statusbar auf dem Macintosh
'Ersatz fuer das technisch nicht moegliche Dialogfenster
'fuer die Fortschrittsanzeige
Sub updatestatusbar_mac(Optional ByVal strMessage = "")
  If strMessage = "" Then
    'Zuruecksetzen auf Excel-Standard
    Application.StatusBar = False
  Else
    Application.StatusBar = "Progress: " & strMessage
    DoEvents '
  End If
End Sub

'*******************************************************************
'Variable fuer Language hat auf Mac von Excel11 zu Excel16 gewechselt
Function funGetLanguageMac()
  If Val(Application.Version) >= 16 Then
    funGetLanguageMac = Application.LanguageSettings.LanguageID(2)
  Else
    funGetLanguageMac = Application.localizedlanguage
  End If
End Function

'*******************************************************************
'Codeschnippsel, der z.Z. nicht eingesetzt wird
Function bIsBookOpen(ByRef szBookName As String) As Boolean
' Contributed by Rob Bovey
    On Error Resume Next
    bIsBookOpen = Not (Application.Workbooks(szBookName) Is Nothing)
End Function

Attribute VB_Name = "sheet_data_form"
'===================================================================
'Methoden, die von den Steuerelementen auf dem Blatt data_head aufgerufen werden


'*******************************************************************
'Schaltflaeche Auswerten loest Auswertung aus
Private Sub btnauswertung_Click()
  If blnNichtFreigegeben() And Not blnIsControlForm() And blnIsAnzahlGueltigeDatenGenuegend() Then 'Function in Modul Hilfsmakros
    Call auswerten
  End If
End Sub



'*******************************************************************
'EBG-Mappe exportieren
Private Sub btnexportdata_Click()
  Call export_ebgsheet
End Sub

'*******************************************************************
'Formatiert den Hintergrund einer Zelle weiss
Sub formatCellBackgroundWhite(ByRef objRange As Range)
    With objRange.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorDark1
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
End Sub

'*******************************************************************
'Formatiert den Eingabebereich der Joblist
Sub formatJoblistEntry(ByRef objRange As Range)
  'Sperrung aufheben
  objRange.Locked = False

  'Schrift anpassen
  objRange.Font.Bold = True
  With objRange.Font
      .name = "Arial"
      .Size = 11
  End With
  With objRange
      .HorizontalAlignment = xlCenter
  End With
  
  'Raender zeichnen
  With objRange.Borders(xlEdgeLeft)
      .LineStyle = xlContinuous
      .ColorIndex = xlAutomatic
      .TintAndShade = 0
      .Weight = xlThin
  End With
  With objRange.Borders(xlEdgeRight)
      .LineStyle = xlContinuous
      .ColorIndex = xlAutomatic
      .TintAndShade = 0
      .Weight = xlThin
  End With
  With objRange.Borders(xlInsideVertical)
      .LineStyle = xlContinuous
      .ColorIndex = xlAutomatic
      .TintAndShade = 0
      .Weight = xlThin
  End With
  
  'Bedingte Formatierung
  Dim objRangeFC As Range
  Dim myRow As Long
  myRow = objRange.Row
  'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
  Set objRangeFC = ThisWorkbook.Sheets(objRange.Worksheet.name).Range("B" & myRow & ":" & "I" & myRow)
  objRangeFC.FormatConditions.delete
  objRangeFC.FormatConditions.Add Type:=xlExpression, Formula1:="=$I" & myRow
  '%%%
  objRangeFC.FormatConditions(objRangeFC.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_format_joblist")

  With objRangeFC.FormatConditions(objRangeFC.FormatConditions.Count).Borders(xlTop)
    .LineStyle = xlContinuous
    .ColorIndex = xlAutomatic
    .TintAndShade = 0
    .Weight = xlThin
  End With
  With objRangeFC.FormatConditions(objRangeFC.FormatConditions.Count).Borders(xlBottom)
    .LineStyle = xlContinuous
    .ColorIndex = xlAutomatic
    .TintAndShade = 0
    .Weight = xlThin
  End With
End Sub


'*******************************************************************
'blendet auf Blatt joblist 2 Zeilen mit Erklaerungen ein oder aus
Private Sub btntogglehelp_Click()
  Dim blnProtected As Boolean
  Dim bereich As String
  
  blnProtected = ThisWorkbook.Sheets(STR_SH_JOBLIST).ProtectContents
  ThisWorkbook.Worksheets(STR_SH_JOBLIST).Unprotect Password:=changeToNumberString("s")

  bereich = ThisWorkbook.Names("joblist_col_job").RefersToRange.Row - 3 & ":" _
    & ThisWorkbook.Names("joblist_col_job").RefersToRange.Row - 2
  ThisWorkbook.Worksheets(STR_SH_JOBLIST).Rows(bereich).EntireRow.Hidden = Not (Rows(bereich).EntireRow.Hidden)
  
  'Buttontext von btntogglehelp wechseln
  If ThisWorkbook.Worksheets(STR_SH_JOBLIST).Rows(bereich).EntireRow.Hidden Then
    Call translateButton(STR_SH_JOBLIST, "btntogglehelp", "joblist.hilfe.ein")
  Else
    Call translateButton(STR_SH_JOBLIST, "btntogglehelp", "joblist.hilfe.aus")
  End If

  'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
  Call protectSheet(STR_SH_JOBLIST, blnProtected)

End Sub


'*******************************************************************
'Nach Sortierung des data forms muss auch Regression sortiert werden
'Parameter ist nur dafuer da, dass der Makro nicht sichtbar ist, Prozedur muss public sein
Sub sortRegr(ByVal strNurFuerPrivate As String)

  Application.Calculate
  ThisWorkbook.Worksheets(STR_SH_HLP_DATA_REGR1).Unprotect Password:=changeToNumberString("s")
  ThisWorkbook.Worksheets(STR_SH_HLP_DATA_REGR2).Unprotect Password:=changeToNumberString("s")
  ThisWorkbook.Names("hlp_data_regr1_col_filter").RefersToRange.Sort _
    Key1:=ThisWorkbook.Names("hlp_data_regr1_col_filter").RefersToRange, _
    Order1:=xlDescending, Header:=xlGuess, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
  
  'regr2 sortieren
  ThisWorkbook.Names("hlp_data_regr2_col_filter").RefersToRange.Sort _
    Key1:=ThisWorkbook.Names("hlp_data_regr2_col_filter").RefersToRange, _
    Order1:=xlDescending, Header:=xlGuess, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
  Call blattschutz_ein_drawing_and_hidden(STR_SH_HLP_DATA_REGR1, True, True)
  Call blattschutz_ein_drawing_and_hidden(STR_SH_HLP_DATA_REGR2, True, True)

End Sub


'*******************************************************************
'Sortiert data_form
'Aufruf mit call sortData_form("data_form_col_laufnr") oder sortData_form("data_form_col_jobmanual")
'Ab 3.1.0 keine Parameter mehr, da nach jedem Feld der Liste sortiert werden kann
'Parameter ist nur dafuer da, dass der Makro nicht sichtbar ist, Prozedur muss public sein
Sub sortData_form(ByVal strNurFuerPrivate As String) 'ByVal strNameColToSort As String)
  On Error GoTo fehler
  
  Dim blnProtected As Boolean
  Dim intOrder
  Dim objRange As Range
  Dim objRangeKey As Range
  
  intOrder = 1 'xlAscending = 1 ist Default, falls keine Eingabe
  If Not IsEmpty(ThisWorkbook.Names("data_form_c_sortierreihenfolge").RefersToRange) Then
    intOrder = Left(ThisWorkbook.Names("data_form_c_sortierreihenfolge").RefersToRange.Value, 1)
  End If
  
  Dim strSortRange As String
  'Steht im Sortierfeld etwas?
  If Not IsEmpty(ThisWorkbook.Names("data_form_c_sortierfeld").RefersToRange) Then
    blnProtected = ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  
    For Each objRange In ThisWorkbook.Names("data_form_vec_collabels").RefersToRange.Cells
      If ThisWorkbook.Names("data_form_c_sortierfeld").RefersToRange.Value = objRange.Value Then
        'Debug.Print objRange.Column
        Set objRangeKey = objRange.Offset(1, 0)
        Exit For
      End If
    Next
      
    strSortRange = ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).CurrentRegion.Address
  
    'Set objRangeKey = Range(funstrcol_byname(strNameColToSort) _
    '  & ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row)
    Debug.Print objRangeKey.Address
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Sort.SortFields.Clear
    
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Sort.SortFields.Add Key:=objRangeKey, _
        SortOn:=xlSortOnValues, Order:=intOrder, DataOption:=xlSortNormal
    With ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Sort
        .SetRange Range(strSortRange)
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With
  
    Call protectSheet(STR_SH_DATA_FORM, blnProtected)
    
    'Regressionsblaetter sortieren
    Call sortRegr("")
  End If 'Not IsEmpty(ThisWorkbook.Names("data_form_c_sortierfeld").RefersToRange)
  
  Exit Sub
  
fehler:
  Debug.Print "Fehler in sortData_form, strNameColToSort: " & strNameColToSort & " " & err.Source & " " & err.Description
  
End Sub




'*******************************************************************
'Sortiert die Jobliste
'Aufruf mit call sortJoblist("joblist_col_job") oder sortJoblist("joblist_col_anfniveau")
Sub sortJoblist(ByVal strNameColToSort As String)
    
  On Error GoTo fehler
  Dim objRangeKey As Range
  Set objRangeKey = Range(ThisWorkbook.Worksheets(STR_SH_JOBLIST).Cells(ThisWorkbook.Names("joblist_lst").RefersToRange.Row, _
    ThisWorkbook.Names(strNameColToSort).RefersToRange.Column), _
    ThisWorkbook.Worksheets(STR_SH_JOBLIST).Cells(LastRowInRange(ThisWorkbook.Names("joblist_lst").RefersToRange), _
    ThisWorkbook.Names(strNameColToSort).RefersToRange.Column))
  'Debug.Print objRangeKey.Address
  ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields.Clear
  
  ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort.SortFields.Add Key:=objRangeKey, _
      SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
  With ThisWorkbook.Worksheets(STR_SH_JOBLIST).Sort
      .SetRange ThisWorkbook.Names("joblist_lst").RefersToRange 'Range("B13:H23")
      .Header = xlNo
      .MatchCase = False
      .Orientation = xlTopToBottom
      .SortMethod = xlPinYin
      .Apply
  End With

  Exit Sub
  
fehler:
  Debug.Print "Fehler in sortJoblist, strNameColToSort: " & strNameColToSort & " " & err.Source & " " & err.Description
  
End Sub

'*******************************************************************
'wechselt Sortierung joblist zwischen Funktion col_job und Kompetenzniveau col_anfniveau
Private Sub btnjoblistsort_Click()
  Call sortJoblistClick
End Sub


'*******************************************************************
'Aufgerufen aus
' - sheet_data_form.btnJoblist_Click
' - ImportExport.btnjoblistimport_Click
Sub updateJoblist(ByRef objCellTarget As Range, ByRef lngLastFilledRowTarget As Long, ByVal objCellSource As Range, _
  ByVal strColStartTarget As String, ByVal introwdatastarttarget As Integer, _
  Optional ByVal blnoverwrite As Boolean = False, Optional ByVal intSourceColOffset As Integer = 1)
  
  Dim objCellTmp As Range
  Dim objCellSourceSkilllist As Range
  Set objCellSourceSkilllist = objCellSource.Offset(0, intSourceColOffset)
  
  With ThisWorkbook.Sheets(STR_SH_JOBLIST).Range(strColStartTarget _
    & introwdatastarttarget & ":" & strColStartTarget & lngLastFilledRowTarget)
    'In Source2 Laufnr zu Zeile suchen
    Set objCellTmp = .Find(what:=objCellSource.Value, _
      LookIn:=xlValues, _
      LookAt:=xlWhole, _
      SearchOrder:=xlByRows, _
      SearchDirection:=xlNext, _
      MatchCase:=False)
                          
    'Existiert diese Laufnr im zweiten File nicht -> Wert kopieren
    If objCellTmp Is Nothing Then
      objCellTarget.Value = objCellSource.Value
      'Erste Spalte weiss formatieren
      Call formatCellBackgroundWhite(ThisWorkbook.Sheets(STR_SH_JOBLIST).Cells(objCellTarget.Row, 1))
      objCellTarget.Offset(0, -1).FormulaR1C1 = "=RC[2]"
      objCellTarget.Offset(0, 1).FormulaR1C1 = _
        "=IF(SUM(ISBLANK(RC[1]),ISBLANK(RC[2]),ISBLANK(RC[3]),ISBLANK(RC[4]))<>3,#N/A,IF(NOT(ISBLANK(RC[1])),1,IF(NOT(ISBLANK(RC[2])),2,IF(NOT(ISBLANK(RC[3])),3,4))))"
      objCellTarget.Offset(0, 6).Formula = "=ISEVEN(CELL(""row""," & objCellTarget.Address(False, True) & "))"
      Call formatJoblistEntry(Range(objCellTarget.Offset(0, 2), objCellTarget.Offset(0, 6)))
      If Not IsEmpty(objCellSourceSkilllist) And IsNumeric(objCellSourceSkilllist) Then
        'falls gueltiger Wert, dann Kompetenzniveau uebernehmen
        If objCellSourceSkilllist.Value > 0 And objCellSourceSkilllist.Value <= 4 _
          And Round(objCellSourceSkilllist.Value, 0) = objCellSourceSkilllist.Value Then
          objCellTarget.Offset(0, objCellSourceSkilllist.Value + 1).Value = STR_JOBLIST_CHAR
        End If
      End If
      
      'Bereich Zielzelle und letzte Reihe verschieben
      lngLastFilledRowTarget = lngLastFilledRowTarget + 1
      Set objCellTarget = objCellTarget.Offset(1, 0)
    Else
      'Wert uebernehmen, wenn vorher noch fehlend oder falsch
      If Not IsNumeric(objCellTmp.Offset(0, 1).Value) _
        And objCellSourceSkilllist.Value > 0 And objCellSourceSkilllist.Value <= 4 _
        And Round(objCellSourceSkilllist.Value, 0) = objCellSourceSkilllist.Value Then
        
        'Debug.Print objcelltmp.Value
        Range(objCellTmp.Offset(0, 2), objCellTmp.Offset(0, 5)).ClearContents
        objCellTmp.Offset(0, objCellSourceSkilllist.Value + 1).Value = STR_JOBLIST_CHAR
      Else
        'Bei Import der Joblist kann overwrite gesetzt werden
        If blnoverwrite Then
          Range(objCellTmp.Offset(0, 2), objCellTmp.Offset(0, 5)).ClearContents
          objCellTmp.Offset(0, objCellSourceSkilllist.Value + 1).Value = STR_JOBLIST_CHAR
        End If
      End If
    End If
  End With
End Sub


Function funAnfniveauRandom()
  Call Randomize
  
  Dim intResult As Integer
  Dim dblnumber As Double
  dbl = Rnd
  If Rnd < 0.1 Then
    intResult = 4
  ElseIf Rnd < 0.3 Then
    intResult = 3
  ElseIf Rnd < 0.6 Then
    intResult = 2
  Else
    intResult = 1
  End If
  funAnfniveauRandom = intResult
End Function

'Nur zum Testen
Private Sub fillAnfNiveauRandom()
    
  Dim objCell As Range
  Dim strColStartTarget As String
  Dim lngLastFilledRowTarget As Long
  Dim introwdatastarttarget As Integer
  
  Call silentCode
  
  strColStartTarget = funstrcol_byname("joblist_col_anfniveau")
  introwdatastarttarget = ThisWorkbook.Names("joblist_col_job").RefersToRange.Range("A1").Row + 1
  lngLastFilledRowTarget = funlnglastfilledrowincol(ThisWorkbook.name, _
      STR_SH_JOBLIST, funstrcol_byname("joblist_col_job"))
  
  For Each objCell In ThisWorkbook.Sheets(STR_SH_JOBLIST).Range( _
    strColStartTarget & introwdatastarttarget & ":" & strColStartTarget & lngLastFilledRowTarget)
    objCell.Value = funAnfniveauRandom
  Next
  
  Call restore
End Sub




Attribute VB_Name = "sheet_data_head"
'===================================================================
'Methoden, die von den Steuerelementen auf dem Blatt data_head aufgerufen werden


'*******************************************************************
'Stellt urspruenglichen Zustand nach Abbruch Import wieder her
'Aufgerufen von
' + btnimporttext_Click()
' + btnimportlse_Click
Private Sub restorenachimportabbruch()
  On Error GoTo fehler
  Call updateActiveProc("sheet_data_head.restorenachimportabbruch")
  Call blatt_ausblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  Call blattschutz_ein
  Call berechnung_einschalten
  Application.Cursor = xlDefault
  
  Exit Sub
  
fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next

End Sub


'*******************************************************************
'Daten loeschen nach Click auf Button "Alle Daten und Auswertungen loeschen"
Private Sub btndeletedata_Click()
  On Error GoTo fehler
  
  Application.ScreenUpdating = False
  Call updateActiveProc("Tabelle17.btndeletedata_Click")
  Call mappe_leeren
  Application.ScreenUpdating = True
  
  Exit Sub
  
fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next

End Sub


'*******************************************************************
'Datenimport aus Text oder Excel-Datei
Private Sub btnimporttext_Click()
  If ISTEST = False Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("Tabelle17.btnimporttext_Click")

  If Not blnNichtFreigegeben Then 'Function in Modul Hilfsmakros
    Exit Sub
  End If

  Dim intanzsteps As Integer
  Dim intwidthtotal As Integer

  If CInt(funvarvalue_byname("data_head_c_jahr")) <= 0 Then
    MsgBox (strtranslate("fehler.msg.jahreingeben"))
    ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Select
  ElseIf CSng(funvarvalue_byname("data_head_c_buwaz")) <= 0 Then
    MsgBox (strtranslate("fehler.msg.buwazeingeben"))
    ThisWorkbook.Names("data_head_c_buwaz").RefersToRange.Select
  ElseIf IsEmpty(funvarvalue_byname("data_head_c_stundenlohn_jn")) Then
    MsgBox (strtranslate("fehler.msg.stundenlohnjneingeben"))
    ThisWorkbook.Names("data_head_c_stundenlohn_jn").RefersToRange.Select
  'ab Logib 2.5 falls Arbeitnehmende im Stundenlohn sind auch diese Felder obligatorisch
  ElseIf Left(funvarvalue_byname("data_head_c_stundenlohn_jn"), 1) = "2" _
    And (IsEmpty(funvarvalue_byname("data_head_c_stundenlohn_anzstunden")) _
    Or IsEmpty(funvarvalue_byname("data_head_c_stundenlohn_bruttonetto"))) Then
    
    If IsEmpty(funvarvalue_byname("data_head_c_stundenlohn_anzstunden")) Then
      MsgBox (strtranslate("fehler.msg.stundenlohnanzstundeneingeben"))
      ThisWorkbook.Names("data_head_c_stundenlohn_jn").RefersToRange.Select
    ElseIf IsEmpty(funvarvalue_byname("data_head_c_stundenlohn_bruttonetto")) Then
      MsgBox (strtranslate("fehler.msg.stundenlohnbruttonettoeingeben"))
      ThisWorkbook.Names("data_head_c_stundenlohn_bruttonetto").RefersToRange.Select
    End If
  Else

    Application.ScreenUpdating = False
    Application.EnableEvents = False

    'Fortschrittsanzeige
    intwidthtotal = frmfortschrittsanzeige.txtrahmen.Width - 2
    intanzsteps = 4
    frmfortschrittsanzeige.btnok.Visible = False
    frmfortschrittsanzeige.Caption = strtranslate("frmfortschrittsanzeige.caption")
    frmfortschrittsanzeige.lblerklaerung = strtranslate("frmfortschrittsanzeige.lblerklaerung1")
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext1")
    frmfortschrittsanzeige.lblbalken.Width = 1

    Call berechnung_ausschalten
    Call blatt_einblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
    'Vorgehen speichern
    ThisWorkbook.Names("hlp_const_c_vorgehen").RefersToRange.Value = "Import"
    Call frmimport_anzeigen

    'Abbruch auf Maske
    If blnImportabbruch Then
      Call restorenachimportabbruch
      MsgBox strtranslate("import.abgebrochen")
      Exit Sub
    End If

    'Blattschutz aufheben
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
    'hier kommt import
    Call import_exceltext(intwidthtotal)

    'Import aus irgendwelchen Gruenden abgebrochen
    If blnImportabbruch Then
      Call restorenachimportabbruch
      Exit Sub
    End If
    'Debug.Print Timer & ": btnimporttext_Click() vor Aufruf init_data_form "

    'Fortschrittsanzeige nicht fuer Mac
    If Not Application.OperatingSystem Like "*Mac*" Then
      frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext2")
      frmfortschrittsanzeige.lblbalken.Width = 2 * Int(intwidthtotal / intanzsteps)
      frmfortschrittsanzeige.Repaint
    Else
      Call updatestatusbar_mac(strtranslate("frmfortschrittsanzeige.lbllauftext2"))
    End If

    Call init_data_form(True)

    'Fortschrittsanzeige nicht fuer Mac
    If Not Application.OperatingSystem Like "*Mac*" Then
      frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftextneuberechnen")
      frmfortschrittsanzeige.lblbalken.Width = 3 * Int(intwidthtotal / intanzsteps)
      frmfortschrittsanzeige.Repaint
    Else
      Call updatestatusbar_mac(strtranslate("frmfortschrittsanzeige.lbllauftextneuberechnen"))
    End If
    
    'Joblist erstellen
    Call btnJoblist_Click
    ThisWorkbook.Worksheets("data_form").Activate
    
    Call berechnung_einschalten

    'Automatisches Speichern
    ThisWorkbook.Save

    frmfortschrittsanzeige.lblbalken.Width = 4 * Int(intwidthtotal / intanzsteps)
    frmfortschrittsanzeige.lblerklaerung = strtranslate("frmfortschrittsanzeige.lblerklaerung2")
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext4")
    frmfortschrittsanzeige.btnok.Visible = True
    If Not Application.OperatingSystem Like "*Mac*" Then
      frmfortschrittsanzeige.Repaint
    Else
      Call updatestatusbar_mac("")
      frmfortschrittsanzeige.Show '(vbModeless)
    End If

  End If 'CInt(funvarvalue_bynam
  
  Application.ScreenUpdating = True
  Application.EnableEvents = True
  Exit Sub

fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next
End Sub


'*******************************************************************
'Datenimport aus EBG-Formular
'Lohnstrukturerhebung LSE 2004 - 2010 ab Version 2.5 nicht mehr unterstuetzt
Private Sub btnimportlse_Click()
  If ISTEST = False Then
    On Error GoTo fehler
  End If
  Call updateActiveProc("Tabelle17.btnimportlse_Click")
 
  If Not blnNichtFreigegeben Then 'Function in Modul Hilfsmakros
    Exit Sub
  End If

  Const BYT_MONAT As Byte = 10
  
  Dim intwidthtotal As Integer
  Dim intJahr As Integer
  intJahr = 0
  Dim varJar As Variant
  Dim varTmp
  
  Call berechnung_ausschalten
   
  If Not ISTEST Then
    Application.ScreenUpdating = False
  End If
  Application.EnableEvents = False
  Call blatt_einblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
  
  'Vorgehen speichern
  ThisWorkbook.Names("hlp_const_c_vorgehen").RefersToRange.Value = "LSE"
  ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  
  'Fortschrittsanzeige
  intwidthtotal = frmfortschrittsanzeige.txtrahmen.Width - 2
  frmfortschrittsanzeige.btnok.Visible = False
  frmfortschrittsanzeige.Caption = strtranslate("frmfortschrittsanzeige.caption")
  frmfortschrittsanzeige.lblerklaerung = strtranslate("frmfortschrittsanzeige.lblerklaerung1")
  frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext1")
  frmfortschrittsanzeige.lblbalken.Width = 1
  
  Call import_lse2004(intwidthtotal)
  
  'Import aus irgendwelchen Gruenden abgebrochen
  If blnImportabbruch Then
    If Not Application.OperatingSystem Like "*Mac*" Then
      frmfortschrittsanzeige.Hide
    End If
    Call restorenachimportabbruch
    Exit Sub
  End If
  
  If Not Application.OperatingSystem Like "*Mac*" And Not ISTEST Then
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext2")
    frmfortschrittsanzeige.lblbalken.Width = 2 * Int(intwidthtotal / 4)
    frmfortschrittsanzeige.Repaint
  Else
    Call updatestatusbar_mac(strtranslate("frmfortschrittsanzeige.lbllauftext2"))
  End If
  
  Call init_data_form(True)
  
  'Hier erfolgt Absturz
  If Not Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.lblbalken.Width = 3 * Int(intwidthtotal / 4)
    frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftextneuberechnen")
  Else
    Call updatestatusbar_mac(strtranslate("frmfortschrittsanzeige.lbllauftextneuberechnen"))
  End If
  Call berechnung_einschalten
  'Debug.Print "fertig"
  
  'Automatisches Speichern
  ThisWorkbook.Save
  
  'msgbox_import.lsejahr
  While ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Value = "" _
    Or Not IsNumeric(ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Value)
    'User/in Jahrzahl eingeben lassen
    varJar = InputBox(strtranslate("msgbox_import.lsejahr"))


    'Eingabe ueberpruefen
    If IsNumeric(varJar) Then
      If CInt(varJar) <= Year(Now) And CInt(varJar) >= Year(Now) - 50 Then
        intJahr = CInt(varJar)
        'Application.ScreenUpdating = True
        'Application.EnableEvents = True
        '%%%%% das hier funktioniert noch nicht richtig
        ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
        ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Value = intJahr
        ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Calculate
        Call protectSheet(STR_SH_DATA_FORM, True)
      End If
    End If
  Wend

  frmfortschrittsanzeige.lblbalken.Width = 4 * Int(intwidthtotal / 4)
  frmfortschrittsanzeige.lblerklaerung = strtranslate("frmfortschrittsanzeige.lblerklaerung2")
  frmfortschrittsanzeige.lbllauftext = strtranslate("frmfortschrittsanzeige.lbllauftext4")
  frmfortschrittsanzeige.btnok.Visible = True
  If Not Application.OperatingSystem Like "*Mac*" Then
    frmfortschrittsanzeige.Repaint
  Else
    Call updatestatusbar_mac("")
    frmfortschrittsanzeige.Show '(vbModeless)
  End If
  Application.ScreenUpdating = True
  Application.EnableEvents = True

  Exit Sub
  
fehler:
  Call senderrormail(straktiveprozedur)
  Application.ScreenUpdating = True
  Application.EnableEvents = True
  Resume Next
End Sub




Attribute VB_Name = "validierung"
Option Explicit
Option Private Module

'===================================================================
' Datenvalidierung
' - Gueltigkeitspruefung -> validation
'     Achtung: Texte fuer InputMessage und ErrorMessage max 255 Zeichen!
' - Routinen zur Ueberpruefung -> val_

'sheet.circleinvalid kreist Daten ein, die ungueltig sind
'mit cell.Validation.Value = False laesst sich Validierung pruefen


'*******************************************************************
'Ueberprueft, ob auf einem Range eine Validierung vorhanden ist
'  geht nur ueber Fehler, mit isobject, isnull, isempty geht es nicht
Function funblnvalidationexists(ByVal objRange As Range)
  On Error GoTo fehler
  If IsNumeric(objRange.Validation.Type) Then
    funblnvalidationexists = True
  End If
  Exit Function
fehler:
  err.Clear
  funblnvalidationexists = False
End Function


'*******************************************************************
'Gueltigkeitspruefung mit Liste V2.5 ((((
'Bedingung: konsequente Benennung
' - "data_form.valhlp" & strspaltenbez -> Eintrag in Suchspalte auf hlp_translations fuer Eingabetexte
' - "data_form.lbl" & strspaltenbez -> Eintrag in Suchspalte auf hlp_translations fuer Eingabetexte fuer Spaltenbeschriftung
' - "data_form_col_" & strspaltenbez -> Name der Spalte auf data_form
' - "hlp_const_vec_" & strspaltenbez -> Name fuer die Werteliste
'Argumente
' - objsheetdata: Worksheet, auf dem die Gueltigkeitspruefung erstellt wird
' - introwfirst: erste Zeile
' - lngrowlast: letzte Zeile
' - strspaltenbez: Bezeichnung der Spalte
' - blnignoreblank: true, wenn Spalte leergelassen werden kann -> auch fuer nicht obligatorische Spalten verwendbar
Sub set_validation_list(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long, _
  ByVal strspaltenbez As String, ByVal blnignoreblank As Boolean)
  
  
  Dim objRange As Range
  Dim strSheetName As String
  strSheetName = objsheetdata.name
  
  Dim strCol As String
  strCol = funstrcol_byname(strSheetName & "_col_" & strspaltenbez)
  
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  'Fuer skillcalculated wird nur bedingte Formatierung gesetzt
  If strspaltenbez = "skillcalculated" Then
    objRange.Validation.delete
    'bezieht sich auf den Vector anfniveau
    Call set_formatconditions_between(objRange, strlocalfunctionganz("MIN(hlp_const_vec_anfniveau)"), _
      strlocalfunctionganz("MAX(hlp_const_vec_anfniveau)"), True, "hlp_const_c_data_invalid")
    '((((
    'weitere Bedingung Unterschied
  Else
    With objRange.Validation
      .delete
      .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:="=hlp_const_vec_" & strspaltenbez
      .IgnoreBlank = blnignoreblank
      .InCellDropdown = True
      .ShowInput = True
      .ShowError = True
    End With
    'fuer Grundgesamtheit alle Werte ausser leer und 1 grau
    If strspaltenbez = "grundgesamtheit" Then
      With objRange
        'Ab 3.0.7 Minimalwert aus Liste, vorher Formula1:="=2"
        'xxxx
        .FormatConditions.Add Type:=xlCellValue, Operator:=xlBetween, _
            Formula1:=strlocalfunctionganz("MIN(hlp_const_vec_" & strspaltenbez & ")+1"), _
            Formula2:=strlocalfunctionganz("MAX(hlp_const_vec_" & strspaltenbez & ")")
        .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_valid_exclusion")
      End With
    End If
    Call set_formatconditions_between(objRange, strlocalfunctionganz("MIN(hlp_const_vec_" & strspaltenbez & ")"), _
      strlocalfunctionganz("MAX(hlp_const_vec_" & strspaltenbez & ")"), True, "hlp_const_c_data_invalid")

  End If

End Sub


'*******************************************************************
'bedingte Formatierung mit Formel setzen statt mit
'eigener Funktion datengueltig
'umschaltbar mit Konstante BLN_FORMATCONDITIONS_FORMULA
'neu ab 11.11.2014
'V2.5 zu .FormatConditions.Count gewechselt
'ab 3.0.7 neuer Parameter strNameColor
Sub set_formatconditions_between(objRange As Range, ByVal strformula1 As String, _
  ByVal strFormula2 As String, ByVal blnganzzahl As Boolean, ByVal strNameColor)
  
  If BLN_FORMATCONDITIONS_FORMULA Then
    With objRange
      .FormatConditions.Add Type:=xlCellValue, Operator:=xlNotBetween, _
          Formula1:=strformula1, Formula2:=strFormula2
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname(strNameColor)
    End With
    
    Dim strfunction As String
    strfunction = strlocalfunction("int", "A1")
    Dim strCol, strrow, straddress As String
    strCol = funstrfirstcol_byrange(objRange)
    strrow = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
    straddress = strCol & strrow
    If blnganzzahl Then
      With objRange
        .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=" & strfunction & "(" & straddress & ")<>" & straddress
        .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
      End With
    End If
  End If
End Sub


'*******************************************************************
'bedingte Formatierung mit Formel einseitig setzen
'ab 12.07.2019
'ermoeglicht ungueltig unten und Warnung oben
Sub set_formatconditions_einseitig(objRange As Range, ByVal intOperator As Integer, ByVal strformula1 As String, _
  ByVal blnganzzahl As Boolean, ByVal strNameColor)
  
  If BLN_FORMATCONDITIONS_FORMULA Then
    With objRange
      .FormatConditions.Add Type:=xlCellValue, Operator:=intOperator, Formula1:=strformula1
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname(strNameColor)
    End With
    
    Dim strfunction As String
    strfunction = strlocalfunction("int", "A1")
    Dim strCol, strrow, straddress As String
    strCol = funstrfirstcol_byrange(objRange)
    strrow = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
    straddress = strCol & strrow
    'Das ist immer zwingend
    If blnganzzahl Then
      With objRange
        .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=" & strfunction & "(" & straddress & ")<>" & straddress
        .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
      End With
    End If
  End If
End Sub


'*******************************************************************
'Laufnummer: obligatorisch und eindeutig
Sub set_validation_laufnr(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim lngLocale As Long
  Dim objRange As Range
  Dim strCol As String
  strCol = funstrcol_byname("data_form_col_laufnr")
  Dim strformula1 As String
  
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  
  objRange.Validation.delete
  strformula1 = "=CountIf(" & strCol & "$" & introwfirst & ":" & _
        strCol & introwfirst & "," & strCol & introwfirst & ")"
  On Error GoTo lokalevalidierung
  
  'Achtung: Englischer Funktionsname und US-Trennzeichen in Formel, d.h. "," !!!
  'Wird manchmal nicht automatisch lokalisiert! Ist nicht von Version abhaengig!
  'Formel prueft, ob Wert mehr als einmal vorkommt: =Z|fffd|HLENWENN(A$16:A16;A16)=1
  'Reagiert erst beim 2. Auftreten
  objRange.Validation.Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, _
        Formula1:=strformula1 & "=1"
  With objRange.Validation
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  'neu ab 11.11.2014
  If BLN_FORMATCONDITIONS_FORMULA Then
    With objRange
      .FormatConditions.Add Type:=xlExpression, Formula1:=strlocalfunctionganz(strformula1 & "<>1")
      .FormatConditions(.FormatConditions.Count).Interior.Color = funvarvalue_byname("hlp_const_c_data_invalid")
    End With
  End If
  Exit Sub
lokalevalidierung:
  objRange.Validation.Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, _
    Formula1:=strlocalfunctionganz(strformula1)
  Resume Next
End Sub


'*******************************************************************
'Geburtsjahr: obligatorisch und zwischen Erfassungsjahr - Min.Alter und Erfassungsjahr - Max.Alter
Sub set_validation_gebjahr(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_gebjahr")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  'Ab 3.0.7 ohne +1 und -1
  strformula1 = "=data_head_c_jahr-hlp_const_c_altermax"
  strFormula2 = "=data_head_c_jahr-hlp_const_c_altermin"
  With objRange.Validation
    .delete
    .Add Type:=xlValidateWholeNumber, AlertStyle:=xlValidAlertStop, _
      Operator:=xlBetween, Formula1:=strformula1, _
      Formula2:=strFormula2
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  Call set_formatconditions_between(objRange, strformula1, strFormula2, True, "hlp_const_c_data_invalid")
End Sub


'*******************************************************************
'Dienstjahre: obligatorisch und zwischen 0 und Max.Alter - Min.Alter
Sub set_validation_dienstjahre(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_dienstjahre")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  strFormula2 = "=hlp_const_c_altermax-hlp_const_c_altermin"
  With objRange.Validation
    .delete
    .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
      Operator:=xlBetween, Formula1:="0", _
      Formula2:=strFormula2
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  strformula1 = "=0"
  'Ab 3.0.7 keine Ganzzahl mehr
  Call set_formatconditions_between(objRange, strformula1, strFormula2, False, "hlp_const_c_data_invalid")
End Sub


'*******************************************************************
'Beschaeftigungsgrad: obligatorisch und zwischen 0 und hlp_const_c_bgradmax
Sub set_validation_bgrad(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_bgrad")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)

  strFormula2 = "=hlp_const_c_bgradmax"
  With objRange.Validation
    .delete
    .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
      Operator:=xlBetween, Formula1:="0", _
      Formula2:=strFormula2
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  strformula1 = "=0"
  Call set_formatconditions_between(objRange, strformula1, strFormula2, False, "hlp_const_c_data_invalid")
End Sub


'*******************************************************************
'Bezahlte Stunden: obligatorisch und zwischen 0 und hlp_const_c_bezstundenmax
Sub set_validation_bezstunden(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_bezstunden")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)

  strFormula2 = "=hlp_const_c_bezstundenmax"
  With objRange.Validation
    .delete
    .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
      Operator:=xlBetween, Formula1:="0", _
      Formula2:=strFormula2
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  strformula1 = "=0"
  Call set_formatconditions_between(objRange, strformula1, strFormula2, False, "hlp_const_c_data_invalid")
End Sub


'*******************************************************************
'Bruttolohn, Zulagen, Sonderzahlungen: obligatorisch und zwischen 0 und hlp_const_c_bruttolohnmax
Sub set_validation_bl_so_zu(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long, _
  ByVal strspaltenbez As String)
  
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_" & strspaltenbez)
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  
  'SR Ab 12.07.2019 kein Maximallohn mehr
  'strFormula2 = "=hlp_const_c_bruttolohnmax"
  'SR Ab 26.01.2017 gibt es wegen der tschechischen Laenderversion (Faktor 25)
  'nur bei Schweizer Version harte Grenzen fuer Lohnbestandteile
  'If getLaenderversion = "ch" Then
    With objRange.Validation
      .delete
      .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
        Operator:=xlGreaterEqual, Formula1:="0"
        'Formula2:=strFormula2
      .IgnoreBlank = False
      .InCellDropdown = True
      .ShowInput = True
      .ShowError = True
    End With
  'End If
  strformula1 = "=0"
  'ab 3.0.7 nur noch hellorange
  Call set_formatconditions_einseitig(objRange, xlLess, strformula1, False, "hlp_const_c_data_invalid")
  If getLaenderversion = "ch" Then
    strFormula2 = "=hlp_const_c_bruttolohnmax"
    Call set_formatconditions_einseitig(objRange, xlGreater, strFormula2, False, "hlp_const_c_data_blank")
  End If
End Sub


'*******************************************************************
'13. Monatslohn: obligatorisch und zwischen 0 und hlp_const_c_13monatslohn_faktor * bruttolohn
Sub set_validation_13monatslohn(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_13monatslohn")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  '$-Zeichen ist fuer Excel 2007 notwendig, keine Klammer Obergrenze = 25%*Grundlohn + 1
  strFormula2 = "=hlp_const_c_13monatslohn_faktor*$" & funstrcol_byname("data_form_col_bruttolohn") & introwfirst
  With objRange.Validation
    .delete
    .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
      Operator:=xlBetween, Formula1:="0", _
      Formula2:=strFormula2
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  strformula1 = "=0"
  Call set_formatconditions_between(objRange, strformula1, strFormula2, False, "hlp_const_c_data_invalid")
End Sub


'*******************************************************************
'Standardisierter Gesamtverdienst: berechnet und zwischen hlp_const_c_gesverdienstmin und hlp_const_c_bruttolohnmax
Sub set_validation_gesverdienst(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_gesverdienst")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
'  strformula1 = "=hlp_const_c_gesverdienstmin"
'  strFormula2 = "=hlp_const_c_bruttolohnmax"
  'If getLaenderversion = "ch" Then
    With objRange.Validation
      .delete
      .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
        Operator:=xlGreater, Formula1:="0"
      .IgnoreBlank = False
      .InCellDropdown = True
      .ShowInput = True
      .ShowError = True
    End With
'  Else
'    'Darf nicht null sein wegen LN!
'    strformula1 = "=1"
'  End If
  'Call set_formatconditions_between(objRange, strformula1, strFormula2, False, "hlp_const_c_data_blank")
  strformula1 = "=0"
  Call set_formatconditions_einseitig(objRange, xlLessEqual, strformula1, False, "hlp_const_c_data_invalid")
  'Fuer Schweiz Warnung bei zu hohen Loehnen
  If getLaenderversion = "ch" Then
    strFormula2 = "=hlp_const_c_bruttolohnmax"
    Call set_formatconditions_einseitig(objRange, xlGreater, strFormula2, False, "hlp_const_c_data_blank")
  End If
End Sub


'*******************************************************************
'BUWAZ: positive Dezimalzahl
Sub set_validation_buwaz(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1 As String
  
  strCol = funstrcol_byname("data_form_col_buwaz")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)

  With objRange.Validation
        .delete
        .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, Operator _
        :=xlGreater, Formula1:="0"
        .IgnoreBlank = True
        .InCellDropdown = True
        .ShowInput = True
        .ShowError = True
  End With
  strformula1 = "=0"
  Call set_formatconditions_einseitig(objRange, xlLessEqual, strformula1, False, "hlp_const_c_data_invalid")
End Sub


'*******************************************************************
'Jahresarbeitszeit
Sub set_validation_jahresarbeitszeit(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_jahresarbeitszeit")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  'strformula1 = "=hlp_const_c_stundenlohn_anzstunden_min"
  With objRange.Validation
    .delete
    .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, _
      Operator:=xlGreater, Formula1:="0"
    .IgnoreBlank = False
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With

  'Call set_formatconditions_between(objRange, strformula1, strFormula2, False, "hlp_const_c_data_invalid")
  strformula1 = "=0"
  Call set_formatconditions_einseitig(objRange, xlLessEqual, strformula1, False, "hlp_const_c_data_invalid")
  strFormula2 = "=hlp_const_c_stundenlohn_anzstunden_max"
  Call set_formatconditions_einseitig(objRange, xlGreater, strFormula2, False, "hlp_const_c_data_blank")
End Sub


'*******************************************************************
'Validierung fuer Wochenarbeitszeit
'nur Versuch, nirgendwo aufgerufen
Sub val_wochenarbzeit(ByVal vartest As Variant, ByRef strfehlermsg As String, ByRef blnok As Boolean)
  blnok = False
  strfehlermsg = strtranslate("fehlermsg.1bis100")
  
  If IsNumeric(vartest) Then
    If CInt(vartest) = vartest And vartest >= 1 And vartest <= 100 Then
      blnok = True
      strfehlermsg = ""
    End If
  End If
End Sub

'*******************************************************************
'setzt alle Gueltigkeitspruefungen und bedingten Formatierungen
'aufgerufen in Hauptmodul.init_data_form
Sub set_all_validations(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  'Laufnummer: laufnr, Range ganze Zahl, obligatorisch
  Call set_validation_laufnr(objsheetdata, introwfirst, lngRowLast)
  'Geburtsjahr: gebjahr, Range ganze Zahl, obligatorisch
  Call set_validation_gebjahr(objsheetdata, introwfirst, lngRowLast)
  'Geschlecht: geschlecht, Liste, obligatorisch
  Call set_validation_list(objsheetdata, introwfirst, lngRowLast, "geschlecht", False)
  'Dienstjahre: dienstjahre, Range ganze Zahl, obligatorisch
  Call set_validation_dienstjahre(objsheetdata, introwfirst, lngRowLast)
  'Ausbildung: ausbildung, Liste, obligatorisch
  Call set_validation_list(objsheetdata, introwfirst, lngRowLast, "ausbildung", False)
  'Anforderungsniveau: anfniveau, Liste, obligatorisch V2.5
  Call set_validation_list(objsheetdata, introwfirst, lngRowLast, "anfniveau", False)
  'Berechnete Skilllevel: skillcalculated, Liste, obligatorisch V2.5, setzt nur bedingte Formatierung
  Call set_validation_list(objsheetdata, introwfirst, lngRowLast, "skillcalculated", False)
  'Berufliche Stellung: berstellung, Liste, obligatorisch
  Call set_validation_list(objsheetdata, introwfirst, lngRowLast, "berstellung", False)
  'Beschaeftigungsgrad: bgrad, Range Dezimalzahl, obligatorisch
  Call set_validation_bgrad(objsheetdata, introwfirst, lngRowLast)
  'Stundenlohn bezahlte Stunden: bezstunden, Range Dezimalzahl, obligatorisch
  Call set_validation_bezstunden(objsheetdata, introwfirst, lngRowLast)
  'Bruttolohn: bruttolohn,
  Call set_validation_bl_so_zu(objsheetdata, introwfirst, lngRowLast, "bruttolohn")
  'Zulagen: zulagen,
  Call set_validation_bl_so_zu(objsheetdata, introwfirst, lngRowLast, "zulagen")
  '13. Monatslohn: 13monatslohn,
  Call set_validation_13monatslohn(objsheetdata, introwfirst, lngRowLast)
  'Sonderzahlungen: sonderz,
  Call set_validation_bl_so_zu(objsheetdata, introwfirst, lngRowLast, "sonderz")
  'Gesamtverdienst
  Call set_validation_gesverdienst(objsheetdata, introwfirst, lngRowLast)
  'Buwaz
  Call set_validation_buwaz(objsheetdata, introwfirst, lngRowLast)
  'Soll-Jahresarbeitszeit
  Call set_validation_jahresarbeitszeit(objsheetdata, introwfirst, lngRowLast)
  'Grundgesamtheit
  Call set_validation_list(objsheetdata, introwfirst, lngRowLast, "grundgesamtheit", True)
  
  'Texte aendert (separat fuer spaeteren Sprachwechsel)
  Call change_all_validations(introwfirst, lngRowLast)
  
  'Wiedereingabe der Formel fuer Filter: Notwendig fuer Berechnung (wird nicht automatisch neu berechnet)
  objsheetdata.Range(funstrcol_byname("data_form_col_filter_erw") & introwfirst).Formula = _
    objsheetdata.Range(funstrcol_byname("data_form_col_filter_erw") & introwfirst).Formula
End Sub


'*******************************************************************
'Wechselt bei einem nachtraeglichen Sprachwechsel
'die Sprache der Validierung fuer eine Spalte
Sub change_validation_of_a_col(ByVal strcolname As String, _
  ByVal introwfirst As Integer, ByVal lngRowLast As Long, _
  ByVal strinputtitle As String, ByVal strerrortitle As String, _
  ByVal strinputmessage As String, ByVal strerrormessage As String)

  Dim objRange As Range
  Dim strCol As String
  
  strCol = funstrcol_byname(strcolname)

  Set objRange = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
    strCol & introwfirst & ":" & strCol & lngRowLast)

  If funblnvalidationexists(objRange) Then
    With objRange.Validation
      .InputTitle = Left(strinputtitle & String(BYT_MAXLENGTH_TITLE, " "), BYT_MAXLENGTH_TITLE)
      .ErrorTitle = Left(strerrortitle & String(BYT_MAXLENGTH_TITLE, " "), BYT_MAXLENGTH_TITLE)
      .InputMessage = Left(strinputmessage, BYT_MAXLENGTH_INPMSG)
      .ErrorMessage = Left(strerrormessage, BYT_MAXLENGTH_ERRMSG)
    End With
  End If
End Sub


'*******************************************************************
'Gueltigkeitspruefung mit Liste
'  Kommentar zu Benennungen siehe set_validation_list
'Argumente
' - introwfirst: erste Zeile
' - lngrowlast: letzte Zeile
' - strspaltenbez: Bezeichnung der Spalte
' - optional sheetname: Blattname (Achtung fuer Texte immer auf data_form)
Sub change_validation_list(ByVal introwfirst As Integer, ByVal lngRowLast As Long, _
  ByVal strspaltenbez As String, Optional ByVal sheetname As String = STR_SH_DATA_FORM)
  
  
  Dim objRange, objCell As Range
  Dim strText As String
  Dim strtextvalgueltig As String
  Dim strtitel As String
  strText = strtranslate("data_form.valhlp" & strspaltenbez)
  strtextvalgueltig = strtranslate("data_form.valgueltig")
  
  Dim strCol As String
  strCol = funstrcol_byname(sheetname & "_col_" & strspaltenbez)
  
  Set objRange = ThisWorkbook.Sheets(sheetname).Range( _
    strCol & introwfirst & ":" & strCol & lngRowLast)
  
  If funblnvalidationexists(objRange) Then
    'nicht aktiviert, da das Problem nur auftritt, wenn in Windows Schriftgroesse > 100%
'    If strspaltenbez = "ausbildung" Then
'      For Each objcell In objrange.Cells
'        objcell.ClearComments
'        objcell.AddComment
'        objcell.Comment.Visible = False
'        objcell.Comment.Text Text:=strtranslate("data_form.lbl" & strspaltenbez) _
'          & Chr(10) & strtext, Start:=200
'        objcell.Comment.Shape.Width = 200
'        objcell.Comment.Shape.Height = 120
'        objcell.Comment.Shape.TextFrame.Characters(1).Font.Bold = True
'        objcell.Comment.Shape.TextFrame.Characters( _
'          Len(strtranslate("data_form.lbl" & strspaltenbez)) + 1).Font.Bold = False
'      Next
'    End If


    With objRange.Validation
    'nicht aktiviert, da das Problem nur auftritt, wenn in Windows Schriftgroesse > 100%
'      If strspaltenbez = "ausbildung" Then
'        .InputTitle = ""
'        .InputMessage = ""
'      Else
        .InputTitle = Left(strtranslate("data_form.lbl" & strspaltenbez) & String(BYT_MAXLENGTH_TITLE, " "), BYT_MAXLENGTH_TITLE)
        .InputMessage = Left(strText, BYT_MAXLENGTH_INPMSG)
'      End If
      .ErrorTitle = Left(strtranslate("data_form.valungueltig") & String(BYT_MAXLENGTH_TITLE, " "), BYT_MAXLENGTH_TITLE)
      If Len(strtextvalgueltig & strText) < BYT_MAXLENGTH_ERRMSG Then
        .ErrorMessage = strtextvalgueltig & vbCrLf & strText
      Else
        .ErrorMessage = strtextvalgueltig & vbCrLf & _
          Application.WorksheetFunction.Min( _
          ThisWorkbook.Names("hlp_const_vec_" & strspaltenbez).RefersToRange) & _
          " " & strtranslate("data_form.valbis") & " " & _
          Application.WorksheetFunction.Max( _
          ThisWorkbook.Names("hlp_const_vec_" & strspaltenbez).RefersToRange)
      End If
    End With
  End If
End Sub


'*******************************************************************
'Bruttolohn, Zulagen, Sonderzahlungen
Sub change_validation_bl_so_zu(ByVal introwfirst As Integer, ByVal lngRowLast As Long, _
  ByVal strspaltenbez As String)
  
  Dim objRange As Range
  Dim strCol As String
  Dim strmsg As String
  
  strCol = funstrcol_byname("data_form_col_" & strspaltenbez)
  Set objRange = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
    strCol & introwfirst & ":" & strCol & lngRowLast)
  
  
'  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & " 0 " & _
'    strtranslate("data_form.valbis") & " " & _
'    Format(funvarvalue_byname("hlp_const_c_bruttolohnmax"), "#,##0.00")
  'Ab 12.07.2019 nur noch positive Dezimalzahl oder 0
  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valpositivedezimalzahlodernull")
  If funblnvalidationexists(objRange) Then
    With objRange.Validation
      .InputTitle = Left(strtranslate("data_form.lbl" & strspaltenbez), BYT_MAXLENGTH_TITLE)
      .ErrorTitle = Left(strtranslate("data_form.valungueltig"), BYT_MAXLENGTH_TITLE)
      .InputMessage = Left(strmsg, BYT_MAXLENGTH_INPMSG)
      .ErrorMessage = Left(strmsg, BYT_MAXLENGTH_ERRMSG)
    End With
  End If
End Sub


'*******************************************************************
'Wechselt bei einem nachtraeglichen Sprachwechsel
'  die Sprache der Validierung fuer alle Spalten
Sub change_all_validations(ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim strmsg As String
  
  'Laufnummer: laufnr, Range ganze Zahl, obligatorisch
  Call change_validation_of_a_col( _
    "data_form_col_laufnr", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lbllaufnr"), _
    strtranslate("data_form.valungueltig"), _
    strtranslate("data_form.valhlplaufnr"), _
    strtranslate("data_form.valhlplaufnrerr"))
  
  'Geburtsjahr: gebjahr, Range ganze Zahl, obligatorisch
  'Ab 3.0.7 -1 und +1 entfernt, da von 14 bis 99
  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valganzzahl") & " " & _
    (funvarvalue_byname("data_head_c_jahr") - funvarvalue_byname("hlp_const_c_altermax")) & _
    " " & strtranslate("data_form.valbis") & " " & _
    (funvarvalue_byname("data_head_c_jahr") - funvarvalue_byname("hlp_const_c_altermin"))
  Call change_validation_of_a_col( _
    "data_form_col_gebjahr", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lblgebjahr"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strmsg)
  
  'Geschlecht: geschlecht, Liste, obligatorisch
  Call change_validation_list(introwfirst, lngRowLast, "geschlecht")
  
  
  'Dienstjahre: dienstjahre, Range ganze Zahl, obligatorisch
  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & " 0 " & _
    strtranslate("data_form.valbis") & " " & _
    (funvarvalue_byname("hlp_const_c_altermax") - funvarvalue_byname("hlp_const_c_altermin"))
  Call change_validation_of_a_col( _
    "data_form_col_dienstjahre", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lbldienstjahre"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strmsg)
  

  'Ausbildung: ausbildung, Liste, obligatorisch
  Call change_validation_list(introwfirst, lngRowLast, "ausbildung")
  
  'Anforderungsniveau: anfniveau, Liste, nicht obligatorisch ab V2.5
  Call change_validation_list(introwfirst, lngRowLast, "anfniveau")
  
  'Berufliche Stellung: berstellung, Liste, obligatorisch
  Call change_validation_list(introwfirst, lngRowLast, "berstellung")
    
  'Beschaeftigungsgrad: bgrad, Range Dezimalzahl, obligatorisch
  'Ab 3.0.7 strmsg ergaenzt mit entweder bgrad oder bezstunden
  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & " 0 " & _
    strtranslate("data_form.valbis") & " " & _
    funvarvalue_byname("hlp_const_c_bgradmax") & funStrNewline & strtranslate("data_form.valbgrad")
  Call change_validation_of_a_col( _
    "data_form_col_bgrad", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lblbgrad_k"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strmsg)
  
  'Stundenlohn bezahlte Stunden: bezstunden, Range Dezimalzahl, obligatorisch
  'Ab 3.0.7 strmsg ergaenzt mit entweder bgrad oder bezstunden
  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & " 0 " & _
    strtranslate("data_form.valbis") & " " & _
    funvarvalue_byname("hlp_const_c_bezstundenmax") & funStrNewline & strtranslate("data_form.valbgrad")
  Call change_validation_of_a_col( _
    "data_form_col_bezstunden", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lblbezstunden_k"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strmsg)
    
  'Bruttolohn: bruttolohn,
  Call change_validation_bl_so_zu(introwfirst, lngRowLast, "bruttolohn")
  
  'Zulagen: zulagen,
  Call change_validation_bl_so_zu(introwfirst, lngRowLast, "zulagen")
  
  '13. Monatslohn: 13monatslohn,
  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & " 0 " & _
    strtranslate("data_form.valbis") & " " & _
    funvarvalue_byname("hlp_const_c_13monatslohn_faktor") & " * " & strtranslate("data_form.lblbruttolohn")
  Call change_validation_of_a_col( _
    "data_form_col_13monatslohn", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lbl13monatslohnkurz"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strtranslate("data_form.valhlp13monatslohn"))
  
  
  'Sonderzahlungen: sonderz,
  Call change_validation_bl_so_zu(introwfirst, lngRowLast, "sonderz")
  
  'Gesamtverdienst
'  strmsg = strtranslate("data_form.valhlpgesverdienst") & _
'    strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & " " & _
'    funvarvalue_byname("hlp_const_c_gesverdienstmin") & " " & _
'    strtranslate("data_form.valbis") & " " & _
'    Format(funvarvalue_byname("hlp_const_c_bruttolohnmax"), "#,##0.00")
  strmsg = strtranslate("data_form.valgueltig") & " " & _
    strtranslate("data_form.valposzahl")
  Call change_validation_of_a_col( _
    "data_form_col_gesverdienst", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lblgesverdienst_k"), _
    "", _
    strmsg, "")
    
  'Buwaz
  Call change_validation_of_a_col( _
    "data_form_col_buwaz", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lbluebarbzeit_k"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strmsg)
  
  'data_form_col_jahresarbeitszeit
'  strmsg = strtranslate("data_form.valgueltig") & " " & strtranslate("data_form.valdezimalzahl") & _
'    " " & funvarvalue_byname("hlp_const_c_stundenlohn_anzstunden_min") & " " & _
'    strtranslate("data_form.valbis") & " " & _
'    funvarvalue_byname("hlp_const_c_stundenlohn_anzstunden_max")
  Call change_validation_of_a_col( _
    "data_form_col_jahresarbeitszeit", _
    introwfirst, lngRowLast, _
    strtranslate("data_form.lbljahresarbeitszeit_k"), _
    strtranslate("data_form.valungueltig"), _
    strmsg, strmsg)
    
  'data_form_col_grundgesamtheit
  Call change_validation_list(introwfirst, lngRowLast, "grundgesamtheit")
  

End Sub


'*******************************************************************
'Wechselt bei einem nachtraeglichen Sprachwechsel die Sprache
Sub changevalidationlang()
  Call updateActiveProc("Validierung.changevalidationlang")
  
  Dim blnprotectcontents As Boolean
  Dim blnscreenupdating As Boolean
  Dim blnenableevents As Boolean
  Dim intRowDatastart As Integer
  Dim lnglastfilledrow As Long
  Dim stractivesheet As String
  blnprotectcontents = False
  
  'Ist Blatt data_form sichtbar =
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Visible Then
    'Start- und Endzeile des Datenbereichs bestimmen
    intRowDatastart = _
      ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
    lnglastfilledrow = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_DATA_FORM, _
      funstrcol_byname("data_form_col_laufnr"))
    
    'Ist Blatt bereits aufbereitet?
    If lnglastfilledrow > intRowDatastart Then
      blnscreenupdating = Application.ScreenUpdating
      Application.ScreenUpdating = False
      blnenableevents = Application.EnableEvents
      Application.EnableEvents = False
      stractivesheet = ThisWorkbook.ActiveSheet.name
      ThisWorkbook.Sheets(STR_SH_DATA_FORM).Activate
      
      'Blattschutz aufheben
      If ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents Then
        blnprotectcontents = True
        ThisWorkbook.Sheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
      End If
      
      'ab Logib 3.1.1 zuerst Filter aufheben
      Call isResetAllFiltersOk(ThisWorkbook.name, STR_SH_DATA_FORM)
      
      'nimmt alle Zellen, nicht nur die ausgefuellten
      lnglastfilledrow = ThisWorkbook.Sheets(STR_SH_DATA_FORM) _
        .Range(STR_DATA_FORM_SD).SpecialCells(xlLastCell).Row
      
      'Validierungen setzen
      Call change_all_validations(intRowDatastart, lnglastfilledrow)
      
      'Blattschutz wieder aktivieren, falls vorher bereits vorhanden
      Call protectSheet(STR_SH_DATA_FORM, blnprotectcontents)
      
      ThisWorkbook.Sheets(stractivesheet).Activate

      Application.ScreenUpdating = blnscreenupdating
      Application.EnableEvents = blnenableevents
    End If 'lnglastfilledrow > introwdatastart
    
  End If 'ThisWorkbook.Sheets(STR_SH_DATA_FORM).Visible
  
End Sub


'*******************************************************************
'Formatiert eine Zelle im data_form, welche die Gueltigkeitspruefung nicht erfuellt
'Blattschutz muss aufgehoben sein
'aufgerufen von format_invalid_range
Sub format_invalid_cell(ByRef objCell As Range)
  'SR 12/2006 Static statt Dim
  Static intcolor As Integer
  
  If intcolor = 0 Then
    intcolor = funvarvalue_byname("hlp_const_c_data_invalid")
  End If
  
  If objCell.Validation.Value = False Then
    With objCell.Interior
      .Color = intcolor
      .Pattern = xlSolid
    End With
  Else
    objCell.Interior.Color = xlNone
  End If
End Sub


'*******************************************************************
'Formatiert alle Zellen im data_form, welche die Gueltigkeitspruefung nicht erfuellen
'Blatt muss sichtbar sein
Sub format_invalid_range(ByRef objRange As Range)
  Dim blnprotectcontents As Boolean
  Dim objCell As Range
  
  'Debug.Print "Validierung.format_invalid_range fuer " & objrange.Address(False, False)
  
  'Blattschutz aufheben
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents Then
    blnprotectcontents = True
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
  End If
  
  'Alle Zellen abarbeiten
  For Each objCell In objRange.Cells
    Call format_invalid_cell(objCell)
  Next
  
  'Blattschutz wieder aktivieren, falls vorher bereits vorhanden
  Call protectSheet(STR_SH_DATA_FORM, blnprotectcontents)
  
End Sub


'*******************************************************************
'Kopiert die Werte eines Ranges auf sich selbst -> loest Validierung aus
'aufgerufen in Validierung.format_all_invalid_cells
Sub copyRangeToItself(ByVal objRange As Range)
  objRange.Copy
  'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
   ThisWorkbook.Sheets(objRange.Worksheet.name).Paste (objRange.Cells(1, 1))
  
  Application.CutCopyMode = False
End Sub


'*******************************************************************
'Formatiert alle Zellen im data_form, welche die Gueltigkeitspruefung nicht erfuellen
'Ersetzt die 2. Bedingung beim Conditional Formatting
'Kopiert den Range auf sich selbst, um Neuberechnung der Spalten V und W auszuloesen
Sub format_all_invalid_cells()
  Dim introwfirst As Integer
  Dim lngRowLast As Long
  Dim objRange As Range
  
  'Ist Blatt data_form sichtbar =
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Visible Then
    'Datenbereich bestimmen
    introwfirst = _
      ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
    lngRowLast = funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_DATA_FORM, _
      funstrcol_byname("data_form_col_laufnr"))
    
    Set objRange = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
        funstrcol_byname("data_form_col_laufnr") & introwfirst & ":" & _
        funstrcol_byname("data_form_col_buwaz") & lngRowLast)
        'funstrcol_byname("data_form_col_gesverdienst") & lngrowlast)
    
    Call copyRangeToItself(objRange)
    Call format_invalid_range(objRange)
  End If
  
End Sub


'*******************************************************************
'testet Validierung.set_all_validations
Private Sub test_validation()
  Call set_all_validations(ThisWorkbook.Sheets(STR_SH_DATA_FORM), 16, 65)
  'Call set_validation_list(ThisWorkbook.Sheets(STR_SH_DATA_FORM), 16, 65, "ausbildung", False)
  'Call set_validation_laufnr(ThisWorkbook.Sheets(STR_SH_DATA_FORM), 16, 65)
End Sub

Attribute VB_Name = "verweismanagement"
Option Explicit

'===================================================================
'Routinen zum Laden und Entladen von Bibliotheken wegen verschiedener Outlook-Versionen
'Diese Routinen werden nicht verwendet


'*******************************************************************
'Prozedur zum dynamischen Laden oder Entladen von Verweisen
'Achtung: Dynamisches Laden von Verweisen geht unter XP und 2003 nur mit Einstellung
'Extras - Makro - Sicherheit - Register Vertrauenswuerdige Quellen - Zugriff auf Visual Basic Projekt vertrauen
'Achtung2: Pfad wird nur unter ExcelXP gefunden!
Sub verweisladenoderentladen(ByVal strguid As String, ByVal blnladen As Boolean)
  Dim blnfound As Boolean

  Dim objvorhandeneverweise As Object
  Dim objverweis As Object
  Dim strName As String

  Set objvorhandeneverweise = ThisWorkbook.VBProject.References

  For Each objverweis In objvorhandeneverweise
    'Verweis vorhanden?
    If UCase(objverweis.GUID) = UCase(strguid) Then
      blnfound = True
      strName = objverweis.name
      Exit For
    End If
  Next
  ' Wenn der Verweis noch nicht gesetzt ist...
  If blnfound Then
    'Entladen
    If Not blnladen Then
      objvorhandeneverweise.Remove objvorhandeneverweise(strName)
    End If
  Else
    'Laden
    If blnladen Then
      'objvorhandeneverweise.AddFromFile strdateiname
      'hinter GUID kommt Major und Minor (scheinen aufwaertskompatibel zu sein)
      objvorhandeneverweise.AddFromGuid strguid, 1, 0
    End If
  End If

End Sub


'*******************************************************************
'Testet das Laden und ev. entladen von Modulen
Private Sub testverweiseladen()
  Const STR_DATEINAME As String = "msoutl.olb"
  Const STR_VERWEISNAME As String = "Outlook"
  Const STR_GUID_OUTLOOK As String = "{00062FFF-0000-0000-C000-000000000046}"
  
  'OLE
  'Name:   stdole
  'Pfad: F:\WINNT\system32\stdole2.tlb
  'GUID: {00020430-0000-0000-C000-000000000046}
  Const STR_GUID_OLE As String = "{00020430-0000-0000-C000-000000000046}"
  'Call verweisladenoderentladen(STR_GUID_OLE, True)
  'MsgBox ("OLE geladen")
  
  'Office
  'Bezeichnung: Microsoft Office 9.0 Object Library
  'Name: Office
  'Pfad: F:\Programme\office\office2000\Office\MSO9.DLL
  'GUID: {2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}
  'Major: 2
  'Minor: 1
  'Standard -Verweis: Falsch
  Const STR_GUID_OFFICE As String = "{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}"
  Call verweisladenoderentladen(STR_GUID_OFFICE, True)
  MsgBox ("Microsoft Office Library geladen")




  'Call verweisladenoderentladen(STR_GUID_OUTLOOK, True)
  'MsgBox ("Outlook geladen")
  'Call verweisladenoderentladen(STR_GUID_OUTLOOK, False)
  'MsgBox ("Outlook entaden")
  
End Sub


'*******************************************************************
'Zeigt die vorhandenen Verweise an
Private Sub vorhandeneverweise()
  Const BLN_ALLES As Boolean = False
  Dim objvorhandeneverweise As Object
  Dim objverweis As Object
  Dim strTemp As String
  
  Set objvorhandeneverweise = ThisWorkbook.VBProject.References

  'debug.print Application.Name & " " & Application.Version
  For Each objverweis In objvorhandeneverweise
    strTemp = "Bezeichnung: " & objverweis.Description
    If BLN_ALLES Then
      strTemp = vbCrLf & "Bezeichnung: " & objverweis.Description & vbCrLf
      strTemp = strTemp & "Name: " & objverweis.name & vbCrLf
      strTemp = strTemp & "Pfad: " & objverweis.FullPath & vbCrLf
      strTemp = strTemp & "GUID: " & objverweis.GUID & vbCrLf
      strTemp = strTemp & "Major: " & objverweis.Major & vbCrLf
      strTemp = strTemp & "Minor: " & objverweis.Minor & vbCrLf
      strTemp = strTemp & "Standard-Verweis: " & objverweis.BuiltIn & vbCrLf
    End If
    'debug.print strTemp
  Next

  Set objvorhandeneverweise = Nothing
  On Error GoTo 0
End Sub
Attribute VB_Name = "zzz_archiv"
Option Explicit
Option Private Module

Public Const STR_HLP_EXPORT_LINK_BEREITSTELLEN = "M22" 'Fuer Export-Formular(e)
Public Const STR_HLP_EXPORT_LINK_STARTEN = "M25"
Public Const STR_HLP_EXPORT_LINKS_LABELS = "B41:Q41"

'===================================================================
'Makros, die nicht mehr in Gebrauch sind


'*******************************************************************
'Bei manueller Ueberarbeitung werden nach bestaetigter Warnung die
'Regressionsdaten geloescht und Auswertungen wieder ausgeblendet
'Funktioniert unter Excel 2010 nicht mit dem Feld data_head_c_monat (Gueltigkeitspruefung mit Liste)
'Achtung bei rueckgaengig gemachter Aenderung durch Gueltigkeitspruefung
'Ab Version V3 2016 ist nach Auswertung data_head und data_form ohnehin gesperrt
'vorher hinter Tabelle17 (data_head)
Private Sub Worksheet_Change_alt(ByVal Target As Range)
  On Error GoTo fehler
  
  Call updateActiveProc("Tabelle17.Worksheet_Change")
  
  Dim blnChange
  Dim strcolbuwaz
  Dim strcolanzstunden As String
  Dim introwfirst
  Dim lngRowLast
  
  If Not blnNichtFreigegeben Then 'Function in Modul Hilfsmakros
    Exit Sub
  End If

  Application.EnableEvents = False
  'Application.ScreenUpdating = False
  
  'Sind bereits Daten vorhanden
  If funlnglastfilledrowincol(ThisWorkbook.name, STR_SH_DATA_FORM, _
    funstrcol_byname("data_form_col_laufnr")) - _
    ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row + 1 > 0 Then
    'Nur Zellen mit Jahr, Anzahl Mitarbeitern und Stunden sind wichtig
    If Not (Application.Intersect(Target, Application.Names("data_head_c_jahr").RefersToRange) Is Nothing) _
      Or Not (Application.Intersect(Target, Application.Names("data_head_c_buwaz").RefersToRange) Is Nothing) _
      Or Not (Application.Intersect(Target, Application.Names("data_head_c_anzmitarb").RefersToRange) Is Nothing) _
      Or Not (Application.Intersect(Target, Application.Names("data_head_c_stundenlohn_jn").RefersToRange) Is Nothing) _
      Or Not (Application.Intersect(Target, Application.Names("data_head_c_stundenlohn_anzstunden").RefersToRange) Is Nothing) _
      Then
      
      blnChange = True
      'Nachfragen nur, wenn Auswertung vorhanden
      If funvarvalue_byname("hlp_const_c_ausgewertet") = True Then
        If MsgBox(strtranslate("msgbox_data_form.delausw"), vbOKCancel) = vbCancel Then
          'Ist ueberhaupt etwas rueckgaengig zu machen?
          If Application.CommandBars.FindControl(ID:=128).Enabled = True Then
            blnChange = False
            Application.Undo
          End If
        End If
      End If
      If blnChange Then
        'Update Buwaz -> Werte neu eintragen 10.12.2008
        If Not (Application.Intersect(Target, Application.Names("data_head_c_buwaz").RefersToRange) Is Nothing) Then
          If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Visible = True Then
            If MsgBox(strtranslate("msgbox_data_form.changebuwaz"), vbExclamation + vbYesNo) = vbNo Then
              'Ist ueberhaupt etwas rueckgaengig zu machen?
              If Application.CommandBars.FindControl(ID:=128).Enabled = True Then
                blnChange = False
                Application.Undo
              End If
            Else
              strcolbuwaz = funstrcol_byname("data_form_col_buwaz")
              introwfirst = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
              lngRowLast = funlnglastfilledrowinnamedcol("data_form_col_buwaz")
              ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
                strcolbuwaz & introwfirst & ":" & strcolbuwaz & lngRowLast).Value = _
                funvarvalue_byname("data_head_c_buwaz")
            End If
          End If
        End If
        
        'Update Soll-Jahresarbeitszeit -> Werte neu eintragen ab Logib 2.5 14.01.2016
        If Not (Application.Intersect(Target, Application.Names("data_head_c_stundenlohn_anzstunden").RefersToRange) Is Nothing) Then
          If ThisWorkbook.Sheets(STR_SH_DATA_FORM).Visible = True Then
            If MsgBox(strtranslate("msgbox_data_form.anzstunden"), vbExclamation + vbYesNo) = vbNo Then
              'Ist ueberhaupt etwas rueckgaengig zu machen?
              If Application.CommandBars.FindControl(ID:=128).Enabled = True Then
                blnChange = False
                Application.Undo
              End If
            Else
              strcolanzstunden = funstrcol_byname("data_form_col_jahresarbeitszeit")
              introwfirst = ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range(STR_DATA_FORM_SD).Row
              lngRowLast = funlnglastfilledrowinnamedcol("data_form_col_jahresarbeitszeit")
              ThisWorkbook.Sheets(STR_SH_DATA_FORM).Range( _
                strcolanzstunden & introwfirst & ":" & strcolanzstunden & lngRowLast).Value = _
                funvarvalue_byname("data_head_c_stundenlohn_anzstunden")
            End If
          End If
        End If
        
        'Hier kommen Aenderungen
        'Auswertungen zuruecksetzen nur, falls bereits Auswertungen vorhanden sind
        If funvarvalue_byname("hlp_const_c_ausgewertet") = True Then
          Call data_sheet_update
          Call updateActiveProc("Tabelle17.Worksheet_Change after data_sheet_update")
        End If
        'Validierungstexte anpassen
        Call changevalidationlang
        Call updateActiveProc("Tabelle17.Worksheet_Change after changevalidationlang")
        'Formatierung fuer invalid Werte anpassen
        If Not BLN_FORMATCONDITIONS_FORMULA Then
          Call format_all_invalid_cells
        End If
      End If 'blnChange
    End If 'Application.Intersect(
  End If 'funlnglastfilledrowincol

fehler:
  Application.EnableEvents = True
  Application.ScreenUpdating = True
End Sub


'*******************************************************************
'Dateneingabe auf Tabellenblatt data_head
'nicht mehr in Gebrauch ab 2.5 von 2016
'vorher hinter: sheet_data_form
Private Sub btninputtable_Click()
  On Error GoTo fehler
  Call updateActiveProc("Tabelle17.btninputtable_Click")
 
  If Not blnNichtFreigegeben Then 'Function in Modul Hilfsmakros
    Exit Sub
  End If

  If funanzmitarb() = 0 Then
    MsgBox (strtranslate("fehler.msg.mitarbeingeben"))
    ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Select
  ElseIf CInt(funvarvalue_byname("data_head_c_jahr")) <= 0 Then
    MsgBox (strtranslate("fehler.msg.jahreingeben"))
    ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Select
  ElseIf CSng(funvarvalue_byname("data_head_c_buwaz")) <= 0 Then
    MsgBox (strtranslate("fehler.msg.buwazeingeben"))
    ThisWorkbook.Names("data_head_c_buwaz").RefersToRange.Select
  Else
    Call berechnung_ausschalten
    'Call blatt_einblenden(STR_SH_DATA_FORM, changeToNumberString("m"))
    'Vorgehen speichern
    ThisWorkbook.Names("hlp_const_c_vorgehen").RefersToRange.Value = "Manuell"
    Application.EnableEvents = False
    Call init_laufnr
    Call init_data_form
    Application.EnableEvents = True
    Call berechnung_einschalten
  End If
  Exit Sub
  
fehler:
  Call senderrormail(straktiveprozedur)
  Resume Next
End Sub

'*******************************************************************
'Bei der ersten manuellen Ueberarbeitung nach vorhandenen Auswertungen
'wird eine Warnmeldung eingeblendet, dass man die Auswertung wieder neu starten soll
'Ab Version V3 2016 ist nach Auswertung data_head und data_form ohnehin gesperrt
'vorher hinter Tabelle12 (data_form)
Private Sub data_form_Worksheet_Change_alt(ByVal Target As Range)
  On Error GoTo fehler
  Call updateActiveProc("Tabelle12.Worksheet_Change")
  'Application.Wait Now + TimeValue("00:00:01")

  'Debug.Print "Tabelle12.Worksheet_Change gestartet, Range " & Target.Address(False, False)
  'Wenn mehr als 1 Zelle geaendert oder geloescht wird, dann automatisch zuruecksetzen
  If Target.Cells.Count > 1 Then
    Application.ScreenUpdating = False
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).EnableCalculation = False
    
    'Damit Ueberarbeitung des Blatts kein erneutes Event ausloest
    Application.EnableEvents = False
    
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Calculate
    Call data_sheet_update
    
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).EnableCalculation = True
  Else
    If Not blnNichtFreigegeben Then 'Function in Modul Hilfsmakros
      Exit Sub
    End If
    
    Dim newvalue, oldvalue As Variant
    
    'Das Change-Ereignis funktioniert nur unter Windows 2000 halbwegs richtig
    ' -> fuer XP und 2003 abgestellt
    If funvarvalue_byname("hlp_const_c_ausgewertet") = True _
      And funvarvalue_byname("hlp_const_c_usersicht") = True Then
      'And Application.version < 10 Then '(nicht mehr noetig)
          
      Application.ScreenUpdating = False
      ThisWorkbook.Worksheets("data_form").EnableCalculation = False
      
      'Damit Ueberarbeitung des Blatts kein erneutes Event ausloest
      Application.EnableEvents = False
      
      'Es wird auf jeden Fall ein Undo ausgeloest, um den alten und neuen Wert zu haben
      newvalue = Target.Value
      'Es wird auf jeden Fall zurueckgesetzt, um alten und neuen Wert zu haben
      If Application.CommandBars.FindControl(ID:=128).Enabled = True Then
        Application.Undo
      End If
      oldvalue = Target.Value
      'Ev. wurde Wert schon durch Gueltigkeitspruefung zurueckgesetzt
      If newvalue <> oldvalue Then
        If MsgBox(strtranslate("msgbox_data_form.delausw"), vbOKCancel) = vbCancel Then
          Target.Value = oldvalue
        Else
          'Hier kommen Aenderungen
          Target.Value = newvalue
          ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Calculate
          Call data_sheet_update
        End If
      End If 'newvalue <> oldvalue
    'Else
      'neu am 25.09.2013 wegen nicht funktionierenden Ereignissen in Excel 2007
     ' If blnausgewertet = True Then 'siehe ConstVarPublic
     '   Call MsgBox(strtranslate("msgbox_data_form.delauswneu"), vbOKOnly)
     '   blnausgewertet = False
    '  End If
    End If 'funvarvalue_byname
    
    'Call format_invalid_range(Target)
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).EnableCalculation = True
  End If
  
  Exit Sub

fehler:
  Dim strmeldung As String
  strmeldung = "Target " & Target.Address(False, False)

  'Debug.Print "Prozedur " & straktiveprozedur & " " & strmeldung & vbCrLf & _
  '  "Fehler-Nr.: " & Err.Number & vbCrLf & Err.Description & vbCrLf & "Quelle: " & Err.Source
  Application.ScreenUpdating = True
  ThisWorkbook.Worksheets("data_form").EnableCalculation = True
  Application.EnableEvents = True
  Resume Next
  
End Sub


'*******************************************************************
'Datenbereich auf Blatt data_form erweitern
'ab Logib 2.5 nicht mehr verwendet
'vorher im Modul sheet_data_form
Private Sub btndatenbereicherweitern_Click()
  On Error GoTo fehler
  Call updateActiveProc("Tabelle12.btndatenbereicherweitern_Click")
  
  'freigegebene Arbeitsmappen koennen nicht bearbeitet werden
  If Not blnNichtFreigegeben Then 'Function in Modul Hilfsmakros
    Exit Sub
  End If
  
  Dim lngdatarowanzneu 'As Long nicht moeglich, Abbrechen erzeugt ""
  Dim lngdatarowanzbisher As Long
  Dim lngdatarownext As Long
  Dim lngdatarowfirst As Long
  Dim lnglaufnr As Long
  Dim blnmitlaufnr As Boolean

  Dim objstartcell As Range
  'Dim objstartcellfix As Range
  Dim varinputbox
  
  'User/in Zahl eingeben lassen
  lngdatarowanzneu = InputBox(strtranslate("data_form.msg.datenbereich"))

  'Eingabe ueberpruefen
  If Not IsNumeric(lngdatarowanzneu) Then
    MsgBox (strtranslate("fehlermsg.ganzzahl"))
  Else
    If lngdatarowanzneu > 0 Then
      Application.EnableEvents = False
      Call berechnung_ausschalten
  
      ThisWorkbook.Sheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
      
      'Startzelle bestimmen
      lngdatarowfirst = Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
        .Range(STR_DATA_FORM_SD).Row
      lngdatarownext = funlnglastfilledrow() + 1
      If lngdatarownext > lngdatarowfirst Then
        lngdatarowanzbisher = lngdatarownext - lngdatarowfirst
      Else
        lngdatarownext = lngdatarowfirst
        lngdatarowanzbisher = 0
      End If
      Set objstartcell = Workbooks(ThisWorkbook.name).Sheets(STR_SH_DATA_FORM) _
        .Range(funstrcol_byname("data_form_col_laufnr") & lngdatarownext)
      
      'Set objstartcellfix = objstartcell
      
      'Ab 22.10.2014 wird Laufnr nicht mehr ausgefuellt -> keine Verfaelschung der Anzahl
      
      'Anzahl Mitarbeiter temporaer eintragen
      ' init_data_form nimmt diese Zahl + Marge
      lnganzmitarbvorher = ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value
      ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value = _
        lngdatarowanzbisher + lngdatarowanzneu - INT_MARGE
        
      'format_all_invalid_cells wird in init_data_form aufgerufen
      Call init_data_form
      
      'Mitarbeiterzahl = vorher eingetragene Zahl + neue Zeilen
      ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Value = _
        lnganzmitarbvorher + lngdatarowanzneu

      'Schutz wieder einschalten
      Call protectSheet(STR_SH_DATA_FORM, True)
      
      Call berechnung_einschalten
      Application.EnableEvents = True
      
    End If
  End If

  Exit Sub

fehler:
  Debug.Print "Fehler in btndatenbereicherweitern_Click "

  'Debug.Print "Prozedur " & straktiveprozedur & " " & strmeldung & vbCrLf & _
  '  "Fehler-Nr.: " & Err.Number & vbCrLf & Err.Description & vbCrLf & "Quelle: " & Err.Source
  Call restore
End Sub


'*******************************************************************
'Gibt die Zeile und Spalte der letzten Zelle im Usedrange an
'nicht mehr verwendet ab 06.01.2016 wegen Fehlern beim Import,
'wenn in Importdateien leere, aber formatierte zusaetzliche Spalten vorhanden
'vorher: Modul DatenAusMappe
Sub lastcolandrow_alt(ByVal strWorkbookName As String, ByVal strSheetName As String, _
  ByRef strCol As String, ByRef intCol As Integer, ByRef lngRow As Long)
  
  Dim intCounter As Integer
  Dim stradress As String
  'Dim strcol As String
  Dim strlastcell As String
  Dim intpos1 As Integer
  Dim intpos2 As Integer
  
  stradress = Application.Workbooks(strWorkbookName).Sheets(strSheetName).UsedRange.Address(True, False)
  intpos1 = InStr(stradress, ":")
  
  strlastcell = Mid(stradress, intpos1 + 1)
  intpos2 = InStr(strlastcell, "$")
  strCol = Left(strlastcell, intpos2 - 1)
  lngRow = CLng(Mid(strlastcell, intpos2 + 1))
  
  intCol = Application.Workbooks(strWorkbookName).Sheets(strSheetName).Range("$" & strCol & "$" & lngRow).Column
  
End Sub



'*******************************************************************
'Alle Eingabezellen in data_head sperren
'ab Logib 2.4 nicht mehr noetig
'Vorher: Modul UpdateManagement
Sub setlocked_data_head(ByVal blnLocked As Boolean)
  Dim blnprotectcontents As Boolean
  blnprotectcontents = False
  
  'Blatt entsperren
  If ThisWorkbook.Sheets(STR_SH_DATA_HEAD).ProtectContents Then
    'Blatt entsperren
    ThisWorkbook.Worksheets(STR_SH_DATA_HEAD).Unprotect Password:=changeToNumberString("s")
    blnprotectcontents = True
  End If

  'Auf den Eingabezellen locked setzen
  ThisWorkbook.Names("data_head_c_monat").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_jahr").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_anzmitarb").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_buwaz").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_stundenlohn_jn").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_stundenlohn_anzstunden").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_jahrarbzeitabw").RefersToRange.Locked = blnLocked
  ThisWorkbook.Names("data_head_c_stundenlohn_bruttonetto").RefersToRange.Locked = blnLocked
  
  'Blattschutz auf urspruenglichen Zustand zuruecksetzen
  Call protectSheet(STR_SH_DATA_HEAD, blnprotectcontents)
End Sub


'*******************************************************************
'Alle Eingabezellen in data_form sperren
'ab Logib 2.4 nicht mehr noetig
'Vorher: Modul UpdateManagement
Sub setlocked_data_form(ByVal blnLocked As Boolean)
  Dim blnprotectcontents As Boolean
  blnprotectcontents = False
  
  'Blattschutz vorhanden?
  If ThisWorkbook.Sheets(STR_SH_DATA_FORM).ProtectContents Then
    'Blatt entsperren
    ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Unprotect Password:=changeToNumberString("s")
    blnprotectcontents = True
  End If
  
  'Auf den Eingabezellen locked setzen
  ThisWorkbook.Worksheets(STR_SH_DATA_FORM).Range( _
    STR_DATA_FORM_SD & ":T" & _
    ThisWorkbook.Sheets("data_form").Range("A1").SpecialCells(xlLastCell).Row).Locked = blnLocked
  
  'Blattschutz auf urspruenglichen Zustand zuruecksetzen
  'Ab 3.1.0 Filtern erlauben
  Call protectSheet(STR_SH_DATA_FORM, blnprotectcontents)
End Sub

'*******************************************************************
'Aktualisiert die Gueltigkeitspruefung auf data_form, weil
'Eventhandling buggy ist und es nicht immer automatisch funktioniert
'ab 11/2014 nicht mehr verwendet, da Gueltigkeitspruefung reorganisiert
'Public Sub Gueltigkeitspruefung_aktualisieren()
  'Call format_all_invalid_cells
'End Sub

'*******************************************************************
'V2.5 2016
'Passt die Links fuer beliebiges Export-Blatt an
'Wird in V3 nie verwendet, da keine Hyperlinks in Export-Blatt
'Aufruf: call changeHyperlinksHlpExportForSheetWithTranslations("hlp_export_e", "E")
Sub changeHyperlinksHlpExportForSheetWithTranslations(ByVal strSheet As String, ByVal strlanguage As String)
  Dim mylink As Hyperlink
  
  For Each mylink In ThisWorkbook.Sheets(strSheet).Hyperlinks
    If mylink.Parent.Range("A1").Address(False, False) = STR_HLP_EXPORT_LINK_BEREITSTELLEN Then
      mylink.Address = strtranslateWithLanguage("hlp_export.link.bereitstellen.address", strlanguage)
      mylink.SubAddress = ""
      Debug.Print mylink.Parent.Address & " " & mylink.Address & mylink.SubAddress
    ElseIf mylink.Parent.Range("A1").Address(False, False) = STR_HLP_EXPORT_LINK_STARTEN Then
      mylink.Address = strtranslateWithLanguage("hlp_export.link.starten.address", strlanguage)
      mylink.SubAddress = ""
      Debug.Print mylink.Parent.Address & " " & mylink.Address & mylink.SubAddress
    ElseIf Not Application.Intersect(ThisWorkbook.Sheets(strSheet).Range(mylink.Parent.Address), _
      ThisWorkbook.Sheets(strSheet).Range(STR_HLP_EXPORT_LINKS_LABELS)) Is Nothing Then
      
      mylink.Address = strtranslateWithLanguage("hlp_export.links.labels.address", strlanguage)
      mylink.SubAddress = ""
      'Debug.Print mylink.Parent.Address & " " & mylink.Address & mylink.SubAddress
    End If
  Next
  
End Sub

'*******************************************************************
'Arbeitsort: nicht obligatorisch und zwischen hlp_const_c_plzmin und hlp_const_c_plzmax
Sub set_validation_arbeitsort(ByRef objsheetdata As Worksheet, ByVal introwfirst As Integer, ByVal lngRowLast As Long)
  Dim objRange As Range
  Dim strCol As String
  Dim strformula1, strFormula2 As String
  
  strCol = funstrcol_byname("data_form_col_arbeitsort")
  Set objRange = objsheetdata.Range(strCol & introwfirst & ":" & strCol & lngRowLast)
  strformula1 = "=hlp_const_c_plzmin"
  strFormula2 = "=hlp_const_c_plzmax"
  With objRange.Validation
    .delete
    .Add Type:=xlValidateWholeNumber, AlertStyle:=xlValidAlertStop, _
      Operator:=xlBetween, Formula1:=strformula1, _
      Formula2:=strFormula2
    .IgnoreBlank = True
    .InCellDropdown = True
    .ShowInput = True
    .ShowError = True
  End With
  Call set_formatconditions_between(objRange, strformula1, strFormula2, True, "hlp_const_c_data_invalid")
End Sub

'*******************************************************************
'Sortiert data_form zwischen Funktion und Laufnr
'Ab 3.1.0 ersetzt mit Prozedur, die nach allen Feldern sortieren kann
'Private Sub btndata_formsort_Click()
'  Dim blnProtected As Boolean
'  Dim strNameColToSort As String
'  strNameColToSort = "data_form_col_jobmanual"
'  Dim strSheet As String
'  strSheet = STR_SH_DATA_FORM
'
'  'nur ausfuehren, wenn Blatt sichtbar und jobliste vorhanden
'  If ThisWorkbook.Sheets(strSheet).Visible Then
'    'Blatt entsperren
'    blnProtected = ThisWorkbook.Sheets(strSheet).ProtectContents
'    ThisWorkbook.Worksheets(strSheet).Unprotect Password:=changeToNumberString("s")
'
'    If ThisWorkbook.Worksheets(strSheet).Sort.SortFields.Count >= 1 Then
'      If ThisWorkbook.Worksheets(strSheet).Sort.SortFields(1).Key.Column = _
'        ThisWorkbook.Names("data_form_col_jobmanual").RefersToRange.Column Then
'        strNameColToSort = "data_form_col_laufnr"
'      End If
'    End If
'    Call sortData_form(strNameColToSort)
'
'    'Buttontext von btndata_formsort wechseln
'    If strNameColToSort = "data_form_col_jobmanual" Then
'      Call translateButton(strSheet, "btndata_formsort", "dataform.lblbtndata_formsort.laufnr")
'    Else
'      Call translateButton(strSheet, "btndata_formsort", "joblist.lblbtnjoblistsort.job")
'    End If
'
'    'Blatt wird nur geschuetzt, wenn es vorher auch schon geschuetzt war
'    Call protectSheet(STR_SH_DATA_FORM, blnProtected)
'  End If
'End Sub

Attribute VB_Name = "zzz_snippets"
Option Explicit
Option Private Module

'===================================================================
'Dieses Blatt enthaelt Codeschnippsel

'Fuer Beschreibung Modul
'===================================================================

'Fuer Prozeduren
'*******************************************************************
'

'Fuer Teilschritte in Prozeduren und Funktionen
  '--------------------------------------------------------------
  '

'Dim intcounter As Integer

'  Debug.Print Timer & ": init_data_form nach Gueltigkeitspruefung"
'  Set objsheetdata = Workbooks(ThisWorkbook.Name).Sheets(STR_SH_DATA_FORM)

'Spaltenbuchstaben eines benannten Bereichs zurueckgeben (von 1. Spalte)
'funstrcol_byname("data_form_col_geschlecht")


'ThisWorkbook.Sheets(STR_SH_RPT_FAZIT).unprotect Password:=changeToNumberString("s")


'*******************************************************************
'Fehlermanagement in Prozeduren
Sub bspfehler(ByVal strSheet As String)
  Dim objSheet As Worksheet
  
  On Error GoTo fehler
  
  Set objSheet = ThisWorkbook.Worksheets(strSheet)
  Exit Sub

fehler:
  Const STR_PROCNAME As String = "range_allesloeschen"
  Dim strmeldung As String
  strmeldung = "Blatt " & strSheet
  
  'Debug.Print "Prozedur " & STR_PROCNAME & " " & strmeldung & vbCrLf & _
  '  "Fehler-Nr.: " & Err.Number & vbCrLf & Err.Description & vbCrLf & "Quelle: " & Err.Source
  Resume Next
End Sub


'*******************************************************************
'Dateiname einer Arbeitsmappe ausgeben
'Gibt den Dateinamen inklusive Endung, aber ohne Pfad zurueck von der Datei, in der ein Makro laeuft
'Im Gegensatz zu ActiveWorkbook.Name muss Arbeitsblatt nicht aktiviert sein
'Funktioniert auch, wenn Datei mit Makro umbenannt wird
Sub dateinamen_makro()
  'debug.print "Workbook Macro: " & ThisWorkbook.Name
  Workbooks.Add
  'debug.print "ActiveWorkbook: " & ActiveWorkbook.Name
  'debug.print "Workbook Macro: " & ThisWorkbook.Name
End Sub


'*******************************************************************
'Namen neu definieren
Sub Namendefinieren()
    ActiveWorkbook.Names.Add name:="loesch", RefersToR1C1:= _
        "=hlp_const!R1C1:R1C1"
End Sub


'*******************************************************************
'Arrayformel eingeben
Sub ArrayFormelEingeben()
    Range("C7").Select
    Selection.FormulaArray = _
        "=SUM((hlp_data_regr2!R6C17:R196C17=1)*hlp_data_regr2!R6C3:R196C3)/R6C"
End Sub


'*******************************************************************
'Beispiele fuer anspringen von Zellen in Excel
Sub Zellen_verarbeiten()
  Dim objCell
  Dim objRange As Range
  Dim objSheet As Worksheet
  Dim objWorkbook As Workbook
  
  Set objWorkbook = Application.Workbooks("dateiname.xls")
  Set objSheet = objWorkbook.Sheets("blattname")
  
  'Wert in Zelle mit bestimmtem Bezug setzen
  objSheet.Range("A1").Value = 1
  objSheet.Cells(1, 2).Value = 2


  '***********************************
  'Bereiche verarbeiten
  
  'Via Bereichsbezuege angegebenen Bereich mit Formel fuellen
  Set objRange = objSheet.Range("C1:D1")
  objRange.Formula = "=RAND()"


  'Einen Bereich mit Range und Cells fuellen
  'Unbedingt objsheet.Cells.., sonst funktioniert es nur auf aktiviertem Blatt!
  objSheet.Range(objSheet.Cells(2, 1), objSheet.Cells(4, 4)).Value = "Text"
  
  'Schleife in Range
  For Each objCell In objSheet.Range(objSheet.Cells(5, 1), objSheet.Cells(5, 3))
    'Rnd erzeugt Zufallszahl >= 0 und < 1
    objCell.Value = Int((10 * Rnd))
  Next
 
 
  '***********************************
  'Zugriff auf ganz bestimmte Zellen
  
  '1. benannten Bereich auswaehlen
  objWorkbook.Names(1).RefersToRange.Select
    
  'Zeile 1 auswaehlen
  Range("1:1").Select
  
  'Mehrere Spalten auswaehlen
  Range("A:A,C:C,F:F").Select
  
  'Von Blattanfang bis zu aktiver Zelle markieren
  Range("A1", ActiveCell).Select
  
  'Block um die angegebene Zelle markieren
  objSheet.Range("A1").CurrentRegion.Select
  
  'Um eine Zeile nach unten verschieben
  objSheet.Range("A1").Offset(1, 0).Select
  
  'auf letzte ausgefuellte Zelle in der aktiven Spalte springen
  Cells(ActiveCell.Row, 256).End(xlToLeft).Select

  'Den ganzen benutzen Berech markieren
  ActiveSheet.UsedRange.Select
  
  'Zellen in Range speichern
  Dim objGefundeneZellen As Range
  Set objGefundeneZellen = Union(objSheet.Range("A1"), objSheet.Range("A3"))
  objGefundeneZellen.Select

  'letzte bearbeitete Zelle anspringen
  objSheet.Cells.SpecialCells(xlCellTypeLastCell).Select
  
End Sub


'*******************************************************************
Sub HorizontalZentrieren()
'
' Makro1 Makro
'

'
    With ActiveSheet.PageSetup
        .CenterHorizontally = True
    End With
End Sub


'*******************************************************************
'mit Formularsteuerelementen funktioniert dies nicht!
Sub colorbutton()
  Dim x As Worksheet
  x.Shapes(1).Line.BackColor.RGB = RGB(0, 0, 9)
  x.ProtectContents
  Dim myButton
  Set myButton = ThisWorkbook.Sheets(STR_SH_DATA_HEAD).Shapes.Range(Array("btnimporttext"))
  '  With myButton.Object
  '        .ForeColor = &HFFFFFF
  '        .BackColor = &HFF
  '    End With
  myButton.Fill.Visible = msoTrue
  myButton.Fill.Transparency = 0#
  myButton.Fill.BackColor.RGB = RGB(0, 0, 0)
End Sub




'*******************************************************************
' ueberprueft, ob in einem Zellbereich alle Zellen die Kriterien der Gueltigkeitspruefung erfuellen
' nicht mehr verwendet
' Wegen des Absturzproblems ersetzt durch allezellengueltig
'zu Argument ByVal geaendert
Function alledatengueltig(ByVal objRange As Range)
  On Error Resume Next

  Call updateActiveProc("Excelfunktionen.alledatengueltig")
  Dim objCell As Range
  
  For Each objCell In objRange.Cells
    If objCell.Validation.Value = False Then
      alledatengueltig = False
      Set objCell = Nothing
      Exit Function
    End If
  Next
  alledatengueltig = True
End Function


'*******************************************************************
'Eingabe einzelner Zellen
'Wird im data_form in den 2 Filterspalten verwendet
Function allezellengueltig_Vor20131003(ParamArray varrange() As Variant)
  On Error Resume Next
  
  'call updateActiveProc("Excelfunktionen.allezellengueltig")
  
  Dim lngCounter As Long
  Dim objCell As Range
  
  For lngCounter = 0 To UBound(varrange())
    For Each objCell In varrange(lngCounter).Cells
      If objCell.Validation.Value = False Then
        allezellengueltig = False
        Set objCell = Nothing
        Exit Function
      End If
    Next
  Next
  allezellengueltig = True
End Function

'*******************************************************************
'V2.5 Hyperlinks F und E stimmen nicht mehr auf Blaettern hlp_export
'in V3 nie aufgerufen, keine Hyperlinks in Export-Datei, keine sprachspezifischen Exportblaetter
Sub changeHyperlinksHlpExport()
  Dim strUrlOld As String
  Dim strUrlNew As String
  Dim strSheet As String
  Dim strSprache As String
  
  strSprache = "D"
  
  If strSprache = "F" Then
    strSheet = "hlp_export_f"
    strUrlOld = "http://www.logib-schritt-fuer-schritt.ch/fr/preparer-les-donnees/"
    strUrlNew = "http://www.logib-etape-par-etape.ch/fr/2-preparer-les-donnees/"
  ElseIf strSprache = "E" Then
    strSheet = "hlp_export_e"
    strUrlOld = "http://www.logib-schritt-fuer-schritt.ch/en/preparing-data/"
    strUrlNew = "http://www.logib-step-by-step.ch/en/2-preparing-the-data/"
  ElseIf strSprache = "I" Then
    strSheet = "hlp_export_i"
    strUrlOld = "http://www.logib-schritt-fuer-schritt.ch/it/approntare-i-dati/"
    strUrlNew = "http://www.logib-passo-per-passo.ch/it/preparare-i-dati/"
  Else
    strSheet = "hlp_export_d"
    strUrlOld = "http://www.logib-schritt-fuer-schritt.ch/de/daten-bereitstellen/"
    strUrlNew = "http://www.logib-schritt-fuer-schritt.ch/de/2-daten-bereitstellen/"
  End If
  'es muessten 15 sein
  'Debug.Print "Anz Links auf " & strSheet & ": " & ThisWorkbook.Sheets(strSheet).Hyperlinks.Count
  '?range("$R$25").hyperlinks.count
  '?range("$R$25").hyperlinks(1).Address
  'range("$R$25").hyperlinks(1).Delete
  
  Call changeHyperlinksHlpExportForSheet(strSheet, strUrlOld, strUrlNew)

End Sub

'*******************************************************************
'Hilfsfunktionen fuer die Berechnungen auf data_form und rpt_fazit
'Hat leider nicht funktioniert: nicht Mac-kompatibel und Probleme mit geschuetzten Blaettern
'Ersetzt ab Logib 3.1.1 mit DatenAusMappe.funLngLastRowEvenIfFiltered
Function lastFilledRow(ByVal objRange As Range)
  On Error Resume Next
  Dim result
  Dim nextRowAfterUsedRange
  Dim objCell As Range
  result = 0
'  If Not Application.OperatingSystem Like "*Mac*" Then
'    'find wird auf Mac in user defined functions nicht unterstuetzt
'    result = objRange.Worksheet.Cells.Find(what:="*", SearchOrder:=xlByRows, SearchDirection:=xlPrevious).row
'    'Debug.Print "result: " & result
'  Else
    nextRowAfterUsedRange = objRange.Worksheet.UsedRange.Cells(objRange.Worksheet.UsedRange.Rows.Count, 1).Row + 1
    'Debug.Print "UsedRange: " & nextRowAfterUsedRange
    For Each objCell In Range(Cells(nextRowAfterUsedRange, objRange.Worksheet.UsedRange.Column), _
      Cells(nextRowAfterUsedRange, objRange.Worksheet.UsedRange.Cells(1, objRange.Worksheet.UsedRange.Columns.Count).Column))
      If objCell.End(xlUp).Row > result Then
        result = objCell.End(xlUp).Row
        If result = nextRowAfterUsedRange - 1 Then
          lastFilledRow = result
        End If
      End If
    Next
'  End If
  lastFilledRow = result
End Function


Private Function addressOfRange(ByVal objRange As Range)
  'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
  addressOfRange = objRange.Worksheet.name & "!" & objRange.Address(False, False, 1) ', True)
End Function

Function columnAsString(ByVal objRange As Range)
  columnAsString = Left(objRange.Address(True, False), InStr(objRange.Address(True, False), "$") - 1)
End Function

Function addressFromRangeToLastRow(ByVal objRange As Range)
  
  On Error Resume Next
  Dim lastRow As Long
  lastRow = objRange.Row
  lastRow = lastFilledRow(objRange) '.Worksheet.Cells.Find("*", [A1], , , xlByRows, xlPrevious).row
  'SR 18.12.2018 objRange.Parent.Name durch objRange.Worksheet.Name ersetzt
  addressFromRangeToLastRow = objRange.Worksheet.name & "!" & objRange.Cells(1, 1).Address(False, False, 1) _
    & ":" & Left(objRange.Address(True, False), InStr(objRange.Address(True, False), "$") - 1) _
    & Application.WorksheetFunction.Max(lastRow, objRange.Row)
End Function

Private Sub bedingteFormatierungKopieren()

    Application.CutCopyMode = False
    Selection.Copy
    Windows("Exportform_f_20160526_092452.xlsx").Activate
    Selection.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _
        SkipBlanks:=False, Transpose:=False
    ActiveWindow.SmallScroll Down:=36
End Sub

'Am 02.11.2016 Version 3.0.2 Ersetzt durch settitleForCountryVersion
Private Sub settitle(ByVal strlanguage As String)
  
  Call updateActiveProc("Translations.settitle")
  'Titelbild wechseln
  'Ab Excel 2010 geht dies nur mit entsperrten Blaettern
  ThisWorkbook.Worksheets(STR_SH_TITLE).Unprotect Password:=changeToNumberString("s")
  ThisWorkbook.Worksheets(STR_SH_TITLE).Shapes("title_img_" & LCase(strlanguage)).ZOrder msoBringToFront
  Call protectSheet(STR_SH_TITLE, True)
End Sub

'Gibt Namen aus, falls es sich um benannte Einzelzellen handelt
Private Sub listNames()
  On Error Resume Next
  Dim objCell
  
  For Each objCell In Selection
    'Debug.Print objCell.Address & " " & objCell.Name.Name
    Debug.Print objCell.name.name
  Next
End Sub

Private Sub showColorFromColorIndex()
  Dim objCell
  
  For Each objCell In Selection
      'Debug.Print objCell.Address & " " & objCell.Name.Name
    objCell.Offset(0, 1).Interior.ColorIndex = objCell.Value
    objCell.Offset(0, 2).Value = objCell.Offset(0, 1).Interior.Color
    
  Next
End Sub


Sub examplesAutofilter()
'
' Makro2 Makro
'

'
    'Autofilter setzen
    Selection.AutoFilter
    'bestimmten Filter setzen
    ActiveSheet.Range("$A$13:$AE$151").AutoFilter Field:=4, Criteria1:=Array( _
        "10.3", "10.4", "10.5", "10.8", "11.2", "11.3", "11.4", "11.7", "12.3", "12.6", "12.7", _
        "12.8", "13.0", "13.2", "13.7", "13.8", "13.9", "14.2", "14.3", "14.4", "14.6", "14.7", _
        "14.8", "15.0", "15.1", "15.4", "15.7", "15.8", "16.0", "16.3", "16.4", "16.5", "17.5", _
        "17.7", "17.8", "18.0", "18.1", "18.7", "19.6", "19.7", "22.5", "22.6", "22.7", "23.7", _
        "24.0", "24.1", "25.0", "27.0", "27.5", "27.7", "29.7", "3.5", "3.6", "3.7", "3.9", "33.2" _
        , "34.6", "35.6", "36.8", "4.0", "4.1", "4.2", "4.3", "4.4", "4.7", "4.8", "5.1", "5.2", _
        "5.3", "5.4", "5.6", "5.7", "5.9", "6.0", "6.2", "6.3", "6.4", "6.6", "6.7", "6.8", "7.3", _
        "7.4", "7.8", "8.3", "8.4", "8.7", "8.8", "8.9", "86.8", "9.0", "9.1", "9.2", "9.3", "9.5", _
        "9.6", "9.7", "9.9"), Operator:=xlFilterValues
    ActiveSheet.Range("$A$13:$AE$151").AutoFilter Field:=5, Criteria1:=Array( _
        "1", "2", "3"), Operator:=xlFilterValues
    'Alle Daten anzeigen
    ActiveSheet.ShowAllData
End Sub

Sub setAutofilter()
'
' Autofilter ein- und ausschalten
'

    Selection.AutoFilter
    Selection.AutoFilter
End Sub


' InQuest injected base64 decoded content
' rB'5
' ($z+l
' {-zYn
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' kzw!
' jx.j
' +-zk){8
' j[kzy
' z'!z
' \zYlj
' BzYl
' zu't
' bz{-
' bz{-
' bz{-
' bz{-
' ejx.j
' jx.j
' jx.j
' jx.j
' ^Z+a-
' J'!z
' {-zYn
' z+%i
' z{ei

INQUEST-PP=macro
