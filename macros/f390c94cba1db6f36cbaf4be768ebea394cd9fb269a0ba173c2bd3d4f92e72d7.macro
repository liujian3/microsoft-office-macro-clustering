Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "W_mdlPubA"
'=======================================================
' Windows API
'
' 2007.2 WZH copied from win32api and date_check in SSS_STAT.xls
'=======================================================
Option Explicit

' |fffd||fffd||fffd|W|fffd|X|fffd|g|fffd||fffd||fffd||58c|W|fffd||fffd|Windows API|fffd||fffd||933e||fffd||fffd||fffd||fffd|
'
'|fffd||fffd||fffd||30d||14c||fffd||fffd||fffd||fffd|DebugTxt|fffd||fffd||fffd||82||fffd|

Const HKEY_CLASSES_ROOT = &H80000000
Const HKEY_CURRENT_USER = &H80000001
Const HKEY_LOCAL_MACHINE = &H80000002
Const HKEY_USERS = &H80000003
Const ERROR_SUCCESS = 0&
Const ERROR_NO_MORE_ITEMS = 259&

Const REG_SZ = 1
Const REG_BINARY = 3
Const REG_DWORD = 4


Const STANDARD_RIGHTS_ALL = &H1F0000
Const KEY_QUERY_VALUE = &H1
Const KEY_ENUMERATE_SUB_KEYS = &H8
Const KEY_NOTIFY = &H10
Const SYNCHRONIZE = &H100000

Const READ_CONTROL = &H20000
Const STANDARD_RIGHTS_READ = (READ_CONTROL)

Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
Const KEY_EXECUTE = (KEY_READ)

'---------
Const KEY_SET_VALUE = &H2
Const KEY_CREATE_SUB_KEY = &H4
Const KEY_CREATE_LINK = &H20
Const KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL Or KEY_QUERY_VALUE Or KEY_SET_VALUE Or KEY_CREATE_SUB_KEY Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY Or KEY_CREATE_LINK) And (Not SYNCHRONIZE))

Const REG_OPTION_VOLATILE = 1           ' Key is not preserved when system is rebooted
Const REG_OPTION_NON_VOLATILE = 0       ' Key is preserved when system is rebooted

Type SECURITY_ATTRIBUTES
        nLength As Long
        lpSecurityDescriptor As Long
        bInheritHandle As Boolean
End Type
'-------
#If Win64 Then
Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hkey As Long) As Long
Declare PtrSafe Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hkey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Declare PtrSafe Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hkey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Declare PtrSafe Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue As Long) As Long
Declare PtrSafe Function RegSetValue Lib "advapi32.dll" Alias "RegSetValueA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long
Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hkey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long          ' Note that if you declare the lpData parameter as String, you must pass it By Value.
Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare PtrSafe Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hkey As Long, ByVal lpSubKey As String) As Long
Declare PtrSafe Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hkey As Long, ByVal lpValueName As String) As Long

Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As Long, phkResult As Long, lpdwDisposition As Long) As Long

'--------------
Declare PtrSafe Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
Declare PtrSafe Function CopyFile Lib "kernel32" Alias "CopyFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String, ByVal bFailIfExists As Long) As Long
Declare PtrSafe Function OSRegSetValueEx Lib "advapi32" Alias "RegSetValueExA" (ByVal hkey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, ByVal fdwType As Long, lpbData As Any, ByVal cbData As Long) As Long
Declare PtrSafe Function OSRegQueryValueEx Lib "advapi32" Alias "RegQueryValueExA" (ByVal hkey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, lpdwType As Long, lpbData As Any, cbData As Long) As Long


'
'|fffd||11713|x|fffd||30e||64fe|
'
'Private Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
'Private Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
Declare PtrSafe Function GetSystemMetrics Lib "USER32" (ByVal flag As Integer) As Integer
#Else
Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hkey As Long) As Long
Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hkey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hkey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Declare Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue As Long) As Long
Declare Function RegSetValue Lib "advapi32.dll" Alias "RegSetValueA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long
Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hkey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hkey As Long, ByVal lpSubKey As String) As Long
Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hkey As Long, ByVal lpValueName As String) As Long

Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hkey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As Long, phkResult As Long, lpdwDisposition As Long) As Long

'--------------
Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
Declare Function CopyFile Lib "kernel32" Alias "CopyFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String, ByVal bFailIfExists As Long) As Long
Declare Function OSRegSetValueEx Lib "advapi32" Alias "RegSetValueExA" (ByVal hkey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, ByVal fdwType As Long, lpbData As Any, ByVal cbData As Long) As Long
Declare Function OSRegQueryValueEx Lib "advapi32" Alias "RegQueryValueExA" (ByVal hkey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, lpdwType As Long, lpbData As Any, cbData As Long) As Long


'
'|fffd||11713|x|fffd||30e||64fe|
'
'Private Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
'Private Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
Declare Function GetSystemMetrics Lib "USER32" (ByVal flag As Integer) As Integer
#End If
Const SM_CXSCREEN As Integer = 0
Const SM_CYSCREEN As Integer = 1

Function getResolutionFlag()
    Dim xdot, ydot
    
    xdot = GetSystemMetrics(SM_CXSCREEN)
    ydot = GetSystemMetrics(SM_CYSCREEN)
    If xdot < 800 Then getResolutionFlag = 1: Exit Function '640|fffd|~480
    If xdot < 1024 Then getResolutionFlag = 2: Exit Function '800|fffd|~600
    If xdot < 1280 Then getResolutionFlag = 3: Exit Function '1024|fffd|~768
    
    getResolutionFlag = 4: Exit Function '1280|fffd|~1024
End Function


Sub setZoom()
    Dim flg As Integer
    
    flg = getResolutionFlag()
    If flg <= 3 Then ActiveWindow.Zoom = 75 Else ActiveWindow.Zoom = 100
End Sub



Function iGet_Ini_String(sIniFileName As String, sSectionName As String, sKeyName As String, ByRef sKeyStr As String) As Integer
'--------------------------
'INI|fffd|t|fffd|@|fffd|C|fffd||fffd||fffd||fffd||fffd||fffd|f|fffd|[|fffd|^|fffd||fffd||1c2||74d||fffd||fffd||fffd|
'|fffd||fffd||fffd||fffd||fffd|F
'|fffd|@sIniFileName:|fffd||fffd||fffd||fffd||fffd||fffd||fffd|t|fffd|@|fffd|C|fffd||fffd||fffd||fffd||fffd||315||fffd||fffd||fffd||fffd||fffd|i|fffd||fffd||fffd||fffd||7fd||fffd|t|fffd||fffd||fffd|j
'|fffd|@sSectionName:|fffd|Z|fffd|N|fffd|V|fffd||fffd||fffd||fffd||fffd||fffd||fffd||315||fffd||fffd||fffd||fffd||fffd|
'  sKeyName:    |fffd|L|fffd|[|fffd||fffd||fffd||315||fffd||fffd||fffd||fffd||fffd|
'|fffd|@sKeyStr:     |fffd|L|fffd|[|fffd||fffd||fffd||fffd||fffd||fffd||30a|i|fffd|[|fffd||a3ca|
'|fffd||7c2||fffd|l|fffd|F
'|fffd|@sKeyStr:     |fffd||1cd||fffd||fffd||42f95||fffd||fffd||fffd||fffd||fffd|
'  |fffd||1cd||fffd||fffd||750||fffd||fffd||fffd||fffd||30f||a347||fffd|F1
'  |fffd||1cd||fffd||fffd||74e||fffd||fffd|s|fffd||30f||a347||fffd|F-1(|fffd|Y|fffd||fffd||fffd||fffd||fffd||fffd|L|fffd|[|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|)
'  |fffd||1cd||fffd||fffd||74e||fffd||fffd|s|fffd||30f||a347||fffd|F-2(|fffd|t|fffd|@|fffd|C|fffd||fffd||fffd||58c|W|fffd||303|G|fffd||fffd||fffd|[|fffd|j
'--------------------------
Dim iRet As Long
Dim sGetBuffer As String
Dim sTemp1 As String
    On Error GoTo ERR_OUT
    
    sGetBuffer$ = String(512, 0)   '|fffd|f|fffd|[|fffd|^|fffd||30f||fffd||fffd||fffd||fffd||fffd|
    iRet = GetPrivateProfileString(ByVal sSectionName, ByVal sKeyName, ByVal "0000000000", sGetBuffer, CInt(512), ByVal sIniFileName)
    sTemp1 = left$(sGetBuffer, InStr(sGetBuffer, Chr(0)) - 1)
    If (sTemp1 = "0000000000") Then
        sKeyStr = ""
        iGet_Ini_String = -1
    Else
        sKeyStr = sTemp1
        iGet_Ini_String = 1
    End If
    On Error GoTo 0
    Exit Function
    
ERR_OUT:
    On Error GoTo 0
    iGet_Ini_String = -1
    sKeyStr = ""

End Function

Function iSet_Ini_String(sIniFileName As String, sSectionName As String, sKeyName As String, sKeyStr As String) As Integer
'--------------------------
'INI|fffd|t|fffd|@|fffd|C|fffd||fffd||fffd||243|f|fffd|[|fffd|^|fffd||fffd||752||80b7||fffd||fffd|
'|fffd||fffd||fffd||fffd||fffd|F
'|fffd|@sIniFileName:|fffd||fffd||fffd||fffd||fffd||fffd||fffd|t|fffd|@|fffd|C|fffd||fffd||fffd||fffd||fffd||315||fffd||fffd||fffd||fffd||fffd|i|fffd||fffd||fffd||fffd||7fd||fffd|t|fffd||fffd||fffd|j
'|fffd|@sSectionName:|fffd|Z|fffd|N|fffd|V|fffd||fffd||fffd||fffd||fffd||fffd||fffd||315||fffd||fffd||fffd||fffd||fffd|
'  sKeyName:    |fffd|L|fffd|[|fffd||fffd||fffd||315||fffd||fffd||fffd||fffd||fffd|
'  sKeyStr:     |fffd|L|fffd|[|fffd||fffd||fffd|e|fffd||315||fffd||fffd||fffd||fffd||fffd|
'|fffd||7c2||fffd|l|fffd|F
'  |fffd||fffd||fffd||fffd||fffd||fffd||fffd||750||fffd||fffd||fffd||fffd||30f||a347||fffd|F1
'  |fffd||fffd||fffd||fffd||fffd||fffd||fffd||74e||fffd||fffd|s|fffd||30f||a347||fffd|F-1
'--------------------------
    Dim lRet As Long
    On Error GoTo ERR_OUT
        
    lRet = WritePrivateProfileString(ByVal sSectionName, ByVal sKeyName, ByVal sKeyStr, ByVal sIniFileName)
    '|fffd||fffd||fffd||fffd||fffd||fffd||fffd||743|f|fffd|[|fffd|^|fffd||30a|m|fffd|F
    If (lRet = 0) Then
        iSet_Ini_String = -1
        Exit Function
    End If
    iSet_Ini_String = 1
    
    On Error GoTo 0
    Exit Function
    
ERR_OUT:
    On Error GoTo 0
    iSet_Ini_String = -1

End Function

'=== EOF ===




Attribute VB_Name = "W_mdlPubB"
'===================================================
' Template File : Open / Close
'
' 2007.2 copied from commTemplate in SSS_STAT.xls
'===================================================
Option Explicit

Function TemplateOpen(fName As String) As Workbook
    Dim bkObj As Workbook
    Set bkObj = Nothing
    
    Application.ScreenUpdating = False
    Call changeToSSDir
    Workbooks.Open Filename:=fName, UpdateLinks:=1, ReadOnly:=True
    Application.ScreenUpdating = True
    
    Set bkObj = Workbooks(fName)
    If bkObj Is Nothing Then
        MsgBox MSG_CANTOPEN_FILE(fName)
        Exit Function
    End If
    
    Set TemplateOpen = bkObj
End Function
'
Sub TemplateClose(fName As String)
    Application.DisplayAlerts = False
    
    Workbooks(fName).Close savechanges:=False
    
    Application.DisplayAlerts = True
End Sub

'=== EOF ===



Attribute VB_Name = "W_mdlPubC"
'=======================================================
' |fffd||fffd||fffd||fffd||fffd|v|fffd||fffd||fffd|n|fffd||fffd||fffd|} in VBA
'
' 2007.02.08 WZH copied from SUBHSK.xls (SonyStat3P6)
' 2010.11.30 LSQ mdf (DZH 11/23)
'=======================================================
Option Explicit

Private Type Node
    id As Integer                       'node id: location no. of this node
    flgDrawn As Boolean                 'flag for drawing: True for drawn , False not yet
    row As Integer                      'row no.
    col As Integer                      'column no.
    text As String                      'displayed text
    val As Integer                      'the length of the text
    Link As Integer                     'linked node id
    left As Double
    top As Double
    width As Double
    height As Double
End Type

Private Type Nodes
    rownum As Integer                   'row number
    colnum As Integer                   'column number
    content() As Node                   'node array for all data
End Type

Private Type ObjPos                     '10.11.23 DZH add
    xValue As Double
    yValue As Double
End Type

Private CEG As Nodes
Private BkShp As Shape

'get information for nodes from data range
Private Sub InitNodes(ByVal dataRge As Range, ByVal strTitle As String)
    Dim rownum As Integer, colnum As Integer
    Dim i As Integer, j As Integer
    Dim k As Integer, mm As Integer
    Dim strVal As String
    
    'get data size and set data structure
    rownum = dataRge.Rows.Count
    colnum = dataRge.Columns.Count + 1
    ReDim CEG.content(1 To rownum * colnum)
    CEG.rownum = rownum
    CEG.colnum = colnum
    
    'set the first element: Title
    strVal = strTitle ' Trim(CStr(dataRge(1, 1)))
    CEG.content(1).id = 1
    If strVal = vbNullString Then
        strVal = "|fffd||fffd||fffd||fffd||fffd|v|fffd||fffd||fffd|n|fffd||fffd||fffd|}"
        CEG.content(1).text = strVal
        CEG.content(1).val = LenB(strVal)
    Else
        CEG.content(1).text = strVal
        CEG.content(1).val = LenB(StrConv(strVal, vbFromUnicode))
    End If
    CEG.content(1).row = 1
    CEG.content(1).col = 1
    CEG.content(1).flgDrawn = False
    
    'set the first column
    For i = 2 To rownum
        mm = (i - 1) * colnum + 1
        CEG.content(mm).text = vbNullString
        CEG.content(mm).val = 0
        CEG.content(mm).Link = 1
        CEG.content(mm).row = i
        CEG.content(mm).col = 1
        CEG.content(mm).flgDrawn = False
    Next i
    
    'set the other information
    For i = 1 To rownum
        For j = 2 To colnum
            mm = (i - 1) * colnum + j
            CEG.content(mm).Link = 1
            CEG.content(mm).row = i
            CEG.content(mm).col = j
            CEG.content(mm).flgDrawn = False
            strVal = Trim(CStr(dataRge(i, j - 1)))
            
            'empty string
            If strVal = vbNullString Then
                CEG.content(mm).id = mm
                CEG.content(mm).text = vbNullString
                CEG.content(mm).val = 0
            'for the char of '=', omit the followed data at the same column
            ElseIf strVal = "=" Then
                For k = j To colnum
                    mm = (i - 1) * colnum + k
                    CEG.content(mm).id = mm
                    CEG.content(mm).text = vbNullString
                    CEG.content(mm).val = 0
                Next k
                Exit For
            Else
                CEG.content(mm).id = mm
                CEG.content(mm).text = strVal
                CEG.content(mm).val = LenB(StrConv(strVal, vbFromUnicode))
            End If
        Next j
    Next i
End Sub

'Get the linked node id for a node
Private Function GetLinkNode(ByVal row As Integer, ByVal col As Integer) As Integer
    Dim i As Integer, j As Integer
    Dim mm As Integer, nn As Integer
    
    'the first elemen is itself
    If row = 1 And col = 1 Then
        GetLinkNode = 1
        Exit Function
    End If
    '
    'look up from right to left
    For i = col - 1 To 1 Step -1
        mm = (row - 1) * CEG.colnum + i
        If CEG.content(mm).val > 0 Then
            GetLinkNode = mm
            Exit Function
        End If
    Next i
    '
    'look up from down
    For i = row - 1 To 1 Step -1
        mm = (i - 1) * CEG.colnum + col
        If CEG.content(mm).val > 0 Then
            GetLinkNode = CEG.content(mm).Link
            Exit Function
        End If
    Next i
    'nothing? look up the element at the first row of the same column
    GetLinkNode = GetLinkNode(1, col)
End Function

Private Sub BrowseNodes()
    Dim i As Integer, j As Integer
    Dim mm As Integer
    Dim nb As Integer
    
    For i = 1 To CEG.colnum
        For j = 1 To CEG.rownum
            mm = (j - 1) * CEG.colnum + i
            CEG.content(mm).Link = GetLinkNode(j, i)
        Next j
    Next i
End Sub

'10.11.23 DZH
'draw a text box
Private Sub SubDrawBox(ByVal cht As Chart, ByVal id As Integer, _
                       ByVal charcnt As Integer, ByVal fontsize As Integer, posInfo() As Double)
    Dim ulx As Double, uly As Double
    Dim lrx As Double, lry As Double
    Dim row As Integer, col As Integer
    Dim strtmp As String
    Dim shp As Shape
    Dim rate As Double
    Dim nExcelVer As Integer
    'On Error Resume Next
    
    If CEG.content(id).flgDrawn Then Exit Sub
    
    nExcelVer = getExcelVerNo
   
    If nExcelVer >= 12 Then
        rate = 100# / 72#
    Else
        rate = 1
    End If

    rate = rate * ActiveWindow.Zoom / 100#
    row = CEG.content(id).row
    col = CEG.content(id).col
    cht.parent.Activate
    'the series no is different between excel 2007 and previous version
    If CInt(Application.Version >= 12) Then col = 2 * col - 1
    strtmp = "S" & col & "P" & row
    
    'get the left-upper position
    ulx = (ExecuteExcel4Macro("GET.CHART.ITEM(1,1,""" & strtmp & """)")) * rate
    uly = (ActiveChart.ChartArea.height * 100# / ActiveWindow.Zoom - ExecuteExcel4Macro("GET.CHART.ITEM(2,1,""" & strtmp & """)")) * rate
    
    'get the right-lower position
    lrx = (ExecuteExcel4Macro("GET.CHART.ITEM(1,5,""" & strtmp & """)")) * rate
    lry = (ActiveChart.ChartArea.height * 100# / ActiveWindow.Zoom - ExecuteExcel4Macro("GET.CHART.ITEM(2,5,""" & strtmp & """)")) * rate
    
    'set temporary position
    CEG.content(id).left = BkShp.left + ulx
    CEG.content(id).top = BkShp.top + uly
    CEG.content(id).width = lrx - ulx + 1
    CEG.content(id).height = lry - uly + 1
    
    'Set shp = cht.Shapes.AddShape(msoShapeRectangle, ulx, uly, lrx - ulx + 1, lry - uly + 1)
    Set shp = ActiveSheet.Shapes.AddTextbox(msoTextOrientationHorizontal, _
                                            CEG.content(id).left, CEG.content(id).top, _
                                            CEG.content(id).width, CEG.content(id).height)
    shp.Name = strtmp
    shp.DrawingObject.text = Mid(CEG.content(id).text, 1, charcnt) '10.12.1 LSQ mdf, old:
    'shp.DrawingObject.text = StrConv(Mid(StrConv(CEG.content(id).text, vbFromUnicode), 1, charcnt), vbUnicode) '10.11.24 DZH mdf,old:MidB
    
    shp.DrawingObject.Font.Size = fontsize
    shp.DrawingObject.Border.LineStyle = xlContinuous
    
    'set margin
    shp.TextFrame.MarginLeft = 2
    shp.TextFrame.MarginTop = 0
    shp.TextFrame.MarginRight = 0
    shp.TextFrame.MarginBottom = 0
    If nExcelVer >= 12 Then
        shp.TextFrame2.WordWrap = msoFalse
    End If
    shp.Select
    Selection.VerticalAlignment = xlCenter
    
    'autosize
    shp.DrawingObject.AutoSize = True
    shp.DrawingObject.left = shp.DrawingObject.left
    shp.DrawingObject.AutoSize = False
    
     '10.11.23 DZH add
    posInfo(0) = shp.left + shp.width + 10      'X-value
    posInfo(1) = shp.top + shp.height + 10      'Y-value
    'end
    
    'set final position
    CEG.content(id).left = shp.left
    CEG.content(id).top = shp.top
    CEG.content(id).width = shp.width
    CEG.content(id).height = shp.height
    
    'set the flag
    CEG.content(id).flgDrawn = True
    
    'On Error GoTo 0
End Sub
'draw the connector between two text boxes
Private Sub SubDrawLine(ByVal cht As Chart, ByVal id1 As Integer, ByVal id2 As Integer)
    Dim row1 As Integer, col1 As Integer
    Dim row2 As Integer, col2 As Integer
    Dim dXVal1 As Double, dYVal1 As Double
    Dim dXVal2 As Double, dYVal2 As Double
    Dim tmpX1 As Double, tmpY1 As Double
    Dim tmpX2 As Double, tmpY2 As Double
    Dim strtmp1 As String, strtmp2 As String
    Dim conn As Object
    'Dim CustomLines As FreeformBuilder
    
    'On Error Resume Next
    If id1 = id2 Then Exit Sub
    
    row1 = CEG.content(id1).row
    col1 = CEG.content(id1).col
    If CInt(Application.Version >= 12) Then col1 = 2 * col1 - 1
    row2 = CEG.content(id2).row
    col2 = CEG.content(id2).col
    If CInt(Application.Version >= 12) Then col2 = 2 * col2 - 1
    strtmp1 = "S" & col1 & "P" & row1
    strtmp2 = "S" & col2 & "P" & row2
    
    'get the left-middle position
    dXVal1 = CEG.content(id1).left ' ActiveSheet.Shapes(strtmp1).left 'ExecuteExcel4Macro("GET.CHART.ITEM(1,8,""" & strtmp1 & """)")
    dYVal1 = CEG.content(id1).top + CEG.content(id1).height / 2 ' ActiveSheet.Shapes(strtmp1).top + ActiveSheet.Shapes(strtmp1).height / 2 'cht.ChartArea.Height - ExecuteExcel4Macro("GET.CHART.ITEM(2,8,""" & strtmp1 & """)")
    
    strtmp2 = "S" & col2 & "P" & row2
    'get the right-middle position
    dXVal2 = CEG.content(id2).left + CEG.content(id2).width 'ActiveSheet.Shapes(strtmp2).left + ActiveSheet.Shapes(strtmp2).width 'ExecuteExcel4Macro("GET.CHART.ITEM(1,4,""" & strtmp2 & """)")
    dYVal2 = CEG.content(id2).top + CEG.content(id2).height / 2 'ActiveSheet.Shapes(strtmp2).top + ActiveSheet.Shapes(strtmp1).height / 2 'cht.ChartArea.Height - ExecuteExcel4Macro("GET.CHART.ITEM(2,4,""" & strtmp2 & """)")
    
    'draw a single line for the boxes at the same row
    If row1 = row2 Then
        Call ActiveSheet.Shapes.AddLine(dXVal1, dYVal1, dXVal2 + 1, dYVal2)
    'draw three lines for the boxes at the different rows
    Else
        tmpX1 = (dXVal1 + dXVal2) / 2
        tmpX2 = tmpX1
        tmpY1 = dYVal1
        tmpY2 = dYVal2
        Call ActiveSheet.Shapes.AddLine(dXVal1, dYVal1, tmpX1, tmpY1)
        Call ActiveSheet.Shapes.AddLine(tmpX1, tmpY1, tmpX2, tmpY2)
        Call ActiveSheet.Shapes.AddLine(tmpX2, tmpY2, dXVal2, dYVal2)
    End If
End Sub

'get data-length matrix by data range
Private Function CreateGrpData(ByVal outrge As Range, ByVal dataRge As Range, _
                               ByVal strTitle As String, ByVal charcnt As Long) As Long
    Dim i As Integer, j As Integer
    Dim rownum As Integer, colnum As Integer
    Dim aryData() As Variant
    Dim nwidth As Long, l As Long
    
    rownum = dataRge.Rows.Count
    colnum = dataRge.Columns.Count
    aryData = dataRge.Value
    For i = 1 To rownum
        For j = 1 To colnum
            aryData(i, j) = StrConv(Mid(StrConv(aryData(i, j), vbFromUnicode), 1, charcnt), vbUnicode) '10.11.24 DZH mdf,old:MidB
        Next j
    Next i
    
    nwidth = 0
    For j = 1 To colnum
        l = 0
        For i = 1 To rownum
            aryData(i, j) = LenB(StrConv(aryData(i, j), vbFromUnicode))
            If l < aryData(i, j) Then l = aryData(i, j)
        Next i
        nwidth = nwidth + l
    Next j
    l = LenB(StrConv(strTitle, vbFromUnicode))
    nwidth = nwidth + l
    'For i = 2 To rownum
    '    aryData(i, 1) = aryData(1, 1)
    'Next i
    For i = 1 To rownum
        outrge(i, 1) = l
    Next i
    Range(outrge(1, 2), outrge(rownum, colnum + 1)).Value = aryData
    CreateGrpData = nwidth
End Function

'create a chart by a data matrix for drawing text box
'provides the postions for all boxes
Private Function CreateCEGGrp(ByVal dataRge As Range, ByVal fontsize As Integer) As Chart
    Dim i As Integer, j As Integer
    Dim rownum As Integer, colnum As Integer
    Dim serieNum As Integer
    Dim serieRge As Range
    Dim serie As Series
    Dim wrkst As Worksheet
    Dim cht As Chart
    Dim intMax As Integer
    Dim aryData() As Integer
    
    'On Error Resume Next
    
    Set wrkst = dataRge.Worksheet
    Set cht = GetTmplGrp(dataRge, ThisWorkbook.Name, "tmplCEG", "grpCEG")
    If cht Is Nothing Then
        Set CreateCEGGrp = Nothing
        Exit Function
    End If
    rownum = dataRge.Rows.Count
    colnum = dataRge.Columns.Count
    
    'resize the chart by fontsize and row number
    cht.parent.height = cht.parent.height * fontsize / 12# * rownum / 8#
    'cht.parent.Width = cht.parent.Width * fontsize / 12# * colnum / 4.5
    
    cht.parent.top = dataRge.top
    cht.parent.left = dataRge.left
    cht.Shapes.SelectAll
    Selection.Delete
    Call cht.SetSourceData(dataRge, xlByColumns)
    
    'add gap between boxes
    serieNum = cht.SeriesCollection.Count
    ReDim aryData(1 To rownum)
    For i = 1 To serieNum - 1
        Set serie = cht.SeriesCollection(2 * i - 1)
        intMax = CInt(Application.WorksheetFunction.max(serie.Values))
        For j = 1 To serie.Points.Count
            aryData(j) = (intMax - serie.Values(j) + 3)
        Next j
        Set serie = cht.SeriesCollection.NewSeries
        serie.Values = aryData
        serie.PlotOrder = 2 * i
        serie.Border.LineStyle = xlNone
        serie.Interior.colorindex = xlNone
    Next i
    'cht.Activate
    cht.ChartArea.Select
    cht.ChartArea.Font.Size = fontsize
    cht.ChartGroups(1).GapWidth = 30
    Set CreateCEGGrp = cht
    
    'On Error GoTo 0
End Function

'draw a chart by the nodes information
Private Sub DrawChart(ByVal cht As Chart, ByVal charcnt As Integer, ByVal fontsize As Integer)
    Dim i As Integer, j As Integer, mm As Integer
    Dim id1 As Integer, id2 As Integer
    Dim firstshp As Long, lastshp As Long, shpcnt As Long
    Dim aryShp() As Variant
    Dim AryPos(0 To 1) As Double, maxX As Double, maxY As Double
    Dim posInfo() As ObjPos
    Dim cnt As Integer
    
    firstshp = ActiveSheet.Shapes.Count + 1
    
    'Draw background text box
    Set BkShp = ActiveSheet.Shapes.AddTextbox(msoTextOrientationHorizontal, _
                                            cht.parent.left, cht.parent.top, _
                                            cht.parent.width, cht.parent.height)
    'Draw text boxes
    ReDim posInfo(1 To CEG.colnum * CEG.rownum) As ObjPos
    cnt = 0
    For i = CEG.colnum To 1 Step -1
        For j = CEG.rownum To 1 Step -1
            mm = (j - 1) * CEG.colnum + i
            If CEG.content(mm).val > 0 Then
                'Call SubDrawBox(cht, mm, charcnt, fontsize)        '10.11.23 DZH cmt
                '10.11.23 DZH mdf
                Call SubDrawBox(cht, mm, charcnt, fontsize, AryPos)
                cnt = cnt + 1
                posInfo(cnt).xValue = AryPos(0)
                posInfo(cnt).yValue = AryPos(1)
                'end
            End If
        Next j
    Next i
    
    '10.11.23 DZH add
    maxX = posInfo(1).xValue
    maxY = posInfo(1).yValue
    For i = 2 To cnt
        If posInfo(i).xValue > maxX Then maxX = posInfo(i).xValue
        If posInfo(i).yValue > maxY Then maxY = posInfo(i).yValue
    Next
    'end
    
    For i = 1 To cht.SeriesCollection.Count
        cht.SeriesCollection(1).Delete
    Next i
    
    'Draw linked lines
    For i = CEG.colnum To 1 Step -1
        For j = CEG.rownum To 1 Step -1
            mm = (j - 1) * CEG.colnum + i
            If CEG.content(mm).val > 0 Then
                id1 = mm
                id2 = CEG.content(mm).Link
                Call SubDrawLine(cht, id1, id2)
            End If
        Next j
    Next i
    
    '10.11.23 DZH add
    'Application.ScreenUpdating = True
    BkShp.height = maxY - cht.parent.top
    BkShp.width = maxX - cht.parent.left
    'end
    
    'Group shapes
    Set BkShp = Nothing
    lastshp = ActiveSheet.Shapes.Count
    shpcnt = lastshp - firstshp + 1
    ReDim aryShp(1 To shpcnt)
    For i = 1 To shpcnt
        aryShp(i) = firstshp + i - 1
    Next i
    ActiveSheet.Shapes.Range(aryShp).Group.Name = "grp"
    
    Application.ScreenUpdating = True
End Sub

Private Sub SubDrawCegGrp(ByVal outrge As Range, ByVal dataRge As Range, ByVal strTitle As String, _
                          Optional ByVal charcnt As Integer = 50, Optional ByVal fontsize As Integer = 10)
    Dim RgeOut As Range
    Dim cht As Chart
    Dim nwidth As Long
    
    Application.ScreenUpdating = False
    strTitle = StrConv(Mid(StrConv(strTitle, vbFromUnicode), 1, charcnt), vbUnicode)   '10.11.24 DZH mdf,old:MidB
    nwidth = CreateGrpData(outrge, dataRge, strTitle, charcnt)
    Set RgeOut = Range(outrge(1, 1), outrge(dataRge.Rows.Count, dataRge.Columns.Count + 1))
    Set cht = CreateCEGGrp(RgeOut, fontsize)
    cht.parent.width = cht.parent.width * nwidth / 45# * fontsize / 10#
    Call InitNodes(dataRge, strTitle)
    Call BrowseNodes
    Call DrawChart(cht, charcnt, fontsize)
    '
    'cht.parent.left = RgeOut.left
    'cht.parent.top = RgeOut.top
    cht.parent.Delete
    RgeOut.Clear
    Application.ScreenUpdating = True
End Sub
'
'|fffd||fffd||fffd||fffd||fffd|v|fffd||fffd||fffd|n|fffd||fffd||fffd|}
Sub DrawCEGGrp(ByVal strWrkSht As String, ByVal strGrpOut As String, _
                ByVal strGrpData As String, ByVal strPara As String)
    Dim wrkbk As Workbook
    Dim wrkst As Worksheet
    Dim dataRge As Range, outrge As Range
    Dim para As Object
    Dim strTitle As String
    Dim strDataSheet As String
    Dim charcnt As Integer, fontsize As Integer
    Dim GrpType As Integer
    Dim rownum As Long, colnum As Long
    Dim cht As Chart
    
    'Application.ScreenUpdating = False
    
    On Error Resume Next
    Set wrkbk = Range("'" & strWrkSht & "'!A1").Worksheet.parent
    Set wrkst = Range("'" & strWrkSht & "'!A1").Worksheet
    Set outrge = wrkst.Range(toXlA1str(strGrpOut))
    Set dataRge = wrkst.Range(toXlA1str(strGrpData))
    Set para = SetDict(strPara)
    On Error GoTo 0
    '
    If outrge Is Nothing Or dataRge Is Nothing Or para Is Nothing Then
        Exit Sub
    End If
    
    GrpType = CInt(para("GrpType"))
    strTitle = Trim(para("Title"))
    charcnt = CInt(para("CharCnt"))
    fontsize = CInt(para("FontSize"))
    strDataSheet = Trim(para("DataSheet"))
    Set para = Nothing
    
    If strDataSheet <> vbNullString Then
        On Error Resume Next
        Set wrkst = Range("'" & strDataSheet & "'!A1").Worksheet
        Set dataRge = wrkst.Range(dataRge.Address)
        On Error GoTo 0
        If dataRge Is Nothing Then
            Exit Sub
        End If
    End If
       
    If GrpType = 2 Then                                 '1: for SonyStat   2: for SSS_Srk2p5
        rownum = dataRge.Rows.Count
        colnum = dataRge.Columns.Count
        strTitle = dataRge(1, 1)
        Set dataRge = wrkst.Range(dataRge(1, 2), dataRge(rownum, colnum))
    End If
    If strTitle = vbNullString Then strTitle = "|fffd||fffd||fffd||fffd||fffd||fffd|"
    Call SubDrawCegGrp(outrge, dataRge, strTitle, charcnt, fontsize)
    Application.ScreenUpdating = True
    
    outrge.Select
End Sub

'=== EOF ===


Attribute VB_Name = "W_mdlPubD"
'=======================================================
' Draw Obi Graph
'
' 2007.02.08 WZH copied from SUBHSK.xls (SonyStat3P6)
'=======================================================

Option Explicit

Sub DrawObiGrp(ByVal strWrkSht As String, ByVal strGrpOut As String, _
                ByVal strGrpData As String, ByVal strPara As String)
    Dim wrkbk As Workbook
    Dim wrksht As Worksheet
    Dim dataRge As Range, outrge As Range
    Dim para As Object
    Dim bTotal As Boolean, bTotalDsp As Boolean
    Dim bN As Boolean, bAvg As Boolean
    Dim dBoLength As Double, dBoWidth As Double, dBoMojiH As Double
    Dim nDatalabDsp As Integer
    Dim strTName As String, strYName As String, strXName As String
    Dim ObiGrp As clsObiGrp
    On Error Resume Next
    Application.ScreenUpdating = False
    Set wrksht = Range("'" & strWrkSht & "'!$A$1").Worksheet
    Set wrkbk = wrksht.parent
    Set para = SetDict(strPara)
    On Error GoTo 0
    If wrksht Is Nothing Or wrkbk Is Nothing Or para Is Nothing Then
        GoTo ExitIt
    End If
    
    Set outrge = wrksht.Range(toXlA1str(strGrpOut))
    Set dataRge = wrksht.Range(toXlA1str(strGrpData))

    bTotal = CBool(para("bTotal"))
    bN = CBool(para("bN"))
    bAvg = CBool(para("bAvg"))
    dBoLength = CDbl(para("dBoLength"))
    dBoWidth = CDbl(para("dBoWidth"))
    dBoMojiH = CDbl(para("dBoMojiH"))
    nDatalabDsp = CInt(para("nDataLabDsp"))
    bTotalDsp = CBool(para("bTotalDsp"))
    strTName = Trim(para("tName"))
    strYName = Trim(para("yName"))
    strXName = Trim(para("xName"))
    Set para = Nothing
    Set ObiGrp = New clsObiGrp
    Call ObiGrp.DrawGraph(outrge, dataRge, bTotal, bN, bAvg, bTotalDsp, _
                          dBoLength, dBoWidth, dBoMojiH, nDatalabDsp, _
                          strTName, strYName, strXName)
    Set ObiGrp = Nothing
ExitIt:
    Application.ScreenUpdating = True
    On Error GoTo 0
End Sub


'=== EOF ===


Attribute VB_Name = "mdlCallBack"
'=======================================================
' VBA Interface For C
'
' 2009.06 WZH
'=======================================================
Option Explicit

#If Win64 Then
Type VBA_CELLFUNC
    pGetCell As Longlong
    pSetCell As Longlong
    pGetValues As Longlong
    pSetValues As Longlong
End Type
#Else
Type VBA_CELLFUNC
    pGetCell As Long
    pSetCell As Long
    pGetValues As Long
    pSetValues As Long
End Type
#End If

Function ConvertString(ByVal strVal As Variant) As String
    Dim i As Long
    Dim ascVal As Long
    Dim tmpstr As String
    Dim maxVal As Long, minVal As Long
    Dim b() As Byte
    If strVal = vbNullString Then
        ConvertString = vbNullString
        Exit Function
    End If
    maxVal = Abs(AscW(Mid(strVal, 1, 1)))
    For i = 1 To Len(strVal)
        ascVal = Abs(AscW(Mid(strVal, i, 1)))
        If ascVal > maxVal Then
            maxVal = ascVal
        End If
        If maxVal > 255 Then
            ConvertString = StrConv(strVal, vbUnicode)
            Exit Function
        End If
    Next i
    tmpstr = vbNullString
    If maxVal > 127 Then
        b = strVal
        For i = LBound(b) To UBound(b)
            tmpstr = tmpstr & Chr(b(i))
        Next i
    Else
        tmpstr = strVal
    End If
    ConvertString = tmpstr
End Function

Private Function bUnicodeInString(ByVal key As String) As Boolean
    Dim i As Long
    For i = 1 To Len(key)
        If Abs(AscW(Mid(key, i, 1))) > 128 Then     '2010.01.19 mdf: > 255
            bUnicodeInString = True
            Exit Function
        End If
    Next i
    bUnicodeInString = False
End Function

Function bValidString(ByVal key As Variant) As Boolean
#If 1 Then
    bValidString = (Trim(key) <> vbNullString And Not IsNumeric(key) And Not IsEmpty(key) And Not IsNull(key) And VarType(key) = vbString)
#Else
    bValidString = (Not IsEmpty(key) And Not IsNull(key))
#End If
End Function

Function GetCellStr(ByVal row As Long, ByVal col As Long) As Variant
    GetCellStr = "{" & ActiveSheet.Name & "!R" & row + 1 & "C" & col + 1 & "}"
End Function

Function subGetCellStr(ByVal strRef As String) As String
    Dim rgeRef As Range
    Dim shtRef As Worksheet
    Dim strFmt As String, strSht As String
    Dim ref As Variant
    On Error GoTo err_handler
    If InStr(1, strRef, "!") > 0 Then
        ref = Split(strRef, "!")
        strSht = ref(0)
        strFmt = ref(1)
        Set shtRef = Worksheets(strSht)
    Else
        strFmt = strRef
        Set shtRef = ActiveSheet
    End If
    strFmt = toXlA1str(strFmt)
    Set rgeRef = shtRef.Range(strFmt)
    subGetCellStr = rgeRef.Value
exit_function:
    On Error GoTo 0
    Exit Function
err_handler:
    subGetCellStr = strRef
    Resume exit_function
End Function

Function SetCellStr(ByVal strRef As String, ByVal row As Long, ByVal col As Long) As Boolean
    Dim i As Integer, j As Integer
    Dim str As String, setStr As String
    Dim refs As Variant, ref As Variant
    str = strRef
    refs = Split(str, "{")
    setStr = vbNullString
    For i = LBound(refs) To UBound(refs)
        If refs(i) <> vbNullString Then
            ref = Split(refs(i), "}")
            setStr = setStr & subGetCellStr(ref(0))
            For j = LBound(ref) + 1 To UBound(ref)
                setStr = setStr & ref(j)
            Next j
        End If
    Next i
    Cells(row + 1, col + 1) = setStr
    SetCellStr = True
End Function

Function GetCellString(ByVal row As Long, ByVal col As Long) As Variant
    Static var As Variant
    Dim key As Variant
    Dim cnt As Long
    var = Cells(row + 1, col + 1)
    key = CStr(var)
    If bUnicodeInString(key) Then var = AddKey(key)
    GetCellString = CStr(var)
End Function

Function SetCellString(strVal As Variant, ByVal row As Long, ByVal col As Long) As Long
    Dim key As Variant, keys As Variant, items As Variant
    Dim i As Long
    'key = CStr(strVal)
    key = ConvertString(strVal)
    'If bValidString(key) Then
        If IsPartTextInCollection(key) Then
            If IsTextInCollection(key) Then
                Cells(row + 1, col + 1) = GetTextFromCollection(key)
            Else
                key = ReplaceTextInCollection(key)
                Cells(row + 1, col + 1) = key
            End If
        Else
            'If bUnicode(strVal) Then
                Cells(row + 1, col + 1) = ConvertString(strVal)
            'Else
            '    Cells(row + 1, col + 1) = strVal
            'End If
        End If
    'Else
    '    Cells(row + 1, col + 1) = strVal
    'End If
End Function

#If Win64 Then
Private Function GetAddr(ByVal addr As Longlong) As Longlong
    GetAddr = addr
End Function
#Else
Private Function GetAddr(ByVal addr As Long) As Long
    GetAddr = addr
End Function
#End If

Function NU_GetValues(strBook As Variant, strSheet As Variant, strRge As Variant) As Variant
    Dim rge As Range
    Set rge = Workbooks(strBook).Worksheets(strSheet).Range(strRge)
    NU_GetValues = rge
End Function

Function GetValues(strRge As Variant) As Variant
    Dim rge As Range
    Dim str As String
    Static var As Variant
    Dim key As Variant
    Dim i As Long, j As Long
    str = strRge
    str = toXlA1str(str)
    Set rge = Range(str)
    var = rge.Value
    If rge.Count = 1 Then
        key = CStr(var)
        If bUnicodeInString(key) Then var = AddKey(key)
    Else
        For i = 1 To rge.Rows.Count
            For j = 1 To rge.Columns.Count
                key = CStr(var(i, j))
                If bUnicodeInString(key) Then var(i, j) = AddKey(key)
            Next j
        Next i
    End If
    GetValues = var
End Function

Function SetValues(strRge As Variant, vData As Variant) As Long
    Dim rge As Range
    Dim str As String
    Dim var As Variant
    Dim i As Long, j As Long
    Dim minRow, maxRow
    Dim minCol, maxCol
    
    str = strRge
    str = toXlA1str(str)
    Set rge = Range(str)
    If Not IsEmpty(vData) Then
        If IsArray(vData) Then
            minRow = LBound(vData, 1)
            maxRow = UBound(vData, 1)
            minCol = LBound(vData, 2)
            maxCol = UBound(vData, 2)
            For i = minRow To maxRow
                For j = minCol To maxCol
                    'var = CStr(vData(i, j))
                    var = ConvertString(vData(i, j))
                    'If bValidString(var) Then
                        If IsTextInCollection(var) Then
                            vData(i, j) = GetTextFromCollection(var)
                        ElseIf IsPartTextInCollection(var) Then
                            vData(i, j) = ReplaceTextInCollection(var)
                        End If
                    'End If
                Next j
            Next i
        Else
            'var = CStr(vData)
            var = ConvertString(vData)
            If IsTextInCollection(var) Then
                vData = GetTextFromCollection(var)
            ElseIf IsPartTextInCollection(var) Then
                vData = ReplaceTextInCollection(var)
            End If
        End If
    End If
    rge = vData
    SetValues = 1
End Function

#If Win64 Then
Function GetVbaInterface() As Longlong
    Static pFunc As VBA_CELLFUNC    '09.6.11 LSQ mdf
    Call InitCollection
    pFunc.pGetCell = GetAddr(AddressOf GetCellString)
    pFunc.pSetCell = GetAddr(AddressOf SetCellString)
    pFunc.pGetValues = GetAddr(AddressOf GetValues)
    pFunc.pSetValues = GetAddr(AddressOf SetValues)
    GetVbaInterface = VarPtr(pFunc)
End Function

Static Function GetThisXL() As Longlong
    Static pApp As Longlong
    pApp = ObjPtr(Application)
    GetThisXL = pApp
End Function

#Else
Function GetVbaInterface() As Long
    Static pFunc As VBA_CELLFUNC    '09.6.11 LSQ mdf
    Call InitCollection
    pFunc.pGetCell = GetAddr(AddressOf GetCellString)
    pFunc.pSetCell = GetAddr(AddressOf SetCellString)
    pFunc.pGetValues = GetAddr(AddressOf GetValues)
    pFunc.pSetValues = GetAddr(AddressOf SetValues)
    GetVbaInterface = VarPtr(pFunc)
End Function

Static Function GetThisXL() As Long
    Static pApp As Long
    pApp = ObjPtr(Application)
    GetThisXL = pApp
End Function
#End If

Sub ReleaseInterface()
    Call ReleaseCollection
End Sub

'===== EOF =====

Attribute VB_Name = "mdlGraph"

Attribute VB_Name = "mdlInfoSht"
'=================================================
' Info Sheet Management Functions
'
' Date: 2007.1.30 -- 2007.2.7 LSQ
' Mdf : 10.6.1 LSQ, 11.5.26 LSQ
'=================================================
Option Explicit
Option Private Module 'Can be run as in Application.Run

'Public Const INFO_CallCnt As Integer = 1   '11.5.26 LSQ cmt; not used

'
'get cell position in sheet "Info"
'
'flg : 1 = Called Count (A3)
'      2 = Version Number (A4)
'
Function getRgeObj(ByVal flg As Integer) As Range
    Set getRgeObj = Nothing
    
    If flg = 1 Then
        Set getRgeObj = ThisWorkbook.Worksheets("Info").Range("A3") 'should not write as "stObj.Range("A3")", error in "TaikouKsk.xls", 10.6.1 LSQ
    End If
    
    If flg = 2 Then
        Set getRgeObj = ThisWorkbook.Worksheets("Info").Range("A4")
    End If

End Function
'
'10.6.1 LSQ add
'
Private Function AddOne_or_DecOne(ByVal bAdd As Boolean) As Integer
    Dim cnt As Integer, cel As Range
    Set cel = getRgeObj(1)
    cnt = CInt(cel)
    cnt = IIf(bAdd, cnt + 1, cnt - 1)
    cel = cnt
    '
    AddOne_or_DecOne = cnt
End Function
'
'count + 1
Function CallNum_AddOne() As Integer
    CallNum_AddOne = AddOne_or_DecOne(True)
End Function

'count - 1
Function CallNum_DecOne() As Integer
    CallNum_DecOne = AddOne_or_DecOne(False)
End Function

'=== EOF ===


Attribute VB_Name = "mdlPrvA"
'=================================================
' VBA Common Functions
'
' Date : 2007.2 - 2007.3 LSQ, WZH
'=================================================
Option Explicit
Option Private Module

Function decNumKeta(ByVal diff As Double) As Integer
    diff = Abs(diff)
    
    If (diff >= 10) Then decNumKeta = 0: Exit Function
    If (diff >= 1) Then decNumKeta = 1: Exit Function
    If (diff >= 0.1) Then decNumKeta = 2: Exit Function
    If (diff >= 0.01) Then decNumKeta = 3: Exit Function
    If (diff >= 0.001) Then decNumKeta = 4: Exit Function
    decNumKeta = 5
End Function

Function vbaRound(dblValue As Double, intDecimals As Integer, _
    Optional RoundingOption As Integer = 0) As Double
    Dim dblPlacesFactor As Double
    Dim dlbRoundFactor As Double
     
    If intDecimals < 0 Then
        vbaRound = 0
        Exit Function
    End If
     
    dblPlacesFactor = 10 ^ intDecimals
     
    Select Case RoundingOption
    Case 0 'Round to Nearest
        dlbRoundFactor = 0.5
    Case 1 'Round UP
        dlbRoundFactor = 1
    Case 2 'Round DOWN
        dlbRoundFactor = 0
    End Select
     
    vbaRound = Int(dblValue * dblPlacesFactor + dlbRoundFactor) / dblPlacesFactor
End Function
'=== EOF ===


Attribute VB_Name = "mdlPubA"
'=================================================
' VBA Common Functions : Public Module
'
' Date : 2007.2.1 LSQ
'=================================================
Option Explicit

'07.1.28
Function getExcelVerNo() As Integer
    getExcelVerNo = val(Application.Version) 'VerNo = 10.1, 12.2 etc exists
    '12 = Excel2007
    '11 = Excel2003
    '10 = Excel2002 (or XP)
    '9  = Excel2000
End Function

'Set data labels for a series
'Based on SonyStat_3P6\subhsk.xla
Sub SetDataLabel(ByVal ser As Series, ByVal namerge As Range, _
                 Optional ByVal fontsize As Integer = 10, _
                 Optional ByVal charcnt As Integer = 32)
    Dim i As Integer
    On Error Resume Next
    ser.ApplyDataLabels Type:= _
            xlDataLabelsShowLabel, AutoText:=True, LegendKey:=False
    ser.DataLabels.Font.Size = fontsize
    For i = 1 To ser.Points.Count
        If CInt(Application.Version) < 12 Then
            ser.Points(i).DataLabel.Characters.text = Mid(namerge(i, 1).Value, 1, charcnt) '10.11.10 LSQ mdf : old use "MidB"
        Else
            ser.Points(i).DataLabel.text = Mid(namerge(i, 1).Value, 1, charcnt) '10.11.10 LSQ mdf : old use "MidB"
        End If
    Next i
    On Error GoTo 0
End Sub

'|fffd|}|fffd||308||292|u|fffd||183|T|fffd|C|fffd|Y
'07.1.30 copied from SSSMCTH1.xls (\MAC04)
'2007.03.05 modified for revising the position in a zoomed worksheet
Sub setChartPosSize(ByVal chartObj As ChartObject, ByVal outGrp As Range, _
    Optional ByVal rownum As Integer = 0, Optional ByVal colnum As Integer = 0)
    Dim oldzoom As Integer
    If rownum <= 0 Then rownum = 16
    If colnum <= 0 Then colnum = 8
    On Error Resume Next
    chartObj.parent.Activate
    oldzoom = ActiveWindow.Zoom
    ActiveWindow.Zoom = 100
    chartObj.left = outGrp.left   '+ 10
    chartObj.top = outGrp.top     '+ 10
    chartObj.width = outGrp.Offset(0, colnum).left - outGrp.left
    chartObj.height = outGrp.Offset(rownum, 0).top - outGrp.top
    
    '10.12.7 LSQ add; for XL07, XL10, plotArea not adjusted acorrding to ChartObject
    If getExcelVerNo >= 12 Then 'for Excel2007, Excel2010
        Dim wdCht As Double, wdObj As Double
        
        wdCht = chartObj.Chart.PlotArea.width
        wdObj = chartObj.width
        If wdObj <= wdCht + 10 Then
            chartObj.Chart.PlotArea.width = wdObj - 10
        End If
    End If
    '10.12.7 LSQ add end
    
#If 0 Then '10.10.4 LSQ cmt : error if no chartTitle, not good for |fffd|U|fffd|z|fffd|}
    '10.10.01 DZH add
    'adjust the Chart size in Excel2007 or Excel2010
    If getExcelVerNo >= 12 Then
        ActiveChart.ChartArea.Select
        With ActiveChart.PlotArea
            .top = ActiveChart.ChartTitle.top + 20
            .height = chartObj.height - ActiveChart.PlotArea.top * 1.3
        End With
    End If
#End If

    ActiveWindow.Zoom = oldzoom
    On Error GoTo 0
End Sub

'Copy a template chart from a worksheet to defined cell
'Nothing will be returned if failure occurs
Function GetTmplGrp(ByVal outrge As Range, ByVal strBkName As String, _
                    ByVal strShtName As String, ByVal strGrpName As String) As Chart
    Dim wrksht As Worksheet
    
    Set GetTmplGrp = Nothing
    On Error GoTo ExitIt
    Set wrksht = outrge.Worksheet

#If 0 Then  '10.10.4 LSQ mdf
'Note: |fffd|C|fffd||fffd||fffd||fffd||fffd|R
'1. ChartObject.Copy may not work in Excel2010 (10.09.07 DZH)
'2. ChartObject.Copy,  the result Chart's 2nd axis can't be selected (TaikouV5!SR2! 2|fffd|Q DotPlot)
'
    Workbooks(strBkName).Worksheets(strShtName).ChartObjects(strGrpName).Copy
#Else
    Workbooks(strBkName).Worksheets(strShtName).Activate
    ActiveSheet.ChartObjects(strGrpName).Activate
    ActiveChart.ChartArea.Copy
#End If '10.10.4 end
    
    wrksht.Activate
    outrge.Select
    wrksht.Paste
    Set GetTmplGrp = Selection.parent
ExitIt:
    On Error GoTo 0
End Function

'Set a dictionary for parameters string whick is divided by '&', e.g. 'GrpType=2&FontSize=10'
Function SetDict(ByVal strPara As String) As Object
    Dim arys() As String, subarys() As String
    Dim s As String
    Dim i As Integer, j As Integer
    Dim dict As Object
    Set SetDict = Nothing
    On Error Resume Next
    arys = Split(strPara, "&")
    Set dict = CreateObject("Scripting.dictionary")
    For i = 0 To UBound(arys)
        subarys = Split(arys(i), "=")
        dict(subarys(0)) = subarys(1)
    Next i
    Set SetDict = dict
ExitIt:
    Set dict = Nothing
    On Error GoTo 0
End Function

'Copied from commMdl in SSS_STAT.xla
'H12.8.28 mdf LSQ : on error added
'
Function toXlRCstr(inputFormula As String) As String
    Dim inx As Long
    Dim str As String, tmpFormula As String
    tmpFormula = Replace(inputFormula, "'", "")
    inx = InStr(1, tmpFormula, "!")
    str = Mid(tmpFormula, inx + 1)
    
    On Error Resume Next
    
    toXlRCstr = Application.ConvertFormula( _
                Formula:=str, _
                fromReferenceStyle:=xlA1, _
                toReferenceStyle:=xlR1C1)
    
    If Err.Number <> 0 Then
        toXlRCstr = inputFormula
        Err.Clear
        Exit Function
    End If
    
    If inx > 1 And InStr(1, toXlRCstr, "!") < 1 Then
        toXlRCstr = "'" & Mid(tmpFormula, 1, inx - 1) & "'!" & toXlRCstr
    End If
    
    On Error GoTo 0
End Function

'Copied from commMdl in SRKV2P5(SRKMAIN.xla)
Function toXlA1str(inputFormula As String) As String
    Dim inx As Long
    Dim str As String, tmpFormula As String
    tmpFormula = Replace(inputFormula, "'", "")
    inx = InStr(1, tmpFormula, "!")
    str = Mid(tmpFormula, inx + 1)
    On Error Resume Next
    toXlA1str = Application.ConvertFormula( _
                Formula:=str, _
                fromReferenceStyle:=xlR1C1, _
                toReferenceStyle:=xlA1)
    If Err.Number <> 0 Then
        toXlA1str = inputFormula
        Err.Clear
        Exit Function
    End If
    If inx > 1 And InStr(1, toXlA1str, "]") < 1 Then
        toXlA1str = "'" & Mid(tmpFormula, 1, inx - 1) & "'!" & toXlA1str
    End If
    On Error GoTo 0
End Function

Sub AdjustMinMax(ByRef minV As Double, ByRef maxV As Double, Optional ByVal MaxDecimalNum As Integer = -1)
    Dim keta As Integer
    Dim tmpd As Double, min As Double, max As Double
    
    tmpd = (maxV - minV) / 20
    keta = decNumKeta(maxV - minV)
    If MaxDecimalNum >= 0 And keta > MaxDecimalNum Then
        keta = MaxDecimalNum
    End If
    max = maxV + tmpd
    min = minV - tmpd
    maxV = vbaRound(max, keta, 1)
    minV = vbaRound(min, keta, 2)
End Sub

Sub SetAxisMinMax(ByVal axisObj As Axis, ByVal minV As Double, ByVal maxV As Double, Optional ByVal DecimalPlaces As Integer = -1)
    Call AdjustMinMax(minV, maxV, DecimalPlaces)
    axisObj.MinimumScaleIsAuto = False
    axisObj.MinimumScale = minV
    axisObj.MaximumScaleIsAuto = False
    axisObj.MaximumScale = maxV
End Sub

Function MatchWorkbookFont()
    On Error Resume Next
    
    Selection.Font.Name = ActiveWorkbook.Styles("Normal").Font.Name
    Selection.Font.Size = ActiveWorkbook.Styles("Normal").Font.Size
    Selection.AutoScaleFont = True
    
    On Error GoTo 0
End Function

Sub SetTicks(ByVal cht As Chart, ByVal strTicks As String)
    Dim i As Integer, j As Integer
    Dim Ticks() As String
    Dim bRevStatus As Boolean
    Dim xSeries As Series
    Dim CateCnt As Integer
    Dim CateNum As Integer
    Dim cates() As Integer
    Dim MaxScale As Double, MinScale As Double
    Dim bScreenUpdating As Boolean
    On Error Resume Next
    bScreenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = False
    bRevStatus = cht.Axes(xlCategory).ReversePlotOrder
    If bRevStatus Then
        cht.Axes(xlCategory).ReversePlotOrder = False
        strTicks = StrReverse(strTicks)
    End If
    Ticks = Split(strTicks, ",")
    CateNum = 0
    CateCnt = UBound(Ticks)
    ReDim cates(1 To CateCnt)
    For i = 1 To CateCnt
        CateNum = CateNum + CInt(Ticks(i - 1))
        cates(i) = CInt(Ticks(i - 1))
        For j = 1 To i - 1
            cates(i) = cates(i) + CInt(Ticks(j - 1))
        Next j
    Next i
    CateNum = CateNum + CInt(Ticks(CateCnt))
    Set xSeries = cht.SeriesCollection.NewSeries
    xSeries.Name = "tick1"
    xSeries.ChartType = xlXYScatterLinesNoMarkers
    With cht.Axes(xlValue, xlSecondary)
        .MinimumScale = 0
        .MaximumScale = CateNum
        .MinorUnitIsAuto = True
        .MajorUnit = 1
    End With
    MaxScale = cht.Axes(xlValue, xlPrimary).MaximumScale
    MinScale = cht.Axes(xlValue, xlPrimary).MinimumScale
    cht.Axes(xlValue, xlPrimary).MaximumScaleIsAuto = False
    cht.Axes(xlValue, xlPrimary).MinimumScaleIsAuto = False
    cht.Axes(xlValue, xlPrimary).MaximumScale = MaxScale
     cht.Axes(xlValue, xlPrimary).MinimumScale = MinScale
    cht.Axes(xlCategory, xlSecondary).MinimumScale = MinScale
    cht.Axes(xlCategory, xlSecondary).MaximumScale = MaxScale
    xSeries.XValues = "={" & MinScale & "," & MaxScale & "}"
    xSeries.Values = "={" & cates(1) & "," & cates(1) & "}"
    xSeries.Border.colorindex = 1
    xSeries.Border.LineStyle = xlDot
    xSeries.Border.Weight = xlThin
    xSeries.MarkerStyle = xlNone
    For i = 2 To CateCnt
        Set xSeries = cht.SeriesCollection.NewSeries
        xSeries.ChartType = xlXYScatterLinesNoMarkers
        xSeries.Name = "tick" & i
        xSeries.XValues = "={" & MinScale & "," & MaxScale & "}"
        xSeries.Values = "={" & cates(i) & "," & cates(i) & "}"
        xSeries.Border.colorindex = 1
        xSeries.Border.LineStyle = xlDot
        xSeries.Border.Weight = xlThin
        xSeries.MarkerStyle = xlNone
    Next i
    
    cht.Axes(xlValue, xlSecondary).Delete
    cht.Axes(xlCategory, xlSecondary).Delete
    cht.Axes(xlCategory).Select
    cht.Axes(xlCategory).ReversePlotOrder = bRevStatus
    Application.ScreenUpdating = bScreenUpdating
    On Error GoTo 0
End Sub

'=== EOF ===


Attribute VB_Name = "mdlPubB"
Attribute VB_Name = "mdlStartEnd"
'=======================================================
' VBA Common Functions : Start & End
'
' 2007.1.30 LSQ
'=======================================================
Option Explicit

Sub Auto_open()
    getRgeObj(1) = 0 'init
End Sub

'=== EOF ===

Attribute VB_Name = "mdlUnicodeText"
Option Explicit

Private Const TEXTHEAD As String = "__TKO__"
Private Const TEXTTAIL As String = "_T_"

Private TextCollection As Collection
Private KeyCollection As Collection

Public Function IsKeyInCollection(ByVal TestCollection As Collection, ByVal key As Variant) As Boolean
   Dim Value As Variant
   IsKeyInCollection = True
   On Error Resume Next
   Value = TestCollection(key)
   If IsEmpty(Value) Then
      Set Value = TestCollection(key)
      If Value Is Nothing Then
         IsKeyInCollection = False
      End If
   End If
End Function

Public Function AddKey(ByVal key As Variant) As Variant
    Dim cnt As Long
    Dim var As Variant
    If VarType(key) <> vbString Then
        var = CStr(key)
    Else
        var = key
    End If
    cnt = KeyCollection.Count + 1
    If Not IsKeyInCollection(TextCollection, var) Then
        TextCollection.Add TEXTHEAD & cnt & TEXTTAIL, var
        KeyCollection.Add var, TEXTHEAD & cnt & TEXTTAIL
    End If
    AddKey = TextCollection(var)
End Function

Public Function IsTextInCollection(ByVal text As Variant) As Boolean
    IsTextInCollection = IsKeyInCollection(KeyCollection, text)
End Function

Public Function GetTextFromCollection(ByVal key As Variant) As Variant
    GetTextFromCollection = KeyCollection(key)
End Function

Public Function IsPartTextInCollection(ByVal text As Variant) As Boolean
    Dim RE As Object, REMatches As Object
    Set RE = CreateObject("vbscript.regexp")
    With RE
        '.MultiLine = False
        .Global = False
        .IgnoreCase = True
        .Pattern = TEXTHEAD & "[0-9]{1,}" & TEXTTAIL
    End With
    Set REMatches = RE.Execute(text)
    IsPartTextInCollection = IIf(REMatches.Count > 0, True, False)
End Function

Function GetAllTags(strData As Variant) As Object
    Dim RE As Object
    Set RE = CreateObject("vbscript.regexp")
    With RE
        '.MultiLine = False
        .Global = True
        .IgnoreCase = True
        .Pattern = TEXTHEAD & "[0-9]{1,}" & TEXTTAIL
    End With
    Set GetAllTags = RE.Execute(strData)
End Function

Public Function ReplaceTextInCollection(ByVal text As Variant) As Variant
    Dim i As Long
    Dim var As Variant
    Dim AllTags As Object
    var = text
    Set AllTags = GetAllTags(var)
    For i = 0 To AllTags.Count - 1
        var = Replace(var, AllTags.Item(i), KeyCollection(AllTags.Item(i))) '10.4.23 LSQ mdf : IE5.0 |fffd||389||fffd|
    Next
    ReplaceTextInCollection = var
End Function

Sub InitCollection()
    Set TextCollection = New Collection
    Set KeyCollection = New Collection
End Sub

Sub ReleaseCollection()
    Set TextCollection = Nothing
    Set KeyCollection = Nothing
End Sub



INQUEST-PP=macro
