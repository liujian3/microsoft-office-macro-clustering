Attribute VB_Name = "CCIExport"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public n As Long
Public wk As Workbook

Public sAnlagenProjekt As String

Public colNewCIsListe As Collection

Private Sub Class_Initialize()
    Set colNewCIsListe = New Collection
End Sub
Attribute VB_Name = "CCIGeneration"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public rDefinition As Range
Public rData As Range

'V3.10
Private oT91 As CT91

'V3.3
'V4.11
'Private sData As String

Public nDefinitionLine As Long
Public nDataLine As Long

Private Const nCellPosSheet = 1
Private Const nCellPosGUID = 2
Private Const nCellPosRange = 3
Private Const nCellPosPK = 4
Private Const nCellPosKey = 5
Private Const nCellPosCondition = 6
Private Const nCellPosCIType = 7
Private Const nCellPosDefUnique = 8

'V4.11
'Private Const nCellPosCheckIfComplete = 9
Private Const nCellPosIgnoreCondition = 9

Private Const nCellPosPropertyStart = 10

'LookupDefinition
Private Const nCellPosLookupRange = 4
Private Const nCellPosLookupGUID = 6
Private Const nCellPosLookupStart = 7
Private Const nCellPosLookupAddValues = 8
Private Const nCellPosLookupValueStart = 9

Public Function GetDefUnique() As Boolean
    GetDefUnique = (rDefinition.Cells(nDefinitionLine, nCellPosDefUnique) <> "")
End Function

Public Function GetCellPosLookupRange() As Long
    GetCellPosLookupRange = nCellPosLookupRange
End Function

Public Function GetCellPosSheet() As Long
    GetCellPosSheet = nCellPosSheet
End Function

Public Function GetCellPosRange() As Long
    GetCellPosRange = nCellPosRange
End Function


Public Function GetCellPosGUID() As Long
    GetCellPosGUID = nCellPosGUID
End Function
    
Public Function GetCellPosKey() As Long
    GetCellPosKey = nCellPosKey
End Function

'V3.3
'Public Sub Init(rDef As Range, nDef As Long, rDat As Range, nDat As Long)
Public Sub Init(rDef As Range, nDef As Long, sDat As String, nDat As Long)
    Set rDefinition = rDef
    'V3.3
    'set rData = rDat
    
    'V4.11
    'Set rData = Range(sDat)
    'sData = sDat
    Set rData = Range2(rDef.Cells(nDef, nCellPosSheet) & "#" & sDat)
    
    
    nDefinitionLine = nDef
    nDataLine = nDat
    
    'V3.10
    Set oT91 = New CT91
    oT91.Init rDef, nDef, sDat, nDat
    
    
End Sub

Private Function GetSheetName() As String
    GetSheetName = rDefinition.Cells(nDefinitionLine, nCellPosSheet)
End Function

Public Function GetGUID() As String
    GetGUID = oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, nCellPosGUID))
End Function
Private Sub SetGUID(s As String)
    oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, nCellPosGUID)) = s
End Sub


Public Function GetKey() As String
    GetKey = oT91.t91(nCellPosKey)
End Function

'V4.11
Public Function IgnoreLine() As Boolean
    If (rDefinition.Cells(nDefinitionLine, nCellPosIgnoreCondition) = "") Or (rDefinition.Cells(nDefinitionLine, nCellPosIgnoreCondition) = "1") Then
        IgnoreLine = False
    Else
        IgnoreLine = oT91.t91(nCellPosIgnoreCondition)
    End If
End Function

Public Function IsKeyComplete() As Boolean
    If rDefinition.Cells(nDefinitionLine, nCellPosCondition) = "" Then
        IsKeyComplete = oT91.T91Complete(nCellPosKey)
    Else
        'V3.10
        'IsKeyComplete = Evaluate(oT91.T91i(nCellPosCondition))
        IsKeyComplete = oT91.t91(nCellPosCondition)
    End If
End Function


Sub UpdateLookup()
    Dim sKey As String
    Dim sGUID As String
    Dim sGUID2 As String

    sKey = GetKey
    sGUID = GetGUID
    
    If sKey = "" Then
        If sGUID <> "" Then
            SetGUID ""
            
            
        End If
        ClearAdditionalValues
    Else
        sGUID2 = GetLookupGUID(Range("" & rDefinition.Cells(nDefinitionLine, nCellPosLookupRange)), sKey)
        If sGUID2 <> sGUID Then
            SetGUID sGUID2
            
        Else
            
        End If
        SetAdditionalValues sGUID2
    End If

End Sub

Sub ClearAdditionalValues()
    Dim i As Long
    If rDefinition.Cells(nDefinitionLine, nCellPosLookupAddValues) <> "" Then
        If oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, nCellPosLookupAddValues)) <> "" Then
            Exit Sub
        End If
    End If
        
    For i = nCellPosLookupValueStart To rDefinition.Columns.Count
        If rDefinition.Cells(nDefinitionLine, i) <> "" Then
            If oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, i)) <> "" Then
                oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, i)) = ""
            End If
        End If
    Next
End Sub

Sub SetAdditionalValues(sGUID As String)
    Dim i As Long
    If rDefinition.Cells(nDefinitionLine, nCellPosLookupAddValues) <> "" Then
        If oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, nCellPosLookupAddValues)) <> "" Then
            Exit Sub
        End If
    End If
    
    For i = nCellPosLookupValueStart To rDefinition.Columns.Count
        If rDefinition.Cells(nDefinitionLine, i) <> "" Then
            If oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, i)) <> GetLookupValue(Range("" & rDefinition.Cells(nDefinitionLine, nCellPosLookupRange)), sGUID, i - nCellPosLookupValueStart + 1) Then
                oT91.GetDataCell(rDefinition.Cells(nDefinitionLine, i)) = GetLookupValue(Range("" & rDefinition.Cells(nDefinitionLine, nCellPosLookupRange)), sGUID, i - nCellPosLookupValueStart + 1)
            End If
        End If
    Next
End Sub


Function RefreshLookupName()
    Dim sKey As String
    Dim sKey2 As String
    Dim sGUID As String
    
    sKey = GetKey
    sGUID = GetGUID
    
    If sGUID = "" Then
        If sKey <> "" Then
            ClearKey
            ClearAdditionalValues
            
        End If
    Else
        sKey2 = GetLookupKey(Range("" & rDefinition.Cells(nDefinitionLine, nCellPosLookupRange)), sGUID)
        If sKey2 <> sKey Then
            SetKey sKey2
            
        End If
        
        SetAdditionalValues sGUID
        
    End If
End Function

Sub ClearKey()
    Dim r As Range
    Set r = UpdateableKeyRange
    If Not r Is Nothing Then
        r.Cells(1, 1) = ""
    End If
End Sub

Sub SetKey(sKey As String)
    Dim r As Range
    Set r = UpdateableKeyRange
    If Not r Is Nothing Then
        r.Cells(1, 1) = sKey
    End If
End Sub

Function UpdateableKeyRange() As Range
    Dim sKeyDef As String
    sKeyDef = rDefinition.Cells(nDefinitionLine, nCellPosKey)
    If Len(sKeyDef) > 2 Then
        If Left(sKeyDef, 1) = "[" And Right(sKeyDef, 1) = "]" Then
            sKeyDef = Left(sKeyDef, Len(sKeyDef) - 1)
            sKeyDef = Mid(sKeyDef, 2)
            If InStr(sKeyDef, "[") = 0 Then
                Set UpdateableKeyRange = oT91.GetDataCell(sKeyDef)
            End If
        End If
    End If
End Function


Function GetLookupGUID(r As Range, sKey As String) As String
    Dim i As Long
    For i = rDefinition.Cells(nDefinitionLine, nCellPosLookupStart) To r.rows.Count
        If r.Cells(i, 1) = "" Then Exit For
        If UCase(r.Cells(i, 1)) = UCase(sKey) Then
            GetLookupGUID = "" & r.Cells(i, rDefinition.Cells(nDefinitionLine, nCellPosLookupGUID))
        End If
    Next
End Function

Function GetLookupKey(r As Range, sGUID As String) As String
    Dim i As Long
    For i = rDefinition.Cells(nDefinitionLine, nCellPosLookupStart) To r.rows.Count
        If r.Cells(i, 1) = "" Then Exit For
        If UCase(r.Cells(i, rDefinition.Cells(nDefinitionLine, nCellPosLookupGUID))) = UCase(sGUID) Then
            GetLookupKey = "" & r.Cells(i, 1)
        End If
    Next
End Function

Function GetLookupValue(r As Range, sGUID As String, number As Long) As String
    Dim i As Long
    For i = rDefinition.Cells(nDefinitionLine, nCellPosLookupStart) To r.rows.Count
        If r.Cells(i, 1) = "" Then Exit For
        If UCase(r.Cells(i, rDefinition.Cells(nDefinitionLine, nCellPosLookupGUID))) = UCase(sGUID) Then
            GetLookupValue = "" & r.Cells(i, 2 + number)
            Exit Function
        End If
    Next
End Function

'V2.3
Private Function GetPropertyValue(nDefcol As Long)
    GetPropertyValue = oT91.t91(nDefcol)
End Function

Sub UpdateProperty(nDefcol As Long, nCILine As Long)
    If (rDefinition.Cells(1, nDefcol) <> "") And (rDefinition.Cells(nDefinitionLine, nDefcol) <> "") Then
        Dim v As Variant
        v = GetPropertyValue(nDefcol)
        
        'Flags werden immer nur mit logischen Operatoren bearbeitet, damit sich Definitionen welche auf die gleiche Zeile wirken nicht gegenseitig unterschiedliche Flags |fffd|berschreiben, glaube ich
        If rDefinition.Cells(1, nDefcol) = "Flags" Then
            Dim nValue As Long
            
            If Left(v, 3) = "or " Then
                nValue = GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, nDefcol), nCILine) Or CLng(Mid(v, 4))
            ElseIf Left(v, 8) = "and not " Then
                nValue = GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, nDefcol), nCILine) And Not CLng(Mid(v, 9))
            Else
                Addlog "Flags: Operation not Supported!"
            End If
            v = nValue
        End If
        
        
        If GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, nDefcol), nCILine) <> v Then
            GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, nDefcol), nCILine) = v
        End If
        
    End If
End Sub

Function UpdateCI() As Boolean

    Dim sKey As String
    Dim sOldKey As String
    Dim sGUID As String
    
    sKey = GetKey
    sGUID = GetGUID
    
    Dim x1 As Long
    x1 = GetBestandslineByGUID(sGUID)
    
    Dim i As Long
    
    'V1.985
    'If x1 = -1 Then Exit Sub
    If x1 = -1 Then
        'CI Neuanlagen, weil die - Defintion m|fffd|glicherweise irrt|fffd|mlich - gel|fffd|scht wurde
        CreateCI
        Exit Function
    End If
    
    
    If sKey = GetCellByTitle("bestandsliste_CIKey", x1) Then
        'eigenschaften aktualisieren
        For i = nCellPosPropertyStart To rDefinition.Columns.Count
            UpdateProperty i, x1
'            If (rDefinition.Cells(1, i) <> "") And (rDefinition.Cells(nDefinitionLine, i) <> "") Then
'                If GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, i), x1) <> T91(i) Then
'                    GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, i), x1) = T91(i)
'                End If
'            End If
        Next
        SetPKFields x1
        
    Else
    
        Dim x2 As Long
        
        If Not GetDefUnique Then
            x2 = GetBestandslineByKey(oT91.t91(nCellPosCIType), sKey)
        Else
            x2 = -1
        End If
        
        If (x2 = -1) And (CLng(GetCellByTitle("bestandsliste_Ref-Count", x1)) <= 1) Then
            
            'CI Umbenennen
            GetCellByTitle("bestandsliste_CIKey", x1) = sKey
            'eigenschaften aktualisiseren
            For i = nCellPosPropertyStart To rDefinition.Columns.Count
                UpdateProperty i, x1
                'If (rDefinition.Cells(1, i) <> "") And (rDefinition.Cells(nDefinitionLine, i) <> "") Then
                '    GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, i), x1) = T91(i)
                'End If
            Next
            SetPKFields x1
        Else
            'altes ci entfernen
            RemoveCI
            'beim bestehenden CI den Ref-count erh|fffd|hen
            CreateCI
        End If
        
    End If
    UpdateCI = True

End Function

Sub RemoveCI()
    Dim x1 As Long
    x1 = GetBestandslineByGUID(GetGUID)
    If x1 <> -1 Then
        If GetCellByTitle("bestandsliste_Ref-Count", x1) > 1 Then
            GetCellByTitle("bestandsliste_Ref-Count", x1) = GetCellByTitle("bestandsliste_Ref-Count", x1) - 1
        Else
            GetCellByTitle("bestandsliste_Ref-Count", x1) = 0
            If (GetCellByTitle("bestandsliste_CI Nummer", x1) = "") Or ((CLng(GetCellByTitle("bestandsliste_Flags", x1)) And cCIFlag_PreventDelete) = cCIFlag_PreventDelete) Then
                'Zeile l|fffd|schen
                GetCellByTitle("bestandsliste_CI Nummer", x1).EntireRow.Delete
            End If
        End If
        
    End If
    SetGUID ""
    

End Sub

Private Sub SetPKFields(x1 As Long)
    If rDefinition.Cells(nDefinitionLine, nCellPosPK) = "" Then Exit Sub
        
    Dim v As Variant
    v = Split("" & rDefinition.Cells(nDefinitionLine, nCellPosPK), "=")
    Dim sPK As String
    
    Dim nPK As Long
    nPK = -1
    Dim i As Long
    Dim rPK As Range
    
    If UBound(v) = 1 Then
        sPK = oT91.GetDataCell(v(0))
        Set rPK = Range(v(1))
        If sPK <> "" Then
            For i = 2 To rPK.rows.Count
                If sPK = rPK.Cells(i, 1) Then
                    nPK = i
                    Exit For
                End If
            Next
        End If
        
        For i = 2 To rPK.Columns.Count
            If nPK = -1 Then
                GetCellByTitle("bestandsliste_" & rPK.Cells(1, i), x1) = ""
            Else
                GetCellByTitle("bestandsliste_" & rPK.Cells(1, i), x1) = rPK.Cells(nPK, i)
            End If
        Next
    End If
        
End Sub


Sub CreateCI()
    Dim sKey As String
    sKey = GetKey
    
    Dim i As Long
    
    Dim x1 As Long
    
    If Not GetDefUnique Then
        x1 = GetBestandslineByKey(oT91.t91(nCellPosCIType), sKey)
    Else
        x1 = -1
    End If
    
    If x1 <> -1 Then
        GetCellByTitle("bestandsliste_Ref-Count", x1) = GetCellByTitle("bestandsliste_Ref-Count", x1) + 1
        
        For i = nCellPosPropertyStart To rDefinition.Columns.Count
            UpdateProperty i, x1
'            If (rDefinition.Cells(1, i) <> "") And (rDefinition.Cells(nDefinitionLine, i) <> "") Then
'                GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, i), x1) = T91(i)
'            End If
        Next
        SetPKFields x1
        
        SetGUID GetCellByTitle("bestandsliste_GUID", x1)
        
    Else
        x1 = GetNextBestandLine(rData.Worksheet.Parent)
        GetCellByTitle("bestandsliste_CIKey", x1) = sKey
        GetCellByTitle("bestandsliste_CI Type", x1) = oT91.t91(nCellPosCIType)
        GetCellByTitle("bestandsliste_Menge", x1) = 1
        GetCellByTitle("bestandsliste_Quelle", x1) = "Generiert"
        GetCellByTitle("bestandsliste_Ref-Count", x1) = 1
        
        
        
    
        'V4.11
        'V4.14
        'GetCellByTitle("bestandsliste_DefNr", x1) = nDefinitionLine
        If ExistCellByTitle("bestandsliste_DefNr") Then GetCellByTitle("bestandsliste_DefNr", x1) = nDefinitionLine
        
        For i = nCellPosPropertyStart To rDefinition.Columns.Count
            'Debug.Print "Property:" & i
            UpdateProperty i, x1
            
'            If (rDefinition.Cells(1, i) <> "") And (rDefinition.Cells(nDefinitionLine, i) <> "") Then
'                GetCellByTitle("bestandsliste_" & rDefinition.Cells(1, i), x1) = T91(i)
'            End If
        Next
        SetPKFields x1
        
        SetGUID GetCellByTitle("bestandsliste_GUID", x1)
    End If
End Sub






'V4.11 ausgebaut, Feld anderweitig verwendet
'Public Function CheckInput()
'    If rDefinition.Cells(nDefinitionLine, nCellPosCheckIfComplete) <> 1 Then Exit Function
'    If Not IsKeyComplete Then
'        CheckInput = "Unvollst|fffd|ndige Zeile"
'    Else
'        Dim sFlags As String
'        Dim nDefcol As Long
'        For nDefcol = nCellPosPropertyStart To rDefinition.Columns.Count
'            If rDefinition.Cells(1, nDefcol) = "Flags" Then
'                sFlags = GetPropertyValue(nDefcol)
'                Exit For
'            End If
'        Next
'        If sFlags <> "" Then
'            If Left(sFlags, 3) = "or " Then
'                If (CLng(Mid(sFlags, 4)) And cCIFlag_PreventCreate) = cCIFlag_PreventCreate Then
'                    CheckInput = "Unvollst|fffd|ndige Zeile"
'                End If
'            End If
'        End If
'
'    End If
'End Function

Attribute VB_Name = "CCellByTitle"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public r As Range
Public sTitle As String
Public sName As String
Public nCol As Long


Attribute VB_Name = "CConnection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public sCIType1 As String
Public sCIType2 As String
Public sCINr1 As String
Public sCINr2 As String
Public sVerbindungsart As String
Public sOperation As String 'V..Verbinden, L..L|fffd|sen, _..nix
Public nMenge As Long
Public dEreignisdatum As Date

'V3.3
Public nMenge_Alt As Long

Public Function GetKey() As String
    GetKey = sCIType1 & "\" & sCINr1 & "->" & sCIType2 & "\" & sCINr2 & ":" & sVerbindungsart
End Function
Attribute VB_Name = "CDBQuery"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Dim connections As Collection

Private Const cDBQueryConnectionName = 1
Private Const cDBQueryConnectionString = 2
Private Const cDBQueryTable = 2
Private Const cDBQueryWhere = 3
Private Const cDBQuerySheet = 4
Private Const cDBQueryRange = 5
Private Const cDBQueryKeyDB = 6
Private Const cDBQueryKeyXLS = 7
Private Const cDBQueryFieldsDB = 8
Private Const cDBQueryFieldsXLS = 9


Private Sub InitConnections(rConnections As Range)
    If connections Is Nothing Then
        Set connections = New Collection
        
        Dim i As Long
        i = 1
        While rConnections.Cells(i, cDBQueryConnectionName) <> ""
            Dim cnn As ADODB.connection
            Set cnn = New ADODB.connection
            cnn.ConnectionString = rConnections.Cells(i, cDBQueryConnectionString)
            connections.Add cnn, "" & rConnections.Cells(i, cDBQueryConnectionName)
            i = i + 1
        Wend
    End If

End Sub

Public Sub RefreshSheet(rConnections As Range, rDefinition As Range, sh As Worksheet)
    InitConnections rConnections
    
    Dim i As Long
    i = 1
    While rDefinition.Cells(i, cDBQuerySheet) <> ""
        If rDefinition.Cells(i, cDBQuerySheet) = SheetName(sh) Then
            'Tu es
            Dim cnn As ADODB.connection
            Set cnn = OpenConnection(rDefinition.Cells(i, cDBQueryConnectionName))
            
            If Not cnn Is Nothing Then
                'Statement bauen
                Dim colFields As Collection
                Set colFields = New Collection
                
                Dim oT91 As New CT91
                oT91.Init rDefinition, i, "", 0
                Dim n As Long
                oT91.T91ExtractFields colFields, cDBQueryKeyDB
                For n = cDBQueryFieldsDB To rDefinition.Columns.Count Step 2
                    oT91.T91ExtractFields colFields, n
                Next
                
                Dim stmt As String
                stmt = ""
                For n = 1 To colFields.Count
                    stmt = stmt & "," & colFields(n)
                Next
                
                If stmt <> "" Then
                    stmt = "SELECT " & Mid(stmt, 2) & " FROM " & rDefinition.Cells(i, cDBQueryTable) & " WHERE " & oT91.t91(cDBQueryWhere)
                    
                    'statement ausf|fffd|hren
                    Dim rs As ADODB.Recordset
                    On Error Resume Next
                    Set rs = cnn.Execute(stmt)
                    
                    If Err.number <> 0 Then
                        Addlog "Fehler beim Lesen der Daten (" & Err.Description & ")"
                    Else
                        On Error GoTo 0
                        Dim colDBData As Collection
                        Set colDBData = New Collection
                        Dim colRow As Collection
                        
                        oT91.Init rDefinition, i, "", 0, rs
                        While Not rs.EOF
                            Dim sKey As String
                            sKey = oT91.t91(cDBQueryKeyDB)
                                   
                            If Not ExistInCol(colDBData, sKey) Then
                                Set colRow = New Collection
                                colDBData.Add colRow, sKey
                                colRow.Add sKey
                            
                                For n = cDBQueryFieldsDB To rDefinition.Columns.Count Step 2
                                    If rDefinition.Cells(i, n) <> "" Then
                                        colRow.Add oT91.t91(n)
                                    End If
                                Next
                            End If
                                
                            rs.MoveNext
                            
                        Wend
                        rs.Close
                        
                        Dim x As Long
                        x = 1
                        Dim rData As Range
                        Set rData = Range(rDefinition.Cells(i, cDBQueryRange))
                        
                        oT91.Init rDefinition, i, rDefinition.Cells(i, cDBQueryRange), x
                        While oT91.GetDataCell(rDefinition.Cells(i, cDBQueryKeyXLS)) <> ""
                            sKey = oT91.GetDataCell(rDefinition.Cells(i, cDBQueryKeyXLS))
                            
                            If ExistInCol(colDBData, sKey) Then
                                'Update
                                Set colRow = colDBData(sKey)
                                For n = cDBQueryFieldsXLS To rDefinition.Columns.Count Step 2
                                    If rDefinition.Cells(i, n) <> "" Then
                                        If oT91.GetDataCell(rDefinition.Cells(i, n)) <> colRow(2) Then
                                            oT91.GetDataCell(rDefinition.Cells(i, n)) = colRow(2)
                                        End If
                                        colRow.Remove 2
                                    End If
                                Next
                                
                                colDBData.Remove sKey
                            Else
                                'delete
                                oT91.GetDataCell(rDefinition.Cells(i, cDBQueryKeyXLS)) = ""
                                
                                For n = cDBQueryFieldsXLS To rDefinition.Columns.Count Step 2
                                    If rDefinition.Cells(i, n) <> "" Then
                                        If oT91.GetDataCell(rDefinition.Cells(i, n)) <> "" Then
                                            oT91.GetDataCell(rDefinition.Cells(i, n)) = ""
                                        End If
                                    End If
                                Next
                                rData.rows(x).EntireRow.Delete
                                x = x - 1
                                
                            End If
                        
                            x = x + 1
                            oT91.Init rDefinition, i, rDefinition.Cells(i, cDBQueryRange), x
                        Wend
                        
                        For Each colRow In colDBData
                        
                            'V4.22
                            If x > rData.rows.Count Then Exit For
                        
                            'add
                            oT91.GetDataCell(rDefinition.Cells(i, cDBQueryKeyXLS)) = colRow(1)
                            For n = cDBQueryFieldsXLS To rDefinition.Columns.Count Step 2
                                If rDefinition.Cells(i, n) <> "" Then
                                    If oT91.GetDataCell(rDefinition.Cells(i, n)) <> colRow(2) Then
                                        oT91.GetDataCell(rDefinition.Cells(i, n)) = colRow(2)
                                    End If
                                    colRow.Remove 2
                                End If
                            Next
                        
                            x = x + 1
                            
                            
                            oT91.Init rDefinition, i, rDefinition.Cells(i, cDBQueryRange), x
                            
                            'V4.03
                            If Fix(x / 10) * 10 = x Then
                                Application.StatusBar = "Bearbeitung in Zeile " & x
                                DoEvents
                            End If
                            
                        Next
                        
                        Set colDBData = Nothing
                        
                        
                        
                    End If
                End If
            End If
            
        End If
        i = i + 1
    Wend
    
    Application.StatusBar = ""
    
End Sub

'V4.23
Public Function Execute(rConnections As Range, sConnection As String, sSQL As String) As ADODB.Recordset
    InitConnections Range("cisettingsDBDatasources")
    Dim cnn As ADODB.connection
    Set cnn = OpenConnection("DWH-ServiceManagement")
    Set Execute = cnn.Execute(sSQL)
    
End Function

Private Function OpenConnection(sName As String) As ADODB.connection
    If ExistInCol(connections, sName) Then
        Dim cnn As ADODB.connection
        Set cnn = connections(sName)
        If cnn.State <> ADODB.adStateOpen Then
            On Error Resume Next
            cnn.Open
            On Error GoTo 0
            If cnn.State <> adStateOpen Then
                Addlog "Fehler beim |fffd|ffnen der Datenbank Verbindung " & sName
            Else
                Set OpenConnection = cnn
            End If
        Else
            Set OpenConnection = cnn
        End If
    Else
        Addlog "Fehler: Datenbank Verbindung " & sName & " nicht gefunden"
    End If
End Function


Private Sub Class_Terminate()
    On Error Resume Next
    Dim cnn As ADODB.connection
    For Each cnn In connections
        cnn.Close
    Next
    On Error GoTo 0
End Sub
Attribute VB_Name = "CIListElement"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'V4.1
Public sCIType As String
Public sCIBezeichnung As String
Public sGUID As String


Attribute VB_Name = "CLookupDefinition"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_sPKFilter As String
Private m_vPKFilter As Variant

Private m_sPropertyFilter As String
Private m_vPropertyFilter As Variant

Private m_sQuellFilter As String

Public colParam As Collection
Public nLine As Long

Public sRange As String
Public sNamesRange As String

'V3.8
Public sCustomName As String


Public Property Let QuellFilter(s As String)
    m_sQuellFilter = s

End Property

'V3.8
Public Function HasPKFilter() As Boolean
    HasPKFilter = m_sPKFilter <> ""
End Function
    
'V3.8
Public Function HasPropertyFilter() As Boolean
    HasPropertyFilter = m_sPropertyFilter <> ""
End Function

Public Property Let PKFilter(s As String)
    Dim v As Variant
    m_sPKFilter = s
    m_vPKFilter = Split(s, "\")
End Property

Public Property Let PropertyFilter(s As String)
    Dim v As Variant
    m_sPropertyFilter = s
    m_vPropertyFilter = Split(s, ",")
End Property
Public Function Match(pk As String, Property As String, Quelle As String) As Boolean
    Dim bMatch As Boolean
    bMatch = True
    
    Dim v As Variant
    Dim i As Long, n As Long
    Dim bFound As Boolean
    
    If bMatch And m_sQuellFilter <> "" Then
        If Quelle <> m_sQuellFilter Then
            bMatch = False
        End If
    
    End If
    If bMatch And m_sPropertyFilter <> "" Then
        v = Split(Property, ",")
        If Property = "" Then
            bMatch = False
        Else
            
            
            For i = LBound(m_vPropertyFilter) To UBound(m_vPropertyFilter)
                bFound = False
                For n = LBound(v) To UBound(v)
                    If m_vPropertyFilter(i) = v(n) Then
                        bFound = True
                        Exit For
                    End If
                Next
                If Not bFound Then
                    bMatch = False
                    Exit For
                End If
            Next
        End If
    End If
    If bMatch And m_sPKFilter <> "" Then
        If pk = "" Then
            bMatch = False
        Else
            
            v = Split(pk, "\")
            For i = LBound(m_vPKFilter) To UBound(m_vPKFilter)
                If i > UBound(v) Then
                    bMatch = False
                    Exit For
                Else
                    If m_vPKFilter(i) <> v(i) Then
                        bMatch = False
                        Exit For
                    End If
                End If
            Next
        End If
    End If
    Match = bMatch

End Function

Private Sub Class_Initialize()
    Set colParam = New Collection
End Sub
Attribute VB_Name = "CPKEintrag"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Public sBereich
Public sFunktion
Public sGruppe
Public sName
Public sSuchstring
Public sBeschreibung

Attribute VB_Name = "CProperty"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public sCIType As String
Public sCINr As String
Public sProperty As String
Public sValue As Variant
Public sOperation As String
Public sNumberFormat As String
Public sCIFlags As Long

'V1.985
Public sUncutValue

Public Function GetKey() As String
    GetKey = sCIType & "\" & sCINr & "." & sProperty
End Function

Attribute VB_Name = "CT91"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'V3.10


Option Explicit

Dim rDefinition As Range
Dim rData As Range
Dim sData As String
Dim nDefinitionLine As Long
Dim nDataLine As Long
Dim oCollectionObject As Object

Public Sub T91ExtractFields(col As Collection, nPos As Long)
    Dim v1 As Variant, v2 As Variant
    Dim s As String
    
    Dim key As String
    key = rDefinition.Cells(nDefinitionLine, nPos)
    
    
    If key = "" Then
        Exit Sub
    End If
    
    v1 = Split(key, "[")
    
    
    Dim i As Integer
    For i = 1 To UBound(v1)
        v2 = Split(v1(i), "]")
        If v2(0) = "" Then
        
        Else
            s = v2(0)
            
            If Not ExistInCol(col, s) Then
                col.Add s, s
            End If
            
                
        End If
        
    Next


End Sub




Public Sub Init(rDef As Range, nDef As Long, sDat As String, nDat As Long, Optional colobj As Object = Nothing)
    Set rDefinition = rDef
    If sDat <> "" Then
        'V4.11
        'Set rData = Range(sDat)
        Set rData = Range2(rDef.Cells(nDef, 1) & "#" & sDat)
    Else
        Set rData = Nothing
    End If
    sData = sDat
    
    nDefinitionLine = nDef
    nDataLine = nDat
    
    Set oCollectionObject = colobj
End Sub


Function t91(nPos As Long) As String
    Dim key As String
    key = rDefinition.Cells(nDefinitionLine, nPos)
    
    t91 = t91s(key)

End Function



Function t91s(sKey As String) As String
    Dim v As Variant
    v = T91is(sKey)
    
    If v = "" Then
        t91s = ""
    Else
        
        If (Len(v) < 255) And (Left(v, 1) <> "#") Then
            t91s = Evaluate(v)
        Else
            If Left(v, 1) = "#" Then
                v = Mid(v, 2)
            End If
            Range("settingsEvaluate").Formula = "=" & v
            t91s = Range("settingsEvaluate").Value
        End If
        
    End If
End Function

Private Function T91i(nPos As Long) As Variant
    Dim key As String
    key = rDefinition.Cells(nDefinitionLine, nPos)

    T91i = T91is(key)
    
End Function

Private Function T91is(key) As String
    Dim sResult As String
    Dim v1 As Variant, v2 As Variant
    Dim s As String
    
    
    If key = "" Then
        T91is = ""
        Exit Function
    End If
    
    v1 = Split(key, "[")
    sResult = v1(0)
    
    Dim i As Integer
    For i = 1 To UBound(v1)
        v2 = Split(v1(i), "]")
        
        s = v2(0)
        
        If (s <> "") Then
            sResult = sResult & """" & GetDataCell(s) & """"
        End If
        sResult = sResult & v2(1)
    Next
    T91is = sResult


End Function


Public Function GetDataCell(sKey) As Object
    If oCollectionObject Is Nothing Then
        If IsNumeric(sKey) Then
            Set GetDataCell = rData.Cells(nDataLine, CLng(sKey))
        Else
            'V3.3
            'Set GetDataCell = GetCellByTitle(rDefinition.Cells(nDefinitionLine, nCellPosRange) & "_" & sKey, nDataLine)
            Set GetDataCell = GetCellByTitle(sData & "_" & sKey, nDataLine)
            
        End If
    Else
        On Error Resume Next
        Set GetDataCell = oCollectionObject(sKey)
        On Error GoTo 0
    End If
        
End Function



Public Function T91Complete(nPos As Long) As Boolean
    
    Dim v1 As Variant, v2 As Variant
    Dim s As String
    
    Dim key As String
    key = rDefinition.Cells(nDefinitionLine, nPos)
    
    
    If key = "" Then
        Exit Function
    End If
    
    v1 = Split(key, "[")
    
    
    Dim i As Integer
    For i = 1 To UBound(v1)
        v2 = Split(v1(i), "]")
        If v2(0) = "" Then
        
        Else
            s = v2(0)
            
            If GetDataCell(s) = "" Then
                Exit Function
            End If
                
                
        End If
        
    Next
    T91Complete = True

End Function

Attribute VB_Name = "CTracking"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public sCINr As String
Public sCIType As String
Public sTrackingType As String
Public nMenge As Long
Public nDiffMenge As Long



Public Property Get GetKey() As String
    GetKey = sctype & "\" & sCINr & "\" & sTrackingType
    
End Property
Attribute VB_Name = "CVorerfassungFilter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public sField As String
Public sMode As String
Public colFilterValues As Collection


Private Sub Class_Initialize()
    Set colFilterValues = New Collection
End Sub

Attribute VB_Name = "CVorerfassungProfile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public colFilter As Collection
Public nColumn As Long
Public sData As String
Public sSplitField As String
Public nEndIndicator As Long

Private Sub Class_Initialize()
    Set colFilter = New Collection
End Sub
Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_AfterSave(ByVal Success As Boolean)
    Tabelle1.Cells(1, 1).Value = Tabelle1.Cells(2, 1).Value
End Sub

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
    Tabelle1.Cells(2, 1).Value = Tabelle1.Cells(1, 1).Value
    Tabelle1.Cells(1, 1).Value = 0
End Sub

Private Sub Workbook_Open()

End Sub
Attribute VB_Name = "JSON"
' VBJSON is a VB6 adaptation of the VBA JSON project at http://code.google.com/p/vba-json/
' Some bugs fixed, speed improvements added for VB6 by Michael Glaser (vbjson@ediy.co.nz)
' BSD Licensed

Option Explicit

Const INVALID_JSON      As Long = 1
Const INVALID_OBJECT    As Long = 2
Const INVALID_ARRAY     As Long = 3
Const INVALID_BOOLEAN   As Long = 4
Const INVALID_NULL      As Long = 5
Const INVALID_KEY       As Long = 6
Const INVALID_RPC_CALL  As Long = 7

Private psErrors As String

Public Function GetParserErrors() As String
   GetParserErrors = psErrors
End Function

Public Function ClearParserErrors() As String
   psErrors = ""
End Function


'
'   parse string and create JSON object
'
Public Function parse(ByRef str As String) As Object

   Dim index As Long
   index = 1
   psErrors = ""
   On Error Resume Next
   Call skipChar(str, index)
   Select Case Mid(str, index, 1)
      Case "{"
         Set parse = parseObject(str, index)
      Case "["
         Set parse = parseArray(str, index)
      Case Else
         psErrors = "Invalid JSON"
   End Select


End Function

 '
 '   parse collection of key/value
 '
Private Function parseObject(ByRef str As String, ByRef index As Long) As Dictionary

   Set parseObject = New Dictionary
   Dim sKey As String
   
   ' "{"
   Call skipChar(str, index)
   If Mid(str, index, 1) <> "{" Then
      psErrors = psErrors & "Invalid Object at position " & index & " : " & Mid(str, index) & vbCrLf
      Exit Function
   End If
   
   index = index + 1

   Do
      Call skipChar(str, index)
      If "}" = Mid(str, index, 1) Then
         index = index + 1
         Exit Do
      ElseIf "," = Mid(str, index, 1) Then
         index = index + 1
         Call skipChar(str, index)
      ElseIf index > Len(str) Then
         psErrors = psErrors & "Missing '}': " & Right(str, 20) & vbCrLf
         Exit Do
      End If

      
      ' add key/value pair
      sKey = parseKey(str, index)
      On Error Resume Next
      
      parseObject.Add sKey, parseValue(str, index)
      If Err.number <> 0 Then
         psErrors = psErrors & Err.Description & ": " & sKey & vbCrLf
         Exit Do
      End If
   Loop
eh:

End Function

'
'   parse list
'
Private Function parseArray(ByRef str As String, ByRef index As Long) As Collection

   Set parseArray = New Collection

   ' "["
   Call skipChar(str, index)
   If Mid(str, index, 1) <> "[" Then
      psErrors = psErrors & "Invalid Array at position " & index & " : " + Mid(str, index, 20) & vbCrLf
      Exit Function
   End If
   
   index = index + 1

   Do

      Call skipChar(str, index)
      If "]" = Mid(str, index, 1) Then
         index = index + 1
         Exit Do
      ElseIf "," = Mid(str, index, 1) Then
         index = index + 1
         Call skipChar(str, index)
      ElseIf index > Len(str) Then
         psErrors = psErrors & "Missing ']': " & Right(str, 20) & vbCrLf
         Exit Do
      End If

      ' add value
      On Error Resume Next
      parseArray.Add parseValue(str, index)
      If Err.number <> 0 Then
         psErrors = psErrors & Err.Description & ": " & Mid(str, index, 20) & vbCrLf
         Exit Do
      End If
   Loop

End Function

'
'   parse string / number / object / array / true / false / null
'
Private Function parseValue(ByRef str As String, ByRef index As Long)

   Call skipChar(str, index)

   Select Case Mid(str, index, 1)
      Case "{"
         Set parseValue = parseObject(str, index)
      Case "["
         Set parseValue = parseArray(str, index)
      Case """", "'"
         parseValue = parseString(str, index)
      Case "t", "f"
         parseValue = parseBoolean(str, index)
      Case "n"
         parseValue = parseNull(str, index)
      Case Else
         parseValue = parseNumber(str, index)
   End Select

End Function

'
'   parse string
'
Private Function parseString(ByRef str As String, ByRef index As Long) As String

   Dim quote   As String
   Dim Char    As String
   Dim Code    As String

   Dim SB As New cStringBuilder

   Call skipChar(str, index)
   quote = Mid(str, index, 1)
   index = index + 1
   
   Do While index > 0 And index <= Len(str)
      Char = Mid(str, index, 1)
      Select Case (Char)
         Case "\"
            index = index + 1
            Char = Mid(str, index, 1)
            Select Case (Char)
               Case """", "\", "/", "'"
                  SB.Append Char
                  index = index + 1
               Case "b"
                  SB.Append vbBack
                  index = index + 1
               Case "f"
                  SB.Append vbFormFeed
                  index = index + 1
               Case "n"
                  SB.Append vbLf
                  index = index + 1
               Case "r"
                  SB.Append vbCr
                  index = index + 1
               Case "t"
                  SB.Append vbTab
                  index = index + 1
               Case "u"
                  index = index + 1
                  Code = Mid(str, index, 4)
                  SB.Append ChrW(Val("&h" + Code))
                  index = index + 4
            End Select
         Case quote
            index = index + 1
            
            parseString = SB.toString
            Set SB = Nothing
            
            Exit Function
            
         Case Else
            SB.Append Char
            index = index + 1
      End Select
   Loop
   
   parseString = SB.toString
   Set SB = Nothing
   
End Function

'
'   parse number
'
Private Function parseNumber(ByRef str As String, ByRef index As Long)

   Dim Value   As String
   Dim Char    As String

   Call skipChar(str, index)
   Do While index > 0 And index <= Len(str)
      Char = Mid(str, index, 1)
      If InStr("+-0123456789.eE", Char) Then
         Value = Value & Char
         index = index + 1
      Else
         parseNumber = CDec(Value)
         Exit Function
      End If
   Loop
End Function

'
'   parse true / false
'
Private Function parseBoolean(ByRef str As String, ByRef index As Long) As Boolean

   Call skipChar(str, index)
   If Mid(str, index, 4) = "true" Then
      parseBoolean = True
      index = index + 4
   ElseIf Mid(str, index, 5) = "false" Then
      parseBoolean = False
      index = index + 5
   Else
      psErrors = psErrors & "Invalid Boolean at position " & index & " : " & Mid(str, index) & vbCrLf
   End If

End Function

'
'   parse null
'
Private Function parseNull(ByRef str As String, ByRef index As Long)

   Call skipChar(str, index)
   If Mid(str, index, 4) = "null" Then
      parseNull = Null
      index = index + 4
   Else
      psErrors = psErrors & "Invalid null value at position " & index & " : " & Mid(str, index) & vbCrLf
   End If

End Function

Private Function parseKey(ByRef str As String, ByRef index As Long) As String

   Dim dquote  As Boolean
   Dim squote  As Boolean
   Dim Char    As String

   Call skipChar(str, index)
   Do While index > 0 And index <= Len(str)
      Char = Mid(str, index, 1)
      Select Case (Char)
         Case """"
            dquote = Not dquote
            index = index + 1
            If Not dquote Then
               Call skipChar(str, index)
               If Mid(str, index, 1) <> ":" Then
                  psErrors = psErrors & "Invalid Key at position " & index & " : " & parseKey & vbCrLf
                  Exit Do
               End If
            End If
         Case "'"
            squote = Not squote
            index = index + 1
            If Not squote Then
               Call skipChar(str, index)
               If Mid(str, index, 1) <> ":" Then
                  psErrors = psErrors & "Invalid Key at position " & index & " : " & parseKey & vbCrLf
                  Exit Do
               End If
            End If
         Case ":"
            index = index + 1
            If Not dquote And Not squote Then
               Exit Do
            Else
               parseKey = parseKey & Char
            End If
         Case Else
            If InStr(vbCrLf & vbCr & vbLf & vbTab & " ", Char) Then
            Else
               parseKey = parseKey & Char
            End If
            index = index + 1
      End Select
   Loop

End Function

'
'   skip special character
'
Private Sub skipChar(ByRef str As String, ByRef index As Long)
   Dim bComment As Boolean
   Dim bStartComment As Boolean
   Dim bLongComment As Boolean
   Do While index > 0 And index <= Len(str)
      Select Case Mid(str, index, 1)
      Case vbCr, vbLf
         If Not bLongComment Then
            bStartComment = False
            bComment = False
         End If
         
      Case vbTab, " ", "(", ")"
         
      Case "/"
         If Not bLongComment Then
            If bStartComment Then
               bStartComment = False
               bComment = True
            Else
               bStartComment = True
               bComment = False
               bLongComment = False
            End If
         Else
            If bStartComment Then
               bLongComment = False
               bStartComment = False
               bComment = False
            End If
         End If
         
      Case "*"
         If bStartComment Then
            bStartComment = False
            bComment = True
            bLongComment = True
         Else
            bStartComment = True
         End If
         
      Case Else
         If Not bComment Then
            Exit Do
         End If
      End Select
      
      index = index + 1
   Loop

End Sub

Public Function toString(ByRef obj As Variant) As String
   Dim SB As New cStringBuilder
   Select Case VarType(obj)
      Case vbNull
         SB.Append "null"
      Case vbDate
         SB.Append """" & CStr(obj) & """"
      Case vbString
         SB.Append """" & Encode(obj) & """"
      Case vbObject
         
         Dim bFI As Boolean
         Dim i As Long
         
         bFI = True
         If TypeName(obj) = "Dictionary" Then

            SB.Append "{"
            Dim keys
            keys = obj.keys
            For i = 0 To obj.Count - 1
               If bFI Then bFI = False Else SB.Append ","
               Dim key
               key = keys(i)
               SB.Append """" & key & """:" & toString(obj.Item(key))
            Next i
            SB.Append "}"

         ElseIf TypeName(obj) = "Collection" Then

            SB.Append "["
            Dim Value
            For Each Value In obj
               If bFI Then bFI = False Else SB.Append ","
               SB.Append toString(Value)
            Next Value
            SB.Append "]"

         End If
      Case vbBoolean
         If obj Then SB.Append "true" Else SB.Append "false"
      Case vbVariant, vbArray, vbArray + vbVariant
         Dim sEB
         SB.Append multiArray(obj, 1, "", sEB)
      Case Else
         SB.Append Replace(obj, ",", ".")
   End Select

   toString = SB.toString
   Set SB = Nothing
   
End Function

Private Function Encode(str) As String

   Dim SB As New cStringBuilder
   Dim i As Long
   Dim j As Long
   Dim aL1 As Variant
   Dim aL2 As Variant
   Dim c As String
   Dim p As Boolean

   aL1 = Array(&H22, &H5C, &H2F, &H8, &HC, &HA, &HD, &H9)
   aL2 = Array(&H22, &H5C, &H2F, &H62, &H66, &H6E, &H72, &H74)
   For i = 1 To Len(str)
      p = True
      c = Mid(str, i, 1)
      For j = 0 To 7
         If c = Chr(aL1(j)) Then
            SB.Append "\" & Chr(aL2(j))
            p = False
            Exit For
         End If
      Next

      If p Then
         Dim a
         a = AscW(c)
         If a > 31 And a < 127 Then
            SB.Append c
         ElseIf a > -1 Or a < 65535 Then
            SB.Append "\u" & String(4 - Len(Hex(a)), "0") & Hex(a)
         End If
      End If
   Next
   
   Encode = SB.toString
   Set SB = Nothing
   
End Function

Private Function multiArray(aBD, iBC, sPS, ByRef sPT)   ' Array BoDy, Integer BaseCount, String PoSition
   
   Dim iDU As Long
   Dim iDL As Long
   Dim i As Long
   
   On Error Resume Next
   iDL = LBound(aBD, iBC)
   iDU = UBound(aBD, iBC)

   Dim SB As New cStringBuilder

   Dim sPB1, sPB2  ' String PointBuffer1, String PointBuffer2
   If Err.number = 9 Then
      sPB1 = sPT & sPS
      For i = 1 To Len(sPB1)
         If i <> 1 Then sPB2 = sPB2 & ","
         sPB2 = sPB2 & Mid(sPB1, i, 1)
      Next
      '        multiArray = multiArray & toString(Eval("aBD(" & sPB2 & ")"))
      SB.Append toString(aBD(sPB2))
   Else
      sPT = sPT & sPS
      SB.Append "["
      For i = iDL To iDU
         SB.Append multiArray(aBD, iBC + 1, i, sPT)
         If i < iDU Then SB.Append ","
      Next
      SB.Append "]"
      sPT = Left(sPT, iBC - 2)
   End If
   Err.Clear
   multiArray = SB.toString
   
   Set SB = Nothing
End Function

' Miscellaneous JSON functions

Public Function StringToJSON(st As String) As String
   
   Const FIELD_SEP = "~"
   Const RECORD_SEP = "|"

   Dim sFlds As String
   Dim sRecs As New cStringBuilder
   Dim lRecCnt As Long
   Dim lFld As Long
   Dim fld As Variant
   Dim rows As Variant

   lRecCnt = 0
   If st = "" Then
      StringToJSON = "null"
   Else
      rows = Split(st, RECORD_SEP)
      For lRecCnt = LBound(rows) To UBound(rows)
         sFlds = ""
         fld = Split(rows(lRecCnt), FIELD_SEP)
         For lFld = LBound(fld) To UBound(fld) Step 2
            sFlds = (sFlds & IIf(sFlds <> "", ",", "") & """" & fld(lFld) & """:""" & toUnicode(fld(lFld + 1) & "") & """")
         Next 'fld
         sRecs.Append IIf((Trim(sRecs.toString) <> ""), "," & vbCrLf, "") & "{" & sFlds & "}"
      Next 'rec
      StringToJSON = ("( {""Records"": [" & vbCrLf & sRecs.toString & vbCrLf & "], " & """RecordCount"":""" & lRecCnt & """ } )")
   End If
End Function


Public Function RStoJSON(rs As ADODB.Recordset) As String
   On Error GoTo errHandler
   Dim sFlds As String
   Dim sRecs As New cStringBuilder
   Dim lRecCnt As Long
   Dim fld As ADODB.Field

   lRecCnt = 0
   If rs.State = adStateClosed Then
      RStoJSON = "null"
   Else
      If rs.EOF Or rs.BOF Then
         RStoJSON = "null"
      Else
         Do While Not rs.EOF And Not rs.BOF
            lRecCnt = lRecCnt + 1
            sFlds = ""
            For Each fld In rs.Fields
               sFlds = (sFlds & IIf(sFlds <> "", ",", "") & """" & fld.Name & """:""" & toUnicode(fld.Value & "") & """")
            Next 'fld
            sRecs.Append IIf((Trim(sRecs.toString) <> ""), "," & vbCrLf, "") & "{" & sFlds & "}"
            rs.MoveNext
         Loop
         RStoJSON = ("( {""Records"": [" & vbCrLf & sRecs.toString & vbCrLf & "], " & """RecordCount"":""" & lRecCnt & """ } )")
      End If
   End If

   Exit Function
errHandler:

End Function

'Public Function JsonRpcCall(url As String, methName As String, args(), Optional user As String, Optional pwd As String) As Object
'    Dim r As Object
'    Dim cli As Object
'    Dim pText As String
'    Static reqId As Integer
'
'    reqId = reqId + 1
'
'    Set r = CreateObject("Scripting.Dictionary")
'    r("jsonrpc") = "2.0"
'    r("method") = methName
'    r("params") = args
'    r("id") = reqId
'
'    pText = toString(r)
'
'    Set cli = CreateObject("MSXML2.XMLHTTP.6.0")
'   ' Set cli = New MSXML2.XMLHTTP60
'    If Len(user) > 0 Then   ' If Not IsMissing(user) Then
'        cli.Open "POST", url, False, user, pwd
'    Else
'        cli.Open "POST", url, False
'    End If
'    cli.setRequestHeader "Content-Type", "application/json"
'    cli.Send pText
'
'    If cli.Status <> 200 Then
'        Err.Raise vbObjectError + INVALID_RPC_CALL + cli.Status, , cli.statusText
'    End If
'
'    Set r = parse(cli.responseText)
'    Set cli = Nothing
'
'    If r("id") <> reqId Then Err.Raise vbObjectError + INVALID_RPC_CALL, , "Bad Response id"
'
'    If r.Exists("error") Or Not r.Exists("result") Then
'        Err.Raise vbObjectError + INVALID_RPC_CALL, , "Json-Rpc Response error: " & r("error")("message")
'    End If
'
'    If Not r.Exists("result") Then Err.Raise vbObjectError + INVALID_RPC_CALL, , "Bad Response, missing result"
'
'    Set JsonRpcCall = r("result")
'End Function




Public Function toUnicode(str As String) As String

   Dim x As Long
   Dim uStr As New cStringBuilder
   Dim uChrCode As Integer

   For x = 1 To Len(str)
      uChrCode = Asc(Mid(str, x, 1))
      Select Case uChrCode
         Case 8:   ' backspace
            uStr.Append "\b"
         Case 9: ' tab
            uStr.Append "\t"
         Case 10:  ' line feed
            uStr.Append "\n"
         Case 12:  ' formfeed
            uStr.Append "\f"
         Case 13: ' carriage return
            uStr.Append "\r"
         Case 34: ' quote
            uStr.Append "\"""
         Case 39:  ' apostrophe
            uStr.Append "\'"
         Case 92: ' backslash
            uStr.Append "\\"
         Case 123, 125:  ' "{" and "}"
            uStr.Append ("\u" & Right("0000" & Hex(uChrCode), 4))
         Case Is < 32, Is > 127: ' non-ascii characters
            uStr.Append ("\u" & Right("0000" & Hex(uChrCode), 4))
         Case Else
            uStr.Append Chr$(uChrCode)
      End Select
   Next
   toUnicode = uStr.toString
   Exit Function

End Function

Private Sub Class_Initialize()
   psErrors = ""
End Sub


Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "cJSONScript"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Option Explicit
'
'Dim dictVars As New Dictionary
'Dim plNestCount As Long
'
'
'Public Function Eval(sJSON As String) As String
'   Dim SB As New cStringBuilder
'   Dim o As Object
'   Dim c As Object
'   Dim i As Long
'
'   Set o = JSON.parse(sJSON)
'   If (JSON.GetParserErrors = "") And Not (o Is Nothing) Then
'      For i = 1 To o.Count
'         Select Case VarType(o.Item(i))
'         Case vbNull
'            SB.Append "null"
'         Case vbDate
'            SB.Append CStr(o.Item(i))
'         Case vbString
'            SB.Append CStr(o.Item(i))
'         Case Else
'            Set c = o.Item(i)
'            SB.Append ExecCommand(c)
'         End Select
'      Next
'   Else
'      MsgBox JSON.GetParserErrors, vbExclamation, "Parser Error"
'   End If
'   Eval = SB.toString
'End Function
'
'Public Function ExecCommand(ByRef obj As Variant) As String
'   Dim SB As New cStringBuilder
'
'   If plNestCount > 40 Then
'      ExecCommand = "ERROR: Nesting level exceeded."
'   Else
'      plNestCount = plNestCount + 1
'
'      Select Case VarType(obj)
'         Case vbNull
'            SB.Append "null"
'         Case vbDate
'            SB.Append CStr(obj)
'         Case vbString
'            SB.Append CStr(obj)
'         Case vbObject
'
'            Dim i As Long
'            Dim j As Long
'            Dim this As Object
'            Dim key
'            Dim paramKeys
'
'            If TypeName(obj) = "Dictionary" Then
'               Dim sOut As String
'               Dim sRet As String
'
'               Dim keys
'               keys = obj.keys
'               For i = 0 To obj.Count - 1
'                  sRet = ""
'
'                  key = keys(i)
'                  If VarType(obj.Item(key)) = vbString Then
'                     sRet = obj.Item(key)
'                  Else
'                     Set this = obj.Item(key)
'                  End If
'
'                  ' command implementation
'                  Select Case LCase(key)
'                  Case "alert":
'                     MsgBox ExecCommand(this.Item("message")), vbInformation, ExecCommand(this.Item("title"))
'
'                  Case "input":
'                     SB.Append InputBox(ExecCommand(this.Item("prompt")), ExecCommand(this.Item("title")), ExecCommand(this.Item("default")))
'
'                  Case "switch"
'                     sOut = ExecCommand(this.Item("default"))
'                     sRet = LCase(ExecCommand(this.Item("case")))
'                     For j = 0 To this.Item("items").Count - 1
'                        If LCase(this.Item("items").Item(j + 1).Item("case")) = sRet Then
'                           sOut = ExecCommand(this.Item("items").Item(j + 1).Item("return"))
'                           Exit For
'                        End If
'                     Next
'                     SB.Append sOut
'
'                  Case "set":
'                     If dictVars.Exists(this.Item("name")) Then
'                        dictVars.Item(this.Item("name")) = ExecCommand(this.Item("value"))
'                     Else
'                        dictVars.Add this.Item("name"), ExecCommand(this.Item("value"))
'                     End If
'
'                  Case "get":
'                     sRet = ExecCommand(dictVars(CStr(this.Item("name"))))
'                     If sRet = "" Then
'                        sRet = ExecCommand(this.Item("default"))
'                     End If
'
'                     SB.Append sRet
'
'                  Case "if"
'                     Dim val1 As String
'                     Dim val2 As String
'                     Dim bRes As Boolean
'                     val1 = ExecCommand(this.Item("value1"))
'                     val2 = ExecCommand(this.Item("value2"))
'
'                     bRes = False
'                     Select Case LCase(this.Item("type"))
'                     Case "eq" ' =
'                        If LCase(val1) = LCase(val2) Then
'                           bRes = True
'                        End If
'
'                     Case "gt" ' >
'                        If val1 > val2 Then
'                           bRes = True
'                        End If
'
'                     Case "lt" ' <
'                        If val1 < val2 Then
'                           bRes = True
'                        End If
'
'                     Case "gte" ' >=
'                        If val1 >= val2 Then
'                           bRes = True
'                        End If
'
'                     Case "lte" ' <=
'                        If val1 <= val2 Then
'                           bRes = True
'                        End If
'
'                     End Select
'
'                     If bRes Then
'                        SB.Append ExecCommand(this.Item("true"))
'                     Else
'                        SB.Append ExecCommand(this.Item("false"))
'                     End If
'
'                  Case "return"
'                     SB.Append obj.Item(key)
'
'
'                  Case Else
'                     If TypeName(this) = "Dictionary" Then
'                        paramKeys = this.keys
'                        For j = 0 To this.Count - 1
'                           If j > 0 Then
'                              sRet = sRet & ","
'                           End If
'                           sRet = sRet & CStr(this.Item(paramKeys(j)))
'                        Next
'                     End If
'
'
'                     SB.Append "<%" & UCase(key) & "(" & sRet & ")%>"
'
'                  End Select
'               Next i
'
'            ElseIf TypeName(obj) = "Collection" Then
'
'               Dim Value
'               For Each Value In obj
'                  SB.Append ExecCommand(Value)
'               Next Value
'
'            End If
'            Set this = Nothing
'
'         Case vbBoolean
'            If obj Then SB.Append "true" Else SB.Append "false"
'
'         Case vbVariant, vbArray, vbArray + vbVariant
'
'         Case Else
'            SB.Append Replace(obj, ",", ".")
'      End Select
'      plNestCount = plNestCount - 1
'   End If
'
'   ExecCommand = SB.toString
'   Set SB = Nothing
'
'End Function
'
'
'
'
Attribute VB_Name = "cStringBuilder"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' ======================================================================================
' Name:     vbAccelerator cStringBuilder
' Author:   Steve McMahon (steve@vbaccelerator.com)
' Date:     1 January 2002
'
' Copyright |fffd| 2002 Steve McMahon for vbAccelerator
' --------------------------------------------------------------------------------------
' Visit vbAccelerator - advanced free source code for VB programmers
' http://vbaccelerator.com
' --------------------------------------------------------------------------------------
'
' VB can be slow to append strings together because of the continual
' reallocation of string size.  This class pre-allocates a string in
' blocks and hence removes the performance restriction.
'
' Quicker insert and remove is also possible since string space does
' not have to be reallocated.
'
' Example:
' Adding "http://vbaccelerator.com/" 10,000 times to a string:
' Standard VB:   34s
' This Class:    0.35s
'
' ======================================================================================

Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
      
Private m_sString As String
Private m_iChunkSize As Long
Private m_iPos As Long
Private m_iLen As Long

Public Property Get Length() As Long
   Length = CLng(m_iPos) \ 2
End Property

Public Property Get Capacity() As Long
   Capacity = m_iLen \ 2
End Property

Public Property Get ChunkSize() As Long
   ' Return the unicode character chunk size:
   ChunkSize = m_iChunkSize \ 2
End Property

Public Property Let ChunkSize(ByVal iChunkSize As Long)
   ' Set the chunksize.  We multiply by 2 because internally
   ' we are considering bytes:
   m_iChunkSize = iChunkSize * 2
End Property

Public Property Get toString() As String
   ' The internal string:
   If m_iPos > 0 Then
      toString = Left$(m_sString, CLng(m_iPos) \ 2)
   End If
End Property

Public Property Let TheString(ByRef sThis As String)
   Dim lLen As Long
   
   ' Setting the string:
   lLen = LenB(sThis)
   If lLen = 0 Then
      'Clear
      m_sString = ""
      m_iPos = 0
      m_iLen = 0
   Else
      If m_iLen < lLen Then
         ' Need to expand string to accommodate:
         Do
            m_sString = m_sString & Space$(m_iChunkSize \ 2)
            m_iLen = m_iLen + m_iChunkSize
         Loop While m_iLen < lLen
      End If
      CopyMemory ByVal StrPtr(m_sString), ByVal StrPtr(sThis), lLen
      m_iPos = lLen
   End If
   
End Property

Public Sub Clear()
   m_sString = ""
   m_iPos = 0
   m_iLen = 0
End Sub

Public Sub AppendNL(ByRef sThis As String)
   Append sThis
   Append vbCrLf
End Sub

Public Sub Append(ByRef sThis As String)
   Dim lLen As Long
   Dim lLenPlusPos As Long
 
   ' Append an item to the string:
   lLen = LenB(sThis)
   lLenPlusPos = lLen + CLng(m_iPos)
   If lLenPlusPos > m_iLen Then
      Dim lTemp As Long
      
      lTemp = m_iLen
      Do While lTemp < lLenPlusPos
         lTemp = lTemp + m_iChunkSize
      Loop
      
      m_sString = m_sString & Space$((lTemp - m_iLen) \ 2)
      m_iLen = lTemp
   End If
   
   CopyMemory ByVal UnsignedAdd(StrPtr(m_sString), m_iPos), ByVal StrPtr(sThis), lLen
   m_iPos = m_iPos + lLen
End Sub

Public Sub AppendByVal(ByVal sThis As String)
   Append sThis
End Sub

Public Sub Insert(ByVal iIndex As Long, ByRef sThis As String)
   Dim lLen As Long
   Dim lPos As LongPtr
   Dim lSize As Long
   
   ' is iIndex within bounds?
   If (iIndex * 2 > m_iPos) Then
      Err.Raise 9
   Else
   
      lLen = LenB(sThis)
      If (m_iPos + lLen) > m_iLen Then
         m_sString = m_sString & Space$(m_iChunkSize \ 2)
         m_iLen = m_iLen + m_iChunkSize
      End If
      
      ' Move existing characters from current position
      lPos = UnsignedAdd(StrPtr(m_sString), iIndex * 2)
      lSize = CLng(m_iPos) - iIndex * 2
      
      ' moving from iIndex to iIndex + lLen
      CopyMemory ByVal UnsignedAdd(lPos, lLen), ByVal lPos, lSize
      
      ' Insert new characters:
      CopyMemory ByVal lPos, ByVal StrPtr(sThis), lLen
      
      m_iPos = m_iPos + lLen
   End If
End Sub

Public Sub InsertByVal(ByVal iIndex As Long, ByVal sThis As String)
   Insert iIndex, sThis
End Sub

Public Sub Remove(ByVal iIndex As Long, ByVal lLen As Long)
   Dim lSrc As LongPtr
   Dim lDst As LongPtr
   Dim lSize As Long

   ' is iIndex within bounds?
   If (iIndex * 2 > m_iPos) Then
      Err.Raise 9
   Else
      ' is there sufficient length?
      If ((iIndex + lLen) * 2 > m_iPos) Then
         Err.Raise 9
      Else
         ' Need to copy characters from iIndex*2 to m_iPos back by lLen chars:
         lSrc = UnsignedAdd(StrPtr(m_sString), (iIndex + lLen) * 2)
         lDst = UnsignedAdd(StrPtr(m_sString), iIndex * 2)
         lSize = (m_iPos - (iIndex + lLen) * 2)
         CopyMemory ByVal lDst, ByVal lSrc, lSize
         m_iPos = m_iPos - lLen * 2
      End If
   End If
End Sub

Public Function Find(ByVal sToFind As String, _
   Optional ByVal lStartIndex As Long = 1, _
   Optional ByVal compare As VbCompareMethod = vbTextCompare _
   ) As Long
   
   Dim lInstr As Long
   If (lStartIndex > 0) Then
      lInstr = InStr(lStartIndex, m_sString, sToFind, compare)
   Else
      lInstr = InStr(m_sString, sToFind, compare)
   End If
   If (lInstr < m_iPos \ 2) Then
      Find = lInstr
   End If
End Function

Public Sub HeapMinimize()
   Dim iLen As Long
   
   ' Reduce the string size so only the minimal chunks
   ' are allocated:
   If (m_iLen - m_iPos) > m_iChunkSize Then
      iLen = m_iLen
      Do While (iLen - m_iPos) > m_iChunkSize
         iLen = iLen - m_iChunkSize
      Loop
      m_sString = Left$(m_sString, iLen \ 2)
      m_iLen = iLen
   End If
   
End Sub
Private Function UnsignedAdd(Start As LongPtr, Incr As Long) As LongPtr
' This function is useful when doing pointer arithmetic,
' but note it only works for positive values of Incr

   If Start And &H80000000 Then 'Start < 0
      UnsignedAdd = Start + Incr
   ElseIf (Start Or &H80000000) < -Incr Then
      UnsignedAdd = Start + Incr
   Else
      UnsignedAdd = (Start + &H80000000) + (Incr + &H80000000)
   End If
   
End Function
Private Sub Class_Initialize()
   ' The default allocation: 8192 characters.
   m_iChunkSize = 16384
End Sub


Attribute VB_Name = "frmGeneral"
Attribute VB_Base = "0{05739E3D-7049-41B4-96B7-D35EA470452A}{DE867E05-FC90-4DD1-9C96-20D54E1F0FF5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Public nRet As Long

Private Sub cmdClose_Click()
    nRet = 0
    Hide
    
    
End Sub

Private Sub cmdOK_Click()
    nRet = 1
    Hide
    
End Sub

Private Sub UserForm_Activate()
    nRet = 0
End Sub

Attribute VB_Name = "frmMsg"
Attribute VB_Base = "0{A75C981B-771A-4FEC-9217-EFBD4F988D12}{28BD465B-2CF8-4D1B-A9E5-7BB9F541DF6A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Attribute VB_Name = "frmOpen"
Attribute VB_Base = "0{BF69FE36-3178-4174-B024-C63BE8AD23B3}{E4B210F2-C2B5-4689-85CA-36945DB293D6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'V3.6

Private Declare PtrSafe Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" _
  Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, _
  ByVal lpKeyName As Any, ByVal lpString As Any, _
  ByVal lpFileName As String) As Long



Private Sub cmdAdd_Click()
    If txtPath.text <> "" Then
        Dim s As String
        s = Dir(txtPath & "\.", vbDirectory)
        If s <> "" Then
            lbPath.AddItem txtPath
            SavePathsToReg
        End If
    End If
End Sub


Private Sub cmdDel_Click()
    If lbPath.ListIndex <> -1 Then
        lbPath.RemoveItem lbPath.ListIndex
        SavePathsToReg
    End If
End Sub

Private Sub cmdOpen_Click()
    If lbFiles.ListIndex <> -1 Then
        Workbooks.Open lbFiles.List(lbFiles.ListIndex, 3)
        Hide
    End If
End Sub

Private Sub cmdRefresh_Click()

    lbFiles.Clear

    Dim i As Integer
    For i = 0 To lbPath.ListCount - 1
        ReadDir lbPath.List(i)
    Next
    
    
End Sub


Sub ReadDir(sPath As String)
    If Right(sPath, 1) <> "\" Then
        sPath = sPath & "\"
    End If
    
    Dim sFile As String
    Dim nState As Integer
    Dim bShowFile As Boolean
    
    sFile = Dir(sPath & "\*.xls?", vbNormal)
    
    
    
    Do
        If sFile <> "" Then
            nState = GetState(sPath & sFile)
            bShowFile = False
            Select Case nState
            Case 0 ' unbekannt oder leer
                bShowFile = False
            Case 1 ' unvollst|fffd|ndig
                bShowFile = Not chkComplete.Value
            Case 2 ' vollst|fffd|ndig
                bShowFile = True
            Case 3 ' abgeschlossen
                bShowFile = False
            End Select
            
            
            
            If bShowFile Then
                Dim sShowPath As String
                sShowPath = Right(sPath, 50)
                If Len(sPath) > Len(sShowPath) Then
                    sShowPath = "... " & sShowPath
                End If
                
                lbFiles.AddItem GetGF(sPath & sFile)
                lbFiles.List(lbFiles.ListCount - 1, 1) = GetStateText(nState)
                lbFiles.List(lbFiles.ListCount - 1, 2) = sShowPath
                lbFiles.List(lbFiles.ListCount - 1, 3) = sPath & sFile
            End If
        End If
        sFile = Dir
    Loop Until sFile = ""
End Sub

Function GetStateText(nState As Integer) As String
    Select Case nState
    Case 0
        GetStateText = "unbekannt"
    Case 1
        GetStateText = "unvollst|fffd|ndig"
    Case 2
        GetStateText = "vollst|fffd|ndig"
    Case 3
        GetStateText = "abgeschlossen"
    End Select
    
    
End Function

Function GetGF(sFile) As String
    Dim sINIFile As String
    sINIFile = sFile & ".ini"
    
    Dim s As String * 300
    GetPrivateProfileString "General", "GF", "<Fehler>", s, 300, sINIFile
    GetGF = Trim2(s)

End Function

Function GetState(sFile As String)
    
    Dim sINIFile As String
    sINIFile = sFile & ".ini"
    
    
    Dim dINIDate As Date
    Dim dFileDate As Date
    
    On Error Resume Next
    dINIDate = FileDateTime(sINIFile)
    dFileDate = FileDateTime(sFile)
    On Error GoTo 0
    
    Dim sImportComplete As String
    Dim sInputComplete As String
    Dim sGF As String
    
    sImportComplete = ""
    sInputComplete = ""
    sGF = ""
    
    Dim s As String * 300
    
    If dINIDate >= dFileDate Then
        GetPrivateProfileString "General", "ImportComplete", "Nein", s, 300, sINIFile
        sImportComplete = Trim2(s)
        
        GetPrivateProfileString "General", "InputComplete", "Nein", s, 300, sINIFile
        sInputComplete = Trim2(s)
        
        
        GetPrivateProfileString "General", "GF", "Nein", s, 300, sINIFile
        sGF = Trim2(s)
    Else
        Dim wk As Workbook
        Set wk = Workbooks.Open(sFile, False, True, , , , , , , False)
        
        On Error Resume Next
        sImportComplete = Range("startImportComplete")
        sInputComplete = Range("startInputComplete")
        sGF = Range("bestandslisteGeschaeftsfallNummer")
        On Error GoTo 0
        
        wk.Close False
        
        WritePrivateProfileString "General", "ImportComplete", sImportComplete, sINIFile
        WritePrivateProfileString "General", "InputComplete", sInputComplete, sINIFile
        WritePrivateProfileString "General", "GF", sGF, sINIFile
        
    End If
    
    If sImportComplete & sInputComplete & sGF = "" Then
        GetState = 0
    ElseIf UCase(sImportComplete) = "JA" Then
        GetState = 3
    ElseIf UCase(sInputComplete) = "JA" Then
        GetState = 2
    Else
        GetState = 1
    End If
        

End Function


Private Sub cmdUpdate_Click()
    If (lbPath.ListIndex <> -1) And (txtPath <> "") Then
        lbPath.List(lbPath.ListIndex) = txtPath
        SavePathsToReg
    End If
End Sub

Private Sub lbPath_Click()
    If lbPath.ListIndex <> -1 Then
        txtPath = lbPath.List(lbPath.ListIndex)
    End If
    
End Sub

Sub ReadPathsFromReg()
    Dim i As Integer
    i = 1
    Dim sPath As String
    
    lbPath.Clear
    Do
        sPath = GetSetting("CITExcel", "Path", "Path" & i, "")
        If sPath <> "" Then
            lbPath.AddItem sPath
        End If
        i = i + 1
    Loop Until sPath = ""
    
    

End Sub

Public Sub SavePathsToReg()
    Dim i As Integer
    i = 1
    Dim sPath As String
    
    Do
        sPath = GetSetting("CITExcel", "Path", "Path1", "")
        If sPath <> "" Then
            DeleteSetting "CITExcel", "Path", "Path" & i
        End If
        i = i + 1
    Loop Until sPath = ""
    For i = 0 To lbPath.ListCount - 1
        SaveSetting "CITExcel", "Path", "Path" & i + 1, lbPath.List(i)
    Next
    
End Sub

Private Sub UserForm_Activate()
    ReadPathsFromReg
End Sub

Attribute VB_Name = "frmPK"
Attribute VB_Base = "0{1C1C3932-0197-4049-A759-BDF95E995025}{29CFE07D-5185-402A-A985-709F5E6F818A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public sPK1 As String

Public sPK2 As String
Public sPK3 As String
Public sPK4 As String
Public nLine As Long



Private Sub cbBereich_Change()
    cbFunktion = ""
    If cbBereich = "" Then
        cbFunktion.Clear
    Else
        cbFunktion.Clear
        Dim x As Integer
        x = 1
        While ExistInCol(colPK2, cbBereich & "\#" & x)
            cbFunktion.AddItem colPK2(cbBereich & "\#" & x)
            x = x + 1
        Wend
    End If
                
                
End Sub


Private Sub cbFunktion_Change()
    cbGruppe = ""
    If cbFunktion = "" Then
        cbGruppe.Clear
    Else
        cbGruppe.Clear
        Dim x As Integer
        x = 1
        While ExistInCol(colPK3, cbBereich & "\" & cbFunktion & "\#" & x)
            cbGruppe.AddItem colPK3(cbBereich & "\" & cbFunktion & "\#" & x)
            x = x + 1
        Wend
    End If

End Sub

Private Sub cbGruppe_Change()
    cbName = ""
    If cbGruppe = "" Then
        cbName.Clear
    Else
        cbName.Clear
        Dim x As Integer
        x = 1
        While ExistInCol(colPK4, cbBereich & "\" & cbFunktion & "\" & cbGruppe & "\#" & x)
            cbName.AddItem colPK4(cbBereich & "\" & cbFunktion & "\" & cbGruppe & "\#" & x)
            x = x + 1
        Wend
    End If
End Sub

Private Sub UserForm_Activate()
    
    Dim s As Variant
    cbBereich.Clear
    For Each s In colPK1
        cbBereich.AddItem s
    Next
    cbBereich = ""
            
    If sPK1 <> "" Then cbBereich = GetCellByTitle(sPK1, nLine) Else cbBereich.Enabled = False
    If sPK2 <> "" Then cbFunktion = GetCellByTitle(sPK2, nLine) Else cbFunktion.Enabled = False
    If sPK3 <> "" Then cbGruppe = GetCellByTitle(sPK3, nLine) Else cbGruppe.Enabled = False
    If sPK4 <> "" Then cbName = GetCellByTitle(sPK4, nLine) Else cbName.Enabled = False
End Sub

Private Sub UserForm_Terminate()
    If sPK1 <> "" Then GetCellByTitle(sPK1, nLine) = cbBereich
    If sPK2 <> "" Then GetCellByTitle(sPK2, nLine) = cbFunktion
    If sPK3 <> "" Then GetCellByTitle(sPK3, nLine) = cbGruppe
    If sPK4 <> "" Then GetCellByTitle(sPK4, nLine) = cbName
End Sub


Attribute VB_Name = "modFunctions"
Option Explicit

Public Const nCellPosRangeSheet = 1
Public Const nCellPosRangeName = 2
Public Const nCellPosRangeTitle = 3
Public Const nCellPosRangeInsertAllowed = 4
Public Const nCellPosRangeDeleteAllowed = 5
Public Const nCellPosRangeGetByTitle = 6
Public Const nCellPosRangeVisibility = 7
Public Const nCellPosRangeDeleteMode = 8
Public Const nCellPosRangeTransferMode = 9
Public Const nCellPosRangeRecalculate = 10
Public Const nCellPosRangeVisiblityMode = 11


Public Const cCIFlag_PreventDelete = 1 'verhindert das l|fffd|schen von CIs, welche aus den Toolkit-Definitionen entfernt werden
Public Const cCIFlag_PreventCreate = 2 'verhindern das anlegen von CIs, wird verwendet wenn bereits existierende CIs in den Toolkit eingetragen werden
Public Const cCIFlag_ForceProperties = 4 'erzwingt das setzten von Properties auch wenn das CI nicht vom Toolkit erzeugt wurde
Public Const cCIFlag_JustDelete = 8 'bewirkt das ein eingetragenes CIs nicht angelegt, sondern gleich gel|fffd|scht wird. sollte mit PreventDelete kombiniert werden, da l|fffd|schen sonst unter umst|fffd|nden 2x angestossen wird
Public Const cCIFlag_DeleteComplete = 16 'best|fffd|tigt das l|fffd|schen per JustDelete, wird automatisch vergeben
Public Const cCIFlag_NoBulk = 32 'Kein Bulk, CIs mit der Menge >1 werden auf mehrere CIs aufgeteilt
Public Const cCIFlag_WriteBackCINo = 64 'CI-Nummern werden in die Quell-Zeile zur|fffd|ckgeschrieben
'V4.13
Public Const cCIFlag_SLMinVorerfassung = 128 'SLM Zeilen werden |fffd|ber die Vorerfassung bef|fffd|llt, diese d|fffd|rfen sich nach dem Anlegen nicht mehr ver|fffd|ndern. Daf|fffd|r kann auch das Feld "Kommentar Vertragsverwaltung" bef|fffd|llt werden.
'V4.23
Public Const cCIFlag_DWHConnections = 256 'Aktive Verbindungen werden immer aus dem DWH ausgelesen

'V4.04
Public nextFree As Integer


Private m_bMonitorLookup As Boolean
'V3.10
Private m_bSuperMonitorLookup As Boolean
Private m_bLookupDirty As Boolean

Private Const nCellPosLookupCIType = 1
Private Const nCellPosLookupPropertyFilter = 2
Private Const nCellPosLookupPKFilter = 3
Private Const nCellPosLookupRange = 4
Private Const nCellPosLookupNamesRange = 5
Private Const nCellPosLookupRangeDirty = 6
Private Const nCellPosLookupNoUpdate = 7
Private Const nCellPosLookupQuellFilter = 8
Private Const nCellPosLookupActivationRange = 9
Private Const nCellPosLookupValueStart = 10
Private Const nLookupvaluecount = 9
'V3.8
Private Const nCellPosLookupCustomName = 19

'V1.985
Public colGUIDs As Collection


'V3.1
Public colProps As Collection 'wird verwendet um bei anlegen von bestandsliste-eintr|fffd|gen von CIs mit Flag=4

'V4.20
'V3.1
'Const cNavUrl = "navision://client/run?servername=s900vs01%5Ckbc%26database=SBC%26company=Kapsch%20BusinessCom%20AG%26target=Form%20##form##%26view=SORTING(Field1)%26position=Field1=0(##ci##)%26servertype=MSSQL"
Const cNavUrl = "dynamicsnav://172.18.98.69:17000/NST_AT_KBC_001//runpage?page=##form##&$filter='Nr.'%20IS%20'##ci##'"


'V4.5
Public colPK As Collection
Public colPK1 As Collection
Public colPK2 As Collection
Public colPK3 As Collection
Public colPK4 As Collection


'V3.10
Function RefreshDatabase()
    Dim dbquery As New CDBQuery
    
    MonitorLookup = True
    m_bSuperMonitorLookup = True
    
    InitSheetVariables
    dbquery.RefreshSheet Range("cisettingsDBDatasources"), Range("cisettingsDBStatements"), ActiveWorkbook.ActiveSheet
    
    MonitorLookup = True
    m_bSuperMonitorLookup = False
    
    MonitorLookup = False
    
End Function

'V3.10
Function RefreshDatabaseAll()
    Dim dbquery As New CDBQuery
    
    Dim sheet As Worksheet
    
    For Each sheet In ActiveWorkbook.Worksheets
    
        
        MonitorLookup = True
        m_bSuperMonitorLookup = True
        
        InitSheetVariables
        
        dbquery.RefreshSheet Range("cisettingsDBDatasources"), Range("cisettingsDBStatements"), sheet
        
        MonitorLookup = True
        m_bSuperMonitorLookup = False
        
        MonitorLookup = False
    Next
    
End Function


'V3.10
Public Function ExtractHostname(s As String) As String
    Dim v As Variant
    v = Split(s, " ")
    Dim sFQDN As String
    
    On Error Resume Next
    
    If Trim(s) = "" Then Exit Function
    
    
    If v(0) = "DK" Then
        sFQDN = v(2)
    Else
       sFQDN = v(0)
    End If
    
    If sFQDN <> "" Then
        v = Split(sFQDN, ".")
        ExtractHostname = v(0)
    End If

    
        
End Function

'V3.8
Function ReadTracking() As Collection
    
    Dim rLastTracking As Range
    Set rLastTracking = Range("lastTracking")
    Dim i As Long
    Dim track As CTracking
    Dim col As Collection
    Set col = New Collection
    Dim n As Long
    
    For i = 1 To rLastTracking.rows.Count
        If rLastTracking.Cells(i, 1) = "" Then Exit For
        
        Set track = New CTracking
        track.sCIType = rLastTracking.Cells(i, 1)
        track.sCINr = rLastTracking.Cells(i, 2)
        track.sTrackingType = rLastTracking.Cells(i, 3)
        track.nMenge = CLng(rLastTracking.Cells(i, 4))
        
        col.Add track, track.GetKey
    
    Next
    
    Set ReadTracking = col


End Function

'V3.8
Function WriteTracking(col As Collection)
    
    Dim rLastTracking As Range
    Set rLastTracking = Range("lastTracking")
    Dim i As Long
    Dim track As CTracking

    rLastTracking.ClearContents
    
        
    For i = 1 To col.Count
        Set track = col(i)
        rLastTracking.Cells(i, 1) = track.sCIType
        rLastTracking.Cells(i, 2) = track.sCINr
        rLastTracking.Cells(i, 3) = track.sTrackingType
        rLastTracking.Cells(i, 4) = track.nMenge
    Next

End Function

'V3.8
Sub GetTracking()
    InitSheetVariables
    
    Dim i As Long
    
    Dim col As Collection
    Dim track As CTracking
    Dim track2 As CTracking
    
    Dim sKey As String
    Dim sGUID As String
    
    Dim rResult As Range
    Set rResult = Range("currentTracking")
    rResult.ClearContents
    
    
    Set col = ReadTracking
    
        
    
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsCITracking")
    
    Dim rData As Range
    Dim nData As Long
    
    Dim sOperation As String
    
    For i = 1 To rDefinition.rows.Count
        If rDefinition.Cells(i, 1) = "" Then Exit For
        
        Set rData = Range(rDefinition.Cells(i, 2))
        
        For nData = 1 To rData.rows.Count
            If LineEmpty(rData, nData) Then Exit For
            
            sGUID = GetDataCellFromRange(rDefinition.Cells(i, 2), rDefinition.Cells(i, 3), nData)
            If sGUID <> "" Then
                Dim nMenge As Long
                Dim oT91 As CT91
                Set oT91 = New CT91
                oT91.Init rDefinition, i, rDefinition.Cells(i, 2), nData
                nMenge = oT91.t91(5)
                Set oT91 = Nothing
        
            
                Dim x As Long
                x = GetBestandslineByGUID(sGUID)
                If x <> -1 Then
                
                    sOperation = rDefinition.Cells(i, 4)
                    
                    Dim v As Variant
                    v = Split(GetCellByTitle("bestandsliste_CI Nummer", x), ", ")
                    Dim i1 As Long
                    For i1 = LBound(v) To UBound(v)
                        Set track2 = New CTracking
                        track2.sCINr = v(i1)
                        track2.sCIType = GetCellByTitle("bestandsliste_CI Type", x)
                                                        
                        Select Case sOperation
                        Case "+", "-"
                            track2.sTrackingType = "+/-"
                        End Select
                        
                        Set track = Nothing
                        If ExistInCol(col, track2.GetKey) Then
                            Set track = col(track2.GetKey)
                            col.Remove track2.GetKey
                        Else
                            Set track = track2
                        End If
                        
                            
                        Select Case sOperation
                        Case "+"
                            track.nDiffMenge = track.nDiffMenge + nMenge
                        Case "-"
                            track.nDiffMenge = track.nDiffMenge - nMenge
                        End Select
                        
                        col.Add track, track.GetKey
                    Next
                End If
            End If
        Next
    Next
    
    
    i = 1
    
    For Each track In col
        If track.nDiffMenge <> track.nMenge Then
            rResult.Cells(i, 1) = track.sCIType
            rResult.Cells(i, 2) = track.sCINr
            rResult.Cells(i, 3) = track.nDiffMenge - track.nMenge
            i = i + 1
        End If
    Next
    
    UnloadSheetVariables

End Sub


'V4.18
Sub ExportDeletes(wk As Workbook)

    InitSheetVariables

    Dim wk2 As Workbook
    Set wk2 = Application.Workbooks.Add
    wk.Activate
    
    Dim shexport As Worksheet
    Set shexport = wk2.Worksheets(1)
    
    
    shexport.UsedRange.Clear
    
    Dim i As Long, n As Long
    
    i = 1
    n = 0
    
    Dim rDelete As Range
    Set rDelete = Range("deleteCIs")
    
    For i = 1 To rDelete.rows.Count
        If rDelete.Cells(i, 1) = "" Then Exit For
        n = n + 1
        shexport.Cells(n, 1) = Range("bestandslisteGeschaeftsfalltype")
        shexport.Cells(n, 2) = Range("bestandslisteGeschaeftsfallNummer")
        shexport.Cells(n, 3) = rDelete.Cells(i, 1)
        shexport.Cells(n, 4) = rDelete.Cells(i, 2)
        'shexport.Cells(n, 5) = rTracking.Cells(i, 3)
            
        
    Next
    If n <> 0 Then
        
        Dim sPath As String
        sPath = wk.Path & "\gfreiter_del_" & Range("bestandslisteAnlagenprojekt") & "_" & Application.UserName & "_" & Format(Now, "yyyymmddhhMMss") & ".txt"
        wk2.SaveAs Filename:=sPath, FileFormat:= _
        xlCSVMSDOS, CreateBackup:=False, Local:=True

        wk2.Close False
        
        Addlog "Datei mit zu l|fffd|schenden CIs wurde nach " & sPath & " exportiert"
        'V3.9
        CopyString sPath
        
    Else
        Addlog "Keine Zeilen gefunden!"
        wk2.Close False
    End If
    
    UnloadSheetVariables



End Sub



'V3.8
Sub ExportTracking(wk As Workbook)

    InitSheetVariables

    Dim wk2 As Workbook
    Set wk2 = Application.Workbooks.Add
    wk.Activate
    
    Dim shexport As Worksheet
    Set shexport = wk2.Worksheets(1)
    
    
    shexport.UsedRange.Clear
    
    Dim i As Long, n As Long
    
    i = 1
    n = 0
    
    Dim rTracking As Range
    Set rTracking = Range("currentTracking")
    
    For i = 1 To rTracking.rows.Count
        If rTracking.Cells(i, 1) = "" Then Exit For
        n = n + 1
        shexport.Cells(n, 1) = Range("bestandslisteGeschaeftsfalltype")
        shexport.Cells(n, 2) = Range("bestandslisteGeschaeftsfallNummer")
        shexport.Cells(n, 3) = rTracking.Cells(i, 1)
        shexport.Cells(n, 4) = rTracking.Cells(i, 2)
        shexport.Cells(n, 5) = rTracking.Cells(i, 3)
            
        
    Next
    If n <> 0 Then
        
        Dim sPath As String
        sPath = wk.Path & "\gfreiter_" & Range("bestandslisteAnlagenprojekt") & "_" & Application.UserName & "_" & Format(Now, "yyyymmddhhMMss") & ".txt"
        wk2.SaveAs Filename:=sPath, FileFormat:= _
        xlCSVMSDOS, CreateBackup:=False, Local:=True

        wk2.Close False
        
        Addlog "Datei f|fffd|r GF-Reiter wurde nach " & sPath & " exportiert"
        'V3.9
        CopyString sPath
        
    Else
        Addlog "Keine Zeilen gefunden!"
        wk2.Close False
    End If
    
    UnloadSheetVariables
    
    
End Sub



'V3.4
'Diese Funktion exportiert alle relevanten Daten in das CMSSyncUpdate Verzeichnis
Public Sub CMSSyncUpdate()

    InitSheetVariables
    

    '|fffd|ffnen der datebank
    Dim cnn As ADODB.connection
    Set cnn = DBConnect
    If Not cnn Is Nothing Then
        If cnn.State = adStateOpen Then
            
            'Datenbank ist offen
            
            
            Dim sRealm As String, sModule As String
            sRealm = Range("settingsSyncRealm")
            sModule = Range("settingsSyncModule")
            If sModule = "" Then sModule = "CITExcel"
            
            Dim stmt As String
            Dim rs As ADODB.Recordset
            Dim rsFM As ADODB.Recordset
            
            
            'laden der SyncSource Eintr|fffd|ge die sich auf dieses Excel bezeihen
            stmt = "select SyncSourceID, ss_name, sp_name from t_syncsource,t_realm, t_syncprofile WHERE (t_syncsource.SyncProfileID=t_syncprofile.SyncProfileID) and (t_syncprofile.RealmID=t_realm.RealmID) and " & _
                " (r_name='" & sRealm & "') and (ss_module='" & sModule & "')"
            Set rs = cnn.Execute(stmt)
            
            Dim colFields As Collection
            Dim colFilter As Collection
            
            'f|fffd|r alle SyncSource Eintr|fffd|ge
            While Not rs.EOF
                
                Set colFilter = New Collection
                Set colFields = New Collection
                
                'Laden der Feldmappings zu einer SyncSource
                stmt = "select fm_sourcefield, fm_filter from t_fieldmapping where SyncSourceID=" & rs!SyncSourceID
                Set rsFM = cnn.Execute(stmt)
                Dim i1 As Long
                Dim x1 As Long
                Dim vField As Variant
                
                'F|fffd|r alle FeldMappings
                While Not rsFM.EOF
                
                    'Source Fields aus dem FeldMapping extrahieren
                    Dim vFields As Variant
                    vFields = Split(Trim("" & rsFM!fm_sourcefield), "[")
                    For i1 = LBound(vFields) To UBound(vFields)
                        
                        
                        x1 = InStr(vFields(i1), "]")
                        If x1 <> 0 Then
                            vField = Left(vFields(i1), x1 - 1)
                            If vField <> "" Then
                                On Error Resume Next
                                colFields.Add vField, vField
                                On Error GoTo 0
                            End If
                        End If
                    Next
                    
                    'filter vorhanden und anwendbar? anwendbar = enth|fffd|lt genaue eine Variable unter [], keinen komplexen Ausdruck im filter oder im sourcefield
                    If ("" & rsFM!fm_filter <> "") And ("" & rsFM!fm_sourcefield <> "") Then
                        If (Left(rsFM!fm_sourcefield, 1) = "[") And (Right(rsFM!fm_sourcefield, 1) = "]") And (InStr(Mid("" & rsFM!fm_sourcefield, 2), "[") = 0) And ((Left(rsFM!fm_filter, 3) = "<>""") Or (Left(rsFM!fm_filter, 2) = "=""")) And (UBound(Split(rsFM!fm_filter, """")) = 2) Then
                        
                            On Error Resume Next
                            colFilter.Add "" & rsFM!fm_filter, Mid("" & rsFM!fm_sourcefield, 2, Len("" & rsFM!fm_sourcefield) - 2)
                            On Error GoTo 0
                        End If
                    End If
                    
                    rsFM.MoveNext
                Wend
                
                rsFM.Close
                
                
                'bestandsliste durchsteppen
                Dim i2 As Long
                i2 = 1
                
                Dim dict As Scripting.Dictionary
                
                Dim colExport As Collection
                Set colExport = New Collection
                
                Dim bIgnoreLine As Boolean
                
                
                While Not LineEmpty(Range("bestandsliste"), i2)
                    bIgnoreLine = False
                    
                    'ein Dictionary entspricht einem Datensatz
                    Set dict = New Scripting.Dictionary
                    For Each vField In colFields
                        If ExistCellByTitle("bestandsliste_" & vField) Then
                            
                            'Feld an Dictionary anh|fffd|ngen
                            dict.Add vField, "" & GetCellByTitle("bestandsliste_" & vField, i2)
                            
                            
                            If ExistInCol(colFilter, "" & vField) Then
                                Dim sFilter As String
                                Dim sFilterValue As String
                                Dim vFilter As Variant
                                sFilter = colFilter(vField)
                                vFilter = Split(sFilter, """")
                                If UBound(vFilter) > 0 Then
                                    Select Case vFilter(0)
                                    Case "="
                                        If dict(vField) <> vFilter(1) Then
                                            bIgnoreLine = True
                                            Exit For
                                        End If
                                    Case "<>"
                                        If dict(vField) = vFilter(1) Then
                                            bIgnoreLine = True
                                            Exit For
                                        End If
                                        
                                    End Select
                                End If
                            End If
                        End If
                    Next
                    
                    'Kein Filter gefunden der gegen die |fffd|bernahme dieses Datensatzes spricht
                    If Not bIgnoreLine Then
                        colExport.Add dict
                    End If
                                
                                
                    i2 = i2 + 1
                Wend
                
                'Debug.Print JSON.toString(colExport)
                'Datei schreiben
                If colExport.Count <> 0 Then
                    Dim sFileName As String
                    sFileName = Range("settingsSyncJobDir")
                    If Right(sFileName, 1) <> "\" Then
                        sFileName = sFileName & "\"
                    End If
                    sFileName = sFileName & replaceforbiddenchars(sRealm & "_" & rs!sp_name & "_" & rs!ss_name) & "_" & Format(Now, "yyyyddmmhhMMss") & ".txt"
                    
                    Dim nfn As Long
                    nfn = FreeFile
                    Open sFileName For Output As #nfn
                    Print #nfn, JSON.toString(colExport)
                    Close #nfn
                    
                    'Job in Datenbank eintragen
                    stmt = "insert into t_importjob(SyncSourceID,ij_filepath) values (" & rs!SyncSourceID & ",'" & sFileName & "')"
                    cnn.Execute stmt
                    
                End If
                
                rs.MoveNext
            Wend
                
        End If
        rs.Close
        
        
        On Error Resume Next
        cnn.Close
        On Error GoTo 0
    End If
    

End Sub


Private Function DBConnect() As ADODB.connection
    Dim cnn As New ADODB.connection
    Dim sCOnnect As String
    On Error Resume Next
    sCOnnect = ""
    sCOnnect = Range("settingsSyncDB")
    On Error GoTo 0
    
    If sCOnnect <> "" Then
        cnn.Open sCOnnect
    End If
    Set DBConnect = cnn
    
End Function



'Simuliert |fffd|nderungen in allen verwendeten Bereichen um so ein Sheet zu aktualisieren, dass m|fffd|glicherweise ohne die Nutzung des Toolkits ver|fffd|ndert wurde.
Public Sub NeuBerechnen()
    InitSheetVariables
    
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsRanges")
    
    Dim col As New Collection
    
    Dim i As Long
    i = 1
    Dim sRangeName As String
    Dim x As Long
    While Not rDefinition.Cells(i, 1) = ""
        If rDefinition.Cells(i, nCellPosRangeRecalculate) <> "" Then
        
            
            sRangeName = rDefinition.Cells(i, nCellPosRangeName)
            'V4.11
            'x = GetNextInRange(sRangeName, 1)
            'V4.25
            'x = GetNextInRange(rDefinition.Cells(i, nCellPosRangeSheet) & "#" & sRangeName, 1)
            x = GetNextInRange(rDefinition.Cells(i, nCellPosRangeSheet) & "#" & sRangeName, 1, bExtendRange:=True)
            
            
            If Not ExistInCol(col, sRangeName) Then
                col.Add CVar(x), sRangeName
            End If
        End If
        i = i + 1
    Wend
    
    Set rDefinition = Range("cisettingsCIGeneration")
    i = 2
    
    Dim cigen As New CCIGeneration
    While Not rDefinition.Cells(i, 1) = ""
        sRangeName = rDefinition.Cells(i, cigen.GetCellPosRange)
        If ExistInCol(col, sRangeName) Then
        
            'V4.11
            'x = GetNextInRange(sRangeName, cigen.GetCellPosGUID)
            'V4.25
            'x = GetNextInRange(rDefinition.Cells(i, nCellPosRangeSheet) & "#" & sRangeName, cigen.GetCellPosGUID)
            x = GetNextInRange(rDefinition.Cells(i, nCellPosRangeSheet) & "#" & sRangeName, cigen.GetCellPosGUID, bExtendRange:=True)
            
            If x > CLng(col(sRangeName)) Then
                col.Remove sRangeName
                col.Add CVar(x), sRangeName
            End If
        End If
        i = i + 1
    Wend
        
    Set rDefinition = Range("cisettingsRanges")
    i = 1
    While Not rDefinition.Cells(i, 1) = ""
        If rDefinition.Cells(i, nCellPosRangeRecalculate) <> "" Then
            sRangeName = rDefinition.Cells(i, nCellPosRangeName)
            If ExistInCol(col, sRangeName) Then
                x = CLng(col(sRangeName)) - 1
                
                If x <> 0 Then
                
                    'V4.11
                    Dim v As Variant
                    v = Split(rDefinition.Cells(i, nCellPosRangeSheet), "#")
                    If UBound(v) = 1 Then
                        If Left(sRangeName, 1) = "!" Then
                            UpdateLookups_And_CIs Workbooks(v(0)).Worksheets(v(1)).ListObjects(Mid(sRangeName, 2)).DataBodyRange
                        Else
                            UpdateLookups_And_CIs Range(Workbooks(v(0)).Worksheets(v(1)).Range(sRangeName).Cells(1, 1), Workbooks(v(0)).Worksheets(v(1)).Range(sRangeName).Cells(x, Workbooks(v(0)).Worksheets(v(1)).Range(sRangeName).Columns.Count))
                        End If
                    Else
                    
                        UpdateLookups_And_CIs Range(Range(sRangeName).Cells(1, 1), Range(sRangeName).Cells(x, Range(sRangeName).Columns.Count))
                    
                    'V4.11
                    End If
                    
                End If
            End If
        End If
        i = i + 1
    Wend
        
    UnloadSheetVariables

End Sub

'Der |fffd|bergebene Range repr|fffd|sentiert einzuf|fffd|gende Zeilen. Die FUnktion |fffd|berpr|fffd|ft ob das zul|fffd|ssig ist
Public Function InsertAllowed2(rInsert As Range) As Boolean
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsRanges")
    Dim i As Integer
    i = 1
    While Not rDefinition.Cells(i, 1) = ""
        If rDefinition.Cells(i, nCellPosRangeInsertAllowed) <> "" Then
            If InsertAllowedForRange2(rInsert, Range(rDefinition.Cells(i, nCellPosRangeName))) Then
                InsertAllowed2 = True
            End If
        End If
        i = i + 1
    Wend
        
End Function

'Der |fffd|bergebene Range repr|fffd|sentiert zu l|fffd|schende Zeilen. Die FUnktion |fffd|berpr|fffd|ft ob das zul|fffd|ssig ist
Public Function DeleteAllowed2(rInsert As Range) As Boolean
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsRanges")
    Dim i As Integer
    i = 1
    While Not rDefinition.Cells(i, 1) = ""
        If rDefinition.Cells(i, nCellPosRangeDeleteAllowed) <> "" Then
            If DeleteAllowedForRange2(rInsert, Range(rDefinition.Cells(i, nCellPosRangeName))) Then
                DeleteAllowed2 = True
            End If
        End If
        i = i + 1
    Wend
        
End Function




'Erh|fffd|lt 2 Ranges. EInen der einzuf|fffd|gende Zeilen enth|fffd|lt und einen bei dem das Einf|fffd|gen erlaubt ist. |fffd|berp|fffd|ft
' ob die beiden Ranges sich |fffd|berschneiden und ob an dieser Position eingef|fffd|gt werden darf.
Public Function InsertAllowedForRange2(rInsert As Range, rCheck As Range) As Boolean
    If rInsert.Parent.Name = rCheck.Parent.Name Then
        If RangesOverlapping(rInsert.rows(1), rCheck) Then
            If RangesOverlapping(rInsert.rows(1).Offset(-1), rCheck) Then InsertAllowedForRange2 = True
        End If
    End If
End Function

'Erh|fffd|lt 2 Ranges. Einen der zu l|fffd|schende Zeilen enth|fffd|lt und einen bei dem das L|fffd|schen erlaubt ist. |fffd|berpr|fffd|ft
' ob die beiden Ranges sich |fffd|berschneiden und ob an dieser Position gel|fffd|scht werden darf.
Private Function DeleteAllowedForRange2(rDelete As Range, rCheck As Range) As Boolean
    If rCheck.rows.Count > 2 Then
        If rDelete.Parent.Name = rCheck.Parent.Name Then
            If RangesOverlapping(rDelete.rows(1), rCheck) Then DeleteAllowedForRange2 = True
        End If
    End If
End Function


Function GetRangeFromOtherWB(sRangeName As String, wk As Workbook) As Range
    'V4.1
    'Set GetRangeFromOtherWB = GetSheetByNameWB(SheetName(Range(sRangeName).Parent), wk).Range(sRangeName)
    Dim oName As Name
    Set oName = wk.Names(sRangeName)
    Dim sReferTo As String
    sReferTo = Mid(oName.RefersTo, 2)
    If Left(sReferTo, 1) <> "'" Then
        Dim x As Long
        x = InStr(sReferTo, "!")
        sReferTo = "'[" & wk.Name & "]" & Left(sReferTo, x - 1) & "'" & Mid(sReferTo, x)
    Else
        sReferTo = "'[" & wk.Name & "]" & Mid(sReferTo, 2)
    End If
    Set GetRangeFromOtherWB = Range(sReferTo)

End Function


Public Function InsertAllowedForRange(rInsert As Range, rCheck As Range) As Boolean
    If rInsert.Parent.Name = rCheck.Parent.Name Then
        If RangesOverlapping(rInsert.rows(1), rCheck) Then
            If RangesOverlapping(rInsert.rows(1).Offset(-1), rCheck) Then InsertAllowedForRange = True
        End If
    End If
End Function


Private Function DeleteAllowedForRange(rDelete As Range, rCheck As Range) As Boolean
    If rCheck.rows.Count > 2 Then
        If rDelete.Parent.Name = rCheck.Parent.Name Then
            If RangesOverlapping(rDelete.rows(1), rCheck) Then DeleteAllowedForRange = True
        End If
    End If
End Function



'V4.2
'Public Sub Import()
 Public Sub Import(Optional sWkSource As String = "")
    
    Dim wk As Workbook
    Dim wk2 As Workbook
    
    On Error Resume Next
    
    Dim x As Long
    
    'V4.2
    If sWkSource = "" Then
        
        If Application.Workbooks.Count > 2 Then
            MsgBox "Zu viele Arbeitsmappen ge|fffd|ffnet. Es d|fffd|rfen nur die neue und die zu importierende Arbeitsmappe in Excel ge|fffd|ffnet sein"
            Exit Sub
        End If
        If Application.Workbooks.Count = 1 Then
            MsgBox "Es wurde keine Arbeitsmappe zum Importieren gefunden"
        End If
        
        If Application.Workbooks(1).Name = ActiveWorkbook.Name Then
            Set wk2 = Application.Workbooks(2)
        Else
            Set wk2 = Application.Workbooks(1)
        End If
    
    'V4.2
    Else
        Set wk2 = Application.Workbooks(sWkSource)
    End If
    
    Set wk = ActiveWorkbook
    
    bAutomaticStopAutoMacros = True
    
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsRanges")
    Dim i As Integer
    i = 1
    While rDefinition.Cells(i, 1) <> ""
        If rDefinition.Cells(i, nCellPosRangeTransferMode) <> "" Then
            Select Case CLng(rDefinition.Cells(i, nCellPosRangeTransferMode))
            Case 0
                'nix
            Case 1
                TransferRange GetRangeFromOtherWB(rDefinition.Cells(i, nCellPosRangeName), wk2), Range(rDefinition.Cells(i, nCellPosRangeName)), 1
            Case 2
                TransferRange GetRangeFromOtherWB(rDefinition.Cells(i, nCellPosRangeName), wk2), Range(rDefinition.Cells(i, nCellPosRangeName)), 2
            Case 3
                TransferRangeByTitle GetRangeFromOtherWB(rDefinition.Cells(i, nCellPosRangeTitle), wk2), GetRangeFromOtherWB(rDefinition.Cells(i, nCellPosRangeName), wk2), Range(rDefinition.Cells(i, nCellPosRangeTitle)), Range(rDefinition.Cells(i, nCellPosRangeName))
            Case 4
                ClearRange Range(rDefinition.Cells(i, nCellPosRangeName)), 1
                
            End Select
 
             
             
        End If
        
        i = i + 1
    Wend
    
    
    
    
    'V2.3
    'Lookups Bezeichnungen aktualisieren
    Dim lookup As CLookupDefinition
    Dim col As Collection
    Dim x1 As Long
    Dim x2 As Long
    Dim r2 As Range
    Dim n As Name
    
    Set col = GetLookupDefinitions
    For Each lookup In col
        Set r2 = Range(lookup.sRange)
        x1 = GetNextInRange(lookup.sRange, 1, 2) - 1
        If x1 > 0 Then
            Set n = ActiveWorkbook.Names(lookup.sNamesRange)
            x2 = InStr(n.RefersToLocal, ":")
            n.RefersToLocal = Left(n.RefersToLocal, x2) & r2.Cells(x1, 1).Address
        End If
    Next

    'V4.1
    If DataUpgrade(wk, wk2, 4, 1) Then
        Dim colConn As Collection
        Set colConn = ReadConnections("_")
        GetConnections_Kontierung colConn
        WriteConnections colConn
        
    End If
    
    
    
    
    
    bAutomaticStopAutoMacros = False
    
    
    ToggleMode
    GetRibbon.Invalidate
    
    wk2.Close False
    
End Sub

'V4.1
'Liefert zur|fffd|ck ob ein neues Importiertes Worksheet beim Update eine bestimmte Versionsnummer |fffd|berspringt
Function DataUpgrade(wkNew As Workbook, wkOld As Workbook, nCheckVersion As Long, Optional nCheckMajor As Long = 0, Optional nCheckMinor As Long = 0) As Boolean
    
    Dim nWBNewVersion As Long
    Dim nWBNewVersionMajor As Long
    Dim nWBNewVersionMinor As Long
    Dim nWBOldVersion As Long
    Dim nWBOldVersionMajor As Long
    Dim nWBOldVersionMinor As Long
    
    nWBNewVersion = GetRangeFromOtherWB("startVersion", wkNew)
    nWBNewVersionMajor = GetRangeFromOtherWB("startVersionMajor", wkNew)
    nWBNewVersionMinor = GetRangeFromOtherWB("startVersionMinor", wkNew)
    nWBOldVersion = GetRangeFromOtherWB("startVersion", wkOld)
    nWBOldVersionMajor = GetRangeFromOtherWB("startVersionMajor", wkOld)
    nWBOldVersionMinor = GetRangeFromOtherWB("startVersionMinor", wkOld)

    If (CompareVersion(nWBOldVersion, nWBOldVersionMajor, nWBOldVersionMinor, nCheckVersion, nCheckMajor, nCheckMinor) < 0) And _
        (CompareVersion(nCheckVersion, nCheckMajor, nCheckMinor, nWBNewVersion, nWBNewVersionMajor, nWBNewVersionMinor) <= 0) Then
        DataUpgrade = True
    Else
        DataUpgrade = False
    End If
    
    
End Function



Sub TransferRange(rSource As Range, rTarget As Range, nMode As Integer)
    Dim i As Long, n As Long
    
    Select Case nMode
    Case 1
        rTarget.Cells(1, 1).Value = rSource.Cells(1, 1).Value
    
    Case 2
        On Error Resume Next
        rTarget.Parent.ShowAllData
        rTarget.ClearContents
        
        For i = 1 To rSource.rows.Count
            If (rSource.Cells(i, 1) = "") And (i <> 1) Then Exit For
                If i > rTarget.rows.Count Then
                    Addlog "Bereich auf Tabellenblatt " & rTarget.Parent.Name & " zu klein (" & i & "->" & rTarget.Address & ")"
                    Exit For
                End If
            
            
            For n = 1 To rSource.Columns.Count
                rTarget.Cells(i, n).Value = rSource.Cells(i, n)
            Next
        Next
    Case 3
        
    
    End Select
End Sub


Sub TransferRangeByTitle(rSourceTitle As Range, rSource As Range, rTargetTitle As Range, rTarget As Range)
    Dim colSource As New Collection
    Dim colTarget As New Collection
    LoadCellsByTitle rSourceTitle, rSource, "Source", colSource
    LoadCellsByTitle rTargetTitle, rTarget, "Target", colTarget
    
    On Error Resume Next
    rTarget.Parent.ShowAllData
    rTarget.ClearContents
    On Error GoTo 0
       
    
    Dim i As Long, n As Long
    For i = 1 To rSource.rows.Count
        Dim bLineEmpty As Boolean
        bLineEmpty = True
        For n = 1 To colSource.Count
            If rSource.Cells(i, n) <> "" Then
                bLineEmpty = False
                Exit For
            End If
        Next
        If bLineEmpty Then Exit For
        
        Dim cbt As CCellByTitle
        Dim cbt2 As CCellByTitle
        For Each cbt In colTarget
            If ExistInCol(colSource, "source" & "_" & cbt.sTitle) Then
                Set cbt2 = colSource("source" & "_" & cbt.sTitle)
                rTarget.Cells(i, cbt.nCol).Value = rSource.Cells(i, cbt2.nCol).Value
            End If
        Next
    Next
End Sub

Sub ClearRange(r As Range, nMode As Integer)
    Select Case nMode
    Case 0
        'don't delete
    Case 1
        On Error Resume Next
        r.Parent.ShowAllData
        r.ClearContents
    Case 2
        r.Value = "NEIN"
    Case 3
        r.Cells(1, 1) = ""
        
    End Select


End Sub


Public Sub ClearAll()
    bAutomaticStopAutoMacros = True
    
    Range("startMode") = "Datenerfassung"
    
    
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsRanges")
    Dim i As Integer
    i = 1
    While rDefinition.Cells(i, 1) <> ""
        If rDefinition.Cells(i, nCellPosRangeDeleteMode) <> "" Then
            ClearRange Range(rDefinition.Cells(i, nCellPosRangeName)), CLng(rDefinition.Cells(i, nCellPosRangeDeleteMode))
        End If
        
        i = i + 1
    Wend
        
    
    'ClearRange Range("applikationenAll"), 1
    'ClearRange Range("bestandlisteZumLoeschen"), 1
    'ClearRange Range("bestandslisteAnlagenprojekt"), 1
    'ClearRange Range("bestandslisteGeschaeftsfallNummer"), 1
    'ClearRange Range("bestandslisteGeschaeftsfalltype"), 1
    'ClearRange Range("currentConnections"), 1
    'ClearRange Range("currentProperties"), 1
    'ClearRange Range("DeleteCIs"), 1
    'ClearRange Range("dependentsliste"), 1
    'ClearRange Range("geraeteliste"), 1
    'ClearRange Range("hardwareAll"), 1
    'ClearRange Range("komponentenliste"), 1
    'ClearRange Range("kontakteAll"), 1
    'ClearRange Range("kontaktliste"), 1
    'ClearRange Range("kostenstellenAll"), 1
    'ClearRange Range("kostenstellenliste"), 1
    'ClearRange Range("lastConnections"), 1
    'ClearRange Range("lastProperties"), 1
    'ClearRange Range("lizenzliste"), 1
    'ClearRange Range("netzwerkAll"), 1
    'ClearRange Range("netzwerkliste"), 1
    'ClearRange Range("newCIsListe"), 1
    'ClearRange Range("projektdatenBuchblatt"), 1
    'ClearRange Range("druckerliste"), 1
    'ClearRange Range("clientliste"), 1
    'ClearRange Range("clientsoftwareliste"), 1
    'ClearRange Range("clienteqliste"), 1

    
    
    
'    Range("projektdatenKostenstellen") = "NEIN"
'    Range("projektdatenDrucker") = "NEIN"
'    Range("projektdatenClients") = "NEIN"
'    Range("projektdatenClientSoftware") = "NEIN"
'    Range("projektdatenKSI") = "NEIN"
    
'    ClearRange Range("projektdatenKundenkuerzel"), 1
    
'    Range("projektdatenProjektbezeichnung").Value = ""
    
'    ClearRange Range("projektdatenSLM"), 1
'    ClearRange Range("projektdatenStandort"), 1
'    ClearRange Range("projektdatenWeitereProjekte"), 1
'    ClearRange Range("serverliste"), 1
'    ClearRange Range("services"), 1
'    ClearRange Range("servicesAll"), 1
'    ClearRange Range("servicesExisting"), 1
'    ClearRange Range("servicesNetworkAll"), 1
'    ClearRange Range("servicesServerAll"), 1
'    ClearRange Range("virtualisierungAll"), 1
'    ClearRange Range("vorerfassung"), 1
'    ClearRange Range("projektdatenEreignisdatum"), 1
    
    
    bAutomaticStopAutoMacros = False
    
    
    ToggleMode
    Dim r As IRibbonUI
    Set r = GetRibbon
    r.Invalidate
    
    
End Sub


Property Get MonitorLookup() As Boolean
    MonitorLookup = m_bMonitorLookup
End Property
    
Property Let MonitorLookup(b As Boolean)
    If m_bMonitorLookup <> b Then
        m_bMonitorLookup = b
        'V3.10
        If Not m_bSuperMonitorLookup Then
        
            If b Then
            Else
                If m_bLookupDirty Then
                    CreateRange_CILookups
                End If
            End If
            m_bLookupDirty = False
        
        'V3.10
        End If
    End If
End Property

Public Sub UnloadSheetVariables()
    'Set colRangeTitles = Nothing
End Sub


    
'initialisiert die Colleciton in der Spalten|fffd|berschriften gespeichert werden
Public Sub InitSheetVariables()
    If Not ExistInCol(colRangeTitleCollections, ActiveWorkbook.Name) Then
        Set colRangeTitles = New Collection
        colRangeTitleCollections.Add colRangeTitles, "" & ActiveWorkbook.Name
    Else
        Set colRangeTitles = colRangeTitleCollections(ActiveWorkbook.Name)
    End If
    
        
'    If Not RangeTitles Is Nothing Then
'        Set colRangeTitles = RangeTitles
'    ElseIf Not wk Is Nothing Then
'        Set colRangeTitles = Application.Run("'" & wk.Name & "'!GetRangeTitles")
'    End If
End Sub





Public Sub ClearVorerfassung()
    Range("vorerfassungTitel").ClearContents
    Range("vorerfassung").ClearContents
End Sub


Sub UebernahmeVorerfassung2(wk As Workbook)


    InitSheetVariables
    
    Set colRangeTitles_Vorerfassung = Nothing
    
    Dim rVorerfassung As Range
    Set rVorerfassung = Range("vorerfassung")
    
    Dim colFilter As New Collection
    
    Dim rDefinition As Range
    Set rDefinition = Range("settingsVorerfassung")
    
    Dim profile As CVorerfassungProfile
    
    Dim colProfiles As New Collection
    Dim v As Variant
    Dim x As Long
    Dim x2 As Long
    Dim x4 As Long
    Dim i As Long
    Dim n As Long
    Dim i2 As Long
    Dim i1 As Long
    
    Dim filter As CVorerfassungFilter
    
    
    
    For i = 4 To rDefinition.Columns.Count
        Set profile = New CVorerfassungProfile
        profile.nColumn = i
        
        x2 = InStr(rDefinition.Cells(1, i), ":")
        If x2 = 0 Then
            profile.sData = rDefinition.Cells(1, i)
            profile.nEndIndicator = 1
        Else
            profile.sData = Left(rDefinition.Cells(1, i), x2 - 1)
            profile.nEndIndicator = CLng(Mid(rDefinition.Cells(1, i), x2 + 1))
        End If
        
        If Range(profile.sData).Parent.visible = True Then
            colProfiles.Add profile
            For n = 2 To rDefinition.rows.Count
                If (rDefinition.Cells(n, 2) = "Filter") Or (rDefinition.Cells(n, 2) = "Filter_NotEqual") Then
                    If rDefinition.Cells(n, i) <> "" Then
                        Set filter = New CVorerfassungFilter
                        
                        filter.sMode = rDefinition.Cells(n, 2)
                        
                        profile.colFilter.Add filter
                        filter.sField = rDefinition.Cells(n, 1)
                        v = Split(rDefinition.Cells(n, i), "|")
                        For x = LBound(v) To UBound(v)
                            filter.colFilterValues.Add CStr(v(x)), "K" & (v(x))
                            
                        Next
                    End If
                End If
                If rDefinition.Cells(n, 2) = "Split" Then
                    If rDefinition.Cells(n, i) <> "" Then
                        profile.sSplitField = rDefinition.Cells(n, 1)
                    End If
                End If
            Next
        End If
        
    Next
    
    
    
    Dim bProfileFound As Boolean
    
    
    
    Dim sCIType As String
    Dim sCINummer As String
    
    Dim colProperties As New Collection
    Dim colConnections As Collection
    
    Dim colLineProperties As Collection
    Dim prop As CProperty
    
    Dim connection As CConnection
    
    ReadProperties colProperties
    Set colConnections = ReadConnections("_")
    
    For n = 1 To rVorerfassung.rows.Count
        If rVorerfassung.Cells(n, 1) = "" Then Exit For
        
        sCIType = ""
        sCINummer = ""
        Set colLineProperties = New Collection
        
        
        bProfileFound = False
        
        Set profile = Nothing
        For i = 1 To colProfiles.Count
            Set profile = colProfiles(i)
            
            Dim bFound As Boolean
            bFound = True
            For Each filter In profile.colFilter
                Select Case filter.sMode
                Case "Filter"
                    If Not ExistInCol(filter.colFilterValues, "K" & GetCellByTitle("vorerfassung_" & filter.sField, n, "VORERFASSUNG")) Then
                        bFound = False
                        Exit For
                    End If
                Case "Filter_NotEqual"
                    If ExistInCol(filter.colFilterValues, "K" & GetCellByTitle("vorerfassung_" & filter.sField, n, "VORERFASSUNG")) Then
                        bFound = False
                        Exit For
                    End If
                End Select
            Next
            
            If bFound = True Then
                bProfileFound = True
                Exit For
            End If
        Next
        
        If bProfileFound Then
            Dim nRepeatCount As Long
            If profile.sSplitField = "" Then
                nRepeatCount = 1
            Else
                nRepeatCount = GetCellByTitle("vorerfassung_" & profile.sSplitField, n, "VORERFASSUNG")
            End If
            
            For i2 = 1 To nRepeatCount
                x = GetNextInRange(profile.sData, profile.nEndIndicator)
                For i1 = 2 To rDefinition.rows.Count
                    If rDefinition.Cells(i1, profile.nColumn) <> "" Then
                        If GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG") <> "" Then
                    
                            Select Case rDefinition.Cells(i1, 2)
                            Case "LookupByGUIDfromLine"
                                
                                v = Split(rDefinition.Cells(i1, 3), "\")
                                If UBound(v) = 4 Then
                                    x2 = GetLineNrFromCellByTitleAndKey(v(0) & "_" & v(1), GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG"), v(0) & "_" & v(4))
                                    If x2 <> -1 Then
                                        GetCellByTitle(profile.sData & "_" & rDefinition.Cells(i1, profile.nColumn), x) = GetCellFromRange(v(3), 2, GetCellByTitle(v(0) & "_" & v(2), x2), 1)
                                    End If
                                End If
                                
                                        
                                
                            Case "Field"
                                GetCellByTitle(profile.sData & "_" & rDefinition.Cells(i1, profile.nColumn), x) = GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                            Case "Field_Bestandsliste_With-Flags"
                                v = Split(rDefinition.Cells(i1, profile.nColumn), "\")
                                If UBound(v) = 1 Then
                                    If GetCellByTitle(profile.sData & "_" & v(0), x) <> "" Then
                                        x4 = GetBestandslineByGUID(GetCellByTitle(profile.sData & "_" & v(0), x))
                                        If x4 <> -1 Then
                                            GetCellByTitle("bestandsliste_" & v(1), x4) = GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                                            GetCellByTitle("bestandsliste_Flags", x4) = CLng("0" & GetCellByTitle("bestandsliste_Flags", x4)) Or CLng("0" & rDefinition.Cells(i1, 3))
                                        End If
                                    End If
                                End If
                            Case "Connection"
                                v = Split(rDefinition.Cells(i1, profile.nColumn), "\")
                                If UBound(v) >= 3 Then
                                    Set connection = New CConnection
                                    If UBound(v) > 3 Then
                                        connection.nMenge = CLng("0" & GetCellByTitle("vorerfassung_" & v(4), n, "VORERFASSUNG"))
                                    Else
                                        connection.nMenge = 1
                                    End If
                                    connection.sCIType1 = v(0)
                                    connection.sCINr1 = "" & GetCellByTitle("vorerfassung_" & v(1), n, "VORERFASSUNG")
                                    connection.sCIType2 = "" & GetCellByTitle("vorerfassung_" & v(2), n, "VORERFASSUNG")
                                    connection.sCINr2 = "" & GetCellByTitle("vorerfassung_" & v(3), n, "VORERFASSUNG")
                                    connection.sOperation = "V"
                                    connection.sVerbindungsart = rDefinition.Cells(i1, 3)
                                    
                                    If connection.sCINr1 <> "" And connection.sCINr2 <> "" Then
                                        If Not ExistInCol(colConnections, connection.GetKey) Then
                                            colConnections.Add connection, connection.GetKey
                                        End If
                                    End If
                                                                
                                    
                                   
                                
                                End If
                            Case "Field_NoSplit"
                                If i2 = 1 Then
                                    GetCellByTitle(profile.sData & "_" & rDefinition.Cells(i1, profile.nColumn), x) = GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                                End If
                            Case "Fixtext"
                                GetCellByTitle(profile.sData & "_" & rDefinition.Cells(i1, profile.nColumn), x) = rDefinition.Cells(i1, 3)
                            Case "Lookup"
                                
                                v = Split(rDefinition.Cells(i1, 3), "\")
                                Dim x3 As Long
                                If UBound(v) >= 2 Then
                                    x3 = CLng(v(2))
                                Else
                                    x3 = 2
                                End If
                                    
                                If Not ExistInRange("" & v(0), x3, "" & GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")) Then
                                    Dim sCreateRange As String
                                    If UBound(v) > 0 Then
                                        sCreateRange = v(1)
                                    Else
                                        sCreateRange = v(0)
                                    End If
                                        
                                    
                                    x2 = GetNextInRange(sCreateRange, 1)
                                    If x2 = -1 Then
                                        Addlog "Kann keinen neuen Eintrag im Bereich " & sCreateRange & " anlegen!"
                                    Else
                                        Range(sCreateRange).Cells(x2, 1) = "Neu" & x2
                                        Range(sCreateRange).Cells(x2, 2) = GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                                    End If
                                End If
                                GetCellByTitle(profile.sData & "_" & rDefinition.Cells(i1, profile.nColumn), x) = GetCellFromRange(v(0), x3, GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG"), 1)
                            
                            End Select
                        End If
                        
                        Select Case rDefinition.Cells(i1, 2)
                            Case "CI_Type"
                                sCIType = GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                            Case "CI_Nummer"
                                sCINummer = GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                            Case "Property"
                                Set prop = New CProperty
                                prop.sProperty = rDefinition.Cells(i1, profile.nColumn)
                                prop.sValue = "" & GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG")
                                colLineProperties.Add prop
                        End Select
                        
                    End If
                    If rDefinition.Cells(i1, 2) = "Result" Then
                        GetCellByTitle("vorerfassung_" & rDefinition.Cells(i1, 1), n, "VORERFASSUNG") = rDefinition.Cells(i1, 3)
                    End If
                    
                    
                Next
            Next
        End If
        
        If sCIType <> "" And sCINummer <> "" Then
            For Each prop In colLineProperties
                prop.sCINr = sCINummer
                prop.sCIType = sCIType
                prop.sOperation = "+"
                prop.sNumberFormat = "@"
                UpdateProperty colProperties, prop, True, True
            Next
        End If
                
        
    Next
    WriteProperties colProperties
    WriteConnections colConnections
    
    UnloadSheetVariables
End Sub

'Sub UebernahmeVorerfassung(wk As Workbook, importNr As String)
'    InitSheetVariables wk
'
'    Dim rBestandsliste As Range
'    Set rBestandsliste = Range("Bestandsliste")
'
'    Dim shFile As Worksheet
'    Set shFile = wk.Worksheets("" & colDynS("settingsImportFileName" & importNr))
'
'    Dim rFile As Range
'    Set rFile = shFile.UsedRange
'
'    Dim i As Long
'    Dim n As Long
'    Dim x As Long
'
'    Dim nSuccessCount As Long
'
'    nSuccessCount = 0
'
'    For i = 1 + CLng(colDynS("settingsImportStartLine" & importNr)) To rFile.Rows.Count
'        n = 1
'        Dim bImportLine As Boolean
'        bImportLine = True
'        While ExistInCol(colDynS, "settingsImportCondition" & n & importNr)
'            If GetCellByTitle("vorerfassung" & "_" & colDynS("settingsImportCondition" & n & importNr), i) <> colDynS("settingsImportConditionParameter" & n & importNr) Then
'                bImportLine = False
'            End If
'            n = n + 1
'        Wend
'
'        If bImportLine Then
'            n = 1
'            x = GetNextBestandLine(wk)
'            If x <> -1 Then
'                nSuccessCount = nSuccessCount + 1
'                While ExistInCol(colDynS, "settingsImportField" & n & importNr)
'                    If ExistInCol(colDynS, "settingsImportFieldToList" & n & importNr) Then
'
'                        If ExistInCol(colDynS, "settingsImportFieldTranslate" & n & importNr) Then
'                            Dim sTranslateRange As String
'                            sTranslateRange = colDynS("settingsImportFieldTranslate" & n & importNr)
'
'
'                            If Not ExistInRange(sTranslateRange, 2, GetCellByTitle("vorerfassung" & "_" & colDynS("settingsImportField" & n & importNr), i)) Then
'
'                                'Anlegen in von neuen Servies in "ServiceExisting" wird von dort wieder auf ServiceAll kopiert
'
'                                If sTranslateRange = "servicesAll" Then
'                                    sTranslateRange = "servicesExisting"
'                                End If
'
'                                Dim x2 As Integer
'                                x2 = GetNextInRange(sTranslateRange, 1)
'                                If x2 = -1 Then
'                                    Addlog "Kann keinen neuen Eintrag im Bereich " & sTranslateRange & " anlegen!"
'                                Else
'                                    Range(sTranslateRange).Cells(x2, 1) = "Neu" & x2
'                                    Range(sTranslateRange).Cells(x2, 2) = GetCellByTitle("vorerfassung" & "_" & colDynS("settingsImportField" & n & importNr), i)
'                                End If
'                            End If
'
'                            GetCellByTitle("bestandsliste_" & colDynS("settingsImportFieldToList" & n & importNr), x) = GetCellFromRange(sTranslateRange, 2, GetCellByTitle("vorerfassung" & "_" & colDynS("settingsImportField" & n & importNr), i), 1)
'                        Else
'                            GetCellByTitle("bestandsliste_" & colDynS("settingsImportFieldToList" & n & importNr), x) = GetCellByTitle("vorerfassung" & "_" & colDynS("settingsImportField" & n & importNr), i)
'                        End If
'                    End If
'
'                    Dim r As Range
'                    Dim s As String
'
'                    '|fffd|bernahme in den Header der Bestandsliste ingoriert, weil dort keine Felder mehr sind
'
''                    If ExistInCol(colDynS, "settingsImportFieldToHeader" & n & importNr) Then
''                        Set r = shBestandsliste.Range("bestandsliste" & colDynS("settingsImportFieldToHeader" & n & importNr))
''                        s = GetCellByTitle("vorerfassung" & "_" & colDynS("settingsImportField" & n & importNr), i)
''                        If "" & r.Cells(1, 1) = "" Then
''                            r.Cells(1, 1) = s
''                        ElseIf "" & r.Cells(1, 1) <> s Then
''                            Addlog "Feld " & colDynS("settingsImportFieldToHeader" & n & importNr) & " im Kopfbereich der CI Liste von " & r.Cells(1, 1) & " auf " & s & " ge|fffd|ndert."
''                        End If
''                        r.Cells(1, 1) = s
''
''                    End If
'
'                    n = n + 1
'                Wend
'            End If
'        End If
'    Next
'
'    Addlog nSuccessCount & " Zeile(n) |fffd|bernommen."
'
'
'End Sub



Public Function GetNextBestandLine(wk As Workbook)
    Dim i As Long
    i = 1
    
    'V4.04
    If nextFree = 0 Then
    
        While i < 100000
            If (GetCellByTitle("bestandsliste_Artikel Nr", i) = "") And (GetCellByTitle("bestandsliste_Beschreibung", i) = "") And (GetCellByTitle("bestandsliste_CI Type", i) = "") And (GetCellByTitle("bestandsliste_GUID", i) = "") Then
            
                'V4.04
                nextFree = i
                
                GetNextBestandLine = i
                Exit Function
            End If
            i = i + 1
        Wend
        GetNextBestandLine = -1
        
    'V4.04
    Else
        nextFree = nextFree + 1
        GetNextBestandLine = nextFree
        Application.StatusBar = nextFree
    End If

End Function

Public Sub Addlog(sText As String)
    If frmMsg.visible = False Then
        frmMsg.Show False
    End If
    
    frmMsg.lbMsg.AddItem Now & " " & Left(sText, 80)
    If Len(sText) > 80 Then
        Addlog Mid(sText, 80 + 1)
    End If
    frmMsg.lbMsg.Selected(frmMsg.lbMsg.ListCount - 1) = True
    
End Sub



Function GetLookupDefinitions(Optional bOnlyDirty As Boolean = False, Optional colRangesToBuild As Collection = Nothing, Optional colUsageRanges As Collection = Nothing) As Collection

    Dim i As Long
    Dim x As Long
    Dim r As Range
    Dim r2 As Range
    Dim x3 As Long
    
    Dim col As Collection
    
    Set col = New Collection
    
    Dim colDouble As New Collection
    Dim lookup As CLookupDefinition



    Set r = Range("cisettingsCILOOKUPS")
    
    Dim bIgnore As Boolean

    For i = 1 To r.rows.Count
        If r.Cells(i, 1) = "" Then Exit For
        
        bIgnore = False
        If r.Cells(i, nCellPosLookupActivationRange) <> "" Then
            If Range(r.Cells(i, nCellPosLookupActivationRange)) = "NEIN" Then
                bIgnore = True
            End If
        End If
        
        If Not bIgnore Then
        
            If bOnlyDirty And (r.Cells(i, nCellPosLookupRangeDirty) <> "") And Not colUsageRanges Is Nothing Then
                If Not ExistInCol(colUsageRanges, "" & r.Cells(i, nCellPosLookupRange)) Then
                    colUsageRanges.Add "" & r.Cells(i, nCellPosLookupRange), "" & r.Cells(i, nCellPosLookupRange)
                End If
            End If
            
                     
            If (Not bOnlyDirty) Or ((r.Cells(i, nCellPosLookupRangeDirty) <> "") And (r.Cells(i, nCellPosLookupNoUpdate) = "")) Then
                Set r2 = Range(r.Cells(i, nCellPosLookupRange))
                If Not ExistInCol(colDouble, r.Cells(i, nCellPosLookupRange)) Then
                    colDouble.Add "" & r.Cells(i, nCellPosLookupRange), "" & r.Cells(i, nCellPosLookupRange)
                    If bOnlyDirty Then r2.ClearContents
                End If
                    
                Dim v As Variant
                v = Split(r.Cells(i, nCellPosLookupCIType), "|")
            
                Set lookup = New CLookupDefinition
                
                For x3 = 0 To nLookupvaluecount - 1
                    
                    'V3.8
                    If ("" & r.Cells(i, nCellPosLookupValueStart + x3) = "") Or ExistInCol(lookup.colParam, "" & r.Cells(i, nCellPosLookupValueStart + x3)) Then
                    
                        lookup.colParam.Add "" & r.Cells(i, nCellPosLookupValueStart + x3)
                    
                    'V3.8
                    Else
                        lookup.colParam.Add "" & r.Cells(i, nCellPosLookupValueStart + x3), "" & r.Cells(i, nCellPosLookupValueStart + x3)
                    End If
                    
                    
                Next
                        
                lookup.nLine = i
                lookup.PKFilter = "" & r.Cells(i, nCellPosLookupPKFilter)
                lookup.QuellFilter = "" & r.Cells(i, nCellPosLookupQuellFilter)
                lookup.PropertyFilter = "" & r.Cells(i, nCellPosLookupPropertyFilter)
                lookup.sRange = "" & r.Cells(i, nCellPosLookupRange)
                lookup.sNamesRange = "" & r.Cells(i, nCellPosLookupNamesRange)
                'V3.8
                lookup.sCustomName = "" & r.Cells(i, nCellPosLookupCustomName)
                 
                If bOnlyDirty And Not colRangesToBuild Is Nothing Then
                    If Not ExistInCol(colRangesToBuild, "" & r.Cells(i, nCellPosLookupRange)) Then
                        colRangesToBuild.Add lookup, "" & r.Cells(i, nCellPosLookupRange)
                    End If
                End If
                 
                 
                 
                
                For x = LBound(v) To UBound(v)
                    Dim x1 As Integer
                    x1 = 1
                    Dim s1 As String
                    s1 = v(x)
                    
                    While ExistInCol(col, s1 & "_" & x1)
                        x1 = x1 + 1
                    Wend
                    
                    col.Add lookup, s1 & "_" & x1
                    
                Next
            End If
        End If
    
    Next

    Set GetLookupDefinitions = col

End Function


Sub ClearMarkCILookups()
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsCILOOKUPS")
    Dim i As Long
    For i = 1 To rDefinition.rows.Count
        rDefinition.Cells(i, nCellPosLookupRangeDirty) = ""
    Next
        
End Sub

'V3.8
'Sub MarkCILookups(nLine As Long, col As Collection)
Sub MarkCILookups(nLine As Long, sField As String, col As Collection)
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsCILOOKUPS")
    
    Dim lookup As CLookupDefinition
    Dim colDirtyRanges As New Collection
    
    Dim x1 As Long
    x1 = 1
    While ExistInCol(col, GetCellByTitle("bestandsliste_CI Type", nLine) & "_" & x1)
        Set lookup = col(GetCellByTitle("bestandsliste_CI Type", nLine) & "_" & x1)
        'If lookup.Match(GetCellByTitle("bestandsliste_PK Produktbereich", nLine) & "\" & GetCellByTitle("bestandsliste_PK Produktfunktion", nLine) & "\" & GetCellByTitle("bestandsliste_PK Produktgruppe", nLine) & "\" & GetCellByTitle("bestandsliste_PK Produktname", nLine), GetCellByTitle("bestandsliste_Properties", nLine)) Then
            
            'V3.8
            Dim bRelevantField As Boolean
            If sField = "" Then
                bRelevantField = True
            Else
                bRelevantField = False
                If lookup.sCustomName <> "" Then
                    If lookup.sCustomName = sField Then
                        bRelevantField = True
                    End If
                Else
                    If (sField = "Beschreibung") Or (sField = "Fabrikationsnummer") Then
                        bRelevantField = True
                    End If
                End If
                If ExistInCol(lookup.colParam, sField) Then
                    bRelevantField = True
                End If
                If (sField = "Properties") And lookup.HasPropertyFilter Then
                    bRelevantField = True
                End If
                If lookup.HasPKFilter Then
                    If (sField = "PK Produktbereich") Or (sField = "PK Produktfunktion") Or (sField = "PK Produktgruppe") Or (sField = "PK Produktname") Then
                        bRelevantField = True
                    End If
                End If
            End If
                        
            'V3.8
            If bRelevantField Then
                
                If Not ExistInCol(colDirtyRanges, lookup.sRange) Then
                    colDirtyRanges.Add lookup.sRange, lookup.sRange
                End If
                
                
            'V3.8
            End If
            
        'End If
        
        x1 = x1 + 1
    Wend

    For Each lookup In col
        If ExistInCol(colDirtyRanges, lookup.sRange) Then
            'mark dirty
            rDefinition.Cells(lookup.nLine, nCellPosLookupRangeDirty) = "1"
        End If
    Next
    
End Sub



Sub CreateRange_CILookups()
    If m_bMonitorLookup Then
        m_bLookupDirty = True
        Exit Sub
    End If

    Dim i As Long
    Dim x As Long
    Dim r As Range
    Dim r2 As Range
    Dim x3 As Long
    Dim x1 As Long
    Dim s1 As String
    
    Dim col As Collection
    
    Dim colRangesToBuild As New Collection
    Dim colUsageRanges As New Collection
    
    Set col = GetLookupDefinitions(True, colRangesToBuild, colUsageRanges)
    ClearMarkCILookups
        
    'Dim colDouble As New Collection
    Dim lookup As CLookupDefinition
    
    
    Set r = Range("bestandsliste")
    For i = 1 To r.rows.Count
        If GetCellByTitle("bestandsliste_CI Type", i) = "" Then Exit For
        
        x1 = 1
        While ExistInCol(col, GetCellByTitle("bestandsliste_CI Type", i) & "_" & x1)
            'Einf|fffd|gen
            Set lookup = col(GetCellByTitle("bestandsliste_CI Type", i) & "_" & x1)
            If lookup.Match(GetCellByTitle("bestandsliste_PK Produktbereich", i) & "\" & GetCellByTitle("bestandsliste_PK Produktfunktion", i) & "\" & GetCellByTitle("bestandsliste_PK Produktgruppe", i) & "\" & GetCellByTitle("bestandsliste_PK Produktname", i), GetCellByTitle("bestandsliste_Properties", i), GetCellByTitle("bestandsliste_Quelle", i)) Then
                x = GetNextInRange(lookup.sRange, 1, 2)
                If x <> -1 Then
                
                    'V3.8
                    If lookup.sCustomName = "" Then
                
                        If "" & GetCellByTitle("bestandsliste_Fabrikationsnummer", i) <> "" Then
                            s1 = GetCellByTitle("bestandsliste_Beschreibung", i) & " - " & GetCellByTitle("bestandsliste_Fabrikationsnummer", i)
                        Else
                            s1 = GetCellByTitle("bestandsliste_Beschreibung", i)
                        End If
                    
                    'V3.8
                    Else
                        s1 = GetCellByTitle("bestandsliste_" & lookup.sCustomName, i)
                    End If
                    
                    'V3.8
                    If s1 <> "" Then
                    
                        Dim sParam(1 To nLookupvaluecount) As String
                        
                        For x3 = 1 To lookup.colParam.Count
                            If lookup.colParam(x3) <> "" Then
                                sParam(x3) = "" & GetCellByTitle("bestandsliste_" & lookup.colParam(x3), i)
                            Else
                                sParam(x3) = ""
                            End If
                        Next
                        
                        
                        AddLine2Range Range(lookup.sRange), x, Array(s1, "" & GetCellByTitle("bestandsliste_GUID", i), sParam(1), sParam(2), sParam(3), sParam(4), sParam(5), sParam(6), sParam(7), sParam(8), sParam(9))
                
                    'V3.8
                    End If
                    
                End If
            End If
            x1 = x1 + 1
        Wend
    Next
    
    
    Dim n As Name
    Dim x2 As Long
    
    'Set colDouble = New Collection
    
    'Set r = Range("cisettingsCILOOKUPS")
    'For i = 1 To r.Rows.Count
    
    'Dim v As Variant
    
    'For Each lookup In col
    For Each lookup In colRangesToBuild
        'If r.Cells(i, 1) <> "" Then
            'If Not ExistInCol(colDouble, lookup.sRange) Then
            '    colDouble.Add "" & lookup.sRange, "" & lookup.sRange
        
        
                Set r2 = Range(lookup.sRange)
                'Set r2 = Range(v)
                
                'V1.982
                On Error Resume Next
                r2.SortSpecial Header:=xlYes
                On Error GoTo 0
                
                
                x1 = GetNextInRange(lookup.sRange, 1, 2) - 1
                If x1 > 0 Then
                    Set n = ActiveWorkbook.Names(lookup.sNamesRange)
                    x2 = InStr(n.RefersToLocal, ":")
                    n.RefersToLocal = Left(n.RefersToLocal, x2) & r2.Cells(x1, 1).Address
                End If
                
            'End If
            
        'End If
    Next
    
    
    'Lookup Verwendung aktualisieren
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsLookupUsage")
    
    Dim cigen As CCIGeneration
    Set cigen = New CCIGeneration
    Dim rData As Range
    Dim i1 As Long
    
    For i = 2 To rDefinition.rows.Count
        If rDefinition.Cells(i, 1) = "" Then Exit For
        
        If ExistInCol(colUsageRanges, rDefinition.Cells(i, cigen.GetCellPosLookupRange)) Then
            Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
            For i1 = 1 To rData.rows.Count
                'If rData.Cells(i1, 1) = "" Then Exit For
                If LineEmpty(rData, i1) Then Exit For
                
                'V3.3
                'cigen.Init rDefinition, i, rData, i1
                cigen.Init rDefinition, i, rDefinition.Cells(i, cigen.GetCellPosRange), i1
                
                cigen.RefreshLookupName
            Next
        End If
    Next
    
    
    
End Sub

'V1.985
'Function GetBestandslineByGUID(sGUID As String) As Long
'
'
'    Dim i As Long
'    i = 1
'    While i < 100000
'        If GetCellByTitle("bestandsliste_GUID", i) = sGUID Then
'            GetBestandslineByGUID = i
'            Exit Function
'        End If
'
'        If (GetCellByTitle("bestandsliste_Artikel Nr", i) = "") And (GetCellByTitle("bestandsliste_Beschreibung", i) = "") And (GetCellByTitle("bestandsliste_CI Type", i) = "") And (GetCellByTitle("bestandsliste_GUID", i) = "") Then
'            GetBestandslineByGUID = -1
'            Exit Function
'        End If
'
'
'        i = i + 1
'    Wend
'    GetBestandslineByGUID = -1
'
'End Function

'V1.986
Function GetBestandslineByGUID(sGUID As String) As Long
    Dim i As Long
    
    
    If colGUIDs Is Nothing Then
        Set colGUIDs = New Collection
        i = 1
        Do While i < 100000
            If (GetCellByTitle("bestandsliste_Artikel Nr", i) = "") And (GetCellByTitle("bestandsliste_Beschreibung", i) = "") And (GetCellByTitle("bestandsliste_CI Type", i) = "") And (GetCellByTitle("bestandsliste_GUID", i) = "") Then
                GetBestandslineByGUID = -1
                Exit Do
            End If
            
            colGUIDs.Add CVar(i), GetCellByTitle("bestandsliste_GUID", i)
            
            i = i + 1
        Loop
    End If
    If Not ExistInCol(colGUIDs, sGUID) Then
        GetBestandslineByGUID = -1
    Else
        GetBestandslineByGUID = colGUIDs(sGUID)
    End If

End Function


Function GetBestandslineByKey(sCIType, sKey As String) As Long
    
    
    Dim i As Long
    i = 1
    While i < 100000
        If (GetCellByTitle("bestandsliste_CIKey", i) = sKey) And (GetCellByTitle("bestandsliste_CI Type", i) = sCIType) Then
            GetBestandslineByKey = i
            Exit Function
        End If
        
        If (GetCellByTitle("bestandsliste_Artikel Nr", i) = "") And (GetCellByTitle("bestandsliste_Beschreibung", i) = "") And (GetCellByTitle("bestandsliste_CI Type", i) = "") And (GetCellByTitle("bestandsliste_GUID", i) = "") Then
            GetBestandslineByKey = -1
            Exit Function
        End If

        
        i = i + 1
    Wend
    GetBestandslineByKey = -1
    
End Function


Sub Add2RangeQueue(col As Collection, rTarget As Range)


    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsLookupUsage") 'definitionsrange
    Dim rData As Range 'erfassungsrange

    Dim i As Long
    Dim i1 As Long
    
    Dim nLine As Long 'Zeilennummer im Erfassungsrange rData
    Dim cigen As New CCIGeneration
    Dim sAddress As String
    
    
    For i = 2 To rDefinition.rows.Count
    
        'V4.11
        'If rDefinition.Cells(i, cigen.GetCellPosSheet) = SheetName(rTarget.Parent) Then
        If FoundDefinitionSheet(rDefinition, i, rTarget) Then

        
            'V4.11
            'Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
            Set rData = Range2(rDefinition.Cells(i, cigen.GetCellPosSheet) & "#" & rDefinition.Cells(i, cigen.GetCellPosRange))
            
            If RangesOverlapping(rTarget, rData) Then
                For i1 = 1 To rTarget.rows.Count
                    If RangesOverlapping(rTarget.rows(i1), rData) Then
                        nLine = rTarget.Row - rData.Row + i1
                        sAddress = SheetName(rTarget.Parent) & "!" & rData.rows(nLine).Address
                        If Not ExistInCol(col, sAddress) Then
                            col.Add rData.rows(nLine), sAddress
                        End If
                    End If
                Next
            End If
        End If
    Next
    
    
    
    Set rDefinition = Range("cisettingsCIGeneration") 'definitionsrange

    For i = 2 To rDefinition.rows.Count
    
        'V4.11
        'If rDefinition.Cells(i, cigen.GetCellPosSheet) = SheetName(rTarget.Parent) Then
        If FoundDefinitionSheet(rDefinition, i, rTarget) Then
            
            'V4.11
            'Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
            Set rData = Range2(rDefinition.Cells(i, cigen.GetCellPosSheet) & "#" & rDefinition.Cells(i, cigen.GetCellPosRange))
            
            If RangesOverlapping(rTarget, rData) Then
                For i1 = 1 To rTarget.rows.Count
                    If RangesOverlapping(rTarget.rows(i1), rData) Then
                        nLine = rTarget.Row - rData.Row + i1
                        sAddress = SheetName(rTarget.Parent) & "!" & rData.rows(nLine).Address
                        If Not ExistInCol(col, sAddress) Then
                            col.Add rData.rows(nLine), sAddress
                        End If
                    End If
                Next
            End If
        End If
    Next



End Sub

'Aktualisiert die Verarbeitung von CIs und Lookups nach einer |fffd|nderung
Public Sub UpdateLookups_And_CIs(rTarget As Range)
    
    
    If bStopAutoMacros Then Exit Sub
    Static bRefreshMode As Boolean
    
    
    
    Static colPreventLooping As New Collection
    
    If RefreshMode(rTarget) Then bRefreshMode = True
    
    Dim bFirstRun As Boolean
    bFirstRun = (colPreventLooping.Count = 0)
    
    'V4.04
    If bFirstRun Then
        nextFree = 0
    End If
    
    Add2RangeQueue colPreventLooping, rTarget
    
    If Not bFirstRun Then Exit Sub
    
    
        
    'Static bReenter As Boolean
    
    
    'If bReenter Then Exit Sub
    'bReenter = True
    
    
    MonitorLookup = True
    
    Dim currentTarget As Range
    Dim i As Long
    i = 1
    While i <= colPreventLooping.Count
        
        While i <= colPreventLooping.Count
            Set currentTarget = colPreventLooping(i)
            If IsRangeValid(currentTarget) Then
                UpdateLookups currentTarget
                CIGeneration currentTarget
            End If
            i = i + 1
        Wend
        
        MonitorLookup = False
        MonitorLookup = True
        
    Wend
    
    MonitorLookup = False
    
    'bReenter = False
    Set colPreventLooping = New Collection
    
    
    
    If bRefreshMode Then
        bRefreshMode = False
        ToggleMode
        
    End If
    
    'V3.1
    If Not colProps Is Nothing Then
        WriteProperties colProps
        Set colProps = Nothing
    End If
    
End Sub


Private Sub UpdateLookups(rTarget As Range)
    
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsLookupUsage") 'definitionsrange
    Dim rData As Range 'erfassungsrange

    Dim i As Long
    Dim i1 As Long
    
   ' Dim x1 As Long
    Dim sGUID As String
    Dim sKey As String
    Dim nLine As Long 'Zeilennummer im Erfassungsrange rData
    Dim cigen As New CCIGeneration

    For i = 2 To rDefinition.rows.Count
    
        'V4.11
        'If rDefinition.Cells(i, cigen.GetCellPosSheet) = SheetName(rTarget.Parent) Then
        If FoundDefinitionSheet(rDefinition, i, rTarget) Then
        
            'V2
            'Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
            Set rData = Range2(rDefinition.Cells(i, cigen.GetCellPosSheet) & "#" & rDefinition.Cells(i, cigen.GetCellPosRange))
            
            If RangesOverlapping(rTarget, rData) Then
                For i1 = 1 To rTarget.rows.Count
                    
                    If RangesOverlapping(rTarget.rows(i1), rData) Then
                        'Modifzierte Zeile entdeckt
                        
                        nLine = rTarget.Row - rData.Row + i1
                        
                        'V3.3
                        'cigen.Init rDefinition, i, rData, nLine
                        cigen.Init rDefinition, i, rDefinition.Cells(i, cigen.GetCellPosRange), nLine
                        
                        cigen.UpdateLookup
                    
                    End If
                Next
            End If
        End If
    Next
End Sub

Private Function RefreshMode(rTarget As Range) As Boolean
    Dim rDefinition As Range
    Set rDefinition = Range("settingsMonitorMode")
    Dim rData As Range
    Dim i As Long
    
    Dim colLookups As New Collection
    
    For i = 1 To rDefinition.rows.Count
        If rDefinition.Cells(i, 1) = "" Then Exit Function
        If rDefinition.Cells(i, 1) = SheetName(rTarget.Parent) Then
        
            Set rData = Range(rDefinition.Cells(i, 2))
            If RangesOverlapping(rTarget, rData) Then
                
                'Ev. auch Lookups erneuern?
                If rDefinition.Cells(i, 3) <> "" Then
                    On Error Resume Next
                    colLookups.Add "" & rDefinition.Cells(i, 3), "" & rDefinition.Cells(i, 3)
                    On Error GoTo 0
                End If
                
            
               RefreshMode = True
            End If
        End If
    Next
    
    'F|fffd|r alle identifzierten Lookup Quellen die CI-Type suchen
    If colLookups.Count <> 0 Then
        Set rDefinition = Range("cisettingsCILOOKUPS")

        Dim colCITypes As New Collection
        Dim v As Variant
        For i = 1 To rDefinition.rows.Count
            If rDefinition.Cells(i, 1) = "" Then Exit For
            If ExistInCol(colLookups, rDefinition.Cells(i, nCellPosLookupQuellFilter)) Then
                On Error Resume Next
                colCITypes.Add "" & rDefinition.Cells(i, nCellPosLookupCIType), "" & rDefinition.Cells(i, nCellPosLookupCIType)
                On Error GoTo 0
            End If
        Next
        If colCITypes.Count <> 0 Then
            For i = 1 To rDefinition.rows.Count
                If rDefinition.Cells(i, 1) = "" Then Exit For
                If ExistInCol(colCITypes, rDefinition.Cells(i, nCellPosLookupCIType)) Then
                    rDefinition.Cells(i, nCellPosLookupRangeDirty) = 1
                End If
            Next
        End If
        CreateRange_CILookups
    End If
End Function


Private Sub CIGeneration(rTarget As Range)

    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsCIGeneration") 'definitionsrange
    Dim rData As Range 'erfassungsrange
    
    
    Dim i As Long
    Dim i1 As Long
    
    Dim x1 As Long
    Dim sGUID As String
    Dim sKey As String
    Dim nLine As Long 'Zeilennummer im Erfassungsrange rData
    
    Dim cigen As New CCIGeneration
    
    
    
    For i = 2 To rDefinition.rows.Count
    
        'V4.11
        'If rDefinition.Cells(i, cigen.GetCellPosSheet) = SheetName(rTarget.Parent) Then
        If FoundDefinitionSheet(rDefinition, i, rTarget) Then
        
            'V4.11
            'Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
            Set rData = Range2(rDefinition.Cells(i, cigen.GetCellPosSheet) & "#" & rDefinition.Cells(i, cigen.GetCellPosRange))
            
            If RangesOverlapping(rTarget, rData) Then
                For i1 = 1 To rTarget.rows.Count
                    
                    If RangesOverlapping(rTarget.rows(i1), rData) Then
                        'Modifzierte Zeile entdeckt
                        
                        nLine = rTarget.Row - rData.Row + i1
                        
                        'V3.3
                        'cigen.Init rDefinition, i, rData, nLine
                        cigen.Init rDefinition, i, rDefinition.Cells(i, cigen.GetCellPosRange), nLine
                        
                        'V4.11
                        If Not cigen.IgnoreLine Then
                        
                            If cigen.IsKeyComplete Then
                                sKey = cigen.GetKey
                            Else
                                sKey = ""
                            End If
                            sGUID = cigen.GetGUID
                            
                            'Key=""
                            If sKey = "" Then
                            
                                'GUID<>""
                                If sGUID = "" Then
                                    'Leerzeile, nix tun
                                
                                Else
                                    'Definition wurde gel|fffd|scht -> Ref-Count vermindern
                                    cigen.RemoveCI
                                
                                End If
                            Else
                                'GUID<>""
                                If sGUID <> "" Then
                                    'Umbennen, Eigenschaften aktualisieren oder was?
                                    If Not (cigen.UpdateCI) Then
                                        
                                        'V3.1
                                        'wenn Flag=4 gesetzt dann m|fffd|ssen mit dem anlegen auch die create properties angelegt werden
                                        Dim x2 As Long
                                        x2 = GetBestandslineByGUID(cigen.GetGUID)
                                        If x2 <> -1 Then
                                            If (GetCellByTitle("bestandsliste_Flags", x2).Value And cCIFlag_ForceProperties) = cCIFlag_ForceProperties Then
                                                InitCreationProperties GetCellByTitle("bestandsliste_CI Type", x2), GetCellByTitle("bestandsliste_CI Nummer", x2), colProps
                                            End If
                                        End If
                                    
                                    End If
                                Else
                                    cigen.CreateCI
                                    
                                    'V3.1
                                    'wenn Flag=4 gesetzt dann m|fffd|ssen mit dem anlegen auch die create properties angelegt werden
                                    'Dim x2 As Long
                                    x2 = GetBestandslineByGUID(cigen.GetGUID)
                                    If x2 <> -1 Then
                                        If (GetCellByTitle("bestandsliste_Flags", x2).Value And cCIFlag_ForceProperties) = cCIFlag_ForceProperties Then
                                            InitCreationProperties GetCellByTitle("bestandsliste_CI Type", x2), GetCellByTitle("bestandsliste_CI Nummer", x2), colProps
                                        End If
                                    End If
                                    
                                    
                                    
                                End If
                            End If
                        
                        'V4.11
                        End If
                        
                    End If
                Next
            End If
        End If
    Next
    

End Sub




'V3.2 gibt die anzahl der Worte in einer Zeile zur|fffd|ck. Trennzeichen sind "," und " "
Function GetNoOfWordsInText(sText As String) As Long
    GetNoOfWordsInText = UBound(Split(sText, ", ")) + 1
End Function



Sub DoExport(wk As Workbook)

    InitSheetVariables

    Dim ciexport As CCIExport
    Set ciexport = New CCIExport
    
    Set ciexport.wk = Application.Workbooks.Add
    wk.Activate
    
    ciexport.sAnlagenProjekt = Range("bestandslisteAnlagenprojekt")
    
    
    
    Dim shexport As Worksheet
    
    Set shexport = ciexport.wk.Worksheets(1)
    
    Dim colExports As New Collection
    colExports.Add ciexport, "Default"
    
    
    Dim shNewCIsListe As Range
    Set shNewCIsListe = Range("newCIsListe")
    shNewCIsListe.ClearContents
    
    Dim i As Long, n As Long, nn As Long
    Dim nEmptyCount As Integer
    nEmptyCount = 0
    
    'V4.1
    Dim CIListElement As CIListElement
    
    Dim ci
    
    i = 1
    
    'V4.1
    'nn = 0
    
    
    While (nEmptyCount < 1)
        'V33
        'If rBestandsliste.Cells(i, 1) <> 0 And rBestandsliste.Cells(i, 1) <> "" Then 'And rBestandsliste.Cells(i, 2) <> "" Then
        'V423
        If GetCellByTitle("bestandsliste_Menge", i) <> 0 Then
            'Zeile nicht leer
            nEmptyCount = 0
            
            'V3.2 'in dieser version wurde das erzeugen von no-bulk CIs mit Menge >1 unterst|fffd|tzt, das erzeugen nicht generierter CIs wurde dabei herausgenommen
            Dim bWorkTodo As Boolean
            Dim nWorkItems As Long
            
            bWorkTodo = False
            If ((CLng(GetCellByTitle("bestandsliste_Flags", i)) And cCIFlag_PreventCreate) = 0) And (CLng(GetCellByTitle("bestandsliste_Ref-Count", i)) > 0) Then
                If ((CLng(GetCellByTitle("bestandsliste_Flags", i)) And cCIFlag_NoBulk) <> 0) Then
                    'No Bulk gesetzt
                    nWorkItems = CLng(GetCellByTitle("bestandsliste_Menge", i)) - GetNoOfWordsInText(GetCellByTitle("bestandsliste_CI Nummer", i))
                    If nWorkItems > 0 Then
                        bWorkTodo = True
                    End If
                ElseIf (GetCellByTitle("bestandsliste_CI Nummer", i) = "") Then
                    bWorkTodo = True
                    nWorkItems = 1
                End If
            End If
            
            'V3.2
            'CI mit bestehender CI Nummer auslassen, ansonsten manuelle CIs und automatische referenzierte mitnehmen, ausserdem CIs mit Flag=2 ignorieren
            'If ((CLng(GetCellByTitle("bestandsliste_Flags", i)) And cCIFlag_PreventCreate) = 0) And (GetCellByTitle("bestandsliste_CI Nummer", i) = "") And ((GetCellByTitle("bestandsliste_Quelle", i) = "") Or (CLng(GetCellByTitle("bestandsliste_Ref-Count", i)) > 0)) Then
            If bWorkTodo Then
                If GetCellByTitle("bestandsliste_ProjektNr", i) = "" Then
                    Set ciexport = colExports("Default")
                Else
                    If ExistInCol(colExports, "K" & GetCellByTitle("bestandsliste_ProjektNr", i)) Then
                        Set ciexport = colExports("K" & GetCellByTitle("bestandsliste_ProjektNr", i))
                    Else
                        Set ciexport = New CCIExport
                        colExports.Add ciexport, "K" & GetCellByTitle("bestandsliste_ProjektNr", i)
                        Set ciexport.wk = Application.Workbooks.Add
                        wk.Activate
                        ciexport.sAnlagenProjekt = GetCellByTitle("bestandsliste_ProjektNr", i)
                    End If
                End If
                
                Set shexport = ciexport.wk.Worksheets(1)
                
                'V3.2
                Dim i1 As Long
                For i1 = 1 To nWorkItems
                
                
                    ciexport.n = ciexport.n + 1
                    n = ciexport.n
                    'V4.1
                    'nn = nn + 1
                    
                    
                    shexport.Cells(n, 1) = ciexport.sAnlagenProjekt
                    shexport.Cells(n, 2) = "Erweiterung"
                    shexport.Cells(n, 3) = "Artikel"
                    shexport.Cells(n, 4) = GetCellByTitle("bestandsliste_Artikel Nr", i)
                    shexport.Cells(n, 5) = GetCellByTitle("bestandsliste_Beschreibung", i)
                    'V1.985
                    If Len(shexport.Cells(n, 5).Value) > 50 Then
                        shexport.Cells(n, 5) = Left(shexport.Cells(n, 5), 50)
                    End If
                    shexport.Cells(n, 6) = GetCellByTitle("bestandsliste_Erweiterte Beschreibung", i)
                    shexport.Cells(n, 7) = GetCellByTitle("bestandsliste_Menge", i)
                    shexport.Cells(n, 8) = 0
                    shexport.Cells(n, 9) = GetCellByTitle("bestandsliste_Leistungs- positionscode", i)
                    shexport.Cells(n, 10) = GetCellByTitle("bestandsliste_Leistungs- umfangcode", i)
                    shexport.Cells(n, 11) = GetCellByTitle("bestandsliste_RZ", i)
                    shexport.Cells(n, 12) = GetCellByTitle("bestandsliste_SZ", i)
                    shexport.Cells(n, 13) = GetCellByTitle("bestandsliste_Fabrikationsnummer", i)
                    shexport.Cells(n, 16) = GetCellByTitle("bestandsliste_Inbetriebnahme Datum", i)
                    shexport.Cells(n, 16).NumberFormat = GetCellByTitle("bestandsliste_Inbetriebnahme Datum", i).NumberFormat
                    'V4.03
                    'shexport.Cells(n, 18) = Format(Now, "dd.mm.yyyy")
                    'shexport.Cells(n, 18).NumberFormat = GetCellByTitle("bestandsliste_Inbetriebnahme Datum", i).NumberFormat
                    'V4.03
                    If "" & GetCellByTitle("bestandsliste_Inbetriebnahme Datum", i) <> "" Then
                        shexport.Cells(n, 18) = GetCellByTitle("bestandsliste_Inbetriebnahme Datum", i)
                        shexport.Cells(n, 18).NumberFormat = GetCellByTitle("bestandsliste_Inbetriebnahme Datum", i).NumberFormat
                    Else
                        shexport.Cells(n, 18) = Range("projektdatenEreignisdatum")
                        shexport.Cells(n, 18).NumberFormat = "m/d/yyyy"
                    End If
                    
                    
                    
                    shexport.Cells(n, 23) = GetCellByTitle("bestandsliste_HZ", i)
                    shexport.Cells(n, 24) = GetCellByTitle("bestandsliste_Garantie bis", i)
                    shexport.Cells(n, 24).NumberFormat = GetCellByTitle("bestandsliste_Garantie bis", i).NumberFormat
                    shexport.Cells(n, 30) = ""
                    shexport.Cells(n, 31) = ""
                    shexport.Cells(n, 32) = ""
                    
                    
                    shexport.Cells(n, 36) = Range("bestandslisteGeschaeftsfalltype")
                                       
                    
                    shexport.Cells(n, 37) = Range("bestandslisteGeschaeftsfallNummer")
                    
                    'V4.12
                    'shexport.Cells(n, 42) = GetCellByTitle("bestandsliste_CI Type", i)
                    If InStr(GetCellByTitle("bestandsliste_CI Type", i), "|") Then
                        shexport.Cells(n, 42) = Left(GetCellByTitle("bestandsliste_CI Type", i), InStr(GetCellByTitle("bestandsliste_CI Type", i), "|") - 1)
                    Else
                        shexport.Cells(n, 42) = GetCellByTitle("bestandsliste_CI Type", i)
                    End If
                        
                    
                    
                    shexport.Cells(n, 43) = GetCellByTitle("bestandsliste_PK Produktbereich", i)
                    shexport.Cells(n, 44) = GetCellByTitle("bestandsliste_PK Produktfunktion", i)
                    shexport.Cells(n, 45) = GetCellByTitle("bestandsliste_PK Produktgruppe", i)
                    shexport.Cells(n, 46) = GetCellByTitle("bestandsliste_PK Produktname", i)
                    shexport.Cells(n, 47) = ""
                    shexport.Cells(n, 33) = GetCellByTitle("bestandsliste_UC", i)
                    
                    
                    'V4.5
                    Dim nVersion As Long
                    nVersion = 2
                    On Error Resume Next
                    nVersion = CLng(Mid(Range("projektdatenVertragsversion"), 2, 2))
                    On Error GoTo 0
                    Select Case nVersion
                    Case 2
                    Case 3
                    
                        'V4.13
                        Dim bSLMinVorerfassung As Boolean
                        Dim sSLMGUID As String
                        bSLMinVorerfassung = ((GetCellByTitle("bestandsliste_Flags", i) And cCIFlag_SLMinVorerfassung) = cCIFlag_SLMinVorerfassung)
                        
                        'V4.13
                        If bSLMinVorerfassung Then
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI1", i)
                            shexport.Cells(n, 32) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI2", i)
                            shexport.Cells(n, 47) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI3", i)
                            shexport.Cells(n, 48) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI4", i)
                            shexport.Cells(n, 49) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI5", i)
                            shexport.Cells(n, 50) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI6", i)
                            shexport.Cells(n, 51) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI7", i)
                            shexport.Cells(n, 52) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                            sSLMGUID = GetCellByTitle("bestandsliste_SLM-CI8", i)
                            shexport.Cells(n, 53) = IIf(sSLMGUID <> "", GetCellByTitle("bestandsliste_CI Nummer", GetBestandslineByGUID(sSLMGUID)), "")
                        Else
                        
                            shexport.Cells(n, 47) = "" 'SLM Felder
                            shexport.Cells(n, 48) = ""
                            shexport.Cells(n, 49) = ""
                            shexport.Cells(n, 50) = ""
                            shexport.Cells(n, 51) = ""
                            shexport.Cells(n, 52) = ""
                            shexport.Cells(n, 53) = ""
                            
                        'V4.13
                        End If
                        
                        'Weitere SLM Felder
                        shexport.Cells(n, 54) = ""
                        shexport.Cells(n, 55) = ""
                        shexport.Cells(n, 56) = ""
                        shexport.Cells(n, 57) = ""
                        shexport.Cells(n, 58) = ""
                        shexport.Cells(n, 59) = ""
                        shexport.Cells(n, 60) = ""
                        shexport.Cells(n, 61) = "" 'Buchungsdatum
                        shexport.Cells(n, 62) = GetCellByTitle("bestandsliste_Abnahmedatum", i) 'Abnahmedatum
                        shexport.Cells(n, 63) = "" 'Beschreibung PA
                        
                        'V4.13
                        'shexport.Cells(n, 64) = "" 'Kommentar Vertragsverwaltung
                        'V4.14
                        'shexport.Cells(n, 64) = GetCellByTitle("bestandsliste_Kommentar-VVW", i) 'Kommentar Vertragsverwaltung
                        shexport.Cells(n, 64) = ""
                        If ExistCellByTitle("bestandsliste_Kommentar-VVW") Then shexport.Cells(n, 64) = GetCellByTitle("bestandsliste_Kommentar-VVW", i) 'Kommentar Vertragsverwaltung
                        
                        
                    Case Else
                        Addlog "Vertragsversion wird nicht unterst|fffd|tzt!"
                    End Select
            
                    'V4.1
                    'shNewCIsListe.Cells(nn, 1) = GetCellByTitle("bestandsliste_CI Type", i)
                    'shNewCIsListe.Cells(nn, 2) = GetCellByTitle("bestandsliste_Beschreibung", i)
                    'shNewCIsListe.Cells(nn, 4) = GetCellByTitle("bestandsliste_GUID", i)
            
                    'V4.1
                    Set CIListElement = New CIListElement
                    CIListElement.sCIBezeichnung = GetCellByTitle("bestandsliste_Beschreibung", i)
                    CIListElement.sCIType = GetCellByTitle("bestandsliste_CI Type", i)
                    CIListElement.sGUID = GetCellByTitle("bestandsliste_GUID", i)
                    ciexport.colNewCIsListe.Add CIListElement
                    
                'V3.1
                Next
            
            End If
            
        Else
            nEmptyCount = nEmptyCount + 1
        
        End If
        
        i = i + 1
    Wend
    
    
    'V4.1
    nn = 0
    
    For Each ciexport In colExports
        n = ciexport.n
        
        If n <> 0 Then
            'shExport.Activate
            
            
            Dim sPath As String
            sPath = wk.Path & "\cmdb_" & ciexport.sAnlagenProjekt & "_" & Application.UserName & "_" & Format(Now, "yyyymmddhhMMss") & ".txt"
            
            ciexport.wk.SaveAs Filename:=sPath, FileFormat:= _
            xlCSVMSDOS, CreateBackup:=False, Local:=True
    
            ciexport.wk.Close False
            
            Addlog "Daten wurden nach " & sPath & " exportiert"
            'shBestandsliste.Activate
            'V3.9
            CopyString sPath
            
            'V4.1
            For Each CIListElement In ciexport.colNewCIsListe
                nn = nn + 1
                shNewCIsListe.Cells(nn, 1) = CIListElement.sCIType
                shNewCIsListe.Cells(nn, 2) = CIListElement.sCIBezeichnung
                shNewCIsListe.Cells(nn, 4) = CIListElement.sGUID
                shNewCIsListe.Cells(nn, 5) = ciexport.sAnlagenProjekt
            Next
            
            
        Else
            Addlog "Keine Zeilen gefunden!"
            ciexport.wk.Close False
        End If
    Next
    
    UnloadSheetVariables
End Sub


'legt f|fffd|r ein bereits existierendes CI die Properties an, welche normalerweise am anlegen erzeugt werden, f|fffd|r das CI-Flag 4 notwendig
Sub InitCreationProperties(sCIType As String, sCINummer As String, ByRef col As Collection)
    'col ist die Liste der Properties
    
    If col Is Nothing Then
        Set col = New Collection
        ReadProperties col
    End If
    
    Dim rDefinition As Range
    Set rDefinition = Range("settingsAttributes")
    
    Dim prop As CProperty

    Dim n As Long

    For n = 1 To rDefinition.rows.Count
        If rDefinition.Cells(n, 3) = 3 Then
            Set prop = New CProperty
            
            prop.sCIType = sCIType
            prop.sCINr = sCINummer
            prop.sProperty = rDefinition.Cells(n, 2)
            prop.sValue = ""
                
            prop.sOperation = "+"
            prop.sNumberFormat = rDefinition.Cells(n, 4)
            UpdateProperty col, prop, True, True
        
        End If
    Next


End Sub

'V4.11
Sub WriteBackCINo(nLine As Long, sCINo As String)
    Dim rDef2 As Range
    Set rDef2 = Range("cisettingsCIGeneration")
    Dim nDef As Long
    nDef = GetCellByTitle("bestandsliste_DefNr", nLine)
    
    Dim cigen As New CCIGeneration
    
    Dim i As Long
    i = GetLineNrFromCellByTitleAndKey(rDef2.Cells(nDef, cigen.GetCellPosRange) & "_" & rDef2.Cells(nDef, cigen.GetCellPosGUID), GetCellByTitle("bestandsliste_GUID", nLine), "", Range2(rDef2.Cells(nDef, cigen.GetCellPosSheet) & "#" & rDef2.Cells(nDef, cigen.GetCellPosRange)))
    'i = GetLineNrFromCellByTitleAndKey("", GetCellByTitle("bestandsliste_GUID", nLine), "", Nothing)
    If i <> -1 Then
        
        GetCellByTitle(rDef2.Cells(nDef, cigen.GetCellPosRange) & "_" & Split(Split(rDef2.Cells(nDef, 18), "[")(1), "]")(0), i) = sCINo
    End If

End Sub

'V4.12
Function GetCIType(sCIPrefix As String)
    Select Case Left(sCIPrefix, 2)
        Case "01": GetCIType = "STANDORT"
        Case "02": GetCIType = "EQUIPMENT"
        Case "03": GetCIType = "TK-SYSTEM"
        Case "04": GetCIType = "TK-ENDGER|fffd|T"
        Case "05": GetCIType = "BAUGRUPPE"
        Case "06": GetCIType = "PROVIDERANBINDUNG"
        Case "07": GetCIType = "FERNWARTUNG"
        Case "08": GetCIType = "OS"
        Case "09": GetCIType = "ZUSATZEINRICHTUNG"
        
        'V4.17
        'Case "10": GetCIType = "APPLIKATIONS-/HW-ANB"
        Case "10": GetCIType = "APPLIKATIONS-/HW-AN"
        
        Case "11": GetCIType = "VOICE-GATEWAY"
        Case "12": GetCIType = "GLEICHRICHTER"
        Case "13": GetCIType = "RECHNER"
        Case "14": GetCIType = "FESTPLATTE"
        Case "15": GetCIType = "PC-STECKKARTE"
        Case "16": GetCIType = "PORT"
        Case "17": GetCIType = "RAM-MODUL"
        Case "18": GetCIType = "DRUCKER/SCANNER"
        Case "19": GetCIType = "LIBRARY"
        Case "20": GetCIType = "BANDLAUFWERK"
        Case "21": GetCIType = "STORAGE"
        Case "22": GetCIType = "BLADE-CENTER"
        Case "23": GetCIType = "ERWEITERUNGS-CHASSIS"
        Case "24": GetCIType = "KVM"
        Case "25": GetCIType = "SCHRANK"
        Case "26": GetCIType = "PDU"
        Case "27": GetCIType = "USV"
        Case "28": GetCIType = "MONITOR"
        Case "29": GetCIType = "VERBRAUCHSMATERIAL"
        Case "30": GetCIType = "APPLIKATION"
        Case "31": GetCIType = "PATCH"
        Case "32": GetCIType = "LIZENZ"
        Case "33": GetCIType = "NETZWERKKONFIG"
        Case "34": GetCIType = "LAUFWERK/LUN"
        Case "35": GetCIType = "RAID-ARRAY"
        Case "36": GetCIType = "CLUSTER"
        Case "37": GetCIType = "SERVICE"
        Case "38": GetCIType = "APPLIANCE"
        Case "39": GetCIType = "NETZWERKKOMPONENTE"
        Case "40": GetCIType = "MODUL"
        Case "41": GetCIType = "MEDIA-INTERFACE"
        Case "42": GetCIType = "LOGIN"
        'V4.15
        'Case "43": GetCIType = "MOBILES ENDGER|fffd|T"
        Case "43": GetCIType = "MOBILES-ENDGER|fffd|T"
        Case "44": GetCIType = "BILDVERARBEITUNG"
        Case "45": GetCIType = "IDENTIFIKATION"
        Case "46": GetCIType = "ERFASSUNGSEINHEIT"
        Case "47": GetCIType = "KONTROLLEINHEIT"
        Case "48": GetCIType = "STELLGLIED"
        Case "49": GetCIType = "SIGNALGEBER"
        Case "50": GetCIType = "SCHUTZEINRICHTUNG"
        Case "51": GetCIType = "KONVERTER"
        Case "52": GetCIType = "LEUCHTE"
        Case "53": GetCIType = "KABEL / LEITUNG"
        Case "54": GetCIType = "KLIMAKOMPONENTE"
        Case "55": GetCIType = "NEA"
        Case "56": GetCIType = "ZELLE"
        Case "57": GetCIType = "PAS. NETZWERKKOMP."
        Case "58": GetCIType = "ANFORDERUNG"
        Case "59": GetCIType = "HISTORISCHE SERVICE DATEN"
        Case "60": GetCIType = "ZERTIFIKAT"
        Case "61": GetCIType = "UC ARTIKEL"
    
    End Select

End Function





'V4.12
Function CheckCIType(sCIType As String, sCINumber As String) As Boolean
    Dim sTargetType As String
    sTargetType = GetCIType(sCINumber)
    If sCIType = sTargetType Then
        CheckCIType = True
        Exit Function
    
    'V4.16
    ElseIf sCIType = "*" Then
        CheckCIType = True
        Exit Function
        
    Else
        Dim v As Variant
        v = Split(sCIType, "|")
        Dim i As Integer
        For i = LBound(v) To UBound(v)
            If v(i) = sTargetType Then
                CheckCIType = True
                Exit Function
            End If
        Next i
    End If
    CheckCIType = False

End Function


Sub RefreshCINumbers(wk As Workbook)
    
    InitSheetVariables
    
    bAutomaticStopAutoMacros = True
    
    'V4.12
    Dim nIgnored As Long
    
    Dim rNewCIsListe As Range
    Set rNewCIsListe = Range("newCIsListe")
    Dim x As Long
    
    Dim col As Collection
    Set col = New Collection
    ReadProperties col
    
    'V4.1
    If MinVersionCheck(4, 1) Then
        Dim colConn As Collection
        Set colConn = ReadConnections("_")
        Dim conn As CConnection
    End If
    
    
    Dim rDefinition As Range
    Set rDefinition = Range("settingsAttributes")
    Dim n As Long
    
    Dim prop As CProperty
    
    Dim i As Long
    For i = 1 To rNewCIsListe.rows.Count
        If rNewCIsListe.Cells(i, 1) = "" Then Exit For
        
        If rNewCIsListe.Cells(i, 3) <> "" Then
            'CI Nummer eingef|fffd|gt
            x = GetBestandslineByGUID(rNewCIsListe.Cells(i, 4))
            
            'V3.2
            Dim sCINumber As String
            sCINumber = "" & rNewCIsListe.Cells(i, 3)
            If ((GetCellByTitle("bestandsliste_Flags", x) And cCIFlag_NoBulk) <> 0) Then
                If GetCellByTitle("bestandsliste_CI Nummer", x) = "" Then
                
                    'V4.12
                    If CheckCIType(GetCellByTitle("bestandsliste_CI Type", x), sCINumber) Then
                        GetCellByTitle("bestandsliste_CI Type", x) = GetCIType(sCINumber)
                    
                        GetCellByTitle("bestandsliste_CI Nummer", x) = sCINumber
                    
                    'V4.12
                    Else
                        nIgnored = nIgnored + 1
                    End If
                        
                Else
                    GetCellByTitle("bestandsliste_CI Nummer", x) = GetCellByTitle("bestandsliste_CI Nummer", x) & ", " & sCINumber
                End If
            Else
                
                'V4.12
                If CheckCIType(GetCellByTitle("bestandsliste_CI Type", x), sCINumber) Then
                    GetCellByTitle("bestandsliste_CI Type", x) = GetCIType(sCINumber)
                
                    GetCellByTitle("bestandsliste_CI Nummer", x) = sCINumber
                
                'V4.12
                Else
                    nIgnored = nIgnored + 1
                End If
            
            End If
            
            
            'V4.11
            If ((GetCellByTitle("bestandsliste_Flags", x) And cCIFlag_WriteBackCINo) <> 0) Then
                WriteBackCINo x, sCINumber
            End If
            
            
            'V4.1
            If MinVersionCheck(4, 1) Then
                Dim sProjekt As String, sDebitor As String
                sProjekt = GetCellByTitle("bestandsliste_ProjektNr", x)
                If sProjekt <> "" Then
                    sDebitor = GetCellFromRange("projektdatenWeitereProjekte", 2, sProjekt, 3)
                Else
                    sProjekt = Range("bestandslisteAnlagenprojekt")
                    sDebitor = ""
                End If
                
                'V4.1
                If sDebitor = "" Then
                        
                        'V4.9
                        If Not ExistInCol(ActiveWorkbook.Names, "projektdatenDebitor") Then
                            sDebitor = "<Default>"
                        'V4.9
                        'If Range("projektdatenDebitor") <> "" Then
                        ElseIf Range("projektdatenDebitor") <> "" Then
                        
                            sDebitor = Range("projektdatenDebitor")
                        Else
                            sDebitor = "<Default>"
                        End If
                    Else
                    
                End If
                
                'V4.10
                If ExistInCol(ActiveWorkbook.Names, "projektdatenDebitor") Then
                
                    'V4.1
                    Set conn = New CConnection
                    conn.nMenge = 1
                    conn.sVerbindungsart = "Kontierung"
                    conn.sCIType1 = "DEBITOR"
                    conn.sCINr1 = sDebitor
                    conn.sCIType2 = GetCellByTitle("bestandsliste_CI Type", x)
                    conn.sCINr2 = sCINumber
                    conn.dEreignisdatum = Fix(Now)
                    If Not ExistInCol(colConn, conn.GetKey) Then
                        colConn.Add conn, "" & conn.GetKey
                    End If
                    
                    'V4.1
                    Set conn = New CConnection
                    conn.nMenge = 1
                    conn.sVerbindungsart = "Kontierung"
                    conn.sCIType1 = "PROJEKT"
                    conn.sCINr1 = sProjekt
                    conn.sCIType2 = GetCellByTitle("bestandsliste_CI Type", x)
                    conn.sCINr2 = sCINumber
                    conn.dEreignisdatum = Fix(Now)
                    If Not ExistInCol(colConn, conn.GetKey) Then
                        colConn.Add conn, conn.GetKey
                    End If
                
                'V4.10
                End If
                
            End If
            
            
            'GetCellByTitle("bestandsliste_CI Nummer", x) = "" & rNewCIsListe.Cells(i, 3)
            
            
            For n = 1 To rDefinition.rows.Count
                If rDefinition.Cells(n, 3) = 3 Then
                    Set prop = New CProperty
                    
                    If GetCellByTitle("bestandsliste_" & rDefinition.Cells(n, 1), x) <> "" Then
                        Set prop = New CProperty
                        prop.sCIType = GetCellByTitle("bestandsliste_CI Type", x)
                        
                        'V3.2
                        'prop.sCINr = GetCellByTitle("bestandsliste_CI Nummer", x)
                        prop.sCINr = sCINumber
                        
                        prop.sProperty = rDefinition.Cells(n, 2)
                        
                        'V1.985
                        If rDefinition.Cells(n, 5) <> "" Then
                            prop.sValue = Left(GetCellByTitle("bestandsliste_" & rDefinition.Cells(n, 1), x), CLng(rDefinition.Cells(n, 5)))
                        Else
                            
                            prop.sValue = GetCellByTitle("bestandsliste_" & rDefinition.Cells(n, 1), x)
                        
                        'V1.985
                        End If
                        
                        
                        prop.sOperation = "+"
                        prop.sNumberFormat = rDefinition.Cells(n, 4)
                        UpdateProperty col, prop
                    End If
                
                End If
            Next
        
        End If
    Next
    
    WriteProperties col
    
    'V4.1 Bugfix
    If MinVersionCheck(4, 1) Then
        
        WriteConnections colConn
    
    'V4.1 Bugfix
    End If
    
    
    rNewCIsListe.ClearContents

    bAutomaticStopAutoMacros = False

    UnloadSheetVariables
    
    'V4.12
    If nIgnored <> 0 Then
        MsgBox nIgnored & " CIs mit falschen CI-Typen wurden ignoriert!", vbExclamation
    End If
    
End Sub

Function ReadConnections(sOperation As String, Optional nKeyMode As Long = 0, Optional dDatum As Date = 0) As Collection

    Dim rLastConnections As Range
    Set rLastConnections = Range("lastConnections")
    Dim i As Long
    Dim conn As CConnection
    Dim col As Collection
    Set col = New Collection
    Dim n As Long
    
    'V4.23
    Dim colDWHConnectionCIs As Collection
    Set colDWHConnectionCIs = GetDWHConnectionCIs
    
    
    
    
    
    For i = 1 To rLastConnections.rows.Count
        If rLastConnections.Cells(i, 1) = "" Then Exit For
        
        Set conn = New CConnection
        conn.sOperation = sOperation
        conn.sCIType1 = rLastConnections.Cells(i, 1)
        conn.sCINr1 = rLastConnections.Cells(i, 2)
        conn.sCIType2 = rLastConnections.Cells(i, 3)
        conn.sCINr2 = rLastConnections.Cells(i, 4)
        conn.sVerbindungsart = rLastConnections.Cells(i, 5)
        conn.nMenge = CLng(rLastConnections.Cells(i, 6))
        conn.dEreignisdatum = dDatum
        
        
        'V4.23
        If rLastConnections.Cells(i, 7) = Fix(Now) Then
            On Error Resume Next
            colDWHConnectionCIs.Remove conn.sCINr1
            colDWHConnectionCIs.Remove conn.sCINr2
            On Error GoTo 0
        End If
            
        'V4.23
        If Not (ExistInCol(colDWHConnectionCIs, conn.sCIType1) Or ExistInCol(colDWHConnectionCIs, conn.sCIType1)) Then
        
            Select Case nKeyMode
            Case 0
                'V3.9 Bugfix?
                On Error Resume Next
                col.Add conn, conn.GetKey
                On Error GoTo 0
            Case 1
                n = 1
                While ExistInCol(col, "K" & conn.sCINr1 & "-" & n)
                    n = n + 1
                Wend
                col.Add conn, "K" & conn.sCINr1 & "-" & n
            Case 2
                n = 1
                While ExistInCol(col, "K" & conn.sCINr2 & "-" & n)
                    n = n + 1
                Wend
                col.Add conn, "K" & conn.sCINr2 & "-" & n
            End Select
            
        'V4.23
        End If
        
    Next
        
    'V4.23
    If colDWHConnectionCIs.Count > 0 Then
        Dim dbquery As CDBQuery
        Set dbquery = New CDBQuery
        
    
        
        'V4.23
        Dim sSQL As String, sSQL2 As String
        sSQL = "select * from v_cmdb WHERE "
        sSQL2 = " and (Gueltigbis> GetDate()) and (Gueltigvon<GetDate())"
        Dim sWhere As String
        Dim rs As ADODB.Recordset
        
        'V4.23
        While colDWHConnectionCIs.Count > 0
            Dim n1 As Long
            n1 = 1
            sWhere = ""
            While colDWHConnectionCIs.Count > 0 And n1 < 256
                sWhere = sWhere & ",'" & colDWHConnectionCIs(1) & "'"
                n1 = n1 + 1
                colDWHConnectionCIs.Remove 1
            Wend
            If sWhere <> "" Then
                sWhere = " (" & Mid(sWhere, 2) & ")"
                'sql fehlt
                Set rs = dbquery.Execute(Range("cisettingsDBDatasources"), "DWH-ServiceManagement", sSQL & "((CI1_Nr IN " & sWhere & ") OR (CI2_Nr IN " & sWhere & "))" & sSQL2)
                'Set rs = cnn.Execute(sSQL & "((CI1_Nr IN " & sWhere & ") OR (CI2_Nr IN " & sWhere & "))" & sSQL2)
                While Not rs.EOF
                    Set conn = New CConnection
                    conn.sOperation = sOperation
                    conn.sCIType1 = rs!CI1_Typ
                    conn.sCINr1 = rs!cI1_Nr
                    conn.sCIType2 = rs!CI2_Typ
                    conn.sCINr2 = rs!CI2_Nr
                    conn.sVerbindungsart = GetConnectionArt(rs!Verbindungsart)
                    conn.nMenge = rs!Menge
                    conn.dEreignisdatum = dDatum
                    rs.MoveNext
                
                    'V4.23
                    Select Case nKeyMode
                    Case 0
                        'V3.9 Bugfix?
                        On Error Resume Next
                        col.Add conn, conn.GetKey
                        On Error GoTo 0
                    Case 1
                        n = 1
                        While ExistInCol(col, "K" & conn.sCINr1 & "-" & n)
                            n = n + 1
                        Wend
                        col.Add conn, "K" & conn.sCINr1 & "-" & n
                    Case 2
                        n = 1
                        While ExistInCol(col, "K" & conn.sCINr2 & "-" & n)
                            n = n + 1
                        Wend
                        col.Add conn, "K" & conn.sCINr2 & "-" & n
                    End Select
                Wend
                
    'V4.23
            End If
        Wend
    End If
        
    
    Set ReadConnections = col


End Function


Function WriteConnections(col As Collection)
    
    Dim rLastConnections As Range
    Set rLastConnections = Range("lastConnections")
    Dim i As Long
    Dim conn As CConnection

    rLastConnections.ClearContents
    
        
    For i = 1 To col.Count
        Set conn = col(i)
        rLastConnections.Cells(i, 1) = conn.sCIType1
        rLastConnections.Cells(i, 2) = conn.sCINr1
        rLastConnections.Cells(i, 3) = conn.sCIType2
        rLastConnections.Cells(i, 4) = conn.sCINr2
        rLastConnections.Cells(i, 5) = conn.sVerbindungsart
        rLastConnections.Cells(i, 6) = conn.nMenge
        'V4.23
        rLastConnections.Cells(i, 7) = Fix(Now)
        
    Next


End Function




Sub SaveConnections(wk As Workbook)
    InitSheetVariables
    
    Dim col As Collection
    
'    Dim rLastConnections As Range
'    Set rLastConnections = Range("lastConnections")
    
    Dim conn As CConnection
    Dim conn2 As CConnection
    
    Dim i As Long
    
    Set col = ReadConnections("_")

    Dim rConnections As Range
    Set rConnections = Range("currentConnections")
    For i = 1 To rConnections.rows.Count
        If rConnections.Cells(i, 1) = "" Then Exit For
        
        Set conn2 = New CConnection
        
        'V3.1
        'conn2.sOperation = rConnections.Cells(i, 7)
        conn2.sOperation = rConnections.Cells(i, 9)
        
        conn2.sCIType1 = rConnections.Cells(i, 1)
        conn2.sCINr1 = rConnections.Cells(i, 2)
        conn2.sCIType2 = rConnections.Cells(i, 3)
        conn2.sCINr2 = rConnections.Cells(i, 4)
        
        'V3.1
        'conn2.sVerbindungsart = rConnections.Cells(i, 5)
        conn2.sVerbindungsart = rConnections.Cells(i, 8)
        
        conn2.nMenge = CLng(rConnections.Cells(i, 6))
        
        If conn2.sOperation = "L" Then
            If ExistInCol(col, conn2.GetKey) Then
            
                'V3.3
                Set conn = col(conn2.GetKey)
                If conn.nMenge <= conn2.nMenge Then
                
                    col.Remove conn2.GetKey
                    
                'V3.3
                Else
                    conn.nMenge = conn.nMenge - conn2.nMenge
                End If
            
                
            End If
        ElseIf conn2.sOperation = "V" Then
            If Not ExistInCol(col, conn2.GetKey) Then
                col.Add conn2, conn2.GetKey
            
            'V3.3
            Else
                Set conn = col(conn2.GetKey)
                conn.nMenge = conn.nMenge + conn2.nMenge
            
            
            End If
        End If
    Next
        
    WriteConnections col
    
    rConnections.ClearContents
    
    UnloadSheetVariables
End Sub


'Umbau in V3.2 Unterst|fffd|tzung f|fffd|r non-Bulks mit Menge >1, Neu ab V3: als Menge wird derzeit immer 1 gebucht, V3.3 abweichende Mengen k|fffd|nnen angegeben werden
Sub InsertConnection(col As Collection, sGUID1 As String, sGUID2 As String, sVerbindungsart As String, dEreignisdatum As Date, Optional nMenge As Long = 1, Optional sFilterMode As String = "")
    
    'V3.3
    If nMenge = 0 Then Exit Sub
    
    
    Dim conn As CConnection
    Dim conn2 As CConnection
    Dim x1 As Long
    Dim x2 As Long
    
    Dim colCINr1 As New Collection
    Dim colCINr2 As New Collection
    
    x1 = GetBestandslineByGUID(sGUID1)
    x2 = GetBestandslineByGUID(sGUID2)
    
    If x1 = -1 Or x2 = -1 Then Exit Sub
    
    Dim v1 As Variant
    Dim v2 As Variant
    
    v1 = Split(GetCellByTitle("bestandsliste_CI Nummer", x1), ", ")
    v2 = Split(GetCellByTitle("bestandsliste_CI Nummer", x2), ", ")
    
    Dim i1, i2 As Long
    
    For i1 = LBound(v1) To UBound(v1)
        For i2 = LBound(v2) To UBound(v2)

            Set conn2 = New CConnection
            conn2.sCIType1 = GetCellByTitle("bestandsliste_CI Type", x1)
            conn2.sCINr1 = v1(i1)
            conn2.sCIType2 = GetCellByTitle("bestandsliste_CI Type", x2)
            conn2.sCINr2 = v2(i2)
            'V3.3
            conn2.nMenge = nMenge
            
            'V3.7
            If sFilterMode <> "" Then
                If sFilterMode = "ByChildType" Then
                    Dim nFilter As Integer
                    Dim bFilterFound As Boolean
                    Dim bFilterMatched As Boolean
                    Dim sFilterName As String
                    Dim sFilter As String
                    
                    Dim x As Long
                    Dim vFilter As Long
                    bFilterFound = False
                    bFilterMatched = False
                    sFilter = Replace(GetCellByTitle("bestandsliste_Properties", x1) & ",", " ", "")
                    
                    'V3.7
                    For nFilter = 1 To 6
                        sFilterName = "Filter" & nFilter
                        If InStr(1, sFilter, sFilterName & "=" & conn2.sCIType2 & ",", vbTextCompare) <> 0 Then
                            bFilterMatched = True
                            Exit For
                        Else
                            x = InStr(1, sFilter, sFilterName & "=", vbTextCompare)
                            If x <> 0 Then
                                If Mid(sFilter, x + Len(sFilterName) + 1, 1) <> "," Then
                                    bFilterFound = True
                                End If
                            End If
                        End If
                    Next
                    If bFilterFound And Not bFilterMatched Then
                        conn2.sCINr1 = ""
                        conn2.sCINr2 = ""
                    End If
                End If
            End If
            
            
            If conn2.sCINr1 <> "" And conn2.sCINr2 <> "" Then
            
            
            
            
                conn2.sVerbindungsart = sVerbindungsart
                conn2.sOperation = "V"
                
                If ExistInCol(col, conn2.GetKey) Then
                    Set conn = col(conn2.GetKey)
                    If conn.sOperation = "L" Then
                        conn.sOperation = "_"
                    End If
                    
                    'V3.3
                    If (conn.nMenge_Alt = 0) And (conn.nMenge <> conn2.nMenge) Then
                        conn.nMenge_Alt = conn.nMenge
                    End If
                    conn.nMenge = conn2.nMenge
                    
                Else
                    conn2.dEreignisdatum = dEreignisdatum
                    col.Add conn2, conn2.GetKey
                    
                End If
            End If
        Next
    Next
End Sub


'V3.1
Function GetSpecificEreignisdatum(sRange As String, sField As String, nLine As Long, dDatum As Date) As Date
    Dim sDate As String
    
    If sField <> "" Then
        sDate = GetDataCellFromRange(sRange, sField, nLine)
        If IsDate(sDate) Then
            GetSpecificEreignisdatum = GetDataCellFromRange(sRange, sField, nLine)
        Else
            GetSpecificEreignisdatum = dDatum
        End If
    Else
        GetSpecificEreignisdatum = dDatum
    End If
    

End Function


'V4.1
Sub GetConnections_Kontierung(col As Collection)

    Dim r As Range
    Dim x1 As Long
    Dim i As Long
    Dim n As Long
    Dim sCINumber
    Dim conn As CConnection
    Dim dDatum As Date
    
    Dim bDefaultDebitor As Boolean
    
    
    dDatum = Range("projektdatenEreignisdatum")
    Set r = Range("bestandsliste")
    
    x1 = 1
    For i = 1 To r.rows.Count
        If GetCellByTitle("bestandsliste_CI Type", i) = "" Then Exit For
        
        
        
        If GetCellByTitle("bestandsliste_CI Nummer", x1) <> "" Then
            
            'V4.23
            'If (GetCellByTitle("bestandsliste_Flags", x1).Value And (cCIFlag_PreventDelete Or cCIFlag_PreventCreate Or cCIFlag_JustDelete)) = 0 Then
            'V4.24 bugfix? wenn bei PreventDelete keine Kontierungsinformation erzeugt wird dann werden die Verbindungen wieder ausgebucht
            'If ((GetCellByTitle("bestandsliste_Flags", x1).Value And (cCIFlag_PreventDelete Or cCIFlag_PreventCreate Or cCIFlag_JustDelete)) = 0) Or _
                '((GetCellByTitle("bestandsliste_Flags", x1).Value And cCIFlag_DWHConnections) = cCIFlag_DWHConnections) Then
            If ((GetCellByTitle("bestandsliste_Flags", x1).Value And (cCIFlag_PreventCreate Or cCIFlag_JustDelete)) = 0) Or _
                ((GetCellByTitle("bestandsliste_Flags", x1).Value And cCIFlag_DWHConnections) = cCIFlag_DWHConnections) Then
            
        
                Dim v As Variant
                v = Split(GetCellByTitle("bestandsliste_CI Nummer", x1), ", ")
                For n = LBound(v) To UBound(v)
                    sCINumber = v(n)
                    
                    'V4.1
                    Dim sProjekt As String, sDebitor As String
                    sProjekt = GetCellByTitle("bestandsliste_ProjektNr", x1)
                    If sProjekt <> "" Then
                        sDebitor = GetCellFromRange("projektdatenWeitereProjekte", 2, sProjekt, 3)
                    Else
                        sProjekt = Range("bestandslisteAnlagenprojekt")
                        sDebitor = ""
                    End If
                    
                    If sDebitor = "" Then
                        bDefaultDebitor = True
                        If Range("projektdatenDebitor") <> "" Then
                            sDebitor = Range("projektdatenDebitor")
                        Else
                            sDebitor = "<Default>"
                        End If
                    Else
                        bDefaultDebitor = False
                    End If
                    
                    'V4.1
                    Set conn = New CConnection
                    conn.nMenge = 1
                    conn.sVerbindungsart = "Kontierung"
                    conn.sCIType1 = "DEBITOR"
                    conn.sCIType2 = GetCellByTitle("bestandsliste_CI Type", x1)
                    conn.sCINr2 = sCINumber
                    conn.dEreignisdatum = dDatum
                    conn.sOperation = "V"
                                    
                    If bDefaultDebitor Then
                        conn.sCINr1 = "<Default>"
                        If Not ExistInCol(col, conn.GetKey) Then
                            conn.sCINr1 = sDebitor
                            If Not ExistInCol(col, conn.GetKey) Then
                                col.Add conn, "" & conn.GetKey
                            Else
                                col(conn.GetKey).sOperation = "_"
                            End If
                        Else
                            col(conn.GetKey).sOperation = "_"
                        End If
                    Else
                        
                        conn.sCINr1 = sDebitor
                        If Not ExistInCol(col, conn.GetKey) Then
                            col.Add conn, "" & conn.GetKey
                        Else
                            col(conn.GetKey).sOperation = "_"
                        End If
                    
                    End If
                    
                    'V4.1
                    Set conn = New CConnection
                    conn.nMenge = 1
                    conn.sVerbindungsart = "Kontierung"
                    conn.sCIType1 = "PROJEKT"
                    conn.sCINr1 = sProjekt
                    conn.sCIType2 = GetCellByTitle("bestandsliste_CI Type", x1)
                    conn.sCINr2 = sCINumber
                    conn.dEreignisdatum = dDatum
                    conn.sOperation = "V"
                    If Not ExistInCol(col, conn.GetKey) Then
                        col.Add conn, conn.GetKey
                    Else
                        col(conn.GetKey).sOperation = "_"
                    End If
                        
                    
                    
                Next
                
            End If
        End If
        
        x1 = x1 + 1
    Next





End Sub

Sub GetConnections_ServiceGruppe(col As Collection)
    Dim rService As Range
    Dim rStandort As Range
    
    
    
    
    'V3.1
    On Error Resume Next
    
    Set rService = Range("services")
    Set rStandort = Range("projektdatenStandort")
    
    'V3.1
    On Error GoTo 0
    If (rService Is Nothing) Or (rStandort Is Nothing) Then Exit Sub
    
    'V3.1
    Dim dDatum As Date
    dDatum = Range("projektdatenEreignisdatum")
    
    
    
    Dim i As Long
    Dim sGUID1 As String
    Dim sGUIDGruppe As String
    
    
    For i = 1 To rStandort.Count
        If rStandort.Cells(i, 3) <> "" And rStandort.Cells(i, 4) <> "" Then
            sGUID1 = rStandort.Cells(i, 4)
            Exit For
        End If
    Next
    
    'V1.986
    'If sGUID1 <> "" Then
        For i = 1 To rService.rows.Count
            'V4.6
            'Select Case "" & rService.Cells(i, 3)
            Select Case "" & rService.Cells(i, 6)
            
            Case "Service Gruppe"
                
                'V4.6
                'sGUIDGruppe = rService.Cells(i, 4)
                sGUIDGruppe = rService.Cells(i, 7)
                
                If sGUID1 <> "" Then
                
                    'V4.6
                    'InsertConnection col, sGUID1, "" & rService.Cells(i, 4), "physisch", dDatum
                    InsertConnection col, sGUID1, "" & rService.Cells(i, 7), "physisch", dDatum
                End If
                
            Case "Business Service"
                If sGUIDGruppe <> "" Then
                
                    'V4.6
                    'InsertConnection col, sGUIDGruppe, "" & rService.Cells(i, 4), "logisch", dDatum
                    InsertConnection col, sGUIDGruppe, "" & rService.Cells(i, 7), "logisch", dDatum
                    
                    
                End If
            Case "Technischer Service"
                If sGUIDGruppe <> "" Then
                
                    'V4.6
                    'InsertConnection col, sGUIDGruppe, "" & rService.Cells(i, 4), "logisch", dDatum
                    InsertConnection col, sGUIDGruppe, "" & rService.Cells(i, 7), "logisch", dDatum
                End If
            End Select
        Next
    'End If
End Sub

'V4.23
Function GetConnectionArt(nArt As Integer) As String
    Select Case nArt
    Case 1
        GetConnectionArt = "Vertrag"
    Case 2
        GetConnectionArt = "Kontierung"
    Case 3
        GetConnectionArt = "Logisch"
    Case 4
        GetConnectionArt = "Physisch"
    Case 5
        GetConnectionArt = "Kabel"
    Case 6
        GetConnectionArt = "Benutzer"
    Case 7
        GetConnectionArt = "Ansprechpartner"
    Case 8
        GetConnectionArt = "Lizenz"
    End Select
End Function

'V4.23
Function GetDWHConnectionCIs() As Collection
    Dim col As Collection
    Set col = New Collection
    
    Dim sCINr As String
    
    Dim i As Long
    i = 1
    While "" & GetCellByTitle("bestandsliste_GUID", i) <> ""
        If (GetCellByTitle("bestandsliste_Flags", i) And cCIFlag_DWHConnections) = cCIFlag_DWHConnections Then
            sCINr = GetCellByTitle("bestandsliste_CI Nummer", i)
            If sCINr <> "" Then
                On Error Resume Next
                col.Add sCINr, sCINr
                On Error GoTo 0
            End If
        End If
        i = i + 1
    Wend
    
    Set GetDWHConnectionCIs = col
    
End Function



'Umbau in V3.1
Sub GetConnections(wk As Workbook)
    
    InitSheetVariables
    
    
    
    Dim i As Long
    
    Dim col As Collection
    Dim conn As CConnection
    
    
    
    
    Dim sKey As String
    
    'V3.1
    'Dim sGUID1 As String
    'Dim sGUID2 As String
    
    'V3.1
    Dim sGUID As String
    
    
    'V1.985
    Dim vGUID2 As Variant
    Dim x As Integer
    
    'V3.5
    Dim vGUID1 As Variant
    
    
    Dim colParentConnections As New Collection
    
    'V3.1 wurde vorher sp|fffd|ter ausgef|fffd|hrt
    Dim rResult As Range
    Set rResult = Range("currentConnections")
    rResult.ClearContents
    
    
    
    'V3.1
    If Not IsDate(Range("projektdatenEreignisdatum")) Then
        Addlog "Kein Ereignisdatum gesetzt!"
        Exit Sub
    End If
    Dim dDatum As Date
    dDatum = Range("projektdatenEreignisdatum")
    
    
    
    'V3.1
    'Set col = ReadConnections("L")
    Set col = ReadConnections("L", , dDatum)
    
        
    
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsConnections")
    
    Dim rData As Range
    Dim nData As Long
    
    'V3.1
    Dim colGUID1 As Collection
    Dim colGUID2 As Collection
    
    
    GetConnections_ServiceGruppe col
    'V4.1
    'V4.10
    'If MinVersionCheck(4, 1) then
    If MinVersionCheck(4, 1) And ExistInCol(ActiveWorkbook.Names, "projektdatenDebitor") Then
    
    
        GetConnections_Kontierung col
    End If
    
    
    
    
    For i = 1 To rDefinition.rows.Count
        If rDefinition.Cells(i, 1) = "" Then Exit For
        
        'V4.11
        'Set rData = Range(rDefinition.Cells(i, 2))
        Set rData = Range2(rDefinition.Cells(i, 1) & "#" & rDefinition.Cells(i, 2))
        
        
        
            
        For nData = 1 To rData.rows.Count
            'If rData.Cells(nData, 1) = "" Then Exit For
            If LineEmpty(rData, nData) Then Exit For
            
            'V3.1
            Dim x3 As Long
            Dim xx3 As Long
            Dim v As Variant
            Dim sRange As String
            Dim sRangeCell As String
            Dim sRangeGUID As String
            Set colGUID1 = New Collection
            Set colGUID2 = New Collection
            
            'V3.1
            If rDefinition.Cells(i, 7) = "Get-Father-From-Range" Then
                x3 = InStr("" & rDefinition.Cells(i, 3), "->")
                If x3 <> 0 Then
                    sRange = Left("" & rDefinition.Cells(i, 3), x3 - 1)
                    v = Split(Mid("" & rDefinition.Cells(i, 3), x3 + 2), "\")
                    sRangeGUID = v(0)
                    If UBound(v) = 1 Then
                        sRangeCell = v(1)
                    Else
                        sRangeCell = ""
                    End If
                End If
                xx3 = 1
                While GetDataCellFromRange(sRange, sRangeGUID, xx3) <> ""
                    If sRangeCell <> "" Then
                        If GetDataCellFromRange(sRange, sRangeCell, xx3) = rDefinition.Cells(i, 2) Then
                            sGUID = GetDataCellFromRange(sRange, sRangeGUID, xx3)
                            If sGUID <> "" Then colGUID1.Add sGUID
                        End If
                    Else
                        sGUID = GetDataCellFromRange(sRange, sRangeGUID, xx3)
                        If sGUID <> "" Then colGUID1.Add sGUID
                        
                    End If
                    xx3 = xx3 + 1
                Wend
            Else
                'V3.5
                'sGUID = GetDataCellFromRange(rDefinition.Cells(i, 2), rDefinition.Cells(i, 3), nData)
                 'V1.985
                vGUID1 = Split(rDefinition.Cells(i, 3), ",")
                sGUID = ""
                x = LBound(vGUID1)
                While sGUID = "" And x <= UBound(vGUID1)
                    sGUID = GetDataCellFromRange(rDefinition.Cells(i, 2), Trim(vGUID1(x)), nData)
                    x = x + 1
                Wend
                
                
                If sGUID <> "" Then colGUID1.Add sGUID
                
            End If
            
'                If IsNumeric(rDefinition.Cells(i, 3)) Then
'                    '
'                Else
'                    sGUID1 = GetCellByTitle(rDefinition.Cells(i, 2) & "_" & rDefinition.Cells(i, 3), nData)
'                End If
                
            
            'V3.1
            If rDefinition.Cells(i, 7) = "Get-Son-From-Range" Then
                x3 = InStr("" & rDefinition.Cells(i, 4), "->")
                If x3 <> 0 Then
                    sRange = Left("" & rDefinition.Cells(i, 4), x3 - 1)
                    v = Split(Mid("" & rDefinition.Cells(i, 4), x3 + 2), ".")
                    sRangeGUID = v(0)
                    If UBound(v) = 1 Then
                        sRangeCell = v(1)
                    Else
                        sRangeCell = ""
                    End If
                End If
                xx3 = 1
                While GetDataCellFromRange(sRange, sRangeGUID, xx3) <> ""
                    If sRangeCell <> "" Then
                        If GetDataCellFromRange(sRange, sRangeCell, xx3) = rDefinition.Cells(i, 2) Then
                            sGUID = GetDataCellFromRange(sRange, sRangeGUID, xx3)
                            If sGUID <> "" Then colGUID2.Add sGUID
                        End If
                    Else
                        sGUID = GetDataCellFromRange(sRange, sRangeGUID, xx3)
                        If sGUID <> "" Then colGUID2.Add sGUID
                    End If
                    xx3 = xx3 + 1
                Wend
            Else
                 'V1.985
                vGUID2 = Split(rDefinition.Cells(i, 4), ",")
                sGUID = ""
                x = LBound(vGUID2)
                While sGUID = "" And x <= UBound(vGUID2)
                    sGUID = GetDataCellFromRange(rDefinition.Cells(i, 2), Trim(vGUID2(x)), nData)
                    x = x + 1
                Wend
                If sGUID <> "" Then colGUID2.Add sGUID
            
            End If
            
            
            If colGUID1.Count <> 0 And colGUID2.Count <> 0 Then
            
                'V3.3 Menge auswerten
                Dim nMenge As Long
                If rDefinition.Cells(i, 9) <> "" Then
                    Dim oT91 As CT91
                    Set oT91 = New CT91
                    oT91.Init rDefinition, i, rDefinition.Cells(i, 2), nData
                    'V3.8 Bugfix
                    'nMenge = cigen.T91(9)
                    nMenge = CLng("0" & oT91.t91(9))
                    Set oT91 = Nothing
                Else
                    nMenge = 1
                End If
                
            
                
                If rDefinition.Cells(i, 7) = "Alternate-Father" Then
                    If Not ExistInCol(colParentConnections, colGUID2(1) & ":" & rDefinition.Cells(i, 5)) Then
                        colParentConnections.Add colGUID2(1) & ":" & rDefinition.Cells(i, 5), colGUID2(1) & ":" & rDefinition.Cells(i, 5)
                        InsertConnection col, colGUID1(1), colGUID2(1), "" & rDefinition.Cells(i, 5), GetSpecificEreignisdatum(rDefinition.Cells(i, 2), rDefinition.Cells(i, 8), nData, dDatum), nMenge
                    End If
                Else
                    Dim sG1 As Variant
                    Dim sG2 As Variant
                    
                    
                    For Each sG2 In colGUID2
                        If Not ExistInCol(colParentConnections, sG2 & ":" & rDefinition.Cells(i, 5)) Then
                            colParentConnections.Add sG2 & ":" & rDefinition.Cells(i, 5), sG2 & ":" & rDefinition.Cells(i, 5)
                        End If
                                    
                        For Each sG1 In colGUID1
                            
                            'V3.7
                            Dim sFilterMode As String
                            sFilterMode = ""
                            If rDefinition.Cells(i, 7) = "Filter-Child-CI-Type" Then
                                sFilterMode = "ByChildType"
                            End If
                                
                            
                            InsertConnection col, "" & sG1, "" & sG2, "" & rDefinition.Cells(i, 5), GetSpecificEreignisdatum(rDefinition.Cells(i, 2), rDefinition.Cells(i, 8), nData, dDatum), nMenge, sFilterMode
                        
                        Next
                    Next
                    
                End If
                
            
            End If
            
            
        Next
    Next
    
'    Dim rResult As Range
'    Set rResult = Range("currentConnections")
'    rResult.ClearContents
    
    i = 1
    
    For Each conn In col
        If conn.sOperation <> "_" Then
            rResult.Cells(i, 1) = conn.sCIType1
            rResult.Cells(i, 2) = conn.sCINr1
            rResult.Cells(i, 3) = conn.sCIType2
            rResult.Cells(i, 4) = conn.sCINr2
            
            'V3.1
            Select Case Left(conn.sVerbindungsart, 1)
            Case "-"
                rResult.Cells(i, 5) = Mid(conn.sVerbindungsart, 2)
                If conn.sOperation = "V" Then
                    rResult.Cells(i, 7) = "L"
                Else
                    rResult.Cells(i, 7) = "-"
                End If
                
            Case "+"
                rResult.Cells(i, 5) = Mid(conn.sVerbindungsart, 2)
                If conn.sOperation = "V" Then
                    rResult.Cells(i, 7) = "V"
                Else
                    rResult.Cells(i, 7) = "-"
                End If
            
            Case Else
                rResult.Cells(i, 5) = conn.sVerbindungsart
                rResult.Cells(i, 7) = conn.sOperation
                        
            'V3.1
            End Select
            rResult.Cells(i, 8) = conn.sVerbindungsart
            rResult.Cells(i, 9) = conn.sOperation
            rResult.Cells(i, 10) = conn.dEreignisdatum
            
            rResult.Cells(i, 6) = conn.nMenge
            i = i + 1
        
        'V3.3 'Mengen korrekturen durchf|fffd|hren
        ElseIf conn.nMenge_Alt <> 0 Then
            'Mengen korrekturen werden f|fffd|r einmal-Verbindungen nicht unterst|fffd|tzt
            If (Left(conn.sVerbindungsart, 1) <> "+") And (Left(conn.sVerbindungsart, 1) <> "-") Then
                rResult.Cells(i, 1) = conn.sCIType1
                rResult.Cells(i, 2) = conn.sCINr1
                rResult.Cells(i, 3) = conn.sCIType2
                rResult.Cells(i, 4) = conn.sCINr2
                rResult.Cells(i, 5) = conn.sVerbindungsart
                rResult.Cells(i, 8) = conn.sVerbindungsart
                rResult.Cells(i, 10) = conn.dEreignisdatum
                If conn.nMenge > conn.nMenge_Alt Then
                    rResult.Cells(i, 7) = "V"
                    rResult.Cells(i, 9) = "V"
                    rResult.Cells(i, 6) = conn.nMenge - conn.nMenge_Alt
                Else
                    rResult.Cells(i, 7) = "L"
                    rResult.Cells(i, 9) = "L"
                    rResult.Cells(i, 6) = conn.nMenge_Alt - conn.nMenge
                End If
                i = i + 1
            End If
        
            
            
        
        End If
    Next
    
    UnloadSheetVariables

End Sub




Sub Buchblatt(wk As Workbook)

    InitSheetVariables

    Dim wk2 As Workbook
    Set wk2 = Application.Workbooks.Add
    
    Dim shexport As Worksheet
    Set shexport = wk2.Worksheets(1)
    
    wk.Activate
    
    shexport.UsedRange.Clear
    
    Dim i As Long, n As Long
    
    i = 1
    n = 0
    
    Dim rConnections As Range
    Set rConnections = Range("currentConnections")
    
    For i = 1 To rConnections.rows.Count
        If rConnections.Cells(i, 1) = "" Then Exit For
        n = n + 1
        
        'V3.1
        If rConnections.Cells(i, 7) <> "-" Then
        
            shexport.Cells(n, 1) = Range("projektdatenBuchblatt").Cells(1, 1)
            
            'V4.19
            'shexport.Cells(n, 2) = rConnections.Cells(i, 7)
            If rConnections.Cells(i, 7) = "V" Then
                shexport.Cells(n, 2) = "VERBINDEN"
            ElseIf rConnections.Cells(i, 7) = "L" Then
                shexport.Cells(n, 2) = "L|fffd|SEN"
            Else
                shexport.Cells(n, 2) = rConnections.Cells(i, 7)
            End If
                
            
            
            shexport.Cells(n, 3) = Fix(Now)
            shexport.Cells(n, 3).NumberFormat = "m/d/yyyy"
            
            'V3.1 bisher Range "projektdatenEreignisdatum" verwendet
            If rConnections.Cells(i, 10) = "" Then
                shexport.Cells(n, 4) = Fix(Now)
            Else
                shexport.Cells(n, 4) = rConnections.Cells(i, 10)
            End If
            
            shexport.Cells(n, 4).NumberFormat = "m/d/yyyy"
            shexport.Cells(n, 5) = rConnections.Cells(i, 1)
            shexport.Cells(n, 6) = rConnections.Cells(i, 2)
            shexport.Cells(n, 7) = rConnections.Cells(i, 3)
            shexport.Cells(n, 8) = rConnections.Cells(i, 4)
            shexport.Cells(n, 9) = rConnections.Cells(i, 5)
            shexport.Cells(n, 10) = rConnections.Cells(i, 6)
            shexport.Cells(n, 11) = Range("bestandslisteGeschaeftsfalltype").Cells(1, 1)
            shexport.Cells(n, 12) = Range("bestandslisteGeschaeftsfallNummer").Cells(1, 1)
            'V4.1
            shexport.Cells(n, 13) = 1
    
        'V3.1
        End If
        
    Next
    If n <> 0 Then
        
        Dim sPath As String
        sPath = wk.Path & "\buchblatt_" & Range("bestandslisteAnlagenprojekt") & "_" & Application.UserName & "_" & Format(Now, "yyyymmddhhMMss") & ".txt"
        wk2.SaveAs Filename:=sPath, FileFormat:= _
        xlCSVMSDOS, CreateBackup:=False, Local:=True

        wk2.Close False
        
        Addlog "Buchblatt wurde nach " & sPath & " exportiert"
        'V3.9
        CopyString sPath
        
    Else
        Addlog "Keine Zeilen gefunden!"
        wk2.Close False
    End If
    
    UnloadSheetVariables
    
End Sub

Sub ConfirmDelete(wk As Workbook)
    InitSheetVariables
    
    Dim rDeleteCIs As Range
    Set rDeleteCIs = Range("deleteCIs")
    
    Dim x1 As Long
    Dim i As Long
    
    Dim n As Long
    
    
    Dim col As Collection, col1 As Collection, col2 As Collection
    Set col = ReadConnections("")
    Set col1 = ReadConnections("", 1)
    Set col2 = ReadConnections("", 2)
    
    
    Dim colProp As New Collection
    ReadProperties colProp, 1
    
    Dim conn As CConnection
    
    
    For i = 1 To rDeleteCIs.rows.Count
        If rDeleteCIs.Cells(i, 1) = "" Then Exit For
        
        'V3.1
        Dim nFlags As Long
        x1 = GetBestandslineByGUID(rDeleteCIs.Cells(i, 4))
        nFlags = 0
        If x1 <> -1 Then
            nFlags = GetCellByTitle("bestandsliste_Flags", x1)
        End If
        
        'V3.1
        If (nFlags And cCIFlag_JustDelete) = cCIFlag_JustDelete Then
            If x1 <> -1 Then GetCellByTitle("bestandsliste_Flags", x1) = (nFlags Or cCIFlag_DeleteComplete)
        Else
            n = 1
            While ExistInCol(col1, "K" & rDeleteCIs.Cells(i, 2) & "-" & n)
                Set conn = col1("K" & rDeleteCIs.Cells(i, 2) & "-" & n)
                If ExistInCol(col, conn.GetKey) Then col.Remove conn.GetKey
                n = n + 1
            Wend
                 
            n = 1
            While ExistInCol(col2, "K" & rDeleteCIs.Cells(i, 2) & "-" & n)
                Set conn = col2("K" & rDeleteCIs.Cells(i, 2) & "-" & n)
                If ExistInCol(col, conn.GetKey) Then col.Remove conn.GetKey
                n = n + 1
            Wend
            
            n = 1
            While ExistInCol(colProp, "K" & rDeleteCIs.Cells(i, 2) & "-" & n)
                colProp.Remove "K" & rDeleteCIs.Cells(i, 2) & "-" & n
                n = n + 1
            Wend
                
            'V3.1 wird bereits weiter oben gemacht
            'x1 = GetBestandslineByGUID(rDeleteCIs.Cells(i, 4))
            
            If x1 <> -1 Then
                
                'V3.2
                If modFunctions.GetNoOfWordsInText(GetCellByTitle("bestandsliste_CI Nummer", x1)) > 1 Then
                    If Left(GetCellByTitle("bestandsliste_CI Nummer", x1), Len("" & rDeleteCIs.Cells(i, 2))) = "" & rDeleteCIs.Cells(i, 2) Then
                        GetCellByTitle("bestandsliste_CI Nummer", x1) = Mid(GetCellByTitle("bestandsliste_CI Nummer", x1), Len("" & rDeleteCIs.Cells(i, 2)) + 3)
                    Else
                        GetCellByTitle("bestandsliste_CI Nummer", x1) = Replace(GetCellByTitle("bestandsliste_CI Nummer", x1), ", " & rDeleteCIs.Cells(i, 2), "")
                    End If
                Else
                
                    GetCellByTitle("bestandsliste_GUID", x1).EntireRow.Delete
                
                'V3.2
                End If
            End If
        End If
    Next
    
    
    rDeleteCIs.ClearContents
    WriteConnections col
    WriteProperties colProp

    UnloadSheetVariables
End Sub

Public Function GetDataCellFromRange(sRange As String, sKey As String, nLine As Long) As Range
    If IsNumeric(sKey) Then
        Set GetDataCellFromRange = Range(sRange).Cells(nLine, CLng(sKey))
    Else
        Set GetDataCellFromRange = GetCellByTitle(sRange & "_" & sKey, nLine)
    End If
End Function


'V3.1
Sub OpenCMDB()
    InitSheetVariables
    
    Dim rDefinition As Range
    
    Dim x1 As Long
    Dim sGUID As String
    Dim n As Long, i As Long
    Dim r As Range
    
    Dim cigen As New CCIGeneration
    Dim s1 As String
    Dim s2 As String
    Dim sRange As String
    
    Dim sFindIn As String
    Dim bFound As Boolean
    
    '1... nach GUIDs suchen
    '2... nach Feldern in der CI Generation suchen
    '3... nach auch ber|fffd|cksichtigen dass Felder einen Lookup steuern
    
    Set r = Application.ActiveCell(1, 1)
    
    'ist die aktive Zelle eine GUID?
    If (Left(r, 1) = "{") And (Len(r) = 38) Then
        sGUID = r
    Else
        
        'Alle Definitionen durchgehen
        Set rDefinition = Range("ciSettingsCIGeneration")
        
        n = 2
        bFound = False
        
        Do While rDefinition.Cells(n, 1) <> ""
            
            'bezieht sich diese Defintion auf das aktuelle Sheet
            If rDefinition.Cells(n, cigen.GetCellPosSheet) = SheetName(ActiveSheet) Then
            
                'Spalten-ID f|fffd|r die aktive Zelle suchen
                sRange = rDefinition.Cells(n, cigen.GetCellPosRange)
                s1 = "[" & (1 + r.Column - Range(rDefinition.Cells(n, cigen.GetCellPosRange)).Column) & "]"
                s2 = GetCellFromRange("cisettingsRanges", 2, sRange, 3)
                If s2 <> "" Then
                    s2 = "[" & Range(s2).Cells(1, (1 + r.Column - Range(rDefinition.Cells(n, cigen.GetCellPosRange)).Column)) & "]"
                End If
                
                
                
                'befindet sich dieaktuelle Zelle in dem in der Definition angegebenen Range
                If RangesOverlapping(r, Range(sRange)) Then
                    
                    sFindIn = ""
                    For i = 1 To rDefinition.Columns.Count
                        sFindIn = sFindIn & rDefinition.Cells(n, i)
                    Next
                    
                    If sFindIn <> "" Then
                        If InStr(sFindIn, s1) <> 0 Then
                            sGUID = GetDataCellFromRange(sRange, rDefinition.Cells(n, cigen.GetCellPosGUID), 1 + r.Row - Range(sRange).Row)
                            Exit Do
                        End If
                        If s2 <> "" Then
                            If InStr(sFindIn, s2) Then
                                sGUID = GetDataCellFromRange(sRange, rDefinition.Cells(n, cigen.GetCellPosGUID), 1 + r.Row - Range(sRange).Row)
                                Exit Do
                            End If
                        End If
                    End If
                    
                    'in der Lookup Tabelle nachsehen
                    Set rDefinition = Range("cisettingsLookupUsage")
                    n = 2
                    bFound = False
                    
                    Do While rDefinition.Cells(n, 1) <> ""
                        'bezieht sich diese Defintion auf das aktuelle Sheet
                        If rDefinition.Cells(n, cigen.GetCellPosSheet) = SheetName(ActiveSheet) Then
                            sRange = rDefinition.Cells(n, cigen.GetCellPosRange)
                            'befindet sich dieaktuelle Zelle in dem in der Definition angegebenen Range
                            If RangesOverlapping(r, Range(sRange)) Then
                                If s2 = rDefinition.Cells(n, cigen.GetCellPosKey) Then
                                    bFound = True
                                    Exit Do
                                End If
                            End If
                        End If
                        n = n + 1
                        
                    Loop
                    If bFound Then
                        sGUID = GetDataCellFromRange(sRange, rDefinition.Cells(n, cigen.GetCellPosGUID), 1 + r.Row - Range(sRange).Row)
                        Exit Do
                    End If
                    
                    
                End If
            End If
            n = n + 1
        Loop
        
        
        
    End If
    
    If sGUID <> "" Then
        x1 = GetBestandslineByGUID(sGUID)
        If x1 <> -1 Then
            OpenNavision GetCellByTitle("bestandsliste_CI Type", x1), GetCellByTitle("bestandsliste_CI Nummer", x1)
        End If
    End If
    
    
    
End Sub


Sub OpenNavision(sCIType, sCINummer)
    If sCIType = "" Or sCINummer = "" Then Exit Sub
    
    Dim sForm As String
    Select Case sCIType
        Case "ANFORDERUNG": sForm = "75158"
        Case "APPLIANCE": sForm = "75138"
        Case "APPLIKATION": sForm = "75130"
        Case "APPLIKATIONS-/HW-AN": sForm = "75110"
        Case "BANDLAUFWERK": sForm = "75120"
        Case "BAUGRUPPE": sForm = "75105"
        Case "BILDVERARBEITUNG": sForm = "75144"
        Case "BLADE-CENTER": sForm = "75122"
        Case "CLUSTER": sForm = "75136"
        Case "DEBITOR": sForm = "21"
        Case "DRUCKER/SCANNER": sForm = "75118"
        Case "EQUIPMENT": sForm = "75102"
        Case "ERFASSUNGSEINHEIT": sForm = "75146"
        Case "ERWEITERUNGS-CHASSI": sForm = "75123"
        Case "FERNWARTUNG": sForm = "75107"
        Case "FESTPLATTE": sForm = "75114"
        Case "GLEICHRICHTER": sForm = "75112"
        Case "HIST. SERVICE DATEN": sForm = "75159"
        Case "IDENTIFIKATION": sForm = "75145"
        Case "KABEL / LEITUNG": sForm = "75153"
        Case "KLIMAKOMPONENTE": sForm = "75154"
        Case "KONTAKT": sForm = "5004"
        Case "KONTROLLEINHEIT": sForm = "75147"
        Case "KONVERTER": sForm = "75151"
        Case "KVM": sForm = "75124"
        Case "LAUFWERK/LUN": sForm = "75134"
        Case "LEUCHTE": sForm = "75152"
        Case "LIBRARY": sForm = "75119"
        Case "LIZENZ": sForm = "75132"
        Case "LOGIN": sForm = "75142"
        Case "MEDIA-INTERFACE": sForm = "75141"
        Case "MOBILES-ENDGER|fffd|T": sForm = "75143"
        Case "MODUL": sForm = "75140"
        Case "MONITOR": sForm = "75128"
        Case "NEA": sForm = "75155"
        Case "NETZWERKKOMPONENTE": sForm = "75139"
        Case "NETZWERKKONFIG": sForm = "75133"
        Case "ORGDATEN": sForm = "76423"
        Case "OS": sForm = "75108"
        Case "PAS. NETZWERKKOMP.": sForm = "75157"
        Case "PATCH": sForm = "75131"
        Case "PC-STECKKARTE": sForm = "75115"
        Case "PDU": sForm = "75126"
        Case "PORT": sForm = "75116"
        Case "PROJEKT": sForm = "89"
        Case "PROVIDERANBINDUNG": sForm = "75106"
        Case "RAID-ARRAY": sForm = "75135"
        Case "RAM-MODUL": sForm = "75117"
        Case "RECHNER": sForm = "75113"
        Case "SCHRANK": sForm = "75125"
        Case "SCHUTZEINRICHTUNG": sForm = "75150"
        Case "SERVICE": sForm = "75137"
        Case "SIGNALGEBER": sForm = "75149"
        Case "STANDORT": sForm = "75101"
        Case "STELLGLIED": sForm = "75148"
        Case "STORAGE": sForm = "75121"
        Case "TK-ENDGER|fffd|T": sForm = "75104"
        Case "TK-SYSTEM": sForm = "75103"
        Case "UC LAUFZEIT": sForm = "75929"
        Case "USV": sForm = "75127"
        Case "VERBRAUCHSMATERIAL": sForm = "75129"
        Case "VERTRAG - SLM": sForm = "75900"
        Case "VOICE-GATEWAY": sForm = "75111"
        Case "ZELLE": sForm = "75156"
        Case "ZERTIFIKAT": sForm = "75160"
        Case "ZUSATZEINRICHTUNG": sForm = "75109"
    End Select
    
    If sForm <> "" Then
        Dim sURL As String
        sURL = Replace(Replace(cNavUrl, "##form##", sForm), "##ci##", sCINummer)
        
        'V4.20
        'Shell "cmd /C start sURL
        Shell "cmd /C start """" """ & sURL & """"
        
        
        'Debug.Print sURL
        'MsgBox sURL
    End If
    
        
        
    
    
    
End Sub


Sub DeleteCIs(wk As Workbook)
    InitSheetVariables

    Dim rDeleteCIs As Range
    Set rDeleteCIs = Range("deleteCIs")
    
    rDeleteCIs.ClearContents
    
    Dim sGUID As String
    
    Dim i As Long
    Dim x2 As Long
    Dim n As Long
    x2 = GetNextBestandLine(wk)
    'V3.2
    Dim vCIs As Variant
    Dim i1 As Long
    
    For i = 1 To x2 - 1
        sGUID = GetCellByTitle("bestandsliste_GUID", i)
        If sGUID <> "" Then
        
        
            If GetCellByTitle("bestandsliste_Quelle", i) = "Generiert" Then
               If GetCellByTitle("bestandsliste_Ref-Count", i) = 0 Then
                    'V3.1
                    'If GetCellByTitle("bestandsliste_CI Nummer", i) = "" Then
                    'ev. bugfix prevent-delete eintr|fffd|ge gleich l|fffd|schen, vor allem wichtig wenn ohne makros gearbeitet wurde
                    If (GetCellByTitle("bestandsliste_CI Nummer", i) = "") Or ((CLng(GetCellByTitle("bestandsliste_Flags", i)) And cCIFlag_PreventDelete) = cCIFlag_PreventDelete) Then
                        GetCellByTitle("bestandsliste_CI Nummer", i).EntireRow.Delete
                        i = i - 1
                        x2 = x2 - 1
                    Else
                        
                        'V3.2
                        vCIs = Split(GetCellByTitle("bestandsliste_CI Nummer", i), ", ")
                        For i1 = LBound(vCIs) To UBound(vCIs)
                        
                            n = n + 1
                            
                            'V4.16
                            If GetCellByTitle("bestandsliste_CI Type", i) = "*" Then
                                rDeleteCIs.Cells(n, 1) = GetCIType("" & vCIs(i1))
                            Else
                            
                                rDeleteCIs.Cells(n, 1) = GetCellByTitle("bestandsliste_CI Type", i)
                            
                            'V4.16
                            End If
                            
                            
                            'V3.2
                            'rDeleteCIs.Cells(n, 2) = GetCellByTitle("bestandsliste_CI Nummer", i)
                            rDeleteCIs.Cells(n, 2) = vCIs(i1)
                            rDeleteCIs.Cells(n, 3) = GetCellByTitle("bestandsliste_Beschreibung", i)
                            rDeleteCIs.Cells(n, 4) = GetCellByTitle("bestandsliste_GUID", i)
                        
                        'V3.2
                        Next
                    
                    End If
                'V3.1
                'Eintr|fffd|ge mit JustDelete l|fffd|schen sobald die CI-Nummer da ist
                ElseIf ((CLng(GetCellByTitle("bestandsliste_Flags", i)) And cCIFlag_JustDelete) = cCIFlag_JustDelete) And (Not ((CLng(GetCellByTitle("bestandsliste_Flags", i)) And cCIFlag_DeleteComplete) = cCIFlag_DeleteComplete)) And (GetCellByTitle("bestandsliste_CI Nummer", i) <> "") Then
                    
                    'V3.2
                    vCIs = Split(GetCellByTitle("bestandsliste_CI Nummer", i), ", ")
                    For i1 = LBound(vCIs) To UBound(vCIs)
                    
                        n = n + 1
                        
                        'V4.16
                        If GetCellByTitle("bestandsliste_CI Type", i) = "*" Then
                            rDeleteCIs.Cells(n, 1) = GetCIType("" & vCIs(i1))
                        Else
                        
                            rDeleteCIs.Cells(n, 1) = GetCellByTitle("bestandsliste_CI Type", i)
                        
                        'V4.16
                        End If
                        
                        'V3.2
                        'rDeleteCIs.Cells(n, 2) = GetCellByTitle("bestandsliste_CI Nummer", i)
                        rDeleteCIs.Cells(n, 2) = vCIs(i1)
                        rDeleteCIs.Cells(n, 3) = GetCellByTitle("bestandsliste_Beschreibung", i)
                        rDeleteCIs.Cells(n, 4) = GetCellByTitle("bestandsliste_GUID", i)
                    
                    'V3.2
                    Next
                    
                'hier auf non-bulk menge >1 pr|fffd|fen wo die menge reduziert wurde
                'V3.2
                Else
                    Dim nCurrentNo As Long
                    nCurrentNo = modFunctions.GetNoOfWordsInText(GetCellByTitle("bestandsliste_CI Nummer", i))
                    If nCurrentNo > GetCellByTitle("bestandsliste_Menge", i) Then
                        vCIs = Split(GetCellByTitle("bestandsliste_CI Nummer", i), ", ")
                        For i1 = GetCellByTitle("bestandsliste_Menge", i) To UBound(vCIs)
                            n = n + 1
                            rDeleteCIs.Cells(n, 1) = GetCellByTitle("bestandsliste_CI Type", i)
                            rDeleteCIs.Cells(n, 2) = vCIs(i1)
                            rDeleteCIs.Cells(n, 3) = GetCellByTitle("bestandsliste_Beschreibung", i)
                            rDeleteCIs.Cells(n, 4) = GetCellByTitle("bestandsliste_GUID", i)
                        Next
                    End If
                    
                End If
            End If
                    
                    
        End If
    Next

    UnloadSheetVariables

End Sub


Sub RefreshRefCounts(wk As Workbook)
    InitSheetVariables

    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsCIGeneration")
    
    Dim cigen As New CCIGeneration
    Dim i As Long
    Dim n As Long
    Dim rData As Range
    
    Dim v As Variant
    Dim col As New Collection
    Dim sGUID As String
    
    For i = 2 To rDefinition.rows.Count
        If rDefinition.Cells(i, 1) = "" Then Exit For
        'V4.11
        'Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
        Set rData = Range2(rDefinition.Cells(i, cigen.GetCellPosSheet) & "#" & rDefinition.Cells(i, cigen.GetCellPosRange))
        For n = 1 To rData.rows.Count
            If LineEmpty(rData, n) Then
                Exit For
            End If
            'If rData.Cells(n, 1) = "" And rData.Cells(n + 1, 1) = "" Then
            '    Exit For
            'End If
            
            'V3.3
            'cigen.Init rDefinition, i, rData, n
            cigen.Init rDefinition, i, rDefinition.Cells(i, cigen.GetCellPosRange), n
            
            sGUID = cigen.GetGUID
            If sGUID <> "" Then
                If Not ExistInCol(col, sGUID) Then
                    v = 1
                    col.Add v, sGUID
                Else
                    v = col(sGUID)
                    v = v + 1
                    col.Remove sGUID
                    col.Add v, sGUID
                End If
            End If
        Next
    Next
    
    Dim x2 As Long
    x2 = GetNextBestandLine(wk)
    For i = 1 To x2 - 1
        sGUID = GetCellByTitle("bestandsliste_GUID", i)
        If sGUID <> "" Then
            If GetCellByTitle("bestandsliste_Quelle", i) = "Generiert" Then
                If ExistInCol(col, sGUID) Then
                    If GetCellByTitle("bestandsliste_Ref-Count", i) <> CLng(col(sGUID)) Then GetCellByTitle("bestandsliste_Ref-Count", i) = CLng(col(sGUID))
                Else
                    If GetCellByTitle("bestandsliste_Ref-Count", i) <> 0 Then GetCellByTitle("bestandsliste_Ref-Count", i) = 0
                End If
            End If
        End If
    Next
    
    UnloadSheetVariables
End Sub


Sub ReadProperties(col As Collection, Optional nKeyMode As Long = 0)
    
    Dim rLastProperties As Range
    Set rLastProperties = Range("lastProperties")
    Dim n As Long
    
    Dim prop As CProperty
    Dim i As Long
    For i = 1 To rLastProperties.rows.Count
        If rLastProperties.Cells(i, 1) = "" Then Exit For
        Set prop = New CProperty
        prop.sCIType = rLastProperties.Cells(i, 1)
        prop.sCINr = rLastProperties.Cells(i, 2)
        prop.sProperty = rLastProperties.Cells(i, 3)
        prop.sValue = rLastProperties.Cells(i, 4)
        prop.sNumberFormat = rLastProperties.Cells(i, 4).NumberFormat
        prop.sOperation = "_"
        
        Select Case nKeyMode
        Case 0
            If ExistInCol(col, prop.GetKey) Then col.Remove prop.GetKey
            col.Add prop, prop.GetKey
        Case 1
            n = 1
            While ExistInCol(col, "K" & prop.sCINr & "-" & n)
                n = n + 1
            Wend
            col.Add prop, "K" & prop.sCINr & "-" & n
        End Select
        
    Next
        
End Sub


Sub UpdateProperty(col As Collection, prop As CProperty, Optional AllowAdd As Boolean = True, Optional AddBlank As Boolean = False)
    
    If Not AllowAdd Then
        If Not ExistInCol(col, prop.GetKey) Then Exit Sub
    End If
    
    If prop.sCINr = "" Or prop.sCIType = "" Then Exit Sub
    
    If ((prop.sCIFlags And cCIFlag_PreventCreate) = cCIFlag_PreventCreate) And ((prop.sCIFlags And cCIFlag_ForceProperties) = 0) Then
        Exit Sub
    End If
    
    Dim prop2 As CProperty
    If "" & prop.sValue = "" Then
        If ExistInCol(col, prop.GetKey) Then
        
            'V3.1
            If "" & col(prop.GetKey).sValue <> "" Then
                col.Remove prop.GetKey
                col.Add prop, prop.GetKey
            End If
                    
        ElseIf AddBlank Then
            col.Add prop, prop.GetKey
        End If
    Else
        If Not ExistInCol(col, prop.GetKey) Then
            col.Add prop, prop.GetKey
        Else
            Set prop2 = col(prop.GetKey)
            If prop2.sValue <> prop.sValue Then
                col.Remove prop.GetKey
                col.Add prop, prop.GetKey
            End If
        End If
    End If
End Sub

Sub ExportProperties(wk As Workbook)

    InitSheetVariables

    Dim col As New Collection
    ReadProperties col
    GetProperties col, wk
    GetProperties2 col, wk
    
    Dim wk2 As Workbook
    Set wk2 = Application.Workbooks.Add
    wk.Activate
    
    
    Dim shexport As Worksheet
    Set shexport = wk2.Worksheets(1)
    
    If ShowProperties(col, shexport) <> 0 Then
        Dim sPath As String
        sPath = wk.Path & "\eigenschaften_" & Range("bestandslisteAnlagenprojekt") & "_" & Application.UserName & "_" & Format(Now, "yyyymmddhhMMss") & ".txt"
        wk2.SaveAs Filename:=sPath, FileFormat:= _
        xlCSVMSDOS, CreateBackup:=False, Local:=True
        wk2.Close False
        
        Addlog "Datei wurde nach " & sPath & " exportiert"
        'V3.9
        CopyString sPath
        
    Else
        Addlog "Keine Zeilen gefunden!"
        wk2.Close False
    End If
    
    
    UnloadSheetVariables
    
End Sub

Sub GetProperties2(col As Collection, wk As Workbook)
    
    Dim x1 As Long
    x1 = GetNextBestandLine(wk)
    
    Dim rDefinition As Range
    Dim i As Long
    Dim n As Long
    
    Set rDefinition = Range("settingsAttributes")
    
    Dim colDef As New Collection
    
    For i = 1 To rDefinition.rows.Count
        If rDefinition.Cells(i, 1) = "" Then Exit For
        If rDefinition.Cells(i, 3) = 2 Then
            colDef.Add CVar(i), rDefinition.Cells(i, 1)
        End If
    Next
    
    
    Dim s As String
    
    Dim prop As CProperty
    Dim v1 As Variant, v2 As Variant
    
    Dim i1 As Long, i2 As Long
    
    For n = 1 To x1
        If GetCellByTitle("bestandsliste_Properties", n) <> "" Then
            s = GetCellByTitle("bestandsliste_Properties", n)
            v1 = Split(s, ",")
            For i1 = LBound(v1) To UBound(v1)
                v2 = Split(v1(i1), "=")
                If UBound(v2) = 1 Then
                    If ExistInCol(colDef, Trim(v2(0))) Then
                        
                        'V3.2
                        Dim vCIs As Variant
                        vCIs = Split(GetCellByTitle("bestandsliste_CI Nummer", n), ", ")
                        Dim i3 As Long
                        For i3 = LBound(vCIs) To UBound(vCIs)
                        
                        
                            Set prop = New CProperty
                            prop.sCIType = GetCellByTitle("bestandsliste_CI Type", n)
                            
                            'V3.2
                            'prop.sCINr = GetCellByTitle("bestandsliste_CI Nummer", n)
                            prop.sCINr = vCIs(i3)
                            
                            prop.sCIFlags = GetCellByTitle("bestandsliste_Flags", n)
                            
                            prop.sProperty = rDefinition.Cells(colDef(Trim(v2(0))), 2)
                            prop.sValue = v2(1)
                        
                            'V1.985
                            If rDefinition.Cells(colDef(Trim(v2(0))), 5) <> "" Then
                                If Len(prop.sValue) > CLng(rDefinition.Cells(colDef(Trim(v2(0))), 5)) Then
                                    prop.sUncutValue = prop.sValue
                                    prop.sValue = Left(prop.sValue, CLng(rDefinition.Cells(colDef(Trim(v2(0))), 5)))
                                End If
                            End If
                            
                            
                            prop.sOperation = "+"
                            prop.sNumberFormat = rDefinition.Cells(colDef(Trim(v2(0))), 4)
                            UpdateProperty col, prop
                        
                        Next
                    End If
                End If
            Next
        End If
    Next

End Sub


Sub GetProperties(col As Collection, wk As Workbook)
    Dim i As Long
    Dim n As Long
    Dim x1 As Long
    
    x1 = GetNextBestandLine(wk)
    
    Dim rDefinition As Range
    Set rDefinition = Range("settingsAttributes")
    
    Dim prop As CProperty
    
    For n = 1 To x1
    
        If "" & GetCellByTitle("bestandsliste_CI Nummer", n) <> "" And "" & GetCellByTitle("bestandsliste_CI Type", n) <> "" Then
            For i = 1 To rDefinition.rows.Count
                If rDefinition.Cells(i, 1) = "" Then Exit For
                
                If (rDefinition.Cells(i, 3) = 1) Or (rDefinition.Cells(i, 3) = 3) Then
                    
                    'V3.2
                    Dim vCIs As Variant
                    vCIs = Split(GetCellByTitle("bestandsliste_CI Nummer", n), ", ")
                    Dim i1 As Long
                    For i1 = LBound(vCIs) To UBound(vCIs)
                    
                    
                        Set prop = New CProperty
                        prop.sCIType = GetCellByTitle("bestandsliste_CI Type", n)
                        
                        'V3.2
                        'prop.sCINr = GetCellByTitle("bestandsliste_CI Nummer", n)
                        prop.sCINr = vCIs(i1)
                        
                        prop.sProperty = rDefinition.Cells(i, 2)
                        prop.sValue = GetCellByTitle("bestandsliste_" & rDefinition.Cells(i, 1), n)
                        
                        'V1.985
                        If rDefinition.Cells(i, 5) <> "" Then
                            If Len(prop.sValue) > CLng(rDefinition.Cells(i, 5)) Then
                                prop.sUncutValue = prop.sValue
                                prop.sValue = Left(prop.sValue, CLng(rDefinition.Cells(i, 5)))
                            End If
                        End If
                        
                        
                        prop.sCIFlags = GetCellByTitle("bestandsliste_Flags", n)
                        
                        prop.sOperation = "+"
                        prop.sNumberFormat = rDefinition.Cells(i, 4)
                        
                        
                        'V4.5
                        'UpdateProperty col, prop, IIf(rDefinition.Cells(i, 3) = 3, False, True)
                        UpdateProperty col, prop, IIf((rDefinition.Cells(i, 3) = 3) And ((prop.sCIFlags And cCIFlag_PreventDelete) = cCIFlag_PreventDelete), False, True)
                    Next
                End If
            Next
        End If
    Next
End Sub

Function ShowProperties(col As Collection, shexport As Worksheet) As Long
    Dim rCurrentProperties As Range
    Set rCurrentProperties = Range("currentProperties")
    
    Dim prop As CProperty
    Dim i As Long
    Dim n As Long
    
    n = 0
    
    rCurrentProperties.ClearContents
    shexport.UsedRange.Clear
    
    For i = 1 To col.Count
        Set prop = col(i)
        If prop.sOperation = "+" Then
            n = n + 1
            rCurrentProperties.Cells(n, 1) = prop.sCIType
            rCurrentProperties.Cells(n, 2) = prop.sCINr
            rCurrentProperties.Cells(n, 3) = prop.sProperty
            rCurrentProperties.Cells(n, 4).NumberFormat = CStr(prop.sNumberFormat)
            rCurrentProperties.Cells(n, 4) = prop.sValue
        
            'V1.985
            If prop.sUncutValue <> "" Then
                Addlog "Der Text """ & prop.sUncutValue & """ wurde auf """ & prop.sValue & """ abgeschnitten."
            End If
        
            shexport.Cells(n, 1) = prop.sCIType
            shexport.Cells(n, 2) = prop.sCINr
            shexport.Cells(n, 3) = prop.sProperty
            shexport.Cells(n, 4).NumberFormat = CStr(prop.sNumberFormat)
            shexport.Cells(n, 4) = prop.sValue
            
        End If
    Next
    ShowProperties = n
    
End Function


Sub SaveProperties(wk As Workbook)
    InitSheetVariables
    
    Dim col As Collection
    
    
    
    Dim prop2 As CProperty
    
    Dim i As Long
    
    Set col = New Collection
    ReadProperties col

    Dim rProperties As Range
    Set rProperties = Range("currentProperties")
    
    For i = 1 To rProperties.rows.Count
        If rProperties.Cells(i, 1) = "" Then Exit For
        
        Set prop2 = New CProperty
        
        prop2.sCIType = rProperties.Cells(i, 1)
        prop2.sCINr = rProperties.Cells(i, 2)
        prop2.sProperty = rProperties.Cells(i, 3)
        prop2.sNumberFormat = rProperties.Cells(i, 4).NumberFormat
        prop2.sValue = rProperties.Cells(i, 4)
        
        prop2.sOperation = "+"
        
        If "" & prop2.sValue = "" Then
            If ExistInCol(col, prop2.GetKey) Then
                col.Remove prop2.GetKey
            End If
        Else
            If ExistInCol(col, prop2.GetKey) Then col.Remove prop2.GetKey
            col.Add prop2, prop2.GetKey
            
        End If
    Next
        
    WriteProperties col
    
    rProperties.ClearContents

    UnloadSheetVariables

End Sub

'V3.8
Sub SaveTracking(wk As Workbook)
    InitSheetVariables
    
    Dim col As Collection
    
    
    
    Dim track As CTracking
    Dim track2 As CTracking
    
    Dim i As Long
    
    Set col = New Collection
    Set col = ReadTracking

    Dim rTracking As Range
    Set rTracking = Range("currentTracking")
    
    For i = 1 To rTracking.rows.Count
        If rTracking.Cells(i, 1) = "" Then Exit For
        
        Set track2 = New CTracking
        
        track2.sCIType = rTracking.Cells(i, 1)
        track2.sCINr = rTracking.Cells(i, 2)
        track2.sTrackingType = "+/-"
        track2.nDiffMenge = rTracking.Cells(i, 3)
        
        If ExistInCol(col, track2.GetKey) Then
            Set track = col(track2.GetKey)
            track.nMenge = track.nMenge + track2.nDiffMenge
            If track.nMenge = 0 Then
                col.Remove track.GetKey
            End If
        Else
            track2.nMenge = track2.nDiffMenge
            col.Add track2, track2.GetKey
        End If
    Next
        
    WriteTracking col
    
    rTracking.ClearContents

    UnloadSheetVariables

End Sub



Function WriteProperties(col As Collection)
    
    Dim rLastProperties As Range
    Set rLastProperties = Range("lastProperties")
    Dim i As Long
    Dim prop As CProperty

    rLastProperties.ClearContents
        
    For i = 1 To col.Count
        Set prop = col(i)
        rLastProperties.Cells(i, 1) = prop.sCIType
        rLastProperties.Cells(i, 2) = prop.sCINr
        rLastProperties.Cells(i, 3) = prop.sProperty
        rLastProperties.Cells(i, 4).NumberFormat = prop.sNumberFormat
        rLastProperties.Cells(i, 4) = prop.sValue
        
    Next


End Function



Sub ToggleMode()

    Dim bDesign As Boolean
    Dim bManipulation As Boolean
    
    Dim rDefinition As Range
    Dim rDefinition2 As Range
    
    Dim sSheets As String
    Dim vSheets As Variant
    
    Dim colSheets2Show As New Collection
    Dim x As Integer
    
    Dim i As Long
    Dim n As Long
    
    Set rDefinition2 = Range("settingsServiceModellRanges")
    n = 1
    While rDefinition2.Cells(n, 1) <> ""
    
        Set rDefinition = Range(rDefinition2.Cells(n, 1))
        For i = 1 To rDefinition.rows.Count
            If rDefinition.Cells(i, 1) <> "" Then
                sSheets = GetCellFromRange("settingsServiceModell", 1, GetCellByTitle(rDefinition2.Cells(n, 1) & "_" & rDefinition2.Cells(n, 2), i), 2)
                If sSheets <> "" Then
                    vSheets = Split(sSheets, "|")
                    For x = LBound(vSheets) To UBound(vSheets)
                        If Not ExistInCol(colSheets2Show, Trim(vSheets(x))) Then
                            colSheets2Show.Add "" & vSheets(x), "" & vSheets(x)
                        End If
                    Next
                End If
            End If
        Next
        
        n = n + 1
    Wend
    
    Set rDefinition = Range("cisettingsRanges")
    i = 1
    While rDefinition.Cells(i, 1) <> ""
        If rDefinition.Cells(i, nCellPosRangeVisibility) <> "" Then
        
            'V3.8
            Dim vVisRange As Variant
            vVisRange = Split(rDefinition.Cells(i, nCellPosRangeVisibility), "|")
            Dim i5 As Long
            For i5 = LBound(vVisRange) To UBound(vVisRange)
            
                
                
                If Range(vVisRange(i5)) = "JA" Then
                    
                    'V3.4
                    Select Case "" & rDefinition.Cells(i, nCellPosRangeVisiblityMode)
                    Case "", "Sheet"
                        
                        On Error Resume Next
                        colSheets2Show.Add "" & rDefinition.Cells(i, nCellPosRangeSheet), "" & rDefinition.Cells(i, nCellPosRangeSheet)
                        On Error GoTo 0
                    
                    
                    'V3.4
                    Case "Columns"
                        Range("" & rDefinition.Cells(i, nCellPosRangeName)).EntireColumn.Hidden = False
                    Case "Rows"
                        Range("" & rDefinition.Cells(i, nCellPosRangeName)).EntireRow.Hidden = False
                    End Select
                Else
                    Select Case "" & rDefinition.Cells(i, nCellPosRangeVisiblityMode)
                    Case "", "Sheet"
                    Case "Columns"
                        Range("" & rDefinition.Cells(i, nCellPosRangeName)).EntireColumn.Hidden = True
                    Case "Rows"
                        Range("" & rDefinition.Cells(i, nCellPosRangeName)).EntireRow.Hidden = True
                    End Select
                
                
                End If
            
            'V3.8
            Next
            
        End If
        i = i + 1
    Wend
    
    Select Case "" & Range("startMode").Cells(1, 1)
    Case "Datenerfassung"
    Case "CMDB-Pflege"
        bManipulation = True
    Case "Design"
        bManipulation = True
        bDesign = True
    End Select
    
    
    n = 0
    
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.Worksheets
        Select Case sh.Range(sSheetID).Value
            Case "CITInput"
                ShowSheet sh, ExistInCol(colSheets2Show, SheetName(sh)), n
            'V3.8, V3.6
            'Case "CITCIListe", "CITErzeugen", "CITL|fffd|schen", "CITVerbindungen", "CITEigenschaften"
            'Case "CITCIListe", "CITErzeugen", "CITL|fffd|schen", "CITVerbindungen", "CITEigenschaften", "CITPflege"
            Case "CITCIListe", "CITErzeugen", "CITL|fffd|schen", "CITVerbindungen", "CITEigenschaften", "CITPflege", "CITTracking"
                ShowSheet sh, bManipulation, n
            Case "CITDesign"
                ShowSheet sh, bDesign
            Case Else
                ShowSheet sh, True, n
        End Select
    Next
    
    
    
    

End Sub


'Ordnet den Server-Software eintr|fffd|gen automatisch Hardware gleichen Hostnamen zu. Diese FUnktion ist spezielle f|fffd|r einen Anwendungsfall ausprogrammiert und ist nichtParameter gesteuert
Sub HardwareAssignment()
    
    InitSheetVariables
    MonitorLookup = True
    
    
    
    Dim i As Long
    i = 1
    Dim colHW As New Collection
    While Not LineEmpty(Range("geraeteliste"), i)
        If (GetCellByTitle("geraeteliste_CI Type", i) = "RECHNER") Or (GetCellByTitle("geraeteliste_CI Type", i) = "APPLIANCE") Then
            If (GetCellByTitle("geraeteliste_hostname", i) <> "") And (GetCellByTitle("geraeteliste_DNS Suffix", i) <> "") Then
                On Error Resume Next
                colHW.Add CVar(i), GetCellByTitle("geraeteliste_Hostname", i) & "." & GetCellByTitle("geraeteliste_DNS Suffix", i)
                On Error GoTo 0
            End If
        End If
        i = i + 1
    Wend
    
    Dim x As Long
    i = 1
    While Not LineEmpty(Range("serverliste"), i)
        If (GetCellByTitle("serverliste_hostname", i) <> "") And (GetCellByTitle("serverliste_DNS Suffix", i) <> "") Then
            If ExistInCol(colHW, GetCellByTitle("serverliste_hostname", i) & "." & GetCellByTitle("serverliste_DNS Suffix", i)) Then
                x = colHW(GetCellByTitle("serverliste_hostname", i) & "." & GetCellByTitle("serverliste_DNS Suffix", i))
                
                GetCellByTitle("serverliste_Hardware", i) = GetCellByTitle("geraeteliste_Hostname", x) & "." & GetCellByTitle("geraeteliste_DNS Suffix", x) & " - " & GetCellByTitle("geraeteliste_Fabrikationsnummer", x)
            End If
        End If
        i = i + 1
    Wend
    
    MonitorLookup = False
    
    UnloadSheetVariables
End Sub

''V4.11 ausgebaut feld in der Defintion anderweitig verwendet
'Sub CheckInputData()
'
'    Dim rDefinition As Range
'    Set rDefinition = Range("cisettingsCIGeneration")
'
'    Dim cigen As CCIGeneration
'    Set cigen = New CCIGeneration
'    Dim rData As Range
'    Dim i1 As Long
'
'    Dim i As Long
'
'    For i = 2 To rDefinition.rows.Count
'        If rDefinition.Cells(i, 1) = "" Then Exit For
'        Set rData = Range(rDefinition.Cells(i, cigen.GetCellPosRange))
'        For i1 = 1 To rData.rows.Count
'            'If rData.Cells(i1, 1) = "" Then Exit For
'            If LineEmpty(rData, i1) Then Exit For
'
'            'V3.3
'            'cigen.Init rDefinition, i, rData, i1
'            cigen.Init rDefinition, i, rDefinition.Cells(i, cigen.GetCellPosRange), i1
'
'            Dim sText As String
'            Dim r As Range
'            sText = cigen.CheckInput
'            If sText <> "" Then
'                Debug.Print "" & rDefinition.Cells(i, cigen.GetCellPosSheet) & "/" & rDefinition.Cells(i, cigen.GetCellPosRange) & "," & " Zeile " & i1 & ": " & sText & ";" & "'" & Range(rDefinition.Cells(i, cigen.GetCellPosRange)).Parent.Name & "'!" & Range(rDefinition.Cells(i, cigen.GetCellPosRange)).rows(i1).Address
'            End If
'
'        Next
'    Next
'
'End Sub

'Wird aufgerufen um anzuzeigen dass sich ein Inhalt ge|fffd|ndert hat
Sub OnChange_Handler(target As Range)
    If target.Address <> sSheetID Then CheckAccess
    InitSheetVariables
    UpdateLookups_And_CIs target
    
    UnloadSheetVariables
End Sub

'Wird aufgerufen um anzuzeigen dass sich ein Inhalt im Sheet mit der CIListe (CI-Daten erg|fffd|nzen) ge|fffd|ndert hat
Sub OnChange_Handler_CIListe(target As Range)
    If target.Address <> sSheetID Then CheckAccess
    
    InitSheetVariables

    Dim sh As Worksheet
    Set sh = GetSheetByName("CI Daten erg|fffd|nzen")
    
    
    If bStopAutoMacros Then Exit Sub
    
    Dim colLookupDef As Collection
    
    Dim nLine As Long
    
    If RangesOverlapping(target, Range("bestandsliste")) Then
    
        'V1.985
        Set colGUIDs = Nothing
        
        Set colLookupDef = GetLookupDefinitions
        
        Dim i As Long
        For i = target.rows(1).Row To target.rows(target.rows.Count).Row
            If i >= Range("bestandsliste").rows(1).Row Then
                If Range("bestandslisteGUID").Cells(i, 1) = "" Then
                    If sh.Cells(i, 1) & sh.Cells(i, 2) & sh.Cells(i, 3) & sh.Cells(i, 4) & sh.Cells(i, 5) <> "" Then
                        Range("bestandslisteGUID").Cells(i, 1) = NewGUID
                    End If
                End If
            End If
            
            nLine = i - Range("bestandsliste").rows(1).Row + 1
            
            'V3.8
            If target.Columns.Count > 1 Then
            
                'V3.8
                'MarkCILookups nLine, colLookupDef
                MarkCILookups nLine, "", colLookupDef
            
            'V.38
            Else
                Dim sField As String
                sField = Range("bestandslisteTitel").Cells(1, target.Column)
                If sField <> "" Then
                    MarkCILookups nLine, sField, colLookupDef
                End If
            End If
            
            
        Next
        
        CreateRange_CILookups
    
    End If
  
    
    
    UpdateLookups_And_CIs target

    UnloadSheetVariables

End Sub

'V4.5 'search PK fields in Selection line
Function SearchPKFields(ByRef sPK1 As String, sPK2 As String, sPK3 As String, sPK4 As String, nLine As Long) As Boolean
    Dim rDefinition As Range
    Set rDefinition = Range("cisettingsRanges")
    Dim i As Integer
    i = 1
    sPK1 = ""
    sPK2 = ""
    sPK3 = ""
    sPK4 = ""
    
    While rDefinition.Cells(i, 1) <> ""
        If SheetName(ActiveWorkbook.ActiveSheet) = rDefinition.Cells(i, nCellPosRangeSheet) Then
            If rDefinition.Cells(i, nCellPosRangeGetByTitle) <> "" Then
                If RangesOverlapping(Selection.Cells(1, 1), Range(rDefinition.Cells(i, nCellPosRangeName))) Then
                    sPK1 = SearchPKField1(rDefinition.Cells(i, nCellPosRangeName), "Bereich")
                    sPK2 = SearchPKField1(rDefinition.Cells(i, nCellPosRangeName), "Funktion")
                    sPK3 = SearchPKField1(rDefinition.Cells(i, nCellPosRangeName), "Gruppe")
                    sPK4 = SearchPKField1(rDefinition.Cells(i, nCellPosRangeName), "Name")
                    nLine = Selection.Row - Range(rDefinition.Cells(i, nCellPosRangeName)).Row + 1
                    
                End If
                           
            End If
        End If
    
        i = i + 1
    Wend
    SearchPKFields = (sPK1 <> "")
    
End Function

'V4.5
Private Function SearchPKField1(sName As String, sTitle As String) As String
    Dim sRet As String
    sRet = SearchPKField2("PK Produkt", sName, sTitle)
    If sRet = "" Then sRet = SearchPKField2("PK-", sName, sTitle)
    If sRet = "" Then sRet = SearchPKField2("Produkt-", sName, sTitle)
    If sRet = "" Then sRet = SearchPKField2("Produkt-" & vbLf, sName, sTitle)
    If sRet = "" Then sRet = SearchPKField2("Produkt", sName, sTitle)
    SearchPKField1 = sRet
End Function

'V4.5
Private Function SearchPKField2(sPrefix As String, sName As String, sTitle As String)
    If ExistCellByTitle(sName & "_" & sPrefix & sTitle) Then
        SearchPKField2 = sName & "_" & sPrefix & sTitle
    End If
End Function

'V4.5
Sub PKTest()
    InitSheetVariables
    InitCellsByTitle "DEFAULT"
    Dim cbt As CCellByTitle
    For Each cbt In colRangeTitles
        If InStr(cbt.sTitle, "ereich") Then
            Debug.Print cbt.sName & "." & cbt.sTitle
        End If
    Next
            
End Sub


'V4.5
Sub PKEdit()
    InitSheetVariables
    LoadPK
    
    Dim frm As New frmPK
    Dim sPK1 As String
    Dim sPK2 As String
    Dim sPK3 As String
    Dim sPK4 As String
    Dim nLine As Long
    
    If SearchPKFields(sPK1, sPK2, sPK3, sPK4, nLine) Then
        frm.sPK1 = sPK1
        frm.sPK2 = sPK2
        frm.sPK3 = sPK3
        frm.sPK4 = sPK4
        frm.nLine = nLine
        frm.Show vbModal
    Else
        MsgBox "Produktkatalogfelder konnten nicht gefunden werden", vbExclamation
    End If
End Sub


'V4.5
Sub LoadPK()

    If Not colPK Is Nothing Then
        If colPK.Count <> 0 Then
            Exit Sub
        End If
    End If
    
    Set colPK = New Collection
    Set colPK1 = New Collection
    Set colPK2 = New Collection
    Set colPK3 = New Collection
    Set colPK4 = New Collection
    
    Dim rPK As Range
    Set rPK = Range("produktkatalog")
    
    Dim pk As CPKEintrag
    
    Dim sKey As String
    Dim i As Long
    Dim x As Long
    i = 1
    While rPK.Cells(i, 1) <> ""
        
        Set pk = New CPKEintrag
        pk.sBereich = rPK.Cells(i, 1)
        pk.sFunktion = rPK.Cells(i, 2)
        pk.sGruppe = rPK.Cells(i, 3)
        pk.sName = rPK.Cells(i, 4)
        pk.sBeschreibung = rPK.Cells(i, 7)
        pk.sSuchstring = rPK.Cells(i, 1) & "\" & rPK.Cells(i, 2) & "\" & rPK.Cells(i, 3) & "\" & rPK.Cells(i, 4) & "\" & rPK.Cells(i, 6) & "\" & rPK.Cells(i, 7)
        
        sKey = rPK.Cells(i, 1)
        If Not ExistInCol(colPK1, sKey) Then colPK1.Add pk.sBereich, sKey
        
        If Not ExistInCol(colPK2, sKey & "\" & pk.sFunktion) Then
            colPK2.Add pk.sFunktion, sKey & "\" & pk.sFunktion
            x = 1
            While ExistInCol(colPK2, sKey & "\#" & x)
                x = x + 1
            Wend
            colPK2.Add pk.sFunktion, sKey & "\#" & x
        End If
        sKey = sKey & "\" & pk.sFunktion
        
        If Not ExistInCol(colPK3, sKey & "\" & pk.sGruppe) Then
            colPK3.Add pk.sGruppe, sKey & "\" & pk.sGruppe
            x = 1
            While ExistInCol(colPK3, sKey & "\#" & x)
                x = x + 1
            Wend
            colPK3.Add pk.sGruppe, sKey & "\#" & x
        End If
        sKey = sKey & "\" & pk.sGruppe
        
        If Not ExistInCol(colPK4, sKey & "\" & pk.sName) Then
            colPK4.Add pk.sGruppe, sKey & "\" & pk.sName
            x = 1
            While ExistInCol(colPK4, sKey & "\#" & x)
                x = x + 1
            Wend
            colPK4.Add pk.sName, sKey & "\#" & x
        End If
        sKey = sKey & "\" & pk.sName
        
        If Not ExistInCol(colPK, sKey) Then colPK.Add pk, sKey
        
        
                
        i = i + 1
    Wend
    
End Sub
Attribute VB_Name = "modGUID"
'V4.21
' Durch das Update KB3213624  (Office'10), kb3213545 (Office'16) ist die der Aufruf des COM Objekts Scriptlet.TypeLib nicht mehr zul|fffd|ssig



' No VT_GUID available so must declare type GUID

Private Type GUID_TYPE

                Data1 As Long

                Data2 As Integer

                Data3 As Integer

                Data4(7) As Byte

End Type

Private Declare PtrSafe Function CoCreateGuid Lib "ole32.dll" (Guid As GUID_TYPE) As LongPtr
Private Declare PtrSafe Function StringFromGUID2 Lib "ole32.dll" (Guid As GUID_TYPE, ByVal lpStrGuid As LongPtr, ByVal cbMax As Long) As LongPtr



Function CreateGuidString()
    Dim Guid As GUID_TYPE
    Dim strGuid As String
    Dim retValue As LongPtr
    Const guidLength As Long = 39 'registry GUID format with null terminator {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    retValue = CoCreateGuid(Guid)
    If retValue = 0 Then
        strGuid = String$(guidLength, vbNullChar)
        retValue = StringFromGUID2(Guid, StrPtr(strGuid), guidLength)
        If retValue = guidLength Then
        'valid GUID as a string
            CreateGuidString = strGuid
        End If
    End If
End Function

Attribute VB_Name = "modGlobal"
Option Explicit

Public colRangeTitles As Collection
Public colRangeTitleCollections As New Collection
Public colRangeTitles_Vorerfassung As Collection



'V1.985
Public bAutomaticStopAutoMacros As Boolean
Public Const bManuellStopAutoMacros = False

'V1.985
Public Property Get bStopAutoMacros() As Boolean
    bStopAutoMacros = (bManuellStopAutoMacros Or bAutomaticStopAutoMacros)
End Property

'V3.6
Public Function Trim2(s As String) As String
    Dim x As Integer
    x = InStr(s, Chr(0))
    
    If x <> 0 Then
        Trim2 = Left(s, x - 1)
    Else
        Trim2 = s
    End If
    
End Function




'''Public Function GetGeneralInfo() As String
'''    GetGeneralInfo = "cmdb Import Toolkit: " & Range("bestandslisteGeschaeftsfalltype").Value & "/" & Range("bestandslisteGeschaeftsfallNummer").Value & "; " & Range("projektdatenBuchblatt").Value & "; " & Range("projektdatenEreignisdatum").Value & " .... (Zeile Doppelklicken zum |fffd|ndern)"
'''End Function


'Gibt zur|fffd|ck ob ein |fffd|bergebenes Range Objekt einen g|fffd|ltigen Bezug enth|fffd|lt
Public Function IsRangeValid(r As Range) As Boolean
    Dim s As String
    On Error Resume Next
    s = r.Address
    If Err.number = 0 Then
        IsRangeValid = True
    Else
        IsRangeValid = False
    End If
End Function

'Entfernt alle zeichen die in einem Dateinamen nicht erlaubt sind
'V3.4
Function replaceforbiddenchars(s As String) As String
    Dim sHide As String
    sHide = "\/:*?""<>|"
    Dim i As Integer
    For i = 1 To Len(sHide)
        s = Replace(s, Mid(sHide, i, 1), "")
    Next
    replaceforbiddenchars = s
    

End Function

'V4.11
Sub LoadWB(sFile As String)
    
    Dim rFiles As Range
    Set rFiles = Range("cisettingsExternalFiles")
    Dim i As Long
    i = 1
    Dim curWb As Workbook
    
    While rFiles.Cells(i, 1) <> ""
        If rFiles.Cells(i, 1) = sFile Then
            Set curWb = ActiveWorkbook
            Workbooks.Open rFiles.Cells(i, 2)
            curWb.Activate
        End If
        i = i + 1
    Wend
    

End Sub


'L|fffd|dt die Titel der Bereiche wo mit GetCellByTitle zugegriffen werden kann in die entsprechenden Collections
Sub InitCellsByTitle(sMode As String)
    Select Case sMode
    Case "DEFAULT"
        If colRangeTitles.Count = 0 Then
            'Set colRangeTitles = New Collection
            
            Dim rDefinition As Range
            Set rDefinition = Range("cisettingsRanges")
            Dim i As Integer
            i = 1
            While rDefinition.Cells(i, 1) <> ""
                If rDefinition.Cells(i, nCellPosRangeGetByTitle) <> "" Then
                
                    'V4.11
                    If InStr(rDefinition.Cells(i, nCellPosRangeSheet), "#") = 0 Then
                    
                        LoadCellsByTitle Range(rDefinition.Cells(i, nCellPosRangeTitle)), Range(rDefinition.Cells(i, nCellPosRangeName)), rDefinition.Cells(i, nCellPosRangeName), colRangeTitles
                        
                    'V4.11
                    Else
                        Dim sWB As String
                        Dim sSheet As String
                        Dim sRange As String
                        Dim v As Variant
                        v = Split(rDefinition.Cells(i, nCellPosRangeSheet), "#")
                        sWB = v(0)
                        sSheet = v(1)
                        sRange = rDefinition.Cells(i, nCellPosRangeName)
                        CheckWB sWB
                        Dim sh As Worksheet
                        
                        Set sh = Workbooks(sWB).Worksheets(sSheet)
                        If Left(sRange, 1) = "!" Then
                            Dim lobj As ListObject
                            Set lobj = sh.ListObjects(Mid(sRange, 2))
                            LoadCellsByTitle lobj.HeaderRowRange, lobj.DataBodyRange, sRange, colRangeTitles
                        Else
                            LoadCellsByTitle sh.Range(rDefinition.Cells(i, nCellPosRangeTitle)), sh.Range(rDefinition.Cells(i, nCellPosRangeName)), rDefinition.Cells(i, nCellPosRangeName), colRangeTitles
                        End If
                    End If
                    
                    
                End If
                i = i + 1
            Wend

        End If
    Case "VORERFASSUNG"
        If colRangeTitles_Vorerfassung Is Nothing Then
            Set colRangeTitles_Vorerfassung = New Collection
            LoadCellsByTitle Range("vorerfassungTitel"), Range("vorerfassung"), "vorerfassung", colRangeTitles_Vorerfassung
        End If
    End Select

End Sub

'|fffd|berpr|fffd|ft ob die Zeile mit der angegebenen Zeilennummer in einem Range leer ist
Function LineEmpty(rTarget As Range, nLine As Long) As Boolean
    'V4.8
    'If rTarget.Cells(nLIne, 2) & rTarget.Cells(nLIne, 3) & rTarget.Cells(nLIne, 4) & rTarget.Cells(nLIne, 5) & rTarget.Cells(nLIne, 6) = "" & rTarget.Cells(nLIne, 7) = "" & rTarget.Cells(nLIne, 8) = "" & rTarget.Cells(nLIne, 9) = "" Then
    'V4.25
    'If rTarget.Cells(nLine, 2) & rTarget.Cells(nLine, 3) & rTarget.Cells(nLine, 4) & rTarget.Cells(nLine, 5) & rTarget.Cells(nLine, 6) & rTarget.Cells(nLine, 7) & rTarget.Cells(nLine, 8) & rTarget.Cells(nLine, 9) = "" Then
    If rTarget.Cells(nLine, 1) & rTarget.Cells(nLine, 2) & rTarget.Cells(nLine, 3) & rTarget.Cells(nLine, 4) & rTarget.Cells(nLine, 5) & rTarget.Cells(nLine, 6) & rTarget.Cells(nLine, 7) & rTarget.Cells(nLine, 8) & rTarget.Cells(nLine, 9) = "" Then
        LineEmpty = True
    Else
        LineEmpty = False
    End If
End Function


Sub LoadCellsByTitle(rTitle As Range, r As Range, sName As String, colTitles As Collection)
    Dim cbc As CCellByTitle
    Dim i As Integer
    For i = 1 To rTitle.Columns.Count
        If rTitle.Cells(1, i) = "" Then
            Exit For
        End If
        If Not ExistInCol(colTitles, sName & "_" & rTitle.Cells(1, i)) Then
            Set cbc = New CCellByTitle
            cbc.nCol = i
            Set cbc.r = r
            cbc.sTitle = rTitle.Cells(1, i)
            cbc.sName = sName
            colTitles.Add cbc, sName & "_" & rTitle.Cells(1, i)

        End If
    Next

End Sub


'|fffd|berpr|fffd|ft ob eine Collection ein Objekt mit dem angegebenen Key enth|fffd|lt
Function ExistInCol(col As Object, key As String) As Boolean
     Dim s As String
     On Error GoTo c1
      s = TypeName(col(key))
     On Error GoTo 0
     ExistInCol = True
     Exit Function
c1:
    ExistInCol = False
End Function




'''Function GetDynamicSettings(sh As Worksheet) As Collection
'''    Dim col As New Collection
'''
'''    Dim i As Integer
'''    For i = 1 To sh.Range("settingsDynamic").Rows.Count
'''        If sh.Range("settingsDynamic").Cells(i, 1) <> "" Then
'''            col.Add "" & sh.Range("settingsDynamic").Cells(i, 3), "" & sh.Range("settingsDynamic").Cells(i, 1) & sh.Range("settingsDynamic").Cells(i, 2)
'''        End If
'''    Next
'''    Set GetDynamicSettings = col
'''End Function


'Sucht in einer durch einen LoadCellByTitle-Key spezifizierten Spalte nach einem String
'V4.11
'Function GetLineNrFromCellByTitleAndKey(sKey As String, sSearch As String, sEndIndicator As String)
Function GetLineNrFromCellByTitleAndKey(sKey As String, sSearch As String, sEndIndicator As String, Optional rRange As Range = Nothing)
    Dim n As Long
    n = 1
    'V4.11
    'While GetCellByTitle(sEndIndicator, n) <> ""
    While 1
        If sEndIndicator <> "" Then
            If GetCellByTitle(sEndIndicator, n) = "" Then
                GetLineNrFromCellByTitleAndKey = -1
                Exit Function
            End If
        ElseIf Not rRange Is Nothing Then
            If LineEmpty(rRange, n) Then
                GetLineNrFromCellByTitleAndKey = -1
                Exit Function
            End If
        Else
            GetLineNrFromCellByTitleAndKey = -1
            Exit Function
        End If
                    
            
        If GetCellByTitle(sKey, n) = sSearch Then
            GetLineNrFromCellByTitleAndKey = n
            Exit Function
        End If
        n = n + 1
    Wend
    
    'V4.11
    'GetLineNrFromCellByTitleAndKey = -1

End Function


'V3.4 |fffd|bper|fffd|ft ob ein CellByTitle Eintrag existiert
Function ExistCellByTitle(sKey As String, Optional sMode As String = "DEFAULT") As Boolean
    Dim colTitles As Collection
    
    Select Case sMode
    Case "DEFAULT"
        Set colTitles = colRangeTitles
    Case "VORERFASSUNG"
        Set colTitles = colRangeTitles_Vorerfassung
    Case Else
        Exit Function
    End Select
    

    If colTitles Is Nothing Then Set colTitles = New Collection
    If colTitles.Count = 0 Then
    
        InitCellsByTitle sMode
     
        Select Case sMode
        Case "DEFAULT"
            Set colTitles = colRangeTitles
        Case "VORERFASSUNG"
            Set colTitles = colRangeTitles_Vorerfassung
        Case Else
            Exit Function
        End Select
     
     
     End If
     
     
     
    If ExistInCol(colTitles, sKey) Then
        ExistCellByTitle = True
    Else
        ExistCellByTitle = False
    End If
End Function


'Gibt in einer durch einen LoadCellByTitle-Key spezifizierten Spalte einen Zelle mit der angegebenen Zeilennummer zur|fffd|ck
'Unterscheidet zwei Modi:
' "DEFAULT" .... |fffd|berschriften werden einmalig ausgelesen
' "VORERFASSUNG" .... |fffd|berschriften werden vor jedem Import ausgelesen

Function GetCellByTitle(sKey As String, n As Long, Optional sMode As String = "DEFAULT") As Range

    Dim colTitles As Collection
    
    Select Case sMode
    Case "DEFAULT"
        Set colTitles = colRangeTitles
    Case "VORERFASSUNG"
        Set colTitles = colRangeTitles_Vorerfassung
    Case Else
        Exit Function
    End Select
    

    If colTitles Is Nothing Then Set colTitles = New Collection
    If colTitles.Count = 0 Then
    
        InitCellsByTitle sMode
     
        Select Case sMode
        Case "DEFAULT"
            Set colTitles = colRangeTitles
        Case "VORERFASSUNG"
            Set colTitles = colRangeTitles_Vorerfassung
        Case Else
            Exit Function
        End Select
     
     
     End If
     
     
     
    If ExistInCol(colTitles, sKey) Then
        Dim cbc As CCellByTitle
        Set cbc = colTitles(sKey)
        
        Set GetCellByTitle = cbc.r.Cells(n, cbc.nCol)
    Else
        MsgBox "Zelle " & sKey & " nicht gefunden!", vbCritical
        Set GetCellByTitle = Nothing
    End If
End Function

'|fffd|berpr|fffd|ft ob in der angebenen Spalte des |fffd|bergebenen Ranges eine Zelle mit dem |fffd|bergebenen Value (Key) vorkommt
Function ExistInRange(sRange As String, nColumn As Long, sKey As String) As Boolean
    Dim r As Range
    Set r = Range(sRange)
    Dim i As Long
    For i = 1 To r.rows.Count
        If r.Cells(i, nColumn) = sKey Then
            ExistInRange = True
            Exit Function
        End If
    Next
    ExistInRange = False
    

End Function

'V4.11
Function Range2(sRange As String) As Range
    Dim v As Variant
    v = Split(sRange, "#")
    Select Case UBound(v)
    Case 0
        Set Range2 = Range(sRange)
    Case 1
        Set Range2 = Range(v(1))
    Case 2
        If Left(v(2), 1) = "!" Then
            Set Range2 = Workbooks(v(0)).Worksheets(v(1)).ListObjects(Mid(v(2), 2)).DataBodyRange
        Else
            Set Range2 = Workbooks(v(0)).Worksheets(v(1)).Range(v(2))
        End If
    End Select
            
        
End Function

'V4.11
Function FoundDefinitionSheet(rDefinition As Range, i As Long, rTarget As Range) As Boolean
    Dim bForeignTarget As Boolean
    bForeignTarget = (rTarget.Parent.Parent.Name <> ActiveWorkbook.Name)
    Dim cigen As New CCIGeneration
    
    Dim v1 As Variant
    
    FoundDefinitionSheet = False
    
    If bForeignTarget Then
        If InStr(rDefinition.Cells(i, cigen.GetCellPosSheet), "#") <> 0 Then
            v1 = Split(rDefinition.Cells(i, cigen.GetCellPosSheet), "#")
            If Left(rTarget.Parent.Parent.Name, Len(v1(0))) = v1(0) Then
                If rTarget.Parent.Name = v1(1) Then
                    FoundDefinitionSheet = True
                End If
            End If
        End If
    Else
        FoundDefinitionSheet = (rDefinition.Cells(i, cigen.GetCellPosSheet) = SheetName(rTarget.Parent))
    End If

End Function

'V4.11
Sub CheckWB(sFile As String)
    If Not ExistInCol(Workbooks, sFile) Then
        LoadWB sFile
    End If

End Sub



'Gibt die n|fffd|chste freie Zeilennummer in einem Range zur|fffd|ck. Dabei wird |fffd|berpr|fffd|ft ob die Zelle der angegebenen Spalte leer ist
'V4.25
'Function GetNextInRange(sRange As String, nColumn As Long, Optional nStart As Long = 1) As Long
Function GetNextInRange(sRange As String, nColumn As Long, Optional nStart As Long = 1, Optional bExtendRange As Boolean = False) As Long
    Dim r As Range
    
    'V4.11
    Dim v As Variant
    v = Split(sRange, "#")
    Select Case UBound(v)
    Case 0
        
        Set r = Range(sRange)
        
    'V4.11
    Case 1
        Set r = Range(v(1))
    Case 2
        CheckWB "" & v(0)
        If Left(v(2), 1) = "!" Then
            Set r = Workbooks(v(0)).Worksheets(v(1)).ListObjects(Mid(v(2), 2)).DataBodyRange
        Else
            Set r = Workbooks(v(0)).Worksheets(v(1)).Range(v(2))
        End If
    End Select
            
    
    
    Dim i As Long
    For i = nStart To r.rows.Count
        If nColumn <> 0 Then
            If "" & r.Cells(i, nColumn) = "" Then
                GetNextInRange = i
                Exit Function
            End If
        Else
            If LineEmpty(r, i) Then
                GetNextInRange = i
                Exit Function
            End If
        End If
    
    Next
    
    'V4.25
    If bExtendRange Then
        GetNextInRange = i
    Else
        GetNextInRange = -1
    End If
End Function

'Sucht in einer Spalte (nColumn) des Ranges (sRange) nach dem Wert (sKey) und gibt dann den Inhalt der Zelle in Spalte (nReturnColumn) zur|fffd|ck
Function GetCellFromRange(sRange, nColumn, sKey, nReturnColumn) As String
    Dim r As Range
    Set r = Range(sRange)
    Dim i As Long
    For i = 1 To r.rows.Count
        If "" & r.Cells(i, nColumn) = "" & sKey Then
            GetCellFromRange = r.Cells(i, nReturnColumn)
            Exit Function
        End If
    Next
    GetCellFromRange = ""
    
End Function

'Schreibt den Wert vom Variant v bzw. die Werte des Variant-Arrays v in die Zeile (nRow) des angegebenen Ranges (r)
Function AddLine2Range(r As Range, nRow As Long, v As Variant)
    Dim i As Long
    Dim x As Long
    If IsArray(v) Then
        x = 1
        For i = LBound(v) To UBound(v)
            r.Cells(nRow, x) = v(i)
            x = x + 1
        Next
    Else
        r.Cells(nRow, 1) = v
    End If
        
End Function

'|fffd|berpr|fffd|ft ob sich zwei angegebenen Ranges |fffd|berschneiden. Es muss jedoch vorher |fffd|berpr|fffd|ft werden ob diese sich |fffd|berhaupt auf dem gleichen Blatt befinden
Function RangesOverlapping(rA As Range, rB As Range) As Boolean
    Dim xa1 As Long, xa2 As Long
    Dim ya1 As Long, ya2 As Long
    
    Dim xb1 As Long, xb2 As Long
    Dim yb1 As Long, yb2 As Long
    
    xa1 = rA.Cells(1, 1).Column
    ya1 = rA.Cells(1, 1).Row
    
    xa2 = rA.Cells(rA.rows.Count, rA.Columns.Count).Column
    ya2 = rA.Cells(rA.rows.Count, rA.Columns.Count).Row
    
    xb1 = rB.Cells(1, 1).Column
    yb1 = rB.Cells(1, 1).Row
    
    xb2 = rB.Cells(rB.rows.Count, rB.Columns.Count).Column
    yb2 = rB.Cells(rB.rows.Count, rB.Columns.Count).Row

    Dim bXLapping As Boolean
    Dim bYlapping As Boolean
    
    bXLapping = True
    bYlapping = True
    
    If (xa1 > xb2) Or (xb1 > xa2) Then bXLapping = False
    If (ya1 > yb2) Or (yb1 > ya2) Then bYlapping = False
    
    If bXLapping And bYlapping Then RangesOverlapping = True

End Function

'Generiert eine neue GUID
Public Function NewGUID() As String
    'V4.21
    'NewGUID = Left(CreateObject("Scriptlet.TypeLib").Guid, 38)
    NewGUID = CreateGuidString
End Function

'Liefert den Namen eines Worksheet Objekts zur|fffd|ck. Es wird dabei von der Namenskonvention "nummer - name" ausgegangen
Public Function SheetName(sh As Worksheet) As String
    Dim x As Long
    x = InStr(sh.Name, "-")
    If x = 0 Then
        SheetName = sh.Name
    Else
        If IsNumeric(Trim(Left(sh.Name, x - 1))) Then
            SheetName = Trim(Mid(sh.Name, x + 1))
        Else
            SheetName = sh.Name
        End If
    End If
End Function

'Liefert ein Worksheet aus dem angegebenen Workbook, identifziert durch den  Namen. Es wird dabei von der Namenskonvention "nummer - name" ausgegangen
Public Function GetSheetByNameWB(s As String, wk As Workbook) As Worksheet
    Dim sh As Worksheet
    For Each sh In wk.Worksheets
        If SheetName(sh) = s Then
            Set GetSheetByNameWB = sh
            Exit Function
        End If
    Next
    
End Function


'Liefert ein Worksheet aus dem aktiven Workbook, identifziert durch den  Namen. Es wird dabei von der Namenskonvention "nummer - name" ausgegangen
Public Function GetSheetByName(s As String) As Worksheet
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.Worksheets
        If SheetName(sh) = s Then
            Set GetSheetByName = sh
            Exit Function
        End If
    Next
    
End Function

'Blendet ein Sheet ein oder aus. Numeriert dabei die Sheets durch
Public Function ShowSheet(sh As Worksheet, visible As Boolean, Optional ByRef n As Long = -1)
    If visible Then
        If n <> -1 Then
            sh.Name = n & " - " & SheetName(sh)
        Else
            sh.Name = SheetName(sh)
        End If
        sh.visible = xlSheetVisible
        sh.Cells(1, 1) = sh.Cells(1, 1)
        n = n + 1
    Else
        sh.visible = xlSheetVeryHidden
    End If
End Function


'Vergleicht 2 Versionen jeweils bestehend aus 3 Zahlen. Gibt 0 zur|fffd|ck wenn beide gleich sind, -1 wenn die 1. kleiner ist und +1 wenn die 2. kleiner ist

Public Function CompareVersion(ByVal nV1 As Integer, ByVal nV1Major As Integer, ByVal nV1Minor As Integer, ByVal nV2 As Integer, ByVal nV2Major As Integer, ByVal nV2Minor As Integer) As Integer
    If nV1 < nV2 Then
        CompareVersion = -1
    ElseIf nV1 > nV2 Then
        CompareVersion = 1
    ElseIf nV1Major < nV2Major Then
        CompareVersion = -1
    ElseIf nV1Major > nV2Major Then
        CompareVersion = 1
    ElseIf nV1Minor < nV2Minor Then
        CompareVersion = -1
    ElseIf nV1Minor > nV2Minor Then
        CompareVersion = 1
    Else
        CompareVersion = 0
    End If


End Function
Attribute VB_Name = "modProtection"
Option Explicit
Private Const sPassword = "t00lkitPWD"


'|fffd|berpr|fffd|ft ob Macros Zugriff auf gesperrte Inhalte haben
Sub CheckAccess()
    On Error Resume Next
    ActiveWorkbook.Worksheets(1).Range(sSheetID) = ActiveWorkbook.Worksheets(1).Range(sSheetID)
    If Err.number <> 0 Then
        ManualUnlock
        ManualLock
    End If
End Sub

'Sperrt alle Sheets
Sub ManualLock()
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.Worksheets
        Select Case sh.Range(sSheetID)
            Case "CITStart", "CITStart", "CITGeneral", "CITVorerfassung", "CITInput", "CITVisibleInput", "CITCIListe", "CITErzeugen", "CITL|fffd|schen", "CITVerbindungen", "CITEigenschaften"
                LockSheet sh
            Case Else
        End Select
    Next
End Sub

'Entsperrt alle Sheets
Sub ManualUnlock()
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.Worksheets
        Select Case sh.Range(sSheetID)
            Case "CITStart", "CITStart", "CITGeneral", "CITVorerfassung", "CITInput", "CITVisibleInput", "CITCIListe", "CITErzeugen", "CITL|fffd|schen", "CITVerbindungen", "CITEigenschaften"
                UnlockSheet sh
            Case Else
        End Select
    Next
End Sub

'Sperrt ein Sheet
Private Sub LockSheet(sh As Worksheet)
    sh.Protect sPassword, userinterfaceonly:=True, AllowFiltering:=True
End Sub

'Entsperrt ein Sheet
Private Sub UnlockSheet(sh As Worksheet)
    sh.Unprotect sPassword
End Sub
Attribute VB_Name = "modRibbon"
Option Explicit

Dim rib As IRibbonUI

Public Const sSheetID = "$A$1"

Public Const bProgramMode = True



Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)

'Callback for customButtonAutoConnect onAction
Sub buttonConnect(control As IRibbonControl)
    Select Case SheetName(ActiveWorkbook.ActiveSheet)
    Case "Server & Applikationen"
        HardwareAssignment
    
    End Select

End Sub

'Callback for customButtonPaste onAction
Sub buttonPaste(control As IRibbonControl)
    On Error Resume Next
    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _
        :=False, Transpose:=False
    On Error GoTo 0
End Sub

Sub buttonOpen(control As IRibbonControl)
    frmOpen.Show vbModal
End Sub

'Callback for customButtonBusinessCaseDlg onAction
Sub buttonBusinessCaseDlg(control As IRibbonControl)
    frmGeneral.txtBuchblatt = Range("projektdatenBuchblatt").Value
    frmGeneral.txtEreignisdatum = Range("projektdatenEreignisdatum").Value
    frmGeneral.txtGFType = Range("bestandslisteGeschaeftsfalltype").Value
    frmGeneral.txtGFNr = Range("bestandslisteGeschaeftsfallNummer").Value
    
    'V4.19
    frmGeneral.cbVertrag.Clear
    frmGeneral.cbVertrag.AddItem "V2 - bis 2014"
    frmGeneral.cbVertrag.AddItem "V3 - ab 2014"
    Dim nVersion As Long
    nVersion = 2
    On Error Resume Next
    nVersion = CLng(Mid(Range("projektdatenVertragsversion"), 2, 2))
    frmGeneral.cbVertrag.ListIndex = nVersion - 2
    On Error GoTo 0
    
    
    
    frmGeneral.Show vbModal
    
    If frmGeneral.nRet = 1 Then
        Range("projektdatenBuchblatt").Value = frmGeneral.txtBuchblatt
        Range("projektdatenEreignisdatum").Value = frmGeneral.txtEreignisdatum
        Range("bestandslisteGeschaeftsfalltype").Value = frmGeneral.txtGFType
        Range("bestandslisteGeschaeftsfallNummer").Value = frmGeneral.txtGFNr
        
        
        On Error Resume Next
        
        'V4.19
        Range("projektdatenVertragsversion") = frmGeneral.cbVertrag.text
        
        Dim r As IRibbonUI
        Set r = GetRibbon
        r.Invalidate
        On Error GoTo 0
    End If

End Sub

'callback for customButtonNavigateInput
Sub buttonNavigateInput(control As IRibbonControl)
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.Worksheets
        If (sh.Range(sSheetID) = "CITInput") Or (sh.Range(sSheetID) = "CITVisibleInput") Then
            sh.Activate
            Exit Sub
        End If
    Next

End Sub

'callback for customButtonNavigateExport
Sub buttonNavigateExport(control As IRibbonControl)
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.Worksheets
        If sh.Range(sSheetID) = "CITErzeugen" Then
            sh.Activate
            Exit Sub
        End If
    Next
End Sub

'callback for customButtonNavigatePrevious
Sub buttonNavigatePrevious(control As IRibbonControl)
    Dim sh As Worksheet
    Set sh = ActiveSheet

    Do Until sh.Previous Is Nothing
        If sh.Previous.visible = True Then
            sh.Previous.Activate
            Exit Do
        End If
        Set sh = sh.Previous
    Loop
    
End Sub

'callback for customButtonNavigateNext
Sub buttonNavigateNext(control As IRibbonControl)
    Dim sh As Worksheet
    Set sh = ActiveSheet

    Do Until sh.Next Is Nothing
        If sh.Next.visible = True Then
            sh.Next.Activate
            Exit Do
        End If
        Set sh = sh.Next
    Loop
    
End Sub

'Callback for customButtonRowInsert onAction
Sub buttonCMDB(control As IRibbonControl)
    OpenCMDB
End Sub

'Callback for customButtonRowInsert onAction
Sub buttonPK(control As IRibbonControl)
    PKEdit
End Sub


'Callback for customButtonRowInsert onAction
Sub buttonRowInsert(control As IRibbonControl)

    Dim r As Range
    Set r = Selection
    Dim i As Integer
    If InsertAllowed2(r.rows(1).EntireRow) Then

        For i = 1 To r.rows.Count
            r.rows(1).EntireRow.Insert
        Next
    Else
        Beep
    End If

End Sub


'Callback for customButtonRowDelete onAction
Sub buttonRowDelete(control As IRibbonControl)
    Dim bDeleted As Boolean
    Dim r As Range
    Set r = Selection
    Dim i As Integer
    For i = r.rows.Count To 1 Step -1
        If DeleteAllowed2(r.rows(i).EntireRow) Then
            r.rows(i).EntireRow.Delete
            bDeleted = True
        End If
    Next
    If Not bDeleted Then
        Beep
    End If

End Sub



'Gibt die Tabellenblatt ID zur|fffd|ck die sich auf vorbereiteten Bl|fffd|ttern in der Zelle A1 befindet
Public Function GetSheetID() As String
    GetSheetID = ActiveSheet.Range(sSheetID)
End Function



'Callback FUnktion die steuert ob ein Control des Ribbons enabled ist
Sub getenabledButton(control As IRibbonControl, ByRef returnedVal)
    If Not IsCurrentWorkbookUsable Then
        returnedVal = False
        Exit Sub
    End If
    
    Select Case control.id
    Case "customButtonNavigateInput"
        returnedVal = True
    
    Case "customButtonNavigatePrevious"
        If Not IsFirstVisibleSheet Then returnedVal = True
            
    Case "customButtonNavigateExport"
        If (Range("StartMode") = "CMDB-Pflege") Or (Range("StartMode") = "Design") Then returnedVal = True
        
        
    Case "customButtonRefreshAllData"
        On Error Resume Next
        Dim r As Range
        Set r = Range("cisettingsDBStatements")
        On Error GoTo 0
        If Not r Is Nothing Then
            If r.Cells(1, 1) <> "" Then
                returnedVal = True
            End If
        End If
        
    Case "customButtonRefreshData"
        On Error Resume Next
        Set r = Range("cisettingsDBStatements")
        On Error GoTo 0
        If Not r Is Nothing Then
            Dim i As Long
            i = 1
            If TypeName(ActiveWorkbook.ActiveSheet) = "Worksheet" Then
            
                While r.Cells(i, 4) <> ""
                    If r.Cells(i, 4) = SheetName(ActiveWorkbook.ActiveSheet) Then
                        returnedVal = True
                    End If
                    
                    i = i + 1
                Wend
            End If
        
        End If
        
    Case "customButtonNavigateNext"
        If Not IsLastVisibleSheet Then returnedVal = True
    
    Case "customButtonRowInsert"
        If InsertAllowed2(Selection.EntireRow) Then returnedVal = True
    Case "customButtonRowDelete"
        If DeleteAllowed2(Selection.EntireRow) Then returnedVal = True
    Case "customButtonVorerfassungClear"
        If ActiveWorkbook.ActiveSheet.Range(sSheetID) = "CITVorerfassung" Then returnedVal = True
    
    Case "customButtonVorerfassungImport"
        If GetSheetID = "CITVorerfassung" Then returnedVal = True
    
    Case "customButtonExportRun"
        If GetSheetID = "CITErzeugen" Or GetSheetID = "CITL|fffd|schen" Or GetSheetID = "CITVerbindungen" Or GetSheetID = "CITEigenschaften" Or GetSheetID = "CITTracking" Then returnedVal = True
    Case "customButtonExportCommit"
        If GetSheetID = "CITErzeugen" Or GetSheetID = "CITL|fffd|schen" Or GetSheetID = "CITVerbindungen" Or GetSheetID = "CITEigenschaften" Or GetSheetID = "CITTracking" Then returnedVal = True
    Case "customEditGFNo"
        returnedVal = True
    Case "customEditDate"
        returnedVal = True
    Case "customButtonBusinessCaseDlg"
        returnedVal = True
    Case "customButtonToolsClear"
        returnedVal = True
    Case "customButtonToolsUpgrade"
        returnedVal = True
    Case "customButtonToolsUnLock"
        returnedVal = True
    Case "customButtonToolsLock"
        returnedVal = True
    Case "customButtonRecalculate"
        returnedVal = True
    Case "customButtonToolsResetVars", "customButtonStopMacros"
        If (Range("StartMode") = "Design") Then returnedVal = True
    Case "customComboMode"
        returnedVal = True
    Case "customButtonCMDB"
        returnedVal = True
    Case "customButtonPK"
        returnedVal = True
        
    Case "customButtonAutoConnect"
        'Muss f|fffd|r spezielle Arbeitsmappen/Bl|fffd|tter ausprogrammiert werden
        If (GetSheetID = "CITInput") And (SheetName(ActiveWorkbook.ActiveSheet) = "Server & Applikationen") Then
            returnedVal = True
        Else
        
        End If
    End Select

End Sub

'callback for customButtonRecalculate onAction
Sub buttonReCalculate(control As IRibbonControl)
    If IsCurrentWorkbookUsable Then
        NeuBerechnen
    End If

End Sub

'callback for customButtonResetVar onAction
Sub buttonResetVar(control As IRibbonControl)
    On Error Resume Next
    colRangeTitleCollections.Remove ActiveWorkbook.Name
    bAutomaticStopAutoMacros = False
End Sub

'callback for customButtonStopMacro onAction
Sub buttonStopMacros(control As IRibbonControl)
    bAutomaticStopAutoMacros = True
    
End Sub


'callback for customButtonVersion onAction
Sub buttonVersion(control As IRibbonControl)
    Dim nRet As Long
    
    MsgBox "CMDB Import Toolkit Version " & sVersion & ". Die aktuelle Arbeitsmappe ist f|fffd|r die Verwendung dieses Addins " & IIf(IsCurrentWorkbookUsable(nRet), "", "NICHT ") & " geeignet.", vbInformation + vbOKOnly
    Select Case nRet
    Case 0
    Case 1
        MsgBox "Die aktuelle Arbeitsmappe ist nicht f|fffd|r die Verwendung des Toolkit Add-Ins vorbereitet", vbExclamation
    Case 2
        MsgBox "Die aktuelle Arbeitsmappe wird von dieser Version des AddIns nicht mehr unterst|fffd|tzt. Bitte f|fffd|hren Sie ein Update der Arbeitsmappe durch.", vbExclamation
    Case 3
        MsgBox "Diese verwendete AddIn Version ist veraltet. Bitte verwenden Sie eine aktuelle Version des Add-Ins", vbExclamation
    Case 4
        MsgBox "In der Arbeitsmappe sind die Makros deaktiviert", vbExclamation
    End Select
    
End Sub

'callback for customUI onLoad, Variable zum ribbon speichern
Sub OnLoadRibbon(ribbon As IRibbonUI)
   ' Store pointer to IRibbonUI
   Dim lngRibPtr As LongPtr
    ' Store the custom ribbon UI Id in a static variable.
    ' This is done once during load of UI. I.e. during workbook open.
    Set rib = ribbon
    lngRibPtr = ObjPtr(ribbon)
    ' Write pointer to worksheet for safe keeping
    Tabelle1.Range("A1").Value = lngRibPtr
End Sub


Function GetRibbon() As Object
    If rib Is Nothing Then
    
        If bProgramMode Then
            Dim lngRibPtr As LongPtr
            lngRibPtr = Tabelle1.Cells(1, 1).Value
            If lngRibPtr <> 0 Then
                Debug.Print lngRibPtr
                Dim objRibbon As Object
                CopyMemory objRibbon, lngRibPtr, Len(lngRibPtr)
                Set GetRibbon = objRibbon
                Set rib = objRibbon
                Set objRibbon = Nothing
            End If
        End If
    Else
        Set GetRibbon = rib
    End If
End Function

Public Sub WorkbookChanged()

    On Error Resume Next
    Dim r As IRibbonUI
    Set r = GetRibbon
    r.Invalidate
    On Error GoTo 0
End Sub


Public Sub WorkbookClose(sName As String)
    If ExistInCol(colRangeTitleCollections, sName) Then
        colRangeTitleCollections.Remove sName
        Set colRangeTitles = Nothing
    End If
End Sub


Public Sub SheetChanged()
    On Error Resume Next
    Dim r As IRibbonUI
    Set r = GetRibbon
    r.Invalidate
    On Error GoTo 0
End Sub

Public Sub CellPosChanged()
    On Error Resume Next
    Dim r As IRibbonUI
    Set r = GetRibbon
    r.Invalidate
    On Error GoTo 0
End Sub

Private Function IsFirstVisibleSheet() As Boolean
    Dim sheet As Worksheet
    Set sheet = ActiveWorkbook.ActiveSheet
    Set sheet = sheet.Previous
    While Not sheet Is Nothing
        If sheet.visible = xlSheetVisible Then
            IsFirstVisibleSheet = False
            Exit Function
        End If
        Set sheet = sheet.Next
    Wend
    IsFirstVisibleSheet = True

End Function


Private Function IsLastVisibleSheet() As Boolean
    Dim sheet As Worksheet
    Set sheet = ActiveWorkbook.ActiveSheet
    Set sheet = sheet.Next
    While Not sheet Is Nothing
        If sheet.visible = xlSheetVisible Then
            IsLastVisibleSheet = False
            Exit Function
        End If
        Set sheet = sheet.Next
    Wend
    IsLastVisibleSheet = True

    
    
End Function


'Liefert true zur|fffd|ck wenn das aktuelle Workbook zumindest die angegebene Version hat
Function MinVersionCheck(nCheckVersion As Long, Optional nCheckMajor As Long = 0, Optional nCheckMinor As Long = 0) As Boolean
    
    Dim nWBVersion As Long
    Dim nWBVersionMajor As Long
    Dim nWBVersionMinor As Long
    nWBVersion = Range("startVersion")
    nWBVersionMajor = Range("startVersionMajor")
    nWBVersionMinor = Range("startVersionMinor")

    MinVersionCheck = True
    If nWBVersion > nCheckVersion Then
        Exit Function
    ElseIf nWBVersion = nCheckVersion Then
        If nWBVersionMajor > nCheckMajor Then
            Exit Function
        ElseIf nWBVersionMajor = nCheckMajor Then
            If nWBVersionMinor >= nCheckMinor Then
                Exit Function
            End If
        End If
    End If
    MinVersionCheck = False
End Function


Private Function IsCurrentWorkbookUsable(Optional ByRef nRet As Long = 0) As Boolean
    On Error Resume Next
    If Not ExistInCol(Application.ActiveWorkbook.Worksheets, "CI-Settings") Then
        IsCurrentWorkbookUsable = False
        nRet = 1
        Exit Function
    End If
    
    Dim nWBVersion As Long
    Dim nWBVersionMajor As Long
    Dim nWBVersionMinor As Long
    Dim nMinAddinVersion As Long
    Dim nMinAddinVersionMajor As Long
    Dim nMinAddinVersionMinor As Long
    
    nWBVersion = Range("startVersion")
    nWBVersionMajor = Range("startVersionMajor")
    nWBVersionMinor = Range("startVersionMinor")
    nMinAddinVersion = Range("startMinAddinVersion")
    nMinAddinVersionMajor = Range("startMinAddinVersionMajor")
    nMinAddinVersionMinor = Range("startMinAddinVersionMinor")
    
    
    If nWBVersion < nIgnoreBelowVersion Then
        IsCurrentWorkbookUsable = False
        nRet = 1
        Exit Function
    End If
    
    If CompareVersion(nWBVersion, nWBVersionMajor, nWBVersionMinor, nMinWBVersion, nMinWBVersionMajor, nMinWBVersionMinor) < 0 Then
        IsCurrentWorkbookUsable = False
        nRet = 2
        Exit Function
    End If

    If CompareVersion(nVersion, nVersionMajor, nVersionMinor, nMinAddinVersion, nMinAddinVersionMajor, nMinAddinVersionMinor) < 0 Then
        IsCurrentWorkbookUsable = False
        nRet = 3
        Exit Function
    End If
    
    On Error Resume Next
    Application.Run ("'" & ActiveWorkbook.Name & "'!MacroPing")
    If Err.number = 0 Then
        IsCurrentWorkbookUsable = True
    Else
        IsCurrentWorkbookUsable = False
        nRet = 4
        Exit Function
    End If
    
    On Error GoTo 0
End Function



'Callback for customEditGFNo getText
Sub gettextGFNo(control As IRibbonControl, ByRef returnedVal)
    If IsCurrentWorkbookUsable Then
        returnedVal = "" & Range("bestandslisteGeschaeftsfallNummer")
    End If
    
End Sub

'Callback for customEditGFNo onChange
Sub editboxGFNo(control As IRibbonControl, text As String)
    If IsCurrentWorkbookUsable Then
        Range("bestandslisteGeschaeftsfallNummer") = text
    End If
End Sub

'Callback for customEditDate getText
Sub getTextDate(control As IRibbonControl, ByRef returnedVal)
    If IsCurrentWorkbookUsable Then
        returnedVal = "" & Range("projektdatenEreignisdatum")
    End If

End Sub

'Callback for customEditDate onChange
Sub editboxDate(control As IRibbonControl, text As String)
    If IsCurrentWorkbookUsable Then
        Range("projektdatenEreignisdatum") = text
    End If

End Sub

'Callback for customComboMode getText
Sub gettextMode(control As IRibbonControl, ByRef returnedVal)
    If IsCurrentWorkbookUsable Then
        returnedVal = "" & Range("startMode")
    Else
        returnedVal = "Datenerfassung"
    End If
End Sub


'Callback for customComboMode onAction
Sub comboboxMode(control As IRibbonControl, id As String, index As Integer)
    If IsCurrentWorkbookUsable Then
        Range("startMode") = id
        On Error Resume Next
        Dim r As IRibbonUI
        Set r = GetRibbon
        r.Invalidate
        On Error GoTo 0
    End If
End Sub

'Callback for customButtonVorerfassungClear onAction
Sub buttonVorerfassungClear(control As IRibbonControl)
    CheckAccess
    ClearVorerfassung
End Sub

'Callback for customButtonVorerfassungImport onAction
Sub buttonVorerfassungImport(control As IRibbonControl)
    CheckAccess
    UebernahmeVorerfassung2 ActiveWorkbook
End Sub

'Callback for customButtonRefreshData onAction
Sub buttonRefreshData(control As IRibbonControl)
    RefreshDatabase
End Sub

'Callback for customButtonRefreshhAllData onAction
Sub buttonRefreshAllData(control As IRibbonControl)
    RefreshDatabaseAll
End Sub



'Callback for customButtonExportRun onAction
Sub buttonExportRun(control As IRibbonControl)
    Debug.Print ActiveWorkbook.ActiveSheet.Range(sSheetID).Value
    Select Case ActiveWorkbook.ActiveSheet.Range(sSheetID).Value
    Case "CITErzeugen"
        DoExport ActiveWorkbook
    Case "CITL|fffd|schen"
        RefreshRefCounts ActiveWorkbook
        DeleteCIs ActiveWorkbook
        
        'V4.18
        ExportDeletes ActiveWorkbook
        
    Case "CITVerbindungen"
        GetConnections ActiveWorkbook
        Buchblatt ActiveWorkbook
    Case "CITEigenschaften"
        ExportProperties ActiveWorkbook
    Case "CITTracking"
        GetTracking
        ExportTracking ActiveWorkbook
    End Select
End Sub

'Callback for customButtonExportCommit onAction
Sub buttonExportCommit(control As IRibbonControl)
    Select Case ActiveWorkbook.ActiveSheet.Range(sSheetID).Value
    Case "CITErzeugen"
        RefreshCINumbers ActiveWorkbook
    Case "CITL|fffd|schen"
        ConfirmDelete ActiveWorkbook
    Case "CITVerbindungen"
        SaveConnections ActiveWorkbook
    Case "CITEigenschaften"
        SaveProperties ActiveWorkbook
    Case "CITTracking"
        SaveTracking ActiveWorkbook
    
    End Select

End Sub


'Callback for customButtonToolsClear onAction
Sub buttonClear(control As IRibbonControl)
    If MsgBox("M|fffd|chten Sie wirklich den gesament Inhalt der Arbeitsmappe l|fffd|schen?", vbYesNo + vbQuestion) = vbYes Then
        CheckAccess
        ClearAll
    End If

End Sub

'Callback for customButtonToolsUpgrade onAction
Sub buttonUpgrade(control As IRibbonControl)
    If MsgBox("M|fffd|chten Sie wirklich den Inhalt einer anderen geladen Arbeitsmappe |fffd|bernehmen? Dabei wird der gesamte Inhalt dieser Arbeitsmappe entfernt!", vbYesNo + vbQuestion) = vbYes Then
        CheckAccess
        Import
    End If

End Sub

'Callback for customButtonToolsLock onAction
Sub buttonLock(control As IRibbonControl)
    ManualLock
End Sub

'Callback for customButtonToolsUnLock onAction
Sub buttonUnlock(control As IRibbonControl)
    ManualUnlock
End Sub


'V3.9
Sub CopyString(s As String)


    Dim obj As New DataObject
    obj.SetText s
    obj.PutInClipboard
    DoEvents
    Dim s1 As String
    Dim obj1 As New DataObject
    obj1.GetFromClipboard
    s1 = obj1.GetText
    
    If s1 <> s Then
        Dim r As Range
        Set r = Range("settingsevaluate")
        r.Cells = s
        r.Copy
    End If
End Sub
Attribute VB_Name = "modVersion"
'V3.5 Unterst|fffd|tzt bei den Verbindungsdefinitionen in GUID1 die angabe von mehreren Alternativen durch Beistrich getrennt
'V3.6 Erm|fffd|glicht es im Pflege Modus zus|fffd|tzliche Bl|fffd|tter einzublenden
'V3.7 Erm|fffd|glicht das Filtern von Verbindungen auf den CI-Type des Kind-CIs abh|fffd|ngig vom Property Wert es Vaters. Notwendig f|fffd|r KSI-SLM Verbindungen
'V3.8 CI-Tracking zum Bef|fffd|llen des GF-Reiters. Erstmals notwendig f|fffd|r Std-GF Mediaprint
'     Bugfix: Wenn die berechnete Verbindungsmenge "" zur|fffd|ckgibt kommt ein Fehler -> es muss 0 angenommen werden
'     Performance Verbesserung: Lookups nur dann aktualisieren, wenn Felder betroffen sind die auf den Lookup Einfluss haben.
'     Einzelne Bl|fffd|tter k|fffd|nnen durch mehrere Optionen geschalten werden (z.B: Lizenzverbrauch f|fffd|r SPLA und Lizenz Management)
'v3.9 Pfade von Export Dateien werden automatisch in die Zwischenablage geschrieben
'V3.10=4.0 Support f|fffd|r die Aktualisierung externe Datenquellen via ADO
'V4.01.00 |fffd|ndern von Debitor und Anlagenprojekt, Generieren von CIs je Anlagenprojekt
'V4.02.00 Unterst|fffd|tzung f|fffd|r Import-Aufruf aus BulkMigrate.xlsm
'V4.03.00 Ereignisdatum wird beim Erzeugen von CIs korrekt bespielt
'V4.04.00 Beim erzeugen mehrere CIs wird aus Performancegr|fffd|nden nur 1x die n|fffd|chste freie Position der Bestandsliste ermittelt
'V4.05.00 Export unterst|fffd|tzt CMDB-Vorerfassung-V3, Eingabehilfe f|fffd|r Produktkatalog
'V4.06.00 Bugfix
'V4.07.00 Leere Zeilen werden von Spalte 2-9 gepr|fffd|ft (bisher 2-6)
'V4.08.00 Bugfix
'V4.09.00 scho wieder a Bugfix
'V4.10.00 aber jetzt! (Bugfix)
'V4.11.00 Arbeiten mit externen Excel Erfassungssheets,
'           Bestandsliste braucht das Feld DefNr
'V4.12.00 Kann damit umgehen, dass sich beim Import der CI-Type |fffd|ndert, Es werden dazu die zul|fffd|ssigen CI-Type in der Definition durch "|" getrennt
'V4.13.00 Unterst|fffd|tzt das Bef|fffd|llen von Kommentar-Vertragsverwaltung beim Initialen Export
'           Bestandsliste braucht das Feld Kommentar-VVW
'V4.14.00 Bugfix
'V4.15.00 Bugfix
'V4.16.00 CI-Type "*" zul|fffd|ssig wenn dieser |fffd|ber den Artikelstamm vergeben wird
'V4.17.00 Bugfix
'V4.18.00 L|fffd|schen kann exportieren!
'V4.19.00 Anpassungen f|fffd|r Nav2016
'V4.20.00 Aufrufe f|fffd|r Nav2016
'V4.21.00 Access-Denied Fehler
'V4.22.00 DB-Zugriffe k|fffd|nnen nicht aus dem Range schreiben
'V4.23.00 Aktuelle Verbindungen aus dem DWH-Lesen
'V4.24.00 Bugfix
'V4.25.00 Bugfix



Public Const sVersion = "4.24.00"
Public Const nVersion = 4
Public Const nVersionMajor = 24
Public Const nVersionMinor = 0

Public Const nMinWBVersion = 3
Public Const nMinWBVersionMajor = 3
Public Const nMinWBVersionMinor = 0

Public Const nIgnoreBelowVersion = 3
          



' InQuest injected base64 decoded content
' -jwl
' +-xg
' -jwl
' +-x	
' tZ+E
' tZ+E
' -jwe
' #zK]j
' #zK]j
' #zK[{7
' #zK]j
' N+ex*%
' x,"jh
' x,"jh
' x,"jh
' x,"jh
' x,"jh
' bzWS
' x,"jh
' bzWS
' #zK]j

INQUEST-PP=macro
