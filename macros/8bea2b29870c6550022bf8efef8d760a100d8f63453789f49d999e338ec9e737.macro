Attribute VB_Name = "Class1"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents App As Application 'Esta class s|fffd| necessita ser criada quando trabalhando Application.EnableEvents=True
Attribute App.VB_VarHelpID = -1

Private Sub App_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    If Val(Application.Version) >= 15 Then WinSDIverifRibbon: WinSDIalinhSetAll Else Wn.WindowState = xlMaximized  'No Excel 2013 SDI a janela do Wb est|fffd| sempre maximizada internamente assim nao |fffd| mais necessario ficar maximizando, mas vou aproveitar o evento para verificar ribbon e alinhar janela rapidamente.
End Sub

Private Sub App_WorkbookOpen(ByVal Wb As Workbook)
    If Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then Exit Sub
    'Stop
    Wb.Activate
    If Wb.Name = ActiveWorkbook.Name Then
        If Application.ExecuteExcel4Macro("GET.WORKSPACE(71)") Then
            Application.Run "cpap_pri.mac!InPlaceExit"
        Else
            Application.Run "cpap_pri.mac!Exclusivo"    'Cpap s|fffd| abre ev disable
        End If
        If Val(Application.Version) >= 12 Then Application.ExecuteExcel4Macro ("SHOW.TOOLBAR(""Ribbon"",TRUE)")  'CommandBars("Ribbon").Visible = True parece bug
    Else
        Application.Run "cpap_pri.mac!Inst.incor"
    End If

    '    If Wb.IsAddin Then
    '        If Val(Application.Version) >= 12 Then If Wb.FullName = ThisWorkbook.Path & "\cpap.xlam" Then Exit Sub
    '        Wb.Activate
    '        If Wb.Name = ActiveWorkbook.Name Then
    '            Application.Run "cpap_pri.mac!Exclusivo"   'O cpap n|fffd|o tem Add-in
    '            If Val(Application.Version) >= 12 Then Application.ExecuteExcel4Macro ("SHOW.TOOLBAR(""Ribbon"",TRUE)")  'CommandBars("Ribbon").Visible = True parece bug
    '            Exit Sub
    '        Else
    '            Application.Run "cpap_pri.mac!Inst.incor"
    '        End If
    '    End If
    '
    '    If Wb.Windows(1).Visible = False Then
    '        If sVerBuild = "9.02719" Then Exit Sub 'Existe instabilidade na 1|fffd| vers|fffd|o do 2000 que perda de retorno
    '        If Wb.FullName = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirBD").Value) & "\banco\cpap-ind.xls" Then Exit Sub
    '        Wb.Activate
    '        On Error Resume Next
    '        Dim i As Boolean
    '        i = Application.ExecuteExcel4Macro("OR(NAMES(,3)=""DirP"")") _
             '                Or Application.ExecuteExcel4Macro("OR(NAMES(,3)=""DadosHist"")")
    '        If Err.Number <> 0 Then Exit Sub
    '        If Not i Then Application.Run "cpap_pri.mac!Exclusivo"  'Identf Wb oculto por nomes
    '    End If
End Sub

Attribute VB_Name = "EstaPasta_de_trabalho"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True



















Attribute VB_Name = "FormFresumo"
Attribute VB_Base = "0{721B5E28-8D26-4871-AD01-D58349CF2956}{AC02D587-0DA6-4868-BB3B-FAF932F8EF44}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub Contiuar_Bt_Click()
    BotAcionado = 1
    Unload Me
End Sub

Private Sub Cancelar_Bt_Click()
    Unload Me
End Sub

Private Sub Image1_Click()
    BotAcionado = 1
    Unload Me
End Sub

Private Sub UserForm_Activate()
    Top = Application.Top + 23
    Left = Application.Left + 5

    'WMF tem zoom maior que o original com um pouco de distor|fffd||fffd|o. J|fffd| o BMP n|fffd|o, mas pega muito
    'espa|fffd|o no disco. O melhor |fffd| corrigir o zoom do WMF aqui.
    Image1.AutoSize = True
    Image1.PictureSizeMode = fmPictureSizeModeClip
    razWidHigh = Image1.Width / Image1.Height

    Image1.AutoSize = False
    Image1.PictureSizeMode = fmPictureSizeModeZoom
    Image1.Width = 336.75    'Peguei essa largura ao salvar como BMP
    Image1.Height = Image1.Width / razWidHigh

    Height = Image1.Top + Image1.Height + 28
    Width = Image1.Left * 2 + Image1.Width + 3
    Contiuar_Bt.Left = Width / 2 - 87
    Cancelar_Bt.Left = Contiuar_Bt.Left + 111
    WhatsThis_Img.Top = -50: If bHtmlHelp And HelpContextID <> 0 Then WhatsThis_Img.Top = -1: WhatsThis_Img.Left = Width - 10
End Sub

Private Sub WhatsThis_Img_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    Static cHHelpWhatsThis1 As cHHelpWhatsThis
    If cHHelpWhatsThis1 Is Nothing Then Set cHHelpWhatsThis1 = New cHHelpWhatsThis
    cHHelpWhatsThis1.WhatsThis_Img_MouseDown Button, Shift, x, y, Me
    If WhatsThis_Img.BackStyle = fmBackStyleOpaque Then Set cHHelpWhatsThis1 = Nothing
End Sub


Attribute VB_Name = "FormOpT"
Attribute VB_Base = "0{1961CF81-97FC-4156-B450-0198C716A8A7}{EEB8C002-2FF0-4784-AA2B-F44360786581}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public lBut As Long
Public xPos As Long
Public yPos As Long

Private Sub OK_Bt_Click()
    BotAcionado = 1
    Hide
End Sub

Private Sub Option1_Lb_Click()
    FlashCtrl Option1_Lb
    BotAcionado = 1
    Hide
End Sub

Private Sub Option2_Lb_Click()
    FlashCtrl Option2_Lb
    BotAcionado = 2
    Hide
End Sub

Private Sub Option3_Lb_Click()
    FlashCtrl Option3_Lb
    BotAcionado = 3
    Hide
End Sub

Private Sub Option4_Lb_Click()
    FlashCtrl Option4_Lb
    BotAcionado = 4
    Hide
End Sub

Sub FlashCtrl(Ctrl As Object)
    Ctrl.Visible = False
    DoEvents
    '    If Application.CanPlaySounds Then Call sndPlaySound32(WavFile, &H1)
    Ctrl.Visible = True
End Sub

Private Sub UserForm_Activate()
    GetLabelSize Option1_Lb
    GetLabelSize Option2_Lb
    GetLabelSize Option3_Lb
    GetLabelSize Option4_Lb

    Option2_Lb.Top = Option1_Lb.Top + IIf(Option2_Lb.Visible, Option1_Lb.Height + 8, 0)
    Option3_Lb.Top = Option2_Lb.Top + IIf(Option3_Lb.Visible, Option2_Lb.Height + 8, 0)
    Option4_Lb.Top = Option3_Lb.Top + IIf(Option4_Lb.Visible, Option3_Lb.Height + 10, 0)
    Height = Option4_Lb.Top + Option4_Lb.Height + (Height - InsideHeight - (Width - InsideWidth) / 2) + 2 + 5  'Entre parentese: altura da barra de t|fffd|tulo(caption)

    GetCaptSize_Lb.Caption = Caption
    Do While Option1_Lb.Width <> Option2_Lb.Width Or Option2_Lb.Width <> Option3_Lb.Width Or Option3_Lb.Width <> Option4_Lb.Width Or Option1_Lb.Width < GetCaptSize_Lb.Width + 8
        If Option1_Lb.Width < GetCaptSize_Lb.Width + 8 Then Option1_Lb.Width = GetCaptSize_Lb.Width + 8

        If Option1_Lb.Width < Option2_Lb.Width Then Option1_Lb.Width = Option2_Lb.Width
        If Option2_Lb.Width < Option3_Lb.Width Then Option2_Lb.Width = Option3_Lb.Width
        If Option3_Lb.Width < Option4_Lb.Width Then Option3_Lb.Width = Option4_Lb.Width
        If Option4_Lb.Width < Option1_Lb.Width Then Option4_Lb.Width = Option1_Lb.Width
    Loop
    Width = Option1_Lb.Width + Option1_Lb.Left * 2 + 5

    'Se o Excel n|fffd|o aceitar muito pequeno
    If Width > Option1_Lb.Width + Option1_Lb.Left * 2 + 5 Then
        Option1_Lb.Width = Width - (Option1_Lb.Left * 2 + 5)
        Option2_Lb.Width = Option1_Lb.Width
        Option3_Lb.Width = Option1_Lb.Width
        Option4_Lb.Width = Option1_Lb.Width
    End If

    OK_Bt.Top = Height + 20
    GetCaptSize_Lb.Top = OK_Bt.Top
    WhatsThis_Img.Top = -50: If bHtmlHelp And HelpContextID <> 0 Then WhatsThis_Img.Top = -1: WhatsThis_Img.Left = Width - 10
End Sub

Sub GetLabelSize(sCtrlLb As Object)
    Dim CountLines As Long
    Dim Lins
    Dim L As Long
    With sCtrlLb
        .AutoSize = True
        If Len(.Caption) = 0 Then
            .Visible = False
            .Width = 1
        Else
            If .Width > 284 Then
                .Width = 284
                'Lins = Split(.Text, vbCrLf)
                Lins = MySplit(.Caption, vbCrLf)
                For L = 0 To UBound(Lins)
                    CountLines = CountLines + 1 + Int(Len(Lins(L)) / 75)
                Next
                .Height = (1 + CountLines) * 12
                .WordWrap = True
            End If
        End If
        .AutoSize = False
        .Height = .Height + 2    'Melhorar est|fffd|tica
    End With
End Sub


Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'    If CloseMode = 0 Then BotAcionado = IIf(Cancel_Bt.Visible, 2, 1)
    If CloseMode = 0 Then Cancel = 1
End Sub


Function MySplit(ByVal sString As String, Optional sDelim As String, Optional lLimit As Long = -1, Optional bCompare As Long = 0) As Variant
'Excel 97 and Word6 haven't Split function
    Dim sSplitArr() As String
    Dim lPos As Long
    Dim i As Long
    Dim R As Long

    If sString = "" Or lLimit = 0 Then
        MySplit = Array()
        Exit Function
    End If

    If sDelim = "" Then
        ReDim Preserve sSplitArr(i)
        sSplitArr(i) = sString
    Else
        lPos = InStr(1, sString, sDelim, bCompare)
        If lPos = 0 Then
            ReDim Preserve sSplitArr(i)
            sSplitArr(i) = sString
        Else
            R = 2
            Do
                ReDim Preserve sSplitArr(i)
                If R > 1 Then
                    sSplitArr(i) = Left(sString, lPos - 1)
                    sString = Mid(sString, lPos + Len(sDelim))
                Else
                    sSplitArr(i) = sString
                    sString = ""
                End If
                lPos = InStr(1, sString, sDelim, bCompare)
                R = R - 1 - 1 * (lPos > 0)
                If lLimit <> -1 And i = lLimit - 1 Then
                    sSplitArr(i) = sSplitArr(i) & IIf(R > 0, sDelim & sString, "")
                    Exit Do
                End If
                i = i + 1
            Loop While R > 0
        End If
    End If
    MySplit = sSplitArr
End Function

Private Sub WhatsThis_Img_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    Static cHHelpWhatsThis1 As cHHelpWhatsThis
    If cHHelpWhatsThis1 Is Nothing Then Set cHHelpWhatsThis1 = New cHHelpWhatsThis
    cHHelpWhatsThis1.WhatsThis_Img_MouseDown Button, Shift, x, y, Me
    If WhatsThis_Img.BackStyle = fmBackStyleOpaque Then Set cHHelpWhatsThis1 = Nothing
End Sub


Attribute VB_Name = "Mod3Outros"
Declare Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal vKey As Integer) As Integer
Declare Function apiGetTempDir Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Declare Function apiGetSys Lib "user32" Alias "GetSystemMetrics" (ByVal nIndex As Long) As Long
Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Type POINTAPI
    x As Long
    y As Long
End Type
Const SM_CXSCREEN = 0
Const SM_CYSCREEN = 1

Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte, _
        ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As Long)
Const VK_SNAPSHOT = &H2C

Declare Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
Const LOCALE_USER_DEFAULT& = &H400
Const LOCALE_SENGLANGUAGE = &H1001   'English name of language
Const LOCALE_SLANGUAGE = &H2   'localized name of language

Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Private Declare Function SetCurrentDirectory Lib "kernel32" Alias "SetCurrentDirectoryA" (ByVal lpPathName As String) As Long

Dim ExcelObj As Object
Dim WbFundo As Workbook
Public WbM|fffd|dAtivo As String
Dim Mplano As Boolean
Dim Mcont As Boolean
Dim Macomp As Boolean
Dim Dem As Boolean
Dim CopyVrng As Range
Public sVerBuild As String
Public NmesIndMax As Long

Sub VerifVari|fffd|veis()
'Verif. e def. as vari|fffd|veis no |fffd|nicio ou quando houver perda de acordo
'com o guardado nas planilhas. O uso do HALT(), por exemplo causa perda.
    If WbFundo Is Nothing Then
        i = Workbooks("cpap_pri.mac").Sheets(1).Names("Fundo").Value
        i = Application.WorksheetFunction.Substitute(i, "=", "")
        i = Application.WorksheetFunction.Substitute(i, """", "")
        Set WbFundo = Workbooks(i)
        Mplano = Workbooks("cpap_pri.mac").Sheets(1).Range("Mplano").Value
        Mcont = Workbooks("cpap_pri.mac").Sheets(1).Range("Mcont").Value
        Macomp = Workbooks("cpap_pri.mac").Sheets(1).Range("Macomp").Value
        Dem = Workbooks("cpap_pri.mac").Sheets(1).Range("Dem").Value
        sVerBuild = Application.Version & Application.Build

        If Workbooks("cpap_pri.mac").Sheets(1).Range("bEventsOn").Value Then _
                If nCls1.App Is Nothing Then Set nCls1.App = Application 'EnableEventsVBA True    'Para recupera poss|fffd|vel perda de Class1 e j|fffd| ativar os eventos se trabalhando ligado.
    End If
    If WbM|fffd|dAtivo = "" Then WbM|fffd|dAtivo = ThisWorkbook.Sheets(1).Range("WbM|fffd|dAtivo").Value
End Sub

Function fTempFolder()
'Returns Temp Folder Name
    Dim strNameFolder As String
    Dim vSize As Long
    strNameFolder = String$(255, 0)
    vSize = apiGetTempDir(255, strNameFolder)
    If vSize <> 0 Then
        fTempFolder = Left(strNameFolder, vSize + 1 * (Mid(strNameFolder, vSize, 1) = "\"))
    Else
        fTempFolder = ""
    End If
End Function

Function DelOldFile(vPath As String, vFile As String, vDiasOld As Long)
'Exclui arquivos vDiasOld dias mais velho ou mais novo do que agora
    F = Dir(vPath & "\" & vFile)
    On Error Resume Next
    Do While Len(F) > 0
        If Abs(FileDateTime(vPath & "\" & F) - Now) > vDiasOld Then Kill vPath & "\" & F
        F = Dir()
    Loop
End Function

Public Function nFilesVba(vPathFile As String) As Long
'Retorna a quantidade de arquivos em uma pasta. O de cpap_arq.mac |fffd| mais completo
    nFilesVba = 0
    F = Dir(vPathFile)
    Do While Len(F) > 0
        nFilesVba = nFilesVba + 1
        F = Dir()
    Loop
End Function

Public Function MousePos()
'Retorna a posi|fffd||fffd|o do mouse em um array horizontal
    Dim Point As POINTAPI
    Dim MyArray(1)
    Result = GetCursorPos(Point)
    If Result <> 0 Then
        MyArray(0) = Int(Point.x * 0.75)
        MyArray(1) = Int(Point.y * 0.75)
    End If
    MousePos = MyArray
End Function

Function PosX(vW As Single)
'Retorna a posi|fffd||fffd|o horizontal ideal em rela|fffd||fffd|o ao mouse para exib caixa de dia
    vW = vW / 0.75   'Point to pixels
    Rx = apiGetSys(SM_CXSCREEN)
    PosX = MousePos(0) / 0.75
    If PosX > Rx - vW Then PosX = Rx - vW
    If PosX < 0 Then PosX = 0
    PosX = PosX * 0.75   'Pixels to Point
End Function

Function PosY(vH As Single)
'Retorna a posi|fffd||fffd|o vertical ideal em rela|fffd||fffd|o ao mouse para exib caixa de dia
    vH = vH / 0.75   'Point to pixels
    Ry = apiGetSys(SM_CYSCREEN)
    PosY = MousePos(1) / 0.75 - vH / 2   'Centralizar
    If PosY > Ry - vH Then PosY = Ry - vH
    If PosY < 0 Then PosY = 0
    PosY = PosY * 0.75   'Pixels to Point
End Function

Public Function ShiftDown()
'Verif. se shift est|fffd| pressionada
    ShiftDown = (GetKeyState32(16) < 0)
End Function

Public Function CtrlDown()
'Verif se Ctrl est|fffd| pressionada
    CtrlDown = (GetKeyState32(17) < 0)
End Function

Public Sub AjustComent()
'Ajustar Coment|fffd|rios na c|fffd|lula ou c|fffd|lulas selecionadas. Dica! O mais r|fffd|pido |fffd| selecionar s|fffd| as c|fffd|l com comm
    Dim c As Range, lFixA1 As Long
    If Range("A1").Width <> 0 And Range("A1").Height <> 0 And Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then lFixA1 = MsgBox("Editando, gostaria de mover e fixar no top em A1?", vbYesNo, "Depois de Coment|fffd|rios Ajustados")        'Ok mant|fffd|m ou restaura o padr|fffd|o do Excel ao inserir
    For Each c In Selection.Cells
        If Not c.Comment Is Nothing Then    'Salta c|fffd|l sem comm
            c.Comment.Shape.TextFrame.AutoSize = True
            With c.Comment.Shape.TextFrame.Characters.Font
                .Name = "Arial"
                .FontStyle = "Normal"
                .Size = 9
            End With
            c.Comment.Shape.TextFrame.AutoSize = False    'Autosize slow dows zooms
            If lFixA1 <> 0 Then    'N|fffd|o altera se n|fffd|o houver questionamento porque A1 est|fffd| oculta.
                c.Comment.Shape.Left = IIf(lFixA1 = vbYes, Range("A1").Left, c.Left + c.Width + 10)
                c.Comment.Shape.Top = IIf(lFixA1 = vbYes, Range("A1").Top, c.Top - 10)
                c.Comment.Shape.Placement = IIf(lFixA1 = vbYes, xlMove, xlFreeFloating)
            End If
        End If
    Next
End Sub

Public Function ActiveWorkbookSavedVBA() As Boolean
    ActiveWorkbook.Saved = True
    ActiveWorkbookSavedVBA = ActiveWorkbook.Saved
End Function

Public Sub CloseFalse()
'Ao fechar tpr.mac dava GPF, mp.mac dava loop e avu.mac dava Erro desconhecido. Isto resolveu.
    If Val(Application.Version) >= 12 And LCase(ActiveWorkbook.Name) = "cpap_mp.mac" Then    'No 2010 e talvez no 2007 gera gpf em add sheet
        With ActiveWorkbook
            .Saved = True: MyWait 0.1
            .Close False
        End With
    Else
        Application.DisplayAlerts = False
        With ActiveWorkbook
            If Not (Val(Application.Version) >= 12 And LCase(.Name) = "cpap_mp.mac") Then .Sheets.Add .Sheets(1)    'No 2010 e talvez no 2007 gera erro aqui em mp
            While .Sheets.Count > 1
                .Sheets(2).Delete
            Wend
            For Each n In .Names
                n.Delete
            Next
            .Saved = True
            'No excel 97 o tpr.mac continuou o problema. Deixar limpo mas sempre aberto.
            If Not (Val(Application.Version) = 8 And LCase(.Name) = "cpap_tpr.mac") Then .Close False
        End With
        Application.DisplayAlerts = True
    End If
    MyWait 0.1
End Sub

Public Sub Localizar()
Pr|fffd|xima:
'   TextLoc = Application.InputBox("Insira o texto a localizar.", "Localizar", TextLoc)
    UserformLocText.Texto_Ct.Value = ThisWorkbook.Sheets(1).Range("TextLoc").Value
    UserformLocText.Show
    If UserformLocText.BotPress_Tb.Value = 2 Then Exit Sub
    TextLoc = UserformLocText.Texto_Ct.Value
    If TextLoc = "" Or TextLoc = False Then Exit Sub
    ThisWorkbook.Sheets(1).Range("TextLoc").Value = TextLoc
    Set AreaLoc = ActiveWorkbook.ActiveSheet.Range(ActiveWorkbook.ActiveSheet.PageSetup.PrintArea)
    Set AreaLoc = AreaLoc.SpecialCells(xlCellTypeVisible)
    Set C|fffd|lInic = Application.Intersect(AreaLoc, Application.ActiveWindow.ActiveCell)
    On Error GoTo ErroHandler
    If C|fffd|lInic Is Nothing Then
        AreaLoc.Find(What:=TextLoc, LookIn:=xlFormulas, _
                LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
                MatchCase:=False).Activate
    Else
        AreaLoc.Find(What:=TextLoc, After:=C|fffd|lInic, LookIn:=xlFormulas, _
                LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
                MatchCase:=False).Activate
    End If
    GoTo Pr|fffd|xima
ErroHandler:
    MsgBox "Texto n|fffd|o encontrado!", vbOKOnly + vbInformation, "CPAP|fffd|"
    Resume Next
End Sub

Public Function MyEdate(DataI As Single, Nmes As Single) As Single
'O Edate XLM em pri n|fffd|o funciona corretamete se chamado de uma rotina VBA
'diretamente ou indiretamente como na fun|fffd||fffd|o M.F em jap

    If IsError(DataI) Or IsError(Nmes) Then
        'Parece n|fffd|o ser necess|fffd|rio em VBA, pois n|fffd|o passa argumento com erro
        MsgBox "Erro em EDATE. C|fffd|lculo abortado!", vbOKOnly + vbCritical, "Erro!"
        Do: Stop: Loop While True  'Antes End foi o melhor para traduzir RESTART() xlm sem equivalente em VBA, mas no 2010 ao compilar no v|fffd|o o End parece ser executado, talvez um bug junto com o nome reservado Edate, por isso troquei tamb|fffd|m para MyEdate, embora Worksheetfuncion.EDate method exista a partir do 2007
    End If

    'Limites do programa
    If NmesIndMax = 0 Then NmesIndMax = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("NmesIndMax").Value
    If Nmes < -NmesIndMax Or Nmes > NmesIndMax Or DataI < 25569 Or DataI > DateSerial(1970, 5 + NmesIndMax + 9 * 12, 0) Then
        MsgBox "Valores discrepantes em EDATE!" & Chr(10) & "Confira suas inclus|fffd|es.", vbOKOnly + vbCritical, "Erro!"
        If Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value = False Then Stop
        MyEdate = DataI
        Exit Function
    End If

    'Calculando
    vDay = Day(DataI)
    i = Month(DataI) + Nmes
    If i >= 0 Then
        vMonth = i - Int((i - 1) / 12) * 12
        vYear = Year(DataI) + Int((i - 1) / 12)
    Else
        vMonth = (1 - Fix(i / 12)) * 12 + i
        vYear = Year(DataI) - (1 - Fix(i / 12))
    End If
    MyEdate = DateSerial(vYear, vMonth, vDay)

    'Ajustando final de m|fffd|s
    Do While Month(MyEdate) <> vMonth
        vDay = vDay - 1
        MyEdate = DateSerial(vYear, vMonth, vDay)
    Loop
End Function

Public Function MyEomonth(DataI As Single, Nmes As Single) As Single
'Parece n|fffd|o ser necess|fffd|rio em VBA, pois n|fffd|o passa argumento com erro
    If IsError(DataI) Or IsError(Nmes) Then
        MsgBox "Erro em EOMONTH. C|fffd|lculo abortado!", vbOKOnly + vbCritical, "Erro!"
        Do: Stop: Loop While True  'Ver coment|fffd|rio em MyEdate
    End If

    'Limites do programa
    If NmesIndMax = 0 Then NmesIndMax = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("NmesIndMax").Value
    If Nmes < -NmesIndMax Or Nmes > NmesIndMax Or DataI < 25569 Or DataI > DateSerial(1970, 5 + NmesIndMax + 9 * 12, 0) Then
        MsgBox "Valores discrepantes em EOMONTH!" & Chr(10) & "Confira suas inclus|fffd|es.", vbOKOnly + vbCritical, "Erro!"
        If Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value = False Then Stop
        MyEomonth = DataI
        Exit Function
    End If

    'Calculando
    vDate = MyEdate(DataI, Nmes + 1)
    vDay = 0
    vMonth = Month(vDate)
    vYear = Year(vDate)
    MyEomonth = DateSerial(vYear, vMonth, vDay)
End Function

Function GetDriveInfo(Optional sDrvPath As String, Optional sInfType As String)
    Dim fs, d
    On Error GoTo ErrorHandler
    Set fs = CreateObject("Scripting.FileSystemObject")
    If sDrvPath = "" Then sDrvPath = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirPini").Value)    'ThisWorkbook.Path
    Set d = fs.GetDrive(fs.GetDriveName(fs.GetAbsolutePathName(sDrvPath)))
    'DriveType 0:Unknown 1:Removable 2:Fixed 3:Network 4:CD-ROM 5:RAM Disk
    'If sInfType = "DriveType" Then GetDriveInfo = d.DriveType Else If sInfType = "FileSystem" Then GetDriveInfo = d.FileSystem Else GetDriveInfo = d.SerialNumber
    Select Case sInfType
    Case "DriveType"
        GetDriveInfo = d.DriveType & ";  "
    Case "FileSystem"
        GetDriveInfo = d.FileSystem & ";  "
    Case "All", "StrWinDir"
        GetDriveInfo = GetDriveInfo & d.DriveLetter & ";  "
        GetDriveInfo = GetDriveInfo & d.Path & ";  "
        GetDriveInfo = GetDriveInfo & d.DriveType & ";  "    'ShowDriveType(d) & ";  "
        GetDriveInfo = GetDriveInfo & CLng(d.IsReady) & ";  "
        If d.IsReady Then
            If d.DriveType = 3 Then
                GetDriveInfo = GetDriveInfo & d.ShareName & ";  "
            Else
                GetDriveInfo = GetDriveInfo & d.VolumeName & ";  "
            End If
            GetDriveInfo = GetDriveInfo & d.FileSystem & ";  "
            If sInfType = "All" Then GetDriveInfo = GetDriveInfo & d.TotalSize & ";  "
            If sInfType = "All" Then GetDriveInfo = GetDriveInfo & d.FreeSpace & ";  "
            If sInfType = "All" Then GetDriveInfo = GetDriveInfo & d.AvailableSpace & ";  "
            GetDriveInfo = GetDriveInfo & d.SerialNumber    'Hex(d.SerialNumber)
        End If
    Case Else
        GetDriveInfo = d.SerialNumber
    End Select
    Exit Function
ErrorHandler:
    GetDriveInfo = 0
End Function

Function SetValueT(RefD As Range, Txt1 As String, Optional Txt2 As String, Optional Txt3 As String, Optional Txt4 As String)
'Estende o SET.VALUE de XLM para mais de 255 caracteres,
'mas cada argumento Txt n|fffd|o pode ultrapasar 255
'RefD - Refer|fffd|ncia destino deve estar desprotegida
    On Error GoTo ErroHandler
    RefD.Value = Txt1 & Txt2 & Txt3 & Txt4
    SetValueT = True
    Exit Function
ErroHandler:
    RefD.Value = "#VALUE!"
    SetValueT = False
End Function

Function SetValueR(RefD As Range, RefO As Range, Optional NoWrapD As Boolean = False)
'Estende o SET.VALUE de XLM para mais de 255 caracteres.
'RefD - Refer|fffd|ncia destino deve estar desprotegida
'RefO - Refer|fffd|ncia origem pode ser maior que 255
'NoWrapD - Evita a formata|fffd||fffd|o autom|fffd|tica de quebra de linha que acontece quando h|fffd| caracter de retorno no text
    On Error GoTo ErroHandler
    If NoWrapD Then WrapD = RefD.WrapText
    RefD.Value = RefO.Value
    If NoWrapD Then If WrapD = False Then RefD.WrapText = False
    SetValueR = True
    Exit Function
ErroHandler:
    RefD.Value = "#VALUE!"
    SetValueR = False
End Function

Function SetValue(RefD As Range, RefO As Range, Optional vConc As Variant, Optional NoWrapD As Boolean = False)
'Estende o SET.VALUE de XLM para mais de 255 caracteres e, depois de bem testada, vai ser usada no lugar do SetValueR e SetValueT.
'RefD - Refer|fffd|ncia destino deve estar desprotegida
'RefO - Refer|fffd|ncia origem pode ser maior que 255
'vConc - Texto extra a concatenar com o da origem (Neste caso o limite da fun|fffd||fffd|o |fffd| 1329 caracteres de retorno)
'NoWrapD - Evita a formata|fffd||fffd|o autom|fffd|tica de quebra de linha que acontece quando h|fffd| caracter de retorno no text
'    On Error GoTo ErroHandler
    If NoWrapD Then WrapD = RefD.WrapText
    If VarType(vConc) = vbNull Or IsMissing(vConc) Then vConc = ""
    If IsObject(vConc) Then vConc = vConc.Value
    L1 = Len(RefO.Value)
    L2 = Len(vConc)
    If L2 = 0 Then
        RefD.Value = RefO.Value
    Else
        If L1 > 1329 - 1 Then
            RefD.Value = Left(RefO.Value, 1329 - 1) & "|fffd|"
        Else
            If L1 + L2 > 1329 Then
                RefD.Value = RefO.Value & Left(vConc, 1329 - 1 - L1) & "|fffd|"
            Else
                RefD.Value = RefO.Value & vConc
            End If
        End If
    End If
    If NoWrapD Then If WrapD = False Then RefD.WrapText = False
    SetValue = True
    Exit Function
ErroHandler:
    RefD.Value = "#VALUE!"
    SetValue = False
End Function

Function MyFind(vStr As String, vRange As Range)
'Tenta locaizar vStr em vRange e retorna uma refer|fffd|ncia como texto
    Static vRef As Range
    If vRef Is Nothing Then Set vRef = vRange.Cells(1, 1)
    If Intersect(vRef, vRange) Is Nothing Then Set vRef = vRange.Cells(1, 1)
    On Error Resume Next
    Set vRef = vRange.Find(What:=vStr, After:=vRef, LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, MatchCase:=False)
    If vRef Is Nothing Then
        MyFind = False
    Else
        MyFind = vRef.Address(, , xlA1)
    End If
End Function

Sub ConfNovaVer()
    Set ExcelObj = New Excel.Application
    DirP = ThisWorkbook.Path
    bEnableEvents = Application.EnableEvents
    Application.EnableEvents = False
    ExcelObj.Workbooks.Open (DirP & "\config2.xla")
    Application.EnableEvents = bEnableEvents
    ExcelObj.Visible = True
    ExcelObj.OnTime Now, "'" & DirP & "\[config2.xla]Sheet2'!Iniciar"
End Sub

Public Function AlertaCpap(vBot As Integer, vTitle As String, vMsg1 As String, Optional vMsg2 As String, Optional vMsg3 As String)
    If vTitle = "" Then vTitle = "CPAP|fffd|"
    AlertaCpap = MsgBox(vMsg1 & vMsg2 & vMsg3, Choose(vBot, vbOKOnly + vbInformation, vbOKCancel + vbQuestion, vbYesNoCancel + vbQuestion, vbAbortRetryIgnore + vbQuestion, vbCritical), vTitle)
    Select Case vBot
    Case 1   'OK inform
        AlertaCpap = True
    Case 2   'Ok ou Cancel quest
        AlertaCpap = AlertaCpap = vbOK
    Case 3   'sim n|fffd|o cancel
        AlertaCpap = -1 * (AlertaCpap = vbYes) - 2 * (AlertaCpap = vbNo) - 3 * (AlertaCpap = vbCancel)
    Case 4   'abortar retentar Ignorar
        AlertaCpap = -1 * (AlertaCpap = vbAbort) - 2 * (AlertaCpap = vbRetry) - 3 * (AlertaCpap = vbIgnore)
    Case 5   'Ok cr|fffd|tico
        AlertaCpap = True
    End Select
End Function

Function Fundo(vMod As Single, Optional vAct As Boolean = True)
    If WbFundo Is Nothing Then
        VerifVari|fffd|veis

        WbFundo.Activate
        Application.GoTo Range("A1"), True
        ActiveWorkbook.ActiveSheet.ScrollArea = "A1"

        If LCase(WbFundo.Name) <> "cpap_fun.pla" Then
            WbFundo.Names.Add Name:="Auto_Close", RefersToR1C1:="=cpap_ex8.mac!AutoFecFundo"
            WbFundo.Names.Add Name:="Fechar_Auto", RefersToR1C1:="=cpap_ex8.mac!AutoFecFundo"
            WbFundo.Names.Add Name:="Aberto", RefersToR1C1:="=FALSE"   'ParaIdDoCpap
            WbFundo.Names.Add Name:="DirP", RefersToR1C1:="=""c:\cpap"""
        End If
    End If

    WbM|fffd|dAtivo = Choose(vMod, "cpap_avu.mac", "cpap_jap.pla", "cpap_ctv.mac", "cpap_mp.mac", "cpap_car.mac")
    On Error Resume Next   'Evita exib de um erro indefinido ao fechar avu
    ThisWorkbook.Sheets(1).Range("WbM|fffd|dAtivo").Value = WbM|fffd|dAtivo   'Quarda vari|fffd|vel na planilha, pois costuma perder ao usa um HALT()
    If Err.Number <> 0 Then Application.StatusBar = "Erro desconhecido ao exibir fundo vindo de avulso"
    On Error GoTo 0
    WbFundo.Windows(1).Visible = True: WbFundo.Activate    'No 2013, antes de ativar |fffd| necess|fffd|rio tornar vis|fffd|vel, pois pode ter sido ocultado.
    WbFundo.Windows(1).Caption = Choose(vMod, "Atualiza|fffd||fffd|es ", "Planos de Pagamentos ", "Emiss|fffd|o de Contratos ", "Acompanhamentos de Contratos ", "Contas A Receber ")
    If vAct Then
        Windows(Workbooks(WbM|fffd|dAtivo).Windows(1).Caption).Visible = False
        WbFundo.Sheets(1).Unprotect
        'Lista o nome do m|fffd|dulo ativo no fundo
        'i = Choose(vMod, "Atualiza|fffd||fffd|es     ", "Planos     ", "Contratos     ", "Acompanhamentos    ", "A Receber    ")
        'On Error Resume Next   'Causa um erro inexplic|fffd|vel fechando avu ap|fffd|s um detalhe e um retorno a aco
        'WbFundo.Names.Add Name:="Aberto", RefersToR1C1:=Application.WorksheetFunction.Rept(i, 8)
        'On Error GoTo 0
        'WbFundo.Sheets(1).Calculate
        Application.DisplayFormulaBar = False
        With Application.ActiveWindow
            .DisplayHorizontalScrollBar = False
            .DisplayVerticalScrollBar = False
            .DisplayWorkbookTabs = False
        End With
        ObjFundoFormatar "RetAtu", 2 - 1 * (vMod = 1)
        If Mplano Then
            '            WbFundo.Sheets(1).DrawingObjects(Array("RetPlano", "RetContr", "RetAco", "RetCAR", "SetAtu", "SetAcoAtu1", "SetAcoAtu2", "SetAco", "SetContr1", "SetContr2", "SetCAR")).Visible = False  'No Excel2007 so suporta 5 itens
            WbFundo.Sheets(1).DrawingObjects(Array("RetPlano", "RetContr", "RetAco", "RetCAR", "SetAtu")).Visible = False
            WbFundo.Sheets(1).DrawingObjects(Array("SetAcoAtu1", "SetAcoAtu2", "SetAco", "SetContr1", "SetContr2")).Visible = False
            WbFundo.Sheets(1).DrawingObjects(Array("SetCAR")).Visible = False
        Else
            '            WbFundo.Sheets(1).DrawingObjects(Array("RetPlano", "RetContr", "RetAco", "RetCAR", "SetAtu", "SetAcoAtu1", "SetAcoAtu2", "SetAco", "SetContr1", "SetContr2", "SetCAR")).Visible = True  'No Excel2007 so suporta 5 itens
            WbFundo.Sheets(1).DrawingObjects(Array("RetPlano", "RetContr", "RetAco", "RetCAR", "SetAtu")).Visible = True
            WbFundo.Sheets(1).DrawingObjects(Array("SetAcoAtu1", "SetAcoAtu2", "SetAco", "SetContr1", "SetContr2")).Visible = True
            WbFundo.Sheets(1).DrawingObjects(Array("SetCAR")).Visible = True

            ObjFundoFormatar "RetPlano", IIf(Mplano, 1, 2 - 1 * (vMod = 2))
            ObjFundoFormatar "RetContr", IIf(Mcont, 1, 2 - 1 * (vMod = 3))
            ObjFundoFormatar "RetAco", IIf(Macomp, 1, 2 - 1 * (vMod = 4))
            ObjFundoFormatar "RetCAR", IIf(Macomp, 1, 2 - 1 * (vMod = 5))
        End If
        WbFundo.Sheets(1).Protect DrawingObjects:=True, Contents:=True, Scenarios:=True

        'Montando ShortMenu
        Set vBarra = CommandBars("Cell")
        'Limpando a barra de menu
        vBarra.Reset
        Dim c As CommandBarControl
        For Each c In vBarra.Controls
            c.Delete
        Next
        vHelpFile = ThisWorkbook.Path & "\cpap.hlp"
        With vBarra
            With .Controls.Add(Type:=msoControlButton)
                .Caption = "Calculadora"
                .OnAction = "cpap_pri.mac!CalcApPlan"
                .HelpFile = vHelpFile
                .HelpContextID = 20118130
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = "Calend|fffd|rio"
                .OnAction = "cpap_pri.mac!CalendApPlan"
                .HelpFile = vHelpFile
                .HelpContextID = 20118135
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = "Login/out"
                .OnAction = "cpap_pri.mac!Logar"
                .BeginGroup = True
                .HelpFile = vHelpFile
                .HelpContextID = 120
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = "Fundo"
                .OnAction = "cpap_pri.mac!FundoAlt"
                .BeginGroup = True
                .HelpFile = vHelpFile
                .HelpContextID = 122
            End With
        End With
    Else
        Windows(Workbooks(WbM|fffd|dAtivo).Windows(1).Caption).Visible = True: WbFundo.Windows(1).Visible = False    'No 2013, devido SDI, |fffd| necess|fffd|rio ocultar o fundo quando n|fffd|o ativo para n|fffd|o ficar sendo exibido em sua janela, mas vou deixar para todas vers|fffd|es.
        Workbooks(WbM|fffd|dAtivo).Activate
    End If
    '    Application.EnableEvents = True 'Depois de false desde cpap.xla(xlm) No cpap 2007 tem on pr|fffd|prio
End Function

Private Sub ObjFundoFormatar(nObj As String, eObj As Single)
    WbFundo.Sheets(1).Shapes(nObj).Select
    Select Case eObj
    Case 1   'Objeto n|fffd|o instalado
        Selection.Font.ColorIndex = 12
        Selection.ShapeRange.Fill.Visible = msoFalse
        Selection.ShapeRange.Line.DashStyle = msoLineSquareDot
        Selection.ShapeRange.Line.ForeColor.SchemeColor = 17
    Case 2   'Objeto instalado
        Selection.Font.ColorIndex = 50
        Selection.ShapeRange.Fill.Visible = msoTrue
        Selection.ShapeRange.Fill.Solid
        Selection.ShapeRange.Fill.ForeColor.SchemeColor = 9
        Selection.ShapeRange.Fill.Transparency = 0.5
        Selection.ShapeRange.Line.DashStyle = msoLineSolid
        Selection.ShapeRange.Line.ForeColor.SchemeColor = 17
    Case 3   'Objeto instalado e ativo
        Selection.Font.ColorIndex = 3
        Selection.ShapeRange.Fill.Visible = msoTrue
        Selection.ShapeRange.Fill.Solid
        Selection.ShapeRange.Fill.ForeColor.SchemeColor = 9
        Selection.ShapeRange.Fill.Transparency = 0.5
        Selection.ShapeRange.Line.DashStyle = msoLineSolid
        Selection.ShapeRange.Line.ForeColor.SchemeColor = 29
    End Select
    WbFundo.Sheets(1).Range("A1").Select    'Necess|fffd|rio no 2007, pois se via rapidamente o RetAco ainda selecionado talvez divido ao bug do 2007 de manter ojbeto selecionado ao editar
End Sub

Sub ObjFundoClick()
    Dim vCmd As String
    Static bIsRun As Boolean    'Precisou com o 2010 (talvez 2007) para evitar dois cliques. Veio depois da tentativa com Interactiv=False que falhou no 2010, pois a Ribbon n|fffd|o atualiza durante o MyWait e gera erro no ShowPopup, e ao fazer True a|fffd| um segundo click pode acontecer. O interactive n|fffd|o |fffd| mais necess|fffd|rio, deixei apenas comentado aqui e no XLM deixei como estava para uma eventualidade
    If bIsRun Then Exit Sub Else VerifVari|fffd|veis
    i = Application.Caller
    If IsError(i) Then Exit Sub Else bIsRun = True
ReClick:
    'Application.Interactive = False    'Precisou com o 2007 para evitar dois cliques, pois ao clicar duas vezes parece iniciar outro processo provocando atualiza|fffd||fffd|o da Ribbon no meio do primeiro processo. No final ou no in|fffd|cio de cada comando fazer True ou DISABLE.INPUT(FALSE)&APP.ACTIVATE() ativar o aplication pois este perde foco e d|fffd| problema no Vista
    On Error Resume Next
    If WbM|fffd|dAtivo = "" Then WbM|fffd|dAtivo = ThisWorkbook.Sheets(1).Range("WbM|fffd|dAtivo").Value
    vMenuAtiv = GetMenuAtivName: If vMenuAtiv = "" Then MenuCfg: bIsRun = False: Exit Sub    'If Application.CommandBars("MenuCPAP1").Visible Then vMenuAtiv = "MenuCPAP1"     'No 2013, erro na propriedade visible |fffd| avaliada pelo if como True e n|fffd|o false ent|fffd|o foi necess|fffd|rio GetMenuAtivName. E ainda |fffd| poss|fffd|vel n|fffd|o existir barra de menu em diferentes janela, ent|fffd|o ignora click e rechamando MenuCfg para criar ou atualizar a seguir...
    If Not MenuAtivIsUpdt() Then MenuCfg: bIsRun = False: Exit Sub      'If vMenuAtiv = "" Then If Application.CommandBars("MenuCPAP2").Visible Then vMenuAtiv = "MenuCPAP2"   '... pois no 2013 pode ser tamb|fffd|m diferente. Por acaso, ficou |fffd|til em todas vers|fffd|es quando editando e exibindo o menu do Excel ficava tremendo ao clicar.
    If (i = "RetAtu" And WbM|fffd|dAtivo = "cpap_avu.mac") Or _
            (i = "RetPlano" And WbM|fffd|dAtivo = "cpap_jap.pla") Or _
            (i = "RetContr" And WbM|fffd|dAtivo = "cpap_ctv.mac") Or _
            (i = "RetAco" And WbM|fffd|dAtivo = "cpap_mp.mac") Or _
            (i = "RetCAR" And WbM|fffd|dAtivo = "cpap_car.mac") Then
        'Se j|fffd| est|fffd| no m|fffd|dulo do objeto clicado
        On Error Resume Next
        CommandBars("BarraDeSa|fffd|da").Delete
        On Error GoTo 0
        Set BarraDeSa|fffd|da = CommandBars _
                .Add(Name:="BarraDeSa|fffd|da", Position:=msoBarPopup, _
                Temporary:=True)

        If i = "RetAtu" And WbM|fffd|dAtivo = "cpap_avu.mac" Then
            With BarraDeSa|fffd|da
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Novo"
                    .OnAction = "cpap_avu.mac!NovoMenu"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Abrir"
                    .OnAction = "cpap_avu.mac!Abrir"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "Editar &Tabelas de |fffd|ndices..."
                    .OnAction = "cpap_avu.mac!Editar.Ind"
                End With
                .ShowPopup
            End With
        End If

        If i = "RetPlano" And WbM|fffd|dAtivo = "cpap_jap.pla" Then
            With BarraDeSa|fffd|da
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Novo"
                    .OnAction = "cpap_jap.mac!NovoMenu"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Abrir"
                    .OnAction = "cpap_jap.mac!Gravadas.jap"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "Editar &Tabelas de |fffd|ndices..."
                    .OnAction = "cpap_jap.mac!Editar.Ind"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "Tabela de &Pre|fffd|os"
                    .OnAction = "cpap_jap.mac!TabPr"
                End With
                .ShowPopup
            End With
        End If

        If i = "RetContr" And WbM|fffd|dAtivo = "cpap_ctv.mac" Then
            With BarraDeSa|fffd|da
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Abrir"
                    .OnAction = "cpap_ctv.mac!Abrir"
                End With
                .ShowPopup
            End With
        End If

        If i = "RetAco" And WbM|fffd|dAtivo = "cpap_mp.mac" Then
            With BarraDeSa|fffd|da
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Abrir"
                    .OnAction = ThisWorkbook.Path & "\cpap_mp.mac!GravadosMPOnTime"    'GravadosMP" No 2010 precisou OnTime, pois n|fffd|o sei porque o GravadosMP acionado diretamente gera erro apenas no WinXP virtual.
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Implementar"
                    .OnAction = "cpap_mp.mac!ArqPlanA"
                End With
                .ShowPopup
            End With
        End If

        If i = "RetCAR" And WbM|fffd|dAtivo = "cpap_car.mac" Then
            With BarraDeSa|fffd|da
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Novo"
                    .OnAction = "cpap_car.mac!Novo"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Abrir"
                    .OnAction = "cpap_car.mac!Abrir"
                End With
                With .Controls.Add(Type:=msoControlButton)
                    .Caption = "&Verificar Rela|fffd||fffd|o"
                    .OnAction = ThisWorkbook.Path & "\cpap_car.mac!VerifRelacaoOnTime"    'VerifRela|fffd||fffd|o" No 2007 precisou OnTime para evitar popdentro do formul|fffd|rio
                End With
                .ShowPopup
            End With
        End If
    Else
        'Ir para outro m|fffd|dulo

        If i = "RetAtu" Then vCmd = "M|fffd|dulo de Atualiza|fffd||fffd|es"
        If i = "RetPlano" Then vCmd = "M|fffd|dulo de Planos de Pagamentos"
        If i = "RetContr" Then vCmd = "M|fffd|dulo de Planos de Pagamentos"
        If i = "RetAco" Then vCmd = "M|fffd|dulo de Acompanhamentos"
        If i = "RetCAR" Then vCmd = "M|fffd|dulo de Contas a Receber"
        Err.Clear
        If vMenuAtiv <> "" And vCmd <> "" Then Run Application.CommandBars(vMenuAtiv).Controls("Janela").Controls(vCmd).OnAction
        'Application.CommandBars(vMenuAtiv).Controls("Janela").Controls(vCmd).Execute
        'Run |fffd| melhor porque o Execute mant|fffd|m a barra travada durante a execu|fffd||fffd|o
        If vMenuAtiv <> "" And i = "RetContr" And Mcont = False Then Run "cpap_jap.mac!ContratoDir"
        If i = "RetPlano" And Mplano Then
            MsgBox "Esta instala|fffd||fffd|o n|fffd|o cont|fffd|m o M|fffd|dulo de Planos de Pagamentos. Veja as perguntas mais freq|fffd|entes sobre este m|fffd|dulo.", vbOKOnly + vbExclamation, "CPAP|fffd|"
            Application.Run "cpap_pri.mac!Cpap_faq", 30
            Err.Number = 1
        End If
        If i = "RetContr" And Mcont Then
            MsgBox "Esta instala|fffd||fffd|o n|fffd|o cont|fffd|m o M|fffd|dulo de Emiss|fffd|o de Contratos. Veja as perguntas mais freq|fffd|entes sobre este m|fffd|dulo.", vbOKOnly + vbExclamation, "CPAP|fffd|"
            Application.Run "cpap_pri.mac!Cpap_faq", 40
            Err.Number = 1
        End If
        If i = "RetAco" And Macomp Then
            MsgBox "Esta instala|fffd||fffd|o n|fffd|o cont|fffd|m o M|fffd|dulo de Acompanhamentos de Contrato. Veja as perguntas mais freq|fffd|entes sobre este m|fffd|dulo.", vbOKOnly + vbExclamation, "CPAP|fffd|"
            Application.Run "cpap_pri.mac!Cpap_faq", 50
            Err.Number = 1
        End If
        If i = "RetCAR" And Macomp Then
            MsgBox "Esta instala|fffd||fffd|o n|fffd|o cont|fffd|m o M|fffd|dulo de Contas A Receber. Veja as perguntas mais freq|fffd|entes sobre este m|fffd|dulo.", vbOKOnly + vbExclamation, "CPAP|fffd|"
            Application.Run "cpap_pri.mac!Cpap_faq", 60
            Err.Number = 1
        End If

        'N|fffd|o havendo erro e, ao mudar de m|fffd|dulo, o fundo ainda estiver em
        'exibi|fffd||fffd|o e n|fffd|o sendo vers|fffd|o demonstrativa reclicar objeto automaticamente
        If Err.Number = 0 And ActiveWorkbook.Name = WbFundo.Name And Dem = False Then
            Application.ScreenUpdating = True
            If Val(Application.Version) >= 12 Then MyWait 0.5  'Para a Ribbon se atualizar antes de exibir um popmenu.  'Application.Interactive = True: MyWait 0.5  Se Interactive = False, a Ribbon n|fffd|o atualiza durante o MyWait.
            GoTo ReClick
        End If
    End If
    Application.ScreenUpdating = True: bIsRun = False
    'Application.Interactive = True: AppActivate Application.Caption    'Se usando Interactive, ativar o aplication pois este perde foco e d|fffd| problema no Vista.
End Sub

Sub AutoFecFundo()
    If ActiveWorkbook Is Nothing Then Application.Run "cpap_pri.mac!Sair": Exit Sub    'No 2013, mas era bug antigo.
    VerifVari|fffd|veis
    If WbFundo.Name = ActiveWorkbook.Name Then Workbooks(WbM|fffd|dAtivo).RunAutoMacros xlAutoClose
    Application.ExecuteExcel4Macro ("HALT(TRUE)")    'No 2013, mas era bug antigo.
End Sub


Private Sub SalvarFundo()
    VerifVari|fffd|veis
    WbFundo.Activate
    WbFundo.Sheets(1).Unprotect
    WbFundo.Names.Add Name:="Aberto", RefersToR1C1:=" "
    WbFundo.Sheets(1).Calculate
    '    WbFundo.Sheets(1).DrawingObjects(Array("RetPlano", "RetContr", "RetAco", "RetCAR", "SetAtu", "SetAcoAtu1", "SetAcoAtu2", "SetAco", "SetContr1", "SetContr2", "SetCAR")).Visible = True 'No Excel2007 so suporta 5 itens
    WbFundo.Sheets(1).DrawingObjects(Array("RetPlano", "RetContr", "RetAco", "RetCAR", "SetAtu")).Visible = True  'No Excel2007 so suporta 5 itens
    WbFundo.Sheets(1).DrawingObjects(Array("SetAcoAtu1", "SetAcoAtu2", "SetAco", "SetContr1", "SetContr2")).Visible = True
    WbFundo.Sheets(1).DrawingObjects(Array("SetCAR")).Visible = True

    ObjFundoFormatar "RetAtu", 1
    ObjFundoFormatar "RetPlano", 1
    ObjFundoFormatar "RetContr", 1
    ObjFundoFormatar "RetAco", 1
    ObjFundoFormatar "RetCAR", 1
    WbFundo.Sheets(1).Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    Range("A1").Select
    If ActiveWorkbook.ReadOnly Then ActiveWorkbook.ChangeFileAccess xlReadWrite
    With ActiveWindow
        .DisplayHeadings = False
        .DisplayZeros = False
        .DisplayHorizontalScrollBar = False
        .DisplayVerticalScrollBar = False
        .DisplayWorkbookTabs = False
    End With
    Application.DisplayFormulaBar = False
    If MsgBox("Salvar?", vbOKCancel) = vbOK Then WbFundo.Save
End Sub

Function Pain|fffd|is(Ref, Vert, Horiz As String)
    With UserFormPain|fffd|is
        .VertHor_OpB.Tag = Ref
        .Vert_OpB.Tag = Vert
        .Hor_OpB.Tag = Horiz
        '      .Show 'Como fun|fffd||fffd|o trava por isso o Sub Pain|fffd|isS
    End With
End Function

Sub Pain|fffd|isS()
    UserFormPain|fffd|is.Show
End Sub

Function fEditObj(Obj As String, Txt As String, Optional lPlacmt As Long = 0)
'Esta fun|fffd||fffd|o existe em EX8 e em CnTP
    Dim bScrUpd As Boolean: bScrUpd = Application.ScreenUpdating: Application.ScreenUpdating = True    'No 2013 fiz por similaridade com GetDocument42VBA com shapes
    On Error Resume Next
    Txt = Application.WorksheetFunction.Substitute(Txt, "-", Chr(10))    'Quebra no meio de palavra
    Txt = Application.WorksheetFunction.Substitute(Txt, "_", Chr(10))    'Quebra em um espa|fffd|o
    ActiveWorkbook.ActiveSheet.Shapes(Obj).TextEffect.Text = Txt

    If InStr(1, Txt, ".") > 0 Then
        ActiveWorkbook.ActiveSheet.Shapes(Obj).TextEffect.NormalizedHeight = msoFalse
    Else
        ActiveWorkbook.ActiveSheet.Shapes(Obj).TextEffect.NormalizedHeight = msoTrue
    End If

    'O ultimo arg informa se o obj flutua ou varia com a cel foi neces. devido a um Bug 2007
    'em macrosheet que fica sempre xlMoveAndSize
    If Val(Application.Version) >= 12 Then
        If lPlacmt = 1 Then ActiveWorkbook.ActiveSheet.Shapes(Obj).Placement = xlMoveAndSize
        If lPlacmt = 2 Then ActiveWorkbook.ActiveSheet.Shapes(Obj).Placement = xlMove
        If lPlacmt = 3 Then ActiveWorkbook.ActiveSheet.Shapes(Obj).Placement = xlFreeFloating
    End If

    fEditObj = (Err.Number = 0)
    Application.ScreenUpdating = bScrUpd
End Function

Function M|fffd|sNoDbf(m As String)
    On Error Resume Next
    If NmesIndMax = 0 Then NmesIndMax = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("NmesIndMax").Value
    If m = "o fim" Then m = Format(DateSerial(1970, 5 + NmesIndMax - 1, 1), "dd/mm/yyyy")
    If Len(m) < 8 Then m = "28/" & m    '28 assim n|fffd|o h|fffd| risco de conf. com m|fffd|s
    m = DateValue(m)
    M|fffd|sNoDbf = Year(m) * 12 + Month(m) - 1970 * 12 - 5 + 1   '05/1970
    If Err.Number = 0 Then
        If M|fffd|sNoDbf < 1 Then M|fffd|sNoDbf = 1
        If M|fffd|sNoDbf > NmesIndMax Then M|fffd|sNoDbf = NmesIndMax
    Else
        M|fffd|sNoDbf = False
    End If
End Function

Sub ToolBar1()
    On Error Resume Next    'Necess|fffd|rio no Excel 2010, parece que attached toolbar carrega mas some logo, diferente do 2007. Sem problema, pois essa barra s|fffd| |fffd|til para editar o cpap no Excel XP.
    With Application.CommandBars("Toolbar 1")
        .Controls(19).OnAction = "cpap_pri.mac!Protegendo"
        .Controls(20).OnAction = "cpap_pri.mac!Desprotegendo"
        .Controls(21).OnAction = "DIVERSOS\TRADUCAO.XLM!tradu|fffd||fffd|o"
        .Controls(22).OnAction = "cpap_pri.mac!AjudFun"
        .Controls(23).OnAction = "cpap_pri.mac!Ir_1"
        .Controls(24).OnAction = "cpap_pri.mac!Ir_2"
        .Controls(25).OnAction = "CART-INS.XLM!CaptSenh"
        .Controls(26).OnAction = "cpap_pri.mac!ExplDirP"
    End With
    ActiveWorkbook.ActiveSheet.ScrollArea = ""
    Err.Clear
End Sub

Function FormulaGoto(vRange As Range, Optional vScr As Boolean = False)
'O XLM gera um devio para retorno n|fffd|o encontrado ao instalar o Translator
'com Excel 2k e ao dar duplo toque em sheet (MacroSheet parece que n|fffd|o). Mesmo
'assim ao iniciar ainda d|fffd|.
'Exibe a barra, pois se painel congelado sem barra em exibi|fffd||fffd|o o scroll n|fffd|o funciona, talvez bug
    TbStd = Application.CommandBars("Standard").Visible
    If TbStd = False Then
        ScUp = Application.ScreenUpdating
        If ScUp Then Application.ScreenUpdating = False
        Application.CommandBars("Standard").Visible = True
    End If
    Application.GoTo vRange.Address(, , xlR1C1), vScr
    If TbStd = False Then
        Application.CommandBars("Standard").Visible = False
        Application.ScreenUpdating = ScUp
    End If
    FormulaGoto = True
End Function

Function ActivateVBA(vStr As String)
'Idem
    Application.Workbooks(vStr).Activate
    ActivateVBA = True
End Function

Function TemFormula(Rng As Range)
    TemFormula = Rng.HasFormula
End Function

Function CopyV(Optional Rng As Variant)
'Possibilita copiar e colar valores sem ocupar o clipboard
    If IsMissing(Rng) Or IsNull(Rng) Then Set CopyVrng = Selection() Else Set CopyVrng = Rng
    CopyV = True
End Function

Function PasteV(Optional PasteVRng As Variant, Optional Transp As Boolean = False)
    If IsMissing(PasteVRng) Or IsNull(PasteVRng) Then Set PasteVRng = Selection()
    PasteV = False
    On Error GoTo ErroHandler
    R = IIf(Transp, CopyVrng.Columns.Count, CopyVrng.Rows.Count)
    c = IIf(Transp, CopyVrng.Rows.Count, CopyVrng.Columns.Count)
    If PasteVRng.Rows.Count = 1 And PasteVRng.Columns.Count = 1 Then Set PasteVRng = PasteVRng.Resize(R, c)
    If PasteVRng.Rows.Count = R And PasteVRng.Columns.Count = c Then
        If CopyVrng.Cells.Count >= 5500 Then
            'Cola em lote de 5500, pois acima disso d|fffd| erro em macrosheet xlm (limita|fffd||fffd|o de array)
            ic = Int(5500 / c)
            For i = 1 To R Step ic
                i1 = i + ic - 1
                If i1 > R Then i1 = R
                If Transp Then
                    PasteVRng.Range(PasteVRng.Cells(1, i), PasteVRng.Cells(c, i1)).Value2 = Application.WorksheetFunction.Transpose(CopyVrng.Range(CopyVrng.Cells(i, 1), CopyVrng.Cells(i1, c)).Value2)
                Else
                    'PasteVRng.Range(PasteVRng.Cells(i, 1), PasteVRng.Cells(i1, c)).Value2 = CopyVrng.Range(CopyVrng.Cells(i, 1), CopyVrng.Cells(i1, c)).Value2
                    PasteVRng.Cells(i, 1).Resize(i1 - i + 1, c).Value2 = CopyVrng.Cells(i, 1).Resize(i1 - i + 1, c).Value2
                End If
            Next
        Else
            If Transp Then
                PasteVRng.Value2 = Application.WorksheetFunction.Transpose(CopyVrng.Value2)
            Else
                PasteVRng.Value2 = CopyVrng.Value2
            End If
        End If
        PasteV = True
    Else
        MsgBox "Imposs|fffd|vel colar, pois |fffd|rea de cola |fffd| diferente da de copia!", vbCritical + vbOKOnly, "Erro!"
    End If
    Exit Function
ErroHandler:
    MsgBox "Imposs|fffd|vel colar, pois a planilha para cola esta protegida!", vbCritical + vbOKOnly, "Erro!"
End Function

Function GetBarVBA(Tipo As Long)
    On Error Resume Next
    If Tipo = 1 Then
        GetBarVBA = ActiveMenuBar.Caption
    Else
        GetBarVBA = ActiveMenuBar.Menus.Count
    End If
    If Err.Number <> 0 Then GetBarVBA = 0
End Function

Function SendToClipboard(Str As String) As Boolean
    SendToClipboard = True
    If Str = "" Then Exit Function
    SendToClipboard = False
    On Error Resume Next
    Set MyData = New DataObject
    MyData.SetText Str
    MyData.PutInClipboard
    If Err.Number = 0 Then SendToClipboard = True
End Function

Sub CopyTextSel()
'Copia s|fffd| texto das c|fffd|lulas selecionadas e vis|fffd|veis. Usado ao acionar Ctrl+C em um relat|fffd|rio, assim leva s|fffd| texto sem formata|fffd||fffd|o
'mas do que isso poderia simplesmente copiar tudo e remover as personaliza|fffd||fffd|o
    Dim Str As String
    Dim SelRng As Range
    Dim R As Range
    Dim c As Range
    Dim r1 As Long
    Dim c1 As Long
    Set SelRng = Selection
    If TypeName(SelRng) <> "Range" Then Exit Sub
    Selection.Copy: MyWait 1: Application.CutCopyMode = False    'S|fffd| enfeite para o usu|fffd|rio ver a a|fffd||fffd|o do ctrl+c
    For Each R In SelRng.Rows
        If Not R.Hidden Then    'Salta linhas ocultas
            r1 = r1 + 1
            If r1 > 1 Then Str = Str & vbCrLf
            c1 = 0
            For Each c In R.Cells
                If Not c.EntireColumn.Hidden Then    'Salta celula em coluna oculta
                    c1 = c1 + 1
                    If c1 > 1 Then Str = Str & vbTab
                    If Not IsError(c.Value) Then Str = Str & c.Value      'Se Value2, data-tempo seria capturado como n|fffd|mero decimal
                End If
            Next c
        End If
    Next R
    If Str <> "" Then SendToClipboard Str
End Sub

Function fScrollArea(Optional Rng As Range)
    If IsMissing(Rng) Or IsNull(Rng) Or Rng Is Nothing Then
        ActiveWorkbook.ActiveSheet.ScrollArea = ""
    Else
        ActiveWorkbook.ActiveSheet.ScrollArea = Rng.Address
    End If
    fScrollArea = True
End Function

Function ProtectDocument(Cnt As Boolean, Psw As String, Obj As Boolean)
'Necess|fffd|rio no Excel 2002, pois ao proteger dados com XLM n|fffd|o permite selecionar c|fffd|lulas ao abrir
    ActiveWorkbook.ActiveSheet.Protect Password:=Psw, DrawingObjects:=Obj, Contents:=Cnt, UserInterfaceOnly:=True
    ProtectDocument = True
End Function

Function SaveVBA() As Boolean
'Retorna True se continuar ativo, pois qualquer problema deve ser resolvido aqui or volta sem salvar
    ADA = Application.DisplayAlerts
    Application.DisplayAlerts = False
    Wn = ActiveWorkbook.Name
    On Error Resume Next
Retry:
    Err.Number = 0
    ActiveWorkbook.Save
    If ActiveWorkbook.Saved = False And (Val(Application.Version) = 8 Or ActiveWorkbook.FileFormat = xlExcel4) Then
        'Para converter arquivo salvo no Excel 2002 em Excel 97, pois normalmente n|fffd|o converte (bug) e fica sempre alertando sobre perda na convers|fffd|o
        'e aproveitando converter Excel4 em Excel5 porque o 4 n|fffd|o |fffd| mais suportado no 2007
        R = R + 1
        If R < 4 Then GoTo Retry
        Wnf = ActiveWorkbook.FullName
        Wnb = Left(Wnf, Len(Wnf) - 3) & "bak"
        ActiveWorkbook.SaveAs Wnb, xlExcel5    '=xlExcel7(95)
        ActiveWorkbook.Close False
        Kill Wnf
        bEnableEvents = Application.EnableEvents
        Application.EnableEvents = False
        Workbooks.Open Wnb, , True
        Application.EnableEvents = bEnableEvents
        ActiveWorkbook.SaveAs Wnf
        Kill Wnb
        On Error GoTo 0
    End If
    SaveVBA = LCase(ActiveWorkbook.Name) = LCase(Wn)
    If SaveVBA And (Err.Number <> 0 Or ActiveWorkbook.Saved = False) Then If MsgBox("Voc|fffd| pode n|fffd|o estar devidamente logado na rede. Acione OK para uma nova tentativa ou Cancelar para desistir.", vbCritical + vbOKCancel, "Falha ao Salvar!") = vbOK Then GoTo Retry
    If SaveVBA = False Then MsgBox "Voc|fffd| pode n|fffd|o estar devidamente logado na rede. Acione OK para continuar.", vbCritical + vbOKOnly, "Falha ao Salvar!"
    Application.DisplayAlerts = ADA
End Function

Function SaveAsVBA(document_text As String, type_num As Long, Optional prot_pwd, Optional backup, Optional write_res_pwd, Optional read_only_rec, Optional lErrAlert) As Boolean
'Precisou com o 2007, pois os formatos para 97 - 2003 n|fffd|o tem no XLM e o 2007 n|fffd|o aceita xlExcel4 (33)
'xlExcel5 e 7 39; xlExcel8 56
    If IsMissing(prot_pwd) Then prot_pwd = ""
    If IsMissing(backup) Then backup = False
    If IsMissing(write_res_pwd) Then write_res_pwd = ""
    If IsMissing(read_only_rec) Then read_only_rec = False
    If IsMissing(lErrAlert) Then lErrAlert = 1 Else If TypeName(lErrAlert) = "Boolean" Then lErrAlert = Abs(CLng(lErrAlert))  'Em XLM quando error(false) evita mensag de erro. 0-SemAlert 1-Com 2-Sem com uma tentativa

    ADA = Application.DisplayAlerts
    Application.DisplayAlerts = False
    On Error Resume Next
Retry:
    Err.Number = 0
    ActiveWorkbook.SaveAs document_text, type_num, prot_pwd, write_res_pwd, read_only_rec, backup
    If ActiveWorkbook.Saved = False Then
        R = R + 1
        If R < 4 And lErrAlert <> 2 Then GoTo Retry
    End If
    SaveAsVBA = Err.Number = 0
    If SaveAsVBA = False And lErrAlert = 1 Then MsgBox "Voc|fffd| pode n|fffd|o estar devidamente logado na rede. Acione OK para continuar.", vbCritical + vbOKOnly, "Falha! - Ao salvar " & document_text
    Application.DisplayAlerts = ADA
End Function

Function OpenVBA(Fn As String, Ro As Boolean, Silence As Boolean) As Boolean
'Com XLM havia alerta de notifica|fffd||fffd|o ao n|fffd|o conseguir abrir um aquivo pra edi|fffd||fffd|o.
    ADA = Application.DisplayAlerts: WinSDIalinhGet    'No Excel 2013 SDI estoca pos e size da janela ativa para alinh a abrir.
    Application.DisplayAlerts = False
    On Error Resume Next
Retry:
    Err.Clear
    R = R + 1
    Application.StatusBar = R & "|fffd| tentativa para abrir " & Fn & "."
    'bEnableEvents = Application.EnableEvents 'No 2013, implementei via EnableEventsVBA, mas era bug antigo
    EnableEventsVBA False     'Application.EnableEvents = False
    Workbooks.Open Filename:=Fn, UpdateLinks:=0, ReadOnly:=Ro, Notify:=False
    EnableEventsVBA True    'Application.EnableEvents = bEnableEvents
    WbnFn = UCase(ActiveWorkbook.FullName) = UCase(Fn) Or UCase(ActiveWorkbook.Name) = UCase(Fn)
    If WbnFn And Ro = False And ActiveWorkbook.ReadOnly Then Err.Number = 1
    If Err.Number <> 0 And WbnFn Then ActiveWorkbook.Close False
    If Err.Number = 0 And WbnFn Then GoTo End1
    If R - 7 * Int(R / 7) = 0 And Err.Number <> 0 Then
        If Silence Then
            GoTo End1
        Else
            If MsgBox("Uma outra esta|fffd||fffd|o da rede pode estar travada com o arquivo aberto, sua esta|fffd||fffd|o pode n|fffd|o est|fffd| devidamente logada na rede ou o arquivo foi salvo por uma vers|fffd|o mais recente ou muito antiga do Excel." & Chr(10) & Chr(10) & "Acione OK para mais 7 tentativas ou Cancelar para desistir." & Chr(10) & Chr(10) & "Excel Erro Info: (" & Err.Number & ") " & Err.Description, vbCritical + vbOKCancel, "Falha! Ao Abrir o Arquivo " & IIf(Len(Fn) > 34, "...", "") & Right(Fn, 34)) = vbOK Then GoTo Retry Else GoTo End1
        End If
    Else
        Application.Wait Now + TimeValue("00:00:01")
        GoTo Retry
    End If
End1:
    OpenVBA = Err.Number = 0
    Application.DisplayAlerts = ADA: WinSDIalinhSet
    MessageVBA False    ' Application.StatusBar = False
End Function

Function OpenItrgVBA(Optional file_text As String, Optional update_links As Long, Optional read_only As Boolean) As Boolean
'Com Open?() XLM havia alerta de notifica|fffd||fffd|o (ProtectedView) no Excel 2010 ao n|fffd|o conseguir abrir o aquivo pra edi|fffd||fffd|o.
    On Error Resume Next
    ActWb = ActiveWorkbook.Name
    If file_text = "*.esp" Then
        sFileFilter = "Arquivos CPAP" & " (*.esp), *.esp)"
    Else
        sFileFilter = "Arquivos Excel" & " (*.xls;*.xlsx), *.xls;*.xlsx)"    'sFileFilter = "Arquivos Excel" & " (*.xls;*.xla;*.xlt;*.xlam;*.xlsm;*.xltm;*.xlsb;*.xlsx;*.xltx), *.xls;*.xla;*.xlt;*.xlam;*.xlsm;*.xltm;*.xlsb;*.xlsx;*.xltx)"
    End If
    fileToOpen = Application.GetOpenFilename(sFileFilter, 1)
    If fileToOpen = False Then Exit Function
    If OpenVBA(CStr(fileToOpen), read_only, False) = False Then OpenItrgVBA = False Else OpenItrgVBA = (Err.Number = 0)
    If OpenItrgVBA = False And ActiveWorkbook.Name <> ActWb Then ActiveWorkbook.Close False    'S|fffd| por seguran|fffd|a
End Function

Function AbrirXLMVBA(Fn As String, Ro As Boolean, sPsw As String, Silence As Boolean)
'No 2010 open XLM ao abrir folha de macro as linhas ficam em altura m|fffd|xima. Isso |fffd| workaround
'preparado especificamente para substituir o OPEN xlm nas condi|fffd||fffd|es na macro AbrirXLM em pri.
    ADA = Application.DisplayAlerts: WinSDIalinhGet    'No Excel 2013 SDI estoca pos e size da janela ativa para alinh a abrir.
    Application.DisplayAlerts = False
    On Error Resume Next
Retry:
    Err.Clear
    R = R + 1
    If R > 2 Then Application.StatusBar = R & "|fffd| tentativa para abrir " & Fn & "."
    'bEnableEvents = Application.EnableEvents No 2013 comentei porque o controle j|fffd| |fffd| feito no AbrirXLM. N|fffd|o seria prejudicial, apenas desnecess|fffd|rio.
    'Application.EnableEvents = False
    Workbooks.Open Filename:=Fn, UpdateLinks:=0, ReadOnly:=Ro, Password:=sPsw
    'Application.EnableEvents = bEnableEvents
    If Err.Number = 0 Then GoTo End1
    If R - 7 * Int(R / 7) = 0 And Err.Number <> 0 Then
        If Silence Then
            GoTo End1
        Else
            If MsgBox("Uma outra esta|fffd||fffd|o da rede pode estar travada com o arquivo aberto, sua esta|fffd||fffd|o pode n|fffd|o est|fffd| devidamente logada na rede ou o arquivo foi salvo por uma vers|fffd|o mais recente ou muito antiga do Excel." & Chr(10) & Chr(10) & "Acione OK para mais 7 tentativas ou Cancelar para desistir." & Chr(10) & Chr(10) & "Excel Erro Info: (" & Err.Number & ") " & Err.Description, vbCritical + vbOKCancel, "Falha! Ao Abrir o Arquivo " & IIf(Len(Fn) > 34, "...", "") & Right(Fn, 34)) = vbOK Then GoTo Retry Else GoTo End1
        End If
    Else
        Application.Wait Now + TimeValue("00:00:01")
        GoTo Retry
    End If
End1:
    AbrirXLMVBA = IIf(Err.Number <> 0, CVErr(xlErrValue), True)
    Application.DisplayAlerts = ADA: WinSDIalinhSet
    If R > 2 Then MessageVBA False    ' Application.StatusBar = False
End Function


Function CapturarTela() As Boolean
    CapturarTela = True
    bScan = 1
    If Application.WindowState = xlNormal Then
        i = MsgBox("Capturar s|fffd| a janela do cpap?", vbYesNoCancel, CPAP|fffd|)
        If i = vbNo Then bScan = 0
        If i = vbCancel Then
            CapturarTela = False
            Exit Function
        End If
    End If
    keybd_event VK_SNAPSHOT, bScan, 0, 0
End Function

Function ActPrinter(vArg As Integer) As String
    On Error Resume Next
    Select Case vArg
    Case 1   'Nome da impressora e porta
        i = Application.ActivePrinter
        If Err.Number <> 0 Then i = "??? em LPTn"
    Case 2   'Nome do comando da pasta de conf. de impressoras no Windows
        Err.Number = 0
        i = gLocInfo(LOCALE_SENGLANGUAGE)
        i = IIf(i Like "English", "printers", IIf(i Like "Portuguese", "impressoras", ""))
        If Err.Number <> 0 Then i = ""
    End Select
    ActPrinter = i
End Function

Function PrinterFolderOpen() As Boolean
    Dim oShell32
    Const CSIDL_PRINTERS = 4
    On Error Resume Next
    Set oShell32 = CreateObject("Shell.Application")    'Ver mais na pasta \SobreExcel\HelpsScrAspHtml sobre shell application object
    oShell32.Open (CSIDL_PRINTERS)    'oShell32.Explore (CSIDL_PRINTERS)
    Set oShell32 = Nothing
    If Err.Number <> 0 Then MsgBox Err.Number & ": " & Err.Description, vbCritical, "Erro!"
    PrinterFolderOpen = Err.Number = 0
End Function

Function gLocInfo(vType As Long) As String
    Dim vLoc As Long
    Dim vStr As String, vLng As Long
    Dim ret As Long
    vStr = String$(255, 0)
    vLng = 255 - 1
    ret = apiGetLocaleInfo(LOCALE_USER_DEFAULT, vType, vStr, vLng)
    If ret <> 0 Then
        gLocInfo = Left$(vStr, ret - 1)
    End If
End Function

Function ArrayEdit(vArr, vElem, vWithRep As Boolean)
'vElem - New element to add on vArr
'vWithRep - Accept or not repeated element
    Dim ArrTmp()
    Dim vExist As Boolean
    If IsError(vArr) Then vArr = ""
    If IsArray(vArr) Then
        iU = UBound(vArr)
        ReDim ArrTmp(iU - 1)
        For i = 1 To iU
            If iU = 1 Then j = vArr(i) Else j = vArr(i, 1)
            If IsError(j) Then j = ""
            ArrTmp(i - 1) = j
            If j = vElem Then vExist = True
        Next
        If vExist = False Or (vExist And vWithRep) Then
            ReDim Preserve ArrTmp(iU)
            ArrTmp(iU) = vElem
        End If
    Else
        ReDim ArrTmp(0)
        iU = 1
        j = IIf(vArr = "", vElem, vArr)
        ArrTmp(0) = j
    End If
    ArrayEdit = Application.Transpose(ArrTmp)
End Function

Function SumPowerToBool(vInt As Integer, vPos As Integer) As Boolean
'Returns a boolean value stored on power sum of 2 (=v1*2^0+v2*2^1+...)
'until the tenth position. Quando quiser aumentar basta editar e inserir a primeira parcl ap|fffd|s vInt
    Static R(9) As Boolean
    Static vIntLast As Integer
    If vInt <> vIntLast Then
        R(9) = vInt >= 2 ^ 9
        R(8) = vInt + 2 ^ 9 * R(9) >= 2 ^ 8
        R(7) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) >= 2 ^ 7
        R(6) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) >= 2 ^ 6
        R(5) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) + 2 ^ 6 * R(6) >= 2 ^ 5
        R(4) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) + 2 ^ 6 * R(6) + 2 ^ 5 * R(5) >= 2 ^ 4
        R(3) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) + 2 ^ 6 * R(6) + 2 ^ 5 * R(5) + 2 ^ 4 * R(4) >= 2 ^ 3
        R(2) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) + 2 ^ 6 * R(6) + 2 ^ 5 * R(5) + 2 ^ 4 * R(4) + 2 ^ 3 * R(3) >= 2 ^ 2
        R(1) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) + 2 ^ 6 * R(6) + 2 ^ 5 * R(5) + 2 ^ 4 * R(4) + 2 ^ 3 * R(3) + 2 ^ 2 * R(2) >= 2 ^ 1
        R(0) = vInt + 2 ^ 9 * R(9) + 2 ^ 8 * R(8) + 2 ^ 7 * R(7) + 2 ^ 6 * R(6) + 2 ^ 5 * R(5) + 2 ^ 4 * R(4) + 2 ^ 3 * R(3) + 2 ^ 2 * R(2) + 2 ^ 1 * R(1) >= 2 ^ 0
        vIntLast = vInt
    End If
    SumPowerToBool = R(vPos - 1)
End Function

Sub ScrollUp()
'Ativado o OnKey em pri. A tecla PageUp ScrollLock. |fffd|til em janela com Scroll limitado
    i1 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollRow
    ActiveWindow.LargeScroll up:=1
    i2 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollRow
    If i1 = i2 Then ActiveWindow.SmallScroll up:=1
End Sub
Sub ScrollDown()
    i1 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollRow
    ActiveWindow.LargeScroll Down:=1
    i2 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollRow
    If i1 = i2 Then ActiveWindow.SmallScroll Down:=1
End Sub
Sub ScrollLeft()
'Ativado o OnKey em pri. A tecla PageUp ScrollLock. |fffd|til em janela com Scroll limitado
    i1 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollColumn
    ActiveWindow.LargeScroll ToLeft:=1
    i2 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollColumn
    If i1 = i2 Then ActiveWindow.SmallScroll ToLeft:=1
End Sub
Sub ScrollRight()
    i1 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollColumn
    ActiveWindow.LargeScroll ToRight:=1
    i2 = ActiveWindow.Panes(ActiveWindow.ActivePane.Index).ScrollColumn
    If i1 = i2 Then ActiveWindow.SmallScroll ToRight:=1
End Sub

Function EXECtoVBAShell(sApp As String, sFile As String, lWinStl) As Long
'O EXEC() xlm s|fffd| suporta 128 caracteres
    On Error Resume Next
    EXECtoVBAShell = Shell(sApp & " """ & sFile & """", lWinStl)
    If Err.Number <> 0 Then EXECtoVBAShell = 0
End Function

Function MyWait(PauseSeg As Double, Optional bDovents As Boolean = True) As Boolean
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        If bDovents Then DoEvents    '|fffd|s vezes o DoEvents pode prejudicar um processo com disparo OnTime ou a|fffd||fffd|es do usu|fffd|rio como fechar Wb.
        If bDovents And PauseSeg > 2 Then Sleep 1    'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
    Loop
    MyWait = True
End Function

Function fCpapCfgTempFld()
'No XP, Vista e Win7 a pasta do Windows s|fffd| pode ser acessada com direitos administrativos. Ent|fffd|o levei para pasta temp.
    sPathSep = Application.PathSeparator
    fCpapCfgTempFld = ""
    If fTempFolder <> "" Then
        'Em Temp tenta a subpasta CpapCfgTemp, se n|fffd|o existir cria e se n|fffd|o tiver sucesso vai no raiz mesmo
        If VBA.FileSystem.Dir(fTempFolder & sPathSep & "CpapCfgTemp", vbDirectory) <> "" Then
            fCpapCfgTempFld = fTempFolder & sPathSep & "CpapCfgTemp"
        Else
            Err.Clear
            VBA.FileSystem.MkDir fTempFolder & sPathSep & "CpapCfgTemp"
            If Err.Number <> 0 Then
                fCpapCfgTempFld = fTempFolder
            Else
                fCpapCfgTempFld = fTempFolder & sPathSep & "CpapCfgTemp"
            End If
        End If
    End If
    If Len(fCpapCfgTempFld) < Len("c:\temp") Then fCpapCfgTempFld = CVErr(0)    'Evitar raiz
End Function

Function DirectoryVBA(Fn As String, Silence As Boolean, Optional lTry As Long = 7) As Boolean
'Substituir DIRECTORY() XLM com tentativas e controle de erro. Usa API porque ChDir n|fffd|o funciona com UNC
Retry:
    ret = 0
    R = R + 1
    If R > 1 Then Application.StatusBar = R & "|fffd| tentativa para ativar pasta " & Fn & "."    'Considerar digno de inform. s|fffd| a partir de algumas tentativas.
    ret = SetCurrentDirectory(Fn)
    If ret <> 0 Then GoTo End1
    If R - lTry * Int(R / lTry) = 0 And ret = 0 Then
        If Silence Then
            GoTo End1
        Else
            If MsgBox("Pasta sem acesso, sua esta|fffd||fffd|o pode n|fffd|o est|fffd| devidamente logada na rede ou a pasta n|fffd|o existe." & Chr(10) & Chr(10) & " Acione OK para mais " & lTry & " tentativas ou Cancelar para desistir.", vbCritical + vbOKCancel, "Falha! Ao Ativar a Pasta " & IIf(Len(Fn) > 34, "...", "") & Right(Fn, 34)) = vbOK Then GoTo Retry Else GoTo End1
        End If
    Else
        Application.Wait Now + TimeValue("00:00:01")
        GoTo Retry
    End If
End1:
    DirectoryVBA = ret <> 0
    If R > 1 Then MessageVBA False  ' Application.StatusBar = False
End Function
Attribute VB_Name = "Mod3Outros2"
Option Explicit
'Esse m|fffd|dulo contem material do Excel 2007
Private Declare Function MapFileAndCheckSum Lib "imagehlp.dll" _
        Alias "MapFileAndCheckSumA" (ByVal Filename As String, _
        HeaderSum As Long, CheckSum As Long) As Long
Public BotAcionado As Integer
Dim bScrUpd As Boolean
Dim Shp As Shape

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128      '  Maintenance string for PSS usage
End Type
'  dwPlatformId defines:
Private Const VER_PLATFORM_WIN32s = 0
Private Const VER_PLATFORM_WIN32_WINDOWS = 1
Private Const VER_PLATFORM_WIN32_NT = 2
Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long

Dim bHHCtrl_ocxLoad As Boolean: Public bHtmlHelp As Boolean

Function CheckXLAM(Optional bAlert As Boolean = False) As Boolean
    Const CHECKSUM_SUCCESS As Long = 0
    Const CHECKSUM_OPEN_FAILURE As Long = 1
    Const CHECKSUM_MAP_FAILURE As Long = 2
    Const CHECKSUM_MAPVIEW_FAILURE As Long = 3
    Const CHECKSUM_UNICODE_FAILURE As Long = 4

    Const lWaitCalcd = 139638
    Const lWaitHeader = 0
    'CheckXLAM = True: If bAlert Then MsgBox "Cuidado xlam liberado!" Else Exit Function
    Dim sFile As String
    Dim lHeader As Long
    Dim lCalcd As Long
    Dim lRet As Long
    sFile = ThisWorkbook.Path & "\cpap.xlam"
    lRet = MapFileAndCheckSum(sFile, lHeader, lCalcd)
    If lRet = CHECKSUM_SUCCESS Then CheckXLAM = (lWaitHeader = lHeader) And (lWaitCalcd = lCalcd)
    If CheckXLAM = False And bAlert Then MsgBox "Return: " & lRet & "   Esperado: " & CHECKSUM_SUCCESS & Chr(10) _
            & "Header: " & lHeader & "   Esperado: " & lWaitHeader & Chr(10) _
            & "Calculado: " & lCalcd & "   Esperado: " & lWaitCalcd & Chr(10) & Chr(10) _
            & "Verifique e salve as constantes esperadas em CheckXLAM() em cpap-ex8.mac", vbCritical, "Checksum (CRC) do Cpap.xlam Alterado!": Stop
    'CheckXLAM = True 'Usar durante edi|fffd||fffd|o para aceitar qualquer resultado
End Function

Function CheckInstRib() As Boolean
    On Error Resume Next    'Devido aos Mso esse projeto n|fffd|o pode ser totalmente compilado em Excel < 12. Comentar depois descomentar
    CheckInstRib = Application.CommandBars.GetVisibleMso("TabHome") = False _
            And Application.CommandBars.GetVisibleMso("TabInsert") = False _
            And Application.CommandBars.GetVisibleMso("TabFormulas") = False _
            And Application.CommandBars.GetVisibleMso("TabData") = False _
            And Application.CommandBars.GetVisibleMso("TabView") = False _
            And Application.CommandBars.GetVisibleMso("TabDeveloper") = False _
            And Application.CommandBars.GetVisibleMso("GroupAddInsMenuCommands") = False _
            And Application.CommandBars.GetVisibleMso("GroupAddInsToolbarCommands") = False
    If Err.Number <> 0 Then CheckInstRib = False
End Function

Function OpTVBA(sHelp As String, sCapt As String, sOpt1 As String, sOpt2 As String, sOpt3 As String, sOpt4 As String) As Long
'Este alerta de quatro op|fffd||fffd|es foi para substituir o XLM que usava figura em dialog n|fffd|o suportado no 20007
    Dim i As Long, sCurDir As String

    'Ajuda
    i = InStr(1, sHelp, "!"): sCurDir = CurDir(): bHtmlHelp = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("bHtmlHelp").Value
    'Com o proj. proteg. essa instru|fffd||fffd|o falha. A solu|fffd||fffd|o foi colocar ..\cpap.hlp nas propriedades e fazer o diret|fffd|rio do cpap ativo.
    'Application.VBE.VBProjects("VBAProjectCxIdent").HelpFile = Left(Identifi(2).Value, I - 1)
    If Mid(ThisWorkbook.Path, 2, 1) = ":" Then ChDrive ThisWorkbook.Path
    If Mid(ThisWorkbook.Path, 2, 1) = ":" Then ChDir ThisWorkbook.Path Else DirectoryVBA ThisWorkbook.Path, False
    If i > 0 Then FormOpT.HelpContextID = Right(sHelp, Len(sHelp) - i)

    bScrUpd = Application.ScreenUpdating
    Application.ScreenUpdating = True: PararEvitarVBA    'No Excel 2013 SDI foi necess|fffd|rio parar, pois OnTime continua age mesmo com userform modal
    With FormOpT
        .Caption = sCapt
        .Option1_Lb.Caption = sOpt1
        .Option2_Lb.Caption = sOpt2
        .Option3_Lb.Caption = sOpt3
        .Option4_Lb.Caption = sOpt4
        .Show
    End With
    Unload FormOpT
    If Mid(sCurDir, 2, 1) = ":" Then ChDrive sCurDir
    If Mid(sCurDir, 2, 1) = ":" Then ChDir sCurDir Else DirectoryVBA sCurDir, False
    OpTVBA = BotAcionado
    Application.ScreenUpdating = bScrUpd: If Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then ProxExec = Now + TimeValue("00:00:02"): Application.OnTime ProxExec, "EvitarVBA"
End Function

Sub TestOpTVBA()
    MsgBox OpTVBA("S:\Cpap\cpap.hlp!131", "Caption", "1", "2", "3", "")
End Sub

Function FresumoVBA(sHelp As String, sCapt As String, sPictureFile As String) As Boolean
'Substitui a F.resumo XLM que usava figura em dialog n|fffd|o suportado no 20007. Todas as figuras (caixa
'de texto) que podem at|fffd| ser exclu|fffd|das foram postas e salvas como WMF em FresumoPic.xls
    Dim i As Long, sCurDir As String
    BotAcionado = 0
    FresumoVBA = True
    If Dir(sPictureFile) = "" Then Exit Function
    On Error Resume Next

    'Ajuda
    i = InStr(1, sHelp, "!"): sCurDir = CurDir(): bHtmlHelp = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("bHtmlHelp").Value
    'Com o proj. proteg. essa instru|fffd||fffd|o falha. A solu|fffd||fffd|o foi colocar ..\cpap.hlp nas propriedades e fazer o diret|fffd|rio do cpap ativo.
    'Application.VBE.VBProjects("VBAProjectCxIdent").HelpFile = Left(Identifi(2).Value, I - 1)
    If Mid(ThisWorkbook.Path, 2, 1) = ":" Then ChDrive ThisWorkbook.Path
    If Mid(ThisWorkbook.Path, 2, 1) = ":" Then ChDir ThisWorkbook.Path Else DirectoryVBA ThisWorkbook.Path, False
    If i > 0 Then FormFresumo.HelpContextID = Right(sHelp, Len(sHelp) - i)

    bScrUpd = Application.ScreenUpdating
    Application.ScreenUpdating = True
    With FormFresumo
        .Caption = sCapt
        .Image1.Picture = LoadPicture(sPictureFile)
        .Show
    End With
    If Mid(sCurDir, 2, 1) = ":" Then ChDrive sCurDir
    If Mid(sCurDir, 2, 1) = ":" Then ChDir sCurDir Else DirectoryVBA sCurDir, False
    FresumoVBA = BotAcionado = 1
    Application.ScreenUpdating = bScrUpd
End Function

Sub TestFresumaVBA()
    MsgBox FresumoVBA("s:\Cpap\cpap.hlp!131", "Caption", "D:\Documents and Settings\Orlando Filho\Desktop\New Folder\JapText_3.wmf")
End Sub

Function FormatMoveObjectVBA(lLeft As Long, lTop As Long, vRef As Range, Optional vStr As String) As Boolean
'Bug 2010 e 2007, o FORMAT.MOVE XLM n|fffd|o funciona. Isso parece que s|fffd| ocorre com embed com link.
'Em rela|fffd||fffd|o ao original tem vantagens ainda de n|fffd|o precisar selecionar e pode estar oculto, basta informar o nome.
    Dim Shp As Shape
    Dim ActWb As Workbook
    Dim ActSh    'As Worksheet
    Dim bScrUpd As Boolean: bScrUpd = Application.ScreenUpdating: Application.ScreenUpdating = True    'No 2013 fiz por similaridade com GetDocument42VBA com shapes

    Set ActWb = ActiveWorkbook
    Set ActSh = ActiveWorkbook.ActiveSheet

    On Error Resume Next
    If vStr = "" Then vStr = Selection.Name
    If Err.Number = 0 Then Set Shp = ActSh.Shapes(vStr)
    If Err.Number <> 0 Then
        MsgBox "O objeto '" & vStr & "' n|fffd|o foi encontrado em " & ActWb.Name & "!", vbCritical + vbOKOnly, "CPAP - FormatMoveObjectVBA"
        FormatMoveObjectVBA = False: Application.ScreenUpdating = bScrUpd
        Exit Function
    End If

    Shp.Left = vRef.Left + lLeft
    Shp.Top = vRef.Top + lTop

    FormatMoveObjectVBA = (Err.Number = 0): Application.ScreenUpdating = bScrUpd
End Function


Function HideObjectVBA(vStr As String, bHide As Boolean) As Boolean
'Bug 2007. Tanto em VBA (form button) quanto em XLM so funciona se pasta e planilha estiverem
'ativa, visivel e desprotegida. E ainda ScreenUpdate true logo depois de unhide. Isso parece
'que s|fffd| ocorre logo em seguida a convers|fffd|o para 2007, depois disso o bug some. Mas essa fun|fffd||fffd|o
'n|fffd|o funciona dentro de macro acionada por ON.ENTRY, dar erro de objeto n|fffd|o encontrado.
    Dim Shp As Shape
    Dim ActWb As Workbook
    Dim ActSh    'As Worksheet
    Dim bWbHid As Boolean
    Dim bShHid As Boolean

    Set ActWb = ActiveWorkbook
    Set ActSh = ActiveWorkbook.ActiveSheet
    bScrUpd = Application.ScreenUpdating
    bWbHid = ActWb.Windows(1).Visible
    bShHid = ActSh.Visible

    On Error Resume Next
    Set Shp = ActSh.Shapes(vStr)
    If Err.Number <> 0 Then
        MsgBox "O objeto '" & vStr & "' n|fffd|o foi encontrado em " & ActWb.Name & "!", vbCritical + vbOKOnly, "CPAP - HideObjectVBA"
        Application.ScreenUpdating = bScrUpd
        HideObjectVBA = False
        Exit Function
    End If

    'Primeiro tenta normal, pois uma fez feito, enquanto nao for fechado, funciona ok. Alem disso
    'o bug pode ser corrigido no futuro e tem as versoes anteriores
    On Error Resume Next
    Shp.Visible = Not bHide
    If Err.Number = 0 Then HideObjectVBA = True: Exit Function
    On Error GoTo 0

    Application.ScreenUpdating = True

    If bWbHid = False Or bShHid = False Then
        ActWb.Windows(1).Visible = True
        ActSh.Visible = True
        ActSh.Activate
        ActWb.Activate
        DoEvents
    End If

    On Error Resume Next    'Por seguranca isso deve ser habilitado na versao para uso
    Shp.Visible = Not bHide

    If bWbHid = False Or bShHid = False Then
        ActSh.Visible = bShHid
        ActWb.Windows(1).Visible = bWbHid
        ActSh.Activate
        ActWb.Activate
    End If

    Application.ScreenUpdating = bScrUpd
    HideObjectVBA = True
End Function

Function TextBoxVBA(sString As String, sObjName As String, Optional lStart, Optional lLength)
'Bug 2007. o TEXT.BOX() XLM nao funciona
    If IsMissing(lStart) Then lStart = 0
    If IsMissing(lLength) Or lStart = 0 Then lLength = 0
    Dim bScrUpd As Boolean: bScrUpd = Application.ScreenUpdating: Application.ScreenUpdating = True    'No 2013 fiz por similaridade com GetDocument42VBA com shapes

    On Error Resume Next
    Set Shp = ActiveWorkbook.ActiveSheet.Shapes(sObjName)
    If Err.Number <> 0 Then
        MsgBox "O objeto '" & sObjName & "' n|fffd|o existe!", vbCritical + vbOKOnly, "CPAP"
        TextBoxVBA = False: Application.ScreenUpdating = bScrUpd
        Exit Function
    End If

    'Alguns shapes sao convertido para um novo no Excel 2007, tipo wordart. Primeiro tenta normal, se falhar...
    If lLength = 0 Then
        If lStart = 0 Then
            'Indica subtituir tudo entao tem que limpar primeiro pois pode ter mais de 255 caracteres
            Do While Shp.TextFrame.Characters.Text <> ""
                Shp.TextFrame.Characters.Text = ""
            Loop
            Shp.TextFrame.Characters.Text = sString
        Else
            Shp.TextFrame.Characters(lStart).Text = sString
        End If
    Else
        Shp.TextFrame.Characters(lStart, lLength).Text = sString
    End If

    If Err.Number <> 0 Then
        Err.Clear
        Shp.TextEffect.Text = IIf(lStart = 1, "", Shp.TextEffect.Text) & sString
    End If

    If Err.Number = 0 Then TextBoxVBA = lStart + Len(sString) - 1 Else TextBoxVBA = False
    Application.ScreenUpdating = bScrUpd
End Function

Function GetDocument42VBA()
'O GET.DOCUMENT(42) n|fffd|o funciona com os novos shapes
    Dim ArrayShps() As String
    Dim Count As Long: Dim bScrUpd As Boolean: bScrUpd = Application.ScreenUpdating: Application.ScreenUpdating = True    'No 2013 foi necess|fffd|rio ScreenUpdating em TabPr
    Count = 0
    For Each Shp In ActiveWorkbook.ActiveSheet.Shapes
        If Shp.Type <> msoComment Then    'A priori, aceitar qualquer tipo, menos os shapes de coment|fffd|rios
            Count = Count + 1
            ReDim Preserve ArrayShps(1 To Count)
            ArrayShps(Count) = Shp.Name
        End If
    Next
    GetDocument42VBA = IIf(Count = 0, CVErr(2042), ArrayShps())   '2042 erro gerado por Application.ExecuteExcel4Macro("Get.Document(42)")
    Application.ScreenUpdating = bScrUpd
End Function

Function OptionsViewVBA(Optional bFormula, Optional bStatus, Optional lNotes) As Boolean
'No 2007 OPTIONS.VIEW(;;1) XLM n|fffd|o funciona. O OPTIONS.VIEW(TRUE) as vezes falha.
    On Error Resume Next
    If Not IsMissing(bFormula) Then Application.DisplayFormulaBar = bFormula
    If Not IsMissing(bStatus) Then Application.DisplayStatusBar = bStatus
    If Not IsMissing(lNotes) Then Application.DisplayCommentIndicator = -lNotes      '-1 xlCommentIndicatorOnly
    OptionsViewVBA = Err.Number = 0
End Function

Function EnableEventsVBA(bEnable As Boolean) As Boolean
'Habilita e desabilita os eventos. Quando trabalhando com eventos ligado (<2007) apenas para evitar
'a minimiza|fffd||fffd|o de janela |fffd| necess|fffd|rio por seguran|fffd|a desabilitar ao abrir um XL e abilitar em seguida.
    Dim ErrBakNumb As Long, ErrBakDesc As String: ErrBakNumb = Err.Number: ErrBakDesc = Err.Description: On Error Resume Next 'Antes |fffd| necess|fffd|rio fazer o backup de Err existente, pois o controle de erro pode estar sendo usado como em OpenVBA.
    Dim bEventsOn As Boolean: bEventsOn = Workbooks("cpap_pri.mac").Sheets(1).Range("bEventsOn").Value   'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, o bEventsOn n|fffd|o vem mais pelo argumento, agora aqui s|fffd| se bEnable for True e bEventsOn tamb|fffd|m que Application.EnableEvents=True.
    If bEnable And bEventsOn Then If nCls1.App Is Nothing Then Set nCls1.App = Application    'Ativa os eventos do aplicativo em Class1
    Application.EnableEvents = bEnable And bEventsOn: EnableExc7Verif bEnable   'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, sempre que abilitar ou desabilitar evento, faz tamb|fffd|m EnableExc7Verif. E passou a trabalhar com eventos ligado no 2007 em diante tamb|fffd|m.
    EnableEventsVBA = (Err.Number = 0): Err.Number = ErrBakNumb: Err.Description = ErrBakDesc
End Function

Function MinimizeRibbon() As Boolean
'Alturas da Ribbon em pixels? 56-Min QAT acima; 80-Min QAT abaixo; 147-Max QAT acima; 173-Max QAT abaixo
    On Error Resume Next
    If Application.CommandBars("Ribbon").Height > 80 Then Application.SendKeys "^{F1}"
    MinimizeRibbon = Err.Number = 0
End Function

Function MessageVBA(bLogical As Boolean, Optional vText, Optional bEchoTrue As Boolean = False) As Boolean
'No Excel 2007 o icone de gravar macro aparece na Status quando ready. O workaround foi
'trabalhar sempre customizado. Entao direcionei todos os MESSAGE(FALSE) XLM pra c|fffd| e decidir
'qual melhor Ready do CPAP.
    On Error Resume Next
    If IsMissing(vText) Then bLogical = False Else If vText = "" Then bLogical = False
    If bLogical Then
        Application.StatusBar = vText
    Else
        Dim bScrUpd As Boolean: bScrUpd = Application.ScreenUpdating: If bEchoTrue Then Application.ScreenUpdating = True  'Em Car, Aco e Avu depois do message(false) restaura o |fffd|ltimo Recomp Tela 95. Parece um bug que foi resolvido definindo em Echo(True)
        If bEchoTrue And Val(Application.Version) >= 15 Then Application.StatusBar = "  ": Application.DisplayStatusBar = False: Application.DisplayStatusBar = True   'No Excel 2013 SDI resolveu o bug de status apagado ao iniciar e o do AutoCalcular
        Dim NumVer As Long: NumVer = Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("NumVer").Value: If NumVer = 0 Then NumVer = 13
        Application.StatusBar = "Pronto  |  CPAP " & Choose(NumVer - 6, "7,0", "", "2000", "2002", "", "12.0", "", "14.0", "15.0")
        If bEchoTrue Then Application.ScreenUpdating = bScrUpd
    End If
    MessageVBA = Err.Number = 0
End Function

Public Function IsWinNTxp() As Boolean
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNTxp = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 5)
End Function

Public Function IsWinNTvista() As Boolean
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNTvista = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6)
End Function

Public Function ClearClipb() As Boolean
'Ao usar copy(), principalmente depois de um PasteSpecial em Windows virtual, dava mensagem de
'que n|fffd|o foi poss|fffd|vel limpar o clipboard. Onde a c|fffd|pia era s|fffd| de valores usei o CopyV aqui e
'em outros casos usei essa fun|fffd||fffd|o para limpar o clipboard antes de copiar. Essa solu|fffd||fffd|o mostrou-se
'at|fffd| melhor do que usando API. A instabilidade ainda era maior se rodasse em Shared Folder.
    Dim i As Long, ActWb As Workbook    'No Excel 2013 SDI foi necess|fffd|rio ActWb, pois perde foco se ativo oculto como ord em mp
    Application.DisplayAlerts = False: Set ActWb = ActiveWorkbook
    For i = 1 To 3
        On Error Resume Next
        ThisWorkbook.Sheets(1).Range("A1").Copy
        MyWait 0.1
        Application.CutCopyMode = False
    Next
    Application.DisplayAlerts = True: ActWb.Activate
    ClearClipb = Err.Number = 0
End Function

Function GetStatusBarName() As String
'No Excel 2007 a barra de status |fffd| uma barra de ferramenta que em XLM tem nome local. J|fffd| a Ribbon n|fffd|o parece variar
    On Error Resume Next
    If Val(Application.Version) >= 12 Then GetStatusBarName = Application.CommandBars("Status Bar").NameLocal
End Function

Private Function CopyDirPiniVBA(sNomXL As String, sDirPini As String, sDirP As String) As Boolean    'Existe igual em cpapf.xla e ex8
    Dim sNomeXLini As String
    Dim bCopy As Boolean    ':If InStr(1, sNomXL, "mp.mac") > 0 Then Stop
    If InStr(1, sNomXL, Application.PathSeparator) = 0 Or LCase(Left(sNomXL, Len(sDirPini))) = LCase(sDirPini) Or LCase(Left(sNomXL, Len(sDirP))) <> LCase(sDirP) Then CopyDirPiniVBA = True: Exit Function   'N|fffd|o |fffd| necess|fffd|rio copiar para DirP se n|fffd|o vier com path explicitado ou pelo path o arquivo estiver sendo aberto diretamente de DipPini mesmo ou n|fffd|o estiver sendo aberto de DirP.
    sNomeXLini = sDirPini & Mid(sNomXL, Len(sDirP) + 1)
    On Error Resume Next
    Dim sRet As String
    sRet = Dir(sNomeXLini)    'Se gerar erro retornando vazio, indica rede com problema e n|fffd|o falta do arquivo.
    If (Err.Number = 0 And sRet = "") And Dir(sNomXL) = "" Then MsgBox "O arquivo " & sNomeXLini & " n|fffd|o foi encontrado. Reinicie o CPAP e, se o problema persistir, reinstale.", vbCritical, "CPAP|fffd| - Erro em CopyDirPiniVBA!": Exit Function
    If (Err.Number <> 0 And sRet = "") And Dir(sNomXL) <> "" Then MsgBox "O arquivo " & sNomeXLini & " n|fffd|o p|fffd|de ser acessado. Ser|fffd| usado o backup existente em " & sNomXL & ".", vbInformation, "CPAP|fffd| - Erro em CopyDirPiniVBA!": CopyDirPiniVBA = True: Exit Function    'Se a rede falhar usa o que est|fffd| em temp
    If Dir(sNomXL) = "" Then bCopy = True Else If FileLen(sNomeXLini) <> FileLen(sNomXL) Or FileDateTime(sNomeXLini) <> FileDateTime(sNomXL) Then bCopy = True    'Se n|fffd|o existir copiar e, se existir, comparar antes de copiar.
    If Not bCopy Then CopyDirPiniVBA = True: Exit Function
    Dim i As Long
    Do    'Copiar com retentativa
        If i > 0 Then MyWait 0.5
        Err.Clear: i = i + 1
        FileCopy sNomeXLini, sNomXL
    Loop While Err.Number <> 0 And i < 20
    If Err.Number <> 0 Then MsgBox Err.Number & ": " & Err.Description, vbCritical, "CPAP|fffd| - Erro em CopyDirPiniVBA!" Else CopyDirPiniVBA = True
End Function

Sub DicasAvu()    'Para criticar se fechado, os OnTimes para Dicas em avu chama aqui primeiro.
    If Not WbIsOpen("cpap_avu.mac") Then Exit Sub
    If LCase(ActiveWorkbook.Name) <> "cpap_avu.mac" Then Application.OnTime Now + TimeValue("00:00:02"), "DicasAvu": Exit Sub 'Se avu n|fffd|o estiver ativo esperar 2
    Application.Run "cpap_avu.mac!Dicas"
End Sub

Sub DicasCar()    'Para criticar se fechado, os OnTimes para Dicas em avu chama aqui primeiro.
    If Not WbIsOpen("cpap_car.mac") Then Exit Sub
    If LCase(ActiveWorkbook.Name) <> "cpap_car.mac" Then Application.OnTime Now + TimeValue("00:00:02"), "DicasAvu": Exit Sub  'Se car n|fffd|o estiver ativo esperar 2
    Application.Run "cpap_car.mac!Dicas"
End Sub

Function MouseCursor(sCur As String) As Boolean
    Dim lCur As Long
    If sCur = "IBeam" Then
        lCur = xlIBeam
    ElseIf sCur = "NorthwestArrow" Then
        lCur = xlNorthwestArrow
    ElseIf sCur = "Wait" Then
        lCur = xlWait
    Else
        lCur = xlDefault
    End If
    Application.Cursor = lCur: MouseCursor = True
End Function

Function HelpVBA(Optional ByVal sHelpFile As String, Optional ByVal HelpContextID As String, Optional ByVal lWinStyle As Long) As Boolean
'No Excel 2013 resolvi converter a ajuda WinHelp (hlp) para HtmlHelp (chm). O HELP() XLM funciona, inclusive
'com AutoTitle, mas, ao contr|fffd|rio do Help VBA, sempre exibe navigation pane que n|fffd|o |fffd| muito |fffd|til principalmente
'no FAQ. Aqui no VBA, at|fffd| com API posso, criar mais op|fffd||fffd|es de janela.
    If lWinStyle = 0 And Not bHHCtrl_ocxLoad Then Exit Function     'O Excel 2003 gera GPF em Win7 se HHCtrl.ocx tiver sido carregado pelo menos uma vez, mesmo para fechar HH_CLOSE_ALL. Ent|fffd|o, se n|fffd|o usou help, n|fffd|o necessita usar API para fechar.
    If lWinStyle = 0 And bHHCtrl_ocxLoad Then HelpVBA sHelpFile, 0, 2: DoEvents    'mas se a janela estiver aberta (vis|fffd|vel) n|fffd|o gera GPF, assinm antes de com HH_CLOSE_ALL carrega e exibe primeiro a janela no t|fffd|pico padr|fffd|o.
    If lWinStyle > 1 Then bHHCtrl_ocxLoad = True

    If Not IsNumeric(HelpContextID) And InStr(1, HelpContextID, "!") > 0 Then HelpContextID = Mid(HelpContextID, InStr(1, HelpContextID, "!") + 1)    'Converte, pois pode ser passado como texto assim: ...\cpap.hlp!131"
    If Not IsNumeric(HelpContextID) Then HelpContextID = 0

    Dim cHHelpWhatsThis1 As cHHelpWhatsThis: Set cHHelpWhatsThis1 = New cHHelpWhatsThis
    HelpVBA = cHHelpWhatsThis1.HelpVBA(sHelpFile, CLng(HelpContextID), lWinStyle): Set cHHelpWhatsThis1 = Nothing
End Function

Public Function New_cHHelpWhatsThis() As cHHelpWhatsThis    'Criar a classe e passa como objeto para outros Wb via chamada Run() usando late binding.
    Set New_cHHelpWhatsThis = New cHHelpWhatsThis
    bHHCtrl_ocxLoad = True
End Function

Public Function MemOpenTryFix(bReadOnly As Boolean) As Boolean
    Dim DirBD As String, lSize As Long, sRestArq As String
    DirBD = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirBD").Value)
    sRestArq = vbCrLf & vbCrLf & "Dica! Fora do CPAP, o comando ''Restaurar Arquivos de Iniciar CPAP " & Workbooks("cpap_pri.mac").Sheets(1).Range("NomRed").Value & "'' no ''Menu Iniciar do Windows > Todos os Programas > CPAP'' pode resolver. Voc|fffd| tamb|fffd|m pode executar, diretamente na pasta do CPAP, o arquivo RestArq.exe."
    MemOpenTryFix = True    'Para continuar tentando em XLM, se nenhum alerta ou ok em algum alerta. Se cancelar algum alerta sai do CPAP imediatamente.
    'Se n|fffd|o encontrado mem e seus baks
    If Dir(DirBD & "\Banco\cpap-mem.mac") = "" And Dir(DirBD & "\Banco\CpapMem1.mac") = "" And Dir(DirBD & "\Banco\CpapMem2.mac") = "" Then _
            MemOpenTryFix = AlertaCpap(2, "", "Em duas tentativas, o arquivo " & DirBD & "\Banco\cpap-mem.mac" & " n|fffd|o foi encontrado. Talvez n|fffd|o exista ou h|fffd| problema com a conex|fffd|o de rede ou drive. Continuar tentando. OK?"): Exit Function
    'Se n|fffd|o encontrado mem, mas um de seus baks
    If Dir(DirBD & "\Banco\cpap-mem.mac") = "" And (Dir(DirBD & "\Banco\CpapMem1.mac") <> "" Or Dir(DirBD & "\Banco\CpapMem2.mac") <> "") Then _
            MemOpenTryFix = AlertaCpap(2, "", "Em duas tentativas, o arquivo " & DirBD & "\Banco\cpap-mem.mac" & " n|fffd|o foi encontrado, mas seu backup sim. Continuar tentando. OK?" & sRestArq): Exit Function
    'Se abriu na |fffd|ltima tentativa, mas read-only
    If bReadOnly Then _
            MemOpenTryFix = AlertaCpap(2, "", "O arquivo " & DirBD & "\Banco\cpap-mem.mac" & " existe, mas em duas tentativas n|fffd|o foi poss|fffd|vel abri-lo para leitura e escrita. Talvez outra esta|fffd||fffd|o da rede esteja travada com ele aberto ou seus direitos n|fffd|o s|fffd|o suficientes para abrir arquivo para leitura e escrita na pasta. Consulte o administrador de seu sistema ou rede. Continuar tentando. OK?"): Exit Function
    'Se tamanho muito diferente dos baks
    If Dir(DirBD & "\Banco\CpapMem1.mac") <> "" Then lSize = FileLen(DirBD & "\Banco\CpapMem1.mac")
    If lSize = 0 And Dir(DirBD & "\Banco\CpapMem2.mac") <> "" Then lSize = FileLen(DirBD & "\Banco\CpapMem2.mac")
    If lSize = 0 And Dir(DirBD & "\Banco\Cpap-Mem.bak") <> "" Then lSize = FileLen(DirBD & "\Banco\Cpap-Mem.bak")
    If lSize <> 0 Then If FileLen(DirBD & "\Banco\cpap-mem.mac") < lSize * 0.5 Or FileLen(DirBD & "\Banco\cpap-mem.mac") > lSize * 1.5 Then _
            MemOpenTryFix = AlertaCpap(2, "", "O arquivo " & DirBD & "\Banco\cpap-mem.mac" & " existe, mas seu tamanho n|fffd|o |fffd| o esperado talvez esteja corrompido. Continuar tentando. OK?" & sRestArq): Exit Function
End Function
Attribute VB_Name = "Mod3Outros3"
Option Explicit
Declare Function GetFocus Lib "user32" () As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Function ExtractIcon Lib "Shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
Declare Function DestroyIcon Lib "user32" (ByVal hIcon As Long) As Long
Declare Function SetFocusAPI Lib "user32" Alias "SetFocus" (ByVal hWnd As Long) As Long
'
' API Constants
Global Const WM_SETICON = &H80
'
' Various Windows Handles
Dim hPreviousXLMAINBigIcon As Long
Dim hPreviousXLMAINSmallIcon As Long
Dim hPreviousEXCEL9BigIcon As Long
Dim hPreviousEXCEL9SmallIcon As Long
Dim hNewIcon As Long
Dim hWndXLMAIN As Long
Dim hWndEXCEL9 As Long

Dim theIconSource As String

Function SetPerceptorIcon() As Boolean    'No 2013 SDI, foi necess|fffd|rio aqui tambem para cada janela de wb aberto. Nas vers|fffd|es anteriores s|fffd| existia e era suficiente em cpap.xla. Aqui |fffd| chamado s|fffd| de pri.
    Dim theIconIndex As Long
    Dim istat As Long

    theIconSource = ThisWorkbook.Path & "\Applicat1.ico"    ' can be any valid windows icon source(.EXE, .DLL, .ICO)
    If Dir(theIconSource) = "" Then theIconSource = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirPini").Value) & "\cpap.exe"
    If Dir(theIconSource) = "" Then MsgBox "Arquivo de |fffd|cone n|fffd|o encontrado!", vbCritical, "CPAP|fffd| - Error!": Exit Function

    theIconIndex = 0    'the index to the icon within the source. If this index is 0, the ExtractIcon function returns the first icon in the source

    istat = SetNewIcon(theIconSource, theIconIndex)    ' do the deed
    SetPerceptorIcon = True
End Function

'   A routine to change the standard Excel Icons
Function SetNewIcon(theIconSource As String, theIconIndex As Long) As Long
    Dim L As Long
    ' Get handle to active window (Classname XLMAIN).
    If Val(Application.Version) > 9 Then hWndXLMAIN = Application.hWnd Else hWndXLMAIN = FindWindow("XLMAIN", Application.Caption)
    L = SetFocusAPI(hWndXLMAIN)
    hWndEXCEL9 = GetFocus()
    ' Getthe icon from the source
    hNewIcon = ExtractIcon(0, theIconSource, 0)
    SetNewIcon = hNewIcon                       ' return code from function
    If hNewIcon = Null Or hNewIcon = 1 Then MsgBox "|fffd|cone n|fffd|o encontrado! No arquivo " & theIconSource, vbCritical, "CPAP|fffd| - Error!": Exit Function         ' 1 means invalid icon source, 0means no icons in source

    hPreviousXLMAINBigIcon = SendMessage(hWndXLMAIN, WM_SETICON, 1, hNewIcon)  ' Big Icon
    hPreviousXLMAINSmallIcon = SendMessage(hWndXLMAIN, WM_SETICON, 0, hNewIcon)    ' Small Icon
    hPreviousEXCEL9BigIcon = SendMessage(hWndEXCEL9, WM_SETICON, 1, hNewIcon)  ' Big Icon
    hPreviousEXCEL9SmallIcon = SendMessage(hWndEXCEL9, WM_SETICON, 0, hNewIcon)    ' Small Icon
TidyUp:
End Function
'
'   A routine to restore the standard Excel Icons
Sub restoreXLIcon()
    Dim hIcon As Long
    Dim lRetv As Long

    hIcon = SendMessage(hWndXLMAIN, WM_SETICON, True, hPreviousXLMAINBigIcon)     ' restore Big Icon
    hIcon = SendMessage(hWndXLMAIN, WM_SETICON, False, hPreviousXLMAINSmallIcon)  ' restore Small Icon
    hIcon = SendMessage(hWndEXCEL9, WM_SETICON, True, hPreviousEXCEL9BigIcon)     ' restore Big Icon
    hIcon = SendMessage(hWndEXCEL9, WM_SETICON, False, hPreviousEXCEL9SmallIcon)  ' restore Small Icon
    lRetv = DestroyIcon(hIcon)      ' I think this is necessary to free memory reserved in ExtractIcon

End Sub

'From Bill Manville (Re: Message)
'MVP - Microsoft Excel, Oxford, England
'===============

Attribute VB_Name = "Mod3Outros4"
Option Explicit
'Para detectar a Janela VBE aberta via API
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hWnd As Long, lpdwProcessId As Long) As Long
Declare Function EnumThreadWindows Lib "user32" (ByVal dwThreadId As Long, ByVal lpfn As Long, ByVal lParam As Long) As Long
Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Declare Function IsWindowVisible Lib "user32" (ByVal hWnd As Long) As Long
Declare Function GetActiveWindow Lib "user32" () As Long   'Janela em foco no THEREAD que chamou
Declare Function GetForegroundWindow Lib "user32" () As Long    'Janela em o foco no WINDOWS
Dim ThreadCount As Integer                                 ' Number of Thread Windows
Public bVBEwinVis As Boolean: Dim VBE_hWnd As Long

'Para detectar VbExe running
'Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
'Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
'Const PROCESS_ALL_ACCESS = &H1F0FFF
Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Const GWL_HINSTANCE = (-6)

'Para EnableExc7Verif
Public Declare Function EnumChildWindows Lib "user32" (ByVal hWndParent As Long, ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long
Private Declare Function SendMessageByStr& Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String)
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Const GWL_ID = (-12)
Private Const WM_SETTEXT = &HC
Private Const WM_GETTEXT = &HD
Dim lExc7Verif As String '(Long)
Dim lControlId As Long, lCntCallExc7Vrf As Long
Public bOffTmpExc7Verif As Boolean

Function IsVBEVisible() As Boolean    'Para facilitar eventuais manuten|fffd||fffd|o, mantive todo o c|fffd|digo feito nos toEXE.
'Foi necess|fffd|rio porque .MainWindow.Visible d|fffd| erro, se o acesso ao VBE is not trustee no Office 10 em
'diante. Neste caso, mesmo aberto, retorna false. Deixei assim mesmo e, em caso de erro, melhorei usando API.
    Dim RetVal As Long: Dim ExcelObj As Application: Dim dHostAppVer As Long: Dim App_hWnd As Long: Set ExcelObj = Application: dHostAppVer = Val(ExcelObj.Version): If dHostAppVer > 9 Then App_hWnd = ExcelObj.hWnd Else App_hWnd = FindWindow("XLMAIN", ExcelObj.Caption)

    If VBE_hWnd <> 0 Then                                  'Se o handle do VBE j|fffd| tiver sido detectado, fica mais e menos intrusivo confirmar e acompanhar por ele e evita um AddressOf.
        Dim WinClassBuf As String * 255
        RetVal = GetClassName(VBE_hWnd, WinClassBuf, 255)
        If Left(WinClassBuf, RetVal) = "wndclass_desked_gsk" Then
            IsVBEVisible = IsWindowVisible(VBE_hWnd) <> 0
            Exit Function
        End If
    End If

    On Error Resume Next
    IsVBEVisible = ExcelObj.VBE.MainWindow.Visible

    If (Err.Number <> 0 And dHostAppVer > 9) Or (IsVBEVisible And VBE_hWnd = 0) Then    'Tentar API para melhorar. A segunda condi|fffd||fffd|o |fffd| para controle pelo handle, se v|fffd|sivel.
        Dim lParam As Long, ProcessID As Long, ThreadID As Long
        ThreadID = GetWindowThreadProcessId(App_hWnd, ProcessID)
        RetVal = EnumThreadWindows(ThreadID, AddressOf EnumThreadProc, lParam)
        IsVBEVisible = bVBEwinVis
    End If
End Function

'Para detectar a Janela VBE aberta via API
Function EnumThreadProc(ByVal lhWnd As Long, ByVal lParam As Long) As Long
    Dim RetVal As Long
    Dim WinClassBuf As String * 255, WinTitleBuf As String * 255
    Dim WinClass As String, WinTitle As String

    RetVal = GetClassName(lhWnd, WinClassBuf, 255)
    WinClass = StripNulls(WinClassBuf)                     ' remove extra Nulls & spaces
    RetVal = GetWindowText(lhWnd, WinTitleBuf, 255)
    WinTitle = StripNulls(WinTitleBuf)
    ThreadCount = ThreadCount + 1
    'see the Windows Class and Title for top level Window
    'Debug.Print "Thread Window Class = "; WinClass; ", Title = "; WinTitle

    EnumThreadProc = True                                  'Continua a procura
    If Not bVBEwinVis Then
        If WinClass = "wndclass_desked_gsk" Then           'Se encontrar a class do VBE window, bVBEwinVis fica true para esse API callback
            bVBEwinVis = IsWindowVisible(lhWnd) <> 0       'Verif. se est|fffd| vis|fffd|vel. Encontrar n|fffd|o |fffd| suficiente, pois se um c|fffd|digo precisar ser compilado no v|fffd|o a janela do VBE |fffd| criada, mas fica oculta
            VBE_hWnd = lhWnd
            EnumThreadProc = False                         'Para a procura se encontrou, oculta ou n|fffd|o, pois s|fffd| pode existir uma janela VBE
        End If
    End If
End Function
Function StripNulls(OriginalStr As String) As String
' This removes the extra Nulls so String comparisons will work
    If (InStr(OriginalStr, Chr(0)) > 0) Then
        OriginalStr = Left(OriginalStr, InStr(OriginalStr, Chr(0)) - 1)
    End If
    StripNulls = OriginalStr
End Function

'Function IsVbExeRun() As Boolean 'Nesta op|fffd||fffd|o vinha o PID do exe que rodava sem form, mas depois foi necess|fffd|rio o form para troca de info, ent|fffd|o preferi passar hWnd deste como no XLtoEXE, mas vou deixar aqui para uma eventualidades
'    Dim lPID As Long, lReturn As Long, lProcess As Long
'    lPID = Application.Evaluate(Workbooks("cpap_pri.mac").Names("VbExeShl").Value)
'    If lPID = 0 Then IsVbExeRun = True: Exit Function    'Se 0, n|fffd|o foi iniciado por exe, ent|fffd|o ignora cr|fffd|tica
'
'    lProcess = OpenProcess(PROCESS_ALL_ACCESS, 0&, lPID): CloseHandle lProcess
'    IsVbExeRun = lProcess <> 0 'Se teve sucesso em abrir e fechar o processo, ent|fffd|o est|fffd| rodando
'End Function
Function IsVbExeRun() As Boolean
    Dim hWnd As Long
    hWnd = Application.Evaluate(Workbooks("cpap_pri.mac").Names("VbExeShl").Value)
    If hWnd = 0 Then IsVbExeRun = True: Exit Function    'Se 0, n|fffd|o foi iniciado por exe, ent|fffd|o ignora cr|fffd|tica
    IsVbExeRun = GetWindowLongA(hWnd, GWL_HINSTANCE) <> 0
End Function

Sub TestEnableExc7Verif()
    Workbooks("cpap_pri.mac").Names.Add "VbExeShl", , , , , , , , , "=" & 329722 'No debug do cpap.exe(ExcelFre.vbp) pego hWnd de um Msgbox, assim debug aqui e o StaySpying l|fffd|.
    EnableExc7Verif
End Sub
Function EnableExc7Verif(Optional bEnable As Boolean = True, Optional bTemp As Boolean) As Boolean   'bEnable True pede o exe para atualizar lSumExc7LastUpdt e ficar verificando. False, pede pausa enquando abre ou fecha Wb.
    Dim hWnd As Long: EnableExc7Verif = True    'A priori, sempre retornar true.
    hWnd = Application.Evaluate(Workbooks("cpap_pri.mac").Names("VbExeShl").Value)
    If bEnable And bTemp Then bOffTmpExc7Verif = False 'Religa ap|fffd|s ter sido desligado temporariamente.
    If hWnd = 0 Or bOffTmpExc7Verif Then Exit Function     'Se 0, n|fffd|o foi iniciado por exe, ent|fffd|o ignora cr|fffd|tica. Ou se desligado temporariamente
    If lExc7Verif = "" Then If Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("InicioFim").Value Then Exit Function    'Para s|fffd| inciar depois que Ir.jap em pri for finalizado
    If Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then Exit Function
    If bEnable = False And bTemp Then bOffTmpExc7Verif = True 'Desliga temporariamente, ignorando chamada com bEnable at|fffd| ser religado. O padr|fffd|o |fffd| Enable/Disable ao abrir wb, mas h|fffd| momento como na indexa|fffd||fffd|o por tr|fffd|s de um form em arq.mac que isso s|fffd| torna a opera|fffd||fffd|o muito lenta, ent|fffd|o desliga temporariamente, ignorando chamadas.
        
    lExc7Verif = IIf(bEnable, "1", CStr(hWnd)): lControlId = 0: lCntCallExc7Vrf = lCntCallExc7Vrf + 1
    EnumChildWindows hWnd, AddressOf EnumChildWin, ByVal 0&
    If lControlId = 0 Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 7: Application.Run "cpap_pri.mac!Inst.incor" 'Sair CPAP se controle n|fffd|o encontrado
End Function

Public Function EnumChildWin(ByVal hWnd As Long, ByVal lParam As Long) As Long
    Dim sSave As String
    Dim RetVal As Long
    Dim sClassName As String: sClassName = String(255, Chr(0))    'Start as a buffer
    Dim sWindowText As String
    Dim StartDate As Date

    RetVal = GetClassName(hWnd, sClassName, 255)     'Get window class name
    sClassName = StripNulls(sClassName)

    If sClassName = "ThunderRT6TextBox" Or sClassName = "ThunderTextBox" Then    'No debug do VB6 o nome da classe n|fffd|o tem RT6
        lControlId = GetWindowLong(hWnd, GWL_ID)    'Get control Id.
        If lControlId <> 0 Then            'Only where lControlId is
            RetVal = SendMessageByStr(hWnd, WM_SETTEXT, 0, lExc7Verif)   'Set window text. |fffd| persistente e retorna 1 ou 0 se falhar.
            If RetVal = 0 Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 8: Application.Run "cpap_pri.mac!Inst.incor": Exit Function    'Sair CPAP se conseguir passar info em 10s.

            If lCntCallExc7Vrf > 1 Then    'No VM trava ao iniciar, talvez seja o alerta para ativa|fffd||fffd|o do Excel. Ent|fffd|o salta a primeira, mesmo porque passando no teste anterior j|fffd| |fffd| bem seguro e este teste s|fffd| tem muita import|fffd|ncia quando desabilitando.
                Do    'Loop para s|fffd| continuar com a certeza de que foi capturado.
                    MyWait 0.1, False  'O MyWait sem DoEvents para evitar disparo de OnTime's ou fechamento wb pelo usu|fffd|rio.
                    If StartDate = 0 Then StartDate = Now Else If DateDiff("s", StartDate, Now) > 3 * 60 Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 9: Application.Run "cpap_pri.mac!Inst.incor": Exit Function
                    sWindowText = String(255, Chr(0))   'Reset as a buffer
                    SendMessageByStr hWnd, WM_GETTEXT, 255, sWindowText    'Get window text.
                    sWindowText = StripNulls(sWindowText) ': Application.StatusBar = sWindowText & " " & (sWindowText = "Text1") & " " & Now: If ShiftDown Then Stop
                Loop While sWindowText <> "Text1"
            End If
        End If
    End If
    EnumChildWin = True    'Continue enumeration
End Function
Attribute VB_Name = "M|fffd|d1OnTime"
Public ProxExec As Date
Dim LastSelec As String
Dim IntervVerif As String
Dim ManterAcelerado As Integer: Public bAutoCalcOff As Boolean
Public nCls1 As New Class1
Dim Bv As Integer   'Num de barras vis|fffd|veis
Dim appWinSDIst As Long, appWinSDItop As Double, appWinSDIleft As Double, appWinSDIheight As Double, appWinSDIwidth As Double

Public Sub InfoAreaTrabVBA()
'Capta configura|fffd||fffd|o da |fffd|rea de trabalho em VBA, imposs|fffd|vel em XLM
    With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
        .Offset(1, 1).Value = Application.AutoCorrect.CorrectSentenceCap
        .Offset(2, 1).Value = Application.EditDirectlyInCell
    End With
    If Val(Application.Version) > 8 Then
        #If VBA6 Then
            With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
                .Offset(3, 1).Value = Application.ShowWindowsInTaskbar
                .Offset(4, 1).Value = Application.CommandBars.AdaptiveMenus
            End With
            If Val(Application.Version) > 9 Then InfoAreaTrabVBAExcel10
        #End If
    End If
    '    Set nCls1.App = Application   'Ativa eventos do aplicativo em Class1
    Application.CommandBars("Toolbar List").Enabled = False
End Sub
Sub InfoAreaTrabVBAExcel10()
    #If VBA6 Then
        With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
            .Offset(5, 1).Value = Application.CommandBars.DisableCustomize
            .Offset(6, 1).Value = Application.CommandBars.DisableAskAQuestionDropdown
            .Offset(7, 1).Value = Application.ErrorCheckingOptions.BackgroundChecking
            .Offset(8, 1).Value = Application.SmartTagRecognizers.Recognize
            .Offset(9, 1).Value = Application.AutoRecover.Enabled
            .Offset(10, 1).Value = Application.MapPaperSize
            .Offset(11, 1).Value = Application.DefaultSheetDirection
        End With

        'Desabilitar as chaves de acelera|fffd||fffd|o do Excel 2003 no 2007
        If Val(Application.Version) >= 12 Then
            For Each c In Application.CommandBars("&Legacy Keyboard Support").Controls
                If InStr(1, c.Caption, "&&&&") = 0 Then c.Caption = Replace(c.Caption, "&", "&&")
            Next
            Application.MultiThreadedCalculation.Enabled = False
        End If
    #End If
End Sub

Public Function WorkSpaceVBA(Col As Long)
'Configurar a |fffd|rea de trabalho em VBA, imposs|fffd|vel em XLM
    With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
        Application.AutoCorrect.CorrectSentenceCap = .Offset(1, Col).Value
        Application.EditDirectlyInCell = .Offset(2, Col).Value
    End With
    If Val(Application.Version) > 8 Then
        #If VBA6 Then
            With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
                Application.ShowWindowsInTaskbar = .Offset(3, Col).Value
                Application.CommandBars.AdaptiveMenus = .Offset(4, Col).Value
            End With
            If Val(Application.Version) > 9 Then WorkspaceVBAExcel10 Col
        #End If
    End If
    If Col = 4 Then
        Application.CommandBars("Toolbar List").Enabled = True
        Application.CommandBars("Cell").Reset
        Application.CommandBars("Xlm Cell").Reset
    End If
End Function
Sub WorkspaceVBAExcel10(Col As Long)
    #If VBA6 Then
        With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
            Application.CommandBars.DisableCustomize = .Offset(5, Col).Value
            Application.CommandBars.DisableAskAQuestionDropdown = .Offset(6, Col).Value
            Application.ErrorCheckingOptions.BackgroundChecking = .Offset(7, Col).Value
            Application.SmartTagRecognizers.Recognize = .Offset(8, Col).Value
            Application.AutoRecover.Enabled = .Offset(9, Col).Value
            Application.MapPaperSize = .Offset(10, Col).Value
            Application.DefaultSheetDirection = .Offset(11, Col).Value
        End With
    #End If
End Sub

Public Sub EvitarVBA()
'Este procedimento verifica de 6 em 6 seg. se o editor VBA _
  est|fffd| aberto e se h|fffd| mais de uma barra de comando em exibi|fffd||fffd| _
  Como usa on.time que interfere no protetor de tela, em 5 min _
  sem atividade ativa o menu que elimina a interfer|fffd|ncia.
    Static Dem
    Static DemReg
    Static DataValidade
    If Dem = "" Then Dem = Workbooks("cpap_pri.mac").Sheets(1).Range("Dem").Value
    If DemReg = "" Then DemReg = Dem And Workbooks("cpap_pri.mac").Sheets(1).Range("NomRed").Value <> "DEMONSTRATIVO"
    If DataValidade = "" Then DataValidade = Workbooks("cpap_pri.mac").Sheets(1).Range("DataPer").Value

    'Application.ScreenUpdating = False 'Piorou
    Application.EnableCancelKey = xlDisabled
    Static Count
    Static Lastcell
    Static LastcellCS

    'Os argumentos de dem e Data de validade acabou n|fffd|o sendo necess|fffd|rios _
     pois esta solu|fffd||fffd|o vai funcionar em qualquer execu|fffd||fffd|o no Excel 8
    If IntervVerif = "" Then IntervVerif = "00:00:06"
    IntervDesOnTime = IIf(IntervVerif = "00:00:06", 40, 240)

    EvitarVBAb   'Protegendo barras def. pelo CPAP e s|fffd| aceita uma em exibi|fffd||fffd|o.
    If Bv > 1 Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 1: GoTo Sair

    AddInnCount = Application.ExecuteExcel4Macro("COLUMNS(DOCUMENTS(2))")    'O cpap n|fffd|o tem Add-in, exceto no 2007
    If Not IsError(AddInnCount) Then
        If Val(Application.Version) >= 12 Then
            Set AddInnRib = Application.Workbooks("cpap.xlam")
            If AddInnRib.Sheets(1).Cells(65800, 260).Locked Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 2: GoTo Sair            'Verifica mais uma vez a autenticidade por estilo padr|fffd|o
            AddInnCount = AddInnCount - 1
        End If
        If AddInnCount > 0 Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 3: GoTo Sair
    End If

    If Application.EnableEvents <> Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("bEventsOn").Value Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 4: GoTo Sair    'Pode indicar intrus|fffd|o atrav|fffd|s da primazia do ev op ou de Auto_open
    If Application.EnableEvents Then If nCls1.App Is Nothing Then Set nCls1.App = Application  'EnableEventsVBA True  'Para recuperar poss|fffd|vel perda de Class1 se trabalhando ligado. Ao segurar ESC para cancelar atualizando tabela parece que perde o Class1.
    If Not IsVbExeRun Then Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 5: GoTo Sair    'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, detecta se VbExe via API.
    On Error GoTo ErrorHandler
    If 2013 <> 2013 Then AppActivate "Microsoft Visual Basic" Else If Not IsVBEVisible Then GoTo ErrorHandler  'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, detecta visibilidade via VBA ou API s|fffd| na inst|fffd|ncia rodando o CPAP. Nas vers|fffd|es anteriores, se n|fffd|o houvesse erro ao ativar o t|fffd|tulo, ent|fffd|o estaria vis|fffd|vel em qualquer inst|fffd|ncia.
    AppActivate "CPAP": Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 6
Sair:
    If Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then
        ProxExec = Now + TimeValue("00:00:02")
        Application.OnTime ProxExec, "EvitarVBA"
        Application.Run "cpap_pri.mac!Inst.incor"
    Else
        MsgBox "Sairia, mas EvitarVBA foi desativada."
        If Val(Application.Version) <> 10 Then MsgBox "Excel " & Application.Version & "! Evitar salvar nesta vers|fffd|o, mas na 10 (2002-XP)"
        Set nCls1.App = Nothing   'Desabilita eventos do aplicativo
    End If
    GoTo Fim
ErrorHandler:
    If ActiveWorkbook Is Nothing Then ProxExec = Now + TimeValue("00:00:02"): Application.OnTime ProxExec, "EvitarVBA": Exit Sub    '2013 mas era bug antigo, mais detalhe em Lembrete2013.txt.
    'Estes comandos |fffd| para evitar o on.time atrapalhe o protetor de tela _
     das tr|fffd|s solu|fffd||fffd|es a melhor |fffd| focar um controle de menu.
    If Now - ProxExec > TimeValue("00:00:03") Or _
            Application.WindowState = xlMinimized Or _
            Lastcell <> Application.ActiveWindow.ActiveCell.Address(ReferenceStyle:=xlR1C1) Or _
            LastcellCS <> Windows(1).VisibleRange.Address(ReferenceStyle:=xlR1C1) Then
        Count = 0
    Else
        Count = Count + 1
        If Count > IntervDesOnTime Then
            If Dem And Not DemReg Then
                If DataValidade > Date Then vVenc = "vence em " Else vVenc = "venceu em "
                MsgBox "Aproveitando a pausa, gostaria de alertar que esta " & _
                        "vers|fffd|o demonstrativa " & vVenc & Application.Text(DataValidade, "dd/mm/yy") _
                        & "." & Chr(10) & Chr(10) & "Para uma instala|fffd||fffd|o autorizada, contate via Internet: " _
                        & Chr(10) & "contato@cpap.com.br <> http://cpap.com.br.", , "CPAP|fffd| - Vers|fffd|o Demonstrativa"
            Else
                Resume ResetErro
ResetErro:
                On Error GoTo Saltando
                For i = 1 To CommandBars.Count
                    If CommandBars(i).Visible Then Exit For
                Next
                CommandBars(i).Controls(1).SetFocus
Saltando:
            End If
            Count = 0
        End If
    End If
    If Not bAutoCalcOff Then AutoCalcular Else ManterAcelerado = 0
    ProxExec = Now + TimeValue(IntervVerif)
    Application.OnTime ProxExec, "EvitarVBA"
    Lastcell = Application.ActiveWindow.ActiveCell.Address(ReferenceStyle:=xlR1C1)
    LastcellCS = Windows(1).VisibleRange.Address(ReferenceStyle:=xlR1C1)
    If ActiveWorkbook.IsInplace Then Application.OnTime Now, "'" & ThisWorkbook.Path & "\cpap_pri.mac'!InPlaceExit"

    'No Excel 12 nao ha como desabilar opcoes no Status Bar entao usar esse on.time para...
    If Val(Application.Version) >= 12 Then
        If ActiveWindow.View <> xlNormalView Then ActiveWindow.View = xlNormalView: AcelAutoCalcular 20    '... evitar xlPageBreakPreview que o cpap nao usa
        If Application.StatusBar = False Then MessageVBA False    'So uma seguranca ate que todos os MESSAGE(FALSE) XLM seja contornados para MessageVBA
    End If
    If Val(Application.Version) < 15 Then If ActiveWindow.WindowState <> xlMaximized Then ActiveWindow.WindowState = xlMaximized: AcelAutoCalcular 20        'Isso |fffd| tempor|fffd|rio, pois por engano fiz IF(2=2;TRUE;WINDOW.MAXIMIZE()) quando deveria ser &IF(AppVer>=15;TRUE;WINDOW.MAXIMIZE()) em todos os .mac. Mas s|fffd| |fffd| |fffd|til antes do 2007 onde o controle de minimizar janelas de wb est|fffd| desabilitado na Ribbon.

    'No Excel 2013 SDI cada wb tem sua janela com seus barras de menu e ribbon que precisam ser verif. e alinhadas...
    If Val(Application.Version) >= 15 Then WinSDIverifRibbon: WinSDIalinhSetAll

    If bOffTmpExc7Verif Then EnableExc7Verif True, True    'O padr|fffd|o |fffd| sempre ligado. Desliga temp ao indexar ligando logo em seguida. Esta |fffd| uma seguran|fffd|a se houver falha durando o desligamento.
    Application.ExecuteExcel4Macro ("cpap_pri.mac!RegWinDir()") 'No 2013
Fim:
End Sub

Public Sub PararEvitarVBA()
'Suspende a pr|fffd|xima execu|fffd||fffd|o programada
    On Error Resume Next
    Application.OnTime ProxExec, "EvitarVBA", , False
End Sub


Public Sub SairEvitarVBA()
'Para sair de vez do CPAP
    On Error Resume Next
    Application.OnTime ProxExec, "EvitarVBA", , False

    'Retornando configura|fffd||fffd|o de ao iniciar
    With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
        If .Offset(1, 1).Value <> "" Then
            Application.AutoCorrect.CorrectSentenceCap = .Offset(1, 1).Value
            Application.EditDirectlyInCell = .Offset(2, 1).Value
            If Val(Application.Version) > 8 Then
                #If VBA6 Then
                    Application.ShowWindowsInTaskbar = .Offset(3, 1).Value
                    Application.CommandBars.AdaptiveMenus = .Offset(4, 1).Value
                    If Val(Application.Version) > 9 Then SairEvitarVBAExcel10
                #End If
            End If
        End If
    End With

    Application.CommandBars("Toolbar List").Enabled = True

    Application.CommandBars("Cell").Reset
    Application.CommandBars("Xlm Cell").Reset
    Application.CommandBars("SomeFacesOnly").Delete
    Application.CommandBars("MenuCPAP1").Delete
    Application.CommandBars("MenuCPAP2").Delete
    Application.CommandBars("BarraDeSa|fffd|da").Delete
End Sub
Sub SairEvitarVBAExcel10()
    #If VBA6 Then
        With Workbooks("cpap_pri.mac").Sheets(1).Range("InfoAreaTrabVBA")
            Application.CommandBars.DisableCustomize = .Offset(5, 1).Value
            Application.CommandBars.DisableAskAQuestionDropdown = .Offset(6, 1).Value
            Application.ErrorCheckingOptions.BackgroundChecking = .Offset(7, 1).Value
            Application.SmartTagRecognizers.Recognize = .Offset(8, 1).Value
            Application.AutoRecover.Enabled = .Offset(9, 1).Value
            Application.MapPaperSize = .Offset(10, 1).Value
            Application.DefaultSheetDirection = .Offset(11, 1).Value
        End With

        'Abilitar as chaves de acelera|fffd||fffd|o do Excel 2003 no 2007
        If Val(Application.Version) >= 12 Then
            For Each c In Application.CommandBars("&Legacy Keyboard Support").Controls
                Do While InStr(1, c.Caption, "&&") > 0
                    c.Caption = Replace(c.Caption, "&&", "&")
                Loop
            Next
        End If
    #End If
End Sub

Public Sub EvitarVBAb()
'Verif. num de barras em exib e protege barra de menu de usuar. ativada pelo cpap
    Dim c As CommandBar
    Bv = 0
    For Each c In CommandBars
        If c.Visible Then
            Bv = Bv + 1
            If c.BuiltIn = False And c.Protection < 10 Then k = c.Name   'Quarda nome pra proteger ap|fffd|s loop
            'Ignora exib. da barra de Clipboard no Excel 2000, Task Pane no 2002 mas oculta
            If c.BuiltIn = True And (c.Name = "Clipboard" Or c.Name = "Task Pane") Then
                c.Visible = False
                Bv = Bv - 1
                AcelAutoCalcular 20
            End If
            If Val(Application.Version) >= 15 And c.ID = 2149 Then Bv = Bv - 1    'No Excel 2013 permite a visibilidade da barra de Buy sem codename. Existe desde 12 eventualmente posso antecipar, mas parece ser um problema mais no Office 365 que pode estar sempre vencendo temp.
        End If
    Next

    'So no Excel 12 permite a visibilidade das novas barras Ribbon e Status Bar
    If Val(Application.Version) >= 12 Then Bv = Bv + CommandBars("Status Bar").Visible + CommandBars("Ribbon").Visible

    If Bv = 1 And k <> "" Then CommandBars(k).Protection = msoBarNoCustomize + msoBarNoMove + msoBarNoChangeVisible + msoBarNoChangeDock
End Sub

Public Sub AutoCalcular()
    Static Soma As Double
    Static Quant As Long
    If Application.CutCopyMode = False Then Else Exit Sub
    Application.Calculate
    For Each Wkb In Application.Workbooks
        Wkb.Saved = True
    Next
    On Error GoTo Sair
    i = Selection.Rows.Count
    ia = Selection.Areas.Count   'Para permitir soma em uma |fffd|nica linha selecionada com mais de uma |fffd|rea. Bom para avu.
    If (UCase(ActiveWorkbook.Name) = "CPAP_TAB.MAC" Or UCase(ActiveWorkbook.Name) = "CPAP_EDB.MAC") And Selection.Cells.Count > 1 Then ia = 2    ' For|fffd|a soma em uma |fffd|nica linha ao visualizar tabela, mas requer pelo menos duas cel selecionadas.
    If IsError(Application.Caller) Then qCh = "" Else qCh = Application.Caller
    If qCh <> "CalcVBA" Then
        If i = 1 And ia = 1 And IntervVerif = "00:00:06" Then Exit Sub
        IntervVerif = IIf(i > 1 Or ia > 1 Or ManterAcelerado > 0, "00:00:01", "00:00:06")
        If LastSelec = Selection.Address(ReferenceStyle:=xlR1C1) Then GoTo Sair
    End If
    Application.StatusBar = "Calculando...."
    Application.EnableCancelKey = xlErrorHandler
    Soma = 0
    Quant = 0
    For Each c In Selection()
        If c.Value <> "" Then
            c1 = Application.WorksheetFunction.IsNumber(c.Value)
            c2 = c.NumberFormat   '"NumPositivos;NumNegativos;Zeros"
            c2 = c2 = "#,##0.00" _
                    Or c2 = "#,##0.00%" _
                    Or c2 = "#,##0.00;[Red]#,##0.00" _
                    Or c2 = "#,##0.00;[Red]-#,##0.00" _
                    Or c2 = "#,##0.00_);[Red](#,##0.00)" _
                    Or c2 = "[Red]-#,##0.00;#,##0.00;0.00" _
                    Or c2 = "[Red]-#,##0.00;#,##0.00;" _
                    Or c2 = "0.00##"
            c3 = c.RowHeight > 0
            c4 = c.ColumnWidth > 0
            If c1 And c2 And c3 And c4 Then
                Quant = Quant + 1
                Soma = Soma + c.Value
            End If
        End If
    Next
    LastSelec = Selection.Address(ReferenceStyle:=xlR1C1)
Sair:
    Static LastStatusMsg     'No Excel 2013 SDI MessageVBA com True resolveu o bug onde o status ficava sem resposta e tinha que deslocar janela. S|fffd| precisa do workaround uma vez logo ao ativar o Wb como pode ser o mesmo vou ter que fazer sempre que alterar a mensagem
    If Soma = 0 Or Quant < 2 Or (i = 1 And ia = 1) Then
        If Val(Application.Version) >= 15 And False <> LastStatusMsg Then MessageVBA False, , True: LastStatusMsg = False
        MessageVBA False    ' Application.StatusBar = False
        ManterAcelerado = ManterAcelerado - IIf(ManterAcelerado > 0, 1, 0)
        If Len(Application.ActiveWindow.ActiveCell.NoteText()) > 0 Then
            'Evita piscar r|fffd|pido ao exibir nota na c|fffd|l. ativa
            IntervVerif = "00:00:06"
            ManterAcelerado = 0
        End If
    Else
        Dim sStatusMsg As String
        sStatusMsg = "Selec.: " & Quant & "  Soma: " & Format(Soma, "#,##0.00")
        If Val(Application.Version) >= 15 And sStatusMsg <> LastStatusMsg Then MessageVBA False, , True: LastStatusMsg = sStatusMsg
        Application.StatusBar = sStatusMsg
        ManterAcelerado = 6
    End If
    If qCh = "CalcVBA" Then
        Workbooks("cpap_pri.mac").Sheets(1).Range("CalcVal").Value = Soma
        Workbooks("cpap_pri.mac").Sheets(1).Range("CalcDec").Value = 2
    End If
End Sub

Function AcelAutoCalcular(Optional nSeg As Integer = 6)
'For|fffd|a a acelera|fffd||fffd|o do autocalcular durante um certo n|fffd|mero de segundos
    IntervVerif = "00:00:01"
    ManterAcelerado = nSeg
End Function

Function AutoCalcOff(bAutoCalcOff1 As Boolean)    'Necess|fffd|rio desligar porque de repente quando abrindo arquivo em car e avu disparava. Assim desliga antes da primeira sele|fffd||fffd|o e vai ligar s|fffd| ao Recompor Tela
    bAutoCalcOff = bAutoCalcOff1
End Function

Public Function CritArqTmp() As Boolean
'Antes de iniciar fazer cr|fffd|ticas de arquivos tmp e cfg criados em execu|fffd||fffd|es anteriores que podem,
'se corrompidos, causar proplemas.
    On Error Resume Next
    DirP = ThisWorkbook.Path: DirBD = Application.Evaluate(Workbooks("cpap_pri.mac").Names("DirBD").Value)
    If Dir(DirBD & "\cpap_ind.tmp") <> "" Then
        If FileLen(DirBD & "\cpap_ind.tmp") < 500 Or FileLen(DirBD & "\cpap_ind.tmp") > 10000 Then Kill DirBD & "\cpap_ind.tmp"
    End If

    DirXLST = Application.StartupPath
    If Dir(DirXLST & "\cpap-cfg.tmp") <> "" And Dir(DirP & "\cpap-cfg.mac") <> "" Then
        If FileLen(DirXLST & "\cpap-cfg.tmp") < FileLen(DirP & "\cpap-cfg.mac") * 0.8 Or FileLen(DirXLST & "\cpap-cfg.tmp") > FileLen(DirP & "\cpap-cfg.mac") * 1.5 Then
            Kill DirXLST & "\cpap-cfg.tmp"
            FileCopy DirP & "\cpap-cfg.mac", DirXLST & "\cpap-cfg.tmp"    'Aproveita e copia assim n|fffd|o precisa usar o SaveAs XLM
        End If
    End If

    'Posso at|fffd| criticar o cpap-mem.mac aqui tamb|fffd|m

    CritArqTmp = True
End Function

Sub WinSDIverifRibbon()
'No Excel 2013 SDI cada wb tem sua janela com seus barras de menu e ribbon. Assim a janela no final de um comando pode n|fffd|o ser
'a ativa do MenuCfg chamado. No final dos pricipais comandos com sucesso vou verificar, mas se houver desvios de erro ent|fffd|o
'usar OnTime do EvitarVBA para verificar aqui.
    If WbIsOpen("cpap.xlam") Then
        Static sLastActTry As String
        If Application.CommandBars("Ribbon").Visible Then
            If CheckInstRib Then
                If Not MenuAtivIsUpdt Then    'Se Ribbon visivel, verificada e barra de menu n|fffd|o atualizada na janela ativa, atualiza
                    'MsgBox "MenuCfg vai ser chamado de EvitarVBA!"    'Em teste alerta antes chamar e ver efeito
                    MenuCfg
                End If
                sLastActTry = ""
            Else
                'MsgBox "Ribbon seria ocultada em EvitarVBA!"     'Em teste alerta antes chamar e ver efeito
                'Application.ExecuteExcel4Macro ("SHOW.TOOLBAR(""Ribbon"",FALSE)")  'Se Ribbon vis|fffd|vel e n|fffd|o passou na verifica|fffd||fffd|o, oculta por seguran|fffd|a. Comentei porque estava atrapalhando as tentativas de ShowRib1 e era apenas uma seguran|fffd|a extra talvez desnecess|fffd|ria.
            End If
        Else
            If sLastActTry <> ActiveWorkbook.Name And ActiveWorkbook.Windows(1).Visible _
                    And (LCase(Right(ActiveWorkbook.Name, 4)) = ".mac" Or LCase(Right(ActiveWorkbook.Name, 4)) = ".pla" _
                    Or ActiveWorkbook.Windows(1).Caption = "Montando Tabela de Pre|fffd|os - Visualizando" _
                    Or ActiveWorkbook.Windows(1).Caption = "Acompanhamentos de  Contrato" _
                    Or ActiveWorkbook.Windows(1).Caption = "Planilha de Amortiza|fffd||fffd|o") Then
                'MsgBox "ShowRib1 vai ser chamado de EvitarVBA!"    'Em teste alerta antes chamar e ver efeito
                Run "cpap_jap.mac!ShowRib1"  'Se Ribbon oculta, faz uma |fffd|nica tentativa para exibir no worbook ativo, mas s|fffd| se n|fffd|o tiver oculto e for .mac ou pla ou rel. sem arq de tab. de pre|fffd|o ou ord acompanhamento sem mp.pla ou de amortiz.
            End If
            sLastActTry = ActiveWorkbook.Name
        End If
        If sLastActTry <> ActiveWorkbook.Name Then sLastActTry = ""
    End If
End Sub

Sub WinSDIalinhSetAll()
'No Excel 2013 SDI cada wb tem sua janela com suas posi|fffd||fffd|es e tamanhos se o App estiver em normal style. No CPAP |fffd| importante
'alinhar para n|fffd|o ficar dan|fffd|ando na tela ao navegar entre m|fffd|dulos. Vou usar OnTime do EvitarVBA para alinhar aqui.
    Dim Wn As Window
    Dim bGetAndSet As Boolean
    Dim ActWin As Window
    Dim bScrUpd As Boolean
    If Application.Visible = False Then Exit Sub
    If Application.WindowState = xlMinimized Or Application.Top < -1000 Then Exit Sub    'Talvez um bug no Win8 e Excel 2013, quando minimizado reporta como xlNormal apesar de ter pos e tamanho de minimizado (-24000, -23999, 21, 120), ent|fffd|o vou cosiderar top menor que -1000 como minimizado e evitar alinhamento.
    If Application.WindowState <> appWinSDIst Then bGetAndSet = True
    If Application.WindowState = xlNormal Then If Application.Top <> appWinSDItop Or Application.Left <> appWinSDIleft Or Application.Height <> appWinSDIheight Or Application.Width <> appWinSDIwidth Then bGetAndSet = True
    If bGetAndSet Then
        WinSDIalinhGet
        Set ActWin = Application.ActiveWindow
        bScrUpd = Application.ScreenUpdating: Application.ScreenUpdating = False: AcelAutoCalcular 20
        For Each Wn In Application.Windows
            If Wn.Visible Then WinSDIalinhSet Wn
            If Wn.Visible = False Then Wn.Visible = True: WinSDIalinhSet Wn: Wn.Visible = False
        Next
        ActWin.Activate
        Application.ScreenUpdating = bScrUpd
    End If
End Sub

Sub WinSDIalinhGet()
    If Val(Application.Version) < 15 Then Exit Sub
    appWinSDIst = Application.WindowState
    If appWinSDIst = xlNormal And Application.Top > -1000 Then
        appWinSDItop = Application.Top
        appWinSDIleft = Application.Left
        appWinSDIheight = Application.Height
        appWinSDIwidth = Application.Width
    End If
End Sub

Sub WinSDIalinhSet(Optional Wn As Variant)
    If Val(Application.Version) < 15 Then Exit Sub
    If IsMissing(Wn) Then Set Wn = Application    'Active window
    bEnableEvents = Application.EnableEvents: Application.EnableEvents = False
    Wn.WindowState = appWinSDIst
    If appWinSDIst = xlNormal Then
        Wn.Top = appWinSDItop + 1.5    'N|fffd|o sei porque requer este ajuste fino em todas as vers|fffd|es.
        Wn.Left = appWinSDIleft
        Wn.Height = appWinSDIheight
        Wn.Width = appWinSDIwidth
    End If
    Application.EnableEvents = bEnableEvents
End Sub

Public Function PauseEvitarVBA(Optional lTime As Long = -2) As Boolean
'Suspende a pr|fffd|xima execu|fffd||fffd|o programada e reprograma outra em lTime
    PararEvitarVBA
    ProxExec = Now + IIf(lTime < 0, -1, 1) * TimeSerial(0, 0, Abs(lTime)) 'TimeValue("00:00:02")
    Application.OnTime ProxExec, "EvitarVBA"
    PauseEvitarVBA = True
End Function
Attribute VB_Name = "M|fffd|d2Menu"
Public vBarra As Object
Public RangeCfg As Range
Public qCh As String: Dim sMenuAtivId As String
Public MenuBeginGroup As Boolean

Sub MenuCfg()
    qCh = Workbooks("cpap_pri.mac").Sheets(1).Range("qChShMenu").Value
    i = InStr(1, qCh, "/")
    qChM = Mid(qCh, i + 1, 200)
    qCh = Left(qCh, i - 1)

    If Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then On Error Resume Next
    'No Excel 2003 Run gera error em aco ao dar enter sem alterar dados. N|fffd|o consegui saber o
    'porque e como parece n|fffd|o ter import|fffd|ncia, preferi temporariamente evitar o alerta e
    'suspender esse sub quando rodando fechado
    If WbIsOpen(qCh) Then Application.Run "'" & qCh & "'!CmdEnabled" Else Exit Sub    'No 2013 foi necess|fffd|rio que rechama |fffd|ltimo MenuCfg e qCh j|fffd| pode estar fechado.
    If Err.Number <> 0 Then Exit Sub

    'Montando ShortMenu
    Set vBarra = CommandBars(qChM)
    Set RangeCfg = Workbooks(qCh).Sheets(1).Range("MenuVBASh")
    'Limpando a barra de menu
    vBarra.Reset
    Dim c As CommandBarControl
    For Each c In vBarra.Controls
        c.Delete
    Next
    MenuBeginGroup = True
    MontarMenu
    'Colocando o menu principal no ShortMenu
    Set Menu = vBarra.Controls.Add(msoControlPopup)
    Menu.Caption = "Menu"
    Set vBarra = Menu
    Set RangeCfg = Workbooks(qCh).Sheets(1).Range("MenuVBA")
    MontarMenu

    'Montando Barra de Menu do CPAP
    'Fica alternando entre dois nomes, pois ao acionar uma macro atrav|fffd|s de um bot|fffd|o este n|fffd|o pode ser deletado enquando n|fffd|o se encerrar a macro.
    Static MenuCPAP As String
    'Foi observado que a vari|fffd|vel MenuCPAP perde o valor quer como p|fffd|blica ou como static quando tudo protegido e houver halt()
TentarOutraBarra:
    MenuCPAP = "MenuCPAP" & IIf(MenuCPAP = "MenuCPAP1", "2", "1")
    '   MsgBox MenuCPAP
    Set vBarra = Nothing
    On Error Resume Next
    Set vBarra = CommandBars(MenuCPAP)
    On Error GoTo 0
    If vBarra Is Nothing Then Set vBarra = CommandBars.Add(Name:=MenuCPAP, Position:=msoBarTop, MenuBar:=True, Temporary:=True)
    Set RangeCfg = Workbooks(qCh).Sheets(1).Range("MenuVBA")
    'Limpando a barra de menu
    On Error Resume Next
    For Each c In vBarra.Controls
        c.Delete
    Next
    On Error GoTo 0
    If vBarra.Controls.Count > 0 Then GoTo TentarOutraBarra
    MenuBeginGroup = False
    MontarMenu
    vBarra.Visible = True: sMenuAtivId = "Empty": If vBarra.Controls.Count > 0 Then sMenuAtivId = CLng(Timer * 1000): vBarra.Controls(1).Tag = sMenuAtivId  '2013 SDI cada janela tem sua barra de menu e este id vai confirmar se a barra de menu da janela ativa foi a |fffd|ltima montada aqui.

    'Adicionando bot|fffd|es ao final da barra de menu
    Set RangeCfg = Nothing
    On Error Resume Next
    Set RangeCfg = Workbooks(qCh).Sheets(1).Range("MenuVBABot")
    On Error GoTo 0
    If RangeCfg Is Nothing Then Else AdicBotAoMenu

    'Copiar barra de menu para a Ribbon se visivel
    If Val(Application.Version) >= 12 Then
        If Application.CommandBars("Ribbon").Visible And Not WbIsOpen("cpap.xlam") Then Application.ExecuteExcel4Macro ("SHOW.TOOLBAR(""Ribbon"",FALSE)")  'No 2013, al|fffd|m de ser mais uma seguran|fffd|a, evita que o OnTime a seguir carregue sem o controle AbrirXLM.
        If Application.CommandBars("Ribbon").Visible Then Application.OnTime Now, "'" & ThisWorkbook.Path & "\cpap.xlam'!InvalidateRibbon"     'No 2013 foi necess|fffd|rio explicitar o path, apesar do xlam j|fffd| aberto como se o 2013 fosse suportar abrir arquivos de mesmo nome."
    End If
End Sub

Sub MontarMenu()
    Static MenuNome As String
    Static SubMenuNome As String
    Static CmdHelpFile As String

    For Each nRow In RangeCfg.Rows
        If nRow.Cells(1, 5).Value = 3 Then GoTo IgnorarComando
        If nRow.Cells(1, 4) = "" And vBarra.Type = msoBarTypePopup Then GoTo IgnorarComando
        If nRow.Cells(1, 1) <> "Id" Then MenuNome = nRow.Cells(1, 1)
        SubMenuBeginGroup = InStr(1, nRow.Cells(1, 2), ">") = 1
        If nRow.Cells(1, 2) <> "Id" Then SubMenuNome = Application.WorksheetFunction.Substitute(nRow.Cells(1, 2), ">", "")
        CmdBeginGroup = InStr(1, nRow.Cells(1, 3), ">") = 1
        CmdNome = Application.WorksheetFunction.Substitute(nRow.Cells(1, 3), ">", "")
        CmdAction = IIf(InStr(1, nRow.Cells(1, 4), "!") = 0, "'" & qCh & "'!", "") & nRow.Cells(1, 4)
        CmdEnabled = nRow.Cells(1, 5) = "" Or nRow.Cells(1, 5) = 1 Or nRow.Cells(1, 5) = 11
        CmdState = IIf(nRow.Cells(1, 5) > 10, msoButtonDown, msoButtonUp)
        If InStr(1, nRow.Cells(1, 6), "!") > 1 Then CmdHelpFile = Left(nRow.Cells(1, 6), InStr(1, nRow.Cells(1, 6), "!") - 1)
        If InStr(1, nRow.Cells(1, 6), "!") > 1 Then CmdHelpCtxId = Mid(nRow.Cells(1, 6), InStr(1, nRow.Cells(1, 6), "!") + 1, 200) Else CmdHelpCtxId = nRow.Cells(1, 6)
        CmdTag = nRow.Cells(1, 7)

        'Comando na barra
        If MenuNome = "" And SubMenuNome = "" Then Set Cmd = vBarra.Controls.Add(IIf(vBarra.Type = msoBarTypePopup, msoControlButton, msoControlPopup))

        'Verificando exist|fffd|ncia de Menu
        If MenuNome <> "" Then
            Set Menu = Nothing
            On Error Resume Next
            Set Menu = vBarra.Controls(MenuNome)
            On Error GoTo 0
            If Menu Is Nothing Then
                Set Menu = vBarra.Controls.Add(msoControlPopup)
                Menu.Caption = MenuNome
                If MenuBeginGroup Then
                    Menu.BeginGroup = True
                    MenuBeginGroup = False
                End If
            End If
        End If

        'Comando em Menu
        If MenuNome <> "" And SubMenuNome = "" Then Set Cmd = Menu.Controls.Add(msoControlButton)

        'Verificando exist|fffd|ncia de SubMenu
        If SubMenuNome <> "" Then
            Set SubMenu = Nothing
            On Error Resume Next
            Set SubMenu = Menu.Controls(SubMenuNome)
            On Error GoTo 0
            If SubMenu Is Nothing Then
                Set SubMenu = Menu.Controls.Add(msoControlPopup)
                SubMenu.Caption = SubMenuNome
                SubMenu.BeginGroup = SubMenuBeginGroup
            End If
            'Comando em SubMenu
            Set Cmd = SubMenu.Controls.Add(msoControlButton)
        End If

        'Definindo o comando
        With Cmd
            .BeginGroup = CmdBeginGroup
            .Caption = CmdNome
            .OnAction = CmdAction
            .Enabled = CmdEnabled
            If .Type = msoControlButton Then .State = CmdState
            '         .Tag = CmdTag 'N|fffd|o parece ter utilidade
            .HelpFile = CmdHelpFile
            .HelpContextID = CmdHelpCtxId
        End With
IgnorarComando:
    Next
End Sub


Sub AdicBotAoMenu()
    Static MenuNome As String
    Static SubMenuNome As String
    Static BotHelpFile As String
    ExibBot = Workbooks("cpap_pri.mac").Sheets(1).Range("ExibBot").Value
    Logado = Workbooks("cpap_pri.mac").Sheets(1).Range("Logado").Value
    If ExibBot = "" Then ExibBot = Logado
    'Menu separador
    With vBarra.Controls.Add(msoControlPopup)
        .Caption = IIf(ExibBot, "|fffd|", "|fffd|")
        .OnAction = "cpap_ex8.mac!ExibOcultBot"
    End With
    If Not ExibBot Then Exit Sub
    For Each nRow In RangeCfg.Rows
        If nRow.Cells(1, 5) = 3 Then GoTo IgnorarBot|fffd|o
        BotFaceId = nRow.Cells(1, 1)
        BotTooltipText = nRow.Cells(1, 2)
        BotBeginGroup = InStr(1, nRow.Cells(1, 3), ">") = 1
        BotNome = Application.WorksheetFunction.Substitute(nRow.Cells(1, 3), ">", "")
        BotAction = IIf(InStr(1, nRow.Cells(1, 4), "!") = 0, "'" & qCh & "'!", "") & nRow.Cells(1, 4)
        BotEnabled = nRow.Cells(1, 5) = "" Or nRow.Cells(1, 5) = 1 Or nRow.Cells(1, 5) = 11
        BotState = IIf(nRow.Cells(1, 5) > 10, msoButtonDown, msoButtonUp)
        If InStr(1, nRow.Cells(1, 6), "!") > 1 Then BotHelpFile = Left(nRow.Cells(1, 6), InStr(1, nRow.Cells(1, 6), "!") - 1)
        If InStr(1, nRow.Cells(1, 6), "!") > 1 Then BotHelpCtxId = Mid(nRow.Cells(1, 6), InStr(1, nRow.Cells(1, 6), "!") + 1, 200) Else BotHelpCtxId = nRow.Cells(1, 6)
        BotTag = nRow.Cells(1, 7)

        'Definindo o bot|fffd|o
        If InStr(1, BotFaceId, "&") > 0 Then
            'A barra 'SomeFacesOnly'|fffd| a fonte que vai anexada a esta pasta de trabalho. Sempre que edit|fffd|-la deve ser reanexada. No Excel 2007 aberto, ela desaparece ao carregar temp*.xlb
            If Not (Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value And Val(Application.Version) >= 12) Then
                On Error Resume Next    'No Excel 2010, parece que attached toolbar carrega mas some logo, diferente do 2007, ent|fffd|o em erro cria bot|fffd|o com face padr|fffd|o. Sem problema, pois n|fffd|o vai ser exibido mesmo.
                Set vBot = Application.CommandBars("SomeFacesOnly").Controls(BotFaceId).Copy(Bar:=Application.CommandBars(vBarra.Name))
                If Err.Number <> 0 Then Set vBot = Application.CommandBars(vBarra.Name).Controls.Add(Type:=msoControlButton): Err.Clear
                vBot.Tag = BotFaceId    'Para distinguir IdImage em xlam
            End If
        Else
            Set vBot = Application.CommandBars(vBarra.Name).Controls.Add(Type:=msoControlButton)
            vBot.FaceId = IIf(Not IsNumeric(BotFaceId) Or IsEmpty(BotFaceId), 2950, BotFaceId)
        End If
        With vBot
            .BeginGroup = BotBeginGroup
            .TooltipText = BotTooltipText
            .Caption = BotNome
            .OnAction = BotAction
            .Enabled = BotEnabled
            .State = BotState
            '.Tag = BotTag 'N|fffd|o parece ter utilidade
            .HelpFile = BotHelpFile
            .HelpContextID = BotHelpCtxId
        End With
IgnorarBot|fffd|o:
    Next
End Sub

Sub ExibOcultBot()
    ExibBot = Workbooks("cpap_pri.mac").Sheets(1).Range("ExibBot").Value
    If ExibBot = "" Then ExibBot = True Else ExibBot = ExibBot = False
    Workbooks("cpap_pri.mac").Sheets(1).Range("ExibBot").Value = ExibBot
    Usu = Workbooks("cpap_pri.mac").Sheets(1).Range("NomeUsua").Value
    If Usu <> "" Then
        Application.Run "cpap_pri.Mac!AbrirCpap_mem"
        Application.Run "'cpap-mem.mac'!AltDados", Usu, 8 - 1, ExibBot
        Workbooks("cpap-mem.mac").Close True
    End If
    MenuCfg
End Sub

Private Sub AddBotEmBranco()
'|fffd|til s|fffd| na edi|fffd||fffd|o
    Application.CommandBars("SomeFacesOnly").Visible = True
    Application.CommandBars("SomeFacesOnly").Controls.Add Type:=msoControlButton
End Sub


Public Sub MenuDeSa|fffd|da()
    On Error Resume Next
    CommandBars("BarraDeSa|fffd|da").Delete
    On Error GoTo 0
    Set BarraDeSa|fffd|da = CommandBars _
            .Add(Name:="BarraDeSa|fffd|da", Position:=msoBarPopup, _
            Temporary:=True)
    With BarraDeSa|fffd|da
        With .Controls.Add(Type:=msoControlButton)
            .Caption = "Sair do CPAP"
            .OnAction = "cpap_ex8.mac!DoMenuDeSa|fffd|da1"
        End With
        With .Controls.Add(Type:=msoControlButton)
            .Caption = "Desligar Computador"
            .OnAction = "cpap_ex8.mac!DoMenuDeSa|fffd|da2"
        End With
        .ShowPopup
        ' Confirmar desligamento do computador
        Set OpDeSa|fffd|da = Application.Workbooks("Cpap_pri.mac").Sheets(1).Range("OpDeSa|fffd|da")
        If OpDeSa|fffd|da.Value = 2 Then
            OpDeSa|fffd|da.Value = 3
            .Controls("Sair do CPAP").Delete
            .Controls("Desligar Computador").Caption = "Desligar Computador. OK?"
            Beep
            .ShowPopup
        End If
    End With
End Sub

Private Sub DoMenuDeSa|fffd|da1()
    Application.Workbooks("Cpap_pri.mac").Sheets(1) _
            .Range("OpDeSa|fffd|da").Value = 1
End Sub
Private Sub DoMenuDeSa|fffd|da2()
    Application.Workbooks("Cpap_pri.mac").Sheets(1) _
            .Range("OpDeSa|fffd|da").Value = 2
End Sub

Function GetMenuAtivName() As String
    Dim bVisible As Boolean
    On Error Resume Next
    bVisible = Application.CommandBars("MenuCPAP1").Visible
    If Err.Number = 0 And bVisible Then GetMenuAtivName = "MenuCPAP1": Exit Function
    Err.Clear
    bVisible = Application.CommandBars("MenuCPAP2").Visible
    If Err.Number = 0 And bVisible Then GetMenuAtivName = "MenuCPAP2"
End Function

Function MenuAtivIsUpdt() As Boolean    'O menu is updated se o seu sMenuAtivId guardado no tab do primeiro controle foi igual ao atual obtido na |fffd|ltima chamada do MenuCfg
    vMenuAtiv = GetMenuAtivName: If vMenuAtiv = "" Then Exit Function    'N|fffd|o existe
    If Application.CommandBars(vMenuAtiv).Controls.Count = 0 Then MenuAtivIsUpdt = (sMenuAtivId = "Empty"): Exit Function 'Cpap vazio
    MenuAtivIsUpdt = (Application.CommandBars(vMenuAtiv).Controls(1).Tag = sMenuAtivId)
End Function

Function WbIsOpen(WbName As String) As Boolean
    Dim Wb As Workbook
    On Error Resume Next
    Set Wb = Workbooks(WbName)
    WbIsOpen = Not Wb Is Nothing
End Function
Attribute VB_Name = "M|fffd|d4Editada"
Sub Editada()
    Dim WbEditada As Workbook
    Set WbEditada = ThisWorkbook
    Windows(WbEditada.Windows(1).Caption).Visible = True
    WbEditada.Activate

    CheckXLAM True

    If LCase(WbEditada.Name) = "cpap_ex8.mac" Then
        'Este if |fffd| usado s|fffd| no cpap_ex8.mac. |fffd| para salvar
        'os bot|fffd|es em "SomeFacesOnly" e em ToolBar1 de edi|fffd||fffd|o do CPAP. E limpar
        'c|fffd|lulas para guardar vari|fffd|veis
        WbEditada.Sheets(1).Range("TextLoc").ClearContents

        If MsgBox("Sem altera|fffd||fffd|es por salvar em bot|fffd|es e barras.", vbOKCancel) = vbCancel Then
            MsgBox "A seguir, anexar apenas ''SomeFacesOnly'' em cpap_ex8.mac"
            Application.CommandBars("SomeFacesOnly").Visible = False
            Application.SendKeys IIf(Application.International(xlCountryCode) = 55, "%x", "%h")
            Application.Dialogs(xlDialogCustomizeToolbar).Show

            Set vTemp = Workbooks.Add
            MsgBox "A seguir, anexar ''SomeFacesOnly'' e ''Toolbar 1'' em temporar.xlb"
            Application.CommandBars("Toolbar 1").Protection = msoBarNoProtection
            Application.CommandBars("Toolbar 1").Visible = True
            Application.SendKeys IIf(Application.International(xlCountryCode) = 55, "%x", "%h")
            Application.Dialogs(xlDialogCustomizeToolbar).Show
            If MsgBox("Salvar Temporar.xlb?", vbOKCancel) = vbOK Then
                DirP = WbEditada.Path
                On Error Resume Next
                Application.DisplayAlerts = False
                ActiveWorkbook.SaveAs Filename:=DirP & "\Diversos\temporar.xlb", FileFormat:=xlNormal
                On Error GoTo 0
            End If
            vTemp.Close (False)
        End If
    End If

    For Each sh In WbEditada.Sheets
        'Este loop |fffd| usado s|fffd| onde houver planilha de hist|fffd|rico
        If Right(sh.Name, 4) = ".hst" Then
            sh.Activate
            NumCampos = Range("A1").CurrentRegion.Columns.Count
            NumSugPadr = Range("A1").CurrentRegion.Rows.Count
            Set Campos = Range(Cells(1, 1), Cells(1, NumCampos))

            'Limpando
            Range("DadosFixos").CurrentRegion.Clear
            Range("DadosHist").CurrentRegion.Clear
            For Each Nome In sh.Names
                Nome.Delete
            Next
            With ActiveWindow
                .SplitColumn = 0
                .SplitRow = 12
            End With

            'Redefinindo
            LFix = 4 + 100   'N|fffd|m de linhas reservadas para sug. fixas. Pode ser alterado o c|fffd|digo |fffd| flex|fffd|vel
            With sh.Names
                Ref = "=" & sh.Name & "!" & Cells(NumSugPadr + 4, 1).Address(ReferenceStyle:=xlR1C1)
                .Add Name:="DadosFixos", RefersToR1C1:=Ref
                Ref = "=" & sh.Name & "!" & Cells(NumSugPadr + 4 + LFix + 1, 1).Address(ReferenceStyle:=xlR1C1)
                .Add Name:="DadosHist", RefersToR1C1:=Ref


                For Each c In Campos
                    .Add Name:=c.Value, RefersToR1C1:=Cells(NumSugPadr + 4, c.Column)
                    .Add Name:=c.Value & "Hist", RefersToR1C1:=Cells(NumSugPadr + 4 + LFix + 2, c.Column)
                    c.Offset(NumSugPadr + 4 + LFix, 0).Value = 15
                    c.Offset(NumSugPadr + 4 + LFix + 1, 0).Value = c.Value & "Hist"
                Next
            End With
            Range("A1").CurrentRegion.Copy
            Range("DadosFixos").PasteSpecial xlPasteValues
            Application.CutCopyMode = False

            ActiveWindow.Panes(1).Activate
            Application.GoTo Reference:="DadosFixos", Scroll:=True
            ActiveWindow.Panes(3).Activate
            Application.GoTo Reference:="DadosHist", Scroll:=True
        End If
    Next

    If WbEditada.ReadOnly Then WbEditada.ChangeFileAccess xlReadWrite
    If Val(Application.Version) < 9 Then If MsgBox(WbEditada.Name & ".  Indenter? (Distanciar margens)", vbOKCancel) = vbOK Then Run "Indenter97.xla!IndentProject"
    WbEditada.Sheets(1).Select
    If MsgBox(WbEditada.Name & ".  Limpar C|fffd|digo?", vbOKCancel) = vbOK Then
        Application.OnTime Now, "VBACodeCleaner.xla!CodeCleanerMain"
    Else
        WbEditada.Save
    End If
End Sub

Sub ListarControles()
    For Each c In UserForm1.Controls
        i = i + 1
        Cells(i, 27).Value = c.Name
        k = InStr(1, c.Name, "_")
        If k <> 0 Then Cells(i, 27 + 1).Value = Mid(c.Name, k + 1, 10)
    Next
End Sub
Attribute VB_Name = "Plan1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True



















Attribute VB_Name = "UserFormPain|fffd|is"
Attribute VB_Base = "0{6F9980FA-6D78-4AD8-973F-C75A5C0B1381}{0827790B-7DC7-43F4-B565-D85B6123E54A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Dim vHorz_ScrB
Dim vVert_ScrB

Private Sub OK_Bt_Click()
    Hide
End Sub

Private Sub UserForm_Initialize()
    DesCong_OpB.Caption = IIf(ActiveWindow.FreezePanes, "Descongelar", "Congelar")
    vHorz_ScrB = Horz_ScrB.Value
    vVert_ScrB = Vert_ScrB.Value
    Scr_OpB.Value = True
End Sub

Private Sub VertHor_OpB_Click()
    Sem_OpB_Click
    ActiveWindow.SplitColumn = Vert_OpB.Tag
    ActiveWindow.SplitRow = Hor_OpB.Tag
    ActiveWindow.FreezePanes = True
    UserForm_Initialize
End Sub

Private Sub Hor_OpB_Click()
    Sem_OpB_Click
    ActiveWindow.SplitRow = Hor_OpB.Tag
    ActiveWindow.FreezePanes = True
    UserForm_Initialize
End Sub

Private Sub Vert_OpB_Click()
    Sem_OpB_Click
    ActiveWindow.SplitColumn = Vert_OpB.Tag
    ActiveWindow.FreezePanes = True
    UserForm_Initialize
End Sub

Private Sub Sem_OpB_Click()
    ActiveWindow.SplitColumn = 0
    ActiveWindow.SplitRow = 0
    Application.GoTo Range(VertHor_OpB.Tag), True
End Sub

Private Sub DesCong_OpB_Click()
    If ActiveWindow.SplitColumn + ActiveWindow.SplitRow > 0 Then ActiveWindow.FreezePanes = Not ActiveWindow.FreezePanes
    UserForm_Initialize
End Sub

Private Sub Horz_ScrB_Change()
    Application.GoTo Range(VertHor_OpB.Tag), True
    i = ActiveWindow.FreezePanes
    j = ActiveWindow.SplitRow
    j1 = IIf(vHorz_ScrB < Horz_ScrB.Value, 1, -1)
    j = j + j1
    While j <> 0 And Range(VertHor_OpB.Tag).Offset(j - j1, 0).RowHeight = 0
        j = j + j1
    Wend
    If j >= 0 Then
        ActiveWindow.SplitRow = j
        If ActiveWindow.SplitColumn + ActiveWindow.SplitRow > 0 Then ActiveWindow.FreezePanes = i
    End If
    Horz_ScrB.ZOrder (fmTop)
    UserForm_Initialize
End Sub

Private Sub Vert_ScrB_Change()
    Application.GoTo Range(VertHor_OpB.Tag), True
    i = ActiveWindow.FreezePanes
    j = ActiveWindow.SplitColumn
    j1 = IIf(vVert_ScrB < Vert_ScrB.Value, 1, -1)
    j = j + j1
    While j <> 0 And Range(VertHor_OpB.Tag).Offset(0, j - j1).ColumnWidth = 0
        j = j + j1
    Wend
    If j >= 0 Then
        ActiveWindow.SplitColumn = j
        If ActiveWindow.SplitColumn + ActiveWindow.SplitRow > 0 Then ActiveWindow.FreezePanes = i
    End If
    Vert_ScrB.ZOrder (fmTop)
    UserForm_Initialize
End Sub

Attribute VB_Name = "UserformLocText"
Attribute VB_Base = "0{CC6808B8-623D-4F5D-87C8-CBFB53D7E32E}{A708AA9C-1A7E-4F77-9051-872728F1DAB8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub Pr|fffd|ximo_Bt_Click()
    BotPress_Tb.Value = 1
    Hide
End Sub

Private Sub Cancelar_Bt_Click()
    BotPress_Tb.Value = 2
    Hide
End Sub

Private Sub Texto_Ct_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 114 Or KeyCode = 13 Then
        KeyCode = False
        BotPress_Tb.Value = 1
        Hide
    End If
End Sub

Private Sub UserForm_Activate()
    Pr|fffd|ximo_Bt.SetFocus
    Texto_Ct.SetFocus
End Sub

Attribute VB_Name = "cHHelpWhatsThis"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Declare Function HtmlHelp Lib "HHCtrl.ocx" Alias "HtmlHelpA" (ByVal hwndCaller As Long, ByVal pszFile As String, ByVal uCommand As Long, ByVal dwData As Long) As Long
Const HH_DISPLAY_TOC = &H1
Const HH_HELP_CONTEXT = &HF         ' Display mapped numeric value in dwData.
'Const HH_DISPLAY_INDEX = &H2
'Const HH_DISPLAY_TOPIC = &H0
'Const HH_SET_WIN_TYPE = &H4
'Const HH_GET_WIN_TYPE = &H5
'Const HH_GET_WIN_HANDLE = &H6
'Const HH_DISPLAY_TEXT_POPUP = &HE   ' Display string resource ID or text in a pop-up window. Pop-up, but help topics must be included in the [TEXT POPUPS] of (.hhp) file
'Const HH_TP_HELP_CONTEXTMENU = &H10    ' Text pop-up help, similar to WinHelp's HELP_CONTEXTMENU. Idem
'Const HH_TP_HELP_WM_HELP = &H11     ' text pop-up help, similar to WinHelp's HELP_WM_HELP. Idem
Const HH_CLOSE_ALL = &H12

Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Type POINTAPI
    x As Long
    y As Long
End Type

Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Private Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
Private Declare Function MoveWindow Lib "user32" (ByVal hWnd As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Const GWL_STYLE = (-16)
Const WS_CAPTION As Long = &HC00000

'Api declarations for get mouse button state and keyboard key
Private Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
Const SM_SWAPBUTTON = 23
Private Enum MouseButtonConstants
    vbLeftButton = 1
    vbRightButton = 2
    vbMiddleButton = 4
End Enum
Private Declare Function GetKeyState Lib "user32" (ByVal vKey As Integer) As Integer

Dim R As RECT
Dim CrtlEnableArr() As String
Dim lCountCtrlWithID As Long
Dim MouseOverCtrlArr() As String
Dim sCtrlTipText As String
Dim Form_hWnd1 As Long

Public Function HtmlHelpTOC(ByVal pszFile As String) As Long    'Abre ajuda normal com TOC (Table Of Contents - ThreeView)
    HtmlHelpTOC = HtmlHelp(0, pszFile, HH_DISPLAY_TOC, 0)
End Function

Public Function HtmlHelpDftTpcHtml(ByVal pszFile As String) As Long    ''Abre em janela pr|fffd|pria no t|fffd|pico padr|fffd|o sem painel de navega|fffd||fffd|o.
    HtmlHelpDftTpcHtml = HtmlHelp(0, pszFile, 0, 0)
End Function

Public Function HtmlHelpCtxHtml(ByVal pszFile As String, ByVal dwData As Long) As Long    'Abre em janela pr|fffd|pria no t|fffd|pico do contexto sem painel de navega|fffd||fffd|o.
    HtmlHelpCtxHtml = HtmlHelp(0, pszFile, HH_HELP_CONTEXT, dwData)
End Function

Public Function HtmlHelpCtxPopupHtml(ByVal hwndCaller As Long, ByVal pszFile As String, ByVal dwData As Long, bWinLarge As Boolean) As Long    'Abre janela indicada suportando html e com context e simula janela popup via API. Doesn't riquire to set texts in [TEXT POPUPS] of (.hhp) file
    Dim sFile As String
    If InStr(1, pszFile, ">") > 0 Then sFile = Left(pszFile, InStr(1, pszFile, ">") - 1) Else sFile = pszFile
    If Dir(sFile) = "" Then MsgBox "O arquivo de ajuda " & sFile & " n|fffd|o foi encontrado!", vbCritical: HtmlHelpCtxPopupHtml = -1: Exit Function

    HtmlHelpCtxPopupHtml = HtmlHelp(hwndCaller, pszFile, HH_HELP_CONTEXT, dwData)
    If HtmlHelpCtxPopupHtml <> 0 Then
        'Hide window title
        Dim lStyle As Long
        lStyle = GetWindowLongA(HtmlHelpCtxPopupHtml, GWL_STYLE)
        lStyle = lStyle And Not WS_CAPTION
        SetWindowLongA HtmlHelpCtxPopupHtml, GWL_STYLE, lStyle

        'Move window next to mouse cursor.
        Dim R As RECT, Point As POINTAPI, Result As Long
        GetWindowRect HtmlHelpCtxPopupHtml, R: Result = GetCursorPos(Point): If Result = 0 Then Point.x = R.Left: Point.y = R.Top
        MoveWindow HtmlHelpCtxPopupHtml, Point.x, Point.y, IIf(R.Right - R.Left > 130 + 30, R.Right - R.Left, IIf(bWinLarge, 430, 285)), IIf(R.Bottom - R.Top > 130, R.Bottom - R.Top, IIf(bWinLarge, 340, 165)), True

        'Wait some key or click out of window to close window.
        DoEvents: Application.Wait Now + TimeSerial(0, 0, 1)
        Do
            DoEvents
            Sleep 1    'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
            If CBool(GetAsyncKeyState(vbLeftButton) And &H8000) Or CBool(GetAsyncKeyState(vbMiddleButton) And &H8000) Or CBool(GetAsyncKeyState(vbRightButton) And &H8000) Then
                GetCursorPos Point: GetWindowRect HtmlHelpCtxPopupHtml, R
                If Point.x < R.Left Or Point.x > R.Right Or Point.y < R.Top Or Point.y > R.Bottom Then HtmlHelpCloseAll: Exit Do    'Exit if any mouse button is down
            End If
            If GetKeyState(&H1B) < 0 Then HtmlHelpCloseAll: Exit Do  'Exit if VK_ESCAPE (ESC key) is down
        Loop
    End If
End Function

Public Function HtmlHelpCloseAll() As Long
    HtmlHelpCloseAll = HtmlHelp(0, 0, HH_CLOSE_ALL, 0)   'Closes all windows opened directly or indirectly by the calling program.
End Function

Public Sub WhatsThis_Img_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single, UserForm1 As Object)
    Dim Ctrl As Control, CtrlTmp As Control, i As Long

    If UserForm1.WhatsThis_Img.BackStyle = fmBackStyleOpaque Then

        'Antes de entrar em modo WhatsThis, verificar se existe ctrl com ID, se n|fffd|o, e se existir ID para o form, executa logo.
        lCountCtrlWithID = 0: CountCtrlWithID UserForm1
        If lCountCtrlWithID = 0 Then
            If UserForm1.HelpContextID <> 0 Then
                i = HtmlHelpCtxPopupHtml(GetForm_hWnd(UserForm1.Caption), ThisWorkbook.Path & "\CPAP.chm>CtxPopup", UserForm1.HelpContextID, True)   'Abre janela indicada e com context
                If i = 0 Then MsgBox "O context ID " & UserForm1.HelpContextID & " definido para este formul|fffd|rio n|fffd|o possui t|fffd|pico definido na ajuda!", vbInformation
            Else
                MsgBox "N|fffd|o foi definido nenhum t|fffd|pico na ajuda para este formul|fffd|rio!", vbInformation
            End If
            Exit Sub
        End If

        'Prepara para entra em modo WhatsThis
        R.Left = UserForm1.WhatsThis_Img.Left: R.Top = UserForm1.WhatsThis_Img.Top: R.Right = UserForm1.WhatsThis_Img.Left + UserForm1.WhatsThis_Img.Width: R.Bottom = UserForm1.WhatsThis_Img.Top + UserForm1.WhatsThis_Img.Height
        UserForm1.WhatsThis_Img.Left = 0: UserForm1.WhatsThis_Img.Top = 0: UserForm1.WhatsThis_Img.Width = UserForm1.Width + 50: UserForm1.WhatsThis_Img.Height = UserForm1.Height
        sCtrlTipText = UserForm1.WhatsThis_Img.ControlTipText: UserForm1.WhatsThis_Img.ControlTipText = "Ajuda (Clique no controle desejado)"
        UserForm1.WhatsThis_Img.BackStyle = fmBackStyleTransparent
        ReDim CrtlEnableArr(0)
        For Each Ctrl In UserForm1.Controls    'Estes tipos de ctrl ficam sempre em frente de imagem, exceto se desabilitados. ListBox |fffd|s vezes sim e |fffd|s vezes nao. Desabilitar estocando nomes para restaurar.
            If TypeName(Ctrl) = "MultiPage" Or TypeName(Ctrl) = "Frame" Or TypeName(Ctrl) = "ListBox" Then
                Ctrl.Enabled = False
                ReDim Preserve CrtlEnableArr(i)
                CrtlEnableArr(i) = Ctrl.Name
                i = i + 1
            End If
        Next
        UserForm1.WhatsThis_Img.ZOrder (0)
    Else
        UserForm1.WhatsThis_Img.Left = R.Left: UserForm1.WhatsThis_Img.Top = R.Top: UserForm1.WhatsThis_Img.Width = R.Right - UserForm1.WhatsThis_Img.Left: UserForm1.WhatsThis_Img.Height = R.Bottom - UserForm1.WhatsThis_Img.Top
        UserForm1.WhatsThis_Img.ControlTipText = sCtrlTipText
        UserForm1.WhatsThis_Img.BackStyle = fmBackStyleOpaque
        If CrtlEnableArr(0) <> "" Then    'Restaurando enabled
            For i = 0 To UBound(CrtlEnableArr)
                UserForm1.Controls(CrtlEnableArr(i)).Enabled = True
            Next
        End If

        ReDim MouseOverCtrlArr(0)
        GetMouseOverCtrls UserForm1, x, y    'Get all controls below mouse point in recorrent way.
        If MouseOverCtrlArr(0) <> "" And UBound(MouseOverCtrlArr) = 0 Then If UserForm1.Controls(MouseOverCtrlArr(0)).Name = UserForm1.WhatsThis_Img.Name Then MouseOverCtrlArr(0) = ""  'Considera o clique no pr|fffd|prio bot|fffd|o WhatsThis_Img como no UserForm
        If MouseOverCtrlArr(0) <> "" Then    'Verificar os controles obtidos com HelpContextID, se mais de um opta pelo menor.
            Set Ctrl = Nothing
            For i = 0 To UBound(MouseOverCtrlArr)
                Set CtrlTmp = UserForm1.Controls(MouseOverCtrlArr(i))
                If TypeName(CtrlTmp) <> "Label" And TypeName(CtrlTmp) <> "Image" Then    'Label and Image haven't HelpContextID
                    If CtrlTmp.HelpContextID <> 0 Then
                        If Ctrl Is Nothing Then
                            Set Ctrl = CtrlTmp
                        Else    'Se houver mais de um sob o mouse com HelpContextID, opta pelo menor, pois provavelmente est|fffd| no interior do maior.
                            If CtrlTmp.Width * CtrlTmp.Height < Ctrl.Width * Ctrl.Height Then Set Ctrl = CtrlTmp
                        End If
                    End If
                End If
            Next
            If Ctrl Is Nothing Then
                MsgBox IIf(UBound(MouseOverCtrlArr) = 0, "N|fffd|o foi definido nenhum t|fffd|pico na ajuda para este controle!", "N|fffd|o foi definido nenhum t|fffd|pico na ajuda para os controles abaixo do cursor!") _
                        & IIf(UserForm1.HelpContextID = 0, "", vbCrLf & vbCrLf & "Dica! Veja a possibilidade de ajuda referente ao formul|fffd|rio como um todo," & vbCrLf & "clicando diretamente no mesmo."), vbInformation
                HtmlHelpCloseAll
            Else
                i = HtmlHelpCtxPopupHtml(GetForm_hWnd(UserForm1.Caption), ThisWorkbook.Path & "\CPAP.chm>CtxPopup", Ctrl.HelpContextID, False)      'Abre janela indicada e com context
                If i = 0 Then MsgBox "O context ID " & Ctrl.HelpContextID & " definido para este controle n|fffd|o possui t|fffd|pico definido na ajuda!", vbInformation
            End If
        Else    'Se n|fffd|o obteve controle abaixo do mouse, opta pelo UserForm se tiver HelpContextID
            If UserForm1.HelpContextID = 0 Then
                MsgBox "N|fffd|o foi definido nenhum t|fffd|pico na ajuda para este formul|fffd|rio!", vbInformation
                HtmlHelpCloseAll
            Else
                i = HtmlHelpCtxPopupHtml(GetForm_hWnd(UserForm1.Caption), ThisWorkbook.Path & "\CPAP.chm>CtxPopup", UserForm1.HelpContextID, True)   'Abre janela indicada e com context
                If i = 0 Then MsgBox "O context ID " & UserForm1.HelpContextID & " definido para este formul|fffd|rio n|fffd|o possui t|fffd|pico definido na ajuda!", vbInformation
            End If
        End If
    End If
End Sub

Private Sub CountCtrlWithID(CtrlParent As Object)
    Dim Ctrl As Control
    For Each Ctrl In CtrlParent.Controls
        If TypeName(Ctrl) = "Frame" Then CountCtrlWithID Ctrl     'Go into frame.
        If TypeName(Ctrl) = "MultiPage" Then CountCtrlWithID Ctrl.Pages(Ctrl.Value)          'Go into MultiPage.
        If Ctrl.Parent.Name = CtrlParent.Name Then
            If TypeName(Ctrl) <> "Label" And TypeName(Ctrl) <> "Image" Then    'Label and Image haven't HelpContextID
                If Ctrl.HelpContextID <> 0 Then lCountCtrlWithID = lCountCtrlWithID + 1
            End If
        End If
    Next
End Sub

Private Sub GetMouseOverCtrls(CtrlParent As Object, ByVal x As Single, ByVal y As Single)
    Dim Ctrl As Control
    Dim i As Long
    For Each Ctrl In CtrlParent.Controls
        If TypeName(Ctrl) = "Frame" Then GetMouseOverCtrls Ctrl, x - Ctrl.Left - 3, y - Ctrl.Top - 3    'Go into frame. O ajuste fino deve ser das bordas.
        If TypeName(Ctrl) = "MultiPage" Then GetMouseOverCtrls Ctrl.Pages(Ctrl.Value), x - Ctrl.Left - 2, y - Ctrl.Top - 15          'Go into MultiPage. O ajuste fino deve ser das bordas e caption.
        If Ctrl.Parent.Name = CtrlParent.Name Then
            If Ctrl.Left < x And x < Ctrl.Left + Ctrl.Width And Ctrl.Top < y And y < Ctrl.Top + Ctrl.Height Then    'MsgBox Ctrl.Name
                i = UBound(MouseOverCtrlArr)
                If MouseOverCtrlArr(0) = "" Then i = i - 1 Else ReDim Preserve MouseOverCtrlArr(i + 1)
                MouseOverCtrlArr(i + 1) = Ctrl.Name
            End If
        End If
    Next
End Sub

Private Function GetForm_hWnd(sCaption As String, Optional bIsCOMAddin As Boolean)     'Get form handle
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), sCaption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, sCaption)
    GetForm_hWnd = Form_hWnd1
End Function

Public Function HelpVBA(Optional sHelpFile As String, Optional HelpContextID As Long, Optional lWinStyle As Long) As Boolean
'HELP() XLM and VBA Help method function will with Html Help files (.chm) inclusive with AutoTitle
'feature, but they always showing navigation pane and on built-in Excel help window. This offers
'those and more options of window type.
    Dim i As Long
    On Error Resume Next
    Select Case lWinStyle
    Case 0
        HtmlHelpCloseAll  'Closes all help windows opened directly or indirectly by the calling program.
    Case 1
        Application.Help sHelpFile, HelpContextID    'Abre na janela da ajuda do Excel com autotitle
    Case 2
        If HelpContextID = 0 Then
            HtmlHelpDftTpcHtml sHelpFile      'Abre em janela pr|fffd|pria no t|fffd|pico padr|fffd|o sem painel de navega|fffd||fffd|o.
        Else
            i = HtmlHelpCtxHtml(sHelpFile, HelpContextID)     'Abre em janela pr|fffd|pria no t|fffd|pico do contexto sem painel de navega|fffd||fffd|o.
            If i = 0 Then MsgBox "O context ID " & HelpContextID & " n|fffd|o possui t|fffd|pico definido na ajuda!", vbInformation
        End If
    Case 3
        Dim hWndXLMAIN As Long
        If Val(Application.Version) > 9 Then hWndXLMAIN = Application.hWnd Else hWndXLMAIN = FindWindow("XLMAIN", Application.Caption)
        HtmlHelpCtxPopupHtml hWndXLMAIN, ThisWorkbook.Path & "\CPAP.chm>CtxPopup", HelpContextID, True       'Abre na janela popup e com context
    End Select
    HelpVBA = (Err.Number = 0)
End Function



' InQuest injected base64 decoded content
' ~`ZrD

INQUEST-PP=macro
