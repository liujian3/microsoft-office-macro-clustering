Attribute VB_Name = "ClsNotFileSystemObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Copyright |fffd|1996-2011 VBnet/Randy Birch, All Rights Reserved.
' Some pages may also contain other copyrights by the author.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Distribution: You can freely use this code in your own
'               applications, but you may not reproduce
'               or publish this code on any web site,
'               online service, or distribute as source
'               on any media without express permission.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Option Explicit

Private Const VBDOT = 46
Private Const MAXDWORD As Long = &HFFFFFFFF
Private Const MAX_PATH As Long = 260
Private Const INVALID_HANDLE_VALUE = -1
Private Const FILE_ATTRIBUTE_DIRECTORY = &H10

Private Type FILETIME
   dwLowDateTime As Long
   dwHighDateTime As Long
End Type

Private Type WIN32_FIND_DATA
   dwFileAttributes As Long
   ftCreationTime As FILETIME
   ftLastAccessTime As FILETIME
   ftLastWriteTime As FILETIME
   nFileSizeHigh As Long
   nFileSizeLow As Long
   dwReserved0 As Long
   dwReserved1 As Long
   cFileName As String * MAX_PATH
   cAlternate As String * 14
End Type

#If VBA7 Then
    Private Declare PtrSafe Function FindClose Lib "kernel32" _
      (ByVal hFindFile As LongPtr) As Boolean
       
    Private Declare PtrSafe Function FindFirstFile Lib "kernel32" _
       Alias "FindFirstFileA" _
      (ByVal lpFileName As String, _
       lpFindFileData As WIN32_FIND_DATA) As LongPtr
       
    Private Declare PtrSafe Function FindNextFile Lib "kernel32" _
       Alias "FindNextFileA" _
      (ByVal hFindFile As LongPtr, _
       lpFindFileData As WIN32_FIND_DATA) As LongPtr
    
    Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As LongPtr
#Else
    Private Declare Function FindClose Lib "kernel32" _
      (ByVal hFindFile As Long) As Boolean
       
    Private Declare Function FindFirstFile Lib "kernel32" _
       Alias "FindFirstFileA" _
      (ByVal lpFileName As String, _
       lpFindFileData As WIN32_FIND_DATA) As Long
       
    Private Declare Function FindNextFile Lib "kernel32" _
       Alias "FindNextFileA" _
      (ByVal hFindFile As Long, _
       lpFindFileData As WIN32_FIND_DATA) As Long
    
    Private Declare Function GetTickCount Lib "kernel32" () As Long
#End If
Private pathList As Collection


Public Function SearchForFiles(rootPath As String, fileMask As String, searchSubfolders As Boolean) As Collection
    Set pathList = New Collection
    SearchFor rootPath, fileMask, searchSubfolders, False
    Set SearchForFiles = pathList
End Function

Public Function SearchForFolders(rootPath As String, fileMask As String, searchSubfolders As Boolean) As Collection
    Set pathList = New Collection
    SearchFor rootPath, fileMask, searchSubfolders, True
    Set SearchForFolders = pathList
End Function

Public Function CheckFileExists(path As String) As Boolean
    Dim fileAttributes As Long
    
    CheckFileExists = False
    If CheckExists(path, fileAttributes) Then
        If Not fileAttributes And FILE_ATTRIBUTE_DIRECTORY Then
            CheckFileExists = True
        End If
    End If
End Function

Public Function CheckFolderExists(ByVal path As String) As Boolean
    Dim fileAttributes As Long
    
    path = UnQualifyPath(path)
    path = ExpandPath(path)
    
    CheckFolderExists = False
    If CheckExists(path, fileAttributes) Then
        If fileAttributes And FILE_ATTRIBUTE_DIRECTORY Then
            CheckFolderExists = True
        End If
    End If
End Function

Private Sub SearchFor(rootPath As String, fileMask As String, searchSubfolders As Boolean, SearchForFolder As Boolean)
    'local working variables
    Dim WFD As WIN32_FIND_DATA
    Dim hFile As LongPtr
    Dim sPath As String
    Dim sRoot As String
    Dim sTmp As String

    sRoot = QualifyPath(rootPath)
    sRoot = ExpandPath(sRoot)
    sPath = sRoot & "*.*"

    'obtain handle to the first match
    hFile = FindFirstFile(sPath, WFD)

    'if valid ...
    If hFile <> INVALID_HANDLE_VALUE Then
        'This is where the method obtains the file
        'list and data for the folder passed.
        GetFilesMatchingName sRoot, fileMask, SearchForFolder
    
        Do
            'if the returned item is a folder...
            If (WFD.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) Then
            '..and the Recurse flag was specified
                If searchSubfolders Then '
                    'and if the folder is not the default
                    'self and parent folders (a . or ..)
                    If Asc(WFD.cFileName) <> VBDOT Then
                        '..then the item is a real folder, which
                        'may contain other sub folders, so assign
                        'the new folder name to FP.sFileRoot and
                        'recursively call this function again with
                        'the amended information.
                        'remove trailing nulls
                        sTmp = sRoot & TrimNull(WFD.cFileName)
                        SearchFor sTmp, fileMask, True, SearchForFolder
                   End If
                End If
            End If
        'continue looping until FindNextFile returns
        '0 (no more matches)
        Loop While FindNextFile(hFile, WFD)
    
        'close the find handle
        hFile = FindClose(hFile)
    End If
End Sub

Private Sub GetFilesMatchingName(rootPath As String, filename As String, SearchForFolder As Boolean)
    'local working variables
    Dim WFD As WIN32_FIND_DATA
    Dim hFile As LongPtr
    Dim sPath As String
    Dim sRoot As String
    Dim sTmp As String
      
    'FP.sFileRoot contains the path to search.
    'FP.sFileNameExt contains the full path and filespec.
    sRoot = QualifyPath(rootPath)
    sPath = sRoot & filename
    
    'obtain handle to the first filespec match
    hFile = FindFirstFile(sPath, WFD)
   
    'if valid ...
    If hFile <> INVALID_HANDLE_VALUE Then
        Do
            'Even though this routine uses file specs,
            '*.* is still valid and will cause the search
            'to return folders as well as files, so a
            'check against folders is still required.
            If SearchForFolder Then
                If Asc(WFD.cFileName) <> VBDOT Then
                    If (WFD.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) = _
                         FILE_ATTRIBUTE_DIRECTORY Then
                        'this is where you add code to store
                        'or display the returned file listing.
                        '
                        'if you want the file name only, save 'sTmp'.
                        'if you want the full path, save 'sRoot & sTmp'
                
                        'remove trailing nulls
                        sTmp = TrimNull(WFD.cFileName)
                        pathList.Add sRoot & sTmp
                    End If
                End If
            Else
                If Not (WFD.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) = _
                     FILE_ATTRIBUTE_DIRECTORY Then
                    'this is where you add code to store
                    'or display the returned file listing.
                    '
                    'if you want the file name only, save 'sTmp'.
                    'if you want the full path, save 'sRoot & sTmp'
            
                    'remove trailing nulls
                    sTmp = TrimNull(WFD.cFileName)
                    pathList.Add sRoot & sTmp
                End If
            End If
        Loop While FindNextFile(hFile, WFD)
        'close the handle
        hFile = FindClose(hFile)
    End If
End Sub

'++********************************************************************
' Procedure:    CollectionSort
' Description:  Sorts a collection.
' Parameters:   fc - Collection to be sorted.
' Returns:      N/A
'--********************************************************************
Public Sub CollectionSort(fc As Collection)

    Dim i As Integer
    Dim bOrderChanged As Boolean
    Dim sText As String
    
    Do
        bOrderChanged = False
        For i = 1 To fc.count - 1
            If fc(i + 1) < fc(i) Then
                sText = fc(i)
                fc.Remove i
                fc.Add sText, , , i
                bOrderChanged = True
            End If
        Next i
    Loop Until bOrderChanged = False
    
End Sub

Public Function ExpandPath(ByVal sPath As String) As String
    Dim sParsed As String
    Dim oShell As WshShell
    
    Set oShell = New WshShell
    
    sParsed = oShell.ExpandEnvironmentStrings(sPath)
    'Replacements below are for strings that are not standart environment variables.
    If Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath) <> vbNullString Then
        sParsed = Replace(sParsed, "%workgroupPath%", Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath), Compare:=vbTextCompare)
    End If
    If Application.Options.DefaultFilePath(wdUserTemplatesPath) <> vbNullString Then
        sParsed = Replace(sParsed, "%userPath%", Application.Options.DefaultFilePath(wdUserTemplatesPath), Compare:=vbTextCompare)
    End If
    
    ExpandPath = sParsed
End Function

'++********************************************************************
' Description:  Checks that the given item exists. The item can be
'               a file or a folder.
' Parameters:   sPath => path to the item. This could have wildcards
'               in them. e.g c:/document.doc* fill find document.doc or
'               document.docx
'               fileAttributes => File attributes if the item
'               Full path without wildcards to first found item
' Returns:      True if item exists, false otherwise
'--********************************************************************
Private Function CheckExists(path As String, Optional ByRef fileAttributes As Long = 0, Optional ByRef FullPath As String = "") As Boolean
    Dim hFile As LongPtr
    Dim WFD As WIN32_FIND_DATA
    
    hFile = FindFirstFile(path, WFD)
    
    If hFile <> INVALID_HANDLE_VALUE Then
        fileAttributes = WFD.dwFileAttributes
        CheckExists = True
        FullPath = WFD.cFileName
    Else
        CheckExists = False
    End If
End Function

'++********************************************************************
' Description:  Assures that a passed path ends in a slash
' Parameters:   sPath => path that should be qualified
' Returns:      path with trailing /
'--********************************************************************
Private Function QualifyPath(sPath As String) As String
   If Right$(sPath, 1) <> "\" Then
      QualifyPath = sPath & "\"
   Else
      QualifyPath = sPath
   End If
End Function

'++********************************************************************
' Description:  Assures that a passed path does not end in a slash
' Parameters:   sPath => path that should be UnQualified
' Returns:      path without trailing /
'--********************************************************************
Private Function UnQualifyPath(sPath As String) As String
   If Right$(sPath, 1) = "\" Then
      UnQualifyPath = Left(sPath, Len(sPath) - 1)
   Else
      UnQualifyPath = sPath
   End If
End Function

'++********************************************************************
' Description:  'returns the string up to the first
'               null, if present, or the passed string
' Parameters:   startstr => String that needs to be trimmed
' Returns:      String without null characters
'--********************************************************************
Private Function TrimNull(ByVal startstr As String) As String
   Dim pos As Integer

   pos = InStr(startstr, Chr$(0))

   If pos Then
      TrimNull = Left$(startstr, pos - 1)
      Exit Function
   End If
   TrimNull = startstr
End Function
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'***********************************************************************************
'* Created by - Brochet ltd for
'*
'* Module: AutoMacro
'*
'* Holds various AutoMacros eg Document New and Document Open
'***********************************************************************************
Option Explicit

Const MODULE_NAME As String = "AutoMacros"

'++*******************************************************************
' Description:  This macro is run every time a new document is created
'               from the template
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Sub Document_New()
    Dim oTmp As template
    Dim sTitle As String
    Dim sText As String
    Dim oUndoRecord As cUndoRecord
    'On Error GoTo Document_New_EH

    'Save the document template name
    Set oTmp = ActiveDocument.AttachedTemplate
    modPrivate.SetDocVar "DocTemplateName", oTmp.Name
    
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "New Document"

    'First save the document variables to record the version of the template used
    SetDocVar INITIAL_TEMPLATE_NAME, oTmp.Name
    SetDocVar INITIAL_TEMPLATE_VERSION, TEMPLATE_VERSION
    SetDocVar INITIAL_TEMPLATE_DATE, TEMPLATE_DATE
    SetDocVar CURRENT_TEMPLATE_NAME, oTmp.Name
    SetDocVar CURRENT_TEMPLATE_DATE, TEMPLATE_DATE

    'Set various options
    SetDocumentOptions

    'Display the Main dialog box
    sText = modPrivate.sGetDocVar("NewDoc")
    If UCase(sText) = "TRUE" Then
        gbNewDoc = True
        gbStarterDoc = False
    Else
        gbNewDoc = True
        gbStarterDoc = True
    End If
    
    frmNewDoc.Show
    oUndoRecord.EndRecording
    Exit Sub

Document_New_EH:
    oUndoRecord.EndRecording
    Const sProcedure As String = "Document_New"
    GlobalErrorHandler err.Number, err.Description, MODULE_NAME, sProcedure
End Sub

'++*******************************************************************
' Description:  This macro is run every time a document is opened
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub Document_Open()
    On Error GoTo Document_Open_EH

    'Set various options
    SetDocumentOptions

    Exit Sub

Document_Open_EH:
    Const sProcedure As String = "Document_Open"
    GlobalErrorHandler err.Number, err.Description, MODULE_NAME, sProcedure
End Sub

'++*******************************************************************
' Description:  This macro is run every time a document is closed
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub Document_Close()
    On Error GoTo Document_Close_EH

    Exit Sub

Document_Close_EH:
    Const sProcedure As String = "Document_Close"
    GlobalErrorHandler err.Number, err.Description, MODULE_NAME, sProcedure
End Sub

'++*******************************************************************
' Description:  Set various Word Document options
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub SetDocumentOptions()
    On Error Resume Next
    On Error GoTo 0
End Sub





Attribute VB_Name = "cAddinAPI"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'* Brochet Legal Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Class:       cBrochetAPI
'*
'* Holds:       Class modules for Brochet API
'* How to use it:
'* Private Sub ReformatChartInExcel(ExcelApplication As Object)
'*     Dim clsBrochetAPI As cAddinAPI
'*     Set clsBrochetAPI = New cAddinAPI
'*     clsBrochetAPI.Initialize ExcelApplication
'*     If clsBrochetAPI.isReady Then
'*         Dim params(1) As String
'*         clsBrochetAPI.RunOperation "ShowDialog"
'*     End If
'* End Sub
'***********************************************************************************



Option Explicit

#If VBA7 Then
    Private Declare PtrSafe Sub Sleep Lib "kernel32 " (ByVal dwMilliseconds As LongPtr) 'For 64 Bit Systems"
#Else
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) 'For 32 Bit Systems
#End If

Private oAPI As Object
Private oCom As COMAddIn
Private bAddinExists As Boolean
Private bAddinTicked As Boolean

Public Property Get AddinExists() As Boolean
    AddinExists = bAddinExists
End Property

Public Property Get AddinTicked() As Boolean
    If Not oCom Is Nothing Then
        AddinTicked = oCom.Connect
    End If
End Property

Private Sub class_initialize()
    For Each oCom In Application.COMAddIns
        bAddinExists = False
        If oCom.ProgID Like "*BrochetWordAddin*" Then
            Set oAPI = oCom.Object
            bAddinExists = True
            Exit For
        End If
    Next oCom
End Sub

Public Sub Initialize(OfficeApplication As Object)
    For Each oCom In OfficeApplication.COMAddIns
        bAddinExists = False
        If oCom.ProgID Like "*BrochetWordAddin*" Then  'ProgID = "BrochetPaste" Then
            Set oAPI = oCom.Object
            bAddinExists = True
            Exit For
        End If
    Next oCom
End Sub

Public Function isReady() As Boolean
    If Not oAPI Is Nothing Then
        isReady = True
    Else
        isReady = False
    End If
End Function

Public Function RunOperation(operation As String, _
        Optional parameter1 As Variant = Nothing, _
        Optional parameter2 As Variant = Nothing, _
        Optional parameter3 As Variant = Nothing, _
        Optional parameter4 As Variant = Nothing) As Boolean
    On Error GoTo ErrorHandler
    If Not oAPI Is Nothing Then
        RunOperation = oAPI.RunOperation(operation, parameter1, parameter2, parameter3, parameter4)
    End If
CleanExit:
    Exit Function
ErrorHandler:
    MsgBox "The function is unavailable." & vbCrLf & "Is Main add-in enabled?", vbCritical, "Function unavailable"
    Resume CleanExit
End Function



Attribute VB_Name = "cUndoRecord"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'***********************************************************************************
'*
'* Module: cUndoRecord
'*
'* Class for working with undostack in word 2010 and 2013. DOes not work in 2007
'* and earlier, but wont crash either
'***********************************************************************************

Option Explicit

#If VBA7 Then
    Private oUndoRecord As undoRecord
#End If

Private iRecordCount As Integer
Private bCanClose As Boolean

Private Sub class_initialize()
    iRecordCount = 0
    bCanClose = False
End Sub

Public Sub SetName(value As String)
    #If VBA7 Then
        Set oUndoRecord = Application.undoRecord
        iRecordCount = iRecordCount + 1
        If Not oUndoRecord.IsRecordingCustomRecord Then
            bCanClose = True
            oUndoRecord.StartCustomRecord value
        End If
    #End If
End Sub

Public Sub EndRecording()
    #If VBA7 Then
        If Not oUndoRecord Is Nothing Then
            If iRecordCount > 0 Then
                iRecordCount = iRecordCount - 1
                If oUndoRecord.IsRecordingCustomRecord And iRecordCount = 0 And bCanClose Then
                    oUndoRecord.EndCustomRecord
                    bCanClose = False
                    'Set oUndoRecord = Nothing
                End If
            End If
        End If
    #End If
End Sub

Private Sub Class_Terminate()
    iRecordCount = 0
    #If VBA7 Then
        If Not oUndoRecord Is Nothing Then
            If oUndoRecord.IsRecordingCustomRecord And bCanClose Then
                oUndoRecord.EndCustomRecord
                Set oUndoRecord = Nothing
            End If
        End If
    #End If
End Sub
Attribute VB_Name = "frmChartInfo"
Attribute VB_Base = "0{84DED1ED-4150-48BB-94FD-2BA1E37A9AE1}{8274AB6A-55B9-4618-9F74-6BA89588BD92}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: frmChartInfo
'*
'* Displays a dialog box containing options for a Provensis table
'***********************************************************************************

Option Explicit

Const msMODULE As String = "frmChartInfo"



Private Sub btnChartLinks_Click()

    On Error GoTo err

    Unload Me
    Dialogs(wdDialogEditLinks).Show

clean:
    Exit Sub

err:
    modError.DisplayMsg "There are no linked Charts in this document"
    Resume clean


End Sub

Private Sub btnClose_Click()

    Unload Me

End Sub



Private Sub btnCopy_Click()


    If txtSource.SelText = "" Then
        txtSource.SelStart = 0
        txtSource.SelLength = Len(txtSource)
    End If
    txtSource.Copy
    

End Sub

Private Sub UserForm_Initialize()


    modUserFormUtilities.CentreFormOnScreen Me
    
    If Selection.InlineShapes.count = 1 Then
        If Selection.InlineShapes(1).Type = wdInlineShapePicture Then
            txtSource = Selection.InlineShapes(1).AlternativeText
            If txtSource = "" Then
                txtSource = "This image was not inserted by Brochet Image Tool and therefore does not have any information to display here." & vbCrLf & _
                            "Click on the Chart Links button below to get more information on linked files"
            End If
        End If
    End If

End Sub
Attribute VB_Name = "frmInsertImage"
Attribute VB_Base = "0{164B7704-57AD-4D33-881C-FDBCC86CBE2C}{4AD066B2-E7D5-4181-AC07-95E6D443114D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: frmInsertImage
'*
'* Displays a dialog box containing options for a Provensis table
'***********************************************************************************

Option Explicit

Const msMODULE As String = "frmInsertImage"

Private objPPoint As Object


'++*******************************************************************
' Procedure:    butCancel_Click
' Author:       Brochet Ltd
' Description:  Cancel Button pressed, close dialog box and new document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butCancel_Click()

    Me.Tag = 1
    Me.hide
    
End Sub

'++*******************************************************************
' Procedure:    butOk_Click
' Author:       Brochet Ltd
' Description:  OK Button pressed, close dialog box and update header
'               if required and insert the new text.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butOk_Click()

    Dim oExcel As Object

    'Hide the form
    Me.hide
    

    If obt1 Then
        'Insert a picture
        modImages.ImageGetAndInsert
    
    ElseIf obt2 Then
        'Insert the selected chart from Excel
        Set oExcel = GetExcelObject
        If Not oExcel Is Nothing Then
            If modMicrosoftExcelChart.InsertExcelChart(oExcel, cbxInsertAsEMF, Not cbxInsertAsEMF) = False Then
                Me.Tag = 1
            End If
        End If
        
    ElseIf obt3 Then

        modMicrosoftPowerPoint.InsertPowerPointObjectOnly False, True

    Else
        'Do nothing - saftey check
    End If

    Me.hide
    
    Exit Sub
    
butOk_Click_EH:
    Const sProcedure As String = "butOK_Click"
    GlobalErrorHandler err.Number, err.Description, msMODULE, sProcedure

End Sub


'++*******************************************************************
' Procedure:    UserForm_Initialize
' Author:       Brochet Ltd
' Description:  Initialse the dialog box with the default settings.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub UserForm_Initialize()

    Dim bExcelLoaded As Boolean
    Dim bExcelChart As Boolean
    Dim dExcelVersion As Double
    Dim oExcel As Object

    Dim bPPointLoaded As Boolean

    modUserFormUtilities.CentreFormOnScreen Me


    'Set the wait cursor as sometimes it take a while to check Excel and PowerPoint
    System.Cursor = wdCursorWait

    'Need to see if Excel is open
    On Error GoTo ExcelNotLoaded
    
    'Create the Excel object
    Set oExcel = GetExcelObject
    
    If Not oExcel Is Nothing Then
        bExcelLoaded = True
        dExcelVersion = oExcel.Version
        If oExcel.ActiveChart Is Nothing Then
            bExcelChart = False
        Else
            bExcelChart = True
        End If
    End If

ExcelNotLoaded:

    If bExcelLoaded Then
        On Error GoTo ExcelError
        If bExcelChart Then
            imgExcelInfo.ControlTipText = "There is an Excel chart selected!"
            obt2.enabled = True
            cbxInsertAsEMF.enabled = True
            obt2.value = True
        Else
            imgExcelInfo.ControlTipText = "There is NO Excel chart selected!"
            obt2.enabled = False
            cbxInsertAsEMF.enabled = False
        End If

    Else
ExcelError:
        On Error GoTo 0
        imgExcelInfo.ControlTipText = "Excel is not open! Open Excel and select the chart to insert"
        obt2.enabled = False
        cbxInsertAsEMF.enabled = False
    End If


    'Need to see if PopwerPoint is loaded
    bPPointLoaded = PowerPointObjectExists

    If bPPointLoaded Then
        On Error GoTo PowerPointError
        'Now need to see is there is a presentation open
        If objPPoint.Presentations.count >= 1 Then
            'Need to see if an object is selected
            'If objPPoint.ActiveWindow.Selection.Type = ppSelectionShapes Then
            If objPPoint.ActiveWindow.Selection.Type = 2 Then
                If objPPoint.ActiveWindow.Selection.ShapeRange.count = 1 Then
                    obt3.enabled = True
                    imgPPointInfo.ControlTipText = "There is a PowerPoint object currently selected!"
                    If obt2.enabled = True Then
                        obt3.value = False
                    Else
                        obt3.value = True
                    End If
                Else
                    obt3.enabled = False
                    imgPPointInfo.ControlTipText = "Too many objects are selected in PowerPoint!"
                End If
            Else
PowerPointError:
                On Error GoTo 0
                obt3.enabled = False
                imgPPointInfo.ControlTipText = "An object is NOT currently selected in PowerPoint!"
            End If
        Else
            obt3.enabled = False
            imgPPointInfo.ControlTipText = "There are no presentations open in PowerPoint!"
        End If

    Else
        obt3.enabled = False
        imgPPointInfo.ControlTipText = "PowerPoint is not open! Open PowerPoint and select the chart to insert"
    End If

  
    Me.Caption = COMPANY_NAME & " - " & Me.Caption
    
    System.Cursor = wdCursorNormal
        
End Sub



'++*******************************************************************
' Procedure:    PowerPointObjectExists
' Author:       Brochet Ltd
' Description:  Check to see if PowerPoint is currently open.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Function PowerPointObjectExists() As Boolean
    
    
    PowerPointObjectExists = False
    On Error Resume Next
    
    Set objPPoint = GetObject(, "PowerPoint.Application")
    
    If err = 0 Then
        PowerPointObjectExists = True
    End If
    
End Function


Attribute VB_Name = "frmNewDoc"
Attribute VB_Base = "0{8F5C4CB7-7FB5-4FD6-9373-B6473B425189}{CD6FD048-2CB2-4EC3-B333-2CE64FAE69AC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: frmNewDoc
'*
'* New Document dialog box with fields for the new document options
'***********************************************************************************

Option Explicit
Option Compare Text

Const msMODULE As String = "frmNewDoc"

Private mbinitializationSuccessfull As Boolean

Dim sTitlePageGraphicslocation As String
Dim sDateFormat As String
Dim bTandCValidFile As Boolean
Dim msDateFormat As String
Dim miDisclosureFileNo As Integer
Dim msDisclosureText As String

'Dim gbTitlePageImageOption As Boolean  'Set to true if the document has a Title Page Image for Option 1
'Dim gbTitlePageImageOption2 As Boolean  'Set to true if the document has a Title Page Image for Option 2
Dim gsTitlePageImageOption As String  'Set to true if the document has a Title Page Image for Option 1
'Dim gsTitlePageImageOption2Text As String  'Set to true if the document has a Title Page Image for Option 2

Const sPaperUS As String = "US Letter"
Const sPaperUK As String = "A4"

Const sLanguageUS As String = "US English"
Const sLanguageUK As String = "UK English"

Dim msContactString1 As String
Dim msContactString2 As String

Private Const sAuthorIniFieldList1 As String = "cbxAuthor1,txtJobTitle1," & _
  "txtContactTel1,txtContactEmail1,txtContactCompany1,txtContactAddress11,txtContactAddress21,txtContactPostCode1"
  
Private Const sAuthorIniFieldList2 As String = "cbxAuthor2,txtJobTitle2," & _
  "txtContactTel2,txtContactEmail2,txtContactCompany2,txtContactAddress12,txtContactAddress22,txtContactPostCode2"

Dim bFieldUpdate As Boolean

Const DISCLOSURE_FILE_DEFAULT As String = "{Use existing text}"



Private Sub btnJurisdiction_Click()

    modPrivate.SetRegistrySettingString "Brochet", "JurisdictionDefaultIndex", cmbJurisdiction

    
    MsgBox "Your Preferences have been saved", vbInformation, "Default Jurisdiction"

End Sub

'++*******************************************************************
' Procedure:    butCancel_Click
' Description:  Cancel Button pressed, close dialog box and new document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butCancel_Click()

    On Error GoTo butCancel_Click_EH
    
    'Unload the files
    Unload Me
    
    'Close the new document
    If gbNewDoc And Not gbStarterDoc Then
        ActiveDocument.Close wdDoNotSaveChanges
    End If
    
    Exit Sub
    
butCancel_Click_EH:
    Const sProcedure As String = "butCancel_Click"
    GlobalErrorHandler err.Number, err.Description, msMODULE, sProcedure
    
End Sub

Private Sub butSaveDefaultPaper_Click()

    modPrivate.SetRegistrySettingString "Brochet", "Papersize", cmbPapersize
    
    MsgBox "Your Preferences have been saved", vbInformation, "Default papersize"

End Sub

Private Sub butSaveDefaultLanguage_Click()

    modPrivate.SetRegistrySettingString "Brochet", "Language", cmbLanguage
    
    MsgBox "Your Preferences have been saved", vbInformation, "Default Language"

End Sub




Function TitlePageImageExists() As Boolean


    Dim shShape As Shape

    With ActiveDocument.Sections(1).Footers(wdHeaderFooterPrimary)
        
        For Each shShape In .Shapes
            If shShape.Name = "TitlePageImage" Then
                TitlePageImageExists = True
            End If
        Next
    
    End With
    
    
End Function



Private Sub cbxContactPage_Click()

    Dim cControl As control
    
    'Enable or disable all the control in the frame
    frmContact.enabled = cbxContactPage.value
    For Each cControl In frmContact.Controls
        cControl.enabled = cbxContactPage.value
    Next

End Sub

Private Sub cbxDisclosures_Click()


    Dim cControl As control
    
    'Enable or disable all the control in the frame
    frmDisclosures.enabled = cbxDisclosures.value
    For Each cControl In frmDisclosures.Controls
        cControl.enabled = cbxDisclosures.value
    Next
    
    
End Sub

Private Sub cmbJurisdiction_Change()
    
    PopulateDisclosures
    TogglePortabilityLanguage

End Sub


Sub TogglePortabilityLanguage()

    Dim sText As String
    Dim sKey As String
    
    cbxPortabilityLanguageUpdate.Visible = False
    sKey = cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1) & INI_KEY_PORTABILITYLANGUAGE
    
    sText = modINI.GetStringValue(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sKey)
    If sText = "True" And cbxTitlePg Then
        cbxPortabilityLanguage.enabled = True
        If modPages.IsPortabilityPageEnabled Then
            cbxPortabilityLanguage.value = True
            cbxPortabilityLanguageUpdate.Visible = True
        End If
    Else
        cbxPortabilityLanguage.enabled = False
        cbxPortabilityLanguage.value = False
    End If


End Sub

Sub PopulateDisclosures()

    Dim sText As String
    Dim j As Integer
    
    'Remember the last setting
    If miDisclosureFileNo <> 0 Then
        msDisclosureText = cmbDisclosures
    End If
    
    cmbDisclosures.Clear
    'Or (gbNewDoc = gbStarterDoc)
    If (Not gbNewDoc) Or (gbNewDoc = gbStarterDoc) Then
        cmbDisclosures.AddItem DISCLOSURE_FILE_DEFAULT
    End If
    
    
    ComboBoxFillFiles gsCompanyIniFileName, INI_SECTION_JURISDICTION, cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1) & "DisclosuresPath", cmbDisclosures
    
    If cmbDisclosures.ListCount > 0 Then
        
        If miDisclosureFileNo = 0 Then
            SetCombo cmbDisclosures, DISCLOSURE_FILE_DEFAULT
            miDisclosureFileNo = -1
        Else
            If msDisclosureText <> "" Then
                sText = msDisclosureText
            Else
                sText = GetCustomDocumentProperty("JurisdictionDisclosureFile")
            End If
            SetCombo cmbDisclosures, sText
        End If
    End If

End Sub

Sub PopulateOfficesCombo()


    Dim sText As String
    Dim j As Integer
    
    cmbLegalEntity.Clear

    j = 1
    sText = System.PrivateProfileString(gsCompanyIniFileName, "Offices", "Office" & j & "Name")
    While sText <> ""
        cmbLegalEntity.AddItem sText
        cmbLegalEntity.List(cmbLegalEntity.ListCount - 1, 1) = j
        j = j + 1
        sText = System.PrivateProfileString(gsCompanyIniFileName, "Offices", "Office" & j & "Name")
    Wend
    
    If cmbLegalEntity.ListCount > 0 Then
        cmbLegalEntity.ListIndex = 0
    End If

End Sub





Private Sub cmbLegalEntity_Change()

    Dim iIndex As Integer
    
    iIndex = cmbLegalEntity.List(cmbLegalEntity.ListIndex, 1)

    txtContactTelephone = modINI.GetStringValue(gsCompanyIniFileName, INI_SECTION_OFFICES, "Office" & iIndex & "TelephonePrefix")
    
    HighlightTelephoneExtension txtContactTelephone
    

End Sub

Sub HighlightTelephoneExtension(cControl As TextBox)

    Dim sText As String
    Dim i As Integer
    
    On Error Resume Next
    
    sText = cControl
    
    If sText <> "" Then
        i = InStr(1, sText, "X")
        With cControl
            i = i - 1
            .SelStart = i
            .SelLength = Len(sText) - i
            .SetFocus
        End With
        
    End If
    

End Sub

Private Sub btnDisclosuresSaveDefault_Click()

    If cmbDisclosures <> DISCLOSURE_FILE_DEFAULT Then
        modPrivate.SetRegistrySettingString "Brochet", "Disclosures", cmbDisclosures
        MsgBox "Your Preferences have been saved", vbInformation, "Default Disclosure"
    Else
        MsgBox "Please choose a valid option from the list", vbInformation, "Default Disclosure"
    End If
    

End Sub

Private Sub btnAddressDefault_Click()

    modPrivate.SetRegistrySettingString "Brochet", "Office", cmbLegalEntity
    
    MsgBox "Your Preferences have been saved", vbInformation, "Default Office"

End Sub



Private Sub optNONReport_Click()

    ShowHideNONReportOptions

End Sub

Sub ShowHideNONReportOptions()

    Dim cControl As control

    If optNONReport Then
    
        cbxTitlePg.value = False
        cbxTitlePg.enabled = False
            cbxPortabilityLanguage.Visible = False
        
        cbxExecutiveSummary.value = False
        cbxExecutiveSummary.enabled = False
        
        cbxContentsPg.value = False
        cbxContentsPg.enabled = False
        
        'Enable or disable all the control in the frame
        frmTitlePg.enabled = True
        For Each cControl In frmTitlePg.Controls
            cControl.enabled = True
        Next
        
    Else
    
        cbxTitlePg.enabled = True
            cbxPortabilityLanguage.Visible = True
        
        cbxExecutiveSummary.enabled = True
        cbxContentsPg.enabled = True
        
          'Enable or disable all the control in the frame
        frmTitlePg.enabled = cbxTitlePg.value
        For Each cControl In frmTitlePg.Controls
            cControl.enabled = cbxTitlePg.value
        Next
          
    End If



End Sub

Private Sub optReport_Click()

    ShowHideNONReportOptions

End Sub

Private Sub sbtDaySpin_SpinDown()
    
    Dim i As Integer
    Dim dt As Date
    
    'Check to see if the date in the footer is the same
    bFieldUpdate = False
    
    
    'Change the date
    If IsDate(Me.txtDate) Then
        dt = CVDate(Me.txtDate)
    Else
        dt = Date
    End If
    
    dt = dt - 1
    Me.txtDate = Format$(dt, msDateFormat)


    
End Sub

Private Sub sbtDaySpin_SpinUp()

    Dim i As Integer
    Dim dt As Date
    


    
    'Change the date
    If IsDate(Me.txtDate) Then
        dt = CVDate(Me.txtDate)
    Else
        dt = Date
    End If
    
    dt = dt + 1
    Me.txtDate = Format$(dt, msDateFormat)

    
End Sub

Private Sub sbtMonthSpin_SpinDown()

    Dim i As Integer
    Dim dt As Date
    

    
    If IsDate(Me.txtDate) Then
        dt = CVDate(Me.txtDate)
    Else
        dt = Date
    End If
    
    dt = DateSerial(Year(dt), Month(dt) - 1, Day(dt))
    Me.txtDate = Format$(dt, msDateFormat)
    
    

    
End Sub

Private Sub sbtMonthSpin_SpinUp()

    Dim i As Integer
    Dim dt As Date
    

    
    If IsDate(Me.txtDate) Then
        dt = CVDate(Me.txtDate)
    Else
        dt = Date
    End If
    
    dt = DateSerial(Year(dt), Month(dt) + 1, Day(dt))
    Me.txtDate = Format$(dt, msDateFormat)


End Sub



Private Sub cbxContentsPg_Click()

    Dim cControl As control
    
    'Enable or disable all the control in the frame
    frmContentsPg.enabled = cbxContentsPg.value
    For Each cControl In frmContentsPg.Controls
        cControl.enabled = cbxContentsPg.value
    Next
    
End Sub


'++*******************************************************************
' Procedure:    cbxTitlePg_Change
' Description:  The status of the Title Page option has changed
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub cbxTitlePg_Change()

    Dim cControl As control

    'Enable or disable all the control in the frame
    frmTitlePg.enabled = cbxTitlePg.value
    For Each cControl In frmTitlePg.Controls
        cControl.enabled = cbxTitlePg.value
    Next


    TogglePortabilityLanguage
    
    
    'Need to set all the Inside Title page options
'    frmInsideTitlePage.enabled = cbxInsideTitlePage.value And cbxTitlePg.value
'    For Each cControl In frmInsideTitlePage.Controls
'        cControl.enabled = cbxInsideTitlePage.value And cbxTitlePg.value
'    Next
End Sub




'++*******************************************************************
' Procedure:    butOk_Click
' Description:  OK Button pressed. Insert all the data into the new
'               letter document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butOk_Click()

    Dim bSmartCut As Boolean
    Dim sText As String
    
    Dim bTitlePgExists As Boolean
    Dim bInsideTitlePgExists As Boolean
    Dim bExecutiveSummary As Boolean
    Dim bContentsPgExists As Boolean
    Dim bBackPageExists As Boolean
    Dim rHeader As Range
    
    Dim tTbl As Table
    Dim iSecNo As Integer
    
    Dim oProgress As frmProgress
    
    Set oProgress = New frmProgress
    oProgress.Init "Update Document", "Part", 14, 1


    'On Error GoTo butOk_Click_EH
    
    'Need to check that there is data in the DocTitle and DocSubTitle fields
'    If (txtDocTitle = "" Or txtDocType = "") And cbxTitlePg.value Then
'        MsgBox "There needs to be some text in the following Title Page Details fields:" & vbCr & "   Document Title and" & vbCr & "   Document Subtitle", vbInformation, COMPANY_NAME_SHORT & " Title Page Options"
'        If txtDocTitle = "" Then
'            Me.txtDocTitle.SetFocus
'            Me.txtDocTitle.SelStart = 0
'            Me.txtDocTitle.SelLength = Len(Me.txtDocTitle)
'        Else
'            Me.txtDocType.SetFocus
'            Me.txtDocType.SelStart = 0
'            Me.txtDocType.SelLength = Len(Me.txtDocType)
'        End If
'        Exit Sub
'    End If

    'Switch update screen off
    modScreenUpdating.ScreenUpdating_Disable

    'If smart cut and pastes is set to on switch off
    bSmartCut = False
    If Options.SmartCutPaste = True Then
        bSmartCut = True
        Options.SmartCutPaste = False
    End If

    Me.hide
    oProgress.Show
    'Change the cursor to Wait
    System.Cursor = wdCursorWait

    'Mark document - so can distinguish between new and starter documents
    modPrivate.DocVarSet "NewDoc", False

    'Save the Date format as always used for at least the footer date
    modPrivate.SetDocVar "DateFormat", msDateFormat

    'Save header/footer info
    'modPrivate.SetDocVar "HideAppendixPageNo", Not cbxAppendixPageNo.value

    'bTitlePgExists = modPages.IsTitlePageEnabled
    bInsideTitlePgExists = False 'modPages.IsInsideTitlePageEnabled
    bExecutiveSummary = modPages.IsExecutiveSummaryEnabled
    bContentsPgExists = modPages.IsContentsPageEnabled
    bBackPageExists = modPages.IsContactPageEnabled


        oProgress.Step

    TurnOffALTF9
        
        oProgress.Step

    AddRemoveTitlePage

    
        oProgress.Step

    AddRemovePortabilityLanguage

    
        oProgress.Step

    AddRemoveExecutiveSummary

    
        oProgress.Step

    AddRemoveContactPage

        oProgress.Step

    AddRemoveDisclosures
    
        oProgress.Step

    SetHeaderFooter

    If cbxTitlePg Then

        
        oProgress.Step
        
        oProgress.Step
        
        oProgress.Step
        'Re-create Title Page Text
        If gbNewDoc Then
            
        End If


        oProgress.Step

    Else
        'Reset the Title Page options
        modPrivate.SetDocVar "TitlePageType", ""
        modPrivate.SetDocVar "TitlePageOption", ""
        modPrivate.SetDocVar "TitlePageImagePath", ""
        modPrivate.SetDocVar "TitlePageImage", ""
        oProgress.Step
        oProgress.Step
        oProgress.Step
        oProgress.Step
    End If

'    '**********************************************
'    '* Update or delete the Contents page/section *
'    '**********************************************

    AddRemoveTOC
    
    oProgress.Step

        
    If optNONReport.value Then
        modPrivate.SetDocVar "RFPReport", "False"
        ModifyReportType False
        WriteNONReportPageText
    Else
        modPrivate.SetDocVar "RFPReport", "True"
        ModifyReportType True
    End If


    SetPagesize cmbPapersize
    
    oProgress.Step

    SetDocumentSpellingLanguage cmbLanguage
    
    oProgress.Step

        
    GotoStartingPoint
    
    'Corrects the size of the A4
    'CorrectA4PageIssue
    
    oProgress.CloseMe

    modFields.UpdateAllFieldCodes

    System.Cursor = wdCursorNormal

    'Switch update screen on
    modScreenUpdating.ScreenUpdating_Enable
    
    'Upload the form
    Unload Me
    
    Exit Sub
   
butOk_Click_EH:
    Const sProcedure As String = "butOk_Click"
    GlobalErrorHandler err.Number, err.Description, msMODULE, sProcedure
    
End Sub


Sub GotoStartingPoint()

     'Goto the CC or bookmark StartHere if exists and then delete the bookmark
    If modContentControls.ContentControlExists("ccStartHere") Then
        modContentControls.GetRangeFromTag("ccStartHere").Select
        If ActiveDocument.Bookmarks.Exists("StartHere") Then
            ActiveDocument.Bookmarks("StartHere").Delete
        End If

    ElseIf ActiveDocument.Bookmarks.Exists("StartHere") Then
        ActiveDocument.Bookmarks("StartHere").Select
        ActiveDocument.Bookmarks("StartHere").Delete
    End If
    
    ActiveWindow.ScrollIntoView Selection.Range
    
End Sub

Sub WriteNONReportPageText()


    WriteNONReportDisclaimer
    
    modContentControls.ReplaceWithTextInControl "ccDate2", txtDate, "NR Date"
    modContentControls.ReplaceWithTextInControl "ccProspect2", txtProspect, "NR Title"
    modContentControls.ReplaceWithTextInControl "ccType2", txtType, "NR Subtitle"

End Sub

Sub TurnOffALTF9()

    If ActiveWindow.View.ShowFieldCodes Then
        ActiveWindow.View.ShowFieldCodes = False
    End If

End Sub



Sub ModifyReportType(bSetAsReport As Boolean)


    Dim sMainDoc As Section

    If bSetAsReport Then
        Set sMainDoc = GetMainSection
        If Not sMainDoc Is Nothing Then
            sMainDoc.PageSetup.DifferentFirstPageHeaderFooter = False
        End If
    Else
        Set sMainDoc = GetMainSection
        If Not sMainDoc Is Nothing Then
            sMainDoc.PageSetup.DifferentFirstPageHeaderFooter = True
            InsertAutotext "z_HeaderNONReport", sMainDoc.Headers(wdHeaderFooterFirstPage).Range, True, True
            InsertAutotext "z_Footer_NONReport", sMainDoc.Footers(wdHeaderFooterFirstPage).Range, True, True
        End If
    End If


End Sub


Function GetMainSection() As Section

    Dim i As Integer

    If GetPageSection(PAGEID_TitlePage) > 0 Then i = i + 1
    If GetPageSection(PAGEID_PortabilityLanguagePage) > 0 Then i = i + 1
    If GetPageSection(PAGEID_ExecutiveSummary) > 0 Then i = i + 1
    If GetPageSection(PAGEID_TOC) > 0 Then i = i + 1
    
    i = i + 1
    
    Set GetMainSection = ActiveDocument.Sections(i)
    

End Function

Sub SetHeaderFooter()

    Dim sText As String
    
    If txtHeader = "" Then
        sText = txtProspect
    Else
        sText = txtHeader
    End If
    
    sText = StripCRLF(sText)
    
    modDocumentProperties.SetCustomDocumentProperty "InsightHeader", sText
    modDocumentProperties.SetCustomDocumentProperty "InsightFooter", txtFooter


End Sub

Function StripCRLF(sText As String) As String

    sText = Replace(sText, vbCrLf, " ")
    sText = Replace(sText, Chr(11), " ")
    
    StripCRLF = sText

End Function


Sub AddRemoveTOC()


    Dim bContentsPgExists As Boolean
    Dim iSecNo As Integer

    bContentsPgExists = modPages.IsContentsPageEnabled

    Dim bTOCExists As Boolean
    Dim iInsertionSection As Integer
    
    bTOCExists = modPages.IsContentsPageEnabled

    If cbxContentsPg And Not bTOCExists Then
        'Insert the Inside Title Page
        If modPages.IsTitlePageEnabled Then iInsertionSection = iInsertionSection + 1
        'If modPages.IsInsideTitlePageEnabled Then iInsertionSection = iInsertionSection + 1
        If modPages.IsExecutiveSummaryEnabled Then iInsertionSection = iInsertionSection + 1
        
        iSecNo = iInsertionSection + 1
        modPages.InsertTOC (iSecNo)
    ElseIf Not cbxContentsPg And bTOCExists Then
        'Delete the Inside Title Page
        modPages.DeleteSection modPages.GetPageSection(PAGEID_TOC), , True
    End If


    If cbxContentsPg Then


        'Need to set the TOC to include / exclude the page numbers in the Appendix
'        If cbxAppendixPageNo Then
            If obtOpt1 Then
                ReplaceTOCFieldCode 1
            Else
                ReplaceTOCFieldCode 3

            End If
'        Else
'            If obtOpt1 Then
'                ReplaceTOCFieldCode 2
'            ElseIf obtOpt2 Then
'                ReplaceTOCFieldCode 4
'
'            End If
'        End If


        If obtOpt1 Then
            modPrivate.SetDocVar "ContentsPageToCType", "1"
        ElseIf obtOpt2 Then
            modPrivate.SetDocVar "ContentsPageToCType", "2"
        Else
            modPrivate.SetDocVar "ContentsPageToCType", "1"
        End If
    Else
        modPrivate.SetDocVar "ContentsPageToCType", "1"
    End If


End Sub

Sub AddRemoveContactPage()


    Dim bContactPageExists As Boolean
    Dim iPageCount As Integer

    bContactPageExists = modPages.IsContactPageEnabled

    If cbxContactPage And Not bContactPageExists Then
        'Insert the Contact Page
        modPages.InsertContactPage
    ElseIf Not cbxContactPage And bContactPageExists Then
        'Delete the Contact Page
        modContentControls.DeleteContentControl CC_CONTACT_PAGE
    End If


    If modPages.IsContactPageEnabled Then
        writeContactDetails
    End If

End Sub

Sub AddRemoveDisclosures()

    Dim bDisclosurePageExists As Boolean
    Dim iPageCount As Integer

    bDisclosurePageExists = modPages.IsDisclosureEnabled

    If cbxDisclosures And Not bDisclosurePageExists Then
        'Insert the Contact Page
        modPages.InsertDisclosurePage
        
    ElseIf Not cbxDisclosures And bDisclosurePageExists Then
        'Delete the Contact Page
        modContentControls.DeleteContentControl CC_BROCHET_DISCLOSURES_GROUP
    End If
    
    If bDisclosurePageExists Then
        SetDisclosurePagetext
    End If

End Sub


Sub SetDisclosurePagetext()

    Dim ccControl As ContentControl
    Dim sPathAndFile As String
    Dim rRange As Range
    
    'Nikki - i have not changed this code when added the first option to keep the information the same as the file is invalid
    'so nothing is updated!!!
    
        If ContentControlExists(CC_BROCHET_DISCLOSURES_GROUP) Then
            sPathAndFile = cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1) & "DisclosuresPath"
            If sPathAndFile <> "" Then
                sPathAndFile = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1) & "DisclosuresPath")
                'sPathAndFile = expand path
                sPathAndFile = sPathAndFile & "\" & cmbDisclosures
                If modPrivate.FileExists(sPathAndFile) Then
                    Set rRange = modContentControls.GetRangeFromTag(CC_BROCHET_DISCLOSURES_GROUP)
                    If Not rRange Is Nothing Then
                        rRange.Style = wdStyleNormal
                        rRange.InsertFile sPathAndFile
                        modContentControls.ClearFirstSpaceAndLastPara CC_BROCHET_DISCLOSURES_GROUP
                    End If
                End If
            End If
        End If
        
        SetCustomDocumentProperty "JurisdictionDisclosureFile", cmbDisclosures
        

End Sub


Sub SetPortabilityLanguagePagetext()

    Dim ccControl As ContentControl
    Dim sPathAndFile As String
    Dim rRange As Range
    
        If ContentControlExists(CC_PORTABILITY_LANGUAGE) Then
            sPathAndFile = cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1) & "PortabilityLanguageFile"
            If sPathAndFile <> "" Then
                sPathAndFile = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sPathAndFile)

                If modPrivate.FileExists(sPathAndFile) Then
                    Set rRange = modContentControls.GetRangeFromTag(CC_PORTABILITY_LANGUAGE)
                    If Not rRange Is Nothing Then
                        rRange.Style = wdStyleNormal
                        rRange.InsertFile sPathAndFile
                        modContentControls.ClearFirstSpaceAndLastPara CC_PORTABILITY_LANGUAGE
                    End If
                End If
            End If
        End If
        

End Sub


Sub ChangeDocTitleStyle(sStyle As String)

    Dim tTable As Table
    Set tTable = GetTable("BrochetTitlePageTable", ActiveDocument.Sections(1).Range)
    
    If Not tTable Is Nothing Then
        With tTable.Cell(1, 1).Range
            .Paragraphs(1).Style = sStyle
        End With
        With tTable.Cell(3, 1).Range
            If Right(sStyle, 5) = "White" Then
                .Style = "TitlePageFieldsWhite"
            Else
                .Style = "TitlePageFields"
            End If
        End With
    End If


End Sub






Sub RenameShape(rRange As Range, sName As String)

    Dim shShape As Shape
    
    For Each shShape In rRange.ShapeRange
        shShape.Name = sName
    Next

End Sub

Sub AddRemoveTitlePage()

    Dim bTitlePageExists

    bTitlePageExists = modPages.IsTitlePageEnabled

    If cbxTitlePg Then
        If Not bTitlePageExists Then
            modPages.InsertTitlePgSection
            If ActiveDocument.Sections(1).PageSetup.PaperSize = wdPaperA4 Then
                SwitchTitlePageHeader True
            Else
                SwitchTitlePageHeader False
            End If
        End If
        WriteTitlePageText
    Else
        If bTitlePageExists Then
            modPages.DeleteSection 1, , True
        End If
    End If

   
    SaveTitlePageText
    
    SetCustomDocumentProperty "JurisdictionIndex", cmbJurisdiction
    SetCustomDocumentProperty "OfficeIndex", cmbLegalEntity
    

End Sub


Sub SaveTitlePageText()

    SetCustomDocumentProperty "TitlePageTitle", txtProspect
    SetCustomDocumentProperty "TitlePageSubtitle", txtType
    SetCustomDocumentProperty "TitlePageDate", txtDate

End Sub



Sub AddRemovePortabilityLanguage()

    Dim bPortabilityLanguagePageExists As Boolean

    bPortabilityLanguagePageExists = modPages.IsPortabilityPageEnabled

    If cbxPortabilityLanguage And Not bPortabilityLanguagePageExists Then
        'Insert the Inside Title Page
        modPages.InsertPortabilityLanguageSection (modPages.GetPageSection(PAGEID_TitlePage) + 1)
    ElseIf Not cbxPortabilityLanguage And bPortabilityLanguagePageExists Then
        'Delete the Inside Title Page
        modPages.DeleteSection modPages.GetPageSection(PAGEID_PortabilityLanguagePage), , True
    End If

    If modPages.IsPortabilityPageEnabled Then
        If cbxPortabilityLanguageUpdate Then
            SetPortabilityLanguagePagetext
        End If
    End If


End Sub

Sub AddRemoveExecutiveSummary()


    Dim bExecutiveSummaryExists As Boolean
    Dim iInsertionSection As Integer
    
    bExecutiveSummaryExists = modPages.IsExecutiveSummaryEnabled

    If cbxExecutiveSummary And Not bExecutiveSummaryExists Then
        'Insert the Inside Title Page
         If modPages.IsTitlePageEnabled Then iInsertionSection = iInsertionSection + 1
         'If modPages.IsInsideTitlePageEnabled Then iInsertionSection = iInsertionSection + 1
         
        modPages.InsertExecutiveSummary (iInsertionSection + 1)
    ElseIf Not cbxExecutiveSummary And bExecutiveSummaryExists Then
        'Delete the Inside Title Page
        modPages.DeleteSection modPages.GetPageSection(PAGEID_ExecutiveSummary)
    End If



End Sub



Sub SetPaperSizeCombo(combo As ComboBox)

    If ActiveDocument.Sections(1).PageSetup.PaperSize = wdPaperA4 Then
        combo = sPaperUK
    Else
        combo = sPaperUS
    End If
    

End Sub

Sub SetLanguageCombo(combo As ComboBox)

    If ActiveDocument.Styles(wdStyleNormal).LanguageID = wdEnglishUS Then
        combo = sLanguageUS
    Else
        combo = sLanguageUK
    End If
    
End Sub


Sub SetDocumentSpellingLanguage(combo As ComboBox)

    Select Case combo
    Case sLanguageUK
        ActiveDocument.Styles(wdStyleNormal).LanguageID = wdEnglishUK
    Case sLanguageUS
        ActiveDocument.Styles(wdStyleNormal).LanguageID = wdEnglishUS
    Case Else
        ActiveDocument.Styles(wdStyleNormal).LanguageID = wdEnglishUS
    End Select


End Sub

Sub PopulatePapersizeCombo(combo As ComboBox)

    combo.AddItem sPaperUK
    combo.AddItem sPaperUS
    

End Sub

Sub PopulateLanguageCombo(combo As ComboBox)

    combo.AddItem sLanguageUK
    combo.AddItem sLanguageUS

End Sub

Sub ReadDefaultPaperSize(combo As ComboBox)

    Dim sPapersize As String
    sPapersize = modPrivate.GetRegistrySettingString("Brochet", "Papersize")
    combo = IIf(sPapersize = "", sPaperUK, sPapersize)
    
End Sub

Sub ReadDefaultLanguage(combo As ComboBox)

    Dim sLanguage As String
    
    sLanguage = modPrivate.GetRegistrySettingString("Brochet", "Language")
    combo = IIf(sLanguage = "", sLanguageUK, sLanguage)

End Sub

Sub ReadDefaultOffice(combo As ComboBox)

    Dim sOffice As String
    
    sOffice = modPrivate.GetRegistrySettingString("Brochet", "Office")
    SetCombo combo, sOffice
    

End Sub

Sub SetPagesize(combo As ComboBox)

    
    If combo = sPaperUK Then
        If ActiveDocument.Sections(1).PageSetup.PaperSize = wdPaperLetter Then
            modPages.SetAllPagesAsType True
            SwitchTitlePageHeader True
        End If
    Else
        If ActiveDocument.Sections(1).PageSetup.PaperSize = wdPaperA4 Then
            modPages.SetAllPagesAsType False
            SwitchTitlePageHeader False
        End If
    End If


End Sub

Sub SwitchTitlePageHeader(bMetric As Boolean)

    Dim sAutotext As String
    Dim rRange As Range
    
    If bMetric Then
        sAutotext = "z_TitlePageHeaderA4"
    Else
        sAutotext = "z_TitlePageHeaderLetter"
    End If
        
    Set rRange = ActiveDocument.Sections(1).Headers(wdHeaderFooterPrimary).Range
        
    If Not rRange Is Nothing Then
        modPrivate.InsertAutotext sAutotext, rRange
    End If
    

End Sub

Sub CorrectA4PageIssue()

    Dim sSection As Section
    
    For Each sSection In ActiveDocument.Sections
        If sSection.PageSetup.Orientation = wdOrientPortrait Then
            Selection.PageSetup.PaperSize = Selection.PageSetup.PaperSize
        End If
    Next
    
End Sub

'++*******************************************************************
' Procedure:    ReplaceTOCFieldCode
' Author:       Brochet ltd
' Description:  Need to find the TOC field code and replace it with the
'               correct TOC code
'               nType = 1 Only DividerTitle style - TOC2
'               nType = 2 DividerTitle style - TOC1, Heading 1s - TOC2
'               nType = 3 DividerTitle style - TOC1, Heading 1s - TOC2, Heading 2s - TOC3
' Parameters:   n/a
' Returns:      n/a
'--********************************************************************
Sub ReplaceTOCFieldCode(nType As Integer, Optional iTOX As Integer = 0)

    Dim fld As Field
    Dim rng As Range
    Dim sTOX As String
    Dim rTOC As Range
     
    modContentControls.ReplaceWithTextInControl "BrochetTOCGroup", ""
'Set rTOC = GetTOCRange
    
    
     
    Select Case nType
        Case 1
            'Option 1 With Numbering - H2
            sTOX = "TOC  \h \z \t ""Heading 1,1,Heading 1 NoNumb,2,Heading 2,3,Heading 2 NoNumb,4,Appendix,5"""
            '"TOC  \h \z \t ""Heading 1,1,Heading 1 NoNumb,1,Heading 2,2,Heading 2 NoNumb,2,Appendix,4,Appx 2,5"""
        Case 2
            'Option 1 No Numbering - H2
            'sTOX = "TOC \h \z \t ""Heading 1NoNumb,1,Heading 2NoNumb,2,Heading 2,2,Heading 1,4,Heading 6,6,"" \n 6-6"
        Case 3
            'Option 2 with Numbering - H1 & H2
            sTOX = "TOC  \h \z \t ""Heading 1,1,Heading 1 NoNumb,2,Appendix,5"""
        Case 4
            'Option 2 No Numbering - H1 & H2
            'sTOX = "TOC \t ""Heading 1,1,Heading 1Land,1,Heading 2,1,Heading 2Land,2,Heading 3,3,Heading 3Land,3,Heading 4,2,Document Heading 1,4,Document Heading 2,5"" \n ""1-2"" """
        Case 5
            'Option 3 with Numbering H2 an H3
            'sTOX = "TOC \t ""Heading 1,1,Heading 1Land,1,Heading 2,1,Heading 2Land,2,Heading 3,3,Heading 3Land,3,Heading 4,2,Document Heading 2,4,Document Heading 3,5"" \n ""1-1"" """
        Case 6
            'Option 3 No Numbering  H2 an H3
            'sTOX = "TOC \t ""Heading 1,1,Heading 1Land,1,Heading 2,1,Heading 2Land,2,Heading 3,3,Heading 3Land,3,Heading 4,2,Document Heading 2,4,Document Heading 3,5"" \n ""1-2"" """
            
 
    End Select
    
'    rTOC.Collapse wdCollapseStart
'    rTOC.Style = wdStyleNormal
'    modFields.InsertField rTOC, sTOX, "Normal"
    modContentControls.AppendFieldtoCC "BrochetTOCGroup", sTOX
     
     modContentControls.ClearFirstSpaceAndLastPara "BrochetTOCGroup"

'    If iTOX And 4 Then
'
'        InsertText rTOC, "Tables", "Heading 2NoTOC"
'        rTOC.Collapse wdCollapseEnd
'        InsertText rTOC, "", "Normal"
'
'        sTOX = "TOC \h \z \t ""Table Title,8"""
'        modFields.InsertField rTOC, sTOX, "Normal"
'
'    End If
'    If iTOX And 2 Then
'        InsertText rTOC, "Figures", "Heading 2NoTOC"
'        rTOC.Collapse wdCollapseEnd
'        InsertText rTOC, "", "Normal"
'
'        sTOX = "TOC \t ""Figure Title,8"" "
'        modFields.InsertField rTOC, sTOX, "Normal"
'End If
    


End Sub

Function GetTOCRange() As Range
    'Returns TOC range without the heading

    Dim iTOCSection As Integer
    Dim iTOCStart As Integer
    Dim iTOCEnd As Integer
    Dim rStart As Range
    Dim rEnd As Range
    
    
    iTOCSection = GetPageSection(PAGEID_TOC)
    
    If iTOCSection > 0 Then
        Set rStart = ActiveDocument.Sections(iTOCSection).Range
        'iTOCStart = rStart
        rStart.Collapse wdCollapseStart
        While rStart.Paragraphs(1).Style = "Heading 1NoTOC"
            rStart.Move wdParagraph, 1
        Wend
        While rStart.Paragraphs(1).Style = "Heading 1ExtraLine"
            rStart.Move wdParagraph, 1
        Wend
        
        Set rEnd = ActiveDocument.Sections(iTOCSection).Range
        rEnd.Collapse wdCollapseEnd
        'rEnd.Move wdCharacter, -2
        rStart.End = rEnd.Start
        rStart.MoveEnd wdCharacter, -2
        Set GetTOCRange = rStart
        
        
    End If


End Function


Private Sub cbxVersPg_Change()
    
'    Me.lblDisclaimer.enabled = Me.cbxVersPg
'    Me.cmbDisclaimer.enabled = Me.cbxVersPg
    
End Sub



Private Sub frmTitlePg_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    
    bFieldUpdate = False
    
End Sub




'++*******************************************************************
' Procedure:    sbtDate_SpinUp, sbtDate_SpinDown
' Description:  Increases / Decreases the date by a day
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub sbtDate_SpinUp()

'    Dim nDate As Date
'
'    'First need to see if the header date is the same
'    bFieldUpdate = False
'    If Me.txtFtrInfo = "" Or Me.txtFtrInfo = txtDate Then bFieldUpdate = True
'
'    On Error GoTo NoDate
'    nDate = DateValue(txtDate)
'    nDate = nDate + 1
'
'    txtDate = Format(nDate, msDataFormat)
'    If bFieldUpdate Then Me.txtFtrInfo = txtDate
'
'    Exit Sub
'
'NoDate:
'    txtDate = Format(Now(), msDataFormat)
'    If bFieldUpdate Then Me.txtFtrInfo = txtDate
    
End Sub
Private Sub sbtDate_SpinDown()

'    Dim nDate As Date
'
'    'First need to see if the header date is the same
'    bFieldUpdate = False
'    If Me.txtFtrInfo = "" Or Me.txtFtrInfo = txtDate Then bFieldUpdate = True
'
'    On Error GoTo NoDate
'    nDate = DateValue(txtDate)
'    nDate = nDate - 1
'
'    txtDate = Format(nDate, msDataFormat)
'    If bFieldUpdate Then Me.txtFtrInfo = txtDate
'
'    Exit Sub
'
'NoDate:
'    txtDate = Format(Now(), msDataFormat)
'    If bFieldUpdate Then Me.txtFtrInfo = txtDate
    
End Sub




Private Sub txtContactEmail_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

    'HighlightTelephoneExtension txtContactEmail
    
End Sub

Private Sub txtContactTelephone_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

    HighlightTelephoneExtension txtContactTelephone
    
End Sub

Private Sub txtProspect_Change()

    
    If bFieldUpdate Then
        txtHeader = StripCRLF(txtProspect)
    End If

End Sub

Private Sub txtProspect_Enter()

    bFieldUpdate = False
    If StripCRLF(txtHeader) = StripCRLF(txtProspect) Or txtHeader = "" Then
        bFieldUpdate = True
    End If
    
End Sub

Private Sub UserForm_Activate()

    If Not mbinitializationSuccessfull Then
        Unload Me
    End If


    
End Sub

'++*******************************************************************
' Procedure:    UserForm_Initialize
' Description:  Set the initial values of the dialog box
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub UserForm_Initialize()

    Dim sText As String
    Dim i As Integer
    Dim iSecNo As Integer

    modUserFormUtilities.CentreFormOnScreen Me, True


    If Not gbNewDoc Then
        miDisclosureFileNo = 0
        'If not a new document then set of False unless there is not section
        If modPages.IsPortabilityPageEnabled Then
            cbxPortabilityLanguageUpdate.value = False
        End If
    End If

    'First check to see if the actual template is loaded or a document
    If ActiveDocument.Type = wdTypeTemplate Then
        MsgBox "The document is a template!"
        mbinitializationSuccessfull = False
        Exit Sub
    End If
    
    'Set the version number text in right bottom corner
    Me.lblVers.Caption = Me.lblVers.Caption & " " & TEMPLATE_VERSION
    
    gbOfflineMode = False


    SetINIFileName
    
    SetDialogCaption
    
    PopulateJurisdiction
    
    PopulateOfficesCombo
    'PopulateDisclosures -
    
    PopulateLanguageCombo cmbLanguage
    PopulatePapersizeCombo cmbPapersize
    
    cbxTitlePg = modPages.IsTitlePageEnabled
    cbxPortabilityLanguage = modPages.IsPortabilityPageEnabled
    cbxExecutiveSummary = modPages.IsExecutiveSummaryEnabled
    cbxContentsPg = modPages.IsContentsPageEnabled
    cbxContactPage = modPages.IsContactPageEnabled
    
    cbxDisclosures = modPages.IsDisclosureEnabled
  
    
    If gbNewDoc Then
    
        'Set the dates to today
        msDateFormat = "MMMM yyyy"
        Me.txtDate = Format(Now(), msDateFormat)
        ReadDefaultPaperSize cmbPapersize
        ReadDefaultLanguage cmbLanguage
        ReadDefaultOffice cmbLegalEntity
        optReport.value = True
    Else
        'If not a new document then read the settings from the document
        msDateFormat = modPrivate.sGetDocVar("DateFormat")
        
        If (modPrivate.sGetDocVar("RFPReport") = "False") Then
            optNONReport.value = True
            ShowHideNONReportOptions
        Else
            optReport.value = True
        End If
        SetPaperSizeCombo cmbPapersize
        SetLanguageCombo cmbLanguage
    End If

    If gbNewDoc = gbStarterDoc Then

        If cbxTitlePg Then
            ReadTitlePageText
        Else
            PopulateTitleTitleETC
        End If

        'Need to display the correct type of Contents page
        If cbxContentsPg Then
            ReadTOCSettings
        End If
        
        If cbxContactPage Then
            ReadContactDetails
        End If
        
        ReadHeaderFooterText
        
        ClearStarterDocFields
        
    End If

    'Select the correct field for the cursor
    If Me.cbxTitlePg Then
        With txtProspect
            .SetFocus
            .SelStart = 0
            .SelLength = Len(.text)
        End With
    End If
    
    Exit Sub
    
UserForm_Initialize_EH:
    Const sProcedure As String = "UserForm_Initialize"
    GlobalErrorHandler err.Number, err.Description, msMODULE, sProcedure

End Sub


Sub PopulateTitleTitleETC()

    txtProspect = GetCustomDocumentProperty("TitlePageTitle")
    txtType = GetCustomDocumentProperty("TitlePageSubtitle")
    txtDate = GetCustomDocumentProperty("TitlePageDate")

End Sub

Sub ReadHeaderFooterText()

    txtHeader = GetCustomDocumentProperty("InsightHeader")
    txtFooter = GetCustomDocumentProperty("InsightFooter")
    
    If txtHeader = StripCRLF(txtProspect) Then
        txtProspect = Replace(txtProspect, Chr(11), vbCrLf)
        txtHeader = StripCRLF(txtProspect)
    End If
    
    If txtHeader = "" Then txtHeader = StripCRLF(txtProspect)
    
    
End Sub

Sub PopulateJurisdiction()


    Dim sJurisdiction As String
    Dim sOffice As String
    Dim sText As String

        modPrivate.ComboBoxFill gsCompanyIniFileName, INI_SECTION_JURISDICTION, "Jurisdiction", cmbJurisdiction

        If cmbJurisdiction.ListCount > 0 Then
            cmbJurisdiction.ListIndex = 0
            'cmbJurisdiction_Change
            If gbNewDoc Then
                'Get defaults
                sJurisdiction = modPrivate.GetRegistrySettingString("Brochet", "JurisdictionDefaultIndex")
                sOffice = modPrivate.GetRegistrySettingString("Brochet", "OfficeDefaultIndex")
                SetCombo cmbJurisdiction, sJurisdiction
                SetCombo cmbLegalEntity, sOffice
            Else
            'Read document properties
                SetCombo cmbJurisdiction, GetCustomDocumentProperty("JurisdictionIndex")
                SetCombo cmbLegalEntity, GetCustomDocumentProperty("OfficeIndex")
            End If
         Else
            modError.DisplayMsg "There is a problem with your INI file settings. Please check the Jurisdiction section"
         End If
        
        

End Sub

Sub ReadTitlePageText()

    txtProspect = modContentControls.GetTextFromControl("ccProspect")
    txtType = modContentControls.GetTextFromControl("ccType")
    txtDate = modContentControls.GetTextFromControl("ccDate")

End Sub

Sub WriteTitlePageText()

    WriteDisclaimer

    modContentControls.ReplaceWithTextInControl "ccProspect", txtProspect, "Cover Page Title"
    modContentControls.ReplaceWithTextInControl "ccType", txtType, "Cover Page Date"
    modContentControls.ReplaceWithTextInControl "ccDate", txtDate, "Cover Page Date"

End Sub

Sub ReadContactDetails()

    Dim sOffice As String
    
    'Read doc var of office
    sOffice = sGetDocVar("Office")
    SetCombo cmbLegalEntity, sOffice
    
    HighlightTelephoneExtension txtContactTelephone

    txtContactName = modContentControls.GetTextFromControl("ccContactName")
    txtContactTitle = modContentControls.GetTextFromControl("ccContactTitle")
    txtContactTelephone = modContentControls.GetTextFromControl("ccContactTelephone")
    txtContactEmail = modContentControls.GetTextFromControl("ccContactEmail")
    'txtContactAddress = modContentControls.GetTextFromControl("ccContactAddress")
    
End Sub

Sub writeContactDetails()

    Dim sOfficeAddress As String
    'Save Doc var for Office
    SetDocVar "Office", cmbLegalEntity

    modContentControls.ReplaceWithTextInControl "ccContactName", txtContactName, "Table Text"
    modContentControls.ReplaceWithTextInControl "ccContactTitle", txtContactTitle, "Table Text"
    modContentControls.ReplaceWithTextInControl "ccContactTelephone", txtContactTelephone, "Table Text"
    modContentControls.ReplaceWithTextInControl "ccContactEmail", txtContactEmail, "Table Text"
    
    WriteOfficeAddress
    
    ShowHideSocial
    
End Sub

Sub ShowHideSocial()

    modContentControls.ClearCCText "ccLinks"
   
    ModifySocial "ccLinks", "ShowWebAddress", "z_SocialWeb"
    ModifySocial "ccLinks", "ShowTwitter", "z_SocialTwitter"
    ModifySocial "ccLinks", "ShowLinkedIn", "z_SocialLinkedIn"
    modContentControls.ClearFirstSpaceAndLastPara "ccLinks"

End Sub

Sub ModifySocial(sCCTag As String, sKeySuffix As String, sAutotext As String)

    Dim sOfficeKey As String
    Dim sOfficeText As String
    Dim sOfficeIndex As String

    sOfficeIndex = cmbLegalEntity.List(cmbLegalEntity.ListIndex, 1)
    sOfficeKey = "Office" & sOfficeIndex & sKeySuffix
    sOfficeText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_OFFICES, sOfficeKey)
    If sOfficeText <> "" Then
        modContentControls.AppendAutoTextToCC sCCTag, sAutotext
        modContentControls.AppendTexttoCC sCCTag, Chr$(160), "Links white"
        modContentControls.AppendTexttoCC sCCTag, sOfficeText, "Links white"
        modContentControls.AppendTexttoCC sCCTag, vbCrLf, "Links white"
    End If

End Sub

Sub WriteOfficeAddress()

    Dim sOfficeIndex As String
    Dim i As Integer
    Dim sOfficeKey As String
    Dim sOfficeText As String
    Dim ccName As String
    
    ccName = "ccContactAddress"
    
    If modContentControls.ContentControlExists(ccName) Then
        'get system
        sOfficeIndex = cmbLegalEntity.List(cmbLegalEntity.ListIndex, 1)
        'get line 1 from system
        i = 1
        sOfficeKey = "Office" & sOfficeIndex & "Line" & Trim(Str(i))
        
        sOfficeText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_OFFICES, sOfficeKey)
        modContentControls.ReplaceWithTextInControl ccName, " "
        While sOfficeText <> ""
            modContentControls.AppendTexttoCC ccName, sOfficeText, "Table text"
            modContentControls.AppendTexttoCC ccName, vbCr, "Table text"
            i = i + 1
            sOfficeKey = "Office" & sOfficeIndex & "Line" & Trim(Str(i))
    
            sOfficeText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_OFFICES, sOfficeKey)
        Wend
        modContentControls.ClearFirstSpaceAndLastPara ccName
    End If


End Sub

Sub WriteDisclaimer()

    Dim sJurisdictionIndex As String
    Dim i As Integer
    Dim sDisclaimerKey As String
    Dim sStyleKey As String
    Dim sDisclaimerText As String
    Dim sStyleText As String
    Dim ccName As String
    
    ccName = "ccDisclaimer"
    
    If modContentControls.ContentControlExists(ccName) Then
        'get system
        sJurisdictionIndex = cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1)
        'get line 1 from system
        i = 1
        sDisclaimerKey = sJurisdictionIndex & "Disclaimer" & Trim(Str(i))
        sStyleKey = sJurisdictionIndex & "DisclaimerStyle" & Trim(Str(i))
        
        sDisclaimerText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sDisclaimerKey)
        sStyleText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sStyleKey)
        modContentControls.ReplaceWithTextInControl ccName, " "
        While sDisclaimerText <> ""
            If sStyleText = "" Then sStyleText = "Header White"
            sDisclaimerText = Replace(sDisclaimerText, "<CR>", vbCr)
            modContentControls.AppendTexttoCC ccName, sDisclaimerText, sStyleText
            'modContentControls.AppendTexttoCC ccName, vbCr, sStyleText
            i = i + 1
            sDisclaimerKey = sJurisdictionIndex & "Disclaimer" & Trim(Str(i))
            sStyleKey = sJurisdictionIndex & "DisclaimerStyle" & Trim(Str(i))
            
            sDisclaimerText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sDisclaimerKey)
            sStyleText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sStyleKey)
        Wend
        modContentControls.ClearFirstSpaceAndLastPara ccName
    End If

End Sub

Sub WriteNONReportDisclaimer()



    Dim sJurisdictionIndex As String
    Dim i As Integer
    Dim sDisclaimerKey As String
    Dim sStyleKey As String
    Dim sDisclaimerText As String
    Dim sStyleText As String
    Dim ccName As String
    
    ccName = "ccDisclaimer2"
    
    If modContentControls.ContentControlExists(ccName) Then
        'get system
        sJurisdictionIndex = cmbJurisdiction.List(cmbJurisdiction.ListIndex, 1)
        'get line 1 from system
        i = 1
        sDisclaimerKey = sJurisdictionIndex & "Disclaimer" & Trim(Str(i))
        sStyleKey = sJurisdictionIndex & "DisclaimerStyle" & Trim(Str(i))
        
        sDisclaimerText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sDisclaimerKey)
        modContentControls.ReplaceWithTextInControl ccName, " "
        sStyleText = "Header Black"
        While sDisclaimerText <> ""
            sDisclaimerText = Replace(sDisclaimerText, "<CR>", vbCr)
            modContentControls.AppendTexttoCC ccName, sDisclaimerText, sStyleText
            'modContentControls.AppendTexttoCC ccName, vbCr, sStyleText
            i = i + 1
            sDisclaimerKey = sJurisdictionIndex & "Disclaimer" & Trim(Str(i))
            sStyleKey = sJurisdictionIndex & "DisclaimerStyle" & Trim(Str(i))
            
            sDisclaimerText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sDisclaimerKey)
            sStyleText = System.PrivateProfileString(gsCompanyIniFileName, INI_SECTION_JURISDICTION, sStyleKey)
            If UCase(Right(sStyleText, 4)) = "BOLD" Then
                sStyleText = "Header Black Bold"
            Else
                sStyleText = "Header Black"
            End If
        Wend
        modContentControls.ClearFirstSpaceAndLastPara ccName
    End If

End Sub

Sub SetCombo(combo As ComboBox, sText As String)

    On Error GoTo err

    If sText <> "" Then
        If combo.ListCount > 0 Then
            combo = sText
        End If
    Else
        combo.ListIndex = 0
    End If
    
clean:

    Exit Sub

err:
    
    If combo.ListCount > 0 Then
        combo.ListIndex = 0
    End If

    Resume clean
    
End Sub



Sub DisableFRM(FRMControl As control)
    
    Dim cControl As control
    
    'Enable or disable all the control in the frame
    For Each cControl In FRMControl.Controls
        cControl.enabled = False
    Next

End Sub

Function GetClientLogo() As String


    Dim tTable As Table
    Dim rInsertion As Range
    Dim sFullImagePathAndName As String
    Dim sh As Shape
    Dim ilSh As InlineShape
    Dim cCell As Cell
    Dim sAltText As String
    
    On Error GoTo err
    
    
    Set tTable = ActiveDocument.Sections(1).Headers(wdHeaderFooterPrimary).Range.Tables(1)

        If tTable.title = "BrochetTitlePageTable" Then
            Set cCell = tTable.Cell(1, 3)
            
            Set rInsertion = cCell.Range
            
            If rInsertion.InlineShapes.count >= 1 Then
            
                sAltText = rInsertion.InlineShapes(1).AlternativeText
                If sAltText = "" Then
                    GetClientLogo = "{None}"
                Else
                    GetClientLogo = sAltText
                End If
            Else
                GetClientLogo = "{None}"
            End If

        End If

Exit Function

err:
    
    GetClientLogo = "{None}"
    

End Function









Sub ClearStarterDocFields()

        If gbStarterDoc Then
        'TODO
'            'Clear unwanted fields
'            txtDocClientName = ""
'            txtProjectReference = ""
            txtCustomer = ""
            txtReference = ""
            txtIssue = ""
        End If

End Sub





Sub ReadTOCSettings()

    Dim sText As String


            sText = modPrivate.DocVarGet("ContentsPageToCType")
            Select Case sText
                Case 1
                    obtOpt1.value = True
                Case 2
                    obtOpt2.value = True

            End Select



End Sub

 Sub SetDialogCaption()
 

    Me.Caption = COMPANY_NAME & " - New RFP"
    If gbNewDoc And gbStarterDoc Then
        Me.Caption = COMPANY_NAME & " - New Starter Doc RFP"
    ElseIf Not gbNewDoc And Not gbStarterDoc Then
        Me.Caption = COMPANY_NAME & " - Update RFP"
    End If
 
 End Sub
 
 
Sub SetINIFileName()

    gsCompanyIniFileName = GetIniFilePath
    'Check that the COMPANY INI file exists. If not display message and exit
    If gsCompanyIniFileName <> vbNullString Then
        mbinitializationSuccessfull = True
    End If

End Sub




'++*******************************************************************
' Procedure:    zReturnIfValueNotBlank
' Author:       Brochet ltd
' Description:  Will return the heading and field value if the field
'               is not blank. If the field is blank, it returns neither.
' Parameters:   sHeading - The field's heading text
'               sValue - The field's value
' Returns:      The string to insert
'--********************************************************************
Private Function zReturnIfValueNotBlank(sHeading As String, sValue As String) As String

    If Trim$(sValue) <> vbNullString Then
        zReturnIfValueNotBlank = sHeading & sValue
    End If
    
End Function

Private Sub zSetValueIfBlank(ctlToSet As control, sValue As String, Optional vOtherBlankValueToCheckFor)

    If ctlToSet = vbNullString Then
        ctlToSet = sValue
    ElseIf Not IsMissing(vOtherBlankValueToCheckFor) Then
        If ctlToSet = vOtherBlankValueToCheckFor Then
            ctlToSet = sValue
        End If
    End If
    
End Sub

Sub zInsertTitlePageText(sStylePostScripts As String)

    Dim rRange As Range
    Dim tTable As Table
    Dim cCell As Cell
    Dim sStyleNames As String
    Dim arrStyleNames As Variant
    Dim iStyleNumber As Integer
    
    If ActiveDocument.Sections(1).Range.Tables.count >= 1 Then
        Set tTable = ActiveDocument.Sections(1).Range.Tables(1)
        If tTable.title = "BrochetTitlePageTable" And tTable.Rows.count >= TITLEPAGE_TEXT_ROWNO Then
            'Set the range and delete the current information
            Set cCell = tTable.Cell(TITLEPAGE_TEXT_ROWNO, 1)
            Set rRange = cCell.Range
            rRange.End = rRange.End - 1
            rRange.Delete
            
            rRange.Style = wdStyleNormal
            rRange.InsertAfter vbCrLf
            rRange.InsertAfter vbCrLf
            
            Set rRange = cCell.Range.Paragraphs(2).Range
            rRange.Collapse wdCollapseStart
            modDocumentProperties.InsertDocumentPropertyField rRange, "IFS_DOCUMENT_SUBTITLE", "DocSubTitle"
            
            Set rRange = cCell.Range.Paragraphs(1).Range
            'rRange.Style = "DocTitle"
            rRange.Collapse wdCollapseStart
            modDocumentProperties.InsertDocumentPropertyField rRange, "IFS_DOCUMENT_TITLE", "DocTitle"

        End If
    End If

End Sub



Sub zInsertParagraph(rRange As Range, sText As String, sStyleName As String)

    'Set the correct style
    On Error Resume Next
    rRange.Paragraphs.Style = sStyleName
    rRange.InsertAfter zCorrectInputText(sText) & vbCr
    'rRange.End = rRange.End + Len(sText)
    rRange.Collapse wdCollapseEnd
    rRange.Paragraphs.Style = wdStyleNormal

End Sub

Function zCorrectInputText(sInputText) As String

    Dim sText As String

    'Replace all return - which are Chr(13) + Chr(10)
    sText = Replace(sInputText, vbCr & Chr(10), vbVerticalTab)
    
    'Remove all empty returns at beginning and end of the text
    Do While Asc(sText) = Asc(vbVerticalTab)
        sText = Mid(sText, 2)
    Loop
    Do While Asc(Mid(sText, Len(sText))) = Asc(vbVerticalTab)
        sText = Mid(sText, 1, Len(sText) - 1)
    Loop
    
    zCorrectInputText = sText

End Function







'++*******************************************************************
' Procedure:    zInsertInsideTitlePageFooterText
' Author:       Brochet ltd
' Description:  Insert the Inside Title Page text into the footer
' Parameters:   n/a
' Returns:      n/a
'--********************************************************************
Sub zInsertInsideTitlePageFooterText()

    Dim i As Integer
    Dim sText As String
    Dim tTable As Table
    Dim cCell As Cell

    'Insert a new empty footer
    ActiveDocument.AttachedTemplate.AutoTextEntries("z_InsideTitlePageFooter").Insert Where _
        :=ActiveDocument.Sections(2).Footers(wdHeaderFooterPrimary).Range, richtext:=True
    'Delete the extra paragraph
    If ActiveDocument.Sections(2).Footers(wdHeaderFooterPrimary).Range.Paragraphs.count > 1 Then
        ActiveDocument.Sections(2).Footers(wdHeaderFooterPrimary).Range.Paragraphs(ActiveDocument.Sections(2).Footers(wdHeaderFooterPrimary).Range.Paragraphs.count).Range.Delete
    End If
    
    If ActiveDocument.Sections(2).Footers(wdHeaderFooterPrimary).Range.Tables.count >= 1 Then
        Set tTable = ActiveDocument.Sections(2).Footers(wdHeaderFooterPrimary).Range.Tables(1)
        If tTable.title = "BrochetInsideTitlePageFooterTable" Then
    
            'Now populate the footer - cycle through the columns and get the text from the ini file
            For i = 1 To INSIDETITLEPAGE_FOOTER_NO_OF_COLUMNS
                If tTable.Columns.count >= i Then
                    sText = modINI.IniFileKeyGet(gsCompanyIniFileName, "A4ReportInsideTitlePage", "BrochetFooterCol" & i & "Text")
                    If sText <> "" Then
                        Set cCell = tTable.Cell(2, i)
                        
                        'Unselect the cell end character
                        cCell.Range.End = cCell.Range.End - 1
                        cCell.Range.Style = "ITTFooterText"
                        cCell.Range.text = Replace(Replace(sText, "<VT>", vbVerticalTab), "|", vbCr)
                
                    End If
                End If
            
            Next
        End If
    End If
    
    'TODO Need to add the logos etc.


End Sub

'++********************************************************************
' Procedure:    zDataSave
' Description:  Gets the relevant field from the Author's address ini
'               file.
' Parameters:   sIniFileName - The address ini file.
'               sFieldList - List of fields for this ini.
'               cmbCombo - Relevant combo box.
'               iRemoveNo - number of characters to remove from the
'                   sFieldList when saving date (so can work with two different lists)
' Returns:      N/A
'--********************************************************************
Private Sub zDataSave(sIniFileName As String, sFieldList As String, cmbCombo As ComboBox, sFieldList2 As String, cmbCombo2 As ComboBox, Optional iRemoveNo As Integer = 0)

    Dim iNoEntries As Integer
    Dim iEntry As Integer
    Dim iField As Integer
    Dim vAryFldNames As Variant
    Dim bNewItem As Boolean
    Dim sName2 As String
    

    
    'See how many enteries are already in the ini file
    iNoEntries = Val(System.PrivateProfileString(sIniFileName, "NoOfEntries", "Count"))

    If cmbCombo.ListIndex <> -1 Then
        If MsgBox("Please confirm you wish to overwrite the details for this Name.", vbQuestion + vbOKCancel, "Save Name") = vbCancel Then
            Exit Sub
        End If
        'If a new item
        If cmbCombo.Column(1) = "N" Then
            iNoEntries = iNoEntries + 1
            iEntry = iNoEntries
            'cmbCombo.Column(1) = iNoEntries
            'bNewItem = True
        Else
            iEntry = cmbCombo.Column(1)
        End If
    Else
        iNoEntries = iNoEntries + 1
        iEntry = iNoEntries
        bNewItem = True
    End If

    vAryFldNames = Split(sFieldList, ",")

    System.PrivateProfileString(sIniFileName, "NoOfEntries", "Count") = iNoEntries

    For iField = 0 To UBound(vAryFldNames, 1)
        System.PrivateProfileString(sIniFileName, "ItemEntry" & iEntry, Mid(vAryFldNames(iField), 1, Len(vAryFldNames(iField)) - iRemoveNo)) = _
          Replace(Me(vAryFldNames(iField)), vbCrLf, "<CR>")
    Next iField

    'If a new item then need to reload all the data in the combo box
    If bNewItem Then
        zDataLoad sIniFileName, sFieldList, cmbCombo, iRemoveNo, "{n/a}"
        'Now need to reload the other list as may have changed
        sName2 = cmbCombo2
        zDataLoad sIniFileName, sFieldList2, cmbCombo2, iRemoveNo, "{n/a}"
        'Now reset the value
        cmbCombo2 = sName2
    Else
        'Need to see if the same item is displayed in other combo and update if necessary
        If cmbCombo.Column(1) = "N" Then
            cmbCombo.Column(1) = iNoEntries
            'Now need to reload the other list as may have changed
            sName2 = cmbCombo2
            zDataLoad sIniFileName, sFieldList2, cmbCombo2, iRemoveNo, "{n/a}"
            'Now reset the value
            cmbCombo2 = sName2
        End If
    End If
    
End Sub

'++********************************************************************
' Procedure:    zDataDelete
' Description:  Delete an entry from a data ini file.
' Parameters:   sIniFileName - The ini file from which to delete entry.
'               sFieldList - List of fields for this ini.
'               cmbCombo - Relevant combo box.
' Returns:      N/A
'--********************************************************************
Private Sub zDataDelete(sIniFileName As String, sFieldList As String, cmbCombo As ComboBox, sFieldList2 As String, cmbCombo2 As ComboBox, Optional iRemoveNo As Integer = 0)
    
    Dim iNoEntries As Integer
    Dim iEntry As Integer
    Dim iCopyEntry As Integer
    Dim iField As Integer
    Dim vAryFldNames As Variant
    Dim sTmpFile As String
    Dim scbxValue1 As String
    Dim scbxValue2 As String
    Dim sText As String
        
    'Make a note of the values of the two drop down list as if the same the need to not set back to original
    scbxValue1 = cmbCombo
    scbxValue2 = cmbCombo2
        
    If MsgBox("Please confirm you would like to delete this entry.", vbQuestion + vbOKCancel, COMPANY_NAME & " - Delete Entry") = vbCancel Then
        Exit Sub
    End If
    
    iNoEntries = Val(System.PrivateProfileString(sIniFileName, "NoOfEntries", "Count"))
            
    If iNoEntries = 1 Then
        Kill sIniFileName
        cmbCombo = vbNullString
        zDataLoad sIniFileName, sFieldList, cmbCombo, iRemoveNo, "{n/a}"
        zDataLoad sIniFileName, sFieldList2, cmbCombo2, iRemoveNo, "{n/a}"
        Exit Sub
    End If
    
    sTmpFile = sIniFileName & ".tmp"
    If FileExists(sTmpFile) Then
        'Make sure the temporary file doesn't already exist
        Kill sTmpFile
    End If
    Name sIniFileName As sTmpFile
    
    'Create and set the no of entries into a new version of the ini
    System.PrivateProfileString(sIniFileName, "NoOfEntries", "Count") = iNoEntries - 1
    
    vAryFldNames = Split(sFieldList, ",")
    
    For iCopyEntry = 1 To iNoEntries
    
        If iCopyEntry <> Val(cmbCombo.Column(1)) Then
            
            'This entry from the temp copy does need to be copied
            iEntry = iEntry + 1
            For iField = 0 To UBound(vAryFldNames, 1)
            
                'Get the data from the temporary copy
                sText = System.PrivateProfileString(sTmpFile, _
                  "ItemEntry" & iCopyEntry, Mid(vAryFldNames(iField), 1, Len(vAryFldNames(iField)) - iRemoveNo))
                
                'Insert it into the new file
                System.PrivateProfileString(sIniFileName, _
                  "ItemEntry" & iEntry, Mid(vAryFldNames(iField), 1, Len(vAryFldNames(iField)) - iRemoveNo)) = sText
                  
            Next iField
            
        End If
        
    Next iCopyEntry
    
    Kill sTmpFile 'Finished with the temp copy of the ini
    
    'Set the entry of the combobox to nothing before reloading
    cmbCombo = vbNullString
    
    zDataLoad sIniFileName, sFieldList, cmbCombo, iRemoveNo, "{n/a}"
    'Make a note of the current setting so can reset
    'sText = cmbCombo2
    zDataLoad sIniFileName, sFieldList2, cmbCombo2, iRemoveNo, "{n/a}"
    'Now reset to original name
    If scbxValue1 <> scbxValue2 Then
        cmbCombo2 = scbxValue1
    Else
        If cmbCombo2.ListCount > 0 Then cmbCombo2.ListIndex = 0
    End If
    
End Sub

'++********************************************************************
' Procedure:    zDataLoad
' Description:  Retrieves data from an ini file and loads into one or
'               more fields on the dialog.
' Parameters:   sIniFileName - Filename of the input ini file.
'               sFieldList - List of fields for this ini.
'               cmbCombo - Relevant combo box.
' Returns:      N/A
'--********************************************************************
Private Sub zDataLoad(sIniFileName As String, sFieldList As String, cmbCombo As ComboBox, Optional iRemoveNo As Integer = 0, Optional sFirstItem As String = "")
    
    Dim i As Integer
    Dim vCmbLst() As String
    Dim vFldLst As Variant
    Dim iAddNo As Integer
    
    'Clear out the combo box
    cmbCombo.Clear
    
    If FileExists(sIniFileName) Then
        i = Val(System.PrivateProfileString(sIniFileName, "NoOfEntries", "Count"))
        vFldLst = Split(sFieldList, ",")
        'Make the array larger and add the first item
        If sFirstItem <> "" Then
            ReDim vCmbLst(i - 1 + 1, 1)
            vCmbLst(0, 0) = sFirstItem
            vCmbLst(0, 1) = "X"
            iAddNo = 1
        Else
            ReDim vCmbLst(i - 1, 1)
            iAddNo = 0
        End If
        For i = 0 To i - 1
            vCmbLst(i + iAddNo, 0) = System.PrivateProfileString(sIniFileName, "ItemEntry" & i + 1, Mid(vFldLst(0), 1, Len(vFldLst(0)) - iRemoveNo))
            vCmbLst(i + iAddNo, 1) = i + 1 'Index number of entry in ini
        Next i
        modArrays.ArraySort vCmbLst(), 0, True, cmbCombo
    Else
        'If there is a first item add it to the list
        If sFirstItem <> "" Then
            ReDim vCmbLst(0, 1)
            vCmbLst(i, 0) = sFirstItem
            vCmbLst(i, 1) = "X"
            modArrays.ArraySort vCmbLst(), 0, True, cmbCombo
       End If
    
    End If

End Sub

'++********************************************************************
' Procedure:    zDirectoryValidate
' Description:  Checks for the existence of the incoming directory and,
'               if it doesn't exist, creates it.
' Parameters:   sDir - Directory for which to check.
' Returns:      N/A
'--********************************************************************
Private Sub zDirectoryValidate(ByVal sDir As String)

    Dim sText As String
    Dim i As Integer
    
    If Dir$(sDir, vbDirectory) <> vbNullString Then
        Exit Sub
    End If
    
    If Right$(sDir, 1) <> "\" Then
        sDir = sDir & "\"
    End If
    
    i = InStr(sDir, "\\")
    
    Do
        i = InStr(i + 1, sDir, "\")
        If i = 0 Then
            Exit Do
        End If
        
        sText = Left$(sDir, i)
        If Dir$(sText, vbDirectory) = vbNullString Then
            MkDir sText
        End If
    Loop
    
End Sub


'++********************************************************************
' Procedure:    zAddressAuthorComboChange
' Description:  Load related information in the relevant fields.
' Parameters:   sIniFileName - The ini file from which to get data.
'               cmbCombo - Relevant combo box.
'               sFieldList - List of fields for this ini.
' Returns:      N/A
'--********************************************************************
Private Sub zAddressAuthorComboChange(sIniFile As String, cmbCombo As ComboBox, sFieldList As String, Optional iRemoveNo As Integer = 0, Optional sInfoString As String = "")
    
    Dim vAryFldNames As Variant
    Dim vAryText As Variant
    Dim iField As Integer
    Dim sText As String
    Dim iStartNo As Integer
    
    'A user address has been chosen, get the details and fill the form
    vAryFldNames = Split(sFieldList, ",")
        
    If cmbCombo.Column(1) <> "N" Then
    
        'Set the relevant field values with the current entries from the ini
        For iField = 1 To UBound(vAryFldNames, 1)
            sText = System.PrivateProfileString(sIniFile, "ItemEntry" & cmbCombo.Column(1), Mid(vAryFldNames(iField), 1, Len(vAryFldNames(iField)) - iRemoveNo))
            sText = Replace(sText, "<CR>", vbCr)
            
            Me(vAryFldNames(iField)) = sText
           
        Next iField
        
    Else
        'Need to read through the text and update the infor
        vAryText = Split(sInfoString, vbCr)
        iStartNo = 1
        
        For iField = 1 To UBound(vAryFldNames, 1)

            Me(vAryFldNames(iField)) = vAryText(iField)

        Next iField
   
        
    End If

End Sub

Sub zContactNameSet(sDefaultSetting As String, cmbCombo As ComboBox, Optional bAddNew As Boolean = False)

    Dim iCount As Integer
    Dim i As Integer
    
    'If a value has been supplied try and set
    If sDefaultSetting <> "" Then
    
        iCount = cmbCombo.ListCount
        'Cycle through all the items in the list and if found set and exit sub
        For i = 0 To iCount - 1
            If cmbCombo.List(i, 0) = sDefaultSetting Then
                cmbCombo.ListIndex = i
                Exit Sub
            End If
        Next
        
        'Only get to this bit if no match found
        If bAddNew Then
            cmbCombo.AddItem sDefaultSetting
            cmbCombo.List(cmbCombo.ListCount - 1, 1) = "N"
            cmbCombo.ListIndex = cmbCombo.ListCount - 1
        Else
            If cmbCombo.ListCount > 0 Then
                cmbCombo.ListIndex = 0
            End If
        End If
    
    'No value sent so set to first item
    Else
        If cmbCombo.ListCount > 0 Then
            cmbCombo.ListIndex = 0
        End If
    End If

End Sub



Sub InsertText(rRange As Range, sText As String, sStyle As String)

        
        rRange.text = vbCr & sText
        rRange.Collapse wdCollapseEnd
        rRange.Style = sStyle



End Sub

Function GetTable(sTableTitle As String, rRange As Range) As Table

    Dim tTable As Table

    Set GetTable = Nothing

    For Each tTable In rRange.Tables
        If tTable.title = sTableTitle Then
            Set GetTable = tTable
        End If
    Next
    
    

End Function



Function GetTextWithStyle(rRange As Range, sStyle As String) As String


    Dim para As Paragraph
    
    For Each para In rRange.Paragraphs
        If para.Style = sStyle Then
            GetTextWithStyle = para.Range.text
            Exit For
        End If
    Next
    
    If GetTextWithStyle = "" Then
        GetTextWithStyle = vbCr
    End If


End Function




Attribute VB_Name = "frmNewSection"
Attribute VB_Base = "0{83544DCB-6507-46D4-B354-5E811405623E}{57850764-4AC8-4036-BA63-73AB138636D6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: frmNewSection
'*
'* Holds New section dialog form and macros
'***********************************************************************************

Option Explicit

Const msMODULE As String = "frmNewSection"



Private miCurrSecType As Brochet_PAGE_TYPE
Private miFollowingSecType As Integer

'++*******************************************************************
' Procedure:    butOk_Click
' Author:       Brochet ltd
' Description:  OK button pressed so insert a new setion
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butOk_Click()

    Dim oTmp As template
    Dim bSmartCut As Boolean
    Dim bTrackChanges As Boolean
    Dim newSectionType As Brochet_PAGE_TYPE
    Dim oUndoRecord As cUndoRecord
    Set oUndoRecord = New cUndoRecord
    
    Me.hide

    'On Error GoTo butOk_Click_EH

    'Switch update screen off
    Application.ScreenUpdating = False

    'If smart cut and pastes is set to on switch off
    bSmartCut = False
    If Options.SmartCutPaste = True Then
        bSmartCut = True
        Options.SmartCutPaste = False
    End If

    'Switch off track changing
    bTrackChanges = False
    If ActiveDocument.TrackRevisions Then
        bTrackChanges = True
        ActiveDocument.TrackRevisions = False
    End If

    
    newSectionType = GetSelectedSectionType()
    
    If modPages.InsertNewSection(obtLocCurr, newSectionType, obtNewPage) = False Then
        oUndoRecord.EndRecording
        ActiveDocument.Undo
        Exit Sub
    End If
    
    'Switch back on Smart cut and paste
    If bSmartCut Then
        Options.SmartCutPaste = True
    End If

    'Switch Track Changes back on
    If bTrackChanges Then
        ActiveDocument.TrackRevisions = True
    End If

    'Switch update screen on
    Application.ScreenUpdating = True
    
    'Unload the files
    Unload Me
    
    Exit Sub
    
butOk_Click_EH:
    Const sProcedure As String = "butOk_Click"
    GlobalErrorHandler err.Number, err.Description, msMODULE, sProcedure

End Sub

Function GetSelectedSectionType() As Brochet_PAGE_TYPE

    If frmMetric.Visible Then
    
        If obtA4PortraitProposal Then GetSelectedSectionType = A4PROPOSAL
        If obtA4PortraitWide Then GetSelectedSectionType = A4WIDE
        If obtA4Landscape Then GetSelectedSectionType = A4LANDSCAPE
        If optA3Landscape Then GetSelectedSectionType = A3LANDSCAPE

    Else
        If obtLetterPortraitProposal Then GetSelectedSectionType = LETTERPROPOSAL
        If obtLetterPortraitWide Then GetSelectedSectionType = LETTERWIDE
        If obtLetterLandscape Then GetSelectedSectionType = LETTERLANDSCAPE
        'If optLEDGERLandscape Then GetSelectedSectionType = LEDGERLANDSCAPE
    End If

End Function


'++*******************************************************************
' Procedure:    lblLocEnd_Click
' Description:  Label underneath obtLocEnd. When clicked the option
'               button value will be set
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub lblLocEnd_Click()
    obtLocEnd.value = True
End Sub

'++*******************************************************************
' Procedure:    lblLocEnd_Click
' Description:  Label underneath obtLocCurr. When clicked the option
'               button value will be set
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub lbLocCurr_Click()
    obtLocCurr.value = True
End Sub




Sub OptionClickImperial(control As control)


    Select Case control.Name
'    Case "obtLetterPortraitProposal", "imgLetterPortraitProposal"
'                If obtLetterPortraitProposal.enabled Then
'                    SetImageBorderImperial imgLetterPortraitProposal
'
'                    If obtLocCurr.enabled Then
'                        lbLocCurr.Caption = "The new Proposal style portrait page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
'                    End If
'
'                    lblLocEnd.Caption = "The new Proposal style portrait page will inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
'
'                    DisableContinuousOptionWhen "Letter Port*"
'                    SetActiveOptionButton obtLetterPortraitProposal
'                    ResetBorderColour imgLetterPortraitProposal
'                End If
                

            
    Case "obtLetterPortraitWide", "imgLetterPortraitWide"
                If obtLetterPortraitWide.enabled Then
                    SetImageBorderImperial imgLetterPortraitWide
            
                    If obtLocCurr.enabled Then _
                        lbLocCurr.Caption = "The new portrait page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
                    lblLocEnd.Caption = "The new portrait page will inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
                    
                    DisableContinuousOptionWhen "Letter Port*"
                End If
                
                SetActiveOptionButton obtLetterPortraitWide
                ResetBorderColour imgLetterPortraitWide
                
    Case "obtLetterLandscape", "imgLetterLandscape"
    
                If obtLetterLandscape.enabled Then
                    SetImageBorderImperial imgLetterLandscape
            
                    If obtLocCurr.enabled Then _
                        lbLocCurr.Caption = "The new landscape page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
                    lblLocEnd.Caption = "The new landscape page will inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
            
                    'Also may need to disable the 'continuous' option button
                    DisableContinuousOptionWhen "Letter Land*"
                    
                End If
                
                    SetActiveOptionButton obtLetterLandscape
                    ResetBorderColour imgLetterLandscape
                
    Case "obtLedgerLandscape", "imgLedgerLandscape"
                If obtLedgerLandscape.enabled Then
                    SetImageBorderImperial imgLedgerLandscape
            
                    If obtLocCurr.enabled Then _
                        lbLocCurr.Caption = "The new Ledger landscape page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
                    lblLocEnd.Caption = "The new Ledger landscape page will be inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
                    
                    'Also may need to disable the 'continuous' option button
                    DisableContinuousOptionWhen "Ledger Land*"
                    
                End If
                
                    SetActiveOptionButton obtLedgerLandscape
                    ResetBorderColour imgLedgerLandscape
    
    End Select
End Sub

Sub OptionClickMetric(control As control)

    Select Case control.Name
'    Case "obtA4PortraitProposal", "imgA4PortraitProposal"
'                If obtA4PortraitProposal.enabled Then
'                    SetImageBorderMetric imgA4PortraitProposal
'
'                    If obtLocCurr.enabled Then
'                        lbLocCurr.Caption = "The new Proposal style portrait page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
'                    End If
'
'                    lblLocEnd.Caption = "The new Proposal style portrait page will inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
'
'                    DisableContinuousOptionWhen "A4 Port*"
'
'                End If
'
'                SetActiveOptionButton obtA4PortraitProposal
'                ResetBorderColour imgA4PortraitProposal
            
    Case "obtA4PortraitWide", "imgA4PortraitWide"
                If obtA4PortraitWide.enabled Then
                    SetImageBorderMetric imgA4PortraitWide
            
                    If obtLocCurr.enabled Then _
                        lbLocCurr.Caption = "The new portrait page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
                    lblLocEnd.Caption = "The new portrait page will inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
                    
                    DisableContinuousOptionWhen "A4 Port*"
                End If
                
                SetActiveOptionButton obtA4PortraitWide
                ResetBorderColour imgA4PortraitWide
                
    Case "obtA4Landscape", "imgA4Landscape"
    
                If obtA4Landscape.enabled Then
                    SetImageBorderMetric imgA4Landscape
            
                    If obtLocCurr.enabled Then _
                        lbLocCurr.Caption = "The new landscape page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
                    lblLocEnd.Caption = "The new landscape page will inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
            
                    'Also may need to disable the 'continuous' option button
                    DisableContinuousOptionWhen "A4 Land*"
                    
                End If
                
                    SetActiveOptionButton obtA4Landscape
                    ResetBorderColour imgA4Landscape
                
    Case "optA3Landscape", "imgA3Landscape"
                If optA3Landscape.enabled Then
                    SetImageBorderMetric imgA3Landscape
            
                    If obtLocCurr.enabled Then _
                        lbLocCurr.Caption = "The new A3 landscape page will split the current '" & lblCurrSecOrient & "' section at the cursor location."
                    lblLocEnd.Caption = "The new A3 landscape page will be inserted at the end of the current '" & lblCurrSecOrient & "' section and before the following '" & lblFollSecOrient & "' section."
                    
                    'Also may need to disable the 'continuous' option button
                    DisableContinuousOptionWhen "A3 Land*"
                    
                End If
                
                    SetActiveOptionButton optA3Landscape
                    ResetBorderColour imgA3Landscape
    
    End Select


End Sub

Sub SetActiveOptionButton(optButton As control)

    With optButton
        .SetFocus
        .value = True
    End With

End Sub

Sub ResetBorderColour(imgControl As control)

        'Next two lines are necessary to display different border colours for image.
        'It seems that it somehow 'resets' the image so the borders display correctly
        With imgControl
            .Visible = False    'now button change event has changed the image border, but it looks like before.
            .Visible = True     'these two lines fixes that
        End With

End Sub

Sub DisableContinuousOptionWhen(sSectionNamePrefix As String)

        'Also may need to disable the 'continuous' option button
        If lblCurrSecOrient Like sSectionNamePrefix Then
            obutContSection.enabled = True
        Else
            If obutContSection.value Then
                obtNewPage.value = True
            End If
            obutContSection.enabled = False
        End If

End Sub

Sub SetImageBorderMetric(imageControl As control)

    Dim cBlack As Long
    Dim cRed As Long

    cBlack = &H80000006
    cRed = &HFF&

        imgA4PortraitProposal.BorderColor = cBlack
        imgA4PortraitWide.BorderColor = cBlack
        imgA4Landscape.BorderColor = cBlack
        imgA3Landscape.BorderColor = cBlack
        
       
        imageControl.BorderColor = cRed


End Sub
Sub SetImageBorderImperial(imageControl As control)

    Dim cBlack As Long
    Dim cRed As Long

    cBlack = &H80000006
    cRed = &HFF&

        imgLetterPortraitProposal.BorderColor = cBlack
        imgLetterPortraitWide.BorderColor = cBlack
        imgLetterLandscape.BorderColor = cBlack
        imgLedgerLandscape.BorderColor = cBlack
        
       
        imageControl.BorderColor = cRed


End Sub


Private Sub obtA4PortraitProposal_Click()

    OptionClickMetric obtA4PortraitProposal

End Sub

Private Sub imgA4PortraitProposal_Click()

    OptionClickMetric imgA4PortraitProposal
    
End Sub

Private Sub obtA4PortraitWide_Click()

    OptionClickMetric obtA4PortraitWide

End Sub

Private Sub imgA4PortraitWide_Click()

    OptionClickMetric imgA4PortraitWide
    
End Sub

Private Sub obtA4Landscape_Click()

    OptionClickMetric obtA4Landscape


End Sub

Private Sub imgA4Landscape_Click()

    OptionClickMetric imgA4Landscape

End Sub

'Private Sub optA3Landscape_Click()
'
'    OptionClickMetric optA3Landscape
'
'End Sub

'Private Sub obtLedgerLandscape_Click()
'
'    OptionClickImperial obtLedgerLandscape
'End Sub

Private Sub obtLetterLandscape_Click()

    OptionClickImperial obtLetterLandscape
End Sub

Private Sub obtLetterPortraitProposal_Click()

    OptionClickImperial obtLetterPortraitProposal
    
End Sub

Private Sub obtLetterPortraitWide_Click()

    OptionClickImperial obtLetterPortraitWide
    
End Sub

Private Sub imgA3Landscape_Click()

    OptionClickMetric imgA3Landscape
    
End Sub

Private Sub imgLedgerLandscape_Click()

    OptionClickImperial imgLedgerLandscape

End Sub

Private Sub imgLetterLandscape_Click()

    OptionClickImperial imgLetterLandscape

End Sub

Private Sub imgLetterPortraitProposal_Click()

    OptionClickImperial imgLetterPortraitProposal
End Sub

Private Sub imgLetterPortraitWide_Click()

    OptionClickImperial imgLetterPortraitWide
End Sub

'++*******************************************************************
' Procedure:    obtLocEnd_Change
' Description:  The location options buttons are changed so reset the
'               available options for section type
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub obtLocCurr_Change()

    Dim cControl As control
    Dim cCurrControl As MSForms.OptionButton

    'Insert at current location is selected
    If obtLocCurr.value Then
        'Disable the option button that match the current section
        SetAllOptionButtons True
        SetOptionButtons lblCurrSecOrient.Tag
        
    'Insert at current location is UNSELECTED therefore insert at end of section
    Else
        SetAllOptionButtons True
        SetOptionButtons lblCurrSecOrient.Tag
        SetOptionButtons lblFollSecOrient.Tag
    End If
    
    SetFocusToFirstEnabledOption

End Sub

Sub UpdateLocationInformation()

    If frmMetric.Visible Then
'        If obtA4PortraitProposal.value = True And obtA4PortraitProposal.enabled Then
'            obtA4PortraitProposal_Click
'        Else
            If obtA4PortraitWide.value = True And obtA4PortraitWide.enabled Then
                obtA4PortraitWide_Click
            Else

                obtA4Landscape_Click

            End If
'        End If
    Else
'        If obtLetterPortraitProposal.value = True And obtLetterPortraitProposal.enabled Then
'            obtLetterPortraitProposal_Click
'        Else
            If obtLetterPortraitWide.value = True And obtLetterPortraitWide.enabled Then
                obtLetterPortraitWide_Click
            Else

                obtLetterLandscape_Click

            End If
'        End If
    End If
End Sub



Sub SetFocusToFirstEnabledOption()

    Dim bGetOut As Boolean
    bGetOut = False


    If frmMetric.Visible Then

            'If obtA4PortraitProposal.value = True And obtA4PortraitProposal.enabled Then bGetOut = True
            If obtA4PortraitWide.value = True And obtA4PortraitWide.enabled Then bGetOut = True
            If obtA4Landscape.value = True And obtA4Landscape.enabled Then bGetOut = True
            If optA3Landscape.value = True And optA3Landscape.enabled Then bGetOut = True
        
            'A4
            If Not bGetOut Then
                If obtA4PortraitProposal.enabled Then
                    obtA4PortraitProposal.value = True
                Else
                    If obtA4PortraitWide.enabled Then
                        obtA4PortraitWide.value = True
                    Else
                        If obtA4Landscape.enabled Then
                            obtA4Landscape.value = True
                        Else
                            optA3Landscape.value = True
                        End If
                    End If
                End If
            End If
    Else
            If obtLetterPortraitProposal.value = True And obtLetterPortraitProposal.enabled Then bGetOut = True
            If obtLetterPortraitWide.value = True And obtLetterPortraitWide.enabled Then bGetOut = True
            If obtLetterLandscape.value = True And obtLetterLandscape.enabled Then bGetOut = True
            If obtLedgerLandscape.value = True And obtLedgerLandscape.enabled Then bGetOut = True
        
            'A4
            If Not bGetOut Then
                If obtLetterPortraitProposal.enabled Then
                    obtLetterPortraitProposal.value = True
                Else
                    If obtLetterPortraitWide.enabled Then
                        obtLetterPortraitWide.value = True
                    Else
                        If obtLetterLandscape.enabled Then
                            obtLetterLandscape.value = True
                        Else
                            obtLedgerLandscape.value = True
                        End If
                    End If
                End If
            End If
    End If
    
End Sub

Sub SetOptionButtons(SectionType As Brochet_PAGE_TYPE)


    Select Case SectionType
'        Case A4PROPOSAL
'            imgA4PortraitProposal.enabled = False
'            obtA4PortraitProposal.enabled = False
        Case A4WIDE
            imgA4PortraitWide.enabled = False
            obtA4PortraitWide.enabled = False
        Case A4LANDSCAPE
            imgA4Landscape.enabled = False
            obtA4Landscape.enabled = False
        Case A3LANDSCAPE
            imgA3Landscape.enabled = False
            optA3Landscape.enabled = False
        Case LETTERWIDE
            imgLetterPortraitWide.enabled = False
            obtLetterPortraitWide.enabled = False
        Case LETTERLANDSCAPE
            imgLetterLandscape.enabled = False
            obtLetterLandscape.enabled = False
    End Select


End Sub

Sub SetAllOptionButtons(bSetting As Boolean)

        If frmMetric.Visible Then

'            imgA4PortraitProposal.enabled = bSetting
'            obtA4PortraitProposal.enabled = bSetting

            imgA4PortraitWide.enabled = bSetting
            obtA4PortraitWide.enabled = bSetting
   
            imgA4Landscape.enabled = bSetting
            obtA4Landscape.enabled = bSetting

'            imgA3Landscape.enabled = bSetting
'            optA3Landscape.enabled = bSetting
            
        ElseIf frmImperial.Visible Then

'            imgLetterPortraitProposal.enabled = bSetting
'            obtLetterPortraitProposal.enabled = bSetting

            imgLetterPortraitWide.enabled = bSetting
            obtLetterPortraitWide.enabled = bSetting

            imgLetterLandscape.enabled = bSetting
            obtLetterLandscape.enabled = bSetting

'            imgLedgerLandscape.enabled = bSetting
'            obtLedgerLandscape.enabled = bSetting
        End If
        

End Sub

'++*******************************************************************
' Procedure:    UserForm_Activate
' Description:  Set up the dialog box on loading
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub UserForm_Activate()

    Dim iSecNo As Integer
    Dim iNoSections As Integer
    Dim iCurrColNo As Integer
    Dim rRange As Range
    Dim bTitlePg As Boolean
    Dim bExecSummPg As Boolean
    Dim bContentsPg As Boolean
    Dim bBackPg As Boolean
    Dim iStartSecNo As Integer
    Dim iEndSecNo As Integer
    Dim bBackPageExists As Boolean
    Dim NextSectionType As Brochet_PAGE_TYPE

    Me.Caption = COMPANY_NAME & " - " & Me.Caption

    'Get the section number
    iNoSections = ActiveDocument.Sections.count
    iSecNo = Selection.Information(wdActiveEndSectionNumber)
    iCurrColNo = ActiveDocument.Sections(iSecNo).PageSetup.TextColumns.count
    
    'Get the Current page type
    miCurrSecType = modPages.GetPageType(iSecNo)
    
    lblCurrSecOrient = GetSectionName(miCurrSecType)
    lblCurrSecOrient.Tag = miCurrSecType

    ShowHidePageOptions miCurrSecType

    

    'Get the following section details
    If iSecNo = iNoSections Then
        'In the last section so no follow on section
        NextSectionType = A4WIDE 'TYPE_OTHER
        lblFollSecOrient = "n/a"
        lblFollSecOrient.Tag = A4WIDE 'TYPE_OTHER
    Else
        NextSectionType = GetPageType(iSecNo + 1)
        lblFollSecOrient.Tag = NextSectionType
        lblFollSecOrient = GetSectionName(NextSectionType)
    End If
    

    'Set the option to Insert in Current section
    obtLocCurr.value = True
    UpdateLocationInformation

End Sub

Sub ShowHidePageOptions(pageType As Brochet_PAGE_TYPE)

    Select Case pageType
        Case A4PROPOSAL, A4WIDE, A4LANDSCAPE, A3LANDSCAPE
            frmImperial.Visible = False
            With frmMetric
                .Visible = True
                .Left = 183
                .Top = 6
            End With
        Case Else
            frmMetric.Visible = False
            With frmImperial
                .Visible = True
                .Left = 183
                .Top = 6
            End With

    End Select

End Sub


Function GetSectionName(NextSectionType As Brochet_PAGE_TYPE) As String

        Select Case NextSectionType
            Case A4WIDE
                GetSectionName = "A4 Portrait Page"
            Case A4LANDSCAPE
                GetSectionName = "A4 Landscape Page"
            Case A3LANDSCAPE
                GetSectionName = "A3 Landscape Page"
            Case LETTERWIDE
                GetSectionName = "Letter Portrait Page"
            Case LETTERLANDSCAPE
                GetSectionName = "Letter Landscape Page"
            Case Else 'Back Page or no other selection
                GetSectionName = "N/A"
        End Select

End Function



'++*******************************************************************
' Procedure:    butCancel_Click
' Description:  Cancel Button pressed, close dialog box and od nothing
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butCancel_Click()

    On Error GoTo butCancel_Click_EH
    
    'Unload the files
    Unload Me
    
    Exit Sub
    
butCancel_Click_EH:
    Const sProcedure As String = "butCancel_Click"
    GlobalErrorHandler err.Number, err.Description, msMODULE, sProcedure
    
End Sub

Private Sub UserForm_Initialize()

    Me.Top = Application.Top + (Application.UsableHeight / 2) - (Me.Height / 2)
    Me.Left = Application.Left + (Application.UsableWidth / 2) - (Me.Width / 2)

End Sub
Attribute VB_Name = "frmPlaceholderInsert"
Attribute VB_Base = "0{B2EB85B7-45C3-47E2-A8A9-225BE6077D43}{636E7469-BC3B-4891-BF3A-B010E267A5DD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: frmPlaceholderInsert
'*
'* Insert placeholder dialog box
'***********************************************************************************

Option Explicit

Dim miCurrSecType As Brochet_PAGE_TYPE
Dim msPg0Colour As String
Dim msPg1Colour As String


'Dim mbPagePortrait As Boolean
'++*******************************************************************
' Procedure:    butCancel_Click
' Author:       Brochet ltd
' Description:  Cancel Button pressed, close dialog box
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butCancel_Click()
    
    Unload Me
    
End Sub

'++*******************************************************************
' Procedure:    butOk_Click
' Author:       Brochet ltd
' Description:  OK Button pressed, insert placeholder and close dialog box
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Sub butOk_Click()
        
    Dim bTrackChanges As Boolean
    Dim bSmartCut As Boolean
    Dim sAutoTextName As String
    Dim iSplitNo As Integer
    Dim cControl As control
    Dim bFirstParaTable As Boolean
    Dim bCheckParaAfter As Boolean
    Dim bChangeColour As Boolean
    Dim sTableColWidth As String
    Dim sColWidth As String
    Dim sDefaultCell As String
    Dim sTagString As String
    Dim sControlName As String
    Dim sRowNo As String
    Dim tTable As Table
    Dim rRange As Range
    Dim rStartPos As Range
    Dim shpBackground As Shape
    Dim pParagraph As Paragraph
    Dim bStylesMissing As Boolean
    Dim sStylesMissing As String
    Dim i As Integer
    Dim sRow As String
    Dim sCol As String
    Dim bDividerPg As Boolean
    Dim bImageRequired As Boolean
    Dim sText As String
    Dim sShape As Shape
    Dim rCCDivider As Range

    If Not butOk.enabled Then
        ' how can we get here, if butOk is disabled?
        Exit Sub
    End If
    
    Me.hide

    'Get the correct placeholder information from the currently selected image
    For Each cControl In Me.mpgMain.Pages(Me.mpgMain.value).Controls
        If cControl.Name Like "img*" Then
            If cControl.BorderColor = &HFF& And cControl.Visible Then
                sTagString = cControl.Tag
                Exit For
            End If
        End If
    Next

    'If smart cut and pastes is set to on switch off
    bSmartCut = False
    If Options.SmartCutPaste = True Then
        bSmartCut = True
        Options.SmartCutPaste = False
    End If

    'Switch off track Changes if on
    bTrackChanges = False
    If ActiveDocument.TrackRevisions Then
        bTrackChanges = True
        ActiveDocument.TrackRevisions = False
    End If

    If sTagString <> "" Then

        'Move the selection to the start of the paragraph as if insert a wrapped table
        Selection.StartOf wdParagraph

        'If the selection is just infront of a table insert an extra CR
        If Selection.Tables.count > 0 And Selection.Information(wdEndOfRangeRowNumber) Then
            Selection.InsertBefore vbCr
            Selection.Collapse wdCollapseEnd
        End If

        iSplitNo = Len(sTagString) - Len(Replace(sTagString, "|", ""))
        sAutoTextName = Split(sTagString, "|")(0)

            
        
            If iSplitNo >= 1 Then
                sTableColWidth = Split(sTagString, "|")(1)
            End If
    
            If iSplitNo >= 2 Then
                sDefaultCell = Split(sTagString, "|")(2)
            End If

            'If the paragraph has no space before then add an NormalNoSpace before adding the image
            If Selection.Paragraphs.SpaceBefore = 0 And bCheckParaAfter Then
                'Next check that not an empty NormalNoSpace para
                If Not (Selection.Paragraphs.Style = "NormalNoSpace" And Len(Selection.Paragraphs(1).Range.text) < 2) Then
                    Selection.InsertBefore vbCr
                    Selection.Collapse wdCollapseStart
                    Selection.Style = "NormalNoSpace"
                End If
            End If
    
            Set rStartPos = Selection.Range.Duplicate
    
            'Insert the correct autotext
            On Error GoTo MissingAutoText
'            ActiveDocument.AttachedTemplate.AutoTextEntries(sAutoTextName).Insert Where _
 '                   :=Selection.Range, richtext:=True
            Set rRange = ActiveDocument.AttachedTemplate.AutoTextEntries(sAutoTextName).Insert(Where _
                    :=Selection.Range, richtext:=True)
            On Error GoTo 0
    
            'ModifySectionDependantStyles rRange
            'Set tTable to point to the table just added
'            Set rRange = Selection().Range
'            rRange.Start = rRange.Start - 2
'            rRange.Collapse wdCollapseStart
            If rRange.Tables.count > 0 Then
                Set tTable = rRange.Tables(1)
            End If
            
            If sTableColWidth <> "" Then
                'Need to split the values of each column
                If Right(sTableColWidth, 1) = "%" Then
                    'Force Table to 100 %
                    tTable.PreferredWidthType = wdPreferredWidthPercent
                    tTable.PreferredWidth = Val(sTableColWidth)
                Else
                    For i = 1 To tTable.Columns.count
                        sColWidth = modPrivate.SplitWithoutError(sTableColWidth, ";", i - 1)
                        If sColWidth <> "" Then
                            If Val(sColWidth) > 0 And Val(sColWidth) < 1000 Then
                                tTable.Columns(i).Width = CentimetersToPoints(Val(sColWidth))
                            End If
                        End If
                    
                    Next
                End If
            End If
    
            'Move the default cell
            If sDefaultCell <> "" Then
    
                sRow = modPrivate.SplitWithoutError(sDefaultCell, ";", 0)
                sCol = modPrivate.SplitWithoutError(sDefaultCell, ";", 1)
                If (Val(sCol) >= 1 And Val(sCol) <= tTable.Columns.count) And _
                    (Val(sRow) >= 1 And Val(sRow) <= tTable.Rows.count) Then
                    Set rRange = tTable.Cell(Val(sRow), Val(sCol)).Range.Paragraphs(1).Range
                    rRange.End = rRange.End - 1
                    rRange.Select
    
                End If
            End If
        
    End If

    'Switch back on Smart cut and paste
    If bSmartCut Then
        Options.SmartCutPaste = True
    End If
    
    'Switch Track Changes back on
    If bTrackChanges Then
        ActiveDocument.TrackRevisions = True
    End If

    Unload Me
    Exit Sub

MissingAutoText:
    MsgBox "The placeholder autotext (" & sTagString & ") cannot be found!", vbInformation, "Insert Placeholder"
    Unload Me
    Exit Sub
    
End Sub


Sub SetOptionAndImageHighlight(optControl As control, imgControl As control)

    optControl.SetFocus
    optControl.value = True
    'Next two lines are necessary to display different border colours for image.
    'It seems that it somehow 'resets' the image so the borders display correctly
    imgControl.Visible = False    'now button change event has changed the image border, but it looks like before.
    imgControl.Visible = True     'these two lines fixes that

End Sub



'=============== Page 0 ===============
'======================================

Private Sub obt1Opt1_Change()
    If obt1Opt1.value Then SetPg0ImagesBorders 1
End Sub
Private Sub obt1Opt2_Change()
    If obt1Opt2.value Then SetPg0ImagesBorders 2
End Sub
Private Sub obt1Opt3_Change()
    If obt1Opt3.value Then SetPg0ImagesBorders 3
End Sub
Private Sub obt1Opt4_Change()
    If obt1Opt4.value Then SetPg0ImagesBorders 4
End Sub
Private Sub obt1Opt5_Change()
    If obt1Opt5.value Then SetPg0ImagesBorders 5
End Sub


Private Sub img1Opt1_Click()
    SetOptionAndImageHighlight obt1Opt1, img1Opt1
End Sub
Private Sub img1Opt2_Click()
    SetOptionAndImageHighlight obt1Opt2, img1Opt2
End Sub
Private Sub img1Opt3_Click()
    SetOptionAndImageHighlight obt1Opt3, img1Opt3
End Sub
Private Sub img1Opt4_Click()
    SetOptionAndImageHighlight obt1Opt4, img1Opt4
End Sub
Private Sub img1Opt5_Click()
    SetOptionAndImageHighlight obt1Opt5, img1Opt5
End Sub


Sub SetPg0ImagesBorders(iPosNo As Integer)

    img1Opt1.BorderColor = IIf(iPosNo = 1, &HFF&, &H80000006)
    img1Opt2.BorderColor = IIf(iPosNo = 2, &HFF&, &H80000006)
    img1Opt3.BorderColor = IIf(iPosNo = 3, &HFF&, &H80000006)
    img1Opt4.BorderColor = IIf(iPosNo = 4, &HFF&, &H80000006)
    img1Opt5.BorderColor = IIf(iPosNo = 5, &HFF&, &H80000006)

End Sub


'=============== Page 1 ===============
'======================================

Private Sub obt2Opt1_Change()
    If obt2Opt1.value Then SetPg1ImagesBorders 1
End Sub
Private Sub obt2Opt2_Change()
    If obt2Opt2.value Then SetPg1ImagesBorders 2
End Sub
Private Sub obt2Opt3_Change()
    If obt2Opt3.value Then SetPg1ImagesBorders 3
End Sub



Private Sub img2Opt1_Click()
    SetOptionAndImageHighlight obt2Opt1, img2Opt1
End Sub
Private Sub img2Opt2_Click()
    SetOptionAndImageHighlight obt2Opt2, img2Opt2
End Sub
Private Sub img2Opt3_Click()
    SetOptionAndImageHighlight obt2Opt3, img2Opt3
End Sub

Sub SetPg1ImagesBorders(iPosNo As Integer)

    img2Opt1.BorderColor = IIf(iPosNo = 1, &HFF&, &H80000006)
    img2Opt2.BorderColor = IIf(iPosNo = 2, &HFF&, &H80000006)
    img2Opt3.BorderColor = IIf(iPosNo = 3, &HFF&, &H80000006)

End Sub

'=============== Page 2 ===============
'======================================

Private Sub obt3Opt1_Change()
    If obt3Opt1.value Then SetPg3ImagesBorders 1
End Sub
Private Sub obt3Opt2_Change()
    If obt3Opt2.value Then SetPg3ImagesBorders 2
End Sub
Private Sub obt3Opt3_Change()
    If obt3Opt3.value Then SetPg3ImagesBorders 3
End Sub



Private Sub img3Opt1_Click()
    SetOptionAndImageHighlight obt3Opt1, img3Opt1
End Sub
Private Sub img3Opt2_Click()
    SetOptionAndImageHighlight obt3Opt2, img3Opt2
End Sub
Private Sub img3Opt3_Click()
    SetOptionAndImageHighlight obt3Opt3, img3Opt3
End Sub

Sub SetPg3ImagesBorders(iPosNo As Integer)

    img3Opt1.BorderColor = IIf(iPosNo = 1, &HFF&, &H80000006)
    img3Opt2.BorderColor = IIf(iPosNo = 2, &HFF&, &H80000006)
    img3Opt3.BorderColor = IIf(iPosNo = 3, &HFF&, &H80000006)

End Sub


'=============== Page 3 ===============
'======================================

Private Sub obt6Opt1_Change()
    If obt6Opt1.value Then SetPg4ImagesBorders 1
End Sub
Private Sub obt6Opt2_Change()
    If obt6Opt2.value Then SetPg4ImagesBorders 2
End Sub
Private Sub obt6Opt3_Change()
    If obt6Opt3.value Then SetPg4ImagesBorders 3
End Sub



Private Sub img6Opt1_Click()
    SetOptionAndImageHighlight obt6Opt1, img6Opt1
End Sub
Private Sub img6Opt2_Click()
    SetOptionAndImageHighlight obt6Opt2, img6Opt2
End Sub
Private Sub img6Opt3_Click()
    SetOptionAndImageHighlight obt6Opt3, img6Opt3
End Sub

Sub SetPg4ImagesBorders(iPosNo As Integer)

    img6Opt1.BorderColor = IIf(iPosNo = 1, &HFF&, &H80000006)
    img6Opt2.BorderColor = IIf(iPosNo = 2, &HFF&, &H80000006)
    img6Opt3.BorderColor = IIf(iPosNo = 3, &HFF&, &H80000006)

End Sub

'++*******************************************************************
' Procedure:    UserForm_Initialize
' Author:       Brochet ltd
' Description:  OK Button pressed, insert placeholder and close dialog box
' Parameters:   N/A
' Returns:      N/A
'++*******************************************************************
Private Sub UserForm_Initialize()

    'Dim sSectionType As String
    Dim iNoSections As Integer
    Dim iSecNo As Integer
    Dim cControl1 As control
    Dim cControl2 As control
    Dim bOptionNoVisible As Boolean
    Dim iCurrColNo As Integer
    Dim i As Integer
    Dim j As Integer
    
    Me.Caption = COMPANY_NAME & " - Insert Placeholder"
    
    Me.Top = Application.Top + (Application.UsableHeight / 2) - (Me.Height / 2)
    Me.Left = Application.Left + (Application.UsableWidth / 2) - (Me.Width / 2)
    
    'Get the section number
    iNoSections = ActiveDocument.Sections.count
    iSecNo = Selection.Information(wdActiveEndSectionNumber)
    iCurrColNo = ActiveDocument.Sections(iSecNo).PageSetup.TextColumns.count
    
    'Get the Current page type
    miCurrSecType = modPages.GetPageType(iSecNo)
    
   
    'Make the all pages invisible until we need them
    Me.mpgMain.Pages(0).Visible = False
    Me.mpgMain.Pages(1).Visible = False
    Me.mpgMain.Pages(2).Visible = False
    Me.mpgMain.Pages(3).Visible = False


    'Make the correct option on the dialog box visible
    obt1Opt1.value = True
    obt2Opt1.value = True
    obt3Opt1.value = True
    obt6Opt1.value = True
'
    'If the current page is a one column page then display the correct page
    Select Case miCurrSecType
        Case A4PROPOSAL, LETTERPROPOSAL
                Me.mpgMain.Pages(0).Visible = True
        Case A4WIDE, LETTERWIDE
                Me.mpgMain.Pages(1).Visible = True
        Case A4LANDSCAPE, LETTERLANDSCAPE
                Me.mpgMain.Pages(2).Visible = True
        Case A3LANDSCAPE, LEDGERLANDSCAPE
                Me.mpgMain.Pages(3).Visible = True
        Case Else
            Me.mpgMain.Pages(0).Visible = True
    End Select
    

    'Make sure the correct page is selected
    For i = 0 To 3
        If Me.mpgMain.Pages(i).Visible Then
            Me.mpgMain.value = i
            Exit For
        End If
    Next
    
End Sub



Attribute VB_Name = "frmProgress"
Attribute VB_Base = "0{4F5BF6B9-8DA4-4390-A775-6616D58CB29A}{72D460CA-257F-49F4-BD76-39503B0DB2CA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


'***********************************************************************************
'* Expense Reduction Analysts Report template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: frmPlaceholderInsert
'*
'* Progress bar for operations that needs that
'***********************************************************************************

Option Explicit

#If VBA7 Then
    'Find the userform's Window
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    
    'Get the current window style
    Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long) As Long
    
    'Set the new window style
    Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    
    'Get the current window style
    Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long) As Long
    
    'Set the new window style
    Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal HWND As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Const GWL_STYLE = -16
Const WS_SYSMENU = &H80000
Const WS_VISIBLE = &H10000000
Const WS_DLGFRAME = &H400000
Const WS_BORDER = &H800000

Private iStep1 As Long
Private iMax1 As Long
Private iOrder1 As Long
Private iStep2 As Long
Private iMax2 As Long
Private iOrder2 As Long
Private iStep3 As Long
Private iMax3 As Long
Private iOrder3 As Long
Private iStep4 As Long
Private iMax4 As Long
Private iOrder4 As Long
Private iStep5 As Long
Private iMax5 As Long
Private iOrder5 As Long

'++*******************************************************************
' Description:  Initializes the progress bar dialog. Does the following
'               Sets the height of dialog based on number of progressbars requested
'               Sets the label for each bar
'               Sets the maximum value and step for each bar
' Parameters:   sCaption - Caption of the dialog
'               sDesc1 - Text in label below the first progress bar
'               iSteps - Number of steps for progressbar
'               iIncrement - How many steps are done in each increment (e.g. if iSteps is 100 and iIncrement is 5 then the progressbar would fill in 20 increments)
'               Other parameters are optional and are there to specify the same value for next prgressbars
' Returns:      N/A
'--********************************************************************
Public Sub Init(sCaption As String, sDesc1 As String, iSteps1 As Long, iIncrement1 As Long, _
            Optional sDesc2 As String, Optional iSteps2 As Long, Optional iIncrement2 As Long, _
            Optional sDesc3 As String, Optional iSteps3 As Long, Optional iIncrement3 As Long, _
            Optional sDesc4 As String, Optional iSteps4 As Long, Optional iIncrement4 As Long, _
            Optional sDesc5 As String, Optional iSteps5 As Long, Optional iIncrement5 As Long)
    Dim minimumHeight As Double
    
    'I need to get the height of title bar and borders around the dialog, so if I change the height to 0
    'the dialog will resize to it's minimum height. That will not be 0
    'THis way I can get the size of parts of dialog that are not usable
    Me.Height = 0
    minimumHeight = Me.Height
    
    'Set the caption of the dialog
    Me.Caption = sCaption
    
    'Position dialog into centre of current window
    Me.StartUpPosition = 0
    Me.Left = Application.Left + (0.5 * Application.Width) - (0.5 * Me.Width)
    Me.Top = Application.Top + (0.5 * Application.Height) - (0.5 * Me.Height)
    
    'Set the control for first progressbar
    lblDesc1.Caption = sDesc1
    lblCount1.Caption = iSteps1
    'lblCount1.AutoSize = True
    lblCount1.Left = frmProgressBars.Width - 10 - lblCount1.Width
    lblCount1.Caption = iSteps1
    lblOrder1.Caption = 0
    lblOrder1.Left = lblCount1.Left - 5 - lblOrder1.Width
    'Set the height of dialog as if there is only one progressbar
    Me.Height = 97
    
    'if the parameter for second progressbar is used, set the controls for that as well
    If LenB(sDesc2) > 0 Then
        lblDesc2.Caption = sDesc2
        lblCount2.Caption = iSteps2
        lblCount2.AutoSize = True
        lblCount2.Left = frmProgressBars.Width - 15 - lblCount2.Width
        lblOrder2.Caption = 0
        lblOrder2.Left = lblCount2.Left - 3 - lblOrder2.Width
        'Set the height of dialog as if there are two progressbars
        Me.Height = 148
        lblDesc2.Visible = True
        frmBar2.Visible = True
        lblOrder2.Visible = True
        lblCount2.Visible = True
    End If
    
    'if the parameter for third progressbar is used, set the controls for that as well
    If LenB(sDesc3) > 0 Then
        lblDesc3.Caption = sDesc3
        lblCount3.Caption = iSteps3
        lblCount3.AutoSize = True
        lblCount3.Left = frmProgressBars.Width - 15 - lblCount3.Width
        lblOrder3.Caption = 0 & " of "
        lblOrder3.Left = lblCount3.Left - 3 - lblOrder3.Width
        'Set the height of dialog as if there are Three progressbars
        Me.Height = 198
        lblDesc3.Visible = True
        frmBar3.Visible = True
        lblOrder3.Visible = True
        lblCount3.Visible = True
    End If
    
    'if the parameter for fourth progressbar is used, set the controls for that as well
    If LenB(sDesc4) > 0 Then
        lblDesc4.Caption = sDesc4
        lblCount4.Caption = iSteps4
        lblCount4.AutoSize = True
        lblCount4.Left = frmProgressBars.Width - 15 - lblCount4.Width
        lblOrder4.Caption = 0 & " of "
        lblOrder4.Left = lblCount4.Left - 3 - lblOrder4.Width
        'Set the height of dialog as if there are four progressbars
        Me.Height = 248
        lblDesc4.Visible = True
        frmBar4.Visible = True
        lblOrder4.Visible = True
        lblCount4.Visible = True
    End If
    
    'if the parameter for fifth progressbar is used, set the controls for that as well
    If LenB(sDesc5) > 0 Then
        lblDesc5.Caption = sDesc5
        lblCount5.Caption = iSteps5
        lblCount5.AutoSize = True
        lblCount5.Left = frmProgressBars.Width - 15 - lblCount5.Width
        lblOrder5.Caption = 0 & " of "
        lblOrder5.Left = lblCount5.Left - 3 - lblOrder5.Width
        Me.Height = 298
        lblDesc5.Visible = True
        frmBar5.Visible = True
        lblOrder5.Visible = True
        lblCount5.Visible = True
    End If
    
    'Set all progressbars to their starting values
    iStep1 = iIncrement1
    iMax1 = iSteps1
    iOrder1 = 0
    iStep2 = iIncrement2
    iMax2 = iSteps2
    iOrder2 = 0
    iStep3 = iIncrement3
    iMax3 = iSteps3
    iOrder3 = 0
    iStep4 = iIncrement4
    iOrder4 = 0
    iMax4 = iSteps4
    iStep5 = iIncrement5
    iOrder5 = 0
    iMax5 = iSteps5
    
    'Position the controls that shows the brochet logo and text at the bottom of dialog
    imgBrochet.Top = Me.Height - (minimumHeight + imgBrochet.Height)
    lblVers.Top = imgBrochet.Top - 1.5
    lblVers.Caption = lblVers.Caption & " " & TEMPLATE_VERSION
    
    frmProgressBars.Height = Me.Height - minimumHeight - frmProgressBars.Top - 10
    RemoveXButton
    
    'Repaint the dialog
    'Me.Repaint
    DoEvents
End Sub

'++*******************************************************************
' Procedure:    Step
' Author:       Brochet ltd
' Description:  Increases the value of given progressbar by one step
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Public Sub Step(Optional iBar As Integer = 1)
    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            SetValue iOrder1 + iStep1, iBar
        Case 2
            SetValue iOrder2 + iStep2, iBar
        Case 3
            SetValue iOrder3 + iStep3, iBar
        Case 4
            SetValue iOrder4 + iStep4, iBar
        Case 5
            SetValue iOrder5 + iStep5, iBar
    End Select
End Sub

'++*******************************************************************
' Procedure:    Finish
' Author:       Brochet ltd
' Description:  Set the value of progressbar to maximum value (finishing it)
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Public Sub Finish(Optional iBar As Integer = 1)
    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            SetValue iMax1, iBar
        Case 2
            SetValue iMax2, iBar
        Case 3
            SetValue iMax3, iBar
        Case 4
            SetValue iMax4, iBar
        Case 5
            SetValue iMax5, iBar
    End Select
End Sub

'++*******************************************************************
' Procedure:    SetValue
' Author:       Brochet ltd
' Description:  Set the value of progressbar to given value
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Public Sub SetValue(iValue As Long, Optional iBar As Integer = 1)
    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            'set the progressbar value
            iOrder1 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder1.Caption = CStr(iOrder1) & " of "
            lblOrder1.Left = lblCount1.Left - 3 - lblOrder1.Width
        Case 2
            'set the progressbar value
            iOrder2 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder2.Caption = CStr(iOrder2) & " of "
            lblOrder2.Left = lblCount2.Left - 3 - lblOrder2.Width
        Case 3
            'set the progressbar value
            iOrder3 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder3.Caption = CStr(iOrder3) & " of "
            lblOrder3.Left = lblCount3.Left - 3 - lblOrder3.Width
        Case 4
            'set the progressbar value
            iOrder4 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder4.Caption = CStr(iOrder4) & " of "
            lblOrder4.Left = lblCount4.Left - 3 - lblOrder4.Width
        Case 5
            'set the progressbar value
            iOrder5 = iValue
            'and redraw it
            RedrawBar iBar
            'and change the label below which displays the progress in numbers
            lblOrder5.Caption = CStr(iOrder5) & " of "
            lblOrder5.Left = lblCount5.Left - 3 - lblOrder5.Width
    End Select
End Sub

'++*******************************************************************
' Procedure:    RedrawBar
' Author:       Brochet ltd
' Description:  The progress bar is in fact a label that changes the width. This will do this
' Parameters:   iBar - Index of bar that should be increased. Optional if ommited the first one will increase
' Returns:      N/A
'--********************************************************************
Private Sub RedrawBar(iBar As Integer)
    Dim maxWidth As Long

    If iBar > 5 Or iBar < 1 Then
        Exit Sub
    End If
    
    Select Case iBar
        Case 1
            maxWidth = frmBar1.Width - 1
            If iOrder1 = 0 Then
                lblProgress1.Width = 0
            Else
                lblProgress1.Width = (maxWidth / iMax1) * (iOrder1 - 1)
            End If
        Case 2
            maxWidth = frmBar2.Width - 1
            If iOrder2 = 0 Then
                lblProgress2.Width = 0
            Else
                lblProgress2.Width = (maxWidth / iMax2) * (iOrder2 - 1)
            End If
        Case 3
            maxWidth = frmBar3.Width - 1
            If iOrder3 = 0 Then
                lblProgress3.Width = 0
            Else
                lblProgress3.Width = (maxWidth / iMax3) * (iOrder3 - 1)
            End If
        Case 4
            maxWidth = frmBar4.Width - 1
            If iOrder4 = 0 Then
                lblProgress4.Width = 0
            Else
                lblProgress4.Width = (maxWidth / iMax4) * (iOrder4 - 1)
            End If
        Case 5
            maxWidth = frmBar5.Width - 1
            If iOrder5 = 0 Then
                lblProgress5.Width = 0
            Else
                lblProgress5.Width = (maxWidth / iMax5) * (iOrder5 - 1)
            End If
    End Select
    Me.Repaint
    DoEvents
End Sub

''++*******************************************************************
'' Procedure:    UserForm_Initialize
'' Author:       Brochet ltd
'' Description:  Event handler for initilization event. Will remove x button for closing from dialog
'' Parameters:   N/A
'' Returns:      N/A
''--********************************************************************
'Private Sub UserForm_Initialize()
'    RemoveXButton
'End Sub

'++*******************************************************************
' Procedure:    RemoveXButton
' Author:       Brochet ltd
' Description:  Event handler for initilization event. Will remove x button for closing from dialog
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub RemoveXButton()
    Dim HWND As Long
    Dim lStyle As Long
    
    'get the handle of dialog windows
    HWND = getCurrentHWND
    'Get the current style of the windows
    lStyle = GetWindowLong(HWND, GWL_STYLE)
    'And set the new style of the windows using the previous style but without sysmenu
    SetWindowLong HWND, GWL_STYLE, (lStyle And Not WS_SYSMENU)
End Sub


'++*******************************************************************
' Procedure:    getCurrentHWND()
' Author:       Brochet ltd
' Description:  Gets the handle of this dialog
' Parameters:   N/A
' Returns:      Handle of dialog for use in WinAPI functions
'--********************************************************************
Private Function getCurrentHWND() As Long
    Dim sCaption As String
    Dim HWND As Long
    
    sCaption = Me.Caption
    'change the current caption to something vierd, because I will use this to identify the windows
    'and this will be less probable to appear twice
    Me.Caption = sCaption & "aaajshjkhdfskjgfjhfgahsfgsdjhjfgsdhj"
    
    'get the hwnd
    If Val(Application.Version) >= 9 Then
        HWND = FindWindow("ThunderDFrame", Me.Caption)
    Else
        HWND = FindWindow("ThunderXFrame", Me.Caption)
    End If
    
    'Set the original caption back
    Me.Caption = sCaption

    'return the handle
    getCurrentHWND = HWND
End Function

'++*******************************************************************
' Procedure:    CloseMe
' Author:       Brochet ltd
' Description:  Get rid of dialog
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub CloseMe()
    Unload Me
End Sub

Attribute VB_Name = "modArrays"
'***********************************************************************************
'* The Strategy Unit 2010 Global template
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modArrays
'*
'* Holds various procs to manipulate arrays
'*
'***********************************************************************************
Option Explicit
Option Compare Text
Option Private Module

Const msMODULE As String = "modArrays"

'++*******************************************************************
' Procedure:    ArrayIsDimed
' Author:       Brochet ltd
' Description:  Checks the incoming array is actaully dimensioned
' Parameters:   ary - the array to check
' Returns:      True is a properly dimensioned array
'--********************************************************************
Function ArrayIsDimed(ary) As Boolean
    'This function will check that an array has been initialised

    Dim i As Integer
    
    On Error Resume Next
    
    i = UBound(ary)
    
    ArrayIsDimed = err = 0
    
End Function

'++*******************************************************************
' Procedure:    ArrayNoOfDimensions
' Author:       Brochet ltd
' Description:  Returns the number of dimensions in the incoming array
' Parameters:   aArray - Array to check
' Returns:      -1=Array is not an aray or the number of dimensions
'--********************************************************************
Private Function ArrayNoOfDimensions(aArray) As Integer
    
    Dim i As Integer
    Dim j As Integer
    
    If Not ArrayIsDimed(aArray) Then
        ArrayNoOfDimensions = -1
        Exit Function
    End If
    
    On Error Resume Next
    Do Until err
        ArrayNoOfDimensions = i
        i = i + 1
        j = LBound(aArray, i)
    Loop
    On Error GoTo 0
    
End Function

'++*******************************************************************
' Procedure:    ArraySort
' Author:       Brochet Ltd
' Description:  Sorts a two dimensional array
' Parameters:   aArrayToSort - Array to sort
'               iCol2Sort - The column to sort (this assumes the incoming
'                 array's 1st dimension is rows and the 2nd columns)
'               bAscending - True if to be sorted ascending
'               TargetListOrComboBox - Listbox or combo box to populate
'                 with sorted array
' Returns:      N/A
'--********************************************************************
Sub ArraySort(aArrayToSort, iCol2Sort As Integer, bAscending As Boolean, Optional TargetListOrComboBox As control)

    Dim B As Variant
    Dim i As Integer
    Dim j As Integer
    Dim s As String
    Dim found As Boolean
    Dim sltn()
    Dim iNoCols As Integer
    
    System.Cursor = wdCursorWait
    
    iNoCols = ArrayNoOfDimensions(aArrayToSort)
    If iNoCols = -1 Then
        Exit Sub
    ElseIf iNoCols <> 2 Then
        MsgBox "Only expecting 2 dimensional arrays in 'ArraySort'.", vbInformation
        Exit Sub
    End If
    
    iNoCols = UBound(aArrayToSort, 2)
    
    Do
        
        found = False
        
        For i = 0 To UBound(aArrayToSort, 1) - 1
        
            If bAscending Then
            
                found = aArrayToSort(i + 1, iCol2Sort) < aArrayToSort(i, iCol2Sort)
                
            Else
            
                found = aArrayToSort(i + 1, iCol2Sort) > aArrayToSort(i, iCol2Sort)
                
            End If
            
            If found Then
                
                'Swap this pair
                For j = 0 To iNoCols
                      
                    B = aArrayToSort(i, j)
                    aArrayToSort(i, j) = aArrayToSort(i + 1, j)
                    aArrayToSort(i + 1, j) = B
                    
                Next j
                
                i = i - 2
                If i < -1 Then
                
                    i = -1
                    
                End If
            
            End If
                
        Next i
        
    Loop Until Not found 'Keep looping until there are no more swaps required
    
    If Not TargetListOrComboBox Is Nothing Then
    
        TargetListOrComboBox.List = aArrayToSort
        
    End If
            
    System.Cursor = wdCursorNormal
    
End Sub

'++*******************************************************************
' Procedure:    ArraySortSingleDimension
' Author:       Brochet Ltd
' Description:  Sorts a single dimensional array
' Parameters:   aArrayToSort - Array to sort
'               bAscending - True if to be sorted ascending
' Returns:      N/A
'--********************************************************************
Sub ArraySortSingleDimension(aArrayToSort, bAscending As Boolean)

    Dim B As Variant
    Dim i As Integer
    Dim found As Boolean
    Dim iNoCols As Integer
    
    System.Cursor = wdCursorWait
    
    iNoCols = ArrayNoOfDimensions(aArrayToSort)
    If iNoCols = -1 Then
        Exit Sub
    ElseIf iNoCols <> 1 Then
        MsgBox "Only expecting single dimensional arrays in 'ArraySortSingleDimension'.", vbInformation
        Exit Sub
    End If
    
    Do
        
        found = False
        
        For i = LBound(aArrayToSort, 1) To UBound(aArrayToSort, 1) - 1
        
            If bAscending Then
            
                found = aArrayToSort(i + 1) < aArrayToSort(i)
                
            Else
            
                found = aArrayToSort(i + 1) > aArrayToSort(i)
                
            End If
            
            If found Then
                
                'Swap this pair
                B = aArrayToSort(i)
                aArrayToSort(i) = aArrayToSort(i + 1)
                aArrayToSort(i + 1) = B
                    
                i = i - 2
                If i < LBound(aArrayToSort, 1) - 1 Then
                
                    i = LBound(aArrayToSort, 1) - 1
                    
                End If
            
            End If
                
        Next i
        
    Loop Until Not found 'Keep looping until there are no more swaps required
    
    System.Cursor = wdCursorNormal
    
End Sub


Attribute VB_Name = "modBrochetChartTool"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modBrochetChartTool
'*
'* Holds various macro code related to the Brochet Chart Tool
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modBrochetChartTool"


Public Function ReformatChart(template As String) As Integer
    Dim clsBrochetAPI As cAddinAPI
    
'    Dim oUndoRecord As cUndoRecord
'
'    Set oUndoRecord = New cUndoRecord
'    oUndoRecord.SetName "Format Excel Chart"
  
    Set clsBrochetAPI = New cAddinAPI
    If clsBrochetAPI.isReady Then
        ReformatChart = clsBrochetAPI.RunOperation("ReformatWordChart", template)
    Else
        modError.DisplayMsg "The Brochet Chart tool is not installed. Please contact your IT department"
    End If
    
'    oUndoRecord.EndRecording
    
End Function


Public Sub ReformatSelectedChart()


    Dim rRange As Range
    
    Dim oUndoRecord As cUndoRecord
   
    modScreenUpdating.ScreenUpdating_Disable
    
    On Error Resume Next
    
    Set rRange = Selection.Range
    
    With rRange
        If .InlineShapes.count = 1 Then
            If .InlineShapes(1).Type = wdInlineShapeChart Then
                Set oUndoRecord = New cUndoRecord
                oUndoRecord.SetName "Reformat Chart"
                modBrochetChartTool.ReformatChart "RFP"
            Else
                modError.DisplayMsg "Please select a linked Excel Chart to reformat"
            End If
        Else
            modError.DisplayMsg "Please select a chart to reformat"
        End If
    End With
    
    modScreenUpdating.ScreenUpdating_Enable
    oUndoRecord.EndRecording
        
        
End Sub
Attribute VB_Name = "modChartInfo"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modChartInfo
'*
'* Code to handle reading of chart types and display appropriate information
'* of metadata
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modChartInfo"


 Public Sub DisplayChartInfo()

    On Error GoTo err

    If Selection.InlineShapes.count = 1 Then
        Select Case Selection.InlineShapes(1).Type
        Case wdInlineShapeChart
            Dialogs(wdDialogEditLinks).Show
        Case wdInlineShapePicture
            frmChartInfo.Show
        End Select
    Else
        Dialogs(wdDialogEditLinks).Show
    End If

err:

    If err.Number = 4605 Then
        modError.DisplayMsg "There are no linked Charts in this document."
    End If

    err.Clear

End Sub
Attribute VB_Name = "modContentControls"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*

'***********************************************************************************

Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modContentControls"

Public Const CC_BROCHET_DISCLOSURES_GROUP As String = "BrochetDisclosuresGroup"
Public Const CC_CONTACT_PAGE As String = "BrochetContactPageGroup"
Public Const CC_PORTABILITY_LANGUAGE As String = "ccPortabilityLanguage"




Public Function ContentControlExists(sControlTag As String) As Boolean

On Error GoTo eErr
    
    Dim cc As ContentControl
    ContentControlExists = False
    
    For Each cc In ActiveDocument.SelectContentControlsByTag(sControlTag)
        If cc.Tag = sControlTag Then
            ContentControlExists = True
            Exit For
        End If
    Next
    
clean:

Exit Function
eErr:

    ContentControlExists = False
    Resume clean

End Function

Sub ApplyStyle(sControlTag As String, sStyle As String)

    Dim cc As ContentControl
    
    Dim bLockContents As Boolean
    Dim bLockControl As Boolean
    
    On Error GoTo err
    
    For Each cc In ActiveDocument.ContentControls
        If cc.Tag = sControlTag Then
            bLockContents = cc.LockContents
            bLockControl = cc.LockContentControl
            cc.LockContents = False
            cc.Range.Style = sStyle
    
            cc.LockContents = bLockContents
            cc.LockContentControl = bLockControl
        End If
    Next

out:

    Exit Sub

err:
    Resume out


End Sub


Function GetTextFromControl(sTag As String) As String

    Dim ccControl As ContentControl
    
    Set ccControl = GetContentControlFromTag(sTag)
    If Not ccControl Is Nothing Then
        If ccControl.Range.text = ccControl.PlaceholderText Then
            GetTextFromControl = ""
        ElseIf ccControl.Range.text = " " Then
            GetTextFromControl = ""
        Else
            GetTextFromControl = ccControl.Range.text
        End If
    Else
        GetTextFromControl = ""
    End If

End Function


Public Function GetContentControlFromTag(sControlTag As String) As ContentControl

On Error GoTo eErr
    
    Dim cc As ContentControl
    
    For Each cc In ActiveDocument.SelectContentControlsByTag(sControlTag)
        If cc.Tag = sControlTag Then
            Set GetContentControlFromTag = cc
            Exit For
        End If
    Next

clean:

    Exit Function
eErr:

    Set GetContentControlFromTag = Nothing
    Resume clean

End Function

Public Function GetRangeFromTag(sControlTag As String) As Range

On Error GoTo eErr
    
    Dim cc As ContentControl
    
    For Each cc In ActiveDocument.ContentControls
        If cc.Tag = sControlTag Then
            Set GetRangeFromTag = cc.Range
            Exit For
        End If
    Next

clean:

    Exit Function
eErr:

    Set GetRangeFromTag = Nothing
    Resume clean

End Function


Sub ReplaceWithAutoTextInControl(sControlTag As String, sAutotext As String)

    Dim cc As ContentControl
    
    Dim bLockContents As Boolean
    Dim bLockControl As Boolean
    
    On Error GoTo err
    
    Set cc = GetContentControlFromTag(sControlTag)
    
    If Not cc Is Nothing Then
        bLockContents = cc.LockContents
        bLockControl = cc.LockContentControl
        cc.LockContents = False
        'cc.Appearance = wdContentControlBoundingBox
        cc.Range.Paragraphs.Style = "Normal"
        cc.Range.text = ""

        ActiveDocument.AttachedTemplate.AutoTextEntries(sAutotext).Insert Where:=cc.Range, richtext:=True
        cc.Range.Fields.Update
        cc.LockContents = bLockContents
        cc.LockContentControl = bLockControl
    End If

out:

    Exit Sub

err:
    'modError.DisplayMsg "There is a problem with the TOC seciton. Please remove and re-add this seciton"
    Resume out

End Sub
Sub ReplaceWithTextInControl(sControlTag As String, sText As String, Optional sStyle As String = "Normal")

    Dim cc As ContentControl
    
    Dim bLockContents As Boolean
    Dim bLockControl As Boolean
    
    On Error Resume Next
    
    Set cc = GetContentControlFromTag(sControlTag)
    
    bLockContents = cc.LockContents
    bLockControl = cc.LockContentControl
    
    If Not cc Is Nothing Then
            cc.LockContents = False
            'cc.Appearance = wdContentControlBoundingBox
            cc.Range.Paragraphs.Style = sStyle
            If sText = "" Then sText = " "
            cc.Range.text = sText
            cc.Range.Fields.Update
            cc.LockContents = bLockContents
            cc.LockContentControl = bLockControl
    End If

End Sub

Sub ClearCCText(sControlTag As String)

    Dim cc As ContentControl
    
    Dim bLockContents As Boolean
    Dim bLockControl As Boolean
    
    On Error Resume Next
    
    Set cc = GetContentControlFromTag(sControlTag)
    
    bLockContents = cc.LockContents
    bLockControl = cc.LockContentControl
    
    If Not cc Is Nothing Then
            cc.LockContents = False
            cc.Range.text = ""
            cc.LockContents = bLockContents
            cc.LockContentControl = bLockControl
    End If

End Sub

Function isChildControl(cControl As ContentControl) As Boolean

    On Error GoTo err
    Dim sTemp As String
    sTemp = cControl.ParentContentControl.Tag
    
clean:
    isChildControl = True
    
    Exit Function
err:
    isChildControl = False
    

End Function

Function ReturnAllContentControlsInRange(rRange As Range) As ContentControls

    Dim rStart As Range
    Dim rEnd As Range

    If modContentControls.IsSelectionInCC(rRange) Then
        If rRange.ContentControls.count = 0 Then
            Set rStart = rRange.Duplicate
            While rStart.ContentControls.count = 0
                rStart.MoveStart wdCharacter, -1
            Wend
            Set rEnd = rRange.Duplicate
            While rEnd.ContentControls.count = 0
                rEnd.MoveEnd wdCharacter, 1
            Wend
            
            Set ReturnAllContentControlsInRange = ActiveDocument.Range(rStart.Start, rEnd.End).ContentControls
        Else
            Set ReturnAllContentControlsInRange = rRange.ContentControls
        End If
    End If


End Function


Function GetAllContentControlsInRange(rRange As Range) As ContentControls

    Dim rStart As Range
    Dim rEnd As Range


        If rRange.ContentControls.count = 0 Then
            Set rStart = rRange.Duplicate
            While rStart.ContentControls.count = 0
                rStart.MoveStart wdCharacter, -1
            Wend
            Set rEnd = rRange.Duplicate
            While rEnd.ContentControls.count = 0
                rEnd.MoveEnd wdCharacter, 1
            Wend
            
            Set GetAllContentControlsInRange = ActiveDocument.Range(rStart.Start, rEnd.End).ContentControls
        Else
            Set GetAllContentControlsInRange = rRange.ContentControls
        End If



End Function

Function ReturnContentControlGroup(rRange As Range) As ContentControl

    Dim ccs As ContentControls
    Dim ccGroup As ContentControl
    Dim ccTemp As ContentControl
    
    
    Set ccs = ReturnAllContentControlsInRange(rRange)
    
    For Each ccTemp In ccs
        If Left(ccTemp.Tag, 7) = "Section" Then
            If ccTemp.Tag = "Section Group" Then
                Set ReturnContentControlGroup = ccTemp
                Exit Function
            Else
                If isChildControl(ccTemp) Then
                    Set ReturnContentControlGroup = ccTemp.ParentContentControl
                    Exit Function
                End If
            End If
        End If
    Next


End Function


Function RangeHasMultipleSections(rRange As Range) As Boolean

    Dim ccTest As ContentControl
    Dim iCCCOunt As Integer

    RangeHasMultipleSections = False

    If rRange.ContentControls.count > 0 Then
        For Each ccTest In rRange.ContentControls
            If ccTest.Tag = "Section Group" Then
                iCCCOunt = iCCCOunt + 1
            End If
        Next
        
        If iCCCOunt > 1 Then
            RangeHasMultipleSections = True
        End If
    End If

End Function


Function IsSelectionInCC(rRange As Range) As Boolean
    Dim rng As Word.Range
    Dim doc As Word.Document
    Dim nrCC As Long
    Dim cc As Word.ContentControl
    Dim InCC As Boolean
    Dim i As Integer
    
    InCC = False
    Set doc = rRange.Parent
    nrCC = doc.ContentControls.count
    
'    If rRange.Information(wdInContentControl) Then
'        InCC = True
'    Else
    
        If nrCC > 0 Then
            For i = 1 To nrCC
                If rRange.InRange(doc.ContentControls(i).Range) Then
                    InCC = True
                End If
            Next
        End If
   ' End If
    
    IsSelectionInCC = InCC
    
End Function

Function GetCCFromRange(rRange As Range) As ContentControl
    Dim rng As Word.Range
    Dim doc As Word.Document
    Dim nrCC As Long
    Dim cc As Word.ContentControl
    Dim InCC As Boolean
    Dim i As Integer
    
    InCC = False
    Set doc = rRange.Parent
    nrCC = doc.ContentControls.count
    
    If nrCC > 0 Then
        For i = 1 To nrCC
            If rRange.InRange(doc.ContentControls(i).Range) Then
                Set GetCCFromRange = doc.ContentControls(i)
            End If
        Next
    End If
    
    
End Function

Sub AppendFieldtoCC(sCCTag As String, sFieldCode As String)

    Dim oControl As ContentControl
    Dim bLocked As Boolean
    Dim rRange As Range
    

    If ContentControlExists(sCCTag) Then
        Set oControl = GetContentControlFromTag(sCCTag)
        bLocked = oControl.LockContents
        oControl.LockContents = False
        Set rRange = oControl.Range
        rRange.Collapse wdCollapseEnd
        ActiveDocument.Fields.Add rRange, wdFieldTOC, sFieldCode
        
        oControl.LockContents = bLocked
        
    End If
        



End Sub
Sub AppendTexttoCC(sCCTag As String, sText As String, Optional sStyle As String = "Normal")

    Dim oControl As ContentControl
    Dim bLocked As Boolean
    Dim rRange As Range
    
    On Error Resume Next

    If ContentControlExists(sCCTag) Then
        Set oControl = GetContentControlFromTag(sCCTag)
        bLocked = oControl.LockContents
        oControl.LockContents = False
        
        Set rRange = oControl.Range
        rRange.Collapse wdCollapseEnd
        rRange.InsertAfter sText
        rRange.Style = sStyle
        
        oControl.LockContents = bLocked
    End If
        

End Sub

Sub AppendAutoTextToCC(sCCTag As String, sAutotext As String)

    Dim oControl As ContentControl
    Dim bLocked As Boolean
    Dim rRange As Range
    

    If ContentControlExists(sCCTag) Then
        Set oControl = GetContentControlFromTag(sCCTag)
        bLocked = oControl.LockContents
        oControl.LockContents = False
        
        Set rRange = oControl.Range
        rRange.Collapse wdCollapseEnd
        
        ActiveDocument.AttachedTemplate.AutoTextEntries(sAutotext).Insert Where:=rRange, richtext:=True

        oControl.LockContents = bLocked
    End If
        

End Sub


Sub ClearFirstSpaceAndLastPara(sTag As String)


    Dim ccControl As ContentControl
    
    On Error Resume Next
    
    Set ccControl = GetContentControlFromTag(sTag)
    
    If Not ccControl Is Nothing Then
        With ccControl.Range
            If .Characters(1) = " " Then
                .Characters(1) = ""
            End If
        
            If .Characters(.Characters.count) = Chr(13) Then
                .Characters(.Characters.count) = ""
            End If
        End With
    
    End If

End Sub


Sub UnlockControlsInRange(rRange As Range)

    On Error Resume Next
    Dim oControl As ContentControl
    
    For Each oControl In rRange.ContentControls
        oControl.LockContentControl = False
        oControl.LockContents = False
    Next
    
End Sub

Sub DeleteContentControl(sTag As String)
    'Unlockall children and deletes the CC
    
    Dim rRange As Range
    Dim ccControl As ContentControl
    
    
    Set rRange = GetRangeFromTag(sTag)
    
    If Not rRange Is Nothing Then
        UnlockControlsInRange rRange
        
        Set ccControl = GetContentControlFromTag(sTag)
        If Not ccControl Is Nothing Then
            ccControl.LockContentControl = False
            ccControl.LockContents = False
            ccControl.Delete
            rRange.Delete
        End If
    End If
    



End Sub


Sub RefreshContentControlStyles()

    modContentControls.ApplyStyle "Section Heading", "Heading 2Char"
    
    'modContentControls.ApplyStyle "Section Group", "Heading 1Char"
    
End Sub

Sub Test()

    Dim cc As ContentControl

    Set cc = GetCCFromRange(Selection.Range)
    Debug.Print cc.Tag
End Sub
Attribute VB_Name = "modDocumentProperties"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'***********************************************************************************

Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modDocumentProperties"

'++*******************************************************************
' Description:  Returns the value of a document property of the
'               passed in name.
' Parameters:   sName => The variable name.
' Returns:      String. The value of the variable or Null if it does
'               not exist.
'--********************************************************************
Function GetCustomDocumentProperty(ByVal sName As String) As String
    On Error GoTo err
'    GetDocumentProperty = ActiveDocument.Variables(sName).value
    GetCustomDocumentProperty = ActiveDocument.CustomDocumentProperties(sName).value
    Exit Function

err:
    Select Case err.Number
      Case 5 'Property does not exist
        GetCustomDocumentProperty = vbNullString
      Case Else
        Const sProcedure As String = "GetCustomDocumentProperty"
        GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Function

'++*******************************************************************
' Description:  Returns the value of a document property of the
'               passed in name.
' Parameters:   sName => The variable name.
' Returns:      String. The value of the variable or Null if it does
'               not exist.
'--********************************************************************
Sub DeleteCustomDocumentProperty(ByVal sName As String)
    On Error GoTo err
'    GetDocumentProperty = ActiveDocument.Variables(sName).value
    ActiveDocument.CustomDocumentProperties(sName).Delete
    Exit Sub

err:

End Sub



'++*******************************************************************
' Description:  Adds or sets the value of a document property of the
'               passed in name and value.
' Parameters:   sName => The variable name.
'               sValue => The variable value.
' Returns:      N/A
'--********************************************************************
Sub SetCustomDocumentProperty(ByVal sName As String, ByVal sValue As String)
    On Error GoTo err
    ActiveDocument.CustomDocumentProperties.Add sName, False, msoPropertyTypeString, sValue
    Exit Sub

err:
    Select Case err.Number
      Case -2147467259 'Variable already exists just set the value
          ActiveDocument.CustomDocumentProperties(sName).value = sValue
      Case Else
        'Const sProcedure As String = "SetCustomDocumentProperty"
        'modError.GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Sub



Function CustomDocumentPropertyExists(NameOfProp As String, Optional CurrentDoc As Document) As Boolean
    Dim prop As DocumentProperty
    Dim ret As Boolean
    
    ret = False
    
    If CurrentDoc Is Nothing Then
        Set CurrentDoc = Application.ActiveDocument
    End If
    
    For Each prop In CurrentDoc.CustomDocumentProperties
        If LCase(prop.Name) = LCase(NameOfProp) Then
            ret = True
            Exit For
        End If
    Next
    
    CustomDocumentPropertyExists = ret
    
End Function



Sub InsertDocumentPropertyField(rInsertionPoint As Range, sIFSCode As String, Optional sStyle As String = "")

    Dim fField As Field
    Dim sFieldCode As String
    Dim sDocProp As String
    Dim bScreenUpdating As Boolean


    ActiveWindow.View.ShowFieldCodes = True
    bScreenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = False

    sDocProp = " DOCPROPERTY " & sIFSCode & " "

    If sStyle <> "" Then
        If StyleExistsInDocument(sStyle) Then
            rInsertionPoint.Paragraphs(1).Style = sStyle
        End If
    End If
    
    With rInsertionPoint
        .Fields.Add rInsertionPoint, wdFieldEmpty, , False
        .Collapse wdCollapseEnd
        .Move wdCharacter, 2
        .InsertBefore " IF "
        .Collapse wdCollapseEnd
        .Fields.Add rInsertionPoint, wdFieldEmpty, sDocProp, False
        .Move wdParagraph, 1
        .Move wdCharacter, -2
        .InsertBefore " = ""Error! Unknown document property name."" """" """
        .Collapse wdCollapseEnd
        .Fields.Add rInsertionPoint, wdFieldEmpty, " IF ", False
        .Move wdParagraph, 1
        .Move wdCharacter, -4
        .Fields.Add rInsertionPoint, wdFieldEmpty, sDocProp, False
        .Move wdParagraph, 1
        .Move wdCharacter, -3
        .InsertBefore "= """" """" """
        .Move wdParagraph, 1
        .Move wdCharacter, -3
        .Fields.Add rInsertionPoint, wdFieldEmpty, sDocProp, False
        .Move wdParagraph, 1
        .Move wdCharacter, -3
        .InsertBefore """"
        .Move wdParagraph, 1
        .Move wdCharacter, -2
        .InsertBefore """"
    End With
    

    
    ActiveWindow.View.ShowFieldCodes = False
    Application.ScreenUpdating = bScreenUpdating

End Sub


'==============================================================================
'==============================================================================

'           Development Utilities

'==============================================================================
'==============================================================================

 Sub DebugPrintAllCustomProperties()

'Prints all of the Custom Document Properties to the end of the current document

    Dim i As Integer

    Debug.Print "===========START==========="
    With ActiveDocument
        For i = 1 To .CustomDocumentProperties.count
            With .CustomDocumentProperties(i)
                Debug.Print .Name & ":"; .value
                'ActiveDocument.Range.InsertAfter .Name & vbCr
            End With
        Next
    End With
      Debug.Print "===========END==========="
 
    
End Sub

Sub SetupSampleDocPropoerties()

'===========Title Page====================================
'Document Title - IFS_DOCUMENT_TITLE
'Document Sub Title - No Corresponding field
'Document Date - IFS_DOCUMENT_TITLE_DATE_CREATED
'Customer ITT Ref - IFS_Project.1.CUSTOMER_PROJECT_ID
'Commercial / Technical Volume
'Commercial in Confidence
'Issue: Draft_01 - IFS_DOCUMENT_REVISION
'Issue Date: Submission Date - IFS_FIRSTREV_ISSUED
'Reference: FPnnnn - IFS_REFERENCE


'===========Document Control Page==========================
'Customer - IFS_Project.1.CUSTOMER_ID
'title - IFS_DOCUMENT_TITLE
'Document Reference - IFS_DOCUMENT_NUMBER
'Classification - IFS_ISO_CLASSIFICATION
'Issue - IFS_DOCUMENT_REVISION
'Issue Date - IFS_FIRSTREV_ISSUED
'Author - IFS_DOCUMENT_TITLE_CREATED_BY
'Approved By - IFS_FIRSTREV_APPROVED_BY
'Authorised By - IFS_FIRSTREV_CHECKED_BY

    SetCustomDocumentProperty "IFS_DOCUMENT_TITLE", "This is the Document Title"
    SetCustomDocumentProperty "IFS_DOCUMENT_TITLE_DATE_CREATED", "01 July 2019"
    SetCustomDocumentProperty "IFS_Project.1.CUSTOMER_PROJECT_ID", "ID123"
    SetCustomDocumentProperty "IFS_DOCUMENT_REVISION", "Rev 1.1"
    SetCustomDocumentProperty "IFS_FIRSTREV_ISSUED", "Issue Date 5 July 2019"
    SetCustomDocumentProperty "IFS_REFERENCE", "Ref123"
    SetCustomDocumentProperty "IFS_Project.1.CUSTOMER_ID", "Customer ID"
    SetCustomDocumentProperty "IFS_DOCUMENT_NUMBER", "123.001"
    SetCustomDocumentProperty "IFS_ISO_CLASSIFICATION", "ISO 1001"
    SetCustomDocumentProperty "IFS_DOCUMENT_REVISION", "Document Revision"
    SetCustomDocumentProperty "IFS_FIRSTREV_ISSUED", "Date Issued"
    SetCustomDocumentProperty "IFS_DOCUMENT_TITLE_CREATED_BY", "Author"
    SetCustomDocumentProperty "IFS_FIRSTREV_APPROVED_BY", "Approved By"
    SetCustomDocumentProperty "IFS_FIRSTREV_CHECKED_BY", "Autorised by"


End Sub



'Sub InsertDocumentPropertyField(rInsertionPoint As Range, sIFSCode As String, sStyle As String)
'
'    Dim fField As Field
'    Dim sFieldCode As String
'    Dim sDocProp As String
'
'    rInsertionPoint.Select
'
'    ActiveWindow.View.ShowFieldCodes = True
'
'    sDocProp = " DOCPROPERTY " & sIFSCode & " "
'
'    With Selection
'        Selection.Fields.Add Selection.Range, wdFieldEmpty, , False
'        Selection.Collapse wdCollapseStart
'        Selection.InsertBefore " IF "
'        Selection.Collapse wdCollapseEnd
'        Selection.Fields.Add Selection.Range, wdFieldEmpty, sDocProp, False
'        Selection.Move wdParagraph, 1
'        Selection.MoveLeft wdCharacter, 2
'        Selection.InsertBefore " = ""Error! Unknown document property name."" ""Doc Property Missing"" """
'        Selection.Collapse wdCollapseEnd
'        Selection.Fields.Add Selection.Range, wdFieldEmpty, " IF ", False
'        Selection.Move wdParagraph, 1
'        Selection.MoveLeft wdCharacter, 4
'        Selection.Fields.Add Selection.Range, wdFieldEmpty, sDocProp, False
'        Selection.Move wdParagraph, 1
'        Selection.MoveLeft wdCharacter, 3
'        Selection.InsertBefore "= """" ""<No Document Title>"" """
'        Selection.Move wdParagraph, 1
'        Selection.MoveLeft wdCharacter, 3
'        Selection.Fields.Add Selection.Range, wdFieldEmpty, sDocProp, False
'        Selection.Move wdParagraph, 1
'        Selection.MoveLeft wdCharacter, 3
'        Selection.InsertBefore """"
'        Selection.Move wdParagraph, 1
'        Selection.MoveLeft wdCharacter, 2
'        Selection.InsertBefore """"
'    End With
'
'    ActiveWindow.View.ShowFieldCodes = False
'
'
'End Sub
Attribute VB_Name = "modError"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modError
'*
'* Holds the error handling routines
'***********************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modError"

' TODO needs to be current project name
Private Const PROJECT_NAME As String = "Standart Global"

'++*******************************************************************
' Description:  This routine displays a message to the user for any
'               VB errors that occur. Hopefully, the user will not see
'               these errors, but if they do, the information will be
'               invaluable to the developer
' Parameters:   lErrCode    => The VB error that occurred (OLE Automation
'                              errors will overflow an integer type)
'               sProcedure  => The name of the procedure where the error
'                              occurred
'               sModule     => The name of the module where the error
'                              occurred
'               sErrDesc    => The description of the VB error
'               sMsg        => User message that can be attached before
'                              standart error message
' Returns:      N/A
'--********************************************************************
Public Sub GlobalErrorHandler(ByVal lErrCode As Long, sErrDesc As String, sModule As String, ByVal sProcedure As String, Optional ByVal sMsg As String = vbNullString, Optional Line As Integer = 0)
    Dim sProcInfo As String
    Dim sErrInfo As String
    Dim sUserMsg As String
    
    On Error GoTo GlobalErrorHandler_EH
    
    sProcInfo = "Module: " & PROJECT_NAME & "." & sModule & vbCr & "Procedure: " & sProcedure & vbCr & IIf(Line = 0, vbCr, "Line: " & Line & vbCr)
    sErrInfo = "VBA Error Number: " & lErrCode & vbCr & "Error Description: " & sErrDesc
    If Len(sMsg) > 0 Then
        sUserMsg = sMsg & vbCr & vbCr
    End If
    sUserMsg = sProcInfo & sUserMsg & sErrInfo
    
    DisplayMsg sUserMsg, vbCritical, , True
    
CleanExit:
    Exit Sub
    
GlobalErrorHandler_EH:
    DisplayMsg "GlobalErrorHandler" & err.Number & " " & err.Description
    Resume CleanExit
End Sub

'++********************************************************************
' Description:  Output standard format error message for any of the
'               template errors.
' Parameters:   vstrProcedureName - Name of proc.
'               vstrMessage - Error message.
'               vlngNumber - Error number.
'               sModule - Module name.
'               iButton - Button type.
'               sExtraInfo - Further user information.
'               bAddStandardContactMsg - Set to true to add standard
'                   message to contact IT Support.
' Returns:      Result
'--********************************************************************
Public Function DisplayMsg(sMsg As String, _
  Optional iButton As VbMsgBoxStyle = vbInformation, _
  Optional sTitleBar As String = COMPANY_NAME, _
  Optional bAddStandardContactMsg As Boolean = False) As VbMsgBoxResult

    If bAddStandardContactMsg Then
        sMsg = sMsg & vbCr & vbCr & modGlobal.gsItSupport
    End If
    
    DisplayMsg = MsgBox(sMsg, iButton, sTitleBar)
                
End Function

Attribute VB_Name = "modFields"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modFields
'*
'* Holds various macro code related to fields
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modFields"

Public Const TOC_CODE As String = "TOC \t ""Heading 1,1,Heading 1Land,"

'Public Const TOC_CODE As String = "TOC \t ""Heading 1,1,Heading 2,2,Heading 3,3,Heading 4,4,Appendix Numb,1"" \n ""1-1"""

Private Const BOOKMARK_END_OF_MAIN_SECTION As String = "_EndOfMainSection"

'++*******************************************************************
' Description:  will update fields in active document.
'               this will call function in global template, which will
'               in turn call function to update TOC in this template
' Parameters:   n/a
' Returns:      n/a
'--********************************************************************
Public Sub UpdateAllFieldCodes()

    modPublic.GlobalDirectivesSendMessageNoConfirmation "UpdateFields", False, False

End Sub

'++**************************************************************************************************************************************
' Description:  Will search the given range for a field with given code
' Parameters:   oRange - Range that will be searched
'               fieldCode - Field with this field will be returned if
'                   it exists
' Returns:      Field object with the given fieldCode or nothing if it
'               doesn't exist
'--**************************************************************************************************************************************
Public Function FindFieldByCode(oRange As Range, fieldCode As String, Optional bUseLike As Boolean = False) As Field
    Dim oField As Field
 
    For Each oField In oRange.Fields
        If bUseLike Then
            If Trim(oField.Code.text) Like (Trim(fieldCode) & "*") Then
                Set FindFieldByCode = oField
                Exit Function
            End If
        Else
            If Trim(oField.Code.text) = Trim(fieldCode) Then
                Set FindFieldByCode = oField
                Exit Function
            End If
        End If
    Next
    
End Function

'++**************************************************************************************************************************************
' Description:  Will move the bookmark marking the end of main section to the correct position. This bookmark is used by the field in
'               the footer for page numbers.
' Parameters:   n/a
' Returns:      n/a
'--**************************************************************************************************************************************
Public Sub SetEndOfMainSectionBookmark()
    Dim oRange As Range
    Dim oRangeLand As Range
    Dim sText As String
    Dim bFound As Boolean
    Dim bFoundLand As Boolean

    On Error GoTo ErrorHandler:

    'Need to see if the Bookmark should be at the end of the Main section or before the first Appendix para
    sText = modPrivate.sGetDocVar("HideAppendixPageNo")
    'Need to set the bookmark to before the first Appendix
    If sText = "True" Then
        Set oRange = ActiveDocument.Range
        Set oRangeLand = ActiveDocument.Range
        'First look for the AppendixDivider style
        bFound = False
        If modPrivate.StyleExists(oRange, "Appendix Numb") Then
            bFound = True
            oRange.Collapse
        End If
        If modPrivate.StyleExists(oRangeLand, "Appendix Numb Land") Then
            bFoundLand = True
            oRangeLand.Collapse
        End If

        
        If bFound And bFoundLand Then
            'Now need to see which Appendix style is found first
            If oRangeLand.Start < oRange.Start Then
                Set oRange = oRangeLand.Duplicate
            End If
        ElseIf Not bFound And bFoundLand Then
            'Only the Landscape version found so need to reset the values
            Set oRange = oRangeLand.Duplicate
            bFound = True
        End If

        'A Appendix paragraph is being found so move the range to the end of the previous page
        If bFound Then
            If oRange.Start <= 4 Then
                'If the first occurence of the App Head 1 style is at the very start of the _
                 document, then there cannot be a main section.
                oRange.End = oRange.Start
            Else
                'Move to the preceeding position
                oRange.Start = oRange.End - 1
                oRange.Start = oRange.Start - 4
                oRange.End = oRange.Start
            End If

        Else
            Set oRange = ActiveDocument.Sections(ActiveDocument.Sections.count).Range
            oRange.MoveEnd wdCharacter, -1
            oRange.Collapse wdCollapseEnd
        End If
    Else
        Set oRange = ActiveDocument.Sections(ActiveDocument.Sections.count).Range
        oRange.MoveEnd wdCharacter, -1
        oRange.Collapse wdCollapseEnd

    End If

    oRange.Bookmarks.Add BOOKMARK_END_OF_MAIN_SECTION, oRange
    oRange.Bookmarks.Add "TestBookmark", oRange

    Exit Sub

CleanExit:
    Exit Sub
ErrorHandler:
    modError.DisplayMsg "It's not possible to find the end of main section of the document. The document may be corrupt.", vbCritical, "Document Corrupted"
    Resume CleanExit:
End Sub

Sub InsertField(rRange As Range, sFieldCode, Optional sStyle As String)

    On Error Resume Next

    ActiveWindow.View.ShowFieldCodes = True

    With rRange
        .Fields.Add rRange, wdFieldEmpty, , False
        .Collapse wdCollapseEnd
        .Move wdCharacter, 2
        .InsertAfter sFieldCode

        .Collapse wdCollapseEnd
        .MoveEnd wdCharacter, 2
        .Collapse wdCollapseEnd
        
        If sStyle <> "" Then
            .Style = sStyle
        End If
        
    End With
    ActiveWindow.View.ShowFieldCodes = False

End Sub


Attribute VB_Name = "modGlobal"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modGlobals
'*
'* Holds the global variables and constants
'***********************************************************************************

'***********************************************************************************
'*  V E R S I O N   H I S T O R Y
'***********************************************************************************
'* Version 1.0 - 18 September 2019 Author Alan Cartwright, Brochet ltd
'*                  Inherited from Brochet
'* Version 1.01 - 26 September 2019 Author Alan Cartwright, Brochet ltd
'*                  Ready for testing
'* Version 1.02 - 27 September 2019 Author Alan Cartwright, Brochet ltd
'*                  Ready for release
'* Version 1.03 - 02 October 2019 Author Alan Cartwright, Brochet ltd
'*                  Fixes from Issue list
'* Version 1.04 - 04 October 2019 Author Alan Cartwright, Brochet ltd
'*                  Changed Contact Page - New Graphics and design
'* Version 1.05 - 10 October 2019 Author Alan Cartwright, Brochet ltd
'*                  Fixed Bullet style to line up
'*                  Dialog boxes now appear centred on the Document Window
'* Version 1.07 - 18 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Insert from Excel/PowerPoint ribbon and implementation of Excel Tool
'*                  Bugfix - Insert Image/ShowLinks/InsertEXcel EMF from dialog
'*                  Bugfix - Word Addin correction
'* Version 1.08 - 19 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Improved Handling of ImageDialog and transfer of code from Flyer
'* Version 1.09 - 19 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Changed to 'Condensed' report
'*                  Bugfix - Can no longer delete S1 in a condensed report
'* Version 1.10 - 21 November 2019 Author Alan Cartwright, Brochet ltd
'*                  "Show codes" off on new doc
'*                  Increase Width of Condensed report header
'*                  Set Default font to Arial
'*                  Update Document only updates field and not charts
'* Version 1.11 - 25 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Prevents deletion of Main body section
'* Version 1.12 - 26 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Improved Section deletion
'*                  Change to Condensed report no longer flickers
'* Version 1.13 - 27 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Changes Placeholder autotext to have at least 6.68cm row
'*                  Textual and Button changes to Images and charts group
'*                  Added Custom Colours to the template
'* Version 1.14 - 29 November 2019 Author Alan Cartwright, Brochet ltd
'*                  Added wait cursor to Screen updating
'*                  Allows Chart/Table insertion in Exec summary
'* Version 1.15 - 6 December 2019 Author Alan Cartwright, Brochet ltd
'*                  Allow for <CR> in Disclosures INI
'*                  Reduce size of Cell displaying the Disclosures
'* Version 1.16 - 10 December 2019 Author Alan Cartwright, Brochet ltd
'*                  Unformatted text improved function. pastes properly from Powerpoint
'*                  Pasting from PowerPoint avoids Tables and text
'* Version 1.17 - 13 December 2019 Author Alan Cartwright, Brochet ltd
'*                  Insert from Powerpoint - handles grouped images better
'* Version 1.18 - 16 December 2019 Author Alan Cartwright, Brochet ltd
'*                  Changed the (Body) font to Arial
'* Version 1.19 - 19 December 2019 Author Alan Cartwright, Brochet ltd
'*                  Keep source formatting  whwen pasting from Excel
'*                  Pastes Excel as ChartLinked from PP
'*
'*'***********************************************************************************
Option Explicit

Public Const DEBUG_MODE As Boolean = False

'Versioning and Startup constants
Public Const TEMPLATE_VERSION As String = "1.19"                'DO NOT CHANGE UNLESS NEW VERSION
Public Const TEMPLATE_DATE As String = "19 December 2019"       'DO NOT CHANGE UNLESS NEW VERSION


Public Const INITIAL_TEMPLATE_NAME As String = "InitialTemplateName"
Public Const INITIAL_TEMPLATE_VERSION As String = "InitialTemplateVersion"
Public Const INITIAL_TEMPLATE_DATE As String = "InitialTemplateDate"
Public Const CURRENT_TEMPLATE_NAME As String = "CurrentTemplateName"
Public Const CURRENT_TEMPLATE_VERSION As String = "CurrentTemplateVersion"
Public Const CURRENT_TEMPLATE_DATE As String = "CurrentTemplateDate"

Public Const TEMPLATE_NAME As String = "RFP"

Public Const COMPANY_NAME As String = "Insight Investment"
Public Const COMPANY_NAME_SHORT As String = "Insight"
Public Const COMPANY_NAME_SAFE As String = "Insight"

Public Const COMPANY_INI_FILE_NAME As String = "Insight.ini"
Public Const ERR_MSG_BOX_TITLE As String = "Insight Error Message"

Public Const AUTHORS_INI_FILE_NAME As String = "Brochet Insight Authors List.ini"

'Where the registry settings are saved
Public Const WORD_REG_SETTING As String = COMPANY_NAME & " Template settings"

Public gsItSupport As String 'Holds the name of the entity to contact when there's a problem _
                              with the system. Will be used in error messages
                              
Public gsCompanyIniFileName As String   'Stores company ini file name and path
Public gsAuthorsIniFileName As String
Public gbNewDoc As Boolean
Public gbUpdate As Boolean
Public gbStarterDoc As Boolean
Public gbOfflineMode As Boolean


Public Const TITLEPAGE_IMAGE_ROWNO As Double = "3"
Public Const TITLEPAGE_TEXT_ROWNO As Double = "1"
Public Const INSIDETITLEPAGE_TEXT_ROWNO As Double = "1"
Public Const INSIDETITLEPAGE_FOOTER_NO_OF_COLUMNS As Double = "3"

Public Const A4_PORT_PROPOSAL_TOP_MARGIN As Double = "4.5"
Public Const A4_PORT_PROPOSAL_BOTTOM_MARGIN As Double = "1.4"
Public Const A4_PORT_PROPOSAL_RIGHT_MARGIN As Double = "2"
Public Const A4_PORT_PROPOSAL_LEFT_MARGIN As Double = "7.8"
Public Const A4_PORT_PROPOSAL_HEADER_MARGIN As Double = "1"
Public Const A4_PORT_PROPOSAL_FOOTER_MARGIN As Double = "1"

Public Const A4_PORT_WIDE_TOP_MARGIN As Double = "1.5"
Public Const A4_PORT_WIDE_BOTTOM_MARGIN As Double = "1.5"
Public Const A4_PORT_WIDE_RIGHT_MARGIN As Double = "1.5"
Public Const A4_PORT_WIDE_LEFT_MARGIN As Double = "1.5"
Public Const A4_PORT_WIDE_HEADER_MARGIN As Double = "1.6"
Public Const A4_PORT_WIDE_FOOTER_MARGIN As Double = "0.9"

Public Const A4_LAND_TOP_MARGIN As Double = "1.5"
Public Const A4_LAND_BOTTOM_MARGIN As Double = "1.5"
Public Const A4_LAND_RIGHT_MARGIN As Double = "1.5"
Public Const A4_LAND_LEFT_MARGIN As Double = "1.5"
Public Const A4_LAND_HEADER_MARGIN As Double = "1.6"
Public Const A4_LAND_FOOTER_MARGIN As Double = "0.9"

Public Const A3_PORT_TOP_MARGIN As Double = "3"
Public Const A3_PORT_BOTTOM_MARGIN As Double = "1.4"
Public Const A3_PORT_RIGHT_MARGIN As Double = "2"
Public Const A3_PORT_LEFT_MARGIN As Double = "2"
Public Const A3_PORT_HEADER_MARGIN As Double = "1"
Public Const A3_PORT_FOOTER_MARGIN As Double = "1"

Public Const A3_LAND_TOP_MARGIN As Double = "3"
Public Const A3_LAND_BOTTOM_MARGIN As Double = "1.4"
Public Const A3_LAND_RIGHT_MARGIN As Double = "2"
Public Const A3_LAND_LEFT_MARGIN As Double = "2"
Public Const A3_LAND_HEADER_MARGIN As Double = "1"
Public Const A3_LAND_FOOTER_MARGIN As Double = "1"



Public Const LETTER_PORT_PROPOSAL_TOP_MARGIN As Double = "4.5"
Public Const LETTER_PORT_PROPOSAL_BOTTOM_MARGIN As Double = "1.4"
Public Const LETTER_PORT_PROPOSAL_RIGHT_MARGIN As Double = "2.3"
Public Const LETTER_PORT_PROPOSAL_LEFT_MARGIN As Double = "8.1"
Public Const LETTER_PORT_PROPOSAL_HEADER_MARGIN As Double = "1"
Public Const LETTER_PORT_PROPOSAL_FOOTER_MARGIN As Double = "1"

Public Const LETTER_PORT_WIDE_TOP_MARGIN As Double = "1.5"
Public Const LETTER_PORT_WIDE_BOTTOM_MARGIN As Double = "1.5"
Public Const LETTER_PORT_WIDE_RIGHT_MARGIN As Double = "1.8"
Public Const LETTER_PORT_WIDE_LEFT_MARGIN As Double = "1.8"
Public Const LETTER_PORT_WIDE_HEADER_MARGIN As Double = "1.6"
Public Const LETTER_PORT_WIDE_FOOTER_MARGIN As Double = "0.9"

Public Const LETTER_LAND_TOP_MARGIN As Double = "1.5"
Public Const LETTER_LAND_BOTTOM_MARGIN As Double = "1.5"
Public Const LETTER_LAND_RIGHT_MARGIN As Double = "1.8"
Public Const LETTER_LAND_LEFT_MARGIN As Double = "1.8"
Public Const LETTER_LAND_HEADER_MARGIN As Double = "1.6"
Public Const LETTER_LAND_FOOTER_MARGIN As Double = "0.9"

Public Const LEDGER_LAND_TOP_MARGIN As Double = "3"
Public Const LEDGER_LAND_BOTTOM_MARGIN As Double = "1.4"
Public Const LEDGER_LAND_RIGHT_MARGIN As Double = "2.6"
Public Const LEDGER_LAND_LEFT_MARGIN As Double = "2.6"
Public Const LEDGER_LAND_HEADER_MARGIN As Double = "1"
Public Const LEDGER_LAND_FOOTER_MARGIN As Double = "1"

Public Type BrochetPageMargins
    Top As Double
    Bottom As Double
    Right As Double
    Left As Double
    Header As Double
    Footer As Double
End Type





Private Sub Test()

    modPrivate.SetDocVar "NewDoc", "True"
        'Save header/footer info
    modPrivate.DocVarSet "HeaderDocTitle", "HeaderTitle"
    modPrivate.DocVarSet "HeaderDocDate", "HeaderDate"

    
End Sub
Attribute VB_Name = "modINI"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*
'* Holds various macro code related to ini files
'*  - 05.06.2018 added function to read string value
'*  - 16/07/2018 added function to read bool value
'*  - 23/07/2018 added function to read path value
'*  - 2018 07 23 - Added more parameters to function returning specific type, so the caller can get the raw data and read status
'*  - 2018 07 25 - Will return real raw data from getPathValue
'***********************************************************************************

Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modINI"

Public Const INI_SECTION_JURISDICTION As String = "Jurisdiction"
Public Const INI_KEY_PORTABILITYLANGUAGE As String = "PortabilityLanguageSection"
Public Const INI_SECTION_OFFICES As String = "Offices"


Public Enum EPathGetOption
    CheckFiles = 1
    CheckFolders = 2
    CheckAnything = 3
End Enum

Public Enum EIniReadStatus
    Success
    InvalidValue
    NoValue
    PathNotValid
    CantReadIni
End Enum



'++*******************************************************************
' Description:  Check if the INI file exists
' Parameters:   n/a
' Returns:      Full path to main ini file or empty string if not succesful
'--********************************************************************
Function GetIniFilePath() As String
    On Error GoTo ErrorHandler
    Dim iniFilePath As String
    Dim nfso As ClsNotFileSystemObject
    
    GetIniFilePath = ""
    
    'get ini file from global template.
    If modPublic.GlobalDirectivesSendMessage("GetIniFilePath", iniFilePath) Then
        If modPrivate.FileExists(iniFilePath) Then
            GetIniFilePath = iniFilePath
        End If
    End If
CleanExit:
    Exit Function
ErrorHandler:
    GetIniFilePath = ""
    Resume CleanExit
End Function

'++********************************************************************
' Description:  Reads an ini file key checking if there are
'               continuation keys.
' Parameters:   sSection - Name of the ini file section.
'               sKey - Name of the ini file key.
' Returns:      Result from the ini file.
'--********************************************************************
Public Function IniFileKeyGet(iniFilePath As String, sSection As String, sKey As String) As String
    Dim i As Integer
    Dim sKeyValue As String
    Dim sText As String
    
    sText = System.PrivateProfileString(iniFilePath, sSection, sKey)
    
    i = 2
    Do While LenB(sText) > 0
        IniFileKeyGet = IniFileKeyGet & sText
        sText = System.PrivateProfileString(iniFilePath, sSection, sKey & i)
        i = i + 1
    Loop
End Function

'++********************************************************************
' Description:  Function will try to read ini setting, and only if the
'               read is succesful it'll change the value passed in in
'               value parameter.
' Parameters:   iniFilePath     - Path to ini file
'               section         - Name of the ini file section.
'               key             - Name of the ini file key.
'               value           - This is byref parameter, so it's value
'                                 can be changed in the function.
'                                 it'll only change if the setting read
'                                 from INI file was succesfull
' Returns:      True if the read was successfull, false otherwise
'--********************************************************************
Public Function TryGetIniFileSetting(iniFilePath As String, Section As String, Key As String, ByRef value As String, Optional expand As Boolean = True) As Boolean
    Dim sText As String
        
    TryGetIniFileSetting = False
    sText = System.PrivateProfileString(iniFilePath, Section, Key)
    
    If LenB(sText) > 0 Then
        If expand Then
            value = modPrivate.ExpandString(sText)
        Else
            value = sText
        End If
        
        TryGetIniFileSetting = True
    End If
End Function

'++*******************************************************************
' Description:  Sometimes the settings in ini file hold multiple substring
'               (e.g. list of files) separated with a separator.
'               This function returns values from settings like this
'               in the array of string in byre parameter retArray
' Parameters:   iniFilePath - Full path to ini file
'               iniFileSection - Ini file section for this set.
'               retArray - Array to fill with SUBSTRINGS
'               defaultValue - If ini file setting is not found (or empty)
'                   this value will be used to fill the retArray instead
'               prefix - Prefix that needs to be attached to start of each
'                   substring
'               prefixesToRemove - coma separated list of prefixes that should
'                   be removed from substring if present. This is done before
'                   the prefix is attached
'               separator - separator that separates substring in the setting
' Returns:      Boolean - True if all's OK.
'--********************************************************************
Public Function GetSplitStringIntoArray(iniFilePath As String, iniFileSection As String, Key As String, _
                ByRef retArray() As String, Optional defaultValue As String = vbNullString, _
                Optional prefix As String = "", Optional prefixesToRemove As String, _
                Optional separator As String = ",") As Boolean
    Dim sText As String
    
    On Error GoTo ErrorHandler
    sText = Trim$(System.PrivateProfileString(iniFilePath, iniFileSection, Key))
    
    If sText = vbNullString Then
        retArray = Split(defaultValue, separator)
    Else
        retArray = Split(sText, separator)
    End If
    
    RemovePrefixes prefixesToRemove, retArray
    AddPrefix prefix, retArray
    modPrivate.TrimArray retArray
    
    GetSplitStringIntoArray = True
CleanExit:
    Exit Function
ErrorHandler:
    GetSplitStringIntoArray = False
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Attaches a given prefix to the beggining of each string
'               in retArray.
' Parameters:   prefix  -   prefix to be attached to each string
'               retArray -  Array of string where each substring needs
'                   to have the prefix. This is out parameter
' Returns:      n/a
'--********************************************************************
Private Sub AddPrefix(prefix As String, ByRef retArray() As String)
    Dim i As Integer
    
    For i = LBound(retArray) To UBound(retArray)
        retArray(i) = prefix & retArray(i)
    Next i
End Sub

'++*******************************************************************
' Description:  Removes any prefix from list of prefixes from
'               each string in given array of strings
' Parameters:   prefixesToRemove - coma separated list of prefixes that should
'                   be removed from substring if present.
'               retArray -  Array of string where each substring needs
'                   to not have the prefix. This is out parameter
'
' Returns:      Boolean - True if all's OK.
'--********************************************************************
Private Sub RemovePrefixes(prefixes As String, ByRef retArray() As String)
    Dim aPrefixesToRemove() As String
    Dim i As Integer
    Dim j As Integer
    
    If LenB(prefixes) > 0 Then
        aPrefixesToRemove = Split(prefixes, ",")
        For i = LBound(aPrefixesToRemove) To UBound(aPrefixesToRemove)
            For j = LBound(retArray) To UBound(retArray)
                If Len(retArray(j)) > Len(aPrefixesToRemove(i)) Then
                    If StrComp(Left(retArray(j), Len(aPrefixesToRemove(i))), aPrefixesToRemove(i), vbTextCompare) = 0 Then
                        retArray(j) = Right(retArray(j), Len(retArray(j)) - Len(aPrefixesToRemove(i)))
                    End If
                End If
            Next
        Next
    End If
End Sub

'++*******************************************************************
' Description:  Will return value from ini file as Integer
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetIntValue(iniFilePath As String, Section As String, Key As String, _
                        Optional defaultValue As Integer = 0, Optional ByRef rawData As String, _
                        Optional ByRef iniReadStatus As EIniReadStatus) As Integer
    iniReadStatus = Success
    
    On Error GoTo IniError
    
    rawData = System.PrivateProfileString(iniFilePath, Section, Key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetIntValue = CInt(rawData)
    Else
        GetIntValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetIntValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetIntValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return value from ini file as String
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetStringValue(iniFilePath As String, Section As String, Key As String, _
                            Optional defaultValue As String = "", Optional ByRef rawData As String, _
                            Optional ByRef iniReadStatus As EIniReadStatus) As String
    iniReadStatus = Success
    
    On Error GoTo IniError
    rawData = System.PrivateProfileString(iniFilePath, Section, Key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetStringValue = rawData
    Else
        GetStringValue = defaultValue
        iniReadStatus = NoValue
    End If
CleanExit:
    Exit Function
ErrorHandler:
    GetStringValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetStringValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return value from ini file as Integer
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetBoolValue(iniFilePath As String, Section As String, Key As String, _
                        Optional defaultValue As Boolean = False, Optional ByRef rawData As String, _
                        Optional ByRef iniReadStatus As EIniReadStatus) As Integer
    iniReadStatus = Success
    
    On Error GoTo IniError
    
    rawData = System.PrivateProfileString(iniFilePath, Section, Key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetBoolValue = CBool(rawData)
    Else
        GetBoolValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetBoolValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetBoolValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return value from ini file as Double
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      numeric value from ini file, or defailt value in case
'               or error
'--********************************************************************
Public Function GetDoubleValue(iniFilePath As String, Section As String, Key As String, _
                        Optional defaultValue As Double = 0#, Optional ByRef rawData As String, _
                        Optional ByRef iniReadStatus As EIniReadStatus) As Integer
    iniReadStatus = Success
    
    On Error GoTo IniError
    rawData = System.PrivateProfileString(iniFilePath, Section, Key)
    
    On Error GoTo ErrorHandler
    If LenB(rawData) > 0 Then
        GetDoubleValue = CDbl(rawData)
    Else
        GetDoubleValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetDoubleValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetDoubleValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Will return Path from ini file as String.
' Parameters:   iniFilePath - Full path to ini file
'               section - Section of the ini file containing the value
'               key - Key of the ini file containing the value
'               defaultValue - Value to be returned if reading from
'                   ini file fails
'               rawData - string as read from ini file without any processing
'               iniReadStatus - CAn be used to find out if the ini file
'                       read was actually successful or if default value was
'                       used because something went wrong
' Returns:      Returns path set in ini file, but only if the path exists.
'               otherwise returns default value
'--********************************************************************
Public Function GetPathValue(iniFilePath As String, Section As String, Key As String, Optional defaultValue As String = "", _
                        Optional pathGetOption As EPathGetOption = EPathGetOption.CheckAnything, _
                        Optional ByRef rawData As String, Optional ByRef iniReadStatus As EIniReadStatus) As String
    
    Dim expandedData As String
    
    iniReadStatus = Success
    
    On Error GoTo ErrorHandler
    rawData = System.PrivateProfileString(iniFilePath, Section, Key)
    expandedData = modPrivate.ExpandString(rawData)
    
    If LenB(expandedData) > 0 Then
        If modPrivate.FolderExists(expandedData) And (pathGetOption Or CheckFolders) Then
            GetPathValue = expandedData
        ElseIf modPrivate.FileExists(expandedData) And (pathGetOption Or CheckFiles) Then
            GetPathValue = expandedData
        Else
            GetPathValue = defaultValue
            iniReadStatus = PathNotValid
        End If
    Else
        GetPathValue = defaultValue
        iniReadStatus = NoValue
    End If
    
CleanExit:
    Exit Function
ErrorHandler:
    GetPathValue = defaultValue
    iniReadStatus = InvalidValue
    Resume CleanExit
IniError:
    GetPathValue = defaultValue
    iniReadStatus = CantReadIni
    rawData = ""
    Resume CleanExit
End Function

'++********************************************************************************************************
' Description:  In ini file we may want to use some markup for inserting specific things like
'               paragraph breaks and so on. This will resolve this markups
' Parameters:   sText - String as read from ini file
' Returns:      String where all markup is replaced with what it should be
'--********************************************************************************************************
'TODO check that all required markup is handled
Public Function ResolveINIMarkup(ByVal sText As String) As String
    'TODO currently the string is only expanded (environment variables are expanded), but nothing else
    'Add more markup resolves as needed.
    ResolveINIMarkup = modPrivate.ExpandString(sText)
End Function

'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************

'++*******************************************************************
' Description:  Checks for the existance of critical ini files and
'               structures a return error msg.
' Parameters:   sTags - Tags/Keywords from file's properties.
'               rtn_iIniErrCount - Returned number of missing, critical
'                   ini files. 0=All OK.
'               rtn_sErrNosMsg - Structured start to error message with
'                   right error numbers.
' Returns:      N/A
'--********************************************************************
Sub IniFilesCriticalCheck(sTags As String, rtn_iIniErrCount As Integer, rtn_sErrNosMsg As String)
    Dim sInis() As String
    Dim sGlbPath As String
    Dim sFilenameSuffix As String
    Dim i As Integer
    Dim j As Integer
    
    rtn_sErrNosMsg = vbNullString
    rtn_iIniErrCount = 0
    
    If sTags = vbNullString Then
        'Nothing to do
        Exit Sub
    End If
    
    sInis = Split(sTags, ";")
    GlobalName , sGlbPath, , sFilenameSuffix
    sFilenameSuffix = Space$(1) & sFilenameSuffix & ".ini"
    
    For i = LBound(sInis) To UBound(sInis)
        j = InStrRev(sInis(i), ".")
        If j = 0 Then
            sInis(i) = sInis(i) & "."
            j = InStrRev(sInis(i), ".")
        End If
        sInis(i) = Left$(sInis(i), j - 1) & sFilenameSuffix
        If Not modPrivate.FileExists(sGlbPath & sInis(i)) Then
            'At least one of the critical ini files are missing
            rtn_iIniErrCount = rtn_iIniErrCount + 1
            'rtn_sErrNosMsg = rtn_sErrNosMsg & Switch( _
              sInis(i) = BR_LEGAL_INI_FILE_NAME, 2, _
              sInis(i) = BR_LEGAL_STYLES_INI_FILE_NAME, 3, _
              sInis(i) = BR_LEGAL_ARCHITECTURE_INI_FILE_NAME, 4, _
              sInis(i) = BR_LEGAL_COURT_INI_FILE_NAME, 5) & ", "
            rtn_sErrNosMsg = rtn_sErrNosMsg & "'" & sInis(i) & "', "
        End If
    Next i
    If rtn_iIniErrCount = 1 Then
        rtn_sErrNosMsg = "Missing ini file: " & Left$(rtn_sErrNosMsg, Len(rtn_sErrNosMsg) - 2)
    ElseIf rtn_iIniErrCount > 1 Then
        rtn_sErrNosMsg = Left$(rtn_sErrNosMsg, Len(rtn_sErrNosMsg) - 2)
        i = InStrRev(rtn_sErrNosMsg, ",")
        rtn_sErrNosMsg = Left$(rtn_sErrNosMsg, i - 1) & " and " & Mid$(rtn_sErrNosMsg, i + 2)
        rtn_sErrNosMsg = "Missing ini files: " & rtn_sErrNosMsg
    End If

End Sub




Attribute VB_Name = "modImages"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modImages
'*
'* Holds code for working with images
'***********************************************************************************
Option Explicit
Option Private Module



'++*******************************************************************
' Procedure:    ImageFileGetName
' Description:  Display the Insert Image dialog box and get the name
'               of the file selected
' Parameters:   Optional sImagePage - if used, the default path where
'                   the dialog should start
' Returns:      N/A
'--********************************************************************
Function ImageFileGetName(Optional sImagePath As String = "") As String

    ImageFileGetName = ""

    Dim oDialog As Word.Dialog
    Dim sDefaultDir As String

    'Change the default file path
    If sImagePath <> "" Then
        sDefaultDir = Options.DefaultFilePath(wdPicturesPath)
        Options.DefaultFilePath(wdPicturesPath) = sImagePath
    End If

    'Display the Picture dialog box
    Set oDialog = Dialogs(wdDialogInsertPicture)

    On Error GoTo errbInsertPictureDialog

    With oDialog
        .Display

         'Insert picture if the Name property (Filepath) <> ""
        If .Name <> "" Then
            ImageFileGetName = .Name
        End If

    End With

    Set oDialog = Nothing

    'Set the default image path back to the default place
    If sImagePath <> "" Then
        Options.DefaultFilePath(wdPicturesPath) = sDefaultDir
    End If

    'Switch update screen on
    Application.ScreenUpdating = True

    Exit Function

errbInsertPictureDialog:

    Exit Function

End Function

'++*******************************************************************
' Procedure:    ImageGetAndInsert
' Description:  Allows user to choose an image and insert it into
'               currently selected range
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Sub ImageGetAndInsert()
    Dim sImagePathAndFile As String
    Dim oInlShape As InlineShape

    'Get the image path
    sImagePathAndFile = modImages.ImageFileGetName()
    
    If sImagePathAndFile <> "" Then
        'The macro may be the result of a call from macrobutton. In which case delete it
        If Selection.Fields.count = 1 Then
            If Selection.Fields(1).Type = wdFieldMacroButton Then
                Selection.Fields(1).result.Delete
            End If
        End If
    
        'Insert the image into chosen position
        Set oInlShape = InsertImageIntoRange(sImagePathAndFile, Selection.Range, False, False, True, False, False)
         oInlShape.AlternativeText = sImagePathAndFile
        'Move view to inserted image
        oInlShape.Select
        ActiveDocument.ActiveWindow.ScrollIntoView Selection
        
    End If
End Sub

'++*******************************************************************
' Procedure:    InsertImageIntoRange
' Description:  Inserts image from specified path into specified range
' Parameters:   sImagePathAndFile - Full path to the image to insert
'               oRange - Range where the image should be inserted
'               Optional bLimitHeight - If true, the max height of image will be 25 cm
'               Optional bDownsizeWidth - Default True - If true the image will be resized do to be at most the width of placeholder
'               Optional bUpsizeWidth - Default False - If true the image will be resized do to be at least the width of placeholder
'               Optional bDownsizeHeight - Default True - If True the image will be resized to be at most the height of placeholder
'               Optional bUpsizeHeight - Default False - If True the image will be resized to be at least the height of placeholder
' Returns:      InlineShape object of inserted image or nothing if unsuccessful
'--********************************************************************
Function InsertImageIntoRange(sImagePathAndFile As String, oRange As Range, Optional bLimitHeight As Boolean = True, _
                                Optional bDownsizeWidth As Boolean = True, Optional bUpsizeWidth As Boolean = False, _
                                Optional bDownsizeHeight As Boolean = True, Optional bUpsizeHeight As Boolean = False) As InlineShape
    Dim dWidth As Double
    Dim dHeight As Double
    Dim dRatio As Double
    Dim ilnShape As InlineShape
    Dim oUndoRecord As cUndoRecord
    Set oUndoRecord = New cUndoRecord

    'Set default return value
    Set InsertImageIntoRange = Nothing

    'First check that the file exists. This does not mean that the file is really an image though
    If Dir(sImagePathAndFile) <> "" Then
        'Start recording undo stact
        oUndoRecord.SetName "Inserting Image"

        'Need to insert the file into the placeholder
        'bWidthSet = False
        If oRange.Information(wdWithInTable) Then
            dWidth = oRange.Cells(1).Width - oRange.Cells(1).LeftPadding - oRange.Cells(1).RightPadding
            dHeight = oRange.Cells(1).Height - oRange.Cells(1).TopPadding - oRange.Cells(1).BottomPadding
        Else
            dWidth = 0
            'Need to set the width to be the column width
            If oRange.Sections(1).PageSetup.TextColumns.count > 1 Then
                'Need to get the width of the column
                dWidth = oRange.Sections(1).PageSetup.TextColumns.Width
            Else
                dWidth = oRange.Sections(1).PageSetup.PageWidth - oRange.Sections(1).PageSetup.LeftMargin - oRange.Sections(1).PageSetup.RightMargin
            End If
        End If

        'Now insert the image as an inline shape. This may fail if the file is not an image.
        On Error GoTo ErrorHandler
        Set ilnShape = oRange.InlineShapes.AddPicture(filename:=sImagePathAndFile)

        dRatio = ilnShape.Width / ilnShape.Height

        'Downsize width of image if larger than placeholder
        If ilnShape.Width > dWidth And bDownsizeWidth Then
            ilnShape.Width = dWidth
            ilnShape.Height = ilnShape.Width / dRatio
        End If

        'Upsize width of image if Smaller than placeholder
        If ilnShape.Width < dWidth And bUpsizeWidth Then
            ilnShape.Width = dWidth
            ilnShape.Height = ilnShape.Width / dRatio
        End If

        'Need to see if the height is large enough
        If ilnShape.Height > dHeight And dHeight > 0 And bDownsizeHeight Then
            ilnShape.Height = dHeight
            ilnShape.Width = ilnShape.Height * dRatio
        End If

        'Need to see if the height is large enough
        If ilnShape.Height < dHeight And dHeight > 0 And bUpsizeHeight Then
            ilnShape.Height = dHeight
            ilnShape.Width = ilnShape.Height * dRatio
        End If

        'Need to put an error check that if the image to too tall for the page to make the height smaller
        If ilnShape.Height > CentimetersToPoints(25) And bLimitHeight Then
            ilnShape.Height = CentimetersToPoints(25)
            ilnShape.Width = ilnShape.Height * dRatio
        End If

        'Lock ratio the new picture
        ilnShape.LockAspectRatio = msoTrue

        'Return the image
        Set InsertImageIntoRange = ilnShape
    End If

CleanExit:
    oUndoRecord.EndRecording
    Exit Function

ErrorHandler:
    'image insertion failed for whatever reason. Exit function
    err.Clear
    Resume CleanExit

End Function

'++*******************************************************************
' Procedure:    InsertImageIntoRange
' Description:  Inserts image from specified path into specified range
' Parameters:   sImagePathAndFile - Full path to the image to insert
'               oRange - Range where the image should be inserted
'               Optional bLimitHeight - If true, the max height of image will be 25 cm
'               Optional bDownsizeWidth - Default True - If true the image will be resized do to be at most the width of placeholder
'               Optional bUpsizeWidth - Default False - If true the image will be resized do to be at least the width of placeholder
'               Optional bDownsizeHeight - Default True - If True the image will be resized to be at most the height of placeholder
'               Optional bUpsizeHeight - Default False - If True the image will be resized to be at least the height of placeholder
' Returns:      InlineShape object of inserted image or nothing if unsuccessful
'--********************************************************************
Sub InsertImageIntoDivider(sImagePathAndFile As String, oRange As Range)
    Dim dWidth As Double
    Dim dHeight As Double
    Dim dRatio As Double
    Dim ilnShape As InlineShape
    Dim oUndoRecord As cUndoRecord
    Set oUndoRecord = New cUndoRecord
    Dim sh As Shape

    'Set default return value
    'Set InsertImageIntoDivider = Nothing

    'First check that the file exists. This does not mean that the file is really an image though
    If Dir(sImagePathAndFile) <> "" Then
        'Start recording undo stact
        oUndoRecord.SetName "Inserting Image"
        
        Set ilnShape = oRange.InlineShapes.AddPicture(sImagePathAndFile)
        Set sh = ilnShape.ConvertToShape
        
        sh.Name = "DividerBackgroundGreen"
        sh.WrapFormat.Type = wdWrapBehind
        
        Do Until sh.ZOrderPosition = 1
            sh.ZOrder (msoSendBackward)
        Loop
        
        sh.RelativeHorizontalPosition = wdRelativeHorizontalPositionColumn
        sh.Left = CentimetersToPoints(-10.95)
        sh.RelativeVerticalPosition = wdRelativeVerticalPositionPage
        sh.Top = CentimetersToPoints(0) ' WORD2016 set to -1.2
        sh.LayoutInCell = True
        sh.LockAspectRatio = msoTrue
        sh.Height = CentimetersToPoints(29.7)
        
        If sh.Width < CentimetersToPoints(21) Then
            sh.Width = CentimetersToPoints(21)
        End If
    
        sh.RelativeHorizontalPosition = wdRelativeHorizontalPositionColumn
        sh.Left = CentimetersToPoints(-10.95)
        sh.RelativeVerticalPosition = wdRelativeVerticalPositionPage
        sh.Top = CentimetersToPoints(0) ' WORD2016 set to -1.2
        

        'Lock ratio the new picture
        ilnShape.LockAspectRatio = msoTrue

        'Return the image
        'Set InsertImageIntoDivider = sh
    End If

CleanExit:
    oUndoRecord.EndRecording
    Exit Sub

ErrorHandler:
    'image insertion failed for whatever reason. Exit function
    err.Clear
    Resume CleanExit

End Sub


Public Sub ShowImageDialog()

    ShowFrmInsertImage
    
End Sub
Attribute VB_Name = "modInsertImage"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modInsertImage
'*
'* Displays the Insert Image dialog
'*
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modInsertImage"

Sub MacroInsertExcelOrShowFrmInsertImage(Optional bUndoOnCancel As Boolean = False)

    On Error GoTo ErrorHandler
    
    Dim oExcel As Object
    Dim oUndoRecord As cUndoRecord
    Dim oForm As frmInsertImage
    Dim lButton As Long
    
    lButton = 0
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Insert Image"
    
    Selection.Delete

    Set oExcel = GetExcelChart

    If oExcel Is Nothing Then
        Set oForm = New frmInsertImage
        oForm.Show
        lButton = oForm.Tag
        Unload oForm
        Set oForm = Nothing
    Else
        InsertExcelChart oExcel, False, True
    End If
    
    
CleanExit:
    oUndoRecord.EndRecording
    If lButton = 1 And bUndoOnCancel Then
        ActiveDocument.Undo
    End If
    Exit Sub
ErrorHandler:
    'Error applying style. Do nothing
    Resume CleanExit
End Sub

Sub ShowFrmInsertImage()

    On Error GoTo ErrorHandler
    
    Dim oUndoRecord As cUndoRecord
    Dim oForm As frmInsertImage

    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Insert Image"

    Set oForm = New frmInsertImage
    oForm.Show
    Unload oForm
    Set oForm = Nothing

CleanExit:
    oUndoRecord.EndRecording

    Exit Sub
ErrorHandler:
    'Error applying style. Do nothing
    Resume CleanExit
End Sub


Attribute VB_Name = "modLinkToPrevious"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modLinkedToPrevious
'*
'* Holds code for setting LinkToPrevious. This should be used as there is a timing
'* (well, we think it's timing) issue which means that sometimes it needs to be set
'* more than once for it to take effect.
'***********************************************************************************
Option Explicit
Option Compare Text   'Makes text compares case insensitive

Const msMODULE As String = "modLinkToPrevious"

Enum brHdrOrFtr
    HeadersOnly = 1
    FootersOnly = 2
    HeadersAndFooters = 3
End Enum

Enum brHdrFtrType
    Primary = 1
    FirstPage = 2
    EvenPages = 3
End Enum

'++*******************************************************************
' Procedure:    LinkToPreviousSet
' Author:       Brochet ltd
' Description:  Sets headers or footers or both to linked or unlinked
' Parameters:   iSecNo = Section number to have its Headers/Footers changed
'               iHdrFtr = HeaderOnly, FootersOnly or HeadersAndFooters to change
'               iHdrFtrType = Which elements to set
'               bLinked = To what to set it
' Returns:      n/a
'--********************************************************************
Public Sub LinkToPreviousSet(iSecNo As Integer, iHdrFtr As brHdrOrFtr, iHdrFtrType As brHdrFtrType, bLinked As Boolean)
    'iHdrFtrType can be a combination e.g. if you wish to only change Primary headers/footers, use 'Primary'. _
     If you wish to change both 1st page and primary headers/footer, use 'FirstPage + Primary'

    Dim iHdrFtrTypeCnt As Integer
    Dim iHdrOrFtrCnt As Integer
    Dim sSecHdrsFtrs As HeadersFooters
    Dim bIsSetAsDesired(1 To 3) As Boolean
    Dim bHdrsAllSetOK As Boolean
    Dim bFtrsAllSetOK As Boolean
    
    If iSecNo = 1 Then
        'Can't set linked property for the first section (there are no previous sections)
        Exit Sub
    End If
    
    If iHdrFtr = 0 Then
        'Check something's been selected
                
        modError.GlobalErrorHandler 0, "No Headers or Footers specified.", msMODULE, "LinkToPreviousSet"
        Exit Sub
    
    ElseIf iHdrFtr = 0 Or iHdrFtrType = 0 Then
        'Check something's been selected
    
        modError.GlobalErrorHandler 0, "No Headers/Footers TYPE specified.", msMODULE, "LinkToPreviousSet"
        Exit Sub
    
    End If
    
    Do
    
        'Assume all is set as desired
        bHdrsAllSetOK = True
        bFtrsAllSetOK = True
        
        For iHdrOrFtrCnt = 1 To 2
            'Loop through once for headers and once for footers
        
            Set sSecHdrsFtrs = Nothing
        
            If iHdrOrFtrCnt = 1 And (iHdrFtr And iHdrOrFtrCnt) Then
                'Have Headers been requested
            
                Set sSecHdrsFtrs = ActiveDocument.Sections(iSecNo).Headers
                
            ElseIf iHdrFtr And iHdrOrFtrCnt Then
                'Have Footers been requested
            
                Set sSecHdrsFtrs = ActiveDocument.Sections(iSecNo).Footers
                
            End If
            
            If Not sSecHdrsFtrs Is Nothing Then
                'Perhaps only headers or footers chosen
            
                For iHdrFtrTypeCnt = 1 To 3
                    'Assume all header/footer types set as desired
                    
                    bIsSetAsDesired(iHdrFtrTypeCnt) = True
                    
                Next iHdrFtrTypeCnt
                
                For iHdrFtrTypeCnt = 1 To 3
                    'For each type of header/footer
                    
                    If iHdrFtrType And Choose(iHdrFtrTypeCnt, Primary, FirstPage, EvenPages) Then
                    
                        'First set whether it is already as desired
                        bIsSetAsDesired(iHdrFtrTypeCnt) = sSecHdrsFtrs(Choose(iHdrFtrTypeCnt, wdHeaderFooterPrimary, wdHeaderFooterFirstPage, wdHeaderFooterEvenPages)).LinkToPrevious = bLinked
                        
                        If Not bIsSetAsDesired(iHdrFtrTypeCnt) Then
                            'If not as desired, set it
                            zLinkToPreviousSetAndTest sSecHdrsFtrs(Choose(iHdrFtrTypeCnt, wdHeaderFooterPrimary, wdHeaderFooterFirstPage, wdHeaderFooterEvenPages)), bLinked, iSecNo
                        End If
                        
                    End If
                
                Next iHdrFtrTypeCnt
                    
                'Now set a switch for both hdrs and ftrs to say if all WAS set as desired before this loop. _
                 If it wasn't, the loop will be repeated. This is because there is a strange bug in Word _
                 which looks like a timing issue when setting LinkedToPrevious. NOTE: If you step through _
                 setting LinkedToPrevious, it will work first time, let the program go at its own pace _
                 it can fail.
                If iHdrOrFtrCnt = 1 Then
                    bHdrsAllSetOK = bIsSetAsDesired(1) And bIsSetAsDesired(2) And bIsSetAsDesired(3)
                Else
                    bFtrsAllSetOK = bIsSetAsDesired(1) And bIsSetAsDesired(2) And bIsSetAsDesired(3)
                End If
            
            End If
            
        Next iHdrOrFtrCnt
    
    'Keep going through the whole process until all is set as desired
    Loop Until bHdrsAllSetOK And bFtrsAllSetOK
    
    'Clean up
    Set sSecHdrsFtrs = Nothing
        
End Sub

'++*******************************************************************
' Procedure:    zLinkToPreviousSetAndTest
' Author:       Brochet Ltd
' Description:  Sets LinkToPrevious and tests it has been set successfully
'               as there is an issue that, sometimes, the setting needs
'               to be performed more than once.
' Parameters:   hfHdrFtr-Header/Footer section to be set
'               bLinkToPrevious-The setting to which the header/footer
'               should be set.
' Returns:      N/A
'--********************************************************************
Private Sub zLinkToPreviousSetAndTest(hfHdrFtr As HeaderFooter, bLinkToPrevious As Boolean, iSecNo As Integer)

    Dim iLoopCnt As Integer
    Dim oRng As Range
    Dim oDoc As Document
    
    'iLoopCnt = 1
    Do
        If iLoopCnt > 3 Then
            'If it's been tried once and failed, make an adjustment to the document which, in all our testing, _
             will 'unblock' things and then allow the LinkToPrevious to be set. Once it's been done, undo _
             that adjustment.
            Set oRng = ActiveDocument.Sections(iSecNo).Range
            oRng.Collapse wdCollapseStart
            oRng.InsertParagraph

            hfHdrFtr.LinkToPrevious = bLinkToPrevious

            oRng.Delete
        Else
            hfHdrFtr.LinkToPrevious = bLinkToPrevious
        End If
        
        'Debug.Print iLoopCnt
        
        DoEvents
        
        iLoopCnt = iLoopCnt + 1
        If iLoopCnt = 51 Then
            Exit Do
        End If
        
    Loop Until hfHdrFtr.LinkToPrevious = bLinkToPrevious
    
    If iLoopCnt > 20 Then
        MsgBox "Please inform IT that 'zLinkToPreviousSetAndTest' has looped more than 20 times.", _
          vbExclamation, COMPANY_NAME_SHORT & " - Set LinkedToPrevious"
    End If
    
End Sub

Attribute VB_Name = "modMicrosoftExcelChart"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modExcelchart
'*
'* Holds various macro code related to fields
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modExcelchart"



Sub InsertExcelChartOnly(Optional bFormat As Boolean = True, Optional bEMF As Boolean = False)

    Dim oExcel As Object

    On Error GoTo err

    Set oExcel = GetExcelObject

    If Not oExcel Is Nothing Then
        If Not oExcel.ActiveChart Is Nothing Then
            InsertExcelChart oExcel, bEMF, bFormat
        Else
            modError.DisplayMsg "Please select a chart to insert"
        End If
    Else
        modError.DisplayMsg "Excel is not running. Open Excel and highlight the chart to insert"
        
    End If
 
clean:
    Exit Sub
 
err:
 
    modError.DisplayMsg "Please make sure Excel is running and you have selected a Chart."
 
    Resume clean
 
 
End Sub


Function GetExcelChart() As Object
    'Return an Excel object if a chart is selected
    'Returns nothing if excel is open but no chart is selected
    Dim oExcel As Object

    On Error GoTo err

    Set oExcel = GetExcelObject

    If Not oExcel Is Nothing Then
        If Not oExcel.ActiveChart Is Nothing Then
            Set GetExcelChart = oExcel

        End If
    End If
 
clean:
    Exit Function
 
err:
 
 
    Resume clean
 
 
End Function

'++*******************************************************************
' Procedure:    InsertExcelChart
' Author:       Brochet Ltd
' Description:  Insert the selected Excel chart into the document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Function InsertExcelChart(oExcel As Object, Optional bInsertAsEMF As Boolean = False, Optional bFormat As Boolean = True) As Boolean

    Dim dWidth As Double
    Dim dTable As Boolean
    Dim dRatio As Double
    Dim dImageHeight As Double
    Dim sShape As InlineShape
    Dim oUndoRecord As cUndoRecord
    
    If Not IsOperationOkToDo("Insert Chart", EnsureNothingSelected + NotInFrame + NotInContentControl + NotInFtOrEndNote + NotInHdrOrFtr + NotInProtectedSection) Then
        Exit Function
    End If
    
    modScreenUpdating.ScreenUpdating_Disable
    
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Insert Excel Chart"
    
    On Error GoTo err

    'Need to get the width of the chart
    If Selection.Information(wdWithInTable) Then
        'In a table and need to get the cell width
        dWidth = Selection.Cells.Width - Selection.Cells(1).LeftPadding - Selection.Cells(1).RightPadding
        dTable = True
    Else
        'Need to set the width to be the column width
        If Selection.PageSetup.TextColumns.count > 1 Then
            'Need to get the width of the column
            dWidth = Selection.PageSetup.TextColumns.Width
            
        Else
            dWidth = Selection.PageSetup.PageWidth - Selection.PageSetup.LeftMargin - Selection.PageSetup.RightMargin
        End If
        dTable = False
    End If
                

    
    If bInsertAsEMF Then
        oExcel.ActiveChart.CopyPicture Appearance:=xlPrinter, Size:=xlScreen, Format:=xlPicture
        Selection.PasteSpecial placement:=wdInLine, dataType:=wdPasteEnhancedMetafile
    Else
        oExcel.ActiveChart.ChartArea.Copy
        If bFormat Then
            Selection.Paste ' inherits document colours
        Else
            Selection.PasteAndFormat wdFormatOriginalFormatting ' keeps colour
        End If
    End If
    
    
    'Resize object if in a table
    If dTable Then
        Set sShape = Selection.Cells(1).Range.InlineShapes(1)
    Else
        Selection.MoveLeft Unit:=1, Extend:=True
        Set sShape = Selection.InlineShapes(1)
    End If
    
    
    If Not sShape Is Nothing Then
        With sShape
            If .Type = wdInlineShapePicture Then
                .AlternativeText = oExcel.ActiveWorkbook.FullName & vbCrLf & "Sheet :" & oExcel.ActiveSheet.Name
            ElseIf .Type = wdInlineShapeChart Then
                .AlternativeText = "Chart inserted using Brochet Excel Tool"
            End If
            dRatio = .Width / .Height
            
            'Make sure the iimage is the full width
            .Width = dWidth
            .Height = .Width / dRatio
            .LockAspectRatio = True
        End With
        
        If bFormat Then
            sShape.Select
            modBrochetChartTool.ReformatChart "RFP"
        End If
    End If
    
    InsertExcelChart = True
    
clean:
    oUndoRecord.EndRecording
    modScreenUpdating.ScreenUpdating_Enable
    Exit Function
    
err:
    oUndoRecord.EndRecording
    modError.DisplayMsg "There is a problem inserting an object at this location. Please move your cursor to an empty paragraph.", vbCritical
    InsertExcelChart = False
    Resume clean
    
End Function

Private Function ReformatChart(template As String) As Integer
    Dim clsBrochetAPI As cAddinAPI
    Set clsBrochetAPI = New cAddinAPI
    If clsBrochetAPI.isReady Then
        ReformatChart = clsBrochetAPI.RunOperation("ReformatWordChart", template)
    End If
End Function
 

 
 '++*******************************************************************
' Procedure:    ExcelObjectExists
' Author:       Brochet Ltd
' Description:  Check to see if Excel is currently open.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Function ExcelObjectExists() As Boolean
    
    Dim objExcel As Object
    
    ExcelObjectExists = False
    On Error Resume Next
    
    Set objExcel = GetObject(, "Excel.Application")
    
    If err = 0 Then
        ExcelObjectExists = True
    End If
    
End Function

 '++*******************************************************************
' Procedure:    ExcelObjectExists
' Author:       Brochet Ltd
' Description:  Check to see if Excel is currently open.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Function GetExcelObject() As Object
    
    On Error Resume Next
    
    Set GetExcelObject = GetObject(, "Excel.Application")
    
    
End Function

Attribute VB_Name = "modMicrosoftPowerPoint"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPowerPoint
'*
'* Holds various macro code related to fields
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modPowerPoint"





'++*******************************************************************
' Procedure:    PowerPointObjectExists
' Author:       Brochet Ltd
' Description:  Check to see if PowerPoint is currently open.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Function PowerPointObjectExists() As Boolean
    
    Dim objPPoint As Object
    
    PowerPointObjectExists = False
    On Error Resume Next
    
    Set objPPoint = GetObject(, "PowerPoint.Application")
    
    If err = 0 Then
        PowerPointObjectExists = True
    End If
    
End Function


Sub InsertPowerPointObjectOnly(bPasteEMF As Boolean, bFormat As Boolean)

    Dim oPowerPoint As Object

    On Error GoTo err

    Set oPowerPoint = GetPowerPointObject

    If Not oPowerPoint Is Nothing Then
        If oPowerPoint.Presentations.count >= 1 Then
            If oPowerPoint.ActiveWindow.Selection.Type = 2 Then
                If oPowerPoint.ActiveWindow.Selection.ShapeRange.count = 1 Then
                    InsertPowerPointObject oPowerPoint, bPasteEMF, bFormat
                Else
                    modError.DisplayMsg "There are too many objects selected in PowerPoint!"
                End If
            Else
                modError.DisplayMsg "Please select an object in PowerPoint!"
            End If
        Else
            modError.DisplayMsg "Please select an object in PowerPoint!"
        End If
    Else
        modError.DisplayMsg "PowerPoint is not running. Open PowerPoint and highlight an object to insert"
        
    End If
 
clean:
    Exit Sub
 
err:
 
    modError.DisplayMsg "Please make sure PowerPoint is running and you have selected an object."
 
    Resume clean


End Sub

'++*******************************************************************
' Procedure:    InsertPowerPointChart
' Author:       Brochet Ltd
' Description:  Insert the selected PowerPoint chart object into the document
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Private Function InsertPowerPointObject(oPowerPoint As Object, Optional bInsertAsEMF As Boolean = False, Optional bFormat As Boolean = True) As Boolean

    Dim dWidth As Double
    Dim dTable As Boolean
    Dim dRatio As Double
    Dim dImageHeight As Double
    Dim silShape As InlineShape
    Dim sShape As Shape
    Dim oUndoRecord As cUndoRecord
    Dim bExcelChart As Boolean
    Dim bSmartArt As Boolean
    Dim bTable As Boolean
    Dim bTextFrame As Boolean
    Dim rInsertedObject As Range
    
    If Not IsOperationOkToDo("Insert Chart", EnsureNothingSelected + NotInFrame + NotInContentControl + NotInFtOrEndNote + NotInHdrOrFtr + NotInProtectedSection) Then
        Exit Function
    End If
    
    modScreenUpdating.ScreenUpdating_Disable
    
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Insert PowerPoint Chart"
    
    On Error GoTo err

    'Need to get the width of the chart
    If Selection.Information(wdWithInTable) Then
        'In a table and need to get the cell width
        dWidth = Selection.Cells.Width - Selection.Cells(1).LeftPadding - Selection.Cells(1).RightPadding
        dTable = True
    Else
        'Need to set the width to be the column width
        If Selection.PageSetup.TextColumns.count > 1 Then
            'Need to get the width of the column
            dWidth = Selection.PageSetup.TextColumns.Width
        Else
            dWidth = Selection.PageSetup.PageWidth - Selection.PageSetup.LeftMargin - Selection.PageSetup.RightMargin
        End If
        dTable = False
    End If

    If oPowerPoint.ActiveWindow.Selection.Type <> 2 Then 'ppSelectionShapes
        err.Raise 513
    End If

    With oPowerPoint.ActiveWindow.Selection.ShapeRange
        bExcelChart = .HasChart = msoTrue
        bTable = .HasTable = msoTrue
        bTextFrame = .HasTextFrame = msoTrue
    End With

    If bTable Or bTextFrame Then
        err.Raise 513
    End If
    
    ' chart has been selected copy and paste
    oPowerPoint.ActiveWindow.Selection.Copy

    Set rInsertedObject = Selection.Range
    
    If bInsertAsEMF Then
        rInsertedObject.PasteSpecial placement:=wdInLine, dataType:=wdPasteEnhancedMetafile
    ElseIf bExcelChart Then
        If bFormat Then
            rInsertedObject.Paste ' inherits document colours
        Else
            rInsertedObject.PasteAndFormat wdChartLinked 'wdFormatOriginalFormatting ' keeps colour
            rInsertedObject.MoveEnd wdCharacter, 1
        End If
    Else
        
        If bFormat Then
            rInsertedObject.Paste ' inherits document colours
        Else
            rInsertedObject.PasteAndFormat wdFormatOriginalFormatting ' keeps colour
        End If
        
        rInsertedObject.MoveEnd wdCharacter, 1
        If rInsertedObject.ShapeRange.count > 0 Then
            rInsertedObject.ShapeRange(1).ConvertToInlineShape
            Set sShape = rInsertedObject.ShapeRange(1)
        End If
    End If
    
    
    If rInsertedObject.InlineShapes.count > 0 Then
        Set silShape = rInsertedObject.InlineShapes(1)
    End If
        
   
    If Not silShape Is Nothing Then silShape.Select
    
    If bFormat And bExcelChart Then
        modBrochetChartTool.ReformatChart "RFP"
    End If
        
     If Not sShape Is Nothing Then
        With sShape
            .AlternativeText = oPowerPoint.ActivePresentation.FullName & vbCrLf & "Slide :" & oPowerPoint.ActiveWindow.View.Slide.slideindex
            
            dRatio = .Width / .Height
            .Width = dWidth
            .Height = .Width / dRatio
            .LockAspectRatio = True
        End With
    End If
        
    If Not silShape Is Nothing Then
        With silShape
            .AlternativeText = oPowerPoint.ActivePresentation.FullName & vbCrLf & "Slide :" & oPowerPoint.ActiveWindow.View.Slide.slideindex
            
            dRatio = .Width / .Height
            .Width = dWidth
            .Height = .Width / dRatio
            .LockAspectRatio = True
        End With
    End If

    InsertPowerPointObject = True
    
clean:
    oUndoRecord.EndRecording
    modScreenUpdating.ScreenUpdating_Enable
    Exit Function
    
err:
    
    Select Case err.Number
    Case 513
        modError.DisplayMsg "This tool can only paste Charts, Smart Art and Shapes", vbCritical
    Case Else
        modError.DisplayMsg "There is a problem inserting from PowerPoint", vbCritical
    End Select
    
    InsertPowerPointObject = False
    Resume clean


End Function




 '++*******************************************************************
' Procedure:    PowerPointObjectExists
' Author:       Brochet Ltd
' Description:  Check to see if Excel is currently open.
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Function GetPowerPointObject() As Object
    
    On Error Resume Next
    
    Set GetPowerPointObject = GetObject(, "PowerPoint.Application")
    
    
End Function


Attribute VB_Name = "modPages"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modPages
'*
'* Holds various macro code for inserting pages and sections
'***********************************************************************************

Option Explicit
Option Private Module 'makes all macros private to this module
Option Compare Text

Const msMODULE As String = "modPages"

Public Const PAGEID_TitlePage As String = "BrochetTitlePageSection"
Public Const PAGEID_PortabilityLanguagePage As String = "BrochetPortabilityLanguagePageTable"
Public Const PAGEID_ExecutiveSummary As String = "BrochetExecutiveSummarySection"
Public Const PAGEID_TOC As String = "BrochetTOCSection"


Public Enum Brochet_PAGE_TYPE
    A4PROPOSAL = 1
    A4WIDE = 2
    A4LANDSCAPE = 4
    A3LANDSCAPE = 8
    LETTERPROPOSAL = 16
    LETTERWIDE = 32
    LETTERLANDSCAPE = 64
    LEDGERLANDSCAPE = 128
    TYPE_OTHER = 256
End Enum
Public Const testtttt As String = "test"



Sub NewSectionButtonPress()

    Dim sText As String

    'Check that in the correct place in the document to insert a new section
    sText = modPublic.isOkToInsertNewSection("section (page layout)")
    If sText = "True" Then
        frmNewSection.Show
    Else
        MsgBox sText, vbInformation, "Insert New Section (page layout)"
    End If

End Sub

Sub NewPlaceholderButtonPress()

    Dim sText As String

    'Check that in the correct place in the document to insert a new section
    'sText = modPublic.isOkToInsertNewSection("placeholder")
    If IsInEditableSection(Selection.Range) Then
        frmPlaceholderInsert.Show
    Else
       modError.DisplayMsg "A Placeholder cannot be inserted into a protected section such as the Title page or Contents.", vbInformation, "Insert New placeholder"
    End If

End Sub

'++*******************************************************************
' Procedure:    InsertNewPPage
' Author:       Brochet ltd
' Description:  Inserts a New Portrait page
' Parameters:   bCurrLoc - Boolean to denote if the insert is at the
'               present location in the document.
'               sOrientation -Portrait Or Landscape
'               sPageSize - A3 or A4
' Returns:      N/A
'--********************************************************************
Function InsertNewSection(bCurrLoc As Boolean, iPageType As Brochet_PAGE_TYPE, bNewPageSection As Boolean, Optional bNewText As Boolean = True) As Boolean

    Dim iNewSecNo As Integer
    Dim iOldSecNo As Integer
    Dim bOneSecOnly As Boolean
    Dim iPageSize As Integer
    Dim bCurrSecPort As Boolean
    Dim bFollowingSecPort As Boolean
    Dim bNewSecPort As Boolean
'    Dim nParaNo As Integer
''    Dim bA4Size As Boolean
    Dim CurrentSectionType As Brochet_PAGE_TYPE
    Dim FollowingSectionType As Brochet_PAGE_TYPE
    Dim newSectionType As Brochet_PAGE_TYPE
    Dim iOrientation As Integer
    Dim PageMargins As BrochetPageMargins

    On Error GoTo InsertNewSectionErr


    'Make a note of the page oriention of the current section
    bCurrSecPort = True
    bFollowingSecPort = True
    
    If Selection.PageSetup.Orientation = wdOrientLandscape Then
        bCurrSecPort = False
        bFollowingSecPort = False
    End If
    
    AdjustInsertionPointStart
    
    
    
    'Need to see if there is a following section orientation is Portrait
    iOldSecNo = Selection.Information(wdActiveEndSectionNumber)
    
    CurrentSectionType = GetPageType(iOldSecNo)
    
    If Not bCurrLoc Then
        If iOldSecNo < ActiveDocument.Sections.count Then
            bFollowingSecPort = (ActiveDocument.Sections(iOldSecNo + 1).PageSetup.Orientation = wdOrientPortrait)
            FollowingSectionType = GetPageType(iOldSecNo + 1)
        End If

    End If


    'If not at the current location then need to move to the end of the current section
    If Not bCurrLoc Then

        'Need to move to the end of the current section
        ActiveDocument.Sections(iOldSecNo).Range.Select
        Selection.Collapse wdCollapseEnd
        If iOldSecNo < ActiveDocument.Sections.count Then Selection.MoveLeft Unit:=wdCharacter, count:=1

        bOneSecOnly = True
    Else
        'Need to see if at the very end of the document and therefore if only one section break needs to be inserted
        bOneSecOnly = False
        If Selection.End = ActiveDocument.Content.End - 1 Then bOneSecOnly = True
    End If

    'Insert para and new section
    
    Selection.InsertAfter " " 'Prevent an error when selection is next to a ContentControl
    
    If bNewPageSection Then
        Selection.InsertBreak Type:=wdSectionBreakNextPage
    Else
        Selection.InsertBreak Type:=wdSectionBreakContinuous
    End If

    'Get the new section number
    iNewSecNo = Selection.Information(wdActiveEndSectionNumber)
    
    'Clean up additional space
    If Selection.Paragraphs(1).Range.Characters(1) = " " Then
        Selection.Paragraphs(1).Range.Characters(1).Delete
    End If
    
    If bNewText Then
        Selection.TypeText "New section"
        Selection.Style = wdStyleNormal
        Selection.TypeText vbCr
    End If

    'Turn off the First Page - just in case
    ActiveDocument.Sections(iNewSecNo).PageSetup.DifferentFirstPageHeaderFooter = False

    'Need to make sure the page numbering is set to continue from last section
    With ActiveDocument.Sections(iNewSecNo).Headers(wdHeaderFooterPrimary).PageNumbers
        .RestartNumberingAtSection = False
    End With


    If Not bOneSecOnly Then
        If bNewPageSection Then
            Selection.InsertBreak Type:=wdSectionBreakNextPage
        Else
            Selection.InsertBreak Type:=wdSectionBreakContinuous
        End If
    End If

    If Selection.Paragraphs(1).Range.Characters(1) = vbCr Then
        'Clears additional CR
        Selection.Paragraphs(1).Range.Characters(1).Delete
    End If
    
    bNewSecPort = True
    
    
    'Set the page
    If SetPagesize(ActiveDocument.Sections(iNewSecNo), iPageType) = False Then
        InsertNewSection = False
        Exit Function
    End If
    
    newSectionType = GetPageType(iNewSecNo)
    
    'Unlink the headers
    If iNewSecNo <= ActiveDocument.Sections.count And Not bOneSecOnly Then
        modLinkToPrevious.LinkToPreviousSet iNewSecNo + 1, HeadersAndFooters, Primary, False
    End If
        
    modLinkToPrevious.LinkToPreviousSet iNewSecNo, HeadersAndFooters, Primary, False
    
    'Insert Header
    Dim rNewSectionHeader As Range
    Dim rNewSectionFooter As Range
    Set rNewSectionHeader = ActiveDocument.Sections(iNewSecNo).Headers(wdHeaderFooterPrimary).Range
    Set rNewSectionFooter = ActiveDocument.Sections(iNewSecNo).Footers(wdHeaderFooterPrimary).Range
'    Select Case ActiveDocument.Sections(iNewSecNo).PageSetup.PaperSize
    Select Case newSectionType
    Case A4PROPOSAL, LETTERPROPOSAL
        InsertAutotext "z_HeaderA4Proposal", rNewSectionHeader, True, True
        InsertAutotext "z_FooterA4Proposal", rNewSectionFooter, True, True
    Case A4WIDE, LETTERWIDE
        InsertAutotext "z_HeaderA4Port", rNewSectionHeader, True, True
        InsertAutotext "z_FooterA4Port", rNewSectionFooter, True, True
    Case A4LANDSCAPE, LETTERLANDSCAPE
        InsertAutotext "z_HeaderA4Land", rNewSectionHeader, True, True
        InsertAutotext "z_FooterA4Land", rNewSectionFooter, True, True
    Case A3LANDSCAPE, LEDGERLANDSCAPE
        InsertAutotext "z_HeaderA3Land", rNewSectionHeader, True, True
        InsertAutotext "z_FooterA3Land", rNewSectionFooter, True, True
    End Select

    'Now select the first paragraph in the new section
    ActiveDocument.Sections(iNewSecNo).Range.Paragraphs(1).Range.Select

    InsertNewSection = True

InsertNewSectionExit:

    Exit Function

InsertNewSectionErr:


    InsertNewSection = False
    modError.GlobalErrorHandler err, Error, msMODULE, "InsertNewSection"
    Resume InsertNewSectionExit

End Function



Function AdjustInsertionPointStart(Optional rRange As Range = Nothing) As Boolean

    'If the insertion point is not at the end then move to the beginning
    If rRange Is Nothing Then
        Set rRange = Selection.Range
    End If
    
    rRange.Collapse wdCollapseStart
    
    If rRange.Start < rRange.Paragraphs(1).Range.End - 1 Then
        rRange.Start = rRange.Paragraphs(1).Range.Start
        rRange.Collapse wdCollapseStart
        rRange.Select
        AdjustInsertionPointStart = True
    End If
    

End Function



'++*******************************************************************
' Procedure:    InsertDivider
' Description:  Calls user form to insert divider page
' Parameters:   n/a
' Returns:      n/a
'--********************************************************************
Sub InsertDivider()

    Dim rRange As Range

    'Select the whole paragraph
    Set rRange = Selection.Paragraphs(1).Range
    
    ActiveDocument.AttachedTemplate.AutoTextEntries("z_DividerPage").Insert Where _
        :=rRange, richtext:=True
        
    'Select the bookmark
    If ActiveDocument.Bookmarks.Exists("bmkDividerTitle") Then
        ActiveDocument.Bookmarks("bmkDividerTitle").Select
        ActiveDocument.Bookmarks("bmkDividerTitle").Delete
    End If

End Sub

'++*******************************************************************
' Procedure:    InsertTitlePgImage
' Description:  Inserts a new Title image
' Parameters:   sImgPath - Path of image
' Returns:      n/a
'--********************************************************************
Sub InsertTitlePgImage(sImgNameandPath As String, bFullbleed As Boolean)
    
    Dim rRange As Range
    Dim sh As Shape
    Dim ilSh As InlineShape
    Dim sFullImagePathAndName As String
    Dim tTable As Table
    Dim cCell As Cell

        sFullImagePathAndName = sImgNameandPath
        If Not modPrivate.FileExists(sFullImagePathAndName) Then
            MsgBox "The image file '" & sFullImagePathAndName & " cannot be found!", _
                vbInformation, COMPANY_NAME_SHORT & " - Add title page image"
            Exit Sub
        End If

        'Delete any existing image
        Set rRange = ActiveDocument.Sections(1).Footers(wdHeaderFooterPrimary).Range
        rRange.Delete
        rRange.Collapse
        
        rRange.Style = "NormalNoSpace"
        'Also delete any image from the Title page table
    
        'ONly insert a new image if not the default image
        Set ilSh = rRange.InlineShapes.AddPicture(sFullImagePathAndName)
        Set sh = ilSh.ConvertToShape
        
        sh.Name = "TitlePageImage"
        sh.WrapFormat.Type = wdWrapBehind
        
        Do Until sh.ZOrderPosition = 1
            sh.ZOrder (msoSendBackward)
        Loop
        
        sh.RelativeHorizontalPosition = wdRelativeHorizontalPositionPage
        sh.Left = CentimetersToPoints(4)
        sh.RelativeVerticalPosition = wdRelativeVerticalPositionPage
        sh.Top = CentimetersToPoints(16)
        sh.LayoutInCell = True
        sh.LockAspectRatio = msoTrue
        sh.Height = CentimetersToPoints(10)
        

    
    Set ilSh = Nothing
    Set sh = Nothing
    Set rRange = Nothing
    
End Sub

'++*******************************************************************
' Procedure:    InsertTitlePgOverlay
' Description:  Inserts a new Title image
' Parameters:   sImgPath - Path of image
' Returns:      n/a
'--********************************************************************
Sub InsertTitlePgOverlay(sImgNameandPath As String)
    
    Dim rRange As Range
    Dim sh As Shape
    Dim ilSh As InlineShape
    Dim sFullImagePathAndName As String
    Dim tTable As Table
    Dim cCell As Cell

        sFullImagePathAndName = sImgNameandPath
        If Not modPrivate.FileExists(sFullImagePathAndName) Then
            MsgBox "The image file '" & sFullImagePathAndName & " cannot be found!", _
                vbInformation, COMPANY_NAME_SHORT & " - Add title page image"
            Exit Sub
        End If

        'Delete any existing image
        Set rRange = ActiveDocument.Sections(1).Headers(wdHeaderFooterPrimary).Range

        If rRange.ShapeRange.count > 0 Then
            If rRange.ShapeRange(1).Name = "TitlePageOverlay" Then
                rRange.ShapeRange(1).Delete
            End If
            
        End If

        rRange.Collapse wdCollapseEnd
        'ONly insert a new image if not the default image
        Set ilSh = rRange.InlineShapes.AddPicture(sFullImagePathAndName)
        Set sh = ilSh.ConvertToShape
        
        sh.Name = "TitlePageOverlay"
        sh.WrapFormat.Type = wdWrapBehind
    
        
        sh.RelativeHorizontalPosition = wdRelativeHorizontalPositionPage
        sh.Left = CentimetersToPoints(0)
        sh.RelativeVerticalPosition = wdRelativeVerticalPositionPage
        sh.Top = CentimetersToPoints(0)
        sh.LayoutInCell = True
        sh.LockAspectRatio = msoTrue
        sh.Height = ActiveDocument.Sections(1).PageSetup.PageHeight
        

    
    Set ilSh = Nothing
    Set sh = Nothing
    Set rRange = Nothing
    
End Sub

Sub DeleteTitlePageImage()

    Dim shShape As Shape

    With ActiveDocument.Sections(1).Footers(wdHeaderFooterPrimary)
        
        For Each shShape In .Shapes
            If shShape.Name = "TitlePageImage" Then
                shShape.Delete
            End If
        Next
    
    End With
    
End Sub


'++*******************************************************************
' Procedure:    InsertTitlePgSection
' Description:  Inserts a new Title page as Section 1
' Parameters:   n/a
' Returns:      n/a
'--********************************************************************
Sub InsertTitlePgSection()

    InsertTopOfDocumentSection 1, "z_TitlePageSection"
    

End Sub

'++*******************************************************************
' Procedure:    InsertPortableLanguageSection
' Description:  Inserts a new Title page as Section 1
' Parameters:   iSecNo = section number for the new section
' Returns:      n/a
'--********************************************************************
Sub InsertPortabilityLanguageSection(iSecNo As Integer)

    InsertTopOfDocumentSection iSecNo, "z_PortabilityLanguageSection"
    
End Sub

Sub InsertExecutiveSummary(iSecNo As Integer)


    InsertTopOfDocumentSection iSecNo, "z_ExecutiveSummarySection"


End Sub

Sub InsertTOC(iSecNo As Integer)

    InsertTopOfDocumentSection iSecNo, "z_TOCSection"


End Sub


'++*******************************************************************
' Procedure:    InsertContentsPgSection
' Author:       Nikki Pike - Brochet ltd
' Description:  Inserts a new Contents page as Section iSecNo
' Parameters:   iSecNo - Section no of the new versions page section
' Returns:      n/a
'--********************************************************************
Sub InsertContentsPgSection(iSecNo As Integer)

    InsertTopOfDocumentSection iSecNo, "z_ContentsPageSection"
    
End Sub

Sub InsertTopOfDocumentSection(iSecNo As Integer, sAutoTextName As String)

    Dim rRange As Range
    Dim sLanguage As String
    Dim bInsertExtraPara As Boolean

    If iSecNo = 1 Then
        Set rRange = ActiveDocument.Bookmarks("\StartOfDoc").Range
    Else
        'Insert at the start of iSecNo
        Set rRange = ActiveDocument.Sections(iSecNo).Range
        rRange.End = rRange.Start
    End If
    
    'Need to see if the start of the range is in a Frame
    If rRange.Frames.count > 0 Then
        bInsertExtraPara = True
        rRange.InsertBefore vbCr
        If iSecNo = 1 Then
            Set rRange = ActiveDocument.Bookmarks("\StartOfDoc").Range
        Else
            'Insert at the start of iSecNo
            Set rRange = ActiveDocument.Sections(iSecNo).Range
            rRange.End = rRange.Start
        End If
        rRange.Style = wdStyleNormal
    End If

    'Insert the auto text
    ActiveDocument.AttachedTemplate.AutoTextEntries(sAutoTextName).Insert Where _
        :=rRange, richtext:=True

    If bInsertExtraPara Then
        'Delete the extra paragraph
        ActiveDocument.Sections(iSecNo + 1).Range.Paragraphs(1).Range.Delete
'        ActiveDocument.Sections(iSecNo + 1).Range.Paragraphs(1).Range.Delete
    End If

End Sub

Sub InsertContactPage()

    Dim rRange As Range
    Dim sLanguage As String
    Dim bInsertExtraPara As Boolean
    Dim iSecNo As Integer


    If modContentControls.ContentControlExists(CC_BROCHET_DISCLOSURES_GROUP) Then
        Set rRange = modContentControls.GetRangeFromTag(CC_BROCHET_DISCLOSURES_GROUP)
        With rRange
            .Collapse wdCollapseStart
            .Move wdCharacter, -1
        End With
        
        InsertAutotext "z_ContactPageGroup", rRange, True, True
    Else
        'Insert at the end
        Set rRange = ActiveDocument.Range
        With rRange
            .Collapse wdCollapseEnd
            '.Move wdCharacter, -1
        End With
        
        InsertAutotext "z_ContactPageGroup", rRange, True, True
    End If

       

End Sub

Sub InsertDisclosurePage()

    Dim rRange As Range
    Dim sLanguage As String
    Dim bInsertExtraPara As Boolean
    Dim iSecNo As Integer



        'Insert at the end
        Set rRange = ActiveDocument.Range
        With rRange
            .Collapse wdCollapseEnd
            '.Move wdCharacter, -1
        End With
        
        InsertAutotext "z_DisclosuresGroup", rRange, True, True

End Sub


Sub A4ReportDeleteSection()

    Dim bSmartCut As Boolean
    Dim bTrackChanges As Boolean
    Dim sText As String
    Dim sTitle As String
    Dim iSectionCount As Integer
    Dim rRange As Range
    Dim iSelectedTextStartingSectionNumber As Integer
    Dim iSelectedTextEndSectionNumber As Integer
    Dim i As Integer
    Dim iNumberOfFrontProtectedSections As Integer
    Dim iLastSectionNumber As Integer
    Dim iLastSectionCount As Integer
    Dim iPgNoStart As Integer
    Dim iPgNoEnd As Integer

    Dim bTitlePgExists As Boolean
    Dim bInsideTitlePgExists As Boolean
    Dim bContentsPgExists As Boolean
    Dim bExecSummPgExists As Boolean

    sTitle = "Delete section(s)"

    'Check not in Header or Footer
    If Selection.Information(wdInHeaderFooter) Then
        MsgBox "A section(s) cannot be deleted in a Header or Footer.", vbInformation, sTitle
    'Check not in Footnote or Endnote
    ElseIf Selection.Information(wdInFootnoteEndnotePane) Then
        MsgBox "A section(s) cannot be deleted in a Footnote or EndNote Pane.", vbInformation, sTitle
    ElseIf Selection.Information(wdInEndnote) Then
        MsgBox "A section(s) cannot be deleted in an EndNote.", vbInformation, sTitle
    ElseIf Selection.Information(wdInFootnote) Then
        MsgBox "A section(s) cannot be deleted in a FootNote.", vbInformation, sTitle
    Else

        'See if the selected range is more than one section
        Set rRange = Selection.Range
        rRange.Collapse wdCollapseStart
        iSelectedTextStartingSectionNumber = rRange.Information(wdActiveEndSectionNumber)

        Set rRange = Selection.Range
        rRange.Collapse (wdCollapseEnd)
        iSelectedTextEndSectionNumber = rRange.Information(wdActiveEndSectionNumber)

        'If more than one section
        
        Set rRange = ActiveDocument.Sections(iSelectedTextStartingSectionNumber).Range
        rRange.Collapse wdCollapseStart
        iPgNoStart = rRange.Information(wdActiveEndPageNumber)
        iPgNoEnd = ActiveDocument.Sections(iSelectedTextStartingSectionNumber).Range.Information(wdActiveEndPageNumber)
                    
        iSectionCount = ActiveDocument.Sections.count

        'See how many start sections there are
        iNumberOfFrontProtectedSections = 0
        bTitlePgExists = modPages.IsTitlePageEnabled
        If bTitlePgExists Then iNumberOfFrontProtectedSections = iNumberOfFrontProtectedSections + 1
        
        bInsideTitlePgExists = False 'modPages.IsInsideTitlePageEnabled
        If bInsideTitlePgExists Then iNumberOfFrontProtectedSections = iNumberOfFrontProtectedSections + 1
        
        bContentsPgExists = modPages.IsContentsPageEnabled
        If bContentsPgExists Then iNumberOfFrontProtectedSections = iNumberOfFrontProtectedSections + 1
        
        bExecSummPgExists = modPages.IsExecutiveSummaryEnabled
        If bExecSummPgExists Then iNumberOfFrontProtectedSections = iNumberOfFrontProtectedSections + 1

        'See how many end sections there are
        If IsContactPageEnabled Or modPages.IsDisclosureEnabled Then
            iLastSectionCount = 1
            iLastSectionNumber = iSectionCount
        Else
            iLastSectionNumber = 0
        End If
        
        'Check is more than 1 section in the document
         If iSectionCount = 1 Then
             MsgBox "There is only one section in the document and therefore cannot be deleted!", vbInformation, "Delete section"

         'Check if in one of the Back sections as cannot delete
         ElseIf iSelectedTextEndSectionNumber = iLastSectionNumber Then
             MsgBox "The last section cannot be deleted using this method!" & vbCr & vbCr & "Use the 'New doc dialog' box to delete the Back page.", vbInformation, "Delete section(s)"

         'Check if in one of the front sections as cannot delete
         ElseIf iSelectedTextStartingSectionNumber <= iNumberOfFrontProtectedSections Then
             MsgBox "One of the front sections (Title, Inside Title Page or Contents sections) cannot be deleted using this method!" & vbCr & vbCr & "Use the 'New doc dialog' box to delete the Title, Inside Title Page or Contents section(s).", vbInformation, "Delete section(s)"

         'Check that more than one section in the main section of the document
         ElseIf iSectionCount - iNumberOfFrontProtectedSections - iLastSectionCount = 1 Then
             MsgBox "This document only contains one main section and therefore no section can be deleted using this method!" & vbCr & vbCr & "Use the 'New doc dialog' box to delete the any of the front sections.", vbInformation, "Delete section(s)"

         'Lastely must check that all the main sections have not been selected
         ElseIf iSelectedTextStartingSectionNumber <= iNumberOfFrontProtectedSections + 1 And iSelectedTextEndSectionNumber = iLastSectionNumber Then
             MsgBox "All the main sections have been selected! The document must contain at least one section in the main body of the report.", vbInformation, "Delete section(s)"

         Else

            'If smart cut and pastes is set to on switch off
            bSmartCut = False
            If Options.SmartCutPaste = True Then
                bSmartCut = True
                Options.SmartCutPaste = False
            End If
        
            'Switch off track changing
            bTrackChanges = False
            If ActiveDocument.TrackRevisions Then
                bTrackChanges = True
                ActiveDocument.TrackRevisions = False
            End If

            If iSelectedTextStartingSectionNumber = 1 And iSelectedTextEndSectionNumber = iSectionCount Then
                 MsgBox "The sections selected (sections " & iSelectedTextStartingSectionNumber & " to " & iSelectedTextEndSectionNumber & ") are the whole document and therefore cannot be deleted!", vbInformation, "Delete sections(s)"
            Else
                
                If iSelectedTextStartingSectionNumber < iSelectedTextEndSectionNumber Then
                    
                    If iPgNoStart = iPgNoEnd Then
                        sText = "Please confirm that you would like the selected " & iSelectedTextEndSectionNumber - iSelectedTextStartingSectionNumber + 1 & _
                            " sections deleted?" & vbCr & vbCr & _
                            "Page " & iPgNoStart & " will be deleted!" & vbCr & vbCr & _
                            "Be aware all contents from these sections will be deleted!"
                    Else
                        sText = "Please confirm that you would like the selected " & iSelectedTextEndSectionNumber - iSelectedTextStartingSectionNumber + 1 & _
                            " sections deleted?" & vbCr & vbCr & _
                            "Pages " & iPgNoStart & " to " & iPgNoEnd & " will be deleted!" & vbCr & vbCr & _
                            "Be aware all contents from these sections will be deleted!"
                    End If

                    If MsgBox(sText, vbOKCancel, "Delete sections") = vbOK Then

                        'Delete each of the sections
                        For i = iSelectedTextEndSectionNumber To iSelectedTextStartingSectionNumber Step -1
                            modPages.DeleteSection i, "", True
                        Next

                    End If

                'Only one section to delte
                Else

                    If iPgNoStart = iPgNoEnd Then
                        sText = "Please confirm that you would like the current section (section " & iSelectedTextStartingSectionNumber & ") deleted?" & vbCr & vbCr & _
                            "Page " & iPgNoStart & " will be deleted!" & vbCr & vbCr & _
                            "Be aware all contents from this section will be deleted!"
                    Else
                        sText = "Please confirm that you would like the current section (section " & iSelectedTextStartingSectionNumber & ") deleted?" & vbCr & vbCr & _
                            "Pages " & iPgNoStart & " to " & iPgNoEnd & " will be deleted!" & vbCr & vbCr & _
                            "Be aware all contents from this section will be deleted!"
                    End If
                    
                    If MsgBox(sText, vbOKCancel, "Delete sections") = vbOK Then

                        'Delete the single section
                        modPages.DeleteSection iSelectedTextStartingSectionNumber, "", True

                    End If

                End If
                    
                'Switch back on Smart cut and paste
                If bSmartCut Then
                    Options.SmartCutPaste = True
                End If
            
                'Switch Track Changes back on
                If bTrackChanges Then
                    ActiveDocument.TrackRevisions = True
                End If

            End If
                
        End If

    End If

End Sub

'++*******************************************************************
' Procedure:    DeleteSection
' Author:       Brochet ltd
' Description:  Deletes the section iSecNo
' Parameters:   iSecNo = Section number to be deleted
' Returns:      n/a
'--********************************************************************
Sub DeleteSection(iSecNo As Integer, Optional sBookmarkToDelete As String = "", Optional bCheckForCCAndDelete As Boolean = False)

    Dim iTotalSecNo As Integer
    Dim rRange As Range
    Dim bLink As Boolean
    Dim iParaNo As Integer
    Dim iParaNo2 As Integer
    Dim rSection As Range
    Dim rSection2 As Range
    Dim i As Integer
    Dim bScreenUpdate As Boolean
    
    System.Cursor = wdCursorWait
    bScreenUpdate = Application.ScreenUpdating
    Application.ScreenUpdating = False
    ActiveDocument.Repaginate
    
    iTotalSecNo = ActiveDocument.Sections.count
    
    'Cannot delete a section is only one exists
    If iTotalSecNo > 1 Then
    
        If iSecNo = 1 Then
            'See if the Section contains any locked Content Controls
            Set rSection = ActiveDocument.Sections(iSecNo).Range
            If bCheckForCCAndDelete Then
                UnlockControlsInRange rSection
            End If
            'Need to unlink the next section heading otherwise they are set to blank
            modLinkToPrevious.LinkToPreviousSet iSecNo + 1, HeadersAndFooters, FirstPage + Primary, False
        
            'Delete the section
            Set rRange = ActiveDocument.Sections(iSecNo).Range
            rRange.Delete
        
        ElseIf iSecNo < iTotalSecNo Then
        
            'See if the Section contains any locked Content Controls
            Set rSection = ActiveDocument.Sections(iSecNo).Range
            If bCheckForCCAndDelete Then
                UnlockControlsInRange rSection
            End If
        
            'If next section header is linked to previous and this section is not, turn it off
            If ActiveDocument.Sections(iSecNo).Headers(wdHeaderFooterPrimary).LinkToPrevious = False _
              And ActiveDocument.Sections(iSecNo + 1).Headers(wdHeaderFooterPrimary).LinkToPrevious = True Then
                modLinkToPrevious.LinkToPreviousSet iSecNo + 1, HeadersOnly, Primary, False
            End If

            'If next section footer is linked to previous and this section is not, turn it off
            If ActiveDocument.Sections(iSecNo).Footers(wdHeaderFooterPrimary).LinkToPrevious = False _
              And ActiveDocument.Sections(iSecNo + 1).Footers(wdHeaderFooterPrimary).LinkToPrevious = True Then
                modLinkToPrevious.LinkToPreviousSet iSecNo + 1, FootersOnly, Primary, False
            End If
            
            'Need to change the following section type to the same as this sectioin
            If ActiveDocument.Sections(iSecNo + 1).PageSetup.SectionStart = wdSectionContinuous Then
                ActiveDocument.Sections(iSecNo + 1).PageSetup.SectionStart = ActiveDocument.Sections(iSecNo).PageSetup.SectionStart
            End If

            'Delete the section
            Set rRange = ActiveDocument.Sections(iSecNo).Range
            modContentControls.UnlockControlsInRange rRange
            rRange.Delete
        
        'Then is the last section so the section break above needs to be deleted
        Else
            'See if the Section contains any locked Content Controls
            Set rSection = ActiveDocument.Sections(iSecNo).Range
            If bCheckForCCAndDelete Then
                UnlockControlsInRange rSection
            End If
            
            'First need to make the section contain the same page setting as the section below
            'As frames are used and could be at the beginning of the section need to set the range to a non frame area
            If ActiveDocument.Sections(iSecNo - 1).Range.Frames.count > 0 Then
                iParaNo = ActiveDocument.Sections(iSecNo - 1).Range.Paragraphs.count
                For i = 1 To iParaNo
                    iParaNo2 = i
                    If ActiveDocument.Sections(iSecNo - 1).Range.Paragraphs(i).Range.Frames.count = 0 Then
                        Exit For
                    End If
                Next
                Set rSection = ActiveDocument.Sections(iSecNo - 1).Range.Paragraphs(iParaNo2).Range
                rSection.Collapse wdCollapseEnd
            Else
                Set rSection = ActiveDocument.Sections(iSecNo - 1).Range.Paragraphs(1).Range
                rSection.Collapse wdCollapseEnd
            End If
            
            'This is the last section which if there is a frame in the first paragraph of the section
            'you can't se the PageSetup so need to remove the frame from the first paragraph
            ActiveDocument.Sections(iSecNo).Range.Paragraphs(1).Style = wdStyleNormal
            
            ActiveDocument.Sections(iSecNo).PageSetup.SectionStart = rSection.PageSetup.SectionStart
            ActiveDocument.Sections(iSecNo).PageSetup.Orientation = rSection.PageSetup.Orientation
            ActiveDocument.Sections(iSecNo).PageSetup.TopMargin = rSection.PageSetup.TopMargin
            ActiveDocument.Sections(iSecNo).PageSetup.BottomMargin = rSection.PageSetup.BottomMargin
            ActiveDocument.Sections(iSecNo).PageSetup.LeftMargin = rSection.PageSetup.LeftMargin
            ActiveDocument.Sections(iSecNo).PageSetup.RightMargin = rSection.PageSetup.RightMargin
            ActiveDocument.Sections(iSecNo).PageSetup.TopMargin = rSection.PageSetup.TopMargin
            ActiveDocument.Sections(iSecNo).PageSetup.DifferentFirstPageHeaderFooter = rSection.PageSetup.DifferentFirstPageHeaderFooter
            ActiveDocument.Sections(iSecNo).PageSetup.SectionStart = rSection.PageSetup.SectionStart
            
            'Link all the headers
            bLink = ActiveDocument.Sections(iSecNo - 1).Headers(wdHeaderFooterFirstPage).LinkToPrevious
            modLinkToPrevious.LinkToPreviousSet iSecNo, HeadersOnly, FirstPage, True
            modLinkToPrevious.LinkToPreviousSet iSecNo, HeadersOnly, FirstPage, bLink
            
            bLink = ActiveDocument.Sections(iSecNo - 1).Headers(wdHeaderFooterPrimary).LinkToPrevious
            modLinkToPrevious.LinkToPreviousSet iSecNo, HeadersOnly, Primary, True
            modLinkToPrevious.LinkToPreviousSet iSecNo, HeadersOnly, Primary, bLink
            
            bLink = ActiveDocument.Sections(iSecNo - 1).Footers(wdHeaderFooterFirstPage).LinkToPrevious
            modLinkToPrevious.LinkToPreviousSet iSecNo, FootersOnly, FirstPage, True
            modLinkToPrevious.LinkToPreviousSet iSecNo, FootersOnly, FirstPage, bLink
            
            bLink = ActiveDocument.Sections(iSecNo - 1).Footers(wdHeaderFooterPrimary).LinkToPrevious
            modLinkToPrevious.LinkToPreviousSet iSecNo, FootersOnly, Primary, True
            modLinkToPrevious.LinkToPreviousSet iSecNo, FootersOnly, Primary, bLink
            
            'Need to unlink the Headers and footers if this is the second to last section
            If iSecNo = 2 Then
                modLinkToPrevious.LinkToPreviousSet iSecNo, HeadersAndFooters, FirstPage + Primary, False
            End If
            
            'Delete the section
            Set rRange = ActiveDocument.Sections(iSecNo).Range
            rRange.Start = rRange.Start - 1
            
            rRange.Delete
        
        End If
    End If
    
    If sBookmarkToDelete <> "" Then
        If Not IsMissing(sBookmarkToDelete) Then
            'Delete bookmark if required
            If ActiveDocument.Bookmarks.Exists(sBookmarkToDelete) Then
                ActiveDocument.Bookmarks(sBookmarkToDelete).Delete
            End If
        End If
    End If
    
    System.Cursor = wdCursorNormal
    Application.ScreenUpdating = bScreenUpdate

End Sub

'Sub RemoveAllContentControl(rRange As Range)
'
'    Dim ccControls As ContentControls
'    Dim ccControl As ContentControl
'
'
'    If rRange.ContentControls.count > 0 Then
'
'        Set ccControls = ReturnAllContentControlsInRange(rRange)
'        UnlockControlsInRange rRange
'        If ccControls.count > 0 Then
'            For Each ccControl In ccControls
'                ccControl.LockContentControl = False
'                ccControl.LockContents = False
'                ccControl.Delete
'            Next
'        End If
'
'    End If
'
'End Sub

'++*******************************************************************
' Procedure:    TitlePageExists
' Description:  Checks to see if the Title page exists - should always be
'               the first section
' Parameters:   n/a
' Returns:      Returns True if it exists
'--********************************************************************
Function IsTitlePageEnabled() As Boolean

    IsTitlePageEnabled = False

    If GetPageSection(PAGEID_TitlePage) > 0 Then
            IsTitlePageEnabled = True
    End If

End Function

Function GetPageSection(sPageID As String) As Integer
    'Looks at the Alt text of a table in the footer or header
    'returns zero if it does not exist
    Dim sSect As Section
    
    'On Error GoTo tryFirstPage
    
    GetPageSection = 0
    
    For Each sSect In ActiveDocument.Sections
        
        If sSect.Footers(wdHeaderFooterPrimary).Exists Then
            If sSect.Footers(wdHeaderFooterPrimary).Range.Tables.count > 0 Then
                If sSect.Footers(wdHeaderFooterPrimary).Range.Tables(1).title = sPageID Then
                    GetPageSection = sSect.Index
                    Exit Function
                End If
            End If
        ElseIf sSect.Footers(wdHeaderFooterFirstPage).Exists Then
            If sSect.Footers(wdHeaderFooterFirstPage).Range.Tables.count > 0 Then
                If sSect.Footers(wdHeaderFooterFirstPage).Range.Tables(1).title = sPageID Then
                    GetPageSection = sSect.Index
                    Exit Function
                End If
            End If
        End If
    Next
    
tryFirstPage:

    

End Function

'++*******************************************************************
' Description:  Checks to see if the ExecutiveSummary exists - should always be
'               the first section
' Parameters:   n/a
' Returns:      Returns True if it exists
'--********************************************************************
Function IsExecutiveSummaryEnabled() As Boolean

    IsExecutiveSummaryEnabled = False

    If GetPageSection(PAGEID_ExecutiveSummary) > 0 Then
            IsExecutiveSummaryEnabled = True

    End If

End Function



'++*******************************************************************
' Description:  Checks to see if the Portability Page exists - should always be
'               the second section
' Parameters:   n/a
' Returns:      Returns True if it exists
'--********************************************************************
Function IsPortabilityPageEnabled() As Boolean

    IsPortabilityPageEnabled = False

    If GetPageSection(PAGEID_PortabilityLanguagePage) > 0 Then
            IsPortabilityPageEnabled = True

    End If

End Function

'++*******************************************************************
'Procedure:     InsideTitlePageExists
' Description:  Checks to see if the Inside Title page exists - should
'               always be the second section
' Parameters:   n/a
' Returns:      Returns True if it exists
'--********************************************************************
Function IsDisclosureEnabled() As Boolean

    IsDisclosureEnabled = False

    If modContentControls.ContentControlExists(CC_BROCHET_DISCLOSURES_GROUP) Then
            IsDisclosureEnabled = True

    End If


End Function

'++*******************************************************************
' Procedure:    ContentsExists
' Description:  Checks to see if the Inside Title page exists - should
'               always be the second section
' Parameters:   n/a
' Returns:      Returns True if it exists
'--********************************************************************
Function IsContentsPageEnabled() As Boolean

    Dim rRange As Range
    Dim fField As Field

    IsContentsPageEnabled = False

    If GetPageSection(PAGEID_TOC) > 0 Then
        IsContentsPageEnabled = True
    End If


End Function

'++*******************************************************************
' Procedure:    IsBackPageEnabled
' Description:  Checks to see if the Back page exists - should
'               always be the last section
' Parameters:   n/a
' Returns:      Returns True if it exists
'--********************************************************************
Function IsContactPageEnabled() As Boolean

    Dim rRange As Range
    Dim fField As Field

    IsContactPageEnabled = False

    If modContentControls.ContentControlExists(CC_CONTACT_PAGE) Then
    'If GetPageSection(PAGEID_ContactPage) > 0 Then
        IsContactPageEnabled = True
    End If


End Function

'++******************************************************************************************************
' Description:  Toggles the section break type between new page and continuos
' Parameters:   oSection - Section which section break needs to change
' Returns:      N/A
'++******************************************************************************************************
Public Sub ToggleSectionType()

    Dim rRange As Range
    Dim iSecStartNo As Integer
    Dim iSecEndNo As Integer
    Dim iPgNoStart As Integer
    Dim iPgNoEnd As Integer
    Dim iSecTotal As Integer
    Dim iStartSecNo As Integer
    Dim iEndSecNo As Integer
    Dim bTitlePgExists As Boolean
    Dim bInsideTitlePgExists As Boolean
    Dim bContentsPgExists As Boolean
    Dim oSection As Section
    Dim iPageSetupType As Integer
    Dim iOrientation As Integer
    
    'First check that only one section is selected
    If Selection.Range.Sections.count > 1 Then
        MsgBox "More than one section has been selected." & vbCr & vbCr & "Make sure only one section is selected.", vbInformation, "Toggle section type"
    Else
    
        'Can't be done in title, inside cover, contents or back page
        'See if the selected range is more than one section
        Set rRange = Selection.Range
        rRange.Collapse wdCollapseStart
        iSecStartNo = rRange.Information(wdActiveEndSectionNumber)

        Set rRange = Selection.Range
        rRange.Collapse (wdCollapseEnd)
        iSecEndNo = rRange.Information(wdActiveEndSectionNumber)

        'If more than one section

        Set rRange = ActiveDocument.Sections(iSecStartNo).Range
        rRange.Collapse wdCollapseStart
        iPgNoStart = rRange.Information(wdActiveEndPageNumber)
        iPgNoEnd = ActiveDocument.Sections(iSecStartNo).Range.Information(wdActiveEndPageNumber)

        iSecTotal = ActiveDocument.Sections.count

        'See how many start sections there are
        iStartSecNo = 0
        bTitlePgExists = modPages.IsTitlePageEnabled
        If bTitlePgExists Then iStartSecNo = iStartSecNo + 1

        bContentsPgExists = modPages.IsContentsPageEnabled
        If bContentsPgExists Then iStartSecNo = iStartSecNo + 1

        'See how many end sections there are
        iEndSecNo = 0

        'Check is more than 1 section in the document
        If iSecTotal = 1 Then
             MsgBox "There is only one section in the document and therefore the section type cannot be changed", vbInformation, "Toggle section type"

        'Check if in one of the Back sections as cannot delete
        ElseIf iSecEndNo > iSecTotal - iEndSecNo Then
            MsgBox "The back page cannot have the section type changed!", vbInformation, "Toggle section type"

        'Check if in one of the front sections as cannot delete
        ElseIf iSecStartNo <= iStartSecNo Then
            MsgBox "One of the front sections (Title, Inside Title Page or Contents sections) cannot have the section type changed!", vbInformation, "Toggle section type"

        'Check that more than one section in the main section of the document
        ElseIf iSecTotal <= iStartSecNo + iEndSecNo + 1 Then
            MsgBox "This document only contains one main section and therefore the section type cannot be changed!", vbInformation, "Toggle section type"
        
        'Check if the first section of the main document as this cannot have the section type changed
        ElseIf iSecStartNo = iStartSecNo + 1 Then
            MsgBox "The first section of the main section cannot have the section type changed!", vbInformation, "Toggle section type"
        Else
        
        
            Set oSection = ActiveDocument.Sections(iSecStartNo)

         
            'Make a note of the page setting so we can see if it has changed
            iPageSetupType = oSection.PageSetup.SectionStart
        
            With oSection.PageSetup
                If .SectionStart = wdSectionNewPage Then
                    .SectionStart = wdSectionContinuous
                Else
                    .SectionStart = wdSectionNewPage
                End If
            End With

            'Check if nothing has changed
            If iPageSetupType = oSection.PageSetup.SectionStart Then
                MsgBox "The section type has not been changed." & vbCr & vbCr & "This maybe due to the fact that the orientation of the section is different to the section in front and therefore the section type cannot be changed!", vbInformation, "Toggle section type"
            End If

            ActiveWindow.ScrollIntoView Selection.Range
       
        End If
    End If
    
End Sub



Function GetPageType(iSectionNumber As Integer) As Brochet_PAGE_TYPE


    Dim iOrientation As Integer

    With ActiveDocument.Sections(iSectionNumber).PageSetup
        Select Case .PaperSize
        Case wdPaperA4
            If .Orientation = wdOrientPortrait Then

                If .LeftMargin > CentimetersToPoints(A4_PORT_PROPOSAL_LEFT_MARGIN - 1) Then 'The -1 is to remove any rounding errors
                     GetPageType = A4PROPOSAL
                Else
                    GetPageType = A4WIDE
                End If
            Else
                GetPageType = A4LANDSCAPE

            End If
        Case wdPaperA3

            GetPageType = A3LANDSCAPE
        Case wdPaperLetter
            If .Orientation = wdOrientPortrait Then

                If .LeftMargin > CentimetersToPoints(LETTER_PORT_PROPOSAL_LEFT_MARGIN - 1) Then 'The -1 is to remove any rounding errors
                     GetPageType = LETTERPROPOSAL
                Else
                    GetPageType = LETTERWIDE
                End If
            Else
                GetPageType = LETTERLANDSCAPE

            End If
        
        Case wdPaper11x17
        
                GetPageType = LEDGERLANDSCAPE
        
        End Select
    End With
    
    
End Function


Function SectionsHaveDifferentHeaders(CurrentSectionType As Brochet_PAGE_TYPE, FollowingSectionType As Brochet_PAGE_TYPE) As Boolean

'    A4NARROW = 1
'    A4WIDE = 2
'    A4LANDSCAPE_COL1 = 4
'    A4LANDSCAPE_COL2 = 8
'
'    A3LANDSCAPE_COL1 = 16
'    A3LANDSCAPE_COL2 = 32
'    A3LANDSCAPE_COL4 = 64

    If (CurrentSectionType And 15) And (FollowingSectionType And 15) Then
        'Same Header style
        SectionsHaveDifferentHeaders = False
    ElseIf (CurrentSectionType And 112) And (FollowingSectionType And 112) Then
        'Same Header style
        SectionsHaveDifferentHeaders = False
    Else
        'Different
        SectionsHaveDifferentHeaders = True
    End If
        
End Function



Function IsInEditableSection(rRange As Range) As Boolean

    Dim iTestSection As Integer
    Dim iStartSecNo As Integer
    Dim bTitlePg As Boolean
    Dim bInsideTitlePg As Boolean
    Dim bContentsPg As Boolean
    Dim bExecSummary As Boolean
    
    Dim rContactPage As Range
    Dim rDisclosure As Range

        iTestSection = rRange.Sections(1).Index

        'See how many start sections there are
        bTitlePg = modPages.IsTitlePageEnabled
        bInsideTitlePg = False 'modPages.IsInsideTitlePageEnabled
        bContentsPg = modPages.IsContentsPageEnabled
        bExecSummary = modPages.IsExecutiveSummaryEnabled
        
        iStartSecNo = 0
        If bTitlePg Then iStartSecNo = iStartSecNo + 1
        If bInsideTitlePg Then iStartSecNo = iStartSecNo + 1
        If bExecSummary Then iStartSecNo = iStartSecNo + 1
        If bContentsPg Then iStartSecNo = iStartSecNo + 1
        
        IsInEditableSection = False
        
        
        If iTestSection > iStartSecNo Then
            IsInEditableSection = True
            
            Set rContactPage = modContentControls.GetRangeFromTag("BrochetContactPageGroup")
            Set rDisclosure = modContentControls.GetRangeFromTag("BrochetDisclosuresGroup")
            If Not rContactPage Is Nothing Then
                If rRange.End > rContactPage.Start Then
                    IsInEditableSection = False
                End If
            ElseIf Not rDisclosure Is Nothing Then
                If rRange.End > rDisclosure.Start Then
                    IsInEditableSection = False
                End If
            End If
        Else
            If GetPageSection(PAGEID_ExecutiveSummary) = iTestSection Then
                IsInEditableSection = True
            End If
        End If
    
End Function


Sub RangeTest()

Dim rRange As Range
Dim range2 As Range


    Set rRange = Selection.Range
    Set range2 = rRange.Duplicate
    
    range2.Move wdCharacter, -3
    range2.InsertBefore "aaa"
    
    rRange.Select


End Sub


Sub SetAllPagesAsType(bMetric As Boolean)

Dim secSect As Section
Dim iOrientation As Integer
Dim oProgress As frmProgress


Set oProgress = New frmProgress
oProgress.Init "Risizing pages", "Page", ActiveDocument.Sections.count, 1
oProgress.Show

    If bMetric Then
    
        For Each secSect In ActiveDocument.Sections
            oProgress.Step
            Select Case GetPageType(secSect.Index)
            Case LETTERPROPOSAL
                SetPagesize secSect, A4PROPOSAL
            Case LETTERWIDE
                SetPagesize secSect, A4WIDE
            Case LETTERLANDSCAPE
                SetPagesize secSect, A4LANDSCAPE
            Case LEDGERLANDSCAPE
                SetPagesize secSect, A3LANDSCAPE
            Case Else
                'SetPagesize secSect, A4WIDE
            End Select
        Next
    Else
        For Each secSect In ActiveDocument.Sections
            oProgress.Step
            Select Case GetPageType(secSect.Index)
            Case A4PROPOSAL
                SetPagesize secSect, LETTERPROPOSAL
            Case A4WIDE
                SetPagesize secSect, LETTERWIDE
            Case A4LANDSCAPE
                SetPagesize secSect, LETTERLANDSCAPE
            Case A3LANDSCAPE
                SetPagesize secSect, LEDGERLANDSCAPE
            Case Else
                'SetPagesize secSect, LETTERWIDE
            End Select
        Next
    End If

    oProgress.CloseMe

End Sub


Function SetPagesize(SectionToChange As Section, pageType As Brochet_PAGE_TYPE) As Boolean

    Dim PageMargins As BrochetPageMargins
    Dim sTargetPaperSize As String
    Dim sDefaultPaperSize As String
    
    On Error GoTo err
    
    PageMargins = GetPageMargins(pageType)
    
    Select Case pageType
    Case A4PROPOSAL
        SectionToChange.PageSetup.PaperSize = wdPaperA4
    Case A4WIDE
        SectionToChange.PageSetup.PaperSize = wdPaperA4
    Case A4LANDSCAPE
        SectionToChange.PageSetup.PaperSize = wdPaperA4
        SectionToChange.PageSetup.Orientation = wdOrientLandscape
    Case A3LANDSCAPE
        sTargetPaperSize = "A3"
        sDefaultPaperSize = "A4"
        SectionToChange.PageSetup.PaperSize = wdPaperA3
        SectionToChange.PageSetup.Orientation = wdOrientPortrait
        SectionToChange.PageSetup.Orientation = wdOrientLandscape
    Case LETTERPROPOSAL
        SectionToChange.PageSetup.PaperSize = wdPaperLetter
    Case LETTERWIDE
        SectionToChange.PageSetup.PaperSize = wdPaperLetter
    Case LETTERLANDSCAPE
        SectionToChange.PageSetup.PaperSize = wdPaperLetter
        SectionToChange.PageSetup.Orientation = wdOrientLandscape
    Case LEDGERLANDSCAPE
        sTargetPaperSize = "Ledger"
        sDefaultPaperSize = "Letter"
        SectionToChange.PageSetup.PaperSize = wdPaper11x17
        SectionToChange.PageSetup.Orientation = wdOrientPortrait
        SectionToChange.PageSetup.Orientation = wdOrientLandscape
    Case TYPE_OTHER
        MsgBox "Unidentified page type"
    End Select
    
    With SectionToChange.PageSetup
        .TopMargin = CentimetersToPoints(PageMargins.Top)
        .BottomMargin = CentimetersToPoints(PageMargins.Bottom)
        .RightMargin = CentimetersToPoints(PageMargins.Right)
        .LeftMargin = CentimetersToPoints(PageMargins.Left)
        .HeaderDistance = CentimetersToPoints(PageMargins.Header)
        .FooterDistance = CentimetersToPoints(PageMargins.Footer)
    End With
    SetPagesize = True
out:
    
    Exit Function
    
err:
    If err = 5889 Then

        If MsgBox("The selected printer cannot print to this paper size (" & sTargetPaperSize & ")." & vbCrLf & vbCrLf & _
                    "If you continue " & sDefaultPaperSize & " paper will be used." & vbCrLf & vbCrLf & _
                    "Alternatively press cancel and change the active printer to one with capability for this paper size, eg Adobe PDF, and then try again." & vbCrLf & vbCrLf & _
                    "Do you want to continue with " & sDefaultPaperSize & " paper size", vbYesNo + vbQuestion, COMPANY_NAME & " - New Section") = vbYes Then
            Resume Next
        End If

        SetPagesize = False
        Resume out

    End If
    SetPagesize = False
    modError.GlobalErrorHandler err, Error, msMODULE, "InsertNewSection"
    SetPagesize = False
    Resume out
    
End Function


Function GetPageMargins(pageType As Brochet_PAGE_TYPE) As BrochetPageMargins

    Select Case pageType
    Case A4PROPOSAL
        With GetPageMargins
            .Top = A4_PORT_PROPOSAL_TOP_MARGIN
            .Bottom = A4_PORT_PROPOSAL_BOTTOM_MARGIN
            .Right = A4_PORT_PROPOSAL_RIGHT_MARGIN
            .Left = A4_PORT_PROPOSAL_LEFT_MARGIN
            .Header = A4_PORT_PROPOSAL_HEADER_MARGIN
            .Footer = A4_PORT_PROPOSAL_FOOTER_MARGIN
        End With
    Case A4WIDE
        With GetPageMargins
            .Top = A4_PORT_WIDE_TOP_MARGIN
            .Bottom = A4_PORT_WIDE_BOTTOM_MARGIN
            .Right = A4_PORT_WIDE_RIGHT_MARGIN
            .Left = A4_PORT_WIDE_LEFT_MARGIN
            .Header = A4_PORT_WIDE_HEADER_MARGIN
            .Footer = A4_PORT_WIDE_FOOTER_MARGIN
        End With
    Case A4LANDSCAPE
        With GetPageMargins
            .Top = A4_LAND_TOP_MARGIN
            .Bottom = A4_LAND_BOTTOM_MARGIN
            .Right = A4_LAND_RIGHT_MARGIN
            .Left = A4_LAND_LEFT_MARGIN
            .Header = A4_LAND_HEADER_MARGIN
            .Footer = A4_LAND_FOOTER_MARGIN
        End With
    Case A3LANDSCAPE
        With GetPageMargins
            .Top = A3_LAND_TOP_MARGIN
            .Bottom = A3_LAND_BOTTOM_MARGIN
            .Right = A3_LAND_RIGHT_MARGIN
            .Left = A3_LAND_LEFT_MARGIN
            .Header = A3_LAND_HEADER_MARGIN
            .Footer = A3_LAND_FOOTER_MARGIN
        End With
    Case LETTERPROPOSAL
        With GetPageMargins
            .Top = LETTER_PORT_PROPOSAL_TOP_MARGIN
            .Bottom = LETTER_PORT_PROPOSAL_BOTTOM_MARGIN
            .Right = LETTER_PORT_PROPOSAL_RIGHT_MARGIN
            .Left = LETTER_PORT_PROPOSAL_LEFT_MARGIN
            .Header = LETTER_PORT_PROPOSAL_HEADER_MARGIN
            .Footer = LETTER_PORT_PROPOSAL_FOOTER_MARGIN
        End With
    Case LETTERWIDE
        With GetPageMargins
            .Top = LETTER_PORT_WIDE_TOP_MARGIN
            .Bottom = LETTER_PORT_WIDE_BOTTOM_MARGIN
            .Right = LETTER_PORT_WIDE_RIGHT_MARGIN
            .Left = LETTER_PORT_WIDE_LEFT_MARGIN
            .Header = LETTER_PORT_WIDE_HEADER_MARGIN
            .Footer = LETTER_PORT_WIDE_FOOTER_MARGIN
        End With
    
    Case LETTERLANDSCAPE
        With GetPageMargins
            .Top = LETTER_LAND_TOP_MARGIN
            .Bottom = LETTER_LAND_BOTTOM_MARGIN
            .Right = LETTER_LAND_RIGHT_MARGIN
            .Left = LETTER_LAND_LEFT_MARGIN
            .Header = LETTER_LAND_HEADER_MARGIN
            .Footer = LETTER_LAND_FOOTER_MARGIN
        End With
    Case LEDGERLANDSCAPE
        With GetPageMargins
            .Top = LEDGER_LAND_TOP_MARGIN
            .Bottom = LEDGER_LAND_BOTTOM_MARGIN
            .Right = LEDGER_LAND_RIGHT_MARGIN
            .Left = LEDGER_LAND_LEFT_MARGIN
            .Header = LEDGER_LAND_HEADER_MARGIN
            .Footer = LEDGER_LAND_FOOTER_MARGIN
        End With
    
    End Select


End Function


Function GetPageCount(rRange As Range) As Integer

    Dim lStartOfRange As Long
    Dim lEndOfRange As Long
    Dim rStart As Range
    Dim rEnd As Range
    
    
    Set rStart = rRange.Duplicate
    rStart.Collapse wdCollapseStart
       
    Set rEnd = rRange.Duplicate
    rEnd.Collapse wdCollapseEnd
    
    lStartOfRange = rStart.Information(wdActiveEndPageNumber)
    lEndOfRange = rEnd.Information(wdActiveEndPageNumber)

    GetPageCount = lEndOfRange - lStartOfRange + 1
    

End Function
Attribute VB_Name = "modPrivate"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*
'* Holds various macro code
'* 2018/08/14 - Some routines were showing DocVarGet as procedure name in error handling. Now fixed
'***********************************************************************************

Option Explicit
Option Private Module 'makes all macros private to this module - NO!!!! It makes it _
                        private to this PROJECT!

Private Const MODULE_NAME As String = "modPrivate"

Enum EFileProperty
    filename
    Size
    ItemType
    DateModified
    DateCreated
    DateAccessed
    Attributes
    OfflineStatus
    OfflineAvailability
    PerceivedType
    Owner
    Kind
    DateTaken
    ContributingArtists
    Album
    YearDate
    Genre
    Conductors
    Tags
    Rating
    Authors
    title
    Subject
    Categories
    Comments
    Copyright
    Number
    Length
    BitRate
    Protected
    CameraModel
    Dimensions
    CameraMaker
    Company
    FileDescription
    ProgramName
    Duration
    IsOnline
    IsRecurring
    Location
    OptionalAttendeeAddresses
End Enum

'++*******************************************************************
' Description:  Adds or sets the value of a document variable of the
'               passed in name and value.
' Parameters:   sName => The variable name.
'               sValue => The variable value.
' Returns:      N/A
'--********************************************************************
Sub DocVarSet(ByVal sName As String, ByVal sValue As String)
    
    On Error GoTo DocVarSet_EH
    ActiveDocument.Variables.Add Name:=sName, value:=sValue
    Exit Sub

DocVarSet_EH:
    Select Case err.Number
        Case 5903 'Variable already exists just set the value
            ActiveDocument.Variables(sName).value = sValue
        Case Else
            Const sProcedure As String = "DocVarSet"
            GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Sub

'++*******************************************************************
' Description:  Returns the value of a document variable of the
'               passed in name.
' Parameters:   sName => The variable name.
' Returns:      String. The value of the variable or Null if it does
'               not exist.
'--********************************************************************
Function DocVarGet(ByVal sName As String, Optional doc As Document = Nothing) As String
    
    If doc Is Nothing Then
        Set doc = ActiveDocument
    End If
    
    On Error GoTo DocVarGet_EH
    DocVarGet = doc.Variables(sName).value
    Exit Function

DocVarGet_EH:
    Select Case err.Number
      Case 5825 'Variable does not exist
        DocVarGet = vbNullString
      Case Else
        Const sProcedure As String = "DocVarGet"
        GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Function

'*******************************************************************************************************
'* Description: If document is opened in reading mode from Outlook it often causes problems.
'*              So we need to switch that option off, and inform the user.
'* Parameters:  N/A
'* Returns:     N/A
'*******************************************************************************************************
Public Sub TurnOffOpenAsReadingPane()
    On Error GoTo ErrorHandler
    If Options.AllowReadingMode Then
        Options.AllowReadingMode = False
        modError.DisplayMsg "Information: The Word Start-up configuration setting to " & _
        "open email attachments in reading view has been turned off." & vbCr & vbCr & _
        "This is to avoid potential problems when opening documents from emails.", vbInformation
    End If
CleanExit:
    Exit Sub
ErrorHandler:
    Dim sProcedure As String
    sProcedure = "TurnOffOpenAsReadingPane"
    GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    Resume CleanExit
End Sub

'*******************************************************************************************************
'* Description: Checks to see if a file exists
'* Parameters:  sFilePathAndName - Path and file name to check for
'* Returns:     True if exists, False if it does not exist
'*******************************************************************************************************
Public Function FileExists(filePathAndName As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    
    Set nfso = New ClsNotFileSystemObject
    FileExists = nfso.CheckFileExists(filePathAndName)
End Function

'*******************************************************************************************************
'* Description: Checks to see if a file exists
'* Parameters:  sFilePathAndName - Path and file name to check for
'* Returns:     True if exists, False if it does not exist
'*******************************************************************************************************
Public Function FolderExists(folderPath As String) As Boolean
    Dim nfso As ClsNotFileSystemObject
    
    Set nfso = New ClsNotFileSystemObject
    FolderExists = nfso.CheckFolderExists(folderPath)
End Function

'*******************************************************************************************************
'* Description: Expands the string with environment variables, and other string code we can define in
'*              NotFileSystemObject class
'* Parameters:  String to expand
'* Returns:     Expanded string where all %XXXXX% codes are replaced with their values
'*******************************************************************************************************
Public Function ExpandString(text As String) As String
    Dim nfso As ClsNotFileSystemObject
    
    Set nfso = New ClsNotFileSystemObject
    ExpandString = nfso.ExpandPath(text)
End Function

'*******************************************************************************************************
'* Description: Returns information regarding the Global's path and name.
'* Parameters:  rtnFullPath - If present, is set to the Global's full path and name.
'*              rtnPathOnly - If present, is set to the Global's path only.
'*              rtnFileNameExtension - If present, is set to the Global's file extension.
'*              rtnFileNameExtension - If present, is set to the file name suffix.
'* Returns:     The Global's name.
'*******************************************************************************************************
Public Function GlobalName(Optional ByRef rtnFullPath As String = "", _
                    Optional ByRef rtnPathOnly As String = "", _
                    Optional ByRef rtnFileNameExtension As String = "", _
                    Optional ByRef rtnFileNameSuffix As String = "") As String
  
    Dim sText As String
    Dim i As Integer
    
    GlobalName = ThisDocument.Name
    rtnFullPath = ThisDocument.FullName
    rtnPathOnly = ThisDocument.path
    rtnFileNameExtension = GetExtensionFromFileName(ThisDocument.Name)
    rtnFileNameSuffix = GetExtensionFromFileName(ThisDocument.Name)
End Function

'*******************************************************************************************************
'* Description: Gets file name suffix. File name suffix is the last word in file name. E.G Global EL.dotm
'*              EL is the suffix. In Global.dotm, no suffix exists
'* Parameters:  n/a
'* Returns:     suffix from global template name
'*******************************************************************************************************
Private Function GetFilenameSuffix() As String
    Dim fso As FileSystemObject
    Dim lSpacePosition As Long
        
    Set fso = New FileSystemObject
    GetFilenameSuffix = fso.GetBaseName(ThisDocument.FullName)
    
    lSpacePosition = InStrRev(GetFilenameSuffix, " ")
    If lSpacePosition = 0 Then
        GetFilenameSuffix = vbNullString
    Else
        GetFilenameSuffix = Trim$(Mid$(GetFilenameSuffix, lSpacePosition))
    End If
End Function

'*******************************************************************************************************
'* Description: Get's the parent folder from full path. If the path points to a file, the directory that
'*              contains it will be returned, if path is a folder, parent folder is returned.
'*              This function will not check if the path or returned parent path exists.
'* Parameters:  fullPath - The path (preferably to a file) of which parent folder we want
'* Returns:     Parent path of fullPath, or empty string if error occured
'*******************************************************************************************************
Public Function GetPathFromFullpath(FullPath As String) As String
    Dim fso As FileSystemObject
    
    On Error GoTo ErrorHandler
    
    Set fso = New FileSystemObject
    GetPathFromFullpath = fso.GetParentFolderName(FullPath)
    
CleanExit:
    Exit Function
ErrorHandler:
    GetPathFromFullpath = vbNullString
    Resume CleanExit:
End Function

'*******************************************************************************************************
'* Description: Get's the parent folder from full path. If the path points to a file, the directory that
'*              contains it will be returned, if path is a folder, parent folder is returned.
'*              This function will not check if the path or returned parent path exists.
'* Parameters:  fullPath - The path (preferably to a file) of which parent folder we want
'* Returns:     Parent path of fullPath, or empty string if error occured
'*******************************************************************************************************
Public Function GetFileNameFromFullpath(FullPath As String) As String
    Dim fso As FileSystemObject
    
    On Error GoTo ErrorHandler
    
    Set fso = New FileSystemObject
    GetFileNameFromFullpath = fso.GetFileName(FullPath)
    
CleanExit:
    Exit Function
ErrorHandler:
    GetFileNameFromFullpath = vbNullString
    Resume CleanExit:
End Function


'*******************************************************************************************************
'* Description: Creates a fullpath from path and file name
'*              This function will not check if the path or returned fullpath exists.
'* Parameters:  path - the folder path containing the file
'*              filename - name of the file
'* Returns:     full path to a file
'*******************************************************************************************************
Public Function JoinPathAndFilename(path As String, filename As String) As String
    Dim oFso As FileSystemObject
    
    On Error GoTo ErrorHandler:
    
    Set oFso = New FileSystemObject
    JoinPathAndFilename = oFso.BuildPath(path, filename)

CleanExit:
    Exit Function
ErrorHandler:
    JoinPathAndFilename = ""
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "JoinPathAndFilename"
    Resume CleanExit
End Function

'*******************************************************************************************************
'* Description: Get's file extension from given file name or file path.
'*              This function will not check if the file exists.
'* Parameters:  FileName - Name of the file, or the path to a file
'* Returns:     File extension of a file, or empty string if error occured
'*******************************************************************************************************
Public Function GetExtensionFromFileName(filename As String) As String
    Dim fso As FileSystemObject
    
    On Error GoTo ErrorHandler
    
    Set fso = New FileSystemObject
    GetExtensionFromFileName = fso.GetExtensionName(filename)
    
CleanExit:
    Exit Function
ErrorHandler:
    GetExtensionFromFileName = vbNullString
    Resume CleanExit:
End Function

'++********************************************************
' Description:  Find minimal value from supplied parameters
' Parameters:   ParamArray nums()   - Any number of parameters of any type. It should only be called with numeric parameters, because it uses < operator
' Returns:      minimal value from supplied parameters
'--**********************************************************
Public Function min(ParamArray nums())
    'there is no type specified, because I wanted it to stay general. THis way it can be used with Integer and floats no problem
    Dim minVal
    Dim X
    
    minVal = nums(1)
    'parameters of cource are not ordered, so I need to go throught all of them
    For Each X In nums
        If X < minVal Then
            minVal = X
        End If
    Next X
    min = minVal
End Function

'++********************************************************
' Description:  Find maximal value from supplied parameters
' Parameters:   ParamArray nums()   - Any number of parameters of any type. It should only be called with numeric parameters, because it uses > operator
' Returns:      maximal value from supplied parameters
'--**********************************************************
Public Function max(ParamArray nums())
    'there is no type specified, because I wanted it to stay general. THis way it can be used with Integer and floats no problem
    Dim maxVal
    Dim X
    
    maxVal = nums(1)
    'parameters of cource are not ordered, so I need to go throught all of them
    For Each X In nums
        If X > maxVal Then
            maxVal = X
        End If
    Next X
    max = maxVal
End Function

'++********************************************************
' Description:  Checks if given document is a template
' Parameters:   Doc - Document to check
' Returns:      True if the document is a template, false otherwise
'--**********************************************************
Public Function IsTemplate(ByVal doc As Document) As Boolean
  Select Case doc.SaveFormat
    Case wdFormatTemplate, wdFormatDocument97, _
         wdFormatXMLTemplate, wdFormatXMLTemplateMacroEnabled, _
         wdFormatFlatXMLTemplate, wdFormatFlatXMLTemplateMacroEnabled
      IsTemplate = True
    Case Else
      IsTemplate = False
  End Select
End Function

'++********************************************************
' Description:  there is a document and if there is, if the active
'               document is in protected view. The reason for this is,
'               that if there are no documents, or activeDoc is protected,
'               we have to disable some operations
' Parameters:   n/a
' Returns:      True if the document is there are no documents
'               of if active document is in protected view.
'               False otherwise
'--**********************************************************
Function DocCountZeroOrDocInProtectedView() As Boolean
    Dim sText As String
    
    DocCountZeroOrDocInProtectedView = Documents.count = 0
    
    If Not DocCountZeroOrDocInProtectedView Then
        On Error Resume Next
        sText = ActiveDocument.Name
        If err = 4248 Then 'This command is not available because no document is open.
            DocCountZeroOrDocInProtectedView = True
        End If
        On Error GoTo 0
    End If
End Function

'++*******************************************************************
' Description:  Retrieves any of the file properties from a non open
'                   file.
' Parameters:   sFilePath - Full path and name of file.
'               iPropertyNo - Property number to return.
' Returns:      The requested property's value.
'--********************************************************************
Function FilePropertyGet(sFilePath As String, property As EFileProperty) As String
    Dim oShell As Shell32.Shell
    Dim oDir As Shell32.Folder
    
    Dim sPath As String
    Dim sFile As String
    Dim doc As Document
    Dim bDocWasSaved As Boolean
    Dim oFso As FileSystemObject
    
    Set oFso = New FileSystemObject
    sPath = oFso.GetParentFolderName(sFilePath)
    sFile = oFso.GetFileName(sFilePath)
    
    'First check the template's not loaded because there's a weird bug that hides _
     a Templates 's Tags/Keywords property if the template is loaded
    Select Case property
    Case EFileProperty.Tags:
        For Each doc In Documents
            If doc.AttachedTemplate.Name = sFile Then
                'The template we need is actually loaded so get the property through _
                 the built in properties for the template
                 
                'Now, believe it or not, getting this property from the attached template will _
                 make it dirty so we need to deal with that by remembering its status before _
                 we call for the property
                bDocWasSaved = doc.AttachedTemplate.Saved
                FilePropertyGet = doc.AttachedTemplate.BuiltInDocumentProperties(wdPropertyKeywords)
                If doc.AttachedTemplate.Saved <> bDocWasSaved Then
                    doc.AttachedTemplate.Saved = bDocWasSaved
                End If
                Exit For
            End If
        Next doc
        
        If doc Is Nothing Then
            'If a starter doc has been initiated, it will have left its project "hanging around" in the _
             VBA environment. If that is the situation the above loop will not have found it if all the _
             docs based on that template are now closed. However, this next little to do will find that _
             Template that 's been left hanging around
            'Now, believe it or not, getting this property from the attached template will _
             make it dirty so we need to deal with that by remembering its status before _
             we call for the property
            On Error Resume Next 'In case the above is not the situation
            bDocWasSaved = Templates(sFilePath).Saved
            If err = 0 Then
                'Yep, here it is hanging around!!!
                FilePropertyGet = Templates(sFilePath).BuiltInDocumentProperties(wdPropertyKeywords)
                If Templates(sFilePath).Saved <> bDocWasSaved Then
                    Templates(sFilePath).Saved = bDocWasSaved
                End If
            End If
        End If
    Case Else:
        'If we didn't find the property we wanted above
        Set oShell = New Shell
        Set oDir = oShell.NameSpace(sPath & "\")
        
        FilePropertyGet = oDir.GetDetailsOf(oDir.ParseName(sFile), CInt(property))
        
        Set oDir = Nothing
        Set oShell = Nothing
    End Select
End Function

'++*******************************************************************
' Description:  Resets the document styles, so they are the same as
'               styles in the template
' Parameters:   bAskForConfirmation - If true, yes/no messagebox
'                   will be shown
' Returns:      none
'--********************************************************************
Sub ResetToDefaultStyles(Optional bAskForConfirmation As Boolean = True)
    Dim nAns As VbMsgBoxResult
    
    If Not modPrivate.DocCountZeroOrDocInProtectedView Then
        'Need to see if the current document is not a template
        If ActiveDocument.Type = wdTypeDocument Then
            If bAskForConfirmation Then
                nAns = modError.DisplayMsg("Reset the current document to default styles?", vbQuestion + vbOKCancel, "Reset document to Default styles")
            Else
                nAns = vbOK
            End If
            
            If nAns = vbOK Then
                'Update the styles
                ActiveDocument.UpdateStyles
                On Error Resume Next
                'Remove the bullets
                ActiveDocument.Styles("Normal").LinkToListTemplate ListTemplate:=Nothing
                'Perform any local post update processing if it exists
                modPublic.GlobalDirectivesSendMessage "RunPostStyleResetProcess", Nothing
                On Error GoTo 0
                
                'Now, just in case there are, for example, some doc template style buttons that _
                 need now to be invalidated, invalidate the whole ribbon
                modRibbon.InvalidateRibbon
            End If
        Else
            modError.DisplayMsg "The document is a template and therefore cannot be reset!", vbExclamation, "Reset to Default Styles"
        End If
    Else
        modError.DisplayMsg "There are no documents open!", vbExclamation, "Reset to Default Styles"
    End If
End Sub

'++*******************************************************************
' Description:  Removes double spaces from document and replaces
'               them with single spaces
' Parameters:   none
' Returns:      none
'--********************************************************************
Public Sub RemoveDoubleSpaces()
    Dim count As Integer
    Dim messageSuffix As String
    Dim title As String
    
    count = DoTextReplacementInSelection(" {2,}", " ", title)
    
    If Selection.Type = wdSelectionIP Then
        messageSuffix = "below the selected point in the document."
    Else
        messageSuffix = "from the selection."
    End If
    
    If count > 0 Then
        modError.DisplayMsg count & " double space" & IIf(count > 1, "s", vbNullString) & " removed " & messageSuffix, , title
    Else
        modError.DisplayMsg "No double spaces found " & messageSuffix, , title
    End If
End Sub

'++********************************************************************
' Description:  Removes double pargraph break characters from document
'               and replaces them with single paragraph break
' Parameters:   none
' Returns:      none
'--********************************************************************
Public Sub RemoveDoubleParagraphs()
    Dim count As Integer
    Dim messageSuffix As String
    Dim title As String
    
    count = DoTextReplacementInSelection("^13{2,}", "^p", "Removing double paragraphs")
    
    If Selection.Type = wdSelectionIP Then
        messageSuffix = "below the selected point in the document."
    Else
        messageSuffix = "from the selection."
    End If
    
    If count > 0 Then
        modError.DisplayMsg count & " double paragraph break" & IIf(count > 1, "s", vbNullString) & " removed " & messageSuffix, , title
    Else
        modError.DisplayMsg "No double paragraph breaks found " & messageSuffix, , title
    End If
End Sub

'++********************************************************************
' Description:  Replaces given text with replacement in selected text
'               or in text after current selection if nothing is selected
' Parameters:   text - what we want to replace
'               replacement - what will replace text
'               operation name - Name of the operation for undorecord
' Returns:      Number of replacements done
'--********************************************************************
Private Function DoTextReplacementInSelection(text As String, replacement As String, operationName As String) As Long
    Dim oRange As Range
    Dim count As Long
    
    Set oRange = Selection.Range
    ' wdSelectionIP means that nothing is selected. selection.start=selection.end.
    ' Do the search from selection to the end of the story
    If Selection.Type = wdSelectionIP Then
        oRange.WholeStory
        oRange.Start = Selection.Start
    End If
    
    DoTextReplacementInSelection = DoTextReplacementInRange(text, replacement, oRange, operationName)
End Function

'++********************************************************************
' Description:  Replaces given text with replacement in given range
' Parameters:   text - what we want to replace
'               replacement - what will replace text
'               oRange - Range where the replacement will be done
'               operation name - Name of the operation for undorecord
' Returns:      Number of replacements done
'--********************************************************************
Private Function DoTextReplacementInRange(text As String, replacement As String, oRange As Range, operationName As String)
    Dim oUndoRecord As cUndoRecord
    Dim count As Long
    
    On Error GoTo ErrorHandler
        
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "operationName"
'
    ScreenUpdating_Disable
    
    count = Len(oRange.text)
    
    AddSomethingToUndoStack oRange
    
    If oRange.End > oRange.Start Then
        With oRange.Duplicate.Find
            .ClearFormatting
            .ClearAllFuzzyOptions
            .text = text
            .replacement.text = replacement
            .Forward = True
            .Wrap = wdFindStop
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = True
            .MatchSoundsLike = False
            .MatchAllWordForms = False

            .Execute Replace:=wdReplaceAll
        End With
    End If
    
    count = count - Len(oRange.text)
    'GetSubstringCount(oRange.text, text)
    
    DoTextReplacementInRange = count
CleanExit:
    oUndoRecord.EndRecording
    ScreenUpdating_Enable
    Exit Function
    
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "DoTextReplacementInRange"
    DoTextReplacementInRange = 0
    Resume CleanExit
End Function

'++********************************************************************
' Description:  There is a bug in word where if undostack is empty
'               and we call orange.Finde.Execute, it can crash word
'               so we have to add something into the undostack.
'               This function will add and immediatelly remove space
'               from start of given range.
' Parameters:   oRange - range at the beginning of which the space will
'                   be temporarily created
' Returns:      n/a
'--********************************************************************
Private Sub AddSomethingToUndoStack(oRange As Range)
    Dim myRange As Range
    
    Set myRange = oRange.Duplicate
    myRange.Collapse wdCollapseStart
    myRange.text = " "
    myRange.text = ""
End Sub

'++********************************************************************
' Description:  Gets the number of substring occurences within given string
' Parameters:   text - String to be searched for substrings
'               substring - what we are looking for
' Returns:      Number of substring withing given string
'--********************************************************************
Private Function GetSubstringCount(text As String, substring As String) As Long
    GetSubstringCount = (Len(text) - Len(Replace(text, substring, "", , , vbTextCompare))) / Len(substring)
End Function


'*******************************************************************************************************
'* Description: Checks if the paragraph is truly empty. Having only a column break in the paragraph is
'*              OK. Having a page break is only OK if it's the last para in the doc.
'* Parameters:  N/A
'* Returns:     True=Paragraph can be assumed empty
'*******************************************************************************************************
Public Function IsParagraphTrulyEmpty() As Boolean
    Dim iAscVal As Integer
    
    Select Case Selection.Paragraphs(1).Range.Characters.count
        Case 1
            IsParagraphTrulyEmpty = True
        Case 2
            iAscVal = Asc(Selection.Paragraphs(1).Range.text)
            'Ascii 12=page break, 14=column break
            IsParagraphTrulyEmpty = iAscVal = 12 Or iAscVal = 14
            If IsParagraphTrulyEmpty Then
                If iAscVal = 12 Then
                    'It's a page break
                    'All's well if it's the last para in the document
                    IsParagraphTrulyEmpty = Selection.End = ActiveDocument.Range.End
                End If
            End If
        Case Else
            IsParagraphTrulyEmpty = False
    End Select
End Function

'*******************************************************************************************************
'* Description: Checks if it's OK to perform an operation for the current selection.
'* Parameters:  sMsgDesc - Description of operation
'*              Series of optional boolean values to control what's tested.
'* Returns:     True if OK to perform operation here. False if not OK.
'*******************************************************************************************************
Public Function IsOperationOkToDo(sMsgDesc As String, pWhatToTest As ESelectionTests) As Boolean
    Dim sMsgCaption As String
    
    sMsgCaption = COMPANY_NAME & " - " & sMsgDesc
    
    IsOperationOkToDo = False 'Assume it can't be done here
        
    If Application.Documents.count = 0 Then
        modError.DisplayMsg sMsgDesc & " can only be performed if a document is opened", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And EnsureNothingSelected) And Selection.Type <> wdSelectionIP Then
        modError.DisplayMsg sMsgDesc & " can only be performed if nothing is selected.", vbInformation, sMsgCaption
    'Check that not in a textbox
    ElseIf (pWhatToTest And NotInTextBox) And Selection.ShapeRange.count > 0 Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a textbox.", vbInformation, sMsgCaption
    'Check not in Header and Footer
    ElseIf (pWhatToTest And NotInHdrOrFtr) And Selection.Information(wdInHeaderFooter) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Header or Footer.", vbInformation, sMsgCaption
    'Check not in Footnote or Endnote
    ElseIf (pWhatToTest And NotInFtOrEndNote) And Selection.Information(wdInFootnoteEndnotePane) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Footnote or EndNote Pane.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInEndNote) And Selection.Information(wdInEndnote) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in an EndNote.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInFootNote) And Selection.Information(wdInFootnote) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a FootNote.", vbInformation, sMsgCaption
        'TODO
    ElseIf (pWhatToTest And NotInContentControl) And modContentControls.IsSelectionInCC(Selection.Range) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Content Control.", vbInformation, sMsgCaption
    'Check to see if the selection includes all or part of a table
    ElseIf (pWhatToTest And NotInTable) And Selection.Information(wdWithInTable) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a Table.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And MustBeEmptyPara) And (modPrivate.IsParagraphTrulyEmpty() = False) Then
        modError.DisplayMsg sMsgDesc & " can only be performed when in an empty (blank) paragraph.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInFrame) And Selection.Frames.count > 0 Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when in a framed paragraph.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And MustBeInTable) And Selection.Tables.count = 0 Then
        modError.DisplayMsg sMsgDesc & " cannot be performed unless a table is selected.", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInTable) And _
        (Selection.Tables.count > 0 And (Selection.Information(wdEndOfRangeRowNumber) <> -1 And Not Selection.Type <> wdSelectionIP)) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when the selection contains a table", vbInformation, sMsgCaption
    ElseIf (pWhatToTest And NotInProtectedSection) And (Not IsInEditableSection(Selection.Range)) Then
        modError.DisplayMsg sMsgDesc & " cannot be performed when the selection is is a protected section", vbInformation, sMsgCaption
    Else
        IsOperationOkToDo = True
    End If
End Function

'*******************************************************************************************************
'* Description: Gets width of textcolum the given range is in.
'* Parameters:  oRange - Range object
'* Returns:     Width in points of textcolumn containing the given range
'* Remarks      This function will change selection temporarily
'*******************************************************************************************************
Public Function getRangeColumnWidth(oRange As Range) As Double
    Dim oSaveRange As Range
    
    On Error GoTo ErrorHandler
    Set oSaveRange = Selection.Range.Duplicate
    
    oRange.Select
    getRangeColumnWidth = oRange.Sections(1).PageSetup.TextColumns(Dialogs(wdDialogFormatColumns).ColumnNo).Width
    
CleanExit:
    oSaveRange.Select
    Exit Function
ErrorHandler:
    getRangeColumnWidth = 0
End Function


'++*******************************************************************
' Description:  Adds or sets the value of a document variable of the
'               passed in name and value.
' Parameters:   sName => The variable name.
'               sValue => The variable value.
' Returns:      N/A
'--********************************************************************
Sub SetDocVar(ByVal sName As String, ByVal sValue As String)
    On Error GoTo SetDocVar_EH
    ActiveDocument.Variables.Add Name:=sName, value:=sValue
    Exit Sub

SetDocVar_EH:
    Select Case err.Number
      Case 5903 'Variable already exists just set the value
          ActiveDocument.Variables(sName).value = sValue
      Case Else
        Const sProcedure As String = "SetDocVar"
        modError.GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Sub

'++*******************************************************************
' Description:  Returns the value of a document variable of the
'               passed in name.
' Parameters:   sName => The variable name.
' Returns:      String. The value of the variable or Null if it does
'               not exist.
'--********************************************************************
Function sGetDocVar(ByVal sName As String) As String
    On Error GoTo sGetDocVar_EH
    sGetDocVar = ActiveDocument.Variables(sName).value
    Exit Function

sGetDocVar_EH:
    Select Case err.Number
      Case 5825 'Variable does not exist
        sGetDocVar = vbNullString
      Case Else
        Const sProcedure As String = "sGetDocVar"
        GlobalErrorHandler err.Number, sProcedure, MODULE_NAME, err.Description
    End Select
End Function

Sub ListDocumentVariable()

Dim dv As Variable

    For Each dv In ActiveDocument.Variables
        Debug.Print dv.Name & " - " & dv.value
        
    Next


End Sub

'++*******************************************************************
' Description:  Trims all strings in given array
' Parameters:   retArray => Array of strings that will be trimmed
' Returns:      n/a
'--********************************************************************
Public Sub TrimArray(retArray() As String)
    Dim i As Integer
    
    For i = LBound(retArray) To UBound(retArray)
        retArray(i) = Trim$(retArray(i))
    Next i
End Sub

'++*******************************************************************
' Description:  This function just makes inserting autotext a little
'               bit easier, because intellisense doesn't work on
'               autotextEntries object.
' Parameters:   autotextName - Name of the autotext
'               oRange - Range where the autotext will be inserted
'               optional richText as Boolean - Should be inserted as rich text?
' Returns:      True if successfull, false otherwise
'--********************************************************************
Public Function InsertAutotext(autotextName As String, oRange As Range, Optional richtext As Boolean = True, Optional bDeleteLastPara As Boolean = False) As Boolean
    On Error GoTo ErrorHandler
    ActiveDocument.AttachedTemplate.AutoTextEntries(autotextName).Insert oRange, richtext
    
    If bDeleteLastPara Then
        oRange.Collapse wdCollapseEnd
        oRange.MoveEnd wdCharacter, 1
        If Asc(oRange.Characters(1)) = 13 Then
            oRange.Delete
        End If
    End If
    
    
    InsertAutotext = True
CleanExit:
    Exit Function
ErrorHandler:
    InsertAutotext = False
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  This function just makes inserting autotext a little
'               bit easier, because intellisense doesn't work on
'               autotextEntries object.
' Parameters:   autotextName - Name of the autotext
'               oRange - Range where the autotext will be inserted
'               optional richText as Boolean - Should be inserted as rich text?
' Returns:      True if successfull, false otherwise
'--********************************************************************
Public Function InsertAutotextGetRange(autotextName As String, oRange As Range, Optional richtext As Boolean = True) As Range
    On Error GoTo ErrorHandler
    
    Set InsertAutotextGetRange = ActiveDocument.AttachedTemplate.AutoTextEntries(autotextName).Insert(oRange, richtext)
    
    
CleanExit:
    Exit Function
ErrorHandler:
    
    Resume CleanExit
End Function
    
'++*******************************************************************
' Description:  Returns trimmed text of a paragraph
' Parameters:   Para - Paragraph of which text we want to know
' Returns:      Text of the paragraph without any white space left and right
'--********************************************************************
Public Function GetParagraphText(para As Paragraph) As String
    GetParagraphText = TrimText(para.Range.text)
End Function

'++*******************************************************************
' Description:  There is a trimm function in word, but it's pretty
'               uselles. It won't even trim tabs and end of para character
' Parameters:   text - string to be trimmed
'               trimLeft - If true, left of the text will be trimmed
'               trimRight - If true, Right of the text will be trimmed
' Returns:      Text without white character left or right
'--********************************************************************
Public Function TrimText(text As String, Optional trimRight As Boolean = True, Optional trimLeft As Boolean = True) As String
    Dim controlCharacter As String
    
    If LenB(text) = 0 Then
        TrimText = text
    Else
        If trimLeft Then
            controlCharacter = Left(text, 1)
            Do While isWhiteSpace(controlCharacter) And LenB(text) > 0
                text = Right(text, Len(text) - 1)
                controlCharacter = Left(text, 1)
            Loop
        End If
        
        If trimRight Then
            controlCharacter = Right(text, 1)
            Do While isWhiteSpace(controlCharacter) And LenB(text) > 0
                text = Left(text, Len(text) - 1)
                controlCharacter = Right(text, 1)
            Loop
        End If
        TrimText = text
    End If
End Function

'++*******************************************************************
' Description:  VBA doesn't have any buildin isWhiteChar function.
'               This function will find out if the character is white
' Parameters:   text - One character string to test
' Returns:      True if the text is white character
'               False otherwise
' Remarks       The list of white characters is probably incomplete.
'--********************************************************************
Public Function isWhiteSpace(text As String) As Boolean
    isWhiteSpace = text = vbTab Or _
                    text = vbVerticalTab Or _
                    text = " " Or _
                    text = Chr(160) Or _
                    text = Chr(7) Or _
                    text = Chr(13)
End Function

'*******************************************************************************************************
'* Description: Deletes the last paragraph in the range is its empty. Useful after inserting autotext,
'*              which creates extra empty paragraph.
'* Parameters:  n/a
'* Returns:     n/a
'*******************************************************************************************************
Public Sub DeleteLastEmptyPara(oRange As Range)
    On Error GoTo ErrorHandler:
    
    If oRange.Paragraphs.count > 1 Then
        If Len(oRange.Paragraphs(oRange.Paragraphs.count).Range.text) = 1 Then
            oRange.Paragraphs(oRange.Paragraphs.count).Range.Delete
        End If
    End If
CleanExit:
    Exit Sub
ErrorHandler:
    Resume CleanExit
End Sub

'++*********************************************************************************
' Description:  Will try and download the style from the attached template. Will
'               return True if style is downloaded and False if not found in the template
' Parameters:   sStyleName - Name of style to try and download
' Returns:      n/a
'--********************************************************************************
Public Function DownloadStyle(sStyleName As String) As Boolean
    Dim oTmp As template

    On Error GoTo StyleNotInTemplate
    
    'Make a link to the attached template
    Set oTmp = ActiveDocument.AttachedTemplate
    'Try down loading the style
    Application.OrganizerCopy Source:=oTmp.path & Application.PathSeparator & oTmp.Name, _
        Destination:=ActiveDocument, Name:=sStyleName, Object:=wdOrganizerObjectStyles

    DownloadStyle = True
    Exit Function

StyleNotInTemplate:

    DownloadStyle = False

End Function

'++*********************************************************************************
' Description:  Returns an item from list using the Split. If not a valid item then
'               return and empty string
' Parameters:   sStyleName - Name of style to try and download
' Returns:      n/a
'--********************************************************************************
Function SplitWithoutError(sText As String, sFindStr As String, iElementNo As Integer) As String

    Dim sResult As String

    SplitWithoutError = ""

    On Error GoTo NoElementFound
    sResult = Split(sText, sFindStr)(iElementNo)
    SplitWithoutError = sResult
    
NoElementFound:

End Function

'++*********************************************************************************
' Description:  Return the registry setting or ablank string if none has been set
' Parameters:   Section - Registry Section
'               Key - Key name
' Returns:      n/a
'--********************************************************************************
Function GetRegistrySettingString(Section As String, Key As String) As String

    Dim RetStr As String
    
    On Error GoTo NoRegistrySettings
    RetStr = System.ProfileString(Section, Key)
    
    GetRegistrySettingString = RetStr
    GoTo EndGetRegistrySettingString
    
NoRegistrySettings:
    GetRegistrySettingString = ""
    
EndGetRegistrySettingString:

End Function

'++*********************************************************************************
' Description:  Set the registry setting
' Parameters:   Section - Registry Section
'               Key - Key name
' Returns:      n/a
'--********************************************************************************
Sub SetRegistrySettingString(Section As String, Key As String, sValue As String)


    On Error GoTo NoRegistrySettings
    System.ProfileString(Section, Key) = sValue
    
NoRegistrySettings:


End Sub

'++*******************************************************************
' Description:  Checks a given range for a list of one or more styles
' Parameters:   rWhere - Range to search
'               StylesToCheck - A list of one or more styles for which
'               to look in rWhere.
' Returns:      True=Found; False=Not found
'--********************************************************************
Function StyleExists(rWhere As Range, ParamArray StylesToCheck()) As Boolean
        
    Dim i As Integer
    
    rWhere.Find.ClearFormatting
    
    For i = 0 To UBound(StylesToCheck, 1)
        rWhere.Find.Style = ActiveDocument.Styles(StylesToCheck(i))
        StyleExists = rWhere.Find.Execute
        If StyleExists Then
            Exit Function
        End If
    Next i
    
    StyleExists = False
    
End Function

'++*******************************************************************
' Procedure:    ComboBoxFill
' Author:       Brochet ltd
' Description:  Fills a FillComboBox with settings from ini file
' Parameters:   sFileName - the ini file name
'               sSecName - the section name in the ini file
'               sItemName - the sequence item name in the ini file (1, 2 ...)
'               sCombbox - the combobox name to be filled
' Returns:      N/A
'--********************************************************************
Sub ComboBoxFill(sFileName As String, sSecName As String, sItemName As String, sCombbox As Object)

    Dim sTextNum, sText As String
    Dim i As Integer

    sTextNum = sItemName + "1"
    i = 1
    sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    While sText <> ""
        sCombbox.AddItem (sText)
        If sCombbox.ColumnCount > 1 Then
            sCombbox.List(sCombbox.ListCount - 1, 1) = sItemName & i
        End If
        i = i + 1
        sTextNum = sItemName + LTrim(Str(i))
        sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    Wend

End Sub

'++*******************************************************************
' Procedure:    ComboBoxFill2
' Author:       Brochet ltd
' Description:  Fills a FillComboBox with settings from ini file
' Parameters:   sFileName - the ini file name
'               sSecName - the section name in the ini file
'               sItemName - the sequence item name in the ini file (1, 2 ...)
'               sCombbox - the combobox name to be filled
' Returns:      N/A
'--********************************************************************
Sub ComboBoxFill2(sFileName As String, sSecName As String, sItemName As String, sCombbox As Object, Optional sSplitChar As String = "|")

    Dim sTextNum, sText, sText2 As String
    Dim i As Integer
    Dim sArray() As String

    'First get the fill text from the ini file
    sTextNum = sItemName + "1"
    i = 1
    sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    While sText <> ""
        i = i + 1
        sText2 = sText2 + sText
        sTextNum = sItemName & i
        sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    Wend
    
    'Now split the text
    If sText2 <> "" Then
        sArray = Split(sText2, sSplitChar)
        For i = 0 To UBound(sArray)
            sCombbox.AddItem (sArray(i))
        Next
    End If

End Sub


'++*******************************************************************
' Procedure:    ComboBoxFillFiles
' Author:       Brochet ltd
' Description:  Fills a FillComboBox with filenames found in given directory
' Parameters:   sIniFile - the ini file name
'               sLocationSecName - The base directory containing the files.
'               sItemName - The item name of the path (normally 'Path')
'               cbxCombbox - The combobox name to be filled
' Returns:      N/A
'--********************************************************************
Sub ComboBoxFillFiles(sIniFile As String, sLocationSecName As String, sItemName As String, cmbCombBox As ComboBox)

    Dim sDir As String
    Dim sFlNm As String
    
    sDir = System.PrivateProfileString(sIniFile, sLocationSecName, sItemName)
    sDir = ExpandString(sDir)
    If Right$(sDir, 1) <> "\" Then
        sDir = sDir & "\"
    End If
    
    On Error GoTo InvalidPath
    sFlNm = Dir$(sDir & "*.*", vbNormal)
    On Error GoTo 0
    
    While sFlNm <> ""
        cmbCombBox.AddItem sFlNm
        If cmbCombBox.ColumnCount > 1 Then
            'If the combo has more than 1 column add the full path to the second column
            cmbCombBox.List(cmbCombBox.ListCount - 1, 1) = sDir & sFlNm
        End If
        sFlNm = Dir$()
    Wend

    Exit Sub

InvalidPath:

End Sub

'++*******************************************************************
' Procedure:    ComboBoxFillFiles
' Author:       Brochet ltd
' Description:  Fills a FillComboBox with filenames found in given directory
' Parameters:   sIniFile - the ini file name
'               sLocationSecName - The base directory containing the files.
'               sItemName - The item name of the path (normally 'Path')
'               cbxCombbox - The combobox name to be filled
' Returns:      N/A
'--********************************************************************
Sub ComboBoxFillSelectedFiles(sIniFile As String, sLocationSecName As String, sItemName As String, cmbCombBox As ComboBox, sMask As String)

    Dim sDir As String
    Dim sFlNm As String
    
    sDir = System.PrivateProfileString(sIniFile, sLocationSecName, sItemName)
    If Right$(sDir, 1) <> "\" Then
        sDir = sDir & "\"
    End If
    
    On Error GoTo InvalidPath
    sFlNm = Dir$(sDir & sMask, vbNormal)
    On Error GoTo 0
    
    While sFlNm <> ""
        cmbCombBox.AddItem sFlNm
        If cmbCombBox.ColumnCount > 1 Then
            'If the combo has more than 1 column add the full path to the second column
            cmbCombBox.List(cmbCombBox.ListCount - 1, 1) = sDir & sFlNm
        End If
        sFlNm = Dir$()
    Wend

    Exit Sub

InvalidPath:

End Sub

'++*******************************************************************
' Procedure:    ComboBoxFill
' Author:       Brochet ltd
' Description:  Fills a FillComboBox with settings from ini file
' Parameters:   sFileName - the ini file name
'               sSecName - the section name in the ini file
'               sItemName - the sequence item name in the ini file (1, 2 ...)
'               sCombbox - the combobox name to be filled
' Returns:      N/A
'--********************************************************************
Sub ComboBoxFillAndSplit(sFileName As String, sSecName As String, sItemName As String, sCombbox As ComboBox)

    Dim sTextNum, sText As String
    Dim i As Integer

    sTextNum = sItemName + "1"
    i = 1
    sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    While sText <> ""
        sCombbox.AddItem SplitWithoutError(sText, "|", 0)
        sCombbox.List(sCombbox.ListCount - 1, 1) = SplitWithoutError(sText, "|", 1)
        sCombbox.List(sCombbox.ListCount - 1, 2) = sText
        i = i + 1
        sTextNum = sItemName + LTrim(Str(i))
        sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    Wend

End Sub

'++*******************************************************************
' Procedure:    ComboBoxFill
' Author:       Brochet ltd
' Description:  Fills a FillComboBox with settings from ini file
' Parameters:   sFileName - the ini file name
'               sSecName - the section name in the ini file
'               sItemName - the sequence item name in the ini file (1, 2 ...)
'               sCombbox - the combobox name to be filled
' Returns:      N/A
'--********************************************************************
Sub ComboBoxFillAndSplitAll(sFileName As String, sSecName As String, sItemName As String, sCombbox As ComboBox)

    Dim sTextNum, sText As String
    Dim i As Integer
    Dim j As Integer
    Dim sArray() As String

    sTextNum = sItemName + "1"
    i = 1
    sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    While sText <> ""
    
            sArray = Split(sText, "|")
            For j = 0 To UBound(sArray)
                sCombbox.AddItem (sArray(j))
            Next
    
        i = i + 1
        sTextNum = sItemName + LTrim(Str(i))
        sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
    Wend

End Sub

''++*******************************************************************
'' Procedure:    ComboBoxFill
'' Author:       Brochet ltd
'' Description:  Fills a FillComboBox with settings from ini file
'' Parameters:   sFileName - the ini file name
''               sSecName - the section name in the ini file
''               sItemName - the sequence item name in the ini file (1, 2 ...)
''               sCombbox - the combobox name to be filled
'' Returns:      N/A
''--********************************************************************
'Sub ComboBoxFillFromSingleKey(sFileName As String, sSecName As String, sItemName As String, sCombbox As ComboBox)
'
'    Dim sTextNum, sText As String
'    Dim sArray() As String
'    Dim i As Integer
'
'    sTextNum = sItemName
'
'    sText = System.PrivateProfileString(sFileName, sSecName, sTextNum)
'    If sText <> "" Then
'
'            sArray = Split(sText, "|")
'            For i = 0 To UBound(sArray)
'                sCombbox.AddItem (sArray(i))
'                sCombbox.Column(2) = sItemName &
'            Next
'    End If
'
'End Sub

'++*******************************************************************
' Procedure:    SectionExists
' Author:       Brochet ltd
' Description:  This funtion will return true if the section exists
' Parameters:   sDocVarName - the name of the document variable
'               sBkMkName - the name of the bookmark
'       bCheckBookmark - if true, search for bookmark overrides
'           search for document variable
' Returns:      True or False
'--********************************************************************
Function SectionExists(sDocVarName As String, sBkMkName As String, Optional bCheckBookmark As Boolean = True) As Boolean

    Dim bExists As Boolean

    'First see if the document variable exists
    bExists = modPrivate.DocVarGet(sDocVarName) = "True"
    'Secondly check that the bookmark in the section exists
    If bCheckBookmark Then
        'Check that the bookmark exists
        If bExists And Not ActiveDocument.Bookmarks.Exists(sBkMkName) Then
            'the bookmark is missing
            bExists = False
        ElseIf Not bExists And ActiveDocument.Bookmarks.Exists(sBkMkName) Then
            'the exist so the section exists
            bExists = True
        End If
    End If

    SectionExists = bExists

End Function


'++*******************************************************************
' Procedure:    PathWithEnvironmentVariable
' Description:  Replaces environment variables (enclosed in percentage
'               signs) with their value.
' Parameters:   sPath - Incoming path
' Returns:      Path including the environment variables
'--********************************************************************
Function PathWithEnvironmentVariable(ByVal sPath As String) As String

    Dim i As Integer
    Dim j As Integer
    Dim sText As String
    
    Do
    
        'Find the start and end location of the %text%
        i = InStr(sPath, "%")
        If i = 0 Then
            Exit Do
        End If
        j = InStr(i + 1, sPath, "%")
        If j = 0 Then
            Exit Do
        End If
        
        'Get the text part of the string
        sText = Mid$(sPath, i + 1, j - i - 1) 'The env var minus the %s around it
        Select Case sText
            Case "Workgroup"
                sText = Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath)
            Case "User"
                sText = Application.Options.DefaultFilePath(wdUserTemplatesPath)
            Case Else
                sText = Environ(sText)
        End Select
        
        sPath = Left$(sPath, i - 1) & sText & Mid$(sPath, j + 1)
          
    Loop
    
    'Remove any trailing back slashes
    Do Until Right$(sPath, 1) <> "\"
        sPath = Left$(sPath, Len(sPath) - 1)
    Loop
    
    PathWithEnvironmentVariable = sPath
    
End Function

Function RemoveLastBackslash(sPath) As String

    RemoveLastBackslash = ""
    If sPath <> "" Then
        If Mid(sPath, Len(sPath), 1) = "\" Then
            RemoveLastBackslash = Mid(sPath, 1, Len(sPath) - 1)
        Else
            RemoveLastBackslash = sPath
        End If
    End If
    
End Function

'++*******************************************************************
' Procedure:    FirstLine
' Author:       Brochet ltd
' Description:  Returns the first line of a string of text
' Parameters:   sText - string to update
' Returns:      sText - first line of the string
'--********************************************************************
Function FirstLine(sText) As String

    Dim iPos As Integer

    iPos = InStr(1, sText, vbCr)
    If iPos > 0 Then
        FirstLine = Mid(sText, 1, iPos - 1)
    Else
        FirstLine = sText
    End If


End Function

Attribute VB_Name = "modPublic"
'************************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modGlobalPublic
'*
'* Holds code for global calls available from any template, and calling methods
'* from other templates.
'************************************************************************************
Option Explicit

Private Const MODULE_NAME As String = "modPublic"

#If VBA7 Then
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function GetSystemMenu Lib "user32" (ByVal HWND As Long, ByVal bRevert As Long) As Long
    Private Declare PtrSafe Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

    Private Declare PtrSafe Function ExtractIcon Lib "shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
    Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal HWND As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long
#Else
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function GetSystemMenu Lib "user32" (ByVal HWND As Long, ByVal bRevert As Long) As Long
    Private Declare Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

    Private Declare Function ExtractIcon Lib "shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
    Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal HWND As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long
#End If

' TODO this needs to be module that holds global directive functions in user templates
Private Const MODULE_TO_CALL As String = "ModGlobalPublic"

Public Enum EDirectiveReturnType
    ReturnString = 0
    ReturnNumeric = 1
    ReturnBoolean = 2
End Enum

Public Enum ESelectionTests
  EnsureNothingSelected = 1
  NotInTextBox = 2
  NotInHdrOrFtr = 4
  NotInFtOrEndNote = 8
  NotInEndNote = 16
  NotInFootNote = 32
  NotInFrame = 64
  NotInTable = 128
  NotInContentControl = 256
  NotInAny = 511
  MustBeEmptyPara = 512
  MustBeInTable = 1024
  NotInProtectedSection = 2048
  All = 2147483647
End Enum
Private Const WM_SETICON = &H80

'++*******************************************************************
' Description:  This is the macro called by the double click to insert
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Public Sub DoubleClickToInsertRFPImage()

    modInsertImage.MacroInsertExcelOrShowFrmInsertImage True


End Sub


'++*******************************************************************
' Description:  Calls the active document's template's 'GlobalDirectives'
'               procedure to retrieve parameters on
'               such things as whether to hide or show the Styles
'               group on the ribbon.
'               NOTE: Only the active document's template is checked
'               for the procedure being called
' Parameters:   sDirectiveName - name of the parameter to return.
' Returns:      The value of the parameter
'--********************************************************************
Public Function GlobalDirectivesReceiveMessage(messageName As String, Optional param1 As Variant, Optional param2 As Variant, _
                            Optional param3 As Variant, Optional param4 As Variant, Optional param5 As Variant, _
                            Optional param6 As Variant, Optional param7 As Variant, Optional param8 As Variant, _
                            Optional param9 As Variant, Optional param10 As Variant, Optional param11 As Variant) As Variant
    On Error GoTo ErrorHandler:
    
    GlobalDirectivesReceiveMessage = Empty
    
    Select Case messageName
    Case "PreUpdateFields"

    Case "PostUpdateFields"
        'Update Content COntrol style, this avoids a styleref bug with Content Controls
        'modContentControls.ApplyStyle "Section Heading", "Heading 2Char"
        'modContentControls.RefreshContentControlStyles

        
    Case "GetTemplateVersion"
        GlobalDirectivesReceiveMessage = modGlobal.TEMPLATE_VERSION
    Case "GetTemplateDate"
        GlobalDirectivesReceiveMessage = modGlobal.TEMPLATE_DATE
   Case "GrpBrochetTables_getVisible"
        GlobalDirectivesReceiveMessage = True
    Case "SelectionOkForFileInsert"
            GlobalDirectivesReceiveMessage = modPrivate.IsOperationOkToDo("Insert File", NotInAny + NotInProtectedSection)
    Case "isOkToInsertTable"
            GlobalDirectivesReceiveMessage = modPrivate.IsOperationOkToDo("Insert Table", MustBeEmptyPara + NotInAny + NotInProtectedSection)
    Case "TableOkToReformat"
        GlobalDirectivesReceiveMessage = modPrivate.IsOperationOkToDo("Modify Table Table", MustBeInTable + NotInProtectedSection)
    Case "TableOkToReformatSelectedCells"
        GlobalDirectivesReceiveMessage = modPrivate.IsOperationOkToDo("Modify Selection", MustBeInTable + NotInProtectedSection)
    Case "RunPostRibbonInvalidateProcess"
        modRibbon.InvalidateRibbon
    Case "ApplyTableTitle"
    Case "GetTemplateID"
        GlobalDirectivesReceiveMessage = TEMPLATE_NAME
    Case Else:
    End Select
    
CleanExit:
    Exit Function
ErrorHandler:
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  This is a deprecated global directive function.
'               This function will call a function in the template of
'               active document, expecting a string as the return value.
' Parameters:   sDirectiveName - name of the function to call
'               iTypeOfReturn - Type of the returned value.
'                       Can be one of EDirectiveReturnType.
'               defaultValue - If User template doesn't return any value
'                   for whatever reason, this will be used as return value instead.
'
' Returns:      The value of the parameter
'--********************************************************************
Public Function GlobalDirectivesGet(sDirectiveName As String, Optional iTypeOfReturn As EDirectiveReturnType = EDirectiveReturnType.ReturnString, Optional defaultValue As Variant) As Variant
    On Error Resume Next
    GlobalDirectivesGet = Application.Run(MODULE_TO_CALL & ".GlobalDirectives", sDirectiveName)
    
    If err Or IsEmpty(GlobalDirectivesGet) Then
        'Either the routine being missing from the target or the directive has _
         not been set by the target template
        
        'Set either the requested default or type relevant default
        If Not IsMissing(defaultValue) Then
            GlobalDirectivesGet = defaultValue
        Else
            'If no default values have been returned, return the variable type's default
            GlobalDirectivesGet = Choose(iTypeOfReturn + 1, vbNullString, 0, False)
        End If
    Else
        On Error GoTo ErrorHandler
        'Ensure the returned variable is of the right type
        Select Case iTypeOfReturn
            Case ReturnBoolean
                If VarType(GlobalDirectivesGet) <> vbBoolean Then
                    GlobalDirectivesGet = GlobalDirectivesGet = "True"
                End If
            Case ReturnNumeric
                If Not IsNumeric(GlobalDirectivesGet) Then
                    GlobalDirectivesGet = Val(GlobalDirectivesGet)
                End If
            Case ReturnString
                GlobalDirectivesGet = CStr(GlobalDirectivesGet)
        End Select
    End If
    
CleanExit:
    Exit Function
    
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "GlobalDirectivesGet"
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Calls the active document's template's
'               GlobalDirectivesReceiveMessage  procedure to
'               retrieve parameters on
'               such things as whether to hide or show the Styles
'               group on the ribbon, or to invoke a method in the template.
'
'               NOTE: Only the active document's template is checked
'               for the procedure being called
' Parameters:   sDirectiveName - name of the message to send
'               defaultValue - This will be used as return value if the message
'                   can't be properly handled
'               parameters() - List of up to 11 parameters for the called message
' Returns:      The value that the function handling the message returned
'               or default value if message handling function failed
'--********************************************************************
Public Function GlobalDirectivesSendMessageNoConfirmation(sDirectiveName As String, defaultValue As Variant, _
                        Optional param1 As Variant, Optional param2 As Variant, _
                        Optional param3 As Variant, Optional param4 As Variant, Optional param5 As Variant, _
                        Optional param6 As Variant, Optional param7 As Variant, Optional param8 As Variant, _
                        Optional param9 As Variant, Optional param10 As Variant, Optional param11 As Variant) As Variant
                        
    On Error GoTo ErrorHandler
    
    GlobalDirectivesSendMessage sDirectiveName, defaultValue, _
                    param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11
        
    
CleanExit:
    SetVariant GlobalDirectivesSendMessageNoConfirmation, defaultValue
    Exit Function
ErrorHandler:
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  Calls the active document's template's
'               GlobalDirectivesReceiveMessage  procedure to
'               retrieve parameters on
'               such things as whether to hide or show the Styles
'               group on the ribbon, or to invoke a method in the template.
'
'               NOTE: Only the active document's template is checked
'               for the procedure being called
' Parameters:   sDirectiveName - name of the message to send
'               retValue - The value that the function handling the message
'                   returns.
'               parameters() - List of up to 11 parameters for the called message
' Returns:      True if the call was succesfull, false otherwise
'--********************************************************************
Public Function GlobalDirectivesSendMessage(sDirectiveName As String, ByRef retValue As Variant, _
                            Optional param1 As Variant, Optional param2 As Variant, _
                            Optional param3 As Variant, Optional param4 As Variant, Optional param5 As Variant, _
                            Optional param6 As Variant, Optional param7 As Variant, Optional param8 As Variant, _
                            Optional param9 As Variant, Optional param10 As Variant, Optional param11 As Variant) As Boolean
    On Error Resume Next
    Dim result As Variant
    
    SetVariant result, Application.Run(MODULE_TO_CALL & ".GlobalDirectivesReceiveMessage", sDirectiveName, _
                                param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11)
    
    If err Or IsEmpty(result) Then
        'If no default values have been returned, return the variable type's default
        GlobalDirectivesSendMessage = False
    Else
        GlobalDirectivesSendMessage = True
        SetVariant retValue, result
    End If
    
CleanExit:
    Exit Function
    
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "GlobalDirectivesGet"
    Resume CleanExit
End Function

'++*******************************************************************
' Description:  When function returns a variant, it's hard to
'               assign the result to a variable, because if its
'               one of the basic type (e.g. integer) we need a simple
'               assigment var = value. But if it's object we need set.
'               This procedure will assign any value in into given variant
' Parameters:   variantToSet - Variant variable we need to change
'               value - What should be new value of variant. Any type
' Returns:      n/a
'--********************************************************************
Private Sub SetVariant(ByRef variantToSet As Variant, value As Variant)
    If IsObject(value) Then
        Set variantToSet = value
    Else
        variantToSet = value
    End If
End Sub


'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'                                 STILL TO CHECK
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************
'******************************************************************************************************************

'*******************************************************************************************************
'* Description: Diables the close button on a userform. If the userform has a short caption, it may be
'*              safer to change it to something crazy first, so it doeasn't change other window by accident
'* Parameters:  sFormCaption - The Caption of the form
'* Returns:     True if function finished without errors, false otherwise
'*******************************************************************************************************
Private Function DisableCloseButton(sFormCaption As String, Optional sIconPath As String = vbNullString) As Boolean
    Dim lnghWnd As Long
    Dim sThunderVers As String
    Dim lIcon As Long
    Const MF_BYPOSITION = &H400&
    
    On Error GoTo ErrorHandler
    
    'Which type of userform
    If Val(Application.Version) >= 9 Then
       sThunderVers = "ThunderDFrame"
    Else
       sThunderVers = "ThunderXFrame"
    End If

    lnghWnd = FindWindow(sThunderVers, sFormCaption)
    
    RemoveMenu GetSystemMenu(lnghWnd, 0), 6, MF_BYPOSITION 'When using by position, 6 represents the 7th menu item (including separators)
    
    If sIconPath <> vbNullString Then
        lIcon = ExtractIcon(0, sIconPath, 0)
        ' Get the window handle of the userform
        'Set the big (32x32) and small (16x16) icons
        'SendMessage lnghWnd, WM_SETICON, True, lIcon 'Set big (32x32) icon
        SendMessage lnghWnd, WM_SETICON, False, lIcon 'Set small (16x16) icon
    End If
    
    DisableCloseButton = True
    
CleanExit:
    Exit Function
ErrorHandler:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "DisableCloseButton"
    Resume CleanExit
    DisableCloseButton = False
End Function


'++*******************************************************************
' Procedure:    isOkToInsertHeading1
' Author:       Brochet ltd
' Description:  Function decides if its ok to insert table into current selection
' Parameters:   N/A
' Returns:      True if its ok to insert table, false otherwise
'--********************************************************************
Function isOkToInsertHeading1() As String
'isOkToInsertHeading1
    Dim iMinStartSection As Integer
    Dim bBackPage As Boolean
    Dim iSecTotal As Integer
    Dim rRange As Range
    Dim rRange2 As Range
    Dim iSecStartNo As Integer
    Dim iSecEndNo As Integer
    Dim iSecNo As Integer
    
    Dim bTitlePg As Boolean
    Dim bInsideTitlePg As Boolean
    Dim bContentsPg As Boolean
    
    Dim iCurrSecNo As Integer
    Dim iStartSecNo As Integer
    Dim sErrorMess As String

    isOkToInsertHeading1 = "True"

    'Check that not in a textbox
    If Selection.Paragraphs.count > 1 Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted in when multiple paragraphs are selected."
    ElseIf StyleExistsBefore("Heading 6", Selection.Range) Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted after an Annex heading."
'    ElseIf Selection.Information(wdActiveEndSectionNumber) = GetPageSection(PAGEID_ContactPage) Then
'        isOkToInsertHeading1 = "Heading 1 cannot be inserted in the back page"
    ElseIf Selection.ShapeRange.count > 0 Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted in a textbox"
    'Check not in Header or Footer
    ElseIf Selection.Information(wdInHeaderFooter) Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted in a Header or Footer."
    'Check not in Footnote or Endnote
    ElseIf Selection.Information(wdInFootnoteEndnotePane) Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted in a Footnote or EndNote Pane."
    ElseIf Selection.Information(wdInEndnote) Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted in an EndNote."
    ElseIf Selection.Information(wdInFootnote) Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted in a FootNote."
    'Check to see if the selection not in a frame
    ElseIf Selection.Frames.count >= 1 Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted when in a frame."
    'Check to see if the selection includes all or part of a table
    ElseIf Selection.Tables.count >= 1 And Selection.Information(wdWithInTable) Then
        isOkToInsertHeading1 = "Heading 1 cannot be inserted when in a table."
    Else
        'Check if not inserting into title page or back page or something simmilar

        iSecTotal = ActiveDocument.Sections.count

        'Get the section start and end section No
        Set rRange = Selection.Range
        rRange.Collapse wdCollapseStart
        iSecStartNo = rRange.Information(wdActiveEndSectionNumber)

        Set rRange = Selection.Range
        rRange.Collapse (wdCollapseEnd)
        iSecEndNo = rRange.Information(wdActiveEndSectionNumber)

        'See how many start sections there are
        bTitlePg = modPages.IsTitlePageEnabled
        bInsideTitlePg = False 'modPages.IsInsideTitlePageEnabled
        
        iStartSecNo = 0
        If bTitlePg Then iStartSecNo = iStartSecNo + 1
        If bInsideTitlePg Then iStartSecNo = iStartSecNo + 1
        
        bContentsPg = modPages.IsContentsPageEnabled
        If bContentsPg Then iStartSecNo = iStartSecNo + 1
        
        iCurrSecNo = Selection.Information(wdActiveEndSectionNumber)

        'Check if in a front section
        If iCurrSecNo <= iStartSecNo Then
            isOkToInsertHeading1 = "Heading 1 cannot be inserted in one of the front sections eg Title, Inside Title or Contents sections!"
        End If
        
        


    End If
    
End Function

'++*******************************************************************
' Procedure:    isOkToInsertAnnex
' Author:       Brochet ltd
' Description:  Function decides if its ok to insert
' Parameters:   N/A
' Returns:      True if its ok to insert table, false otherwise
'--********************************************************************
Function isOkToInsertAnnex() As String
'isOkToInsertAnnex
    Dim iMinStartSection As Integer
    Dim bBackPage As Boolean
    Dim iSecTotal As Integer
    Dim rRange As Range
    Dim rRange2 As Range
    Dim iSecStartNo As Integer
    Dim iSecEndNo As Integer
    Dim iSecNo As Integer
    
    Dim bTitlePg As Boolean
    Dim bInsideTitlePg As Boolean
    Dim bContentsPg As Boolean
    
    Dim iCurrSecNo As Integer
    Dim iStartSecNo As Integer
    Dim sErrorMess As String

    isOkToInsertAnnex = "True"

    'Check that not in a textbox
    If Selection.Paragraphs.count > 1 Then
        isOkToInsertAnnex = "An Annex cannot be inserted in when multiple paragraphs are selected."
    ElseIf StyleExistsAfter("Heading 1", Selection.Range) Then
        isOkToInsertAnnex = "An Annex cannot be inserted before a Heading 1."
'    ElseIf Selection.Information(wdActiveEndSectionNumber) = GetPageSection(PAGEID_ContactPage) Then
'        isOkToInsertAnnex = "An Annex cannot be inserted in the back page"
    ElseIf Selection.ShapeRange.count > 0 Then
        isOkToInsertAnnex = "An Annex cannot be inserted in a textbox"
    'Check not in Header or Footer
    ElseIf Selection.Information(wdInHeaderFooter) Then
        isOkToInsertAnnex = "An Annex cannot be inserted in a Header or Footer."
    'Check not in Footnote or Endnote
    ElseIf Selection.Information(wdInFootnoteEndnotePane) Then
        isOkToInsertAnnex = "An Annex cannot be inserted in a Footnote or EndNote Pane."
    ElseIf Selection.Information(wdInEndnote) Then
        isOkToInsertAnnex = "An Annex cannot be inserted in an EndNote."
    ElseIf Selection.Information(wdInFootnote) Then
        isOkToInsertAnnex = "An Annex cannot be inserted in a FootNote."
    'Check to see if the selection not in a frame
    ElseIf Selection.Frames.count >= 1 Then
        isOkToInsertAnnex = "An Annex cannot be inserted when in a frame."
    'Check to see if the selection includes all or part of a table
    ElseIf Selection.Tables.count >= 1 And Selection.Information(wdWithInTable) Then
        isOkToInsertAnnex = "An Annex cannot be inserted when in a table."
    Else
        'Check if not inserting into title page or back page or something simmilar

        iSecTotal = ActiveDocument.Sections.count

        'Get the section start and end section No
        Set rRange = Selection.Range
        rRange.Collapse wdCollapseStart
        iSecStartNo = rRange.Information(wdActiveEndSectionNumber)

        Set rRange = Selection.Range
        rRange.Collapse (wdCollapseEnd)
        iSecEndNo = rRange.Information(wdActiveEndSectionNumber)

        'See how many start sections there are
        bTitlePg = modPages.IsTitlePageEnabled
        bInsideTitlePg = False ' modPages.IsInsideTitlePageEnabled
        
        iStartSecNo = 0
        If bTitlePg Then iStartSecNo = iStartSecNo + 1
        If bInsideTitlePg Then iStartSecNo = iStartSecNo + 1
        
        bContentsPg = modPages.IsContentsPageEnabled
        If bContentsPg Then iStartSecNo = iStartSecNo + 1
        
        iCurrSecNo = Selection.Information(wdActiveEndSectionNumber)

        'Check if in a front section
        If iCurrSecNo <= iStartSecNo Then
            isOkToInsertAnnex = "An Annex cannot be inserted in one of the front sections eg Title, Inside Title or Contents sections!"
           
        Else
        
            'Need to check that not immediately after a column break.
            Set rRange = Selection.Paragraphs(1).Range
            If Asc(rRange.text) = 14 Then
                'Need to check if this column break is before a section heading control field
                Set rRange2 = rRange.Duplicate
                rRange2.MoveStart wdParagraph, -1
                rRange2.Collapse wdCollapseStart
                If modContentControls.IsSelectionInCC(rRange2) Then
                    isOkToInsertAnnex = "An Annex cannot be inserted immediately after section paragraphs."
                End If
            End If
           
        End If

    End If
    
End Function


'++*******************************************************************
' Procedure:    isOkToInsertNewSection
' Author:       Brochet ltd
' Description:  Function decides if its ok to insert section into current selection
' Parameters:   N/A
' Returns:      True if its ok to insert table, false otherwise
'--********************************************************************
Function isOkToInsertNewSection(sInsertTypeText As String) As String

    Dim iMinStartSection As Integer
    Dim bBackPage As Boolean
    Dim iSecTotal As Integer
    Dim rRange As Range
    Dim iSecStartNo As Integer
    Dim iSecEndNo As Integer
    Dim iSecNo As Integer
    
    Dim bTitlePg As Boolean
    Dim bInsideTitlePg As Boolean
    Dim bContentsPg As Boolean
    
    Dim iCurrSecNo As Integer
    Dim iStartSecNo As Integer
    Dim sErrorMess As String

    isOkToInsertNewSection = "True"

    'Check that not in a textbox
    If Selection.Type <> wdSelectionIP Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in when text is selected."
    ElseIf Selection.Paragraphs.count > 1 Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in when multiple paragraphs as selected."
    ElseIf Selection.ShapeRange.count > 0 Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in a textbox"
    'Check not in Header or Footer
    ElseIf Selection.Information(wdInHeaderFooter) Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & "  cannot be inserted in a Header or Footer."
    'Check not in Footnote or Endnote
    ElseIf Selection.Information(wdInFootnoteEndnotePane) Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in a Footnote or EndNote Pane."
    ElseIf Selection.Information(wdInEndnote) Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in an EndNote."
    ElseIf Selection.Information(wdInFootnote) Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in a FootNote."
    'Check to see if the selection not in a frame
    ElseIf Selection.Frames.count >= 1 Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted when in a frame."
    'Check to see if the selection includes all or part of a table
    ElseIf Selection.Tables.count >= 1 And Selection.Information(wdWithInTable) Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted when in a table."
    ElseIf modContentControls.IsSelectionInCC(Selection.Range) Then
        isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted when in a content control."
    
    Else
        'Check if not inserting into title page or back page or something simmilar

        iSecTotal = ActiveDocument.Sections.count

        'Get the section start and end section No
        Set rRange = Selection.Range
        rRange.Collapse wdCollapseStart
        iSecStartNo = rRange.Information(wdActiveEndSectionNumber)

        Set rRange = Selection.Range
        rRange.Collapse (wdCollapseEnd)
        iSecEndNo = rRange.Information(wdActiveEndSectionNumber)

        'See how many start sections there are
        bTitlePg = modPages.IsTitlePageEnabled
        bInsideTitlePg = False 'modPages.IsInsideTitlePageEnabled
        
        iStartSecNo = 0
        If bTitlePg Then iStartSecNo = iStartSecNo + 1
        If bInsideTitlePg Then iStartSecNo = iStartSecNo + 1
        
        bContentsPg = modPages.IsContentsPageEnabled
        If bContentsPg Then iStartSecNo = iStartSecNo + 1
        
        iCurrSecNo = Selection.Information(wdActiveEndSectionNumber)

        'Check if in a front section
        If iCurrSecNo <= iStartSecNo Then
        
            isOkToInsertNewSection = "A new " & sInsertTypeText & " cannot be inserted in one of the front sections eg Title, Inside Title or Contents sections!"
           
        End If

    End If
    
End Function


'++*******************************************************************
' Procedure:    PasteUnformattedText
' Author:       Brochet ltd
' Description:  Pastes text in as unformatted text
' Shortcut key: Alt + v
' Parameters:   none
' Returns:      n/a
'--********************************************************************
Public Sub PasteUnformattedText()

    On Error GoTo PasteUnformattedTextError
    Selection.PasteSpecial dataType:=wdPasteText, placement:=wdInLine

    Exit Sub
PasteUnformattedTextError:
    If err.Number = 5342 Then
        Selection.PasteAndFormat wdFormatPlainText
    End If
    
End Sub


'++*******************************************************************
' Procedure:    PasteEnhancedMetafile
' Author:       Brochet ltd
' Description:  Pastes Graph as EnhancedMetafile
'--********************************************************************
Public Sub PasteEnhancedMetafile()

    On Error GoTo PasteEnhancedMetafileError
    Selection.PasteSpecial dataType:=wdPasteEnhancedMetafile, placement:=wdInLine
    'Selection.PasteSpecial dataType:=wdPasteText, placement:=wdInLine
    Exit Sub
PasteEnhancedMetafileError:
    Beep
    
End Sub

Attribute VB_Name = "modRibbon"
'*******************************************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module:      modRibbon
'*
'* Holds:       Callbacks and support procedures for the ribbon.
'*******************************************************************************************************
Option Explicit
Option Private Module

Private Const MODULE_NAME As String = "modRibbon"

Private rxBrochetA4ReportRibbonUI As IRibbonUI

'++********************************************************************
' Procedure:    rxBrochetLegalRibbonUI_onLoad
' Description:  Respond to the load of the ribbon.
' Parameters:   ribbon - Ribbon control
' Returns:      N/A
'--********************************************************************
Sub RbnBrochetUIReport_onLoad(ribbon As IRibbonUI)
    On Error GoTo BrochetA4RibbonUI_onLoadErr
    
    Set rxBrochetA4ReportRibbonUI = ribbon

BrochetA4LegalRibbonUI_onLoadExit:
    Exit Sub

BrochetA4RibbonUI_onLoadErr:
    modError.GlobalErrorHandler err.Number, err.Description, MODULE_NAME, "RbnBrochetUI_onLoad", "Initialization of Global template failed "
    Resume BrochetA4LegalRibbonUI_onLoadExit:
End Sub

'++********************************************************************
' Description:  Sets the enabled status of various ribbon controls
' Parameters:   control - the ribbon control name
'               enabled - The enabled status
' Returns:      none
' TODO:         Make sure that all controls are covered and correct.
'--********************************************************************
Private Sub RbnBrochetA4Report_getEnabled(control As IRibbonControl, ByRef enabled)
    Select Case control.ID
    Case Else
        enabled = modPublic.GlobalDirectivesSendMessageNoConfirmation("IsGlobalOK", False) And Not modPrivate.DocCountZeroOrDocInProtectedView
    End Select
End Sub

'++********************************************************************
' Description:  Invalidating the whole ribbon will evoke the the series
'               of calls to the procedure 'RbnBrochet_getEnabled
'               to enable/disable controls on the Global's ribbon.
' Parameters:   sControls - Array of control IDs. If empty, whole ribbon
'                   will be refreshed. If not, Ccntrols with specified
'                   IDs will be refreshed only.
' Returns:      none
'--********************************************************************
Sub InvalidateRibbon(ParamArray sControls())
    Dim i As Integer
    
    If Not rxBrochetA4ReportRibbonUI Is Nothing Then
        On Error Resume Next
    
        If UBound(sControls) = -1 Then
            rxBrochetA4ReportRibbonUI.Invalidate
        Else
            For i = LBound(sControls) To UBound(sControls)
                rxBrochetA4ReportRibbonUI.InvalidateControl sControls(i)
            Next i
        End If
        
        On Error GoTo 0
    End If
End Sub

'++********************************************************************
' Description:  Handles all style button presses on ribbon of this template
' Parameters:   control - Ribbon button that was pressed
' Returns:      N/A
'--********************************************************************
Private Sub BtnBrochetA4ReportStyles_onAction(control As IRibbonControl)
    On Error GoTo ErrorHandler
    
    Dim oUndoRecord As cUndoRecord
    
    Set oUndoRecord = New cUndoRecord
    oUndoRecord.SetName "Changing Style to: " & control.Tag
    
    'Need select case for buildin styles, because those change name depending on locale
    'So instead of name we have to use the word identifier
    Select Case control.ID
    
    Case "BtnStylesSectionDelete", "BtnStylesSectionDelete2"
        modStyles.DeleteSectionParagraph
    Case "BtnColumnBreak"
        oUndoRecord.SetName "Insert Column Break"
        modStyles.InsertColumnBreak
    Case "BtnStylesShadeDkGreen"
        ShadeSelectedText 1
    Case "BtnStylesShadeLtGreen"
        ShadeSelectedText 2
    Case "BtnStylesRemoveShade"
        ShadeSelectedText 0
    Case Else
    
        If IsNumeric(control.Tag) Then
            Selection.Range.Style = CInt(control.Tag)
        Else
            Selection.Range.Style = control.Tag
            ActiveWindow.ScrollIntoView Selection.Range
        End If
        
    End Select
    
CleanExit:
    oUndoRecord.EndRecording
    Exit Sub
ErrorHandler:
    'Error applying style. Do nothing
    Resume CleanExit
End Sub

'++********************************************************************
' Description:  Word calls this function to get label for various
'               controls
' Parameters:   control - Ribbon control that is asking for it's label
'               label - out param new label for the control
' Returns:      N/A
'--********************************************************************
Private Sub RbnBrochetReport_getLabel(control As IRibbonControl, ByVal label As String)
    Select Case control.ID
    Case "GrpDoc"
        label = modGlobal.COMPANY_NAME_SHORT
    End Select
End Sub
'++********************************************************************
' Description:  Removes the White space (space after) of the selected paragraphs
' Parameters:   control - Ribbon control that was pressed
' Returns:      N/A
'--********************************************************************
Private Sub rxbtnBrochetA4ReportStylesRemoveWhiteSpace_onAction(control As IRibbonControl)

    Selection.Paragraphs.SpaceAfter = 0
    
End Sub

'++********************************************************************
' Description:  Runs when Doc Dialog button on the ribbon is pressed
' Parameters:   control - Ribbon control that was pressed
' Returns:      N/A
'--********************************************************************
Private Sub BtnBrochetA4ReportDocDialog_onAction(control As IRibbonControl)

    Dim undoRecord As cUndoRecord
    Set undoRecord = New cUndoRecord
    
    
    'First check the ini file is in order
    If gsCompanyIniFileName = vbNullString Then
        gsCompanyIniFileName = GetIniFilePath
        If modPrivate.FileExists(gsCompanyIniFileName) = False Then
            MsgBox "The system ini file (" & gsCompanyIniFileName & ") cannot be found.", vbInformation
            Exit Sub
        End If
    End If
    
    gbNewDoc = False
    gbStarterDoc = False
    
    undoRecord.SetName "Update Document"
    
    modTools.SaveLocation
    frmNewDoc.Show
    modTools.GotoLocation
    undoRecord.EndRecording

    
End Sub


'++********************************************************************
' Description:  Runs when Delete Section button on the ribbon is pressed
' Parameters:   control - Ribbon control that was pressed
' Returns:      N/A
'--********************************************************************
Private Sub BtnBrochetPageLayouts_onAction(control As IRibbonControl)
    Dim undoRecord As cUndoRecord
    
    
    Select Case control.ID
        Case "BtnBrochetSectionsInsert"
            Set undoRecord = New cUndoRecord
            undoRecord.SetName "Insert Word Section"
            modPages.NewSectionButtonPress
            undoRecord.EndRecording
            
        Case "BtnBrochetSectionsDelete"
            Set undoRecord = New cUndoRecord
            undoRecord.SetName "Delete Word Section"
            modPages.A4ReportDeleteSection
            undoRecord.EndRecording
   
         Case "BtnBrochetSectionsToggle"
            Set undoRecord = New cUndoRecord
            undoRecord.SetName "Toogle Section Type"
            modPages.ToggleSectionType
            undoRecord.EndRecording

    End Select

End Sub


'++********************************************************************
' Description:  Runs when Delete Section button on the ribbon is pressed
' Parameters:   control - Ribbon control that was pressed
' Returns:      N/A
'--********************************************************************
Private Sub BtnBrochetPlaceholder_onAction(control As IRibbonControl)
    
    Dim undoRecord As cUndoRecord
    
    Select Case control.ID
        Case "BtnBrochetPlaceholderInsert"
            Set undoRecord = New cUndoRecord
            undoRecord.SetName "Insert Placeholder"
            modPages.NewPlaceholderButtonPress
            undoRecord.EndRecording
    End Select

End Sub



'Callback for BtnInsertImage onAction
Sub BtnBrochetA4ReportInsertImage_onAction(control As IRibbonControl)

    modImages.ImageGetAndInsert
    
End Sub

'++*******************************************************************
' Callback for: rxbtnKRPasteUnformattedText_onAction
' Author:       Brochet ltd
' Description:  Callback from the Paste Unformatted Text button. Pastes
'               the last copy as Unformatted text
' Parameters:   control - the menu item ribbon control name
' Returns:      none
'--********************************************************************
Sub rxbtnKRPasteUnformattedText_onAction(control As IRibbonControl)

    modPublic.PasteUnformattedText
    
End Sub
'++*******************************************************************
' Callback for: rxbtnKRPasteUnformattedText_onAction
' Author:       Brochet ltd
' Description:  Callback from the Paste Unformatted Text button. Pastes
'               the last copy as Unformatted text
' Parameters:   control - the menu item ribbon control name
' Returns:      none
'--********************************************************************
Sub rxbtnPasteEnhancedMetafile_onAction(control As IRibbonControl)

    modPublic.PasteEnhancedMetafile
    
End Sub



'Callback for rxbtnBrochetInsertExcelChart onAction
Sub rxbtnInsertPowerPoint_onAction(control As IRibbonControl)

    modMicrosoftPowerPoint.InsertPowerPointObjectOnly False, True
    
End Sub

'Callback for rxbtnBrochetShowAlternativeText onAction
Sub rxbtnAlternativeText_onAction(control As IRibbonControl)

    modChartInfo.DisplayChartInfo
    
End Sub

Sub BtnBrochetA4ReportInsertImageDialog_onAction(control As IRibbonControl)

    ShowFrmInsertImage
    
End Sub

'Callback for rxbtnBrochetInsertExcelChart onAction
Sub rxbtnInsertExcel_onAction(control As IRibbonControl)

    modMicrosoftExcelChart.InsertExcelChartOnly True, False
    
End Sub

'Callback for rxbtnBrochetSplitbutton1 onAction
Sub rxbtnInsertExcelNoFormat_onAction(control As IRibbonControl)

    modMicrosoftExcelChart.InsertExcelChartOnly False, False

End Sub

'Callback for rxbtnBrochetSplitbutton2 onAction
Sub rxbtnInsertExcelEMF_onAction(control As IRibbonControl)

    modMicrosoftExcelChart.InsertExcelChartOnly False, True

End Sub


'Callback for rxbtnBrochetSplitbuttonPP1 onAction
Sub rxbtnInsertPowerPointNoFormat_onAction(control As IRibbonControl)

    modMicrosoftPowerPoint.InsertPowerPointObjectOnly False, False

End Sub

'Callback for rxbtnBrochetSplitbuttonPP2 onAction
Sub rxbtnInsertPowerPointEMF_onAction(control As IRibbonControl)

    modMicrosoftPowerPoint.InsertPowerPointObjectOnly True, False

End Sub

'Callback for rxbtnBrochetReformatChart onAction
Sub rxbtnReformatChart_onAction(control As IRibbonControl)

    modBrochetChartTool.ReformatSelectedChart

End Sub
Attribute VB_Name = "modScreenUpdating"
'***********************************************************************************
'* Module: modScreenUpdating
'*
'* Module is designed to work as class with static methods. It holds function, that makes disabling and enabling
'* screen updating more reliable and easier.
'* Functions in this module will allow to disable and enable screen updating in nested procedures
'* without accidentaly enabling screen updating in higher level
'***********************************************************************************

Option Explicit
Option Private Module

Private Const msMODULE As String = "modMacros"

'indicates how many times must ScreenUpdating_Enable be called before the screen updating is really enabled
Private giCounter As Integer

'With disabling screen update, the track changes should be disabled as well, but when screen updating is enabled, return to original setting
Private mbTrackChanges As Boolean
Private mbTrackChangesKnown As Boolean

'++*******************************************************************
' Procedure:    ScreenUpdating_Disable
' Author:       Brochet ltd
' Description:  Disables screenupdating, and Increment giCounter
'               should be called in pair with ScreenUpdating_Enable
' Parameters:   nothing
' Returns:      nothing
'--********************************************************************
Public Sub ScreenUpdating_Disable()
    If giCounter = 0 Then
        mbTrackChanges = ActiveDocument.TrackRevisions
        mbTrackChangesKnown = True
    End If
    giCounter = giCounter + 1
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    ActiveDocument.TrackRevisions = False
End Sub

'++*******************************************************************
' Procedure:    ScreenUpdating_Enable
' Author:       Brochet ltd
' Description:  Decrement giCounter if it is larger than 0. If giCounter is 0 after decrementation, enables screen updating
'               should be called in pair with ScreenUpdating_Disable
' Parameters:   nothing
' Returns:      nothing
'--********************************************************************
Public Sub ScreenUpdating_Enable()
    'giCounter should never be smaller than 0
    giCounter = max(giCounter - 1, 0)
    If giCounter = 0 Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
        If mbTrackChangesKnown Then
            ActiveDocument.TrackRevisions = mbTrackChanges
        End If
    End If
End Sub

'++*******************************************************************
' Procedure:    ScreenUpdating_Reset
' Author:       Brochet ltd
' Description:  Resets giCounter, and enables screen refreshing.
'               Should only be used on higher level.
' Parameters:   nothing
' Returns:      nothing
'--********************************************************************
Public Sub ScreenUpdating_Reset()
    giCounter = 0
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    If mbTrackChangesKnown Then
        ActiveDocument.TrackRevisions = mbTrackChanges
    End If
End Sub

Attribute VB_Name = "modStyles"
'*******************************************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*
'* Module: modStyles
'*
'* Holds various macro code for applying the funny styles eh Heading 1 styles
'***********************************************************************************

Option Explicit
Option Private Module
Const msMODULE As String = "modStyles"



Function GetNextParaStyle(rRange As Range) As Style

    On Error GoTo err

    rRange.Move wdParagraph, 1
    Set GetNextParaStyle = rRange.Style
    
clean:
    
    Exit Function
err:
    Set GetNextParaStyle = ActiveDocument.Styles(wdStyleNormal)
    Resume clean

End Function


Function GetNextPara(rRange As Range) As Range

    On Error GoTo err

    rRange.Move wdParagraph, 1
    Set GetNextPara = rRange
    
clean:
    
    Exit Function
err:
    Set GetNextPara = Nothing
    Resume clean

End Function

Function GetPreviousPara(rRange As Range) As Range

    On Error GoTo err

    rRange.Move wdParagraph, -2
    Set GetPreviousPara = rRange
    
clean:
    
    Exit Function
err:
    Set GetPreviousPara = Nothing
    Resume clean

End Function

Sub ModifyParaFrame(rSection As Range, ccTag As String, sStyle As String)

    Dim para As Paragraph
    Dim ccSection As ContentControl
    Dim sReferenceStyle As String
    
    sReferenceStyle = "Section HeadingLand"

    For Each ccSection In rSection.ContentControls
        If ccSection.Tag = ccTag Then
            ccSection.LockContents = False
            For Each para In ccSection.Range.Paragraphs
            
                'Horizontal Position does not appear to hold values correctly
                'i.e 426.65 is stored as 426.6 if added programatically
                para.Range.Frames(1).HorizontalPosition = 426.6
                
                
                If para.Style = "Heading 2" Then
                    With para.Range.Frames(1)
                        .TextWrap = ActiveDocument.Styles(sReferenceStyle).Frame.TextWrap
                        .WidthRule = ActiveDocument.Styles(sReferenceStyle).Frame.WidthRule
                        .Width = ActiveDocument.Styles(sReferenceStyle).Frame.Width
                        .HeightRule = ActiveDocument.Styles(sReferenceStyle).Frame.HeightRule
                        .Height = ActiveDocument.Styles(sReferenceStyle).Frame.Height

                        .RelativeHorizontalPosition = ActiveDocument.Styles(sReferenceStyle).Frame.RelativeHorizontalPosition
                        .HorizontalDistanceFromText = ActiveDocument.Styles(sReferenceStyle).Frame.HorizontalDistanceFromText
                        .VerticalPosition = ActiveDocument.Styles(sReferenceStyle).Frame.VerticalPosition
                        .RelativeVerticalPosition = ActiveDocument.Styles(sReferenceStyle).Frame.RelativeVerticalPosition
                        .VerticalDistanceFromText = ActiveDocument.Styles(sReferenceStyle).Frame.VerticalDistanceFromText
                        .LockAnchor = ActiveDocument.Styles(sReferenceStyle).Frame.LockAnchor
                    End With
                End If
            Next
            ccSection.LockContents = True
        End If
    Next


End Sub

Sub printframe()

Debug.Print "====" & Selection.Range.Style & "========================"

        With Selection.Range.Frames(1)
            Debug.Print .TextWrap
            Debug.Print .WidthRule
            Debug.Print .Width
            Debug.Print .HeightRule
            Debug.Print .Height
            Debug.Print .HorizontalPosition
            Debug.Print .RelativeHorizontalPosition
            Debug.Print .HorizontalDistanceFromText
            Debug.Print .VerticalPosition
            Debug.Print .RelativeVerticalPosition
            Debug.Print .VerticalDistanceFromText
            Debug.Print .LockAnchor
        End With
Debug.Print "============================"

End Sub

'This is a dirty fix to make sure the
Sub RefreshCCStyle(rSection As Range, ccTag As String, sStyle As String)

    Dim para As Paragraph
    Dim ccSection As ContentControl
    
    For Each ccSection In rSection.ContentControls
        If ccSection.Tag = ccTag Then
            ccSection.LockContents = False
            For Each para In ccSection.Range.Paragraphs
                If para.Style = sStyle Then
                    para.Style = sStyle
                End If
            Next
            ccSection.LockContents = True
        End If
    Next


End Sub

'++*******************************************************************
' Procedure:    StyleExists
' Description:  Checks for the existence of a given style in the doc.
' Parameters:   sStyleName - Name of style to check.
' Returns:      True if it exists in the active doc.
'--********************************************************************
Function StyleExistsInDocument(sStyleName As String) As Boolean

    Dim sText As String
    
    On Error Resume Next
    sText = ActiveDocument.Styles(sStyleName).NameLocal
    On Error GoTo 0
    
    StyleExistsInDocument = sText <> vbNullString
    
End Function



Function StyleExistsBefore(sStyle As String, rRange As Range) As Boolean
'Returns True if the Style appears in the document before the range

    On Error GoTo err

    Dim SearchRange As Range
    
    Set SearchRange = rRange.Duplicate
    
    SearchRange.Collapse wdCollapseStart
    
    With SearchRange.Find
        .ClearFormatting
        .Style = ActiveDocument.Styles(sStyle)
        .ClearAllFuzzyOptions
        .text = "^?"
        .Forward = False
        .Wrap = wdFindStop

        StyleExistsBefore = .Execute
    End With

Exit Function

err:

    StyleExistsBefore = False
    Resume


End Function

Function StyleExistsAfter(sStyle As String, rRange As Range) As Boolean
'Returns True if the Style appears in the document after the range

    On Error GoTo err

    Dim SearchRange As Range
    
    Set SearchRange = rRange.Duplicate
    
    SearchRange.Collapse wdCollapseStart
    
    With SearchRange.Find
        .ClearFormatting
        .Style = ActiveDocument.Styles(sStyle)
        .ClearAllFuzzyOptions
        .text = "^?"
        .Forward = True
        .Wrap = wdFindStop

        StyleExistsAfter = .Execute
    End With

Exit Function

err:

    StyleExistsAfter = False
    Resume


End Function

Function GetSectionAutoText(rRange As Range, bSection As Boolean) As String

        'Insert the correct autotext
        Select Case modPages.GetPageType(rRange.Information(wdActiveEndSectionNumber))
        Case A4PROPOSAL, A4WIDE
            If bSection Then
                GetSectionAutoText = "z_SectionCCPortrait"
            Else
                GetSectionAutoText = "z_AppendixCCPortrait"
            End If
        Case A4LANDSCAPE
            If bSection Then
                GetSectionAutoText = "z_SectionCCLandscape"
            Else
                GetSectionAutoText = "z_AppendixCCLandscape"
            End If
        Case A3LANDSCAPE
            If bSection Then
                GetSectionAutoText = "z_SectionCC_A3Landscape"
            Else
                GetSectionAutoText = "z_AppendixCC_A3Landscape"
            End If
        
        End Select

End Function

Function SectionBreakExistsBefore(rRange As Range) As Boolean

    On Error GoTo err

    Dim Chr As Integer
    Dim rTest As Range
    Dim iInitialSectionNumber As Integer
    Dim iTestSectionNumber As Integer

    Set rTest = rRange.Duplicate
    iInitialSectionNumber = rTest.Information(wdActiveEndSectionNumber)
    
    rTest.Collapse WdCollapseDirection.wdCollapseStart
    rTest.Move wdCharacter, -1
    Chr = Asc(rTest.Characters(1).text)
    iTestSectionNumber = rTest.Information(wdActiveEndSectionNumber)
    
    SectionBreakExistsBefore = False
    
    If Chr = 12 And iTestSectionNumber < iInitialSectionNumber Then
            SectionBreakExistsBefore = True
        
    End If


err:



End Function

Function SectionBreakExistsAfter(ByVal rRange As Range) As Boolean

    
    Dim iInitialSectionNumber As Integer
    Dim iTestSectionNumber As Integer

    rRange.Collapse wdCollapseEnd
    
    iInitialSectionNumber = rRange.Information(wdActiveEndSectionNumber)
    
    rRange.Move wdCharacter, 1
    iTestSectionNumber = rRange.Information(wdActiveEndSectionNumber)
    
    SectionBreakExistsAfter = False
    
    If iTestSectionNumber > iInitialSectionNumber Then
            SectionBreakExistsAfter = True
        
    End If


End Function

'++*******************************************************************
' Procedure:    DeleteSectionParagraph
' Author:       Brochet ltd
' Description:  Deletes the currently selected Section Content Control
' Parameters:   N/A
' Returns:      N/A
'--********************************************************************
Sub DeleteSectionParagraph()

    'Assumes current Group control
    
    On Error GoTo err
    
    Dim rSection As Range
    Dim ccSection As ContentControl
    Dim ccControl As ContentControl
    Dim ccTemp As ContentControl
    Dim sTemp As String
    Dim iPos As Integer
    Dim i As Integer
    Dim iAppendixSectionStart As Integer
    
    Dim iSectionStartPosition As Integer
    Dim iCurrentSection As Integer
    
    Set rSection = Selection.Range
'    If rSection.Information(wdInContentControl) Then
    If modContentControls.IsSelectionInCC(rSection) Then
    
        'Check for multiple sections
        If rSection.ContentControls.count > 1 Then
            'For Each ccTemp In rSection.ContentControls
            If RangeHasMultipleSections(rSection) Then
                err.Raise 4
            End If
       
        End If
    
        Set ccSection = ReturnContentControlGroup(rSection)
        
        If ccSection.Tag = "Section Group" Then
            ccSection.LockContentControl = False
            ccSection.LockContents = False
            'Delete all children
            For Each ccTemp In ccSection.Range.ContentControls
                With ccTemp
                    .LockContents = False
                    .LockContentControl = False
                End With
            Next
            
            Set rSection = ccSection.Range
            
            With ccSection
                .Range.text = ""
                .Range.Style = wdStyleNormal
                .Delete True
            End With

            'The control has been deleted but left with a blank normal para than needs deleting
            rSection.End = rSection.Start + 1
            rSection.Delete

            'Need to check if the next character is a Column break
            rSection.End = rSection.Start + 1
            If Asc(rSection.text) = 14 Then
                rSection.Delete
            Else
                rSection.Collapse wdCollapseStart
            End If
            
            'Set the numbering to same as previous if section is Appendix start plus 1
            iAppendixSectionStart = GetFirstAppendixSectionIndex
            iCurrentSection = rSection.Information(wdActiveEndSectionNumber)
            
            If iCurrentSection > iAppendixSectionStart Then
                ActiveDocument.Sections(iCurrentSection).Footers(wdHeaderFooterPrimary).PageNumbers.RestartNumberingAtSection = False
            End If
            
            'Do the following to make the paragraph visible on the screen
            ActiveDocument.ActiveWindow.ScrollIntoView Selection.Range
            
        Else
            err.Raise 2
        End If
    Else
        err.Raise 2
        
   End If
    
clean:

    Exit Sub
err:

    Select Case err
    Case 1
        MsgBox "There is a problem with the section heading"
    Case 2
        MsgBox "The cursor needs to be somewhere in the Section Title or Appendix Title content control before it can be deleted.", vbInformation, "Delete Title or Appendix content control"
    Case 4
        MsgBox "The selection potentially contains multiple sections. Please select only one"
    Case Else
        MsgBox "Something has gone wrong : " & err.Description
  End Select

    Resume clean

End Sub

Sub ResetPageNumber(rRange As Range)


    Dim pPageNumber As PageNumber
    Dim iFirstAppendix As Integer
    Dim i As Integer
    
    Dim sSection As Section
    
    iFirstAppendix = GetFirstAppendixSectionIndex
    
    For Each sSection In ActiveDocument.Sections
        If sSection.Index <= 3 Then
            'Do not change the numbering
        ElseIf sSection.Index < iFirstAppendix Then
            'Main Sections
        Else
            'Appendices
        End If
        
    Next
    
'    For Each pPageNumber In rRange.Sections(1).Footers(wdHeaderFooterPrimary).PageNumbers
'        pPageNumber.Select
'        Debug.Print pPageNumber.Index
'        If rRange.Sections(1).Footers(wdHeaderFooterPrimary).PageNumbers.IncludeChapterNumber = True Then
'            Debug.Print "IncludeChapter" & pPageNumber.Index
'        End If
'
'    Next



End Sub

Function GetFirstAppendixSectionIndex() As Integer

    Dim rSearch As Range
    Dim ccControl As ContentControl
    
    Set rSearch = ActiveDocument.Range
    
    GetFirstAppendixSectionIndex = 0
    
    For Each ccControl In rSearch.ContentControls
        If ccControl.Tag = "Section Group" Then
            If InStr(1, ccControl.title, "Append") Then
                GetFirstAppendixSectionIndex = ccControl.Range.Information(wdActiveEndSectionNumber)
                Exit For
            End If
        End If
    Next

End Function


Sub InsertColumnBreak()

    Selection.InsertBreak Type:=1


End Sub






Function GetNextParaWithStyle(ByRef rStart As Range, sStyle As String, Optional bFromStart As Boolean = False) As Range

    On Error GoTo err

    rStart.Collapse wdCollapseStart
    
    With rStart.Find
        .ClearFormatting
        .Style = ActiveDocument.Styles(sStyle)
        .ClearAllFuzzyOptions
        .text = "^?"
        .Forward = True
        .Wrap = wdFindStop

        .Execute
        If .found Then
            Set GetNextParaWithStyle = rStart
        End If
    End With

    
Exit Function

err:

    'GetNextParaWithStyle = Null
    Resume

End Function

Sub ShadeSelectedText(iIndex As Integer)

    On Error Resume Next

    Select Case iIndex
    Case 0 'remove
        Selection.Font.Reset
    Case 1 'Dk Green
        Selection.Font.TextColor.RGB = RGB(0, 84, 50)
    Case 2 'Lt Green
        Selection.Font.TextColor.RGB = RGB(122, 193, 67)
    End Select

End Sub
Attribute VB_Name = "modTables"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modTables
'*
'* Holds various macro code related to tables. Most of the functionality is in the
'* global template
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modFields"

'*******************************************************************************************************
'* Description: Checks if its ok to insert table into current selection
'* Parameters:  N/A
'* Returns:     True if the selection is valid range for new table. false otherwise
'*******************************************************************************************************
Public Function IsOKToInsertTable() As Boolean
    IsOKToInsertTable = modPublic.GlobalDirectivesSendMessageNoConfirmation("IsOperationOkToDo", False, "Inserting new Table", ESelectionTests.NotInAny)
End Function

'*******************************************************************************************************
'* Description: Checks if its ok to reformat given table
'* Parameters:  oTable - table about to be reformatted
'* Returns:     True if the Table is valid for reformat. false otherwise
'*******************************************************************************************************
Public Function IsOkToReformatTable(oTable As Table) As Boolean
'    If IsRangeInSpecialSection(oTable.Range) Then
'        IsOkToReformatTable = False
'        modError.DisplayMsg "Table in front pages or back pages cannot be reformatted.", vbInformation, "Table Reformat"
'    Else
    If Not Selection.Information(wdWithInTable) Then
        IsOkToReformatTable = False
        modError.DisplayMsg "Table cells can only be reformatted when the whole selection is within a table.", vbInformation, "Table Selection Reformat"
    Else
        IsOkToReformatTable = True
    End If
'    End If
End Function

'*******************************************************************************************************
'* Description: Checks if its ok to reformat given table selection
'* Parameters:  n/a
'* Returns:     True if the Table selection is valid for reformat. false otherwise
'*******************************************************************************************************
Public Function IsOkToReformatSelection() As Boolean
'    If IsRangeInSpecialSection(Selection.Range) Then
'        IsOkToReformatSelection = False
'        modError.DisplayMsg "Table cells in front pages or back pages cannot be reformatted.", vbInformation, "Table Selection Reformat"
    If Not Selection.Information(wdWithInTable) Then
        IsOkToReformatSelection = False
        modError.DisplayMsg "Table cells can only be reformatted when the whole selection is within a table.", vbInformation, "Table Selection Reformat"
    Else
        IsOkToReformatSelection = True
    End If
End Function


'++*******************************************************************
' Description:  Will check if the given table is unified (no merged cells)
' Parameters:   oTable - Table to be checked
'               checkRows - if true - Will check vertical merging
'               checkColumns - if true -  Will check horizontal merging
' Returns:      True if the table is unified, false otherwise
'--********************************************************************
Public Function IsTableUnified(oTable As Table, Optional checkRows As Boolean = True, Optional checkColumns As Boolean = True) As Boolean
    On Error GoTo ErrorHandler
    Dim oRow As Row
    Dim oCollumn As Column
    
    If checkRows Then
        For Each oRow In oTable.Rows
        Next
    End If
    
    If checkColumns Then
        For Each oCollumn In oTable.Columns
        Next
    End If
    
    IsTableUnified = True
    
CleanExit:
    Exit Function
ErrorHandler:
    IsTableUnified = False
    Resume CleanExit
End Function

Attribute VB_Name = "modTools"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modPrivate
'*

'***********************************************************************************

Option Explicit
Option Private Module 'makes all macros private to this module - NO!!!! It makes it _
                        private to this PROJECT!

Private Const MODULE_NAME As String = "modTools"

Dim gbLocationBookMark As Bookmark

' Bookmarks the current location
' Use this along with GotoLocation to manage the cursor
' location when programatically modifying the document
Sub SaveLocation()

    On Error Resume Next

    Set gbLocationBookMark = ActiveDocument.Bookmarks.Add("Origin", Selection.Range)

End Sub


' Jumps to the Bookmark defines in SaveLocation
Sub GotoLocation()


On Error Resume Next
    If Not gbLocationBookMark Is Nothing Then
        gbLocationBookMark.Select
        gbLocationBookMark.Delete
        ActiveWindow.ScrollIntoView Selection.Range
    End If

End Sub
Attribute VB_Name = "modUserFormUtilities"
'***********************************************************************************
'* Created by - Brochet ltd
'*              www.brochet.co.uk
'*              01264 730450
'*
'* Module: modUserFormUtilities
'*
'* General tools for managing Userforms
'*
'***********************************************************************************
Option Explicit
Option Private Module
Private Const MODULE_NAME As String = "modUserFormUtilities"



Sub CentreFormOnScreen(fForm As Object, Optional bCentreScreen As Boolean = False)

    With fForm
        .Left = Application.Left + (0.5 * Application.Width) - (0.5 * .Width)
        .Top = Application.Top + (0.5 * Application.Height) - (0.5 * .Height)

    End With


End Sub
Attribute VB_Name = "modUtils"
Option Explicit
Option Private Module

Sub PrintStyleInformation()

Dim sStyle As Style
Dim rRange As Range

    Set rRange = ActiveDocument.Range
    rRange.Collapse wdCollapseEnd

    AddHeading rRange
    

    For Each sStyle In ActiveDocument.Styles
        AddStyleName rRange, sStyle
        AddText rRange, sStyle.Font.Size
        AddText rRange, sStyle.Font.Name
    '    AddText rRange, sStyle.ParagraphFormat.SpaceBefore
     '   AddText rRange, sStyle.ParagraphFormat.SpaceAfter
        
        rRange.Collapse wdCollapseEnd
        rRange.InsertAfter vbCrLf
   Next
    
End Sub

Sub AddHeading(rRange As Range)

    AddText rRange, "Style Name"
    AddText rRange, "Font Size"
    AddText rRange, "Font Name"
'    AddText rRange, "Para Space Before"
'    AddText rRange, "Para Space After"
    
            rRange.Collapse wdCollapseEnd
        rRange.InsertAfter vbCrLf

End Sub

Sub AddText(rRange As Range, sString As String)


        rRange.InsertAfter sString
        rRange.InsertAfter vbTab
        rRange.Collapse wdCollapseEnd

End Sub
Sub AddStyleName(rRange As Range, sStyle As Style)


        rRange.InsertAfter sStyle.NameLocal
        rRange.Font.Name = sStyle.Font.Name
        rRange.Font.Size = sStyle.Font.Size
        rRange.Font.TextColor = sStyle.Font.TextColor
        rRange.InsertAfter vbTab
        rRange.Collapse wdCollapseEnd
        rRange.Font.TextColor = wdBlack
End Sub

Sub PrintDocVars()

Dim dv As Variable

    For Each dv In ActiveDocument.Variables
        Debug.Print dv.Name & " = " & dv.value
        
    Next

End Sub

' InQuest injected base64 decoded content
' Szjej
' Zn)b
' Zn)b
' '^N+ex
' Qzj/x
' jx.j
' jx.j
' Zn)b
' jx.j
' lL^r
' x*&n
' !bzW
' "{"u
' l"tZ
' K?"{
' Szjej
' z{Szjej
' jx.j
' Zn)b
' z{Ry
' zjej
' zjej
' zjej
' aZ+a
' z{Uj
' jTbm
' jTbm
' y*Zq
' +-jw
' *^r&

INQUEST-PP=macro
