Attribute VB_Name = "FOIMethod"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Name As String
Public OutputCellRef As String
Public OutputType As String
Public Params As New Collection
Attribute VB_Name = "FOIParam"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Name As String
Public CellRef As String
Public VarType As String
Attribute VB_Name = "FOISheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Name As String
Public index As Long
Public FOIMethods As New Collection

Property Get Methods() As Collection
    Set Methods = FOIMethods
End Property
Attribute VB_Name = "FPIVariable"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public TagName As String
Public VarType As String
Public CellRef As String
Public TableMode As String
Attribute VB_Name = "NewFPIDlg"
Attribute VB_Base = "0{80968A3C-D2D5-4B59-884E-0CE3FB21194D}{2864F5B7-46B3-42FC-9C6D-7B63DFA6C613}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cmdAdd_Click()
    ' Create a new FPIVariable object
    Dim obj As New FPIVariable
    Dim pos As Integer
    
    ' Make sure tag name is given, otherwise
    ' we don't accept it
    If txtTagName = "" Then Exit Sub
    
    ' If this new tag already exists, select the
    ' existing one
    Dim i As Integer
    For i = 0 To lstVariables.ListCount - 1
        If txtTagName Like lstVariables.List(i, 0) Then
            ' Select this item and flee
            lstVariables.ListIndex = i
            Exit Sub
        End If
    Next i
    
    ' Fill in the details
    obj.TagName = txtTagName.Text
    obj.VarType = cmbType.Value
    obj.CellRef = txtCellRef.Text
    obj.TableMode = txtTableMode.Text
    
    ' Check whether this is a gTIME definition
    ' If it is, add it to the front of the list
    If obj.TagName = "gTIME" And modMakeFPSheet.FPIVariables.count <> 0 Then
        modMakeFPSheet.FPIVariables.Add obj, obj.TagName, 1
    Else
        ' Add it to the public collection
        modMakeFPSheet.FPIVariables.Add obj, obj.TagName
    End If
    
    ' Select this latest object in the list
    pos = AddListItem(lstVariables, obj.TagName)
    lstVariables.ListIndex = pos
    
    ' Reset focus to TagName input
    txtTagName.SelStart = 0
    txtTagName.SelLength = txtTagName.TextLength
    txtTagName.SetFocus
End Sub

Private Sub cmdCancel_Click()
    ' Need to clear out the collection
    While modMakeFPSheet.FPIVariables.count > 0
        modMakeFPSheet.FPIVariables.Remove 1
    Wend
    
    Unload Me
End Sub

Private Sub cmdDelete_Click()
    ' Delete this item from the list
    Dim index As Integer
    
    index = lstVariables.ListIndex
    If index > -1 Then
        ' Remove it from collection
        modMakeFPSheet.FPIVariables.Remove lstVariables.Value
        
        ' and now the listbox
        lstVariables.RemoveItem index
    End If
    
    ' If there are no longer any entries
    ' Empty the textboxes
    If lstVariables.ListCount = 0 Then
        txtTagName.Text = ""
        cmbType.Value = Null
        txtCellRef = ""
        txtTableMode = ""
    End If
End Sub

Private Sub cmdOK_Click()
    Unload Me
End Sub

Private Sub lstVariables_Change()
    ' If an item is selected, update all the
    ' textboxes
    If lstVariables.ListIndex > -1 Then
        With modMakeFPSheet.FPIVariables(lstVariables.Value)
            txtTagName.Text = .TagName
            txtCellRef = .CellRef
            txtTableMode = .TableMode
            
            Select Case Left(.VarType, 1)
                Case "R", "r"
                    cmbType.Value = "Real"
                Case "I", "i"
                    cmbType.Value = "Integer"
                Case "L", "l"
                    cmbType.Value = "Logical"
                Case Else
                    cmbType.Value = Null
            End Select
        End With
    End If
End Sub

Private Sub UserForm_Initialize()
    On Error Resume Next
    
    ' Set the focus so that a new tag can be added straight away
    txtTagName.SetFocus
    
    ' Initialise the drop-down list of types
    cmbType.AddItem "Integer"
    cmbType.AddItem "Logical"
    cmbType.AddItem "Real"
    
    ' Get any tags already defined
    Dim ws As Worksheet
    
    Set ws = Worksheets("gfpi")
    If Not ws Is Nothing Then
        ' Some tags are already defined. Get them.
        GetTags ws, modMakeFPSheet.FPIVariables
    End If
        
    ' Makes the listbox automatically resize to
    ' fit complete lines in
    lstVariables.AddItem ""
    lstVariables.RemoveItem 0
    
    ' Initialise the listbox
    Dim tag As FPIVariable
    For Each tag In modMakeFPSheet.FPIVariables
        AddListItem lstVariables, tag.TagName
    Next tag
End Sub
Attribute VB_Name = "Sheet31"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "frmMain"
Attribute VB_Base = "0{99867336-8EED-45FE-8137-9C79F5AE104F}{2F7B65EC-C039-47B0-9989-414130F56938}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Compare Text
Private sheet_defs As New Collection
Private old_height As Long

Property Get CurrentWorksheet() As Worksheet
    If lstSheets.ListIndex = -1 Then
        Set CurrentWorksheet = Nothing
    Else
        Set CurrentWorksheet = Sheets(sheet_defs(lstSheets.ListIndex + 1).index)
    End If
End Property

Property Get CurrentFOISheet() As FOISheet
    If lstSheets.ListIndex = -1 Then
        Set CurrentFOISheet = Nothing
    Else
        Set CurrentFOISheet = sheet_defs(lstSheets.ListIndex + 1)
    End If
End Property

Property Get Methods(i As Long) As Collection
    Set Methods = sheet_defs(i).FOIMethods
End Property

Private Sub cmdDelete_Click()
    ' Delete the worksheet selected in the listbox
    Dim index As Long
    
    index = lstSheets.ListIndex
    If index > -1 Then
        ' A worksheet name is selected, so delete it
        Dim num_ws As Long
        Dim ws_index As Long
        ws_index = sheet_defs(index + 1).index
        num_ws = Worksheets.count
        Sheets(ws_index).Delete
        
        ' Check to see whether it has been deleted
        If Worksheets.count <> num_ws Then
            ' Remove this item from the listbox and the
            ' array of worksheet indices
            lstSheets.RemoveItem index
            sheet_defs.Remove index + 1
            
            ' Correct the worksheet indices
            Dim sh As FOISheet
            
            For Each sh In sheet_defs
                If sh.index > ws_index Then
                    sh.index = sh.index - 1
                End If
            Next sh
        End If
    End If
End Sub

Private Sub cmdExit_Click()
    Unload Me
End Sub

Private Sub cmdMethods_Click()
    Dim dlg As New frmMethods
    
    ' Check that a method is selected
    If lstSheets.ListIndex = -1 Then Exit Sub
    
    ' Show the methods dialog
    Load dlg
    dlg.Show
End Sub

Private Sub cmdNewSheet_Click()
    Dim dlg As New frmNewSheet
    dlg.Show
    
    ' Check whether a valid name has been specified
    If dlg.txtNewName = "" Then Exit Sub
    
    Dim index As Long
    Dim pos As Long
    Dim i As Long
        
    ' Check whether this sheet exists already
    For i = 0 To lstSheets.ListCount - 1
        If dlg.txtNewName Like lstSheets.List(i) Then
            lstSheets.ListIndex = i
            Exit Sub
        End If
    Next i
        
    ' Add this name to the listbox
    index = AddListItem(lstSheets, dlg.txtNewName)
        
    ' Now add a new worksheet
    Dim sh As New FOISheet
        
    pos = AddNewFOWorksheet(ActiveWorkbook, "gFO-" + dlg.txtNewName)
        
    ' Add this worksheet to the collection
    sh.index = pos
    sh.Name = dlg.txtNewName
    If sheet_defs.count = 0 Then
        sheet_defs.Add sh
    Else
        sheet_defs.Add sh, , index + 1
    End If
        
    ' Select this sheet in the listbox
    lstSheets.ListIndex = index
    
    ' Fill in helpful hints
    ActiveSheet.Cells(20, 1).Value = "Notes:"
    ActiveSheet.Cells(21, 1).Value = "1.  gExcelFOI searches for method definitions by looking for the word ""Output"" in the first row"
    ActiveSheet.Cells(22, 1).Value = "     of a ""gFO-"" worksheet. The search starts in cell B1 and ends when it reaches an empty cell."
    ActiveSheet.Cells(23, 1).Value = "     Any column not headed by ""Output"" is considered an input of the current method."
    ActiveSheet.Cells(24, 1).Value = "     All inputs to a method must be provided a suitable column heading name. As in"
    ActiveSheet.Cells(25, 1).Value = "     gPROMS, the order of inputs is left to right."
    
    ActiveSheet.Cells(27, 1).Value = "2.  In an ""Output"" column, the second row must contain the name of the method. This is the method"
    ActiveSheet.Cells(28, 1).Value = "     name used in the gPROMS input file"
    
    ActiveSheet.Cells(30, 1).Value = "3.  The Cell X-reference tells gExcelFOI where the parameter values for a method go (for input"
    ActiveSheet.Cells(31, 1).Value = "     columns) and where to retrieve the method return value from (for ""output"" columns). For a method"
    ActiveSheet.Cells(32, 1).Value = "     call, gExcelFOI places the input values in the correct cells, recalculates the workbook, and then"
    ActiveSheet.Cells(33, 1).Value = "     returns the value in the ""Output"" cell to gPROMS."
    
    ActiveSheet.Cells(35, 1).Value = "4.  The 'Type' field can be either (R)eal, (I)nteger, (L)ogical or (S)tring. These types must correlate with the internal"
    ActiveSheet.Cells(36, 1).Value = "     gPROMS variables used in the method call. Currently all gPROMS variables are of type Real, but"
    ActiveSheet.Cells(37, 1).Value = "     gPROMS parameters may be of type Integer, Logical or Ordered_Set (String) as well. Note that the String type is applicable only to an 'Output' parameter."
    
    ActiveSheet.Cells(39, 1).Value = "5.  All the dimension fields (Rows 5 to 14) are ignored at the moment, along with the SI Offset and"
    ActiveSheet.Cells(40, 1).Value = "     SI Mulitplier fields. These are for future compatibility with new versions of gPROMS."
    
    ActiveSheet.Cells(42, 1).Value = "6.  The derivative cell (row 17) is another cell X-reference. If this cell is empty, it indicates that the"
    ActiveSheet.Cells(43, 1).Value = "     time derivative of the method is unavailable. Otherwise it should indicate where the derivative value"
    ActiveSheet.Cells(44, 1).Value = "     is."
End Sub

Private Sub lstSheets_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    ' Show the definition sheet for the selected sheet name
    Dim ws As Worksheet
    Dim ws_name As String
    
    ws_name = "gFO-" + lstSheets.Value
    
    For Each ws In Worksheets
        If ws.Name Like ws_name Then
'            If ws.Visible = xlSheetVisible Then
                ws.Activate
'            End If
            Exit For
        End If
    Next ws
End Sub

Private Sub UserForm_Initialize()
    Dim ws As Worksheet
    Dim list_name As String
    Dim index As Long
    Dim i As Long
    Dim sh As FOISheet
    
    ' Makes the listbox automatically resize to
    ' fit complete lines in
    lstSheets.AddItem ""
    lstSheets.RemoveItem 0
    
    ' Find all the existing FO definition sheets
    ' and add them to the list
    For i = 1 To Worksheets.count
        Set ws = Worksheets(i)
        If Left(ws.Name, 4) Like "gFO-" Then
            list_name = Right(ws.Name, Len(ws.Name) - 4)
            index = AddListItem(lstSheets, list_name)
            
            ' Store the index of this worksheet in the
            ' workbook
            Set sh = New FOISheet
            sh.Name = list_name
            sh.index = ws.index
            
            ' Get the methods for this sheet
            GetSheetMethods sh
            
            ' Add this sheet to the collection
            If sheet_defs.count = 0 Then
                sheet_defs.Add sh
            Else
                sheet_defs.Add sh, , index + 1
            End If
        End If
    Next i
    
    ' Store the old height of the list box
    old_height = lstSheets.Height
End Sub

' LongArrayInsert
'
' Index starts at 0.
'
Private Sub LongArrayInsert(arr() As Long, curr_size As Long, index As Long, val As Long)
    Dim i As Long
    ReDim Preserve arr(0 To curr_size)
    
    For i = curr_size To index + 1 Step -1
        arr(i) = arr(i - 1)
    Next i
    arr(index) = val
End Sub

' LongArrayRemove
'
' Index starts at 0
'
Private Sub LongArrayRemove(arr() As Long, curr_size As Long, index As Long)
    Dim i As Long
    
    For i = index To curr_size - 2
        arr(i) = arr(i + 1)
    Next i
    
    ReDim Preserve arr(0 To curr_size - 2)
End Sub
Attribute VB_Name = "frmMethods"
Attribute VB_Base = "0{7BC4B206-E073-4F49-8B45-54D11BA017C0}{147017E5-E21E-4BDA-B3FE-E16DF0F4A710}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Text
Private curr_method As FOIMethod
Private param_method As String

Private Sub cmbOutputType_Change()
    If Not curr_method Is Nothing Then
        If txtMethodName Like lstMethods.Value Then
            curr_method.OutputType = cmbOutputType.Value
        End If
    End If
End Sub

Private Sub cmbParamType_Change()
    Dim param As FOIParam
    If lstParams.ListIndex > -1 Then
        If txtParamName Like lstParams.Value Then
            Set param = curr_method.Params(lstParams.Value)
            param.VarType = cmbParamType.Value
        End If
    End If
End Sub

Private Sub cmdCancel_Click()
    ' Clear the list of methods
    Dim curr_sheet As FOISheet
    
    Set curr_sheet = frmMain.CurrentFOISheet
    While curr_sheet.FOIMethods.count > 0
        curr_sheet.FOIMethods.Remove 1
    Wend
    
    ' Now rebuild this list
    GetSheetMethods curr_sheet
    
    ' Get rid of the dialog box
    Unload Me
End Sub

Private Sub cmdMethodAdd_Click()
    ' Add a method to the list
    Dim obj As New FOIMethod
    
    ' Check whether a method name had been given
    If txtMethodName = "" Then Exit Sub
    
    ' If this method already exists, then select
    ' the existing method and exit
    Dim i As Integer
    For i = 0 To lstMethods.ListCount - 1
        If txtMethodName Like lstMethods.List(i, 0) Then
            ' Select this item and flee
            lstMethods.ListIndex = i
            Exit Sub
        End If
    Next i
    
    ' Initialise the method
    obj.Name = txtMethodName
    obj.OutputType = cmbOutputType.Value
    obj.OutputCellRef = txtOutputCellRef
    
    ' Add this method to the collection
    frmMain.CurrentFOISheet.FOIMethods.Add obj, obj.Name
    
    ' Add it to the listbox
    Dim index As Long
    index = AddListItem(lstMethods, obj.Name)
    lstMethods.ListIndex = index
        
    ' Reset focus to method name
    With txtMethodName
        .SelStart = 0
        .SelLength = .TextLength
        .SetFocus
    End With
End Sub

Private Sub cmdMethodRemove_Click()
    ' Remove a method from the list
    Dim index As Integer
    
    index = lstMethods.ListIndex
    If index = -1 Then Exit Sub
    
    ' Remove this method from the internal
    ' collection and the listbox
    frmMain.CurrentFOISheet.FOIMethods.Remove lstMethods.Value
    lstMethods.RemoveItem (index)
    
    ' If there are no longer any entries,
    ' update things
    If lstMethods.ListCount = 0 Then
        lstMethods_Change
    End If
End Sub

Private Sub cmdMethods_Click()
    fmeParams.Visible = False
    fmeMethods.Visible = True
    txtMethodName.SelStart = 0
    txtMethodName.SelLength = Len(txtMethodName)
    txtMethodName.SetFocus
End Sub

Private Sub cmdOK_Click()
    ' Fill in the worksheet with the current methods
    Dim ws As Worksheet
    Dim rng As range
    Dim method As FOIMethod
    Dim param As FOIParam
    Dim curr_col As Long
    Dim col As String
    Dim input_num As Long
    Dim j As Long
    
    Set ws = frmMain.CurrentWorksheet
    curr_col = 2
    For Each method In frmMain.CurrentFOISheet.FOIMethods
        
        ' Remove the gridlines to make it look pretty
        ' ActiveWindow.DisplayGridlines = False
    
        ' Output first:
        '   Put the heading and name in
        ws.Cells(1, curr_col).Value = "Output"
        ws.Cells(2, curr_col).Value = method.Name
        ws.Cells(3, curr_col).Value = method.OutputCellRef
        ws.Cells(4, curr_col).Value = method.OutputType
        ws.Cells(17, curr_col).Value = "N/A"
        
        '   Colours
        col = NumToString(curr_col)
        With ws.range(col + "2", col + "17").Interior
            .ColorIndex = 42    ' Aqua
            .Pattern = xlSolid
            .PatternColorIndex = xlAutomatic
        End With
        
        ' Now input parameters
        curr_col = curr_col + 1
        input_num = 1
        For Each param In method.Params
            ' Put the heading and name in
            ws.Cells(1, curr_col).Value = "Input #" + CStr(input_num)
            ws.Cells(2, curr_col).Value = param.Name
            ws.Cells(3, curr_col).Value = param.CellRef
            ws.Cells(4, curr_col).Value = param.VarType
            
            ' Colours
            col = NumToString(curr_col)
            With ws.range(col + "2", col + "17").Interior
                .ColorIndex = 40    ' Tan
                .Pattern = xlSolid
                .PatternColorIndex = xlAutomatic
            End With
            
            ' Next column
            curr_col = curr_col + 1
            input_num = input_num + 1
        Next param
        
        ' Add a division bar to mark the end of a method
        Set rng = ws.Cells(1, curr_col - 1)
        Set rng = rng.Resize(17, 1)
        With rng.Borders(xlEdgeRight)
            .LineStyle = xlContinuous
            .Weight = xlThin
            .ColorIndex = xlAutomatic
        End With
    Next method
        
    ' Default values
    Dim last_col As String
    
    last_col = NumToString(curr_col - 1)
    Set rng = ws.range("B5", last_col + "14")
    rng.Value = "0/1"
    Set rng = ws.range("B15", last_col + "15")
    rng.Value = "0"                             ' SI Offset
    Set rng = rng.Offset(1, 0)
    rng.Value = "1"                             ' SI Multiplier
    
    ' Formatting
    ws.range("B4", last_col + "17").NumberFormat = "@"
    With ws.range("B1", last_col + "17")
        .HorizontalAlignment = xlCenter
        .ColumnWidth = 12
    End With
       
    ' Now make it look pretty
    With ws.range("B1", last_col + "1").Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    
    With ws.range("B2", last_col + "2").Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    With ws.range("B4", last_col + "4").Borders(xlEdgeBottom)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
            
    With ws.range("B14", last_col + "14").Borders(xlEdgeBottom)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    With ws.range("B16", last_col + "16").Borders(xlEdgeBottom)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    ' Clear any other columns after this last one
    Set rng = ws.Cells(1, curr_col)
    Set rng = rng.Resize(17, 1)
    While rng(1, 1).Value <> ""
        rng.Clear
        Set rng = rng.Offset(0, 1)
    Wend
    
    ' Quit this form
    Unload Me
End Sub

Private Sub cmdParamAdd_Click()
    ' Add a parameter to the current method
    
    ' Check that the parameter has a name
    If txtParamName = "" Then Exit Sub
    
    ' If this parameter already exists, then select
    ' the existing parameter and exit
    Dim i As Integer
    For i = 0 To lstParams.ListCount - 1
        If txtParamName = lstParams.List(i, 0) Then
            ' Select this item and flee
            lstParams.ListIndex = i
            Exit Sub
        End If
    Next i
    
    ' Initialise new parameter
    Dim param As New FOIParam
    
    param.Name = txtParamName
    param.CellRef = txtParamCellRef
    param.VarType = cmbParamType.Value
    
    ' Add it to the method's list
    curr_method.Params.Add param, param.Name
    
    ' Update the listbox
    Dim index As Long
    index = AddListItem(lstParams, param.Name)
    lstParams.ListIndex = index
    
    ' Reset focus to parameter name
    With txtParamName
        .SelStart = 0
        .SelLength = .TextLength
        .SetFocus
    End With
End Sub

Private Sub cmdParameters_Click()
    ' Check whether the method has changed since
    ' last time the parameters were modified
    If curr_method.Name = param_method Then
        GoTo Show
    End If
    param_method = curr_method.Name
    
    ' Update list of parameters
    Dim param As FOIParam
    lstParams.Clear
    
    For Each param In curr_method.Params
        AddListItem lstParams, param.Name
    Next param
    
    ' Now the other controls
    txtParamName = ""
    txtParamCellRef = ""
    cmbParamType.Value = Null
    
    ' Now can show the parameters frame
    fmeParams.Caption = Left(fmeParams.Caption, 15) + txtMethodName.Value + ":"

Show:
    fmeParams.Visible = True
    fmeMethods.Visible = False
    txtParamName.SetFocus
End Sub

Private Sub cmdParamRemove_Click()
    ' Remove a parameter from the list
    Dim index As Integer
    
    index = lstParams.ListIndex
    If index = -1 Then Exit Sub
    
    ' Remove this parameter from the internal
    ' collection and the listbox
    curr_method.Params.Remove lstParams.Value
    lstParams.RemoveItem (index)
    
    ' If there are no longer any entries
    ' Empty the textboxes
    If lstParams.ListCount = 0 Then
        lstParams_Change
    End If
End Sub

Private Sub lstMethods_Change()
    On Error GoTo onerror
    
    ' Update everything
    If lstMethods.ListIndex = -1 Then
        cmdParameters.Enabled = False
        txtMethodName = ""
        txtOutputCellRef = ""
        cmbOutputType.Value = ""
        
        Set curr_method = Nothing
    Else
        cmdParameters.Enabled = True
        
        ' Find this method
        Set curr_method = frmMain.CurrentFOISheet.FOIMethods(lstMethods.Value)
        
        ' Setup the controls for this method
        txtMethodName = curr_method.Name
        txtOutputCellRef = curr_method.OutputCellRef
        
        Select Case Left(curr_method.OutputType, 1)
            Case "R", "r"
                cmbOutputType.Value = "Real"
            Case "I", "i"
                cmbOutputType.Value = "Integer"
            Case "L", "l"
                cmbOutputType.Value = "Logical"
            Case "S", "s"
                cmbOutputType.Value = "String"
            Case Else
                cmbOutputType.Value = Null
        End Select
    End If
    
onerror:
    ' Probably just means the method is new and hasn't been
    ' attached to the methods collection
End Sub

Private Sub lstParams_Change()
    On Error GoTo onerror
    
    ' Update everything
    Dim index As Integer
    Dim obj As FOIParam
    
    index = lstParams.ListIndex
    
    If lstParams.ListIndex = -1 Then
        ' Clear everything
        txtParamName = ""
        txtParamCellRef = ""
        cmbParamType.Value = Null
    Else
        ' Get the parameter object
        Set obj = curr_method.Params(lstParams.Value)
    
        ' Fill in the parameter name and type textboxes
        txtParamName = obj.Name
        txtParamCellRef = obj.CellRef
        
        Select Case Left(obj.VarType, 1)
            Case "R", "r"
                cmbParamType.Value = "Real"
            Case "I", "i"
                cmbParamType.Value = "Integer"
            Case "L", "l"
                cmbParamType.Value = "Logical"
            Case Else
                cmbParamType.Value = Null
        End Select
    End If
    
onerror:
    ' Probably just means the parameter is new and hasn't been
    ' attached to the parameters collection
End Sub

Private Sub txtOutputCellRef_Change()
    If Not curr_method Is Nothing Then
        If txtMethodName Like lstMethods.Value Then
            curr_method.OutputCellRef = txtOutputCellRef
        End If
    End If
End Sub

Private Sub txtParamCellRef_Change()
    Dim param As FOIParam
    If lstParams.ListIndex > -1 Then
        If txtParamName Like lstParams.Value Then
            Set param = curr_method.Params(lstParams.Value)
            param.CellRef = txtParamCellRef
        End If
    End If
End Sub

Private Sub UserForm_Initialize()
    txtMethodName.SetFocus
    
    ' Initialise the drop-down list of types
    cmbOutputType.AddItem "Integer"
    cmbOutputType.AddItem "Logical"
    cmbOutputType.AddItem "Real"
    cmbOutputType.AddItem "String"
    
    cmbParamType.AddItem "Integer"
    cmbParamType.AddItem "Logical"
    cmbParamType.AddItem "Real"
    
    ' Get any methods already defined
    Dim sh As FOISheet
    Dim method As FOIMethod
    
    Set sh = frmMain.CurrentFOISheet
    For Each method In sh.FOIMethods
        AddListItem lstMethods, method.Name
    Next method
    
    ' Change the caption
    Me.Caption = "Methods for sheet 'gFO-" + frmMain.CurrentFOISheet.Name + "'"
End Sub
Attribute VB_Name = "frmNewSheet"
Attribute VB_Base = "0{176F31EC-E540-4EE0-B076-9599A438A49A}{2F81DFAF-DB5E-4F99-A638-BDFD09C7E3BA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cmdCancel_Click()
    txtNewName = ""
    Unload Me
End Sub

Private Sub cmdOK_Click()
    Unload Me
End Sub
Attribute VB_Name = "modMakeFOSheet"
Option Explicit
Public FOIMethods As New Collection

Sub MakeFOSheet()
Attribute MakeFOSheet.VB_ProcData.VB_Invoke_Func = "O\n14"
    ' Launch the FOI Creator form
    Load frmMain
    frmMain.Show
End Sub

Function NumToString(ByVal column As Integer) As String
    column = column - 1
    If column < 26 Then
        NumToString = Chr$(Asc("A") + column)
    Else
        Dim first_letter As String
        Dim int1, int2 As Integer
        
        int1 = Int(column / 26)
        int2 = column Mod 26
        NumToString = NumToString(int1) + NumToString(int2 + 1)
    End If
End Function

Attribute VB_Name = "modMakeFPSheet"
Option Explicit
Public FPIVariables As New Collection

Sub MakeFPSheet()
Attribute MakeFPSheet.VB_ProcData.VB_Invoke_Func = "P\n14"
    Dim dialog As New NewFPIDlg
    Dim ws As Worksheet
    Dim num_tags As Integer
    Dim i As Integer
    Dim last_col, column As String
    Dim old_num_tags As Integer
    Dim obj As FPIVariable
        
    ' Load the dialog first
    Load dialog
    dialog.Show
    
    ' If cancel was pressed, disappear
    num_tags = FPIVariables.count
    If num_tags = 0 Then End
    
    ' The worksheet name is "gFPI". If this worksheet already exists, use
    ' it. Otherwise create a new one
    old_num_tags = 0
    For i = 1 To Worksheets.count
        If Worksheets(i).Name = "gFPI" Then
            Set ws = Worksheets(i)
            
            ' Scan for the current number of tags
            While ws.Cells(1, old_num_tags + 2).Value <> ""
                old_num_tags = old_num_tags + 1
            Wend
        End If
    Next i
    
    If ws Is Nothing Then
        ' Add the new sheet
        Worksheets.Add after:=ActiveSheet
        
        ' Remove the gridlines to make it look pretty
        ActiveWindow.DisplayGridlines = False
        
        ' Set this as the working worksheet
        Set ws = ActiveSheet
        ws.Name = "gFPI"
        
        ' Put the headings in
        ws.Cells(1, 1).Value = "Tag name"
        ws.Cells(2, 1).Value = "Type (R, I or L)"
        ws.Cells(3, 1).Value = "Cell X-ref"
        ws.Cells(4, 1).Value = "Table mode (C, R or none)"
        ws.Cells(6, 1).Value = "Execution mode"
        
        ' Format it
        With ws.range("A1:A4")
            .ColumnWidth = 22
            .VerticalAlignment = xlCenter
            .RowHeight = .RowHeight + 4
            .BorderAround xlContinuous, xlMedium, xlColorIndexAutomatic
            .Borders(xlEdgeRight).Weight = xlThin
        End With
        
        ' Put some info on this sheet
        ws.Cells(8, 1).Value = "Notes:"
        ws.Cells(9, 1).Value = "1.  'Tag name' is the string used in the GET and SEND commands to attach a tag to a gPROMS variable"
        ws.Cells(11, 1).Value = "2.  The type must correspond to the type of the attached gPROMS variable. At the moment, only "
        ws.Cells(12, 1).Value = "     PARAMETERS support the types INTEGER and LOGICAL."
        ws.Cells(14, 1).Value = "3.  The tag is ignored if the Cell X-Reference is not provided. This cell X-reference informs gExcelFPI where"
        ws.Cells(15, 1).Value = "     to find the value or values to be retrieved for a GET task and modified for a SEND task."
        ws.Cells(17, 1).Value = "4.  The table mode allows tabulation of values. If this is set to 'C', then after each SEND task the cell reference"
        ws.Cells(18, 1).Value = "     effectively moves to the next column. This is column tabulation, whereas 'R' provides row tabulation. Leave"
        ws.Cells(19, 1).Value = "     this cell empty for no tabulation."
        ws.Cells(21, 1).Value = "5.  The execution mode modifies the execution behaviour of the various FPI tasks. 'Manual' mode causes"
        ws.Cells(22, 1).Value = "     the GET task to pause until the workbook has recalculated. This allows user interaction. 'Automatic' mode"
        ws.Cells(23, 1).Value = "     tries to synchronise the gPROMS simulation with the gTIME tag. Each GET task waits until the value"
        ws.Cells(24, 1).Value = "     specified by the gTIME tag is equal to the gPROMS simulation time. ' Normal' mode involves the modification"
        ws.Cells(25, 1).Value = "     and retrieval of values with no pauses, i.e. it does nothing special."
        ws.Cells(27, 1).Value = "6.  The first tag must be defined in the range ""B1:B4"". There must not be any gaps between tag defintions since"
        ws.Cells(28, 1).Value = "     gExcelFPI searches along the first row of this worksheet, retrieving tags, until it reaches an empty cell."
    End If
    
    ' If gTIME was not specified, add it now
    If FPIVariables.item(1).TagName <> "gTIME" Then
        Set obj = New FPIVariable
        obj.TagName = "gTIME"
        obj.VarType = "Real"
        FPIVariables.Add obj, obj.TagName, 1
        num_tags = num_tags + 1
    End If
    
    ' Find out the reference for the last column
    last_col = NumToString(num_tags + 1)
    
    For i = 1 To num_tags
        Set obj = FPIVariables.item(i)
        ws.Cells(1, i + 1).Value = obj.TagName
        ws.Cells(2, i + 1).Value = obj.VarType
        ws.Cells(3, i + 1).Value = obj.CellRef
        ws.Cells(4, i + 1).Value = obj.TableMode
        
        ' Colour the columns
        column = NumToString(i + 1)
        With range(column + "1", column + "4").Interior
            If i Mod 2 Then
                .ColorIndex = 19
            Else
                .ColorIndex = 34
            End If
            .Pattern = xlSolid
            .PatternColorIndex = xlAutomatic
        End With
    Next i
    
    ' Format the cells
    With ws.range("B1", last_col + "4")
        .HorizontalAlignment = xlCenter
        .ColumnWidth = 12
    End With
    
    ' Add a border
    With ws.range("B1", last_col + "4").Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    
    With ws.range("B1", last_col + "4").Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
   
    With ws.range("B1", last_col + "4").Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    
    With ws.range("B1", last_col + "1").Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
        
    For i = 1 To num_tags
        FPIVariables.Remove 1
    Next i
    
    ' Clean up any existing tags that might have been removed
    Dim rng As range
    
    Set rng = ws.Cells(1, num_tags + 2)
    While rng.Value <> ""
        rng.Resize(4, 1).Clear
        Set rng = rng.Offset(0, 1)
    Wend
    
    ' If there are more tags than before, one of the thick borders needs
    ' removing
    If old_num_tags < num_tags Then
        last_col = NumToString(old_num_tags + 1)
        With ws.range(last_col + "1:" + last_col + "4")
            .Borders(xlEdgeRight).LineStyle = xlLineStyleNone
        End With
    End If
End Sub
Attribute VB_Name = "modUtility"
Option Compare Text

Public Function AddListItem(lst As MSForms.ListBox, item As String) As Long
    Dim lower_bound As Long
    Dim upper_bound As Long
    Dim index As Long
    
    upper_bound = lst.ListCount - 1
    lower_bound = 0
    
    If upper_bound = -1 Then
        lst.AddItem item, lower_bound
        AddListItem = lower_bound
    ElseIf item < lst.List(lower_bound) Then
        lst.AddItem item, lower_bound
        AddListItem = lower_bound
    ElseIf item > lst.List(upper_bound) Then
        lst.AddItem item
        AddListItem = upper_bound + 1
    Else
        Do
            index = Int((lower_bound + upper_bound) / 2)
        
            If index = lower_bound Then
                lst.AddItem item, index + 1
                Exit Do
            End If
        
            If item < lst.List(index) Then
                upper_bound = index
            Else
                lower_bound = index
            End If
        Loop
        
        AddListItem = index + 1
    End If
End Function

' GetTags
'
' Generates tags from the definition in a given worksheet.
' These tags are attached to the 'coll' collection
'
Public Sub GetTags(ws As Worksheet, coll As Collection)
    ' Make sure the name of the worksheet is 'gFPI'
    If Not ws.Name Like "gFPI" Then Exit Sub
    
    ' First tag is in "B1:B4"
    Dim rng As range
    Dim tag As FPIVariable
    Dim temp As FPIVariable
    
    Set rng = ws.Cells(1, 2)
    While rng.Value <> ""
        Set tag = New FPIVariable
        tag.TagName = rng.Value
        tag.VarType = rng.Offset(1, 0).Value
        tag.CellRef = rng.Offset(2, 0).Formula
        tag.TableMode = rng.Offset(3, 0).Value
        
        ' Add this to the collection
        coll.Add tag, tag.TagName
        
        ' Next tag
        Set rng = rng.Offset(0, 1)
    Wend
End Sub

' GetSheetMethods
'
' Generates an internal collection of FOIMethod
' objects from a given FOI definition sheet
'
Public Sub GetSheetMethods(sh As FOISheet)
    Dim ws As Worksheet
    Dim rng As range
    Dim method As FOIMethod
    
    Set ws = Sheets(sh.index)
    Set rng = ws.Cells(1, 2)
    While rng.Value <> ""
        If rng.Value Like "Output" Then
            ' Create a new method
            Set method = New FOIMethod
            method.Name = rng.Offset(1, 0).Value
            method.OutputCellRef = rng.Offset(2, 0).Formula
            method.OutputType = rng.Offset(3, 0).Value
            
            ' Get the parameters for this method
            Set rng = GetMethodParams(rng, method)
            
            ' Add it to the collection
            sh.FOIMethods.Add method, method.Name
        Else
            Set rng = rng.Offset(0, 1)
        End If
    Wend
End Sub

' GetMethodParams
'
' The input to this function must be a range which first
' cell is the 'Output' cell of the method definition. It
' returns the next cell along that is not a method
' parameter.
'
Public Function GetMethodParams(ByVal rng As range, method As FOIMethod) As range
    Dim param As FOIParam
    
    Set rng = rng.Offset(0, 1)
    While rng.Value <> "" And Not rng.Value Like "Output"
        Set param = New FOIParam
        param.Name = rng.Offset(1, 0).Value
        param.CellRef = rng.Offset(2, 0).Formula
        param.VarType = rng.Offset(3, 0).Value
        
        ' Add this parameter to the method's list
        method.Params.Add param, param.Name
        
        ' Next cell along
        Set rng = rng.Offset(0, 1)
    Wend
    
    Set GetMethodParams = rng
End Function

Attribute VB_Name = "modWorksheets"
Public Function AddNewFOWorksheet(wb As Workbook, Optional new_name As String, Optional ByVal pos As Long) As Long
    If pos = 0 Then
        ' pos is missing (or invalid)
        wb.Worksheets.Add after:=wb.Worksheets(wb.Worksheets.count)
    Else
        ' Add a new worksheet
        wb.Worksheets.Add (pos)
    End If
    
    ' Rename it
    If new_name <> "" Then
        ActiveSheet.Name = new_name
    End If
        
    ' Remove the gridlines to make it look pretty
    ActiveWindow.DisplayGridlines = False
    
    ' Fill it in
    ActiveSheet.Cells(2, 1).Formula = "Name"
    ActiveSheet.Cells(3, 1).Formula = "Cell X-Ref"
    ActiveSheet.Cells(4, 1).Formula = "Type"
    ActiveSheet.Cells(5, 1).Formula = "[Length]"
    ActiveSheet.Cells(6, 1).Formula = "[Mass]"
    ActiveSheet.Cells(7, 1).Formula = "[Time]"
    ActiveSheet.Cells(8, 1).Formula = "[Electric Current]"
    ActiveSheet.Cells(9, 1).Formula = "[Temperature]"
    ActiveSheet.Cells(10, 1).Formula = "[Amount of Substance]"
    ActiveSheet.Cells(11, 1).Formula = "[Luminous Intensity]"
    ActiveSheet.Cells(12, 1).Formula = "[Plane Angle]"
    ActiveSheet.Cells(13, 1).Formula = "[Solid Angle]"
    ActiveSheet.Cells(14, 1).Formula = "[Money]"
    ActiveSheet.Cells(15, 1).Formula = "SI Offset"
    ActiveSheet.Cells(16, 1).Formula = "SI Multiplier"
    ActiveSheet.Cells(17, 1).Formula = "Derivative"
    Columns("A:A").ColumnWidth = 19.43
    range("A1").Select
    
    ' Now make it look pretty
    With range("A1").Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    
    With range("A2").Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    With range("A4").Borders(xlEdgeBottom)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    With range("A14").Borders(xlEdgeBottom)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    With range("A16").Borders(xlEdgeBottom)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    
    With range("A1:A17").Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    
    ' Return value
    AddNewFOWorksheet = ActiveSheet.index
End Function


INQUEST-PP=macro
