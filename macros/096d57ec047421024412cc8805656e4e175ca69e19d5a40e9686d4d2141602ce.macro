Attribute VB_Name = "AutoExit"
Public Sub Main()
    DebugMsgBox "", "AutoExit:Main"
    If gIsMultiEditShowing Then
        DebugMsgBox "Close the Multi Edit Job Window.", "AutoExit:"
        gJobForm.saveLocation
        Set gJobForm = Nothing
        gIsMultiEditShowing = False
    End If
End Sub

Attribute VB_Name = "AutoNew"
Public Sub Main()
    DebugMsgBox "AutoNew:Main"
    If modInit.ApplicationExists Then
        GetApplication.RunOpenCodeOnActiveDocument
    End If
End Sub
Attribute VB_Name = "AutoOpen"
Public Sub Main()
    DebugMsgBox "AutoOpen:Main"
    If modInit.ApplicationExists Then
        GetApplication.RunOpenCodeOnActiveDocument
    End If
End Sub
Attribute VB_Name = "CTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If Win64 Then
Private Declare PtrSafe Function SetTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As LongPtr, ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As LongPtr
Private Declare PtrSafe Function KillTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As LongPtr) As LongPtr

Private m_TmrID As LongPtr
#Else
Private Declare Function SetTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
Private Declare Function KillTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long) As Long

Private m_TmrID As Long
#End If

Private m_hWnd As Long
Private m_Enabled As Boolean
Private m_Interval As Long
Private m_TimerType As TimerTypes
Private m_JobID As String

Private Const defEnabled As Boolean = False
Private Const defInterval As Long = 0
Private Const defTimerType As Integer = 0 'Not Set

Public Event Timer()

Public Enum TimerTypes
    NotSet = 0
    ExternalDialog = 1
    SaveDialog = 2
End Enum

' ****************************************************
'  Initialization and Termination
' ****************************************************
Private Sub Class_Initialize()
   ' Set default values for members
   m_Enabled = defEnabled
   m_Interval = defInterval
   m_TimerType = defTimerType
   ' Get handle for main application window.
   m_hWnd = hWndMain()
End Sub

Private Sub Class_Terminate()
   ' Make sure timer is wiped out.
   Call KillTimer(m_hWnd, m_TmrID)
End Sub

' ****************************************************
'  Public Properties
' ****************************************************
Public Property Get Enabled() As Boolean
   ' Return cached setting.
   Enabled = m_Enabled
End Property

Public Property Let Enabled(ByVal NewEnabled As Boolean)
   ' Stop current timer, if already running.
   If m_Enabled Then
      Call KillTimer(m_hWnd, m_TmrID)
      m_TmrID = 0
   End If
   
   ' Cache passed value.
   m_Enabled = NewEnabled
   
   ' An interval of zero implicitly disables timer.
   If m_Interval > 0 Then
      ' Set new timer, if requested.
      If m_Enabled Then
         ' Pass pointer to Me so we can return event to this instance.
         m_TmrID = SetTimer(m_hWnd, ObjPtr(Me), m_Interval, AddressOf TimerProc)
      End If
   End If
End Property

Public Property Get Interval() As Long
   ' Return cached value.
   Interval = m_Interval
End Property

Public Property Let Interval(ByVal NewInterval As Long)
   ' Cache passed value, and reset timer.
   If NewInterval >= 0 Then
      m_Interval = NewInterval
      Me.Enabled = m_Enabled
   End If
End Property

Public Property Get TimerType() As Integer
   ' Return cached value.
   TimerType = m_TimerType
End Property

Public Property Let TimerType(ByVal NewTimerType As Integer)
   ' Cache passed value.
   m_TimerType = NewTimerType
End Property

Public Property Get JobID() As String
   ' Return cached value.
   JobID = m_JobID
End Property

Public Property Let JobID(ByVal NewJobID As String)
   m_JobID = NewJobID
End Property

' ****************************************************
'  Public Methods
' ****************************************************
Public Sub RaiseTimer()
'   RaiseEvent Timer
    
    On Error GoTo ErrorHandler

    Dim currentState As String
    If m_TimerType = ExternalDialog Then
        DebugMsgBox "Call wsm_GetDialogStatus", "RaiseTimer"
        currentState = ss.wsm_GetDialogStatus()
        DebugMsgBox "State - " & currentState, "RaiseTimer"
        If Not currentState = "Open" Or waitDialog.bCancelClicked Then
            If currentState = "Cancel" Then
                DebugMsgBox "Cancel", "RaiseTimer"
            Else
                waitDialog.bSelectedClicked = True
            End If
            DebugMsgBox "waitDialog.KillMe", "RaiseTimer"
            waitTimer.Enabled = False
            waitDialog.KillMe
        End If
    ElseIf m_TimerType = SaveDialog Then
        'NON DIALOG WAIT TYPE
        If Not waitForSaveDialog.bCancelClicked Then
            Dim bInProgress As Boolean
            DebugMsgBox "Call wsm_GetSPSJobPendingState", "RaiseTimer"
            bInProgress = ss.wsm_GetSPSJobPendingState(m_JobID)
            DebugMsgBox "bInProgress - " & bInProgress, "RaiseTimer"
            If Not bInProgress Then
                DebugMsgBox "waitForSaveDialog.KillMe", "RaiseTimer"
                waitTimer.Enabled = False
                waitForSaveDialog.KillMe
            End If
        Else
            'Form killing self, we don't need to.  Just stop timer.
            DebugMsgBox "User closed dialog.", "RaiseTimer"
            waitTimer.Enabled = False
        End If
    End If
     
    Exit Sub
ErrorHandler:
    On Error Resume Next
    DebugMsgBox "Something bad happened: " & Err.Number & " - " & Err.description, "CTimer - RaiseTimer:"
    waitTimer.Enabled = False
    waitDialog.KillMe
End Sub

Attribute VB_Name = "MSharedTimer"
Option Explicit

' Win32 API Declarations
#If Win64 Then
Private Declare PtrSafe Function GlobalSize Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GetCurrentThreadId Lib "kernel32" () As LongPtr
Private Declare PtrSafe Function EnumThreadWindows Lib "user32" (ByVal dwThreadId As LongPtr, ByVal lpfn As LongPtr, ByVal lParam As LongPtr) As LongPtr
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
#Else
Private Declare Function GetCurrentThreadId Lib "kernel32" () As Long
Private Declare Function EnumThreadWindows Lib "user32" (ByVal dwThreadId As Long, ByVal lpfn As Long, ByVal lParam As Long) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If

Private Const GWL_HWNDPARENT As Long = (-8)

Public Sub TimerProc(ByVal hWnd As Long, ByVal uMsg As Long, ByVal oTimer As CTimer, ByVal dwTime As Long)
    ' Alert appropriate timer object instance.
    If oTimer.Enabled Then
        oTimer.RaiseTimer
    End If
End Sub

#If Win64 Then
Public Function hWndMain() As Long
   ' This function returns the toplevel application hWnd.
   ' If running within VBA, this would be the main Word,
   ' Excel, PowerPoint (etc) window. If running in ClassicVB
   ' this would be the hidden top-level window.
   Call EnumThreadWindows(GetCurrentThreadId(), AddressOf EnumThreadWndProc, VarPtr(hWndMain))
End Function

Private Function EnumThreadWndProc(ByVal hWnd As Long, ByVal lpResult As LongPtr) As Long
    Dim WindowText As String
    Dim lSize As LongLong
    
    ' Continue enumeration, by default.
    EnumThreadWndProc = True
    
    ' Make sure this window isn't parented.
    ' Quick way to eliminate most windows.
    If GetWindowLong(hWnd, GWL_HWNDPARENT) = 0 Then
       
        Dim txtName As String
        If getVersion > 14 Then
             txtName = "- Word"
        Else
             txtName = "- " & Application.name
        End If
       
       ' Grab title/caption of this window.
       WindowText = Space$(512)
       If GetWindowText(hWnd, WindowText, Len(WindowText)) Then
       
          ' Look for application name in window title?
          DebugMsgBox "WindowText = [" & WindowText & "]", "EnumThreadWndProc:"
          DebugMsgBox "txtName = [" & txtName & "]", "EnumThreadWndProc:"
          If InStr(WindowText, txtName) Then
             ' Copy hWnd to result variable pointer,
             ' and stop enumeration.
             lSize = 8
             Call CopyMemory(ByVal lpResult, hWnd, lSize)
             EnumThreadWndProc = False
          End If
       End If
    End If
End Function
#Else
Public Function hWndMain() As Long
   ' This function returns the toplevel application hWnd.
   ' If running within VBA, this would be the main Word,
   ' Excel, PowerPoint (etc) window. If running in ClassicVB
   ' this would be the hidden top-level window.
   Call EnumThreadWindows(GetCurrentThreadId(), AddressOf EnumThreadWndProc, VarPtr(hWndMain))
End Function

Private Function EnumThreadWndProc(ByVal hWnd As Long, ByVal lpResult As Long) As Long
    Dim WindowText As String
    
    ' Continue enumeration, by default.
    EnumThreadWndProc = True
    
    ' Make sure this window isn't parented.
    ' Quick way to eliminate most windows.
    If GetWindowLong(hWnd, GWL_HWNDPARENT) = 0 Then
       
        Dim txtName As String
        If getVersion > 14 Then
             txtName = "- Word"
        Else
             txtName = "- " & Application.name
        End If
       
       ' Grab title/caption of this window.
       WindowText = Space$(512)
       If GetWindowText(hWnd, WindowText, Len(WindowText)) Then
       
          ' Look for application name in window title?
          DebugMsgBox "WindowText = [" & WindowText & "]", "EnumThreadWndProc:"
          DebugMsgBox "txtName = [" & txtName & "]", "EnumThreadWndProc:"
          If InStr(WindowText, txtName) Then
             ' Copy hWnd to result variable pointer,
             ' and stop enumeration.
             Call CopyMemory(ByVal lpResult, hWnd, 4&)
             EnumThreadWndProc = False
          End If
       End If
    End If
End Function
#End If

Attribute VB_Name = "RijnDaelCode"
Option Explicit

Const KeyLength = 256 'or 128 or 192

Public Function rdEncryptString(ByVal PlainText As String, PassPhrase As String) As String

Dim oRijndael As clsRijnDael
Dim i As Long
Dim key(31) As Byte
Dim block(31) As Byte
Dim tEncodedText As String

Set oRijndael = New clsRijnDael
oRijndael.gentables
   
For i = 0 To Len(PassPhrase) - 1
  key(i) = Asc(Mid$(PassPhrase, i + 1, 1))
Next i
oRijndael.gkey KeyLength / 32, KeyLength / 32, key

Do While PlainText <> ""
  If Len(PlainText) < 32 Then PlainText = Left(PlainText & "                               ", 32)

  For i = 0 To 31
    block(i) = Asc(Mid(PlainText, i + 1, 1))
  Next

  oRijndael.ENCRYPT block
  For i = 0 To 31
    tEncodedText = tEncodedText & Right("0" & Hex(block(i)), 2)
  Next

  PlainText = Mid(PlainText, 33)
Loop

rdEncryptString = tEncodedText

End Function

Public Function rdDecryptString(ByVal EncodedText As String, PassPhrase As String) As String

Dim oRijndael As clsRijnDael
Dim i As Long
Dim key(31) As Byte
Dim block(31) As Byte
Dim tPlainText As String
Dim sResults As String

Set oRijndael = New clsRijnDael
oRijndael.gentables

For i = 0 To Len(PassPhrase) - 1
  key(i) = Asc(Mid$(PassPhrase, i + 1, 1))
Next i
oRijndael.gkey KeyLength / 32, KeyLength / 32, key

tPlainText = ""
Do While EncodedText <> ""
 For i = 0 To 31
   block(i) = CInt("&H" & Mid$(EncodedText, i * 2 + 1, 2))
 Next
 oRijndael.DECRYPT block
 
 For i = 0 To 31
   tPlainText = tPlainText & Chr$(block(i))
 Next

 EncodedText = Mid(EncodedText, 65)
Loop

rdDecryptString = Trim(tPlainText)

End Function





Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "clsAdvSmartMarking"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum SmartMarkingModes
    MODE_BULKLOAD = 1
    MODE_BURST = 2
End Enum

Public Enum ParseModes
    SINGLE_PARAGRAPH = 1
    DOUBLE_PARAGRAPH = 2
    BEGINS_WITH = 3
End Enum

Public Enum MatchModes
    MATCH_ANY = 1
    MATCH_ALL = 2
End Enum

Public Enum TypesToMark
    NONE = 0
    HEADER = 1
    QUESTION = 2
    ANSWER = 3
End Enum

Private thisDocument As Document
Private thisWindow As Window
Public MarkingMode As SmartMarkingModes
Public ParseMode As ParseModes
Public MatchMode As MatchModes
Public UseEndingPunctuation As Boolean
Public EndingPunctuation As String
Public UseParagraphLength As Boolean
Public ParagraphLengthEquality As String
Public ParagraphLength As Long
Private BeginsWith() As String
Public BeginsWithString As String
Public UseFontSize As Boolean
Public FontSizeEquality As String
Public fontSize As Double
Public UseBold As Boolean
Public UseItalic As Boolean
Public UseUline As Boolean
Public UseFontName As Boolean
Public fontName As String
Public UseStyle As Boolean
Public styleName As String
Public TypeToMark As TypesToMark
Public CombineQ As Boolean
Public CombineAH As Boolean
Public SMTypeToMark As TypesToMark

'Local variables
Private bookmarkCounter As Integer
Private LastMarkerType As String
Private bMarking As Boolean

Const HEADER_MARKER As String = "SantHeader"
Const QUESTION_MARKER As String = "SantQuestion"
Const ANSWER_MARKER As String = "SantAnswer"
Const FEATUREMATRIX_MARKER As String = "SantFeatureMatrix"
Const HEADERROW_MARKER As String = "SantHeaderRow"
Const QUESTIONROW_MARKER As String = "SantQuestionRow"
Const DESCRIPTION_MARKER As String = "SantDescription"
Const CONTENT_MARKER As String = "SantContent"

Const AUTOFIT_FIXED As Integer = 0
Const AUTOFIT_CONTENTS As Integer = 1
Const AUTOFIT_WINDOW As Integer = 2


Private Sub Class_Initialize()
    Select Case GetTemplateMode(ActiveDocument)
        Case "SantBulkload", "SantWordBulkLoad"
            MarkingMode = MODE_BULKLOAD
        Case Else
            MarkingMode = MODE_BURST
    End Select
    
    ParseMode = SINGLE_PARAGRAPH
    MatchMode = MATCH_ANY
    UseEndingPunctuation = False
    EndingPunctuation = "?"
    UseParagraphLength = False
    ParagraphLengthEquality = ">"
    ParagraphLength = 60
'    BeginsWith() As String
    UseFontSize = False
    FontSizeEquality = ">"
    fontSize = 16
    UseBold = True
    UseItalic = False
    UseUline = False
    UseFontName = False
    fontName = "Times New Roman"
    UseStyle = False
    styleName = "Heading1"
    TypeToMark = QUESTION
    CombineQ = False
    CombineAH = True

'    MarkingMode = MODE_BULKLOAD
'    ParseMode = SINGLE_PARAGRAPH
'    MatchMode = MATCH_ANY
'    UseEndingPunctuation = False
'    EndingPunctuation = "?"
'    UseParagraphLength = False
'    ParagraphLengthEquality = ">"
'    ParagraphLength = 60
''    BeginsWith() As String
'    UseFontSize = False
'    FontSizeEquality = ">"
'    fontSize = 16
'    UseBold = True
'    UseItalic = False
'    UseUline = False
'    UseFontName = False
'    fontName = "Times New Roman"
'    UseStyle = False
'    styleName = "Heading1"
'    TypeToMark = QUESTION
'    CombineQ = False
'    CombineAH = True
End Sub

Public Sub SetReferences(ByRef pDocument As Document, ByRef pWindow As Window)
    Set thisDocument = pDocument
    Set thisWindow = pWindow
    
'    ' Disable spelling and grammar checking!
'    thisDocument.showGrammaticalErrors = False
'    thisDocument.showSpellingErrors = False
End Sub

Public Sub SetParameters(ByRef pDocument As Document, _
    ByRef pWindow As Window, _
    ByVal pParseMode As ParseModes, _
    ByVal pMatchMode As MatchModes, _
    ByVal pUseEndingPunctuation As Boolean, _
    ByVal pEndingPunctuation As String, _
    ByVal pUseParagraphLength As Boolean, _
    ByVal pParagraphLengthEquality As String, _
    ByVal pParagraphLength As Long, _
    ByVal pBeginsWith As String, _
    ByVal pUseFontSize As Boolean, _
    ByVal pFontSizeEquality As String, _
    ByVal pFontSize As Double, _
    ByVal pUseBold As Boolean, _
    ByVal pUseItalic As Boolean, _
    ByVal pUseUline As Boolean, _
    ByVal pUseFontName As Boolean, _
    ByVal pFontName As String, _
    ByVal pUseStyle As Boolean, _
    ByVal pStyleName As String, _
    ByVal pTypeToMark As TypesToMark, _
    ByVal pCombineQ As Boolean, _
    ByVal pCombineAH As Boolean)

    Set thisDocument = pDocument
    Set thisWindow = pWindow
    'MarkingMode = pMarkingMode
    ParseMode = pParseMode
    MatchMode = pMatchMode
    UseEndingPunctuation = pUseEndingPunctuation
    EndingPunctuation = pEndingPunctuation
    UseParagraphLength = pUseParagraphLength
    ParagraphLengthEquality = pParagraphLengthEquality
    ParagraphLength = pParagraphLength
    BeginsWith = Split(pBeginsWith, "|") 'CHECK
    UseFontSize = pUseFontSize
    FontSizeEquality = pFontSizeEquality
    fontSize = pFontSize
    UseBold = pUseBold
    UseItalic = pUseItalic
    UseUline = pUseUline
    UseFontName = pUseFontName
    fontName = pFontName
    UseStyle = pUseStyle
    styleName = pStyleName
    TypeToMark = pTypeToMark
    CombineQ = pCombineQ
    CombineAH = pCombineAH


End Sub

Public Sub StartAdvancedSmartMarking(ByRef progress As frmProgressBar)
    progress.Repaint
    progress.UpdateProgressBarStatus 100, 1 ', ""
    modTools.StartProcess thisDocument, thisWindow
    progress.UpdateProgressBarStatus 100, 2 ', ""
    ParseDocument
    progress.UpdateProgressBarStatus 100, 99 ', ""
    modTools.EndProcess thisDocument, thisWindow
    
    If GetTemplateMode(thisDocument) = "" Then
        WriteProperty "SantTemplateMode", "SantWordBulkLoad", ActiveDocument
    End If
    progress.UpdateProgressBarStatus 100, 100 ', ""
    
End Sub

Private Sub ParseDocument()
    Dim bContinue As Boolean
    Dim bFoundText As Boolean
    Dim bSelStartsWithDesiredText As Boolean
    Dim lStatusStart As Long
    Dim lSelStart As Long
    Dim lSelEnd As Long
    Dim lTotal As Long
    Dim parCounter As Integer
    parCounter = 0

    bMarking = True
    
    'Remove any existing markings
    thisWindow.Selection.WholeStory
    RemoveAllSelectedMarkerBars
    frmProgressBar.UpdateProgressBarStatus 100, 3 ', ""
    
    'Convert numbers and bullets to textual equivalents, so numbering doesn't get altered.
    'Crush: Moved ConvertNumbersToText to RunOpenCode
    'If MarkingMode <> MODE_BULKLOAD Then
    '    ConvertNumbersToText 'JSB: TESTING REMOVAL OF THIS FOR BULK LOAD (still need it for burst)
    'End If
    frmProgressBar.UpdateProgressBarStatus 100, 4 ', ""
    
    'Replace all instances of Character 11 with Character 13 (evaluate if this is still necessary)
    RemoveCharacter11
    frmProgressBar.UpdateProgressBarStatus 100, 5 ', ""
    
    'Make sure document ends in 2 paragraphs.
    'MakeSureDocumentEndsInDoubleParagraphMarkers
    
    'Initialize variables.
    bContinue = True
    bFoundText = False
    bSelStartsWithDesiredText = False
    lSelStart = thisWindow.Selection.Start
    lSelEnd = thisWindow.Selection.Start
    bookmarkCounter = 0
    LastMarkerType = ""
    lTotal = thisDocument.Characters.count
    
    'Loop through paragraphs until we're at the end.
    While bContinue
        'Increment status bar
        lStatusStart = thisWindow.Selection.Start
        If lStatusStart > lTotal Then
            lTotal = lStatusStart
        End If
        frmProgressBar.UpdateProgressBarStatus 100, 5 + ((lStatusStart / lTotal) * 94) ', ""
        
        thisWindow.Selection.Expand wdParagraph

        'TODO NOTES:
        '~If in a table, handle differently (
        '~Burst and Bulkload difference - Mark Tables option shouldn't be available in Bulkload?
        'To change back to always marking feature matrix, remove the "if" part above, keep the else part.
        '   Then in each case below, if we're in a table, handle the table in the If part, and have the normal marking in the else part.
        '   In the if part, for single paragraph, mark the table.  Double - if found text select previous range, mark; if not found text, mark as fm.  similar approach to numbering.
        
        Select Case ParseMode
            Case ParseModes.SINGLE_PARAGRAPH
                
                If Len(thisWindow.Selection.Text) > 1 Then
                    If thisWindow.Selection.Information(wdWithInTable) Then
                        If MarkingMode = MODE_BULKLOAD Then
                            thisWindow.Selection.Expand wdTable
                        End If
                        MarkSelectedTable
                    Else
                        MarkSelectedText
                    End If
                End If
                
                thisWindow.Selection.Collapse wdCollapseEnd
                
            Case ParseModes.DOUBLE_PARAGRAPH
                
                If thisWindow.Selection.Information(wdWithInTable) Then
                    If bFoundText Then
                        thisWindow.Selection.SetRange Start:=lSelStart, End:=lSelEnd
                        MarkSelectedText
                    Else
                        thisWindow.Selection.Expand wdTable
                        MarkSelectedTable
                    End If
                    bFoundText = False
                Else
                    'If we haven't found any text yet, set the start location to the beginning of this paragraph
                    If Not bFoundText Then
                        lSelStart = thisWindow.Selection.Start
                    End If
                    
                    'If this paragraph contains text, indicate that we've found text.
                    'Else, it is an empty paragraph.  So, if we've found text, and we're now on an empty paragraph, mark it.
                    If Len(thisWindow.Selection.Text) = 1 Or thisWindow.Selection.Bookmarks.Exists("\EndOfDoc") Then
                        If bFoundText Then
                            lSelEnd = thisWindow.Selection.End
                            thisWindow.Selection.SetRange Start:=lSelStart, End:=lSelEnd
                            MarkSelectedText
                            bFoundText = False
                        End If
                    ElseIf Len(thisWindow.Selection.Text) > 1 Then
                        lSelEnd = thisWindow.Selection.End
                        bFoundText = True
                    End If
                    
                End If
                
                thisWindow.Selection.Collapse wdCollapseEnd
                
            Case ParseModes.BEGINS_WITH

                If thisWindow.Selection.Information(wdWithInTable) Then
                    thisWindow.Selection.Expand wdTable
                    If bFoundText Then
                        thisWindow.Selection.SetRange Start:=lSelStart, End:=lSelEnd
                        MarkSelectedText
                    Else
                        thisWindow.Selection.Expand wdTable
                        MarkSelectedTable
                    End If
                    bFoundText = False
                Else
                    bSelStartsWithDesiredText = SelectionStartsWithDesiredText
                    
                    'If this paragraph is at the beginning of the document, or the paragraph begins with desired text,
                    '   If we had already found desired text
                    '       Mark the previous section.  This paragraph will be evaluated again on the next pass.
                    '   Else
                    '       indicate that we've found desired text
                    '       start the marking range at the start, end the marking range at the end
                    'Else
                    '   Just extend the end range to the end of this paragraph
                    If thisWindow.Selection.Bookmarks.Exists("\StartOfDoc") Or bSelStartsWithDesiredText Then
                        If bFoundText Then
                            thisWindow.Selection.SetRange Start:=lSelStart, End:=lSelEnd
                            MarkSelectedText
                            bFoundText = False
                        Else
                            lSelStart = thisWindow.Selection.Start
                            lSelEnd = thisWindow.Selection.End
                            bFoundText = True
                        End If
    
                    Else
                        lSelEnd = thisWindow.Selection.End
                    End If
                End If
                
                thisWindow.Selection.Collapse wdCollapseEnd
                
                'If current paragraph is at the end of the document, and we've already found desired text, mark it.
                If thisWindow.Selection.Bookmarks.Exists("\EndOfDoc") And bFoundText Then
                    lSelEnd = thisWindow.Selection.End
                    thisWindow.Selection.SetRange Start:=lSelStart, End:=lSelEnd
                    MarkSelectedText
                    thisWindow.Selection.Collapse wdCollapseEnd
                End If
        End Select
        
        'UpdateProgressBarStatus 1, 0, Locale
            
        'Clear the undo list after every 20 or so iterations, so Word does not run out of memory.
        parCounter = parCounter + 1
        If (parCounter Mod 20) = 0 Then
            thisDocument.UndoClear
        End If
        
        'If we're at the end of the document, stop processing.
        If thisWindow.Selection.Bookmarks.Exists("\EndOfDoc") Then
            bContinue = False
        End If
    Wend
    
    thisDocument.UndoClear
    SwitchToPrintLayout thisWindow
    bMarking = False

End Sub

Private Sub MarkSelectedText()
    Dim UnusedCriteriaIncrement As Integer
    Dim RequiredCriteriaCount As Integer
    Dim CriteriaCount As Integer
    Dim myRange As Range

    Set myRange = thisWindow.Selection.Range

    If MatchMode = MATCH_ALL Then
        UnusedCriteriaIncrement = 1
        RequiredCriteriaCount = 8
    Else
        UnusedCriteriaIncrement = 0
        RequiredCriteriaCount = 1
    End If
    
    'CHECK 1: Ending Punctuation
    If Not UseEndingPunctuation Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        'If InStr(1, Right(thisWindow.Selection.Text, 2), sEndingPunctuation) Then
        If InStr(1, Right(Replace(Replace(thisWindow.Selection.Text, Chr(13), ""), Chr(32), ""), Len(EndingPunctuation)), EndingPunctuation) Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If
    
    'CHECK 2: Paragraph Length
    If Not UseParagraphLength Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        Dim Length As Long
        Length = Len(thisWindow.Selection.Text) - 1 'The -1 is to account for paragraph marker.
        
        If CheckEquality(Length, ParagraphLengthEquality, ParagraphLength) Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If
    
    'Move to the beginning of the selection.
    thisWindow.Selection.Collapse wdCollapseStart
    
    'CHECK 3: Font Size
    If Not UseFontSize Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        Dim SelectedFontSize As Double
        SelectedFontSize = thisWindow.Selection.Font.size
            
        If CheckEquality(SelectedFontSize, FontSizeEquality, fontSize) Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If

    'CHECK 4: Bold
    If Not UseBold Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        If thisWindow.Selection.Font.Bold <> 0 Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If

    'CHECK 5: Italic
    If Not UseItalic Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        If thisWindow.Selection.Font.Italic <> 0 Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If

    'CHECK 6: Underline (WHAT ABOUT NUMBERING)
    If Not UseUline Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
       If thisWindow.Selection.Font.Underline <> 0 Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If

    'CHECK 7: Font Name
    If Not UseFontName Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        If thisWindow.Selection.Font.name = fontName Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If

    'CHECK 8: Style
    If Not UseStyle Then
        CriteriaCount = CriteriaCount + UnusedCriteriaIncrement
    Else
        If thisWindow.Selection.Style.NameLocal = styleName Then
            CriteriaCount = CriteriaCount + 1
        End If
    End If

    'Reselect the range we're marking.
    myRange.Select
    
    'Mark the text with the appropriate marker.
    Select Case TypeToMark
        Case QUESTION
            If CriteriaCount >= RequiredCriteriaCount Then
                InsertQuestionMarker
            Else
                If MarkingMode = MODE_BULKLOAD Then
                    InsertAnswerMarker
                Else
                    InsertHeaderMarker
                End If
            End If
        Case HEADER
            If CriteriaCount >= RequiredCriteriaCount Then
                InsertHeaderMarker
            Else
                InsertQuestionMarker
            End If
        Case ANSWER
            If CriteriaCount >= RequiredCriteriaCount Then
                InsertAnswerMarker
            Else
                InsertQuestionMarker
            End If
    End Select
End Sub

Public Sub MarkSelectedTable()
    If MarkingMode = MODE_BULKLOAD Then
        'Skip table
    Else
        InsertFeatureMatrixMarker
    End If
End Sub

Private Function CheckEquality(ByVal leftValue As Variant, ByVal equalityOperator As String, ByVal rightValue As Variant)
    Dim bResult As Boolean
    bResult = False
    
    Select Case equalityOperator
        Case "="
            If leftValue = rightValue Then
                bResult = True
            End If
        Case "<"
            If leftValue < rightValue Then
                bResult = True
            End If
        Case ">"
            If leftValue > rightValue Then
                bResult = True
            End If
        Case "<="
            If leftValue <= rightValue Then
                bResult = True
            End If
        Case ">="
            If leftValue >= rightValue Then
                bResult = True
            End If
        Case "<>", "!="
            If leftValue <> rightValue Then
                bResult = True
            End If
    End Select
        
    CheckEquality = bResult
End Function

Private Function SelectionStartsWithDesiredText() As Boolean
    Dim sStringToCheck As String
    Dim i As Integer
    
    SelectionStartsWithDesiredText = False
    sStringToCheck = thisWindow.Selection.Text
    
    For i = LBound(BeginsWith) To UBound(BeginsWith)
        If Left(sStringToCheck, Len(BeginsWith(i))) = BeginsWith(i) Then
            SelectionStartsWithDesiredText = True
            Exit For
        End If
    Next i
    
End Function

Public Sub InsertAnswerMarker()
    Select Case MarkingMode
        Case SmartMarkingModes.MODE_BULKLOAD
            InsertMarker CONTENT_MARKER
        Case SmartMarkingModes.MODE_BURST
            InsertMarker ANSWER_MARKER
    End Select
End Sub

Public Sub InsertQuestionMarker()
    Select Case MarkingMode
        Case SmartMarkingModes.MODE_BULKLOAD
            InsertMarker DESCRIPTION_MARKER
        Case SmartMarkingModes.MODE_BURST
            InsertMarker QUESTION_MARKER
    End Select
End Sub

Public Sub InsertHeaderMarker()
    InsertMarker HEADER_MARKER
End Sub

Public Sub InsertFeatureMatrixMarker()
    InsertMarker FEATUREMATRIX_MARKER
End Sub

Public Sub InsertHeaderRowMarker()
    InsertMarkerInTable HEADERROW_MARKER, False
End Sub

Public Sub InsertQuestionRowMarker()
    InsertMarkerInTable QUESTIONROW_MARKER, False
End Sub

Private Sub InsertMarkerInTable(ByVal MarkerType As String, Optional ByVal ExpandToTable As Boolean = True)
    Dim CurrentRange As Range
    Dim bWithinTable As Boolean
    Dim bWithinMarker As Boolean
    bWithinTable = thisWindow.Selection.Information(wdWithInTable)
    If bWithinTable Then
        On Error Resume Next
        Dim ri As Integer
        ri = thisWindow.Selection.Rows(1).Index
        If Err.Number = 5991 Then
            MsgBox "Word_Error_VerticallyMergedCells" 'GetTemplateString("Word_Error_VerticallyMergedCells")
            Exit Sub
        ElseIf Err.Number <> 0 Then
            EndProcess thisDocument, thisWindow
            MsgBox Err.description
            Exit Sub
        End If
        On Error GoTo 0
        If thisWindow.Selection.Rows(1).Range.Bookmarks.count > 0 Then
            If InStr(1, thisWindow.Selection.Rows(1).Range.Bookmarks(1).name, "Sant") > 0 Then
                bWithinMarker = True
            End If
        End If
    End If
    If ExpandToTable Then
        If bWithinTable Then
            thisWindow.Selection.Expand (wdTable)
        Else
            thisWindow.Selection.Expand (wdParagraph)
        End If
    Else
        'thisWindow.Selection.Expand (wdParagraph) '2006/12/21 SEL Bug #1672 - This line did not handle paragraph markers in a single table row. Changed to wdRow.
        thisWindow.Selection.Expand (wdRow)
    End If
    Set CurrentRange = thisWindow.Selection.Range
    RemoveAllSelectedMarkerBars
    thisWindow.Selection.Collapse wdCollapseStart
    
    Dim prefWidthType As WdPreferredWidthType
    prefWidthType = thisWindow.Selection.Tables(1).PreferredWidthType
    
    Dim thisTbl As Table
    Set thisTbl = thisWindow.Selection.Tables(1)
    'determine if this table is autofit
    If thisTbl.AllowAutoFit Then
        'tag the table so we can attempt to reset this property later
        thisTbl.Descr = "*QvidianAF" & TablesAutofit(thisTbl) & "*" & thisTbl.Descr
    End If
    
    'set to fixed width while we split
    thisTbl.AllowAutoFit = False
    thisTbl.AutoFitBehavior (wdAutoFitFixed)
    
    If Not IsCombinedMarking(MarkerType) Then
        If bWithinMarker And Not thisWindow.Selection.Information(wdWithInTable) Then
            thisWindow.Selection.InsertParagraph
            InsertAutoTextVersionSafe MarkerType & "Bar", thisWindow, SantTemplate
            thisWindow.Selection.MoveUp wdParagraph, 1, wdMove
            AddSantBookmark MarkerType
        Else
            If bWithinTable Then
                thisWindow.Selection.SplitTable
                thisWindow.Selection.InsertParagraph
                thisWindow.Selection.MoveDown wdParagraph, 1, wdMove
            End If
            InsertAutoTextVersionSafe MarkerType & "Bar", thisWindow, SantTemplate
            If bWithinTable Then
                thisWindow.Selection.Delete
                thisWindow.Selection.MoveUp wdParagraph, 3, wdMove
                thisWindow.Selection.Delete
                thisWindow.Selection.MoveDown wdParagraph, 2
            End If
            AddSantBookmark MarkerType
        End If
    End If
    
    thisWindow.Selection.Tables(1).PreferredWidthType = prefWidthType

    CurrentRange.Select
End Sub

Private Sub InsertMarker(ByVal MarkerType As String, Optional ByVal bExpandToTable As Boolean = True)
    Dim CurrentRange As Range
    Dim bWithinTable As Boolean
    Dim bSplit As Boolean
    bWithinTable = thisWindow.Selection.Information(wdWithInTable)
    If bExpandToTable Then
        If bWithinTable Then
            thisWindow.Selection.Expand (wdTable)
        Else
            thisWindow.Selection.Expand (wdParagraph)
        End If
    Else
        thisWindow.Selection.Expand (wdParagraph)
    End If
    Set CurrentRange = thisWindow.Selection.Range
    RemoveAllSelectedMarkerBars
    thisWindow.Selection.Collapse wdCollapseStart
    bSplit = False
    If Not IsCombinedMarking(MarkerType) Then
        If bWithinTable And thisWindow.Selection.Information(wdWithInTable) Then
            thisWindow.Selection.SplitTable
            bSplit = True
        End If
        InsertAutoTextVersionSafe MarkerType & "Bar", thisWindow, SantTemplate
        If bSplit Then
            thisWindow.Selection.Delete
        End If
        AddSantBookmark MarkerType

    End If
    CurrentRange.Select
End Sub
    
Private Sub AddSantBookmark(ByVal MarkerType As String)
    thisWindow.Selection.MoveUp wdParagraph, 1
    thisWindow.Selection.Expand wdRow
    thisWindow.Selection.Collapse wdCollapseStart
    IncrementBookmarkCounter MarkerType
    thisWindow.Selection.Bookmarks.Add MarkerType & "_" & bookmarkCounter
End Sub
    
Public Sub IncrementBookmarkCounter(ByVal MarkerType As String)
    bookmarkCounter = bookmarkCounter + 1
    
    'Ensure bookmark doesn't already exist (in case bookmark counter has been reset)
    While thisDocument.Bookmarks.Exists(MarkerType & "_" & bookmarkCounter)
        bookmarkCounter = bookmarkCounter + 1
    Wend
End Sub
    
Public Sub RebaseBookmarkCounter(ByRef thisDoc As Document)
    Dim bm As Bookmark
    bookmarkCounter = 0
    For Each bm In thisDoc.Bookmarks
        If InStr(1, bm.name, "Sant") > 0 Then
            UpdateBookmarkCounter (bm.name)
        End If
    Next bm
End Sub

Public Sub UpdateBookmarkCounter(ByVal sBookmarkToCheck As String)
    Dim NumberPart As Integer
    NumberPart = GetNumberPart(sBookmarkToCheck)
    If NumberPart > bookmarkCounter Then
        bookmarkCounter = NumberPart
    End If
End Sub

Private Function GetNumberPart(ByVal sBookmarkToCheck As String) As Integer
    Dim sRightPart As String
    sRightPart = Right(sBookmarkToCheck, Len(sBookmarkToCheck) - InStrRev(sBookmarkToCheck, "_"))
    If IsNumeric(sRightPart) Then
        GetNumberPart = CInt(sRightPart)
    Else
        GetNumberPart = -1
    End If
End Function

Public Sub RemoveAllSelectedMarkerBars()
    Dim tempBookmark As Bookmark
    Dim CurrentRange As Range
    thisWindow.Selection.Expand wdParagraph
    Set CurrentRange = CheckRange

    For Each tempBookmark In thisWindow.Selection.Bookmarks
        If Left(tempBookmark.name, 4) = "Sant" Then
            thisWindow.Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
            tempBookmark.Delete
            
            'DS-bug #2403 add code to collapse selection back to within table
            thisWindow.Selection.Collapse wdCollapseStart
            'DS-bug #2403 end
            
            If thisWindow.Selection.Information(wdWithInTable) Then
                thisWindow.Selection.Rows.Delete
            End If
        End If
        CurrentRange.Select
    Next
End Sub
    
Public Sub RemoveAllSelectedMarkerBarsInTable()
    Dim tempBookmark As Bookmark
    Dim tempRow As row
    For Each tempBookmark In thisWindow.Selection.Tables(1).Range.Bookmarks
        If Left(tempBookmark.name, 4) = "Sant" Then
            tempBookmark.Range.Rows(1).Delete
            '2007/08/08 [JSB]: Explicitly delete the bookmarks, because if the bookmark has been expanded to
            'include the contents (row following marker), just deleting the row will not delete the bookmark.
            'Found and fixed this issue during testing of the fix for BUG 2748.
            'Without the code, if you have marked table rows, then choose the mark all table rows as questions,
            'any bookmarks that were in the original markers will be left in the document and cause problems later.
            On Error Resume Next
            tempBookmark.Delete
        End If
    Next
End Sub

Public Sub RemoveAllMarkerBars()
    Dim CurrentRange As Range
    Set CurrentRange = thisWindow.Selection.Range
    StartProcess thisDocument, thisWindow
    thisWindow.Selection.WholeStory
    RemoveAllSelectedMarkerBars
    CurrentRange.Select
    EndProcess thisDocument, thisWindow
End Sub

Public Function CheckRange() As Range
    Dim CurrentRange As Range
    Set CurrentRange = thisWindow.Selection.Range
    thisWindow.Selection.Collapse wdCollapseStart
    thisWindow.Selection.MoveUp wdParagraph, 1
    If thisWindow.Selection.Information(wdWithInTable) Then
        thisWindow.Selection.Expand wdRow
        If SelectionContainsSantBookmarks Then
            CurrentRange.Start = thisWindow.Selection.Start
        End If
    End If
    CurrentRange.Select
    Set CheckRange = CurrentRange
End Function

Public Function SelectionContainsSantBookmarks() As Boolean
    Dim tempBookmark As Bookmark
    SelectionContainsSantBookmarks = False
    For Each tempBookmark In thisWindow.Selection.Bookmarks
        '2007/08/08 [JSB]: To be contained in the selection, the bookmark must START in the selection (BUG 2748).
        '   I added the second constraint in the If statement to enforce this.
        '   Without that code, changing markers in a table will not work correctly in most situations.
        If Left(tempBookmark, 4) = "Sant" And thisWindow.Selection.Start <= tempBookmark.Start Then
            SelectionContainsSantBookmarks = True
            Exit For
        End If
    Next tempBookmark
End Function

Public Function IsCombinedMarking(ByVal MarkerType As String) As Boolean
    IsCombinedMarking = False
    If bMarking Then
        If Not thisWindow.Selection.Information(wdWithInTable) Then
            If MarkerType = LastMarkerType Then
                If (CombineQ And (MarkerType = QUESTION_MARKER Or MarkerType = DESCRIPTION_MARKER)) Or _
                   (CombineAH And (MarkerType = HEADER_MARKER Or MarkerType = ANSWER_MARKER Or MarkerType = CONTENT_MARKER)) Then
                    IsCombinedMarking = True
                End If
            Else
                LastMarkerType = MarkerType
            End If
        End If
    End If
End Function

Private Sub RemoveMarkerByBookmark(ByVal bookmarkName As String)
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:=bookmarkName
    If thisWindow.Selection.Information(wdWithInTable) Then
        thisWindow.Selection.Tables(1).Rows(1).Delete
    Else
        thisDocument.Bookmarks(bookmarkName).Delete
    End If
End Sub

Private Sub MakeSureDocumentEndsInDoubleParagraphMarkers()
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    thisWindow.Selection.MoveLeft wdCharacter, 1
    If thisWindow.Selection.Text <> Chr(13) Then
        thisWindow.Selection.Collapse wdCollapseEnd
        thisWindow.Selection.InsertParagraphAfter
    End If
    'Go to beginning of document.
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\StartOfDoc"
End Sub

Function TablesAutofit(tbl As Table) As Integer
    Dim TypePrefWidth As WdPreferredWidthType
    Dim i As Integer
    Dim FirstColWidth As Long, NewColWidth As Long
    Dim bAllColumnsEqual As Boolean
    
    TypePrefWidth = tbl.PreferredWidthType
    tbl.PreferredWidthType = wdPreferredWidthPercent
    
    With tbl
        If .PreferredWidth < 100 And .AllowAutoFit = True Then
            TablesAutofit = AUTOFIT_CONTENTS
        ElseIf .PreferredWidth = 100 And .AllowAutoFit = True Then
            TablesAutofit = AUTOFIT_WINDOW
        Else
            TablesAutofit = AUTOFIT_FIXED
            
            'we are not concerned with column vs table fixed, they are all the same to us
'            bAllColumnsEqual = True
'
'            If .Columns.count > 1 Then
'                FirstColWidth = .Columns(1).width
'                For i = 2 To .Columns.count
'                    NewColWidth = .Columns(i).width
'                    If NewColWidth <> FirstColWidth Then
'                        bAllColumnsEqual = False
'                        Exit For
'                    End If
'                Next i
'            End If
'
'            If bAllColumnsEqual = True Then
'                TablesAutofit = AUTOFIT_FIXED
'            Else
'                TablesAutofit = AUTOFIT_DISABLED
'            End If
        End If
    End With
    
    ' return table to the preferredwidthtype it started with
    tbl.PreferredWidthType = TypePrefWidth
    
End Function



'TODO: Change or branch to handle "Title" marker.
Public Sub MarkTableRowsAsQuestions()
    Dim thisRange As Range
    Dim tableRange As Range
    Dim LastRow As Integer
    Dim UndoCounter As Integer
    Dim RowRange As Range
    Dim ExtraParagraph As Range
    UndoCounter = 0
    
    StartProcess thisDocument, thisWindow
    
    If thisWindow.Selection.Information(wdWithInTable) Then
        'reference the rows collection to see if we're going to get errors because of merged cells.
        'Changed to reference a specific row.  Just referencing the collection wasn't causing the problem.
        On Error Resume Next
        Dim ri As Integer
        ri = thisWindow.Selection.Tables(1).Rows(1).Index
        If Err.Number = 5991 Then
            ' show error and get out
            EndProcess thisDocument, thisWindow
            'TODO: Fix resource strings.
            MsgBox "Word_Error_VerticallyMergedCells" 'GetTemplateString("Word_Error_VerticallyMergedCells")
            Exit Sub
        ElseIf Err.Number <> 0 Then
            EndProcess thisDocument, thisWindow
            MsgBox Err.description
            Exit Sub
        End If
        On Error GoTo 0
        
        RemoveAllSelectedMarkerBarsInTable
        
        Set thisRange = thisWindow.Selection.Range
        Set tableRange = thisWindow.Selection.Tables(1).Range
        
        Dim prefWidthType As WdPreferredWidthType
        prefWidthType = thisWindow.Selection.Tables(1).PreferredWidthType
        
        Dim thisTbl As Table
        Set thisTbl = thisWindow.Selection.Tables(1)
        'determine if this table is autofit
        If thisTbl.AllowAutoFit Then
            'tag the table so we can attempt to reset this property later
            thisTbl.Descr = "*QvidianAF" & TablesAutofit(thisTbl) & "*" & thisTbl.Descr
        End If
        
        'set to fixed width while we split
        thisTbl.AllowAutoFit = False
        thisTbl.AutoFitBehavior (wdAutoFitFixed)
        
        LastRow = thisWindow.Selection.Tables(1).Rows.count
        
        While LastRow > 0
            
            thisWindow.Selection.Tables(1).Rows(LastRow).Select
            Set RowRange = thisWindow.Selection.Range
            thisWindow.Selection.SplitTable
            thisWindow.Selection.InsertParagraph
            Set ExtraParagraph = thisWindow.Selection.Range
            thisWindow.Selection.MoveDown wdParagraph, 1
            InsertAutoTextVersionSafe QUESTIONROW_MARKER & "Bar", thisWindow, SantTemplate
            IncrementBookmarkCounter QUESTIONROW_MARKER
            RowRange.Bookmarks.Add QUESTIONROW_MARKER & "_" & bookmarkCounter
            LastRow = LastRow - 1
            thisWindow.Selection.Delete
            ExtraParagraph.Delete
            tableRange.Select
            
            'Clear the undo list after every 20 or so iterations, so Word does not run out of memory.
            UndoCounter = UndoCounter + 1
            If UndoCounter > 20 Then
                thisDocument.UndoClear
                UndoCounter = 0
            End If
        Wend
        thisRange.Select
        
        thisWindow.Selection.Tables(1).PreferredWidthType = prefWidthType
    End If

    thisDocument.UndoClear
    EndProcess thisDocument, thisWindow
End Sub

Public Sub AddMissingAnswerMarkers(Optional ByVal bIncludeExtraSpace As Boolean = True)
    Dim thisRange As Range
    Dim TempTable As Table
    Dim tempBookmark As Bookmark
    Dim bFoundQuestion As Boolean
    Dim parCounter As Long
    Dim parCount As Long
    
    parCount = ActiveDocument.Bookmarks.count
                    
    Set thisRange = thisWindow.Selection.Range
    
    bFoundQuestion = False
    
    StartProcess thisDocument, thisWindow
    
    For Each TempTable In thisDocument.Tables
        
        For Each tempBookmark In TempTable.Range.Bookmarks
            If TempTable.Range.Start = tempBookmark.Range.Start Then
                If Left(tempBookmark.name, 13) = "SantQuestion_" Then
                    If bFoundQuestion = True Then
                        TempTable.Range.Select
                        AddAnswerMarkerBeforeCurrentMarker bIncludeExtraSpace
                    Else
                        bFoundQuestion = True
                    End If
                    
                ElseIf Left(tempBookmark.name, 11) = "SantAnswer_" Then
                    If bFoundQuestion Then
                        bFoundQuestion = False 'Complete Q&A pair.
                    Else
                        TempTable.Range.Select
                        AddQuestionMarkerBeforeAnswer bIncludeExtraSpace
                    End If
                    
                ElseIf Left(tempBookmark.name, 4) = "Sant" Then
                    If bFoundQuestion Then
                        bFoundQuestion = False
                        TempTable.Range.Select
                        AddAnswerMarkerBeforeCurrentMarker bIncludeExtraSpace
                    End If
                    
                End If
            End If
            parCounter = parCounter + 1
            If (parCounter Mod 20) = 0 Then
                frmProgressBar.UpdateProgressBarStatus 100, 100 * (parCounter / parCount)
                DoEvents
                thisDocument.UndoClear
           End If
        Next tempBookmark
    Next TempTable
    
    If bFoundQuestion Then
        InsertAnswerMarkerAtEndOfDoc bIncludeExtraSpace
    End If
    
    thisDocument.UndoClear
    thisRange.Select
    
    EndProcess thisDocument, thisWindow
End Sub

Public Sub AddQuestionMarkerBeforeAnswer(Optional ByVal bIncludeExtraSpace As Boolean = True)
    Dim thisRange As Range
    Set thisRange = thisWindow.Selection.Range
    
    thisWindow.Selection.SplitTable
    
    If bIncludeExtraSpace Then
        thisWindow.Selection.MoveDown wdParagraph, 1
        thisWindow.Selection.SplitTable
    End If
    
    InsertQuestionMarker
    
    thisRange.Select
End Sub

Public Sub AddAnswerMarkerBeforeCurrentMarker(Optional ByVal bIncludeExtraSpace As Boolean = True)
    Dim thisRange As Range
    Dim bMoved As Boolean
    Dim p As Paragraph
    bMoved = False
    Set thisRange = thisWindow.Selection.Range
    
    thisWindow.Selection.MoveUp wdParagraph, 2
    thisWindow.Selection.Expand wdParagraph
    
    If bIncludeExtraSpace Then
        If Len(thisWindow.Selection.Text) > 1 Then
            thisRange.Tables(1).Range.Select
            thisWindow.Selection.SplitTable
        End If
    End If
    
    thisRange.Tables(1).Range.Select
    thisWindow.Selection.SplitTable
    Set p = thisWindow.Selection.Paragraphs(1)
        
    If bIncludeExtraSpace Then
        thisWindow.Selection.MoveDown wdParagraph, 1
        thisWindow.Selection.SplitTable
        thisWindow.Selection.MoveUp wdParagraph, 1
    Else
        'Make sure answer is immediately after question, and any spaces that were after the question go after the answer.
        thisWindow.Selection.MoveUp wdParagraph, 1
        While Len(thisWindow.Selection.Paragraphs(1).Range.Text) = 1
            bMoved = True
            thisWindow.Selection.MoveUp wdParagraph, 1
        Wend
        thisWindow.Selection.MoveDown wdParagraph, 1
        If bMoved Then
            p.Range.Cut
            thisWindow.Selection.Collapse wdCollapseStart
            thisWindow.Selection.Paste
        End If
    End If
    
    InsertAnswerMarker
    
    thisRange.Select
End Sub

Private Sub InsertAnswerMarkerAtEndOfDoc(Optional ByVal bIncludeExtraSpace As Boolean = True)
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    If bIncludeExtraSpace Then
        thisWindow.Selection.MoveLeft wdCharacter, 1
        If Asc(thisWindow.Selection.Text) <> 13 Then
            thisWindow.Selection.MoveRight wdCharacter, 1
            thisWindow.Selection.InsertParagraph
            thisWindow.Selection.Collapse wdCollapseEnd
            thisWindow.Selection.InsertParagraph
        Else
            thisWindow.Selection.MoveRight wdCharacter, 1
            thisWindow.Selection.InsertParagraph
        End If
        thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    Else
        'Make sure answer is immediately after question, and any spaces that were after the question go after the answer.
        If Len(thisWindow.Selection.Paragraphs(1).Range.Text) = 1 Then
            'Selection.MoveUp wdParagraph, 1
            While Len(thisWindow.Selection.Paragraphs(1).Range.Text) = 1
                thisWindow.Selection.MoveUp wdParagraph, 1
            Wend
            thisWindow.Selection.MoveDown wdParagraph, 1
        Else
            thisWindow.Selection.InsertParagraph
            thisWindow.Selection.Collapse wdCollapseEnd
        End If

    End If
    InsertAnswerMarker
End Sub

Public Sub CombineConsecutiveHeaderMarkings()
    CombineConsecutiveMarkings HEADER_MARKER & "_"
End Sub

Public Sub CombineConsecutiveAnswerMarkings()
    CombineConsecutiveMarkings ANSWER_MARKER & "_"
    CombineConsecutiveMarkings CONTENT_MARKER & "_"
End Sub

Public Sub CombineConsecutiveQuestionMarkings()
    CombineConsecutiveMarkings QUESTION_MARKER & "_"
    CombineConsecutiveMarkings DESCRIPTION_MARKER & "_"
End Sub

Public Sub CombineConsecutiveMarkings(ByVal Marker As String)
    Dim t As Table
    Dim bm As Bookmark
    Dim MarkerLen As Integer
    Dim PrevMatch As Boolean
    
    MarkerLen = Len(Marker)
    PrevMatch = False
    
    StartProcess thisDocument, thisWindow
    For Each t In thisDocument.Tables
        For Each bm In t.Range.Bookmarks
            If Left(bm.name, 4) = "Sant" Then
                If Left(bm.name, MarkerLen) = Marker Then
                    If PrevMatch Then
                        t.Select
                        RemoveAllSelectedMarkerBars
                    End If
                    PrevMatch = True
                Else
                    PrevMatch = False
                End If
            End If
        Next bm
    Next t
    EndProcess thisDocument, thisWindow
End Sub

Public Sub CheckForLoneTitle()
    Dim t As Table
    Dim bm As Bookmark
    Dim PrevTitle As Boolean
    Dim count As Integer
    
    count = 0
    PrevTitle = False
    
    StartProcess thisDocument, thisWindow
    For Each t In thisDocument.Tables
        For Each bm In t.Range.Bookmarks
            If Left(bm.name, 4) = "Sant" Then
                If Left(bm.name, 15) = DESCRIPTION_MARKER Then
                    If PrevTitle Then
                        count = count + 1
                    End If
                    PrevTitle = True
                Else
                    PrevTitle = False
                End If
            End If
        Next bm
    Next t
    
    If count > 0 Then
        MsgBox "You marked a title without associated content. Some records will not be added."
    End If
    
    EndProcess thisDocument, thisWindow
End Sub

Public Sub RemoveCharacter11()
    'Remove all Chr(11) and replace with Chr(13)
    thisWindow.Selection.WholeStory
    thisWindow.Selection.Find.ClearFormatting
    thisWindow.Selection.Find.Replacement.ClearFormatting
    thisWindow.Selection.Find.Execute Chr(11), False, False, False, False, False, True, wdFindContinue, , Chr(13), wdReplaceAll
    'Go to beginning of document.
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\StartOfDoc"
End Sub

Public Sub ConvertNumbersToText()
    thisWindow.Selection.WholeStory
    thisWindow.Selection.Range.ListFormat.ConvertNumbersToText
    thisWindow.Selection.Collapse wdCollapseStart
End Sub

Public Sub StartSmartMarking(ByRef progress As frmProgressBar)
    Dim thisRange As Range
    Dim origpar As Paragraph
    Dim par As Paragraph
    Dim parCount As Long
    Dim parCounter As Long
    
    Set thisRange = thisWindow.Selection.Range
    parCount = thisDocument.Paragraphs.count
    parCounter = 0

    thisWindow.Selection.Collapse wdCollapseStart
    If thisWindow.Selection.Information(wdWithInTable) Then
        MsgBox "You must select a paragraph to perform this action."
    Else
        Set origpar = thisWindow.Selection.Paragraphs(1)
    
        StartProcess thisDocument, thisWindow
        For Each par In thisDocument.Paragraphs
            DoEvents
    '        If SantData.bCancelEvaluate Then
    '            EndProcess
    '            Unload frmEvaluate
    '            Exit Sub
    '        End If
            If par.Range.Tables.count = 0 Then
                If TypeName(par.Range.Style) <> "Nothing" Then
                    If par.Range.Style = origpar.Range.Style And _
                        par.Range.Font.name = origpar.Range.Font.name And _
                        par.Range.Font.size = origpar.Range.Font.size And _
                        par.Range.Font.Bold = origpar.Range.Font.Bold And _
                        par.Range.Font.Italic = origpar.Range.Font.Italic And _
                        par.Range.Font.Underline = origpar.Range.Font.Underline And _
                        par.Range.Font.Color = origpar.Range.Font.Color Then
        
                        par.Range.Select
                        
                        If Len(thisWindow.Selection.Text) > 1 Then
                            Select Case SMTypeToMark
                                Case TypesToMark.HEADER
                                    InsertHeaderMarker
                                Case TypesToMark.QUESTION
                                    InsertQuestionMarker
                                Case TypesToMark.ANSWER
                                    InsertAnswerMarker
                                Case Else
                                    RemoveAllSelectedMarkerBars
                            End Select
                        End If
                    End If
                End If
            End If
            
            parCounter = parCounter + 1
            progress.UpdateProgressBarStatus 100, 100 * (parCounter / parCount)
            
            'Clear the undo list after every 20 or so iterations, so Word does not run out of memory.
            If (parCounter Mod 20) = 0 Then
                thisDocument.UndoClear
            End If

        Next par
    End If
    
    thisDocument.UndoClear
    
    EndProcess thisDocument, thisWindow
    Unload progress
    thisRange.Select
End Sub
Attribute VB_Name = "clsBuild"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'03/04/08 [mag]: per bug#3246 added to be able to access the clipboard
'Open, Empty and Close the clipboard
#If Win64 Then
Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
#Else
Private Declare Function OpenClipboard Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function EmptyClipboard Lib "user32" () As Long
Private Declare Function CloseClipboard Lib "user32" () As Long
#End If

Public Sub SetReferences(ByRef pDocument As Document, ByRef pWindow As Window)
    Set buildDocument = pDocument
    Set buildWindow = pWindow
End Sub

Public Sub RunBuild()
    On Error GoTo ErrorHandler
    
    DebugMsgBox "RunBuild"

    GetBuildParameters
    DebugMsgBox "ProjectID = " & thisProjectID
    
    MakeSureBuildPathsExist
    
    If setupWSConnection(buildDocument) <> ConnectionStatus.worked Then
        Exit Sub
    End If
       
    Set dh = New clsDownloadHelper
    
    InitializeDocument
    
    DownloadBuildStyleTemplate
    ImportStyles buildDocument
    ImportTables buildDocument
    
    InitializeTempDoc
    
    BuildProject
    
    CloseDH

    Exit Sub
ErrorHandler:
    Application.visible = True
    MsgBox Err.Number & " " & Err.description
    CloseDH
End Sub

Private Sub GetBuildParameters()
    On Error GoTo ErrorHandler
    DebugMsgBox "thisProjectID:" & GetPropertyText("ProjectID", buildDocument)
    thisProjectID = CLng(GetPropertyText("ProjectID", buildDocument))
    DebugMsgBox "lOtherPageTray:" & GetPropertyText("OtherPagesTray", buildDocument)
    lOtherPageTray = CLng(GetPropertyText("OtherPagesTray", buildDocument))
    DebugMsgBox "lFirstPageTray:" & GetPropertyText("FirstPageTray", buildDocument)
    lFirstPageTray = CLng(GetPropertyText("FirstPageTray", buildDocument))
    DebugMsgBox "lPaperOrientation:" & GetPropertyText("PageOrientation", buildDocument)
    lPaperOrientation = CLng(GetPropertyText("PageOrientation", buildDocument))
    DebugMsgBox "lPaperSize:" & GetPropertyText("PageSize", buildDocument)
    lPaperSize = CLng(GetPropertyText("PageSize", buildDocument))
    DebugMsgBox "bUseBuildSettings:" & GetPropertyText("UseBuildSettings", buildDocument)
    bUseBuildSettings = CBool(GetPropertyText("UseBuildSettings", buildDocument))
    DebugMsgBox "bAutoSave:" & GetPropertyText("AutoSave", buildDocument)
    bAutoSave = CBool(GetPropertyText("AutoSave", buildDocument))
    DebugMsgBox "bReplaceMergeCodes:" & GetPropertyText("ReplaceMergeCodes", buildDocument)
    bReplaceMergeCodes = CBool(GetPropertyText("ReplaceMergeCodes", buildDocument))
    DebugMsgBox "bPrintAllSelections:" & GetPropertyText("PrintAllSelections", buildDocument)
    bPrintAllSelections = CBool(GetPropertyText("PrintAllSelections", buildDocument))
    DebugMsgBox "bConvertDocToDocx:" & GetPropertyText("ConvertDocToDocx", buildDocument)
    bConvertDocToDocx = CBool(GetPropertyText("ConvertDocToDocx", buildDocument))
      
    bPrintToPDF = CBool(GetPropertyText("BuildToPDF", buildDocument))
      
    lStyleTemplateID = CLng(GetPropertyText("TemplateID", buildDocument))
    sStyleTemplateFileName = CStr(GetPropertyText("TemplateFileName", buildDocument))
           
    Exit Sub
ErrorHandler:
    thisProjectID = -1
    MsgBox Err.Number & Err.description
    MsgBox "The ProjectID does not exist as a custom document property."
End Sub

Public Sub InitializeDocument()
    'init build variables
    bMoveToNextRow = False
    bDeleteLastRow = False
    IsReport = False
    iERCnt = 0
    iRFPFileCount = 0
    
    '---------------------------------------------------------------------
    ' Set the Cursor to the hourglass
    '---------------------------------------------------------------------
    System.Cursor = wdCursorWait
    
    'Stop pagination (improves performance)
    Application.Options.Pagination = False
    
    '---------------------------------------------------------------------
    ' Hide Office Assistant (improves performance)
    ' Setting Assistant properties will cause a runtime error if Word
    ' does not have the focus.  So set error handling to resume next to
    ' prevent these and then turn error handling off.
    '---------------------------------------------------------------------
    On Error Resume Next
    
    Set oDocSettings = New struct_DocSettings
        
    SaveDocumentSettings buildDocument, oDocSettings, True
    
    On Error GoTo 0
    
    'Set the View to Normal
    ' 2005-07-26 KV: no need to store layout anymore. we will always set layout to print at the end
    ' vViewType = ActiveWindow.ActivePane.View.Type
    buildDocument.ActiveWindow.ActivePane.View.Type = wdNormalView
    
    '------------------------------------------------------------------
    '  Bring the new document in front of all other applications.
    '------------------------------------------------------------------
    If bHideWordDuringBuild Then
        glngWindowWidth = buildDocument.ActiveWindow.width
        glngWindowHeight = buildDocument.ActiveWindow.Height
        glngWindowLeft = buildDocument.ActiveWindow.Left
        glngWindowTop = buildDocument.ActiveWindow.Top
        
        Call ResizeAndMoveWindow(400, 20, 0, 0)
    End If
    
    '--------------------------------------------------------------------------
    'Initialize the Presentation Flag
    '--------------------------------------------------------------------------
    bPresentation = False
End Sub

Public Sub InitializeTempDoc()
    lTempDocCnt = 0
    sPathToTempDoc = "temp\tempDoc"
    sBasePath = GetClientPath
    KillPath sBasePath & "temp\tempDoc*"
End Sub


Public Sub BuildProject() 'userID?
    
    Application.Options.SaveNormalPrompt = False
    
    If Not BuildPrintingFile Then
        GoTo LeaveAFterError
    End If
    
    '---------------------------------------------------------------------
    ' If files exist, then build the document
    '---------------------------------------------------------------------
    If GetFileSystemObject.FileExists(sPrintingFilePath) Then
        CreateDocument
    Else
        MsgBox "Error: pm.txt (" & sPrintingFilePath & ") file does not exist" 'GetTemplateString("Build_SantSuite_pmtxt_Error")
        GoTo LeaveAFterError
    End If

    Exit Sub
    
LeaveAFterError:
    buildDocument.AttachedTemplate.Saved = True
    Application.NormalTemplate.Saved = True
    Application.Options.SaveNormalPrompt = False
        
    CloseDH
    Set dh = Nothing
        
    bActiveBuild = False
        
    'No more code will run after the following line.
    buildDocument.AttachedTemplate = buildDocument.Application.NormalTemplate.FullName
End Sub

Private Sub RemovePreviousPrintingFile()
    KillPath sPrintingFilePath
End Sub

Private Function BuildPrintingFile() As Boolean
    RemovePreviousPrintingFile
    
    'call download method here
    BuildPrintingFile = dh.DownloadBuildFile(sPrintingFilePath, thisProjectID)
    
End Function

Sub CreateDocument()
    Dim sDocumentName As String
   
    DebugMsgBox ("CreateDocument:")
   
    '---------------------------------------------------------------------
    ' Parse the text file
    '---------------------------------------------------------------------
    bLockDocument = False
    DebugMsgBox ("CreateDocument: ParseInfoFile")
    ParseInfoFile sPrintingFilePath, sDocumentName

    ' Flag that we don't need to do anything in
    GetApplication.ignoreDocChange = True
    
    If Not (IsReport) And bReplaceMergeCodes Then
        DebugMsgBox ("CreateDocument: CleanAllStories")
        CleanAllStories ActiveDocument
    End If
    
    DebugMsgBox ("CreateDocument: FormatAllStories")
    FormatAllStories ActiveDocument, PRE_ER
    FormatAllStories ActiveDocument, POST_ER
    FormatAllStories ActiveDocument, POST_CLEANUP
   
    '---------------------------------------------------------------------
    ' Apply Build Settings if selected
    '---------------------------------------------------------------------
    DebugMsgBox ("CreateDocument: ApplyBuildSettings")
    ApplyBuildSettings
        
    '---------------------------------------------------------------------
    ' Update fields to account for changes in size as e/r codes are replaced
    '---------------------------------------------------------------------
    DebugMsgBox ("CreateDocument: Update the field codes")
    buildDocument.Fields.Update
        
    '---------------------------------------------------------------------
    ' We have to explicitly check for Table of Figures becuase the previous update does
    ' create it, but it does NOT update the title correclty. ARH 2/9/2011 (2007 specific)
    '---------------------------------------------------------------------
    If buildDocument.TablesOfFigures.count > 0 Then
        Dim tof As TableOfFigures
        For Each tof In buildDocument.TablesOfFigures
            tof.Update
        Next
    End If

    '
    'restore document settings
    '
    RestoreDocumentSettings buildDocument, oDocSettings
    
   '------------------------------------------------------------------
    '  Go to the top of the document
    '------------------------------------------------------------------
    buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToSection, which:=wdGoToFirst
      
    buildDocument.AttachedTemplate.Saved = True
    Application.NormalTemplate.Saved = True
    Application.Options.SaveNormalPrompt = False
    
    If bPresentation Then
        DebugMsgBox ("CreateDocument: It's a presentation")
        CallingPage.SetAsPresentation
        
        'this function will close down the word doc...
        DebugMsgBox ("CreateDocument: It's a presentation")
        CreatePresentation
    ElseIf bPrintToPDF Then
        DebugMsgBox ("CreateDocument: Save to PDF")
        FinishWordDoc
    
        CreatePDF
    Else
        DebugMsgBox ("CreateDocument: No PDF")
        FinishWordDoc
        
        If bAutoSave Then
            DebugMsgBox ("CreateDocument: Call SaveToRepository")
            SaveToRepository
            buildDocument.Saved = True
        End If
    End If
    
    bActiveBuild = False
End Sub

Sub FinishWordDoc()
    DebugMsgBox ("FinishWordDoc:")
    Dim comM As comment
    
    ClearClipboard
    
    DebugMsgBox ("FinishWordDoc: Clean out the comments")
    buildDocument.AcceptAllRevisions
    If buildDocument.Comments.count > 0 Then
        For Each comM In buildDocument.Comments
            comM.Delete
        Next
    End If
    DebugMsgBox ("FinishWordDoc: Update the title")
    buildDocument.BuiltInDocumentProperties(wdPropertyTitle) = sProjectName
    
    DebugMsgBox ("FinishWordDoc: Save the file")
    buildDocument.SaveAs fileName:=sDocumentFilePath, addtorecentfiles:=False, fileformat:=WdSaveFormat.wdFormatDocumentDefault
    
    FinalizeDocument
    
    SwitchToPostBuild
    
    CloseDH
            
    If bLockDocument Then
        buildDocument.Protect password:=bLockPassword, NoReset:=False, Type:= _
                wdAllowOnlyComments
    End If
End Sub

Sub CloseDH()
    If TypeName(dh) <> "Nothing" Then
        dh.CloseDownloadHelper
    End If
End Sub

Sub SavePDFToRepository()
    DebugMsgBox ("SavePDFToRepository:")
    WriteProperty "TemplateMode", "18", buildDocument   '18=SavePDFToRepository
    
    Set modInit.activeSantDocument = buildDocument
    modToolbarActions.SaveToSantSuite
End Sub

Sub SaveToRepository()
    Set modInit.activeSantDocument = buildDocument
    'modToolbarActions.SaveToSantSuite
    DebugMsgBox "SaveToRepository: call SaveBuiltDoc"
    modWS.SaveBuiltDoc buildDocument
End Sub

Sub ParseInfoFile(ThisInfoFile As String, ThisDocumentName As String)
    Dim sCurrentFileLine As String
    Dim lRowCount As Long

    DebugMsgBox ("ParseInfoFile:")

    '---------------------------------------------------------------------
    '   Open the File
    '---------------------------------------------------------------------
    SantTextReadFile ThisInfoFile
  
    DebugMsgBox ("ParseInfoFile: file read")
  
    '---------------------------------------------------------------------
    ' Retrieve the Project Name From the first line in the txt file
    '---------------------------------------------------------------------
    sCurrentFileLine = SantTextNextLine()
    sProjectName = sCurrentFileLine
    sDocumentFilePath = CreateDocumentName(sProjectName, ".docx")
    buildDocument.SaveAs fileName:=sDocumentFilePath, addtorecentfiles:=False, fileformat:=WdSaveFormat.wdFormatDocumentDefault

    DebugMsgBox ("ParseInfoFile: project name: [" & sProjectName & "] file is [" & sDocumentFilePath & "]")

    bFirstAction = True

    '---------------------------------------------------------------------
    '   Iterate through each line of the file
    '---------------------------------------------------------------------
    While Not SantTextEOF() 'EOF(lFileNumber)
   
       '-----------------------------------------------------------------
       '   Allow the operating system to process any events it needs to
       '-----------------------------------------------------------------
       DoEvents
              
       lRowCount = lRowCount + 1
       '-----------------------------------------------------------------
       '   Read the current line in from the file
       '-----------------------------------------------------------------
       sCurrentFileLine = SantTextNextLine()
        DebugMsgBox ("ParseInfoFile: [" & sCurrentFileLine & "]")
       
       '-----------------------------------------------------------------
       '   Parse the string read from the file and insert information
       '   into ThisDataArray()
       '-----------------------------------------------------------------
       RunAction sCurrentFileLine, lRowCount ', lFileNumber
       
    Wend
   
    '---------------------------------------------------------------------
    '   Close the file
    '---------------------------------------------------------------------
    SantTextClose
   
    DebugMsgBox ("ParseInfoFile: File Closed.")
End Sub

Sub RunAction(ThisFileLine As String, ThisRowCount As Long) ', ThisFileNumber As Long)
    Dim LocalDataArray() As String
    Dim ActionCode As SantActionCodes
    Dim bForceDownload As Boolean
    
    LocalDataArray = Split(ThisFileLine, DELIM)
    
    ActionCode = CInt(LocalDataArray(0))
    DebugMsgBox ("RunAction: " & ActionCode)
    
    Select Case ActionCode
        Case SantActionCodes.ACTION_BOOKMARK_GOTO
            Action_GotoBookmark LocalDataArray(1)
        Case SantActionCodes.ACTION_BOOKMARK_INSERT
            Action_InsertBookmark LocalDataArray(1)
        Case SantActionCodes.ACTION_BUILD_CHART
            Action_InsertPicture DownloadChart(LocalDataArray(1), LocalDataArray(2)), LocalDataArray(3), LocalDataArray(4)
        Case SantActionCodes.ACTION_CLEAN_RFP_MARKERS
            Action_CleanRFPMarkers buildDocument, LocalDataArray(1)
        Case SantActionCodes.ACTION_DISPLAY_BUILD_ERROR
            Action_DisplayBuildError
        Case SantActionCodes.ACTION_DOWNLOAD_FILE_TO_BUILD_FOLDER
            Action_DownloadFileToBuildFolder LocalDataArray(1), LocalDataArray(2)
        Case SantActionCodes.ACTION_DOWNLOAD_RFP_FILE_TO_BUILD_FOLDER
            Action_DownloadRFPFileToBuildFolder LocalDataArray(1), LocalDataArray(2), LocalDataArray(3)
        Case SantActionCodes.ACTION_EDIT_REPLACE
            Action_CreateERArray LocalDataArray(1), LocalDataArray(2)
        Case SantActionCodes.ACTION_EDIT_REPLACE_GRAPHIC
            Action_EditReplace_Graphic LocalDataArray(1), LocalDataArray(2), CInt(LocalDataArray(3)), CBool(LocalDataArray(4))
        Case SantActionCodes.ACTION_EDIT_REPLACE_GRAPHIC_BY_CONTENTID
            Action_EditReplace_Graphic LocalDataArray(1), dlContent(LocalDataArray(2), CInt(LocalDataArray(3))), CInt(LocalDataArray(4))
        Case SantActionCodes.ACTION_EDIT_REPLACE_GRAPHIC_BY_MISCFILEID
            Action_EditReplace_Graphic LocalDataArray(1), dlMiscFile(LocalDataArray(2)), CInt(LocalDataArray(3))
        Case SantActionCodes.ACTION_INCLUDE_PRESENTATION
            Action_IncludePresentation
        'Case SantActionCodes.ACTION_INSERT_AUTOTEXT
        Case SantActionCodes.ACTION_INSERT_BREAK
            Action_InsertBreak CInt(LocalDataArray(1))
        Case SantActionCodes.ACTION_INSERT_COMPLIANCE_MATRIX_FILE
            Action_InsertComplianceMatrixFile dlMiscFile(LocalDataArray(1)), LocalDataArray(2)
        Case SantActionCodes.ACTION_INSERT_COMPLIANCE_MATRIX_ROW
            Action_InsertComplianceMatrixRow LocalDataArray(1), LocalDataArray(2), LocalDataArray(3), LocalDataArray(4)
        Case SantActionCodes.ACTION_COMPLIANCE_MATRIX_PROCESS_HEADERS
            Action_ComplianceMatrix_ProcessHeaders
        Case SantActionCodes.ACTION_INSERT_COMPLIANCE_MATRIX_HEADER
            Action_ComplianceMatrix_AddLevel LocalDataArray(1), LocalDataArray(2)
        Case SantActionCodes.ACTION_COMPLIANCE_MATRIX_CLEAN
            Action_ComplianceMatrixClean
        Case SantActionCodes.ACTION_INSERT_FILE
            Action_InsertFile LocalDataArray(1), CBool(LocalDataArray(2)), CBool(LocalDataArray(3))
        Case SantActionCodes.ACTION_INSERT_FILE_BY_CONTENTID
            bForceDownload = False
            If LocalDataArray(5) <> "" Then
                If CBool(LocalDataArray(5)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertFile dlContent(LocalDataArray(1)), CBool(LocalDataArray(2)), CBool(LocalDataArray(3)), True, LocalDataArray(4)
        Case SantActionCodes.ACTION_INSERT_FILE_BY_CONTENTID_REVISION
            bForceDownload = False
            If LocalDataArray(6) <> "" Then
                If CBool(LocalDataArray(6)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertFile dlContent(LocalDataArray(1), CInt(LocalDataArray(2))), CBool(LocalDataArray(3)), CBool(LocalDataArray(4)), True, LocalDataArray(5)
        Case SantActionCodes.ACTION_INSERT_FILE_BY_MISCFILEID
            bForceDownload = False
            If LocalDataArray(5) <> "" Then
                If CBool(LocalDataArray(5)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertFile dlMiscFile(LocalDataArray(1)), CBool(LocalDataArray(2)), CBool(LocalDataArray(3)), True, LocalDataArray(4)
        Case SantActionCodes.ACTION_INSERT_OBJECT
            Action_InsertObject LocalDataArray(1), LocalDataArray(2)
        Case SantActionCodes.ACTION_INSERT_OBJECT_BY_CONTENTID
            bForceDownload = False
            If LocalDataArray(5) <> "" Then
                If CBool(LocalDataArray(5)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertObject dlContent(LocalDataArray(1), CInt(LocalDataArray(2))), LocalDataArray(3), LocalDataArray(4)
        Case SantActionCodes.ACTION_INSERT_PICTURE
            Action_InsertPicture LocalDataArray(1), LocalDataArray(2), True 'TODOJSB: Allow all options to be passed in?
        Case SantActionCodes.ACTION_INSERT_PICTURE_BY_CONTENTID
            bForceDownload = False
            If LocalDataArray(4) <> "" Then
                If CBool(LocalDataArray(4)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertPicture dlContent(LocalDataArray(1), CInt(LocalDataArray(2))), LocalDataArray(3), True 'TODOJSB: Allow all options to be passed in?
        Case SantActionCodes.ACTION_INSERT_OBJECT_BY_MISCFILEID
            bForceDownload = False
            If LocalDataArray(4) <> "" Then
                If CBool(LocalDataArray(4)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertObject dlMiscFile(LocalDataArray(1)), LocalDataArray(2), LocalDataArray(3)
        Case SantActionCodes.ACTION_INSERT_PICTURE_BY_MISCFILEID
            bForceDownload = False
            If LocalDataArray(3) <> "" Then
                If CBool(LocalDataArray(3)) Then
                    bForceDownload = True
                End If
            End If
            Action_InsertPicture dlMiscFile(LocalDataArray(1)), LocalDataArray(2), True 'TODOJSB: Allow all options to be passed in?
        Case SantActionCodes.ACTION_INSERT_TEXT
            Dim textPiece As String
            Dim textWhole As String
            Dim lItem As Long
            For lItem = 1 To val(LocalDataArray(3))
'                Line Input #ThisFileNumber, textPiece
                textPiece = SantTextNextLine()
                textWhole = textWhole + LTrim(textPiece) + DELIM
            Next lItem
            Action_InsertText textWhole, LocalDataArray(1), LocalDataArray(2)
        Case SantActionCodes.ACTION_MOVE_THROUGH_TABLE
            Action_MoveThroughTable LocalDataArray(1)
        Case SantActionCodes.ACTION_PAGE_SETUP
            Action_PageSetup LocalDataArray(1)
        Case SantActionCodes.ACTION_RUN_EDIT_REPLACE_ARRAY
            Action_EditReplace
        Case SantActionCodes.ACTION_RUN_MACRO
            Action_RunMacro LocalDataArray(1)
        Case SantActionCodes.ACTION_LOCK_DOCUMENT
            bLockDocument = True
            bLockPassword = UnScrambleX(LocalDataArray(1))
        Case SantActionCodes.ACTION_DYNAMIC_CONTENT_INSERT_FILE '= 71
             'insert file: path, num fields
            '   -create object, insert file, init fields num
            '   -create starting BM for globals
            Action_DynamicContent_Insert dlMiscFile(LocalDataArray(1)), CInt(LocalDataArray(2))
        Case SantActionCodes.ACTION_DYNAMIC_CONTENT_ADD_FIELD '= 72
            'insert field: code
            Action_DynamicContent_AddField LocalDataArray(1)
        Case SantActionCodes.ACTION_DYNAMIC_CONTENT_ADD_VALUE '= 73
            'insert value text: row, code, value
            Action_DynamicContent_AddValue CInt(LocalDataArray(1)), LocalDataArray(2), LocalDataArray(3)
        Case SantActionCodes.ACTION_DYNAMIC_CONTENT_ADD_VALUE_BY_CONTENTID '= 74
            'insert value contentID: row, code, contentID
            '   -download and insert (ER by content code copy?)
            Action_DynamicContent_AddValueFromContent CInt(LocalDataArray(1)), LocalDataArray(2), dlContent(LocalDataArray(3))
        Case SantActionCodes.ACTION_DYNAMIC_CONTENT_ADD_GLOBAL_VALUE '= 75
            'insert global ER: code, value
            Action_DynamicContent_AddGlobalValue LocalDataArray(1), LocalDataArray(2)
        Case SantActionCodes.ACTION_DYNAMIC_CONTENT_PROCESS_DATA '= 76
            Action_DynamicContent_ProcessData
    End Select
    
    'Reset flag on any action code that does not call Action_InsertFile
    If ActionCode <> SantActionCodes.ACTION_INSERT_FILE And ActionCode <> SantActionCodes.ACTION_INSERT_FILE_BY_CONTENTID _
        And ActionCode <> SantActionCodes.ACTION_INSERT_FILE_BY_MISCFILEID Then
        bLastFileSettingsPreserved = False
    End If
    
    bFirstAction = False

    SaveDocument
End Sub

Public Function SaveDocument() As Boolean

   Static lSaveCount As Long
   Const SAVE_WHEN As Long = 20
   
   If lSaveCount >= SAVE_WHEN Then
        buildDocument.AttachedTemplate.Saved = True
        
        buildDocument.AcceptAllRevisions
        buildDocument.SaveAs fileName:=sDocumentFilePath, fileformat:=wdFormatDocumentDefault, addtorecentfiles:=False

      lSaveCount = 0
      SaveDocument = True
   Else
      lSaveCount = lSaveCount + 1
      SaveDocument = False
   End If
   
End Function

Sub ApplyBuildSettings()
    '08/06/2004 JAA Added On Error to gracefully handle bad users setting
    On Error Resume Next
    If bUseBuildSettings Then
        'paper size
        If lPaperSize >= 0 Then
            buildDocument.PageSetup.PaperSize = lPaperSize
        End If
        
        'paper orientation
        If lPaperOrientation >= 0 Then
            buildDocument.PageSetup.Orientation = lPaperOrientation
        End If
        
        'first page tray
        If lFirstPageTray >= 0 Then
            buildDocument.PageSetup.FirstPageTray = lFirstPageTray
        End If
        
        'other pages tray
        If lOtherPageTray >= 0 Then
            buildDocument.PageSetup.OtherPagesTray = lOtherPageTray
        End If
    End If
End Sub

Sub CreatePresentation()
    
    Dim AppPP As Object
    Dim sPotPath As String, sPPTName As String
    Dim DocumentDataArray(8) As String
    Dim sTemplate As String
    Dim count As Integer
    
    Set AppPP = CreateObject("Powerpoint.Application")
    
    RemoveDoubleParagraphs
    
    buildDocument.PresentIt
    
    '---------------------------------------------------------------------
    '  Try to Activate the Presentation PresentIt has created so the template can be applied
    '---------------------------------------------------------------------
    DoEvents
    
    '08/10/04 [jaa]: per bug#2584, give powerpoint some time to wake up
    AppPP.Activate
    count = 0
    While AppPP.Presentations.count = 0
        If count > 450 Then
            buildDocument.Saved = True
            buildDocument.Close SaveChanges:=wdDoNotSaveChanges
            Exit Sub
        End If
        DoEvents
        Sleep 100
        count = count + 1
    Wend
    
    sPotPath = Left(sPrintingTemplate, InStrRev(sPrintingTemplate, "\"))
    If GetFileSystemObject.FolderExists(sPotPath) And Len(sPrintingTemplate) > 0 Then
        AppPP.ActivePresentation.ApplyTemplate fileName:=sPrintingTemplate
    End If
    
    sPPTName = CreateDocumentName(sProjectName, ".ppt")
    
    Dim oPres As Object
    Set oPres = AppPP.ActivePresentation
    
    oPres.SaveAs sPPTName
    oPres.CustomDocumentProperties.Add "Server", False, 4, sServer
    oPres.CustomDocumentProperties.Add "ProjectID", False, 1, thisProjectID
    oPres.CustomDocumentProperties.Add "PostBuild_frmUpload_Message", False, 4, GetTemplateString("PostBuild_frmUpload_Message")
    oPres.CustomDocumentProperties.Add "PostBuild_frmUpload_Cancel", False, 4, GetTemplateString("PostBuild_frmUpload_Cancel")

    buildDocument.Saved = True
    buildDocument.Close SaveChanges:=wdDoNotSaveChanges
    
    CloseDH
    
    If GetFileSystemObject.FileExists(sDocumentFilePath) Then
        '03/10/04 [mag]: per bug#3264
        KillPath sDocumentFilePath
    End If

End Sub

Sub CreatePDF()
    '
    On Error GoTo ErrorHandler
    
    sPDFFilePath = sBuildFolder & sProjectName & ".pdf"
    
    buildDocument.ExportAsFixedFormat sPDFFilePath, wdExportFormatPDF, True

    If bAutoSave Then
        SavePDFToRepository
        buildDocument.Saved = True
    End If

    'buildDocument.Close SaveChanges:=wdDoNotSaveChanges
    
    CloseDH
    
    If GetFileSystemObject.FileExists(sDocumentFilePath) Then
        '03/10/04 [mag]: per bug#3264
        KillPath sDocumentFilePath
    End If
    
    
    'If Application.Documents.count = 0 Then
    '    Application.Quit wdDoNotSaveChanges
    'End If

    Exit Sub
    
ErrorHandler:
        'MsgBox GetTemplateString("Build_CreatePDF_Error") & vbCrLf & Err.Number & " " & Err.description
    MsgBox "There was an error generating your PDF file. Please check your system requirements." & vbCrLf & Err.Number & " " & Err.description
    
    'attempt to close word doc and exit word
    On Error Resume Next
    buildDocument.Saved = True
    buildDocument.Close SaveChanges:=wdDoNotSaveChanges
    
    If Application.Documents.count = 0 Then
        Application.Quit wdDoNotSaveChanges
    End If
    
End Sub

Sub RemoveDoubleParagraphs()
    buildDocument.ActiveWindow.Selection.Find.ClearFormatting
    buildDocument.ActiveWindow.Selection.Find.Replacement.ClearFormatting
    With buildDocument.ActiveWindow.Selection.Find
        .Text = "^p^p"
        .Forward = True
        .Wrap = wdFindStop
        .format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    
    buildDocument.ActiveWindow.Selection.Find.Execute
    buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
    While buildDocument.ActiveWindow.Selection.Find.Found
        buildDocument.ActiveWindow.Selection.Collapse wdCollapseEnd
        buildDocument.ActiveWindow.Selection.TypeBackspace
        buildDocument.ActiveWindow.Selection.Find.Execute
        buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
    Wend
End Sub

Public Sub SwitchToPostBuild()
    DebugMsgBox ("SwitchToPostBuild: Update the TemplateMode")
    modDocProperties.WriteProperty "SantTemplateMode", "SantPostBuild", ActiveDocument
    DebugMsgBox ("SwitchToPostBuild: Switch the toolbar")
    modToolbar.SwitchToolbars ActiveDocument
End Sub

Public Sub SwitchToPostBuildDone()
    DebugMsgBox ("SwitchToPostBuildDone: Update the TemplateMode")
    modDocProperties.WriteProperty "SantTemplateMode", "", ActiveDocument
    DebugMsgBox ("SwitchToPostBuildDone: Switch the toolbar")
    modToolbar.SwitchToolbars ActiveDocument
End Sub

Public Sub FinalizeDocument()
    If Not bPresentation Then
        DebugMsgBox ("FinalizeDocument: Reset the view")
        ReturnDocumentToNormal
               
        '---------------------------------------------------------------------
        ' Show the finished screen since the document is done building
        '---------------------------------------------------------------------
        Application.Activate
            
        CloseDH
        
        If bPrintToPDF Then
            frmFinished.PDFMessage
        Else
            frmFinished.Show
        End If
       
        On Error Resume Next
        Assistant.visible = bDefaultAssistantVisible
        Assistant.Sounds = bDefaultAssistantSounds
        On Error GoTo 0
        NormalTemplate.Saved = True
    Else
        If Application.Documents.count = 0 Then
          Application.Quit
        End If
    End If
End Sub

Public Sub WriteDocumentProperties(ByRef thisDocument As Document)
    thisDocument.CustomDocumentProperties.Add name:="Server", LinkToContent:=False, Value:=sServer, Type:=msoPropertyTypeString
    thisDocument.CustomDocumentProperties.Add name:="ProjectID", LinkToContent:=False, Value:=thisProjectID, Type:=msoPropertyTypeNumber
    thisDocument.CustomDocumentProperties.Add name:="CRMNoteText", LinkToContent:=False, Value:=sCRMNoteText, Type:=msoPropertyTypeString
End Sub


'*********************************************
' GENERAL TOOLS
'*********************************************
'03/04/08 [mag]: per bug#3246 created to clear the clipboard at the end of Build
Public Sub ClearClipboard()
    Dim hClip As Long
    Dim h As Long
    
    hClip = OpenClipboard(0&)
    If hClip > 0 Then
        h = EmptyClipboard
        hClip = CloseClipboard
    End If
End Sub

Public Sub DownloadBuildStyleTemplate()
    'If a printing template has been specified, make sure we have a copy, and apply the styles.
    If lStyleTemplateID > 0 Then
        sPrintingTemplate = sBuildTemplatesPath & sStyleTemplateFileName
        sPrintingTemplateExt = LCase(Mid(sPrintingTemplate, InStrRev(sPrintingTemplate, ".") + 1))
        
        ' Download it.
        dh.DownloadStyleTemplate sPrintingTemplate, lStyleTemplateID
    End If
End Sub

Sub ImportTables(ByRef thisDoc As Document)
    
    If sPrintingTemplateExt <> "pot" _
        And sPrintingTemplateExt <> "potx" _
        And sPrintingTemplateExt <> "potm" _
        And sPrintingTemplateExt <> "none" Then
    
        'if we hit any snags (can't find a style, etc.) skip and continue
        'we will try to get as many correct styles as possible here.
        On Error Resume Next
        
        Dim stX As Style
        
        'organizer only works if document is saved
        thisDoc.SaveAs thisDoc.FullName
        
        For Each stX In thisDoc.Styles
            If stX.Type = wdStyleTypeTable Then
                If stX.InUse Then
                    'this will override table styles that copy incorrectly with the CopyStylesFromTemplate
                    'command in ImportStyles. The styles are brought in, but incorrectly formatted. So this finds
                    'them by name and brings in the correct version.
                    Application.OrganizerCopy sPrintingTemplate, thisDoc.FullName, stX.NameLocal, wdOrganizerObjectStyles
                End If
            End If
        Next
    
    End If
    
End Sub

'used?
Public Function DownloadChart(ByVal thisProjectID As String, ByVal thisCompID As String) As String
'    Dim lReturnVal As Long
'
'    lReturnVal = URLDownloadToFile(0, _
'        sServer & "DocumentBuilder/DownloadChart.aspx?ProjectID=" & thisProjectID & "&ComponentID=" & thisCompID, _
'        sTempPath & "TempChart.jpg", 0, 0)
'
'    If lReturnVal = 0 Then
'        DownloadChart = sTempPath & "TempChart.jpg"
'    Else
'        Err.Raise -1, "Long", GetTemplateString("Build_SantSuite_DownloadFile_Error") & " """ & sTempPath & "TempChart.jpg" & """." & vbCrLf & _
'                "Error code: " & lReturnVal
'    End If
End Function

Private Sub Class_Initialize()
    'bActiveBuild = True
End Sub
Attribute VB_Name = "clsCMHeaderData"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public CMHeaderData As Scripting.Dictionary

Private headerAbbr() As String

Private mNumLevels As Integer
Private mNewHeaderIndex As Integer

Private Sub Class_Initialize()
    Reset
End Sub

Public Sub Reset()
    ReDim headerAbbr(0)
    mNumLevels = 0
    mNewHeaderIndex = 0
    Set CMHeaderData = Nothing
End Sub

Public Property Get NumLevels() As Integer
    NumLevels = mNumLevels
End Property

Public Property Let NumLevels(ByVal iCount As Integer)
    mNumLevels = iCount
    ReDim headerAbbr(iCount)
    Set CMHeaderData = New Scripting.Dictionary
End Property

Public Sub AddLevel(thisAbbr As String, thisValue As String)
    If UBound(headerAbbr) = mNewHeaderIndex Then
        ReDim Preserve headerAbbr(mNewHeaderIndex)
    End If
    headerAbbr(mNewHeaderIndex) = thisAbbr
    mNewHeaderIndex = mNewHeaderIndex + 1
    
    CMHeaderData(thisAbbr) = thisValue
End Sub

Public Property Get CMLevel(i As Integer) As String
    CMLevel = headerAbbr(i)
End Property




Attribute VB_Name = "clsDownloadHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Sub CloseDownloadHelper()
    On Error Resume Next
    ss.wsm_ConnectionTerminate
End Sub

Public Function DownloadBuildFile(ByVal sLocalPath As String, ByVal thisProjectID As Long) As Boolean
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetBuildFile(thisProjectID, bReplaceMergeCodes, bPrintAllSelections)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    
    DoEvents
    DownloadBuildFile = True
End Function

Public Function DownloadContentFile(ByVal sLocalPath As String, ByVal thisContentID As Long, Optional ByVal thisRevision As Long = -1, Optional bForceDownload As Boolean = False)
    If GetFileSystemObject.FileExists(sLocalPath) Then
        If bForceDownload Then
            Kill sLocalPath
        Else
            DownloadContentFile = True
            Exit Function
        End If
    End If
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetContentFile(thisContentID, thisRevision, bConvertDocToDocx)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    DoEvents
    DownloadContentFile = True
End Function

Public Function DownloadMiscFile(ByVal sLocalPath As String, ByVal thisMiscFileID As Long)
    If GetFileSystemObject.FileExists(sLocalPath) Then
        Kill sLocalPath
    End If
        
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetMiscFile(thisMiscFileID)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    DownloadMiscFile = True
    DoEvents
End Function

Public Function DownloadStyleTemplate(ByVal sLocalPath As String, ByVal thisTemplateID As Long)
    If GetFileSystemObject.FileExists(sLocalPath) Then
        Kill sLocalPath
    End If
        
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetStyleTemplateFile(thisTemplateID)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    DoEvents
    DownloadStyleTemplate = True
End Function

Public Function GetFormattedValue(ByVal val As String, ByVal format As String, ByVal culture As String, Optional ByVal additionalInfo As String = "")
    GetFormattedValue = ss.wsm_GetFormattedValue(val, format, culture, additionalInfo)
End Function

Public Function EvaluateFormula(ByVal val As String)
    EvaluateFormula = ss.wsm_EvaluateFormula(val)
End Function

Public Function GetContentFileByGUID(ByVal sGUID As String) As String
    GetContentFileByGUID = ss.wsm_GetContentFileByGUID(sGUID)
End Function

Attribute VB_Name = "clsDynamicContentData"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public ERFieldData As Scripting.Dictionary
Public GlobalData As Scripting.Dictionary



Private ContentFileFields As Scripting.Dictionary
Private codes() As String
Private mNumFields As Integer
Private mNewCodeIndex As Integer

Private FormulaSums As Scripting.Dictionary
Private FormulaFormats As Scripting.Dictionary

Private Sub Class_Initialize()
    Reset
End Sub

Public Sub Reset()
    ReDim codes(0)
    mNumFields = 0
    mNewCodeIndex = 0
    Set ERFieldData = Nothing
    Set GlobalData = Nothing
    Set newDataRow = Nothing
    Set ContentFileFields = Nothing
    Set FormulaSums = Nothing
    Set FormulaFormats = Nothing
End Sub

Public Property Get NumFields() As Integer
    NumFields = mNumFields
End Property

Public Property Let NumFields(ByVal iCount As Integer)
    mNumFields = iCount
    ReDim codes(iCount)
    
    Set GlobalData = New Scripting.Dictionary 'init new global array when fields are initialized
    Set FormulaSums = New Scripting.Dictionary 'init new global array when fields are initialized
    Set FormulaFormats = New Scripting.Dictionary 'init new global array when fields are initialized
End Property

Public Property Get NumRows() As Integer
    If ERFieldData Is Nothing Then
        NumRows = 0
    Else
        NumRows = ERFieldData.count
    End If
End Property

Public Property Get Field(i As Integer) As String
    Field = codes(i)
End Property

Public Function IsContentField(thisRow, thisCode) As Boolean
    If ContentFileFields.Exists(thisRow & thisCode) Then
        IsContentField = CBool(ContentFileFields(thisRow & thisCode))
    Else
        IsContentField = False
    End If
End Function

Public Sub AddGlobalValue(thisCode As String, thisValue As String)
    If GlobalData.Exists(thisCode) Then
        GlobalData(thisCode) = thisValue
    Else
        GlobalData.Add thisCode, thisValue
    End If
End Sub

Public Sub AddField(thisCode As String)
    If UBound(codes) = mNewCodeIndex Then
        ReDim Preserve codes(mNewCodeIndex)
    End If
    codes(mNewCodeIndex) = thisCode
    mNewCodeIndex = mNewCodeIndex + 1
End Sub
Public Sub AddValue(thisRow As Integer, thisCode As String, thisValue As String)
    thisValue = CheckForFormula(thisCode, thisValue)

    AddValueToDict thisRow, thisCode, thisValue
    
    If Not ContentFileFields.Exists(thisRow & thisCode) Then
        ContentFileFields.Add thisRow & thisCode, False
    End If
End Sub



Public Sub AddValueFromFile(thisRow As Integer, thisCode As String, thisFile As String)
    AddValueToDict thisRow, thisCode, thisFile
    If Not ContentFileFields.Exists(thisRow & thisCode) Then
        ContentFileFields.Add thisRow & thisCode, True
    End If
End Sub


Private Sub AddValueToDict(thisRow As Integer, thisCode As String, thisValue As String)
    Dim newDataRow As Scripting.Dictionary 'CreateObject("Scripting.Dictionary")
    
    If ERFieldData Is Nothing Then
        Set ERFieldData = New Scripting.Dictionary
        Set ContentFileFields = New Scripting.Dictionary
    End If

    If ERFieldData.Exists(thisRow) Then
        Set newDataRow = ERFieldData(thisRow)
    Else
        Set newDataRow = New Scripting.Dictionary
    End If
    
    newDataRow(thisCode) = thisValue
    Set ERFieldData(thisRow) = newDataRow
End Sub

Private Function CheckForFormula(thisCode As String, thisValue As String) As String
    On Error GoTo eh
    Dim formulaValues() As String
    Dim tmp As String
    Dim calcVal As String

    If InStr(thisValue, "{eval}") Then
        If InStr(thisValue, "~~~") Then
            formulaValues = Split(thisValue, "~~~")
            
            tmp = Replace(formulaValues(1), "{eval}", "")
            
            'calcVal = GetScriptObject.eval(tmp)
            calcVal = EvaluateFormula(tmp)
            
            tmp = Replace(formulaValues(0), "{format}", "")
            
            AddToFormulaSum thisCode, CDbl(calcVal), tmp
            
            CheckForFormula = GetFormattedValue(tmp, calcVal)
        Else
            thisValue = Replace(thisValue, "{eval}", "")
            CheckForFormula = GetScriptObject.eval(thisValue)
        End If
    Else
        CheckForFormula = thisValue
    End If
    
    Exit Function

eh:
    MsgBox "CheckForFormula Error: " & Err.description
    CheckForFormula = thisValue
End Function

Private Sub AddToFormulaSum(thisCode As String, thisVal As Double, thisFormat As String)
    Dim curVal As Double
    Dim newVal As Double
    
    'get sum, add together, save new sum
    If FormulaSums Is Nothing Then
        Set FormulaSums = New Scripting.Dictionary
        Set FormulaFormats = New Scripting.Dictionary
    End If

    If FormulaSums.Exists(thisCode) Then
        curVal = CDbl(FormulaSums(thisCode))
    Else
        curVal = 0
    End If
    
    newVal = curVal + thisVal
    
    FormulaSums(thisCode) = newVal
    
    'save format
    FormulaFormats(thisCode) = thisFormat
    
End Sub

Private Function EvaluateFormula(thisFormula As String) As String
    EvaluateFormula = dh.EvaluateFormula(thisFormula)
End Function

Private Function GetFormattedValue(formatString As String, calcVal As String) As String
    Dim formatValues() As String
    
    formatValues = Split(formatString, "!")

    If UBound(formatValues) = 2 Then
        GetFormattedValue = dh.GetFormattedValue(calcVal, formatValues(0), formatValues(1), formatValues(2))
    Else
        GetFormattedValue = dh.GetFormattedValue(calcVal, formatValues(0), formatValues(1))
    End If

End Function
    
Public Sub AddFormulasToGlobals()
    Dim k() As Variant
    Dim sumValue As Double
    Dim fmtString As String
    Dim newVal As String
    Dim newAvg As String
    Dim sCode As String
    
    If Not FormulaSums Is Nothing Then
        k = FormulaSums.Keys
        
        For i = 0 To FormulaSums.count - 1
            sumValue = FormulaSums(k(i))
            fmtString = FormulaFormats(k(i))
            
            newVal = GetFormattedValue(fmtString, CStr(sumValue))
            
            'remove current set of ending brackets on regular code name, so we can move to the end
            sCode = Replace(k(i), ">", "")
            
            'sum: <<OriginalCode_Sum>>
            AddGlobalValue sCode & "_Sum>>", newVal
                                                  
            'avg: <<OriginalCode_Avg>>
            newAvg = GetFormattedValue(fmtString, sumValue / NumRows)
            AddGlobalValue sCode + "_Avg>>", newAvg
        Next
    End If
    
    
End Sub



Attribute VB_Name = "clsJob"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mJobXMLDoc As MSXML2.DOMDocument30
Public JobQvidianServer As String

Private contentFileNode As IXMLDOMNode
Public contentList As Collection
Public cmdList As Scripting.Dictionary
Public MultiValueDelimiter As String
Public ClearBuiltInOfficePropertiesOnSave As Boolean
Public ClearCustomOfficePropertiesOnSave As Boolean
Public isSMEJob As Boolean
Public SMEJobID As String
Public isCompositeEdit As Boolean
Public firstID As Long
Public compositeJobID As String
Public compositeContent As struct_Content
Public xmlVersion As String

Public mJobFileDir As String
Public isPS As Boolean
Private mJobTitle As String
Private mJobID As String
Private mJobSubFolderName As String
Private mJobFileName As String

Public Function DownloadJobFile(parFolderName As String, ByVal parJobTitle As String, _
                                ByVal parJobID As String, stagesCount As Long) As ConnectionStatus
    DownloadJobFile = ConnectionStatus.Error
    
    ' Set some globals up and make sure the folders are created.
    mJobTitle = parJobTitle
    mJobID = parJobID
    mJobSubFolderName = parFolderName
    EnsureJobFolderExists
    mJobFileName = mJobFileDir & parJobID & ".xml"
    
    If Not GetFileSystemObject.FileExists(mJobFileName) Then
        frmProgressBar.UpdateProgressBarStatus stagesCount, 1
        frmProgressBar.StartGeneric ("Connecting to the server...stage 2 of " & stagesCount)
        DoEvents
        DownloadJobFile = setupWSConnection(ActiveDocument)
        If DownloadJobFile <> ConnectionStatus.worked Then
            DebugMsgBox "setupWSConnection Cancelled/Failed", "DownloadJobFile:"
            Exit Function
        End If
        
        ' New file, so create it.
        Dim nFile As Long
        Dim mfsData() As Byte
        frmProgressBar.UpdateProgressBarStatus stagesCount, 2
        frmProgressBar.StartGeneric ("Retrieving the Job file...stage 3 of " & stagesCount)
        DoEvents
        mfsData = ss.wsm_GetJobFile(parJobID)
        nFile = FreeFile
        Open mJobFileName For Binary Access Read Write Lock Write As #nFile
        Put #nFile, , mfsData
        Close #nFile
        DoEvents
    End If
    
    ' Now open the file, either way...
    openJobFile parFolderName, parJobTitle, parJobID
    DownloadJobFile = ConnectionStatus.worked
End Function

Public Function openJobFile(parFolderName As String, ByVal parJobTitle As String, ByVal parJobID As String, Optional force As Boolean = False)
    
    openJobFile = False
    
    ' Set some globals up and make sure the folders are created.
    mJobTitle = parJobTitle
    mJobID = parJobID
    mJobSubFolderName = parFolderName
    EnsureJobFolderExists
    
    Dim newJobFileName As String
    newJobFileName = mJobFileDir & parJobID & ".xml"
    If mJobXMLDoc Is Nothing Or mJobFileName <> newJobFileName Or force Then
        Set mJobXMLDoc = New MSXML2.DOMDocument30
        mJobFileName = newJobFileName
        On Error GoTo noJobFile
        mJobXMLDoc.Load mJobFileName
        
        JobQvidianServer = getServerProperty
        DebugMsgBox "Server name in XML file is [" & JobQvidianServer & "]", "openJobFile:"
        
        ' What we do after this is XML version specific...
        loadXmlVersion
        
        If xmlVersion = "10.1" Then
            DebugMsgBox "Check SME Job ID", "openJobFile:"
            checkSMEJob
            
            DebugMsgBox "Read in the Composite content", "openJobFile:"
            getCompositeEdit
        Else
            isCompositeEdit = False
        End If
        
        If Not isCompositeEdit Then
            DebugMsgBox "Read in the content", "openJobFile:"
            loadContentList
            
            DebugMsgBox "Read in the custom meta-data definitions", "openJobFile:"
            loadCMDList
        End If
    
        openJobFile = True
    End If
    
    Exit Function
noJobFile:
    If MsgBox("The Job file does not exist or is corrupt. Would you like to remove this job?", vbYesNo) = vbYes Then
        gMultiEditFile.removeJobFromJobfile parJobID
    End If
End Function
'
'Public Function updateModifiedAttribute(contentNode As IXMLDOMNode)
'    updateModifiedAttribute = True
'
'    ' Update/Set the Modified flag in the XML
'    Dim attrib As IXMLDOMAttribute
'    Dim foundFlag As Boolean
'    foundFlag = False
'    For Each attrib In contentNode.Attributes
'        Select Case attrib.name
'            Case "Modified"
'                attrib.Text = "Y"
'                DebugMsgBox "updateModifiedAttribute: Update the Modified flag to Y"
'                foundFlag = True
'                Exit For
'        End Select
'    Next
'    If Not foundFlag Then
'        ' Add the modified flag.
'        Dim contentAttribs As IXMLDOMNamedNodeMap
'        Set contentAttribs = contentNode.Attributes
'        Dim modifiedAttrib As IXMLDOMNode
'        Set modifiedAttrib = mJobXMLDoc.createNode(2, "Modified", "")
'        modifiedAttrib.Text = "Y"
'        contentAttribs.setNamedItem modifiedAttrib
'        DebugMsgBox "updateModifiedAttribute: Add the Modified flag to Y"
'    End If
'
'    mJobXMLDoc.Save mJobFileName
'
'    updateModifiedAttribute = False
'End Function

Public Function getContentNodeByID(nContentID As Long) As IXMLDOMNode
    Set getContentNodeByID = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & nContentID & "']")
End Function

Public Function getContentByID(nContentID As Long) As struct_Content

    Set getContentByID = Nothing
    If isCompositeEdit Then
        Set getContentByID = compositeContent
    Else
        If contentList Is Nothing Or contentList.count = 0 Then
            DebugMsgBox "content list is empty.", "getContentByID:"
            Exit Function
        End If
        
        Dim content As struct_Content
        For Each content In contentList
            If content.contentID = nContentID Then
                Set getContentByID = content
                Exit For
            End If
        Next
    End If
End Function

Public Sub removeContentByID(nContentID As Long)

    If contentList Is Nothing Or contentList.count = 0 Then
        Exit Sub
    End If
    
    Dim content As struct_Content
    Dim count As Integer
    count = contentList.count
    Dim idx As Integer
    For idx = 1 To count
        Set content = contentList(idx)
        If content.contentID = nContentID Then
            DebugMsgBox "removing idx [" & idx & "]", "removeContentByID:"
            contentList.Remove idx
            Exit Sub
        End If
    Next idx
End Sub

Public Function getNextContentByID(nContentID As Long) As struct_Content

    Set getNextContentByID = Nothing
    If contentList Is Nothing Or contentList.count = 0 Then
        Exit Function
    End If
    
    Dim content As struct_Content
    Dim count As Integer
    count = contentList.count
    Dim idx As Integer
    For idx = 1 To count - 1
        Set content = contentList(idx)
        If content.contentID = nContentID Then
            Set getNextContentByID = contentList(idx + 1)
            Exit For
        End If
    Next idx
End Function

Public Function getPreviousContentByID(nContentID As Long) As struct_Content

    Set getPreviousContentByID = Nothing
    If contentList Is Nothing Or contentList.count = 0 Then
        Exit Function
    End If
    
    Dim content As struct_Content
    Dim count As Integer
    count = contentList.count
    Dim idx As Integer
    For idx = 2 To count
        Set content = contentList(idx)
        If content.contentID = nContentID Then
            Set getPreviousContentByID = contentList(idx - 1)
            Exit For
        End If
    Next idx
End Function

Private Sub checkSMEJob()
    Dim serverNode As IXMLDOMNode
    Set serverNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile")

    Dim attrib As IXMLDOMAttribute
    For Each attrib In serverNode.Attributes
        Select Case attrib.name
            Case "SMEJobID"
                SMEJobID = attrib.Text
                DebugMsgBox "from the file SMEJobID = [" & SMEJobID & "]", "checkSMEJob:"
                If SMEJobID = "" Then
                    isSMEJob = False
                Else
                    isSMEJob = True
                End If
                DebugMsgBox "isSMEJob = [" & isSMEJob & "]", "checkSMEJob:"
        End Select
    Next
End Sub

Private Sub loadXmlVersion()
    Dim serverNode As IXMLDOMNode
    Set serverNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Version")

    xmlVersion = ""
    Dim attrib As IXMLDOMAttribute
    For Each attrib In serverNode.Attributes
        Select Case attrib.name
            Case "Number"
                xmlVersion = attrib.Text
                DebugMsgBox "XML version is [" & getVersion & "]", "getVersion:"
        End Select
    Next
End Sub

Private Function getServerProperty() As String
    Dim serverNode As IXMLDOMNode
    Set serverNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Server")

    getServerProperty = ""
    Dim attrib As IXMLDOMAttribute
    For Each attrib In serverNode.Attributes
        Select Case attrib.name
            Case "Name"
                getServerProperty = attrib.Text
                DebugMsgBox "from the file [" & getServerProperty & "]", "getServerProperty:"
                If LCase(Left(getServerProperty, 4)) <> "http" Then
                    getServerProperty = UnScramble(getServerProperty)
                End If
                DebugMsgBox "after cleanup [" & getServerProperty & "]", "getServerProperty:"
            Case "ClearBuiltInOfficePropertiesOnSave"
                ClearBuiltInOfficePropertiesOnSave = IIf(LCase(attrib.Text) = "true", True, False)
                DebugMsgBox "ClearBuiltInOfficePropertiesOnSave [" & ClearBuiltInOfficePropertiesOnSave & "]", "getServerProperty:"
            Case "ClearCustomOfficePropertiesOnSave"
                ClearCustomOfficePropertiesOnSave = IIf(LCase(attrib.Text) = "true", True, False)
                DebugMsgBox "ClearCustomOfficePropertiesOnSave [" & ClearCustomOfficePropertiesOnSave & "]", "getServerProperty:"
        End Select
    Next
End Function

Private Function getCompositeEdit() As String
    Dim returnVal As String
    Dim serverNode As IXMLDOMNode
    Set serverNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/CompositeEdit")

    getCompositeEdit = ""
    isCompositeEdit = False
    Dim attrib As IXMLDOMAttribute
    For Each attrib In serverNode.Attributes
        Select Case attrib.name
            Case "JobID"
                compositeJobID = attrib.Text
                DebugMsgBox "compositeJobID [" & compositeJobID & "]", "getCompositeEdit:"
            Case "IsComposite"
                isCompositeEdit = IIf(LCase(attrib.Text) = "true", True, False)
                DebugMsgBox "isCompositeEdit [" & isCompositeEdit & "]", "getCompositeEdit:"
                If isCompositeEdit Then
                    Set compositeContent = New struct_Content
                    compositeContent.getCompositeContentProperties serverNode
                    
                    ' ARH Force the first row to be selected (should eb the ONLY row).
                    compositeContent.selected = True
                    
                    ' Load the actual modified file time.
                    Dim sEditFilePath As String
                    sEditFilePath = mJobFileDir & compositeContent.LocalFileName
                    compositeContent.FileModified = False
                    compositeContent.LocalFileModifiedDateSet = False
                    If GetFileSystemObject.FileExists(sEditFilePath) Then
                        ' We can only get here when ConntentID and LoalFileName are set,
                        ' so we can set Temp too
                        Dim f As Object
                        Set f = GetFileSystemObject.GetFile(sEditFilePath)
                        compositeContent.LocalFileModifiedDate = f.DateLastModified
                        DebugMsgBox "file modified timestamp [" & f.DateLastModified & "] compared with a create timestamp of [" & _
                                    compositeContent.LocalFileCreateDate & "] DateDiff = " & _
                                    DateDiff("s", compositeContent.LocalFileCreateDate, compositeContent.LocalFileModifiedDate), "getCompositeEdit:"
                        If DateDiff("s", compositeContent.LocalFileCreateDate, compositeContent.LocalFileModifiedDate) > 0 Then
                            compositeContent.FileModified = True
                        End If
                    End If
                End If
        End Select
    Next
End Function

Public Function loadContentProperties(contentID As Long) As struct_Content
    Set contentFileNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & contentID & "']")
    
    Set loadContentProperties = New struct_Content
    loadContentProperties.getContentProperties contentFileNode
End Function

Public Sub saveContentProperties(updatedAttribs As struct_Content)
    Dim contentFileNode As IXMLDOMNode
    Set contentFileNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & updatedAttribs.contentID & "']")

    Dim attrib As IXMLDOMAttribute
    For Each attrib In contentFileNode.Attributes
        Select Case attrib.name
            Case "ChangedTitle"
                attrib.Text = IIf(updatedAttribs.ChangedTitle, "True", "False")
            Case "UpdatedTitle"
                attrib.Text = updatedAttribs.UpdatedTitle
            Case "ChangedComments"
                attrib.Text = IIf(updatedAttribs.ChangedComments, "True", "False")
            Case "UpdatedComments"
                attrib.Text = updatedAttribs.UpdatedComments
            Case "ChangedContactInfo"
                attrib.Text = IIf(updatedAttribs.ChangedContactInfo, "True", "False")
            Case "UpdatedContactInfo"
                attrib.Text = updatedAttribs.UpdatedContactInfo
            Case "ChangedAlertEnabled"
                attrib.Text = IIf(updatedAttribs.ChangedAlertEnabled, "True", "False")
            Case "UpdatedAlertEnabled"
                attrib.Text = IIf(updatedAttribs.UpdatedAlertEnabled, "True", "False")
            Case "ChangedAlertText"
                attrib.Text = IIf(updatedAttribs.ChangedAlertText, "True", "False")
            Case "UpdatedAlertText"
                attrib.Text = updatedAttribs.UpdatedAlertText
            Case "ChangedDateToExpire"
                attrib.Text = IIf(updatedAttribs.ChangedDateToExpire, "True", "False")
            Case "UpdatedDateToExpireSet"
                attrib.Text = IIf(updatedAttribs.UpdatedDateToExpireSet, "True", "False")
            Case "UpdatedDateToExpire"
                If updatedAttribs.UpdatedDateToExpireSet Then
                    attrib.Text = format(ConvertLocalToUTC(updatedAttribs.UpdatedDateToExpire), "yyyy/mm/dd ttttt")
                Else
                    attrib.Text = ""
                End If
        End Select
    Next
    
    If updatedAttribs.cmdValues.count > 0 Then
        Dim cmdItem As struct_CMD
        Dim cmdNode As IXMLDOMNode
        Dim idx As Integer
        For idx = 0 To updatedAttribs.cmdValues.count - 1
            Set cmdItem = updatedAttribs.cmdValues.Items(idx)
            Set cmdNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & updatedAttribs.contentID & "']/CustomMetaDataValues/CustomMetaDataValue[@CMID='" & cmdItem.cmID & "']")
            For Each attrib In cmdNode.Attributes
                Select Case attrib.name
                    Case "ChangedValue"
                        attrib.Text = IIf(cmdItem.ChangedValue, "True", "False")
                    Case "UpdatedValue"
                        If cmdItem.DataType = CMDataTypes.DateType And cmdItem.UpdatedValue <> "" Then
                            attrib.Text = format(ConvertLocalToUTC(cmdItem.UpdatedValue), "yyyy/mm/dd ttttt")
                        Else
                            attrib.Text = cmdItem.UpdatedValue
                        End If
                End Select
            Next
        Next
    End If
    mJobXMLDoc.Save mJobFileName
End Sub

Public Sub saveContentFileProperties(contentID As Long, newFileName As String, newDate As Date)
    Dim contentFileNode As IXMLDOMNode
    Set contentFileNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & contentID & "']")

    Dim attrib As IXMLDOMAttribute
    Dim foundLocalFileName As Boolean
    Dim foundLocalFileCreateDate As Boolean
    foundLocalFileName = False
    foundLocalFileCreateDate = False
    For Each attrib In contentFileNode.Attributes
        Select Case attrib.name
            Case "LocalFileName"
                attrib.Text = newFileName
                foundLocalFileName = True
            Case "LocalFileCreateDate"
                DebugMsgBox "found the LocalFileCreateDate node", "saveContentFileProperties:"
                attrib.Text = ConvertLocalToUTC(newDate)
                foundLocalFileCreateDate = True
                Exit For
        End Select
    Next
    
    Dim contentAttribs As IXMLDOMNamedNodeMap
    Dim modifiedAttrib As IXMLDOMNode
    If Not foundLocalFileName Then
        DebugMsgBox "did NOT find the LocalFileName node", "saveContentFileProperties:"
        ' Didn't find it, so add to the file.
        Set contentAttribs = contentFileNode.Attributes
        Set modifiedAttrib = mJobXMLDoc.createNode(2, "LocalFileName", "")
        modifiedAttrib.Text = newFileName
        contentAttribs.setNamedItem modifiedAttrib
    End If
    
    If Not foundLocalFileCreateDate Then
        DebugMsgBox "did NOT find the LocalFileCreateDate node", "saveContentFileProperties:"
        ' Didn't find it, so add to the file.
        Set contentAttribs = contentFileNode.Attributes
        Set modifiedAttrib = mJobXMLDoc.createNode(2, "LocalFileCreateDate", "")
        modifiedAttrib.Text = ConvertLocalToUTC(newDate)
        contentAttribs.setNamedItem modifiedAttrib
    End If
    mJobXMLDoc.Save mJobFileName
End Sub

Public Sub saveCompositeContentFileProperties(newFileName As String, newDate As Date)
    Dim contentFileNode As IXMLDOMNode
    Set contentFileNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/CompositeEdit")

    Dim attrib As IXMLDOMAttribute
    Dim foundLocalFileName As Boolean
    Dim foundLocalFileCreateDate As Boolean
    foundLocalFileName = False
    foundLocalFileCreateDate = False
    For Each attrib In contentFileNode.Attributes
        Select Case attrib.name
            Case "LocalFileName"
                attrib.Text = newFileName
                foundLocalFileName = True
            Case "LocalFileCreateDate"
                DebugMsgBox "found the LocalFileCreateDate node", "saveContentFileProperties:"
                attrib.Text = ConvertLocalToUTC(newDate)
                foundLocalFileCreateDate = True
                Exit For
        End Select
    Next
    
    Dim contentAttribs As IXMLDOMNamedNodeMap
    Dim modifiedAttrib As IXMLDOMNode
    If Not foundLocalFileName Then
        DebugMsgBox "did NOT find the LocalFileName node", "saveContentFileProperties:"
        ' Didn't find it, so add to the file.
        Set contentAttribs = contentFileNode.Attributes
        Set modifiedAttrib = mJobXMLDoc.createNode(2, "LocalFileName", "")
        modifiedAttrib.Text = newFileName
        contentAttribs.setNamedItem modifiedAttrib
    End If
    
    If Not foundLocalFileCreateDate Then
        DebugMsgBox "did NOT find the LocalFileCreateDate node", "saveContentFileProperties:"
        ' Didn't find it, so add to the file.
        Set contentAttribs = contentFileNode.Attributes
        Set modifiedAttrib = mJobXMLDoc.createNode(2, "LocalFileCreateDate", "")
        modifiedAttrib.Text = ConvertLocalToUTC(newDate)
        contentAttribs.setNamedItem modifiedAttrib
    End If
    mJobXMLDoc.Save mJobFileName
End Sub

Public Sub RemoveAll()
    On Error Resume Next
    Set mJobXMLDoc = Nothing
    DebugMsgBox "Remove file [" & mJobFileName & "]", "RemoveAll:"
    KillPath mJobFileName
    DebugMsgBox "DeleteFolderContent [" & mJobFileDir & "]", "RemoveAll:"
    DeleteFolderContent mJobFileDir
    DebugMsgBox "DeleteFolder [" & Mid(mJobFileDir, 1, Len(mJobFileDir) - 1) & "]", "RemoveAll:"
    GetFileSystemObject.DeleteFolder Mid(mJobFileDir, 1, Len(mJobFileDir) - 1), True
    DebugMsgBox "DeleteFolder [" & Err.Number & "], [" & Err.description & "]", "RemoveAll:"
End Sub

Public Sub removeContentFile(contentID As Long)
    Dim contentFileNode As IXMLDOMNode
    Set contentFileNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & contentID & "']")
    
    If contentFileNode Is Nothing Then
        Exit Sub
    End If
    contentFileNode.parentNode.RemoveChild contentFileNode
    mJobXMLDoc.Save mJobFileName
    removeContentByID contentID
End Sub

Public Sub removeCompositeContentFile(contentID As Long)
    Dim contentFileNode As IXMLDOMNode
    Set contentFileNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/Content/ContentItem[@ContentID='" & contentID & "']")
    
    If contentFileNode Is Nothing Then
        Exit Sub
    End If
    contentFileNode.parentNode.RemoveChild contentFileNode
    mJobXMLDoc.Save mJobFileName
    removeContentByID contentID
End Sub

Public Sub loadContentList()
    DebugMsgBox "", "loadContentList:"
    
    Set contentList = New Collection
    
    Dim xmlList As IXMLDOMNodeList
    Dim contentNode As IXMLDOMNode
    Set xmlList = mJobXMLDoc.getElementsByTagName("ContentItem")
    If Not xmlList Is Nothing And xmlList.Length > 0 Then
        For Each contentNode In xmlList
            Dim content As struct_Content
            Set content = New struct_Content
            
            ' Load the meta-data
            content.getContentProperties contentNode
            
            ' Load the actual modified file time.
            Dim sEditFilePath As String
            sEditFilePath = mJobFileDir & content.LocalFileName
            content.FileModified = False
            content.LocalFileModifiedDateSet = False
            If GetFileSystemObject.FileExists(sEditFilePath) Then
                ' We can only get here when ConntentID and LoalFileName are set,
                ' so we can set Temp too
                content.LocalTempFileName = content.contentID & Mid(content.LocalFileName, InStrRev(content.LocalFileName, "."), Len(content.LocalFileName))
                If content.LocalTempFileName = content.LocalFileName Then
                    content.LocalTempFileName = ""
                End If
                
                Dim f As Object
                Set f = GetFileSystemObject.GetFile(sEditFilePath)
                content.LocalFileModifiedDate = f.DateLastModified
                DebugMsgBox "file modified timestamp [" & f.DateLastModified & "] compared with a create timestamp of [" & _
                            content.LocalFileCreateDate & "] DateDiff = " & _
                            DateDiff("s", content.LocalFileCreateDate, content.LocalFileModifiedDate), "loadContentList:"
                If DateDiff("s", content.LocalFileCreateDate, content.LocalFileModifiedDate) > 0 Then
                    content.FileModified = True
                End If
            End If
            contentList.Add content
        Next
    End If
End Sub

Public Sub loadCMDList()
    DebugMsgBox "", "loadCMDList:"
    Dim cmdNode As IXMLDOMNode
    Set cmdNode = mJobXMLDoc.SelectSingleNode("//MultiEditFile/CustomMetaDataDefinitions")

    Dim attrib As IXMLDOMAttribute
    For Each attrib In cmdNode.Attributes
        Select Case attrib.name
            Case "MultiValueDelimiter"
                MultiValueDelimiter = attrib.Text
                DebugMsgBox "MultiValueDelimiter is [" & MultiValueDelimiter & "]", "loadCMDList:"
        End Select
    Next
    
    Set cmdList = New Scripting.Dictionary
    
    Dim xmlList As IXMLDOMNodeList
    Set xmlList = mJobXMLDoc.getElementsByTagName("CustomMetaDataItem")
    If Not xmlList Is Nothing And xmlList.Length > 0 Then
        For Each cmdNode In xmlList
            Dim cmd As struct_CMDDef
            Set cmd = New struct_CMDDef
            
            ' Load the meta-data
            cmd.getCMDProperties cmdNode
            cmdList.Add cmd.cmID, cmd
        Next
    End If
End Sub

Public Function Cancel() As Boolean
    DebugMsgBox "", "clsJob.Cancel:"
    Cancel = False
    
    frmProgressBar.StartGeneric ("Connecting to the server...stage 1 of 3")
    frmProgressBar.UpdateProgressBarStatus 3, 0
    DoEvents
    
    ' Create the list of content ID's to cancel
    Dim item As Variant
    Dim contentNode As struct_Content
    Dim coList As String
    Dim id As Long
    DebugMsgBox "total of [" & selectedContentIDs.count & "] content items", "clsJob.Cancel:"
    For Each item In selectedContentIDs
        id = CLng(item)
        DebugMsgBox "ContentID is [" & id & "] document", "clsJob.Cancel:"
        
        ' Make sure it's a valid Content ID
        Set contentNode = getContentByID(id)
        If Not contentNode Is Nothing Then
            ' We need to close this document, if it's open
            Dim openDoc As Document
            For Each openDoc In Documents
                If openDoc.name = contentNode.LocalFileName Then
                    If Not editDoc Is Nothing Then
                        DebugMsgBox "Compare with ours [" & editDoc.FullName & "]", "clsJob.Cancel:"
                        
                        If openDoc.FullName = editDoc.FullName Then
                            isEditOpen = False
                            Set editDoc = Nothing
                        End If
                    End If
                    currentContentID = ContentIDNotSet
                    DebugMsgBox "Close the [" & contentNode.LocalFileName & "] document", "clsJob.Cancel:"
                    openDoc.Close False
                End If
            Next
            
            If Documents.count = 0 Then
                ' Open new document
                Set extraDoc = Documents.Add
                extraDoc.Activate
            End If
            
            ' Delete the local file...
            DebugMsgBox "remove local file is [" & mJobFileDir & contentNode.LocalFileName & "]", "clsJob.Cancel:"
            KillPath (mJobFileDir & contentNode.LocalFileName)
            
            ' Remove from the current Job file...
            DebugMsgBox "remove content from Job file", "clsJob.Cancel:"
            removeContentFile contentNode.contentID

            If Not coList = "" Then
                coList = coList & ","
            End If
            coList = coList & CStr(item)
        End If
    Next
    DebugMsgBox "contentID list is [" & coList & "]", "clsJob.Cancel:"
    
    frmProgressBar.StartGeneric ("Cancelling checkouts...stage 2 of 3")
    frmProgressBar.UpdateProgressBarStatus 3, 1
    DoEvents
    ' Cancel the checkouts, and refresh the Library if open...
    If CancelJobContentCheckout(coList) Then
        Cancel = True
    End If

End Function

Public Function CancelALL() As Boolean

    If isCompositeEdit = False And contentList Is Nothing And contentList.count = 0 Then
        CancelALL = True
        Exit Function
    End If
    
    CancelALL = False
    
    frmProgressBar.StartGeneric ("Connecting to the server...stage 1 of 3")
    frmProgressBar.UpdateProgressBarStatus 3, 0
    DoEvents
    
    Dim ContentIDs As String
    ' Get the Content IDs
    Dim content As struct_Content
    For Each content In contentList
        If content.contentID <> ContentIDNotSet Then
            If ContentIDs = "" Then
                ContentIDs = content.contentID
            Else
                ContentIDs = ContentIDs & "," & content.contentID
            End If
        End If
    Next
        
    CloseOpenJobFiles
        
    DebugMsgBox "contentIDs is [" & ContentIDs & "]", "CancelALL:"
    If Documents.count = 0 Then
        ' Open new document
        Set extraDoc = Documents.Add
        extraDoc.Activate
    End If
    
    frmProgressBar.StartGeneric ("Cancelling checkouts...stage 2 of 3")
    frmProgressBar.UpdateProgressBarStatus 3, 1
    DoEvents
    ' Cancel the checkouts, and refresh the Library if open...
    If CancelJobContentCheckout(ContentIDs) Then
        CancelALL = True
        
        ' Delete all local files and directories...
        RemoveAll
    End If
End Function

Private Function CloseOpenJobFiles() As Boolean
    
    ' Close/Save "our" window, if it's open.
    modMultiEdit.saveContentFile
    isEditOpen = False
    Set editDoc = Nothing
        
    Dim content As struct_Content
    Dim openDoc As Document
    If isCompositeEdit Then
        If Documents.count > 0 Then
            For Each openDoc In Documents
                If openDoc.name = compositeContent.LocalFileName Then
                    DebugMsgBox "Close the [" & compositeContent.LocalFileName & "] document", "CloseOpenJobFiles:"
                    openDoc.Close False
                End If
            Next
        End If
    Else
        For Each content In contentList
            If content.contentID <> ContentIDNotSet Then
                ' We need to close this document, if it's open
                If Documents.count > 0 Then
                    For Each openDoc In Documents
                        If openDoc.name = content.LocalFileName Then
                            DebugMsgBox "Close the [" & content.LocalFileName & "] document", "CloseOpenJobFiles:"
                            openDoc.Close False
                        End If
                    Next
                End If
            End If
        Next
    End If
    
    If Documents.count = 0 Then
        ' Open new document
        Set extraDoc = Documents.Add
        extraDoc.Activate
    End If
End Function

Private Function CancelJobContentCheckout(ContentIDs As String) As Boolean

    CancelJobContentCheckout = False
    
    ' If  this is an SME Job, we don't have to do anything
    If isSMEJob Then
        DebugMsgBox "This is an SME Edit job, so don't do anything to the actual files.", "CancelJobContentCheckout:"
        CancelJobContentCheckout = True
    Else
        
        ' Using the second param means it will ignore the first one...which is what we want
        If setupWSConnection(ActiveDocument, False, True, JobQvidianServer) <> ConnectionStatus.worked Then
            Exit Function
        End If
        
        If isCompositeEdit Then
            DebugMsgBox "compositeJobID [" & compositeJobID & "]", "CancelJobContentCheckout:"
            CancelJobContentCheckout = ss.wsm_CancelCompositeContentCheckout(compositeJobID)
        Else
            DebugMsgBox "contentIDs [" & ContentIDs & "]", "CancelJobContentCheckout:"
            CancelJobContentCheckout = ss.wsm_CancelContentCheckout(ContentIDs)
        End If
        DebugMsgBox "CancelJobContentCheckout = " & CancelJobContentCheckout, "CancelJobContentCheckout:"
    
        If CancelJobContentCheckout Then
            ' Let's try and refresh an IE window....
            DebugMsgBox "call RefreshScreen", "CancelJobContentCheckout:"
            If isCompositeEdit Then
                RefreshScreen 0, -1, -1, isPS
            Else
                ' Get the first Content ID...
                Dim ids() As String
                ids = Split(ContentIDs, ",")
                RefreshScreen 0, ids(0), -1, isPS
            End If
            DebugMsgBox "back from RefreshScreen", "CancelJobContentCheckout:"
        Else
            MsgBox "Failed to Cancel the checkout(s), please try again.", vbOKOnly, AppTitle
        End If
        
        DebugMsgBox "wsm_ConnectionTerminate", "CancelJobContentCheckout:"
        ss.wsm_ConnectionTerminate
    End If

End Function

Public Function Reset() As Boolean

    If (isCompositeEdit = False And (contentList Is Nothing Or contentList.count = 0)) Or _
       (selectedContentIDs Is Nothing Or selectedContentIDs.count = 0) Then
        Reset = True
        Exit Function
    End If
    
    Reset = False
    
    Dim stagesCount As Long
    stagesCount = 2 + selectedContentIDs.count
    frmProgressBar.StartGeneric ("Connecting to the server...stage 1 of " & stagesCount)
    frmProgressBar.UpdateProgressBarStatus stagesCount, 0
    DoEvents
    ' Using the second param means it will ignore the first one...which is what we want
    If setupWSConnection(ActiveDocument, False, True, JobQvidianServer) <> ConnectionStatus.worked Then
        Exit Function
    End If
    
    ' Get the Content IDs
    Dim content As struct_Content
    Dim result As String
    Dim idx As Long
    idx = 2
    Dim item As Variant
    Dim id As Long
    firstID = ContentIDNotSet
    Dim openDoc As Document
    Dim sEditFilePath As String
    Dim f As Object
    If isCompositeEdit Then
        Set content = compositeContent
        ' We need to close this document, if it's open
        For Each openDoc In Documents
            If openDoc.name = content.LocalFileName Then
                ' Close, it no point in saving as it's being restored anyways!
                content.FileModified = False
                
                isEditOpen = False
                Set editDoc = Nothing
                currentContentID = ContentIDNotSet
                
                DebugMsgBox "Close the [" & content.LocalFileName & "] document", "Reset:"
                openDoc.Close False
                If Documents.count = 0 Then
                    DebugMsgBox "Open a new blank document as there are none open right now.", "Reset:"
                    ' Open new document
                    Set extraDoc = Documents.Add
                    extraDoc.Activate
                End If
                Exit For
            End If
        Next
                
        ' Just download the file again...
        sEditFilePath = gJobFile.mJobFileDir & content.LocalFileName
        ' Remove it...
        DebugMsgBox "remove local file is [" & mJobFileDir & content.LocalFileName & "]", "Reset:"
        KillPath (sEditFilePath)
        DebugMsgBox "Call modWS.DownloadCompositeContentFile [" & sEditFilePath & "] " & compositeJobID, "Reset:"
        If Not modWS.DownloadCompositeContentFile(sEditFilePath, ActiveDocument, compositeJobID) Then
            'TODO: Change message to be more specific to this case.
            MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
            Exit Function
        End If
        
        ' Get the time-stamp of the file...
        Set f = GetFileSystemObject.GetFile(sEditFilePath)
        DebugMsgBox "file creation timestamp [" & f.DateLastModified & "]", "Reset:"
        content.LocalFileCreateDate = f.DateLastModified
        
        ' ...and save it
        gJobFile.saveCompositeContentFileProperties content.LocalFileName, content.LocalFileCreateDate
    Else
        For Each item In selectedContentIDs
            id = CLng(item)
            Set content = getContentByID(id)
            
            frmProgressBar.StartGeneric ("Saving Content ID [" & content.contentID & "]...stage " & idx & " of " & stagesCount)
            frmProgressBar.UpdateProgressBarStatus stagesCount, idx - 1
            DoEvents
            If content.contentID <> ContentIDNotSet Then
                If firstID = ContentIDNotSet Then firstID = id
                ' We need to close this document, if it's open
                For Each openDoc In Documents
                    If openDoc.name = content.LocalFileName Then
                        ' Close, it no point in saving as it's being restored anyways!
                        content.FileModified = False
                        
                        isEditOpen = False
                        Set editDoc = Nothing
                        currentContentID = ContentIDNotSet
                        
                        DebugMsgBox "Close the [" & content.LocalFileName & "] document", "Reset:"
                        openDoc.Close False
                        If Documents.count = 0 Then
                            DebugMsgBox "Open a new blank document as there are none open right now.", "Reset:"
                            ' Open new document
                            Set extraDoc = Documents.Add
                            extraDoc.Activate
                        End If
                        Exit For
                    End If
                Next
                
                ' Just download the file again...
                DebugMsgBox "IsTranslation: " & content.IsTranslation & " TranslationParent: " & content.TranslationParent, "Reset:"
                
                Dim sourceID As Long
                sourceID = content.contentID
                If content.IsTranslation Then
                    sourceID = content.TranslationParent
                End If
                
                sEditFilePath = gJobFile.mJobFileDir & content.LocalFileName
                ' Remove it...
                DebugMsgBox "remove local file is [" & mJobFileDir & content.LocalFileName & "]", "Reset:"
                KillPath (sEditFilePath)
                DebugMsgBox "Call modWS.DownloadContentFile [" & sEditFilePath & "] " & sourceID, "Reset:"
                If Not modWS.DownloadContentFile(sEditFilePath, ActiveDocument, sourceID, -1) Then
                    'TODO: Change message to be more specific to this case.
                    MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
                    Exit Function
                End If
                
                ' Get the time-stamp of the file...
                Set f = GetFileSystemObject.GetFile(sEditFilePath)
                DebugMsgBox "file creation timestamp [" & f.DateLastModified & "]", "Reset:"
                content.LocalFileCreateDate = f.DateLastModified
                
                ' ...and save it
                gJobFile.saveContentFileProperties content.contentID, content.LocalFileName, content.LocalFileCreateDate
            End If
            idx = idx + 1
        Next
    End If
    
    Reset = True
End Function

Public Function Save() As Boolean


    DebugMsgBox "Entered: isCompositeEdit: " & CStr(isCompositeEdit), "Save:"
    If contentList Is Nothing Then
        DebugMsgBox "contentList is Nothing", "Save:"
    Else
        DebugMsgBox "contentList.count = " & CStr(contentList.count), "Save:"
    End If
    
    If selectedContentIDs Is Nothing Then
        DebugMsgBox "selectedContentIDs is Nothing", "Save:"
    Else
        DebugMsgBox "selectedContentIDs.count = " & CStr(selectedContentIDs.count), "Save:"
    End If
    
    If (isCompositeEdit = False And (contentList Is Nothing Or contentList.count = 0)) Or _
       (selectedContentIDs Is Nothing Or selectedContentIDs.count = 0) Then
        Save = True
        Exit Function
    End If
    
    
    If ActiveDocument.ActiveWindow.Panes.count > 1 Then
        MsgBox "Please close any open Word panes before saving.", vbOKOnly, "Qvidian"
        Exit Function
    End If
    
    DebugMsgBox "Past the early return", "Save:"
    
    Save = False
    
    Dim stagesCount As Long
    stagesCount = 2 + selectedContentIDs.count
    frmProgressBar.StartGeneric ("Connecting to the server...stage 1 of " & stagesCount)
    frmProgressBar.UpdateProgressBarStatus stagesCount, 0
    DoEvents
    ' Using the second param means it will ignore the first one...which is what we want
    If setupWSConnection(ActiveDocument, False, True, JobQvidianServer) <> ConnectionStatus.worked Then
        Exit Function
    End If
    
    Dim uploadParams As struct_UploadParams
    Set uploadParams = New struct_UploadParams
    uploadParams.SantTemplateMode = "MultiEdit"
    
    ' Set the SME Job ID, regardless of what we are doing...
    uploadParams.JobID = SMEJobID
    uploadParams.isSMEJob = isSMEJob
    
    ' Get the Content IDs
    Dim content As struct_Content
    Dim result As String
    Dim idx As Long
    idx = 2
    Dim item As Variant
    Dim id As Long
    firstID = ContentIDNotSet
    Dim openDoc As Document
    Dim res As VbMsgBoxResult
    
    If isCompositeEdit Then
        uploadParams.TemplateMode = 28      ' 28 = CompositeFileSave
        uploadParams.JobID = compositeJobID
        Set content = compositeContent
        ' We need to close this document, if it's open
        For Each openDoc In Documents
            If openDoc.name = content.LocalFileName Then
                Dim ContentIDs As String
                ContentIDs = modDocProperties.GetPropertyText("ContentIDList", openDoc)
                If ContentIDs <> "" Then
                    Dim ContentIDArray() As String
                    ContentIDArray = Split(ContentIDs, ",")
                    firstID = CLng(ContentIDArray(0))
                End If
            
                '10253 close any open panes
                If openDoc.ActiveWindow.View.SplitSpecial = 18 Then
                    openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                    openDoc.ActiveWindow.View.SplitSpecial = wdPaneRevisions
                    openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                Else
                    openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                End If
                
                
                ' Save it if it's been changed...
                If Not openDoc.Saved Then
                    ' Save the file...
                    modMultiEdit.PromptSaveCurrentDoc openDoc, False, False, False, True
                    content.FileModified = True
                Else
                    DebugMsgBox "no save pending, FileModified is [" & content.FileModified & "]", "Save:"
                    If content.FileModified = False Then
                        res = MsgBox("The content has not been modified, would you like to save it as a new revision anyway?", vbYesNo, "Confirm Save")
                        
                        If res = vbYes Then
                            content.FileModified = True
                        End If
                    End If
                End If
                
                isEditOpen = False
                Set editDoc = Nothing
                currentContentID = ContentIDNotSet
                
                DebugMsgBox "Close the [" & content.LocalFileName & "] document", "Save:"
                openDoc.Close False
                Exit For
            End If
        Next
        
        ' Upload the changed file, if it's changed.
        If content.FileModified Then
            DebugMsgBox "Call wsm_UploadFileChunk: " & content.LocalFileName, "Save:"
            ' No
            result = ss.wsm_UploadFileChunk(uploadParams, content.ContentFilename, mJobFileDir & content.LocalFileName)
            DebugMsgBox "wsm_UploadFileChunk gave a result of: " + result, "Save:"
        Else
            ' Otherwise we need to cancel the checkout.
            ss.wsm_CancelCompositeContentCheckout (compositeJobID)
        End If
        
        DebugMsgBox "remove local file is [" & mJobFileDir & content.LocalFileName & "]", "Save:"
        KillPath (mJobFileDir & content.LocalFileName)
    Else
        uploadParams.TemplateMode = 3      ' 3 = Edit
        For Each item In selectedContentIDs
            id = CLng(item)
            Set content = getContentByID(id)
            
            frmProgressBar.StartGeneric ("Saving Content ID [" & content.contentID & "]...stage " & idx & " of " & stagesCount)
            frmProgressBar.UpdateProgressBarStatus stagesCount, idx - 1
            DoEvents
            If content.contentID <> ContentIDNotSet Then
                If firstID = ContentIDNotSet Then firstID = id
                ' We need to close this document, if it's open
                For Each openDoc In Documents
                    If openDoc.name = content.LocalFileName Then
                    
                        '10253 close any open panes
                        If openDoc.ActiveWindow.View.SplitSpecial = 18 Then
                            openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                            openDoc.ActiveWindow.View.SplitSpecial = wdPaneRevisions
                            openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                        Else
                            openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                        End If

                        ' Save it if it's been changed...
                        If Not openDoc.Saved Then
                            ' Save the file...
                            modMultiEdit.PromptSaveCurrentDoc openDoc, False, False, False, True
                            content.FileModified = True
                        Else
                            DebugMsgBox "no save pending, FileModified is [" & content.FileModified & "]", "Save:"
                            If content.FileModified = False Then
                                res = MsgBox("The content has not been modified, would you like to save it as a new revision anyway?", vbYesNo, "Confirm Save")
                                
                                If res = vbYes Then
                                    content.FileModified = True
                                End If
                            End If
                        End If
                        
                        isEditOpen = False
                        Set editDoc = Nothing
                        currentContentID = ContentIDNotSet
                        
                        DebugMsgBox "Close the [" & content.LocalFileName & "] document", "Save:"
                        openDoc.Close False
                        Exit For
                    End If
                Next
                
                ' Upload the changed file, if it's changed.
                If content.FileModified Then
                    uploadParams.contentID = content.contentID
                    DebugMsgBox "Call wsm_UploadFile: " & content.LocalFileName, "Save:"
                    ' Rename before we upload (unicode issues)?
                    If content.LocalTempFileName = "" Then
                        ' No
                        result = ss.wsm_UploadFileChunk(uploadParams, content.ContentFilename, mJobFileDir & content.LocalFileName)
                        DebugMsgBox "wsm_UploadFileChunk gave a result of: " + result, "Save:"
                    Else
                        ' Yes
                        GetFileSystemObject.MoveFile mJobFileDir & content.LocalFileName, mJobFileDir & content.LocalTempFileName
                        result = ss.wsm_UploadFileChunk(uploadParams, content.ContentFilename, mJobFileDir & content.LocalTempFileName)
                        DebugMsgBox "wsm_UploadFileChunk gave a result of: " + result, "Save:"
                        
                        ' And now move it back again!
                        GetFileSystemObject.MoveFile mJobFileDir & content.LocalTempFileName, mJobFileDir & content.LocalFileName
                    End If
                Else
                    ' Otherwise we need to cancel the checkout.
                    If Not isSMEJob Then
                        ss.wsm_CancelContentCheckout (content.contentID)
                    End If
                End If
                
                ' Did the meta-data change?
                If content.MetadataModified Then
                    DebugMsgBox "Call wsm_UpdateContentDetails: ", "Save:"
                    result = ss.wsm_UpdateContentDetails(content.contentID, content)
                    DebugMsgBox "wsm_UpdateContentDetails gave a result of: " & result, "Save:"
                End If
            End If
                
            ' Remove from the current Job file...
            DebugMsgBox "remove content from Job file", "Save:"
            removeContentFile content.contentID
        
            DebugMsgBox "remove local file is [" & mJobFileDir & content.LocalFileName & "]", "Save:"
            KillPath (mJobFileDir & content.LocalFileName)
            
            idx = idx + 1
        Next
    End If
       
    'DebugMsgBox "contentIDs is [" & contentIDs & "]"
    If Documents.count = 0 Then
        ' Open new document
        Set extraDoc = Documents.Add
        extraDoc.Activate
    End If

    DebugMsgBox "wsm_ConnectionTerminate", "Save:"
    ss.wsm_ConnectionTerminate
    
    ' Refresh the library window - not the firstID, this is so that Architecting saves refresh the icon.
    If Not isSMEJob And Not isCompositeEdit Then
        RefreshScreen 0, firstID, -1, isPS
    End If
    
    Save = True
End Function

Public Function SaveAll() As Boolean

    If contentList Is Nothing And contentList.count = 0 Then
        SaveAll = True
        Exit Function
    End If
    
    If ActiveDocument.ActiveWindow.Panes.count > 1 Then
        MsgBox "Please close any open Word panes before saving.", vbOKOnly, "Qvidian"
        Exit Function
    End If
    
    SaveAll = False
    
    Dim stagesCount As Long
    stagesCount = 2 + contentList.count
    frmProgressBar.StartGeneric ("Connecting to the server...stage 1 of " & stagesCount)
    frmProgressBar.UpdateProgressBarStatus stagesCount, 0
    DoEvents
    ' Using the second param means it will ignore the first one...which is what we want
    If setupWSConnection(ActiveDocument, False, True, JobQvidianServer) <> ConnectionStatus.worked Then
        Exit Function
    End If
    
    Dim uploadParams As struct_UploadParams
    Set uploadParams = New struct_UploadParams
    uploadParams.SantTemplateMode = "MultiEdit"
    uploadParams.TemplateMode = 3      ' 3 = Edit
    uploadParams.JobID = SMEJobID
    uploadParams.isSMEJob = isSMEJob
    
    ' Get the Content IDs
    Dim content As struct_Content
    Dim result As String
    Dim idx As Long
    idx = 2
    firstID = ContentIDNotSet
    DebugMsgBox "contentList.count is [" & contentList.count & "]", "SaveAll:"
    For Each content In contentList
        frmProgressBar.StartGeneric ("Saving Content ID [" & content.contentID & "]...stage " & idx & " of " & stagesCount)
        frmProgressBar.UpdateProgressBarStatus stagesCount, idx - 1
        DoEvents
        If content.contentID <> ContentIDNotSet Then
            If firstID = ContentIDNotSet Then firstID = content.contentID
            ' We need to close this document, if it's open
            Dim openDoc As Document
            For Each openDoc In Documents
                If openDoc.name = content.LocalFileName Then
                    '10253 close any open panes
                    If openDoc.ActiveWindow.View.SplitSpecial = 18 Then
                        openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                        openDoc.ActiveWindow.View.SplitSpecial = wdPaneRevisions
                        openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                    Else
                        openDoc.ActiveWindow.View.SplitSpecial = wdPaneNone
                    End If
                
                    ' Save it if it's been changed...
                    If Not openDoc.Saved Then
                        ' Save the file...
                        modMultiEdit.PromptSaveCurrentDoc openDoc, False, False, False, True
                        content.FileModified = True
                    End If

                    Set editDoc = Nothing
                    isEditOpen = False
                    currentContentID = ContentIDNotSet
                    
                    DebugMsgBox "Close the [" & content.LocalFileName & "] document", "SaveAll:"
                    openDoc.Close False
                    Exit For
                End If
            Next
            
            ' Upload the changed file, if it's changed.
            DebugMsgBox "contentID is [" & content.contentID & "] FileModified is [" & content.FileModified & "] MetadataModified is [" & content.MetadataModified & "]", "SaveAll:"
            If content.FileModified Then
                uploadParams.contentID = content.contentID
                DebugMsgBox "Call wsm_UploadFile: " & content.LocalFileName, "SaveAll:"
                ' Rename before we upload (unicode issues)?
                If content.LocalTempFileName = "" Then
                    ' No
                    result = ss.wsm_UploadFileChunk(uploadParams, content.ContentFilename, mJobFileDir & content.LocalFileName)
                    DebugMsgBox "wsm_UploadFile gave a result of: " + result, "Save:"
                Else
                    ' Yes
                    GetFileSystemObject.MoveFile mJobFileDir & content.LocalFileName, mJobFileDir & content.LocalTempFileName
                    result = ss.wsm_UploadFileChunk(uploadParams, content.ContentFilename, mJobFileDir & content.LocalTempFileName)
                    DebugMsgBox "wsm_UploadFile gave a result of: " + result, "Save:"
                    
                    ' And now move it back again!
                    GetFileSystemObject.MoveFile mJobFileDir & content.LocalTempFileName, mJobFileDir & content.LocalFileName
                End If
            Else
                ' Otherwise we need to cancel the checkout.
                If Not isSMEJob Then
                    DebugMsgBox "Call wsm_CancelContentCheckout: " & content.LocalFileName, "SaveAll:"
                    ss.wsm_CancelContentCheckout (content.contentID)
                End If
            End If
            
            ' Did the meta-data change?
            If content.MetadataModified Then
                DebugMsgBox "Call wsm_UpdateContentDetails: ", "SaveAll:"
                result = ss.wsm_UpdateContentDetails(content.contentID, content)
                DebugMsgBox "wsm_UpdateContentDetails gave a result of: " & result, "SaveAll:"
            End If
        End If
        
        idx = idx + 1
    Next
        
    If Documents.count = 0 Then
        ' Open new document
        Set extraDoc = Documents.Add
        extraDoc.Activate
    End If

    DebugMsgBox "wsm_ConnectionTerminate", "SaveAll:"
    ss.wsm_ConnectionTerminate
        
    ' Delete all local files and directories...
    RemoveAll
    
    ' Refresh the library window - not the firstID, this is so that Architecting saves refresh the icon.
    If Not isSMEJob And Not gJobFile.isCompositeEdit Then
        RefreshScreen 0, firstID, -1, isPS
    End If
    
    SaveAll = True
End Function

Public Function openContentFile(contentID As Long)
    openContentFile = False
    DebugMsgBox "", "clsJob.openContentFile:"
    
    If contentID <> ContentIDNotSet Then
        Dim contentNode As struct_Content
        Set contentNode = getContentByID(contentID)
        If contentNode Is Nothing Then
            DebugMsgBox "Did not find the ContentItem node in the XML file", "clsJob.openContentFile:"
            Exit Function
        End If
        
        openContentFile = openContentFileFromNode(contentNode)
        DebugMsgBox "back from openContentFileFromNode", "clsJob.openContentFile:"
    End If
    
End Function

Public Function openContentFileFromNode(contentNode As struct_Content)
    openContentFileFromNode = False
    DebugMsgBox "", "clsJob.openContentFileFromNode:"
    
    If contentNode Is Nothing Then
        DebugMsgBox "Did not find the ContentItem node in the XML file", "openContentFileFromNode:"
        Exit Function
    End If
    
    Dim ContentFilename As String
    currentContentID = contentNode.contentID
     
    ' Need to get the filename...
    ContentFilename = mJobFileDir & contentNode.LocalFileName
    DebugMsgBox "File path is [" & ContentFilename & "]", "openContentFileFromNode:"
    
    ' SETTING THIS FLAG WILL PREVENT TOOLBAR INITIATION, WHICH IS WHAT WE WANT
    bActiveBuild = True
    
    ' Potentially close the current file...
    On Error Resume Next
    If isEditOpen Then
        DebugMsgBox "One of ours [" & editDoc.name & "] is open, close it", "openContentFileFromNode:"
        ' Some times, the job window gets forced closed when it shouldn't be!
        ' this flag is an attempt at preventing that.
        Dim gForceJobFormOpen As Boolean
        gForceJobFormOpen = gIsMultiEditShowing
        ' Note, no save required here because we've already prompted for that
        ' further up the tree.
        currentContentID = ContentIDNotSet
        editDoc.Close False
        DebugMsgBox "See ya, it's gone...gForceJobFormOpen [" & gForceJobFormOpen & "] and gIsMultiEditShowing is [" & gIsMultiEditShowing & "]", "openContentFileFromNode:"
        If gForceJobFormOpen And Not gIsMultiEditShowing Then
            ToggleForm
            gForceJobFormOpen = False
        End If
        isEditOpen = False
    Else
        ' Potentially need to close the doc if it's a new blank one.
        DebugMsgBox "None of ours are open, but still may need to close something...[" & ActiveDocument.path & "] state is [" & ActiveDocument.Saved & "]", "openContentFileFromNode:"
        If ActiveDocument.path = "" And ActiveDocument.Saved = True Then
            DebugMsgBox "Close the current document, it's a blank with no changes", "openContentFileFromNode:"
            ActiveDocument.Close False
        End If
    End If
    
    ' Open the first file...
    DebugMsgBox "Open the new document...[" & ContentFilename & "]", "openContentFileFromNode:"
    Set editDoc = Documents.Open(ContentFilename, False, False, True)
    
    ' Content that was uploaded with a template mode and server were causing problems in PowerPoint (removing them in both Word and PowerPoint)
    DebugMsgBox "Remove existing Custom Document Properties not required by multi edit...[" & ContentFilename & "]", "openContentFileFromNode:"
    RemoveProperty "SantTemplateMode", editDoc
    RemoveProperty "Server", editDoc
    
    DebugMsgBox "set it as active...", "openContentFileFromNode:"
    Set modInit.activeSantDocument = editDoc
    
    ' Defect 9201 Fix
    SwitchToPrintLayout editDoc.ActiveWindow

    isEditOpen = True
    bActiveBuild = False
    SwitchToolbarsExplicit "MultiEdit", editDoc
    
    ActivateQvidianRibbon
    
    openContentFileFromNode = True
    DebugMsgBox "Leaving", "openContentFileFromNode:"
End Function

Private Sub EnsureJobFolderExists()
    ' This makes sure we get the base path (sMultiEditFilesFolder)...
    ' Not a big fan of putting the dependency in here, but it is easier:)
    If gMultiEditFile Is Nothing Then
        Set gMultiEditFile = New clsMultiEdit
    End If
    
    On Error Resume Next
    mJobFileDir = gMultiEditFile.sMultiEditFilesFolder & mJobSubFolderName
    DebugMsgBox "mJobFileDir = [" & mJobFileDir & "]", "EnsureJobFolderExists:"
    If Not GetFileSystemObject.FolderExists(mJobFileDir) Then GetFileSystemObject.CreateFolder (mJobFileDir)
    mJobFileDir = mJobFileDir & "\"
End Sub

Private Sub clearOutLocalFileCreateDates(xmlFileFullPath As String)

    Dim expXMLDoc As MSXML2.DOMDocument30
    Set expXMLDoc = New MSXML2.DOMDocument30
    On Error GoTo badProcessing
    expXMLDoc.Load xmlFileFullPath

    Dim xmlList As IXMLDOMNodeList
    Dim contentNode As IXMLDOMNode
    Set xmlList = expXMLDoc.getElementsByTagName("ContentItem")
    If Not xmlList Is Nothing And xmlList.Length > 0 Then
        For Each contentNode In xmlList
            Dim attrib As IXMLDOMAttribute
            For Each attrib In contentNode.Attributes
                Select Case attrib.name
                    Case "LocalFileCreateDate"
                        attrib.Text = ""
                        Exit For
                End Select
            Next
        Next
        expXMLDoc.Save xmlFileFullPath
    End If

badProcessing:
End Sub

Private Sub Class_Initialize()
    Set contentList = New Collection
    ClearBuiltInOfficePropertiesOnSave = False
    ClearCustomOfficePropertiesOnSave = False
    MultiValueDelimiter = ";"
    SMEJobID = ""
    isCompositeEdit = False
    isSMEJob = False
    compositeJobID = ""
End Sub

Private Sub Class_Terminate()
    Set cmdList = Nothing
End Sub
Attribute VB_Name = "clsMultiEdit"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' These next two are for the current Job file that is active
Private multiEditXMLFile As MSXML2.DOMDocument
Public sMultiEditFilesFolder As String
Private sMultiEditFullName As String
Private lastModifiedDate As Date
Public jobFileData As Scripting.Dictionary
Public jobFolderData As Scripting.Dictionary


Private Sub Class_Initialize()
    Set jobFileData = New Scripting.Dictionary
    Set jobFolderData = New Scripting.Dictionary
    EnsureMultiEditFolderExists
    sMultiEditFullName = sDocumentsPath & MEJFile
End Sub

Private Function openMultiEditJobsXMLFile() As Boolean
    openMultiEditJobsXMLFile = False
    
    ' Get the current DT stamp...
    On Error Resume Next
    Dim f As Object
    Set f = GetFileSystemObject.GetFile(sMultiEditFullName)
    ' Does the file exist?
    DebugMsgBox "GetFileSystemObject.GetFile - Err [" & Err.Number & "]", "openMultiEditJobsXMLFile:"
    If Err.Number = 53 Then
        DebugMsgBox "create a new blank file...", "openMultiEditJobsXMLFile:"
        createEmptyJobFile
        Set f = GetFileSystemObject.GetFile(sMultiEditFullName)
    End If
    
    DebugMsgBox "file modified timestamp [" & f.DateLastModified & "]", "openMultiEditJobsXMLFile:"
    DebugMsgBox "compared with a create timestamp of [" & lastModifiedDate & "]", "openMultiEditJobsXMLFile:"
    DebugMsgBox "DateDiff = " & DateDiff("s", lastModifiedDate, f.DateLastModified), "openMultiEditJobsXMLFile:"
    If DateDiff("s", lastModifiedDate, f.DateLastModified) > 0 Then
        lastModifiedDate = f.DateLastModified
        Set multiEditXMLFile = New MSXML2.DOMDocument
        multiEditXMLFile.Load sMultiEditFullName
        If Err.Number <> 0 Or multiEditXMLFile.parseError.ErrorCode <> 0 Then
            Set multiEditXMLFile = Nothing
            openMultiEditJobsXMLFile = True
        End If
    End If
End Function

Public Function loadMultiEditFile() As Boolean
    DebugMsgBox "load [" & sMultiEditFullName & "]", "loadMultiEditFile:"
    loadMultiEditFile = False
    If openMultiEditJobsXMLFile Then
        loadMultiEditFile = True
        Exit Function
    End If
    
    Set jobFileData = Nothing
    Set jobFileData = New Scripting.Dictionary
       
    Set jobFolderData = Nothing
    Set jobFolderData = New Scripting.Dictionary
 
    Dim jobList As IXMLDOMNodeList
    Dim jobNode As IXMLDOMNode
    Set jobList = multiEditXMLFile.getElementsByTagName("MultiEditJob")
    If Not jobList Is Nothing And jobList.Length > 0 Then
        Dim JobID As String
        Dim title As String
        Dim folder As String
        Dim attrib As IXMLDOMAttribute
        For Each jobNode In jobList
            For Each attrib In jobNode.Attributes
                Select Case attrib.name
                    Case "JobID"
                        JobID = attrib.Text
                    Case "Title"
                        title = attrib.Text
                    Case "FolderName"
                        folder = attrib.Text
                End Select
            Next
            
            If JobID <> "" And folder <> "" And title <> "" Then
                AddJobFileValue title, JobID, folder
                If currentJobTitle = "" Then
                    currentJobTitle = title
                End If
            End If
            
            multiEditXMLFile.getElementsByTagName ("MultiEditJob")
        Next
        
    Else
        currentJobTitle = ""
        currentContentID = 0
    End If
End Function

Public Sub AddJobFileValue(sJobTitle As String, sJobFile As String, sJobFolder As String)
    If jobFileData.Exists(sJobTitle) Then
        jobFileData(sJobTitle) = sJobFile
        jobFolderData(sJobTitle) = sJobFolder
    Else
        DebugMsgBox "Add new [" & sJobTitle & "] [" & sJobFile & "]", "AddJobFileValue:"
        jobFileData.Add sJobTitle, sJobFile
        DebugMsgBox "Add new [" & sJobTitle & "] [" & sJobFolder & "]", "AddJobFileValue:"
        jobFolderData.Add sJobTitle, sJobFolder
    End If
End Sub

Public Sub RemoveJobFileValue(sJobTitle As String)
    If jobFileData.Exists(sJobTitle) Then
        jobFileData.Remove sJobTitle
        jobFolderData.Remove sJobTitle
    End If
End Sub

Private Sub createEmptyJobFile()
    Dim sXml As String
    sXml = "<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>"
    sXml = sXml & vbNewLine & "<MultiEditJobs>"
    sXml = sXml & vbNewLine & "</MultiEditJobs>"
    
    Set multiEditXMLFile = New MSXML2.DOMDocument
    multiEditXMLFile.loadXML sXml
    multiEditXMLFile.Save sMultiEditFullName
End Sub

Public Function addJobToJobfile(sJobFile As String, jobFileTitle As String, jobFolderName As String)
    openMultiEditJobsXMLFile
    
    If multiEditXMLFile Is Nothing Then
        Dim sXml As String
        sXml = "<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>"
        sXml = sXml & vbNewLine & "<MultiEditJobs>"
        sXml = sXml & vbNewLine & "<MultiEditJob JobID=""" & sJobFile & """ Title=""" & jobFileTitle & """ FolderName=""" & jobFolderName & """/>"
        sXml = sXml & vbNewLine & "</MultiEditJobs>"
        
        Set multiEditXMLFile = New MSXML2.DOMDocument
        multiEditXMLFile.loadXML sXml
    Else
        Dim meNode As IXMLDOMElement
        Dim jobNode As IXMLDOMNode
        Set meNode = multiEditXMLFile.SelectSingleNode("//MultiEditJobs")
        Set jobNode = multiEditXMLFile.createNode(1, "MultiEditJob", "")
        Dim jobAttribs As IXMLDOMNamedNodeMap
        Set jobAttribs = jobNode.Attributes
        Dim JobID As IXMLDOMNode
        Set JobID = multiEditXMLFile.createNode(2, "JobID", "")
        JobID.Text = sJobFile
        jobAttribs.setNamedItem JobID
        Dim jobFolder As IXMLDOMNode
        Set jobFolder = multiEditXMLFile.createNode(2, "FolderName", "")
        jobFolder.Text = jobFolderName
        jobAttribs.setNamedItem jobFolder
        Dim jobTitle As IXMLDOMNode
        Set jobTitle = multiEditXMLFile.createNode(2, "Title", "")
        jobTitle.Text = jobFileTitle
        jobAttribs.setNamedItem jobTitle
        meNode.appendChild jobNode
    End If
    multiEditXMLFile.Save sMultiEditFullName

End Function

Public Function removeJobFromJobfile(sJobFile As String)
    removeJobFromJobfile = False
    If Not multiEditXMLFile Is Nothing Then
    
        Dim deleteNode As IXMLDOMNode
        Set deleteNode = multiEditXMLFile.SelectSingleNode("//MultiEditJobs/MultiEditJob[@JobID='" & sJobFile & "']")
        If deleteNode Is Nothing Then
            DebugMsgBox "Failed to find JobID [" & sJobFile & "]", "removeJobFromJobfile:"
            Exit Function
        End If
        deleteNode.parentNode.RemoveChild deleteNode
        multiEditXMLFile.Save sMultiEditFullName
    End If
    
    removeJobFromJobfile = True
End Function

Public Function updateJobTitle(sJobID As String, sJobTitle As String, sNewTitle As String)
    updateJobTitle = False
    DebugMsgBox "Change [" & sJobID & "] from [" & sJobTitle & "] to [" & sNewTitle & "]", "updateJobTitle:"
    Dim jobNode As IXMLDOMNode
    Set jobNode = multiEditXMLFile.SelectSingleNode("//MultiEditJobs/MultiEditJob[@JobID='" & sJobID & "']")

    If jobNode Is Nothing Then
        Exit Function
    End If
    
    Dim attrib As IXMLDOMAttribute
    Dim tempJobID As String
    Dim tempJobFolder As String
    For Each attrib In jobNode.Attributes
        Select Case attrib.name
            Case "Title"
                attrib.Text = sNewTitle
            Case "JobID"
                tempJobID = attrib.Text
            Case "FolderName"
                tempJobFolder = attrib.Text
        End Select
    Next
    
    multiEditXMLFile.Save sMultiEditFullName
    
    ' Update the globals
    RemoveJobFileValue (sJobTitle)
    AddJobFileValue sNewTitle, tempJobID, tempJobFolder
    
    updateJobTitle = True
End Function

Private Function EnsureMultiEditFolderExists() As String
    'The following variables are defined in the build files.
    sDocumentsPath = GetClientPath
    If Not GetFileSystemObject.FolderExists(sDocumentsPath) Then GetFileSystemObject.CreateFolder (sDocumentsPath)
    
    sMultiEditFilesFolder = sDocumentsPath & "MultiEditFiles\"
    DebugMsgBox "sMultiEditFilesFolder = [" & sMultiEditFilesFolder & "]", "EnsureMultiEditFolderExists:"
    If Not GetFileSystemObject.FolderExists(sMultiEditFilesFolder) Then GetFileSystemObject.CreateFolder (sMultiEditFilesFolder)
End Function

Public Function doesJobTitleExist(sJobTitle As String) As Boolean
    doesJobTitleExist = jobFileData.Exists(sJobTitle)
End Function
Attribute VB_Name = "clsRijnDael"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'*******************************************************************************
' MODULE:       CRijndael
' FILENAME:     C:\My Code\vb\Rijndael\CRijndael.cls
' AUTHOR:       Phil Fresle
' CREATED:      16-Feb-2001
' COPYRIGHT:    Copyright 2001 Phil Fresle
' EMAIL:        phil@frez.co.uk
' WEB:          http://www.frez.co.uk
'
' DESCRIPTION:
' Implementation of the AES Rijndael Block Cipher. Inspired by Mike Scott's
' implementation in C. Permission for free direct or derivative use is granted
' subject to compliance with any conditions that the originators of the
' algorithm place on its exploitation.
'
' MODIFICATION HISTORY:
' 1.0       18-Feb-2001
'           Phil Fresle
'           Initial Version
'*******************************************************************************
Option Explicit

Private m_lOnBits(30)   As Long
Private m_l2Power(30)   As Long
Private m_bytOnBits(7)  As Byte
Private m_byt2Power(7)  As Byte

Private m_InCo(3) As Byte

Private m_fbsub(255)    As Byte
Private m_rbsub(255)    As Byte
Private m_ptab(255)     As Byte
Private m_ltab(255)     As Byte
Private m_ftable(255)   As Long
Private m_rtable(255)   As Long
Private m_rco(29)       As Long

Private m_Nk        As Long
Private m_Nb        As Long
Private m_Nr        As Long
Private m_fi(23)    As Byte
Private m_ri(23)    As Byte
Private m_fkey(119) As Long
Private m_rkey(119) As Long

'*******************************************************************************
' Class_Initialize (SUB)
'*******************************************************************************
Private Sub Class_Initialize()
    m_InCo(0) = &HB
    m_InCo(1) = &HD
    m_InCo(2) = &H9
    m_InCo(3) = &HE
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - BITS SET FROM RIGHT
    m_bytOnBits(0) = 1          ' 00000001
    m_bytOnBits(1) = 3          ' 00000011
    m_bytOnBits(2) = 7          ' 00000111
    m_bytOnBits(3) = 15         ' 00001111
    m_bytOnBits(4) = 31         ' 00011111
    m_bytOnBits(5) = 63         ' 00111111
    m_bytOnBits(6) = 127        ' 01111111
    m_bytOnBits(7) = 255        ' 11111111
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - POWERS OF 2
    m_byt2Power(0) = 1          ' 00000001
    m_byt2Power(1) = 2          ' 00000010
    m_byt2Power(2) = 4          ' 00000100
    m_byt2Power(3) = 8          ' 00001000
    m_byt2Power(4) = 16         ' 00010000
    m_byt2Power(5) = 32         ' 00100000
    m_byt2Power(6) = 64         ' 01000000
    m_byt2Power(7) = 128        ' 10000000
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - BITS SET FROM RIGHT
    m_lOnBits(0) = 1            ' 00000000000000000000000000000001
    m_lOnBits(1) = 3            ' 00000000000000000000000000000011
    m_lOnBits(2) = 7            ' 00000000000000000000000000000111
    m_lOnBits(3) = 15           ' 00000000000000000000000000001111
    m_lOnBits(4) = 31           ' 00000000000000000000000000011111
    m_lOnBits(5) = 63           ' 00000000000000000000000000111111
    m_lOnBits(6) = 127          ' 00000000000000000000000001111111
    m_lOnBits(7) = 255          ' 00000000000000000000000011111111
    m_lOnBits(8) = 511          ' 00000000000000000000000111111111
    m_lOnBits(9) = 1023         ' 00000000000000000000001111111111
    m_lOnBits(10) = 2047        ' 00000000000000000000011111111111
    m_lOnBits(11) = 4095        ' 00000000000000000000111111111111
    m_lOnBits(12) = 8191        ' 00000000000000000001111111111111
    m_lOnBits(13) = 16383       ' 00000000000000000011111111111111
    m_lOnBits(14) = 32767       ' 00000000000000000111111111111111
    m_lOnBits(15) = 65535       ' 00000000000000001111111111111111
    m_lOnBits(16) = 131071      ' 00000000000000011111111111111111
    m_lOnBits(17) = 262143      ' 00000000000000111111111111111111
    m_lOnBits(18) = 524287      ' 00000000000001111111111111111111
    m_lOnBits(19) = 1048575     ' 00000000000011111111111111111111
    m_lOnBits(20) = 2097151     ' 00000000000111111111111111111111
    m_lOnBits(21) = 4194303     ' 00000000001111111111111111111111
    m_lOnBits(22) = 8388607     ' 00000000011111111111111111111111
    m_lOnBits(23) = 16777215    ' 00000000111111111111111111111111
    m_lOnBits(24) = 33554431    ' 00000001111111111111111111111111
    m_lOnBits(25) = 67108863    ' 00000011111111111111111111111111
    m_lOnBits(26) = 134217727   ' 00000111111111111111111111111111
    m_lOnBits(27) = 268435455   ' 00001111111111111111111111111111
    m_lOnBits(28) = 536870911   ' 00011111111111111111111111111111
    m_lOnBits(29) = 1073741823  ' 00111111111111111111111111111111
    m_lOnBits(30) = 2147483647  ' 01111111111111111111111111111111
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - POWERS OF 2
    m_l2Power(0) = 1            ' 00000000000000000000000000000001
    m_l2Power(1) = 2            ' 00000000000000000000000000000010
    m_l2Power(2) = 4            ' 00000000000000000000000000000100
    m_l2Power(3) = 8            ' 00000000000000000000000000001000
    m_l2Power(4) = 16           ' 00000000000000000000000000010000
    m_l2Power(5) = 32           ' 00000000000000000000000000100000
    m_l2Power(6) = 64           ' 00000000000000000000000001000000
    m_l2Power(7) = 128          ' 00000000000000000000000010000000
    m_l2Power(8) = 256          ' 00000000000000000000000100000000
    m_l2Power(9) = 512          ' 00000000000000000000001000000000
    m_l2Power(10) = 1024        ' 00000000000000000000010000000000
    m_l2Power(11) = 2048        ' 00000000000000000000100000000000
    m_l2Power(12) = 4096        ' 00000000000000000001000000000000
    m_l2Power(13) = 8192        ' 00000000000000000010000000000000
    m_l2Power(14) = 16384       ' 00000000000000000100000000000000
    m_l2Power(15) = 32768       ' 00000000000000001000000000000000
    m_l2Power(16) = 65536       ' 00000000000000010000000000000000
    m_l2Power(17) = 131072      ' 00000000000000100000000000000000
    m_l2Power(18) = 262144      ' 00000000000001000000000000000000
    m_l2Power(19) = 524288      ' 00000000000010000000000000000000
    m_l2Power(20) = 1048576     ' 00000000000100000000000000000000
    m_l2Power(21) = 2097152     ' 00000000001000000000000000000000
    m_l2Power(22) = 4194304     ' 00000000010000000000000000000000
    m_l2Power(23) = 8388608     ' 00000000100000000000000000000000
    m_l2Power(24) = 16777216    ' 00000001000000000000000000000000
    m_l2Power(25) = 33554432    ' 00000010000000000000000000000000
    m_l2Power(26) = 67108864    ' 00000100000000000000000000000000
    m_l2Power(27) = 134217728   ' 00001000000000000000000000000000
    m_l2Power(28) = 268435456   ' 00010000000000000000000000000000
    m_l2Power(29) = 536870912   ' 00100000000000000000000000000000
    m_l2Power(30) = 1073741824  ' 01000000000000000000000000000000
End Sub

'*******************************************************************************
' LShift (FUNCTION)
'*******************************************************************************
Private Function LShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _
            m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _
            m_l2Power(iShiftBits))
    End If
End Function

'*******************************************************************************
' RShift (FUNCTION)
'*******************************************************************************
Private Function RShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function

'*******************************************************************************
' LShiftByte (FUNCTION)
'*******************************************************************************
Private Function LShiftByte(ByVal bytValue As Byte, _
                            ByVal bytShiftBits As Byte) As Byte
    If bytShiftBits = 0 Then
        LShiftByte = bytValue
        Exit Function
    ElseIf bytShiftBits = 7 Then
        If bytValue And 1 Then
            LShiftByte = &H80
        Else
            LShiftByte = 0
        End If
        Exit Function
    ElseIf bytShiftBits < 0 Or bytShiftBits > 7 Then
        Err.Raise 6
    End If
    
    LShiftByte = ((bytValue And m_bytOnBits(7 - bytShiftBits)) * _
        m_byt2Power(bytShiftBits))
End Function

'*******************************************************************************
' RShiftByte (FUNCTION)
'*******************************************************************************
Private Function RShiftByte(ByVal bytValue As Byte, _
                            ByVal bytShiftBits As Byte) As Byte
    If bytShiftBits = 0 Then
        RShiftByte = bytValue
        Exit Function
    ElseIf bytShiftBits = 7 Then
        If bytValue And &H80 Then
            RShiftByte = 1
        Else
            RShiftByte = 0
        End If
        Exit Function
    ElseIf bytShiftBits < 0 Or bytShiftBits > 7 Then
        Err.Raise 6
    End If
    
    RShiftByte = bytValue \ m_byt2Power(bytShiftBits)
End Function

'*******************************************************************************
' RotateLeft (FUNCTION)
'*******************************************************************************
Private Function RotateLeft(ByVal lValue As Long, _
                            ByVal iShiftBits As Integer) As Long
    RotateLeft = LShift(lValue, iShiftBits) Or RShift(lValue, (32 - iShiftBits))
End Function

''*******************************************************************************
'' RotateLeftByte (FUNCTION)
'*******************************************************************************
Private Function RotateLeftByte(ByVal bytValue As Byte, _
                                ByVal bytShiftBits As Byte) As Byte
    RotateLeftByte = LShiftByte(bytValue, bytShiftBits) Or _
        RShiftByte(bytValue, (8 - bytShiftBits))
End Function

'*******************************************************************************
' Pack (FUNCTION)
'*******************************************************************************
Private Function Pack(b() As Byte) As Long
    Dim lCount As Long
    Dim lTemp  As Long
    
    For lCount = 0 To 3
        lTemp = b(lCount)
        Pack = Pack Or LShift(lTemp, (lCount * 8))
    Next
End Function

'*******************************************************************************
' PackFrom (FUNCTION)
'*******************************************************************************
Private Function PackFrom(b() As Byte, _
                          ByVal k As Long) As Long
    Dim lCount As Long
    Dim lTemp  As Long
    
    For lCount = 0 To 3
        lTemp = b(lCount + k)
        PackFrom = PackFrom Or LShift(lTemp, (lCount * 8))
    Next
End Function

'*******************************************************************************
' Unpack (SUB)
'*******************************************************************************
Private Sub Unpack(ByVal a As Long, _
                   b() As Byte)
    b(0) = a And m_lOnBits(7)
    b(1) = RShift(a, 8) And m_lOnBits(7)
    b(2) = RShift(a, 16) And m_lOnBits(7)
    b(3) = RShift(a, 24) And m_lOnBits(7)
End Sub

'*******************************************************************************
' UnpackFrom (SUB)
'*******************************************************************************
Private Sub UnpackFrom(ByVal a As Long, _
                       b() As Byte, _
                       ByVal k As Long)
    b(0 + k) = a And m_lOnBits(7)
    b(1 + k) = RShift(a, 8) And m_lOnBits(7)
    b(2 + k) = RShift(a, 16) And m_lOnBits(7)
    b(3 + k) = RShift(a, 24) And m_lOnBits(7)
End Sub

'*******************************************************************************
' xtime (FUNCTION)
'*******************************************************************************
Private Function xtime(ByVal a As Byte) As Byte
    Dim b As Byte
    
    If (a And &H80) Then
        b = &H1B
    Else
        b = 0
    End If
    
    a = LShiftByte(a, 1)
    a = a Xor b
    
    xtime = a
End Function

'*******************************************************************************
' bmul (FUNCTION)
'*******************************************************************************
Private Function bmul(ByVal X As Byte, _
                      Y As Byte) As Byte
    If X <> 0 And Y <> 0 Then
        bmul = m_ptab((CLng(m_ltab(X)) + CLng(m_ltab(Y))) Mod 255)
    Else
        bmul = 0
    End If
End Function

'*******************************************************************************
' SubByte (FUNCTION)
'*******************************************************************************
Private Function SubByte(ByVal a As Long) As Long
    Dim b(3) As Byte
    
    Unpack a, b
    b(0) = m_fbsub(b(0))
    b(1) = m_fbsub(b(1))
    b(2) = m_fbsub(b(2))
    b(3) = m_fbsub(b(3))
    
    SubByte = Pack(b)
End Function

'*******************************************************************************
' product (FUNCTION)
'*******************************************************************************
Private Function product(ByVal X As Long, _
                         ByVal Y As Long) As Long
    Dim xb(3) As Byte
    Dim yb(3) As Byte
    
    Unpack X, xb
    Unpack Y, yb
    product = bmul(xb(0), yb(0)) Xor bmul(xb(1), yb(1)) Xor bmul(xb(2), yb(2)) _
        Xor bmul(xb(3), yb(3))
End Function

'*******************************************************************************
' InvMixCol (FUNCTION)
'*******************************************************************************
Private Function InvMixCol(ByVal X As Long) As Long
    Dim Y       As Long
    Dim m       As Long
    Dim b(3)    As Byte
    
    m = Pack(m_InCo)
    b(3) = product(m, X)
    m = RotateLeft(m, 24)
    b(2) = product(m, X)
    m = RotateLeft(m, 24)
    b(1) = product(m, X)
    m = RotateLeft(m, 24)
    b(0) = product(m, X)
    Y = Pack(b)
    
    InvMixCol = Y
End Function

'*******************************************************************************
' ByteSub (FUNCTION)
'*******************************************************************************
Private Function ByteSub(ByVal X As Byte) As Byte
    Dim Y As Byte
    
    Y = m_ptab(255 - m_ltab(X))
    X = Y
    X = RotateLeftByte(X, 1)
    Y = Y Xor X
    X = RotateLeftByte(X, 1)
    Y = Y Xor X
    X = RotateLeftByte(X, 1)
    Y = Y Xor X
    X = RotateLeftByte(X, 1)
    Y = Y Xor X
    Y = Y Xor &H63
    
    ByteSub = Y
End Function

'*******************************************************************************
' gentables (SUB)
'*******************************************************************************
Public Sub gentables()
    Dim i       As Long
    Dim Y       As Byte
    Dim b(3)    As Byte
    Dim ib      As Byte
    
    m_ltab(0) = 0
    m_ptab(0) = 1
    m_ltab(1) = 0
    m_ptab(1) = 3
    m_ltab(3) = 1
    
    For i = 2 To 255
        m_ptab(i) = m_ptab(i - 1) Xor xtime(m_ptab(i - 1))
        m_ltab(m_ptab(i)) = i
    Next
    
    m_fbsub(0) = &H63
    m_rbsub(&H63) = 0
    
    For i = 1 To 255
        ib = i
        Y = ByteSub(ib)
        m_fbsub(i) = Y
        m_rbsub(Y) = i
    Next
    
        Y = 1
    For i = 0 To 29
        m_rco(i) = Y
        Y = xtime(Y)
    Next
    
    For i = 0 To 255
        Y = m_fbsub(i)
        b(3) = Y Xor xtime(Y)
        b(2) = Y
        b(1) = Y
        b(0) = xtime(Y)
        m_ftable(i) = Pack(b)
        
        Y = m_rbsub(i)
        b(3) = bmul(m_InCo(0), Y)
        b(2) = bmul(m_InCo(1), Y)
        b(1) = bmul(m_InCo(2), Y)
        b(0) = bmul(m_InCo(3), Y)
        m_rtable(i) = Pack(b)
    Next
End Sub

'*******************************************************************************
' gkey (SUB)
'*******************************************************************************
Public Sub gkey(ByVal nb As Long, _
                ByVal nk As Long, _
                key() As Byte)
                
    Dim i               As Long
    Dim j               As Long
    Dim k               As Long
    Dim m               As Long
    Dim n               As Long
    Dim C1              As Long
    Dim C2              As Long
    Dim C3              As Long
    Dim CipherKey(7)    As Long
    
    m_Nb = nb
    m_Nk = nk
    
    If m_Nb >= m_Nk Then
        m_Nr = 6 + m_Nb
    Else
        m_Nr = 6 + m_Nk
    End If
    
    C1 = 1
    If m_Nb < 8 Then
        C2 = 2
        C3 = 3
    Else
        C2 = 3
        C3 = 4
    End If
    
    For j = 0 To nb - 1
        m = j * 3
        
        m_fi(m) = (j + C1) Mod nb
        m_fi(m + 1) = (j + C2) Mod nb
        m_fi(m + 2) = (j + C3) Mod nb
        m_ri(m) = (nb + j - C1) Mod nb
        m_ri(m + 1) = (nb + j - C2) Mod nb
        m_ri(m + 2) = (nb + j - C3) Mod nb
    Next
    
    n = m_Nb * (m_Nr + 1)
    
    For i = 0 To m_Nk - 1
        j = i * 4
        CipherKey(i) = PackFrom(key, j)
    Next
    
    For i = 0 To m_Nk - 1
        m_fkey(i) = CipherKey(i)
    Next
    
    j = m_Nk
    k = 0
    Do While j < n
        m_fkey(j) = m_fkey(j - m_Nk) Xor _
            SubByte(RotateLeft(m_fkey(j - 1), 24)) Xor m_rco(k)
        If m_Nk <= 6 Then
            i = 1
            Do While i < m_Nk And (i + j) < n
                m_fkey(i + j) = m_fkey(i + j - m_Nk) Xor _
                    m_fkey(i + j - 1)
                i = i + 1
            Loop
        Else
            i = 1
            Do While i < 4 And (i + j) < n
                m_fkey(i + j) = m_fkey(i + j - m_Nk) Xor _
                    m_fkey(i + j - 1)
                If j + 4 < n Then
                    m_fkey(j + 4) = m_fkey(j + 4 - m_Nk) Xor _
                        SubByte(m_fkey(j + 3))
                    i = 5
                    Do While i < m_Nk And (i + j) < n
                        m_fkey(i + j) = m_fkey(i + j - m_Nk) Xor _
                            m_fkey(i + j - 1)
                        i = i + 1
                    Loop
                End If
                i = i + 1
            Loop
        End If
        
        j = j + m_Nk
        k = k + 1
    Loop
    
    For j = 0 To m_Nb - 1
        m_rkey(j + n - nb) = m_fkey(j)
    Next
    
    i = m_Nb
    Do While i < n - m_Nb
        k = n - m_Nb - i
        For j = 0 To m_Nb - 1
            m_rkey(k + j) = InvMixCol(m_fkey(i + j))
        Next
        i = i + m_Nb
    Loop
    
    j = n - m_Nb
    Do While j < n
        m_rkey(j - n + m_Nb) = m_fkey(j)
        j = j + 1
    Loop
End Sub

'*******************************************************************************
' encrypt (SUB)
'*******************************************************************************
Public Sub ENCRYPT(buff() As Byte)
    Dim i       As Long
    Dim j       As Long
    Dim k       As Long
    Dim m       As Long
    Dim u As Integer
    Dim a(7)    As Long
    Dim b(7)    As Long
    Dim X(7)     As Long
    Dim Y(7)     As Long
    Dim t(7)     As Long
    
    For i = 0 To m_Nb - 1
        j = i * 4
        
        a(i) = PackFrom(buff, j)
        a(i) = a(i) Xor m_fkey(i)
    Next
    
    k = m_Nb
    For u = 0 To 7: X(u) = a(u): Next u
    For u = 0 To 7: Y(u) = b(u): Next u
    
    For i = 1 To m_Nr - 1
        For j = 0 To m_Nb - 1
            m = j * 3
            Y(j) = m_fkey(k) Xor m_ftable(X(j) And m_lOnBits(7)) Xor _
                RotateLeft(m_ftable(RShift(X(m_fi(m)), 8) And m_lOnBits(7)), 8) Xor _
                RotateLeft(m_ftable(RShift(X(m_fi(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
                RotateLeft(m_ftable(RShift(X(m_fi(m + 2)), 24) And m_lOnBits(7)), 24)
            k = k + 1
        Next
        For u = 0 To 7: t(u) = X(u): Next u
        For u = 0 To 7: X(u) = Y(u): Next u
        For u = 0 To 7: Y(u) = t(u): Next u

    Next
    
    For j = 0 To m_Nb - 1
        m = j * 3
        Y(j) = m_fkey(k) Xor m_fbsub(X(j) And m_lOnBits(7)) Xor _
            RotateLeft(m_fbsub(RShift(X(m_fi(m)), 8) And m_lOnBits(7)), 8) Xor _
            RotateLeft(m_fbsub(RShift(X(m_fi(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
            RotateLeft(m_fbsub(RShift(X(m_fi(m + 2)), 24) And m_lOnBits(7)), 24)
        k = k + 1
    Next
    
    For i = 0 To m_Nb - 1
        j = i * 4
        UnpackFrom Y(i), buff, j
        X(i) = 0
        Y(i) = 0
    Next
End Sub

'*******************************************************************************
' decrypt (SUB)
'*******************************************************************************
Public Sub DECRYPT(buff() As Byte)
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim m As Long
    Dim u As Integer
    Dim a(7) As Long
    Dim b(7) As Long
    Dim X(7) As Long
    Dim Y(7) As Long
    Dim t(7) As Long
    
    For i = 0 To m_Nb - 1
        j = i * 4
        a(i) = PackFrom(buff, j)
        a(i) = a(i) Xor m_rkey(i)
    Next
    
    k = m_Nb
    For u = 0 To 7: X(u) = a(u): Next u
    For u = 0 To 7: Y(u) = b(u): Next u
    
    For i = 1 To m_Nr - 1
        For j = 0 To m_Nb - 1
            m = j * 3
            Y(j) = m_rkey(k) Xor m_rtable(X(j) And m_lOnBits(7)) Xor _
                RotateLeft(m_rtable(RShift(X(m_ri(m)), 8) And m_lOnBits(7)), 8) Xor _
                RotateLeft(m_rtable(RShift(X(m_ri(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
                RotateLeft(m_rtable(RShift(X(m_ri(m + 2)), 24) And m_lOnBits(7)), 24)
            k = k + 1
        Next
        For u = 0 To 7: t(u) = X(u): Next u
        For u = 0 To 7: X(u) = Y(u): Next u
        For u = 0 To 7: Y(u) = t(u): Next u
    Next
    
    For j = 0 To m_Nb - 1
        m = j * 3
        
        Y(j) = m_rkey(k) Xor m_rbsub(X(j) And m_lOnBits(7)) Xor _
            RotateLeft(m_rbsub(RShift(X(m_ri(m)), 8) And m_lOnBits(7)), 8) Xor _
            RotateLeft(m_rbsub(RShift(X(m_ri(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
            RotateLeft(m_rbsub(RShift(X(m_ri(m + 2)), 24) And m_lOnBits(7)), 24)
        k = k + 1
    Next
    
    For i = 0 To m_Nb - 1
        j = i * 4
        
        UnpackFrom Y(i), buff, j
        X(i) = 0
        Y(i) = 0
    Next
End Sub


Attribute VB_Name = "clsws_Qvidian"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Dimensioning private class variables.
Private Const c_WSDL_URL As String = "http://localhost/Qvidian/Qvidian.asmx"
Private Const c_SERVICE As String = "Qvidian"
Private Const c_PORT As String = "QvidianSoap"
Private Const c_SERVICE_NAMESPACE As String = "http://qvidian.com/webservices/"
Private Const intAuthToken As String = "641YPpW6lAaidjn0dPS0nhYcRLCKVwPDc4EK5wWZFNg="

Private mAuthToken As String
Private mIsConnected As Boolean
Private mBasePortalURL As String
Private mPortalURL As String
Private mURL As String
Private mBaseURL As String
Private mFaultCode As String
Private mFaultString As String

Public ErrorCode As Long
Public ErrorMessage As String
Public ErrorSource As String
Public ErrorType As String

Private xmlResponse As DOMDocument

Private Sub Class_Initialize()
    mURL = c_WSDL_URL
    mPortalURL = c_WSDL_URL
    mAuthToken = ""
    mIsConnected = False
End Sub

Public Sub PortalURL(url As String)
    mBasePortalURL = url
    If Right(url, 1) <> "/" Then
        mBasePortalURL = url & "/"
    Else
        mBasePortalURL = url
    End If
    mPortalURL = mBasePortalURL & "Qvidian.asmx"
    DebugMsgBox "Set mBasePortalURL to [" & mBasePortalURL & "]", "PortalURL:"
    DebugMsgBox "Set mPortalURL to [" & mPortalURL & "]", "PortalURL:"
End Sub

Public Sub ConnectToURL(url As String)
    mBaseURL = url
    mURL = url & "Qvidian.asmx"
End Sub

Public Function IsConnected() As Boolean
    IsConnected = mIsConnected
End Function

Public Function GetPortalPage() As String
    GetPortalPage = mBasePortalURL & "Default.aspx"
End Function

Public Function GetHomeAddress(isPS As Boolean) As String
    If isPS Then
        GetHomeAddress = mBaseURL & "ProSearch/Default.aspx"
    Else
        GetHomeAddress = mBaseURL & "Default.aspx"
    End If
End Function

Public Function GetDialogAddress(mode As DialogModes) As String
Dim subPage As String
    Select Case mode
        Case DialogModes.EmailDialog
            subPage = "Dialogs/EmailExternal.aspx?"
        Case DialogModes.SubmitDialog
            subPage = "Dialogs/Submit.aspx?"
        Case DialogModes.BulkLoadDialog
            subPage = "Dialogs/Submit.aspx?IsBulkLoad=1"
        Case DialogModes.WordTemplatesDialog
            subPage = "Common/Dialogs.aspx?type=1"
        Case DialogModes.PowerPointTemplatesDialog
            subPage = "Common/Dialogs.aspx?type=2"
        Case Else
            subPage = "Common/Dialogs.aspx?"
    End Select
    GetDialogAddress = mBaseURL & subPage
End Function

Public Function GetServerName() As String
    On Error Resume Next
    Dim serverValue As String
    serverValue = mBaseURL
    
    If serverValue = "" Then
        GetServerName = ""
        Exit Function
    End If
    
    ' Clean it up.
'    serverValue = Replace(serverValue, "http://", "")
'    serverValue = Replace(serverValue, "https://", "")
'    serverValue = Replace(serverValue, ":", "")
'    serverValue = Replace(serverValue, "/", "")
    DebugMsgBox "GetServerName = [" & serverValue & "]", "GetServerName:"
    GetServerName = serverValue
End Function

Private Sub Class_Terminate()
    '*****************************************************************
    'This subroutine will be called each time the class is destructed.
    'Sets sc_ComplexTypes to Nothing.
    '*****************************************************************

    'Error Trap
    On Error GoTo Class_TerminateTrap
    wsm_ConnectionTerminate
    Exit Sub

Class_TerminateTrap:
    QvidianErrorHandler ("Class_Terminate")
End Sub

Public Function wsm_Connect(ByVal str_userName As String, ByVal str_password As String, ByVal bln_qpaLogin As Boolean, _
                            bln_wsLogin As Boolean) As struct_ConnectInfo
Dim objNodeList As IXMLDOMNodeList

    'Error Trap
    On Error GoTo wsm_ConnectTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><Connect xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<userName/>"
    soapMsg = soapMsg & "<password/>"
    soapMsg = soapMsg & "<qpaLogin/>"
    soapMsg = soapMsg & "<wsLogin/>"
    soapMsg = soapMsg & "</Connect></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg

    setXMLValue xml, "userName", str_userName
    setXMLValue xml, "password", str_password
    setXMLValue xml, "qpaLogin", IIf(bln_qpaLogin, 1, 0)
    setXMLValue xml, "wsLogin", IIf(bln_wsLogin, 1, 0)
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "Connect", True
    
    Set wsm_Connect = New struct_ConnectInfo
    
    Set objNodeList = xmlResponse.getElementsByTagName("ConnectResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        Set objNodeList = xmlResponse.getElementsByTagName("AuthToken")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.authToken = objNodeList(0).Text
            mAuthToken = wsm_Connect.authToken
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ServerURL")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ServerURL = objNodeList(0).Text
            ConnectToURL (wsm_Connect.ServerURL)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("RequiredVersion")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.RequiredVersion = CLng(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ProductFileVersion")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ProductFileVersion = objNodeList(0).Text
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ProductMinorVersion")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ProductMinorVersion = objNodeList(0).Text
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ClearPropsOnMultiSave")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ClearPropsOnMultiSave = CBool(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ClearCustomPropsOnMultiSave")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ClearCustomPropsOnMultiSave = CBool(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ClearPropsOnSingleSave")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ClearPropsOnSingleSave = CBool(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("ClearCustomPropsOnSingleSave")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.ClearCustomPropsOnSingleSave = CBool(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("LibraryRunning")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.LibraryRunning = CBool(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("MaxFileLength")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_Connect.MaxFileLength = CLng(objNodeList(0).Text)
        End If
        Set objNodeList = xmlResponse.getElementsByTagName("SMEExportMode")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            DebugMsgBox "SMEExportMode: [" & objNodeList(0).Text & "]", "wsm_Connect"
            setRegUserDword "HKEY_CURRENT_USER\Software\Qvidian\SMEExportMode", CLng(objNodeList(0).Text)
        End If
        
        mIsConnected = True
    Else
        QvidianErrorHandler "wsm_Connect"
    End If
    
Exit Function
wsm_ConnectTrap:
    QvidianErrorHandler "wsm_Connect"
End Function

Public Sub wsm_ConnectionTerminate()
Dim objNodeList As IXMLDOMNodeList

    'Error Trap
    On Error GoTo wsm_ConnectionTerminateTrap

    If mIsConnected Then
        DebugMsgBox "mAuthToken is [" & mAuthToken & "]", "wsm_ConnectionTerminate:"
        ' Create the SOAP string....
        Dim soapMsg As String
        
        ' Add the header...
        soapMsg = soapMsg & addSOAPHeader
        soapMsg = soapMsg & "<soap:Body><ConnectionTerminate xmlns=""http://qvidian.com/webservices/""/>"
        soapMsg = soapMsg & "</soap:Body>"
        soapMsg = soapMsg & "</soap:Envelope>"
    
        ' Execute the call and work out if there are errors. If there are, an exception is thrown
        executeMessage soapMsg, "ConnectionTerminate"
    
        mAuthToken = ""
        mIsConnected = False
    End If
Exit Sub
wsm_ConnectionTerminateTrap:
    mAuthToken = ""
    mIsConnected = False
    QvidianErrorHandler "wsm_ConnectionTerminate"
End Sub

Public Function wsm_UpdateContentDetails(ByVal str_contentIDs As String, ByVal content As struct_Content) As String ' struct_Content()
    'Error Trap
    On Error GoTo wsm_UpdateContentDetailsTrap

    ' Create the SOAP string....
    Dim soapMsg As String
    
    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><UpdateContentDetails xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<contentIDs/>"
    soapMsg = soapMsg & "<contentChanges>"
    soapMsg = soapMsg & "<AlertEnabled>false</AlertEnabled>"
    soapMsg = soapMsg & "<AlertEnabledUpdated>false</AlertEnabledUpdated>"
    soapMsg = soapMsg & "<AlertText/>"
    soapMsg = soapMsg & "<AlertTextUpdated>false</AlertTextUpdated>"
    soapMsg = soapMsg & "<Comments/>"
    soapMsg = soapMsg & "<CommentsUpdated>false</CommentsUpdated>"
    soapMsg = soapMsg & "<ContactInfo/>"
    soapMsg = soapMsg & "<ContactInfoUpdated>false</ContactInfoUpdated>"
    soapMsg = soapMsg & "<ContentText/>"
    soapMsg = soapMsg & "<ContentTextUpdated>false</ContentTextUpdated>"
    soapMsg = soapMsg & "<DateToExpire/>"
    soapMsg = soapMsg & "<DateToExpireUpdated>false</DateToExpireUpdated>"
    soapMsg = soapMsg & "<Enabled>false</Enabled>"
    soapMsg = soapMsg & "<EnabledUpdated>false</EnabledUpdated>"
    soapMsg = soapMsg & "<Title/>"
    soapMsg = soapMsg & "<TitleUpdated>false</TitleUpdated>"
    soapMsg = soapMsg & "</contentChanges>"
    soapMsg = soapMsg & "<cmdChanges>"
    soapMsg = soapMsg & "</cmdChanges>"
    soapMsg = soapMsg & "</UpdateContentDetails></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "contentIDs", str_contentIDs
    
    If content.ChangedTitle Then
        setXMLValue xml, "Title", content.UpdatedTitle
        setXMLValue xml, "TitleUpdated", "true"
    End If
    
    If content.ChangedComments Then
        setXMLValue xml, "Comments", content.UpdatedComments
        setXMLValue xml, "CommentsUpdated", "true"
    End If
    
    If content.ChangedContactInfo Then
        setXMLValue xml, "ContactInfo", content.UpdatedContactInfo
        setXMLValue xml, "ContactInfoUpdated", "true"
    End If
    
    If content.ChangedAlertText Then
        setXMLValue xml, "AlertText", content.UpdatedAlertText
        setXMLValue xml, "AlertTextUpdated", "true"
    End If
    
    If content.ChangedAlertEnabled Then
        setXMLValue xml, "AlertEnabled", StrConv(content.UpdatedAlertEnabled, vbLowerCase)
        setXMLValue xml, "AlertEnabledUpdated", "true"
    End If
    
    If content.ChangedDateToExpire Then
        If content.UpdatedDateToExpireSet Then
            setXMLValue xml, "DateToExpire", format(ConvertLocalToUTC(content.UpdatedDateToExpire), "yyyy/mm/dd ttttt")
        End If
        setXMLValue xml, "DateToExpireUpdated", "true"
    End If
    'xml.Save "c:\soap3.xml"
    
    ' Now lets add the Custom meta-data...
    If content.cmdValues.count > 0 Then
        Dim cmdItem As struct_CMD
        Dim cmdNodes As IXMLDOMNode
        Set cmdNodes = xml.SelectSingleNode("//UpdateContentDetails/cmdChanges")
        Dim idx As Integer
        For idx = 0 To content.cmdValues.count - 1
            Set cmdItem = content.cmdValues.Items(idx)
            If cmdItem.ChangedValue Then
                Dim cmdNode As IXMLDOMNode
                Set cmdNode = xml.createNode(1, "CustomMetadataUpdate", "http://qvidian.com/webservices/")
                
                Dim cmID As IXMLDOMNode
                Set cmID = xml.createNode(1, "CMID", "http://qvidian.com/webservices/")
                cmID.nodeTypedValue = cmdItem.cmID
                cmdNode.appendChild cmID
               
                Dim cmDataType As IXMLDOMNode
                Set cmDataType = xml.createNode(1, "DataType", "http://qvidian.com/webservices/")
                cmDataType.nodeTypedValue = cmdItem.DataType
                cmdNode.appendChild cmDataType

                Dim cmUpdatedValue As IXMLDOMNode
                Set cmUpdatedValue = xml.createNode(1, "UpdatedValue", "http://qvidian.com/webservices/")
                If cmdItem.DataType = CMDataTypes.DateType Then
                    If cmdItem.UpdatedValue = "" Then
                        cmUpdatedValue.nodeTypedValue = ""
                    Else
                        cmUpdatedValue.nodeTypedValue = format(ConvertLocalToUTC(cmdItem.UpdatedValue), "yyyy/mm/dd ttttt")
                    End If
                Else
                    cmUpdatedValue.nodeTypedValue = cmdItem.UpdatedValue
                End If
                cmdNode.appendChild cmUpdatedValue
               
                cmdNodes.appendChild cmdNode
            End If
        Next
    End If
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "UpdateContentDetails"
    
    'Dim retRecs As struct_Content
    wsm_UpdateContentDetails = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("UpdateContentDetailsResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_UpdateContentDetails = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_UpdateContentDetails"
    End If

Exit Function
wsm_UpdateContentDetailsTrap:
    QvidianErrorHandler "wsm_UpdateContentDetails"
End Function

Public Function wsm_UploadFile(ByVal obj_uploadParams As struct_UploadParams, ByVal str_fileName As String, _
                               ByRef arrFile() As Byte) As String
    'Error Trap
    On Error GoTo wsm_UploadFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><UploadFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<uploadParams>"
    soapMsg = soapMsg & "<AddCRMNote/>"
    soapMsg = soapMsg & "<ContentMetadataSettings/>"
    soapMsg = soapMsg & "<SantTemplateMode/>"
    soapMsg = soapMsg & "<TemplateMode/>"
    soapMsg = soapMsg & "<contentID/>"
    soapMsg = soapMsg & "<CRMNoteText/>"
    soapMsg = soapMsg & "<miscFileID/>"
    soapMsg = soapMsg & "<projectID/>"
    soapMsg = soapMsg & "<rfpFileID/>"
    soapMsg = soapMsg & "<compareContentID/>"
    soapMsg = soapMsg & "<first/>"
    soapMsg = soapMsg & "<tempDir/>"
    soapMsg = soapMsg & "<title/>"
    soapMsg = soapMsg & "<cText/>"
    soapMsg = soapMsg & "<JobID/>"
    soapMsg = soapMsg & "</uploadParams>"
    soapMsg = soapMsg & "<fileName/>"
    soapMsg = soapMsg & "<file/>"
    soapMsg = soapMsg & "</UploadFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "AddCRMNote", IIf(obj_uploadParams.AddCRMNote, "true", "false")
    setXMLValue xml, "ContentMetadataSettings", obj_uploadParams.ContentMetadataSettings
    setXMLValue xml, "SantTemplateMode", obj_uploadParams.SantTemplateMode
    setXMLValue xml, "TemplateMode", obj_uploadParams.TemplateMode
    setXMLValue xml, "contentID", obj_uploadParams.contentID
    setXMLValue xml, "CRMNoteText", obj_uploadParams.CRMNoteText
    setXMLValue xml, "miscFileID", obj_uploadParams.miscFileID
    setXMLValue xml, "projectID", obj_uploadParams.projectID
    setXMLValue xml, "rfpFileID", obj_uploadParams.rfpFileID
    setXMLValue xml, "compareContentID", obj_uploadParams.compareContentID
    setXMLValue xml, "JobID", obj_uploadParams.JobID
    
    If (InStr(LCase(Application.name), "powerpoint") > 0) Then
        setXMLValue xml, "first", IIf(obj_uploadParams.first, "true", "false")
        setXMLValue xml, "tempDir", obj_uploadParams.tempDir
        setXMLValue xml, "title", EncodeBase64(StrConv(obj_uploadParams.title, vbFromUnicode))
        setXMLValue xml, "cText", EncodeBase64(StrConv(obj_uploadParams.cText, vbFromUnicode))
    Else
        setXMLValue xml, "first", "false"
    End If

    setXMLValue xml, "fileName", str_fileName
    setXMLValue xml, "file", arrFile, "bin.base64"
    
'    xml.Save "c:\soap3.xml"
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "UploadFile"
    
    wsm_UploadFile = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("UploadFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_UploadFile = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_UploadFile"
    End If

Exit Function
wsm_UploadFileTrap:
    QvidianErrorHandler "wsm_UploadFile"
End Function

Public Function wsm_UploadFileChunk(ByVal obj_uploadParams As struct_UploadParams, ByVal str_fileName As String, _
                               ByVal fileName) As String
    'Error Trap
    On Error GoTo wsm_UploadFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><UploadFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<uploadParams>"
    soapMsg = soapMsg & "<AddCRMNote/>"
    soapMsg = soapMsg & "<ContentMetadataSettings/>"
    soapMsg = soapMsg & "<SantTemplateMode/>"
    soapMsg = soapMsg & "<TemplateMode/>"
    soapMsg = soapMsg & "<contentID/>"
    soapMsg = soapMsg & "<CRMNoteText/>"
    soapMsg = soapMsg & "<miscFileID/>"
    soapMsg = soapMsg & "<projectID/>"
    soapMsg = soapMsg & "<rfpFileID/>"
    soapMsg = soapMsg & "<compareContentID/>"
    soapMsg = soapMsg & "<first/>"
    soapMsg = soapMsg & "<tempDir/>"
    soapMsg = soapMsg & "<title/>"
    soapMsg = soapMsg & "<cText/>"
    soapMsg = soapMsg & "<chunk/>"
    soapMsg = soapMsg & "<complete/>"
    soapMsg = soapMsg & "<isSMEJob/>"
    soapMsg = soapMsg & "<JobID/>"
    soapMsg = soapMsg & "</uploadParams>"
    soapMsg = soapMsg & "<fileName/>"
    soapMsg = soapMsg & "<file/>"
    soapMsg = soapMsg & "</UploadFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "AddCRMNote", IIf(obj_uploadParams.AddCRMNote, "true", "false")
    setXMLValue xml, "ContentMetadataSettings", obj_uploadParams.ContentMetadataSettings
    setXMLValue xml, "SantTemplateMode", obj_uploadParams.SantTemplateMode
    setXMLValue xml, "TemplateMode", obj_uploadParams.TemplateMode
    setXMLValue xml, "contentID", obj_uploadParams.contentID
    setXMLValue xml, "CRMNoteText", obj_uploadParams.CRMNoteText
    setXMLValue xml, "miscFileID", obj_uploadParams.miscFileID
    setXMLValue xml, "projectID", obj_uploadParams.projectID
    setXMLValue xml, "rfpFileID", obj_uploadParams.rfpFileID
    setXMLValue xml, "compareContentID", obj_uploadParams.compareContentID
    setXMLValue xml, "isSMEJob", IIf(obj_uploadParams.isSMEJob, "true", "false")
    setXMLValue xml, "JobID", obj_uploadParams.JobID
    
    If (InStr(LCase(Application.name), "powerpoint") > 0) Then
        setXMLValue xml, "first", IIf(obj_uploadParams.first, "true", "false")
        setXMLValue xml, "tempDir", obj_uploadParams.tempDir
        setXMLValue xml, "title", EncodeBase64(StrConv(obj_uploadParams.title, vbFromUnicode))
        setXMLValue xml, "cText", EncodeBase64(StrConv(obj_uploadParams.cText, vbFromUnicode))
    Else
        setXMLValue xml, "first", "false"
    End If

    setXMLValue xml, "fileName", str_fileName
    
    'Const maxTransferSize As Long = 1024
    Const maxTransferSize As Long = 1048576
    Dim FileContents() As Byte
    Dim totalLength As Long
    Dim bufferSize As Long
    Dim FileNumber As Integer
    
    totalLength = FileLen(fileName)
    FileNumber = FreeFile
    
    Open fileName For Binary As FileNumber
    Dim iChunk As Integer
    iChunk = 1
    Dim bComplete As Boolean
    bComplete = False
    setXMLValue xml, "complete", "false"
    Dim bytesToRead As Long
    
    ReDim FileContents(maxTransferSize)
    
    DebugMsgBox "totalLength: " & Str(totalLength) & " and maxTransferSize: " & Str(maxTransferSize), "UploadFileChunk:"
    
    While (Not EOF(FileNumber)) And (totalLength > Seek(FileNumber))
        DebugMsgBox "Seek: " & Str(Seek(FileNumber)), "UploadFileChunk:"
        
        If totalLength < Seek(FileNumber) + maxTransferSize Then
            bytesToRead = totalLength - Seek(FileNumber)
            DebugMsgBox "Redimming: bytesToRead: " & Str(bytesToRead), "UploadFileChunk:"
            ReDim FileContents(bytesToRead)
        Else
            bytesToRead = maxTransferSize
        End If
        
        Get FileNumber, , FileContents
        DebugMsgBox "bytesRead: " & Str(bytesToRead), "UploadFileChunk:"
        
        setXMLValue xml, "file", FileContents, "bin.base64"
        setXMLValue xml, "chunk", iChunk
        
        If EOF(FileNumber) Or Seek(FileNumber) > totalLength Then
            setXMLValue xml, "complete", "true"
            bComplete = True
        End If
        DebugMsgBox "chunk: " & Str(iChunk) & " complete: " & bComplete, "UploadFileChunk:"
        executeMessage xml, "UploadFile"
    
        wsm_UploadFileChunk = ""
    
        Dim objNodeList As IXMLDOMNodeList
        Set objNodeList = xmlResponse.getElementsByTagName("UploadFileResult")
        If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
            wsm_UploadFileChunk = objNodeList(0).Text
        Else
            QvidianErrorHandler "wsm_UploadFileChunk"
        End If
        iChunk = iChunk + 1
    Wend
    Close (FileNumber)
    
Exit Function
wsm_UploadFileTrap:
    QvidianErrorHandler "wsm_UploadFileChunk"
End Function

Private Sub setXMLValue(ByRef xmlDoc As DOMDocument, ByVal tagName As String, ByVal newValue As Variant, Optional ByVal theDataType As String = "")
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlDoc.getElementsByTagName(tagName)
    If objNodeList.Length = 0 Then
        Err.Raise 10777, "setXMLValue", "XML Node not found"
        Exit Sub
    End If
    Dim objNode As MSXML2.IXMLDOMElement
    Set objNode = objNodeList(0)
    If Len(theDataType) > 0 Then
        objNode.DataType = theDataType
    End If
    objNode.nodeTypedValue = newValue
End Sub

Public Function wsm_EvaluateFormula(ByVal str_val As String) As String

    'Error Trap
    On Error GoTo wsm_EvaluateFormulaTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><EvaluateFormula xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<val/>"
    soapMsg = soapMsg & "</EvaluateFormula></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "val", str_val

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "EvaluateFormula"
    
    wsm_EvaluateFormula = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("EvaluateFormulaResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_EvaluateFormula = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_EvaluateFormula"
    End If
    
Exit Function
wsm_EvaluateFormulaTrap:
    QvidianErrorHandler "wsm_EvaluateFormula"
End Function

Public Function wsm_GetGlobalSetting(ByVal str_name As String) As String

    'Error Trap
    On Error GoTo wsm_GetGlobalSettingTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetGlobalSetting xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<settingName/>"
    soapMsg = soapMsg & "</GetGlobalSetting></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "settingName", str_name

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetGlobalSetting"
    
    wsm_GetGlobalSetting = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetGlobalSettingResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetGlobalSetting = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_GetGlobalSetting"
    End If
    
Exit Function
wsm_GetGlobalSettingTrap:
    QvidianErrorHandler "wsm_GetGlobalSetting"
End Function

Public Function wsm_GetBuildFile(ByVal lng_projectID As Long, bln_replaceMergeCodes As Boolean, _
                                 ByVal bln_printAllSelections As Boolean) As Byte()
    'Error Trap
    On Error GoTo wsm_GetBuildFileTrap
    
    Dim isPPT As Boolean
    
    isPPT = (InStr(LCase(Application.name), "powerpoint") > 0)

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetBuildFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<projectID/>"
    soapMsg = soapMsg & "<replaceMergeCodes/>"
    soapMsg = soapMsg & "<printAllSelections/>"
    soapMsg = soapMsg & "<isPPT/>"
    soapMsg = soapMsg & "</GetBuildFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "projectID", lng_projectID
    setXMLValue xml, "replaceMergeCodes", IIf(bln_replaceMergeCodes, 1, 0)
    setXMLValue xml, "printAllSelections", IIf(bln_printAllSelections, 1, 0)
    setXMLValue xml, "isPPT", IIf(isPPT, 1, 0)
    
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetBuildFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetBuildFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetBuildFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetBuildFile"
    End If

Exit Function
wsm_GetBuildFileTrap:
    QvidianErrorHandler "wsm_GetBuildFile"
End Function

Public Function wsm_GetContentFile(ByVal lng_contentID As Long, ByVal lng_contentRevision As Long, ByVal bln_office2007 As Boolean, Optional str_JobID As String = "") As Byte()
    'Error Trap
    On Error GoTo wsm_GetContentFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetContentFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<contentID/>"
    soapMsg = soapMsg & "<contentRevision/>"
    soapMsg = soapMsg & "<office2007/>"
    soapMsg = soapMsg & "<smejobid/>"
    soapMsg = soapMsg & "</GetContentFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "contentID", lng_contentID
    setXMLValue xml, "contentRevision", lng_contentRevision
    setXMLValue xml, "office2007", IIf(bln_office2007, 1, 0)
    setXMLValue xml, "smejobid", str_JobID 'Will be GUID when multiedit is on SME job, will be empty string otherwise.
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetContentFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetContentFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetContentFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetContentFile"
    End If

Exit Function
wsm_GetContentFileTrap:
    QvidianErrorHandler "wsm_GetContentFile"
End Function

Public Function wsm_GetContentFileForEdit(ByVal lng_contentID As Long, ByVal lng_contentRevision As Long) As Byte()
    'Error Trap
    On Error GoTo wsm_GetContentFileForEditTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetContentFileForEdit xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<contentID/>"
    soapMsg = soapMsg & "<contentRevision/>"
    soapMsg = soapMsg & "</GetContentFileForEdit></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "contentID", lng_contentID
    setXMLValue xml, "contentRevision", lng_contentRevision
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetContentFileForEdit"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetContentFileForEditResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetContentFileForEdit = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetContentFileForEdit"
    End If

Exit Function
wsm_GetContentFileForEditTrap:
    QvidianErrorHandler "wsm_GetContentFileForEdit"
End Function

Public Function wsm_GetContentFileByGUID(ByVal str_guid As String) As String
    'Error Trap
    On Error GoTo wsm_GetContentFileByGUIDTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetContentFileByGUID xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<guid/>"
    soapMsg = soapMsg & "</GetContentFileByGUID></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "guid", str_guid

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetContentFileByGUID"
    
    wsm_GetContentFileByGUID = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetContentFileByGUIDResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetContentFileByGUID = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_GetContentFileByGUID"
    End If

Exit Function
wsm_GetContentFileByGUIDTrap:
    QvidianErrorHandler "wsm_GetContentFileByGUID"
End Function

Public Function wsm_GetExportFile(ByVal str_contentIDs As String) As Byte()
    'Error Trap
    On Error GoTo wsm_GetExportFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetExportFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<contentIDs/>"
    soapMsg = soapMsg & "</GetExportFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "contentIDs", str_contentIDs
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetExportFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetExportFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetExportFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetExportFile"
    End If

Exit Function
wsm_GetExportFileTrap:
    QvidianErrorHandler "wsm_GetExportFile"
End Function

Public Function wsm_GetFormattedValue(ByVal str_val As String, ByVal str_format As String, ByVal str_culture As String, ByVal str_additionalInfo As String) As String

    'Error Trap
    On Error GoTo wsm_GetFormattedValueTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetFormattedValue xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<val/>"
    soapMsg = soapMsg & "<format/>"
    soapMsg = soapMsg & "<culture/>"
    soapMsg = soapMsg & "<additionalInfo/>"
    soapMsg = soapMsg & "</GetFormattedValue></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "val", str_val
    setXMLValue xml, "format", str_format
    setXMLValue xml, "culture", str_culture
    setXMLValue xml, "additionalInfo", str_additionalInfo
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetFormattedValue"
    
    wsm_GetFormattedValue = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetFormattedValueResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetFormattedValue = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_GetFormattedValue"
    End If
    
Exit Function
wsm_GetFormattedValueTrap:
    QvidianErrorHandler "wsm_GetFormattedValue"
End Function

Public Function wsm_GetJobFile(ByVal str_JobFile As String) As Byte()
    'Error Trap
    On Error GoTo wsm_GetJobFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetJobFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<JobFileID/>"
    soapMsg = soapMsg & "</GetJobFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "JobFileID", str_JobFile
   
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetJobFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetJobFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetJobFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetJobFile"
    End If

Exit Function
wsm_GetJobFileTrap:
    QvidianErrorHandler "wsm_GetJobFile"
End Function

Public Function wsm_GetMiscFile(ByVal lng_miscFileID As Long) As Byte()
    'Error Trap
    On Error GoTo wsm_GetMiscFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetMiscFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<miscFileID/>"
    soapMsg = soapMsg & "</GetMiscFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "miscFileID", lng_miscFileID
   
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetMiscFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetMiscFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetMiscFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetMiscFile"
    End If

Exit Function
wsm_GetMiscFileTrap:
    QvidianErrorHandler "wsm_GetMiscFile"
End Function

Public Function wsm_GetStyleTemplateFile(ByVal lng_templateID As Long) As Byte()
    'Error Trap
    On Error GoTo wsm_GetStyleTemplateFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetStyleTemplateFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<templateID/>"
    soapMsg = soapMsg & "</GetStyleTemplateFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "templateID", lng_templateID
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "GetStyleTemplateFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetStyleTemplateFileResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetStyleTemplateFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetStyleTemplateFile"
    End If

Exit Function
wsm_GetStyleTemplateFileTrap:
    QvidianErrorHandler "wsm_GetStyleTemplateFile"
End Function

Public Function wsm_CancelContentCheckout(ByVal str_contentIDs As String) As Boolean
    'Error Trap
    On Error GoTo wsm_CancelContentCheckoutTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><CancelContentCheckout xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<contentIDs/>"
    soapMsg = soapMsg & "</CancelContentCheckout></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "contentIDs", str_contentIDs

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "CancelContentCheckout"
    
    wsm_CancelContentCheckout = False
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("CancelContentCheckoutResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_CancelContentCheckout = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_CancelContentCheckout"
    End If

Exit Function
wsm_CancelContentCheckoutTrap:
    QvidianErrorHandler "wsm_CancelContentCheckout"
End Function

Public Function wsm_CancelCompositeContentCheckout(ByVal str_JobID As String) As Boolean
    'Error Trap
    On Error GoTo wsm_CancelCompositeContentCheckoutTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><CancelCompositeContentCheckout xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<JobID/>"
    soapMsg = soapMsg & "</CancelCompositeContentCheckout></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "JobID", str_JobID

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "CancelCompositeContentCheckout"
    
    wsm_CancelCompositeContentCheckout = False
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("CancelCompositeContentCheckoutResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        DebugMsgBox "objNodeList(0).Text = [" & objNodeList(0).Text & "]", "wsm_CancelCompositeContentCheckout"
        wsm_CancelCompositeContentCheckout = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_CancelCompositeContentCheckout"
    End If

Exit Function
wsm_CancelCompositeContentCheckoutTrap:
    QvidianErrorHandler "wsm_CancelCompositeContentCheckout"
End Function

Public Function wsm_CancelFileListCheckout(ByVal lng_miscFileID As Long) As Boolean
    'Error Trap
    On Error GoTo wsm_CancelFileListCheckoutTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><CancelFileListCheckout xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<miscFileID/>"
    soapMsg = soapMsg & "</CancelFileListCheckout></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "miscFileID", lng_miscFileID

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "CancelFileListCheckout"
    
    wsm_CancelFileListCheckout = False
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("CancelFileListCheckoutResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_CancelFileListCheckout = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_CancelFileListCheckout"
    End If

Exit Function
wsm_CancelFileListCheckoutTrap:
    QvidianErrorHandler "wsm_CancelFileListCheckout"
End Function

Public Function wsm_CancelRFPCheckout(ByVal lng_rfpFileID As Long, ByVal str_mappingInfo As String) As Boolean
    'Error Trap
    On Error GoTo wsm_CancelRFPCheckoutTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><CancelRFPCheckout xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<rfpFileID/>"
    soapMsg = soapMsg & "<mappingInfo/>"
    soapMsg = soapMsg & "</CancelRFPCheckout></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "rfpFileID", lng_rfpFileID
    setXMLValue xml, "mappingInfo", str_mappingInfo

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "CancelRFPCheckout"
    
    wsm_CancelRFPCheckout = False
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("CancelRFPCheckoutResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_CancelRFPCheckout = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_CancelRFPCheckout"
    End If

Exit Function
wsm_CancelRFPCheckoutTrap:
    QvidianErrorHandler "wsm_CancelRFPCheckout"
End Function

Public Function wsm_GetDialogStatus() As String
    'Error Trap
    On Error GoTo wsm_GetDialogStatusTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetDialogStatus xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "</GetDialogStatus></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage soapMsg, "GetDialogStatus"
    
    wsm_GetDialogStatus = "Open"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetDialogStatusResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetDialogStatus = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_GetDialogStatus"
    End If

Exit Function
wsm_GetDialogStatusTrap:
    QvidianErrorHandler "wsm_GetDialogStatus"
End Function

Public Function wsm_GetDialogResults() As String
    'Error Trap
    On Error GoTo wsm_GetDialogResultsTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetDialogResults xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "</GetDialogResults></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage soapMsg, "GetDialogResults"
    
    wsm_GetDialogResults = ""
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetDialogResultsResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetDialogResults = objNodeList(0).Text
    Else
        QvidianErrorHandler "wsm_GetDialogResults"
    End If

Exit Function
wsm_GetDialogResultsTrap:
    QvidianErrorHandler "wsm_GetDialogResults"
End Function

Public Function wsm_RemoveSearchParams() As Boolean
    ' Error Trap
    On Error GoTo wsm_RemoveSearchParamsTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><RemoveSearchParams xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "</RemoveSearchParams></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
'    xml.Save "c:\soap3.xml"
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "RemoveSearchParams"
    
    wsm_RemoveSearchParams = False
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("RemoveSearchParamsResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_RemoveSearchParams = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_RemoveSearchParams"
    End If

Exit Function
wsm_RemoveSearchParamsTrap:
    QvidianErrorHandler "wsm_RemoveSearchParams"
End Function

Public Function wsm_SaveSearchParams(ByVal obj_searchParams As structSearchParams) As Boolean
    ' Error Trap
    On Error GoTo wsm_SaveSearchParamsTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><SaveSearchParams xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<objSearchParams>"
    soapMsg = soapMsg & "<searchMode/>"
    soapMsg = soapMsg & "<executeSearch/>"
    soapMsg = soapMsg & "<andSearch/>"
    soapMsg = soapMsg & "<orSearch/>"
    soapMsg = soapMsg & "<saveCmd/>"
    soapMsg = soapMsg & "<authToken/>"
    soapMsg = soapMsg & "</objSearchParams>"
    soapMsg = soapMsg & "</SaveSearchParams></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"

    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "executeSearch", IIf(obj_searchParams.executeSearch, "true", "false")
    setXMLValue xml, "searchMode", obj_searchParams.searchMode
    setXMLValue xml, "andSearch", obj_searchParams.andSearch
    setXMLValue xml, "orSearch", obj_searchParams.orSearch
    setXMLValue xml, "saveCmd", obj_searchParams.saveCmd
    setXMLValue xml, "authToken", obj_searchParams.authToken
    
'    xml.Save "c:\soap3.xml"
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "SaveSearchParams"
    
    wsm_SaveSearchParams = False
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("SaveSearchParamsResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_SaveSearchParams = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_SaveSearchParams"
    End If

Exit Function
wsm_SaveSearchParamsTrap:
    QvidianErrorHandler "wsm_SaveSearchParams"
End Function

Public Function wsm_GetTemplateFile(ByVal lng_templateID As Long) As Byte()
    'Error Trap
    On Error GoTo wsm_GetTemplateFileTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body><GetTemplateFile xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<templateID>"
    soapMsg = soapMsg & lng_templateID
    soapMsg = soapMsg & "</templateID>"
    soapMsg = soapMsg & "</GetTemplateFile></soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage soapMsg, "GetTemplateFile"
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("GetTemplateFileResult")
    If Not objNodeList Is Nothing Then
        wsm_GetTemplateFile = DecodeBase64(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_GetTemplateFile"
    End If

Exit Function
wsm_GetTemplateFileTrap:
    QvidianErrorHandler "wsm_GetTemplateFile"
End Function

Public Function wsm_GetSPSJobPendingState(ByVal JobID As String) As Boolean
    'Error Trap
    On Error GoTo wsm_GetDialogStatusTrap

    ' Create the SOAP string....
    Dim soapMsg As String

    ' Add the header...
    soapMsg = soapMsg & addSOAPHeader
    soapMsg = soapMsg & "<soap:Body>"
    soapMsg = soapMsg & "<getSPSJobPendingState xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<JobID/>"
    soapMsg = soapMsg & "</getSPSJobPendingState>"
    soapMsg = soapMsg & "</soap:Body>"
    soapMsg = soapMsg & "</soap:Envelope>"
    
    Dim xml As DOMDocument
    Set xml = New DOMDocument
    xml.loadXML soapMsg
    
    setXMLValue xml, "JobID", JobID

    ' Execute the call and work out if there are errors. If there are, an exception is thrown
    executeMessage xml, "getSPSJobPendingState"
    
    wsm_GetSPSJobPendingState = True
    
    Dim objNodeList As IXMLDOMNodeList
    Set objNodeList = xmlResponse.getElementsByTagName("getSPSJobPendingStateResult")
    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
        wsm_GetSPSJobPendingState = CBool(objNodeList(0).Text)
    Else
        QvidianErrorHandler "wsm_getSPSJobPendingState"
    End If

Exit Function
wsm_GetDialogStatusTrap:
    QvidianErrorHandler "wsm_GetDialogStatus"
End Function

Private Sub QvidianErrorHandler(str_Function As String)
    If ErrorType = "QvidianException" Then
        Err.Raise ErrorCode, str_Function, ErrorMessage
    ElseIf mFaultCode <> "" Then
        Err.Raise vbObjectError, str_Function, ErrorMessage
    Else
        Err.Raise Err.Number, str_Function, Err.description
    End If
End Sub

Private Function addSOAPHeader() As String
    
    'Error Trap
    On Error GoTo wsm_ConnectTrap

    ' Reset the ErrorCode
    ErrorCode = 0

    ' Create the SOAP string....
    Dim soapMsg As String
    soapMsg = "<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>"
    soapMsg = soapMsg & "<soap:Envelope xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/"">"
    soapMsg = soapMsg & "<soap:Header>"
    soapMsg = soapMsg & "<QvidianCredentialHeader xmlns=""http://qvidian.com/webservices/"">"
    soapMsg = soapMsg & "<AuthenticationToken>"
    soapMsg = soapMsg & mAuthToken
    soapMsg = soapMsg & "</AuthenticationToken>"
    soapMsg = soapMsg & "<InternalToken>"
    soapMsg = soapMsg & intAuthToken
    soapMsg = soapMsg & "</InternalToken>"
    soapMsg = soapMsg & "</QvidianCredentialHeader>"
    soapMsg = soapMsg & "</soap:Header>"

    addSOAPHeader = soapMsg
Exit Function
wsm_ConnectTrap:
    QvidianErrorHandler "addSOAPHeader"
End Function

Private Sub executeMessage(soapMsg As Variant, cmd As String, Optional login As Boolean = False)
Dim XMLHttpRequest As XMLHTTP
Set XMLHttpRequest = New MSXML2.XMLHTTP
Dim objNodeList As IXMLDOMNodeList
Dim objDataNode As IXMLDOMNode
Dim connectURL As String

    On Error Resume Next
    If login Then
        connectURL = mPortalURL
    Else
        connectURL = mURL
    End If
    DebugMsgBox "connectURL is [" & connectURL & "] for cmd [" & cmd & "]", "executeMessage:"
    
    Dim retryCount As Integer
    retryCount = 0
    
    'retry up to 10 times
    Do While (retryCount < 10)
        With XMLHttpRequest
            .Open "POST", connectURL & "?Timestamp=" & Strings.format(Now, "yyyy_mm_dd_HH_nn_ss") & "." & Strings.Right(Strings.format(Timer, "#0.00"), 2), False
            .setRequestHeader "Content-Type", "text/xml; charset=utf-8"
            .setRequestHeader "SOAPAction", "http://qvidian.com/webservices/" & cmd
            .send soapMsg
        End With
    
        Set xmlResponse = New DOMDocument
        xmlResponse.loadXML XMLHttpRequest.responseXML.xml
    
        ' Process the results...
        DebugMsgBox "XMLHttpRequest.Status is [" & XMLHttpRequest.Status & "]", "executeMessage:"
        If XMLHttpRequest.Status = 200 Then
            Exit Do
        Else
            DebugMsgBox "Oh dear, something unexpected happened! [" & XMLHttpRequest.responseXML.xml & "]", "executeMessage:"
            ErrorType = "QvidianException"
            ErrorCode = XMLHttpRequest.Status
            ' Couldn't find the server!!!
            If XMLHttpRequest.Status = 404 Or XMLHttpRequest.Status = 12029 Or _
               XMLHttpRequest.Status = 12031 Or XMLHttpRequest.Status = 12007 Then
                ErrorMessage = "The specific Qvidian server " & connectURL & " could not be found. Please contact your Administrator to make sure the server is running. " & vbNewLine & "Terminating the current operation."
            Else
        
                ' Let's work out if there was a failure in there...
                Set objNodeList = xmlResponse.getElementsByTagName("faultcode")
                ErrorType = ""
                If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
                    mFaultCode = objNodeList(0).Text
                    DebugMsgBox "mFaultCode is [" & mFaultCode & "]", "executeMessage:"
                    Set objNodeList = xmlResponse.getElementsByTagName("faultstring")
                    If Not objNodeList Is Nothing And objNodeList.Length > 0 Then
                        ErrorType = objNodeList(0).Text
                        DebugMsgBox "ErrorType is [" & ErrorType & "]", "executeMessage:"
                        If InStr(1, ErrorType, "QvidianException") > 0 Then
                            Set objNodeList = xmlResponse.getElementsByTagName("Number")
                            ErrorCode = CLng(objNodeList(0).Text)
                            Set objNodeList = xmlResponse.getElementsByTagName("Message")
                            ErrorMessage = objNodeList(0).Text
                            Set objNodeList = xmlResponse.getElementsByTagName("Source")
                            ErrorSource = objNodeList(0).Text
                        Else
                            ErrorMessage = objNodeList(0).Text
                            ErrorType = "SoapException"
                        End If
                    End If
                    QvidianErrorHandler "executeMessage"
                Else
                    ErrorMessage = "Connecting to the Qvidian server " & connectURL & " failed with the following error code: " & ErrorCode & ". Terminating the current operation."
                End If
                
                Exit Do
            End If
        End If
        
        'otherwise, sleep 2 seconds and retry
        Sleep 2000
        
        retryCount = retryCount + 1
    Loop
End Sub

Private Function DecodeBase64(ByVal strData As String) As Byte()
    Dim objXML As MSXML2.DOMDocument
    Dim objNode As MSXML2.IXMLDOMElement
   
    ' help from MSXML
    Set objXML = New MSXML2.DOMDocument
    Set objNode = objXML.createElement("b64")
    objNode.DataType = "bin.base64"
    objNode.Text = strData
    DecodeBase64 = objNode.nodeTypedValue
   
    ' thanks, bye
    Set objNode = Nothing
    Set objXML = Nothing
End Function

Private Function EncodeBase64(ByRef arrData() As Byte) As String
    Dim objXML As MSXML2.DOMDocument
    Dim objNode As MSXML2.IXMLDOMElement
    
    ' help from MSXML
    Set objXML = New MSXML2.DOMDocument
    
    ' byte array to base64
    Set objNode = objXML.createElement("b64")
    objNode.DataType = "bin.base64"
    objNode.nodeTypedValue = arrData
    EncodeBase64 = objNode.Text

    ' thanks, bye
    Set objNode = Nothing
    Set objXML = Nothing
End Function

Attribute VB_Name = "evtCheckBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oXb As MSForms.CheckBox
Attribute oXb.VB_VarHelpID = -1

Private Sub oXb_Click()
    gProps.enableSaveButton
End Sub
Attribute VB_Name = "evtComboBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oCb As MSForms.ComboBox
Attribute oCb.VB_VarHelpID = -1

Private Sub oCb_Change()
    gProps.enableSaveButton
End Sub

Attribute VB_Name = "evtDateBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oDateTb As MSForms.TextBox
Attribute oDateTb.VB_VarHelpID = -1

Private Sub oDateTb_Change()
    gProps.validateDateField oDateTb.name
End Sub

Attribute VB_Name = "evtDefButton"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oImg As MSForms.Image
Attribute oImg.VB_VarHelpID = -1

Private Sub oImg_Click()
    Debug.Print "oImg_Click: " & shiftPressed & " " & ctrlPressed
    gProps.defaultClicked oImg.name
End Sub
Attribute VB_Name = "evtFocus"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Event GetFocus()
Public Event LostFocus(ByVal strCtrl As String)
Private strPreCtr As String

Public Sub CheckActiveCtrl(objForm As MSForms.UserForm)
    With objForm
        If TypeName(.ActiveControl) = "ComboBox" Or _
           TypeName(.ActiveControl) = "TextBox" Then
            strPreCtr = .ActiveControl.name
            On Error GoTo Terminate
            Do
                DoEvents
                If .ActiveControl.name <> strPreCtr Then
                    If TypeName(.ActiveControl) = "ComboBox" Or _
                       TypeName(.ActiveControl) = "TextBox" Then
                        RaiseEvent LostFocus(strPreCtr)
                        strPreCtr = .ActiveControl.name
                        RaiseEvent GetFocus
                    End If
                End If
            Loop
            End If
        End With
Terminate:
    Exit Sub
End Sub


Attribute VB_Name = "evtImage"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oImg As MSForms.Image
Attribute oImg.VB_VarHelpID = -1

Dim ctrlPressed As Boolean
Dim shiftPressed As Boolean

Private Sub oImg_Click()
    Debug.Print "oImg_Click: " & shiftPressed & " " & ctrlPressed
    gJobForm.LabelClick oImg.name, shiftPressed, ctrlPressed
End Sub

Private Sub oImg_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Debug.Print "oImg_Click"
    gJobForm.LabelDoubleClick
End Sub

Private Sub oImg_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Debug.Print "oImg_MouseDown: " & ctrlPressed & " " & Shift
    Select Case Shift
        Case 1
            shiftPressed = True
            ctrlPressed = False
        Case 2
            shiftPressed = False
            ctrlPressed = True
        Case 3
            shiftPressed = True
            ctrlPressed = True
        Case Else
            shiftPressed = False
            ctrlPressed = False
    End Select
End Sub

Attribute VB_Name = "evtIntegerBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oTb As MSForms.TextBox
Attribute oTb.VB_VarHelpID = -1

Private Sub oTb_Change()
    gProps.validateNumberField oTb.name, True
End Sub

Private Sub oTb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
Debug.Print KeyCode
    If KeyCode < 32 Then
        Select Case KeyCode
            Case 8      ' backspace
            Case 9      ' tab
            Case 13     ' enter
            Case Else
                KeyCode = 0
        End Select
    Else
        ' -
        If KeyCode = 189 Then
        Else
            ' 0-9
            If KeyCode < 48 Or KeyCode > 57 Then
                KeyCode = 0
            End If
        End If
    End If
End Sub
Attribute VB_Name = "evtLabel"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oLbl As MSForms.Label
Attribute oLbl.VB_VarHelpID = -1

Dim buttonPressed As Integer
Dim ctrlPressed As Boolean
Dim shiftPressed As Boolean

Private Sub oLbl_Click()
    Debug.Print "oLbl_Click: " & shiftPressed & " " & ctrlPressed
    gJobForm.LabelClick oLbl.name, shiftPressed, ctrlPressed
End Sub

Private Sub oLbl_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Debug.Print "oLbl_Click"
    gJobForm.LabelDoubleClick
End Sub

Private Sub oLbl_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Debug.Print "oLbl_MouseDown: " & ctrlPressed & " " & Shift
    buttonPressed = Button
    Select Case Shift
        Case 1
            shiftPressed = True
            ctrlPressed = False
        Case 2
            shiftPressed = False
            ctrlPressed = True
        Case 3
            shiftPressed = True
            ctrlPressed = True
        Case Else
            shiftPressed = False
            ctrlPressed = False
    End Select
End Sub

Private Sub oLbl_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    'Debug.Print "oLbl_MouseMove: " & shiftPressed & " " & ctrlPressed
    gJobForm.FakeMouseMove oLbl.name, Button, shiftPressed, ctrlPressed, X, Y
End Sub

Private Sub oLbl_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Debug.Print "oLbl_MouseUp: " & shiftPressed & " " & ctrlPressed
    gJobForm.FakeMouseUp oLbl.name, Button, shiftPressed, ctrlPressed, X, Y
End Sub
Attribute VB_Name = "evtListBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oLb As MSForms.ListBox
Attribute oLb.VB_VarHelpID = -1

Private Sub oLb_Change()
    gProps.enableSaveButton
End Sub

Private Sub oLb_Click()
    gProps.enableSaveButton
End Sub

Attribute VB_Name = "evtNumberBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oTb As MSForms.TextBox
Attribute oTb.VB_VarHelpID = -1

Private Sub oTb_Change()
    gProps.validateNumberField oTb.name, False
End Sub

Private Sub oTb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
Debug.Print KeyCode
    If KeyCode < 32 Then
        Select Case KeyCode
            Case 8      ' backspace
            Case 9      ' tab
            Case 13     ' enter
            Case Else
                KeyCode = 0
        End Select
    Else
        ' - or .
        If KeyCode = 189 Or KeyCode = 190 Then
        Else
            ' 0-9
            If KeyCode < 48 Or KeyCode > 57 Then
                KeyCode = 0
            End If
        End If
    End If
End Sub

Attribute VB_Name = "evtPropLabel"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oLbl As MSForms.Label
Attribute oLbl.VB_VarHelpID = -1
Private Const BurgundayText As Long = 1250185    ' RGB(137, 19, 19)

Private Sub oLbl_Click()
    Debug.Print "oLbl_Click: " & oLbl.name
    
    gProps.ShowOrigCMDData oLbl
End Sub

Private Sub oLbl_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If oLbl.ForeColor = BurgundayText Then
        oLbl.Font.Underline = True
    End If
End Sub
Attribute VB_Name = "evtTextBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents oTb As MSForms.TextBox
Attribute oTb.VB_VarHelpID = -1

Private Sub oTb_Change()
    gProps.enableSaveButton
End Sub
Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{18CCB709-A172-4F8E-9D82-5AA360A7E1F2}{1FB7B56F-038C-410E-9917-A9A65921E0A7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cbOK_Click()
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    lblFinishedText.caption = "Template Version " & modVersionInfo.TemplateVersion
    Label1.caption = modVersionInfo.ProductCopyright
End Sub
Attribute VB_Name = "frmAdvancedSmartMarking"
Attribute VB_Base = "0{CACA5BFB-55F6-45CC-A1E8-B0B7B3EE8FD1}{4126D9F4-E65A-49DB-B53F-693DF28253E7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




'------------------------------------------------------------------------------
'  require variable declarations: set array bases to 1
'------------------------------------------------------------------------------
Option Explicit: Option Base 1

Private Sub UserForm_Initialize()
    cmdCancel.ForeColor = EnableMenu
    cmdSmartMark.ForeColor = EnableMenu

    'LoadStrings'JSB: Leave defaults for now.
    LoadDropdowns
    'LoadDefaultSettings
    LoadPreviousSelections
    EnableDisableControls
 
End Sub

Private Sub LoadStrings()
'    Select Case SantData.lTemplateMode
'        Case MODE_BULKLOAD
'            chkCombineAH.Caption = GetTemplateString("Bulkload_frmOptions_chkCombineAH")
'        Case MODE_BURST
'            chkCombineAH.Caption = GetTemplateString("Burst_frmOptions_chkCombineAH")
'    End Select
'
'    lblMarkingCriteria.Caption = GetTemplateString("BurstBulkload_frmOptions_lblMarkingCriteria")
'    cmdCancel.Caption = GetTemplateString("BurstBulkload_frmOptions_cmdCancel")
'    cmdHelp.Caption = GetTemplateString("BurstBulkload_frmOptions_cmdHelp")
'    cmdSmartMark.Caption = GetTemplateString("BurstBulkload_frmOptions_cmdSmartMark")
'    cmdCancelHi.Caption = GetTemplateString("BurstBulkload_frmOptions_cmdCancel")
'    cmdHelpHi.Caption = GetTemplateString("BurstBulkload_frmOptions_cmdHelp")
'    cmdSmartMarkHi.Caption = GetTemplateString("BurstBulkload_frmOptions_cmdSmartMark")
'    lblAdvanced.Caption = GetTemplateString("BurstBulkload_frmOptions_lblAdvanced")
'    lblFormattingOption.Caption = GetTemplateString("BurstBulkload_frmOptions_lblFormattingOption")
'    lblMarkingOption1.Caption = GetTemplateString("BurstBulkload_frmOptions_lblMarkingOption1")
'    lblParsingCriteria.Caption = GetTemplateString("BurstBulkload_frmOptions_lblParsingCriteria")
'    chkBold.Caption = GetTemplateString("BurstBulkload_frmOptions_chkBold")
'    chkCombineQ.Caption = GetTemplateString("BurstBulkload_frmOptions_chkCombineQ")
'    chkItalic.Caption = GetTemplateString("BurstBulkload_frmOptions_chkItalic")
'    chkMinimize.Caption = GetTemplateString("BurstBulkload_frmOptions_chkMinimize")
'    chkShowOptions.Caption = GetTemplateString("BurstBulkload_frmOptions_chkShowOptions")
'    chkUnderline.Caption = GetTemplateString("BurstBulkload_frmOptions_chkUnderline")
'    chkUseFont.Caption = GetTemplateString("BurstBulkload_frmOptions_chkUseFont")
'    chkUseFontSize.Caption = GetTemplateString("BurstBulkload_frmOptions_chkUseFontSize")
'    chkUseLength.Caption = GetTemplateString("BurstBulkload_frmOptions_chkUseLength")
'    chkUsePunctuation.Caption = GetTemplateString("BurstBulkload_frmOptions_chkUsePunctuation")
'    chkUseStyle.Caption = GetTemplateString("BurstBulkload_frmOptions_chkUseStyle") 'Text begins with style:
'    optSingleParagraph.Caption = GetTemplateString("BurstBulkload_frmOptions_optSingleParagraph") 'Mark each paragraph individually.
'    optDoubleParagraph.Caption = GetTemplateString("BurstBulkload_frmOptions_optDoubleParagraph") 'Mark text that is separated by two paragraph markers.
'    optBeginsWith.Caption = GetTemplateString("BurstBulkload_frmOptions_optBeginsWith") 'Mark text that begins with:
'    optMatchAny.Caption = GetTemplateString("BurstBulkload_frmOptions_optMatchAny") 'Match Any
'    optMatchAll.Caption = GetTemplateString("BurstBulkload_frmOptions_optMatchAll") 'Match All
'    Me.Caption = GetTemplateString("BurstBulkload_frmOptions_WindowCaption") 'SmartMarking Options
'
End Sub

Private Sub LoadDropdowns()
    'Add possible marking options
    Select Case SmartMarking.MarkingMode
        Case MODE_BULKLOAD
            cboMarkingOption.AddItem "Title" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Question")) 'Question
            cboMarkingOption.AddItem "Content" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Answer")) 'Answer
        Case MODE_BURST
            cboMarkingOption.AddItem "Header" '(GetTemplateString("Burst_frmOptions_cboMarkingOption_Header")) 'Header
            cboMarkingOption.AddItem "Question" '(GetTemplateString("Burst_frmOptions_cboMarkingOption_Question")) 'Question
    End Select
    
    cboMatchAnyAll.AddItem "Any"
    cboMatchAnyAll.AddItem "All"
    
    'Add equality operators to size and length equality dropdowns
    If cboLengthEquality.ListCount < 1 Then
        cboLengthEquality.AddItem "<"
        cboLengthEquality.AddItem ">"
        cboLengthEquality.AddItem "="
        cboLengthEquality.AddItem "<="
        cboLengthEquality.AddItem ">="
        cboLengthEquality.AddItem "<>"
    End If
    If cboFontSizeEquality.ListCount < 1 Then
        cboFontSizeEquality.AddItem "<"
        cboFontSizeEquality.AddItem ">"
        cboFontSizeEquality.AddItem "="
        cboFontSizeEquality.AddItem "<="
        cboFontSizeEquality.AddItem ">="
        cboFontSizeEquality.AddItem "<>"
    End If

    'Add common punctuations from ASCII table to punctuation list
    If cboPunctuation.ListCount < 1 Then
        Dim a As Integer
        For a = 33 To 47
            cboPunctuation.AddItem (Chr(a))
        Next a
        For a = 58 To 63
            cboPunctuation.AddItem (Chr(a))
        Next a
    End If

    'Add available fonts to font list
    If cboFont.ListCount < 1 Then
        Dim i As Integer
        Dim sArray() As String
        i = thisDocument.Application.FontNames.count
        ReDim sArray(i) As String

        For a = 1 To i
            sArray(a) = thisDocument.Application.FontNames.item(a)

        Next a
        QuickSortVariants sArray, LBound(sArray), UBound(sArray)
        For a = LBound(sArray) To UBound(sArray)
            cboFont.AddItem sArray(a)
        Next a
    End If
    
    'Load the style dropdown with the styles that are in use in this document.
    If cboStyle.ListCount < 1 Then
        Dim AvailableStyle As Style
        For Each AvailableStyle In ActiveDocument.Styles
            If AvailableStyle.InUse Then
                cboStyle.AddItem AvailableStyle.NameLocal
            End If
        Next
    End If
End Sub

Private Sub LoadDefaultSettings()
    cboLengthEquality.Text = "="
    chkUseLength.Value = False
    txtLength.Text = "60"
    chkUsePunctuation.Value = False
    cboPunctuation.Text = "?"
    chkUseFont.Value = False
    Call SetFontName("Times New Roman")
    chkUseFontSize.Value = False
    cboFontSizeEquality.Text = ">"
    txtFontSize.Text = "12"
    chkBold.Value = True
    chkItalic.Value = False
    chkUnderline.Value = False
'    chkMinimize.Value = False
'    chkShowOptions.Value = False
    cboMarkingOption.Text = "Title"
    chkCombineQ.Value = False
    chkCombineAH.Value = True
    chkUseStyle.Value = False
    txtBeginsWith.Text = ""

    optSingleParagraph.Value = True
    cboMatchAnyAll.Value = "All"

    'Handle case where style does not exist.
    On Error Resume Next
    cboStyle.Text = "Heading1"
    Err.Clear


End Sub

Private Sub LoadPreviousSelections()
    If Len(SmartMarking.ParagraphLengthEquality) = 0 Then
        LoadDefaultSettings
        
        Select Case SmartMarking.MarkingMode
            Case MODE_BULKLOAD
                chkCombineQ.caption = "Title markings"
                chkCombineAH.caption = "Content markings"
            Case MODE_BURST
                chkCombineQ.caption = "Question markings"
                chkCombineAH.caption = "Header markings"
        End Select
    Else
    
        cboLengthEquality.Text = SmartMarking.ParagraphLengthEquality
        chkUseLength.Value = SmartMarking.UseParagraphLength
        txtLength.Text = SmartMarking.ParagraphLength
        chkUsePunctuation.Value = SmartMarking.UseEndingPunctuation
        cboPunctuation.Text = SmartMarking.EndingPunctuation
        chkUseFont.Value = SmartMarking.UseFontName
        Call SetFontName(SmartMarking.fontName)
        chkUseFontSize.Value = SmartMarking.UseFontSize
        cboFontSizeEquality.Text = SmartMarking.FontSizeEquality
        txtFontSize.Text = SmartMarking.fontSize
        chkBold.Value = SmartMarking.UseBold
        chkItalic.Value = SmartMarking.UseItalic
        chkUnderline.Value = SmartMarking.UseUline
        'chkMinimize.Value = Not SantData.bShowSmartMark
        'chkShowOptions.Value = SantData.bShowOptionsOnOpen
        Select Case SmartMarking.MarkingMode
            Case MODE_BULKLOAD
                If SmartMarking.TypeToMark = QUESTION Then
                    cboMarkingOption.Text = "Title"
                Else
                    cboMarkingOption.Text = "Content"
                End If
                chkCombineQ.caption = "Title markings"
                chkCombineAH.caption = "Content markings"
            Case MODE_BURST
                If SmartMarking.TypeToMark = QUESTION Then
                    cboMarkingOption.Text = "Question" 'GetTemplateString("Burst_frmOptions_cboMarkingOption_Question")
                Else
                    cboMarkingOption.Text = "Header" 'GetTemplateString("Burst_frmOptions_cboMarkingOption_Header")
                End If
                chkCombineQ.caption = "Question markings"
                chkCombineAH.caption = "Header markings"
        End Select
        chkCombineQ.Value = SmartMarking.CombineQ
        chkCombineAH.Value = SmartMarking.CombineAH
        chkUseStyle.Value = SmartMarking.UseStyle
        txtBeginsWith.Text = SmartMarking.BeginsWithString 'Join(SmartMarking.BeginsWith, ",")
    
        Select Case SmartMarking.ParseMode
            Case ParseModes.SINGLE_PARAGRAPH
                optSingleParagraph.Value = True
            Case ParseModes.DOUBLE_PARAGRAPH
                optDoubleParagraph.Value = True
            Case ParseModes.BEGINS_WITH
                optBeginsWith.Value = True
        End Select
    
        If SmartMarking.MatchMode = MATCH_ALL Then
            cboMatchAnyAll.Value = "All"
        Else
            cboMatchAnyAll.Value = "Any"
        End If
    
        'Handle case where style does not exist.
        On Error Resume Next
        cboStyle.Text = SmartMarking.styleName
        Err.Clear
    End If
End Sub

Private Sub SetFontName(ByVal strFontName As String)
    Dim i As Integer
    
    cboFont.ListIndex = -1
    For i = 0 To cboFont.ListCount - 1
        If cboFont.List(i) = strFontName Then
            cboFont.ListIndex = i
            Exit Sub
        End If
    Next
End Sub

Private Sub EnableDisableControls()
    'Enable/Disable appropriate controls
    cboLengthEquality.Enabled = chkUseLength
    txtLength.Enabled = chkUseLength
    cboFontSizeEquality.Enabled = chkUseFontSize
    txtFontSize.Enabled = chkUseFontSize
    cboPunctuation.Enabled = chkUsePunctuation
    cboFont.Enabled = chkUseFont
    cboStyle.Enabled = chkUseStyle
End Sub

'POTENTIAL FEATURE ENHANCEMENT: Sample area.  Piece of text that
'gets formatted with the selections.

Private Sub chkUseLength_Click()
    cboLengthEquality.Enabled = chkUseLength
    txtLength.Enabled = chkUseLength
End Sub

Private Sub chkUseStyle_Click()
    cboStyle.Enabled = chkUseStyle
End Sub

Private Sub chkUseFont_Click()
    cboFont.Enabled = chkUseFont
End Sub

Private Sub chkUseFontSize_Click()
    cboFontSizeEquality.Enabled = chkUseFontSize
    txtFontSize.Enabled = chkUseFontSize
End Sub

Private Sub chkUsePunctuation_Click()
    cboPunctuation.Enabled = chkUsePunctuation
End Sub

Private Sub cmdCancel_Click()

   'Exit form without saving
   Unload Me

End Sub

Private Sub cmdSmartMark_Click()
    
    'Save current selections to calling page (which will save them when we're done with burst/bulkload)
    'SaveCriteria 'TODO: Decide if we want the SmartMarking settings to automatically save when a document is uploaded, or if we want to allow an explicit save.
    
'    If SantData.FirstTime = True Then
'        SantData.FirstTime = False
'    End If
    
    'Clear all current markings.
    'SantData.FirstTime = False'JSB: Not used?
    Dim thisWindow As Window
    Dim thisDocument As Document
    
    Set thisWindow = ActiveWindow
    Set thisDocument = ActiveDocument
    
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\StartOfDoc"
    
    SmartMarking.SetParameters thisDocument, thisWindow, GetParseMode, GetMatchMode, _
        chkUsePunctuation.Value, cboPunctuation.Text, chkUseLength.Value, cboLengthEquality.Text, txtLength.Text, _
        txtBeginsWith.Text, chkUseFontSize.Value, cboFontSizeEquality.Text, txtFontSize.Text, _
        chkBold.Value, chkItalic.Value, chkUnderline.Value, chkUseFont.Value, cboFont.Text, _
        chkUseStyle.Value, cboStyle.Text, GetTypeToMark, chkCombineQ.Value, chkCombineAH.Value
    
        'Refresh the screen
    Me.Repaint
    
    
    Unload Me 'Hide the form
    DoEvents
    frmProgressBar.StartAdvancedSmartMarking
    

    
    'modMain.ShowHideSmartMark'TODO: Decide if we still need the show/hide smart marking option.
    'frmProgressBar.StartAdvancedSmartMarking    'frmEvaluate.Show
    

    
    
    'JSB: Commented out the following 4 lines.  Determine if needed/desired with new model..
'    Application.Visible = True
'    Application.ScreenUpdating = True
'    Application.WindowState = wdWindowStateMinimize
'    Application.WindowState = wdWindowStateMaximize
    Application.Selection.GoTo what:=wdGoToBookmark, name:="\StartOfDoc"
    
End Sub

Private Sub cmdHelp_Click()
    Dim sMode As String
    sMode = GetTemplateMode(ActiveDocument)
    If sMode = "SantWordBulkLoad" Then
        modWS.CallContextHelp (18)
    Else
        modWS.CallContextHelp (195)
    End If
End Sub

Private Sub SaveCriteria()
'    Dim SettingsString As String
'
'    'Save settings from this screen to public variables that will eventually be saved to the database.
'    SantData.bCombineQ = chkCombineQ.Value
'    SantData.bCombineAH = chkCombineAH.Value
'    SantData.bShowSmartMark = Not CBool(chkMinimize.Value)
'    Select Case SantData.lTemplateMode
'        Case MODE_BULKLOAD
'            If cboMarkingOption.Text = GetTemplateString("Bulkload_frmOptions_cboMarkingOption_Question") Then
'                SantData.sTypeToMark = "Question"
'            Else
'                SantData.sTypeToMark = "Answer"
'            End If
'        Case MODE_BURST
'            If cboMarkingOption.Text = GetTemplateString("Burst_frmOptions_cboMarkingOption_Question") Then
'                SantData.sTypeToMark = "Question"
'            Else
'                SantData.sTypeToMark = "Header"
'            End If
'    End Select
'    SantData.bShowOptionsOnOpen = chkShowOptions.Value
'    SantData.sParagraphLengthEquality = cboLengthEquality.Text
'    SantData.bUseParagraphLength = chkUseLength.Value
'    SantData.lParagraphLength = txtLength.Text
'    SantData.bUseEndingPunctuation = chkUsePunctuation.Value
'    SantData.sEndingPunctuation = cboPunctuation.Text
'    SantData.bUseFontName = chkUseFont.Value
'    SantData.sFontName = cboFont.Text
'    SantData.bUseFontSize = chkUseFontSize.Value
'    SantData.sFontSizeEquality = cboFontSizeEquality.Text
'    SantData.dFontSize = txtFontSize.Text
'    SantData.bUseBold = chkBold.Value
'    SantData.bUseItalic = chkItalic.Value
'    SantData.bUseUline = chkUnderline.Value
'
'    SantData.bUseStyle = chkUseStyle.Value
'    SantData.sStyleName = cboStyle.Text
'
'    If optSingleParagraph.Value = True Then
'        SantData.iParse = 1
'    ElseIf optDoubleParagraph.Value = True Then
'        SantData.iParse = 2
'    Else
'        SantData.iParse = 3
'    End If
'
'    SantData.bMatchAll = optMatchAll.Value
'
'    SantData.sBeginsWith = txtBeginsWith.Text
'    SetBeginsWithArray
'
'    'Tell page to save settings on next post back.
'    'The order of these values IS important.
'    Const DIVIDER As String = "|*|"
'    SettingsString = CInt(SantData.bShowOptionsOnOpen) & DIVIDER & CInt(SantData.bShowSmartMark) & DIVIDER & SantData.sTypeToMark & DIVIDER & _
'            SantData.lParagraphLength & DIVIDER & CInt(SantData.bUseParagraphLength) & DIVIDER & CInt(SantData.bUseEndingPunctuation) & DIVIDER & _
'            CInt(SantData.bUseFontName) & DIVIDER & CInt(SantData.bUseFontSize) & DIVIDER & _
'            SantData.sParagraphLengthEquality & DIVIDER & SantData.sFontSizeEquality & DIVIDER & SantData.sEndingPunctuation & DIVIDER & _
'            SantData.sFontName & DIVIDER & SantData.dFontSize & DIVIDER & CInt(SantData.bUseBold) & DIVIDER & CInt(SantData.bUseItalic) & DIVIDER & _
'            CInt(SantData.bUseUline) & DIVIDER & SantData.iParse & DIVIDER & CInt(SantData.bCombineQ) & DIVIDER & CInt(SantData.bCombineAH) & DIVIDER & _
'            CInt(SantData.bUseStyle) & DIVIDER & SantData.sStyleName & DIVIDER & CInt(SantData.bMatchAll) & DIVIDER & SantData.sBeginsWith
'    'Write the settings to the calling page, skip if we get an error for now.
'    On Error Resume Next
'    SantData.CallingPage.SetBurstBulkloadSettings SettingsString

End Sub

Public Sub QuickSortVariants(vArray As Variant, inLow As Long, inHi As Long)
      
  'vArray()   The array to sort
  'inLow      Lower bound of sort point
  'inHi       Upper bound of sort point
      
  'Dim two working variables to hold
  'array members. The first holds the
  'pivot item - the item half way between
  'the inLow and inHi values, while the
  'second is used to hold the array contents
  'that will be swapped later.
  'These two items should be declared as
  'the same data type as the array passed.
   Dim pivot   As Variant
   Dim tmpSwap As Variant
   
  'Dim two working variables to hold the
  'values representing the pivot's lower
  'and upper points as passed to the routine.
  'These should be declared as the same data
  'type as the inLow/inHi variables passed.
   Dim tmpLow  As Long
   Dim tmpHi   As Long
    
  'Save to the working variables the
  'values passed as lower & upper
   tmpLow = inLow
   tmpHi = inHi
    
  'Get the item halfway through the data
  'determined by the range passed as lower
  'and upper and assign it as the pivot data
  '
  'When first calling this routine the
  'range is inLow = LBound(array), and
  'inHi = UBound(array). During subsequent
  'calls, inLow and inHi will receive
  'different values as determined below.
   pivot = vArray((inLow + inHi) \ 2)
  
  'With pivot holding the value of the item
  'halfway through the range, compare the
  'rank of tmpLow to tmpHi and assign the two
  'tmp storage variables that data for later
  'comparison. Here we're continuing the loop
  'while the low item being compared value (tmpLow)
  'is less than tmpHi (the upper bound value).
   While (tmpLow <= tmpHi)
  
     'Since (and while) tmpLow remains less than
     'tmpHi, compare the value of the array()
     'element at this position against pivot.
      While (vArray(tmpLow) < pivot And tmpLow < inHi)
         tmpLow = tmpLow + 1
      Wend
      
     'repeat the same for the array value at
     'position tmpHi.
      While (pivot < vArray(tmpHi) And tmpHi > inLow)
         tmpHi = tmpHi - 1
      Wend

     'When the position of tmpHi exceeds or matches tmpLow
     'swap the two items.
      If (tmpLow <= tmpHi) Then
      
        'a: assign vArray(tmpLow) to tmpSwap
        'b: swap vArray(tmpHi) for vArray(tmpLow)
        'c: assign tmpSwap back to vArray(tmpHi)
         tmpSwap = vArray(tmpLow)
         vArray(tmpLow) = vArray(tmpHi)
         vArray(tmpHi) = tmpSwap
         
        'adjust the new Hi and Low values
         tmpLow = tmpLow + 1
         tmpHi = tmpHi - 1
      End If
   
   Wend
  
  'if the original lower is less than tmpHi,
  'call the routine again with inLow & tmpHi
  'as the pivot's lower and upper points.
   If (inLow < tmpHi) Then QuickSortVariants vArray, inLow, tmpHi
   
  'if the new tmpLow value lower is less than
  'the original inHi, call the routine again with
  'tmpLow & inHi as the pivot's lower and upper points.
   If (tmpLow < inHi) Then QuickSortVariants vArray, tmpLow, inHi
  
End Sub

Private Function GetParseMode() As ParseModes
    If optSingleParagraph.Value = True Then
        GetParseMode = SINGLE_PARAGRAPH
    ElseIf Me.optDoubleParagraph.Value = True Then
        GetParseMode = DOUBLE_PARAGRAPH
    Else
        GetParseMode = BEGINS_WITH
    End If
End Function

Private Function GetMatchMode() As MatchModes
    If Me.cboMatchAnyAll.Value = "All" Then
        GetMatchMode = MATCH_ALL
    Else
        GetMatchMode = MATCH_ANY
    End If
End Function

Private Function GetTypeToMark() As TypesToMark
    Select Case cboMarkingOption.Text
        Case "Title", "Question"
            GetTypeToMark = QUESTION
        Case "Content", "Answer"
            GetTypeToMark = ANSWER
        Case "Header"
            GetTypeToMark = HEADER
    End Select
End Function


Attribute VB_Name = "frmContentProperties"
Attribute VB_Base = "0{377E9B35-967A-4E5C-BDE7-CE6513900545}{FF57E87A-854C-4BF5-96F9-9E811AE9BA10}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private saveEnabled As Boolean
Private resetEnabled As Boolean
Public dataChanged As Boolean
Private expDateValid As Boolean
Private noValidate As Boolean
Public content As struct_Content
Public cmdList As Scripting.Dictionary
Public MultiValueDelimiter As String
Private Const RedText As Long = 255              ' RGB(255, 0, 0)
Private Const BlackText As Long = 0              ' RGB(160, 160, 160)
Private Const BurgundayText As Long = 1250185    ' RGB(137, 19, 19)
Private moEvents As Collection
Private Const MaxFormHeight As Integer = 540

Private Sub cbCancel_Click()
    Unload Me
End Sub

Private Sub cbReset_Click()
    If resetEnabled Then
        showDefaults
    End If
End Sub

Private Sub cbSave_Click()

    If Not saveEnabled Then
        Exit Sub
    End If
    
    If (content.ChangedTitle = True And tbTitle.Text <> "" And tbTitle.Text <> content.UpdatedTitle) Or _
       (content.ChangedTitle = False And tbTitle.Text <> "" And tbTitle.Text <> content.title) Then
        If tbTitle.Text = content.title Then
            content.ChangedTitle = False
            content.UpdatedTitle = ""
        Else
            content.ChangedTitle = True
            content.UpdatedTitle = tbTitle.Text
        End If
        dataChanged = True
    End If
    
    If (content.ChangedComments = True And tbComments.Text <> content.UpdatedComments) Or _
       (content.ChangedComments = False And tbComments.Text <> content.Comments) Then
        If tbComments.Text = content.Comments Then
            content.ChangedComments = False
            content.UpdatedComments = ""
        Else
            content.ChangedComments = True
            content.UpdatedComments = tbComments.Text
        End If
        dataChanged = True
    End If
    If (content.ChangedContactInfo = True And tbContactInfo.Text <> content.UpdatedContactInfo) Or _
       (content.ChangedContactInfo = False And tbContactInfo.Text <> content.ContactInfo) Then
        If tbContactInfo.Text = content.ContactInfo Then
            content.ChangedContactInfo = False
            content.UpdatedContactInfo = ""
        Else
            content.ChangedContactInfo = True
            content.UpdatedContactInfo = tbContactInfo.Text
        End If
        dataChanged = True
    End If
    If (content.ChangedAlertText = True And tbAlertText.Text <> content.UpdatedAlertText) Or _
       (content.ChangedAlertText = False And tbAlertText.Text <> content.AlertText) Then
        If tbAlertText.Text = content.AlertText Then
            content.ChangedAlertText = False
            content.UpdatedAlertText = ""
        Else
            content.ChangedAlertText = True
            content.UpdatedAlertText = tbAlertText.Text
        End If
        dataChanged = True
    End If
    If (content.ChangedAlertEnabled = True And xbAlertEnabled.Value <> content.UpdatedAlertEnabled) Or _
       (content.ChangedAlertEnabled = False And xbAlertEnabled.Value <> content.AlertEnabled) Then
        If xbAlertEnabled.Value = content.AlertEnabled Then
            content.ChangedAlertEnabled = False
            content.UpdatedAlertEnabled = False
        Else
            content.ChangedAlertEnabled = True
            content.UpdatedAlertEnabled = xbAlertEnabled.Value
        End If
        dataChanged = True
    End If
    Dim dateChanged As Boolean
    dateChanged = False
    If content.ChangedDateToExpire = True Then
        If (CStr(tbExpiresOn.Text) = "" And content.UpdatedDateToExpireSet) Or _
           (Not CStr(tbExpiresOn.Text) = "" And (content.UpdatedDateToExpireSet = False Or CStr(tbExpiresOn.Text) <> CStr(content.UpdatedDateToExpire))) Then
            dateChanged = True
        End If
    Else
        If tbExpiresOn.Text = "" Then
            If content.DateToExpireSet Then
                dateChanged = True
            End If
        Else
            If (content.DateToExpireSet = False Or CStr(tbExpiresOn.Text) <> CStr(content.DateToExpire)) Then
                dateChanged = True
            End If
        End If
    End If
    If dateChanged Then
        If (CStr(tbExpiresOn.Text) = "" And content.DateToExpireSet = False) Or _
           (Not CStr(tbExpiresOn.Text) = "" And CStr(tbExpiresOn.Text) = CStr(content.DateToExpire)) Then
            content.ChangedDateToExpire = False
            content.UpdatedDateToExpireSet = False
        Else
            content.ChangedDateToExpire = True
            content.UpdatedDateToExpireSet = IIf(CStr(tbExpiresOn.Text) = "", False, True)
            If content.UpdatedDateToExpireSet Then
                content.UpdatedDateToExpire = tbExpiresOn.Text
            End If
        End If
        dataChanged = True
    End If
    
    ' Custom meta-data time?
    If content.cmdValues.count > 0 And content.cmdValues.count = cmdList.count Then
        ' Yes, and the right amount....
        Dim cmdItem As struct_CMD
        Dim idx As Integer
        For idx = 0 To content.cmdValues.count - 1
            Set cmdItem = content.cmdValues.Items(idx)
            With Me.Controls("cc" & cmdItem.cmID)
                If cmdItem.DataType = CMDataTypes.BooleanType Then
                    If (cmdItem.ChangedValue = True And .Value <> CBool(cmdItem.UpdatedValue)) Or _
                       (cmdItem.ChangedValue = False And .Value <> CBool(cmdItem.Value)) Then
                        If .Value = CBool(cmdItem.Value) Then
                            cmdItem.ChangedValue = False
                            cmdItem.UpdatedValue = "False"
                        Else
                            cmdItem.ChangedValue = True
                            cmdItem.UpdatedValue = IIf(.Value, "True", "False")
                        End If
                        dataChanged = True
                    End If
                ElseIf cmdItem.DataType = CMDataTypes.MultiValueType Then
                    Dim curVal As String
                    curVal = getLBString(cmdItem.cmID)
                    If (cmdItem.ChangedValue = True And curVal <> cmdItem.UpdatedValue) Or _
                       (cmdItem.ChangedValue = False And curVal <> cmdItem.Value) Then
                        If curVal = cmdItem.Value Then
                            cmdItem.ChangedValue = False
                            cmdItem.UpdatedValue = ""
                        Else
                            cmdItem.ChangedValue = True
                            cmdItem.UpdatedValue = curVal
                        End If
                        dataChanged = True
                    End If
                ElseIf cmdItem.DataType = CMDataTypes.DateType Then
                    If (cmdItem.ChangedValue = True And .Text <> cmdItem.UpdatedValue) Or _
                       (cmdItem.ChangedValue = False And .Text <> cmdItem.Value) Then
                        If .Text = cmdItem.Value Then
                            cmdItem.ChangedValue = False
                            cmdItem.UpdatedValue = ""
                        Else
                            cmdItem.ChangedValue = True
                            cmdItem.UpdatedValue = .Text
                        End If
                        dataChanged = True
                    End If
                Else
                    If (cmdItem.ChangedValue = True And .Text <> cmdItem.UpdatedValue) Or _
                       (cmdItem.ChangedValue = False And .Text <> cmdItem.Value) Then
                        If .Text = cmdItem.Value Then
                            cmdItem.ChangedValue = False
                            cmdItem.UpdatedValue = ""
                        Else
                            cmdItem.ChangedValue = True
                            cmdItem.UpdatedValue = .Text
                        End If
                        dataChanged = True
                    End If
                End If
            End With
        Next
    End If
    
    If dataChanged Then
        gJobFile.saveContentProperties content
    End If
    Unload Me
End Sub

Private Sub dtExpiresOn_CallbackKeyDown(ByVal KeyCode As Integer, ByVal Shift As Integer, ByVal CallbackField As String, CallbackDate As Date)
    enableSaveButton
End Sub

Private Sub dtExpiresOn_Change()
    enableSaveButton
End Sub

Private Sub labHelp_Click()
    launchHelpFile HelpTopics.ContentProperties
End Sub

Private Sub labHelp_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    labHelp.Font.Underline = True
End Sub

Private Sub lblAlertEnabled_Click()
    ShowOrigDataXB lblAlertEnabled, xbAlertEnabled, content.AlertEnabled
End Sub

Private Sub lblAlertEnabled_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If lblAlertEnabled.ForeColor = BurgundayText Then
        lblAlertEnabled.Font.Underline = True
    End If
End Sub

Private Sub lblAlertText_Click()
    ShowOrigData lblAlertText, tbAlertText, content.AlertText
End Sub

Private Sub lblAlertText_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If lblAlertText.ForeColor = BurgundayText Then
        lblAlertText.Font.Underline = True
    End If
End Sub

Private Sub lblComments_Click()
    ShowOrigData lblComments, tbComments, content.Comments
End Sub

Private Sub lblComments_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If lblComments.ForeColor = BurgundayText Then
        lblComments.Font.Underline = True
    End If
End Sub

Private Sub lblContactInfo_Click()
    ShowOrigData lblContactInfo, tbContactInfo, content.ContactInfo
End Sub

Private Sub lblContactInfo_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If lblContactInfo.ForeColor = BurgundayText Then
        lblContactInfo.Font.Underline = True
    End If
End Sub

Private Sub lblExpiresOn_Click()
    ShowOrigData lblExpiresOn, tbExpiresOn, IIf(content.DateToExpireSet, CStr(content.DateToExpire), "")
End Sub

Private Sub lblExpiresOn_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If lblExpiresOn.ForeColor = BurgundayText Then
        lblExpiresOn.Font.Underline = True
    End If
End Sub

Private Sub lblTitle_Click()
    ShowOrigData lblTitle, tbTitle, content.title
End Sub

Private Sub lblTitle_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If lblTitle.ForeColor = BurgundayText Then
        lblTitle.Font.Underline = True
    End If
End Sub

Private Sub tbAlertText_Change()
    enableSaveButton
End Sub

Private Sub tbComments_Change()
    enableSaveButton
End Sub

Private Sub tbContactInfo_Change()
    enableSaveButton
End Sub

Private Sub tbExpiresOn_Change()
    validateDateField tbExpiresOn.name
End Sub

Private Sub tbTitle_Change()
    enableSaveButton
End Sub

Private Sub xbAlertEnabled_Click()
    enableSaveButton
End Sub

Private Sub xbAlertEnabled_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If xbAlertEnabled.ForeColor = BurgundayText Then
        xbAlertEnabled.Font.Underline = True
    End If
End Sub

Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    lblTitle.Font.Underline = False
    lblComments.Font.Underline = False
    lblContactInfo.Font.Underline = False
    lblExpiresOn.Font.Underline = False
    lblAlertText.Font.Underline = False
    lblAlertEnabled.Font.Underline = False
    labHelp.Font.Underline = False
    
    ' Custom meta-data?
    If content.cmdValues.count > 0 And content.cmdValues.count = cmdList.count Then
        Dim cmdItem As struct_CMD
        Dim idx As Integer
        For idx = 0 To content.cmdValues.count - 1
            Set cmdItem = content.cmdValues.Items(idx)
            Me.Controls("lbl" & cmdItem.cmID).Font.Underline = False
        Next
    End If
End Sub

Private Sub UserForm_Initialize()
    DebugMsgBox "", "UserForm_Initialize:"
    Set moEvents = New Collection
    
    tlContentID.ForeColor = EnableMenu
    tlLangauge.ForeColor = EnableMenu
    tlContentType.ForeColor = EnableMenu
    labHelp.ForeColor = &HFF0000
    expDateValid = True
End Sub

Private Sub UserForm_Terminate()
    DebugMsgBox "", "UserForm_Terminate:"
    Set cmdList = Nothing
    Set moEvents = Nothing
    Set content = Nothing
End Sub

Public Sub layoutForm()
    DebugMsgBox "", "layoutForm:"
    
    ' We are going to manually position the field's to get ready for different langauges.
    ' "Fixed" first row.
    lblContentID.Left = 6
    tlContentID.Left = lblContentID.Left + lblContentID.width + 3
    lblContentType.Left = tlContentID.Left + tlContentID.width '+ 20
    tlContentType.Left = lblContentType.Left + lblContentType.width + 3
    lblLanguage.Left = tlContentType.Left + tlContentType.width '+ 45
    tlLangauge.Left = lblLanguage.Left + lblLanguage.width + 3
    labHelp.Top = lblContentID.Top

    Dim maxWidth As Integer
    With lblTitle
        .Left = 6
        If .width > maxWidth Then maxWidth = .width
    End With
    With lblComments
        .Left = 6
        If .width > maxWidth Then maxWidth = .width
    End With
    With lblContactInfo
        .Left = 6
        If .width > maxWidth Then maxWidth = .width
    End With
    With lblExpiresOn
        .Left = 6
        If .width > maxWidth Then maxWidth = .width
    End With
    With lblAlertText
        .Left = 6
        If .width > maxWidth Then maxWidth = .width
    End With
    
    ' Custom meta-data or not?
    Dim widthOffset As Integer
    widthOffset = 12
    Dim formHeight As Integer
    formHeight = 206
    Dim tabStopIndex As Integer
    tabStopIndex = 6
    
    Dim cmd As struct_CMDDef
    Dim idx As Integer
    If cmdList.count > 0 Then
        ' Yep
        'widthOffset = 24

        ' Need to add each one to the dialog
        For idx = 0 To cmdList.count - 1
            Set cmd = cmdList.Items(idx)
            
            ' Add the text label
            Dim myLabel As MSForms.Label
            Set myLabel = fmScroll.Controls.Add("Forms.Label.1", "lbl" & cmd.cmID)
            
            With myLabel
                If cmd.Required Then
                    .caption = cmd.DisplayName & "*:"
                Else
                    .caption = cmd.DisplayName & ":"
                End If
                .Font.size = 8
                .Font.name = "Verdana"
                .WordWrap = False
                .AutoSize = True
                If .width > 180 Then .width = 180
                If .width > maxWidth Then maxWidth = .width
                .Left = 6
                .Top = formHeight + 2 ' 231 + (cmdIdx * 20)
            End With
            
            Dim oEvt As evtPropLabel
            Set oEvt = New evtPropLabel
            Set oEvt.oLbl = myLabel
            moEvents.Add oEvt
            
            Select Case cmd.DataType
                Case CMDataTypes.DateType
                    ' Add the Textbox field.
                    addDateBox idx, cmd, formHeight, tabStopIndex
                
                Case CMDataTypes.BooleanType
                    ' Add the Textbox field.
                    addBooleanBox idx, cmd, formHeight, tabStopIndex
                
                Case CMDataTypes.IntegerType
                    ' Add the Textbox field.
                    addIntegerBox idx, cmd, formHeight, tabStopIndex
                
                Case CMDataTypes.FloatType
                    ' Add the Textbox field.
                    addFloatBox idx, cmd, formHeight, tabStopIndex
                
                Case CMDataTypes.DropDownType
                    ' Add the Drop-down field.
                    addDropDown idx, cmd, formHeight, tabStopIndex
                
                Case CMDataTypes.MultiValueType
                    addMultiValue idx, cmd, formHeight, tabStopIndex
                
                Case Else
                    ' Add the Textbox field.
                    addTextBox idx, cmd, formHeight, tabStopIndex
            End Select
        Next
    Else
        ' Nope
    End If
    
    maxWidth = maxWidth + 9
    
    ' Now position everything
    With tbTitle
        .Left = maxWidth
        .width = Me.width - .Left - widthOffset
    End With
    With tbComments
        .Left = tbTitle.Left
        .width = tbTitle.width
    End With
    With tbContactInfo
        .Left = tbTitle.Left
        .width = tbTitle.width
    End With
    With tbExpiresOn
        .Left = maxWidth
    End With
    With xbAlertEnabled
        .Left = Me.width - .width - widthOffset + 4
    End With
    With lblAlertEnabled
        .Left = xbAlertEnabled.Left - .width - 4
    End With
    With tbAlertText
        .Left = tbTitle.Left
        .width = lblAlertEnabled.Left - .Left - 4 ' Me.width - .Left - widthOffset - 4 - xbAlertEnabled.width
    End With
    
    If cmdList.count > 0 Then
        ' Need to reset the location and size of the custom fields too.
        For idx = 0 To cmdList.count - 1
            Set cmd = cmdList.Items(idx)
            With fmScroll.Controls("cc" & cmd.cmID)
                .Left = tbTitle.Left
                If cmd.DataType = CMDataTypes.TextType Or _
                   cmd.DataType = CMDataTypes.TextAreaType Then
                    .width = tbTitle.width
                End If
                If cmd.DataType = CMDataTypes.DropDownType Then
                    If .width > tbTitle.width Then
                        .width = tbTitle.width
                    End If
                End If
                If cmd.DefaultValue <> "" Then
                    If .width > tbTitle.width - 26 Then
                        .width = tbTitle.width - 26
                    End If
                    Dim defBtn As MSForms.control
                    Set defBtn = Me.Controls("btn" & idx)
                    defBtn.Left = .Left + .width + 6
                End If
            End With
        Next
        
        DebugMsgBox "cbCancel.Top is " & cbCancel.Top, "layoutForm:"
        Dim scrollHeight As Single
        scrollHeight = formHeight
        If scrollHeight > MaxFormHeight Then
            Me.Height = MaxFormHeight
            Me.width = fmScroll.width + 6
            fmScroll.Height = MaxFormHeight - 77
            fmScroll.ScrollBars = fmScrollBarsVertical
            fmScroll.scrollHeight = scrollHeight
        Else
            fmScroll.ScrollBars = fmScrollBarsNone
            fmScroll.Height = scrollHeight
            Me.Height = scrollHeight + 76
        End If
    End If
        
    cbCancel.Left = Me.width - cbCancel.width - widthOffset
    cbCancel.Top = fmScroll.Top + fmScroll.Height + 7
    cbCancel.TabIndex = tabStopIndex + 3
    cbReset.Left = cbCancel.Left - cbReset.width - 5
    cbReset.Top = cbCancel.Top
    cbReset.TabIndex = tabStopIndex + 2
    cbSave.Left = cbReset.Left - cbSave.width - 5
    cbSave.Top = cbCancel.Top
    cbSave.TabIndex = tabStopIndex + 1
    labHelp.Left = Me.width - labHelp.width - 12
    
    cbSave.AutoSize = False
    cbSave.Height = 20
    cbSave.Enabled = False
    cbReset.AutoSize = False
    cbReset.Height = 20
    cbReset.Enabled = False
End Sub

Private Sub addDateBox(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myTextBox As MSForms.TextBox
    Dim oEvt As evtDateBox

    Set myTextBox = fmScroll.Controls.Add("Forms.TextBox.1", "cc" & cmd.cmID, True)
    With myTextBox
        .Height = 15.7
        .Top = formHeight
        formHeight = formHeight + 4.3 + .Height
        .Font.size = 8
        .Font.name = "Verdana"
        .width = 150
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addDateBox:"
    End With

    Set oEvt = New evtDateBox
    Set oEvt.oDateTb = myTextBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myTextBox.Left, myTextBox.Top, tabStopIndex
    End If
End Sub

Private Sub addBooleanBox(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myCheckBox As MSForms.CheckBox
    Dim oEvt As evtCheckBox

    Set myCheckBox = fmScroll.Controls.Add("Forms.CheckBox.1", "cc" & cmd.cmID, True)
    With myCheckBox
        .Height = 15.7
        .caption = ""
        .AutoSize = True
        .Top = formHeight
        formHeight = formHeight + 4.3 + .Height
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addBooleanBox:"
    End With

    Set oEvt = New evtCheckBox
    Set oEvt.oXb = myCheckBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myCheckBox.Left, myCheckBox.Top, tabStopIndex
    End If
End Sub

Private Sub addIntegerBox(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myTextBox As MSForms.TextBox
    Dim oEvt As evtIntegerBox

    Set myTextBox = fmScroll.Controls.Add("Forms.TextBox.1", "cc" & cmd.cmID, True)
    With myTextBox
        .Height = 16
        .Top = formHeight
        formHeight = formHeight + 4.3 + .Height
        .Font.size = 8
        .Font.name = "Verdana"
        .width = 100
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addIntegerBox:"
    End With

    Set oEvt = New evtIntegerBox
    Set oEvt.oTb = myTextBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myTextBox.Left, myTextBox.Top, tabStopIndex
    End If
End Sub

Private Sub addFloatBox(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myTextBox As MSForms.TextBox
    Dim oEvt As evtNumberBox

    Set myTextBox = fmScroll.Controls.Add("Forms.TextBox.1", "cc" & cmd.cmID, True)
    With myTextBox
        .Height = 16
        .Top = formHeight
        formHeight = formHeight + 4.3 + .Height
        .Font.size = 8
        .Font.name = "Verdana"
        .width = 100
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addFloatBox:"
    End With

    Set oEvt = New evtNumberBox
    Set oEvt.oTb = myTextBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myTextBox.Left, myTextBox.Top, tabStopIndex
    End If
End Sub

Private Sub addTextBox(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myTextBox As MSForms.TextBox
    Dim oEvt As evtTextBox

    Set myTextBox = fmScroll.Controls.Add("Forms.TextBox.1", "cc" & cmd.cmID, True)
    With myTextBox
        If cmd.DataType = CMDataTypes.TextAreaType Then
            .MultiLine = True
            .EnterKeyBehavior = True
            .Height = 16 * CDbl(cmd.TextAreaRows)
        Else
            .Height = 16
        End If
        
        If cmd.MaxTextLengthSet Then
            .MaxLength = cmd.MaxTextLength
        End If
            
        .Font.size = 8
        .Font.name = "Verdana"
        .Top = formHeight
        formHeight = formHeight + 4.3 + .Height
        .width = 100
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addTextBox:"
    End With

    Set oEvt = New evtTextBox
    Set oEvt.oTb = myTextBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myTextBox.Left, myTextBox.Top, tabStopIndex
    End If
End Sub

Private Sub addDropDown(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myComboBox As MSForms.ComboBox
    Dim oEvt As evtComboBox

    Set myComboBox = fmScroll.Controls.Add("Forms.ComboBox.1", "cc" & cmd.cmID, True)
    With myComboBox
        .Height = 16
        .Top = formHeight
        formHeight = formHeight + 4.3 + .Height
        .Font.size = 8
        .Font.name = "Verdana"
        .width = 300
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addDropDown:"
        
        .AddItem " "
        Dim ddItem As struct_CMDDefItem
        For Each ddItem In cmd.ddItems
            .AddItem ddItem.DropdownValueText
        Next
    End With

    Set oEvt = New evtComboBox
    Set oEvt.oCb = myComboBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myComboBox.Left, myComboBox.Top, tabStopIndex
    End If
End Sub

Private Sub addMultiValue(idx As Integer, cmd As struct_CMDDef, ByRef formHeight As Integer, ByRef tabStopIndex As Integer)
    Dim myListBox As MSForms.ListBox
    Dim oEvt As evtListBox

    Set myListBox = fmScroll.Controls.Add("Forms.ListBox.1", "cc" & cmd.cmID, True)
    Dim hgt As Single
    If cmd.ddItems.count > 6 Then
        hgt = 6 * 11.75
    Else
        hgt = cmd.ddItems.count * 11.75
    End If
    With myListBox
        .Height = hgt
        .Top = formHeight
        formHeight = formHeight + .Height - 3
        .width = 300
        .Left = 75
        .TabIndex = tabStopIndex
        .TabStop = True
        .MultiSelect = fmMultiSelectMulti
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "cc" & cmd.cmID & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addMultiValue:"
        
        '.AddItem " "
        Dim ddItem As struct_CMDDefItem
        For Each ddItem In cmd.ddItems
            .AddItem ddItem.DropdownValueText
        Next
    End With

    Set oEvt = New evtListBox
    Set oEvt.oLb = myListBox
    moEvents.Add oEvt
    
    ' Default icon?
    If cmd.DefaultValue <> "" Then
        ' Yes
        addDefaultButton idx, myListBox.Left, myListBox.Top, tabStopIndex
    End If
End Sub

Private Sub addDefaultButton(idx As Integer, ByRef X As Integer, Y As Integer, ByRef tabStopIndex As Integer)
    Dim myCMDButton As MSForms.Image
    Dim oEvt As evtDefButton

    Set myCMDButton = fmScroll.Controls.Add("Forms.Image.1", "btn" & idx, True)
    With myCMDButton
        .AutoSize = True
        .Top = Y + 2
        .Left = X
        .picture = imgDefBtn.picture
        .BorderStyle = fmBorderStyleNone
        tabStopIndex = tabStopIndex + 1
        DebugMsgBox "btn" & idx & " at [" & .Left & "," & .Top & "] [" & .width & "," & .Height & "]", "addDefaultButton:"
    End With

    Set oEvt = New evtDefButton
    Set oEvt.oImg = myCMDButton
    moEvents.Add oEvt
End Sub

Public Sub showDefaults()
    noValidate = True
    tlContentID.caption = content.contentID
    tlLangauge.caption = content.Language
    DebugMsgBox "ChangedTitle = [" & content.ChangedTitle & "]", "showDefaults:"
    If content.ChangedTitle Then
        tbTitle.Text = content.UpdatedTitle
    Else
        tbTitle.Text = content.title
    End If
    DebugMsgBox "ChangedComments = [" & content.ChangedComments & "]", "showDefaults:"
    If content.ChangedComments Then
        tbComments.Text = content.UpdatedComments
    Else
        tbComments.Text = content.Comments
    End If
    DebugMsgBox "ChangedContactInfo = [" & content.ChangedContactInfo & "]", "showDefaults:"
    If content.ChangedContactInfo Then
        tbContactInfo.Text = content.UpdatedContactInfo
    Else
        tbContactInfo.Text = content.ContactInfo
    End If
    DebugMsgBox "ChangedAlertText = [" & content.ChangedAlertText & "]", "showDefaults:"
    If content.ChangedAlertText Then
        tbAlertText.Text = content.UpdatedAlertText
    Else
        tbAlertText.Text = content.AlertText
    End If
    DebugMsgBox "ChangedAlertEnabled = [" & content.ChangedAlertEnabled & "]", "showDefaults:"
    If content.ChangedAlertEnabled Then
        xbAlertEnabled.Value = content.UpdatedAlertEnabled
    Else
        xbAlertEnabled.Value = content.AlertEnabled
    End If
    tlContentType.caption = content.ContentType
    DebugMsgBox "ChangedDateToExpire = [" & content.ChangedDateToExpire & "]", "showDefaults:"
    If content.ChangedDateToExpire Then
        If content.UpdatedDateToExpireSet Then
            tbExpiresOn.Text = content.UpdatedDateToExpire
        Else
            tbExpiresOn.Text = ""
        End If
    Else
        If content.DateToExpireSet Then
            tbExpiresOn.Text = content.DateToExpire
        Else
            tbExpiresOn.Text = ""
        End If
    End If
    
    ' Custom meta-data?
    If content.cmdValues.count > 0 And content.cmdValues.count = cmdList.count Then
        ' Yes, and the right amount....
        Dim cmdItem As struct_CMD
        Dim idx As Integer
        For idx = 0 To content.cmdValues.count - 1
            Set cmdItem = content.cmdValues.Items(idx)
            DebugMsgBox "cc" & cmdItem.cmID & " = [" & cmdItem.ChangedValue & "]", "showDefaults:"
            If cmdItem.DataType = CMDataTypes.BooleanType Then
                If cmdItem.ChangedValue Then
                    fmScroll.Controls("cc" & cmdItem.cmID).Value = CBool(IIf(UCase(cmdItem.UpdatedValue) = "TRUE", True, False))
                Else
                    fmScroll.Controls("cc" & cmdItem.cmID).Value = CBool(IIf(UCase(cmdItem.Value) = "TRUE", True, False))
                End If
            ElseIf cmdItem.DataType = CMDataTypes.MultiValueType Then
                Dim selItems() As String
                If cmdItem.ChangedValue Then
                    selItems = Split(cmdItem.UpdatedValue, MultiValueDelimiter)
                Else
                    selItems = Split(cmdItem.Value, MultiValueDelimiter)
                End If
                
                setMultiFieldValue cmdItem.cmID, selItems
            Else
                If cmdItem.ChangedValue Then
                    fmScroll.Controls("cc" & cmdItem.cmID).Text = cmdItem.UpdatedValue
                Else
                    fmScroll.Controls("cc" & cmdItem.cmID).Text = cmdItem.Value
                End If
            End If
        Next
    End If
    noValidate = False
    enableSaveButton
    dataChanged = False
End Sub

Public Sub validateDateField(controlID As String)
Dim REX As Object
Dim dateSepChar As String

    DebugMsgBox "DateFormat [" & DateFormat & "]", "validateDateField:"
    DebugMsgBox "DateFormatRegEx [" & DateFormatRegEx & "]", "validateDateField:"
    If REX Is Nothing Then
        Set REX = CreateObject("VBScript.RegExp")
        'dateSepChar = Application.International(wdDateSeparator)
        With REX
            .Global = True
            '.Pattern = "[^0-9\/]"
            .Pattern = "^" & DateFormatRegEx & "$"
            '.Pattern = "^(([1-9])|(0[1-9])|(1[0-2]))\/((0[1-9])|([1-31]))\/((\d{2})|(\d{4}))$" ' Matches U.S. dates with leading zeros and without and with 2 or four digit years
            '.Pattern = "^(((0?[1-9]|1[012])/(0?[1-9]|1\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\d)\d{2}|0?2/29/((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$"
            .Pattern = ""
        End With
    End If
 
    DebugMsgBox "Before [" & Me.Controls(controlID).Value & "]", "validateDateField:"
    Me.Controls(controlID).Value = REX.Replace(Me.Controls(controlID).Value, vbNullString)
    DebugMsgBox "After  [" & Me.Controls(controlID).Value & "]", "validateDateField:"
    If Len(Me.Controls(controlID).Text) = 0 Or IsDate(Me.Controls(controlID).Text) Then
        Me.Controls(controlID).ForeColor = BlackText
        expDateValid = True
    Else
        Me.Controls(controlID).ForeColor = RedText
        expDateValid = False
    End If
    enableSaveButton
End Sub

Public Sub validateNumberField(controlID As String, integerOnly As Boolean)
Dim REX As Object
Dim dateSepChar As String

    DebugMsgBox "controlID = [" & controlID & "]", "validateNumberField:"
    ' Get the field definition
    Dim cmdItem As struct_CMD
    Set cmdItem = content.cmdValues(controlID)
    Dim cmdDef As struct_CMDDef
    Set cmdDef = cmdList(cmdItem.cmID)
    
    ' Let's make sure it's a number....
    If Not IsNumeric(Me.Controls(controlID).Text) Then
        Me.Controls(controlID).ForeColor = RedText
        enableSaveButton
        Exit Sub
    End If
    
    If cmdDef.MinNumericValueSet Then
        If CDec(Me.Controls(controlID).Text) < cmdDef.MinNumericValue Then
            Me.Controls(controlID).ForeColor = RedText
            enableSaveButton
            Exit Sub
        End If
    End If
      
    If cmdDef.MaxNumericValueSet Then
        If CDec(Me.Controls(controlID).Text) > cmdDef.MaxNumericValue Then
            Me.Controls(controlID).ForeColor = RedText
            enableSaveButton
            Exit Sub
        End If
    End If
  
    Me.Controls(controlID).ForeColor = BlackText
    enableSaveButton
End Sub

Public Sub enableSaveButton()
    DebugMsgBox "", "enableSaveButton:"
    
    If noValidate Then Exit Sub
    
    saveEnabled = False
    resetEnabled = False
    If (content.ChangedTitle = True And tbTitle.Text <> content.UpdatedTitle) Or _
       (content.ChangedTitle = False And tbTitle.Text <> content.title) Then
        saveEnabled = True
        resetEnabled = True
        DebugMsgBox "Title changed", "enableSaveButton:"
        tbTitle.ControlTipText = "Changed"
    Else
        tbTitle.ControlTipText = ""
    End If
    lblTitle.ForeColor = IIf(tbTitle.Text <> content.title, BurgundayText, vbBlack)
    If (content.ChangedComments = True And tbComments.Text <> content.UpdatedComments) Or _
       (content.ChangedComments = False And tbComments.Text <> content.Comments) Then
        saveEnabled = True
        resetEnabled = True
        DebugMsgBox "Comments changed", "enableSaveButton:"
        tbComments.ControlTipText = "Changed"
    Else
        tbComments.ControlTipText = ""
    End If
    lblComments.ForeColor = IIf(tbComments.Text <> content.Comments, BurgundayText, vbBlack)
    If (content.ChangedContactInfo = True And tbContactInfo.Text <> content.UpdatedContactInfo) Or _
       (content.ChangedContactInfo = False And tbContactInfo.Text <> content.ContactInfo) Then
        saveEnabled = True
        resetEnabled = True
        DebugMsgBox "ContactInfo changed", "enableSaveButton:"
        tbContactInfo.ControlTipText = "Changed"
    Else
        tbContactInfo.ControlTipText = ""
    End If
    lblContactInfo.ForeColor = IIf(tbContactInfo.Text <> content.ContactInfo, BurgundayText, vbBlack)
    If (content.ChangedAlertText = True And tbAlertText.Text <> content.UpdatedAlertText) Or _
       (content.ChangedAlertText = False And tbAlertText.Text <> content.AlertText) Then
        saveEnabled = True
        resetEnabled = True
        DebugMsgBox "AlertText changed", "enableSaveButton:"
        tbAlertText.ControlTipText = "Changed"
    Else
        tbAlertText.ControlTipText = ""
    End If
    lblAlertText.ForeColor = IIf(tbAlertText.Text <> content.AlertText, BurgundayText, vbBlack)
    
    If (content.ChangedAlertEnabled = True And xbAlertEnabled.Value <> content.UpdatedAlertEnabled) Or _
       (content.ChangedAlertEnabled = False And xbAlertEnabled.Value <> content.AlertEnabled) Then
        saveEnabled = True
        resetEnabled = True
        DebugMsgBox "AlertEnabled changed", "enableSaveButton:"
        xbAlertEnabled.ControlTipText = "Changed"
    Else
        xbAlertEnabled.ControlTipText = ""
    End If
    lblAlertEnabled.ForeColor = IIf(xbAlertEnabled.Value <> content.AlertEnabled, BurgundayText, vbBlack)
    
    ' Now lets' worry about date!
    tbExpiresOn.ControlTipText = ""
    If content.ChangedDateToExpire = True Then
        If CStr(tbExpiresOn.Text) = "" Then
            If content.UpdatedDateToExpireSet Then
                saveEnabled = True
                resetEnabled = True
                tbExpiresOn.ControlTipText = "Changed"
                DebugMsgBox "saveEnabled 2", "enableSaveButton:"
            End If
        Else
            If (content.UpdatedDateToExpireSet = False Or CStr(tbExpiresOn.Text) <> CStr(content.UpdatedDateToExpire)) Then
                saveEnabled = True
                resetEnabled = True
                tbExpiresOn.ControlTipText = "Changed"
                DebugMsgBox "saveEnabled 3", "enableSaveButton:"
            End If
        End If
    Else
        If CStr(tbExpiresOn.Text) = "" Then
            If content.DateToExpireSet Then
                saveEnabled = True
                resetEnabled = True
                tbExpiresOn.ControlTipText = "Changed"
                DebugMsgBox "saveEnabled 4", "enableSaveButton:"
            End If
        Else
            If (content.DateToExpireSet = False Or CStr(tbExpiresOn.Text) <> CStr(content.DateToExpire)) Then
                saveEnabled = True
                resetEnabled = True
                tbExpiresOn.ControlTipText = "Changed"
                DebugMsgBox "saveEnabled 5", "enableSaveButton:"
            End If
        End If
    End If
    If content.DateToExpireSet Then
        lblExpiresOn.ForeColor = IIf(CStr(tbExpiresOn.Text) <> CStr(content.DateToExpire), BurgundayText, vbBlack)
    Else
        lblExpiresOn.ForeColor = IIf(CStr(tbExpiresOn.Text) <> "", BurgundayText, vbBlack)
    End If
    
    ' Custom meta-data time?
    If content.cmdValues.count > 0 And content.cmdValues.count = cmdList.count Then
        ' Yes, and the right amount....
        Dim cmdItem As struct_CMD
        Dim idx As Integer
        For idx = 0 To content.cmdValues.count - 1
            Set cmdItem = content.cmdValues.Items(idx)
            With Me.Controls("cc" & cmdItem.cmID)
                If cmdItem.DataType = CMDataTypes.BooleanType Then
                    If (cmdItem.ChangedValue = True And .Value <> CBool(cmdItem.UpdatedValue)) Or _
                       (cmdItem.ChangedValue = False And .Value <> CBool(cmdItem.Value)) Then
                        saveEnabled = True
                        resetEnabled = True
                        DebugMsgBox "" & .name, "enableSaveButton:"
                        .ControlTipText = "Changed"
                    Else
                        .ControlTipText = ""
                    End If
                    Me.Controls("lbl" & cmdItem.cmID).ForeColor = IIf(.Value <> CBool(cmdItem.Value), BurgundayText, vbBlack)
                ElseIf cmdItem.DataType = CMDataTypes.MultiValueType Then
                    ' "construct" the current value
                    Dim curVal As String
                    curVal = getLBString(cmdItem.cmID)

                    If (cmdItem.ChangedValue = True And curVal <> cmdItem.UpdatedValue) Or _
                       (cmdItem.ChangedValue = False And curVal <> cmdItem.Value) Then
                        saveEnabled = True
                        resetEnabled = True
                        DebugMsgBox "" & .name, "enableSaveButton:"
                        .ControlTipText = "Changed"
                    Else
                        .ControlTipText = ""
                    End If
                    Me.Controls("lbl" & cmdItem.cmID).ForeColor = IIf(curVal <> cmdItem.Value, BurgundayText, vbBlack)
                Else
                    If (cmdItem.ChangedValue = True And .Text <> cmdItem.UpdatedValue) Or _
                       (cmdItem.ChangedValue = False And .Text <> cmdItem.Value) Then
                        saveEnabled = True
                        resetEnabled = True
                        DebugMsgBox "" & .name, "enableSaveButton:"
                        .ControlTipText = "Changed"
                    Else
                        .ControlTipText = ""
                    End If
                    Me.Controls("lbl" & cmdItem.cmID).ForeColor = IIf(.Text <> cmdItem.Value, BurgundayText, vbBlack)
                End If
            End With
        Next
        ' Required field checks After processing the changes.
        For idx = 0 To content.cmdValues.count - 1
            Set cmdItem = content.cmdValues.Items(idx)
            If cmdItem.Required Then
                With Me.Controls("cc" & cmdItem.cmID)
                    If cmdItem.DataType <> CMDataTypes.BooleanType Then
                        If .Text = "" Then
                            saveEnabled = False
                            Exit For
                        End If
                    End If
                End With
            End If
        Next

    End If
    ' Lastly, check the Title as a required field.
    If tbTitle.Text = "" Then
        saveEnabled = False
    End If
    
    DebugMsgBox "saveEnabled = [" & saveEnabled & "] expDateValid = [" & expDateValid & "]", "enableSaveButton:"
    If saveEnabled And expDateValid Then
        cbSave.Enabled = True
    Else
        cbSave.Enabled = False
    End If
    
    cbReset.Enabled = resetEnabled

End Sub

Public Sub defaultClicked(id As String)
    DebugMsgBox "id = [" & id & "]", "defaultClicked:"
    Dim idx As Integer
    idx = CInt(Mid(id, 4))
    Dim cmd As struct_CMDDef
    Set cmd = cmdList.Items(idx)
    With Me.Controls("cc" & cmd.cmID)
        If cmd.DataType = CMDataTypes.BooleanType Then
            If LCase(cmd.DefaultValue) = "true" Then
                .Value = True
            Else
                .Value = False
            End If
        ElseIf cmd.DataType = CMDataTypes.MultiValueType Then
            Dim selItems() As String
            selItems = Split(cmd.DefaultValue, MultiValueDelimiter)
            setMultiFieldValue cmd.cmID, selItems
        Else
            .Text = cmd.DefaultValue
        End If
    End With
End Sub

Private Function getLBString(id As String) As String
    Dim lb As MSForms.ListBox
    Set lb = Me.Controls("cc" & id)
    Dim lItem As Long
    getLBString = ""
    For lItem = 0 To lb.ListCount - 1
        If lb.selected(lItem) Then
            If Len(getLBString) > 0 Then getLBString = getLBString + MultiValueDelimiter
            getLBString = getLBString + lb.List(lItem)
        End If
    Next lItem
End Function

Private Sub setMultiFieldValue(id As String, selItems() As String)
    Dim itemCount As Integer
    itemCount = UBound(selItems) + 1
    Dim ctrl As MSForms.ListBox
    Set ctrl = Me.Controls("cc" & id)
    Dim lItem As Long
    If itemCount > 0 Then
        Dim itemName As String
        Dim itemIdx As Integer
        
        For lItem = 0 To ctrl.ListCount - 1
            ctrl.selected(lItem) = False
            For itemIdx = 0 To itemCount - 1
                itemName = selItems(itemIdx)
                If ctrl.List(lItem) = itemName Then
                    ctrl.selected(lItem) = True
                End If
            Next itemIdx
        Next lItem
    Else
        For lItem = 0 To ctrl.ListCount - 1
            ctrl.selected(lItem) = False
        Next lItem
    End If
End Sub

Public Sub ShowOrigData(ctrlLbl As MSForms.Label, ctrlText As MSForms.TextBox, startValue As String)
    If ctrlLbl.ForeColor <> BurgundayText Then Exit Sub
    
    Dim qResults As VbMsgBoxResult
    qResults = MsgBox("The original value is:" & vbNewLine & vbNewLine & startValue & vbNewLine & vbNewLine & _
                      "Would you like to revert back to the original value?", vbYesNo, ctrlLbl.caption)
    
    If qResults = vbYes Then
        ctrlText.Text = startValue
    End If
End Sub

Public Sub ShowOrigDataXB(ctrlLbl As MSForms.Label, ctrlText As MSForms.CheckBox, startValue As Boolean)
    If ctrlLbl.ForeColor <> BurgundayText Then Exit Sub
    
    Dim qResults As VbMsgBoxResult
    qResults = MsgBox("The original value is:" & vbNewLine & vbNewLine & startValue & vbNewLine & vbNewLine & _
                      "Would you like to revert back to the original value?", vbYesNo, ctrlLbl.caption)
    
    If qResults = vbYes Then
        ctrlText.Value = startValue
    End If
End Sub

Public Sub ShowOrigCMDData(ctrlLbl As MSForms.Label)
    If ctrlLbl.ForeColor <> BurgundayText Then Exit Sub
    
    Dim idx As Integer
    idx = CInt(Mid(ctrlLbl.name, 4))
    Dim cmd As struct_CMDDef
    Set cmd = getCMDDef(idx)
   
    Dim startValue As String
    Dim cmdVal As struct_CMD
    Set cmdVal = getCMDValue(cmd.cmID)
    startValue = cmdVal.Value

    Dim qResults As VbMsgBoxResult
    qResults = MsgBox("The original value is:" & vbNewLine & vbNewLine & startValue & vbNewLine & vbNewLine & _
                      "Would you like to revert back to the original value?", vbYesNo, ctrlLbl.caption)
    
    If qResults = vbYes Then
        With Me.Controls("cc" & cmd.cmID)
            If cmdVal.DataType = CMDataTypes.BooleanType Then
                .Value = CBool(IIf(UCase(startValue) = "TRUE", True, False))
            ElseIf cmdVal.DataType = CMDataTypes.MultiValueType Then
                Dim selItems() As String
                selItems = Split(startValue, MultiValueDelimiter)
                
                setMultiFieldValue cmd.cmID, selItems
            Else
                .Text = startValue
            End If
        End With
    End If
End Sub

Private Function getCMDValue(cmID As Integer) As struct_CMD
    Dim idx As Integer
    For idx = 0 To content.cmdValues.count - 1
        'Dim cmd As struct_CMD
        Set getCMDValue = content.cmdValues.Items(idx)
        If getCMDValue.cmID = cmID Then Exit Function
    Next
End Function

Private Function getCMDDef(cmID As Integer) As struct_CMDDef
    Dim idx As Integer
    For idx = 0 To cmdList.count - 1
        'Dim cmd As struct_CMDDef
        Set getCMDDef = cmdList.Items(idx)
        If getCMDDef.cmID = cmID Then Exit Function
    Next
End Function

Attribute VB_Name = "frmEditReplace"
Attribute VB_Base = "0{1B527BF4-ED6F-41F8-A50B-20D8FDFDA5AF}{78BA62CD-2A2D-4145-B2CF-53706D855AF3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub cmdOK_Click()
    Unload Me
End Sub

Private Sub UserForm_Initialize()
'    lblFinishedText.Caption = GetTemplateString("Build_frmEditReplace_Message")
'    Me.Caption = GetTemplateString("Build_frmEditReplace_Caption")
    TextBox1.Text = sMissingEditReplaces
    TextBox1.selStart = 0
    TextBox1.SelLength = 0
    
    cmdOK.ForeColor = EnableMenu
    ActiveDocument.Activate
    Application.Activate
End Sub

Attribute VB_Name = "frmFinished"
Attribute VB_Base = "0{964757F3-D0DA-42A5-998C-BFBA2D9A9F22}{913802C2-EF21-4A8F-8ABF-50A6B64B1FA9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub cmdOK_Click()
    Unload Me
End Sub

Public Sub PDFMessage()
    lblMsg.caption = "Click OK to convert it to PDF format."
    Me.Show vbModal
End Sub

Private Sub UserForm_Initialize()
    'lblFinishedText.Caption = GetTemplateString("Build_frmFinished_Message")

    cmdOK.ForeColor = EnableMenu
    ActiveDocument.Activate
    Application.Activate
End Sub

Attribute VB_Name = "frmFormatting"
Attribute VB_Base = "0{0C9D74E7-92F4-402B-8146-61F581EF7AE2}{10B46C20-18F6-45EA-93C7-136D22D24C7D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'------------------------------------------------------------------------------
'  require variable declarations: set array bases to 1
'------------------------------------------------------------------------------
Option Explicit: Option Base 1

Private Sub cboStyle_Change()
    On Error Resume Next
    Me.txtDescription.Text = ActiveDocument.Styles(Me.cboStyle.Text).description
End Sub

Private Sub cmdHelp_Click()
    modWS.CallContextHelp (192)
End Sub

Private Sub UserForm_Initialize()
    cmdApply.ForeColor = EnableMenu
    cmdCancel.ForeColor = EnableMenu
    cmdCreate.ForeColor = EnableMenu

    'LoadStrings
    LoadDropdowns
    LoadSelectionInfo

End Sub

Private Sub LoadStrings()
'    Select Case lTemplateMode
'        Case MODE_BULKLOAD
'            chkCombineAH.Caption = GetTemplateString("Bulkload_frmOptions_chkCombineAH")
'        Case MODE_BURST
'            chkCombineAH.Caption = GetTemplateString("Burst_frmOptions_chkCombineAH")
'    End Select

    Me.lblDescription.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblDescription")
    Me.lblFormatting.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblFormatting")
    Me.lblNewStyle.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblNewStyle")
    Me.lblNewStyleSection.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblNewStyleSection")
    Me.lblSelectStyle.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblSelectStyle")
    Me.lblSelectStyleSection.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblSelectStyleSection")
    Me.lblSelectType.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_lblSelectType")
    'cmdCancel.Caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_cmdCancel")
    cmdHelp.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_cmdHelp")
    cmdApply.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_cmdApply")
    cmdCreate.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_cmdCreate")
    Me.caption = GetTemplateString("BurstBulkloadEdit_frmFormatting_WindowCaption") 'SmartMarking Options

End Sub

Private Sub LoadDropdowns()
    'Add possible marking options
    
    Select Case GetTemplateMode(ActiveDocument)
        Case "SantWordBulkLoad"
            cboContentType.AddItem "Title" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Question")) 'Question
            cboContentType.AddItem "Content" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Answer")) 'Answer
        Case "SantRFPFileWordEdit", "SantRFPCompareContent" 'Includes Burst
            cboContentType.AddItem "Header" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Header")) 'Header
            cboContentType.AddItem "Question" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Question")) 'Question
            cboContentType.AddItem "Answer" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_Answer")) 'Answer
            cboContentType.AddItem "Table" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_FeatureMatrix")) 'FeatureMatrix
            cboContentType.AddItem "Header Row" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_HeaderRow")) 'HeaderRow
            cboContentType.AddItem "Question Row" '(GetTemplateString("BurstBulkloadEdit_frmFormatting_QuestionRow")) 'QuestionRow
    End Select
    
    'Load the style dropdown with the styles that are in use in this document.
    If cboStyle.ListCount < 1 Then
        Dim AvailableStyle As Style
        For Each AvailableStyle In ActiveDocument.Styles
            If AvailableStyle.InUse Then
                Debug.Print AvailableStyle.NameLocal & ": [" & AvailableStyle.InUse & "] [" & AvailableStyle.Visibility & "] [" & AvailableStyle.BuiltIn & "]"
                If Not AvailableStyle.Visibility Then
                    cboStyle.AddItem AvailableStyle.NameLocal
                End If
            End If
        Next
    End If
End Sub

Private Sub LoadSelectionInfo()
    Dim CurrentRange As Range
    Dim SelectedType As String
    Dim SelectedStyle As String
    
    Set CurrentRange = Selection.Range
    If Not Selection.Style Is Nothing Then
        SelectedStyle = Selection.Style.NameLocal
        cboStyle.Text = SelectedStyle
    End If
    
    SelectedType = modTools.FindCurrentMarker
    
    If InStr(1, SelectedType, "HeaderRow") > 0 Then
        Me.cboContentType.Text = "Header Row" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_HeaderRow")
    ElseIf InStr(1, SelectedType, "QuestionRow") > 0 Then
        Me.cboContentType.Text = "Question Row" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_QuestionRow")
    ElseIf InStr(1, SelectedType, "Header") > 0 Then
        Me.cboContentType.Text = "Header" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_Header")
    ElseIf InStr(1, SelectedType, "Question") > 0 Then
        Me.cboContentType.Text = "Question" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_Question")
    ElseIf InStr(1, SelectedType, "Answer") > 0 Then
        Me.cboContentType.Text = "Answer" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_Answer")
    ElseIf InStr(1, SelectedType, "FeatureMatrix") > 0 Then
        Me.cboContentType.Text = "Table" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_FeatureMatrix")
    End If
    
    CurrentRange.Select
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Sub cmdApply_Click()
    Dim i As Integer
    Dim MarkerTextPart As String
    Dim currentPar As Paragraph
    Dim sMappingInfo As String
    Dim sMappingInfoArray() As String
    sMappingInfo = GetPropertyText("CheckedOutRecords", ActiveDocument)
    sMappingInfoArray = Split(sMappingInfo, "|")
    
    Select Case cboContentType.Text
        Case "Header Row" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_HeaderRow")
            MarkerTextPart = "HeaderRow_"
        Case "Question Row" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_QuestionRow")
            MarkerTextPart = "QuestionRow_"
        Case "Header" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_Header")
            MarkerTextPart = "Header_"
        Case "Question" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_Question")
            MarkerTextPart = "Question_"
        Case "Answer" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_Answer")
            MarkerTextPart = "Answer_"
        Case "Table" 'GetTemplateString("BurstBulkloadEdit_frmFormatting_FeatureMatrix")
            MarkerTextPart = "FeatureMatrix_"
        Case Else
            Unload Me
            Exit Sub
    End Select
    
    For i = LBound(sMappingInfoArray) To UBound(sMappingInfoArray)

        If InStr(1, sMappingInfoArray(i), MarkerTextPart) > 0 Then
            SelectRecord sMappingInfoArray(i), True
            On Error Resume Next
            For Each currentPar In Selection.Paragraphs
                If currentPar.Range.Bookmarks(1).Start <> currentPar.Range.Start Then
                    currentPar.Style = cboStyle.Text
                End If
            Next currentPar
            ActiveDocument.UndoClear
        End If
        
    Next i
    
    Unload Me

End Sub

Private Sub cmdCreate_Click()
    On Error Resume Next
    ActiveDocument.Styles.Add txtNewStyle.Text
    cboStyle.AddItem txtNewStyle.Text
    Me.cboStyle.Text = txtNewStyle.Text
End Sub
Attribute VB_Name = "frmImages"
Attribute VB_Base = "0{CFCC50EF-B82E-4C57-A5AE-60638928AF5F}{376EEC4C-177A-4A66-88DD-D63270D88ED6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Attribute VB_Name = "frmJobTitle"
Attribute VB_Base = "0{0A54FFB6-23EC-488C-A39D-BB8F65F6B962}{75A09D75-70AC-449C-8A30-66D69AFEE410}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public sOrigTitle As String
Public savePressed As Boolean

Private Sub cbCancel_Click()
    savePressed = False
    Me.Hide
End Sub

Private Sub cbSave_Click()
    savePressed = True
    Me.Hide
End Sub

Private Sub labHelp_Click()
    launchHelpFile HelpTopics.JobProperties
End Sub

Private Sub labHelp_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    labHelp.Font.Underline = True
End Sub

Private Sub lbMore_Click()
    If lbMore.caption = "more" Then
        lbMore.caption = "less"
        lblFolder.visible = True
        tlFolder.visible = True
        lblJobID.visible = True
        tlJobID.visible = True
        cbSave.Top = cbSave.Top + 42
        cbCancel.Top = cbCancel.Top + 42
        lbMore.Top = lbMore.Top + 42
        Me.Height = Me.Height + 42
    Else
        lbMore.caption = "more"
        lblFolder.visible = False
        tlFolder.visible = False
        lblJobID.visible = False
        tlJobID.visible = False
        cbSave.Top = cbSave.Top - 42
        cbCancel.Top = cbCancel.Top - 42
        lbMore.Top = lbMore.Top - 42
        Me.Height = Me.Height - 42
    End If
End Sub

Private Sub txtJobTitle_Change()
    enableSaveButton
End Sub

Private Sub txtJobTitle_Enter()
    mOrigBackColour = txtJobTitle.BackColor
    txtJobTitle.BackColor = FocusColour
End Sub

Private Sub txtJobTitle_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    txtJobTitle.BackColor = mOrigBackColour
End Sub

Private Sub txtJobTitle_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    KeyCode = tbValidate(KeyCode, Shift)
End Sub

Private Function tbValidate(ByVal KeyCode1 As Integer, ByVal Shift As Integer)

    ' Windows kernel forbids the use of characters in range 1-31 (i.e., 0x01-0x1F)
    ' and characters " * : < > ? \ / |
    If KeyCode1 < 32 Then
        Select Case KeyCode1
            Case 8      ' backspace
            Case 9      ' tab
            Case 13     ' enter
            Case Else
                KeyCode1 = 0
        End Select
    Else
        Select Case KeyCode1
            Case 222, 56, 186, 188, 190 ' " * : < > when shift = 1
                If Shift = 1 Then KeyCode1 = 0
            Case 191, 220 ' ? / \ |
                KeyCode1 = 0
            Case Else
        End Select
    End If
    
    tbValidate = KeyCode1
End Function

Private Sub UserForm_Initialize()
    savePressed = False
    
    ' We are going to manually position the menu's to get ready for different langauges.
    labHelp.ForeColor = &HFF0000
    labHelp.Top = lblJobTitle.Top
    labHelp.Left = Me.width - labHelp.width - 12
    txtJobTitle.Left = lblJobTitle.Left + lblJobTitle.width + 3
    txtJobTitle.width = labHelp.Left - txtJobTitle.Left - 12
    lblFolder.Left = lblJobTitle.Left
    tlFolder.Left = txtJobTitle.Left
    tlFolder.width = txtJobTitle.width
    tlJobID.Left = txtJobTitle.Left
    tlJobID.width = txtJobTitle.width
   
    cbCancel.Left = Me.width - cbCancel.width - 12
    cbSave.Left = cbCancel.Left - cbSave.width - 5
    lbMore_Click
    cbSave.Enabled = False
End Sub

Private Sub enableSaveButton()
    If txtJobTitle.Text <> "" And sOrigTitle <> txtJobTitle.Text Then
        If gMultiEditFile.doesJobTitleExist(txtJobTitle.Text) Then
            txtJobTitle.ForeColor = vbRed
            cbSave.Enabled = False
        Else
            txtJobTitle.ForeColor = vbBlack
            cbSave.Enabled = True
        End If
    Else
        cbSave.Enabled = False
    End If
End Sub

Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    labHelp.Font.Underline = False
End Sub
Attribute VB_Name = "frmLogin"
Attribute VB_Base = "0{678AE121-4389-4020-BA9D-04A1684C467A}{494CE87A-8102-403C-91EE-DAA32CF82A36}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private okEnabled As Boolean
Public UserID As String
Public password As String
Public bSingleSignOn As Boolean
Public bRemember As Boolean
Public bCanceled As Boolean

Private Sub cmdCancel_Click()
    bCanceled = True
    bRemember = False
    Me.Hide
End Sub

Private Sub cmdHelp_Click()
    frmLoginHelp.Show vbModal
End Sub

Private Sub cmdLogin_Click()
    If okEnabled Then
        UserID = tbUserID.Text
        password = tbPassword.Text
        bSingleSignOn = xbSingleSignOn.Value
        bRemember = xbRemember.Value
        bCanceled = False
        Me.Hide
    End If
End Sub

Private Sub enableLoginButton()
    If (tbUserID.Text <> "" And tbPassword.Text <> "") Or xbSingleSignOn.Value Then
        cmdLogin.picture = frmImages.imgBtn56.picture
        okEnabled = True
    Else
        cmdLogin.picture = frmImages.imgBtn56D.picture
        okEnabled = False
    End If

End Sub

Private Sub cmdReset_Click()
    modWSTools.resetLoginCredentials
    UserForm_Initialize
End Sub

Private Sub tbPassword_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    enableLoginButton
End Sub

Private Sub tbUserID_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    enableLoginButton
End Sub

Private Sub UserForm_Initialize()
    cmdReset.ForeColor = EnableMenu
    cmdLogin.ForeColor = EnableMenu
    cmdCancel.ForeColor = EnableMenu
    lblUserID.ForeColor = EnableMenu
    lblPassword.ForeColor = EnableMenu

    Dim UserID As String
    Dim password As String
    Dim bSingleSignOn As Boolean
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    If QvidianServer = "" Then
        QvidianServer = GetDefaultServer()
    End If

    modWSTools.getLoginCredentials UserID, password, bSingleSignOn
    tbUserID.Text = UserID
    'tbPassword.Text = password
    xbSingleSignOn.Value = bSingleSignOn
    enableLoginButton

    If Not bSingleSignOn Then
        If UserID = "" Then
            tbUserID.SetFocus
        Else
            tbPassword.SetFocus
        End If
    End If
End Sub

Private Sub xbSingleSignOn_Change()
    If xbSingleSignOn.Value Then
        tbUserID.Enabled = False
        tbUserID.Text = ""
        tbPassword.Enabled = False
        tbPassword.Text = ""
    Else
        tbUserID.Enabled = True
        tbPassword.Enabled = True
    End If
    enableLoginButton
End Sub

Public Sub SetAllowReset(allowReset)
    If allowReset Then
        cmdLogin.caption = "Set"
    Else
        cmdLogin.caption = "Login"
    End If
    cmdReset.visible = allowReset
End Sub
Attribute VB_Name = "frmLoginHelp"
Attribute VB_Base = "0{3501AADC-1F64-4B15-9273-EE36C7FF30CB}{9DA9E97A-4ADE-47F5-898B-E132E3DE9477}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cmdCancel_Click()
    Unload Me
End Sub
Attribute VB_Name = "frmMultiEdits"
Attribute VB_Base = "0{3C946FDB-1D72-4C39-BBF8-7BD818C680F8}{9174272D-8B9D-4B47-B980-91D0AC542A5C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private pLastRowIdClicked As Integer
Private pCurrentContentID As Long

Const HWND_DESKTOP = 0
Const LOGPIXELSX = 88
Const LOGPIXELSY = 90

Private moEvents As Collection
Private TwipsPerPixelX As Single
Private TwipsPerPixelY As Single
Private EnteredFakeMenu As Boolean

Private mAnythingChanged As Boolean

Private Type MENUITEMINFO
    cbSize As Long
    fMask As Long
    fType As Long
    fState As Long
    wID As Long
    hSubMenu As Long
    hbmpChecked As Long
    hbmpUnchecked As Long
    dwItemData As Long
    dwTypeData As String
    cch As Long
End Type
Private Type POINTAPI
    X As Long
    Y As Long
End Type


' Flags for TrackPopupMenu
Private Const TPM_LEFTBUTTON = &H0&
Private Const TPM_RIGHTBUTTON = &H2&
Private Const TPM_LEFTALIGN = &H0&
Private Const TPM_CENTERALIGN = &H4&
Private Const TPM_RIGHTALIGN = &H8&
Private Const MF_STRING = &H0&
Private Const TPM_RETURNCMD = &H100&
Private Const MIIM_ID = &H2
Private Const MIIM_STATE As Long = &H1&

Private Const MIIM_TYPE = &H10
Private Const MIIM_DATA = &H20
Private Const MFS_DISABLED = &H3
Private Const MFS_ENABLED = &H0

Private pt As POINTAPI
Private objMNU As MENUITEMINFO

Private Const cdlOFNFileMustExist = &H1000

#If Win64 Then


Private Type OPENFILENAME
    lStructSize As Long
    hwndOwner As LongPtr
    hInstance As LongPtr
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As LongPtr
    lpTemplateName As String
End Type

Private lngHwndLV As LongPtr
Private lngMnuLV As LongPtr
Private mlHwnd As LongPtr
Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hWnd As LongPtr, ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long

Private Type TPMPARAMS
    cbSize As Long
    rcExclude As RECT
End Type

Private Declare PtrSafe Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function CreatePopupMenu Lib "user32" () As LongPtr
Private Declare PtrSafe Function TrackPopupMenuEx Lib "user32" (ByVal hMenu As LongPtr, ByVal un As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal hWnd As LongPtr, lpTPMParams As TPMPARAMS) As Long
Private Declare PtrSafe Function InsertMenuItem Lib "user32" Alias "InsertMenuItemA" (ByVal hMenu As LongPtr, ByVal un As Long, ByVal bool As Long, ByRef lpcMenuItemInfo As MENUITEMINFO) As Long
Private Declare PtrSafe Function DestroyMenu Lib "user32" (ByVal hMenu As LongPtr) As Long
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long

Private Sub setTwipsPerPixelX()
  Dim intDC As LongPtr
  intDC = GetDC(HWND_DESKTOP)
  TwipsPerPixelX = 1440 / GetDeviceCaps(intDC, LOGPIXELSX) / 20
  ReleaseDC HWND_DESKTOP, intDC
End Sub

Private Sub setTwipsPerPixelY()
  Dim intDC As LongPtr
  intDC = GetDC(HWND_DESKTOP)
  TwipsPerPixelY = 1440 / GetDeviceCaps(intDC, LOGPIXELSY) / 20
  ReleaseDC HWND_DESKTOP, intDC
End Sub

Private Sub addContextMenyItem(lngMNU As LongPtr, title As String, id As Long, fState As Long)
    With objMNU
        .cbSize = Len(objMNU)
        .fMask = MIIM_TYPE Or MIIM_ID Or MIIM_DATA Or MIIM_STATE
        .dwTypeData = title
        .cch = Len(title)
        .fType = MF_STRING
        .wID = id
        .fState = fState
    End With
    Call InsertMenuItem(lngMNU, id, 1, objMNU)
End Sub
#Else

Private Type OPENFILENAME
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type

Private lngHwndLV As Long
Private lngMnuLV As Long
Private Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hDC As Long) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long

Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare Function CreatePopupMenu Lib "user32" () As Long
Private Declare Function TrackPopupMenuEx Lib "user32" (ByVal hMenu As Long, ByVal un As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal hWnd As Long, lpTPMParams As Any) As Long
Private Declare Function InsertMenuItem Lib "user32" Alias "InsertMenuItemA" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Long, lpcMenuItemInfo As MENUITEMINFO) As Long
Private Declare Function DestroyMenu Lib "user32" (ByVal hMenu As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long

Private Sub setTwipsPerPixelX()
  Dim intDC As Long
  intDC = GetDC(HWND_DESKTOP)
  TwipsPerPixelX = 1440 / GetDeviceCaps(intDC, LOGPIXELSX) / 20
  ReleaseDC HWND_DESKTOP, intDC
End Sub

Private Sub setTwipsPerPixelY()
  Dim intDC As Long
  intDC = GetDC(HWND_DESKTOP)
  TwipsPerPixelY = 1440 / GetDeviceCaps(intDC, LOGPIXELSY) / 20
  ReleaseDC HWND_DESKTOP, intDC
End Sub

Private Sub addContextMenyItem(lngMNU As Long, title As String, id As Long, fState As Long)
    With objMNU
        .cbSize = Len(objMNU)
        .fMask = MIIM_TYPE Or MIIM_ID Or MIIM_DATA Or MIIM_STATE
        .dwTypeData = title
        .cch = Len(title)
        .fType = MF_STRING
        .wID = id
        .fState = fState
    End With
    Call InsertMenuItem(lngMNU, id, 1, objMNU)
End Sub
#End If

Public Function loadNewJobFile(parJobTitle As String, parJobID As String, parJobFolder As String) As Boolean
    loadNewJobFile = True
    
    ' Add the job file to the combo box
    gMultiEditFile.AddJobFileValue parJobTitle, parJobID, parJobFolder
    currentJobTitle = parJobTitle
    currentJobID = parJobID
    comJobs.Text = currentJobTitle
    
    If Not gIsMultiEditShowing Then
        DebugMsgBox "apparently we're not already showing, so show us again.", "loadNewJobFile:"
        Me.Show vbModeless
        gIsMultiEditShowing = True
    End If
    loadNewJobFile = False
End Function

Private Sub comJobs_Change()
    DebugMsgBox "[" & comJobs.Text & "]", "comJobs_Change:"
    If comJobs.Text <> "" Then
        comJobs.MatchRequired = True
        currentJobTitle = comJobs.Text
        If gMultiEditFile Is Nothing Then
            DebugMsgBox "gMultiEditFile is NOTHING  - not sure how:(", "comJobs_Change:"
            Set gMultiEditFile = New clsMultiEdit
            DebugMsgBox "reload the Multi Edit file", "comJobs_Change:"
            gMultiEditFile.loadMultiEditFile
        End If
        currentJobID = gMultiEditFile.jobFileData(currentJobTitle)
        currentJobFolder = gMultiEditFile.jobFolderData(currentJobTitle)
        DebugMsgBox "[" & currentJobFolder & "] or [" & currentJobID & "]", "comJobs_Change:"
        ' Open the selected file
        If currentJobID <> "" Then
            Set gJobFile = Nothing
            deselectAllContent
            loadJobFileIntoGrid currentJobFolder, currentJobTitle, currentJobID
        End If
    Else
        comJobs.MatchRequired = False
    End If
End Sub

Private Sub comJobs_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If comJobs.ListIndex < 0 Then
        comJobs.MatchRequired = False
    End If
End Sub


Public Sub reloadGridFromJobFile()
    DebugMsgBox "", "reloadGridFromJobFile:"
    Dim X As Single
    Dim Y As Single
    X = 0
    Dim row As Integer
    row = 1
    
    If gJobFile Is Nothing Then
        Exit Sub
    End If
    
    If fakeGrid.Controls.count > 0 Then
        fakeGrid.Controls.Clear
    End If
    Set moEvents = New Collection
    
    ' Update the dialog title
    Me.caption = "Multi Edit jobs - " & gJobFile.JobQvidianServer

    ' Now load the grid....
    Dim state As Integer
    state = 0
    If gJobFile.isCompositeEdit Then
        gJobFile.compositeContent.selected = True
        selectedContentIDs.Add CLng(gJobFile.compositeContent.contentID)
        If gJobFile.compositeContent.FileModified Then
           state = 1
        End If
        addRowGraphic row, 0, X, Y, 20, state, fmTextAlignCenter, gJobFile.compositeContent.selected
        addRowGraphic row, 1, X, Y, 20, 0, fmTextAlignCenter, gJobFile.compositeContent.selected
        addRowLabel row, 2, X, Y, 60, "", fmTextAlignLeft, gJobFile.compositeContent.selected
        
        addRowLabel row, 3, X, Y, 80, "", fmTextAlignCenter, gJobFile.compositeContent.selected
        addRowLabel row, 4, X, Y, 467, gJobFile.compositeContent.title, fmTextAlignLeft, gJobFile.compositeContent.selected
        addRowLabel row, 5, X, Y, 87, "", fmTextAlignCenter, gJobFile.compositeContent.selected
        addRowLabel row, 6, X, Y, 147, "", fmTextAlignLeft, gJobFile.compositeContent.selected

        addRowLabel row, 7, X, Y, 87, "", fmTextAlignCenter, gJobFile.compositeContent.selected
        addRowLabel row, 8, X, Y, 60, "", fmTextAlignCenter, gJobFile.compositeContent.selected
        addRowLabel row, 9, X, Y, 467, "", fmTextAlignLeft, gJobFile.compositeContent.selected
        addRowLabel row, 10, X, Y, 237, "", fmTextAlignLeft, gJobFile.compositeContent.selected
        Y = addRowLabel(row, 11, X, Y, 237, gJobFile.compositeContent.ContentFilename, fmTextAlignLeft, gJobFile.compositeContent.selected)
    Else
        If Not gJobFile.contentList Is Nothing And gJobFile.contentList.count > 0 Then
            Dim content As struct_Content
            Dim rowID As String
    
            For Each content In gJobFile.contentList
                X = 0
                If content.contentID > 0 Then
                    Dim tmpTitle As String
                    tmpTitle = ""
                    state = 0
                    If content.FileModified Then
                       state = 1
                    End If
                    addRowGraphic row, 0, X, Y, 20, state, fmTextAlignCenter, content.selected
                    state = 0
                    If content.MetadataModified Then
                       state = 3
                    End If
                    addRowGraphic row, 1, X, Y, 20, state, fmTextAlignCenter, content.selected
                    addRowLabel row, 2, X, Y, 60, content.contentID, fmTextAlignLeft, content.selected
                    
                    addRowLabel row, 3, X, Y, 80, content.ContentType, fmTextAlignCenter, content.selected
                    If content.ChangedTitle Then
                        tmpTitle = content.UpdatedTitle
                    Else
                        tmpTitle = content.title
                    End If
                    addRowLabel row, 4, X, Y, 467, tmpTitle, fmTextAlignLeft, content.selected
                    If content.ChangedDateToExpire Then
                        If content.UpdatedDateToExpireSet Then
                            tmpTitle = JustDate(content.UpdatedDateToExpire)
                        Else
                            tmpTitle = ""
                        End If
                    Else
                        If content.DateToExpireSet Then
                            tmpTitle = JustDate(content.DateToExpire)
                        Else
                            tmpTitle = ""
                        End If
                    End If
                    addRowLabel row, 5, X, Y, 87, tmpTitle, fmTextAlignCenter, content.selected
                    addRowLabel row, 6, X, Y, 147, content.Owners, fmTextAlignLeft, content.selected
    
                    If content.DateLastModifiedSet Then
                        tmpTitle = content.DateLastModified
                    Else
                        tmpTitle = ""
                    End If
                    addRowLabel row, 7, X, Y, 87, tmpTitle, fmTextAlignCenter, content.selected
                    addRowLabel row, 8, X, Y, 60, content.TimesUsed, fmTextAlignCenter, content.selected
                    If content.ChangedComments Then
                        tmpTitle = content.UpdatedComments
                    Else
                        tmpTitle = content.Comments
                    End If
                    addRowLabel row, 9, X, Y, 467, tmpTitle, fmTextAlignLeft, content.selected
                    If content.ChangedAlertText Then
                        tmpTitle = content.UpdatedAlertText
                    Else
                        tmpTitle = content.AlertText
                    End If
                    addRowLabel row, 10, X, Y, 237, tmpTitle, fmTextAlignLeft, content.selected
                    Y = addRowLabel(row, 11, X, Y, 237, content.ContentFilename, fmTextAlignLeft, content.selected)
                    
                    row = row + 1
                End If
            Next
        End If
    End If
    fakeGrid.scrollHeight = Y
    
    updateMenuStates
End Sub

Public Sub loadJobFileIntoGrid(parFolderName As String, parJobTitle As String, parJobID As String)
    DebugMsgBox "[" & parFolderName & "] [" & parJobTitle & "] [" & parJobID & "]", "loadJobFileIntoGrid:"
    Dim forceLoad As Boolean
    
    If gJobFile Is Nothing Then
        Set gJobFile = New clsJob
        forceLoad = False
    Else
        forceLoad = True
    End If
    If gJobFile.openJobFile(parFolderName, parJobTitle, parJobID, forceLoad) Then
        reloadGridFromJobFile
    Else
        ' Can only get here if it's a bad Job file, so refresh our drop-down of jobs.
        ReloadMultiEditFile
        updateMenuStates
    End If
    
End Sub

Public Sub ReloadMultiEditFile()
    DebugMsgBox "", "ReloadMultiEditFile:"
    Set selectedContentIDs = New Collection
    mAnythingChanged = False
    If gMultiEditFile Is Nothing Then
        Set gMultiEditFile = New clsMultiEdit
    End If
    
    ' Load the job file in - see if anything changed.
    If gMultiEditFile.loadMultiEditFile Then Exit Sub
    
    ' Something changed, clear out the combo....
    comJobs.Clear
    comJobs.MatchRequired = False
    
    ' add it to the drop-down
    Dim idx As Integer
    With gMultiEditFile.jobFileData
        For idx = 0 To .count - 1
            'Dim jobID As String
            Dim title As String
            title = CStr(.Keys(idx))
            'jobID = .Items(idx)
            comJobs.AddItem title
            
            If currentJobTitle = "" Then
                currentJobTitle = title
            End If
        Next idx
    End With
    comJobs.Text = currentJobTitle
    If comJobs.ListCount > 0 Then comJobs.MatchRequired = False
    
    updateMenuStates
End Sub

Public Sub selectContentByID(contentID As Long)
    Dim content As struct_Content
    Set selectedContentIDs = Nothing
    Set selectedContentIDs = New Collection
    mAnythingChanged = True
    Dim row As Integer
    row = 1
    DebugMsgBox "contentID is [" & contentID & "]", "selectContentByID:"
    If contentID = ContentIDCompositeEdit Then
        DebugMsgBox "Selecting a Composite Edit file...", "selectContentByID:"
        Set content = gJobFile.compositeContent
        content.contentID = ContentIDCompositeEdit
        pCurrentContentID = content.contentID
        pLastRowIdClicked = row
        content.selected = True
        selectedContentIDs.Add CLng(content.contentID)
        If Not (content.FileModified Or content.MetadataModified) Then
            mAnythingChanged = False
        End If
    Else
        For Each content In gJobFile.contentList
            If content.contentID = contentID Then
                pCurrentContentID = content.contentID
                pLastRowIdClicked = row
                content.selected = True
                selectedContentIDs.Add CLng(content.contentID)
                If Not (content.FileModified Or content.MetadataModified) Then
                    mAnythingChanged = False
                End If
            Else
                content.selected = False
            End If
            row = row + 1
        Next
    End If
    
    gJobForm.HighlightGrid
    updateMenuStates
End Sub

Public Function getCurrentContentID()
    getCurrentContentID = pCurrentContentID
End Function

Private Sub fakeGrid_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    hideFakeMenu
End Sub

Private Sub fakeHeader_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    hideFakeMenu
End Sub

Private Sub fakeMenu_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    EnteredFakeMenu = True
    frameTTOn.BorderColor = &H8000000F
    frameTTOff.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub frameReplace_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameReplace.BorderColor = RGB(174, 207, 247)
    frameTTOff.BorderColor = &H8000000F
    frameTTOn.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub frameReplaceAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOff.BorderColor = &H8000000F
    frameTTOn.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = RGB(174, 207, 247)
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub frameSelectTemplate_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOff.BorderColor = &H8000000F
    frameTTOn.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = RGB(174, 207, 247)
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub frameSelectTemplateAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOff.BorderColor = &H8000000F
    frameTTOn.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = RGB(174, 207, 247)
End Sub

Private Sub labCancel_Click()
    If labCancel.ForeColor = EnableMenu Then
        modMultiEdit.Cancel
    End If
End Sub

Private Sub labCancel_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labCancel.ForeColor = EnableMenu Then
        labCancel.Font.Underline = True
    End If
End Sub

Private Sub labCancelAll_Click()
    If labCancelAll.ForeColor = EnableMenu Then
        modMultiEdit.CancelALL
    End If
End Sub

Private Sub labCancelAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labCancelAll.ForeColor = EnableMenu Then
        labCancelAll.Font.Underline = True
    End If
End Sub

Private Sub labFakeReplace_Click()
    With fakeMenu
        .visible = False
        .Enabled = False
    End With

    modMultiEdit.GlobalReplaceInternal True
End Sub

Private Sub labFakeReplace_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOn.BorderColor = &H8000000F
    frameTTOff.BorderColor = &H8000000F
    frameReplace.BorderColor = RGB(174, 207, 247)
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub labFakeReplaceAll_Click()
    If labFakeReplaceAll.ForeColor = DisableMenu Then Exit Sub
    With fakeMenu
        .visible = False
        .Enabled = False
    End With
    
    modMultiEdit.GlobalReplaceInternal False
End Sub

Private Sub labFakeReplaceAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOn.BorderColor = &H8000000F
    frameTTOff.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = RGB(174, 207, 247)
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub labFakeSelectTemplate_Click()
    With fakeMenu
        .visible = False
        .Enabled = False
    End With
    
    modInit.ActivateCurrent
    modWS.ShowExtDialog WordTemplatesDialog
End Sub

Private Sub labFakeSelectTemplate_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOn.BorderColor = &H8000000F
    frameTTOff.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = RGB(174, 207, 247)
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub labFakeSelectTemplateAll_Click()
    If labFakeSelectTemplateAll.ForeColor = DisableMenu Then Exit Sub
    With fakeMenu
        .visible = False
        .Enabled = False
    End With
    
    modInit.ActivateCurrent
    modWS.ShowExtDialog WordTemplatesDialog, True
End Sub

Private Sub labFakeSelectTemplateAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOn.BorderColor = &H8000000F
    frameTTOff.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = RGB(174, 207, 247)
End Sub

Private Sub labFakeTrackChangesOff_Click()
    If labFakeTrackChangesOff.ForeColor = DisableMenu Then Exit Sub
    With fakeMenu
        .visible = False
        .Enabled = False
    End With
    
    modInit.ActivateCurrent
    modMultiEdit.TrackChangesInternal False
End Sub

Private Sub labFakeTrackChangesOff_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOff.BorderColor = RGB(174, 207, 247)
    frameTTOn.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub labFakeTrackChangesOn_Click()
    If labFakeTrackChangesOn.ForeColor = EnableMenu Then
        With fakeMenu
            .visible = False
            .Enabled = False
        End With
        
        modInit.ActivateCurrent
        modMultiEdit.TrackChangesInternal True
    End If
End Sub

Private Sub labFakeTrackChangesOn_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameTTOn.BorderColor = RGB(174, 207, 247)
    frameTTOff.BorderColor = &H8000000F
    frameReplace.BorderColor = &H8000000F
    frameReplaceAll.BorderColor = &H8000000F
    frameSelectTemplate.BorderColor = &H8000000F
    frameSelectTemplateAll.BorderColor = &H8000000F
End Sub

Private Sub labHelp_Click()
    launchHelpFile HelpTopics.JobManager
End Sub

Private Sub labHelp_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    labHelp.Font.Underline = True
End Sub

Private Sub labJobProps_Click()
    If labJobProps.ForeColor = EnableMenu Then
        Dim title As frmJobTitle
        
        Set title = New frmJobTitle
        title.sOrigTitle = currentJobTitle
        title.txtJobTitle.Text = currentJobTitle
        title.txtJobTitle.SetFocus
        title.tlFolder.caption = currentJobFolder
        title.tlJobID.caption = currentJobID
        title.cbSave.caption = "Save"
    
        title.Show vbModal
        
        Dim saveCurrentContentID As Long
        saveCurrentContentID = currentContentID
        
        Debug.Print title.txtJobTitle.Text
        DebugMsgBox "gIsMultiEditShowing before rename [" & gIsMultiEditShowing & "]", "labJobProps:"
        DebugMsgBox "currentContentID before rename [" & currentContentID & "]", "labJobProps:"
        If title.savePressed And title.txtJobTitle.Text <> currentJobTitle Then
            If gMultiEditFile.updateJobTitle(currentJobID, currentJobTitle, title.txtJobTitle.Text) Then
                ' Update the drop-down too.
                comJobs.RemoveItem (comJobs.ListIndex)
                currentJobTitle = title.txtJobTitle.Text
                comJobs.AddItem (currentJobTitle)
                comJobs.Text = currentJobTitle
            End If
            DebugMsgBox "gIsMultiEditShowing after rename [" & gIsMultiEditShowing & "]", "labJobProps:"
            If gIsMultiEditShowing Then
                DebugMsgBox "saveCurrentContentID after rename [" & saveCurrentContentID & "]", "labJobProps:"
                gJobForm.selectContentByID saveCurrentContentID
                currentContentID = saveCurrentContentID
            End If
        End If
    End If
End Sub

Private Sub labJobProps_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labJobProps.ForeColor = EnableMenu Then
        labJobProps.Font.Underline = True
    End If
End Sub

Private Sub labOpen_Click()
    If labOpen.ForeColor = EnableMenu Then
        labOpen.Font.Underline = False
        LabelDoubleClick
    End If
End Sub

Private Sub labOpen_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labOpen.ForeColor = EnableMenu Then
        labOpen.Font.Underline = True
    End If
End Sub

Private Sub labProperties_Click()
    If labProperties.ForeColor = EnableMenu Then
        labProperties.Font.Underline = False
        ChangeContentProperties getCurrentContentID
    End If
End Sub

Private Sub labProperties_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labProperties.ForeColor = EnableMenu Then
        labProperties.Font.Underline = True
    End If
End Sub

Private Sub labReset_Click()
    If labReset.ForeColor = EnableMenu Then
        modMultiEdit.Reset
    End If
End Sub

Private Sub labReset_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labReset.ForeColor = EnableMenu Then
        labReset.Font.Underline = True
    End If
End Sub

Private Sub labSave_Click()
    If labSave.ForeColor = EnableMenu Then
        modMultiEdit.Save
    End If
End Sub

Private Sub labSave_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labSave.ForeColor = EnableMenu Then
        labSave.Font.Underline = True
    End If
End Sub

Private Sub labSaveAll_Click()
    If labSaveAll.ForeColor = EnableMenu Then
        modMultiEdit.SaveAll
    End If
End Sub

Private Sub labSaveAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labSaveAll.ForeColor = EnableMenu Then
        labSaveAll.Font.Underline = True
    End If
End Sub

Private Sub deselectAllContent()
    Dim content As struct_Content
    If Not gJobFile Is Nothing Then
        For Each content In gJobFile.contentList
            content.selected = False
        Next
    End If
    mAnythingChanged = False
    Set selectedContentIDs = Nothing
    Set selectedContentIDs = New Collection
    DebugMsgBox "currentContentID = " & currentContentID, "deselectAllContent:"
    currentContentID = ContentIDNotSet
End Sub

Private Sub updateMenuStates()
    DebugMsgBox "selectedContentIDs.count = " & selectedContentIDs.count, "updateMenuStates:"
    
    If gJobFile Is Nothing Or comJobs.ListCount = 0 Then
        labSaveAll.ForeColor = DisableMenu
        labCancelAll.ForeColor = DisableMenu
        labSave.ForeColor = DisableMenu
        labReset.ForeColor = DisableMenu
        labCancel.ForeColor = DisableMenu
        labOpen.ForeColor = DisableMenu
        labProperties.ForeColor = DisableMenu
        labJobProps.ForeColor = DisableMenu
        labTools.ForeColor = DisableMenu
        imgDownArrow.visible = False
        imgDownArrowD.visible = True
        Exit Sub
    End If
    
    labJobProps.ForeColor = EnableMenu
    ' Only allow a save if something has changed...
    Dim anythingChanged As Boolean
    anythingChanged = False
    Dim content As struct_Content
    Dim saveEnable As Boolean
    saveEnable = True
    
    If gJobFile.isCompositeEdit Then
        DebugMsgBox "selected = " & gJobFile.compositeContent.selected & " FileModified = " & gJobFile.compositeContent.FileModified, "updateMenuStates:"
        If gJobFile.compositeContent.FileModified Then
            anythingChanged = True
            'Exit For
        End If
        If gJobFile.compositeContent.selected Then
            If Not (gJobFile.compositeContent.FileModified) Then saveEnable = False
        End If
        labFakeTrackChangesOn.ForeColor = DisableMenu
        labFakeTrackChangesOff.ForeColor = DisableMenu
        labFakeSelectTemplateAll.ForeColor = DisableMenu
        labFakeReplaceAll.ForeColor = DisableMenu
    Else
        If Not gJobFile.contentList Is Nothing Then
            For Each content In gJobFile.contentList
                DebugMsgBox "selected = " & content.selected & " FileModified = " & content.FileModified & " MetadataModified = " & content.MetadataModified, "updateMenuStates:"
                If content.FileModified Or content.MetadataModified Then
                    anythingChanged = True
                    'Exit For
                End If
                If content.selected Then
                    If Not (content.FileModified Or content.MetadataModified) Then saveEnable = False
                End If
            Next
        End If
        labFakeTrackChangesOn.ForeColor = EnableMenu
        labFakeTrackChangesOff.ForeColor = EnableMenu
        labFakeSelectTemplateAll.ForeColor = EnableMenu
        labFakeReplaceAll.ForeColor = EnableMenu
    End If
    labSaveAll.ForeColor = IIf(anythingChanged, EnableMenu, DisableMenu)
    labCancelAll.ForeColor = EnableMenu
    labTools.ForeColor = EnableMenu
    imgDownArrow.visible = True
    imgDownArrowD.visible = False
    anythingChanged = False
    DebugMsgBox "saveEnable = " & saveEnable, "updateMenuStates:"
    Select Case selectedContentIDs.count
        Case 0
            labSave.ForeColor = DisableMenu
            labReset.ForeColor = DisableMenu
            labCancel.ForeColor = DisableMenu
            labOpen.ForeColor = DisableMenu
            labProperties.ForeColor = DisableMenu

        Case 1
            labSave.ForeColor = IIf(saveEnable, EnableMenu, DisableMenu)
            labReset.ForeColor = labSave.ForeColor
            labCancel.ForeColor = EnableMenu
            labOpen.ForeColor = EnableMenu
            labProperties.ForeColor = EnableMenu
        
        Case Else
            labSave.ForeColor = IIf(saveEnable, EnableMenu, DisableMenu)
            labReset.ForeColor = labSave.ForeColor
            labCancel.ForeColor = EnableMenu
            labOpen.ForeColor = DisableMenu
            labProperties.ForeColor = DisableMenu
    End Select
    If gJobFile.isCompositeEdit Then
        labProperties.ForeColor = DisableMenu
    End If
End Sub

Private Sub labTools_Click()
    If labTools.ForeColor <> EnableMenu Then Exit Sub
    
#If Win64 Then
    DebugMsgBox "show the fake menu...", "labTools_Click:"
    With frameTTOn
        .visible = True
        .Enabled = True ' IIf(gJobFile.isCompositeEdit, False, True)
    End With
    With frameTTOff
        .visible = True
        .Enabled = frameTTOn.Enabled
    End With
    With frameReplace
        .visible = True
        .Enabled = True
    End With
    With frameReplaceAll
        .visible = True
        .Enabled = frameTTOn.Enabled
    End With
    With frameSelectTemplate
        .visible = True
        .Enabled = True
    End With
    With frameSelectTemplateAll
        .visible = True
        .Enabled = frameTTOn.Enabled
    End With
    With fakeMenu
        .visible = True
        .Enabled = True
    End With
    EnteredFakeMenu = False
#Else
    lngMnuLV = CreatePopupMenu()
    DebugMsgBox "lngHwndLV = [" & lngHwndLV & "]", "labTools_Click:"
    addContextMenyItem lngMnuLV, "Track Changes On", 1, IIf(gJobFile.isCompositeEdit, MFS_DISABLED, MFS_ENABLED)
    addContextMenyItem lngMnuLV, "Track Changes Off", 2, IIf(gJobFile.isCompositeEdit, MFS_DISABLED, MFS_ENABLED)
    addContextMenyItem lngMnuLV, "Replace", 3, MFS_ENABLED
    addContextMenyItem lngMnuLV, "Replace All", 4, IIf(gJobFile.isCompositeEdit, MFS_DISABLED, MFS_ENABLED)
    addContextMenyItem lngMnuLV, "Select Style Template", 5, MFS_ENABLED
    addContextMenyItem lngMnuLV, "Select Style Template for All", 6, IIf(gJobFile.isCompositeEdit, MFS_DISABLED, MFS_ENABLED)
    
    GetCursorPos pt
    #If Win64 Then
    Dim lngID As LongPtr
    Dim temp As TPMPARAMS
    lngID = TrackPopupMenuEx(lngMnuLV, TPM_RETURNCMD, pt.X - 12, pt.Y + 12, lngHwndLV, temp)
    #Else
    Dim lngID As Long
    lngID = TrackPopupMenuEx(lngMnuLV, TPM_RETURNCMD, pt.X - 12, pt.Y + 11, lngHwndLV, ByVal 0&)
    #End If
    Select Case lngID
        Case 1
            If Not gJobFile.isCompositeEdit Then
                ' Track Changes On
                modMultiEdit.TrackChangesInternal True
            End If
        Case 2
            If Not gJobFile.isCompositeEdit Then
                ' Track Changes Off
                modMultiEdit.TrackChangesInternal False
            End If
        Case 3
            modMultiEdit.GlobalReplaceInternal True
        Case 4
            If Not gJobFile.isCompositeEdit Then
                modMultiEdit.GlobalReplaceInternal False
            End If
        Case 5
            modInit.ActivateCurrent
            modWS.ShowExtDialog WordTemplatesDialog
        Case 6
            If Not gJobFile.isCompositeEdit Then
                modInit.ActivateCurrent
                modWS.ShowExtDialog WordTemplatesDialog, True
            End If
    End Select

    DestroyMenu (lngHwndLV)
#End If
End Sub

Private Sub labTools_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If labTools.ForeColor = EnableMenu Then
        labTools.Font.Underline = True
    End If
End Sub

Private Sub UserForm_Resize()
    DebugMsgBox "", "UserForm_Resize: "
    ReloadMultiEditFile
End Sub

Private Sub UserForm_Initialize()
    lngHwndLV = FindWindow(vbNullString, Me.caption)
    DebugMsgBox "form handle is [" & lngHwndLV & "]", "UserForm_Initialize:"
    
    setTwipsPerPixelX
    setTwipsPerPixelY
    
    ' Grab us some sizes and locations...
    Dim Top As Integer
    Top = getRegUserDword("HKEY_CURRENT_USER\Software\Qvidian\MultiEditTop")
    If Top > 0 Then
        Me.StartUpPosition = 0
        Me.Top = Top
    End If
    Dim Left As Integer
    Left = getRegUserDword("HKEY_CURRENT_USER\Software\Qvidian\MultiEditLeft")
    If Left > 0 Then
        Me.StartUpPosition = 0
        Me.Left = Left
    End If
    Me.Height = 189
    
    ' We are going to manually position the menu's to get ready for different langauges.
    comJobs.Left = Label1.Left + Label1.width + 1
    labJobProps.Left = comJobs.Left + comJobs.width + 3
    labSaveAll.Left = labJobProps.Left + labJobProps.width + 15
    labCancelAll.Left = labSaveAll.Left + labSaveAll.width + 5
    labTools.Left = labCancelAll.Left + labCancelAll.width + 5
    imgDownArrow.Left = labTools.Left + labTools.width + 1
    imgDownArrow.Top = labTools.Top + 3
    imgDownArrowD.Left = labTools.Left + labTools.width + 1
    imgDownArrowD.Top = labTools.Top + 3
    imgDownArrowD.visible = False
    Label2.Left = imgDownArrow.Left + imgDownArrow.width + 15
    labOpen.Left = Label2.Left + Label2.width + 3
    labSave.Left = labOpen.Left + labOpen.width + 5
    labReset.Left = labSave.Left + labSave.width + 5
    labProperties.Left = labReset.Left + labReset.width + 5
    labCancel.Left = labProperties.Left + labProperties.width + 5
    labHelp.Left = Me.width - labHelp.width - 12
    
    labSave.ForeColor = EnableMenu
    labReset.ForeColor = EnableMenu
    labSaveAll.ForeColor = EnableMenu
    labCancel.ForeColor = EnableMenu
    labCancelAll.ForeColor = EnableMenu
    labTools.ForeColor = EnableMenu
    labJobProps.ForeColor = EnableMenu
    labOpen.ForeColor = EnableMenu
    labProperties.ForeColor = EnableMenu
    labHelp.ForeColor = &HFF0000

    ' Even though this is set up for all breads, ONLY 64-bit Office
    ' uses the controls to do the fake Tools menu.
    With labFakeTrackChangesOn
        .ForeColor = EnableMenu
        .Left = 12
        .Top = 3 * TwipsPerPixelY
    End With
    With labFakeTrackChangesOff
        .ForeColor = EnableMenu
        .Left = 12
        .Top = labFakeTrackChangesOn.Top
    End With
    With labFakeReplace
        .ForeColor = EnableMenu
        .Left = 12
        .Top = labFakeTrackChangesOn.Top
    End With
    With labFakeReplaceAll
        .ForeColor = EnableMenu
        .Left = 12
        .Top = labFakeTrackChangesOn.Top
    End With
    With labFakeSelectTemplate
        .ForeColor = EnableMenu
        .Left = 12
        .Top = labFakeTrackChangesOn.Top
    End With
    With labFakeSelectTemplateAll
        .ForeColor = EnableMenu
        .Left = 12
        .Top = labFakeTrackChangesOn.Top
    End With
    With frameTTOn
        .Left = 2 * TwipsPerPixelX
        .Top = 2 * TwipsPerPixelY
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &H8000000F
        .Height = (labFakeTrackChangesOn.Top * 2 * TwipsPerPixelY) + labFakeTrackChangesOn.Height
        .Height = labFakeTrackChangesOn.Top + labFakeTrackChangesOn.Height + (5 * TwipsPerPixelY)
        .width = frameSelectTemplateAll.width 'Widest control
        .visible = False
        .Enabled = False
    End With
    With frameTTOff
        .Left = frameTTOn.Left
        .Top = frameTTOn.Top + frameTTOn.Height
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &H8000000F
        .Height = frameTTOn.Height
        .width = frameSelectTemplateAll.width 'Widest control
        .visible = False
        .Enabled = False
    End With
    With frameReplace
        .Left = frameTTOff.Left
        .Top = frameTTOff.Top + frameTTOff.Height
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &H8000000F
        .Height = frameTTOff.Height
        .width = frameSelectTemplateAll.width 'Widest control
        .visible = False
        .Enabled = False
    End With
    With frameReplaceAll
        .Left = frameReplace.Left
        .Top = frameReplace.Top + frameReplace.Height
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &H8000000F
        .Height = frameReplace.Height
        .width = frameSelectTemplateAll.width 'Widest control
        .visible = False
        .Enabled = False
    End With
    With frameSelectTemplate
        .Left = frameReplace.Left
        .Top = frameReplaceAll.Top + frameReplaceAll.Height
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &H8000000F
        .Height = frameReplace.Height
        .width = frameSelectTemplateAll.width 'Widest control
        .visible = False
        .Enabled = False
    End With
    With frameSelectTemplateAll
        .Left = frameReplace.Left
        .Top = frameSelectTemplate.Top + frameSelectTemplate.Height
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &H8000000F
        .Height = frameReplace.Height
        .visible = False
        .Enabled = False
    End With
    With fakeMenu
        .Left = labTools.Left
        .Top = labTools.Top + labTools.Height + 2
        .visible = False
        .Enabled = False
        .width = frameSelectTemplateAll.Left + frameSelectTemplateAll.width + 3 'Use widest menu option.
        .Height = frameSelectTemplateAll.Top + frameSelectTemplateAll.Height + 3 'Use last menu option.
    End With
    EnteredFakeMenu = False
        
    With Me.fakeHeader
        .Left = 6
        .Top = 30
        .BorderStyle = fmBorderStyleNone
    End With
    With fakeGrid
        .width = Me.width - 20
        .Height = 120
    End With
    
    displayHeader

    ' Check to see if we have any files?
    ReloadMultiEditFile
End Sub

Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    labJobProps.Font.Underline = False
    labOpen.Font.Underline = False
    labProperties.Font.Underline = False
    labReset.Font.Underline = False
    labSave.Font.Underline = False
    labSaveAll.Font.Underline = False
    labCancel.Font.Underline = False
    labCancelAll.Font.Underline = False
    labHelp.Font.Underline = False
    labTools.Font.Underline = False
    
#If Win64 Then
    hideFakeMenu
#End If
End Sub

Private Sub hideFakeMenu()
    If EnteredFakeMenu Then
        With frameTTOn
            .visible = False
            .Enabled = False
        End With
        With frameTTOff
            .visible = False
            .Enabled = False
        End With
        With frameReplace
            .visible = False
            .Enabled = False
        End With
        With frameReplaceAll
            .visible = False
            .Enabled = False
        End With
        With frameSelectTemplate
            .visible = False
            .Enabled = False
        End With
        With frameSelectTemplateAll
            .visible = False
            .Enabled = False
        End With
        With fakeMenu
            .visible = False
            .Enabled = False
        End With
    End If
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    gIsMultiEditShowing = False
    Set moEvents = Nothing
    saveLocation
End Sub

Public Sub saveLocation()
    DebugMsgBox "Size [" & Me.width & "," & Me.Height & "]", "saveLocation:"
    DebugMsgBox "Location [" & Me.Left & "," & Me.Top & "]", "saveLocation:"
    setRegUserDword "HKEY_CURRENT_USER\Software\Qvidian\MultiEditLeft", Me.Left
    setRegUserDword "HKEY_CURRENT_USER\Software\Qvidian\MultiEditTop", Me.Top
End Sub

Public Function SelectFileOpenDialog() As String
Dim strTemp, strTemp1, pathStr As String
Dim i, n, j As Long
Dim OpenFile As OPENFILENAME
Dim lReturn As Long
Dim sFilter As String
Dim Fname As String

    OpenFile.lStructSize = Len(OpenFile)
    sFilter = "Zip file (*.zip)" & Chr(0) & "*.zip" & Chr(0)
    OpenFile.lpstrFilter = sFilter
    OpenFile.nFilterIndex = 1
    OpenFile.lpstrFile = String(257, 0)
    OpenFile.nMaxFile = Len(OpenFile.lpstrFile) - 1
    OpenFile.lpstrFileTitle = OpenFile.lpstrFile
    OpenFile.nMaxFileTitle = OpenFile.nMaxFile
    OpenFile.lpstrInitialDir = "C:\"
    OpenFile.lpstrTitle = "Locate the SME Zip file to Import..."
    OpenFile.flags = cdlOFNFileMustExist

    lReturn = GetOpenFileName(OpenFile)
    
    If lReturn = 0 Then
        MsgBox "You didn't select any file"
    Else
        'MsgBox "The user Chose " & Trim(OpenFile.lpstrFile)
        
        Fname = Trim$(OpenFile.lpstrFileTitle) ' copy the filename to "Fname"
        
        n = FileLen(OpenFile.lpstrFile) 'length of the file
    End If
    
    SelectFileOpenDialog = Fname
End Function

Public Sub updateModifiedFlag()
    Dim content As struct_Content
    Dim row As Integer
    row = 1
    Dim bgColor As Long
    If gJobFile.isCompositeEdit Then
        gJobFile.compositeContent.FileModified = True
        fakeGrid.Controls("bgrow_" & row & "_0").picture = imgDisk.picture
    Else
        For Each content In gJobFile.contentList
            
            If content.contentID = currentContentID Then
                content.FileModified = True
                fakeGrid.Controls("bgrow_" & row & "_0").picture = imgDisk.picture
                Exit For
            End If
            row = row + 1
        Next
    End If
    
    mAnythingChanged = True
    updateMenuStates
End Sub

Public Sub HighlightGrid()
    Dim content As struct_Content
    Dim row As Integer
    row = 1
    Dim bgColor As Long
    If gJobFile.isCompositeEdit Then
        If gJobFile.compositeContent.selected Then
            bgColor = &HA9FAFF
        Else
            bgColor = vbWhite
        End If
        fakeGrid.Controls("bgrow_" & row & "_0").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_1").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_2").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_3").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_4").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_5").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_6").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_7").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_8").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_9").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_10").BackColor = bgColor
        fakeGrid.Controls("bgrow_" & row & "_11").BackColor = bgColor
    Else
        For Each content In gJobFile.contentList
            
            If content.selected Then
                bgColor = &HA9FAFF
            Else
                bgColor = vbWhite
            End If
            fakeGrid.Controls("bgrow_" & row & "_0").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_1").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_2").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_3").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_4").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_5").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_6").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_7").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_8").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_9").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_10").BackColor = bgColor
            fakeGrid.Controls("bgrow_" & row & "_11").BackColor = bgColor
            row = row + 1
        Next
    End If
End Sub

Private Sub displayHeader()
    Dim X As Single
    Dim Y As Single
    X = 0
    ' -   Content ID
    ' -   Content type
    ' -   Document Title
    ' -   Expiration date
    ' -   Content Owner
    ' -   Last Modified
    ' -   Times Used
    ' -   Comments
    ' -   Alert Text
    ' -   File name
    addHeaderLabel 0, X, 20, "", fmTextAlignCenter                 ' 15 = 20
    addHeaderLabel 1, X, 20, "", fmTextAlignCenter                 ' 15 = 20
    addHeaderLabel 2, X, 60, " ID", fmTextAlignLeft                ' 45 = 60
    addHeaderLabel 3, X, 80, " Type", fmTextAlignCenter            ' 60 = 80
    addHeaderLabel 4, X, 467, " Title", fmTextAlignLeft            ' 350 = 467
    addHeaderLabel 5, X, 87, " Expires on", fmTextAlignCenter      ' 65 =  87
    addHeaderLabel 6, X, 147, " Content Owner", fmTextAlignLeft    ' 110 = 147
    addHeaderLabel 7, X, 87, " Last Modified", fmTextAlignCenter   ' 65 =  87
    addHeaderLabel 8, X, 60, " Times Used", fmTextAlignCenter      ' 45 = 60
    addHeaderLabel 9, X, 467, " Comments", fmTextAlignLeft         ' 350 = 467
    addHeaderLabel 10, X, 237, " Alert Text", fmTextAlignLeft      ' 178 = 237
    Y = addHeaderLabel(11, X, 237, " File Name", fmTextAlignLeft)  ' 178 = 237
    
    fakeHeader.width = fakeGrid.width - 12.75
    fakeHeader.ScrollWidth = X
    fakeHeader.Height = Y
    fakeGrid.Left = fakeHeader.Left
    fakeGrid.ScrollWidth = X
    fakeGrid.Top = fakeHeader.Top + fakeHeader.Height
End Sub

Private Function addHeaderLabel(col As Integer, ByRef X As Single, width As Integer, lbl As String, align As fmTextAlign) As Single
    Dim lblHdr As MSForms.Label

    Set lblHdr = fakeHeader.Controls.Add("Forms.Label.1", "row_0_" & col)
    With lblHdr
        .Left = X
        .Top = 0
        .width = width * TwipsPerPixelX
        .Height = 14
        .TextAlign = align
        .caption = lbl
        .BackColor = &H8000000F
        .BorderStyle = fmBorderStyleNone
        .SpecialEffect = fmSpecialEffectRaised
    End With
    X = X + lblHdr.width
    
    addHeaderLabel = lblHdr.Top + lblHdr.Height
End Function

Private Function addRowGraphic(row As Integer, col As Integer, ByRef X As Single, ByRef Y As Single, _
                               width As Integer, state As Integer, align As fmTextAlign, sel As Boolean) As Single
    
    Dim id As String
    id = "row_" & row & "_" & col
    Dim lblBorder As MSForms.Label
    Set lblBorder = fakeGrid.Controls.Add("Forms.Label.1", "bg" & id)
    With lblBorder
        .Left = X
        .Top = Y
        .width = (width * TwipsPerPixelX) + TwipsPerPixelX
        .Height = 19 * TwipsPerPixelY
        .caption = ""
        .BackStyle = fmBackStyleOpaque
        If sel Then
            .BackColor = &HA9FAFF
        Else
            .BackColor = vbWhite
        End If
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &HF0F0F0
        .SpecialEffect = fmSpecialEffectFlat
        .Font.name = "Verdana"
        .Font.size = 8
        .TextAlign = align
    End With

    Dim oEvt As evtImage
    Dim imgIcon As MSForms.Image
    Set imgIcon = fakeGrid.Controls.Add("Forms.Image.1", id)
    With imgIcon
        .Left = X + (3 * TwipsPerPixelX)
        .Top = Y + (2 * TwipsPerPixelY)
        .BackStyle = fmBackStyleTransparent
        .BorderStyle = fmBorderStyleNone
        .AutoSize = True
        If state = 1 Then
            .picture = imgDisk.picture
        ElseIf state = 2 Then
            .picture = imgLocked.picture
        ElseIf state = 3 Then
            .picture = imgMetaSave.picture
        Else
        End If
    End With

    Set oEvt = New evtImage
    Set oEvt.oImg = imgIcon
    moEvents.Add oEvt
    
    X = lblBorder.Left + lblBorder.width - TwipsPerPixelX
    
    addRowGraphic = lblBorder.Top + lblBorder.Height - TwipsPerPixelY
End Function

Private Function addRowLabel(row As Integer, col As Integer, ByRef X As Single, ByRef Y As Single, _
                             width As Integer, lbl As String, align As fmTextAlign, sel As Boolean) As Single
    
    Dim id As String
    id = "row_" & row & "_" & col
    Dim lblBorder As MSForms.Label
    Set lblBorder = fakeGrid.Controls.Add("Forms.Label.1", "bg" & id)
    With lblBorder
        .Left = X
        .Top = Y
        .width = (width * TwipsPerPixelX) + TwipsPerPixelX
        .Height = 19 * TwipsPerPixelY
        .caption = ""
        .BackStyle = fmBackStyleOpaque
        If sel Then
            .BackColor = &HA9FAFF
        Else
            .BackColor = vbWhite
        End If
        .BorderStyle = fmBorderStyleSingle
        .BorderColor = &HF0F0F0
        .SpecialEffect = fmSpecialEffectFlat
        .Font.name = "Verdana"
        .Font.size = 8
        .TextAlign = align
    End With

    Dim oEvt As evtLabel
    Dim lblText As MSForms.Label
    Set lblText = fakeGrid.Controls.Add("Forms.Label.1", id)
    With lblText
        .Top = Y + (3 * TwipsPerPixelY)
        .Height = 12
        .BackStyle = fmBackStyleTransparent
        .BorderStyle = fmBorderStyleNone
        .SpecialEffect = fmSpecialEffectFlat
        .ForeColor = vbBlack
        .Font.name = "Verdana"
        .Font.size = 8
        .TextAlign = align
        .WordWrap = False
        .caption = lbl
        .AutoSize = True
        If .width > (width * TwipsPerPixelX) + TwipsPerPixelX Then
            DebugMsgBox "control width is [" & .width & "] > [" & (width * TwipsPerPixelX) + TwipsPerPixelX & "] for [" & lbl & "]", "addRowLabel:"
            .ControlTipText = lbl
        End If
        .WordWrap = True
        .AutoSize = False
        If align = fmTextAlignCenter Then
            .Left = X
            .width = (width * TwipsPerPixelX) + TwipsPerPixelX
        Else
            .Left = X + (2 * TwipsPerPixelX)
            .width = (width - 2) * TwipsPerPixelX
        End If
    End With

    Set oEvt = New evtLabel
    Set oEvt.oLbl = lblText
    moEvents.Add oEvt
    
    X = lblBorder.Left + lblBorder.width - TwipsPerPixelX
    
    addRowLabel = lblBorder.Top + lblBorder.Height - TwipsPerPixelY
End Function

Private Sub fakeGrid_Scroll(ByVal ActionX As MSForms.fmScrollAction, ByVal ActionY As MSForms.fmScrollAction, ByVal RequestDx As Single, ByVal RequestDy As Single, ByVal ActualDx As MSForms.ReturnSingle, ByVal ActualDy As MSForms.ReturnSingle)
    Debug.Print ActionX & " "; ActionY & " " & RequestDx & " " & RequestDy
    Debug.Print fakeGrid.ScrollLeft & " " & fakeGrid.ScrollTop
    If ActionX > 0 Then
        fakeHeader.ScrollLeft = fakeHeader.ScrollLeft + RequestDx
    End If
End Sub

Public Sub LabelClick(id As String, shiftPressed As Boolean, ctrl As Boolean)
    DebugMsgBox id, "LabelClick:"
    Dim idParts() As String

    idParts = Split(id, "_")
    Dim rowID As Integer
    rowID = idParts(1)
    DebugMsgBox rowID, "LabelClick:"
    
    Dim content As struct_Content
    Dim row As Integer
    row = 1
    Set selectedContentIDs = Nothing
    Set selectedContentIDs = New Collection
    mAnythingChanged = True
    If gJobFile.isCompositeEdit Then
        If ctrl Then
            gJobFile.compositeContent.selected = Not gJobFile.compositeContent.selected
        Else
            gJobFile.compositeContent.selected = True
        End If
        
        If gJobFile.compositeContent.selected Then
            selectedContentIDs.Add CLng(gJobFile.compositeContent.contentID)
            If Not (gJobFile.compositeContent.FileModified) Then
                mAnythingChanged = False
            End If
        End If
        pCurrentContentID = gJobFile.compositeContent.contentID
    Else
        If shiftPressed And pLastRowIdClicked > 0 Then
            Dim lowerID As Integer
            Dim higherID As Integer
            If pLastRowIdClicked > rowID Then
                lowerID = rowID
                higherID = pLastRowIdClicked
            Else
                lowerID = pLastRowIdClicked
                higherID = rowID
            End If
            For Each content In gJobFile.contentList
                If row >= lowerID And row <= higherID Then
                    content.selected = True
                Else
                    If Not ctrl Then
                        content.selected = False
                    End If
                End If
                
                If content.selected Then
                    selectedContentIDs.Add CLng(content.contentID)
                    If Not (content.FileModified Or content.MetadataModified) Then
                        mAnythingChanged = False
                    End If
                End If
                row = row + 1
            Next
        Else
            If gJobFile.isCompositeEdit Then
            Else
                For Each content In gJobFile.contentList
                    If row = rowID Then
                        If ctrl Then
                            content.selected = Not content.selected
                        Else
                            content.selected = True
                        End If
                    Else
                        If Not ctrl Then
                            content.selected = False
                        End If
                    End If
                    
                    If content.selected Then
                        selectedContentIDs.Add CLng(content.contentID)
                        If Not (content.FileModified Or content.MetadataModified) Then
                            mAnythingChanged = False
                        End If
                    End If
                    row = row + 1
                Next
            End If
        End If
        Set content = gJobFile.contentList(rowID)
        
        pCurrentContentID = content.contentID
    End If
    
    pLastRowIdClicked = rowID
    gJobForm.HighlightGrid
    updateMenuStates
End Sub

Public Sub FakeMouseUp(id As String, ByVal Button As Integer, shiftPressed As Boolean, ctrl As Boolean, _
                       ByVal X As Single, ByVal Y As Single)
    DebugMsgBox CStr(IIf(selectedContentIDs.count = 1, MFS_ENABLED, MFS_DISABLED)), "FakeMouseUp:"
    If Button = 2 Then
        ' We need to work out if the curssor is currently over a selected row
        ' or not.
        DebugMsgBox id, "FakeMouseUp:"
        Dim idParts() As String
    
        idParts = Split(id, "_")
        Dim rowID As Integer
        rowID = idParts(1)
        DebugMsgBox rowID, "FakeMouseUp:"
        
        Dim content As struct_Content
        Dim row As Integer
        row = 1
        For Each content In gJobFile.contentList
            If row = rowID Then
                If Not content.selected Then
                    ' We're not over a currently selected row, so we now
                    ' select THIS row.
                    LabelClick id, shiftPressed, ctrl
                End If
                Exit For
            End If
            row = row + 1
        Next
    
        DebugMsgBox "Selected the item: " & CStr(IIf(selectedContentIDs.count = 1, MFS_ENABLED, MFS_DISABLED)), "FakeMouseUp:"

        lngMnuLV = CreatePopupMenu()
        DebugMsgBox "lngHwndLV = [" & lngHwndLV & "]", "FakeMouseUp:"
        addContextMenyItem lngMnuLV, "Open", 1, IIf(selectedContentIDs.count = 1, MFS_ENABLED, MFS_DISABLED)
        addContextMenyItem lngMnuLV, "Save", 2, IIf(mAnythingChanged, MFS_ENABLED, MFS_DISABLED)
        addContextMenyItem lngMnuLV, "Reset", 3, IIf(mAnythingChanged, MFS_ENABLED, MFS_DISABLED)
        addContextMenyItem lngMnuLV, "Properties", 4, IIf(selectedContentIDs.count = 1, MFS_ENABLED, MFS_DISABLED)
        addContextMenyItem lngMnuLV, "Cancel", 5, MFS_ENABLED

        GetCursorPos pt
        #If Win64 Then
        Dim lngID As LongPtr
        Dim temp As TPMPARAMS
        lngID = TrackPopupMenuEx(lngMnuLV, TPM_RETURNCMD, pt.X, pt.Y, lngHwndLV, temp)
        #Else
        Dim lngID As Long
        lngID = TrackPopupMenuEx(lngMnuLV, TPM_RETURNCMD, pt.X, pt.Y, lngHwndLV, ByVal 0&)
        #End If
        Select Case lngID
            Case 1
                LabelDoubleClick
            Case 2
                modMultiEdit.Save
            Case 3
                modMultiEdit.Reset
            Case 4
                ChangeContentProperties getCurrentContentID
            Case 5
                modMultiEdit.Cancel
        End Select

        DestroyMenu (lngHwndLV)
    End If
End Sub

Public Sub FakeMouseMove(id As String, ByVal Button As Integer, shiftPressed As Boolean, ctrl As Boolean, _
                         ByVal X As Single, ByVal Y As Single)
    'DebugMsgBox CStr(IIf(selectedContentIDs.count = 1, MFS_ENABLED, MFS_DISABLED)), "FakeMouseMove:"
    hideFakeMenu
End Sub

Public Sub LabelDoubleClick()
    DebugMsgBox "", "LabelDoubleClick:"
    On Error Resume Next
    DebugMsgBox "double clicked on ContentID: " & getCurrentContentID, "LabelDoubleClick:"
    
    modMultiEdit.openContentFile getCurrentContentID
    DebugMsgBox "back from modMultiEdit.openContentFile", "LabelDoubleClick:"
    
    ' The open *could* have done a save, which would have reloaded bJobList,
    ' which trashes the .selected flag on the content. So, we need to reapply
    ' selected ID's
    If Not selectedContentIDs Is Nothing Then
        Dim content As struct_Content
        
        If gJobFile.isCompositeEdit Then
            gJobFile.compositeContent.selected = True
        Else
            If Not gJobFile.contentList Is Nothing Then
                Dim item As Variant
                Dim id As Long
                For Each content In gJobFile.contentList
                    For Each item In selectedContentIDs
                        id = CLng(item)
                        If id = content.contentID Then
                            DebugMsgBox "ContentID [" & id & "] is selected", "LabelDoubleClick:"
                            content.selected = True
                            Exit For
                        End If
                    Next
                Next
            End If
        End If
    End If
    
    updateMenuStates
End Sub

Public Sub ClearOutGrid()
    If fakeGrid.Controls.count > 0 Then
        fakeGrid.Controls.Clear
        DoEvents
    End If
    Set moEvents = New Collection
End Sub
Attribute VB_Name = "frmProgressBar"
Attribute VB_Base = "0{CCF59451-E47E-4903-8B64-22733184A7C5}{1D0E4AEF-853D-445D-9B52-913EE7B856F3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Dim iFormMode As Integer

Public Sub StartAdvancedSmartMarking()
    lblMessageText.caption = "Your document is being marked..."
    'cmdCancel.Caption = "Cancel" 'GetPropertyText("CancelButtonText")
    iFormMode = 2
    Me.Show vbModal
End Sub

Public Sub StartSmartMarking()
    lblMessageText.caption = "Your document is being marked..."
    'cmdCancel.Caption = "Cancel"
    iFormMode = 3
    Me.Show vbModal
End Sub
Public Sub StartGeneric(X As String)
    lblMessageText.caption = X
    iFormMode = 4
    Me.Show vbModeless
End Sub

Private Sub UserForm_Activate()
    Select Case iFormMode
        Case 2
            SmartMarking.StartAdvancedSmartMarking Me
        Case 3
            SmartMarking.StartSmartMarking Me
    End Select
    If iFormMode < 4 Then
        Unload Me
    End If
End Sub

Private Sub UserForm_Initialize()
    lblMessageText.caption = ""
    cmdCancel.ForeColor = EnableMenu
End Sub


'-------------------------------------------------------------------------------------------
' Function: UpdateProgressBarStatus
' Purpose:  Calculates the percentage the current operation has completed.  Updates display.
' Input:    TotalSectionCount, Counter, sCaption
' Return:   (Nothing)
'-------------------------------------------------------------------------------------------
Public Sub UpdateProgressBarStatus(TotalSectionCount As Long, counter As Long)
    Dim dPercentComplete As Double, CalculatedPercent As String, DecimalLocation As Long

    'Make sure no division by zero.
    If TotalSectionCount > 0 Then

        dPercentComplete = counter / TotalSectionCount

        Me.cmdProgressBar.width = dPercentComplete * lblPercentageComplete.width

        CalculatedPercent = CStr((100 * (dPercentComplete)) + 0.5)
        DecimalLocation = InStr(1, CalculatedPercent, ".")

        If DecimalLocation = 0 Then
            DecimalLocation = InStr(1, CalculatedPercent, ",")
        End If

        If DecimalLocation > 0 Then
            CalculatedPercent = Left(CalculatedPercent, DecimalLocation - 1)
        End If

        lblPercentageComplete.caption = CalculatedPercent & "%"

        DoEvents

    Else
        'Do nothing.  Cannot divide by zero.
    End If

End Sub

Private Sub cmdCancel_Click()
    bCancelUpload = True
End Sub

Attribute VB_Name = "frmSaveConfirm"
Attribute VB_Base = "0{0235C8A0-B947-411D-9D0E-50930FFB402A}{341B4A7F-4790-486D-9AA0-638F3993621A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public gYes As Boolean
Public gAllFuture As Boolean

Private Sub cbNo_Click()
    gYes = False
    Me.Hide
End Sub

Private Sub cbYes_Click()
    gYes = True
    Me.Hide
End Sub

Private Sub UserForm_Initialize()
    gYes = False
    gAllFuture = False
End Sub

Private Sub xbAllFuture_Click()
    gAllFuture = xbAllFuture.Value
End Sub
Attribute VB_Name = "frmSelectServer"
Attribute VB_Base = "0{B7EAC70A-588A-4F3E-BBEF-8E48438C16E2}{EBBB01EB-0B09-4AE1-BB36-745FC5DD31B2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private okEnabled As Boolean

Public Sub ShowSelections()
    Dim serverFile As String
    Dim serverValue As String
    Dim tempName As String
   
    serverFile = GetClientPath

    If (Right$(serverFile, 1) <> "\") Then serverFile = serverFile & "\"
    serverFile = serverFile & "Servers.txt"

    cmbServers.Clear
    ' Does the server file exists?
    If GetFileSystemObject.FileExists(serverFile) Then
        On Error GoTo NoServerFound
        ' Yep, so now we open it
        Open serverFile For Input As #1
        Do While Not EOF(1)    ' Loop until end of file.
            Line Input #1, serverValue
    
            tempName = LCase(serverValue)
            If Len(tempName) < 7 Or (Left(tempName, 7) <> "http://" And Left(tempName, 8) <> "https://") Then
                cmbServers.AddItem "http://" & serverValue
            Else
                cmbServers.AddItem serverValue
            End If
        Loop
        Close #1
    End If
    
NoServerFound:
    If cmbServers.ListCount Then
        lblCurrent.caption = "Current server: " & cmbServers.List(0, 0)
    Else
        lblCurrent.caption = "Current server: "
    End If
    
    Me.Show vbModal
End Sub

Private Sub cmbServers_Change()
    If cmbServers.Text <> "" Then
        cmdOK.picture = frmImages.imgBtn56.picture
        okEnabled = True
    Else
        cmdOK.picture = frmImages.imgBtn56D.picture
        okEnabled = False
    End If
End Sub

Private Sub cmdCancel_Click()
    bCancelUpload = True
    Unload Me
End Sub

Private Sub cmdOK_Click()
    If okEnabled Then
    ' Need to re-write the file
    Dim serverFile As String
    Dim bakFile As String
    Dim serverValue As String
    Dim tempName As String
    
    serverValue = cmbServers.Text
    tempName = LCase(serverValue)
    If Len(tempName) < 7 Or (LCase(Left(tempName, 7)) <> "http://" And Left(tempName, 8) <> "https://") Then
        serverValue = "http://" & cmbServers.Text
        cmbServers.Text = serverValue
    End If
    
    serverFile = GetClientPath

    If (Right$(serverFile, 1) <> "\") Then serverFile = serverFile & "\"
    bakFile = serverFile & "Servers.bak"
    serverFile = serverFile & "Servers.txt"

    ' Does the server file exists?
    If GetFileSystemObject.FileExists(bakFile) Then
        GetFileSystemObject.DeleteFile (bakFile)
    End If
    
    ' Move the curent text file to the bak file.
    If GetFileSystemObject.FileExists(serverFile) Then
        GetFileSystemObject.MoveFile serverFile, bakFile
    End If
    
    ' Output the new file
    Open serverFile For Output As #1
    ' Write out the selected server
    Print #1, serverValue
    
    ' Now add the "rest"
    Dim i As Integer
    For i = 0 To cmbServers.ListCount - 1
        If cmbServers.List(i, 0) <> cmbServers.Text Then
            Print #1, cmbServers.List(i, 0)
        End If
    Next i
    
    Close #1
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    QvidianServer = serverValue

    Unload Me
    End If
End Sub

Private Sub UserForm_Initialize()
    cmdOK.ForeColor = EnableMenu
    cmdCancel.ForeColor = EnableMenu
    okEnabled = False
End Sub
Attribute VB_Name = "frmWait"
Attribute VB_Base = "0{C5173C24-1436-4954-AFE0-E11A77E948DA}{410423B4-AD6C-4DB6-889E-55A55F1BCFE3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public bSelectedClicked As Boolean
Public bCancelClicked As Boolean

Private Sub cmdCancel_Click()
    bCancelClicked = True
    KillMe
End Sub

Public Sub KillMe()
    DebugMsgBox "KillMe", "frmWait"
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    DebugMsgBox "", "frmWait::UserForm_Initialize"
    bSelectedClicked = False
    bCancelClicked = False
    cmdCancel.ForeColor = EnableMenu
End Sub

Private Sub UserForm_Activate()
    DebugMsgBox "Call to ExtDialogStart", "frmWait::UserForm_Activate"
    Dim bRet As Boolean
    bRet = modWS.ExtDialogStart
    DebugMsgBox "Back from ExtDialogStart: " & bRet, "frmWait::UserForm_Activate"
    
    If bRet Then
        bCancelClicked = True
        'KillMe
    End If
End Sub

Attribute VB_Name = "frmWaitForSave"
Attribute VB_Base = "0{1B33D911-9986-407E-98E6-434C4FE694BB}{BC90E26E-FED0-4DC3-847A-58F731B18D60}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public bSelectedClicked As Boolean
Public bCancelClicked As Boolean

Private Sub cmdOK_Click()
    bCancelClicked = True
    KillMe
End Sub

Public Sub KillMe()
    DebugMsgBox "KillMe", "frmWait"
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    DebugMsgBox "", "frmWait::UserForm_Initialize"
    bCancelClicked = False
    cmdOK.ForeColor = EnableMenu
End Sub

Attribute VB_Name = "modAccessibility"
' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '
' Definitions and Procedures relating to Accessibility, used by the Ribbon VBA  '
' Demonstration UserForm. The constants have been lifted from oleacc.h, and are '
' just a subset of those available.                                             '
'                                                                               '
'                                                    Tony Jollans, August 2008. '
' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '

Option Explicit

Public Const CHILDID_SELF                  As Long = &H0&

Public Const STATE_SYSTEM_UNAVAILABLE      As Long = &H1&
Public Const STATE_SYSTEM_INVISIBLE        As Long = &H8000&
Public Const STATE_SYSTEM_SELECTED         As Long = &H2&

Public Enum RoleNumber
    ROLE_SYSTEM_CLIENT = &HA&
    ROLE_SYSTEM_PANE = &H10&
    ROLE_SYSTEM_GROUPING = &H14&
    ROLE_SYSTEM_TOOLBAR = &H16&
    ROLE_SYSTEM_PAGETAB = &H25&
    ROLE_SYSTEM_PROPERTYPAGE = &H26&
    ROLE_SYSTEM_GRAPHIC = &H28&
    ROLE_SYSTEM_STATICTEXT = &H29&
    ROLE_SYSTEM_TEXT = &H2A&
    ROLE_SYSTEM_BUTTONDROPDOWNGRID = &H3A&
    ROLE_SYSTEM_PAGETABLIST = &H3C&
End Enum

Private Enum NavigationDirection
    NAVDIR_FIRSTCHILD = &H7&
End Enum

#If Win64 Then
Declare PtrSafe Function AccessibleChildren _
                Lib "oleacc.dll" _
                    (ByVal paccContainer As Object, _
                     ByVal iChildStart As Long, _
                     ByVal cChildren As Long, _
                           rgvarChildren As Variant, _
                           pcObtained As Long) _
                As Long
#Else
Private Declare Function AccessibleChildren _
                Lib "oleacc.dll" _
                    (ByVal paccContainer As Object, _
                     ByVal iChildStart As Long, _
                     ByVal cChildren As Long, _
                           rgvarChildren As Variant, _
                           pcObtained As Long) _
                As Long
#End If

Public Function GetAccessible _
                    (Element As IAccessible, _
                     RoleWanted As RoleNumber, _
                     NameWanted As String, _
                     Optional GetClient As Boolean) _
                As IAccessible

    ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '
    ' This procedure recursively searches the accessibility hierarchy, starting '
    ' with the element given, for an object matching the given name and role.   '
    ' If requested, the Client object, assumed to be the first child, will be   '
    ' returned instead of its parent.                                           '
    '                                                                           '
    ' Called by: RibbonForm procedures to get parent objects as required        '
    '            Itself, recursively, to move down the hierarchy                '
    ' Calls: GetChildren to, well, get children.                                '
    '        Itself, recursively, to move down the hierarchy                    '
    ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '

    Dim ChildrenArray()
    Dim Child               As IAccessible
    Dim ndxChild            As Long
    Dim ReturnElement       As IAccessible
    
    
    'if this is the type of item we are looking for, has the right name and is available/visible return it.
    'we need the last check because we have multiple instances of our tabs in the template and we want to find the right one.
    If Element.accRole(CHILDID_SELF) = RoleWanted Then
        
        Debug.Print "Element Role: " & Element.accRole(CHILDID_SELF)
        Debug.Print "Element Name: " & Element.accName(CHILDID_SELF)
    
        If Element.accName(CHILDID_SELF) = NameWanted _
            And (Element.accState(CHILDID_SELF) And (STATE_SYSTEM_UNAVAILABLE Or STATE_SYSTEM_INVISIBLE)) = 0 Then
        
            Set ReturnElement = Element
        End If
    Else ' not found yet
    
        ChildrenArray = GetChildren(Element)
        
        If (Not ChildrenArray) <> True Then
            
            For ndxChild = LBound(ChildrenArray) To UBound(ChildrenArray)
                
                If TypeOf ChildrenArray(ndxChild) Is IAccessible Then
                
                    Set Child = ChildrenArray(ndxChild)
                    Set ReturnElement = GetAccessible(Child, _
                                                      RoleWanted, _
                                                      NameWanted)
                    If Not ReturnElement Is Nothing Then Exit For
                
                End If ' Child is IAccessible
            
            Next ndxChild
        
        End If ' there are children
    
    End If ' still looking

    If GetClient Then
        Set ReturnElement = ReturnElement.accNavigate(NAVDIR_FIRSTCHILD, _
                                                      CHILDID_SELF)
    End If
    
    Set GetAccessible = ReturnElement
    
End Function

Private Function GetChildren _
                     (Element As IAccessible) _
                 As Variant()

    ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '
    ' General purpose subroutine to get an array of children of an IAccessible  '
    ' object. The returned array is Variant because the elements may be either  '
    ' IAccessible objects or simple (Long) elements, and the caller must treat  '
    ' them appropriately.                                                       '
    '                                                                           '
    ' Called by: GetAccessible when searching for an Accessible element         '
    ' Calls: AccessibleChildren API                                             '
    ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '
    
    Const FirstChild        As Long = 0&

    Dim NumChildren         As Long
    Dim NumReturned         As Long
    
    Dim ChildrenArray()

    NumChildren = Element.accChildCount

    If NumChildren > 0 Then
    
        ReDim ChildrenArray(NumChildren - 1)
        AccessibleChildren Element, FirstChild, NumChildren, _
                           ChildrenArray(0), NumReturned

    End If
    
    GetChildren = ChildrenArray
    
End Function




Attribute VB_Name = "modBrowsers"
Option Explicit

Public Enum BrowserType
    FireFox = 2
    Chrome = 3
End Enum

Public Enum BrowserQvidianState
    NotRunning = 0
    Focused = 1
    DetectedCantFocus = 2
    DetectedCantTabFocus = 4
End Enum

Public Const GW_HWNDNEXT = 2
Public Const GW_CHILD = 5
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOSIZE = &H1
Public Const SWP_NOZORDER = &H4
Public Const SWP_NOACTIVATE = &H10
Public Const HWND_TOP = 0
Public Const HWND_NOTOPMOST = -2
Public Const flag = SWP_NOSIZE + SWP_NOMOVE

Public Const FFClassName = "Mozilla*WindowClass"
Public Const ChromeClassName = "Chrome_WidgetWin*"
Public Const LoginTitle = "* - Login*"
Public Const EndAppTitle = "* - End Application*"
Public Const AppErrorTitle = "* - Application Error*"
Public Const SessionEndTitle = "* - Session Ended*"

#If Win64 Then
Declare PtrSafe Function GetWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal wCmd As Long) As LongPtr
Declare PtrSafe Function GetDesktopWindow Lib "user32" () As LongPtr
Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As LongPtr, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As LongPtr, ByVal lpString As String, ByVal cch As Long) As Long
Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long

Public Function FindBrowserWindows(ByRef hTabWnds As Collection, ByRef hBrowserWnds As Collection, ByVal hWndStart As LongPtr, WindowText As String) As Long

Dim hWnd As LongPtr
Dim sWindowText As String
Dim sClassname As String
Dim sModname As String
Dim r As Long
Static level As Integer
Dim browser As structBrowser
Dim subCheck As Boolean

    DebugMsgBox "[" & hWndStart & "]" & vbTab & "[" & WindowText & "]", "FindBrowserWindows:"

    If hWndStart = 0 Then hWndStart = GetDesktopWindow()
 
    level = level + 1
     
    hWnd = GetWindow(hWndStart, GW_CHILD)
    
    Do Until hWnd = 0
        
        sWindowText = Space$(255)
        r = GetWindowText(hWnd, sWindowText, 255)
        sWindowText = Left(sWindowText, r)

        sClassname = Space$(255)
        r = GetClassName(hWnd, sClassname, 255)
        sClassname = Left(sClassname, r)

        If sWindowText <> "" Then
            'DebugMsgBox level & " [" & hWnd & "]" & vbTab & "[" & sClassname & "]" & vbTab & "[" & sWindowText & "]", "FindBrowserWindows:"
        End If
        subCheck = False
        ' Check for FF first.
        If sClassname Like FFClassName Then
            DebugMsgBox "Firefox match, potentially...", "FindBrowserWindows:"
            subCheck = True
            If sWindowText <> "" And (sWindowText Like WindowText) And Not ( _
              (sWindowText Like LoginTitle) Or (sWindowText Like EndAppTitle) Or _
              (sWindowText Like AppErrorTitle) Or (sWindowText Like SessionEndTitle)) Then
                DebugMsgBox "Matched - " & level & " [" & hWnd & "]" & vbTab & "[" & sClassname & "]" & vbTab & "[" & sWindowText & "]", "FindBrowserWindows:"
                Set browser = New structBrowser
                If (sWindowText Like "* - Mozilla Firefox") Then
                    browser.hWnd = hWnd
                Else
                    browser.hWnd = 0
                End If
                browser.title = sWindowText
                browser.BrowserType = FireFox
                'browser.Classname = sClassname
                hTabWnds.Add browser
                subCheck = False
            End If
        Else
           If sClassname Like ChromeClassName Then
            DebugMsgBox "Chrome match, potentially...", "FindBrowserWindows:"
               subCheck = True
               ' Is this the main window?
               If (sWindowText Like "* - Google Chrome") And Not (sWindowText Like "* - Library - Google Chrome") Then
                   Set browser = New structBrowser
                   browser.hWnd = hWnd
                   browser.title = sWindowText
                   browser.BrowserType = Chrome
                   'browser.Classname = sClassname
                   hBrowserWnds.Add browser
               End If
               If sWindowText <> "" And (sWindowText Like WindowText) And Not ( _
                 (sWindowText Like LoginTitle) Or (sWindowText Like EndAppTitle) Or _
                 (sWindowText Like AppErrorTitle) Or (sWindowText Like SessionEndTitle)) Then
                   DebugMsgBox "Matched - " & level & " [" & hWnd & "]" & vbTab & "[" & sClassname & "]" & vbTab & "[" & sWindowText & "]", "FindBrowserWindows:"
                   Set browser = New structBrowser
                   If (sWindowText Like "* - Google Chrome") Then
                       browser.hWnd = hWnd
                   Else
                       browser.hWnd = 0
                   End If
                   browser.title = sWindowText
                   browser.BrowserType = Chrome
                   'browser.Classname = sClassname
                   hTabWnds.Add browser
                   subCheck = False
               End If
        
           End If
        End If
        If subCheck Then Call FindBrowserWindows(hTabWnds, hBrowserWnds, hWnd, WindowText)
        
        hWnd = GetWindow(hWnd, GW_HWNDNEXT)
 
    Loop

    level = level - 1
    DebugMsgBox "Leaving [" & level & "]", "FindBrowserWindows:"
End Function
#Else
Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Declare Function GetDesktopWindow Lib "user32" () As Long
Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long

Public Function FindBrowserWindows(ByRef hTabWnds As Collection, ByRef hBrowserWnds As Collection, ByVal hWndStart As Long, WindowText As String) As Long

Dim hWnd As Long
Dim sWindowText As String
Dim sClassname As String
Dim sModname As String
Dim r As Long
Static level As Integer
Dim browser As structBrowser
Dim subCheck As Boolean

    If hWndStart = 0 Then hWndStart = GetDesktopWindow()
 
    level = level + 1
     
    hWnd = GetWindow(hWndStart, GW_CHILD)
    
    Do Until hWnd = 0
        
        sWindowText = Space$(255)
        r = GetWindowText(hWnd, sWindowText, 255)
        sWindowText = Left(sWindowText, r)

        sClassname = Space$(255)
        r = GetClassName(hWnd, sClassname, 255)
        sClassname = Left(sClassname, r)

        If sWindowText <> "" Then
            'DebugMsgBox level & " [" & hwnd & "]" & vbTab & "[" & sClassname & "]" & vbTab & "[" & sWindowText & "]"
        End If
        subCheck = False
        ' Check for FF first.
        If sClassname Like FFClassName Then
            subCheck = True
            If sWindowText <> "" And (sWindowText Like WindowText) And Not ( _
              (sWindowText Like LoginTitle) Or (sWindowText Like EndAppTitle) Or _
              (sWindowText Like AppErrorTitle) Or (sWindowText Like SessionEndTitle)) Then
                DebugMsgBox level & " [" & hWnd & "]" & vbTab & "[" & sClassname & "]" & vbTab & "[" & sWindowText & "]", "FindBrowserWindows:"
                Set browser = New structBrowser
                If (sWindowText Like "* - Mozilla Firefox") Then
                    browser.hWnd = hWnd
                Else
                    browser.hWnd = 0
                End If
                browser.title = sWindowText
                browser.BrowserType = FireFox
                'browser.Classname = sClassname
                hTabWnds.Add browser
                subCheck = False
            End If
        Else
           If sClassname Like ChromeClassName Then
               subCheck = True
               ' Is this the main window, ignoring Library?
               If (sWindowText Like "* - Google Chrome") And Not (sWindowText Like "* - Library - Google Chrome") Then
                   Set browser = New structBrowser
                   browser.hWnd = hWnd
                   browser.title = sWindowText
                   browser.BrowserType = Chrome
                   'browser.Classname = sClassname
                   hBrowserWnds.Add browser
               End If
               If sWindowText <> "" And (sWindowText Like WindowText) And Not ( _
                 (sWindowText Like LoginTitle) Or (sWindowText Like EndAppTitle) Or _
                 (sWindowText Like AppErrorTitle) Or (sWindowText Like SessionEndTitle)) Then
                   DebugMsgBox level & " [" & hWnd & "]" & vbTab & "[" & sClassname & "]" & vbTab & "[" & sWindowText & "]", "FindBrowserWindows:"
                   Set browser = New structBrowser
                   If (sWindowText Like "* - Google Chrome") Then
                       browser.hWnd = hWnd
                   Else
                       browser.hWnd = 0
                   End If
                   browser.title = sWindowText
                   browser.BrowserType = Chrome
                   'browser.Classname = sClassname
                   hTabWnds.Add browser
                   subCheck = False
               End If
        
           End If
        End If
        If subCheck Then Call FindBrowserWindows(hTabWnds, hBrowserWnds, hWnd, WindowText)
        
        hWnd = GetWindow(hWnd, GW_HWNDNEXT)
 
    Loop

    level = level - 1
End Function
#End If

Public Function BrowserFocusLibrary(Optional checkOnly As Boolean = False) As Boolean
    BrowserFocusLibrary = False
    
    Dim hBrowserWnds As Collection
    Set hBrowserWnds = New Collection
    Dim hTabWnds As Collection
    Set hTabWnds = New Collection
    FindBrowserWindows hTabWnds, hBrowserWnds, 0, LibraryTitle
    
    If hTabWnds.count > 0 Then
        Dim browserWin As structBrowser
        For Each browserWin In hTabWnds
            If browserWin.BrowserType = FireFox Then
                Debug.Print "FF [" & browserWin.hWnd & "]" & vbTab & _
                          "[" & browserWin.Classname & "]" & vbTab & "[" & _
                          browserWin.title & "]"
                If browserWin.hWnd > 0 Then
                    If Not checkOnly Then Call SetWindowPos(browserWin.hWnd, HWND_TOP, 0, 0, 0, 0, flag)
                    BrowserFocusLibrary = True
                End If
            Else
                Debug.Print "Chrome [" & browserWin.hWnd & "]" & vbTab & _
                          "[" & browserWin.Classname & "]" & vbTab & "[" & _
                          browserWin.title & "]"
                If browserWin.hWnd > 0 Then
                    If Not checkOnly Then Call SetWindowPos(browserWin.hWnd, HWND_TOP, 0, 0, 0, 0, flag)
                    BrowserFocusLibrary = True
                End If
            End If
        Next
    End If
End Function

Public Function BrowserFocusQvidian(Optional checkOnly As Boolean = False, Optional isProsearch As Boolean = False) As BrowserQvidianState
    DebugMsgBox "[" & QvidianTitle & "]" & vbTab & "[" & FFClassName & "]", "BrowserFocusQvidian:"
    BrowserFocusQvidian = NotRunning
    
    Dim hBrowserWnds As Collection
    Set hBrowserWnds = New Collection
    Dim hTabWnds As Collection
    Set hTabWnds = New Collection
    If isProsearch Then
        FindBrowserWindows hTabWnds, hBrowserWnds, 0, ProSearchTitle
    Else
        FindBrowserWindows hTabWnds, hBrowserWnds, 0, QvidianTitle
    End If
    
    DebugMsgBox "FindBrowserWindows found [" & hTabWnds.count & "] windows", "BrowserFocusQvidian:"
    If hTabWnds.count > 0 Then
        Dim browserWin As structBrowser
        For Each browserWin In hTabWnds
            If browserWin.BrowserType = FireFox Then
                DebugMsgBox "FF [" & browserWin.hWnd & "]" & vbTab & _
                          "[" & browserWin.Classname & "]" & vbTab & "[" & _
                          browserWin.title & "]", "BrowserFocusQvidian:"
                If browserWin.hWnd > 0 Then
                    If Not checkOnly Then
                        Call SetWindowPos(browserWin.hWnd, HWND_TOP, 0, 0, 0, 0, flag)
                    End If
                    BrowserFocusQvidian = Focused
                Else
                    BrowserFocusQvidian = DetectedCantFocus
                End If
            Else
                DebugMsgBox "Chrome [" & browserWin.hWnd & "]" & vbTab & _
                          "[" & browserWin.Classname & "]" & vbTab & "[" & _
                          browserWin.title & "]", "BrowserFocusQvidian:"
                If browserWin.hWnd > 0 Then
                    If Not checkOnly Then Call SetWindowPos(browserWin.hWnd, HWND_TOP, 0, 0, 0, 0, flag)
                    BrowserFocusQvidian = Focused
                Else
                    If hBrowserWnds.count > 0 Then
                        If Not checkOnly Then Call SetWindowPos(hBrowserWnds(1).hWnd, HWND_TOP, 0, 0, 0, 0, flag)
                        BrowserFocusQvidian = DetectedCantTabFocus
                    Else
                        BrowserFocusQvidian = DetectedCantFocus
                    End If
                End If
            End If
        Next
    End If
    DebugMsgBox "FindBrowserWindows leaving with status of [" & BrowserFocusQvidian & "]", "BrowserFocusQvidian:"
End Function

Public Function BrowserDialogsRunning() As Boolean
    DebugMsgBox "", "BrowserDialogsRunning:"
    BrowserDialogsRunning = False
    
    Dim hBrowserWnds As Collection
    Set hBrowserWnds = New Collection
    Dim hTabWnds As Collection
    Set hTabWnds = New Collection
    FindBrowserWindows hTabWnds, hBrowserWnds, 0, DialogsTitle
    
    DebugMsgBox "FindBrowserWindows found [" & hTabWnds.count & "] windows", "BrowserDialogsRunning:"
    If hTabWnds.count > 0 Then
        Dim browserWin As structBrowser
        For Each browserWin In hTabWnds
            If browserWin.BrowserType = FireFox Then
                DebugMsgBox "FF [" & browserWin.hWnd & "]" & vbTab & _
                          "[" & browserWin.Classname & "]" & vbTab & "[" & _
                          browserWin.title & "]", "BrowserDialogsRunning:"
                If browserWin.hWnd > 0 Then
                    BrowserDialogsRunning = True
                End If
            Else
                DebugMsgBox "Chrome [" & browserWin.hWnd & "]" & vbTab & _
                          "[" & browserWin.Classname & "]" & vbTab & "[" & _
                          browserWin.title & "]", "BrowserDialogsRunning:"
                If browserWin.hWnd > 0 Then
                    BrowserDialogsRunning = True
                End If
            End If
        Next
    End If
End Function

Public Sub BrowserExecScript(thisWebBrowser, thisScript)
        Err.Clear
        On Error Resume Next
        
        DebugMsgBox "Browser URL=" & thisWebBrowser.locationurl, "BrowserExecScript:"
        DebugMsgBox "Script=" & thisScript, "BrowserExecScript:"

        thisWebBrowser.Document.parentWindow.execScript thisScript
                                                                                              
        If Err.Number <> 0 Then
            DebugMsgBox "Err.Number=" & Err.Number, "BrowserExecScript:"
        End If
        
        If Err.Number = -2147024891 Then
            'access is denied error in IE11, try alternate method
            thisWebBrowser.navigate "javascript:" & thisScript
        End If
    
End Sub

Attribute VB_Name = "modBuildActions"
Option Explicit

Public Sub Action_DisplayBuildError()
    buildDocument.ActiveWindow.Selection.WholeStory
    buildDocument.ActiveWindow.Selection.Delete
    buildDocument.ActiveWindow.Selection.InsertFile sPrintingFilePath
    ReturnDocumentToNormal
    buildDocument.SaveAs fileName:=sDocumentFilePath, addtorecentfiles:=False, fileformat:=WdSaveFormat.wdFormatDocumentDefault
    Templates(buildDocument.AttachedTemplate.FullName).Saved = True
    Application.NormalTemplate.Saved = True
    'No code will run after this line.
    buildDocument.AttachedTemplate = Application.NormalTemplate.FullName
End Sub

Public Sub Action_DownloadFileToBuildFolder(ByVal thisMiscFileID As String, ByVal NameToUse As String)
    dh.DownloadMiscFile sBuildFolder & NameToUse, thisMiscFileID
    CreateRFPFileArray sBuildFolder & NameToUse, ""
End Sub

Public Sub Action_DownloadRFPFileToBuildFolder(ByVal thisMiscFileID As String, ByVal QuAIDMappingInfo As String, ByVal NameToUse As String)
    Dim NewFilePath As String
    If dh.DownloadMiscFile(sBuildFolder & NameToUse, thisMiscFileID) Then
        NewFilePath = sBuildFolder & NameToUse
    End If
    CreateRFPFileArray NewFilePath, QuAIDMappingInfo
End Sub

Public Sub ProcessRFPFileArray()
    Dim i As Integer
    Dim objFSO
    Dim myExt As String
    Set objFSO = CreateObject("Scripting.FileSystemObject")

    If iRFPFileCount > 0 Then
        For i = 0 To UBound(sRFPFilesArray, 2)
             myExt = objFSO.GetExtensionName(sRFPFilesArray(0, i))

            Select Case LCase(Left(myExt, 3))
                Case "doc"
                    ProcessWordRFPFile sRFPFilesArray(0, i), sRFPFilesArray(1, i)
                Case "xls"
                    ProcessExcelRFPFile sRFPFilesArray(0, i)
            End Select
        Next i
    End If
End Sub

Private Sub ProcessWordRFPFile(ByVal thisPath As String, ByVal QuAIDMappingInfo As String)
    Dim WordRFPDocument As Document
    Set WordRFPDocument = Documents.Open(thisPath, , False, False, , , , , , , , False)
    
    Action_CleanRFPMarkers WordRFPDocument, QuAIDMappingInfo
    
    ImportStyles WordRFPDocument
    
    FormatAllStories WordRFPDocument, PRE_ER
    ReplaceAllStories WordRFPDocument
    FormatAllStories WordRFPDocument, POST_ER
    CleanAllStories WordRFPDocument
    
    WordRFPDocument.Save
    
    WordRFPDocument.Application.visible = True
    buildDocument.Activate
    Application.Activate
    'WordRFPDocument.Close wdDoNotSaveChanges
End Sub

Private Sub ProcessExcelRFPFile(ByVal thisPath As String)
    Dim ExcelApp As Object
    Dim ExcelRFPSpreadsheet As Object
    
    Set ExcelApp = CreateObject("Excel.Application")
    Set ExcelRFPSpreadsheet = ExcelApp.workbooks.Open(thisPath, , False, , , , , , , , , , False)
    
    ProcessEditReplaceListForExcel ExcelRFPSpreadsheet

    ProcessFormatListForExcel ExcelRFPSpreadsheet 'Basically, we're just removing most of them from Excel, except {{DateLong}} and {{DateShort}}
    
    ExcelRFPSpreadsheet.Worksheets(1).Activate
    
    ExcelRFPSpreadsheet.Save
    ExcelRFPSpreadsheet.Application.visible = True
    'ExcelRFPSpreadsheet.Close 2
    'ExcelApp.Quit
    Set ExcelApp = Nothing
    buildDocument.Activate
    Application.Activate
End Sub

Public Sub Action_CleanRFPMarkers(ByRef thisDocument As Document, ByVal QuAIDMappingInfo As String)
    Dim tempBookmark As Bookmark
    For Each tempBookmark In thisDocument.Bookmarks
        If Left(tempBookmark.name, 4) = "Sant" Then
            CleanRFPMarkersNEW thisDocument, QuAIDMappingInfo
            Exit For
        ElseIf InStr(1, tempBookmark.name, "Sant") > 0 Then
            CleanRFPMarkersOLD thisDocument, QuAIDMappingInfo
            Exit For
        End If
    Next tempBookmark
    
End Sub

Private Sub CleanRFPMarkersNEW(ByRef thisDocument As Document, ByVal QuAIDMappingInfo As String)
    Dim tempBookmark As Bookmark
    Dim name As String
    Dim StringToCheck As String
    Dim rangeLocation As Long
    Dim tempRange
    Dim QuAIDMappingArray() As String

    QuAIDMappingArray = Split(QuAIDMappingInfo, "/")
    
    Application.ScreenUpdating = False
    Options.Pagination = False

    For Each tempBookmark In thisDocument.Bookmarks
        name = tempBookmark.name
        If Left(name, 4) = "Sant" Then
            
            StringToCheck = tempBookmark.name
            
            rangeLocation = tempBookmark.Range.Start
            
            'in case the table was removed but the bookmark remained...
            If tempBookmark.Range.Tables.count > 0 Then
                tempBookmark.Range.Tables(1).Delete
            End If
            
            Dim i As Integer
            For i = LBound(QuAIDMappingArray) To UBound(QuAIDMappingArray)
                If QuAIDMappingArray(i) = StringToCheck Then
                    thisDocument.Range(rangeLocation, rangeLocation).Bookmarks.Add "QuAID_" & QuAIDMappingArray(i - 1)
                    Exit For
                End If
            Next i
            
            ' Sometimes this deletes the bookmark itself
            If thisDocument.Bookmarks.Exists(name) Then
                tempBookmark.Delete
            End If
        
        
        End If
        thisDocument.UndoClear
    Next tempBookmark
    
    'Remove extra paragraphs we added to split tables when saving.
    For Each tempBookmark In thisDocument.Bookmarks
        If Left(tempBookmark.name, 22) = "deleteparagraphonbuild" Then
            If tempBookmark.Range = vbCrLf Or tempBookmark.Range = vbCr Or tempBookmark.Range = vbLf Then
                tempBookmark.Range.Delete
            Else
                tempBookmark.Delete
            End If
        End If
    Next tempBookmark
    
'Enable this if we need to remove an extra paragraph after the document.
'    'Remove extra paragraph that gets inserted at end of doc.
'    If ActiveDocument.Range(thisDocument.Range.End - 1, thisDocument.Range.End).Bookmarks.count = 0 Then
'        ActiveDocument.Range(thisDocument.Range.End - 1, thisDocument.Range.End).Delete
'    End If
    
    Application.ScreenUpdating = True
    Application.ScreenRefresh
    
End Sub

Private Sub CleanRFPMarkersOLD(ByRef thisDocument As Document, ByVal QuAIDMappingInfo As String)

    Dim tempBookmark As Bookmark
    Dim TempTable As Table
    Dim QuAIDMappingArray() As String
    Dim i As Integer
    Dim StringToCheck As String
    
    Application.ScreenUpdating = False
    Options.Pagination = False

    QuAIDMappingArray = Split(QuAIDMappingInfo, "/")
    
    For Each tempBookmark In thisDocument.Bookmarks
        If Left(tempBookmark.name, 10) = "Begin_Sant" Then
            thisDocument.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
            thisDocument.ActiveWindow.Selection.Delete
            thisDocument.ActiveWindow.Selection.Delete
            thisDocument.ActiveWindow.Selection.MoveUp wdParagraph, 1
            thisDocument.ActiveWindow.Selection.Rows.Delete
            
            StringToCheck = Right(tempBookmark.name, Len(tempBookmark.name) - 6)
            For i = LBound(QuAIDMappingArray) To UBound(QuAIDMappingArray)
                If QuAIDMappingArray(i) = StringToCheck Then
                    thisDocument.ActiveWindow.Selection.Bookmarks.Add "QuAID_" & QuAIDMappingArray(i - 1)
                    Exit For
                End If
            Next i

            tempBookmark.Delete
        ElseIf Left(tempBookmark.name, 8) = "End_Sant" Then
            thisDocument.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
            thisDocument.ActiveWindow.Selection.Delete
            thisDocument.ActiveWindow.Selection.Delete
            tempBookmark.Delete
        End If
    Next tempBookmark
    
    thisDocument.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    thisDocument.ActiveWindow.Selection.Delete
    
    Application.ScreenUpdating = True
    Application.ScreenRefresh
    
End Sub

Public Sub Action_InsertBookmark(ByVal sBookMarkName As String)
    On Error GoTo Action_InsertBookmark_EH
    
    '---------------------------------------------------------------------
    '  Insert the bookmark
    '---------------------------------------------------------------------
    If Len(sBookMarkName) Then
    
        With buildDocument.Bookmarks
            .Add Range:=buildDocument.ActiveWindow.Selection.Range, name:=sBookMarkName
        End With
        
    End If
   
    Exit Sub
   
Action_InsertBookmark_EH:
    MsgBox GetTemplateString("Build_modActions_InsertBookmark_Error") & vbCrLf & Err.Number & " " & Err.description
End Sub

Public Sub Action_GotoBookmark(ByVal sBookMarkName As String)
    If buildDocument.Bookmarks.Exists(sBookMarkName) Then
        buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:=sBookMarkName
    Else
        buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    End If
End Sub

Public Sub Action_CreateERArray(ByVal sSearchText As String, ByVal sReplaceText As String, Optional AllowCarret As Boolean = False)
    'sEditReplaceArray is a global array eventually used in the Action_EditReplace sub
    'We are adding the values to an array so we can process them all at once (for performance)
    If Not (iERCnt >= 0) Then iERCnt = 0
    ReDim Preserve sEditReplaceArray(2, iERCnt)
    
    ' ^ (carret) is a special character for Find/Replace functionality
    ' so we must make sure there are no single ^ chars in ReplaceText
    If Not AllowCarret Then
        sReplaceText = Replace(sReplaceText, "^", "^^")
    End If
    
    sEditReplaceArray(0, iERCnt) = sSearchText
    sEditReplaceArray(1, iERCnt) = sReplaceText
    If iERCnt >= 0 Then iERCnt = iERCnt + 1
    
End Sub

Private Sub CreateRFPFileArray(ByVal thisFilePath As String, ByVal thisMappingInfo As String)
    'sRFPFilesArray is a global array eventually used to download and process the RFP files (after the edit/replaces are all avaliable)
    If Not (iRFPFileCount >= 0) Then iRFPFileCount = 0
    ReDim Preserve sRFPFilesArray(2, iRFPFileCount)
    sRFPFilesArray(0, iRFPFileCount) = thisFilePath
    sRFPFilesArray(1, iRFPFileCount) = thisMappingInfo
    If iRFPFileCount >= 0 Then iRFPFileCount = iRFPFileCount + 1
End Sub

Public Sub Action_EditReplace()
    Dim lItem As Long
    Dim lCurrentSection As Long
    
    Dim lPrevWindowHeight As Long
    Dim bPrevPagination As Boolean

    PreventWordCrashOnFindReplace
    
    'first do any gallery edit replace in case they have e/r content of their own
    DoGalleryEditReplaces
    
    buildDocument.ActiveWindow.ActivePane.View.Type = wdNormalView
    Application.ScreenUpdating = False
    bPrevPagination = Options.Pagination
    Options.Pagination = False
    
    'Add edit/replaces to the array for vbcrlf, bar |, etc.
    AddSpecialEditReplaces
    
    Application.ScreenUpdating = True
    Application.ScreenRefresh

    lPrevWindowHeight = buildDocument.ActiveWindow.Height
    If bHideWordDuringBuild Then
        If buildDocument.ActiveWindow.WindowState <> wdWindowStateMaximize Then
            buildDocument.ActiveWindow.Height = 300
        End If
    End If

    FormatAllStories buildDocument, PRE_ER
    ReplaceAllStories buildDocument
    FormatAllStories buildDocument, POST_ER

    buildDocument.ActiveWindow.ActivePane.View.Type = wdPrintView

    If bHideWordDuringBuild Then
        If buildDocument.ActiveWindow.WindowState <> wdWindowStateMaximize Then
            buildDocument.ActiveWindow.Height = lPrevWindowHeight
        End If
    End If
    
    Options.Pagination = bPrevPagination
    buildDocument.Repaginate
    
    'May find a better place for this later, but basically we need to
    '   process the edit/replaces in the RFP files that are built separately
    '   after the edit/replace list is complete.  This code performs
    '   additional processing besides E/Rs, but we were just waiting on E/Rs.
    ProcessRFPFileArray
    
End Sub

Private Sub PreventWordCrashOnFindReplace()
    'Bug #507 in Sant Suite 8.2 required this funky workaround to prevent an issue where
    '   on the second build, if you didn't have a graphic edit/replace AND a path for that edit/replace,
    '   build would peg the CPU and stop responding.  I narrowed it down to these lines of code.
    '   There may be a cleaner way of doing this, but this is the first pass.
    buildDocument.ActiveWindow.View = wdPrintView
    buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToSection, which:=wdGoToFirst, count:=1, name:=""
    buildDocument.ActiveWindow.Selection.Find.ClearFormatting
    buildDocument.ActiveWindow.Selection.Find.Execute FindText:="<<", Forward:=True, Wrap:=False
    CloseHeaderFooterView
End Sub

Sub AddSpecialEditReplaces()
    Action_CreateERArray "<<comma>>", ","
    Action_CreateERArray "<<PIPE>>", "|"
    Action_CreateERArray "<<vbcrlf>>", "^p", True
End Sub

'Fix for issue where long er values were getting cut off.  'TODOJSB: Evaluate.
Sub ReplaceLongERValues(ByVal sERCode As String, ByVal sERVal As String)
    On Error GoTo ErrorHandler
    Dim sTempER As String
    Dim lLenERCode As Long
    Dim lStartPos As Long
    Dim lFinishPos As Long
    Dim sTempStr As String

    buildDocument.ActiveWindow.Selection.Find.ClearFormatting
    buildDocument.ActiveWindow.Selection.Find.Replacement.ClearFormatting

    With buildDocument.ActiveWindow.Selection.Find
        .Text = sERCode
        Debug.Print .Text
        
        'If we're working with a long value, process the long value, otherwise do a standard find/replace.
        If Len(sERVal) > 254 Then
            
            'Get the starting string.
            sTempER = sERVal
            
            'Get the length of the edit/replace code.
            lLenERCode = Len(sERCode)
            
            'Start at the beginning of the string.
            'This value doesn't change... the string gets trimmed, so 1 is always the start.
            lStartPos = 1
            
            'End at the max length, minus the length of the edit/replace code.
            'The ER code length will be a max of 60 characters (for custom ERs).
            lFinishPos = 254 - lLenERCode
            
            'Loop until the remaining chunk of text is smaller than 254 characters.
            Do
                'Get the part of value we're currently inserting, plus the ER Code.
                'This will allow us to replace that same code again with the next
                'piece of the string.
                sTempStr = Mid(sTempER, lStartPos, lFinishPos) & sERCode
                
                'Get the rest of the string after the part we're currently inserting.
                sTempER = Right(sTempER, Len(sTempER) - lFinishPos)
                
                'Replace the ER code with this 254 character chunk.
                .Replacement.Text = sTempStr
                .Forward = True
                .Wrap = wdFindContinue
                .format = False
                .MatchCase = False
                .MatchWholeWord = False
                .MatchWildcards = False
                .MatchSoundsLike = False
                .MatchAllWordForms = False
                .Execute Replace:=wdReplaceAll
                'ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
            Loop Until Len(sTempER) <= 254
            
            'We're down to the last chunk, which is 254 characters or less.  Process it normally.
            sERVal = sTempER
            
        End If
            
        'The remaining value is 254 characters or less, we can process it with a single find/replace.
        .Replacement.Text = Left(sERVal, 254)
        .Forward = True
        .Wrap = wdFindContinue
        .format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        .Execute Replace:=wdReplaceAll
    
    
        'ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.

    End With

ReplaceLongERValues_Exit:
    Exit Sub

ErrorHandler:
    Err.Clear
    GoTo ReplaceLongERValues_Exit
End Sub

'04/19/04 [mag]: per bug#3372 the Sentence/List ERs were getting cut off
Sub ReplaceLongHeaderFooterERValues(ByVal sERCode As String, ByVal sERVal As String, ByVal sERDataType As String)
    On Error GoTo ErrorHandler
    Dim sTempER As String
    Dim lLenERCode As Long
    Dim lStartPos As Long
    Dim lFinishPos As Long
    Dim sTempStr As String

    buildDocument.ActiveWindow.Selection.Find.ClearFormatting
    buildDocument.ActiveWindow.Selection.Find.Replacement.ClearFormatting

    With buildDocument.ActiveWindow.Selection.Find
        .Text = sERCode
        Debug.Print .Text
        
        'If we're working with a long value, process the long value, otherwise do a standard find/replace.
        If Len(sERVal) > 254 Then
            
            'Get the starting string.
            sTempER = sERVal
            
            'Get the length of the edit/replace code.
            lLenERCode = Len(sERCode)
            
            'Start at the beginning of the string.
            'This value doesn't change... the string gets trimmed, so 1 is always the start.
            lStartPos = 1
            
            'End at the max length, minus the length of the edit/replace code.
            'The ER code length will be a max of 60 characters (for custom ERs).
            lFinishPos = 254 - lLenERCode
            
            'Loop until the remaining chunk of text is smaller than 254 characters.
            Do
                'Get the part of value we're currently inserting, plus the ER Code.
                'This will allow us to replace that same code again with the next
                'piece of the string.
                sTempStr = Mid(sTempER, lStartPos, lFinishPos) & sERCode
                
                'Get the rest of the string after the part we're currently inserting.
                sTempER = Right(sTempER, Len(sTempER) - lFinishPos)
                
                'Replace the ER code with this 254 character chunk.
                .Replacement.Text = sTempStr
                .Forward = True
                .Wrap = wdFindContinue
                .format = False
                .MatchCase = False
                .MatchWholeWord = False
                .MatchWildcards = False
                .MatchSoundsLike = False
                .MatchAllWordForms = False
                .Execute Replace:=wdReplaceAll
                'ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
            Loop Until Len(sTempER) <= 254
            
            'We're down to the last chunk, which is 254 characters or less.  Process it normally.
            sERVal = sTempER
            
        End If
            
        'The remaining value is 254 characters or less, we can process it with a single find/replace.
        .Replacement.Text = Left(sERVal, 254)
        .Forward = True
        .Wrap = wdFindContinue
        .format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        .Execute Replace:=wdReplaceAll
    
    
        'ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.

    End With

ReplaceLongHeaderFooterERValues_Exit:
    Exit Sub

ErrorHandler:
    Err.Clear
    GoTo ReplaceLongHeaderFooterERValues_Exit
End Sub

Public Sub Action_InsertBreak(ByVal thisBreakType As Integer)
    'skip page break if this is formatting the first action
    If Not bFirstAction Then
       buildDocument.ActiveWindow.Selection.InsertBreak Type:=thisBreakType
    End If
End Sub

'Keep for reference, Jason will delete.
'Public Sub Action_InsertRFPQAFile(ThisDataArray() As String)
'On Error Resume Next
'
'    Const CONTENT_HEADER As Long = 1
'    Const CONTENT_QA As Long = 2
'    Const CONTENT_FMATRIX As Long = 5
'    Const CONTENT_QASET As Long = 6
'
'    Dim DataArray(2 To 5) As String
'    Dim sFormatValuesArray() As String
'    Dim lQIndentVal As Long
'    Dim lContentType As Long
'
'    DataArray(2) = ThisDataArray(2)
'    DataArray(3) = ThisDataArray(3)
'    DataArray(4) = ThisDataArray(4)
'    DataArray(5) = ThisDataArray(5)
'    lContentType = DataArray(5)
'
'    'insert bookmark
'    With ActiveDocument.Bookmarks
'        .Add Range:=Selection.Range, Name:="BeforeRFPQA"
'        .DefaultSorting = wdSortByName
'        .ShowHidden = False
'    End With
'
'    'insert file
'    Action_InsertFile DataArray(), False
'    'sFileName = DataArray(2)
'    'sFileName = Right(sFileName, Len(sFileName) - IstrRev(sFileName, "\") + 1)
'    'sFileName = Left(sFileName, Len(sFileName) - 4)
'
'    Selection.InsertParagraph
'
'    'go to bookmark
'    With ActiveDocument.Bookmarks
'        Selection.GoTo What:=wdGoToBookmark, Name:="BeforeRFPQA"
'        .DefaultSorting = wdSortByName
'        .ShowHidden = False
'    End With
'
''    RemoveDoubleParagraphs
'
'    'remove bookmark
'    ActiveDocument.Bookmarks("BeforeRFPQA").Delete
'
'    'jump to end
'    Selection.GoTo What:=wdGoToBookmark, Name:="\EndOfDoc"
'
'End Sub

Public Sub Action_CreateComplianceMatrixTable(ByVal HeaderString As String)
'    Dim HeaderArray() As String
'    Dim ValueArray() As String
'    Dim i As Integer
'    Dim z As Integer
'    Dim ColCount As Integer
'    Const UNIT_DIVIDER As String = "/:/"
'    Const BLOCK_DIVIDER As String = "/;/"
'
'    HeaderArray = Split(HeaderString, BLOCK_DIVIDER)
'    ColCount = HeaderArray.count + 3
'    For i = LBound(HeaderArray) To UBound(HeaderArray)
'        ValueArray = Split(HeaderArray(i), UNIT_DIVIDER)
'            ActiveDocument.Tables.Add Range:=Selection.Range, NumRows:=3, NumColumns:=ColCount, AutoFitBehavior:=wdAutoFitWindow
'            With Selection.Tables(1)
'                If .Style <> "Table List 8" Then
'                    .Style = "Table List 8"
'                End If
'                .ApplyStyleHeadingRows = True
'                .ApplyStyleLastRow = True
'                .ApplyStyleFirstColumn = True
'                .ApplyStyleLastColumn = True
'            End With
'            Selection.MoveRight Unit:=wdCharacter, count:=1
'            Selection.MoveRight Unit:=wdCharacter, count:=4, Extend:=wdExtend
'            Selection.Cells.Merge
'            Selection.MoveRight Unit:=wdCharacter, count:=1
'            Selection.MoveLeft Unit:=wdCharacter, count:=1
'            Selection.MoveDown Unit:=wdLine, count:=1
'    Next i
End Sub


Public Sub Action_InsertComplianceMatrixFile(ByVal sfileName As String, ByVal NumLevels As Integer)
    On Error GoTo eh
       
    Set cmData = New clsCMHeaderData
    cmData.NumLevels = NumLevels
    
    
    buildDocument.Bookmarks.Add "CMStart"
    Action_InsertFile sfileName, False, True, False

    Exit Sub
eh:
    MsgBox "modActions.Action_InsertComplianceMatrixFile:" & Err.Number & " " & Err.description
End Sub


Public Function Action_ComplianceMatrix_AddLevel(ByVal abbr As String, Text As String)
    On Error GoTo eh
       
    cmData.AddLevel abbr, Text
    
    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_AddField::" & Err.Number & " " & Err.description
End Function

Sub CompMatrix_CopyTableRow(bmName As String)
    Dim oCell As Cell
    Dim oPrevRow As row, oNewRow As row
    Dim iColumn As Long
    Dim thisTable As Table
    Dim sourceRow As row
    Dim newRowIndex As Integer
    Dim tmpRange As Range
    iColumn = 0
    newRowIndex = 0
    
    If Selection.Information(wdWithInTable) = True Then
        Selection.Rows(1).Select
            
        ' Insert new row
        Set thisTable = Selection.Tables(1)
        Set sourceRow = Selection.Rows(1)
        
        
        If buildDocument.Bookmarks.Exists(bmName) Then
            Set tmpRange = buildDocument.Bookmarks(bmName).Range
            tmpRange.Select
                                            
            newRowIndex = Selection.Rows(1).Index + 1
        Else
            newRowIndex = sourceRow.Index + 1
        End If
        
        If sourceRow.Index = thisTable.Rows.count Or newRowIndex >= thisTable.Rows.count Then
            Set oNewRow = thisTable.Rows.Add()
        Else
            Set oNewRow = thisTable.Rows.Add(thisTable.Rows(newRowIndex))     'thisTable.Rows(thisTable.Rows.count)
        End If
        
        'Set oNewRow = thisTable.Rows.Add(sourceRow.Index + 1) 'thisTable.Rows(thisTable.Rows.count)
        '
        
        buildDocument.Bookmarks.Add bmName, oNewRow.Range
        
        ' Copy text to new row
        For Each oCell In sourceRow.Cells
            iColumn = iColumn + 1
            oNewRow.Cells(iColumn).Range = sourceRow.Cells(iColumn).Range
            'get rid of extra Cr
            oNewRow.Cells(iColumn).Range.Characters(oNewRow.Cells(iColumn).Range.Characters.count - 1).Delete
        Next
    End If

End Sub


Sub CompMatrix_CopyBookMark(BookmarkToCopy As String, Optional bmName As String = "CurrentRow", Optional bmRename As String = "")
    Dim BMRange As Range
    Set BMRange = buildDocument.Bookmarks(BookmarkToCopy).Range
    
    If bmRename = "" Then
        bmRename = BookmarkToCopy
    End If
    
    BMRange.Select
    
    If Not Selection.Information(wdWithInTable) Then
        'include paragraph if not already
        Dim strTemp As String
        strTemp = BMRange.Text
        If Right(strTemp, 1) <> vbCr Then
            BMRange.End = BMRange.End + 1
        End If
    End If
    
    BMRange.Copy
    
    If Not Selection.Information(wdWithInTable) Then
        'MsgBox "no table"
        CM_MoveToNewRowPosition
        
        buildDocument.Bookmarks.Add "CurrentRowStart", Selection.Range
        
        'office 2007+ supports wdUseDestinationStylesRecovery. We use the constant value 19 here
        'so we can compile in office 2003. 2003 uses the wdFormatOriginalFormatting. This
        'copies content correctly but does not preserve associated styles (it copies as formatted "normal").
        'This is a limitation of 2003 that we can't prevent.
        If getVersion >= 12 Then
            Selection.PasteAndFormat 19  'wdUseDestinationStylesRecovery
        Else
            Selection.PasteAndFormat wdFormatOriginalFormatting
        End If
        
        Selection.Select
        Selection.Collapse wdCollapseEnd
        
        Dim NewRowRange As Range
        Set NewRowRange = buildDocument.Range(Start:=buildDocument.Bookmarks("CurrentRowStart").Range.Start, End:=Selection.Start)
        NewRowRange.Select
        
        buildDocument.Bookmarks.Add bmName, NewRowRange
        buildDocument.Bookmarks("CurrentRowStart").Delete
    Else
        'MsgBox "table"
        BMRange.Select
        buildDocument.Bookmarks(BookmarkToCopy).Delete
        CompMatrix_CopyTableRow bmName
        buildDocument.Bookmarks.Add bmRename, BMRange
    End If
    
End Sub

Sub CM_MoveToNewRowPosition()
    If buildDocument.Bookmarks.Exists("NewRowPosition") Then
        Dim tmpRange As Range
        Set tmpRange = buildDocument.Bookmarks("NewRowPosition").Range
        tmpRange.Select
        'tmpRange.Collapse wdCollapseStart
        Selection.MoveUp WdUnits.wdParagraph
'        Selection.TypeParagraph
    Else
        Selection.Collapse wdCollapseEnd
        Selection.TypeParagraph
        Selection.TypeParagraph
        buildDocument.Bookmarks.Add "NewRowPosition", Selection.Range
        CM_MoveToNewRowPosition
    End If
End Sub


Public Function CM_ProcessKeyRow(ByVal thisRange As Range, ByVal abbr As String, Value As String)
    Dim tempRange As Range
    If InStr(1, LCase(thisRange.Text), LCase("<<ComplianceShort>>"), vbTextCompare) > 0 Then
        With thisRange.Find
            .Text = "<<ComplianceShort>>"
            .Wrap = wdFindStop
            .MatchCase = False
            If Len(Value) < 155 Then
                .Replacement.Text = FixValueForReplace(abbr)
                .Execute Replace:=wdReplaceAll
            Else
                Set tempRange = thisRange
                .Execute
                While thisRange.Find.Found
                    thisRange.Select
                    buildDocument.ActiveWindow.Selection.Text = abbr
                    Set thisRange = tempRange
                    .Execute
                Wend
            End If
        End With
    End If

    If InStr(1, LCase(thisRange.Text), LCase("<<ComplianceLong>>"), vbTextCompare) > 0 Then
        With thisRange.Find
            .Text = "<<ComplianceLong>>"
            .Wrap = wdFindStop
            .MatchCase = False
            If Len(Value) < 155 Then
                .Replacement.Text = FixValueForReplace(Value)
                .Execute Replace:=wdReplaceAll
            Else
                Set tempRange = thisRange
                .Execute
                While thisRange.Find.Found
                    thisRange.Select
                    buildDocument.ActiveWindow.Selection.Text = Value
                    Set thisRange = tempRange
                    .Execute
                Wend
            End If
        End With
    End If

End Function

Public Function Action_ComplianceMatrix_ProcessHeaders()
    On Error GoTo eh
    
    Dim i As Integer
    Dim lvlAbbr As String
    Dim NewRowRange As Range
    
    If buildDocument.Bookmarks.Exists("ss_cmkey") Then
        For i = 1 To cmData.NumLevels
            lvlAbbr = cmData.CMLevel(i - 1)

            CompMatrix_CopyBookMark "ss_cmkey"
            
            Set NewRowRange = buildDocument.Bookmarks("CurrentRow").Range
            
            CM_ProcessKeyRow NewRowRange, lvlAbbr, cmData.CMHeaderData(lvlAbbr)
        Next
        
        'delete original repeater
        DynamicContent_DeleteBookmark "ss_cmkey"
        buildDocument.Bookmarks("CurrentRow").Delete
    End If


    Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"

    Dim cmRange As Range
    Set cmRange = buildDocument.Range(Start:=buildDocument.Bookmarks("CMStart").Range.Start, End:=Selection.Start)
    cmRange.Select
    
    If InStr(1, LCase(cmRange.Text), LCase("<<ComplianceHeaders>>"), vbTextCompare) > 0 Then
        With cmRange.Find
            .Text = "<<ComplianceHeaders>>"
            .Wrap = wdFindStop
            .MatchCase = False
            .Replacement.Text = ""
            .Execute
            cmRange.Select
        End With
        
        If Selection.Information(wdWithInTable) Then
            Selection.Cells.Split NumRows:=1, NumColumns:=cmData.NumLevels, MergeBeforeSplit:=False
            
            For i = 1 To cmData.NumLevels
                lvlAbbr = cmData.CMLevel(i - 1)
                If i = 1 Then
                    Selection.Cells(i).Select
                Else
                    Selection.MoveRight wdCell, 1
                End If
                Selection.TypeText lvlAbbr
            Next
                       
        End If
    End If

    
    Exit Function
eh:
    MsgBox "modActions.Action_ComplianceMatrix_ProcessHeaders::" & Err.Number & " " & Err.description
End Function


Public Sub Action_InsertComplianceMatrixRow(Text As String, CMLevel As String, rowBkMark As String, comment As String)
    Dim NewRowRange As Range
    
    If buildDocument.Bookmarks.Exists("ss_cmentry") Then
        'NOTE: We need to create a second "blank" row, because otherwise when we split the cells to
        '   place the bullet, the next row will inherit the multiple cells and make copying from the template
        '   row impossible (extra cells). So we create a second row that we can build a duplicate off of while
        '   modifying the first one.
    
        'if blank row exists, copy it and replace "current row"
        If Not buildDocument.Bookmarks.Exists("ss_blank_cmrow") Then
            CompMatrix_CopyBookMark "ss_cmentry", "ss_blank_cmrow", ""
        End If
        
        CompMatrix_CopyBookMark "ss_blank_cmrow", "ss_blank_cmrow", "CurrentRow"
        
        Set NewRowRange = buildDocument.Bookmarks("CurrentRow").Range
        
        DynamicContent_ProcessField NewRowRange, "<<ComplianceText>>", Text
        DynamicContent_ProcessField NewRowRange, "<<ComplianceComment>>", comment
        DynamicContent_ProcessField NewRowRange, "<<Pg>>", rowBkMark
        
        If InStr(1, LCase(NewRowRange.Text), LCase("<<ComplianceBullet>>"), vbTextCompare) > 0 Then
            With NewRowRange.Find
                .Text = "<<ComplianceBullet>>"
                .Wrap = wdFindStop
                .MatchCase = False
                .Replacement.Text = ""
                .Execute Replace:=wdReplaceOne
                NewRowRange.Select
            End With
        
            Selection.Cells.Split NumRows:=1, NumColumns:=cmData.NumLevels, MergeBeforeSplit:=False
            Selection.Cells(CInt(CMLevel)).Select
            Selection.TypeText ""
            Selection.InsertSymbol "183", "Symbol"
        End If
    End If


End Sub

Public Sub Action_ComplianceMatrixClean()
    If buildDocument.Bookmarks.Exists("CurrentRow") Then
        buildDocument.Bookmarks("CurrentRow").Delete 'remove bookmark only
    End If
    
    If buildDocument.Bookmarks.Exists("ss_cmentry") Then
        DynamicContent_DeleteBookmark "ss_cmentry" 'delete sample row
    End If

    If buildDocument.Bookmarks.Exists("ss_blank_cmrow") Then
        DynamicContent_DeleteBookmark "ss_blank_cmrow" 'delete sample row
    End If
    
    Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    Selection.Collapse wdCollapseEnd
End Sub

'Public Sub Action_InsertComplianceMatrix(ByVal MatrixLevel As Integer, Optional ByVal CrossRefBookmark As String = "")
'
'    On Error GoTo Action_InsertComplianceMatrix_EH
'
'    Select Case MatrixLevel
'
'        Case 0
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'        Case 1
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'            '------------------------------------------------------------------------------------------------
'            ' Insert the bullet in the current cell
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.InsertSymbol CharacterNumber:=183, Font:="Symbol", Unicode:=False
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'        Case 2
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'            '------------------------------------------------------------------------------------------------
'            ' Insert the bullet in the current cell
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.InsertSymbol CharacterNumber:=183, Font:="Symbol", Unicode:=False
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'        Case 3
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'            '------------------------------------------------------------------------------------------------
'            ' Insert the bullet in the current cell
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.InsertSymbol CharacterNumber:=183, Font:="Symbol", Unicode:=False
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'        Case 4
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'            '------------------------------------------------------------------------------------------------
'            ' Insert the bullet in the current cell
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.InsertSymbol CharacterNumber:=183, Font:="Symbol", Unicode:=False
'
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'        Case Else
'        End Select
'
'        '------------------------------------------------------------------------------------------------
'        ' If a bookmark name was passed, insert a cross reference to it's page number
'        '------------------------------------------------------------------------------------------------
'        If CrossRefBookmark <> "" Then
'
'            If Not buildDocument.Bookmarks.Exists(CrossRefBookmark) Then
'
'                '--
'                ' Mark my place with a temporary bookmark
'                '--
'                With buildDocument.Bookmarks
'                    .Add Range:=buildDocument.ActiveWindow.Selection.Range, name:="BM_Temporary_Placemark"
'                    .DefaultSorting = wdSortByName
'                    .ShowHidden = True
'                End With
'
'                '--
'                ' Go to the enmd of the document
'                '--
'                buildDocument.ActiveWindow.Selection.GoTo What:=wdGoToBookmark, name:="\EndOfDoc"
'
'                '--
'                ' Add the bookmark to the end of the document
'                '--
'                With buildDocument.Bookmarks
'                    .Add Range:=buildDocument.ActiveWindow.Selection.Range, name:=CrossRefBookmark
'                    .DefaultSorting = wdSortByName
'                    .ShowHidden = True
'                End With
'
'                '--
'                ' Go to the temporary placement bookmark in the compliance matrix
'                '--
'                buildDocument.ActiveWindow.Selection.GoTo What:=wdGoToBookmark, name:="BM_Temporary_Placemark"
'
'                '--
'                ' Remove the temporary placement bookmark
'                '--
'                buildDocument.Bookmarks("BM_Temporary_Placemark").Delete
'
'            End If
'
'            '------------------------------------------------------------------------------------------------
'            ' Insert the Cross Reference to the passed bookmark name
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.InsertCrossReference ReferenceType:="Bookmark", ReferenceKind:= _
'                wdPageNumber, ReferenceItem:=CrossRefBookmark, _
'                InsertAsHyperlink:=True, IncludePosition:=False
'
'            '------------------------------------------------------------------------------------------------
'            ' Move the cursor to the comments cell
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'            With buildDocument.Bookmarks
'                .Add Range:=buildDocument.ActiveWindow.Selection.Range, name:="BM_ComplianceMatrix"
'                .DefaultSorting = wdSortByName
'                .ShowHidden = False
'            End With
'
'            bDeleteLastRow = True
'
'            buildDocument.ActiveWindow.Selection.MoveLeft Unit:=wdCell
'
'            bMoveToNextRow = True
'
'        Else
'
'            '------------------------------------------------------------------------------------------------
'            ' Move the cursor to the comments cell
'            '------------------------------------------------------------------------------------------------
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'            buildDocument.ActiveWindow.Selection.MoveRight Unit:=wdCell
'
'            With buildDocument.Bookmarks
'                .Add Range:=buildDocument.ActiveWindow.Selection.Range, name:="BM_ComplianceMatrix"
'                .DefaultSorting = wdSortByName
'                .ShowHidden = False
'            End With
'
'            bDeleteLastRow = True
'
'            buildDocument.ActiveWindow.Selection.MoveLeft Unit:=wdCell
'
'            bMoveToNextRow = True
'
'        End If
'
'    Exit Sub
'
'Action_InsertComplianceMatrix_EH:
'    MsgBox GetTemplateString("Build_modActions_InsertComplianceMatrix_Error")
'    Exit Sub
'
'End Sub

'ONLY USED FOR BUILD, NO LONGER BUILDING CLIENT SIDE>
Public Sub ImportStyles(ByRef thisDocument As Document)
    
    If sPrintingTemplateExt <> "pot" _
        And sPrintingTemplateExt <> "potx" _
        And sPrintingTemplateExt <> "potm" _
        And sPrintingTemplateExt <> "none" Then
        
        CopyStylesWithHiddenProperty thisDocument, sPrintingTemplate
    End If
    
End Sub

Public Sub Action_InsertFile(ByVal sfileName As String, ByVal bKeepHeadersAndFooters As Boolean, _
                    ByVal bIncludeParagraph As Boolean, Optional bIncludeSectionBreak As Boolean = True, _
                    Optional ByVal sStyle As String = "")
    On Error Resume Next
    
    Dim sTempFile As String
    
    Dim lPrevSectionCount As Long, lSectionInfo As Long
    Dim lCount As Long
    Dim bCheck1 As Boolean
    Dim bCheck2 As Boolean
    Dim bEndWhile As Boolean
    Dim i As Integer
    Dim sDocPath As String
    Dim insertDocument As Document
   
    If Not GetFileSystemObject.FileExists(sfileName) Then
        'The file does not exist
    Else
        'open instead of insert, because some formatting gets lost on an insert...
        Set insertDocument = Documents.Open(fileName:=sfileName, ConfirmConversions:=False, _
                     ReadOnly:=False, addtorecentfiles:=False, PasswordDocument:="", _
                     PasswordTemplate:="", Revert:=False, WritePasswordDocument:="", _
                     WritePasswordTemplate:="", format:=wdOpenFormatAuto)
                     
        ' 2011-08-26 [KV]:  Due to multiple defects with images missing or changing after build
        '                   we will remove all the picture links and select every image
        FixDocumentPictures insertDocument

        ImportStyles insertDocument '2007/03/07 [JSB]: Added to fix Word issue where it fails to copy bulleted and numbered styles.
        'Copy everything but the Headers and Footers
        
        '2011-09-29 [DS]: After the FixDocumentPictures, we need to return focus to the start of the document
        'to remove only  the headers/footers from the first document section.
        insertDocument.ActiveWindow.Selection.HomeKey wdStory
               
        'Delete the Header
        With insertDocument.ActiveWindow.View
            .Type = wdPageView
            .SeekView = wdSeekCurrentPageHeader
        End With
        insertDocument.ActiveWindow.Selection.HeaderFooter.Range.Delete

        'Delete the Footer
        With insertDocument.ActiveWindow.View
            .Type = wdPageView
            .SeekView = wdSeekCurrentPageFooter
        End With
        insertDocument.ActiveWindow.Selection.HeaderFooter.Range.Delete
      
        'Close Header/Footer View
        With insertDocument.ActiveWindow.View
            .Type = wdNormalView
        End With
    
        'get section count
        lCount = insertDocument.Sections.count
        
        'if there are multiple sections, we want to return to this current section formatting at the end, so save it
        'now and we will add a section break and reset it later..
        If lCount > 1 Then
         
            'Copy content of the document (without header/footer)
            insertDocument.content.Copy
            insertDocument.ActiveWindow.Close SaveChanges:=False
         
            If Not bLastFileSettingsPreserved Then
               With buildDocument.Sections(buildDocument.Sections.count).PageSetup
                   '------------------------------------------------------------
                   '  Resize the array for the current section and get the
                   '  properties
                   '------------------------------------------------------------
                   ReDim Preserve vParameters(17, 1)
                   vParameters(1, 1) = .LeftMargin
                   vParameters(2, 1) = .RightMargin
                   vParameters(3, 1) = .TopMargin
                   vParameters(4, 1) = .BottomMargin
                   vParameters(5, 1) = .DifferentFirstPageHeaderFooter
                   vParameters(6, 1) = .FooterDistance
                   vParameters(7, 1) = .Gutter
                   vParameters(8, 1) = .HeaderDistance
                   vParameters(9, 1) = .MirrorMargins
                   vParameters(10, 1) = .OddAndEvenPagesHeaderFooter
                   vParameters(11, 1) = .Orientation
                   vParameters(12, 1) = .PageHeight
                   vParameters(13, 1) = .PageWidth
                   vParameters(14, 1) = .PaperSize
                   vParameters(15, 1) = .SuppressEndnotes
                   vParameters(16, 1) = .VerticalAlignment
                   vParameters(17, 1) = .TextColumns.count
                   
               End With
        
               buildDocument.ActiveWindow.Selection.InsertBreak Type:=wdSectionBreakContinuous
            End If
            
            If Len(sStyle) > 0 Then
                On Error Resume Next
                buildDocument.ActiveWindow.Selection.Style = sStyle
                On Error GoTo 0
            End If
            
            'Paste into actual document
            buildDocument.ActiveWindow.Selection.GoTo wdGoToBookmark, , , "\EndOfDoc"
            DoEvents
            buildDocument.ActiveWindow.Selection.Paste
    
            buildDocument.ActiveWindow.Selection.InsertBreak Type:=wdSectionBreakContinuous
        
            With buildDocument.Sections(buildDocument.Sections.count).PageSetup
                .LeftMargin = vParameters(1, 1)
                .RightMargin = vParameters(2, 1)
                .TopMargin = vParameters(3, 1)
                .BottomMargin = vParameters(4, 1)
                .DifferentFirstPageHeaderFooter = vParameters(5, 1)
                .FooterDistance = vParameters(6, 1)
                .Gutter = vParameters(7, 1)
                .HeaderDistance = vParameters(8, 1)
                .MirrorMargins = vParameters(9, 1)
                .OddAndEvenPagesHeaderFooter = vParameters(10, 1)
                .Orientation = vParameters(11, 1)
                .PageHeight = vParameters(12, 1)
                .PageWidth = vParameters(13, 1)
                .PaperSize = vParameters(14, 1)
                .SuppressEndnotes = vParameters(15, 1)
                .VerticalAlignment = vParameters(16, 1)
                .TextColumns.SetCount vParameters(17, 1)
            End With
            
            bLastFileSettingsPreserved = True
        Else
            bLastFileSettingsPreserved = False
'            Selection.InsertFile FileName:=sDocPath, Range:="", _
'                         ConfirmConversions:=False, Link:=False, Attachment:=False

            ' 2005-11-01 KV
            ' We add paragraph at the end of the blob
            ' then select everything but that paragraph
            ' then copy
            ' we do this because otherwise we have the following issue
            '       in case if the last thing in main document is section break
            '       pasting entire blob preserves the page settings of the blob
            '       in every other case page settings of the blob are lost
            '       we would like to lose page settings of the blob in every case
            With insertDocument.ActiveWindow
                .Selection.GoTo wdGoToBookmark, , , "\EndOfDoc"
                
                'Try alternative method of adding a paragraph to avoid a Word issue
                '   where it makes the paragraph at the end of the text a carriage return.
                '.Selection.MoveLeft wdCharacter, 1
                '.Selection.MoveRight wdCharacter, 1

                .Selection.MoveRight wdCharacter, 1, wdExtend
                .Selection.Copy
                .Selection.Collapse wdCollapseStart
                .Selection.Paste

                '.Selection.InsertParagraphAfter
                
                .Document.content.Select
                .Selection.MoveLeft Unit:=wdCharacter, count:=1, Extend:=wdExtend
                .Selection.Copy
                .Document.Saved = True
                .Close SaveChanges:=False
            End With
         
            If Len(sStyle) > 0 Then
                On Error Resume Next
                buildDocument.ActiveWindow.Selection.Style = sStyle
                On Error GoTo 0
            End If
            
            ' paste the blob
            buildDocument.ActiveWindow.Selection.GoTo wdGoToBookmark, , , "\EndOfDoc"
            DoEvents
            buildDocument.ActiveWindow.Selection.Paste
        End If
    
        'delete excess carriage returns in this document (caused by insert file...
        buildDocument.ActiveWindow.Selection.GoTo wdGoToBookmark, , , "\EndOfDoc"
     
        i = 0
     
        While i < 2 And Not bEndWhile And (buildDocument.ActiveWindow.Selection.Text = vbCrLf Or buildDocument.ActiveWindow.Selection.Text = vbCr Or buildDocument.ActiveWindow.Selection.Text = vbLf)
            'don't delete the last paragraph marker in the answer...
            buildDocument.ActiveWindow.Selection.MoveLeft wdCharacter, 1, wdMove
            If (buildDocument.ActiveWindow.Selection.Text = vbCrLf Or buildDocument.ActiveWindow.Selection.Text = vbCr Or buildDocument.ActiveWindow.Selection.Text = vbLf) Then
                bCheck1 = True
            Else
                bCheck1 = False
            End If
         
            buildDocument.ActiveWindow.Selection.MoveLeft wdCharacter, 1, wdMove
            If (buildDocument.ActiveWindow.Selection.Text = vbCrLf Or buildDocument.ActiveWindow.Selection.Text = vbCr Or buildDocument.ActiveWindow.Selection.Text = vbLf) Then
                bCheck2 = True
            Else
                bCheck2 = False
            End If
         
            buildDocument.ActiveWindow.Selection.MoveRight wdCharacter, 2, wdMove
         
            If bCheck1 And bCheck2 Then
                i = i + 1
                buildDocument.ActiveWindow.Selection.Delete
            Else
                bEndWhile = True
            End If
        Wend
     
        buildDocument.ActiveWindow.Selection.GoTo wdGoToBookmark, , , "\EndOfDoc"
   
        If bIncludeParagraph Then
            'do nothing, we left a paragraph return
        Else
            buildDocument.ActiveWindow.Selection.Delete
        End If
    End If
   
End Sub

'Public Sub Action_InsertFooters(ByVal FirstPageSection As Long)
'
'    Const INDEX_BEGIN_PAGE_NUMBER_SECTION As Long = 2
'
'    Dim lSection As Long
'    Dim sHeaderAutoTextName As String
'    Dim LastSection As Integer
'
'    On Error GoTo ErrorHandler
'
'    SwitchToPrintView
'
'    If bHideWordDuringBuild Then
'        Call ResizeAndMoveWindow(600, 400, 0, 0) 'W,H,L,T
'    End If
'
'    LastSection = ActiveDocument.Sections.count
''    If LastSection > MAX_SECTIONS Then
''        LastSection = MAX_SECTIONS
''    End If
'
'    ReDim Preserve Footers(LastSection)
'    ReDim Preserve FirstPageFooters(LastSection)
'    ReDim Preserve EvenFooters(LastSection)
'    ReDim Preserve OddFooters(LastSection)
'    ReDim Preserve DifferentFirstPage(LastSection)
'    ReDim Preserve OddAndEvenPages(LastSection)
'
'    Dim oHeaderFooter As HeaderFooter
'
'    For lSection = 1 To LastSection
'        Selection.GoTo What:=wdGoToSection, which:=wdGoToAbsolute, count:=lSection
'
'        With ActiveDocument.Sections(lSection).PageSetup
'            If .OddAndEvenPagesHeaderFooter Then
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Footers(wdHeaderFooterEvenPages)
'                oHeaderFooter.Range.Select
'                If EvenFooters(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, EvenFooters(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Footers(wdHeaderFooterEvenPages).Range.Delete
'                End If
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Footers(wdHeaderFooterPrimary)
'                oHeaderFooter.Range.Select
'                If OddFooters(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, OddFooters(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Footers(wdHeaderFooterPrimary).Range.Delete
'                End If
'            End If
'            If .DifferentFirstPageHeaderFooter Then
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Footers(wdHeaderFooterFirstPage)
'                oHeaderFooter.Range.Select
'                If FirstPageFooters(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, FirstPageFooters(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Footers(wdHeaderFooterFirstPage).Range.Delete
'                End If
'            ElseIf Not .OddAndEvenPagesHeaderFooter Then
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Footers(wdHeaderFooterPrimary)
'                oHeaderFooter.Range.Select
'                If Footers(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, Footers(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Footers(wdHeaderFooterPrimary).Range.Delete
'                End If
'            End If
'        End With
'    Next
'    If ActiveWindow.Panes.count > 1 Then
'        ActiveWindow.ActivePane.Close
'    End If
'    If ActiveWindow.ActivePane.View.Type = wdNormalView Or ActiveWindow. _
'        ActivePane.View.Type = wdOutlineView Then
'        ActiveWindow.ActivePane.View.Type = wdPageView
'    End If
'
'    If FirstPageSection > 0 Then
'        If ActiveWindow.View.SplitSpecial <> wdPaneNone Then
'           ActiveWindow.Panes(2).Close
'        End If
'        If ActiveWindow.ActivePane.View.Type = wdNormalView Or _
'           ActiveWindow.ActivePane.View.Type = wdOutlineView Or _
'           ActiveWindow.ActivePane.View.Type = wdMasterView Then
'            ActiveWindow.ActivePane.View.Type = wdPageView
'        End If
'        Selection.GoTo What:=wdGoToSection, which:=wdGoToAbsolute, count:=FirstPageSection
'        ActiveWindow.ActivePane.View.SeekView = wdSeekCurrentPageFooter
'
'        With Selection.HeaderFooter.PageNumbers
'          .RestartNumberingAtSection = True
'          .StartingNumber = 1
'        End With
'
'    End If
'
'    ActiveWindow.ActivePane.View.SeekView = wdSeekMainDocument
'    Selection.EndKey Unit:=wdStory, Extend:=wdMove
'
'    If bHideWordDuringBuild Then
'        ActiveWindow.Visible = True
'        Call ResizeAndMoveWindow(400, 20, 0, 0)
'    End If
'
'  Exit Sub
'
'ErrorHandler:
'  If CheckForKnownError(Err.Number, "Action_InsertFooters") Then
'    'Known error.  Continue to execute code.
'    Err.Clear
'    Resume Next
'  Else
'    On Error GoTo 0  'Turn off error handling
'    Resume           'Go to line that caused the error and let execution break
'  End If
'
'End Sub

'Public Sub Action_InsertHeaders()
'
'    On Error GoTo ErrorHandler
'
'    Dim SectionObject As section
'    Dim lSection As Long
'    Dim sHeaderAutoTextName As String
'    Dim LastSection As Integer
'
'    Dim oHeaderFooter As HeaderFooter
'
'    LastSection = ActiveDocument.Sections.count
'
'    SwitchToPrintView
'
'    If bHideWordDuringBuild Then
'        Call ResizeAndMoveWindow(600, 400, 0, 0) 'W,H,L,T
'    End If
'
''    If LastSection > MAX_SECTIONS Then
''        LastSection = MAX_SECTIONS
''    End If
'    ReDim Preserve Headers(LastSection)
'    ReDim Preserve FirstPageHeaders(LastSection)
'    ReDim Preserve EvenHeaders(LastSection)
'    ReDim Preserve OddHeaders(LastSection)
'    ReDim Preserve DifferentFirstPage(LastSection)
'    ReDim Preserve OddAndEvenPages(LastSection)
'
'    For lSection = 1 To LastSection
'        Selection.GoTo What:=wdGoToSection, which:=wdGoToAbsolute, count:=lSection
'        Set SectionObject = ActiveDocument.Sections(lSection)
'        SectionObject.Headers(wdHeaderFooterEvenPages).LinkToPrevious = False
'        SectionObject.Footers(wdHeaderFooterEvenPages).LinkToPrevious = False
'        SectionObject.Headers(wdHeaderFooterFirstPage).LinkToPrevious = False
'        SectionObject.Footers(wdHeaderFooterFirstPage).LinkToPrevious = False
'        SectionObject.Headers(wdHeaderFooterPrimary).LinkToPrevious = False
'        SectionObject.Footers(wdHeaderFooterPrimary).LinkToPrevious = False
'
'        With ActiveDocument.Sections(lSection).PageSetup
'            If OddAndEvenPages(lSection) Then
'                .OddAndEvenPagesHeaderFooter = True
'            End If
'            If DifferentFirstPage(lSection) Then
'                .DifferentFirstPageHeaderFooter = True
'            End If
'        End With
'    Next
'    For lSection = LastSection To 1 Step -1
'        Selection.GoTo What:=wdGoToSection, which:=wdGoToAbsolute, count:=lSection
'
'        With ActiveDocument.Sections(lSection).PageSetup
'            If OddAndEvenPages(lSection) Then
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Headers(wdHeaderFooterEvenPages)
'                oHeaderFooter.Range.Select
'                If EvenHeaders(lSection) <> "" Then
'                    '05/28/04 [mag]: per issue with repeating header/footer autotext inserts
'                    CopyAndInsertAutotext oHeaderFooter, EvenHeaders(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Headers(wdHeaderFooterEvenPages).Range.Delete
'                End If
'
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Headers(wdHeaderFooterPrimary)
'                oHeaderFooter.Range.Select
'                If OddHeaders(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, OddHeaders(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Headers(wdHeaderFooterPrimary).Range.Delete
'                End If
'            End If
'            If DifferentFirstPage(lSection) Then
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Headers(wdHeaderFooterFirstPage)
'                oHeaderFooter.Range.Select
'                If FirstPageHeaders(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, FirstPageHeaders(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Headers(wdHeaderFooterFirstPage).Range.Delete
'                End If
'            ElseIf Not OddAndEvenPages(lSection) Then
'                Set oHeaderFooter = ActiveDocument.Sections(lSection).Headers(wdHeaderFooterPrimary)
'                oHeaderFooter.Range.Select
'                If Headers(lSection) <> "" Then
'                    CopyAndInsertAutotext oHeaderFooter, Headers(lSection)
'                Else
'                    ActiveDocument.Sections(lSection).Headers(wdHeaderFooterPrimary).Range.Delete
'                End If
'            End If
'        End With
'    Next
'
'    If ActiveWindow.Panes.count > 1 Then
'        ActiveWindow.ActivePane.Close
'    End If
'    If ActiveWindow.ActivePane.View.Type = wdNormalView Or ActiveWindow. _
'        ActivePane.View.Type = wdOutlineView Then
'        ActiveWindow.ActivePane.View.Type = wdPageView
'    End If
'    ActiveWindow.ActivePane.View.SeekView = wdSeekMainDocument
'
'    Selection.EndKey Unit:=wdStory, Extend:=wdMove
'
'    If bHideWordDuringBuild Then
'        ActiveWindow.Visible = True
'        Call ResizeAndMoveWindow(400, 20, 0, 0)
'    End If
'
'Exit Sub
'
'ErrorHandler:
'  If CheckForKnownError(Err.Number, "Action_InsertHeaders") Then
'    'Known error.  Continue to execute code.
'    Err.Clear
'    Resume Next
'  Else
'    On Error GoTo 0  'Turn off error handling
'    Resume           'Go to line that caused the error and let execution break
'  End If
'
'End Sub


'Private Sub InsertLogo(theSection As Long, LogoFile As String)
'
'    Dim logoFound As Boolean
'    Dim num As Integer
'    Const LOGO_TEXT = "(Your logo here)"
'    Dim HeaderFooter As HeaderFooter
'    Dim myAlign As Long, leftAmount As Single, rightAmount As Single
'    Dim topAmount As Long
'
'    On Error GoTo InsertLogoError
'    leftAmount = ActiveDocument.Sections(theSection).PageSetup.LeftMargin
'    rightAmount = ActiveDocument.Sections(theSection).PageSetup.RightMargin
'    topAmount = ActiveDocument.Sections(theSection).PageSetup.HeaderDistance
'
'    Selection.Find.ClearFormatting
'    Selection.Find.Replacement.ClearFormatting
'    With Selection.Find
'        .Text = LOGO_TEXT
'        .Forward = True
'        .Wrap = wdFindContinue
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'        logoFound = .Execute
'        ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
'    End With
'    If logoFound Then
'        myAlign = Selection.Range.Paragraphs.Alignment
'        Selection.Cut
'
'        If LogoFile <> "" Then
'           Set HeaderFooter = Selection.HeaderFooter
'           num = HeaderFooter.Shapes.count
'           ActiveDocument.Shapes.AddPicture _
'              FileName:=LogoFile, _
'              LinkToFile:=False, SaveWithDocument:=True, _
'              Anchor:=Selection.Range
'           '
'           'size it to no taller then 3/4 inch
'           '
'           HeaderFooter.Shapes(num + 1).Select
'           Selection.ShapeRange.Select
'           Selection.ShapeRange.LockAspectRatio = msoTrue
'           If Selection.ShapeRange.Height > 54# Then
'              Selection.ShapeRange.Height = 54#
'           End If
'           Selection.ShapeRange.Align myAlign, True
'           If myAlign = msoAlignLefts Then
'              Selection.ShapeRange.Left = Selection.ShapeRange.Left + leftAmount
'           ElseIf myAlign = msoAlignRights Then
'              Selection.ShapeRange.Left = Selection.ShapeRange.Left - rightAmount
'           ElseIf myAlign = msoAlignTops Then   'Justify
'              Selection.ShapeRange.Top = Selection.ShapeRange.Top + topAmount
'           End If
'        End If
'    End If
'ExitSub:
'    Exit Sub
'
'InsertLogoError:
'    Dim sErrorText As String
'    If Err.Number = 5152 Then
'        sErrorText = "Error (" & Err.Number & ")" & vbCrLf & Error & vbCrLf & vbCrLf & _
'                   "This error occurred inserting logo file:" & vbCrLf & _
'                   LogoFile
'        MsgBox sErrorText, vbExclamation, PM_TITLE
'        Resume ExitSub
'    Else
'        Resume Next
'    End If
'
'End Sub

Public Sub Action_InsertObject(ByVal sfileName As String, ByVal sObjectClass As String, Optional ByVal sStyle As String = "")
    
   If GetFileSystemObject.FileExists(sfileName) Then

      buildDocument.ActiveWindow.Selection.TypeParagraph
      
      If Len(sStyle) > 0 Then
        On Error Resume Next
        buildDocument.ActiveWindow.Selection.Style = sStyle
        On Error GoTo 0
      End If
      
      buildDocument.ActiveWindow.Selection.InlineShapes.AddOLEObject _
         ClassType:=sObjectClass, _
         fileName:=sfileName, LinkToFile:=False, _
         DisplayAsIcon:=False
    
      buildDocument.ActiveWindow.Selection.TypeParagraph
   
      buildDocument.ActiveWindow.Selection.EndKey Unit:=wdStory
    End If
    
End Sub

Public Sub Action_InsertPicture(ByVal sPath As String, Optional ByVal sStyle As String = "", Optional ByVal bIncludeParagraph As Boolean = True)
    On Error GoTo Action_InsertPicture_EH
    Dim picture As InlineShape
    Dim ShapeRatio As Integer
    
    If GetFileSystemObject.FileExists(sPath) And sPath <> "" Then
        Set picture = buildDocument.ActiveWindow.Selection.InlineShapes.AddPicture(fileName:=sPath, LinkToFile:=False, SaveWithDocument:=True)
        If buildDocument.ActiveWindow.Selection.StoryType = wdEvenPagesFooterStory Or buildDocument.ActiveWindow.Selection.StoryType = wdEvenPagesHeaderStory _
             Or buildDocument.ActiveWindow.Selection.StoryType = wdFirstPageFooterStory Or buildDocument.ActiveWindow.Selection.StoryType = wdFirstPageHeaderStory _
             Or buildDocument.ActiveWindow.Selection.StoryType = wdPrimaryFooterStory Or buildDocument.ActiveWindow.Selection.StoryType = wdPrimaryHeaderStory Then
            If (picture.Height > 54) Then
                ShapeRatio = picture.width / picture.Height
                picture.Height = 54
                picture.width = Int(picture.Height * ShapeRatio)
            End If
        End If
        
        ' Set picture wrap mode to "Square"
        'picture.ConvertToShape.WrapFormat.Type = wdWrapSquare
        
        'Customer is having an issue where replacing a graphical edit/replace is causing her table to lose some settings.
        'This is caused by the Else part that is commented out of the code below.  It is applying the Table Grid style,
        'which is causing some changes to content in the table.  Heidi and Jason spoke with Debi Bailey about the
        'functionality below, and Debi thought we should just leave the style as is in the situation where we don't
        'specify an alternative style.  So, I am changing this to not set the style to the NextParagraphStyle if no style was passed in.
        'We could change this to only skip that code if this routine is being called for a graphic edit/replace if we find problems with
        'just removing the line of code.
        If Len(sStyle) > 0 Then
            buildDocument.ActiveWindow.Selection.Style = sStyle
        Else
            'buildDocument.ActiveWindow.Selection.Style = buildDocument.Styles(buildDocument.ActiveWindow.Selection.Style).NextParagraphStyle
        End If
        If bIncludeParagraph Then
            buildDocument.ActiveWindow.Selection.TypeParagraph
        End If
    Else
        buildDocument.ActiveWindow.Selection.insertAfter "{{Red}}" & GetTemplateString("Build_Error_Inserting_File") & vbCrLf & sPath & "{{Red}}"
    End If
   
    Exit Sub
   
Action_InsertPicture_EH:

    '------------------------------------------------------------------
    '  If style is not in template, apply Normal style
    '------------------------------------------------------------------
    If Err.Number = ERROR_NO_STYLE Then
        buildDocument.ActiveWindow.Selection.Style = "Normal"
        Resume Next
    Else
        Dim sErrorText As String
      
        sErrorText = GetTemplateString("Build_modActions_InsertPicture_Error") & _
                    " " & Err.Number & " " & Err.description & vbCrLf & _
                    vbTab & "Action_InsertPicture" & vbCrLf & _
                    vbTab & "sPath = " & sPath & vbCrLf & _
                    vbTab & "sStyle = " & sStyle & vbCrLf & _
                    vbTab & "bIncludeParagraph = " & bIncludeParagraph
      
        MsgBox sErrorText, vbExclamation, PM_TITLE
        Exit Sub
    End If
   
End Sub

Public Sub Action_InsertText(ByVal sText As String, ByVal sStyle As String, _
                    Optional ByVal bIncludeParagraph As Boolean = True)
    Dim lItem As Integer
    Dim textArray() As String
    On Error GoTo Action_InsertText_EH
    
    textArray = Split(sText, DELIM)
    
    '----------------------------------------------------------------------
    '  Parse and insert text
    '----------------------------------------------------------------------
    For lItem = LBound(textArray) To UBound(textArray)
        '------------------------------------------------------------------
        '  Insert paragraph marker before text IF this is NOT the first paragraph inserted
        '------------------------------------------------------------------
        If lItem <> LBound(textArray) Then
            buildDocument.ActiveWindow.Selection.TypeParagraph
        End If
      
        '------------------------------------------------------------------
        '  Insert the text
        '------------------------------------------------------------------
        buildDocument.ActiveWindow.Selection.Text = textArray(lItem)
        
        '------------------------------------------------------------------
        '  Apply style to text
        '------------------------------------------------------------------
        If sStyle <> "" Then
            buildDocument.ActiveWindow.Selection.Style = sStyle
        End If
        
        '------------------------------------------------------------------
        '  Move to end of inserted text
        '------------------------------------------------------------------
        buildDocument.ActiveWindow.Selection.EndKey Unit:=wdLine
      
    Next lItem

    '---------------------------------------------------------------------
    '   Include paragraph marker at the end of text.
    '---------------------------------------------------------------------
    If bIncludeParagraph Then
        '------------------------------------------------------------------
        '  Move to end of inserted text
        '------------------------------------------------------------------
        buildDocument.ActiveWindow.Selection.Collapse wdCollapseEnd
        buildDocument.ActiveWindow.Selection.TypeParagraph
    End If
  
    Exit Sub
  
Action_InsertText_EH:

   '------------------------------------------------------------------
   '  If style is not in template, apply Normal style
   '------------------------------------------------------------------
   If Err.Number = ERROR_NO_STYLE Then
      buildDocument.ActiveWindow.Selection.Style = "Normal"
      Resume Next
   Else
      Dim sErrorText As String
      
      sErrorText = GetTemplateString("Build_modActions_InsertText_Error") & vbCrLf & _
                    Err.Number & " " & Err.description
      MsgBox Mid(sErrorText, 1, 255), vbExclamation, PM_TITLE
      Exit Sub
   End If
   
End Sub

Public Sub Action_MoveThroughTable(ByVal sMoveType As String)
   
   Dim ActionType$
   Dim ActionParameters$
   Dim tableFormat As Integer, headingRows As Integer, dash As Integer
   Dim AutoFitFlag As Integer
   Dim NumberRows As Integer
   Dim NumberCols As Integer
   Dim iCurColumn As Integer
   Dim dTotalWidth As Long
   Dim dCurrentWidth As Double
   Dim dColWidth As Double
   Dim i As Integer
   
   If InStr(sMoveType, ";") > 0 Then
      ActionType$ = Left(sMoveType, InStr(sMoveType, ";") - 1)
      ActionParameters$ = Right(sMoveType, Len(sMoveType) - Len(ActionType$) - 1)
   Else
      ActionType$ = sMoveType
      ActionParameters$ = "2"
   End If
   Select Case format(ActionType$, "<")
      Case "create table"
         If InStr(ActionParameters$, "-") > 0 Then
            dash = InStr(ActionParameters$, "-")
            NumberCols = val(Left(ActionParameters$, dash - 1))
            NumberRows = val(Right(ActionParameters$, Len(ActionParameters$) - dash))
         Else
            NumberCols = val(ActionParameters$)
            NumberRows = 1
         End If
         buildDocument.Tables.Add Range:=buildDocument.ActiveWindow.Selection.Range, NumRows:=NumberRows, NumColumns:=NumberCols
         
      Case "next cell"
         NumberRows = 0
         Do Until NumberRows = 1
            NumberRows = buildDocument.ActiveWindow.Selection.MoveRight(Unit:=wdCell)
         Loop
         
      Case "insert row"
        buildDocument.ActiveWindow.Selection.InsertRows 1
        
      Case "previous cell"
         NumberRows = 0
         Do Until NumberRows = 1
             buildDocument.ActiveWindow.Selection.MoveLeft Unit:=wdCell
         Loop
         
      Case "up"
         NumberRows = 0
         Do Until NumberRows > 0
            NumberRows = buildDocument.ActiveWindow.Selection.MoveUp(Unit:=wdLine, count:=1)
         Loop
         
      Case "down"
         NumberRows = 0
         Do Until NumberRows > 0
            NumberRows = buildDocument.ActiveWindow.Selection.MoveDown(Unit:=wdLine, count:=1)
         Loop
         
      Case "format", "style"     'the current table is the last table created
                        ' which is the highest indexed table, which is the table count
                        ' some customers want tables without lines, so format-heading
                        ' where heading=1/0 for true/false, also autofit =1/0 for true/false
         If InStr(ActionParameters$, "-") > 0 Then
            dash = InStr(ActionParameters$, "-")
            tableFormat = val(Left(ActionParameters$, dash - 1))
            ActionParameters$ = Right(ActionParameters$, Len(ActionParameters$) - dash)
            dash = InStr(ActionParameters$, "-")
            If dash > 0 Then
               headingRows = val(Left(ActionParameters$, dash - 1))
               AutoFitFlag = val(Right(ActionParameters$, Len(ActionParameters$) - dash))
            Else
               headingRows = val(ActionParameters$)
               AutoFitFlag = 0
            End If
         Else
            tableFormat = val(ActionParameters$)
            headingRows = True
            AutoFitFlag = False
         End If
         buildDocument.Tables(buildDocument.Tables.count).AutoFormat tableFormat, 1, 1, 0, 1, headingRows, 0, 0, 0, AutoFitFlag
         
      Case "merge row"
         buildDocument.ActiveWindow.Selection.SelectRow
         buildDocument.ActiveWindow.Selection.Cells.Merge
         
      Case "set breaking"
         With buildDocument.ActiveWindow.Selection
            .SelectRow
            If val(ActionParameters$) = 0 Then
                .Rows.AllowBreakAcrossPages = False
            Else
                .Rows.AllowBreakAcrossPages = True
            End If
            .Collapse direction:=wdCollapseStart
         End With
        
      Case "set header"
         With buildDocument.ActiveWindow.Selection
            .SelectRow
            If val(ActionParameters$) = 0 Then
                .Rows.HeadingFormat = False
            Else
                .Rows.HeadingFormat = True
            End If
            .Collapse direction:=wdCollapseStart
         End With
        
      Case "set widths"
'jk in word 2000 this allows the column widths to be set by percentage but
'   since that funcitonality is not a part of the word 97 system width will
'   have to be set as points.
'         While InStr(ActionParameters$, "-")
'            dash = InStr(ActionParameters$, "-")
'            iColWidth = Val(Left(ActionParameters$, dash - 1))
'            ActionParameters$ = Right(ActionParameters$, Len(ActionParameters$) - dash)
'            If iColWidth <> 0 Then
'                Selection.SelectColumn
'                Selection.Columns.PreferredWidthType = wdPreferredWidthPercent
'                Selection.Columns.PreferredWidth = iColWidth
'                Selection.Columns.Width = iColWidth
'            End If
'            Selection.Move unit:=wdColumn, Count:=1
'         Wend
'         iColWidth = Val(ActionParameters$)
'         If iColWidth <> 0 Then
'            Selection.SelectColumn
'            Selection.Columns.PreferredWidthType = wdPreferredWidthPercent
'            Selection.Columns.PreferredWidth = iColWidth
'            Selection.Columns.Width = iColWidth
'         End If
'         Selection.HomeKey unit:=wdRow

'This is the word 97 version
            buildDocument.ActiveWindow.Selection.SelectRow
            dTotalWidth = 0
            For iCurColumn = 1 To buildDocument.ActiveWindow.Selection.Columns.count
                dTotalWidth = dTotalWidth + buildDocument.ActiveWindow.Selection.Columns(iCurColumn).width
                buildDocument.ActiveWindow.Selection.Columns(iCurColumn).width = 11
            Next iCurColumn
            buildDocument.ActiveWindow.Selection.Collapse
            
            dCurrentWidth = 0
            While InStr(ActionParameters$, "-")
               dash = InStr(ActionParameters$, "-")
               dColWidth = val(Left(ActionParameters$, dash - 1))
               ActionParameters$ = Right(ActionParameters$, Len(ActionParameters$) - dash)
               buildDocument.ActiveWindow.Selection.SelectColumn
               dColWidth = (dColWidth / 100) * dTotalWidth
               buildDocument.ActiveWindow.Selection.Columns.width = dColWidth
               dCurrentWidth = dCurrentWidth + dColWidth
               buildDocument.ActiveWindow.Selection.Move Unit:=wdColumn, count:=1
            Wend
            buildDocument.ActiveWindow.Selection.SelectColumn
            buildDocument.ActiveWindow.Selection.Columns.width = dTotalWidth - dCurrentWidth
            buildDocument.ActiveWindow.Selection.HomeKey Unit:=wdRow
         
        Case "remove borders"
            buildDocument.ActiveWindow.Selection.Tables(buildDocument.ActiveWindow.Selection.Tables.count).Select
            With buildDocument.ActiveWindow.Selection.Tables(buildDocument.ActiveWindow.Selection.Tables.count)
               .Borders(wdBorderBottom).LineStyle = wdLineStyleNone
               .Borders(wdBorderHorizontal).LineStyle = wdLineStyleNone
               .Borders(wdBorderLeft).LineStyle = wdLineStyleNone
               .Borders(wdBorderRight).LineStyle = wdLineStyleNone
               .Borders(wdBorderTop).LineStyle = wdLineStyleNone
               .Borders(wdBorderVertical).LineStyle = wdLineStyleNone
               .Borders.Shadow = False
            End With
            buildDocument.ActiveWindow.Selection.Collapse direction:=wdCollapseStart
            
        Case "convert to table"
            IsReport = True 'This action will only be called by reporting.
            buildDocument.ActiveWindow.Selection.WholeStory
            Application.DefaultTableSeparator = Chr(172)
            buildDocument.ActiveWindow.Selection.ConvertToTable Separator:=wdSeparateByDefaultListSeparator, format:=wdTableFormatNone
            buildDocument.UndoClear
            
        Case "set alignment"
            buildDocument.ActiveWindow.Selection.HomeKey Unit:=wdStory
            While InStr(ActionParameters$, "-") And Len(ActionParameters$) > 1
                dash = InStr(ActionParameters$, "-")
                i = InStr(ActionParameters$, "/")
                buildDocument.ActiveWindow.Selection.Tables(1).Columns(Left(ActionParameters$, i - 1) + 1).Select
                
                buildDocument.ActiveWindow.Selection.Style = Mid(ActionParameters$, i + 1, (dash - i) - 1)
                ActionParameters$ = Right(ActionParameters$, Len(ActionParameters$) - dash)
            Wend
            buildDocument.ActiveWindow.Selection.Tables(1).Rows(1).Select
            buildDocument.ActiveWindow.Selection.Style = "PMReportColHeader"
            buildDocument.UndoClear
            
        Case "merge groups"
            Dim vStyle As Variant
            buildDocument.ActiveWindow.Selection.HomeKey Unit:=wdStory
            buildDocument.ActiveWindow.Selection.Find.ClearFormatting
            With buildDocument.ActiveWindow.Selection.Find
                .Text = "{{Group}}"
                .Forward = True
                .Wrap = wdFindContinue
            End With
            While buildDocument.ActiveWindow.Selection.Find.Execute
                buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
                Set vStyle = buildDocument.ActiveWindow.Selection.Style
                buildDocument.ActiveWindow.Selection.SelectRow
                buildDocument.ActiveWindow.Selection.Cells.Merge
                buildDocument.ActiveWindow.Selection.Style = buildDocument.Styles(vStyle)
                buildDocument.ActiveWindow.Selection.Text = Right(buildDocument.ActiveWindow.Selection.Text, Len(buildDocument.ActiveWindow.Selection.Text) - 9)
                buildDocument.ActiveWindow.Selection.Collapse wdCollapseEnd
            Wend
            buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
            buildDocument.UndoClear
            
        Case "home"
            buildDocument.ActiveWindow.Selection.HomeKey Unit:=wdStory
            
        Case "style"
            
   End Select

End Sub

Public Sub Action_RunMacro(ByVal sMacroName As String)
   
   Application.Run MacroName:=sMacroName
   
End Sub

'TODOJSB: Change this to accept a file path, and use that file to pull settings.
Public Sub Action_PageSetup(ByVal sMiscFileID As String)
    On Error Resume Next
    Dim sourceDoc As Document
    Dim SourceDocPageSetup As PageSetup
    Dim SourceSection As Section
    Dim SourceDocTextColumns As TextColumns
    Dim destDoc As Document
    Dim DestDocPageSetup As PageSetup
    Dim DestSection As Section
    Dim DestDocTextColumns As TextColumns
    Dim ColumnCounter As Integer
    Dim SourceDocPath As String
    
    If buildDocument.ActiveWindow.View.SplitSpecial <> wdPaneNone Then
        buildDocument.ActiveWindow.Panes(2).Close
    End If
    If buildDocument.ActiveWindow.ActivePane.View.Type <> wdPrintView Then
        buildDocument.ActiveWindow.ActivePane.View.Type = wdPrintView
    End If
    
    'Get Document Objects.
    Set destDoc = buildDocument
    If InStr(1, sMiscFileID, ".") = 0 Then
        sMiscFileID = sMiscFileID & ".doc"
    End If
    SourceDocPath = dlMiscFile(sMiscFileID)
    ' We MUST show the file or the copy/paste of images will not work.
    Set sourceDoc = Documents.Open(SourceDocPath, False, True, False, , , , , , , , True)
    
    'Get Section Objects
    Set SourceSection = sourceDoc.Sections(sourceDoc.Sections.count)
    Set DestSection = destDoc.Sections(destDoc.Sections.count)
    
    'Get Page Setup Objects
    Set SourceDocPageSetup = SourceSection.PageSetup
    Set DestDocPageSetup = DestSection.PageSetup
    
    'Get Text Columns Objects
    Set SourceDocTextColumns = SourceDocPageSetup.TextColumns
    Set DestDocTextColumns = DestDocPageSetup.TextColumns

    'Reset cursor location to end of document.  This is a fix to an issue where the document
    'would build out of order because the cursor location got moved to the beginning of the
    'document during the block of code above that begins with the 'Get Document Objects comment.
    'None of the actions should cause the cursor to get moved, and the customer had some Word
    'plug ins running that may have been causing the problem.
    destDoc.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"

    'Line Numbering
    DestDocPageSetup.LineNumbering.Active = SourceDocPageSetup.LineNumbering.Active
    DestDocPageSetup.LineNumbering.StartingNumber = SourceDocPageSetup.LineNumbering.StartingNumber
    DestDocPageSetup.LineNumbering.CountBy = SourceDocPageSetup.LineNumbering.CountBy
    DestDocPageSetup.LineNumbering.RestartMode = SourceDocPageSetup.LineNumbering.RestartMode
    DestDocPageSetup.LineNumbering.DistanceFromText = SourceDocPageSetup.LineNumbering.DistanceFromText

    'Page Setup
    DestDocPageSetup.Orientation = SourceDocPageSetup.Orientation
    DestDocPageSetup.TopMargin = SourceDocPageSetup.TopMargin
    DestDocPageSetup.BottomMargin = SourceDocPageSetup.BottomMargin
    DestDocPageSetup.LeftMargin = SourceDocPageSetup.LeftMargin
    DestDocPageSetup.RightMargin = SourceDocPageSetup.RightMargin
    DestDocPageSetup.Gutter = SourceDocPageSetup.Gutter
    DestDocPageSetup.HeaderDistance = SourceDocPageSetup.HeaderDistance
    DestDocPageSetup.FooterDistance = SourceDocPageSetup.FooterDistance
    DestDocPageSetup.PageWidth = SourceDocPageSetup.PageWidth
    DestDocPageSetup.PageHeight = SourceDocPageSetup.PageHeight
    DestDocPageSetup.FirstPageTray = SourceDocPageSetup.FirstPageTray
    DestDocPageSetup.OtherPagesTray = SourceDocPageSetup.OtherPagesTray
    DestDocPageSetup.SectionStart = SourceDocPageSetup.SectionStart
    DestDocPageSetup.OddAndEvenPagesHeaderFooter = SourceDocPageSetup.OddAndEvenPagesHeaderFooter
    DestDocPageSetup.DifferentFirstPageHeaderFooter = SourceDocPageSetup.DifferentFirstPageHeaderFooter
    DestDocPageSetup.VerticalAlignment = SourceDocPageSetup.VerticalAlignment
    DestDocPageSetup.SuppressEndnotes = SourceDocPageSetup.SuppressEndnotes
    DestDocPageSetup.MirrorMargins = SourceDocPageSetup.MirrorMargins
    DestDocPageSetup.TwoPagesOnOne = SourceDocPageSetup.TwoPagesOnOne
    If getVersion >= 10 Then
        CopyPageSetupPropertiesOfficeXPandUp DestDocPageSetup, SourceDocPageSetup
    End If
    DestDocPageSetup.GutterPos = SourceDocPageSetup.GutterPos

    'Borders
    CopyBorderFormatting DestSection.Borders(wdBorderTop), SourceSection.Borders(wdBorderTop)
    CopyBorderFormatting DestSection.Borders(wdBorderLeft), SourceSection.Borders(wdBorderLeft)
    CopyBorderFormatting DestSection.Borders(wdBorderRight), SourceSection.Borders(wdBorderRight)
    CopyBorderFormatting DestSection.Borders(wdBorderBottom), SourceSection.Borders(wdBorderBottom)
    CopyBorderFormatting DestSection.Borders(wdBorderVertical), SourceSection.Borders(wdBorderVertical)
    CopyBorderFormatting DestSection.Borders(wdBorderHorizontal), SourceSection.Borders(wdBorderHorizontal)
    CopyBorderFormatting DestSection.Borders(wdBorderDiagonalUp), SourceSection.Borders(wdBorderDiagonalUp)
    CopyBorderFormatting DestSection.Borders(wdBorderDiagonalDown), SourceSection.Borders(wdBorderDiagonalDown)
    DestSection.Borders.DistanceFrom = SourceSection.Borders.DistanceFrom
    DestSection.Borders.AlwaysInFront = SourceSection.Borders.AlwaysInFront
    DestSection.Borders.SurroundHeader = SourceSection.Borders.SurroundHeader
    DestSection.Borders.SurroundFooter = SourceSection.Borders.SurroundFooter
    DestSection.Borders.JoinBorders = SourceSection.Borders.JoinBorders
    DestSection.Borders.DistanceFromTop = SourceSection.Borders.DistanceFromTop
    DestSection.Borders.DistanceFromLeft = SourceSection.Borders.DistanceFromLeft
    DestSection.Borders.DistanceFromBottom = SourceSection.Borders.DistanceFromBottom
    DestSection.Borders.DistanceFromRight = SourceSection.Borders.DistanceFromRight
    DestSection.Borders.Shadow = SourceSection.Borders.Shadow
    DestSection.Borders.EnableFirstPageInSection = SourceSection.Borders.EnableFirstPageInSection
    DestSection.Borders.EnableOtherPagesInSection = SourceSection.Borders.EnableOtherPagesInSection
    
    'Columns
    If SourceDocPageSetup.TextColumns.count > 1 Then
        If SourceDocPageSetup.TextColumns.EvenlySpaced Then
            DestDocTextColumns.SetCount NumColumns:=SourceDocTextColumns.count
            DestDocTextColumns.EvenlySpaced = True
            DestDocTextColumns.LineBetween = SourceDocTextColumns.LineBetween
            DestDocTextColumns.width = SourceDocTextColumns.width
            DestDocTextColumns.Spacing = SourceDocTextColumns.Spacing
        Else
            DestDocTextColumns.SetCount NumColumns:=1
            DestDocTextColumns.EvenlySpaced = False
            DestDocTextColumns.LineBetween = SourceDocTextColumns.LineBetween
            For ColumnCounter = 2 To SourceDocTextColumns.count
                DestDocTextColumns.Add _
                    width:=SourceDocTextColumns(ColumnCounter).width, _
                    Spacing:=SourceDocTextColumns(ColumnCounter - 1).SpaceAfter, _
                    EvenlySpaced:=False
            Next ColumnCounter
            DestDocTextColumns(1).width = SourceDocTextColumns(1).width
        End If
    Else
        'Reset the destination back to one column.
        DestDocTextColumns.SetCount NumColumns:=1
    End If
    
    'Headers and Footers
    CopyHeaderFooter DestSection.Headers(wdHeaderFooterEvenPages), SourceSection.Headers(wdHeaderFooterEvenPages)
    CopyHeaderFooter DestSection.Headers(wdHeaderFooterFirstPage), SourceSection.Headers(wdHeaderFooterFirstPage)
    CopyHeaderFooter DestSection.Headers(wdHeaderFooterPrimary), SourceSection.Headers(wdHeaderFooterPrimary)
    CopyHeaderFooter DestSection.Footers(wdHeaderFooterEvenPages), SourceSection.Footers(wdHeaderFooterEvenPages)
    CopyHeaderFooter DestSection.Footers(wdHeaderFooterFirstPage), SourceSection.Footers(wdHeaderFooterFirstPage)
    CopyHeaderFooter DestSection.Footers(wdHeaderFooterPrimary), SourceSection.Footers(wdHeaderFooterPrimary)

    sourceDoc.Saved = True
    sourceDoc.Close wdDoNotSaveChanges
End Sub

Private Sub CopyPageSetupPropertiesOfficeXPandUp(ByRef DestDocPageSetup As Object, ByRef SourceDocPageSetup As Object)
    'Using objects so we'll be able to compile the template in Office 2000.
    DestDocPageSetup.BookFoldPrinting = SourceDocPageSetup.BookFoldPrinting
    DestDocPageSetup.BookFoldRevPrinting = SourceDocPageSetup.BookFoldRevPrinting
    DestDocPageSetup.BookFoldPrintingSheets = SourceDocPageSetup.BookFoldPrintingSheets
End Sub

Private Sub CopyHeaderFooter(ByRef DestHF As HeaderFooter, ByRef SourceHF As HeaderFooter)
    'Set Link to Previous to False, so that we're not changing all of the headers/footers.
    'Need error handling, because this property is not available on the first section of the
    'document.
    On Error Resume Next
    DestHF.LinkToPrevious = False
    DestHF.Range.Delete
    On Error GoTo 0
    If SourceHF.Exists Then
        SourceHF.Range.Copy
        DestHF.Range.Paste
        'When you paste a header/footer, there will be an extra paragraph marker.  Delete it.
        DestHF.Range.Characters(DestHF.Range.Characters.count).Delete
    End If
    DestHF.PageNumbers.NumberStyle = SourceHF.PageNumbers.NumberStyle
    DestHF.PageNumbers.HeadingLevelForChapter = SourceHF.PageNumbers.HeadingLevelForChapter
    DestHF.PageNumbers.IncludeChapterNumber = SourceHF.PageNumbers.IncludeChapterNumber
    DestHF.PageNumbers.ChapterPageSeparator = SourceHF.PageNumbers.ChapterPageSeparator
    DestHF.PageNumbers.RestartNumberingAtSection = SourceHF.PageNumbers.RestartNumberingAtSection
    If SourceHF.PageNumbers.RestartNumberingAtSection Then
        DestHF.PageNumbers.StartingNumber = SourceHF.PageNumbers.StartingNumber
    End If
End Sub

Private Sub CopyBorderFormatting(ByRef DestBorder As Border, ByRef SourceBorder As Border)
    DestBorder.visible = SourceBorder.visible
    If SourceBorder.ArtStyle <> 0 Then
        DestBorder.ArtStyle = SourceBorder.ArtStyle
        DestBorder.ArtWidth = SourceBorder.ArtWidth
        DestBorder.ColorIndex = SourceBorder.ColorIndex
    ElseIf SourceBorder.LineStyle <> 0 Then
        DestBorder.LineStyle = SourceBorder.LineStyle
        DestBorder.LineWidth = SourceBorder.LineWidth
        DestBorder.Color = SourceBorder.Color
    End If
End Sub

Public Function Action_IncludePresentation()

    bPresentation = True

End Function

Public Function Action_EditReplace_Graphic(ByVal sSearchText As String, ByVal sfileName As String, _
                    Optional ByVal lSearchType As SearchTypes = SearchTypes.SEARCH_BODY, Optional ByVal bOptional As Boolean = False)
    On Error GoTo eh
    
    Dim lItem As Long
    Dim bSearchHeaderFooter As Boolean
    Dim bSearchBody As Boolean
    Dim lPrevWindowHeight As Long
  
    If (sfileName = "") And Not bOptional Then
        MsgBox GetTemplateString("Build_Required_File_Does_Not_Exist")
    ElseIf sfileName = "" Then
        'Do nothing, no path was entered.
    ElseIf (Not GetFileSystemObject.FileExists(sfileName)) And Not bOptional Then
        MsgBox GetTemplateString("Build_File_Does_Not_Exist") & " (" & sfileName & ")"
    Else
        Select Case lSearchType
            Case SEARCH_BODY
                bSearchHeaderFooter = False
                bSearchBody = True
            Case SEARCH_HEADERFOOTER
                bSearchHeaderFooter = True
                bSearchBody = False
            Case SEARCH_ALL
                bSearchHeaderFooter = True
                bSearchBody = True
            Case Else
                bSearchHeaderFooter = False
                bSearchBody = True
        End Select
        
        lPrevWindowHeight = buildDocument.ActiveWindow.Height
        If bHideWordDuringBuild Then
            If buildDocument.ActiveWindow.WindowState <> wdWindowStateMaximize Then
                buildDocument.ActiveWindow.Height = 300
            End If
        End If
        
        If bSearchBody Then
            buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToSection, which:=wdGoToFirst, count:=1, name:=""
            ReplaceGraphic sSearchText, sfileName
        End If
        
        If bSearchHeaderFooter Then
        
            'Replace ER codes in the HEADER/FOOTER of the document.
            For lItem = 1 To buildDocument.Sections.count
                'TODOJSB: Replace this with a more efficient version.
                ReplaceGraphicInHeaderFooter buildDocument.Sections(lItem).Headers(wdHeaderFooterPrimary), sSearchText, sfileName
                ReplaceGraphicInHeaderFooter buildDocument.Sections(lItem).Headers(wdHeaderFooterFirstPage), sSearchText, sfileName
                ReplaceGraphicInHeaderFooter buildDocument.Sections(lItem).Headers(wdHeaderFooterEvenPages), sSearchText, sfileName
                ReplaceGraphicInHeaderFooter buildDocument.Sections(lItem).Footers(wdHeaderFooterPrimary), sSearchText, sfileName
                ReplaceGraphicInHeaderFooter buildDocument.Sections(lItem).Footers(wdHeaderFooterFirstPage), sSearchText, sfileName
                ReplaceGraphicInHeaderFooter buildDocument.Sections(lItem).Footers(wdHeaderFooterEvenPages), sSearchText, sfileName
        
            Next lItem
            
        End If
        
        If bHideWordDuringBuild Then
            If buildDocument.ActiveWindow.WindowState <> wdWindowStateMaximize Then
                buildDocument.ActiveWindow.Height = lPrevWindowHeight
            End If
        End If
        
        CloseHeaderFooterView
    End If
    
    Exit Function
eh:
    MsgBox "modActions.Action_EditReplace_Graphic::" & Err.Number & " " & Err.description
End Function

Sub ReplaceGraphicInHeaderFooter(thisHeaderFooter As Object, sSearchText As String, sfileName As String)
    On Error GoTo ErrorHandler
    
    'Each section has 3 headers/footers available.  It may not use all of them.
    'Make sure the header/footer exists before processing it.
    If thisHeaderFooter.Exists Then
        thisHeaderFooter.Range.Select
        
        'Only run the edit/replace if there is text in the header/footer.
        If thisHeaderFooter.Range.Characters.count > 1 Then
            ReplaceGraphic sSearchText, sfileName
        End If
    End If
    
    Exit Sub
ErrorHandler:
    'Currently jumping out of this routine if there is an error.
    'There is a known issue with the Range if the header only contains
    'a picture.  We get an error saying the range object doesn't exist.
    'If we figure out a better way to check the range, we can remove the error code.
End Sub

Private Sub ReplaceGraphic(sSearchText As String, sfileName As String)
    buildDocument.ActiveWindow.Selection.Find.ClearFormatting
    buildDocument.ActiveWindow.Selection.Find.Execute FindText:=sSearchText, Forward:=True, Wrap:=False
    'ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
    
    While buildDocument.ActiveWindow.Selection.Find.Found
        '--------------------------------------------------------
        '  Delete the edit replace tag and insert picture.
        '--------------------------------------------------------
        buildDocument.ActiveWindow.Selection.Delete
        If IsFileGraphic(sfileName) Then
            Action_InsertPicture sfileName, "", False
        Else
            EditReplaceFile sfileName
        End If

        '--------------------------------------------------------
        '  Search again
        '--------------------------------------------------------
        buildDocument.ActiveWindow.Selection.HomeKey Unit:=wdStory, Extend:=wdMove
        buildDocument.ActiveWindow.Selection.Find.Execute FindText:=sSearchText, Forward:=True, Wrap:=False
        'ActiveDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
    Wend
End Sub

Public Function EditReplaceFile(ByVal sfileName As String)
    Select Case LCase(Right(sfileName, Len(sfileName) - InStrRev(sfileName, ".")))
        Case "xls"
            buildDocument.ActiveWindow.Selection.InlineShapes.AddOLEObject _
               ClassType:="Excel.Sheet", _
               fileName:=sfileName, LinkToFile:=False, _
               DisplayAsIcon:=False
        Case "ppt"
            buildDocument.ActiveWindow.Selection.InlineShapes.AddOLEObject _
               ClassType:="Powerpoint.presentation", _
               fileName:=sfileName, LinkToFile:=False, _
               DisplayAsIcon:=False
        Case "doc", "docx", "docm"
            If Selection.Start = Selection.Paragraphs(1).Range.Start And _
                Selection.End = Selection.Paragraphs(1).Range.End - 1 Then
                buildDocument.ActiveWindow.Selection.InsertFile fileName:=sfileName, Range:="", _
                     ConfirmConversions:=False, Link:=False, Attachment:=False
            Else
                Dim tempDoc As New Document
                Set tempDoc = Documents.Open(sfileName)
                tempDoc.ActiveWindow.Selection.WholeStory
                tempDoc.ActiveWindow.Selection.End = tempDoc.ActiveWindow.Selection.End - 1
                If Right(tempDoc.ActiveWindow.Selection.Text, 1) = Chr(13) Then
                    tempDoc.ActiveWindow.Selection.End = tempDoc.ActiveWindow.Selection.End - 1
                End If
                tempDoc.ActiveWindow.Selection.Copy
                buildDocument.ActiveWindow.Selection.Paste
                tempDoc.Saved = True
                tempDoc.AttachedTemplate.Saved = True
                tempDoc.Close wdDoNotSaveChanges
            End If
        Case Else
            buildDocument.ActiveWindow.Selection.InsertFile fileName:=sfileName, Range:="", _
                     ConfirmConversions:=False, Link:=False, Attachment:=False
    End Select
End Function

Private Function CheckForKnownError(ByVal ErrorNumber As Long, ByVal FunctionName As String) As Boolean
  'Various known error constants'
  Const PAPERSIZE_NOT_AVAILABLE = 5889
  Const MEMBER_DOESNOT_EXIST = 5941
  Const CANNOT_CLOSE_PANE = 5867
  
  Dim sErrorText As String
  
  CheckForKnownError = False
  
  Select Case ErrorNumber

    Case PAPERSIZE_NOT_AVAILABLE
      sErrorText = GetTemplateString("Build_modActions_PapersizeError_Pt1") & vbCrLf & _
                    GetTemplateString("Build_modActions_PapersizeError_Pt2")
      MsgBox sErrorText, vbInformation, PM_TITLE
      
      CheckForKnownError = True

    Case MEMBER_DOESNOT_EXIST
      sErrorText = GetTemplateString("Build_modActions_MissingAutoText_Pt1") & vbCrLf & _
                    GetTemplateString("Build_modActions_MissingAutoText_Pt2")
      MsgBox sErrorText, vbInformation, PM_TITLE
      
      CheckForKnownError = True

    Case CANNOT_CLOSE_PANE  'Cannot close pane when window has only one pane.
      CheckForKnownError = True

  End Select
  
End Function



Public Function GetTemplateString(ByVal thisString As String) As String
    GetTemplateString = thisString
End Function


Public Function Action_DynamicContent_Insert(ByVal sfileName As String, ByVal NumFields As Integer)
    On Error GoTo eh
     'insert file: path, num fields
    '   -create object, insert file, init fields num
    '   -create starting BM for globals
       
    Set dcData = New clsDynamicContentData
    dcData.NumFields = NumFields
    
    
    buildDocument.Bookmarks.Add "DynamicContentStart"
    Action_InsertFile sfileName, False, True, False

    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_Insert::" & Err.Number & " " & Err.description
End Function

Public Function Action_DynamicContent_AddField(ByVal code As String)
    On Error GoTo eh
       
    dcData.AddField code
    
    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_AddField::" & Err.Number & " " & Err.description
End Function

Public Function Action_DynamicContent_AddValue(ByVal rowIdx As Integer, code As String, Value As String)
    On Error GoTo eh
    'insert value text: row, code, value

    dcData.AddValue rowIdx, code, Value

    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_AddValue::" & Err.Number & " " & Err.description
End Function

Public Function Action_DynamicContent_AddValueFromContent(ByVal rowIdx As Integer, code As String, sfileName As String)
    On Error GoTo eh
    'insert value contentID: row, code, contentID
    '   -download and insert (ER by content code copy?)
   
    dcData.AddValueFromFile rowIdx, code, sfileName

    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_AddValueFromContent::" & Err.Number & " " & Err.description
End Function


Public Function Action_DynamicContent_AddGlobalValue(ByVal code As String, Value As String)
    On Error GoTo eh
'            'insert global ER: code, value
'            Action_DynamicContent_AddGlobalValue LocalDataArray(1), LocalDataArray(2)
   dcData.AddGlobalValue code, Value

    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_AddGlobalValue::" & Err.Number & " " & Err.description
End Function


Public Function Action_DynamicContent_ProcessData()
    On Error GoTo eh
    'process rows
    '   -loop for each repeater BM found
    '      -loop data/process
    '      -delete original repeater
    '   -process globals
    '
    Dim i As Integer
    Dim rptIndex As Integer
    Dim NewRowRange As Range
    Dim startPos As Long
    
    If dcData.NumRows > 0 Then
    
        rptIndex = 1
        
        startPos = buildDocument.Bookmarks("DynamicContentStart").Start
        Do While buildDocument.Bookmarks.Exists("ss_repeat_" & rptIndex)
            ProcessBM "ss_repeat_" & rptIndex, dcData.NumRows
            
            rptIndex = rptIndex + 1
        Loop
    
        buildDocument.Range(startPos, startPos).Bookmarks.Add ("DynamicContentStart")
    
        Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    
        dcData.AddFormulasToGlobals
    
        Dim k() As Variant
        k = dcData.GlobalData.Keys
        Dim dcRange As Range
        Set dcRange = buildDocument.Range(Start:=buildDocument.Bookmarks("DynamicContentStart").Range.Start, End:=Selection.Start)
        dcRange.Select
        
        For i = 0 To dcData.GlobalData.count - 1
            DynamicContent_ProcessField dcRange, k(i), dcData.GlobalData(k(i))
        Next
    End If
    
    buildDocument.ActiveWindow.Selection.Collapse wdCollapseEnd

    If buildDocument.Bookmarks.Exists("DynamicContentStart") Then
        buildDocument.Bookmarks("DynamicContentStart").Delete
    End If
    Exit Function
eh:
    MsgBox "modActions.Action_DynamicContent_ProcessData::" & Err.Number & " " & Err.description

End Function

Private Sub ProcessBM(ByVal sBookmark As String, ByVal rowCount As Integer)
    If buildDocument.Bookmarks.Exists(sBookmark) Then
        Dim i As Integer
        Dim originalRange As Range
        buildDocument.Bookmarks(sBookmark).Range.Select
        
        'If within a table, and not within a single cell, ensure we have whole rows selected.
        If buildDocument.ActiveWindow.Selection.Information(wdWithInTable) Then
            ExpandToRows
            buildDocument.ActiveWindow.Selection.Bookmarks.Add (sBookmark)
        End If
        
        buildDocument.ActiveWindow.Selection.Copy
        
        'Reposition end of bookmark for tables to prevent pasted rows from inheriting the bookmark
        If buildDocument.ActiveWindow.Selection.Information(wdWithInTable) Then
            Set originalRange = buildDocument.ActiveWindow.Selection.Range
        End If
        
        'Replicate the repeater for the number of records being processed.
        Dim lStart As Long
        Dim lEnd As Long
        For i = 1 To rowCount
            buildDocument.ActiveWindow.Selection.Collapse wdCollapseEnd
            buildDocument.ActiveWindow.Selection.InsertParagraph
            lStart = buildDocument.ActiveWindow.Selection.Start
            CheckForAdjacentBookmark
            buildDocument.ActiveWindow.Selection.Collapse wdCollapseStart
            buildDocument.ActiveWindow.Selection.Paste
            If buildDocument.ActiveWindow.Selection.Information(wdWithInTable) Then
                originalRange.Bookmarks.Add (sBookmark)
            End If
            buildDocument.ActiveWindow.Selection.Delete
            lEnd = buildDocument.ActiveWindow.Selection.End
            buildDocument.Range(lStart, lEnd).Select
            buildDocument.ActiveWindow.Selection.Bookmarks.Add (sBookmark & "_" & i)
        Next i
        
        'Fix table bookmarks
        For i = 1 To rowCount - 1
            buildDocument.Bookmarks(sBookmark & "_" & i).End = buildDocument.Bookmarks(sBookmark & "_" & (i + 1)).Start
        Next i
        
        'Remove Original Bookmarked Block
        buildDocument.Bookmarks(sBookmark).Range.Select
        If buildDocument.ActiveWindow.Selection.Information(wdWithInTable) Then
            buildDocument.ActiveWindow.Selection.Rows.Delete
        Else
            buildDocument.ActiveWindow.Selection.Delete
        End If

        'Replace Values
        Dim selRange As Range
        For i = 1 To dcData.NumRows
            Set selRange = buildDocument.Bookmarks(sBookmark & "_" & i).Range
            
            DynamicContent_ProcessRow selRange, i
        Next
        
        'Remove Bookmarks
        For i = 1 To rowCount
            If buildDocument.Bookmarks.Exists(sBookmark & "_" & i) Then
                buildDocument.Bookmarks(sBookmark & "_" & i).Delete
            End If
        Next i
        
    End If
End Sub

'Assumes we are in a table.
Private Sub ExpandToRows()
    buildDocument.ActiveWindow.Selection.Start = buildDocument.ActiveWindow.Selection.Rows(1).Range.Start
    buildDocument.ActiveWindow.Selection.End = buildDocument.ActiveWindow.Selection.Rows(buildDocument.ActiveWindow.Selection.Rows.count).Range.End
End Sub

'Assumes we have a single paragraph marker selected.
Private Sub CheckForAdjacentBookmark()
    Dim tempBM As Bookmark
    For Each tempBM In buildDocument.ActiveWindow.Selection.Bookmarks
        If tempBM.Start = buildDocument.ActiveWindow.Selection.Start Then
            tempBM.Start = buildDocument.ActiveWindow.Selection.End
        End If
    Next tempBM
End Sub
'
Sub DynamicContent_ProcessRow(ByVal thisRowRange As Range, ByVal iRow As Integer)
    Dim tempRow As Scripting.Dictionary
    Dim fldName As String
    Dim j As Integer
    
    Set tempRow = dcData.ERFieldData(iRow)
    
    For j = 1 To dcData.NumFields
        fldName = dcData.Field(j - 1)
        If dcData.IsContentField(iRow, fldName) Then
            DynamicContent_ProcessContentField thisRowRange, fldName, tempRow(fldName)
        Else
            DynamicContent_ProcessField thisRowRange, fldName, tempRow(fldName)
        End If
    Next

End Sub

Sub DynamicContent_DeleteBookmark(thisBM As String)
    Dim BMRange As Range
    Set BMRange = buildDocument.Bookmarks(thisBM).Range
    
    BMRange.Select
    If Not Selection.Information(wdWithInTable) Then
        Dim strTemp As String
        strTemp = BMRange.Text
        If Right(strTemp, 1) <> vbCr Then
            BMRange.End = BMRange.End + 1
        End If
        
        BMRange.Delete
    Else
        Selection.Rows(1).Delete
    End If
    
    If buildDocument.Bookmarks.Exists(thisBM) Then
        buildDocument.Bookmarks(thisBM).Delete
    End If
End Sub

Sub DynamicContent_CopyBookMark(BookmarkToCopy As String)
    Dim BMRange As Range
    Set BMRange = buildDocument.Bookmarks(BookmarkToCopy).Range
    
    BMRange.Select
    
    'include paragraph if not already
    If Not Selection.Information(wdWithInTable) Then
        Dim strTemp As String
        strTemp = BMRange.Text
        If Right(strTemp, 1) <> vbCr Then
            BMRange.End = BMRange.End + 1
        End If
    End If
    
    BMRange.Copy
    
    If Not Selection.Information(wdWithInTable) Then
        'MsgBox "no table"
        DynamicContent_MoveToNewRowPosition
        
        buildDocument.Bookmarks.Add "CurrentRowStart", Selection.Range
        
        'office 2007+ supports wdUseDestinationStylesRecovery. We use the constant value 19 here
        'so we can compile in office 2003. 2003 uses the wdFormatOriginalFormatting. This
        'copies content correctly but does not preserve associated styles (it copies as formatted "normal").
        'This is a limitation of 2003 that we can't prevent.
        If getVersion >= 12 Then
            Selection.PasteAndFormat 19  'wdUseDestinationStylesRecovery
        Else
            Selection.PasteAndFormat wdFormatOriginalFormatting
        End If
        
        Selection.Select
        Selection.Collapse wdCollapseEnd
        
        Dim NewRowRange As Range
        Set NewRowRange = buildDocument.Range(Start:=buildDocument.Bookmarks("CurrentRowStart").Range.Start, End:=Selection.Start)
        NewRowRange.Select
        
        buildDocument.Bookmarks.Add "CurrentRow", NewRowRange
        buildDocument.Bookmarks("CurrentRowStart").Delete
    Else
        'MsgBox "table"
        BMRange.Select
        buildDocument.Bookmarks(BookmarkToCopy).Delete
        DynamicContent_CopyTableRow
        buildDocument.Bookmarks.Add BookmarkToCopy, BMRange
    End If
    
End Sub

Sub DynamicContent_MoveToNewRowPosition()
    If buildDocument.Bookmarks.Exists("NewRowPosition") Then
        Dim tmpRange As Range
        Set tmpRange = buildDocument.Bookmarks("NewRowPosition").Range
        tmpRange.Select
        'tmpRange.Collapse wdCollapseStart
        Selection.MoveUp WdUnits.wdParagraph
'        Selection.TypeParagraph
    Else
        Selection.Collapse wdCollapseEnd
        Selection.TypeParagraph
        'Selection.TypeParagraph
        buildDocument.Bookmarks.Add "NewRowPosition", Selection.Range
        DynamicContent_MoveToNewRowPosition
    End If
End Sub

Sub DynamicContent_CopyTableRow()
    Dim oCell As Cell
    Dim oPrevRow As row, oNewRow As row
    Dim iColumn As Long
    Dim thisTable As Table
    Dim sourceRow As row
    Dim newRowIndex As Integer
    Dim tmpRange As Range
    iColumn = 0
    newRowIndex = 0
    
    If Selection.Information(wdWithInTable) = True Then
        Selection.Rows(1).Select
            
        ' Insert new row
        Set thisTable = Selection.Tables(1)
        Set sourceRow = Selection.Rows(1)
        
        
        If buildDocument.Bookmarks.Exists("CurrentRow") Then
            Set tmpRange = buildDocument.Bookmarks("CurrentRow").Range
            tmpRange.Select
                                            
            newRowIndex = Selection.Rows(1).Index + 1
        Else
            newRowIndex = sourceRow.Index + 1
        End If
        
        If sourceRow.Index = thisTable.Rows.count Or newRowIndex >= thisTable.Rows.count Then
            Set oNewRow = thisTable.Rows.Add()
        Else
            Set oNewRow = thisTable.Rows.Add(thisTable.Rows(newRowIndex))     'thisTable.Rows(thisTable.Rows.count)
        End If
        
        'Set oNewRow = thisTable.Rows.Add(sourceRow.Index + 1) 'thisTable.Rows(thisTable.Rows.count)
        '
        
        buildDocument.Bookmarks.Add "CurrentRow", oNewRow.Range
        
        ' Copy text to new row
        For Each oCell In sourceRow.Cells
            iColumn = iColumn + 1
            oNewRow.Cells(iColumn).Range = sourceRow.Cells(iColumn).Range
            'get rid of extra Cr
            oNewRow.Cells(iColumn).Range.Characters(oNewRow.Cells(iColumn).Range.Characters.count - 1).Delete
        Next
    End If

End Sub

Sub DynamicContent_ProcessField(ByVal thisRange As Range, ByVal code As String, ByVal Value As String)
    If InStr(1, LCase(thisRange.Text), LCase(code), vbTextCompare) > 0 Then
        With thisRange.Find
            .Text = code
            .Wrap = wdFindStop
            .MatchCase = False
            If Len(Value) < 155 Then
                .Replacement.Text = FixValueForReplace(Value)
                .Execute Replace:=wdReplaceAll
            Else
                Dim tempBookmark As Bookmark
                Dim markName As String
                markName = "qpa_replaceBookmark13579"
                buildDocument.Bookmarks.Add markName, thisRange

                .Execute
                
                While thisRange.Find.Found
                    thisRange.Select
                    buildDocument.ActiveWindow.Selection.Text = Value
                    thisRange.Start = buildDocument.Bookmarks(markName).Range.Start
                    thisRange.End = buildDocument.Bookmarks(markName).Range.End
                    .Execute
                Wend
                
                buildDocument.Bookmarks(markName).Delete
            End If
        End With
    End If
End Sub

Sub DynamicContent_ProcessContentField(ByVal thisRange As Range, ByVal code As String, ByVal fileName As String)
    thisRange.Select
    buildDocument.ActiveWindow.Selection.Find.Execute FindText:=code, Forward:=True, Wrap:=False
    
    While buildDocument.ActiveWindow.Selection.Find.Found
        '--------------------------------------------------------
        '  Delete the edit replace tag and insert picture.
        '--------------------------------------------------------
        buildDocument.ActiveWindow.Selection.Delete
        If IsFileGraphic(fileName) Then
            Action_InsertPicture fileName, "", False
        Else
            EditReplaceFile fileName
        End If

        '--------------------------------------------------------
        '  Search again
        '--------------------------------------------------------
        thisRange.Select
        buildDocument.ActiveWindow.Selection.Find.Execute FindText:=code, Forward:=True, Wrap:=False
    Wend
    
End Sub







Attribute VB_Name = "modBuildDeclares"
Public debugMsg As Boolean
Public g_DebugEnabled As Boolean
Public g_DebugFile As String
Public bActiveBuild As Boolean

Public Const AppTitle As String = "Qvidian" 'Title for Message Boxes
Public CallingPage As Object
Public continueEditing As Boolean

Public burstMode As Boolean
Public buildDocument As Document
Public buildWindow As Window
Public thisProjectID As Long
Public dh As clsDownloadHelper
Public dcData As clsDynamicContentData
Public cmData As clsCMHeaderData

Public glngWindowWidth As Long
Public glngWindowHeight As Long
Public glngWindowLeft As Long
Public glngWindowTop As Long
Public gstrTemplateName As String

Public sEditReplaceArray() As String
Public iERCnt As Integer
Public sRFPFilesArray() As String
Public iRFPFileCount As Integer
Public bMoveToNextRow As Boolean
Public bDeleteLastRow As Boolean
Public IsReport As Boolean
Public bDefaultAssistantVisible As Boolean
Public bDefaultAssistantSounds As Boolean
Public bHideWordDuringBuild As Boolean
Public bPresentation As Boolean
Public lTempDocCnt As Integer
Public sPathToTempDoc As String
Public sBasePath As String
Public sTempPath As String
Public sTemplatesPath As String
Public sPrintingFilePath As String
Public fso As Object
Public bLockDocument As Boolean
Public bLockPassword As String
Public bLastFileSettingsPreserved As Boolean
Public bKeepTempFileAfterBuild As Boolean
Public lOtherPageTray As Long
Public lFirstPageTray As Long
Public lPaperOrientation As Long
Public lPaperSize As Long
Public bUseBuildSettings As Boolean
Public bAutoSave As Boolean
Public sToolbarTemplate As String 'need to set value?
Public sPrintingTemplate As String
Public sPrintingTemplateExt As String
Public sServer As String 'set?
Public sCRMNoteText As String
Public vParameters() As Variant
Public sMissingEditReplaces As String
Public bFirstAction As Boolean
Public bPrintToPDF As Boolean
Public sDocTypeName As String

Public sDocumentsPath As String 'path to root Qvidian folder
Public sBuildFolder As String 'path to project name and date folder
Public sDocumentFilePath As String 'path to word doc being built
Public sProjectName As String 'just the project name, no extension
Public sPDFFilePath As String 'path to the outputted PDF file

'NEW FOLDERS IN USER'S TEMP FOLDER
Public sBuildDocumentsPath As String 'path to root Qvidian build folder
Public sBuildTempPath As String
Public sBuildTemplatesPath As String

Public lStyleTemplateID As Long
Public sStyleTemplateFileName As String

Dim ctlScript As Object 'MSScriptControl.ScriptControl

Public bReplaceMergeCodes As Boolean
Public bPrintAllSelections As Boolean
Public bConvertDocToDocx As Boolean

Public oDocSettings As struct_DocSettings

Public Enum SantActionCodes
    ACTION_INSERT_TEXT = 1
    ACTION_INSERT_FILE = 2
    ACTION_EDIT_REPLACE = 3
    'ACTION_INSERT_AUTOTEXT = 4
    ACTION_RUN_MACRO = 5
    ACTION_INSERT_PICTURE = 6
    ACTION_INSERT_BREAK = 14
    ACTION_MOVE_THROUGH_TABLE = 15
    ACTION_BOOKMARK_INSERT = 16
    ACTION_BOOKMARK_GOTO = 20
    ACTION_INSERT_OBJECT = 22
    ACTION_PAGE_SETUP = 26
    ACTION_INCLUDE_PRESENTATION = 50
    ACTION_EDIT_REPLACE_GRAPHIC = 52
    ACTION_INSERT_COMPLIANCE_MATRIX = 54
    ACTION_RUN_EDIT_REPLACE_ARRAY = 55
    ACTION_INSERT_FILE_BY_CONTENTID = 57 'Alternate version that accepts CONTENTID
    ACTION_INSERT_PICTURE_BY_CONTENTID = 58 'Alternate version that accepts CONTENTID
    ACTION_INSERT_OBJECT_BY_CONTENTID = 60 'Alternate version that accepts CONTENTID
    ACTION_EDIT_REPLACE_GRAPHIC_BY_CONTENTID = 62 'Alternate version that accepts CONTENTID
    ACTION_BUILD_CHART = 63 'Template will call DownloadChart.aspx, which will build and return the chart.
    ACTION_CLEAN_RFP_MARKERS = 64
    ACTION_DOWNLOAD_RFP_FILE_TO_BUILD_FOLDER = 65
    ACTION_DOWNLOAD_FILE_TO_BUILD_FOLDER = 66
    ACTION_INSERT_COMPLIANCE_MATRIX_FILE = 67
    ACTION_INSERT_COMPLIANCE_MATRIX_ROW = 68
    ACTION_LOCK_DOCUMENT = 69
    ACTION_INSERT_FILE_BY_MISCFILEID = 70 'Insert File for Misc File ID instead of BLOB ID
    ACTION_DYNAMIC_CONTENT_INSERT_FILE = 71
    ACTION_DYNAMIC_CONTENT_ADD_FIELD = 72
    ACTION_DYNAMIC_CONTENT_ADD_VALUE = 73
    ACTION_DYNAMIC_CONTENT_ADD_VALUE_BY_CONTENTID = 74
    ACTION_DYNAMIC_CONTENT_ADD_GLOBAL_VALUE = 75
    ACTION_DYNAMIC_CONTENT_PROCESS_DATA = 76
    ACTION_INSERT_PICTURE_BY_MISCFILEID = 77 'Alternate version that accepts Misc File ID
    ACTION_INSERT_OBJECT_BY_MISCFILEID = 78 'Alternate version that accepts Misc File ID
    ACTION_INSERT_COMPLIANCE_MATRIX_HEADER = 79
    ACTION_COMPLIANCE_MATRIX_PROCESS_HEADERS = 80
    ACTION_COMPLIANCE_MATRIX_CLEAN = 81
    ACTION_EDIT_REPLACE_GRAPHIC_BY_MISCFILEID = 82 'Alternate version that accepts Misc File ID
    ACTION_INSERT_FILE_BY_CONTENTID_REVISION = 83
    ACTION_DISPLAY_BUILD_ERROR = 9999 'An error occurred in the build engine, display the error message.
End Enum

'
Public Enum SearchTypes
    SEARCH_BODY = 1
    SEARCH_HEADERFOOTER = 2
    SEARCH_ALL = 3
End Enum

Public Const DELIM As String = "|"
Public Const ERROR_NO_STYLE As Long = 5834
Public Const PM_TITLE = "Qvidian"
Public Const PB_DOC_NAME As String = "PM_PB.doc"

'#If Win64 Then
'Public Declare PtrSafe Sub OutputDebugString Lib "kernel32" Alias "OutputDebugStringA" (ByVal lpOutputString As String)
'#Else
'Public Declare Sub OutputDebugString Lib "kernel32" Alias "OutputDebugStringA" (ByVal lpOutputString As String)
'#End If

Public Sub SetDebugFile()
    If g_DebugFile = "" Then
        g_DebugFile = GetClientPath() & "QvidianWordDebug.txt"
        Debug.Print "SetDebugFile - [" & g_DebugFile & "]"
        g_DebugEnabled = GetFileSystemObject.FileExists(g_DebugFile)
        DebugMsgBox "SetDebugFile - [" & g_DebugFile & "]", "SetDebugFile"
    End If
End Sub

Public Sub DebugMsgBox(thisText, Optional thisProc As String = "")
    If g_DebugEnabled Then
        On Error Resume Next
        Dim finalMsg As String
        If thisProc <> "" Then
            finalMsg = format(thisProc, "!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
        End If
        finalMsg = finalMsg & thisText
        If debugMsg Then
            If MsgBox(finalMsg, vbOKCancel) = vbCancel Then
                debugMsg = False
            End If
        End If
        'OutputDebugString finalMsg
        Debug.Print finalMsg
        Dim stream As TextStream
        Set stream = GetFileSystemObject.OpenTextFile(g_DebugFile, 8, 1) 'For appending
        stream.WriteLine Now & " - " & finalMsg
        stream.Close
    End If
End Sub

Public Function IsFileGraphic(ByVal sfileName As String)
    Dim sExt As String
    
    sExt = GetFileInfo(sfileName, "Extension")

    Select Case LCase(sExt)
        Case "gif", "bmp", "jpg", "jpeg", "wmf", "tif", "pbm", "pcd", "tiff", "wpg", "pcx", "png"
            IsFileGraphic = True
        Case Else
            IsFileGraphic = False
    End Select
End Function

Public Function dlMiscFile(thisFile As String) As String
    Dim sPath As String
    sPath = sBuildTempPath & "MiscFile_" & thisFile
    If dh.DownloadMiscFile(sPath, Left(thisFile, InStr(1, thisFile, ".") - 1)) Then
        dlMiscFile = sPath
    Else
        dlMiscFile = ""
    End If
End Function

Public Function dlContent(thisFile As String, Optional Revision As Integer = -1, Optional bForceDownload As Boolean = False) As String
    Dim extIdx As Integer
    extIdx = InStr(1, thisFile, ".")
    Dim contentID As String
    contentID = Left(thisFile, extIdx - 1)
    Dim sPath As String
    sPath = sBuildTempPath & "Content_"
    If Revision = -1 Then
        sPath = sPath & thisFile
    Else
        sPath = sPath & contentID & "_" & CStr(Revision) & Mid(thisFile, extIdx)
    End If
    
    DebugMsgBox "FilePath: " & sPath
    sPath = FixDocExt(sPath)
    DebugMsgBox "fixed to: " & sPath
    
    If dh.DownloadContentFile(sPath, contentID, Revision, bForceDownload) Then
        dlContent = sPath
    Else
        dlContent = ""
    End If
End Function


Public Function FixDocExt(thisPath As String) As String
    If bConvertDocToDocx And LCase(GetFileInfo(thisPath, "extension")) = "doc" Then
        FixDocExt = thisPath & "x"
    Else
        FixDocExt = thisPath
    End If
End Function


'-------------------------------------------------------------------------------------------------
'  PURPOSE: To return information about a file string
'  INPUT:   PathAndName: A file name/path as a string
'           InfoType: an optional string specificing the information requested
'              Valid requests are: The path of the string: "Path" (default)
'              The name of the file without the path: "Name"
'              The extention of the file: "Extention"
'              The drive letter of the file: "Drive"
'           OtherOptions: Valid requests are: "No Extension" to return the string without a file
'                         extension
'  RETURN:  A string (an empty string if request was not found)
'-------------------------------------------------------------------------------------------------
Public Function GetFileInfo(ByVal PathAndName As String, Optional InfoType As String = "Path", _
                         Optional OtherOptions As String = "") As String

   Const PathSep As String = "\"
   Dim CurPos As Long, LastPos As Long
   Dim TempString As String
   
   '-----------------------------------------------------------------------------------------
   '
   '-----------------------------------------------------------------------------------------
   Select Case format(InfoType, "<")
      Case "path", "name"
         LastPos = 1
         CurPos = InStr(LastPos, PathAndName, PathSep)
         Do While True
            CurPos = InStr(LastPos, PathAndName, PathSep)
            If CurPos > 0 Then
               LastPos = CurPos + 1
            Else
               Exit Do
            End If
         Loop
         If format(InfoType, "<") = "path" Then
            If LastPos = 1 Then
               GetFileInfo = ""
            Else
               GetFileInfo = Mid(PathAndName, 1, (LastPos - 2))
            End If
         Else
            Select Case format(OtherOptions, "<")
               Case "no extension"
                  TempString = Mid(PathAndName, LastPos, Len(PathAndName) - (LastPos - 1))
                  CurPos = InStr(1, TempString, ".")
                  If CurPos = 0 Then
                     GetFileInfo = TempString
                  Else
                     GetFileInfo = Mid(TempString, 1, CurPos - 1)
                  End If
               Case Else
                  GetFileInfo = Mid(PathAndName, LastPos, Len(PathAndName) - (LastPos - 1))
            End Select
         End If
      Case "extension"
        '03/04/08 [mag]: per bug#3259 changed from InStr because the server could be an
        '               IP Address 128.XXX.XXX.XXX and we want the file extension which
        '               should be the LAST "."
         CurPos = InStrRev(PathAndName, ".")
         If CurPos = 0 Then
            GetFileInfo = ""
         Else
            GetFileInfo = Mid(PathAndName, CurPos + 1, Len(PathAndName) - (CurPos))
         End If
      Case "drive"
         CurPos = InStr(1, PathAndName, ":")
         If CurPos = 0 Then
            GetFileInfo = ""
         Else
            GetFileInfo = Mid(PathAndName, CurPos - 1, 1)
         End If
      Case Else
         GetFileInfo = ""
   End Select
   
End Function


Public Sub ReturnDocumentToNormal()
    'Resume pagination
    Application.Options.Pagination = True
    
    ' 2005-07-26 KV: always switch to Print Layout at the end
    buildDocument.ActiveWindow.ActivePane.View.Type = wdPrintView ' = vViewType
    
    '---------------------------------------------------------------------
    ' Set the Cursor back to normal
    '---------------------------------------------------------------------
    System.Cursor = wdCursorNormal
    
    If bHideWordDuringBuild Then
        'MsgBox glngWindowWidth & " " & glngWindowHeight & " " & glngWindowLeft & " " & glngWindowTop
        Call ResizeAndMoveWindow(glngWindowWidth, glngWindowHeight, glngWindowLeft, glngWindowTop)
    End If
    '---------------------------------------------------------------------
    ' Set the Cursor back to normal
    '---------------------------------------------------------------------
    System.Cursor = wdCursorNormal
End Sub


Public Function CreateDocumentName(ThisProjectName As String, Extension As String) As String
    Dim sDocumentName As String
    Dim sPath As String
    Dim lNamePostFix As Long
    On Error GoTo eh
    
    sPath = sDocumentsPath

    If (Right$(sPath, 1) <> "\") Then sPath = sPath & "\"

    'generate build folder
    Dim adjustedProjectName As String
    If Len(ThisProjectName) > 50 Then
        adjustedProjectName = Left(Replace(ThisProjectName, ".", "_"), 50)
    Else
        adjustedProjectName = Replace(ThisProjectName, ".", "_")
    End If
    sBuildFolder = sPath & "Projects\"
    If Not GetFileSystemObject.FolderExists(sBuildFolder) Then GetFileSystemObject.CreateFolder (sBuildFolder)
    sBuildFolder = sBuildFolder & adjustedProjectName & "\"
    If Not GetFileSystemObject.FolderExists(sBuildFolder) Then GetFileSystemObject.CreateFolder (sBuildFolder)
    sBuildFolder = sBuildFolder & format(Now, "yyyy") & "_" & format(Now, "mm") & "_" & format(Now, "dd") & " " & format(Now, "hh") & "_" & format(Now, "nn") & "_" & format(Now, "ss") & "\"
    If Not GetFileSystemObject.FolderExists(sBuildFolder) Then GetFileSystemObject.CreateFolder (sBuildFolder)
    
    If bPrintToPDF Then
        sPath = sPath & "Temp\"
        If Not GetFileSystemObject.FolderExists(sPath) Then GetFileSystemObject.CreateFolder (sPath)
        
        sBuildFileName = adjustedProjectName & Extension
        sDocumentName = sPath & sBuildFileName
    Else
        
        sBuildFileName = adjustedProjectName & Extension
        sDocumentName = sBuildFolder & sBuildFileName
    End If
                        
    If GetFileSystemObject.FileExists(sDocumentName) Then
        KillPath sDocumentName
    End If
    
    CreateDocumentName = sDocumentName
    Exit Function
eh:
    MsgBox "ERROR! sPath = '" & sPath & "' sDocumentName = '" & sDocumentName & "' ERROR: " & Err.Number & " " & Err.description
End Function

Public Function GetFileSystemObject() As Object
    If TypeName(fso) = "Nothing" Then
        Set fso = CreateObject("Scripting.FileSystemObject")
    End If
    Set GetFileSystemObject = fso
End Function

Public Function GetScriptObject() As Object
    If TypeName(ctlScript) = "Nothing" Then
        Set ctlScript = CreateObject("MSScriptControl.ScriptControl")
        ctlScript.Language = "VBScript"
    End If
    Set GetScriptObject = ctlScript
End Function


Public Sub ResizeAndMoveWindow(ByVal plngWidth As Long, ByVal plngHeight As Long, ByVal plngLeft As Long, ByVal plngTop As Long)
    Dim lobjWord
    If buildDocument.ActiveWindow.WindowState = wdWindowStateMaximize Then buildDocument.ActiveWindow.WindowState = wdWindowStateNormal
    Application.Resize plngWidth, plngHeight
    Application.Move plngLeft, plngTop
End Sub

Public Function GetClientPath() As String
    'We are now pulling the user's documents path from their user preferences.
    'GetClientPath = CallingPage.GetDocumentsPath
    Dim myDocPath As String
    myDocPath = GetMyDocumentsPath
    
    If (Right$(myDocPath, 1) <> "\") Then
        myDocPath = myDocPath & "\"
    End If
    
    GetClientPath = myDocPath & "Qvidian\"
    DebugMsgBox GetClientPath, "GetClientPath:"
    
    Exit Function
End Function

Public Function GetClientBuildTempPath() As String
    Dim myDocPath As String
    myDocPath = GetLongPath(GetFileSystemObject.GetSpecialFolder(2))
    
    If (Right$(myDocPath, 1) <> "\") Then
        myDocPath = myDocPath & "\"
    End If
    
    myDocPath = myDocPath & "Qvidian\"
    If Not GetFileSystemObject.FolderExists(myDocPath) Then
        GetFileSystemObject.CreateFolder (myDocPath)
    End If
    
    'Ensure temp folder exists.
    If Not GetFileSystemObject.FolderExists(myDocPath & "temp\") Then
        GetFileSystemObject.CreateFolder (myDocPath & "temp\")
    End If
    
    GetClientBuildTempPath = myDocPath
    DebugMsgBox GetClientBuildTempPath, "GetClientBuildTempPath:"
    Exit Function
End Function

Public Sub MakeSureBuildPathsExist()
    modTools.EnsureTempFolderExists
    modTools.EnsureBuildTempFolderExists
    sPrintingFilePath = sBuildTempPath & "pm.txt"
End Sub

Public Sub KillPath(sPath As String)
On Error GoTo eh

    If Dir(sPath) <> "" Then
        Kill sPath
    End If

eh:
'Thank you!
End Sub

Public Sub CloseHeaderFooterView()
    'Close the header/footer pane
    If buildDocument.ActiveWindow.Panes.count > 1 Then
        buildDocument.ActiveWindow.Panes(2).Close
    End If
 
    'Switch to Print View
    If buildDocument.ActiveWindow.View.SplitSpecial = wdPaneNone Then
        buildDocument.ActiveWindow.ActivePane.View.Type = wdPrintView
    Else
        buildDocument.ActiveWindow.View.Type = wdPrintView
    End If
End Sub

Public Function StoryExists(ByRef thisDocument As Document, ByVal thisStory As WdStoryType) As Boolean
    On Error Resume Next
    Dim myStoryRange As Range
    Set myStoryRange = thisDocument.StoryRanges(thisStory)
    If Err.Number <> 0 Then
        StoryExists = False
    Else
        StoryExists = True
    End If
    Err.Clear
End Function

Public Sub AddToCollection(ByRef missingStrings As Collection, ByVal newValue As String)
    Dim missingValue As Variant
    For Each missingValue In missingStrings
        If LCase(missingValue) = LCase(newValue) Then
            Exit Sub
        End If
    Next
    missingStrings.Add (newValue)
End Sub










Attribute VB_Name = "modBuildEditReplaces"
Option Explicit

Public Enum ReplaceTiming
    PRE_ER = 1
    POST_ER = 2
    POST_CLEANUP = 3
End Enum

Public Sub ReplaceAllStories(ByRef thisDocument As Document)
    PrepareNestedEditReplacesInArray
    
    ReplaceStories2000AndUp thisDocument
    
    'Handle stories available in Office 2003 and up.
    If getVersion >= 11 Then
        ReplaceStories2003AndUp thisDocument
    End If
    
    'JSB 2012-06-07: Added code to handle shapes that would otherwise not be handled.
    ReplaceInShapes thisDocument
End Sub

Public Sub ReplaceStories2000AndUp(ByRef thisDocument As Document)

    Dim replaceStr As String
    replaceStr = GetTemplateString("Build_modEditReplaces_Replacing")
    
    'Using numbers so this will compile in older versions that don't have the constants.
    StatusBar = replaceStr & " wdMainTextStory"
    ReplaceThisStory thisDocument, 1, False 'wdMainTextStory
    StatusBar = replaceStr & " wdPrimaryHeaderStory"
    ReplaceThisStory thisDocument, 7, True 'wdPrimaryHeaderStory
    StatusBar = replaceStr & " wdPrimaryFooterStory"
    ReplaceThisStory thisDocument, 9, True 'wdPrimaryFooterStory
    StatusBar = replaceStr & " wdFirstPageHeaderStory"
    ReplaceThisStory thisDocument, 10, True 'wdFirstPageHeaderStory
    StatusBar = replaceStr & " wdFirstPageFooterStory"
    ReplaceThisStory thisDocument, 11, True 'wdFirstPageFooterStory
    StatusBar = replaceStr & " wdEvenPagesHeaderStory"
    ReplaceThisStory thisDocument, 6, True 'wdEvenPagesHeaderStory
    StatusBar = replaceStr & " wdEvenPagesFooterStory"
    ReplaceThisStory thisDocument, 8, True 'wdEvenPagesFooterStory
    StatusBar = replaceStr & " wdTextFrameStory"
    'JSB 2012-06-07: Changed to use standard handling, resolved original issue with text boxes in a different way.
    'ReplaceTextBoxStory thisDocument, 5, False 'wdTextFrameStory
    ReplaceThisStory thisDocument, 5, False 'wdTextFrameStory 'ReplaceTextBoxStory
    StatusBar = replaceStr & " wdCommentsStory"
    ReplaceThisStory thisDocument, 4, False 'wdCommentsStory
    StatusBar = replaceStr & " wdEndnotesStory"
    ReplaceThisStory thisDocument, 3, False 'wdEndnotesStory
    StatusBar = replaceStr & " wdFootnotesStory"
    ReplaceThisStory thisDocument, 2, False 'wdFootnotesStory
End Sub

Public Sub ReplaceStories2003AndUp(ByRef thisDocument As Document)
    
    Dim replaceStr As String
    replaceStr = GetTemplateString("Build_modEditReplaces_Replacing")
    
    'Using numbers so this will compile in older versions that don't have the constants.
    StatusBar = replaceStr & " wdEndnoteContinuationNoticeStory"
    ReplaceThisStory thisDocument, 17, False 'wdEndnoteContinuationNoticeStory
    StatusBar = replaceStr & " wdEndnoteContinuationSeparatorStory"
    ReplaceThisStory thisDocument, 16, False 'wdEndnoteContinuationSeparatorStory
    StatusBar = replaceStr & " wdEndnoteSeparatorStory"
    ReplaceThisStory thisDocument, 15, False 'wdEndnoteSeparatorStory
    StatusBar = replaceStr & " wdFootnoteContinuationNoticeStory"
    ReplaceThisStory thisDocument, 14, False 'wdFootnoteContinuationNoticeStory
    StatusBar = replaceStr & " wdFootnoteContinuationSeparatorStory"
    ReplaceThisStory thisDocument, 13, False 'wdFootnoteContinuationSeparatorStory
    StatusBar = replaceStr & " wdFootnoteSeparatorStory"
    ReplaceThisStory thisDocument, 12, False 'wdFootnoteSeparatorStory
End Sub

Private Sub ReplaceThisStory(ByRef thisDocument As Document, ByVal thisStory As WdStoryType, ByVal isHeaderFooter As Boolean)
    Dim MyFindText As String
    Dim MyReplaceText As String
    Dim myStoryRange As Range
    Dim i As Integer
    'JSB 2012-06-07: Added code to switch to print layout to prevent infinite loop issues that can occur when not in print layout.
    SwitchToPrintLayout thisDocument.ActiveWindow
    
    If Not StoryExists(thisDocument, thisStory) And isHeaderFooter Then
        Select Case thisStory
            Case WdStoryType.wdEvenPagesFooterStory
                InitializeHeaderFooter thisDocument.Sections.first.Footers(wdHeaderFooterEvenPages)
            Case WdStoryType.wdEvenPagesHeaderStory
                InitializeHeaderFooter thisDocument.Sections.first.Headers(wdHeaderFooterEvenPages)
            Case WdStoryType.wdFirstPageFooterStory
                InitializeHeaderFooter thisDocument.Sections.first.Footers(wdHeaderFooterFirstPage)
            Case WdStoryType.wdFirstPageHeaderStory
                InitializeHeaderFooter thisDocument.Sections.first.Headers(wdHeaderFooterFirstPage)
            Case WdStoryType.wdPrimaryFooterStory
                InitializeHeaderFooter thisDocument.Sections.first.Footers(wdHeaderFooterPrimary)
            Case WdStoryType.wdPrimaryHeaderStory
                InitializeHeaderFooter thisDocument.Sections.first.Headers(wdHeaderFooterPrimary)
        End Select
    End If
    
    If StoryExists(thisDocument, thisStory) Then
        For i = 0 To UBound(sEditReplaceArray, 2)
            If Len(sEditReplaceArray(1, i)) > 0 Then
                Set myStoryRange = thisDocument.StoryRanges(thisStory)
                
                'JSB 2012-06-07: Changed code to process list to work with the story and nextrange directly,
                'which helps prevent issues with range find re-defining the range.
                ProcessEditReplaceListOnStory thisDocument, thisStory, myStoryRange, i, True
                Do While Not (myStoryRange.NextStoryRange Is Nothing)
                    ProcessEditReplaceListOnStory thisDocument, thisStory, myStoryRange, i, False
                    Set myStoryRange = myStoryRange.NextStoryRange
                Loop
            End If
        Next i
    End If
End Sub

'JSB 2012-06-07: Should no longer need the text box story replace.
'Private Sub ReplaceTextBoxStory(ByRef thisDocument As Document, ByVal thisStory As WdStoryType, ByVal isHeaderFooter As Boolean)
'    Dim MyFindText As String
'    Dim MyReplaceText As String
'    Dim myStoryRange As Range
'    Dim i As Integer
'
'    If StoryExists(thisDocument, thisStory) Then
'        For i = 0 To UBound(sEditReplaceArray, 2)
'            If Len(sEditReplaceArray(1, i)) > 0 Then
'                Set myStoryRange = thisDocument.StoryRanges(thisStory)
'
'                ProcessTextBoxEditReplaceList myStoryRange, i
'                Do While Not (myStoryRange.NextStoryRange Is Nothing)
'                    Set myStoryRange = myStoryRange.NextStoryRange
'                    ProcessEditReplaceListOnRange myStoryRange, i
'                Loop
'            End If
'        Next i
'    End If
'End Sub

'JSB 2012-06-07: Added this routine to handle replacing text in shapes that may not otherwise be handled.
' Also added code to exclude the check for TextFrame2 in versions earlier than Office 2007 (version 12).
Private Sub ReplaceInShapes(ByRef thisDocument As Document)
    Dim s As Shape
    Dim sect As Section
    Dim hf As HeaderFooter
    Dim i As Integer
    Dim shapeObject As Object
    For Each sect In ActiveDocument.Sections
        For Each hf In sect.Headers
            For Each s In hf.Shapes
                If s.Type = 17 Or s.Type = 1 Then
                    On Error Resume Next
                    If s.TextFrame.HasText Then
                        If Err.Number = 0 Then
                            If InStr(1, s.TextFrame.TextRange, "<<") > 0 Then
                                For i = 0 To UBound(sEditReplaceArray, 2)
                                    If Len(sEditReplaceArray(1, i)) > 0 Then
                                        ProcessEditReplaceListOnRange s.TextFrame.TextRange, i
                                    End If
                                Next i
                            End If
                        End If
                    End If
                    If Application.Version >= 12 Then
                        Set shapeObject = s
                        If shapeObject.TextFrame2.HasText Then
                            If Err.Number = 0 Then
                                If InStr(1, shapeObject.TextFrame2.TextRange, "<<") > 0 Then
                                    For i = 0 To UBound(sEditReplaceArray, 2)
                                        If Len(sEditReplaceArray(1, i)) > 0 Then
                                            ProcessEditReplaceListOnRange2 shapeObject.TextFrame2.TextRange, i
                                        End If
                                    Next i
                                End If
                            End If
                        End If
                    End If
                End If
            Next s
        Next hf
        For Each hf In sect.Footers
            For Each s In hf.Shapes
                If s.Type = 17 Or s.Type = 1 Then
                    On Error Resume Next
                    If s.TextFrame.HasText Then
                        If Err.Number = 0 Then
                            If InStr(1, s.TextFrame.TextRange, "<<") > 0 Then
                                For i = 0 To UBound(sEditReplaceArray, 2)
                                    If Len(sEditReplaceArray(1, i)) > 0 Then
                                        ProcessEditReplaceListOnRange s.TextFrame.TextRange, i
                                    End If
                                Next i
                            End If
                        End If
                    End If
                    If Application.Version >= 12 Then
                        Set shapeObject = s
                        If shapeObject.TextFrame2.HasText Then
                            If Err.Number = 0 Then
                                If InStr(1, shapeObject.TextFrame2.TextRange, "<<") > 0 Then
                                    For i = 0 To UBound(sEditReplaceArray, 2)
                                        If Len(sEditReplaceArray(1, i)) > 0 Then
                                            ProcessEditReplaceListOnRange2 shapeObject.TextFrame2.TextRange, i
                                        End If
                                    Next i
                                End If
                            End If
                        End If
                    End If
                End If
            Next s
        Next hf
    Next sect
    For Each s In ActiveDocument.Shapes
        If s.Type = 17 Or s.Type = 1 Then
            On Error Resume Next
            If s.TextFrame.HasText Then
                If Err.Number = 0 Then
                    If InStr(1, s.TextFrame.TextRange, "<<") > 0 Then
                        For i = 0 To UBound(sEditReplaceArray, 2)
                            If Len(sEditReplaceArray(1, i)) > 0 Then
                                ProcessEditReplaceListOnRange s.TextFrame.TextRange, i
                            End If
                        Next i
                    End If
                End If
            End If
            If Application.Version >= 12 Then
                Set shapeObject = s
                If shapeObject.TextFrame2.HasText Then
                    If Err.Number = 0 Then
                        If InStr(1, shapeObject.TextFrame2.TextRange, "<<") > 0 Then
                            For i = 0 To UBound(sEditReplaceArray, 2)
                                If Len(sEditReplaceArray(1, i)) > 0 Then
                                    ProcessEditReplaceListOnRange2 shapeObject.TextFrame2.TextRange, i
                                End If
                            Next i
                        End If
                    End If
                End If
            End If
        End If
    Next s
    
#If VBA7 Then
    'handle inline shapes
    Dim nodeIndex As Integer
    Dim inShp As InlineShape
    
    If Application.Version >= 14 Then
        For Each inShp In ActiveDocument.InlineShapes
            If inShp.HasSmartArt Then
                On Error Resume Next
                For nodeIndex = 1 To inShp.SmartArt.Nodes.count
                    If inShp.SmartArt.Nodes(nodeIndex).TextFrame2.HasText Then
                        If InStr(1, inShp.SmartArt.Nodes(nodeIndex).TextFrame2.TextRange, "<<") > 0 Then
                            For i = 0 To UBound(sEditReplaceArray, 2)
                                If Len(sEditReplaceArray(1, i)) > 0 Then
                                    ProcessEditReplaceListOnRange2 inShp.SmartArt.Nodes(nodeIndex).TextFrame2.TextRange, i
                                End If
                            Next i
                        End If
                    End If 'has text
                Next 'node index
            End If 'has smart art
        Next 'inshp
    End If 'app version
#End If
    
End Sub

'DS 8/28/12 new function to handle format codes in shapes
Private Sub FormatInShapes(ByRef thisDocument As Document, timing As ReplaceTiming)
    Dim s As Shape
    Dim sect As Section
    Dim hf As HeaderFooter
    Dim i As Integer
    Dim shapeObject As Object
    For Each sect In ActiveDocument.Sections
        For Each hf In sect.Headers
            For Each s In hf.Shapes
                If s.Type = 17 Or s.Type = 1 Then
                    On Error Resume Next
                    If s.TextFrame.HasText Then
                        If Err.Number = 0 Then
                            ProcessFormattingReplaceList thisDocument, s.TextFrame.TextRange, timing
                        End If
                    End If
                    If Application.Version >= 12 Then
                        Set shapeObject = s
                        If shapeObject.TextFrame2.HasText Then
                            If Err.Number = 0 Then
                                ProcessFormattingReplaceListInRange2 thisDocument, shapeObject.TextFrame2.TextRange, timing
                            End If
                        End If
                    End If
                End If
            Next s
        Next hf
        For Each hf In sect.Footers
            For Each s In hf.Shapes
                If s.Type = 17 Or s.Type = 1 Then
                    On Error Resume Next
                    If s.TextFrame.HasText Then
                        If Err.Number = 0 Then
                            ProcessFormattingReplaceList thisDocument, s.TextFrame.TextRange, timing
                        End If
                    End If
                    If Application.Version >= 12 Then
                        Set shapeObject = s
                        If shapeObject.TextFrame2.HasText Then
                            If Err.Number = 0 Then
                                ProcessFormattingReplaceListInRange2 thisDocument, shapeObject.TextFrame2.TextRange, timing
                            End If
                        End If
                    End If
                End If
            Next s
        Next hf
    Next sect
    For Each s In ActiveDocument.Shapes
        If s.Type = 17 Or s.Type = 1 Then
            On Error Resume Next
            If s.TextFrame.HasText Then
                If Err.Number = 0 Then
                    ProcessFormattingReplaceList thisDocument, s.TextFrame.TextRange, timing
                End If
            End If
            If Application.Version >= 12 Then
                Set shapeObject = s
                If shapeObject.TextFrame2.HasText Then
                    If Err.Number = 0 Then
                        ProcessFormattingReplaceListInRange2 thisDocument, shapeObject.TextFrame2.TextRange, timing
                    End If
                End If
            End If
        End If
    Next s
    
#If VBA7 Then
    'handle inline shapes
    Dim nodeIndex As Integer
    Dim inShp As InlineShape
    
    If Application.Version >= 14 Then
        For Each inShp In ActiveDocument.InlineShapes
            If inShp.HasSmartArt Then
                On Error Resume Next
                For nodeIndex = 1 To inShp.SmartArt.Nodes.count
                    If inShp.SmartArt.Nodes(nodeIndex).TextFrame2.HasText Then
                        ProcessFormattingReplaceListInRange2 thisDocument, inShp.SmartArt.Nodes(nodeIndex).TextFrame2.TextRange, timing
                    End If 'has text
                Next 'node index
            End If 'has smart art
        Next 'inshp
    End If 'app version
#End If
    
End Sub


'Think of this as 2 lists of edit/replaces.  We loop through the first list,
'   and check if any records in the second list are in the values of the first list.
Private Sub PrepareNestedEditReplacesInArray()
    Const MAX_PASSES As Integer = 100
    Dim i As Integer
    Dim X As Integer
    Dim iPassCounter As Integer
    Dim bContinue As Boolean
    
    'Loop through list of edit/replaces.
    For i = 0 To UBound(sEditReplaceArray, 2)
        iPassCounter = 0
        'Check if the value for this edit/replace has another edit/replaces in it.
        If InStr(1, sEditReplaceArray(1, i), "<<") Then
            bContinue = True
            'Loop while we're REPLACING edit/replaces in the text.
            Do While bContinue
                bContinue = False
                'Make a pass through the edit/replaces list.
                iPassCounter = iPassCounter + 1
                For X = 0 To UBound(sEditReplaceArray, 2)
                    'Check if this edit/replace exists in the value we're looking at.
                    If InStr(1, sEditReplaceArray(1, i), sEditReplaceArray(0, X)) Then
                        'Replace the edit/replace in the value, and set the flag to go through the list again.
                        sEditReplaceArray(1, i) = Replace(sEditReplaceArray(1, i), sEditReplaceArray(0, X), sEditReplaceArray(1, X))
                        bContinue = True
                    End If
                Next X
                'If we've reached the maximum number of passes, we have likely encountered an infinite loop.  Move on.
                If iPassCounter = MAX_PASSES Then
                    bContinue = False
                End If
            Loop
        End If
    Next i
End Sub

'JSB 2012-06-07: Handling text boxes in a different way that appears to work.  Removing this code.
'' Word will not let you replace more than 255 characters in a FormField right now
'' in VBA:( So, we'll truncate anything more than that until I can make the work-around
'' actually work (look at ProcessEditReplaceListOnRange), which it does not:(
'Private Sub ProcessTextBoxEditReplaceList(ByVal thisRange As Range, ByVal i As Integer)
'    Dim tempRange As Range
'    Dim counter As Integer
'    Dim repText As String
'    If InStr(1, LCase(thisRange.Text), LCase(sEditReplaceArray(0, i)), vbTextCompare) > 0 Then
'        If Len(sEditReplaceArray(1, i)) < 256 Then
'            repText = sEditReplaceArray(1, i)
'        Else
'            repText = Mid(sEditReplaceArray(1, i), 1, 255)
'        End If
'
'        With thisRange.Find
'            .Text = sEditReplaceArray(0, i)
'            .Wrap = wdFindContinue
'            .MatchCase = False
'            .Replacement.Text = repText
'            .Execute Replace:=wdReplaceAll
'        End With
'    End If
'End Sub

'JSB 2012-06-07: Added this routine to handle processing the merge code list in a way that
' should run into fewer issus with range find redefining the range.  Cleans up a couple of other issues as well.
Private Sub ProcessEditReplaceListOnStory(ByRef thisDocument As Document, ByRef thisStory As WdStoryType, ByVal originalRange As Range, ByVal i As Integer, ByVal bFirst As Boolean)
    Dim tempRange As Range
    Dim bContinue As Boolean

    'Set the range for each find.
    If bFirst Then
        Set tempRange = thisDocument.StoryRanges(thisStory)
    Else
        Set tempRange = originalRange.NextStoryRange
    End If

    'To save time, see if the text contains any instances of the code before using Word's find.
    If InStr(1, LCase(tempRange.Text), LCase(sEditReplaceArray(0, i)), vbTextCompare) > 0 Then
        If Len(sEditReplaceArray(1, i)) < 256 Then
            'Replace text is less than 256 characters, use regular find/replace.
            With tempRange.Find
                .Text = sEditReplaceArray(0, i)
                .Wrap = wdFindContinue
                .MatchCase = False
                .Replacement.Text = sEditReplaceArray(1, i)
                .Execute Replace:=wdReplaceAll
            End With
        Else
            'Replace text is longer than find/replace supports.  Just find, and manually replace.
            bContinue = True
            While bContinue
                'Reset the range for each find.
                If bFirst Then
                    Set tempRange = thisDocument.StoryRanges(thisStory)
                Else
                    Set tempRange = originalRange.NextStoryRange
                End If
                
                'Find the merge code
                With tempRange.Find
                    .Text = sEditReplaceArray(0, i)
                    .Wrap = wdFindContinue
                    .MatchCase = False
                    .Execute
                    If .Found Then
                        tempRange.Text = sEditReplaceArray(1, i)
                    Else
                        bContinue = False
                    End If
                End With
            Wend
        End If
    End If
End Sub

'JSB 2012-06-07: Changed this code to specifically work on a range, and to handle the replace more efficiently.
Private Sub ProcessEditReplaceListOnRange(ByVal originalRange As Range, ByVal i As Integer)
    Dim tempRange As Range
    Set tempRange = originalRange
    If InStr(1, LCase(originalRange.Text), LCase(sEditReplaceArray(0, i)), vbTextCompare) > 0 Then
        With tempRange.Find
            .Text = sEditReplaceArray(0, i)
            .Wrap = wdFindContinue
            .MatchCase = False
            If Len(sEditReplaceArray(1, i)) < 256 Then
                .Replacement.Text = sEditReplaceArray(1, i)
                .Execute Replace:=wdReplaceAll
            Else
                Do While .Execute = True
                    tempRange.Text = sEditReplaceArray(1, i)
                    Set tempRange = originalRange
                Loop
            End If
        End With
    End If
End Sub

'DS 8/28/12 TextRange2 (2010) does not support the .Find object and uses a different syntax...
Private Sub ProcessEditReplaceListOnRange2(ByVal originalRange As TextRange2, ByVal i As Integer)
    Do While InStr(1, LCase(originalRange.Text), LCase(sEditReplaceArray(0, i)), vbTextCompare) > 0
        originalRange.Replace LCase(sEditReplaceArray(0, i)), sEditReplaceArray(1, i)
    Loop
End Sub

Public Sub ProcessEditReplaceListForExcel(ByRef thisWorkbook As Object)
    Dim i As Integer
    Dim oSheet As Object
    
    PrepareNestedEditReplacesInArray
    
    For Each oSheet In thisWorkbook.Worksheets
        For i = 0 To UBound(sEditReplaceArray, 2)
            'Note: The replace routine has a MatchByte parameter that is documented as follows:
            '   "You can use this argument only if you|fffd|ve selected or installed double-byte language support in Microsoft Excel"
            '   I'm not sure if that means it isn't available, or if it isn't functional without double-byte language support.
            '   So, if we have problems, we'll try it with the extra parameter, and if we get an error we'll try without.
            '   If we have to fix this problem, please also check modFormatReplaces for its use of the replace routine.
            If TypeName(oSheet.Cells.Find(sEditReplaceArray(0, i), , -4163, 2, 1, 1, False, False)) <> "Nothing" Then
                oSheet.Cells.Replace sEditReplaceArray(0, i), sEditReplaceArray(1, i), 2, 1, False, False, False, False
            End If
        Next i
    Next oSheet
End Sub


Public Sub CleanUpEditReplaces()

    Dim lCurrentSection As Long
    Dim missingValue As Variant
    Dim lItem As Long
    Dim missingStrings As New Collection

    buildDocument.ActiveWindow.Selection.HomeKey Unit:=wdStory, Extend:=wdMove

   buildDocument.ActiveWindow.Selection.Find.ClearFormatting
   With buildDocument.ActiveWindow.Selection.Find
      .Text = "<<"
      .Forward = True
      .Wrap = wdFindContinue
      .format = True
      .MatchCase = False
      .MatchWholeWord = False
      .MatchWildcards = False
      .MatchSoundsLike = False
      .MatchAllWordForms = False
   End With
   
   buildDocument.ActiveWindow.Selection.Find.Execute
   buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
   'find start of code <<..
   While buildDocument.ActiveWindow.Selection.Find.Found
        'find end of code...
        buildDocument.ActiveWindow.Selection.ExtendMode = True
        
        buildDocument.ActiveWindow.Selection.Find.Execute FindText:=">>", Forward:=True, Wrap:=False
        buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
        If buildDocument.ActiveWindow.Selection.Find.Found Then
            AddToCollection missingStrings, buildDocument.ActiveWindow.Selection.Text
            buildDocument.ActiveWindow.Selection.Text = ""
        End If
        
        '--------------------------------------------------------
        '  Turn off the 'ExtendSelection'
        '--------------------------------------------------------
        buildDocument.ActiveWindow.Selection.ExtendMode = False
        '--------------------------------------------------------
        '  Search again
        '--------------------------------------------------------
'        Selection.HomeKey unit:=wdStory, Extend:=wdMove
        buildDocument.ActiveWindow.Selection.Find.Execute FindText:="<<", Forward:=True, Wrap:=False
        buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
        buildDocument.UndoClear
   Wend
   
   'headers...
    For lItem = 1 To buildDocument.Sections.count
        
        If lItem = 1 Then
            buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToSection, which:=wdGoToAbsolute, count:=lItem, name:=""
            If buildDocument.ActiveWindow.View.SplitSpecial <> wdPaneNone Then
                buildDocument.ActiveWindow.Panes(2).Close
            End If
            If buildDocument.ActiveWindow.ActivePane.View.Type = wdNormalView Or buildDocument.ActiveWindow. _
                ActivePane.View.Type = wdOutlineView Or buildDocument.ActiveWindow.ActivePane.View.Type _
                 = wdMasterView Then
                buildDocument.ActiveWindow.ActivePane.View.Type = wdPageView
            End If
            
            buildDocument.ActiveWindow.ActivePane.View.SeekView = wdSeekCurrentPageHeader
        Else
            lCurrentSection = buildDocument.ActiveWindow.Selection.Information(wdActiveEndSectionNumber)
        
            If lCurrentSection = buildDocument.Sections.count Then
                Exit For
            End If
             
            On Error Resume Next
            Err.Clear
             
            buildDocument.ActiveWindow.ActivePane.View.NextHeaderFooter
            
            If Err.Number > 0 Then
                Exit For
            End If
            
        End If
        
           buildDocument.ActiveWindow.Selection.Find.Execute
           buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
           
           'find start of code <<..
           While buildDocument.ActiveWindow.Selection.Find.Found
                'find end of code...
                buildDocument.ActiveWindow.Selection.ExtendMode = True
                
                buildDocument.ActiveWindow.Selection.Find.Execute FindText:=">>", Forward:=True, Wrap:=False
                buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
                
                If buildDocument.ActiveWindow.Selection.Find.Found Then
                    AddToCollection missingStrings, buildDocument.ActiveWindow.Selection.Text
                    buildDocument.ActiveWindow.Selection.Text = ""
                End If
                
                '--------------------------------------------------------
                '  Turn off the 'ExtendSelection'
                '--------------------------------------------------------
                buildDocument.ActiveWindow.Selection.ExtendMode = False
                '--------------------------------------------------------
                '  Search again
                '--------------------------------------------------------
        '        Selection.HomeKey unit:=wdStory, Extend:=wdMove
                buildDocument.ActiveWindow.Selection.Find.Execute FindText:="<<", Forward:=True, Wrap:=False
                buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
                
                buildDocument.UndoClear
           Wend

    Next lItem
   
    'footers...
    For lItem = 1 To buildDocument.Sections.count
        
        If lItem = 1 Then
            buildDocument.ActiveWindow.Selection.GoTo what:=wdGoToSection, which:=wdGoToAbsolute, count:=lItem, name:=""
            If buildDocument.ActiveWindow.View.SplitSpecial <> wdPaneNone Then
                buildDocument.ActiveWindow.Panes(2).Close
            End If
            If buildDocument.ActiveWindow.ActivePane.View.Type = wdNormalView Or buildDocument.ActiveWindow. _
                ActivePane.View.Type = wdOutlineView Or buildDocument.ActiveWindow.ActivePane.View.Type _
                 = wdMasterView Then
                buildDocument.ActiveWindow.ActivePane.View.Type = wdPageView
            End If
            
            buildDocument.ActiveWindow.ActivePane.View.SeekView = wdSeekCurrentPageFooter
        Else
            lCurrentSection = buildDocument.ActiveWindow.Selection.Information(wdActiveEndSectionNumber)
        
            If lCurrentSection = buildDocument.Sections.count Then
                Exit For
            End If
             
            On Error Resume Next
            Err.Clear
             
            buildDocument.ActiveWindow.ActivePane.View.NextHeaderFooter
            
            If Err.Number > 0 Then
                Exit For
            End If
            
        End If
        
           buildDocument.ActiveWindow.Selection.Find.Execute
           buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
           'find start of code <<..
           While buildDocument.ActiveWindow.Selection.Find.Found
                'find end of code...
                buildDocument.ActiveWindow.Selection.ExtendMode = True
                
                buildDocument.ActiveWindow.Selection.Find.Execute FindText:=">>", Forward:=True, Wrap:=False
                buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
                
                If buildDocument.ActiveWindow.Selection.Find.Found Then
                    AddToCollection missingStrings, buildDocument.ActiveWindow.Selection.Text
                    buildDocument.ActiveWindow.Selection.Text = ""
                End If
                
                '--------------------------------------------------------
                '  Turn off the 'ExtendSelection'
                '--------------------------------------------------------
                buildDocument.ActiveWindow.Selection.ExtendMode = False
                '--------------------------------------------------------
                '  Search again
                '--------------------------------------------------------
        '        Selection.HomeKey unit:=wdStory, Extend:=wdMove
                buildDocument.ActiveWindow.Selection.Find.Execute FindText:="<<", Forward:=True, Wrap:=False
                buildDocument.Activate 'JSB: Workaround to a Word issue that switched docs on Execute.
                
                buildDocument.UndoClear
           Wend

    Next lItem
    
    buildDocument.ActiveWindow.ActivePane.View.SeekView = wdSeekMainDocument
   
    If missingStrings.count > 0 Then
        sMissingEditReplaces = ""
        For Each missingValue In missingStrings
            sMissingEditReplaces = sMissingEditReplaces & missingValue & vbCrLf
        Next
        Application.Activate
        frmEditReplace.Show
    End If
    
End Sub

'*************************************************************
' Format Replaces
'*************************************************************

Public Sub FormatAllStories(ByRef thisDocument As Document, ByVal timing As ReplaceTiming)
    FormatStories2000AndUp thisDocument, timing
    
    'Handle stories available in Office 2003 and up.
    If getVersion >= 11 Then
        FormatStories2003AndUp thisDocument, timing
    End If
    
    'DS 8/28/12 add code to format shapes, so any codes inside shapes that have formatting info get processed
    FormatInShapes thisDocument, timing
End Sub

Public Sub FormatStories2000AndUp(ByRef thisDocument As Document, ByVal timing As ReplaceTiming)
    'Using numbers so this will compile in older versions that don't have the constants.
    FormatThisStory thisDocument, 1, False, timing 'wdMainTextStory
    FormatThisStory thisDocument, 7, True, timing 'wdPrimaryHeaderStory
    FormatThisStory thisDocument, 9, True, timing 'wdPrimaryFooterStory
    FormatThisStory thisDocument, 10, True, timing 'wdFirstPageHeaderStory
    FormatThisStory thisDocument, 11, True, timing 'wdFirstPageFooterStory
    FormatThisStory thisDocument, 6, True, timing 'wdEvenPagesHeaderStory
    FormatThisStory thisDocument, 8, True, timing 'wdEvenPagesFooterStory
    FormatThisStory thisDocument, 5, False, timing 'wdTextFrameStory
    FormatThisStory thisDocument, 4, False, timing 'wdCommentsStory
    FormatThisStory thisDocument, 3, False, timing 'wdEndnotesStory
    FormatThisStory thisDocument, 2, False, timing 'wdFootnotesStory
End Sub

Public Sub FormatStories2003AndUp(ByRef thisDocument As Document, ByVal timing As ReplaceTiming)
    'Using numbers so this will compile in older versions that don't have the constants.
    FormatThisStory thisDocument, 17, False, timing 'wdEndnoteContinuationNoticeStory
    FormatThisStory thisDocument, 16, False, timing 'wdEndnoteContinuationSeparatorStory
    FormatThisStory thisDocument, 15, False, timing 'wdEndnoteSeparatorStory
    FormatThisStory thisDocument, 14, False, timing 'wdFootnoteContinuationNoticeStory
    FormatThisStory thisDocument, 13, False, timing 'wdFootnoteContinuationSeparatorStory
    FormatThisStory thisDocument, 12, False, timing 'wdFootnoteSeparatorStory
End Sub

Private Sub FormatThisStory(ByRef thisDocument As Document, ByVal thisStory As WdStoryType, ByVal isHeaderFooter As Boolean, ByVal timing As ReplaceTiming)
    Dim MyFindText As String
    Dim MyReplaceText As String
    Dim myStoryRange As Range
    
    If Not StoryExists(thisDocument, thisStory) And isHeaderFooter Then
        Select Case thisStory
            Case WdStoryType.wdEvenPagesFooterStory
                InitializeHeaderFooter thisDocument.Sections.first.Footers(wdHeaderFooterEvenPages)
            Case WdStoryType.wdEvenPagesHeaderStory
                InitializeHeaderFooter thisDocument.Sections.first.Headers(wdHeaderFooterEvenPages)
            Case WdStoryType.wdFirstPageFooterStory
                InitializeHeaderFooter thisDocument.Sections.first.Footers(wdHeaderFooterFirstPage)
            Case WdStoryType.wdFirstPageHeaderStory
                InitializeHeaderFooter thisDocument.Sections.first.Headers(wdHeaderFooterFirstPage)
            Case WdStoryType.wdPrimaryFooterStory
                InitializeHeaderFooter thisDocument.Sections.first.Footers(wdHeaderFooterPrimary)
            Case WdStoryType.wdPrimaryHeaderStory
                InitializeHeaderFooter thisDocument.Sections.first.Headers(wdHeaderFooterPrimary)
        End Select
    End If
    
    If StoryExists(thisDocument, thisStory) Then
        Set myStoryRange = thisDocument.StoryRanges(thisStory)
        ProcessFormattingReplaceList thisDocument, myStoryRange, timing
        Do While Not (myStoryRange.NextStoryRange Is Nothing)
            Set myStoryRange = myStoryRange.NextStoryRange
            ProcessFormattingReplaceList thisDocument, myStoryRange, timing
        Loop
    End If
End Sub

Private Sub ProcessFormattingReplaceList(ByRef thisDocument As Document, ByVal thisRange As Range, ByVal timing As ReplaceTiming)
    If InStr(1, thisRange.Text, "{{") > 0 Then
    
        Select Case timing
            Case ReplaceTiming.PRE_ER
                FindReplaceFormattingCode thisDocument, thisRange, "{{InsertAutoText}}"
            
            Case ReplaceTiming.POST_ER
    
                'Moved these compliance matrix related codes to before the rest of the formatting codes,
                'because the table autoformat must occur before setting text to bold.
                FindReplaceFormattingCode thisDocument, thisRange, "{{TextToTable}}"
                FindReplaceTableFormattingCode thisDocument, thisRange, "{{MergeCells}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableAutoFormat}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableAutoFormatDoubleHeader}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableStyle}}" 'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableStyleAdvanced}}" 'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{ApplyStyleToParagraph}}" 'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{LeftIndentInches}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{LeftIndentCentimeters}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{LeftIndentPoints}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableWidthInches}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableWidthCentimeters}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{TableWidthPoints}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{ColumnWidthInches}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{ColumnWidthCentimeters}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{ColumnWidthPoints}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{ColumnWidthPercent}}"  'NEW
                FindReplaceFormattingCode thisDocument, thisRange, "{{Symbol}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{AddBookmark}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{LinkToBookmark}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{AutoFitContents}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{ApplyStyleToRow}}"
                FindReplaceTableFormattingCode thisDocument, thisRange, "{{Right}}" 'NEW
                FindReplaceTableFormattingCode thisDocument, thisRange, "{{Left}}" 'NEW
                FindReplaceTableFormattingCode thisDocument, thisRange, "{{Center}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{LinkToPrevious}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{ApplyWatermarkFromFile}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{Bold}}"
                FindReplaceTableFormattingCode thisDocument, thisRange, "{{Bold}}"
                
                'These formatting codes may change based on the
                'regional setting that can now be applied to projects.
                FindReplaceFormattingCode thisDocument, thisRange, "{{DateLong}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{DateShort}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{Currency}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{Number}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{DefaultLongDate}}"
                FindReplaceFormattingCode thisDocument, thisRange, "{{DefaultShortDate}}"
            
            Case ReplaceTiming.POST_CLEANUP
                'This formatting code should be the last one, so that any
                'formatting codes that were within this marker have already been replaced.
                FindReplaceFormattingCode thisDocument, thisRange, "{{DeleteParagraphIfEmpty}}"
        End Select
    End If
End Sub


Private Sub ProcessFormattingReplaceListInRange2(ByRef thisDocument As Document, ByVal thisRange As TextRange2, ByVal timing As ReplaceTiming)
    If InStr(1, thisRange.Text, "{{") > 0 Then
    
        Select Case timing
            Case ReplaceTiming.PRE_ER
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{InsertAutoText}}"
            
            Case ReplaceTiming.POST_ER
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{Symbol}}"
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{Bold}}"
                
                'These formatting codes may change based on the
                'regional setting that can now be applied to projects.
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{DateLong}}"
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{DateShort}}"
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{Currency}}"
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{Number}}"
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{DefaultLongDate}}"
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{DefaultShortDate}}"
            
            Case ReplaceTiming.POST_CLEANUP
                'This formatting code should be the last one, so that any
                'formatting codes that were within this marker have already been replaced.
                FindReplaceFormattingCodeInRange2 thisDocument, thisRange, "{{DeleteParagraphIfEmpty}}"
        End Select
    End If
End Sub

'Sub needed to handle textRange2 objects which do not support the same object model as regular textranges
Private Sub FindReplaceFormattingCodeInRange2(ByRef thisDocument As Document, ByVal thisRange As TextRange2, ByVal thisFormattingCode As String)
    Dim tempRange As TextRange2
    Dim ApplyRange As TextRange2
    Dim lStart As Long
    Dim lEnd As Long
    
    'loops so we get all instances of this formatting code
    Do While InStr(1, thisRange.Text, thisFormattingCode) > 0
        Set tempRange = thisRange.Find(thisFormattingCode)
        'find starting point of first code instance
        lStart = tempRange.Start
        
        'remove the code
        tempRange.Text = ""
        
        'find the matching code
        If InStr(1, thisRange.Text, thisFormattingCode) > 0 Then
            Set tempRange = thisRange.Find(thisFormattingCode)
            'this is the start position of the matching code
            lEnd = tempRange.Start
    
            'remove the code
            tempRange.Text = ""
            
            'create a new range selecting only the characters between the prior code locations
            Set ApplyRange = thisRange.Characters(lStart, lEnd - lStart)
            
            'apply formatting to the new range text
            ApplyFormattingToRange2 thisDocument, thisFormattingCode, ApplyRange
        End If
    Loop
End Sub

'Unfortunately, many of the subtleties of the range.find require that we
'redefine the range we're working with after every execute, and that we
'use a continuation flag in the while look instead of range.find.found
'(because the range gets redefined within the loop).  We are also redefining
'the find properties for the range object each time we redefine it (they are not sticky).
'We also had to change from removing the markers after selecting the text to removing
'them right after we find them.  Since the range.find doesn't select what it finds
'(it only redefines the range), we have to get the starting and ending positions of what
'we find so that we can select the text between the markers.
Private Sub FindReplaceFormattingCode(ByRef thisDocument As Document, ByVal thisRange As Range, ByVal thisFormattingCode As String)
    Dim FindRange As Range
    Dim lStart As Long
    Dim lEnd As Long
    Dim bContinue As Boolean
    Dim EscapedCode As String
    Dim WildCardCode As String
    Dim sFoundText As String
    Dim RangeCopy1 As Range
    Dim RangeCopy2 As Range
    EscapedCode = Replace(Replace(thisFormattingCode, "{", "\{"), "}", "\}")
    WildCardCode = EscapedCode & "*" & EscapedCode
    
    Set FindRange = thisRange.Duplicate
    If InStr(1, FindRange.Text, "{{") > 0 Then
        With FindRange.Find
            .ClearFormatting
            .Text = WildCardCode 'thisFormattingCode
            .Wrap = wdFindContinue
            .MatchWildcards = True
            .MatchCase = False
            .Execute
        End With
        
        bContinue = FindRange.Find.Found

        While bContinue
            'lStart = FindRange.Start
            'FindRange.Delete

            If FindRange.Find.Found Then
            
                sFoundText = FindRange.Text
                sFoundText = Replace(sFoundText, thisFormattingCode, "")
                
                Set RangeCopy1 = FindRange.Duplicate
                Set RangeCopy2 = FindRange.Duplicate
                
                With RangeCopy1.Find
                    .ClearFormatting
                    .Text = thisFormattingCode 'thisFormattingCode
                    .Wrap = wdFindContinue
                    .MatchWildcards = False
                    .MatchCase = False
                    .Execute
                End With
                RangeCopy1.Delete
                
                'If the range already equals the formatting code, delete it.
                'Otherwise, find the code within the range, then delete it.
                If RangeCopy2.Text = thisFormattingCode Then
                    RangeCopy2.Delete
                Else
                    With RangeCopy2.Find
                        .ClearFormatting
                        .Text = thisFormattingCode 'thisFormattingCode
                        .Wrap = wdFindContinue
                        .MatchWildcards = False
                        .MatchCase = False
                        .Execute
                    End With
                    RangeCopy2.Delete
                End If
            
                ApplyFormatting thisDocument, thisFormattingCode, FindRange
            End If
            Set FindRange = thisRange.Duplicate
            With FindRange.Find
                .ClearFormatting
                .Text = WildCardCode 'thisFormattingCode
                .Wrap = wdFindContinue
                .MatchWildcards = True
                .MatchCase = False
                .Execute
            End With
            
            bContinue = FindRange.Find.Found
        Wend
        thisDocument.UndoClear
    End If
    
End Sub

Private Sub FindReplaceTableFormattingCode(ByRef thisDocument As Document, ByVal thisRange As Range, ByVal thisFormattingCode As String)
    Dim FindRange As Range
    Dim lStart As Long
    Dim lEnd As Long
    Dim bContinue As Boolean
    Dim sFoundText As String
    
    Set FindRange = thisRange.Duplicate
    If InStr(1, FindRange.Text, "{{") > 0 Then
        With FindRange.Find
            .ClearFormatting
            .Text = thisFormattingCode
            .Wrap = wdFindContinue
            .MatchWildcards = False
            .MatchCase = False
            .Execute
        End With

        bContinue = FindRange.Find.Found

        While bContinue
            lStart = FindRange.Start
            FindRange.Delete
            Set FindRange = thisRange.Duplicate
            With FindRange.Find
                .ClearFormatting
                .Text = thisFormattingCode
                .Wrap = wdFindContinue
                .MatchWildcards = False
                .MatchCase = False
                .Execute
            End With
            If FindRange.Find.Found Then
                FindRange.Delete
                lEnd = FindRange.End
                thisDocument.Range(lStart, lEnd + 1).Select

                ApplyFormatting thisDocument, thisFormattingCode, thisDocument.ActiveWindow.Selection.Range
            End If
            Set FindRange = thisRange.Duplicate
            With FindRange.Find
                .ClearFormatting
                .Text = thisFormattingCode
                .Wrap = wdFindContinue
                .MatchWildcards = False
                .MatchCase = False
                .Execute
            End With
            bContinue = FindRange.Find.Found
        Wend
        thisDocument.UndoClear
    End If
End Sub

Private Sub RemoveFormattingCode(ByRef thisDocument As Document, ByVal thisFormattingCode As String)
    Dim thisRange As Range
    Set thisRange = thisDocument.ActiveWindow.Selection.Range
    With thisRange.Find
        .ClearFormatting
        .Text = thisFormattingCode
        .Replacement.Text = ""
        .Wrap = wdFindStop
    End With
    thisRange.Find.Execute Replace:=wdReplaceAll
    thisRange.Select
End Sub


Private Sub ApplyFormattingToRange2(ByRef thisDocument As Document, ByVal thisFormattingCode As String, ByRef thisRange As TextRange2)
    Dim Range1 As Range
    Dim Range2 As Range
    Dim valueParts() As String
    Dim selectedText As String
    Dim tableObject As Object
    selectedText = thisRange.Text
    
    Select Case thisFormattingCode
        Case "{{Bold}}"
           thisRange.Font.Bold = True
        Case "{{DateLong}}"
            selectedText = Replace(selectedText, "{{DefaultLongDate}}", "")
            selectedText = Replace(selectedText, "{{DefaultShortDate}}", "")
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Left(selectedText, InStr(1, selectedText, "~~~~") - 1)
            End If
            thisRange.Text = selectedText
        Case "{{DateShort}}"
            selectedText = Replace(selectedText, "{{DefaultLongDate}}", "")
            selectedText = Replace(selectedText, "{{DefaultShortDate}}", "")
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Mid(selectedText, InStr(selectedText, "~~~~") + 4)
            End If
            thisRange.Text = selectedText
        Case "{{Currency}}"
'            If IsNumeric(thisRange.Text) Then
'                thisRange.Text = FormatCurrency(selectedText)
'            End If
        Case "{{Number}}"
'            If IsNumeric(thisRange.Text) Then
'                thisRange.Text = FormatNumber(selectedText)
'            End If
        Case "{{DefaultShortDate}}"
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Mid(selectedText, InStr(selectedText, "~~~~") + 4)
            End If
            thisRange.Text = selectedText
        Case "{{DefaultLongDate}}"
            selectedText = Replace(selectedText, "{{DefaultShortDate}}", "")
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Left(selectedText, InStr(1, selectedText, "~~~~") - 1)
            End If
            thisRange.Text = selectedText
        Case "{{DeleteParagraphIfEmpty}}"
        'expand capability not available for range2
'            If thisRange.Start = thisRange.End Then
'                thisRange.Expand wdParagraph
'                thisRange.Delete
'            End If
        Case "{{Symbol}}"
            thisRange.Delete
            thisRange.InsertSymbol CharNumber:=CInt(selectedText), fontName:="Symbol", Unicode:=False
        Case "{{InsertAutoText}}"
            On Error Resume Next
            Dim NewTempDoc As Document
            If sPrintingTemplateExt = "dot" Then
                Set NewTempDoc = Documents.Add(sPrintingTemplate)
                NewTempDoc.Activate
                NewTempDoc.Range.Select
                NewTempDoc.AttachedTemplate.AutoTextEntries(selectedText).Insert Where:=Selection.Range, RichText:=True
                If Err.Number = 0 Then
                    NewTempDoc.Range.Select
                    Selection.MoveLeft wdCharacter, 1, wdExtend
                    Selection.Copy
                    thisDocument.Activate
                    thisRange.Paste
                ElseIf Err.Number = 5941 Then
                    MsgBox "The AutoText entry for """ & selectedText & """ is not valid."
                End If
                NewTempDoc.Saved = True
                NewTempDoc.Close wdDoNotSaveChanges
            End If
            If sPrintingTemplateExt = "dotx" Then
                Set NewTempDoc = Documents.Add(sPrintingTemplate)
                NewTempDoc.Activate
                NewTempDoc.Range.Select
                NewTempDoc.AttachedTemplate.BuildingBlockEntries(selectedText).Insert Where:=Selection.Range, RichText:=True
                If Err.Number = 0 Then
                    NewTempDoc.Range.Select
                    Selection.MoveLeft wdCharacter, 1, wdExtend
                    Selection.Copy
                    thisDocument.Activate
                    thisRange.Paste
                ElseIf Err.Number = 5941 Then
                    MsgBox "The AutoText entry for """ & selectedText & """ is not valid."
                End If
                NewTempDoc.Saved = True
                NewTempDoc.Close wdDoNotSaveChanges
            End If
            On Error GoTo 0
        Case Else

    End Select
End Sub

Private Sub ApplyFormatting(ByRef thisDocument As Document, ByVal thisFormattingCode As String, ByRef thisRange As Range)
    Dim Range1 As Range
    Dim Range2 As Range
    Dim valueParts() As String
    Dim selectedText As String
    Dim tableObject As Object
    selectedText = thisRange.Text
    
    Select Case thisFormattingCode
        Case "{{Bold}}"
           thisRange.Font.Bold = True
        Case "{{DateLong}}"
            selectedText = Replace(selectedText, "{{DefaultLongDate}}", "")
            selectedText = Replace(selectedText, "{{DefaultShortDate}}", "")
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Left(selectedText, InStr(1, selectedText, "~~~~") - 1)
            End If
            thisRange.Text = selectedText
        Case "{{DateShort}}"
            selectedText = Replace(selectedText, "{{DefaultLongDate}}", "")
            selectedText = Replace(selectedText, "{{DefaultShortDate}}", "")
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Mid(selectedText, InStr(selectedText, "~~~~") + 4)
            End If
            thisRange.Text = selectedText
        Case "{{Currency}}"
'            If IsNumeric(thisRange.Text) Then
'                thisRange.Text = FormatCurrency(selectedText)
'            End If
        Case "{{Number}}"
'            If IsNumeric(thisRange.Text) Then
'                thisRange.Text = FormatNumber(selectedText)
'            End If
        Case "{{DefaultShortDate}}"
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Mid(selectedText, InStr(selectedText, "~~~~") + 4)
            End If
            thisRange.Text = selectedText
        Case "{{DefaultLongDate}}"
            selectedText = Replace(selectedText, "{{DefaultShortDate}}", "")
            If InStr(1, selectedText, "~~~~") > 0 Then
                selectedText = Left(selectedText, InStr(1, selectedText, "~~~~") - 1)
            End If
            thisRange.Text = selectedText
        Case "{{DeleteParagraphIfEmpty}}"
            If thisRange.Start = thisRange.End Then
                thisRange.Expand wdParagraph
                thisRange.Delete
            End If
        Case "{{TextToTable}}"
            Application.DefaultTableSeparator = Chr(172)
            thisRange.ConvertToTable Separator:=wdSeparateByDefaultListSeparator, format:=wdTableFormatNone
        Case "{{MergeCells}}"
            If thisRange.Information(wdWithInTable) Then
                thisRange.Cells.Merge
            End If
        Case "{{TableAutoFormat}}"
            If thisRange.Information(wdWithInTable) Then
                thisRange.Delete
                thisRange.Tables(1).AutoFormat CInt(selectedText), 1, 1, 0, 1, 1, 0, 0, 0, 0
            End If
        Case "{{TableAutoFormatDoubleHeader}}"
            thisRange.Select
            If thisDocument.ActiveWindow.Selection.Information(wdWithInTable) Then
                thisDocument.ActiveWindow.Selection.Delete
                thisDocument.ActiveWindow.Selection.Tables(1).AutoFormat CInt(selectedText), 1, 1, 0, 1, 1, 0, 0, 0, 0
                Set Range1 = thisDocument.ActiveWindow.Selection.Range
                thisDocument.ActiveWindow.Selection.SplitTable
                Set Range2 = thisDocument.ActiveWindow.Selection.Range
                Range1.Select
                thisDocument.ActiveWindow.Selection.Tables(1).AutoFormat CInt(selectedText), 1, 1, 0, 1, 1, 0, 0, 0, 0
                Range2.Select
                thisDocument.ActiveWindow.Selection.Delete
            End If
        Case "{{Symbol}}"
            thisRange.Delete
            thisRange.InsertSymbol CharacterNumber:=CInt(selectedText), Font:="Symbol", Unicode:=False
        Case "{{AddBookmark}}"
            thisRange.Delete
            thisRange.Bookmarks.Add selectedText
        Case "{{LinkToBookmark}}"
            thisRange.Delete
            On Error Resume Next
            'Ignore errors on this line (bookmark will not be there for Excel or when building separately).
            thisRange.InsertCrossReference ReferenceType:="Bookmark", ReferenceKind:= _
                wdPageNumber, ReferenceItem:=selectedText, _
                InsertAsHyperlink:=True, IncludePosition:=False
            On Error GoTo 0
        Case "{{Center}}"
            thisRange.ParagraphFormat.Alignment = wdAlignParagraphCenter
        Case "{{AutoFitContents}}"
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).AutoFitBehavior (wdAutoFitContent)
            End If
        Case "{{InsertAutoText}}"
            On Error Resume Next
            Dim NewTempDoc As Document
            If sPrintingTemplateExt = "dot" Then
                Set NewTempDoc = Documents.Add(sPrintingTemplate)
                NewTempDoc.Activate
                NewTempDoc.Range.Select
                NewTempDoc.AttachedTemplate.AutoTextEntries(selectedText).Insert Where:=Selection.Range, RichText:=True
                If Err.Number = 0 Then
                    NewTempDoc.Range.Select
                    Selection.MoveLeft wdCharacter, 1, wdExtend
                    Selection.Copy
                    thisDocument.Activate
                    thisRange.Paste
                ElseIf Err.Number = 5941 Then
                    MsgBox "The AutoText entry for """ & selectedText & """ is not valid."
                End If
                NewTempDoc.Saved = True
                NewTempDoc.Close wdDoNotSaveChanges
            End If
            If sPrintingTemplateExt = "dotx" Then
                Set NewTempDoc = Documents.Add(sPrintingTemplate)
                NewTempDoc.Activate
                NewTempDoc.Range.Select
                NewTempDoc.AttachedTemplate.BuildingBlockEntries(selectedText).Insert Where:=Selection.Range, RichText:=True
                If Err.Number = 0 Then
                    NewTempDoc.Range.Select
                    Selection.MoveLeft wdCharacter, 1, wdExtend
                    Selection.Copy
                    thisDocument.Activate
                    thisRange.Paste
                ElseIf Err.Number = 5941 Then
                    MsgBox "The AutoText entry for """ & selectedText & """ is not valid."
                End If
                NewTempDoc.Saved = True
                NewTempDoc.Close wdDoNotSaveChanges
            End If
            On Error GoTo 0
        Case "{{LinkToPrevious}}"
            If thisRange.Information(wdInHeaderFooter) Then
                'TODO WE NEED TO FIX THIS!!!! thisRange.HeaderFooter.LinkToPrevious = True
                If thisRange.Sections.count > 0 Then
                    If thisRange.Sections(1).Headers.count > 0 Then
                        thisRange.Sections(1).Headers(1).LinkToPrevious = True
                    End If
                    If thisRange.Sections(1).Footers.count > 0 Then
                        thisRange.Sections(1).Footers(1).LinkToPrevious = True
                    End If
                End If
            End If
        Case "{{ApplyWatermarkFromFile}}"
            thisDocument.Background.Fill.visible = msoTrue
            thisDocument.Background.Fill.UserPicture selectedText
        Case "{{ApplyStyleToRow}}"
            'Ignore error if style no longer exists.
            On Error Resume Next
            Set Range2 = thisRange.Duplicate
            thisRange.Expand wdRow
            thisRange.Style = selectedText
            Range2.Delete
            
        'NEW CODES
        Case "{{TableStyle}}"
            'Not avialable in Office 2000
            If getVersion >= 10 Then
                If thisRange.Information(wdWithInTable) Then
                    thisRange.Delete
                    
                    Set tableObject = thisRange.Tables(1)
                    
                    On Error Resume Next
                    tableObject.Style = selectedText
                    If Err.Number <> 0 Then
                        'TODO Add resource string for the parts of this message.
                        MsgBox "The table style '" & selectedText & "' does not exist in the selected style template."
                    End If
                    tableObject.ApplyStyleHeadingRows = True
                    tableObject.ApplyStyleLastRow = True
                    tableObject.ApplyStyleFirstColumn = True
                    tableObject.ApplyStyleLastColumn = True
                End If
            Else
                'TODO Add resource string for the parts of this message.
                MsgBox "The {{TableStyle}} formatting code is not available in Office 2000."
            End If
        Case "{{TableStyleAdvanced}}"
            'Not avialable in Office 2000
            If getVersion >= 10 Then
                If thisRange.Information(wdWithInTable) Then
                    thisRange.Delete
                    
                    valueParts = Split(selectedText, "|")
                    
                    Set tableObject = thisRange.Tables(1)
                    On Error Resume Next
                    tableObject.Style = valueParts(0)
                    If Err.Number <> 0 Then
                        'TODO Add resource string for the parts of this message.
                        MsgBox "The table style '" & valueParts(0) & "' does not exist in the selected style template."
                    End If
                    tableObject.ApplyStyleHeadingRows = CBool(valueParts(1))
                    tableObject.ApplyStyleLastRow = CBool(valueParts(2))
                    tableObject.ApplyStyleFirstColumn = CBool(valueParts(3))
                    tableObject.ApplyStyleLastColumn = CBool(valueParts(4))
                End If
            Else
                'TODO Add resource string for the parts of this message.
                MsgBox "The {{TableStyle}} formatting code is not available in Office 2000."
            End If
        Case "{{Right}}"
            thisRange.ParagraphFormat.Alignment = wdAlignParagraphRight
        Case "{{Left}}"
            thisRange.ParagraphFormat.Alignment = wdAlignParagraphLeft
        Case "{{TableWidthInches}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).PreferredWidthType = wdPreferredWidthPoints
                thisRange.Tables(1).PreferredWidth = InchesToPoints(ConvertDoubleNumberLocale(selectedText))
            End If
        Case "{{TableWidthCentimeters}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).PreferredWidthType = wdPreferredWidthPoints
                thisRange.Tables(1).PreferredWidth = CentimetersToPoints(ConvertDoubleNumberLocale(selectedText))
            End If
        Case "{{TableWidthPoints}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).PreferredWidthType = wdPreferredWidthPoints
                thisRange.Tables(1).PreferredWidth = selectedText
            End If
        Case "{{ColumnWidthInches}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Columns.PreferredWidthType = wdPreferredWidthPoints
                thisRange.Columns.PreferredWidth = InchesToPoints(ConvertDoubleNumberLocale(selectedText))
            End If
        Case "{{ColumnWidthCentimeters}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Columns.PreferredWidthType = wdPreferredWidthPoints
                thisRange.Columns.PreferredWidth = CentimetersToPoints(ConvertDoubleNumberLocale(selectedText))
            End If
        Case "{{ColumnWidthPoints}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Columns.PreferredWidthType = wdPreferredWidthPoints
                thisRange.Columns.PreferredWidth = selectedText
            End If
        Case "{{ColumnWidthPercent}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Columns.PreferredWidthType = wdPreferredWidthPercent
                thisRange.Columns.PreferredWidth = selectedText
            End If
        Case "{{LeftIndentInches}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).Rows.LeftIndent = InchesToPoints(ConvertDoubleNumberLocale(selectedText))
            End If
        Case "{{LeftIndentCentimeters}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).Rows.LeftIndent = CentimetersToPoints(ConvertDoubleNumberLocale(selectedText))
            End If
        Case "{{LeftIndentPoints}}"
            thisRange.Delete
            If thisRange.Information(wdWithInTable) Then
                thisRange.Tables(1).Rows.LeftIndent = selectedText
            End If
        Case "{{ApplyStyleToParagraph}}"
            thisRange.Delete
            On Error Resume Next
            thisRange.Paragraphs.Style = selectedText
            If Err.Number <> 0 Then
                'TODO Add resource string for the parts of this message.
                MsgBox "The style '" & selectedText & "' does not exist in the selected style template."
            End If
        Case Else

    End Select
End Sub

Public Function ConvertDoubleNumberLocale(ByVal strNumber As String) As Double
    ConvertDoubleNumberLocale = 0
    
    Dim commaOffset As Integer
    Dim periodOffset As Integer
    commaOffset = InStr(1, strNumber, ",")
    periodOffset = InStr(1, strNumber, ".")
    
    If periodOffset > 0 Or commaOffset > 0 Then
        If periodOffset > commaOffset Then
            strNumber = Replace(strNumber, ",", "")
        Else
            strNumber = Replace(strNumber, ".", " ")
            strNumber = Replace(strNumber, ",", ".")
        End If
    End If
    
    ConvertDoubleNumberLocale = CDbl(val(strNumber))
End Function

Public Sub ProcessFormatListForExcel(ByRef thisWorkbook As Object)
        'Moved these compliance matrix related codes to before the rest of the formatting codes,
        'because the table autoformat must occur before setting text to bold.
        RemoveCode thisWorkbook, "{{TextToTable}}"
        RemoveCode thisWorkbook, "{{MergeCells}}"
        RemoveCode thisWorkbook, "{{TableAutoFormat}}"
        RemoveCode thisWorkbook, "{{TableAutoFormatDoubleHeader}}"
        RemoveCode thisWorkbook, "{{Symbol}}"
        RemoveCode thisWorkbook, "{{AddBookmark}}"
        RemoveCode thisWorkbook, "{{LinkToBookmark}}"
        RemoveCode thisWorkbook, "{{Center}}"
        RemoveCode thisWorkbook, "{{AutoFitContents}}"
        
        'New formatting codes.
        RemoveCode thisWorkbook, "{{InsertAutoText}}"
        RemoveCode thisWorkbook, "{{LinkToPrevious}}"
        RemoveCode thisWorkbook, "{{ApplyWatermarkFromFile}}"
        
        'Traditional formatting codes.
        RemoveCode thisWorkbook, "{{Bold}}"
        
'2007/04/02 [jsb]: Removing most "traditional" formatting codes for bug 2213.
'        RemoveCode thisWorkbook, "{{Italic}}"
'        RemoveCode thisWorkbook, "{{ULine}}"
'        RemoveCode thisWorkbook, "{{Strike}}"
'        RemoveCode thisWorkbook, "{{Sub}}"
'        RemoveCode thisWorkbook, "{{Sup}}"
'        RemoveCode thisWorkbook, "{{Cap}}"
'        RemoveCode thisWorkbook, "{{SmCap}}"
'        RemoveCode thisWorkbook, "{{Shadow}}"
'        RemoveCode thisWorkbook, "{{Hidden}}"
'        RemoveCode thisWorkbook, "{{Black}}"
'        RemoveCode thisWorkbook, "{{Blue}}"
'        RemoveCode thisWorkbook, "{{BrightGreen}}"
'        RemoveCode thisWorkbook, "{{DarkBlue}}"
'        RemoveCode thisWorkbook, "{{DarkRed}}"
'        RemoveCode thisWorkbook, "{{DarkYellow}}"
'        RemoveCode thisWorkbook, "{{Gray25}}"
'        RemoveCode thisWorkbook, "{{Gray50}}"
'        RemoveCode thisWorkbook, "{{Green}}"
'        RemoveCode thisWorkbook, "{{NoHighlight}}"
'        RemoveCode thisWorkbook, "{{Pink}}"
'        RemoveCode thisWorkbook, "{{Red}}"
'        RemoveCode thisWorkbook, "{{Teal}}"
'        RemoveCode thisWorkbook, "{{Turquoise}}"
'        RemoveCode thisWorkbook, "{{Violet}}"
'        RemoveCode thisWorkbook, "{{White}}"
'        RemoveCode thisWorkbook, "{{Yellow}}"
        
        
        'These formatting codes may change based on the
        'regional setting that can now be applied to projects.
        FormatInExcel thisWorkbook, "{{DateLong}}"
        FormatInExcel thisWorkbook, "{{DateShort}}"
        RemoveCode thisWorkbook, "{{Currency}}"
        RemoveCode thisWorkbook, "{{Number}}"
        FormatInExcel thisWorkbook, "{{DefaultLongDate}}"
        FormatInExcel thisWorkbook, "{{DefaultShortDate}}"
        
        'This formatting code should be the last one, so that any
        'formatting codes that were within this marker have already been replaced.
        RemoveCode thisWorkbook, "{{DeleteParagraphIfEmpty}}"
End Sub

Sub FormatInExcel(ByRef thisWorkbook As Object, ByVal textToFind As String)
    Dim FoundRange As Object
    Dim selectedText As String
    Dim replacementText As String
    Dim selStart As Long
    Dim selEnd As Long
    Dim oSheet As Object
    
    'Loop through the sheets in thisWorkbook
    For Each oSheet In thisWorkbook.Worksheets
        'Find the next cell that contains the textToFind
        Set FoundRange = oSheet.Cells.Find(textToFind, , -4163, 2, 1, 1, False, False)
        
        'Keep applying the formatting code as long as we keep finding cells that contain it.
        While TypeName(FoundRange) <> "Nothing"
        
            'Find the first location of the textToFind
            selStart = InStr(1, FoundRange.Text, textToFind)
            
            'If we've found the textToFind, proceed (should always find it)
            If selStart > 0 Then
                'Reset the starting location to the end of the textToFind
                '   (will now point to the start of the text between the markers)
                selStart = selStart + Len(textToFind)
                
                'Find the location of the nextTextToFind in the same cell.
                selEnd = InStr(selStart, FoundRange.Text, textToFind)
                
                'If we found another marker, apply the formatting code to the text within it.
                If selEnd > 0 Then
                    'Get the text between the markers.
                    selectedText = Mid(FoundRange.Text, selStart, selEnd - selStart)
                    
                    'Handle the specific formatting code.
                    Select Case textToFind
                        Case "{{DateLong}}"
                            replacementText = Left(selectedText, InStr(1, selectedText, "~~~~") - 1)
                            replacementText = Replace(replacementText, "{{DefaultLongDate}}", "")
                            replacementText = Replace(replacementText, "{{DefaultShortDate}}", "")
                        Case "{{DateShort}}"
                            replacementText = Mid(selectedText, InStr(selectedText, "~~~~") + 4)
                            replacementText = Replace(replacementText, "{{DefaultLongDate}}", "")
                            replacementText = Replace(replacementText, "{{DefaultShortDate}}", "")
                        Case "{{DefaultLongDate}}"
                            replacementText = Left(selectedText, InStr(1, selectedText, "~~~~") - 1)
                        Case "{{DefaultShortDate}}"
                            replacementText = Mid(selectedText, InStr(selectedText, "~~~~") + 4)
                    End Select
                    
                    'Replace ALL instances of this same text with the new replacement value.
                    '   So, if the same code and contained text exists multiple times, they'll all be replaced at once.
                    FoundRange.Value = Replace(FoundRange.Text, textToFind & selectedText & textToFind, replacementText)
                Else
                    'If there was only once instance of the formatting code in this cell, just remove it.
                    FoundRange.Value = Replace(FoundRange.Text, textToFind, "", 1, 1)
                End If
            End If
        
            'Find the next cell that contains the textToFind
            Set FoundRange = oSheet.Cells.FindNext
        Wend
    Next oSheet
End Sub

Private Sub RemoveCode(ByRef thisWorkbook As Object, ByVal thisText As String)
    Dim i As Integer
    Dim oSheet As Object
    
    For Each oSheet In thisWorkbook.Worksheets
        'Note: The replace routine has a MatchByte parameter that is documented as follows:
        '   "You can use this argument only if you|fffd|ve selected or installed double-byte language support in Microsoft Excel"
        '   I'm not sure if that means it isn't available, or if it isn't functional without double-byte language support.
        '   So, if we have problems, we'll try it with the extra parameter, and if we get an error we'll try without.
        '   If we have to fix this problem, please also check modEditReplaces for its use of the replace routine.
        If TypeName(oSheet.Cells.Find(thisText, , -4163, 2, 1, 1, False, False)) <> "Nothing" Then
            oSheet.Cells.Replace thisText, "", 2, 1, False, False, False, False
        End If
    Next oSheet
End Sub




'GENERAL ER TOOLS
Public Sub InitializeHeaderFooter(ByRef thisHeaderFooter As Object)
    '2009-02-12 [JSB]: Changed the following line to include "Not".
    '   The intent of this routine is to create the header/footer if it doesn't already exist.
    '   So, we only want to initialize it if it DOESN'T already exist.
    If Not thisHeaderFooter.Exists Then
        thisHeaderFooter.Range.Text = " "
    End If
End Sub

Public Sub DoGalleryEditReplaces()
    Const CODE_START = "<<GALLERY: "
    Dim sFullCode As String
    Dim sGUID As String
    Dim FindRange As Range
    Dim sContentFile As String
    Dim contentID As String
    Dim nRevision As Integer
    Set FindRange = buildDocument.StoryRanges(1)
    
    'find each occurrence of the "<<GALLERY:" openening tag
    Do While InStr(1, FindRange.Text, CODE_START) > 0
    
        'retrieve the GUID
        'find the remaining tag
        sFullCode = GetFullGalleryCode(FindRange.Text, sGUID)
                
        'get local file name (including content ID and revision)
        sContentFile = dh.GetContentFileByGUID(sGUID)
        DebugMsgBox ("DoGalleryEditReplaces: sContentFile [" & sContentFile & "]")
        
        ' We need to split out the content file and revision
        Dim extIdx As Integer
        extIdx = InStr(1, sContentFile, "|")
        DebugMsgBox ("DoGalleryEditReplaces: extIdx [" & extIdx & "]")
        If extIdx > 0 Then
            contentID = Left(sContentFile, extIdx - 1)
            nRevision = CInt(Mid(sContentFile, extIdx + 1))
        Else
            contentID = sContentFile
            nRevision = -1
        End If
        DebugMsgBox ("DoGalleryEditReplaces: contentID [" & contentID & "] and nRevision [" & nRevision & "]")
        
        'download file
        'replace tag with content
        Action_EditReplace_Graphic sFullCode, dlContent(contentID, nRevision, True)
    
        Set FindRange = buildDocument.StoryRanges(1)
    Loop
    
End Sub

Private Function GetFullGalleryCode(ByVal sText As String, ByRef GUID As String) As String
    Dim sERCode As String
    Dim sRestOfTag As String
    Dim lFoundPos As Long
    
    lFoundPos = InStr(1, sText, "<<GALLERY: ")

    If lFoundPos > 0 Then

        sText = Right(sText, Len(sText) - lFoundPos - 10) 'trim off up to found portion

        lFoundPos = InStr(1, sText, " -")

        GUID = Left(sText, lFoundPos - 1)

        sText = Right(sText, Len(sText) - lFoundPos - 1)

        lFoundPos = InStr(1, sText, ">>")

        sRestOfTag = Left(sText, lFoundPos - 1)

        sText = Right(sText, Len(sText) - lFoundPos - 1)

        sERCode = "<<GALLERY: " & GUID & " -" & sRestOfTag & ">>"
    End If

    GetFullGalleryCode = sERCode

End Function








Attribute VB_Name = "modCleanEditReplaces"

Public Sub CleanAllStories(ByRef thisDocument As Document)
    Dim missingStrings As New Collection
    CleanStories2000AndUp thisDocument, missingStrings
    
    'Handle stories available in Office 2003 and up.
    If getVersion >= 11 Then
        CleanStories2003AndUp thisDocument, missingStrings
    End If
   
    ActiveDocument.ActiveWindow.ActivePane.View.SeekView = wdSeekMainDocument
   
    If missingStrings.count > 0 Then
        sMissingEditReplaces = ""
        For Each missingValue In missingStrings
            sMissingEditReplaces = sMissingEditReplaces & missingValue & vbCrLf
        Next
        Application.Activate
        frmEditReplace.Show
    End If
End Sub

Public Sub CleanStories2000AndUp(ByRef thisDocument As Document, ByRef missingStrings As Collection)

    'Dim replaceStr As String
    'replaceStr = GetTemplateString("Build_modEditReplaces_Replacing")
    'Using numbers so this will compile in older versions that don't have the constants.
    'StatusBar = replaceStr & " wdMainTextStory"
    CleanThisStory thisDocument, 1, False, missingStrings 'wdMainTextStory
    'StatusBar = replaceStr & " wdPrimaryHeaderStory"
    CleanThisStory thisDocument, 7, True, missingStrings 'wdPrimaryHeaderStory
    'StatusBar = replaceStr & " wdPrimaryFooterStory"
    CleanThisStory thisDocument, 9, True, missingStrings 'wdPrimaryFooterStory
    'StatusBar = replaceStr & " wdFirstPageHeaderStory"
    CleanThisStory thisDocument, 10, True, missingStrings 'wdFirstPageHeaderStory
    'StatusBar = replaceStr & " wdFirstPageFooterStory"
    CleanThisStory thisDocument, 11, True, missingStrings 'wdFirstPageFooterStory
    'StatusBar = replaceStr & " wdEvenPagesHeaderStory"
    CleanThisStory thisDocument, 6, True, missingStrings 'wdEvenPagesHeaderStory
    'StatusBar = replaceStr & " wdEvenPagesFooterStory"
    CleanThisStory thisDocument, 8, True, missingStrings 'wdEvenPagesFooterStory
    'StatusBar = replaceStr & " wdTextFrameStory"
    CleanThisStory thisDocument, 5, False, missingStrings 'wdTextFrameStory
    'StatusBar = replaceStr & " wdCommentsStory"
    CleanThisStory thisDocument, 4, False, missingStrings 'wdCommentsStory
    'StatusBar = replaceStr & " wdEndnotesStory"
    CleanThisStory thisDocument, 3, False, missingStrings 'wdEndnotesStory
    'StatusBar = replaceStr & " wdFootnotesStory"
    CleanThisStory thisDocument, l, False, missingStrings 'wdFootnotesStory
End Sub

Public Sub CleanStories2003AndUp(ByRef thisDocument As Document, ByRef missingStrings As Collection)
    
    'Dim replaceStr As String
    'replaceStr = GetTemplateString("Build_modEditReplaces_Replacing")
    
    'Using numbers so this will compile in older versions that don't have the constants.
    'StatusBar = replaceStr & " wdEndnoteContinuationNoticeStory"
    CleanThisStory thisDocument, 17, False, missingStrings 'wdEndnoteContinuationNoticeStory
    'StatusBar = replaceStr & " wdEndnoteContinuationSeparatorStory"
    CleanThisStory thisDocument, 16, False, missingStrings 'wdEndnoteContinuationSeparatorStory
    'StatusBar = replaceStr & " wdEndnoteSeparatorStory"
    CleanThisStory thisDocument, 15, False, missingStrings 'wdEndnoteSeparatorStory
    'StatusBar = replaceStr & " wdFootnoteContinuationNoticeStory"
    CleanThisStory thisDocument, 14, False, missingStrings 'wdFootnoteContinuationNoticeStory
    'StatusBar = replaceStr & " wdFootnoteContinuationSeparatorStory"
    CleanThisStory thisDocument, 13, False, missingStrings 'wdFootnoteContinuationSeparatorStory
    'StatusBar = replaceStr & " wdFootnoteSeparatorStory"
    CleanThisStory thisDocument, 12, False, missingStrings 'wdFootnoteSeparatorStory
End Sub

Private Sub CleanThisStory(ByRef thisDocument As Document, ByVal thisStory As WdStoryType, ByVal isHeaderFooter As Boolean, ByRef missingStrings As Collection)
    Dim MyFindText As String
    Dim MyReplaceText As String
    Dim myStoryRange As Range
    Dim i As Integer
    Dim tempText As String
    Dim oShp As Shape
    
    If Not StoryExists(thisDocument, thisStory) And isHeaderFooter Then
        Select Case thisStory
            Case WdStoryType.wdEvenPagesFooterStory
                tempText = thisDocument.Sections.first.Footers(wdHeaderFooterEvenPages).Range.Text
            Case WdStoryType.wdEvenPagesHeaderStory
                tempText = thisDocument.Sections.first.Headers(wdHeaderFooterEvenPages).Range.Text
            Case WdStoryType.wdFirstPageFooterStory
                tempText = thisDocument.Sections.first.Footers(wdHeaderFooterFirstPage).Range.Text
            Case WdStoryType.wdFirstPageHeaderStory
                tempText = thisDocument.Sections.first.Headers(wdHeaderFooterFirstPage).Range.Text
            Case WdStoryType.wdPrimaryFooterStory
                tempText = thisDocument.Sections.first.Footers(wdHeaderFooterPrimary).Range.Text
            Case WdStoryType.wdPrimaryHeaderStory
                tempText = thisDocument.Sections.first.Headers(wdHeaderFooterPrimary).Range.Text
        End Select
    End If

    If StoryExists(thisDocument, thisStory) Then
        Set myStoryRange = thisDocument.StoryRanges(thisStory)
        CleanEditReplaces myStoryRange, thisDocument, missingStrings
        CleanShapes thisDocument, myStoryRange, missingStrings
        Do While Not (myStoryRange.NextStoryRange Is Nothing)
            Set myStoryRange = myStoryRange.NextStoryRange
            CleanEditReplaces myStoryRange, thisDocument, missingStrings
        CleanShapes thisDocument, myStoryRange, missingStrings
        Loop

    End If
End Sub



Private Sub CleanShapes(ByRef thisDocument As Document, ByVal thisStoryRange As Range, ByRef missingStrings As Collection)
    Dim oShp As Shape
        On Error Resume Next
        If thisStoryRange.ShapeRange.count > 0 Then
          For Each oShp In thisStoryRange.ShapeRange
            On Error Resume Next
            If oShp.TextFrame2.HasText Then
              CleanEditReplaces oShp.TextFrame2.TextRange, thisDocument, missingStrings
            End If
            If oShp.TextFrame.HasText Then
              CleanEditReplaces oShp.TextFrame.TextRange, thisDocument, missingStrings
            End If
          Next
        End If
        On Error GoTo 0
End Sub

Private Sub CleanEditReplaces(ByVal thisRange As Range, ByRef thisDocument As Document, ByRef missingStrings As Collection)
    Dim tempRange As Range

    Dim bContinue As Boolean
    bContinue = True

    While bContinue
        Set tempRange = thisRange.Duplicate
        
        tempRange.Find.ClearFormatting
        With tempRange.Find
           .Text = "\<\<*\>\>"
           .Forward = True
           .Wrap = wdFindContinue
           .format = True
           .MatchCase = False
           .MatchWholeWord = False
           .MatchWildcards = True
           .MatchSoundsLike = False
           .MatchAllWordForms = False
           .Execute
        End With
        
        If tempRange.Find.Found Then
            AddToCollection missingStrings, tempRange.Text
            tempRange.Delete
        Else
            bContinue = False
        End If
        
        thisDocument.UndoClear
        
    Wend
End Sub


Attribute VB_Name = "modCompare"
Option Explicit

Private dh As clsDownloadHelper

Public Sub InitCompare(ByRef thisDoc As Document)
    Dim oldState As Integer
    'SwitchToPrintLayout ActiveWindow
    
    oldState = thisDoc.ActiveWindow.WindowState
    'thisDoc.ActiveWindow.WindowState = wdWindowStateMinimize
    
    thisDoc.AttachedTemplate.Saved = True
    Application.NormalTemplate.Saved = True
    
    DoCompare CLng(GetPropertyText("SantCompareContentID2", thisDoc)), CLng(GetPropertyText("SantCompareRevision2", thisDoc)), GetPropertyText("SantCompareRev2Ext", thisDoc)

    thisDoc.ActiveWindow.visible = True
    thisDoc.ActiveWindow.WindowState = wdWindowStateNormal
    thisDoc.ActiveWindow.WindowState = oldState
    thisDoc.ActiveWindow.Activate
End Sub

Public Sub InitRFPCompare(ByRef thisDoc As Document)
    Dim oldState As Integer

    'SwitchToPrintLayout ActiveWindow
    oldState = thisDoc.ActiveWindow.WindowState
    'thisDoc.ActiveWindow.WindowState = wdWindowStateMinimize
            
    'Mark the attached template as saved, so we don't get propmted to save.
    thisDoc.AttachedTemplate.Saved = True
    Application.NormalTemplate.Saved = True
    
    ' NEW DoRFPCompareNew() being called!
    DoRFPCompareNew CLng(GetPropertyText("SantCompareContentID", thisDoc)), GetPropertyText("SantCompareExt", thisDoc)
    
    'modTools.SaveToSantTemp thisDoc
    'thisDoc.Save
    
    thisDoc.ActiveWindow.visible = True
    thisDoc.ActiveWindow.WindowState = wdWindowStateNormal
    thisDoc.ActiveWindow.WindowState = oldState
    thisDoc.ActiveWindow.Activate
End Sub

'Public Sub DoRFPCompare(ByVal contentID As Long, ByVal ContentExt As String)
'    Dim thisDoc As Document 'Current Word doc opened for the initial template code.
'    Dim sEditFilePath As String 'Local path to the file we're editing.
'    Dim tempDoc As Document
'    Dim tempBookmark As Bookmark
'    Dim fso As Object
'    Dim thisExt As String
'
'    Set fso = CreateObject("Scripting.FileSystemObject")
'
'    Set thisDoc = Application.ActiveDocument
'
'    thisExt = Right(thisDoc.FullName, Len(thisDoc.FullName) - InStrRev(thisDoc.FullName, "."))
'
'    sEditFilePath = GetClientPath & "temp\MergeTemp." & ContentExt
'    modTools.EnsureTempFolderExists
'    If fso.FileExists(sEditFilePath) Then
'        fso.DeleteFile sEditFilePath
'    End If
'    ' This is needed because DownloadContentFile will update the
'    ' temporary file name to DOCX is it's a DOC file.
'    If ContentExt = "doc" Then
'        If fso.FileExists(sEditFilePath & "x") Then
'            fso.DeleteFile sEditFilePath & "x"
'        End If
'    End If
'
'    OpenDH
'
'    If Not dh.DownloadContentFile(sEditFilePath, contentID) Then
'        'TODO: Change message to be more specific to this case.
'        MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
'        Exit Sub
'    End If
'
'    CloseDH
'
'    Dim copyFile As String
'    copyFile = GetClientPath & "temp\CurrentAnswer." & thisExt
'    If fso.FileExists(copyFile) Then
'        fso.DeleteFile copyFile
'    End If
'    fso.copyFile thisDoc.FullName, copyFile                 'copy of project QA
'
'    Set tempDoc = Application.Documents.Open(sEditFilePath) 'open corp QA
'    tempDoc.Activate
'
'    tempDoc.Select
'
'    Selection.Copy
'
'    tempDoc.Close
'
'    thisDoc.Activate
'    For Each tempBookmark In thisDoc.Bookmarks
'        If InStr(1, tempBookmark.name, "SantAnswer") > 0 Then
'            Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
'            If Len(Selection.text) > 1 Then
'                Selection.Collapse wdCollapseStart
'                Selection.MoveDown wdParagraph, 2
'                SelectToEnd thisDoc
'            Else
'                Selection.MoveStartWhile Chr(13) & Chr(12)
'                SelectToEnd thisDoc
'                Selection.MoveEndWhile Chr(13) & Chr(12), wdBackward
'                Selection.MoveDown wdParagraph, 1, wdExtend
'            End If
'            Exit For
'        End If
'    Next tempBookmark
'
'    Selection.MoveStartWhile Chr(13) & Chr(12)
'    Selection.MoveEndWhile Chr(13) & Chr(12), wdBackward
'    Selection.MoveRight wdCharacter, 1, wdExtend
'    Selection.Paste
'
'    Selection.Collapse wdCollapseStart
'
'    thisDoc.Merge copyFile, 1, True, 0, False
'
'    Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
'    Selection.Collapse wdCollapseEnd
'End Sub

Public Sub DoRFPCompareNew(ByVal contentID As Long, ByVal ContentExt As String)
    Dim thisDoc As Document 'Current Word doc opened for the initial template code.
    Dim sEditFilePath As String 'Local path to the file we're editing.
    Dim tempDoc As Document
    Dim tempBookmark As Bookmark
    Dim fso As Object
    Dim thisExt As String
    
    Set fso = CreateObject("Scripting.FileSystemObject")

    Set thisDoc = Application.ActiveDocument
    
    thisExt = Right(thisDoc.FullName, Len(thisDoc.FullName) - InStrRev(thisDoc.FullName, "."))
        
    sEditFilePath = GetClientPath & "temp\CurrentLibraryAnswer_ID" & CStr(contentID) & "." & ContentExt
    modTools.EnsureTempFolderExists
    If fso.FileExists(sEditFilePath) Then
        fso.DeleteFile sEditFilePath
    End If
    ' This is needed because DownloadContentFile will update the
    ' temporary file name to DOCX is it's a DOC file.
    If ContentExt = "doc" Then
        If fso.FileExists(sEditFilePath & "x") Then
            fso.DeleteFile sEditFilePath & "x"
        End If
    End If

    OpenDH

    If Not dh.DownloadContentFile(sEditFilePath, contentID) Then
        'TODO: Change message to be more specific to this case.
        MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
        Exit Sub
    End If
    
    CloseDH
    
    ' Open library content and select/copy answer
    Set tempDoc = Application.Documents.Open(sEditFilePath) 'open corp QA
    tempDoc.Activate
    tempDoc.Select
    Selection.Copy
    tempDoc.Saved = True
    tempDoc.Close
    
    ' Copy project QA into working copy
    Dim copyFile As String
    copyFile = GetClientPath & "temp\CurrentLibraryAnswer_ID" & CStr(contentID) & "." & thisExt
    If fso.FileExists(copyFile) Then
        fso.DeleteFile copyFile
    End If
    fso.copyFile thisDoc.FullName, copyFile
    
    ' Open project QA working copy and replace answer with the library content answer
    Set tempDoc = Application.Documents.Open(copyFile)
    tempDoc.Activate

    For Each tempBookmark In tempDoc.Bookmarks
        If InStr(1, tempBookmark.name, "SantAnswer") > 0 Then
            Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
            If Len(Selection.Text) > 1 Then
                Selection.Collapse wdCollapseStart
                Selection.MoveDown wdParagraph, 2
                SelectToEnd tempDoc
            Else
                Selection.MoveStartWhile Chr(13) & Chr(12)
                SelectToEnd tempDoc
                Selection.MoveEndWhile Chr(13) & Chr(12), wdBackward
                Selection.MoveDown wdParagraph, 1, wdExtend
            End If
            Exit For
        End If
    Next tempBookmark

    Selection.MoveStartWhile Chr(13) & Chr(12)
    Selection.MoveEndWhile Chr(13) & Chr(12), wdBackward
    Selection.MoveRight wdCharacter, 1, wdExtend
    Selection.Paste
    
    Selection.Collapse wdCollapseStart
    
    Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
    Selection.Collapse wdCollapseEnd
    
    tempDoc.Save
    tempDoc.Close
    
    Dim compareBuild As New clsBuild
    compareBuild.ClearClipboard
    
    ' Activate original document and compare to library content
    thisDoc.Activate
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' IMPORTANT: 2007 uses the "Compare" method while 2003 uses the "Merge" method!!!
    '
    '       thisDoc.Merge copyFile, wdMergeTargetCurrent, True, 0, False
    '
    thisDoc.Compare copyFile, , wdCompareTargetCurrent, True, False, False
    thisDoc.Saved = True
    
    Application.Activate
End Sub

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IMPORTANT: 2007 template code different than 2003 template code for DoCompare sub !!!
'
Public Sub DoCompare(ByVal contentID As Long, ByVal Revision As Long, ByVal Rev2Ext As String)
    Dim thisDoc As Document 'Current Word doc opened for the initial template code.
    Dim sEditFilePath As String 'Local path to the file we're editing.
    Dim tempDoc As Document
    Dim tempBookmark As Bookmark
    Dim fso As Object
    
    Stop
    
    Set fso = CreateObject("Scripting.FileSystemObject")

    Set thisDoc = Application.ActiveDocument
        
    sEditFilePath = GetClientPath & "temp\CurrentContent_ID" & CStr(contentID) & "_R" & CStr(Revision) & "." & Rev2Ext
    modTools.EnsureTempFolderExists
    ' Remove the file if it already exists or the donwload will use the cached file:)
    If fso.FileExists(sEditFilePath) Then
        fso.DeleteFile sEditFilePath
    End If
    ' This is needed because DownloadContentFile will update the
    ' temporary file name to DOCX is it's a DOC file.
    If Rev2Ext = "doc" Then
        If fso.FileExists(sEditFilePath & "x") Then
            fso.DeleteFile sEditFilePath & "x"
        End If
    End If

    OpenDH
    
    If Not dh.DownloadContentFile(sEditFilePath, contentID, Revision) Then
        'TODO: Change message to be more specific to this case.
        MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
        Exit Sub
    End If
    
    CloseDH
    
    thisDoc.Compare sEditFilePath, , wdCompareTargetCurrent, True, False, False
    'thisDoc.Merge sEditFilePath, 1, True, 0, False
    thisDoc.Saved = True
    
    Application.Activate
End Sub

Sub OpenDH()
    If setupWSConnection(buildDocument) <> ConnectionStatus.worked Then
        Exit Sub
    End If
    
    Set dh = New clsDownloadHelper
End Sub

Sub CloseDH()
    If TypeName(dh) <> "Nothing" Then
        dh.CloseDownloadHelper
    End If
End Sub

'Select the answer part of the document
Public Sub SelectAnswer(ByRef thisDoc As Document)
    Dim lCharCount As Long
    Dim lEnd As Long
    On Error Resume Next
    
    thisDoc.Selection.GoTo what:=wdGoToBookmark, name:="\StartOfDoc"
    If Selection.Find.Execute("Beginning of Answer", False, True, False, False, False, True, wdFindStop) Then

        While Selection.Range.Information(wdWithInTable)
            lEnd = Selection.End
            Selection.MoveDown wdParagraph, 1, wdMove
            If Asc(Selection.Text) = 12 Then
                Selection.MoveDown wdParagraph, 1, wdMove
            End If
            If lEnd = Selection.End Then
                Exit Sub
            End If
        Wend
        While (Selection.Text = vbCrLf Or Selection.Text = vbCr Or Selection.Text = vbLf)
            lCharCount = thisDoc.Characters.count
            Selection.Delete
            If lCharCount = thisDoc.Characters.count Then
                SelectToEnd thisDoc
                Exit Sub
            End If
        Wend
        SelectToEnd thisDoc
    Else
        Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    End If
End Sub

Public Sub SelectToEnd(ByRef thisDoc As Document)

    'FAILS TO SELECT HIDDEN TEXT
    'ActiveDocument.Range(Selection.Start, ActiveDocument.Characters.Count).Select
    
    'FAILS TO SELECT THE LAST PARAGRAPH MARKER
    'Dim SelStart As Long
    'SelStart = Selection.Start
    'Selection.GoTo What:=wdGoToBookmark, Name:="\EndOfDoc"
    'ActiveDocument.Range(SelStart, Selection.End).Select

    Dim lEnd As Long
    Dim lStart As Long
    
    lStart = Selection.Start
    Selection.WholeStory
    lEnd = Selection.End
    Selection.Collapse wdCollapseEnd
    thisDoc.Range(lStart, lEnd).Select
    
End Sub


Attribute VB_Name = "modDocProperties"
Public Sub CopyProperty(ByVal PropertyName As String, ByRef sourceDoc As Document, ByRef destDoc As Document)
    WriteProperty PropertyName, GetPropertyText(PropertyName, sourceDoc), destDoc
End Sub

'Public Function GetPropertyText(ByVal PropertyName As String, ByRef thisDoc As Document) As String
'    On Error Resume Next
'    GetPropertyText = Replace(Replace(thisDoc.CustomDocumentProperties(PropertyName), Chr(13), ""), Chr(7), "")
'    If Err.Number <> 0 Then
'        GetPropertyText = ""
'    End If
'End Function

Public Function GetPropertyText(ByVal PropertyName As String, ByRef thisDoc As Document) As String
    Dim sPropValue As String
    'DebugMsgBox "GetPropertyText - Entered: Name: [" & PropertyName & "]"
    On Error Resume Next
    Dim thisText As String
    'DebugMsgBox "GetPropertyText - Before CustomDocumentProperties"
    sPropValue = ""
    sPropValue = thisDoc.CustomDocumentProperties(PropertyName)
    'DebugMsgBox "GetPropertyText - After CustomDocumentProperties: Value: [" & sPropValue & "]"
    thisText = Replace(Replace(sPropValue, Chr(13), ""), Chr(7), "")
    'DebugMsgBox "GetPropertyText - After Replace: Value: [" & thisText & "]"
    'thisText = Replace(Replace(thisDoc.CustomDocumentProperties(PropertyName), Chr(13), ""), Chr(7), "")
    'DebugMsgBox "GetPropertyText - Err.Number: " & Err.Number
    If Err.Number <> 0 Then
        thisText = ""
    Else
        If Left(thisText, 10) = "MULTIPART:" Then
            thisText = GetLongPropertyText(PropertyName, thisDoc, CInt(Right(thisText, Len(thisText) - 10)))
        End If
    End If
    'DebugMsgBox "GetPropertyText - Exit: [" & thisText & "]"
    GetPropertyText = thisText
End Function

Private Function GetLongPropertyText(ByVal PropertyName As String, ByRef thisDoc As Document, ByVal thisCount As Integer) As String
    Dim thisText As String
    Dim i As Integer
    For i = 1 To thisCount
        thisText = thisText & Replace(Replace(thisDoc.CustomDocumentProperties(PropertyName & i), Chr(13), ""), Chr(7), "")
    Next i
    GetLongPropertyText = thisText
End Function

Public Function GetServerText(ByRef thisDoc As Object) As String
    On Error Resume Next
    'MsgBox thisDoc.CustomDocumentProperties("Server")
    Dim serverValue As String
    serverValue = thisDoc.CustomDocumentProperties("Server")
    If LCase(Left(serverValue, 4)) <> "http" Then
        GetServerText = UnScramble(serverValue)
    Else
        GetServerText = serverValue
    End If
    
End Function

'Object parameter allows passing in of Document or Template
Public Sub WriteProperty(ByVal thisProperty As String, ByVal thisValue As String, ByRef thisDocument As Object)
    On Error Resume Next
    thisDocument.CustomDocumentProperties(thisProperty).Delete
    
    Const PARTLEN As Integer = 255
    
    If Len(thisValue) > PARTLEN Then
        WriteLongProperty thisDocument, thisProperty, thisValue
    Else
        thisDocument.CustomDocumentProperties.Add _
            name:=thisProperty, LinkToContent:=False, Value:=thisValue, _
            Type:=msoPropertyTypeString
    End If
End Sub

Public Sub RemoveProperty(ByVal thisProperty As String, ByRef thisDocument As Object)
    On Error Resume Next
    thisDocument.CustomDocumentProperties(thisProperty).Delete
    Err.Clear
End Sub

Public Sub WriteLongProperty(ByRef thisDoc As Document, ByVal thisSetting As String, ByVal thisValue As String)
        Const PARTLEN As Integer = 255
        Dim iCount As Integer
        iCount = 0
        
        'We will be processing thisValue in chunks, gradually reducing the length.
        While Len(thisValue) > 0
            iCount = iCount + 1
            
            Dim thisValuePart As String

            'If the remaining string is bigger than the chunk size, take another chunk.
            '   Otherwise, the remaining string is the last chunk.
            If Len(thisValue) > PARTLEN Then
                thisValuePart = Left(thisValue, PARTLEN)
                thisValue = Right(thisValue, Len(thisValue) - PARTLEN)
            Else
                thisValuePart = thisValue
                thisValue = ""
            End If

            'Write this chunk.
            WriteProperty thisSetting & iCount, thisValuePart, thisDoc
            
        Wend

        WriteProperty thisSetting, "MULTIPART:" & iCount, thisDoc

    End Sub
Attribute VB_Name = "modHelp"
Option Explicit

Public Enum HelpTopics
    JobProperties = 1
    JobManager = 2
    JobManagerSME = 3
    ContentProperties = 4
    SingleEditWord = 5
    multiEditWord = 6
    SingleEditPowerPoint = 7
    MultiEditPowerPoint = 8
    SingleEditExcel = 9
    MultiEditExcel = 10
End Enum

Public Sub launchHelpFile(helpID As HelpTopics)
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    EnsureTempFolderExists
    DebugMsgBox "launch is [hh -mapid " & helpID & " ms-its:" & sTemplatesPath & "QvidianHelp.chm]", "launchHelpFile:"
    Shell "hh -mapid " & helpID & " ms-its:" & sTemplatesPath & "QvidianHelp.chm", vbMaximizedFocus
End Sub

Public Sub SingleEditHelp(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modHelp.launchHelpFile HelpTopics.SingleEditWord
End Sub

Public Sub MultiEditHelp(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modHelp.launchHelpFile HelpTopics.multiEditWord
End Sub

Attribute VB_Name = "modInit"
Option Explicit
'
Public SmartMarking As New clsAdvSmartMarking

'
Public oAppClass As New thisApplication
Public oldNoOfOpenDocs As Long
Public FirstNewDoc As Boolean
Public activeSantDocument As Document
Public bulkloadInitDoc As Document

Public Sub ActivateCurrent()
    On Error Resume Next
    DebugMsgBox "[" & activeSantDocument.FullName & "]", "ActivateCurrent:"
    If Documents.count > 0 Then
        activeSantDocument.Activate
        If Err.Number > 0 Then
            Set activeSantDocument = ActiveDocument
            activeSantDocument.Activate
            Err.Clear
        End If
    Else
        Set activeSantDocument = Nothing
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        End
    End If
    On Error GoTo 0
End Sub

Public Function ApplicationExists() As Boolean
    If TypeName(oAppClass) = "thisApplication" Then
        ApplicationExists = True
    End If
End Function

Public Function GetApplication() As thisApplication
    Set GetApplication = oAppClass
End Function

Public Sub AutoExec()
    SetDebugFile
    DebugMsgBox "Inside", "AutoExec:"
    oAppClass.ignoreDocChange = False
    oAppClass.doAfterEvent = True
    If TypeName(oAppClass.oApp) = "Nothing" Then
        DebugMsgBox "initiate AppClase", "AutoExec:"
        Set oAppClass.oApp = Word.Application
        oldNoOfOpenDocs = 0
        FirstNewDoc = True
        Set activeSantDocument = Nothing
        modToolbar.ShowToolbar (WORD_TOOLBAR)
    End If
End Sub

Public Sub ManualRunOpenCode(debugMode As Boolean)
    DebugMsgBox "", "ManualRunOpenCode:"
    On Error Resume Next
    debugMsg = debugMode
    DebugMsgBox "Debug Mode enabled", "ManualRunOpenCode:"
    Set oAppClass = Nothing
    Set oAppClass = New thisApplication
    oAppClass.ignoreDocChange = False
    oAppClass.doAfterEvent = True
    AutoExec
    oAppClass.RunOpenCodeOnActiveDocument
End Sub
Attribute VB_Name = "modLaunch"
Option Explicit
Option Base 0

Public WebBrowserCollection As New Collection
Public bCancelUpload As Boolean

Public Function GetWebBrowser(isPS As Boolean) As Boolean
    On Error GoTo ErrorHandler
    GetWebBrowser = False
    While WebBrowserCollection.count > 0
        Set WebBrowserCollection = New Collection
    Wend
    GetExistingBrowsers isPS
    If WebBrowserCollection.count > 0 Then
        GetWebBrowser = True
    End If
    Exit Function
ErrorHandler:
    'Received an error, skip out for now.
    DebugMsgBox Err.Number & " " & Err.description & vbCrLf & "DEVELOPER: If this is an expected error, add appropriate handling.", "GetWebBrowser:"
    'Err.Raise CLng(Err.Number)
End Function

Public Sub ClearBrowserCollection()
    While WebBrowserCollection.count > 0
        WebBrowserCollection.Remove (1)
    Wend
End Sub

Public Function GetExistingBrowsers(isPS As Boolean)
    Dim objInstances As Object
    Dim objIE As Object
    Dim sName As String
    Dim urlName As String
    Dim sPath As String
    
    On Error GoTo HandleError
    
    ClearBrowserCollection
    
    Dim curServerName As String
    curServerName = ""
    If Not ss Is Nothing Then curServerName = ss.GetServerName()
    'curServerName = GetServerName(ActiveDocument)
    DebugMsgBox "curServerName = [" & curServerName & "]", "GetExistingBrowsers:"
    
    If curServerName = "" Then
        DebugMsgBox "Call GetDefaultServer", "GetExistingBrowsers:"
        curServerName = GetDefaultServer()
        DebugMsgBox "Back from GetDefaultServer - curServerName = [" & curServerName & "]", "GetExistingBrowsers:"
        If curServerName = "" Then
            Exit Function
        End If
    End If
    
    Set objInstances = CreateObject("Shell.Application").Windows
    
    If objInstances.count > 0 Then '/// make sure we have instances open.
    
        Dim ucSName As String
        ucSName = UCase(curServerName)
        For Each objIE In objInstances
            
            ' avoiding errors
            ' some objects don't seem to have .FullName
            On Error Resume Next
            sName = objIE.FullName
            On Error GoTo HandleError
            
            'MsgBox sName
            DebugMsgBox sName, "GetExistingBrowsers:"
            If UCase(Right(sName, 12)) = "IEXPLORE.EXE" Then '/// it's internet explorer not windows explorer.

                urlName = UCase(objIE.locationurl)
                DebugMsgBox sName & " --> " & urlName, "GetExistingBrowsers:"
                
'                If isPS Then'
                    If (InStr(1, urlName, "QVIDIAN.MVC") > 0 Or InStr(1, urlName, QPA_URL) > 0) Then 'And (InStr(1, urlName, "PROSEARCHHOME.ASPX") > 0) Then
                        DebugMsgBox "Qvidian Browser Window Added " & objIE.locationurl, "GetExistingBrowsers:"
                        WebBrowserCollection.Add objIE
                    End If
'                Else
'                    If (InStr(1, urlName, "QVIDIAN.MVC") > 0 Or InStr(1, urlName, QPA_URL) > 0) And (InStr(1, urlName, "LOGIN.ASPX") <= 0) Then
'                        DebugMsgBox "Qvidian Browser Window Added " & objIE.locationurl, "GetExistingBrowsers:"
'                        WebBrowserCollection.Add objIE
'                    End If
'                End If
            End If
    
        Next
    End If
    Exit Function
    
HandleError:
    DebugMsgBox Err.Number & " " & Err.description & vbCrLf & "DEVELOPER: If this is an expected error, add appropriate handling.", "GetExistingBrowsers:"
    Err.Raise CLng(Err.Number)
    
End Function

Public Function GetIsPS(ByRef thisDoc As Document) As Boolean
    If Len(GetPropertyText("IsPS", thisDoc)) > 0 Then
        GetIsPS = True
    Else
        GetIsPS = False
    End If
End Function

Public Function GetLibraryFolderID(ByVal thisSetting As String) As Long
    Dim rPart As String
    Dim idx As Integer
    idx = InStr(1, thisSetting, "LibraryFolderID")
    If idx > 0 Then
        rPart = Mid(thisSetting, idx + Len("LibraryFolderID"":"))
        idx = InStr(1, rPart, ",")
        GetLibraryFolderID = CLng(Left(rPart, idx - 1))
    Else
        GetLibraryFolderID = 0
    End If
End Function
Attribute VB_Name = "modMultiEdit"
Option Explicit
Public gJobForm As frmMultiEdits
Public gProps As frmContentProperties
Public gIsMultiEditShowing As Boolean
Public currentJobTitle As String
Public currentJobFolder As String
Public currentJobID As String
Public selectedContentIDs As Collection
Public Const MEJFile As String = "MultiEditJobs.xml"

Public gMultiEditFile As clsMultiEdit
Public gJobFile As clsJob
Public Const EnableMenu As Long = 8346395          ' RGB(27, 91, 127)
Public Const DisableMenu As Long = 10526880        ' RGB(160, 160, 160)
Public Const FocusColour As Long = 11139839        ' RGB(255, 250, 169)
Public mOrigBackColour As Long
Public currentContentID As Long

Public gIsQuickEdit As Boolean
Public gOpenViaNewEdit As Boolean
Public extraDoc As Document

Public Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type

Public Const ContentIDCompositeEdit As Integer = -99
Public Const ContentIDNotSet As Integer = -2
Public Const ContentIDComposite As Integer = -1

#If Win64 Then
Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr
Declare PtrSafe Function GetWindowRect Lib "user32" (ByVal hWnd As LongPtr, lpRect As RECT) As LongPtr
Declare PtrSafe Function IsWindow Lib "user32" (ByVal hWnd As Long) As LongPtr
Private lngWin As LongPtr
#Else
Public Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParams As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Public Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
Public Declare Function IsWindow Lib "user32" (ByVal hWnd As Long) As Long
Private lngWin As Long
#End If

Public editDoc As Document
Public isEditOpen As Boolean

Public Enum CMDataTypes
    TextType = 1
    DateType = 2
    IntegerType = 3
    FloatType = 4
    BooleanType = 5
    TextAreaType = 6
    DropDownType = 7
    MultiValueType = 8
End Enum

Public Sub PreviousME(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    PromptSaveCurrentDoc ActiveDocument

    Dim nextNode As struct_Content
    Set nextNode = gJobFile.getPreviousContentByID(currentContentID)
    If Not nextNode Is Nothing Then
        gJobFile.openContentFileFromNode nextNode
        currentContentID = nextNode.contentID
        If gIsMultiEditShowing Then
            gJobForm.selectContentByID nextNode.contentID
        End If
        
        ActivateQvidianRibbon
    End If
End Sub

Public Sub NextME(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    PromptSaveCurrentDoc ActiveDocument

    Dim nextNode As struct_Content
    Set nextNode = gJobFile.getNextContentByID(currentContentID)
    If Not nextNode Is Nothing Then
        gJobFile.openContentFileFromNode nextNode
        currentContentID = nextNode.contentID
        If gIsMultiEditShowing Then
            gJobForm.selectContentByID nextNode.contentID
        End If
        
        ActivateQvidianRibbon
    End If
End Sub

Public Function PromptSaveCurrentDoc(thisDoc As Document, Optional ByVal checkFutureAll As Boolean = False, _
                                     Optional ByRef doFutureAll As Boolean = False, Optional ByVal reloadContentList As Boolean = True, _
                                     Optional ByVal editJobSave As Boolean = False, Optional ByVal showCancel As Boolean = False) As Boolean
    PromptSaveCurrentDoc = False
    DebugMsgBox "The current document has a Saved flag of [" & thisDoc.Saved & "]", "PromptSaveCurrentDoc:"
    If Not thisDoc.Saved Then
        Dim promptResult As VbMsgBoxResult
        DebugMsgBox "checkFutureAll = [" & checkFutureAll & "]", "PromptSaveCurrentDoc:"
        If checkFutureAll Then
            Dim frmANS As frmSaveConfirm
            Set frmANS = New frmSaveConfirm
            frmANS.Show vbModal
            If frmANS.gYes Then
                promptResult = vbYes
            Else
                promptResult = vbNo
            End If
            doFutureAll = frmANS.gAllFuture
            Set frmANS = Nothing
        Else
            If editJobSave Then
                'Switching to automatic save.
                promptResult = vbYes 'MsgBox("You have unsaved changes to your current document. Would you like to save these changes before the content is saved to Qvidian?", vbYesNo, "Save?")
            Else
                If showCancel Then
                    promptResult = MsgBox("You have unsaved changes to your current content. Would you like to save these changes?", vbYesNoCancel, "Save?")
                Else
                    promptResult = MsgBox("You have unsaved changes to your current content. Would you like to save these changes?", vbYesNo, "Save?")
                End If
            End If
        End If
        Select Case promptResult
            Case vbYes
                ' Because we are in control of this update, we DON'T
                ' need the after event to fire that will reload the job file
                oAppClass.doAfterEvent = False
                
                'save document
                thisDoc.Save
                
                ' Reload the metadata to get the updated dates.
                If reloadContentList Then
                    DebugMsgBox "...done the Save, now reload the JobFile...", "PromptSaveCurrentDoc:"
                    gJobFile.loadContentList
                    DebugMsgBox "...done the reload", "PromptSaveCurrentDoc:"
                    If gIsMultiEditShowing Then
                        gJobForm.updateModifiedFlag
                    End If
                End If
                
                oAppClass.doAfterEvent = True
            Case vbNo
                'dont save, continue on
                thisDoc.Saved = True
                
            Case vbCancel
                'cancel the previous
                PromptSaveCurrentDoc = True
                Exit Function
        End Select
    End If

End Function

Public Sub Reset(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    DebugMsgBox "", "modMultiEdit.Reset:"
    
    Dim stagesCount As Long
    stagesCount = 2 + selectedContentIDs.count
    frmProgressBar.StartGeneric ("Your content is being restored...")
    frmProgressBar.Repaint
    DoEvents
    ' Save all the changed documents, and refresh the Library if open...
    ' This also takes care of saving any open documents that have changed too
    If gJobFile.Reset Then
        frmProgressBar.StartGeneric ("Refresh the Job...stage " & stagesCount - 1 & " of " & stagesCount)
        frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount - 1
        DoEvents
        ' Refresh the form...
        If gIsMultiEditShowing Then
            gJobForm.ClearOutGrid
            gJobForm.ReloadMultiEditFile
        End If
    End If
    
    frmProgressBar.StartGeneric ("Finished!")
    frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount
    DoEvents
    Unload frmProgressBar
    checkForCloseApp
    DebugMsgBox "Leaving", "modMultiEdit.Reset:"
End Sub

Public Sub Save(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    
    If ActiveDocument.ActiveWindow.Panes.count > 1 Then
        MsgBox "Please close any open Word panes before saving.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    
    DebugMsgBox "", "modMultiEdit.Save:"
    Dim bComposite As Boolean
    bComposite = gJobFile.isCompositeEdit
    Dim stagesCount As Long
    stagesCount = 2 + selectedContentIDs.count
    frmProgressBar.StartGeneric ("Your file is being saved...")
    frmProgressBar.Repaint
    DoEvents
    
    'if we are doing a single edit, strip any composite bookmarks that will break the CheckCompositeEditBookmarkMap function
    If Not bComposite Then
        Dim bm As Bookmark
        For Each bm In ActiveDocument.Bookmarks
            If Left(LCase(bm.name), 16) = "compositecontent" Or Left(LCase(bm.name), 17) = "compositemetadata" Then
                bm.Delete
            End If
        Next bm
    End If
    
    If Not CheckCompositeEditBookmarkMap(ActiveDocument) Then
        'Messaging handled within check routine.
        DoEvents
        Unload frmProgressBar
        Exit Sub
    End If
           
    ' Save all the changed documents, and refresh the Library if open...
    ' This also takes care of saving any open documents that have changed too
    If gJobFile.Save Then
        frmProgressBar.StartGeneric ("Refresh the Job...stage " & stagesCount - 1 & " of " & stagesCount)
        frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount - 1
        DoEvents
        
        DebugMsgBox "call removeEmptyJob", "modMultiEdit.Save:"
        If removeEmptyJob(bComposite) Then
            DebugMsgBox "back from removeEmptyJob, TRUE", "modMultiEdit.Save:"
        Else
            DebugMsgBox "back from removeEmptyJob, FALSE", "modMultiEdit.Save:"
            
            ' Refresh the form...
            If gIsMultiEditShowing Then
                gJobForm.ClearOutGrid
                gJobForm.ReloadMultiEditFile
            End If
        End If
    End If
    
    If bComposite Then
        frmProgressBar.StartGeneric ("Upload Complete...")
        DoEvents
        Unload frmProgressBar
        modWS.ShowWaitForSaveDialog (gJobFile.compositeJobID)
        checkForCloseApp
    Else
        frmProgressBar.StartGeneric ("Finished!")
        frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount
        DoEvents
        Unload frmProgressBar
        checkForCloseApp
    End If

    DebugMsgBox "Leaving", "modMultiEdit.Save:"
End Sub

Public Sub SaveAll(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    
    ' Special case...a Composite job is treated like a Save
    If gJobFile.isCompositeEdit Then
        Save
        Exit Sub
    End If
    
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    DebugMsgBox "", "SaveALL:"
    
    If ActiveDocument.ActiveWindow.Panes.count > 1 Then
        MsgBox "Please close any open Word panes before saving.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    
    
    Dim stagesCount As Long
    stagesCount = 2 + gJobFile.contentList.count
    frmProgressBar.StartGeneric ("Your files are being saved...")
    frmProgressBar.Repaint
    DoEvents
    ' Save all the changed documents, and refresh the Library if open...
    ' This also takes care of saving any open documents that have changed too
    If gJobFile.SaveAll Then
        frmProgressBar.StartGeneric ("Removing the Job...stage " & stagesCount - 1 & " of " & stagesCount)
        frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount - 1
        DoEvents
        ' Remove the Job from the job file and Dialog...
        DebugMsgBox "removeJobFromJobfile [" & gMultiEditFile.jobFileData(currentJobTitle) & "]", "SaveALL:"
        gMultiEditFile.removeJobFromJobfile gMultiEditFile.jobFileData(currentJobTitle)
        currentJobTitle = ""
        
        ' Refresh the form...
        If gIsMultiEditShowing Then
            gJobForm.ClearOutGrid
            gJobForm.ReloadMultiEditFile
        End If
    End If
    
    frmProgressBar.StartGeneric ("Finished!")
    frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount
    DoEvents
    Unload frmProgressBar
    checkForCloseApp
End Sub

Private Sub checkForCloseApp()
    DebugMsgBox "gIsQuickEdit = [" & gIsQuickEdit & "]", "checkForCloseApp:"
    DebugMsgBox "gMultiEditFile.jobFileData.count = [" & gMultiEditFile.jobFileData.count & "]", "checkForCloseApp:"
    DebugMsgBox "gOpenViaNewEdit = [" & gOpenViaNewEdit & "]", "checkForCloseApp:"
    Dim docCount As Integer
    docCount = Application.Documents.count
    DebugMsgBox "docCount = [" & docCount & "]", "checkForCloseApp:"
    
    If TypeName(extraDoc) <> "Nothing" Then
        On Error Resume Next
        extraDoc.Saved = True
        extraDoc.AttachedTemplate.Saved = True
        extraDoc.Close wdDoNotSaveChanges
    End If
    
    If Application.Documents.count = 0 Then
        Application.Quit wdDoNotSaveChanges
    End If
'    ' If quick edit mode or there are no jobs left, close too!
'    If (gOpenViaNewEdit And gMultiEditFile.jobFileData.count = 0) Then  'REMOVED: gIsQuickEdit Or
'        DebugMsgBox "call CloseDoc", "checkForCloseApp:"
'        CloseDoc
'    End If
    gOpenViaNewEdit = False
End Sub

Private Function removeEmptyJob(Optional ByVal bForceRemove As Boolean = False) As Boolean
    removeEmptyJob = False
    
    ' If we have no files left, then we need to remove the Job. This situation
    ' realy only happens on single file edits...
    ' Remove the Job from the job file and Dialog...
    DebugMsgBox "gJobFile.contentList.count =  [" & gJobFile.contentList.count & "]", "removeEmptyJob:"
    If gJobFile.contentList.count = 0 Or bForceRemove Then
        ' Remove the job files/folder
        DebugMsgBox "Remove folder/files...", "removeEmptyJob:"
        gJobFile.RemoveAll
        
        If gMultiEditFile Is Nothing Then
            DebugMsgBox "Job file currently not loaded, so loading it...", "removeEmptyJob:"
            Set gMultiEditFile = New clsMultiEdit
        
            ' Load the job file in
            gMultiEditFile.loadMultiEditFile
        End If

        DebugMsgBox "removeJobFromJobfile gMultiEditFile.jobFileData([" & currentJobID & ")]", "removeEmptyJob:"
        gMultiEditFile.removeJobFromJobfile currentJobID
        currentJobTitle = ""
        
        ' If this was a quick edit, then close Word, otherwise, reload the job file.
        DebugMsgBox "gIsQuickEdit = [" & gIsQuickEdit & "]", "removeEmptyJob:"
        If gIsQuickEdit Then
            removeEmptyJob = True
        Else
            ' Reload the file
            DebugMsgBox "reload the jobs file", "removeEmptyJob:"
            gMultiEditFile.loadMultiEditFile
        End If
    End If
    DebugMsgBox "Leaving...", "removeEmptyJob:"
End Function

Public Sub ContentProperties(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    ChangeContentProperties currentContentID
End Sub

Public Sub ChangeContentProperties(contentID As Long)
    On Error GoTo ContentError
    Set gProps = New frmContentProperties
    Set gProps.content = gJobFile.loadContentProperties(contentID)
    Set gProps.cmdList = gJobFile.cmdList
    gProps.MultiValueDelimiter = gJobFile.MultiValueDelimiter
    gProps.layoutForm
    gProps.showDefaults
    gProps.Show vbModal
    
    DebugMsgBox "Did something get changed [" & gProps.dataChanged & "]", "ChangeContentProperties:"
    If gProps.dataChanged Then
        If gIsMultiEditShowing Then
            ' Reload the Job file so the grid gets updated.
            gJobForm.loadJobFileIntoGrid currentJobFolder, currentJobTitle, currentJobID
            gJobForm.selectContentByID contentID
        Else
            DebugMsgBox "We're going to have to refresh the job file", "ChangeContentProperties:"
            gJobFile.openJobFile currentJobFolder, currentJobTitle, currentJobID, True
        End If
    End If
    Set gProps = Nothing
    Exit Sub
ContentError:
    DebugMsgBox "[" & Err.description & "]", "ChangeContentProperties:"
End Sub

Public Sub Cancel(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    If Documents.count = 0 Then
        MsgBox "This action requires an active document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    DebugMsgBox "", "modMultiEdit.Cancel:"
    
    frmProgressBar.StartGeneric ("Your selected file is being cancelled...")
    frmProgressBar.Repaint
    DoEvents
    
    ' Cancel the checkouts, and refresh the Library if open...
    If gJobFile.Cancel() Then
        frmProgressBar.StartGeneric ("Refresh the Job...stage 3 of 3")
        frmProgressBar.UpdateProgressBarStatus 3, 2
        DoEvents
        
        DebugMsgBox "call removeEmptyJob", "modMultiEdit.Cancel:"
        If removeEmptyJob Then
            DebugMsgBox "back from removeEmptyJob, TRUE", "modMultiEdit.Cancel:"
        Else
            DebugMsgBox "back from removeEmptyJob, FALSE", "modMultiEdit.Cancel:"
            
            ' Refresh the form...
            DebugMsgBox "gIsMultiEditShowing is [" & gIsMultiEditShowing & "]", "modMultiEdit.Cancel:"
            If gIsMultiEditShowing Then
                gJobForm.ClearOutGrid
                gJobForm.ReloadMultiEditFile
            End If
        End If
    End If
    
    frmProgressBar.StartGeneric ("Finished!")
    frmProgressBar.UpdateProgressBarStatus 3, 3
    DoEvents
    Unload frmProgressBar
    
    checkForCloseApp
    DebugMsgBox "Leaving", "modMultiEdit.Cancel:"
End Sub

Public Sub CancelALL(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    CancelALLDirect
End Sub

Public Sub CancelALLDirect(Optional cleanOutEditFile As Boolean = True)
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    DebugMsgBox "", "CancelALLDirect:"
    
    frmProgressBar.StartGeneric ("Your job is being cancelled...")
    frmProgressBar.Repaint
    DoEvents
    ' Cancel the checkouts, and refresh the Library if open...
    If gJobFile.CancelALL Then
        If cleanOutEditFile Then
            frmProgressBar.StartGeneric ("Removing the Job...stage 3 of 3")
            frmProgressBar.UpdateProgressBarStatus 3, 2
            DoEvents
            ' Remove the Job from the job file and Dialog...
            DebugMsgBox "removeJobFromJobfile(" & currentJobTitle & ") [" & gMultiEditFile.jobFileData(currentJobTitle) & "]", "CancelALLDirect:"
            gMultiEditFile.removeJobFromJobfile gMultiEditFile.jobFileData(currentJobTitle)
            currentJobTitle = ""
            
            ' Refresh the form...
            If gIsMultiEditShowing Then
                gJobForm.ClearOutGrid
                gJobForm.ReloadMultiEditFile
            End If
        End If
    End If
    
    frmProgressBar.StartGeneric ("Finished!")
    frmProgressBar.UpdateProgressBarStatus 3, 3
    DoEvents
    Unload frmProgressBar
    checkForCloseApp
End Sub

Public Sub ToggleForm(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    If gJobForm Is Nothing Then
        DebugMsgBox "Creating a new job form.", "ToggleForm:"
        'Set gJobForm = New frmMultiEdits
        gIsMultiEditShowing = False
    End If
    If gIsMultiEditShowing Then
        gJobForm.saveLocation
        DebugMsgBox "hide...", "ToggleForm:"
        gJobForm.Hide
        Set gJobForm = Nothing
        gIsMultiEditShowing = False
    Else
        ' Make sure we can lock the job file
        If gMultiEditFile Is Nothing Then
            Set gMultiEditFile = New clsMultiEdit
        End If

        DebugMsgBox "currentJobTitle is [" & currentJobTitle & "]", "ToggleForm:"
        DebugMsgBox "currentContentID is [" & currentContentID & "]", "ToggleForm:"
        Dim saveContentID As Long
        Dim saveJobTitle As String
        saveContentID = currentContentID
        saveJobTitle = currentJobTitle
        Set gJobForm = New frmMultiEdits
        
        gJobForm.Show vbModeless
        DebugMsgBox "saveJobTitle is [" & saveJobTitle & "]", "ToggleForm:"
        If Not saveJobTitle = "" Then
            DebugMsgBox "saveContentID is [" & saveContentID & "]", "ToggleForm:"
            currentJobTitle = saveJobTitle
            If saveContentID > 0 Then
                gJobForm.selectContentByID saveContentID
            End If
            currentContentID = saveContentID
        End If
        gIsMultiEditShowing = True
    End If
End Sub

Public Function processJobFile(parJobID As String, contentCount As Integer) As Boolean
    processJobFile = True
    gIsQuickEdit = False
    gOpenViaNewEdit = True
    Dim bCancelJob As Boolean
    bCancelJob = False
    
    ' Grab the handle for the current window - me may need it later to bring it back to focus
#If Win64 Then
    Dim iHandleDoc As LongPtr
#Else
    Dim iHandleDoc As Long
#End If

    Dim translationJob As String
    translationJob = GetPropertyText("IsTranslation", ActiveDocument)
    
    iHandleDoc = GetActiveWindow()
    DebugMsgBox "BringToFront [" & iHandleDoc & "]...", "processJobFile:"
    SetWindowPos iHandleDoc, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE
    
    ' Create the MultiEdit class and load the contents
    If gMultiEditFile Is Nothing Then
        DebugMsgBox "gMultiEditFile is not currently loaded...", "processJobFile:"
        Set gMultiEditFile = New clsMultiEdit
        ' We need to load the contents so that the title name can be checked.
        gMultiEditFile.loadMultiEditFile
    End If
    
    Dim sJobTitle As String
    Dim sFolderName As String
    sFolderName = format(Date, "yyyy_mm_dd") & "_" & format(Time, "hh_mm_ss_AMPM")
    DebugMsgBox "SubFolderName = [" & sFolderName & "]", "processJobFile:"
    DebugMsgBox "filename: " & ActiveDocument.FullName, "processJobFile:"
    ' Prompt the user for the Job File
    Dim titlePrefix As String
    titlePrefix = "Edit on "
    If translationJob = "1" Then
        titlePrefix = "Translation on "
    End If
    
    sJobTitle = titlePrefix & sFolderName ' cleanFileName(Date & "_" & Time)
    If contentCount > 1 Then
        Dim title As frmJobTitle
        
        Set title = New frmJobTitle
        title.txtJobTitle.Text = sJobTitle
        title.txtJobTitle.selStart = 0
        title.txtJobTitle.SelLength = Len(sJobTitle)
        title.txtJobTitle.SetFocus
        title.tlFolder.caption = sFolderName
        title.tlJobID.caption = parJobID
        title.Show vbModal
        sJobTitle = title.txtJobTitle.Text
        
        If Not title.savePressed Then
            'cancel job here
            DebugMsgBox "cancel new job", "processJobFile:"
            bCancelJob = True
        End If
    Else
        gIsQuickEdit = True
    End If
    
    Dim stagesCount As Long
    stagesCount = 3 + contentCount
    frmProgressBar.StartGeneric ("Downloading the Job file...stage 1 of " & stagesCount)
    frmProgressBar.Repaint
    DoEvents
    
    ' Now we can download the file and open it.
    Set gJobFile = New clsJob
    gJobFile.isPS = GetIsPS(ActiveDocument)

    ' Note, we are going to download the Job file even if we couldn't
    ' lock the MutiEdit file because it's the only way we can cleanly
    ' cancel the checkouts!
    Dim bStatus As ConnectionStatus
    DebugMsgBox "Call DownloadJobFile JobID = [" & parJobID & "]", "processJobFile:"
    bStatus = gJobFile.DownloadJobFile(sFolderName, sJobTitle, parJobID, stagesCount)
    DebugMsgBox "DownloadJobFile returned [" & bStatus & "]", "processJobFile:"
    If Not bStatus = ConnectionStatus.worked Then
        If bStatus = ConnectionStatus.Cancelled Then
            MsgBox "You cancelled the connection to the server, so the Edit operation cannot be cancelled. You will need to manually cancel the checkouts for all the files in Qvidian."
        ElseIf bStatus = ConnectionStatus.Error Then
            MsgBox "Failed to download the JobFile [" & parJobID & "]. You will need to manually cancel the checkouts for all the files in Qvidian."
        Else
            MsgBox "Because the Qvidian Add-ins are out-of-date, the Job has been terminated and you will need to manually cancel the checkouts for all the files in Qvidian."
        End If
        ss.wsm_ConnectionTerminate
        DoEvents
        Unload frmProgressBar
        
        processJobFile = False 'set to false because we are exiting purposefully, not via error.
        CloseDoc
        Exit Function
    End If
    
    If bCancelJob Then
        DebugMsgBox "cancelling all because of job title cancel [" & bCancelJob & "]", "processJobFile:"
        CancelALLDirect False
        processJobFile = False 'set to false because we are exiting purposefully, not via error.
                        
        DoEvents
        Unload frmProgressBar
        
        ' The Cancel caused the IE window (if present...) to steal the focus, so we are going
        ' to grab it back agin!
        DebugMsgBox "BringToFront [" & iHandleDoc & "]...", "processJobFile:"
        SetWindowPos iHandleDoc, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE

        MsgBox "You cancelled the Edit session, all files have been checked back in."
        
        CloseDoc
        Exit Function
    End If
    
    ' Add it to the master job file...
    DebugMsgBox "addJobToJobfile: [" & parJobID & "]", "processJobFile:"
    gMultiEditFile.addJobToJobfile parJobID, sJobTitle, sFolderName

    ' Download the contents...
    Dim content As struct_Content
    Dim sEditFilePath As String
    Dim firstContentID As Long
    Dim firstContentFilename As String
    Dim f As Object
    firstContentID = ContentIDNotSet
    firstContentFilename = ""
    currentContentID = ContentIDNotSet
    
    ' If we have a Job ID it's actually a composite edit.
    If gJobFile.isCompositeEdit Then
        frmProgressBar.UpdateProgressBarStatus stagesCount, 3
        frmProgressBar.StartGeneric ("Downloading Composite content files...stage " & 4 & " of " & stagesCount)
        DoEvents
        
        Set content = gJobFile.compositeContent
        content.contentID = ContentIDCompositeEdit
        content.LocalFileName = content.ContentFilename
        sEditFilePath = gJobFile.mJobFileDir & content.LocalFileName
        
        DebugMsgBox "modWS.DownloadCompositeContentFile [" & sEditFilePath & "] " & gJobFile.compositeJobID, "processJobFile:"
        If Not modWS.DownloadCompositeContentFile(sEditFilePath, ActiveDocument, gJobFile.compositeJobID) Then
            'TODO: Change message to be more specific to this case.
            MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
            Exit Function
        End If
        
        ' Get the time-stamp of the file...
        Set f = GetFileSystemObject.GetFile(sEditFilePath)
        DebugMsgBox "file creation timestamp [" & f.DateCreated & "]", "processJobFile:"
        content.LocalFileCreateDate = f.DateCreated
        
        ' ...and save it
        gJobFile.saveCompositeContentFileProperties content.LocalFileName, content.LocalFileCreateDate
        
        If firstContentID = ContentIDNotSet Then
            firstContentID = content.contentID
            firstContentFilename = sEditFilePath
        End If

    Else
        If Not gJobFile.contentList Is Nothing And gJobFile.contentList.count > 0 Then
            Dim idx As Long
            idx = 4
            For Each content In gJobFile.contentList
                frmProgressBar.UpdateProgressBarStatus stagesCount, idx - 1
                frmProgressBar.StartGeneric ("Downloading content files...stage " & idx & " of " & stagesCount)
                DoEvents
                
                If content.contentID > -1 And content.ContentFilename <> "" Then
                    content.LocalFileName = content.ContentFilename
                    sEditFilePath = gJobFile.mJobFileDir & content.LocalFileName
                    ' Check to see if the file already exists
                    DebugMsgBox "[" & sEditFilePath & "] exists...", "processJobFile:"
                    If GetFileSystemObject.FileExists(sEditFilePath) Then
                        Dim tmpIdx As Integer
                        Dim baseName As String
                        Dim ext As String
                        tmpIdx = InStrRev(content.LocalFileName, ".")
                        ext = Mid(content.LocalFileName, tmpIdx, Len(content.LocalFileName))
                        baseName = Mid(content.LocalFileName, 1, tmpIdx - 1)
                        tmpIdx = 1
                        While GetFileSystemObject.FileExists(sEditFilePath)
                            ' Update the Job file with the new file name.
                            content.LocalFileName = baseName & tmpIdx & ext
                            sEditFilePath = gJobFile.mJobFileDir & content.LocalFileName
                            DebugMsgBox "try the new file name [" & sEditFilePath & "] ...", "processJobFile:"
                            tmpIdx = tmpIdx + 1
                        Wend
                    End If
                    
                    DebugMsgBox "IsTranslation: " & content.IsTranslation & " TranslationParent: " & content.TranslationParent, "processJobFile:"
                    
                    Dim sourceID As Long
                    sourceID = content.contentID
                    If content.IsTranslation Then
                        sourceID = content.TranslationParent
                    End If
                    
                    DebugMsgBox "modWS.DownloadContentFile [" & sEditFilePath & "] " & sourceID, "processJobFile:"
                    ' We've had some problems with Unicode here, so going to download
                    ' the file to the Content ID first and then rename later
                    content.LocalTempFileName = content.contentID & Mid(content.LocalFileName, InStrRev(content.LocalFileName, "."), Len(content.LocalFileName))
                    Dim tempFileName As String
                    tempFileName = gJobFile.mJobFileDir & content.LocalTempFileName
                    If Not modWS.DownloadContentFile(tempFileName, ActiveDocument, sourceID, -1, gJobFile.SMEJobID) Then
                        'TODO: Change message to be more specific to this case.
                        MsgBox GetTemplateString("Edit_Download_InvalidBLOBID"), vbCritical, AppTitle
                        Exit Function
                    End If
                    ' Now we'll rename it, if we need to
                    If content.LocalTempFileName <> content.LocalFileName Then
                        On Error Resume Next
                        GetFileSystemObject.MoveFile tempFileName, sEditFilePath
                        If Err.Number > 0 Then
                            ' The move failed, so we'll use the temporary name
                            content.LocalFileName = content.LocalTempFileName
                            content.LocalTempFileName = ""
                        End If
                    Else
                        ' They are the same, so clear out temp to make it easier later
                        content.LocalTempFileName = ""
                    End If
                    
                    ' Get the time-stamp of the file...
                    Set f = GetFileSystemObject.GetFile(sEditFilePath)
                    DebugMsgBox "file creation timestamp [" & f.DateCreated & "]", "processJobFile:"
                    content.LocalFileCreateDate = f.DateCreated
                    
                    ' ...and save it
                    gJobFile.saveContentFileProperties content.contentID, content.LocalFileName, content.LocalFileCreateDate
                    
                    If firstContentID = ContentIDNotSet Then
                        firstContentID = content.contentID
                        firstContentFilename = sEditFilePath
                    End If
                End If
                
                idx = idx + 1
            Next
        End If
    End If
    
    ' We should be done with the DB right now...
    ss.wsm_ConnectionTerminate
    
    frmProgressBar.StartGeneric ("Finished!")
    frmProgressBar.UpdateProgressBarStatus stagesCount, stagesCount
    DoEvents
    Unload frmProgressBar

    DebugMsgBox "firstContentID [" & firstContentID & "] and firstContentFilename = [" & firstContentFilename & "]", "processJobFile:"
    If firstContentID <> ContentIDNotSet And firstContentFilename <> "" Then
            
        If gIsMultiEditShowing Then
            DebugMsgBox "gJobForm is already showing, refresh the drop-down...", "processJobFile:"
            gJobForm.ReloadMultiEditFile
        Else
            DebugMsgBox "gJobForm is NOT showing, set gJobForm to nothing...", "processJobFile:"
            Set gJobForm = Nothing
        End If
        
        DebugMsgBox "Close the current Job launch document", "processJobFile:"
        ActiveDocument.Close
        
        DebugMsgBox "Open the first Content File [" & firstContentID & "]", "processJobFile:"
        openContentFile firstContentID

        ' Note, the following stuff is done AFTER the previous open
        ' because of 64-bit Word/PowerPoint - they crash if done the
        ' other way around:(
        ' More than one file?
        If contentCount > 1 And Not gJobFile.isCompositeEdit Then
            If gJobForm Is Nothing Then
                DebugMsgBox "Creating a new job form.", "processJobFile:"
                Set gJobForm = New frmMultiEdits
            End If
            gJobForm.loadNewJobFile sJobTitle, parJobID, sFolderName 'FullName
            gJobForm.selectContentByID (firstContentID)
        Else
            ' Need to create the global ID's list and add the file
            Set selectedContentIDs = New Collection
            selectedContentIDs.Add (firstContentID)
            currentJobTitle = sJobTitle
            currentJobID = parJobID
            currentJobFolder = sFolderName
            
            ' Track boookmark order to compare on save.
            SaveCompositeEditBookmarkMap editDoc
            
            ' If the Job Manager IS ALREADY showing, we do have to
            ' switch the job
            If gIsMultiEditShowing Then
                DebugMsgBox "gJobForm is already showing, switch the drop-down", "processJobFile:"
                gJobForm.loadNewJobFile sJobTitle, parJobID, sFolderName 'FullName
                gJobForm.selectContentByID (firstContentID)
            End If
        End If
        
        ' Need to force set the current content ID
        currentContentID = firstContentID
    End If
    
    DebugMsgBox "DONE WITH JOB FILE PROCESSING, WE'RE OUT OF HERE.", "processJobFile:"
    processJobFile = False
End Function

Public Function GetCompositeEditBookmarkMap() As String
    Dim bm As Bookmark
    Dim bmString As String
    Dim bmName As String
    DebugMsgBox "Getting list of Composite Edit bookmarks.", "GetCompositeEditBookmarkMap:"
    For Each bm In ActiveDocument.Range.Bookmarks
        bmName = bm.name
        If Len(bmName) >= 17 Then
            If Left(bmName, 16) = "CompositeContent" Or Left(bmName, 17) = "CompositeMetadata" Then
                If bmString = "" Then
                    bmString = bmName
                Else
                    bmString = bmString & "|" & bmName
                End If
            End If
        End If
    Next bm
    DebugMsgBox "Composite Edit bookmarks: " & bmString, "GetCompositeEditBookmarkMap:"
    GetCompositeEditBookmarkMap = bmString
End Function

Public Function SaveCompositeEditBookmarkMap(ByRef thisDoc As Document) As String
    DebugMsgBox "Saving bookmark map", "SaveCompositeEditBookmarkMap:"
    Dim bmMap As String
    bmMap = GetCompositeEditBookmarkMap
    WriteProperty "CompositeEditBookmarkMap", bmMap, thisDoc
    
    'QPA-48672 save the file, so the property change is persisted
    ' properties alone don't save correctly, so make a minor edit to force the save
    thisDoc.ActiveWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    thisDoc.ActiveWindow.Selection.InsertParagraph
    thisDoc.Save
    
    'remove the extra edit
    thisDoc.Range(thisDoc.Range.End - 1, thisDoc.Range.End).Delete
    thisDoc.Save
    
    DebugMsgBox "Saved bookmark map " & bmMap & " to property CompositeEditBookmarkMap", "SaveCompositeEditBookmarkMap:"
    SaveCompositeEditBookmarkMap = bmMap
End Function

Public Function GetSavedCompositeEditBookmarkMap(ByRef thisDoc As Document) As String
    Dim bmMap As String
    DebugMsgBox "Retrieving bookmark map", "GetSavedCompositeEditBookmarkMap:"
    bmMap = GetPropertyText("CompositeEditBookmarkMap", thisDoc)
    DebugMsgBox "Retried bookmark map: " & bmMap, "GetSavedCompositeEditBookmarkMap:"
    GetSavedCompositeEditBookmarkMap = bmMap
End Function

Public Function CheckCompositeEditBookmarkMap(ByRef thisDoc As Document) As Boolean
    'Get the original string and current string to compare them.
    Dim prevString As String
    Dim currentString As String
    DebugMsgBox "Validating bookmark map", "CheckCompositeEditBookmarkMap:"
    prevString = GetPropertyText("CompositeEditBookmarkMap", thisDoc)
    DebugMsgBox "prevString: " & prevString, "CheckCompositeEditBookmarkMap:"
    currentString = GetCompositeEditBookmarkMap
    DebugMsgBox "currentString: " & currentString, "CheckCompositeEditBookmarkMap:"
    
    If prevString = "" Then
        DebugMsgBox "Composite Edit bookmarks cannot be compared because the original string was lost.", "CheckCompositeEditBookmarkMap:"
        'Let the save continue...
        CheckCompositeEditBookmarkMap = True
    End If
    
    If prevString <> currentString Then
        If (InStr(1, prevString, "|") > 0) Then
            'Original string had more than one value, nothing we can do.
            DebugMsgBox "Values do not match, terminate save.", "CheckCompositeEditBookmarkMap:"
            MsgBox "One or more bookmarks have been lost and this file cannot be saved properly.  Please save a copy of this file, cancel your original edit, open the edit again, show bookmarks in the Word document, and paste each piece of content within the appropriate bookmark."
            CheckCompositeEditBookmarkMap = False
        Else
            'Original string had one value, add bookmark back around content.
            thisDoc.ActiveWindow.Selection.WholeStory
            thisDoc.ActiveWindow.Selection.Bookmarks.Add (prevString)
            DebugMsgBox "Bookmark added: " & prevString, "CheckCompositeEditBookmarkMap:"
            CheckCompositeEditBookmarkMap = True
        End If

    Else
        'Values match, continue with save.
        DebugMsgBox "Values match, continue with save.", "CheckCompositeEditBookmarkMap:"
        CheckCompositeEditBookmarkMap = True
    End If
End Function

Public Function saveContentFile(Optional ByRef checkFutureAll As Boolean = False, Optional ByRef doFutureAll As Boolean = False)
    saveContentFile = True
    
    ' Save the current file...
    DebugMsgBox "isEditOpen is [" & isEditOpen & "]", "saveContentFile:"
    If isEditOpen Then
        On Error Resume Next
        If editDoc.Saved = False Then
            DebugMsgBox "one of our open windows needs saving", "saveContentFile:"
            If Err.Number > 0 Then
                ' Should only get here because the user closed our edit window!
                isEditOpen = False
                Set editDoc = Nothing
            Else
                If PromptSaveCurrentDoc(editDoc, checkFutureAll, doFutureAll, , , True) Then
                    Exit Function
                End If
            End If
        End If
    End If
    
    saveContentFile = False
End Function

Public Function openContentFile(contentID As Long)
    openContentFile = True
    DebugMsgBox "currentContentID [" & currentContentID & "]", "openContentFile:"
        
    ' Save the current file...
    If saveContentFile Then
        Exit Function
    End If
    
    DebugMsgBox "call gJobFile.openContentFile on [" & contentID & "]", "openContentFile:"
    DebugMsgBox "currentContentID [" & currentContentID & "]", "openContentFile:"
    If currentContentID <> contentID Then
        If gJobFile.openContentFile(contentID) Then
            currentContentID = contentID
        End If
    End If
    DebugMsgBox "back from gJobFile.openContentFile", "openContentFile:"
    
    openContentFile = False
End Function

Private Function cleanFileName(uncleanName As String)
    ' Windows kernel forbids the use of characters in range 1-31 (i.e., 0x01-0x1F)
    ' and characters " * : < > ? \ / |
    cleanFileName = Replace(uncleanName, """", "_")
    cleanFileName = Replace(cleanFileName, "*", "_")
    cleanFileName = Replace(cleanFileName, ":", "_")
    cleanFileName = Replace(cleanFileName, "<", "_")
    cleanFileName = Replace(cleanFileName, ">", "_")
    cleanFileName = Replace(cleanFileName, "?", "_")
    cleanFileName = Replace(cleanFileName, "\", "_")
    cleanFileName = Replace(cleanFileName, "/", "_")
    cleanFileName = Replace(cleanFileName, "|", "_")
End Function

Public Function DownloadTemplateFile(ByVal sLocalPath As String, ByVal templateNumber As Integer, stagesCount As Long) As Boolean
    frmProgressBar.StartGeneric ("Connecting to the server...stage 2 of " & stagesCount)
    frmProgressBar.UpdateProgressBarStatus stagesCount, 1
    DoEvents
    If setupWSConnection(ActiveDocument, False, True, gJobFile.JobQvidianServer) <> ConnectionStatus.worked Then
        Exit Function
    End If
On Error GoTo ErrorHandler
    Dim nFile As Long
    Dim base64Data As String
    Dim count As Integer
    Dim result As String
    
    If Dir(sLocalPath) <> "" Then
        On Error Resume Next
        Kill sLocalPath
        If Err.Number <> 0 Then
            Err.Clear
            On Error GoTo ErrorHandler
            
            ' Let's try a little more industrial strength delete:)
            GetFileSystemObject.DeleteFile sLocalPath, True
        End If
    End If
    
    frmProgressBar.UpdateProgressBarStatus stagesCount, 2
    frmProgressBar.StartGeneric ("Downloading the template file...stage 3 of " & stagesCount)
    DoEvents
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetTemplateFile(templateNumber)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile

    DownloadTemplateFile = True
    
    Exit Function
ErrorHandler:
    If Err.Number = 438 Then
        'If we receive this error, most likely we attempted to call javascript before it was ready.
        Err.Clear
        DoEvents
        Resume
    Else
        DownloadTemplateFile = False
        If nFile <> -1 Then
            Close #nFile
        End If

        MsgBox Err.Number & " " & Err.description, vbOKOnly, "Qvidian"
        If Dir(sLocalPath) <> "" Then
            On Error Resume Next
            Kill sLocalPath
        End If
    End If
End Function

Sub NewZip(sPath)
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub

Public Function ZipFolder(ByVal FolderPath As Variant, _
                          ByVal ZipFileName As Variant, _
                          Optional ByVal FileFilter As String, _
                          Optional ByVal Overwrite As Boolean = True) As Boolean
                                
    Dim fso As Object, tf As Object
    Dim strZIPHeader As String, sFile As String
    ZipFolder = True
    
    On Error GoTo done
    ' create zip file header
    strZIPHeader = Chr(80) & Chr(75) & Chr(5) & Chr(6) & String(18, Chr(0))
    
    ' make sure source folder path ends in a backslash
    If Right$(FolderPath, 1) <> "\" Then FolderPath = FolderPath & "\"
    
    ' Create new Zip file?
    If Dir(ZipFileName, vbNormal) = vbNullString Or Overwrite = True Then
        Set fso = CreateObject("Scripting.FileSystemObject")
        Set tf = fso.CreateTextFile(ZipFileName)
        tf.Write strZIPHeader
        tf.Close
    End If
    
    ' zip all sub folders and files?
    If FileFilter = vbNullString Then
        With CreateObject("Shell.Application")
            DebugMsgBox "call CopyHere with [" & ZipFileName & "] [" & FolderPath & "]", "ZipFolder:"
            .Namespace((ZipFileName)).CopyHere .Namespace((FolderPath)).Items
        End With
    Else ' zip files from specific folder and file type only!
        With CreateObject("Shell.Application")
            sFile = Dir(FolderPath & FileFilter, vbNormal)
            Do Until sFile = vbNullString
                .Namespace((ZipFileName)).CopyHere FolderPath & sFile
                sFile = Dir
            Loop
        End With
    End If
    
    ZipFolder = False
    
done:
    Set tf = Nothing
    Set fso = Nothing
    
    If Err.Number <> 0 Then
        DebugMsgBox "There was a problem creating the export Zip file (probably because PKZIP is installed): [" & Err.Number & "] [" & Err.description & "]", "ZipFolder:"
        MsgBox "There was a problem creating the exported ZIP file. Please check to make sure your ZIP file application is set to the Operating System|fffd|s default setting. " & _
               "If the problem still exists, please contact Qvidian Technical Support at support@qvidian.com.", vbApplicationModal + vbInformation
    End If
End Function

Public Function isItOurFile(ByVal Doc As Document, ByRef bClearBuiltInProps As Boolean, ByRef bClearCustomProps As Boolean)
    isItOurFile = False
    bClearBuiltInProps = False
    bClearCustomProps = False
    Dim content As struct_Content
    Dim strFile As String
    strFile = LCase(Doc.name)
    
    ' Is it part of the Job file?
    If Not gJobFile Is Nothing Then
        bClearBuiltInProps = gJobFile.ClearBuiltInOfficePropertiesOnSave
        bClearCustomProps = gJobFile.ClearCustomOfficePropertiesOnSave
        DebugMsgBox "gJobFile is SOMETHING BuiltIn = [" & bClearBuiltInProps & "] and Custom = [" & _
                    bClearCustomProps & "]", "isItOurFile:"
        DebugMsgBox "gJobFile isCompositeEdit = [" & gJobFile.isCompositeEdit & "]", "isItOurFile:"
        If gJobFile.isCompositeEdit Then
            If LCase(gJobFile.compositeContent.LocalFileName) = strFile Then
                isItOurFile = True
                Exit Function
            End If
        Else
            For Each content In gJobFile.contentList
                DebugMsgBox "compare [" & LCase(content.LocalFileName) & "] with [" & strFile & "]", "isItOurFile:"
                If LCase(content.LocalFileName) = strFile Then
                    isItOurFile = True
                    Exit Function
                End If
            Next
        End If
    End If
   
    ' Is it part of ANY of our job files?
    DebugMsgBox "gJobFile is nothing", "isItOurFile:"
    If gMultiEditFile Is Nothing Then
        DebugMsgBox "Multi Edit file currently not loaded, so loading it...", "isItOurFile:"
        Set gMultiEditFile = New clsMultiEdit
    
        ' Load the job file in
        gMultiEditFile.loadMultiEditFile
    End If
        
    If gMultiEditFile.jobFileData.count > 0 Then
        Dim strPath As String
        strPath = LCase(Replace(Doc.FullName, "\" & Doc.name, ""))
        
        Dim idx As Integer
        With gMultiEditFile.jobFolderData
            For idx = 0 To .count - 1
                Dim jobFolder As String
                jobFolder = CStr(.Items(idx))
                Dim jobFullFolder As String
                jobFullFolder = LCase(gMultiEditFile.sMultiEditFilesFolder & jobFolder)
                DebugMsgBox "[" & jobFolder & "] compare [" & jobFullFolder & "] with [" & strPath & "]", "isItOurFile:"
                If jobFullFolder = strPath Then
                    Dim JobID As String
                    JobID = CStr(gMultiEditFile.jobFileData.Items(idx))
                    DebugMsgBox "Open [" & JobID & "]", "isItOurFile:"
                    Dim tempJobFile As New clsJob
                    tempJobFile.openJobFile jobFolder, "Temp", JobID, True
                    
                    bClearBuiltInProps = tempJobFile.ClearBuiltInOfficePropertiesOnSave
                    bClearCustomProps = tempJobFile.ClearCustomOfficePropertiesOnSave
                    DebugMsgBox "tempJobFile BuiltIn = [" & bClearBuiltInProps & "] and Custom = [" & _
                                bClearCustomProps & "]", "isItOurFile:"
                    DebugMsgBox "tempJobFile isCompositeEdit = [" & tempJobFile.isCompositeEdit & "]", "isItOurFile:"
                    If tempJobFile.isCompositeEdit Then
                        If LCase(tempJobFile.compositeContent.LocalFileName) = strFile Then
                            isItOurFile = True
                            Exit Function
                        End If
                    Else
                        For Each content In tempJobFile.contentList
                            DebugMsgBox "compare [" & LCase(content.LocalFileName) & "] with [" & strFile & "]", "isItOurFile:"
                            If LCase(content.LocalFileName) = strFile Then
                                isItOurFile = True
                                Exit Function
                            End If
                        Next
                    End If
                End If
            Next idx
        End With
    End If
    DebugMsgBox "It's not one of ours at this point!", "isItOurFile:"
End Function

Public Sub AfterSaveEvent()
    
    DebugMsgBox "call gJobFile.loadContentList", "AfterSaveEvent:"
    If Not gJobFile Is Nothing Then
        gJobFile.loadContentList
        If gIsMultiEditShowing Then
            DebugMsgBox "call gJobForm.reloadGridFromJobFile", "AfterSaveEvent:"
            gJobForm.reloadGridFromJobFile
            DebugMsgBox "call gJobForm.selectContentByID [" & currentContentID & "]", "AfterSaveEvent:"
            gJobForm.selectContentByID currentContentID
        End If
    End If
End Sub

Public Sub GlobalReplaceInternal(Optional alwaysShow As Boolean = True)
    If Documents.count = 0 Then
        MsgBox "This action requires an active document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    ' Do we have anything to do?
    If gJobFile Is Nothing Then Exit Sub
    If gJobFile.contentList.count = 0 And gJobFile.isCompositeEdit = False Then Exit Sub
    
    Dim returnContentID As Long
    returnContentID = currentContentID
    
    ' loop through all the content...
    Dim first As Boolean
    first = True
    Dim content As struct_Content
    On Error Resume Next
    Dim doFutureAll As Boolean
    doFutureAll = False
    If gJobFile.isCompositeEdit Then
        Set content = gJobFile.compositeContent
        If gIsMultiEditShowing Then gJobForm.selectContentByID (content.contentID)
        openContentFile content.contentID
    
        Err.Clear
        Dialogs(wdDialogEditReplace).Show
    
        DebugMsgBox "exited with code [" & Err.Number & "] [" & Err.description & "]", "GlobalReplaceInternal:"
        
        If editDoc.Saved = False Then
            DebugMsgBox "One of our open windows needs saving. doFutureAll = [" & doFutureAll & "[", "GlobalReplaceInternal:"
            If doFutureAll Or alwaysShow = False Then
                oAppClass.doAfterEvent = False
                editDoc.Save
                If gIsMultiEditShowing Then gJobForm.updateModifiedFlag
                oAppClass.doAfterEvent = True
            Else
                saveContentFile True, doFutureAll
            End If
        End If
    Else
    For Each content In gJobFile.contentList
        ' Open each file!
        If gIsMultiEditShowing Then gJobForm.selectContentByID (content.contentID)
        openContentFile content.contentID
        
        ' Show Find/Replace
        If first Or alwaysShow Then
            Err.Clear
            Dialogs(wdDialogEditReplace).Show
        
            DebugMsgBox "exited with code [" & Err.Number & "] [" & Err.description & "]", "GlobalReplaceInternal:"
            
            ' Check to see if the user should be prompted to stop.
            ' The ONLY way to get a 0 is if no changes and the user just clicked close,
            ' so no need to check for saving.
            If Err.Number = 0 Then
                Dim promptResult As VbMsgBoxResult
                promptResult = MsgBox("Cancel Replace operation?", vbYesNo, "Cancel Confirmation")
                If promptResult = vbYes Then
                    DebugMsgBox "User wants to terminate the cancel", "GlobalReplaceInternal:"
                    Exit For
                End If
            Else
                If editDoc.Saved = False Then
                    DebugMsgBox "One of our open windows needs saving. doFutureAll = [" & doFutureAll & "[", "GlobalReplaceInternal:"
                    If doFutureAll Or alwaysShow = False Then
                        oAppClass.doAfterEvent = False
                        editDoc.Save
                        If gIsMultiEditShowing Then gJobForm.updateModifiedFlag
                        oAppClass.doAfterEvent = True
                    Else
                        saveContentFile True, doFutureAll
                    End If
                End If
            End If
            first = False
        Else
            ' Display/Update progress dialog
            With Dialogs(wdDialogEditReplace)
                .replaceall = 1
                .Execute
            End With
            DebugMsgBox "auto exited with code [" & Err.Number & "] [" & Err.description & "]", "GlobalReplaceInternal:"
            
            ' Save the file, we always do this!
            If editDoc.Saved = False Then
                oAppClass.doAfterEvent = False
                editDoc.Save
                If gIsMultiEditShowing Then gJobForm.updateModifiedFlag
                oAppClass.doAfterEvent = True
            End If
        End If
    Next
    End If
    
    ' Re-display the original file, if there was one.
    DebugMsgBox "Should we change the displayed file [" & currentContentID & "] to [" & returnContentID & "]", "GlobalReplaceInternal:"
    If returnContentID <> ContentIDNotSet Then
        If currentContentID <> returnContentID Then
            If gIsMultiEditShowing Then gJobForm.selectContentByID (returnContentID)
            openContentFile returnContentID
            currentContentID = returnContentID
        End If
    Else
        editDoc.Close False
        isEditOpen = False
        currentContentID = ContentIDNotSet
        Set editDoc = Nothing
    End If
    
    ' Reload the metadata to get the updated dates.
    gJobFile.loadContentList
    
    If Not alwaysShow Then
        MsgBox "Replace All has finished.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
End Sub

Public Sub TrackChangesInternal(ByVal ttState As Boolean)
    ' Do we have anything to do?
    If gJobFile Is Nothing Then Exit Sub
    If gJobFile.contentList.count = 0 Then Exit Sub
    
    Dim returnContentID As Long
    returnContentID = currentContentID
    
    ' loop through all the content...
    Dim first As Boolean
    first = True
    Dim content As struct_Content
    On Error Resume Next
    Dim doFutureAll As Boolean
    doFutureAll = False
    For Each content In gJobFile.contentList
        ' Open each file!
        If gIsMultiEditShowing Then gJobForm.selectContentByID (content.contentID)
        openContentFile content.contentID
        
        ' Set  the track changes status...
        editDoc.trackRevisions = ttState
        ' ...and save the file (turning TT is concidered a change to the file and
        ' requires a save per Word)
        editDoc.Save
    Next
    
    ' Re-display the original file, if there was one.
    DebugMsgBox "Should we change the displayed file [" & currentContentID & "] to [" & returnContentID & "]", "TrackChangesInternal:"
    If returnContentID > 0 Then
        If gIsMultiEditShowing Then gJobForm.selectContentByID (returnContentID)
        openContentFile returnContentID
        currentContentID = returnContentID
    Else
        editDoc.Close False
        isEditOpen = False
        currentContentID = ContentIDNotSet
        Set editDoc = Nothing
    End If
    
    ' Just in case...
     If Documents.count = 0 Then
        DebugMsgBox "Open a new blank document as there are none open right now.", "TrackChangesInternal:"
        ' Open new document
        Set extraDoc = Documents.Add
        extraDoc.Activate
    End If
   
    ' Reload the metadata to get the updated dates.
    If gIsMultiEditShowing Then
        gJobForm.ClearOutGrid
        gJobForm.ReloadMultiEditFile
    End If
End Sub

Public Sub ApplyStyleTemplatesInternal(ByVal sTemplate As String)
    If Documents.count = 0 Then
        MsgBox "This action requires an active Word document.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    
    ' Do we have anything to do?
    If gJobFile Is Nothing Then Exit Sub
    If gJobFile.isCompositeEdit Then
        ' Should NEVER be able to get here!!!
        Exit Sub
    End If
    If gJobFile.contentList Is Nothing Then Exit Sub
    If gJobFile.contentList.count = 0 Then Exit Sub
    
    Dim returnContentID As Long
    returnContentID = currentContentID
    
    ' loop through all the content...
    Dim first As Boolean
    first = True
    Dim content As struct_Content
    On Error Resume Next
    Dim doFutureAll As Boolean
    doFutureAll = False
    For Each content In gJobFile.contentList
        ' Open each file!
        If gIsMultiEditShowing Then gJobForm.selectContentByID (content.contentID)
        openContentFile content.contentID
        
        'APPLY STYLE TEMPLATE (may not need copy if we're attaching and updating)
        CopyStylesWithHiddenProperty editDoc, sTemplate
        
        'JSB: 2013/06/06 - attaching style template in case there are toolbars, macros, etc.
        editDoc.UpdateStylesOnOpen = True
        editDoc.AttachedTemplate = sTemplate
        editDoc.UpdateStyles
        'DS 9/21/18 setting back to false so content doesn't look for template on future edits
        editDoc.UpdateStylesOnOpen = False

        
        ' Save the file, we always do this!
        If editDoc.Saved = False Then
            oAppClass.doAfterEvent = False
            editDoc.Save
            If gIsMultiEditShowing Then gJobForm.updateModifiedFlag
            oAppClass.doAfterEvent = True
        End If
    Next
    
    ' Re-display the original file, if there was one.
    DebugMsgBox "Should we change the displayed file [" & currentContentID & "] to [" & returnContentID & "]", "GlobalReplaceInternal:"
    If returnContentID > 0 Then
        If currentContentID <> returnContentID Then
            If gIsMultiEditShowing Then gJobForm.selectContentByID (returnContentID)
            openContentFile returnContentID
            currentContentID = returnContentID
        End If
    Else
        editDoc.Close False
        isEditOpen = False
        currentContentID = ContentIDNotSet
        Set editDoc = Nothing
    End If
    
    ' Just in case...
     If Documents.count = 0 Then
        DebugMsgBox "Open a new blank document as there are none open right now.", "ApplyStyleTemplatesInternal:"
        ' Open new document
        Set extraDoc = Documents.Add
        extraDoc.Activate
    End If
    
    ' Reload the metadata to get the updated dates.
    gJobFile.loadContentList
End Sub
Attribute VB_Name = "modRibbonNOCOPY"
Public Const TEMPLATETYPE As Integer = 2007

Option Explicit
Public Rib As IRibbonUI
Public currentID As String

'Callback for customUI.
Public Sub RibbonCB(Ribbon As IRibbonUI)
    'MsgBox "Hello from ribbonville"
    Set Rib = Ribbon
    'ShowRibbon BURST_TOOLBAR
End Sub

'May switch to tag, and use the same tag as the toolbars.
Public Sub ShowRibbon(ByVal thisMode As String)
    Call RefreshRibbon("")
    Select Case thisMode
        Case WORD_TOOLBAR: Call RefreshRibbon("WORD_TOOLBAR")
        Case CONTENT_TOOLBAR: Call RefreshRibbon("CONTENT_TOOLBAR")
        Case BULKLOAD_TOOLBAR: Call RefreshRibbon("BULKLOAD_TOOLBAR")
        Case BURST_TOOLBAR: Call RefreshRibbon("BURST_TOOLBAR")
        Case RFPTEAM_TOOLBAR: Call RefreshRibbon("RFPTEAM_TOOLBAR")
        Case RFPTEAMVIEW_TOOLBAR: Call RefreshRibbon("RFPTEAMVIEW_TOOLBAR")
        Case RFPINDIVIDUAL_TOOLBAR: Call RefreshRibbon("RFPINDIVIDUAL_TOOLBAR")
        Case VIEW_TOOLBAR: Call RefreshRibbon("VIEW_TOOLBAR")
        Case POSTBUILD_TOOLBAR: Call RefreshRibbon("POSTBUILD_TOOLBAR")
        Case STRUCTURE_TOOLBAR: Call RefreshRibbon("STRUCTURE_TOOLBAR")
        Case FILELIST_TOOLBAR: Call RefreshRibbon("FILELIST_TOOLBAR")
        Case MULTIEDIT_TOOLBAR: Call RefreshRibbon("MULTIEDIT_TOOLBAR")
        Case MULTIEDIT_S_TOOLBAR: Call RefreshRibbon("MULTIEDIT_S_TOOLBAR")
        'Case Else: Call RefreshRibbon("")
    End Select
End Sub

Public Sub GetVisibleQvidian(control As IRibbonControl, ByRef visible)
    If currentID = "show" Then
        visible = True
    Else
        If control.id Like currentID Then
            visible = True
        Else
            visible = False
        End If
    End If
End Sub

Public Sub RefreshRibbon(thisID As String)
    currentID = thisID
    If Rib Is Nothing Then
        'MsgBox "Error, Save/Restart your workbook"
    Else
        Rib.Invalidate
    End If
End Sub

Public Sub ShowHideTabs(ByVal bShow As Boolean)
    If bShow Then
        ShowAllTabs
    Else
        HideAllTabs
    End If
End Sub

Public Sub ShowAllTabs()
    Call RefreshRibbon("show")
End Sub

Public Sub HideAllTabs()
'Hide every Tab, Group or Control(we use Tag:="")
    Call RefreshRibbon("")
End Sub

Public Sub GetDescription(control As IRibbonControl, ByRef description)
    'description = "Not set"
End Sub

Public Sub GetScreenTip(control As IRibbonControl, ByRef screentip)
    'screentip = "Not set"
End Sub





Attribute VB_Name = "modSantTextFile"
' 2006-10-06 KV
' This module was created to read PM/PB.txt files while preserving Unicode chars
' Regular VBA text reading commands such as LINE INPUT do not handle Unicode properly

Option Explicit

Private nSantTextCurrentChar As Long
Private strSantTextFile As String

Public Sub SantTextReadFile(strFilename As String)
    Dim byteArray() As Byte
    Dim FileNum As Long
    Dim FileSize As Long
    
    SantTextReset
    
    FileSize = FileLen(strFilename)
    If FileSize > 0 Then
        ReDim byteArray(0 To FileSize - 1) As Byte
        
        FileNum = FreeFile()
        
        Open strFilename For Binary As FileNum
        Get FileNum, , byteArray
        Close FileNum
        
        strSantTextFile = byteArray
        
    End If
End Sub

Public Function SantTextNextLine() As String
    Dim nPos As Long
    
    nPos = InStr(nSantTextCurrentChar, strSantTextFile, vbCrLf)
    If nPos > 0 Then
        SantTextNextLine = Mid(strSantTextFile, nSantTextCurrentChar, nPos - nSantTextCurrentChar)
        nSantTextCurrentChar = nPos + Len(vbCrLf) ' skip CRLF
    Else
        ' return everything to the end of the file
        SantTextNextLine = Mid(strSantTextFile, nSantTextCurrentChar)
        nSantTextCurrentChar = Len(strSantTextFile) + 1 ' step outside the file length
    End If
End Function

Public Function SantTextEOF() As Boolean
    If nSantTextCurrentChar > Len(strSantTextFile) Then
        SantTextEOF = True
    End If
End Function

Private Sub SantTextReset()
    strSantTextFile = ""
    nSantTextCurrentChar = 1
End Sub

Public Sub SantTextClose()
    SantTextReset
End Sub

Public Sub SantTextCreate(ByVal thisPath As String, ByVal thisString As String)
    Dim fnum As Integer

    If Dir(thisPath) <> "" Then
        Kill (thisPath)
    End If
    
    'set and open file for output
    fnum = FreeFile()
    Open thisPath For Output As fnum
    'use Print when you want the string without quotation marks
    Print #fnum, thisString
    Close #fnum
End Sub




Attribute VB_Name = "modToolbar"
Option Explicit
'CALL CreateToolbars when the template is in the same folder as the toolbar graphics to re-build the toolbars.

Public Const WORD_TOOLBAR As String = "Qvidian - Word Toolbar"
Public Const CONTENT_TOOLBAR As String = "Qvidian - Content Toolbar"
Public Const BULKLOAD_TOOLBAR As String = "Qvidian - Bulk Load Toolbar"
Public Const BURST_TOOLBAR As String = "Qvidian - Burst Toolbar"
Public Const RFPTEAM_TOOLBAR As String = "Qvidian - Team RFP Toolbar"
Public Const RFPTEAMVIEW_TOOLBAR As String = "Qvidian - Team RFP Toolbar - Read Only"
Public Const RFPINDIVIDUAL_TOOLBAR As String = "Qvidian - Individual RFP Toolbar"
Public Const VIEW_TOOLBAR As String = "Qvidian - Read Only Toolbar"
Public Const POSTBUILD_TOOLBAR As String = "Qvidian - Post-Build Toolbar"
Public Const STRUCTURE_TOOLBAR As String = "Qvidian - Structured Content Toolbar"
Public Const FILELIST_TOOLBAR As String = "Qvidian - File List Toolbar"
Public Const MULTIEDIT_TOOLBAR As String = "Qvidian - Multi-Edit Toolbar"
Public Const MULTIEDIT_S_TOOLBAR As String = "Qvidian - Multi-Edit (Single Edit) Toolbar"

Private currentTemplateMode As String

Public Sub SwitchToolbarsExplicit(ByRef sMode As String, ByRef thisDoc As Document)
    DebugMsgBox "SantTemplateMode = [" & sMode & "]", "SwitchToolbarsExplicit:"
    DebugMsgBox "Spreadsheet = [" & thisDoc.name & "]", "SwitchToolbarsExplicit:"
    
    If modInit.activeSantDocument Is Nothing Then
        DebugMsgBox "modInit.activeSantDocument.FullName is empty", "SwitchToolbarsExplicit:"
        thisDoc.Activate
        Set modInit.activeSantDocument = thisDoc
    End If
    
    Select Case sMode
        Case "BulkloadLaunch", "SantCopyAndClose", "SantCopyAndOpen", "SantScriptedCopy", "QvidianDocNoToolbar"
            ShowToolbar ""
        Case "SantRFPFileWordEdit", "SantRFPCompareContent"
            If GetPropertyText("ForMarking", thisDoc) = "1" Then
                SmartMarking.MarkingMode = MODE_BURST
                ShowToolbar (BURST_TOOLBAR)
            ElseIf GetPropertyText("CheckedOutRecords", thisDoc) = "" Then
                ShowToolbar (RFPINDIVIDUAL_TOOLBAR)
            Else
                ShowToolbar (RFPTEAM_TOOLBAR)
            End If
            
        Case "SantFileListWordEdit"
            ShowToolbar (FILELIST_TOOLBAR)
            
        Case "SantRFPFileWordView"
            ShowToolbar (RFPTEAMVIEW_TOOLBAR)
            
        Case "SantWordView", "SantCompareContent"
            ShowToolbar (VIEW_TOOLBAR)
            
        Case "SantWordMultiEdit", "SantWordEdit"
            'ShowToolbar (VIEW_TOOLBAR) 'Check what we need to look for to determine this toolbar.
            ShowToolbar (CONTENT_TOOLBAR)
            
        Case "SantWordBulkLoad"
            SmartMarking.MarkingMode = MODE_BULKLOAD
            ShowToolbar (BULKLOAD_TOOLBAR)
            
        Case "SantPostBuild"
            ShowToolbar (POSTBUILD_TOOLBAR)
            
        Case "SantStructure"
            ShowToolbar (STRUCTURE_TOOLBAR) 'Mode not implemented
                    
        Case "MultiEdit"
            DebugMsgBox "gJobFile.contentList.count = " & gJobFile.contentList.count, "SwitchToolbarsExplicit:"
            If gJobFile.isCompositeEdit Or gJobFile.contentList.count = 1 Then
                ShowToolbar (MULTIEDIT_S_TOOLBAR)
            Else
                ShowToolbar (MULTIEDIT_TOOLBAR)
            End If

        Case Else
            ShowToolbar (WORD_TOOLBAR)
            
    End Select
    'End If
    DebugMsgBox "Leaving", "SwitchToolbarsExplicit:"
End Sub

Public Sub SwitchToolbars(ByRef thisDoc As Document)
    Dim sMode As String
    Dim sMappingInfo As String
        
    'Testing to see if this fixes issue.
    If LCase(TypeName(thisDoc)) = "object" Or LCase(TypeName(thisDoc)) = "nothing" Then
        Exit Sub
    End If
    
    sMode = GetPropertyText("SantTemplateMode", thisDoc)
    DebugMsgBox "SantTemplateMode = [" & sMode & "] and currentTemplateMode = [" & currentTemplateMode & "] and thisDoc.FullName = [" & thisDoc.FullName & "]", "SwitchToolbars:"
    
    'hide toolbars for WebDav edits
    Dim lcName As String
    Dim bHideToolbars As Boolean
    bHideToolbars = False
    
    lcName = LCase(thisDoc.FullName)
    ' Must start with http and have /webdav/ in it somewhere
    If Left(lcName, 4) = "http" Then
        If InStr(1, lcName, "/webdav/", VbCompareMethod.vbTextCompare) Then
            bHideToolbars = True
        End If
    End If
    
    'for local dev, use this check
    If InStr(1, lcName, "qvidian.mvc/webdav/", VbCompareMethod.vbTextCompare) Then
        bHideToolbars = True
    End If
    
    If bHideToolbars Then
        DebugMsgBox "It's from WebDAV, so no toolbar", "SwitchToolbars"
        HideAllToolbars
        Exit Sub
    End If
        
    Set modInit.activeSantDocument = thisDoc
    If currentTemplateMode = "" Or currentTemplateMode <> sMode Then
        currentTemplateMode = sMode
        Select Case sMode
            Case "BulkloadLaunch", "SantCopyAndClose", "SantCopyAndOpen", "SantScriptedCopy", "QvidianDocNoToolbar"
                ShowToolbar ""
            Case "SantRFPFileWordEdit", "SantRFPCompareContent"
                If GetPropertyText("ForMarking", thisDoc) = "1" Then
                    SmartMarking.MarkingMode = MODE_BURST
                    ShowToolbar (BURST_TOOLBAR)
                ElseIf GetPropertyText("CheckedOutRecords", thisDoc) = "" Then
                    ShowToolbar (RFPINDIVIDUAL_TOOLBAR)
                    VerifyRFPBookmarkMap
                Else
                    ShowToolbar (RFPTEAM_TOOLBAR)
                End If
                
            Case "SantFileListWordEdit"
                ShowToolbar (FILELIST_TOOLBAR)
                
            Case "SantRFPFileWordView"
                ShowToolbar (RFPTEAMVIEW_TOOLBAR)
                
            Case "SantWordView", "SantCompareContent"
                ShowToolbar (VIEW_TOOLBAR)
                
            Case "SantWordMultiEdit", "SantWordEdit"
                'ShowToolbar (VIEW_TOOLBAR) 'Check what we need to look for to determine this toolbar.
                ShowToolbar (CONTENT_TOOLBAR)
                
            Case "SantWordBulkLoad"
                SmartMarking.MarkingMode = MODE_BULKLOAD
                ShowToolbar (BULKLOAD_TOOLBAR)
                
                If GetPropertyText("BulkLoadOriginalFilename", thisDoc) = "" Then
                    DebugMsgBox "SwitchToolbars: BulkLoadOriginalFilename=" & thisDoc.name
                    WriteProperty "BulkLoadOriginalFilename", thisDoc.name, thisDoc
                End If
                
            Case "SantPostBuild"
                ShowToolbar (POSTBUILD_TOOLBAR)
                
            Case "SantStructure"
                ShowToolbar (STRUCTURE_TOOLBAR) 'Mode not implemented
                
            Case Else
                Dim smeStubFile As String
                smeStubFile = GetPropertyText("SMEStubFile", thisDoc)
                DebugMsgBox "smeStubFile = [" & smeStubFile & "]", "SwitchToolbars:"
                ' Check to see if we are a SME Stub file...
                If smeStubFile = "" Then
                    If isItOurFile(thisDoc, False, False) Then
                    'If Not gJobFile Is Nothing Then
                        DebugMsgBox "gJobFile is SOMETHING", "SwitchToolbars:"
                        If gJobFile.isCompositeEdit Or gJobFile.contentList.count = 1 Then
                            ShowToolbar (MULTIEDIT_S_TOOLBAR)
                        Else
                            ShowToolbar (MULTIEDIT_TOOLBAR)
                        End If
                    Else
                        ' Still could be a SME launch of a content file!
                        Dim smeLaunch As Boolean
                        smeLaunch = False
                        ' Check for JobFile.xml being in the same folder as the content
                        Dim strPath As String
                        strPath = LCase(Replace(thisDoc.FullName, "\" & thisDoc.name, ""))
                        DebugMsgBox "gJobFile is nothing - Check Stub File = [" & strPath & "\JobFile.xml]", "SwitchToolbars:"
                        If GetFileSystemObject.FileExists(strPath & "\JobFile.xml") Then
                            smeLaunch = True
                        End If
                        If smeLaunch Then
                            HideAllToolbars
                        Else
                            ShowToolbar (WORD_TOOLBAR)
                        End If
                    End If
                Else
                    HideAllToolbars
                End If
        End Select
    End If
End Sub

Public Sub HideAllToolbars()
    ShowHideToolbars (False)
End Sub

Private Sub hideCheckToolbar(tbName As String, showThisToolbar As String)
    Dim bTemp As Boolean
    bTemp = IIf(tbName = showThisToolbar, True, False)
    If bTemp <> CommandBars(tbName).visible Then CommandBars(tbName).visible = False
End Sub

Public Sub ShowToolbar(ByVal showThisToolbar As String)
    DebugMsgBox "showThisToolbar = [" & showThisToolbar & "]", "ShowToolbar:"
    If modRibbonNOCOPY.TEMPLATETYPE = 2007 Then
        HideAllToolbars
        'RemoveToolbars
        ShowRibbon showThisToolbar
    Else
        DebugMsgBox "hide all toolbars", "ShowToolbar:"
        HideAllToolbars
    
        If showThisToolbar <> "" Then
            CommandBars(showThisToolbar).visible = True
        End If
    End If
End Sub

Public Sub ShowAllToolbars()
    ShowHideToolbars True
End Sub

Private Sub ShowHideToolbars(ByVal bShow As Boolean)
    On Error GoTo ErrorHandler
    If modRibbonNOCOPY.TEMPLATETYPE = 2007 Then
        modRibbonNOCOPY.ShowHideTabs bShow
    Else
        CommandBars(BURST_TOOLBAR).visible = bShow
        CommandBars(BULKLOAD_TOOLBAR).visible = bShow
        CommandBars(CONTENT_TOOLBAR).visible = bShow
        CommandBars(VIEW_TOOLBAR).visible = bShow
        CommandBars(RFPTEAM_TOOLBAR).visible = bShow
        CommandBars(RFPTEAMVIEW_TOOLBAR).visible = bShow
        CommandBars(RFPINDIVIDUAL_TOOLBAR).visible = bShow
        CommandBars(POSTBUILD_TOOLBAR).visible = bShow
        CommandBars(STRUCTURE_TOOLBAR).visible = bShow
        CommandBars(WORD_TOOLBAR).visible = bShow
        CommandBars(FILELIST_TOOLBAR).visible = bShow
        CommandBars(MULTIEDIT_TOOLBAR).visible = bShow
        CommandBars(MULTIEDIT_S_TOOLBAR).visible = bShow
    End If
    Exit Sub
ErrorHandler:
    Exit Sub
    'MsgBox "Error switching toolbars.  Toolbars may not exist in the template."
End Sub

Public Sub RemoveToolbars()
    RemoveToolbar (BURST_TOOLBAR)
    RemoveToolbar (BULKLOAD_TOOLBAR)
    RemoveToolbar (CONTENT_TOOLBAR)
    RemoveToolbar (VIEW_TOOLBAR)
    RemoveToolbar (RFPTEAM_TOOLBAR)
    RemoveToolbar (RFPTEAMVIEW_TOOLBAR)
    RemoveToolbar (RFPINDIVIDUAL_TOOLBAR)
    RemoveToolbar (POSTBUILD_TOOLBAR)
    RemoveToolbar (STRUCTURE_TOOLBAR)
    RemoveToolbar (WORD_TOOLBAR)
    RemoveToolbar (FILELIST_TOOLBAR)
End Sub

Public Sub CreateToolbars()
    CreateBurstToolbar
    CreateBulkloadToolbar
    CreateContentToolbar
    CreateStructureToolbar
    CreateRFPTeamToolbar
    CreateRFPTeamReadOnlyToolbar
    CreateRFPIndividualToolbar
    CreateViewToolbar
    CreateGenericToolbar
    CreatePostBuildToolbar
    CreateFileListToolbar
    
    DebugMsgBox "hide all toolbars", "CreateToolbars:"
    HideAllToolbars
End Sub

Private Sub CreateBurstToolbar()
'Burst (8.3): Prev, Next, SmartMarking Enabled/Disabled, Header, Question, Answer, Feature Matrix, Remove, Tools, Finished, Cancel, Help
'   Tools (Advanced SmartMarking Options, Clear All Markings, Mark Selected Row as Header, Mark Selected Row as Header.
'       Mark All Table Rows as Questions, Add Missing Answer Markers, Add Missing Answer Markers (without Spaces),
'       Combine Consecutive Headers)

    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(BURST_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "&Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the marked records back to the Qvidian created document.", True
    AddButton SantCommandBar, "&Prev", "modToolbarActions.PreviousParagraph", "Move to the previous paragraph.", True
    AddButton SantCommandBar, "&Next", "modToolbarActions.NextParagraph", "Move to the next paragraph.", True
    AddSmartMarkingToggle SantCommandBar
    AddButton SantCommandBar, "&Header", "modToolbarActions.MarkHeaderClick", "Header", True
    AddButton SantCommandBar, "&Question", "modToolbarActions.MarkDescriptionClick", "Question", True
    AddButton SantCommandBar, "&Answer", "modToolbarActions.MarkContentClick", "Answer", True
    AddButton SantCommandBar, "&Table", "modToolbarActions.MarkFeatureMatrixClick", "Mark Table", True
    AddButton SantCommandBar, "&Remove", "modToolbarActions.RemoveSelectedMarkers", "Remove", True
    AddBurstMarkingPopUp SantCommandBar, "&Tools"
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateBulkloadToolbar()
'Bulk Load (8.3): Prev, Next, SmartMarking Enabled/Disabled, Question, Answer, Remove, Tools, Finished, Cancel, Help
'   Tools (Advanced SmartMarking Options, Clear All Markings, Convert Table to Text, Insert Edit Replace Code,
'       Select Style Template, Combine Consecutive Answers, Specify Destination Category)

    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(BULKLOAD_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the marked content to the Qvidian Library.", True
    AddButton SantCommandBar, "&Prev", "modToolbarActions.PreviousParagraph", GetTemplateString("Bulkload_Toolbar_Prev_TipText"), True
    AddButton SantCommandBar, "&Next", "modToolbarActions.NextParagraph", GetTemplateString("Bulkload_Toolbar_Next_TipText"), True
    AddSmartMarkingToggle SantCommandBar
    AddButton SantCommandBar, "&Description", "modToolbarActions.MarkDescriptionClick", GetTemplateString("Bulkload_Toolbar_Question_TipText"), True
    AddButton SantCommandBar, "&Content", "modToolbarActions.MarkContentClick", GetTemplateString("Bulkload_Toolbar_Answer_TipText"), True
    AddButton SantCommandBar, "&Remove", "modToolbarActions.RemoveSelectedMarkers", GetTemplateString("Bulkload_Toolbar_Remove_TipText"), True
    AddBulkloadMarkingPopUp SantCommandBar, "&Tools"
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CloseClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateContentToolbar()
'Content Edit (8.3): Tools (Insert Edit Replace Code, Insert File Gallery Item, Select Style Template), Finished, Cancel, Help
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(CONTENT_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the latest changes back to the Qvidian created document.", True
    AddContentEditToolsPopUp SantCommandBar, "&Tools"
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateStructureToolbar()
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(STRUCTURE_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the latest changes back to the Qvidian created document.", True
    AddButton SantCommandBar, "Mark Repeating Section", "modToolbarActions.MarkRepeatingSection", "Mark the selected text as a repeating section.", True
    AddButton SantCommandBar, "Clear Markers", "modToolbarActions.ClearRepeatingSections", "Clear existing markers.", True
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateRFPTeamToolbar()
'RFP Team Edit (8.3): Prev, Next, View (Details, Compliance Matrix Info, Preview Without Markers),
'   Tools (Formatting, Insert Edit Replace Code, Email Selected Question, Save and Keep Working),
'   Search (Keyword Search, Advanced Keyword Search, Smart Index Search, Advanced Smart Index Search,
'       Browse Database, File Gallery),
'   Submit (Quick Submit, Review and Submit), Finished, Cancel, Help
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(RFPTEAM_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the latest changes back to the Qvidian created document.", True
    AddButton SantCommandBar, "&Prev", "modToolbarActions.PrevButton", GetTemplateString("Bulkload_Toolbar_Prev_TipText"), True
    AddButton SantCommandBar, "&Next", "modToolbarActions.NextButton", GetTemplateString("Bulkload_Toolbar_Next_TipText"), True
    AddRFPTeamToolsPopUp SantCommandBar, "&Tools"
    AddButton SantCommandBar, "Search", "modToolbarActions.BasicSearchClick", "Basic Search", True
    ' US2627: MOLO 12/05/2016
    'AddButton SantCommandBar, "Advanced Search", "modToolbarActions.AdvancedSearchClick", "Search", True
    AddButton SantCommandBar, "Library", "modToolbarActions.LibraryClick", "Browse the Content Library", True
    AddButton SantCommandBar, "Submit", "modToolbarActions.SubmitClick", "Submit", True
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateRFPTeamReadOnlyToolbar()
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(RFPTEAMVIEW_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "&Prev", "modToolbarActions.PrevButton", GetTemplateString("Bulkload_Toolbar_Prev_TipText"), True
    AddButton SantCommandBar, "&Next", "modToolbarActions.NextButton", GetTemplateString("Bulkload_Toolbar_Next_TipText"), True
    AddRFPTeamToolsReadOnlyPopUp SantCommandBar, "&Tools"
    AddButton SantCommandBar, "Submit", "modToolbarActions.SubmitClick", "Submit", True
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateRFPIndividualToolbar()
'RFP Individual Edit (8.3): Tools (Insert Edit Replace Code, Email Selected Question, Save and Keep Working),
'   Search (Keyword Search, Advanced Keyword Search, Smart Index Search, Advanced Smart Index Search,
'       Browse Database, File Gallery), Submit (Quick Submit, Review and Submit),
'   Finished, Cancel, Help
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(RFPINDIVIDUAL_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the latest changes back to the Qvidian created document.", True
    AddRFPIndividualToolsPopUp SantCommandBar, "&Tools"
    AddButton SantCommandBar, "Search", "modToolbarActions.BasicSearchClick", "Basic Search", True
    ' US2627: MOLO 12/05/2016
    'AddButton SantCommandBar, "Advanced Search", "modToolbarActions.AdvancedSearchClick", "Search", True
    AddButton SantCommandBar, "Library", "modToolbarActions.LibraryClick", "Browse the Content Library", True
    AddButton SantCommandBar, "Submit", "modToolbarActions.SubmitClick", "Submit", True
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateFileListToolbar()
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(FILELIST_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the latest changes back to the Qvidian created document.", True
    AddButton SantCommandBar, "Insert Field", "modToolbarActions.EditReplaceClick", GetTemplateString("Full_Edit_Toolbar_EditReplace_TipText"), True
    AddButton SantCommandBar, "Submit", "modToolbarActions.SubmitClick", "Submit", True
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CancelClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub
    
Private Sub CreateViewToolbar()
'View (8.3): Cancel, Select Style Template, Help
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(VIEW_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Select Style Template", "modToolbarActions.SelectTemplate", GetTemplateString("Edit_Toolbar_SelectTemplate_TipText"), True
    AddButton SantCommandBar, "&Cancel", "modToolbarActions.CloseClick", "", True
    AddHelpPopUp SantCommandBar, "&Help"
End Sub

Private Sub CreateGenericToolbar()
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(WORD_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SelectAndSubmit", "Save the latest changes back to the Qvidian created document.", True
    AddButton SantCommandBar, "Select Style Template", "modToolbarActions.SelectTemplate", GetTemplateString("Edit_Toolbar_SelectTemplate_TipText"), True
    AddButton SantCommandBar, "Bulk Load", "modToolbarActions.SwitchToBulkLoad", GetTemplateString("Edit_Toolbar_SelectTemplate_TipText"), True
    'AddButton SantCommandBar, "&Cancel", "modToolbarActions.CloseClick", "", True
    AddHelpPopUp SantCommandBar, "&Help", True
    'May need a non-searching option.
End Sub

Private Sub CreatePostBuildToolbar()
'Post Build (8.3): ???
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = CreateCommandBar(POSTBUILD_TOOLBAR)
    AddBranding SantCommandBar
    AddButton SantCommandBar, "Save to Qvidian", "modToolbarActions.SaveToSantSuite", "Save the latest changes back to the Qvidian created document.", True
    'AddButton SantCommandBar, "&Cancel", "modToolbarActions.CloseClick", "", True
    AddButton SantCommandBar, "Help", "modToolbarActions.HelpClick", "", True
End Sub

'***********
'SUB-MENUS

Private Sub AddHelpPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String, Optional bSelectServer As Boolean = False)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
    AddButton oPopUp, "Help", "modToolbarActions.HelpClick", "", False
    AddButton oPopUp, "Qvidian Support", "modToolbarActions.SantSupportClick", "", False
    If bSelectServer Then
        AddButton oPopUp, "Select Server", "modToolbarActions.SelectServerClick", "", True
    End If
    AddButton oPopUp, "About", "modToolbarActions.SantAboutClick", "", False
End Sub

Private Sub AddContentEditToolsPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
    AddButton oPopUp, "Insert Field", "modToolbarActions.EditReplaceClick", GetTemplateString("Edit_Toolbar_EditReplace_TipText")
    ' US2627: MOLO 12/05/2016
    'AddButton oPopUp, "Insert Library Reference", "modToolbarActions.InsertLibraryReference", GetTemplateString("Edit_Toolbar_FileGallery_TipText")
    'If SantData.CallingPage.CanChangeTemplate Then
        AddButton oPopUp, "Select Style Template", "modToolbarActions.SelectTemplate", GetTemplateString("Edit_Toolbar_SelectTemplate_TipText")
    'End If
End Sub

Private Function AddSmartMarkingToggle(ByRef thisParentObject As Object) As Object
    Dim oCombo As CommandBarComboBox
    Set oCombo = thisParentObject.Controls.Add(msoControlComboBox)
    oCombo.BeginGroup = True
    oCombo.Style = msoComboLabel
    oCombo.width = "120"

    oCombo.AddItem "SmartMarking On", 1
    oCombo.AddItem "SmartMarking Off", 2

    oCombo.Text = oCombo.List(1)
End Function

Private Sub AddBurstMarkingPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
'   Tools (Advanced SmartMarking Options, Clear All Markings, Mark Selected Row as Header, Mark Selected Row as Question.
'       Mark All Table Rows as Questions, Add Missing Answer Markers, Add Missing Answer Markers (without Spaces),
'       Combine Consecutive Headers)
    AddButton oPopUp, "Advanced SmartMarking Options", "modToolbarActions.ShowSmartMarkingScreen", "~"
    AddButton oPopUp, "Clear All Markings", "modToolbarActions.RemoveAllMarkerBars", "~"
    AddButton oPopUp, "Mark Selected Row as Header", "modToolbarActions.MarkHeaderRowClick", "~", True
    AddButton oPopUp, "Mark Selected Row as Question", "modToolbarActions.MarkQuestionRowClick", "~"
    AddButton oPopUp, "Mark All Table Rows as Questions", "modToolbarActions.MarkQuestionRowsClick", "~"
    AddButton oPopUp, "Add Missing Answer Markers", "modToolbarActions.AddMissingAnswerMarkersClick", "~", True
    AddButton oPopUp, "Add Missing Answer Markers (without Spaces)", "modToolbarActions.AddMissingAnswersNoSpacesClick", "~"
    AddButton oPopUp, "Combine Consecutive Headers", "modToolbarActions.CombineHeadersClick", "~", True
    AddButton oPopUp, "Combine Consecutive Answers", "modToolbarActions.CombineAnswersClick", "~", False
End Sub

Private Sub AddBulkloadMarkingPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String)
'   Tools (Advanced SmartMarking Options, Clear All Markings, Convert Table to Text, Insert Edit Replace Code,
'       Select Style Template, Combine Consecutive Answers, Specify Destination Category)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
    AddButton oPopUp, "Advanced SmartMarking Options", "modToolbarActions.ShowSmartMarkingScreen", GetTemplateString("Bulkload_Toolbar_SmartMarking_TipText")
    AddButton oPopUp, "&Clear All Markings", "modToolbarActions.RemoveAllMarkerBars", GetTemplateString("Bulkload_Toolbar_ClearAll_TipText")
    AddButton oPopUp, "Convert Table to &Text", "modToolbarActions.ConvertSelectedTablesToText", GetTemplateString("Bulkload_Toolbar_TableToText_TipText")
    AddButton oPopUp, "Insert Field", "modToolbarActions.EditReplaceClick", GetTemplateString("Edit_Toolbar_EditReplace_TipText")
    AddButton oPopUp, "Select Style Template", "modToolbarActions.SelectTemplate", GetTemplateString("Edit_Toolbar_SelectTemplate_TipText")
    AddButton oPopUp, "Combine Consecutive Content Items", "modToolbarActions.CombineAnswersClick", "~", True
End Sub

Private Sub AddRFPTeamToolsPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
    AddButton oPopUp, "Formatting", "modToolbarActions.Formatting", GetTemplateString("Full_Edit_Toolbar_Formatting_TipText")
    AddButton oPopUp, "Insert Field", "modToolbarActions.EditReplaceClick", GetTemplateString("Full_Edit_Toolbar_EditReplace_TipText")
    AddButton oPopUp, "Email Selected Question", "modToolbarActions.EmailSelectedQuestion", GetTemplateString("Full_Edit_Toolbar_Email_TipText")
    AddButton oPopUp, "Preview Without Markers", "modToolbarActions.PreviewWithoutMarkers", GetTemplateString("Full_Edit_Toolbar_Preview_TipText")
End Sub

Private Sub AddRFPTeamToolsReadOnlyPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
    AddButton oPopUp, "Formatting", "modToolbarActions.Formatting", GetTemplateString("Full_Edit_Toolbar_Formatting_TipText")
    AddButton oPopUp, "Email Selected Question", "modToolbarActions.EmailSelectedQuestion", GetTemplateString("Full_Edit_Toolbar_Email_TipText")
    AddButton oPopUp, "Preview Without Markers", "modToolbarActions.PreviewWithoutMarkers", GetTemplateString("Full_Edit_Toolbar_Preview_TipText")
End Sub

Private Sub AddRFPIndividualToolsPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String)
    Dim oPopUp As CommandBarPopup
    Set oPopUp = AddPopUp(thisParentObject, thisCaption)
    AddButton oPopUp, "Insert Field", "modToolbarActions.EditReplaceClick", GetTemplateString("Full_Edit_Toolbar_EditReplace_TipText")
    AddButton oPopUp, "Email Selected Question", "modToolbarActions.EmailSelectedQuestion", GetTemplateString("Full_Edit_Toolbar_Email_TipText")
End Sub

'************
'STANDARD CODE

Public Sub RemoveToolbar(ByVal thisToolbarName As String)
    On Error Resume Next
    Dim SantCommandBar As CommandBar
    Set SantCommandBar = ActiveDocument.CommandBars(thisToolbarName)
    If Not SantCommandBar Is Nothing Then
        SantCommandBar.Enabled = False
        SantCommandBar.visible = False
        SantCommandBar.Delete
    End If
End Sub

Private Function CreateCommandBar(ByVal thisName As String) As CommandBar
    Dim NewCommandBar As CommandBar

    On Error Resume Next
    ActiveDocument.CommandBars(thisName).Delete
    On Error GoTo ErrorHandler
    
    Set NewCommandBar = ActiveDocument.CommandBars.Add(thisName, msoBarTop, False, False)
    NewCommandBar.visible = True

    Set CreateCommandBar = NewCommandBar
    Exit Function
ErrorHandler:
    MsgBox Err.Number & " " & Err.description
End Function

Private Sub AddBranding(ByRef thisParentObject As Object)
    If getVersion >= 10 Then
        AddPictureButton thisParentObject, True
    End If
End Sub

Private Function AddPictureButton(ByRef thisParentObject As Object, Optional ByVal InsertLine As Boolean = False) As Object
    Dim sLocalPath As String
    Dim picPicture As IPictureDisp

    Dim oButton As Object 'CommandBarButton 'Making generic, so it will compile in Office 2000.
    Set oButton = thisParentObject.Controls.Add(msoControlButton)
    oButton.BeginGroup = InsertLine
    oButton.Style = msoButtonAutomatic

    'Check if the logo file exists.  If not download it.  Then set it as the button's picture.
    sLocalPath = ActiveDocument.AttachedTemplate.path & "\Logo.bmp"
    Set picPicture = stdole.StdFunctions.LoadPicture(sLocalPath)
    oButton.picture = picPicture
    
    'Check if the logo mask file exists.  If not download it.  Then set it as the button's mask picture.
    'H:\NewTemplateWork
    sLocalPath = ActiveDocument.AttachedTemplate.path & "\LogoMask.bmp"
    Set picPicture = stdole.StdFunctions.LoadPicture(sLocalPath)
    oButton.Mask = picPicture

    Set AddPictureButton = oButton
End Function

Private Function AddButton(ByRef thisParentObject As Object, ByVal thisCaption As String, ByVal thisAction As String, Optional ByVal thisTipText As String = "", Optional ByVal InsertLine As Boolean = False) As Object
    Dim oButton As CommandBarButton
    Set oButton = thisParentObject.Controls.Add(msoControlButton)
    oButton.BeginGroup = InsertLine
    oButton.Style = msoButtonCaption
    oButton.caption = thisCaption
    oButton.OnAction = thisAction
    oButton.TooltipText = thisTipText
    Set AddButton = oButton
End Function

Private Function AddPopUp(ByRef thisParentObject As Object, ByVal thisCaption As String) As Object
    Dim oPopUp As CommandBarPopup
    Set oPopUp = thisParentObject.Controls.Add(MsoControlType.msoControlPopup)
    oPopUp.BeginGroup = True
    oPopUp.caption = thisCaption
    oPopUp.visible = True
    Set AddPopUp = oPopUp
End Function

Private Function GetTemplateString(ByVal thisString As String) As String
    GetTemplateString = thisString
End Function

Public Function RepeatMarkersChecked() As Boolean
    Dim oControl As Object
    Dim toolbarName As String
    If CommandBars(BURST_TOOLBAR).visible = True Then
        toolbarName = BURST_TOOLBAR
    ElseIf CommandBars(BULKLOAD_TOOLBAR).visible = True Then
        toolbarName = BULKLOAD_TOOLBAR
    End If
    
    If toolbarName <> "" Then
        For Each oControl In CommandBars(toolbarName).Controls
            If oControl.Type = msoControlComboBox Then
                If oControl.ListIndex = 1 Then
                    RepeatMarkersChecked = True
                Else
                    RepeatMarkersChecked = False
                End If
            End If
        Next oControl
    End If
End Function

'___+_+_+_+_+_+_+

'Public Sub RunAfterSigning()
'    On Error Resume Next
'    Dim cc As Object
'    Set cc = Application.CustomizationContext
'    Set Application.CustomizationContext = ActiveDocument
'    ActiveDocument.CommandBars(COMMAND_BAR_NAME).Visible = True
'    Application.CustomizationContext = cc
'End Sub

'Public Sub UpdateToolbar(ByRef thisDoc As Document, ByVal thisCaption As String, ByVal thisText As String, ByVal thisTipText As String)
'    Dim oControl As CommandBarControl
'    For Each oControl In thisDoc.CommandBars(COMMAND_BAR_NAME).Controls
'        If oControl.Caption = thisCaption Then
'            oControl.Caption = thisText
'            oControl.TooltipText = thisTipText
'            'Exit For
'        End If
'    Next oControl
'End Sub





'BurstBulkloadEdit_Toolbar_Help Qvidian Help
'BurstBulkloadEdit_Toolbar_About About Qvidian
'BurstBulkloadEdit_Toolbar_WordHelp Word Help

'Burst_Toolbar_Prev &Prev
'Burst_Toolbar_Next &Next
'Burst_Toolbar_Header &Header
'Burst_Toolbar_Question &Question
'Burst_Toolbar_Answer &Answer
'Burst_Toolbar_FeatureMatrix Feature &Matrix
'Burst_Toolbar_Remove &Remove
'Burst_Toolbar_Tools &Tools
'Burst_Toolbar_Finished &Finished
'Burst_Toolbar_Cancel &Cancel
'Burst_Toolbar_Help &Help
'Burst_Toolbar_SmartMarking &Smart Mark
'Burst_Toolbar_ClearAll &Clear All Markings
'Burst_Toolbar_HeaderRow Mark Selected Row as a &Header
'Burst_Toolbar_QuestionRow Mark Selected Row as a &Question
'Burst_Toolbar_MarkRowsAsQuestions Mark All &Table Rows as Questions
'Burst_Toolbar_AddMissingAnswers Add Missing &Answer Markers

'Edit_Toolbar_Tools &Tools
'Edit_Toolbar_Finished &Finished
'Edit_Toolbar_Cancel &Cancel
'Edit_Toolbar_Help &Help
'Edit_Toolbar_EditReplace Insert Edit Replace Code
'Edit_Toolbar_FileGallery Insert File Gallery Item

'View_Toolbar_Cancel &Cancel
'View_Toolbar_Help &Help

'FULL EDIT - WORD
'POWERPOINT
'EXCEL



'Public Sub AddSingleEditToolbar()
'    Dim SantCommandBar As CommandBar
'    Set SantCommandBar = CreateCommandBar("Sant Suite - Edit")
'    AddBranding SantCommandBar
'    AddGenericToolsPopUp SantCommandBar, GetTemplateString("Word_Toolbar_Menu_Tools")
'    AddButton SantCommandBar, GetTemplateString("Edit_Toolbar_Finished_Caption"), "FinishedButton", GetTemplateString("Edit_Toolbar_Finished_TipText"), True
'    AddButton SantCommandBar, GetTemplateString("Edit_Toolbar_Cancel_Caption"), "CancelButton", GetTemplateString("Edit_Toolbar_Cancel_TipText"), True
'    AddHelpPopUp SantCommandBar, GetTemplateString("Word_Toolbar_Menu_Help")
'End Sub

'Private Function GetToolbarTopSetting() As Long
'    'GetToolbarTopSetting = 1
'    GetToolbarTopSetting = SantData.CallingPage.GetToolbarTop
'End Function

'Private Function GetToolbarLeftSetting() As Long
'    'GetToolbarLeftSetting = 1
'    GetToolbarLeftSetting = SantData.CallingPage.GetToolbarLeft
'End Function
'
'Private Function GetToolbarPosition() As MsoBarPosition
'    'GetToolbarPosition = MsoBarPosition.msoBarTop
'    GetToolbarPosition = SantData.CallingPage.GetToolbarPosition
'End Function

'Private Function GetSearchPreference() As Integer
'    GetSearchPreference = SantData.CallingPage.GetSearchPreference
'End Function

'Private Function AddSearch(ByRef thisParentObject As Object, ByVal thisCaption As String, ByVal thisAction As String) As Object
'    Dim oCombo As CommandBarComboBox
'    Set oCombo = thisParentObject.Controls.Add(MsoControlType.msoControlComboBox)
'    oCombo.BeginGroup = True
'    oCombo.Style = msoComboLabel
'    oCombo.Width = "155"
'
'    Dim kMaxItem As Integer
'    kMaxItem = 6
'
'    oCombo.AddItem GetTemplateString("Word_Toolbar_Menu_Search_AutoKeyword"), 1
'    oCombo.AddItem GetTemplateString("Word_Toolbar_Menu_Search_AdvKeyword"), 2
'    oCombo.AddItem GetTemplateString("Word_Toolbar_Menu_Search_AutoFullText"), 3
'    oCombo.AddItem GetTemplateString("Word_Toolbar_Menu_Search_AdvFullText"), 4
'    oCombo.AddItem GetTemplateString("Word_Toolbar_Menu_Search_Browse"), 5
'    oCombo.AddItem GetTemplateString("Word_Toolbar_Menu_Search_FileGallery"), kMaxItem  ' increase kMaxItem if more items are needed
'    'oCombo.AddItem "Search External Source", 6
'
'    Dim SearchPreferenceIndex As Integer
'    SearchPreferenceIndex = GetSearchPreference
'    If SearchPreferenceIndex < 1 Or SearchPreferenceIndex > kMaxItem Then
'        SearchPreferenceIndex = 1
'    End If
'    oCombo.Text = oCombo.List(SearchPreferenceIndex)
'    SantData.SearchDropdownIndex = oCombo.Index
'
'    Set AddSearch = oCombo
'
'    'Add Search Button
'    Dim oButton As CommandBarButton
'    Set oButton = thisParentObject.Controls.Add(msoControlButton)
'    oButton.Style = msoButtonCaption
'    oButton.Caption = thisCaption
'    oButton.OnAction = thisAction
'    oButton.TooltipText = GetTemplateString("Full_Edit_Toolbar_Search_TipText")
'
'End Function

'Public Sub SaveToolbarSettings()
'    Dim SettingsString As String
'    SettingsString = ActiveDocument.CommandBars(SantData.CurrentToolbarName).Position & "|" & ActiveDocument.CommandBars(SantData.CurrentToolbarName).Top & "|" & ActiveDocument.CommandBars(SantData.CurrentToolbarName).Left & "||"
'    If SantData.lTemplateMode = TemplateModes.MODE_EDITINCONTEXT Or SantData.lTemplateMode = TemplateModes.MODE_EDITSINGLEUSERRFP Then
'        SettingsString = SettingsString & ActiveDocument.CommandBars(SantData.CurrentToolbarName).Controls(SantData.SearchDropdownIndex).ListIndex
'    End If
'
'    SantData.CallingPage.SetToolbarSettings SettingsString
'End Sub


Attribute VB_Name = "modToolbarActions"
Option Explicit: Option Base 1

Public Sub UpdateCredentials(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modWSTools.changeLoginCredentials (True)
End Sub

Public Sub EmailSelectedQuestion(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.CallEmail
End Sub

Public Sub Formatting(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    frmFormatting.Show vbModeless
End Sub

Public Sub CancelClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    'Call back into Qvidian, log in, call routine on Sant.js to cancel changes for specified type and IDs.
    If MsgBox("Are you sure you wish to cancel this edit?", vbOKCancel, "Qvidian") = vbOK Then
       modWS.CancelCheckout GetTemplateMode(ActiveDocument)
    End If
End Sub

Public Sub HelpClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.CallHelp
End Sub

Public Sub SantSupportClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.CallSantSupport
End Sub

Public Sub SantAboutClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.AboutClick
End Sub

Public Sub SelectServerClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    frmSelectServer.ShowSelections
End Sub

Public Sub ConvertSelectedTablesToText(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    Dim thisRange As Range

    Set thisRange = Selection.Range
    
    While Selection.Tables.count > 0
        Selection.Tables(1).ConvertToText wdSeparateByParagraphs
        thisRange.Select
    Wend
End Sub

Public Sub CloseClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    Dim thisDoc As Document
    Dim sMessage As String
    modInit.ActivateCurrent
    Set thisDoc = ActiveDocument
    If thisDoc.Saved = True Then
        sMessage = "Are you sure you wish to close this Word document?"
    Else
        sMessage = "Are you sure you wish to close this Word document and lose any unsaved changes?"
    End If
    
    If MsgBox(sMessage, vbOKCancel, "Qvidian") = vbOK Then
        CloseThisDoc ActiveDocument, ""
    End If
End Sub

Public Sub DeleteTemporaryContent(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    ' Two pieces to do here Qvidian\Temp and Qvidian\Temp\ServerName
    Dim delFolder As String
    delFolder = GetClientPath & "Temp\"
    If Not GetFileSystemObject.FolderExists(delFolder) Then GetFileSystemObject.CreateFolder (delFolder)
    DeleteFolderContent (delFolder)
    
    delFolder = delFolder & GetServerName(GetActiveDocument) & "\"
    If Not GetFileSystemObject.FolderExists(delFolder) Then GetFileSystemObject.CreateFolder (delFolder)
    DeleteFolderContent (delFolder)
    
    delFolder = GetClientBuildTempPath & "temp\"
    If Not GetFileSystemObject.FolderExists(delFolder) Then GetFileSystemObject.CreateFolder (delFolder)
    DeleteFolderContent (delFolder)
    
    delFolder = delFolder & GetServerName(GetActiveDocument) & "\"
    If Not GetFileSystemObject.FolderExists(delFolder) Then GetFileSystemObject.CreateFolder (delFolder)
    DeleteFolderContent (delFolder)
    
End Sub

Public Sub DeleteFolderContent(folder As Variant)
    Dim fl As File
    Dim fls As Files
    Dim Fldr As Scripting.folder
    
    Set Fldr = GetFileSystemObject.GetFolder(folder)
    Set fls = Fldr.Files
   
    On Error Resume Next
    For Each fl In fls
        fl.Delete True
    Next
    
    Set Fldr = Nothing
End Sub

Public Sub CombineHeadersClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.CombineConsecutiveHeaderMarkings
End Sub

Public Sub CombineAnswersClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.CombineConsecutiveAnswerMarkings
End Sub

Public Sub CombineQuestionsClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.CombineConsecutiveQuestionMarkings
End Sub

Public Sub MarkContentClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    
    StartProcess ActiveDocument, ActiveWindow
    If modRibbonNOCOPY.TEMPLATETYPE = 2003 Then
        If RepeatMarkersChecked = True Then
            SmartMarking.SMTypeToMark = ANSWER
            frmProgressBar.StartSmartMarking
        Else
            SmartMarking.InsertAnswerMarker
        End If
    Else
        SmartMarking.InsertAnswerMarker
    End If
    EndProcess ActiveDocument, ActiveWindow
End Sub

Public Sub SmartRemoveSelectedMarkers(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.SMTypeToMark = NONE
    frmProgressBar.StartSmartMarking
End Sub

Public Sub SmartMarkHeaderClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.SMTypeToMark = HEADER
    frmProgressBar.StartSmartMarking
End Sub

Public Sub SmartMarkContentClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.SMTypeToMark = ANSWER
    frmProgressBar.StartSmartMarking
End Sub

Public Sub SmartMarkDescriptionClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.SMTypeToMark = QUESTION
    frmProgressBar.StartSmartMarking
End Sub

Public Sub MarkDescriptionClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    
    If modRibbonNOCOPY.TEMPLATETYPE = 2003 Then
        If RepeatMarkersChecked = True Then
            SmartMarking.SMTypeToMark = QUESTION
            frmProgressBar.StartSmartMarking
        Else
            SmartMarking.InsertQuestionMarker
        End If
    Else
        SmartMarking.InsertQuestionMarker
    End If

End Sub

Public Sub MarkHeaderClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    
    If modRibbonNOCOPY.TEMPLATETYPE = 2003 Then
        If RepeatMarkersChecked = True Then
            SmartMarking.SMTypeToMark = HEADER
            frmProgressBar.StartSmartMarking
        Else
            SmartMarking.InsertHeaderMarker
        End If
    Else
        SmartMarking.InsertHeaderMarker
    End If
End Sub

Public Sub MarkFeatureMatrixClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.MarkSelectedTable
End Sub

Public Sub MarkHeaderRowClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.InsertHeaderRowMarker
End Sub

Public Sub MarkQuestionRowClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.InsertQuestionRowMarker
End Sub

Public Sub MarkQuestionRowsClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.MarkTableRowsAsQuestions
End Sub

Public Sub AddMissingAnswerMarkersClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.AddMissingAnswerMarkers True
End Sub

Public Sub AddMissingAnswersNoSpacesClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.AddMissingAnswerMarkers False
End Sub

Public Sub NextParagraph(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    Selection.Expand wdParagraph
    Selection.MoveDown wdParagraph, 1, wdMove
    If Selection.Information(wdWithInTable) Then
        Selection.Expand wdRow
    Else
        Selection.Expand wdParagraph
    End If
End Sub

Public Sub PreviousParagraph(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    Selection.Expand wdParagraph
    Selection.MoveUp wdParagraph, 2, wdMove
    If Selection.Information(wdWithInTable) Then
        Selection.Expand wdRow
    Else
        Selection.Expand wdParagraph
    End If
End Sub

Public Sub PrevButton(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    Dim bm As Bookmark
    Set bm = modTools.GetPrevBookmark(ActiveDocument, ActiveWindow)
    If Not bm Is Nothing Then
        modTools.SelectTextOfBookmark bm
    End If
End Sub

Public Sub NextButton(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    Dim bm As Bookmark
    Set bm = modTools.GetNextBookmark(ActiveDocument, ActiveWindow)
    If Not bm Is Nothing Then
        modTools.SelectTextOfBookmark bm
    End If
End Sub

Public Sub RemoveAllMarkerBars(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    SmartMarking.RemoveAllMarkerBars
End Sub

Public Sub RemoveSelectedMarkers(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    SmartMarking.SetReferences ActiveDocument, ActiveWindow
    
    If modRibbonNOCOPY.TEMPLATETYPE = 2003 Then
        If RepeatMarkersChecked = True Then
            SmartMarking.SMTypeToMark = NONE
            frmProgressBar.StartSmartMarking
        Else
            SmartMarking.RemoveAllSelectedMarkerBars
        End If
    Else
        SmartMarking.RemoveAllSelectedMarkerBars
    End If
End Sub

Public Sub ShowSmartMarkingScreen(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    frmAdvancedSmartMarking.Show vbModal
End Sub

Public Sub SaveToSantSuite(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    Dim tempMode As String
    tempMode = GetTemplateMode(ActiveDocument)
    
    If ActiveDocument.ActiveWindow.Panes.count > 1 Then
        MsgBox "Please close any open Word panes before saving.", vbOKOnly, "Qvidian"
        Exit Sub
    End If
    
    Select Case tempMode
        Case "SantWordBulkLoad"
            If ActiveDocument.Bookmarks.count > 0 Then
                Dim bookmarkFound As Boolean
                bookmarkFound = False
                Dim bm As Bookmark
                For Each bm In ActiveDocument.Bookmarks
                    If InStr(1, LCase(bm.name), "sant") Then
                        bookmarkFound = True
                        Exit For
                    End If
                Next bm

                If bookmarkFound = True Then
                    modWS.BulkLoadFile
                Else
                    MsgBox ("There were no Qvidian markers found. Please mark the file before attempting to save to Qvidian.")
                End If
            Else
                MsgBox ("There were no Qvidian markers found. Please mark the file before attempting to save to Qvidian.")
            End If
        Case "SantCompareContent", "SantRFPCompareContent"
            If MsgBox("This action can not be undone. Are you sure you wish to proceed?", vbYesNo, "Qvidian Alert") = vbYes Then
                modWS.SaveCopyWS tempMode
            End If
        Case "SantRFPFileWordEdit"
            Dim SavedBookmarkMap As String
            Dim hasMarkerErrors As Boolean
            SavedBookmarkMap = GetSavedBookmarkMap
            hasMarkerErrors = checkForMarkerErrors(ActiveDocument)
            If GetPropertyText("ForMarking", ActiveDocument) = "1" Then
                'Modify Markings - Proceed with save.
                modWS.SaveCopyWS tempMode
            ElseIf hasMarkerErrors Or (SavedBookmarkMap <> GetBookmarkMap And SavedBookmarkMap <> "") Then
                'RFP Edit, markers are out of place.  Prevent save.
                MsgBox "The Qvidian bookmarks appear to be out of place, and cannot be saved." & vbCrLf & vbCrLf & _
                    "This can happen if you attempt to re-order the RFP during an edit, manually delete a marker bar or bookmark, or accidentally paste over the marker bar." & vbCrLf & vbCrLf & _
                    "To preserve your work:" & vbCrLf & _
                    "  1) On the Qvidian tab, select Tools --> Preview Without Markers." & vbCrLf & _
                    "  2) Cancel the current RFP edit." & vbCrLf & _
                    "  3) Open a new RFP edit." & vbCrLf & _
                    "  4) Copy each modified answer and paste them AFTER the answer marker " & vbCrLf & _
                    "      bar in the RFP." & vbCrLf & _
                    "  5) When you're finished copying your answers, save to Qvidian."
            Else
                'RFP Edit, markers are in place.  Proceed with save.
                modWS.SaveCopyWS tempMode
            End If
        Case Else
            modWS.SaveCopyWS tempMode
    End Select
End Sub

Public Sub SelectAndSubmit(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.SubmitPartialFile
End Sub

Public Sub SubmitDocument(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.SubmitFile
End Sub

Public Sub ShowAdvancedSmartMarking(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    frmAdvancedSmartMarking.Show vbModal
End Sub

Public Sub SwitchToBulkLoad(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modDocProperties.WriteProperty "SantTemplateMode", "SantWordBulkLoad", ActiveDocument
    modToolbar.SwitchToolbars ActiveDocument
End Sub

Public Sub BasicSearchClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.Library LibraryModes.Basic
End Sub

Public Sub AdvancedSearchClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.Library LibraryModes.Advanced
End Sub

Public Sub LibraryClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.Library LibraryModes.Browse
End Sub

Public Sub SubmitClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    ' If we're doing an RFP, are Prosearch and don't have submit permissions,
    ' flag the user and don't let them continue.
    Dim currentTemplateMode As String
    currentTemplateMode = GetPropertyText("SantTemplateMode", ActiveDocument)
    DebugMsgBox "SantTemplateMode is " & currentTemplateMode
    If currentTemplateMode = "SantRFPFileWordEdit" Then
        Dim isPS As Boolean
        isPS = GetIsPS(ActiveDocument)
        DebugMsgBox "Is ProSearch is " & isPS
        If isPS Then
            Dim HasSubmitNew As String
            HasSubmitNew = GetPropertyText("HasSubmitNew", ActiveDocument)
            
            DebugMsgBox "HasSubmitNew is " & HasSubmitNew
            If HasSubmitNew <> "true" Then
                MsgBox "You do not have the required permissions to Submit the Answer to the Library, Please contact your Qvidian Administrator change this permission."
                Exit Sub
            End If
        End If
    End If
    modInit.ActivateCurrent
    modWS.SubmitPartialFile
End Sub

Public Sub MarkRepeatingSection(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modTools.MarkRepeater ActiveDocument, ActiveWindow
End Sub

Public Sub ClearRepeatingSections(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modTools.ClearRepeaters ActiveDocument, ActiveWindow
End Sub

Public Sub EditReplaceClick(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.ShowExtDialog MergeCodeDialog
End Sub

Public Sub SelectTemplate(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.ShowExtDialog WordTemplatesDialog
End Sub

Public Sub SelectTemplateForAll(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.ShowExtDialog WordTemplatesDialog, True
End Sub

Public Sub InsertLibraryReference(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    modInit.ActivateCurrent
    modWS.Library LibraryModes.LibraryReference
End Sub

Public Sub PreviewWithoutMarkers(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    Dim myDoc As Document
    Dim myWindow As Window
    Dim thisDoc As Document
    Dim thisWindow As Window
    Dim TempTable As Table
    Dim tempBookmark As Bookmark
    Dim name As String
    
    modInit.ActivateCurrent
    
    Set thisDoc = ActiveDocument
    Set thisWindow = ActiveWindow
    thisWindow.Selection.WholeStory
    thisWindow.Selection.Copy
    
    Set myDoc = Documents.Add
    myDoc.Activate
    
    modDocProperties.CopyProperty "Server", thisDoc, myDoc
    modDocProperties.CopyProperty "IsPS", thisDoc, myDoc
    
    Set myWindow = myDoc.ActiveWindow
    myWindow.Selection.Paste
    StartProcess myDoc, myWindow
    
    For Each TempTable In myDoc.Tables
        For Each tempBookmark In TempTable.Range.Bookmarks
            If Left(tempBookmark.name, 4) = "Sant" Then
                name = tempBookmark.name
                '2007/01/09 [JSB]: Delete the row instead of the whole table.
                myWindow.Selection.GoTo what:=wdGoToBookmark, name:=tempBookmark.name
                myWindow.Selection.Collapse wdCollapseStart
                myWindow.Selection.Rows(1).Delete
                If myDoc.Bookmarks.Exists(name) Then
                    tempBookmark.Delete
                End If
            End If
        Next tempBookmark
    Next TempTable
    
    'Remove extra paragraphs we added to split tables when saving.
    For Each tempBookmark In myDoc.Bookmarks
        If Left(tempBookmark.name, 22) = "deleteparagraphonbuild" Then
            If tempBookmark.Range = vbCrLf Or tempBookmark.Range = vbCr Or tempBookmark.Range = vbLf Then
                tempBookmark.Range.Delete
            Else
                tempBookmark.Delete
            End If
        End If
    Next tempBookmark
    
    EndProcess myDoc, myWindow
    myWindow.Selection.GoTo what:=wdGoToBookmark, name:="\StartOfDoc"
End Sub


Public Sub GlobalReplace(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    GlobalReplaceInternal True
End Sub

Public Sub GlobalReplaceAll(Optional ByVal control As Object = Nothing, Optional ByVal pressed As Boolean = True)
    GlobalReplaceInternal False
End Sub

'END DIRECT TOOLBAR CALLS

'BEGIN UTILITY CODE
Public Sub SaveAndContinue()
    Application.Dialogs(wdDialogFileSaveAs).Show
    Application.Dialogs(wdDialogFileSaveAs).Execute
End Sub

'WARNING: When modifying this code, remember that when you close the
'   document with the template attached, no more code will run.
Public Sub CloseThisDoc(ByRef thisDoc As Document, ByRef sMode As String)
    DebugMsgBox "Documents.count: result: [" & CStr(Documents.count) & "]", "CloseThisDoc:"
    DebugMsgBox "TemplateMode: " & sMode, "CloseThisDoc:"
    'Dim sMode As String

    'modInit.ActivateCurrent
    On Error Resume Next
    thisDoc.Saved = True
    thisDoc.AttachedTemplate.Saved = True
    If sMode = "SantCompareContent" Then
        If Documents.count = 1 Then
            Application.Quit wdPromptToSaveChanges
        Else
            thisDoc.Close
        End If
    Else
        If Documents.count = 1 Then
            Application.Quit wdPromptToSaveChanges
        Else
            thisDoc.Close
        End If
    End If
End Sub

Public Sub CloseDoc()
    CloseThisDoc ActiveDocument, ""
End Sub

Public Function SaveOrSaveAs(ByRef thisDoc As Document) As Boolean
On Error GoTo ErrorHandler
    'MsgBox "SaveOrSaveAs - Start"
    modInit.ActivateCurrent
    
    'Ensure Folder Exists (will be created as sTempPath)
    modTools.EnsureTempFolderExists
    
    'Save dest doc.
    Dim desiredExt As String
    desiredExt = modDocProperties.GetPropertyText("SubmitExtension", thisDoc)
    If Len(desiredExt) = 0 Then
        desiredExt = modTools.GetProperExtension(thisDoc)
    Else
        modDocProperties.RemoveProperty "SubmitExtension", thisDoc
    End If
    Dim savePath As String
    savePath = sTempPath & "Uploaded " & modTools.GetFileTimeStamp & "." & desiredExt
    thisDoc.SaveAs savePath
    
    'ActiveDocument.Save
    'MsgBox "SaveOrSaveAs - Saved"
    SaveOrSaveAs = True
    Exit Function
ErrorHandler:
    'MsgBox "SaveOrSaveAs - ErrorHandler"
    If Application.Dialogs(wdDialogFileSaveAs).Show = 0 Then
        SaveOrSaveAs = False
    Else
        Application.Dialogs(wdDialogFileSaveAs).Execute
        SaveOrSaveAs = True
    End If
End Function

'END UTILITY CODE

Attribute VB_Name = "modTools"
Option Explicit: Option Base 1

Private appVer As Integer
Public activeDocSettings As struct_DocSettings

#If Win64 Then
Private Declare PtrSafe Function GetLongPathName Lib "kernel32" Alias _
    "GetLongPathNameA" (ByVal lpszShortPath As String, _
    ByVal lpszLongPath As String, ByVal cchBuffer As Long) As Long
Public Declare PtrSafe Function GetActiveWindow Lib "user32" () As LongPtr
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Function GetLongPathName Lib "kernel32" Alias _
    "GetLongPathNameA" (ByVal lpszShortPath As String, _
    ByVal lpszLongPath As String, ByVal cchBuffer As Long) As Long
Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Public Declare Function GetActiveWindow Lib "user32" () As Long
#End If

Public Function GetLongPath(ByVal shortPath As String) As String
    Dim buffer As String
    Dim size As Integer
   
    buffer = Space(256)
    size = GetLongPathName(shortPath, buffer, Len(buffer))
    GetLongPath = Left(Trim(buffer), size)
End Function

Public Function UsingAttachedTemplate(ByRef thisDoc As Document) As Boolean
    If InStr(1, LCase(thisDoc.AttachedTemplate), "qvidian.dot") > 0 Then
        UsingAttachedTemplate = True
    Else
        UsingAttachedTemplate = False
    End If
End Function

Public Sub CloseLaunchDoc()
    Dim d As Document
    For Each d In Application.Documents
        If modDocProperties.GetPropertyText("CloseMe", d) = "1" Then
            d.AttachedTemplate.Saved = True
            Application.NormalTemplate.Saved = True
            d.Saved = True
            DoEvents
            If Application.Documents.count > 1 Then
                d.Close wdDoNotSaveChanges
            Else
                Application.Quit wdDoNotSaveChanges
            End If
        End If
    Next d
End Sub

Public Sub BulkLoadPrepForAspose()
    Dim t As Table
    Dim b As Bookmark
    Dim myStr As String
    Dim myArray() As String
    Dim i As Integer
    Dim bFirst As Boolean
    bFirst = True

    ' Build list of all Sant bookmarks in order of location
    For Each t In ActiveDocument.Tables
        For Each b In t.Range.Bookmarks
            If b.Start >= t.Range.Start Then
                If Left(b.name, 4) = "Sant" Then
                   If bFirst Then
                        bFirst = False
                        myStr = myStr & b.name
                    Else
                        myStr = myStr & "|" & b.name
                    End If
                End If
            End If
        Next
    Next

    ' Set End for each Sant bookmark
    If Len(myStr) > 0 Then
        myArray = Split(myStr, "|")
        For i = LBound(myArray) To UBound(myArray) - 1
            ActiveDocument.Bookmarks(myArray(i)).End = ActiveDocument.Bookmarks(myArray(i + 1)).Start
            ActiveDocument.UndoClear
        Next i
        ' Mark End of last bookmark
        ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).InsertParagraphAfter
        ActiveDocument.Bookmarks(myArray(UBound(myArray))).End = ActiveDocument.Range.End - 1
        'ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Delete
    End If
End Sub

Public Sub SelectRecord(ByVal sSelectedMappingInfo As String, Optional ByVal bWholeAnswer As Boolean = False)
    Dim lSelStart As Long
    Dim lSelEnd As Long

    If ActiveDocument.Range.Bookmarks(sSelectedMappingInfo).Start <> ActiveDocument.Range.Bookmarks(sSelectedMappingInfo).End Then
        ActiveDocument.Range.Bookmarks(sSelectedMappingInfo).Select
        
        If InStr(1, sSelectedMappingInfo, "Answer") > 0 And Not bWholeAnswer Then
            Selection.Collapse wdCollapseStart
            Selection.MoveDown wdParagraph, 1
            Selection.MoveRight wdCharacter, 1
        End If
        
    End If
    
End Sub

Public Function GetUserID(ByRef thisDoc As Document) As String
    On Error GoTo ErrorHandler
    GetUserID = modDocProperties.GetPropertyText("UserID", thisDoc)
    Exit Function
ErrorHandler:
    GetUserID = ""
End Function

Public Function GetRFPFileID(ByRef thisDoc As Document) As String
    On Error GoTo ErrorHandler
    GetRFPFileID = modDocProperties.GetPropertyText("RFPFileID", thisDoc)
    Exit Function
ErrorHandler:
    GetRFPFileID = "-1"
End Function

Public Function GetMiscFileID(ByRef thisDoc As Document) As String
    On Error GoTo ErrorHandler
    GetMiscFileID = modDocProperties.GetPropertyText("MiscFileID", thisDoc)
    Exit Function
ErrorHandler:
    GetMiscFileID = "-1"
End Function

Public Function GetContentID(ByRef thisDoc As Document) As String
    On Error GoTo ErrorHandler
    GetContentID = modDocProperties.GetPropertyText("ContentID", thisDoc)
    Exit Function
ErrorHandler:
    GetContentID = "-1"
End Function

Public Function GetContentIDs(ByRef thisDoc As Document) As String
    On Error GoTo ErrorHandler
    Dim ContentIDList As String
    Dim bk As Bookmark
    For Each bk In thisDoc.Bookmarks
        If InStr(1, bk.name, "ContentExport_") > 0 Then
            If ContentIDList = "" Then
                ContentIDList = Replace(bk.name, "ContentExport_", "")
            Else
                ContentIDList = ContentIDList & "," & Replace(bk.name, "ContentExport_", "")
            End If
        End If
    Next bk
    GetContentIDs = ContentIDList
    Exit Function
ErrorHandler:
    GetContentIDs = ""
End Function

Public Function GetSearchText() As String
    If Selection.Start = Selection.End Then
        Dim bm As Bookmark
        Set bm = modTools.GetCurrentSantBookmark(ActiveDocument, ActiveWindow)
        If TypeName(bm) <> "Nothing" Then
            SelectTextOfBookmark bm
        ElseIf Selection.Information(wdWithInTable) Then
            Selection.Expand wdRow
        Else
            Selection.Expand wdParagraph
        End If
    End If
    GetSearchText = RemoveNonPrintingCharacters(Selection.Text)
End Function

Public Function RemoveNonPrintingCharacters(ByVal thisText As String) As String
    Dim WorkingString As String
    Dim CharCode As Long
    WorkingString = thisText

    If WorkingString <> "" Then
        'Remove any non-printing characters
        For CharCode = 0 To 31
            WorkingString = Replace(WorkingString, Chr(CharCode), Space(1))
        Next
    End If
    RemoveNonPrintingCharacters = WorkingString
End Function

'TODO: Fix this to select whole marked record.
Public Sub SelectTextForSubmit(ByRef thisDoc As Document, ByRef thisWin As Window)
    Dim bm As Bookmark
    Dim bmA As Bookmark
    Dim searchDoc As Boolean
    searchDoc = False
    
    DebugMsgBox "Selection.Text: " & thisWin.Selection.Text, "SelectTextForSubmit:"
    If Len(thisWin.Selection.Text) < 3 Then
        DebugMsgBox "Selection.Bookmakrs.count: " & thisWin.Selection.Bookmarks.count, "SelectTextForSubmit:"
        If thisWin.Selection.Bookmarks.count > 0 Then
            For Each bm In thisWin.Selection.Bookmarks
                DebugMsgBox "Selection - bm.name: " & bm.name, "SelectTextForSubmit:"
                If InStr(1, bm.name, "Sant") Then
                    If InStr(1, bm.name, "SantHeader") Then
                        searchDoc = True
                        Exit For
                    End If
                    'Defect #6485. Select only Answer text
                    If InStr(1, bm.name, "SantQuestion") Then
                        Set bmA = GetNextBookmark(thisDoc, thisWin)
                    End If
                    If InStr(1, bm.name, "SantAnswer") Then
                        Set bmA = bm
                    End If
                    DebugMsgBox "Selection - bmA.Start: " & bmA.Start & " and bmA.En: " & bmA.End, "SelectTextForSubmit:"
                    If bmA.Start <> bmA.End Then
                        SelectTextOfBookmark bmA
                        Exit Sub
                    End If
                End If
            Next bm
        Else
            searchDoc = True
        End If
        
        DebugMsgBox "searchDoc: " & searchDoc & " ", "SelectTextForSubmit:"
        If searchDoc Then
            'No Bookmark selected.  Use the first one
            For Each bm In thisDoc.Bookmarks
                DebugMsgBox "DOC - bm.name: " & bm.name, "SelectTextForSubmit:"
                If InStr(1, bm.name, "SantAnswer") Then
                   If bm.Start <> bm.End Then
                        SelectTextOfBookmark bm
                      Exit Sub
                   End If
                End If
            Next bm
        End If
        If thisWin.Selection.Information(wdWithInTable) Then
            thisWin.Selection.Expand wdTable
        Else
            thisWin.Selection.Expand wdParagraph
        End If
    End If
End Sub

Public Function FindCurrentMarker() As String
    Dim bContinue As Boolean
    Dim tempBookmark As Bookmark
    bContinue = True
    Selection.Collapse wdCollapseStart
    While bContinue
        'Looping upwards in the document, if we reach the top, do this one last check and then exit.
        If Selection.Bookmarks.Exists("\StartOfDoc") Then
            bContinue = False
        End If
        If Selection.Information(wdWithInTable) Then
            Selection.Expand wdRow
            For Each tempBookmark In Selection.Range.Bookmarks
                If Left(tempBookmark.name, 4) = "Sant" Then
                    FindCurrentMarker = tempBookmark.name
                    Exit Function
                End If
            Next tempBookmark
            Selection.MoveUp wdParagraph, 2
        Else
            Selection.Collapse wdCollapseStart
            Selection.MoveUp wdParagraph, 1
            Selection.Expand wdParagraph
        End If
    Wend
End Function

Public Sub MarkRepeater(ByRef thisDoc As Document, ByRef thisWindow As Window)
    Dim i As Integer
    Dim bm As Bookmark
    Dim bmNameParts() As String
    i = 0
    If thisWindow.Selection.Start = thisWindow.Selection.End Then
        If Selection.Information(wdWithInTable) Then
            Selection.Expand (wdRow)
        Else
            Selection.Expand (wdParagraph)
        End If
    End If
    For Each bm In thisDoc.Bookmarks
        If InStr(1, bm.name, "ss_repeat_") > 0 Then
            If (bm.Start < thisWindow.Selection.Start And bm.End <= thisWindow.Selection.Start) Or _
                (bm.Start >= thisWindow.Selection.End And bm.End > thisWindow.Selection.End) Then
                
                bmNameParts = Split(bm.name, "_")
                If CInt(bmNameParts(UBound(bmNameParts))) > i Then
                    i = CInt(bmNameParts(UBound(bmNameParts)))
                End If
            Else
                bm.Delete
            End If
        End If
    Next bm
    i = i + 1
    thisWindow.Selection.Bookmarks.Add "ss_repeat_" & i
End Sub

Public Sub ClearRepeaters(ByRef thisDoc As Document, ByRef thisWindow As Window)
    Dim bm As Bookmark
    For Each bm In thisDoc.Bookmarks
        If InStr(1, bm.name, "ss_repeat_") > 0 Then
            bm.Delete
        End If
    Next bm
End Sub

Public Sub SelectTextOfBookmark(ByRef thisBookmark As Bookmark)
    ActiveDocument.Range(thisBookmark.Range.Tables(1).Range.End, thisBookmark.End).Select
End Sub

Public Function GetCurrentSantBookmark(ByRef thisDoc As Document, ByRef thisWindow As Window) As Bookmark
    Dim bm As Bookmark
    Dim foundBm As Bookmark
    DebugMsgBox "Selection.Bookmarks.count: " & Selection.Bookmarks.count, "GetCurrentSantBookmark:"
    If Selection.Bookmarks.count > 0 Then
        For Each bm In Selection.Range.Bookmarks
            DebugMsgBox "bm.name: [" & bm.name & "]", "GetCurrentSantBookmark:"
            If Left(bm.name, 4) = "Sant" Then
                Set foundBm = bm
                Exit For
            End If
        Next bm
    End If
    Set GetCurrentSantBookmark = foundBm
End Function

Public Function GetPrevBookmark(ByRef thisDoc As Document, ByRef thisWindow As Window) As Bookmark
    Dim currentBM As Bookmark
    Set currentBM = GetCurrentSantBookmark(thisDoc, thisWindow)
    Set GetPrevBookmark = currentBM
    If currentBM Is Nothing Then
        Exit Function
    End If
    
    Dim bm As Bookmark
    For Each bm In thisDoc.Bookmarks
        If bm.End = currentBM.Start Then
            Set GetPrevBookmark = bm
            Exit Function
        End If
    Next bm
    Set GetPrevBookmark = currentBM
End Function

Public Function GetNextBookmark(ByRef thisDoc As Document, ByRef thisWindow As Window) As Bookmark
    Dim currentBM As Bookmark
    Set currentBM = GetCurrentSantBookmark(thisDoc, thisWindow)
    Set GetNextBookmark = currentBM
    If currentBM Is Nothing Then
        Exit Function
    End If
    
    Dim bm As Bookmark
    For Each bm In thisDoc.Bookmarks
        If bm.Start = currentBM.End Then
            Set GetNextBookmark = bm
            Exit Function
        End If
    Next bm
    Set GetNextBookmark = currentBM
End Function

Public Sub PrepareForSave(sMode As String, ByRef thisDocument As Document, ByRef thisWindow As Window)
    DebugMsgBox "PrepareForSave: sMode is " & sMode
    Select Case sMode
        Case "SantWordMultiEdit"
            FixMultiEditBookmarks thisDocument, thisWindow
            'Ensure bookmarks are placed properly.
        Case "SantWordEdit"
            '???
        Case "SantWordBulkLoad"
            PrepareForBulkload thisDocument, thisWindow
        Case "SantWordBuild"
        
        Case "SantPostBuild"
            WriteProperty "CRMNoteText", sCRMNoteText, thisDocument
            
            Dim bAddCRMNote As Boolean
            bAddCRMNote = CBool(Len(sCRMNoteText) > 0)
            
            WriteProperty "AddCRMNote", Abs(CInt(bAddCRMNote)), thisDocument

            continueEditing = True 'keep doc open after upload
        
        Case "SantRFPFileWordEdit"
            If GetPropertyText("ForMarking", thisDocument) = "1" Then
                PrepareForBurst thisDocument, thisWindow
            Else
                FixBookmarks "Your file is being saved...stage 1 of 2"
                FixEndingBookmark
            End If
            
        Case "SantCompareContent", "SantRFPCompareContent"
            FixBookmarks "Your file is being saved...stage 1 of 2"
            FixEndingBookmark
            ActiveDocument.AcceptAllRevisions
            ActiveDocument.trackRevisions = False
            
    End Select
End Sub

Public Sub FixMultiEditBookmarks(ByRef thisDocument As Document, ByRef thisWindow As Window)
    Dim bm As Bookmark
    Dim lEnd As Long
    Dim maxbm As Bookmark
    Dim newName As String
    
    For Each bm In thisDocument.Bookmarks
        If Left(bm.name, 19) = "ContentPlaceholder_" Then
            On Error Resume Next
            newName = Replace(bm.name, "ContentPlaceholder_", "ContentExport_")
            thisDocument.Bookmarks(newName).End = bm.Start - 1
            thisDocument.UndoClear
        End If
    Next bm
    
    lEnd = 0
    For Each bm In thisDocument.Bookmarks
        If Left(bm.name, 14) = "ContentExport_" Then
            If bm.End > lEnd Then
                lEnd = bm.End
                Set maxbm = bm
                thisDocument.UndoClear
            End If
        End If
    Next bm
    If lEnd > 0 Then
        maxbm.End = thisDocument.Range.End
        thisDocument.UndoClear
    End If
End Sub

Public Sub CollapseBookmarksForMarking(ByRef thisDoc As Document)
    Dim thisBookmark As Bookmark
    For Each thisBookmark In thisDoc.Bookmarks
        If Left(thisBookmark.name, 4) = "Sant" Then
            If thisBookmark.End <> thisBookmark.Start Then
                thisBookmark.End = thisBookmark.Start
                thisDoc.UndoClear
            End If
        End If
    Next thisBookmark
End Sub

Public Sub RemoveBookmarks(ByRef thisDoc As Document)
    Dim tempBookmark As Bookmark
    
    For Each tempBookmark In thisDoc.Bookmarks
        tempBookmark.Delete
    Next
End Sub

Public Sub PrepareForEdit(ByRef thisDoc As Document, ByRef thisWindow As Window, ByVal thisMappingInfo As String)
    Dim tempBookmark As Bookmark
    
    StartProcess thisDoc, thisWindow

    For Each tempBookmark In thisDoc.Bookmarks
        DebugMsgBox "  tempBookmark.name [" & tempBookmark.name & "]", "PrepareForEdit:"
        If InStr(1, tempBookmark.name, "Sant") > 0 Then
            If Left(tempBookmark.name, 5) <> "SantH" And InStr(1, "|" & thisMappingInfo & "|", "|" & tempBookmark.name & "|") = 0 Then
                DebugMsgBox "    set background color", "PrepareForEdit:"
                tempBookmark.Range.Tables(1).Rows(1).Cells.Shading.BackgroundPatternColor = &H999999
            End If
        End If
    Next tempBookmark
    
    'Remove extra paragraph that gets inserted at end of doc.
    If ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Bookmarks.count = 0 Then
        ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Delete
    End If

    EndProcess thisDoc, thisWindow
    
End Sub

Public Sub SwitchBulkloadDocs(ByVal bulkloadPath As String, ByRef thisDoc As Document)
    DebugMsgBox "SwitchBulkloadDocs: Version [" & CStr(getVersion) & "] bulkloadPath [" & bulkloadPath & "]..."
    DebugMsgBox "SwitchBulkloadDocs: TemplateMode [" & GetPropertyText("SantTemplateMode", thisDoc) & "] ProcessStarted [" & GetPropertyText("ProcessStarted", thisDoc) & "]"
    
    Dim bulkloadDoc As Document
    Set bulkloadDoc = Documents.Open(bulkloadPath)
    ClearProperties bulkloadDoc
    CopyProperties thisDoc, bulkloadDoc
    WriteProperty "SantTemplateMode", "SantWordBulkLoad", bulkloadDoc

    Set modInit.bulkloadInitDoc = thisDoc
    
    If getVersion > 11 Or GetPropertyText("SantTemplateMode", thisDoc) = "SantWordBulkLoadActive" Then
        CleanupBulkLoadInit
    End If
    
    DebugMsgBox "SwitchBulkloadDocs: DONE"
End Sub

Public Sub ProcessBulkLoadInit(ByRef Doc As Document)

    If Not modInit.bulkloadInitDoc Is Nothing Then
        DebugMsgBox "ProcessBulkLoadInit: Doc [" & Doc.FullName & "]"
        DebugMsgBox "ProcessBulkLoadInit: TemplateMode [" & GetPropertyText("SantTemplateMode", Doc) & "] ProcessStarted [" & GetPropertyText("ProcessStarted", Doc) & "]"
    
        If GetPropertyText("SantTemplateMode", Doc) = "SantWordBulkLoad" And _
           GetPropertyText("ProcessStarted", Doc) = "1" _
        Then
            CleanupBulkLoadInit
        End If
    End If

End Sub

Public Sub CleanupBulkLoadInit()
    If Not modInit.bulkloadInitDoc Is Nothing Then
        Dim bulkloadInitDocFileName As String
        bulkloadInitDocFileName = modInit.bulkloadInitDoc.FullName
        DebugMsgBox "CleanupBulkLoadInit: Closing bulkloadInitDoc [" & bulkloadInitDocFileName & "]"
        bulkloadInitDoc.Saved = True
        bulkloadInitDoc.AttachedTemplate.Saved = True
        bulkloadInitDoc.Close
        DebugMsgBox "CleanupBulkLoadInit: Deleting bulkloadInitDoc [" & bulkloadInitDocFileName & "]"
        GetFileSystemObject.DeleteFile bulkloadInitDocFileName
        DebugMsgBox "CleanupBulkLoadInit: DONE!"
        Set modInit.bulkloadInitDoc = Nothing
    End If
End Sub

Public Sub DisplayCustomProperties(ByRef thisDoc As Document)
    Dim i As Integer
    For i = 1 To thisDoc.CustomDocumentProperties.count
        MsgBox thisDoc.CustomDocumentProperties(i).name & ": " & thisDoc.CustomDocumentProperties(i).Value
    Next i
End Sub

Public Sub ClearProperties(ByRef thisDoc As Document)
    Dim i As Integer
    If thisDoc.CustomDocumentProperties.count > 0 Then
        For i = thisDoc.CustomDocumentProperties.count To 1 Step -1
            thisDoc.CustomDocumentProperties(i).Delete
        Next i
    End If
End Sub

Public Sub CopyProperties(ByRef sourceDoc As Document, ByRef destDoc As Document)
    Dim i As Integer
    If sourceDoc.CustomDocumentProperties.count > 0 Then
        For i = 1 To sourceDoc.CustomDocumentProperties.count
            If sourceDoc.CustomDocumentProperties(i).name <> "SantTemplateMode" Then
                WriteProperty sourceDoc.CustomDocumentProperties(i).name, sourceDoc.CustomDocumentProperties(i).Value, destDoc
            End If
        Next i
    End If
End Sub

Public Function GetDocumentToOpen() As String
    GetDocumentToOpen = ""

    Dim myDocPath As String
    myDocPath = GetMyDocumentsPath
    DebugMsgBox "GetPresentationToOpen(): myDocPath [" & myDocPath & "]"
    
    With Application.FileDialog(msoFileDialogOpen)
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Word Documents", "*.doc,*.docx,*.docm"
        .InitialFileName = myDocPath
        .Show
        If .SelectedItems.count = 1 Then
            GetDocumentToOpen = .SelectedItems(1)
            DebugMsgBox "GetDocumentToOpen(): [" & .SelectedItems(1) & "]"
        End If
        .Filters.Clear
    End With
End Function

Public Sub CopyAndClose(ByVal sCopyCloseMode As String)
    Dim thisDoc As Document
    Dim thisWindow As Window
    Set thisDoc = ActiveDocument
    Set thisWindow = ActiveWindow
    
    thisWindow.Selection.WholeStory
    
    ' Apply ProSearch Formatting?
    If GetPropertyText("ApplyProSearchFormatting", thisDoc) <> "" Then
        'MsgBox "ApplyProSearchFormatting!"
        
        Dim PSSetting As String
        PSSetting = GetPropertyText("PSFontName", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontName: " & PSSetting
            thisWindow.Selection.Font.name = PSSetting
        End If
        
        PSSetting = GetPropertyText("PSFontSize", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontSize: " & PSSetting
            thisWindow.Selection.Font.size = CLng(PSSetting)
        End If
        
        PSSetting = GetPropertyText("PSFontColor", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontColor: " & PSSetting
            thisWindow.Selection.Font.Color = CLng(PSSetting)
        End If
        
        PSSetting = GetPropertyText("PSFontBold", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontBold: " & PSSetting
            thisWindow.Selection.Font.Bold = CBool(PSSetting)
        End If
        
        PSSetting = GetPropertyText("PSFontItalic", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontItalic: " & PSSetting
            thisWindow.Selection.Font.Italic = CBool(PSSetting)
        End If
        
        PSSetting = GetPropertyText("PSFontUnderline", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontUnderline: " & PSSetting
            thisWindow.Selection.Font.Underline = CBool(PSSetting)
        End If
        
        PSSetting = GetPropertyText("PSFontStrikethrough", thisDoc)
        If PSSetting <> "" Then
            'MsgBox "PSFontStrikethrough: " & PSSetting
            thisWindow.Selection.Font.StrikeThrough = CBool(PSSetting)
        End If
    End If
    
    Dim clearClip As New clsBuild
    clearClip.ClearClipboard
    DoEvents
    
    thisWindow.Selection.Copy
    DoEvents
        
    thisWindow.Selection.Collapse
    DoEvents
        
    thisDoc.Saved = True
    thisDoc.AttachedTemplate.Saved = True
    
    Select Case sCopyCloseMode
        Case "SantCopyAndClose"
            MsgBox "Your content has been placed on the Windows clipboard."
            If Documents.count = 1 Then Application.visible = False
            CloseThisDoc thisDoc, "SantCopyAndClose"
            
        Case "SantCopyAndOpen"
            MsgBox "Your content has been placed on the Office clipboard. When finished using clipboard content, please close this Word session."
        
        Case Else
            CloseThisDoc thisDoc, ""
    End Select
End Sub

Private Sub PrepareForBurst(ByRef thisDocument As Document, ByRef thisWindow As Window)
    
    RemoveSmartTags2002andUp thisDocument
    
    Dim AdvSmartMarking As clsAdvSmartMarking
    Set AdvSmartMarking = SmartMarking
    AdvSmartMarking.SetReferences thisDocument, thisWindow
    AdvSmartMarking.MarkingMode = MODE_BURST
    
    frmProgressBar.StartGeneric ("Your file is being saved...stage 1 of 6")
    frmProgressBar.Repaint
    DoEvents
    
    AdvSmartMarking.AddMissingAnswerMarkers False
    DoEvents
    'Unload frmProgressBar
    
    thisWindow.Selection.WholeStory
    DoEvents
    
    PrepareForAsposeParsing
    DoEvents
    
    'DEFECT 9369 - We were ending up with extra paragraph markers in the document with each "modify markings"
    '   Removing the following code resolved the issue without causing problems on edit.
'    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
'    thisWindow.Selection.InsertParagraph

'    '2007 template only.  2003 was reported as not having the same problem.
'    If getVersion >= 12 Then
'        Selection.WholeStory
'        Selection.Collapse wdCollapseEnd
'        thisWindow.Selection.MoveLeft wdCharacter, 1
'        If thisWindow.Selection.Bookmarks.count > 0 Then
'            If LCase(Left(thisWindow.Selection.Bookmarks(1).name, 4)) = "sant" Then
'                thisWindow.Selection.Bookmarks(1).End = thisWindow.Selection.End
'            End If
'        End If
'        thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
'    End If
    
    Unload frmProgressBar
End Sub

Private Sub PrepareForBulkload(ByRef thisDocument As Document, ByRef thisWindow As Window)
    
    RemoveSmartTags2002andUp thisDocument
    
    Dim AdvSmartMarking As clsAdvSmartMarking
    Set AdvSmartMarking = SmartMarking
    
    AdvSmartMarking.SetReferences thisDocument, thisWindow
    
    AdvSmartMarking.AddMissingAnswerMarkers
    DoEvents
    
    AdvSmartMarking.CheckForLoneTitle
    DoEvents
    
    thisWindow.Selection.WholeStory
    DoEvents
    
    BulkLoadPrepForAspose
    'PrepareForAsposeParsing
    DoEvents
    
    thisWindow.Selection.GoTo what:=wdGoToBookmark, name:="\EndOfDoc"
    thisWindow.Selection.InsertParagraph
    
    'Defect 4408
    If getVersion >= 12 Then
        If thisWindow.Selection.Bookmarks.count > 0 Then
            If InStr(1, thisWindow.Selection.Bookmarks(1).name, "Sant") > 0 Then
                thisWindow.Selection.Bookmarks(1).End = thisWindow.Selection.Bookmarks(1).End - 1
            End If
        End If
    End If
End Sub

Public Sub RemoveSmartTags2002andUp(ByRef thisDoc As Document)
    Dim docObj As Object
    If getVersion >= 10 Then
        Set docObj = thisDoc
        docObj.RemoveSmartTags
    End If
End Sub

Public Function PrepareForAsposeParsing() As Boolean
'status is at 5% at beginning of this routine, and will end at 60%.'JSB: May change status percentages.
    Dim tempBookmark As Bookmark
    Dim tempRev As Revision
    Dim currentRevFound As Boolean
    Dim TempTable As Table
    
    'All other bookmark beginnings and ends should remain in place, since they are contained within the markers.
    'Just make sure the LAST marker (not just the last checked out) is at the end of the document.
    FixBookmarks "Your file is being saved...stage 2 of 6"
    
    CleanUpBookmarks 25, 10

    PrepareForAsposeParsing = PrepareForAsposeParsing_ByBookmark
    
    'JIRA 8602 - 6/25/14 DS: Move this to after PrepareForAsposeParsing_ByBookmark so tables marked
    ' as individual question rows will be split and the proper last bookmark will be the one extended
    ' to contain all the content.
    FixEndingBookmark
End Function

'Currently used by Burst and Bulkload, but not for Edit In Context.
Public Function PrepareForAsposeParsing_ByBookmark() As Boolean
    frmProgressBar.StartGeneric ("Your file is being saved...stage 4 of 6")
    frmProgressBar.UpdateProgressBarStatus 100, 0
    frmProgressBar.Repaint
    DoEvents
    Dim myTable As Table
    Dim myBook As Bookmark
    Dim myStr As String
    Dim myArray() As String
    Dim i As Integer
    Dim bFirst As Boolean
    Dim lastMarkerEnd As Long
    Dim lastTableEnd As Long
    Dim delBookmarkCount As Long
    lastMarkerEnd = -1
    lastTableEnd = -2
    delBookmarkCount = 1
    
    bFirst = True
    Dim tblCount As Long
    tblCount = ActiveDocument.Tables.count
    Dim count As Long
    count = 0
    For Each myTable In ActiveDocument.Tables
        If myTable.Range.Start = lastMarkerEnd Then
            myTable.Rows(1).Select
            Selection.SplitTable
            MarkParagraphForDeletionOnBuild delBookmarkCount
        Else
            For Each myBook In myTable.Range.Bookmarks
                If Left(myBook.name, 4) = "Sant" Then
                    If bFirst Then
                        bFirst = False
                        myStr = myStr & myBook.name
                    Else
                        myStr = myStr & "|" & myBook.name
                    End If
                    
                    If myTable.Range.Start = lastTableEnd Then
                        myTable.Rows(1).Select
                        Selection.SplitTable
                        MarkParagraphForDeletionOnBuild delBookmarkCount
                    Else
                        'We currently have to add spaces between our markers and their tables, so Word and Aspose don't get confused.
                        'We may be able to improve this in the future, but it isn't the best use of time right now.
                        If myBook.Range.Tables.count > 0 Then
                            If myBook.Range.Tables(1).Rows.count > 1 Then
                                'If bookmark start isn't in the first row, split the table at the row of the bookmark.
                                If myBook.Range.Tables(1).Range.Start < myBook.Start Then
                                    ActiveDocument.Range(myBook.Start, myBook.Start + 1).Select
                                    Selection.SplitTable
                                    MarkParagraphForDeletionOnBuild delBookmarkCount
                                End If
                                'If row count still > 1 then move to second row and split.
                                If myBook.Range.Tables(1).Rows.count > 1 Then
                                    ActiveDocument.Range(myBook.Start, myBook.Start + 1).Select
                                    Selection.Move wdRow, 1
                                    Selection.SplitTable
                                    MarkParagraphForDeletionOnBuild delBookmarkCount
                                End If
                            Else
                                lastMarkerEnd = myBook.Range.Tables(1).Range.End
                            End If
                        End If
                    End If
                End If
                ActiveDocument.UndoClear
            Next myBook
        End If
        lastTableEnd = myTable.Range.End
        count = count + 1
        frmProgressBar.UpdateProgressBarStatus tblCount, count
    Next myTable
        
    If Len(myStr) = 0 Then
        PrepareForAsposeParsing_ByBookmark = False
    Else
        frmProgressBar.StartGeneric ("Your file is being saved...stage 5 of 6")
        frmProgressBar.UpdateProgressBarStatus 100, 0
        frmProgressBar.Repaint
        DoEvents
        myArray = Split(myStr, "|")
        PrepareForAsposeParsing_ByBookmark = True
        tblCount = UBound(myArray) - LBound(myArray)
        For i = LBound(myArray) To UBound(myArray) - 1
            If ActiveDocument.Bookmarks(myArray(i)).End <> ActiveDocument.Bookmarks(myArray(i + 1)).Start Then
                ActiveDocument.Bookmarks(myArray(i)).End = ActiveDocument.Bookmarks(myArray(i + 1)).Start
                ActiveDocument.UndoClear
            End If
            frmProgressBar.UpdateProgressBarStatus tblCount, (i - LBound(myArray))
        Next i
        ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).InsertParagraphAfter
        ActiveDocument.Bookmarks(myArray(UBound(myArray))).End = ActiveDocument.Range.End - 1
        ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Delete
    End If
    
End Function

Private Sub MarkParagraphForDeletionOnBuild(ByRef delBookmarkCount As Long)
    Selection.Expand wdParagraph
    delBookmarkCount = delBookmarkCount + 1
    Selection.Bookmarks.Add "deleteparagraphonbuild" & "_" & delBookmarkCount
End Sub

Public Sub CheckForExistingBookmarks(ByRef thisDoc As Document)
    Dim b As Bookmark
    Dim i As Integer
    Dim foundOne As Boolean
    foundOne = False
    
    'Loop through bookmarks
    For i = thisDoc.Bookmarks.count To 1 Step -1
        Set b = thisDoc.Bookmarks(i)
        
        'If bookmark is one of ours (SantContent or SantDescription), ask they user if they want to clear them.
        If LCase(Left(b.name, 11)) = "santcontent" Or LCase(Left(b.name, 15)) = "santdescription" Then
            foundOne = True
            Exit For

        End If
        
    Next i
    
    'Prompt if they want to delete them or keep them.
    If foundOne Then
        Dim qResults As VbMsgBoxResult
        qResults = MsgBox("There are bookmarks from a previous operation in this document.  This could cause the current operation to fail." & vbCrLf & vbCrLf & _
                "Do you want to remove these bookmarks now?" & vbCrLf & vbCrLf & _
                "If you are intentionally using a document that is already marked, choose No.", vbYesNo, "Qvidian")
    
        If qResults = vbYes Then
            Dim cnt As Integer
            cnt = 0
            For i = thisDoc.Bookmarks.count To 1 Step -1
                Set b = thisDoc.Bookmarks(i)
                
                'If bookmark is one of ours (SantContent or SantDescription), ask they user if they want to clear them.
                If LCase(Left(b.name, 11)) = "santcontent" Or LCase(Left(b.name, 15)) = "santdescription" Then
                    b.Delete
                End If
                
                cnt = cnt + 1
                
            Next i
            DebugMsgBox cnt & " bookmarks were found in pre-bulk load check, and removed.", "CheckForExistingBookmarks"
            MsgBox cnt & " bookmarks have been removed."
        Else
            DebugMsgBox "Bookmarks were found in pre-bulk load check, user chose to keep them.", "CheckForExistingBookmarks"
        End If
    Else
        DebugMsgBox "No bookmarks were found in pre-bulk load check.", "CheckForExistingBookmarks"
    End If
End Sub

Public Sub FixBookmarks(caption As String)
    frmProgressBar.StartGeneric (caption)
    frmProgressBar.Repaint
    DoEvents
    Dim t As Table
    Dim b As Bookmark
    Dim prevb As Bookmark
    Dim tblCount As Long
    tblCount = ActiveDocument.Tables.count
    Dim counter As Long
    counter = 0
    For Each t In ActiveDocument.Tables
        For Each b In t.Range.Bookmarks
            If b.Start >= t.Range.Start Then
                If Left(b.name, 4) = "Sant" Then
                    If TypeName(prevb) <> "Nothing" Then
                        If prevb.End <> b.Start Then
                            prevb.End = b.Start
                            ActiveDocument.UndoClear
                        End If
                    End If
                    Set prevb = b
                End If
            End If
        Next b
        counter = counter + 1
        frmProgressBar.UpdateProgressBarStatus tblCount, counter
    Next t
    Unload frmProgressBar
End Sub

Public Sub CleanUpBookmarks(ByVal statusStart As Integer, ByVal statusRange As Integer)
    frmProgressBar.StartGeneric ("Your file is being saved...stage 3 of 6")
    frmProgressBar.UpdateProgressBarStatus 100, 0
    frmProgressBar.Repaint
    DoEvents
    'BEGIN TEST JSB
    Dim bookmarkCount As Long
    Dim bookmarkCounter As Long
    Dim bShowMessage As Boolean
    Dim tempBookmark As Bookmark
    bShowMessage = False
    bookmarkCount = ActiveDocument.Bookmarks.count
    bookmarkCounter = 0
    For Each tempBookmark In ActiveDocument.Bookmarks
        bookmarkCounter = bookmarkCounter + 1
        If Left(tempBookmark.name, 4) = "Sant" Then
            If tempBookmark.Range.Tables.count = 0 Then
                'If this bookmark has become disassociated from its table,
                'assume the end user doesn't expext this text to be a part of that block.
                'Remove the bookmark.  The text may become a part of a different block.
                tempBookmark.Delete
                ActiveDocument.UndoClear
                bShowMessage = True

            ElseIf tempBookmark.Range.Tables(1).Rows.count = 1 Then
                
                If tempBookmark.Range.Start = tempBookmark.Range.End Then
                    'Do nothing.  This is a new marker.
                ElseIf tempBookmark.Range.Tables(1).Range.End = tempBookmark.Range.End Then
                    'If all the bookmark contains is the table, then delete the table.
                    tempBookmark.Range.Tables(1).Delete
                    ActiveDocument.UndoClear
                    bShowMessage = True
    
                ElseIf tempBookmark.Range.Tables(1).Range.End > tempBookmark.Range.End Then
                    'If the bookmark is contained IN the table, delete the first row?
                    tempBookmark.Range.Tables(1).Rows(1).Delete
                    ActiveDocument.UndoClear
                    bShowMessage = True
                    
                ElseIf tempBookmark.Range.Tables(1).Range.Start <> tempBookmark.Range.Start Then
                    'If the bookmark doesn't start at the beginning of the table, remove the bookmark.
                    tempBookmark.Delete
                    ActiveDocument.UndoClear
                    bShowMessage = True
                End If
            Else
                'Marker table contains multiple rows (has not been split yet, which should be ok), or bookmark exists in a random table.
                'May add more checks here later.
            End If
        End If
        frmProgressBar.UpdateProgressBarStatus bookmarkCount, bookmarkCounter

    Next tempBookmark
    
    If bShowMessage = True Then
        MsgBox "Edit_MarkersOutOfPlace" 'GetTemplateString("Edit_MarkersOutOfPlace"), vbOKOnly, "Qvidian"
    End If
    'END TEST JSB
End Sub

Public Sub CleanUpBookmarksBAD(ByVal statusStart As Integer, ByVal statusRange As Integer)
    'BEGIN TEST JSB
    Dim bookmarkCount As Integer
    Dim bookmarkCounter As Integer
    Dim bShowMessage As Boolean
    Dim tempBookmark As Bookmark
    bShowMessage = False
    bookmarkCount = ActiveDocument.Bookmarks.count
    bookmarkCounter = 0
    For Each tempBookmark In ActiveDocument.Bookmarks
        bookmarkCounter = bookmarkCounter + 1
        If Left(tempBookmark.name, 4) = "Sant" Then
            If tempBookmark.Range.Tables.count = 0 Then
                'If this bookmark has become disassociated from its table,
                'assume the end user doesn't expext this text to be a part of that block.
                'Remove the bookmark.  The text may become a part of a different block.
                tempBookmark.Delete
                bShowMessage = True

            ElseIf tempBookmark.Range.Start = tempBookmark.Range.End Then
                'New bookmark, still contained at the beginning of the marker.
                'Do nothing.
                
            ElseIf tempBookmark.Range.Tables(1).Range.End = tempBookmark.Range.End Then
                'If all the bookmark contains is the table, then delete the table.
                tempBookmark.Range.Tables(1).Delete
                bShowMessage = True
                
            ElseIf tempBookmark.Range.Tables(1).Range.End > tempBookmark.Range.End Then
                'If the bookmark is contained IN the table, delete the first row?
                tempBookmark.Range.Tables(1).Rows(1).Delete
                bShowMessage = True
                
            ElseIf tempBookmark.Range.Tables(1).Range.Start <> tempBookmark.Range.Start Then
                'If the bookmark doesn't start at the beginning of the table, remove the bookmark.
                tempBookmark.Delete
                bShowMessage = True
                
            End If
        End If
        ActiveDocument.UndoClear
        frmProgressBar.UpdateProgressBarStatus 100, statusStart + statusRange * (bookmarkCounter / bookmarkCount) ', ""

    Next tempBookmark
    
    If bShowMessage = True Then
        MsgBox "Edit_MarkersOutOfPlace" 'GetTemplateString("Edit_MarkersOutOfPlace"), vbOKOnly, "Qvidian"
    End If
    'END TEST JSB
End Sub

Private Sub FixEndingBookmark()
    Dim tableIndex As Integer
    Dim tempBookmark As Bookmark
    Dim tblCount As Long
    tblCount = ActiveDocument.Tables.count
    For tableIndex = tblCount To 1 Step -1
        For Each tempBookmark In ActiveDocument.Tables(tableIndex).Range.Bookmarks
            If Left(tempBookmark.name, 4) = "Sant" Then
                If Len(ActiveDocument.Paragraphs(ActiveDocument.Paragraphs.count).Range.Text) > 1 Or _
                    ActiveDocument.Paragraphs(ActiveDocument.Paragraphs.count).Range.Tables.count > 0 Or _
                    ActiveDocument.Paragraphs(ActiveDocument.Paragraphs.count).Range.InlineShapes.count > 0 Or _
                    ActiveDocument.Paragraphs(ActiveDocument.Paragraphs.count).Range.Frames.count > 0 Or _
                    ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End - 1).Tables.count > 0 Then

                    ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).InsertParagraphAfter
                End If

                tempBookmark.End = ActiveDocument.Range.End - 1
                'ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Delete
                Exit Sub
            End If
        Next tempBookmark
        ActiveDocument.UndoClear
    Next tableIndex
End Sub
Public Function GetTemplateMode(ByRef thisDoc As Document) As String
    GetTemplateMode = GetPropertyText("SantTemplateMode", thisDoc)
End Function

Public Function UnScramble(ByVal base64String) As String
'MsgBox "UnScramble - Start"
  'rfc1521
  '1999 Antonin Foller, Motobit Software, http://Motobit.cz
  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  Dim dataLength, sOut, groupBegin
  
  'remove white spaces, If any
  base64String = Replace(base64String, vbCrLf, "")
  base64String = Replace(base64String, vbTab, "")
  base64String = Replace(base64String, " ", "")
  
  'The source must consists from groups with Len of 4 chars
  dataLength = Len(base64String)
  If dataLength Mod 4 <> 0 Then
    'MsgBox "bad base 64 string"
    Err.Raise 1, "Base64Decode", "Bad Base64 string."
    Exit Function
  End If

  'MsgBox "UnScramble - DataLength: " & dataLength
  ' Now decode each group:
  For groupBegin = 1 To dataLength Step 4
    Dim numDataBytes, CharCounter, thisChar, thisData, nGroup, pOut
    ' Each data group encodes up To 3 actual bytes.
    numDataBytes = 3
    nGroup = 0

    For CharCounter = 0 To 3
      ' Convert each character into 6 bits of data, And add it To
      ' an integer For temporary storage.  If a character is a '=', there
      ' is one fewer data byte.  (There can only be a maximum of 2 '=' In
      ' the whole string.)

      thisChar = Mid(base64String, groupBegin + CharCounter, 1)

      If thisChar = "=" Then
        numDataBytes = numDataBytes - 1
        thisData = 0
      Else
        thisData = InStr(1, Base64, thisChar, vbBinaryCompare) - 1
      End If
      If thisData = -1 Then
        Err.Raise 2, "Base64Decode", "Bad character In Base64 string."
        Exit Function
      End If

      nGroup = 64 * nGroup + thisData
    Next
    
    'Hex splits the long To 6 groups with 4 bits
    nGroup = Hex(nGroup)
    
    'Add leading zeros
    nGroup = String(6 - Len(nGroup), "0") & nGroup
    
    'Convert the 3 byte hex integer (6 chars) To 3 characters
    pOut = Chr(CByte("&H" & Mid(nGroup, 1, 2))) + _
      Chr(CByte("&H" & Mid(nGroup, 3, 2))) + _
      Chr(CByte("&H" & Mid(nGroup, 5, 2)))
    
    'add numDataBytes characters To out string
    sOut = sOut & Left(pOut, numDataBytes)
  Next

  UnScramble = sOut
End Function

Public Function UnScrambleX(ByVal base64String) As String
  UnScrambleX = StrConv(UnScramble(base64String), vbFromUnicode)
End Function

Public Function getVersion() As Integer
    Dim count As Integer
    Dim iVersion As Integer
    Dim aChar As String
    
    If appVer = 0 Then
        iVersion = 0
        For count = 1 To Len(Application.Version)
            aChar = Mid(Application.Version, count, 1)
            If IsNumeric(aChar) Then
                iVersion = iVersion * 10 + CInt(aChar)
            Else
                Exit For
            End If
        Next
        
        appVer = iVersion
    End If
    
    getVersion = appVer
End Function

Public Sub StartProcess(ByRef thisDocument As Document, ByRef thisWindow As Window)
    thisWindow.View = wdNormalView
    Application.ScreenUpdating = False
    Options.Pagination = False
    
    Set activeDocSettings = New struct_DocSettings
        
    SaveDocumentSettings thisDocument, activeDocSettings, True

    'all handled above in save settings
'    thisDocument.trackRevisions = False
'
'    ' Disable spelling and grammar checking!
'    thisDocument.showGrammaticalErrors = False
'    thisDocument.showSpellingErrors = False
End Sub

Public Sub EndProcess(ByRef thisDocument As Document, ByRef thisWindow As Window)
    Options.Pagination = True
    Application.ScreenUpdating = True
    
    RestoreDocumentSettings thisDocument, activeDocSettings
    
    Application.ScreenRefresh
    SwitchToPrintLayout thisWindow 'JSB: Do we want to always do this?
End Sub

Public Sub SwitchToPrintLayout(ByRef thisWindow As Window)
    If thisWindow.View.SplitSpecial = wdPaneNone Then
        thisWindow.ActivePane.View.Type = wdPrintView
    Else
        thisWindow.View.Type = wdPrintView
    End If
    thisWindow.ActivePane.View.Zoom.Percentage = 100
End Sub

Public Function GetMyDocumentsPath() As String
    Dim wsh As Object
    Set wsh = CreateObject("WScript.Shell")
    GetMyDocumentsPath = wsh.SpecialFolders("MyDocuments")
End Function

Public Sub EnsureTempFolderExists()
    'The following variables are defined in the build files.
    sDocumentsPath = GetClientPath
    If Not GetFileSystemObject.FolderExists(sDocumentsPath) Then GetFileSystemObject.CreateFolder (sDocumentsPath)
    sTempPath = sDocumentsPath & "Temp\"
    If Not GetFileSystemObject.FolderExists(sTempPath) Then GetFileSystemObject.CreateFolder (sTempPath)
    sTempPath = sTempPath & GetServerName(ActiveDocument) & "\"
    DebugMsgBox sTempPath, "EnsureTempFolderExists:"
    If Not GetFileSystemObject.FolderExists(sTempPath) Then GetFileSystemObject.CreateFolder (sTempPath)
    sTemplatesPath = sDocumentsPath & "Templates\"
    If Not GetFileSystemObject.FolderExists(sTemplatesPath) Then GetFileSystemObject.CreateFolder (sTemplatesPath)
End Sub

Public Sub EnsureBuildTempFolderExists()
    'The following variables are defined in the build files.
    sBuildDocumentsPath = GetClientBuildTempPath
    If Not GetFileSystemObject.FolderExists(sBuildDocumentsPath) Then GetFileSystemObject.CreateFolder (sBuildDocumentsPath)
    sBuildTempPath = sBuildDocumentsPath & "Temp\"
    If Not GetFileSystemObject.FolderExists(sBuildTempPath) Then GetFileSystemObject.CreateFolder (sBuildTempPath)
    sBuildTempPath = sBuildTempPath & GetServerName(ActiveDocument) & "\"
    DebugMsgBox sBuildTempPath, "EnsureBuildTempFolderExists:"
    If Not GetFileSystemObject.FolderExists(sBuildTempPath) Then GetFileSystemObject.CreateFolder (sBuildTempPath)
    sBuildTemplatesPath = sBuildDocumentsPath & "Templates\"
    If Not GetFileSystemObject.FolderExists(sBuildTemplatesPath) Then GetFileSystemObject.CreateFolder (sBuildTemplatesPath)
End Sub

Public Function GetFileTimeStamp() As String
    Dim ts As Date
    ts = Now()
    GetFileTimeStamp = format(ts, "yyyy") & "_" & format(ts, "mm") & "_" & format(ts, "dd") & " " & format(ts, "hh") & "_" & format(ts, "nn") & "_" & format(ts, "ss")
End Function

Public Function GetProperExtension(ByRef thisDoc As Document) As String
    Dim docName As String
    docName = thisDoc.FullName
    Select Case LCase(Right(docName, Len(docName) - InStrRev(docName, ".")))
        Case "doc"
            GetProperExtension = "doc"
        Case "docx"
            GetProperExtension = "docx"
        Case "docm"
            GetProperExtension = "docm"
        Case Else
            Select Case thisDoc.SaveFormat
                Case 12     ' DIFFERENT VALUE THAN Word 2003 returns for DOCX
                    GetProperExtension = "docx"
                Case 13     ' DIFFERENT VALUE THAN Word 2003 returns for DOCM
                    GetProperExtension = "docm"
                Case 0
                    GetProperExtension = "doc"
                Case Else
                    GetProperExtension = "doc"
            End Select
    End Select
    
'    If GetVersion > 11 Then
'        GetProperExtension = "docx"
'    Else
'        GetProperExtension = "doc"
'    End If
End Function

Public Function GetDefaultServer() As String
ReReadServer:
    GetDefaultServer = ""
    Dim serverFile As String
    Dim serverValue As String
    Dim tempName As String
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    QvidianServer = GetDefaultServer
    
    serverFile = GetClientPath

    If (Right$(serverFile, 1) <> "\") Then serverFile = serverFile & "\"
    serverFile = serverFile & "Servers.txt"

    ' Does the server file exist?
    If GetFileSystemObject.FileExists(serverFile) Then
        On Error GoTo NoServerFound
        ' Yep, so now we open it
        Open serverFile For Input As #1
        Line Input #1, serverValue
        Close #1
    
        tempName = LCase(serverValue)
        If Len(tempName) < 7 Or (Left(tempName, 7) <> "http://" And Left(tempName, 8) <> "https://") Then
            GetDefaultServer = "http://" & serverValue
        Else
            GetDefaultServer = serverValue
        End If
    End If
    
    If GetDefaultServer <> "" Then
        If Right(GetDefaultServer, 1) <> "/" Then GetDefaultServer = GetDefaultServer & "/"
    
        ' QPA-11367: MOLO 05/12/2016
        ' QvidianServer variable used for managing server specific user credentials
        QvidianServer = GetDefaultServer
        Exit Function
    End If
    
NoServerFound:
    frmSelectServer.ShowSelections

    If Not bCancelUpload Then
        GoTo ReReadServer
    End If
End Function

Public Function GetPassedServer(ByRef thisDoc As Document) As String
    Dim currentServer As String
    currentServer = GetServerText(thisDoc)
    'DebugMsgBox "GetPassedServer: GetServerText gives us [" & CurrentServer & "]"
    If currentServer = "" Then
        currentServer = GetDefaultServer()
        'DebugMsgBox "GetPassedServer: GetDefaultServer gives us [" & CurrentServer & "]"
    End If
    
    If currentServer = "" Then Exit Function
    If Right(currentServer, 1) <> "/" Then currentServer = currentServer & "/"

    GetPassedServer = currentServer
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    QvidianServer = GetPassedServer
End Function

Public Function GetServerName(ByRef thisDoc As Object) As String
    On Error Resume Next
    Dim serverValue As String
    serverValue = GetPassedServer(thisDoc)
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    QvidianServer = serverValue
    
    If serverValue = "" Then
        GetServerName = "NotSet"
        QvidianServer = GetServerName
        Exit Function
    End If
    
    ' Clean it up.
    serverValue = Replace(serverValue, "http://", "")
    serverValue = Replace(serverValue, "https://", "")
    serverValue = Replace(serverValue, ":", "")
    serverValue = Replace(serverValue, "/", "")
    DebugMsgBox "GetServerName = [" & serverValue & "]", "GetServerName:"
    GetServerName = serverValue
End Function

Public Sub SaveToSantTemp(ByRef thisDoc As Document)
    
    DebugMsgBox "FullName - " & thisDoc.FullName, "SaveToSantTemp:"
    ' Document in IE's "Temporary Internet Files" folder or system "TMP" folder ?
    Dim tempInternetFolder As String
    tempInternetFolder = getRegUserString("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Cache")
    DebugMsgBox "tempInternetFolder - " & tempInternetFolder, "SaveToSantTemp:"
        
    Dim myDocPath As String
    myDocPath = GetLongPath(GetFileSystemObject.GetSpecialFolder(2))
    DebugMsgBox "myDocPath - " & myDocPath, "SaveToSantTemp:"
    
    Dim strPath As String
    strPath = LCase(Replace(thisDoc.FullName, "\" & thisDoc.name, ""))
    
    DebugMsgBox "ReadOnly - " & CStr(thisDoc.ReadOnly), "SaveToSantTemp:"
    
    If InStr(1, thisDoc.FullName, tempInternetFolder) > 0 Or _
       InStr(1, thisDoc.FullName, "\Downloads\") > 0 Or _
       StrComp(strPath, LCase(myDocPath), vbTextCompare) = 0 Or _
       thisDoc.ReadOnly Then
        ' Do a "SaveAs" to the OS Temp\Qvidian\temp folder so that template can perform all document operations
        ' Ensure temporary folder exists (will be created as sBuildTempPath)
        modTools.EnsureBuildTempFolderExists
        Dim saveFile As String
        saveFile = sBuildTempPath & thisDoc.name
        DebugMsgBox "SaveAs: " & saveFile, "SaveToSantTemp:"
        thisDoc.SaveAs saveFile
        
        ' Trickery to prevent Word recovery when activeX disabled and
        ' Word session already opened with "blank" document1
        thisDoc.Saved = True
        thisDoc.Save
    Else
        DebugMsgBox "Just Save - " & thisDoc.FullName, "SaveToSantTemp:"
        thisDoc.Save
    End If
End Sub

Public Function FixValueForReplace(thisValue As String) As String
    FixValueForReplace = Replace(thisValue, "^", "^^")
End Function

Public Function RemoveFile(path As String) As Boolean
    If Dir(path) <> "" Then
        On Error Resume Next
        GetFileSystemObject.DeleteFile path, True
    End If
            
    On Error GoTo 0
    RemoveFile = False
End Function

' breaking links on linked images and selecting some images solves missing images problems
Public Sub FixDocumentPictures(ByRef thisDoc As Document)
    Dim inShp As InlineShape
    Dim shpShp As Shape
    Dim i As Long
    
    DebugMsgBox "FixDocumentPictures on " & thisDoc.name
    
    On Error GoTo FDPError
    
    For i = thisDoc.InlineShapes.count To 1 Step -1
        Set inShp = thisDoc.InlineShapes(i)
        If inShp.Type = wdInlineShapeLinkedPicture Or inShp.Type = wdInlineShapeLinkedPictureHorizontalLine Then
            If Not inShp.LinkFormat Is Nothing Then
                inShp.LinkFormat.BreakLink
            End If
        End If
    Next

    For i = thisDoc.Shapes.count To 1 Step -1
        Set shpShp = thisDoc.Shapes(i)
        If shpShp.Type = msoLinkedPicture Then
            If Not shpShp.LinkFormat Is Nothing Then
                shpShp.LinkFormat.BreakLink
            End If
        End If
    Next
    
    Call BringGraphicsToView
    
    DebugMsgBox "Finished FixDocumentPictures on " & thisDoc.name
    Exit Sub

FDPError:
    DebugMsgBox "ERROR: FixDocumentPictures on " & thisDoc.name & ". " & Err.description
End Sub

Sub BringGraphicsToView()
    Dim myRange As Range
    Dim myLastRange As Range
    
    Set myRange = ActiveWindow.Selection.GoTo(wdGoToGraphic, wdGoToFirst)
    Do
        DoEvents
        If Not myLastRange Is Nothing Then
            If myRange.End = myLastRange.End Then
                Exit Sub
            End If
        End If
        Set myLastRange = myRange
        Set myRange = ActiveWindow.Selection.GoTo(wdGoToGraphic, wdGoToNext)
    Loop
End Sub

Public Function GetActiveDocument() As Document
    If Documents.count > 0 Then
        Set GetActiveDocument = ActiveDocument
    Else
        Set GetActiveDocument = Nothing
    End If
End Function

Public Sub ActivateQvidianRibbon()
    On Error Resume Next
    
'    If gJobFile.contentList.count = 1 Then
'        SetActiveRibbonTab ("MULTIEDIT_S_TOOLBAR")
'    Else
'        SetActiveRibbonTab ("MULTIEDIT_TOOLBAR")
'    End If
    SetActiveRibbonTab ("Qvidian")
End Sub

Public Function SetActiveRibbonTab(thisTabName As String) As Boolean
    Dim RibbonTab   As IAccessible
    
    SetActiveRibbonTab = False
    DebugMsgBox "activate Ribbon: " & thisTabName, "SetActiveRibbonTab:"

    Set RibbonTab = GetAccessible(CommandBars("Ribbon"), _
                                  ROLE_SYSTEM_PAGETAB, _
                                  thisTabName)

    If Not RibbonTab Is Nothing Then
        RibbonTab.accDoDefaultAction CHILDID_SELF
        SetActiveRibbonTab = True
    Else
        DebugMsgBox "Ribbon [" & thisTabName & "] is nothing", "SetActiveRibbonTab:"
    End If

End Function

Public Function ClearBuiltInProperties(thisDoc As Document) As Boolean
    
    Dim oProp As DocumentProperty
    
    ' saveDoc.BuiltInDocumentProperties.Clear
    ' The previous statement fails, for some reason, so we're changng to
    ' just the strings!
    On Error Resume Next
    For Each oProp In thisDoc.BuiltInDocumentProperties
        DebugMsgBox "DocumentProperty - " & oProp.name, "ClearBuiltInProperties:"
        If oProp.Type = msoPropertyTypeString Then
            oProp.Value = ""
            Err.Clear
        End If
    Next
   
    ClearBuiltInProperties = True
    
End Function
    
Public Function ClearCustomProperties(thisDoc As Document) As Boolean
    
    Dim oProp As DocumentProperty
    
    ' saveDoc.BuiltInDocumentProperties.Clear
    ' The previous statement fails, for some reason, so we're changng to
    ' just the strings!
    On Error Resume Next
        
    For Each oProp In thisDoc.CustomDocumentProperties
        oProp.Delete
    Next

    ClearCustomProperties = True
    
End Function
    
Public Function RestoreDocumentSettings(ByRef thisDoc As Document, ByRef theseSettings As struct_DocSettings) As Boolean
    'skip any bad or missing settings
    On Error Resume Next
    
    thisDoc.showGrammaticalErrors = theseSettings.showGrammaticalErrors
    thisDoc.showSpellingErrors = theseSettings.showSpellingErrors
    thisDoc.trackRevisions = theseSettings.trackRevisions
    thisDoc.showRevisions = theseSettings.showRevisions
    thisDoc.printRevisions = theseSettings.printRevisions
    Assistant.Sounds = theseSettings.assistantSounds
    Assistant.visible = theseSettings.assistantVisible

    RestoreDocumentSettings = True
End Function

Public Function SaveDocumentSettings(ByRef thisDoc As Document, ByRef theseSettings As struct_DocSettings, Optional bClearValues As Boolean = False) As Boolean
    'save current settings
    theseSettings.showGrammaticalErrors = thisDoc.showGrammaticalErrors
    theseSettings.showSpellingErrors = thisDoc.showSpellingErrors
    theseSettings.assistantSounds = Assistant.Sounds
    theseSettings.assistantVisible = Assistant.visible
    theseSettings.trackRevisions = thisDoc.trackRevisions
    theseSettings.showRevisions = thisDoc.showRevisions
    theseSettings.printRevisions = thisDoc.printRevisions
    
    'if told to clear values, turn settings to desired "off" state
    If bClearValues Then
        thisDoc.showGrammaticalErrors = False
        thisDoc.showSpellingErrors = False
        Assistant.Sounds = False
        Assistant.visible = False
        thisDoc.trackRevisions = False
        thisDoc.showRevisions = False
        thisDoc.printRevisions = False
    End If
    
    SaveDocumentSettings = True
End Function

Public Function GetBookmarkMap() As String
    Dim bm As Bookmark
    Dim bmString As String
    Dim bmName As String
    Dim t As Table
    For Each t In ActiveDocument.Tables
        For Each bm In t.Range.Bookmarks
            If bm.Range.Start >= t.Range.Start Then
                bmName = bm.name
                If Left(bmName, 4) = "Sant" Then
                    If bmString = "" Then
                        bmString = bmName
                    Else
                        bmString = bmString & "|" & bmName
                    End If
                End If
            End If
        Next bm
    Next t
    GetBookmarkMap = bmString
End Function

Public Function GetSavedBookmarkMap() As String
    GetSavedBookmarkMap = GetPropertyText("RFPBookmarkMap", ActiveDocument)
End Function

Public Sub VerifyRFPBookmarkMap()
    If GetSavedBookmarkMap = "" Then
        WriteProperty "RFPBookmarkMap", GetBookmarkMap, ActiveDocument
    End If
End Sub

Public Sub CopyStylesWithHiddenProperty(ByRef thisDoc As Document, ByVal thisTemplate As String)
    thisDoc.CopyStylesFromTemplate thisTemplate
    On Error Resume Next
    Dim template As Document
    Set template = Documents.Open(thisTemplate, False, True, False, , , , , , , , False)
    
    Dim i As Integer
    For i = 1 To template.Styles.count
        Dim oStyle As Style
        Set oStyle = template.Styles(i)
        thisDoc.Styles(oStyle.NameLocal).Visibility = oStyle.Visibility
        thisDoc.Styles(oStyle.NameLocal).UnhideWhenUsed = oStyle.UnhideWhenUsed
    Next i
    
    template.Saved = True
    template.Close wdDoNotSaveChanges
    
End Sub

Public Function checkForMarkerErrors(ByRef thisDoc As Document) As Boolean
    'Verify each table with an RFP marker contains only one RFP marker.
    'Verify each table that starts with an RFP marker has only one row.
    Dim TempTable As Table
    Dim tempBookmark As Bookmark
    Dim bookmarkCount As Integer
    For Each TempTable In thisDoc.Tables
        bookmarkCount = 0
        For Each tempBookmark In TempTable.Range.Bookmarks
            If Left(tempBookmark.name, 4) = "Sant" Then
                If TempTable.Range.Start = tempBookmark.Range.Start Then
                    bookmarkCount = bookmarkCount + 1
                
                    If TempTable.Rows.count > 1 Then
                        checkForMarkerErrors = True
                        Exit Function
                    End If
                End If
            End If
        Next tempBookmark
        If bookmarkCount > 1 Then
            checkForMarkerErrors = True
            Exit Function
        End If
     Next TempTable
     checkForMarkerErrors = False
                
End Function
Attribute VB_Name = "modUtcConv"
Option Explicit

Private Const TIME_ZONE_ID_UNKNOWN  As Long = 0
Private Const TIME_ZONE_ID_STANDARD As Long = 1
Private Const TIME_ZONE_ID_DAYLIGHT As Long = 2
Private Const TIME_ZONE_ID_INVALID  As Long = &HFFFFFFFF

Type SYSTEMTIME
  wYear                             As Integer
  wMonth                            As Integer
  wDayOfWeek                        As Integer
  wDay                              As Integer
  wHour                             As Integer
  wMinute                           As Integer
  wSecond                           As Integer
  wMilliseconds                     As Integer
End Type

Type TIME_ZONE_INFORMATION
  Bias                              As Long
  StandardName(0 To ((32 * 2) - 1)) As Byte   ' Unicode.
  StandardDate                      As SYSTEMTIME
  StandardBias                      As Long
  DaylightName(0 To ((32 * 2) - 1)) As Byte   ' Unicode.
  DaylightDate                      As SYSTEMTIME
  DaylightBias                      As Long
End Type

#If Win64 Then
Private Declare PtrSafe Function GetTimeZoneInformation Lib "KERNEL32.dll" (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
#Else

' TIME_ZONE_INFORMATION-type variables hold information about the system's selected time zone.
' The two arrays in the structure are actually strings, each element holding the ASCII codes for
' each character (the end of the string is marked by a NULL character, ASCII code 0).
' For more information about how to convert the arrays into usable data, see the example for
' GetTimeZoneInformation.
'
' Bias
' The difference in minutes between UTC (a.k.a. GMT) time and local time.
' It satisfies the formula UTC time = local time + Bias.
'
' StandardName(0 To 31)
' Holds the name of the time zone for standard time.
'
' StandardDate
' The relative date for when daylight savings time ends.
'
' StandardBias
' A number to add to Bias to form the true bias during standard time.
'
' DaylightName(0 To 31)
' Holds the name of the time zone for daylight savings time.
'
' DaylightDate
' The relative date for when daylight savings time begins.
'
' DaylightBias
' A number to add to Bias to form the true bias during daylight savings time.

Private Declare Function GetTimeZoneInformation Lib "KERNEL32.dll" (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
#End If

Public Function ConvertLocalToUTC(ByVal datDateLocal As Date, Optional ByVal booIgnoreDaylightSetting As Boolean) As Date
  Const clngBiasUtc As Long = 0
  
  Dim datUtc        As Date
  Dim lngBiasLocal  As Long
  
  lngBiasLocal = GetLocalTimeZoneBias(datDateLocal, booIgnoreDaylightSetting)
  datUtc = DateAddTimeZoneDiff(datDateLocal, lngBiasLocal, clngBiasUtc)

  ConvertLocalToUTC = datUtc

End Function

Public Function GetLocalFromUTC(ByVal datUtc As Date, Optional ByVal booIgnoreDaylightSetting As Boolean) As Date
  Const clngBiasUtc As Long = 0
  
  Dim datDateLocal        As Date
  Dim lngBiasLocal  As Long
  
  If datDateLocal = 0 Then
    datDateLocal = Now
  End If
  
  lngBiasLocal = GetLocalTimeZoneBias(datUtc, booIgnoreDaylightSetting)
  datDateLocal = DateAddTimeZoneDiff(datUtc, -lngBiasLocal, clngBiasUtc)

  GetLocalFromUTC = datDateLocal

End Function

Public Function DateAddTimeZoneDiff(ByVal datLocal As Date, ByVal lngLocalBias, ByVal lngRemoteBias) As Date
  
' Calculates the date/time of datLocal in a remote time zone.
' Adds the difference in minutes between the local time zone bias and
' the remote time zone bias, if both bias are relative to UTC.
'
' Examples:
'
'   datRemote = DateAddTimeZoneDiff(Now(), 60, -600)
' will return datRemote as eleven hours ahead of local time.
'
'   datRemote = DateAddTimeZoneDiff(Now(), -600, 60)
' will return datRemote as eleven hours behind local time.
'
' 2000-05-30. Cactus Data ApS, CPH.
' 2005-01-25. Adjusted to accommodate change in TimeZoneBiasDiff().

  Dim datRemote As Date
  Dim lngBias   As Long
  
  ' Get difference (in minutes) in time zone bias.
  lngBias = TimeZoneBiasDiff(lngLocalBias, lngRemoteBias)
  ' Calculate remote date/time.
  datRemote = DateAdd("n", lngBias, datLocal)
  
  DateAddTimeZoneDiff = datRemote
  
End Function

Public Function TimeZoneBiasDiff( _
  ByVal lngLocalTimeBias As Long, _
  ByVal lngRemoteTimeBias As Long) _
  As Long
  
' Calculates the difference in minutes between two time zones,
' typically from the local time zone to the remote time zone.
' Both time zones must be expressed by their bias relative to
' UTC (Coordinated Universal Time) which is measured in minutes.
'
' 2000-05-30. Cactus Data ApS, CPH.
' 2005-01-25. Output reversed to express bias value.

  ' Minimum amount of minutes for a time zone bias.
  Const clngTimeZoneBiasMin As Long = 15

  Dim lngTimeZoneBiasDiff As Long
  
  ' Round off time zone bias by minimum time zone difference.
  lngLocalTimeBias = lngLocalTimeBias \ clngTimeZoneBiasMin
  lngLocalTimeBias = lngLocalTimeBias * clngTimeZoneBiasMin
  lngRemoteTimeBias = lngRemoteTimeBias \ clngTimeZoneBiasMin
  lngRemoteTimeBias = lngRemoteTimeBias * clngTimeZoneBiasMin
  
  ' Calculate difference in time zone bias.
  lngTimeZoneBiasDiff = lngLocalTimeBias - lngRemoteTimeBias
  
  TimeZoneBiasDiff = lngTimeZoneBiasDiff

End Function

Public Function GetLocalTimeZoneBias( _
  Optional ByVal datDateLocal As Date, _
  Optional ByVal booIgnoreDaylightSetting As Boolean) _
  As Long

' Returns True if the date is within the local Daylight Saving Time period as defined for the current year.
' 2005-05-26. Cactus Data ApS, CPH.
' 2010-02-16. Modified to accept parameter datDateLocal.
'             Daylight setting check moved to external function IsLocalDaylightSavingTime.
  
  Dim TZI           As TIME_ZONE_INFORMATION
  Dim lngTimeZoneID As Long
  Dim lngBias       As Long
  
  lngTimeZoneID = GetTimeZoneInformation(TZI)
  
  Select Case lngTimeZoneID
    Case TIME_ZONE_ID_STANDARD, TIME_ZONE_ID_DAYLIGHT
      lngBias = TZI.Bias
      If booIgnoreDaylightSetting = False Then
        If IsLocalDaylightSavingTime(datDateLocal) = True Then
          lngBias = lngBias + TZI.DaylightBias
        End If
      End If
  End Select
  
  GetLocalTimeZoneBias = lngBias
   
End Function

Public Function IsLocalDaylightSavingTime( _
  Optional datDate As Date) _
  As Boolean

' Returns True if the date is within the local Daylight Saving Time period as defined for the current year.
' Limitation: Does not count for previous or future changes in definition of DST period.
' 2010-02-16. Cactus Data ApS, CPH.

  Dim TZI           As TIME_ZONE_INFORMATION
  Dim booDST        As Boolean
  Dim lngTimeZoneID As Long
  Dim datDaylight   As Date
  Dim datStandard   As Date
  Dim intYear       As Integer
    
  lngTimeZoneID = GetTimeZoneInformation(TZI)
  
  If datDate = 0 Or datDate = Date Then
    ' GetTimeZoneInformation returns the timezone ID for the current date.
    booDST = (lngTimeZoneID = TIME_ZONE_ID_DAYLIGHT)
  Else
    ' Calculate daylight starting date and standard starting date for intYear.
    intYear = Year(datDate)
    datDaylight = DateMonthWeekday(TZI.DaylightDate.wDay, DateSerial(intYear, TZI.DaylightDate.wMonth, 1), vbSunday)
    datStandard = DateMonthWeekday(TZI.StandardDate.wDay, DateSerial(intYear, TZI.StandardDate.wMonth, 1), vbSunday)
    ' Check if datDate falls within the period of daylight saving time for year intYear.
    If datDate >= datDaylight And datDate < datStandard Then
      booDST = True
    End If
  End If
  
  IsLocalDaylightSavingTime = booDST
  
End Function

Public Function DateMonthWeekday( _
  Optional ByVal bytWeekdayOccurrence As Byte, _
  Optional ByVal datDateInMonth As Date, _
  Optional ByVal bytWeekday As Byte) _
  As Date
  
  Const cintDaysInWeek  As Integer = 7
  Dim intDayOffset      As Integer
  Dim datMonthFirst     As Date
  Dim datWeekday        As Date
  
' Calculates occurrence of bytWeekday of the month of datDateInMonth.
' If bytWeekdayOccurrence is 0 the first occurrence of bytWeekday of the month is assumed.
' If bytWeekdayOccurrence is 5 or anything else different from 0 to 4, the
' last occurrence of bytWeekday of the month is assumed.
' If no date for the month is supplied, today's date is used.
' If bytWeekday is not the Value of a weekday, the weekday of datDateInMonth is used.
' Returns the date as a date/time Value.
'
' 2008-09-12, Cactus Data ApS, CPH.
' 2009-12-10. Calculation of last occurrence changed to call of DateMonthLastWeekday().

  If datDateInMonth = 0 Then
    ' No date is specified.
    datDateInMonth = Date
  End If

  ' Validate bytWeekday.
  Select Case bytWeekday
    Case _
      vbMonday, _
      vbTuesday, _
      vbWednesday, _
      vbThursday, _
      vbFriday, _
      vbSaturday, _
      vbSunday
    Case Else
      ' Zero, none or invalid value for weekday.
      bytWeekday = Weekday(datDateInMonth, vbSunday)
  End Select
  
  ' Validate bytWeekdayOccurrence.
  If bytWeekdayOccurrence = 0 Then
    bytWeekdayOccurrence = 1
  End If
  
  Select Case bytWeekdayOccurrence
    Case 1, 2, 3, 4
      datMonthFirst = DateSerial(Year(datDateInMonth), Month(datDateInMonth), 1)
      ' Find offset of bytWeekday from first day of month.
      intDayOffset = (bytWeekday - Weekday(datMonthFirst, vbSunday) + cintDaysInWeek) Mod cintDaysInWeek
      ' Find offset for occurence no. of bytWeekday from first day of month.
      intDayOffset = intDayOffset + cintDaysInWeek * (bytWeekdayOccurrence - 1)
      datWeekday = DateAdd("d", intDayOffset, datMonthFirst)
    Case Else
      datWeekday = DateMonthLastWeekday(datDateInMonth, bytWeekday)
  End Select
  
  DateMonthWeekday = datWeekday

End Function

Public Function DateMonthLastWeekday( _
  Optional ByVal datDateInMonth As Date, _
  Optional ByVal bytWeekday As Byte) _
  As Date

' Calculates last occurrence of bytWeekday of the month of datDateInMonth.
' If no date for the month is supplied, today's date is used.
' If no weekday is supplied, the weekday of the supplied date is used.
' Returns the date as a date/time Value.
'
' 2007-01-25, Cactus Data ApS, CPH.
' 2009-12-10. Calculation of bytDayDiff simplified.
'             Parameters made optional.
  
  Dim datLastDay As Date
  Dim bytDayDiff As Byte
  
  ' No specific error handling.
  On Error Resume Next
  
  If datDateInMonth = 0 Then
    datDateInMonth = Date
  End If
  
  ' Validate bytWeekday.
  Select Case bytWeekday
    Case _
      vbMonday, _
      vbTuesday, _
      vbWednesday, _
      vbThursday, _
      vbFriday, _
      vbSaturday, _
      vbSunday
    Case Else
      ' Zero, none or invalid value for weekday.
      bytWeekday = Weekday(datDateInMonth, vbSunday)
  End Select
  
  ' Find last day of the month of datDateInMonth.
  datLastDay = DateSerial(Year(datDateInMonth), Month(datDateInMonth) + 1, 0)
  
  ' Determine number of days between last day of month and last lngWeekday of month
  ' by assuming lngWeekday being the first day of a week.
  bytDayDiff = Weekday(datLastDay, bytWeekday) - 1
  
  ' Calculate closest preceding weekday of the last day including this.
  DateMonthLastWeekday = DateAdd("d", -bytDayDiff, datLastDay)
  
End Function

Function JustDate(fullTime As Date) As Date
    JustDate = DateSerial(Year(fullTime), Month(fullTime), Day(fullTime))
End Function

Public Function DateFormat() As String
DateFormat = FormatDateTime(DateSerial(2003, 1, 2), vbShortDate)
DateFormat = Replace(DateFormat, "2003", "YYYY") ' YYYY = (\d{4})
DateFormat = Replace(DateFormat, "03", "YY")     ' YY = (\d{2})
DateFormat = Replace(DateFormat, "01", "MM")     ' MM = (0[1-9]|1[012])
DateFormat = Replace(DateFormat, "1", "M")       ' M  = (0?[1-9]|1[012])
DateFormat = Replace(DateFormat, "02", "dd")     ' dd = ((0[1-9])|([1-31]))
DateFormat = Replace(DateFormat, "2", "d")       ' d  = ((0?[1-9])|([1-31]))
DateFormat = Replace(DateFormat, MonthName(1), "MMMM")      ' MMMM = Going to knock this back to MM
DateFormat = Replace(DateFormat, MonthName(1, True), "MMM") ' MMM = Going to knock this back to MM
End Function

Public Function DateFormatRegEx() As String
DateFormatRegEx = FormatDateTime(DateSerial(2003, 6, 7), vbShortDate)
DateFormatRegEx = Replace(DateFormatRegEx, "2003", "(\d{4})")                     ' YYYY = (\d{4})
DateFormatRegEx = Replace(DateFormatRegEx, "03", "(\d{2})")                       ' YY = (\d{2})
DateFormatRegEx = Replace(DateFormatRegEx, "06", "(0[1-9]|1[012])")               ' MM = (0[1-9]|1[012])
DateFormatRegEx = Replace(DateFormatRegEx, "6", "(0?[1-9]|1[012])")               ' M  = (0?[1-9]|1[012])
DateFormatRegEx = Replace(DateFormatRegEx, "07", "((0[1-9])|([1-31]))")           ' dd = ((0[1-9])|([1-31]))
DateFormatRegEx = Replace(DateFormatRegEx, "7", "((0?[1-9])|([1-31]))")           ' d  = ((0?[1-9])|([1-31]))
DateFormatRegEx = Replace(DateFormatRegEx, MonthName(1), "(0[1-9]|1[012])")       ' MMMM = Going to knock this back to MM
DateFormatRegEx = Replace(DateFormatRegEx, MonthName(1, True), "(0[1-9]|1[012])") ' MMM = Going to knock this back to MM
End Function


Attribute VB_Name = "modVersionInfo"
'Public Const ProductVersion = "11.0"
Public Const QPA_URL = "QPA_"

Public Const TemplateVersion = 110011

Public Const ProductCopyright = "Copyright |fffd| 1998-2019 Qvidian. All rights reserved."
Public Const LibraryTitle = "Qvidian * - Library*"
Public Const DialogsTitle = "Qvidian * - Dialogs*"
Public Const QvidianTitle = "Qvidian * - *"
Public Const ProSearchTitle = "ProSearch * - *"
Attribute VB_Name = "modWS"
Option Explicit

Public connection As struct_ConnectInfo
Public ss As clsws_Qvidian
Private dlgTimeCounter As Integer
Public waitDialog As frmWait
Public waitForSaveDialog As frmWaitForSave
Public dialogMode As DialogModes
Public waitTimer As CTimer

' These ID's correspond to DialogWindows.js
Public Enum DialogModes
    'About = 0
    MergeCodeDialog = 4
    EmailDialog = 10
    SubmitDialog = 11
    BulkLoadDialog = 12
    WordTemplatesDialog = 14
    PowerPointTemplatesDialog = 15
    LibraryReferenceDialog = 16
End Enum
    
Public Enum LibraryModes
    Basic = 1
    Advanced = 2
    Browse = 3
    LibraryReference = 4
End Enum
Private sumbitMiscFileID As Long
Private EmailRFPFileID As Long
Private librayFolderID As Long
Private currentTemplateMode As String
Private submitRFPFileID As Long
Private submitBookmark As String

Public Sub SaveCopyWS(ByVal tempMode As String)
    DebugMsgBox "Start", "SaveCopyWS:"
    sumbitMiscFileID = -1
    submitRFPFileID = -1
    submitBookmark = ""
    currentTemplateMode = tempMode
    modInit.ActivateCurrent

    Dim SaveDocument As Document
    Set SaveDocument = ActiveDocument
    DebugMsgBox "Got doc reference. ReadOnly? " & SaveDocument.ReadOnly, "SaveCopyWS:"
    
    continueEditing = False
    
    DebugMsgBox "SaveDocument.ReadOnly: " & SaveDocument.ReadOnly, "SaveCopyWS:"
    If Not SaveDocument.ReadOnly Then
        ' Establish the server WS connection...
        If setupWSConnection(SaveDocument) <> ConnectionStatus.worked Then
            Exit Sub
        End If

        Dim supportedExts
        supportedExts = ss.wsm_GetGlobalSetting("SelectFileAllowedFileExtensions")
        DebugMsgBox supportedExts

        Dim validExt As Boolean
        validExt = False

        'if we have a list, ensure that our document is a valid type
        If supportedExts <> "" Then
            Dim extArray() As String
            extArray = Split(LCase(supportedExts), ",")
            
            'Ensure Folder Exists (will be created as sTempPath)
            modTools.EnsureTempFolderExists
    
            Dim i As Integer
            For i = 1 To 10
                'sometimes the first saveAs doesn't truly save. second time usually works, so give it a few tries...
                If InStrRev(SaveDocument.name, ".") = 0 Then
                    SaveDocument.SaveAs sTempPath & SaveDocument.name, WdSaveFormat.wdFormatDocumentDefault, , , False
                Else
                    Exit For
                End If
            Next
            
            Dim SaveDocExt As String
            SaveDocExt = LCase(Right(SaveDocument.name, Len(SaveDocument.name) - InStrRev(SaveDocument.name, ".")))

            For i = LBound(extArray) To UBound(extArray)
                If extArray(i) = SaveDocExt Then
                    validExt = True
                    Exit For
                End If
            Next
        Else
            validExt = True
        End If
        
        If Not validExt Then
            MsgBox "The file type (" & SaveDocExt & ") is not supported. Please save in a supported format (" & supportedExts & ") and try again."
            Exit Sub
        End If
        
        Dim isPS As Boolean
        isPS = GetIsPS(SaveDocument)

        Dim closeWSConnection As Boolean
        closeWSConnection = True
        Dim refreshType As Integer
        refreshType = 0
        librayFolderID = -1
        EmailRFPFileID = -1
        Dim fileID As Long
        Dim uploadParams As struct_UploadParams
        Set uploadParams = New struct_UploadParams
        uploadParams.SantTemplateMode = currentTemplateMode
        
        Dim selectedText As Boolean
        selectedText = False
        Dim bClearBuiltInProps As Boolean
        Dim bClearCustomProps As Boolean
        DebugMsgBox "SantTemplateMode: " & uploadParams.SantTemplateMode, "SaveCopyWS:"
        Select Case uploadParams.SantTemplateMode
            Case "SantWordMultiEdit"
                If continueEditing Then
                    uploadParams.TemplateMode = 17 '17=QAExportImportAndContinue
                Else
                    uploadParams.TemplateMode = 16 '16=QAExportImport
                End If
                uploadParams.ContentMetadataSettings = modDocProperties.GetPropertyText("ContentMetadataSettings", SaveDocument)
                librayFolderID = GetLibraryFolderID(uploadParams.ContentMetadataSettings)
                bClearBuiltInProps = connection.ClearPropsOnMultiSave
                bClearCustomProps = connection.ClearCustomPropsOnMultiSave
                
            Case "SantWordEdit", "SantCompareContent"
                uploadParams.TemplateMode = 3      ' 3 = Edit
                fileID = CLng(modTools.GetContentID(SaveDocument))
                uploadParams.contentID = fileID
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave

            Case "SantRFPCompareContent"
                uploadParams.TemplateMode = 26 ' 26 = RFPFileWordEdit
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
                uploadParams.compareContentID = CLng(GetPropertyText("SantCompareContentID", SaveDocument))
                DebugMsgBox "Compare ID is " + CStr(uploadParams.compareContentID), "SaveCopyWS:"
                fileID = CLng(modTools.GetMiscFileID(SaveDocument))
                uploadParams.miscFileID = fileID
                uploadParams.rfpFileID = CLng(modTools.GetRFPFileID(SaveDocument))
                refreshType = 1

            Case "SantRFPFileWordEdit"
                If GetPropertyText("ForMarking", SaveDocument) = "1" Then 'TODO: Change to a specific document reference.
                    uploadParams.TemplateMode = 2  ' 2 = Burst
                    bClearBuiltInProps = connection.ClearPropsOnMultiSave
                    bClearCustomProps = connection.ClearCustomPropsOnMultiSave
                Else
                    uploadParams.TemplateMode = 26 ' 26 = RFPFileWordEdit
                    bClearBuiltInProps = connection.ClearPropsOnSingleSave
                    bClearCustomProps = connection.ClearCustomPropsOnSingleSave
                End If
                fileID = CLng(modTools.GetMiscFileID(SaveDocument))
                uploadParams.miscFileID = fileID
                uploadParams.rfpFileID = CLng(modTools.GetRFPFileID(SaveDocument))
                refreshType = 1
                
            Case "SantPostBuild"
                If bPrintToPDF Then
                    uploadParams.TemplateMode = 19  ' 19 = SaveDocAsPDF
                Else
                    uploadParams.TemplateMode = 24  ' 24 = BuildFile
                End If
                fileID = thisProjectID
                uploadParams.projectID = fileID
                DebugMsgBox "Project ID is: " & fileID, "SaveCopyWS:"
                uploadParams.CRMNoteText = sCRMNoteText
                uploadParams.AddCRMNote = CBool(Len(sCRMNoteText) > 0)
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
           
            Case "SantPartialSubmit"
                uploadParams.TemplateMode = 25  ' 25 = Submit
                DebugMsgBox "Before GetRFPFile: " & modTools.GetRFPFileID(SaveDocument), "SaveCopyWS:"
                submitRFPFileID = CLng(modTools.GetRFPFileID(SaveDocument))
                DebugMsgBox "After GetRFPFile: " & submitRFPFileID, "SaveCopyWS:"
                uploadParams.SantTemplateMode = "SantSubmit"
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
                selectedText = True
                closeWSConnection = False
           
            Case "SantSubmit"
                uploadParams.TemplateMode = 25  ' 25 = Submit
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
                closeWSConnection = False
                   
            Case "SantEmailSubmit"
                uploadParams.TemplateMode = 25  ' 25 = Submit
                uploadParams.SantTemplateMode = "SantSubmit"
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
                selectedText = True
                closeWSConnection = False
                EmailRFPFileID = CLng(modTools.GetRFPFileID(SaveDocument))
        
            Case "SantWordBulkLoad"
                uploadParams.ContentMetadataSettings = modDocProperties.GetPropertyText("ContentMetadataSettings", SaveDocument)
                librayFolderID = GetLibraryFolderID(uploadParams.ContentMetadataSettings)
                
                uploadParams.TemplateMode = 25  ' 25 = Submit
                uploadParams.SantTemplateMode = "SantSubmit"
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
                closeWSConnection = False

            Case Else
                DebugMsgBox "WARNING, we fell through to the default...", "SaveCopyWS:"
                uploadParams.TemplateMode = 23  ' 23 = MiscFileStorage
                fileID = CLng(modTools.GetMiscFileID(SaveDocument))
                uploadParams.miscFileID = fileID
                refreshType = 1
                bClearBuiltInProps = connection.ClearPropsOnSingleSave
                bClearCustomProps = connection.ClearCustomPropsOnSingleSave
        End Select
        DebugMsgBox "bClearBuiltInProps: " & bClearBuiltInProps, "SaveCopyWS:"
        DebugMsgBox "bClearCustomProps: " & bClearCustomProps, "SaveCopyWS:"
        DebugMsgBox "uploadParams.TemplateMode is " & CStr(uploadParams.TemplateMode), "SaveCopyWS:"
        
        ' Disable spelling and grammar checking!
        'QPA-33092 leave settings as previously set
        'SaveDocument.showGrammaticalErrors = False
        'SaveDocument.showSpellingErrors = False
        
        DebugMsgBox "Call PrepareForSave", "SaveCopyWS:"
        PrepareForSave currentTemplateMode, SaveDocument, ActiveWindow

        Dim result As String
        result = ""
        Dim saveFileName As String
        Dim tmpFileName As String
        Dim originalFileName As String
        originalFileName = SaveDocument.FullName
        DebugMsgBox "originalFileName [" & originalFileName & "]", "SaveCopyWS:"
        If InStrRev(originalFileName, ".") = 0 Then
            originalFileName = originalFileName & "." & modTools.GetProperExtension(SaveDocument)
        End If
        
        DebugMsgBox "Call SaveOrSaveAsWS [" & originalFileName & "]", "SaveCopyWS:"
        If SaveOrSaveAsWS(SaveDocument, bClearBuiltInProps, bClearCustomProps, selectedText, saveFileName, tmpFileName) Then
            ' Upload Document
            DebugMsgBox "Call wsm_UploadFile: " & originalFileName, "SaveCopyWS:"
            'result = ss.wsm_UploadFile(uploadParams, originalFileName, GetFile(saveFileName))
            result = ss.wsm_UploadFileChunk(uploadParams, originalFileName, saveFileName)
            DebugMsgBox "wsm_UploadFile gave a result of: " + result, "SaveCopyWS:"
            
            ' Now, if we have a temporary file name then we CAN delete, the saveFileName
            If tmpFileName <> "" Then
                DebugMsgBox "RemoveFile: " + saveFileName, "SaveCopyWS:"
                modTools.RemoveFile saveFileName
            End If
        End If
        If closeWSConnection Then
            ss.wsm_ConnectionTerminate
        End If
        
        If result = "" Then
            ' Let's try and refresh an IE window....
            RefreshScreen refreshType, fileID, librayFolderID, isPS
            
            If Not continueEditing Then
                CloseThisDoc SaveDocument, uploadParams.SantTemplateMode
            End If
        Else
            If Len(result) > 0 Then
                If Left(result, 13) = "SubmitFileID:" Then
                    sumbitMiscFileID = CLng(Right(result, Len(result) - 13))
                    result = ""
                Else
                    MsgBox "The following issues occurred during upload, and the associated items have not been saved: " & result, vbOKOnly, AppTitle
                End If
            End If
        End If
    Else
        MsgBox "The file is read-only.  Please save the file with a different name and try again.", vbOKOnly, AppTitle
    End If

End Sub

Public Sub CancelCheckout(ByVal tempMode As String)

    currentTemplateMode = tempMode
    If setupWSConnection(ActiveDocument) <> ConnectionStatus.worked Then
        Exit Sub
    End If
    
    Dim worked As Boolean
    worked = False
    Dim fileID As String
    Dim refreshType As Integer
    refreshType = 0
    Dim folderID As Long
    folderID = -1
    Select Case currentTemplateMode
        Case "SantWordEdit"
            fileID = modTools.GetContentID(ActiveDocument)
            'Don't actually cancel the checkout on a SME job
            If gJobFile.isCompositeEdit = False Then
                worked = ss.wsm_CancelContentCheckout(fileID)
            Else
                worked = True
            End If
            Dim settings As String
            settings = modDocProperties.GetPropertyText("ContentMetadataSettings", ActiveDocument)
            folderID = GetLibraryFolderID(settings)
        Case "SantWordMultiEdit"
            Dim ContentIDs As String
            ContentIDs = modTools.GetContentIDs(ActiveDocument)
            'Don't actually cancel the checkout on a SME job
            If gJobFile.isCompositeEdit = False Then
                DebugMsgBox "wsm_CancelContentCheckout contentIDs: " & ContentIDs, "CancelCheckout:"
                Dim idx As Integer
                idx = InStr(1, ContentIDs, ",")
                If idx > 0 Then
                    fileID = Mid(ContentIDs, 1, idx - 1)
                Else
                    fileID = ContentIDs
                End If
                DebugMsgBox "wsm_CancelContentCheckout fileID: " & fileID, "CancelCheckout:"
                worked = ss.wsm_CancelContentCheckout(ContentIDs)
            Else
                worked = True
            End If

        Case "SantRFPFileWordEdit", "SantRFPCompareContent"
            fileID = modTools.GetRFPFileID(ActiveDocument)
            worked = ss.wsm_CancelRFPCheckout(fileID, modDocProperties.GetPropertyText("CheckedOutRecords", ActiveDocument))
            fileID = modDocProperties.GetPropertyText("MiscFileID", ActiveDocument)
            refreshType = 1
        Case "SantFileListWordEdit", "SantStructure"
            fileID = modTools.GetMiscFileID(ActiveDocument)
            worked = ss.wsm_CancelFileListCheckout(fileID)
            refreshType = 1
    End Select

    ss.wsm_ConnectionTerminate

    If worked Then
        Dim isPS As Boolean
        isPS = GetIsPS(ActiveDocument)

        ' Let's try and refresh an IE window....
        RefreshScreen refreshType, CLng(fileID), folderID, isPS
        CloseThisDoc ActiveDocument, currentTemplateMode
    Else
        MsgBox "Failed to Cancel the checkout, please try again.", vbOKOnly, AppTitle
    End If
End Sub

Public Sub ShowWaitForSaveDialog(ByVal thisJobID As String)
    ' We know we'll need a DB connection so we're going to establsh that
    ' NOW to prevent problems with Cancel "isssues" later on...I hope...
    If setupWSConnection(ActiveDocument, False, True) <> ConnectionStatus.worked Then
        DebugMsgBox "setupWSConnection was cancelled", "ShowWaitForSaveDialog:"
        Exit Sub
    End If

    ' Wait for a reply....
    'modInit.ActivateCurrent
    Set waitTimer = New CTimer
    waitTimer.TimerType = TimerTypes.SaveDialog
    waitTimer.JobID = thisJobID
    waitTimer.Interval = 2000
    waitTimer.Enabled = True

    On Error Resume Next
    Set waitForSaveDialog = New frmWaitForSave
    waitForSaveDialog.Show vbModal
    waitTimer.Enabled = False
    
    If Not waitForSaveDialog.bCancelClicked Then
        'Refresh and close (isn't that refreshing?)
        If gJobFile.firstID > 0 Then
            RefreshScreen 0, gJobFile.firstID, -1, gJobFile.isPS
        Else
            'MsgBox "first ID is NOT what I was expecting"
            'If First ID is not available, do generic refresh.
            RefreshScreen 0, -1, -1, gJobFile.isPS
        End If
    Else
        'Close dialog?
        'MsgBox "You can't cancel me!"
    End If
    
    ss.wsm_ConnectionTerminate
    Set waitForSaveDialog = Nothing
    ' Due to Windows 7, this WON'T bring the window back into focus, but it WILL
    ' cause the icon on the taskbar for us to FLASH!
    'Application.Activate
End Sub

Public Sub ShowExtDialog(dlgMode As DialogModes, Optional ByVal bAltMode As Boolean = False)
    ' We know we'll need a DB connection so we're going to establsh that
    ' NOW to prevent problems with Cancel "isssues" later on...I hope...
    If setupWSConnection(ActiveDocument, False, True) <> ConnectionStatus.worked Then
        DebugMsgBox "setupWSConnection was cancelled", "ShowExtDialog:"
        Exit Sub
    End If

    ' Wait for a reply....
    'modInit.ActivateCurrent
    dialogMode = dlgMode
    Set waitTimer = New CTimer
    waitTimer.TimerType = TimerTypes.ExternalDialog
    waitTimer.Interval = 1000
    waitTimer.Enabled = True

    On Error Resume Next
    Set waitDialog = New frmWait
    waitDialog.Show 'vbModal
    waitTimer.Enabled = False
    DebugMsgBox "Back from frmWait: " & waitDialog.bSelectedClicked, "ShowExtDialog:"
    
    If waitDialog.bSelectedClicked Then
        ' Get the results
        Dim dlgResults As String
        dlgResults = ss.wsm_GetDialogResults()
        Select Case dialogMode
            Case DialogModes.MergeCodeDialog
                ActiveWindow.Selection.Text = ss.wsm_GetDialogResults()
            Case DialogModes.LibraryReferenceDialog
                ActiveWindow.Selection.Text = ss.wsm_GetDialogResults()
            Case DialogModes.WordTemplatesDialog
                downloadTemplateResult dlgResults, bAltMode
            Case DialogModes.SubmitDialog
                submitDialogResult dlgResults
            Case DialogModes.BulkLoadDialog
                bulkloadDialogResult dlgResults
            Case DialogModes.EmailDialog
                emailDialogResults dlgResults
        End Select
    Else
        DebugMsgBox "Was it a cancel: " & waitDialog.bCancelClicked, "ShowExtDialog:"
        If waitDialog.bCancelClicked Then
            If dialogMode = DialogModes.LibraryReferenceDialog Then
                ' Need to clean out the User Preferences!
                ss.wsm_RemoveSearchParams
            End If
        End If
    End If
    ss.wsm_ConnectionTerminate
    Set waitDialog = Nothing
    
    ' Due to Windows 7, this WON'T bring the window back into focus, but it WILL
    ' cause the icon on the taskbar for us to FLASH!
    Application.Activate
End Sub

Public Sub SubmitFile()
    ' Upload the file....
    SaveCopyWS "SantSubmit"
    
    If sumbitMiscFileID > 0 Then
        modWS.ShowExtDialog DialogModes.SubmitDialog
    End If
End Sub

Public Sub BulkLoadFile()
    ' Upload the file....
    SaveCopyWS "SantWordBulkLoad"
       
    If sumbitMiscFileID > 0 Then
        modWS.ShowExtDialog DialogModes.BulkLoadDialog
    End If
End Sub

Public Sub SubmitPartialFile()
    ' Upload the file....
    SaveCopyWS "SantPartialSubmit"

    If sumbitMiscFileID > 0 Then
        modWS.ShowExtDialog DialogModes.SubmitDialog
    End If
End Sub

Public Sub CallEmail()
    ' Upload the file....
    SaveCopyWS "SantEmailSubmit"
    
    If sumbitMiscFileID > 0 Then
        modWS.ShowExtDialog DialogModes.EmailDialog
    End If
End Sub

Public Function AddQueryParams(base As String, params As String) As String
Dim result As String

Dim first As Variant
first = Left(params, 1)
If (first = "?" Or first = "&") Then
    params = CStr(Right(params, Len(params) - 1))
End If

If InStr(base, "?") <> 0 Then
    Dim last As Variant
    last = Right(base, 1)
    If (CStr(last) = "?" Or CStr(last) = "&") Then
        result = base & params
        Else
        result = base & "&" & params
    End If
Else
    result = base & "?" & params
End If
AddQueryParams = result
End Function

Public Function ExtDialogStart() As Boolean
    'modInit.ActivateCurrent
    Dim launchString As String
    Dim origFileName As String
    Dim isPS As Boolean
    DebugMsgBox "Call GetIsPS", "ExtDialogStart:"
    isPS = GetIsPS(ActiveDocument)
    ExtDialogStart = False
    
    If dialogMode = LibraryReferenceDialog Then
        BrowserFocusLibrary
        Exit Function
    End If

    DebugMsgBox "Call GetWebBrowser", "ExtDialogStart:"
    If GetWebBrowser(isPS) Then
        DebugMsgBox "Found an IE window", "ExtDialogStart:"
        If setupWSConnection(ActiveDocument, False, True) <> ConnectionStatus.worked Then
            DebugMsgBox "setupWSConnection1 was cancelled", "ExtDialogStart:"
            ExtDialogStart = True
            Exit Function
        End If
        launchString = AddQueryParams(launchString, "ResultAT=" & connection.authToken)
        launchString = AddQueryParams(launchString, "&ExternalLaunch=1")
        If dialogMode = SubmitDialog Or dialogMode = BulkLoadDialog Or dialogMode = DialogModes.EmailDialog Then
            launchString = AddQueryParams(launchString, "&SubmitMiscFileID=" & sumbitMiscFileID)
            If librayFolderID > 0 Then
                launchString = AddQueryParams(launchString, "&LibFolderID=" & librayFolderID)
            End If
            If EmailRFPFileID > 0 Then
                launchString = AddQueryParams(launchString, "&EmailRFPFileID=" & EmailRFPFileID)
            End If
            If submitRFPFileID > 0 Then
                launchString = AddQueryParams(launchString, "&SubmitRFPFileID=" & submitRFPFileID)
            End If
            If submitBookmark <> "" Then
                launchString = AddQueryParams(launchString, "&SubmitBookmark=" & submitBookmark)
            End If
            If dialogMode = BulkLoadDialog Then
                origFileName = GetPropertyText("BulkLoadOriginalFilename", ActiveDocument)
                If origFileName <> "" Then
                    origFileName = Replace(origFileName, "&", "_AMP_")
                    launchString = AddQueryParams(launchString, "&OriginalFileName=" & origFileName)
                End If
            End If
        End If
        
        DebugMsgBox "IE Launch string is: " & launchString, "ExtDialogStart:"
        'WebBrowserCollection(1).Document.parentWindow.PSshow dialogMode, launchString
        'WebBrowserCollection(1).Document.parentWindow.execScript "PSshow(" & dialogMode & ",'" & launchString & "')"
        BrowserExecScript WebBrowserCollection(1), "PSshow(" & dialogMode & ",'" & launchString & "')"
                
        ' QPA-11882: MOLO 05/25/2016
        ' Give QPA Window focus!
        Call SetWindowPos(WebBrowserCollection(1).hWnd, HWND_TOP, 0, 0, 0, 0, flag)
    Else
        DebugMsgBox "NO IE window, so call BrowserFocusQvidian", "ExtDialogStart:"
        ' It is not. Let's see if FF/Chrome is running (no library)
        Dim bstate As BrowserQvidianState
        bstate = BrowserFocusQvidian(True, isPS)
        DebugMsgBox "BrowserFocusQvidian gave us [" & bstate & "]", "ExtDialogStart:"
        If Not bstate = NotRunning Then
            ' Is the dialog tab already there?
            If BrowserDialogsRunning Then
                waitTimer.Enabled = False
                waitDialog.KillMe
                MsgBox "It appears that the Dialogs tab is still open in your browser. Please close it and then re-try the operation."
                Exit Function
            Else
                ' No, so we need to launch a browser window.
                ' Terminate, just to be safe, because if there IS a current connection, it probably
                ' WON'T be created with TRUE, FALSE..
                terminateWSConnection
                If setupWSConnection(ActiveDocument, True, True) <> ConnectionStatus.worked Then
                    DebugMsgBox "setupWSConnection2 was cancelled", "ExtDialogStart:"
                    ExtDialogStart = True
                    Exit Function
                End If
                
                ' Launch the UI....
                launchString = AddQueryParams(ss.GetDialogAddress(dialogMode), "AuthenticationToken=" & connection.authToken & "&Mode=" & dialogMode)
                
                If dialogMode = SubmitDialog Or dialogMode = BulkLoadDialog Or dialogMode = DialogModes.EmailDialog Then
                    launchString = AddQueryParams(launchString, "&SubmitMiscFileID=" & sumbitMiscFileID)
                    If librayFolderID > 0 Then
                        launchString = AddQueryParams(launchString, "&LibFolderID=" & librayFolderID)
                    End If
                    If EmailRFPFileID > 0 Then
                        launchString = AddQueryParams(launchString, "&EmailRFPFileID=" & EmailRFPFileID)
                    End If
                    If submitRFPFileID > 0 Then
                        launchString = AddQueryParams(launchString, "&SubmitRFPFileID=" & submitRFPFileID)
                    End If
                    If submitBookmark <> "" Then
                        launchString = AddQueryParams(launchString, "&SubmitBookmark=" & submitBookmark)
                    End If
                    If dialogMode = BulkLoadDialog Then
                        origFileName = GetPropertyText("BulkLoadOriginalFilename", ActiveDocument)
                        If origFileName <> "" Then
                            origFileName = Replace(origFileName, "&", "_AMP_")
                            launchString = AddQueryParams(launchString, "&OriginalFileName=" & origFileName)
                        End If
                    End If
                End If
        
                DebugMsgBox "exisiting Launch URL string is: " & launchString, "ExtDialogStart:"
                Call RunShellExecute("Open", launchString)
                ' It might *seam* to make sense to call BrowserFocusQvidian, but DON'T!!!
                ' If you do, if Library is displayed then it will be raised infront of the
                ' main FF window - not what we want!
            End If
        Else
            ' No, so we need to launch a browser window.
            ' Terminate, just to be safe, because if there IS a current connection, it probably
            ' WON'T be created with TRUE, FALSE..
            DebugMsgBox "(Re)-Establish a connection...", "ExtDialogStart:"
            terminateWSConnection
            If setupWSConnection(ActiveDocument, True, True) <> ConnectionStatus.worked Then
                DebugMsgBox "setupWSConnection3 was cancelled", "ExtDialogStart:"
                ExtDialogStart = True
                Exit Function
            End If
    
            ' Launch the UI....
            launchString = AddQueryParams(ss.GetHomeAddress(isPS), "?AuthenticationToken=" & connection.authToken & "&Launch=" & dialogMode)
            
            If dialogMode = SubmitDialog Or dialogMode = BulkLoadDialog Or dialogMode = DialogModes.EmailDialog Then
                launchString = AddQueryParams(launchString, "&SubmitMiscFileID=" & sumbitMiscFileID)
                If librayFolderID > 0 Then
                    launchString = AddQueryParams(launchString, "&LibFolderID=" & librayFolderID)
                End If
                If EmailRFPFileID > 0 Then
                    launchString = AddQueryParams(launchString, "&EmailRFPFileID=" & EmailRFPFileID)
                End If
                If submitRFPFileID > 0 Then
                    launchString = AddQueryParams(launchString, "&SubmitRFPFileID=" & submitRFPFileID)
                End If
                If submitBookmark <> "" Then
                    launchString = AddQueryParams(launchString, "&SubmitBookmark=" & submitBookmark)
                End If
                If dialogMode = BulkLoadDialog Then
                    origFileName = GetPropertyText("BulkLoadOriginalFilename", ActiveDocument)
                    If origFileName <> "" Then
                        origFileName = Replace(origFileName, "&", "_AMP_")
                        launchString = AddQueryParams(launchString, "&OriginalFileName=" & origFileName)
                    End If
                End If
            End If
    
            DebugMsgBox "Direct Launch URL string is: [" & launchString & "]", "ExtDialogStart:"
            Call RunShellExecute("Open", launchString)

        End If
    End If
End Function

Public Sub submitDialogResult(result As String)
    
    DebugMsgBox "result is: [" & result & "]", "submitDialogResult:"
    
    If Not IsNumeric(result) Then
        MsgBox result, vbOKOnly, AppTitle
        Exit Sub
    End If
    
'    If result = "" Then
'        Exit Sub
'    End If
    
    librayFolderID = CLng(result)
    DebugMsgBox "librayFolderID is: [" & librayFolderID & "]", "submitDialogResult:"
    
    ' Let's try and refresh an IE window....
    RefreshScreen 0, -1, librayFolderID, False
    'MsgBox "Content was successfully submitted to the Library."
End Sub

Public Sub emailDialogResults(result As String)
    
    If result = "" Then
        Exit Sub
    End If

    MsgBox "Email was sent."
End Sub

Public Sub bulkloadDialogResult(result As String)
    DebugMsgBox "result is: [" & result & "]", "bulkloadDialogResult:"
    
    If Not IsNumeric(result) Then
        MsgBox result, vbOKOnly, AppTitle
        Exit Sub
    End If
    
'    If result <> "" Then
'        MsgBox result, vbOKOnly, AppTitle
'        Exit Sub
'    End If
    
    librayFolderID = CLng(result)
    DebugMsgBox "librayFolderID is: [" & librayFolderID & "]", "bulkloadDialogResult:"
    
    ' REFRESHSCREEN handled by new MVC submit dialog!!!!
    
    ' Let's try and refresh an IE window....
    'RefreshScreen 0, -1, librayFolderID, False

    CloseThisDoc ActiveDocument, ""
End Sub

Public Sub downloadTemplateResult(result As String, Optional bMultiple As Boolean = False)
    Dim lTemplateID As Long
    Dim sLocalPath As String
    Dim nFile As Long
    
    If result = "" Then
        Exit Sub
    End If
    
    'Ensure Folder Exists (will be created as sTempPath)
    modTools.EnsureTempFolderExists

    If InStr(1, result, "|") <= 0 Then
        lTemplateID = CLng(result)
        sLocalPath = sTempPath & "Template_" & lTemplateID & "_" & modTools.GetFileTimeStamp & ".dot" 'Add dotx and
    Else
        Dim resultParts() As String
        resultParts = Split(result, "|")
        lTemplateID = CLng(resultParts(0))
        sLocalPath = sTempPath & "Template_" & lTemplateID & "_" & modTools.GetFileTimeStamp
        If Not GetFileSystemObject.FolderExists(sLocalPath) Then GetFileSystemObject.CreateFolder (sLocalPath)
        sLocalPath = sLocalPath & "\" & resultParts(1)
    End If
    
    DebugMsgBox "Download new template to: [" & sLocalPath & "]", "downloadTemplateResult:"
    
    On Error Resume Next
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetMiscFile(lTemplateID)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    If Not bMultiple Then
        CopyStylesWithHiddenProperty ActiveDocument, sLocalPath
        
        'JSB: 2013/06/06 - attaching style template in case there are toolbars, macros, etc.
        If Not UsingAttachedTemplate(ActiveDocument) Then
            ActiveDocument.UpdateStylesOnOpen = True
            ActiveDocument.AttachedTemplate = sLocalPath
            ActiveDocument.UpdateStyles
            'DS 9/21/18 setting back to false so content doesn't look for template on future edits
            ActiveDocument.UpdateStylesOnOpen = False
        End If
        ' Defect 10660 - Save the file to force a UI update for toolbars.
        oAppClass.doAfterEvent = False
        ActiveDocument.Save
        If gIsMultiEditShowing Then gJobForm.updateModifiedFlag
        oAppClass.doAfterEvent = True
    Else
        modMultiEdit.ApplyStyleTemplatesInternal (sLocalPath)
    End If
End Sub

Public Sub Library(pageMode As LibraryModes)

    Dim searchMode As Integer
    Dim executeSearch As Boolean
    Dim andSearch As String
    Dim orSearch As String
    Dim menuCommand As String
    
    executeSearch = False
    andSearch = ""
    orSearch = ""
    menuCommand = ""
    currentTemplateMode = GetTemplateMode(ActiveDocument)
    Select Case pageMode
        Case LibraryModes.Basic
            searchMode = 1
            executeSearch = True
            orSearch = modTools.GetSearchText
            If currentTemplateMode = "SantRFPFileWordEdit" Then
                menuCommand = "RFPAcceptAnswer"
            End If
        Case LibraryModes.Advanced
            searchMode = 2
            orSearch = modTools.GetSearchText
            If currentTemplateMode = "SantRFPFileWordEdit" Then
                menuCommand = "RFPAcceptAnswer"
            End If
        Case LibraryModes.Browse
            searchMode = 3
            If currentTemplateMode = "SantRFPFileWordEdit" Then
                menuCommand = "RFPAcceptAnswer"
            End If
        Case LibraryModes.LibraryReference
            searchMode = 3
            menuCommand = "saveLibraryReferenceMergeCode"
    End Select
    
    ' Is there an IE session running?
    Dim isPS As Boolean
    isPS = GetIsPS(ActiveDocument)
    
    Dim IsIE As Boolean
    IsIE = GetWebBrowser(isPS)
    DebugMsgBox "IsIE: [" & IsIE & "]", "modWS - Library"
    ' Terminate, just to be safe, because if there IS a current connection, it probably
    ' WON'T be created with TRUE, TRUE..
    terminateWSConnection
    If IsIE Then
        If setupWSConnection(ActiveDocument, False, True) <> ConnectionStatus.worked Then
            Exit Sub
        End If
        ' Yes, so get it to do the work for us.
'        WebBrowserCollection(1).Document.parentWindow.LibrarySearchWin.Search searchMode, executeSearch, andSearch, _
'                                                                              orSearch, "", menuCommand, _
'                                                                              connection.authToken
        BrowserExecScript WebBrowserCollection(1), "LibrarySearchWin.Search(" & searchMode & ",'" & _
                                                                                executeSearch & "','" & _
                                                                                andSearch & "','" & _
                                                                                orSearch & "','','" & _
                                                                                menuCommand & "','" & _
                                                                                connection.authToken & "')"

'        WebBrowserCollection(1).Document.parentWindow.execScript "LibrarySearchWin.Search(" & searchMode & ",'" & _
'                                                                                              executeSearch & "','" & _
'                                                                                              andSearch & "','" & _
'                                                                                              orSearch & "','','" & _
'                                                                                              menuCommand & "','" & _
'                                                                                              connection.authToken & "')"
    Else
        If setupWSConnection(ActiveDocument, True, True) <> ConnectionStatus.worked Then
            Exit Sub
        End If
    End If
    
    'Defect #6610.  Need to put up dialog for LibraryReference (both IE and FF)
    If pageMode = LibraryModes.LibraryReference Or Not IsIE Then
        ' At this point, anything we do will require the search params in the DB,
        ' so let's get them there before we do anything else
        Dim searchParams As structSearchParams
        Set searchParams = New structSearchParams
        searchParams.searchMode = searchMode
        searchParams.executeSearch = executeSearch
        searchParams.orSearch = orSearch
        searchParams.saveCmd = menuCommand
        searchParams.authToken = connection.authToken
        
        DebugMsgBox "authToken: [" & searchParams.authToken & "]", "modWS - Library"
        
        Dim worked As Boolean
        worked = ss.wsm_SaveSearchParams(searchParams)
        
        ' NOTE, ONLY DISCONNECT IF WE FAIL, OTHERWISE THE URL LAUNCH WILL FAIL TO LOG IN
        If Not worked Then
            MsgBox "Failed to store the search in the database. Please try again."
            ss.wsm_ConnectionTerminate
            Exit Sub
        End If
        
        ' Check to see if FF/Chrome Library is running, and if it is, just focus it.
        If Not IsIE And BrowserFocusLibrary(True) Then
            BrowserFocusLibrary
        Else
            ' It is not. Let's see if FF/Chrome is running (no library)
            If Not BrowserFocusQvidian(True, isPS) = NotRunning Then
                MsgBox "Qvidian is currently running in your Browser but the Library window is not open. You'll need to open the Library window."
                BrowserFocusQvidian False, isPS
                DebugMsgBox "No FF Library. Terminating connection", "modWS - Library"
                searchParams.saveCmd = ""
                searchParams.authToken = ""
                worked = ss.wsm_SaveSearchParams(searchParams)
                ss.wsm_ConnectionTerminate
                Exit Sub
            Else
                ' No, so we need to launch a browser window.
                Dim sFile As String
            
                sFile = ss.GetHomeAddress(isPS) & "?AuthenticationToken=" & connection.authToken
                'Only launch if IE is not running
                If Not IsIE Then
                    DebugMsgBox "Launching browser window: [" & sFile & "]", "modWS - Library"
                    Call RunShellExecute("Open", sFile)
                End If
            End If
        End If
    End If
    
    'Defect 6610.  If we made it here and LibraryReference, we need to wait
    If pageMode = LibraryModes.LibraryReference Then
       modWS.ShowExtDialog DialogModes.LibraryReferenceDialog
    End If
    
End Sub

Public Sub AboutClick()
    frmAbout.Show
End Sub

Public Function SaveBuiltDoc(ByRef thisDoc As Document) As Boolean
On Error GoTo ErrorHandler
    Dim originalFileName As String
    originalFileName = thisDoc.FullName
    DebugMsgBox "originalFileName [" & originalFileName & "]", "SaveBuiltDoc:"
    DebugMsgBox "thisDoc.Path: " & thisDoc.path, "SaveBuiltDoc:"
    
    Dim saveFileName As String
    Dim oProp As DocumentProperty
    ' Connect to the Server
    If setupWSConnection(thisDoc) <> ConnectionStatus.worked Then
        SaveBuiltDoc = False
        Exit Function
    End If
    
    ' Save off the custom properties that we do want to keep after the save.
    ' Get the current template mode....
    Dim currentSTMode As String
    currentSTMode = GetTemplateMode(thisDoc)
    DebugMsgBox "current SantTemplateMode: " & currentSTMode, "SaveBuiltDoc:"
    Dim tmpServer As String
    tmpServer = modDocProperties.GetPropertyText("Server", thisDoc)
    DebugMsgBox "tmpServer = [" & tmpServer & "]", "SaveBuiltDoc:"
   
    ' Clean out the custom properties
    On Error Resume Next
    For Each oProp In thisDoc.CustomDocumentProperties
        oProp.Delete
    Next
    On Error GoTo ErrorHandler
    
    ' Re-save the document so the properties get removed...
    thisDoc.Saved = False
    thisDoc.Save
    
    ' What mode are we running in?
    DebugMsgBox "AttachedTemplate is [" & thisDoc.AttachedTemplate.FullName & "]", "SaveBuiltDoc:"
    DebugMsgBox "AttachedTemplate is [" & thisDoc.AttachedTemplate.path & "]", "SaveBuiltDoc:"
    DebugMsgBox "AttachedTemplate is [" & thisDoc.AttachedTemplate & "]", "SaveBuiltDoc:"
    If LCase(thisDoc.AttachedTemplate) = "qvidian.dotm" Or FileOpsUnavailable(thisDoc.FullName) Then
        ' Ensure temporary folder exists (will be created as sBuildTempPath)
        modTools.EnsureBuildTempFolderExists
        
        ' Disable spelling and grammar checking!
        thisDoc.showGrammaticalErrors = False
        thisDoc.showSpellingErrors = False
        
        Dim saveDoc As Document
        Dim desiredExt As String
        desiredExt = modTools.GetProperExtension(thisDoc)
        saveFileName = sBuildTempPath & "Build_" & modTools.GetFileTimeStamp & "." & desiredExt
        DebugMsgBox "saveFileName: " & saveFileName, "SaveBuiltDoc:"
        
        Dim tmpFileName As String
        tmpFileName = sBuildTempPath & "TmpUploaded_" & modTools.GetFileTimeStamp & "." & desiredExt
        DebugMsgBox "tmpFileName: " & tmpFileName, "SaveBuiltDoc:"
        
        ' Save the file...
        thisDoc.SaveAs tmpFileName, , , , False
        
        ' Reset the Document name
        thisDoc.SaveAs originalFileName, , , , False
        
        ' Re-enable spelling and grammar checking!
        thisDoc.showGrammaticalErrors = True
        thisDoc.showSpellingErrors = True

        GetFileSystemObject.copyFile tmpFileName, saveFileName
        
        DebugMsgBox "Open the copied file...", "SaveBuiltDoc:"
        Set saveDoc = Documents.Open(saveFileName, False, False, False, , , , , , , , False)
    
        ' Dettach templates
        saveDoc.AttachedTemplate = ""
        saveDoc.Saved = False
        saveDoc.Save
        On Error Resume Next
        saveDoc.Close

    Else
        saveFileName = thisDoc.FullName
    End If
        
    ' Upload the file
    Dim uploadParams As struct_UploadParams
    Set uploadParams = New struct_UploadParams
    uploadParams.SantTemplateMode = "SantPostBuild"
    uploadParams.TemplateMode = 24
    uploadParams.projectID = thisProjectID
    DebugMsgBox "Project ID is " & thisProjectID, "SaveBuiltDoc:"
    uploadParams.CRMNoteText = sCRMNoteText
    uploadParams.AddCRMNote = CBool(Len(sCRMNoteText) > 0)
    DebugMsgBox "Call wsm_UploadFile: " & originalFileName, "SaveBuiltDoc:"
    Dim result As String
    'result = ss.wsm_UploadFile(uploadParams, originalFileName, GetFile(saveFileName))
    result = ss.wsm_UploadFileChunk(uploadParams, originalFileName, saveFileName)
    DebugMsgBox "wsm_UploadFile gave a result of: " + result, "SaveBuiltDoc:"
    
    ' Close the WS connection
    ss.wsm_ConnectionTerminate
    
    ' "Reset" the properties we saved.
    modDocProperties.WriteProperty "SantTemplateMode", currentSTMode, thisDoc
    modDocProperties.WriteProperty "Server", tmpServer, thisDoc
    modDocProperties.WriteProperty "ProjectID", thisProjectID, thisDoc
    
    If result = "" Then
        SaveBuiltDoc = True
    Else
        SaveBuiltDoc = False
        If Len(result) > 0 Then
            MsgBox "The following issues occurred during upload, and the build file has not been saved: " & result, vbOKOnly, AppTitle
        Else
            MsgBox "Any error occurred during upload, and the build file has not been saved.", vbOKOnly, AppTitle
        End If
    End If
    
    Exit Function
ErrorHandler:
    SaveBuiltDoc = False
End Function

Public Function FileOpsUnavailable(path As String) As Boolean
On Error GoTo eh
    Dim l As Long
    l = FileLen(path)   ' use this to test if file operations will be successful
    FileOpsUnavailable = False
Exit Function
eh:
    DebugMsgBox "File operations not available for " & path, "FileOpsUnavailable:"
    FileOpsUnavailable = True
End Function

Public Function SaveOrSaveAsWS(ByRef thisDoc As Document, ByRef bClearBuiltInProps As Boolean, _
                               ByRef bClearCustomProps As Boolean, ByVal selectedText As Boolean, _
                               ByRef saveFileName As String, ByRef tmpFileName As String) As Boolean
On Error GoTo ErrorHandler
    modInit.ActivateCurrent
    DebugMsgBox "", "SaveOrSaveAsWS:"
    
    ' Ensure temporary folder exists (will be created as sBuildTempPath)
    modTools.EnsureBuildTempFolderExists
    
    Dim saveDoc As Document
    Dim desiredExt As String
    desiredExt = modTools.GetProperExtension(thisDoc)
    saveFileName = sBuildTempPath & "Uploaded " & modTools.GetFileTimeStamp & "." & desiredExt
    DebugMsgBox "saveFileName: " & saveFileName, "SaveOrSaveAsWS:"
    tmpFileName = ""
    
    Dim currentBM As Bookmark
    If selectedText Then
        'Select appropriate text
        modTools.SelectTextForSubmit thisDoc, thisDoc.ActiveWindow
        
        Set currentBM = GetCurrentSantBookmark(thisDoc, thisDoc.ActiveWindow)
        If Not currentBM Is Nothing Then
           submitBookmark = currentBM.name
        End If
        
        'Create a new doc
        Set saveDoc = Documents.Add
        saveDoc.Activate
        Dim thisDestWindow As Window
        Set thisDestWindow = saveDoc.ActiveWindow
        
        'Copy from source
        thisDoc.ActiveWindow.Selection.Copy
        DoEvents
    
        'Paste in Dest
        thisDestWindow.Selection.WholeStory
        thisDestWindow.Selection.Paste
    
        'Save dest doc.
        saveDoc.SaveAs saveFileName, , , , False
            
        On Error Resume Next
        saveDoc.Close
    Else
        ' We are going to save the current document to a new document, then
        ' Open it and do all processing on that file. This is the only
        ' (easy) way to deal with detaching the template without the macros
        ' terminating!
        DebugMsgBox "thisDoc.Path: " & thisDoc.path, "SaveOrSaveAsWS:"
        DebugMsgBox "thisDoc.FullName: " & thisDoc.FullName, "SaveOrSaveAsWS:"
      
        If thisDoc.path = "" Then
            Set saveDoc = thisDoc
            saveDoc.SaveAs saveFileName, , , , False
        Else
            tmpFileName = sBuildTempPath & "TmpUploaded " & modTools.GetFileTimeStamp & "." & desiredExt
            DebugMsgBox "tmpFileName: " & tmpFileName, "SaveOrSaveAsWS:"
            
            ' Get the current template mode....
            Dim currentSTMode As String
            currentSTMode = GetTemplateMode(thisDoc)
            DebugMsgBox "current SantTemplateMode: " & currentSTMode, "SaveOrSaveAsWS:"
            
            ' Remove it from the file before we save....
            modDocProperties.RemoveProperty "SantTemplateMode", thisDoc
            
            ' Save the file...
            thisDoc.SaveAs tmpFileName, , , , False
            
            ' Now set the template mode back again...
            modDocProperties.WriteProperty "SantTemplateMode", currentSTMode, thisDoc

            GetFileSystemObject.copyFile tmpFileName, saveFileName
        
            ' Defect 9201 Fix: Modified Open to be visible to apply current view type (e.g. Print Layout, Draft, etc...)
            DebugMsgBox "Open the copied file...", "SaveOrSaveAsWS:"
            Set saveDoc = Documents.Open(saveFileName, False, False, False, , , , , , , , True)
        
            If bClearBuiltInProps Then
                ClearBuiltInProperties saveDoc
            End If
        
            If bClearCustomProps Then
                ClearCustomProperties saveDoc
            Else
                RemoveWordCustomProperties saveDoc
            End If
        
            ' Detach templates
            If UsingAttachedTemplate(saveDoc) Then
                saveDoc.AttachedTemplate = ""
            End If
            saveDoc.Saved = False
            saveDoc.Save
            
            On Error Resume Next
            saveDoc.Close
        End If
    End If
    
    SaveOrSaveAsWS = True
    Exit Function
ErrorHandler:
    If Application.Dialogs(wdDialogFileSaveAs).Show = 0 Then
        SaveOrSaveAsWS = False
    Else
        Application.Dialogs(wdDialogFileSaveAs).Execute
        SaveOrSaveAsWS = True
    End If
End Function

Public Sub CallSantSupport()
    Call RunShellExecute("Open", "http://qvidian.com/community")
End Sub

Public Sub CallHelp()
    CallContextHelp -1
End Sub

Public Sub CallContextHelp(helpID As Integer)
    If helpID = -1 Then
        Dim sMode As String
        sMode = GetTemplateMode(ActiveDocument)
        Select Case sMode
            Case "SantRFPFileWordEdit", "SantRFPCompareContent"
                If GetPropertyText("ForMarking", ActiveDocument) = "1" Then
                    'Burst
                    helpID = 169
                ElseIf GetPropertyText("CheckedOutRecords", ActiveDocument) = "" Then
                    'Individual
                    helpID = 69
                Else
                    'RFP Team
                    helpID = 222
                End If
            Case "SantWordEdit", "SantWordMultiEdit", "SantCompareContent"
                helpID = 87
            Case "PSSubmit"
                helpID = 74
            Case ""
                helpID = 21
            Case "SantFileListWordEdit"
                helpID = 191
            Case "SantWordBulkLoad"
                helpID = 17
            Case "SantPostBuild", "SantWordBuild"
                helpID = 201
            Case "SantRFPFileWordView"
                helpID = 223
            Case "SantWordView"
                helpID = 202
            Case "SantStructure"
                helpID = 104
            Case "BulkloadLaunch", "SantCopyAndClose", "SantCopyAndOpen", "SantScriptedCopy"
                MsgBox "Help is not available in this mode."
            Case Else
                MsgBox "Help is not currently available in this mode."
        End Select
    End If
    
    Dim isPS As Boolean
    isPS = GetIsPS(ActiveDocument)
    If GetWebBrowser(isPS) Then
        BrowserExecScript WebBrowserCollection(1), "showSectionHelp(" & helpID & ")"
        'WebBrowserCollection(1).Document.parentWindow.execScript "showSectionHelp(" & helpID & ")"
    Else
        ' No, so we need to launch a browser window.
        If setupWSConnection(ActiveDocument, True, False) <> ConnectionStatus.worked Then
            Exit Sub
        End If
    
        ' Launch the UI....
        Dim sFile As String
        sFile = ss.GetHomeAddress(isPS) & "?AuthenticationToken=" & connection.authToken & "&ShowHelp=" & helpID

        Call RunShellExecute("Open", sFile)
        
        ' We can call Terminate here because we never actually set up a
        ' WS connection, just a QPA connection! Doing this will mean that
        ' if somebody calls setupWSConnection again, then if the previously
        ' opened window has been closed it WILL open another one.
        ss.wsm_ConnectionTerminate
    End If
End Sub

Public Function DownloadContentFile(ByVal sLocalPath As String, ByVal thisDoc As Document, ByVal thisContentID As Long, _
                                    Optional ByVal thisRevision As Long = -1, Optional ByVal thisJobID As String = "")
    If setupWSConnection(thisDoc) <> ConnectionStatus.worked Then
        Exit Function
    End If
    
    If GetFileSystemObject.FileExists(sLocalPath) Then
        DownloadContentFile = True
        Exit Function
    End If
    DebugMsgBox "File does not already exist [" & sLocalPath & "], get new version...", "DownloadContentFile:"
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetContentFile(thisContentID, thisRevision, False, thisJobID)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    DoEvents
    DownloadContentFile = True
End Function

Public Function DownloadCompositeContentFile(ByVal sLocalPath As String, ByVal thisDoc As Document, ByVal thisJobID As String)
    If setupWSConnection(thisDoc) <> ConnectionStatus.worked Then
        Exit Function
    End If
    
    If GetFileSystemObject.FileExists(sLocalPath) Then
        DownloadCompositeContentFile = True
        Exit Function
    End If
    DebugMsgBox "File does not already exist [" & sLocalPath & "], get new version...", "DownloadCompositeContentFile:"
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetContentFile(-1, -1, False, thisJobID)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    DoEvents
    DownloadCompositeContentFile = True
End Function

Public Function DownloadExportFile(ByVal sLocalPath As String, ByVal thisDoc As Document, ByVal thisContentIDs As String)
    If setupWSConnection(thisDoc) <> ConnectionStatus.worked Then
        Exit Function
    End If
    
    If GetFileSystemObject.FileExists(sLocalPath) Then
        DownloadExportFile = True
        Exit Function
    End If
    Dim nFile As Long
    Dim mfsData() As Byte
    mfsData = ss.wsm_GetExportFile(thisContentIDs)
    nFile = FreeFile
    Open sLocalPath For Binary Access Read Write Lock Write As #nFile
    Put #nFile, , mfsData
    Close #nFile
    DoEvents
    DownloadExportFile = True
End Function

Attribute VB_Name = "modWSTools"
Option Explicit

Public Enum ConnectionStatus
    worked = 0
    TemplatesOutOfDate = 1
    Cancelled = 2
    Error = 3
End Enum

Private Const MAXLEN = 256
Public Const KEY_READ = &H20019
Public Const HKEY_CURRENT_USER = &H80000001
Private Const SW_SHOW As Long = 5
Private Const SW_SHOWDEFAULT As Long = 10

Private Const key As String = "hZr$2qh*7bw?!==hqxcat"

#If Win64 Then
Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr
Private Declare PtrSafe Function GetDesktopWindow Lib "user32" () As LongPtr
#Else
Public Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParams As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Private Declare Function GetDesktopWindow Lib "user32" () As Long
#End If
Public UserID As String
Public password As String
Public bSingleSignOn As Boolean

' QPA-11367: MOLO 05/12/2016
' QvidianServer variable used for managing server specific user credentials
Public QvidianServer As String

Public Function GetFile(ByVal fileName As String) As Variant
    Dim FileContents() As Byte
    Dim totalLength As Long
    Dim bufferSize As Long
    Dim FileNumber As Integer
    
    totalLength = FileLen(fileName)
    ReDim FileContents(totalLength - 1)
    FileNumber = FreeFile
    Open fileName For Binary As FileNumber
    Get FileNumber, , FileContents
    Close (FileNumber)
    GetFile = FileContents
End Function

Public Sub terminateWSConnection()
    If Not ss Is Nothing Then
        ss.wsm_ConnectionTerminate
    End If
End Sub

Public Function setupWSConnection(thisDoc As Document, Optional qpaLogin As Boolean = False, _
                                  Optional wsLogin As Boolean = True, Optional xmlServer As String = "") As ConnectionStatus

    setupWSConnection = ConnectionStatus.worked
    If Not ss Is Nothing Then
        If ss.IsConnected Then
            ' We want to validate that the token has NOT timed out.
            DebugMsgBox "Currently connected, with token [" & connection.authToken & "]", "setupWSConnection:"
            
            ' We're going to call GetFormattedValue to validate if there are problems
            Dim retVal As String
            On Error Resume Next
            retVal = ss.wsm_GetFormattedValue("validate", "Z", "", "")
            DebugMsgBox "wsm_GetFormattedValue gave [" & retVal & "] and ErrNo = " & Err.Number, "setupWSConnection:"
            If Err.Number = 0 And retVal = "validate" Then
                DebugMsgBox "The token is still valid", "setupWSConnection:"
                Exit Function
            End If
            DebugMsgBox "The token is NOT valid any more", "setupWSConnection:"
            Set ss = Nothing
        End If
    End If
    
    Dim portalServer As String
    If xmlServer = "" Then
        portalServer = GetPassedServer(thisDoc)
    Else
        portalServer = xmlServer
    End If
    If portalServer = "" Then
        setupWSConnection = ConnectionStatus.Error
        Exit Function
    End If
    DebugMsgBox "portalServer is [" & portalServer & "]", "setupWSConnection:"
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    QvidianServer = portalServer
    
    ' Do we need to check the registry?
    If Not bSingleSignOn And (UserID = "" Or password = "") Then
        getLoginCredentials UserID, password, bSingleSignOn
    End If
    
    On Error Resume Next
    Set ss = New clsws_Qvidian
    DebugMsgBox "call PortalURL with [" & portalServer & "]", "setupWSConnection:"
    ss.PortalURL portalServer
    
    Do
        ' If we still have nothing, then prompt...
        While Not bSingleSignOn And (UserID = "" Or password = "")
            If changeLoginCredentials(False) Then
                DebugMsgBox "changeLoginCredentials cancelled out of", "setupWSConnection:"
                setupWSConnection = ConnectionStatus.Cancelled
                Exit Function
            End If
        Wend
    
        If bSingleSignOn Then
            UserID = GetSingleSignOnUser
            DebugMsgBox "SSO UserID: " & UserID, "setupWSConnection:"
            password = ""
        End If
            
        DebugMsgBox "call wsm_Connect", "setupWSConnection:"
        Set connection = ss.wsm_Connect(UserID, password, qpaLogin, wsLogin)
        If ss.ErrorCode > 0 Then
            If ss.ErrorCode = 2002 Then
                DebugMsgBox "Wrong credentials!!!", "setupWSConnection:"
                MsgBox ss.ErrorMessage & ". Please try again."
                UserID = ""
                password = ""
                bSingleSignOn = False
            Else
                DebugMsgBox ss.ErrorMessage, "setupWSConnection:"
                MsgBox ss.ErrorMessage
                setupWSConnection = ConnectionStatus.Error
                Exit Function
            End If
        Else
            ' US4436 - Remove the dependency onversion number.
            ' Check to see if we are matching the write Major/Minor release...
            'If Not connection.ProductMinorVersion = ProductVersion Then
            '    DebugMsgBox "Wrong Qvidian Server version! [" & connection.ProductMinorVersion & "] != [" & ProductVersion & "]", "setupWSConnection:"
            '    MsgBox "These QPA Add-ins require a " & ProductVersion & " Qvidian server version. Please download the correct Add-ins before performing any Qvidian operations."
            '    setupWSConnection = ConnectionStatus.TemplatesOutOfDate
            '    ss.wsm_ConnectionTerminate
            '    Exit Function
            'End If
            ' Check to see if we are out-of-date...
            If connection.RequiredVersion > TemplateVersion Then
                DebugMsgBox "Wrong version! [" & connection.RequiredVersion & "] > [" & TemplateVersion & "]", "setupWSConnection:"
                MsgBox "The QPA Add-ins are out-of-date. Please download the latest Add-ins before performing any Qvidian operations."
                setupWSConnection = ConnectionStatus.TemplatesOutOfDate
                ss.wsm_ConnectionTerminate
                Exit Function
            End If
        End If
    Loop Until ss.ErrorCode = 0
    DebugMsgBox "authToken = [" & connection.authToken & "]", "setupWSConnection:"
    DebugMsgBox "ServerURL = [" & connection.ServerURL & "]", "setupWSConnection:"
    DebugMsgBox "setupWSConnection = [" & setupWSConnection & "]", "setupWSConnection:"
    ss.ConnectToURL connection.ServerURL
End Function

Public Function changeLoginCredentials(allowReset As Boolean) As Boolean

    changeLoginCredentials = False
    
    getLoginCredentials UserID, password, bSingleSignOn

    Dim login As New frmLogin
    login.SetAllowReset allowReset
    Dim result As Integer
    login.Show
    
    If login.bCanceled Then
        DebugMsgBox "Cancel out", "changeLoginCredentials:"
        changeLoginCredentials = True
        Exit Function
    End If
    
    UserID = login.UserID
    password = login.password
    bSingleSignOn = login.xbSingleSignOn
    DebugMsgBox "Login Credentials are: " & UserID & ", ******, SSO = " & bSingleSignOn, "changeLoginCredentials:"
    If login.bRemember Then
        modWSTools.setLoginCredentials UserID, password, bSingleSignOn
    End If
End Function

Public Sub RunShellExecute(sTopic As String, sFile As Variant)

#If Win64 Then
    Dim hWndDesk As LongPtr
    Dim success As LongPtr
#Else
    Dim hWndDesk As Long
    Dim success As Long
#End If
  
    DebugMsgBox "sTopic=" & sTopic, "RunShellExecute:"
    DebugMsgBox "sFile=" & sFile, "RunShellExecute:"
    
    'the desktop will be the
    'default for error messages
    hWndDesk = GetDesktopWindow()
  
    'execute the passed operation
    success = ShellExecute(hWndDesk, sTopic, sFile, vbNullString, vbNullString, SW_SHOW)
End Sub

Public Sub getLoginCredentials(ByRef UserID As String, ByRef password As String, ByRef singleSignOn As Boolean)
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials

    ' Get the info from the registry...
    UserID = getRegUserString("HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\UserID")
    Dim encPassword As String
    encPassword = getRegUserString("HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\Password")
    'DebugMsgBox "encPassword is [" & encPassword & "]", "getLoginCredentials:"
    password = rdDecryptString(encPassword, key)
    'DebugMsgBox "password is [" & password & "]", "getLoginCredentials:"
    singleSignOn = getRegUserBoolean("HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\SingleSignOn")
End Sub

Public Sub setLoginCredentials(ByVal UserID As String, ByVal password As String, ByVal singleSignOn As Boolean)
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials

    ' Get the info from the registry...
    setRegUserString "HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\UserID", UserID
    Dim encPassword As String
    'DebugMsgBox "password is [" & password & "]", "setLoginCredentials:"
    encPassword = rdEncryptString(password, key)
    'DebugMsgBox "encPassword is [" & encPassword & "]", "setLoginCredentials:"
    setRegUserString "HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\Password", encPassword
    setRegUserBoolean "HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\SingleSignOn", singleSignOn
End Sub

Public Sub resetLoginCredentials()
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials

    ' Get the info from the registry...
    setRegUserString "HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\UserID", ""
    setRegUserString "HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\Password", ""
    setRegUserBoolean "HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\SingleSignOn", False
End Sub

Public Function getRegUserString(ByRef keyID As String) As String
    getRegUserString = RegKeyRead(keyID)
End Function

Private Sub setRegUserString(ByRef keyID As String, newValue As String)
    RegKeySave keyID, newValue
End Sub

Private Sub setRegUserBoolean(ByRef keyID As String, newValue As Boolean)
    Dim tmpVal As String
    If newValue Then
        tmpVal = "1"
    Else
        tmpVal = "0"
    End If
    RegKeySave keyID, tmpVal, "REG_DWORD"
End Sub

Private Function getRegUserBoolean(ByRef keyID As String) As Long
    Dim tmpBuf As String
    tmpBuf = RegKeyRead(keyID)
    Debug.Print tmpBuf
   
    If tmpBuf = "1" Then
        getRegUserBoolean = True
    Else
        getRegUserBoolean = False
    End If
End Function

Public Function getRegUserDword(ByRef keyID As String) As Integer
    Dim tmpBuf As String
    tmpBuf = RegKeyRead(keyID)
    Debug.Print tmpBuf
    
    If tmpBuf = "" Then
        getRegUserDword = -1
    Else
        getRegUserDword = CInt(tmpBuf)
    End If
End Function

Public Sub setRegUserDword(ByRef keyID As String, tmpVal As Integer)
    RegKeySave keyID, CStr(tmpVal), "REG_DWORD"
End Sub

Function RegKeyRead(i_RegKey As String) As String
Dim myWS As Object

  On Error Resume Next
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'read key from registry
  RegKeyRead = myWS.RegRead(i_RegKey)
End Function

Sub RegKeySave(i_RegKey As String, i_Value As String, Optional i_Type As String = "REG_SZ")
Dim myWS As Object

  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'write registry key
  myWS.RegWrite i_RegKey, i_Value, i_Type

End Sub

Public Function HTMLEncode(ByVal Text As String, Optional HardSpaces As Boolean = False) As String
    Dim i As Integer
    Dim ch As String
    Dim NewString As String


    For i = 1 To Len(Text)
        ch = Mid$(Text, i, 1)
        Select Case ch
            Case " "
                If HardSpaces Then ch = "&nbsp;"
            Case """"
                ch = "&quot;"
            Case "&"
                ch = "&amp;"
            Case "<"
                ch = "&lt;"
            Case ">"
                ch = "&gt;"
            Case " " To "~"
                ' Not one we already processed but
                ' but in the normal display range
            Case Else
                ch = "&#" & Asc(ch) & ";"
        End Select
        NewString = NewString & ch
    Next
    HTMLEncode = NewString
End Function

Public Function URLEncode(ByVal Text As String) As String
    Dim i As Integer
    Dim ch As String
    Dim NewString As String


    For i = 1 To Len(Text)
        ch = Mid$(Text, i, 1)
        Select Case ch
            Case " "
                ch = "+"
            Case "+"
                ch = "%2B"
            Case "&"
                ch = "%26"
            Case "/"
                ch = "%2F"
            Case "\"
                ch = "%5C"
            Case ":"
                ch = "%23"
            Case "#"
                ch = "%3A"
            Case "|"
                ch = "%7C"
            Case " " To "~"
                ' Not one we already processed but
                ' but in the normal display range
            Case Else
                'ch = "%" & Right("00" & Hex(Asc(ch)), 2)
        End Select
        NewString = NewString & ch
    Next
    URLEncode = NewString
End Function

Public Sub RemoveWordCustomProperties(ByRef Doc As Document)
    modDocProperties.RemoveProperty "ProcessStarted", Doc
    modDocProperties.RemoveProperty "SantTemplateMode", Doc
    modDocProperties.RemoveProperty "TemplateMode", Doc
    modDocProperties.RemoveProperty "Server", Doc
    modDocProperties.RemoveProperty "UserID", Doc
    modDocProperties.RemoveProperty "CheckedOutRecords", Doc
    modDocProperties.RemoveProperty "RFPFileID", Doc
    modDocProperties.RemoveProperty "ForMarking", Doc
    modDocProperties.RemoveProperty "IsMarked", Doc
    modDocProperties.RemoveProperty "IsPS", Doc
    modDocProperties.RemoveProperty "ProjectID", Doc
    modDocProperties.RemoveProperty "CRMNoteText", Doc
    modDocProperties.RemoveProperty "AddCRMNote", Doc
    modDocProperties.RemoveProperty "UseBuildSettings", Doc
    modDocProperties.RemoveProperty "DontUseTemplate", Doc
    modDocProperties.RemoveProperty "AutoSave", Doc
    modDocProperties.RemoveProperty "PageSize", Doc
    modDocProperties.RemoveProperty "PageOrientation", Doc
    modDocProperties.RemoveProperty "FirstPageTray", Doc
    modDocProperties.RemoveProperty "OtherPagesTray", Doc
    modDocProperties.RemoveProperty "BuildToPDF", Doc
    modDocProperties.RemoveProperty "ReplaceMergeCodes", Doc
    modDocProperties.RemoveProperty "PrintAllSelections", Doc
    modDocProperties.RemoveProperty "ReplaceMergeCodes", Doc
    modDocProperties.RemoveProperty "PrintAllSelections", Doc
    modDocProperties.RemoveProperty "TemplateID", Doc
    modDocProperties.RemoveProperty "TemplateFileName", Doc
    modDocProperties.RemoveProperty "ErrorMessage", Doc
    modDocProperties.RemoveProperty "MappingInfoToSelect", Doc
    modDocProperties.RemoveProperty "MiscFileID", Doc
    modDocProperties.RemoveProperty "ContentID", Doc
    modDocProperties.RemoveProperty "Revision", Doc
    modDocProperties.RemoveProperty "SantCompareQuAID", Doc
    modDocProperties.RemoveProperty "SantCompareContentID", Doc
    modDocProperties.RemoveProperty "SantCompareExt", Doc
    modDocProperties.RemoveProperty "SantCompareContentID1", Doc
    modDocProperties.RemoveProperty "SantCompareRevision1", Doc
    modDocProperties.RemoveProperty "SantCompareContentID2", Doc
    modDocProperties.RemoveProperty "SantCompareRevision2", Doc
    modDocProperties.RemoveProperty "SantCompareRev2Ext", Doc
    modDocProperties.RemoveProperty "BulkloadPath", Doc
    modDocProperties.RemoveProperty "ContentMetadataSettings", Doc
    modDocProperties.RemoveProperty "SantUserAlert", Doc
    modDocProperties.RemoveProperty "AutoOpen", Doc
End Sub

Public Function RefreshScreen(ByVal refreshType As Integer, ByVal fileID As Long, ByVal folderID As Long, isPS As Boolean) As Boolean
    DebugMsgBox "refreshType = [" & refreshType & "], fileID = [" & fileID & "], folderID = [" & folderID & "], isPS = [" & isPS & "]", "RefreshScreen:"

    RefreshScreen = False
    On Error Resume Next
    If GetWebBrowser(isPS) Then
        Dim webBrowser As Object
        For Each webBrowser In WebBrowserCollection
            DebugMsgBox "Call browser, we found one...", "RefreshScreen:"
            'webBrowser.Document.parentWindow.editComplete refreshType, fileID, folderID
            BrowserExecScript webBrowser, "editComplete(" & refreshType & "," & fileID & "," & folderID & ")"
            'webBrowser.Document.parentWindow.execScript "editComplete(" & refreshType & "," & fileID & "," & folderID & ")"
            RefreshScreen = True
        Next webBrowser
    End If
End Function

Public Function GetSingleSignOnUser() As String
    GetSingleSignOnUser = ""
    On Error GoTo ErrorHandler
    
    ' QPA-11367: MOLO 05/12/2016
    ' QvidianServer variable used for managing server specific user credentials
    
    Dim encSSOUser As String
    encSSOUser = getRegUserString("HKEY_CURRENT_USER\Software\Qvidian\" & QvidianServer & "\SingleSignOnUser")
    GetSingleSignOnUser = rdDecryptString(encSSOUser, key)
    Exit Function
ErrorHandler:
    GetSingleSignOnUser = ""
End Function

Attribute VB_Name = "modX"
Global GlobalSantTemplate As template

Public Sub TestAutoText()
    InsertAutoTextVersionSafe "SantAnswerBar", ActiveWindow, SantTemplate
End Sub

Public Function SantTemplate() As template
    If TypeName(GlobalSantTemplate) = "Nothing" Then
        Set GlobalSantTemplate = GetTemplateReference()
    End If
    Set SantTemplate = GlobalSantTemplate
End Function

Private Sub HowToGetTemplateReference()
    Dim t As template
    Set t = GetTemplateReference("Qvidian.dot")
    If TypeName(t) = "Nothing" Then
        MsgBox "The template Qvidian.dot was not found."
    End If
End Sub

Public Function GetTemplateReference(Optional ByVal thisName As String = "") As template
    Dim t As template
    If thisName = "" Then
        If modRibbonNOCOPY.TEMPLATETYPE = 2003 Then
            thisName = "Qvidian.dot"
        Else
            thisName = "Qvidian.dotm"
        End If
    End If
    For Each t In Application.Templates
        'MsgBox t.name
        If LCase(t.name) = LCase(thisName) Then
            Set GetTemplateReference = t
            Exit Function
        End If
    Next t
End Function

'thisTemplate intentionally left as object, so that compile errors won't occur when referencing properties that differ between versions.
Public Sub InsertAutoTextVersionSafe(ByVal thisAutoText As String, ByRef thisWindow As Window, ByRef thisTemplate As Object)
    If getVersion > 11 Then
        thisTemplate.BuildingBlockEntries(thisAutoText).Insert Where:=thisWindow.Selection.Range, RichText:=True
    Else
        thisTemplate.AutoTextEntries(thisAutoText).Insert Where:=thisWindow.Selection.Range, RichText:=True
    End If
End Sub
Attribute VB_Name = "structBrowser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If Win64 Then
Public hWnd As LongPtr
#Else
Public hWnd As Long
#End If
Public title As String
Public Classname As String
Public BrowserType As BrowserType

Attribute VB_Name = "structSearchParams"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public searchMode As Integer
Public executeSearch As Boolean
Public andSearch As String
Public orSearch As String
Public saveCmd As String
Public authToken As String

Attribute VB_Name = "struct_CMD"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public cmID As Long
Public DataType As Integer
Public Required As Boolean
Public Value As String

Public MetadataModified As Boolean
Public ChangedValue As Boolean
Public UpdatedValue As String

Private Sub Class_Initialize()
    ChangedValue = False
    MetadataModified = False
End Sub

Public Sub getCMDProperties(contentNode As IXMLDOMNode)

    Dim attrib As IXMLDOMAttribute
    MetadataModified = False
    For Each attrib In contentNode.Attributes
        Select Case attrib.name
            Case "CMID"
                cmID = CLng(attrib.Text)
                'DebugMsgBox "getCMDProperties: CMID = " & attrib.Text
            Case "DataType"
                DataType = CInt(attrib.Text)
            Case "Required"
                If UCase(attrib.Text) = "TRUE" Then
                    Required = True
                Else
                    Required = False
                End If
            Case "Value"
                Value = attrib.Text
            Case "ChangedValue"
                If UCase(attrib.Text) = "TRUE" Then
                    ChangedValue = True
                    MetadataModified = True
                Else
                    ChangedValue = False
                End If
            Case "UpdatedValue"
                UpdatedValue = attrib.Text
        End Select
    Next
    
    ' If it's a date field, we have to convert it.
    If DataType = CMDataTypes.DateType Then
        If Value <> "" Then
            Value = GetLocalFromUTC(CDate(Value))
        End If
        If UpdatedValue <> "" Then
            UpdatedValue = GetLocalFromUTC(CDate(UpdatedValue))
        End If
    End If
End Sub


Attribute VB_Name = "struct_CMDDef"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public cmID As Long
Public CMType As Integer
Public DataType As Integer
Public DisplayName As String
Public Required As Boolean
Public Editable As Boolean
Public ValidationRegex As String
Public DefaultValue As String
Public TextAreaRows As Integer
Public MaxTextLength As Integer
Public MaxTextLengthSet As Boolean
Public MinNumericValue As Double
Public MinNumericValueSet As Boolean
Public MaxNumericValue As Double
Public MaxNumericValueSet As Boolean

Public ddItems As Collection

Private Sub Class_Initialize()
    cmID = -1
    MaxTextLengthSet = False
    MinNumericValueSet = False
    MaxNumericValueSet = False
    Required = False
    TextAreaRows = 1
    ValidationRegex = ""
    Set ddItems = New Collection
End Sub

Public Sub getCMDProperties(contentNode As IXMLDOMNode)

    Dim attrib As IXMLDOMAttribute
    For Each attrib In contentNode.Attributes
        Select Case attrib.name
            Case "CMID"
                cmID = CLng(attrib.Text)
                'DebugMsgBox "getCMDProperties: CMID = " & attrib.Text
            Case "CMType"
                CMType = CInt(attrib.Text)
            Case "DataType"
                DataType = CInt(attrib.Text)
            Case "DisplayName"
                DisplayName = attrib.Text
            Case "Required"
                If UCase(attrib.Text) = "TRUE" Then
                    Required = True
                Else
                    Required = False
                End If
            Case "Editable"
                If UCase(attrib.Text) = "TRUE" Then
                    Editable = True
                Else
                    Editable = False
                End If
            Case "ValidationRegex"
                ValidationRegex = attrib.Text
            Case "DefaultValue"
                DefaultValue = attrib.Text
            Case "TextAreaRows"
                If attrib.Text = "" Then
                    TextAreaRows = 1
                Else
                    TextAreaRows = CInt(attrib.Text)
                End If
            Case "MaxTextLength"
                If attrib.Text = "" Then
                    MaxTextLengthSet = False
                Else
                    MaxTextLength = CInt(attrib.Text)
                    MaxTextLengthSet = True
                End If
            Case "MinNumericValue"
                If attrib.Text = "" Then
                    MinNumericValueSet = False
                Else
                    MinNumericValue = CDbl(attrib.Text)
                    MinNumericValueSet = True
                End If
            Case "MaxNumericValue"
                If attrib.Text = "" Then
                    MaxNumericValueSet = False
                Else
                    MaxNumericValue = CDbl(attrib.Text)
                    MaxNumericValueSet = True
                End If
        End Select
    Next
    
    If DataType = CMDataTypes.DropDownType Or DataType = CMDataTypes.MultiValueType Then
        ' Drop-down values...
        Dim xmlList As IXMLDOMNodeList
        Dim cmdNode As IXMLDOMNode
        Set cmdNode = contentNode.SelectSingleNode("CustomMetaDropDownValues")
        If Not cmdNode Is Nothing Then
            Set xmlList = cmdNode.SelectNodes("CustomMetaDropDownValue")
            If Not xmlList Is Nothing And xmlList.Length > 0 Then
                For Each cmdNode In xmlList
                    Dim ddItem As struct_CMDDefItem
                    Set ddItem = New struct_CMDDefItem
                    
                    ' Load the meta-data
                    ddItem.getCMDItemProperties cmdNode
                    ddItems.Add ddItem
                Next
            End If
        End If
    End If
End Sub

Attribute VB_Name = "struct_CMDDefItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public DropdownValueText As String
Public IsDefault As Boolean

Private Sub Class_Initialize()
    IsDefault = False
End Sub

Public Sub getCMDItemProperties(itemNode As IXMLDOMNode)

    Dim attrib As IXMLDOMAttribute
    For Each attrib In itemNode.Attributes
        Select Case attrib.name
            Case "DropdownValueText"
                DropdownValueText = attrib.Text
            Case "IsDefault"
                If UCase(attrib.Text) = "TRUE" Then
                    IsDefault = True
                Else
                    IsDefault = False
                End If
        End Select
    Next
End Sub


Attribute VB_Name = "struct_ConnectInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public authToken As String
Public ClearPropsOnMultiSave As Boolean
Public ClearCustomPropsOnMultiSave As Boolean
Public ClearPropsOnSingleSave As Boolean
Public ClearCustomPropsOnSingleSave As Boolean
Public LibraryRunning As Boolean
Public MaxFileLength As Long
Public AuthUserName As String
Public UserID As Integer
Public SMEExportMode As Integer
Public ServerURL As String
Public RequiredVersion As Long
Public ProductFileVersion As String
Public ProductMinorVersion As String


Attribute VB_Name = "struct_Content"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public selected As Boolean

Public contentID As Long
Public title As String
Public Comments As String
Public Language As String
Public ContentFilename As String
Public ContentFileSize As String
Public ContentType As String
Public ContactInfo As String
Public DateToExpireSet As Boolean
Public DateToExpire As Date
Public DateCreatedSet As Boolean
Public DateCreated As Date
Public DateLastModifiedSet As Boolean
Public DateLastModified As Date
Public AlertEnabled As Boolean
Public AlertText As String
Public TimesUsed As Long
Public Owners As String
Public IsTranslation As Long
Public TranslationParent As Long

Public cmdValues As Scripting.Dictionary

Public LocalTempFileName As String
Public LocalFileName As String
Public LocalFileCreateDateSet As Boolean
Public LocalFileCreateDate As Date
Public LocalFileModifiedDateSet As Boolean
Public LocalFileModifiedDate As Date
Public FileModified As Boolean

Public MetadataModified As Boolean
Public ChangedTitle As Boolean
Public UpdatedTitle As String
Public ChangedComments As Boolean
Public UpdatedComments As String
Public ChangedContactInfo As Boolean
Public UpdatedContactInfo As String
Public ChangedAlertText As Boolean
Public UpdatedAlertText As String
Public ChangedAlertEnabled As Boolean
Public UpdatedAlertEnabled As Boolean
Public ChangedDateToExpire As Boolean
Public UpdatedDateToExpire As Date
Public UpdatedDateToExpireSet As Boolean

'Private contentFileNode As IXMLDOMNode

Private Sub Class_Initialize()
    FileModified = False
    MetadataModified = False
    ChangedTitle = False
    ChangedComments = False
    ChangedContactInfo = False
    ChangedAlertText = False
    ChangedAlertEnabled = False
    ChangedDateToExpire = False
    UpdatedDateToExpireSet = False
    LocalFileCreateDateSet = False
    LocalFileModifiedDateSet = False
    TimesUsed = 0
    Set cmdValues = New Scripting.Dictionary
End Sub

Public Sub getContentProperties(contentNode As IXMLDOMNode)

    Dim attrib As IXMLDOMAttribute
    For Each attrib In contentNode.Attributes
        Select Case attrib.name
            Case "ContentID"
                contentID = CLng(attrib.Text)
            Case "Title"
                title = attrib.Text
            Case "LCIDLanguage"
                Language = attrib.Text
            Case "Comments"
                Comments = attrib.Text
            Case "ContentType"
                ContentType = attrib.Text
            Case "ContentFilename"
                ContentFilename = attrib.Text
            Case "ContentFileSize"
                ContentFileSize = attrib.Text
            Case "ContactInfo"
                ContactInfo = attrib.Text
            Case "AlertEnabled"
                If UCase(attrib.Text) = "TRUE" Then
                    AlertEnabled = True
                Else
                    AlertEnabled = False
                End If
            Case "TimesUsed"
                TimesUsed = CInt(attrib.Text)
            Case "Owners"
                Owners = attrib.Text
            Case "AlertText"
                AlertText = attrib.Text
            Case "LocalFileName"
                LocalFileName = attrib.Text
            Case "LocalFileCreateDate"
                If attrib.Text <> "" Then
                    LocalFileCreateDate = GetLocalFromUTC(CDate(attrib.Text))
                    DebugMsgBox "LocalFileCreateDate UTC [" & attrib.Text & "] and LocalFileCreateDate local [" & LocalFileCreateDate & "]", "getContentProperties:"
                    LocalFileCreateDateSet = True
                Else
                    LocalFileCreateDateSet = False
                End If
            Case "DateCreated"
                If attrib.Text <> "" Then
                    DateCreated = GetLocalFromUTC(CDate(attrib.Text))
                    DebugMsgBox "DateCreated UTC [" & attrib.Text & "] and DateCreated local [" & DateCreated & "]", "getContentProperties:"
                    DateCreatedSet = True
                Else
                    DateCreatedSet = False
                End If
            Case "DateLastModified"
                If attrib.Text <> "" Then
                    DateLastModified = GetLocalFromUTC(CDate(attrib.Text))
                    DebugMsgBox "DateLastModified UTC [" & attrib.Text & "] and DateLastModified local [" & DateCreated & "]", "getContentProperties:"
                    DateLastModifiedSet = True
                Else
                    DateLastModifiedSet = False
                End If
            Case "DateToExpire"
                If attrib.Text <> "" Then
                    DateToExpire = GetLocalFromUTC(CDate(attrib.Text))
                    DebugMsgBox "DateToExpire UTC [" & CDate(attrib.Text) & "] and DateToExpire local [" & DateToExpire & "]", "getContentProperties:"
                    DateToExpireSet = True
                Else
                    DateToExpireSet = False
                End If
            Case "ChangedTitle"
                If UCase(attrib.Text) = "TRUE" Then
                    ChangedTitle = True
                    MetadataModified = True
                Else
                    ChangedTitle = False
                End If
            Case "UpdatedTitle"
                UpdatedTitle = attrib.Text
            Case "ChangedComments"
                If UCase(attrib.Text) = "TRUE" Then
                    ChangedComments = True
                    MetadataModified = True
                Else
                    ChangedComments = False
                End If
            Case "UpdatedComments"
                UpdatedComments = attrib.Text
            Case "ChangedContactInfo"
                If UCase(attrib.Text) = "TRUE" Then
                    ChangedContactInfo = True
                    MetadataModified = True
                Else
                    ChangedContactInfo = False
                End If
            Case "UpdatedContactInfo"
                UpdatedContactInfo = attrib.Text
            Case "ChangedAlertEnabled"
                If UCase(attrib.Text) = "TRUE" Then
                    ChangedAlertEnabled = True
                    MetadataModified = True
                Else
                    ChangedAlertEnabled = False
                End If
            Case "UpdatedAlertEnabled"
                If UCase(attrib.Text) = "TRUE" Then
                    UpdatedAlertEnabled = True
                    MetadataModified = True
                Else
                    UpdatedAlertEnabled = False
                End If
            Case "ChangedAlertText"
                If UCase(attrib.Text) = "TRUE" Then
                    ChangedAlertText = True
                    MetadataModified = True
                Else
                    ChangedAlertText = False
                End If
            Case "UpdatedAlertText"
                UpdatedAlertText = attrib.Text
            Case "ChangedDateToExpire"
                 If UCase(attrib.Text) = "TRUE" Then
                    ChangedDateToExpire = True
                    MetadataModified = True
                Else
                    ChangedDateToExpire = False
                End If
            Case "UpdatedDateToExpire"
                If attrib.Text <> "" Then
                    UpdatedDateToExpire = GetLocalFromUTC(CDate(attrib.Text))
                    DebugMsgBox "UpdatedDateToExpire UTC [" & CDate(attrib.Text) & "] and UpdatedDateToExpire local [" & UpdatedDateToExpire & "]", "getContentProperties:"
                    UpdatedDateToExpireSet = True
                Else
                    UpdatedDateToExpireSet = False
                End If
            Case "IsTranslation"
                IsTranslation = CLng(attrib.Text)
            Case "TranslationParent"
                TranslationParent = CLng(attrib.Text)
        End Select
    Next
    
    ' Custom meta-data?
    Dim xmlList As IXMLDOMNodeList
    Dim cmdNode As IXMLDOMNode
    Set cmdNode = contentNode.SelectSingleNode("CustomMetaDataValues")
    If Not cmdNode Is Nothing Then
        Set xmlList = cmdNode.SelectNodes("CustomMetaDataValue")
        If Not xmlList Is Nothing And xmlList.Length > 0 Then
            For Each cmdNode In xmlList
                Dim cmdItem As struct_CMD
                Set cmdItem = New struct_CMD
                
                ' Load the meta-data
                cmdItem.getCMDProperties cmdNode
                If Not cmdValues.Exists(CStr(cmdItem.cmID)) Then
                    cmdValues.Add "cc" & CStr(cmdItem.cmID), cmdItem
                End If
                If cmdItem.MetadataModified Then
                    MetadataModified = True
                End If
            Next
        End If
    End If
End Sub

Public Sub getCompositeContentProperties(contentNode As IXMLDOMNode)

    Dim attrib As IXMLDOMAttribute
    For Each attrib In contentNode.Attributes
        Select Case attrib.name
            Case "Title"
                title = attrib.Text
                DebugMsgBox "Title [" & title & "]", "getCompositeContentProperties:"
            Case "ContentFilename"
                ContentFilename = attrib.Text
                contentID = ContentIDComposite
                DebugMsgBox "ContentFilename [" & ContentFilename & "]", "getCompositeContentProperties:"
            Case "LocalFileName"
                LocalFileName = attrib.Text
                DebugMsgBox "LocalFileName [" & LocalFileName & "]", "getCompositeContentProperties:"
            Case "LocalFileCreateDate"
                If attrib.Text <> "" Then
                    LocalFileCreateDate = GetLocalFromUTC(CDate(attrib.Text))
                    DebugMsgBox "LocalFileCreateDate UTC [" & attrib.Text & "] and LocalFileCreateDate local [" & LocalFileCreateDate & "]", "getCompositeContentProperties:"
                    LocalFileCreateDateSet = True
                Else
                    LocalFileCreateDateSet = False
                End If
            Case "IsTranslation"
                IsTranslation = CLng(attrib.Text)
            Case "TranslationParent"
                TranslationParent = CLng(attrib.Text)
        End Select
    Next
End Sub

Private Sub Class_Terminate()
    Set cmdValues = Nothing
End Sub
Attribute VB_Name = "struct_DocSettings"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public showGrammaticalErrors As Boolean
Public showSpellingErrors As Boolean
Public assistantVisible As Boolean
Public assistantSounds As Boolean
Public trackRevisions As Boolean
Public showRevisions As Boolean
Public printRevisions As Boolean
Attribute VB_Name = "struct_UploadParams"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public AddCRMNote As Boolean
Public ContentMetadataSettings As String
Public SantTemplateMode As String
Public TemplateMode As Long
Public contentID As Long
Public CRMNoteText As String
Public miscFileID As Long
Public projectID As Long
Public rfpFileID As Long
Public compareContentID As Long
Public first As Boolean
Public tempDir As String
Public title As String
Public cText As String
Public JobID As String
Public isSMEJob As Boolean

Attribute VB_Name = "thisApplication"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents oApp As Word.Application
Attribute oApp.VB_VarHelpID = -1
Const bTestEvents As Boolean = False
Public ignoreDocChange As Boolean
Public doAfterEvent As Boolean

Public Sub RunOpenCodeOnActiveDocument()
    RunOpenCode ActiveDocument
End Sub

Private Sub RunOpenCode(ByRef thisDoc As Document)
    Dim sMode As String
    Dim sProcessStarted As String
    Dim saveFile As String
    Dim sMappingInfo As String
    
    On Error GoTo ExitCode
    
    'DS: some files had sant template mode properties and when used in build it blows up if we run the other actions as well
    'so skip the processing if we have an active build going on.
    If bActiveBuild Then
        DebugMsgBox "Not running code on [" & thisDoc.FullName & "] due to build process", "RunOpenCode:"
        Exit Sub
    End If
    
    Dim stubMode As String
    stubMode = GetPropertyText("QvidianStubMode", thisDoc)
    DebugMsgBox "Stub Operation [" & stubMode & "]", "RunOpenCode:"
    gOpenViaNewEdit = False
    If stubMode <> "" Then
        modDocProperties.WriteProperty "QvidianStubMode", "Processed", thisDoc

        Dim sServer As String
        'Dim sUserID As String
        Dim sJobFile As String
        Dim contentCount As Integer
        sServer = GetPropertyText("Server", thisDoc)
        DebugMsgBox "Server in stub file is [" & sServer & "]", "RunOpenCode:"
        Select Case stubMode
            Case "MultiEdit"
                ' MAJOR BUG FOR Office 2013!!!!
                ActiveWindow.View.ReadingLayout = False
                
                ' Before we do anything else, hide the text that is only required
                ' when the add-in is NOT installed.
                ActiveWindow.Selection.WholeStory
                ActiveWindow.Selection.Delete
                ActiveDocument.Saved = True
                sJobFile = GetPropertyText("QvidianJobFile", thisDoc)
                contentCount = CInt(GetPropertyText("ContentCount", thisDoc))
                DebugMsgBox "sJobFile [" & sJobFile & "] and count of [" & contentCount & "]", "RunOpenCode:"
                If sJobFile <> "" Then
                    If processJobFile(sJobFile, contentCount) Then
                        MsgBox "Failed to download the Job File."
                    End If
                Else
                    MsgBox "The seed file does not contain a Job File!"
                End If
            Case "SantWordEdit"
            Case "Processed"
                'already ran on this doc, ignore
                'was causing multiple open requests with lots of errors associated.
        End Select
        DebugMsgBox "DONE WITH STUB OPERATION STUFF, WE'RE OUT OF HERE.", "RunOpenCode:"
        Exit Sub
    End If
    
    sMode = GetPropertyText("SantTemplateMode", thisDoc)
    sProcessStarted = GetPropertyText("ProcessStarted", thisDoc)
    DebugMsgBox "Template Mode [" & sMode & "], Process Started [" & sProcessStarted & "], File [" & thisDoc.FullName & "]", "RunOpenCode:"

    burstMode = False

    Select Case sMode
        Case "SantWordBulkLoad"
            'Check if existing bookmarks are ok.
            DebugMsgBox "CheckForExistingBookmarks", "RunOpenCode:"
            modTools.CheckForExistingBookmarks thisDoc
    End Select

    Select Case sMode
        Case "BulkloadLaunch", "SantWordBulkLoadActive"
            'Do nothing
        Case "SantRFPFileWordEdit"
            Set modInit.activeSantDocument = thisDoc 'Application.ActiveDocument
            modToolbar.SwitchToolbars thisDoc
            WriteProperty "RFPBookmarkMap", GetBookmarkMap, thisDoc
        Case Else
            Set modInit.activeSantDocument = thisDoc 'Application.ActiveDocument
            modToolbar.SwitchToolbars thisDoc
    End Select

    'Unprotect the document if it is protected
    ActiveWindow.View.ReadingLayout = False
    If ActiveDocument.ProtectionType <> wdNoProtection Then
        DebugMsgBox "ActiveDocument.Unprotect", "RunOpenCode:"
        ActiveDocument.Unprotect
    End If

    If sProcessStarted <> "1" Then
        'CHECK IF FILE NEEDS SAVED
        Select Case sMode
            Case ""
                'Do not save.
            Case "BulkloadLaunch", "SantWordBulkLoadActive"
                modDocProperties.WriteProperty "ProcessStarted", "1", thisDoc
                'Do not save
            Case Else
                modDocProperties.WriteProperty "ProcessStarted", "1", thisDoc
                thisDoc.Saved = False
                DebugMsgBox "...Saving Document...", "RunOpenCode:"
                modTools.SaveToSantTemp thisDoc
                DebugMsgBox "...Saving Finished", "RunOpenCode:"
        End Select
        
        DebugMsgBox "Potential Save finished...[" & sMode & "]", "RunOpenCode:"
        Select Case sMode
            Case "SantWordBulkLoad"
                'Should have already hit SwitchToolbars.
                DebugMsgBox sMode & " BulkLoadOriginalFilename=" & thisDoc.name
                WriteProperty "BulkLoadOriginalFilename", thisDoc.name, thisDoc
                
            Case "BulkloadLaunch", "SantWordBulkLoadActive"
                Dim bulkloadDocFile As String
                bulkloadDocFile = GetPropertyText("BulkloadPath", thisDoc)
            
                If bulkloadDocFile = "" Then
                    DebugMsgBox "Browse for document to bulk load...", "RunOpenCode:"
                    bulkloadDocFile = modTools.GetDocumentToOpen
                End If
                
                If bulkloadDocFile <> "" Then
                    'User selected a file.
                    
                    'modTools.SwitchBulkloadDocs bulkloadDocFile, thisDoc
                    Dim bulkloadDoc As Document
                    Set bulkloadDoc = Documents.Open(bulkloadDocFile)
                    ClearProperties bulkloadDoc
                    CopyProperties thisDoc, bulkloadDoc
                    modDocProperties.RemoveProperty "ProcessStarted", bulkloadDoc
                    modDocProperties.RemoveProperty "CloseMe", bulkloadDoc
                    WriteProperty "SantTemplateMode", "SantWordBulkLoad", bulkloadDoc
                    
                    DebugMsgBox sMode & " BulkLoadOriginalFilename=" & bulkloadDoc.name
                    WriteProperty "BulkLoadOriginalFilename", bulkloadDoc.name, bulkloadDoc
                    
                    bulkloadDoc.Activate
                    'bulkloadDoc.AttachedTemplate = ""
                    
                    If modTools.UsingAttachedTemplate(thisDoc) Then
                        bulkloadDoc.AttachedTemplate = thisDoc.AttachedTemplate
                        ManualRunOpenCode debugMsg
                        'Close launch file.
                        modDocProperties.WriteProperty "CloseMe", "1", thisDoc
                        'Defect #8880. Timer not working for Word 2010
                        If getVersion < 11 Then
                            Application.OnTime Now + TimeSerial(0, 0, 1), "modTools.CloseLaunchDoc"
                        Else
                            modTools.CloseLaunchDoc
                        End If
                            
                    Else
                        SmartMarking.MarkingMode = MODE_BULKLOAD
                        ManualRunOpenCode debugMsg
                        'modToolbar.SwitchToolbars bulkloadDoc
    
                        modDocProperties.WriteProperty "CloseMe", "1", thisDoc
                        'Defect #8880. Timer not working for Word 2010
                        If getVersion < 11 Then
                            Application.OnTime Now + TimeSerial(0, 0, 1), "modTools.CloseLaunchDoc"
                        Else
                            modTools.CloseLaunchDoc
                        End If
                        
                    End If
                Else
                    'User cancelled browse, close this doc.
                    modDocProperties.WriteProperty "CloseMe", "1", thisDoc
                    Application.OnTime Now + TimeSerial(0, 0, 1), "modTools.CloseLaunchDoc"
                End If
            
            Case "SantCopyAndClose", "SantCopyAndOpen"
                modTools.CopyAndClose sMode
                
            Case "SantBuild"
                InitiateBuild
                
            Case "SantRFPFileWordEdit"
                DebugMsgBox "SantRFPFileWordEdit", "RunOpenCode:"
                If GetPropertyText("ForMarking", thisDoc) = "1" Then
                    DebugMsgBox "For marking...", "RunOpenCode:"
                    SmartMarking.MarkingMode = MODE_BURST
                    burstMode = True
                    If GetPropertyText("IsMarked", thisDoc) = "0" Then
                        SmartMarking.SetReferences ActiveDocument, ActiveWindow
                        SmartMarking.RemoveAllMarkerBars
                        modTools.RemoveBookmarks thisDoc
                        SmartMarking.ConvertNumbersToText 'Crush: Needs to run on all RFP Marking Files
                    End If
                    modTools.CollapseBookmarksForMarking thisDoc
                    SmartMarking.RebaseBookmarkCounter thisDoc
                Else
                    DebugMsgBox "NOT for marking...", "RunOpenCode:"
                    sMappingInfo = GetPropertyText("CheckedOutRecords", thisDoc)
                    DebugMsgBox "  CheckedOutRecords [" & sMappingInfo & "]", "RunOpenCode:"
                    If sMappingInfo <> "" Then
                        modTools.PrepareForEdit thisDoc, ActiveWindow, sMappingInfo
                    Else
                        If ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Bookmarks.count = 0 Then
                            ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Delete
                        End If
                    End If

                    Dim sMappingInfoToSelect As String
                    Dim sMITSParts() As String
                    sMappingInfoToSelect = GetPropertyText("MappingInfoToSelect", thisDoc)

                    DebugMsgBox "  MappingInfoToSelect [" & sMappingInfo & "]", "sMappingInfoToSelect:"
                    If sMappingInfoToSelect <> "" Then
                        sMITSParts = Split(sMappingInfoToSelect, "|")
                        SelectRecord sMITSParts(0), False
                    End If
                End If
                
            Case "PSSubmit"
                Debug.Print "PSSubmit"
                
                If Len(Selection.Paragraphs(1).Range.Text) = 1 Then
                    thisDoc.ActiveWindow.Selection.Text = "Please paste your content here, then click 'Save to Qvidian'"
                End If
                If Len(modDocProperties.GetPropertyText("IsPS", thisDoc)) = 0 Then
                    WriteProperty "IsPS", "1", thisDoc
                End If
                
                'download and apply default template if there is one
                Dim tempID As String
                tempID = modDocProperties.GetPropertyText("DefaultTemplateID", thisDoc)
                Debug.Print "TempID: " & tempID
                Debug.Print "IsNumeric(tempID): " & CStr(IsNumeric(tempID))
                
                If InStr(1, tempID, "|") > 0 Or (IsNumeric(tempID) And CDbl(tempID) > 0) Then
                    Debug.Print "download template result"
                    downloadTemplateResult tempID
                Else
                    Debug.Print "no template applied"
                End If
                
                thisDoc.ActiveWindow.Selection.WholeStory
                
            Case "SantRFPCompareContent"
                sMappingInfo = GetPropertyText("CheckedOutRecords", thisDoc)
                If sMappingInfo <> "" Then
                    modTools.PrepareForEdit thisDoc, ActiveWindow, sMappingInfo
                Else
                    If ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Bookmarks.count = 0 Then
                        ActiveDocument.Range(ActiveDocument.Range.End - 1, ActiveDocument.Range.End).Delete
                    End If
                End If
                modCompare.InitRFPCompare thisDoc
                
            Case "SantCompareContent"
                modCompare.InitCompare thisDoc
                
            Case Else
                'No actions on open.
        End Select
        
        ' Any user alert message specified in the document properties?
        Dim sUserAlert As String
        sUserAlert = GetPropertyText("SantUserAlert", thisDoc)
        If sUserAlert <> "" Then
            MsgBox sUserAlert
            modDocProperties.WriteProperty "SantUserAlert", "", thisDoc
        End If

    End If
        
    'ACTIVATE
    'Application.OnTime When:=Now + TimeValue("00:00:02"), name:="Application.Activate"
    
    Select Case sMode
        Case "BulkloadLaunch", "SantWordBulkLoadActive"
            'Do nothing
        Case Else
            Set modInit.activeSantDocument = thisDoc 'Application.ActiveDocument
    End Select

    'MIN/MAX
'    ActiveWindow.WindowState = wdWindowStateMinimize
'    ActiveWindow.WindowState = wdWindowStateMaximize
ExitCode:
    If Err.Number > 0 Then
        DebugMsgBox "ERROR: " & Err.Number & " - [" & Err.description & "] [" & Err.Source & "]", "RunOpenCode:"
    End If
    DebugMsgBox "Leaving", "RunOpenCode:"

End Sub

Private Sub oApp_DocumentBeforeSave(ByVal Doc As Document, SaveAsUI As Boolean, Cancel As Boolean)
    DebugMsgBox "", "oApp_DocumentBeforeSave:"
    On Error Resume Next
    
    ' Work out if the file is "one of ours" in terms of multi-edit
    Dim itsOurs As Boolean
    itsOurs = False
    Dim content As struct_Content
    Dim bClearBuiltInProps As Boolean
    Dim bClearCustomProps As Boolean

    bClearBuiltInProps = False
    bClearCustomProps = False
    
    DebugMsgBox "call isItOurFile", "oApp_DocumentBeforeSave:"
    If isItOurFile(Doc, bClearBuiltInProps, bClearCustomProps) Then
        ' Potentially need to strip our properties.
        DebugMsgBox "We should do some removal here...", "oApp_DocumentBeforeSave:"
        If bClearBuiltInProps Then
            ClearBuiltInProperties Doc
        End If

        If bClearCustomProps Then
            ClearCustomProperties Doc
        Else
            RemoveWordCustomProperties Doc
        End If

        ' Only want to do the after event when we really mean it...
        DebugMsgBox "ignoreDocChange = [" & ignoreDocChange & "] bActiveBuild = [" & bActiveBuild & "] doAfterEvent = [" & doAfterEvent & "]", "oApp_DocumentBeforeSave:"
        If ignoreDocChange Or bActiveBuild Or Not doAfterEvent Then Exit Sub
        
        ' This works because Word will finish processing the Save event BEFORE
        ' it tries to fire the OnTime event, EVEN if it takes longer to save the
        ' file than the delay!
        DebugMsgBox "start the AfterEvent timer", "oApp_DocumentBeforeSave:"
        Application.OnTime Now + TimeSerial(0, 0, 1), "modMultiEdit.AfterSaveEvent"
    End If
End Sub

Private Sub oApp_NewDocument(ByVal Doc As Document)
    DebugMsgBox "oApp_NewDocument:"
    RunNewCode Doc
End Sub

Private Sub oApp_DocumentOpen(ByVal Doc As Document)
    DebugMsgBox "", "oApp_DocumentOpen:"
    
    ' Defect 11684 - Insert Object (Word file) causes this event to
    ' fire and then causes the wrong toolbar to be shown! So,
    ' try and detect this and just bail without doing anything
    On Error Resume Next
    DebugMsgBox "ActiveDocument = [" & ActiveDocument.FullName & "]", "oApp_DocumentOpen:"
    Dim bDoProcessing As Boolean
    bDoProcessing = False
    If Doc Is Nothing Then
        bDoProcessing = False
    Else
        DebugMsgBox "Doc = [" & Doc.FullName & "]", "oApp_DocumentOpen:"
        If ActiveDocument.FullName = Doc.FullName Then
            bDoProcessing = True
        End If
    End If
    
    Dim lcName As String
    Dim bHideToolbars As Boolean
    bHideToolbars = False
    
    lcName = LCase(ActiveDocument.FullName)
    ' Must start with http and have /webdav/ in it somewhere
    If Left(lcName, 4) = "http" Then
        If InStr(1, lcName, "/webdav/", VbCompareMethod.vbTextCompare) Then
            bHideToolbars = True
        End If
    End If
    
    'for local dev, use this check
    If InStr(1, lcName, "qvidian.mvc/webdav/", VbCompareMethod.vbTextCompare) Then
        bHideToolbars = True
    End If
    
    If bHideToolbars Then
        DebugMsgBox "It's from WebDAV, so no toolbar", "oApp_DocumentOpen:"
        bDoProcessing = False
        HideAllToolbars
    End If
    
    If bDoProcessing Then
        RunOpenCode Doc
    End If
    
    ' Do any required bulkload cleanup
    modTools.ProcessBulkLoadInit Doc
    
    DebugMsgBox "Exiting", "oApp_DocumentOpen:"
'    If Not gJobFile Is Nothing Then
'        If gJobFile.isCompositeEdit Then
'            DebugMsgBox "Calling LabelClick", "oApp_DocumentOpen:"
'            Call frmMultiEdits.LabelClick("row_1_4", False, False)
'        End If
'    End If
    
End Sub

Private Sub oApp_DocumentChange()
    
    If ignoreDocChange Or bActiveBuild Then Exit Sub
    
    'this delay prevents word from crashing if blank documents are open when certain processes launch (such as edit)
    Application.OnTime Now + TimeValue("00:00:01"), "DocChangeCode"
    
End Sub


Public Sub DocChangeCode()

    On Error GoTo ExitCode

    Dim newNoOfOpenDocs As Long
    Dim docAdded As Boolean
    Dim docClosed As Boolean
    Dim thisDoc As Document
        
    DebugMsgBox "Started", "oApp_DocumentChange:"
    
    If ignoreDocChange Or bActiveBuild Then Exit Sub
    
    newNoOfOpenDocs = Application.Documents.count
    
    DebugMsgBox "Documents.count is [" & newNoOfOpenDocs & "]"
    If newNoOfOpenDocs = 0 Then
        DebugMsgBox "No ActiveDocument, leaving", "oApp_DocumentChange:"
        Exit Sub
    End If
    
    On Error Resume Next
    
    DebugMsgBox "ActiveDocument", "oApp_DocumentChange:"
    Set thisDoc = ActiveDocument
    Set modInit.activeSantDocument = thisDoc
    If Err.Number > 0 Then
        DebugMsgBox "Err.Number is [" & Err.Number & "]", "oApp_DocumentChange:"
        Exit Sub
    End If
    On Error GoTo ExitCode
    DebugMsgBox "Template Mode [" & GetPropertyText("SantTemplateMode", thisDoc) & "] Process Started [" & GetPropertyText("ProcessStarted", thisDoc) & "]", "oApp_DocumentChange:"
    DebugMsgBox "File [" & thisDoc.FullName & "]", "oApp_DocumentChange:"

    DebugMsgBox "newNoOfOpenDocs = " & newNoOfOpenDocs & " and oldNoOfOpenDocs = " & oldNoOfOpenDocs, "oApp_DocumentChange:"
    If newNoOfOpenDocs > oldNoOfOpenDocs Then
        docAdded = True

        DebugMsgBox "FirstNewDoc = " & FirstNewDoc, "oApp_DocumentChange:"
        If thisDoc.name = "Document1" And FirstNewDoc Then
            FirstNewDoc = True
        Else
            FirstNewDoc = False
        End If
        oldNoOfOpenDocs = oldNoOfOpenDocs + 1

    ElseIf oldNoOfOpenDocs > newNoOfOpenDocs Then
        docClosed = True
        FirstNewDoc = False
        oldNoOfOpenDocs = oldNoOfOpenDocs - 1
    End If

    DebugMsgBox "FirstNewDoc = " & FirstNewDoc & " and docAdded = " & docAdded, "oApp_DocumentChange:"

    If docAdded Then
        If Len(thisDoc.path) = 0 Then
            Call PsuedoAutoNew(thisDoc)
        Else
            'DS 5/31/12 this line is causing the multiedit to crash (closing all files) if there is a blank, unsaved document open
            ' may be related to manualrunopencode being called and resetting the internal application, causing files to "open" again
            '
            'seems to be resolved by calling this code on a delay from the actual event (possibly giving the other file a chance to close?)
            Call PsuedoAutoOpen(thisDoc)
        End If
    
    ElseIf docClosed Then
        Call PsuedoAutoClose
    
    ElseIf FirstNewDoc Then
        If Len(thisDoc.path) = 0 Then
            Call PsuedoAutoNew(thisDoc)
        Else
            Call PsuedoAutoOpen(thisDoc)
        End If
    
    Else
        Call DocChangedFocus
    End If

    DebugMsgBox "Exiting", "oApp_DocumentChange:"
    Exit Sub

ExitCode:
    DebugMsgBox "Exiting [" & Err.Number & "] - " & Err.description, "oApp_DocumentChange:"
End Sub

Private Sub PsuedoAutoNew(ByRef thisDoc As Document)
    DebugMsgBox "", "PseudoAutoNew:"
    RunNewCode thisDoc
End Sub

Private Sub PsuedoAutoOpen(ByRef thisDoc As Document)
    DebugMsgBox "", "PseudoAutoOpen:"
    RunOpenCode thisDoc
End Sub

Private Sub PsuedoAutoClose()
    DebugMsgBox "", "PseudoAutoClose:"
End Sub

Private Sub DocChangedFocus()
    'Your code here
    DebugMsgBox ActiveDocument.name, "DocChangedFocus:"
    modToolbar.SwitchToolbars ActiveDocument
End Sub

Private Sub RunNewCode(ByRef thisDoc As Document)
    DebugMsgBox "", "RunNewCode:"
    'Typically don't need to do anything here, except possibly
    '   set up menu options.
    'Set modInit.activeSantDocument = thisDoc
    modToolbar.SwitchToolbars thisDoc
End Sub

Private Sub InitiateBuild()
    Dim newBuild As New clsBuild
    bActiveBuild = True
    
    newBuild.SetReferences ActiveDocument, ActiveWindow
    newBuild.RunBuild
End Sub

Private Sub oApp_WindowActivate(ByVal Doc As Document, ByVal Wn As Window)
    DebugMsgBox Doc.FullName, "oApp_WindowActivate:"
    modToolbar.SwitchToolbars Doc
End Sub


' InQuest injected base64 decoded content
' wl"p
' "w+zg
' wN|:
' z{Rz
' zRhl*'
' l:s.
' j)lN
' j)lE
' z{Lz
' z{Lz
' (^rJ.
' zTE<(^rJ.
' R="hl
' z{bjQ
' Szjej
' ~`ZrD
' v+Qz
' WSzjE
' ^tGb
' @'uJ
' p'uJ
' 'vz-x*'
' 'vz-x*'
' 'vz-y'
' v+Qz
' .+-"tZ
' Bz{b
' *':pn
' z+x6
' xLmz{"

INQUEST-PP=macro
