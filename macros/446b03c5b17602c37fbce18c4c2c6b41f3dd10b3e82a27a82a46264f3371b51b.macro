Attribute VB_Name = "Feuil1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Feuil3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "M_Actions"
Option Explicit

Function Init(ByRef AWS As Worksheet, ByRef ALast_Col As Long, ByRef ALast_Row As Long, ByVal ARow As Long) As Boolean
  
  If AWS.Name = "Hidden" Or AWS.Name = "_" Then
    Init = False
  Else
    ALast_Col = Last_Col(AWS)
    ALast_Row = Last_Row(AWS)
    
    Init = (AWS.Cells(ARow, 2).Value <> "x")
  End If
End Function

Sub Finalize(ByVal AWS As Worksheet, ByVal ARow As Long)
  
  AWS.Cells(ARow, 2) = "x"

End Sub

'''<summary>Procedure formating the data.</summary>
Public Sub CB_Format_Data_Click()
Dim WS As Worksheet
Dim R As Range
Dim sFirst_Adress As String
Dim iLast_Col As Long
Dim iLast_Row As Long
Dim sFormat As String
Dim sTD
Dim sTD_Date_And_Time As String

  For Each WS In ActiveWorkbook.Worksheets
    
    If Init(WS, iLast_Col, iLast_Row, 3) Then
    
        If iLast_Row < C_First_Object_Row Then: Exit Sub
    
        'Looking for date to display them in a readable format.
        sFormat = Worksheets("Hidden").Cells(10, 3).Value
        sTD = Worksheets("Hidden").Cells(3, 3).Value
        sTD_Date_And_Time = Worksheets("Hidden").Cells(4, 3).Value
        
        Set R = WS.Range(WS.Cells(C_Row_TD, 3), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD, LookAt:=xlPart)
        If Not (R Is Nothing) Then
          
          sFirst_Adress = R.Address
          Do
             
            If InStr(R.Value, sTD_Date_And_Time) < 1 Then
              Call Format_Dates(WS.Range(WS.Cells(C_First_Object_Row, R.Column), WS.Cells(iLast_Row, R.Column)), sFormat)
            End If
              
            Set R = WS.Range(WS.Cells(C_Row_TD, 3), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
          Loop While RangeOk(R, sFirst_Adress)
          
        End If
        
        'Looking for date and time to display them in a readable format.
        sFormat = Worksheets("Hidden").Cells(11, 3).Value
        Set R = WS.Range(WS.Cells(C_Row_TD, 3), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD_Date_And_Time, LookAt:=xlPart)
        If Not (R Is Nothing) Then
        
          sFirst_Adress = R.Address
          Do
            Call Format_Dates(WS.Range(WS.Cells(C_First_Object_Row, R.Column), WS.Cells(iLast_Row, R.Column)), sFormat)
            Set R = WS.Range(WS.Cells(C_Row_TD, 3), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
          Loop While RangeOk(R, sFirst_Adress)
         
        End If
        
        'Replacing the return char by a real #10 character.
        Call WS.Cells.Replace(C_Data_Separator, Chr(10))
        
        'Replacing the data separators by a #10 character.
        Call WS.Cells.Replace(C_Line_Separator, Chr(10))
          
        'Replacing the value separator for multiple links and enumerations by a #10 character.
        For Each sTD In Array(Worksheets("Hidden").Cells(7, 3), Worksheets("Hidden").Cells(8, 3))
          Set R = WS.Range(WS.Cells(C_Row_TD, 3), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD, LookAt:=xlPart)
          
          If Not (R Is Nothing) Then
           
           sFirst_Adress = R.Address
           Do
              Call WS.Range(WS.Cells(C_First_Object_Row, R.Column), WS.Cells(iLast_Row, R.Column)).Replace(C_Value_Separator, Chr(10))
              Set R = WS.Range(WS.Cells(C_Row_TD, 3), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD, R, , xlPart, xlByColumns, xlNext)
           Loop While RangeOk(R, sFirst_Adress)
            
          End If
          
        Next sTD
        
        Call Finalize(WS, 3)
    End If 'If init()
  Next
End Sub


'''<summary>Procedure splitting the range and range+mean Attribute's columns into two or three columns.</summary>
Public Sub Cb_Split_Decimal_Click()
Dim WS As Worksheet
Dim R As Range
Dim iLast_Col As Long
Dim iLast_Row As Long
Dim sTD_Range As String
Dim sTD_Range_Mean As String
Dim sFirst_Adress As String
Dim iCol As Long
Dim sData_Separator As String

    For Each WS In ActiveWorkbook.Worksheets
    
      If Init(WS, iLast_Col, iLast_Row, 4) Then
        
        sTD_Range = Worksheets("Hidden").Cells(5, 3).Value
        sTD_Range_Mean = Worksheets("Hidden").Cells(6, 3).Value
        
        sData_Separator = Get_Data_Separator
        
        'Looking for "Range" Attributes
        Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD_Range, LookAt:=xlPart)
        If Not (R Is Nothing) Then
          
          sFirst_Adress = R.Address
          Do
            iCol = R.Column
            
            If InStr(R.Value, sTD_Range_Mean) < 1 Then
              Call Split_Range_Attribute(WS, R.Column, iLast_Row, sData_Separator)
              iLast_Col = iLast_Col + 1
              Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
            End If
            
            Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
            
          Loop While RangeOk(R, sFirst_Adress)
        
        End If
        
        'Same work with the "Range+Mean value" Attributes
        Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD_Range_Mean, LookAt:=xlPart)
        If Not (R Is Nothing) Then
          
          sFirst_Adress = R.Address
          Do
            iCol = R.Column
            Call Split_Range_And_Mean_Attribute(WS, R.Column, iLast_Row, sData_Separator)
            iLast_Col = iLast_Col + 2
            Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
            Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
            Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
            
          Loop While RangeOk(R, sFirst_Adress)
        
        End If
         
        Call Finalize(WS, 4)
      
      End If 'If init()
    Next

End Sub

Sub Split_Range_Attribute(AWS As Worksheet, ACol As Long, ALast_Row As Long, AData_Separator As String)
Dim R As Range
Dim Cell As Range
Dim Arr_Data
Dim Arr_Value
Dim sData

  'Inserting a new column before "after" the column to treat.
  AWS.Range(AWS.Cells(8, ACol + 1), AWS.Cells(ALast_Row, ACol + 1)).Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove
  
  'Header(s)
  AWS.Range(AWS.Cells(8, ACol + 1), AWS.Cells(11, ACol + 1)).Value = AWS.Range(AWS.Cells(8, ACol), AWS.Cells(11, ACol)).Value
  AWS.Cells(11, ACol + 1).Value = AWS.Cells(11, ACol + 1) & "-" & Worksheets("Hidden").Cells(4, 5).Value
  AWS.Cells(11, ACol).Value = AWS.Cells(11, ACol).Value & "-" & Worksheets("Hidden").Cells(3, 5)
    
  If ALast_Row < C_First_Object_Row Then: Exit Sub
  
  'Browsing cells (and spliting the values)
  Set R = AWS.Range(AWS.Cells(C_First_Object_Row, ACol), AWS.Cells(ALast_Row, ACol))
  For Each Cell In R
    
    If Cell <> "" Then
        
      Arr_Data = Split(Cell.Value, AData_Separator)
      
      Cell.Value = ""
      
      For Each sData In Arr_Data
               
        Arr_Value = Split(sData, C_Value_Separator)
    
        AWS.Cells(Cell.Row, ACol) = Quick_Concat(AWS.Cells(Cell.Row, ACol), Arr_Value(0), C_Data_Separator)
        AWS.Cells(Cell.Row, ACol + 1) = Quick_Concat(AWS.Cells(Cell.Row, ACol + 1), Arr_Value(1), C_Data_Separator)
      
      Next sData
      
    End If
    
  Next Cell
  
End Sub

Sub Split_Range_And_Mean_Attribute(AWS As Worksheet, ACol As Long, ALast_Row As Long, AData_Separator As String)
Dim R As Range
Dim Cell As Range
Dim Arr_Value
Dim Arr_Data
Dim sData

    'Inserting a new column before "before" the column to treat.
    AWS.Range(AWS.Cells(8, ACol + 1), AWS.Cells(ALast_Row, ACol + 1)).Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove
    AWS.Range(AWS.Cells(8, ACol + 1), AWS.Cells(ALast_Row, ACol + 1)).Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove
    
    'Header(s)
    AWS.Range(AWS.Cells(8, ACol + 1), AWS.Cells(11, ACol + 1)).Value = AWS.Range(AWS.Cells(8, ACol), AWS.Cells(11, ACol)).Value
    AWS.Range(AWS.Cells(8, ACol + 2), AWS.Cells(11, ACol + 2)).Value = AWS.Range(AWS.Cells(8, ACol), AWS.Cells(11, ACol)).Value
    AWS.Cells(11, ACol + 1) = AWS.Cells(11, ACol) & "-" & Worksheets("Hidden").Cells(4, 5)
    AWS.Cells(11, ACol + 2) = AWS.Cells(11, ACol) & "-" & Worksheets("Hidden").Cells(5, 5)
    AWS.Cells(11, ACol) = AWS.Cells(11, ACol) & "-" & Worksheets("Hidden").Cells(3, 5)
      
    If ALast_Row < C_First_Object_Row Then: Exit Sub
    
    'Browsing cells (and spliting the values)
    Set R = AWS.Range(AWS.Cells(C_First_Object_Row, ACol), AWS.Cells(ALast_Row, ACol))
    For Each Cell In R
      
      If Cell <> "" Then
        
        Arr_Data = Split(Cell.Value, AData_Separator)
        
        Cell.Value = ""
        
        For Each sData In Arr_Data
                 
          Arr_Value = Split(sData, C_Value_Separator)
      
          AWS.Cells(Cell.Row, ACol) = Quick_Concat(AWS.Cells(Cell.Row, ACol), Arr_Value(0), C_Data_Separator)
          AWS.Cells(Cell.Row, ACol + 1) = Quick_Concat(AWS.Cells(Cell.Row, ACol + 1), Arr_Value(1), C_Data_Separator)
          AWS.Cells(Cell.Row, ACol + 2) = Quick_Concat(AWS.Cells(Cell.Row, ACol + 2), Arr_Value(2), C_Data_Separator)
        
        Next sData
      
      End If
      
    Next Cell
    
End Sub

Public Sub CB_Transform_Table_Click()
Dim vAnswer As Variant
Dim sDir As String
Dim WS As Worksheet
Dim R As Range
Dim iLast_Col As Long
Dim iLast_Row As Long
Dim sTD As String
Dim sLine_Separator As String
Dim sFirst_Adress As String
Dim iNb_Files As Long
Dim Cell As Range
Dim WB_Table As Workbook
Dim WS_Table As Worksheet
Dim Arr_Rows
Dim sRow
Dim Arr_Values
Dim sVal
Dim iCol As Long
Dim iRow As Long

    For Each WS In ActiveWorkbook.Worksheets
    
      If Init(WS, iLast_Col, iLast_Row, 5) Then
      
        'Directory where to save the files.
        vAnswer = Application.InputBox(Prompt:=Worksheets("Hidden").Cells(7, 5), Title:=Worksheets("Hidden").Cells(6, 5), Type:=2)
        
        'This means the user cancelled its action.
        If VarType(vAnswer) = vbBoolean Then: Exit Sub
        
        sDir = vAnswer
        If Trim(sDir) = "" Then: Exit Sub
        
        sDir = IncludeTrailingPathDelimiter(sDir)
        Call Create_Dir(sDir)
        
        If iLast_Row < C_First_Object_Row Then: Exit Sub
        
        sTD = Worksheets("Hidden").Cells(9, 3).Value
        
        sLine_Separator = Get_Line_Separator
        
        'Looking for "Table" Attributes
        Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).Find(sTD, LookAt:=xlPart)
        iNb_Files = 0
        If Not (R Is Nothing) Then
          
          sFirst_Adress = R.Address
          Do
            'Analyzing each cell
            For Each Cell In WS.Range(WS.Cells(C_First_Object_Row, R.Column), WS.Cells(iLast_Row, R.Column))
            
              If Cell.Value <> "" Then
              
                'Creating a new workbook
                Call Application.Workbooks.Add
                Set WB_Table = ActiveWorkbook
                Set WS_Table = WB_Table.Worksheets(1)
                
                'Spliting the cell value into a table of rows
                Arr_Rows = Split(Cell.Value, sLine_Separator)
                iCol = 1
                iRow = 1
                For Each sRow In Arr_Rows
                
                  'Spliting the row into a table of values
                  Arr_Values = Split(sRow, C_Value_Separator)
                  iCol = 1
                  'Writing each value into the file (a transposition is done).
                  For Each sVal In Arr_Values
                    WS_Table.Cells(iRow, iCol) = sVal
                   Call Inc(iCol)
                  Next sVal
                  Call Inc(iRow)
                Next sRow
                
                'Saving the workbook and writing its path into the cell.
                Call Inc(iNb_Files)
                Cell.Value = sDir & "Table_" & CStr(iNb_Files) & ".xls"
                Call WB_Table.SaveAs(Cell.Value)
                WB_Table.Close
                
              End If
            
            Next Cell
            
            Set R = WS.Range(WS.Cells(C_Row_TD, 2), WS.Cells(C_Row_TD, iLast_Col)).FindNext(R)
            
          Loop While R.Address <> sFirst_Adress
        
        End If
        
        Call Finalize(WS, 5)
      
      End If 'If init()
  Next

End Sub

Attribute VB_Name = "M_Excel"
'---------------------------------------------------------------------------------------
' Module    : M_Utils
' Author    : dev@bassetti.fr
' Date      : 01/01/2006
' Purpose   : utils for Excel.
'---------------------------------------------------------------------------------------

Option Explicit

Enum VSeries_Range_Treatment
  [_First] = 0
    'The ranges X and Y of a given Series are used as passed.
    'quick method but non complete couples interrupt the series line (if drawned).
    srtUse_Full_Range = 0
    'Only complete couples are used. This method is slow bu allows to draw a non interrupted line (if drawned).
    srtUse_Complete_Couples_Only = 1
  [_Last] = 1
End Enum

'---------------------------------------------------------------------------------------
' Procedure : List_File
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function listing in rows the files and sub-folders found into a given folder. It returns the last filled row. In case no file could be found, it returns ARow-1.
' Params(s):
' - ADirectory As String - the directory to search into.
' - AWS As Worksheet - the sheet where to write the results.
' - Optional ByVal ARecursive as boolean = True - if true, subfolders will also be scanned.
' - Optional AExtensions As String = vbNullString - a list of filtering extensions (separated by a ";" character).
' - Optional ByVal AList_Directories As Boolean = False - if true, directories are listed.
' - Optional ByVal ARow As Integer = 1 - the first row where to write the files and folders paths.
' - Optional ByVal ACol As Integer = 1 - the column where to write the files and folders paths.
'---------------------------------------------------------------------------------------
'
Public Function List_Files(ADirectory As String, AWS As Worksheet, Optional ByVal ARecursive As Boolean = True, Optional AExtensions As String = vbNullString, Optional ByVal AList_Directories As Boolean = False, Optional ByVal ARow As Long = 1, Optional ByVal ACol As Long = 1) As Long
Dim i As Long
Dim Arr_Files
      
  Arr_Files = Create_Arr_Files(ADirectory, ARecursive, AExtensions, AList_Directories)
  
  If Not IsArrayAllocated(Arr_Files) Then
    List_Files = ARow - 1
  Else
    For i = LBound(Arr_Files) To UBound(Arr_Files)
      AWS.Cells(ARow + i - LBound(Arr_Files), ACol) = Arr_Files(i)
    Next i
  
    List_Files = ARow + UBound(Arr_Files) - LBound(Arr_Files)
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_Last_Col
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning the last col of a worksheet in case the input column is lower than 1. The function is compatible with Excel 95 and higher.
' Param(s)  :
' - ByVal ACol As Long - the column sent.
'---------------------------------------------------------------------------------------
'
Private Function Get_Last_Col(AWS As Worksheet, ByVal ACol As Long) As Long
    
  If ACol < 1 Then
    Get_Last_Col = AWS.Columns.Count
  Else
    Get_Last_Col = ACol
  End If

End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_Last_Row
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning the last row of a worksheet in case the input row is lower than 1. The function is compatible with Excel 95 and higher.
' Params(s):
' - ByVal ACol As Long - the column sent.
'---------------------------------------------------------------------------------------
'
Private Function Get_Last_Row(AWS As Worksheet, ByVal ARow As Long) As Long
    
  If ARow < 1 Then
    Get_Last_Row = AWS.Rows.Count
  Else
    Get_Last_Row = ARow
  End If

End Function

'---------------------------------------------------------------------------------------
' Procedure : Last_Row
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning the last non empty row of a range in a Worksheet.
' Param(s)  :
' - AWS As Worksheet - the worskheet.
' - Optional ByVal AFirst_Col As Long = 1 - the first column of the range.
' - Optional ByVal ALast_Col As Long = 255 - the last column of the range.
' - Optional AFirst_Row As Long = 1 - the first row of the range.
' - Optional ALast_Row As Long = 65536 - the last row of the range.
'---------------------------------------------------------------------------------------
'
Public Function Last_Row(AWS As Worksheet, Optional ByVal AFirst_Col As Long = 1, Optional ByVal ALast_Col As Long = 0, Optional AFirst_Row As Long = 1, Optional ALast_Row As Long = 0) As Long
Dim R As Range
  
  
  ALast_Col = Get_Last_Col(AWS, ALast_Col)
  ALast_Row = Get_Last_Row(AWS, ALast_Row)
  
  Set R = AWS.Range(AWS.Cells(AFirst_Row, AFirst_Col), AWS.Cells(ALast_Row, ALast_Col)).Find("*", , , , xlByRows, xlPrevious)
  
  If R Is Nothing Then
    Last_Row = -1
  Else
    Last_Row = R.Row
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Last_Col
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning the last non empty row of a range in a Worksheet.
' Param(s)
' - AWS As Worksheet - the worskheet.
' - Optional AFirst_Row As Long = 1 - the first row of the range.
' - Optional ALast_Row As Long = 65536 - the last row of the range.
' - Optional ByVal AFirst_Col As Long = 1 - the first column of the range.
' - Optional ByVal ALast_Col As Long = 255 - the last column of the range.
'---------------------------------------------------------------------------------------
'
Public Function Last_Col(AWS As Worksheet, Optional AFirst_Row As Long = 1, Optional ALast_Row As Long = 0, Optional ByVal AFirst_Col As Long = 1, Optional ByVal ALast_Col As Long = 0) As Long
Dim R As Range
  
  ALast_Col = Get_Last_Col(AWS, ALast_Col)
  ALast_Row = Get_Last_Row(AWS, ALast_Row)
  
  Set R = AWS.Range(AWS.Cells(AFirst_Row, AFirst_Col), AWS.Cells(ALast_Row, ALast_Col)).Find("*", , , , xlByColumns, xlPrevious)
     
  If R Is Nothing Then
    Last_Col = -1
  Else
    Last_Col = R.Column
  End If
End Function

'---------------------------------------------------------------------------------------
' Procedure : First_Row
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning the first non empty row of a range in a Worksheet.
' Param(s)
' - AWS As Worksheet - the worskheet.
' - Optional ByVal AFirst_Col As Long = 1 - the first column of the range.
' - Optional ByVal ALast_Col As Long = 255 - the last column of the range.
' - Optional AFirst_Row As Long = 1 - the first row of the range.
' - Optional ALast_Row As Long = 65536 - the last row of the range.
'---------------------------------------------------------------------------------------
'
Public Function First_Row(AWS As Worksheet, Optional ByVal AFirst_Col As Long = 1, Optional ByVal ALast_Col As Long = 0, Optional AFirst_Row As Long = 1, Optional ALast_Row As Long = 0) As Long
Dim R As Range
  
  ALast_Col = Get_Last_Col(AWS, ALast_Col)
  ALast_Row = Get_Last_Row(AWS, ALast_Row)
  
  Set R = AWS.Range(AWS.Cells(AFirst_Row, AFirst_Col), AWS.Cells(ALast_Row, ALast_Col)).Find("*", , , , xlByRows, xlNext)
  
  If R Is Nothing Then
    First_Row = -1
  Else
    First_Row = R.Row
  End If
End Function

'---------------------------------------------------------------------------------------
' Procedure : First_Col
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning the first non empty column of a range in a Worksheet.
' Param(s)
' - AWS As Worksheet - the worskheet.
' - Optional ByVal AFirst_Col As Long = 1 - the first column of the range.
' - Optional ByVal ALast_Col As Long = 255 - the last column of the range.
' - Optional AFirst_Row As Long = 1 - the first row of the range.
' - Optional ALast_Row As Long = 65536 - the last row of the range.
'---------------------------------------------------------------------------------------
'
Public Function First_Col(AWS As Worksheet, Optional AFirst_Row As Long = 1, Optional ALast_Row As Long = 0, Optional ByVal AFirst_Col As Long = 1, Optional ByVal ALast_Col As Long = 0) As Long
Dim R As Range
  
  ALast_Col = Get_Last_Col(AWS, ALast_Col)
  ALast_Row = Get_Last_Row(AWS, ALast_Row)
  
  Set R = AWS.Range(AWS.Cells(AFirst_Row, AFirst_Col), AWS.Cells(ALast_Row, ALast_Col)).Find("*", , , , xlByColumns, xlNext)
  
  If R Is Nothing Then
    First_Col = -1
  Else
    First_Col = R.Column
  End If
      
End Function

'---------------------------------------------------------------------------------------
' Procedure : CDblR
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure trying to convert the values of a range into double values. No error is raised if one the values is not convertable.
' Param(s)
' - AR As Range - the range to convert.
'---------------------------------------------------------------------------------------
'
Public Sub CDblR(AR As Range)
Dim f As Double
Dim sAddress As String
Dim C As Range

  For Each C In AR.Cells
    f = CDblExt(C.Value)
    If Not isNaN(f) Then: C.Value = f
  Next C
    
End Sub

'---------------------------------------------------------------------------------------
' Procedure : TrimR
' Author    : dev@bassetti.fr
' Date      : 26/10/2011
' Purpose   : procedure removing the spaces before and after the value contained in a range of cells. The value does not treat the numerical cells nor the date cells
' Param(s)  :
' - AR As Range - the range to treat.
'---------------------------------------------------------------------------------------
'
Sub TrimR(AR As Range)
Dim C As Range
  
  For Each C In AR.Cells
    
    On Error Resume Next
    If Not isNumericExt(C.Value) Then: C.Value = Trim(C.Value)
  Next C
    
End Sub
'---------------------------------------------------------------------------------------
' Procedure : IncCoords
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure Incrementing cells coordinates, depending on ATranspose. It is usefull in case of a table, if it has to be initialized verticaly or horizontaly.
' Param(s)
' - ByRef ARow As Long - the row value.
' - ByRef ACol As Long - the col value.
' - ByVal ANRow As Long - the row incremention.
' - ByVal ANCol As Long - the column incrementation.
' - ByVal ATranspose As Boolean - transpose or not ?
'---------------------------------------------------------------------------------------
'
Public Sub IncCoords(ByRef ARow As Long, ByRef ACol As Long, ByVal ANRow As Long, ByVal ANCol As Long, ByVal ATranspose As Boolean)

    If ATranspose Then
      ARow = ARow + ANCol
      ACol = ACol + ANRow
    Else
      ARow = ARow + ANRow
      ACol = ACol + ANCol
    End If

End Sub

'---------------------------------------------------------------------------------------
' Procedure : ReinitCoords
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure reinitializing cells coordinates, depending on ATranspose. It is usefull in case of a table, if it has to be initialized verticaly or horizontaly.
' Param(s)
' - ByRef ARow As Long - the row value.
' - ByRef ACol As Long - the col value.
' - ByVal ADefault_Row As Long - the row's default value.
' - ByVal ADefault_Col As Long - the column' default value.
' - ByVal ATranspose As Boolean - transpose or not ?
'---------------------------------------------------------------------------------------
'
Public Sub ReinitCoords(ByRef ARow As Long, ByRef ACol As Long, ByVal ADefault_Row As Long, ByVal ADefault_Col As Long, ByVal ATranspose As Boolean)

    If ATranspose Then
      ARow = ADefault_Row
    Else
      ACol = ADefault_Col
    End If

End Sub

'---------------------------------------------------------------------------------------
' Procedure : Comment_Range
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure enabling to add a comment to a given range.
' Param(s)
' - AR As Range - the cells range.
' - ByVal AComment As String - the comment.
'---------------------------------------------------------------------------------------
'
Public Sub Comment_Range(AR As Range, ByVal AComment As String)

  If AR Is Nothing Then: Exit Sub
  
  If AComment = vbNullString Then
    
    If Not AR.Comment Is Nothing Then: AR.ClearComments
  
  Else
    If AR.Comment Is Nothing Then: AR.AddComment
    AR.Comment.Text Text:=AComment
  End If

End Sub

'---------------------------------------------------------------------------------------
' Procedure : Get_Comment
' Author    : dev@bassetti.fr
' Date      : 15/09/2011
' Purpose   : Function retrieving the comment associated to a given range.
'---------------------------------------------------------------------------------------
'
Public Function Get_Comment(AR As Range) As String
  
  If AR Is Nothing Or AR.Comment Is Nothing Then
    Get_Comment = vbNullString
  Else
    Get_Comment = AR.Comment.Text
  End If
End Function

'---------------------------------------------------------------------------------------
' Procedure : Write_vCell
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function writing a value into a given cell.
' Param(s)  :
' - AWS As Worksheet - the worksheet where to write the value.
' - ByRef ARow As Integer - the row of the cell.
' - ByVal ACol As Long - the column of the cell.
' - ByVal AValue As Variant - the value to write.
' - ByVal AAdd_Comments As Boolean - if true, a comment is added.
' - Optional AComments As String = vbNullString - the comment string.
'---------------------------------------------------------------------------------------
'
Public Sub Write_vCell(AWS As Worksheet, ByVal ARow As Long, ByVal ACol As Long, ByVal AValue As Variant, ByVal AAdd_Comments As Boolean, Optional AComments As String = vbNullString)
    
    AWS.Cells(ARow, ACol) = AValue
    If AAdd_Comments Then: Call Comment_Range(AWS.Cells(ARow, ACol), AComments)
    
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Export_Charts
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure exporting all graphics of a given Worksheet as PNG files into a given directory.
' Param(s)  :
' - AWS As Worksheet - the worksheet.
' - ADirectory As String - the directory where to save the picture files.
'---------------------------------------------------------------------------------------
'
Sub Export_Charts(AWS As Worksheet, ADirectory As String)
Dim iNb_Charts As Long
Dim rGraph As ChartObject
  
  '
  iNb_Charts = 0
  For Each rGraph In AWS.ChartObjects
     Call Inc(iNb_Charts)
     rGraph.Chart.Export FileName:=ADirectory & Trim(CStr(iNb_Charts)) & ".png", Filtername:="PNG"
  Next rGraph

End Sub

Sub Move_Charts(AWS As Worksheet)
Dim rGraph As ChartObject
Dim sName As String
  
  For Each rGraph In AWS.ChartObjects
    If rGraph.Chart.HasTitle Then
      sName = rGraph.Chart.ChartTitle.Characters.Text
    Else
      sName = ""
    End If
    rGraph.Chart.Location Where:=xlLocationAsNewSheet
    
    If sName <> "" Then: ActiveSheet.Name = Get_WS_Compatible_Name(AWS.Parent, sName)
  Next rGraph

End Sub

'---------------------------------------------------------------------------------------
' Procedure : RangeToSeriesFormula2003
' Author    : dev@bassetti.fr
' Date      : 06/02/2013
' Purpose   : function returning a formula compatible with excel 2003 for chart's series from a given range.
' Param(s)  :
' - AR - the range to use.
'---------------------------------------------------------------------------------------
'
Private Function RangeToSeriesFormula2003(AR) As String
Dim C As Range
Dim s As String

  s = ""
  For Each C In AR
    s = Quick_Concat(s, C.Address(, , xlR1C1, True), ",")
  Next C
  
  RangeToSeriesFormula2003 = "=(" & s & ")"

End Function


'---------------------------------------------------------------------------------------
' Procedure : Init_Series_From_Arrays
' Author    : dev@bassetti.fr
' Date      : 02/05/2012
' Purpose   : Procedure initialing a given series of a chart (and creating it if needed) using two arrays of values.
' Param(s)  :
' - AChart As Chart - the chart owning the series.
' - ANb_Series As Integer - the index of the series. If higher than the number of series of the chart, a new series is created.
' - AR_XValues - the array of X values.
' - AR_Values - the array of Y values.
' - Optional ASeries_Name As String = vbNullString - the name of the Series.
' - Optional AAxis_Group As XlAxisGroup = xlPrimary - the axis group of the Series.
'---------------------------------------------------------------------------------------
'
Sub Init_Series_From_Arrays(AChart As Chart, ByVal ANb_Series As Integer, AXValues, AValues, Optional ASeries_Name As String = vbNullString, Optional AAxis_Group As XlAxisGroup = xlPrimary)
Dim rSeries As Series

  If AChart.SeriesCollection.Count >= ANb_Series Then
    Set rSeries = AChart.SeriesCollection(ANb_Series)
  Else
    Set rSeries = AChart.SeriesCollection.NewSeries
  End If
  
  If ASeries_Name <> vbNullString Then: rSeries.Name = ASeries_Name
  
  If (CDblExt(Application.Version) > 11) Or ((AXValues.Areas.Count < 2) And (AValues.Areas.Count < 2)) Then
    rSeries.XValues = AXValues
    rSeries.Values = AValues
  Else
    rSeries.XValues = RangeToSeriesFormula2003(AXValues)
    rSeries.Values = RangeToSeriesFormula2003(AValues)
  End If
  rSeries.AxisGroup = AAxis_Group
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Init_Series
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure initialing a given series of a chart (and creating it if needed).
' Param(s)  :
' - AChart As Chart - the chart owning the series.
' - ANb_Series As Integer - the index of the series. If higher than the number of series of the chart, a new series is created.
' - ByVal ACol_X As Long - the index of the X column.
' - ByVal ARow_X_Start As Long - the first row of the X column.
' - ByVal ARow_X_End As Long - the last row of the X column.
' - ByVal ACol_Y As Long - the index of the Y column.
' - ByVal ARow_Y_Start As Long - the first row of the Y column.
' - ByVal ARow_Y_End As Long - the last row of the Y column.
' - Optional ASeries_Name As String = vbNullString - the name of the Series.
' - Optional ASeries_Range_Treatment As VSeries_Range_Treatment = srtUse_Full_Range - the type of range to use for the series (see the definition of VSeries_Range_Treatment).
' - Optional AAxis_Group As XlAxisGroup = xlPrimary - the axis group of the Series.
'---------------------------------------------------------------------------------------
'
Sub Init_Series(AChart As Chart, ByVal ANb_Series As Integer, AWS As Worksheet, ByVal ACol_X As Long, ByVal ARow_X_Start As Long, ByVal ARow_X_End As Long, ByVal ACol_Y As Long, ByVal ARow_Y_Start As Long, ByVal ARow_Y_End As Long, Optional ASeries_Name As String = vbNullString, Optional ASeries_Range_Treatment As VSeries_Range_Treatment = srtUse_Full_Range, Optional AAxis_Group As XlAxisGroup = xlPrimary)
Dim RX As Range, RY As Range
Dim iRow_X As Long, iRow_Y As Long
  
  'Values
  Select Case ASeries_Range_Treatment
    Case srtUse_Full_Range
      
      Set RX = AWS.Range(AWS.Cells(ARow_X_Start, ACol_X), AWS.Cells(ARow_X_End, ACol_X))
      Set RY = AWS.Range(AWS.Cells(ARow_Y_Start, ACol_Y), AWS.Cells(ARow_Y_End, ACol_Y))
    
    Case srtUse_Complete_Couples_Only
      'TODO
      Set RX = Nothing
      Set RY = Nothing
      iRow_Y = ARow_Y_Start
      For iRow_X = ARow_X_Start To ARow_X_End
        If isNumericExt(AWS.Cells(iRow_X, ACol_X)) And isNumericExt(AWS.Cells(iRow_Y, ACol_Y)) Then
          
          If Not RX Is Nothing Then
            Set RX = Union(RX, AWS.Cells(iRow_X, ACol_X))
            Set RY = Union(RY, AWS.Cells(iRow_Y, ACol_Y))
          Else
            Set RX = AWS.Cells(iRow_X, ACol_X)
            Set RY = AWS.Cells(iRow_Y, ACol_Y)
          End If
                    
        End If
        Call Inc(iRow_Y)
        
        If iRow_Y > ARow_Y_End Then: Exit For
        
      Next iRow_X
  End Select
       
  Call Init_Series_From_Arrays(AChart, ANb_Series, RX, RY, ASeries_Name, AAxis_Group)
    
  
End Sub


'---------------------------------------------------------------------------------------
' Procedure : AutoFit_Axes
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : procedure setting the two axis of a given chart so that it only displays the interesting ranges.
' Param(s)
' - AChart As Chart - the chart to modify.
'---------------------------------------------------------------------------------------
'
Public Static Sub AutoFit_Axes(AChart As Chart)
  
  Call AutoFit_Axis(AChart, xlCategory)
  Call AutoFit_Axis(AChart, xlValue)
  If AChart.HasAxis(xlValue, xlSecondary) Then: Call AutoFit_Axis(AChart, xlValue, xlSecondary)

End Sub


'---------------------------------------------------------------------------------------
' Procedure : AutoFit_Axis
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : procedure setting a given axis of a given chart so that it only displays the interesting range.
' Param(s)
' - AChart As Chart - the chart to modify.
' - AAxis_Type As XlAxisType - the type of the axis to modify.
' - AAxis_Group As XlAxisGroup = XlAxisGroup - the axis group. By default, the primary axis is used.
'---------------------------------------------------------------------------------------
'
Public Static Sub AutoFit_Axis(AChart As Chart, AAxis_Type As XlAxisType, Optional AAxis_Group As XlAxisGroup = xlPrimary)
Dim rAxs As Axis
Dim Ser As Series
Dim fMin As Double, fMax As Double, fMargin As Double, iLog As Long
Dim iNb1 As Long, iNb2 As Long
Dim Arr_Values()
Dim bOk As Boolean

  If AChart Is Nothing Then: Exit Sub
  
  Set rAxs = AChart.Axes(AAxis_Type, AAxis_Group)
  fMax = NegInfinity
  fMin = Infinity
  On Error Resume Next
  For Each Ser In AChart.SeriesCollection
    
    If AAxis_Type = xlCategory Then
      bOk = True
      Arr_Values = Ser.XValues
    Else
      bOk = (Ser.AxisGroup = AAxis_Group)
      Arr_Values = Ser.Values
    End If
    If bOk Then
      fMin = Application.Min(Arr_Values, fMin)
      fMax = Application.Max(Arr_Values, fMax)
    End If
  Next Ser
  
  'No numerical value.
  If fMax = NegInfinity Then: Exit Sub
  
  If rAxs.ScaleType = xlScaleLogarithmic Then
      
    iLog = Int(Log10(fMin))
    If iLog = Log10(fMin) Then: Call Dec(iLog)
    fMin = Application.Power(10#, iLog)
    
    fMax = Application.Power(10#, Int(Log10(fMax)) + 1)
  Else
    fMargin = (fMax - fMin) / 10# '10% of margin.
    fMin = fMin - fMargin
    fMax = fMax + fMargin
  End If
  
  rAxs.MaximumScale = fMax
  rAxs.MinimumScale = fMin
  rAxs.CrossesAt = fMin
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Reset_Axis
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : procedure setting a given axis of a given chart to the default setttings: automatic maximum and minimum scales, automatic Axis Crosses value.
' Param(s)
' - AChart As Chart - the chart to modify.
' - AAxis_Type As XlAxisType - the type of the axis to modify.
'---------------------------------------------------------------------------------------
'
Public Static Sub Reset_Axis(AChart As Chart, AAxis_Type As XlAxisType)
Dim rAxs As Axis
  
  If AChart Is Nothing Then: Exit Sub
  
  Set rAxs = AChart.Axes(AAxis_Type)
  
  rAxs.MaximumScaleIsAuto = True
  rAxs.MinimumScaleIsAuto = True
  rAxs.Crosses = xlAxisCrossesAutomatic
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : isNumericExt
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : Extension of the isNumeric function: it handles dates and empty expressions.
' Param(s)
' - Expression - the expression to evaluate.
'---------------------------------------------------------------------------------------
'
Public Function isNumericExt(Expression) As Boolean
  isNumericExt = Not IsEmpty(Expression) And (IsNumeric(Expression) Or IsDate(Expression))
End Function

'---------------------------------------------------------------------------------------
' Procedure : Integrate
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : function returning the integrale of a curve represented by its X and Y ranges. The method used is a trapezoidale sum.
' Param(s)
' - AR_X As Range - the X range.
' - AR_Y As Range - the Y range.
'---------------------------------------------------------------------------------------
'
Public Static Function Integrate(AR_X As Range, AR_Y As Range) As Double
Dim Arr_X() As Double, Arr_Y() As Double
Dim i As Long
  
  If AR_X Is Nothing Or AR_Y Is Nothing Then
    Integrate = 0
    Exit Function
  End If
  
  ReDim Arr_X(0 To AR_X.Cells.Count - 1)
  ReDim Arr_Y(0 To AR_X.Cells.Count - 1)
  
  For i = 1 To AR_X.Cells.Count
    
    If i > AR_Y.Cells.Count Then
      Arr_X(i - 1) = NaN
      Arr_Y(i - 1) = NaN
    Else
      Arr_X(i - 1) = CDblExt(AR_X.Cells(i).Value)
      Arr_Y(i - 1) = CDblExt(AR_Y.Cells(i).Value)
    End If
    
  Next i
  
  Integrate = Integrate_From_Arrays(Arr_X, Arr_Y)
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Reset_Axes
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : procedure setting the two axis of a given chart to the default setttings: automatic maximum and minimum scales, automatic Axis Crosses value.
' Param(s)
' - AChart As Chart - the chart to modify.
'---------------------------------------------------------------------------------------
'
Public Static Sub Reset_Axes(AChart As Chart)

  Call Reset_Axis(AChart, xlCategory)
  Call Reset_Axis(AChart, xlValue)

End Sub

'---------------------------------------------------------------------------------------
' Procedure : Duplicate_Chart
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure duplicating a given chart.
' Param(s)  :
' - AWS As Worksheet - the worksheet owning the chart to duplicate.
' - AChart_Name As String - the name of the chart to duplicate.
' - Optional ARow As Long = 1 - the row of the cell where to paste the chart.
' - Optional ACol As Long = 1 - the column of the cell where to paste the chart.
' - Optional AName_Chart as string = vbNullString - the name of the new chart.
'---------------------------------------------------------------------------------------
'
Function Duplicate_Chart(AWS As Worksheet, AChart_Name As String, Optional ARow As Long = 1, Optional ACol As Long = 1, Optional AName_Chart As String = vbNullString) As Chart

  AWS.Activate
  AWS.ChartObjects(AChart_Name).Activate
  ActiveChart.ChartArea.Copy
  AWS.Cells(ARow, ACol).Select
  ActiveSheet.Paste
  
  Set Duplicate_Chart = ActiveChart
  
  
  If AName_Chart <> vbNullString Then
    Duplicate_Chart.Parent.Name = AName_Chart
  Else
    Duplicate_Chart.Parent.Name = "Copy_of_" & ActiveChart.Name
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Decorate_Chart
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure decorating the series of a given chart with the settings defined on an other chart.
' Param(s)  :
' - AChart_Source As Chart - the chart used as "source"
' - AChart_Dest As Chart - the chart to decorate.
'---------------------------------------------------------------------------------------
'
Public Sub Decorate_Chart(AChart_Source As Chart, AChart_Dest As Chart, AUse_Last_For_Last As Boolean)
Dim i As Integer, iNb_Series As Integer, iIndex As Integer, iNb_Series_Source As Integer
Dim iColorIndex As Integer, iWeight As Integer, iLineStyle As Integer, iMarkerBackgroundColorIndex As Integer
Dim iMarkerForegroundColorIndex As Integer, iMarkerStyle As Integer, iMarkerSize As Integer
  
On Error GoTo ErrorHandler

  iNb_Series_Source = AChart_Source.SeriesCollection.Count
  
  iNb_Series = AChart_Dest.SeriesCollection.Count
  
  'D|fffd|coration des courbes
  For i = 1 To iNb_Series

    If AUse_Last_For_Last And (i = iNb_Series) Then
      iIndex = iNb_Series_Source
    Else
      iIndex = (iNb_Series_Source - 1 + i) Mod (iNb_Series_Source - 1)
    End If
  
'    AChart_Source.Parent.Activate
'
'    iColorIndex = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.Border.ColorIndex
'    iWeight = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.Border.Weight
'    iLineStyle = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.Border.LineStyle
'    iMarkerBackgroundColorIndex = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.MarkerBackgroundColorIndex
'    iMarkerForegroundColorIndex = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.MarkerForegroundColorIndex
'    iMarkerStyle = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.MarkerStyle
'    iMarkerSize = ActiveChart.Legend.LegendEntries(iIndex).LegendKey.MarkerSize
'
'
'    AChart_Dest.Parent.Activate
'    ActiveChart.Legend.LegendEntries(i).LegendKey.Border.ColorIndex = iColorIndex
'    ActiveChart.Legend.LegendEntries(i).LegendKey.Border.Weight = iWeight
'    ActiveChart.Legend.LegendEntries(i).LegendKey.Border.LineStyle = iLineStyle
'    ActiveChart.Legend.LegendEntries(i).LegendKey.MarkerBackgroundColorIndex = iMarkerBackgroundColorIndex
'    ActiveChart.Legend.LegendEntries(i).LegendKey.MarkerForegroundColorIndex = iMarkerForegroundColorIndex
'    ActiveChart.Legend.LegendEntries(i).LegendKey.MarkerStyle = iMarkerStyle
'    ActiveChart.Legend.LegendEntries(i).LegendKey.MarkerSize = iMarkerSize
'
    AChart_Dest.SeriesCollection(i).Border.ColorIndex = AChart_Source.SeriesCollection(iIndex).Border.ColorIndex
    AChart_Dest.SeriesCollection(i).Border.Weight = AChart_Source.SeriesCollection(iIndex).Border.Weight
    AChart_Dest.SeriesCollection(i).Border.LineStyle = AChart_Source.SeriesCollection(iIndex).Border.LineStyle
    AChart_Dest.SeriesCollection(i).MarkerBackgroundColorIndex = AChart_Source.SeriesCollection(iIndex).MarkerBackgroundColorIndex
    AChart_Dest.SeriesCollection(i).MarkerForegroundColorIndex = AChart_Source.SeriesCollection(iIndex).MarkerForegroundColorIndex
    AChart_Dest.SeriesCollection(i).MarkerStyle = AChart_Source.SeriesCollection(iIndex).MarkerStyle
    AChart_Dest.SeriesCollection(i).MarkerSize = AChart_Source.SeriesCollection(iIndex).MarkerSize
        
  Next i

ErrorHandler:
  
  Err = 0

End Sub

'---------------------------------------------------------------------------------------
' Procedure : Set_Borders
' Author    : dev@bassetti.fr
' Date      : 15/09/2011
' Purpose   : procedure settings the 4 external borders of a range with a given set of attributes.
'---------------------------------------------------------------------------------------
'
Public Sub Set_Borders(AR As Range, Optional ALineStyle = xlNone, Optional AWeight = xlThick, Optional AColorIndex = 1)
    
    Call Set_Border(AR.Borders(xlEdgeRight), ALineStyle, AWeight, AColorIndex)
    Call Set_Border(AR.Borders(xlEdgeBottom), ALineStyle, AWeight, AColorIndex)
    Call Set_Border(AR.Borders(xlEdgeTop), ALineStyle, AWeight, AColorIndex)
    Call Set_Border(AR.Borders(xlEdgeLeft), ALineStyle, AWeight, AColorIndex)

End Sub

'---------------------------------------------------------------------------------------
' Procedure : Set_Border
' Author    : dev@bassetti.fr
' Date      : 15/09/2011
' Purpose   : procedure settings the a given border with a given set of attributes.
'---------------------------------------------------------------------------------------
'
Public Sub Set_Border(ABorder As Border, Optional ALineStyle = xlNone, Optional AWeight = xlThick, Optional AColorIndex = 1)
  
  ABorder.LineStyle = ALineStyle
  
  If ALineStyle = xlNone Then: Exit Sub
  
  ABorder.Weight = AWeight
  ABorder.ColorIndex = AColorIndex
End Sub


'---------------------------------------------------------------------------------------
' Procedure : Clear_Border
' Author    : dev@bassetti.fr
' Date      : 28/03/2012
' Purpose   : procedure removing all borders of a given range.
'---------------------------------------------------------------------------------------
'
Sub Clear_Borders(AR As Range)

  Call Set_Borders(AR)
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Clear_Border
' Author    : dev@bassetti.fr
' Date      : 28/03/2012
' Purpose   : procedure removing a given border of a given range.
'---------------------------------------------------------------------------------------
'
Sub Clear_Border(ABorder As Border)
  
  Call Set_Border(ABorder)
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : WSExists
' Author    : dev@bassetti.fr
' Date      : 20/02/2012
' Purpose   : function returning true if a given workbook owns a sheet with a given name.
'---------------------------------------------------------------------------------------
'
Public Function WSExists(AWB As Workbook, ByVal AName As String) As Boolean
Dim i As Integer

  For i = 1 To AWB.Sheets.Count
    
    If StrComp(AWB.Sheets(i).Name, AName, vbTextCompare) = 0 Then
      WSExists = True
      Exit Function
    End If
  Next i

  WSExists = False
End Function

'---------------------------------------------------------------------------------------
' Function  : Get_WS_Compatible_Name
' Author    : dev@bassetti.fr
' Date      : 29/03/2012
' Purpose   : function returning a worksheet name compatible with a given workbook. The name is based on a proposed name. It is possibly truncated. A suffix (_1, _2, aso.) may be added if another sheets has the same name.
' Param     :
' - AWB As Workbook - the excel workbook where to search for an eventual worksheet with the same name.
' - AName As String - the name of the workbook.
'---------------------------------------------------------------------------------------
'
Function Get_WS_Compatible_Name(AWB As Workbook, AName As String, Optional ANew As Boolean = True) As String
Dim sSuffix As String, sName As String
Dim i As Long
Dim s

  'Worksheet's names cannot exceed 31 characters.
  sName = Left(AName, Application.Min(Len(AName), 31))
   
  For Each s In [{"?",":","/",";","*"}]
  

    sName = Replace(sName, s, " ")
  
  Next s
   
  Get_WS_Compatible_Name = sName
  
  If ANew And WSExists(AWB, Get_WS_Compatible_Name) Then
    i = 1
    Do
      sSuffix = "_" & i
      Get_WS_Compatible_Name = Left(sName, Application.Min(Len(sName), 30 - Len(sSuffix))) & sSuffix
      Call Inc(i)
    Loop While WSExists(AWB, Get_WS_Compatible_Name)
        
  End If

End Function

'---------------------------------------------------------------------------------------
' Function  : Copy_WS
' Author    : dev@bassetti.fr
' Date      : 29/03/2012
' Purpose   : function copying a given Worksheet.
' Param     :
' - AWS As Worksheet - the worksheet to copy.
' - Optional ByVal AName As String = vbNullString - the name to assign to the worksheet copied. This name may be automatically changed.
'                                         If empty, the default name "Copy of ..." is kept.
'---------------------------------------------------------------------------------------
'
Public Function Copy_WS(AWS As Worksheet, Optional ByVal AName As String = vbNullString) As Worksheet
Dim sName As String
Dim i As Long
Dim WB As Workbook
  
  Set WB = AWS.Parent
  
  Call AWS.Copy(, WB.Worksheets(WB.Sheets.Count))
  Set Copy_WS = WB.Worksheets(WB.Sheets.Count)
  
  If AName <> vbNullString Then: Copy_WS.Name = Get_WS_Compatible_Name(WB, AName)

End Function

'---------------------------------------------------------------------------------------
' Procedure : Unmerge_Cells_In_Range
' Author    : dev@bassetti.fr
' Date      : 27/03/2012
' Purpose   : function unmerging all merged cells into a given range and possibly duplicating the values contained into the merge area.
' Param(s)  :
' - ByRef AR As Range - the range to treat.
' - ByVal ADuplicate_Values As Boolean - if true, values contained into the merge area are copied into all the cells of the area.
'---------------------------------------------------------------------------------------
'
Sub Unmerge_Cells_In_Range(ByRef AR As Range, ByVal ADuplicate_Values As Boolean)
Dim Area As Range, C As Range
Dim s As String
  
  For Each C In AR
    
    If C.MergeCells Then
        
      Set Area = C.MergeArea
      
      C.UnMerge
      
      If ADuplicate_Values Then: Area.Value = C.Value
    
    End If
  Next C
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : RangeOk
' Author    : dev@bassetti.fr
' Date      : 10/04/2012
' Purpose   : function returning true if a a given range is assigned and has an address different from a given one.
'             This function is usefull when using the textsearch of Excel because is may loop infinitely.
' Param(s)  :
' - ByRef AR As Range - the range to check.
' - Optional AAddress_To_Avoid As String = vbNullString - The address to avoid. If empty, the function only checks if the range is assigned or not.
'---------------------------------------------------------------------------------------
'
Public Static Function RangeOk(AR As Range, Optional AAddress_To_Avoid As String = vbNullString) As Boolean

  RangeOk = Not AR Is Nothing
  If RangeOk Then: RangeOk = (AAddress_To_Avoid = vbNullString) Or (AR.Address <> AAddress_To_Avoid)

End Function

Public Function Open_TSV_File(ByVal APath_File As String, Optional AInterpret_Cells_Values As Boolean = True, Optional AOrigin As Long = 0) As Workbook
Dim i As Long, iLast_Col As Long
Dim sDir As String, sPath_File As String

  'Loading the file if needed.
  If StrComp(LCase(Left(APath_File, 4)), "http", vbTextCompare) = 0 Then
    sDir = Get_Dir_User_Tmp
    i = 1
    sPath_File = sDir & "File" & i & ".tsv"
    While FileExists(sPath_File)
      sPath_File = sDir & "File" & Inc(i) & ".tsv"
    Wend
    
    Call Download_File(APath_File, sPath_File)
  Else
    sPath_File = APath_File
  End If
  
  If AOrigin = 0 Then
    'Excel 2002 does not handle codepage for the field "origin".
    'Assuming it is an Ansi file.
    If CDblExt(Application.Version) < 11 Then
      AOrigin = xlWindows
    Else
      AOrigin = Get_File_CodePage(sPath_File)
      'In case of no code page, assuming it is an Ansi file.
      If AOrigin = 0 Then: AOrigin = xlWindows
    End If
  End If
  
  'Opening the data file a first time to retrieve the number of colums (...)
  Workbooks.OpenText FileName:=sPath_File, Origin:=AOrigin, DataType:=xlDelimited, Tab:=True, TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=False
  
  If Not AInterpret_Cells_Values Then
  
    iLast_Col = Last_Col(ActiveWorkbook.Worksheets(1))
  
    'Setting the array used for the FieldInfo parameter.
    ReDim Arr2_Field_Info(1 To iLast_Col, 0 To 1)
    For i = 1 To iLast_Col
          
      Arr2_Field_Info(i, 0) = i
      Arr2_Field_Info(i, 1) = xlTextFormat
          
    Next i
    ActiveWorkbook.Close
    
    'Opening the data file (a second time...)
    Workbooks.OpenText FileName:=sPath_File, Origin:=AOrigin, DataType:=xlDelimited, Tab:=True, TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=False, FieldInfo:=Arr2_Field_Info
  End If
  
  Set Open_TSV_File = ActiveWorkbook


End Function

Public Sub Clear_Chart(AChart As Chart)
  
  While AChart.SeriesCollection.Count > 0
    Call AChart.SeriesCollection(1).Delete
  Wend
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Concat_Range
' Author    : dev@bassetti.fr
' Date      : 31/08/2012
' Purpose   : function concatenating the values of a given range.
'             For each row, columns are concatenated using the ASep1 separator.
'             Rows are concatenated using the ASep2 separator.
'             The function forces the separator even if the cells are empty.
' Param(s)
' - AR As Range - The range to concatenate.
' - ASep1 as string - the separator used for the first spliting.
' - ASep2 as string - the separator used for the second spliting (which is done many times).
'---------------------------------------------------------------------------------------
'
Function Concat_Range(AR As Range, ByVal ASep1 As String, ByVal ASep2 As String) As String
Dim C
Dim sLine As String, sTot As String
Dim iRow As Long
    
  If AR Is Nothing Then
    Concat_Range = ""
    Exit Function
  End If
  
  sTot = ""
    
  If AR.Areas.Count > 1 Then: Exit Function
  
  iRow = 0
  sLine = ""
  For Each C In AR.Cells
      
    If C.Row <> iRow Then
      If iRow > 0 Then
        sTot = Quick_Concat(sTot, sLine, ASep1)
      End If
      iRow = C.Row
      sLine = C.Value
    Else
      sLine = Quick_Concat(sLine, C.Value, ASep2, True)
    End If
    
  Next C
  
  Concat_Range = Quick_Concat(sTot, sLine, ASep1)
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Concat_Worksheet
' Author    : dev@bassetti.fr
' Date      : 31/08/2012
' Purpose   : function concatenating the values of the filled range of a given worksheet.
'             For each row, columns are concatenated using the ASep1 separator.
'             Rows are concatenated using the ASep2 separator.
'             The function forces the separator even if the cells are empty.
' Param(s)
' - ByVal AWS as Worksheet - The worksheet to concatenate.
' - ASep1 as string - the separator used for the first spliting.
' - ASep2 as string - the separator used for the second spliting (which is done many times).
'---------------------------------------------------------------------------------------
'
Function Concat_Worksheet(AWS As Worksheet, ByVal ARow_Separator As String, ByVal ACol_Separator As String) As String
Dim iRow_Max As Long, iCol_Max As Long

  iRow_Max = Last_Row(AWS)
  iCol_Max = Last_Col(AWS)
    
  If iRow_Max > 0 And iCol_Max > 0 Then
    Concat_Worksheet = Concat_Range(AWS.Range(AWS.Cells(1, 1), AWS.Cells(iRow_Max, iCol_Max)), ARow_Separator, ACol_Separator)
  Else
    Concat_Worksheet = ""
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Split2_Value
' Author    : dev@bassetti.fr
' Date      : 31/08/2012
' Purpose   : function returning a 2 dimensions array, result of a double spliting operation.
'             The first spliting is done using the ASep1 separator.
'             The second spliting (one for each row) is done using the ASep2 separator.
'             The function does not guaranty that all the arrays of the second dimension have the same length.
' Param(s)
' - ByVal S as string - the string to split.
' - ASep1 as string - the separator used for the first spliting.
' - ASep2 as string - the separator used for the second spliting (which is done many times).
'---------------------------------------------------------------------------------------
'
Function Split2(ByVal s As String, ByVal ASep1 As String, ByVal ASep2 As String)
Dim Arr_Sep1, v
Dim Arr2()
Dim i As Long

  Arr_Sep1 = Split(s, ASep1)
  
  Call Redim_Array(Arr2, LenExt(Arr_Sep1))
  
  i = 0
  For Each v In Arr_Sep1
    
    Arr2(i) = Split(v, ASep2)
    Call Inc(i)
  Next v
  
  Split2 = Arr2
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Split2_To_Range
' Author    : dev@bassetti.fr
' Date      : 31/08/2012
' Purpose   : function double spliting a string and assigning the result to a given range with the values.
'             The first spliting is done using the ASep1 separator.
'             The second spliting (one for each row) is done using the ASep2 separator.
'             The function returns the range filled.
' Param(s)
' - ByVal S as string - the string to split.
' - ACell_Start as range - the start cell where to put the splited values.
' - ASep1 as string - the separator used for the first spliting.
' - ASep2 as string - the separator used for the second spliting (which is done many times).
'---------------------------------------------------------------------------------------
'
Function Split2_To_Range(ByVal s As String, ACell_Start As Range, ByVal ASep1 As String, ByVal ASep2 As String) As Range
Dim Arr_Sep1, v, Arr_Sep2
Dim rWS As Worksheet
Dim iRow As Long, iCol_Start As Long, iNb_Col As Long, iNb_Col_Max As Long

  Set rWS = ACell_Start.Worksheet
  iRow = ACell_Start.Row
  iCol_Start = ACell_Start.Column
  
  Arr_Sep1 = Split(s, ASep1)
  
  For Each v In Arr_Sep1
      
    Arr_Sep2 = Split(v, ASep2)
    iNb_Col = LenExt(Arr_Sep2)
    iNb_Col_Max = Application.Max(iNb_Col, iNb_Col_Max)
    rWS.Range(rWS.Cells(iRow, iCol_Start), rWS.Cells(iRow, iCol_Start + iNb_Col - 1)) = Arr_Sep2
    Call Inc(iRow)
      
  Next v
  
  Set Split2_To_Range = rWS.Range(ACell_Start, rWS.Cells(iRow - 1, iCol_Start + iNb_Col_Max - 1))
  
End Function



Attribute VB_Name = "M_Exportation"
Option Explicit


Public Const C_Data_Separator = "|"
Public Const C_Value_Separator = "<v>"
Public Const C_Line_Separator = "<br>"

Public Const C_Row_TD = 9
Public Const C_First_Object_Row = 12


'''<summary>Procedure formating a range of dates values (or list of dates).</summary>
'''<param name='AR'>The range to format.</param>
'''<param name='AFormat'>The date format.</param>
Public Sub Format_Dates(AR As Range, AFormat As String)
Dim Cell As Range
Dim Arr_Value
Dim sValue
Dim s As String


  For Each Cell In AR.Cells
    Arr_Value = Split(Cell.Value, C_Data_Separator)
    
    s = ""
    If UBound(Arr_Value) > 0 Then
      For Each sValue In Arr_Value
        s = Quick_Concat(s, Format(sValue, AFormat), C_Data_Separator)
      Next sValue
      
      Cell.Value = s
    Else
      If s <> "" Then
        Cell.Value = CDblExt(Cell.Value)
      End If
      Cell.NumberFormat = AFormat
    End If
    
  Next Cell
End Sub


'''<summary>Do not use for the moment!</summary>
'''<returns>A string</returns>
Public Function Get_Data_Separator() As String
  
  'If Worksheets("Hidden").Cells(14, 3) Then
  '  Get_Data_Separator = Chr(10)
  'Else
    Get_Data_Separator = C_Data_Separator
  'End If
  
End Function



'''<summary>Function returning the line separator used in this file. By default, it is C_Line_Separator
'''but the Data formating function may have replaced them by a #10 character.</summary>
'''<returns>A string</returns>
Public Function Get_Line_Separator() As String
  
  If Worksheets("Hidden").Cells(14, 3) Then
    Get_Line_Separator = Chr(10)
  Else
    Get_Line_Separator = C_Line_Separator
  End If
  
End Function


Attribute VB_Name = "M_Utils"
'---------------------------------------------------------------------------------------
' Module    : M_Utils
' Author    : dev@bassetti.fr
' Date      : 20/09/2011
' Purpose   : Utils for VBA.
'---------------------------------------------------------------------------------------

Option Explicit

Private Type PROCESS_INFORMATION
          hProcess As Long
          hThread As Long
          dwProcessId As Long
          dwThreadId As Long
        End Type

Private Type STARTUPINFO
          cb As Long
          lpReserved As String
          lpDesktop As String
          lpTitle As String
          dwX As Long
          dwY As Long
          dwXSize As Long
          dwYSize As Long
          dwXCountChars As Long
          dwYCountChars As Long
          dwFillAttribute As Long
          dwFlags As Long
          wShowWindow As Integer
          cbReserved2 As Integer
          lpReserved2 As Long
          hStdInput As Long
          hStdOutput As Long
          hStdError As Long
        End Type

#If Win64 Then
Private Declare PtrSafe Function CreateProcess Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
Private Declare PtrSafe Function OpenProcess Lib "kernel32.dll" (ByVal dwAccess As Long, ByVal fInherit As Integer, ByVal hObject As Long) As Long
Private Declare PtrSafe Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
Private Declare PtrSafe Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
#Else
Private Declare Function CreateProcess Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
Private Declare Function OpenProcess Lib "kernel32.dll" (ByVal dwAccess As Long, ByVal fInherit As Integer, ByVal hObject As Long) As Long
Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
Private Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
#End If

Public Const NaN As Double = 1.79769313486231E+308
Public Const Infinity As Double = 1.7976931348623E+308
Public Const NegInfinity As Double = -1.79769313486231E+308

'---------------------------------------------------------------------------------------
' Procedure : BrowseForFolder
' Author    : http://www.mrexcel.com/forum/showthread.php?t=294728
' Date      : 13/04/2012
' Purpose   : function opening a dialog box allowing to select a folder and returning the path of the folder selected.
' Param(s)  :
' - Optional ATitle As String = "Select folder" - the title of the dialog box.
' - Optional ARoot_Dir As String = "" - a root directory to filter on.
'---------------------------------------------------------------------------------------
'
Public Static Function BrowseForFolder(Optional ATitle As String = "Select folder", Optional ARoot_Dir As String = "") As String
Dim FD As FileDialog
  
  Set FD = Application.FileDialog(msoFileDialogFolderPicker)
  With FD
    .Title = ATitle
    .AllowMultiSelect = False
    .InitialFileName = ARoot_Dir
    If .Show = -1 Then
      BrowseForFolder = IncludeTrailingPathDelimiter(.SelectedItems(1))
    Else
      BrowseForFolder = ""
    End If
  End With
  
  Set FD = Nothing

End Function

'---------------------------------------------------------------------------------------
' Procedure : Short_DirPath
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : function returning the DOS path of a given folder.
'---------------------------------------------------------------------------------------
'
Public Static Function Short_DirPath(ByVal APath As String, Optional ByVal AInclude_Slash As Boolean = True) As String
Dim fs, f

 Set fs = CreateObject("Scripting.FileSystemObject")
 
 Set f = fs.GetFolder(APath)
 
 Short_DirPath = f.ShortPath
 If AInclude_Slash Then: Short_DirPath = Short_DirPath & "\"
 Set fs = Nothing

End Function

'---------------------------------------------------------------------------------------
' Procedure : ExtractFileDir
' Author    : dev@bassetti.fr
' Date      : 30/11/2011
' Purpose   : function returning the directory of a given file.
' Param(s)  :
'  - ByVal APath_File as string - the path to the file (relative or absolute).
'---------------------------------------------------------------------------------------
'
Public Static Function ExtractFileDir(ByVal APath_File As String) As String
  
  ExtractFileDir = Left(APath_File, InStrRev(APath_File, "\"))
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : ExtractFileName
' Author    : dev@bassetti.fr
' Date      : 13/04/2012
' Purpose   : function returning the filename of a given file path.
' Param(s)  :
'  - ByVal APath_File as string - the path to the file (relative or absolute).
'---------------------------------------------------------------------------------------
'
Public Static Function ExtractFileName(ByVal APath_File As String) As String
  
  ExtractFileName = Right(APath_File, Len(APath_File) - InStrRev(APath_File, "\"))

End Function

'---------------------------------------------------------------------------------------
' Procedure : ExtractFileExt
' Author    : dev@bassetti.fr
' Date      : 13/04/2012
' Purpose   : function returning the extension of a given file.
' Param(s)  :
'  - ByVal APath_File as string - the path to the file (relative or absolute).
'---------------------------------------------------------------------------------------
'
Public Static Function ExtractFileExt(ByVal APath As String) As String
Dim iPos As Integer
Dim sFileName As String

  'Usefull in certain cases (for example : C:\.svn\A_File_Without_Extension)
  sFileName = ExtractFileName(APath)
  
  iPos = InStrRev(sFileName, ".")
  If iPos > 0 Then
    ExtractFileExt = Right(sFileName, Len(sFileName) - iPos + 1)
  Else
    ExtractFileExt = ""
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Short_FilePath
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : function returning the DOS path of a given file.
'---------------------------------------------------------------------------------------
'
Public Static Function Short_FilePath(ByVal APath As String) As String
Dim fs, f

 Set fs = CreateObject("Scripting.FileSystemObject")
 
 Set f = fs.GetFile(APath)
 
 Short_FilePath = f.ShortPath

 Set fs = Nothing

End Function


Public Static Sub Copy_File(ByVal ASource As String, ByVal ADest As String)
Dim fs As Object
  
  Set fs = CreateObject("Scripting.FileSystemObject")
  fs.CopyFile ASource, ADest
  
  Set fs = Nothing


End Sub
'---------------------------------------------------------------------------------------
' Procedure : DirExists
' Author    : dev@bassetti.fr
' Date      : 30/11/2011
' Purpose   : function returning true if a directory exists.
' Param(s)  :
'  - ByVal ADir As String - the directory to check.
'---------------------------------------------------------------------------------------
'
Public Static Function DirExists(ByVal ADir As String) As Boolean
Dim fs
  
  Set fs = CreateObject("Scripting.FileSystemObject")
  DirExists = fs.FolderExists(ADir)
  Set fs = Nothing

End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_Dir_User_Tmp
' Author    : http://nicholasworkshop.wordpress.com/2010/07/13/get-temporary-folder-path-in-vba/
' Date      : 11/04/2012
' Purpose   : function returning the user's temporary directory path.
'---------------------------------------------------------------------------------------
'
Public Static Function Get_Dir_User_Tmp() As String
Const C_Length_Path = 256
Dim sDir As String
Dim iCode As Long

  sDir = String(C_Length_Path, 0)
  iCode = GetTempPath(C_Length_Path, sDir)
  
  If iCode <> 0 Then
    Get_Dir_User_Tmp = IncludeTrailingPathDelimiter(Left(sDir, InStr(sDir, Chr(0)) - 1))
  Else
    Get_Dir_User_Tmp = vbNullString
  End If

End Function

'---------------------------------------------------------------------------------------
' Procedure : Fill_Arr_Files
' Author    : dev@bassetti.fr
' Date      : 13/04/2012
' Purpose   : procedure filling a given array with the files/folders of a given directory.
' Param(s)  :
' - ByRef AArr_Files As Variant - the array to fill.
' - ByVal ADirectory As String - the directory to search into.
' - ByVal ARecursive as boolean - if true, subfolders will also be scanned.
' - ByRef AArr_Extension() As String  - an array of filtering extensions.
' - ByVal AList_Directories As Boolean = False - if true, directories are listed.
'---------------------------------------------------------------------------------------
'
Private Sub Fill_Arr_Files(ByRef AArr_Files As Variant, ADirectory As String, ByVal ARecursive As Boolean, ByRef AArr_Extension() As String, AList_Directories As Boolean)
Dim fs
Dim Obj_Folder, Obj_SubFolders
Dim Obj
Dim bFilter_On_Extensions As Boolean

  bFilter_On_Extensions = IsArrayAllocated(AArr_Extension)
  
  Set fs = CreateObject("Scripting.FileSystemObject")
  Set Obj_Folder = fs.GetFolder(ADirectory)
  Set Obj_SubFolders = Obj_Folder.SubFolders
  
  'Treating subfolders
  For Each Obj In Obj_SubFolders
    If AList_Directories Then
      Call Redim_Array(AArr_Files, 1, Obj.Path)
    End If
    
    If ARecursive Then: Call Fill_Arr_Files(AArr_Files, Obj.Path, True, AArr_Extension, AList_Directories)
  Next Obj
  
  'Treating files.
  For Each Obj In Obj_Folder.Files
    If bFilter_On_Extensions Then
      If sIndexOf(AArr_Extension, ExtractFileExt(Obj.Path)) > -1 Then
        Call Redim_Array(AArr_Files, 1, Obj.Path)
      End If
    Else
      Call Redim_Array(AArr_Files, 1, Obj.Path)
    End If
  Next Obj
  
  'TODO: not sure it is very usefull.
  Set Obj_SubFolders = Nothing
  Set Obj_Folder = Nothing
  Set fs = Nothing

End Sub

'---------------------------------------------------------------------------------------
' Procedure : Create_Arr_Files
' Author    : dev@bassetti.fer
' Date      : 12/04/2012
' Purpose   : function creating an array containing the path of the files contained into a given directory.
' Param(s)  :
' - ADirectory As String - the directory to search into.
' - Optional ByVal ARecursive as boolean = True - if true, subfolders will also be scanned.
' - Optional AExtensions As String = vbNullString - a list of filtering extensions (separated by a ";" character).
' - Optional ByVal AList_Directories As Boolean = False - if true, directories are listed.
'---------------------------------------------------------------------------------------
'
Public Function Create_Arr_Files(ADirectory As String, Optional ByVal ARecursive As Boolean = True, Optional AExtensions As String = vbNullString, Optional ByVal AList_Directories As Boolean = False) As String()
Dim Arr_Extension() As String

  Arr_Extension = Split(AExtensions, ";")
       
  Call Fill_Arr_Files(Create_Arr_Files, ADirectory, ARecursive, Arr_Extension, AList_Directories)
  
  Erase Arr_Extension
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Create_Dir
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure creating a directory (and deleting the previous dir if existing).
'Params(s):
' - ByVal ADir as String - the directory path to create.
'---------------------------------------------------------------------------------------
'
Public Static Sub Create_Dir(ByVal ADir As String)

  If Not DirExists(ADir) Then: MkDir ADir
    
End Sub

'---------------------------------------------------------------------------------------
' Procedure : FileExists
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning true if a given file exists.
'Params(s):
' - AFile_Path as String - the path to the file.
'---------------------------------------------------------------------------------------
'
Public Static Function FileExists(AFile_Path As String)
Dim fs
  Set fs = CreateObject("Scripting.FileSystemObject")
  FileExists = fs.FileExists(AFile_Path)
End Function

'---------------------------------------------------------------------------------------
' Procedure : Delete_File
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure deleting a file or a directory.
' Param(s)  :
' - ADir as String - the directory path to create.
'---------------------------------------------------------------------------------------
'
Public Static Sub Delete_File(AFile_Path As String)
  If FileExists(AFile_Path) Then
    Call Kill(AFile_Path)
  End If
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Execute
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function executing a (executable) file with a string of parameters.
' Param(s)  :
' - ByVal AExecutable As String - the executable path.
' - Optional AParameters As String = vbNullString - a parameter string.
' - Optional AWait As Boolean = False - if true, the function will wait until the executable ends.
' - Optional AVisible As Boolean = False - if false, the executable will not be visible.
'---------------------------------------------------------------------------------------
'
Public Static Function Execute(ByVal AExecutable As String, Optional AParameters As String = vbNullString, Optional AWait As Boolean = False, Optional AVisible As Boolean = True) As Long
Const SYNCHRONIZE = 1048576
Const NORMAL_PRIORITY_CLASS = &H20&
Const INFINITE = &HFFFF
Const STARTF_USESHOWWINDOW = 1
Const SW_HIDE = 0

Dim pInfo As PROCESS_INFORMATION
Dim sInfo As STARTUPINFO
Dim sNull As String

  sInfo.cb = Len(sInfo)
  
  If Not AVisible Then
    sInfo.dwFlags = STARTF_USESHOWWINDOW
    sInfo.wShowWindow = SW_HIDE
  End If
  
  Execute = CreateProcess(sNull, AExecutable & " " & AParameters, ByVal 0&, ByVal 0&, _
                                 1&, NORMAL_PRIORITY_CLASS, ByVal 0&, sNull, sInfo, pInfo)
  
  If AWait Then
    Call WaitForSingleObject(pInfo.hProcess, INFINITE)
  End If

  Call TerminateProcess(pInfo.hProcess, 0&)
  Call CloseHandle(pInfo.hThread)
  Call CloseHandle(pInfo.hProcess)
  
End Function


'---------------------------------------------------------------------------------------
' Procedure : Pi
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Pi!
'---------------------------------------------------------------------------------------
'
Public Static Function Pi() As Double
  Pi = 4 * Atn(1)
End Function

'---------------------------------------------------------------------------------------
' Procedure : Random
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Random function.
' Param(s)
' - ByVal AMin_Value As Double - the min value of the range.
' - ByVal AMax_Value As Double - the max value of the range.
'---------------------------------------------------------------------------------------
'
Public Static Function Random(ByVal AMin_Value As Double, ByVal AMax_Value As Double) As Double
  Call Randomize
  Random = Rnd() * (AMax_Value - AMin_Value) + AMin_Value
End Function

'---------------------------------------------------------------------------------------
' Procedure : Log10
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : Function returning the Log10 value of a given value.
' Param(s)
' - X as double - the value used for the log calculation.
'---------------------------------------------------------------------------------------
'
Public Static Function Log10(X As Double) As Double
  
  If Not isNaN(X) Then
    If X > 0 Then
      Log10 = Log(X) / Log(10#)
    Else
      Log10 = NaN
    End If
  Else
    Log10 = NaN
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_Decimal_Separator
' Author    : dev@bassetti.fr
' Date      : 31/10/2012
' Purpose   : Function returning THE REAL decimal separator used by Excel and not the one stored into Application. DecimalSeparator. The function assumes that the decimal separator is a single character.
'---------------------------------------------------------------------------------------
'
Function Get_Decimal_Separator() As String
Dim s As String * 256
Const LOCALE_SDECIMAL = &HE
Const LOCALE_USER_DEFAULT = &H400
  
  If Application.UseSystemSeparators Then
    If GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, s, Len(s)) > 0 Then
      Get_Decimal_Separator = Left(s, InStr(s, Chr(0)) - 1)
    Else
      Get_Decimal_Separator = Application.DecimalSeparator
    End If
  Else
    Get_Decimal_Separator = Application.DecimalSeparator
  End If

End Function

'---------------------------------------------------------------------------------------
' Procedure : CDblExt
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : Extension of the CDbl function. The function returns a given default value if the conversion of the expression as double fails.
' Param(s)
' - Expression - the expression to convert.
' - Optional ByVal ADefault As Double = NaN - the default value to return in case of the conversion fails.
'---------------------------------------------------------------------------------------
'
Public Static Function CDblExt(Expression, Optional ByVal ADefault As Double = NaN) As Double
Dim sFrom As String, sTo As String, s As String

  CDblExt = ADefault
  
  If IsEmpty(Expression) Then: Exit Function
    
  sTo = Get_Decimal_Separator
  sFrom = IIf(sTo = ",", ".", ",")
  
  If InStr(Expression, sFrom) Then
    s = Replace(Expression, sFrom, sTo)
  Else
    s = Expression
  End If
  
  If IsNumeric(s) Then
    CDblExt = CDbl(s)
  Else
    'Date are numerics.
    If IsDate(Expression) Then: CDblExt = CDate(Expression)
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : isNaN
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : function returning true if a given double value is "Not A Numerical".
' Param(s)
' - AValue As Double - the value to evaluate.
'---------------------------------------------------------------------------------------
'
Public Static Function isNaN(AValue As Double) As Boolean
  isNaN = (AValue = NaN)
End Function

'---------------------------------------------------------------------------------------
' Procedure : isInfinite
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : function returning true if a given double value is either the infinity or the negative infinity.
' Param(s)
' - AValue As Double - the value to evaluate.
'---------------------------------------------------------------------------------------
'
Public Static Function isInfinite(AValue As Double) As Boolean
  isInfinite = (AValue = Infinity) Or (AValue = NegInfinity)
End Function

'---------------------------------------------------------------------------------------
' Procedure : Integrate_From_Arrays
' Author    : dev@bassetti.fr
' Date      : 08/04/2012
' Purpose   : function returning the integrale of a curve represented by its X and Y arrays. The method used is a trapezoidale sum.
'             The function handles NaN values.
' Param(s)
' - ByRef AArr_X() As Double - the X array.
' - ByRef AArr_Y() As Double - the Y array.
'---------------------------------------------------------------------------------------
'
Public Static Function Integrate_From_Arrays(ByRef AArr_X() As Double, ByRef AArr_Y() As Double) As Double
Dim i As Long, iStart As Long, iEnd As Long
Dim fXi_1 As Double, fYi_1 As Double
  
  Integrate_From_Arrays = 0
  iStart = LBound(AArr_X)
  iEnd = Application.Min(UBound(AArr_X), UBound(AArr_Y))
  Do
    fXi_1 = AArr_X(iStart)
    fYi_1 = AArr_Y(iStart)
    Call Inc(iStart)
  Loop While iStart < iEnd And isNaN(fXi_1) Or isNaN(fYi_1)
  
  For i = iStart To iEnd
    
    If Not isNaN(AArr_X(i)) And Not isNaN(AArr_Y(i)) Then
      Integrate_From_Arrays = Integrate_From_Arrays + (AArr_Y(i) + fYi_1) * (AArr_X(i) - fXi_1) / 2
      fXi_1 = AArr_X(i)
      fYi_1 = AArr_Y(i)
    End If
    
  Next i

End Function


'---------------------------------------------------------------------------------------
' Procedure : Inc
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure incrementing a long value by AShift.
' Param(s)
' - ByRef AVal As Long - the value to increment.
' - Optional AShift As Long = 1 - the shift.Sub Dec(ByRef AVal As Long, Optional AShift As Long = 1)
'---------------------------------------------------------------------------------------
'
Public Function Inc(ByRef AVal As Long, Optional AShift As Long = 1) As Long

   AVal = AVal + AShift
   Inc = AVal
    
End Function

'---------------------------------------------------------------------------------------
' Procedure : Dec
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Procedure decrementing a long value by AShift.
' Param(s)
' - ByRef AVal As Long - the value to decrement.
' - Optional AShift As Long = 1 - the shift.
'---------------------------------------------------------------------------------------
'
Public Function Dec(ByRef AVal As Long, Optional AShift As Long = 1) As Long

   Dec = Inc(AVal, -AShift)
    
End Function

'---------------------------------------------------------------------------------------
' Procedure : Quick_Concat
' Author    : dev@bassetti.fr
' Date      : 09/09/2011
' Purpose   : Function returning a string obtained by concatenating two string and a separator. By default, the function does not add the separator if one of the string is empty.
' Param(s)
' - ByVal AValue1 As String - the first string.
' - ByVal AValue2 As String - the second string.
' - ByVal ASeparator As String - the separator string.
' - Optional AForce_Separator As Boolean = False - if true, the separator will be added even if AValue2 is empty.
'---------------------------------------------------------------------------------------
'
Public Static Function Quick_Concat(ByVal AValue1 As String, ByVal AValue2 As String, ByVal ASeparator As String, Optional AForce_Separator As Boolean = False) As String

    If ((AValue1 <> vbNullString) And (AValue2 <> vbNullString)) Or AForce_Separator Then
      Quick_Concat = AValue1 & ASeparator & AValue2
    Else
      Quick_Concat = AValue1 & AValue2
    End If
    
End Function


'---------------------------------------------------------------------------------------
' Procedure : Count_Token
' Author    : dev@bassetti.fr
' Date      : 12/10/2011
' Purpose   : function returning the number of token into a given string.
' Param(s)
' - ByVal S As String - the string where to search the token.
' - ByVal AToken As String - the token to search.
'---------------------------------------------------------------------------------------
'
Public Static Function Count_Token(ByVal s As String, ByVal AToken As String) As String
  
  Count_Token = (Len(s) - Len(Replace(s, AToken, vbNullString, , , 1))) / Len(AToken)
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : IncludeTrailingPathDelimiter
' Author    : dev@bassetti.fr
' Date      : 12/10/2011
' Purpose   : An implementation of the IncludeTrailingPathDelimiter (not existing in vba (?)).
' Param(s)
' - ByVal ADir As String - the directory.
'---------------------------------------------------------------------------------------
'
Public Static Function IncludeTrailingPathDelimiter(ByVal ADir As String) As String
  
  If Right(ADir, 1) <> "\" Then
    IncludeTrailingPathDelimiter = ADir & "\"
  Else
    IncludeTrailingPathDelimiter = ADir
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : ExcludeTrailingPathDelimiter
' Author    : dev@bassetti.fr
' Date      : 30/11/2011
' Purpose   : An implementation of the ExcludeTrailingPathDelimiter (not existing in vba (?)).
' Param(s)  :
' - ByVal ADir As String - the directory.
'---------------------------------------------------------------------------------------
'
Public Static Function ExcludeTrailingPathDelimiter(ByVal ADir As String) As String
  
  If Right(ADir, 1) = "\" Then
    ExcludeTrailingPathDelimiter = Left(ADir, Len(ADir) - 1)
  Else
    ExcludeTrailingPathDelimiter = ADir
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Sort_Arr_Long
' Author    : dev@bassetti.fr
' Date      : 20/20/2012
' Purpose   : procedure sorting entirely or partially an array of long values, using the bubble sort method.
' Param(s)  :
' - ByRef AArr() As Long - the array to sort.
' - Optional ByVal ALB As Long = -1 - the lower bound of the range inside the array where to apply the sort.
' - Optional ByVal AUB As Long = -1 - the upper bound of the range inside the array where to apply the sort.
'---------------------------------------------------------------------------------------
'
Public Sub Sort_Arr_Long(ByRef AArr() As Long, Optional ByVal ALB As Long = -1, Optional ByVal AUB As Long = -1)
Dim i As Long
Dim bOk As Boolean
Dim iTmp As Long
 
  If ALB = -1 Then
    ALB = LBound(AArr())
  Else
    ALB = Application.Max(LBound(AArr()), ALB)
  End If
  
  If AUB = -1 Then
    AUB = UBound(AArr())
  Else
    ALB = Application.Min(UBound(AArr()), AUB)
  End If

  Do
    bOk = True
    For i = ALB To AUB - 1
      If AArr(i) > AArr(i + 1) Then
          bOk = False
          iTmp = AArr(i)
          AArr(i) = AArr(i + 1)
          AArr(i + 1) = iTmp
      End If
    Next i
  Loop While Not bOk
  
End Sub

'---------------------------------------------------------------------------------------
' Procedure : IndexOf
' Author    : dev@bassetti.fr
' Date      : 14/10/2011
' Purpose   : function returning the index of a given value into a given array. The function returns -1 if not found.
' Param(s)  :
' - ByRef AArray() - the array where to search the value.
' - ByVal AValue - the value to search.
'---------------------------------------------------------------------------------------
'
Public Static Function IndexOf(ByRef AArray(), ByVal AValue) As Long

  If IsArrayAllocated(AArray) Then

    For IndexOf = LBound(AArray) To UBound(AArray)
    
      If AArray(IndexOf) = AValue Then: Exit Function
  
    Next IndexOf
     
  End If
  
  IndexOf = -1

End Function

' Procedure : sIndexOf
' Author    : dev@bassetti.fr
' Date      : 14/10/2011
' Purpose   : function returning the index of a given STRING value into a given STRING array. The function returns -1 if not found.
' Param(s)  :
' - ByRef AArray() as string - the array where to search the value.
' - ByVal AValue as string - the value to search.
'---------------------------------------------------------------------------------------
'
Public Static Function sIndexOf(ByRef AArray() As String, ByVal AValue As String) As Long

  If IsArrayAllocated(AArray) Then

    For sIndexOf = LBound(AArray) To UBound(AArray)
    
      If AArray(sIndexOf) = AValue Then: Exit Function
  
    Next sIndexOf
     
  End If
  
  sIndexOf = -1

End Function

' Procedure : sIndexOf
' Author    : dev@bassetti.fr
' Date      : 14/10/2011
' Purpose   : function returning the index of a given STRING value into a given STRING array. The function returns -1 if not found.
' Param(s)  :
' - ByRef AArray() as string - the array where to search the value.
' - ByVal AValue as string - the value to search.
'---------------------------------------------------------------------------------------
'
Public Static Function iIndexOf(ByRef AArray() As Long, ByVal AValue As Long) As Long

  If IsArrayAllocated(AArray) Then

    For iIndexOf = LBound(AArray) To UBound(AArray)
    
      If AArray(iIndexOf) = AValue Then: Exit Function
  
    Next iIndexOf
     
  End If
  
  iIndexOf = -1

End Function

'---------------------------------------------------------------------------------------
' Procedure : IsArrayAllocated
' Author    : dev@bassetti.fr based on http://www.cpearson.com/excel/vbaarrays.htm
' Date      : 14/10/2011
' Purpose   : function returning true if the variant sent is an Array and was allocated.
' Param(s)  :
' - ByRef AArr As Variant - the array to test.
'---------------------------------------------------------------------------------------
'
Public Static Function IsArrayAllocated(ByRef AArr As Variant) As Boolean
Dim iUB As Long

  On Error Resume Next

  'The variant is not an array.
  If IsArray(AArr) = False Then
    IsArrayAllocated = False
    Exit Function
  End If

  'Attempting to get the UBound of the array. If the array has not been allocated, an error should raise.
  iUB = UBound(AArr, 1)
    
  If (Err.Number = 0) Then
    'Under some circumstances, even if an array is not allocated, no error raises.
    'The comparison of the bounds enables to detect this case.
    IsArrayAllocated = (LBound(AArr) <= iUB)
  Else
    IsArrayAllocated = False
  End If
  
  Err.Clear

End Function

'---------------------------------------------------------------------------------------
' Procedure : Redim_Array
' Author    : dev@bassetti.fr
' Date      : 10/04/2012
' Purpose   : function resizing a given array. It preserves the existing values, handles the case where the array is not assigned.
'             The new items may be assigned a default value.
'             The main interest of this function is its aptitude to handle unassigned array.
' Param(s)  :
' - ByRef AArr As Variant - the array to modify.
' - Optional AShift As Long = 1 - the number of items to add / remove. In case of a negative shift, if the new length is lower than 0, the array is simply deallocated.
' - Optional AValue As Variant = vbNullString - a default value. If the variant value is set to an empty string, no value is assigned.
'---------------------------------------------------------------------------------------
'
Function Redim_Array(ByRef AArr As Variant, Optional AShift As Long = 1, Optional AValue As Variant = vbNullString) As Long
Dim i As Long
Dim iLB As Long, iUB As Long
  
  If IsArrayAllocated(AArr) Then
    iLB = LBound(AArr)
    iUB = UBound(AArr) + AShift
  Else
    iLB = 0
    iUB = AShift - 1
  End If
  
  If iLB > iUB Then
    Erase AArr
  Else
    ReDim Preserve AArr(iLB To iUB)
    
    If AValue <> vbNullString And AShift > 0 Then
      For i = iUB - AShift + 1 To iUB
        AArr(i) = AValue
      Next i
    End If
  End If
  
  Redim_Array = iUB
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Add_To_Array
' Author    : dev@bassetti.fr
' Date      : 12/04/2012
' Purpose   : function resizing a given array. It preserves the existing values, handles the case where the array is not assigned.
'             The new items may be assigned a default value.
'             The main interest of this function is its aptitude to handle unassigned array.
' Param(s)  :
' - ByRef AArr_Dest As Variant - the array to modify.
' - ByRef AArr_Source as Variant - the array of values to add.
' - Optional APreserve As Boolean = True - if false, the destination array is erased.
'---------------------------------------------------------------------------------------
'
Public Sub Add_To_Array(ByRef AArr_Dest As Variant, ByRef AArr_Source As Variant, Optional APreserve As Boolean = True)
Dim i As Long, iShift As Long

  If Not APreserve Then: Erase AArr_Dest
  
  If Not IsArrayAllocated(AArr_Source) Then: Exit Sub
  
  Call Redim_Array(AArr_Dest, UBound(AArr_Source) - LBound(AArr_Source) + 1)
  
  iShift = UBound(AArr_Dest) - UBound(AArr_Source)
  
  For i = LBound(AArr_Source) To UBound(AArr_Source)
    AArr_Dest(i + iShift) = AArr_Source(i)
  Next i

End Sub

'---------------------------------------------------------------------------------------
' Procedure : LenExt
' Author    : dev@bassetti.fr
' Date      : 10/04/2012
' Purpose   : extension of the function "Len" handling arrays.
' Param(s)  :
' - Expression - the value whose length must be evaluated.
'---------------------------------------------------------------------------------------
'
Function LenExt(Expression) As Long

  If IsArray(Expression) Then
    If IsArrayAllocated(Expression) Then
      LenExt = UBound(Expression) - LBound(Expression) + 1
    Else
      LenExt = 0
    End If
  Else
    LenExt = Len(Expression)
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_File_Encoding
' Author    : dev@bassetti.fr
' Date      : 15/05/2012
' Purpose   : function returning the encoding of a given text file. The function returns an empty value for non unicode format.
' Param(s)  :
' - APath_File as string - the path of the file.
'---------------------------------------------------------------------------------------
'
Public Function Get_File_Encoding(ByVal APath_File As String) As String
Dim b1 As Byte, b2 As Byte, b3 As Byte, b4 As Byte
    
  Open APath_File For Binary As #1
  
  Get #1, , b1
  Get #1, , b2
  Get #1, , b3
  Get #1, , b4
  Close #1

  If b1 = &HEF And b2 = &HBB And b3 = &HBF Then
    Get_File_Encoding = "UTF-8" '65001
  ElseIf b1 = &HFF And b2 = &HFE And b3 = &H0 And b4 = &H0 Then
    Get_File_Encoding = "UTF-32LE" '12000 aka UTF-32 Little Endian
  ElseIf b1 = &H0 And b2 = &H0 And b3 = &HFE And b4 = &HFF Then
    Get_File_Encoding = "UTF-32BE" '12001 aka UTF-32 Big Endian
  ElseIf b1 = &HFF And b2 = &HFE Then
    Get_File_Encoding = "UTF-16LE" '1200 aka UTF-16 Little Endian
  ElseIf b1 = &HFE And b2 = &HFF Then
    Get_File_Encoding = "UTF-16BE" '1201 aka UTF-16 Big Endian
  ElseIf b1 = &H2B And b2 = &H2F And b3 = &H76 And (b4 = &H38 Or b4 = &H39 Or b4 = &H2B Or b4 = &H2F) Then
    Get_File_Encoding = "UTF-7" '65000
  ElseIf b1 = &HDD And b2 = &H73 And b3 = &H66 And b4 = &H73 Then
    Get_File_Encoding = "UTF-EBCDIC"
  ElseIf b1 = &HE And b2 = &HFE And b3 = &HFF Then
     Get_File_Encoding = "SCSU"
  ElseIf b1 = &HFB And b2 = &HEE And b3 = &H28 Then
      Get_File_Encoding = "BOCU-1"
  ElseIf b1 = &H84 And b2 = &H31 And b3 = &H95 And b4 = &H33 Then
     Get_File_Encoding = "GB18030"
  Else
    Get_File_Encoding = ""
  End If
  
End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_File_CodePage
' Author    : dev@bassetti.fr
' Date      : 15/05/2012
' Purpose   : function returning the windows code page of a given text file. The function returns an null value for non unicode format.
'             See http://msdn.microsoft.com/en-us/library/dd317756%28VS.85%29.aspx
' Param(s)  :
' - APath_File as string - the path of the file.
'---------------------------------------------------------------------------------------
'
Public Function Get_File_CodePage(ByVal APath_File As String) As Long
      
  Select Case Get_File_Encoding(APath_File)
    Case "UTF-8"
      Get_File_CodePage = 65001
    Case "UTF-32LE"
      Get_File_CodePage = 12000
    Case "UTF-32BE"
      Get_File_CodePage = 12001
    Case "UTF-16LE"
      Get_File_CodePage = 1200
    Case "UTF-16BE"
      Get_File_CodePage = 1201
    Case "UTF-7"
      Get_File_CodePage = 65000
    Case "GB18030"
      Get_File_CodePage = 54938
    Case Else
      Get_File_CodePage = 0
  End Select
    
End Function

Function Download_File(ASource As String, ADestination As String) As Boolean
Dim WinHttpReq As Object
Dim oStream As Object
    
  Set WinHttpReq = CreateObject("Microsoft.XMLHTTP")
  WinHttpReq.Open "GET", ASource, False
  WinHttpReq.send
  
  ASource = WinHttpReq.responseBody
  If WinHttpReq.Status = 200 Then
    Set oStream = CreateObject("ADODB.Stream")
    oStream.Open
    oStream.Type = 1
    oStream.Write WinHttpReq.responseBody
    oStream.SaveToFile (ADestination)
    oStream.Close
    Download_File = True
  Else
    Download_File = False
  End If
End Function

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

' InQuest injected base64 decoded content
' ZrH+

INQUEST-PP=macro
