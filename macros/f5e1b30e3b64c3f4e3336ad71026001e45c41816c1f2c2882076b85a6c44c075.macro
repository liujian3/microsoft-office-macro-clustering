Attribute VB_Name = "AAMainCode"
Option Explicit
#If Win64 Then
  Private Declare PtrSafe Sub AppSleep Lib "kernel32" Alias "Sleep" (ByVal dwMilliseconds As LongLong)
#Else
  Private Declare Sub AppSleep Lib "kernel32" Alias "Sleep" (ByVal dwMilliseconds As Long)
#End If
Public Fs(5) As String
Public Ts(5) As String
Public PDesc(5) As String
Public PatternItem As Integer
Public Qt As String
Public findText(200) As String
Public replaceT(200) As String
Public patternSW(5, 200) As Boolean
Public vPoints As Single
Public hPoints As Single
Public HideText As String
Public OldWindowView As Object
Dim globalFindString As String
Dim globalIndexString As String
Dim globalSubString As String, aIndexStr As String
Dim cancelSw As Boolean
Dim WholeWord As Boolean, MatchCaseSw As Boolean, goSingleSw As Boolean
Dim BulletsOrNumbersItem As Integer, TypeItemValue As Integer
Dim PromptResponse As Integer
Dim No_of_Changes As Integer
Dim track_hold As Boolean, view_track_hold As Boolean
Dim Percentage_old As Integer
Dim Viewtype_Old As Long
Dim RangetoTest As Range
Dim RgStart As Range
Dim RgFin As Range
Dim RgTst As Range
Dim MasterRange As Range
Dim HighlightReturn As Long
Dim rr As Range
Dim savedStatus As Boolean
Dim nList As Long
Dim FormIsVert As Boolean
Dim returnToSw As Boolean
Dim shp As Shape
Dim textboxSw As Boolean
Dim shadingOBJ As Shading
Dim userCase As Boolean
Dim jString As Long
Dim noHighlightSW As Boolean

Sub GO_TEXTEDIT() ' initiate from icon or Launcher button
Dim j As Long

  HideText = ""

  If HideText = "Hidden" Then
   With MainForm
     .IndexNames.Height = 192
     .Show
     For j = 0 To 4
      Select Case j
        Case 0
          .Strings0Option.Caption = PDesc(0)
        Case 1
          .Strings1Option.Caption = PDesc(1)
        Case 2
          .Strings2Option.Caption = PDesc(2)
        Case 3
          .Strings3Option.Caption = PDesc(3)
        Case 4
          .Strings4Option.Caption = PDesc(4)
      End Select
     Next j
     .PromptAllOption.Value = True
   End With
'HideText = ""
'PatternItem = -1
   Exit Sub
  End If
  HideText = "Hidden"
  For j = 0 To 4
    PDesc(j) = "empty"
  Next j
'  PDesc(0) = ""
  Set_TextEdit
End Sub

Private Sub Set_TextEdit()
Dim astr As String
Dim j As Long
Dim k As Long
  Qt = Chr(34)
  'Set MainForm = VertForm
  FormIsVert = True
  Call GiveScreenPoints(hPoints, vPoints)
  Set OldWindowView = ActiveWindow.View
  With ActiveWindow
    .DisplayHorizontalScrollBar = True
    .DisplayVerticalScrollBar = True
    .DisplayLeftScrollBar = False
    If .StyleAreaWidth = 0 Then .StyleAreaWidth = CentimetersToPoints(1.5)
    .DisplayRightRuler = False
    .DisplayScreenTips = False
    setOldPaneValues
  End With
  
  With MainForm
  .IndexNames.Height = 192
    .IndexNames.ColumnWidths = "310" ' forces horizontal scroll bar
'    .RemoveSpaces.Value = True
'   MainForm.RemoveSpaces.Value = True ' reset selection to first item
'    PatterNameSet (PatternItem)
    MainForm.StartUpPosition = 0
    If vPoints - .Height < 40 Then
      .Top = 0
      PromptReplaceForm.Top = 60 'vPoints - PromptReplaceForm.Height
      OkBox.Top = 60 'vPoints - OkBox.Height
      PromptItem.Top = 60 'vPoints - PromptItem.Height
    Else
      .Top = 20
      PromptReplaceForm.Top = 235
      OkBox.Top = 345
      PromptItem.Top = 250
    End If
 
    .Left = hPoints - MainForm.Width - 15
    OkBox.Left = hPoints - OkBox.Width - 15
    Application.DisplayStatusBar = True
    ActiveWindow.View.ShowFieldCodes = False
  
    PromptReplaceForm.StartUpPosition = 0
    PromptReplaceForm.Left = hPoints - PromptReplaceForm.Width - 15
    PromptItem.StartUpPosition = 0
    PromptItem.Left = hPoints - PromptItem.Width - 15
   ' .AllTextAction.Value = True
   ' Change_Master_Actions (1) ' set text changes as default master action

    PatternItem = -1
    If .Strings0Option.Value = True Then PatternItem = 0
    If .Strings1Option.Value = True Then PatternItem = 1
    If .Strings2Option.Value = True Then PatternItem = 2
    If .Strings3Option.Value = True Then PatternItem = 3
    If .Strings4Option.Value = True Then PatternItem = 4
    
    If PatternItem < 0 Then ' hasn't been initiated
      For j = 0 To 5
        Fs(j) = ""
        Ts(j) = ""
        For k = 0 To 200
          patternSW(j, k) = True
        Next k
        PatternItem = 0
      Next j
      Fs(0) = Qt & "[^32]{2,}" & Qt & "," & Qt & " ^13" & Qt
      Ts(0) = Qt & "^32" & Qt & "," & Qt & "^p" & Qt
  
     
      .Strings0Option.Caption = "Multiple spaces to single space"
      PDesc(0) = .Strings0Option.Caption
      Call UserSetupOK(False, Fs(PatternItem), Ts(PatternItem))
      .Strings0Option.Value = True
    Else
   ' LoadPatterns (PatternItem)
    Call UserSetupOK(False, Fs(PatternItem), Ts(PatternItem))
    End If
    PDesc(0) = .Strings0Option.Caption
    LoadPatterns (PatternItem)
    .AutoQuotesCheckbox.Value = Options.AutoFormatAsYouTypeReplaceQuotes
    .Show
  End With
End Sub
Sub Cancel_Edit(n As Long)
  UserSet.Hide
  'CapitaliseForm.hide
  MainForm.Hide
  resetPanes (1)
End Sub
Sub gotoDocTop(n As Long)
Dim sRange As Range
  Set sRange = ActiveDocument.Paragraphs(1).Range
  sRange.End = sRange.Start
  sRange.Select
End Sub
Private Sub setOldPaneValues()
Exit Sub
     With ActiveWindow
       If .View.SplitSpecial = wdPaneNone Then
         Viewtype_Old = .ActivePane.View.Type
    '     .ActivePane.View.Type = wdNormalView
       Else
         Viewtype_Old = .View.Type
   '      .View.Type = wdNormalView
       End If
       Percentage_old = .ActivePane.View.Zoom.Percentage
     End With
     With ActiveDocument
       track_hold = .TrackRevisions
       view_track_hold = .ShowRevisions
     End With
End Sub
Sub resetPanes(n As Long)
Exit Sub
   With ActiveWindow
     If .View.SplitSpecial = wdPaneNone Then
       .ActivePane.View.Type = Viewtype_Old
     Else
       .View.Type = Viewtype_Old
     End If
       Percentage_old = .ActivePane.View.Zoom.Percentage
   End With
   With ActiveDocument
     .TrackRevisions = track_hold
     .ShowRevisions = view_track_hold
   End With
End Sub

Private Sub Changeto_NormalView()
 ' With ActiveWindow
 '  If .View.SplitSpecial = wdPaneNone Then
 '    .ActivePane.View.Type = wdNormalView
 '  Else
 '    .View.Type = wdNormalView
 '  End If
 ' End With
  Options.Pagination = False ' turn off pagination to speed up. Must be in normal view ??????
End Sub

Private Sub Changeto_PrintView()
  With ActiveWindow
   If .View.SplitSpecial = wdPaneNone Then
     .ActivePane.View.Type = wdPrintView
   Else
     .View.Type = wdPrintView
   End If
  End With
End Sub

Private Sub Changeto_DefaultView()
  With ActiveWindow
    On Error Resume Next
    If .View.SplitSpecial = wdPaneNone Then
      .ActivePane.View.Type = Viewtype_Old
    Else
      .View.Type = Viewtype_Old
    End If
    On Error GoTo 0
  End With
End Sub

'Sub Change_Master_Actions(n As Integer) ' 1=Text changes, 2=Textbox convert, 3=Headers, 4=Capitalise
'  MasterAction = n
'  savedStatus = ThisDocument.Saved
'  If MainForm Is Nothing Then Exit Sub
'  Select Case n
'    Case 2
'      MainForm.LoadCountsButton.Enabled = True
'      'PatterNameSet (13)
'      With TextboxForm
'        .Left = MainForm.Left + 40
'        .Top = MainForm.Top + 150
'        .Show
'      End With
  '    TextBoxFind
'    Case Else
'      'MainForm.Height = 478
'  End Select
'  Select Case n
'  Case 1 ' Text Changes
'     PatterNameSet (0)
'     With MainForm
'      .GoEdit.Visible = True
'      .GoSingle.Caption = "GO selected item"
'      .IndexNames.Visible = True
'      .Label3.Visible = True
'      .Label4.Visible = True
'      .ReplacementFrame.Visible = True
'      .PromptAllOption.Caption = "Prompt each replace"
'      .PromptDontOption.Caption = "No prompt"
'      .PromptItemOption.Caption = "Prompt at item start"
'      .PromptAllOption.Value = True
'      .LoadCountsButton.Enabled = True
'      .RemoveSpaces.Value = True
'PromptResponse = 2
'      .GoSingle.Visible = True
'      .GoSingle.Caption = "GO Single"
'      .Form1PageNo.Caption = ""
'      .ReplacementFrame.Visible = True
'      .PatternChange.Visible = True
'    End With
 
  '    Headfoot_Execute (1)
  
'  End Select
'  ThisDocument.Saved = savedStatus
'End Sub
Sub Set_CaseSensitive(n As Long)
  'userCase = UserSet.CaseSensitive.Value
End Sub
Sub set_RemoveOrAdd(n As Integer) 'remove=0, add=1, convert=2
  If n = 1 Then
     set_BtypeText (BulletsOrNumbersItem)
  Else
     set_BtypeText2 (n)
  End If
End Sub
Sub Set_PromptResponse(n As Integer)
  PromptResponse = n '0=yes, 1=No, 2=exit, 3=no more prompts, 4=cancel
  PromptReplaceForm.Hide
End Sub
Sub Set_ItemResponse(n As Integer)
  PromptResponse = n '0=yes, 1=No, 2=exit, 3=no more prompts, 4=cancel
  PromptItem.Hide
End Sub

Sub Go_Edit(gSw As Boolean)
 'If Not MainForm.AllTextAction.Value Then Exit Sub
  If ActiveDocument.TrackRevisions = True Then
    MsgBox "WARNING. Due to a bug in Word, when Track Changes is on" & vbCrLf & _
           "Find and Replace with wildcards can give results in error if" & vbCrLf & _
           "replace string contains more than one group replacement." & _
           "Suggest that you turn off Track Changes before you continue."
  End If
  goSingleSw = gSw
  On Error Resume Next ' in case bookmark already exists
  With ActiveDocument.Bookmarks ' bookmark position to return to
    .Add Range:=Selection.Range, Name:="returnto"
    .DefaultSorting = wdSortByName
    .ShowHidden = True
    returnToSw = True
  End With
  On Error GoTo 0
  
  Call EditRtext(findText, replaceT, WholeWord)
  On Error Resume Next
  MainForm.PromptAllOption.Value = True
  If returnToSw Then Selection.GoTo What:=wdGoToBookmark, Name:="returnto"
  ActiveDocument.Bookmarks("returnto").Delete
  On Error GoTo 0
End Sub
Private Sub Range_Test()
  Set RgStart = Selection.Range
  Set RgFin = Selection.Range
  Set RgTst = Selection.Range
  If Selection.End = Selection.Start + 1 Then Selection.End = Selection.Start ' single char
  If Selection.End > Selection.Start Then ' selected range
    RgStart.End = RgStart.Start
    RgFin.Start = RgFin.End
    RgTst.End = RgTst.Start
    Set RangetoTest = Selection.Range
    Set MasterRange = Selection.Range
  '  MainForm.RangeLabel.Caption = "CHANGES ONLY IN SELECTED RANGE"
  Else
    RgStart.End = RgStart.Start
    RgFin.End = ActiveDocument.Range.End
    RgFin.Start = RgFin.End
    RgTst.End = RgTst.Start
    Set RangetoTest = ActiveDocument.Range
    Set MasterRange = ActiveDocument.Range
    MasterRange.Start = Selection.Start  ' from selection forward
    RangetoTest.SetRange Start:=MasterRange.Start, End:=MasterRange.End
     
   ' MainForm.RangeLabel.Caption = "CHANGES FROM CURSOR TO DOC END"
  End If
  MasterRange.Start = RgStart.Start
  RangetoTest.Start = RgTst.Start
End Sub

Sub EditRtext(ByRef findText, ByRef replaceT, WholeWord)  ' edit replace
Dim Plength As Integer, irp As Long, iv As Integer
Dim testr As Boolean, singlesw As Boolean
Dim promptR As Variant
Dim st1 As String, st2 As String, changeStr As String
Dim aRange As Range
Dim thisReplace As Boolean
Dim j As Long, k As Long
  Range_Test ' sets ranges and RgTst. RgFin
  No_of_Changes = 0
  irp = 0
  If goSingleSw Then irp = MainForm.IndexNames.ListIndex
  If irp < 0 Then
    MsgBox "No item selected"
    Exit Sub
  End If
  ReDim nBefore(0)
  j = ActiveDocument.ComputeStatistics(statistic:=wdStatisticPages)
  If j > 300 Then
    MainForm.CountCheckbox.Value = False
  End If
  If j > 500 And goSingleSw = False Then
    If MsgBox("This document is large and may take a very long time to process." & vbCrLf & _
       "Suggest that you process single items at a time. Do you want to abort?", vbYesNo, "") = vbYes Then Exit Sub
  End If
  
 ' *********************** $$$$ the following will raise error if irp >200 $$$$**********************************************************************
  Do While (irp < 200) And (findText(irp) <> "") ' step through all replace items ******************************
    If MainForm.CountCheckbox.Value Then No_of_Changes = No_of_Changes + Load_Counts(irp)
    Changeto_NormalView
DoEvents
    With MainForm
      On Error Resume Next
      If .IndexNames.ListCount >= irp Then .IndexNames.ListIndex = irp ' count words may give fewer
      On Error GoTo 0
      .Repaint
    
      If Not patternSW(PatternItem, irp) Then GoTo itemExit
   
      If .PromptItemOption.Value And Not goSingleSw Then
        PromptItem.Show
        If PromptResponse = 2 Then GoTo loopExit
        If PromptResponse = 1 Then GoTo itemExit
      End If
      If .PromptDontOption.Value = False Then
        promptR = wdReplaceAll
        singlesw = True
      Else
        promptR = wdReplaceOne
        singlesw = False
      End If
    End With
    st1 = findText(irp)
    
    ' ******* SET RANGE TO TEST for each iteration **************************
Set RangetoTest = RgTst.Duplicate  ' *********************
      Set RangetoTest = ActiveDocument.Range
      RangetoTest.Start = RgTst.Start 'MasterRange.Start
      RangetoTest.End = RgFin.End 'MasterRange.End
    ' ************************************************
    
    If Not MainForm.PromptAllOption.Value Then
      thisReplace = True
    Else
      thisReplace = False
    End If
    If MainForm.HighlightOnlyOption.Value Then
      changeStr = "HIGHLIGHT"
      promptR = wdReplaceAll
      thisReplace = True
    Else
      changeStr = replaceT(irp)
    End If

    If Replace_it(RangetoTest, st1, changeStr, singlesw, thisReplace) < 0 Then GoTo loopExit
     
   On Error Resume Next ' ********** if no shaperange will give error ********
   j = 0
   On Error Resume Next
   j = MasterRange.ShapeRange.Count
   On Error GoTo 0
   If j = 0 Then GoTo itemExit
   
  ' ********************* shapes *********************************
   If Not MainForm.TextboxCheckbox.Value Then GoTo itemExit
   On Error GoTo itemExit
   For Each shp In MasterRange.ShapeRange
      If Application.Version < 14 And shp.Type <> 17 Then GoTo shpNext ' overcomes bug in W2007
      With shp.TextFrame
        If .HasText Then
          Set aRange = .TextRange
          aRange.Select  ' this changes view to printview ***************
         If Replace_it(aRange, st1, changeStr, singlesw, thisReplace) < 0 Then GoTo loopExit
        End If
      End With
shpNext:
    Next shp
    resetPanes (1)
    RangetoTest.Start = RgTst.Start
    RangetoTest.End = RgFin.End
    
    RgTst.Select ' does not work if selection has no length
  '  RangetoTest.Select
    
itemExit:
    On Error GoTo 0
    If MainForm.CountCheckbox.Value Then No_of_Changes = No_of_Changes - Load_Counts(irp)
    irp = irp + 1
    If goSingleSw Then irp = 200
    
    Set RangetoTest = MasterRange
 
  Loop ' do while i<200 ***************************************
  
  Selection.End = Selection.Start
  GoTo endgame
  
loopExit: ' cancel buttons return here
  returnToSw = False
  
  If MainForm.CountCheckbox.Value Then No_of_Changes = No_of_Changes - Load_Counts(irp)
endgame:
  PromptReplaceForm.Hide
  Application.StatusBar = ""
  'MainForm.Form1PageNo.Caption = ""
  Changeto_PrintView
  ActiveWindow.View.ShowFieldCodes = False
  
  
  With OkBox
    If Not MainForm.CountCheckbox.Value Or MainForm.HighlightOnlyOption.Value Or noHighlightSW Then
      .OkBoxLabel = "End of run." & vbCrLf & "Counts not available."
    Else
      .OkBoxLabel = "End of run." & vbCrLf & Trim(Str(No_of_Changes)) & " text changes made"
    End If
    .Left = MainForm.Left + 116
    .Top = MainForm.Top + 200
    .Show
     'OkBox.hide
  End With
 ' Changeto_DefaultView
    RgFin.Select
Jpoint1:
 
  'MainForm.RangeLabel.Caption = ""
  MainForm.PromptAllOption.Value = True ' reset default prompt
End Sub


Function Replace_it(RTest As Range, st1 As String, changeStr As String, _
                    singlesw As Boolean, thisReplace As Boolean) As Integer
Dim WXstart As Range
Dim Ftest As Boolean
Dim st3 As String
Dim rpCount As Long
Dim fieldView As Boolean
   Set WXstart = Selection.Range
   WXstart.Start = RTest.Start
   WXstart.End = RTest.End ' find range

    With WXstart.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Replacement.Highlight = False
        .Text = st1
        .Replacement.Text = changeStr
        .Forward = True
        .Format = False
        .Wrap = wdFindStop
        .Format = False
    '    .Highlight = False leave unset to be non specific
        .MatchCase = False
        .MatchWholeWord = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        .MatchPrefix = False
        .MatchWildcards = MainForm.WildcardsOption.Value
        .MatchCase = MainForm.CaseSensitiveOption.Value
    End With

 '  WXstart.Select
   Ftest = True
   rpCount = 0
   
   ' ***************************** find loop *****************************
   Do Until Not Ftest
     rpCount = rpCount + 1
     If rpCount > 500 Then
       MsgBox "More than 500 items found for " & st1
       GoTo itemExit
     End If
     
     fieldView = ActiveWindow.View.ShowFieldCodes
     ActiveWindow.View.ShowFieldCodes = True
     If InStr(1, Selection.Range.Sentences(1), Chr(19)) > 0 Then ' in a field ***********
       WXstart.Start = Selection.Range.Sentences(1).End ' not perfect but it works
     End If
     ActiveWindow.View.ShowFieldCodes = fieldView
     
     If Selection.Information(wdWithInTable) Then ' ditto
       WXstart.End = Selection.End
     Else
       WXstart.End = RTest.End
     End If
'    WXstart.Select
'RTest.Select
 '    WXstart.Find.MatchWildcards = MainForm.WildcardsOption.Value
 '    WXstart.Find.MatchCase = MainForm.CaseSensitiveOption.Value
     
 '    If PatternItem = 12 And UserSet.WildcardCheckBox = True Then
 '      WXstart.Find.MatchWildcards = True
       If InStr(st1, "^p") > 0 And MainForm.WildcardsOption Then
         If MsgBox("Cannot search for ^p if wild cards is on. Use ^13 instead" & vbCrLf & _
           "Do you want to switch off wild cards and continue", vbYesNo) = vbNo Then Exit Function
         WXstart.Find.MatchWildcards = False
         'UserSet.WildcardCheckBox.Value = False
       End If
  '   End If
  
     If WXstart.Find.MatchCase And Selection.Find.MatchWildcards Then
       If MsgBox("Cannot have both matchcase and wildcards at the same time" & vbCrLf & _
          "Do you want to switch off matchcase and continue?", vbYesNo) = vbNo Then Exit Function
          WXstart.Find.MatchCase = False
         ' UserSet.CaseSensitive.Value = False
     End If
     noHighlightSW = False
     If st1 = "NO HIGHLIGHT" Or MainForm.NoHighlightOption Then ' special case
       noHighlightSW = True
       changeStr = ""
       st1 = ""
       With WXstart.Find ' highlighting ******************
         .Text = st1
         .Replacement.Text = changeStr
         .Highlight = True  ' will find only highlighted text
         .Replacement.Highlight = False
         .Format = True
         Ftest = .Execute(Replace:=wdReplaceAll)
       End With
       
       With RTest.Font.Shading ' shading **********MUST HAVE RANGE AND NOT "from here"********
         .Texture = wdTextureNone
         .ForegroundPatternColor = wdColorAutomatic
         .BackgroundPatternColor = wdColorAutomatic
       End With
       With Options
         .DefaultBorderLineStyle = wdLineStyleSingle
         .DefaultBorderLineWidth = wdLineWidth050pt
         .DefaultBorderColor = wdColorAutomatic
       End With
       
       GoTo itemExit
     End If
     
' if no prompt then execute with Replace:=wdreplaceall and goto itemexit
     On Error GoTo itemerr   ' picks up invalid wildcards
     If thisReplace Then
       With WXstart.Find
         If changeStr = "HIGHLIGHT" Then
            .Replacement.Highlight = True
            .Replacement.Text = ""
            If Options.DefaultHighlightColorIndex = wdNoHighlight Then _
              MsgBox "There is no highlight color set."
         End If
        Ftest = .Execute(Replace:=wdReplaceAll)
      End With
      GoTo itemExit
     Else
       Ftest = WXstart.Find.Execute(Replace:=wdReplaceNone)
     End If
'WXstart.Select
     On Error GoTo 0
     If Not Ftest And Selection.Information(wdWithInTable) Then
        GoToNextcell
        WXstart.Start = Selection.Start
        Ftest = True
        GoTo nextLoop
     End If
     If Ftest Then
       WXstart.Select
       If MainForm.ReplacementFrame.PromptDontOption.Value = True Or _
          MainForm.HighlightOnlyOption.Value = True Then
         PromptResponse = 0
       Else
         Changeto_PrintView ' for viewing prompt ********
         SetColor
         If changeStr = "HIGHLIGHT" Then
           With WXstart.Find
             .ClearFormatting
             .Replacement.ClearFormatting
             .Replacement.Highlight = True
             .Replacement.Text = ""
           End With
         End If
  '       Call Replace_Found_Text_Prompt(singlesw, st1, changeStr)
  'WXstart.Select
  DoEvents
         Call Replace_Found_Text_Prompt(singlesw, Selection.Text, changeStr)
         RemoveColor
       End If
       If PromptResponse = 2 Then GoTo itemExit ' goto next find item
       If PromptResponse = 4 Then GoTo loopExit ' cancel
       
       If PromptResponse = 1 Then ' No don't change
       
         WXstart.Select
         If Selection.Information(wdWithInTable) Then
           GoToNextcell
           WXstart.Start = Selection.Start
         Else
           WXstart.Start = WXstart.End
         
           WXstart.MoveStart unit:=wdCharacter, Count:=1
         End If
  WXstart.Select ' **********************************************************************
         If WXstart.Start >= RTest.End Then GoTo itemExit
         GoTo nextLoop
       End If
      
       If PromptResponse = 0 Or PromptResponse = 3 Then ' change
         If PromptResponse = 3 Then thisReplace = True
         With Selection ' ****** find results in a selection ***************
           .Collapse direction:=wdCollapseStart
           WXstart.MoveStart unit:=wdCharacter, Count:=-1
           WXstart.End = RTest.End 'ActiveDocument.Range.End
           Ftest = WXstart.Find.Execute(Replace:=wdReplaceOne)
          
           WXstart.Select
           .Collapse direction:=wdCollapseEnd
           If Not Ftest Then ' can get no replacement if selection includes shape anchor
             Selection.Move unit:=wdCharacter, Count:=Len(st1)
           End If
         End With
         If Selection.Information(wdWithInTable) Then ' advance to next cell
           GoToNextcell
           WXstart.Start = Selection.Start
         End If
         WXstart.Start = Selection.Start ' **** move to end of found *******
         
   'WXstart.Select
         
       End If ' change
       
     End If ' ftest
nextLoop:
   Loop ' *********************** end of loop ***************************************
itemExit:
  Replace_it = 0
  Exit Function
loopExit:
  Replace_it = -1
  Exit Function
itemerr:
  MsgBox "Error in wildcards"
End Function

Private Sub GoToNextcell() ' moves to next table cell. if last cell then move to next char after table
Dim cellOBJ As Cell
  With Selection
     On Error Resume Next
     Set cellOBJ = .Cells(1).Next
     On Error GoTo 0
     If cellOBJ Is Nothing Then
         .Move unit:=wdCharacter, Count:=1
      Else
         .MoveRight unit:=wdCell, Count:=1, Extend:=wdMove
      End If
  End With
End Sub

Sub Replace_Found_Text_Prompt(ByVal singlesw As Boolean, ByVal st3 As String, ByVal changeStr As String)
Dim st2 As String
'SetColor
  If Not singlesw Then
    PromptResponse = 0
  Else
    st2 = "Replace " & Chr(34) & st3 & Chr(34) & _
          Chr(13) & "With    " & Chr(34) & changeStr & Chr(34)
    With PromptReplaceForm
      .ReplaceWhat.Caption = st2
      .Left = MainForm.Left + 115
      .Top = MainForm.Top + 90
      .Show
    End With
'RemoveColor
  End If
End Sub

'***************************************************************??????????????
'Sub PatterNameSet(n As Integer)
'Dim s As String

 ' n=8 is not used
'  PatternItem = n
'  Call Get_Pattern(n, findText, replaceT, WholeWord, MatchCaseSw)
'  Load_Patterns (1)
'  UserSet.hide
'  TextBoxForm.hide
'  textboxSw = True
  
'  Range_Test  '
  
'  If PatternItem = 12 Then ' user defined
'    With UserSet
'      .CaseSensitive.Value = False
'      .StartUpPosition = 0
'      .Left = hPoints - 60 - UserSet.Width
'      .Top = (vPoints - UserSet.Height) / 2
'      .UserHints = "Find/replace pairs can be entered directly above or can be" & vbCrLf & _
'          "copied from any open document. Text must be in quotes and must be matched. " & _
'          "Straight or curley quotes can be used." & vbCrLf & vbCrLf & _
'          "Wildcard strings can also be entered. For example" & vbCrLf & _
'          "from "",([! 0-9])"" to "", \1"" will add a space after a" & vbCrLf & _
'          "comma that doesn't have a space except if the nexr char is numeric. Wildcards must be selected." & vbCrLf & _
'          vbCrLf & """HIGHLIGHT""" & " in To will highlight specified text" & _
'          vbCrLf & """NO HIGHLIGHT""" & " in From will remove all highlighting in document. No prompt will be given" & vbCrLf & _
'          vbCrLf & "Document FindReplaceData.docx containing useful pairs."
'      .AutoformatCheckbox.Value = Options.AutoFormatReplaceQuotes
'      .UserFrom = giveStrings(s)
'      .UserTo = s
'      .Show
'    End With
'  End If
'End Sub


Sub setPatternSw(j As Long, i As Long)
Dim k As Long
  jString = j
  For k = 0 To i
    patternSW(j, k) = True
  Next k
End Sub

Sub GetCounts(n As Integer)

  If ActiveDocument.ComputeStatistics(statistic:=wdStatisticPages) > 200 Then
    If MsgBox("This may take some time because document is large" & vbCrLf & _
              "Do you want to continue?", vbYesNo, "") = vbNo Then Exit Sub
  End If
  Call Load_Counts(-1)
End Sub

Function Load_Counts(ii As Long) As Long
Dim i As Long
Dim iCount As Long
Dim imax As Long
Dim st As String
Dim fct As Long
Dim rnge As Range
Dim Xtot As Long
Dim Qt As String
Dim st1 As String
Dim st2 As String
Dim rrgst As Long
Dim rmgst As Long
Dim rmgfn As Long
Dim rrgfn As Long
Dim ggtst As Long
Dim ggtfn As Long
  Load_Counts = 0
  Qt = Chr(34)
  'MainForm.AllTextAction.Value = False
  Set rnge = ActiveDocument.Content
  Xtot = ActiveDocument.Range.End
   
  With rnge.Find
    .ClearFormatting
    .Replacement.ClearFormatting
   ' .Text = "<et al>"
   ' .Font.Italic = True
    .Replacement.Text = "^&!"
 '   .MatchWildcards = False
    .MatchWholeWord = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
    .MatchPrefix = False
    .MatchWildcards = True
    .MatchCase = False
   ' .Execute Replace:=wdReplaceAll
     If PatternItem = 10 Or PatternItem = 6 Or (PatternItem = 12 And userCase) Then
       rnge.Find.MatchCase = True
     Else
       rnge.Find.MatchCase = False
     End If
   
  End With
  
  If ii < 0 Then
    i = 0
    imax = 200
    MainForm.IndexNames.Clear
  Else
    i = ii
    imax = ii + 1
  End If
  Do While (i < imax) And (findText(i) <> "")
    st1 = findText(i)
    If InStr(st1, "^p") > 0 Then
      rnge.Find.MatchWildcards = False
    Else
      rnge.Find.MatchWildcards = True
    End If
    If RangetoTest Is Nothing Then
      Exit Function
    End If
    rrgst = RangetoTest.Start
    rrgfn = RangetoTest.End
    rmgst = MasterRange.Start
    rmgfn = MasterRange.End
    ggtst = RgTst.Start
    ggtfn = RgTst.End
    If patternSW(PatternItem, i) Then
      rnge.Find.Text = st1
      On Error Resume Next ' some strings are incompatible with wildcards
      rnge.Find.Execute Replace:=wdReplaceAll ' initialise count ********************
      On Error GoTo 0
      fct = ActiveDocument.Range.End - Xtot
      If fct > 0 Then WordBasic.editundo  ' editundo suuffs up ranges *****
    Else
      fct = -1
      st1 = "***" & st1
    End If
    RangetoTest.Start = rrgst
    RangetoTest.End = rrgfn
    MasterRange.Start = rmgst
    MasterRange.End = rmgfn
    RgTst.Start = ggtst
    RgTst.End = ggtfn
    
 Set RgFin = RangetoTest.Duplicate ' *******???????
    
    RgFin.Start = RangetoTest.Start
    RgFin.End = RangetoTest.End
    If ii < 0 Then
      st1 = Qt & st1 & Qt
      st2 = Str(fct)
      If Len(st1) > 20 Then
        If Len(st1) > 30 Then st1 = Left(st1, 16) & Chr(133)
      Else
        st1 = Left(st1 & "                  ", 20)
      End If
      MainForm.IndexNames.AddItem st1 & st2
    End If
    
    If ii = i Then Load_Counts = fct
    i = i + 1
  Loop

End Function
Private Sub SetColor()
  Set shadingOBJ = Selection.Font.Shading
  Selection.Font.Shading.Texture = wdTextureNone
  Selection.Font.Shading.ForegroundPatternColor = wdColorAutomatic
  Selection.Font.Shading.BackgroundPatternColor = wdColorTurquoise
  DoEvents
 ' need a pause here
 'PauseApp (1)

End Sub
Private Sub RemoveColor()
  On Error Resume Next
  Selection.Font.Shading.Texture = shadingOBJ.Texture
  Selection.Font.Shading.BackgroundPatternColor = wdColorWhite 'shadingOBJ.BackgroundPatternColor
  On Error GoTo 0
End Sub
 
Private Sub PauseApp(PauseInSeconds As Long)
    Call AppSleep(PauseInSeconds * 500) ' half seconds  will not word in 64 bit 2013
End Sub

Sub set_btype(n As Integer)
 ' MainForm.NoBullets.Value = True
  TypeItemValue = n
End Sub

'Private Sub TextBoxFind()
'  ActiveDocument.ActiveWindow.View.ShowObjectAnchors = True
'  textboxSw = False
'  Call mTb(False)
'End Sub
Sub LoadTextboxForm(n As Long)
    With TextboxForm
      .Left = MainForm.Left + 40
      .Top = MainForm.Top + 150
      .Show
    End With
End Sub
Sub Go_nextBox(n As Long)
 ' TextBoxForm.TBLabel.Caption = ""
 ' MainForm.TBLabel.Caption = ""
 TextboxForm.TextboxLabel = ""
  mTb (True)
End Sub

Sub Go_Inline(n As Long)
Dim tBox As Shape
Dim BoxRange As Range
With Selection


 ' If .InlineShapes.Count > 0 Then GoTo derr
  TextboxForm.TextboxLabel = ""
  If .Range.ShapeRange.Count > 0 Then .Range.ShapeRange(1).Select
  If .ShapeRange.Count < 1 Then GoTo derr
  Set tBox = .ShapeRange(1)
  If tBox.Type <> msoTextBox Then GoTo derr
  tBox.TextFrame.TextRange.Select
 
  Selection.Copy
  
  Set BoxRange = tBox.Anchor
  BoxRange.End = BoxRange.Start
  tBox.Delete
  BoxRange.Select
  Selection.PasteAndFormat (wdFormatOriginalFormatting)
'  tBox.Delete
  Exit Sub
End With

derr:
   TextboxForm.TextboxLabel = "Textbox not selected"
End Sub

Sub Go_CancelBox(n As Long)
  TextboxForm.TextboxLabel = ""
  TextboxForm.Hide
  With MainForm
 '  On Error Resume Next ' will raise error if mainform is closed first
 '  .AllTextAction.Value = True ' needed to return to text changes
  End With
  On Error GoTo 0
End Sub

Private Sub mTb(isNext As Boolean)
'Dim oTxtRange As TextRange
Dim oTxtFrame As TextFrame
Dim rSW As Boolean
Dim rCount As Long
  With Selection
    If .ShapeRange.Count > 0 Then
      .ShapeRange(1).Anchor.Select
      Selection.Start = Selection.End + 1
    End If
  End With
  With Selection ' because selection may have changed
    If .InlineShapes.Count = 0 Then
      If .ShapeRange.Count > 0 Then
        If Not isNext Then Exit Sub ' first time use existing
      End If
    End If
    Application.Browser.Target = wdBrowseGraphic
    rCount = 0
    
    Do While rCount < ActiveDocument.Shapes.Count
      rSW = True
      Application.Browser.Next
      .MoveEnd unit:=wdCharacter
      If .Range.ShapeRange.Count > 0 Then .Range.ShapeRange(1).Select
     ' Exit Sub
      If .InlineShapes.Count > 0 Then GoTo nextDo
      If .ShapeRange.Count > 0 Then
        Set oTxtFrame = .ShapeRange(1).TextFrame
        If oTxtFrame Is Nothing Then
         ' MsgBox "no text"
         rSW = False
        Else
          If Not oTxtFrame.HasText Then
            rSW = False
           ' MsgBox "no hastext"
          End If
         ' MsgBox .ShapeRange.TextFrame.TextRange.Text
        End If
        If rSW Then Exit Sub
      Else
        Exit Sub
      End If
nextDo:
      rCount = rCount + 1
    Loop
  End With
  If Selection.ShapeRange.Count = 0 Then
    MsgBox "No textbox found"
    Exit Sub
  End If
  Set oTxtFrame = Selection.ShapeRange(1).TextFrame
  If oTxtFrame Is Nothing Then
    Selection.End = Selection.Start
    MsgBox "No textbox found"
  Else
    If Not oTxtFrame.HasText Then
      Selection.End = Selection.Start
      MsgBox "No textbox found"
    End If
  End If
  
End Sub

Sub TextToBox(n As Long) ' A better way.
Dim aRange As Range
Dim aTxt As String
Dim aShape As Shape
Dim tf As TextFrame
Dim aTable As Table
Dim wdth As Single
Dim hgt As Single
  
  aTxt = Selection.Range.Text
  ' don't include last para char
  If Right(aTxt, 1) = Chr(13) And Len(aTxt) > 1 Then
    Selection.End = Selection.End - 1
  End If
  
  ' is selection start or finish is inside a table then select the whole table
  Set aRange = Selection.Range
  Selection.Collapse
  If Selection.Information(wdWithInTable) = True Then
    Selection.Range.Tables(1).Select
    aRange.Start = Selection.Start
  End If
  aRange.Select
  Selection.Collapse direction:=wdCollapseEnd
  If Selection.Information(wdWithInTable) = True Then
    Selection.Range.Tables(1).Select
    aRange.End = Selection.End
  End If
  aRange.Select
  
  wdth = 140
  hgt = 30
  'If selection contains a table or shape set the textbox size. First table or shape only.
  If aRange.Tables.Count > 0 Then
    Set aTable = aRange.Tables(1)
    wdth = TableWidth(aTable)
  End If
  
  If aRange.ShapeRange.Count > 0 Then
    Set aShape = aRange.ShapeRange(1)
    If wdth < aShape.Width Then wdth = aShape.Width
    If hgt < aShape.Height Then hgt = aShape.Height
  End If
  
  If aRange.InlineShapes.Count > 0 Then
    With aRange.InlineShapes(1)
      If wdth < .Width Then wdth = .Width
      If hgt < .Height Then hgt = .Height
    End With
  End If
  
  If Selection.Range.Start = Selection.Range.End Then
    MsgBox "Nothing selected"
    Exit Sub
  End If
  Selection.Cut
  
  ActiveDocument.Shapes.AddTextbox Orientation:=msoTextOrientationHorizontal, _
    Left:=Selection.Information(wdHorizontalPositionRelativeToPage) + 10, _
    Top:=Selection.Information(wdVerticalPositionRelativeToPage), _
    Width:=wdth, Height:=hgt
    
  Selection.End = Selection.End + 1

    If Selection.Range.ShapeRange.Count < 1 Then
      MsgBox "Cannot fill textbox. Might be trying to nest textboxes"
      Selection.PasteAndFormat (wdFormatOriginalFormatting)
    Else
      Set aShape = Selection.Range.ShapeRange(1)
      aShape.WrapFormat.Type = wdWrapTopBottom
      If TextboxForm.NoBorderCheckbox.Value = True Then aShape.Line.Visible = msoFalse
      Set tf = aShape.TextFrame
      tf.AutoSize = True
      tf.TextRange.Select
      Selection.PasteAndFormat (wdFormatOriginalFormatting)
    End If
    
End Sub

Function TableWidth(Tbl As Table) As Single
Dim tRng As Range, sngWdth As Single
  With Tbl
    Set tRng = .Cell(1, 1).Range
    sngWdth = -tRng.Information(wdHorizontalPositionRelativeToPage)
    Do While tRng.Cells(1).RowIndex = 1
      tRng.Move unit:=wdCell, Count:=1
    Loop
    tRng.MoveEnd wdCharacter, -1
    sngWdth = sngWdth + tRng.Information(wdHorizontalPositionRelativeToPage)
    TableWidth = sngWdth
  End With
End Function

Sub TextToBoxOLD(n As Long)
Dim aRange As Range
Dim bRange As Range
Dim cRange As Range
Dim aTxt As String
Dim aShape As Shape
Dim tf As TextFrame
Dim fSize As Single
Dim fStyle As Style
  TextboxForm.TextboxLabel = ""
  Set aRange = Selection.Range
  aTxt = BuildBoxtext(aRange)
  fSize = Selection.Range.Paragraphs(1).Style.Font.Size
  Set fStyle = Selection.Paragraphs(1).Style
  'aRange.Delete
 ' On Error GoTo noBox
  Selection.End = Selection.Start
  Set bRange = Selection.Paragraphs(1).Range
  Set cRange = aRange
 ' cRange.End = cRange.Start
 ' cRange.Select
  ActiveDocument.Shapes.AddTextbox Orientation:=msoTextOrientationHorizontal, _
    Left:=Selection.Information(wdHorizontalPositionRelativeToPage) + 10, _
    Top:=Selection.Information(wdVerticalPositionRelativeToPage), _
    Width:=140, Height:=30
 

   ' Selection.MoveStart unit:=wdCharacter, Count:=-1
   bRange.Select
    If Selection.Range.ShapeRange.Count > 0 Then
      Set aShape = Selection.Range.ShapeRange(1)
      aShape.WrapFormat.Type = wdWrapTopBottom ' = wdWrapSquare
      aShape.Select
      Set tf = aShape.TextFrame
      tf.AutoSize = True
      tf.TextRange.Text = aTxt
      tf.TextRange.Style = fStyle
      
      aShape.Select
      DoEvents
      If aRange.ShapeRange.Count > 0 Then aRange.MoveStart unit:=wdCharacter, Count:=1
      If aRange.ShapeRange.Count >= 0 Then
        aRange.Select
        aRange.Text = ""
      Else
        MsgBox "Selection contains a shape. Text will not be deleted"
      End If
      aShape.Select
      
      On Error GoTo 0
      Exit Sub
    End If
noBox:
    On Error GoTo 0
    aRange.Select
    Selection.InsertAfter aTxt
End Sub

Function BuildBoxtext(aRange As Range) As String
Dim strng As String
  strng = aRange.Text
  If Right(strng, 1) = Chr(13) Then strng = Left(strng, Len(strng) - 1)
  If Left(strng, 1) = Chr(13) And Len(strng) > 1 Then strng = Mid(strng, 2)
  BuildBoxtext = strng
End Function

Sub Import_Text(n As Long)
  With ImportForm
    .Left = MainForm.Left + 6
    .Top = MainForm.Top + 200
    .Show
  End With
End Sub

Function GetFileSelection() As String
    Dim dlgOpen As FileDialog
    Set dlgOpen = Application.FileDialog( _
        FileDialogType:=msoFileDialogFilePicker)
    With dlgOpen
        .AllowMultiSelect = False
        .InitialFileName = ActiveDocument.Path
        .Show   ' could use if .show=-1
        If .SelectedItems.Count > 0 Then
          GetFileSelection = .SelectedItems(1)
        Else
          GetFileSelection = ""
        End If
   End With
   Set dlgOpen = Nothing
End Function

Sub browseImportFiles(n As Long)
Dim TxtFileName As String
  TxtFileName = GetFileSelection
  ImportForm.FileTextbox.Value = TxtFileName
End Sub
Sub cancelImport(n As Long)
  ImportForm.Hide
End Sub
Sub goImportfile(n As Long)
Dim txtImport As String
Dim TxtFileName As String
Dim thisDocumentName As String
Dim aRange As Range
  TxtFileName = ImportForm.FileTextbox.Value
  If TxtFileName = "" Then Exit Sub
  thisDocumentName = ActiveDocument.Name
  On Error GoTo Ferr
  Application.Documents.Open (TxtFileName)
  GoTo Ferr2
Ferr:
  On Error GoTo 0
  
  If Err.Number = 55 Or Err.Number = 0 Then
    Application.Documents(TxtFileName).Activate
  Else
MsgBox "ERR=" & Err.Number & "   file=" & TxtFileName
'     MsgBox "Error opening file"
     Exit Sub
  End If
Ferr2:
  On Error GoTo 0
  ImportForm.Hide
  If ImportForm.TextOnlyButton.Value Then ' text only
    txtImport = ActiveDocument.Range.Text
    Application.Documents(TxtFileName).Close SaveChanges:=wdDoNotSaveChanges
    Selection.Collapse direction:=wdCollapseEnd
    Selection.TypeText txtImport & vbCrLf
  Else ' file content including formatting
    Set aRange = ActiveDocument.Range
    aRange.MoveEnd unit:=wdCharacter, Count:=-1
   ' aRange.Select
    aRange.Copy
    Application.Documents(thisDocumentName).Activate
    Selection.Collapse direction:=wdCollapseEnd
    'aRange.Paste
    Selection.PasteAndFormat (wdFormatOriginalFormatting)
    Selection.TypeText vbCrLf
    Application.Documents(TxtFileName).Close SaveChanges:=wdDoNotSaveChanges
  End If
End Sub


Sub RemovePair(n As Long)
Dim k As Long
  With MainForm.IndexNames
    If .ListIndex > -1 Then
      k = .ListIndex
      patternSW(PatternItem, k) = Not patternSW(PatternItem, k)
 '     .List(.ListIndex, 0) = "****"
      Load_Patterns (PatternItem)
      .ListIndex = k
    End If
  End With
End Sub

Sub autoQuotes(n As Long)
   Options.AutoFormatAsYouTypeReplaceQuotes = MainForm.AutoQuotesCheckbox.Value
End Sub


Attribute VB_Name = "CombineHelpMoodule"
Option Explicit
Sub CombineHelp(n As Long)
Dim s As String
  s = "All the files to be combined must be in the same folder and have generic names such as 'Book 3 Chapter 01', 'Book 3 Chapter 02' etc. The names are case sensitive so that 'Book 3 chapter 01' is not the same as 'Book 3 Chapter 01'. Make sure that there are no unwanted files in the directory that have names starting with the generic name."
  

  s = s & vbCrLf & vbCrLf & "You need to have created a master document with the generic name which in this case is 'Book 3' and save to the same folder as the chapter files. The master document can be blank or have frontispiece text" & vbCrLf
  s = s & "If 'Use current file' is not ticked then enter the master file name otherwise the current file will be the master."
  
  s = s & vbCrLf & vbCrLf & "After combining Thoroughly check that the chapter numbers agree with the file numbers. If they do not then the file names are in error and are not sorting properly. Correct the names, delete the text in the master document and run again. Creating a temporary TOC will help to check chapter sequence."
  s = s & vbCrLf & vbCrLf & "If everything is OK then if necessary remove the file names from the chapter headings."
  s = s & vbCrLf & vbCrLf & "Headers and footers are not copied."
  HelpForm.Helptxt0.Caption = s
  
  HelpForm.HelpTxt4.Caption = ""
  HelpForm.HelpTxt5.Caption = ""

  HelpForm.Show
  
  End Sub
Attribute VB_Name = "CombineModule"
Option Explicit
Dim goSW As Boolean

Sub GO_Combine(n As Long)
  goSW = False
  CombiningFilesForm.CurrentFileCheckbox.Value = True
  CombiningFilesForm.FileNameCheckbox.Value = ActiveDocument.Name
  CombiningFilesForm.Show
  If goSW Then CombineFilesProcess
End Sub

Private Sub CombineFilesProcess()
Dim aRange As Range
Dim fl As String
Dim flNames() As String
Dim flCount As Long
Dim j As Long
Dim k As Long
Dim s As String
Dim mydir As String
Dim aString As String
Dim projName As String
Dim InclFirstpageSW As Boolean
Dim nextDoc As Document
  ActiveWindow.View.ShowFieldCodes = False
    ' ----- set generic name to current file name -----
  mydir = ActiveDocument.Path
  If CombiningFilesForm.CurrentFileCheckbox Then
    projName = ActiveDocument.Name
    CombiningFilesForm.FileNameCheckbox.Value = ActiveDocument.Name
  Else
    projName = Trim(CombiningFilesForm.FileNameCheckbox.Value)
    If projName = "" Then
      MsgBox "No generic filename"
      Exit Sub
    End If
  End If
  'InclFirstpageSW = CombiningFilesForm.CreateFirstpageCheckbox.Value
    
  ' ------ get list of files in directory ------
  j = InStr(projName, ".")
  If j = 0 Then
    projName = projName & ".docx"
    j = InStr(projName, ".")
  End If
  aString = Left(projName, j - 1) & "*" & Mid(projName, j)
  flCount = 0
  ReDim flNames(0)
  fl = Dir(mydir & "\" & aString)
  Do While fl <> ""
    If UCase(fl) <> UCase(ActiveDocument.Name) Then
      flCount = flCount + 1
      ReDim Preserve flNames(flCount)
      flNames(flCount) = fl
    End If
    fl = Dir()
  Loop
  If flCount = 0 Then
    MsgBox "No files found that match " & aString
    Exit Sub
  End If
  
  ' ----- sort file names -----
  For j = 1 To UBound(flNames) - 1
    For k = j + 1 To UBound(flNames)
      If flNames(j) > flNames(k) Then
        fl = flNames(j)
        flNames(j) = flNames(k)
        flNames(k) = fl
      End If
    Next k
  Next j
  
   If Not CombiningFilesForm.CurrentFileCheckbox Then ' open new file
     ActiveDocument.Close SaveChanges:=wdSaveChanges
     Documents.Open FileName:=mydir & "\" & projName, Visible:=True
     Selection.Paragraphs(1).Style = "Heading 1"
     Selection.TypeText "Combined document for " & projName & vbCrLf
      Selection.Paragraphs(1).Style = "Heading 1"
   End If
  
  ' ----- first document. Advance to end  -----
 
    ActiveDocument.Range.Select
    Selection.Collapse direction:=wdCollapseEnd
  
  ' ----- successive documents -----
  For j = 1 To UBound(flNames)
    fl = mydir & "\" & flNames(j)
    Documents.Open FileName:=fl, Visible:=False
    
    Set aRange = Documents(fl).Range
'    aRange.MoveEnd unit:=wdCharacter, Count:=-1
    aRange.Copy ' puts onto clipboard
    Application.Documents(projName).Activate
    Selection.Collapse direction:=wdCollapseEnd
    
    If j = 1 Then InsertPageNo
    If (j > 1) Or (j = 1 And Selection.Paragraphs.Count > 1) Then
      If CombiningFilesForm.IncludeSectionBreaks Then
        Selection.InsertBreak Type:=wdSectionBreakNextPage
        InsertPageNo
      Else
        Selection.InsertBreak Type:=wdPageBreak
      End If
    End If
    
    If Not CombiningFilesForm.NoneOption Then
      s = Trim(Str(j))
      With CombiningFilesForm
        If .Chapter1Option Then s = "Chapter " & s
        If .Part1Option Then s = "Part " & s
        If .IncludeFilenameCheckbox Then s = s & "        " & flNames(j) & vbCrLf
      End With
      Selection.Paragraphs(1).Style = "Heading 1"
      Selection.TypeText s
      Selection.TypeText vbCrLf
      Selection.Paragraphs(1).Style = "Normal"
      Selection.TypeText vbCrLf
    End If
    Selection.Paste '  AndFormat (wdFormatOriginalFormatting) ' from clipboard
    Selection.TypeText vbCrLf
    Application.Documents(flNames(j)).Close SaveChanges:=wdDoNotSaveChanges
 
  Next j

  j = ActiveDocument.TablesOfContents.Count
  If j < 1 Then
    'MsgBox "There are no tables of contents to update"
  Else
    ActiveDocument.TablesOfContents(1).Update
  End If
  ActiveDocument.Range.Select
  Selection.Collapse
  ActiveWindow.ScrollIntoView Selection.Range
End Sub

Private Sub InsertPageNo()
       With ActiveDocument.ActiveWindow.View
        .Type = wdPrintView
        .SeekView = wdSeekCurrentPageFooter
        End With
        Selection.HeaderFooter.LinkToPrevious = False
        Selection.WholeStory
        Selection.Text = ""
        Selection.InsertAfter "Page "
        Selection.Collapse wdCollapseEnd
        Selection.Fields.Add Range:=Selection.Range, Type:=wdFieldEmpty, Text:= _
           "PAGE  ", PreserveFormatting:=True
        Selection.ParagraphFormat.Alignment = wdAlignParagraphCenter
       
        ActiveDocument.StoryRanges(wdMainTextStory).Select
        Selection.Collapse wdCollapseEnd
End Sub

Sub gogo(n As Long)
  goSW = True
  CombiningFilesForm.Hide
End Sub
Attribute VB_Name = "CombiningFilesForm"
Attribute VB_Base = "0{A9B837CB-009D-4FA3-BE4B-8FBACAF89C2A}{2742B3B5-8C60-41EB-AD9E-839868F407A5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub CancelCombineButton_Click()
  CombiningFilesForm.Hide
End Sub

Private Sub CombineButton_Click()
  gogo (1)
End Sub

Private Sub CombinedHelpButton_Click()
  CombineHelp (1)
End Sub

Private Sub CurrentFileCheckbox_Click()
  With CombiningFilesForm
    If .CurrentFileCheckbox Then
      .FileNameCheckbox.Value = ActiveDocument.Name
    Else
      .FileNameCheckbox.Value = ""
    End If
  End With
  
End Sub

Private Sub Frame1_Click()

End Sub
Attribute VB_Name = "FindAnywhere"
Option Explicit

 ' from: http://word.mvps.org/faqs/customization/ReplaceAnywhere.htm

Public Sub FindReplaceAnywhere(n As Long)
  Dim rngStory As Word.Range
  Dim pFindTxt As String
  Dim pReplaceTxt As String
  Dim lngJunk As Long
  Dim oShp As Shape
  pFindTxt = InputBox("Enter the text that you want to find." _
    , "FIND")
  If pFindTxt = "" Then
    MsgBox "Cancelled by User"
    Exit Sub
  End If
TryAgain:
  pReplaceTxt = InputBox("Enter the replacement.", "REPLACE")
  If pReplaceTxt = "" Then
    If MsgBox("Do you just want to delete the found text?", _
     vbYesNoCancel) = vbNo Then
      GoTo TryAgain
    ElseIf vbCancel Then
      MsgBox "Cancelled by User."
      Exit Sub
    End If
  End If
  'Fix the skipped blank Header/Footer problem
  lngJunk = ActiveDocument.Sections(1).Headers(1).Range.StoryType
  'Iterate through all story types in the current document
  For Each rngStory In ActiveDocument.StoryRanges
    'Iterate through all linked stories
    Do
      SearchAndReplaceInStory rngStory, pFindTxt, pReplaceTxt
      On Error Resume Next
      Select Case rngStory.StoryType
      Case 6, 7, 8, 9, 10, 11
        If rngStory.ShapeRange.Count > 0 Then
          For Each oShp In rngStory.ShapeRange
            If oShp.TextFrame.HasText Then
              SearchAndReplaceInStory oShp.TextFrame.TextRange, _
                  pFindTxt, pReplaceTxt
            End If
          Next
        End If
      Case Else
        'Do Nothing
      End Select
      On Error GoTo 0
      'Get next linked story (if any)
      Set rngStory = rngStory.NextStoryRange
    Loop Until rngStory Is Nothing
  Next
End Sub
Public Sub SearchAndReplaceInStory(ByVal rngStory As Word.Range, _
    ByVal strSearch As String, ByVal strReplace As String)
  With rngStory.Find
    .ClearFormatting
    .Replacement.ClearFormatting
    .Text = strSearch
    .Replacement.Text = strReplace
    .Wrap = wdFindContinue
    .Execute Replace:=wdReplaceAll
  End With
End Sub



Attribute VB_Name = "HeadersFooters"
Option Explicit

Dim StartSectNo As Long
Dim EndsectNo As Long
Dim SectnCount As Long
Dim ShowAllSw As Boolean
Dim sectn As Section

Sub Headfoot_Execute(n As Integer) ' from Go or selecting headers & Footers
Dim hPoints As Single
Dim vPoints As Single
Dim viewHold As Long
  If ActiveWindow.View.SplitSpecial = wdPaneNone Then
    viewHold = ActiveWindow.ActivePane.View.Type
    ActiveWindow.ActivePane.View.Type = wdPrintView
  Else
    viewHold = ActiveWindow.View.Type
    ActiveWindow.View.Type = wdPrintView
  End If
  Call GiveScreenPoints(hPoints, vPoints)
  With HFform
    .StartUpPosition = 0
    .Left = hPoints - .Width - 15
    .Top = 40
    StartSectNo = 1
    HeadFootExecute (StartSectNo)
    .ShowAll.Caption = "Show" & vbCr & "All"
    .Show
  End With
End Sub
Sub move_updown(yesup As Boolean)
  If yesup Then
    If StartSectNo > 1 Then
      StartSectNo = StartSectNo - 1
      HeadFootExecute (StartSectNo)
    Else
      StartSectNo = 1
    End If
  Else
    If EndsectNo < SectnCount Then
      StartSectNo = StartSectNo + 1
      HeadFootExecute (StartSectNo)
    End If
  End If
End Sub

Sub ShowAll_Toggle(n As Long)
  ShowAllSw = Not ShowAllSw
  If ShowAllSw = True Then
    HFform.ShowAll.Caption = "Short" & vbCr & "Form"
  Else
    HFform.ShowAll.Caption = "Show" & vbCr & "All"
  End If
  HeadFootExecute (StartSectNo)
End Sub
Sub HeadFootExecute(startSect As Long)
Dim sectn As Section
Dim sectnC As Long
Dim s As String
Dim ss As String
Dim lcount As Integer
Dim LinesPersect As Integer
Dim SaveStatus As Boolean
Dim rr As Range
  SectnCount = ActiveDocument.Sections.Count
  If startSect > SectnCount Then
    StartSectNo = SectnCount
  End If
  
  sectnC = 0
  lcount = 0
  SaveStatus = ThisDocument.Saved
 
  HFform.TotalSectionsLabel.Caption = "Total Number of Sections " & Str(SectnCount)

  If ShowAllSw Then
    With HFform
      .ShortformListBox.Visible = False
      .UPButton.Visible = True
      .DownButton.Visible = True
    End With
    ss = BuildEntry(StartSectNo, 1)
  Else
    With HFform
      .ShortformListBox.Visible = True
      .UPButton.Visible = False
      .DownButton.Visible = False
    End With
    BuildShortForm
  End If
  If StartSectNo < SectnCount Then
    ss = BuildEntry(StartSectNo + 1, 2)
  Else
     HFform.SectBFTPrimary.Caption = ""
     HFform.SectBHDPrimary.Caption = ""
     HFform.SectBTop.Caption = ""
  End If
  Exit Sub
  ' *******************************************************
End Sub
Private Sub BuildShortForm()
Dim sno As Long
Dim sn As Section
Dim s As String
Dim ss As String
Dim i As Long
  HFform.ShortformListBox.Clear
  sno = 0
  For Each sn In ActiveDocument.Sections
    sno = sno + 1
    s = Section_Page_String(sn)
    ss = """" & FirstLineOfSect(sno, 44) & """"
    HFform.ShortformListBox.AddItem "SECTION " & Str(sno) & "  " & s & "  " & ss
    If sn.Headers(wdHeaderFooterPrimary).LinkToPrevious = True Then
      s = ""
    Else
      s = "- new -"
    End If
    If sn.Footers(wdHeaderFooterPrimary).LinkToPrevious = True Then
      ss = ""
    Else
      ss = "- new -"
    End If
    s = s & "   Footer: " & ss
    If sn.PageSetup.OddAndEvenPagesHeaderFooter Then s = s & "  Odd & Even pages"
     
    HFform.ShortformListBox.AddItem "Header: " & s
       
  Next sn
  i = Selection.Information(wdActiveEndSectionNumber)
  If i > 0 And i <= ActiveDocument.Sections.Count And _
     i * 2 <= HFform.ShortformListBox.ListCount Then
    HFform.ShortformListBox.ListIndex = (i - 1) * 2
  End If
  
End Sub
Sub goto_Section(n As Long) ' entered by clicking listbox
Dim i As Integer
Dim j As Integer
Dim rng As Range
  j = HFform.ShortformListBox.ListIndex + 1
  i = Int((j + 1) / 2)
  If i > 0 And i <= ActiveDocument.Sections.Count Then
    StartSectNo = i
    Set rng = ActiveDocument.Sections(i).Range
    rng.Collapse wdCollapseStart
    If j = i * 2 Then
      rng.Select ' even
      ActiveDocument.ActiveWindow.SmallScroll
    Else
      rng.Select ' odd = header
      ActiveDocument.ActiveWindow.SmallScroll up:=3
    End If
  End If
  Application.Activate ' returns focus to document

End Sub
Function Section_Page_String(sectn As Section) As String
Dim rng As Range
Dim fld As Field
  With sectn
    Set rng = .Range
    rng.Collapse wdCollapseStart
    Set fld = rng.Fields.Add(rng, wdFieldPage)
    Section_Page_String = "Page " & fld.result
    fld.Delete
  End With
End Function
Function BuildEntry(sno As Long, lNo As Integer) As String
Dim asect As Section
Dim s As String
Dim ss As String
Dim sOdd As String
       
  s = ""
  Set sectn = ActiveDocument.Sections(sno)
  If sno = 1 Then
    ActiveWindow.ActivePane.VerticalPercentScrolled = 0
  Else
    ActiveWindow.ActivePane.SmallScroll Down:=-6
  End If
  With sectn
    s = Section_Page_String(sectn)
    If .Headers(wdHeaderFooterPrimary).PageNumbers.RestartNumberingAtSection = True Then
      s = s & "  Numbering Restarted"
    Else
      s = s & "  Numbering Continued From Previous Section"
    End If
    s = "SECTION " & Str(sno) & "  " & s & vbCrLf & """" & FirstLineOfSect(sno, 64) & """"
    If lNo = 1 Then
      HFform.SectATop.Caption = s
    Else
      HFform.SectBTop.Caption = s
    End If
    
    ' ---------------- Headers -----------
    s = "HEADER "
    If .PageSetup.DifferentFirstPageHeaderFooter = True Then
      ss = StripTrailing(.Headers(wdHeaderFooterFirstPage).Range.Text)
      s = s & "Header Firstpage" & Test_PreviousLink(True, wdHeaderFooterFirstPage) & _
         "= " & ss & vbCrLf
    End If
  
    If .PageSetup.OddAndEvenPagesHeaderFooter = True Then
      sOdd = "Odd pages: " '& vbCrLf
    Else
      sOdd = "Primary page: " '& vbCrLf
    End If
    s = "Header " & sOdd & Test_PreviousLink(True, wdHeaderFooterPrimary) & "  "
    ss = StripTrailing(.Headers(wdHeaderFooterPrimary).Range.Text)
    s = s & ss & "  " ' vbCr
    If .PageSetup.OddAndEvenPagesHeaderFooter = True Then
      s = s & vbCrLf & "Evenpages: " & Test_PreviousLink(True, wdHeaderFooterEvenPages) & _
        "  " & StripTrailing(.Headers(wdHeaderFooterEvenPages).Range.Text)
    End If
    If lNo = 1 Then
      HFform.SectAHDPrimary.Caption = s
    Else
      HFform.SectBHDPrimary.Caption = s
    End If
  
  '  ----------- Footers ---------------------
    s = "FOOTER "
    If .PageSetup.DifferentFirstPageHeaderFooter = True Then
      ss = StripTrailing(.Footers(wdHeaderFooterFirstPage).Range.Text)
      s = "Footer Firstpage" & Test_PreviousLink(True, wdHeaderFooterFirstPage) & _
         "= " & ss & vbCrLf
    End If
    s = "Footer " & sOdd & Test_PreviousLink(True, wdHeaderFooterPrimary) & "  "
    ss = StripTrailing(.Headers(wdHeaderFooterPrimary).Range.Text)
    s = s & ss & "  " ' vbCr
    If .PageSetup.OddAndEvenPagesHeaderFooter = True Then
      s = s & vbCrLf & "Evenpages: " & Test_PreviousLink(True, wdHeaderFooterEvenPages) & _
        "  " & StripTrailing(.Footers(wdHeaderFooterEvenPages).Range.Text)
    End If
    If lNo = 1 Then
      HFform.SectAFTPrimary.Caption = s
    Else
      HFform.SectBFTPrimary.Caption = s
    End If
  
    BuildEntry = s & vbCr
  End With
End Function
Function Test_PreviousLink(isHeader As Boolean, LType As Long) As String
Dim sss As String
  If isHeader Then
    If sectn.Headers(LType).LinkToPrevious = True Then
        sss = "Same as previous "
      Else
        sss = " "
    End If
  Else
      If sectn.Footers(LType).LinkToPrevious = True Then
        sss = "Same as previous "
      Else
        sss = " "
    End If
  End If
  Test_PreviousLink = sss
End Function
Function StripTrailing(ByVal s As String) As String
Dim ii As Integer
Dim jj As Integer
  If s = "" Then GoTo sfin
    While Asc(Right(s, 1)) < 32
      s = Left(s, Len(s) - 1)
      If s = "" Then GoTo sfin
    Wend
sfin:
  For ii = 1 To Len(s)
    If Asc(Mid(s, ii, 1)) < 32 Then ' remove embedded non printing chars
      s = Left(s, ii - 1) & " " & Mid(s, ii + 1)
    End If
  Next ii
  If Len(s) > 64 Then
    s = Left(s, 64) & "..."
  Else
    s = Left(s, 64)
  End If
  If s = "" Then
    s = "nil"
  Else
    StripTrailing = """" & s & """"
  End If
End Function
Function FirstLineOfSect(sno As Long, L As Integer) As String ' returm first sentence in section
Dim senr As Range
Dim aaa As Range
Dim ss As String
Dim ii As Integer
Dim jj As Integer
  ii = ActiveDocument.Sections(sno).Range.Paragraphs.Count
  Set senr = ActiveDocument.Sections(sno).Range
  FirstLineOfSect = ""
  For jj = 1 To ii
    Set aaa = senr.Paragraphs(jj).Range
    ss = StripTrailing(aaa.Text)
    If Len(ss) > 1 Then
      If Len(ss) > L Then
        ss = Left(ss, L) & "..."
      Else
        ss = Left(ss, L)
      End If
      FirstLineOfSect = ss
      Exit For
    End If
  Next jj
End Function
Function Return_PageNumb(sno As Integer) As String
Dim pnStyle As Long
Dim pNo As Long
Dim s As String
Dim sectn As Section
 Set sectn = ActiveDocument.Sections(sno)
' sectn.Range.Characters(1).Select
 
 With ActiveDocument.Sections(sno)
  
   pnStyle = .Headers(1).PageNumbers.NumberStyle
   pNo = .Range.Characters(1).Information(wdActiveEndAdjustedPageNumber)
'MsgBox "  "
   Select Case pnStyle
   Case wdPageNumberStyleArabic
     s = Str(pNo)
   Case wdPageNumberStyleLowercaseRoman
     s = FormatRoman(pNo, 0)
   Case wdPageNumberStyleUppercaseRoman
     s = FormatRoman(pNo, 1)
   Case wdPageNumberStyleLowercaseLetter
     s = FormatAlpha(pNo, 0)
   Case wdPageNumberStyleUppercaseLetter
     s = FormatAlpha(pNo, 1)
   Case Else
     s = "??"
   End Select
   
   Return_PageNumb = s
 
 End With
End Function

' Formats a number as a roman numeral.
' Author: Christian d'Heureuse (www.source-code.biz)
Public Function FormatRoman(ByVal n As Integer, ByVal ncase As Integer) As String
   If n = 0 Then FormatRoman = "0": Exit Function
      ' There is no roman symbol for 0, but we don't want to return an empty string.
   'Const r = "IVXLCDM"              ' roman symbols
   Dim r As String
   Dim i As Integer: i = Abs(n)
   Dim s As String, p As Integer
   If ncase = 1 Then ' upper case
     r = "IVXLCDM"
   Else
     r = "ivxlcdm"
   End If
   For p = 1 To 5 Step 2
      Dim d As Integer: d = i Mod 10: i = i \ 10
      Select Case d                 ' format a decimal digit
         Case 0 To 3: s = String(d, Mid(r, p, 1)) & s
         Case 4:      s = Mid(r, p, 2) & s
         Case 5 To 8: s = Mid(r, p + 1, 1) & String(d - 5, Mid(r, p, 1)) & s
         Case 9:      s = Mid(r, p, 1) & Mid(r, p + 2, 1) & s
         End Select
      Next
   s = String(i, "M") & s           ' format thousands
   If n < 0 Then s = "-" & s        ' insert sign if negative (non-standard)
   FormatRoman = s
   End Function
' format a number as alphabetic characters
Function FormatAlpha(ByVal n As Integer, ByVal ncase As Integer) As String
Dim s As String
Dim k As Integer
Dim ktype As Integer
  If ncase = 1 Then ' capitals
    ktype = 65
  Else              ' lower case
    ktype = 97
  End If
  If n < 1 Then
    FormatAlpha = "?"
    Exit Function
  End If
  s = ""
  k = ((n - 1) Mod 26)
  While n > 0
    s = Trim(Chr(k + ktype)) & s
    n = (n - 1) \ 26
    k = ((n - 1) Mod 26)
  Wend
  FormatAlpha = s
End Function



Attribute VB_Name = "HelpForm"
Attribute VB_Base = "0{B7403EA5-FDD4-4022-B62C-B151B0F028DF}{91870AF1-E45A-4198-A740-777BA16FB137}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Private Sub HelpCancelButton_Click()
  HelpForm.Hide
End Sub

Private Sub URLlabel_Click()
  ActiveDocument.FollowHyperlink HelpForm.URLlabel.Caption
End Sub
Attribute VB_Name = "HelpModule"
Option Explicit
Sub HelpText(n As Long)
Dim s As String
   HelpForm.Caption = "Text Editing - Help"
  With HelpForm.Helptxt0
  
    s = "FIND/REPLACE STRINGS" & vbCrLf
    s = s & "Find/Replace strings are string pairs that contain Find and Replace commands. " & _
     "Each command is enclosed in quotes and separated by commas. Each item in the find string " & _
     "must match an item in the replace string. Quotes around strings can be straight or smart quotes so that strings can be copied from any source." & vbCrLf
    s = s & _
     "Special characters may be specified by the caret character followed by the ascii code eg ^148." & vbCrLf & _
     "String pairs can be extracted from any formatted document or can be entered ad-hoc." & vbCrLf & vbCrLf & _
     "The document FindReplaceData.docx contains useful samples as well as a primer on how to use wildcards."

    s = s & vbCrLf & vbCrLf & "LOADING STRINGS FROM FindReplaceData DOCUMENT" & vbCrLf
    s = s & "1.  Select a Find/Replace strings option. If existing is selected it will be replaced." & vbCrLf & _
    "2.  Click the OpenFindReplaceData.docx button. This will open the document containing example strings." & vbCrLf & _
    "3.  Click on the item in the Contents (or CTRL/click if set). The entry will jump to the data item in the document" & vbCrLf & _
    "4.  Make sure that the cursor is in the description paragraph and click the From open document button." & vbCrLf & _
    "5.  Either close the FindReplaceData document or minimise it"

    s = s & vbCrLf & vbCrLf & "MANUAL ENTRY OF STRING PAIRS OR EDIT EXISTING STRINGS" & vbCrLf
    s = s & "1. Select a Find/Replace strings option." & vbCrLf & _
      "2.  In the pop up form enter or edit the From and To strings of data. Enter a description." & vbCrLf & _
      "3.  Click OK."
    .Caption = s

    s = s & vbCrLf & vbCrLf & "EXECUTING" & vbCrLf
    s = s & "Single Items: select a pair from the Find Change to pane then click GO selected item" & vbCrLf & _
      "All items:       click the GO all items button. Each find item will be processed in turn" & vbCrLf & _
      "In some cases the items should be run sequentially and not individually. Most of them require that " & _
      "the wildcards option be selected. Wildcards and Case sensitive are mutually exclusive."
    .Caption = s
  End With
  
  With HelpForm.HelpTxt4
    s = "OPTIONS" & vbCrLf
    s = s & "Prompt all changes:     will prompt whenever an item is found." & vbCrLf & _
        "Don't prompt any:       will process all find and replace without any prompts. Be careful using this." & vbCrLf & _
        "Prompt only at item:    there will be a prompt only at first string found for each item." & vbCrLf & _
        "HIGHLIGHT only:         found text is highlighted and not changed. Highlight colour set in Word is used." & vbCrLf & _
        "Include textboxes:      will search text in textboxes as well as the rest of the document." & vbCrLf & _
        "Wildcards:                   must be selected if wildcards are used." & vbCrLf & _
        "Case sensitive:            Find will be case sensitive. Mutually exclusive to Wildcards."
    .Caption = s
  End With
  With HelpForm.HelpTxt5
    s = "IMPORT TEXT" & vbCrLf & _
      "Imports all the text in another document. Option to import bare text only or include formatting."
    s = s & vbCrLf & vbCrLf & "TEXTBOX CONVERT" & vbCrLf & _
      "Convert to in-line text:    Converts text, tables and images in textbox to inline text & removes textbox." & vbCrLf & _
      "Convert text to textbox: Selection which may contain text, tables and images is put inside newly created textbox. The textbox is sized to fit tables or Shapes if present and can be with or without borders."
    s = s & vbCrLf & vbCrLf & _
      "SPELL CHECKING" & vbCrLf & _
      "In order to display spelling errors (with a wiggly underline) 'Check spelling as you type' must be on and 'Hide spelling errors' must be off."
    s = s & " Also, spell checking can be suppressed in blocks of text or by style. If there are more than about 1400 spelling errors then the display of errors is inhibited by Word." & vbCrLf & _
      "'Check spelling as you type' is a setting in the user's Word installation and applies to all documents that the user opens. Other settings are specific to a document and are stored with individual documents."
    
    .Caption = s
  End With
  
  HelpForm.Show
End Sub





Attribute VB_Name = "ImportForm"
Attribute VB_Base = "0{0C4C66AE-F67E-4159-A973-00A65B786DD1}{FF30E32D-D216-48A1-A6A1-F8F2BD87A86B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub BrowseButton_Click()
  browseImportFiles (1)
End Sub

Private Sub CancelImportButton_Click()
  cancelImport (1)
End Sub

Private Sub Importbutton_Click()
  goImportfile (1)
End Sub
Attribute VB_Name = "MainForm"
Attribute VB_Base = "0{ED5A2F60-D544-43DC-BC77-8CF23E05CF97}{948365F4-F796-4134-ACDF-0C5FC6E95545}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub AgainButton_Click()
  If MainForm.UserDefined.Value Then PatterNameSet (12)
End Sub

'Private Sub AllTextAction_Click()
'  Change_Master_Actions (1)
'End Sub

Private Sub AttachCheckbox_Click()
  If AttachCheckbox.Value = True Then
    MainForm.Level1Txt.Enabled = True
  Else
    MainForm.Level1Txt.Enabled = False
  End If
End Sub


'Private Sub CapitaliseAction_Click()
' Change_Master_Actions (4)
'End Sub


'Private Sub ConvertTextButton_Click()
' Change_Master_Actions (2)
'End Sub

'Private Sub HeadFootAction_Click()
'  Change_Master_Actions (3)
'End Sub

Private Sub AutoQuotesCheckbox_Click()
  autoQuotes (1)
End Sub

Private Sub CommandButton1_Click()
  GO_Combine (1)
End Sub

Private Sub DocTopButtom_Click()
 gotoDocTop (1)
End Sub


Private Sub HelpButton_Click()
  HelpText (1)
End Sub


Private Sub Importbutton_Click()
 Import_Text (1)
End Sub

Private Sub OutlineNumb1_Click()
  Set_Bullets (3)
End Sub
Private Sub Outlinenumb2_Click()
  Set_Bullets (4)
End Sub

Private Sub OutlineNumb3_Click()
  Set_Bullets (5)
End Sub

Private Sub OutlineNumb4_Click()
  Set_Bullets (6)
End Sub

Private Sub Remove_Click()
  set_RemoveOrAdd (0)
End Sub
Private Sub AddButton_click()
  set_RemoveOrAdd (1)
End Sub

Private Sub ConvertToTextButton_Click()
    set_RemoveOrAdd (2)
End Sub

Private Sub Getwingdings_Click()
 ' select_wingding (1)
 MsgBox "tried to execute select_wingding"
End Sub

Private Sub Getwingdingbutton_Click()
  setup_wingdings (1)
End Sub

Private Sub Btype1_Click()
  set_btype (1)
End Sub

Private Sub Btype2_Click()
  set_btype (2)
End Sub

Private Sub Btype3_Click()
  set_btype (3)
End Sub

Private Sub Btype4_Click()
  set_btype (4)
End Sub

Private Sub Btype5_Click()
  set_btype (5)
End Sub

Private Sub Level1Button_Click()
  MainForm.Level1Txt.Caption = get_new_style(Level1Txt.Caption)
End Sub

Private Sub SelectBullets_Click()
  Set_Bullets (1)
End Sub

Private Sub SelectNumbering_Click()
  Set_Bullets (2)
End Sub

Private Sub ShowlistsButton_Click()
  Show_Lists (1)
End Sub

Private Sub LoadCountsButton_Click()
  GetCounts (1)
End Sub

Private Sub ManualDataButton_Click()
  getStrings (3)
End Sub

Private Sub OpenFindFileButton_Click()
  getStrings (1)
End Sub

Private Sub FromOpenDocButton_Click()
  getStrings (2)
End Sub

Private Sub RemovePairButton_Click()
  RemovePair (1)
End Sub

Private Sub SentenceCaseButton_Click()
 change_Case (2)
End Sub

Private Sub UpperCaseButton_Click()
 change_Case (3)
End Sub
Private Sub LowerCaseButton_Click()
 change_Case (4)
End Sub

Private Sub TitleWordButton_Click()
  change_Case (5)
End Sub

Private Sub SpellerButton_Click()
  Application.Run macroname:="GO_SPELLER"
End Sub

Private Sub Strings0Option_Click()
  Load_Patterns (0)
End Sub
Private Sub Strings1Option_Click()
  Load_Patterns (1)
End Sub
Private Sub Strings2Option_Click()
  Load_Patterns (2)
End Sub
Private Sub Strings3Option_Click()
  Load_Patterns (3)
End Sub
Private Sub Strings4Option_Click()
  Load_Patterns (4)
End Sub

Private Sub TextboxButton_Click()
  LoadTextboxForm (1)
End Sub

Private Sub Userform_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then Cancel_Edit (1)
End Sub
Private Sub EditCancel_Click()
  Cancel_Edit (1)
End Sub

Private Sub GoEdit_Click()
  Go_Edit (False)
End Sub

Private Sub GoSingle_Click()
  Go_Edit (True)
End Sub

Private Sub RemoveSpaces_Click()
 PatterNameSet (0)
End Sub
Private Sub CarriageReturns_Click()
 PatterNameSet (1)
End Sub
Private Sub HardReturns_Click()
 PatterNameSet (2)
End Sub
Private Sub DoubleQuotes_Click()
 PatterNameSet (3)
End Sub
Private Sub PunctuationQuotes_Click()
 PatterNameSet (4)
End Sub
Private Sub EllipseNoSpace_Click()
 PatterNameSet (5)
End Sub
Private Sub MinorWords_Click()
 PatterNameSet (6)
End Sub
Private Sub Numberens_Click()
 PatterNameSet (7)
End Sub

Private Sub Ellipses_Click()
 PatterNameSet (9)
End Sub
Private Sub ChangeWords_Click()
 PatterNameSet (10)
End Sub
Private Sub UserDefined_Click()
  PatterNameSet (12)
End Sub

Private Sub TextBoxes_Click()
  PatterNameSet (13)
End Sub




Attribute VB_Name = "OkBox"
Attribute VB_Base = "0{47C98DC1-4C5C-41C3-8CEC-268D6F157C80}{2C1D2F78-5567-4301-8F5F-0E40B7B16C7C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub OkBoxOk_Click()
  OkBox.Hide
End Sub
Attribute VB_Name = "PromptItem"
Attribute VB_Base = "0{70881592-A13B-4A0B-AA98-6805C29AF375}{A9A95C04-3A1B-4627-BAA4-6F82EFB7A7A5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Private Sub PitemCancel_Click()
  Set_ItemResponse (2)
End Sub

Private Sub PitemNo_Click()
  Set_ItemResponse (1)
End Sub

Private Sub PitemYes_Click()
  Set_ItemResponse (0)
End Sub
Private Sub Userform_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then Set_ItemResponse (2)
End Sub
Attribute VB_Name = "PromptReplaceForm"
Attribute VB_Base = "0{EC108F5B-B988-4378-8EBB-B04027BF2655}{2215EC32-383D-46FA-B0F5-B874C3FFBAEB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub PromptCancel_Click()
  Set_PromptResponse (4)
End Sub

Private Sub PromptDont_Click()
  Set_PromptResponse (3)
End Sub

Private Sub PromptExit_Click()
  Set_PromptResponse (2)
End Sub

Private Sub PromptNo_Click()
  Set_PromptResponse (1)
End Sub

Private Sub PromptYes_Click()
  Set_PromptResponse (0)
End Sub
Private Sub Userform_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then Set_PromptResponse (4)
End Sub
Attribute VB_Name = "SetPatterns"
Option Explicit

Dim Qt As String
Dim uft(200) As String, rft(200) As String ' store user defined items
Dim nU As Integer ' count of user defined items
Dim UwholeWord As Boolean, UmatchCase As Boolean
Dim fromString As String
Dim toString As String
Dim jStr As Long

'Public Sub Get_Pattern(ByVal PatternIndex, findText, replaceT, WholeWord, MatchCase)
'Dim i As Integer
'  For i = 0 To 200 ' maximum of 200 items
'    findText(i) = ""
'  Next i
'  WholeWord = False
'  MatchCase = False
'  Select Case PatternIndex
'   Case 0
'
'   Case 13
'
'  End Select
  'Qt = Chr(34) 'double quotes
  'For i = 0 To findlength
  '  findText(i) = Qt & findText(i) & Qt
  '  replaceT(i) = Qt & replaceT(i) & Qt
  'Next i
'End Sub

Sub UserSetup(findText, replaceT, WholeWord, MatchCase)
Dim i As Integer
Dim stF As String, stRx As String
  stF = ""
  stRx = ""
  nU = 0
  Do While findText(nU) <> "" And nU < 200
    nU = nU + 1
  Loop
  
  If findText(0) = "" Then
   ' findText(0) = ""
    stF = ""
    stRx = ""
    UwholeWord = False
    UmatchCase = False
  Else
    
    On Error Resume Next
    For i = 0 To nU - 1
      findText(i) = Mid(uft(i), 2, Len(uft(i)) - 1)
      stF = stF & "," & uft(i)
      replaceT(i) = Mid(rft(i), 2, Len(rft(i)) - 1)
      stRx = stRx & "," & rft(i)
    Next i
    On Error GoTo 0
    stF = Mid(stF, 2) ' remove leading comma
    If Left(stF, 1) = "," Then stF = Mid(stF, 2)
    stRx = Mid(stRx, 2)
    If Left(stRx, 1) = "," Then stRx = Mid(stRx, 2)
    WholeWord = UwholeWord
    MatchCase = UmatchCase
    findText(nU) = ""
  End If
  With UserSet
    .UserFrom.Value = stF
    .UserTo.Value = stRx
    .CaseSensitive.Value = MatchCase
  End With
End Sub

Sub getStrings(n As Long) ' 1=open FindReplaceData file, 2=from open file, 3=manual
  With UserSet
    Select Case n
      Case 1
        openDataFile
        .UserFrom.Value = ""
        .UserTo.Value = ""
        ' also blank out description
      Case 2
        .UserFrom.Value = ""
        .UserTo.Value = ""
        getStringsFromDoc (1)
      Case 3
        .UserFrom.Value = Fs(PatternItem)
        .UserTo.Value = Ts(PatternItem)
        .UserDescr.Value = PDesc(PatternItem)
        getStringsManual
    End Select
  End With
End Sub
Private Sub getStringsManual()
  With UserSet
      '.CaseSensitive.Value = False
      .StartUpPosition = 0
      .Left = hPoints - 60 - UserSet.Width
      .Top = (vPoints - UserSet.Height) / 2
      .UserHints = "Find/replace pairs can be entered directly above or can be" & vbCrLf & _
          "copied from any open document. Text must be in quotes and must be matched. " & _
          "Straight or curley quotes can be used." & vbCrLf & vbCrLf & _
          "Wildcard strings can also be entered. For example" & vbCrLf & _
          "from "",([! 0-9])"" to "", \1"" will add a space after a" & vbCrLf & _
          "comma that doesn't have a space except if the nexr char is numeric. Wildcard must be checked." & vbCrLf & _
          vbCrLf & """HIGHLIGHT""" & " in To will highlight specified text" & _
          vbCrLf & """NO HIGHLIGHT""" & " in From and "" "" in To will remove all highlighting in document. No prompt will be given" & vbCrLf & _
          vbCrLf & "Document FindReplaceData.docx contains useful pairs. "
      '.AutoformatCheckbox.Value = Options.AutoFormatReplaceQuotes
     ' .UserFrom = giveStrings(s)
     ' .UserTo = s
      .Show
    End With
End Sub
Sub getStringsFromDoc(n As Long)
Dim s1 As String
Dim s2 As String
Dim j As Long
Dim StringDescr As String
Dim aRange As Range
  Set aRange = Selection.Paragraphs(1).Range
  aRange.MoveEnd unit:=wdParagraph, Count:=3
  aRange.Select
  If aRange.Paragraphs.Count < 4 Then
    MsgBox "There must be at least 3 paragraphs document containing find/replace strings"
    Exit Sub
  End If
  s1 = aRange.Paragraphs(3).Range.Text
  s2 = aRange.Paragraphs(4).Range.Text
  s1 = changeSmartquotes(Left(s1, Len(s1) - 1))
  s2 = changeSmartquotes(Left(s2, Len(s2) - 1))
  If InStr(1, s1, Chr(34)) = 0 Or InStr(1, s2, Chr(34)) = 0 Then
    MsgBox "Error in selection. The third and/or fourth paragraphs do not appear to have string data"
    Exit Sub
  End If
  StringDescr = aRange.Paragraphs(1).Range.Text
  j = -1
  With MainForm
    If .Strings1Option.Value = True Then
      j = 1
      .Strings1Option.Caption = StringDescr
    End If
    If .Strings2Option.Value = True Then
      j = 2
      .Strings2Option.Caption = StringDescr
    End If
    If .Strings3Option.Value = True Then
      j = 3
      .Strings3Option.Caption = StringDescr
    End If
    If .Strings4Option.Value = True Then
      j = 4
      .Strings4Option.Caption = StringDescr
    End If
    If .Strings0Option.Value = True Or j = -1 Then
      j = 0
      .Strings0Option.Caption = StringDescr
      .Strings0Option.Value = True
    End If
  End With
  PatternItem = j
  Fs(PatternItem) = s1
  Ts(PatternItem) = s2
  PDesc(j) = StringDescr
  Call UserSetupOK(False, s1, s2)
  LoadPatterns (j)
  'MainForm.Show
  
End Sub
Sub LoadPatterns(p As Long)
Dim st As String, st1 As String, st2 As String, Qt As String
Dim i As Long
  MainForm.IndexNames.Clear
  If Fs(PatternItem) = "" Then Exit Sub ' no text set
  Qt = Chr(34)
  With MainForm
    .IndexNames.Font.Name = "Tahoma"
    .IndexNames.Font.Size = 7
  End With
  Call UserSetupOK(False, Fs(p), Ts(p))
    i = 0
  Do While (i < 200) And (findText(i) <> "")
    If i = 20 Then DoEvents  ' needed for Word to catch up
    st1 = Qt & findText(i) & Qt
    st2 = Qt & replaceT(i) & Qt
    If Len(st1) > 25 Then
      st1 = st1 & "  "
    Else
      st1 = Left(st1 & "                     ", 25)
    End If
    st = st1 & st2
    If Not patternSW(PatternItem, i) Then st = "**** " & st
    MainForm.IndexNames.AddItem st
    i = i + 1
  Loop
  'If i > 20 Then i = 20
  MainForm.IndexNames.Height = 197.25
  
End Sub

Sub Load_Patterns(k As Long) ' called from change in options
  PatternItem = k
  LoadPatterns (k)
End Sub

Sub put_SelectedText(n As Long)
Dim s1 As String
Dim s2 As String
  If Selection.Paragraphs.Count <> 2 Then
    MsgBox "Exactly two paragraphs must be selected"
    Exit Sub
  End If
  s1 = Selection.Paragraphs(1).Range.Text
  s2 = Selection.Paragraphs(2).Range.Text
  s1 = changeSmartquotes(Left(s1, Len(s1) - 1))
  s2 = changeSmartquotes(Left(s2, Len(s2) - 1))
  UserSet.UserFrom.Value = s1
  UserSet.UserTo.Value = s2
End Sub
Function changeSmartquotes(s As String) As String ' unless surrounded by straight quotes
Dim j As Long
Dim k As Long
  k = 1
  On Error GoTo Cerr
  Do While k < Len(s)
    j = InStr(k, s, ",")
    If j = 0 Then j = Len(s) + 1
    If Mid(s, k, 1) = Chr(147) Or Mid(s, k, 1) = Chr(148) Then
      Mid(s, k, 1) = Chr(34)
    End If
    If Mid(s, j - 1, 1) = Chr(147) Or Mid(s, j - 1, 1) = Chr(148) Then
      Mid(s, j - 1, 1) = Chr(34)
    End If
    k = j + 1
  Loop
  On Error GoTo 0
  changeSmartquotes = s
  Exit Function
Cerr:
  On Error GoTo 0
  MsgBox s & " is an invalid string"
  changeSmartquotes = "ERROR"
End Function


Sub UserSetupOK(fromUser As Boolean, FFs As String, TTs As String)  'unpick to & from. If no error hide userset
Dim i As Long, j As Long, k As Long
'Dim stF As String, stR As String
Dim paraSW As Boolean

  FFs = Trim(FFs)
  FFs = changeSmartquotes(FFs)
  TTs = Trim(TTs)
  TTs = changeSmartquotes(TTs)
  Qt = Chr(34)

  If Not unpick(FFs, i, findText) Then
    MsgBox "Syntax error in From items."
    Exit Sub
  End If
 ' If UserSet.WildcardCheckBox Then
 '   For k = 0 To i
 '     If InStr(findText(k), "^p") > 0 Then
 '       MsgBox "Cannot have ^p in From and have wildcard set." & vbCrLf & _
 '       "Change ^p to ^13 or turn off wildcard." & vbCrLf & "WARNING: don't use ^p in replacement text"
  '      Exit Sub
 '     End If
 '   Next k
 ' End If
  If Not unpick(TTs, j, replaceT) Then
    MsgBox "Syntax error in To items."
    Exit Sub
  End If
  If i <> j Then
    MsgBox "Unequal From and Replace items. From=" & i & "  replace=" & j
    Exit Sub
  End If

'  Call setPatternSw(PatternItem, i) '???????????????????????
  UwholeWord = False  'UserSet.WholeWord.Value
 ' If fromUser Then UmatchCase = UserSet.CaseSensitive.Value
'  Call setItems(Fs, Ts, i, UwholeWord, UmatchCase)
  nU = i + 1
 ' Load_Patterns (1)
  Set_CaseSensitive (1)
  If fromUser Then UserSet.Hide
End Sub

Sub setItems(F, r, i, w, C) ' called from Set patterns - user specified items ?????????????????
Dim k As Integer
  On Error GoTo Werr
   For k = 0 To i - 1   ' ith is blank
    findText(k) = Mid(F(k), 2, Len(F(k)) - 2)
    replaceT(k) = Mid(r(k), 2, Len(r(k)) - 2)
  Next k
  findText(i) = ""
  WholeWord = w
  MatchCaseSw = C
  On Error GoTo 0
  Exit Sub
Werr:
  On Error GoTo 0
  i = 1
  MsgBox "Error in user specified strings. Could be nul character in item"
End Sub

Function unpick(st As String, L As Long, U) As Boolean ' st format must be "text1","text2",etc
Dim st1 As String, st2 As String
Dim i As Long, j As Long, k As Long, m As Long
  unpick = False
  st = Trim(st) & " " ' for running off end with quote within quote
  If st = "" Or Left(st, 1) = "," Or Left(st, 1) <> Qt Then Exit Function
  L = -1
  k = 1
  m = 1
  Do While k < Len(st)
    j = InStr(k, st, Qt) ' first quote
    If j = 0 Then Exit Do
    m = InStr(j + 1, st, Qt) ' next quote
    If m = 0 Then Exit Do 'm = Len(st) - 1 ' last item
    If Mid(st, m + 1, 1) = Qt Then
      ' test for quote within quote
      m = m + 1
    End If
    st1 = Mid(st, j, m - j + 1)
 ' If Left(st1, 1) = " " Then MsgBox "leading space"
    L = L + 1
    U(L) = Mid(st1, 2, Len(st1) - 2)
    k = m + 1
  Loop
  L = L + 1
  U(L) = ""
  unpick = True
End Function

Private Sub openDataFile()
Dim startPath As String
Dim s As String
Dim doc As Document
  s = "FindReplaceData.docx"
  For Each doc In Application.Documents
    If doc.Name = s Then
     doc.Activate
     If doc.Windows(1).WindowState = wdWindowStateMinimize Then _
            doc.Windows(1).WindowState = wdWindowStateMaximize
     Exit Sub
   End If
  Next doc
  On Error GoTo dd:
   startPath = Options.DefaultFilePath(wdStartupPath)
   Documents.Open (startPath & "\" & s)
  On Error GoTo 0
  Exit Sub
dd:
  MsgBox "Cannot find file FindReplaceData.docx in " & startPath
  On Error GoTo 0
End Sub

Sub manualOK(n As Long)
Dim s As String
  Fs(PatternItem) = UserSet.UserFrom.Value
  Ts(PatternItem) = UserSet.UserTo.Value
  Call UserSetupOK(True, UserSet.UserFrom.Value, UserSet.UserTo.Value)
  LoadPatterns (PatternItem)
  s = Trim(UserSet.UserDescr.Value)
  If s = "" Then s = "Manual data"
  With MainForm
    Select Case PatternItem
      Case 0
        .Strings0Option.Caption = s
      Case 1
        .Strings1Option.Caption = s
      Case 2
        .Strings2Option.Caption = s
      Case 3
        .Strings3Option.Caption = s
      Case 4
        .Strings4Option.Caption = s
    End Select
  End With
  PDesc(PatternItem) = s
End Sub
Attribute VB_Name = "TextboxForm"
Attribute VB_Base = "0{FC19FB86-0B4C-4BF5-96C0-8E5631D7954D}{0DC02906-10F5-4D46-873D-39937D2711CB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub NextTextBox_Click()
  Go_nextBox (1)
End Sub

Private Sub CancelTextBox_Click()
  Go_CancelBox (1)
End Sub

Private Sub ConvertTextBox_Click()
 Go_Inline (1)
End Sub

Private Sub ConvertToTextbox_Click()
  TextToBox (1)
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "UserSet"
Attribute VB_Base = "0{FBDFD591-EFEE-4C1A-B314-C351C56AB22D}{55E75C5D-F054-4616-9296-C1F90DD6598A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub OpenDataButton_Click()
  openDataFile (1)
End Sub

Private Sub SelectedTextButton_Click()
  getStringsFromDoc (1)
End Sub
Private Sub CaseSensitive_Click()
  Set_CaseSensitive (1)
End Sub

Private Sub UserDefinedCancel_Click()
  UserSet.Hide
End Sub

Private Sub UserDefinedOK_Click()
  manualOK (1)
End Sub

Private Sub Userform_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then UserSet.Hide
End Sub


Attribute VB_Name = "WindowsParameters"
Option Explicit
' can also use #If VBA7 to see if working in VBA 7 environment

#If Win64 Then
  Private Declare PtrSafe Function GetDC Lib "User32" (ByVal hWnd As Long) As Long
  Private Declare PtrSafe Function ReleaseDC Lib "User32" ( _
    ByVal hWnd As Long, _
    ByVal hDC As Long) As Long
  Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" ( _
    ByVal hDC As Long, _
    ByVal nIndex As Long) As Long
  Private Declare PtrSafe Function GetSystemMetrics Lib "User32" ( _
    ByVal nIndex As Long) As Long
 ' MsgBox "64 bit version"
#Else
  Private Declare Function GetDC Lib "User32" (ByVal hWnd As Long) As Long
  Private Declare Function ReleaseDC Lib "User32" ( _
    ByVal hWnd As Long, _
    ByVal hDC As Long) As Long
  Private Declare Function GetDeviceCaps Lib "gdi32" ( _
    ByVal hDC As Long, _
    ByVal nIndex As Long) As Long
  Private Declare Function GetSystemMetrics Lib "User32" ( _
    ByVal nIndex As Long) As Long
'MsgBox "32 bit version"
#End If

Const LOGPIXELSX = 88
Const LOGPIXELSY = 90
Const TWIPSPERINCH = 1440
Private Const SM_CXFULLSCREEN = 16 ' also 0 gives overall screenwidth
Private Const SM_CYFULLSCREEN = 17 ' 1 gives overall, 17 gives useable excluding taskbars


Sub ConvertPixelsToPoints(ByRef x As Single, ByRef y As Single)
    Dim hDC As Long
    Dim RetVal As Long
    Dim XPixelsPerInch As Long
    Dim YPixelsPerInch As Long

    hDC = GetDC(0)
    XPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX)
    YPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSY)
    RetVal = ReleaseDC(0, hDC)
    x = x * TWIPSPERINCH / 20 / XPixelsPerInch
    y = y * TWIPSPERINCH / 20 / YPixelsPerInch
    
 ' MsgBox "points x=" & x & " y=" & y
End Sub
Sub GiveScreenPoints(ByRef scx As Single, ByRef scy As Single)
Dim wt As Single
Dim ht As Single
 wt = GetSystemMetrics(SM_CXFULLSCREEN)
 ht = GetSystemMetrics(SM_CYFULLSCREEN)
 ConvertPixelsToPoints wt, ht
 scx = wt
 scy = ht
End Sub


' InQuest injected base64 decoded content
' z{Rr
' yJiz
' yJiz

INQUEST-PP=macro
