Attribute VB_Name = "ClsSimple"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim Key As String
Dim Name As String

Attribute VB_Name = "Constants"
Option Explicit

Public Const pcWSName_Cover As String = "Cover sheet"
Public Const pcWSName_Summary As String = "Systems"
Public Const pcWSName_PrintLayout As String = "PrintLayout"
Public Const pcWSName_Index As String = "Index"
Public Const pcWSName_Transfer As String = "TransferForm"
Public Const pcWSName_Storage As String = "Storage"
Public Const pcWSName_Deka As String = "Deka"
Public Const pcWSName_VersionLog As String = "VersionLog"

Public Const pcWSPara_Summary_TemplateRow As Long = 8
Public Const pcWSPara_Summary_IDCol As Long = 20

Public Const pcPara_Worksheetpassword As String = "471158"
Public Const pcPara_WorkBookpassword As String = "471158"
Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_AfterSave(ByVal Success As Boolean)


    If Success Then
        Debug.Print "CheckForSaveWarning: " & CheckForSaveWarning()
    End If

End Sub



Private Sub Workbook_BeforeClose(Cancel As Boolean)
    
    Unload frmConstruction
    Unload frmSort
    
End Sub

Private Sub Workbook_Open()

    On Error Resume Next

    UNProtectAll
    ProtectAll
    ButtonSaver
    
    On Error GoTo 0
    
    '* On Error Resume Next
    '* ThisWorkbook.Worksheets(pcWSName_Cover).Activate
    '* ThisWorkbook.Worksheets(pcWSName_Cover).Cells(6, 2).Select
    '* On Error GoTo 0
    
End Sub
Attribute VB_Name = "SaveWarningXLMT"
Option Explicit

'Private Sub Workbook_AfterSave(ByVal Success As Boolean)
'    if success then
'        Debug.Print "CheckForSaveWarning: " & CheckForSaveWarning()
'    End If
'End Sub


Public Function CheckForSaveWarning() As Boolean

    'Debug.Print "Filename: " & ThisWorkbook.Name
    
    CheckForSaveWarning = False
    
    Select Case LCase(ExtensionOnly(ThisWorkbook.Name))
        
        Case "xlsb": CheckForSaveWarning = True
        
        Case "xlsm": CheckForSaveWarning = True
        
        Case "xls":
            If Val(Application.Version) > 11 Then
                ' Off 2007 ff
                MsgBox "You just have saved this file in a format which is not recommended!" & vbCrLf & vbCrLf & _
                        "Please save only in .xls format for compatibility reasons." & vbCrLf & _
                        "Some constrictions in functionality may occur." _
                        , vbExclamation + vbOKOnly, "Warning !"
            Else
                ' Off 2003 an before
                CheckForSaveWarning = True
            End If
        
        Case "xlsx":
            MsgBox "You just have saved this file in a format which is not allowed !" & vbCrLf & vbCrLf & _
                    "Please save only in the formats .xlsm or .xlsb, otherwise you may loose all your data in this workbook!" _
                    , vbExclamation + vbOKOnly, "Warning !"
                    
        Case Else:
            MsgBox "You just have saved this file in a format which is not allowed !" & vbCrLf & vbCrLf & _
                    "Please save only in the formats .xlsm or .xlsb, otherwise you may loose all your data in this workbook!" _
                    , vbExclamation + vbOKOnly, "Warning !"
    
    End Select

End Function



Attribute VB_Name = "Service"
Option Explicit

Public Sub ButtonSaver()
    ' Resize ans Place all Buttons because of "Button growing bug"
    
    Const xOffset As Long = 406
    Const yOffset As Long = 20
    
    With ThisWorkbook.Worksheets(pcWSName_Summary).cmdAdd
        .Top = 10.5 + yOffset
        .Height = 23.25
        .Width = 93.75
        .Left = 45.75 + xOffset
        .Font.Name = "Arial"
        .Font.Size = 10
        .Font.Bold = False
    End With
    With ThisWorkbook.Worksheets(pcWSName_Summary).cmdSort
        .Top = 10.5 + yOffset
        .Height = 23.25
        .Width = 93.75
        .Left = 145.5 + xOffset
        .Font.Name = "Arial"
        .Font.Size = 10
        .Font.Bold = False
    End With
    With ThisWorkbook.Worksheets(pcWSName_Summary).cmdPrintAll
        .Top = 10.5 + yOffset
        .Height = 23.25
        .Width = 123.75
        .Left = 246 + xOffset
        .Font.Name = "Arial"
        .Font.Size = 10
        .Font.Bold = False
    End With

End Sub

Public Function SortRange(MyRange As Range, SortColumn1 As Long, Optional SortColumn2 As Long = 0, Optional SortColumn3 As Long = 0, Optional OrderAsc1 As Boolean = True, Optional OrderAsc2 As Boolean = True, Optional OrderAsc3 As Boolean = True, Optional SortColumn4 As Long = 0, Optional OrderAsc4 As Boolean = True) As Boolean

    Dim lngSortMethod As Long

    ' Return office version No:
    ' 2010 = 14
    ' 2007 = 12
    ' 2003 = 11

    If Val(Application.Version) > 11 Then
        ' Off 2007 ff
        lngSortMethod = 1
    Else
        ' office 2003 or before
        '**** Office 2003 can only handle 3 Sort Columns !!!!
        lngSortMethod = 2
    End If
    
    
    Select Case lngSortMethod
            
        Case 1
            ' Office 2007 ff
            With MyRange.Parent
                .Sort.SortFields.Clear
                
                .Sort.SortFields.Add Key:=MyRange.Columns(SortColumn1), _
                        SortOn:=0, _
                        Order:=IIf(OrderAsc1, xlAscending, xlDescending), _
                        DataOption:=xlSortNormal
                If SortColumn2 > 0 Then
                    .Sort.SortFields.Add Key:=MyRange.Columns(SortColumn2), _
                            SortOn:=0, _
                            Order:=IIf(OrderAsc2, xlAscending, xlDescending), _
                            DataOption:=xlSortNormal
                End If
                If SortColumn3 > 0 Then
                    .Sort.SortFields.Add Key:=MyRange.Columns(SortColumn3), _
                            SortOn:=0, _
                            Order:=IIf(OrderAsc3, xlAscending, xlDescending), _
                            DataOption:=xlSortNormal
                End If
                If SortColumn4 > 0 Then
                    .Sort.SortFields.Add Key:=MyRange.Columns(SortColumn4), _
                            SortOn:=0, _
                            Order:=IIf(OrderAsc4, xlAscending, xlDescending), _
                            DataOption:=xlSortNormal
                End If
                
            
                .Sort.SetRange MyRange
                .Sort.Header = xlNo
                .Sort.MatchCase = False
                .Sort.Orientation = xlTopToBottom
                .Sort.SortMethod = xlPinYin
                .Sort.Apply
                
            End With
        
        
        Case 2
        ' ** Office 2003 version
        
            If SortColumn3 > 0 Then
                MyRange.Sort key1:=MyRange.Columns(SortColumn1), Order1:=IIf(OrderAsc1, xlAscending, xlDescending), _
                    key2:=MyRange.Columns(SortColumn2), Order1:=IIf(OrderAsc2, xlAscending, xlDescending), _
                    key3:=MyRange.Columns(SortColumn3), Order1:=IIf(OrderAsc3, xlAscending, xlDescending), _
                    Header:=xlNo, Orientation:=xlTopToBottom

            ElseIf SortColumn2 > 0 Then
                MyRange.Sort key1:=MyRange.Columns(SortColumn1), Order1:=IIf(OrderAsc1, xlAscending, xlDescending), _
                    key2:=MyRange.Columns(SortColumn2), Order1:=IIf(OrderAsc2, xlAscending, xlDescending), _
                    Header:=xlNo, Orientation:=xlTopToBottom
            
            Else
                        MyRange.Sort key1:=MyRange.Columns(SortColumn1), Order1:=IIf(OrderAsc1, xlAscending, xlDescending), _
                            Header:=xlNo, Orientation:=xlTopToBottom

            End If
                 
        
    End Select
    
    SortRange = True
    
End Function

Sub MarkupObject(myObj As Object, Markup As Boolean, Optional AllOk As Boolean, Optional AllOkLocal As Boolean)

    ' Use Border as Markup instrument
    ' Color of Border is predefined in Form, borde is only swithced on or off
    
    
    myObj.BorderStyle = IIf(Markup, 1, 0)
    If Markup Then AllOk = False
    If Markup Then AllOkLocal = False
    
    

End Sub


Public Function NoZeroDates(myDate As Date, Optional myDateFormat As String = "Short Date") As String

    '*** Do not show 00:00:00 when date is zero
    '*** return "" instead
    
    If myDate = 0 Then
        NoZeroDates = ""
    Else
        NoZeroDates = Format(myDate, myDateFormat)
    End If

End Function
Public Function ShowPrinterDialog() As Boolean

    ' Shows standard dialog f|fffd|r Printer choice with default printer marked.
    ' Returns False when canceled
    
    ShowPrinterDialog = Application.Dialogs(xlDialogPrinterSetup).Show
    'Application.Dialogs(xlDialogPrint).Show
    
    
End Function

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "cmdPrintAll, 37, 0, MSForms, CommandButton"
Attribute VB_Control = "cmdSort, 4, 1, MSForms, CommandButton"
Attribute VB_Control = "cmdAdd, 3, 2, MSForms, CommandButton"

Private Sub cmdAdd_Click()
    '*******************************
    '** add new System
    '*******************************
    Dim Thisrow As Long
    
    frmConstruction.EditId = 0
    frmConstruction.Show 1
    Unload frmConstruction
    
    On Error Resume Next
    Thisrow = ActiveCell.Row
    Me.Cells(Thisrow, 1).Select
    On Error GoTo 0

End Sub

Private Sub cmdPrintAll_Click()
    '*********************************
    '** Print All
    '*********************************
    
    Dim myM As clsMain
    Dim RowId As Long
    Dim iRow As Long
    Dim iCount As Long

    ' .. Ask for sure ?
    iCount = Application.Range("nrNextFreeRow").Value - 9
    If Not vbYes = MsgBox("Do you want to print all " & iCount & " system cards ?", vbQuestion + vbYesNoCancel) Then
        Exit Sub
    End If
    
    '... select printer
    If Not ShowPrinterDialog() Then
        Exit Sub
    End If
    
    '.. get clsMain
    Set myM = New clsMain
    Application.ScreenUpdating = False
    
    '.. Loop Cover sheet rows
    For iRow = 9 To Application.Range("nrNextFreeRow").Value - 1
        RowId = Me.Cells(iRow, pcWSPara_Summary_IDCol).Value
        myM.SystemPrint RowId, False, False
    Next iRow
    
    '.. cleanup
    Application.ScreenUpdating = True
    Set myM = Nothing
    
    '... msg ok
    MsgBox "All sheets have been sent to the printer.", vbInformation + vbOKOnly
    
    
End Sub

Private Sub cmdSort_Click()
    frmSort.Show 1
    Unload frmSort

End Sub

Private Sub Worksheet_Change(ByVal Target As Range)

    Dim ActionCommand As String
    Dim myM As clsMain
    Dim RowId As Long

    If Not Application.Intersect(Target, Me.Columns(1)) Is Nothing Then
        
        '* only whe this is a singel cell...
        If Target.Rows.Count > 1 Then GoTo ActionOut
        If Target.Row < 9 Then GoTo ActionOut
        If Target.Columns.Count > 1 Then GoTo ActionOut
        
        ' This is the Action Column
        ActionCommand = Trim(LCase(Target.Value))
        Application.EnableEvents = False
        Target.Value = ""
        Application.EnableEvents = True
        
        Select Case ActionCommand
        
            Case "edit"
                frmConstruction.EditId = CLng(Me.Cells(Target.Row, pcWSPara_Summary_IDCol))
                frmConstruction.Show 1
                Unload frmConstruction
            
            Case "delete"
                '.. del from storage
                If Not vbYes = MsgBox("Do you really want to delete this system ?", vbQuestion + vbYesNoCancel + vbDefaultButton1) Then
                    GoTo ActionOut
                End If
                
                Set myM = New clsMain
                RowId = Me.Cells(Target.Row, pcWSPara_Summary_IDCol).Value
                Application.ScreenUpdating = False
                myM.DeleteFromStorage (RowId)
                Set myM = Nothing
                
                '. del in summary
                DeleteXLSLine Me, Target.Row
                PrintRangeSet pcWSName_Summary
                Application.ScreenUpdating = True
                
            Case "print"
                Set myM = New clsMain
                RowId = Me.Cells(Target.Row, pcWSPara_Summary_IDCol).Value
                myM.SystemPrint RowId, True
                Set myM = Nothing
                
            Case "no action"
                ' just for interface dummies...
            
        End Select
        
    End If
    
ActionOut:

End Sub


Attribute VB_Name = "Tabelle9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tools"
'Option Explicit

#If VBA7 Then
        ' This is Office 2007 ff
        Public Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (OFN As OPENFILENAME) As Boolean
        Public Type OPENFILENAME
            lStructSize As Long
            hwndOwner As LongPtr
            hInstance As LongPtr
            lpstrFilter As String
            lpstrCustomFilter As String
            nMaxCustFilter As Long
            nFilterIndex As Long
            lpstrFile As String
            nMaxFile As Long
            lpstrFileTitle As String
            nMaxFileTitle As Long
            lpstrInitialDir As String
            lpstrTitle As String
            flags As Long
            nFileOffset As Integer
            nFileExtension As Integer
            lpstrDefExt As String
            lCustData As Long
            lpfnHook As LongPtr
            lpTemplateName As String
        End Type

#Else
        ' this is office 2003
        Public Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (OFN As OPENFILENAME) As Boolean
        Public Type OPENFILENAME
          lStructSize As Long
          hwndOwner As Long
          hInstance As Long
          lpstrFilter As String
          lpstrCustomFilter As String
          nMaxCustFilter As Long
          nFilterIndex As Long
          lpstrFile As String
          nMaxFile As Long
          lpstrFileTitle As String
          nMaxFileTitle As Long
          lpstrInitialDir As String
          lpstrTitle As String
          flags As Long
          nFileOffset As Integer
          nFileExtension As Integer
          lpstrDefExt As String
          lCustData As Long
          lpfnHook As Long
          lpTemplateName As String
        End Type
#End If


Public Function GetFileNameOnly(FullPath As String)

    Dim StrFind As String
    Dim iCount As Long
    
    Do Until Left(StrFind, 1) = "\"
        iCount = iCount + 1
        StrFind = Right(FullPath, iCount)
        If iCount = Len(FullPath) Then Exit Do
    Loop

    GetFileNameOnly = Right(StrFind, Len(StrFind) - 1)

End Function
Public Function WorkBookIsOpen(WorkbookName As String) As Boolean

    Dim wBook As Workbook

    On Error Resume Next
    Set wBook = Workbooks(WorkbookName)

    If wBook Is Nothing Then 'Not open
        WorkBookIsOpen = False
    Else 'It is open
        WorkBookIsOpen = True
    End If
    Set wBook = Nothing
    On Error GoTo 0

End Function
Public Function FolderExists(myFolder As String) As Boolean
   FolderExists = False
   FolderExists = Dir(myFolder, vbDirectory) <> ""
End Function

Public Function ExcelWorkbookGet(WBFilename As String, ReturnWorkbook As Object) As Boolean
                
    Dim myXLS As Object ' Excel.Application
    Dim myWB As Object  ' Excel.Workbook

    If Not FileExists(WBFilename) Then
        Exit Function
    End If
    
    ' get Excel applixcation
    On Error Resume Next
    Set myXLS = GetObject(, "Excel.Application")
    
    If Err Then
        Err.Clear
        On Error GoTo ewbgErr
        Set myXLS = CreateObject("Excel.Application")
    End If
    
    On Error GoTo ewbgErr
    
    ' Open Workbook
    Set myWB = myXLS.Workbooks.Open(WBFilename, False)
    
    'OK out
    ExcelWorkbookGet = True
    Set ReturnWorkbook = myWB
    
ewbgExit:
        On Error Resume Next
        Set myXLS = Nothing
        Set myWB = Nothing
        On Error GoTo 0
        Exit Function

ewbgErr:
        Debug.Print "Fehler in ExcelWorkbookGet" & Err & " -> "; Error(Err)
        Resume ewbgExit
    
End Function
Public Function RangeExists(RangeName As String) As Boolean

    Dim wBook As Range

    On Error Resume Next

    Set wBook = Application.Range(RangeName)

    If (Not Err = 0) Or wBook Is Nothing Then 'Not open
        RangeExists = False
    Else 'It is open
        RangeExists = True
    End If
    Set wBook = Nothing
    On Error GoTo 0

End Function
Public Function WorkSheetExists(Worksheetname As String) As Boolean

    Dim wBook As Worksheet

    On Error Resume Next

    Set wBook = ThisWorkbook.Worksheets(Worksheetname)

    If (Not Err = 0) Or wBook Is Nothing Then 'Not open
        WorkSheetExists = False
    Else 'It is open
        WorkSheetExists = True
    End If
    Set wBook = Nothing
    On Error GoTo 0

End Function
Public Function SlideExists(myPP As Object, SlideName As String) As Boolean

    '*Dim wBook As PowerPoint.Slide
    Dim wBook As Object

    On Error Resume Next

    Set wBook = myPP.Slides.Item(SlideName)

    If (Not Err = 0) Or wBook Is Nothing Then 'Not open
        SlideExists = False
    Else 'It is open
        SlideExists = True
    End If
    Set wBook = Nothing
    On Error GoTo 0

End Function



Public Function FileExists(sFilePath As String) As Boolean
 
    If Trim(sFilePath) = "" Then Exit Function
    If Right(sFilePath, 1) = "\" Then Exit Function
    On Error Resume Next
    FileExists = Dir(sFilePath) <> ""
    FileExists = FileExists And Err.Number = 0
    On Error GoTo 0
 
End Function

Sub showObjName()
    Debug.Print ActiveChart.Name
End Sub
Public Function fXLNumberToLetter(iColumn As Long) As String
   Dim s1 As Long, s2 As Long, s3 As Long, s4 As Long
    
   s2 = iColumn \ 26
   s1 = iColumn Mod 26
   If s1 = 0 Then
      s1 = 26
      s2 = s2 - 1
   End If
   s3 = (s2 - 1) \ 26
   s4 = (s3 - 1) \ 26
    
   s2 = s2 - s3 * 26
   s3 = s3 - s4 * 26
    
   fXLNumberToLetter = Replace(Chr(s4 + 64) & Chr(s3 + 64) & Chr(s2 + 64) & _
         Chr(s1 + 64), "@", "")
End Function
Public Function fXLLetterToNumber(ColumnStr As String) As Long
    Dim myStr As String
    Dim i As Long
    Dim iMulti As Long
    
    
    myStr = UCase(Trim(ColumnStr))
    iMulti = 0
    For i = 1 To Len(myStr)
        fXLLetterToNumber = fXLLetterToNumber + (Asc(Mid(myStr, Len(myStr) - (i - 1))) - 64) * 26 ^ (i - 1)
    Next i
    
End Function



Public Function ColItemExists(myCollection As Collection, myKey As String) As Boolean
'returns true if the key value (not index) exists in the collection
Dim objTemp As String

On Error GoTo Exists_Err
objTemp = myCollection.Item(myKey).Key

ColItemExists = True

Exit_Function:
    Exit Function

Exists_Err:
    If Err.Number = 5 Then
        ColItemExists = False
    Else
        'further error handling here for other error types
    End If
    Resume Exit_Function

End Function
Function ShowFileSelectDialog(Filetypes As String) As String
    Dim Filetoopen As Variant
    Filetoopen = Application.GetOpenFileName(Filetypes, , "Select import file", , False)
    If Filetoopen <> False Then
        ShowFileSelectDialog = Filetoopen
    End If
End Function
Public Function SeperateFilters(myFilterstr As String, Optional Seperator As String = ";", Optional retFilterAnz) As Variant

    ReDim tmpArr(1 To 200) As Variant
    Dim nextPos As Long
    Dim filterRest As String
    Dim iCounter As Long
    
    filterRest = Trim(myFilterstr)
    nextPos = InStr(1, filterRest, Seperator)
    
    Do While nextPos > 0
        iCounter = iCounter + 1
        tmpArr(iCounter) = Trim(Left(filterRest, nextPos - 1))
        filterRest = Right(filterRest, Len(filterRest) - nextPos)
        nextPos = InStr(1, filterRest, Seperator)
    Loop
    If Len(Trim(filterRest)) > 0 Then
        iCounter = iCounter + 1
        tmpArr(iCounter) = Trim(filterRest)
    End If
    
    ReDim Preserve tmpArr(1 To iCounter) As Variant
    SeperateFilters = tmpArr
    retFilterAnz = iCounter
    
End Function
Function RangeExpander(MyRangeStr As String, Optional yTopAdd As Long = 0, Optional yBottomAdd As Long = 0, Optional xLeftAdd As Long = 0, Optional xRightAdd As Long = 0) As String
    
    ' range must be absulote e.g. $A$1:$V$12
    
    Dim StartColStr As String
    Dim EndColStr As String
    
    Dim StartCol As Long
    Dim EndCol As Long
    Dim StartRow As Long
    Dim EndRow As Long
    
    Dim iPoint1 As Long
    Dim iPoint2 As Long
    Dim iPoint3 As Long
    
    If Len(MyRangeStr) = 0 Then Exit Function
    
    
    iPoint1 = InStr(2, MyRangeStr, "$")
    iPoint2 = InStr(iPoint1 + 1, MyRangeStr, "$")
    iPoint3 = InStr(iPoint2 + 1, MyRangeStr, "$")

    If iPoint1 = 0 Or iPoint2 = 0 Or iPoint3 = 0 Then
        Exit Function
    End If
    
    StartColStr = Mid(MyRangeStr, 2, iPoint1 - 2)
    StartRow = Val(Mid(MyRangeStr, iPoint1 + 1, iPoint2 - iPoint1))
    EndColStr = Mid(MyRangeStr, iPoint2 + 1, iPoint3 - iPoint2 - 1)
    EndRow = Val(Mid(MyRangeStr, iPoint3 + 1, Len(MyRangeStr) - iPoint3))
    
    StartCol = fXLLetterToNumber(StartColStr)
    EndCol = fXLLetterToNumber(EndColStr)
    
    If Not yTopAdd = 0 Then StartRow = StartRow - yTopAdd
    If Not yBottomAdd = 0 Then EndRow = EndRow + yBottomAdd
    If Not xLeftAdd = 0 Then StartCol = StartCol - xLeftAdd
    If Not xRightAdd = 0 Then EndCol = EndCol + xRightAdd
    
    StartColStr = fXLNumberToLetter(StartCol)
    EndColStr = fXLNumberToLetter(EndCol)
    
    RangeExpander = "$" & StartColStr & "$" & StartRow & ":$" & EndColStr & "$" & EndRow
    
End Function
Function RangeSetStatic(MyRangeStr As String, Optional fixedTop As Variant, Optional fixedBottom As Variant, Optional fixedLeft As Variant, Optional fixedRight As Variant) As String
    
    ' range must be absulote e.g. $A$1:$V$12
    
    Dim StartColStr As String
    Dim EndColStr As String
    
    Dim StartCol As Long
    Dim EndCol As Long
    Dim StartRow As Long
    Dim EndRow As Long
    
    Dim iPoint1 As Long
    Dim iPoint2 As Long
    Dim iPoint3 As Long
    
    If Len(MyRangeStr) = 0 Then Exit Function
    
    
    iPoint1 = InStr(2, MyRangeStr, "$")
    iPoint2 = InStr(iPoint1 + 1, MyRangeStr, "$")
    iPoint3 = InStr(iPoint2 + 1, MyRangeStr, "$")

    If iPoint1 = 0 Or iPoint2 = 0 Or iPoint3 = 0 Then
        Exit Function
    End If
    
    StartColStr = Mid(MyRangeStr, 2, iPoint1 - 2)
    StartRow = Val(Mid(MyRangeStr, iPoint1 + 1, iPoint2 - iPoint1))
    EndColStr = Mid(MyRangeStr, iPoint2 + 1, iPoint3 - iPoint2 - 1)
    EndRow = Val(Mid(MyRangeStr, iPoint3 + 1, Len(MyRangeStr) - iPoint3))
    
    StartCol = fXLLetterToNumber(StartColStr)
    EndCol = fXLLetterToNumber(EndColStr)
    
    If Not IsMissing(fixedTop) Then StartRow = fixedTop
    If Not IsMissing(fixedBottom) Then EndRow = fixedBottom
    If Not IsMissing(fixedLeft) Then StartCol = fixedLeft
    If Not IsMissing(fixedRight) Then EndCol = fixedRight
    
    StartColStr = fXLNumberToLetter(StartCol)
    EndColStr = fXLNumberToLetter(EndCol)
    
    RangeSetStatic = "$" & StartColStr & "$" & StartRow & ":$" & EndColStr & "$" & EndRow
    
End Function
Public Function FieldExists(myRecordset As Object, myFieldName As String) As Boolean
'returns true if the Fieldname exists in the Recorset
Dim objTemp As String

On Error GoTo Exists_Err
objTemp = myRecordset.Fields(myFieldName).Name

FieldExists = True

Exit_Function:
    Exit Function

Exists_Err:
    If Err.Number = 5 Then
        FieldExists = False
    Else
        'further error handling here for other error types
    End If
    Resume Exit_Function

End Function

Public Function NoInvalidForDBName(ByVal myStr As Variant) As String

    myStr = Replace(myStr, " ", "")
    myStr = Replace(myStr, "-", "")
    myStr = Replace(myStr, "_", "")
    myStr = Replace(myStr, "\", "")
    myStr = Replace(myStr, "/", "")
    myStr = Replace(myStr, ":", "")
    myStr = Replace(myStr, "*", "")
    myStr = Replace(myStr, "?", "")
    myStr = Replace(myStr, "<", "")
    myStr = Replace(myStr, ">", "")
    myStr = Replace(myStr, "|", "")
    NoInvalidForDBName = Replace(myStr, Chr(34), "")
    
End Function


Public Function BoolGetter(myBoolvalue As Variant) As Variant

    
    If IsNull(myBoolvalue) Then BoolGetter = Null: Exit Function
    If Trim(myBoolvalue) = "" Then BoolGetter = Null: Exit Function
    
    BoolGetter = Null
    If myBoolvalue = False Then BoolGetter = False: Exit Function
    If myBoolvalue = True Then BoolGetter = True: Exit Function
    If myBoolvalue = 1 Then BoolGetter = True: Exit Function
    
    Dim myStr As String
    myStr = LCase(Trim(myBoolvalue))
    
    If myStr = "on" Then BoolGetter = True: Exit Function
    If myStr = "off" Then BoolGetter = False: Exit Function
    If myStr = "no" Then BoolGetter = False: Exit Function
    If myStr = "yes" Then BoolGetter = True: Exit Function
    If myStr = "ja" Then BoolGetter = True: Exit Function
    If myStr = "nein" Then BoolGetter = False: Exit Function
    If myStr = "true" Then BoolGetter = True: Exit Function
    If myStr = "false" Then BoolGetter = False: Exit Function

End Function
Public Function GetFileNameDialog(sFilter As String, Optional StartPath As String = "", Optional retOk As Boolean) As String

    '// Sample filter:
    '// "Text Files (*.txt)" & Chr$(0) & "*.sky" & Chr$(0) & "All Files (*.*)" & Chr$(0) & "*.*"
    '// "Excel Files (*.xl*)" & Chr(0) & "*.xl*"
    '// "Excel Files (*.xl*)" & Chr(0) & "*.xl*" & Chr$(0) & "All Files (*.*)" & Chr$(0) & "*.*"

    Dim OpenFile As OPENFILENAME
    Dim lReturn As Long
    
     On Error GoTo errTrap
    
    OpenFile.lStructSize = LenB(OpenFile)

    
    
    OpenFile.lpstrFilter = sFilter
    OpenFile.nFilterIndex = 1
    OpenFile.lpstrFile = String(257, 0)
    OpenFile.nMaxFile = Len(OpenFile.lpstrFile) - 1
    OpenFile.lpstrFileTitle = OpenFile.lpstrFile
    OpenFile.nMaxFileTitle = OpenFile.nMaxFile
    If Not Trim(StartPath) = "" Then
        OpenFile.lpstrInitialDir = StartPath
    End If
    
    OpenFile.lpstrTitle = "Select File"
    OpenFile.flags = 0
    lReturn = GetOpenFileName(OpenFile)
    
    If lReturn = 0 Then
       GetFileNameDialog = ""
    Else
      retOk = True
      GetFileNameDialog = Trim(OpenFile.lpstrFile)
      'GetFileNameDialog = Replace(filePath, Chr(0), vbNullString)
    End If

    Exit Function
    
errTrap:
    Exit Function
    Resume

End Function


Public Function WithoutSlash(Filename As String) As String

    WithoutSlash = Filename
    If Right(Filename, 1) = "\" Then
        WithoutSlash = Left(Filename, Len(Filename) - 1)
    End If

End Function
Public Function ExtensionOnly(Filename As String) As String

    ExtensionOnly = ""

    Dim i As Long
    For i = Len(Filename) To 1 Step -1
        If Mid(Filename, i, 1) = "." Then
            ExtensionOnly = Right(Filename, Len(Filename) - i)
            Exit For
        End If
    Next i

End Function
Public Function WithoutExtension(Filename As String) As String

    WithoutExtension = Filename

    Dim i As Long
    For i = Len(Filename) To 1 Step -1
        If Mid(Filename, i, 1) = "." Then
            WithoutExtension = Left(Filename, i - 1)
            Exit For
        End If
    Next i

End Function
Public Sub RangeSplitter(MyRangeStr As String, Optional yTop As Long = 0, Optional yBottom As Long = 0, Optional xLeft As Long = 0, Optional xRight As Long = 0)
    ' range must be absulote e.g. $A$1:$V$12
    
    Dim StartColStr As String
    Dim EndColStr As String
    
    Dim StartCol As Long
    Dim EndCol As Long
    Dim StartRow As Long
    Dim EndRow As Long
    
    Dim iPoint1 As Long
    Dim iPoint2 As Long
    Dim iPoint3 As Long
    
    If Len(MyRangeStr) = 0 Then Exit Sub
    
    
    iPoint1 = InStr(2, MyRangeStr, "$")
    iPoint2 = InStr(iPoint1 + 1, MyRangeStr, "$")
    iPoint3 = InStr(iPoint2 + 1, MyRangeStr, "$")

    If iPoint1 = 0 Or iPoint2 = 0 Or iPoint3 = 0 Then
        Exit Sub
    End If
    
    xLeft = fXLLetterToNumber(Mid(MyRangeStr, 2, iPoint1 - 2))
    yTop = Val(Mid(MyRangeStr, iPoint1 + 1, iPoint2 - iPoint1))
    xRight = fXLLetterToNumber(Mid(MyRangeStr, iPoint2 + 1, iPoint3 - iPoint2 - 1))
    yBottom = Val(Mid(MyRangeStr, iPoint3 + 1, Len(MyRangeStr) - iPoint3))
    
    
End Sub


Public Function ConvertUmlaute(pString As String) As String

  Dim i As Integer
  Dim Ch As String * 1
  Dim Ch1 As String * 1
  Dim IsUpCase As Boolean
  Dim Res As String
  
  If IsNull(pString) Then ConvertUmlaute = Null: Exit Function
  Res = ""
  For i = 1 To Len(pString)
    Ch = Mid(pString, i, 1)
    Ch1 = IIf(i < Len(pString), Mid(pString, i + 1, 1), " ")
    
    ' next char is nor lcase
    IsUpCase = (Asc(Ch1) = Asc(UCase(Ch1)))
    Select Case Asc(Ch)
      Case Asc("|fffd|"): Res = Res & IIf(IsUpCase, "AE", "Ae")
      Case Asc("|fffd|"): Res = Res & IIf(IsUpCase, "OE", "Oe")
      Case Asc("|fffd|"): Res = Res & IIf(IsUpCase, "UE", "Ue")
      Case Asc("|fffd|"): Res = Res & "ae"
      Case Asc("|fffd|"): Res = Res & "oe"
      Case Asc("|fffd|"): Res = Res & "ue"
      Case Asc("|fffd|"): Res = Res & "ss"
      Case Else: Res = Res & Ch
    End Select
  Next i
  ConvertUmlaute = Res
 
End Function
Public Function FirstsBig(ByVal myStr As Variant) As String

    Dim i As Long
    Dim GoBig As Boolean
    
    myStr = LCase(myStr)
    
    For i = 1 To Len(myStr)
        GoBig = False
        If i = 1 Then GoBig = True
        If i > 1 Then
            If Mid(myStr, i - 1, 1) = " " Then GoBig = True
        End If
        If GoBig Then Mid(myStr, i, 1) = UCase(Mid(myStr, i, 1))
        FirstsBig = myStr
    Next i

End Function




Public Function GetPathNameOnly(FullPath As Variant) As String

    Dim StrFind As String
    Dim iCount As Long
    If IsNull(FullPath) Then
        GetPathNameOnly = ""
        Exit Function
    End If
    
    Do Until Left(StrFind, 1) = "\"
        iCount = iCount + 1
        StrFind = Right(FullPath, iCount)
        If iCount >= Len(FullPath) Then Exit Do
    Loop

    'GetFileNameOnly = Right(StrFind, Len(StrFind) - 1)
    GetPathNameOnly = Left(FullPath, Len(FullPath) - Len(StrFind) + 1)
End Function
Public Function NNDbl(myF As Object) As Variant
        If IsNull(myF) Then
            NNDbl = 0
        Else
            NNDbl = myF.Value
        End If
End Function
Public Function NnEofResistent(myF As Object, myrec As Object) As Variant

    NnEofResistent = ""
    If myrec.EOF Then
        Exit Function
    End If
    
    NnEofResistent = NNauto(myF)
    

End Function
Public Function NNauto(myF As Object) As Variant
    '* myF As DAO.Field
    
        If myF.Type = dbdate Then
            ' Date
            If IsNull(myF) Then
                NNauto = 0
            Else
                NNauto = Format$(myF.Value, "dd.mm.yyyy")
            End If
        ElseIf myF.Type = 202 Then  ' ADO Text
            If IsNull(myF) Then
                NNauto = ""
            Else
                NNauto = Trim$(myF.Value)
            End If
        Else                         ' 3,5 = ADO Number
            If IsNull(myF) Then
                NNauto = 0
            Else
                NNauto = myF.Value
            End If
        End If

End Function
Function NoSlash(MyPath As String) As String

    MyPath = Trim(MyPath)
    If Right(MyPath, 1) = "\" Then
        NoSlash = Left(MyPath, Len(MyPath) - 1)
    Else
        NoSlash = MyPath
    End If
    
    
End Function
Public Function NoSpaces(myStr As Variant) As String

    NoSpaces = Replace(myStr, " ", "")

End Function
Public Function NoSeparators(myStr As Variant) As String

    NoSeparators = Replace(myStr, " ", "_")

End Function

Public Function GetParam(ParamName As String) As Variant

    Const MaxCount As Single = 1000

    Dim ConfigRange As Range
    Dim Count As Single
    Dim GotIt As Boolean
    
    Set ConfigRange = ThisWorkbook.Worksheets(pcSheetname_FTPConfig).Range("B7:C" & CStr(MaxCount))
    

    GetParam = ""
    Count = 0
    GotIt = False

    While Not GotIt And Count < MaxCount
        Count = Count + 1
        If LCase(ConfigRange(Count, 1)) = LCase(ParamName) Then
            GetParam = ConfigRange(Count, 2)
            GotIt = True
        End If
    Wend
    
End Function

Public Function SetParam(ParamName As String, ParamValue As Variant)

    Const MaxCount As Single = 1000

    Dim ConfigRange As Range
    Dim Count As Single
    Dim GotIt As Boolean

    Set ConfigRange = ThisWorkbook.Worksheets(pcSheetname_FTPConfig).Range("B7:C" & CStr(MaxCount))

    Count = 0
    GotIt = False
    
    While Not GotIt And Count < MaxCount
        Count = Count + 1
        If LCase(ConfigRange(Count, 1)) = LCase(ParamName) Then
            ConfigRange(Count, 2) = ParamValue
            GotIt = True
        End If
    Wend
    
    Set ConfigRange = Nothing
    
End Function
Public Sub MoveToCell(Mycell As Object)

   Mycell.Copy
    
    Mycell.PasteSpecial _
        Paste:=xlPasteAll, _
        Operation:=xlNone, _
        SkipBlanks:=False, _
        Transpose:=False
    
    Application.CutCopyMode = False
End Sub
Public Sub RowCopyStdLine(DSTRange As Object, srcRange As Object)

    Const fvl_Name_Cell1 As String = "StdLine_Cell1"
    Const fvl_Name_Cell2 As String = "StdLine_Cell2"
    Const fvl_Name_Cell3 As String = "StdLine_Cell3"
    Const fvl_Name_Cell4ff As String = "StdLine_Cell4ff"
    
    '* Value
    '*DSTRange.Value = srcRange.Value
    
    '* Style
    DSTRange.Style = fvl_Name_Cell4ff
    DSTRange.Offset(0, 0).Resize(, 1).Style = fvl_Name_Cell1
    DSTRange.Offset(0, 1).Resize(, 1).Style = fvl_Name_Cell2
    DSTRange.Offset(0, 2).Resize(, 1).Style = fvl_Name_Cell3
    
    'Sum
    DSTRange.Offset(0, pcYearsToUse + 3).Resize(, 1).FormulaR1C1 = "=SUM(RC[-" & pcYearsToUse & "]:RC[-1])"
           

End Sub
Public Sub RowCopy(DSTRange As Object, srcRange As Object)

        
    ' Return office version No:
    ' 2010 = 14
    ' 2007 = 12
    ' 2003 = 11

    If Val(Application.Version) > 13 Then
        ' Off 2010 ff
        CopyMethod = 1
    Else
        ' office 2007,2003 or before
        CopyMethod = 2
    End If
    
    
    Select Case CopyMethod
            
        Case 1
            '******* Copy and merge conditional formats *******************
            ' **** This runs with Office 2010 ff ******
            ' copy template
            srcRange.Copy
            
            ' Paste Formats
            DSTRange.PasteSpecial _
                Paste:=xlPasteAllMergingConditionalFormats, _
                Operation:=xlNone, _
                SkipBlanks:=False, _
                Transpose:=False
                
            Application.CutCopyMode = False
        
        
        Case 2
            '****** default: Alternative 1
            ' **** This runs with Office 2007,2003  ******
            srcRange.Copy Destination:=DSTRange

    End Select
    
    
    
End Sub
Public Sub RowFormatCopy(DSTRange As Object, srcRange As Object)

    ' Format row like Template row
    Dim tt0 As Single
    Dim i As Long

    GoTo nejp2
    
    
    ' copy template
    srcRange.Copy
    
    ' Paste Formats
    DSTRange.PasteSpecial _
        Paste:=xlPasteFormats, _
        Operation:=xlNone, _
        SkipBlanks:=False, _
        Transpose:=False

    Application.CutCopyMode = False
    
    Exit Sub
    
    '***************************************
nejp1:


    Application.ScreenUpdating = False
    tt0 = Timer
    For i = 1 To 100
    
    DSTRange.Value = srcRange.Value
    DSTRange.Font.ColorIndex = srcRange.Font.ColorIndex
    DSTRange.Font.Bold = srcRange.Font.Bold
    'DSTRange.NumberFormat = srcRange.NumberFormat
    
    DSTRange.Borders(xlEdgeTop).LineStyle = srcRange.Borders(xlEdgeTop).LineStyle
    DSTRange.Borders(xlEdgeTop).ColorIndex = srcRange.Borders(xlEdgeTop).ColorIndex
    DSTRange.Borders(xlEdgeTop).TintAndShade = srcRange.Borders(xlEdgeTop).TintAndShade
    DSTRange.Borders(xlEdgeTop).Weight = srcRange.Borders(xlEdgeTop).Weight
    
    'DSTRange.Borders(2) = srcRange.Borders(2)
    'DSTRange.Borders(3) = srcRange.Borders(3)
    'DSTRange.Borders(4) = srcRange.Borders(4)
    
     With DSTRange.Interior
        .Pattern = srcRange.Interior.Pattern
        .PatternColorIndex = srcRange.Interior.PatternColorIndex
        .color = srcRange.Interior.color
        .TintAndShade = IIf(IsNull(srcRange.Interior.TintAndShade), 0, srcRange.Interior.TintAndShade)
        .PatternTintAndShade = srcRange.Interior.PatternTintAndShade
    End With
    
    
    Next i
    Debug.Print Timer - tt0
    Exit Sub
    
    
nejp2:

    Application.ScreenUpdating = False
    tt0 = Timer
    For i = 1 To 100
    
    DSTRange.Value = srcRange.Value
    DSTRange.Style = "Neutral"
    DSTRange.Style = "Gut"
    DSTRange.Style = "Neutral"
    DSTRange.Style = "Gut"
    
    
    Next i
    Debug.Print Timer - tt0
    Application.ScreenUpdating = True
    Exit Sub
    
    
    
    i = i
    
End Sub




Public Sub Work_Insert12Cols()
    Dim i As Long
    For i = 1 To 12
        Selection.EntireColumn.Insert
    Next i
End Sub
Public Function lT(strInput As Variant) As String
    lT = LCase(Trim(strInput))
End Function
Public Function NamedRange_Create(NameOfRange As String, strWorksheetName As String, strRangeString As String) As Boolean

    
    Dim xStr As String
    
    
    On Error Resume Next
    xStr = Application.Names(NameOfRange).Name
    If Err = 0 Then
        Application.Names(NameOfRange).Delete
    End If
    
    Application.Names.Add _
        Name:=NameOfRange, _
        RefersTo:="=" & strWorksheetName & "!" & strRangeString

    On Error GoTo 0
    
    
End Function

Public Function NamedRange_Delete(NameOfRange As String) As Boolean
    
    On Error Resume Next
    Application.Names(NameOfRange).Delete
    If Err = 0 Then NamedRange_Delete = True
     
    On Error GoTo 0
    
End Function
Public Sub CalcAndScreen(OnOff As Boolean)

    Static calModeOldValue As Long
    
    '****
    calModeOldValue = xlAutomatic
    '****

    If Not OnOff Then
        ' Off
        Application.ScreenUpdating = False
        calModeOldValue = Application.Calculation
        Application.Calculation = xlManual
        Application.EnableEvents = False
    Else
        ' On
        If calModeOldValue = xlManual Or calModeOldValue = xlAutomatic Then
            Application.Calculation = calModeOldValue
        Else
            Application.Calculation = xlAutomatic
        End If
        Application.EnableEvents = True
        Application.Calculate
        Application.ScreenUpdating = True
    End If
    
End Sub
Public Function ProtectWorkbook(Protect As Boolean) As Boolean

    If Protect Then
        ThisWorkbook.Protect Password:=pcPara_WorkBookpassword, Structure:=True, Windows:=False
    Else
        ThisWorkbook.Unprotect Password:=pcPara_WorkBookpassword
    End If
    
End Function
Public Function ProtectWS(Protect As Boolean, myWorksheet As Worksheet) As Boolean

    ' Protect / Unprotect Worksheet
    ' Worksheet must Exist !
    
Dim ScreenUpInValue As Long
Dim EventsInValue As Long


ScreenUpInValue = Application.ScreenUpdating
EventsInValue = Application.EnableEvents

If pcErrorOn Then On Error GoTo fnErr
    
   With myWorksheet
            Application.ScreenUpdating = False
            Application.EnableEvents = False
            '.Select
            .EnableOutlining = True
            
            If Protect Then
                    ' Standard Protect
                    .Protect _
                    Password:=pcPara_Worksheetpassword, _
                    DrawingObjects:=True, _
                    Contents:=True, _
                    Scenarios:=True, _
                    AllowFormattingCells:=False, _
                    AllowFormattingColumns:=False, _
                    AllowFormattingRows:=False, _
                    AllowInsertingColumns:=False, _
                    AllowInsertingRows:=False, _
                    AllowInsertingHyperlinks:=False, _
                    AllowDeletingColumns:=False, _
                    AllowDeletingRows:=False, _
                    AllowSorting:=False, _
                    AllowFiltering:=False, _
                    AllowUsingPivotTables:=False, _
                    UserInterfaceOnly:=True
                    .EnableSelection = xlNoRestrictions
            Else
               .Unprotect Password:=pcPara_Worksheetpassword
            End If

   End With
    
    
    ProtectWS = True
fnOut:
    On Error Resume Next
    Application.ScreenUpdating = ScreenUpInValue
    Application.EnableEvents = EventsInValue

    On Error GoTo 0
    Exit Function

fnErr:
    '* ErrorHandler.TriggerError "Tools\ProtectWS", , 55
    Debug.Print "Error: " & Err & " - Tools\ProtectWS"
    Resume fnOut
    
End Function
Public Function NamedRangeExists(RangeName As String, myParentObject As Object) As Boolean

    Dim xRange As Range

    On Error Resume Next

    Set xRange = myParentObject.Range(RangeName)

    If (Not Err = 0) Or xRange Is Nothing Then
        NamedRangeExists = False
    Else
        NamedRangeExists = True
    End If
    Set xRange = Nothing
    On Error GoTo 0

End Function

Public Function ItemExists(Itemname As String, myCol As Object) As Boolean

    Dim wBook As Object

    On Error Resume Next

    Set wBook = myCol(Itemname)

    If (Not Err = 0) Or wBook Is Nothing Then 'Not open
        ItemExists = False
    Else 'It is open
        ItemExists = True
    End If
    Set wBook = Nothing
    On Error GoTo 0

End Function
Public Sub ButtonVisible(ButtonName As String, WSname As String, SwitchOn As Boolean, Optional AllButtons As Boolean = False, Optional CommentCellRow As Long, Optional CommentCellColumn As Long)

    If pcErrorOn Then On Error GoTo fnErr
    Dim iObj As Object
    
    If AllButtons Then
        For Each iObj In ThisWorkbook.Worksheets(WSname).Shapes
            iObj.Visible = SwitchOn
        Next
        For Each iObj In ThisWorkbook.Worksheets(WSname).Comments
            iObj.Shape.Height = IIf(SwitchOn, 15, 0)
            iObj.Visible = False
        Next
        
    Else
        ThisWorkbook.Worksheets(WSname).Shapes.Range(Array(ButtonName)).Visible = SwitchOn
        If CommentCellRow > 0 And CommentCellColumn > 0 Then
            ThisWorkbook.Worksheets(WSname).Cells(CommentCellRow, CommentCellColumn).Comment.Shape.Height = IIf(SwitchOn, 15, 0)
            ThisWorkbook.Worksheets(WSname).Cells(CommentCellRow, CommentCellColumn).Comment.Visible = False
        End If
        
    End If
        
    
fnOut:
    On Error Resume Next
    Set iObj = Nothing
    
    On Error GoTo 0
    Exit Sub

fnErr:
    '* ErrorHandler.TriggerError "Tools\ButtonVisible", , 45
    Debug.Print "Error: " & Err & " - Tools\ButtonVisible"
    Resume fnOut
End Sub


Public Function FilenameReplaceInvalidChars(strFilename As String, Optional strRepChar As String) As String
     
     'Deklaration
     Dim strOutput As String
     Dim strSpecChar As String
     Dim strChar As String
     
     Dim i As Integer
     Dim imax As Integer
     
     'Init
     strOutput = ""
     strSpecChar = "/\:*?<>"
     imax = Len(strFilename)
     If IsMissing(strRepChar) Then strRepChar = ""
     
     For i = 1 To imax
         strChar = Mid(strFilename, i, 1)
         If InStr(1, strSpecChar, strChar) > 0 Then
             strChar = strRepChar
         End If
         strOutput = strOutput & strChar
     Next i
     
     FilenameReplaceInvalidChars = strOutput
     
End Function

Public Sub SetFooterLayot(myWS As Worksheet, Optional LeftFooter As Variant, Optional CenterFooter As Variant, Optional RightFooter As Variant)

    '* Set Footer of Worksheet
    
    'Application.PrintCommunication = False
    With myWS.PageSetup
        '* .LeftHeader = ""
        '* .CenterHeader = ""
        '* .RightHeader = ""
        
        If Not IsMissing(LeftFooter) Then .LeftFooter = LeftFooter
        If Not IsMissing(CenterFooter) Then .CenterFooter = CenterFooter
        If Not IsMissing(RightFooter) Then .RightFooter = RightFooter
        
    End With
    DoEvents
    'Application.PrintCommunication = True
End Sub
Public Sub DeleteXLSLine(myWS As Worksheet, LineNo As Long)

    myWS.Rows(LineNo).Delete Shift:=xlUp
    
End Sub

Public Function fnTemplate(Mycell As Object, myListRange As Range) As Boolean

    If pcErrorOn Then On Error GoTo fnErr
    
    
    fnTemplate = True
fnOut:
    On Error Resume Next
    
    On Error GoTo 0
    Exit Function

fnErr:
    '*ErrorHandler.TriggerError "xx\xx", , 55
    Debug.Print "Error: " & Err & " - Tools\fntemplate"
    Resume fnOut
End Function
Public Function Get1000Seperator() As String
    Dim myStr As String
    myStr = Format(1000, "#,###")
    Get1000Seperator = Mid(myStr, 2, 1)
End Function
Public Function GetDecimalSeperator() As String
    Dim myStr As String
    myStr = Format(1, "0.0")
    GetDecimalSeperator = Mid(myStr, 2, 1)
End Function
Public Function ValueAllCountries(ByVal myVal As String) As Double

    Dim decSep As String
    Dim tauSep As String
    decSep = GetDecimalSeperator()
    tauSep = Get1000Seperator()
    
    myVal = Replace(myVal, tauSep, "")
    myVal = Replace(myVal, decSep, ".")
    
    ValueAllCountries = 0
    On Error Resume Next
    ValueAllCountries = CDbl(myVal)
    On Error GoTo 0
    
    'If IsNumeric(myVal) Then
    '    ValueAllCountries = Val(myVal)
    'Else
    '    ValueAllCountries = 0
    'End If
     
End Function
Public Sub SortCombobox(myCombo As ComboBox)

    Dim iRowBack As Long
    Dim iRow As Long
    Dim sTemp As String


    '** Sort as filled combobox

    For iRow = 0 To myCombo.ListCount - 1
        For iRowBack = 0 To iRow - 1
            If myCombo.List(iRowBack) > myCombo.List(iRow) Then
                sTemp = myCombo.List(iRowBack)
                myCombo.List(iRowBack) = myCombo.List(iRow)
                myCombo.List(iRow) = sTemp
            End If
        Next iRowBack
    Next iRow

End Sub

Public Function ShowSystemDateFormat() As String

    Dim myDate As String
    myDate = Format(DateSerial(3333, 10, 22), "Short Date")
    myDate = Replace(myDate, "3", "Y")
    myDate = Replace(myDate, "2", "D")
    myDate = Replace(myDate, "1", "M")
    myDate = Replace(myDate, "0", "M")
    ShowSystemDateFormat = myDate
    
End Function

Public Function DateOrNix(myDate As Variant) As Date

    If IsDate(myDate) Then
        DateOrNix = CDate(myDate)
    Else
        DateOrNix = 0
    End If
    
End Function
Attribute VB_Name = "XLSTools"
Option Explicit



Public Sub UnProtectSelection()
    
    Selection.Locked = False
    Selection.FormulaHidden = False

End Sub
Public Sub ProtectSelection()
    
    Selection.Locked = True
    Selection.FormulaHidden = False

End Sub

Public Sub PrintRangeSet(WSname As String)

    Dim Lastline As Long

    Select Case WSname
        Case pcWSName_Summary
            Lastline = Application.Range("nrNextFreeRow").Value - 1
            If Lastline < 6 Then Lastline = 6
            ThisWorkbook.Worksheets(WSname).PageSetup.PrintArea = "$B$1:$K$" & Lastline
       
    End Select
    
xout:
    

End Sub
Attribute VB_Name = "ZZZ_Develop"
Option Explicit






































































Private Sub declarations()
    ' just dummy
End Sub
Public Sub WorkbookToUserMode()
    '------------------------------
    '---- Workbook to User Mode
    '------------------------------
    
    UNProtectAll
    HideSystemSheets True
    HideAllHidden True
    ProtectAll
    
End Sub

Public Sub WorkbookToDevelopMode()
    '------------------------------
    '---- Workbook to Develop Mode
    '------------------------------

    UNProtectAll
    HideSystemSheets False
    
    
End Sub
Public Sub ProtectAll()
    
    With ThisWorkbook
        ProtectWS True, .Worksheets(pcWSName_Cover)
        ProtectWS True, .Worksheets(pcWSName_Summary)
        ProtectWS True, .Worksheets(pcWSName_Index)
        'ProtectWS True, .Worksheets(pcWSName_PrintLayout)
        'ProtectWS True, .Worksheets(pcWSName_Transfer)
        'ProtectWS True, .Worksheets(pcWSName_Storage)
        'ProtectWS True, .Worksheets(pcWSName_Deka)
        
        ProtectWorkbook True
    End With

End Sub
Public Sub UNProtectAll()

    With ThisWorkbook
        ProtectWorkbook False
        
        ProtectWS False, .Worksheets(pcWSName_Cover)
        ProtectWS False, .Worksheets(pcWSName_Summary)
        ProtectWS False, .Worksheets(pcWSName_Index)
        
        ProtectWS False, .Worksheets(pcWSName_PrintLayout)
        ProtectWS False, .Worksheets(pcWSName_Transfer)
        ProtectWS False, .Worksheets(pcWSName_Storage)
        ProtectWS False, .Worksheets(pcWSName_Deka)
        
    End With
    
End Sub
Public Sub HideSystemSheets(Hide As Boolean)
    
    ' Normal Hidden
    ThisWorkbook.Worksheets(pcWSName_PrintLayout).Visible = Not Hide
    ThisWorkbook.Worksheets(pcWSName_Index).Visible = Not Hide

    'Very hidden
    ThisWorkbook.Worksheets(pcWSName_Transfer).Visible = IIf(Hide, xlVeryHidden, True)
    ThisWorkbook.Worksheets(pcWSName_Storage).Visible = IIf(Hide, xlVeryHidden, True)
    ThisWorkbook.Worksheets(pcWSName_Deka).Visible = IIf(Hide, xlVeryHidden, True)
    ThisWorkbook.Worksheets(pcWSName_VersionLog).Visible = IIf(Hide, xlVeryHidden, True)
    
    ' only if they exist
    If WorkSheetExists("Unused Anlagen-Karte") Then
        ThisWorkbook.Worksheets("Unused Anlagen-Karte").Visible = IIf(Hide, xlVeryHidden, True)
    End If
    If WorkSheetExists("Unused Status Anlagen") Then
        ThisWorkbook.Worksheets("Unused Status Anlagen").Visible = IIf(Hide, xlVeryHidden, True)
    End If
    
End Sub



Public Sub HideAllHidden(Hide As Boolean)

    ' Summary Sheet
    With ThisWorkbook.Worksheets(pcWSName_Summary)
        .Rows("8:8").Hidden = Hide
        .Columns("R:Z").Hidden = Hide
    End With
    
End Sub

Public Sub ResetCoversheetDropdowns()

    With ThisWorkbook.Worksheets(pcWSName_Cover)
        .Cells(6, 2).Value = "Enter SAP No."
        .Cells(7, 2).Value = "Enter property name"
        
        .Cells(12, 2).Value = "SELECT NAME OF DEKA FUND"
        .Cells(13, 2).Value = "DIRECTLY / SPV STRUCTURE"
        .Cells(19, 2).Value = "SELECT CURRENCY"
        
        .Cells(15, 2).Value = "" ' Fiscal Year
        
    End With

End Sub
Attribute VB_Name = "clsConstructionItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public StorageID As Long
Public ElementID As Long
Public Status As Long

Public Category As String
Public CategoryCode As String
Public Construction As String
Public Description As String
Public WarrantyEnd As Date
Public Warranty As Boolean

Public ServiceRequired As Date
Public ServiceDone As Date
Public ServiceNext As Date
Public DefectNoticed As Date
Public Defects As Boolean

Public ServiceDescription As String
Public ServiceComment As String
Public DefectDescription As String
Public DefectComment As String
Public WarrantyComment As String

Public InstallationPart As String





Attribute VB_Name = "clsMain"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'* Const
Const lcWSName_Storage As String = "Storage"
Const lcWSName_Transfer As String = "TransferForm"
Const lcWSName_TGAElements As String = "Index"
Const lcWSName_PrintLayout As String = "PrintLayout"


'* Public
Public TGAElements As Collection

'* Private
Private lcWSStorage As Worksheet
Private lcWSTransfer As Worksheet
Private lcWSPrintLayout As Worksheet



Private Sub Class_Initialize()

    '**  get Storage Sheet
    Set lcWSStorage = ThisWorkbook.Worksheets(lcWSName_Storage)
    Set lcWSTransfer = ThisWorkbook.Worksheets(lcWSName_Transfer)
    Set lcWSPrintLayout = ThisWorkbook.Worksheets(lcWSName_PrintLayout)

    GetTGAElementsToCollection
        
    
End Sub

Private Sub Class_Terminate()

    ' ***** Cleanup
    Set lcWSStorage = Nothing
    Set lcWSTransfer = Nothing
    Set lcWSPrintLayout = Nothing
    
    Set TGAElements = Nothing
    
End Sub

Private Sub GetTGAElementsToCollection()

    '*****************************************
    '** read TGA Elemenst from Worksheet to Collection
    '*****************************************
    
    Dim iLine As Long
    Dim iEmpty As Long
    Dim ColVals As Variant
    
    Dim LastCode As String
    Dim LastCat As String
    Dim LastCon As String
    Dim Element As String
    Dim ElementID As Long
    
    Dim myItm As clsTGAElement
    
    ' Clear it
    Set TGAElements = Nothing
    Set TGAElements = New Collection
    
    With ThisWorkbook.Worksheets(lcWSName_TGAElements)
    
        iLine = 3
        Do
            iLine = iLine + 1
            ColVals = .Range(.Cells(iLine, 1), .Cells(iLine, 5))
            If Trim(ColVals(1, 1) & ColVals(1, 2) & ColVals(1, 3) & ColVals(1, 4)) = "" Then
                iEmpty = iEmpty + 1
            Else
                iEmpty = 0
            End If
            
            If Not Trim(ColVals(1, 1)) = "" Then LastCode = Trim(ColVals(1, 1))
            If Not Trim(ColVals(1, 2)) = "" Then LastCat = Trim(ColVals(1, 2))
            If Not Trim(ColVals(1, 3)) = "" Then LastCon = Trim(ColVals(1, 3))
            Element = Trim(ColVals(1, 4))
            ElementID = 0
            
            If Not Element = "" Then
                Set myItm = New clsTGAElement
                myItm.Code = LastCode
                myItm.Category = LastCat
                myItm.Construction = LastCon
                myItm.Element = Element
                myItm.ID = ElementID
                myItm.Key = iLine
                myItm.SRCLineNo = iLine
                TGAElements.Add myItm, myItm.Key
                Set myItm = Nothing
                
            End If
            
        Loop While iEmpty < 20
    
    End With
    
    
End Sub

Private Property Get NextFreeLineNo() As Long
    '*****************************************
    '** get next free Line No
    '*****************************************
    NextFreeLineNo = lcWSStorage.Range("nrlNextFreeLine").Value
    
End Property



Public Sub ReferTransferSheet(ID As Long)

    '*****************************************
    '** Refer dataset from Storage to Transfer
    '*****************************************
    Dim StorageRow As Long
    StorageRow = StorageRowFromID(ID)

        
    lcWSTransfer.Range("nrActStorageRow").Value = StorageRow
        
    
End Sub

Public Sub DeleteFromStorage(ID As Long)

    '**************************************
    '* delete line from storage
    '**************************************
    Dim StorageRow As Long
    StorageRow = StorageRowFromID(ID)
    
    If Not StorageRow = 0 Then
        lcWSStorage.Rows(StorageRow).Delete Shift:=xlUp
    End If
    
End Sub

Public Function AddLineToStorage() As Long

    '**************************************
    '* Add line to storage, return ID
    '**************************************
    Dim NewID As Long
    Dim NewRow As Long
    NewID = lcWSStorage.Range("nrlNextFreeId").Value
    NewRow = lcWSStorage.Range("nrlNextFreeLine").Value
        
    lcWSStorage.Cells(NewRow, 2).Value = 1
    lcWSStorage.Cells(NewRow, 1).Value = NewID
    lcWSStorage.Cells(NewRow, 3).FormulaR1C1 = "=IF(RC[7]<RC[8],1,0)"
    
    AddLineToStorage = NewID

End Function

Public Property Get ConstructionElement(StorageID As Long) As clsConstructionItem

    Dim StorageRow As Long
    StorageRow = StorageRowFromID(StorageID)

    With lcWSStorage
        Set ConstructionElement = New clsConstructionItem
        
        ConstructionElement.StorageID = StorageID
        ConstructionElement.ElementID = .Cells(StorageRow, 19)
        ConstructionElement.Status = .Cells(StorageRow, 3)
        
        ConstructionElement.Category = .Cells(StorageRow, 4)
        ConstructionElement.CategoryCode = .Cells(StorageRow, 21)
        ConstructionElement.Construction = .Cells(StorageRow, 5)
        ConstructionElement.Description = .Cells(StorageRow, 6)
        ConstructionElement.WarrantyEnd = .Cells(StorageRow, 7)
        ConstructionElement.Warranty = .Cells(StorageRow, 8)
        ConstructionElement.ServiceRequired = .Cells(StorageRow, 10)
        ConstructionElement.ServiceDone = .Cells(StorageRow, 11)
        ConstructionElement.ServiceNext = .Cells(StorageRow, 12)
        ConstructionElement.DefectNoticed = .Cells(StorageRow, 13)
        ConstructionElement.Defects = .Cells(StorageRow, 20)
        ConstructionElement.ServiceDescription = .Cells(StorageRow, 15)
        ConstructionElement.ServiceComment = .Cells(StorageRow, 16)
        ConstructionElement.DefectDescription = .Cells(StorageRow, 17)
        ConstructionElement.DefectComment = .Cells(StorageRow, 18)
        ConstructionElement.WarrantyComment = .Cells(StorageRow, 22)
        ConstructionElement.InstallationPart = .Cells(StorageRow, 23)
    End With
    
End Property
Public Property Set ConstructionElement(StorageID As Long, ConstructionElement As clsConstructionItem)

    Dim StorageRow As Long

    With lcWSStorage
                
        If StorageID = 0 Then
            ' new Elemenet
            StorageID = AddLineToStorage()
            ConstructionElement.StorageID = StorageID
        End If
            
        StorageRow = StorageRowFromID(StorageID)
       
        .Cells(StorageRow, 4) = ConstructionElement.Category
        .Cells(StorageRow, 21) = ConstructionElement.CategoryCode
        .Cells(StorageRow, 5) = ConstructionElement.Construction
        .Cells(StorageRow, 6) = ConstructionElement.Description
        .Cells(StorageRow, 7) = ConstructionElement.WarrantyEnd
        .Cells(StorageRow, 8) = ConstructionElement.Warranty
        .Cells(StorageRow, 10) = ConstructionElement.ServiceRequired
        .Cells(StorageRow, 11) = ConstructionElement.ServiceDone
        .Cells(StorageRow, 12) = ConstructionElement.ServiceNext
        .Cells(StorageRow, 13) = ConstructionElement.DefectNoticed
        .Cells(StorageRow, 15) = ConstructionElement.ServiceDescription
        .Cells(StorageRow, 16) = ConstructionElement.ServiceComment
        .Cells(StorageRow, 17) = ConstructionElement.DefectDescription
        .Cells(StorageRow, 18) = ConstructionElement.DefectComment
        .Cells(StorageRow, 20) = ConstructionElement.Defects
        .Cells(StorageRow, 22) = ConstructionElement.WarrantyComment
        .Cells(StorageRow, 23) = ConstructionElement.InstallationPart
        
    End With
    
End Property


Public Property Get TGAElementBoxConstruction(Category As String, myCbx As ComboBox) As Boolean
    
    Dim TGAElement As clsTGAElement
    
    Dim LastCon As String
        
    myCbx.Clear
    
    LastCon = ""
    For Each TGAElement In TGAElements
        If Category = TGAElement.Category And LastCon <> TGAElement.Construction Then
            myCbx.AddItem TGAElement.Construction
            LastCon = TGAElement.Construction
        End If
        
    Next
    
    TGAElementBoxConstruction = True

End Property
Public Property Get TGAElementBoxCategory(myCombo As ComboBox) As Boolean
    
    Dim TGAElement As clsTGAElement
    Dim LastCat As String
    
    'Set TGAElementBoxCategoryXXX = myCombo
        
    myCombo.Clear
    
    LastCat = ""
    For Each TGAElement In TGAElements
        If Not LastCat = TGAElement.Category Then
            myCombo.AddItem TGAElement.Code
            myCombo.List(myCombo.ListCount - 1, 1) = TGAElement.Category
            LastCat = TGAElement.Category
        End If
    Next
    
    TGAElementBoxCategory = True

End Property

Public Property Get TGAElementsAdd(myCombo As ListBox) As Boolean

    '*** give handle of an 5 Column Listbox
    
    Dim TGAElement As clsTGAElement
    Dim LastCat As String
    
    Dim iIndex As Long
    
    
        
    myCombo.Clear
    
    LastCat = ""
    For Each TGAElement In TGAElements
        If Not LastCat = TGAElement.Category Then
            myCombo.AddItem TGAElement.ID
            iIndex = myCombo.ListCount - 1
            myCombo.Column(1, iIndex).Value = TGAElement.Code
            myCombo.Column(2, iIndex).Value = TGAElement.Category
            myCombo.Column(3, iIndex).Value = TGAElement.Construction
            myCombo.Column(4, iIndex).Value = TGAElement.Element
        End If
    Next
    
    TGAElementsAdd = True

End Property
Private Function StorageRowFromID(StorageID As Long) As Long
    ' *********************
    ' get Storage row no from Storage ID no
    ' *********************
    
    Dim SeekRange As Range
    Dim xFound As Range
    
    Set SeekRange = lcWSStorage.Range(lcWSStorage.Cells(11, 1), lcWSStorage.Cells(5000, 1))
    
    Set xFound = SeekRange.Find(StorageID, , , xlWhole, xlByColumns)
    If xFound Is Nothing Then
        Exit Function
    End If
    
    StorageRowFromID = xFound.Row
    
End Function
Public Function SystemPrint(ID As Long, Optional DisableScreenupdating As Boolean = False, Optional optShowPrinterDialog As Boolean = True)

    '*************************
    ' *** Get from storage to transfer and print it in Layout Sheet
    '*************************
    
    
    Dim WBwasProtected As Boolean
    Dim WSwasVisible As Boolean
    
    '... select printer
    If optShowPrinterDialog Then
        If Not ShowPrinterDialog() Then
            Exit Function
        End If
    End If
    
    If DisableScreenupdating Then Application.ScreenUpdating = False
    
    ReferTransferSheet ID
    
    WSwasVisible = ThisWorkbook.Worksheets(pcWSName_PrintLayout).Visible
    WBwasProtected = ThisWorkbook.ProtectStructure
    ProtectWorkbook False
    
    ThisWorkbook.Worksheets(pcWSName_PrintLayout).Visible = True
    lcWSPrintLayout.PrintOut Copies:=1, Collate:=True, IgnorePrintAreas:=False
    ThisWorkbook.Worksheets(pcWSName_PrintLayout).Visible = WSwasVisible
    
    If WBwasProtected Then ProtectWorkbook True
    
    If DisableScreenupdating Then Application.ScreenUpdating = True
    
End Function
Attribute VB_Name = "clsTGAElement"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Key As String
Public Code As Long
Public Category As String
Public Construction As String
Public Element As String
Public InstallationPart As String
Public ID As Long


Public SRCLineNo As Long
Attribute VB_Name = "frmConstruction"
Attribute VB_Base = "0{B0E9E233-E9D1-4E47-953F-2A0A3F6FB039}{82A69AD5-380E-48CE-803B-BE3479A00077}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public EditId As Long
Public myM As New clsMain

Private Sub cbxcategory_Click()
    Dim bRet As Boolean
    
    If cbxcategory.ListIndex = -1 Then Exit Sub
    
    cbxConstruction.ListIndex = -1
    txtIParts.Text = ""
    bRet = myM.TGAElementBoxConstruction(cbxcategory, cbxConstruction)
    
    
End Sub

Private Sub cbxConstruction_Change()
    txtIParts.Text = ""
End Sub

Private Sub cmdCancel_Click()
    Me.Hide
End Sub

Private Sub cmdOK_Click()

    '*******************
    '** Ok was clicked
    '*******************
    Dim AllOk As Boolean
    Dim AllOkDefects As Boolean
    Dim AllOkInspection As Boolean
    Dim AllOkWarranty As Boolean
    
    '.. perform checks
    AllOk = True
    MarkupObject txtServiceDateNext, False
    MarkupObject cbxcategory, Trim(cbxcategory.Value) = "", AllOk
    MarkupObject cbxConstruction, Trim(cbxConstruction.Value) = "", AllOk
    
    ' Defects
    AllOkDefects = True
    If Not Trim(txtDefectsDateNoticed.Value) = "" Then
        MarkupObject txtDefectsDateNoticed, Not IsDate(txtDefectsDateNoticed.Value), AllOk, AllOkDefects
    Else
        MarkupObject txtDefectsDateNoticed, False
    End If
    
    ' Inspection
    AllOkInspection = True
    If Not Trim(txtServiceDateRequired.Value) = "" Then
        MarkupObject txtServiceDateRequired, Not IsDate(txtServiceDateRequired.Value), AllOk, AllOkInspection
    Else
        MarkupObject txtServiceDateRequired, False
    End If
    If Not Trim(txtServiceDateDone.Value) = "" Then
        MarkupObject txtServiceDateDone, Not IsDate(txtServiceDateDone.Value), AllOk, AllOkInspection
    Else
        MarkupObject txtServiceDateDone, False
    End If
    If Not Trim(txtServiceDateNext.Value) = "" Then
        MarkupObject txtServiceDateNext, Not IsDate(txtServiceDateNext.Value), AllOk, AllOkInspection
    Else
        MarkupObject txtServiceDateNext, False
    End If
        
    If Trim(txtServiceDateRequired.Value) <> "" And Trim(txtServiceDateNext.Value) <> "" Then
        ' Next>Required
        If IsDate(txtServiceDateRequired.Value) And IsDate(txtServiceDateNext.Value) Then
            MarkupObject txtServiceDateNext, CDate(txtServiceDateNext.Value) <= CDate(txtServiceDateRequired.Value), AllOk, AllOkInspection
        End If
    End If

    
    ' Warranty
    AllOkWarranty = True
    If Not Trim(txtWarrantyEnd.Value) = "" Then
        MarkupObject txtWarrantyEnd, Not IsDate(txtWarrantyEnd.Value), AllOk, AllOkWarranty
    Else
        MarkupObject txtWarrantyEnd, False
    End If
    
    '*** Switch to first Page with error
    If Not AllOkWarranty Then
        MultiPage1.Value = 3
    ElseIf Not AllOkInspection Then
        MultiPage1.Value = 1
    ElseIf Not AllOkDefects Then
        MultiPage1.Value = 2
    End If
    
    
    If Not AllOk Then
        MsgBox "Please check the input fields marked in red !", vbExclamation + vbOKOnly
        Exit Sub
    End If
    
    '... save Data
    SaveData
    
    '.. close form
    Me.Hide
    
End Sub


Private Sub LstIndex_DblClick(ByVal Cancel As MSForms.ReturnBoolean)

    ' Index was double clicked.
    ' try to find Category and system for the clicked line
    
    Dim iIdx As Long
    Dim i As Long
    
    Dim strCategory As String
    Dim strSystem As String
    
    
    If LstIndex.ListIndex = -1 Then Exit Sub
    iIdx = LstIndex.ListIndex
    If Trim(LstIndex.List(iIdx, 3)) = "" Then
        ' this line is empty
        Exit Sub
    End If

    For i = iIdx To 0 Step -1
        If Not Trim(LstIndex.List(i, 2)) = "" Then
            strSystem = LstIndex.List(i, 2)
            Exit For
        End If
    Next i
    
    For i = iIdx To 0 Step -1
        If Not Trim(LstIndex.List(i, 1)) = "" Then
            strCategory = LstIndex.List(i, 1)
            Exit For
        End If
    Next i
    
    If strSystem <> "" And strCategory <> "" Then
        ' both found, set listsboxed
        cbxcategory.Value = strCategory
        cbxConstruction.Value = strSystem
        txtIParts.Text = LstIndex.List(iIdx, 3)
    End If



End Sub

Private Sub ToggleButton1_Click()
    If ToggleButton1.Value Then
        MultiPage1.Pages("pgIndex").Visible = True
        MultiPage1.Value = MultiPage1.Pages("pgIndex").Index
    Else
        MultiPage1.Pages("pgIndex").Visible = False
    End If
End Sub

Private Sub txtServiceDateDone_Change()
    UpdateStatus
End Sub

Private Sub txtServiceDateRequired_Change()
    UpdateStatus
End Sub

Private Sub UserForm_Activate()
    
    ' hide index sheet
    MultiPage1.Pages("pgIndex").Visible = False
    
    ' Load data
    LoadData
    cbxcategory.SetFocus
    
End Sub

Private Sub UserForm_Initialize()
    
    Dim bRet As Boolean
    bRet = myM.TGAElementBoxCategory(cbxcategory)
    
    '** set to first Page
    MultiPage1.Value = 0
    
    '*** Fill Index Sheet
    ' lstIndex is filled with direct connection:
    ' lstIndex.Rowsource=nrIndexData
    
    '** Date hints
    lblDateHint1.Caption = "[" & ShowSystemDateFormat & "]"
    lblDateHint2.Caption = "[" & ShowSystemDateFormat & "]"
    lblDateHint3.Caption = "[" & ShowSystemDateFormat & "]"
    lblDateHint4.Caption = "[" & ShowSystemDateFormat & "]"
    lblDateHint5.Caption = "[" & ShowSystemDateFormat & "]"
    
    
    
End Sub
Private Sub UserForm_Terminate()
    Set myM = Nothing
End Sub


Public Sub LoadData()
    '**********************************
    '** Load Data block from Storage
    '**********************************
      
    Dim myCE As clsConstructionItem
    
    If EditId > 0 Then
        ' *** Edit
        Set myCE = myM.ConstructionElement(EditId)
        
        On Error Resume Next
        cbxcategory.Value = myCE.Category
        cbxConstruction.Value = myCE.Construction
        txtIParts.Text = myCE.InstallationPart
        On Error GoTo 0
                
        '... Status
        lblStatus.BackColor = IIf(myCE.Status = 0, &HFFFFFF, &HFF&)
        lblStatus.Caption = IIf(myCE.Status = 0, "OK", "Red")
        
        '...Description
        txtConstructionDescription.Text = myCE.Description
        
        '...Warranty
        txtWarrantyEnd.Text = NoZeroDates(myCE.WarrantyEnd)
        cbxWarranty.Value = myCE.Warranty
        txtWarrantyComment.Text = myCE.WarrantyComment
        
        '...Service
        txtServiceDescription.Text = myCE.ServiceDescription
        txtServiceComment.Text = myCE.ServiceComment
        
        txtServiceDateRequired.Text = NoZeroDates(myCE.ServiceRequired)
        txtServiceDateDone.Text = NoZeroDates(myCE.ServiceDone)
        txtServiceDateNext.Text = NoZeroDates(myCE.ServiceNext)
        
        '...Defects
        cbxDefects.Value = myCE.Defects
        txtDefectsDescription.Text = myCE.DefectDescription
        txtDefectsComment.Text = myCE.DefectComment
        txtDefectsDateNoticed.Text = NoZeroDates(myCE.DefectNoticed)
        
        Set myCE = Nothing
    
    Else
        ' *** New Item
        
    End If
    

End Sub

Public Sub SaveData()
    '**********************************
    '** Save Data block to Storage
    '**********************************
    
    Dim myCE As New clsConstructionItem
    Dim NextFreeLine As Long
    
    If EditId > 0 Then
        ' *** Edit
        myCE.StorageID = EditId
    Else
        ' *** New Item
        myCE.StorageID = 0
    End If
    
    myCE.Category = cbxcategory.Value
    If Not cbxcategory.ListIndex = -1 Then
        myCE.CategoryCode = cbxcategory.List(cbxcategory.ListIndex, 0)
    End If
    myCE.Construction = cbxConstruction.Value
    myCE.InstallationPart = txtIParts.Text
    
    '...Description
    myCE.Description = txtConstructionDescription.Text
    
    '...Warranty
    myCE.WarrantyEnd = DateOrNix(txtWarrantyEnd.Text)
    myCE.Warranty = IIf(cbxWarranty.Value, -1, 0)
    myCE.WarrantyComment = txtWarrantyComment.Text
    
    '...Service
    myCE.ServiceDescription = txtServiceDescription.Text
    myCE.ServiceComment = txtServiceComment.Text
    myCE.ServiceRequired = DateOrNix(txtServiceDateRequired.Text)
    myCE.ServiceDone = DateOrNix(txtServiceDateDone.Text)
    myCE.ServiceNext = DateOrNix(txtServiceDateNext.Text)
    
    '...Defects
    myCE.Defects = IIf(cbxDefects.Value, -1, 0)
    myCE.DefectDescription = txtDefectsDescription.Text
    myCE.DefectComment = txtDefectsComment.Text
    myCE.DefectNoticed = DateOrNix(txtDefectsDateNoticed.Text)
    
    Set myM.ConstructionElement(myCE.StorageID) = myCE
    
    If EditId = 0 Then
        ' add new line to Summary Sheet.
        ' StorageID is stored in myCE.StorageID
        Application.ScreenUpdating = False
        With ThisWorkbook.Worksheets(pcWSName_Summary)
            .Activate
            NextFreeLine = Application.Range("nrNextFreeRow").Value
            
            ProtectWS False, ThisWorkbook.Worksheets(pcWSName_Summary)
            
            RowCopy .Range(.Rows(NextFreeLine), .Rows(NextFreeLine)), _
                    .Range(.Rows(pcWSPara_Summary_TemplateRow), .Rows(pcWSPara_Summary_TemplateRow))
                    
            ' unhide it
            
            .Range(.Rows(NextFreeLine), .Rows(NextFreeLine)).Hidden = False
            ProtectWS True, ThisWorkbook.Worksheets(pcWSName_Summary)
            
            ' Fill in ID
            .Cells(NextFreeLine, pcWSPara_Summary_IDCol).Value = myCE.StorageID
            
            ' set print range
            PrintRangeSet pcWSName_Summary
        End With
        Application.ScreenUpdating = True
        
    End If
    
    Set myCE = Nothing
    

End Sub

Private Sub UpdateStatus()


    Dim StatusWasSet As Boolean
    Dim NewStatus As Long
    
    If IsDate(txtServiceDateRequired.Text) And IsDate(txtServiceDateDone.Text) Then
        StatusWasSet = True
        NewStatus = CDate(txtServiceDateRequired.Text) < CDate(txtServiceDateDone.Text)
    End If

    ' only if status was calculated
    If StatusWasSet Then
        lblStatus.BackColor = IIf(NewStatus = 0, &HFFFFFF, &HFF&)
        lblStatus.Caption = IIf(NewStatus = 0, "OK", "Red")
    End If
    
End Sub
Attribute VB_Name = "frmSort"
Attribute VB_Base = "0{1BF3F82F-3053-4706-AB95-3909061E6545}{E8D8A8B5-61EA-4EA9-9A77-2088A71D38E9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub UserForm_Activate()

    If Val(Application.Version) > 11 Then
        ' Off 2007 ff
    Else
        ' office 2003 or before
        Label144.Visible = False
        cbxSort3.Visible = False
        cbxOrder3.Visible = False
    End If
    
End Sub

Private Sub cmdCancel_Click()
    Me.Hide
    Unload Me
End Sub

Private Sub cmdSort_Click()

    Dim DataRange As Range
    Dim NextFreeLine As Long
    
    Dim Sort(1 To 15)  As Long
    Dim SortOrder(1 To 15)  As String
    Dim nextSort As Long
    
    
    NextFreeLine = Application.Range("nrNextFreeRow").Value
    If NextFreeLine < 9 Then
        GoTo xout
    End If
    
    
    With ThisWorkbook.Worksheets(pcWSName_Summary)
        Set DataRange = .Range(.Cells(9, 1), .Cells(NextFreeLine - 1, pcWSPara_Summary_IDCol + 2))
    End With

    nextSort = 1
    If Not cbxSort1.ListIndex = -1 Then
        Sort(nextSort) = cbxSort1.Column(1, cbxSort1.ListIndex)
        SortOrder(nextSort) = cbxOrder1.Value
        nextSort = nextSort + 1
        If Sort(nextSort - 1) = 2 Then
            Sort(nextSort) = 4
            SortOrder(nextSort) = cbxOrder1.Value
            nextSort = nextSort + 1
            Sort(nextSort) = 5
            SortOrder(nextSort) = cbxOrder1.Value
            nextSort = nextSort + 1
        End If
    Else
        ' NO Sort Selected
        MsgBox "Please select sort order", vbOKOnly + vbExclamation
        Set DataRange = Nothing
        Exit Sub
    End If
    
    If Not cbxSort2.ListIndex = -1 Then
        Sort(nextSort) = cbxSort2.Column(1, cbxSort2.ListIndex)
        SortOrder(nextSort) = cbxOrder2.Value
        nextSort = nextSort + 1
        If Sort(nextSort - 1) = 2 Then
            Sort(nextSort) = 4
            SortOrder(nextSort) = cbxOrder2.Value
            nextSort = nextSort + 1
            Sort(nextSort) = 5
            SortOrder(nextSort) = cbxOrder1.Value
            nextSort = nextSort + 1
        End If
    End If
    
    If Not cbxSort3.ListIndex = -1 Then
        Sort(nextSort) = cbxSort3.Column(1, cbxSort3.ListIndex)
        SortOrder(nextSort) = cbxOrder3.Value
        nextSort = nextSort + 1
        If Sort(nextSort - 1) = 2 Then
            Sort(nextSort) = 4
            SortOrder(nextSort) = cbxOrder3.Value
            nextSort = nextSort + 1
            Sort(nextSort) = 5
            SortOrder(nextSort) = cbxOrder1.Value
            nextSort = nextSort + 1
        End If
    End If
    
    SortRange DataRange, Sort(1), Sort(2), Sort(3), SortOrder(1) = "Ascending", SortOrder(2) = "Ascending", SortOrder(3) = "Ascending", Sort(4), SortOrder(4) = "Ascending"
    
xout:
    Set DataRange = Nothing
    Me.Hide
    Unload Me
    
End Sub



Private Sub UserForm_Initialize()

    Dim SortValues As Variant
    Dim SortColums As Variant
    Dim i As Long
    
    Dim MyArray(0 To 1, 1 To 7)
    
    MyArray(0, 1) = "Code / Category / System / Inst. Part"
    MyArray(0, 2) = "Status"
    MyArray(0, 3) = "Date of required inspection"
    MyArray(0, 4) = "Date of executed inspection"
    MyArray(0, 5) = "Date of next inspection"
    MyArray(0, 6) = "Warranty"
    MyArray(0, 7) = "Defects"
    
    MyArray(1, 1) = "2"
    MyArray(1, 2) = "6"
    MyArray(1, 3) = "7"
    MyArray(1, 4) = "8"
    MyArray(1, 5) = "9"
    MyArray(1, 6) = "10"
    MyArray(1, 7) = "11"
    
    cbxOrder1.Clear
    cbxOrder1.List = Array("Ascending", "Descending")
    cbxOrder1.ListIndex = 0
    
    cbxOrder2.Clear
    cbxOrder2.List = Array("Ascending", "Descending")
    cbxOrder2.ListIndex = 0
    
    cbxOrder3.Clear
    cbxOrder3.List = Array("Ascending", "Descending")
    cbxOrder3.ListIndex = 0
    
    
    cbxSort1.Clear
    cbxSort1.List = MyArray
    cbxSort1.Column() = MyArray
    cbxSort1.ListIndex = 0
    
    cbxSort2.Clear
    cbxSort2.List = MyArray
    cbxSort2.Column() = MyArray

    
    cbxSort3.Clear
    cbxSort3.List = MyArray
    cbxSort3.Column() = MyArray


    

End Sub

' InQuest injected base64 decoded content
' *'v+b

INQUEST-PP=macro
