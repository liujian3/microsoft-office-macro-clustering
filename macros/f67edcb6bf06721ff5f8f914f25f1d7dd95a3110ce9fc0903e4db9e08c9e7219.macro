Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'Option Explicit        ' Auskommentiert, da sonst immer die Toolreinigung mosert...

'
Private Sub Workbook_BeforeClose(Cancel As Boolean)
    ' |fffd|ber Cancel wird gesteuert, ob die Aktion hier beendet ist oder nicht:
    '   Cancel = true: In dieser Funktion ist bereits alles erledigt worden
    '   Cancel = false: Mit den Standardaktionen weitermachen...
    Dim lRetVal As Long
    Dim oServ As Object
    Dim vDate As Variant
    
    ' Datei bei Bedarf speichern
    If Not ThisWorkbook.Saved Then
        ' Pr|fffd|fen, ob unser OLE-Server vorhanden ist
        Set oServ = MainServer("KWEDokument")
        If oServ Is Nothing Then
            ' Der OLE-Server ist nicht vorhanden --> Meldung an den User
            lRetVal = MsgBox(TOOLID + "067" + vbCrLf + vbCrLf + _
                "Die Datei '" + ThisWorkbook.Name + "' wurde noch nicht gespeichert." + vbCrLf + _
                "Sie m|fffd|ssen die Datei Speichern, bevor Sie die Arbeitsmappe schlie|fffd|en," + vbCrLf + _
                "sonst gehen Ihre |fffd|nderungen verloren." + vbCrLf + vbCrLf + _
                "Soll das Schlie|fffd|en der Datei jetzt abgebrochen werden?", _
                vbYesNoCancel, TOOLHDR)
            Select Case lRetVal
                Case vbYes, vbCancel
                    Cancel = True
                Case vbNo
                    Cancel = False
                    ThisWorkbook.Saved = True
            End Select
            GoTo END_BeforeClose
        End If
            
        lRetVal = MsgBox(TOOLID + "007" + vbCrLf + vbCrLf + _
            "Die Datei '" + ThisWorkbook.Name + "' wurde noch nicht gespeichert." + vbCrLf + vbCrLf + _
            "Soll die Datei jetzt gespeichert werden?", _
            vbYesNoCancel, TOOLHDR)
        Call DoLog("BeforeClose(); Datei speichern = " + IIf(lRetVal = vbYes, "Yes", IIf(lRetVal = vbNo, "No", "Cancel")))
        Select Case lRetVal
            Case vbYes
                Set oServ.XlApplication = Application
                Set oServ.xlWorkbook = ThisWorkbook
                lRetVal = oServ.Speichern(False)
                Call DoLog("BeforeClose(); Speichern; RetVal=" + CStr(lRetVal))
                Select Case lRetVal
                    Case oServ.FILESAVE_CANCEL, oServ.FILESAVE_ERROR
                        Cancel = True
                    Case oServ.FILESAVE_OK
                        Cancel = False
                End Select
            Case vbNo
                ThisWorkbook.Saved = True
            Case vbCancel
                Cancel = True
        End Select
    End If

END_BeforeClose:
    ' Hilfe-Server Verbindung schlie|fffd|en
    Set oServ = Nothing
    Set cHelp = Nothing
    Set cLog = Nothing
End Sub

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
    ' |fffd|ber Cancel wird gesteuert, ob die Aktion hier beendet ist oder nicht:
    '   Cancel = true: In dieser Funktion ist bereits alles erledigt worden
    '   Cancel = false: Mit den Standardaktionen weitermachen...
    Dim lRetVal As Long
    Dim oServ As Object
    Dim vDate As Variant
    
    If SaveAsUI Then
        Call DoLog("BeforeSave(); Datei speichern unter...")
        Set oServ = MainServer("KWEDokument")
        If oServ Is Nothing Then
            Cancel = False
            Exit Sub
        End If
        Set oServ.XlApplication = Application
        Set oServ.xlWorkbook = ThisWorkbook
        lRetVal = oServ.Speichern(SaveAsUI)
        Call DoLog("BeforeSave(); Speichern; RetVal=" + CStr(lRetVal))
        Select Case lRetVal
            Case oServ.FILESAVE_CANCEL
                Cancel = True
            Case oServ.FILESAVE_ERROR
                Cancel = False
            Case oServ.FILESAVE_OK
                Call SetSaveFormat
                Cancel = True
        End Select
        Set oServ = Nothing
    End If
End Sub

Private Sub Workbook_Activate()
    If ActiveSheet.Type <> xlWorksheet Then Exit Sub
    If ActiveSheet.Cells(ROW_SH_INFO, COL_SH_DATEN) = "Daten" Then Call SetKeyBehaviour
End Sub

Private Sub Workbook_Deactivate()
    Call ResetKeyBehaviour
End Sub

Private Sub Workbook_SheetActivate(ByVal Sh As Object)
    If Sh.Type <> xlWorksheet Then Exit Sub
    If Sh.Cells(ROW_SH_INFO, COL_SH_DATEN) = "Daten" Then Call SetKeyBehaviour
End Sub

Private Sub Workbook_SheetDeactivate(ByVal Sh As Object)
    Call ResetKeyBehaviour
End Sub

Private Function DMSAktiv() As Boolean
    Dim oSrv As Object
    Dim lRetVal As Long

    On Error Resume Next
    If KomponenteInstalled("K0005101") Then
        DMSAktiv = False
    Else
        ' Unseren eigenen Server anziehen
        Set oSrv = BasisServer("DDMA")
        If oSrv Is Nothing Then
            ' Kein Server --> keine Aussage m|fffd|glich = kein DMS
            DMSAktiv = False
        Else
            ' Wir sind da --> nach dem DMS fragen
            DMSAktiv = (oSrv.DMSAktiv And (oSrv.DMSTyp = oSrv.DDMA_DMSTYPE_DOKORG))
        End If
        Set oSrv = Nothing
    End If
    On Error GoTo 0
End Function

Private Function IgnoreDMS() As Boolean
    Dim bIgnoreDMS As Boolean
    Dim oServ As Object
        
    ' Im Fehlerfall wird ebenfalls diese Einstellung verwendet
    bIgnoreDMS = ThisWorkbook.Worksheets(TAB_DATEN).Range("IgnoreDMS")
    If Not bIgnoreDMS Then
        ' Jetzt die globale Einstellung auch abtesten
        Set oServ = BasisServer("Settings")
        If Not oServ Is Nothing Then
            ' Die globale Einstellung |fffd|berschreibt nur, wenn sie True ist
            If oServ.ReadSetting("IgnoreDMS", False) Then
                bIgnoreDMS = True
            End If
        End If
        Set oServ = Nothing
    End If
    IgnoreDMS = bIgnoreDMS
End Function
Attribute VB_Name = "Tabelle001"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "lblToolInfo, 16, 4, MSForms, Label"
Option Explicit

Private Sub lblToolInfo_Click()
    Call LabelToolInfoClick
End Sub
Attribute VB_Name = "Tabelle002"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle003"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle004"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Attribute VB_Name = "Tabelle006"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle007"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "btnSortKonto, 9, 0, MSForms, CommandButton"
Attribute VB_Control = "btnSortText, 11, 2, MSForms, CommandButton"
Attribute VB_Control = "btnSortKost1, 12, 3, MSForms, CommandButton"
Attribute VB_Control = "btnSortKost2, 13, 4, MSForms, CommandButton"
Option Explicit

Private Sub btnSortKonto_Click()
    Call SortVorlage(ActiveSheet, COL_TXT_KONTO)
End Sub

Private Sub btnSortText_Click()
    Call SortVorlage(ActiveSheet, COL_TXT_TEXT1)
End Sub

Private Sub btnSortKost1_Click()
    Call SortVorlage(ActiveSheet, COL_TXT_KOST1)
End Sub

Private Sub btnSortKost2_Click()
    Call SortVorlage(ActiveSheet, COL_TXT_KOST2)
End Sub

Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    Select Case Target.Column
        Case COL_TXT_KOST1, COL_TXT_KOST2
            Cancel = ContextMenu_KostAuswahl(Target)
    End Select
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
    Call EingabeKontrolleTextvorlagen(Target)
End Sub

Private Sub Worksheet_Activate()
    Dim ws As Worksheet
    Dim bProtected As Boolean
    Dim lLastRow As Long
    Dim szPrintArea As String
    
    Set ws = ActiveSheet
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    
    On Error Resume Next
    
    lLastRow = GetLastUsedRow(ws, ROW_TXT_START, COL_TXT_END)
    szPrintArea = "$" & sz2a1(COL_TXT_START) & "$" & ROW_TXT_START & ":$" & sz2a1(COL_TXT_END) & "$" & lLastRow

    With ws.PageSetup
        .PrintTitleRows = "$" + CStr(ROW_TXT_START - 2) + ":$" + CStr(ROW_TXT_START - 1)
        .PrintTitleColumns = ""
    End With
    ws.PageSetup.PrintArea = szPrintArea
    With ws.PageSetup
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
    
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    Set ws = Nothing
    On Error GoTo 0
End Sub

Attribute VB_Name = "Tabelle008"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "btnSortKostenstelle, 9, 0, MSForms, CommandButton"
Attribute VB_Control = "btnSortBezeichnung, 10, 1, MSForms, CommandButton"
Option Explicit

Private Sub btnSortBezeichnung_Click()
    Call SortVorlage(ActiveSheet, COL_KOST_TEXT)
End Sub

Private Sub btnSortKostenstelle_Click()
    Call SortVorlage(ActiveSheet, COL_KOST_KOST)
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
    Call EingabeKontrolleKostenstellen(Target)
End Sub

Private Sub Worksheet_Activate()
    Dim ws As Worksheet
    Dim bProtected As Boolean
    Dim lLastRow As Long
    Dim szPrintArea As String
    
    Set ws = ActiveSheet
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    
    On Error Resume Next
    
    lLastRow = GetLastUsedRow(ws, ROW_KOST_START, COL_KOST_END)
    szPrintArea = "$" & sz2a1(COL_KOST_START) & "$" & ROW_KOST_START & ":$" & sz2a1(COL_KOST_END) & "$" & lLastRow

    With ws.PageSetup
        .PrintTitleRows = "$" + CStr(ROW_KOST_START - 2) + ":$" + CStr(ROW_KOST_START - 1)
        .PrintTitleColumns = ""
    End With
    ws.PageSetup.PrintArea = szPrintArea
    With ws.PageSetup
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
    
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    Set ws = Nothing
    On Error GoTo 0
End Sub

Attribute VB_Name = "Tabelle010"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle011"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    If Target.Column = COL_ZP_DATE Then
        Cancel = ContextMenu_Zaehlprotokoll(Target)
    End If
End Sub

Attribute VB_Name = "Tabelle100"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle101"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle102"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle103"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle104"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle105"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle106"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle107"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle108"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle109"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle110"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle111"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle112"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "Tabelle113"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Change(ByVal Target As Excel.Range)
    Dim bRetVal As Boolean
    Dim lCRC As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    
    bRetVal = EingabeKontrolle(Target)
    If bRetVal Then
        Set ws = Target.Parent
        ' Hat die Buchungszeile den Status "Angelegt"?
        If IsDate(ws.Cells(Target.Row, COL_AW_DAT_CREATED).Value) Then
            ' Neue Pr|fffd|fsumme berechnen
            lCRC = GetCRC32(ws, Target.Row)
            If Target.Parent.Cells(Target.Row, COL_AW_CRC32).Value <> lCRC Then
                bProtected = ws.ProtectContents
                If bProtected Then ws.Unprotect
                Application.EnableEvents = False
                ' Neue Pr|fffd|fsumme eintragen
                ws.Cells(Target.Row, COL_AW_CRC32).Value = lCRC
                ' Falls eine Daten|fffd|bernahme durchgef|fffd|hrt wird, dann d|fffd|rfen exportierte
                ' Zeilen nicht weiter ver|fffd|ndert werden
                If Not ([ToolDatenImport] And IsDate(ws.Cells(Target.Row, COL_AW_DAT_EXPORTED).Value)) Then
                    ws.Cells(Target.Row, COL_AW_DAT_CHANGED).Value = Now
                    ws.Cells(Target.Row, COL_AW_EXPORTSTATUS).Value = 0
                    Call UpdateStatusColumnPerRow(ws, Target.Row)
                End If
                Application.EnableEvents = True
                If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            End If
        End If
    End If
End Sub

' Kontextmen|fffd|...
Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    ' Hier muss unterschieden werden
    ' 1. DropDown zwischen Col_Datum und Col_Saldo (2-11)
    Select Case Target.Column
        Case COL_BS_STATUS
            Cancel = ContextMenu_Status(Target)
        Case COL_BS_UST
            Cancel = ContextMenu_UStAuswahl(Target)
        Case COL_BS_DATUM
            If [TOOLKASSE] Then
                Cancel = ContextMenu_Zaehlprotokoll(Target)
            End If
        Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KOST1, COL_BS_KOST2, COL_BS_KONTO, COL_BS_GEGENKTO
            Cancel = ContextMenu_TextAuswahl(Target)
    End Select
End Sub

Attribute VB_Name = "gfrmDrucken"
Attribute VB_Base = "0{7BDDAFFA-F30D-49C8-BDA0-1B0742FD8D8D}{7F485DDC-C8AB-4057-A052-5293E5885300}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private mbAbbruch As Boolean
Private mlOrientation As Long
Private mbBlackWhite As Boolean
'
Private pbActivated As Boolean
Private plColorInactive As Long
'

Public Property Get Abbruch() As Boolean
    Abbruch = mbAbbruch
End Property

Public Property Get Copies() As Integer
    Copies = txtAnzahl.Value
End Property

Public Property Get SchwarzWeiss() As Boolean
    SchwarzWeiss = cbBlackWhite.Value
End Property

Public Property Get Orientierung() As Long
    Orientierung = IIf(optHochformat.Value, xlPortrait, xlLandscape)
End Property

Public Property Let Orientierung(vData As Long)
    mlOrientation = vData
End Property

Private Sub btnCancel_Click()
    mbAbbruch = True
    On Error Resume Next
    ActiveSheet.PageSetup.Orientation = mlOrientation
    ActiveSheet.PageSetup.BlackAndWhite = mbBlackWhite
    On Error GoTo 0
    Me.Hide
End Sub

Private Sub btnDrucker_Click()
    If Application.Dialogs(xlDialogPrinterSetup).Show Then
       txtAktiverdrucker.Text = Application.ActivePrinter
    End If
End Sub

Private Sub btnOk_Click()
    mbAbbruch = False
    Me.Hide
End Sub

Private Sub btnPreview_Click()
    gbPreview = True
    Me.Hide
    gbPrinting = True
    
    On Error GoTo ERR_btnPreview_LFZ_9
    
    ActiveSheet.PageSetup.Orientation = IIf(optHochformat.Value, xlPortrait, xlLandscape)
    ActiveSheet.PageSetup.BlackAndWhite = IIf(cbBlackWhite.Value, True, False)
    Application.Dialogs(xlDialogPrintPreview).Show
    gbPrinting = False
    Me.Show
    gbPreview = False
    On Error GoTo 0
    Exit Sub
    
ERR_btnPreview_LFZ_9:
    Call DoLogPerm("btnPreview(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number <> 9 Then
        MsgBox TOOLID + "066" + vbCrLf + vbCrLf + _
            "Beim Drucken der Seite ist ein Fehler aufgetreten." + vbCrLf + vbCrLf + _
            "Fehler " + CStr(Err.Number) + vbCrLf + Err.Description + vbCrLf + vbCrLf + _
            Chr(187) + " Pr|fffd|fen Sie, ob der gew|fffd|hlte Drucker verf|fffd|gbar ist.", vbInformation, TOOLHDR
    End If
    Resume Next
End Sub

Private Sub btnSetup_Click()
    Application.Dialogs(xlDialogPageSetup).Show
End Sub

Private Sub spnAnzahl_Change()
    txtAnzahl.Value = spnAnzahl.Value
End Sub

Private Sub txtAnzahl_Change()
    spnAnzahl.Value = txtAnzahl.Value
End Sub

Private Sub UserForm_Activate()
    ' Unter Excel 97 kommt es sonst zu mehrfachem Aufruf
    If pbActivated Then Exit Sub
    pbActivated = True
    
    Me.Caption = TOOLHDR & " - Drucken"
    txtAnzahl.Value = 1
    spnAnzahl.min = 1
    spnAnzahl.Max = 99
    spnAnzahl.Value = 1
    txtAktiverdrucker.BackColor = plColorInactive
    txtAktiverdrucker = Application.ActivePrinter
    mbBlackWhite = False
    cbBlackWhite.Value = mbBlackWhite
    If mlOrientation = xlPortrait Then
        ' Hochformat
        optHochformat.Value = True
        optQuerformat.Value = False
    Else
        ' Querformat
        optHochformat.Value = False
        optQuerformat.Value = True
    End If
End Sub

Private Sub UserForm_Initialize()
    pbActivated = False
    plColorInactive = Me.BackColor
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        mbAbbruch = True
        Me.Hide
        Cancel = 1
    End If
End Sub

Attribute VB_Name = "gfrmEinstellungen"
Attribute VB_Base = "0{40F03576-150F-4498-B546-08543CB62A6D}{F5382D48-20A0-4CC9-863B-215761786B8F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'
' Konstanten f|fffd|r das Layout
'
Private Const MP_IMPUT = 0      ' Register Eingabe
Private Const MP_CHECK = 1      ' Register Pr|fffd|fungen
Private Const MP_SORT = 2       ' Register Sortierung
Private Const MP_TEMPLATE = 3   ' Register Vorlagen
Private Const MP_VIEW = 4       ' Register Anzeige
'
' Register Pr|fffd|fungen
Private Const HEIGHT_FRAME21 = 144
Private Const TOP_OPT_MINUS = 60
Private Const TOP_OPT_CHECKSORT = 84
Private Const TOP_OPT_CHECKLINE = 100
Private Const TOP_OPT_CHECKMONTH = 114
Private Const TOP_OPT_ALLOWDELETECHECKED = 132
Private Const DIFF_FRAME21 = 25
Private Const TOP_FRAME12 = 146.25
Private Const TOP_FRAME12_TEXT = TOP_FRAME12 + 0
Private Const TOP_FRAME12_FRAME = TOP_FRAME12 + 3.75
Private Const HEIGHT_FRAME12 = 70
Private Const TOP_OPT_BELEG1 = 162
Private Const TOP_OPT_GEGENKONTO = 180
Private Const TOP_OPT_KONTO = 198
Private Const DIFF_FRAME12 = 16
Private Const HEIGHT_FRAME31 = 61.5
Private Const DIFF_FRAME31 = 24
' Form
Private Const HEIGHT_FORM_KASSE = 285   ' 337.5
Private Const HEIGHT_FORM_WARE = 306    ' 294
' Multipage
Private Const HEIGHT_REG_KASSE = 252    ' 300
Private Const HEIGHT_REG_WARE = 276     ' 256.5
'
' Private Datentypen
'
Private Type tDatenEingabe
    bKeinTrennzeichen As Boolean
    bNullWerte As Boolean
    bBUmitGegenKto As Boolean
    bSpalten|fffd|berspringen As Boolean
    bSpalteGegenKto As Boolean
    bTextLen_Postversand As Boolean
    bTextLen_DatevFormat As Boolean
    bTextLen_Max As Boolean
    '
    bNeedBeleg1 As Boolean
    bNeedGegenkonto As Boolean
    bNeedKonto As Boolean
    bNeedKost1 As Boolean
    bNeedKost2 As Boolean
End Type

Private Type tDatenPr|fffd|fung
    bDatumPr|fffd|fen As Boolean
    bVormonatZulassen As Boolean
    bMinuspr|fffd|fung As Boolean
    bSortierenUndPr|fffd|fen As Boolean
    bZeilenweisePr|fffd|fen As Boolean
    bAllowDeleteChecked As Boolean
End Type

Private Type tDatenSortierung
    iSortierSpalte() As Integer
    szSortierName() As String
    iSortierOption() As Integer
    iSortierIndex As Integer
    bSortAllMonths As Boolean
    bSortEnabled As Boolean
End Type

Private Type tDatenTemplate
    bOverwrite As Boolean
End Type

Private Type tDatenView
    ' Gruppe Ansicht Lfd Nummer
    bLfdNummerReal As Boolean
    bBestandImmerZeigen As Boolean
    bProtokollSchreiben As Boolean
End Type

'
' Membervariablen
'
Private tInput As tDatenEingabe
Private tCheck As tDatenPr|fffd|fung
Private tSort As tDatenSortierung
Private tTemplate As tDatenTemplate
Private tView As tDatenView
'
Private pbActivated As Boolean
'
Private mbAbbruch As Boolean
Private mbLayoutKasse As Boolean
'

'
' *** Properties
'
Public Property Get Abbruch() As Boolean
    Abbruch = mbAbbruch
End Property

Public Property Let IsKasse(bKasse As Boolean)
    mbLayoutKasse = bKasse
End Property

'
' *** Funktionen
'
Private Sub btnOk_Click()
    Dim szData As String
    Dim szMatch As String
    Dim iTextbox As Integer
    
    ' Page *Eingabe*
    tInput.bKeinTrennzeichen = cbKeinTrennzeichen.Value
    tInput.bNullWerte = cbNullValues.Value
    If tInput.bSpalteGegenKto Then
        tInput.bBUmitGegenKto = cbBUmitGegenkonto.Value
        tInput.bSpalten|fffd|berspringen = cbBUSpaltenSprung.Value
    End If
    '
    tInput.bNeedBeleg1 = cbNeedsBeleg1.Value
    tInput.bNeedKost1 = cbNeedsKost1.Value
    tInput.bNeedKost2 = cbNeedsKost2.Value
    If tInput.bSpalteGegenKto Then
        tInput.bNeedGegenkonto = cbNeedsGegenkto.Value
    End If
    If Not mbLayoutKasse Then tInput.bNeedKonto = cbNeedsKonto.Value
    '
    ' Page *Pr|fffd|fung*
    tCheck.bDatumPr|fffd|fen = cbDatumPr|fffd|fen.Value
    tCheck.bVormonatZulassen = cbVormonatZulassen.Value
    tCheck.bMinuspr|fffd|fung = cbMinuspr|fffd|fung.Value            ' Nur f|fffd|r Kassenerfassung
    tCheck.bSortierenUndPr|fffd|fen = cbSortAndCheck.Value
    tCheck.bZeilenweisePr|fffd|fen = optCheckLine.Value
    tCheck.bAllowDeleteChecked = cbAllowDeleteChecked.Value
    '
    ' Page *Sortierung*
    tSort.iSortierIndex = ddSpalten.ListIndex
    tSort.iSortierOption(tSort.iSortierIndex) = IIf(cbSortTextAsNumber.Value, 1, 0)
    '
    ' Page *Vorlagen*
    tTemplate.bOverwrite = cbOverwrite.Value
    '
    ' Page *View*
    ' Gruppe Lfd. Nr.
    tView.bLfdNummerReal = optLfdNrReal.Value
    tView.bBestandImmerZeigen = cbBestandImmerZeigen.Value
    tView.bProtokollSchreiben = cbProtokoll.Value
    '
    ' Alles ok, Daten zur|fffd|ckschreiben
    Call DatenSchreiben
    Me.Hide
    mbAbbruch = False
    
End Sub

Private Sub btnCancel_Click()
    Me.Hide
    mbAbbruch = True
End Sub

Private Sub cbBUmitGegenkonto_Change()
    If cbBUmitGegenkonto.Value = True Then
        cbBUSpaltenSprung.Enabled = True
        cbBUSpaltenSprung.TabStop = True
    Else
        cbBUSpaltenSprung.Enabled = False
        cbBUSpaltenSprung.TabStop = False
    End If
End Sub

Private Sub cbDatumPr|fffd|fen_Change()
    If cbDatumPr|fffd|fen.Value = True Then
        cbVormonatZulassen.Enabled = True
        cbVormonatZulassen.TabStop = True
    Else
        cbVormonatZulassen.Enabled = False
        cbVormonatZulassen.TabStop = False
    End If
End Sub

Private Sub cbSortAndCheck_Change()
    If cbSortAndCheck.Value = True Then
        optCheckLine.Enabled = True
        optCheckLine.TabStop = True
        optCheckMonth.Enabled = True
        optCheckMonth.TabStop = True
    Else
        optCheckLine.Enabled = False
        optCheckLine.TabStop = False
        optCheckMonth.Enabled = False
        optCheckMonth.TabStop = False
    End If
End Sub

Private Sub ddSpalten_Click()
    Call SetSortMethod
End Sub

Private Sub UserForm_Activate()
    Dim i As Integer
    
    ' Unter Excel 97 kommt es sonst zu mehrfachem Aufruf
    If pbActivated Then Exit Sub
    pbActivated = True
    
    '
    ' Layout einstellen
    Me.Caption = TOOLHDR & " - Einstellungen"
    If mbLayoutKasse Then
        '
        ' Register Einstellungen - Frame 2
        lblFrame12.Height = HEIGHT_FRAME12 - DIFF_FRAME12
        cbNeedsKonto.Visible = False
        cbNeedsKonto.TabStop = False
        '
        ' Register Pr|fffd|fungen - Frame 1
        lblFrame21.Height = HEIGHT_FRAME21
        cbMinuspr|fffd|fung.Top = TOP_OPT_MINUS
        cbMinuspr|fffd|fung.Visible = True
        cbMinuspr|fffd|fung.TabStop = True
        cbSortAndCheck.Top = TOP_OPT_CHECKSORT
        optCheckLine.Top = TOP_OPT_CHECKLINE
        optCheckMonth.Top = TOP_OPT_CHECKMONTH
        cbAllowDeleteChecked.Top = TOP_OPT_ALLOWDELETECHECKED
        '
        ' Register Sortierung
        If Val(Application.Version) > 9 Then
            lblFrame31.Height = HEIGHT_FRAME31
            cbSortTextAsNumber.Visible = True
        Else
            lblFrame31.Height = HEIGHT_FRAME31 - DIFF_FRAME31
            cbSortTextAsNumber.Visible = False
        End If
        '
        ' Register View
        lblFrame63.Visible = True
        lblFrame63Text.Visible = True
        cbBestandImmerZeigen.Visible = True
        '
    Else
        '
        ' Register Einstellungen - Frame 2
        lblFrame12.Height = HEIGHT_FRAME12
        cbNeedsKonto.Visible = True
        cbNeedsKonto.TabStop = True
        '
        ' Register Pr|fffd|fungen - Frame 1
        lblFrame21.Height = HEIGHT_FRAME21 - DIFF_FRAME21
        cbMinuspr|fffd|fung.Top = TOP_OPT_MINUS - DIFF_FRAME21
        cbMinuspr|fffd|fung.Visible = False
        cbMinuspr|fffd|fung.TabStop = False
        cbSortAndCheck.Top = TOP_OPT_CHECKSORT - DIFF_FRAME21
        optCheckLine.Top = TOP_OPT_CHECKLINE - DIFF_FRAME21
        optCheckMonth.Top = TOP_OPT_CHECKMONTH - DIFF_FRAME21
        cbAllowDeleteChecked.Top = TOP_OPT_ALLOWDELETECHECKED - DIFF_FRAME21
        '
        ' Register Sortierung
        If Val(Application.Version) > 9 Then
            lblFrame31.Height = HEIGHT_FRAME31
            cbSortTextAsNumber.Visible = True
        Else
            lblFrame31.Height = HEIGHT_FRAME31 - DIFF_FRAME31
            cbSortTextAsNumber.Visible = False
        End If
        '
        ' Register View
        lblFrame63.Visible = False
        lblFrame63Text.Visible = False
        cbBestandImmerZeigen.Visible = False
    End If
    '
    Call DatenEinlesen
    '
    ' Page *Eingabe*
    cbKeinTrennzeichen.Value = tInput.bKeinTrennzeichen
    cbNullValues.Value = tInput.bNullWerte
    If tInput.bSpalteGegenKto Then
        cbBUmitGegenkonto.Value = tInput.bBUmitGegenKto
        cbBUSpaltenSprung.Value = tInput.bSpalten|fffd|berspringen
        If tInput.bBUmitGegenKto Then
            cbBUSpaltenSprung.Enabled = True
            cbBUSpaltenSprung.TabStop = True
        Else
            cbBUSpaltenSprung.Enabled = False
            cbBUSpaltenSprung.TabStop = False
        End If
        cbNeedsGegenkto.Enabled = True
        cbNeedsGegenkto.TabStop = True
    Else
        ' Gegenkonto und BU ausgeblendet
        cbBUmitGegenkonto.Enabled = False
        cbBUmitGegenkonto.TabStop = False
        cbBUSpaltenSprung.Enabled = False
        cbBUSpaltenSprung.TabStop = False
        cbNeedsGegenkto.Value = False
        cbNeedsGegenkto.Enabled = False
        cbNeedsGegenkto.TabStop = False
    End If
    cbNeedsBeleg1.Value = tInput.bNeedBeleg1
    cbNeedsKost1.Value = tInput.bNeedKost1
    cbNeedsKost2.Value = tInput.bNeedKost2
    If tInput.bSpalteGegenKto Then
        cbNeedsGegenkto.Value = tInput.bNeedGegenkonto
    Else
        cbNeedsGegenkto.Value = False
    End If
    cbNeedsKonto.Value = tInput.bNeedKonto
    '
    optTextLen_Postversand.Value = tInput.bTextLen_Postversand
    optTextLen_DATEV.Value = tInput.bTextLen_DatevFormat
    optTextLen_Max.Value = tInput.bTextLen_Max
    '
    ' Page *Pr|fffd|fung*
    cbDatumPr|fffd|fen.Value = tCheck.bDatumPr|fffd|fen
    cbVormonatZulassen.Value = tCheck.bVormonatZulassen
    If tCheck.bDatumPr|fffd|fen = True Then
        cbVormonatZulassen.Enabled = True
        cbVormonatZulassen.TabStop = True
    Else
        cbVormonatZulassen.Enabled = False
        cbVormonatZulassen.TabStop = False
    End If
    cbMinuspr|fffd|fung.Value = tCheck.bMinuspr|fffd|fung            ' Nur f|fffd|r Kassenerfassung
    cbSortAndCheck.Value = tCheck.bSortierenUndPr|fffd|fen
    optCheckLine.Value = tCheck.bZeilenweisePr|fffd|fen
    optCheckMonth.Value = Not tCheck.bZeilenweisePr|fffd|fen
    If tCheck.bSortierenUndPr|fffd|fen Then
        optCheckLine.Enabled = True
        optCheckLine.TabStop = True
        optCheckMonth.Enabled = True
        optCheckMonth.TabStop = True
    Else
        optCheckLine.Enabled = False
        optCheckLine.TabStop = False
        optCheckMonth.Enabled = False
        optCheckMonth.TabStop = False
    End If
    cbAllowDeleteChecked.Value = tCheck.bAllowDeleteChecked
    '
    ' Page *Sortierung*
    For i = 0 To UBound(tSort.szSortierName) - 1
        If tSort.iSortierSpalte(i) <> 0 Then ddSpalten.AddItem tSort.szSortierName(i)
    Next
    ddSpalten.ListIndex = tSort.iSortierIndex
    mpOptions.Pages(MP_SORT).Enabled = tSort.bSortEnabled
    '
    ' Page *Vorlagen*
    cbOverwrite.Value = tTemplate.bOverwrite
    '
    optLfdNrReal.Value = tView.bLfdNummerReal
    optLfdNrSort.Value = Not tView.bLfdNummerReal
    cbBestandImmerZeigen.Value = tView.bBestandImmerZeigen
    cbProtokoll.Value = tView.bProtokollSchreiben
    '
    ' Erste Seite anzeigen
    mpOptions.Value = 0
    
    mbAbbruch = False
End Sub

Private Sub UserForm_Initialize()
    pbActivated = False
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        Me.Hide
        mbAbbruch = True
        Cancel = 1
    End If
End Sub

Private Sub SetSortMethod()
    Dim ws As Worksheet
    Dim iSortierSpalte As Integer
    
    Set ws = ThisWorkbook.Worksheets(TAB_IMPORT)
    
    ' Sortierspalte holen
    iSortierSpalte = tSort.iSortierSpalte(ddSpalten.ListIndex)
    
    ' Aktuelle Einstellung eintragen
    cbSortTextAsNumber.Value = IIf(tSort.iSortierOption(ddSpalten.ListIndex) = 1, True, False)
    
    ' Ist das eine alphanumerische Spalte?
    If ws.Cells(ROW_TAB_TYPE, COL_TAB_OFFSET + iSortierSpalte) = "A" Then
        cbSortTextAsNumber.Enabled = True
    Else
        cbSortTextAsNumber.Enabled = False
    End If
End Sub

Private Sub DatenEinlesen()
    Dim ws As Worksheet
    Dim szKtoL|fffd|nge As String
    Dim iSortierSpalte As Integer
    Dim i As Integer
    Dim j As Integer
    Dim rRange As Range
    Dim bAdd As Boolean
    
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    
    With ws
        ' Page *Eingabe*
        tInput.bKeinTrennzeichen = .Range("DATEVEingabe")
        tInput.bNullWerte = .Range("AllowZeroValues")
        tInput.bBUmitGegenKto = .Range("BUMitGegenkonto")
        tInput.bSpalten|fffd|berspringen = .Range("BUSpaltenSprung")
        tInput.bSpalteGegenKto = .Range("OptSpalteGegenkonto")
        If .Range("AllowLongText") Then
            tInput.bTextLen_Max = True
            tInput.bTextLen_DatevFormat = False
            tInput.bTextLen_Postversand = False
        Else
            tInput.bTextLen_Max = False
            If Val(.Range("StandardTextLen")) = MAX_LEN_TEXT Then
                tInput.bTextLen_Postversand = True
                tInput.bTextLen_DatevFormat = False
            Else
                tInput.bTextLen_Postversand = False
                tInput.bTextLen_DatevFormat = True
            End If
        End If
        '
        tInput.bNeedBeleg1 = .Range("NeedsSpalteBeleg1")
        tInput.bNeedGegenkonto = .Range("NeedsSpalteGegenKto")
        tInput.bNeedKonto = .Range("NeedsSpalteKonto")
        tInput.bNeedKost1 = .Range("NeedsSpalteKost1")
        tInput.bNeedKost2 = .Range("NeedsSpalteKost2")
        ' Page *Pr|fffd|fung*
        tCheck.bDatumPr|fffd|fen = .Range("DatumPr|fffd|fen")
        tCheck.bVormonatZulassen = .Range("VormonatZulassen")
        tCheck.bMinuspr|fffd|fung = .Range("KassePr|fffd|fen")               ' Nur f|fffd|r Kassenerfassung
        tCheck.bSortierenUndPr|fffd|fen = .Range("ImmerPr|fffd|fen")
        tCheck.bZeilenweisePr|fffd|fen = .Range("NurZeilePr|fffd|fen")
        tCheck.bAllowDeleteChecked = .Range("AllowDeleteChecked")
        ' Page *Sortierung*
        tSort.bSortEnabled = True
        If LCase(ActiveSheet.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
            iSortierSpalte = ActiveSheet.Cells(ROW_HD_SORT, COL_HD_SORTNUM)
        Else
            iSortierSpalte = .Range("SKey1")
            If .Range("Angelegt").Value = True Then tSort.bSortEnabled = False
        End If
        If iSortierSpalte = 0 Then iSortierSpalte = .Range("SKey1")
        Set rRange = .Range("SortierSpalten")
        ReDim tSort.iSortierSpalte(rRange.Rows.Count - 1)
        ReDim tSort.szSortierName(rRange.Rows.Count - 1)
        ReDim tSort.iSortierOption(rRange.Rows.Count - 1)
        j = 0
        For i = 0 To rRange.Rows.Count - 1
            bAdd = True
            If LCase(rRange.Cells(i + 1, 3)) Like "*opt*" Then
                ' |fffd|bernehmen der Einstellung f|fffd|r diese Zusatzspalte, falls aktiviert
                bAdd = .Range(rRange.Cells(i + 1, 3))
            End If
            If bAdd Then
                tSort.szSortierName(j) = rRange.Cells(i + 1, 1)
                tSort.iSortierSpalte(j) = rRange.Cells(i + 1, 2)
                tSort.iSortierOption(j) = rRange.Cells(i + 1, 4)
                If iSortierSpalte = tSort.iSortierSpalte(j) Then tSort.iSortierIndex = j
                j = j + 1
            End If
        Next
        ' Page *Vorlagen*
        tTemplate.bOverwrite = .Range("OverwriteFields")
        ' Page *View*
        tView.bLfdNummerReal = .Range("SpalteLfdNrReal")
        tView.bBestandImmerZeigen = .Range("BestandImmerZeigen")
        tView.bProtokollSchreiben = .Range("ToolDebug")
    End With
    
    Set ws = Nothing
End Sub

Private Sub DatenSchreiben()
    Dim ws As Worksheet
    Dim szKtoL|fffd|nge As String
    Dim hit As Range
    Dim szRange As String
    Dim iIndex As Integer
    Dim i As Integer
    
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    
    With ws
        ' Page *Eingabe*
        .Range("DATEVEingabe") = tInput.bKeinTrennzeichen
        .Range("AllowZeroValues") = tInput.bNullWerte
        .Range("BUMitGegenkonto") = tInput.bBUmitGegenKto
        .Range("BUSpaltenSprung") = tInput.bSpalten|fffd|berspringen
        '
        If tInput.bTextLen_Postversand Then
            .Range("AllowLongText") = False
            .Range("StandardTextLen") = MAX_LEN_TEXT
        ElseIf tInput.bTextLen_DatevFormat Then
            .Range("AllowLongText") = False
            .Range("StandardTextLen") = MAX_LEN_TEXT_2
        Else
            .Range("AllowLongText") = True
            ' Hier immer auf den Standard gehen
            .Range("StandardTextLen") = .Range("LongTextMaxLen")
        End If
        '
        .Range("NeedsSpalteBeleg1") = tInput.bNeedBeleg1
        .Range("NeedsSpalteGegenKto") = tInput.bNeedGegenkonto
        .Range("NeedsSpalteKost1") = tInput.bNeedKost1
        .Range("NeedsSpalteKost2") = tInput.bNeedKost2
        If Not mbLayoutKasse Then .Range("NeedsSpalteKonto") = tInput.bNeedKonto
        ' Page *Pr|fffd|fung*
        .Range("DatumPr|fffd|fen") = tCheck.bDatumPr|fffd|fen
        .Range("VormonatZulassen") = tCheck.bVormonatZulassen
        .Range("KassePr|fffd|fen") = tCheck.bMinuspr|fffd|fung            ' Nur f|fffd|r Kassenerfassung
        .Range("ImmerPr|fffd|fen") = tCheck.bSortierenUndPr|fffd|fen
        .Range("NurZeilePr|fffd|fen") = tCheck.bZeilenweisePr|fffd|fen
        .Range("AllowDeleteChecked") = tCheck.bAllowDeleteChecked
        ' Page *Sortierung*
        If LCase(ActiveSheet.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
            ActiveSheet.Cells(ROW_HD_SORT, COL_HD_SORTNUM) = tSort.iSortierSpalte(tSort.iSortierIndex)
            ActiveSheet.Cells(ROW_HD_SORT, COL_HD_SORTTEXT) = tSort.szSortierName(tSort.iSortierIndex)
            ActiveSheet.Cells(ROW_HD_SORT, COL_HD_SORTOPT) = tSort.iSortierOption(tSort.iSortierIndex)
            ' Sortieroption zur|fffd|ckschreiben
            For i = 0 To .Range("SortierSpalten").Rows.Count - 1
                If .Range("SortierSpalten").Cells(i + 1, 2) = tSort.iSortierSpalte(tSort.iSortierIndex) Then
                    .Range("SortierSpalten").Cells(i + 1, 4) = tSort.iSortierOption(tSort.iSortierIndex)
                    Exit For
                End If
            Next
        Else
            .Range("SKey1") = tSort.iSortierSpalte(tSort.iSortierIndex)
        End If
        ' Page *Vorlagen*
        .Range("OverwriteFields") = tTemplate.bOverwrite
        ' Page *View*
        .Range("SpalteLfdNrReal") = tView.bLfdNummerReal
        .Range("BestandImmerZeigen") = tView.bBestandImmerZeigen
        .Range("ToolDebug") = tView.bProtokollSchreiben
    End With
    
    Set ws = Nothing
End Sub

Private Sub FehlerMeldung(szNum As String, szMsg As String)
    MsgBox TOOLID + szNum + vbCrLf + vbCrLf + szMsg, vbInformation, TOOLHDR
End Sub

Private Function InStr2(szIn As String, szWhat As String, szMatch As String) As Long
    Dim i As Long
    Dim j As Long
    Dim szC As String
    
    InStr2 = 0
    For i = 1 To Len(szIn)
        For j = 1 To Len(szWhat)
            szMatch = Mid(szWhat, j, 1)
            If Mid(szIn, i, 1) = szMatch Then
                InStr2 = i
                Exit Function
            End If
        Next j
    Next i
End Function

Attribute VB_Name = "gfrmExportASCII"
Attribute VB_Base = "0{DBD78E77-1B4F-4A8D-A661-A402A57ABA45}{CEDC2C65-8760-4767-ADAA-65528862AB11}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private mbAbbruch As Boolean
Private mwsExportSheet As Worksheet
Private mszExportPath As String
Private mszExportFile As String
'
Private pbActivated As Boolean
Private plColorInactive As Long
Private plColorActive As Long
Private plDiffHeight As Long
'

Public Property Get Abbruch() As Boolean
    Abbruch = mbAbbruch
End Property

Public Property Get ExportFile() As String
    ExportFile = AddBackslash(mszExportPath) + mszExportFile
End Property

Public Property Set ExportSheet(ws As Worksheet)
    Set mwsExportSheet = ws
End Property



Private Sub btnCancel_Click()
    mbAbbruch = True
    Me.Hide
End Sub

Private Sub btnOk_Click()
    Dim szData As String
    Dim szPath As String
    Dim szFile As String
    
    ' Verzeichnisdaten einlesen
    szData = Trim(txtZielVerzeichnis.Text)
        
    ' Der Pfad muss bereits existieren
    szPath = RemoveLastDir(szData)
    If Not ExistsDir(szPath) Then
        MsgBox TOOLID + "046" + vbCrLf + vbCrLf + _
            "Das Zielverzeichnis existiert nicht." + vbCrLf + vbCrLf + _
            Chr(187) + " W|fffd|hlen Sie ein existierendes Verzeichnis aus.", _
            vbExclamation, TOOLHDR
        txtZielVerzeichnis.SetFocus
        txtZielVerzeichnis.SelStart = 0
        txtZielVerzeichnis.SelLength = Len(txtZielVerzeichnis.Text)
        Exit Sub
    End If
    
    ' Am Eingabefeld sollte der Dateiname noch mit dranh|fffd|ngen...
    szFile = PopLastDir(szData)
    If UCase(Right(szFile, 4)) <> ".TXT" Then
        MsgBox TOOLID + "047" + vbCrLf + vbCrLf + _
            "Es wurde kein Dateiname f|fffd|r die Exportdatei angegeben, oder sie ist nicht vom Typ ""txt""." + vbCrLf + vbCrLf + _
            Chr(187) + " |fffd|ndern oder Erg|fffd|nzen Sie die Angaben.", _
            vbExclamation, TOOLHDR
        txtZielVerzeichnis.SetFocus
        txtZielVerzeichnis.SelStart = 0
        txtZielVerzeichnis.SelLength = Len(txtZielVerzeichnis.Text)
        Exit Sub
    End If
    
    ' Pfad + Dateiname
    If ExistsFile(szData) Then
        If MsgBox(TOOLID + "048" + vbCrLf + vbCrLf + _
              "Die Datei """ + szFile + """ existiert bereits." + vbCrLf + _
              "Soll die Datei |fffd|berschrieben werden?", _
              vbExclamation + vbYesNo, TOOLHDR) = vbNo Then
            txtZielVerzeichnis.SetFocus
            txtZielVerzeichnis.SelStart = 0
            txtZielVerzeichnis.SelLength = Len(txtZielVerzeichnis.Text)
            Exit Sub
        End If
    End If
    mszExportPath = szPath
    mszExportFile = szFile
    
    mbAbbruch = False
    Me.Hide
End Sub

Private Sub btnZielVerzeichnis_Click()
    Dim szPath As String
    Dim szFileName As String
    Dim vRetVal As Variant
    
ZielVerzeichnisNochmal:
    szPath = ""
    szFileName = GetNewFilename
    If txtZielVerzeichnis.Text <> "" Then
        If Not ExistsDir(txtZielVerzeichnis.Text) Then
            szPath = RemoveLastDir(txtZielVerzeichnis.Text)
        Else
            szPath = txtZielVerzeichnis.Text
        End If
        szPath = AddBackslash(szPath)
    End If
    vRetVal = Application.GetSaveAsFilename(szPath + szFileName, "Exportdatei (*.txt), *.txt")
    If vRetVal <> False Then
        If UCase(Right(vRetVal, 4)) <> ".TXT" Then
            ' Wir wollen die Exportdateien als .txt haben...
            If MsgBox(TOOLID + "032" + vbCrLf + vbCrLf + _
                "Die gew|fffd|hlte Datei hat nicht das erwartete Format." + vbCrLf + vbCrLf + _
                Chr(187) + " W|fffd|hlen Sie eine Datei mit dem Dateityp ""TXT"".", _
                vbInformation + vbOKCancel, TOOLHDR) = vbOK Then
                txtZielVerzeichnis.Text = RemoveLastDir(vRetVal)
                GoTo ZielVerzeichnisNochmal
            End If
        Else
            txtZielVerzeichnis.Text = CStr(vRetVal)
        End If
    End If
End Sub

Private Sub UserForm_Activate()
    Dim szFile As String
    Dim szPath As String
    
    ' Unter Excel 97 kommt es sonst zu mehrfachem Aufruf
    If pbActivated Then Exit Sub
    pbActivated = True
    
    Me.Caption = TOOLHDR & " - ASCII Export"
    
    ' Info f|fffd|r den Anwender
    lblInfo.Caption = "Die Export-Komponente der Anwendung konnte nicht gefunden werden." + vbCrLf + _
        "Es steht daher nur der ASCII-Export der gesamten Erfassungsseite zur Verf|fffd|gung." + vbCrLf + vbCrLf + _
        "Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder f|fffd|hren" + vbCrLf + _
        "eine Reparaturinstallation durch."
    
    ' Ordnungsbegriff und MPD anzeigen
    txtBNR.Text = IIf([BNR] = "", "<keine>", CStr([BNR]))
    txtMNR.Text = IIf([MNR] = "", "<keine>", CStr([MNR]))
    txtKtoL|fffd|nge.Text = IIf([KtoL|fffd|nge] = "", "<keine>", CStr([KtoL|fffd|nge]))
    '
    txtBNR.BackColor = plColorInactive
    txtMNR.BackColor = plColorInactive
    txtKtoL|fffd|nge.BackColor = plColorInactive
    
    mszExportPath = ""
    mszExportFile = ""
    ' Verzeichnisdaten einlesen
    szPath = Trim(CStr([ZielVerzeichnisASCII]))
    If Len(szPath) > 0 Then
        szFile = PopLastDir(szPath)
        If UCase(Right(szFile, 4)) = ".TXT" Then
            ' Ein Dateiname enthalten --> abschneiden
            szPath = RemoveLastDir(szPath)
        End If
        If szPath <> "" Then
            mszExportPath = szPath
            mszExportFile = GetNewFilename
        End If
    End If
    txtZielVerzeichnis.Text = AddBackslash(mszExportPath) + mszExportFile
    txtZielVerzeichnis.SetFocus
        
End Sub

Private Sub UserForm_Initialize()
    pbActivated = False
    plColorInactive = Me.BackColor
    plColorActive = txtMNR.BackColor
    plDiffHeight = IIf(Me.Height - Me.InsideHeight = 24, 5.25, 0)
    mbAbbruch = False
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        mbAbbruch = True
        Me.Hide
        Cancel = 1
    End If
End Sub


Private Function GetNewFilename() As String
    Dim szJahr As String
    Dim szMonat As String
    Dim szMandant As String
    Dim szToolPrefix As String
    
    szToolPrefix = GetToolPrefix
    szMonat = Left(mwsExportSheet.Name, 2)
    szJahr = Right(mwsExportSheet.Name, 4)
    szMandant = Format(txtMNR.Text, "00000")
    GetNewFilename = szToolPrefix + szMandant + "_" + szJahr + "_" + szMonat + ".txt"
End Function

Private Function AddBackslash(ByVal szPfad As String) As String
    AddBackslash = Trim(szPfad)
    If AddBackslash <> "" Then
        If Right(AddBackslash, 1) <> "\" Then
            AddBackslash = AddBackslash & "\"
        End If
    End If
End Function

Private Function ExistsDir(szDir As String) As Boolean
    Dim szCurrentDir As String
    Dim lRetVal As Long
    
    ExistsDir = False
    szCurrentDir = CurDir()
    lRetVal = SetCurrentDirectory(szDir)
    If lRetVal <> 0 Then
        Call SetCurrentDirectory(szCurrentDir)
        ExistsDir = True
    End If
End Function

Private Function ExistsFile(szFile As String) As Boolean
    ExistsFile = False
    If szFile = "" Then Exit Function
    On Error GoTo ErrExistsFile
    If Dir(szFile) <> "" Then ExistsFile = True
    On Error GoTo 0
    Exit Function

ErrExistsFile:
    On Error GoTo 0
End Function


Attribute VB_Name = "gfrmFehler"
Attribute VB_Base = "0{B617311E-77FA-4498-B330-4717F2A645E2}{D34313DD-EB51-49F0-8A0C-684F539C09A6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private mbNoCancel As Boolean
Private mbAborted As Boolean
Private sHelpTop As Single
'
Private plColorInactive As Long


Public Property Let CancelButton(bCancelButton As Boolean)
    mbNoCancel = Not bCancelButton
    If mbNoCancel Then
        btnCancel.Visible = False
        btnCancel.Enabled = False
        btnHelp.Top = btnCancel.Top
        btnCancel.Cancel = False
    Else
        btnCancel.Visible = True
        btnCancel.Enabled = True
        btnCancel.Cancel = True
        btnHelp.Top = 56.25
    End If
End Property

Public Property Let MessageText(szMsg As String)
    lbMsg.Text = szMsg
End Property

Public Property Let ErrorNumber(szErrNum As String)
    lblErrNo.Caption = TOOLID + szErrNum
End Property

Public Property Let ActionText(szAction As String)
    lblAnweisung.Caption = Chr(187) & " " & szAction
End Property

Public Property Let OkButtonCaption(szCaption As String)
    btnOk.Caption = szCaption
End Property

Public Property Get Aborted() As Boolean
    Aborted = mbAborted
End Property

Private Sub btnHelp_Click()
    Call HoleHilfe("HLPID_FRMFEHLER")
End Sub

Private Sub btnCancel_Click()
    mbAborted = True
    Me.Hide
End Sub

Private Sub btnOk_Click()
    mbAborted = False
    Me.Hide
End Sub

Private Sub UserForm_Activate()
    Me.Caption = TOOLHDR & " - Validierung Kontoblatt"
    lbMsg.BackColor = plColorInactive
    lbMsg.SetFocus
    lbMsg.SelStart = 0
    mbAborted = False
    If btnCancel.Visible Then
        btnCancel.Cancel = True
        btnCancel.SetFocus
    Else
        btnOk.Cancel = True
        btnOk.SetFocus
    End If
    Beep
End Sub

Private Sub UserForm_Initialize()
    sHelpTop = btnCancel.Top
    plColorInactive = Me.BackColor
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        mbAborted = True
        Me.Hide
        Cancel = 1
    End If
End Sub
Attribute VB_Name = "gfrmStammdaten"
Attribute VB_Base = "0{D7F66C3A-CEFB-4835-8D8C-3E1169665ED2}{FE613C60-6E83-40E5-8204-7F0963594BC9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'
' Lokale Variablen
'
Private pbActivated As Boolean

'
' Membervariablen
'
' Allgemein
Private mbLayoutKasse As Boolean        ' "Kasse" = true, sonst/default = false
Private mbDATEVEingabe As Boolean
Private mbAbbruch As Boolean            ' Abbruch durch den Benutzer


'
' Funktionen
'
Private Sub btnCancel_Click()
    Me.Hide
End Sub

Private Sub btnOk_Click()
    Dim ws As Worksheet
    ' Gruppe Mandantendaten
    Dim szMandantenName As String
    Dim lBNR As Long
    Dim lMNR As Long
    ' Gruppe Kontodaten
    Dim lKtoNummer As Long
    Dim lKtoVerrechnung As Long
    Dim szCurrency As String
    Dim lKtoLen As Long
    Dim cSaldoStart As Currency
    
    
    ' Gruppe Mandantendaten
    ' Mandantenname, Kann-Feld
    szMandantenName = Trim(txtMName.Text)
    ' Beraternummer
    lBNR = Val(Trim(txtBNR.Text))
    If lBNR < 1 Or lBNR > 9999999 Then
        Call FehlerMeldung("043", "Die Beraternummer muss ungleich 0 und darf maximal 7-stellig sein.")
        Exit Sub
    End If
    ' Mandantennummer
    lMNR = Val(Trim(txtMNR.Text))
    If lMNR < 1 Or lMNR > 99999 Then
        Call FehlerMeldung("044", "Die Mandantennummer muss ungleich 0 und darf maximal 5-stellig sein.")
        Exit Sub
    End If
    
    ' Gruppe Kontodaten
    If mbLayoutKasse Then
        ' Kontonummer, Muss-Feld f|fffd|r Kasse
        If Not CheckNummer(txtKtoNummer, txtKtoNummer.Text, 9, True) Then Exit Sub
        lKtoNummer = Val(txtKtoNummer.Text)
    Else
        ' In der Ware darf die Sachkontenl|fffd|nge manuell ge|fffd|ndert werde --> pr|fffd|fen
        If Not CheckNummer(txtKtoLen, txtKtoLen.Text, 1, True) Then Exit Sub
        If Val(txtKtoLen.Text) < 4 Or Val(txtKtoLen.Text) > 8 Then
            Call FehlerMeldung("072", "Sachkontenl|fffd|nge ausserhalb des g|fffd|ltigen Bereichs." + vbCrLf + "Geben Sie eine g|fffd|ltige Sachkontenl|fffd|nge ein.")
            txtKtoLen.SetFocus
            txtKtoLen.SelStart = 0
            txtKtoLen.SelLength = 1
            Exit Sub
        End If
    End If
    lKtoLen = Val(txtKtoLen.Text)
    ' Verrechnungskonto
    lKtoVerrechnung = Val(txtKtoVerrechnung.Text)
    ' Pr|fffd|fen
    If Not CheckNummer(txtKtoVerrechnung, txtKtoVerrechnung.Text, lKtoLen, False) Then Exit Sub
    ' Anfangssaldo, Kann-Feld
    If Not CheckBetrag(txtSaldoStart) Then Exit Sub
    If Len(txtSaldoStart.Text) > 0 Then cSaldoStart = CCur(txtSaldoStart.Text)
    szCurrency = UCase(Trim(ddCurrency.Text))
    If Not szCurrency Like "[A-Z][A-Z][A-Z]" Then
        Call FehlerMeldung("073", "Ung|fffd|ltiges W|fffd|hrungskennzeichen. Das Kennzeichen muss aus drei Buchstaben bestehen." + vbCrLf + "Geben Sie eine g|fffd|ltige Sachkontenl|fffd|nge ein.")
        ddCurrency.SetFocus
        Exit Sub
    End If
    
    mbAbbruch = False
    
    '
    ' Werte in das Sheet zur|fffd|ckschreiben
    '
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    With ws
        .Range("MName") = szMandantenName
        .Range("BNR") = lBNR
        .Range("MNR") = lMNR
        .Range("KtoL|fffd|nge") = lKtoLen
        If mbLayoutKasse Then .Range("KtoNummer") = lKtoNummer
        .Range("KtoVerrechnung") = lKtoVerrechnung
        .Range("KtoSaldoStart") = cSaldoStart
        .Range("EingabeW|fffd|hrung") = szCurrency
    End With
    
    Me.Hide
End Sub

Private Sub btnHelp_Click()
    Call HoleHilfe("HLPID_STAMM_CHNG")
End Sub


Private Sub txtKtoNummer_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If CheckNummer(txtKtoNummer, txtKtoNummer.Text, 9) Then
        Cancel = False
        txtKtoLen.Text = GetKtoLen(txtKtoNummer.Text)
    Else
        Cancel = True
    End If
End Sub

Private Sub txtKtoLen_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    If Len(Trim(txtKtoLen.Text)) <> 0 Then
        If CheckNummer(txtKtoLen, txtKtoLen.Text, 1, False) Then
            If Val(txtKtoLen.Text) < 4 Or Val(txtKtoLen.Text) > 8 Then
                Call FehlerMeldung("079", "Sachkontenl|fffd|nge ausserhalb des g|fffd|ltigen Bereichs." + vbCrLf + "Geben Sie eine g|fffd|ltige Sachkontenl|fffd|nge an.")
                Application.EnableEvents = False
                txtKtoLen.Text = ""
                Application.EnableEvents = True
                Cancel = True
            Else
                Cancel = False
            End If
        Else
            Cancel = True
        End If
    End If
End Sub

Private Sub txtSaldoStart_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Cancel = Not CheckBetrag(txtSaldoStart)
End Sub



Private Sub UserForm_Activate()
    Dim lLen As Long
    Dim ws As Worksheet
    
    ' Unter Excel 97 kommt es sonst zu mehrfachem Aufruf
    If pbActivated Then Exit Sub
    pbActivated = True
    
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    
    ' Pr|fffd|fung ob angelegt
    If Not ws.Range("Angelegt") Then
        MsgBox TOOLID + "045" + vbCrLf + vbCrLf + _
            "Stammdaten k|fffd|nnen nur bei angelegter Erfassung ge|fffd|ndert werden.", _
            vbInformation, TOOLHDR
        Me.Hide
        Exit Sub
    End If

    '
    ' Layout einstellen
    '
    mbLayoutKasse = ws.Range("ToolKasse")
    ' Das WJ darf nie ge|fffd|ndert werden
    txtWJBeginn.Locked = True
    txtWJBeginn.BackColor = Me.BackColor
    txtWJEnde.Locked = True
    txtWJEnde.Locked = True
    If Not mbLayoutKasse Then
        ' Gruppe Kontodaten einstellen
        lblKtoNummer.Visible = False
        txtKtoNummer.Visible = False
        ' Zuerst Feld f|fffd|r Sachkontenl|fffd|nge verschieben
        lblKtoL|fffd|nge.Left = lblKtoVerrechnung.Left
        txtKtoLen.Left = txtKtoVerrechnung.Left
        ' Dann das Verrechnungskonto
        lblKtoVerrechnung.Left = lblKtoNummer.Left
        txtKtoVerrechnung.Left = txtKtoNummer.Left
        ' Sachkontenl|fffd|nge darf bei Warenerfassung ver|fffd|ndert werden
        txtKtoLen.BackColor = txtMName.BackColor
        txtKtoLen.Locked = False
    End If
    
    '
    ' Daten laden
    '
    ' Gruppe Mandantendaten
    txtMName.Text = ws.Range("MName")
    If IsDate(ws.Range("WJBeginn")) Then
        txtWJBeginn.Text = Format(CDate(ws.Range("WJBeginn")), "dd.mm.yyyy")
    Else
        txtWJBeginn.Text = ""
    End If
    If IsDate(ws.Range("WJEnde")) Then
        txtWJEnde.Text = Format(CDate(ws.Range("WJEnde")), "dd.mm.yyyy")
    Else
        txtWJEnde.Text = ""
    End If
    txtBNR.Text = IIf(Val(ws.Range("BNR")) > 0, CStr(ws.Range("BNR")), "")
    txtMNR.Text = IIf(Val(ws.Range("MNR")) > 0, CStr(ws.Range("MNR")), "")
    
    ' Gruppe Kontodaten
    lLen = Val(ws.Range("KtoL|fffd|nge"))
    txtKtoLen.Text = IIf(lLen > 3 And lLen < 9, CStr(lLen), "")
    If mbLayoutKasse Then
        txtKtoNummer.Text = IIf(ws.Range("KtoNummer") > 0, CStr(ws.Range("KtoNummer")), "")
        If txtKtoLen.Text = "" And txtKtoNummer.Text <> "" Then
            ' Bestimmen der Sachkontenl|fffd|nge aus der Kontonummer
            lLen = GetKtoLen(ws.Range("KtoNummer"))
            txtKtoLen.Text = CStr(lLen)
        End If
    End If
    txtKtoVerrechnung.Text = IIf(ws.Range("KtoVerrechnung") > 0, CStr(ws.Range("KtoVerrechnung")), "")
    
    If LoadWkz Then
        ' W|fffd|hrungen vom Server geholt
        Call SetWkz(ws.Range("EingabeW|fffd|hrung"))
    Else
        ddCurrency.Style = fmStyleDropDownCombo
        ddCurrency.AddItem CStr(ws.Range("EingabeW|fffd|hrung"))
    End If
    
    txtSaldoStart.Text = Format(ws.Range("KtoSaldoStart"), "#,##0.00")
    
    lblFrame1.ZOrder 1
    lblFrame2.ZOrder 1
    
    mbAbbruch = False
End Sub

Private Sub UserForm_Initialize()
    pbActivated = False
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        mbAbbruch = True
        Me.Hide
        Cancel = 1
    End If
End Sub

Private Function InitW|fffd|hrungsAuswahl(szW|fffd|hrung As String) As Long
    Dim i As Long
    
    InitW|fffd|hrungsAuswahl = 0
    For i = 0 To ddCurrency.ListCount - 1
        If szW|fffd|hrung = ddCurrency.List(i) Then
            InitW|fffd|hrungsAuswahl = i
            Exit Function
        End If
    Next i
End Function

Private Sub FehlerMeldung(szNum As String, szMsg As String)
    MsgBox TOOLID + szNum + vbCrLf + vbCrLf + szMsg, vbInformation, TOOLHDR
End Sub

Private Function MyTrim(szIn As String)
    Dim szOut As String
    Dim szC As String
    Dim i As Long
    
    szOut = ""
    For i = 1 To Len(szIn)
        szC = Mid(szIn, i, 1)
        If szC <> " " Then szOut = szOut & szC
    Next i
    MyTrim = szOut
End Function

'
' Pr|fffd|froutinen
'

Private Function CheckNummer(tb As Object, szNummer As String, ByVal lLen As Integer, Optional bNotEmpty As Boolean = False, Optional bShowErr As Boolean = True) As Boolean
    Dim bError As Boolean
    Dim szData As String
    
    bError = False
    'If Me.Tag = "Cancel" Then Exit Function
    szData = MyTrim(szNummer)
    If Len(szData) > 0 Then
        If Not IsNumeric(szData) Then
            If bShowErr Then Call FehlerMeldung("074", "Keine g|fffd|ltige Zahl." + vbCrLf + "Geben Sie eine g|fffd|ltige Zahl ein.")
            bError = True
            GoTo AusgangCheckNummer
        End If
        If Len(szData) > lLen Then
            If bShowErr Then Call FehlerMeldung("075", "Die eingegebene Zahl muss ungleich 0 und darf maximal " & lLen & "-stellig sein.")
            bError = True
            GoTo AusgangCheckNummer
        End If
        If Val(szData) < 1 Or Val(szData) > Val(String(lLen, "9")) Then
            If bShowErr Then Call FehlerMeldung("076", "Die eingegebene Zahl muss ungleich 0 und darf maximal " & lLen & "-stellig sein.")
            bError = True
            GoTo AusgangCheckNummer
        End If
    ElseIf bNotEmpty Then
        bError = True
        If bShowErr Then Call FehlerMeldung("071", "Eine Eingabe in das Feld ist notwendig." + vbCrLf + vbCrLf + Chr(187) & " Geben Sie einen maximal " & lLen & "-stelligen Wert ungleich 0 ein.")
    End If
    
AusgangCheckNummer:
    If bError And bShowErr And Not tb Is Nothing Then
        On Error Resume Next
        tb.SetFocus
        tb.SelStart = 0
        tb.SelLength = Len(tb.Text)
        On Error GoTo 0
    End If
    CheckNummer = Not bError
End Function

Private Function CheckBetrag(tb As Object) As Boolean
    Dim vSaldo As Variant
    Dim bError As Boolean
    
    bError = False
    'If Me.Tag = "Cancel" Then Exit Function
    vSaldo = Trim(tb.Text)
    If Len(vSaldo) > 0 Then
        ' DATEV-Logik pr|fffd|fen
        If mbDATEVEingabe And Not vSaldo Like "*,*" Then
            vSaldo = "00" & tb.Text
            vSaldo = Left(vSaldo, Len(vSaldo) - 2) & "," & Right(vSaldo, 2)
        End If
        If Not IsNumeric(vSaldo) Then
            Call FehlerMeldung("077", "Geben Sie einen g|fffd|ltigen Betrag ein.")
            bError = True
            GoTo AusgangCheckBetrag
        End If
        If vSaldo > 99999999999.99 Then
            Call FehlerMeldung("078", "Der eingegebene Betrag ist zu gro|fffd| (max. 10.2-stellig).")
            bError = True
            GoTo AusgangCheckBetrag
        End If
        tb.Text = Format(vSaldo, "#,##0.00")
    Else
        tb.Text = "0,00"
    End If
    
AusgangCheckBetrag:
    If bError Then
        On Error Resume Next
        tb.SetFocus
        tb.SelStart = 0
        tb.SelLength = Len(tb.Text)
        On Error GoTo 0
    End If
    CheckBetrag = Not bError
End Function


' ConvertDate()
' Konvertiert einen Datumsstring der Form "[d]dmm[yy[yy]]" in ein Datum
' der Form dd.mm.yy[yy]
Private Function ConvertDate(ByVal szDateIn As String) As String
    Dim i As Integer
    Dim szDay As String
    Dim szMonth As String
    Dim szYear As String
    
    ConvertDate = szDateIn
    ' Fehlende f|fffd|hrende 0 erg|fffd|nzen
    i = Len(szDateIn)
    Select Case i
        Case 3, 5, 7
            szDateIn = "0" & szDateIn
    End Select
    ' Datum zerlegen...
    szDay = Left(szDateIn, 2)
    szMonth = Mid(szDateIn, 3, 2)
    szYear = CStr(Year(Now))
    If Len(szDateIn) > 4 Then szYear = Mid(szDateIn, 5)
    ' ...und wieder zusammensetzen
    ConvertDate = szDay & "." & szMonth & "." & szYear
End Function

' MyIsDate()
' |fffd|hnlich wie IsDate(), erwartet aber immer ein Datum in der Form "[d]d.[m]m.[yy[yy]]"
Private Function MyIsDate(szDate As String) As Boolean
    Dim szConv As String
    Dim da As Date
    Dim i As Integer
    Dim iDay As Integer
    Dim iMonth As Integer
    Dim iYear As Integer
    
    MyIsDate = False
    
    On Error GoTo ErrMyIsDate
    i = InStr(szDate, ".")
    If i = 0 Then Exit Function
    ' Tag
    iDay = Val(Left(szDate, i - 1))
    If iDay < 1 Or iDay > 31 Then Exit Function
    szConv = Mid(szDate, i + 1)
    ' Monat
    i = InStr(szConv, ".")
    If i = 0 Then
        iMonth = Val(szConv)
        szConv = ""
    Else
        iMonth = Val(Left(szConv, i - 1))
        szConv = Mid(szConv, i + 1)
    End If
    If iMonth < 1 Or iMonth > 12 Then Exit Function
    Select Case iMonth
        Case 4, 6, 9, 11
            If iDay > 30 Then Exit Function
        Case 2
            If iDay > 29 Then Exit Function
    End Select
    ' Jahr
    If szConv <> "" Then
        iYear = Val(szConv)
        If iYear < 0 Or iYear > 2999 Then Exit Function
    Else
        iYear = Year(Now)
    End If
    ' Validieren
    szConv = Format(iDay, "00") & "." & Format(iMonth, "00") & "." & CStr(iYear)
    If Not IsDate(szConv) Then Exit Function
    MyIsDate = True
    ' Fall through
    
ErrMyIsDate:
    On Error GoTo 0
End Function

Private Function GetKtoLen(szKtoLen As String) As Long
    Dim o As Object
    
    Set o = Nothing
    If CheckNummer(o, szKtoLen, 9, True, False) Then
        GetKtoLen = Len(MyTrim(szKtoLen))
        If GetKtoLen < 4 Then
            GetKtoLen = 4
        ElseIf GetKtoLen > 8 Then
            GetKtoLen = 8
        End If
    Else
        GetKtoLen = 0
    End If
End Function

Private Function LoadWkz(Optional bShowAll As Boolean = True) As Boolean
    Dim cSet As Object
    Dim lCount As Long
    Dim lPos As Long
    Dim szSection As String
    Dim szCurrency As String
    Dim lEurPos As Long
    
    LoadWkz = False
    
    ddCurrency.Clear
    lEurPos = 0
    
    Set cSet = BasisServer("Settings")
    If Not cSet Is Nothing Then
        If cSet.SetIniFile(TOOLWKZINIFILE) Then
            szSection = IIf(bShowAll, "WKZ_ALLE", "WKZ_SEL")
            lCount = Val(cSet.ReadGlobalSetting(szSection, "WKZ_Anzahl"))
            For lPos = 1 To lCount
                szCurrency = cSet.ReadGlobalSetting(szSection, "WKZ_" + CStr(lPos))
                ddCurrency.AddItem Left(szCurrency, 3)
                If Left(szCurrency, 3) = "EUR" Then lEurPos = lPos - 1
            Next lPos
        Else
            ddCurrency.AddItem "EUR"
        End If
        
        Set cSet = Nothing
    Else
        ' Nur Euro
        ddCurrency.AddItem "EUR"
    End If
    ddCurrency.ListIndex = lEurPos
    LoadWkz = True
    
End Function

Private Sub SetWkz(szWkz As String)
    Dim i As Long
    
    For i = 0 To ddCurrency.ListCount - 1
        If Left(ddCurrency.List(i), 3) = szWkz Then Exit For
    Next i
    
    If i < ddCurrency.ListCount Then ddCurrency.ListIndex = i
End Sub


Attribute VB_Name = "gfrmTextAuswahl"
Attribute VB_Base = "0{DE1FA730-7658-4D23-95AB-61AFF0F2DC6A}{0B70E4BA-EE71-494A-9211-BEF14543FB51}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private mszPattern As String
Private mlSpalte As Long
Private mbKost As Boolean
Private mbAbbruch As Boolean
Private mlZuordnung(COL_BS_ENDE) As Long
'


Public Property Let Pattern(vData As String)
    mszPattern = vData
End Property

Public Property Let Spalte(vData As Long)
    mlSpalte = vData
    mbKost = IIf(mlSpalte = COL_BS_KOST1 Or mlSpalte = COL_BS_KOST2, True, False)
End Property

Public Property Let Kost(vData As Boolean)
    mbKost = vData
End Property

Public Property Get TextAuswahl() As String
    Dim lCount As Long
    Dim szAuswahl As String
    
    For lCount = 0 To lbAuswahl.ColumnCount - 1
        szAuswahl = szAuswahl + CStr(lbAuswahl.List(lbAuswahl.ListIndex, lCount)) + "#"
    Next lCount
    TextAuswahl = Left(szAuswahl, Len(szAuswahl) - 1)
End Property

Public Property Get Overwrite() As Boolean
    Overwrite = cbOverwrite.Value
End Property

Public Property Get Abbruch() As Boolean
    Abbruch = mbAbbruch
End Property

Private Sub cmdCancel_Click()
    mbAbbruch = True
    Me.Hide
End Sub

Private Sub cmdOk_Click()
    Me.Hide
End Sub

Private Sub lbAuswahl_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.Hide
End Sub

Private Sub UserForm_Activate()
    Dim wsT As Worksheet
    Dim wsE As Worksheet
    Dim lRowCount As Long
    Dim lIndex As Long
    Dim bScreenUpdating As Boolean
    Dim lLastCol As Long
    
    ' Vorbereitungen
    If mbKost Then
        Set wsT = ThisWorkbook.Worksheets(TAB_KOST)
        lLastCol = COL_KOST_END
    Else
        Set wsT = ThisWorkbook.Worksheets(TAB_TEXTE)
        lLastCol = COL_TXT_END
    End If
    Set wsE = ActiveSheet
    bScreenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = False
    wsT.Activate
    mbAbbruch = True
    
    ' Keine Spalte angegeben
    If mlSpalte = 0 Then GoTo TextAuswahlFehler
    
    ' Zeile des letzten Eintrags ermitteln
    lRowCount = wsT.Range(wsT.Cells(1, 1), wsT.Cells(ROW_BS_MAX, lLastCol)).Find(What:="*", After:=[A1], SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row
    
    ' Sortieren
    If wsT.ProtectContents = True Then wsT.Unprotect
    If mbKost Then
        wsT.Range(sz2a1(COL_TXT_START, ROW_TXT_START) + ":" + sz2a1(lLastCol, lRowCount)).Sort _
            Key1:=wsT.Cells(ROW_TXT_START, COL_TXT_START), Order1:=xlAscending, _
            Header:=xlNo, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
    Else
        wsT.Range(sz2a1(COL_TXT_START, ROW_TXT_START) + ":" + sz2a1(lLastCol, lRowCount)).Sort _
            Key1:=wsT.Range(sz2a1(mlZuordnung(mlSpalte), ROW_TXT_START)), Order1:=xlAscending, _
            Header:=xlNo, OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
    End If
    wsT.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    
    ' Zeile des letzten Eintrags nochmal ermitteln
    lRowCount = wsT.Range(wsT.Cells(1, 1), wsT.Cells(ROW_BS_MAX, lLastCol)).Find(What:="*", After:=[A1], SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row
    
    ' Gibt es vordefinierte Texte?
    If lRowCount < ROW_TXT_START Then
        MsgBox TOOLID + "031" + vbCrLf + vbCrLf + _
            "F|fffd|r diese Eingabespalte sind noch keine Vorlagen definiert." + vbCrLf + vbCrLf + _
            Chr(187) + " Wechseln Sie auf das Eintragungsblatt " + IIf(mbKost, """Kostenstellen""", """Textvorlagen""") + " und erfassen Ihre Vorlagen" + _
            IIf(mbKost, ".", ", oder " + vbCrLf + "nutzen Sie das Kontextmen|fffd|, um bereits erfasste Texte der Vorlage hinzuzuf|fffd|gen."), _
            vbInformation, TOOLHDR
        mbAbbruch = True
        GoTo TextAuswahlFehler
    End If
    
    ' Liste f|fffd|llen
    lbAuswahl.ColumnCount = lLastCol - COL_TXT_START + 1
    lbAuswahl.RowSource = sz2a1(COL_TXT_START, ROW_TXT_START) + ":" + sz2a1(lLastCol, lRowCount)
    If lbAuswahl.ListCount > 0 Then lbAuswahl.ListIndex = 0
    
    ' Den richtigen ListIndex-Eintrag w|fffd|hlen
    If mszPattern <> "" Then
        For lIndex = 0 To lbAuswahl.ListCount - 1
            If UCase(lbAuswahl.List(lIndex)) Like UCase(mszPattern) + "*" Then
                lbAuswahl.ListIndex = lIndex
                Exit For
            End If
        Next lIndex
    End If
    
    mbAbbruch = False
    wsE.Activate
    Application.ScreenUpdating = bScreenUpdating
    Set wsE = Nothing
    Set wsT = Nothing
    
    Exit Sub
    
TextAuswahlFehler:
    wsE.Activate
    Application.ScreenUpdating = bScreenUpdating
    Set wsE = Nothing
    Set wsT = Nothing
    Me.Hide
    
End Sub

Private Sub UserForm_Initialize()
    Dim lCol As Long
    
    mlSpalte = 0
    
    For lCol = COL_BS_START To COL_BS_ENDE
        Select Case lCol
            Case COL_BS_KONTO
                mlZuordnung(lCol) = COL_TXT_KONTO
            Case COL_BS_GEGENKTO
                mlZuordnung(lCol) = COL_TXT_GEGENKTO
            Case COL_BS_TEXT
                mlZuordnung(lCol) = COL_TXT_TEXT1
            Case COL_BS_NAMEORT
                mlZuordnung(lCol) = COL_TXT_TEXT2
            Case COL_BS_KOST1
                mlZuordnung(lCol) = COL_TXT_KOST1
            Case COL_BS_KOST2
                mlZuordnung(lCol) = COL_TXT_KOST2
            Case Else
                mlZuordnung(lCol) = 0
        End Select
    Next lCol
    
    cbOverwrite.Value = ThisWorkbook.Worksheets(TAB_DATEN).Range("OverwriteFields")
End Sub

Attribute VB_Name = "gmodAPI"
Option Explicit

#If VBA7 Then
'
' Pointersafe declarations f|fffd|r Office x64
'
' gfrmExportASCII
Public Declare PtrSafe Function SetCurrentDirectory Lib "kernel32" Alias "SetCurrentDirectoryA" (ByVal lpPathName As String) As Long
' gmodInterface
Public Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" Alias "GetCurrentProcessId" () As Long
' gmodUtils
Public Declare PtrSafe Function GetFileAttributes Lib "kernel32" Alias "GetFileAttributesA" (ByVal lpFileName As String) As Long
Public Declare PtrSafe Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
' gmodGetDir
Public Type BROWSEINFO  ' bi
    hOwner As LongPtr
    pidlRoot As Long
    pszDisplayName As String
    lpszTitle As String
    ulFlags As Long
    lpFn As LongPtr
    lParam As LongPtr
    iImage As Long
End Type
Public Const BIF_RETURNONLYFSDIRS = &H1
Public Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
Public Declare PtrSafe Function SHGetPathFromIDList Lib "Shell32" Alias "SHGetPathFromIDListA" (ByVal pidl As Long, ByVal pszPath As String) As Long
Public Declare PtrSafe Sub CoTaskMemFree Lib "ole32" (ByVal pv As LongPtr)
Public Declare PtrSafe Function GetActiveWindow Lib "user32" Alias "GetActiveWindow" () As LongPtr

#Else

' gfrmExportASCII
Public Declare Function SetCurrentDirectory Lib "kernel32" Alias "SetCurrentDirectoryA" (ByVal lpPathName As String) As Long
' gmodInterface
Public Declare Function GetCurrentProcessId Lib "kernel32" () As Long
' gmodUtils
Public Declare Function GetFileAttributes Lib "kernel32" Alias "GetFileAttributesA" (ByVal lpFileName As String) As Long
Public Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
' gmodGetDir
Public Type BROWSEINFO 'bi
    hOwner As Long
    pidlRoot As Long
    pszDisplayName As String
    lpszTitle As String
    ulFlags As Long
    lpFn As Long
    lParam As Long
    iImage As Long
End Type
Public Const BIF_RETURNONLYFSDIRS = &H1
Public Declare Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListA" (ByVal pidl As Long, ByVal pszPath As String) As Long
Public Declare Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
Public Declare Function GetActiveWindow Lib "user32.dll" () As Long
Public Declare Sub CoTaskMemFree Lib "ole32" (ByVal pv As Long)

#End If
Attribute VB_Name = "gmodAuto"
Option Explicit

Sub auto_open()
    Dim m As Integer
    Dim j As Integer
    Dim szName As String
    Dim wsD As Worksheet
    Dim szMessage As String
    
    Application.Calculation = xlCalculationAutomatic
    
    gbEingabeKontrolle = True
    
    ' Die Property "Last Save Time" ist bereits gesetzt und entspricht der des Templates --> Problem mit BSOffice
    Call ResetLastSaveTime
    ' Das Speicherformat f|fffd|r die Dokumentenablage einstellen
    Call SetSaveFormat
    
    Set wsD = ThisWorkbook.Worksheets(TAB_DATEN)
    
    If wsD.Range("Angelegt") Then
        If wsD.Range("ShowCurrentMonth") Then
            ' Buch vorhanden --> auf aktuelles(?) Monatsblatt wechseln
            m = Month(Date)
            j = Year(Date)
            szName = Format(m, "00") & "." & j
            If ExistsWorksheet(ThisWorkbook, szName) Then
                ThisWorkbook.Worksheets(szName).Activate
            End If
        End If
        ' Aktuelles Blatt 'aktivieren'
        ActiveSheet.EnableSelection = xlUnlockedCells
        ActiveSheet.Cells(ROW_BS_START, COL_BS_FIRST).Select
        If LCase(ActiveSheet.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" And ActiveSheet.ProtectContents = True Then
            Application.OnKey "{ENTER}", "WeiterSchalten"
            Application.OnKey "{TAB}", "WeiterSchalten"
            Application.OnKey "~", "WeiterSchalten"
        End If
    End If
    
    If Application.DisplayCommentIndicator = xlCommentAndIndicator Then
        ' Die Kommentare d|fffd|rfen nicht dauerhaft angezeigt werden
        Application.DisplayCommentIndicator = xlCommentIndicatorOnly
    End If
    
    If Application.FixedDecimal = True Then
        ' XL2003: Extras | Optionen | Bearbeiten die Einstellung Feste Dezimalstelle setzen
        ' XL2007: Office | Excel-Optionen | Erweitert unter Bearbeitungsoptionen die Einstellung Dezimalkomma automatisch einf|fffd|gen
        ' XL2010: Datei | Optionen | Erweitert unter Bearbeitungsoptionen die Einstellung Dezimalkomma automatisch einf|fffd|gen
        Select Case Val(Application.Version)
            Case Is <= 11
                szMessage = "Sie haben unter Extras | Optionen | Bearbeiten die Einstellung ""Feste Dezimalstelle setzen"" gew|fffd|hlt."
            Case 12
                szMessage = "Sie haben unter Office | Excel-Optionen | Erweitert in Bearbeitungsoptionen die Einstellung ""Dezimalkomma automatisch einf|fffd|gen"" gew|fffd|hlt."
            Case Is > 12
                szMessage = "Sie haben unter Datei | Optionen | Erweitert in Bearbeitungsoptionen die Einstellung ""Dezimalkomma automatisch einf|fffd|gen"" gew|fffd|hlt."
        End Select
        ' Das darf nicht sein, sonst werden Konto/Gegenkonto "gerundet"
        MsgBox TOOLID + "005" + vbCrLf + vbCrLf + _
            szMessage & vbCrLf & _
            "Mit dieser Einstellung arbeitet die " + TOOLHDR + " nicht korrekt. Die Option wird deaktiviert.", _
            vbInformation, TOOLHDR
        Application.FixedDecimal = False
    End If
    If ThisWorkbook.MultiUserEditing = True Then
        ' XL2003: Extras | Arbeitsmappe freigeben...
        ' XL2007ff: |fffd|berpr|fffd|fen | Arbeitsmappe freigeben...
        Select Case Val(Application.Version)
            Case Is <= 11
                szMessage = Chr(187) & " L|fffd|schen Sie die Freigabe indem Sie unter Extras | Arbeitsmappe freigeben... das" & vbCrLf & _
                    "   Kontrollk|fffd|stchen ""Bearbeitung von mehrere Benutzer zur selben Zeit zulassen"" deaktivieren." & vbCrLf & _
                    "   Sollte das Kontrollk|fffd|stchen eingegraut sein, so kann dies |fffd|ber Extras | Schutz | Freigabeschutz aufheben... ge|fffd|ndert werden."
            Case Is >= 12
                szMessage = Chr(187) & " L|fffd|schen Sie die Freigabe indem Sie unter |fffd|berpr|fffd|fen | Arbeitsmappe freigeben... das" & vbCrLf & _
                    "   Kontrollk|fffd|stchen ""Bearbeitung von mehrere Benutzer zur selben Zeit zulassen"" deaktivieren."
        End Select
        '
        MsgBox TOOLID + "009" + vbCrLf + vbCrLf + _
            "Sie haben die " + TOOLHDR + " f|fffd|r die gemeinsame Nutzung durch mehrere Benutzer freigegeben." & vbCrLf & _
            "In dieser Betriebsart ist die " + TOOLHDR + " nicht voll funktionsf|fffd|hig." + vbCrLf + vbCrLf + _
            szMessage, _
            vbInformation, TOOLHDR
    End If
    If ThisWorkbook.ProtectWindows = True Or ThisWorkbook.ProtectStructure = True Then
        ' XL2003: Extras | Schutz, Arbeitsmappenschutz aufheben...
        ' XL2007ff: |fffd|berpr|fffd|fen | Arbeitsmappe sch|fffd|tzen
        Select Case Val(Application.Version)
            Case Is <= 11
                szMessage = Chr(187) & " Entfernen Sie den Schutz |fffd|ber Extras | Schutz, Arbeitsmappenschutz aufheben... bevor Sie weiterarbeiten."
            Case Is >= 12
                szMessage = Chr(187) & " Entfernen Sie den Schutz |fffd|ber |fffd|berpr|fffd|fen | Arbeitsmappe sch|fffd|tzen... bevor Sie weiterarbeiten."
        End Select
        ' Der Anwender hat einen Arbeitsmappenschutz draufgelegt
        MsgBox TOOLID + "022" + vbCrLf + vbCrLf + _
            "Die Arbeitsmappe ist mit einem Schutz versehen worden." + vbCrLf + _
            "In dieser Betriebsart ist die " + TOOLHDR + " nicht voll funktionsf|fffd|hig." + vbCrLf + vbCrLf + _
            szMessage, _
            vbInformation, TOOLHDR
    End If
    Set wsD = Nothing
    
    ' Noch haben wir nichts ge|fffd|ndert...
    ThisWorkbook.Saved = True
End Sub
Attribute VB_Name = "gmodCallbacks"
Option Explicit

Sub DoScreenUpdate(ws As Worksheet)
    Dim i As Long
    Dim bScreenUpdating As Boolean
    Dim bEnableEvents As Boolean
    
    On Error Resume Next
    
    bScreenUpdating = Application.ScreenUpdating
    bEnableEvents = Application.EnableEvents
    
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
    ws.Activate
    
    For i = 1 To 10
        DoEvents
    Next i
    
    Application.EnableEvents = bEnableEvents
    Application.ScreenUpdating = bScreenUpdating
End Sub

Sub UpdateLaufendeNummer(ws As Worksheet)
    Dim lRow As Long
    Dim lCount As Long
    Dim lLfdNr As Long
    Dim lMaxLfdNr As Long
    Dim lLastRow As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    
    Call DoLog("gmodCallbacks.UpdateLaufendeNummer(); funcStart")
    
    ' Worksheet vorbereiten
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    bEnableEvents = Application.EnableEvents
    Application.EnableEvents = False
    
    ' Den Bereich bestimmen
    lLastRow = GetLastUsedRow(ws)
    ' Die gr|fffd||fffd|te Nummer |fffd|ber WorksheetFunction bestimmen
    If lLastRow < ROW_BS_START Then
        lMaxLfdNr = 0
    Else
        On Error Resume Next
        lMaxLfdNr = Application.WorksheetFunction.Max(ws.Range(ws.Cells(ROW_BS_START, COL_AW_LFDNR), ws.Cells(lLastRow, COL_AW_LFDNR)))
        If Err.Number <> 0 Then
            ' Fehler --> dann z|fffd|hlen wir zu Fu|fffd|...
            lCount = 0
            lMaxLfdNr = 0
            For lRow = ROW_BS_START To lLastRow
                Application.StatusBar = "Ermittle laufende Nummer f|fffd|r " + ws.Name + "  " + Format((lRow) * 100 / (lLastRow), "#0.0") + "% fertiggestellt"
                lCount = lCount + 1
                lLfdNr = Val(ws.Cells(lRow, COL_AW_LFDNR).Value)
                If lMaxLfdNr < lLfdNr Then lMaxLfdNr = lLfdNr
            Next lRow
        End If
    End If
    Application.StatusBar = False
    ' Aktuell ermittelte Nummer zur|fffd|ckschreiben wenn n|fffd|tig
    If Val(ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value) < lMaxLfdNr Then
        Call DoLog("gmodCallbacks.UpdateLaufendeNummer(); MaxLfdNr=" + CStr(lMaxLfdNr))
        ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value = lMaxLfdNr
    End If
    
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    Application.EnableEvents = bEnableEvents
    Call DoLog("gmodCallbacks.UpdateLaufendeNummer(); funcEnd")
End Sub

Function SortierenUndValidieren(ws As Worksheet, szMsg As String, Optional bSortDatum As Boolean = False) As Long
    Dim lLast As Long
    Dim l As Long
    Dim lSKey As Long
    Dim lSDataOption As Long
    Dim bFehler As Boolean
    Dim bFehlerNeu As Boolean
    Dim szRow As String
    Dim bScreenUpdate As Boolean
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim rFirstError As Range
    Dim rActiveCell As Range
    
    ' ScreenUpdating ausschalten
    bScreenUpdate = Application.ScreenUpdating
    If bScreenUpdate Then Application.ScreenUpdating = False
    
    ws.Activate
    Set rActiveCell = ActiveCell
    
    ' Blattschutz aufheben
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    
    ' Meldungen zur|fffd|cksetzen
    szMsg = ""
    SortierenUndValidieren = BS_OK
    
    ' |fffd|berpr|fffd|fung auf leeres Sheet
    lLast = GetLastUsedRow(ws)  ' ws.UsedRange.Rows.Count
    If lLast = ROW_BS_START - 1 Then
        SortierenUndValidieren = BS_EMPTY
        szMsg = "Das Kontoblatt enth|fffd|lt keine Eintragungen."
        GoTo AusgangSortierenUndValidieren
    End If
    
    ' Sortierbereich festlegen und sortieren
    If bSortDatum Then
        lSKey = COL_AW_DATUM          ' Sortieren nach Datum (Default)
        lSDataOption = 0
    Else
        lSKey = ws.Cells(ROW_HD_SORT, COL_HD_SORTNUM)           ' Sortieren nach Anwendereinstellung
        lSDataOption = ws.Cells(ROW_HD_SORT, COL_HD_SORTOPT)    ' Zahlen als Text numerisch sortieren?
    End If
    If Val(Application.Version) > 9 Then
        ws.Range(ws.Cells(ROW_BS_START, COL_BS_START), ws.Cells(lLast, COL_OFFSET + COL_ANZAUSWERT)).Select
        Selection.Sort Key1:=ws.Cells(ROW_BS_START, lSKey), Order1:=xlAscending, Header:=xlGuess, _
            OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, DataOption1:=lSDataOption
    Else
        ' Die DataOption1 gab es erst nach Office 2000
        ws.Range(ws.Cells(ROW_BS_START, COL_BS_START), ws.Cells(lLast, COL_OFFSET + COL_ANZAUSWERT)).Select
        Selection.Sort Key1:=ws.Cells(ROW_BS_START, lSKey), Order1:=xlAscending, Header:=xlGuess, _
            OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
    End If
    
    ' Zweite |fffd|berpr|fffd|fung auf leeres Sheet
    ' ...nach dem Sortieren stehen "leere" Zeilen am Ende
    lLast = GetLastUsedRow(ws)
    If lLast < ROW_BS_START Then
        SortierenUndValidieren = BS_EMPTY
        szMsg = "Das Kontoblatt enth|fffd|lt keine Eintragungen."
        GoTo AusgangSortierenUndValidieren
    End If
    
    ' Funktionen in den ausgeblendeten Spalten neu schreiben. Zur Verbesserung der Performance
    ' passiert das in Bl|fffd|cken und nicht Zeilenweise wie in den Vorversionen
    Call UpdateMetadata(ws)
    
    ' Fehlerauswertung
    Set rFirstError = Nothing
    For l = ROW_BS_START To lLast
        bEnableEvents = Application.EnableEvents
        Application.EnableEvents = False
        ' Laufende Nummer vergeben - nur wenn auch was drinn steht
        If Val(ws.Cells(l, COL_AW_USEDCELLS)) > 0 Then
            If [SpalteLfdNrReal] And Val(ws.Cells(l, COL_AW_LFDNR)) > 0 Then
                ws.Cells(l, COL_BS_LFDNR).Value = ws.Cells(l, COL_AW_LFDNR)
            Else
                ws.Cells(l, COL_BS_LFDNR).Value = l - ROW_BS_START + 1
            End If
        End If
        Application.EnableEvents = bEnableEvents
        ' Zeile Pr|fffd|fen
        Application.StatusBar = "Pr|fffd|fe Arbeitsblatt " + ws.Name + "  " + Format((l) * 100 / (lLast), "#0.0") + "% fertiggestellt"
        bFehler = Not Pr|fffd|feZeile(ws, l, szMsg)
        ' Tagesendsaldo einf|fffd|gen, wenn es die Kassenerfassung ist und
        ' nach Datum sortiert wird oder die Option BestandImmerZeigen gesetzt ist
        If TOOLKASSE Then
            ' Teil des Range bestimmen
            szRow = sz2a1(COL_BS_BESTAND)
            ' Farbe zur|fffd|cksetzen
            ws.Range(szRow & l).Interior.ColorIndex = COLOR_LOCKED
            ' Tagessaldo l|fffd|uft nicht in die CRC, also k|fffd|nnen wir die Events ausschalten
            bEnableEvents = Application.EnableEvents
            Application.EnableEvents = False
            ' Tagessaldo kopieren oder l|fffd|schen
            If (lSKey = COL_AW_DATUM And ws.Cells(l, COL_AW_DATECHANGE)) Or [BestandImmerZeigen] Then
                ws.Range(szRow & l) = ws.Cells(l, COL_AW_SALDO).Value
            Else
                ws.Range(szRow & l) = ""
            End If
            ' Bei aktivierter Kassenminuspr|fffd|fung den Bestand evtl. noch markieren
            If ws.Cells(l, COL_AW_DATECHANGE) And lSKey = COL_AW_DATUM And _
               ws.Range(szRow & l) < 0 And [KassePr|fffd|fen] Then
                ' Tagesendsaldo im Minus
                ws.Range(szRow & l).Interior.ColorIndex = COLOR_ERROR
                bFehler = True
                szMsg = szMsg & "Zeile " & l - ROW_BS_START + 1 & ": " & "Negativer Kassenbestand (" & Format(ws.Range(szRow & l), "#,##0.00") & ")" & vbCrLf
            End If
            Application.EnableEvents = bEnableEvents
        End If
        If bFehler And rFirstError Is Nothing Then Set rFirstError = ws.Cells(l, COL_BS_LFDNR)
    Next l
    Application.StatusBar = False
    
    ' Fehler aufgetreten?
    rActiveCell.Select
    If Not rFirstError Is Nothing Then
        SortierenUndValidieren = BS_ERROR
        ' Letzten CRLF im Meldungstext l|fffd|schen
        szMsg = Left(szMsg, Len(szMsg) - 1)
        
        ' Auf den ersten Fehler positionieren
        For l = COL_BS_FIRST To COL_BS_ENDE
            If ws.Cells(rFirstError.Row, l).Interior.ColorIndex = COLOR_ERROR Then
                Set rFirstError = ws.Cells(rFirstError.Row, l)
                Exit For
            End If
        Next l
        If rFirstError.Interior.ColorIndex <> COLOR_STANDARD Then rFirstError.Select
    End If
    
AusgangSortierenUndValidieren:
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    ws.EnableSelection = xlUnlockedCells
    Application.ScreenUpdating = bScreenUpdate
End Function


Sub UpdateStatusColumn(ws As Worksheet)
    Dim lLastRow As Long
    Dim lRow As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    
    If Not LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then Exit Sub
    
    ws.Activate
    
    ' Worksheet vorbereiten
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Den Bereich bestimmen
    lLastRow = GetLastUsedRow(ws)
    
    ' Multiselect beachten
    For lRow = ROW_BS_START To lLastRow
        Application.StatusBar = "Schreibe Statusinformationen f|fffd|r " + ws.Name + "  " + Format((lRow) * 100 / (lLastRow), "#0.0") + "% fertiggestellt"
        DoEvents
        Call UpdateStatusColumnPerRow(ws, lRow)
    Next lRow
    Application.StatusBar = False

    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
End Sub

Sub SetKeyBehaviour()
    Dim szKeyCode As String
    Dim ws As Worksheet
    
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    gbEingabeKontrolle = True
    Application.OnKey "{ENTER}", "WeiterSchalten"
    Application.OnKey "{TAB}", "WeiterSchalten"
    Application.OnKey "~", "WeiterSchalten"
    szKeyCode = ws.Range("InsertTextKey1") + ws.Range("InsertTextKey2")
    If szKeyCode <> "" Then Application.OnKey szKeyCode, "ShowContextMenu"
    On Error GoTo 0
End Sub

Sub ResetKeyBehaviour()
    Dim szKeyCode As String
    Dim ws As Worksheet
    
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    Application.OnKey "{ENTER}"
    Application.OnKey "{TAB}"
    Application.OnKey "~"
    szKeyCode = ws.Range("InsertTextKey1") + ws.Range("InsertTextKey2")
    If szKeyCode <> "" Then Application.OnKey szKeyCode
    On Error GoTo 0
End Sub

Sub DeepResetKeyBehaviour()
    On Error Resume Next
    Application.OnKey "{ENTER}"
    Application.OnKey "{TAB}"
    Application.OnKey "~"
    Application.OnKey "^{F2}"
    On Error GoTo 0
End Sub


Attribute VB_Name = "gmodContextMenuKost"
Option Explicit

Private Const CMDB_NAME = "CM_KostAuswahl"

' Modul-Globale Variablen
Private pWs As Worksheet
Private plRow As Long
Private pRange As Range
'

' Liefert TRUE, wenn das Statusmen|fffd| angezeigt wird, liefert FALSE, wenn das
' Standard Kontextmen|fffd| angezeigt werden soll.
Public Function ContextMenu_KostAuswahl(r As Range) As Boolean
    Dim myBar As CommandBar
    Dim myPopup As CommandBarControl
    Dim bStartGroup As Boolean
    
    On Error GoTo ERR_ContextMenu_KostAuswahl
    Call DoLog("ContextMenu_KostAuswahl(); funcStart")

    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    Set myBar = CommandBars.Add(Name:=CMDB_NAME, Position:=msoBarPopup, Temporary:=False)
    With myBar
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Kostenstelle einf|fffd|gen..."
        myPopup.OnAction = "CMT_AuswahlKost"
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Zur Vorlage Kostenstellen wechseln"
        myPopup.OnAction = "CMT_ShowKost"
    End With
    
    On Error GoTo ERR_ContextMenu_KostAuswahl_LFZ_9
    bStartGroup = True
    For Each myPopup In Application.CommandBars("cell").Controls
        myPopup.Copy Bar:=myBar
        If myPopup.BeginGroup Or bStartGroup Then
            myBar.Controls(myBar.Controls.Count).BeginGroup = True
            bStartGroup = False
        End If
    Next
    
    On Error GoTo ERR_ContextMenu_KostAuswahl
    myBar.ShowPopup
    myBar.Delete
    
    Set pWs = Nothing
    Set pRange = Nothing
    plRow = 0

    ' Kein Standard-Kontext Men|fffd|
    ContextMenu_KostAuswahl = True
    Call DoLog("ContextMenu_KostAuswahl(); funcEnd")
    On Error GoTo 0
    Exit Function

ERR_ContextMenu_KostAuswahl_LFZ_9:
    Call DoLogPerm("ContextMenu_KostAuswahl(); Problem bei Commandbars(""cell""); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
    
ERR_ContextMenu_KostAuswahl:
    Call DoLogPerm("ContextMenu_KostAuswahl(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number = 5 Then
        CommandBars(CMDB_NAME).Delete
        Resume Next
    End If
    ContextMenu_KostAuswahl = False
    Call DoLog("ContextMenu_KostAuswahl(); funcExit")
    On Error GoTo 0
End Function

'**************************************************************************
'*                                                                        *
'*   Funktionen f|fffd|r das Kontextmen|fffd| zu Spalten Kost1 und Kost2            *
'*                                                                        *
'**************************************************************************

Public Sub CMT_AuswahlKost()
    Dim fmAuswahl As gfrmTextAuswahl
    Dim vSplit As Variant
    Dim objMain As Object
    Dim bRetVal As Boolean
    
    Call DoLog("CMT_AuswahlKost(); funcStart")
    
    Set objMain = MainServer("KWEVorlagen")
    If Not objMain Is Nothing Then
        ' Methode aufrufen
        ' Kostenstelle aus Vorlage in Erfassungseite einf|fffd|gen
        bRetVal = objMain.AuswahlKost(pRange)
        Set objMain = Nothing
        Call DoLog("CMT_AuswahlKost(); funcEnd")
        Exit Sub
    End If
    
    Call DoLog("CMT_AuswahlKost(); Using Builtin")
    
    On Error GoTo ERR_AuswahlKost
    Set fmAuswahl = New gfrmTextAuswahl
    fmAuswahl.Spalte = pRange.Column ' - COL_BS_START + 1
    fmAuswahl.Pattern = pRange.Value
    fmAuswahl.Show
    If Not fmAuswahl.Abbruch Then
        gbEingabeKontrolle = True
        ' Ausgew|fffd|hlte Werte einlesen
        vSplit = Split(fmAuswahl.TextAuswahl, "#")
        pRange = CStr(vSplit(0))
    End If
    GoTo END_AuswahlKost
    
ERR_AuswahlKost:
    Call DoLogPerm("CMT_AuswahlKost(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_AuswahlKost:
    On Error Resume Next
    Unload fmAuswahl
    Set fmAuswahl = Nothing
    Call DoLog("CMT_AuswahlKost(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMT_ShowKost()
    Dim lRowCount As Long
        
    ' Zeile des letzten Eintrags ermitteln
    lRowCount = ROW_KOST_START
    Do While Trim(ThisWorkbook.Worksheets(TAB_KOST).Cells(lRowCount, COL_KOST_KOST).Value) <> ""
        lRowCount = lRowCount + 1
    Loop

    ThisWorkbook.Worksheets(TAB_KOST).Activate
    ActiveSheet.Cells(lRowCount, COL_KOST_KOST).Select
End Sub

Attribute VB_Name = "gmodContextMenuStatus"
Option Explicit

Private Const CMDB_NAME = "CM_Status"

' Globale Variablen
Private pWs As Worksheet
Private plRow As Long
Private pRange As Range
Private pBShowDate As Boolean
'

' Liefert TRUE, wenn das Statusmen|fffd| angezeigt wird, liefert FALSE, wenn das
' Standard Kontextmen|fffd| angezeigt werden soll.
Public Function ContextMenu_Status(r As Range) As Boolean
    Dim myBar As CommandBar
    Dim myPopup As CommandBarControl
    Dim bShowDate As Boolean
    
    On Error GoTo ERR_ContextMenu_Status
    Call DoLog("ContextMenu_Status(); funcStart")
    
    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    pBShowDate = [ShowDateOnStatus]
    
    Set myBar = CommandBars.Add(Name:=CMDB_NAME, Position:=msoBarPopup, Temporary:=False)
    With myBar
        ' Pseudolabel "Angelegt"
        If IsDate(pWs.Cells(r.Row, COL_AW_DAT_CREATED).Value) Then
            Set myPopup = .Controls.Add(Type:=msoControlButton)
            myPopup.Caption = "Angelegt" + IIf(pBShowDate, ":      " + Format(pWs.Cells(r.Row, COL_AW_DAT_CREATED).Value, "dd.mm.yyyy HH:MM:SS"), "")
            myPopup.Enabled = False
        Else
            If pBShowDate Then
                Set myPopup = .Controls.Add(Type:=msoControlButton)
                myPopup.Caption = "Angelegt:      (Kein korrekter Buchungssatz)"
                myPopup.Enabled = False
            End If
        End If
        ' Pseudolabel "Ge|fffd|ndert"
        If IsDate(pWs.Cells(r.Row, COL_AW_DAT_CHANGED).Value) And _
            pWs.Cells(r.Row, COL_AW_DAT_CREATED).Value <> pWs.Cells(r.Row, COL_AW_DAT_CHANGED).Value Then
            Set myPopup = .Controls.Add(Type:=msoControlButton)
            myPopup.Caption = "Ge|fffd|ndert" + IIf(pBShowDate, ":  " + Format(pWs.Cells(r.Row, COL_AW_DAT_CHANGED).Value, "dd.mm.yyyy HH:MM:SS"), "")
            myPopup.Enabled = False
        End If
        ' Pseudolabel "Gepr|fffd|ft"
        If IsDate(pWs.Cells(r.Row, COL_AW_DAT_CHECKED).Value) Then
            Set myPopup = .Controls.Add(Type:=msoControlButton)
            myPopup.Caption = "Gepr|fffd|ft" + IIf(pBShowDate, ":    " + Format(pWs.Cells(r.Row, COL_AW_DAT_CHECKED).Value, "dd.mm.yyyy HH:MM:SS"), "")
            myPopup.Enabled = False
        Else
            If pBShowDate Then
                Set myPopup = .Controls.Add(Type:=msoControlButton)
                myPopup.Caption = "Gepr|fffd|ft:     (ungepr|fffd|ft)"
                myPopup.Enabled = False
            End If
        End If
        ' Pseudolabel "Exportiert"
        If IsDate(pWs.Cells(r.Row, COL_AW_DAT_EXPORTED).Value) Then
            Set myPopup = .Controls.Add(Type:=msoControlButton)
            myPopup.Caption = "Exportiert" + IIf(pBShowDate, ":  " + Format(pWs.Cells(r.Row, COL_AW_DAT_EXPORTED).Value, "dd.mm.yyyy HH:MM:SS"), "")
            myPopup.Enabled = False
        Else
            If pBShowDate Then
                Set myPopup = .Controls.Add(Type:=msoControlButton)
                myPopup.Caption = "Exportiert:  (nicht exportiert)"
                myPopup.Enabled = False
            End If
        End If
        ' Pseudolabel "Zu pr|fffd|fen"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Status Gepr|fffd|ft setzen"
        myPopup.OnAction = "CMS_DateCheckedSet"
        myPopup.BeginGroup = True
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Status Gepr|fffd|ft l|fffd|schen"
        myPopup.OnAction = "CMS_DateCheckedDelete"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Alle Status Gepr|fffd|ft l|fffd|schen"
        myPopup.OnAction = "CMS_DateCheckedDeleteAll"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Status Zu pr|fffd|fen setzen"
        myPopup.OnAction = "CMS_StatusToCheckSet"
        myPopup.BeginGroup = True
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Status Zu pr|fffd|fen l|fffd|schen"
        myPopup.OnAction = "CMS_StatusToCheckDelete"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Alle ungepr|fffd|ften auf Zu pr|fffd|fen setzen"
        myPopup.OnAction = "CMS_StatusToCheckSetUnchecked"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Alle Status Zu pr|fffd|fen setzen"
        myPopup.OnAction = "CMS_StatusToCheckSetAll"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Alle Status Zu pr|fffd|fen l|fffd|schen"
        myPopup.OnAction = "CMS_StatusToCheckDeleteAll"
        '
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Status aktualisieren"
        myPopup.OnAction = "CMS_UpdateStatus"
        myPopup.BeginGroup = True
    End With
    myBar.ShowPopup
    myBar.Delete
    
    Set pWs = Nothing
    Set pRange = Nothing
    plRow = 0

    ' Kein Standard-Kontext Men|fffd|
    ContextMenu_Status = True
    Call DoLog("ContextMenu_Status(); funcEnd")
    On Error GoTo 0
    Exit Function
    
ERR_ContextMenu_Status:
    Call DoLogPerm("ContextMenu_Status(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number = 5 Then
        CommandBars(CMDB_NAME).Delete
        Resume Next
    End If
    ContextMenu_Status = False
    On Error GoTo 0
    Call DoLog("ContextMenu_Status(); funcExit")
End Function


'****************************************************************
'*                                                              *
'*   Private Funktionen f|fffd|r das Kontextmen|fffd| zur Spalte Status   *
'*                                                              *
'****************************************************************

Public Sub CMS_DateCheckedSet()
    Dim lRow As Long
    Dim lCol As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim r As Range
    Dim bExportedRows As Boolean
    Dim bRowNotValid As Boolean
    Dim dChecked As Date
    Dim szMsg As String
    
    On Error GoTo ERR_CMS_DateCheckedSet
    Call DoLog("CMS_DateCheckedSet(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then
        Call DoLog("CMS_DateCheckedSet(); funcExit")
        Exit Sub
    End If
    
    dChecked = Now
    bExportedRows = False
    bRowNotValid = False
    
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Multiselect beachten
    For Each r In pRange.Rows
        lRow = r.Row
        ' Datum gepr|fffd|ft nur setzen, wenn noch nicht exportiert und Zeile g|fffd|ltig ist
        If IsDate(pWs.Cells(lRow, COL_AW_DAT_EXPORTED).Value) Then
            ' Zeile bereits exportiert
            bExportedRows = True
        ElseIf Not IsDate(pWs.Cells(lRow, COL_AW_DAT_CREATED).Value) Then
            ' Zeile noch gar nicht g|fffd|ltig
            bRowNotValid = True
        Else
            ' Alles ok....
            ' Datum Gepr|fffd|ft setzen
            pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value = dChecked
            ' Flag zu pr|fffd|fen zur|fffd|cknehmen
            pWs.Cells(lRow, COL_AW_TOCHECK).Value = 0
            ' Status anpassen
            Call UpdateStatusColumnPerRow(pWs, lRow)
            ' Eingabefelder sperren
            For lCol = COL_BS_FIRST To COL_BS_ENDE
                If lCol <> COL_BS_BESTAND And lCol <> COL_BS_BEZAHLT Then
                    ' Sperre setzen
                    pWs.Cells(lRow, lCol).Locked = True
                End If
            Next lCol
        End If
    Next r
    
    ' Meldung bei Bedarf
    szMsg = ""
    If bExportedRows Then
        szMsg = "Bereits exportierte Zeilen k|fffd|nnen nicht mehr auf ""gepr|fffd|ft"" gesetzt werden." + vbCrLf
    End If
    If bRowNotValid Then
        szMsg = szMsg + "Zeilen, die keinen minimal g|fffd|ltigen Buchungssatz enthalten k|fffd|nnen nicht auf ""gepr|fffd|ft"" gesetzt werden." + vbCrLf
    End If
    If szMsg <> "" Then
        MsgBox TOOLID + "028" + vbCrLf + vbCrLf + _
            szMsg + "Diese Zeilen wurden von der |fffd|nderung ausgeschlossen.", _
            vbInformation, TOOLHDR
    End If
    GoTo END_CMS_DateCheckedSet
    
ERR_CMS_DateCheckedSet:
    Call DoLogPerm("CMS_DateCheckedSet(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMS_DateCheckedSet:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_DateCheckedSet(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_DateCheckedDelete()
    Dim lRow As Long
    Dim lCol As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim r As Range
    Dim bExportedRows As Boolean
        
    On Error GoTo ERR_CMS_DateCheckedDelete
    Call DoLog("CMS_DateCheckedDelete(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then
        Call DoLog("CMS_DateCheckedDelete(); funcExit")
        Exit Sub
    End If
    
    bExportedRows = False
    
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Multiselect beachten
    For Each r In pRange.Rows
        lRow = r.Row
        ' Datum gepr|fffd|ft nur zur|fffd|cksetzen, wenn noch nicht exportiert
        If Not IsDate(pWs.Cells(lRow, COL_AW_DAT_EXPORTED).Value) Then
            ' Datum Gepr|fffd|ft l|fffd|schen
            pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value = ""
            ' Status anpassen
            Call UpdateStatusColumnPerRow(pWs, lRow)
            ' Eingabefelder Sperre aufheben
            For lCol = COL_BS_FIRST To COL_BS_ENDE
                If lCol <> COL_BS_BESTAND Then
                    pWs.Cells(lRow, lCol).Locked = False
                End If
            Next lCol
        Else
            bExportedRows = True
        End If
    Next r

    ' Meldung bei Bedarf
    If bExportedRows Then
        MsgBox TOOLID + "029" + vbCrLf + vbCrLf + _
            "Bereits exportierte Zeilen k|fffd|nnen nicht mehr ver|fffd|ndert werden." + vbCrLf + _
            "Diese Zeilen wurden von der |fffd|nderung ausgeschlossen.", _
            vbInformation, TOOLHDR
    End If
    GoTo END_CMS_DateCheckedDelete
    
ERR_CMS_DateCheckedDelete:
    Call DoLogPerm("CMS_DateCheckedDelete(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
END_CMS_DateCheckedDelete:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_DateCheckedDelete(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_DateCheckedDeleteAll()
    Dim lRow As Long
    Dim lCol As Long
    Dim lLast As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim bExportedRows As Boolean
    
    On Error GoTo ERR_CMS_DateCheckedDeleteAll
    Call DoLog("CMS_DateCheckedDeleteAll(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then GoTo END_CMS_DateCheckedDeleteAll
    
    ' Letzte Buchungszeile bestimmen und evtl. korrigieren
    lLast = GetLastUsedRow(pWs)
    
    ' |fffd|berpr|fffd|fung auf leeres Sheet
    If lLast < ROW_BS_START Then GoTo END_CMS_DateCheckedDeleteAll
        
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Alle Zeilen durchlaufen
    bExportedRows = False
    For lRow = ROW_BS_START To lLast
        If Not IsDate(pWs.Cells(lRow, COL_AW_DAT_EXPORTED).Value) And IsDate(pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value) Then
            pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value = ""
            ' Status anpassen
            Call UpdateStatusColumnPerRow(pWs, lRow)
            ' Eingabefelder Sperre aufheben
            For lCol = COL_BS_FIRST To COL_BS_ENDE
                If lCol <> COL_BS_BESTAND Then
                    pWs.Cells(lRow, lCol).Locked = False
                End If
            Next lCol
        Else
            bExportedRows = True
        End If
    Next lRow
    
    ' Meldung |fffd|ber gesperrte Zeilen?
    If bExportedRows Then
        MsgBox TOOLID + "030" + vbCrLf + vbCrLf + _
            "Bereits exportierte Zeilen k|fffd|nnen nicht mehr ver|fffd|ndert werden." + vbCrLf + _
            "Diese Zeilen wurden von der |fffd|nderung ausgeschlossen.", _
            vbInformation, TOOLHDR
    End If
    GoTo END_CMS_DateCheckedDeleteAll
    
ERR_CMS_DateCheckedDeleteAll:
    Call DoLogPerm("CMS_DateCheckedDeleteAll(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
    
END_CMS_DateCheckedDeleteAll:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_DateCheckedDeleteAll(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_StatusToCheckSet()
    Dim lRow As Long
    Dim r As Range
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim bExportedRows As Boolean
    
    On Error GoTo ERR_CMS_StatusToCheckSet
    Call DoLog("CMS_StatusToCheckSet(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then GoTo END_CMS_StatusToCheckSet
    
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Multiselect beachten
    bExportedRows = False
    For Each r In pRange.Rows
        lRow = r.Row
        ' Status nur setzen, wenn noch nicht exportiert und noch nicht gepr|fffd|ft wurde
        If IsDate(pWs.Cells(lRow, COL_AW_DAT_EXPORTED).Value) Then
            ' Zeile bereits exportiert
            bExportedRows = True
        Else
            ' Alles ok....
            ' Flag setzen
            pWs.Cells(lRow, COL_AW_TOCHECK).Value = 1
            ' Datum gepr|fffd|ft l|fffd|schen
            pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value = ""
            ' Status setzen
            Call UpdateStatusColumnPerRow(pWs, lRow)
        End If
    Next
    
    ' Meldung bei Bedarf
    If bExportedRows Then
        MsgBox TOOLID + "021" + vbCrLf + vbCrLf + _
            "Bereits exportierte Zeilen k|fffd|nnen nicht mehr auf ""zu pr|fffd|fen"" gesetzt werden.", _
            vbInformation, TOOLHDR
    End If
    GoTo END_CMS_StatusToCheckSet
    
ERR_CMS_StatusToCheckSet:
    Call DoLogPerm("CMS_StatusToCheckSet(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMS_StatusToCheckSet:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_StatusToCheckSet(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_StatusToCheckDelete()
    Dim lRow As Long
    Dim r As Range
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    
    On Error GoTo ERR_CMS_StatusToCheckDelete
    Call DoLog("CMS_StatusToCheckDelete(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then GoTo END_CMS_StatusToCheckDelete
    
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Multiselect beachten
    For Each r In pRange.Rows
        lRow = r.Row
        pWs.Cells(lRow, COL_AW_TOCHECK).Value = 0
        Call UpdateStatusColumnPerRow(pWs, lRow)
    Next
    GoTo END_CMS_StatusToCheckDelete
    
ERR_CMS_StatusToCheckDelete:
    Call DoLogPerm("CMS_StatusToCheckDelete(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMS_StatusToCheckDelete:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_StatusToCheckDelete(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_StatusToCheckSetUnchecked()
    Dim lRow As Long
    Dim lLast As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim bExportedRows As Boolean
    
    On Error GoTo ERR_CMS_StatusToCheckSetUnchecked
    Call DoLog("CMS_StatusToCheckSetUnchecked(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then GoTo END_CMS_StatusToCheckSetUnchecked
    
    ' Letzte Buchungszeile bestimmen und evtl. korrigieren
    lLast = GetLastUsedRow(pWs)
    ' |fffd|berpr|fffd|fung auf leeres Sheet
    If lLast < ROW_BS_START Then GoTo END_CMS_StatusToCheckSetUnchecked
        
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If Application.EnableEvents = False Then Application.EnableEvents = False
    
    ' Alle Zeilen durchlaufen
    bExportedRows = False
    For lRow = ROW_BS_START To lLast
        ' Status nur setzen, wenn noch nicht exportiert und noch nicht gepr|fffd|ft wurde
        If IsDate(pWs.Cells(lRow, COL_AW_DAT_EXPORTED).Value) Or IsDate(pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value) Then
            ' Zeile bereits exportiert oder gepr|fffd|ft
            bExportedRows = True
        Else
            ' Alles ok....
            ' Flag setzen
            pWs.Cells(lRow, COL_AW_TOCHECK).Value = 1
            ' Status setzen
            Call UpdateStatusColumnPerRow(pWs, lRow)
        End If
    Next

    ' Meldung bei Bedarf
    If bExportedRows Then
        MsgBox TOOLID + "024" + vbCrLf + vbCrLf + _
            "Bereits exportierte Zeilen wurden nicht auf ""zu pr|fffd|fen"" gesetzt.", _
            vbInformation, TOOLHDR
    End If
    GoTo END_CMS_StatusToCheckSetUnchecked
    
ERR_CMS_StatusToCheckSetUnchecked:
    Call DoLogPerm("CMS_StatusToCheckSetUnchecked(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMS_StatusToCheckSetUnchecked:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_StatusToCheckSetUnchecked(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_StatusToCheckSetAll()
    Dim lRow As Long
    Dim lLast As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim bExportedRows As Boolean
    
    On Error GoTo ERR_CMS_StatusToCheckSetAll
    Call DoLog("CMS_StatusToCheckSetAll(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then GoTo END_CMS_StatusToCheckSetAll
    
    ' Letzte Buchungszeile bestimmen und evtl. korrigieren
    lLast = GetLastUsedRow(pWs)
    ' |fffd|berpr|fffd|fung auf leeres Sheet
    If lLast < ROW_BS_START Then GoTo END_CMS_StatusToCheckSetAll
        
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Alle Zeilen durchlaufen
    bExportedRows = False
    For lRow = ROW_BS_START To lLast
        ' Status nur setzen, wenn noch nicht exportiert und noch nicht gepr|fffd|ft wurde
        If IsDate(pWs.Cells(lRow, COL_AW_DAT_EXPORTED).Value) Then
            ' Zeile bereits exportiert
            bExportedRows = True
        Else
            ' Alles ok....
            ' Flag setzen und Datum gepr|fffd|ft l|fffd|schen
            pWs.Cells(lRow, COL_AW_TOCHECK).Value = 1
            pWs.Cells(lRow, COL_AW_DAT_CHECKED).Value = ""
            Call UpdateStatusColumnPerRow(pWs, lRow)
        End If
    Next

    ' Meldung bei Bedarf
    If bExportedRows Then
        MsgBox TOOLID + "026" + vbCrLf + vbCrLf + _
            "Bereits exportierte Zeilen wurden nicht auf ""zu pr|fffd|fen"" gesetzt.", _
            vbInformation, TOOLHDR
    End If
    GoTo END_CMS_StatusToCheckSetAll
    
ERR_CMS_StatusToCheckSetAll:
    Call DoLogPerm("CMS_StatusToCheckSetAll(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMS_StatusToCheckSetAll:
    On Error Resume Next
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_StatusToCheckSetAll(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_StatusToCheckDeleteAll()
    Dim lRow As Long
    Dim lLast As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    
    On Error GoTo ERR_CMS_StatusToCheckDeleteAll
    Call DoLog("CMS_StatusToCheckDeleteAll(); funcStart")
    
    If pWs Is Nothing Or plRow < ROW_BS_START Then GoTo END_CMS_StatusToCheckDeleteAll
    
    ' Letzte Buchungszeile bestimmen und evtl. korrigieren
    lLast = GetLastUsedRow(pWs)
    ' |fffd|berpr|fffd|fung auf leeres Sheet
    If lLast < ROW_BS_START Then GoTo END_CMS_StatusToCheckDeleteAll
        
    ' Worksheet vorbereiten
    bProtected = pWs.ProtectContents
    If bProtected Then pWs.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Alle Zeilen durchlaufen
    For lRow = ROW_BS_START To lLast
        If pWs.Cells(lRow, COL_AW_TOCHECK).Value <> 0 Then
            pWs.Cells(lRow, COL_AW_TOCHECK).Value = 0
            Call UpdateStatusColumnPerRow(pWs, lRow)
        End If
    Next
    GoTo END_CMS_StatusToCheckDeleteAll
    
ERR_CMS_StatusToCheckDeleteAll:
    Call DoLogPerm("CMS_StatusToCheckDeleteAll(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    On Error Resume Next
    
END_CMS_StatusToCheckDeleteAll:
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("CMS_StatusToCheckDeleteAll(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub UpdateStatusColumnPerRow(ws As Worksheet, lRow As Long)
    Dim lLastRow As Long
    Dim lCol As Long
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim r As Range
    Dim bShowDate As Boolean
    Dim bLockLine As Boolean
    Dim szText As String
    
    On Error GoTo ERR_UpdateStatusColumnPerRow
    Call DoLog("UpdateStatusColumnPerRow(); funcStart")
    
    If Not LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
        GoTo END_UpdateStatusColumnPerRow
    End If
    
    bShowDate = [ShowDateOnStatus]
    ws.Activate
    
    ' Worksheet vorbereiten
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Farbe setzen
    If ws.Cells(lRow, COL_BS_STATUS).Interior.ColorIndex <> ws.Cells(lRow, COL_AW_STATUSCOLOR) Then
        ws.Cells(lRow, COL_BS_STATUS).Interior.ColorIndex = ws.Cells(lRow, COL_AW_STATUSCOLOR)
    End If
    ' Eingabezellen sch|fffd|tzen
    If IsDate(ws.Cells(lRow, COL_AW_DAT_EXPORTED).Value) Or Val(ws.Cells(lRow, COL_AW_EXPORTSTATUS).Value) = 2 Then
        bLockLine = True
    ElseIf IsDate(ws.Cells(lRow, COL_AW_DAT_CHECKED).Value) Then
        bLockLine = True
    Else
        bLockLine = False
    End If
    For lCol = COL_BS_FIRST To COL_BS_ENDE
        Select Case lCol
            ' Spalten, die immer gesperrt oder ungesperrt bleiben
            Case COL_BS_BESTAND, COL_BS_BEZAHLT
                ' Nichts tun
            ' Optionale Spalten, die nicht ausgeblendet, sondern gesperrt werden
            Case COL_BS_SKONTO
                If [OptSpalteSkonto] Then
                    ' Sperre aufheben/setzen
                    If ws.Cells(lRow, lCol).Locked <> bLockLine Then
                        ws.Cells(lRow, lCol).Locked = bLockLine
                    End If
                End If
            Case COL_BS_GEGENKTO, COL_BS_B, COL_BS_U
                If [OptSpalteGegenkonto] Then
                    ' Sperre aufheben/setzen
                    If ws.Cells(lRow, lCol).Locked <> bLockLine Then
                        ws.Cells(lRow, lCol).Locked = bLockLine
                    End If
                End If
            Case COL_BS_UST
                If [OptSpalteUst] Then
                    ' Sperre aufheben/setzen
                    If ws.Cells(lRow, lCol).Locked <> bLockLine Then
                        ws.Cells(lRow, lCol).Locked = bLockLine
                    End If
                End If
            ' Alle anderen Spalten
            Case Else
                ' Sperre aufheben/setzen
                If ws.Cells(lRow, lCol).Locked <> bLockLine Then
                    ws.Cells(lRow, lCol).Locked = bLockLine
                End If
        End Select
            
'        If lCol <> COL_BS_BESTAND And lCol <> COL_BS_BEZAHLT Then
'            ' Sperre aufheben/setzen
'            If ws.Cells(lRow, lCol).Locked <> bLockLine Then
'                ws.Cells(lRow, lCol).Locked = bLockLine
'            End If
'        End If
    Next lCol
    GoTo END_UpdateStatusColumnPerRow
    
ERR_UpdateStatusColumnPerRow:
    Call DoLogPerm("UpdateStatusColumnPerRow(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    On Error Resume Next
    
END_UpdateStatusColumnPerRow:
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then pWs.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Call DoLog("UpdateStatusColumnPerRow(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMS_UpdateStatus()
    Call UpdateStatusColumn(ActiveSheet)
End Sub

Attribute VB_Name = "gmodContextMenuText"
Option Explicit

Private Const CMDB_NAME = "CM_TextAuswahl"

' Modul-Globale Variablen
Private pWs As Worksheet
Private plRow As Long
Private pRange As Range
'

Public Sub ShowContextMenuText(r As Range, bText As Boolean)
    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    If bText Then
        Call CMT_TextAuswahl
    Else
        Call CMT_KostAuswahl
    End If
End Sub

' Liefert TRUE, wenn das Statusmen|fffd| angezeigt wird, liefert FALSE, wenn das
' Standard Kontextmen|fffd| angezeigt werden soll.
Public Function ContextMenu_TextAuswahl(r As Range) As Boolean
    Dim myBar As CommandBar
    Dim myPopup As CommandBarControl
    Dim bStartGroup As Boolean
    
    On Error GoTo ERR_ContextMenu_TextAuswahl
    Call DoLog("ContextMenu_TextAuswahl(); funcStart")

    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    Set myBar = CommandBars.Add(Name:=CMDB_NAME, Position:=msoBarPopup, Temporary:=False)
    With myBar
        ' Kostenstellen
        If r.Column = COL_BS_KOST1 Or r.Column = COL_BS_KOST2 Then
            Set myPopup = .Controls.Add(Type:=msoControlButton)
            myPopup.Caption = "Kostenstelle einf|fffd|gen..."
            myPopup.OnAction = "CMT_KostAuswahl"
        End If
        ' Textvorlagen
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Text einf|fffd|gen..."
        myPopup.OnAction = "CMT_TextAuswahl"
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Text der Vorlage hinzuf|fffd|gen"
        myPopup.OnAction = "CMT_CopyText"
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Zur Textvorlage wechseln"
        myPopup.OnAction = "CMT_ShowText"
        ' Buchen
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.BeginGroup = True
        myPopup.Caption = "Stapelerfassung"
        myPopup.OnAction = "CMT_Dialogbuchen"
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Buchung aufteilen"
        myPopup.OnAction = "CMT_SplitBuchung"
    End With
    
    On Error GoTo ERR_ContextMenu_TextAuswahl_LFZ_9
    bStartGroup = True
    For Each myPopup In Application.CommandBars("cell").Controls
        myPopup.Copy Bar:=myBar
        If myPopup.BeginGroup Or bStartGroup Then
            myBar.Controls(myBar.Controls.Count).BeginGroup = True
            bStartGroup = False
        End If
    Next
    
    On Error GoTo ERR_ContextMenu_TextAuswahl
    myBar.ShowPopup
    myBar.Delete
    
    Set pWs = Nothing
    Set pRange = Nothing
    plRow = 0

    ' Kein Standard-Kontext Men|fffd|
    ContextMenu_TextAuswahl = True
    Call DoLog("ContextMenu_TextAuswahl(); funcEnd")
    On Error GoTo 0
    Exit Function

ERR_ContextMenu_TextAuswahl_LFZ_9:
    Call DoLogPerm("ContextMenu_TextAuswahl(); Problem bei Commandbars(""cell""); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
    
ERR_ContextMenu_TextAuswahl:
    Call DoLogPerm("ContextMenu_TextAuswahl(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number = 5 Then
        CommandBars(CMDB_NAME).Delete
        Resume Next
    End If
    ContextMenu_TextAuswahl = False
    Call DoLog("ContextMenu_TextAuswahl(); funcExit")
    On Error GoTo 0
End Function

'**************************************************************************
'*                                                                        *
'*   Funktionen f|fffd|r das Kontextmen|fffd| zu Spalten Kost1/2, Buchungstext und  *
'*   Konto/Gegenkonto                                                     *
'*                                                                        *
'**************************************************************************

Public Sub CMT_KostAuswahl()
    Dim fmAuswahl As gfrmTextAuswahl
    Dim vSplit As Variant
    Dim objMain As Object
    Dim bRetVal As Boolean
    
    On Error GoTo ERR_CMT_KostAuswahl
    Call DoLog("CMT_KostAuswahl(); funcStart")
    
    Set objMain = MainServer("KWEVorlagen")
    If Not objMain Is Nothing Then
        ' Methode aufrufen
        ' Kostenstelle aus Vorlage in Erfassungseite einf|fffd|gen
        bRetVal = objMain.AuswahlKost(pRange)
        Set objMain = Nothing
        Call DoLog("CMT_KostAuswahl(); funcEnd")
        Exit Sub
    End If
    
    Call DoLog("CMT_AuswahlKost(); Using Builtin")
    On Error GoTo ERR_CMT_KostAuswahl
    
    Set fmAuswahl = New gfrmTextAuswahl
    fmAuswahl.Spalte = pRange.Column ' - COL_BS_START + 1
    fmAuswahl.Pattern = pRange.Value
    fmAuswahl.Show
    If Not fmAuswahl.Abbruch Then
        gbEingabeKontrolle = True
        ' Ausgew|fffd|hlte Werte einlesen
        vSplit = Split(fmAuswahl.TextAuswahl, "#")
        pRange = CStr(vSplit(0))
    End If
    GoTo END_CMT_KostAuswahl
    
ERR_CMT_KostAuswahl:
    Call DoLogPerm("CMT_KostAuswahl(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMT_KostAuswahl:
    On Error Resume Next
    Unload fmAuswahl
    Set fmAuswahl = Nothing
    Call DoLog("CMT_KostAuswahl(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMT_TextAuswahl()
    Dim szCurText As String
    Dim szText As String        ' Text oder Name/Ort
    Dim szWarenart As String       ' Warenart
    Dim szKonto As String       ' Nur Ware
    Dim szGegenKto As String
    Dim szKost1 As String
    Dim szKost2 As String
    Dim fmAuswahl As gfrmTextAuswahl
    Dim lPos As Long
    Dim lKto As Long
    Dim rRange As Range
    Dim ws As Worksheet
    Dim vSplit As Variant
    Dim bOverwrite As Boolean
    Dim objMain As Object
    Dim bRetVal As Boolean
    
    On Error GoTo ERR_CMT_TextAuswahl
    Call DoLog("CMT_TextAuswahl(); funcStart")
    
    Set objMain = MainServer("KWEVorlagen")
    If Not objMain Is Nothing Then
        ' Methode aufrufen
        ' Textvorlage in Erfassungsseite einf|fffd|gen
        bRetVal = objMain.AuswahlText(pRange)
        Set objMain = Nothing
        Call DoLog("CMT_TextAuswahl(); funcEnd")
        Exit Sub
    End If
    
    Call DoLog("CMT_TextAuswahl(); Using Builtin")
    On Error GoTo ERR_CMT_TextAuswahl
    
    ' Nur Bordmittel
    Set fmAuswahl = New gfrmTextAuswahl
    fmAuswahl.Spalte = pRange.Column ' - COL_BS_START + 1
    fmAuswahl.Pattern = pRange.Value
    fmAuswahl.Show
    On Error GoTo 0
    If Not fmAuswahl.Abbruch Then
        gbEingabeKontrolle = True
        bOverwrite = fmAuswahl.Overwrite
        ' Ausgew|fffd|hlte Werte einlesen
        vSplit = Split(fmAuswahl.TextAuswahl, "#")
        If [TOOLKASSE] Then
            ' Kassenerfassung
            szKonto = ""
            szGegenKto = CStr(vSplit(0))
            szText = CStr(vSplit(1))
            szWarenart = ""
            szKost1 = CStr(vSplit(2))
            szKost2 = CStr(vSplit(3))
        Else
            szKonto = CStr(vSplit(0))
            szGegenKto = CStr(vSplit(1))
            szText = CStr(vSplit(2))
            szWarenart = CStr(vSplit(3))
            szKost1 = CStr(vSplit(4))
            szKost2 = CStr(vSplit(5))
        End If
        ' Und jetzt alles wegschreiben...
        With pRange
            ' 1a. Text oder Name/Ort (eine von beiden Spalten ist immer 0!)
            If szText <> "" And _
               (bOverwrite Or _
                .Column = COL_BS_TEXT + COL_BS_NAMEORT Or _
                .Parent.Cells(pRange.Row, COL_BS_TEXT + COL_BS_NAMEORT) = "" _
               ) Then
                
                pRange.Parent.Cells(pRange.Row, COL_BS_TEXT + COL_BS_NAMEORT) = szText
            End If
            
            ' 1b. Warenart (in der Kasse immer 0)
            If szWarenart <> "" And COL_BS_WARENART > 0 Then
                If bOverwrite Or .Column = COL_BS_WARENART Or .Parent.Cells(pRange.Row, COL_BS_WARENART) = "" Then
                    pRange.Parent.Cells(pRange.Row, COL_BS_WARENART) = szWarenart
                End If
            End If
            
            ' 2a. Konto (in der Kasse immer 0)
            If szKonto <> "" And Val(szKonto) > 0 And COL_BS_KONTO > 0 Then
                If bOverwrite Or .Column = COL_BS_KONTO Or .Parent.Cells(pRange.Row, COL_BS_KONTO) = "" Then
                    pRange.Parent.Cells(pRange.Row, COL_BS_KONTO) = szKonto
                End If
            End If
            
            ' 2b. Gegenkonto
            If szGegenKto <> "" And Val(szGegenKto) > 0 And _
               (bOverwrite Or _
                .Column = COL_BS_GEGENKTO Or _
                .Parent.Cells(pRange.Row, COL_BS_GEGENKTO) = "" _
               ) Then
                
                pRange.Parent.Cells(pRange.Row, COL_BS_GEGENKTO) = szGegenKto
            End If
            
            ' 3. Kost 1
            lPos = InStr(szKost1, "(")
            If lPos > 0 Then szKost1 = Trim(Left(szKost1, lPos - 1))
            If szKost1 <> "" And _
               (bOverwrite Or _
                .Column = COL_BS_KOST1 Or _
                .Parent.Cells(pRange.Row, COL_BS_KOST1) = "" _
               ) Then
                
                pRange.Parent.Cells(pRange.Row, COL_BS_KOST1) = szKost1
            End If
            
            ' 4. Kost 2
            lPos = InStr(szKost2, "(")
            If lPos > 0 Then szKost2 = Trim(Left(szKost2, lPos - 1))
            If szKost2 <> "" And _
               (bOverwrite Or _
                .Column = COL_BS_KOST2 Or _
                .Parent.Cells(pRange.Row, COL_BS_KOST2) = "" _
               ) Then
                
                pRange.Parent.Cells(pRange.Row, COL_BS_KOST2) = szKost2
            End If
            
        End With
    End If
    GoTo END_CMT_TextAuswahl

ERR_CMT_TextAuswahl:
    Call DoLogPerm("CMT_TextAuswahl(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMT_TextAuswahl:
    On Error Resume Next
    Unload fmAuswahl
    Set fmAuswahl = Nothing
    Call DoLog("CMT_TextAuswahl(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMT_CopyText()
    Dim bDoInsert As Boolean
    Dim bSameText As Boolean
    Dim bSameWare As Boolean
    Dim bSameGegKto As Boolean
    Dim bSameKonto As Boolean
    Dim bSameKost1 As Boolean
    Dim bSameKost2 As Boolean
    Dim lRow As Long
    Dim lLastRow As Long
    Dim szText As String
    Dim wsTexte As Worksheet
    
    On Error GoTo ERR_CMT_CopyText
    Call DoLog("CMT_CopyText(); funcEnd")
    
    Set wsTexte = ThisWorkbook.Worksheets(TAB_TEXTE)
    
    ' Leerstrings werden nicht bearbeitet
    If Trim(pRange.Value) = "" Then Exit Sub
    
    ' Zeile des letzten Eintrags ermitteln
    lLastRow = GetLastUsedRow(wsTexte, ROW_TXT_START, COL_TXT_END)
    
    ' Gibt es den Text schon?
    bDoInsert = True
    For lRow = ROW_TXT_START To lLastRow
        If [TOOLKASSE] Then
            bSameWare = True
            bSameKonto = True
            bSameText = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_TEXT))) = Trim(wsTexte.Cells(lRow, COL_TXT_TEXT1)))
        Else
            bSameWare = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_WARENART))) = Trim(wsTexte.Cells(lRow, COL_TXT_TEXT2)))
            bSameKonto = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_KONTO))) = Trim(wsTexte.Cells(lRow, COL_TXT_KONTO)))
            bSameText = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_NAMEORT))) = Trim(wsTexte.Cells(lRow, COL_TXT_TEXT1)))
        End If
        bSameGegKto = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_GEGENKTO))) = Trim(wsTexte.Cells(lRow, COL_TXT_GEGENKTO)))
        bSameKost1 = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_KOST1))) = Trim(wsTexte.Cells(lRow, COL_TXT_KOST1)))
        bSameKost2 = (CStr(Trim(pWs.Cells(pRange.Row, COL_BS_KOST2))) = Trim(wsTexte.Cells(lRow, COL_TXT_KOST2)))
        If bSameText And bSameWare And bSameGegKto And bSameKonto And bSameKost1 And bSameKost2 Then
            MsgBox TOOLID + "027" + vbCrLf + vbCrLf + _
                "Dieser Eintrag ist bereits vorhanden.", _
                vbInformation, TOOLHDR
            bDoInsert = False
            Exit For
        End If
    Next
    
    If bDoInsert Then
        ' Die folgenden haben wir immer
        If [TOOLKASSE] Then
            szText = CStr(Trim(pWs.Cells(pRange.Row, COL_BS_TEXT)))
        Else
            szText = CStr(Trim(pWs.Cells(pRange.Row, COL_BS_NAMEORT)))
        End If
        wsTexte.Cells(lLastRow + 1, COL_TXT_TEXT1) = szText
        wsTexte.Cells(lLastRow + 1, COL_TXT_GEGENKTO) = Trim(pWs.Cells(pRange.Row, COL_BS_GEGENKTO))
        wsTexte.Cells(lLastRow + 1, COL_TXT_KOST1) = Trim(pWs.Cells(pRange.Row, COL_BS_KOST1))
        wsTexte.Cells(lLastRow + 1, COL_TXT_KOST2) = Trim(pWs.Cells(pRange.Row, COL_BS_KOST2))
        ' Zus|fffd|tzliche f|fffd|r die Warenerfassung
        If Not [TOOLKASSE] Then
            wsTexte.Cells(lLastRow + 1, COL_TXT_KONTO) = Trim(pWs.Cells(pRange.Row, COL_BS_KONTO))
            wsTexte.Cells(lLastRow + 1, COL_TXT_TEXT2) = Trim(pWs.Cells(pRange.Row, COL_BS_WARENART))
        End If
    End If
    GoTo END_CMT_CopyText
    
ERR_CMT_CopyText:
    Call DoLogPerm("CMT_CopyText(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    
END_CMT_CopyText:
    Set wsTexte = Nothing
    Call DoLog("CMT_CopyText(); funcEnd")
    On Error GoTo 0
End Sub

Public Sub CMT_ShowText()
    Dim lLastRow As Long
    Dim wsTexte As Worksheet
    
    Set wsTexte = ThisWorkbook.Worksheets(TAB_TEXTE)
    ' Zeile des letzten Eintrags ermitteln
    lLastRow = GetLastUsedRow(wsTexte, ROW_TXT_START, COL_TXT_END) + 1
    
    wsTexte.Activate
    ActiveSheet.Cells(lLastRow, COL_TXT_START).Select
    Set wsTexte = Nothing
End Sub


'
' Buchungen
'
Public Sub CMT_Dialogbuchen()
    Call BuchenClick(pWs, pRange.Row, False)
End Sub

Public Sub CMT_SplitBuchung()
    Call BuchenClick(pWs, pRange.Row, True)
End Sub
Attribute VB_Name = "gmodContextMenuUSt"
Option Explicit

Private Const CMDB_NAME = "CM_USt"

' Modul-Globale Variablen
Private pWs As Worksheet
Private plRow As Long
Private pRange As Range
'

Public Sub ShowContextMenuUSt(r As Range)
    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    If [InsertUStValue] = "voll" Then
        Call CMT_UStAuswahl_Voll
    Else
        Call CMT_UStAuswahl_Halb
    End If
End Sub

' Liefert TRUE, wenn das Statusmen|fffd| angezeigt wird, liefert FALSE, wenn das
' Standard Kontextmen|fffd| angezeigt werden soll.
Public Function ContextMenu_UStAuswahl(r As Range) As Boolean
    Dim myBar As CommandBar
    Dim myPopup As CommandBarControl
    Dim szSteuer As String
    Dim bStartGroup As Boolean
    
    On Error GoTo ERR_ContextMenu_UStAuswahl
    Call DoLog("ContextMenu_UStAuswahl(); funcStart")

    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    Set myBar = CommandBars.Add(Name:=CMDB_NAME, Position:=msoBarPopup, Temporary:=False)
    With myBar
        ' Voller Steuersatz 19%/20%
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "USt " + IIf([ToolCountry] = COUNTRY_DE, "19%", "20%") + " einf|fffd|gen"
        myPopup.OnAction = "CMT_UStAuswahl_Voll"
        ' Halber Steuersatz 7%/10%
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "USt " + IIf([ToolCountry] = COUNTRY_DE, "7%", "10%") + " einf|fffd|gen"
        myPopup.OnAction = "CMT_UStAuswahl_Halb"
    End With
    
    On Error GoTo ERR_ContextMenu_UStAuswahl_LFZ_9
    bStartGroup = True
    For Each myPopup In Application.CommandBars("cell").Controls
        myPopup.Copy Bar:=myBar
        If myPopup.BeginGroup Or bStartGroup Then
            myBar.Controls(myBar.Controls.Count).BeginGroup = True
            bStartGroup = False
        End If
    Next
    
    On Error GoTo ERR_ContextMenu_UStAuswahl
    myBar.ShowPopup
    myBar.Delete
    
    Set pWs = Nothing
    Set pRange = Nothing
    plRow = 0

    ' Kein Standard-Kontext Men|fffd|
    ContextMenu_UStAuswahl = True
    Call DoLog("ContextMenu_UStAuswahl(); funcEnd")
    On Error GoTo 0
    Exit Function

ERR_ContextMenu_UStAuswahl_LFZ_9:
    Call DoLogPerm("ContextMenu_UStAuswahl(); Problem bei Commandbars(""cell""); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
    
ERR_ContextMenu_UStAuswahl:
    Call DoLogPerm("ContextMenu_UStAuswahl(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number = 5 Then
        CommandBars(CMDB_NAME).Delete
        Resume Next
    End If
    ContextMenu_UStAuswahl = False
    Call DoLog("ContextMenu_UStAuswahl(); funcExit")
    On Error GoTo 0
End Function

'****************************************************
'*                                                  *
'*   Funktionen f|fffd|r das Kontextmen|fffd| zu Spalte USt   *
'*                                                  *
'****************************************************

Public Sub CMT_UStAuswahl_Voll()
    If [DATEVEingabe] Then
        pRange.Value = IIf([ToolCountry] = COUNTRY_DE, 1900, 2000)
    Else
        pRange.Value = IIf([ToolCountry] = COUNTRY_DE, 19, 20)
    End If
End Sub

Public Sub CMT_UStAuswahl_Voll_Alt()
    If [DATEVEingabe] Then
        pRange.Value = IIf([ToolCountry] = COUNTRY_DE, 1600, 2000)
    Else
        pRange.Value = IIf([ToolCountry] = COUNTRY_DE, 16, 20)
    End If
End Sub

Public Sub CMT_UStAuswahl_Halb()
    If [DATEVEingabe] Then
        pRange.Value = IIf([ToolCountry] = COUNTRY_DE, 700, 1000)
    Else
        pRange.Value = IIf([ToolCountry] = COUNTRY_DE, 7, 10)
    End If
End Sub

Attribute VB_Name = "gmodContextMenuZP"
Option Explicit

Private Const CMDB_NAME = "CM_ZP_Zaehlprotokoll"

' Modul-Globale Variablen
Private pWs As Worksheet
Private plRow As Long
Private pRange As Range
'

Public Sub ShowContextMenuZP(r As Range)
    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    Call CMT_ZP_Zaehlprotokoll
End Sub

' Liefert TRUE, wenn das Statusmen|fffd| angezeigt wird, liefert FALSE, wenn das
' Standard Kontextmen|fffd| angezeigt werden soll.
Public Function ContextMenu_Zaehlprotokoll(r As Range) As Boolean
    Dim myBar As CommandBar
    Dim myPopup As CommandBarControl
    Dim szSteuer As String
    Dim bStartGroup As Boolean
    
    On Error GoTo ERR_ContextMenu_Zaehlprotokoll
    Call DoLog("ContextMenu_Zaehlprotokoll(); funcStart")

    ' Globale Variablen setzen
    Set pWs = r.Parent
    Set pRange = r
    plRow = r.Row
    
    Set myBar = CommandBars.Add(Name:=CMDB_NAME, Position:=msoBarPopup, Temporary:=False)
    With myBar
        ' Aufruf Erfassung / Bearbeitung / Druck
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Z|fffd|hlprotokoll"
        myPopup.OnAction = "CMT_ZP_Zaehlprotokoll"
        ' Aufruf Erfassung / Bearbeitung / Druck
        Set myPopup = .Controls.Add(Type:=msoControlButton)
        myPopup.Caption = "Z|fffd|hlprotokoll drucken"
        myPopup.OnAction = "CMT_ZP_ZaehlprotokollDruck"
    End With
    
    On Error GoTo ERR_ContextMenu_Zaehlprotokoll_LFZ_9
    bStartGroup = True
    For Each myPopup In Application.CommandBars("cell").Controls
        myPopup.Copy Bar:=myBar
        If myPopup.BeginGroup Or bStartGroup Then
            myBar.Controls(myBar.Controls.Count).BeginGroup = True
            bStartGroup = False
        End If
    Next
    
    On Error GoTo ERR_ContextMenu_Zaehlprotokoll
    myBar.ShowPopup
    myBar.Delete
    
    Set pWs = Nothing
    Set pRange = Nothing
    plRow = 0

    ' Kein Standard-Kontext Men|fffd|
    ContextMenu_Zaehlprotokoll = True
    Call DoLog("ContextMenu_Zaehlprotokoll(); funcEnd")
    On Error GoTo 0
    Exit Function

ERR_ContextMenu_Zaehlprotokoll_LFZ_9:
    Call DoLogPerm("ContextMenu_Zaehlprotokoll(); Problem bei Commandbars(""cell""); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next

ERR_ContextMenu_Zaehlprotokoll:
    Call DoLogPerm("ContextMenu_Zaehlprotokoll(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number = 5 Then
        CommandBars(CMDB_NAME).Delete
        Resume Next
    End If
    ContextMenu_Zaehlprotokoll = False
    Call DoLog("ContextMenu_KostAuswahl(); funcExit")
    On Error GoTo 0
End Function

'******************************************************
'*                                                    *
'*   Funktionen f|fffd|r das Kontextmen|fffd| zu Spalte Datum   *
'*                                                    *
'******************************************************

Public Sub CMT_ZP_Zaehlprotokoll()
    Dim objZP As Object
    
    Set objZP = MainServer("KWEBericht")
    If objZP Is Nothing Then
        MsgBox TOOLID + "059" + vbCrLf + vbCrLf + _
            "Die angeforderte Funktion kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "weil eine notwendige Komponente nicht initialisiert werden konnte." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbExclamation, TOOLHDR
    Else
        Set objZP.XlApplication = Application
        Set objZP.xlWorkbook = ThisWorkbook
        Set objZP.xlWorksheet = pRange.Parent
        ' Unterscheidung zwischen den Erfassungsseiten und dem Z|fffd|hlprotokoll
        If LCase(pRange.Parent.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
            Call objZP.Zaehlprotokoll(False, pRange.Parent.Cells(pRange.Row, COL_AW_DATUM))
        Else
            Call objZP.Zaehlprotokoll(False, pRange.Value)
        End If
        Set objZP = Nothing
    End If
End Sub

Public Sub CMT_ZP_ZaehlprotokollDruck()
    Dim objZP As Object
    
    Set objZP = MainServer("KWEBericht")
    If objZP Is Nothing Then
        MsgBox TOOLID + "060" + vbCrLf + vbCrLf + _
            "Die angeforderte Funktion kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "weil eine notwendige Komponente nicht initialisiert werden konnte." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbExclamation, TOOLHDR
    Else
        Set objZP.XlApplication = Application
        Set objZP.xlWorkbook = ThisWorkbook
        Set objZP.xlWorksheet = pRange.Parent
        ' Unterscheidung zwischen den Erfassungsseiten und dem Z|fffd|hlprotokoll
        If LCase(pRange.Parent.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
            Call objZP.Zaehlprotokoll(True, pRange.Parent.Cells(pRange.Row, COL_AW_DATUM))
        Else
            Call objZP.Zaehlprotokoll(True, pRange.Value)
        End If
        Set objZP = Nothing
    End If
End Sub

Attribute VB_Name = "gmodDrucken"
Option Explicit

Private Const COL_DRUCK_POS = 2
Private Const COL_DRUCK_TEXT = 3
Private Const ROW_DRUCK_START = 7
Private Const ROW_DRUCK_START_BERICHT = 16
Private Const MAX_HEADERFOOTER = 248
'
Public gbPrinting As Boolean
Public gbPreview As Boolean
'

Function DruckeMonat(ws As Worksheet) As Long
    Dim szPrintArea As String
    Dim lLastRow As String
    Dim lRetVal As Long
    Dim szMsg As String
    Dim fError As gfrmFehler
    Dim fPrint As gfrmDrucken
    Dim lOrientation As Long
    
    '
    ' Ideen:
    ' Vor dem Ausdruck am Ende der Seite eine Zeile hinzuf|fffd|gen, an Hand der das Ende
    ' eindeutig erkannt wird und Info |fffd|ber die Anzahl an Buchungss|fffd|tzen und den Endsaldo
    ' ausgibt.
    '
    lRetVal = SortierenUndValidieren(ws, szMsg)
    DruckeMonat = lRetVal
    Select Case lRetVal
        Case BS_ERROR
            Set fError = New gfrmFehler
            fError.OkButtonCaption = "Drucken..."
            fError.CancelButton = True
            fError.ErrorNumber = "062"
            fError.MessageText = szMsg
            fError.ActionText = "Wollen Sie das Kontoblatt trotzdem drucken?"
            fError.Show
            If fError.Aborted Then Exit Function
            Unload fError
            Set fError = Nothing
        Case BS_EMPTY
            MsgBox TOOLID + "063" + vbCrLf + vbCrLf + _
              "Das Erfassungsblatt enth|fffd|lt keine Daten." & vbCrLf & _
              "Wenn Sie ein leeres Erfassungsblatt drucken wollen, w|fffd|hlen Sie die Funktion" & vbCrLf & _
              """Blanko Formulardruck..."" in der Verwaltung (DATEV | " + TOOLNAME + ") aus.", _
              vbInformation, TOOLHDR
            Exit Function
    End Select
    
    lLastRow = GetLastUsedRow(ws)
    szPrintArea = "$" & sz2a1(COL_BS_START) & "$" & ROW_BS_START & ":$" & sz2a1(COL_BS_ENDE + 1) & "$" & lLastRow
    lOrientation = IIf(GetVisibleColumns(ws) > DRUCK_ORIENTATION_CHNG, xlLandscape, xlPortrait)
    
    On Error GoTo ERR_DruckeMonat_LFZ_9_1
    
    ' Seiteneinstellungen
    Application.ScreenUpdating = False
    ws.Activate
    With ActiveSheet.PageSetup
        .PrintTitleRows = "$4:$12"
        .PrintTitleColumns = ""
    End With
    ActiveCell.Select
    ActiveSheet.PageSetup.PrintArea = szPrintArea
    
    ' Header/Footer werden |fffd|ber DvKasseWareMain eingestellt.
    Call SetupHeaderFooter(ws)
    
    With ActiveSheet.PageSetup
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .HeaderMargin = Application.CentimetersToPoints(0.5)
        .FooterMargin = Application.CentimetersToPoints(0.5)
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = lOrientation
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
    ' XXX F|fffd|r die Seitenanzeige: hier noch die Ansicht auf Druck umschalten
    Application.ScreenUpdating = True
    
    Set fPrint = New gfrmDrucken
    fPrint.Orientierung = lOrientation
    fPrint.Show
    If Not fPrint.Abbruch Then
        gbPrinting = True
        ' 22.02.2010, tt: Unter Office 2007 kann der Zugriff auf ActiveSheet.PageSetup einen LFZ 9 produzieren :-((
        ActiveSheet.PageSetup.BlackAndWhite = fPrint.SchwarzWeiss
        ActiveSheet.PageSetup.Orientation = fPrint.Orientierung
        
        On Error GoTo ERR_DruckeMonat_LFZ_9_2
        ActiveSheet.PrintOut Copies:=fPrint.Copies, Collate:=True
        gbPrinting = False
    End If
    Unload fPrint
    Set fPrint = Nothing
    Application.ScreenUpdating = True
    On Error GoTo 0
    Exit Function
    
ERR_DruckeMonat_LFZ_9_2:
    Call DoLogPerm("DruckeMonat(); Einrichten oder Drucken; Err=" + CStr(Err.Number) + "; " + Err.Description)
    If Err.Number <> 9 Then
        MsgBox TOOLID + "064" + vbCrLf + vbCrLf + _
            "Beim Drucken der Seite ist ein Fehler aufgetreten." + vbCrLf + vbCrLf + _
            "Fehler " + CStr(Err.Number) + ": " & Err.Description + vbCrLf + vbCrLf + _
            Chr(187) + " Pr|fffd|fen Sie, ob der gew|fffd|hlte Drucker verf|fffd|gbar ist.", vbInformation, TOOLHDR
    End If
    Resume Next
    
ERR_DruckeMonat_LFZ_9_1:
    If Err.Number <> 9 Then
        MsgBox TOOLID + "061" + vbCrLf + vbCrLf + _
            "Beim Einrichten der Seite ist ein Fehler aufgetreten." + vbCrLf + vbCrLf + _
            Chr(187) & " Pr|fffd|fen Sie, ob ein Drucker installiert ist.", vbInformation, TOOLHDR
    Else
        Resume Next
    End If
    Application.ScreenUpdating = True
    On Error GoTo 0
End Function



Public Function ResetHeaderFooterAll() As Boolean
    Dim ws As Worksheet
    Dim bSuccess As Boolean
    Dim i As Long
    Dim lRow As Long
    
    ' Umkopieren des Defaults auf die Seite Druckeinstellungen
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    lRow = ws.Range("ErfassungHeaderLeft").Row
    For i = 0 To 5
        ThisWorkbook.Worksheets(TAB_DRUCKSETUP).Cells(ROW_DRUCK_START + i, COL_DRUCK_TEXT) = ws.Cells(lRow + i, COL_DRUCK_TEXT)
    Next
    lRow = ws.Range("BerichtHeaderLeft").Row
    For i = 0 To 5
        ThisWorkbook.Worksheets(TAB_DRUCKSETUP).Cells(ROW_DRUCK_START_BERICHT + i, COL_DRUCK_TEXT) = ws.Cells(lRow + i, COL_DRUCK_TEXT)
    Next
    
    ' R|fffd|cksetzen der einzelnen Tabellen
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name Like "##[._]####" Or ws.Name Like "Blatt_##" Or ws.Name = TAB_TEXTE Or ws.Name = TAB_KOST Or ws.Name = TAB_ZAEHLPROTOKOLL Then
            If Not ResetHeaderFooter(ws) Then bSuccess = False
        End If
    Next
    
    ResetHeaderFooterAll = bSuccess
    On Error GoTo 0
End Function

Public Function ResetHeaderFooter(ws As Worksheet) As Boolean
    Dim bProtected As Boolean
        
    On Error Resume Next

    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    ' L|fffd|schen
    If ws.PageSetup.LeftHeader <> [ErfassungHeaderLeft] Then ws.PageSetup.LeftHeader = ""
    If ws.PageSetup.CenterHeader <> [ErfassungHeaderCenter] Then ws.PageSetup.CenterHeader = ""
    If ws.PageSetup.RightHeader <> [ErfassungHeaderRight] Then ws.PageSetup.RightHeader = ""
    If ws.PageSetup.LeftFooter <> [ErfassungFooterLeft] Then ws.PageSetup.LeftFooter = ""
    If ws.PageSetup.CenterFooter <> [ErfassungFooterCenter] Then ws.PageSetup.CenterFooter = ""
    If ws.PageSetup.RightFooter <> [ErfassungFooterRight] Then ws.PageSetup.RightFooter = ""
    ' Default setzen
    If ws.PageSetup.LeftHeader <> [ErfassungHeaderLeft] Then ws.PageSetup.LeftHeader = [ErfassungHeaderLeft]
    If ws.PageSetup.CenterHeader <> [ErfassungHeaderCenter] Then ws.PageSetup.CenterHeader = [ErfassungHeaderCenter]
    If ws.PageSetup.RightHeader <> [ErfassungHeaderRight] Then ws.PageSetup.RightHeader = [ErfassungHeaderRight]
    If ws.PageSetup.LeftFooter <> [ErfassungFooterLeft] Then ws.PageSetup.LeftFooter = [ErfassungFooterLeft]
    If ws.PageSetup.CenterFooter <> [ErfassungFooterCenter] Then ws.PageSetup.CenterFooter = [ErfassungFooterCenter]
    If ws.PageSetup.RightFooter <> [ErfassungFooterRight] Then ws.PageSetup.RightFooter = [ErfassungFooterRight]
    '
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    ResetHeaderFooter = (Err.Number = 0)
    On Error GoTo 0
End Function

Public Function SetupHeaderFooterAll() As Boolean
    Dim bSuccess As Boolean
    Dim oDok As Object
    
    bSuccess = False
    Set oDok = MainServer("KWEDokument")
    If oDok Is Nothing Then
        MsgBox TOOLID + "055" + vbCrLf + vbCrLf + _
            "Die Funktion zum Setzen der Kopf- und Fu|fffd|zeilen kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "da keine Verbindung zum Anwendungsserver aufgebaut werden konnte." + vbCrLf + vbCrLf + _
            "Sollten die Kopf- und Fu|fffd|zeilen nicht korrekt gesetzt sein, m|fffd|ssen Sie" + vbCrLf + _
            "die Angaben |fffd|ber den Excel-Standard-Dialog ""Seite einrichten"" erg|fffd|nzen.", vbInformation, TOOLHDR
    Else
        Set oDok.XlApplication = Application
        Set oDok.xlWorkbook = ThisWorkbook
        bSuccess = oDok.Drucken(Nothing)
        If Not bSuccess Then
            If LenB(oDok.LastError) = 0 Then
                Call DoLogPerm("SetupHeaderFooterAll(); Kopf-/Fu|fffd|zeilen; Success=false")
            Else
                MsgBox oDok.LastError
            End If
        End If
    End If
    Set oDok = Nothing
    
    SetupHeaderFooterAll = bSuccess
End Function

' Die Funktion wird beim Drucken aufgerufen und soll die Kopf-/Fu|fffd|zeilen
' gem|fffd||fffd| der Vorgabe in der Tabelle Druckeinstellungen einstellen
Public Function SetupHeaderFooter(ws As Worksheet) As Boolean
    Dim bSuccess As Boolean
    Dim oDok As Object

    bSuccess = False
    Set oDok = MainServer("KWEDokument")
    If oDok Is Nothing Then
        MsgBox TOOLID + "056" + vbCrLf + vbCrLf + _
            "Die Funktion zum Setzen der Kopf- und Fu|fffd|zeilen kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "da keine Verbindung zum Anwendungsserver aufgebaut werden konnte." + vbCrLf + vbCrLf + _
            "Sollten die Kopf- und Fu|fffd|zeilen nicht korrekt gesetzt sein, m|fffd|ssen Sie" + vbCrLf + _
            "die Angaben |fffd|ber den Excel-Standard-Dialog ""Seite einrichten"" erg|fffd|nzen.", vbInformation, TOOLHDR
    Else
        Set oDok.XlApplication = Application
        Set oDok.xlWorkbook = ThisWorkbook
        bSuccess = oDok.Drucken(ws)
        If Not bSuccess Then
            If LenB(oDok.LastError) = 0 Then
                Call DoLogPerm("SetupHeaderFooter(); Kopf-/Fu|fffd|zeilen; Success=false")
            Else
                MsgBox oDok.LastError
            End If
        End If
    End If
    Set oDok = Nothing

    SetupHeaderFooter = bSuccess
End Function

Attribute VB_Name = "gmodEingabe"
Option Explicit


Sub WeiterSchalten()
    Dim lCol As Long
    Dim lColPrev As Long
    Dim lRow As Long
    Dim lRowPrev As Long
    Dim lLast As Long
    Dim lRetVal As Long
    Dim bNeueZeile As Boolean
    Dim wsD As Worksheet
    
    Set wsD = ThisWorkbook.Worksheets(TAB_DATEN)
    
    'Debug.Print ActiveCell.Row & " " & ActiveCell.Column
    lColPrev = ActiveCell.Column
    lRowPrev = ActiveCell.Row
    lCol = lColPrev + 1
    lRow = lRowPrev
    
    ' Optionale Spalten bei Bedarf |fffd|berspringen
    ' Achtung Reihenfolge beachten!!
    
    ' Tagesbestand
    If TOOLKASSE And lCol = COL_BS_BESTAND Then
        lCol = lCol + 1
    End If
    
    ' B-/U- und Gegenkonto
    If lCol = COL_BS_B Then
        If wsD.Range("OptSpalteGegenkonto") = False Then
            ' B-, U- und Gegenkontospalte sind gesperrt --> 3 weiter
            lCol = lCol + 3
        Else
            ' B-, U- und Gegenkontospalte nicht gesperrt --> Einstellungen pr|fffd|fen
            If wsD.Range("BUmitGegenkonto") And wsD.Range("BUSpaltenSprung") Then
                ' B- und U- werden |fffd|bersprungen
                lCol = lCol + 2
            End If
        End If
    End If
    '
    If Not TOOLKASSE Then
        ' Ware: zuerst Kost1, dann Beleg2
        If lCol = COL_BS_KOST1 And wsD.Range("OptSpalteKost1") = False Then
            lCol = lCol + 1
        End If
        If lCol = COL_BS_BELEG2 And wsD.Range("OptSpalteBeleg2") = False Then
            lCol = lCol + 1
        End If
    Else
        ' Kasse: zuerst Beleg2, dann Kost1
        If lCol = COL_BS_BELEG2 And wsD.Range("OptSpalteBeleg2") = False Then
            lCol = lCol + 1
        End If
        If lCol = COL_BS_KOST1 And wsD.Range("OptSpalteKost1") = False Then
            lCol = lCol + 1
        End If
    End If
    ' KOST 2 |fffd|berspringen
    If lCol = COL_BS_KOST2 And wsD.Range("OptSpalteKost2") = False Then
        lCol = lCol + 1
    End If
    ' KOST-Menge |fffd|berspringen
    If lCol = COL_BS_KOSTMENGE And wsD.Range("OptSpalteKostMenge") = False Then
        lCol = lCol + 1
    End If
    ' Skonto |fffd|berspringen
    If lCol = COL_BS_SKONTO And wsD.Range("OptSpalteSkonto") = False Then
        lCol = lCol + 1
    End If
    ' USt |fffd|berspringen
    If lCol = COL_BS_UST And wsD.Range("OptSpalteUSt") = False Then
        lCol = lCol + 1
    End If
    
    lRetVal = BS_OK
    If lCol > COL_BS_ENDE Then bNeueZeile = True
    Call VorverarbeitungZeile(ActiveSheet, lRowPrev)
    If bNeueZeile And wsD.Range("ImmerPr|fffd|fen") Then
        If wsD.Range("NurZeilePr|fffd|fen") Then
            lRetVal = AktualisiereZeile(ActiveSheet, lRowPrev)
        Else
            lRetVal = AktualisiereMonat(ActiveSheet, True)
        End If
    End If
    
    If bNeueZeile And lRetVal = BS_OK Then
        lCol = COL_BS_FIRST
        lRow = lRowPrev + 1
        lLast = GetLastUsedRow(ActiveSheet)
        If lRow > lLast Then lRow = lLast + 1
        Do While ActiveSheet.Cells(lRow, lCol).Locked
            lRow = lRow + 1
        Loop
    End If
    If lRetVal = BS_OK Then
        ActiveSheet.Cells(lRow, lCol).Select
        ActiveSheet.Cells(lRow, lCol).Activate
    End If
End Sub

Function EingabeKontrolle(r As Range) As Boolean
    Dim vData As Variant
    Dim szMsg As String
    Dim lColumn As Long
    Dim lLen As Long
    Dim cData As Currency
    Dim cRounded As Currency
    Dim cMax As Currency
    Dim szStellen As String
    Dim szInfo As String
    Dim szDate As String
    Dim iKtoL|fffd|nge As Integer
    Dim bInsert As Boolean
    Dim lRetVal As Long
    Dim lOtherCol As Long
    Dim lColWidth As Long
    Dim bNumericKostOnly As Boolean
    Dim bDefinedKostOnly As Boolean
    Dim wsActive As Worksheet
    Dim bRetVal As Boolean
    Dim bEditMode As Boolean
    
    bRetVal = False
    EingabeKontrolle = bRetVal
    
    ' Shortcuts:
    ' - Eingabekontrolle durchf|fffd|hren?
    If Not gbEingabeKontrolle Then Exit Function
    ' - G|fffd|ltige Eingabezelle |fffd|bergeben?
    If r.Column < COL_BS_START_INPUT Or r.Column > COL_BS_ENDE Or r.Row < ROW_BS_START Then Exit Function
    ' - Liegt eine Mehrfachselektion vor?
    If r.Rows.Count > 1 Or r.Columns.Count > 1 Then Exit Function
    
    ' R|fffd|ckgabewert der Funktion --> Default: alles ok
    bRetVal = True
    ' Automatisch in den Edit-Mode wechseln, damit die Pr|fffd|fung erneut laufen kann
    bEditMode = False
    ' Initialen Text der Fehlermeldung bei falscher Eingabe festlegen
    szMsg = TOOLID + "011" + vbCrLf + vbCrLf + "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + vbCrLf
    
    
    ' Eingegebenen Wert vorbereiten
    ' Am Ende der Funktion werden die Daten aus vData zur|fffd|ckgeschrieben,
    ' so sie vom urspr|fffd|nglichen Inhalt abweichen
    On Error Resume Next
    vData = Trim(r.Value)
    
    '
    ' Daten|fffd|berpr|fffd|fung abh|fffd|ngig von der Spalte
    '
    On Error GoTo ERR_Eingabekontrolle
    
    Select Case r.Column
        Case COL_BS_SOLL, COL_BS_HABEN, COL_BS_SKONTO, COL_BS_KOSTMENGE
            ' Betr|fffd|ge der Form 8.2/9.2/10.2
            If r.Column = COL_BS_SKONTO Then
                cMax = CCur("99999999,99")
                szStellen = "8.2"
                szInfo = "Betrag"
            ElseIf r.Column = COL_BS_KOSTMENGE Then
                cMax = CCur("999999999,99")
                szStellen = "9.2"
                szInfo = "Mengenwert"
            Else
                cMax = CCur("9999999999,99")
                szStellen = "10.2"
                szInfo = "Betrag"
            End If
            If Len(vData) > 0 Then
                If Not IsNumeric(vData) Then
                    MsgBox szMsg + "Geben Sie einen g|fffd|ltigen " + szInfo + " ein.", vbInformation, TOOLHDR
                    bRetVal = False
                    bEditMode = True
                    GoTo END_Eingabekontrolle
                End If
                ' Ok, generell ein numerischer Wert
                On Error Resume Next
                cData = CCur(vData)
                If Err.Number <> 0 Then
                    ' Aber viel zu gro|fffd|
                    MsgBox szMsg + "Der " + szInfo + " ist zu gro|fffd|. Geben Sie einen g|fffd|ltigen " + szInfo + " ein (max. " + szStellen + "-stellig).", vbInformation, TOOLHDR
                    bRetVal = False
                    bEditMode = True
                    On Error GoTo 0     ' Sonst schl|fffd|gt die Fehlermeldung am Ende zu
                    GoTo END_Eingabekontrolle
                End If
                On Error GoTo ERR_Eingabekontrolle
                ' Ok, ein g|fffd|ltiger Currency-Wert
                ' DATEV-Logik pr|fffd|fen
                If [DATEVEingabe] Then
                    ' Eingabe ohne Dezimaltrennzeichen
                    If InStr(vData, ",") = 0 Then
                        ' - wenn keines vorhanden ist, dann liegt der Wert in Cent vor
                        cData = CCur(Format(cData / 100, "#0.00"))
                    Else
                        ' - wenn eines vorhanden ist, dann k|fffd|nnen wir nur sicher sein, wenn auch Cent-Betr|fffd|ge
                        '   vorliegen, da die Text-Property den bereits formatierten Wert zur|fffd|ckliefert und der
                        '   ist bei "1" und "1,00" identisch! --> Nix tun - diese L|fffd|cke bleibt :-(
                    End If
                End If
                ' Betrag auf maximal zul|fffd|ssigen Wert pr|fffd|fen
                If cData > cMax Then
                    MsgBox szMsg & "Der " + szInfo + " ist zu gro|fffd|. Geben Sie einen g|fffd|ltigen " + szInfo + " ein (max. " + szStellen + "-stellig).", vbInformation, TOOLHDR
                    bRetVal = False
                    GoTo END_Eingabekontrolle
                End If
                ' Anzahl an Nachkommastellen durch Rundung pr|fffd|fen
                cRounded = Application.WorksheetFunction.Round(cData * 100, 0)
                If cRounded <> cData * 100 Then
                    MsgBox szMsg & "Es sind nur 2 Nachkommastellen zul|fffd|ssig." + vbCrLf + _
                        "Der eingegebene Wert (" + CStr(cData) + ") wird zu " + Format(CStr(Round(cData, 2)), "#,##0.00") + " gerundet.", _
                        vbInformation, TOOLHDR
                    Application.EnableEvents = False
                    cData = Round(cData, 2)
                    Cells(r.Row, r.Column).Value = cData
                    Application.EnableEvents = True
                End If
                If Not [AllowZeroValues] Then
                    If cData = 0 Then
                        MsgBox szMsg & "Wollen Sie einen " + szInfo + " mit Wert 0 erfassen, so m|fffd|ssen Sie diese Option in den" + vbCrLf + _
                            "Einstellungen aktivieren." + _
                            IIf(r.Column <> COL_BS_KOSTMENGE, vbCrLf + "Beachten Sie dass Buchungszeilen mit Betrag 0 nicht exportiert werden.", ""), vbInformation, TOOLHDR
                        bRetVal = False
                    End If
                End If
                ' Negative Werte
                If cData < 0 Then
                    ' Negative Werte bei Soll/Haben setzen wir um
                    If r.Column = COL_BS_SOLL Then
                        Application.EnableEvents = False
                        r.Value = ""
                        vData = ""
                        Cells(r.Row, COL_BS_HABEN).Value = cData * -1
                        Application.EnableEvents = True
                    ElseIf r.Column = COL_BS_HABEN Then
                        Application.EnableEvents = False
                        r.Value = ""
                        vData = ""
                        Cells(r.Row, COL_BS_SOLL).Value = cData * -1
                        Application.EnableEvents = True
                    Else
                        ' F|fffd|r Skonto und Kostmenge lassen wir keine negativen Werte zu
                        MsgBox szMsg + "Ein negativer Wert ist nicht zul|fffd|ssig."
                        bRetVal = False
                    End If
                Else
                    vData = cData
                End If
            End If
            
        Case COL_BS_B, COL_BS_U
            ' Zul|fffd|ssige Werte:
            ' * einstellige positive Zahl
            ' * zweistellige Zahl, die automatisch aufgeteilt werden kann
            If Len(vData) > 0 Then
                If Not IsNumeric(vData) Or Len(vData) > 2 Then
                    MsgBox szMsg + "Die Felder B und U k|fffd|nnen jeweils eine Ziffer enthalten. Bei Eingabe" + vbCrLf + _
                        "von zwei Ziffern werden diese auf die beiden Spalten verteilt." + vbCrLf + vbCrLf + _
                        "Geben Sie eine max. zweistellige positive Zahl ein.", vbInformation, TOOLHDR
                    bEditMode = True
                    bRetVal = False
                ElseIf Len(vData) = 2 Then
                    ' Nachbarspalte ermitteln
                    lOtherCol = ((r.Column - COL_BS_B + 1) Mod 2) + COL_BS_B
                    ' Zehner- und Einerstelle aufteilen
                    bInsert = True
                    If Cells(r.Row, lOtherCol) <> "" Then
                        lRetVal = MsgBox(TOOLID + "023" + vbCrLf + vbCrLf + _
                            "In der Spalte " + IIf(r.Column = COL_BS_B, "U", "B") + " ist bereits der Wert '" + CStr(Cells(r.Row, lOtherCol)) + "' eingetragen." + vbCrLf + vbCrLf + _
                            Chr(187) + " Soll der Wert mit '" + CStr(IIf(lOtherCol > r.Column, Right(vData, 1), Left(vData, 1))) + "' |fffd|berschrieben werden?", _
                            vbInformation, vbYesNo)
                        bInsert = (lRetVal <> vbNo)
                    End If
                    If bInsert Then
                        Application.EnableEvents = False
                        Cells(r.Row, lOtherCol).Value = IIf(lOtherCol > r.Column, Right(vData, 1), Left(vData, 1))
                        vData = IIf(lOtherCol > r.Column, Left(vData, 1), Right(vData, 1))
                        r.Value = vData
                        Application.EnableEvents = True
                    End If
                End If
            End If
            
        Case COL_BS_GEGENKTO, COL_BS_KONTO
            ' Leerzeichen/Punkte in der Kontonummer entfernen
            vData = ConvertKto(vData)
            ' L|fffd|nge KtoNr. muss zwischen 1 und Sachkontenl|fffd|nge + 1 liegen
            If Len(vData) > 0 Then
                iKtoL|fffd|nge = IIf([KtoL|fffd|nge] > 0, [KtoL|fffd|nge], 8)
                If [BUmitGegenkonto] Then
                    iKtoL|fffd|nge = iKtoL|fffd|nge + 3
                Else
                    iKtoL|fffd|nge = iKtoL|fffd|nge + 1
                End If
                If Not IsNumeric(vData) Then
                    MsgBox szMsg + "F|fffd|r das Eingabefeld sind nur numerische Werte zul|fffd|ssig." + vbCrLf + "Geben Sie eine g|fffd|ltige Kontonummer mit 1 bis " + CStr(iKtoL|fffd|nge) + " Stellen ein.", vbInformation, TOOLHDR
                    bEditMode = True
                    bRetVal = False
                Else
                    If Len(vData) > iKtoL|fffd|nge Then
                        ' L|fffd|nge zu gro|fffd|
                        MsgBox szMsg + "Der eingegebene Wert '" + CStr(vData) + "' ist zu lang." + vbCrLf + "Geben Sie eine g|fffd|ltige Kontonummer mit 1 bis " + CStr(iKtoL|fffd|nge) + " Stellen ein.", vbInformation, TOOLHDR
                        bEditMode = True
                        bRetVal = False
                    ElseIf Val(vData) <= 0 Then
                        ' Keine Null-Werte
                        MsgBox szMsg + "Werte kleiner oder gleich 0 sind nicht zul|fffd|ssig." + vbCrLf + "Geben Sie eine g|fffd|ltige Kontonummer mit 1 bis " + CStr(iKtoL|fffd|nge) + " Stellen ein.", vbInformation, TOOLHDR
                        bEditMode = True
                        bRetVal = False
                    Else
                        ' Alles ok soweit --> Autoinsert pr|fffd|fen
                        If ThisWorkbook.Worksheets(TAB_DATEN).Range("AutoTextInsert") Then
                            If TryAutotextInsert(r) Then
                                ' Es wurden Daten geschrieben --> aktuellen Wert wieder holen
                                vData = r.Value
                            End If
                        End If
                    End If
                End If
            End If
            
        Case COL_BS_BELEG1, COL_BS_BELEG2
            ' Alphanumerischer max. 12-stelliger Wert
            If Len(vData) > MAX_LEN_BELEG Then
                lRetVal = MsgBox(szMsg + "F|fffd|r dieses Eingabefeld sind maximal " + CStr(MAX_LEN_BELEG) + " Zeichen zul|fffd|ssig." + vbCrLf + vbCrLf + _
                    "Soll das Feld automatisch gek|fffd|rzt werden?", vbInformation + vbYesNoCancel, TOOLHDR)
                If lRetVal = vbYes Then
                    vData = Left(vData, MAX_LEN_BELEG)
                    ' Zur|fffd|ckschreiben wegen m|fffd|glicher Breiten|fffd|nderung
                    Application.EnableEvents = False
                    r.Value = vData
                    Application.EnableEvents = True
                ElseIf lRetVal = vbNo Then
                    bRetVal = False
                    bEditMode = True
                    GoTo END_Eingabekontrolle
                Else
                    bRetVal = False
                    bEditMode = False
                End If
            End If
            ' Erweiterte Pr|fffd|fung auf erlaubte Zeichen
            If Not CheckBelegfeld(vData) Then
                Beep
                lRetVal = MsgBox(TOOLID + "013" + vbCrLf + vbCrLf + _
                    "Das Eingabefeld enth|fffd|lt ung|fffd|ltige Zeichen. Neben Ziffern, Gro|fffd|- und" + vbCrLf + _
                    "Kleinbuchstaben sind nur die Sonderzeichen $ & % * + - / erlaubt." + vbCrLf + vbCrLf + _
                    "Soll das Feld wie folgt ge|fffd|ndert werden?" + vbCrLf + vbCrLf + _
                    vbTab + CStr(vData) + " --> " + ConvertBelegfeld(vData), _
                    vbInformation + vbYesNoCancel, TOOLHDR)
                If lRetVal = vbYes Then
                    vData = ConvertBelegfeld(vData)
                    ' Zur|fffd|ckschreiben wegen m|fffd|glicher Breiten|fffd|nderung
                    Application.EnableEvents = False
                    r.Value = vData
                    Application.EnableEvents = True
                ElseIf lRetVal = vbNo Then
                    bRetVal = False
                    bEditMode = True
                    GoTo END_Eingabekontrolle
                Else
                    bRetVal = False
                    bEditMode = False
                End If
            End If
            ' Spaltenbreite korrigieren
            If r.Parent.ProtectContents Then r.Parent.Unprotect
            ' 21.12.2010, tt: Unter Office 2007 kann der AutoFit einen LFZ 9 produzieren :-((
            On Error Resume Next
            r.EntireColumn.AutoFit
            If r.EntireColumn.Width < COL_WIDTH_ZUSATZ_BREIT Then
                r.EntireColumn.ColumnWidth = COL_WIDTH_ZUSATZ_BREIT
            End If
            On Error GoTo ERR_Eingabekontrolle
            r.Parent.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            
        Case COL_BS_KOST1, COL_BS_KOST2
            If Len(vData) > 0 Then
                '
                bDefinedKostOnly = ThisWorkbook.Worksheets(TAB_DATEN).Range("DefinedKostOnly")
                bNumericKostOnly = ThisWorkbook.Worksheets(TAB_DATEN).Range("NumericKostOnly")
                '
                ' Nur in der Vorlage definierte Kostenstellen zul|fffd|ssig...
                If bDefinedKostOnly Then
                    If Not IsDefinedKost(CStr(vData)) Then
                        MsgBox szMsg + "Als Kostenstellen sind nur bereits definierte Werte aus den Vorlagen zul|fffd|ssig." + vbCrLf + "Pr|fffd|fen Sie die Einstellungen oder Textvorlagen.", vbInformation, TOOLHDR
                        bRetVal = False
                        bEditMode = False
                        GoTo END_Eingabekontrolle
                    End If
                ' Es sind nur numerische Kostenstellen zul|fffd|ssig...
                ElseIf bNumericKostOnly Then
                    ' Mit einem Muster auf nur Ziffern pr|fffd|fen
                    If Not CStr(vData) Like String(Len(vData), "#") Then
                        ' Andere Zeichen vorhanden
                        MsgBox szMsg + "Die Kostenstellen d|fffd|rfen nur numerische Werte beinhalten." + vbCrLf + "Geben Sie eine g|fffd|ltige Kostenstelle ein.", vbInformation, TOOLHDR
                        bEditMode = True
                        bRetVal = False
                        GoTo END_Eingabekontrolle
                    End If
                End If
                ' Generelle L|fffd|ngenpr|fffd|fung (Maximal 8 Zeichen f|fffd|r KOST1 und KOST2)
                If Len(vData) > MAX_LEN_KOST Then
                    If bDefinedKostOnly Then
                        MsgBox szMsg + "Die Kostenstelle ist zu lang. Es sind maximal " + CStr(MAX_LEN_KOST) + " Zeichen zul|fffd|ssig." + vbCrLf + "Pr|fffd|fen Sie Ihre Vorgabewerte in der Textvorlage.", vbInformation, TOOLHDR
                        bRetVal = False
                    ElseIf bNumericKostOnly Then
                        MsgBox szMsg + "Die Kostenstelle ist zu lang. Es sind maximal " + CStr(MAX_LEN_KOST) + " Ziffern zul|fffd|ssig." + vbCrLf + "Geben Sie einen g|fffd|ltigen Eingabewert ein.", vbInformation, TOOLHDR
                        bEditMode = True
                        bRetVal = False
                    Else
                        lRetVal = MsgBox(szMsg + "Die Kostenstelle ist zu lang. Es sind maximal " + CStr(MAX_LEN_KOST) + " Zeichen zul|fffd|ssig." + vbCrLf + vbCrLf + _
                            "Soll das Feld automatisch gek|fffd|rzt werden?", _
                            vbInformation + vbYesNoCancel, TOOLHDR)
                        If lRetVal = vbYes Then
                            vData = Left(vData, MAX_LEN_KOST)
                        ElseIf lRetVal = vbNo Then
                            bEditMode = True
                            bRetVal = False
                        Else
                            bEditMode = False
                            bRetVal = False
                        End If
                    End If
                End If
            End If
            
        Case COL_BS_DATUM
            ' Verarbeitet ein Datum der Form [d]d[mm[yy[yy]]] oder [d]d.[m]m.[yy[yy]]
            If Len(vData) > 0 Then
                If InStr(vData, ".") = 0 Then
                    szDate = ConvertDate(vData, r.Parent.Name)
                Else
                    szDate = vData
                    If Right(szDate, 1) = "." Then szDate = Left(szDate, Len(szDate) - 1)
                End If
                If MyIsDate(szDate, r.Parent.Name) Then
                    vData = Format(Day(CDate(szDate)), "00") + "." & Format(Month(CDate(szDate)), "00") + "."
                Else
                    If [DatumMitMonat] Then
                        MsgBox szMsg + "Geben Sie ein g|fffd|ltiges Datum mit Tag und Monat ein.", vbInformation, TOOLHDR
                    Else
                        MsgBox szMsg + "Geben Sie ein g|fffd|ltiges Datum ein.", vbInformation, TOOLHDR
                    End If
                    bEditMode = True
                    bRetVal = False
                End If
            End If
            
        Case COL_BS_WARENART, COL_BS_NAMEORT, COL_BS_BEZAHLT, COL_BS_TEXT
            ' Maximale Textl|fffd|ngen festlegen
            lLen = IIf(ThisWorkbook.Worksheets(TAB_DATEN).Range("AllowLongText"), ThisWorkbook.Worksheets(TAB_DATEN).Range("LongTextMaxLen"), ThisWorkbook.Worksheets(TAB_DATEN).Range("StandardTextLen"))
            If r.Column = COL_BS_BEZAHLT Then lLen = MAX_LEN_INFO
            ' Zusatzinformation: maximal x Zeichen
            If Len(vData) > lLen Then
                szMsg = szMsg + "In den Einstellungen ist hinterlegt, dass f|fffd|r dieses Eingabefeld maximal " + CStr(lLen) + " Zeichen zul|fffd|ssig sind." + vbCrLf + vbCrLf + _
                    "Soll der Text automatisch gek|fffd|rzt werden?"
                If MsgBox(szMsg, vbOKCancel, TOOLHDR) = vbOK Then
                    vData = Left(r.Value, lLen)
                Else
                    bRetVal = False
                    GoTo END_Eingabekontrolle
                End If
            End If
            ' Zeilenh|fffd|he korrigieren
            If r.Parent.ProtectContents Then r.Parent.Unprotect
            ' Die Zeilenh|fffd|he |fffd|ber die Schriftgr|fffd||fffd|e festlegen. F|fffd|r einzelne Zeile kann die H|fffd|he alternativ
            ' auch direkt gesetzt werden. F|fffd|r das gesamte Blatt geht es so wesentlich schneller. Zudem
            ' bleibt die H|fffd|he konsistent.
            r.Parent.Cells(r.Row, 1).Font.Size = Val([DefaultLineHeightFont]) + IIf([ShowDateOnStatus], Val([DefaultLineHeightSpacing]), 0)
            ' 21.12.2010, tt: Unter Office 2007 kann der AutoFit einen LFZ 9 produzieren :-((
            On Error Resume Next
            r.EntireRow.AutoFit
            On Error GoTo ERR_Eingabekontrolle
            r.Parent.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
            ' Alles ok soweit --> Autoinsert pr|fffd|fen
            If ThisWorkbook.Worksheets(TAB_DATEN).Range("AutoKontoInsert") Then
                If TryAutotextInsert(r) Then
                    ' Es wurden Daten geschrieben --> aktuellen Wert wieder holen
                    vData = r.Value
                End If
            End If
            
        Case COL_BS_UST
            ' Zusatzinformation: Umsatzsteuersatz in Prozent (2.2)
            cMax = CCur("99,99")
            If Len(vData) > 0 Then
                If Not IsNumeric(vData) Then
                    MsgBox szMsg + "Geben Sie einen g|fffd|ltigen Betrag ein.", vbInformation, TOOLHDR
                    bRetVal = False
                    GoTo END_Eingabekontrolle
                End If
                ' Ok, generell ein numerischer Wert
                On Error Resume Next
                cData = CCur(vData)
                If Err.Number <> 0 Then
                    ' Aber viel zu gro|fffd|
                    MsgBox szMsg + "Der Betrag ist zu gro|fffd|. Geben Sie einen g|fffd|ltigen Betrag ein (max. 2.2-stellig).", vbInformation, TOOLHDR
                    bRetVal = False
                    On Error GoTo 0
                    GoTo END_Eingabekontrolle
                End If
                On Error GoTo ERR_Eingabekontrolle
                ' Ok, ein g|fffd|ltiger Currency-Wert
                If CCur(vData) >= 100 Then
                    ' Steuers|fffd|tze gr|fffd||fffd|er 100 gibt es hier nicht --> Eingabe ohne Dezimaltrennzeichen
                    cData = cData / 100
                    ' Damit der ge|fffd|nderte Wert auch wieder zur|fffd|ckgeschrieben wird
                    vData = cData
                End If
                cData = CCur(Format(cData, "#0.00"))
                ' Betrag auf maximal zul|fffd|ssigen Wert pr|fffd|fen
                If cData > cMax Then
                    MsgBox szMsg + "Der Betrag ist zu gro|fffd|. Geben Sie einen g|fffd|ltigen Betrag ein (max. 2.2-stellig).", vbInformation, TOOLHDR
                    bRetVal = False
                    GoTo END_Eingabekontrolle
                End If
                ' Anzahl an Nachkommastelen durch Rundung pr|fffd|fen
                cRounded = Application.WorksheetFunction.Round(cData * 100, 0)
                If cRounded <> cData * 100 Then
                    MsgBox szMsg + "Es sind nur 2 Nachkommastellen zul|fffd|ssig. Geben Sie einen g|fffd|ltigen Betrag ein.", vbInformation, TOOLHDR
                    bRetVal = False
                End If
            End If
            
    End Select
    GoTo END_Eingabekontrolle

ERR_Eingabekontrolle:
    MsgBox TOOLID + "012" + vbCrLf + vbCrLf + _
        "Bei der Verarbeitung der Eingabedaten ist ein Fehler aufgetreten." + vbCrLf + _
        "Fehler " + CStr(Err.Number) + vbCrLf + Err.Description + vbCrLf + vbCrLf + _
        Chr(187) + " Pr|fffd|fen Sie bitte Ihre Eingabe.", vbInformation, TOOLHDR
    On Error GoTo 0
    Application.EnableEvents = True
    bRetVal = False
    
END_Eingabekontrolle:
    On Error Resume Next
    If bRetVal Then
        If r.Value <> vData Then
            ' Ge|fffd|nderten Wert zur|fffd|ckschreiben
            Application.EnableEvents = False
            r.Value = vData
            Application.EnableEvents = True
        End If
    Else
        ' Fehlerhafte Zelle wieder markieren
        r.Parent.Select
        r.Select
        If bEditMode Then Call SendKeys("{F2}")
    End If
    On Error GoTo 0
    
    EingabeKontrolle = bRetVal
End Function

Sub EingabeKontrolleTextvorlagen(r As Range)
    Dim vData As Variant
    Dim vToCheck As Variant
    Dim lPos As Long
    Dim lMaxLenText As Long
    Dim bNumericKostOnly As Boolean
        
    ' Keine Eingabekontrolle
    If Not gbEingabeKontrolle Then Exit Sub
    ' Kein Eingabebereich
    If r.Row < ROW_TXT_START Then Exit Sub
    If r.Column < COL_TXT_START Or r.Column > COL_TXT_END Then Exit Sub
    ' Mehrfachselektion
    If r.Rows.Count > 1 Or r.Columns.Count > 1 Then Exit Sub
    
    ' Eingegebenen Wert vorbereiten
    On Error Resume Next
    vData = Trim(r.Value)
    If Err.Number <> 0 Then
        MsgBox TOOLID + "014" + vbCrLf + vbCrLf + _
            "Bei der Pr|fffd|fung der Zelle ist ein Fehler aufgetreten:" + vbCrLf + _
            CStr(Err.Number) + ": " + Err.Description + vbCrLf + vbCrLf + _
            Chr(187) + " Pr|fffd|fen Sie bitte Ihre Eingabe.", vbInformation, TOOLHDR
        On Error GoTo 0
        r.Select
        Exit Sub
    End If
    vToCheck = vData
        
    On Error GoTo ERR_EingabeKontrolleTextvorlagen_LFZ_9

    ' Daten|fffd|berpr|fffd|fung abh|fffd|ngig von der Spalte
    Select Case r.Column
        Case COL_TXT_KONTO, COL_TXT_GEGENKTO
            ' Sonderbehandlung f|fffd|r numerische Werte
            If Not IsNumeric(r.Value) Then
                Application.EnableEvents = False
                r.Value = ""
                Application.EnableEvents = True
                MsgBox TOOLID + "017" + vbCrLf + vbCrLf + _
                    "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                    "In dieses Eingabefeld muss ein numerischer Wert eingetragen werden.", _
                    vbInformation, TOOLHDR
                r.Select
            End If
        
        Case COL_TXT_TEXT1, COL_TXT_TEXT2
            lMaxLenText = IIf(ThisWorkbook.Worksheets(TAB_DATEN).Range("AllowLongText"), ThisWorkbook.Worksheets(TAB_DATEN).Range("LongTextMaxLen"), ThisWorkbook.Worksheets(TAB_DATEN).Range("StandardTextLen"))
            If COL_TXT_TEXT1 <> COL_TXT_TEXT2 And r.Column = COL_TXT_TEXT2 Then lMaxLenText = MAX_LEN_INFO
            ' Pr|fffd|fen, ob Gegenkonto in [] angegeben
            lPos = InStr(CStr(vToCheck), "[")
            ' Wenn Gegenkonto vorhanden, dann f|fffd|r die L|fffd|ngenpr|fffd|fung weglassen
            If lPos > 0 Then vToCheck = Trim(Left(vData, lPos - 1))
            ' L|fffd|ngenpr|fffd|fung
            If Len(vToCheck) > lMaxLenText Then
                Beep
                Application.EnableEvents = False
                If lPos > 0 Then
                    r.Value = Left(vToCheck, lMaxLenText) + " " + Mid(vData, lPos)
                Else
                    r.Value = Left(vToCheck, lMaxLenText)
                End If
                Application.EnableEvents = True
                MsgBox TOOLID + "016" + vbCrLf + vbCrLf + _
                    "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                    "F|fffd|r dieses Eingabefeld sind maximal " + CStr(lMaxLenText) + " Zeichen zul|fffd|ssig." + vbCrLf + vbCrLf + _
                    "Der Text wurde automatisch gek|fffd|rzt.", _
                    vbInformation, TOOLHDR
                r.Select
            End If
        
        Case COL_TXT_KOST1, COL_TXT_KOST2
            bNumericKostOnly = ThisWorkbook.Worksheets(TAB_DATEN).Range("NumericKostOnly")
            ' Maximal 8 Zeichen f|fffd|r KOST1 und KOST2
            If Len(vToCheck) > MAX_LEN_KOST Then
                Beep
                Application.EnableEvents = False
                r.Value = Left(vToCheck, MAX_LEN_KOST)
                Application.EnableEvents = True
                MsgBox TOOLID + "015" + vbCrLf + vbCrLf + _
                    "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                    "F|fffd|r dieses Eingabefeld sind maximal " + CStr(MAX_LEN_KOST) + IIf(bNumericKostOnly And r.Column = COL_BS_KOST1, " Ziffern", " Zeichen") + " zul|fffd|ssig." + vbCrLf + vbCrLf + _
                    "Der Text wurde automatisch gek|fffd|rzt.", _
                    vbInformation, TOOLHDR
                r.Select
            ElseIf Len(vToCheck) > 0 And bNumericKostOnly Then
                ' Noch auf nur Ziffern pr|fffd|fen
                If Not CStr(vToCheck) Like String(Len(vToCheck), "#") Then
                    ' Andere Zeichen vorhanden
                    Beep
                    MsgBox TOOLID + "025" + vbCrLf + vbCrLf + _
                        "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                        "Gem|fffd||fffd| Ihrer Einstellunge sind f|fffd|r Kostenstellen nur Ziffern zul|fffd|ssig.", _
                        vbInformation, TOOLHDR
                    r.Select
                End If
            End If
        
    End Select
    On Error GoTo 0
    Exit Sub
    
ERR_EingabeKontrolleTextvorlagen_LFZ_9:
    Call DoLogPerm("EingabeKontrolleTextvorlagen(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
End Sub

Sub EingabeKontrolleKostenstellen(r As Range)
    Dim vData As Variant
    Dim vToCheck As Variant
    Dim lPos As Long
    Dim bNumericKostOnly As Boolean
    
    ' Keine Eingabekontrolle
    If Not gbEingabeKontrolle Then Exit Sub
    ' Kein Eingabebereich
    If r.Row < ROW_TXT_START Then Exit Sub
    If r.Column < COL_KOST_START Or r.Column > COL_KOST_END Then Exit Sub
    ' Mehrfachselektion
    If r.Rows.Count > 1 Or r.Columns.Count > 1 Then Exit Sub
    
    ' Eingegebenen Wert vorbereiten
    On Error Resume Next
    vData = Trim(r.Value)
    If Err.Number <> 0 Then
        MsgBox TOOLID + "018" + vbCrLf + vbCrLf + _
            "Bei der Pr|fffd|fung der Zelle ist ein Fehler aufgetreten:" + vbCrLf + _
            CStr(Err.Number) + ": " + Err.Description + vbCrLf + vbCrLf + _
            Chr(187) + " Pr|fffd|fen Sie bitte Ihre Eingabe.", vbInformation, TOOLHDR
        On Error GoTo 0
        r.Select
        Exit Sub
    End If
    vToCheck = vData
        
    On Error GoTo ERR_EingabeKontrolleKostenstellen_LFZ_9

    ' Daten|fffd|berpr|fffd|fung abh|fffd|ngig von der Spalte
    Select Case r.Column
        Case COL_KOST_KOST
            bNumericKostOnly = ThisWorkbook.Worksheets(TAB_DATEN).Range("NumericKostOnly")
            ' Maximal 8 Zeichen f|fffd|r KOST1 und KOST2
            If Len(vToCheck) > MAX_LEN_KOST Then
                Beep
                Application.EnableEvents = False
                r.Value = Left(vToCheck, MAX_LEN_KOST)
                Application.EnableEvents = True
                MsgBox TOOLID + "019" + vbCrLf + vbCrLf + _
                    "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                    "F|fffd|r dieses Eingabefeld sind maximal " + CStr(MAX_LEN_KOST) + IIf(bNumericKostOnly And r.Column = COL_BS_KOST1, " Ziffern", " Zeichen") + " zul|fffd|ssig." + vbCrLf + vbCrLf + _
                    "Der Text wurde automatisch gek|fffd|rzt.", _
                    vbInformation, TOOLHDR
                r.Select
            ElseIf Len(vToCheck) > 0 And bNumericKostOnly Then
                ' Noch auf nur Ziffern pr|fffd|fen
                If Not CStr(vToCheck) Like String(Len(vToCheck), "#") Then
                    ' Andere Zeichen vorhanden
                    Beep
                    MsgBox TOOLID + "001" + vbCrLf + vbCrLf + _
                        "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                        "Gem|fffd||fffd| Ihrer Einstellunge sind f|fffd|r Kostenstellen nur Ziffern zul|fffd|ssig.", _
                        vbInformation, TOOLHDR
                    r.Select
                End If
            End If
        
        Case COL_KOST_TEXT
            ' Pr|fffd|fen, ob Gegenkonto in [] angegeben
            lPos = InStr(CStr(vToCheck), "[")
            ' Wenn Gegenkonto vorhanden, dann f|fffd|r die L|fffd|ngenpr|fffd|fung weglassen
            If lPos > 0 Then vToCheck = Trim(Left(vData, lPos - 1))
            ' L|fffd|ngenpr|fffd|fung
            If Len(vToCheck) > MAX_LEN_TEXT Then
                Beep
                Application.EnableEvents = False
                If lPos > 0 Then
                    r.Value = Left(vToCheck, MAX_LEN_TEXT) + " " + Mid(vData, lPos)
                Else
                    r.Value = Left(vToCheck, MAX_LEN_TEXT)
                End If
                Application.EnableEvents = True
                MsgBox TOOLID + "020" + vbCrLf + vbCrLf + _
                    "Die eingegebenen Daten sind mit dem Eingabefeld nicht vertr|fffd|glich!" + vbCrLf + _
                    "F|fffd|r dieses Eingabefeld sind maximal " + CStr(MAX_LEN_TEXT) + " Zeichen zul|fffd|ssig." + vbCrLf + vbCrLf + _
                    "Der Text wurde automatisch gek|fffd|rzt.", _
                    vbInformation, TOOLHDR
                r.Select
            End If
        
    End Select
    On Error GoTo 0
    Exit Sub
    
ERR_EingabeKontrolleKostenstellen_LFZ_9:
    Call DoLogPerm("EingabeKontrolleKostenstellen(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
End Sub

Sub UpdateLineHeights(ws As Worksheet)
    Dim bProtected As Boolean
    Dim bEnableEvents As Boolean
    Dim lLastRow As Long
    
    If Not LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then Exit Sub
    
    ' Worksheet vorbereiten
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    bEnableEvents = Application.EnableEvents
    Application.EnableEvents = False
    
    ' Das Spacing innerhalb der Zellen wird |fffd|ber die Schriftgr|fffd||fffd|e bestimmt
    ' Bis 10pt ist die Zellgr|fffd||fffd|e 12,75. Pro Punkt steigt sie um ca 1,18 an. Wir addieren das Spacing auf die aktuelle
    ' Schriftgr|fffd||fffd|e und setzen dadurch die H|fffd|he der Zellen
    
    ' Letzte Zeile bestimmen
    lLastRow = GetLastUsedRow(ws)
    ' Wir m|fffd|ssen nur etwas tun, wenn Buchungen da sind
    If lLastRow >= ROW_BS_START Then
        ' 21.12.2010, tt: Unter Office 2007 kann der AutoFit einen LFZ 9 produzieren :-((
        On Error Resume Next
        ws.Range(ws.Cells(ROW_BS_START, 1), ws.Cells(lLastRow, 1)).Font.Size = Val([DefaultLineHeightFont]) + IIf([ShowDateOnStatus], Val([DefaultLineHeightSpacing]), 0)
        ws.Range(ws.Cells(ROW_BS_START, 1), ws.Cells(lLastRow, 1)).EntireRow.AutoFit
        On Error GoTo 0
    End If
        
    ' Worksheet wieder zur|fffd|cksetzen
    If bEnableEvents Then Application.EnableEvents = True
    If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
End Sub

Private Function ConvertKto(ByVal szKto As String) As String
    Dim i As Integer
    Dim szOut As String
    Dim szMatch As String
    
    szOut = Trim(szKto)
    i = InStr2(szOut, " ,.", szMatch)
    Do While i > 0
        szOut = Left(szOut, i - 1) & Mid(szOut, i + 1)
        i = InStr2(szOut, " ,.", szMatch)
    Loop
    ConvertKto = szOut
End Function

' ConvertDate()
' Konvertiert einen Datumsstring der Form "[d]d[mm[yy[yy]]]" in ein Datum
Private Function ConvertDate(ByVal szDateIn As String, szName As String) As String
    Dim i As Integer
    Dim szDay As String
    Dim szMonth As String
    Dim szYear As String
    
    ConvertDate = szDateIn
    ' Monat und Jahr aus dem Namen ableiten
    i = InStr(szName, ".")
    szMonth = Left(szName, i - 1)
    szYear = Mid(szName, i + 1)
    ' Fehlende f|fffd|hrende 0 und fehlendes Jahr erg|fffd|nzen
    i = Len(szDateIn)
    Select Case i
        Case 1, 2
            If [DatumMitMonat] Then
                ConvertDate = szDateIn
            Else
                ConvertDate = IIf(i = 1, "0" + szDateIn, szDateIn) + "." + szMonth + "." + szYear
            End If
        Case 3
            szDay = Format(Left(szDateIn, 1), "00")
            szMonth = Right(szDateIn, 2)
            ConvertDate = szDay + "." + szMonth + "." & szYear
        Case 4
            szDay = Left(szDateIn, 2)
            szMonth = Right(szDateIn, 2)
            ConvertDate = szDay + "." + szMonth & "." + szYear
        Case 5, 7
            ConvertDate = "0" + szDateIn
    End Select
End Function

' MyIsDate()
' |fffd|hnlich wie IsDate(), erwartet aber immer ein Datum in der Form "[d]d.[m]m.[yy[yy]]"
Private Function MyIsDate(szDate As String, szName As String) As Boolean
    Dim szConv As String
    Dim da As Date
    Dim i As Integer
    Dim iDay As Integer
    Dim iMonth As Integer
    Dim iYear As Integer
    Dim szMonth As String
    Dim szYear As String
    
    MyIsDate = False
    
    ' Monat und Jahr aus dem Namen ableiten
    i = InStr(szName, ".")
    szMonth = Left(szName, i - 1)
    szYear = Mid(szName, i + 1)
    
    On Error GoTo ErrMyIsDate
    i = InStr(szDate, ".")
    If i = 0 Then Exit Function
    ' Tag
    iDay = Val(Left(szDate, i - 1))
    If iDay < 1 Or iDay > 31 Then Exit Function
    szConv = Mid(szDate, i + 1)
    ' Monat
    i = InStr(szConv, ".")
    If i = 0 Then
        iMonth = Val(szConv)
        If iMonth = 0 Then iMonth = Val(szMonth)
        szConv = ""
    Else
        iMonth = Val(Left(szConv, i - 1))
        szConv = Mid(szConv, i + 1)
    End If
    If iMonth < 1 Or iMonth > 12 Then Exit Function
    Select Case iMonth
        Case 4, 6, 9, 11
            If iDay > 30 Then Exit Function
        Case 2
            If iDay > 29 Then Exit Function
    End Select
    ' Jahr
    If szConv <> "" Then
        iYear = Val(szConv)
        If iYear < 0 Or iYear > 2999 Then Exit Function
    Else
        iYear = Val(szYear)
    End If
    ' Validieren
    szConv = Format(iDay, "00") + "." + Format(iMonth, "00") + "." + CStr(iYear)  'IIf(szConv = "", "", "." & szConv)
    If Not IsDate(szConv) Then Exit Function
    MyIsDate = True
    ' Fall through
    
ErrMyIsDate:
    On Error GoTo 0
End Function

Private Function rIndex(szRange As String, szChar As String) As Integer
    Dim i As Integer
    
    rIndex = 0
    For i = Len(szRange) To 1 Step -1
        If Mid(szRange, i, Len(szChar)) = szChar Then
            rIndex = i
            Exit Function
        End If
    Next
End Function

Private Function CheckBelegfeld(ByVal szBelegfeld As String) As Boolean
    Dim i As Long
    Dim szC As String
    Const szSpecial As String = "$&%*+-/"   ' tt, 28.06.2007: Umlaute entfernt
    
    CheckBelegfeld = True
    For i = 1 To Len(szBelegfeld)
        szC = Mid(szBelegfeld, i, 1)
        If (szC >= "A" And szC <= "Z") Or (szC >= "a" And szC <= "z") Or _
            (szC >= "0" And szC <= "9") Or (InStr(szSpecial, szC) > 0) Then
            ' Nop
        Else
            CheckBelegfeld = False
            Exit For
        End If
    Next i
End Function

Private Function ConvertBelegfeld(ByVal szBelegfeld As String) As String
    Dim i As Long
    Dim szC As String
    Const szSpecial As String = "$&%*+-/"   ' tt, 28.06.2007: Umlaute entfernt
    
    ConvertBelegfeld = szBelegfeld
    For i = 1 To Len(szBelegfeld)
        szC = Mid(szBelegfeld, i, 1)
        If (szC >= "A" And szC <= "Z") Or (szC >= "a" And szC <= "z") Or _
            (szC >= "0" And szC <= "9") Or (InStr(szSpecial, szC) > 0) Then
            ' Nop
        Else
            Mid(ConvertBelegfeld, i, 1) = "%"
        End If
    Next i
End Function

Private Function InStr2(szIn As String, szWhat As String, szMatch As String) As Long
    Dim i As Long
    Dim j As Long
    Dim szC As String
    
    InStr2 = 0
    For i = 1 To Len(szIn)
        For j = 1 To Len(szWhat)
            szMatch = Mid(szWhat, j, 1)
            If Mid(szIn, i, 1) = szMatch Then
                InStr2 = i
                Exit Function
            End If
        Next j
    Next i
End Function

Private Function TryAutotextInsert(r As Range) As Boolean
    Dim rHitFirst As Range
    Dim rHitNext As Range
    Dim wsTexte As Worksheet
    Dim szPattern As String
    Dim lLastRow As Long
    Dim lTextCol As Long
    Dim szData As String
    Dim bEinzelwert As Boolean
    Dim objMain As Object
    
    On Error Resume Next
    ' R|fffd|ckgabewert: False=es wurde nichts eingef|fffd|gt, True=es wurde was eingef|fffd|gt
    TryAutotextInsert = False
    
    Set objMain = MainServer("KWEVorlagen")
    If objMain Is Nothing Then
        ' Wenn die Schnittstelle nicht vorhanden ist, dann sind wir schon fertig
        Exit Function
    End If
    
    ' Nach der passenden Vorlage suchen
    Set wsTexte = ThisWorkbook.Worksheets(TAB_TEXTE)
    lLastRow = GetLastUsedRow(wsTexte)
    ' Variablen je nach Spalte setzen
    Select Case r.Column
        Case COL_BS_KONTO
            lTextCol = COL_TXT_KONTO
            bEinzelwert = [AutotextInsertSingle]    ' Nur den Buchungstext |fffd|bernehmen?
        Case COL_BS_GEGENKTO
            lTextCol = COL_TXT_GEGENKTO
            bEinzelwert = False     ' Was soll bei der Ware der korrespondiernde "Einzelwert" sein?
        Case COL_BS_TEXT
            lTextCol = COL_TXT_TEXT1
            bEinzelwert = [AutotextInsertSingle]    ' Nur den Buchungstext |fffd|bernehmen?
        Case COL_BS_NAMEORT
            lTextCol = COL_TXT_TEXT1
            bEinzelwert = False     ' Was soll bei der Ware der korrespondiernde "Einzelwert" sein?
        Case COL_BS_WARENART
            lTextCol = COL_TXT_TEXT2
            bEinzelwert = False     ' Was soll bei der Ware der korrespondiernde "Einzelwert" sein?
    End Select
    
    ' Ersten Eintrag suchen (als Suchstring wird der bereits normalisierte Wert verwendet)
    szPattern = CStr(r.Value)
    Set rHitFirst = wsTexte.Range(wsTexte.Cells(ROW_TXT_START, lTextCol), wsTexte.Cells(lLastRow, lTextCol)).Find(What:=szPattern, After:=wsTexte.Cells(ROW_TXT_START, lTextCol), SearchOrder:=xlByRows, SearchDirection:=xlNext)
    If Not rHitFirst Is Nothing Then
        ' Nachfolger pr|fffd|fen
        Set rHitNext = wsTexte.Range(wsTexte.Cells(ROW_TXT_START, lTextCol), wsTexte.Cells(lLastRow, lTextCol)).FindNext(rHitFirst)
        If rHitNext.Address = rHitFirst.Address Then
            ' Es gibt nur einen --> Daten zusammenbauen
            If [TOOLKASSE] Then
                ' Nop, Nop, GegKto, Text, Nop, Kost1, Kost2
                szData = _
                    "##" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_GEGENKTO)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_TEXT1)) + "#" + _
                    "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_KOST1)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_KOST2))
            Else
                ' Nop, Konto, GegKto, Text, WarenArt, Kost1, Kost2
                szData = _
                    "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_KONTO)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_GEGENKTO)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_TEXT1)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_TEXT2)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_KOST1)) + "#" + _
                    CStr(wsTexte.Cells(rHitFirst.Row, COL_TXT_KOST2))
            End If
            ' Daten einf|fffd|gen
            On Error Resume Next
            gbEingabeKontrolle = False
            TryAutotextInsert = objMain.AuswahlSchreiben(r, r.Column, szData, bEinzelwert)
            gbEingabeKontrolle = True
        ElseIf [AutotextInsertAlways] Then
            ' Es gibt mehrere --> Auswahl anzeigen
            On Error Resume Next
            gbEingabeKontrolle = False
            TryAutotextInsert = objMain.AuswahlText(r)
            gbEingabeKontrolle = True
        End If
    Else
        ' Kein Eintrag gefunden --> nop
    End If
    
    Set wsTexte = Nothing
    Set objMain = Nothing

End Function
Attribute VB_Name = "gmodErfassungVorbereiten"
Option Explicit

Public Sub ErfassungsseitenAnlegen()
    Dim wb As Workbook
    Dim wsSD As Worksheet
    Dim wsTempl As Worksheet
    Dim wsNew As Worksheet
    Dim wsPrev As Worksheet
    Dim hit As Range
    Dim i As Long
    Dim iTag As Long
    Dim iMonat As Long
    Dim iJahr As Long
    Dim iAnzahl As Long
    Dim szName As String
    Dim szNamePrev As String
    Dim szBuch As String
    Dim szFirst As String
    Dim lSortKey As Long
    Dim szSortText As String
    
    Set wb = ThisWorkbook   'Workbooks("dv" + szTitel + ".xlt")
    Set wsSD = wb.Worksheets(TAB_DATEN)
    
    ' Template vorbereiten
    Set wsTempl = wb.Worksheets(TAB_TEMPLATE)
    wsTempl.Visible = xlSheetVisible
    If wsTempl.ProtectContents Then wsTempl.Unprotect
    wsTempl.Activate
    
    ' Monatsbl|fffd|tter l|fffd|schen
    For i = 13 To 1 Step -1
        szName = "Blatt_" + Format(i, "00")
        If ExistsWorksheet(wb, szName) Then
            Application.DisplayAlerts = False
            wb.Worksheets(szName).Delete
            Application.DisplayAlerts = True
        End If
    Next i
    ' 13 Monatsbl|fffd|tter anlegen
    szName = ""
    For i = 1 To 13
        szNamePrev = szName
        szName = "Blatt_" + Format(i, "00")
        Debug.Print "Bearbeite " + szName
        ' Neues Sheet hinten anh|fffd|ngen
        If szNamePrev = "" Then
            wsTempl.Copy After:=wb.Worksheets(wb.Worksheets.Count)
        Else
            wsTempl.Copy After:=wb.Worksheets(szNamePrev)
        End If
        Set wsNew = ActiveSheet
'        ' Pr|fffd|fen und ggf l|fffd|schen
'        If ExistsWorksheet(wb, szName) Then
'            Application.DisplayAlerts = False
'            wb.Worksheets(szName).Delete
'            Application.DisplayAlerts = True
'        End If
        ' Namen vergeben
        wsNew.Name = szName
        ' Eingabezellen aktivieren
        wsNew.EnableSelection = xlUnlockedCells
        ' Sheets hier nicht ausblenden, da sonst die Reihenfolge nicht passt
        'wsNew.Visible = xlSheetHidden
        Call HideButton(wsNew, "Jahres|fffd|bernahme")
    Next i
    ' Sheets ausblenden
    wsTempl.Visible = xlSheetHidden
    For i = 1 To 13
        wb.Worksheets("Blatt_" + Format(i, "00")).Visible = xlSheetHidden
    Next i
    wb.Worksheets(TAB_MAIN).Activate
    
    Set wsSD = Nothing
    Set wsTempl = Nothing
    Set wsNew = Nothing
    
    MsgBox "Fertig"
End Sub

Private Function ExistsWorksheet(wb As Workbook, szName As String) As Boolean
    ExistsWorksheet = False
    On Error GoTo ErrExistsWorksheet
    If wb.Worksheets(szName).Name = szName Then ExistsWorksheet = True
    On Error GoTo 0
    Exit Function
    
ErrExistsWorksheet:
    On Error GoTo 0
End Function

Private Sub HideButton(ws As Worksheet, szText As String)
    Dim i As Long
    
    For i = 1 To ws.Shapes.Count
        If ws.Shapes(i).Type = msoFormControl Then
            ' Einer der Buttons
            If ws.Shapes(i).AlternativeText = szText Then
                ws.Shapes(i).Visible = msoFalse
            End If
        End If
    Next i
    Set ws = Nothing
End Sub
Attribute VB_Name = "gmodExportASCII"
Option Explicit


'
' |fffd|ffentliche Funktionen
'

Public Sub DoExportASCII(ws As Worksheet, lLast As Long)
    Dim fm As gfrmExportASCII
    Dim szFile As String
    
    ' Exportdatei bestimmen
    Set fm = New gfrmExportASCII
    Set fm.ExportSheet = ws
    fm.Show
    If fm.Abbruch Then
        GoTo END_DoExportASCII
    End If
    szFile = fm.ExportFile
    
    If ASCII_DoExport(ws, lLast, szFile) Then
        ' Erfolgreich geschrieben, daher Pfad zur|fffd|ckschreiben
        ThisWorkbook.Worksheets(TAB_DATEN).Range("ZielVerzeichnisASCII") = szFile
    End If
    
END_DoExportASCII:
    Unload fm
    Set fm = Nothing
End Sub



'
' Private Funktionen
'

Private Function ASCII_DoExport(ws As Worksheet, lLastRow As Long, szFile As String) As Boolean
    Dim fd As Integer
    Dim lRetVal As Long
    Dim bError As Boolean

    ' In [ZielVerzeichnisASCII] steht der Pfad und die Datei. Falls sie bereits
    ' existiert darf sie |fffd|berschrieben werden, da die Abfrage bereits im Dialog
    ' erfolgte.
    fd = ASCII_OpenExportFile(szFile)
    If fd = 0 Then Exit Function
    
    lRetVal = ASCII_WriteHeader(fd, ws)
    If lRetVal <> 0 Then
        ' Uups ein Problem...
        MsgBox "Fehler beim Schreiben der Stammdaten... " + CStr(lRetVal)
        bError = True
        GoTo END_DoExportASCII
    End If

    lRetVal = ASCII_WriteData(fd, ws, lLastRow)
    If lRetVal <> 0 Then
        ' Uups ein Problem...
        MsgBox "Fehler beim Schreiben der Buchungsdaten... " + CStr(lRetVal)
        bError = True
    End If
        
END_DoExportASCII:
    ASCII_DoExport = Not bError
    Close #fd
    If Not bError Then
        MsgBox TOOLID + "040" + vbCrLf + vbCrLf + _
            "Die Exportdatei" + vbCrLf + _
            szFile + vbCrLf + _
            "wurde angelegt.", vbInformation, TOOLHDR
    End If
End Function

Private Function ASCII_OpenExportFile(szFile As String) As Integer
    Dim fd As Integer
    Dim lRetVal As Long
    
    ASCII_OpenExportFile = 0
    
    fd = FreeFile
    On Error GoTo ASCII_OpenExportFileErr
    Open szFile For Output As fd
    ASCII_OpenExportFile = fd
    Exit Function
    
ASCII_OpenExportFileErr:
    MsgBox TOOLID + "041" + vbCrLf + vbCrLf + _
        "Beim |fffd|ffnen der Datei ist der Fehler " + CStr(Err.Number) + " aufgetreten:" + vbCrLf + _
        Err.Description + vbCrLf + vbCrLf + _
        "Der Export wird abgebrochen.", vbCritical, TOOLHDR
    On Error GoTo 0
End Function

Private Function ASCII_WriteHeader(fd As Integer, ws As Worksheet) As Long
    ASCII_WriteHeader = 0
    
    On Error GoTo ASCII_WriteHeaderErr
    ' 1. Versionsnummer schreiben
    Print #fd, "[HEADER]"
    Print #fd, "Version;" + CStr(TOOLEXPVERS)
    ' 2. Ordnungsbegriff: BNR, MNR, MName, WJBeginn, WJEnde
    Print #fd, "BNR;" + CStr(ThisWorkbook.Worksheets(TAB_DATEN).Range("BNR"))
    Print #fd, "MNR;" + CStr(ThisWorkbook.Worksheets(TAB_DATEN).Range("MNR"))
    Print #fd, "MName;" + CStr(ThisWorkbook.Worksheets(TAB_DATEN).Range("MName"))
    Print #fd, "WJBeginn;" + CStr(ThisWorkbook.Worksheets(TAB_DATEN).Range("WJBeginn"))
    Print #fd, "WJEnde;" + CStr(ThisWorkbook.Worksheets(TAB_DATEN).Range("WJEnde"))
    ' 3. Header der Bewegungsdaten: Monat, AB, EB
    Print #fd, "Monat;" + CStr(ws.Name)
    Print #fd, "AB;" + Format(ws.Cells(ROW_HD_SALDO, COL_HD_SALDO).Value, "#0.00")
    Print #fd, "EB;" + Format(ws.Cells(ROW_HD_SALDO, COL_HD_SALDOEND).Value, "#0.00")
    Print #fd, "LfdNr;" + CStr(ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value)
    ' Header ist hier zu Ende
    On Error GoTo 0
    Exit Function
    
ASCII_WriteHeaderErr:
    ASCII_WriteHeader = Err.Number
    On Error GoTo 0
End Function

Private Function ASCII_WriteData(fd As Integer, ws As Worksheet, lLastRow As Long)
    Dim szLine As String
    Dim szValue As String
    Dim lRow As Long
    Dim lCol As Long
    
    ASCII_WriteData = 0

    On Error GoTo ASCII_WriteDataErr
    
    Print #fd, "[DATA]"
    ' Schleife |fffd|ber die Buchungszeilen (inkl. Header)
    For lRow = ROW_BS_START - 1 To lLastRow
        szLine = ""
        For lCol = COL_BS_START To COL_OFFSET + COL_ANZAUSWERT
            Select Case lCol
                Case COL_BS_LFDNR, COL_BS_SOLL, COL_BS_HABEN, COL_BS_B, COL_BS_U, _
                     COL_BS_GEGENKTO, COL_BS_BELEG1, COL_BS_BELEG2, COL_BS_DATUM, _
                     COL_BS_KOST1, COL_BS_KOST2, COL_BS_KOSTMENGE, COL_BS_SKONTO, _
                     COL_BS_TEXT, COL_BS_UST, _
                     COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KONTO, COL_BS_BEZAHLT, _
                     COL_AW_DAT_CREATED, COL_AW_DAT_CHANGED, COL_AW_DAT_CHECKED, _
                     COL_AW_DAT_EXPORTED, COL_AW_CRC32, COL_AW_LFDNR
                    ' Achtung keine Zeilenumbr|fffd|che |fffd|bernehmen!
                    szValue = ReplaceCrLf(CStr(ws.Cells(lRow, lCol).Value))
                    szLine = szLine + szValue + ";"
            End Select
        Next lCol
        'szLine = Left(szLine, Len(szLine) - 1)
        Print #fd, szLine
    Next lRow
    ' Bewegungsdaten sind hier zu Ende
    On Error GoTo 0
    Exit Function
    
ASCII_WriteDataErr:
    ASCII_WriteData = Err.Number
    On Error GoTo 0
End Function


Attribute VB_Name = "gmodGetDir"
Option Explicit

Public Function GetDirFromDialog(szTitle As String) As String
    Dim bi As BROWSEINFO
    Dim pidl As Long
    Dim r As Long
    Dim pos As Integer
    Dim spath As String

   'Fill the BROWSEINFO structure with the needed data.
    bi.hOwner = GetActiveWindow
    
   'Pointer to the item identifier list specifying the
   'location of the "root" folder to browse from.
   'If NULL, the desktop folder is used.
    bi.pidlRoot = 0&

   'message to be displayed in the Browse dialog.
   'Note: the code here does not check to determine if
   'in fact the system folder was selected; it is provided
   'only as an example of a message.
    bi.lpszTitle = szTitle

   'the type of folder to return.
    bi.ulFlags = BIF_RETURNONLYFSDIRS

   'show the browse folder dialog
    pidl& = SHBrowseForFolder(bi)

   'the dialog has closed, so parse & display the user's
   'returned folder selection contained in pidl&.
    spath$ = Space$(512)
    r = SHGetPathFromIDList(ByVal pidl&, ByVal spath$)

    If r Then
        pos = InStr(spath$, Chr$(0))
        GetDirFromDialog = Left(spath$, pos - 1)
    Else
        GetDirFromDialog = ""
    End If
    Call CoTaskMemFree(pidl)
End Function

Attribute VB_Name = "gmodInterface"
Option Explicit


'
' 1. Schaltfl|fffd|chen, die |fffd|berall gleich sind
'
Public Sub GrafikHilfeClick()
    Call HoleHilfe("HLPID_MAIN")
End Sub


'
' 2. Schaltfl|fffd|chen der Seite Stammdaten
'

' 2.1 Organisationshinweise
Public Sub ButtonOrgHinweiseClick()
    Call HoleHilfe("HLPID_GOB")
End Sub

' 2.2 Stammdaten |fffd|ndern
Public Sub ButtonStammdatenAendernClick()
    Dim fm As gfrmStammdaten
    
    Set fm = New gfrmStammdaten
    fm.Show
    Unload fm
    Set fm = Nothing
End Sub

' 2.3 Verwaltung anzeigen
Public Sub ButtonVerwaltungAnzeigenClick()
    Dim oVerwalt As Object
    
    On Error Resume Next
    ' Das Verwaltungsobjekt anlegen
    Set oVerwalt = MainServer("KWEVerwaltung")
    If oVerwalt Is Nothing Then
        MsgBox TOOLID + "002" + vbCrLf + vbCrLf + _
            "Eine ben|fffd|tigte Komponente der Anwendung konnte nicht gefunden werden." + vbCrLf + _
            "Die Verwaltung kann daher nicht angezeigt werden." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbInformation, TOOLHDR
        GoTo END_ButtonVerwaltungAnzeigenClick
    End If
    ' ...und Main zuweisen
    Set oVerwalt.XlApplication = Application
    Call oVerwalt.VerwaltungAnzeigen
    
END_ButtonVerwaltungAnzeigenClick:
    Set oVerwalt = Nothing
End Sub

' 2.4 Hilfe
Public Sub ButtonStammdatenHilfeClick()
    Call HoleHilfe("HLPID_MAIN")
End Sub

' 2.5 Toolinfo
Public Sub LabelToolInfoClick()
    Dim oServer As Object
    Dim ws As Worksheet
    
    On Error Resume Next
    Set oServer = CreateObject("DvKasseWareDllInfo.KWEDllInfo")
    If Err.Number = 0 Then
        Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
        oServer.KWTypKasse = (ws.Range("ToolKasse"))
        oServer.KWVersion = CStr(ws.Range("ToolVersion"))
        oServer.KWBuild = CStr(ws.Range("ToolStand"))
        Call oServer.DllInfo
        Set ws = Nothing
        Set oServer = Nothing
    End If
    On Error GoTo 0
End Sub

'
' 3. Schaltfl|fffd|chen der Textvorlagen
'

' 3.1 Importieren (Textvorlagen)
Public Sub ButtonImportTextVorlagenClick()
    ' Diese Funktion ist f|fffd|r den Import von Daten in die Tabellen
    ' Textvorlagen und Kostenstelle gleicherma|fffd|en geeignet
    Call DoImportTextVorlagen
End Sub

' 3.2 Exportieren (Textvorlagen)
Public Sub ButtonExportTextVorlagenClick()
    ' Diese Funktion ist f|fffd|r den Export von Daten aus den Tabellen
    ' Textvorlagen und Kostenstelle gleicherma|fffd|en geeignet
    Call DoExportTextVorlagen
End Sub

' 3.3 Hilfe Import Kontenplan
Public Sub ButtonHilfeTextvorlagenClick()
    Call HoleHilfe("HLPID_VORLAGEN")
End Sub


'
' 4. Schaltfl|fffd|chen der Kostenstellen
'

' 4.1 Importieren (Kostenstellen)
Public Sub ButtonImportTextKostenstellenClick()
    ' Diese Funktion ist f|fffd|r den Import von Daten in die Tabellen
    ' Textvorlagen und Kostenstelle gleicherma|fffd|en geeignet
    Call DoImportTextVorlagen
End Sub

' 4.2 Exportieren (Kostenstellen)
Public Sub ButtonExportTextKostenstellenClick()
    ' Diese Funktion ist f|fffd|r den Export von Daten aus den Tabellen
    ' Textvorlagen und Kostenstelle gleicherma|fffd|en geeignet
    Call DoExportTextVorlagen
End Sub

' 4.3 Hilfe Import Kostenstellen
Public Sub ButtonHilfeKostenstellenClick()
    Call HoleHilfe("HLPID_VORLAGEN")
End Sub


'
' 5. Schaltfl|fffd|chen der Erfassungsseiten
'

' 5.1 Pr|fffd|fen/Aktualisieren
' 5.2 Drucken
' 5.3 Exportieren
' 5.4 Importieren
' 5.5 Einstellungen
' 5.6 Buchung(en) l|fffd|schen
' 5.7 Hilfe


' 5.1 Pr|fffd|fen/Aktualisieren
Public Sub ButtonAktualisierenClick()
    Dim ws As Worksheet
    Dim lRetVal As Long
    Dim tStart As Single
    Dim tEnd As Single
    
    ActiveCell.Select
    Set ws = ActiveSheet
    
    
    tStart = Timer
    Call UpdateLaufendeNummer(ws)
    
    ' Daten pr|fffd|fen
    lRetVal = AktualisiereMonat(ws, False)
    
    Call UpdateStatusColumn(ws)
    Call UpdateLineHeights(ws)
    
    tEnd = Timer
    
    'MsgBox "Dauer = " & tEnd - tStart & " s"
    
    Set ws = Nothing
    If lRetVal <> BS_ERROR Then ActiveCell.Select
End Sub

' 5.2 Drucken
Public Sub ButtonDruckenClick()
    Dim ws As Worksheet
    Dim lRetVal As Long
    
    
    ActiveCell.Select
    Set ws = ActiveSheet
    
    lRetVal = DruckeMonat(ws)
    
    Set ws = Nothing
    If lRetVal <> BS_ERROR Then ActiveCell.Select
End Sub

' 5.3 Exportieren
Public Sub ButtonExportClick()
    Dim ws As Worksheet
    Dim lRetVal As Long
    Dim oServer As Object
    Dim lLast As Long
    
    ActiveCell.Select
    Set ws = ActiveSheet
    
    ' Daten pr|fffd|fen
    lRetVal = AktualisiereMonat(ws, True)
    Select Case lRetVal
        Case BS_EMPTY
            ' Es gibt keine Buchungss|fffd|tze
            MsgBox TOOLID + "035" + vbCrLf + vbCrLf + _
                "Das Eintragungsblatt enth|fffd|lt keine Daten.", _
                vbInformation, TOOLHDR
            Set ws = Nothing
            ActiveCell.Select
            Exit Sub
        Case BS_ERROR
            ' Es sind Fehler aufgetreten, die bereinigt werden m|fffd|ssen
            lRetVal = MsgBox(TOOLID + "034" + vbCrLf + vbCrLf + _
                "Bei der Pr|fffd|fung der Buchungss|fffd|tze sind Fehler gefunden worden." + vbCrLf + vbCrLf + _
                "Soll der Export trotzdem durchgef|fffd|hrt werden?", _
                vbYesNoCancel + vbInformation, TOOLHDR)
            If lRetVal <> vbYes Then
                Set ws = Nothing
                Exit Sub
            End If
    End Select
    
    ' Letzte Buchungszeile bestimmen und evtl. korrigieren
    lLast = GetLastUsedRow(ws)
    
    ' Pr|fffd|fen, ob der Server f|fffd|r die Businesslogik vorhanden ist
    Set oServer = MainServer("KWEExport")
    If oServer Is Nothing Then
        ' Nicht installiert --> Nur den ASCII-Export anbieten
        Call DoExportASCII(ws, lLast)
    Else
        ' Installiert --> Alle Exportvarianten
        ' Returns: -1=Cancel, 0=Success, 1=Error
        lRetVal = oServer.ExportDaten(ws)
        Set oServer = Nothing
    End If
    
    Set ws = Nothing
    ActiveCell.Select
End Sub

' 5.4 Importieren
Public Sub ButtonImportClick()
    Dim ws As Worksheet
    Dim lRetVal As Long
    Dim oServer As Object
    Dim szMsg As String
    
    ActiveCell.Select
    Set ws = ActiveSheet
    
    ' Pr|fffd|fen, ob der Server f|fffd|r die Businesslogik vorhanden ist
    Set oServer = MainServer("KWEImport")
    If oServer Is Nothing Then
        ' Nicht installiert --> Pech
        MsgBox TOOLID + "036" + vbCrLf + vbCrLf + _
            "Eine ben|fffd|tigte Komponente der Anwendung " + TOOLNAME + " konnte nicht gefunden werden." + vbCrLf + _
            "Es steht daher kein ASCII-Import von Buchungss|fffd|tzen zur Verf|fffd|gung." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbInformation, TOOLHDR
    Else
        ' Installiert --> Alle Importvarianten
        ' Returns: 0=Error, -1=Cancel >0=Success (Anzahl Zeilen)
        lRetVal = oServer.ImportDaten(ws)
        Select Case lRetVal
            Case 0
                ' Fehler aufgetreten
'                MsgBox oServer.Message, vbCritical, TOOLHDR
            Case -1
                ' Abbruch --> Keine Ma|fffd|nahme
            Case Else
                ' Alles ok --> Tool-interne Pr|fffd|fung anwerfen
'                MsgBox TOOLID + "033" + vbCrLf + vbCrLf + _
'                    "Es wurden " + CStr(lRetVal) + " Datens|fffd|tze importiert." + vbCrLf + _
'                    "Die Pr|fffd|fung der Daten wird gestartet.", _
'                    vbInformation, TOOLHDR
                Call ButtonAktualisierenClick
        End Select
        Set oServer = Nothing
    End If
    
    Set ws = Nothing
    ActiveCell.Select
End Sub

' 5.5 Einstellungen
Public Sub ButtonEinstellungenClick()
    Dim lRetVal As Long
    Dim bProtected As Boolean
    Dim ws As Worksheet
    Dim fOptionen As gfrmEinstellungen
    Dim oServer As Object
    
    ActiveCell.Select
    Set ws = ActiveSheet

    ' Blattschutz aufheben
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect

    ' Pr|fffd|fen, ob der Server f|fffd|r die Businesslogik vorhanden ist
    Set oServer = MainServer("KWEOptionen")
    If oServer Is Nothing Then
        ' Nicht installiert --> Nur den ASCII-Export anbieten
        lRetVal = BS_OK
        Set fOptionen = New gfrmEinstellungen
        fOptionen.IsKasse = CBool(ThisWorkbook.Worksheets(TAB_DATEN).Range("ToolKasse"))
        fOptionen.Show
        If Not fOptionen.Abbruch Then
            If LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
                lRetVal = AktualisiereMonat(ws, True)
                Call UpdateStatusColumn(ws)
                Call UpdateLineHeights(ws)
            End If
        End If
        Unload fOptionen
        Set fOptionen = Nothing
    Else
        ' Installiert --> Alle Exportvarianten
        ' Returns: BS_OK = 1 = Success, BS_ERROR = -2 = Error
        lRetVal = oServer.Einstellungen(ws)
        Set oServer = Nothing
        ' Erfassungsseite aktualisieren
        If LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" And lRetVal = BS_OK Then
            lRetVal = AktualisiereMonat(ws, True)
            Call UpdateStatusColumn(ws)
            Call UpdateLineHeights(ws)
        End If
    End If
    
    ' Blattschutz wieder herstellen
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True

    Set ws = Nothing
    If lRetVal <> BS_ERROR Then ActiveCell.Select
End Sub

' 5.6 Buchung(en) l|fffd|schen
Public Sub ButtonZeileL|fffd|schenClick()
    Call L|fffd|scheBuchungssatz(Selection)
End Sub

' 5.7 Hilfe
Public Sub ButtonErfassungHilfeClick()
    Call HoleHilfe("HLPID_ERFASSUNG")
    ActiveCell.Select
End Sub

' 5.8 Jahres|fffd|bernahme (optional, nur letzte Seite)
Public Sub ButtonErfassungJahresUebernahmeClick()
    Dim bRetVal As Boolean
    Dim oServer As Object
    Dim szWJNeu As String
    Dim lRetVal As Long
    Dim dDateTemp As Date
    
    ActiveCell.Select

    ' Pr|fffd|fen, ob der Server f|fffd|r die Businesslogik vorhanden ist
    On Error Resume Next
    Set oServer = MainServer("KWENeuanlage")
    If oServer Is Nothing Then
        ' Nicht installiert --> das ist aber schade
        MsgBox TOOLID + "050" + vbCrLf + vbCrLf + _
            "Die angeforderte Funktion kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "weil eine notwendige Komponente nicht initialisiert werden konnte." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbExclamation, TOOLHDR
        Call DoLogPerm("ButtonErfassungJahresUebernahmeClick(); MainServer(""KWENeuanlage"")=Nothing")
    Else
        ' Vorgehen:
        '
        ' WJEnde_alt vorhanden   --> WJBeginn_neu = WJEnde_alt + 1d; WJEnde_neu = WJBeginn_neu + 1a - 1d
        ' nur WJBeginn vorhanden --> WJBeginn_neu = WJBeginn_alt + 1a; WJEnde_neu = WJBeginn_neu + 1a - 1d
        ' WJBeginn = DateAdd("d", 1, WJEnde)
        ' WJEnde = DateAdd("d", -1, DateAdd("yyyy", 1, WJBeginn))
        '
        szWJNeu = "<Bereich nicht ermittelbar>"
        If IsDate([WJEnde]) Then
            dDateTemp = DateAdd("d", 1, [WJEnde])
            szWJNeu = Format(dDateTemp, "dd.mm.yyyy") + " - " + Format(DateAdd("d", -1, DateAdd("yyyy", 1, dDateTemp)), "dd.mm.yyyy")
        End If
        lRetVal = MsgBox(TOOLID + "054" + vbCrLf + vbCrLf + _
            "F|fffd|r die Jahres|fffd|bernahme wird eine neue Erfassungsdatei angelegt, anschlie|fffd|end" + vbCrLf + _
            "werden die Stammdaten und ihre Textvorlagen automatisch |fffd|bernommen." + vbCrLf + vbCrLf + _
            "Als neues Wirtschaftsjahr wird " + szWJNeu + " angenommen." + vbCrLf + vbCrLf + _
            "Sollten Sie ein davon abweichendes Wirtschaftsjahr ben|fffd|tigen, f|fffd|hren Sie" + vbCrLf + _
            "eine Neuanlage durch und importieren Sie anschlie|fffd|end Ihre Textvorlagen manuell." + vbCrLf + vbCrLf + _
            "Soll die Jahres|fffd|bernahme jetzt durchgef|fffd|hrt werden?", _
            vbInformation + vbYesNoCancel, TOOLHDR)
        If lRetVal = vbYes Then
            ' Installiert --> aufrufen
            Set oServer.xlWorkbook = ThisWorkbook
            Call oServer.JahresUebernahme
            Set oServer = Nothing
        End If
    End If
End Sub


'
' 6. Aufruf der Kontextmen|fffd|s |fffd|ber Tastaturshortcuts
'
Public Sub ShowContextMenu()
    Dim Target As Range
    
    Set Target = ActiveCell
    
    ' Shortcuts gibt es nur auf den Datenheets (zur Sicherheit hier nochmal pr|fffd|fen)
    If Target.Parent.Cells(ROW_SH_INFO, COL_SH_DATEN) = "Daten" Then
        Select Case Target.Column
            Case COL_BS_STATUS
                'Call ShowContextMenuStatus(Target)
            Case COL_BS_KOST1, COL_BS_KOST2
                Call ShowContextMenuText(Target, False)
            Case COL_BS_UST
                Call ShowContextMenuUSt(Target)
            Case Else   'COL_BS_TEXT, COL_BS_NAMEORT, COL_BS_WARENART, COL_BS_KONTO, COL_BS_GEGENKTO
                Call ShowContextMenuText(Target, True)
        End Select
    End If
End Sub


'
' 7. Buchen (Dialogbuchen / Splitbuchung)
'
Public Sub BuchenClick(ws As Worksheet, lZeile As Long, Optional bAufteilen As Boolean = False)
    Dim bRetVal As Boolean
    Dim oServer As Object
    
    ActiveCell.Select

    ' Pr|fffd|fen, ob der Server f|fffd|r die Businesslogik vorhanden ist
    On Error Resume Next
    Set oServer = MainServer("KWEBuchen")
    If oServer Is Nothing Then
        ' Nicht installiert --> das ist aber schade
        MsgBox TOOLID + "051" + vbCrLf + vbCrLf + _
            "Die f|fffd|r das Buchen notwendige Komponente ist nicht installiert." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbInformation, TOOLHDR
    Else
        ' Installiert --> aufrufen
        bRetVal = oServer.Buchen(ws, lZeile, bAufteilen)
        Set oServer = Nothing
        ' Erfassungsseite aktualisieren
        If LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" And bRetVal Then
            Call AktualisiereMonat(ws, True)
        End If
    End If
    
End Sub


'
' 8. Schaltfl|fffd|chen der Druckeinstellungen
'
Public Sub ButtonPrintSetupSetupClick()
    Call SetupHeaderFooterAll
End Sub

Public Sub ButtonPrintSetupResetClick()
    Call ResetHeaderFooterAll
End Sub

Public Sub ButtonPrintSetupHilfeClick()
    Call HoleHilfe("HLPID_PRINTSETUP")
End Sub


'
' 9. Schaltfl|fffd|chen f|fffd|r Zaehlprotokoll
'
Public Sub ButtonZaehlprotokollClick()
    Dim objZP As Object
    
    Set objZP = MainServer("KWEBericht")
    If objZP Is Nothing Then
        MsgBox TOOLID + "057" + vbCrLf + vbCrLf + _
            "Die angeforderte Funktion kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "weil eine notwendige Komponente nicht initialisiert werden konnte." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbExclamation, TOOLHDR
    Else
        Set objZP.XlApplication = Application
        Set objZP.xlWorkbook = ThisWorkbook
        Set objZP.xlWorksheet = ActiveSheet
        Call objZP.Zaehlprotokoll(False, Selection)
        Set objZP = Nothing
    End If
End Sub

Public Sub ButtonZaehlprotokollDruckenClick()
    Dim objZP As Object
    
    Set objZP = MainServer("KWEBericht")
    If objZP Is Nothing Then
        MsgBox TOOLID + "058" + vbCrLf + vbCrLf + _
            "Die angeforderte Funktion kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "weil eine notwendige Komponente nicht initialisiert werden konnte." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbExclamation, TOOLHDR
    Else
        Set objZP.XlApplication = Application
        Set objZP.xlWorkbook = ThisWorkbook
        Set objZP.xlWorksheet = ActiveSheet
        Call objZP.Zaehlprotokoll(True, Selection)
        Set objZP = Nothing
    End If
End Sub

Public Sub ButtonZaehlprotokollLoeschenClick()
    Call LoescheZaehlprotokoll(Selection)
End Sub

Public Sub ButtonZaehlprotokollHilfeClick()
    Call HoleHilfe("HLPID_ZAEHLPROTOKOLL")
End Sub


'
' Logging
'
Public Sub DoLog(szLine As String)
    Dim lErrNumber As Long
    Dim szErrDesc As String
    
    lErrNumber = Err.Number
    szErrDesc = Err.Description
    
    If cLog Is Nothing Then
        Set cLog = BasisServer("Logging")
        If cLog Is Nothing Then Exit Sub
        cLog.Module = TOOLFILE + "(" + ThisWorkbook.Name + ")"
        cLog.ThreadID = GetCurrentProcessId
    End If
    If Not cLog Is Nothing Then
        Call cLog.DoLog(szLine)
    Else
        If [ToolDebug] Then Debug.Print szLine
    End If
    
    Err.Number = lErrNumber
    Err.Description = szErrDesc
End Sub

Public Sub DoLogPerm(szLine As String)
    Dim lErrNumber As Long
    Dim szErrDesc As String
    
    lErrNumber = Err.Number
    szErrDesc = Err.Description
    
    If cLog Is Nothing Then
        Set cLog = BasisServer("Logging")
        If cLog Is Nothing Then Exit Sub
        cLog.Module = TOOLFILE + "(" + ThisWorkbook.Name + ")"
        cLog.ThreadID = GetCurrentProcessId
    End If
    If Not cLog Is Nothing Then
        Call cLog.DoLogPerm(szLine)
    Else
        If [ToolDebug] Then Debug.Print szLine
    End If

    Err.Number = lErrNumber
    Err.Description = szErrDesc
End Sub



'
' Hilfe
'
Public Sub HoleHilfe(ContextID As String)
    
    ' Pr|fffd|fen, ob schon ein Server da ist. Wenn nein, dann anlegen...
    If cHelp Is Nothing Then Set cHelp = BasisServer("Help")
    ' Wenn wir einen Server haben, dann Hilfe aus DvKasseWareBasis holen
    If Not cHelp Is Nothing Then
        Call cHelp.HoleHilfe(cHelp.GetID(ContextID))
        ' Niemals die Verbindung hier schlie|fffd|en, da sonst die Hilfe auch Excel b|fffd|se terminiert!!
        ' Set cHelp = Nothing
    Else
        ' Nicht installiert --> Pech
        MsgBox TOOLID + "065" + vbCrLf + vbCrLf + _
            "Eine ben|fffd|tigte Komponente der Anwendung konnte nicht gefunden werden." + vbCrLf + _
            "Es steht daher keine Hilfe zur Verf|fffd|gung." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbInformation, TOOLHDR
    End If
End Sub



'
' Serveraufrufe
'
Public Function MainServer(szKlasse As String) As Object
    Dim o As Object
    
    Set MainServer = Nothing
    If szKlasse = "" Then Exit Function
    On Error Resume Next
    Set o = CreateObject("DvKasseWareMain." + szKlasse)
    If o Is Nothing Then
        If [ToolDebug] Then Debug.Print "MainServer(); Klasse DvKasseWareMain." + szKlasse + "; Err=" + CStr(Err.Number) + "; " + Err.Description
    Else
        Set MainServer = o
        Set o = Nothing
    End If
    On Error GoTo 0
End Function

Public Function BasisServer(szKlasse As String) As Object
    Dim o As Object
    
    Set BasisServer = Nothing
    If szKlasse = "" Then Exit Function
    On Error Resume Next
    Set o = CreateObject("DvKasseWareBasis." + szKlasse)
    If o Is Nothing Then
        If [ToolDebug] Then Debug.Print "BasisServer(); Klasse DvKasseWareBasis." + szKlasse + "; Err=" + CStr(Err.Number) + "; " + Err.Description
    Else
        Set BasisServer = o
        Set o = Nothing
    End If
    On Error GoTo 0
End Function


Attribute VB_Name = "gmodMain"
Option Explicit

' Fehlernummern: N|fffd|chste freie Nummer = 080
' Zus|fffd|tzlich frei: 068, 069, 070


Private Sub SetToolInfo()
    Dim ws As Worksheet
    Dim i As Integer
    Dim bSuccess As Boolean
    
    ' Lfd Nummer und Kopf-/Fu|fffd|zeilen zur|fffd|cksetzen
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name = "Template" Or ws.Name Like "Blatt_##" Then
            If ws.ProtectContents Then ws.Unprotect
            ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value = 0
            ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
        End If
    Next
    ' Kopf-/Fu|fffd|zeilen zur|fffd|cksetzen
    Call ResetHeaderFooterAll
    
    Set ws = ThisWorkbook.Worksheets(TAB_MAIN)
    ws.Activate
    If ws.ProtectContents Then ws.Unprotect
    
    [ToolDatum] = TOOLDATE
    [ToolVersion] = TOOLVERS
    [ToolJahr] = TOOLYEAR
    [ToolStand] = TOOLBUILD
    ThisWorkbook.Worksheets(TAB_MAIN).lblToolInfo.Caption = [ToolInfo]
    [SpaltenOffsetDatum] = COL_AW_DATUM
    
    ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    ws.Range("Hidden").Select
    
    Set ws = Nothing
End Sub

Public Sub UpdateMetadata(ws As Worksheet)
    Dim lRow As Long
    Dim lCol As Long
    Dim lLastRow As Long
    Dim lLastCol As Long
    Dim szFormel As String
    Dim iKtoL|fffd|nge As Long
    
    '
    ' Formeln in die erste Zeile schreiben und direkt in die Spalte kopieren
    '
    lRow = ROW_BS_START
    lLastRow = GetLastUsedRow(ws)


    ' Blockbildung Kasse:
    ' 1. COL_AW_SOLLHABEN - COL_AW_CHECKZEROLEN
    ' 2. COL_AW_KOSTNUMERIC_1 - COL_AW_TEXTLEN

    ' Blockbildung Ware:
    ' ...

' -- Start Block 1
    ' 27: COL_AW_SOLLHABEN: Soll oder Haben muss gef|fffd|llt sein
    ws.Cells(lRow, COL_AW_SOLLHABEN).FormulaR1C1 = "=COUNT(RC[-" & COL_AW_SOLLHABEN - COL_BS_SOLL & "],RC[-" & COL_AW_SOLLHABEN - COL_BS_HABEN & "])"
    
    ' 28: COL_AW_CHECKDATE: Pr|fffd|fen, ob Datum im g|fffd|ltigen Bereich liegt
    ws.Cells(lRow, COL_AW_CHECKDATE).Formula = "=IF(OR(DATEVALUE(" & sz2a1(COL_BS_DATUM, lRow) & " & " & sz2a1(COL_DAT_JAHR, ROW_DAT_MONATJAHR, True) & ") < IF(VormonatZulassen," & sz2a1(COL_DAT_PREVIOUS, ROW_DAT_START, True) & "," & sz2a1(COL_DAT_CURRENT, ROW_DAT_START, True) & "), DATEVALUE(" & sz2a1(COL_BS_DATUM, lRow) & " & " & sz2a1(COL_DAT_JAHR, ROW_DAT_MONATJAHR, True) & ") > " & sz2a1(COL_DAT_CURRENT, ROW_DAT_END, True) & "),FALSE,TRUE)"
    
    ' 29, 30: COL_AW_DATECHANGE: Tagwechsel (nur bei Kasse)
    If TOOLKASSE Then
        ' Auf Tageswechsel pr|fffd|fen
        ws.Cells(lRow, COL_AW_DATECHANGE).FormulaR1C1 = "=IF(RC[-" & COL_AW_DATECHANGE - COL_BS_DATUM & "]<>R[1]C[-" & COL_AW_DATECHANGE - COL_BS_DATUM & "],TRUE,FALSE)"
        ' Tagessaldo zur|fffd|cksetzen
        ws.Cells(lRow, COL_BS_BESTAND) = ""
        ' Tagessaldo f|fffd|hren. Nur relevant, wenn nach Datum sortiert
        ws.Cells(lRow, COL_AW_SALDO).FormulaR1C1 = "=ROUND(R[-1]C+IF(ISNUMBER(RC[-" & COL_AW_SALDO - COL_BS_SOLL & "]),RC[-" & COL_AW_SALDO - COL_BS_SOLL & "],0)-IF(ISNUMBER(RC[-" & COL_AW_SALDO - COL_BS_HABEN & "]),RC[-" & COL_AW_SALDO - COL_BS_HABEN & "],0),2)"
    End If
    
    ' 31: COL_AW_USEDCELLS: Anzahl gef|fffd|llter Felder?
    szFormel = "=LEN("
    ' Die evtl vorhandene Bestandsspalte wird (sicherheitshalber) ausgenommen
    For lCol = COL_BS_STATUS + 1 To COL_BS_ENDE
        If lCol <> COL_BS_BESTAND Then
            szFormel = szFormel + "TRIM(RC[-" & COL_AW_USEDCELLS - lCol & "]) &"
        End If
    Next lCol
    ' Formelende
    szFormel = Left(szFormel, Len(szFormel) - 1) + ")"
    ' Zuweisung
    ws.Cells(lRow, COL_AW_USEDCELLS).FormulaR1C1 = szFormel
    
    ' 32: COL_AW_DATUM: "Echtes" Datum f|fffd|r Export
    ws.Cells(lRow, COL_AW_DATUM).Formula = "=DATEVALUE(" & sz2a1(COL_BS_DATUM, lRow) & " & " & sz2a1(COL_DAT_JAHR, ROW_DAT_MONATJAHR, True) & ")"
    
    ' 33: COL_AW_CHECKSKONTO: Skonto kleiner als Einnahmen und Ausgaben?
    ws.Cells(lRow, COL_AW_CHECKSKONTO).FormulaR1C1 = "=IF(ROUND(ABS(IF(ISNUMBER(RC[-" & COL_AW_CHECKSKONTO - COL_BS_SOLL & "]),RC[-" & COL_AW_CHECKSKONTO - COL_BS_SOLL & "],0) - IF(ISNUMBER(RC[-" & COL_AW_CHECKSKONTO - COL_BS_HABEN & "]),RC[-" & COL_AW_CHECKSKONTO - COL_BS_HABEN & "],0)),2)>=IF(ISNUMBER(RC[-" & COL_AW_CHECKSKONTO - COL_BS_SKONTO & "]),RC[-" & COL_AW_CHECKSKONTO - COL_BS_SKONTO & "],0),FALSE,TRUE)"
    
    ' 34: COL_AW_CHECKBU: BU-Feld nur mit Gegenkonto
    If [BUErzwingtGegenkonto] Then
        ws.Cells(lRow, COL_AW_CHECKBU).FormulaR1C1 = "=IF(AND(COUNTA(RC[-" & COL_AW_CHECKBU - COL_BS_B & "]:RC[-" & COL_AW_CHECKBU - COL_BS_U & "])>0,RC[-" & COL_AW_CHECKBU - COL_BS_GEGENKTO & "]=""""),FALSE,TRUE)"
    Else
        ws.Cells(lRow, COL_AW_CHECKBU) = True
    End If
    
    ' 35: COL_AW_CHECKKTOLEN_G: Pr|fffd|fung L|fffd|nge Gegenkonto
    iKtoL|fffd|nge = IIf([KtoL|fffd|nge] > 0, [KtoL|fffd|nge], 8)
    If [BUmitGegenkonto] Then
        iKtoL|fffd|nge = iKtoL|fffd|nge + 3
    Else
        iKtoL|fffd|nge = iKtoL|fffd|nge + 1
    End If
    ws.Cells(lRow, COL_AW_CHECKKTOLEN_G).FormulaR1C1 = "=IF(OR(KtoL|fffd|nge=0,RC[-" & COL_AW_CHECKKTOLEN_G - COL_BS_GEGENKTO & "]=0),TRUE,IF(LEN(RC[-" & COL_AW_CHECKKTOLEN_G - COL_BS_GEGENKTO & "])>" & iKtoL|fffd|nge & ",FALSE,TRUE))"
    
    ' 36: COL_AW_CHECKZEROLEN: Soll+Haben<>0?
    If TOOLKASSE Then
        ' Betrag (abs(soll-haben) = 0) ?
        ws.Cells(lRow, COL_AW_CHECKZEROLEN).FormulaR1C1 = "=IF(ROUND(ABS(IF(ISNUMBER(RC[-" & COL_AW_CHECKZEROLEN - COL_BS_SOLL & "]),RC[-" & COL_AW_CHECKZEROLEN - COL_BS_SOLL & "],0) - IF(ISNUMBER(RC[-" & COL_AW_CHECKZEROLEN - COL_BS_HABEN & "]),RC[-" & COL_AW_CHECKZEROLEN - COL_BS_HABEN & "],0)),2)=0,TRUE,FALSE)"
    Else
        ' Pr|fffd|fung L|fffd|nge Konto
        ws.Cells(lRow, COL_AW_CHECKKTOLEN_K).FormulaR1C1 = "=IF(OR(KtoL|fffd|nge=0,RC[-" & COL_AW_CHECKKTOLEN_K - COL_BS_KONTO & "]=0),TRUE,IF(LEN(RC[-" & COL_AW_CHECKKTOLEN_K - COL_BS_KONTO & "])>" & iKtoL|fffd|nge & ",FALSE,TRUE))"
        ' Zusatzinfo Nachricht f|fffd|r Export, Variante 1 = Name + Bezahlt
        ws.Cells(lRow, COL_AW_ZUSATZ1).FormulaR1C1 = "=RC[-" & COL_AW_ZUSATZ1 - COL_BS_NAMEORT & "] & IF(AND(RC[-" & COL_AW_ZUSATZ1 - COL_BS_NAMEORT & "]<>"""",RC[-" & COL_AW_ZUSATZ1 - COL_BS_BEZAHLT & "]<>""""),"", "","""") & RC[-" & COL_AW_ZUSATZ1 - COL_BS_BEZAHLT & "]"
        ' Zusatzinfo Nachricht f|fffd|r Export, Variante 2 = Warenart + Bezahlt
        ws.Cells(lRow, COL_AW_ZUSATZ2).FormulaR1C1 = "=RC[-" & COL_AW_ZUSATZ2 - COL_BS_WARENART & "] & IF(AND(RC[-" & COL_AW_ZUSATZ2 - COL_BS_WARENART & "]<>"""",RC[-" & COL_AW_ZUSATZ2 - COL_BS_BEZAHLT & "]<>""""),"", "","""") & RC[-" & COL_AW_ZUSATZ2 - COL_BS_BEZAHLT & "]"
        ' Rechnungsart festlegen
        ws.Cells(lRow, COL_AW_RECHNART).FormulaR1C1 = "=IF(RC[-" & COL_AW_RECHNART - COL_BS_SOLL & "]<>"""",""R"",""G"") & IF(WarenEingang,""E"",""A"")"
    End If

    ' Block 1 kopieren
    lLastCol = IIf(TOOLKASSE, COL_AW_CHECKZEROLEN, COL_AW_RECHNART)
    ws.Range(ws.Cells(ROW_BS_START, COL_AW_SOLLHABEN), ws.Cells(ROW_BS_START, lLastCol)).Copy
    ws.Range(ws.Cells(ROW_BS_START, COL_AW_SOLLHABEN), ws.Cells(lLastRow, lLastCol)).PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
' -- Ende Block 1
    
    
' -- Start Block 2
    ' 45, 46: COL_AW_KOSTNUMERIC: Kost nur numerisch
    If [NumericKostOnly] Then
        ws.Cells(lRow, COL_AW_KOSTNUMERIC_1).FormulaR1C1 = "=IF(RC[-" & COL_AW_KOSTNUMERIC_1 - COL_BS_KOST1 & "]="""",TRUE,IF(ISERROR(VALUE(RC[-" & COL_AW_KOSTNUMERIC_1 - COL_BS_KOST1 & "])),FALSE,TRUE))"
        ws.Cells(lRow, COL_AW_KOSTNUMERIC_2).FormulaR1C1 = "=IF(RC[-" & COL_AW_KOSTNUMERIC_2 - COL_BS_KOST2 & "]="""",TRUE,IF(ISERROR(VALUE(RC[-" & COL_AW_KOSTNUMERIC_2 - COL_BS_KOST2 & "])),FALSE,TRUE))"
    End If
    
    ' 47: COL_AW_TEXTLEN: Erweiterte L|fffd|ngen bei bestimmten Textfeldern
    If TOOLKASSE Then
        ws.Cells(lRow, COL_AW_TEXTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_TEXTLEN - COL_BS_TEXT & "]) > " + CStr([StandardTextLen])
    Else
        ws.Cells(lRow, COL_AW_NAMEORTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_NAMEORTLEN - COL_BS_NAMEORT & "]) > " + CStr([StandardTextLen])
        ws.Cells(lRow, COL_AW_WARENARTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_WARENARTLEN - COL_BS_WARENART & "]) > " + CStr([StandardTextLen])
        ws.Cells(lRow, COL_AW_BEZAHLTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_BEZAHLTLEN - COL_BS_BEZAHLT & "]) > " + CStr([StandardTextLen])
    End If
    
    ' 48: COL_AW_STATUSTEXT: Formel f|fffd|r Statusspalte
    If [ShowDateOnStatus] Then
        ws.Cells(lRow, COL_AW_STATUSTEXT).FormulaR1C1 = _
            "=IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_EXPORTED & "]<>"""",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=2,""|fffd|bersprungen"",""Exportiert"") & """ & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_EXPORTED & "],""TT.MM.JJJJ""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=1,""Exportfehler"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHECKED & "]<>"""",""Gepr|fffd|ft" & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHECKED & "],""TT.MM.JJJJ""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_TOCHECK & "]=1,""Zu pr|fffd|fen"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHANGED & "]<>"""",""Ge|fffd|ndert" & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHANGED & "],""TT.MM.JJJJ""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CREATED & "]<>"""",""Angelegt" & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CREATED & "],""TT.MM.JJJJ""),""""))))))"
    Else
        ws.Cells(lRow, COL_AW_STATUSTEXT).FormulaR1C1 = _
            "=IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_EXPORTED & "]<>"""",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=2,""|fffd|bersprungen"",""Exportiert""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=1,""Exportfehler"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHECKED & "]<>"""",""Gepr|fffd|ft"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_TOCHECK & "]=1,""Zu pr|fffd|fen"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHANGED & "]<>"""",""Ge|fffd|ndert"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CREATED & "]<>"""",""Angelegt"",""""))))))"
    End If
    ' 49: COL_AW_STATUSCOLOR: Colorindex f|fffd|r die Statuszelle
    ws.Cells(lRow, COL_AW_STATUSCOLOR).FormulaR1C1 = _
        "=IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_EXPORTED & "]<>"""",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_EXPORTSTATUS & "]=2," + CStr(COLOR_SKIPPED) + "," + CStr(COLOR_EXPORTED) + "),IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_EXPORTSTATUS & "]=1," + CStr(COLOR_ERROR) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_CHECKED & "]<>""""," + CStr(COLOR_CHECKED) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_TOCHECK & "]=1," + CStr(COLOR_TOCHECK) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_CHANGED & "]<>""""," + CStr(COLOR_CHANGED) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_CREATED & "]<>""""," + CStr(COLOR_CREATED) + "," + CStr(COLOR_LOCKED) + "))))))"

    ' Block 2 kopieren
    ws.Range(ws.Cells(ROW_BS_START, COL_AW_KOSTNUMERIC_1), ws.Cells(ROW_BS_START, COL_AW_LASTCOL)).Copy
    ws.Range(ws.Cells(ROW_BS_START, COL_AW_KOSTNUMERIC_1), ws.Cells(lLastRow, COL_AW_LASTCOL)).PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
' -- Ende Block 2


End Sub

Sub VorverarbeitungZeile(ws As Worksheet, lRow As Long, Optional bDoCalculate As Boolean = True)
    Dim bScreenUpdate As Boolean
    Dim bEnableEvents As Boolean
    Dim bProtected As Boolean
    Dim iKtoL|fffd|nge As Integer
    Dim lCol As Long
    Dim szFormel As String
    
    ' Validiere Zeilennummer
    If lRow < ROW_BS_START Then Exit Sub
    
    ' Erste |fffd|berpr|fffd|fung auf leeres Sheet
    If ws.UsedRange.Rows.Count < ROW_BS_START Then Exit Sub

    ' ScreenUpdating ausschalten
    bScreenUpdate = Application.ScreenUpdating
    If bScreenUpdate Then Application.ScreenUpdating = False
    
    ' Eventverarbeitung ausschalten
    bEnableEvents = Application.EnableEvents
    If bEnableEvents Then Application.EnableEvents = False
    
    ' Blattschutz aufheben
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect

    ' Eingabekontrolle deaktivieren
    ' XXX nicht n|fffd|tig, wenn EnableEvents = False ??
    gbEingabeKontrolle = False
    
    ' Laufende Nummer zur|fffd|cksetzen
    If Not [SpalteLfdNrReal] Then ws.Cells(lRow, COL_BS_LFDNR).Value = ""
    ' Anzahl gef|fffd|llter Felder?
    ' alt: |fffd|ber Anzahl2 --> Leerzeichen werden mitgez|fffd|hlt!
    ' ws.Cells(lRow, COL_AW_USEDCELLS).FormulaR1C1 = "=COUNTA(RC[-" & COL_AW_USEDCELLS - COL_BS_SOLL & "],RC[-" & COL_AW_USEDCELLS - COL_BS_HABEN & "],RC[-" & COL_AW_USEDCELLS - COL_BS_B & "]:RC[-" & COL_AW_USEDCELLS - COL_BS_ENDE & "])"
    ' neu: Die Zellen einzeln Trimmen und dann Konkatenieren --> Auswertung der L|fffd|nge
    '
    ' Formelstart
    szFormel = "=LEN("
    ' Die evtl vorhandene Bestandsspalte wird (sicherheitshalber) ausgenommen
    For lCol = COL_BS_STATUS + 1 To COL_BS_ENDE
        If lCol <> COL_BS_BESTAND Then
            szFormel = szFormel + "TRIM(RC[-" & COL_AW_USEDCELLS - lCol & "]) &"
        End If
    Next lCol
    ' Formelende
    szFormel = Left(szFormel, Len(szFormel) - 1) + ")"
    ' Zuweisung
    ws.Cells(lRow, COL_AW_USEDCELLS).FormulaR1C1 = szFormel
    ' Pr|fffd|fung
    If Val(ws.Cells(lRow, COL_AW_USEDCELLS)) = 0 Then
        'MsgBox "Uups"
        ws.Range(ws.Cells(lRow, COL_BS_START), ws.Cells(lRow, COL_BS_ENDE)).ClearContents
        ws.Range(ws.Cells(lRow, COL_OFFSET), ws.Cells(lRow, COL_OFFSET + COL_ANZAUSWERT)).ClearContents
        GoTo EXIT_VorverarbeitungZeile
    End If
    ' Soll oder Haben muss gef|fffd|llt sein
    ws.Cells(lRow, COL_AW_SOLLHABEN).FormulaR1C1 = "=COUNT(RC[-" & COL_AW_SOLLHABEN - COL_BS_SOLL & "],RC[-" & COL_AW_SOLLHABEN - COL_BS_HABEN & "])"
    ' Pr|fffd|fen, ob Datum im g|fffd|ltigen Bereich liegt
    ws.Cells(lRow, COL_AW_CHECKDATE).Formula = "=IF(OR(DATEVALUE(" & sz2a1(COL_BS_DATUM, lRow) & " & " & sz2a1(COL_DAT_JAHR, ROW_DAT_MONATJAHR) & ") < IF(VormonatZulassen," & sz2a1(COL_DAT_PREVIOUS, ROW_DAT_START) & "," & sz2a1(COL_DAT_CURRENT, ROW_DAT_START) & "), DATEVALUE(" & sz2a1(COL_BS_DATUM, lRow) & " & " & sz2a1(COL_DAT_JAHR, ROW_DAT_MONATJAHR) & ") > " & sz2a1(COL_DAT_CURRENT, ROW_DAT_END) & "),FALSE,TRUE)"
    If TOOLKASSE Then
        ' Auf Tageswechsel pr|fffd|fen
        ws.Cells(lRow, COL_AW_DATECHANGE).FormulaR1C1 = "=IF(RC[-" & COL_AW_DATECHANGE - COL_BS_DATUM & "]<>R[1]C[-" & COL_AW_DATECHANGE - COL_BS_DATUM & "],TRUE,FALSE)"
        ' Tagessaldo zur|fffd|cksetzen
        ws.Cells(lRow, COL_BS_BESTAND) = ""
        ' Tagessaldo f|fffd|hren. Nur relevant, wenn nach Datum sortiert
        ws.Cells(lRow, COL_AW_SALDO).FormulaR1C1 = "=ROUND(R[-1]C+IF(ISNUMBER(RC[-" & COL_AW_SALDO - COL_BS_SOLL & "]),RC[-" & COL_AW_SALDO - COL_BS_SOLL & "],0)-IF(ISNUMBER(RC[-" & COL_AW_SALDO - COL_BS_HABEN & "]),RC[-" & COL_AW_SALDO - COL_BS_HABEN & "],0),2)"
    End If
    ' "Echtes" Datum f|fffd|r Export
    ws.Cells(lRow, COL_AW_DATUM).Formula = "=DATEVALUE(" & sz2a1(COL_BS_DATUM, lRow) & " & " & sz2a1(COL_DAT_JAHR, ROW_DAT_MONATJAHR) & ")"
    ' Skonto kleiner als Einnahmen und Ausgaben?
    ws.Cells(lRow, COL_AW_CHECKSKONTO).FormulaR1C1 = "=IF(ROUND(ABS(IF(ISNUMBER(RC[-" & COL_AW_CHECKSKONTO - COL_BS_SOLL & "]),RC[-" & COL_AW_CHECKSKONTO - COL_BS_SOLL & "],0) - IF(ISNUMBER(RC[-" & COL_AW_CHECKSKONTO - COL_BS_HABEN & "]),RC[-" & COL_AW_CHECKSKONTO - COL_BS_HABEN & "],0)),2)>=IF(ISNUMBER(RC[-" & COL_AW_CHECKSKONTO - COL_BS_SKONTO & "]),RC[-" & COL_AW_CHECKSKONTO - COL_BS_SKONTO & "],0),FALSE,TRUE)"
    ' BU-Feld nur mit Gegenkonto
    If [BUErzwingtGegenkonto] Then
        ws.Cells(lRow, COL_AW_CHECKBU).FormulaR1C1 = "=IF(AND(COUNTA(RC[-" & COL_AW_CHECKBU - COL_BS_B & "]:RC[-" & COL_AW_CHECKBU - COL_BS_U & "])>0,RC[-" & COL_AW_CHECKBU - COL_BS_GEGENKTO & "]=""""),FALSE,TRUE)"
    Else
        ws.Cells(lRow, COL_AW_CHECKBU) = True
    End If
    ' Pr|fffd|fung L|fffd|nge Gegenkonto
    iKtoL|fffd|nge = IIf([KtoL|fffd|nge] > 0, [KtoL|fffd|nge], 8)
    If [BUmitGegenkonto] Then
        iKtoL|fffd|nge = iKtoL|fffd|nge + 3
    Else
        iKtoL|fffd|nge = iKtoL|fffd|nge + 1
    End If
    ws.Cells(lRow, COL_AW_CHECKKTOLEN_G).FormulaR1C1 = "=IF(OR(KtoL|fffd|nge=0,RC[-" & COL_AW_CHECKKTOLEN_G - COL_BS_GEGENKTO & "]=0),TRUE,IF(LEN(RC[-" & COL_AW_CHECKKTOLEN_G - COL_BS_GEGENKTO & "])>" & iKtoL|fffd|nge & ",FALSE,TRUE))"
    If TOOLKASSE Then
        ' Betrag (abs(soll-haben) = 0) ?
        ws.Cells(lRow, COL_AW_CHECKZEROLEN).FormulaR1C1 = "=IF(ROUND(ABS(IF(ISNUMBER(RC[-" & COL_AW_CHECKZEROLEN - COL_BS_SOLL & "]),RC[-" & COL_AW_CHECKZEROLEN - COL_BS_SOLL & "],0) - IF(ISNUMBER(RC[-" & COL_AW_CHECKZEROLEN - COL_BS_HABEN & "]),RC[-" & COL_AW_CHECKZEROLEN - COL_BS_HABEN & "],0)),2)=0,TRUE,FALSE)"
    Else
        ' Pr|fffd|fung L|fffd|nge Konto
        ws.Cells(lRow, COL_AW_CHECKKTOLEN_K).FormulaR1C1 = "=IF(OR(KtoL|fffd|nge=0,RC[-" & COL_AW_CHECKKTOLEN_K - COL_BS_KONTO & "]=0),TRUE,IF(LEN(RC[-" & COL_AW_CHECKKTOLEN_K - COL_BS_KONTO & "])>" & iKtoL|fffd|nge & ",FALSE,TRUE))"
        ' Zusatzinfo Nachricht f|fffd|r Export, Variante 1 = Name + Bezahlt
        ws.Cells(lRow, COL_AW_ZUSATZ1).FormulaR1C1 = "=RC[-" & COL_AW_ZUSATZ1 - COL_BS_NAMEORT & "] & IF(AND(RC[-" & COL_AW_ZUSATZ1 - COL_BS_NAMEORT & "]<>"""",RC[-" & COL_AW_ZUSATZ1 - COL_BS_BEZAHLT & "]<>""""),"", "","""") & RC[-" & COL_AW_ZUSATZ1 - COL_BS_BEZAHLT & "]"
        ' Zusatzinfo Nachricht f|fffd|r Export, Variante 2 = Warenart + Bezahlt
        ws.Cells(lRow, COL_AW_ZUSATZ2).FormulaR1C1 = "=RC[-" & COL_AW_ZUSATZ2 - COL_BS_WARENART & "] & IF(AND(RC[-" & COL_AW_ZUSATZ2 - COL_BS_WARENART & "]<>"""",RC[-" & COL_AW_ZUSATZ2 - COL_BS_BEZAHLT & "]<>""""),"", "","""") & RC[-" & COL_AW_ZUSATZ2 - COL_BS_BEZAHLT & "]"
        ' Rechnungsart festlegen
        ws.Cells(lRow, COL_AW_RECHNART).FormulaR1C1 = "=IF(RC[-" & COL_AW_RECHNART - COL_BS_SOLL & "]<>"""",""R"",""G"") & IF(WarenEingang,""E"",""A"")"
    End If
    ' Neue Pr|fffd|fungen ab Version 2.2
    ' Kost nur numerisch
    If [NumericKostOnly] Then
         ws.Cells(lRow, COL_AW_KOSTNUMERIC_1).FormulaR1C1 = "=IF(RC[-" & COL_AW_KOSTNUMERIC_1 - COL_BS_KOST1 & "]="""",TRUE,IF(ISERROR(VALUE(RC[-" & COL_AW_KOSTNUMERIC_1 - COL_BS_KOST1 & "])),FALSE,TRUE))"
         ws.Cells(lRow, COL_AW_KOSTNUMERIC_2).FormulaR1C1 = "=IF(RC[-" & COL_AW_KOSTNUMERIC_2 - COL_BS_KOST2 & "]="""",TRUE,IF(ISERROR(VALUE(RC[-" & COL_AW_KOSTNUMERIC_2 - COL_BS_KOST2 & "])),FALSE,TRUE))"
    End If
    ' Erweiterte L|fffd|ngen bei bestimmten Textfeldern
    If TOOLKASSE Then
        ws.Cells(lRow, COL_AW_TEXTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_TEXTLEN - COL_BS_TEXT & "]) > " + CStr([StandardTextLen])
    Else
        ws.Cells(lRow, COL_AW_NAMEORTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_NAMEORTLEN - COL_BS_NAMEORT & "]) > " + CStr([StandardTextLen])
        ws.Cells(lRow, COL_AW_WARENARTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_WARENARTLEN - COL_BS_WARENART & "]) > " + CStr([StandardTextLen])
        ws.Cells(lRow, COL_AW_BEZAHLTLEN).FormulaR1C1 = "=LEN(RC[-" & COL_AW_BEZAHLTLEN - COL_BS_BEZAHLT & "]) > " + CStr([StandardTextLen])
    End If
    
    ' Neue Pr|fffd|fungen ab Version 2.4
    ' Formel f|fffd|r Statusspalte
    If [ShowDateOnStatus] Then
        ws.Cells(lRow, COL_AW_STATUSTEXT).FormulaR1C1 = _
            "=IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_EXPORTED & "]<>"""",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=2,""|fffd|bersprungen"",""Exportiert"") & """ & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_EXPORTED & "],""TT.MM.JJJJ""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=1,""Exportfehler"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHECKED & "]<>"""",""Gepr|fffd|ft" & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHECKED & "],""TT.MM.JJJJ""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_TOCHECK & "]=1,""Zu pr|fffd|fen"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHANGED & "]<>"""",""Ge|fffd|ndert" & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHANGED & "],""TT.MM.JJJJ""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CREATED & "]<>"""",""Angelegt" & Chr(10) & "am "" & TEXT(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CREATED & "],""TT.MM.JJJJ""),""""))))))"
    Else
        ws.Cells(lRow, COL_AW_STATUSTEXT).FormulaR1C1 = _
            "=IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_EXPORTED & "]<>"""",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=2,""|fffd|bersprungen"",""Exportiert""),IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_EXPORTSTATUS & "]=1,""Exportfehler"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHECKED & "]<>"""",""Gepr|fffd|ft"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_TOCHECK & "]=1,""Zu pr|fffd|fen"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CHANGED & "]<>"""",""Ge|fffd|ndert"",IF(RC[-" & COL_AW_STATUSTEXT - COL_AW_DAT_CREATED & "]<>"""",""Angelegt"",""""))))))"
    End If
    ' Farbindex f|fffd|r die Statuszelle
    ws.Cells(lRow, COL_AW_STATUSCOLOR).FormulaR1C1 = _
        "=IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_EXPORTED & "]<>"""",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_EXPORTSTATUS & "]=2," + CStr(COLOR_SKIPPED) + "," + CStr(COLOR_EXPORTED) + "),IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_EXPORTSTATUS & "]=1," + CStr(COLOR_ERROR) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_CHECKED & "]<>""""," + CStr(COLOR_CHECKED) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_TOCHECK & "]=1," + CStr(COLOR_TOCHECK) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_CHANGED & "]<>""""," + CStr(COLOR_CHANGED) + ",IF(RC[-" & COL_AW_STATUSCOLOR - COL_AW_DAT_CREATED & "]<>""""," + CStr(COLOR_CREATED) + "," + CStr(COLOR_LOCKED) + "))))))"
    
    
EXIT_VorverarbeitungZeile:

    ' Events wieder einschalten
    If bEnableEvents Then Application.EnableEvents = bEnableEvents
    
    ' Formeln berechnen
    If bDoCalculate Then ws.Calculate
    
    ' Zellfarben zur|fffd|cksetzen
    For lCol = COL_BS_START To COL_BS_ENDE
        If lCol <> COL_BS_STATUS Then
            If ws.Cells(lRow, lCol).Interior.ColorIndex <> COLOR_LOCKED Then
                ws.Cells(lRow, lCol).Interior.ColorIndex = COLOR_STANDARD
            End If
        End If
    Next lCol
    ' und nun die Ausnahmen...
    ws.Cells(lRow, COL_BS_LFDNR).Interior.ColorIndex = COLOR_LOCKED
    If TOOLKASSE Then
        ws.Cells(lRow, COL_BS_BESTAND).Interior.ColorIndex = COLOR_LOCKED
    End If
    If Not ThisWorkbook.Worksheets(TAB_DATEN).Range("OptSpalteGegenkonto") Then
        ws.Cells(lRow, COL_BS_B).Interior.ColorIndex = COLOR_LOCKED
        ws.Cells(lRow, COL_BS_U).Interior.ColorIndex = COLOR_LOCKED
        ws.Cells(lRow, COL_BS_GEGENKTO).Interior.ColorIndex = COLOR_LOCKED
    End If
    If Not ThisWorkbook.Worksheets(TAB_DATEN).Range("OptSpalteSkonto") Then
        ws.Cells(lRow, COL_BS_SKONTO).Interior.ColorIndex = COLOR_LOCKED
    End If
    If Not ThisWorkbook.Worksheets(TAB_DATEN).Range("OptSpalteUSt") Then
        ws.Cells(lRow, COL_BS_UST).Interior.ColorIndex = COLOR_LOCKED
    End If
        
    DoEvents
    
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    ws.EnableSelection = xlUnlockedCells
    If bScreenUpdate Then Application.ScreenUpdating = bScreenUpdate
    
    ' Eingabekontrolle aktivieren
    gbEingabeKontrolle = True
End Sub

Function Pr|fffd|feZeile(ws As Worksheet, lRow As Long, szMsg As String) As Boolean
    Dim lCol As Long
    Dim bEnableEvents As Boolean
    Dim lRowHeight As Long
    
    Pr|fffd|feZeile = True
    On Error GoTo ERR_PruefeZeile_LFZ_9
    
    ' Alle Fehlerkennzeichen zur|fffd|cksetzen
    For lCol = COL_BS_START To COL_BS_ENDE
        If ws.Cells(lRow, lCol).Interior.ColorIndex = COLOR_ERROR Then
            ws.Cells(lRow, lCol).Interior.ColorIndex = COLOR_STANDARD
        End If
    Next
    
    ' Pseudoleerzeilen stehen immer am Ende --> Ende des Loops
    If ws.Cells(lRow, COL_AW_USEDCELLS).Value = 0 Then Exit Function
    
    ' Referenz f|fffd|r Status setzen
    ws.Cells(lRow, COL_BS_STATUS).NumberFormat = "General"
    ws.Cells(lRow, COL_BS_STATUS).FormulaR1C1 = "=RC[" + CStr(COL_AW_STATUSTEXT - COL_BS_STATUS) + "]"
    
    ' Pr|fffd|fen, ob |fffd|berhaupt ein Datum eingegeben wurde
    If IsError(ws.Cells(lRow, COL_AW_CHECKDATE)) Then
        ws.Cells(lRow, COL_BS_DATUM).Interior.ColorIndex = COLOR_ERROR
        Pr|fffd|feZeile = False
        szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Unzul|fffd|ssiges oder fehlendes Datum (" & ws.Cells(lRow, COL_BS_DATUM) & ")" & vbCrLf
        
    Else
        
        ' Einhaltung des Datumbereichs pr|fffd|fen
        If [DatumPr|fffd|fen] Then
            ' Ok, es muss gepr|fffd|ft werden
            If Not ws.Cells(lRow, COL_AW_CHECKDATE) Then
                ws.Cells(lRow, COL_BS_DATUM).Interior.ColorIndex = COLOR_ERROR
                Pr|fffd|feZeile = False
                szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Datum (" & _
                    ws.Cells(lRow, COL_BS_DATUM) & ") ausserhalb des g|fffd|ltigen Bereichs (" & _
                    IIf([VormonatZulassen] = True, ws.Cells(ROW_DAT_START, COL_DAT_PREVIOUS), ws.Cells(ROW_DAT_START, COL_DAT_CURRENT)) & " - " & _
                    ws.Cells(ROW_DAT_END, COL_DAT_CURRENT) & ")" & vbCrLf
            End If
        End If
    
    End If
    
    ' Einnahmen/Ausgaben nicht leer?
    If ws.Cells(lRow, COL_AW_SOLLHABEN).Value <> 1 Then
        ws.Cells(lRow, COL_BS_SOLL).Interior.ColorIndex = COLOR_ERROR
        ws.Cells(lRow, COL_BS_HABEN).Interior.ColorIndex = COLOR_ERROR
        If TOOLKASSE Then
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Genau eines der Felder ""Einnahmen"" oder ""Ausgaben"" muss gef|fffd|llt sein" & vbCrLf
        Else
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Genau eines der Felder ""Rechnungsbetrag"" oder ""Gutschriften"" mu|fffd| gef|fffd|llt sein" & vbCrLf
        End If
        Pr|fffd|feZeile = False
    Else
        ' Skontobetrag glaubw|fffd|rdig?
        If ws.Cells(lRow, COL_AW_CHECKSKONTO) Then
            ' Da passt was nicht...
            If [AllowZeroValues] = True Then
                ' Sonderfall, wenn Betr|fffd|ge mit 0 zul|fffd|ssig sind
                If Len(Trim(ws.Cells(lRow, COL_BS_SKONTO).Value)) > 0 Then
                    ws.Cells(lRow, COL_BS_SKONTO).Interior.ColorIndex = COLOR_ERROR
                    If TOOLKASSE Then
                        szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Der Skontobetrag darf nicht gr|fffd||fffd|er oder gleich der Einnahme bzw. Ausgabe sein" & vbCrLf
                    Else
                        szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Der Skontobetrag darf nicht gr|fffd||fffd|er als Rechnungsbetrag bzw. Gutschriften sein" & vbCrLf
                    End If
                    Pr|fffd|feZeile = False
                End If
            Else
                ws.Cells(lRow, COL_BS_SKONTO).Interior.ColorIndex = COLOR_ERROR
                If TOOLKASSE Then
                    szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Der Skontobetrag darf nicht gr|fffd||fffd|er oder gleich der Einnahme bzw. Ausgabe sein" & vbCrLf
                Else
                    szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Der Skontobetrag darf nicht gr|fffd||fffd|er als Rechnungsbetrag bzw. Gutschriften sein" & vbCrLf
                End If
                Pr|fffd|feZeile = False
            End If
        End If
    End If
    
    ' Spalten B/U/Gegenkonto vorhanden?
    If [OptSpalteGegenkonto] Then
        ' BU-Feld nur mit Gegenkonto?
        If Not ws.Cells(lRow, COL_AW_CHECKBU) Then
            ws.Cells(lRow, COL_BS_B).Interior.ColorIndex = COLOR_ERROR
            ws.Cells(lRow, COL_BS_U).Interior.ColorIndex = COLOR_ERROR
            ws.Cells(lRow, COL_BS_GEGENKTO).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Eine Belegung der BU-Felder ist nur zus. mit einem Gegenkonto erlaubt" & vbCrLf
            Pr|fffd|feZeile = False
        End If
        ' L|fffd|nge des Gegenkontos pr|fffd|fen
        If Not ws.Cells(lRow, COL_AW_CHECKKTOLEN_G) Then
            ws.Cells(lRow, COL_BS_GEGENKTO).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Die L|fffd|nge des Gegenkontos (Ist: " & Len(Trim(ws.Cells(lRow, COL_BS_GEGENKTO))) & ") ist zu gro|fffd| (Max: " & [KtoL|fffd|nge] + 1 & ")" & vbCrLf
            Pr|fffd|feZeile = False
        End If
        ' Muss das Gegenkonto vorhanden sein?
        If [NeedsSpalteGegenKto] Then
            If Len(Trim(ws.Cells(lRow, COL_BS_GEGENKTO).Value)) = 0 Then
                ws.Cells(lRow, COL_BS_GEGENKTO).Interior.ColorIndex = COLOR_ERROR
                szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Eine Eingabe in das Feld Gegenkonto ist notwendig. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
                Pr|fffd|feZeile = False
            End If
        End If
    End If
    
    ' Kontospalte pr|fffd|fen?
    If [NeedsSpalteKonto] Then
        ' Spalte Konto gef|fffd|llt?
        If Len(Trim(ws.Cells(lRow, COL_BS_KONTO).Value)) = 0 Then
            ws.Cells(lRow, COL_BS_KONTO).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Eine Eingabe in das Feld Konto ist notwendig. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        ElseIf Not ws.Cells(lRow, COL_AW_CHECKKTOLEN_K) Then
            ' Die L|fffd|nge der Kontonummer ist zu gro|fffd|
            ws.Cells(lRow, COL_BS_KONTO).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Die L|fffd|nge der Kontonummer (Ist: " & Len(Trim(ws.Cells(lRow, COL_BS_KONTO))) & ") ist zu gro|fffd| (Max: " & [KtoL|fffd|nge] + 1 & ")" & vbCrLf
            Pr|fffd|feZeile = False
        End If
    End If
    
    ' Belegfeld1 als Pflichtangabe
    If [NeedsSpalteBeleg1] Then
        If Len(Trim(ws.Cells(lRow, COL_BS_BELEG1).Value)) = 0 Then
            ws.Cells(lRow, COL_BS_BELEG1).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Eine Eingabe in das Feld Rechn.Nr. ist notwendig. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
    End If
    
    ' Kostfeld1 als Pflichtangabe
    If [NeedsSpalteKost1] Then
        If Len(Trim(ws.Cells(lRow, COL_BS_KOST1).Value)) = 0 Then
            ws.Cells(lRow, COL_BS_KOST1).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Eine Eingabe in das Feld Kostenstelle ist notwendig. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
    End If
    If [OptSpalteKost1] Then
        ' Kostfeld1 muss vorgegeben sein
        If [DefinedKostOnly] And Not IsDefinedKost(ws.Cells(lRow, COL_BS_KOST1).Value) Then
            ws.Cells(lRow, COL_BS_KOST1).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld Kostenstelle darf nur vordefinierte Werte enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen oder Textvorlagen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
        ' Kostfeld1 nur numerisch
        If [NumericKostOnly] Then
            If Not ws.Cells(lRow, COL_AW_KOSTNUMERIC_1) Then
                ws.Cells(lRow, COL_BS_KOST1).Interior.ColorIndex = COLOR_ERROR
                szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld Kostenstelle darf nur numerische Werte enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
                Pr|fffd|feZeile = False
            End If
        End If
    End If
    
    ' Kostfeld2 als Pflichtangabe
    If [NeedsSpalteKost2] Then
        If Len(Trim(ws.Cells(lRow, COL_BS_KOST2).Value)) = 0 Then
            ws.Cells(lRow, COL_BS_KOST2).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Eine Eingabe in das Feld KOST2 ist notwendig. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
    End If
    If [OptSpalteKost2] Then
        ' Kostfeld2 muss vorgegeben sein
        If [DefinedKostOnly] And Not IsDefinedKost(ws.Cells(lRow, COL_BS_KOST2).Value) Then
            ws.Cells(lRow, COL_BS_KOST2).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld KOST2 darf nur vordefinierte Werte enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen oder Textvorlagen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
        ' Kostfeld1 nur numerisch
        If [NumericKostOnly] Then
            If Not ws.Cells(lRow, COL_AW_KOSTNUMERIC_2) Then
                ws.Cells(lRow, COL_BS_KOST2).Interior.ColorIndex = COLOR_ERROR
                szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld KOST2 darf nur numerische Werte enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
                Pr|fffd|feZeile = False
            End If
        End If
    End If
    
    ' L|fffd|nge von Textfeldern
    If TOOLKASSE Then
        If ws.Cells(lRow, COL_AW_TEXTLEN) Then
            ' Gr|fffd||fffd|er als erlaubt
            ws.Cells(lRow, COL_BS_TEXT).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld Text darf maximal " + CStr([StandardTextLen]) + " Zeichen enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
    Else
        ' todo Warenart, Bezahlt am/durch
        If ws.Cells(lRow, COL_AW_NAMEORTLEN) Then
            ' Gr|fffd||fffd|er als erlaubt
            ws.Cells(lRow, COL_BS_NAMEORT).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld Name und Ort darf maximal " + CStr([StandardTextLen]) + " Zeichen enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
        If ws.Cells(lRow, COL_AW_WARENARTLEN) Then
            ' Gr|fffd||fffd|er als erlaubt
            ws.Cells(lRow, COL_BS_WARENART).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld Warenart darf maximal " + CStr([StandardTextLen]) + " Zeichen enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
        If ws.Cells(lRow, COL_AW_BEZAHLTLEN) Then
            ' Gr|fffd||fffd|er als erlaubt
            ws.Cells(lRow, COL_BS_BEZAHLT).Interior.ColorIndex = COLOR_ERROR
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Das Feld Bezahlt am/durch darf maximal " + CStr([StandardTextLen]) + " Zeichen enthalten. (Pr|fffd|fen Sie ggf. Ihre Einstellungen)" & vbCrLf
            Pr|fffd|feZeile = False
        End If
    End If
    
    If TOOLKASSE Then
        ' Nullbuchungen erlaubt?
        If ws.Cells(lRow, COL_AW_CHECKZEROLEN) And Not [AllowZeroValues] Then
            ws.Cells(lRow, COL_BS_SOLL).Interior.ColorIndex = COLOR_ERROR
            ws.Cells(lRow, COL_BS_HABEN).Interior.ColorIndex = COLOR_ERROR
            Pr|fffd|feZeile = False
            szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "Buchungen mit Betrag 0 sind nicht zul|fffd|ssig. |fffd|ndern Sie ggf. die Einstellungen." & vbCrLf
        End If
        
        ' Zeilenh|fffd|he korrigieren
        If Len(ws.Cells(lRow, COL_BS_TEXT)) > 20 Then
            ' Die Zeilenh|fffd|he |fffd|ber die Schriftgr|fffd||fffd|e festlegen. F|fffd|r einzelne Zeile kann die H|fffd|he alternativ
            ' auch direkt gesetzt werden. F|fffd|r das gesamte Blatt geht es so wesentlich schneller. Zudem
            ' bleibt die H|fffd|he konsistent.
            ws.Cells(lRow, 1).Font.Size = Val([DefaultLineHeightFont]) + IIf([ShowDateOnStatus], Val([DefaultLineHeightSpacing]), 0)
            ' 21.12.2010, tt: Unter Office 2007 kann der AutoFit einen LFZ 9 produzieren :-((
            ws.Cells(lRow, 1).EntireRow.AutoFit
        End If
    End If
    
    ' Irgendein Formelfehler?
    If Val(ws.Cells(lRow, COL_AW_TEXTLEN + 1).Value) > 0 Then
        For lCol = COL_OFFSET To COL_OFFSET + COL_ANZAUSWERT
            If IsError(ws.Cells(lRow, lCol).Value) Then
                ' Dieser Fehler wird nur ausgewiesen, wenn noch kein anderer aufgetreten ist,
                ' da z.B. bei fehlendem Datum auch ein Formelfehler vorliegt.
                If Pr|fffd|feZeile Then
                    ' Bislang kein Fehler
                    Pr|fffd|feZeile = False
                    szMsg = szMsg & "Zeile " & lRow - ROW_BS_START + 1 & ": " & "In Spalte " & lCol & " ist ein Formelfehler aufgetreten. Pr|fffd|fen Sie Ihre Eingaben." & vbCrLf
                    Exit For
                End If
            End If
        Next lCol
    End If
    
    ' Fehler aufgetreten? Dann Zeilennummer auch markieren
    If Not Pr|fffd|feZeile Then
        ws.Cells(lRow, COL_BS_LFDNR).Interior.ColorIndex = COLOR_ERROR
    Else
    ' Kein Fehler aufgetreten, dann vergeben wir eine lfd Nummer, sofern noch keine vergeben
        ws.Cells(lRow, COL_BS_LFDNR).Interior.ColorIndex = COLOR_LOCKED
        bEnableEvents = Application.EnableEvents
        Application.EnableEvents = False
        If ws.Cells(lRow, COL_AW_LFDNR).Value < 1 Then
            ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value = ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value + 1
            ws.Cells(lRow, COL_AW_LFDNR).Value = ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value
            If [SpalteLfdNrReal] Then ws.Cells(lRow, COL_BS_LFDNR).Value = ws.Cells(lRow, COL_AW_LFDNR).Value
        End If
        ' Kein Fehler (in der aktuellen Zeile), also CREATED und CRC32 setzen
        If Not IsDate(ws.Cells(lRow, COL_AW_DAT_CREATED).Value) Then
            ws.Cells(lRow, COL_AW_DAT_CREATED).Value = Now
            ws.Cells(lRow, COL_AW_CRC32).Value = GetCRC32(ws, lRow)
            'ws.Cells(lRow, COL_BS_STATUS).Value = "Angelegt" + IIf([ShowDateOnStatus], ":" + Chr(10) + Format(ws.Cells(lRow, COL_AW_DAT_CREATED).Value, "dd.mm.yyyy"), "")
        End If
        Application.EnableEvents = bEnableEvents
    End If
    On Error GoTo 0
    Exit Function
    
ERR_PruefeZeile_LFZ_9:
    Call DoLogPerm("Pr|fffd|feZeile(); Err=" + CStr(Err.Number) + "; " + Err.Description)
    Resume Next
End Function

Attribute VB_Name = "gmodPro"
Option Explicit

Public Const DispIdSetSaveFormatXls = 0
Public Const DispIdSetSaveFormatXlsm = 1
Public Const DispIdSetMetaData = 2

' SetSaveFormat
Public Const EXCEL_SAVEFORMAT_XLS = "MicrosoftDocFormat"
Public Const EXCEL_SAVEFORMAT_XLSM = "NativeDocMacroEnabled"

' Achtung: xlWorkbookNormal hat immer den Wert -4143, aber
'          unter den verschiedenen Office-Versionen eine andere Bedeutung
Public Const XLFMT_Template = 17
Public Const XLFMT_OpenXMLWorkbook = 51
Public Const XLFMT_OpenXMLWorkbookMacroEnabled = 52
Public Const XLFMT_OpenXMLTemplateMacroEnabled = 53
Public Const XLFMT_OpenXMLTemplate = 54
Public Const XLFMT_Excel8 = 56


Public Sub SetSaveFormat(Optional DefaultFormat As Long = XLFMT_Excel8)
    Dim szPara(0) As String
    Dim szFormat As String
    Dim lRetVal As Long
    
    If KomponenteInstalled("K0000133") Then
        lRetVal = -2
        If LenB(ThisWorkbook.Path) = 0 Then
            ' Datei wurde noch nicht gespeichert --> Speicherformat = Default Format
            If DefaultFormat = XLFMT_OpenXMLWorkbookMacroEnabled Then
                szFormat = EXCEL_SAVEFORMAT_XLSM
                lRetVal = Execute(DispIdSetSaveFormatXlsm, szPara)
            Else
                szFormat = EXCEL_SAVEFORMAT_XLS
                lRetVal = Execute(DispIdSetSaveFormatXls, szPara)
            End If
        Else
            ' Datei wurde schon gespeichert --> Speicherformat = "aktuelles Format", aber immer mit Makros
            If Val(Application.Version) >= 12 Then
                If ThisWorkbook.FileFormat = XLFMT_OpenXMLWorkbookMacroEnabled Then
                    szFormat = EXCEL_SAVEFORMAT_XLSM
                    lRetVal = Execute(DispIdSetSaveFormatXlsm, szPara)
                ElseIf ThisWorkbook.FileFormat = XLFMT_Excel8 Then
                    szFormat = EXCEL_SAVEFORMAT_XLS
                    lRetVal = Execute(DispIdSetSaveFormatXls, szPara)
                End If
            Else
                szFormat = EXCEL_SAVEFORMAT_XLS
                lRetVal = Execute(DispIdSetSaveFormatXls, szPara)
            End If
        End If
        Debug.Print "SetSaveFormat(<" + szFormat + ">): " + CStr(lRetVal)
    End If
End Sub


Private Sub SetSaveFormat_Obsolete()
    Dim szPara(0) As String
    
    ' Wenn das Workbook noch nie gespeichert wurde und GOAL installiert ist,
    ' dann geben wir das Speicherformat (fest: XLS) vor.
    If LenB(ThisWorkbook.Path) = 0 Then
        If KomponenteInstalled("K0000133") Then
            Call Execute(DispIdSetSaveFormatXls, szPara, True)
        End If
    End If
End Sub

Public Function Execute(dispId As Integer, params() As String, Optional bSilent = False) As Integer
    Dim extensionLoader As Object
    Dim extension As Object
    Dim strFilename As String
    Dim lRetVal As Long
    
    Set extensionLoader = ProvideGoalExtensionLoader
    
    If extensionLoader Is Nothing Then
        If Not bSilent Then
            MsgBox TOOLID + "203" + vbCrLf + vbCrLf + _
                "Es konnte keine Verbindung zum Office-Plugin-Lader hergestellt werden.", _
                vbExclamation, TOOLHDR
        End If
        lRetVal = -1
        GoTo END_Execute
    End If
    
    strFilename = AddBackslash(GetProgrammPfad()) + "DvKasseWareGoalExtension"
    If Not ExistsFile(strFilename + ".dll") Then
        If Not bSilent Then
            MsgBox TOOLID + "702" + vbCrLf + vbCrLf + _
                "Das Office-Plugin von " + TOOLHDR + " konnte nicht gefunden werden." + vbCrLf + vbCrLf + _
                Chr$(187) + " Installieren Sie die aktuelle Version der Anwendung " + TOOLHDR + ".", _
                vbExclamation, TOOLHDR
        End If
        lRetVal = -1
        GoTo END_Execute
    End If
    
    Set extension = extensionLoader.LoadFile(strFilename, 0)
    
    If extension Is Nothing Then
        If Not bSilent Then
            MsgBox TOOLID + "701" + vbCrLf + vbCrLf + _
                "Es konnte keine Verbindung zum Office-Plugin hergestellt werden." + vbCrLf + vbCrLf + _
                Chr$(187) + " Installieren Sie die aktuelle Version der Anwendung " + TOOLHDR + ".", _
                vbExclamation, TOOLHDR
        End If
        lRetVal = -1
        Exit Function
    End If
    
    lRetVal = extension.Execute(dispId, params)
    
END_Execute:
    Set extension = Nothing
    Set extensionLoader = Nothing
    On Error GoTo 0
    Execute = lRetVal
End Function

Private Function ProvideGoalExtensionLoader() As Object
    Dim componentProvider As Object
    Dim newCai As COMAddIn
    Dim objExtLoader As Object

    On Error GoTo TryHookConnection
    
    Set newCai = Application.COMAddIns("HookCairo.Connect")
    
    If newCai.Connect Then
        Set componentProvider = newCai.Object.componentProvider
        If Not componentProvider Is Nothing Then
            Set ProvideGoalExtensionLoader = componentProvider.GetComponentFromName("IGoalExtensionLoader")
            Set componentProvider = Nothing
            Exit Function
        End If
    End If
     
TryHookConnection:
    If HookConnection(objExtLoader) Then
       Set ProvideGoalExtensionLoader = objExtLoader
    End If
    
End Function

Private Function HookConnection(objExtLoader As Object) As Boolean
    Dim aCai As COMAddIn                    'Verbindung zum CAI aufbauen
    Dim extLoader As Object                 'den Loader holen
    
    On Error GoTo ErrHookConnection
    
    Set aCai = Application.COMAddIns("DATEV.Goal.StartupJob.1")

    Set extLoader = aCai.Object.GetComponentFromName("IGoalExtensionLoader")
    
    Set objExtLoader = extLoader
    HookConnection = True
    Exit Function

ErrHookConnection:
    HookConnection = False
    
End Function

Private Function GetProgrammPfad(Optional bSilent As Boolean = True) As String
    Dim szPfad As String
    Dim objBasisServer As Object
    
    szPfad = ""
    
    On Error GoTo ErrGetProgrammPfad
    Set objBasisServer = BasisServer("Pfade")
    If Not objBasisServer Is Nothing Then
        szPfad = objBasisServer.GetProgrammPfad
    End If
    On Error GoTo 0
    GetProgrammPfad = szPfad
    Exit Function
    
ErrGetProgrammPfad:
    If Not bSilent Then
        MsgBox TOOLID + "202" + vbCrLf + vbCrLf + _
            "Es konnte keine Verbindung zum DvTvBasisServer hergestellt werden!" + vbCrLf + vbCrLf + _
            "Fehler " + CStr(Err.Number) + vbCrLf + Err.Description + vbCrLf + vbCrLf + _
            Chr$(187) + " Bitte f|fffd|hren Sie auf diesem System die Arbeitsplatzinstallation der Toolbox-Umgebung durch.", _
            vbCritical, TOOLHDR
    End If
    GetProgrammPfad = ""

End Function


Attribute VB_Name = "gmodTextVorlagen"
Option Explicit

Sub DoImportTextVorlagen()
    ' Diese Funktion ist f|fffd|r den Import von Daten in die Tabellen
    ' Textvorlagen und Kostenstelle gleicherma|fffd|en geeignet
    Dim objBasis As Object
    Dim bRetVal As Boolean
    ' Parameter
    Dim wsT As Worksheet
    Dim wsD As Worksheet
    Dim lBNR As Long
    Dim lMNR As Long
    Dim szWJBeginn As String
    Dim lKtoLen As Long
    Dim szDatenpfad As String
    
    Set wsT = ThisWorkbook.Worksheets(ThisWorkbook.ActiveSheet.Name)
    If LCase(wsT.Name) <> LCase(TAB_TEXTE) And LCase(wsT.Name) <> LCase(TAB_KOST) Then
        MsgBox TOOLID + "037" + vbCrLf + vbCrLf + _
            "Diese Funktion kann nur von den Vorlagenseiten f|fffd|r" + vbCrLf + _
            "Buchungss|fffd|tze und Kostenstellen aus aufgerufen werden.", _
            vbInformation, TOOLHDR
        GoTo END_DoImportTextVorlagen
    End If
    
    Set objBasis = MainServer("KWEVorlagen")
    If objBasis Is Nothing Then
        MsgBox TOOLID + "038" + vbCrLf + vbCrLf + _
            "Die angeforderte Funktion kann nicht ausgef|fffd|hrt werden," + vbCrLf + _
            "weil eine notwendige Komponente nicht initialisiert werden konnte." + vbCrLf + vbCrLf + _
            Chr(187) + " Zur Nutzung der vollen Funktionalit|fffd|t installieren Sie die Anwendung oder" + vbCrLf + _
            "   f|fffd|hren eine Reparaturinstallation durch.", _
            vbExclamation, TOOLHDR
        Call DoLogPerm("DoImportTextVorlagen(); MainServer(""KWEVorlagen"")=Nothing")
        GoTo END_DoImportTextVorlagen
    End If
    
    ' Parameter setzen
    Set wsD = ThisWorkbook.Worksheets(TAB_DATEN)
    lBNR = wsD.Range("BNR")
    lMNR = wsD.Range("MNR")
    If IsDate(wsD.Range("WJBeginn")) Then
        szWJBeginn = Format(wsD.Range("WJBeginn"), "dd.mm.yyyy")
    Else
        szWJBeginn = ""
    End If
    lKtoLen = wsD.Range("KtoL|fffd|nge")
    szDatenpfad = wsD.Range("Datenpfad")
    '
    On Error GoTo END_DoImportTextVorlagen
    bRetVal = objBasis.ImportTexte2(lBNR, lMNR, szWJBeginn, szDatenpfad, lKtoLen, wsT)
    
    GoTo END_DoImportTextVorlagen
    
ERR_DoImportTextVorlagen:
    MsgBox TOOLID + "052" + vbCrLf + vbCrLf + _
        "Beim Aufruf der Importfunktion ist ein Fehler aufgetreten." + vbCrLf + vbCrLf + _
        "Fehler " + CStr(Err.Number) + vbCrLf + Err.Description, _
        vbExclamation, TOOLHDR
    
END_DoImportTextVorlagen:
    Set objBasis = Nothing
    Set wsT = Nothing
    Set wsD = Nothing
    
End Sub

Sub DoExportTextVorlagen()
    ' Diese Funktion ist f|fffd|r den Export von Daten aus den Tabellen
    ' Textvorlagen und Kostenstelle gleicherma|fffd|en geeignet
    Dim objBasis As Object
    Dim bRetVal As Boolean
    ' Parameter
    Dim wsT As Worksheet
    Dim wsD As Worksheet
    Dim lBNR As Long
    Dim lMNR As Long
    Dim szWJBeginn As String
    
    Set wsT = ThisWorkbook.Worksheets(ThisWorkbook.ActiveSheet.Name)
    If LCase(wsT.Name) <> LCase(TAB_TEXTE) And LCase(wsT.Name) <> LCase(TAB_KOST) Then
        MsgBox TOOLID + "039" + vbCrLf + vbCrLf + _
            "Diese Funktion kann nur von den Vorlagenseiten f|fffd|r" + vbCrLf + _
            "Buchungss|fffd|tze und Kostenstellen aus aufgerufen werden.", _
            vbInformation, TOOLHDR
        GoTo END_DoExportTextVorlagen
    End If
    
    Set objBasis = MainServer("KWEVorlagen")
    If objBasis Is Nothing Then
        MsgBox TOOLID + "042" + vbCrLf + vbCrLf + _
            "Der OLE-Server der " + TOOLNAME + " kann nicht angesprochen werden." + vbCrLf + vbCrLf + _
            Chr(187) + " Pr|fffd|fen Sie die Installation des Programms.", _
            vbExclamation, TOOLHDR
        GoTo END_DoExportTextVorlagen
    End If
    
    ' Parameter setzen
    Set wsD = ThisWorkbook.Worksheets(TAB_DATEN)
    lBNR = wsD.Range("BNR")
    lMNR = wsD.Range("MNR")
    If IsDate(wsD.Range("WJBeginn")) Then
        szWJBeginn = Format(wsD.Range("WJBeginn"), "dd.mm.yyyy")
    Else
        szWJBeginn = ""
    End If
    '
    bRetVal = objBasis.ExportTexte2(lBNR, lMNR, szWJBeginn, wsT)
'    If objBasis.Message <> "" Then
'        MsgBox objBasis.Message
'    End If
    
END_DoExportTextVorlagen:
    Set objBasis = Nothing
    Set wsT = Nothing
    Set wsD = Nothing
    
End Sub

Attribute VB_Name = "gmodUtils"
Option Explicit

Private Const INVALID_FILE_ATTRIBUTES = &HFFFFFFFF
Private Const FILE_ATTRIBUTE_READONLY = &H1
Private Const FILE_ATTRIBUTE_HIDDEN = &H2
Private Const FILE_ATTRIBUTE_SYSTEM = &H4
Private Const FILE_ATTRIBUTE_DIRECTORY = &H10
Private Const FILE_ATTRIBUTE_ARCHIVE = &H20
Private Const FILE_ATTRIBUTE_NORMAL = &H80
Private Const FILE_ATTRIBUTE_TEMPORARY = &H100
Private Const FILE_ATTRIBUTE_COMPRESSED = &H800
'

Public Function ConvertDLLVersion(szVersion As String) As Long
    Dim lPos1 As Long
    Dim lPos2 As Long
    Dim szValue As String
    
    lPos1 = InStr(szVersion, ".")
    lPos2 = InStrRev(szVersion, ".")
    
    szValue = Left(szVersion, lPos1 - 1) + Format(Mid(szVersion, lPos1 + 1, lPos2 - lPos1 - 1), "!@@") + Format(Mid(szVersion, lPos2 + 1), "!@@@")
    szValue = Replace(szValue, " ", "0")
    ConvertDLLVersion = szValue 'Val(Left(szVersion, lPos1 - 1)) * 100000 + Val(Mid(szVersion, lPos1 + 1, lPos2 - lPos1 - 1)) * 10000 + Val(Mid(szVersion, lPos2 + 1)) * 100
End Function

Public Function ExistsDir(ByVal szDir As String) As Boolean
    Dim lRetVal As Long
    Dim szTemp As String
    
    ExistsDir = False
    
    szTemp = RemoveTrailingBackslash(szDir)
    lRetVal = GetFileAttributes(szTemp)
    
    If (lRetVal <> INVALID_FILE_ATTRIBUTES) And ((lRetVal And FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY) Then
        ExistsDir = True
    End If
End Function

Public Function ExistsFile(szFile As String) As Boolean
    Dim lRetVal As Long
    Dim szTemp As String
    
    ExistsFile = False
    
    szTemp = RemoveTrailingBackslash(szFile)
    lRetVal = GetFileAttributes(szTemp)
    
    If (lRetVal <> INVALID_FILE_ATTRIBUTES) And ((lRetVal And FILE_ATTRIBUTE_DIRECTORY) <> FILE_ATTRIBUTE_DIRECTORY) Then
        ExistsFile = True
    End If
End Function

Public Function ExistsWorksheet(wb As Workbook, szName As String) As Boolean
    ExistsWorksheet = False
    On Error GoTo ErrExistsWorksheet
    If wb.Worksheets(szName).Name = szName Then ExistsWorksheet = True
    On Error GoTo 0
    Exit Function
    
ErrExistsWorksheet:
    On Error GoTo 0
End Function

Public Function LastDayOf(ByVal iMonat As Integer, ByVal iJahr As Integer) As Integer
    Dim d As Date
    Dim m As Integer
    Dim j As Integer
    
    m = iMonat + 1
    j = iJahr
    If m > 12 Then
        j = j + 1
        m = 1
    End If
    d = "1." & m & "." & j
    LastDayOf = Day(d - 1)
End Function

Public Function zs2a1(ByVal lRow As Long, ByVal lCol As Long) As String
    zs2a1 = sz2a1(lCol, lRow)
End Function

Public Function sz2a1(ByVal lCol As Long, Optional ByVal lRow As Long = 0, Optional bAbsolut As Boolean = False) As String
    Dim l1 As Long
    Dim l2 As Long
    
    l1 = Fix((lCol - 1) / 26)   ' 0 = "", 1 = "A", 2 = "B", ...
    l2 = lCol - (l1 * 26)       ' Rest
    
    If l1 > 0 Then sz2a1 = Chr(Asc("A") - 1 + l1)
    sz2a1 = IIf(bAbsolut, "$", "") + sz2a1 + Chr(Asc("A") - 1 + l2)
    
    If lRow <> 0 Then
        sz2a1 = sz2a1 + IIf(bAbsolut, "$", "") + CStr(lRow)
    End If
End Function

Public Function a12sz(szA1 As String) As Long
    If Len(szA1) > 1 Then
        a12sz = ((Asc(UCase(Left(szA1, 1))) - Asc("A") + 1) * 26) + (Asc(UCase(Mid(szA1, 2, 1))) - Asc("A") + 1)
    Else
        a12sz = Asc(UCase(Left(szA1, 1))) - Asc("A") + 1
    End If
End Function

Public Function GetLeer(strWert As String) As String
    If strWert = "" Then
        GetLeer = " "
    Else
        GetLeer = strWert
    End If
End Function

Public Sub SeitenanzeigeEinstellen(ws As Worksheet, bShowPageNumber As Boolean)
    Dim rCell As Range
    Dim bEingabeKontrolle As Boolean
    Dim lLastRow As Long
    Dim szPrintArea As String
    Dim lOrientation As Long
    
    ' Sheet vorbereiten
    ws.Activate
    Set rCell = ActiveCell
    bEingabeKontrolle = gbEingabeKontrolle
    gbEingabeKontrolle = False
    
    ' Seitenanzeige in Kopfzeilenbereich
    If COL_HD_PAGE_TXT <> 0 Then
        ws.Cells(ROW_HD_PAGE, COL_HD_PAGE_TXT) = IIf(bShowPageNumber, "Aktuelle Seite", "")
    End If
    'ws.Cells(ROW_HD_PAGE, COL_HD_PAGE_NUM).Interior.ColorIndex = IIf(bShowPageNumber, COLOR_CHECKED, COLOR_STANDARD)
    
    ' Druckeinstellungen - notwendig zur Ermittlung der Seitengrenzen
    If bShowPageNumber And Not ws.Cells(ROW_HD_PRINT, COL_HD_PRINT) Then
        ' Default Druckeinstellungen
        lLastRow = GetLastUsedRow(ws)
        szPrintArea = "$" & sz2a1(COL_BS_START) & "$" & ROW_BS_START & ":$" & sz2a1(COL_BS_ENDE + 1) & "$" & lLastRow
        lOrientation = IIf(GetVisibleColumns(ws) > DRUCK_ORIENTATION_CHNG, xlLandscape, xlPortrait)
        
        ' Seiteneinstellungen
        With ActiveSheet.PageSetup
            .PrintTitleRows = "$4:$12"
            .PrintTitleColumns = ""
        End With
        ActiveCell.Select
        On Error Resume Next
        ActiveSheet.PageSetup.PrintArea = szPrintArea
        With ActiveSheet.PageSetup
            .PrintHeadings = False
            .PrintComments = xlPrintNoComments
            .HeaderMargin = Application.CentimetersToPoints(0.5)
            .FooterMargin = Application.CentimetersToPoints(0.5)
            .CenterHorizontally = False
            .CenterVertically = False
            .Orientation = lOrientation
            .Draft = False
            .PaperSize = xlPaperA4
            .Zoom = False
            .FitToPagesWide = 1
            .FitToPagesTall = False
        End With
        On Error GoTo 0
    End If
    
    ws.Activate
    rCell.Select
    gbEingabeKontrolle = bEingabeKontrolle
    Set rCell = Nothing
End Sub

Public Sub CleanupUsedRows(ws As Worksheet)
    Dim bScreenUpdating As Boolean
    Dim bEnableEvents As Boolean
    Dim bProtected As Boolean
    Dim lLastRow As Long
    
    If ws.Name Like "##.####" Then
        ' Einstellungen merken
        bScreenUpdating = Application.ScreenUpdating
        bEnableEvents = Application.EnableEvents
        bProtected = ws.ProtectContents
        ' Einstellungen setzen
        If bScreenUpdating Then Application.ScreenUpdating = False
        If bEnableEvents Then Application.EnableEvents = False
        If bProtected Then ws.Unprotect
        ' Zeilen bereinigen
        ws.Activate
        lLastRow = GetLastUsedRow(ws) + 1
        If lLastRow < ROW_BS_START Then lLastRow = ROW_BS_START
        ws.Range(ws.Cells(lLastRow, COL_BS_FIRST), ws.Cells(65536, COL_BS_FIRST)).Select
        Selection.EntireRow.Delete
        ws.Cells(COL_BS_FIRST, GetLastUsedRow(ws)).Select
        ' Einstellungen wieder herstellen
        If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
        If bEnableEvents Then Application.EnableEvents = True
        If bScreenUpdating Then Application.ScreenUpdating = True
    End If
End Sub

Public Function GetSortText(lSortKey As Long) As String
    Dim ws As Worksheet
    Dim hit As Range
    
    GetSortText = ""
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    Set hit = ws.Range("SortierSpalten").Columns(2).Find(What:=lSortKey, LookIn:=xlValues, LookAt:=xlWhole)
    If Not hit Is Nothing Then GetSortText = ws.Cells(hit.Row, 2)
    Set ws = Nothing
End Function

Public Sub L|fffd|scheBuchungssatz(rCells As Range)
    Dim lRetVal As Long
    Dim r As Range
    Dim i As Long
    Dim szMsg As String
    Dim ws As Worksheet
    Dim bProtectContents As Boolean
    Dim lCntChecked As Long
    Dim lCntExported As Long
    Dim lCntInvalid As Long
    Dim aDelRows() As Variant
    Dim lRow As Long
    Dim bFound As Boolean
    
    Set ws = ActiveSheet
    bProtectContents = ws.ProtectContents
    
    ' Sicher ist sicher...
    If Not LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
        ' Kein Datensheet
        Set ws = Nothing
        Exit Sub
    End If
        
    ' Bereich pr|fffd|fen und evtl. Hinweismeldung
    lCntChecked = 0
    lCntExported = 0
    lCntInvalid = 0
    lRow = 0
    ReDim aDelRows(0)
    For Each r In rCells.Rows
        If r.Row < ROW_BS_START Then
            lCntInvalid = lCntInvalid + 1
        ElseIf Trim(ws.Cells(r.Row, COL_AW_DAT_EXPORTED).Value) <> "" Then
            lCntExported = lCntExported + 1
        ElseIf ThisWorkbook.Worksheets(TAB_DATEN).Range("AllowDeleteChecked").Value = False And _
               Trim(ws.Cells(r.Row, COL_AW_DAT_CHECKED).Value) <> "" Then
            lCntChecked = lCntChecked + 1
        Else
            ' Achtung: bei einem Multiselect kann eine Zelle mehrfach im Range vorkommen
            ' --> darf aber nur einmal in der Liste auftauchen!!
            bFound = False
            For i = LBound(aDelRows) To UBound(aDelRows)
                If aDelRows(i) = r.Row Then
                    ' Zeile schon vorhanden
                    bFound = True
                    Exit For
                End If
            Next i
            If Not bFound Then
                ' Nummer der Zeile merken...
                ReDim Preserve aDelRows(lRow)
                aDelRows(lRow) = r.Row
                lRow = lRow + 1
            End If
        End If
    Next
    If lCntExported + lCntChecked + lCntInvalid > 0 Then
        szMsg = ""
        If lCntInvalid > 0 Then
            szMsg = szMsg + Chr(149) + " Im ausgew|fffd|hlten Bereich sind Kopfzeilen enthalten." + vbCrLf + "  Diese werden beim L|fffd|schen ignoriert." + vbCrLf
        End If
        If lCntExported > 0 Then
            szMsg = szMsg + Chr(149) + " Im ausgew|fffd|hlten Bereich sind bereits exportierte Buchungss|fffd|tze enthalten." + vbCrLf + "  Diese werden beim L|fffd|schen ignoriert." + vbCrLf
        End If
        If lCntChecked > 0 Then
            szMsg = szMsg + Chr(149) + " Im ausgew|fffd|hlten Bereich sind gepr|fffd|fte Buchungss|fffd|tze enthalten." + vbCrLf + "  Gem|fffd||fffd| aktueller Einstellung werden diese beim L|fffd|schen ignoriert."
        End If
        
        If MsgBox(TOOLID + "010" + vbCrLf + vbCrLf + szMsg, _
           vbInformation + vbOKCancel, TOOLHDR) = vbCancel Then
            Set ws = Nothing
            Exit Sub
        End If
    End If
    
    ' Bleib etwas zum L|fffd|schen |fffd|brig?
    On Error Resume Next
    lRow = aDelRows(0)
    If Err.Number <> 0 Then
        On Error GoTo 0
        Exit Sub
    End If
    
    ' Zu l|fffd|schende Zeilen markieren
    rCells.EntireRow.Select
    lRetVal = MsgBox(TOOLID + "008" + vbCrLf + vbCrLf + _
        "Sollen die markierten Zeilen gel|fffd|scht werden?", vbExclamation + vbYesNo, TOOLHDR)
    If lRetVal = vbYes Then
        If bProtectContents Then ws.Unprotect
        Application.EnableEvents = False
        Application.ScreenUpdating = False
        ' Array sortieren, da wir zuverl|fffd|ssig von hinten nach vorne laufen wollen
        Call SelectionSort(aDelRows)
        For lRow = UBound(aDelRows) To LBound(aDelRows) Step -1
            If aDelRows(lRow) >= ROW_BS_START And _
               Trim(ws.Cells(aDelRows(lRow), COL_AW_DAT_EXPORTED).Value) = "" And _
               (ThisWorkbook.Worksheets(TAB_DATEN).Range("AllowDeleteChecked").Value = True Or _
                 Trim(ws.Cells(aDelRows(lRow), COL_AW_DAT_CHECKED).Value) = "") Then
                ws.Cells(aDelRows(lRow), 1).EntireRow.Delete
            End If
        Next lRow
        Application.ScreenUpdating = True
        Application.EnableEvents = True
        ws.Cells(1, 1).Select
        DoEvents
        ws.Cells(ROW_BS_START, COL_BS_START_INPUT).Select
        DoEvents
        If bProtectContents Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    End If
    
    If TOOLKASSE Then
        ' Sortieren und Validieren wegen evtl. fehlendem Tagessaldo
        If ws.Cells(ROW_HD_SORT, COL_HD_SORTNUM) = [SpaltenOffsetDatum] Then
            Call SortierenUndValidieren(ActiveSheet, szMsg)
        End If
    End If
    
    ' Lfd. Nr. zur|fffd|cksetzen, wenn Seite leer ist
    If GetLastUsedRow(ws) < ROW_BS_START Then ws.Cells(ROW_HD_LFD, COL_HD_LFD).Value = 0
    Set ws = Nothing
    
End Sub

Public Sub LoescheZaehlprotokoll(rCells As Range)
    ' Achtung: Wir d|fffd|rfen keine Zeilen l|fffd|schen, da uns sonst irgendwann mal der ausgeblendete
    ' Druckbereich in die Quere kommt.
    Dim lRetVal As Long
    Dim r As Range
    Dim i As Long
    Dim ws As Worksheet
    Dim bProtectContents As Boolean
    Dim lCntInvalid As Long
    Dim aDelRows() As Variant
    Dim lRow As Long
    Dim bFound As Boolean
    Dim lLastRow As Long
    
    Set ws = ActiveSheet
    
    ' Sicher ist sicher...
    If ws.Name <> TAB_ZAEHLPROTOKOLL Then
        ' Kein Z|fffd|hlprotokoll
        Set ws = Nothing
        Exit Sub
    End If
        
    ' Bereich pr|fffd|fen und evtl. Hinweismeldung
    lCntInvalid = 0
    lRow = 0
    ReDim aDelRows(0)
    For Each r In rCells.Rows
        If r.Row < ROW_ZP_START Then
            lCntInvalid = lCntInvalid + 1
        Else
            ' Achtung: bei einem Multiselect kann eine Zelle mehrfach im Range vorkommen
            ' --> darf aber nur einmal in der Liste auftauchen!!
            bFound = False
            For i = LBound(aDelRows) To UBound(aDelRows)
                If aDelRows(i) = r.Row Then
                    ' Zeile schon vorhanden
                    bFound = True
                    Exit For
                End If
            Next i
            If Not bFound Then
                ' Nummer der Zeile merken...
                ReDim Preserve aDelRows(lRow)
                aDelRows(lRow) = r.Row
                lRow = lRow + 1
            End If
        End If
    Next
    If lCntInvalid > 0 Then
        If MsgBox(TOOLID + "006" + vbCrLf + vbCrLf + _
                Chr(149) + " Im ausgew|fffd|hlten Bereich sind Kopfzeilen enthalten." + vbCrLf + _
                "  Diese werden beim L|fffd|schen ignoriert." + vbCrLf, _
                vbInformation + vbOKCancel, TOOLHDR) = vbCancel Then
            Set ws = Nothing
            Exit Sub
        End If
    End If
    
    ' Bleib etwas zum L|fffd|schen |fffd|brig?
    On Error Resume Next
    lRow = aDelRows(0)
    If Err.Number <> 0 Then
        On Error GoTo 0
        Exit Sub
    End If
    
    bProtectContents = ws.ProtectContents
    
    ' Zu l|fffd|schende Zeilen markieren
    rCells.EntireRow.Select
    lRetVal = MsgBox(TOOLID + "049" + vbCrLf + vbCrLf + _
        "Sollen die markierten Zeilen gel|fffd|scht werden?", vbExclamation + vbYesNo, TOOLHDR)
    If lRetVal = vbYes Then
        If bProtectContents Then ws.Unprotect
        Application.EnableEvents = False
        Application.ScreenUpdating = False
        ' Inhalt leeren
        Selection.ClearContents
        ' und neu sortieren
        lLastRow = GetLastUsedRow(ws, ROW_ZP_START, COL_ZP_END)
        ws.Range(ws.Cells(ROW_ZP_START, COL_ZP_START), ws.Cells(lLastRow, COL_ZP_END)).Sort _
            Key1:=ws.Cells(ROW_ZP_START), Order1:=xlAscending, Header:=xlNo
        Application.ScreenUpdating = True
        Application.EnableEvents = True
        ws.Cells(ROW_ZP_START, COL_ZP_START).Select
        DoEvents
    End If
    
    If Not ws.ProtectContents Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    Set ws = Nothing
    
End Sub

Public Function AktualisiereMonat(ws As Worksheet, Optional bSuppressEmpty As Boolean = False) As Long
    Dim lRetVal As Integer
    Dim szMsg As String
    Dim bScreenUpdate As Boolean
    Dim fError As gfrmFehler
    Dim rCell As Range
    
    ' Keine Aktualisierung der Anzeige
    bScreenUpdate = Application.ScreenUpdating
    Application.ScreenUpdating = False
    
    AktualisiereMonat = BS_OK
    
    ' Verarbeitung starten
    Set rCell = ActiveCell
    lRetVal = SortierenUndValidieren(ws, szMsg)
    ' Anzeige aktualisieren
    If lRetVal <> BS_ERROR Then rCell.Select
    Application.ScreenUpdating = bScreenUpdate
    
    ' Ergebnis anzeigen
    If bSuppressEmpty And lRetVal = BS_EMPTY Then GoTo AusgangAktualisiereMonat
    If lRetVal <> BS_OK Then
        Set fError = New gfrmFehler
        fError.OkButtonCaption = "Ok"
        fError.CancelButton = False
        fError.ErrorNumber = "003"
        fError.MessageText = szMsg
        fError.ActionText = "Bereinigen Sie die Fehler. N|fffd|here Informationen entnehmen Sie bitte der Hilfe."
        fError.Show
        Unload fError
        Set fError = Nothing
    End If
    
AusgangAktualisiereMonat:
    AktualisiereMonat = lRetVal
End Function

Public Function AktualisiereZeile(ws As Worksheet, lRowPrev As Long) As Long
    Dim szMsg As String
    Dim bScreenUpdate As Boolean
    Dim fError As gfrmFehler
    Dim rCell As Range
    Dim bFehler As Boolean
    Dim bProtected As Boolean
    Dim l As Long
    
    AktualisiereZeile = BS_OK
    
    ' Validiere Zeilennummer
    If lRowPrev < ROW_BS_START Then Exit Function
    
    ' Keine Aktualisierung der Anzeige
    bScreenUpdate = Application.ScreenUpdating
    Application.ScreenUpdating = False
    
    ' Blattschutz aufheben
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    
    ' Verarbeitung starten
    Set rCell = ActiveCell
    bFehler = Not Pr|fffd|feZeile(ws, lRowPrev, szMsg)
    ' Fehler aufgetreten?
    If bFehler Then
        AktualisiereZeile = BS_ERROR
        ' Letzten CRLF im Meldungstext l|fffd|schen
        szMsg = Left(szMsg, Len(szMsg) - 1)
        ' Auf den ersten Fehler der Zeile positionieren
        For l = COL_BS_FIRST To COL_BS_ENDE
            If ws.Cells(lRowPrev, l).Interior.ColorIndex <> COLOR_STANDARD Then
                Set rCell = ws.Cells(lRowPrev, l)
                Exit For
            End If
        Next l
    Else
        ' Kein Fehler, also CREATED setzen
        If Not IsDate(ws.Cells(lRowPrev, COL_AW_DAT_CREATED).Value) Then
            ws.Cells(lRowPrev, COL_AW_DAT_CREATED).Value = Now
        End If
    End If
    
    ' Blattschutz, falls notwendig
    If bProtected Then ws.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    
    ' Anzeige aktualisieren
    rCell.Select
    Application.ScreenUpdating = bScreenUpdate
    
    ' Ergebnis anzeigen
    If bFehler Then
        Set fError = New gfrmFehler
        fError.OkButtonCaption = "Ok"
        fError.CancelButton = False
        fError.ErrorNumber = "004"
        fError.MessageText = szMsg
        fError.ActionText = "Bereinigen Sie die Fehler. N|fffd|here Informationen entnehmen Sie bitte der Hilfe."
        fError.Show
        Unload fError
        Set fError = Nothing
    End If
End Function

Public Function GetNewLogFileName(Optional szPrefix As String = "", Optional szExt As String = "txt", Optional bHostname As Boolean = True) As String
    Dim szHostname As String
    Dim szTime As String
    Dim lRet As Long
    Dim szBuffer As String * 255

    ' Workstationname holen
    lRet = Len(szBuffer)
    Call GetComputerName(szBuffer, lRet)
    szHostname = Left(szBuffer, lRet)
    ' Zeitkomponenten holen
    szTime = Format(Date, "MMDD") + Format(Time, "HHMMSS")
    GetNewLogFileName = szPrefix + IIf(bHostname, szHostname, "") + "_" + szTime + "." & szExt
End Function

Public Function GetVisibleColumns(ws As Worksheet) As Long
    Dim i As Long
    
    GetVisibleColumns = 0
    If LCase(ws.Cells(ROW_SH_INFO, COL_SH_DATEN)) Like "*daten*" Then
        For i = COL_BS_START To COL_BS_ENDE
            If ws.Cells(ROW_BS_START, i).EntireColumn.ColumnWidth <> 0 Then GetVisibleColumns = GetVisibleColumns + 1
        Next i
    End If

End Function

Public Function GetCRC32(ws As Worksheet, lRow As Long) As Long
    Dim lCol As Long
    Dim szData As String
    
    If ws Is Nothing Then Set ws = ActiveSheet
    
    szData = ""
    For lCol = COL_BS_FIRST To COL_BS_ENDE
        Select Case lCol
            Case COL_BS_BESTAND, COL_BS_BEZAHLT
                ' Nichts tun
            Case Else
                szData = szData + Trim(CStr(ws.Cells(lRow, lCol).Value))
        End Select
    Next lCol
    GetCRC32 = CRC32(szData)
    'Debug.Print CStr(GetCRC32) + ": " + szData
End Function

Public Function RemoveLastDir(szDir) As String
    Dim iPos As Integer
    Dim iLen As Integer
    Dim a As Variant
    
    iLen = Len(szDir)
    If iLen > 1 Then iLen = iLen - 1
    If iLen > 0 Then
        iPos = InStrR(szDir, "\", iLen)
        RemoveLastDir = Left(szDir, iPos)
    Else
        RemoveLastDir = ""
    End If
End Function

Public Function PopLastDir(szDir) As String
    Dim iPos As Integer
    Dim szPath As String
    
    szPath = RemoveTrailingBackslash(szDir)
    If Len(szPath) > 0 Then
        iPos = InStrR(szPath, "\")
        PopLastDir = Mid(szPath, iPos + 1)
        If Right(PopLastDir, 1) = "\" Then PopLastDir = Left(PopLastDir, Len(PopLastDir) - 1)
    Else
        PopLastDir = ""
    End If
End Function

Public Function AddBackslash(szPath As String) As String
    AddBackslash = Trim(szPath)
    If Len(AddBackslash) = 0 Then Exit Function
    If Right(AddBackslash, 1) <> "\" Then AddBackslash = AddBackslash & "\"
End Function

Public Function RemoveTrailingBackslash(ByVal szPath As String) As String
    Dim szTemp As String
    
    szTemp = Trim(szPath)
    If Right(szTemp, 1) = "\" Then
        szTemp = Left(szTemp, Len(szTemp) - 1)
    End If
    RemoveTrailingBackslash = szTemp
End Function

Public Function InStrR(ByVal szCheck As String, ByVal szMatch As String, Optional iStart As Integer = -1, Optional iCompare As Integer = 0) As Variant
    Dim i As Long
    Dim iFirst As Long
    
    If IsNull(szCheck) Or IsNull(szMatch) Then
        InStrR = Null
        Exit Function
    End If
    
    If Len(szCheck) = 0 Or iStart > Len(szCheck) Then
        InStrR = 0
        Exit Function
    End If
    
    If Len(szMatch) = 0 Then
        InStrR = iStart
        Exit Function
    End If
    
    
    InStrR = 0
    iFirst = IIf(iStart = -1, Len(szCheck), iStart)
    For i = iFirst To 1 Step -1
        Select Case iCompare
            Case vbTextCompare
                ' Text compare
                If UCase(Mid(szCheck, i, 1)) = UCase(szMatch) Then
                    InStrR = i
                    Exit Function
                End If
            Case Else
                ' Binary compare
                If Mid(szCheck, i, 1) = szMatch Then
                    InStrR = i
                    Exit Function
                End If
        End Select
    Next i
End Function

Public Function GetLastUsedRow(ws As Worksheet, Optional lRowStart As Long = ROW_BS_START, Optional lColEnde As Long = COL_BS_ENDE) As Long
    Dim lLast As Long
    Dim bProtected As Boolean
    
    ' Worksheet vorbereiten
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    
    GetLastUsedRow = ws.Range(ws.Cells(1, 1), ws.Cells(ROW_BS_MAX, lColEnde)).Find(What:="*", After:=[A1], SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row
    If GetLastUsedRow < lRowStart Then GetLastUsedRow = lRowStart - 1
    If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
End Function

Public Function ReplaceCrLf(ByVal szText As String)
    Dim i As Long
    Dim szNew As String
    Dim c As Variant
    
    szNew = szText
    For Each c In Array(10, 13)
        i = InStr(szNew, Chr(Val(c)))
        Do While i > 0
            If i > 0 Then Mid(szNew, i, 1) = " "
            i = InStr(szNew, Chr(Val(c)))
        Loop
    Next
    ReplaceCrLf = szNew
End Function

Public Function GetToolPrefix() As String
    Dim ws As Worksheet
    Dim szPrefix As String
    Dim szLand As String
    
    GetToolPrefix = ""
    
    Set ws = ThisWorkbook.Worksheets(TAB_DATEN)
    szLand = ws.Range("ToolCountry") + "_"
    szLand = Replace(szLand, "DE", "")
    If ws.Range("ToolKasse") Then
        szPrefix = TOOLPREFIX_KASSE + szLand
    Else
        If ws.Range("WarenEingang") Then
            szPrefix = TOOLPREFIX_WARE_EIN + szLand
        Else
            szPrefix = TOOLPREFIX_WARE_AUS + szLand
        End If
    End If
    Set ws = Nothing
    
    GetToolPrefix = szPrefix
End Function

Public Sub SortVorlage(ws As Worksheet, lSortKey As Long)
    Dim bProtected As Boolean
    Dim lRowStart As Long
    Dim lColStart As Long
    Dim lRowEnd As Long
    Dim lColEnd As Long
    Dim rActiveCell As Range
    
    Set rActiveCell = ActiveCell
    
    ' Links oben / Rechts unten
    If ws.Name = TAB_TEXTE Then
        lRowStart = ROW_TXT_START
        lColStart = COL_TXT_START
        lRowEnd = Application.Rows.Count
        lColEnd = COL_TXT_END
    ElseIf ws.Name = TAB_KOST Then
        lRowStart = ROW_KOST_START
        lColStart = COL_KOST_START
        lRowEnd = Application.Rows.Count
        lColEnd = COL_KOST_END
    Else
        Exit Sub
    End If
    
    ' Blattschutz aufheben
    bProtected = ws.ProtectContents
    If bProtected Then ws.Unprotect
    
    If Val(Application.Version) > 9 Then
        
        ws.Range(ws.Cells(lRowStart, lColStart), ws.Cells(lRowEnd, lColEnd)).Select
        Selection.Sort Key1:=ws.Cells(lRowStart, lSortKey), Order1:=xlAscending, Header:=xlNo, _
            OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, DataOption1:=1    'xlSortTextAsNumbers

    Else
        
        ws.Range(ws.Cells(lRowStart, lColStart), ws.Cells(lRowEnd, lColEnd)).Select
        Selection.Sort Key1:=ws.Cells(lRowStart, lSortKey), Order1:=xlAscending, Header:=xlNo, _
            OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom
    
    End If

    If bProtected Then ws.Protect Contents:=True, Scenarios:=True, DrawingObjects:=True
    rActiveCell.Select
End Sub

' Wird nur von L|fffd|scheBuchungssatz verwendet()
Public Sub SelectionSort(aszValues() As Variant)
    Dim i As Long
    Dim j As Long
    Dim szSmallest As Variant
    Dim lSmallest As Long
    Dim lMin As Long
    Dim lMax As Long
    
    lMin = LBound(aszValues)
    lMax = UBound(aszValues)
    
    For i = lMin To lMax
        ' Find the smallest remaining value in entries i through num.
        szSmallest = aszValues(i)
        lSmallest = i
    
        For j = i + 1 To lMax
            ' See if values(j) is smaller.
            If aszValues(j) < szSmallest Then
                ' Save the new smallest value.
                szSmallest = aszValues(j)
                lSmallest = j
            End If
        Next j
    
        If lSmallest <> i Then
            ' Swap items i and lSmallest.
            aszValues(lSmallest) = aszValues(i)
            aszValues(i) = szSmallest
        End If
      Next i
End Sub

Public Function CRC32(Str As String) As Long
    Dim i As Long
    Dim j As Long
    Dim nPowers(0 To 7) As Integer
    Dim nCRC As Long
    Dim nByte As Integer
    Dim nBit As Boolean
    
    For i = 0 To 7
        nPowers(i) = 2 ^ i
    Next 'i
    For i = 1 To Len(Str)
        nByte = Asc(Mid$(Str, i, 1))
        For j = 7 To 0 Step -1
            nBit = CBool((nCRC And 32768) = 32768) Xor ((nByte And nPowers(j)) = nPowers(j))
            nCRC = (nCRC And 32767&) * 2&
            If nBit Then
                nCRC = nCRC Xor &H8005&
            End If
        Next 'j
    Next 'i
    CRC32 = nCRC
End Function

Public Function IsDefinedKost(szKost As String) As Boolean
    Dim ws As Worksheet
    Dim r As Range
    
    IsDefinedKost = False
    
    On Error GoTo ERR_IsDefinedKost
    
    ' Sheet Textvorlagen
    Set ws = ThisWorkbook.Worksheets(TAB_TEXTE)
    Set r = ws.Columns(COL_TXT_KOST1).Find(What:=szKost, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)
    If Not r Is Nothing Then
        IsDefinedKost = True
        Exit Function
    End If
    ' Sheet Kostenstellen
    Set ws = ThisWorkbook.Worksheets(TAB_KOST)
    Set r = ws.Columns(COL_KOST_KOST).Find(What:=szKost, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)
    If Not r Is Nothing Then IsDefinedKost = True
    Exit Function
    
ERR_IsDefinedKost:
    MsgBox TOOLID + "053" + vbCrLf + vbCrLf + _
        "Bei der Pr|fffd|fung der Kostenstelle ist ein Fehler aufgetreten." + vbCrLf + vbCrLf + _
        "Fehler " + CStr(Err.Number) + vbCrLf + Err.Description, _
        vbExclamation, TOOLHDR
    IsDefinedKost = True
End Function

Public Function ResetLastSaveTime() As Boolean
    Dim vDate As Variant
    Dim bReset As Boolean
    
    ' Wurde ein Workbook neu erstellt und noch nicht gespeichert, dann geht die
    ' BSOffice-Schnittstelle davon aus, dass auch die Dokumenteigenschaft
    ' "LastSaveTime" leer oder nicht gesetzt ist. Neben anderen Kriterien wird
    ' sie herangezogen um zu entscheiden, ob die BSO-Men|fffd|s angezeigt werden oder nicht.
    '
    ' Excel Bug?
    ' Die Property "Last Save Time" ist bereits gesetzt und entspricht der des Templates
    '
    bReset = False
    If LenB(ThisWorkbook.Path) = 0 And Not ThisWorkbook.ReadOnly Then
        On Error Resume Next
        ' Das Lesen der Property liefert einen Fehler, wenn sie noch nicht angelegt wurde
        vDate = ThisWorkbook.BuiltinDocumentProperties("Last Save Time")
        If Err.Number = 0 Then
            If IsDate(vDate) Then
                ThisWorkbook.BuiltinDocumentProperties("Last Save Time") = Empty
                bReset = True
            End If
        End If
        On Error GoTo 0
    End If
    '
    ResetLastSaveTime = bReset
End Function

Public Function KomponenteInstalled(szKompID As String) As Boolean
    Dim objServ As Object
    
    Set objServ = BasisServer("KonfigDB")
    If Not objServ Is Nothing Then
        KomponenteInstalled = objServ.ComponentExists(szKompID)
    Else
        KomponenteInstalled = False
    End If
End Function

Attribute VB_Name = "modGlobals"
Option Explicit

Public Const TOOLID As String = "#KB80"
Public Const TOOLHDR As String = "Kassenerfassung"
Public Const TOOLCOMPID As String = "T0000180"
Public Const TOOLCOMPVERS As String = "1.0"
Public Const TOOLEXPVERS As Long = 1#
Public Const TOOLNAME As String = "Kassen- und Warenerfassung"
Public Const TOOLFILE As String = "DvKasse"
'
Public Const TOOLDATE As String = "04.06.2014"
Public Const TOOLYEAR As String = "2013"
Public Const TOOLVERS As String = "2.61"
Public Const TOOLBUILD As String = "31"
Public Const TOOLKASSE As Boolean = True
'
Public Const TOOLPREFIX_KASSE As String = "KE"
Public Const TOOLPREFIX_WARE_EIN As String = "WE"
Public Const TOOLPREFIX_WARE_AUS As String = "WA"
'
Public Const TOOLPREFIX_DE As String = "_"
Public Const TOOLPREFIX_AT As String = "AT_"
'
Public Const TOOLWKZINIFILE = "DvKasseWareWkz.ini"
'
' Fehlercodes von SortierenUndValidieren()
Public Const BS_OK = 1          ' Keine Fehler
Public Const BS_EMPTY = -1      ' Eintragungsseite ist leer
Public Const BS_ERROR = -2      ' Eintragungsseite enth|fffd|lt Fehler
'
Public Const TAB_DATEN = "Eintragungen"
Public Const TAB_HINWEISE = "Hinweise"
Public Const TAB_KOMMENTARE = "Kommentare"
Public Const TAB_MAIN = "Stammdaten"
Public Const TAB_TEMPLATE = "Template"
Public Const TAB_DRUCK = "Blankodruck"
Public Const TAB_TEXTE = "Textvorlagen"
Public Const TAB_KOST = "Kostenstellen"
Public Const TAB_IMPORT = "ASCII_Import"
Public Const TAB_DRUCKSETUP = "Druckeinstellungen"
Public Const TAB_ZAEHLPROTOKOLL = "Z|fffd|hlprotokoll"
'
Public Const DRUCK_ORIENTATION_CHNG = 14
'
Public Const COUNTRY_DE = "DE"
Public Const COUNTRY_AT = "AT"
'
' Laengenbegrenzungen
Public Const MAX_LEN_KOST = 8
Public Const MAX_LEN_BELEG = 12
Public Const MAX_LEN_TEXT = 30
Public Const MAX_LEN_TEXT_2 = 60
Public Const MAX_LEN_INFO = 210
'
' Maximale Zeilenh|fffd|he (irgend ein gr|fffd||fffd|erer Wert)
Public Const MAX_ROW_HEIGHT = 100
'
' Konstanten f|fffd|r die nicht sichtbaren Zellen
'
' Datentypen Offsets f|fffd|r ASCII-Import
Public Const ROW_DATA_TYPE = 4
Public Const COL_DATA_TYPE = 2
'
Public Const COL_OFFSET = 27                            ' Startspalte
Public Const COL_OFFSET_DUMMY = COL_OFFSET - 1
'
' Datenzeilen im Kopfbereich
Public Const ROW_HD_DATA_0 = 1
Public Const ROW_HD_DATA_1 = 2
Public Const ROW_HD_DATA_2 = 3
Public Const ROW_HD_DATA_3 = 5
Public Const ROW_HD_DATA_4 = 7
Public Const ROW_HD_DATA_5 = 9
'
' Kennzeichnung des Erfassungsblattes
Public Const ROW_SH_INFO = ROW_HD_DATA_0
Public Const COL_SH_DATEN = COL_OFFSET + 0              ' Kennzeichnung f|fffd|r Datensheet
'Public Const COL_SH_KOST = COL_OFFSET + 1              ' mit oder ohne Spalten Kost
'
' Auswertespalten
Public Const COL_AW_SOLLHABEN = COL_OFFSET + 0          ' Einnahmen oder Ausgaben muss gef|fffd|llt sein
Public Const COL_AW_CHECKDATE = COL_OFFSET + 1          ' Datumspr|fffd|fung
Public Const COL_AW_DATECHANGE = COL_OFFSET + 2         ' Auf Tageswechsel pr|fffd|fen
Public Const COL_AW_SALDO = COL_OFFSET + 3              ' Tagessaldo f|fffd|hren. Nur relevant, wenn nach Datum sortiert
Public Const COL_AW_USEDCELLS = COL_OFFSET + 4          ' Anzahl gef|fffd|llter Felder?
Public Const COL_AW_DATUM = COL_OFFSET + 5              ' Auswertespalte: vollst|fffd|ndiges Datum
Public Const COL_AW_CHECKSKONTO = COL_OFFSET + 6        ' Skonto kleiner als Einnahmen und Ausgaben?
Public Const COL_AW_CHECKBU = COL_OFFSET + 7            ' BU-Feld nur mit Gegenkonto
Public Const COL_AW_CHECKKTOLEN_G = COL_OFFSET + 8      ' Pr|fffd|fung L|fffd|nge Gegenkonto
Public Const COL_AW_CHECKKTOLEN_K = COL_OFFSET_DUMMY    ' Pr|fffd|fung L|fffd|nge Konto
Public Const COL_AW_CHECKZEROLEN = COL_OFFSET + 9       ' Pr|fffd|fung ob Betrag 0 ergibt
Public Const COL_AW_ZUSATZ1 = COL_OFFSET_DUMMY
Public Const COL_AW_ZUSATZ2 = COL_OFFSET_DUMMY
Public Const COL_AW_RECHNART = COL_OFFSET_DUMMY
Public Const COL_AW_DAT_CREATED = COL_OFFSET + 10       ' Datum, wann der Datensatz angelegt wurde
Public Const COL_AW_DAT_CHANGED = COL_OFFSET + 11       ' Datum, wann der Datensatz zuletzt ge|fffd|ndert wurde
Public Const COL_AW_DAT_CHECKED = COL_OFFSET + 12       ' Datum, wann der Datensatz exportiert wurde
Public Const COL_AW_DAT_EXPORTED = COL_OFFSET + 13      ' Datum, wann der Datensatz exportiert wurde
Public Const COL_AW_EXPORTSTATUS = COL_OFFSET + 14      ' Status des Exports
Public Const COL_AW_CRC32 = COL_OFFSET + 15             ' Die zum Datum 'Zuletzt ge|fffd|ndert' geh|fffd|rende CRC32
Public Const COL_AW_LFDNR = COL_OFFSET + 16             ' Die 'echte' Lfd.Nr.
Public Const COL_AW_TOCHECK = COL_OFFSET + 17           ' Status Zu pr|fffd|fen
Public Const COL_AW_KOSTNUMERIC_1 = COL_OFFSET + 18     ' Kost1 nur numerisch
Public Const COL_AW_KOSTNUMERIC_2 = COL_OFFSET + 19     ' Kost2 nur numerisch
Public Const COL_AW_TEXTLEN = COL_OFFSET + 20           ' L|fffd|nge des Textes ok
Public Const COL_AW_NAMEORTLEN = COL_OFFSET_DUMMY
Public Const COL_AW_WARENARTLEN = COL_OFFSET_DUMMY
Public Const COL_AW_BEZAHLTLEN = COL_OFFSET_DUMMY
Public Const COL_AW_STATUSTEXT = COL_OFFSET + 21
Public Const COL_AW_STATUSCOLOR = COL_OFFSET + 22
'
Public Const COL_AW_LASTCOL = COL_AW_STATUSCOLOR
'
Public Const COL_ANZAUSWERT = COL_AW_LASTCOL + 1        ' Anzahl an Auswertespalten ???????
'
'
' Laufende Nummer
Public Const ROW_HD_LFD = ROW_HD_DATA_2
Public Const COL_HD_LFD = COL_OFFSET + 3
' Sortierung
Public Const ROW_HD_SORT = ROW_HD_DATA_4
Public Const COL_HD_SORTNUM = COL_OFFSET + 4
Public Const COL_HD_SORTTEXT = COL_OFFSET + 5
Public Const COL_HD_SORTOPT = COL_OFFSET + 6
' Start-/Endsaldo
Public Const ROW_HD_SALDO = ROW_HD_DATA_2
Public Const COL_HD_SALDO = COL_OFFSET + 0
Public Const COL_HD_SALDOEND = COL_OFFSET + 2
' Datum: Startdatum aktueller Monat, Vormonat / Enddatum
Public Const COL_DAT_CURRENT = COL_OFFSET + 1
Public Const COL_DAT_PREVIOUS = COL_OFFSET + 2
Public Const ROW_DAT_START = ROW_HD_DATA_4
Public Const ROW_DAT_END = ROW_HD_DATA_5
' Datum: Monat/Jahr
Public Const COL_DAT_MONAT = COL_OFFSET + 2
Public Const COL_DAT_JAHR = COL_OFFSET + 3
Public Const ROW_DAT_MONATJAHR = ROW_HD_DATA_3
' Seitenanzeige
Public Const ROW_HD_PAGE = ROW_HD_DATA_3    ' Zeile f|fffd|r Seitennummer
Public Const COL_HD_PAGE_TXT = 4            ' Spalte f|fffd|r Text. Wenn = 0, dann Text mit Nummer zusammen
Public Const COL_HD_PAGE_NUM = 5            ' Spalte f|fffd|r Seitennummer
' Druck einmal durchlaufen
Public Const ROW_HD_PRINT = ROW_HD_DATA_2
Public Const COL_HD_PRINT = COL_OFFSET + 4
'
' Konstanten f|fffd|r Farben
'
Public Const COLOR_STANDARD = 2        ' Wei|fffd|/keine Farbe
Public Const COLOR_CREATED = 39        '
Public Const COLOR_CHANGED = 39        '
Public Const COLOR_LOCKED = 39         ' helles grau
Public Const COLOR_ERROR = 45          ' Orange
Public Const COLOR_EXPORTED = 36       ' zartes Gelb
Public Const COLOR_SKIPPED = 19        ' zarteres Gelb
Public Const COLOR_CHECKED = 4         ' Gr|fffd|n
Public Const COLOR_TOCHECK = 37        ' helles Blau
'
' Konstanten f|fffd|r die sichtbaren Eingabe-/Ausgabefelder
'
Public Const COL_WIDTH_ZUSATZ = 8.71        ' Breite der optionalen Spalten
Public Const COL_WIDTH_ZUSATZ_BREIT = 10.29 ' Breite f|fffd|r Spalten mit bis zu 12 Zeichen
Public Const COL_WIDTH_ZUSATZ_HALF = 4      ' Breite der Zusatzspalten LfdNr und USt
'
Public Const ROW_BS_START = 13
Public Const ROW_BS_MAX = 65536
Public Const ROW_MIN_COUNT = 4
Public Const ROW_HEIGHT = 18
'
Public Const COL_BS_START = 2                          ' Erste Spalte
Public Const COL_BS_LFDNR = COL_BS_START + 0           ' Laufende Nummer
Public Const COL_BS_STATUS = COL_BS_START + 1          ' Status
Public Const COL_BS_START_INPUT = COL_BS_START + 2     ' Erste Eingabespalte
Public Const COL_BS_NAMEORT = 0                        ' Dummy aus Ware
Public Const COL_BS_WARENART = 0                       ' Dummy aus Ware
Public Const COL_BS_SOLL = COL_BS_START + 2            ' Einnahmen
Public Const COL_BS_HABEN = COL_BS_START + 3           ' Ausgaben
Public Const COL_BS_FIRST = COL_BS_SOLL                ' Erste m|fffd|gliche Eingabespalte
Public Const COL_BS_BESTAND = COL_BS_START + 4         ' Bestand
Public Const COL_BS_B = COL_BS_START + 5               ' Berichtigungsschl|fffd|ssel
Public Const COL_BS_U = COL_BS_START + 6               ' Umsatzsteuerschl|fffd|ssel
Public Const COL_BS_GEGENKTO = COL_BS_START + 7        ' Gegenkonto
Public Const COL_BS_BELEG1 = COL_BS_START + 8          ' Rechnungsnummer
Public Const COL_BS_BELEG2 = COL_BS_START + 9          ' Belegnummer
Public Const COL_BS_DATUM = COL_BS_START + 10          ' Buchungsdatum
Public Const COL_BS_KONTO = 0                          ' Dummy aus Ware
Public Const COL_BS_KOST1 = COL_BS_START + 11          ' Kost 1
Public Const COL_BS_KOST2 = COL_BS_START + 12          ' Kost 2
Public Const COL_BS_KOSTMENGE = COL_BS_START + 13      ' Kost-Menge
Public Const COL_BS_SKONTO = COL_BS_START + 14         ' Skonto
Public Const COL_BS_TEXT = COL_BS_START + 15           ' Buchungstext
Public Const COL_BS_BEZAHLT = 0                        ' Dummy aus Ware
Public Const COL_BS_UST = COL_BS_START + 16            ' Umsatzsteuer
Public Const COL_BS_ENDE = COL_BS_UST                  ' Letzte Spalte
'
'
'
' Konstanten f|fffd|r Textvorlagen (allgemein)
'
Public Const ROW_TXT_START = 5
'
Public Const COL_TXT_KONTO = 2      ' Dummy f|fffd|r Ware
Public Const COL_TXT_GEGENKTO = 2   ' Spalte mit Kontonummer
Public Const COL_TXT_TEXT1 = 3      ' Spalte mit Text
Public Const COL_TXT_TEXT2 = 3      ' Dummy f|fffd|r Ware
Public Const COL_TXT_KOST1 = 4
Public Const COL_TXT_KOST2 = 5
' Erste und letzte Spalte
Public Const COL_TXT_START = 2
Public Const COL_TXT_END = 5
'
'
'
' Konstanten f|fffd|r Textvorlagen (Kostenstellen)
'
Public Const ROW_KOST_START = 5
'
Public Const COL_KOST_KOST = 2      ' Spalte mit Kostenstelle
Public Const COL_KOST_TEXT = 3      ' Spalte mit Bezeichnung der Kostenstelle
' Erste und letzte Spalte
Public Const COL_KOST_START = 2
Public Const COL_KOST_END = 3
'
'
'
' Konstanten f|fffd|r Z|fffd|hlprotokoll
'
Public Const ROW_ZP_HEADER = 4
Public Const ROW_ZP_START = ROW_ZP_HEADER + 1
Public Const COL_ZP_START = 2
Public Const COL_ZP_DATE = 2
Public Const COL_ZP_WERT_START = 3
Public Const COL_ZP_SUMME = 18
Public Const COL_ZP_NAME = 19
Public Const COL_ZP_FEHLBETRAG = 20
Public Const COL_ZP_END = COL_ZP_FEHLBETRAG
Public Const ANZ_ZP_WERTE = 15
'
'
'
' Konstanten f|fffd|r ASCII_Import
'
Public Const COL_TAB_OFFSET = 1
Public Const ROW_TAB_NUMBER = 3
Public Const ROW_TAB_TYPE = 4
'
'
' Variablen
'
Public gbEingabeKontrolle As Boolean
Public giCountry As Integer
'
' Hilfe-Klasse
' Die Hilfe-Klasse muss - einmal aufgebaut - bis zum Schlie|fffd|en
' der Arbeitsmappe bestehen bleiben! Wird die Verbindung geschlossen, dann
' wird automatisch auch die Hilfe geschlossen!
Public cHelp As Object
'
' Logging-Klasse
' Die Logging-Klasse ist global verf|fffd|gbar. Sie wird beim ersten Aufruf
' angelegt und beim Schlie|fffd|en des Workbooks ebenfalls geschlossen
Public cLog As Object


' InQuest injected base64 decoded content
' *Zr)
' x)br
' )_x)br
' -z{-zY^
' -z{-zY^
' )_x)br
' )_x)br
' zjej
' {-jYZ
' ZrK%j

INQUEST-PP=macro
