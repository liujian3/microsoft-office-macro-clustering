Attribute VB_Name = "ChooseProjectTypeForm"
Attribute VB_Base = "0{4D9C18A8-B824-4578-BC3C-3AC6F9A67ACB}{5158E0D2-137A-411C-846D-66AE67214A57}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim ok As Boolean
Dim importFileName As String

Public Function GetImportFileName() As String
    GetImportFileName = importFileName
End Function

Public Function GetResult() As Boolean
    GetResult = ok
End Function

Public Function GetLanguage() As String
    GetLanguage = ""
    If SpecSharpButton.Value Then
        GetLanguage = Constants.lSpecSharp
    ElseIf AsmLButton.Value Then
        GetLanguage = Constants.lAsmL
    End If
End Function
Private Sub BrowseButton_Click()
    Dim Filter As String, Flags As Long, fileName As String
  
    Flags = OFN_FILEMUSTEXIST Or OFN_HIDEREADONLY Or OFN_PATHMUSTEXIST
            
    Filter = "Spec# files (*.specs)" & Chr$(0) & "*.specs" & Chr$(0) & _
             "AsmL files (*.asml)" & Chr$(0) & "*.asml" & Chr$(0) & _
             "XML files (*.xml)" & Chr$(0) & "*.xml" & Chr$(0) & _
             "All files (*.*)" & Chr$(0) & "*.*" & Chr$(0) & _
             Chr$(0)
    
    fileName = MySystem.ShowOpen(Filter, Flags, MySystem.GetCurrentFocus())
    
    If fileName <> "" Then
        TextBox.text = fileName
    End If
End Sub

Private Sub CancelButton_Click()
    ok = False
    Hide
End Sub

Private Sub ImportCheckBox_Click()
    Dim checked As Boolean
    checked = ImportCheckBox.Value
    
    ImportFrame.Enabled = checked
    TextBox.Enabled = checked
    BrowseButton.Enabled = checked
End Sub

Private Sub OKButton_Click()
    If ImportCheckBox.Value Then
        importFileName = TextBox.text
    Else
        importFileName = ""
    End If
    
    ok = True
    Hide
EndLabel:
End Sub

Private Sub SetOptionButton(button As OptionButton)
    button.Value = True
    button.SetFocus
End Sub

Sub Init(Optional restrict As Boolean = False)
    ImportCheckBox.Visible = Not restrict
    ImportFrame.Visible = Not restrict
    
    ok = False
End Sub
Attribute VB_Name = "CompilerForm"
Attribute VB_Base = "0{FA88D2B1-3DD3-47C6-91AC-14D16504BA64}{64CFB91D-F43F-488D-8584-E46232563A6E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim indices As Collection
Dim project As project

Public Sub Init(aProject As project)
    Set indices = New Collection
    Set project = aProject
    
    ShowErrors.Value = project.ShowErrors
    ShowWarnings.Value = project.ShowWarnings
    ShowHints.Value = project.ShowHints
End Sub

Private Function FindRealIndex(i As Integer) As Integer
    Dim reali As Integer
    reali = 1
    Dim j As Variant
    For Each j In indices
        i = i - 1
        If i = 0 Then
            FindRealIndex = j
        End If
    Next
End Function

Private Sub ListBox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim i As Integer
    i = ListBox.ListIndex + 1
    Dim reali As Integer
    reali = 1
    Dim j As Variant
    For Each j In indices
        i = i - 1
        If i = 0 Then
            reali = j
        End If
    Next
    project.GoToError reali
End Sub

Public Sub AppendText(text As String)
    Output.text = Output.text & text
    Output.SelLength = 0
    Output.SelStart = Len(Output.text)
End Sub

Public Sub ShowError(index As Integer)
    If ListBox.ListIndex >= 0 Then
        If FindRealIndex(ListBox.ListIndex + 1) = index Then
            Exit Sub
        End If
    End If
    
    Dim k As Integer
    k = 0
    Dim j As Variant
    For Each j In indices
        If j = index Then
            ListBox.ListIndex = k
            Exit Sub
        End If
        k = k + 1
    Next
End Sub

Public Sub AppendError(index As Integer, text As String)
    ListBox.AddItem text
    indices.Add index
End Sub

Public Sub ClearErrors()
    ListBox.Clear
    Set indices = New Collection
End Sub

Private Sub ShowErrors_Click()
    project.ShowErrors = ShowErrors.Value
    project.CompileErrors
End Sub

Private Sub ShowHints_Click()
    project.ShowHints = ShowHints.Value
    project.CompileErrors
End Sub

Private Sub ShowWarnings_Click()
    project.ShowWarnings = ShowWarnings.Value
    project.CompileErrors
End Sub

Attribute VB_Name = "Constants"
Option Explicit

Public tExe As String
Public tWinexe As String
Public tLibrary As String
Public tModule As String

Public lSpecSharp As String
Public lAsmL As String

Public Sub Init(Optional hideFromWord As Boolean = True)
    tExe = "exe"
    tWinexe = "winexe"
    tLibrary = "library"
    tModule = "module"
    
    lSpecSharp = "Spec#"
    lAsmL = "AsmL"
End Sub


Attribute VB_Name = "CustomizationHelper"
Option Explicit

Dim oldContext As Object
Dim oldSaved As Boolean

Public Sub EnterContext(Optional hideFromWord As Boolean = True)
    Set oldContext = Nothing ' default
    
    On Error Resume Next
    oldContext = ActiveDocument ' default
    
    On Error Resume Next
    oldContext = CustomizationContext
    
    CustomizationContext = ThisDocument
    oldSaved = ThisDocument.Saved
End Sub

Public Sub LeaveContext(Optional hideFromWord As Boolean = True)
    On Error GoTo ExitLabel
    If oldSaved And Not ThisDocument.Saved Then
        ThisDocument.Saved = True
    End If
ExitLabel:

    On Error Resume Next
    Set CustomizationContext = oldContext
End Sub

Attribute VB_Name = "DocumentFactory"
Option Explicit

Private Function CreateFromDocument(ByVal sourceFileName As String, Optional ByVal replacements As String = "") As Boolean
    CreateFromDocument = False
    
    Dim tempFileName As String
    tempFileName = sourceFileName & ".tmp.doc"
    
    Dim cmdLine As String
    cmdLine = Chr(34) & MySystem.GetWordGeneratorFileName & Chr(34) & _
        " -v -p " & Chr(34) & sourceFileName & Chr(34) & " " & Chr(34) & tempFileName & Chr(34) & " " & replacements
    
    On Error GoTo errorLabel
    WaitForTermination Shell(PathName:=cmdLine, WindowStyle:=vbNormalFocus)
    
    ActiveDocument.Select
    selection.InsertFile tempFileName
    selection.GoTo What:=wdGoToLine, Which:=wdGoToAbsolute, count:=1
    CreateFromDocument = True
    
    Kill tempFileName
    
    GoTo ExitLabel
errorLabel:
    MsgBox "An error has occurred, your specification could not be imported."
    Resume ExitLabel
ExitLabel:
End Function

Private Sub InsertLine(paraStyle As String, text As String)
    Dim sel As selection
    Set sel = selection
    
    sel.style = paraStyle
    sel.TypeText text
    EditingHElp.RehighlightLine
    sel.TypeParagraph
End Sub

Private Sub InsertSpecSharpModel()
    InsertLine "Title", "Sample Specification"
    InsertLine "Heading 1", "Introduction"
    InsertLine "Normal", "Format the paragraphs which contain the embedded model with the style 'Spec#'."
    InsertLine "Normal", "Since the compiler will ignore everything else, you are free insert pictures, " & _
                         "tables, etc. into your document, and to any formatting for all other text. " & _
                         "However, you can only convert this document into the Spec Explorer Document " & _
                         "XML representation and back without loss of information if you stick to the " & _
                         "styles predefined by the 'Spec Explorer Document' template."
    InsertLine "Heading 1", "Model"
    'InsertLine "Normal", "All definitions in this document live in the namespace 'Model'. " & _
    '                     "Of course, you are free to change the namespace."
    'InsertLine "Spec#", "namespace Model;"
    InsertLine "Normal", "You need a main method for an executable model."
    InsertLine "Spec#", "void Main() {"
    InsertLine "Spec#", "  WriteLine(" & Chr(34) & "Hello, world!" & Chr(34) & ");"
    InsertLine "Spec#", "}"
End Sub

Private Sub InsertAsmLModel()
    InsertLine "Title", "Sample Specification"
    InsertLine "Heading 1", "Introduction"
    InsertLine "Normal", "Format the paragraphs which contain the embedded model with the style 'AsmL'."
    InsertLine "Normal", "Since the compiler will ignore everything else, you are free insert pictures, " & _
                         "tables, etc. into your document, and to any formatting for all other text. " & _
                         "However, you can only convert this document into the Spec Explorer Document " & _
                         "XML representation and back without loss of information if you stick to the " & _
                         "styles predefined by the 'Spec Explorer Document' template."
    InsertLine "Heading 1", "Model"
    'InsertLine "Normal", "All definitions in this document live in the namespace 'Model'. " & _
    '                     "Of course, you are free to change the namespace."
    'InsertLine "AsmL", "namespace Model"
    InsertLine "Normal", "You need a main method for an executable model."
    InsertLine "AsmL", "Main()"
    InsertLine "AsmL", "  WriteLine(" & Chr(34) & "Hello, world!" & Chr(34) & ")"
End Sub

Public Sub CreateNewDocument()
Attribute CreateNewDocument.VB_Description = "Spec Explorer Document/InsertNewAsmLSpecification: A new Spec Explorer Document is inserted into your document."
Attribute CreateNewDocument.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.DocumentFactory.CreateNewDocument"
    Constants.Init
    
    Dim form As New ChooseProjectTypeForm
    form.Init
    form.Show
    
    If form.GetResult Then
        If form.GetImportFileName <> "" Then
            If CreateFromDocument(form.GetImportFileName) Then
                ThisDocument.CheckActiveWindow
            Else
                ActiveDocument.Close
            End If
        Else
            If form.GetLanguage() = Constants.lSpecSharp Then
                InsertSpecSharpModel
            ElseIf form.GetLanguage() = Constants.lAsmL Then
                InsertAsmLModel
            End If
            
            ThisDocument.CheckActiveWindow
            ActiveDocument.Saved = False
        End If
    Else
        ActiveDocument.Close
    End If
End Sub
Attribute VB_Name = "EditingHElp"
Option Explicit

Dim AsmLKeywords As Collection
Dim SpecSharpKeywords As Collection
Dim initialized As Boolean
Dim LinesToRehighlight As Collection

Const NoStyle As Integer = 0
Const AsmLStyle As Integer = 1
Const SpecSharpStyle As Integer = 2

Public Sub Done(Optional hideFromWord As Boolean = True)
End Sub

Public Sub InitKeybindings()
Attribute InitKeybindings.VB_Description = "Spec Explorer Document"
Attribute InitKeybindings.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.EditingHelp.InitKeybindings"
    ' This method must be called manually once to initialize the
    ' keybindings for this template.
    ' Then, the keybindings become part of the customization context
    ' of this template and thus need never to be called again.
    
    On Error GoTo errorLabel

    'CustomizationHelper.EnterContext
    CustomizationContext = ActiveDocument.AttachedTemplate

    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeySpacebar), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicSpacebar"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyTab), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicTab"
     
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeyTab), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicShiftTab"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyReturn), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicReturn"
     
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyBackspace), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicBackspace"
     
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyDelete), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicDelete"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyPeriod), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicPeriod"
     
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyComma), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicComma"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeySemiColon), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicColon"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeySemiColon), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicSemicolon"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKey0), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicCloseParenthesis"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeySingleQuote), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicDoubleQuote"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeySingleQuote), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicSingleQuote"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeySlash), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicSlash"
        
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyCloseSquareBrace), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicCloseSquareBrace"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeyCloseSquareBrace), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicCloseCurlyBrace"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeyPeriod), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicCloseAngleBrace"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeyControl, wdKeyR), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="RehighlightLine"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyControl, wdKeyCloseSquareBrace), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicBraceJump"
        
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyHome), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicHome"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyEnd), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicEnd"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyF5), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicRun"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyF9), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicBreakpoint"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyF10), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicStepOver"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyF11), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicStepInto"
    
    KeyBindings.Add _
        KeyCode:=BuildKeyCode(wdKeyShift, wdKeyF11), _
        KeyCategory:=wdKeyCategoryMacro, _
        Command:="MagicStepOut"
    
errorLabel:
End Sub

Private Function LoadKeywords(ByVal fileName As String) As Collection
    On Error GoTo errorLabel
    Dim keywords As New Collection
    Set keywords = New Collection
    
    Dim keywordsFileName As String
    keywordsFileName = fileName
    
    Open keywordsFileName For Input Access Read Shared As #2
    
    On Error GoTo CloseLabel
    While Not EOF(2)
        Dim s As String
        Input #2, s
        Trim s
        If s <> "" Then
            ' VB does not have structured error handling, which makes it a bit ugly
            ' to catch the exception if a keyword appears twice in the list.
            ' Of course you can argue whether a keyword should be allowed to appear
            ' twice in the list, but it cost me some headache to find this error
            ' anyway. This fixes it forever, even if someone enters a keyword
            ' twice in the list.
            On Error GoTo ResumeLabel
            keywords.Add Item:=s, key:=s
            GoTo ContinueLabel
ResumeLabel:
            Resume ContinueLabel
ContinueLabel:
            On Error GoTo CloseLabel
        End If
    Wend
    
CloseLabel:
    Close #2

errorLabel:
    Set LoadKeywords = keywords
End Function

Public Sub Init(Optional hideFromWord As Boolean = True)
    If Not initialized Then
        initialized = True
        Set LinesToRehighlight = New Collection
        Set AsmLKeywords = LoadKeywords(MySystem.GetAsmLKeywordsFileName)
        Set SpecSharpKeywords = LoadKeywords(MySystem.GetSpecSharpKeywordsFileName)
    End If
    
End Sub

Private Function IsKeyword(ByVal text As String, ByVal style As Integer) As Boolean
    IsKeyword = False
    
    If LCase(text) <> text Then
        GoTo ExitLabel
    End If
    
    On Error GoTo ExitLabel
    Dim dummy As String
    
    If style = AsmLStyle Then
        dummy = AsmLKeywords(text)
    ElseIf style = SpecSharpStyle Then
        dummy = SpecSharpKeywords(text)
    Else
        GoTo ExitLabel
    End If
    ' If the program survived and did not throw an error, we got it.
    IsKeyword = True
    
ExitLabel:
End Function

Private Function IsAlpha(c As String) As Boolean
  IsAlpha = (c >= "a" And c < "z") Or (c >= "A" And c <= "Z")
End Function

Private Function IsIdent(c As String) As Boolean
  IsIdent = IsAlpha(c) Or (c >= "0" And c < "9") Or (c = "_")
End Function

Private Sub GetState(inSingleQuote As Boolean, inDoubleQuote As Boolean, inComment As Boolean, inBackslash As Boolean, inSlash As Boolean, inIdent As Boolean)
    Dim range As range
    Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
    Call range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999)
    
    Dim text As String
    text = range.text
    
    GetStateFromString text, inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
End Sub

Private Sub AdvanceStateFromString(ByVal text As String, inSingleQuote As Boolean, inDoubleQuote As Boolean, inComment As Boolean, inBackslash As Boolean, inSlash As Boolean, inIdent As Boolean)
    Dim nextInBackslash As Boolean
    Dim nextInSlash As Boolean
    Dim nextInIdent As Boolean
    
    If Not inComment Then
        Dim i As Integer
        For i = 1 To Len(text)
            nextInBackslash = False
            nextInSlash = False
            nextInIdent = False
            
            Dim c As String
            c = Mid(text, i, 1)
            Select Case c
            Case "\"
                nextInBackslash = True
            Case "/"
                If (Not inSingleQuote) And (Not inDoubleQuote) And inSlash Then
                    inComment = True
                    inSlash = False
                    inBackslash = False
                    GoTo ExitLabel
                End If
                nextInSlash = True
            Case Chr(34)
                If (Not inBackslash) And Not (inSingleQuote) Then
                    inDoubleQuote = Not inDoubleQuote
                End If
            Case "'"
                If (Not inBackslash) And (Not inDoubleQuote) Then
                    If inIdent Then
                        nextInIdent = True
                    Else
                        inSingleQuote = Not inSingleQuote
                    End If
                End If
            Case Else
                If (Not inSingleQuote) And (Not inDoubleQuote) And IsIdent(c) Then
                    nextInIdent = True
                End If
            End Select
            
            inBackslash = nextInBackslash
            inSlash = nextInSlash
            inIdent = nextInIdent
        Next
    End If
ExitLabel:
End Sub

Private Sub GetStateFromString(ByVal text As String, inSingleQuote As Boolean, inDoubleQuote As Boolean, inComment As Boolean, inBackslash As Boolean, inSlash As Boolean, inIdent As Boolean)
    inSingleQuote = False
    inDoubleQuote = False
    inComment = False
    inBackslash = False
    inSlash = False
    inIdent = False
    
    AdvanceStateFromString text, inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
End Sub

Private Function HighlightKeyword(ByVal style As Integer) As Boolean
    Dim range As range
    Set range = ActiveDocument.range(selection.start, selection.End)
    Call range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999)
    
    Dim text As String
    text = range.text
    
    Dim inSingleQuote As Boolean
    Dim inDoubleQuote As Boolean
    Dim inComment As Boolean
    Dim inBackslash As Boolean
    Dim inSlash As Boolean
    Dim inIdent As Boolean
    GetStateFromString text, inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
    
    If Not (inSingleQuote Or inDoubleQuote Or inComment) Then
        Dim start As Integer
        start = Len(text)
        While start > 0
            If Not IsIdent(Mid(text, start, 1)) Then
                text = Mid(text, start + 1, Len(text) - start)
                range.MoveStart Unit:=wdCharacter, count:=start
                GoTo Break
            End If
            start = start - 1
        Wend
Break:
        
        If IsKeyword(text, style) Then
            range.Font.Bold = True
            HighlightKeyword = True
        Else
            range.Font.Bold = False
            HighlightKeyword = False
        End If
    End If
End Function

Public Sub RehighlightDocument(Optional hideFromWord As Boolean = True)
    System.Cursor = wdCursorWait
    
    Dim i As Integer
    i = 0
    Dim para As Paragraph
    For Each para In ActiveDocument.Paragraphs
        Rehilight para
        
        i = i + 1
        Dim s As String
        s = i / ActiveDocument.Paragraphs.count * 100
        s = Mid(s, 1, 5) & "% rehighlighted. Please wait..."
        Application.StatusBar = s
    Next
    
    Application.StatusBar = "done."
    System.Cursor = wdCursorNormal
End Sub

Public Sub RehighlightSection(Optional hideFromWord As Boolean = True)
    Dim para As Paragraph
    Set para = selection.Paragraphs.First
    
    On Error GoTo HaveBeginError
    While GetGlobalStyle(para.Previous.style) <> NoStyle
        Set para = para.Previous
    Wend
    
    GoTo HaveBegin
HaveBeginError:
    Resume HaveBegin
HaveBegin:
    
    Dim i As Integer
    i = 0
    On Error GoTo ExitLabel
    While GetGlobalStyle(para.style) <> NoStyle
        Rehilight para
        
        i = i + 1
        Dim s As String
        s = i & " lines rehighlighted. Please wait..."
        Application.StatusBar = s
        
        Set para = para.Next
    Wend
ExitLabel:
    Application.StatusBar = "done."
End Sub
           
Public Sub RehighlightLine(Optional hideFromWord As Boolean = True)
    RehilighlightAroundSelection
    Application.StatusBar = "1 line rehighlighted."
End Sub

Private Sub RehilighlightAroundSelection(Optional minLineLength As Integer = 0)
    Application.ScreenUpdating = False
    Dim para As Paragraph
    For Each para In selection.Paragraphs
        Rehilight para, minLineLength
    Next
    Application.ScreenUpdating = True
End Sub

Private Sub Rehilight(para As Paragraph, Optional minLineLength As Integer = 0)
    On Error GoTo ExitLabel
    Dim style As Integer
    style = GetGlobalStyle(para.style)
    If style <> NoStyle Then
        Dim paraRange As range
        Set paraRange = para.range
        
        Dim text As String
        text = paraRange.text
        
        
        If paraRange.Font.Bold <> False Then
            paraRange.Font.Bold = False
        End If
        If paraRange.Font.Italic <> False Then
            paraRange.Font.Italic = False
        End If
        
        ' General Rehighlightting
        If paraRange.Font.ColorIndex <> wdAuto Then
            paraRange.Font.ColorIndex = wdAuto
        End If
        If paraRange.Font.Underline <> wdUnderlineNone Then
            paraRange.Font.Underline = wdUnderlineNone
        End If
        If paraRange.Font.UnderlineColor <> wdColorAutomatic Then
            paraRange.Font.UnderlineColor = wdColorAutomatic
        End If
        
        Dim lastWord As String
        
        Dim inSingleQuote As Boolean
        Dim inDoubleQuote As Boolean
        Dim inComment As Boolean
        Dim inBackslash As Boolean
        Dim inSlash As Boolean
        Dim inIdent As Boolean
        inSingleQuote = False
        inDoubleQuote = False
        inComment = False
        inBackslash = False
        inSlash = False
        inIdent = False
        Dim startItalic As Long
        Dim endItalic As Long
        startItalic = -1
        endItalic = -1
        
        Dim finalSpaces As Integer
        finalSpaces = 0
        
        Dim i As Integer
        For i = 1 To Len(text)
            Dim c As String
            c = Mid(text, i, 1)
            
            If Asc(c) <= 32 Then
                finalSpaces = finalSpaces + 1
            Else
                finalSpaces = 0
            End If
            
            If IsIdent(c) Then
                lastWord = lastWord & c
            Else
                If Not (lastWord = "") Then
                    If IsKeyword(lastWord, style) And Not (inSingleQuote Or inDoubleQuote Or inComment) Then
                        Dim keyword As range
                        Set keyword = ActiveDocument.range(start:=paraRange.Characters(i - Len(lastWord)).start, _
                            End:=paraRange.Characters(i - 1).End)
                        keyword.Bold = True
                    End If
                    lastWord = ""
                End If
            End If
            
            If (inSingleQuote And Not (c = "'" And Not inBackslash)) Or _
               (inDoubleQuote And Not (c = Chr(34) And Not inBackslash)) Then
                If startItalic = -1 Then
                    startItalic = i
                Else
                    endItalic = i
                End If
            Else
                If startItalic <> -1 Then
                    Dim quoted As range
                    Set quoted = ActiveDocument.range(start:=paraRange.Characters(startItalic).start, _
                        End:=paraRange.Characters(endItalic).End)
                    quoted.Italic = True
                    
                    startItalic = -1
                    endItalic = -1
                End If
            End If
            
            If inComment And i >= 3 Then
                If Mid(text, i - 2, 2) = "//" Then
                    Dim comment As range
                    Set comment = paraRange.Characters(i - 2)
                    comment.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 9999
                    'comment.MoveEnd Unit:=wdCharacter, count:=-1
                    comment.Font.ColorIndex = wdGray50
                End If
            End If
            
            AdvanceStateFromString c, inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
        Next i
        If startItalic <> -1 Then
            Set quoted = ActiveDocument.range(start:=paraRange.Characters(startItalic).start, _
                End:=paraRange.Characters(startItalic).start)
            quoted.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 9999
            'quoted.MoveEnd Unit:=wdCharacter, count:=-1
            quoted.Font.Underline = wdUnderlineWavy
            quoted.Font.UnderlineColor = wdColorRed
            quoted.Italic = True
        End If
        
        finalSpaces = finalSpaces - 1
        If finalSpaces > 0 Then
            Dim spaces As range
            i = Len(text) - finalSpaces
            If i < minLineLength + 1 Then
                i = minLineLength + 1
            End If
            If i < Len(text) Then
                Set spaces = paraRange.Characters(i)
                spaces.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 9999
                spaces.Delete
            End If
        End If
    End If
ExitLabel:
End Sub

Private Function GetLocalStyle(ByVal style As String) As Integer
    Dim s As String
    s = UCase(style)
    If (s = "ASML") Or (s = "ASML LITERAL") Or (s = "ASML LITERAL LAYOUT") Then
        GetLocalStyle = AsmLStyle
    Else
        If (s = "A#") Or (s = "A# LITERAL") Or (s = "A# LITERAL LAYOUT") Or _
           (s = "SPEC#") Or (s = "SPEC# LITERAL") Or (s = "SPEC# LITERAL LAYOUT") Then
            GetLocalStyle = SpecSharpStyle
        Else
            GetLocalStyle = NoStyle
        End If
    End If
    
End Function

Private Function GetGlobalStyle(ByVal style As String) As Integer
    Dim s As String
    s = UCase(style)
    If (s = "ASML") Or (s = "ASML LITERAL LAYOUT") Then
        GetGlobalStyle = AsmLStyle
    Else
        If (s = "A#") Or (s = "A# LITERAL LAYOUT") Or _
            (s = "SPEC#") Or (s = "SPEC# LITERAL LAYOUT") Then
            GetGlobalStyle = SpecSharpStyle
        Else
            GetGlobalStyle = NoStyle
        End If
    End If
End Function

Private Function Indentation(ByVal s As String) As Integer
    Dim i As Integer
    i = 1
    
    s = s & "|"
    Do While Mid(s, i, 1) = " "
        i = i + 1
    Loop
    
    Indentation = i - 1
End Function

Private Function ContainsOnlySpaces(ByVal s As String) As Boolean
    ContainsOnlySpaces = Indentation(s) = Len(s)
End Function

Private Function CreateSpaces(ByVal n As Integer) As String
    Dim s As String, i As Integer
    s = ""
    For i = 1 To n
        s = s & " "
    Next
    CreateSpaces = s
End Function

Private Sub CheckForPreceedingKeyword(Optional typeSome As String = "")
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetLocalStyle(selection.style)
    If style <> NoStyle Then
        If HighlightKeyword(style) And (typeSome <> "") Then
            selection.TypeText text:=typeSome
            
            Dim range As range
            Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
            range.MoveStart Unit:=wdCharacter, count:=-1
            range.Font.Bold = False
        ElseIf typeSome <> "" Then
            selection.TypeText text:=typeSome
        End If
    ElseIf typeSome <> "" Then
        selection.TypeText text:=typeSome
    End If
errorLabel:
End Sub

Public Sub MagicSpacebar(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword typeSome:=" "
End Sub

Public Sub MagicComma(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword typeSome:=","
End Sub

Public Sub MagicSemicolon(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword typeSome:=";"
End Sub

Public Sub MagicColon(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword typeSome:=":"
End Sub

Public Sub MagicPeriod(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword typeSome:="."
End Sub

Public Sub RehighlightSomeLines()
Attribute RehighlightSomeLines.VB_Description = "Spec Explorer Document"
Attribute RehighlightSomeLines.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.EditingHelp.RehighlightSomeLines"
    Application.ScreenUpdating = False
    Dim foundSome As Boolean
    
    Dim range As range
    For Each range In LinesToRehighlight
        On Error GoTo errorLabel
        
        Rehilight range.Paragraphs.First
        
        GoTo ContinueLabel
errorLabel:
        Resume ContinueLabel
ContinueLabel:
    Next
    
    If foundSome Then
        Set LinesToRehighlight = New Collection
    End If
    Application.ScreenUpdating = True
End Sub

Private Function MatchBrace(text As String, ByVal pos As Integer) As Integer
    Dim inSingleQuote As Boolean
    Dim inDoubleQuote As Boolean
    Dim inComment As Boolean
    Dim inBackslash As Boolean
    Dim inSlash As Boolean
    Dim inIdent As Boolean
    inSingleQuote = False
    inDoubleQuote = False
    inComment = False
    inBackslash = False
    inSlash = False
    inIdent = False
    
    Dim i As Integer
    For i = 1 To Len(text)
        Dim c As String
        c = Mid(text, i, 1)
        
        If inSingleQuote Or inDoubleQuote Or inComment Or inBackslash Then
            Mid(text, i, 1) = " "
        End If
        
        AdvanceStateFromString c, inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
    Next i

    Dim left As String
    Dim right As String
    c = Mid(text, pos, 1)
    
    Select Case c
    Case ")"
        left = "("
        right = c
    Case "}"
        left = "{"
        right = c
    Case "]"
        left = "["
        right = c
    Case ">"
        left = "<"
        right = c
    Case "("
        left = c
        right = ")"
    Case "{"
        left = c
        right = "}"
    Case "["
        left = c
        right = "]"
    Case "<"
        left = c
        right = ">"
    End Select
    
    Dim count As Integer
    count = 1
    
    MatchBrace = 0
    If c = right Then
        i = pos - 1
        
        Do While i > 0
            Select Case Mid(text, i, 1)
            Case left
                count = count - 1
                If count = 0 Then
                    MatchBrace = i
                    Exit Do
                End If
            Case right
                count = count + 1
            End Select
            i = i - 1
        Loop
    Else
        i = pos + 1
        Do While i <= Len(text)
            Select Case Mid(text, i, 1)
            Case left
                count = count + 1
            Case right
                count = count - 1
                If count = 0 Then
                    MatchBrace = i
                    Exit Do
                End If
            End Select
            i = i + 1
        Loop
    End If
End Function

Private Sub ColorBraces(ByVal range As range, ByVal left As Integer, ByVal right As Integer)
' i must be right of the right brace
    range.MoveStart Unit:=wdCharacter, count:=left - 1
    range.End = range.start + 1
    range.Font.Bold = True
    range.Font.Underline = wdUnderlineWavy
    range.Font.UnderlineColor = wdColorGreen
    
    LinesToRehighlight.Add range
    
    range.start = range.start + right - left
    range.End = range.start + 1
    
    range.Font.Bold = True
    range.Font.Underline = wdUnderlineWavy
    range.Font.UnderlineColor = wdColorGreen
    
    Application.OnTime When:=Now + TimeValue("00:00:05"), name:="AsmlWordAddin.EditingHelp.RehighlightSomeLines"
End Sub

Private Sub CloseBrace(ByVal kind As String)
    On Error GoTo errorLabel

' This feature is too slow, and therefore currently disabled.
'    If InLocalAsmL(selection.style) Then
'        selection.TypeText text:=kind
'        RehilighlightAroundSelection
'
'        Dim range As range
'        Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
'        range.MoveStartUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), -999
'
'        Dim text As String
'        text = range.text
'
'        Dim i As Integer
'        i = MatchBrace(text, Len(text))
'        If i > 0 Then
'            RehighlightSomeLines
'            ColorBraces range, i, Len(text)
'            selection.Font.Bold = False
'            selection.Font.Underline = wdUnderlineNone
'        End If
'    Else
        selection.TypeText text:=kind
'    End If
errorLabel:
End Sub

Public Sub MagicCloseParenthesis(Optional hideFromWord As Boolean = True)
    CloseBrace kind:=")"
End Sub

Public Sub MagicCloseSquareBrace(Optional hideFromWord As Boolean = True)
    CloseBrace kind:="]"
End Sub

Public Sub MagicCloseCurlyBrace(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style = SpecSharpStyle Then
        If Len(selection.text) > 1 Then
            Dim r As range
            Set r = ActiveDocument.range(start:=selection.start, End:=selection.End)
            Reindent r, -2
        Else
            Dim range As range
            Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
            Dim movedBy As Integer
            movedBy = -range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999) - 1
            
            Dim text As String
            text = range.text
            
            If Indentation(text) = movedBy And Len(text) Mod 2 = 0 And Len(text) >= 2 Then
                selection.TypeBackspace
                selection.TypeBackspace
            End If
        End If
    End If
errorLabel:
    
    CloseBrace kind:="}"
End Sub

Public Sub MagicCloseAngleBrace(Optional hideFromWord As Boolean = True)
    CloseBrace kind:=">"
End Sub

Private Function IsBrace(ByVal s As String) As Boolean
    IsBrace = (s = "(") Or (s = "{") Or (s = "[") Or (s = "<") Or _
              (s = ")") Or (s = "}") Or (s = "]") Or (s = ">")
End Function

Public Sub MagicBraceJump(Optional hideFromWord As Boolean = True)
    Dim style As Integer
    style = GetLocalStyle(selection.style)
    If style < NoStyle Then
        Dim range As range
        Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
        Dim moved As Integer
        moved = range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999)
        range.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 999
        
        Dim text As String
        text = range.text
        
        Dim right As Integer
        Dim left As Integer
        right = -moved
        
        If right > 1 Then
            If Not (IsBrace(Mid(text, right, 1)) And Not IsBrace(Mid(text, right - 1, 1))) Then
                right = right - 1
            End If
        End If
        
        If IsBrace(Mid(text, right, 1)) Then
            left = MatchBrace(text, right)
            If left > 0 Then
                Dim moveBy As Integer
                
                If left > right Then
                    Dim temp As Integer
                    temp = left
                    left = right
                    right = temp
                    moveBy = left - right
                Else
                    moveBy = right - left
                End If
                
                RehighlightSomeLines
                ColorBraces range, left, right
                selection.MoveLeft Unit:=wdCharacter, count:=moveBy
                
                selection.Font.Bold = False
                selection.Font.Underline = wdUnderlineNone
            End If
        End If
    End If
End Sub

Private Sub Reindent(r As range, by As Integer)
    Dim p As Paragraph
    For Each p In r.Paragraphs
        If by > 0 Then
            p.range.InsertBefore CreateSpaces(by)
        Else
            Dim q As range
            Set q = ActiveDocument.range(start:=p.range.start, End:=p.range.start)
            Dim c As Integer
            c = q.MoveEndWhile(" ", 2)
            If c > 0 And q.text = CreateSpaces(c) Then
                q.Delete
            End If
        End If
    Next
            
    selection.SetRange r.Paragraphs.First.range.start, r.Paragraphs.last.range.End
End Sub

Public Sub MagicTab(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        If Len(selection.text) > 1 Then
            Reindent selection.range, 2
        Else
            Dim movedCount As Integer
            Dim range As range
            Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
            movedCount = range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999)
            movedCount = -movedCount - 1
            If movedCount Mod 2 = 0 Then
                selection.TypeText text:="  "
            Else
                selection.TypeText text:=" "
            End If
        End If
    Else
        selection.TypeText text:=Chr(9)
    End If
errorLabel:
End Sub

Public Sub MagicShiftTab(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        If Len(selection.text) > 1 Then
            Dim r As range
            Set r = ActiveDocument.range(start:=selection.start, End:=selection.End)
            Reindent r, -2
        Else
            Dim range As range
            Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
            Dim movedBy As Integer
            movedBy = -range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999) - 1
            
            Dim text As String
            text = range.text
            
            If Indentation(text) = movedBy And Len(text) Mod 2 = 0 And Len(text) >= 2 Then
                selection.TypeBackspace
                selection.TypeBackspace
            End If
        End If
    End If
errorLabel:
End Sub

Public Sub MagicReturn(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword
    
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        selection.Font.ColorIndex = wdAuto
        selection.Font.Italic = False
        selection.Font.Bold = False
        
        selection.InsertParagraphAfter
        
        Dim range As range
        Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
        Call range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999)
        
        Dim text As String
        text = range.text
        
        Dim spaces As Integer
        spaces = Indentation(text)
        
        If style = SpecSharpStyle Then
            Dim lastpos As Long
            lastpos = selection.start
            Dim c As String
            c = " "
            On Error GoTo CatchLabel
            c = ActiveDocument.Characters(lastpos)
            GoTo AfterCatchLabel
CatchLabel:
            Resume AfterCatchLabel
AfterCatchLabel:
            On Error GoTo errorLabel
            If c = "{" Then
                spaces = spaces + 2
            End If
        End If
        
        RehilighlightAroundSelection
        
        selection.InsertAfter CreateSpaces(spaces)
        selection.MoveRight
        
        RehilighlightAroundSelection spaces
    Else
        selection.TypeText text:=Chr(13)
    End If
errorLabel:
End Sub

Public Sub MagicBackspace(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    If selection.End - selection.start > 1 Then
        selection.Delete
    Else
        Dim style As Integer
        style = GetGlobalStyle(selection.style)
        If style <> NoStyle Then
            Dim range As range
            Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
            Dim movedBy As Integer
            movedBy = -range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999) - 1
            
            Dim text As String
            text = range.text
            
            If Len(text) Mod 2 = 0 And Len(text) >= 2 Then
                If Mid(text, Len(text) - 1, 2) = "  " Then
                    selection.TypeBackspace
                    selection.TypeBackspace
                Else
                    selection.TypeBackspace
                End If
            Else
                selection.MoveLeft
                selection.Delete
            End If
            
            If Len(text) > 1 Then
                If Mid(text, Len(text), 1) <> " " Then
                    RehilighlightAroundSelection movedBy
                End If
            End If
        Else
            selection.TypeBackspace
        End If
    End If
errorLabel:
End Sub

Public Sub MagicDelete(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    selection.Delete
    
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        Dim range As range
        Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
        range.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 999
        Dim fromLeft As Integer
        fromLeft = -range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999) - 1
        
        If selection.text <> " " Then
            RehilighlightAroundSelection fromLeft
        End If
    End If
errorLabel:
End Sub

Public Sub MagicDoubleQuote(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetLocalStyle(selection.style)
    If style <> NoStyle Then
        Dim inSingleQuote As Boolean
        Dim inDoubleQuote As Boolean
        Dim inComment As Boolean
        Dim inBackslash As Boolean
        Dim inSlash As Boolean
        Dim inIdent As Boolean
        GetState inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
        
        selection.TypeText text:=Chr(34)
        RehilighlightAroundSelection
        If Not (inDoubleQuote And Not inBackslash) Then
            selection.Font.Italic = True
        End If
    Else
        selection.TypeText text:=Chr(34)
    End If
errorLabel:
End Sub

Public Sub MagicSingleQuote(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetLocalStyle(selection.style)
    If style <> NoStyle Then
        Dim inSingleQuote As Boolean
        Dim inDoubleQuote As Boolean
        Dim inComment As Boolean
        Dim inBackslash As Boolean
        Dim inSlash As Boolean
        Dim inIdent As Boolean
        GetState inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
        
        If inIdent Then
            selection.TypeText text:="'"
        Else
            selection.TypeText text:="'"
            RehilighlightAroundSelection
            If Not (inSingleQuote And Not inBackslash) Then
                selection.Font.Italic = True
            End If
        End If
    Else
        selection.TypeText text:="'"
    End If
errorLabel:
End Sub

Public Sub MagicSlash(Optional hideFromWord As Boolean = True)
    CheckForPreceedingKeyword
    
    On Error GoTo errorLabel
    selection.TypeText text:="/"
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        
        Dim inSingleQuote As Boolean
        Dim inDoubleQuote As Boolean
        Dim inComment As Boolean
        Dim inBackslash As Boolean
        Dim inSlash As Boolean
        Dim inIdent As Boolean
        GetState inSingleQuote, inDoubleQuote, inComment, inBackslash, inSlash, inIdent
        
        If inComment Then
            RehilighlightAroundSelection
            'Dim range As range
            'Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
            'range.MoveStart Unit:=wdCharacter, count:=-2
            'Call range.MoveEndUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), 999)
            'range.Font.ColorIndex = wdGray50
        End If
    End If
errorLabel:
End Sub

Public Sub MagicHome(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        Dim range As range
        Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
        range.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 999
        Dim fromLeft As Integer
        fromLeft = -range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999) - 1
        
        Dim text As String
        text = range.text
        
        Dim spaces As Integer
        spaces = Indentation(text)
        
        If spaces = fromLeft Or spaces = Len(text) Then
            selection.StartOf Unit:=wdLine
        Else
            selection.SetRange range.start + spaces, range.start + spaces
        End If
    Else
        selection.StartOf Unit:=wdLine
    End If
errorLabel:
End Sub

Public Sub MagicEnd(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    Dim style As Integer
    style = GetGlobalStyle(selection.style)
    If style <> NoStyle Then
        Dim range As range
        Set range = ActiveDocument.range(start:=selection.start, End:=selection.End)
        range.MoveEndUntil Chr(10) & Chr(11) & Chr(12) & Chr(13), 999
        Dim fromLeft As Integer
        fromLeft = -range.MoveStartUntil(Chr(10) & Chr(11) & Chr(12) & Chr(13), -999) - 1
        
        Dim text As String
        text = "|" & range.text
        
        Dim i As Integer
        i = Len(text)
        Do While Asc(Mid(text, i, 1)) <= 32
            i = i - 1
        Loop
        i = i - 1
        text = Mid(text, 2, Len(text) - 1)
        
        If i = fromLeft Or i = 0 Then
            selection.EndOf Unit:=wdLine
        Else
            selection.SetRange range.start + i, range.start + i
        End If
    Else
        selection.EndOf Unit:=wdLine
    End If
errorLabel:
End Sub

Attribute VB_Name = "GotoForm"
Attribute VB_Base = "0{CF8A6738-1D97-4590-B6CD-686DCB6498F9}{6F7B9381-04C8-4218-BD8A-8C3DBDD57FF3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private nodeNumber As Integer
Private startLine As Integer
Private endLine As Integer
Private startColumn As Integer
Private endColumn As Integer
Private ok As Boolean
Private errorMsg As String

Public Function GetResult(ByRef outNodeNumber As Integer, ByRef outStartLine As Integer, ByRef outStartColumn As Integer, ByRef outEndLine As Integer, ByRef outEndColumn As Integer) As Boolean
    outNodeNumber = nodeNumber
    outStartLine = startLine
    outEndLine = endLine
    outStartColumn = startColumn
    outEndColumn = endColumn
    GetResult = ok
End Function

Public Sub Init()
    If Not RegionButton.Value And Not LineButton.Value Then
        LineButton.Value = True
    End If
    If RegionButton.Value Then
        NodeNumberText.SetFocus
    End If
    enableStuff
    If LineButton.Value Then
        NodeNumberText2.SetFocus
    End If
    
    Call eval
End Sub

Private Sub enableStuff()
    Dim regionEnabled As Boolean
    regionEnabled = RegionButton.Value
    
    NodeNumberText.Enabled = regionEnabled
    StartLineText.Enabled = regionEnabled
    StartColumnText.Enabled = regionEnabled
    EndLineText.Enabled = regionEnabled
    EndColumnText.Enabled = regionEnabled
    
    Dim lineEnabled As Boolean
    lineEnabled = LineButton.Value
    
    NodeNumberText2.Enabled = lineEnabled
    LineText.Enabled = lineEnabled
End Sub

Private Function ToInt(ByVal s As String, ByVal label As String) As Integer
    If s = "" Then
        If errorMsg <> "" Then
            errorMsg = errorMsg & " "
        End If
        errorMsg = errorMsg & "Number is missing for " & label & "."
        ToInt = -1
        GoTo EndLabel
    Else
        Dim v As Double
        On Error GoTo errorLabel
        v = Val(s)
        Dim i As Integer
        i = CInt(v)
        If i < 0 Then
            GoTo errorLabel
        End If
        ToInt = i
        GoTo EndLabel
    End If
    GoTo EndLabel
errorLabel:
    If errorMsg <> "" Then
        errorMsg = errorMsg & " "
    End If
    errorMsg = errorMsg & Chr(34) & label & Chr(34) & " is not a valid number for " & label & "."
    ToInt = -1
    GoTo EndLabel
EndLabel:
End Function

Private Sub eval()
    If LineButton.Value Then
        nodeNumber = ToInt(NodeNumberText2.text, "node number")
        startLine = ToInt(LineText.text, "line")
        endLine = startLine
        startColumn = -1
        endColumn = -1
    Else
        If RegionButton.Value Then
            nodeNumber = ToInt(NodeNumberText.text, "node number")
            startLine = ToInt(StartLineText.text, "start line")
            endLine = ToInt(EndLineText.text, "end line")
            startColumn = ToInt(StartColumnText.text, "start column")
            endColumn = ToInt(EndColumnText.text, "end column")
            If startLine <> -1 And endLine <> -1 And endLine < startLine Then
                errorMsg = errorMsg & " The start line must not be greater than the end line."
            End If
            If startColumn <> -1 And endColumn <> -1 And endColumn < startColumn Then
                errorMsg = errorMsg & " The start column must not be greater than the end column."
            End If
        Else
            errorMsg = "Please enter the position."
        End If
    End If
End Sub

Private Sub CancelButton_Click()
    ok = False
    Hide
End Sub

Private Sub LineButton_Click()
    enableStuff
End Sub

Private Sub OKButton_Click()
    errorMsg = ""
    eval
    If errorMsg = "" Then
        ok = True
        Hide
    Else
        MsgBox errorMsg
    End If
End Sub

Private Sub RegionButton_Click()
    enableStuff
End Sub


Attribute VB_Name = "Menus"
Option Explicit

Public Enum buttonIdentifiers
    buttonFirst = 1
    buttonLast = 13
    
    buttonCompile = 1
    buttonStopCompile = 2
    buttonGoToNextError = 3
    buttonRun = 4
    buttonQuickWatch = 5
    
    buttonGoToCodePosition = 6
    
    buttonEditParamFile = 7
    buttonCreateXML = 8
    buttonShowOutput = 9
    buttonShowErrors = 10
    
    buttonRehighlightDocument = 11
    buttonRehighlightSection = 12
    buttonRehighlightLine = 13
    
    buttonHelp = 14 ' Not part of first..last
End Enum

'Private Sub DeleteBar(barName As String)
'    On Error Resume Next
'    Application.CommandBars(barName).Delete
'End Sub

'Private Sub DeletePopup(popupName As String)
'    On Error Resume Next
'    Application.CommandBars("Menu Bar").Controls(popupName).Delete
'End Sub

'Private Sub DeleteButton(popupName As String, buttonName As String)
'    On Error GoTo ErrorLabel
'    Dim popup As CommandBarPopup
'    Set popup = Application.CommandBars("Menu Bar").Controls(popupName)
'    popup.Controls(buttonName).Delete
'    GoTo ExitLabel
'ErrorLabel:
'    Resume ExitLabel
'ExitLabel:
'End Sub

'Private Sub InsertPopup(popupName As String, position As Integer)
'    On Error GoTo ErrorLabel
'
'    Dim p As CommandBarPopup
'    Set p = Application.CommandBars("Menu Bar").Controls.Add(Type:=msoControlPopup, Temporary:=True, before:=position)
'    p.Caption = popupName
'    GoTo ExitLabel
'
'ErrorLabel:
'    Resume ExitLabel
'ExitLabel:
'End Sub

Private Sub GetButtonInfo(buttonId As Integer, popupName As String, buttonName As String, buttonIndex As Integer, toolbarIndex)
    Select Case buttonId
    Case buttonCompile
        popupName = "&Program"
        buttonName = "&Compile"
        buttonIndex = 1
        toolbarIndex = 1
    Case buttonStopCompile
        popupName = "&Program"
        buttonName = "&Stop Compile"
        buttonIndex = 2
        toolbarIndex = 2
    Case buttonGoToNextError
        popupName = "&Program"
        buttonName = "Go To Next &Error"
        buttonIndex = 3
        toolbarIndex = 3
    Case buttonRun
        popupName = "&Program"
        buttonName = "&Run"
        buttonIndex = 4
        toolbarIndex = 5
    Case buttonQuickWatch
        popupName = "&Program"
        buttonName = "&Quick Watch"
        buttonIndex = 4
        toolbarIndex = 6
    Case buttonGoToCodePosition
        popupName = "Edit"
        buttonName = "&Go To Position in Program..."
        buttonIndex = 0
        toolbarIndex = 0
    Case buttonEditParamFile
        popupName = "&Program"
        buttonName = "Edit &Configuration File"
        buttonIndex = 6
        toolbarIndex = 0
    Case buttonCreateXML
        popupName = "&Program"
        buttonName = "Create &XML"
        buttonIndex = 7
        toolbarIndex = 0
    Case buttonShowOutput
        popupName = "View"
        buttonName = "Compiler &Output"
        buttonIndex = 0
        toolbarIndex = 0
    Case buttonShowErrors
        popupName = "View"
        buttonName = "Compiler &Errors"
        buttonIndex = 0
        toolbarIndex = 4
    Case buttonRehighlightDocument
        popupName = "Format"
        buttonName = "Rehighlight Program (whole document)"
        buttonIndex = 0
        toolbarIndex = 0
    Case buttonRehighlightSection
        popupName = "Format"
        buttonName = "Rehighlight Program (this section)"
        buttonIndex = 0
        toolbarIndex = 0
    Case buttonRehighlightLine
        popupName = "Format"
        buttonName = "Rehighlight Program (this line)"
        buttonIndex = 0
        toolbarIndex = 0
    Case buttonHelp
        popupName = "Help"
        buttonName = "About Spec Explorer Document"
        buttonIndex = 7
        toolbarIndex = 0
    End Select
End Sub

Private Sub InsertButton(buttonId As Integer, action As String, toolHint As String, Optional position As Integer = -1, Optional begingroup As Boolean = False)
    On Error GoTo errorLabel
    
    Dim popupName As String
    Dim buttonName As String
    Dim buttonIndex As Integer
    Dim toolbarIndex As Integer
    GetButtonInfo buttonId, popupName, buttonName, buttonIndex, toolbarIndex
    
    Dim popup As CommandBarPopup
    Set popup = Application.CommandBars("Menu Bar").Controls(popupName)

    Dim b As CommandBarButton
    If position = -1 Then
        Set b = popup.Controls.Add(Type:=msoControlButton, Temporary:=True)
    Else
        Set b = popup.Controls.Add(Type:=msoControlButton, Temporary:=True, before:=position)
    End If
    b.Caption = buttonName
    b.begingroup = begingroup
    b.OnAction = action
    b.TooltipText = toolHint
    
    If toolbarIndex <> 0 Then
        Application.CommandBars("Spec Explorer ToolBar").Controls(toolbarIndex).TooltipText = toolHint
    End If
    GoTo ExitLabel
        
errorLabel:
    Resume ExitLabel
ExitLabel:
End Sub

Public Sub ResetMenus(Optional hideFromWord As Boolean = True)
    SetButtonEnabled buttonCompile, False
    SetButtonEnabled buttonStopCompile, False
    SetButtonEnabled buttonGoToNextError, False
    SetButtonEnabled buttonRun, False
    SetButtonEnabled buttonQuickWatch, False
    SetButtonEnabled buttonGoToCodePosition, False
    SetButtonEnabled buttonShowOutput, False
    SetButtonEnabled buttonShowErrors, False

    SetButtonEnabled buttonRehighlightDocument, False
    SetButtonEnabled buttonRehighlightSection, False
    SetButtonEnabled buttonRehighlightLine, False
    SetButtonEnabled buttonEditParamFile, False
    SetButtonEnabled buttonCreateXML, False
End Sub

Public Sub SetButtonEnabled(buttonId As Integer, Enabled As Boolean)
    On Error GoTo errorLabel
    
    CustomizationHelper.EnterContext
    
    Dim popupName As String
    Dim buttonName As String
    Dim buttonIndex As Integer
    Dim toolbarIndex As Integer
    GetButtonInfo buttonId, popupName, buttonName, buttonIndex, toolbarIndex
    
    If toolbarIndex <> 0 Then
        Dim bar As CommandBar
        Set bar = Application.CommandBars("Spec Explorer ToolBar")
        Dim button As CommandBarButton
        Set button = bar.Controls(toolbarIndex)
        button.Enabled = Enabled
    End If
    
    Dim popup As CommandBarPopup
    Set popup = Application.CommandBars("Menu Bar").Controls(popupName)
    On Error GoTo TryByNumber
    Set button = popup.Controls(buttonName)
    button.Enabled = Enabled
    GoTo ExitLabel
    
TryByNumber:
    On Error GoTo errorLabel
    If buttonIndex < 1 Or buttonIndex > popup.Controls.count Then
        GoTo errorLabel
    End If
    Set button = popup.Controls(buttonIndex)
    button.Enabled = Enabled
    GoTo ExitLabel
    
errorLabel:
    Resume ExitLabel
ExitLabel:
    CustomizationHelper.LeaveContext
End Sub

Public Sub SetButtonCaption(buttonId As Integer, Caption As String)
    On Error GoTo errorLabel
    
    CustomizationHelper.EnterContext
    
    Dim popupName As String
    Dim buttonName As String
    Dim buttonIndex As Integer
    Dim toolbarIndex As Integer
    GetButtonInfo buttonId, popupName, buttonName, buttonIndex, toolbarIndex
    
    Dim popup As CommandBarPopup
    Set popup = Application.CommandBars("Menu Bar").Controls(popupName)
    Dim button As CommandBarButton
    On Error GoTo TryByNumber
    Set button = popup.Controls(buttonName)
    button.Caption = Caption
    GoTo ExitLabel
TryByNumber:
    On Error GoTo errorLabel
    If buttonIndex < 1 Or buttonIndex > popup.Controls.count Then
        GoTo errorLabel
    End If
    Set button = popup.Controls(buttonIndex)
    button.Caption = Caption
errorLabel:
ExitLabel:
    CustomizationHelper.LeaveContext
End Sub

Public Sub Init(Optional hideFromWord As Boolean)
    On Error GoTo errorLabel
    Dim cb As Office.CommandBar
    Set cb = Application.CommandBars("Spec Explorer ToolBar")
    cb.Visible = True
errorLabel:
End Sub

Public Sub Done(Optional hideFromWord As Boolean)
End Sub

Attribute VB_Name = "MySystem"
Option Explicit

Private pathObjectInitialized As Boolean
Private pathObject As Object

Private Declare Function GetFocus Lib "user32" () As Long

Private Declare Function GetEnvironmentVariable Lib "kernel32" Alias "GetEnvironmentVariableA" (ByVal lpName As String, ByVal lpBuffer As String, ByVal nSize As Long) As Long

Private Declare Function GetDesktopWindow Lib "user32" () As Long

Private Declare Function ShellExecute Lib "shell32.dll" _
    Alias "ShellExecuteA" _
   (ByVal hWnd As Long, ByVal lpOperation As String, _
    ByVal lpFile As String, ByVal lpParameters As String, _
    ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
    
Private Declare Function Kernel32GetTempFileName Lib "kernel32" _
    Alias "GetTempFileNameA" (ByVal lpszPath As String, _
    ByVal lpPrefixString As String, ByVal wUnique As Long, _
    ByVal lpTempFileName As String) As Long

Private Declare Function Kernel32GetTempPath Lib "kernel32" _
    Alias "GetTempPathA" (ByVal nBufferLength As Long, _
    ByVal lpBuffer As String) As Long

Private Declare Function OpenProcess _
        Lib "kernel32" _
        (ByVal dwDesiredAccess As Long, _
         ByVal bInheritHandle As Long, _
         ByVal dwProcessId As Long) As Long
Private Declare Function CloseHandle _
        Lib "kernel32" _
        (ByVal hObject As Long) As Long
Private Declare Function WaitForSingleObject _
        Lib "kernel32" _
        (ByVal hHandle As Long, _
         ByVal dwMilliseconds As Long) As Long

Public Const SW_SHOWNORMAL As Long = 1
Public Const SW_SHOWMAXIMIZED As Long = 3
Public Const SW_SHOWDEFAULT As Long = 10

Private Declare Function GetOpenFileName Lib "comdlg32.dll" _
        Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) _
        As Long
        
Private Declare Function GetSaveFileName Lib "comdlg32.dll" _
        Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) _
        As Long

Private Type OPENFILENAME
  lStructSize As Long
  hwndOwner As Long
  hInstance As Long
  lpstrFilter As String
  lpstrCustomFilter As String
  nMaxCustFilter As Long
  nFilterIndex As Long
  lpstrFile As String
  nMaxFile As Long
  lpstrFileTitle As String
  nMaxFileTitle As Long
  lpstrInitialDir As String
  lpstrTitle As String
  Flags As Long
  nFileOffset As Integer
  nFileExtension As Integer
  lpstrDefExt As String
  lCustData As Long
  lpfnHook As Long
  lpTemplateName As String
End Type

Public Const OFN_ALLOWMULTISELECT = &H200
Public Const OFN_CREATEPROMPT = &H2000
Public Const OFN_ENABLEHOOK = &H20
Public Const OFN_ENABLETEMPLATE = &H40
Public Const OFN_ENABLETEMPLATEHANDLE = &H80
Public Const OFN_EXPLORER = &H80000
Public Const OFN_EXTENSIONDIFFERENT = &H400
Public Const OFN_FILEMUSTEXIST = &H1000
Public Const OFN_HIDEREADONLY = &H4
Public Const OFN_LONGNAMES = &H200000
Public Const OFN_NOCHANGEDIR = &H8
Public Const OFN_NODEREFERENCELINKS = &H100000
Public Const OFN_NOLONGNAMES = &H40000
Public Const OFN_NONETWORKBUTTON = &H20000
Public Const OFN_NOREADONLYRETURN = &H8000
Public Const OFN_NOTESTFILECREATE = &H10000
Public Const OFN_NOVALIDATE = &H100
Public Const OFN_OVERWRITEPROMPT = &H2
Public Const OFN_PATHMUSTEXIST = &H800
Public Const OFN_READONLY = &H1
Public Const OFN_SHAREAWARE = &H4000
Public Const OFN_SHAREFALLTHROUGH = 2
Public Const OFN_SHARENOWARN = 1
Public Const OFN_SHAREWARN = 0
Public Const OFN_SHOWHELP = &H10

Public Function GetEnvVar(name As String) As String
    Dim s As String
    Dim i As Integer
    s = String(256, 0)
    i = GetEnvironmentVariable(name, s, 255)
    GetEnvVar = left(s, i)
End Function

Public Function GetTempPath() As String
    Dim s As String
    s = String(260, 0)
    Dim i As Integer
    i = Kernel32GetTempPath(260, s)
    GetTempPath = left(s, i)
End Function

Public Function GetTempFileName(prefix As String) As String
    Dim path As String
    path = GetTempPath()
    Dim wUnique As Long
    wUnique = Int(32000 * Rnd())
    Dim s As String
    s = String(260, 0)
    Dim i As Integer
    i = Kernel32GetTempFileName(path, prefix, wUnique, s)
    GetTempFileName = left(s, i)
End Function

Public Sub RunShellExecute(sTopic As String, sFile As Variant, _
                           sParams As Variant, sDirectory As Variant, _
                           nShowCmd As Long)
   Dim hWndDesk As Long
   Dim success As Long
  
   hWndDesk = GetDesktopWindow()
  
   success = ShellExecute(hWndDesk, sTopic, sFile, sParams, sDirectory, nShowCmd)
End Sub

Public Function ShowOpen(Filter$, Flags&, hWnd) As String
  Dim Buffer$, result&
  Dim ComDlgOpenFileName As OPENFILENAME
  
    Buffer = String$(128, 0)
   
    With ComDlgOpenFileName
      .lStructSize = Len(ComDlgOpenFileName)
       .hwndOwner = hWnd
      .Flags = Flags
      .nFilterIndex = 1
      .nMaxFile = Len(Buffer)
      .lpstrFile = Buffer
      .lpstrFilter = Filter
    End With
    
    result = GetOpenFileName(ComDlgOpenFileName)
    
    If result <> 0 Then
      ShowOpen = left$(ComDlgOpenFileName.lpstrFile, _
                 InStr(ComDlgOpenFileName.lpstrFile, _
                 Chr$(0)) - 1)
    End If
End Function

Public Function ShowSave(Filter$, Flags&, _
                           hWnd, fileName$) As String
                           
  Dim Buffer$, result&
  Dim ComDlgOpenFileName As OPENFILENAME
  
    Buffer = fileName & String$(128 - Len(fileName), 0)
    
    With ComDlgOpenFileName
      .lStructSize = Len(ComDlgOpenFileName)
      .hwndOwner = hWnd
      .Flags = OFN_HIDEREADONLY Or OFN_PATHMUSTEXIST
      .nFilterIndex = 1
      .nMaxFile = Len(Buffer)
      .lpstrFile = Buffer
      .lpstrFilter = Filter
    End With

    result = GetSaveFileName(ComDlgOpenFileName)
    
    If result <> 0 Then
      ShowSave = left$(ComDlgOpenFileName.lpstrFile, _
                 InStr(ComDlgOpenFileName.lpstrFile, _
                 Chr$(0)) - 1)
    End If
End Function

Public Function GetCurrentFocus() As Long
    GetCurrentFocus = GetFocus()
End Function

Public Function CreateGUID() As String
    Dim creator As Object
    Set creator = CreateObject("Microsoft.AsmL.Tools.Word.Connector.GUIDCreator")
    CreateGUID = creator.CreateGUID
End Function

Public Function WaitForTermination(PID As Double) As Boolean
    If PID = 0 Then
        WaitForTermination = False
    Else
        Dim hProcess As Long
        hProcess = OpenProcess(&H100000, True, PID)
        WaitForSingleObject hProcess, -1
        CloseHandle hProcess
        
        WaitForTermination = True
    End If
End Function

Public Function DateTimeLess(a As String, b As String)
    Dim aDate As Date, bDate As Date
    aDate = DateValue(a)
    bDate = DateValue(b)
    
    If aDate < bDate Then
        DateTimeLess = True
    Else
        Dim aTime As Date, bTime As Date
        aTime = TimeValue(a)
        bTime = TimeValue(b)
        
        DateTimeLess = aTime < bTime
    End If
End Function

Public Sub FileDelete(fileName As String)
    On Error Resume Next
    Kill fileName
End Sub

Public Function FileExists(fileName As String) As Boolean
    On Error GoTo errorLabel
    
    Dim name As String
    Dim i As Integer
    
    i = InStrRev(fileName, "\")
    If i = 0 Then
        name = LCase(fileName)
    Else
        name = LCase(Mid(fileName, i + 1, Len(fileName) - i))
    End If
    
    FileExists = LCase(dir(fileName)) = name
    GoTo ExitLabel
errorLabel:
    FileExists = False
    Resume ExitLabel
ExitLabel:
End Function

Private Sub InitPathObject()
    If Not pathObjectInitialized Then
        Set pathObject = CreateObject("Microsoft.AsmL.Tools.Word.Connector.Path")
        pathObjectInitialized = True
    End If
End Sub

Public Function GetInstallationDir() As String
    InitPathObject
    GetInstallationDir = pathObject.GetInstallationDir()
End Function

Public Function GetDocumentationFileName() As String
    InitPathObject
    GetDocumentationFileName = pathObject.GetDocumentationFileName()
End Function

Public Function GetWordGeneratorFileName() As String
    InitPathObject
    GetWordGeneratorFileName = pathObject.GetWordGeneratorFileName()
End Function

Public Function GetWordExtractorFileName() As String
    InitPathObject
    GetWordExtractorFileName = pathObject.GetWordExtractorFileName()
End Function

Public Function GetAsmLKeywordsFileName() As String
    InitPathObject
    GetAsmLKeywordsFileName = pathObject.GetAsmLKeywordsFileName()
End Function

Public Function GetSpecSharpKeywordsFileName() As String
    InitPathObject
    GetSpecSharpKeywordsFileName = pathObject.GetSpecSharpKeywordsFileName()
End Function

Attribute VB_Name = "Parameters"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim items As Collection
Dim lastdate As String

Public Function Load_Success() As Integer
    Load_Success = 0
End Function

Public Function Load_FileDoesNotExist() As Integer
    Load_FileDoesNotExist = 1
End Function
    
Public Function Load_FileExistsButIsUnreadable() As Integer
    Load_FileExistsButIsUnreadable = 2
End Function
    
Public Sub Init(Optional hideFromWord As Boolean = True)
    Set items = New Collection
End Sub

Public Sub Done(Optional hideFromWord As Boolean = True)
    Set items = Nothing
End Sub

Public Function count() As Integer
    count = items.count
End Function

Public Sub Insert(line As String)
    items.Add line
End Sub

Public Function GetOptionValue(key As String) As String
    GetOptionValue = ""
    
    Dim prefix As String
    prefix = "/" & key & "="
    
    Dim s As Variant
    For Each s In items
        Dim i As Integer
        i = InStr(s, prefix)
        
        If i <> 0 Then
            s = Mid(s, i + Len(prefix), Len(s) - i - Len(prefix) + 1)
            i = InStr(s, " ")
            If i <> 0 Then
                s = Mid(s, 1, i - 1)
            End If
            GetOptionValue = s
        End If
    Next
End Function

Public Function Load(fileName As String) As Integer
    Set items = New Collection
    
    On Error GoTo errorLabel
    Open fileName For Input Access Read Shared As #1
    Do While Not EOF(1)
        Dim s As String
        Line Input #1, s
        s = Trim(s)
        If s <> "" Then
            Dim line As String
            line = s & " "
            Dim param As String
            param = ""
            Dim quoted As Boolean
            quoted = False
            Dim i As Integer
            For i = 1 To Len(line)
                Dim c As String
                c = Mid(line, i, 1)
                If c = " " And Not quoted Then
                    Dim param2 As String
                    param2 = Trim(param)
                    If param2 <> "" Then
                        Insert param2
                    End If
                    param = ""
                 ElseIf c = Chr(34) Or c = Chr(148) Then
                     quoted = Not quoted
                 Else
                     param = param & c
                 End If
            Next
        End If
    Loop
    
    Close #1
    Load = Load_Success
    lastdate = FileDateTime(fileName)
    GoTo ExitLabel
    
errorLabel:
    If MySystem.FileExists(fileName) Then
        MsgBox "The configuration file " + fileName + " cannot be read.  (It is probably open in another Word window. Please close it and then try again.)"
        Load = Load_FileExistsButIsUnreadable
    Else
        Load = Load_FileDoesNotExist
    End If
    Resume ExitLabel
ExitLabel:
End Function

Public Sub LoadDefault()
    Set items = New Collection
    
    Insert "/target=exe"
    Insert "/out=$dir\$basename.exe"
    Insert "$filename"
End Sub

Public Function Store(fileName As String) As Boolean
    Store = True
    
    On Error GoTo errorLabel
    Open fileName For Output As #1
    Dim s As Variant
    For Each s In items
        If InStr(s, " ") Then
            Print #1, Chr(34) & s & Chr(34)
        Else
            Print #1, s
        End If
    Next
    Close #1
    lastdate = FileDateTime(fileName)
    Store = True
    GoTo ExitLabel
    
errorLabel:
    Store = False
    Resume ExitLabel
ExitLabel:
End Function

Public Function Check(fileName As String) As Integer
    If FileExists(fileName) And lastdate <> "" Then
        Dim DateOnDisk As String
        DateOnDisk = FileDateTime(fileName)
        
        If MySystem.DateTimeLess(lastdate, DateOnDisk) Then
            Check = Load(fileName)
        Else
            Check = Load_Success
        End If
    Else
        Check = Load_FileDoesNotExist
    End If
End Function
Attribute VB_Name = "Project"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim doc As Document
Dim compiler As Object 'AsmL.compiler
Dim run As Object 'AsmLCompiler.CompilerRun
Dim runAvail As Boolean
Dim errors As Object 'AsmL.CompilerErrors
Dim errorsAvail As Boolean
Dim errorIndex As Integer
Dim lastOutput As String
Dim dummyError As String
Dim params As Parameters
Dim interrupted As Boolean
Dim compform As CompilerForm
Dim compilationSuccessful As Boolean
Dim theWatchForm As WatchForm
Dim theWatchFormAvail As Boolean
Dim watchEnabled As Boolean

Public ShowHints As Boolean
Public ShowWarnings As Boolean
Public ShowErrors As Boolean

Private Function compformAvail() As Boolean
    compformAvail = False
    On Error GoTo errorLabel
    If compform.name = "CompilerForm" Then
        compformAvail = True
    End If
    GoTo ExitLabel
errorLabel:
    Resume ExitLabel
ExitLabel:
End Function

Private Function GetWatchForm() As WatchForm
    If Not theWatchFormAvail Then
        Set theWatchForm = New WatchForm
        theWatchForm.Init
        theWatchFormAvail = True
    End If
    Set GetWatchForm = theWatchForm
End Function

Private Sub ReleaseExecutable()
    If theWatchFormAvail Then
        theWatchForm.ReleaseExecutable
        theWatchForm.Hide
    End If
End Sub

Public Function GetDocument() As Document
    Set GetDocument = doc
End Function

Public Function IsValid() As Boolean
    On Error GoTo errorLabel
    
    IsValid = True
    'IsValid = False
    
    'Dim props As DocumentProperties
    'Set props = GetDocument().CustomDocumentProperties
    
    'Dim prop As DocumentProperty
    'For Each prop In props
    '    If prop.name = "AsmL" Then
    '        IsValid = prop.value <> ""
    '    End If
    'Next
    
    GoTo ExitLabel
errorLabel:
    Resume ExitLabel
ExitLabel:
End Function

Public Function MayClose() As Boolean
    MayClose = True
End Function

Private Function StripExt(ByVal s As String) As String
    Dim i As Integer
    i = InStrRev(s, ".")
    If i <> 0 Then
        s = Mid(s, 1, i - 1)
    End If
    StripExt = s
End Function

Private Function GetExt(ByVal s As String) As String
    Dim i As Integer
    i = InStrRev(s, ".")
    If i <> 0 Then
        s = Mid(s, i)
    End If
    GetExt = s
End Function

Private Function StripDir(ByVal s As String) As String
    Do While InStr(s, "\") <> 0
        s = Mid(s, InStr(s, "\") + 1, Len(s) - InStr(s, "\"))
    Loop
    StripDir = s
End Function

Public Function GetBaseName() As String
    Dim s As String
    s = StripExt(doc.name)
    s = Replace(s, " ", "_")
    GetBaseName = s
End Function

Public Function GetWorkingDirectory() As String
    GetWorkingDirectory = doc.path
End Function

Public Function GetParamFileName() As String
    GetParamFileName = StripExt(doc.fullName) & ".cfg"
End Function

Public Function GetExecutableFileName() As String
    SetCompilerParamEnv (False)
    
    Dim out As String
    out = params.GetOptionValue("out")
    If out = "" Then
        MsgBox "Warning: The option /out=filename is required in the configuration file."
    End If
    
    GetExecutableFileName = Replace(compiler.ApplyEnv(out), Chr(34), "")
End Function

Public Function GetFullName(cheat As Boolean) As String
    Dim s As String
    s = doc.fullName
    If cheat Then
        s = StripExt(s) & ".html"
    End If
    GetFullName = s
End Function

Public Function IsExecutableExistent() As Boolean
    Dim executableFileName As String
    executableFileName = GetExecutableFileName
    
    IsExecutableExistent = MySystem.FileExists(executableFileName)
End Function

Public Function IsExecutableUpToDate() As Boolean
    On Error GoTo errorLabel
    
    Dim executableFileName As String
    executableFileName = GetExecutableFileName
    
    If doc.Saved And IsExecutableExistent Then
        Dim sourceDate As String, destDate As String
        sourceDate = FileDateTime(doc.fullName)
        destDate = FileDateTime(executableFileName)
        
        IsExecutableUpToDate = MySystem.DateTimeLess(sourceDate, destDate)
    Else
        IsExecutableUpToDate = False
    End If
    
    GoTo ExitLabel
errorLabel:
    IsExecutableUpToDate = False
    Resume ExitLabel
ExitLabel:
End Function

'Private Function Read(FileName As String) As String
'    On Error GoTo ErrorLabel
'    Open FileName For Input Access Read Shared As #1
'    Dim s As String
'    Line Input #1, s
'    Read = s
'    Close #1
'
'    GoTo ExitLabel
'ErrorLabel:
'    Read = ""
'    Resume ExitLabel
'ExitLabel:
'End Function

Public Sub Init(aDoc As Document)
    Set doc = aDoc
    Set compiler = CreateObject("Microsoft.AsmL.Tools.Word.Connector.Compiler") 'New AsmL.compiler
    Set run = Nothing
    runAvail = False
    Set errors = Nothing
    errorsAvail = False
    Set params = New Parameters
    Set compform = Nothing
    compilationSuccessful = True
    interrupted = False
    
    Dim load_result As Integer
    load_result = params.Load(GetParamFileName())
    
    If load_result <> params.Load_Success Then
        params.LoadDefault
    End If
    dummyError = ""
    ShowHints = True
    ShowWarnings = True
    ShowErrors = True
    watchEnabled = True
End Sub

Public Sub Done()
    Set doc = Nothing
End Sub

Public Sub HideAllForms()
    If compformAvail Then
        compform.Hide
    End If
    GetWatchForm.Hide
End Sub

Public Sub CreateNewCompForm()
    If compformAvail Then
        compform.Hide
    End If
    
    Set compform = New CompilerForm
    compform.Init Me
End Sub

Private Function FindNextError(e As Integer) As Integer
    If errorsAvail Then
        Dim count As Integer
        count = errors.count
        
        If count > 0 And e <= count Then
            Dim f As Integer
            f = e
            Dim cond As Boolean
            cond = False
            Do Until cond
                f = f + 1
                If f > count Then
                    f = 1
                End If
                
                Dim error As Object 'AsmL.CompilerError
                Set error = errors(f)
                
                If (error.hint And ShowHints) Or _
                    (error.warning And ShowWarnings) Or _
                    (Not error.hint And Not error.warning And ShowErrors) Then
                    FindNextError = f
                    Exit Function
                End If
                
                cond = ((e Mod count) = (f Mod count))
            Loop
        End If
        
        FindNextError = -1
    Else
        FindNextError = -1
    End If
End Function

Private Function GetErrorsAvail() As Boolean
    If errorsAvail Then
        GetErrorsAvail = (FindNextError(0) <> -1)
    Else
        GetErrorsAvail = False
    End If
End Function

Public Sub UpdateMenu()
    Menus.SetButtonEnabled Menus.buttonCompile, True
    Menus.SetButtonEnabled Menus.buttonStopCompile, runAvail
    Menus.SetButtonEnabled Menus.buttonGoToNextError, GetErrorsAvail()
    Menus.SetButtonEnabled Menus.buttonRun, True
    Menus.SetButtonEnabled Menus.buttonShowOutput, compformAvail
    Menus.SetButtonEnabled Menus.buttonShowErrors, compformAvail
    
    Menus.SetButtonEnabled Menus.buttonRehighlightDocument, True
    Menus.SetButtonEnabled Menus.buttonRehighlightSection, True
    Menus.SetButtonEnabled Menus.buttonRehighlightLine, True
    Menus.SetButtonEnabled Menus.buttonEditParamFile, True
    Menus.SetButtonEnabled Menus.buttonCreateXML, True
End Sub

Private Sub CompileWait()
    lastOutput = ""
    Dim s As String
    s = run.ReadOutput
    compform.AppendText s
    lastOutput = lastOutput & s
    compform.Repaint
    DoEvents
    compilationSuccessful = True
    Do Until run.Finished
        If compformAvail Then
            s = run.ReadOutput
            lastOutput = lastOutput & s
            If s <> "" Then
                compform.AppendText s
                compform.Repaint
            End If
            DoEvents
        End If
        compiler.Wait 50
        DoEvents
    Loop
    If compformAvail Then
        s = run.ReadOutput
        compform.AppendText s
        lastOutput = lastOutput & s
        compform.Repaint
    End If
End Sub

Private Function IsSeparator(c As String) As Boolean
    IsSeparator = (c = " ") Or (c = "(") Or (c = ",")
End Function

Public Sub CompileErrors(Optional hideFromWord As Boolean)
    Dim count As Integer
    count = errors.count
    Dim i As Integer
    compform.ClearErrors
    
    For i = 1 To count
        Dim error As Object 'AsmL.CompilerError
        Set error = errors(i)
        
        Dim skip As Boolean
        skip = False
        
        Dim s As String
        s = error.fileName
        Dim j As Integer
        j = InStrRev(s, "\")
        If j > 0 Then
            s = Mid(s, j + 1, Len(s) - j)
        End If
        s = s & "@" & error.nodeNumber & "(" & error.startLine & "," & error.startColumn & "-" & error.endLine & "," & error.endColumn & "): "
        If error.hint Then
            s = s & "Hint: "
            If Not ShowHints Then
                skip = True
            End If
        ElseIf error.warning Then
            s = s & "Warning: "
            If Not ShowWarnings Then
                skip = True
            End If
        Else
            If Not ShowErrors Then
                skip = True
            End If
        End If
        s = s & error.message
        
        Dim prefix As String
        prefix = ""
        
        Do Until s = ""
            
            j = InStr(s, Chr(10))
            If j = 0 Then
                j = InStr(s, Chr(13))
            End If
            
            If (j = 0 And Len(s) > 90) Or (j > 90) Then
                j = 90
                Do Until j = 1 Or IsSeparator(Mid(s, j, 1))
                    j = j - 1
                Loop
            End If
            
            Dim linebreak As Boolean
            linebreak = False
            If j > 0 Then
                If Mid(s, j, 1) < " " Then
                    linebreak = True
                End If
            End If
                
            
            Dim t As String
            If j = 0 Or j = 1 Then
                t = s
                s = ""
            Else
                t = Mid(s, 1, j)
                If j < Len(s) Then
                    s = Mid(s, j + 1, Len(s) - j)
                Else
                    s = ""
                End If
            End If
            
            Do Until Len(t) = 0 Or Mid(t, Len(t), 1) > " "
                t = Mid(t, 1, Len(t) - 1)
            Loop
            
            If compformAvail And Not skip Then
                compform.AppendError i, prefix & t
            End If
        
            If linebreak Then
                prefix = ""
            Else
                prefix = "        "
            End If
        Loop
    Next
    If dummyError <> "" Then
        compform.AppendError 1, dummyError
    End If
    
    UpdateMenu
End Sub

Public Sub SetCompilerParamEnv(cheat As Boolean)
    Call compiler.ClearParamEnv
    Call compiler.SetParamEnv("dir", Chr(34) & GetWorkingDirectory() & Chr(34))
    Call compiler.SetParamEnv("basename", Chr(34) & GetBaseName() & Chr(34))
    Call compiler.SetParamEnv("filename", Chr(34) & GetFullName(cheat) & Chr(34))
End Sub

Public Sub Compile(Optional ignoreHintsAndWarnings As Boolean = False)
    compilationSuccessful = False
    ReleaseExecutable
    
    If Not doc.Saved Then
        On Error GoTo SaveErrorLabel
        doc.Save
        
        GoTo ContinueLabel
SaveErrorLabel:
        MsgBox "You must save the document before you can compile it."
        GoTo ExitLabel
ContinueLabel:
    End If
    On Error GoTo errorLabel
    
    compiler.ParamFile = GetParamFileName()
    compiler.workingDirectory = GetWorkingDirectory()

    Dim resultFileName As String
    resultFileName = GetExecutableFileName()
    MySystem.FileDelete resultFileName
    If MySystem.FileExists(resultFileName) Then
        MsgBox "Error: The output file cannot be overwritten. (Please make sure that no old instance of your program is still running and then try again.)"
        GoTo ExitLabel
    End If
   
    
    Dim paramFileName As String
    paramFileName = GetParamFileName()
    If Not MySystem.FileExists(paramFileName) Then
        params.Store paramFileName
    Else
        If params.Check(paramFileName) = params.Load_FileExistsButIsUnreadable Then
            GoTo ExitLabel
        End If
    End If
    
    System.Cursor = wdCursorWait
    CreateNewCompForm
    dummyError = ""
    compform.Show
    compform.MousePointer = fmMousePointerHourGlass
    compform.Repaint
    DoEvents
    
    Dim cheat As Boolean
    Dim ext As String
    ext = UCase(GetExt(GetFullName(False)))
    cheat = ext = ".DOC" Or ext = ".DOCX"
    If cheat Then
        On Error GoTo HtmlErrorLabel
        Dim htmlDoc As Document
        Set htmlDoc = Documents.Add(Visible:=False)
        htmlDoc.Content.InsertFile fileName:=GetFullName(False)
        htmlDoc.SaveAs fileName:=GetFullName(True), FileFormat:=wdFormatHTML, AddToRecentFiles:=False
        htmlDoc.Close
        doc.Saved = True ' don't know why this gets reset here
        GoTo NoHtmlError

HtmlErrorLabel:
        MsgBox "The document could not be saved as an HTML file. Please make sure that this file does not conflict with an already existing HTML file in the same directory."
        GoTo ExitLabel
        
NoHtmlError:
        On Error GoTo errorLabel
    End If
    
    SetCompilerParamEnv cheat
    
    Set run = compiler.run
    
    runAvail = True
    
    
    interrupted = False
    
    UpdateMenu
    CompileWait
    Set errors = compiler.errors
    errorsAvail = True
    
    If cheat Then
        Kill GetFullName(True)
    End If
    
    If Not MySystem.FileExists(resultFileName) Then
        compilationSuccessful = False
    End If
    
    If interrupted Then
        If compformAvail Then
            compform.AppendText "Interrupted."
        End If
        dummyError = "Compilation interrupted."
        compilationSuccessful = False
    ElseIf compilationSuccessful Then
        dummyError = "Compilation successful. No Errors occurred."
    ElseIf Not compilationSuccessful And errors.count = 0 Then
        dummyError = "Some errors occurred. Please look at the Output tab."
    End If
    
    CompileErrors
    If compformAvail Then
        compform.MultiPage1.Value = 1
    End If
    
    If MySystem.FileExists(resultFileName) And Not compilationSuccessful Then
        Kill resultFileName
    End If
    
    Set run = Nothing
    runAvail = False
    UpdateMenu
    If compformAvail Then
        compform.MousePointer = fmMousePointerDefault
    End If
    
    Dim e As Integer
    e = FindNextError(0)
    If e <> -1 And Not (compilationSuccessful And ignoreHintsAndWarnings) Then
        GoToError e
    End If
    System.Cursor = wdCursorNormal
    
    GoTo ExitLabel
errorLabel:
    compform.AppendText "An error occurred during the compilation:" & Chr(13)
    compform.AppendText Err.Description & Chr(13)
    
    If compformAvail Then
        compform.MousePointer = fmMousePointerDefault
    End If
    System.Cursor = wdCursorNormal
    GoTo ExitLabel
ExitLabel:
End Sub

Public Sub StopCompile()
    If runAvail Then
        interrupted = True
        compilationSuccessful = False
        run.Break
    End If
End Sub

Public Sub GoToNextError()
    If GetErrorsAvail() Then
        errorIndex = FindNextError(errorIndex)
        If errorIndex <> -1 Then
            GoToError errorIndex
        End If
    End If
End Sub

Private Function EndOfLine(ByVal start As Integer, ByVal s As String) As Integer
    Dim i As Integer
    Dim j As Integer
    i = InStr(start, s, Chr(11))
    j = InStr(start, s, Chr(13))
    If (i = 0) Or ((j > 0) And (i > j)) Then
        i = j
    End If
    EndOfLine = i
End Function

Public Sub GoToLocation(ByVal nodeNumber As Long, ByVal startLine As Long, ByVal startColumn As Long, ByVal endLine As Long, ByVal endColumn As Long)

    Dim para As Paragraph
    Dim laststyle As String
    laststyle = ""
    Dim startOfs As Long
    Dim endOfs As Long
    For Each para In doc.Paragraphs
        On Error GoTo LocalErrorLabel
        Dim style As String
        style = UCase(para.style)
        If style = "ASML" Or style = "A#" Or style = "SPEC#" Then
            If laststyle <> style Then
                nodeNumber = nodeNumber - 1
                laststyle = style
            End If
            If nodeNumber <= 0 Then
                startLine = startLine - 1
                endLine = endLine - 1
                If startLine <= 0 Then
                    If startColumn = -1 And endColumn = -1 Then
                        startOfs = para.range.start
                        endOfs = para.range.End
                    Else
                        If startLine = 0 And endLine = 0 Then
                            ' start and end in this line
                            startOfs = para.range.start + startColumn
                            endOfs = para.range.start + endColumn + 1
                        ElseIf startLine = 0 And endLine > 0 Then
                            ' start
                            startOfs = para.range.start + startColumn
                        ElseIf startLine < 0 And endLine > 0 Then
                            ' middle
                        ElseIf startLine < 0 And endLine = 0 Then
                            ' end
                            endOfs = para.range.start + endColumn + 1
                        End If
                    End If
                    If endLine = 0 Then
                        Dim r As range
                        Set r = doc.range(startOfs, endOfs)
                        r.Select
                        GoTo EndLabel
                    End If
                End If
            End If
        Else
            laststyle = style
        End If
        GoTo ContinueLabel
LocalErrorLabel:
        Resume ContinueLabel
ContinueLabel:
    Next
    GoTo EndLabel
errorLabel:
    MsgBox "Position could not be found."
EndLabel:
End Sub

Sub DisplayError(warning As Boolean, message As String)
    StatusBar = message
End Sub

Public Sub GoToError(index As Integer)
    errorIndex = index
    If index > errors.count Then
        GoTo errorLabel
    End If
    
    System.Cursor = wdCursorWait
    
    Dim error As Object 'AsmL.CompilerError
    Set error = errors(index)
    
    If compformAvail Then
        compform.ShowError index
    End If
    
    Dim found As Boolean
    found = False
    
    If UCase(StripDir(doc.fullName)) = UCase(StripDir(error.fileName)) Then
        DisplayError error.warning, (error.message & "...")
        If error.startChar = -1 Then
            GoToLocation error.nodeNumber, error.startLine, error.startColumn, error.endLine, error.endColumn
        End If
        DisplayError error.warning, error.message
        found = True
    End If
    
    If Not found Then
        MsgBox "I could not find the location of this error in this document."
    End If
    
ExitLabel:
errorLabel:
    System.Cursor = wdCursorNormal
End Sub

Public Sub RunSpec()
    If Not IsExecutableExistent Then
        Compile
        
        If Not compilationSuccessful Then
            GoTo errorLabel
        End If
        
        If Not IsExecutableUpToDate Then
            GoTo ExitLabel
        End If
    ElseIf Not IsExecutableUpToDate Then
        Dim form As RunForm
        Set form = New RunForm
        form.Init (False)
        form.Show
        Select Case form.GetResult
        Case -1
            GoTo ExitLabel
        Case 0
            Compile
            
            If Not compilationSuccessful Then
                GoTo errorLabel
            End If
            
            If Not IsExecutableUpToDate Then
                GoTo ExitLabel
            End If
        Case 1
            ' do nothing
        End Select
    End If
    
    Dim cmdLine As String
    cmdLine = GetExecutableFileName()
    
    If cmdLine = "" Then
        GoTo errorLabel
    End If
    
    On Error GoTo errorLabel
    
    If params.GetOptionValue("target") <> Constants.tWinexe Then
        cmdLine = Chr(34) & cmdLine & Chr(34)
        
        Dim cmdFile As String
        cmdFile = GetWorkingDirectory & "\" & GetBaseName() & ".cmd"
        Open cmdFile For Output As #1
        Print #1, "@echo off"
        Print #1, cmdLine
        Print #1, "pause"
        Close #1
        
        Shell PathName:=cmdFile, WindowStyle:=vbNormalFocus
    Else
        Shell PathName:=cmdLine, WindowStyle:=vbNormalFocus
    End If
        
    GoTo ExitLabel
errorLabel:
    MsgBox "An error has occurred, your specification could not be run."
ExitLabel:
End Sub

Public Sub GoToCodePosition()
    Dim form As GotoForm
    Set form = New GotoForm
    form.Init
    form.Show
    Dim nodeNumber As Integer
    Dim startLine As Integer
    Dim startColumn As Integer
    Dim endLine As Integer
    Dim endColumn As Integer
    If form.GetResult(nodeNumber, startLine, startColumn, endLine, endColumn) Then
        HideAllForms
        
        GoToLocation nodeNumber, startLine, startColumn, endLine, endColumn
    End If
End Sub

Public Sub QuickWatch()
    If watchEnabled Then
        If Not IsExecutableExistent Then
            Compile True
            
            If Not compilationSuccessful Then
                GoTo errorLabel
            End If
            
            If Not IsExecutableUpToDate Then
                GoTo ExitLabel
            End If
        ElseIf Not IsExecutableUpToDate Then
            HideAllForms
            
            Dim form As RunForm
            Set form = New RunForm
            form.Init (True)
            form.Show
            Select Case form.GetResult
            Case -1
                GoTo ExitLabel
            Case 0
                Compile True
                
                If Not compilationSuccessful Then
                    GoTo errorLabel
                End If
                
                If Not IsExecutableUpToDate Then
                    GoTo ExitLabel
                End If
            Case 1
                ' do nothing
            End Select
        End If
        
        HideAllForms
        
        Dim myWatchForm As WatchForm
        Set myWatchForm = GetWatchForm
        
        myWatchForm.SetWorkingDirectory GetWorkingDirectory()
        myWatchForm.SetExecutable GetExecutableFileName()
        
        If selection.End - selection.start > 0 Then
            Dim expression As String
            expression = selection.text
            Dim result As String
            result = myWatchForm.Evaluate(expression)
            
            If Not myWatchForm.Visible Then
                myWatchForm.Show ' Instead, it would be nice to show a tool tip. How?
            End If
        Else
            myWatchForm.Show
            myWatchForm.SetFocus
        End If
    Else
        MsgBox "The QuickWatch is no longer supported."
    End If
    GoTo ExitLabel
    
errorLabel:
    MsgBox "An error has occurred."
ExitLabel:
End Sub

Public Sub EditParameterFile()
    On Error GoTo errorLabel
    params.Store GetParamFileName()
    Documents.Open fileName:=GetParamFileName(), ConfirmConversions:=False, Format:=wdOpenFormatText, NoEncodingDialog:=True, Visible:=True
    
    GoTo ExitLabel
errorLabel:
    MsgBox "Cannot open " & GetParamFileName() & "."
    Resume ExitLabel
ExitLabel:
End Sub

Private Function internalCreateXML(ByVal fileName As String, ByVal args As String) As Boolean
    If fileName <> "" Then
        If InStr(fileName, ".") = 0 Then
            fileName = fileName + ".specs"
        End If
        If Not doc.Saved Then
            doc.Save
        End If
        Dim cmdLine As String
        cmdLine = Chr(34) & MySystem.GetWordExtractorFileName & Chr(34) & _
            " " & args & " " & Chr(34) & doc.fullName & Chr(34) & " " & Chr(34) & fileName & Chr(34)
        
        On Error GoTo errorLabel
        WaitForTermination Shell(PathName:=cmdLine, WindowStyle:=vbNormalFocus)
        
        internalCreateXML = True
        GoTo ExitLabel
errorLabel:
        MsgBox "An error has occurred, your specification could not be converted to XML."
        internalCreateXML = False
    Else
        internalCreateXML = False
    End If
ExitLabel:

End Function

Public Sub CreateXML()
    Dim Filter As String, Flags As Long, fileName As String
  
    Flags = OFN_FILEMUSTEXIST Or OFN_HIDEREADONLY Or OFN_PATHMUSTEXIST
            
    Filter = "Spec# files (*.specs)" & Chr$(0) & "*.specs" & Chr$(0) & _
             "AsmL files (*.asml)" & Chr$(0) & "*.asml" & Chr$(0) & _
             "XML files (*.xml)" & Chr$(0) & "*.xml" & Chr$(0) & _
             "All files (*.*)" & Chr$(0) & "*.*" & Chr$(0) & _
             Chr$(0)
    
    fileName = MySystem.ShowSave(Filter, Flags, MySystem.GetCurrentFocus(), StripExt(doc.name))
    internalCreateXML fileName, "-v -i -p"
End Sub

Public Sub ViewCompilerOutput()
    If Not compformAvail Then
        CreateNewCompForm
        compform.AppendText lastOutput
        CompileErrors
    End If
    
    compform.MultiPage1.Value = 0
    compform.Show
End Sub

Public Sub ViewCompilerErrors()
    If Not compformAvail Then
        CreateNewCompForm
        compform.AppendText lastOutput
        CompileErrors
    End If
    
    compform.MultiPage1.Value = 1
    compform.Show
End Sub

Public Sub Activate()
    UpdateMenu
End Sub






Attribute VB_Name = "ProjectCollection"
Option Explicit

Dim projects As Collection
Dim initialized As Boolean

Public Sub Init(Optional hideFromWord As Boolean)
    If Not initialized Then
        Set projects = New Collection
        initialized = True
    End If
End Sub

Public Function FindProject(doc As Document) As project
    On Error GoTo LookUpError
    Dim q As project
    
    ' 1. Try straight-forward lookup
    Set q = projects(doc)
    If Not q.IsValid Then
        GoTo AddProject
    End If
   
    Set FindProject = q
    GoTo ExitLabel
    
LookUpError:
    Resume LookHarder
LookHarder:
    
    ' 2. Try looking harder
    Dim i As Integer
    For i = 1 To projects.count
        On Error GoTo ItemError
        Set q = projects(i)
        If q.GetDocument() = doc Then
            If Not q.IsValid Then
                GoTo AddProject
            End If
            Set FindProject = q
            GoTo ExitLabel
        End If
        GoTo TryNext
ItemError:
        Resume TryNext
TryNext:
    Next
    
    GoTo AddProject
    
LookHarderError:
    Resume AddProject
AddProject:
    ' 3. Add project
    
    Dim p As project
    Set p = New project
    p.Init doc
    projects.Add Item:=p, key:=doc
    Set FindProject = p
    
ExitLabel:
End Function
Attribute VB_Name = "RunForm"
Attribute VB_Base = "0{F13F05C5-2531-47A1-B74B-FCE2A45F3F10}{A308590B-F99F-4575-96A7-C5D110C4B7C8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private result As Integer

Public Sub Init(watch As Boolean)
    OptionButton1.Value = True
    result = -1
    If watch Then
        OptionButton1.Caption = "Recompile and watch expression"
        OptionButton2.Caption = "Ignore the changes and use the old executable"
    End If
End Sub

Public Function GetResult() As Integer
    GetResult = result
End Function

Private Sub CommandButton1_Click()
    If OptionButton1.Value Then
        result = 0
    ElseIf OptionButton2.Value Then
        result = 1
    End If
    Hide
End Sub

Private Sub CommandButton2_Click()
    result = -1
    Hide
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Dim initialized As Boolean
Dim captionItems As Collection

Public Sub Initialize(Optional hideFromWord As Boolean = True)
    On Error GoTo errorLabel
    If Not initialized Then
        initialized = True
        
        Menus.Init
        Constants.Init
        EditingHElp.Init
        ProjectCollection.Init
        
        On Error Resume Next
        CheckActiveWindow
    End If
errorLabel:
End Sub
    
Private Sub Finalize()
    EditingHElp.Done
    Menus.Done
    initialized = False
End Sub

Private Function GetActiveProject() As project
    Initialize
    Dim p As project
    Set GetActiveProject = ProjectCollection.FindProject(ActiveDocument)
End Function

Sub CheckActiveWindow()
Attribute CheckActiveWindow.VB_Description = "Spec Explorer Document/CheckActiveWindow"
Attribute CheckActiveWindow.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.CheckActiveWindow"
    Application.ScreenUpdating = False
    On Error GoTo errorLabel
    
    GetActiveProject().Activate
    
errorLabel:
    Application.ScreenUpdating = True
End Sub

Sub Compile()
Attribute Compile.VB_Description = "Spec Explorer Document/Compile:Compiles the embedded program."
Attribute Compile.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.Compile"
    GetActiveProject().Compile
End Sub

Sub QuickWatch()
Attribute QuickWatch.VB_Description = "Spec Explorer Document/Quick Watch"
Attribute QuickWatch.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.QuickWatch"
    GetActiveProject().QuickWatch
End Sub

Sub GoToCodePosition()
Attribute GoToCodePosition.VB_Description = "Spec Explorer Document/GoToCodePosition"
Attribute GoToCodePosition.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.GoToCodePosition"
    GetActiveProject().GoToCodePosition
End Sub

Sub StopCompile()
Attribute StopCompile.VB_Description = "Spec Explorer Document/StopCompile: You can stop the compilation process."
Attribute StopCompile.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.StopCompile"
    GetActiveProject().StopCompile
End Sub

Sub GoToNextError()
Attribute GoToNextError.VB_Description = "Spec Explorer Document/GoToNextError: If any error was detected in the last compilation, this macro selects the next error in the document."
Attribute GoToNextError.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.GoToNextError"
    GetActiveProject().GoToNextError
End Sub

Sub RunSpec()
Attribute RunSpec.VB_Description = "Spec Explorer Document/RunSpec: If the last compilation was successful and your project type is Console application or Windows application, then you can execute your program with this macro."
Attribute RunSpec.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.RunSpec"
    GetActiveProject().RunSpec
End Sub

Sub EditParameterFile()
Attribute EditParameterFile.VB_Description = "Spec Explorer Document/EditConfigurationFile: This lets the user edit the configuration file that contains all important options for the compiler."
Attribute EditParameterFile.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.EditParameterFile"
    GetActiveProject().EditParameterFile
End Sub

Sub CreateXML()
Attribute CreateXML.VB_Description = "Spec Explorer Document/CreateXML: Creates an XML document from the current Spec Explorer document."
Attribute CreateXML.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.CreateXML"
    GetActiveProject().CreateXML
End Sub

Sub ViewCompilerOutput()
Attribute ViewCompilerOutput.VB_Description = "Spec Explorer Document/ViewCompilerOutput: View the compiler output."
Attribute ViewCompilerOutput.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.ViewCompilerOutput"
    GetActiveProject().ViewCompilerOutput
End Sub

Sub ViewCompilerErrors()
Attribute ViewCompilerErrors.VB_Description = "Spec Explorer Document/ViewCompilerErrors: View all available compiler errors."
Attribute ViewCompilerErrors.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.ViewCompilerErrors"
    GetActiveProject().ViewCompilerErrors
End Sub

Sub SpecsHelp()
Attribute SpecsHelp.VB_Description = "Spec Explorer Document/Help: View the help file for the Spec Explorer Word AddIn."
Attribute SpecsHelp.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.SpecsHelp"
    Dim s As String
    s = GetDocumentationFileName()
    RunShellExecute "Open", s, 0&, 0&, SW_SHOWNORMAL
End Sub

Sub RehighlightDocument()
Attribute RehighlightDocument.VB_Description = "Spec Explorer Document"
Attribute RehighlightDocument.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.RehighlightDocument"
    EditingHElp.Init
    EditingHElp.RehighlightDocument
End Sub

Sub RehighlightSection()
Attribute RehighlightSection.VB_Description = "Spec Explorer Document"
Attribute RehighlightSection.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.RehighlightSection"
    EditingHElp.Init
    EditingHElp.RehighlightSection
End Sub

Sub RehighlightLine()
Attribute RehighlightLine.VB_Description = "Spec Explorer Document"
Attribute RehighlightLine.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.RehighlightLine"
    EditingHElp.Init
    EditingHElp.RehighlightLine
End Sub

Sub MagicSpacebar()
Attribute MagicSpacebar.VB_Description = "Spec Explorer Document"
Attribute MagicSpacebar.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicSpacebar"
    EditingHElp.Init
    EditingHElp.MagicSpacebar
End Sub

Sub MagicTab()
Attribute MagicTab.VB_Description = "Spec Explorer Document"
Attribute MagicTab.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicTab"
    EditingHElp.Init
    EditingHElp.MagicTab
End Sub

Sub MagicShiftTab()
Attribute MagicShiftTab.VB_Description = "Spec Explorer Document"
Attribute MagicShiftTab.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicShiftTab"
    EditingHElp.Init
    EditingHElp.MagicShiftTab
End Sub

Sub MagicReturn()
Attribute MagicReturn.VB_Description = "Spec Explorer Document"
Attribute MagicReturn.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicReturn"
    EditingHElp.Init
    EditingHElp.MagicReturn
End Sub

Sub MagicBackspace()
Attribute MagicBackspace.VB_Description = "Spec Explorer Document"
Attribute MagicBackspace.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicBackspace"
    EditingHElp.Init
    EditingHElp.MagicBackspace
End Sub

Sub MagicDelete()
Attribute MagicDelete.VB_Description = "Spec Explorer Document"
Attribute MagicDelete.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicDelete"
    EditingHElp.Init
    EditingHElp.MagicDelete
End Sub

Sub MagicPeriod()
Attribute MagicPeriod.VB_Description = "Spec Explorer Document"
Attribute MagicPeriod.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicPeriod"
    EditingHElp.Init
    EditingHElp.MagicPeriod
End Sub

Sub MagicComma()
Attribute MagicComma.VB_Description = "Spec Explorer Document"
Attribute MagicComma.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicComma"
    EditingHElp.Init
    EditingHElp.MagicComma
End Sub

Sub MagicSemicolon()
Attribute MagicSemicolon.VB_Description = "Spec Explorer Document"
Attribute MagicSemicolon.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicSemicolon"
    EditingHElp.Init
    EditingHElp.MagicSemicolon
End Sub

Sub MagicColon()
Attribute MagicColon.VB_Description = "Spec Explorer Document"
Attribute MagicColon.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicColon"
    EditingHElp.Init
    EditingHElp.MagicColon
End Sub

Sub MagicCloseParenthesis()
Attribute MagicCloseParenthesis.VB_Description = "Spec Explorer Document"
Attribute MagicCloseParenthesis.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicCloseParenthesis"
    EditingHElp.Init
    EditingHElp.MagicCloseParenthesis
End Sub

Sub MagicCloseSquareBrace()
Attribute MagicCloseSquareBrace.VB_Description = "Spec Explorer Document"
Attribute MagicCloseSquareBrace.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicCloseSquareBrace"
    EditingHElp.Init
    EditingHElp.MagicCloseSquareBrace
End Sub

Sub MagicCloseCurlyBrace()
Attribute MagicCloseCurlyBrace.VB_Description = "Spec Explorer Document"
Attribute MagicCloseCurlyBrace.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicCloseCurlyBrace"
    EditingHElp.Init
    EditingHElp.MagicCloseCurlyBrace
End Sub

Sub MagicCloseAngleBrace()
Attribute MagicCloseAngleBrace.VB_Description = "Spec Explorer Document"
Attribute MagicCloseAngleBrace.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicCloseAngleBrace"
    EditingHElp.Init
    EditingHElp.MagicCloseAngleBrace
End Sub

Sub MagicBraceJump()
Attribute MagicBraceJump.VB_Description = "Spec Explorer Document"
Attribute MagicBraceJump.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicBraceJump"
    EditingHElp.Init
    EditingHElp.MagicBraceJump
End Sub

Sub MagicDoubleQuote()
Attribute MagicDoubleQuote.VB_Description = "Spec Explorer Document"
Attribute MagicDoubleQuote.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicDoubleQuote"
    EditingHElp.Init
    EditingHElp.MagicDoubleQuote
End Sub

Sub MagicSingleQuote()
Attribute MagicSingleQuote.VB_Description = "Spec Explorer Document"
Attribute MagicSingleQuote.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicSingleQuote"
    EditingHElp.Init
    EditingHElp.MagicSingleQuote
End Sub

Sub MagicSlash()
Attribute MagicSlash.VB_Description = "Spec Explorer Document"
Attribute MagicSlash.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicSlash"
    EditingHElp.Init
    EditingHElp.MagicSlash
End Sub

Sub MagicHome()
Attribute MagicHome.VB_Description = "Spec Explorer Document"
Attribute MagicHome.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicHome"
    EditingHElp.Init
    EditingHElp.MagicHome
End Sub

Sub MagicEnd()
Attribute MagicEnd.VB_Description = "Spec Explorer Document"
Attribute MagicEnd.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicEnd"
    EditingHElp.Init
    EditingHElp.MagicEnd
End Sub

Sub MagicRun()
Attribute MagicRun.VB_Description = "Spec Explorer Document"
Attribute MagicRun.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicRun"
    Application.Caption = "run"
End Sub

Sub MagicBreakpoint()
Attribute MagicBreakpoint.VB_Description = "Spec Explorer Document"
Attribute MagicBreakpoint.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicBreakpoint"
    Application.Caption = "breakpoint"
End Sub

Sub MagicStepOver()
Attribute MagicStepOver.VB_Description = "Spec Explorer Document"
Attribute MagicStepOver.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicStepOver"
    Application.Caption = "step over"
End Sub

Sub MagicStepInto()
Attribute MagicStepInto.VB_Description = "Spec Explorer Document"
Attribute MagicStepInto.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicStepInto"
    Application.Caption = "step into"
End Sub

Sub MagicStepOut()
Attribute MagicStepOut.VB_Description = "Spec Explorer Document"
Attribute MagicStepOut.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.MagicStepOut"
    Application.Caption = "step out"
End Sub

Public Sub InternalGoToLocation(nodeNumber As Long, startLine As Long, startColumn As Long, endLine As Long, endColumn As Long)
    Initialize
    GetActiveProject().GoToLocation nodeNumber, startLine, startColumn, endLine, endColumn
End Sub

Private Sub Document_New()
    Initialize
    DocumentFactory.CreateNewDocument
End Sub

Private Sub Document_Open()
    Initialize
End Sub

Private Sub Document_Close()
End Sub

Sub CopyStyles()
Attribute CopyStyles.VB_Description = "Spec Explorer Document/CopyStyles"
Attribute CopyStyles.VB_ProcData.VB_Invoke_Func = "SpecExplorerDocument.ThisDocument.CopyStyles"
    Dim Filter As String, Flags As Long, fileName As String
    Flags = OFN_FILEMUSTEXIST Or OFN_HIDEREADONLY Or OFN_PATHMUSTEXIST
            
    Filter = "Word Template (*.dot)" & Chr$(0) & "*.dot" & Chr$(0) & _
             "All files (*.*)" & Chr$(0) & "*.*" & Chr$(0) & _
             Chr$(0)
    
    fileName = MySystem.ShowOpen(Filter, Flags, MySystem.GetCurrentFocus())
    If fileName <> "" Then
        If InStr(fileName, ".") = 0 Then
            fileName = fileName + ".dot"
        End If
        ThisDocument.CopyStylesFromTemplate template:=fileName
    End If
End Sub
Attribute VB_Name = "WatchForm"
Attribute VB_Base = "0{58912300-F0B9-49ED-992B-E641E8143D31}{FDDAE8B7-108A-4656-BF7F-135B2C8E76D6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private hasInterpreter As Boolean
Private interpreter As Object
Private workingDirectory As String
Private executable As String
Private lastOutput As String
Private lastError As Boolean
Private Output As String

Public Sub Init()
    ScopeTextBox.text = "Application"
    ExpressionTextBox.SetFocus
End Sub

Private Function AcquireInterpreter() As Boolean
    If Not hasInterpreter Then
        System.Cursor = wdCursorWait
        Set interpreter = CreateObject("Microsoft.AsmL.Tools.Word.Connector.Interpreter")
        If workingDirectory <> "" Then
            interpreter.SetWorkingDirectory workingDirectory
        End If
        interpreter.AddReference executable
        interpreter.Startup
        PrintOutput
        If interpreter.GetLastError Then
            AcquireInterpreter = False
        Else
            interpreter.SetScope ScopeTextBox.text
            PrintOutput
        
            AcquireInterpreter = True
            hasInterpreter = True
        End If
        System.Cursor = wdCursorNormal
    Else
        AcquireInterpreter = True
    End If
End Function

Public Function GetLastOutput() As String
    GetLastOutput = lastOutput
End Function

Public Function GetLastError() As Boolean
    GetLastError = lastError
End Function

Private Sub PrintOutput()
    If hasInterpreter Then
        lastOutput = interpreter.GetLastOutput()
        lastError = interpreter.GetLastError()
        If lastOutput <> "" Then
            If Output <> "" Then
                If Mid(Output, Len(Output), 1) <> Chr(13) Then
                    Output = Output & Chr(13)
                End If
            End If
            If lastError Then
                ExpressionTextBox.BackColor = RGB(255, 224, 224)
            Else
                ExpressionTextBox.BackColor = RGB(255, 255, 255)
            End If
            Output = Output & lastOutput & Chr(13)
            
            ResultTextBox.text = Output
            ResultTextBox.SelLength = 0
            ResultTextBox.SelStart = Len(Output)
        End If
    End If
End Sub

Private Sub KillOnTimeOut()
    If hasInterpreter Then
        lastOutput = interpreter.GetLastOutput()
        lastError = interpreter.GetLastError()
        If lastError And InStr(lastOutput, "Timeout") Then
            ReleaseInterpreter
        End If
    End If
End Sub

Private Sub ReleaseInterpreter()
    If hasInterpreter Then
        interpreter.Kill
        Set interpreter = Nothing
        hasInterpreter = False
    End If
End Sub

Public Sub ReleaseExecutable()
    ReleaseInterpreter
End Sub

Public Sub SetWorkingDirectory(d As String)
    If workingDirectory <> d Then
        ReleaseInterpreter
        workingDirectory = d
    End If
End Sub

Public Sub SetExecutable(e As String)
    If executable <> e Then
        ReleaseInterpreter
        executable = e
    End If
End Sub

Public Sub SetScope(scope As String)
    If ScopeTextBox.text <> scope Then
        ScopeTextBox.text = scope
        SetScopeButton_Click
    End If
End Sub

Public Function Evaluate(expr As String) As String
    ExpressionTextBox.text = expr
    EvaluateButton_Click
    Evaluate = GetLastOutput()
End Function

Public Sub SetFocus()
    ExpressionTextBox.SetFocus
End Sub

Private Sub CloseButton_Click()
    'ReleaseExecutable
    Hide
End Sub

Private Sub ExpressionTextBox_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = vbKeyReturn Then
        EvaluateButton_Click
    End If
End Sub

Private Sub SetScopeButton_Click()
    If AcquireInterpreter Then
        interpreter.SetScope ScopeTextBox.text
    End If
    PrintOutput
    ResultTextBox.SetFocus
    ExpressionTextBox.SetFocus
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Hide
    Cancel = -1
End Sub

Private Sub EvaluateButton_Click()
    If AcquireInterpreter Then
        interpreter.Evaluate ExpressionTextBox.text
    End If
    PrintOutput
    KillOnTimeOut
    ResultTextBox.SetFocus
    ExpressionTextBox.SetFocus
End Sub


' InQuest injected base64 decoded content
' wRzW
' SzjE
' (^r@
' *'~(.

INQUEST-PP=macro
