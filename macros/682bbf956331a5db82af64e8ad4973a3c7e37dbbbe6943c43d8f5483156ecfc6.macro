Attribute VB_Name = "FormMyMsgBox"
Attribute VB_Base = "0{6474CE34-DB87-4E55-9FC5-915151A62C74}{42F902CF-123D-41B1-A1D4-A7E1DB4C401C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Public EmailSubj As String
Public HomePageUrl As String
Public lBut As Long
Public Xpos As Long
Public Ypos As Long

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub OK_Bt_Click()
    BotAcionado = 1
    Hide
End Sub
Private Sub Cancel_Bt_Click()
    BotAcionado = 2
    Hide
End Sub

Private Sub Ignore_Bt_Click()
    BotAcionado = 3
    Hide
End Sub

Private Sub UserForm_Activate()
    Dim CountLines As Long
    Dim Lins
    Dim l As Long

    With Alert_Tb
        .Width = 284
        'Lins = Split(.Text, vbCrLf)
        Lins = MySplit(.Text, vbCrLf)
        For l = 0 To UBound(Lins)
            CountLines = CountLines + 1 + Int(Len(Lins(l)) / 75)
        Next
        .Height = (1 + CountLines) * 12
        If .Height > 16 * 12 Then
            .Height = 15 * 12
            .SpecialEffect = fmSpecialEffectSunken
            .SetFocus
            .SelStart = 0
        End If
    End With

    Icon_Lb.Caption = IIf(lBut <> 1, "?", "i")
    Cancel_Bt.Visible = lBut <> 1
    Ignore_Bt.Visible = lBut = 3

    OK_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "Sim", "Yes"), "OK")
    Cancel_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "N|fffd|o", "No"), IIf(IsPortg, "Cancelar", "Cancel"))
    Ignore_Bt.Caption = IIf(IsPortg, "Ignorar", "Ignore")

    OK_Bt.Top = Alert_Tb.Top + Alert_Tb.Height + 5
    Cancel_Bt.Top = OK_Bt.Top
    Ignore_Bt.Top = OK_Bt.Top
    HomePage_Lb.Top = OK_Bt.Top + 7.5
    Email_Lb.Top = HomePage_Lb.Top

    Email_Lb.Left = Width - Email_Lb.Width - (Width - InsideWidth) - 4    'Email_Lb.Left = Width - Email_Lb.Width - 8    'Em COM add-in |fffd| preciso transformar width e height em Twips
    Height = HomePage_Lb.Top + OK_Bt.Height + (Height - InsideHeight) - 2    'Height = HomePage_Lb.Top + OK_Bt.Height + (Height - InsideHeight - (Width - InsideWidth) / 2) + 2    'Entre parentese: altura da barra de t|fffd|tulo(caption)

    If lBut = 1 Then OK_Bt.Left = 135
    If lBut = 2 Then OK_Bt.Left = 90: Cancel_Bt.Left = 180
    If Xpos <> 0 Then Left = Xpos
    If Ypos <> 0 Then Top = Ypos
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = IIf(Cancel_Bt.Visible, 2, 1)
End Sub
Attribute VB_Name = "Mod1ConstByUtility"
Option Explicit

'==== Utility Const List. To other Office app, change Word and Wd is sufficent. To other utility, change Calendar
Public Const sAddInNameByApp As String = "WordSpellNumber"    'AppUtilityNameInt
Public Const sAddInCaptByApp As String = "Popup SpellNumber for Word"    'UtilityNameExt for App in En
Public Const sAddInCaptByAppPt As String = "SpellNumber Popup para Word"    'UtilityNameExt para App em Pt
Public Const sDLLProgId As String = "AddInWdSpellNumber.WordDesigner"    'AddInXlUtilityNameInt.AppDesigner
Public Const sAppTarget As String = "Word"    'Useful when installing to other Office app and not Excel

Public Const sCOMAddInFileName As String = "WordSpellNumber.dll"
Public Const sAddInFileName As String = ""    'XLA, DOT, PPA, MDB...
Public Const AttachFileNames As Variant = "WordSpellNumberHotKey.dot;WordSpellNumberClick.wav;WordSpellNumber.ini"    'Attached and created while running

Public Const sOfficeVerReqMin As String = "9.0"     'Office Version required to Install - Min
Public Const sOfficeVerReqMax As String = "16.0"     'Office Version required to Install - Max
Public Const sAppVerReqToRun As String = ""    'Excel 12 (2007) or Excel 14 (2010)"    'Application Versions required to run utility. Let empty if Office riquired to install is sufficiente

Public Const sSuccessMsg As String = "Do not forget! The ''SpellNumber'' command will be available on document Mouse Rigth-click Menu when you restart the Word."
Public Const sSuccessMsgPt As String = "N|fffd|o esque|fffd|a! O comando ''Calend|fffd|rio'' estar|fffd| dispon|fffd|vel no Menu de Atalho de Clique Direito na documento (Menu de Contexto) ao reiniciar o Word."

Public Const lIsPortg As Long = 2    '0-Detect  1-Always portugues 2-Never Portuguese(always English) Useful to atend Extenso and SpellNumber for specic lang

Attribute VB_Name = "Mod1Global"
Option Explicit

#If VBA7 Then
    Private Declare PtrSafe Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
#Else
    Private Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
#End If

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128                           '  Maintenance string for PSS usage
End Type
'  dwPlatformId defines:
Private Const VER_PLATFORM_WIN32s = 0
Private Const VER_PLATFORM_WIN32_WINDOWS = 1
Private Const VER_PLATFORM_WIN32_NT = 2
#If VBA7 Then
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long
    Public Declare PtrSafe Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal nKey As Long) As Integer
#Else
    Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long
    Public Declare Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal vKey As Integer) As Integer
#End If

Public AddInTitle As String    'Orlando's AppCalendar
Public appHostApp     'As PowerPoint.Application  'As Word.Application  'As Application falha no word
Public dHostAppVer As Double
Public bIsCOMAddin As Boolean    'Auto detect by Project File Name ext and option user
Public sStartupPath As String
Public Fn As Variant
Public PathInst As String

Sub PleaseWait(bShow As Boolean)
    If bShow Then
        If Val(Application.Version) > 8 Then
            UserFormWait.Caption = IIf(IsPortg, "POR FAVOR", "PLEASE") & String(8, 32)
            UserFormWait.Label1.Caption = IIf(IsPortg, "AGUARDE...", "WAIT...")
            #If VBA6 Then
                UserFormWait.Show 0
            #End If
        Else
            Application.StatusBar = IIf(IsPortg, "AGUARDE...", "WAIT...")
        End If
    Else
        If Val(Application.Version) > 8 Then
            UserFormWait.Hide
        Else
            Application.StatusBar = False
        End If
    End If
End Sub

Sub PleaseWaitExeIndep(bShow As Boolean)
'Para evitar o vacuo ao reiniciar convertido para EXE, roda o PleaseWait.exe externo e independente
    Dim lRet As Long
    Dim sTempFolder As String    'Em usu|fffd|rio limitado, o reiniciar com eleva|fffd||fffd|o de direito leva o temp para o do administrador, ent|fffd|o o temp aqui deve ser o de tr|fffd|s n|fffd|vel abaixo no path deste e n|fffd|o TempForder()
    sTempFolder = ThisDocument.Path
    sTempFolder = Left(sTempFolder, InStrRev(sTempFolder, "\") - 1)
    sTempFolder = Left(sTempFolder, InStrRev(sTempFolder, "\") - 1)
    sTempFolder = Left(sTempFolder, InStrRev(sTempFolder, "\") - 1)

    If bShow Then
        If Dir(ThisDocument.Path & "\PleaseWait.exe") = "" Then Exit Sub
        On Error Resume Next
        FileCopy ThisDocument.Path & "\PleaseWait.exe", sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe"
        If Err.Number <> 0 Or Dir(sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe") = "" Then Exit Sub
        lRet = Shell(sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe", vbNormalFocus)
        If lRet = 0 Then Kill sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe"
    Else
        PleaseWait True
        On Error Resume Next 'S|fffd| vai ser poss|fffd|vel deletar depois que ele se fechar ao detectar o PleaseWait acima
        Do While Dir(sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe") <> "" And lRet < 10
            MyWait 0.5
            lRet = lRet + 1
            Kill sTempFolder & "\" & sAddInNameByApp & "PleaseWait.exe"
        Loop
        PleaseWait False
    End If
End Sub

Function IsInstallAsCOMAddin() As Boolean
    Dim sGuid
    sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\Clsid", "", False)
    IsInstallAsCOMAddin = sGuid <> "Error"
End Function

Function IsInstallAsAddin() As Boolean
    If sAddInFileName = "" Then Exit Function
    '    If WbIsOpen(sAddInFileName) Then IsInstallAsAddin = True: Exit Function

    Dim ad As AddIn
    For Each ad In AddIns
        If LCase(ad.Name) = LCase(sAddInFileName) Then
            '            If Dir(ad.FullName) <> "" Then IsInstallAsAddin = True    'S|fffd| est|fffd| insalado, se registrado e o arquivo existir
            Exit For
        End If
    Next
End Function

Sub VerifRestDisabledItems()
'Verify and restore if disabledItem in each Office Version. Since Office 10.0 user can disable thru
'an alert project that crash the app when starting. Unfortunately almost none knows as enable again
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
      Dim OpenKeyHdl As Long
    #End If
    Dim sNameRet As String
    Dim sDataRet As String
    Dim retRegEnumKey
    Dim i As Long
    Dim v As Long
    Dim sApplication As String: sApplication = sAppTarget    '"Excel"
    Dim sAppVersion As String
    'Const sAddInNameByApp As String = "ExcelStopwatch" 'Usado para testar com instalador em Install_ExcelStopwatchGPF.zip montado para instalar uma DLL que gera GPF

    For v = 10 To Val(Left(sOfficeVerReqMax, 2))  'Office Versions
        sAppVersion = v & ".0"
        retRegEnumKey = fRegEnumKey(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Resiliency\DisabledItems", True, True)
        If TypeName(retRegEnumKey) = "String()" Then
            For i = 0 To UBound(retRegEnumKey, 2)
                sNameRet = Replace(retRegEnumKey(1, i), Chr(0) & Chr(0), " ")
                sNameRet = LCase(Trim(Replace(sNameRet, Chr(0), "")))
                If InStr(1, sNameRet, LCase(sAddInNameByApp)) > 0 Then
                    If RegOpenKeyEx(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\Resiliency\DisabledItems", 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then     'Open key
                        sDataRet = retRegEnumKey(0, i)
                        RegDeleteValue OpenKeyHdl, sDataRet    'Delete the value
                        RegCloseKey OpenKeyHdl    'Close the handle
                    End If
                End If
            Next
        End If
    Next
End Sub

'Function WbIsOpen(WbName As String) As Boolean
'    Dim Wb As Workbook
'    On Error Resume Next
'    Set Wb = Workbooks(WbName)
'    WbIsOpen = Not Wb Is Nothing
'End Function

Sub Sair()
    If ShiftDown Or CtrlDown Then
        ButtonLanguage False
        If MsgBox("OK  - Save edited and exit" & vbCrLf & vbCrLf & "Cancel - Edit now, unhiding all text", vbOKCancel, "Edit?") = vbOK Then
            ButtonLanguage True: ThisDocument.Save
        Else
            'EditarDOC
            ButtonLanguage False
            If Not ThisDocument.ProtectionType = wdNoProtection Then ThisDocument.Unprotect
            Exit Sub
        End If
    Else
        ThisDocument.Saved = True
    End If
    If Not DOCtoEXE_IsThisDocExe() Then Application.Quit Else On Error Resume Next: ThisDocument.Close False
End Sub

Public Function IsWinNT(sVersion As String) As Boolean
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    Select Case sVersion
    Case "Any": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT)
    Case "XP": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 5)
    Case "Vista": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 0)
    Case "Win7": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 1)   'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1
    Case "Win8": IsWinNT = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 2)   'Win7 e Win8 se distinguem apenas apenas em dwMinorVersion, 1 e 2
    Case Else: Stop
    End Select
End Function

Public Function IsOffice64_bit() As Boolean
#If VBA7 Then
'  Code is running in the new VBA7 editor
     #If Win64 Then
     IsOffice64_bit = True 'Code is running in 64-bit version of Microsoft Office
     #Else
     '  Code is running in 32-bit version of Microsoft Office
     #End If
#Else
' Code is running in VBA version 6 or earlier
#End If
End Function

Function HasAdminPrivilege() As Boolean
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
        Dim OpenKeyHdl As Long
    #End If
    Dim lRet As Long
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion", 0, KEY_ALL_ACCESS, OpenKeyHdl)     'Only test to open a key, do not change
    If OpenKeyHdl <> 0 Then RegCloseKey OpenKeyHdl     'Close the key
    HasAdminPrivilege = (lRet = 0) And HasAdminPrivilege2
End Function

Function HasAdminPrivilege2() As Boolean    'In Chinese Win7 despite it is has privilage to access register, it hasn't full rights to access Program Files folder than we need test this also.
    Dim sProgFileDir As String
    On Error Resume Next
    sProgFileDir = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)    'Personal - MyDocuments
    If Len(sProgFileDir) > 5 Then
        sProgFileDir = sProgFileDir & "\OrlandoApp.inf"
        If Not IsLock(sProgFileDir) Then
            If Dir(sProgFileDir) <> "" Then If FileLen(sProgFileDir) = 0 Then Kill sProgFileDir    'Len 0 to make sure any third party contents.
            HasAdminPrivilege2 = (Err.Number = 0)
        End If
    End If
End Function

Public Function IsLock(sFile As String) As Boolean
    Dim hFile As Long
    On Error Resume Next
    hFile = FreeFile
    '    Open sFile For Binary Lock Write As #hFile 'Only for write
    Open sFile For Append As #hFile                        'For read and write
    Close #hFile
    IsLock = Err.Number <> 0
End Function

Function TempFolder() As String
'Get Temp Folder
    Dim fctRet As Long
    TempFolder = String$(255, 0)
    fctRet = GetTempPath(255, TempFolder)
    If fctRet <> 0 Then
        TempFolder = Left(TempFolder, fctRet)
        If Right(TempFolder, 1) = "\" Then TempFolder = Left(TempFolder, Len(TempFolder) - 1)
    Else
        TempFolder = ""
    End If
End Function

Public Function ShiftDown()
'Verif. if Shift is pressed
    ShiftDown = (GetKeyState32(16) < 0)
End Function

Public Function CtrlDown()
'Verif. if Ctrl is pressed
    CtrlDown = (GetKeyState32(17) < 0)
End Function

Sub ButtonLanguage(Optional bLight As Boolean = False)
'Adjust document according language and Office version. bLight is to select range of detected language, if False, use the first
    On Error Resume Next: If Application.Visible = False Then Application.Visible = True    'Need in Office 365 because SplashScreen of expired and buy can hide.
    ThisDocument.Activate: Selection.HomeKey Unit:=wdStory    '    ThisDocument.Sheets(1).Range("A1").Select
    ThisDocument.Windows(1).WindowState = wdWindowStateMaximize
    If ActiveWindow.View.SplitSpecial = wdPaneNone Then
        ActiveWindow.ActivePane.View.Type = wdWebView
    Else
        ActiveWindow.View.Type = wdWebView
    End If
    ActiveWindow.ActivePane.View.Zoom.PageFit = wdPageFitTextFit

    If Not ThisDocument.ProtectionType = wdNoProtection Then ThisDocument.Unprotect
    IsPortg = IIf(lIsPortg = 0, Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070, lIsPortg = 1)    'Application.International(xlCountryCode) = 55
    Application.ScreenUpdating = False
    Selection.WholeStory: Selection.Font.Hidden = False    'No 2007 dava error ao ocultar tudo para depois exibir, ent|fffd|o inverti exibindo tudo e ocultando tabela de lingua que n|fffd|o interessar
    If bLight Then
        If IsPortg Then
            ThisDocument.Tables(1).Select: Selection.Font.Hidden = True
        Else
            ThisDocument.Tables(2).Select: Selection.Font.Hidden = True
        End If
    End If

    ThisDocument.Activate: Selection.HomeKey Unit:=wdStory
    '    ThisDocument.Protect wdAllowOnlyFormFields    ' wdAllowOnlyReading 'Suspendi prote|fffd||fffd|o, porque links n|fffd|o estava funcionando
    If Val(Application.Version) >= 11 Then Set appHostApp = Application: appHostApp.ActiveWindow.View.ReadingLayout = True: appHostApp.ActiveWindow.View.ReadingLayoutAllowMultiplePages = False: appHostApp.ActiveWindow.View.ReadingLayoutActualView = False  'No 2013 wdWebView fica tela branca. Talvez este modo seja melhor para todos desde que passou a existir no 2003.
    Application.ScreenUpdating = True
End Sub










Function InstallMSAddnDrDLL() As Boolean
'To register/unregister COM, requires MSAddnDr.DLL, then verify and install if need. This was need from Office 2013 (15).
    If IsMSAddnDrDLLInstall Then InstallMSAddnDrDLL = True: Exit Function

    'Install dll
    Dim sPathInst As String
    sPathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "CommonFilesDir", False)
    If sPathInst = "Error" Then sPathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "CommonFilesDir", False)
    If sPathInst = "Error" Or Len(sPathInst) < 5 Then MyMsgBox "CommonFilesDir not found.", 1, sAddInCaptByApp & " - Fail!": Exit Function
    sPathInst = sPathInst & "\DESIGNER"
    If Dir(sPathInst, vbDirectory) = "" Then MyMsgBox "CommonFilesDir\DESIGNER not found.", 1, sAddInCaptByApp & " - Fail!": Exit Function
    If PathTemp = "" Then Stop: PathTemp = ThisDocument.Path 'Useful in debug. |fffd| muito pouco prov|fffd|vel que estes MsgBox aconte|fffd|am, vou deixar por seguran|fffd|a mas simples sem muito detalhe.
    If Dir(sPathInst & "\" & "MSAddnDr.DLL") = "" Then MyMoveFile "MSAddnDr.DLL", PathTemp, sPathInst, True
    If Dir(sPathInst & "\" & "MSAddnDr.DLL") = "" Then MyMsgBox "MSAddnDr.DLL not found or not copied.", 1, sAddInCaptByApp & " - Fail!": Exit Function

    InstallMSAddnDrDLL = True
    Dim bInstalled As Boolean
    bInstalled = RegisterServer(sPathInst & "\" & "MSAddnDr.DLL", True)
    If bInstalled Then MyWait 1: bInstalled = IsMSAddnDrDLLInstall    'Conferir

    If Not bInstalled Then
        If IsPortg Then
            Msg1 = "Ao registrar a DLL no Windows (MSAddnDr.DLL)." & vbCrLf & vbCrLf & _
                    "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
            Msg2 = sAddInCaptByAppPt & " - Falha!"
        Else
            Msg1 = "When registering the DLL on Windows (MSAddnDr.DLL)." & vbCrLf & vbCrLf & _
                    "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
            Msg2 = sAddInCaptByApp & " - Fail!"
        End If
        MyMsgBox Msg1, 1, Msg2
        InstallMSAddnDrDLL = False
        Exit Function
    End If
End Function

Function IsMSAddnDrDLLInstall() As Boolean
    Dim sGuid, sDLLProgId
    sDLLProgId = "MSAddnDr.AddInDesigner"
    sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\Clsid", "", False)
    IsMSAddnDrDLLInstall = sGuid <> "Error"

    If IsMSAddnDrDLLInstall Then   'Por segurana|fffd|a, se o arquivo n|fffd|o for encontrado, considerar n|fffd|o registrada. Algo dificil de acontecer na pr|fffd|tica, mas nos teste com CTR se for desregistrada e deletada a DLL o sGuid continua reportando ok, ou seja, o registro referente o CTR n|fffd|o |fffd| atualizado com RegSvr32.exe /u, inclusive se a dll n|fffd|o for deletada continua funcionando. Talvez possa acontecer se CTV e MSI-b instalandos e o MSI-b venha a ser desinstalado.
        Dim sDllPath As String
        sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "CLSID\" & sGuid & "\InprocServer32", "", False)
        IsMSAddnDrDLLInstall = (Len(sDllPath) > 0 And Len(Dir(sDllPath))) > 0
    End If
End Function


Attribute VB_Name = "Mod1Install"
Option Explicit
Public PathTemp As String

Sub Install()
    IsPortg = IIf(lIsPortg = 0, Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070, lIsPortg = 1)    'Application.International(xlCountryCode) = 55
    Set appHostApp = Application
    dHostAppVer = Val(Application.Version)
    AddInTitle = "Orlando's " & sAddInNameByApp
    sStartupPath = Application.StartupPath

    'Office 32-bit version required to install
    If IsOffice64_bit Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "Esta primeira vers|fffd|o do " & sAppTarget & " 64-bit ainda n|fffd|o suporta os atuais suplementos COM!" _
                 & vbCrLf & vbCrLf & "Obs.: Voc|fffd| est|fffd| certo que necessita usar o " & sAppTarget & " 64-bit? A Microsoft recomenda a vers|fffd|o 32-bit exceto em grande quantidade de dados que possa superar seus limites. A vers|fffd|o 32-bit, al|fffd|m de mais completa, |fffd| perceptivelmente t|fffd|o r|fffd|pida quanto |fffd| de 64-bit, mesmo rodando em Windows 64-bit."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "This first version of " & sAppTarget & " 64-bit does not support the existing COM add-ins yet!" _
                 & vbCrLf & vbCrLf & "Note: Are you sure that you need to use " & sAppTarget & " 64-bit? Microsoft recommends the 32-bit version except in large amount of data that can overcome its limits. The 32-bit version, beyond more complete, is noticeably as fast as 64-bit version even if running on Windows 64-bit."
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Sub
    End If

    'Office version required to install - Min
    If Val(Application.Version) < Val(sOfficeVerReqMin) Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "S|fffd| |fffd| poss|fffd|vel instalar este utilit|fffd|rio no " & sAppTarget & " " & sOfficeVerReqMin & " ou mais recente!"
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "Only it is possible to install this utility on " & sAppTarget & " " & sOfficeVerReqMin & " or later!"
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Sub
    End If

    'Office version required to install - Max
    If Val(Application.Version) > Val(sOfficeVerReqMax) Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "Nova vers|fffd|o do Office desconhecida para esta vers|fffd|o do " & sAddInCaptByAppPt & "! Clique no link Ajuda, logo abaixo, para baixar uma nova vers|fffd|o compat|fffd|vel."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "New Office version unknown to this " & sAddInCaptByApp & " version! Click Help link, soon below, to download a new compatible version."
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Sub
    End If

    'Application versions required to run the utility
    If sAppVerReqToRun <> "" Then
        Dim bReqOk As Boolean
        For Each Fn In Split(sAppVerReqToRun, " or ")
            bReqOk = OpenEspVerAppObj(True, Left(Fn, InStr(1, Fn, " ") - 1), Mid(Fn, InStr(1, Fn, " ") + 1))
            If bReqOk Then Exit For
        Next
        If Not bReqOk Then
            PleaseWait False
            If IsPortg Then
                Msg1 = "Embora este utilit|fffd|rio possa ser instalado, ele requer para rodar a instala|fffd||fffd|o de pelo menos: " & MyReplace(sAppVerReqToRun, "or", "ou") & "! Continua assim mesmo?"
                Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Rodar!"
            Else
                Msg1 = "Although this utility can be installed, it requires to run the installation of at least: " & sAppVerReqToRun & "! Continue anyway?"
                Msg2 = sAddInCaptByApp & " - Impossible to Run!"
            End If
            If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
        End If
    End If

    PathTemp = TempFolder()
    PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)    'Personal - MyDocuments
    If PathInst = "Error" Then PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Or Len(PathInst) < 5 Then PathInst = "C:"
    PathInst = PathInst & "\OrlandoApp"

    'Uninstall early version
    If IsInstallAsCOMAddin Or IsInstallAsAddin Or (sCOMAddInFileName <> "" And Dir(PathInst & "\" & sCOMAddInFileName) <> "") _
       Or (sAddInFileName <> "" And Dir(PathInst & "\" & sAddInFileName) <> "") Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "H|fffd| uma instala|fffd||fffd|o anterior ainda n|fffd|o removida." & vbCrLf & vbCrLf & "A seguir, voc|fffd| ser|fffd| redirecionado para o desinstalador que precisar|fffd| fechar o " & sAppTarget & " para completar a desinstala|fffd||fffd|o." & vbCrLf & vbCrLf & "Por favor, tente instalar novamente logo ap|fffd|s o " & sAppTarget & " ser fechado."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Instalar!"
        Else
            Msg1 = "There is a previous installation not removed yet." & vbCrLf & vbCrLf & "Next, you'll be redirected to the uninstaller that will need to close " & sAppTarget & " to complete the uninstallation." & vbCrLf & vbCrLf & "Please, try to install again soon after " & sAppTarget & " is closed."
            Msg2 = sAddInCaptByApp & " - Impossible to Install!"
        End If
        MyMsgBox Msg1, 1, Msg2
        UnInstall
        Exit Sub
    End If

    'Choose COM Add-in or Add-in if both available
    PathTemp = ThisDocument.Path
    If (sCOMAddInFileName <> "" And Dir(PathTemp & "\" & sCOMAddInFileName) <> "") And (sAddInFileName <> "" And Dir(PathTemp & "\" & sAddInFileName) <> "") Then
        PleaseWait False
        If IsPortg Then
            Msg1 = "Sim - Instalar como COM Add-in (" & sCOMAddInFileName & ")" & vbCrLf & vbCrLf & _
                   "N|fffd|o - Instalar como Add-in (" & sAddInFileName & "). Ou suspender."
            Msg2 = sAddInCaptByAppPt & " - COM Add-in ou Add-in?"
        Else
            Msg1 = "Yes - Install as COM Add-in (" & sCOMAddInFileName & ")" & vbCrLf & vbCrLf & _
                   "No - Install as Add-in (" & sAddInFileName & "). Or suspend."
            Msg2 = sAddInCaptByApp & " - COM Add-in ou Add-in?"
        End If
        If MyMsgBox(Msg1, 3, Msg2) = 1 Then bIsCOMAddin = True Else bIsCOMAddin = False
        If BotAcionado = 3 Then Exit Sub
    ElseIf sAddInFileName <> "" And Dir(PathTemp & "\" & sAddInFileName) <> "" Then
        bIsCOMAddin = False
    Else
        bIsCOMAddin = True
    End If

    'Antes verificar se tem privilegio de admin para registrar DLL, se n|fffd|o, reopen asking
    If bIsCOMAddin Then If Not HasAdminPrivilege Then CloseReOpenWordToRegDLL: Exit Sub
    'If Not bIsCOMAddin Then PathInst = Application.UserLibraryPath & "OrlandoApp"    'This folder doesn't need privileg elevation and moreover add-in is installed only for active limited user ou logge adm user
ReTry:
    PleaseWait False
    UserFormInst.folder_Tb.Value = PathInst
    UserFormInst.Show
    If BotAcionado = 3 Then Exit Sub

    PathInst = UserFormInst.folder_Tb.Value
    If UserFormInst.Xlstart_OpB.Value Then PathInst = Application.StartupPath

    On Error Resume Next
    If Dir(PathInst, vbDirectory) = "" Then MkDir PathInst
    If Err.Number <> 0 Then
        If IsPortg Then
            Msg1 = "Talvez voc|fffd| n|fffd|o tenha direitos suficientes para criar pastas neste local do disco ou rede. Tentar novamente?" & vbCrLf & vbCrLf & _
                   "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
            Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Criar Pasta!"
        Else
            Msg1 = "Maybe you haven't sufficient rights to create folders in this place on the disk or network. Try again?" & vbCrLf & vbCrLf & _
                   "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
            Msg2 = sAddInCaptByApp & " - Impossible to Create Folder!"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then GoTo ReTry Else Exit Sub
    End If

    'Pacote usando o aplicativo DOCtoEXE onde todos arquivos j|fffd| foram extra|fffd|dos
    Dim i As Long
    PleaseWait True
    MyWait 1

    'Conferindo extra|fffd||fffd|o
    Do While Dir(PathTemp & "\" & IIf(bIsCOMAddin, sCOMAddInFileName, sAddInFileName)) = ""
        MyWait 1
        i = i + 1
        If i > 40 Then
            MsgBox IIf(IsPortg, "Ao extrair arquivos para a pasta " & PathTemp & ".", "When extract files to " & PathTemp & " folder."), vbCritical, IIf(IsPortg, "Falha!", "Fail!")
            Exit Sub
        End If
    Loop

    VerifRestDisabledItems

    Dim bSuccess As Boolean
    If bIsCOMAddin Then bSuccess = InstallAsCOMAddIn Else bSuccess = InstallAsAddIn
    PleaseWait False
    If bSuccess Then
        If IsPortg Then
            Msg1 = sSuccessMsgPt
            Msg2 = sAddInCaptByAppPt & " - Instalado com Sucesso"
        Else
            Msg1 = sSuccessMsg
            Msg2 = sAddInCaptByApp & " - Installed with Success"
        End If
        MyMsgBox Msg1, 1, Msg2
    End If
    ThisDocument.Saved = True
    If Not DOCtoEXE_IsThisDocExe() Then Application.Quit Else On Error Resume Next: ThisDocument.Close False
End Sub

Private Function InstallAsCOMAddIn() As Boolean
    If Not InstallMSAddnDrDLL Then Exit Function    'To register/unregister COM, requires MSAddnDr.DLL, then verify and install if need.
'Install dll
    InstallAsCOMAddIn = True
    MyMoveFile sCOMAddInFileName, PathTemp, PathInst, True
    If UserFormInst.AsAddIn_OpB.Value Then    'Op|fffd||fffd|o |fffd|nica para COM
        For Each Fn In Split(AttachFileNames, ";")
            If Dir(PathTemp & "\" & Fn) <> "" Then MyMoveFile CStr(Fn), PathTemp, PathInst, True
        Next
        Dim bInstalled As Boolean
        bInstalled = RegisterServer(PathInst & "\" & sCOMAddInFileName, True)
        If bInstalled Then MyWait 1: bInstalled = IsInstallAsCOMAddin    'Conferir

        If Not bInstalled Then
            If IsPortg Then
                Msg1 = "Ao registrar a DLL no Windows." & vbCrLf & vbCrLf & _
                        "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
                Msg2 = sAddInCaptByAppPt & " - Falha!"
            Else
                Msg1 = "When registering the DLL on Windows." & vbCrLf & vbCrLf & _
                        "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
                Msg2 = sAddInCaptByApp & " - Fail!"
            End If
            MyMsgBox Msg1, 1, Msg2
            InstallAsCOMAddIn = False
            Exit Function
        End If

        If UserFormInst.AllWinUsers_Chb.Value Then
            #If VBA7 Then
                Dim OpenKeyHdl As LongPtr
            #Else
              Dim OpenKeyHdl As Long
            #End If
            Dim lRet As Long
            Dim SecurAttr As SECURITY_ATTRIBUTES

            'Create local machine subkey for AddIn is used for All Win User
            If GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "", False) = "Error" Then
                RegCreateKeyEx HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, _
                        0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                        KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
                RegCloseKey OpenKeyHdl
            End If

            'Set value at subkey copying from HKEY_CURRENT_USER
            Dim vStoreValu
            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "LoadBehavior", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "LoadBehavior", REG_DWORD, CLng(vStoreValu)

            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "FriendlyName", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "FriendlyName", REG_SZ, CStr(vStoreValu)

            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "CommandLineSafe", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "CommandLineSafe", REG_DWORD, CLng(vStoreValu)

            vStoreValu = GetRegValue(HKEY_CURRENT_USER, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "Description", False)
            SetKeyValue HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "Description", REG_SZ, CStr(vStoreValu)
        End If
    End If
End Function


Private Function InstallAsAddIn() As Boolean
'Install Xla
    InstallAsAddIn = True
    MyMoveFile sAddInFileName, PathTemp, PathInst, True
    If UserFormInst.AsAddIn_OpB.Value Then
        For Each Fn In Split(AttachFileNames, ";")
            If Dir(PathTemp & "\" & Fn) <> "" Then MyMoveFile CStr(Fn), PathTemp, PathInst, True
        Next
        Dim bInstalled As Boolean
        On Error Resume Next: If Val(Application.Version) >= 11 Then appHostApp.ActiveWindow.View.ReadingLayout = False 'No 2016 AddIns.Add n|fffd|o funcionam neste modo, mas vou desabitar para todos desde que passou a existir no 2003.
        AddIns.Add Filename:=PathInst & "\" & sAddInFileName
        AddIns(AddInTitle).Installed = True
        bInstalled = Err.Number = 0
        If bInstalled Then MyWait 1: bInstalled = IsInstallAsAddin    'Conferir

        If Not bInstalled Then
            If IsPortg Then
                Msg1 = "Ao registrar o Add-in no Windows."
                Msg2 = sAddInCaptByAppPt & " - Falha!"
            Else
                Msg1 = "When registering the Add-in on Windows."
                Msg2 = sAddInCaptByApp & " - Fail!"
            End If
            MyMsgBox Msg1, 1, Msg2
            InstallAsAddIn = False
            Exit Function
        End If
    Else
        For Each Fn In Split(AttachFileNames, ";")
            If Dir(PathTemp & "\" & Fn) <> "" Then MyMoveFile CStr(Fn), PathTemp, Application.Path, True
        Next
        '        Workbooks.Open PathInst & "\" & sAddInFileName
    End If
End Function

Private Sub CloseReOpenWordToRegDLL()
    PleaseWait False
    If DOCtoEXE_IsThisDocExe() Then
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para registrar a DLL, vou ser reiniciado automaticamente pedindo-lhe acesso ao registro." & vbCrLf & vbCrLf & "Por favor, pressione OK e permita."
            Msg2 = sAddInCaptByAppPt & " - Instala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to register the DLL, I will be restarted automatically asking you access to the register." & vbCrLf & vbCrLf & "Please, press OK and allow."
            Msg2 = sAddInCaptByApp & " - Install"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            lDOCtoEXE_AutoReopen = 2
            lDOCtoEXE_WaitReopen = 0
            sDOCtoEXE_CmdLineReopen = "Install": ThisDocument.Activate
            If DOCtoEXE_SyncProperties(True) Then
                PleaseWait True: PleaseWaitExeIndep True: PleaseWait False
                ThisDocument.Saved = True
                On Error Resume Next: ThisDocument.Close False    'Application.Quit
            End If
        End If
    Else
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para registrar a DLL, agora |fffd| necess|fffd|rio fechar e voc|fffd| deve me reiniciar logo depois como administrador e ent|fffd|o acionar o bot|fffd|o Instalar novamente."
            Msg2 = sAddInCaptByAppPt & " - Instala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to register the DLL, now it must close and you should restart me afterwards immediately as administrator and then press Install button again."
            Msg2 = sAddInCaptByApp & " - Install"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            ThisDocument.Saved = True
            Application.Quit
        End If
    End If
End Sub

Sub MyMoveFile(vFiles As String, vOrigPath As String, vDestPath As String, bOnlyCopy As Boolean)
    Dim vFilename As String
    vFilename = Dir(vOrigPath & "\" & vFiles)
    While vFilename <> ""
        If bOnlyCopy Then
            FileCopy vOrigPath & "\" & vFilename, vDestPath & "\" & vFilename
            vFilename = Dir()
        Else
            If Dir(vDestPath & "\" & vFilename) <> "" Then Kill vDestPath & "\" & vFilename
            Name vOrigPath & "\" & vFilename As vDestPath & "\" & vFilename
            vFilename = Dir(vOrigPath & "\" & vFiles)
        End If
    Wend
End Sub

Private Function OpenEspVerAppObj(Optional bVerfOnly As Boolean = False, Optional sApplication As String = "Excel", Optional sAppVersion As String = "12 (2007)") As Boolean
    Dim ret As Long
    Dim sAppExeFile As String
    OpenEspVerAppObj = False
    On Error Resume Next
    'If install and where
    sAppExeFile = GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\InstallRoot", "Path", False)
    If sAppExeFile = "Error" Then sAppExeFile = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Office\" & Val(Left(sAppVersion, 2)) & ".0\" & sApplication & "\InstallRoot", "Path", False)
    If sAppExeFile = "Error" Or Len(sAppExeFile) < 5 Then Exit Function

    Select Case sApplication
    Case "Access"
        sAppExeFile = sAppExeFile & "Msaccess.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function

    Case "Excel"
        sAppExeFile = sAppExeFile & "Excel.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function

    Case "PowerPoint"
        sAppExeFile = sAppExeFile & "Powerpnt.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function

    Case "Word"
        sAppExeFile = sAppExeFile & "Winword.exe"
        If Dir(sAppExeFile) = "" Then Exit Function
        If bVerfOnly Then OpenEspVerAppObj = True: Exit Function
    End Select
    
    OpenEspVerAppObj = True
End Function
Attribute VB_Name = "Mod1Uninstall"
Option Explicit
Dim sTempFile As String
Dim bCloseReOpenWord As Boolean

Sub UnInstall()
    IsPortg = IIf(lIsPortg = 0, Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070, lIsPortg = 1) 'Application.International(xlCountryCode) = 55
    Set appHostApp = Application
    dHostAppVer = Val(Application.Version)
    AddInTitle = "Orlando's " & sAddInNameByApp
    sStartupPath = Application.StartupPath

    sTempFile = TempFolder() & "\" & sAddInNameByApp & "DllPath.tmp"

    PleaseWait False
    If Dir(sTempFile) = "" And sDOCtoEXE_CmdLineReopen <> "UnInstall" Then
        If IsPortg Then
            Msg1 = "Ser|fffd| verificada a exist|fffd|ncia de uma instala|fffd||fffd|o anterior e, em seguida, ela ser|fffd| devidamente removida. OK?"
            Msg2 = sAddInCaptByAppPt & " - DesInstalar"
        Else
            Msg1 = "It will be verified a previous installation and, after that, it will be duly removed. OK?"
            Msg2 = sAddInCaptByApp & " - UnInstall"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
        PleaseWait True
    Else
        PleaseWaitExeIndep False: PleaseWait True
        MyWait 3    'To give time to other eventual instance of sAppTarget closes
    End If
    
    'Antes verificar se tem privilegio de admin para desregistrar DLL, se n|fffd|o, reopen asking
    If IsInstallAsCOMAddin And Not HasAdminPrivilege Then CloseReOpenWordToUnregDLL: Exit Sub

    If UnInstallAsCOMAddIn Then
        If UnInstallAsAddIn Then
            VerifRestDisabledItems
            If IsPortg Then
                Msg1 = "Arquivos e comando do " & sAddInCaptByAppPt & " foram removidos."
                Msg2 = sAddInCaptByAppPt & " - DesInstala|fffd||fffd|o Conclu|fffd|da"
            Else
                Msg1 = sAddInCaptByApp & " files and command were removed."
                Msg2 = sAddInCaptByApp & " - UnInstall Finished"
            End If
            If MyMsgBox(Msg1, 1, Msg2) = 1 Then
                ThisDocument.Saved = True
                If Not DOCtoEXE_IsThisDocExe() Then Application.Quit Else On Error Resume Next: ThisDocument.Close False       'Diferente do Excel, normalmente s|fffd| instala ou se trabalha com uma |fffd|nica vers|fffd|o do Word. Assim n|fffd|o vou desinstalar em outras via API
            End If
        End If
    Else
        If bCloseReOpenWord Then
            bCloseReOpenWord = False
            If sAppTarget = "Word" Then
                If HasAdminPrivilege Then CloseReOpenWordToDelDLL Else CloseReOpenWordToUnregDLL    'Abrir outra inst|fffd|ncia |fffd| melhor que reopen mas precisa ter direito admin
            Else
                'N|fffd|o |fffd| necess|fffd|rio o Word est|fffd| fechado pra remover a dll e sim o sAppTarget, bastando ReTry imediatamente.
                'Mantive o mesmo esquema, pois se falhar na pr|fffd|xima tentativa j|fffd| vai completando a desinstala|fffd||fffd|o
                ' CloseAllAccess True    'Qure retorne True or False, retenta pode ser que d|fffd| certo nesta execu|fffd||fffd|o mesmo
                UnInstall
            End If
        End If
    End If
End Sub

Private Function UnInstallAsCOMAddIn() As Boolean
    Dim sGuid As String
    Dim sDllPath As String

    PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Then PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Or Len(PathInst) < 5 Then PathInst = "C:"
    PathInst = PathInst & "\OrlandoApp"

    If IsInstallAsCOMAddin Then    'Uninstall from reg saving info in tmp file, close aplic, reopen, and then recall to delete the files
        'Get Dll Path on register
        sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\Clsid", "", False)
        sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "CLSID\" & sGuid & "\InprocServer32", "", False)
        
        'Se for Office 64-bits e como a instala|fffd||fffd|o s|fffd| pode ter sido feita pelo 32-bit ent|fffd|o a pasta
        'deve ser detectada via Wow6432Node no registro e o unregister ir|fffd| ser feito via regsvr32.exe.
        'Exceto isto, nada foi alterado no codigo de uninstall pra 32-bit.
        If Not (Len(sDllPath) > 0 And Len(Dir(sDllPath))) > 0 And IsOffice64_bit Then
            sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "Wow6432Node\CLSID\" & sGuid & "\InprocServer32", "", False)
        End If

        Dim sDllPathPct    'Se a dll registrada n|fffd|o for encontrada ou estiver inacess|fffd|vel, usar a do pacote. Isto |fffd| s|fffd| para desregistrar, o processo continua como se sDllPath existisse inclusive reopen
        If Not (Len(sDllPath) > 0 And Len(Dir(sDllPath))) > 0 Then
            sDllPathPct = ThisDocument.Path & "\" & sCOMAddInFileName
            If Not (Len(sDllPathPct) > 0 And Len(Dir(sDllPathPct))) > 0 Then sDllPathPct = ""
        End If

        PathTemp = ThisDocument.Path: If Not InstallMSAddnDrDLL Then Exit Function   'To register/unregister COM, requires MSAddnDr.DLL, then verify and install if need. A priori isto s|fffd| seria necess|fffd|rio em uma tenhativa de instala|fffd||fffd|o de uma vers|fffd|o anterior que normalmente n|fffd|o pode acontecer, pois os antigos n|fffd|o rodam no 2013. Fica aqui em teste ou por seguran|fffd|a.
        
        If Not IsOffice64_bit Then
            RegisterServer IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
        Else
            RegisterServerShell32 IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
        End If

        'Se a dll registrada falhar ainda por algum outro motivo falhar, corrompida por exemplo,
        'tenta usar a do pacote se ainda n|fffd|o foi usada
        MyWait 1
        If IsInstallAsCOMAddin And sDllPathPct = "" Then   'Conferir
            sDllPathPct = ThisDocument.Path & "\" & sCOMAddInFileName
            If Not (Len(sDllPathPct) > 0 And Len(Dir(sDllPathPct))) > 0 Then sDllPathPct = ""
            If sDllPathPct <> "" Then
                If Not IsOffice64_bit Then
                    RegisterServer IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
                Else
                    RegisterServerShell32 IIf(sDllPathPct = "", sDllPath, sDllPathPct), False
                End If
                MyWait 1
            End If
        End If

        If IsInstallAsCOMAddin Then    'Conferir novamente
            If IsPortg Then
                Msg1 = "Ao desregistrar a DLL no Windows." & vbCrLf & vbCrLf & _
                        "Obs.: No Windows XP e Vista, somente usu|fffd|rios com plenos direitos administrativos podem instalar e desinstalar COM add-ins, mas, se tentar instalar sem direitos, n|fffd|o vai causar nenhum problema maior, simplesmente n|fffd|o vai instalar."
                Msg2 = sAddInCaptByAppPt & " - Falha!"
            Else
                Msg1 = "When unregister the DLL on Windows." & vbCrLf & vbCrLf & _
                        "Note: In Windows XP and Vista, only users with full administrative rights can install and uninstall COM add-ins; however if you try to install without rights, this won't cause any major problems, it simply won't install."
                Msg2 = sAddInCaptByApp & " - Fail!"
            End If
            MyMsgBox Msg1, 1, Msg2
            PleaseWait False
            Exit Function
        End If

        'Delete local machine subkey for AddIn is used for All Win User
        If Not GetRegValue(HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId, "LoadBehavior", False) = "Error" Then _
                RegDeleteKey HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Office\" & sAppTarget & "\Addins\" & sDLLProgId

        sDllPath = MyReplace(UCase(sDllPath), UCase("\" & sCOMAddInFileName), "")

        If Dir(sDllPath & "\LembreteDirProj.txt") <> "" Then sDllPath = PathInst    'Avoid to delete in folder project

        Open sTempFile For Output As #1
        Write #1, sDllPath
        Close #1
        bCloseReOpenWord = True    'Para Quit Word fora da fun|fffd||fffd|o, pois n|fffd|o sai quando perde o foco
        Exit Function
    Else
        'Get Dll Path on temp file
        If Dir(sTempFile) <> "" Then
            Open sTempFile For Input As #1
            Input #1, sDllPath
            Close #1
        Else
            sDllPath = PathInst
        End If

        'Delete files and folder
        Dim i As Double
        Do
            i = i + 1
            MyWait i
            On Error Resume Next
            If Dir(PathInst & "\" & sCOMAddInFileName) <> "" Then Kill PathInst & "\" & sCOMAddInFileName
            If Dir(sDllPath & "\" & sCOMAddInFileName) <> "" Then Kill sDllPath & "\" & sCOMAddInFileName
        Loop While Err.Number <> 0 And i < 5
        If Err.Number = 0 Then
            For Each Fn In Split(AttachFileNames, ";")
                If Dir(PathInst & "\" & Fn) <> "" Then Kill PathInst & "\" & Fn
                If Dir(sDllPath & "\" & Fn) <> "" Then Kill sDllPath & "\" & Fn
            Next
            If Dir(PathInst & "\*.*") = "" And Dir(PathInst, vbDirectory) <> "" Then RmDir PathInst
            If Dir(sTempFile) <> "" Then Kill sTempFile
            PleaseWait False
        Else
            PleaseWait False
            'Antes verificar se n|fffd|o |fffd| falta de privilegio de admin para deletar DLL em pastas protegidas, se n|fffd|o, reopen asking. Isso acontece quando a DLL foi desregistrada por outros meios e n|fffd|o deletou os arquivo ou at|fffd| por falha aqui.
            If Not HasAdminPrivilege Then bCloseReOpenWord = True: Exit Function
            
            If IsPortg Then
                Msg1 = "Acesso n|fffd|o permitido. Feche todas as janelas do " & sAppTarget & " e depois tente novamente." _
                        & vbCrLf & vbCrLf & "Veja ainda se seus direitos de acessos s|fffd|o suficientes para excluir arquivos na pasta " & IIf(Dir(PathInst & "\" & sCOMAddInFileName) <> "", PathInst, sDllPath) & "."
                Msg2 = sAddInCaptByAppPt & " - Imposs|fffd|vel Excluir!"
            Else
                Msg1 = "Access denied. Close all " & sAppTarget & " windows and then try again." _
                        & vbCrLf & vbCrLf & "See still if your access rights are sufficient to delete files in " & IIf(Dir(PathInst & "\" & sCOMAddInFileName) <> "", PathInst, sDllPath) & " folder."
                Msg2 = sAddInCaptByApp & " - Impossible to Delete!"
            End If
            MyMsgBox Msg1, 1, Msg2
            Exit Function
        End If
    End If
    UnInstallAsCOMAddIn = True
End Function

Private Function UnInstallAsAddIn() As Boolean
    Dim PathInst As String
    Dim ad As AddIn

    UnInstallAsAddIn = True
    If sAddInFileName = "" Then Exit Function

    PathInst = ""
    For Each ad In AddIns
        If ad.Name = "ExcelCalendar.xla" Then
            PathInst = ad.Path
            Exit For
        End If
    Next

    On Error Resume Next

    'Deactivate Add
    AddIns("Orlando's Excel Calendar").Installed = False    'Vers|fffd|o antiga com AddInTitle diferente
    AddIns(AddInTitle).Installed = False
    'If WbIsOpen(sAddInFileName) Then Workbooks(sAddInFileName).Close False

    'Delete files and folder...
    'In Anywhere detected if loaded
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst, False

    'InDefautOrlando
    PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Then PathInst = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows\CurrentVersion", "ProgramFilesDir", False)
    If PathInst = "Error" Or Len(PathInst) < 5 Then
        PathInst = ""
    Else
        If Dir(PathInst & "\OrlandoApp", vbDirectory) = "" Then
            PathInst = ""
        Else
            PathInst = PathInst & "\OrlandoApp"
        End If
    End If
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst, True

    'InDefautOrlando-InUserLibrary
    'PathInst = Application.UserLibraryPath & "OrlandoApp"
    If Dir(PathInst, vbDirectory) = "" Then PathInst = ""
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst, True

    'In XLSTART
    PathInst = Application.StartupPath
    If Dir(PathInst, vbDirectory) = "" Then PathInst = ""
    If PathInst <> "" Then DelAddInFlFld PathInst, PathInst & "\" & "..", False    'In XLSTART data files are one level down

    UnInstallAsAddIn = Not IsInstallAsAddin
End Function

Private Sub DelAddInFlFld(AddInPath As String, AddInDataPath As String, bFldToo As Boolean)   'Delete files and the folder
    On Error Resume Next
    If Dir(AddInPath & "\" & sAddInFileName) <> "" Then Kill AddInPath & "\" & sAddInFileName
    For Each Fn In Split(AttachFileNames, ";")
        If Dir(AddInDataPath & "\" & Fn) <> "" Then Kill AddInDataPath & "\" & Fn
    Next
    If bFldToo Then If Dir(AddInPath & "\*.*") = "" And Dir(AddInPath, vbDirectory) <> "" Then RmDir AddInPath
End Sub

Private Sub CloseReOpenWordToUnregDLL()
    PleaseWait False
    If DOCtoEXE_IsThisDocExe() Then
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para desregistrar a DLL, vou ser reiniciado automaticamente pedindo-lhe acesso ao registro." & vbCrLf & vbCrLf & " Por favor, pressione OK e permita."
            Msg2 = sAddInCaptByAppPt & " - Desinstala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to unregister the DLL, I will be restarted automatically asking you access to the register." & vbCrLf & vbCrLf & "Please, press OK and allow."
            Msg2 = sAddInCaptByApp & " - Uninstall"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            lDOCtoEXE_AutoReopen = 2
            lDOCtoEXE_WaitReopen = 0
            sDOCtoEXE_CmdLineReopen = "UnInstall": ThisDocument.Activate
            If DOCtoEXE_SyncProperties(True) Then
                PleaseWait True: PleaseWaitExeIndep True: PleaseWait False
                ThisDocument.Saved = True
                On Error Resume Next: ThisDocument.Close False    'Application.Quit
            End If
        End If
    Else
        If IsPortg Then
            Msg1 = "Teria que ter iniciado com privil|fffd|gios de administrador para desregistrar a DLL, agora |fffd| necess|fffd|rio fechar e voc|fffd| deve me reiniciar logo depois como administrador e ent|fffd|o acionar o bot|fffd|o Desinstalar novamente."
            Msg2 = sAddInCaptByAppPt & " - Desinstala|fffd||fffd|o"
        Else
            Msg1 = "Would have to have started with administrator privilege to unregister the DLL, now it must close and you should restart me afterwards immediately as administrator and then press Uninstall button again."
            Msg2 = sAddInCaptByApp & " - Uninstall"
        End If
        If MyMsgBox(Msg1, 2, Msg2) = 1 Then
            ThisDocument.Saved = True
            Application.Quit
        End If
    End If
End Sub

Private Sub CloseReOpenWordToDelDLL()
    Dim Doc As Document
    'Shell Application.Path & "\Word.exe  /r " & thisdocument.FullName, vbMinimizedFocus
    Dim Perc As Long
    Dim WordObj As Word.Application

    Dim ActWordObj As Word.Application
    Set ActWordObj = Application    'Deu maior estabilidade
    ThisDocument.Saved = True

    Do
        Perc = Perc + 1
        If Perc > 10 Then
            If MsgBox(IIf(IsPortg, "N|fffd|o foi poss|fffd|vel criar um novo objeto Word.Application para deletar a DLL! Tentar mais uma vez?", "Could not create a new Word.Application object to delete the DLL! Try again?"), vbOKCancel + vbCritical, IIf(IsPortg, "Falha!", "Fail!")) = vbCancel Then
                BotAcionado = 1
                Exit Sub
            End If
        End If
        Set WordObj = New Word.Application
        Application.StatusBar = WordObj.Version
        MyWait 1
    Loop Until WordObj.Documents.Count = 0

    If WordObj.Visible Then    'Isto porque no Exc 97 n|fffd|o fica oculto
        WordObj.WindowState = wdWindowStateMinimize
        DoEvents
    End If

    'WordObj.EnableEvents = False
    WordObj.DisplayAlerts = wdAlertsNone    'Isto e o loop abaixo |fffd| porque no Word 2000, talvez bug, emite alerta para abrir somente leitura...
    Do
        On Error Resume Next
        WordObj.Documents.Open ThisDocument.FullName, True, True, , "123"
    Loop While Err.Number <> 0
    WordObj.DisplayAlerts = wdAlertsAll
    On Error GoTo 0
    'WordObj.EnableEvents = True

    For Each Doc In ActWordObj.Documents
        If Doc.Name <> ThisDocument.Name Then
            Doc.Close
        End If
    Next
    For Each Doc In ActWordObj.Documents
        Doc.Saved = True
    Next
    WordObj.OnTime Now, "UnInstall"
    MyWait 1
    WordObj.Visible = True
    PleaseWait False

    Dim i As Long
    For i = 1 To 20    'Deu maior estabilidade
        ThisDocument.Saved = True
        DoEvents
    Next
    If DOCtoEXE_IsThisDocExe() Then
        lDOCtoEXE_AutoReopen = 3    'To DOCtoEXE tries to make the exit without reopen
        ThisDocument.Activate
        If Not DOCtoEXE_SyncProperties(True) Then ActWordObj.Quit Else On Error Resume Next: ThisDocument.Close False
    Else
        ActWordObj.Quit
    End If
End Sub
Attribute VB_Name = "Mod2RegEdit"
Option Explicit

Public Const REG_SZ As Long = &H1
Public Const REG_DWORD As Long = &H4
Public Const REG_BINARY As Long = &H3

Public Const HKEY_CLASSES_ROOT As Long = &H80000000
Public Const HKEY_CURRENT_USER As Long = &H80000001
Public Const HKEY_LOCAL_MACHINE As Long = &H80000002
Public Const HKEY_USERS As Long = &H80000003

Public Const KEY_ALL_ACCESS As Long = &H3F
Private Const KEY_QUERY_VALUE As Long = &H1
Public Const REG_OPTION_NON_VOLATILE As Long = 0

Private Const ERROR_MORE_DATA As Long = 234
Private Const ERROR_NO_MORE_ITEMS = 259

Public Type SECURITY_ATTRIBUTES
    nLength As Long
    #If VBA7 Then
        lpSecurityDescriptor As LongPtr
    #Else
        lpSecurityDescriptor As Long
    #End If
    bInheritHandle As Long
End Type
    
#If VBA7 Then
    Public Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long
    Public Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As LongPtr, lpdwDisposition As Long) As Long
    Public Declare PtrSafe Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As LongPtr, ByVal lpSubKey As String) As Long
    Public Declare PtrSafe Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As LongPtr, ByVal lpValueName As String) As Long
    Private Declare PtrSafe Function RegQueryValueExStr Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, ByRef lpType As Long, ByVal lpData As String, ByRef lpcbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegQueryValueExLng Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, ByRef lpType As Long, lpData As Long, ByRef lpcbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegQueryValueExByt Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, ByRef lpType As Long, lpData As Byte, ByRef lpcbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Public Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
    Private Declare PtrSafe Function RegSetValueExStr Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegSetValueExLng Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Long, ByVal cbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare PtrSafe Function RegSetValueExByt Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Byte, ByVal cbData As Long) As Long        ' Note that if you declare the lpData parameter as String, you must pass it By Value.
#Else
    Public Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
    Public Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As Long, lpdwDisposition As Long) As Long
    Public Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As Long, ByVal lpSubKey As String) As Long
    Public Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long
    Private Declare Function RegQueryValueExStr Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, ByVal lpData As String, ByRef lpcbData As Long) As Long                                      'Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegQueryValueExLng Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, lpData As Long, ByRef lpcbData As Long) As Long                                      'Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegQueryValueExByt Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, lpData As Byte, ByRef lpcbData As Long) As Long                                      'Note that if you declare the lpData parameter as String, you must pass it By Value.
    Public Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
    Private Declare Function RegSetValueExStr Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long                                  ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegSetValueExLng Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Long, ByVal cbData As Long) As Long                                  ' Note that if you declare the lpData parameter as String, you must pass it By Value.
    Private Declare Function RegSetValueExByt Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Byte, ByVal cbData As Long) As Long                                  ' Note that if you declare the lpData parameter as String, you must pass it By Value.
#End If

Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type
#If VBA7 Then
    Private Declare PtrSafe Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As LongPtr, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As LongPtr, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As FILETIME) As Long
    Private Declare PtrSafe Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As LongPtr, ByVal dwIndex As Long, ByVal lpValueName As String, lpcbValueName As Long, ByVal lpReserved As LongPtr, lpType As Long, lpData As String, lpcbData As Long) As Long
#Else
    Private Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As Long, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As FILETIME) As Long
    Private Declare Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpValueName As String, lpcbValueName As Long, ByVal lpReserved As Long, lpType As Long, lpData As String, lpcbData As Long) As Long                                            'Note that if you declare the lpData parameter as String, you must pass it By Value.
#End If

Sub FileExtAssociation(sExt As String, sAppName As String, sAppFullNameFile As String)
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
      Dim OpenKeyHdl As Long
    #End If
    Dim lRet As Long
    Dim SecurAttr As SECURITY_ATTRIBUTES

    'Create root extension subkey (.xxx)
    If GetRegValue(HKEY_CLASSES_ROOT, sExt, "", False) = "Error" Then
        RegCreateKeyEx HKEY_CLASSES_ROOT, sExt, _
                0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
        RegCloseKey OpenKeyHdl
    End If

    'Create root Application subkey about file extension (AppNameFile subkey)
    If GetRegValue(HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", "", False) = "Error" Then
        RegCreateKeyEx HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", _
                0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
        RegCloseKey OpenKeyHdl
    End If

    'Set open command value at AppNameFile subkey
    SetKeyValue HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", "", REG_SZ, """" & sAppFullNameFile & """" & " %1"

    'Define a description for the extension file as default value at AppNameFile subkey.
    SetKeyValue HKEY_CLASSES_ROOT, sAppName & "File", "", REG_SZ, sAppName & " File"

    'Set default value at extension subkey to look for commands at AppNameFile subkey
    SetKeyValue HKEY_CLASSES_ROOT, sExt, "", REG_SZ, sAppName & "File"

End Sub

#If VBA7 Then
    Function SetValueEx(ByVal hKey As LongPtr, sValueName As String, lType As Long, vlpData As Variant) As Long
#Else
    Function SetValueEx(ByVal hKey As Long, sValueName As String, lType As Long, vlpData As Variant) As Long
#End If
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
      Dim OpenKeyHdl As Long
    #End If


    Dim blpData() As Byte
    Dim llpData As Long
    Dim slpData As String

    Select Case lType
    Case REG_BINARY
        blpData = vlpData
        SetValueEx = RegSetValueExStr(hKey, _
                sValueName, _
                0&, _
                lType, _
                blpData(0), _
                UBound(blpData) - LBound(blpData) - 1)

    Case REG_SZ
        slpData = vlpData & Chr$(0)
        SetValueEx = RegSetValueExStr(hKey, _
                sValueName, _
                0&, _
                lType, _
                slpData, _
                Len(slpData))

    Case REG_DWORD
        llpData = vlpData
        SetValueEx = RegSetValueExLng(hKey, _
                sValueName, _
                0&, _
                lType, _
                llpData, _
                4)
    End Select
End Function

Sub SetKeyValue(lKey As Long, sSubKey As String, _
        sValueName As String, lType As Long, vValue As Variant)
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
      Dim OpenKeyHdl As Long
    #End If

    'open the key
    RegOpenKeyEx lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl

    'Set the value
    SetValueEx OpenKeyHdl, sValueName, lType, vValue

    'Close the key
    RegCloseKey OpenKeyHdl

End Sub

'Get Registry Value, Arguments:
'1 - Reg Key (Ex.: HKEY_LOCAL_MACHINE),
'2 - Reg SubKey (Ex.: "Software\Microsoft\Windows\CurrentVersion"),
'3 - Name of Value (Ex.:"ProgramFilesDir" or "" for default)
'4 - Convert to text like written in reg files (*.reg)
Function GetRegValue(lKey As Long, sSubKey As String, sValueName As String, ConvRegText)
    Dim sRet As String * 255  'Fixed-length strings
    Dim lRet As Long
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
      Dim OpenKeyHdl As Long
    #End If
    Dim lType As Long
    Dim lLen As Long
    Dim sDataRet As String
    Dim lDataRet As Long
    Dim abDataRet() As Byte
    Dim i As Integer
    Dim BrkLine As Long

    lRet = RegOpenKeyEx(lKey, sSubKey, 0, KEY_QUERY_VALUE, OpenKeyHdl)

    lRet = RegQueryValueExLng(OpenKeyHdl, sValueName, 0&, lType, 0&, lLen)
    If lRet And lRet <> ERROR_MORE_DATA Then
        RegCloseKey OpenKeyHdl
        GetRegValue = "Error"
        Exit Function
    End If

    Select Case lType
    Case REG_DWORD
        lRet = RegQueryValueExLng(OpenKeyHdl, sValueName, _
                0&, lType, lDataRet, lLen)
        GetRegValue = CLng(lDataRet)

        If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=dword:" & Left("00000000", 8 - Len(Hex(GetRegValue))) & Hex(GetRegValue)

    Case REG_SZ
        sDataRet = String$(lLen - 1, 0)
        lRet = RegQueryValueExStr(OpenKeyHdl, sValueName, _
                0&, lType, sDataRet, lLen)
        GetRegValue = sDataRet

        If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=" & GetRegValue

    Case Else   'REG_BINARY and others
        ReDim abDataRet(lLen)
        lRet = RegQueryValueExByt(OpenKeyHdl, sValueName, _
                0&, lType, abDataRet(0), lLen)
        GetRegValue = abDataRet

        If ConvRegText Then
            If lType = REG_BINARY Then
                GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=hex:"
                sDataRet = String$(lLen, 0)
                lRet = RegQueryValueExStr(OpenKeyHdl, sValueName, 0&, lType, sDataRet, lLen)
                BrkLine = Len(GetRegValue)
                For i = 1 To lLen
                    If BrkLine >= 77 Then
                        BrkLine = 2
                        GetRegValue = GetRegValue & "\" & Chr(10) & "  "
                    End If
                    GetRegValue = GetRegValue _
                            & IIf(Len(Hex(Asc(Mid(sDataRet, i, 1)))) = 1, "0", "") _
                            & Hex(Asc(Mid(sDataRet, i, 1))) & ","
                    BrkLine = BrkLine + 3
                Next
            Else
                If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=" & GetRegValue
            End If
        End If
    End Select
    RegCloseKey OpenKeyHdl
End Function

Function fRegEnumKey(lKey As Long, sSubKey As String, bEnumKeys As Boolean, bEnumValues As Boolean)
    #If VBA7 Then
        Dim OpenKeyHdl As LongPtr
    #Else
      Dim OpenKeyHdl As Long
    #End If
    Dim lCount As Long
    Dim sNameRet As String
    Dim lLenNameRet As Long
    Dim sDataRet As String
    Dim lLenDataRet As Long
    Dim fRetArr() As String
    Dim ft As FILETIME

    ReDim fRetArr(1, 0)

    If bEnumKeys Then    'Enumerate the keys
        If RegOpenKeyEx(lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then     'Open key
            lLenNameRet = 255: sNameRet = String$(255, 0)    'Buffering
            Do While RegEnumKeyEx(OpenKeyHdl, lCount, sNameRet, lLenNameRet, ByVal 0&, vbNullString, ByVal 0&, ft) <> ERROR_NO_MORE_ITEMS    'Enumerate the keys
                If lCount > 0 Then ReDim Preserve fRetArr(1, UBound(fRetArr, 2) + 1)
                fRetArr(0, UBound(fRetArr, 2)) = Left$(sNameRet, lLenNameRet)
                lCount = lCount + 1    'Next key
                sNameRet = String$(255, 0)
                lLenNameRet = 255
            Loop
            RegCloseKey OpenKeyHdl    'Close key
        Else
            fRegEnumKey = False    'Error when opening Key
            Exit Function
        End If
    End If

    If bEnumValues Then    'Enumerate the values
        lCount = 0
        If RegOpenKeyEx(lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl) = 0 Then     'Open key
            lLenNameRet = 255: lLenDataRet = 255: sNameRet = String$(255, 0): sDataRet = String$(255, 0)    'Buffering
            Do While RegEnumValue(OpenKeyHdl, lCount, sNameRet, lLenNameRet, 0, ByVal 0&, ByVal sDataRet, lLenDataRet) <> ERROR_NO_MORE_ITEMS
                If fRetArr(0, UBound(fRetArr, 2)) <> "" Then ReDim Preserve fRetArr(1, UBound(fRetArr, 2) + 1)
                fRetArr(0, UBound(fRetArr, 2)) = Left$(sNameRet, lLenNameRet)
                fRetArr(1, UBound(fRetArr, 2)) = Left$(sDataRet, lLenDataRet - 1)
                lCount = lCount + 1    'Next key
                lLenNameRet = 255: lLenDataRet = 255: sNameRet = String$(255, 0): sDataRet = String$(255, 0)
            Loop
            RegCloseKey OpenKeyHdl    'Close key
        Else
            fRegEnumKey = False    'Error when opening Key
            Exit Function
        End If
    End If

    fRegEnumKey = fRetArr
End Function


Attribute VB_Name = "Mod4DllRegServer"
'Obtive no VB NG mas tenho dois outros que tamb|fffd|m funcionam
#If VBA7 Then
    Private Declare PtrSafe Function LoadLibraryA Lib "kernel32" (ByVal lLibFileName As String) As LongPtr
    Private Declare PtrSafe Function CreateThread Lib "kernel32" (lThreadAttributes As Any, ByVal lStackSize As LongPtr, ByVal lStartAddress As LongPtr, ByVal lParameter As LongPtr, ByVal lCreationFlags As Long, lThreadId As Long) As LongPtr
    Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal lMilliseconds As Long) As Long
    Private Declare PtrSafe Function GetProcAddress Lib "kernel32" (ByVal hModule As LongPtr, ByVal lProcName As String) As LongPtr
    Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As LongPtr) As Long
    Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
    Private Declare PtrSafe Function GetExitCodeThread Lib "kernel32" (ByVal hThread As LongPtr, lExitCode As Long) As Long
    Private Declare PtrSafe Sub ExitThread Lib "kernel32" (ByVal lExitCode As Long)
#Else
    Private Declare Function LoadLibraryA Lib "kernel32" (ByVal lLibFileName As String) As Long
    Private Declare Function CreateThread Lib "kernel32" (lThreadAttributes As Any, ByVal lStackSize As Long, ByVal lStartAddress As Long, ByVal larameter As Long, ByVal lCreationFlags As Long, lThreadId As Long) As Long
    Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal lMilliseconds As Long) As Long
    Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lProcName As String) As Long
    Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
    Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
    Private Declare Function GetExitCodeThread Lib "kernel32" (ByVal hThread As Long, lExitCode As Long) As Long
    Private Declare Sub ExitThread Lib "kernel32" (ByVal lExitCode As Long)
#End If

'Purpose   :    This function registers and Unregisters OLE components
'Inputs    :    sFilePath                       The path to the DLL/OCX or ActiveX EXE
'               bRegister                       If True Registers the control, else unregisters control
'Outputs   :    Returns True if successful
'Author    :    Andrewb
'Date      :    04/09/2000
'Notes     :    This effectively replaces RegSvr32.exe by loading the library and
'               calling the register or unregister functions exposed by all OLE components.
'Revisions :    Updated to include code for registering ActiveX Exes.

Function RegisterServer(sFilePath As String, Optional bRegister As Boolean = True) As Boolean
    #If VBA7 Then
        Dim lLibAddress As LongPtr
        Dim lProcAddress As LongPtr
        Dim lThread As LongPtr
    #Else
        Dim lLibAddress As Long
        Dim lProcAddress As Long
        Dim lThread As Long
    #End If
    Dim lThreadId As Long
    Dim lSuccess As Long
    Dim lExitCode As Long
    Dim sRegister As String
    Const clMaxTimeWait As Long = 20000    'Wait 20 secs for register to complete
   
    On Error GoTo ExitFunc
    If Len(sFilePath) > 0 And Len(Dir(sFilePath)) > 0 Then
        'File exists
        If UCase$(Right$(sFilePath, 3)) = "EXE" Then
            'Register/Unregister ActiveX EXE
            If bRegister Then
                'Register EXE
                Shell sFilePath & " /REGSERVER", vbHide
            Else
                'Unregister ActiveX EXE
                Shell sFilePath & " /UNREGSERVER", vbHide
            End If
            RegisterServer = True
        Else
            'Register/Unregister DLL
            If bRegister Then
                sRegister = "DllRegisterServer"
            Else
                sRegister = "DllUnregisterServer"
            End If

            'Load library into current process
            lLibAddress = LoadLibraryA(sFilePath)

            If lLibAddress Then
                'Get address of the DLL function
                lProcAddress = GetProcAddress(lLibAddress, sRegister)

                If lProcAddress Then
                    'Found interface, make call to component
                    lThread = CreateThread(ByVal 0&, 0&, ByVal lProcAddress, ByVal 0&, 0&, lThreadId)
                    If lThread Then
                        'Created thread
                        lSuccess = (WaitForSingleObject(lThread, clMaxTimeWait) = 0)
                        If Not lSuccess Then
                            'Failed to register, close thread
                            Call GetExitCodeThread(lThread, lExitCode)
                            Call ExitThread(lExitCode)
                            RegisterServer = False
                        Else
                            'Register control
                            RegisterServer = True
                            Call CloseHandle(lThread)
                        End If
                    End If
                Else
                    'Object doesn't expose OLE interface
                    FreeLibrary lLibAddress
                End If
                Call FreeLibrary(lLibAddress)
            End If
        End If
    End If
ExitFunc:
    On Error GoTo 0
End Function

Sub RegisterServerShell32(sFilePath As String, Optional bRegister As Boolean = True)
'No Office 64-bit n|fffd|o aceita instalar, mas pode ser preciso desinstalar se tiver sido instalado
'antes, infelizmente, ao unregistrar via API, falha em LoadLibraryA(sFilePath) mesmo sFilPath
'esteja correto. Entao tentar aqui via shell regsrv32 em vez da fun|fffd||fffd|o RegisterServer
    If Len(sFilePath) > 0 And Len(Dir(sFilePath)) > 0 Then
        If bRegister Then
            Shell "regsvr32.exe /s """ & sFilePath & """"
        Else
            Shell "regsvr32.exe /u /s """ & sFilePath & """"
        End If
        MyWait 5
    End If
End Sub

Attribute VB_Name = "ModDOCtoEXE"
Option Explicit
Public sDOCtoEXE_ThisDocPathExe As String    'Name of the EXE file on the disk
Public sDOCtoEXE_ThisDocNameExe As String    'Path where the EXE file is found on the disk.
Public lDOCtoEXE_hWnd As Long    'Handle of a window that DOCtoEXE created in Windows specially for the VBA project watches it and take action when it fails to run for some reason, for example, misuse of Ctrl+Alt+Del.

Public lDOCtoEXE_AutoReopen As Long    'To DOCtoEXE auto reopen after all closed, set 1 for normal reopen or 2 for reopen asking privilege elevation.
Public lDOCtoEXE_WaitReopen As Long    'Wait in seconds to auto reopen.
Public sDOCtoEXE_CmdLineReopen As String    'Command line argument to be passed to the VBA project when opening or auto reopening.
Public lDOCtoEXE_AvoidAccessVBE As Long    'Set as 1 to avoid access to VBE, 2 to allow, and 0 to follow the option set when converting.
Public lDOCtoEXE_SaveNow As Long    'Set as 1 to DOCtoEXE save this project now. This useful when all data is saved in attached files. If the project is read-only or there is not to save, it will be ignored.
Public sDOCtoEXE_SaveAsExe As String    'Set a full name for a new EXE file that will be created from the open EXE with the current changes by still to save. The current EXE will be closed without the changes and the new one will be open in its place already due saved. If the project is read-only, it will be ignored.
Public sDOCtoEXE_SaveCopyAsExe As String    'Set a full name for a new EXE file that will be created from the open EXE with the current changes by still to save. The current EXE will continue open as it is and the new one will be closed duly saved with the changes. If the project is read-only, it will be ignored.
Public sDOCtoEXE_TrustDocNames As String    'List of trusted workbook names (with or without path) for DOCtoEXE allows in exclusive window. Use ';' as separator. Path will be required on all names if there is at least one path separator character '\' on the list.

'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
'" If DOCtoEXE_IsThisDocExe() function return True, moreover to indicate a converted DOC to
'" EXE, it captures and attributes values to sDOCtoEXE_ThisDocPathExe and sDOCtoEXE_ThisDocNameExe
'" public variables informed by DOCtoEXE to be used in any part of this VBA project.
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Function DOCtoEXE_IsThisDocExe() As Boolean
    Dim DOCtoEXEtmpLog As String
    Dim hFile As Long
    hFile = FreeFile
    DOCtoEXEtmpLog = ThisDocument.Path & "\DOCtoEXE.log"
    If Dir(DOCtoEXEtmpLog, vbHidden) = "" Then Exit Function
    On Error Resume Next
    Open DOCtoEXEtmpLog For Input As #hFile
    Input #hFile, sDOCtoEXE_ThisDocPathExe
    Input #hFile, sDOCtoEXE_ThisDocNameExe
    Input #hFile, sDOCtoEXE_CmdLineReopen
    Input #hFile, lDOCtoEXE_hWnd
    Close #hFile
    If Err.Number = 0 Then
        If LCase(Dir(sDOCtoEXE_ThisDocPathExe & "\" & sDOCtoEXE_ThisDocNameExe)) = LCase(sDOCtoEXE_ThisDocNameExe) _
                Then DOCtoEXE_IsThisDocExe = True
    End If
End Function


'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
'" DOCtoEXE_SyncProperties() function is used by DOCtoEXE to Synchronize properties of this
'" workbook changed at run-time. If you need to change a value of a property, you change it
'" and call this function with True in argument. If it has succces, it will return True.
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Public Function DOCtoEXE_SyncProperties(bChangingProperties As Boolean)
    Static bGettingProperties As Boolean    'True while properties are got.
    If bChangingProperties Then
        bGettingProperties = True
        Dim i As Long
        'Application.Interactive = False
        Do While bGettingProperties And i < 20
            i = i + 1
            MyWait 0.5
        Loop
        DOCtoEXE_SyncProperties = Not bGettingProperties
        lDOCtoEXE_SaveNow = 0: sDOCtoEXE_SaveAsExe = "": sDOCtoEXE_SaveCopyAsExe = ""
        'Application.Interactive = True
    Else
        DOCtoEXE_SyncProperties = Array(bGettingProperties, lDOCtoEXE_AutoReopen, _
                lDOCtoEXE_WaitReopen, sDOCtoEXE_CmdLineReopen, lDOCtoEXE_AvoidAccessVBE, _
                lDOCtoEXE_SaveNow, sDOCtoEXE_SaveAsExe, sDOCtoEXE_SaveCopyAsExe, sDOCtoEXE_TrustDocNames)
    End If
    bGettingProperties = False
End Function

'Sub MyWait(PauseSeg As Double)
'    Dim Start
'    Start = Timer
'    Do While Timer < Start + PauseSeg
'        DoEvents
'    Loop
'End Sub








Attribute VB_Name = "ModMyMsgBox"
Option Explicit
Public Const LOCALE_USER_DEFAULT& = &H400
Public Const LOCALE_SENGLANGUAGE = &H1001   'English name of language
Public Const LOCALE_SLANGUAGE = &H2   'localized name of language
Public Const LOCALE_SLIST = &HC         '  list item separator
Public Const LOCALE_SDECIMAL = &HE         '  decimal separator
Public Const LOCALE_STHOUSAND = &HF         '  thousand separator
Public Const LOCALE_ICOUNTRY = &H5         '  country code
Public Const LOCALE_ITIME = &H23        '  time format specifier
Public Const LOCALE_SDATE = &H1D        '  date separator
Public Const LOCALE_STIME = &H1E        '  time separator
#If VBA7 Then
    Private Declare PtrSafe Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
    Private Declare PtrSafe Function GetVersion Lib "kernel32" () As Long
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" Alias "WNetGetUserA" (ByVal lpName As String, ByVal lpUserName As String, lpnLength As Long) As Long
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr
#Else
    Private Declare Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
    Private Declare Function GetVersion Lib "kernel32" () As Long
    Declare Function WNetGetUser Lib "mpr.dll" Alias "WNetGetUserA" (ByVal lpName As String, ByVal lpUserName As String, lpnLength As Long) As Long
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
#End If

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128                           '  Maintenance string for PSS usage
End Type
'  dwPlatformId defines:
Private Const VER_PLATFORM_WIN32s = 0
Private Const VER_PLATFORM_WIN32_WINDOWS = 1
Private Const VER_PLATFORM_WIN32_NT = 2
#If VBA7 Then
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (lpVersionInformation As OSVERSIONINFO) As Long
#Else
    Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (ByRef lpVersionInformation As OSVERSIONINFO) As Long
#End If

Public BotAcionado As Integer
Public IsPortg As Boolean
Public Msg1 As String
Public Msg2 As String

Public Function MyMsgBox(sPrompt As String, lBut As Long, sTitle As String, Optional Xpos As Long, Optional Ypos As Long)
    With FormMyMsgBox
        .Caption = sTitle
        .Alert_Tb = sPrompt
        .lBut = lBut
        .Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
        .Email_Lb.ControlTipText = "orlando@cpap.com.br"
        .EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInCaptByApp
        .HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
        .HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
        .HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=InstAjuda", "More.asp?IdC=InstHelp")
        .Xpos = Xpos    '* Twips 'Twips usa em COM Add-in
        .Ypos = Ypos    '* Twips
        .Show  '1   '|fffd| preciso usar em COM add-in
    End With
    Unload FormMyMsgBox
    MyMsgBox = BotAcionado
End Function

Sub MyWait(PauseSeg As Double)
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        DoEvents
        Sleep 1    'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
    Loop
End Sub

Function gLocInfo(vType As Long) As String
    Dim vStr As String, vLng As Long
    Dim ret As Long
    vStr = String$(255, 0)
    vLng = 255 - 1
    ret = apiGetLocaleInfo(LOCALE_USER_DEFAULT, vType, vStr, vLng)
    If ret <> 0 Then
        gLocInfo = Left$(vStr, ret - 1)
    End If
End Function

Function SendEMailByURL(oCtrl As Object, EmailUrl As String, Subj As String, Msg As String, bCtrlError As Boolean) As Boolean
    Dim URL As String
    Dim ret As Long

    If Not oCtrl Is Nothing Then
        If oCtrl.MousePointer = fmMousePointerHourGlass Then Exit Function
        oCtrl.MousePointer = fmMousePointerHourGlass
        oCtrl.ForeColor = &H80FF&
        DoEvents
    End If

    If Subj <> "" Then                                     'Indica para montar uma URL para email
        If appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word" Then _
                appHostApp.StatusBar = IIf(IsPortg, "Preparando E-mail. Aguarde...", "Preparing Email. Wait...")

        '& in Hex
        Subj = MyReplace(Subj, "&", "%26")
        Msg = MyReplace(Msg, "&", "%26")

        'Spaces in Hex
        Subj = MyReplace(Subj, " ", "%20")
        Msg = MyReplace(Msg, " ", "%20")

        'CRLF in Hex
        Msg = MyReplace(Msg, vbCrLf, "%0D%0A")

        URL = "mailto:" & EmailUrl & "?subject=" & Subj & "&body=" & Msg

        'Launch Start command with URL (Falha no Win2000)
        'Ret = Shell(Left("Start " & URL, 460), vbHide)
    Else
        URL = EmailUrl
    End If

    If Not bCtrlError And InStr(1, URL, "#") = 0 Then
        'A vantagem do ShellExecute |fffd| que no m|fffd|todo FollowHyperlink a lingua do Navegador n|fffd|o |fffd| enviada
        'e tem que ter documento aberto. Vou usar FollowHyperlink s|fffd| quando precisar controlar erro e
        'se houver bookmark
        ShellExecute 0&, vbNullString, Left(URL, 457), vbNullString, vbNullString, vbNormalFocus
    Else
        Dim sBookmark As String
        If InStr(1, URL, "#") = 0 Then
            sBookmark = ""
        Else
            sBookmark = Mid(URL, InStr(1, URL, "#"))
            URL = Left(URL, InStr(1, URL, "#") - 1)
        End If

        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            If appHostApp.ActiveWorkbook Is Nothing Then appHostApp.Workbooks.Add
            appHostApp.ActiveWorkbook.FollowHyperlink Left(URL, 457), sBookmark, True       'DifAppMet
        Case "Microsoft Word"
            If appHostApp.ActiveDocument Is Nothing Then appHostApp.Documents.Add
            appHostApp.ActiveDocument.FollowHyperlink Left(URL, 457), sBookmark, True
        Case "Microsoft PowerPoint"
            If appHostApp.ActivePresentation Is Nothing Then appHostApp.Presentations.Add
            appHostApp.ActivePresentation.FollowHyperlink Left(URL, 457), sBookmark, True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink Left(URL, 457), sBookmark, True
        End Select
    End If
    If Err.Number = 0 Then MyWait 10
    If Subj <> "" And (appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word") Then _
            appHostApp.StatusBar = False

    If Err.Number <> 0 Then MsgBox Err.Description
    If Not oCtrl Is Nothing Then oCtrl.MousePointer = fmMousePointerCustom
    SendEMailByURL = Err.Number = 0
    Err.Clear
End Function

Function MyReplace(vText As String, vTxtFind As String, vTxtRep As String)
'Word 6.0 VBA doesn't have Replace function
    Dim lPos As Long
    lPos = 1 - Len(vTxtRep)
vStart:
    lPos = InStr(lPos + Len(vTxtRep), vText, vTxtFind)
    If lPos = 0 Or vTxtFind = "" Then
        MyReplace = vText
        Exit Function
    End If
    vText = Left(vText, lPos - 1) & vTxtRep & Right(vText, Len(vText) - lPos - Len(vTxtFind) + 1)
    GoTo vStart
End Function

Function MySplit(ByVal sString As String, Optional sDelim As String, Optional lLimit As Long = -1, Optional bCompare As Long = 0) As Variant
'Excel 97 and Word6 haven't Split function
    Dim sSplitArr() As String
    Dim lPos As Long
    Dim i As Long
    Dim R As Long

    If sString = "" Or lLimit = 0 Then
        MySplit = Array()
        Exit Function
    End If

    If sDelim = "" Then
        ReDim Preserve sSplitArr(i)
        sSplitArr(i) = sString
    Else
        lPos = InStr(1, sString, sDelim, bCompare)
        If lPos = 0 Then
            ReDim Preserve sSplitArr(i)
            sSplitArr(i) = sString
        Else
            R = 2
            Do
                ReDim Preserve sSplitArr(i)
                If R > 1 Then
                    sSplitArr(i) = Left(sString, lPos - 1)
                    sString = Mid(sString, lPos + Len(sDelim))
                Else
                    sSplitArr(i) = sString
                    sString = ""
                End If
                lPos = InStr(1, sString, sDelim, bCompare)
                R = R - 1 - 1 * (lPos > 0)
                If lLimit <> -1 And i = lLimit - 1 Then
                    sSplitArr(i) = sSplitArr(i) & IIf(R > 0, sDelim & sString, "")
                    Exit Do
                End If
                i = i + 1
            Loop While R > 0
        End If
    End If
    MySplit = sSplitArr
End Function

Function EmlMsg() As String
    Dim WinVer As String
    Dim AppVer As String
    EmlMsg = ""
    EmlMsg = EmlMsg & IIf(IsPortg, "Prezado", "Dear") & " Orlando,"
    EmlMsg = EmlMsg & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Gostaria...", "I would like...")
    EmlMsg = EmlMsg & vbCrLf & vbCrLf & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Atenciosamente,", "Regards,") & vbCrLf & vbCrLf & vbCrLf

    EmlMsg = EmlMsg & "___" & vbCrLf
    EmlMsg = EmlMsg & GetWinUserName & vbCrLf    'O acc e pp n|fffd|o tem appHostApp.UserName e Win user me parece mais

    Select Case appHostApp.Name
    Case "Microsoft Excel"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)  'DifAppMet
    Case "Microsoft Word"
        WinVer = appHostApp.System.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft PowerPoint"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft Access"
        WinVer = GetOperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    End Select

    AppVer = gLocInfo(LOCALE_ICOUNTRY)
    AppVer = IIf(AppVer = 1, "English", IIf(AppVer = 55, "Portugu|fffd|s", "Language " & AppVer))
    AppVer = appHostApp.Name & " " & dHostAppVer & " (" & AppVer & ")"
    EmlMsg = EmlMsg & WinVer & vbCrLf
    EmlMsg = EmlMsg & AppVer & vbCrLf
End Function

Public Function GetOperatingSystem() As String
    Dim Ver As Long, WinVer As Long
    Ver = GetVersion()
    WinVer = Ver And &HFFFF&
    'retrieve the windows version
    GetOperatingSystem = "Windows " & Format((WinVer Mod 256) + ((WinVer \ 256) / 100), "Fixed")
End Function

Function GetWinUserName() As String
    Dim vStr As String, ret As Long, lpName As String
    vStr = String$(255, 0)
    ret = WNetGetUser(lpName, vStr, 255)
    If ret = 0 Then GetWinUserName = Left$(vStr, InStr(vStr, Chr(0)) - 1)
End Function

Public Function IsWinNTVista() As Boolean    'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNTVista = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 0)
End Function

Public Function IsWinNT7() As Boolean    'Vista e Win7 se distinguem apenas apenas em dwMinorVersion, 0 e 1.
    Dim ThisOS As OSVERSIONINFO
    ThisOS.dwOSVersionInfoSize = Len(ThisOS)
    GetVersionEx ThisOS
    IsWinNT7 = (ThisOS.dwPlatformId = VER_PLATFORM_WIN32_NT) And (ThisOS.dwMajorVersion = 6) And (ThisOS.dwMinorVersion = 1)
End Function





Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "1Normal.ThisDocument"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = True
Attribute VB_Customizable = True
Attribute VB_Control = "Sair_Bt, 5, 6, MSForms, CommandButton"
Attribute VB_Control = "Desinstalar_Bt, 4, 7, MSForms, CommandButton"
Attribute VB_Control = "Instalar_Bt, 3, 8, MSForms, CommandButton"
Attribute VB_Control = "Exit_Bt, 2, 9, MSForms, CommandButton"
Attribute VB_Control = "UnInstall_Bt, 1, 10, MSForms, CommandButton"
Attribute VB_Control = "Install_Bt, 0, 11, MSForms, CommandButton"
Option Explicit

Private Sub Document_Open()
    Static bAvoidTwoFire As Boolean    'Avoid two fire from DOCtoEXE trying AutoMacro
    If Not bAvoidTwoFire Then bAvoidTwoFire = True Else Exit Sub

    'To complete uninstall if fail
    Dim sTempFile As String
    sTempFile = TempFolder() & "\WordTeachRibbonDllPath.tmp"
    'Ontime foi necess|fffd|rio porque um bug no Excell2000 dispara o evento apesar de
    'EnableEvents=false n|fffd|o liberando a outra execu|fffd||fffd|o do Excel para fechar
    If Dir(sTempFile) <> "" Then Application.OnTime Now() + TimeValue("00:00:01"), "UnInstall"
    
    If DOCtoEXE_IsThisDocExe() Then
        If sDOCtoEXE_CmdLineReopen = "Install" Then PleaseWaitExeIndep False: PleaseWait True: Application.OnTime Now() + TimeValue("00:00:01"), "Install"
        If sDOCtoEXE_CmdLineReopen = "UnInstall" Then PleaseWaitExeIndep False: PleaseWait True: Application.OnTime Now() + TimeValue("00:00:01"), "UnInstall"
    End If

    ButtonLanguage True
    ThisDocument.Saved = True
End Sub

Private Sub Instalar_Bt_Click()
    Install
End Sub
Private Sub Desinstalar_Bt_Click()
    UnInstall
End Sub
Private Sub Sair_Bt_Click()
    Sair
End Sub

Private Sub Install_Bt_Click()
    Install
End Sub
Private Sub UnInstall_Bt_Click()
    UnInstall
End Sub
Private Sub Exit_Bt_Click()
    Sair
End Sub


Attribute VB_Name = "UserFormInst"
Attribute VB_Base = "0{B4AABD5A-B2BC-4D76-8788-153FA784FE88}{FA217154-C9F6-4263-85B2-D4FC4B14C98A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
#If VBA7 Then
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
#Else
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
#End If
Dim EmailSubj As String
Dim HomePageUrl As String

Private Sub Instal_Bt_Click()
    If IsPortg Then
        Msg1 = "CONTRATO DE LICEN|fffd|A DE USO:" & vbCrLf & _
                "Antes de acionar o bot|fffd|o OK para efetivar a instala|fffd||fffd|o, voc|fffd| deve ler e concordar com alguns termos e condi|fffd||fffd|es abaixo relacionados. Caso n|fffd|o concorde ou n|fffd|o se enquadre com algum destes termos e condi|fffd||fffd|es, acione o bot|fffd|o Cancelar para suspender a instala|fffd||fffd|o." & vbCrLf & _
                "1 - Voc|fffd| se compromete a N|fffd|O distribuir este utilit|fffd|rio, mas agrade|fffd|o recomenda|fffd||fffd|es a amigos para uma visita ao meu site em http://cpap.com.br/orlando/ (veja link no canto esquerdo inferior deste alerta) onde eles mesmos podem baixar este e outros;" & vbCrLf & _
                "2 - Embora n|fffd|o preste suporte, |fffd| bem vindo qualquer email com sugest|fffd|es para melhoramentos, mas n|fffd|o espere resposta, pelo menos de imediato. Email de agradecimento para alimenta|fffd||fffd|o do ego tamb|fffd|m |fffd| bem vindo, afinal est|fffd| |fffd| a |fffd|nica recompensa pelas horas, neur|fffd|nios e vista despendidos frente ao computador;" & vbCrLf & _
                "3 - Voc|fffd| deve ter baixado (download) o arquivo diretamente de meu site em http://cpap.com.br/orlando/ (veja link no canto esquerdo inferior deste alerta)  e que o tamanho do arquivo em bytes em seu computador corresponde ao descrito no site. Isto |fffd| um importante ind|fffd|cio de que o arquivo n|fffd|o foi alterado por v|fffd|rus, mas s|fffd| um ind|fffd|cio, pois o seu sistema eventualmente j|fffd| pode conter v|fffd|rus ou o v|fffd|rus pode inteligentemente ter conservado o tamanho original do arquivo;" & vbCrLf & _
                "4 - Este utilit|fffd|rio |fffd| oferecido gratuitamente para pessoas f|fffd|sicas em meu site tal como est|fffd| sem nenhum tipo de garantia, n|fffd|o cabendo nenhuma reclama|fffd||fffd|o de sua parte sobre suporte e preju|fffd|zos de qualquer natureza no uso ou abuso do mesmo;" & vbCrLf & _
                "5 - Voc|fffd| assume todos os riscos resultantes do uso ou do desempenho deste utilit|fffd|rio e de qualquer servi|fffd|o de suporte;" & vbCrLf & _
                "6 - Na extens|fffd|o m|fffd|xima permitida pela legisla|fffd||fffd|o aplic|fffd|vel, me isento de todas as condi|fffd||fffd|es e garantias relacionadas a:  comercializa|fffd||fffd|o, adequa|fffd||fffd|o a uma finalidade espec|fffd|fica, aus|fffd|ncia de v|fffd|rus, respostas e resultados completos e corretos e aus|fffd|ncia de esfor|fffd|o de aprimoramento;" & vbCrLf & _
                "7 - Na extens|fffd|o m|fffd|xima permitida pela legisla|fffd||fffd|o aplic|fffd|vel, em nenhuma hip|fffd|tese eu serei respons|fffd|vel por quaisquer danos especiais, incidentais, indiretos, punitivos ou conseq|fffd|enciais (incluindo, sem limita|fffd||fffd|es, danos por: lucros cessantes, perda de informa|fffd||fffd|es confidenciais ou outras, interrup|fffd||fffd|o nos neg|fffd|cios, danos pessoais, perda de privacidade, falha no cumprimento de qualquer obriga|fffd||fffd|o (inclusive de boa f|fffd| e com cuidados razo|fffd|veis), neglig|fffd|ncia e qualquer outra perda financeira ou de qualquer natureza) resultantes do ou de qualquer forma relacionados com o uso ou inabilidade no uso deste utilit|fffd|rio;" & vbCrLf & _
                "8 - Caso a legisla|fffd||fffd|o vigente n|fffd|o permita a total isen|fffd||fffd|o acima descrita, fica ent|fffd|o minha responsabilidade limitada ao valor efetivamente pago por voc|fffd| a mim por este utilit|fffd|rio ou R10,00 (dez reais) em moeda brasileira o que for maior;" & vbCrLf & _
                "9 - Como j|fffd| frisei acima, a gratuidade deste utilit|fffd|rio se destina exclusivamente para pessoas f|fffd|sicas. Pessoas jur|fffd|dicas, sejam p|fffd|blicas ou privadas, devem adquirir uma licen|fffd|a de uso. Favor entrar em contato clicando no email orlando@cpap.com.br no canto direito inferior deste alerta;" & vbCrLf & _
                "10 - Fora das condi|fffd||fffd|es acima descritas, n|fffd|o |fffd| permitida a utiliza|fffd||fffd|o, a reprodu|fffd||fffd|o, a modifica|fffd||fffd|o ou a distribui|fffd||fffd|o n|fffd|o autorizada no todo e de partes  deste utilit|fffd|rio, estando sujeito |fffd|s penalidades da lei em vigor sobre direitos autorais. Copyright by Francisco Orlando Magalh|fffd|es Filho. Todos os direitos reservados."

        Msg2 = sAddInCaptByAppPt & " - Contrato de Licen|fffd|a de Uso"
    Else
        Msg1 = "USE LICENSE AGREEMENT:" & vbCrLf & _
                "Before to action the OK button to effective the installation, you have to read and concord with some terms and conditions that will be listed below. If you do not concord or do not fit with some of this terms and conditions, action the Cancel button to suspend the installation." & vbCrLf & _
                "1 - You commit yourself with not deliver this utility, but I thank recommendations to your friends to visit my site at http://cpap.com.br/orlando/ (see link at left down corner of this alert) where they same can download this and others ones;" & vbCrLf & _
                "2 - Although I don't offer support, it is welcome any email with suggestions to improvements, but don't wait reply, at least of immediate. Email with thanks to feed the ego is welcome too, after all this is the unique reward by hours, neurons and eyes wasted in front of the computer;" & vbCrLf & _
                "3 - You have to have downloaded the file directly from my site at http://cpap.com.br/orlando/ (see link at left down corner of this alert) and that file size in bytes on your computer correspond with described on site. This is a important indication that the file wasn't changed by virus, but only an indication, since your system eventually already can contain virus or the virus can have preserved the original file size;" & vbCrLf & _
                "4 - This utility is offered freely for home user at my site AS IS without any warranty, do not fit any claim from you about support and loss of any kind in use or abuse of the same;" & vbCrLf & _
                "5 - You assume all consequent risks of the use or of the performance of this utility and of the any support service;" & vbCrLf & _
                "6 - In maximum extension allowed by applicable legislation, I absolve myself of all the conditions and warranties related with: commercialization, adequacy to a specific purpose, virus absence, complete and correct replies, complete and correct results and effort improvement absence;" & vbCrLf & _
                "7 - In maximum extension allowed by applicable legislation, in any hypothesis I will be responsible by any special, incidental, indirect, punitive or consequential harms (including, without limitations, harms by: ceasing profits, loss of confidential data or others, interruption in businesses, personal harms, loss of privacy, fault in the fulfillment of any obligation (inclusively of good faith and with reasonable attendances), negligence and any other financial loss or of any kind) resulting of or any form related with the use or  inabilities of the use this utility;" & vbCrLf & _
                "8 - Case the current legislation do not allow the total immunity above written, it stays then my responsibility limited to the value effectively paid by you to me for this utility or R$ 10,00 (ten reais) in Brazilian currency what will be the larger;" & vbCrLf & _
                "9 - How I already emphasize above, the free of charge of this utility is exclusively to home users. Public or private companies have to acquire a use license. Please contact clicking orlando@cpap.com.br email in the right down corner of this alert;" & vbCrLf & _
                "10 - Outside above written conditions, it is not allowed the unauthorized utilization, reproduction, modification or distribution of the whole and parts of this utility, being subject to current law penalty about international author rights. Copyright by Francisco Orlando Magalh|fffd|es Filho. All rights reserved."
        Msg2 = sAddInCaptByApp & " - Use License Agreement"
    End If
    If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
    BotAcionado = 1
    Hide
End Sub

Private Sub Cancel_Bt_Click()
    BotAcionado = 3
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    Dim sStartUp As String
    Dim i As Integer
    sStartUp = sStartupPath
    For i = Len(sStartUp) - 2 To 1 Step -1
        If Mid(sStartUp, i, 1) = "\" Then Exit For
    Next
    sStartUp = UCase(Mid(sStartUp, i + 1, 255))
    Xlstart_OpB.Enabled = Not bIsCOMAddin
    AsAddIn_OpB.Value = True
    If IsPortg Then
        Caption = sAddInCaptByAppPt & " - Instala|fffd||fffd|o como " & IIf(bIsCOMAddin, "COM ", "") & "Add-in"
        Frame1.Caption = "Instalar Arquivo na Pasta: "
        Xlstart_OpB.Caption = sStartUp & ", pasta padr|fffd|o do " & sAppTarget & ", para ser carregado pelo " & sAppTarget & " ao iniciar"
        AsAddIn_OpB.Caption = "EXCLUSIVA, descrita abaixo, para ser carregado pelo " & sAppTarget & " como " & IIf(bIsCOMAddin, "COM ", "") & " add-in instalado:"
        BrowserFld_Lb.ControlTipText = "Procurar pasta"
        AllWinUsers_Chb.Caption = "Para todos os usu|fffd|rios deste Windows, inclusive os sem n|fffd|vel de administrador"
        Cancel_Bt.Caption = "Cancelar"
        Instal_Bt.Caption = "Continuar"
    Else
        Caption = sAddInCaptByApp & " - Installation as " & IIf(bIsCOMAddin, "COM ", "") & "Add-in"
        Frame1.Caption = "Install File in the Folder: "
        Xlstart_OpB.Caption = sStartUp & ", " & sAppTarget & " default folder, to be loaded by " & sAppTarget & " when starting up"
        AsAddIn_OpB.Caption = "EXCLUSIVE, described below, to be loaded by " & sAppTarget & " as installed " & IIf(bIsCOMAddin, "COM ", "") & "add-in:"
        AllWinUsers_Chb.Caption = "For all users of this Windows, inclusive the ones without level of administrator"
        BrowserFld_Lb.ControlTipText = "Search folder"
        Cancel_Bt.Caption = "Cancel"
        Instal_Bt.Caption = "Continue"
    End If

    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")

    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
    Email_Lb.Left = Width - Email_Lb.Width - (Width - InsideWidth) - 4    'Email_Lb.Left = Width - Email_Lb.Width - 8
    If Not IsWinNT("Any") Or Not bIsCOMAddin Then AllWinUsers_Chb.Enabled = False: AllWinUsers_Chb.Value = False
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = 3
End Sub

Private Sub BrowserFld_Lb_Click()
    Dim sFolderName As String

    If IsPortg Then
        Msg1 = "A menos que voc|fffd| tenha uma raz|fffd|o espec|fffd|fica para mudar a pasta para instala|fffd||fffd|o, o melhor seria usar a pasta sugerida como padr|fffd|o." & vbCrLf & vbCrLf & "Indicar outra pasta assim mesmo?"
        Msg2 = sAddInCaptByAppPt & " - Alterar Pasta para Instala|fffd||fffd|o!"
    Else
        Msg1 = "Unless you have a specific reason to change the folder for installation, the best would be to use the suggested folder as the default." & vbCrLf & vbCrLf & "Select another folder anyway?"
        Msg2 = sAddInCaptByApp & " - Change Folder for Installation!"
    End If
    If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub

    sFolderName = GetFolderName(IIf(IsPortg, "Indique a pasta para instala|fffd||fffd|o.", "Select the folder for installation."), "")
    If sFolderName <> "" Then folder_Tb.Value = sFolderName
End Sub

Function GetFolderName(sSubTitle As String, IniRootFolder As String) As String
    Dim ShAppObj, ShAppObjFld
    Const BIF_returnonlyfsdirs As Long = &H1
    Set ShAppObj = CreateObject("Shell.Application")    'From Microsoft Shell Controls And Automation library
    Set ShAppObjFld = ShAppObj.BrowseForFolder(FindWindow("ThunderDFrame", Caption), sSubTitle, BIF_returnonlyfsdirs, CStr(IniRootFolder))
    If Not ShAppObjFld Is Nothing Then GetFolderName = ShAppObjFld.Items.Item.Path
End Function

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub
Attribute VB_Name = "UserFormWait"
Attribute VB_Base = "0{D7C88F4A-227D-4E0D-B526-0EB5A63083C6}{A37C2A77-CF41-4A42-846C-C8E3596D2D58}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




INQUEST-PP=macro
