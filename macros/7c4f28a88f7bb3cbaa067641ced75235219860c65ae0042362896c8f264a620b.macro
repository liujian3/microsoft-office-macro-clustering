Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "SCSModule"
Option Explicit

' *******************************************************************************************
' *
' * @ Author: Rory Combe (rory.combe@siemens.com)
' * @ Version: 1.0
' * @ Company: Siemens Small Company Solutions
' *
' * This module contains the logic for generating an XML file for the SCS Exact Globe. The
' * XML file contains the correct Siemens Depth Structure for importing into Exact Globe.
' *
' * Letzte |fffd|nderung:
' *  30.04.2009, K.-L. Frick: Export-Pfad fix auf C:\temp gesetzt.
' *  28.05.2009, K.-L. Frick: Neue Sub StartXMLGeneratorForGlobe angelegt, das
' *                           per Tastaturk|fffd|rzel Ctrl-Shift-M gestartet werden kann
' *                           und dann die Funktion XMLGeneratorForGlobe() aufruft.
' *******************************************************************************************

'Const spStart = 1
'Const spEnde = 6

'
' Function to automate the generation of an XML file for import into EXACT Globe and
' return the name of the XML file created.
'
Function XMLGeneratorForGlobe() As String
    
    Dim myWorksheet
    Dim XMLFile
    Dim XMLFileOutput%
    Dim XMLOutputString As String
    Dim Depth As Integer
    Dim cellIndex As Integer
    Dim CCClassCode As String, MedText As String
    Dim rowIndex As Integer
    Dim firstRow As Integer
    Dim lastRow As Integer
    
    firstRow = 2
    lastRow = Worksheets(1).UsedRange.Row + Worksheets(1).UsedRange.Rows.Count - 1 'Last used row
    
    XMLFile = "Globe-DepthStructureXML_" + CStr(Year(Date)) + CStr(Format(Month(Date), "0#")) + CStr(Format(Day(Date), "0#")) + ".xml"
    
    'Open XML file for output
    XMLFileOutput = FreeFile
    Open "C:\temp\" + XMLFile For Output As #XMLFileOutput
        
    ' Access Worksheets(worksheetX)
    With Worksheets(1)
    
    ' Output content to the XML file
    XMLOutputString = "<?xml version=""1.0"" ?>" + vbNewLine _
                        + "<CostcenterClasses>" + vbNewLine
        
    For rowIndex = firstRow To lastRow
        Call GetLineText(rowIndex, CCClassCode, Depth, MedText)
        If Depth > 2 And CCClassCode <> "" And LCase$(CCClassCode) <> "zzz" And InStr(CCClassCode, "_") = 0 Then
            CCClassCode = formatXMLString(CCClassCode)
            MedText = formatXMLString(MedText)
            XMLOutputString = XMLOutputString + "<CostcenterClass>" + vbNewLine _
                                + "<ClassID>" + CStr(Depth - 2) + "</ClassID>" + vbNewLine _
                                + "<CostcenterClassCode>" + CCClassCode + "</CostcenterClassCode>" + vbNewLine _
                                + "<Description>" + MedText + "</Description>" + vbNewLine _
                                + "</CostcenterClass>" + vbNewLine
        End If
    Next rowIndex
    
    XMLOutputString = XMLOutputString + "</CostcenterClasses>"
                        
    
    End With
    
    Print #XMLFileOutput, XMLOutputString
    ' Close output XML file as we are finished
    Close #XMLFileOutput
    
    XMLGeneratorForGlobe = XMLFile
    
End Function

'
' Function to format a string by removing all invalid XML characters
'
Function formatXMLString(strReplace)
    Dim newString As String
    Dim c As String
    Dim index As Integer
                
    strReplace = Replace(strReplace, "&", "&amp;")
    strReplace = Replace(strReplace, ">", "&gt;")
    strReplace = Replace(strReplace, "<", "&lt;")
    strReplace = Replace(strReplace, """", "&quot;")
                    
    newString = ""
                    
    For index = 1 To Len(strReplace)
        c = Mid$(strReplace, index, 1)
        
        ' If character c is an extended ASCII character
        ' then replace
        If Asc(c) > 127 Then
            Select Case c
                Case "|fffd|"
                    c = "ae"
                Case "|fffd|"
                    c = "oe"
                Case "|fffd|"
                    c = "ue"
                Case "|fffd|"
                    c = "Ae"
                Case "|fffd|"
                    c = "Oe"
                Case "|fffd|"
                    c = "Ue"
                Case Else
                    c = ""
            End Select
        End If
        newString = newString & c
    Next
            
    'strReplace = Replace(strReplace, CStr(Chr(45)), "")
    'strReplace = Replace(strReplace, CStr(Chr(151)), "")
    'strReplace = Replace(strReplace, CStr(Chr(150)), "")
    'strReplace = Replace(strReplace, CStr(Chr(160)), "")

    formatXMLString = newString
    
End Function

'
' Sub to return the content of a given row in the current Excel worksheet
'
Sub GetLineText(currentRow As Integer, CostcenterClassCode As String, DepthStructure As Integer, tMed As String)
    Dim cellIndex As Integer
    
    'Access Worksheet 1
    With Worksheets(1)
        'Return text for given line
        DepthStructure = GetHierarchieTiefe(currentRow)
        For cellIndex = spStart To spEnde
            If .Cells(currentRow, cellIndex).Value <> "" Then
               CostcenterClassCode = .Cells(currentRow, cellIndex).Value
            End If
        Next cellIndex
        tMed = .Cells(currentRow, spLangtext_E).Value
    End With
End Sub


Sub StartXMLGeneratorForGlobe()
Attribute StartXMLGeneratorForGlobe.VB_Description = "Startet das Makro zum Generieren der Datei Globe-DepthStructureXML"
Attribute StartXMLGeneratorForGlobe.VB_ProcData.VB_Invoke_Func = "M\n14"
    Application.StatusBar = "Please wait, generating files ..."

    Call XMLGeneratorForGlobe
    
    Application.StatusBar = False
End Sub
Attribute VB_Name = "TG_Export"
Option Explicit

'*****************************************************************************************************
' VBA-Makros zur Erzeugung der Tiefengliederungs-Uploadfiles.
'
' Letzte |fffd|nderung:
'  15.02.2006, KLF: Ausgabe "RealDivision (GG)" in File FXS40-Stammdaten ge|fffd|ndert:
'                   Es wird nun der jeweils letzte Wert der Spalte E (GG) des TG-Excelsheets verwendet.
'  13.04.2006, KLF: Prozeduren auto_open() und auto_close() eingef|fffd|gt zum Ausblenden des Export-Buttons.
'  02.05.2006, KLF: TG-Datens|fffd|tze unterhalb eines GG-Knotens xxx000 (also nicht mehr g|fffd|ltige Eintr|fffd|ge) werden nicht mehr ausgegeben
'  27.02.2007, KLF: Anpassung an ge|fffd|nderte Struktur des Excelsheets (Umstukturierung und Entfernung |fffd|berfl|fffd|ssiger Spalten).
'  23.04.2009, KLF: - Anpassung wegen Dummy-Knoten "SIEMENS1", der nicht in den Exportfiles erscheinen soll.
'                   - Zus|fffd|tzliches Hierarchiefile SIPC mit ge|fffd|nderter Struktur f|fffd|r abgegangene Knoten, die unter ___000 h|fffd|ngen.
'  30.04.2009, KLF: Die Aufbereitung des SIPC-Hierarchiefiles wurde nochmal |fffd|berarbeitet.
'  14.12.2009, KLF: Erstellung des neuen Hierarchiefiles SIPC_NEA.
'  13.01.2010, KLF: Erstellung des neuen Hirarchiefiles f|fffd|r SG&A mit G8/G9 Elementen f|fffd|r SG&A sowie FB-Elemente f|fffd|r FinBun.
'  14.01.2010, KLF: In die SG&A Hierarchie werden nur Elemente ausgegeben, die nicht abgegangen sind (d.h. nicht unger xxx000 h|fffd|ngen).
'  19.01.2010, KLF: Korrektur SG&A Hierarchie.
'  02.02.2010, KLF: Bei Generierung der SiPc Hierarchie folgt nun per Sonderregel SEI auf Healthcare (bisher SFS).
'  22.04.2010, KLF: Ausgabe der aktuellen Version im SIPC_NEA File
'  08.06.2010, KLF: Im SIPC2 Hierarchiefile zus|fffd|tzlich den Short- und Longtext ausgeben.
'  16.06.2010, KLF: Umstellung des Ausgabeformats f|fffd|r SIPC2 Hierarchiefile: die einzelnen Felder werden mit einer
'                   vorgegebenen Feldbreite ausgegeben, der Semikolon als Felddrennzeichen entf|fffd|llt.
'  25.06.2010, KLF: Es wird eine weitere Exportdatei SIPC3 generiert, die inhaltlich identisch mit SIPC2 ist,
'                   in der aber die Daten nicht |fffd|ber die Spaltenposition definiert ausgegeben werde, sondern
'                   im CSV-Format
'  28.07.2010, KLF: Es wird eine neue Exportdatei f|fffd|r das BTA System erzeugt namens "FXS22_MEP_...".
'  16.08.2010, KLF: Im neuen BTA-File "FXS22_MEP_..." wird zus|fffd|tzlich auch die Verkn|fffd|pfung Siemens -> SIS ausgegeben.
'  17.08.2010, KLF: Ausgabe des neuen Stammdatenfiles f|fffd|r BTA: FXS20_MEP_MD-BUSS_...
'  24.10.2010, KLF: - In den BTA-Stammdatenfiles FXS20_MEP und FXS21_MEP sollen grunds|fffd|tzlich keine
'                     der folgenden Elemente ausgegeben: *TEC,*ADJ, *INV, *CON, *GOW, *GWS, *FB, *G8, *G9
'                   - In der BTA-Hierarchie FXS22_MEP werden die Ersatzentit|fffd|ten abgegangener BUs ohne das X
'                     ausgegeben, also z.B. IIA010_E anstelle von IIA010X_E.
'  27.08.2010, KLF: Im Stammdatenfile FXS20_MEP und Hierarchiefile FXS22_MEP werden f|fffd|r abgegangene Elemente
'                   keine Ersatzentit|fffd|ten mehr generiert und ausgegeben.
'  19.10.2010, KLF: Bei CIT, ELI und CFI verschiebt sich die RealBU-Spalte eins nach rechts.
'  05.05.2011, KLF: RealGG wird im Stammdatenfile FSX40 nun auch auf Hierarchietiefe=3 ausgegeben.
'  30.06.2011, KLF: Korrektur der Berechnung des NextNode f|fffd|r das SIPC2-File f|fffd|r die Divisions CIT, ELI, CFI.
'  19.07.2011, KLF: InfraCities soll in Stammdaten- und Hierarchiefile (FXS40 und FXS41) nicht in Grossbuchstaben konvertiert werden.
'  26.07.2011, KLF: Im FXS64-Stammdatenfile werden die beiden Knoten "FIN_IMO_E" und "OP_E" jetzt mit ausgegeben.
'  04.08.2011, KLF: FXS40_Stammdaten: Wert f|fffd|r Real-BU (=RealGG) von Sektoren und Divisions immer ausgeben, nicht nur f|fffd|r _E.
'  10.05.2012, KLF: |fffd|nderung in Proc ProcessSipcHierarchie: bisher sollte als Sonderlocke auf HEALTHCARE SEI folgen,
'                   nun auf INFRACITIES IOS
'  03.12.2012, DTPB: Umsetzen der Anforderung [23]
'                    Anpassung von FXS65_RD_HY und FXS64_RD_MD (Pr|fffd|fen und ausgeben fehlender RealBUs)
'  09.01.2013, DTPB: Umsetzen der Anforderung [25]
'                    Anpassung der Export-Files FXS64 & FXS65
'  07.02.2013, KLF: Neue Variable ExportFxs40_Classification eingef|fffd|hrt: Wenn sie auf TRUE gesetzt wird,
'                   dann wird im FXS40 Stammdatenfile eine zus|fffd|tzlich Spalte "Classification" ausgegeben.
'                   Diese wird zum Berechnen der TG-Reportingunits im externen Tool TG_Reporting_Units.xls verwendet.
'  13.08.2013, KLF: - Die neuen Exportdateien FXS41_HBU_HY und FXS41_HBU_BW werden mit erzeugt.
'                   - Die Ausgabe der BTA Files ist entfallen.
'  30.08.2013, KLF: Bugfix bei Ausgabeunterdr|fffd|ckung f|fffd|r vorgegebene Elemente in HBU-Hierarchie.
'  03.09.2013, KLF: - HBU_Hierarchiefile: HC_E und IC_E werden mit ausgegeben.
'                   - HBU BW Hierarchiefile: Zus|fffd|tzlich werden Kurz- Mittel- und Langtext mit ausgegeben.
'  04.09.2013, KLF: HBU-Ausgabe: Anpassung an ge|fffd|ndertes Datenformat in verstecktem Tabellemblatt HBU_data.
'  09.10.2013, KLF: HBU-BW Ausgabe: zus|fffd|tzliches Leerzeichen eingef|fffd|gt.
'  25.11.2013, TKR: FXS40 Ausgabe: Neues DO Attribut auf Basis des Mappings in neuem Sheet DOMapping eingef|fffd|hrt.
'  26.11.2013, KLF: FXS40 Ausgabe: Spaltentitel angepasst an neue Vorgabe.
'  20.12.2013, KLF: HBU-Ausgabe: neue HbuExcludeItems Liste eingebaut.
'  03.02.2014, KLF: FXS65-Exportfile ohne *DIV-Elemente.
'  17.06.2014, KLF: Gr|fffd|sse der internen Arrays von 5000 auf 10000 vergr|fffd|ssert.
'  30.07.2014, KLF: Neues Exportfile "YH070" wird ausgegeben mit TG und Langtext.
'  05.11.2014, KLF: - HBU-Hierarchie: im Sheet HBU_data gibt es den Neuen Bereich "Items to rename" in Zelle C3. Hier k|fffd|nnen TG-Items angegeben werden,
'                     die bei der Ausgabe in das HBU-Hierarchiefile umbenannt werden sollen.
'                   - Die 3 bisherigen Exportfiles "FCT_DS_SIPC_...", "FCT_DS_SIPC2_" und "FCT_DS_SipcNea_..." werden nicht mehr ausgegeben. [36]
'  21.11.2014, KLF: HBU-BW Hierarchie: neue Ausnahmeregelung f|fffd|r ELI_CG. Der Parent wird fix auf CIT_CG gesetzt.
'  08.01.2015, KLF: Logik zur SIPC Generierung komplett entfernt, kein Export mehr von File FCT_DS_BTA_... [42]
'  22.01.2015, KLF: - |fffd|nderung Dateiname Exportfiles GJ_xxx_IST_gueltige_TG... und ...PTG ... [52].
'                   - In allen Dateinamen wurde das Format f|fffd|r die akt.Periode umgestellt von Pxx-YYYY nach YYYY-Pxx [48]
'                   - Die Berechnung und Ausgabe der SG&A Hierarchie (File FXS41_DS_RH_....csv) ist entfallen. [46]
'  02.02.2015, KLF: Die doppelte Ausgabe von Daten im FXS65 Exportfile f|fffd|r die RealDivision Hierarchie wird verhindert. [51]
'                   Dazu werden die Daten in einem neuen Array zwischengespeichert und bei der Ausgabe dagegen gepr|fffd|ft.
'  24.07.2015, KWA: - Kleinere |fffd|nderungen: Codenamen f|fffd|r die im Code verwendeten Bl|fffd|tter vergeben (z. B. "wksTG")
'                   - Sortierreihenfolge f|fffd|r die Divisions eingebaut gem|fffd||fffd| Anforderung Sebastian Kahl vom 21.11.2014
'*********************************************************************************************************************************



'*****************************************************************************************************
'Diese Konstanten-Definitionen sind jeweils vom User anzupassen:

'- Bezeichnung des Gesch|fffd|ftsjahres, f|fffd|r das die Tiefengliederung gedacht ist, z.B. "GJ_2007_08_FC".
'  Dies wird verwendet um den Dateinamen der generierten Uploadfiles zu berechnen

Const Geschaeftsjahr = "GJ_2018_IST"
Const AktuellePeriode = "2018-P03"    'Das Format YYYY-PMM wird f|fffd|r das Mapping des DO-Attributs ben|fffd|tigt

'- Die Versionsbezeichnung wird zur Generierung der Dateinamen der Exportfiles verwendet
Const Version = "V310"

Const ExportFxs40_Classification = False    'Wenn TRUE, dann wird im FXS40 Stammdatenfile hinten
                                            'zus|fffd|tzlich die Spalte "Classification" ausgegeben
'*****************************************************************************************************




'---------------------------------------------------------------------------------
' AB HIER NICHTS MEHR |fffd|NDERN !!!

Public Const spStart = 1
Public Const spEnde = 6
Public Const spGG = 4
Public Const spKurztext_E = 7
Public Const spLangtext_E = 8
Public Const spDienstLeistungsGG = 10
Public Const spCheckTG = 17
Public Const spCheckPTG = 18
Public DateinamePfad As String

Const maxZeilen = 10000
Const constFIELD = "3"
Const constFIELDPTgl = "3"
Const constHSTEP = "3" + ";;;"
Const constHSTEP2 = "3" + ";;"
Const FT = ";"
Const constLEFTK = ""
Const Bereich = 11
Const GGuPGG = 16
Const RealGG = 13
Const GG999 = 15
Const constFieldShortText = 7
Const constFieldLongText = 8
Const spClassification = 9
Const MAX_HIER_LEVEL = 10             ' KWA 24.07.2015

Dim GgParentArrCount As Integer
Dim GgParentArr(maxZeilen) As String  ' Hierin merken wir uns alle bisher schon ausgegebenen Parents in der GG-Hierarchie. _
                                        Dadurch k|fffd|nnen wir dann checken, ob ein Parent zum ersten mal auftaucht, um nur dann den _
                                        Short- Mittel- und Langtext mit auszugeben.
Dim RealGgArrCount As Integer
Dim RealGgArr(maxZeilen) As String    ' Hierin merken wir uns alle bisher schon ausgegebenen GG-Werte f|fffd|r die GG-Hierarchie. _
                                        Damit wird dann gecheckt, ob ein GG-Wert bereits schon einmal ausgegeben wurde, um eine _
                                        wiederholte Ausgabe zu verhindern.

Dim arrHBU(maxZeilen, 10) As String   ' Hierin bauen wir die HBU Hierarchiestruktur auf.
Dim AnzHBUNodes As Integer            ' Anzahl g|fffd|ltiger Eintr|fffd|ge im HBU Array.

Dim debugSwitch As Boolean



Sub auto_open()
    'Ausblenden des Export-Buttons, falls kein Zugriff auf das Zielverzeichnis auf dem
    'Gruppenlaufwerk besteht.
    
    Dim FH As Integer
    
    On Error GoTo Err_Handler
    
    DateinamePfad = ActiveWorkbook.Path + "\uploadfiles\"
    
    FH = FreeFile
    Open DateinamePfad + "dummy.txt" For Output As #FH
    Close #FH
    Kill DateinamePfad & "dummy.txt"
    
    If (wksTG.Shapes("BtnExport").Visible = False) Then
        wksTG.Shapes("BtnExport").Visible = True
    End If
    
Exit_Sub:
    On Error Resume Next
    wksTG.Range("A1:A1").Select
    Exit Sub
    
Err_Handler:
    'Wenn beim Zugriff auf das Gruppenlaufwerk ein Fehler auftritt,
    'dann den Export-Button ausblenden.
    DateinamePfad = "C:\temp\"

    If (wksTG.Shapes("BtnExport").Visible = True) Then
        wksTG.Shapes("BtnExport").Visible = False
    End If
    Resume Exit_Sub
End Sub 'auto_open()


Sub auto_close()
    On Error Resume Next
    If (wksTG.Shapes("BtnExport").Visible = True) Then
        wksTG.Shapes("BtnExport").Visible = False
    End If
    wksTG.Range("A1:A1").Select
    Exit Sub
End Sub 'auto_close()



' Hauptfunktion, die die Dateien erzeugt
Sub GeneriereUploadDateien()
    Dim zeIndex As Integer, HierarchieTiefe As Integer, Parent As String
    Dim StammOutput_E As String, YH070Output As String
    Dim StammOutput_E_Real As String
    Dim HierOutput As String, HbuOutput As String, HbuParent As String, HbuChild As String
    Dim HierTglOutput_E As String
    Dim SAS_TGOutput As String
    Dim RealGGHierOut As String
    Dim constLANGU As String
    
    
    Dim File_Nr_Hier%, File_Nr_Stamm%, File_Nr_PTglHier%, File_Nr_PTglStamm%, File_Check_TG%
    Dim File_Check_PTG%, File_SAS_TG%, FileRealGgHier%, FileRealGgStamm%, FileHBU%, FileHBU_BW%
    Dim FileDBG%, FileYH070%
    
    Dim KorrektesL|fffd|nderk|fffd|rzel As Boolean
    Dim ParentShortText As String
    Dim ParentMedText As String
    Dim ParentOld As String
    Dim SliceName As String
    Dim tempInt As Integer, i As Integer, j As Integer
    Dim tempStr As String
    Dim ParentRealGg As String, ParentRealGgOld As String
    Dim StammRealGG As String
    Dim strCellValue As String
    Dim strOldCellValue As String
    Dim strRealBuCellValue As String
    Dim intRealBuCellColor As Integer
    Dim TempTxt As String
    Dim HbuExcludeDivisions As String, HbuExcludeItems As String, HbuRenameItems As String
    Dim HbuExcludeItemsArr() As String, HbuRenameItemsArr() As String, HbuArrIdx As Integer, skipHbuElement As Boolean
    Dim HbuHierTiefe As Integer
    Dim DoAttribut As String 'Hier wird der Mapping Wert f|fffd|r das DO Attribut gespeichert
    
    Dim HbuIdx As Integer
    Dim HierLevelParentID(MAX_HIER_LEVEL) As String 'Hier merken wir uns den Namen des aktuelle Parents je Hierarchielevel
    Dim HbuDivisionStart As Integer     'Start einer Division, wird zum Sortieren ben|fffd|tigt.
    Dim aktDivision As String
    Dim aktItem As String
    Dim aktPeriod As Long
    
    Dim sInfoObject, sNodeName  'Objekte zur formatierten Ausgabe
    Dim sShortText, sMediumText, sLongText  'Objekte zur formatierten Ausgabe
    Dim TabChar As String, sTemp As String
    
    
    On Error GoTo Err_Handler
    
    DateinamePfad = ActiveWorkbook.Path + "\uploadfiles\"
    strOldCellValue = "..."
    KorrektesL|fffd|nderk|fffd|rzel = False
    GgParentArrCount = 0
    RealGgArrCount = 0

    debugSwitch = False
    TabChar = Chr(9)
       
    aktDivision = ""
    
    Call InitHierarchieArrays
    
    HbuIdx = 2
        
    Call OpenOutputfiles( _
            File_Nr_Hier, FileHBU, FileHBU_BW, _
            File_Nr_Stamm, File_Check_TG, File_Check_PTG, File_SAS_TG, FileRealGgHier, FileRealGgStamm, _
            FileDBG, FileYH070 _
        )
    
    
    Application.StatusBar = "Exportdateien werden generiert ..."
    'Application.Cursor = xlWait
    
    HbuExcludeDivisions = wksHBU.Range("C1")
    HbuExcludeItems = wksHBU.Range("C2")
    HbuExcludeItemsArr = Split(HbuExcludeItems, ",")
    
    HbuRenameItems = wksHBU.Range("C3")
    HbuRenameItemsArr = Split(HbuRenameItems, ",")

    'aktPeriod = Right(AktuellePeriode, 4) + "0" + Left(Replace(AktuellePeriode, "P", ""), 2)
    aktPeriod = Left(AktuellePeriode, 4) + "0" + Right(Replace(AktuellePeriode, "P", "0"), 2)
     
    With wksTG
        HierarchieTiefe = GetHierarchieTiefe(3)
        ' Erste Kopfzeile schreiben
            
        ' Check_TG Eintrag f|fffd|r SIEMENS erstellen
        If .Cells(3, spCheckTG).Value <> "X" Then Print #File_Check_TG, .Cells(3, HierarchieTiefe).Value
        If .Cells(3, spCheckPTG).Value <> "X" Then Print #File_Check_PTG, .Cells(3, HierarchieTiefe).Value
        
        ' Gesamtes Hierarchiesheet durchlaufen
        zeIndex = 4
        Do
          'If zeIndex = 87 Then
          '  Debug.Print ""
          'End If
           
          HierarchieTiefe = GetHierarchieTiefe(zeIndex)
          If HierarchieTiefe = 0 Then GoTo End_Do_Loop
          
          Parent = GetParent(zeIndex, HierarchieTiefe)
          '02.02.2010, KLF: Siemens000 erg|fffd|nzt
          If ((UCase(Parent) = "SIEMENS1") Or (UCase(Parent) = "Siemens000")) Then
              'Dies sind nur ein DUMMY-Knoten, umbenennen in SIEMENS
              Parent = "SIEMENS"
              'auch f|fffd|r die Sipc TG ummappen
              HierLevelParentID(2) = "SIEMENS"
          End If
          
          Application.StatusBar = "   Hierarchietiefe: " & HierarchieTiefe & ", Parent: " & Parent
          'Debug.Print "zeIndex:" & zeIndex, "TG-Item: " & .Cells(zeIndex, HierarchieTiefe).Value & ", HierarchieTiefe:" & HierarchieTiefe, "Parent:" & Parent
          
          '25.11.2013, TKR Ausgabe eines neuen DO Attributs
          DoAttribut = GetDoAttribut(.Cells(zeIndex, HierarchieTiefe).Value, aktPeriod)
    
          
          If Parent <> ParentOld Then
            'Es gibt einen neuen Parent
            Call GetParentText(zeIndex, HierarchieTiefe, ParentShortText, ParentMedText)
            ParentOld = Parent
            If HierarchieTiefe <= 4 Then
                ParentRealGg = Parent
                'Debug.Print "ParentRealGg:" & ParentRealGg
            End If  'If HierarchieTiefe <= 4
            If (HierarchieTiefe > 4) And (Len(Parent) = 3) Then
                ParentRealGg = Parent
                'Debug.Print "New ParentRealGg:" & Parent
            End If  'If HierarchieTiefe <= 4
            HierLevelParentID(HierarchieTiefe - 1) = Parent
            
            'Die h|fffd|heren Hierarchieparents bereinigen
            For tempInt = HierarchieTiefe To MAX_HIER_LEVEL
                HierLevelParentID(tempInt) = ""
            Next tempInt
          End If    'If Parent <> ParentOld
          
          'Debug.Print "HierarchieTiefe:" & HierarchieTiefe & ", HierLevelParentID(" & (HierarchieTiefe - 1) & "): " & HierLevelParentID(HierarchieTiefe - 1) & " - HierLevelParentID(" & HierarchieTiefe & "): " & HierLevelParentID(HierarchieTiefe)
          
          'Wenn wir uns auf Division-Level (also 3) befinden, dann checken wir, ob grade eine neue Division beginnt.
          'Wenn ja dann lassen wir das HBU-Array f|fffd|r die vorausgegangene Division sortieren.
          If (HierarchieTiefe = 3) Then
            'Gilt nur f|fffd|r echte Divisions (d.h. 3 Zeichen lang), nicht aber z.B. f|fffd|r IN_E
            If (Len(.Cells(zeIndex, HierarchieTiefe).Value) = 3) Then
                If (.Cells(zeIndex, HierarchieTiefe).Value <> aktDivision) Then
                    'Wir brauchen nur sortieren, wenn dies nicht die aller erste Division ist
                    If (aktDivision <> "") Then
                        Call DbgWriteArrHBU(FileDBG)
                        Call QuickSort(arrHBU, 0, HbuDivisionStart, AnzHBUNodes)
                    End If
                    
                    'Wir merken uns den Startindex der neuen Division
                    HbuDivisionStart = HbuIdx
                    
                    'Und wir merken uns den Namen der aktuellen Division
                    '02.02.2010, KLF: Bugfix
                    'OLD: aktDivision = .Cells(zeIndex, HierarchieTiefe).Value <> aktDivision
                    aktDivision = .Cells(zeIndex, HierarchieTiefe).Value
                    
                End If  'If (.Cells(zeIndex, HierarchieTiefe).Value <> aktDivision)
            End If  'If (Len(.Cells(zeIndex, HierarchieTiefe).Value) = 3)
          End If    'If (HierarchieTiefe = 3)
          
          
          'Wir merken uns den jeweils letzten aufgetretenen GG-Wert aus Spalte E, um ihn
          'als "RealDevision (GG)" im FXS40-Stammdatenfile ausgeben zu k|fffd|nnen
          '05.05.2011, KLF: RealGG wird nun aus Spalte M gelesen
          'StammRealGG = .Cells(zeIndex, (RealGG)).Value
          
          If HierarchieTiefe >= 4 Then
            '19.10.2010, KLF: Bei CIT, ELI und CFI verschiebt sich die RealBU-Spalte eins nach rechts
            If ((Parent = "CIT") Or (Parent = "ELI") Or (Parent = "CFI")) Then
                If Trim(.Cells(zeIndex, (spGG + 1)).Value) <> "" Then
                    StammRealGG = .Cells(zeIndex, (spGG + 1)).Value
                End If
            Else
                If Trim(.Cells(zeIndex, spGG).Value) <> "" Then
                    StammRealGG = .Cells(zeIndex, spGG).Value
                End If
            End If  'Else, If (Parent <> "CIT")
          End If    'If HierarchieTiefe >= 4
          
          ' .Cells(zeIndex, 1).Value = HierarchieTiefe
          If HierarchieTiefe > 0 Then
            
            'Slice-Name merken
            If (HierarchieTiefe < 3) Then
                SliceName = ""
            ElseIf (HierarchieTiefe = 3) And (Right(UCase(.Cells(zeIndex, HierarchieTiefe).Value), 2) = "_E") Then
                SliceName = UCase(.Cells(zeIndex, HierarchieTiefe).Value)
            ElseIf (HierarchieTiefe = 3) And (Right(UCase(.Cells(zeIndex, HierarchieTiefe).Value), 2) <> "_E") And (SliceName = "") Then
                SliceName = "SIE_E"
            End If
            
            'HBU-Ausgabestring berechnen
            'Die Daten sollen nur ausgegeben werden, wenn die aktuelle Division nicht in der Exklude-Liste ist.
            'Debug.Print "aktDivision: " & aktDivision & ", Parent: " & Parent & ", Item: " & .Cells(zeIndex, HierarchieTiefe).Value
    
            'HBU
            If (HierarchieTiefe < 3) Then
                If (UCase(.Cells(zeIndex, HierarchieTiefe).Value) <> "SIEMENS1") Then
                    HbuParent = "HS1_WORLD"
                    HbuChild = .Cells(zeIndex, HierarchieTiefe).Value
                    HbuHierTiefe = HierarchieTiefe
                Else
                    HbuChild = ""
                End If
            Else  'If (HierarchieTiefe < 3)
                'Wenn die aktuelle Division und das aktuelle TG-Element nicht in der Exclude-Liste ist, dann ausgeben, sonst |fffd|berspringen
                'If ((InStr(HbuExcludeDivisions, aktDivision) = 0) Or (aktDivision = "") _
                '    Or (Right(.Cells(zeIndex, HierarchieTiefe).Value, 2) = "_E") Or .Cells(zeIndex, HierarchieTiefe).Value <> "SIEMENS1") Then
                If (((aktDivision = "") Or (InStr(HbuExcludeDivisions, aktDivision) = 0) Or (Right(.Cells(zeIndex, HierarchieTiefe).Value, 2) = "_E")) _
                    And (.Cells(zeIndex, HierarchieTiefe).Value <> "SIEMENS1")) Then
                        
                    If (Right(Parent, 3) = "000") Then
                        Select Case Len(.Cells(zeIndex, HierarchieTiefe).Value)
                            Case 6
                                HbuParent = Left(.Cells(zeIndex, HierarchieTiefe).Value, 3) + "_CG"
                                HbuHierTiefe = 4
                            Case 8
                                HbuParent = Left(.Cells(zeIndex, HierarchieTiefe).Value, 6)
                                HbuHierTiefe = 5
                            Case 10
                                HbuParent = Left(.Cells(zeIndex, HierarchieTiefe).Value, 8)
                                HbuHierTiefe = 6
                            Case Else
                                HbuParent = "???"
                        End Select
                    Else    ' If (Right(Parent, 3) = "000")
                        If (Parent = "SIEMENS") Then
                            HbuParent = "HS1_WORLD"
                        Else
                            HbuParent = UCase(Parent)
                        End If
                        If Len(Parent) = 3 Then
                            HbuParent = HbuParent + "_CG"
                        End If
                        HbuHierTiefe = HierarchieTiefe
                    End If  ' Else, If (Right(Parent, 3) = "000")
    
                    If (.Cells(zeIndex, 22).Value = "X") Or (.Cells(zeIndex, HierarchieTiefe).Value = "ZZZ") Then
                        HbuChild = ""
                    Else
                        HbuChild = UCase(.Cells(zeIndex, HierarchieTiefe).Value)
                    End If
                    If Len(HbuChild) = 3 Then
                        HbuChild = HbuChild + "_CG"
                    End If
                    
                Else
                    HbuParent = ""
                    HbuChild = ""
                End If  ' If (InStr(HbuExcludeDivisions, aktDivision) = 0)
            End If  'Else, If (HierarchieTiefe < 3)
            
            'Checken, ob eines der Elemente in HbuExcludeItemsArr sich mit dem aktuelle HbuParent oder HbuChild dekt.
            'Falls JA dann dieses Element nicht in die HBU ausgeben.
            skipHbuElement = False
            For HbuArrIdx = 0 To UBound(HbuExcludeItemsArr)
                If ((Len(HbuChild) >= Len(HbuExcludeItemsArr(HbuArrIdx))) _
                    And (InStr(HbuChild, HbuExcludeItemsArr(HbuArrIdx)) > 0)) Then
                    skipHbuElement = True
                    Exit For
                End If
                If ((Len(HbuParent) >= Len(HbuExcludeItemsArr(HbuArrIdx))) _
                    And (InStr(HbuParent, HbuExcludeItemsArr(HbuArrIdx)) > 0)) Then
                    skipHbuElement = True
                    Exit For
                End If
            Next HbuArrIdx
                    
            'Checken, ob wir HBU-Elemente umbenennen m|fffd|ssen HbuRenameItemsArr
            For HbuArrIdx = 0 To UBound(HbuRenameItemsArr) Step 2
                If (HbuChild = Trim(HbuRenameItemsArr(HbuArrIdx)) And (Len(Trim(HbuRenameItemsArr(HbuArrIdx + 1))) > 0)) Then
                    HbuChild = Trim(HbuRenameItemsArr(HbuArrIdx + 1))
                    Exit For
                End If
                If (HbuParent = Trim(HbuRenameItemsArr(HbuArrIdx)) And (Len(Trim(HbuRenameItemsArr(HbuArrIdx + 1))) > 0)) Then
                    HbuParent = Trim(HbuRenameItemsArr(HbuArrIdx + 1))
                    Exit For
                End If
            Next HbuArrIdx
            
            '21.11.2014, KLF: neue Ausnahmeregelung f|fffd|r ELI_CG. Der Parent wird fix auf CIT_CG gesetzt
            If (HbuChild = "ELI_CG") Then
                HbuParent = "CIT_CG"
            End If
            
            '0:NodeName, 1:Parent-Name, 2:Parent-ID, 3:FirstChild-Name, 4:FirstChild-ID, 5:NextNode-Name, 6:NextNode-ID, 7: HierarchieLevel
            If ((HbuChild <> "") And (skipHbuElement = False)) Then
    '            If (Left(HbuChild, 3) = "ELI") Then
    '                Debug.Print "HbuIdx: " & HbuIdx - 1 & ", C: " & arrHBU(HbuIdx - 1, 0) & ", P: " & arrHBU(HbuIdx - 1, 1) & ", HT: " & arrHBU(HbuIdx - 1, 7)
    '            End If
                
                arrHBU(HbuIdx, 0) = HbuChild                                      'NodeName
                arrHBU(HbuIdx, 1) = HbuParent                                     'Parent-Name
                arrHBU(HbuIdx, 4) = "0"                                           '4:FirstChild-ID
                arrHBU(HbuIdx, 6) = "0"                                           '6:NextNode-ID
                arrHBU(HbuIdx, 7) = CStr(HbuHierTiefe)                            'Hierarchietiefe
                arrHBU(HbuIdx, 8) = .Cells(zeIndex, constFieldShortText).Value    '8:ShortText
                arrHBU(HbuIdx, 9) = .Cells(zeIndex, constFieldLongText).Value     '9:LongText
    
                If (debugSwitch = True) Then
                    Print #FileDBG, "Add to arrHBU(" & HbuIdx & ": N:" & HbuChild & ", P:" & HbuParent & ", HT:" & CStr(HierarchieTiefe)
                End If
                
                HbuIdx = HbuIdx + 1
                
                HbuOutput = constHSTEP + HbuParent + FT + HbuChild
                'HBU Hierarchie nur ausgeben, wenn ein g|fffd|ltiger Child vorhanden ist
                'debug.Print HbuOutput
                Print #FileHBU, HbuOutput
            End If  'If ((HbuChild <> "") And (skipHbuElement = False))
            
    
                
    
            
            '19.07.2011, KLF: InfraCities soll nicht in Grossbuchstaben konvertiert werden
            If (UCase(Parent) = "INFRACITIES") Then
                HierOutput = constHSTEP + Parent
            Else
                HierOutput = constHSTEP + UCase(Parent)
            End If
            
            If (UCase(.Cells(zeIndex, HierarchieTiefe).Value) = "INFRACITIES") Then
                HierOutput = HierOutput + FT + .Cells(zeIndex, HierarchieTiefe).Value
            Else
                HierOutput = HierOutput + FT + UCase(.Cells(zeIndex, HierarchieTiefe).Value)
            End If
            
                    
            
            ' Check_TG Eintrag erstellen
            If .Cells(zeIndex, spCheckTG).Value <> "X" Then Print #File_Check_TG, .Cells(zeIndex, HierarchieTiefe).Value
            If .Cells(zeIndex, spCheckPTG).Value <> "X" Then Print #File_Check_PTG, .Cells(zeIndex, HierarchieTiefe).Value
            
            If (HierarchieTiefe <= 3) Then
                SAS_TGOutput = UCase(.Cells(zeIndex, HierarchieTiefe).Value) + Chr(59) + Chr(59) + Chr(59) + Chr(59)
            Else
                SAS_TGOutput = Mid(UCase(.Cells(zeIndex, HierarchieTiefe).Value), 1, 3) + Chr(59) + Mid(UCase(.Cells(zeIndex, HierarchieTiefe).Value), 4, 3) + Chr(59) _
                    + Mid(UCase(.Cells(zeIndex, HierarchieTiefe).Value), 7, 2) + Chr(59) + Mid(UCase(.Cells(zeIndex, HierarchieTiefe).Value), 9, 2) + Chr(59)
            End If
            SAS_TGOutput = SAS_TGOutput + UCase(.Cells(zeIndex, HierarchieTiefe).Value) + Chr(32) + .Cells(zeIndex, spLangtext_E).Value + Chr(59) _
                + "" + Chr(59) _
                + .Cells(zeIndex, spCheckTG) + Chr(59) _
                + .Cells(zeIndex, spCheckPTG)
            
            ' Stammdaten und Texte an Hierarchie-Zeile anh|fffd|ngen
            '19.07.2011, KLF: InfraCities soll nicht in Grossbuchstaben konvertiert werden
            If (UCase(.Cells(zeIndex, HierarchieTiefe).Value) = "INFRACITIES") Then
                StammOutput_E = .Cells(zeIndex, HierarchieTiefe).Value
                StammOutput_E_Real = .Cells(zeIndex, HierarchieTiefe).Value
            Else
                StammOutput_E = UCase(.Cells(zeIndex, HierarchieTiefe).Value)
                StammOutput_E_Real = UCase(.Cells(zeIndex, HierarchieTiefe).Value)
            End If
            YH070Output = StammOutput_E + TabChar + .Cells(zeIndex, spLangtext_E).Value
            
            StammOutput_E = StammOutput_E + FT + "EN" + FT + .Cells(zeIndex, spKurztext_E).Value + FT + .Cells(zeIndex, spLangtext_E).Value + FT + .Cells(zeIndex, spLangtext_E).Value + FT + .Cells(zeIndex, Bereich).Value + FT + .Cells(zeIndex, GGuPGG).Value + FT + .Cells(zeIndex, RealGG).Value + FT + .Cells(zeIndex, GG999).Value + FT + SliceName + FT + UCase(.Cells(zeIndex, HierarchieTiefe).Value) + FT + .Cells(zeIndex, Bereich).Value
            
            '15.02.2006: RealGG f|fffd|r Stammdatenfile ist der Wert der GG-Spalte (Spalte E bzw 5) oder,
            'falls die Spalte in der aktuellen Zeile leer ist, der letzte in den dar|fffd|berliegenden Zeilen angegebene Wert
            If ((HierarchieTiefe >= 4) And (Len(.Cells(zeIndex, HierarchieTiefe).Value) >= 6)) Then
                StammOutput_E = StammOutput_E + FT + StammRealGG
            
            '05.05.2011, KLF:
            'ElseIf (HierarchieTiefe <= 3) And (Right(.Cells(zeIndex, HierarchieTiefe).Value, 2) = "_E") Then
            '04.08.2011, KLF: Wert f|fffd|r Real-BU (=RealGG) immer ausgeben, nicht nur f|fffd|r _E
            ElseIf (HierarchieTiefe <= 3) Or _
                   ((.Cells(zeIndex, HierarchieTiefe).Value = "CIT") Or _
                   (.Cells(zeIndex, HierarchieTiefe).Value = "ELI") Or _
                   (.Cells(zeIndex, HierarchieTiefe).Value = "CFI") Or _
                   (.Cells(zeIndex, HierarchieTiefe).Value = "InfraCities")) Then
                StammOutput_E = StammOutput_E + FT + .Cells(zeIndex, RealGG).Value
            End If
    
            If (ExportFxs40_Classification = True) Then
                StammOutput_E = StammOutput_E + FT + Cells(zeIndex, spClassification).Value + FT + DoAttribut
            Else
                StammOutput_E = StammOutput_E + FT + DoAttribut
            End If
    
            StammOutput_E_Real = StammOutput_E_Real + FT + "EN" + FT + .Cells(zeIndex, spKurztext_E).Value + FT _
                               + .Cells(zeIndex, spLangtext_E).Value + FT + .Cells(zeIndex, spLangtext_E).Value
            
            '<<< 02.05.2006, KLF: TG-Datens|fffd|tze unterhalb eines GG-Knotens xxx000 (also nicht mehr g|fffd|ltige Eintr|fffd|ge) werden nicht mehr ausgegeben
            If ((HierarchieTiefe < 4) Or (Right$(StammRealGG, 3) <> "000")) Then
                'Dummy-Zeile SIEMENS1 nicht ausgeben
                If (UCase(.Cells(zeIndex, HierarchieTiefe).Value) <> "SIEMENS1") Then
                    Print #File_Nr_Stamm, StammOutput_E
                    Print #FileYH070, YH070Output
                End If
            End If
            '>>> 02.05.2006
            
            If (UCase(.Cells(zeIndex, HierarchieTiefe).Value) <> "SIEMENS1") Then
                ' File_SAS_TG ausgeben
                Print #File_SAS_TG, SAS_TGOutput
                ' Hierarchie ausgeben
                Print #File_Nr_Hier, HierOutput
            End If
    
            strCellValue = UCase(.Cells(zeIndex, HierarchieTiefe).Value)
            strRealBuCellValue = .Cells(zeIndex, 13).Value
            intRealBuCellColor = .Cells(zeIndex, 13).Font.ColorIndex
            RealGGHierOut = "3" + FT + FT + UCase(ParentRealGg) + FT + FT + strCellValue
    
            'evtl. Real-GG ausgeben.
            'Hierarchie nur ausgeben, wenn Child gr|fffd|sser 3 stellig und nicht l|fffd|nger als 6 stellig ist, oder wenn wir
            'uns auf Hierarchiestufe 2 befinden.
            'If ((Len(.Cells(zeIndex, HierarchieTiefe).Value) > 3) And (Len(.Cells(zeIndex, HierarchieTiefe).Value) <= 6)) Or (HierarchieTiefe < 3) Then
            '26.07.2011, KLF: FIN_IMO_E und OP_E sollen mit ausgegeben werden im Stammdatenfile.
            '03.12.2012, DTPB: Umsetzen der Anforderung [23] - Anpassung von FXS65_RD_HY und FXS64_RD_MD (Pr|fffd|fen und ausgeben fehlender RealBUs)
            '09.01.2013, DTPB: Umsetzen der Anforderung [25] - Anpassung der Export-Files FXS64 & FXS65
            If (((Len(strCellValue) <= 6) Or (HierarchieTiefe < 3)) And (Right$(strCellValue, 2) <> "_E")) Or _
               (strCellValue = "FIN_IMO_E") Or _
               (strCellValue = "OP_E") Then
               
               'Rote bzw. gel|fffd|schte Real BUs sollen nicht mit exportiert werden
               If (intRealBuCellColor <> 3) Then
                    'Zeile mit FIN_IMO_E und OP_E |fffd|berspringen
                    '03.02.2014, KLF: *DIF nicht exportieren
                    If (strCellValue <> "FIN_IMO_E") And (strCellValue <> "OP_E") And (Right(strCellValue, 3) <> "DIF") Then
                        If GGParentIsNew(ParentRealGg) Then
                            RealGGHierOut = RealGGHierOut + FT + FT + ParentRealGg + FT + ParentRealGg + FT + ParentRealGg
                        End If
                        
                        'Zeile mit SIEMENS1 |fffd|berspringen
                        If (UCase(strCellValue) <> "SIEMENS1") Then
                            'Sonderbehandlung bei CIT, ELI und CFI
                            If (strCellValue <> "CIT" And strCellValue <> "ELI" And strCellValue <> "CFI") Then
                                If HierarchieTiefe = 4 And _
                                   strOldCellValue <> "..." And _
                                   strCellValue <> strRealBuCellValue And _
                                   strRealBuCellValue <> strOldCellValue Then
                                    If GgWertIsNew(strRealBuCellValue) Then
                                        Print #FileRealGgHier, Left(RealGGHierOut, LastOccurenceOfChar(RealGGHierOut, FT)) + strRealBuCellValue
                                    End If
                                End If
                            End If
                            
                            If GgWertIsNew(strCellValue) Then
                                Print #FileRealGgHier, RealGGHierOut
                            End If
                            
                            If (strRealBuCellValue = "ELICON") Then
                                Dim strTemp2 As String
                                strTemp2 = "lskdjf"
                            End If
                        End If
                    End If
                    
                    'RealGgStamm nur ausgeben, wenn Child 6 stellig ist und die letzten 3 Zeichen eine Zahl sind (und die ersten 3 Buchstaben)
                    If (Len(strCellValue) = 6) Or (strCellValue = "FIN_IMO_E") Or (strCellValue = "OP_E") Then
                        'Zeile mit ENERGY |fffd|berspringen
                        If (UCase(strCellValue) <> "ENERGY") Then
                            If (HierarchieTiefe = 4 And strOldCellValue <> "..." And (strCellValue <> strRealBuCellValue And strRealBuCellValue <> strOldCellValue)) Then
                                Print #FileRealGgStamm, strRealBuCellValue + FT + "EN" + FT + Left(strRealBuCellValue, 3) + " Others" + FT + Left(strRealBuCellValue, 3) + " Others" + FT + Left(strRealBuCellValue, 3) + " Others"
                            End If
                        
                            Print #FileRealGgStamm, StammOutput_E_Real
                        End If
                    End If
                End If
                
                strOldCellValue = strCellValue
            End If
          End If    'If HierarchieTiefe > 0
          
          AnzHBUNodes = HbuIdx - 1
    
          zeIndex = zeIndex + 1
    
End_Do_Loop:
        Loop Until (zeIndex > maxZeilen) Or HierarchieTiefe = "0"      '(zeIndex > 294)     '(zeIndex > maxZeilen) Or HierarchieTiefe = "0"
    End With
      
    Application.StatusBar = "Zusatzitems werden hinzugef|fffd|gt..."
    DoEvents
    Call AddHbuAdditionalItems(FileHBU, AnzHBUNodes)

    If (debugSwitch = True) Then
        Print #FileDBG, ""
        Print #FileDBG, ""
        Print #FileDBG, "--------------------------------------------------------------------------------------------------"
        Print #FileDBG, "arrHBU VOR ProcessHbuHierarchie"
        Call DbgWriteArrHBU(FileDBG)
    End If
        
    ' KWA 24.07.2015 - An dieser Stelle ist in jedem Node die Parent-ID noch 0. Wir verwenden sie, um die Knoten nach der _
      vorgegebenen Sortierreihenfolge zu sortieren.
    Call sortHbuHierarchy(FileDBG)
    If (debugSwitch = True) Then
        Print #FileDBG, ""
        Print #FileDBG, ""
        Print #FileDBG, "--------------------------------------------------------------------------------------------------"
        Print #FileDBG, "arrHBU nach sortHbuHierarchy"
        Call DbgWriteArrHBU(FileDBG)
    End If
      
    ' Jetzt werden die Parent-/Child-Beziehungen ermittelt
    Application.StatusBar = "Parent-/Child-Beziehungen werden ermittelt..."
    Call ProcessHbuHierarchie(FileDBG)
        
    If (debugSwitch = True) Then
        Print #FileDBG, ""
        Print #FileDBG, ""
        Print #FileDBG, "--------------------------------------------------------------------------------------------------"
        Print #FileDBG, "arrHBU NACH ProcessHbuHierarchie"
        Call DbgWriteArrHBU(FileDBG)
    End If

'Ausgabe des neuen Hierarchiefils f|fffd|r HBU
Application.StatusBar = "HBU-Hierarchiefile wird erzeugt..."
For zeIndex = 1 To AnzHBUNodes
    If (Right$(arrHBU(zeIndex, 0), 3) <> "000") Then
        
        sInfoObject = "....x....1....x....2....x....3" 'L|fffd|nge=30
        sNodeName = "....x....1....x....2....x....3..." 'L|fffd|nge=33
        sShortText = "....x....1....x....2"
        sMediumText = "....x....1....x....2....x....3....x....4"
        sLongText = "....x....1....x....2....x....3....x....4....x....5....x....6"
        
        LSet sInfoObject = "/SIE/ST_OTGL"
        LSet sNodeName = arrHBU(zeIndex, 0)
        LSet sShortText = arrHBU(zeIndex, 8)
        LSet sMediumText = arrHBU(zeIndex, 9)
        LSet sLongText = arrHBU(zeIndex, 9)
        'Print #FileHBU_BW, "#Node ID#-InfoObject Name             #-Node Name                     *#Par.ID #FiCldID#NeNoID #-Platzhalter                                                                   *#-Short text        #-Medium text                           #-Long text"
        '0:NodeName  1:Parent-Name  2:Parent-ID  3:FirstChild-Name  4:FirstChild-ID  6:NextNode-ID  7:Hierarchietiefe  8:ShortText  9:LongText
        
        'Print #FileHBU_BW, Format(zeIndex, "00000000") + sInfoObject + sNodeName + Format(arrHBU(zeIndex, 2), "00000000") + Format(arrHBU(zeIndex, 4), "00000000") + Format(arrHBU(zeIndex, 6), "00000000") _
        '    + "0000000000000000                                                                "
        Print #FileHBU_BW, _
              Format(zeIndex, "00000000") _
            + sInfoObject _
            + sNodeName _
            + Format(arrHBU(zeIndex, 2), "00000000") _
            + Format(arrHBU(zeIndex, 4), "00000000") _
            + Format(arrHBU(zeIndex, 6), "00000000") _
            + "0000000000000000                                                                " _
            + sShortText _
            + sMediumText _
            + sLongText
    End If
Next zeIndex



Close #File_Nr_Stamm
Close #File_Nr_Hier
Close #FileHBU
Close #FileHBU_BW
Close #File_Check_TG
Close #File_Check_PTG
Close #File_SAS_TG
Close #FileRealGgHier
Close #FileRealGgStamm
Close #FileDBG
Close #FileYH070

Application.StatusBar = ""
Application.Cursor = xlDefault

Call MsgBox("Die Uploadfiles wurden im Verzeichnis " + Chr(13) + Chr(13) + DateinamePfad _
                + Chr(13) + Chr(13) + "gespeichert." + Chr(13) + Chr(13), vbInformation)


Exit Sub

Err_Handler:
    Application.Cursor = xlDefault
    Call MsgBox(Err.Number & ": " & Err.Description, vbExclamation + vbOKOnly, "FEHLER")
    Application.StatusBar = ""
    On Error Resume Next
    Close #File_Nr_Stamm
    Close #File_Nr_Hier
    Close #FileHBU
    Close #FileHBU_BW
    Close #File_Check_TG
    Close #File_Check_PTG
    Close #File_SAS_TG
    Close #FileRealGgHier
    Close #FileRealGgStamm
    Close #FileDBG
    Exit Sub
End Sub

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Zum Sortieren der HBU-Hierarchie wird das Feld "Parent-ID" verwendet; das hat zu diesem Zeitpunkt f|fffd|r alle Knoten noch den Wert
' "0" oder "". Der Schl|fffd|ssel wird folgenderma|fffd|en gebildet: wir bestimmen die Anzahl Stellen, die wir zum Durchnummerieren der Kno-
' ten ben|fffd|tigen (im Normalfall 4) und schreiben davor die Sortiernummer aus dem Bereich "rngDivSort". Danach sortieren wir die
' Hierarchie nach diesem Schl|fffd|ssel und setzen schlie|fffd|lich die Parent-ID durchgehend auf "".
' Kleine Schwierigkeit: alle Felder des HBU-Arrays sind Strings, also m|fffd|ssen wir links evtl. eine "0" davorschreiben.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub sortHbuHierarchy(pFileDBG As Integer)
  Dim rngDivSort As Range, rngHit As Range
  Dim sDiv As String, sFmtDiv As String, sFmtEnt As String
  Dim idxNode As Integer, iDivSort As Integer
  Dim bErr As Boolean
  
  bErr = False
  
  Set rngDivSort = wksDivSort.Range("rngDivSort")
  If rngDivSort Is Nothing Then
    Print #pFileDBG, ">>> Range """ & rngDivSort.Name & """ im Blatt """ & wksDivSort.Name & """ nicht gefunden<<<"
    bErr = True
  End If
  
  sFmtDiv = "000"   ' Wenn's mal mehr als 999 Divisions werden, muss hier entsprechend erweitert werden
  sFmtEnt = "00000" ' Wenn's mal mehr als 99.999 Entities werden, muss hier entsprechend erweitert werden
  
  ' Ermittle die Sortier-Schl|fffd|ssel; wir beginnen mit dem zweiten Eintrag, weil der erste (HS1_WORLD) bereits einige Werte enth|fffd|lt
  For idxNode = 2 To AnzHBUNodes
    sDiv = Left$(arrHBU(idxNode, 0), 3)
    Set rngHit = rngDivSort.Find(What:=sDiv, LookAt:=xlWhole, MatchCase:=True)
    If rngHit Is Nothing Then
      Print #pFileDBG, ">>> Division """ & sDiv & """ im Zellbereich """ & rngDivSort.Address & """ nicht gefunden<<<"
      bErr = True
    Else
      iDivSort = rngHit.Offset(0, 1)
      arrHBU(idxNode, 2) = Format$(iDivSort, sFmtDiv) & Format$(idxNode, sFmtEnt)
    End If
  Next idxNode
  
  ' Sortiere das HBU-Array (2. Feld, ab dem 2. Eintrag)
  Call QuickSort(arrHBU, 2, 2, AnzHBUNodes)
  
  ' Setze die Parent-IDs auf ""
  For idxNode = 2 To AnzHBUNodes
    arrHBU(idxNode, 2) = ""
  Next idxNode
  
LExit:
  If bErr Then
    MsgBox "sortHbuHierarchy mit Fehler(n) beendet. Bitte |fffd|berpr|fffd|fen Sie die Debug-Datei!", vbInformation
  End If
End Sub



Sub ProcessHbuHierarchie(pFileDBG As Integer)
    Dim aktNode As Integer, aktChild As Integer
    
    On Error GoTo Err_Handler
    
    For aktNode = 1 To AnzHBUNodes
        If (debugSwitch = True) Then
            Print #pFileDBG, "aktNode " & aktNode & ": arrHBU(aktNode, 0): " & arrHBU(aktNode, 0)
        End If
        
        aktChild = aktNode + 1
        arrHBU(aktNode, 6) = "0"
        
        For aktChild = 1 To AnzHBUNodes
            ' Trage |fffd|berall, wo der aktNode als Parent referenziert wird seine ID in (2) ein
            If (arrHBU(aktChild, 1) = arrHBU(aktNode, 0)) Then
                arrHBU(aktChild, 2) = aktNode
             
                ' Wenn der aktNode bisher noch keine Child-Datensatz vermerkt hat, dann merken wir uns diesen hier
                ' 3:FirstChild-Name, 4:FirstChild-ID
                If (arrHBU(aktNode, 3) = "") Then
                    arrHBU(aktNode, 3) = arrHBU(aktChild, 0)
                    arrHBU(aktNode, 4) = aktChild
                End If
                
            End If
            ' Wenn dieser Folgedatensatz das gleiche Hierarchielevel hat wie der aktNode, und die NextNode-ID bisher 0 ist, _
              und er hat den gleichen Parent wie der aktNode, dann ist dies der erste Nachfolger, den wir uns merken m|fffd|ssen. _
              Da wir mit der Schleife nicht mehr erst 1 hinter dem aktNode starten, sondern ganz vorne bei 1, d|fffd|rfen wir diesen _
              Check erst bei (aktChild > aktNode) machen.
            If (aktChild > aktNode) And _
               (CInt(arrHBU(aktChild, 7)) = CInt(arrHBU(aktNode, 7))) And _
               (arrHBU(aktNode, 6) = "0") And _
               (arrHBU(aktChild, 1) = arrHBU(aktNode, 1)) Then
                arrHBU(aktNode, 5) = arrHBU(aktChild, 0)  ' 5: NextNode-Name
                arrHBU(aktNode, 6) = CStr(aktChild)       ' 6: NextNode-ID
            End If
        Next aktChild
    Next aktNode
Exit Sub

Err_Handler:
    Application.Cursor = xlDefault
    Call MsgBox("ProcessHbuHierarchie: Err " & Err.Number & ": " & Err.Description, vbExclamation + vbOKOnly, "FEHLER")
    Application.StatusBar = ""
End Sub 'ProcessHbuHierarchie()

Sub ProcessHbuHierarchie_Save(pFileDBG As Integer)
    Dim aktNode As Integer, aktChild As Integer
    Dim healthcareID As Integer
    
    On Error GoTo Err_Handler
    
    For aktNode = 1 To AnzHBUNodes
        If (debugSwitch = True) Then
            Print #pFileDBG, "aktNode " & aktNode & ": arrHBU(aktNode, 0): " & arrHBU(aktNode, 0)
        End If
        
        'If (arrHBU(aktNode, 0) = "ENERGY") Or (arrHBU(aktNode, 0) = "HS1_WORLD") Then
        '    Debug.Print arrHBU(aktNode, 0)
        'End If
        
        aktChild = aktNode + 1
        arrHBU(aktNode, 6) = "0"
        'durchsuche die folgenden Knoten solange, wie sie ein gr|fffd|sseres Hierarchielevel haben wie der aktuelle Knoten
        'While (CInt(arrHBU(aktChild, 7)) > CInt(arrHBU(aktNode, 7))) And (aktChild <= AnzHbuNodes)
            'Debug.Print "   Akt.Child(" & CStr(aktChild) & "): " & arrHBU(aktChild, 0) & ", HT: " & arrHBU(aktChild, 7)
            'aktChild = aktChild + 1
        'Wend
        
        
        'If arrHBU(aktNode, 0) = "CIT8308P" Then
        '    Debug.Print "Akt.Node=" & arrHBU(aktNode, 0)
        'End If
        
        'For aktChild = aktNode + 1 To AnzHbuNodes
        'For aktChild = 1 To AnzHBUNodes
        For aktChild = 1 To AnzHBUNodes
            'If aktChild = 273 Then
            '    Debug.Print
            'End If
            'Debug.Print "   Akt.Child(" & CStr(aktChild) & "): " & arrHBU(aktChild, 0) & ", HT: " & arrHBU(aktChild, 7)
            'Trage |fffd|berall, wo der aktNode als Parent referenziert wird seine ID in (2) ein
            If (arrHBU(aktChild, 1) = arrHBU(aktNode, 0)) Then
                'debug.Print "aktChild: " + arrHBU(aktChild, 0) + ", aktNode: " + arrHBU(aktNode, 0)
                arrHBU(aktChild, 2) = aktNode
            
                'Wenn der aktNode bisher noch keine Child-Datensatz vermerkt hat, dann merken wir uns diesen hier
                '3:FirstChild-Name, 4:FirstChild-ID
                If (arrHBU(aktNode, 3) = "") Then
                    arrHBU(aktNode, 3) = arrHBU(aktChild, 0)
                    arrHBU(aktNode, 4) = aktChild
                End If
                
            End If
            'Wenn dieser Folgedatensatz das gleiche Hierarchielevel hat wie der aktNode, und die NextNode-ID bisher 0 ist,
            'und er hat den gleichen Parent wie der aktNode, dann ist dies der erste Nachfolger, den wir uns merken m|fffd|ssen.
            'Da wir mit der Schleife nicht mehr erst 1 hinter dem aktNode starten, sondern ganz vorne bei 1, d|fffd|rfen wir diesen Check erst bei (aktChild > aktNode) machen.
            If (aktChild > aktNode) And (CInt(arrHBU(aktChild, 7)) = CInt(arrHBU(aktNode, 7))) And (arrHBU(aktNode, 6) = "0") And (arrHBU(aktChild, 1) = arrHBU(aktNode, 1)) Then
                arrHBU(aktNode, 5) = arrHBU(aktChild, 0)  '5:NextNode-Name
                arrHBU(aktNode, 6) = CStr(aktChild)        '6:NextNode-ID
            End If
        Next aktChild
    Next aktNode

Exit Sub

Err_Handler:
    Application.Cursor = xlDefault
    Call MsgBox("ProcessHbuHierarchie: Err " & Err.Number & ": " & Err.Description, vbExclamation + vbOKOnly, "FEHLER")
    Application.StatusBar = ""
    Exit Sub
End Sub 'ProcessHbuHierarchie()


'Funktion, die die Tiefe (=erste nicht-leere Zelle) der aktuellen Zeile bestimmt
Function GetHierarchieTiefe(aktZeile As Integer) As Integer
Dim spaltenIndex As Integer
  With wksTG
    For spaltenIndex = spStart To spEnde
        If .Cells(aktZeile, spaltenIndex).Value <> "" Then
           GetHierarchieTiefe = spaltenIndex
           Exit Function
        Else
           GetHierarchieTiefe = "0"
        End If
    Next spaltenIndex
  End With
End Function


'Funktion, die den Parent der aktuellen Zeile bestimmt
Function GetParent(aktZeile As Integer, aktHierarchieTiefe As Integer) As String
Dim zeilenIndex As Integer, HierarchieTiefe As Integer
  With wksTG
    For zeilenIndex = (aktZeile - 1) To spStart Step -1
        HierarchieTiefe = GetHierarchieTiefe(zeilenIndex)
        If HierarchieTiefe < aktHierarchieTiefe Then
           GetParent = .Cells(zeilenIndex, HierarchieTiefe)
           Exit Function
        Else
           GetParent = "FEHLER"
        End If
    Next zeilenIndex
  End With
End Function
'Funktion, die zu einem TG-Item das DO-Attribut aus dem Sheet "DOMapping" bestimmt
Function GetDoAttribut(TGItem As String, aktPeriod As Long) As String
Dim zeilenIndex As Long, lRow As Long, StrDOMap As String, StrDOMapOld As String
  StrDOMap = ""
  StrDOMapOld = ""
  GetDoAttribut = ""
  With wksMapDO 'Wir suchen das Mapping in dem Sheet DOMapping
    lRow = .Cells(.Rows.Count, "A").End(xlUp).Row
    For zeilenIndex = 3 To lRow 'Loopen durch die Mappingtabelle
        If (aktPeriod >= .Cells(zeilenIndex, 3).Value And aktPeriod <= .Cells(zeilenIndex, 4).Value) Then 'Nur wenn das Mapping in aktueller Periode g|fffd|ltig ist, wird es auch ber|fffd|cksichtigt
            StrDOMap = Replace(.Cells(zeilenIndex, 1).Value, "*", "")
            If InStr(.Cells(zeilenIndex, 1).Value, "*") > 0 Then  'Wenn das Mapping mit einem * versehen ist, dann auch alle darunterliegenden Einheiten mappen
                If Left(StrDOMap, Len(StrDOMap)) = Left(TGItem, Len(StrDOMap)) And Len(StrDOMap) > Len(StrDOMapOld) Then
                   GetDoAttribut = .Cells(zeilenIndex, 2)
                   StrDOMapOld = StrDOMap
                End If
            Else 'Mapping ohne * werden nur dann gemappt, wenn die Einheiten |fffd|bereinstimmen
                If StrDOMap = TGItem Then
                   GetDoAttribut = .Cells(zeilenIndex, 2)
                   StrDOMapOld = StrDOMap
                End If
            End If
        End If
    Next zeilenIndex
  End With
End Function

'Kurz- und Mitteltext des Parent der aktuellen Zeile bestimmen
Sub GetParentText(aktZeile As Integer, aktHierarchieTiefe As Integer, tShort As String, tMed As String)
Dim zeilenIndex As Integer, HierarchieTiefe As Integer
  With wksTG
    For zeilenIndex = (aktZeile - 1) To spStart Step -1
        HierarchieTiefe = GetHierarchieTiefe(zeilenIndex)
        If HierarchieTiefe < aktHierarchieTiefe Then
              tShort = .Cells(zeilenIndex, spKurztext_E).Value
              tMed = .Cells(zeilenIndex, spLangtext_E).Value
           Exit Sub
        Else
           tShort = "FEHLER"
           tMed = "FEHLER"
        End If
    Next zeilenIndex
  End With
End Sub     'GetParentText()


Function GGParentIsNew(pParent As String) As Boolean
    'Pr|fffd|ft, ob der angegebene Parent bereits im GgParentArr-Array gespeichert ist. Falls nicht dann f|fffd|gen wir
    'ihn ins Array ein.
    '
    ' Returnwert:
    '   False   : Der Parent ist bereits vorhanden
    '   True    : Der Parent ist neu
    
    Dim i As Integer
    Dim blFound As Boolean
    
    blFound = False
    For i = 0 To GgParentArrCount
        If GgParentArr(i) = pParent Then
            blFound = True
        End If
    Next i
    If Not blFound Then
        'Der Parent ist neu, also nehmen wir ihn in's Array auf
        GgParentArr(GgParentArrCount) = pParent
        GgParentArrCount = GgParentArrCount + 1
        GGParentIsNew = True
    Else
        GGParentIsNew = False
    End If
End Function    'GGParentIsNew()

Function GgWertIsNew(pGG As String) As Boolean
    'Pr|fffd|ft, ob der angegebene GgWert bereits im RealGgArr-Array gespeichert ist. Falls nicht dann f|fffd|gen wir
    'ihn ins Array ein.
    '
    ' Returnwert:
    '   False   : Der GgWert ist bereits vorhanden
    '   True    : Der GgWert ist neu
    
    Dim i As Integer
    Dim blFound As Boolean
    
    blFound = False
    For i = 0 To RealGgArrCount
        If RealGgArr(i) = pGG Then
            blFound = True
        End If
    Next i
    If Not blFound Then
        'Der Parent ist neu, also nehmen wir ihn in's Array auf
        RealGgArr(RealGgArrCount) = pGG
        RealGgArrCount = RealGgArrCount + 1
        GgWertIsNew = True
    End If

    GgWertIsNew = Not blFound
End Function    'GGParentIsNew()



Function LastOccurenceOfChar(strVal As String, strChar As String) As Long
    LastOccurenceOfChar = InStrRev(strVal, strChar)
End Function


Sub DbgWriteArrHBU(pFileDBG As Integer)
    Dim i As Integer
    
    If (debugSwitch = True) Then
        Print #pFileDBG, ""
        Print #pFileDBG, "----------------------------------------------------------------------------------------------"
        Print #pFileDBG, "AnzHBUNodes: " & AnzHBUNodes
        For i = 1 To AnzHBUNodes
            ' 0: NodeName     1: Parent-Name      2: Parent-ID  3: FirstChild-Name  4: FirstChild-ID _
              6: NextNode-ID  7: Hierarchietiefe  8: ShortText  9: LongText
            Print #pFileDBG, i & ": Node: " & arrHBU(i, 0) & ", Parent: " & arrHBU(i, 1) & ", Parent-ID: " & arrHBU(i, 2) _
                           & ", FirstChild-ID: " & arrHBU(i, 4) & ", NextNode-ID: " & arrHBU(i, 6) & ", HT: " & arrHBU(i, 7)
        Next i
        Print #pFileDBG, "----------------------------------------------------------------------------------------------"
        Print #pFileDBG, ""
    End If
End Sub

Sub OpenOutputfiles( _
        pFile_Nr_Hier As Integer, pFileHBU As Integer, pFileHBU_BW As Integer, _
        pFile_Nr_Stamm As Integer, pFile_Check_TG As Integer, pFile_Check_PTG As Integer, pFile_SAS_TG As Integer, _
        pFileRealGgHier As Integer, pFileRealGgStamm As Integer, _
        pFileDBG As Integer, pFileYH070 As Integer _
    )
    Dim DateinameHier As String, DateinameHBU As String, DateinameHBU_BW As String, DateinameStamm As String
    Dim DateinameCheck_TG As String, DateinameCheck_PTG As String, DateinameSAS_TG As String
    Dim DateinameRealGGHier As String, DateinameRealGGStamm As String
    Dim DateinameYH070 As String
    Dim sPer As String  ' KWA 24.07.2015
    
    On Error GoTo ErrHandler
    
    sPer = "_" + AktuellePeriode + "_" + CStr(Year(Date)) + CStr(Format(Month(Date), "0#")) + CStr(Format(Day(Date), "0#"))
    DateinameHier = "FXS41_DS_HY_" + Version + sPer + ".csv"
    DateinameHBU = "HBU_FXS41_HY_" + Version + sPer + ".csv"
    DateinameHBU_BW = "HBU_FXS41_BW_" + Version + sPer + ".txt"
    DateinameStamm = "FXS40_DS_MD_" + Version + sPer + ".csv"
    DateinameCheck_TG = Geschaeftsjahr + "_gueltig-TG" + sPer + ".csv"
    DateinameCheck_PTG = Geschaeftsjahr + "_gueltig-PTG" + sPer + ".csv"
    DateinameSAS_TG = Geschaeftsjahr + "_SAS_TG" + sPer + ".csv"
    DateinameRealGGHier = "FXS65_RD_HY_" + Version + sPer + ".csv"
    DateinameRealGGStamm = "FXS64_RD_MD_" + Version + sPer + ".csv"
    DateinameYH070 = "YH070_" + Version + sPer + ".txt"
    
    'Dateien |fffd|ffenen
    pFile_Nr_Hier = FreeFile
    Open DateinamePfad + DateinameHier For Output As #pFile_Nr_Hier
    pFileHBU = FreeFile
    Open DateinamePfad + DateinameHBU For Output As #pFileHBU
    pFileHBU_BW = FreeFile
    Open DateinamePfad + DateinameHBU_BW For Output As #pFileHBU_BW
    
    pFile_Nr_Stamm = FreeFile
    Open DateinamePfad + DateinameStamm For Output As #pFile_Nr_Stamm
    'Dateien f|fffd|r CHECK_TG |fffd|ffenen
    pFile_Check_TG = FreeFile
    Open DateinamePfad + DateinameCheck_TG For Output As #pFile_Check_TG
    pFile_Check_PTG = FreeFile
    Open DateinamePfad + DateinameCheck_PTG For Output As #pFile_Check_PTG
    'Datei f|fffd|r SAS_TG |fffd|ffnen
    pFile_SAS_TG = FreeFile
    Open DateinamePfad + DateinameSAS_TG For Output As #pFile_SAS_TG
    pFileRealGgHier = FreeFile
    'Datei f|fffd|r GG-Hierarchie
    Open DateinamePfad + DateinameRealGGHier For Output As #pFileRealGgHier
    'Datei f|fffd|r GG-Stammdaten
    pFileRealGgStamm = FreeFile
    Open DateinamePfad + DateinameRealGGStamm For Output As #pFileRealGgStamm

    pFileDBG = FreeFile
    Open DateinamePfad + "DBG.txt" For Output As #pFileDBG
    pFileYH070 = FreeFile
    Open DateinamePfad + DateinameYH070 For Output As #pFileYH070
    
    
    Print #pFile_Nr_Hier, "#" + FT + "Hierarchy" + FT + "Text Node" + FT + "TGL" + FT + "From Value" + FT + "To Value" + FT _
                               + "Short" + FT + "Medium" + FT + "Long"
    Print #pFile_Nr_Hier, constFIELD + FT + "DS" + FT + FT + "SIEMENS" + FT + FT + FT _
                               + "Depth Structure" + FT + "Depth Structure" + FT + "Depth Structure"
                               
    Print #pFileHBU, "#" + FT + "Hierarchy" + FT + "Text Node" + FT + "TGL" + FT + "From Value" + FT + "To Value" + FT
    Print #pFileHBU, constFIELD + FT + "HBU" + FT + FT + "HS1_WORLD" + FT + FT + FT
      
    Print #pFileHBU_BW, "#Node ID#-InfoObject Name             #-Node Name                      #Par.ID #pFiCldID#NeNoID #-Platzhalter                                                                  #-Short text        #-Medium text                           #-Long text"

    Print #pFileRealGgHier, "#" + FT + "Hierarchy" + FT + "Text Node" + FT + "Real Div" + FT + "From Value" + FT + "To Value" + FT _
                               + "Short" + FT + "Medium" + FT + "Long"
    Print #pFileRealGgHier, constFIELD + FT + "RD" + FT + "SIEMENS" + FT + FT + FT + FT _
                               + "Real Divisions" + FT + "Real Divisions" + FT + "Real Divisions"
    Print #pFileRealGgStamm, "#RealDiv" + FT + "Sprache" + FT + "Kurz" + FT + "Mittel" + FT + "Lang"
    
    If (ExportFxs40_Classification = True) Then
        Print #pFile_Nr_Stamm, "#TGL" + FT + "Sprache" + FT + "Kurz" + FT + "Mittel" + FT + "Lang" + FT + "Div.-Attribute" + FT _
                                   + "BU/Pseudo-BU" + FT + "Real Division" + FT + "Consolidation Div." + FT + "Elimination DS" + FT + "Depth Stru. official" + FT + "Div. official" + FT + "Real Division (GG)" + FT + "Classification" + FT + "DO Attribut"
    Else
        Print #pFile_Nr_Stamm, "#TGL" + FT + "Sprache" + FT + "Kurz" + FT + "Mittel" + FT + "Lang" + FT + "Div.-Attribute" + FT _
                                   + "BU/Pseudo-BU" + FT + "Real Division" + FT + "Consolidation Div." + FT + "Elimination DS" + FT + "Depth Stru. official" + FT + "Div. official" + FT + "Real Division (GG)" + FT + "DO Attribut"
    End If
    Print #pFile_Nr_Stamm, "SIEMENS" + FT + "EN" + FT + "SIEMENS" + FT + "SIEMENS" + FT + "SIEMENS"
    
    Print #pFile_SAS_TG, "#Bereich;GG;Zweig;Segment;Mitteltext englisch;nicht bebuchbar;Check_TG;Check_PTG"
    Print #pFile_SAS_TG, "#group;division;subdivision;segment;Mediumtext english;not valid for posting;Check_TG;Check_PTG"
       
    Exit Sub

ErrHandler:
    Application.Cursor = xlDefault
    Call MsgBox("OpenOutputfiles(): Err " & Err.Number & ": " & Err.Description, vbExclamation + vbOKOnly, "FEHLER")

    Exit Sub
End Sub  ' OpenOutputfiles()

Sub InitHierarchieArrays()
    Dim i As Integer, j As Integer
    
    For i = 1 To maxZeilen
        For j = 0 To UBound(arrHBU, 2) - 1
            arrHBU(i, j) = ""
        Next j
    Next i
    
    arrHBU(1, 0) = "HS1_WORLD"        ' 0: NodeName
    arrHBU(1, 1) = ""                 ' 1: Parent-Name
    arrHBU(1, 2) = "0"                ' 2: Parent-ID
    arrHBU(1, 3) = ""                 ' 3: FirstChild-Name
    arrHBU(1, 4) = "0"                ' 4: FirstChild-ID
    arrHBU(1, 6) = "0"                ' 6: NextNode-ID
    arrHBU(1, 7) = "1"                ' 7: Hierarchietiefe
    arrHBU(1, 8) = "HS1_WORLD"        ' 8: ShortText
    arrHBU(1, 9) = "Sector Hierarchy" ' 9: LongText
End Sub


'---------------------------------------------------------------------------------------------------------
'Ausgabe zus|fffd|tzlicher TG-Elemente speziell f|fffd|r die HBU-Hierarchie.
'Diese sind im Tabellenblatt HBU_data hinterlegt
Sub AddHbuAdditionalItems(pFileHBU As Integer, pAnzHbuNodes As Integer)
    Dim rngHit As Range ' KWA 24.07.2015
    Dim HbuDataIdx As Integer, HbuHT As Integer
    Dim HbuAddParent As String, HbuAddChild As String, HbuOutput As String
    
    'HBU: nun schreiben wir noch die zus|fffd|tzlich auszugebenen Daten aus Worksheet HBU_data in das HBU Hierarchiefile
    Set rngHit = wksHBU.Cells.Find(What:="Additional Elements for HBU", LookAt:=xlWhole, MatchCase:=True)
    If rngHit Is Nothing Then
      MsgBox "Zelle ""Additional Elements for HBU"" im Blatt & """ & wksHBU.Name & """ nicht gefunden." & vbLf _
           & "Additional Items k|fffd|nnen nicht ausgegeben werden.", vbInformation
      Exit Sub
    Else
      HbuDataIdx = rngHit.Row + 1 ' KWA 24.07.2015; vorher: HbuDataIdx = 6
    End If
    Do
        HbuAddParent = wksHBU.Cells(HbuDataIdx, 1).Value
        HbuAddChild = wksHBU.Cells(HbuDataIdx, 2).Value
        HbuOutput = constHSTEP + HbuAddParent + FT + HbuAddChild
        If (HbuAddParent <> "") Then
            Print #pFileHBU, HbuOutput
        
            Select Case Len(HbuAddChild)
                Case 6
                    HbuHT = 4
                Case 8
                    HbuHT = 5
                Case 10
                    HbuHT = 6
                Case Else
                    HbuHT = 4
            End Select
            If Right(HbuAddChild, 3) = "_CG" Then
                HbuHT = 4
            End If
            
            pAnzHbuNodes = pAnzHbuNodes + 1
            arrHBU(pAnzHbuNodes, 0) = HbuAddChild                           ' 0: NodeName
            arrHBU(pAnzHbuNodes, 1) = HbuAddParent                          ' 1: Parent-Name
            arrHBU(pAnzHbuNodes, 2) = "0"                                   ' 2: Parent-ID
            arrHBU(pAnzHbuNodes, 3) = ""                                    ' 3: FirstChild-Name
            arrHBU(pAnzHbuNodes, 4) = "0"                                   ' 4: FirstChild-ID
            arrHBU(pAnzHbuNodes, 6) = "0"                                   ' 6: NextNode-ID
            arrHBU(pAnzHbuNodes, 7) = CStr(HbuHT)                           ' 7: Hierarchietiefe
            arrHBU(pAnzHbuNodes, 8) = wksHBU.Cells(HbuDataIdx, 3).Value     ' 8: ShortText
            arrHBU(pAnzHbuNodes, 9) = wksHBU.Cells(HbuDataIdx, 5).Value     ' 9: LongText
        End If
        
        HbuDataIdx = HbuDataIdx + 1
    Loop Until (HbuAddParent = "")
End Sub



Attribute VB_Name = "TG_Sort"
Option Explicit
Option Compare Text

'Quelle: http://www.vbforums.com/showthread.php?t=473677
'Angepasst f|fffd|r die Verarbeitung von 8-dimensionalen Arrays mit Datentyp String.
' Omit plngLeft & plngRight; they are used internally during recursion
'08.12.2009: Neuer Parameter SortColumnIndex hinzugef|fffd|gt. Er gibt an, nach welcher Spalte sortiert werden soll.
Public Sub QuickSort(ByRef pstrArray() As String, ByVal SortColumnIndex As Integer, Optional ByVal plngLeft As Long, Optional ByVal plngRight As Long)
    Dim lngFirst As Long
    Dim lngLast As Long
    Dim strMid As String
    Dim strSwap(10) As String
    Dim i As Integer
    
    If plngRight = 0 Then
        plngLeft = LBound(pstrArray, 1)     'KLF
        plngRight = UBound(pstrArray, 1)
    End If
    lngFirst = plngLeft
    lngLast = plngRight
    strMid = pstrArray((plngLeft + plngRight) \ 2, SortColumnIndex)
    Do
        Do While pstrArray(lngFirst, SortColumnIndex) < strMid And lngFirst < plngRight
            lngFirst = lngFirst + 1
        Loop
        Do While strMid < pstrArray(lngLast, SortColumnIndex) And lngLast > plngLeft
            lngLast = lngLast - 1
        Loop
        If lngFirst <= lngLast Then
            For i = 0 To (UBound(pstrArray, 2) - 1) 'KLF
                strSwap(i) = pstrArray(lngFirst, i)
                pstrArray(lngFirst, i) = pstrArray(lngLast, i)
                pstrArray(lngLast, i) = strSwap(i)
            Next i
            lngFirst = lngFirst + 1
            lngLast = lngLast - 1
        End If
    Loop Until lngFirst > lngLast
    If plngLeft < lngLast Then QuickSort pstrArray, SortColumnIndex, plngLeft, lngLast
    If lngFirst < plngRight Then QuickSort pstrArray, SortColumnIndex, lngFirst, plngRight
End Sub





Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "wksDivSort"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "wksHBU"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "wksMapDO"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "wksTG"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "BtnExport, 1, 0, MSForms, CommandButton"
Private Sub BtnExport_Click()
    'VB-Sub zum generieren der Uploadfiles aufrufen
    Call GeneriereUploadDateien
End Sub
Private Sub recreateGrouping()
  Dim curRow As Range
  Dim intLevel As Integer
  
  ActiveSheet.UsedRange.ClearOutline
  
  For Each curRow In ActiveSheet.Range("4:" & ActiveSheet.UsedRange.Rows.Count).Rows
    intLevel = 0
    While Trim(curRow.Cells(1, intLevel + 1).Value) = "" And intLevel < 99
      intLevel = intLevel + 1
    Wend
    If intLevel > 1 And intLevel < 99 Then curRow.OutlineLevel = intLevel - 1
  Next
End Sub


Attribute VB_Name = "wksTG1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub BtnExport_Click()
    'VB-Sub zum generieren der Uploadfiles aufrufen
    Call GeneriereUploadDateien
End Sub
Private Sub recreateGrouping()
  Dim curRow As Range
  Dim intLevel As Integer
  
  ActiveSheet.UsedRange.ClearOutline
  
  For Each curRow In ActiveSheet.Range("4:" & ActiveSheet.UsedRange.Rows.Count).Rows
    intLevel = 0
    While Trim(curRow.Cells(1, intLevel + 1).Value) = "" And intLevel < 99
      intLevel = intLevel + 1
    Wend
    If intLevel > 1 And intLevel < 99 Then curRow.OutlineLevel = intLevel - 1
  Next
End Sub




INQUEST-PP=macro
