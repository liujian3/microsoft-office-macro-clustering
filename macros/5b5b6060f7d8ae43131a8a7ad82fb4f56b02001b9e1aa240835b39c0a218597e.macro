Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "clsAddIn"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'   Version:    11/06/17
'   Save as:    cslAddIn.cls
'   Requisites: *None
'   Description:Confirm save of add-in

'     Date   Ini Modification
'   11/06/17 CWH Initial Development

Option Explicit

Private Const cModule       As String = "cslAddIn"

Private WithEvents Workbook  As Workbook
Attribute Workbook.VB_VarHelpID = -1

Private Sub Class_Initialize()

    Application.CalculateFull
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    Set Workbook = ThisWorkbook

End Sub


Private Sub Class_Terminate()

    Set Workbook = Nothing

End Sub


Private Sub Workbook_AfterSave(ByVal Success As Boolean)

    If Success Then _
        MsgBox Prompt:=ThisWorkbook.Name & " saved!", _
               Title:="Save Workbook", _
               Buttons:=vbInformation
               
End Sub

Attribute VB_Name = "clsForm"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'   Version:    04/06/17

'   Save As:    clsForm
'   Description:Formats User Forms and Controls

'     Date   Ini Modification
'   06/21/13 CWH Initial Programming
'   07/10/14 CWH Version 2014.07
'   10/22/14 CWH Changed sRoutine to cRoutine
'   04/05/17 CWH Added flexibility in coloring

Option Explicit
   
'   Private Properties
Const cModule               As String = "clsForm"   'This module's name
Const Success               As Boolean = False      'Successful Finish
Const Failure               As Boolean = True       'Failed Finish
Const NoError               As Long = 0             'No Error
Const LogError              As Long = 997           'Log Error
Const RtnError              As Long = 998           'Return Error
Const DspError              As Long = 999           'Display Error

Private WithEvents oMsForm  As UserForm             'Object for Form Events
Attribute oMsForm.VB_VarHelpID = -1
Private WithEvents oFrame   As Frame                'Object for Frame Events
Attribute oFrame.VB_VarHelpID = -1
Private WithEvents oCmdBtn  As CommandButton        'Object for Command Button Events
Attribute oCmdBtn.VB_VarHelpID = -1
Private WithEvents oImage   As Image                'Object for Image Control Events
Attribute oImage.VB_VarHelpID = -1
Private WithEvents oMltPag  As Multipage            'Object for Multipage Events
Attribute oMltPag.VB_VarHelpID = -1
Private oForm               As Object               'Object for Form Properties
Dim dicCtrls                As Object               'Controls that impact Glowing

'   Color Request Types (see modSetup)


'   Public Properties
Public Property Set UserForm(ByVal oUserForm As Object)

'   Description:Attach Userform to Class
'   Inputs:     oUserForm       User form
'   Outputs:    *None
'   Requisites: *None
'   Example:    *None
'   Note!       Object type "UserForm" does not expose all form properties.
'               Examples include: Top, Left, Width, Height, and Caption.
'               A generic object will. But a generic object does not expose
'               any events. So to expose events AND all properties
'               we pass the user form as a generic "Object" (for properties)
'               and assign it to an MsForms.UserForm object (for events).

'     Date   Ini Modification
'   06/21/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "UserForm"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Initialize Variables
    If dicCtrls Is Nothing Then _
        Set dicCtrls = CreateObject("Scripting.Dictionary")

'   Procedure
    Set oForm = oUserForm: Set oMsForm = oForm
    Setup oForm

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Property

Public Property Set Frame(ByVal Frame As Frame)
    Set oFrame = Frame
End Property

Public Property Set Multipage(ByVal Multipage As Multipage)
    Set oMltPag = Multipage
End Property

Public Property Set CommandButton(ByVal CommandButton As CommandButton)
    Set oCmdBtn = CommandButton
End Property

Public Property Set Image(ByVal Image As Image)
    Set oImage = Image
End Property

Private Sub Class_Terminate()
    Set dicCtrls = Nothing
End Sub



'   Event Handlers
Private Sub oMsForm_MouseMove(ByVal Button As Integer, _
                              ByVal Shift As Integer, _
                              ByVal X As Single, _
                              ByVal Y As Single)

'   Description:Sets all Command Buttons to "normal" color
'   Inputs:     Button      Pressed Mouse button
'               Shift       State of the SHIFT, CTRL, and ALT keys
'               X           Mouse X
'               Y           Mouse Y
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Notes:      http://msdn.microsoft.com/en-us/library/office/aa220909(v=office.11).aspx
'   Example:    *None (Event Handler)

'     Date   Ini Modification
'   06/21/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "oMsForm_MouseMove"
    Dim oCtrl           As Control

'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Procedure
    For Each oCtrl In oForm.Controls
        If TypeName(oCtrl) = "CommandButton" Then
            oCtrl.BackColor = Color(crButton)
            oCtrl.ForeColor = Color(crButtonFont)
        End If
        If TypeName(oCtrl) = "Image" Then
            oCtrl.BackColor = Color(crButton)
            oCtrl.BackStyle = fmBackStyleTransparent
        End If
    Next
                
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Private Sub oFrame_MouseMove(ByVal Button As Integer, _
                           ByVal Shift As Integer, _
                           ByVal X As Single, _
                           ByVal Y As Single)

'   Description:Sets all Command Buttons to "normal" color
'   Inputs:     Button      Pressed Mouse button
'               Shift       State of the SHIFT, CTRL, and ALT keys
'               X           Mouse X
'               Y           Mouse Y
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Example:    *None (Event Handler)

'     Date   Ini Modification
'   06/09/14 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "oFrame_MouseMove"
    Dim oCtrl           As Control

'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Procedure
    For Each oCtrl In oFrame.Controls
        If TypeName(oCtrl) = "CommandButton" Then
            oCtrl.BackColor = Color(crButton)
            oCtrl.ForeColor = Color(crButtonFont)
        End If
        If TypeName(oCtrl) = "Image" Then
            oCtrl.BackColor = Color(crButton)
            oCtrl.BackStyle = fmBackStyleTransparent
        End If
    Next
                
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Private Sub oCmdBtn_MouseMove(ByVal Button As Integer, _
                              ByVal Shift As Integer, _
                              ByVal X As Single, _
                              ByVal Y As Single)

    oCmdBtn.BackColor = Color(crButtonGlow)
    oCmdBtn.ForeColor = Color(crButtonGlowFont)

End Sub

Private Sub oImage_MouseMove(ByVal Button As Integer, _
                             ByVal Shift As Integer, _
                             ByVal X As Single, _
                             ByVal Y As Single)

    oImage.BackColor = Color(crButtonGlow)
    oImage.BackStyle = fmBackStyleOpaque
    'oImage.ForeColor = Color(crButtonGlowFont)

End Sub

Private Sub oMltPag_MouseMove(ByVal index As Long, _
                              ByVal Button As Integer, _
                              ByVal Shift As Integer, _
                              ByVal X As Single, _
                              ByVal Y As Single)

'   Description:Sets all Command Buttons to "normal" color
'   Inputs:     Button      Pressed Mouse button
'               Shift       State of the SHIFT, CTRL, and ALT keys
'               X           Mouse X
'               Y           Mouse Y
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Notes:      http://msdn.microsoft.com/en-us/library/office/aa220909(v=office.11).aspx
'   Example:    *None (Event Handler)

'     Date   Ini Modification
'   06/21/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "oMltPag_MouseMove"
    Dim oCtrl           As Control

'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Procedure
    For Each oCtrl In oMltPag.Parent.Controls
        If TypeName(oCtrl) = "CommandButton" Then
            oCtrl.BackColor = Color(crButton)
            oCtrl.ForeColor = Color(crButtonFont)
        End If
    Next
                
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub



'   Public Routines



'   Private Routines
Private Function Setup(ByVal oForm As Object) As Boolean

'   Description:Set backgrounds, fonts, and position
'   Inputs:     oForm       User Form (as Object for Properties)
'   Outputs:    Me          Success/Failure
'   Requisites: Classes     clsCmd
'   Example:    ?Setup(oForm)

'     Date   Ini Modification
'   06/21/13 CWH Initial Development
'   04/05/17 CWH Allow crFrom to be a picture

'   Declarations
    Const cRoutine      As String = "Setup"
    Dim oCtrl           As Control
    Dim oPage           As Control
    Dim clsCtrl         As clsForm

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    ApyClr oForm, crForm
    For Each oCtrl In oForm.Controls
        Set clsCtrl = New clsForm
        With oCtrl
            Select Case TypeName(oCtrl)
                Case Is = "TextBox"
                    If .Name = "txtErrMsg" Then
                        .BackStyle = fmBackStyleTransparent
                        .ForeColor = Color(crFormFont)
                    Else
                        ApyClr oCtrl, crlight
                    End If
                Case Is = "ComboBox", "ListBox"
                     ApyClr oCtrl, crlight
                Case Is = "CommandButton"
                    Set clsCtrl.CommandButton = oCtrl
                    Set dicCtrls(oCtrl.Name) = clsCtrl
                    ApyClr oCtrl, crButton
                Case Is = "Image"
                    Set clsCtrl.Image = oCtrl
                    Set dicCtrls(oCtrl.Name) = clsCtrl
                    .BackColor = Color(crButton)
                Case Is = "Frame"
                    Set clsCtrl.Frame = oCtrl
                    Set dicCtrls(oCtrl.Name) = clsCtrl
                    ApyClr oCtrl, crFrame
                Case Is = "TabStrip"
                    .BackColor = Color(crForm)
                    .ForeColor = Color(crDark)
                Case Is = "MultiPage"
                    Set clsCtrl.Multipage = oCtrl
                    Set dicCtrls(oCtrl.Name) = clsCtrl
                    ApyClr oCtrl, crForm
                    For Each oPage In .Pages
                        ApyClr oCtrl, crForm
                    Next
                Case Is = "SpinButton", "ScrollBar"
                        ApyClr oCtrl, crButton
                Case Is = "Label", "CheckBox", _
                          "OptionButton", "ToggleBotton"
                        ApyClr oCtrl, crForm
            End Select
        End With
        Set clsCtrl = Nothing
    Next
    
    oForm.StartUpPosition = 3 'Windows Default
    With Application
        oForm.Left = .Left + .Width / 2 - oForm.Width / 2
        oForm.Top = .Top + .Height / 2 - oForm.Height / 2
    End With

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function




Private Function ApyClr(ByVal oControl As Object, _
                        ByVal lColor As crRequestTypes) As Boolean

'   Description:Apply color or picture to Control
'   Inputs:     oControl    Control to set
'               lColor      Color Request
'   Outputs:    Me          Success/Failure
'   Requisites: Routines    modGeneral.Color
'   Example:    ?Exists(Thisworkbook.Worksheets, "Test")

'     Date   Ini Modification
'   04/06/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "ApyClr"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    ApyClr = Failure

'   Procedure
    With oControl
        .ForeColor = Color(lColor + 1)
        If TypeName(Color(lColor)) = "Picture" Then
            .Picture = Color(lColor)
            .PictureAlignment = 2   'fmPictureAlignmentCenter
            .PictureSizeMode = 0
            .PictureTiling = True
        Else
            .BackColor = Color(lColor)
        End If
        If InStr(1, TypeName(oForm) & ",Image", TypeName(oControl)) > 0 Then
            If TypeName(Color(crSkin)) = "Picture" Then
                .Picture = Color(crSkin)
                .PictureAlignment = 2   'fmPictureAlignmentCenter
                .PictureSizeMode = 0
                .PictureTiling = True
            End If
        End If
    End With
    ApyClr = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function




Private Function Exists(ByVal oCollection As Object, _
                        ByVal sName As String, _
               Optional ByVal vItem As Variant) As Boolean

'   Description:Determine if a name exists in a collection
'   Inputs:     oCollection Collection to check
'               sName       Collection Item's Name
'               vItem       Variable to hold collection instance
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Example:    ?Exists(Thisworkbook.Worksheets, "Test")

'     Date   Ini Modification
'   01/01/01 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "Exists"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Exists = False

'   Procedure
    Set vItem = oCollection(sName)
    Exists = True

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9                                 'Do Nothing (not found)
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Attribute VB_Name = "clsSettings"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'   Version:    02/12/18
'   Save As:    clsSettings
'   Description:Save, Set and Restore System Settings
'               @Craig Hatmaker 08/07/2013
'               Others may not claim credit for, nor sell this.
'               Others may copy, modify, and distribute freely.

'   NOTE!   To make one of my existing routines into a class is inspired
'           by the work of Bern Plumoff and Jon T.  Any of this work that
'           overlaps their work is not copy protected by me.
'           See: http://www.sulprobil.com/Get_it_done/IT/Excel_Fun/Excel_VBA/VBA_Intro/VBA_08_Optimization/SystemState/systemstate.html

'   Example:Dim oSettings   as clsSettings
'           Set oSettings = New clsSettings

'   Routines (Alphabetically)

'     Date   Ini Modification
'   08/16/13 CWH Modified for Class and to include coding standards
'   09/06/13 CWH Moved Class_Terminate before Class_Initialize
'   10/28/13 CWH Added Clipboard restoration after changing calculation
'   10/22/14 CWH Changed sRoutine to cRoutine
'   10/31/16 CWH Workbook Protection
'   02/08/18 CWH Changed name for protection to match modGeneral.Protection

Option Explicit

Public WithEvents Worksheet As Worksheet
Attribute Worksheet.VB_VarHelpID = -1

Private Const cModule       As String = "clsSettings"
Private Sheet               As Object
Private SheetType           As Long
Private SheetName           As String
Private Calculation         As XlCalculation
Private EnableEvents        As Boolean
Private ScreenUpdating      As Boolean
Private ProtectContents     As Boolean
Private ProtectStructure    As Boolean
Private ProtectWindows      As Boolean
Private sPassword           As String

Private Sub Class_Terminate()
    Restore
End Sub

Private Sub Class_Initialize()
    With ActiveSheet
        If Not IsError(.Evaluate("PWD" & .Name)) Then _
            sPassword = Evaluate("PWD" & .Name)
    End With
    Save
    Disable
End Sub


Public Sub Save()

'   Description:Save System Settings
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: *None
'   Example:    Dim clsStg as clsSettings
'               Set clsStg = New clsSettings
'               clsStg.Save *NOTE! This is not necessary

'     Date   Ini Modification
'   08/16/13 CWH Initial Development
'   10/31/16 CWH Workbook Protection

'   Declarations
    Const cRoutine      As String = "Save"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    Set Sheet = ActiveSheet
    SheetType = ActiveSheet.Type
    SheetName = ActiveSheet.Name
    EnableEvents = Application.EnableEvents
    ScreenUpdating = Application.ScreenUpdating
    Calculation = Application.Calculation
    ProtectContents = ActiveSheet.ProtectContents
    ProtectStructure = ActiveWorkbook.ProtectStructure
    ProtectWindows = ActiveWorkbook.ProtectWindows
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub


Public Sub Restore()

'   Description:Save System Settings
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: *None
'   Example:    Dim clsStg as clsSettings
'               Set clsStg = New clsSettings
'               clsStg.Restore *NOTE! This is not necessary

'     Date   Ini Modification
'   08/16/13 CWH Initial Development
'   10/31/16 CWH Workbook Protection

'   Declarations
    Const cRoutine      As String = "Restore"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    Sheet.Activate
    Application.EnableEvents = EnableEvents
    Application.ScreenUpdating = ScreenUpdating
    Application.Calculation = Calculation
    If ProtectContents Then _
        Sheet.Protect sPassword Else _
            Sheet.Unprotect sPassword
    If ProtectStructure Or ProtectContents Then _
        ActiveWorkbook.Protect sPassword, ProtectStructure, ProtectWindows
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Is = 424, 1004: Resume Next
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Public Sub Clear()

'   Description:Set System Settings to Default
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: *None
'   Example:    Dim clsStg as clsSettings
'               Set clsStg = New clsSettings
'               clsStg.Clear

'     Date   Ini Modification
'   08/16/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "Clear"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    Application.EnableEvents = True
    Application.SceenUpdating = True
    OpenClipboard 0
    Application.Calculation = xlCalculationAutomatic
    CloseClipboard
    ActiveSheet.Unprotect sPassword
    ActiveWorkbook.Unprotect sPassword
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Public Sub Disable()

'   Description:Disable Events and Updating
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: *None
'   Example:    Dim clsStg as clsSettings
'               Set clsStg = New clsSettings
'               clsStg.Save *NOTE! This is not necessary

'     Date   Ini Modification
'   08/16/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "Disable"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    OpenClipboard 0
    Application.Calculation = xlCalculationManual
    CloseClipboard
    ActiveSheet.Unprotect sPassword
    ActiveWorkbook.Unprotect sPassword
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:                             'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Public Sub Protect()

'   Description:Protect Activesheet
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: *None
'   Example:    Dim clsStg as clsSettings
'               Set clsStg = New clsSettings
'               clsStg.Save *NOTE! This is not necessary

'     Date   Ini Modification
'   08/16/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "Protect"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    With ActiveSheet
        .Protect _
            Password:=sPassword, _
            Contents:=True
        .Protect _
            DrawingObjects:=True, _
            Contents:=True, _
            Scenarios:=True, _
            AllowInsertingRows:=True, _
            AllowDeletingRows:=True, _
            AllowSorting:=True, _
            AllowFiltering:=True
        .EnableSelection = xlUnlockedCells
    End With
    ThisWorkbook.Protect sPassword, True
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Public Sub Display()

'   Description:Displayz System Settings
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: *None
'   Example:    Dim clsStg as clsSettings
'               Set clsStg = New clsSettings
'               clsStg.Display

'     Date   Ini Modification
'   08/16/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "Display"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    Debug.Print "SheetType        State:"; ActiveSheet.Type, " Save:"; SheetType
    Debug.Print "SheetName        State:"; ActiveSheet.Name, " Save:"; SheetName
    Debug.Print "EnableEvents     State:"; Application.EnableEvents, , " Save:"; EnableEvents
    Debug.Print "ScreenUpdating   State:"; Application.ScreenUpdating, , " Save:"; ScreenUpdating
    Debug.Print "Calculation      State:"; Application.Calculation, " Save:"; Calculation
    Debug.Print "ProtectContents  State:"; ActiveSheet.ProtectContents, , " Save:"; ProtectContents
    Debug.Print "ProtectStructure State:"; ActiveWorkbook.ProtectStructure, , " Save:"; ProtectStructure
    Debug.Print "ProtectWindows   State:"; ActiveWorkbook.ProtectWindows, , " Save:"; ProtectWindows
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub

Attribute VB_Name = "frmMsg"
Attribute VB_Base = "0{95C9018D-E8FC-4730-A6F3-322F1673DB03}{4BB3357C-8B9C-4942-AD9D-3ED534E81812}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'   Version:    10/16/17

'   Save As:    frmMsg.frm
'   Description:Mimics VBA's Message Box w/branding
'   Requisites: Classes:    clsFrom
'   Example:    ?frmMsg.Display("Prompt", vbAbortRetryIgnore, "Title")

'     Date   Ini Modification
'   01/16/12 CWH Redesign
'   04/25/12 CWH Set Height
'   04/30/12 CWH Applied new error processing standards
'   01/02/13 CWH Version 2013.01
'   04/26/13 CWH Version 2013.04
'   07/05/13 CWH Switched to clsForm and clsCmd for colors
'   08/19/14 CWH Parameter standardization
'   10/16/17 CWH Changed from CONST AprvdSavers to name Savers

Option Explicit

Dim sCaption        As String   'Button Caption
Dim sHelpFile       As String   'Help File
Dim lHelpContext    As Long     'Help Context

Private Sub UserForm_Initialize()
'   NOTE! Static - to keep in memory after this routine ends
    Static FormClass As New clsForm
    Set FormClass.UserForm = Me
End Sub

'   Event Handlers
Private Sub cmd1_Click(): Button_Click cmd1: End Sub
Private Sub cmd2_Click(): Button_Click cmd2: End Sub
Private Sub cmd3_Click(): Button_Click cmd3: End Sub
Private Sub cmd4_Click(): Button_Click cmd4: End Sub


'   Public Methods
Public Function Display(ByVal Prompt As String, _
               Optional ByVal Buttons As VbMsgBoxStyle = -1, _
               Optional ByVal Title As String = "", _
               Optional ByVal HelpFile As String = "", _
               Optional ByVal HelpContext As Long = 0) As VbMsgBoxResult

'   Description:Mimics VBA's Message Box to a limited degree w/branding
'   Inputs:     Message     Text to display
'               Title       Text for the form's title
'               Buttons     Which buttons to display
'               HelpFile    Help File (if "Buttons" includes vbMsgBoxHelpButton)
'               HelpContext Help File Context
'   Outputs:    Display     Success/Failure
'   Requisites
'   Example:    ?frmMsg.Display("Retrieving Records", "Load_Click")
'               ?frmMsg.Display("Retrieving Records", "Load_Click")
'   NOTES:      vBtns(#, 0) Caption
'               vBtns(#, 1) Default/Cancel/neither
'
'     Date   Ini Modification
'   12/08/11 CWH Redesign
'   12/03/12 CWH Version 2013.01
'   10/16/17 CWH Changed from CONST AprvdSavers to name Savers

'   Declarations
    Dim sRoutine        As String       'Routine's Name
    Static DoneThat     As Boolean
    Dim bHelp           As Boolean      'Help Button Request
    Dim sBtns(3, 1)     As String       'Command Buttons Array
    Dim lBtn            As Long         'Command Button #
    Dim sSavers         As String       'Approved Savers
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    sRoutine = Me.Name & ".Display"
    Display = Failure
    
'   Check Inputs
    sHelpFile = HelpFile
    lHelpContext = HelpContext

'   Initialize Variables
    If IsError([Savers]) Then _
        sSavers = Environ("UserName") Else _
            sSavers = [Savers]
    If Not DoneThat Then
        DoneThat = True:
        txtMsg.BackStyle = fmBackStyleOpaque
        txtMsg.BackColor = Color(crForm)
        txtMsg.ForeColor = Color(crFormFont)
    End If
    txtMsg = Prompt
    Caption = Title
    Me.Height = 120
    lBtn = -1
    
'   Procedure
    If Buttons >= vbMsgBoxHelpButton Then
        Buttons = Buttons - vbMsgBoxHelpButton
        If sHelpFile <> "" Then lBtn = lBtn + 1: sBtns(lBtn, 0) = "Help"
    End If
    Select Case Buttons
        Case Is = -1
            Me.Height = Me.txtMsg.Height + 35
        Case Is = vbOKCancel:
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "OK":     sBtns(lBtn, 1) = "Default"
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Cancel": sBtns(lBtn, 1) = "Cancel"
        Case Is = vbAbortRetryIgnore
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Abort":  sBtns(lBtn, 1) = "Default"
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Retry":
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Ignore": sBtns(lBtn, 1) = "Cancel"
        Case Is = vbYesNoCancel
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Yes":    sBtns(lBtn, 1) = "Default"
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "No":
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Cancel": sBtns(lBtn, 1) = "Cancel"
        Case Is = vbYesNo
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Yes":    sBtns(lBtn, 1) = "Default"
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "No":     sBtns(lBtn, 1) = "Cancel"
        Case Is = vbRetryCancel
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Retry":  sBtns(lBtn, 1) = "Default"
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "Cancel": sBtns(lBtn, 1) = "Cancel"
        Case Else:
            lBtn = lBtn + 1: sBtns(lBtn, 0) = "OK":     sBtns(lBtn, 1) = "Default"
    End Select
    For lBtn = 0 To 3
        With Controls("cmd" & lBtn + 1)
            .Caption = sBtns(lBtn, 0)
            .Visible = sBtns(lBtn, 0) <> ""
            .Default = sBtns(lBtn, 1) = "Default"
            .Cancel = sBtns(lBtn, 1) = "Cancel"
        End With
    Next
    txtMsg.SetFocus: 'txtMsg.CurLine = 0
    Show vbModeless
    DoEvents
    If Buttons = -1 Then
        Display = Success
    Else
        While Me.Visible: DoEvents: Wend
        Display = Result
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Else:      'Display Error Message in Message Box
        '   NOTE! Avoid DspErrMsg to prevent endless recursion possibility
            Select Case MsgBox("Error#" & Err.Number & ":" & Err.Description, _
                                IIf(InStr(1, sSavers, Environ("UserName"), vbTextCompare) > 0, _
                                    vbAbortRetryIgnore, vbCritical) + _
                                    IIf(Err.Number = 999, 0, vbMsgBoxHelpButton), _
                                sRoutine, _
                                Err.HelpFile, _
                                Err.HelpContext)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


' Private Routines
Private Function Button_Click(ByVal oCtrl As Control) As Boolean

'   Description:Handles Command Button Click
'   Inputs:     oCtrl       Clicked Command Button
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Example:    ?Button_Click(frmMsg.Contorls("cmd1"))
'
'     Date   Ini Modification
'   12/01/12 CWH Version 2013.01

'   Declarations
    Dim sRoutine        As String       'Routine's Name
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    sRoutine = Me.Name & ".Button_Click"
    Button_Click = Failure
    
'   Procedure
    sCaption = oCtrl.Caption
    Select Case sCaption
        Case Is = "Help": Application.Help sHelpFile, lHelpContext
        Case Else:        Me.Hide
    End Select
    
    Button_Click = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:  'Do nothing
        Case Else:          'Display Error Message in Message Box
            Select Case DspErrMsg(sRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function Result() As VbMsgBoxResult
    Select Case sCaption
        Case Is = "OK":     Result = vbOK
        Case Is = "Cancel": Result = vbCancel
        Case Is = "Abort":  Result = vbAbort
        Case Is = "Retry":  Result = vbRetry
        Case Is = "Ignore": Result = vbIgnore
        Case Is = "Yes":    Result = vbYes
        Case Is = "No":     Result = vbNo
        Case Else:          Result = Failure
    End Select
End Function


Attribute VB_Name = "frmOrgChart"
Attribute VB_Base = "0{1D8E926D-919E-42A3-A3AF-E48C178C802C}{43CA95F0-8256-4F45-9592-B48243CC5CE4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'   Version:    11/30/18

'   Save As:    frmOrgChart.frm

'   Description:Org Chart Wizard
'   Requisites: Classes:    clsForm
'               Functions:
'   Interface:  See Display

'     Date   Ini Modification
'   01/29/15 CWH Original Programming
'   02/24/15 CWH See SetMsg
'   08/04/17 CWH Removed hidden tables from ComboBox
'   08/07/17 CWH Changed from AddNode to AddNod
'   12/07/17 CWH Added Skin table
'   11/30/18 CWH Added check for tables

Option Explicit

Private Const cModule           As String = "frmOrgChart"
Private WithEvents oApplication As Application      'Used with GetAddress parameter
Attribute oApplication.VB_VarHelpID = -1
Private oWkb                    As Workbook         'Active Workbook
Private bOK                     As Boolean



Private Sub UserForm_Initialize()
'   NOTE! Static - to keep in memory after this routine ends
    Static FormClass As New clsForm
    Set FormClass.UserForm = Me
    Set oApplication = Application
    bOK = False
    StartUpPosition = 3 'Windows Default
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'   If "X" clicked, cancel unloading. Use cmdExit_Click instead
    If CloseMode = vbFormControlMenu Then
        Cancel = True
        cmdExit_Click
    End If
End Sub

'   Event Handlers

Private Sub cmdOK_Click():            bOK = True:  Me.Hide:                     End Sub
Private Sub cmdExit_Click():          bOK = False: Me.Hide:                     End Sub
Private Sub spnHeight_SpinUp():       txtHeight = Val(txtHeight) + 1:           End Sub
Private Sub spnHeight_SpinDown():     txtHeight = Application.Max(0, Val(txtHeight) - 1): End Sub
Private Sub spnWidth_SpinUp():        txtWidth = Val(txtWidth) + 1:             End Sub
Private Sub spnWidth_SpinDown():      txtWidth = Application.Max(0, Val(txtWidth) - 1): End Sub
Private Sub spnSeparation_SpinUp():   txtSeparation = Val(txtSeparation) + 1:   End Sub
Private Sub spnSeparation_SpinDown(): txtSeparation = Application.Max(0, Val(txtSeparation) - 1): Application.EnableEvents = True: End Sub
Private Sub cboTable_Change():         Validate cboTable, ActiveSheet:          End Sub

Private Sub cmdRight_Click()
    txtLayout = IIf(Len(Trim(txtLayout)) > 0 And _
        Not txtLayout Like "*" & vbLf, txtLayout & "|1a|", txtLayout) & lstNodeText.Text
End Sub

Private Sub cmdDown_Click()
    txtLayout = IIf(Len(Trim(txtLayout)) > 0, txtLayout & "|14|" & vbLf, "")
End Sub

Private Sub cmdLeft_Click()
    Dim sLines()        As String
    Dim sHeadings()     As String
    Dim sHeading        As String
    If txtLayout Like "*|14|" & vbCr & vbLf Then txtLayout = Left(txtLayout, Len(txtLayout) - 3)
    sLines = Split(txtLayout, "|14|" & vbCr & vbLf)
    If UBound(sLines) >= 0 Then
        sHeadings = Split(sLines(UBound(sLines)), "|1a|")
        txtLayout = Left(txtLayout, Len(txtLayout) - Len(sHeadings(UBound(sHeadings))))
        If txtLayout Like "*" & vbCr & vbLf Then txtLayout = Left(txtLayout, Len(txtLayout) - 3)
        If txtLayout Like "*|1a|" Then txtLayout = Left(txtLayout, Len(txtLayout) - 1)
    End If
End Sub

Private Sub lstNodeText_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    cmdRight_Click
End Sub

Private Sub lstNodeText_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 32 Then cmdRight_Click
End Sub

Private Sub oApplication_WorkbookActivate(ByVal Wb As Workbook)
    If Me.Visible Then Me.txtTopLeft = ActiveCell.Address(External:=True)
End Sub

Private Sub oApplication_SheetSelectionChange(ByVal sh As Object, _
                                              ByVal Target As Range)
    If Me.Visible Then Me.txtTopLeft = Target.Address(External:=True)
End Sub


'   Procedures
Public Function Display() As Boolean

'   Description:Mimic VBA's InputBox w/benefits!
'   Inputs:
'   Outputs:    Me              Success/Failure
'   Requisites: Properties      oWkb - Active Workbook
'   Example:

'   Declarations
    Const cRoutine      As String = "Display"
    Dim oSettings       As clsSettings
    Dim oWks            As Worksheet
    Dim oLo             As ListObject
    Dim oTopLeft        As Range
    Dim oControl        As Control
    Dim bReady          As Boolean
    
'   Error Handling and Function initialization
    On Error GoTo ErrHandler

'   Initialize Variables
    Set oWkb = ActiveWorkbook
    Set oWks = ActiveSheet
    Application.EnableEvents = True

'   Check Inputs and Requisites
    If Tables(oWkb, True).Count = 0 Then Err.Raise DspError, , _
        "Problem:" & vbTab & ThisWorkbook.Name & " requires data in tables." & vbLf & _
        "Fix:" & vbTab & "To make your data a table see: " & vbLf & _
                 vbTab & "https://www.contextures.com/xlExcelTable01.html"

'   Procedure
'   Set Defaults
    For Each oControl In Me.Controls
        If SetDefault(oControl, oWks) = Failure Then _
            Err.Raise NoError, , "SetDefault raised error"
    Next
    While Not bReady
        Me.Show vbModeless
        SetFocus cboTable
    '   Wait for cmdOK or cmdExit
        While Me.Visible
            DoEvents
            If oControl Is Nothing Then Set oControl = ActiveControl
            If ActiveControl <> oControl Then _
                Field_Exit oControl, oWks: Set oControl = ActiveControl
        Wend
    '   Final Validation
        bReady = True
        If bOK Then
            For Each oControl In Me.Controls
                If Validate(oControl, oWks) = Failure Then bReady = False
            Next
        End If
    Wend
    
'   Create Chart
    Display = bOK
    If bOK Then
    '   Create chart
        Set oSettings = New clsSettings
        If Not Exists(Tables(oWkb), cboTable.Value, oLo) Then Err.Raise DspError, , _
            "Problem:" & vbTab & cboTable.Value & " not found." & vbLf & _
            "Fix:" & vbTab & "Unload and reload " & ThisWorkbook.Name
        Set oTopLeft = oWks.Evaluate(txtTopLeft.Value)
        AddNod sNodeID:=cboStart.Value, _
                sParentID:=vbNullString, _
                oData:=oLo, _
                lNodes:=oLo.ListColumns(cboNodes.Value).index, _
                lParents:=oLo.ListColumns(cboParents.Value).index, _
                oWks:=oTopLeft.Worksheet, _
                sNodeText:=txtLayout, _
                lTop:=oTopLeft.Top, _
                lLeft:=oTopLeft.Left, _
                lHeight:=Val(txtHeight), _
                lWidth:=Val(txtWidth), _
                lSeparation:=Val(txtSeparation.Value), _
                lStyle:=optTD * -1 + optLR * -2 + optOL * -3
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:    'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    Me.Hide

End Function



Private Function Fill(ByRef oComboBox As MSForms.ComboBox, _
                      ByVal vList As Variant) As Boolean
    
'   Description:Fill a ComboBox List
'   Inputs:     oComboBox       ComboBox to fill with values
'               sList           Values List
'   Outputs:    Me              Success/Failure
'   Example:    Fill Me.Controls(1), "True,False"

'     Date   Ini Modification
'   08/14/11 CWH Initial Programming
'   11/26/12 CWH Version 2013.01
    
'   Declarations
    Const cRoutine      As String = "Fill"
    Dim v               As Variant      'Generic Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Fill = Failure

'   Procedure
    With oComboBox
        .RowSource = ""
        .Clear
        Select Case TypeName(vList)
            Case Is = "Range"
                If vList.Rows.Count = 1 And vList.Columns.Count > 1 Then
                    For Each v In vList.Cells: .AddItem v: Next
                Else
                    .RowSource = cAddress(vList.Columns(1))
                End If
            Case Is = "ListObject"
                .RowSource = cAddress(vList.DataBodyRange.Columns(1))
            Case Is = "Variant()"
                For Each v In vList: .AddItem v: Next
            Case Is = "String"
                If vList Like "=*" Then
                    If TypeName(Evaluate(vList)) = "Range" Then _
                        .RowSource = cAddress(Evaluate(vList).Columns(1)) Else _
                            For Each v In Split(v, ","): .AddItem v: Next
                Else
                    If Not vList Like "*,*" Then vList = Collection2CSV(vList, True)
                    For Each v In Split(vList, ",")
                        If v Like "'*" Then v = Right(Trim(v), Len(Trim(v)) - 1)
                        .AddItem v
                    Next
                End If
            Case Else
                v = Collection2CSV(vList, True)
                For Each v In Split(v, ","): .AddItem v: Next
        End Select
    End With
    Fill = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 380: 'Can't set rowsource
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Private Function Field_Exit(ByVal oControl As Control, _
                            ByVal oWks As Worksheet) As Boolean

'   Description:Handles exiting a field event
'   Inputs:     oControl        Control being exited
'               oWks            Worksheet
'   Outputs:    Me              Success/Failure
'   Example:    ?Field_Exit(txtBox1)

'     Date   Ini Modification
'   04/17/14 CWH Initial Programming
    
'   Declarations
    Const cRoutine      As String = "Field_Exit"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Field_Exit = Failure

'   Procedure
    lblMsg = ""
    If Validate(oControl, oWks) = Failure Then _
        SetFocus oControl Else _
            SetFocus ActiveControl
    Field_Exit = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Private Function SetFocus(ByVal oControl As Control) As Boolean

'   Description:Does what set focus should do but doesn't
'   Inputs:     oControl        Control to receive focus
'   Outputs:    Me              Success/Failure
'   Example:    ?SetFocus(txtBox1)

'     Date   Ini Modification
'   04/17/14 CWH Initial Programming
    
'   Declarations
    Const cRoutine      As String = "SetFocus"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetFocus = Failure

'   Procedure
    With oControl
        Select Case TypeName(oControl)
            Case Is = "ComboBox", "TextBox"
                .SetFocus
                .SelStart = 0
                .SelLength = Len(oControl)
            Case Is = "ListBox"
                .SetFocus
        End Select
    End With
    SetMsg oControl
    SetFocus = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Private Function SetMsg(ByVal oControl As Control) As Boolean

'   Description:Set lblMsg text for a control
'   Inputs:     oControl        Control to describe
'   Outputs:    Me              Success/Failure
'   Example:    ?SetMsg(txtBox1)

'     Date   Ini Modification
'   02/28/15 CWH Initial Programming
    
'   Declarations
    Const cRoutine      As String = "SetMsg"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetMsg = Failure

'   Procedure
    With lblMsg
        .Caption = oControl.Name
        Select Case oControl.Name
            Case Is = "cboTable"
                .Caption = "Select table containing items to graph"
            Case Is = "cboNodes"
                .Caption = "Select column containing unique Item IDs" & vbLf & _
                           "NOTE! Items belonging to multiple parents " & vbLf & _
                           "      create duplicates. The item's chart element " & vbLf & _
                           "      may require manual placement adjustment."
            Case Is = "cboParents"
                .Caption = "Select column containing items' parent IDs"
            Case Is = "cboStart"
                .Caption = "Select first/top level item to start chart"
            Case Is = "txtTopLeft"
                .Caption = "Click on cell for chart's top left corner"
            Case Is = "txtHeight"
                .Caption = "Indicate how tall to make each item's chart element"
            Case Is = "txtWidth"
                .Caption = "Indicate how wide to make each item's chart element"
            Case Is = "lstNodeText"
                .Caption = "Select columns to assemble item's chart element text"
            Case Is = "txtSeparation"
                .Caption = "Indicate how much space to place between item chart elements"
            Case Is = "optTD"
                .Caption = "Draws parents centered over children"
            Case Is = "optLR"
                .Caption = "Draws parents centered left of children"
            Case Is = "optOL"
                .Caption = "Draws items as an outline"
        End Select
    End With
    SetMsg = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Private Function Validate(ByVal oControl As Control, _
                          ByVal oWks As Worksheet) As Boolean

'   Description:Validates controls
'   Inputs:     oControl        Control to receive focus
'               oWks            Worksheet
'   Outputs:    Me              Success/Failure
'   Example:    ?Validate(cboTable, ActiveSheet)
'     Date   Ini Modification
'   04/17/14 CWH Initial Programming
    
'   Declarations
    Const cRoutine      As String = "Validate"
    Dim oLoSkin         As ListObject   'Skin Table
    Dim oRng            As Range        'Used for cboTable
    Dim oCel            As Range        'Used for cboTable
    Dim oGood           As Range        'Good Style
    Dim oBad            As Range        'Bad  Style
    Static sTable       As String       'Old Value
    Static sNodes       As String       'Old Value
    Static sParents     As String       'Old Value
    Static sStart       As String       'Old Value
   
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Validate = Failure
    
'   Initialize Variables
    If Not Exists(Tables(ThisWorkbook), "Skin", oLoSkin) Then _
        Err.Raise DspError, , ThisWorkbook.Name & " is corrupt. Get a new copy"
    Set oGood = XLookup(oLoSkin, "Format", "Good")
    Set oBad = XLookup(oLoSkin, "Format", "Bad")

'   Procedure
    Select Case oControl.Name
        Case Is = "cboTable"
            If Not cboTable.MatchFound Then
                oControl.BackColor = oBad.Interior.Color
                lblMsg = lblMsg & IIf(lblMsg <> vbNullString, vbLf, "") & _
                    "Select a table from the dropdown list"
            Else
                Validate = Success
                oControl.BackColor = oGood.Interior.Color
                If sTable <> cboTable.Value Then
                    sTable = cboTable.Value
                    SetDefault cboNodes, oWks
                    SetDefault cboParents, oWks
                    SetDefault cboStart, oWks
                    SetDefault lstNodeText, oWks
                    txtLayout = ""
                End If
            End If
        Case Is = "cboNodes"
            If Not cboNodes.MatchFound Then
                oControl.BackColor = oBad.Interior.Color
                lblMsg = lblMsg & IIf(lblMsg <> vbNullString, vbLf, "") & _
                    "Select a column from the dropdown list"
            Else
                Validate = Success
                oControl.BackColor = oGood.Interior.Color
                If sNodes <> cboNodes.Value Then
                    sNodes = cboNodes.Value
                    Set oRng = Evaluate(cboTable.Value).ListObject _
                        .ListColumns(cboNodes.Value).DataBodyRange
                    cboStart.Enabled = True
                    SetDefault cboStart, oWks
                End If
            End If
        Case Is = "cboParents"
            If Not cboParents.MatchFound Then
                oControl.BackColor = oBad.Interior.Color
                lblMsg = lblMsg & IIf(lblMsg <> vbNullString, vbLf, "") & _
                    "Select a column from the dropdown list"
                SetFocus oControl
            ElseIf cboParents.Value = cboNodes.Value Then
                oControl.BackColor = oBad.Interior.Color
                lblMsg = lblMsg & IIf(lblMsg <> vbNullString, vbLf, "") & _
                    "Parents cannot be the same as Nodes"
            Else
                oControl.BackColor = oGood.Interior.Color
                Validate = Success
            End If
        Case Is = "cboStart"
            If Not cboParents.MatchFound Then
                oControl.BackColor = oBad.Interior.Color
                lblMsg = lblMsg & IIf(lblMsg <> vbNullString, vbLf, "") & _
                    "Select a start node from the dropdown list"
            Else
                oControl.BackColor = oGood.Interior.Color
                Validate = Success
            End If
        Case Is = "txtTopLeft"
            If TypeName(Evaluate(txtTopLeft.Value)) <> "Range" Then _
                txtTopLeft = ActiveCell.Address(External:=True)
            Validate = Success
        Case Else
            Validate = Success
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Private Function SetDefault(ByVal oControl As Control, _
                            ByVal oWks As Worksheet) As Boolean

'   Description:Set control Defaults
'   Inputs:     oControl        Control to set
'   Outputs:    Me              Success/Failure
'   Example:    ?SetDefaults(cboTable)

'     Date   Ini Modification
'   04/17/14 CWH Initial Programming
    
'   Declarations
    Const cRoutine      As String = "SetDefault"
    Dim oLo             As ListObject
    Dim oRng            As Range
    Dim oCel            As Range
    Dim sOldValue       As String
   
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetDefault = Failure
    
'   Check Inputs and Requisites
    If Tables(oWkb, True).Count = 0 Then Err.Raise DspError, , _
        "Problem:" & vbTab & ThisWorkbook.Name & " requires data in tables." & vbLf & _
        "Fix:" & vbTab & "To make your data a table see: " & vbLf & _
                 vbTab & "https://www.contextures.com/xlExcelTable01.html"

'   Procedure
    Select Case oControl.Name
        Case Is = "cboTable"
            sOldValue = oControl.Value
            cboTable.Clear
            Fill cboTable, Tables(oWkb, True)
            cboTable = sOldValue
            If Not cboTable.MatchFound Then cboTable.Value = cboTable.List(0)
            SetDefault cboNodes, oWks
            SetDefault cboParents, oWks
            SetDefault lstNodeText, oWks
        Case Is = "cboNodes"
            sOldValue = oControl.Value
            If Not Exists(Tables(oWkb), cboTable.Value, oLo) Then Err.Raise DspError, , _
                "Problem:" & vbTab & cboTable.Value & " not found." & vbLf & _
                "Fix:" & vbTab & "Unload and reload add-in " & ThisWorkbook.Name
            Set oRng = oLo.HeaderRowRange
            Fill cboNodes, Collection2CSV(modGeneral.Get_Distinct(oRng), True)
            cboNodes = sOldValue
            If Not cboNodes.MatchFound Then cboNodes.Value = cboNodes.List(0)
        Case Is = "cboParents"
            sOldValue = oControl.Value
            If Not Exists(Tables(oWkb), cboTable.Value, oLo) Then Err.Raise DspError, , _
                "Problem:" & vbTab & cboTable.Value & " not found." & vbLf & _
                "Fix:" & vbTab & "Unload and reload add-in " & ThisWorkbook.Name
            Set oRng = oLo.HeaderRowRange
            Fill cboParents, Collection2CSV(modGeneral.Get_Distinct(oRng), True)
            cboParents = sOldValue
            If Not cboParents.MatchFound Then cboParents.Value = cboParents.List(0)
        Case Is = "cboStart"
            sOldValue = oControl.Value
            If Not Exists(Tables(oWkb), cboTable.Value, oLo) Then Err.Raise DspError, , _
                "Problem:" & vbTab & cboTable.Value & " not found." & vbLf & _
                "Fix:" & vbTab & "Unload and reload add-in " & ThisWorkbook.Name
            Set oRng = oLo.DataBodyRange
            Fill cboStart, Collection2CSV(modGeneral.Get_Distinct(oRng), True)
            oControl.Value = sOldValue
            If Not cboStart.MatchFound Then cboStart.Value = cboStart.List(0)
        Case Is = "txtTopLeft"
            If TypeName(Evaluate(txtTopLeft.Value)) <> "Range" Then _
                txtTopLeft = ActiveCell.Address(External:=True)
        Case Is = "lstNodeText"
            If Not Exists(Tables(oWkb), cboTable.Value, oLo) Then Err.Raise DspError, , _
                "Problem:" & vbTab & cboTable.Value & " not found." & vbLf & _
                "Fix:" & vbTab & "Unload and reload add-in " & ThisWorkbook.Name
            Set oRng = oLo.HeaderRowRange
            lstNodeText.Clear
            For Each oCel In oRng.Cells: lstNodeText.AddItem oCel: Next
        Case Is = "txtHeight"
            If Val(txtHeight) = 0 Then txtHeight = 75
        Case Is = "txtWidth"
            If Val(txtWidth) = 0 Then txtWidth = 125
        Case Is = "txtSeparation"
            If Val(txtSeparation) = 0 Then txtSeparation = 10
    End Select
    SetDefault = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function





Attribute VB_Name = "modGeneral"
'   Version:    05/17/18
'   Save As:    modGeneral
'   Description:General purpose/Often used routines

'     Date   Ini Modification
'   07/11/17 CWH Version 2017.07    'Standardization and trimming
'   07/13/17 CWH See Tables()
'   08/05/17 CWH See SelRows
'   09/02/17 CWH Added Option Compare Text
'   09/25/17 CWH Added UpdXLT
'   09/26/17 CWH See Exists
'   10/16/17 CWH Changed from CONST AprvdSavers to name Savers
'   10/19/17 CWH Added GUID Generator to string functions
'   11/22/17 CWH Added IsIn()
'   12/08/17 CWH Added XLookup()
'   12/11/17 CWH Added MLookup()
'   01/03/18 CWH see XLookup() and MLookup()
'   01/11/18 CWH See IsIn()
'   01/22/18 CWH Added HasAutoFilter()
'   01/29/18 CWH Added RmvRng()
'   02/08/18 CWH Add Protect(). See also Exists()
'   02/10/18 CWH See Collection2CSV
'   02/24/18 CWH Remove error 13 logging from XLookup and MLookup
'   02/27/18 CWH See PivotTables
'   03/21/18 CWH Added IsDST
'   05/04/18 CWH See Collection2CSV
'   05/17/18 CWH See GetCN

'   Routine Sections:
'       Template
'       Error Handling
'       Utilities and Servers (Color and Class)
'       "Is" functions
'       "Has" functions
'       "In" functions
'       "Exists" functions and <Collections> functions
'       Conversion Functions
'       CSV Functions
'       Array Functions
'       String Functions
'       Table Functions
'       Search and Update Functions

'   Naming Conventions
'       Variable Types - Prefixes for variable names
'           b       Boolean
'           c       Currency        Use for most decimal values
'           d       Date
'           f       Float (double)  Use Currency if it will work
'           l       Long            Use this instead of Integers
'           o       Object
'           s       String
'           v       Variant
'       VBE Object Types - Prefixes for VBE Project object names
'           cls     Class Module
'           frm     UserForm
'           mod     Module
'           wks     Worksheet
'       Form Controls - Prefixes for UserForm control names
'           cbo     ComboBox
'           chk     CheckBox
'           cmd     Command Button
'           grp     Group/Frame
'           img     Image/Picture
'           lbl     Label
'           lst     ListBox
'           mlt     MultiPage
'           opt     Option/Radio Button
'           pag     Page
'           scr     SrollBar
'           spn     Spin Button
'           tab     Tab Strip
'           tgl     Toggle Button
'           txt     TextBox
'       Verbs - Start routine names
'           Add     Add
'           Clr     Clear
'           Cls     Close
'           Crt     Create
'           Del     Delete
'           Dsp     Display
'           Exp     Export
'           Get     Get
'           Imp     Import
'           Inp     Input
'           Lod     Load
'           Log     Log
'           Prt     Print
'           Rmv     Remove
'           Rtn     Return
'           Sav     Save
'           Set     Set
'       Nouns - Used in Variable and Routine names
'           Cel     Cell
'           Cht     Chart
'           Col     Collection
'           Cls     Class
'           Dic     Dictionary
'           Err     Error
'           LO      ListObject  (use in variable names)
'           LR      ListRows
'           LC      ListColumn
'           Msg     Message
'           Tbl     Table       (use in routine names)
'           Txt     Text
'           Pvt     Pivot
'           Qry     QueryTable
'           Rng     Range
'           Shp     Shape
'           Val     Value
'           Wkb     Workbook
'           Wks     Worksheet

'Options
Option Explicit
Option Private Module
Option Compare Text

'Private Constants
Private Const cModule       As String = "modGeneral"

'Global Constants
Global Const Success        As Boolean = False
Global Const Failure        As Boolean = True
Global Const NoError        As Long = 0         'No Error
Global Const LogError       As Long = 997       'Log Error
Global Const RtnError       As Long = 998       'Return Error
Global Const DspError       As Long = 999       'Display Error

'Enumerations
Enum csRequestType      'Class Server Request Types
    csGet
    csRmv
    csSav
    csClr
    csLst
    [_cs]
End Enum

Enum prRequest          'Protection Requests
    prUnprotect
    prRestore
    [_pr]
End Enum

Enum rxRequestType      'RegEx Request Types
    rxTest
    rxReplace
    rxExecute
    [_rx]
End Enum

Enum crRequestTypes     'Color Request Types
     crReset
     crLogo
     crSkin
     crForm
     crFormFont
     crFrame
     crFrameFont
     crButton
     crButtonFont
     crButtonGlow
     crButtonGlowFont
     crDark
     crDarkFont
     crlight
     crLightFont
     crAccentDark
     crAccentDarkFont
     crAccent
     crAccentFont
     crAccentlight
     crAccentLightFont
     crTableStyle
     crPivotTableStyle
     crSlicerStyle
     crBackground
     crChartStyle
     crChartColor
     crChartArea
     crPlotArea
     crChartTitleLocation
     crChartLegendLocation
     [_cr]
End Enum
    
'   API Classes
Global oClipboard           As Object       'Clipboard

Private Type GUID_TYPE                      'GUID
                Data1       As Long
                Data2       As Integer
                Data3       As Integer
                Data4(7)    As Byte
End Type

#If VBA7 And Win64 Then
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
'   Clipboard
    Public Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
    Public Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
    Public Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
'   Play a sound
    Public Declare PtrSafe Function sndPlaySound32 Lib "winmm.dll" _
        Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
'   Get Key state
    Public Declare PtrSafe Function GetAsyncKeyState Lib "user32" (ByVal vKey As LongPtr) As Integer
'   Twips per Pixel
    Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As LongPtr) As Long
    Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As LongPtr, ByVal hdc As LongPtr) As Long
    Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hdc As LongPtr, ByVal nIndex As Long) As Long
'   10 Millisecond counter
    Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
'   GUID
    Private Declare PtrSafe Function CoCreateGuid Lib "ole32.dll" (guid As GUID_TYPE) As LongPtr
    Private Declare PtrSafe Function StringFromGUID2 Lib "ole32.dll" (guid As GUID_TYPE, ByVal lpStrGuid As LongPtr, ByVal cbMax As Long) As LongPtr
#Else
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
'   Clipboard
    Public Declare Function OpenClipboard Lib "User32.dll" (ByVal hwnd As Long) As Long
    Public Declare Function EmptyClipboard Lib "User32.dll" () As Long
    Public Declare Function CloseClipboard Lib "User32.dll" () As Long
'   Play a sound
    Public Declare Function sndPlaySound32 Lib "winmm.dll" _
        Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
'   Get Key state
    Public Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
'   Twips per Pixel
    Public Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
    Public Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
    Public Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
'   10 Millisecond counter
    Public Declare Function GetTickCount Lib "kernel32" () As Long
'   GUID
    Private Declare Function CoCreateGuid Lib "ole32.dll" (guid As GUID_TYPE) As LongPtr
    Private Declare Function StringFromGUID2 Lib "ole32.dll" (guid As GUID_TYPE, ByVal lpStrGuid As LongPtr, ByVal cbMax As Long) As LongPtr
#End If


'   Template

'   Use this to create new functions.  The basic idea is everything that
'   isn't tied to a windows event should be a function.  Functions can
'   be called like Subroutines but can also be checked for Success or
'   Failure return codes if needed.

'   1) Replace every instance of "Template" to your routine's name
'   2) Change "As Boolean" if your function returns something other than
'      True/False or Success/Failure
'   3) Change the Application.MacroOptions Category to:
'      13 - User Defined - to make this visible to the user
'      11 - Customizing - to make this less visible to the user
'   4) Execute the Application.MacroOptions in the Immediate Window
'   5) Where desired: Application.MacroOptions _
'                       Macro:="Template", _
'                       Category:=13 (visible)/11 (hidden), _
'                       Description:=<copy the description here>


Private Function Template(ByVal sMyParameter As String) As Boolean

'   Description:Description of Routine
'   Inputs:     Variable    Description
'               Variable    Description
'   Outputs:    Me          Success/Failure
'   Requisites: Table:      Worksheet.TableName
'               Function:   Module.FunctionName
'               Form:       UserFormName
'   Example:    ?Template()

'     Date   Ini Modification
'   01/01/01 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Template"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Template = Failure

'   Check Inputs and Requisites

'   Initialize variables

'   Procedure
    
    Template = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = LogError: Debug.Print cRoutine & ":" & _
                            Err.Number & "-" & Err.Description
        Case Is = RtnError: Template = cRoutine & ":" & _
                            Err.Number & "-" & Err.Description
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
'   Cleanup

End Function



'Error Handling

Public Function DspErrMsg(ByVal cRoutineName As String, _
                 Optional ByVal sAddText As String = "")

'   Description:Display an unanticipated error message
'   Inputs:     RoutineName     Function or Subroutine's name
'               AddText         Additional Text
'   Outputs:    *None
'   Requisites: *None
'   Note!       This cannot have an error handler
'   Example:    Select Case DspErrMsg(cModule & "." & cRoutine)
'                   Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
'                   Case Is = vbRetry:  Resume          'Try again
'                   Case Is = vbIgnore:                 'End routine
'               End Select

'     Date   Ini Modification
'   11/08/11 CWH Initial Development
'   11/17/11 CWH Made it always in debugmode if I'm the user
'   02/16/12 CWH Removed "Help" button for err.number 999
'   04/18/12 CWH Add AddText
'   10/16/17 CWH Changed from CONST AprvdSavers to name Savers

'   Declarations
    Const DebugMode     As Boolean = False  'True forces routines to stop on error
    Dim sHelpFile       As String
    Dim lHelpContext    As Long
    Dim sSavers         As String       'Approved Savers

'   Initialize variables
    If IsError([Savers]) Then _
        sSavers = Environ("UserName") Else _
            sSavers = [Savers]
    If sSavers = vbNullString Then sSavers = Environ("UserName")

'   Procedure
    sHelpFile = Err.HelpFile
    lHelpContext = Err.HelpContext
    DspErrMsg = MsgBox( _
        "Error#" & Err.Number & vbLf & Err.Description & vbLf & sAddText, _
        IIf(DebugMode Or InStr(1, sSavers, Environ("UserName"), vbTextCompare) > 0, _
            vbAbortRetryIgnore, vbCritical) + IIf(Err.Number = 999, 0, vbMsgBoxHelpButton), _
        cRoutineName, _
        sHelpFile, _
        lHelpContext)

End Function



'   Utilities

Public Function Pad(ByVal sString As String, _
                    ByVal iLen As Integer, _
           Optional ByVal bBefore = False) As String

'   Description:Pad a string with spaces
'   Inputs:     sString     String to pad
'               iLen        Resulting length of string
'               bBefore     TRUE-Pad Before, FALSE-Pad After
'   Outputs:    Pad         Success: Padded string
'                           Failure: Original string
'   Requisites: *None
'   Example:    ?Pad("1", 4)

'     Date   Ini Modification
'   12/16/11 CWH Initial Development
'   04/17/13 CWH Added bBefore

'   Declarations
    Const cRoutine      As String = "Pad"

'   Error Handling and Procedure Initialization
    On Error GoTo ErrHandler
    Pad = sString

'   Procedure
    If Len(sString) < iLen Then
        If bBefore Then
            Pad = Space(iLen - Len(sString)) & sString
        Else
             Pad = sString & Space(iLen - Len(sString))
       End If
    End If
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function Encrypt(ByVal sValue As String, _
                        ByVal sKey As String) As String

'   Description:Encrypt a value using a key
'   Inputs:     sValue      String to encrypt
'               sKey        Key to use for encryption
'   Outputs:    Me          Success: Encrypted String
'                           Failure: vbNullString
'   Requisites: *None
'   Example:    ?Encrypt("Hi There", "asd")

'     Date   Ini Modification
'   12/08/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Encrypt"
    Const cEncrypt      As String = " 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    Dim sEncrypt        As String
    Dim xKey()          As Byte         'sKey Array
    Dim lValue          As Long         'Value counter
    Dim lKey            As Long         'Key counter
    Dim lTemp           As Long

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Encrypt = vbNullString

'   Check Inputs and Requisites
    If Not RegEx(sValue, "^[a-zA-Z0-9 ]+$", rxTest) Then _
        Err.Raise DspError, , "Value must contain letters, numbers and spaces only"
    If Not RegEx(sKey, "^[0-9]+$", rxTest) Then _
        Err.Raise DspError, , "Key must be numbers only"

'   Initialize variables
    sEncrypt = cEncrypt & cEncrypt
    xKey = StrConv(sKey, vbFromUnicode)

'   Procedure
    For lValue = 1 To Len(sValue)
        lKey = (lKey + 1) Mod (UBound(xKey) + 1)
        lTemp = InStr(1, sEncrypt, Mid(sValue, lValue, 1))
        lTemp = lTemp + xKey(lKey)
        lTemp = lTemp Mod Len(sEncrypt)
        Encrypt = Encrypt & Mid(sEncrypt, lTemp + 1, 1)
    Next

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function Decrypt(ByVal sValue As String, _
                        ByVal sKey As String) As String

'   Description:Decrypt a value using a key
'   Inputs:     sValue      String to Decrypt
'               sKey        Key to used for encryption
'   Outputs:    Me          Success: Decrypted String
'                           Failure: vbNullString
'   Requisites: *None
'   Example:    ?Decrypt("N`NZ_Yx\", "asd")

'     Date   Ini Modification
'   12/08/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Decrypt"
    Const cEncrypt      As String = " 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    Dim sEncrypt        As String
    Dim xKey()          As Byte         'sKey Array
    Dim lValue          As Long         'Value counter
    Dim lKey            As Long         'Key counter
    Dim lTemp           As Long

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Decrypt = vbNullString

'   Check Inputs and Requisites
    If Not RegEx(sValue, "^[a-zA-Z0-9 ]+$", rxTest) Then _
        Err.Raise DspError, , "Value must contain letters, numbers and spaces only"
    If Not RegEx(sKey, "^[0-9]+$", rxTest) Then _
        Err.Raise DspError, , "Key must be numbers only"

'   Initialize variables
    sEncrypt = cEncrypt & cEncrypt
    xKey = StrConv(sKey, vbFromUnicode)
    lKey = 0

'   Procedure
    For lValue = 1 To Len(sValue)
        lKey = (lKey + 1) Mod (UBound(xKey) + 1)
        lTemp = InStr(1, sEncrypt, Mid(sValue, lValue, 1))
        lTemp = Len(sEncrypt) \ 2 + lTemp - xKey(lKey)
        lTemp = lTemp Mod Len(sEncrypt)
        Decrypt = Decrypt & Mid(sEncrypt, lTemp - 1, 1)
    Next

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function Protection(ByVal lRequest As prRequest, _
                           ByVal oObject As Object) As Boolean

'   Description:Disable/Restore Protection
'   Inputs:     lRequest        Request type (Unprotect/Restore)
'               oObject         Workbook or Worksheet
'   Outputs:    Me              Success/Failure
'   Requisites:
'   Example:

'     Date   Ini Modification
'   02/08/18 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Protection"
    Dim oWkb            As Workbook
    Dim oWks            As Worksheet
    Dim oName           As Name             'Name Object
    Dim sName           As String           'Name
    Dim sPwd            As String           'Password
    Dim vResult         As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Protection = Failure
    
'   Check Inputs and Requisites
    Select Case TypeName(oObject)
        Case Is = "Workbook":  Set oWkb = oObject
        Case Is = "Worksheet": Set oWks = oObject: Set oWkb = oWks.Parent
    End Select
       
'   Procedure
'   Workbook
    If TypeName(oObject) = "Workbook" Then
        If oWkb.ProtectStructure Or oWkb.ProtectWindows Or lRequest = prRestore Then
            sPwd = vbNullString: sName = "PWDWorkbook"
            If Exists(oWkb.Names, sName, oName) Then sPwd = Evaluate(sName)
            If lRequest = prUnprotect Then _
                oWkb.Unprotect sPwd Else _
                    If Not oName Is Nothing Then oWkb.Protect sPwd
        End If
    End If
    
    If oWks Is Nothing Then
    '   All Worksheets
        For Each oWks In oWkb.Worksheets
            If oWks.ProtectContents Or lRequest = prRestore Then
                sPwd = vbNullString: sName = "PWD" & oWks.Name
                If Exists(oWkb.Names, sName, oName) Then sPwd = Evaluate(sName)
                If lRequest = prUnprotect Then _
                    oWks.Unprotect sPwd Else _
                        If Not oName Is Nothing Then oWks.Protect sPwd
            End If
        Next
    Else
    '   Just one worksheet
        If oWks.ProtectContents Or lRequest = prRestore Then
            sPwd = vbNullString: sName = "PWD" & oWks.Name
            If Exists(oWkb.Names, sName, oName) Then sPwd = Evaluate(sName)
            If lRequest = prUnprotect Then _
                oWks.Unprotect sPwd Else _
                    If Not oName Is Nothing Then oWks.Protect sPwd
        End If
    End If
        
    Protection = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:
            vResult = InputBox("Enter password for " & Replace(sName, "PWD", ""), "Password")
            If vResult <> vbNullString Then
                If Exists(oWkb.Names, sName, oName) Then _
                    oName.RefersTo = vResult Else _
                        oWkb.Names.Add sName, vResult, False
                sPwd = Evaluate(sName): Resume
            End If
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Private Sub Unhide()

'   Description:Unhide worksheets for development
'   Inputs:     *None
'   Outputs:    *None
'   Requisits:  *None
'   Example:    Unhide

'     Date   Ini Modification
'   07/08/11 CWH Initial Development
'   03/23/12 CWH Added Chart Sheets
'   11/12/12 CWH Part of 11/12/12 Versioning

'   Declarations
    Const cRoutine      As String = "Unhide"
    Dim o               As Object
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
    For Each o In Sheets: o.Visible = xlSheetVisible: Next
    For Each o In Charts: o.Visible = xlSheetVisible: Next
       
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub


Public Function ColorCode2RGB(ByVal lColorCode As Long, _
                              ByRef iRed As Integer, _
                              ByRef iGreen As Integer, _
                              ByRef iBlue As Integer) As Boolean

'   Description:Converts Color Code to RGB values
'   Inputs:     lColorCode  Color Code as a Long variable
'   Outputs:    iRed        Red value
'               iGreen      Green value
'               iBlue       Blue value
'               Me          Success/Failure
'   Requisites: *None
'   Example:    ColorCode2RGB(Style.Color, iRed, iGreen, iBlue)

'     Date   Ini Modification
'   01/16/96 UNK  Return the individual colors for lColorCode
'   07/15/96 UNK  Use Tip 171: Determining RGB Color Values, MSDN July 1996.
'   01/01/01 CWH Conformed to standard template to add error handling
    

'   Declarations
    Const cRoutine      As String = "ColorCode2RGB"
    Dim lColor          As Long
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    ColorCode2RGB = Failure     'Assume the worst
    
 '  Procedure
    lColor = lColorCode
    iRed = lColor Mod &H100     'Get red component
    lColor = lColor \ &H100     'Remove red component
    iGreen = lColor Mod &H100   'Get green component
    lColor = lColor \ &H100     'Remove green component
    iBlue = lColor Mod &H100    'Get blue component
    ColorCode2RGB = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


'   Color Server

Function Color(ByVal ColorType As crRequestTypes, _
      Optional ByVal oWorkbook As Workbook = Nothing) As Variant

'   Description:Get a Color from Skin Table or Pallet
'   Inputs:     ColorType   Color Request Type
'   Outputs:    Me          Success:Color or Picture
'                           Failure:Null
'   Requisites: Table:      Skin (optional)
'               Routines:   me.Exists
'               Routines:   me.Tables
'   Example:    Selection.Interior.Color = Color(crAccent)

'     Date   Ini Modification
'   07/08/13 CWH Initial Development
'   06/03/14 CWH Added *DefaultTableStyle,*DefaultPivotTableStyle
'   09/04/14 CWH Better handling of Picture pathing
'   10/06/14 CWH Added oWorkbook Parameter
'   06/25/15 CWH Accomodated running Excel from illegal directory (ex. web)
'   12/16/15 CWH Changed how oWorkbook is determined when not sent
'   01/28/16 CWH Added ChartStyle and SlicerStyle
'   04/29/17 CWH Fixed problem when Skin.jpg is not found
'   06/30/17 CWH Accomodated old Skin tables

'   Declarations
    Const cRoutine      As String = "Color"
    Static dicColors    As Object       'Color Dictionary
    Dim oLo             As ListObject   'Current ListObject
    Dim oLR             As ListRow      'Current ListRow
    Dim sKey            As String       'Dictionary's Key
    Dim sTyp            As String       'Color Source Type
    Dim sVal            As String       'Color Source Value
    Dim v               As Variant      'Generic Result
    Const sDefaults     As String = _
        "Logo,                  T,Logo.gif; " & _
        "Skin,                  P,Skin.jpg; " & _
        "Form,                  S,20;       " & _
        "Frame,                 S,20;       " & _
        "Button,                S,21;       " & _
        "Button Glow,           S,19;       " & _
        "Dark,                  C,1,2;      " & _
        "Light,                 C,2,1;      " & _
        "Accent Dark,           S,19;       " & _
        "Accent,                S,20;       " & _
        "Accent Light,          S,21;       " & _
        "TableStyle,            T,*DefaultTableStyle;" & _
        "PivotTable Style,      T,*DefaultPivotTableStyle;" & _
        "SlicerStyle,           T,*DefaultSlicerStyle;" & _
        "Background,            T,BackGround.jpg;" & _
        "ChartStyle,            T,201;" & _
        "ChartColor,            T,2;" & _
        "ChartArea,             T,ChartArea;" & _
        "PlotArea,              T,PlotArea; " & _
        "Chart Title Location,  T,Above;    " & _
        "Chart Legend Location, T,Right     "
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Color = Null
    
'   Check inputs and requisites
    If oWorkbook Is Nothing Then _
        If Exists(Tables(ThisWorkbook), "Skin") Then _
            Set oWorkbook = ThisWorkbook Else _
                Set oWorkbook = ActiveWorkbook

'   Initialize variables
    If ColorType = crReset Then Set dicColors = Nothing
    If dicColors Is Nothing Then
        Set dicColors = CreateObject("Scripting.Dictionary")
        With oWorkbook
            For Each v In Split(sDefaults, ";")
                sKey = Trim(Split(v, ",")(0))
                sTyp = Trim(Split(v, ",")(1))
                sVal = Trim(Split(v, ",")(2))
                Select Case sVal
                    Case Is = "*DefaultTableStyle": sVal = .DefaultTableStyle
                    Case Is = "*DefaultPivotTableStyle": sVal = .DefaultPivotTableStyle
                    Case Is = "*DefaultSlicerStyle": sVal = .DefaultSlicerStyle
                End Select
                Select Case sTyp
                    Case Is = "P"   'Picture
                        Set dicColors(sKey) = Nothing
                        If Not sVal Like "[A-Z]:*" And Not sVal Like "\\*" Then _
                            sVal = .Path & "\" & sVal
                        If Dir(sVal) <> vbNullString Then _
                            Set dicColors(sKey) = LoadPicture(sVal)
                    Case Is = "S"   'Style
                        dicColors(sKey) = .Styles(CLng(sVal)).Interior.Color
                        dicColors(sKey & ",Font") = .Styles(CLng(sVal)).Font.Color
                    Case Is = "C"   'Color
                        dicColors(sKey) = .Colors(CLng(sVal))
                        sVal = Split(v, ",")(3)
                        dicColors(sKey & ",Font") = .Colors(CLng(sVal))
                    Case Is = "T"   'Text/Value
                        dicColors(sKey) = sVal
                End Select
            Next
            If Exists(Tables(oWorkbook), "Skin", oLo) Then
                For Each oLR In oLo.ListRows
                    With oLR.Range(2)
                        sKey = oLR.Range(1)
                        sVal = Trim(.Text)
                        dicColors(sKey) = sVal
                        Select Case sKey
                            Case Is = "TableStyle":       oWorkbook.DefaultTableStyle = sVal
                            Case Is = "PivotTable Style": oWorkbook.DefaultPivotTableStyle = sVal
                            Case Is = "SlicerStyle":      oWorkbook.DefaultSlicerStyle = sVal
                            Case Else
                                Set v = GetFLD(oLR, "Number")
                                If Not v Is Nothing Then If v.Value = vbNullString Then Set v = Nothing
                                If sVal Like "*.*" And v Is Nothing Then
                                    If Not sVal Like "[A-Z]:*" And Not sVal Like "\\*" Then _
                                        sVal = oWorkbook.Path & "\" & sVal
                                    If Dir(sVal) <> vbNullString Then _
                                        Set dicColors(sKey) = LoadPicture(sVal) Else _
                                            dicColors(sKey) = .Interior.Color
                                Else
                                    dicColors(sKey) = .Interior.Color
                                End If
                                dicColors(sKey & ",Font") = .Font.Color
                        End Select
                    End With
                Next
            End If
        End With
    End If
    
'   Procedure
    If ColorType <> crReset Then
        If IsObject(dicColors.ITems()(ColorType - 1)) Then _
            Set Color = dicColors.ITems()(ColorType - 1) Else _
                Color = dicColors.ITems()(ColorType - 1)
    End If
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 52, 75:   Resume Next             'Illegal directory
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


'   Class Server

Private Function ClassServer(ByVal csRequest As csRequestType, _
                    Optional ByVal sName As String, _
                    Optional ByRef oClass As Object) As Boolean

'   Description:Performs various requests on the class container dictionary.
'               Classes placed in ClassServer will persist as long as the
'               workbook remains open, or until removed from ClassServer.
'               While this was specifically designed to contain classes,
'               this can hold anything.
'   Inputs:     csRequest   Sav,Get,Remove, or Clear
'               sName       Name class instance was saved as
'               oClass      Class instance
'   Outputs:    Me          Success/Failure
'               oClass      Class instance
'   Requisites: *None
'   Notes:      This routine serves UI routines: GetCls, SavCls, RmvCls, and ClrCls
'               It provides all error handling for the UIs
'               It provides one place to manage classes and eliminates the need
'               for a global variable
'               Class names should be fully qualified (include workbook name)
'   Example:    ?SavCls(ThisWorkbook.Name & ":clsWorkbook", oClass)

'     Date   Ini Modification
'   07/07/14 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "ClassServer"
    Static oDic         As Object       'Data Dictionary used as Class container
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    ClassServer = Failure

'   Initialize variables
    If oDic Is Nothing Then Set oDic = CreateObject("Scripting.Dictionary")

'   Procedure
    Select Case csRequest
        Case Is = csSav: Set oDic(sName) = oClass
        Case Is = csGet: If oDic.Exists(sName) Then Set oClass = oDic(sName)
        Case Is = csRmv: If oDic.Exists(sName) Then oDic.Remove sName
        Case Is = csClr: oDic.RemoveAll
        Case Is = csLst: For Each v In oDic.Keys(): Debug.Print v: Next
    End Select
    ClassServer = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function SavCls(ByVal sSaveAs As String, _
                       ByVal oClass As Object) As Boolean
    SavCls = ClassServer(csSav, sSaveAs, oClass)
End Function

Public Function GetCls(ByVal sSavedAs As String) As Object
    ClassServer csGet, sSavedAs, GetCls
End Function

Public Function RmvCls(ByVal sSavedAs As String) As Boolean
    RmvCls = ClassServer(csRmv, sSavedAs)
End Function

Public Function ClrCls() As Boolean
    ClrCls = ClassServer(csClr)
End Function

Public Function LstCls() As Boolean
    LstCls = ClassServer(csLst)
End Function


'   Connection Server
Public Function GetCN(ByVal sID As String, _
             Optional ByVal bClose As Boolean = False, _
             Optional ByVal oWorkbook As Workbook) As Object

'   Description:Connection Server (See Examples)
'   Inputs:     sID             Connections table ID entry
'                               "*" closes all connections
'               bClose          If TRUE, close connection
'               oWorkbook       Workbook containing tblCST
'   Outputs:    Me              Success: Connection Object
'                               Failure: Nothing
'   Requisites: Tables:         AppCodes.Connections
'               Routines:       me.FileOpen
'                               me.RegEx
'                               me.GetCST
'   Suggestion: Don't store passwords in connection strings.
'               Instead, prompt the user for their UID and PWD, then use
'               their authority to access tables instead of a global authority
'   Examples:   Get/create a single opened connection
'                           Set cn = GetCN("NorthWind")
'               Close a specific connections
'                           GetCN "XL", True
'               Close all connections
'                           GetCN "*"

'     Date   Ini Modification
'   08/14/11 CWH Original Development
'   01/24/18 CWH Moved modGeneral.Get_Connection to here
'   05/17/18 CWH Used CST.Type to determine DBQ "\" requirement
    
'   Declarations
    Const cRoutine      As String = "GetCN"
    Static oCNO         As Object       'Connection Object Container
    Static oCNS         As Object       'Connection String Container
    Dim sType           As String       'Database Product (XL, ACCESS, DB2, ...)
    Dim sDBQ            As String       'Database Location (path/server/IP)
    Dim sDB             As String       'Database/Directory (DB2) Name
    Dim sCn             As String       'Connection String
    Dim oCn             As Object       'Connection Object
    Dim vResult         As Variant      'Generic Result
    Dim v               As Variant      'Generic Result
    Dim s               As String       'Generic String
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set GetCN = Nothing

'   Check Inputs and Requisites
    If oWorkbook Is Nothing Then Set oWorkbook = ThisWorkbook
    
'   Variable Initialization
    If oCNO Is Nothing Then Set oCNO = CreateObject("Scripting.Dictionary")
    If oCNS Is Nothing Then Set oCNS = CreateObject("Scripting.Dictionary")
    
'   Procedure
'   Get Connection if Exists in container/dictionary
    If oCNO.Exists(sID) Then Set oCn = oCNO(sID)
'   Create Connection String if needed
    If oCn Is Nothing And sID <> "*" Then
        With oWorkbook
            sCn = GetCST(sID, "Connection String", oWorkbook)
            sDBQ = GetCST(sID, "DBQ", oWorkbook)
            sDB = GetCST(sID, "DB", oWorkbook)
            sType = GetCST(sID, "Type", oWorkbook)
            If Trim(UCase(sDBQ)) = "*PATH" Then sDBQ = .Path
            If sDBQ <> vbNullString And _
               Right(sDBQ, 1) <> "\" And _
               Not IsIn(sType, "DB2,SQL") Then sDBQ = sDBQ & "\"
            If Trim(UCase(sDB)) = "*TYPE" Then _
                sDB = Split(.Name, ".") & sType
            If Trim(UCase(sDB)) = "*FILENAME" Then sDB = .Name
            If InStr(1, sDBQ, "?") > 0 Or InStr(1, sDB, "?") > 0 Then
                sDBQ = Replace(sDBQ, "?", ""): sDB = Replace(sDB, "?", "")
                v = FileOpen(sDefault:=sDBQ & "\" & sDB, _
                             sFilterText:=sID, _
                             sFilter:=sType, _
                             sTitle:="Select Database")
                If v = vbNullString Then Err.Raise LogError, , "User Cancelled"
                sDBQ = Left(v, InStrRev(v, "\"))
                sDB = Right(v, Len(v) - InStrRev(v, "\"))
            End If
        End With
        sCn = Replace(sCn, "<DBQ>", sDBQ)
        sCn = Replace(sCn, "<DB>", sDB)
        Set oCn = CreateObject("ADODB.Connection")
        oCNS(sID) = sCn
        Set oCNO(sID) = oCn
    End If
'   Close Connection(s)
    If bClose Or sID = "*" Then
        If sID = "*" Then
            For Each v In oCNO.ITems
                If v.State = 1 Then v.Close
            Next
        Else
            If oCn.State = 1 Then oCn.Close
        End If
'   Open Connection
    Else
        Set oCn = oCNO(sID)
        If oCn.State = 0 Then oCn.Open oCNS(sID)
    End If
'   Return Connection
    Set GetCN = oCn
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function GetCST(ByVal sID As String, _
                       ByVal sProperty As String, _
              Optional ByVal oWorkbook As Workbook = Nothing) As String
                     
'   Description:Get a property's value from tblCST
'   Inputs:     sID             Connection String Table ID
'               sProperty       Property to get
'               oWorkbook       Workbook containing tblCST
'   Outputs:    Me              Success:Property's value
'                               Failure:vbNullString
'   Requisites: Routines        modGeneral.Exists
'                               modGeneral.Tables
'               Table           tblCST
'   Example:    ?GetCST(ID:="BXL", Property:="Type")
                                
'     Date   Ini Modification
'   07/21/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetCST"
    Static oLo          As ListObject       'tblCST
    Dim vResult         As Variant          'Generic result
    
'   Error Handling and Initialization
    On Error GoTo ErrHandler
    GetCST = vbNullString
      
'   Check Inputs and Requisites
    If oWorkbook Is Nothing Then Set oWorkbook = ThisWorkbook
    If Not oLo Is Nothing Then _
        If oLo.Parent.Parent.Name <> oWorkbook.Name Then _
            Set oLo = Nothing
    If oLo Is Nothing Then _
        If Not Exists(Tables(oWorkbook), "tblCST", oLo) Then _
            Err.Raise DspError, , "tblCST not found in " & oWorkbook.Name

'   Procedure
    Set vResult = XLookup(oLo, sProperty, sID)
    If vResult Is Nothing Then _
        Err.Raise DspError, , sID & " not found in CST"
    GetCST = CStr(vResult)
        
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function FileOpen(Optional sDefault As String, _
                         Optional sFilterText As String, _
                         Optional sFilter As String, _
                         Optional sTitle As String = "Open File", _
                         Optional lType As MsoFileDialogType = msoFileDialogFilePicker) As String

'   Description:Display FileOpen Dialog
'   Inputs:     sDefault    Default file name or initial path
'               sFilterText Filter description (ex. "Databases")
'               sFilter     Extension filter (ex. "*mdb; *.accdb")
'               sTitle      Dialog Title (ex. "Select Database")
'   Outputs:    Me          Success: File name w/path
'                           Failure: ""
'   Requisites: *None
'   Notes:      msoFileDialogOpen = 1
'               Adapted from post by Kenneth Hobson on Aug 24th, 2011 in MrExcel's forum:
'               www.mrexcel.com/forum/excel-questions/574110-getopenfilename-default-directory.html
'               See also http://msdn.microsoft.com/en-us/library/office/aa432348(v=office.12).aspx
'   Example:    ?FileOpen
'               ?FileOpen(sDefault:=ThisWorkbook.Path & "\")
'               ?FileOpen(ThisWorkbook.Path & "\", "MS Access", _
'                         "*.mdb; *.accdb", "Select Database")
'               ?FileOpen(oCn.DefaultDatabase, sTitle:="Select Database")

'     Date   Ini Modification
'   01/19/13 CWH Initial Development (see Notes)
'   08/20/13 CWH Added documentation and Default changes
'   03/15/16 CWH Added lType in parameters

'   Declarations
    Const cRoutine      As String = "FileOpen"

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    With Application.FileDialog(lType)
        .ButtonName = "&Open"
        If (.InitialFileName = "" Or _
            .InitialFileName = "Network\") And _
            sDefault = "" Then sDefault = ThisWorkbook.Path
        .InitialFileName = sDefault
        .Filters.Clear
        If sFilter <> "" Then .Filters.Add sFilterText, sFilter, 1
        .Title = sTitle
        .AllowMultiSelect = False
        If .Show Then FileOpen = .SelectedItems(1)
    End With
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function




Public Function Get_Distinct(ByVal vList As Variant, _
                    Optional ByVal bIgnoreCase As Boolean = True, _
                    Optional ByVal bRemoveNull As Boolean = True) As Variant

'   Description:Get Distinct/Unique Values from a list
'   Inputs:     vList        List to deduplicate
'               bIgnoreCase  Ignore Case in Comparison flag
'               bRemoveNull  Remove null from the output
'   Outputs:    Get_Distinct If Success: A list with unique values
'                            If Failure: Null
'   Example:    ?Get_Distinct("1,2,3,4,4")(0)
'               ??Get_Distinct(Range("Form_Properties[Set ID]"))(0)
'               ?Get_Distinct(cRange("States"))

'     Date   Ini Modification
'   07/10/12 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Get_Distinct"
    Dim dDict           As Object
    Dim oArea           As Range
    Dim oCell           As Range
    Dim vArray          As Variant
    Dim v               As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Get_Distinct = Null        'Assume Failure
    
    Set dDict = CreateObject("Scripting.Dictionary")
    dDict.CompareMode = -bIgnoreCase
    
    Select Case TypeName(vList)
        Case Is = "String"
            If vList Like "%,%" Then
                vArray = Split(CStr(vList), ",")
            ElseIf Exists(Names, CStr(vList)) Then
                vArray = Range(CStr(vList))
            ElseIf Not IsError(Evaluate(vList)) Then
                vArray = Evaluate(vList)
            Else
                vArray = CStr(vList)
            End If
        Case Is = "ListObject", "ListColumn"
            vArray = vList.DataBodyRange
        Case Is = "ListRow": vArray = vList.Range
        Case Is = "Range":
            For Each oArea In vList.Areas
                For Each oCell In oArea.Cells
                    dDict(oCell.Value) = oCell.Value
                Next
            Next
        Case Else
            If IsArray(vList) Then vArray = vList
    End Select
    
    If IsArray(vArray) Then
        If Not IsEmpty(vArray) Then
            For Each v In vArray: dDict(v) = v: Next
        End If
    End If
    If bRemoveNull And dDict.Exists("") Then dDict.Remove ""
    
    Get_Distinct = dDict.Keys
        
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else: Debug.Print cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function Get_Segment(ByVal sText As String, _
                            ByVal lSegment As Long, _
                   Optional ByVal sDelimiter As String = ",") As String

'   Description:Extend SPLIT to Excel
'   Inputs:     sText       Text to split
'               lSegment    Segment to return from text
'               sDelimiter  Character dividing text segments
'   Outputs:    Get_Segment Success: Segment from string
'                           Failure: If segment numbers does not exist, an
'                                   empty string; otherwise, an error message
'   Example:    Result  Test
'               1       ?Get_Segment("1,2,3,4", 1, ",")
'               2       ?Get_Segment("1,2,3,4", 2, ",")
'               4       ?Get_Segment("1,2,3,4", 4, ",")
'               A       ?Get_Segment("""A"",""B"",""D""", 1, """,""")
'               B       ?Get_Segment("""A"",""B"",""D""", 2, """,""")
'               D       ?Get_Segment("""A"",""B"",""D""", 3, """,""")
'               ""      ?Get_Segment("""A"",""B"",""D""", 4, """,""")

'     Date   Ini Modification
'   10/01/11 CWH Initial Development
'   10/13/11 CWH Added clean up ends for first or last segment
'   11/21/11 CWH Added test scripts

'   Declarations
    Const cRoutine      As String = "Get_Segment"
    Dim lDlmLen         As Long     'Delimiter Length

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Get_Segment = ""        'Assume Failure
    
'   Procedure
    lDlmLen = Len(sDelimiter) / 2   '>0 means delimiter like quoted values
    If lDlmLen > 0 Then sText = Mid(sText, lDlmLen, Len(sText) - lDlmLen)
    Get_Segment = Split(sText, sDelimiter)(lSegment - 1)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9: Get_Segment = ""   'Subscript out of range
        Case Else: Get_Segment = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function Get_Special(ByVal oRange As Range, _
                            ByVal lType As XlCellType, _
                   Optional ByVal vValue As Variant) As Range

'   Description:Get Special Cells and handle 1004 errors
'   Inputs:     oRange      Range to get special cells from
'               lType       Type of specials cells to get
'               vValue      See: https://msdn.microsoft.com/en-us/library/office/ff196157.aspx
'   Outputs:    Me          Success: Range
'                           Failure: Nothing
'   Example:    ?Get_Special(ActiveSheet.UsedRange, xlCellTypeConstants) is Nothing

'     Date   Ini Modification
'   09/24/16 CWH Initial Development
'   04/05/17 CWH Added vValue

'   Declarations
    Const cRoutine      As String = "Get_Special"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set Get_Special = Nothing       'Assume Failure
    
'   Procedure
    If IsMissing(vValue) Then _
        Set Get_Special = oRange.SpecialCells(lType) Else _
            Set Get_Special = oRange.SpecialCells(lType, vValue)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:                             'Nothing Found, Do nothing.
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Public Function CstLst(ByVal sString As String) As Long

'   Description:Get Custom List Number
'   Inputs:     sString     Enough comma delimited entries to determine list number
'   Outputs:    Me          Success: Custom List #
'                           Failure: 0
'   Example:    ?CstLst("Fri,")

'     Date   Ini Modification
'   01/24/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "CstLst"
    Dim s               As String
    Dim n               As Long

'   Error Handling Initialization
    On Error GoTo ErrHandler
    CstLst = 0          'Assume Failure
    
'   Procedure
    For n = 1 To Application.CustomListCount
        s = Collection2CSV(Application.GetCustomListContents(n))
        If s Like sString & "*" Then CstLst = n: Exit For
    Next n

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function RegEx(ByVal sString As String, _
                      ByVal sPattern As String, _
             Optional ByVal lOperation As rxRequestType = rxTest, _
             Optional ByVal sReplace As String = vbNullString, _
             Optional ByVal bIgnoreCase As Boolean = True, _
             Optional ByVal bGlobal As Boolean = True) As Variant

'   Description:Find first occurance of any of several items
'   Inputs:     sString         String to search
'               sPattern        Regular Expression to apply
'               lOperation      RegEx Method to apply: Test, Replace, Execute
'               sReplace        When lOperation = rxReplace, this replaces any matches
'               bIgnoreCase     Case sensitivity
'               bGlobal         Apply to all instances within string
'   Outputs:    Me              rxTest:     TRUE/FALSE (Match/Did not match)
'                               rxReplace:  Resulting String
'                               rxExecute:  Matches Collection object
'   Requisites: *None
'   Notes:      Tester: http://regexr.com/
'               Object Model: https://msdn.microsoft.com/en-us/library/30wbz966(v=vs.110).aspx
'               VBScript: https://msdn.microsoft.com/en-us/library/ms974570.aspx
'   Example:    Get all words in a string, display 1st:
'                   ?RegEx("Mark  J  Wenner", "(\w+)\b", rxExecute)(0)

'     Date   Ini Modification
'   12/01/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "RegEx"
    Static oRegEx       As Object       'Regular Expression Object
    Dim n               As Long         'Starting Position
    Dim v               As Variant      'Elements in vOfThese

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Initialize Variables
    If oRegEx Is Nothing Then Set oRegEx = CreateObject("vbscript.regexp")
    oRegEx.Pattern = sPattern
    oRegEx.IgnoreCase = bIgnoreCase
    oRegEx.Global = bGlobal

'   Procedure
    Select Case lOperation
        Case Is = rxTest:    RegEx = oRegEx.Test(sString)
        Case Is = rxReplace: RegEx = Failure: RegEx = oRegEx.Replace(sString, sReplace)
        Case Is = rxExecute: Set RegEx = Nothing: Set RegEx = oRegEx.Execute(sString)
        Case Else: Err.Raise DspError, , "Unrecognize operation"
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 5018, 5020, 5021
            Select Case DspErrMsg(cModule & "." & cRoutine, "Invalid pattern:" & sPattern)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function InStrAny(ByVal sString As String, _
                         ParamArray vOfThese() As Variant) As Long

'   Description:Find first occurance of any of several items
'   Inputs:     sString         String to search
'               vOfThese        Items to search for in sString
'   Outputs:    Me              Success: First starting position of anything found
'                               Failure: 0
'   Requisites: *None
'   Example:    ?InStrAny(s, " ", vbCr, vbLf, vbTab)

'     Date   Ini Modification
'   04/01/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "InStrAny"
    Dim n               As Long         'Starting Position
    Dim v               As Variant      'Elements in vOfThese

'   Error Handling Initialization
    On Error GoTo ErrHandler
    InStrAny = 0

'   Procedure
    If sString <> "" And _
       Not IsMissing(vOfThese) Then
        For Each v In vOfThese()
            n = InStr(1, sString, CStr(v))
            If n > 0 Then _
                If InStrAny = 0 Then _
                    InStrAny = n Else _
                        If n < InStrAny Then InStrAny = n
        Next
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else: InStrAny = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function ReplaceAny(ByVal sString As String, _
                           ByVal sSubstituteThis As String, _
                      ParamArray vForThese() As Variant) As String

'   Description:Replace any items found in a string with sSubstituteThis
'   Inputs:     sString         String to be manipulated
'               sSubstituteThis Character of string to replace anything found
'               vForThese       Items to search for in sString
'   Outputs:    ReplaceAny      Success: String with replacements
'                               Failure: Original string
'   Requisites: *None
'   Example:    ?ReplaceAny(s, " ", vbCr, vbLf, vbTab)

'     Date   Ini Modification
'   03/22/12 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "ReplaceAny"
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    ReplaceAny = sString

'   Procedure
    If sString <> "" And _
       sSubstituteThis <> "" And _
       Not IsMissing(vForThese) Then
        For Each v In vForThese()
            ReplaceAny = Replace(sString, CStr(v), sSubstituteThis)
        Next
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else: ReplaceAny = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function User(Optional bWindows As Boolean = False) As String
    
'   Description:Return the user ID for MS Office or Windows Login

'   Parameters: bWindows - if TRUE then returns Windows Login ID
'   Example:    <this example is a cell formula>  =User(True)

'     Date   Ini Modification
'   01/01/01 CWH Initial Development
'   11/27/10 CWH Code Simplification

'   Declarations
    Const cRoutine      As String = "User"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    User = ""               'Assume no user
    
'   Procedure
    If bWindows Then _
        User = Trim(Environ("UserName")) Else _
            User = Trim(Application.UserName)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:      User = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function Workbook_Path(Optional ByVal bFull As Boolean = False, _
                              Optional ByVal oWorkbook As Workbook) As String

'   Description:Get Path of current Workbook
'   Inputs:     bFull       Full Path Flag
'   Outputs:    Me          Success: Workbook Path
'                           Failure: vbNullString
'   Requisites: *None
'   Example:    =Workbook_Path()

'     Date   Ini Modification
'   05/06/11 CWH Initial Development
'   12/08/11 CWH Added Full Option

'   Declarations
    Const cRoutine      As String = "Workbook_Path"
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Workbook_Path = vbNullString
    
'   Check Inputs and requisites
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    
'   Procedure
    Workbook_Path = IIf(bFull, oWorkbook.FullName, oWorkbook.Path)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:      Workbook_Path = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function Julian2Date(ByVal vYYYYDDD As Variant) As Variant

'   Description:Convert YYYYDDD to date data type
'   Inputs:     sYYYYDDD    Ordinal date string
'   Outputs:    Me          Success: Date
'                           Failure: 0
'   Requisites: *None
'   Example:    dPosted = Julian2Date("2009002")

'     Date   Ini Modification
'   01/01/01 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Julian2Date"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Julian2Date = "#DATE!"

'   Procedure
    Julian2Date = DateValue("01/01/" & _
                    Val(Left(CStr(vYYYYDDD), 4))) + _
                    Val(Right(Trim(CStr(vYYYYDDD)), 3)) - 1
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:                                  'Return "#DATE!"
    End Select

End Function


Public Function Date2Julian(ByVal vDate As Variant) As Variant
    
'   Date2Julian:Convert MM/DD/YYYY to YYYYDDD
'   Inputs:     vDate       Something representing a data
'   Outputs:    Me          Success: Ordinal Date
'                           Failure: 0
'   Requisites: *None
'   Example:    ?Date2Julian(now())

'     Date   Ini Modification
'   01/01/01 CWH Initial Development
'   11/15/11 CWH Handled date serial possibility
'   06/04/13 CWH Expanded format to "mm/dd/yyyy"

'   Declarations
    Const cRoutine      As String = "Date2Julian"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Date2Julian = "#DATE!"
    
'   If sDate is a date serial number, convert to a string
    If IsNumeric(vDate) Then vDate = Format(Val(vDate), "mm/dd/yyyy")
    If IsDate(vDate) Then
        vDate = DateValue(vDate)
        If Int(vDate) = 0 Then
            Date2Julian = 0
        Else
            Date2Julian = Year(vDate) & _
                Format(vDate - DateValue("01/01/" & Year(vDate)) + 1, "000")
        End If
    End If
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:                                  'Return "#DATE!"
    End Select

End Function


Public Function Date2IBM(ByVal vDate As Variant) As String
    
'   Date2IBM:   Convert MM/DD/YYYY to CYYMMDD
'   Inputs:     vDate       Something representing a data
'   Outputs:    Me          Success: IBM Date
'                           Failure: 0
'   Requisites: *None
'   Examples:   ?Date2IBM(now())

'     Date   Ini Modification
'   01/17/12 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Date2IBM"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Date2IBM = "#DATE!"

'   Check Inputs
    If IsNumeric(vDate) Then vDate = Format(Val(vDate), "mm/dd/yy")
    If Not IsDate(vDate) Then Err.Raise DspError, , "Date2IBM requires a date"

'   Procedure
    Date2IBM = IIf(Year(vDate) >= 2000, 1, 0) & Right(Year(vDate), 2) & _
                Format(Month(vDate), "00") & Format(Day(vDate), "00")

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:                                  'Return "#DATE!"
    End Select

End Function



'   "Is" functions

Public Function IsArrayAllocated(vArray As Variant) As Boolean

'   Description:Determine if an array has been allocated
'   Inputs:     vArray      Array to test
'   Outputs:    Me          True/False
'   Requisites: *None
'   Notes!      From http://www.cpearson.com/excel/isarrayallocated.aspx
'   Example:    ?IsArrayAllocated(vArray)

'     Date   Ini Modification
'   04/18/09 CP  Initial Programming

'   Declarations
    Const cRoutine      As String = "IsArrayAllocated"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsArrayAllocated = False
    
'   Procedure
    IsArrayAllocated = IsArray(vArray) And _
                       Not IsError(LBound(vArray, 1)) And _
                       LBound(vArray, 1) <= UBound(vArray, 1)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9:                                'Do nothing (Array not allocated)
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function IsDST(dDate As Date) As Boolean

'   Description:Is Date within Daylight Savings Time
'   Inputs:     dDate       Date to check
'   Outputs:    Me          TRUE/FALSE
'   Requisites: *None
'   Example:    ?IsDST(now())
'   Notes:      This works for USA standards.
'               Prior to 2007 Daylight Savings Time begins first Sunday
'               in April. Standard Time begins last Sunday in October.
'               2007 and later DayLight Savings Time begins second Sunday
'               in March. Standard Time begins first Sunday in November.

'     Date   Ini Modification
'   Unknown  CP  Initial Development by Chip Pearson from modLocalTimeAndGMT.bas
'   03/21/18 CWH BXL standards applied

'   Declarations
    Const cRoutine      As String = "IsDST"
    Const lMARCH        As Long = 3
    Const lAPRIL        As Long = 4
    Const lOCTOBER      As Long = 10
    Const lNOVEMBER     As Long = 11
    Dim dDstStart       As Date             'DST Start
    Dim dStdStart       As Date             'Non-DST Start (Standard time)
    Dim lYr             As Long             'Year
    Dim lDoW            As Long             'Day of Week #. 1 = Sunday

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsDST = False

'   Procedure
    If dDate > 0 Then
        lYr = Year(dDate)
        With WorksheetFunction
            If lYr < 2007 Then
            '   First Sunday in April
                dDstStart = .EoMonth(DateSerial(lYr, lAPRIL, 1), -1) + 1
                lDoW = .Weekday(dDstStart, vbSunday)
                dDstStart = dDstStart + (IIf(lDoW = vbSunday, 1, 8) - lDoW)
            '   Last Sunday in October
                dStdStart = .EoMonth(DateSerial(lYr, lOCTOBER, 1), 0)
                lDoW = .Weekday(dStdStart, 1)
                dStdStart = dStdStart - (IIf(lDoW = vbSunday, 1, 8) - lDoW)
            Else
            '   Second Sunday of March
                dDstStart = .EoMonth(DateSerial(lYr, lMARCH, 1), -1) + 1
                lDoW = .Weekday(dDstStart, vbSunday)
                dDstStart = dDstStart + (IIf(lDoW = vbSunday, 8, 15) - lDoW)
            '   First Sunday in November
                dStdStart = .EoMonth(DateSerial(lYr, lNOVEMBER, 1), -1) + 1
                lDoW = .Weekday(dStdStart, vbSunday)
                dStdStart = dStdStart + (IIf(lDoW = vbSunday, 1, 8) - lDoW)
            End If
        End With
        IsDST = (dDate >= dDstStart) And (dDate < dStdStart)
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function IsIn(ByVal Key As Variant, _
                ParamArray List() As Variant) As Boolean

'   Description:Determine if Key is in List
'   Inputs:     Key         Value to look for in list
'               List        List of values
'   Outputs:    Me          TRUE/FALSE
'   Requisites: *None
'   Example:    ?IsIn("Drink", "Beverage", "Drinks")
'               ?IsIn(2, Array(1,2,3))
'               ?IsIn(int(now()), int(now()), int(now())+1)

'     Date   Ini Modification
'   11/22/17 CWH Initial Development
'   01/09/18 CWH Switched to ParamArray
'   01/11/18 CWH Dumped FILTER in favor of MATCH

'   Declarations
    Const cRoutine      As String = "IsIn"
    Dim vArray          As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsIn = False

'   Check Inputs and Requisites
    Select Case UBound(List)
        Case Is = -1: Err.Raise DspError, , "List required"
        Case Is = 0:
            If IsArray(List(0)) Then _
                vArray = List(0) Else _
                    If TypeName(List(0)) = "String" Then _
                        vArray = Split(List(0), ",")
        Case Else:  vArray = List
    End Select
    
'   Procdedure
    IsIn = WorksheetFunction.Match(Key, vArray, 0) > 0

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004: Resume Next                 'No Match
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function

Public Function IsNumberFormat(ByVal sFormatString As String) As Boolean

'   Description:Determine if a number format is valid
'   Inputs:     vFormat     Format to be validated
'   Outputs:    Me          True/False
'   Requisites: *None
'   Example:    ?IsNumberFormat("@#$")

'     Date   Ini Modification
'   01/01/01 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "IsNumberFormat"
    Dim s               As String       'Temporary String

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsNumberFormat = False

'   Procedure
    s = ActiveCell.NumberFormat
    ActiveCell.NumberFormat = sFormatString
    IsNumberFormat = True

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004
            If Not Err.Description Like "*NumberFormat*" Then
                Select Case DspErrMsg(cModule & "." & cRoutine)
                    Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                    Case Is = vbRetry:  Resume          'Try again
                    Case Is = vbIgnore:                 'End routine
                End Select
            End If
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
'   Cleanup
    Err.Clear
    On Error GoTo 0
    ActiveCell.NumberFormat = s

End Function


Public Function IsProtected(ByVal oWks As Worksheet) As Boolean

'   Description:Determine if a worksheet is protected
'   Inputs:     oWks        Worksheet being examined
'   Outputs:    Me          True/False
'   Requisites: *None
'   Notes:      https://support.microsoft.com/en-us/kb/161245
'   Example:    ?IsProtected(ActiveSheet)

'     Date   Ini Modification
'   03/18/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "IsProtected"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsProtected = False

'   Procedure
    IsProtected = oWks.ProtectContents
    If Not IsProtected Then IsProtected = oWks.ProtectDrawingObjects
    If Not IsProtected Then IsProtected = oWks.ProtectScenarios

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function IsRangeEqual(ByVal oRange1 As Range, _
                             ByVal oRange2 As Range) As Boolean

'   Description:Determine if two ranges are identical
'   Inputs:     vRange1     Range to be compared to:
'               vRange2     The other range
'   Outputs:    Me          True/False
'   Example:    bResult = Range_Equal(Range("A4:B10"),Range("G4:H10"))

'     Date   Ini Modification
'   01/01/01 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "IsRangeEqual"
    Dim lRow            As Long
    Dim lCol            As Long
    Dim vArray1         As Variant
    Dim vArray2         As Variant
    Dim v               As Variant
    Dim bMatch          As Boolean

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsRangeEqual = False
    
'   Check Inputs and Requisites
    If oRange1 Is Nothing Then Err.RaiseDspError , , "Range1 required"
    If oRange2 Is Nothing Then Err.RaiseDspError , , "Range2 required"
       
'   Procedure
    vArray1 = oRange1
    vArray2 = oRange2
    bMatch = UBound(vArray1) = UBound(vArray2)
    If bMatch Then bMatch = UBound(vArray1, 2) = UBound(vArray2, 2)
    If bMatch Then
        For lRow = LBound(vArray1) To UBound(vArray1)
            For lCol = LBound(vArray1, 2) To UBound(vArray2)
                bMatch = vArray1(lRow, lCol) = vArray2(lRow, lCol)
                If Not bMatch Then Exit For
            Next
            If Not bMatch Then Exit For
        Next
    End If
    IsRangeEqual = bMatch
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function IsRangeEmpty(ByVal oRange As Range) As Boolean
    
'   Description:Unhide worksheets for development
'   Inputs:     oRange      Range to be compared
'   Outputs:    Me          True/False
'   Requisites: Routines    modGeneral.cRange
'   Example:    IsRangeEmpty([A1:C4])

'     Date   Ini Modification
'   07/08/11 CWH Initial Development
'   04/22/13 CWH Version 2013.04

'   Declarations
    Const cRoutine      As String = "IsRangeEmpty"
    Dim vArray          As Variant      'Range as an Array
    Dim lRow            As Long         'Array Row
    Dim lCol            As Long         'Array Column
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsRangeEmpty = True
    
'   Check Inputs and Requisites
    If oRange Is Nothing Then Err.Raise DspError, , "Range required"
    
'   Procedure
    vArray = oRange
    For lRow = LBound(vArray) To UBound(vArray)
        For lCol = LBound(vArray, 2) To UBound(vArray, 2)
            If vArray(lRow, lCol) <> vbNullString Then _
                IsRangeEmpty = False: Exit For
        Next
    Next
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function IsRangeDestroyed(ByRef oTarget As Range) As Boolean
    
'   Description:Determine if a range has been "deleted" out of existence
'   Inputs:     oTarget     Range to be checked
'   Outputs:    Me          True/False
'   Requisites: *None
'   Example:    ?IsRangeDestroyed([A1:C4])

'     Date   Ini Modification
'   01/19/11 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "IsRangeDestroyed"
    Dim s               As String

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsRangeDestroyed = True
    
'   Procedure
    s = oTarget.Address
    IsRangeDestroyed = s = ""

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 424:                              'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function IsListObjectDestroyed(ByVal oListObject As Object) As Boolean
    
'   Description:Determine if a ListObject has been "deleted" out of existence
'   Inputs:     ListObject  ListObject to be checked
'   Outputs:    Me          True/False
'   Requisites: *None
'   Example:    ?IsListObjectDestroyed([DET].ListObject)

'     Date   Ini Modification
'   02/21/15 CWH Initial Development
'   01/29/17 CWH Modified to work with any listobject object
    
'   Declarations
    Const cRoutine      As String = "IsListObjectDestroyed"
    Dim s               As String

'   Error Handling Initialization
    On Error GoTo ErrHandler
    IsListObjectDestroyed = True
    
'   Procedure
    s = oListObject.Range.Address
    IsListObjectDestroyed = s = ""

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004, 424, 91                     'Do nothing (Destroyed)
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


'   "Has" functions

Public Function HasName(ByVal oTarget As Range) As Boolean

'   Description:Determine if a range is named
'   Inputs:     oTarget     A single cell
'   Outputs:    me          TRUE/FALSE
'   Requisites: *None
'   Example:    ?HasValidation(Selection)

'     Date   Ini Modification
'   04/16/11 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "HasName"
    Dim v               As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    HasName = False

'   Procedure
    v = oTarget.Name
    HasName = True
        
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:                             'Ignore: No Name
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function HasValidation(ByVal oTarget As Range) As Boolean

'   Description:Determine if a cell has validation
'   Inputs:     oTarget     A single cell
'   Outputs:    me          TRUE/FALSE
'   Requisites: *None
'   Example:    ?HasValidation(Selection)

'     Date   Ini Modification
'   04/16/11 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "HasValidation"
    Dim v               As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    HasValidation = False

'   Procedure
    v = oTarget.Validation.Type
    HasValidation = True
        
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:                             'Ignore: No Validation
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function HasQueryTable(ByVal oTable As ListObject) As Boolean

'   Description:Determine if a table has a QueryTable
'   Inputs:     oTable          Table/ListObject to check for a QueryTable
'   Outputs:    HasQueryTable   True/False
'   Requisites: *None
'   Example:    ?HasQueryTable("DDT")

'     Date   Ini Modification
'   03/10/12 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "HasQueryTable"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    HasQueryTable = False

'   Procedure
    HasQueryTable = Not oTable.QueryTable Is Nothing

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:     'Ignore: object variable or With block variable not set
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function HasAutoFilter(ByVal oRange As Range) As Boolean

'   Description:Determine if a Range has Autofilter displayed
'   Inputs:     oTable          Table/ListObject to check for Autofilter
'   Outputs:    HasAutoFilter   True/False
'   Requisites: *None
'   Example:    ?HasAutoFilter(Selection)

'     Date   Ini Modification
'   01/22/18 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "HasAutoFilter"
    Dim oWks            As Worksheet
    Dim oFilter         As Filter

'   Error Handling Initialization
    On Error GoTo ErrHandler
    HasAutoFilter = False

'   Procedure
    Set oWks = oRange.Worksheet
    If Not Intersect(oRange, oWks.AutoFilter.Range) Is Nothing Then _
        HasAutoFilter = True

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 91, 424:                          'Ignore: object variable not set
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


'   "Exists" Functions with <Collections> Functions

Public Function Exists(ByVal vCollection As Variant, _
                       ByVal sName As String, _
              Optional ByRef vItem As Variant) As Boolean

'   Description:Determine if a name exists in a collection
'   Inputs:     vCollection Collection to check
'               sName       Collection Item's Name
'               vItem       Variable to hold collection instance
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Example:    ?Exists(Worksheets, "UsrCodes")
'               ?Exists(ActiveWorkbook.Names, "WBS", vItem)
'               ?Exists(ThisWorkbook.Styles, "Bad", vItem)
'               ?Exists(Workbooks(2).TableStyles, "TableStyleMedium14", vItem)
'               ?Exists(ActiveSheet.Shapes, "Button", vItem)
'               ?Exists(Array("Input", "Bad", "Good", "Neutral"), Selection.Style.Name)

'     Date   Ini Modification
'   06/25/01 CWH Initial Development
'   08/01/13 CWH Test for Blank Item
'   10/22/13 CWH Covered oCollection not set
'   12/04/15 CWH Now handles arrays
'   10/28/16 CWH Now handles Dictionaries
'   09/26/17 CWH Now handles SeriesCollection
'   02/08/18 CWH Make sure vItem doesn't return something on failure

'   Declarations
    Const cRoutine      As String = "Exists"
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Exists = False

'   Procedure
    Select Case TypeName(vCollection)
        Case Is = "String"
            vItem = vbNullString
            Exists = InStr(1, vCollection, sName) > 0
        Case Is = "Range"
            Set vItem = vCollection.Find(What:=sName, _
                                         LookIn:=xlValues, _
                                         LookAt:=xlWhole)
            If vItem Is Nothing Then Err.Raise 5
            Exists = True
        Case Is = "Variant()", "String()"
            vItem = vbNullString
            For Each v In vCollection
                If CStr(v) = sName Then
                    vItem = v
                    Exists = True
                    Exit For
                End If
            Next
        Case Is = "Dictionary"
            Set vItem = Nothing
            Exists = vCollection.Exists(sName)
            If Exists Then
                If IsObject(vCollection(sName)) Then _
                    Set vItem = vCollection(sName) Else _
                        vItem = vCollection(sName)
            End If
        Case Is = "SeriesCollection"
            Set vItem = Nothing
            For Each v In vCollection
                If v.Name = sName Then
                    Set vItem = v
                    Exists = True
                    Exit For
                End If
            Next
        Case Else
            If IsObject(vCollection) Then
                Set vItem = Nothing
                If IsObject(vCollection(sName)) Then
                    Set vItem = vCollection(sName)
                    Exists = True
                Else
                    vItem = vbNullString
                    vItem = vCollection(sName)
                    Exists = True
                End If
            End If
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 5, 9, 13, 91, 1004, 3265, -2147024809   'Do Nothing (not found)
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function Charts(Optional ByVal oWorkbook As Workbook = Nothing) As Collection

'   Description:Creates a collection of Charts
'   Inputs:     oWorkbook   Chart's Workbook
'   Outputs     me          Success: Charts Collection
'                           Failure: Nothing
'   Example:    ? Exists(Charts(ActiveWorkbook), "chtTest")

'     Date   Ini Modification
'   02/04/15 CWH Initial Development
'   10/18/16 CWH Accomodated Chart Sheets
    
'   Declarations
    Const cRoutine      As String = "Charts"
    Dim oCollection     As New Collection
    Dim oWks            As Object
    Dim Chart            As ChartObject

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set Charts = Nothing     'Assume not found
    
'   Procedure
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    For Each oWks In oWorkbook.Sheets
        If TypeName(oWks) = "Worksheet" Then
            For Each Chart In oWks.ChartObjects
                oCollection.Add Chart.Chart, Chart.Name
                oCollection.Add Chart.Chart, Chart.CodeName
            Next
        Else
            oCollection.Add oWks, oWks.Name
       End If
    Next
    Set Charts = oCollection
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 438: Resume Next                  'CodeName not supported
        Case Is = 457: Resume Next                  'Already Exists
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function Tables(Optional ByVal oWorkbook As Workbook = Nothing, _
                Optional ByVal bExcludeHidden As Boolean = False) As Collection

'   Description:Creates a collection of Tables
'   Inputs:     oWorkbook       Table's Workbook
'               bExcludeHidden  Exclude tables on hidden worksheets
'   Outputs     me              Success: Tables Collection
'                               Failure: Nothing
'   Example:    ? Exists(Tables(ActiveWorkbook), "Table1")

'     Date   Ini Modification
'   02/04/15 CWH Initial Development
'   01/23/16 CWH Changed Sheets to Worksheets
'   07/13/17 CWH Added bExcludeHidden parameter
    
'   Declarations
    Const cRoutine      As String = "Tables"
    Dim oCollection     As New Collection
    Dim oWks            As Worksheet
    Dim oLo             As ListObject

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set Tables = Nothing     'Assume not found
    
'   Procedure
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    For Each oWks In oWorkbook.Worksheets
        If Not bExcludeHidden Or oWks.Visible = xlSheetVisible Then
            For Each oLo In oWks.ListObjects
                oCollection.Add oLo, oLo.Name
            Next
        End If
    Next
    Set Tables = oCollection
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function OLEDBs(Optional bList As Boolean = False) As Object

'   Description:Creates a dictionary of OLE DBs
'   Inputs:     bList       If TRUE lists OLEDBs
'   Outputs     me          Success: OLE DB Providers Collection
'                           Failure: Nothing
'   Notes:      Based on Patrick R. O'Beirn's post https://sysmod.wordpress.com/2014/07/11/vbscript-to-list-installed-oledb-providers/
'   Examples:   ? Exists(OLEDBs, "Microsoft.ACE.OLEDB.12.0")
'               OLEDBs bList:=TRUE

'     Date   Ini Modification
'   10/28/16 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "OLEDBs"
    Const HKEY_CLASSES_ROOT As Long = &H80000000    'Registry Root
    Const sComputer         As String = "."         'This Computer
    Static oDic             As Object               'OLEDB Dictionary
    Dim oReg                As Object               'Registry
    Dim vKeys               As Variant              'Keys array
    Dim vKey                As Variant              'Single Key
    Dim sPath               As String               'Key's Registry Path
    Dim sName               As String               'Key's Value Name
    Dim sValue              As String               'String Value
    Dim dwValue             As Long                 'dWord Value

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set OLEDBs = Nothing     'Assume not found
    
'   Procedure
'   Create dictionary if needed
    If oDic Is Nothing Then
        Set oDic = CreateObject("Scripting.Dictionary")
    '   Connect to Registry
        Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & sComputer & "\root\default:StdRegProv")
    '   Get all CLSID keys
        oReg.enumKey HKEY_CLASSES_ROOT, "CLSID", vKeys
    '   Search CLSID Keys for OLDB providers
        For Each vKey In vKeys
            sPath = "CLSID\" & vKey
            sName = "OLEDB_SERVICES"
            If oReg.GetDWordValue(HKEY_CLASSES_ROOT, sPath, sName, dwValue) = 0 Then
                oReg.GetStringValue HKEY_CLASSES_ROOT, sPath, "", sValue
                oDic(sValue) = "HKEY_CLASSES_ROOT\" & sPath
            End If
        Next
    End If
        
'   List Providers if requested
    If bList Then
        For Each vKey In oDic.Keys()
            Debug.Print oDic(vKey), vKey
        Next
    End If
    
    Set OLEDBs = oDic

    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function PivotTables(Optional ByVal oWorkbook As Workbook = Nothing) As Object

'   Description:Creates a collection of PivotTables
'   Inputs:     oWorkbook   PivotTable's Workbook
'   Outputs     me          Success: PivotTables Collection
'                           Failure: Nothing
'   Example:    ?Filter(PivotTables(ActiveWorkbook), "pvtTest")(0)

'     Date   Ini Modification
'   02/04/15 CWH Initial Development
'   02/27/18 CWH Changed to Dictionary to enable filter
    
'   Declarations
    Const cRoutine      As String = "PivotTables"
    Dim oDic            As Object
    Dim oWks            As Worksheet
    Dim oPvt            As PivotTable

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set PivotTables = Nothing     'Assume not found
    
'   Procedure
    Set oDic = CreateObject("Scripting.Dictionary")
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    For Each oWks In oWorkbook.Sheets
        For Each oPvt In oWks.PivotTables
            Set oDic(oPvt.Parent.Name & "!" & oPvt.Name) = oPvt
        Next
    Next
    Set PivotTables = oDic
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function QueryTables(Optional ByVal oWorkbook As Workbook = Nothing) As Collection

'   Description:Creates a collection of QueryTables
'   Inputs:     oWorkbook   QueryTable's Workbook
'   Outputs     me          Success: QueryTables Collection
'                           Failure: Nothing
'   Example:    ? Exists(QueryTables(ActiveWorkbook), "Table1")

'     Date   Ini Modification
'   02/04/15 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "QueryTables"
    Dim oCollection     As New Collection
    Dim oWks            As Worksheet
    Dim oLo             As ListObject

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set QueryTables = Nothing     'Assume not found
    
'   Procedure
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    For Each oWks In oWorkbook.Sheets
        For Each oLo In oWks.ListObjects
            If HasQueryTable(oLo) Then oCollection.Add oLo, oLo.Name
        Next
    Next
    Set QueryTables = oCollection
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function Slicers(Optional ByVal oWorkbook As Workbook = Nothing) As Collection

'   Description:Creates a collection of Slicers
'   Inputs:     oWorkbook   Table's Workbook
'   Outputs     me          Success: Tables Collection
'                           Failure: Nothing
'   Example:    ?Exists(Slicers(ActiveWorkbook), "Revenue")

'     Date   Ini Modification
'   01/28/16 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "Slicers"
    Dim oCollection     As New Collection
    Dim oSlcCch         As SlicerCache
    Dim oSlc            As Slicer

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set Slicers = Nothing     'Assume not found
    
'   Procedure
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    For Each oSlcCch In oWorkbook.SlicerCaches
        For Each oSlc In oSlcCch.Slicers
            oCollection.Add oSlc, oSlc.Name
        Next
    Next
    Set Slicers = oCollection
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function Tabs(Optional ByVal oWorkbook As Workbook = Nothing) As Object
    
'   Description:Creates a "collection" of Worksheets
'   Inputs:     oWorkbook   Worksheet's Workbook
'   Outputs     me          Success: Worksheets Collection
'                           Failure: Nothing
'   Example:    ? Exists(Worksheets(ActiveWorkbook), "Sheet1")

'     Date   Ini Modification
'   02/04/15 CWH Initial Development
'   03/15/15 CWH Changed from Collection to Dictionary Object
    
'   Declarations
    Const cRoutine      As String = "Tabs"
    Dim oDictionary     As Object
    Dim oWks            As Worksheet

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set Tabs = Nothing     'Assume not found
    
'   Initialize Variable
    Set oDictionary = CreateObject("Scripting.Dictionary")

'   Procedure
    If oWorkbook Is Nothing Then Set oWorkbook = ActiveWorkbook
    For Each oWks In oWorkbook.Worksheets
        oDictionary.Add oWks.Name, oWks
        oDictionary.Add oWks.CodeName, oWks
    Next
    Set Tabs = oDictionary
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 457: Resume Next                  'Already Exists
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function




'   Conversion Functions

'   Similar to VBA's "Type Conversion Functions" (CBool, CInt, CDate, etc)
'   this routine attempts to coerce whatever is passed to it into a
'   workbook object. It allows functions to accept workbook parameters as
'   objects, names, ranges, or index numbers adding a 'polymorphic' quality
'   to host routines.


Public Function cAddress(ByVal vTarget As Variant, _
                Optional ByVal bDataBody As Boolean = True) As String

'   Description:Convert something to a range address
'   Inputs:     vTarget     Something to be converted to an address
'               bDataOnly   For Tables, get databodyrange when True
'   Outputs:    cAddress    Success: An address
'                           Failure: Failure
'   Example:    ?cAddress("Connections")

'     Date   Ini Modification
'   12/02/11 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "cAddress"
    Dim oRng            As Range        'Temporary Range
    Dim oLo             As ListObject   'Temporary ListObject
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    cAddress = Failure     'Assume the Worst
        
'   Procedure
    Select Case TypeName(vTarget)
        Case Is = "Range":
            Set oRng = vTarget
        Case Is = "ListObject":
            Set oRng = IIf(bDataBody, vTarget.DataBodyRange, vTarget.Range)
        Case Is = "String":
            If Exists(Tables, CStr(vTarget), oLo) Then
                Set oRng = IIf(bDataBody, oLo.DataBodyRange, oLo.Range)
            Else
                Set oRng = cRange(vTarget)
            End If
    End Select
    If Not oRng Is Nothing Then cAddress = oRng.Address(External:=True)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select


End Function


Public Function cWorkbook(ByRef vWorkbook As Variant) As Workbook

'   Description:Convert some variable or literal to a workbook object
'   Inputs:     vWorkbook   Something that can be coerced to a workbook object
'   Outputs:    Me          Success:Workbook
'                           Failure:Nothing
'   Requisites: *None
'   Example:    ?cWorkbook(1).Name
'               ?cWorkbook("PapaGantt.xls").Name

'     Date   Ini Modification
'   07/07/14 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "cWorkbook"
    Dim o               As Object

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set cWorkbook = Nothing    'Assume the Worst
            
'   Procedure
    Select Case TypeName(vWorkbook)
        Case Is = "Workbook":           Set cWorkbook = vWorkbook
        Case Is = "Integer", "String":  Set cWorkbook = Workbooks(vWorkbook)
        Case Is = "Nothing", "Empty":   Set cWorkbook = ActiveWorkbook
        Case Else
            If IsObject(vWorkbook) Then
                Set o = vWorkbook.Parent
                If TypeName(o) <> "Workbook" Then Set o = vWorkbook.Parent
                If TypeName(o) = "Workbook" Then Set cWorkbook = o
            End If
    End Select
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9, 13:  Resume Next
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function cWorksheet(ByVal vWorksheet As Variant, _
                  Optional ByVal vWorkbook As Variant) As Object

'   Description:Convert some variable or literal to a Worksheet object
'   Inputs:     vWorksheet  Something that can be coerced to a worksheet or
'                           Chart object
'               vWorkbook   Something that can be coerced to a Workbook object
'   Outputs:    Me          Success:Worksheet
'                           Failure:Nothing
'   Requisites: Routines    me.cWorkbook
'   Example:    Set ws = cWorksheet(WorkSheet)
'   Tests:      ?cWorksheet(Workbooks(1).Activesheet.name, Workbooks(1)).Name
'               ?cWorksheet(Workbooks(1).ActiveSheet.Name, 1).Name
'               ?cWorksheet(Workbooks(1).ActiveSheet.Name).Name 'Erros if 1 isn't ThisWorkbook
'               ?cWorksheet(ActiveSheet.Name).Name

'     Date   Ini Modification
'   03/31/11 CWH Initial Development
'   07/08/11 CWH Added Integer and Range options
'   08/15/11 CWH Added default to ActiveSheet
'   11/08/11 CWH Added Component Name handling and new Error Handling
'   02/21/12 CWH Added optional parameter vWorkbook
'   06/01/12 CWH Added Code Names

'   Declarations
    Const cRoutine      As String = "cWorksheet"
    Dim oWkb            As Workbook
    Dim oObj            As Object

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set cWorksheet = Nothing    'Assume the Worst
    
'   Check Inputs and Requisites
    If IsMissing(vWorkbook) Then _
        Set oWkb = ActiveWorkbook Else _
            Set oWkb = cWorkbook(vWorkbook)
            
'   Procedure
    Select Case TypeName(vWorksheet)
        Case Is = "Chart", "Worksheet":  Set cWorksheet = vWorksheet
        Case Is = "Integer"
            If CLng(vWorksheet) > 0 Then
                If CLng(vWorksheet) <= oWkb.Worksheets.Count Then
                    Set cWorksheet = oWkb.Worksheets(CLng(vWorksheet))
                ElseIf CLng(vWorksheet) <= oWkb.Charts.Count Then
                    Set cWorksheet = oWkb.Charts(CLng(vWorksheet))
                End If
            End If
        Case Is = "String"
            If Exists(oWkb.Worksheets, vWorksheet, oObj) Then
                Set cWorksheet = oObj
            ElseIf Exists(oWkb.Charts, vWorksheet, oObj) Then
                Set cWorksheet = oObj
            Else
                For Each oObj In oWkb.Worksheets
                    If oObj.CodeName = vWorksheet Then
                        Set cWorksheet = oObj
                        Exit For
                    End If
                Next
                If TypeName(vWorksheet) <> "Worksheet" Then
                    For Each oObj In oWkb.Charts
                        If oObj.CodeName = vWorksheet Then
                            Set cWorksheet = oObj
                            Exit For
                        End If
                    Next
                End If
            End If
        Case Is = "Nothing", "Empty"
            Set cWorksheet = ActiveSheet
        Case Else
            If IsObject(vWorksheet) Then Set cWorksheet = vWorksheet.Parent
    End Select
        
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9:   Resume Next
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function cRange(ByVal vTarget As Variant, _
              Optional ByVal bDataOnly As Boolean = False, _
              Optional ByVal vWorkbook As Variant) As Range

'   Description:Convert some variable or literal to a Range object
'   Inputs:     vTarget     Item to convert to range
'               bDataOnly   If TRUE, excludes Table HeaderRowRange and TotalRow
'   Outputs:    Me          Success: Range
'                           Failure: Nothing
'   Requisites: Routines    me.cWorkbook
'   Example:    Set Data = CRange(Table)

'     Date   Ini Modification
'   11/20/10 CWH Initial Development
'   03/14/11 CWH Added conversion of Table to Range
'   04/25/11 CWH Added conversion of ListRow and ListColumn
'   07/10/13 CWH Handle R1C1 notation
'   07/23/13 CWH Added Type Mismatch Error handling

'   Declarations
    Dim sRoutine    As String       'Routine's Name
    Dim oWkb        As Workbook
    Dim lo          As ListObject
    Dim s           As String
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    sRoutine = cModule & ".cRange"
    Set cRange = Nothing

'   Check Inputs and Requisites
    If IsMissing(vWorkbook) Then _
        Set oWkb = ActiveWorkbook Else _
            Set oWkb = cWorkbook(vWorkbook)
       
'   Procedure
    Select Case TypeName(vTarget)
        Case Is = "Range":      Set cRange = vTarget
        Case Is = "Worksheet":  Set cRange = vTarget.UsedRange
        Case Is = "String"
            s = CStr(vTarget)
            With oWkb.Worksheets(1)
                If TypeName(.Evaluate(s)) = "Error" Then _
                    s = Application.ConvertFormula(s, xlR1C1, xlA1)
                If TypeName(.Evaluate(s)) = "Range" Then
                    Set cRange = .Evaluate(s)
                    If Not cRange.Cells(1).ListObject Is Nothing Then _
                        If Not bDataOnly Then _
                            Set cRange = cRange.Cells(1).ListObject.Range
                End If
            End With
        Case Is = "ListObject"
            Set cRange = IIf(bDataOnly, vTarget.DataBodyRange, vTarget.Range)
        Case Is = "ListRow", "ListColumn"
            Set cRange = vTarget.Range
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004, 13
        Case Else:
            Select Case DspErrMsg(sRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Public Function cListObject(ByVal vTable As Variant, _
                   Optional ByVal vWorkbook As Variant) As ListObject

'   Description:Make sure Table is a ListObject/Table
'   Inputs      vTable      Something representing a table
'               vWorkbook   Table's workbook
'   Outputs     Me          Success:ListObject
'                           Failure:Nothing
'   NOTE!       This will not create a ListObject
'   Example:    Set lo = cListObject(Table)

'     Date   Ini Modification
'   03/31/11 CWH Initial Development
'   07/21/11 CWH Simplified Coding
'   07/08/13 CWH Added Optional Workbook parameter
    
'   Declarations
    Const cRoutine      As String = "cListObject"
    Dim lo              As ListObject
    Dim oWkb            As Workbook

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set cListObject = Nothing
        
'   Check Inputs and Requisites
    If IsMissing(vWorkbook) Then
        If ActiveWorkbook Is Nothing Then _
            Set oWkb = ThisWorkbook Else _
                Set oWkb = ActiveWorkbook
    Else
        Set oWkb = cWorkbook(vWorkbook)
    End If

'   Procedure
    Select Case TypeName(vTable)
        Case Is = "ListObject": Set cListObject = vTable
        Case Is = "Range":      Set cListObject = vTable.Cells(1).ListObject
        Case Is = "String"
            With oWkb.Worksheets(1)
                If TypeName(.Evaluate(CStr(vTable))) = "Range" Then _
                    Set cListObject = .Evaluate(CStr(vTable)).ListObject
            End With
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function cPivotTable(ByVal vPivotTable As Variant, _
                   Optional ByVal vWorkbook As Variant) As PivotTable

'   Description:Make sure vPivotTable is a PivotTable
'   NOTE!       This will not create a PivotTable
'   Inputs      vPivotTable Something representing a PivotTable
'               vWorkbook   PivotTable's workbook
'   Outputs     Me          Success:PivotTable
'                           Failure:Nothing
'   Example:    ?cPivotTable("pvt").Name

'     Date   Ini Modification
'   06/13/13 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "cPivotTable"
    Dim oWkb            As Workbook
    Dim oWks            As Worksheet
    Dim oPvt            As PivotTable
    Dim Chart            As Chart

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set cPivotTable = Nothing   'Assume the Worst
        
'   Check Inputs and Requisites
    If IsMissing(vWorkbook) Then _
        Set oWkb = ActiveWorkbook Else _
            Set oWkb = cWorkbook(vWorkbook)
        
'   Procedure
    Select Case TypeName(vPivotTable)
        Case Is = "PivotTable": Set cPivotTable = vPivotTable
        Case Is = "Range":      Set cPivotTable = vPivotTable.PivotTable
        Case Is = "String"
            For Each oWks In oWkb.Worksheets
                For Each oPvt In oWks.PivotTables
                    If oPvt.Name = CStr(vPivotTable) Then
                        Set cPivotTable = oPvt
                        Exit For
                    End If
                Next
            Next
            If oPvt Is Nothing Then
                Set Chart = cChart(vPivotTable, oWkb)
                If Not Chart Is Nothing Then _
                    Set cPivotTable = Chart.PivotLayout.PivotTable
            End If
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function cChart(ByVal vChart As Variant, _
              Optional ByVal vWorkbook As Variant) As Chart

'   Description:Make sure vChart is a Chart
'   NOTE!       This will not create a Chart
'   Inputs      vPivotTable Something representing a PiChartvotTable
'               vWorkbook   Chart's workbook
'   Outputs     Me          Success:Chart
'                           Failure:Nothing
'   Example:    ?cChart(Table).Name

'     Date   Ini Modification
'   07/04/13 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "cChart"
    Dim oWkb            As Workbook
    Dim oWks            As Worksheet
    Dim Chart            As ChartObject  'Chart Object
    Dim s               As String       'Generic String
    Dim n               As Long         'Generic Number

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set cChart = Nothing   'Assume the Worst
        
'   Check Inputs and Requisites
    If IsMissing(vWorkbook) Then _
        Set oWkb = ActiveWorkbook Else _
            Set oWkb = cWorkbook(vWorkbook)
        
'   Procedure
    Select Case TypeName(vChart)
        Case Is = "Shape":          Set cChart = vChart.Chart
        Case Is = "ChartObject":    Set cChart = vChart.Chart
        Case Is = "ChartArea":      Set cChart = vChart.Parent
        Case Is = "Chart":          Set cChart = vChart
        Case Is = "Range":          Set cChart = vChart.Chart
        Case Is = "String"
            If vChart Like "*:*" Then
                s = Split(vChart, ":")(0)
                n = CLng(Split(vChart, ":")(1))
                Set cChart = cWorksheet(s).ChartObjects(n).Chart
            End If
            If cChart Is Nothing Then
                For Each oWks In oWkb.Worksheets
                    For Each Chart In oWks.ChartObjects
                        If Chart.Chart.Name = CStr(vChart) Then
                            Set cChart = Chart.Chart
                            Exit For
                        End If
                    Next
                Next
            End If
    End Select

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:                             'Doesn't Exist
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function cColumnIndex(ByVal vTable As Variant, _
                             ByVal vColumn As Variant, _
                    Optional ByVal vWorkbook As Variant) As Long

'   Description:Attempt to convert something to a ListObject Column Index
'   Inputs      vTable      Something representing a Table
'               vColumn     Something representing a Column
'               vWorkbook   Table's workbook
'   Outputs     Me          Success:Column index
'                           Failure:0
'   Examples:   ? cColumnIndex("DET_Properties", "Property")
'               ? cColumnIndex(cListObject("DET_Properties"), 2)
'               ? cColumnIndex(Selection, Selection)

'     Date   Ini Modification
'   11/17/11 CWH Initial Development
'   02/14/12 CWH Checked for Range not in table
'   09/17/12 CWH Allow "column not found" to return 0

'   Declarations
    Const cRoutine      As String = "cColumnIndex"
    Dim oWkb            As Workbook
    Dim oLo             As ListObject

'   Error Handling Initialization
    On Error GoTo ErrHandler
    cColumnIndex = 0                    'Assume failure

'   Check Parameters
    If IsMissing(vWorkbook) Then Set vWorkbook = ActiveWorkbook
    Set oWkb = cWorkbook(vWorkbook)
    Set oLo = cListObject(vTable, oWkb)
    If oLo Is Nothing Then Err.Raise DspError, , "Table not found"
       
'   Procedure
    Select Case TypeName(vColumn)
        Case Is = "String"
            If IsNumeric(vColumn) Then
                cColumnIndex = CLng(vColumn)
            Else
                cColumnIndex = oLo.ListColumns(CStr(vColumn)).index
            End If
        Case Is = "Range"
            If Not cRange(vColumn).ListObject Is Nothing Then
                cColumnIndex = 1 + vColumn.Column - _
                               cRange(vColumn).ListObject.Column
            Else
                cColumnIndex = oLo.ListColumns(CStr(vColumn)).index
            End If
        Case Is = "Integer", "Long", "Single", "Double"
            cColumnIndex = CLng(vColumn)
    End Select
    If cColumnIndex > oLo.ListColumns.Count Then cColumnIndex = 0

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9:    'Subscript out of range - column not found
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function cLocal(ByVal sFormula As String) As String

'   Description:Convert to local formula
'   Inputs      sFormula    Formula to convert to regional value
'   Outputs     Me          Success:Regional Formula
'                           Failure:vbNullString
'   Example:    ?cLocal("=INDEX(tblCfg[Value],MATCH(""WDE"", tblCfg[Code],0))")

'     Date   Ini Modification
'   10/26/16 EVR Initial Development (Special thanks to Eric van Rooijen)
    
'   Declarations
    Const cRoutine      As String = "cLocal"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    cLocal = vbNullString

'   Procedure
    Names.Add "TempFormula", RefersTo:=sFormula
    cLocal = Names("TempFormula").RefersToLocal

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



'   CSV Functions

Public Function Collection2CSV(ByVal vCollection As Variant, _
                      Optional ByVal bSort As Boolean = True, _
                      Optional ByVal vWorkbook As Variant) As String
    
'   Description:Create a CSV (comma seperated values) string from a collection
'   Inputs:     vCollection     Collection to convert items to a CSV
'               bSort           Sort collection first
'               vWorkbook       Workbook containing collections
'   Outputs:    Collection2CSV  If Success: CSV string
'                           If Failure: ""
'   Requisites:
'   Example:    ?Collection2CSV("Tables")
'               ?Collection2CSV(Thisworkbook.BuiltinDocumentProperties)

'     Date   Ini Modification
'   08/14/11 CWH Initial Development
'   12/03/11 CWH Removed Worksheet
'   03/10/12 CWH Added QueryTables
'   03/26/12 CWH Accomodated Embedded Charts
'   04/12/12 CWH Separated this from CBO_Fill
'   09/08/12 CWH Replace obj with v and added Variant()
'   11/28/12 CWH Version 2013.01
'   01/22/13 CWH Used DisplayName for tables
'   07/22/13 CWH Handled empty collection
'   09/17/13 CWH Added oWkb parameter
'   09/18/13 CWH > 0
'   03/16/15 CWH Added Dictionary
'   05/12/15 CWH Added ListRow, ListColumn
'   05/04/18 CWH Handled vWorkbook = Nothing
    
'   Declarations
    Const cRoutine      As String = "Collection2CSV"
    Dim oWkb            As Workbook     'Current Workbook
    Dim oWks            As Worksheet    'Current Worksheet
    Dim oLo             As ListObject   'Current ListObject
    Dim sCSV            As String       'Temporary Result
    Dim v               As Variant      'Element of collection/list/array/range...
    Dim i               As Integer      'Generic Counter
    Dim s               As String       'Generic String
    
'   Error Handling and Function initialization
    On Error GoTo ErrHandler
    Collection2CSV = ""
    
'   Check Inputs
    If IsMissing(vWorkbook) Then Set vWorkbook = ActiveWorkbook
    If vWorkbook Is Nothing Then Set vWorkbook = ThisWorkbook
    Set oWkb = vWorkbook

'   Procedure
    Select Case TypeName(vCollection)
        Case Is = "Nothing"
            sCSV = vbNullString
        Case Is = "Range":
            For Each v In vCollection.Cells
               sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Value
            Next
        Case Is = "ListObject"
            For Each v In vCollection.ListRows
               sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Range(1)
            Next
        Case Is = "Dictionary"
            For Each v In vCollection.Keys()
               sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & CStr(v)
            Next
        Case Is = "String"
            Select Case UCase(Trim(vCollection))
                Case Is = "CHARTS"
                    For Each v In oWkb.Charts
                        sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                    For Each oWks In oWkb.Worksheets
                        For Each v In oWks.ChartObjects
                            sCSV = IIf(Len(sCSV) > 1, sCSV & ",", "") & _
                                oWks.Name & ":" & v.index
                        Next
                    Next
                Case Is = "NAMES"
                    For Each v In oWkb.Names
                        sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Is = "PIVOTTABLES"
                    For Each oWks In oWkb.Worksheets
                        For Each v In oWks.PivotTables
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                        Next
                    Next
                Case Is = "QUERYTABLES"
                    For Each oWks In oWkb.Worksheets
                        For Each v In oWks.ListObjects
                            If HasQueryTable(v) Then _
                                sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.DisplayName
                        Next
                    Next
                Case Is = "SHAPES"
                    For Each oWks In oWkb.Worksheets
                        For Each v In oWks.Shapes
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                        Next
                    Next
                Case Is = "STYLES"
                    For Each v In oWkb.Styles
                        sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Is = "PIVOTTABLE STYLES", "PIVOTTABLESTYLES"
                    For Each v In oWkb.TableStyles
                        If v.Name Like "Pivot*" Then _
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Is = "TABLE STYLES", "TABLESTYLES"
                    For Each v In oWkb.TableStyles
                        If Not v.Name Like "Pivot*" Then _
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Is = "TABLES"
                    For Each oWks In oWkb.Worksheets
                        For Each v In oWks.ListObjects
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.DisplayName
                        Next
                    Next
                Case Is = "TABLES AND NAMES"
                    For Each oWks In oWkb.Worksheets
                        For Each v In oWks.ListObjects
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.DisplayName
                        Next
                    Next
                    For Each v In oWkb.Names
                        If v.Visible Then _
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Is = "WORKBOOKS"
                    For Each v In Application.Workbooks
                        sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Is = "WORKSHEETS", "SHEETS", "TABS"
                    For Each v In oWkb.Worksheets
                        sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                    Next
                Case Else
                    If CStr(vCollection) = "" Then
                        sCSV = vCollection
                    ElseIf Exists(Tables, CStr(vCollection), oLo) Then
                        sCSV = Collection2CSV(oLo)
                    ElseIf Not cRange(vCollection) Is Nothing Then
                        sCSV = Collection2CSV(cRange(vCollection).Columns(1))
                    Else
                        sCSV = vCollection
                    End If
            End Select
        Case Else
            If IsArray(vCollection) Then
                If IsArrayAllocated(vCollection) Then
                For Each v In vCollection
                    Select Case TypeName(v)
                        Case Is = "Range":  v = v.Text
                        Case Is = "Object": v = v.Name
                        Case Else
                    End Select
                    sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v
                Next
                End If
            ElseIf IsObject(vCollection) Then
                Select Case TypeName(vCollection)
                    Case Is = "ListColumn", "ListRow"
                        For Each v In vCollection.Range.Cells
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v
                        Next
                    Case Is = "HTMLSelectElement"
                        For Each v In vCollection
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.InnerText
                        Next
                    Case Else
                        For Each v In vCollection
                            sCSV = IIf(Len(sCSV) > 0, sCSV & ",", "") & v.Name
                        Next
                End Select
            End If
    End Select

    If bSort And UBound(Split(sCSV, ",")) > 0 Then _
        sCSV = Collection2CSV(Sort(Split(sCSV, ",")), False)
        
    Collection2CSV = sCSV

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Public Function DelimitString(ByVal sID As String) As String
    
'   Description:Place single quotes around values in string that are
'               separated by commas
'   Inputs:     sID     String containing one or more values
'   Outputs:    Me      Success:String with singles quotes around values
'                       Failure:Original String
'   Example:    sSQL = "Select * From CUSTMAST where CUSTID in (" & _
                        DelimitString(sInputFromUser) & ") "

'     Date   Ini Modification
'   01/01/01 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "DelimitString"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    DelimitString = sID                   'Assume it's ok
    
'   Procedure
    If InStr(1, sID, ",") > 0 Or _
       InStr(1, sID, Chr(13)) > 0 Then    'If this is a list of IDs
        sID = Replace(sID, "'", "")       'Remove any single quotes
        sID = Replace(sID, Chr(13), ",")  'Replace C/R w/commas
        sID = Replace(sID, ",", "','")    'Put ' around commas between IDs
        sID = "'" & Trim(sID) & "'"       'and around the first & last ID
    End If
    DelimitString = sID

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Public Function CrtCSV(ByVal s As String) As String
    
'   Description:Place double quotes around values in string that are
'               separated by commas
'   Inputs:     sID     String containing one or more values
'   Outputs:    Me      Success:String with singles quotes around values
'                       Failure:Original String
'   Example:    sCSV = CrtCSV(s)

'     Date   Ini Modification
'   10/14/10 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "CrtCSV"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    CrtCSV = s                      'Assume it's ok

    If InStr(1, s, ",") > 0 Or _
       InStr(1, s, Chr(13)) > 0 Then    'If this is a list
        s = Replace(s, Chr(13), ",")    'Replace carriage returns w/commas
        s = Replace(s, ",", """,""")    'Put quotes around commas
    End If
    If Left(LTrim(s), 1) <> """" Then s = """" & s
    If Right(RTrim(s), 1) <> """" Then s = s & """"
    CrtCSV = s

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function Parse_CSV(ByVal sString As String, _
                          ByVal iElement As Integer) As String

'   Description:Returns nth element in a comma & quote seperated string
'   Inputs:     sString     String to be parsed
'               iElement    nth element to return
'   Outputs:    Me          Success:Nth Element
'                           Failure:vbNullString
'   Example:    sName = Parse_CSV(sSQLRead(sSQL, sConnect), 1)

'     Date   Ini Modification
'   01/01/01 CWH Initial Development
'   01/27/11 CWH Code Simplification

'   Declarations
    Const cRoutine      As String = "Parse_CSV"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Parse_CSV = vbNullString    'Assume the Worst

'   Procedure
'   Make sure delimiters are consistent "," (not ", ")
    Do While sString <> Replace(sString, """, ", """,")
        sString = Replace(sString, """, ", """,")
    Loop
'   Get the nth element
    sString = Get_Segment(sString, CLng(iElement), """,""")
    If Len(sString) > 1 Then
      If Left(sString, 1) = """" Then sString = Right(sString, Len(sString) - 1)
      If Right(sString, 1) = """" Then sString = Left(sString, Len(sString) - 1)
    End If
    Parse_CSV = sString
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9: Parse_CSV = "*EOF"  'End of file/string reached
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



'   Array Functions
Function ArrayDimensions(ByVal vArray As Variant) As Long

'   Description:Determine the number of dimensions in an array
'   Inputs:     vArray      Array to determine # of dimensions
'   Outputs:    Me          Success: # of dimensions
'                           Failure: 0
'   Requisites: *None
'   Example:    ?ArrayDimensions(Selection)

'     Date   Ini Modification
'   09/11/12 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "ArrayDimensions"
    Dim X               As Long
    Dim n               As Long

'   Error Handling Initialization
    On Error GoTo ErrHandler
    ArrayDimensions = 0

'   Procedure
    For X = 1 To 60000: n = LBound(vArray, X): Next

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9:    ArrayDimensions = X - 1
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function Sort(ByVal vArray As Variant, _
            Optional ByVal lMin As Long, _
            Optional ByVal lMax As Long) As Variant

'   Description:Sort a 1 dimensional array
'   Inputs:     vArray      Array to sort
'               lMin        Lowest element to restrict sort
'               lMax        Highest element to restrict sort
'   Outputs:    Sort        Success:Sorted Array
'                           Failure:Null
'   Requisites: *None
'   Example:    ?Collection2CSV(Sort(vArray))

'     Date   Ini Modification
'   10/25/12 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Sort"
    Dim vCompare        As Variant  'Compare Value
    Dim i               As Long
    Dim j               As Long
    Dim v               As Variant  'Temporary Variant

'   Error Handling and Procedure Initialization
    On Error GoTo ErrHandler
    Sort = Null
    
'   Check Inputs and Requisites
    If TypeName(vArray) = "Range" Then vArray = Application.Transpose(vArray)
    If Not IsArray(vArray) Then Err.Raise LogError, , "No array sent"
       
'   Procedure
    If LBound(vArray) < UBound(vArray) Then
        If lMin = 0 Then lMin = LBound(vArray)
        If lMax = 0 Then lMax = UBound(vArray)
        i = lMin: j = lMax
        vCompare = vArray(((i + j) \ 2) + IIf(i = 0, 1, 0))
        Do While i < j
            Do While (vArray(i) < vCompare And i < lMax): i = i + 1: Loop
            Do While (vCompare < vArray(j) And j > lMin): j = j - 1: Loop
            If i < j Then
                v = vArray(i)
                vArray(i) = vArray(j)
                vArray(j) = v
            End If
            If i <= j Then i = i + 1: j = j - 1
        Loop
        If lMin < j Then vArray = Sort(vArray, lMin, j)
        If i < lMax Then vArray = Sort(vArray, i, lMax)
    End If
    Sort = vArray

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = LogError: Debug.Print cRoutine & ":" & Err.Description
        Case Is = RtnError: Sort = Err.Description
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Function QSort2D(ByVal vArray As Variant, _
                 ByVal iOnElement As Integer, _
                 ByVal iMin As Integer, _
                 ByVal iMax As Integer) As Boolean

'   Description:Sort an array with 2 dimensions
'   Inputs:     vArray      Array to sort
'               iOnElement  Array's 1st dimension element
'                           on which to sort the array
'               iMin        Lowest element to restrict sort
'               iMax        Highest element to restrict sort
'   Outputs:    QSort2D     Success/Failure
'               vArray      Sorted Array
'   Requisites: *None
'   Example:    ?QSort2D vArray, 1, 0, uBound(vArray,2)

'     Date   Ini Modification
'   12/22/11 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "QSort2D"
    Dim vCompare        As Variant      'Compare Value
    Dim i               As Integer
    Dim j               As Integer
    Dim n               As Integer      'unsorted elements counter
    Dim v               As Variant      'Temporary Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    QSort2D = Failure
       
'   Procedure
    i = iMin: j = iMax
    vCompare = vArray(iOnElement, (i + j) \ 2)
    Do
        Do While (vArray(iOnElement, i) < vCompare And i < iMax)
            i = i + 1
        Loop
        Do While (vCompare < vArray(iOnElement, j) And j > iMin)
            j = j - 1
        Loop
        If i <= j Then
            v = vArray(iOnElement, i)
            vArray(iOnElement, i) = vArray(iOnElement, j)
            vArray(iOnElement, j) = v
        '   Move unsorted elements with sort key
            For n = 0 To UBound(vArray, 1)
                If n <> iOnElement Then
                    v = vArray(n, i)
                    vArray(n, i) = vArray(n, j)
                    vArray(n, j) = v
                End If
            Next
            i = i + 1: j = j - 1
        End If
    Loop While i <= j

    If iMin < j Then QSort2D vArray, iOnElement, iMin, j
    If i < iMax Then QSort2D vArray, iOnElement, i, iMax

    QSort2D = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function




'   String Functions
Function GetClipboard() As String

'   Description:Get text from clipboard
'   Inputs:     *None
'   Outputs:    Me          Success: Clipboard text
'                           Failure: vbNullString
'   Requisites: *None
'   References: https://desmondoshiwambo.wordpress.com/2012/02/23/how-to-copy-and-paste-text-tofrom-clipboard-using-vba-microsoft-access/
'   Example:    ?GetClipboard

'     Date   Ini Modification
'   12/09/14 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetClipboard"
    Static oClipboard   As Object
    Dim s               As String
    Dim n               As Long

'   Error Handling and Procedure Initialization
    On Error GoTo ErrHandler
    GetClipboard = vbNullString
    
'   Initialize Variables
    If oClipboard Is Nothing Then _
        Set oClipboard = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
    
'   Procedure
    oClipboard.GetFromClipboard
    GetClipboard = oClipboard.GetText

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = -2147221404                       'Nothing in Clipboard
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function



Public Function CrtGUID() As String

'   Description:Create a GUID
'   Inputs:     *None
'   Outputs:    Me          Success: GUID
'                           Failure: vbNullString
'   Requisites: Type        GUID_TYPE
'               API         CoCreateGuid
'                           StringFromGUID2
'   Notes:      https://support.microsoft.com/en-us/help/4036837/run-time-error-70-permission-denied-generate-guid-with-office-vba
'               StrPtr gets the memory address of a string
'               String$ is the same as String()
'               LongPtr and Long are the same in VBA at this time
'   Example:    ?CrtGUID

'     Date   Ini Modification
'   10/19/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "CrtGUID"
    Const guidLength    As Long = 39 'registry GUID format with null terminator {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    Dim guid            As GUID_TYPE
    Dim sGuid           As String
    Dim lpValue         As LongPtr

'   Error Handling Initialization
    On Error GoTo ErrHandler
    CrtGUID = vbNullString
    
'   Procedure
    lpValue = CoCreateGuid(guid)
    If lpValue = 0 Then
        sGuid = String(guidLength, vbNullChar) 'Reserve memory space of 39 characters
        lpValue = StringFromGUID2(guid, StrPtr(sGuid), guidLength)
        If lpValue = guidLength Then CrtGUID = Left(sGuid, 38)
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


'   Table Functions
Public Function CrtLO(ByVal vWorksheet As Variant, _
                      ByVal vTopLeft As Variant, _
                      ByVal sTableName As String) As ListObject

'   Description:Create a Table/ListObject to BXL Standards
'   Inputs:     vWorksheet  Worksheet with table's range
'               vTopLeft    Top Left cell of table's range
'               sTableName  Name to give table
'   Outputs:    Me          Success:ListObject
'                           Failure:Nothing
'   Example:    This was created to service Create_Table which is the UI
'               for this function.  By seperating it, the function can be
'               called from code.

'     Date   Ini Modification
'   03/30/11 CWH Initial Development
'   04/25/11 CWH Return ListObject
'   07/20/11 CWH Added MergeArea
'   07/22/11 CWH Added check for style TableHeader
'   09/22/11 CWH Consolidated AutoFilter
'   08/06/12 CWH Used cWorksheet instead of WorksheetExists and
'                to not create so many range names.
'   03/25/15 CWH Added sTableName above Table

'   Declarations
    Const cRoutine      As String = "CrtLO"
    Dim oLo             As ListObject   'Generic ListObject
    Dim oWks            As Worksheet
    Dim oRange          As Range

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set CrtLO = Nothing
    
'   Check Inputs
    Set oWks = cWorksheet(vWorksheet)
    If oWks Is Nothing Then Err.Raise DspError, , "Worksheet not found"
    If TypeName(vTopLeft) = "String" Then Set vTopLeft = oWks.Range(vTopLeft)
    Set oRange = cRange(vTopLeft).CurrentRegion
    If oRange Is Nothing Then Err.Raise DspError, , "TopLeft not a valid range"
        
'   Procedure
    If oRange.Rows.Count < 2 Then Set oRange = oRange.Rows("1:2")
    sTableName = FixName(sTableName)
    If sTableName <= "" Then Err.Raise DspError, , "TableName not valid"
'   Unlist table (if it exists) and get rid of any name conflicts
    If Exists(Tables(oWks.Parent), sTableName, oLo) Then oLo.Unlist
    If Exists(oWks.Parent.Names, sTableName) Then oWks.Parent.Names(sTableName).Delete
'   Create table and Format to taste
    Set oLo = oWks.ListObjects.Add(xlSrcRange, oRange, , xlYes, Selection)
    With oLo
        .Name = sTableName
        If .Range.ROW > 2 Then
            If .Range.Cells(-1, 1).ListObject Is Nothing Then
                With .Range.Cells(-1, 1)
                    .UnMerge
                    .Value = sTableName
                    .Style = "Heading 2"
                    .Resize(1, oLo.ListColumns.Count).Merge
                End With
                With .Range.Cells(0, 1)
                    .UnMerge
                    .Style = "Explanatory Text"
                    .Resize(1, oLo.ListColumns.Count).Merge
                End With
            End If
        End If
        .HeaderRowRange.Style = _
            IIf(Exists(oWks.Parent.Styles, "TableHeader"), "TableHeader", "Accent1")
    End With
   'Turn off annoying auto filter (because that's the way I roll)
    oLo.Range.Cells(1, 1).AutoFilter
    Set CrtLO = oLo
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function GetLC(ByVal oTarget As Range) As ListColumn

'   Description:Get a Target's ListColumn
'   Inputs:     oTarget     Cell for which to get ListColumn
'   Outputs:    Me          Success: ListColumn
'                           Failure: Nothing
'   Requisites: *None
'   Example:    ?GetLC(Selection).Name

'     Date   Ini Modification
'   02/11/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetLC"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set GetLC = Nothing
    
'   Procedure
    With oTarget
        If Not .ListObject Is Nothing Then _
            Set GetLC = .ListObject.ListColumns(1 + .Column - .ListObject.Range.Column)
    End With
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function GetLR(ByVal oTarget As Range) As ListRow

'   Description:Get a Target's ListRow
'   Inputs:     oTarget     Cell for which to get ListRow
'   Outputs:    Me          Success: ListRow
'                           Failure: Nothing
'   Requisites: *None
'   Example:    ?GetLR(Selection).Index

'     Date   Ini Modification
'   02/11/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetLR"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set GetLR = Nothing
    
'   Procedure
    With oTarget
        If Not .ListObject Is Nothing Then _
            Set GetLR = .ListObject.ListRows(.ROW - .ListObject.HeaderRowRange.ROW)
    End With
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function GetFLD(ByVal oLR As ListRow, _
                       ByVal sHdg As String) As Range

'   Description:Get a ListRow's Cell by Heading
'   Inputs:     oLR         ListRow
'               sHdg        Column Heading
'   Outputs:    Me          Success: Cell
'                           Failure: Nothing
'   Requisites: *None
'   Example:    ?GetFLD([tblWCS].ListObject.ListRows(1), "Title")

'     Date   Ini Modification
'   07/19/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetFLD"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set GetFLD = Nothing
    
'   Procedure
    Set GetFLD = oLR.Range(oLR.Parent.ListColumns(sHdg).index)
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 9                                 'Do nothing (Heading not found)
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function SrtTbl(ByVal oListObject As ListObject, _
                       ParamArray vColOrdPars() As Variant) As Boolean

'   Description:Sort Table
'   Inputs:     oListObject Table to Sort
'               vColOrdPars Column/Order Pairs
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   Example:    ?SrtTbl([CFR].ListObject, "SetID","A","Priority","A")

'     Date   Ini Modification
'   04/22/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "SrtTbl"
    Dim n               As Long
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SrtTbl = Failure
    
'   Procedure
    With oListObject
        .Sort.SortFields.Clear
        For n = LBound(vColOrdPars) To UBound(vColOrdPars) Step 2
           'Note: xlSortTextAsNumbers = 1  (enumeration valid in 2003+)
            .Sort.SortFields.Add Key:=.ListColumns(vColOrdPars(n)).Range, _
                                 SortOn:=xlSortOnValues, _
                                 Order:=IIf(vColOrdPars(n + 1) = "D", _
                                            xlDescending, xlAscending), _
                                 DataOption:=xlSortNormal, _
                                 CustomOrder:=IIf(Len(vColOrdPars(n + 1)) > 1, _
                                            vColOrdPars(n + 1), vbNullString)
            With .Sort
                .Header = xlYes
                .MatchCase = False
                .Orientation = xlTopToBottom
                .SortMethod = xlPinYin
            End With
        Next n
        .Sort.Apply
    End With
    SrtTbl = Success
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function FixName(ByVal sName As String) As String

'   Description:Fix strings for use as a name
'   Inputs:     sName       String to be fixed
'   Outputs:    Me          Success:String
'                           Failure:vbNullString
'   Example:    FixName = FixName("1st deposit %")

'     Date   Ini Modification
'   11/02/10 CWH Initial Development
'   09/26/16 CWH Used RegEx & Replace arrays
    
'   Declarations
    Const cRoutine      As String = "FixName"
    Dim n               As Long         'Counter
    Dim X               As Long         'Number
    Dim sReplace()      As String
    Dim sWith()         As String

'   Error Handling Initialization
    On Error GoTo ErrHandler
    FixName = sName
            
'   Procedure
    sReplace = Split("1st ,2nd ,3rd ,4th ,5th ,6th ,7th ,8th ,9th ", ",")
    sWith = Split("First,Second,Third,Fourth,Fifth,Sixth,Seventh,Eighth,Nineth", ",")
    For n = LBound(sReplace) To UBound(sReplace)
        X = WorksheetFunction.Min(Len(sName), 4)
        sName = IIf(Left(sName, X) = Left(sReplace(n), X), _
                    sWith(n), _
                    Left(sName, X)) & Right(sName, Len(sName) - X)
    Next
    sName = IIf(Left(sName, 1) Like "[0-9]", "_", "") & sName
    sReplace = Split("#,$,%,&,*,+,-,/,<,=,>,@,|fffd|,|fffd|,|fffd|", ",")
    sWith = Split("No.,USD ,Pct. , And , Times , Plus , Less , Per ," & _
                  " Less Than , Equals , Greater Than , At ,Cents ,GBP ,Yen ", ",")
    For n = LBound(sReplace) To UBound(sReplace)
        sName = Replace(sName, sReplace(n), sWith(n))
    Next
    sName = Replace(sName, "  ", " ")
    sName = RegEx(sName, "[|fffd|!""#$%&'()*+,-/:;<=>@\[\]^`{\|}~|fffd||fffd||fffd||fffd||fffd||fffd| ]", rxReplace, "_")
    FixName = sName

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


'   Index Functions

Public Function CrtIDX(ByVal vRecords As Variant, _
              Optional ByVal lKeyColumns As Long = 1) As Object

'   Description:Create Property Table Dictionary (Recursive)
'   Inputs:     vRecords    Records (in Range, or Table)
'               lKeyColumns Number of columns to use as keys
'   Outputs:    Me          Success: Dictionary
'                           Failure: Nothing
'   Requisites: Function:   IdxRec
'   Notes:      See LstIDX for how to access IDX
'               PDD ex: Set oIDX = CrtIDX([PDD],3)
'   Example:    ?CrtIDX([PDD]).Count

'     Date   Ini Modification
'   10/02/15 CWH Initial Development
'   08/13/16 CWH Handled DataBodyRange is Nothing

'   Declarations
    Const cRoutine      As String = "CrtIDX"
    Dim oLo             As ListObject   'Table to Index
    Dim oRecords        As Object       'Records to be processed in a dictionary
    Dim vHdrs           As Variant      'Record Field Names/Column Headers
    Dim lRow            As Long         'Records Row
    Dim lCol            As Long         'Records Column
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set CrtIDX = Nothing
    
'   Check Inputs and Requisites
    Select Case TypeName(vRecords)
        Case Is = "ListObject": Set oLo = vRecords
        Case Is = "Range":      Set oLo = vRecords.ListObject
        Case Is = "String":     Set oLo = Range(vRecords).ListObject
    End Select
    If oLo Is Nothing Then Err.Raise _
        DspError, , "Could not interpret vRecords parameter"
    
'   Initialize Variables
    Set oRecords = CreateObject("Scripting.Dictionary")
    vHdrs = Application.Transpose( _
        Application.Transpose(oLo.HeaderRowRange))
    
'   Procedure
    If Not oLo.DataBodyRange Is Nothing Then
    '   Convert records to dictionary
        ReDim v(1 To oLo.ListColumns.Count)
        For lRow = 1 To oLo.ListRows.Count
        '   Handle bug in Application.Transpose
            If oLo.ListColumns.Count < 4 Then
                For lCol = 1 To oLo.ListColumns.Count
                    v(lCol) = oLo.ListRows(lRow).Range(lCol)
                Next
                oRecords(lRow) = v
            Else
                oRecords(lRow) = Application.Transpose( _
                    Application.Transpose(oLo.ListRows(lRow).Range))
            End If
        Next
    '   Index Records
        Set CrtIDX = IdxRec(oRecords:=oRecords, _
                            lKeyColumns:=lKeyColumns, _
                            vHdrs:=vHdrs, _
                            lCol:=1)
    End If
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Private Function IdxRec(ByVal oRecords As Object, _
                        ByVal lKeyColumns As Long, _
                        ByVal vHdrs As Variant, _
                        ByVal lCol As Long) As Variant

'   Description:Index Records in a Dictionary Object (Recursive)
'   Inputs:     oRecords    Records to index
'               lKeyColumns Number of columns to use as keys
'               vHdrs       Record Field Names/Column Headers
'               lCol        Table Column to filter
'   Outputs:    Me          Success: Dictionary
'                           Failure: Nothing
'   Requisites: Function:   *None!
'   Notes:      See LstIDX for how to access IDX
'               PDD ex: Set oPivot = IdxRec([PDD])
'                       ?
'   Example:    See IdxRecUI()

'     Date   Ini Modification
'   09/30/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "IdxRec"
    Dim oResults        As Object       'Results Dictionary
    Dim oChildren       As Object       'Filtered Records in a dictionary
    Dim lRowChild       As Long         'Children Row
    Dim oValues         As Object       'Unique Values in column lKey + 1
    Dim vValue          As Variant      'A single value
    Dim lCols           As Long         'Record Column Count
    Dim lRow            As Long         'Records Row
    Dim n               As Long         'Generic Counter

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set IdxRec = Nothing

'   Initialize Variables
    Set oResults = CreateObject("Scripting.Dictionary")
    lCols = UBound(oRecords(1))
    
'   Procedure
    If lCol = lKeyColumns Then
    '   Last key column. Return data
        For lRow = 1 To oRecords.Count
            If lCols = lKeyColumns + 1 Then
            '   Return value at right using value in column as key
                oResults(oRecords(lRow)(lCol)) = oRecords(lRow)(lCols)
            Else
            '   Return values at right using column headings as keys
                Set oValues = CreateObject("Scripting.Dictionary")
                For n = lKeyColumns + 1 To lCols
                    oValues(vHdrs(n)) = oRecords(lRow)(n)
                Next
                Set oResults(oRecords(lRow)(lCol)) = oValues
                Set oValues = Nothing
            End If
        Next
    Else
    '   Not last key column.  Determining key values in column
        Set oValues = CreateObject("Scripting.Dictionary")
        For lRow = 1 To oRecords.Count
            oValues(oRecords(lRow)(lCol)) = oRecords(lRow)(lCol)
        Next
    '   Process each unique key value
        For Each vValue In oValues
        '   Filter records on unique key value
            Set oChildren = CreateObject("Scripting.Dictionary")
            lRowChild = 0
            For lRow = 1 To oRecords.Count
                If oRecords(lRow)(lCol) = vValue Then
                    lRowChild = lRowChild + 1
                    oChildren(lRowChild) = oRecords(lRow)
                End If
            Next
        '   Index on key value
            Set oResults(vValue) = IdxRec(oChildren, lKeyColumns, vHdrs, lCol + 1)
            Set oChildren = Nothing
        Next
    End If
    
    Set IdxRec = oResults
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 13                                'Do Nothing?
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function LstIDX(ByVal oIDX As Object, _
              Optional ByVal sKey As String = vbNullString) As Boolean

'   Description:List Property Table Dictionary (Recursive)
'   Inputs:     oIDX        Dictionare to list
'   Outputs:    Me          Success/Failure
'   Requisites: Function:   *None
'   Notes:      See LstIDX for how to access IDX
'   Example:    ?lstIDX(CrtIDX([PDD]))

'     Date   Ini Modification
'   09/30/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "LstIDX"
    Dim vValue          As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    LstIDX = Failure

'   Procedure
    For Each vValue In oIDX
        If TypeName(oIDX(vValue)) = "Dictionary" Then _
            LstIDX oIDX(vValue), sKey & vbTab & vValue Else _
                Debug.Print sKey & vbTab & vValue & vbTab & oIDX(vValue)
    Next
    
    LstIDX = Success
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Public Function GetIDX(ByVal oIDX As Object, _
                       ParamArray vKeys() As Variant) As Variant

'   Description:Get a property or property collection from an index
'   Inputs:     oIDX        Index (Dictionary Object)
'   Outputs:    Me          Success: Property value or, if a partial key was sent,
'                                    Dictionary collection of matching properties
'                           Failure: Null
'   Requisites: Function:   *None
'   Example:    ?GetIDX(CrtIDX([PDD]), "Test","Values","Caption")

'     Date   Ini Modification
'   09/30/15 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetIDX"
    Dim vKey            As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    GetIDX = Null

'   Check Inputs and Requisites
    If UBound(vKeys) = -1 Then Err.Raise DspError, , "Key(s) required"
    
'   Procedure
    For Each vKey In vKeys
        If TypeName(oIDX(vKey)) = "Dictionary" Then _
            Set oIDX = oIDX(vKey) Else _
                GetIDX = oIDX(vKey): Exit For
    Next
    If IsNull(GetIDX) Then Set GetIDX = oIDX
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


'   Search and  Update Functions

Public Function RmvRng(ByVal oRemove As Range, _
                       ByVal oFrom As Range) As Range

'   Description:Remove a range from a range
'   Inputs:     oRemove     Range to remove from Parent (Remove this)
'               oFrom       Starting Range (From this)
'   Outputs:    Me          Success:Reduced Range
'                           Failure:Unchanged Range
'   Requisites: Routines:   *None
'   Example:    RmvRng([tblWorksheets], Selection).Select

'     Date   Ini Modification
'   01/29/18 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "RmvRng"
'   Parent area top, left, bottom, right
    Dim lALeft          As Long
    Dim lATop           As Long
    Dim lARight         As Long
    Dim lABottom        As Long
'   Exclude top, left, bottom, right
    Dim lXLeft          As Long
    Dim lXTop           As Long
    Dim lXRight         As Long
    Dim lXBottom        As Long
'   Temporary Attributes
    Dim lTop            As Long
    Dim lLeft           As Long
    Dim lRows           As Long
    Dim lCols           As Long
'   Area's within From Range
    Dim oArea           As Range
'   Blocks without Exclude range
    Dim oTop            As Range
    Dim oBottom         As Range
    Dim oLeft           As Range
    Dim oRight          As Range
'   Combine Blocks
    Dim oResult         As Range
    Dim oBlock          As Range        'Range block to combine
    Dim n               As Long         'Loop Counter

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set RmvRng = oFrom
    
'   Check Inputs and Requisites
    If oFrom Is Nothing Then Err.Raise DspError, , "Range required"
    
'   Initialize Variables
    Set oResult = Nothing
'   Get Remove's Coordinates
    With oRemove
        lXLeft = .Column
        lXTop = .ROW
        lXRight = .Column + .Columns.Count - 1
        lXBottom = .ROW + .Rows.Count - 1
    End With

'   Procedure
    For Each oArea In oFrom.Areas
        If Intersect(oArea, oRemove) Is Nothing Then
        '   No intersection. Keep entire area
            If oResult Is Nothing Then _
                Set oResult = oArea Else _
                    Set oResult = Union(oResult, oArea)
        Else
        '   Initialize variables
            Set oTop = Nothing:  Set oBottom = Nothing
            Set oLeft = Nothing: Set oRight = Nothing
        '   Get Area's Coordinates
            With oArea
                lALeft = .Column
                lATop = .ROW
                lARight = .Column + .Columns.Count - 1
                lABottom = .ROW + .Rows.Count - 1
            End With
        '   Top block - Area's top must be above Remove's top
            If lATop < lXTop Then
                lCols = oArea.Columns.Count
                lRows = lXTop - lATop
                Set oTop = oArea.Resize(lRows, lCols)
            End If
        '   Bottom block - Area's bottom must be below Remove's bottom
            If lABottom > lXBottom Then
                lTop = lXBottom - lATop + 2
                lCols = oArea.Columns.Count
                lRows = lABottom - lXBottom
                Set oBottom = oArea.Cells(lTop, 1).Resize(lRows, lCols)
            End If
        '   Determine left and right blocks' top row (relative to Area)
            If oTop Is Nothing Then _
                lTop = 1 Else _
                    lTop = oTop.Rows.Count + 1
        '   Determine left and right block's row count
            If oBottom Is Nothing Then _
                lRows = lABottom - lATop - lTop + 2 Else _
                    lRows = oBottom.ROW - lATop - lTop + 1
        '   Left block - Area's Left must be left of Remove's left
            If lALeft < lXLeft Then
                lCols = lXLeft - lALeft
                Set oLeft = oArea.Cells(lTop, 1).Resize(lRows, lCols)
            End If
        '   Right block - Area's right must be right of Remove's right
            If lARight > lXRight Then
                lLeft = lXRight - lALeft + 2
                lCols = lARight - lXRight
                Set oRight = oArea.Cells(lTop, lLeft).Resize(lRows, lCols)
            End If
        '   Combine blocks
            For n = 1 To 4
                Set oBlock = Choose(n, oTop, oBottom, oLeft, oRight)
                If Not oBlock Is Nothing Then _
                    If Not oResult Is Nothing Then _
                        Set oResult = Union(oResult, oBlock) Else _
                            Set oResult = oBlock
            Next
        End If
    Next
                
        
    
    Set RmvRng = oResult
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 5: Resume Next                    'All Ranges are Nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function




Public Function FindNextGreater(ByVal oRange As Range, _
                                ByVal vValue As Variant) As Variant

'   Description:Finds next greater value in a range
'   Inputs:     oRange      Range to check
'               vValue      Value that the result must be greater than
'   Outputs:    Me          Success:Value
'                           Failure:Null
'   Requisites: Routines:   Me.cRange
'   Example:    dNextDay = FindNextGreater(Range("Data_PostingDate"), Now())

'     Date   Ini Modification
'   01/01/01 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "FindNextGreater"
    Dim sFormula        As String
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    FindNextGreater = Null
    
'   Check Inputs and Requisites
    If oRange Is Nothing Then Err.Raise DspError, , "Range required"
    
'   Initialize Variables
    sFormula = "SMALL(<Range>,RANK(""<Value>"",<Range>,1)+1)"
    
'   Procedure
    sFormula = Replace(sFormula, "<Range>", oRange.Address(External:=True))
    sFormula = Replace(sFormula, "<Value>", vValue)
    v = oRange.Parent.Evaluate(sFormula)
    FindNextGreater = v
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SelCols(ByVal oLo As ListObject, _
                        ByVal vHdgs As Variant) As Range

'   Description:Select table records in specified columns
'   Inputs:     oLO         Table containing columns
'               vHdgs       Array of column headings
'   Outputs:    Me          Success: Range
'                           Failure: Nothing
'   Requisites: Routines    modGeneral.Exists
'   Example:    ?SelCols(oLO:=Selection.ListObject, _
                         vHdgs:=Array("Formula Complexity", _
                                      "Formula Complexity Penalty")).Address
'   Example:    ?SelCols(oLO:=Selection.ListObject, _
                         vHdgs:=Split("Formula Complexity,Formula Complexity Penalty", ",")).Address

'     Date   Ini Modification
'   08/13/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "SelCols"
    Dim oCols           As Range        'Selected Columns
    Dim oLC             As ListColumn   'Current ListColumn
    Dim n               As Long         'Counter

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set SelCols = Nothing

'   Check Inputs and Requisites
    If Not IsArray(vHdgs) Then vHdgs = Array(vHdgs)

'   Initialize Variables
    Set oCols = Nothing
    
'   Procedure
    For n = LBound(vHdgs) To UBound(vHdgs)
        If Exists(oLo.ListColumns, vHdgs(n), oLC) Then
            If oCols Is Nothing Then _
                Set oCols = oLC.Range Else _
                    Set oCols = Union(oCols, oLC.Range)
        End If
    Next
    Set SelCols = oCols

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SelRows(ByVal vTable As Variant, _
                        ByVal vKeyCol As Variant, _
                        ByVal lKeyOpr As XlAutoFilterOperator, _
                        ByVal vKeyVal As Variant, _
                        ParamArray vAddKeys() As Variant) As Range

'   Description:Select a row or rows in a table based on key values
'   Inputs:     vTable      Table (Name,Range,or ListObject) containing rows to Select
'               vKeyCol     First column to search (Required)
'               lKeyOpr     Comparison Operator
'               vKeyVal     Value to find in first column (Required)
'               vAddKeys    (Optional) Additional column/opr/key
'   Outputs:    Me          Success: Range(s) of rows matching criteria
'                           Failure: Nothing
'   Requisites: Function:   modGeneral.cListObject
'   References: XlAutoFilterOperator: msdn.microsoft.com/en-us/library/bb240957(v=office.12).aspx
'   Example:    ?SelRows("Skin", 2, xlFilterValues, "FONT").Address
'               ?SelRows("Skin", 2, xlFilterCellColor, thisworkbook.Styles("Good").Interior.Color, "2", xlFilterValues, "FONT").Select
'               SelRows("DET_Properties", 1, xlAnd, "DET").Delete
'               SelRows("DET_Properties", 2, "ID*").Select
'               ?SelRows("Table1", 3,xlFilterCellColor,RGB(255,0,0), "A",xlOr, "4,8").address

'     Date   Ini Modification
'   08/14/14 CWH Initial Development
'   08/05/17 CWH Return Error when column name not found

'   Declarations
    Const cRoutine      As String = "SelRows"
    Dim oLo             As ListObject   'Table being searched
    Dim vArray          As Variant      'Parameter Array
    Dim bScreenUpdating As Boolean      'Screen Updating Flag
    Dim n               As Long         'Generic Counter

'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set SelRows = Nothing
    bScreenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = False

'   Check Inputs and Requisites
    Set oLo = cListObject(vTable)
    If oLo Is Nothing Then Err.Raise DspError, , "Table missing"
    If Not IsMissing(vAddKeys()) Then _
        If IsArray(vAddKeys(0)) Then _
            vArray = vAddKeys(0) Else _
                vArray = vAddKeys

'   Procedure
    With oLo
        If oLo.ListRows.Count > 0 Then
        '   Create Filter
            .Range.AutoFilter
            SetFilter oRange:=.Range, _
                      lField:=.ListColumns(vKeyCol).index, _
                      lOperator:=lKeyOpr, _
                      vCriteria:=vKeyVal
            If Not IsMissing(vAddKeys()) Then
                For n = 0 To UBound(vArray) Step 3
                    SetFilter oRange:=.Range, _
                              lField:=.ListColumns(vArray(n)).index, _
                              lOperator:=vArray(n + 1), _
                              vCriteria:=vArray(n + 2)
                Next
            End If
            Set SelRows = .DataBodyRange.SpecialCells(xlCellTypeVisible)
            oLo.Range.AutoFilter = Nothing
        End If
    End With

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004, 424: Resume Next            'No Cells Selected
        Case Is = 9
            Select Case DspErrMsg(cModule & "." & cRoutine, _
                                  vArray(n) & " not found in " & oLo.Name)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    Application.ScreenUpdating = bScreenUpdating

End Function


Public Function SetFilter(ByVal oRange As Range, _
                          ByVal lField As Long, _
                          ByVal lOperator As XlAutoFilterOperator, _
                          ByVal vCriteria As Variant) As Boolean
                           
'   Inputs:     oRange      Range containing rows to Select
'               lField      Column # within range to filter
'               lOperator   Comparison Operator
'               vCriteria   Criteria to use for filtering
'   Outputs:    Me          Success: Range(s) of rows matching criteria
'                           Failure: Nothing
'   Requisites: *None
'   Notes:      XlAutoFilterOperator: msdn.microsoft.com/en-us/library/bb240957(v=office.12).aspx)
'   Example:    SetFilter([tblComponents], 2, xlAnd, "FONT").Address
'               SetFilter [tblComponents], 1, xlFilterCellColor, 12566463

'     Date   Ini Modification
'   08/14/14 CWH Initial Development
'   04/27/17 CWH Added no operator option
'   06/27/17 CWH Handled empty table situation

'   Declarations
    Const cRoutine      As String = "SetFilter"
    Dim vArray          As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetFilter = Failure
    
'   Procedure
    With oRange
        Select Case lOperator
            Case Is = 0
                .AutoFilter Field:=lField, _
                            Criteria1:=vCriteria
            Case Is = xlFilterValues
                If IsArray(vCriteria) Then vArray = vCriteria Else vArray = Split(vCriteria, ",")
                .AutoFilter Field:=lField, _
                            Operator:=lOperator, _
                            Criteria1:=vArray
            Case Is = xlOr, xlAnd
                If IsArray(vCriteria) Then vArray = vCriteria Else vArray = Split(vCriteria, ",")
                If UBound(vArray) = -1 Then vArray = Array(vCriteria, vCriteria)
                .AutoFilter Field:=lField, _
                            Operator:=lOperator, _
                            Criteria1:=vArray(LBound(vArray)), _
                            Criteria2:=vArray(UBound(vArray))
            Case Else
                .AutoFilter Field:=lField, _
                            Operator:=lOperator, _
                            Criteria1:=vCriteria
        End Select
    End With
    SetFilter = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004:                             'Can't set. Do Nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
                           
End Function


Public Function XLookup(ByVal vTable As Variant, _
                        ByVal vResult As Variant, _
                   ParamArray vKeyVals() As Variant) As Variant

'   Description:Multiple Key (Left most) lookup
'   Inputs:     vTable      Data table
'               vResult     Result Column (heading or #)
'               vKeyVals    Key Values to search for
'   Outputs:    Me          Success: Cell
'                           Failure: If UDF #REF Else Nothing
'   Requisites: *None
'   Example:    ?XLookup("tblCities", "USA", "VA", "Norfolk", "Population")

'     Date   Ini Modification
'   12/07/17 CWH Initial Development
'   12/20/17 CWH Added special section for 1 key lookup
'   01/03/18 CWH Handle error 1004

'   Declarations
    Const cRoutine      As String = "XLookup"
    Dim oLo             As ListObject   'Table containing data
    Dim vKeys           As Variant      'vKeyVals internal version
    Dim sCol            As String       'Column Address Range to search
    Dim vKey            As Variant      'Key(s) to find in Column(s)
    Dim lKey            As Long         'Current key
    Dim lRow            As Long         'Found Row
    Dim lCol            As Long         'Found Column
    Dim sAddTxt         As String       'Additional Error Text
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set XLookup = Nothing

'   Check Inputs and Requisites
'   Table
    Select Case TypeName(vTable)
        Case Is = "ListObject": Set oLo = vTable
        Case Is = "Range":      Set oLo = vTable.ListObject
        Case Else:              Set oLo = ActiveSheet.Evaluate(vTable).ListObject
    End Select
'   Return Column
    If TypeName(vResult) = "Range" Then vResult = vResult.Cells(1).Value2
'   Search Keys
    If UBound(vKeyVals) = -1 Then Err.Raise DspError, , "#Key(s) required"
'   When called by VBA, ParamArrays sometimes are stuffed in the first element
    If IsArray(vKeyVals(LBound(vKeyVals))) Then _
        vKeys = vKeyVals(LBound(vKeyVals)) Else _
            vKeys = vKeyVals
    
'   Procedure
    With oLo
        If Not .DataBodyRange Is Nothing Then
        '   Just 1 key - Use Worksheet.Function because it is fastest w/1 Key
            If LBound(vKeys) = UBound(vKeys) Then
                vKey = vKeys(UBound(vKeys))
                If IsNumeric(vKey) Then vKey = CDbl(vKey)
                lRow = Application.WorksheetFunction.Match( _
                            vKey, _
                            .ListColumns(1).DataBodyRange, _
                            0)
        '   More than 1 key - Use Worksheet.Evaluation because it is fastest w/multiple keys
            Else
            '   Concatenate Key Values and Search Column Addresses
                For lKey = LBound(vKeys) To UBound(vKeys)
                    lCol = lCol + 1
                    sCol = IIf(sCol <> vbNullString, sCol & " & ", vbNullString) & _
                        .ListColumns(lCol).DataBodyRange.Address
                '   Determine Key Value
                    If TypeName(vKeys(lKey)) = "Range" Then _
                        vKey = vKey & vKeys(lKey).Value2 Else _
                            If IsDate(vKeys(lKey)) Then _
                                vKey = vKey & CLng(vKeys(lKey)) Else _
                                    vKey = vKey & vKeys(lKey)
                Next
            '   Find Row #
                lRow = .Parent.Evaluate("=Match(""" & vKey & """," & sCol & "," & "0)")
            End If
        '   Get Column #
            lCol = .ListColumns(vResult).index
        '   Return result
            Set XLookup = .ListRows(lRow).Range(lCol)
        End If
    End With
    
ErrHandler:
    If Err.Number > 0 Then
    '   Create Additional Error Text (if needed)
        Select Case Err.Number
            Case Is = 9:        sAddTxt = "Column " & vResult & " not found in " & oLo.Name
            Case Is = 13, 1004: sAddTxt = Join(vKeys, ",") & " not found in " & oLo.Name
            Case Is = 424:      sAddTxt = "Table not found"
        End Select
    '   Customize Errors based on UDF of VBA caller
        If TypeName(Application.Caller) = "Range" Then      'Called from UDF
            XLookup = CVErr(xlErrRef)
            Debug.Print cModule & "." & cRoutine & ":" & Err.Description & vbLf & sAddTxt
        Else                                                'Called from VBA (most likely)
            Select Case Err.Number
                Case Is = 13, 1004:                         'Do Nothing
                Case Else:
                    Select Case DspErrMsg(cModule & "." & cRoutine, sAddTxt)
                        Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                        Case Is = vbRetry:  Resume          'Try again
                        Case Is = vbIgnore:                 'End routine
                    End Select
            End Select
        End If
    End If
    
End Function


Public Function MLookup(ByVal vTable As Variant, _
                        ByVal vResult As Variant, _
                   ParamArray vKVP() As Variant) As Variant

'   Description:Multiple Key (any order) lookup
'   Inputs:     vTable      Data table
'               vResult     Result Column (heading or #)
'               vKVP        Keys/Value pairs to search for
'   Outputs:    Me          Success: Cell
'                           Failure: If UDF #REF Else Nothing
'   Requisites: *None
'   Example:    ?MLookup("tblCities", "Population", "Country", "USA", "State", "VA", "City", "Norfolk")

'     Date   Ini Modification
'   12/11/17 CWH Initial Development
'   01/03/18 CWH Handle error 1004

'   Declarations
    Const cRoutine      As String = "MLookup"
    Dim oLo             As ListObject   'Table containing data
    Dim oLC             As ListColumn   'Table Column
    Dim vKeys           As Variant      'vKVP internal version
    Dim sCol            As String       'Column Address Range to search
    Dim vKey            As Variant      'Key(s) to find in Column(s)
    Dim vCol            As Variant      'Column to search (1 key only)
    Dim lKey            As Long         'Current key
    Dim lRow            As Long         'Found Row
    Dim lCol            As Long         'Found Column
    Dim vVal            As Variant      'Temporary Key Value
    Dim sAddTxt         As String       'Additional Error Text
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Set MLookup = Nothing

'   Check Inputs and Requisites
'   Table
    Select Case TypeName(vTable)
        Case Is = "ListObject": Set oLo = vTable
        Case Is = "Range":      Set oLo = vTable.ListObject
        Case Else:              Set oLo = ActiveSheet.Evaluate(vTable).ListObject
    End Select
'   Return Column
    If TypeName(vResult) = "Range" Then vResult = vResult.Cells(1).Value2
'   Search Keys
    If UBound(vKVP) = -1 Then Err.Raise DspError, , "#Key(s) required"
'   When called by VBA, ParamArrays sometimes are stuffed in the first element
    If IsArray(vKVP(LBound(vKVP))) Then _
        vKeys = vKVP(LBound(vKVP)) Else _
            vKeys = vKVP
        
'   Procedure
    With oLo
        If Not .DataBodyRange Is Nothing Then
        '   Just 1 key - Use Worksheet.Function because it is fastest w/1 Key
            If UBound(vKeys) <= 2 Then
                vCol = vKeys(LBound(vKeys))
                vKey = vKeys(UBound(vKeys))
                If IsNumeric(vKey) Then vKey = CDbl(vKey)
                lRow = Application.WorksheetFunction.Match( _
                            vKey, _
                            .ListColumns(vCol).DataBodyRange, _
                            0)
        '   More than 1 key - Use Worksheet.Evaluation because it is fastest w/multiple keys
            Else
            '   Concatenate Key Values and Search Column Addresses
                For lKey = LBound(vKeys) To UBound(vKeys) Step 2
                '   Determine column name
                    If TypeName(vKeys(lKey)) = "Range" Then _
                        vCol = vKeys(lKey).Value2 Else _
                            vCol = vKeys(lKey)
                    Set oLC = oLo.ListColumns(vCol)
                '   Concatenate Column Addresses
                    sCol = IIf(sCol <> vbNullString, sCol & " & ", vbNullString) & _
                        oLC.DataBodyRange.Address
                '   Determine Key Value
                    If TypeName(vKeys(lKey + 1)) = "Range" Then _
                        vKey = vKey & vKeys(lKey + 1).Value2 Else _
                            If IsDate(vKeys(lKey + 1)) And Len(vKeys(lKey + 1)) > 3 Then _
                                vKey = vKey & CLng(vKeys(lKey + 1)) Else _
                                    vKey = vKey & vKeys(lKey + 1)
                Next
            '   Find Row #
                lRow = .Parent.Evaluate("=Match(""" & vKey & """," & sCol & "," & "0)")
            End If
        '   Get Column #
            lCol = .ListColumns(vResult).index
        '   Return result
            Set MLookup = .ListRows(lRow).Range(lCol)
        End If
    End With
    
ErrHandler:
    If Err.Number > 0 Then
    '   Create Additional Error Text (if needed)
        Select Case Err.Number
            Case Is = 9:        If lKey > UBound(vKeys) Then _
                                   sAddTxt = vResult Else _
                                       sAddTxt = vKeys(lKey)
                                sAddTxt = "Column " & sAddTxt & " not found in " & oLo.Name
            Case Is = 13, 1004: sAddTxt = Join(vKeys, ",") & " not found in " & oLo.Name
            Case Is = 424:      sAddTxt = "Table not found"
        End Select
    '   Customize Errors based on UDF of VBA caller
        If TypeName(Application.Caller) = "Range" Then      'Called from UDF
            MLookup = CVErr(xlErrRef)
            Debug.Print cModule & "." & cRoutine & ":" & Err.Description & vbLf & sAddTxt
        Else                                                'Called from VBA (most likely)
            Select Case Err.Number
                Case Is = 13, 1004:                         'Do Nothing
                Case Else:
                    Select Case DspErrMsg(cModule & "." & cRoutine, sAddTxt)
                        Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                        Case Is = vbRetry:  Resume          'Try again
                        Case Is = vbIgnore:                 'End routine
                    End Select
            End Select
        End If
    End If
    
End Function


Public Function XL_Find(ByVal vLookup_Label As Variant, _
                        ByVal vTable_Array As Variant, _
               Optional ByVal lOffset_Rows As Long = 0, _
               Optional ByVal lOffset_Cols As Long = 1, _
               Optional ByVal bExactMatch As Boolean = False, _
               Optional ByVal bMatchCase As Boolean = False) As Variant

'   Description:Find a cell relative to some value
'   Inputs:     vLookup_Label   Label to search for
'               vTable_Array    Range to search in
'               lOffset_Rows    Rows up(+)/down(-) where return value is
'                               This defaults to the same row
'               lOffset_Cols    Columns up(+)/down(-) where return value is
'                               This defaults to one column over
'               bExactMatch     Set to TRUE if you want to match exactly
'               bMatchCase      Set to TRUE if you want to match case
'   Outputs:    Me              Success:Cell Value
'                               Failure:Null
'   Example:    =XL_Find("DOT#:", "FMCSA Data")

'     Date   Ini Modification
'   03/17/11 CWH Initial Development
    
'   Declarations
    Const cRoutine      As String = "XL_Find"
    Dim oCell           As Range
    Dim lLookAt         As Long
    Dim oTable          As Range

'   Error Handling Initialization
    On Error GoTo ErrHandler
    XL_Find = Null
    
   'Make sure Table_Array is a valid range
    Set oTable = cRange(vTable_Array)
    If oTable Is Nothing Then Err.Raise DspError, "", "Table Array not found"
   
   'Set matching parameters
    bMatchCase = IIf(bExactMatch, True, bMatchCase)
    lLookAt = IIf(bExactMatch, xlWhole, xlPart)
    
   'Find the label
    Set oCell = oTable.Find(vLookup_Label, LookAt:=lLookAt, _
        MatchCase:=bMatchCase)
    If oCell Is Nothing Then Err.Raise DspError, "", _
        "'" & vLookup_Label & "' not found in '" & _
        oTable.Parent.Name & "'!" & oTable.Address
        
   'Return the value
    XL_Find = oCell.Offset(lOffset_Rows, lOffset_Cols)

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else: XL_Find = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function XL_Lookup(ByVal vTable As Variant, _
                          ByVal vResult As Variant, _
                          ByVal vKeyCol As Variant, _
                          ByVal vKeyVal As Variant, _
                     ParamArray vAddKeys() As Variant) As Variant

'   DO NOT USE: Use MLookup or XLookup instead


'   Description:Vlookup with multiple key values (no limit)
'   Note:       This is a wrapper for XL_Lookup_API.  Its job is to convert
'               "Table" to a range, "Result" to a column number, and
'               column headings in Keys() to column numbers.  For speed, use
'               XL_Lookup_API.
'   Inputs:     vTable      Table/ListObject with keys and values
'                           To query table in other workbooks, fully qualify
'                           Tabel name: "[Book3]Sheet1!Customers"
'               vResult     What to return.
'                           "Row#"  Return the row # within Table
'                           #       Return what's in this column # within table
'                                   NOTE! Won't recognize numbers as column headings
'                           Field   Return a column within table with this
'                                   column heading (slower than #)
'                           NOTE:   If vResultColumn is a #, it is
'                                   assumed to be a column #, NOT a
'                                   column heading.
'               vKeyCol     First column to search (Required)
'               vKeyVal     Value to find in first column (Required)
'               vAddKeys    (Optional) Additional column numbers or column headings
'                           to search, with each followed by a value to match
'                           NOTE:   To speed things up, use the column
'                                   that is most likely to be unique first
'                           NOTE:   You can pass an Array in the first element of
'                                   Keys().  This accomodates XL_Update and other
'                                   routines that might build an Array to pass
'                                   instead of separate values
   
'   Example:    #1  Simple Lookup (1 Key and 1 Value) returning a value
'                   Return from Chart_Types what is in the 'Value' column
'                   Where the 'Code' column = "3DPie"
'                   ?XL_Lookup("Chart_Types", "Value", "Code", "3DPie")
'   Example:    #2  Simple Lookup (1 Key and 1 Value) returning the row number
'                   Return Chart_Types' row # where the 'Code' column = "3DPie"
'                   ?XL_Lookup("Chart_Types", "Row#", "Code", "3DPie")
'   Example:    #3  Lookup with additional keys
'                   ?XL_Lookup("VRT_DDT","Value","Rule","Field","Parameter","Notes")

'     Date   Ini Modification
'   06/12/10 CWH Initial Development
'   04/11/11 CWH Err.Raise method added
'   04/16/11 CWH Now returns Row# if requested
'   07/27/11 CWH Made 999 errors non-msgbox errors
'   08/01/11 CWH Accomodated an array in ParamArray
'   10/25/11 CWH Split lookup logic out to XL_Lookup_API
'   11/17/11 CWH Withdraw support for ranges.  Supports Tables only.
'   12/30/14 CWH Return NULL if no DataBodyRange

'   Declarations
    Const cRoutine      As String = "XL_Lookup"
    Dim oLo             As ListObject   'ListObject/Table to search
    Dim v               As Variant      'Generic Variant
    Dim n               As Integer      'Generic Counter
'   XL_Lookup_API Parameters
    Dim prmData         As Range        'Data
    Dim prmResult       As Integer      'Result
    Dim prmKeyCol       As Integer      'Required Key Column
    Dim prmKeyVal       As Variant      'Required Key Value
    Dim prmKeys()       As Variant      'Keys()
    Dim vArray          As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    XL_Lookup = Null                'Assume not found

'   Check Parameters
    Set oLo = cListObject(vTable)
    If oLo Is Nothing Then Err.Raise LogError, , "Table not found"
    
'   Procedures
    If Not oLo.DataBodyRange Is Nothing Then
        Set prmData = oLo.DataBodyRange
    '   prmResult column
        prmResult = 0
        If UCase(vResult) <> "ROW#" Then
            prmResult = cColumnIndex(oLo, vResult)
            If prmResult = 0 Then Err.Raise DspError, , "#ERROR:Result Column not found"
        End If
        prmKeyVal = vKeyVal
    '   prmKeyCol column
        prmKeyCol = cColumnIndex(oLo, vKeyCol)
        If prmKeyCol = 0 Then Err.Raise DspError, , "#ERROR:Key Column not found"
        If IsMissing(vAddKeys()) Then
            v = XL_Lookup_API(prmData, prmResult, prmKeyCol, prmKeyVal)
        Else
            If IsArray(vAddKeys(0)) Then vArray = vAddKeys(0) Else vArray = vAddKeys
        '   Set AddKeys() to Column Numbers and Values
            ReDim prmKeys(UBound(vArray))
            For n = LBound(vArray) To UBound(vArray) Step 2
                prmKeys(n) = cColumnIndex(oLo, vArray(n))
                If n > LBound(vArray) And prmKeys(n) = 0 Then Err.Raise DspError, , _
                        "#ERROR:Key '" & CStr(vArray(n)) & "' not found"
                prmKeys(n + 1) = vArray(n + 1)
            Next n
            v = XL_Lookup_API(prmData, prmResult, prmKeyCol, prmKeyVal, prmKeys())
        End If
        If Not IsError(v) Then XL_Lookup = v
    End If
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = LogError: Debug.Print Err.Description
        Case Else: XL_Lookup = cRoutine & "-" & Err.Number & ": " & Err.Description
    End Select

End Function


Public Function XL_Lookup_API(ByVal oData As Range, _
                              ByVal iResult As Integer, _
                              ByVal iKeyCol As Integer, _
                              ByVal vKeyVal As Variant, _
                     Optional ByVal vAddKeys As Variant) As Variant

'   DO NOT USE: Use MLookup or XLookup instead

'   Description:Internal routine for XL_Lookup
'   Notes:      This is designed for speed.  It is assumed this is
'               only called from code with parameters properly set.
'               In particular Keys must contain an array (see example)
'   Inputs:     oData       Range with keys and values
'               iResult     What to return.
'                           0 = Return row # within Table
'                           # = Return what is in this column #
'               iKeyCol     First column to search (Required)
'               vKeyVal     Value to find in first column (Required)
'               lAddKeys    Additional column #s to search followed by values to match (Optional)
'   Example:    #1 - Simple Lookup (1 Key and 1 Value)
'               ?XL_Lookup_API(cRange("Chart_Types"), 3, 1, "3DPie")
'   Example:    #2 - Lookup w/additional keys passed in a predefined array
'               XL_Lookup = XL_Lookup_API(prmData, prmResult, prmCol, prmVal, prmKeys())
'   Example:    #3 - Lookup w/additional keys passed in an 'ad-hoc' array
'               ?XL_Lookup_API(cRange("VRT_DDT"),3,1,"Field", Array(2,"Notes")))

'     Date   Ini Modification
'   10/25/11 CWH Initial Development
'   11/23/11 CWH Replaced FIND with MATCH
'   04/25/12 CWH Added processing to handle Dates better. Also changed
'                Application.WorksheetFunction.Match to Application.Match
'   09/11/12 CWH Removed iLower and iUpper
'   12/26/14 CWH Handled Key in string variable with numeric value

'   Declarations
    Const cRoutine      As String = "XL_Lookup_API"
    Dim oCol            As Range        'Column to Match/Search
    Dim lRow            As Long         'Current Row
    Dim vArray          As Variant      'vAddKeys
    Dim bMatch          As Boolean      'Match found Flag
    Dim n               As Integer      'Loop Counter
    Dim v               As Variant      'Generic Result

'   Error Handling Initialization
    On Error GoTo ErrHandler
    XL_Lookup_API = Null  'Assume not found

'   Procedure
    Set oCol = oData.Columns(iKeyCol)
    If Not IsMissing(vAddKeys) Then
        If IsArray(vAddKeys(0)) Then vArray = vAddKeys(0) Else vArray = vAddKeys
    End If
   
    Do
    '   Position to first/next possible candidate
        If IsDate(vKeyVal) Then
            lRow = Application.Match(CLng(CDate(vKeyVal)), oCol, 0)
        Else
            v = Application.Match(vKeyVal, oCol, 0)
            If IsError(v) Then v = Application.Match( _
                IIf(TypeName(vKeyVal) = "String", Val(vKeyVal), CStr(vKeyVal)), _
                oCol, 0)
            lRow = IIf(IsError(v), 0, CLng(v))
        End If
        If lRow <> 0 Then
            lRow = oCol.ROW - oData.ROW + lRow
        '   If something found and additional keys, check them
            bMatch = True                   'Assume the rest is good
            If Not IsMissing(vAddKeys) Then
                For n = LBound(vArray) To UBound(vArray) Step 2
                    If UCase(oData.Cells(lRow, vArray(n))) <> _
                       UCase(vAddKeys(n + 1)) Then
                        bMatch = False      'Assumption was bad
                        Exit For
                    End If
                Next n
            End If
        End If
        With oData.Columns(iKeyCol)
            If Not bMatch And oData.Rows.Count > lRow Then _
                Set oCol = .Offset(lRow, 0).Resize(.Rows.Count - lRow, 1)
        End With
        
'   If something didn't match and not at end, look again.
    Loop Until bMatch Or lRow = 0 Or lRow >= oData.Rows.Count
    
    If bMatch And iResult = 0 Then XL_Lookup_API = IIf(lRow > 0, lRow, Null)
    If bMatch And iResult > 0 Then XL_Lookup_API = oData.Cells(lRow, iResult).Text
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 13, 1004: 'No match
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Public Function XL_Update(ByVal vTable As Variant, _
                          ByVal vColumn As Variant, _
                          ByVal vValue As Variant, _
                          ByVal vKeyCol As Variant, _
                          ByVal vKeyVal As Variant, _
                     ParamArray vAddKeys() As Variant) As Variant

'   DO NOT USE - Use UpdXLT instead

'   Description:Post a result to a table
'   Inputs:     vTable      Table/ListObject to update
'                           To reference tables in other workbooks, fully qualify
'                           tabel name. ex: "[Book3]Sheet1!Customers"
'               vColumn     Column to update
'                           #:      Update what's in this column # within table
'                                   NOTE! Won't recognize numbers as column headings
'                           Field:  Update a column within table with this
'                                   column heading (slower than #)
'                           NOTE:   If vColumn is a #, it is assumed to be a column #,
'                                   NOT a column heading.
'               vValue      Value to put in Result
'               vKeyCol     First column to search (Required)
'               vKeyVal     Value to find in first column (Required)
'               vAddKeys    (Optional) Additional column numbers or column headings
'                           to search, with each followed by a value to match
'                           NOTE:   To speed things up, use the column
'                                   that is most likely to be unique first
'                           NOTE:   You can pass an Array in the first element of
'                                   Keys().  This accomodates XL_Update and other
'                                   routines that might build an Array to pass
'                                   instead of separate values
'   Outputs:    Me          Success/Failure
'   Example:    This updates the cell in the column labeled
'               "Budget Amount" from an XL range called "DET"
'               with the value 100 where a row contains:
'                   "Hardware" under column labeled "Budget Item" &
'                   "SAP" under column labeled "Project" &
'                   "Capital" under column labeled "Expense Type"

'               Dim cAmount as Currency
'               Dim vResult as Variant
'               vResult = XL_Update(Range("Data"), "Budget Amount", 100, _
'                               "Budget Item", "Hardware", _
'                               "Project", "SAP", _
'                               "Expense Type", "Capital")
'               If not isNull(vResult) then cAmount = cCur(vResult)

'     Date   Ini Modification
'   08/01/11 CWH Initial Development
'   11/17/11 CWH No longer works with ranges.  Tables only.

'   Declarations
    Const cRoutine      As String = "XL_Update"
    Dim oLo             As ListObject   'Table
    Dim lCol            As Long
    Dim lRow            As Long         'Row to update
    Dim v               As Variant      'Temporary Result
    Dim vArray()        As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    XL_Update = Failure     'Assume not found

'   Check Inputs and Requisites
    Set oLo = cListObject(vTable)
    If oLo Is Nothing Then Err.Raise DspError, , "Table not found"

'   Procedure
    If IsMissing(vAddKeys) Then
        v = XL_Lookup(oLo, "Row#", vKeyCol, vKeyVal)
    Else
        If IsArray(vAddKeys(0)) Then vArray = vAddKeys(0) Else vArray = vAddKeys
        v = XL_Lookup(oLo, "Row#", vKeyCol, vKeyVal, vArray)
    End If
    
    If Not IsNull(v) Then
        lRow = CLng(v)
        lCol = cColumnIndex(oLo, vColumn)
        If lCol > 0 Then
            If Left(vValue, 1) = "=" Then
                oLo.ListRows(lRow).Range(lCol).FormulaR1C1 = vValue
            Else
                oLo.ListRows(lRow).Range(lCol) = vValue
            End If
        End If
    End If
    
    XL_Update = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function XL_UpdAdd(ByVal vTable As Variant, _
                          ByVal vColumn As Variant, _
                          ByVal vValue As Variant, _
                          ByVal vKeyCol As Variant, _
                          ByVal vKeyVal As Variant, _
                     ParamArray vAddKeys() As Variant) As Boolean
    Stop    'Use UpdXLT instead
End Function


Public Function UpdXLT(ByVal Table As ListObject, _
                       ByVal KeyCols As Variant, _
                       ByVal KeyVals As Variant, _
              Optional ByVal UpdCols As Variant, _
              Optional ByVal UpdVals As Variant, _
              Optional ByVal AddOnly As Boolean = False) As Boolean

'   Description:Update or, if keys not found, add row to a table
'   Inputs:     Table       Table/ListObject to update
'               KeyCols     Key columns array
'               KeyVals     Key values array
'               UpdCols     Columns to update array
'               UpdVals     Values array
'               AddOnly     If TRUE, do not update existing records
'   Outputs:    Me          Success/Failure
'   Requisites:

'   Example:    ?UpdXLT(Table:=[tblMCS].ListObject, _
                        KeyCols:=Array("Tab","Group","Caption"), _
                        KeyVals:=Array("Make", "Setup", "Rest Make"), _
                        UpdCols:=Array("Control", "Values", "Setting"), _
                        UpdVals:=Array("Button", "RstPrjUI", ""))
'               ?UpdXLT(Table:=[tblWCS].ListObject, _
                        KeyCols:=1, _
                        KeyVals:="Test", _
                        UpdCols:=Array("Start State", "Clear", "DET"), _
                        UpdVals:=Array("Start", "Clear", "test 1"))

'     Date   Ini Modification
'   09/25/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "UpdXLT"
    Dim vKVP()          As Variant      'Key Value Pairs Array
    Dim oLR             As ListRow      'Table Row
    Dim n               As Long         'Generic Counter
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    UpdXLT = Failure

'   Check Inputs and Requisites
    If Not IsArray(KeyCols) Then KeyCols = Array(KeyCols)
    If Not IsArray(KeyVals) Then KeyVals = Array(KeyVals)
    If Not IsMissing(UpdCols) Then
        If Not IsArray(UpdCols) Then UpdCols = Array(UpdCols)
        If Not IsArray(UpdVals) Then UpdVals = Array(UpdVals)
    End If
    
'   Initialize Variables
    Set v = Nothing
    ReDim vKVP(2 * UBound(KeyCols) + 1)

'   Procedure
    With Table
        If AddOnly Or .DataBodyRange Is Nothing Then
            Set oLR = .ListRows.Add
        Else
        '   Find Table Row
            If Not .DataBodyRange Is Nothing Then
                For n = LBound(KeyCols) To UBound(KeyCols)
                    vKVP(n * 2) = KeyCols(n)
                    vKVP(n * 2 + 1) = KeyVals(n)
                Next n
                Set v = MLookup(Table, 1, vKVP)
                If v Is Nothing Then _
                    Set oLR = .ListRows.Add Else _
                        Set oLR = .ListRows(v.ROW - .HeaderRowRange.ROW)
            End If
        End If
    '   Add Keys to new row
        If v Is Nothing Then
            For n = LBound(KeyCols) To UBound(KeyCols)
                oLR.Range(.ListColumns(KeyCols(n)).index) = KeyVals(n)
            Next
        End If
    '   Add Other values
        If Not IsMissing(UpdCols) Then
            For n = LBound(UpdCols) To UBound(UpdCols)
                oLR.Range(.ListColumns(UpdCols(n)).index) = UpdVals(n)
            Next
        End If
    End With
    
    UpdXLT = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004, 424: Resume Next            'No Cells Selected
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



Attribute VB_Name = "modOrg"
'   Version:    12/07/17

'   Save As:    modOrg
'   Description:Org/Hierarchical Chart
'   Requisites: Modules     modGeneral
'               Forms       frmOrgChart (Only if using CrtOrgChtUI)
'                           frmMsg      (Only if using CrtOrgChtUI)

'     Date   Ini Modification
'   01/24/15 CWH Initial Development
'   04/06/15 CWH Added protected worksheet checking
'   02/09/17 CWH Fixed bug reported by Robert Hoffower
'   08/07/17 CWH Updated to newer routines in modGeneral
'   09/28/17 CWH See AddNod
'   12/07/17 CWH Modified StartUp to use new clsAddIn

Option Explicit

Private Const cModule       As String = "modOrg"

Type AddNodeReturn
    oNode       As Shape
    oFirstChild As Shape
    oLastChild  As Shape
End Type

'   Auto Open
Public Sub StartUp()

'   Description:Prepare Workbook for use (Called by modRI.IniRbnUI)
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: Routines:   modGeneral.SavCLs
'               Classes:    clsAddIn
'   Example:    (Event Handler)

'     Date   Ini Modification
'   03/10/15 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "StartUp"
    Dim oAddIn          As clsAddIn

'   Error Handling Initialization
    On Error GoTo ErrHandler

'   Procedure
    Application.EnableEvents = True
    Set oAddIn = New clsAddIn
    SavCls "clsAddIn:" & ThisWorkbook.Name, oAddIn
            
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 1004: Resume Next
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Sub


'   User Interface Routines
Public Function CrtOrgChtUI(Optional ByRef Control As IRibbonControl) As Boolean
Attribute CrtOrgChtUI.VB_Description = "Create an employee organization hierarchy chart from tblData"
Attribute CrtOrgChtUI.VB_ProcData.VB_Invoke_Func = " \n14"

'   Description:Ask a bunch of questions and then call AddNode
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: Routines:   me.AddNode
'   Example:    CrtOrgChtUI

'     Date   Ini Modification
'   01/23/15 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "CrtOrgCht"
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Check Inputs and requisites
    If ActiveSheet.ProtectContents Then _
        Err.Raise DspError, , "Unprotect worksheet first"
    
'   Procedure
    frmOrgChart.Display

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Public Function GrpOrgChtUI(Optional ByRef Control As IRibbonControl) As Boolean

'   Description:Group all nodes
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: Routines        modGeneral.RegEx
'                               modGeneral.IsProtected
'   Example:    GrpOrgChtUI

'     Date   Ini Modification
'   01/23/15 CWH Initial Development
'   08/04/17 CWH Used Dictionary to purge any duplicate shapes

'   Declarations
    Const cRoutine      As String = "GrpOrgChtUI"
    Dim oWks            As Worksheet    'Active Worksheet
    Dim oDic            As Object       'Shape's Dictionary
    Dim oShape          As Shape        'Current Shape
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Check Inputs and requisites
    Set oWks = ActiveSheet
    If modGeneral.IsProtected(oWks) Then _
        Err.Raise DspError, , "Unprotect worksheet first"
        
'   Initialize Variables
    Set oDic = CreateObject("Scripting.Dictionary")

'   Procedure
'   Collect Distinct Shapes
    For Each oShape In oWks.Shapes
        If modGeneral.RegEx(oShape.Name, "^Node:|^Conn:", rxTest) Then
            If Not oDic.Exists(oShape.Name) Then _
                oDic(oShape.Name) = oShape.ID Else _
                    oShape.Delete
        End If
    Next
'   Group Shapes
    oWks.Shapes.Range(oDic.Keys()).Group.Name = "Node:Group" & oWks.Shapes.Count

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function DelOrgChtUI(Optional ByRef Control As IRibbonControl) As Boolean

'   Description:Ask a bunch of questions and then call AddNode
'   Inputs:     *None
'   Outputs:    *None
'   Requisites: Routines:   me.AddNode
'   Example:    CrtOrgChtUI

'     Date   Ini Modification
'   01/23/15 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "DelOrgChtUI"
    Dim v               As Variant
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Check Inputs and requisites
    If ActiveSheet.ProtectContents Then _
        Err.Raise DspError, , "Unprotect worksheet first"

'   Procedure
    v = frmMsg.Display(Prompt:="Delete all nodes from current worksheet?", _
                       Buttons:=vbOKCancel, _
                       Title:="Delete Org Chart")
    If v = vbOK Then
        For Each v In ActiveSheet.Shapes
            If modGeneral.RegEx(v.Name, "^Node:|^Conn:", rxTest) Then v.Delete
        Next
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function



'   Public non-UI routines
Public Function AddNod(ByVal sNodeID As String, _
                       ByVal sParentID As String, _
                       ByVal oData As ListObject, _
                       ByVal lNodes As Long, _
                       ByVal lParents As Long, _
                       ByVal oWks As Worksheet, _
                       ByVal sNodeText As String, _
                       ByVal lTop As Long, _
                       ByVal lLeft As Long, _
                       ByVal lHeight As Long, _
                       ByVal lWidth As Long, _
                       ByVal lSeparation As Long, _
              Optional ByVal oParent As Shape, _
              Optional ByVal lStyle = 1) As AddNodeReturn

'   Description:Create Org Chart
'   Inputs:     sNodeID     Node's ID
'               oData       Data (must be an XL Table)
'               oNodes      Range in Data containing Node ID's (Employee IDs)
'               oParents    Range in Data containing Parent ID's for eacy Node
'               oWks     Chart's worksheet
'               sNodeText   Instructions for adding text to nodes
'               lTop        Parent Shape's Top (Y) coordinate
'               lLeft       Parnet Shape's Left (X) coordinate
'               lHeight     All Shapes' Height
'               lWidth      All Shapes' Widht
'               lSeparation Horizontally separation between shapes
'               oParent     Node's Parent Shape
'               lStyle      Top/Down, Left/Right, Outline Orientation
'   Outputs:    Me          Last Shape created by this function call
'   Requisites: Function:   modGeneral.Exists
'                           me.GetNodeTxt
'                           me.CrtNode
'   Example:    Run "AddNode", 2, [tblEmp].ListObject, [tblEmp[EmployeeID]], [tblEmp[ReportsTo]], _
                                Activesheet, "LastName,FirstName", [G10].top, [G10].left, 55, 125, 20

'     Date   Ini Modification
'   01/23/15 CWH Initial Programming
'   02/09/17 CWH Checked for shape collisions
'   08/04/17 CWH Leveraged additions to modGeneral to steamline code
'   09/28/17 CWH Added oStack to stop recursive loops
                
'   Declarations
    Const cRoutine      As String = "AddNode"
    Static oPCD         As Object   'Parent/Child Index
    Static oStack       As Object   'Routine's Stack
    Dim oNode           As Shape    'Node's Shape
    Dim oChild          As AddNodeReturn
    Dim sChildID        As String   'Node's Child ID
    Dim oRange          As Range    'Found Range
    Dim oArea           As Range    'oRange's Area
    Dim oRow            As Range    'oArea's Row
    Dim oLR             As ListRow  'Found Row
    Dim oFirst          As Shape    'First Child's Shape
    Dim oLast           As Shape    'Last Child's Shape
    Dim oShape          As Shape    'Worksheet's Shape (for collisions)
    Dim sText           As String   'Shape's Text
    Dim sID             As String   'Node's Shape ID
    Dim v               As Variant
    Dim lRow            As Long
    Dim lChild          As Long     'Child Loop Counter
    
    Dim sChild          As String
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Initialize variables
    Set oFirst = Nothing: Set oLast = Nothing
    sText = sNodeID
    
'   Procedure
    DoEvents
'   Top Level Node
    If sParentID = vbNullString Then
        Set oStack = CreateObject("Scripting.Dictionary")
        Set oPCD = CrtPCD(oData, lParents, lNodes)
    '   Look for parent in nodes
        v = XL_Lookup(oData, "Row#", lNodes, sNodeID)
        If IsNull(v) Then       'Not in Nodes
            sText = sNodeID
        Else                    'In Nodes
            lRow = CLng(v)
            sParentID = oData.ListRows(lRow).Range(lParents)
            sNodeID = oData.ListRows(lRow).Range(lNodes)
            sText = GetNodTxt(oPCD(sParentID)(sNodeID), sNodeText)
        End If
'   Lower Level Nodes
    Else
        sText = GetNodTxt(oPCD(sParentID)(sNodeID), sNodeText)
    End If
    
    If Not oStack.Exists(sNodeID) Then
    '   Add to Stack
        Debug.Print sNodeID
        If sChildID = "frmInputBox" Then Stop
        oStack(sNodeID) = oStack.Count
    
    
    '   Create Node
        Set oNode = CrtNode(oWks:=oWks, _
                            sID:=sID, _
                            sText:=sText, _
                            lTop:=lTop, _
                            lLeft:=lLeft, _
                            lHeight:=lHeight, _
                            lWidth:=lWidth, _
                            oParent:=oParent, _
                            lStyle:=lStyle)
        Select Case lStyle
            Case Is = 1 'Top/Down
                lTop = oNode.Top + oNode.Height + lSeparation * 2 'oNode.Height \ 2
                lLeft = oNode.Left
            Case Is = 2 'Left/Right
                lTop = oNode.Top
                lLeft = oNode.Left + oNode.Width + lSeparation * 2 'oNode.Width \ 2
            Case Is = 3 'Outline
                lTop = oNode.Top + oNode.Height + lSeparation * 2 'oNode.Height \ 2
                lLeft = oNode.Left + oNode.Width + lSeparation * 2 '* 0.75
        End Select
        
    '   Add Child nodes
        Set oLast = oNode: Set oFirst = oNode
    '   Loop through child nodes
        If oPCD.Exists(sNodeID) Then
            For lChild = 0 To oPCD(sNodeID).Count - 1
                sChildID = oPCD(sNodeID).Keys()(lChild)
            '   NOTE! Recursive call - Add each Child's Children and so forth
                oChild = AddNod(sNodeID:=sChildID, _
                                 sParentID:=sNodeID, _
                                 oData:=oData, _
                                 lNodes:=lNodes, _
                                 lParents:=lParents, _
                                 oWks:=oWks, _
                                 sNodeText:=sNodeText, _
                                 lTop:=lTop, _
                                 lLeft:=lLeft, _
                                 lHeight:=lHeight, _
                                 lWidth:=lWidth, _
                                 lSeparation:=lSeparation, _
                                 oParent:=oNode, _
                                 lStyle:=lStyle)
            '   Connect Child to Parent
                If Not oChild.oNode Is Nothing Then CnnNode oChild.oNode, oNode, lStyle
            '   Check for collisions and adjust accordingly
                If Not oChild.oNode Is Nothing Then
                    For Each oShape In oWks.Shapes
                        If oChild.oLastChild.Name <> oShape.Name And Not oShape.Name Like "Conn:*" Then
                           If Collided(oChild.oLastChild, oShape) Then
                                Select Case lStyle
                                    Case Is = 1 'Top/Down
                                        oChild.oLastChild.Left = oShape.Left + oShape.Width + lSeparation
                                    Case Is = 2 'Left/Right
                                        oChild.oLastChild.Top = oShape.Top + oShape.Height + lSeparation
                                    Case Is = 3 'Outline
                                        oChild.oLastChild.Top = oShape.Top + oShape.Height + lSeparation
                                End Select
                            End If
                        End If
                    Next
                End If
            '   Prepare for next shape
                If Not oChild.oNode Is Nothing Then
                    Select Case lStyle
                        Case Is = 1 'Top/Down
                            lLeft = oChild.oLastChild.Left + oChild.oLastChild.Width + lSeparation
                        Case Is = 2 'Left/Right
                            lTop = oChild.oLastChild.Top + oChild.oLastChild.Height + lSeparation
                        Case Is = 3 'Outline
                            lTop = oChild.oLastChild.Top + oChild.oLastChild.Height + lSeparation
                    End Select
                    Set oLast = oChild.oNode
                    If oFirst.Name = oNode.Name Then Set oFirst = oChild.oNode
                End If
            Next
        End If
    '   Center Parent's position to children
        Select Case lStyle
            Case Is = 1 'Top/Down
                oNode.Left = oFirst.Left + (oLast.Left - oFirst.Left) \ 2
            Case Is = 2 'Left/Right
                oNode.Top = oFirst.Top + (oLast.Top - oFirst.Top) \ 2
            Case Is = 3 'Outline
        End Select
        
        Set AddNod.oNode = oNode
        Set AddNod.oFirstChild = oFirst
        Set AddNod.oLastChild = oLast
    '   Remove From Stack
        oStack.Remove sNodeID
    End If
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
                
End Function


'   Private Routines
Private Function CrtPCD(ByVal oTable As ListObject, _
                        ByVal lParents As Long, _
                        ByVal lChildren As Long) As Object

'   Description:Create Parent/Child Index over entire Table
'   Inputs:     oTable      Table containing Parent's and Children
'               lParents    oTable's Parent Column
'               lChildren   oTable's Children Column
'   Outputs:    Me          Success: PDC
'                           Failure: Nothing
'   Requisites: *None
'   Example:    Set oPDC = CrtPDC("Inquiry", [tblBOMs].Listobject, 1, 2)

'     Date   Ini Modification
'   08/07/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "CrtPCD"
    Dim oParents        As Object       'Parents Dictionary
    Dim oChildren       As Object       'Children Dictionary
    Dim oAttributes     As Object       'Parent/Child Attributes
    Dim sParent         As String       'Parent ID
    Dim sChild          As String       'Child ID
    Dim lOuter          As Long         'Outer Loop Counter
    Dim lInner          As Long         'Inner Loop Counter
    Dim lHdr            As Long         'Header Loop Counter
    Dim vData           As Variant      'Table's cell values in an array
    Dim vHdrs           As Variant      'Table's Headers in an Array
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Initialize Variables
    Set oParents = CreateObject("Scripting.Dictionary")
    vData = oTable.DataBodyRange
    vHdrs = oTable.HeaderRowRange
    
'   Procedure
    For lOuter = LBound(vData) To UBound(vData)
        sParent = CStr(vData(lOuter, lParents))
        If Not oParents.Exists(sParent) Then
            Set oChildren = CreateObject("Scripting.Dictionary")
            For lInner = lOuter To UBound(vData)
                If vData(lInner, lParents) = vData(lOuter, lParents) Then
                    Set oAttributes = CreateObject("Scripting.Dictionary")
                    For lHdr = LBound(vHdrs, 2) To UBound(vHdrs, 2)
                        oAttributes(vHdrs(1, lHdr)) = vData(lInner, lHdr)
                    Next
                    sChild = CStr(vData(lInner, lChildren))
                    Set oChildren(sChild) = oAttributes
                End If
            Next
            Set oParents(sParent) = oChildren
        End If
    Next
    Set CrtPCD = oParents

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Private Function CrtNode(ByVal oWks As Worksheet, _
                         ByVal sID As String, _
                         ByVal sText As String, _
                         ByVal lTop As Long, _
                         ByVal lLeft As Long, _
                         ByVal lHeight As Long, _
                         ByVal lWidth As Long, _
                Optional ByVal oParent As Shape = Nothing, _
                Optional ByVal lStyle As Long = 1) As Shape

'   Description:Create a Node's shape
'   Inputs:     oWks        Chart's Worksheet
'               sID         Shape's ID
'               lTop        Shape's Top (Y) coordinate
'               lLeft       Shape's Left (X) coordinate
'               oParent     Shape's Parent (Employee's boss)
'               lStyle      Top/Down, Left/Right, Outline Orientation
'   Outputs:    Me          Shape created by this function call
'   Requisites: *None
'   Example:    See AddNode

'     Date   Ini Modification
'   01/23/15 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "CrtNode"
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Procedure
    Set CrtNode = oWks.Shapes.AddShape(Type:=msoShapeRoundedRectangle, _
                                       Left:=lLeft, Top:=lTop, _
                                       Width:=lWidth, Height:=lHeight)
    With CrtNode
        .Name = "Node:" & oWks.Shapes.Count
        With .TextFrame2.TextRange
            .Characters.Text = sText
            With .ParagraphFormat
                .FirstLineIndent = 0
                .Alignment = msoAlignLeft
                .WordWrap = msoTrue
            End With
        End With
    End With

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Private Function CnnNode(ByVal oNode As Shape, _
                         ByVal oParent As Shape, _
                Optional ByVal lStyle As Long = 1) As Boolean

'   Description:Connect Nodes
'   Inputs:     oNode       Child Node's Shape
'               oParent     Parent Node's Shape
'               lStyle      Top/Down, Left/Right, Outline Orientation
'   Outputs:    Me          Success/Failure
'   Requisites: Routines    modGeneral.Exists
'   Example:    See CrtNode

'     Date   Ini Modification
'   01/23/15 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "CnnNode"
    Dim oWks            As Worksheet        'Shape's Worksheet
    Dim sName           As String           'Shape's Name
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    CnnNode = Failure
    
'   Procedure
    Set oWks = oNode.Parent
    sName = "Conn:" & Replace(oParent.Name, "Node:", "") & _
                "," & Replace(oNode.Name, "Node:", "")
    If Not Exists(oWks.Shapes, sName) Then
        With oNode.Parent.Shapes.AddConnector(msoConnectorElbow, 1, 1, 1, 1)
            .ConnectorFormat.BeginConnect oParent, Choose(lStyle, 3, 4, 3)
            .ConnectorFormat.EndConnect oNode, Choose(lStyle, 1, 2, 2)
            .Name = sName
        End With
    End If

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function


Private Function Collided(ByVal oShape1 As Shape, _
                          ByVal oShape2 As Shape) As Boolean

'   Description:Determine if 2 shapes have collided (Intersect)
'   Inputs:     oShape1     First Shape
'               oShape2     Second Shape
'   Outputs:    me          True/False
'   Requisites: *None
'   Notes:      https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
'   Example:    ?Collision(ActiveChart.Shapes(1), ActiveChart.Shapes(2))

'     Date   Ini Modification
'   01/30/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "Collided"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    Collided = False
    
'   Procedure
    Collided = oShape1.Left <= oShape2.Left + oShape2.Width And _
               oShape1.Left + oShape1.Width >= oShape2.Left And _
               oShape1.Top <= oShape2.Top + oShape2.Height And _
               oShape1.Height + oShape1.Top >= oShape2.Top
           
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
        
End Function


Private Function GetNodTxt(ByVal oPCE As Object, _
                           ByVal sNodeText As String) As String

'   Description:Determine Node Text for Shape
'   Inputs:     oPCE        Parent/Child Entry
'               sNodeText   String containing Column headings
'   Outputs:    Me          Node's Text
'   Requisites: *None
'   Example:    Set oPCR = modOrg.CrtPCD([tblEmp].Listobject, 17, 1)
'               ?modOrg.GetNodTxt(oPCD(1)(4), "FirstName" & "|1a|" & "LastName")

'     Date   Ini Modification
'   08/07/17 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetNodTxt"
    Dim vLine           As Variant      'Columns in one line
    Dim vCol            As Variant      'A single column
 
'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Initialize Variables

'   Procedure
    For Each vLine In Split(sNodeText, "|14|")
        For Each vCol In Split(vLine, "|1a|")
            GetNodTxt = GetNodTxt & oPCE(Application.Clean(CStr(vCol))) & " "
        Next
        GetNodTxt = GetNodTxt & vbLf
    Next

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function
Attribute VB_Name = "modRI"
'   Version:    01/03/18
'   Save As:    modRI
'   Description:Ribbon Interface
'   Requisites: tblMCS

'     Date   Ini Modification
'   08/25/14 CWH Initial Development
'   09/22/14 CWH Add UI suffix to callback routines for convention
'   10/07/14 CWH Added ComboBox UI elements
'   10/31/14 CWH cRoutine replaces sRoutine
'   11/28/14 CWH Added Wrappers
'   12/10/14 CWH Added CCC
'   12/30/14 CWH Documentation goes in its own folder now
'   05/20/15 CWH Made Dsp* parameter optional
'   09/01/15 CWH Added DspWWWUI
'   11/14/15 CWH Leveraged MCS Setting for Guide and Web Site
'   02/03/16 CWH Added riSaveItems, riGetItemID, SavCtlLstUI
'   04/14/16 CWH DspPDFUI now supports web documentation
'   08/12/16 CWH Added ability to set control labels
'   09/06/16 CWH 64 bit PtrSafe
'   09/08/16 CWH Made sure tblMCS comes from this workbook
'   12/07/16 CWH Added handling error# -2147467260
'   02/10/17 CWH See IniRbnUI
'   04/25/17 CWH Leveraging tblMCS to set control values and lists
'   06/15/17 CWH Added ActTabUI
'   08/10/17 CWH Added http:// to URL's missing it.
'   01/03/18 CWH See DspPDFUI and DspWWWUI

Option Explicit
Option Private Module

Private Const cModule       As String = "modRI"

Public Enum riRequestTypes
    riSave
    riSaveLabel
    riSaveItems
    riGet
    riGetLabel
    riGetItemCount
    riGetItemID
    riGetItemLabel
    riSet
    riSetLabel
    riSetItems
    riActivateTab
    [_ri]
End Enum

Public Enum riMCSColumns
    riTab = 1
    riGroup = 2
    riCaption = 3
    riControl = 4
    riCallBack = 5
    riValues = 6
    riSetting = 7
    [_ri]
End Enum

#If VBA7 And Win64 Then
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
#Else
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
#End If

 
 
Private Function SavObjRef(ByRef oObj As Object, _
                           ByVal sName As String) As Boolean
'   References:
'   Rory Archibald: http://www.mrexcel.com/forum/excel-questions/518629-how-preserve-regain-id-my-custom-ribbon-ui.html
'   Werner Geiger:
'   http://code.ecomerc.com/Articles/VBA_Ribbon/
'   Store an object reference
    ThisWorkbook.Names.Add Name:=sName, RefersTo:=ObjPtr(oObj)
End Function
 
 
Private Function GetObjRef(ByVal sName As String) As Object
'   References:
'   Rory Archibald: http://www.mrexcel.com/forum/excel-questions/518629-how-preserve-regain-id-my-custom-ribbon-ui.html
'   Werner Geiger:
'   http://code.ecomerc.com/Articles/VBA_Ribbon/
'   Retrieve the object reference
    Dim oObj As Object
    If Exists(ThisWorkbook.Names, sName) Then
        CopyMemory oObj, CLng(Evaluate(sName)), 4
        Set GetObjRef = oObj
    End If
End Function


Public Sub IniRbnUI(Ribbon As IRibbonUI)

'   Description:Initialize Ribbon Interface
'   Inputs:     Ribbon      Ribbon Object
'   Outputs:    *None
'   Requisites: *None
'   Example:    *None

'     Date   Ini Modification
'   08/25/14 CWH Initial Development
'   02/10/17 CWH Added call to "Startup"

'   Declarations
    Const cRoutine      As String = "RbnInt"

'   Error Handling Initialization
    On Error GoTo ErrHandler
    
'   Procedure
    Debug.Print cModule & ":" & cRoutine
    SavObjRef Ribbon, "iRibbonUI"
    RbnInt lRequest:=riSave, vValue:="Ribbon", oRibbonUI:=Ribbon, sControl:="Ribbon"
    Application.Run "StartUp"

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 424                               'Do Nothing
        Case Is = 1004: Resume Next                 'Application.Run failed
        Case Is = 91                                'oRibbonControl destroyed
            MsgBox Prompt:="Save/Export your project, close Excel, and restart", _
                   Buttons:=vbCritical, _
                   Title:="Ribbon Interface Failure"
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Sub

Public Sub GetValueUI(ByRef Control As IRibbonControl, _
                      ByRef ReturnValue As Variant)
    ReturnValue = GetCtlValUI(Control.Tag)
    RbnInt lRequest:=riGet, vValue:=ReturnValue, oRibbonControl:=Control
End Sub

Public Sub GetLabelUI(ByVal Control As IRibbonControl, _
                      ByRef ReturnValue As Variant)
    ReturnValue = GetCtlLblUI(Control.Tag)
    RbnInt lRequest:=riGetLabel, vValue:=ReturnValue, oRibbonControl:=Control
End Sub

Public Sub GetItemCountUI(ByVal Control As IRibbonControl, _
                          ByRef ReturnValue As Variant)
    ReturnValue = GetCtlValUI(Control.Tag)
    RbnInt lRequest:=riGetItemCount, vValue:=ReturnValue, oRibbonControl:=Control
End Sub

Public Sub GetItemIDUI(ByVal Control As IRibbonControl, _
                          ByVal index As Integer, _
                          ByRef ReturnValue As Variant)
    RbnInt lRequest:=riGetItemLabel, vValue:=ReturnValue, oRibbonControl:=Control, iIndex:=index
End Sub

Public Sub GetItemLabelUI(ByVal Control As IRibbonControl, _
                          ByVal index As Integer, _
                          ByRef ReturnValue As Variant)
    ReturnValue = GetCtlValUI(Control.Tag & ":Label")
    RbnInt lRequest:=riGetItemLabel, vValue:=ReturnValue, oRibbonControl:=Control, iIndex:=index
End Sub

Function GetMCS(ByVal sCaption As String, _
                ByVal lColumn As riMCSColumns) As Variant

'   Description:Get a value from tblMCS
'   Inputs:     sCaption    tblMCS Caption Value
'               lColumn     tblMCS Value Column#
'   Outputs:    Me          Success: Property value
'                           Failure: Null
'   Requisites: Tables:     tblMCS
'   Example:    ?GetMCS("Website", riSetting)

'     Date   Ini Modification
'   05/17/16 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "GetMCS"
    Dim v               As Variant

'   Error Handling Initialization
    On Error GoTo ErrHandler
    GetMCS = Null

'   Check Inputs and Requisites
    
'   Procedure
    v = Evaluate("Match(""" & sCaption & """,tblMCS[Caption],0)")
    If IsError(v) Then _
        Err.Raise DspError, , "Check spelling of " & sCaption & " in MCS table"
    GetMCS = Evaluate("INDEX(tblMCS," & CLng(v) & "," & lColumn & ")")
    
ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function

Public Function RbnInt(ByVal lRequest As riRequestTypes, _
                       ByRef vValue As Variant, _
              Optional ByVal oRibbonUI As IRibbonUI, _
              Optional ByVal oRibbonControl As IRibbonControl, _
              Optional ByVal sControl As String, _
              Optional ByVal iIndex As Integer) As Boolean

'   Description:Ribbon Interface
'   Inputs:     lRequest    Request Type
'               vControl    Control (object or caption)
'               vValue      Value to set in or returned from control
'               oRibbonUI   Ribbon Object
'               oRibbonControl  Ribbon Control Object
'               sControl    Control's Tag name
'               iIndex      Item index
'   Outputs:    Me          Success/Failure
'   Requisites: *None
'   NOTE!       XL2007 won't pass ribbon objects in variants or generic objects
'   Example:    ?RibInt(riSet, "Project Name", "My First Project")
'               RibInt riGet, "Project Name", v: debug.print v

'     Date   Ini Modification
'   08/25/14 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "RbnInt"
    Dim bInvalidate     As Boolean      'IF true, issues Invalidate to Ribbon
    Static oDic         As Object       'Controls Container

'   Error Handling Initialization
    On Error GoTo ErrHandler
    RbnInt = Failure
    
'   Initialize variables
    bInvalidate = False
    If oDic Is Nothing Then Set oDic = CreateObject("Scripting.Dictionary")
    If Not oRibbonUI Is Nothing Then
        sControl = "Ribbon"
        Set oDic(sControl) = oRibbonUI
    End If
    If Not oRibbonControl Is Nothing Then
        sControl = oRibbonControl.Tag
        Set oDic(sControl) = oRibbonControl
    End If
    If oDic.Exists("Ribbon") Then Set oRibbonUI = oDic("Ribbon")
    
'   Procedure
    Select Case lRequest
        Case Is = riSave:         oDic(sControl & ":Value") = vValue
        Case Is = riSaveLabel:    oDic(sControl & ":Label") = vValue
        Case Is = riSaveItems:    oDic(sControl & ":Items") = vValue
        Case Is = riGet:          vValue = oDic(sControl & ":Value")
        Case Is = riGetLabel:     vValue = oDic(sControl & ":Label")
        Case Is = riGetItemCount: vValue = UBound(Split(oDic(sControl & ":Items"), ",")) + 1
        Case Is = riGetItemID:    vValue = "Item" & iIndex
        Case Is = riGetItemLabel: vValue = Split(oDic(sControl & ":Items"), ",")(iIndex)
        Case Is = riSet:          oDic(sControl & ":Value") = vValue: bInvalidate = True
        Case Is = riSetLabel:     oDic(sControl & ":Label") = vValue: bInvalidate = True
        Case Is = riSetItems:     oDic(sControl & ":Items") = vValue: bInvalidate = True
        Case Is = riActivateTab:  oRibbonUI.ActivateTab vValue: bInvalidate = False
    End Select
    If bInvalidate Then
        If oDic.Exists(sControl) Then Set oRibbonControl = oDic(sControl)
        If Not oRibbonControl Is Nothing Then _
            oRibbonUI.InvalidateControl oRibbonControl.ID Else _
                If Not oRibbonUI Is Nothing Then oRibbonUI.Invalidate
    End If
    RbnInt = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = 424                               'Do Nothing
        Case Is = 91                                'oRibbonControl destroyed
            MsgBox Prompt:="Save/Export your project, close Excel, and restart", _
                   Buttons:=vbCritical, _
                   Title:="Ribbon Interface Failure"
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select
    
End Function

'   Ribbon Interface Wrappers


Public Function ActTabUI(ByRef sTab As String) As Boolean

'   Description:Activate Ribbon Tab
'   Inputs:     sTab            Tab to activate
'   Outputs:    Me              Success/Failure
'   Requisites: Modules         me.RbnInt
'   Example:    ?ActTabUI("BXLHelper")

'     Date   Ini Modification
'   06/09/17 CWH Initial development

'   Declarations
    Const cRoutine      As String = "ActTabUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    ActTabUI = Failure
    
'   Procedure
    RbnInt lRequest:=riActivateTab, vValue:=sTab
    ActTabUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function GetCtlValUI(ByVal vControl As Variant) As Variant

'   Description:Get Control Value
'   Inputs:     sControl        Control to query
'   Outputs:    Me              Success: Value
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?GetCtlValUI("Double Click")

'     Date   Ini Modification
'   11/28/14 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "GetCtlValUI"
    Dim vValue          As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    GetCtlValUI = Null
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riGet, vValue, oRibbonControl:=vControl Else _
            RbnInt riGet, vValue, sControl:=vControl
    GetCtlValUI = vValue

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

Public Function GetCtlLblUI(ByVal vControl As Variant) As Variant

'   Description:Get Control Label
'   Inputs:     sControl        Control to query
'   Outputs:    Me              Success: Label
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?GetCtlLblUI("Worksheet")

'     Date   Ini Modification
'   08/12/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "GetCtlLblUI"
    Dim vValue          As Variant
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    GetCtlLblUI = Null
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riGetLabel, vValue, oRibbonControl:=vControl Else _
            RbnInt riGetLabel, vValue, sControl:=vControl
    GetCtlLblUI = vValue

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SetCtlValUI(ByVal vControl As Variant, _
                   Optional ByVal vValue As Variant) As Boolean

'   Description:Set Control Value
'   Inputs:     sControl        Control to Set
'               vValue          Value to set Control to
'                               NOTE! If omitted, get from tblMCS[Setting]
'   Outputs:    Me              Success: Value
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?SetCtlValUI("Double Click", TRUE)

'     Date   Ini Modification
'   11/28/14 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "SetCtlValUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetCtlValUI = Failure
    
'   Initialize Variables
    If IsMissing(vValue) Then vValue = GetMCS(vControl, riSetting)
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riSet, vValue, oRibbonControl:=vControl Else _
            RbnInt riSet, vValue, sControl:=vControl
    
    SetCtlValUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SetCtlLblUI(ByVal vControl As Variant, _
                   Optional ByVal vValue As Variant) As Boolean

'   Description:Set Control Label
'   Inputs:     sControl        Control to Set
'               vValue          Value to set Control label to
'                               NOTE! If omitted, get from tblMCS[Values]
'   Outputs:    Me              Success: Value
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?SetCtlLblUI("Worksheet", "Workbook")

'     Date   Ini Modification
'   08/12/16 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "SetCtlLblUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetCtlLblUI = Failure
    
'   Initialize Variables
    If IsMissing(vValue) Then vValue = GetMCS(vControl, riValues)
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riSetLabel, vValue, oRibbonControl:=vControl Else _
            RbnInt riSetLabel, vValue, sControl:=vControl
    
    SetCtlLblUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SetCtlLstUI(ByVal vControl As Variant, _
                   Optional ByVal vValue As Variant) As Boolean

'   Description:Set Control (ComboBox) listitems
'   Inputs:     sControl        Control to Set
'               vValue          Values to set Control listitems to
'                               NOTE! If omitted, get from tblMCS[Values]
'   Outputs:    Me              Success: Value
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?SetCtlLstUI("Transactions", "New,1,2,3")

'     Date   Ini Modification
'   11/28/14 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "SetCtlLstUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SetCtlLstUI = Failure
    
'   Initialize Variables
    If IsMissing(vValue) Then vValue = GetMCS(vControl, riValues)
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riSetItems, vValue, oRibbonControl:=vControl Else _
            RbnInt riSetItems, vValue, sControl:=vControl
    SetCtlLstUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SavCtlValUI(ByVal vControl As Variant, _
                   Optional ByVal vValue As Variant) As Boolean

'   Description:Save Control Value
'   Inputs:     sControl        Control to set
'               vValue          Value to save
'                               NOTE! If omitted, get from tblMCS[Setting]
'   Outputs:    Me              Success: Value
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?SavCtlValUI("Double Click")

'     Date   Ini Modification
'   11/28/14 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "SavCtlValUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SavCtlValUI = Failure
    
'   Initialize Variables
    If IsMissing(vValue) Then vValue = GetMCS(vControl, riSetting)
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riSave, vValue, oRibbonControl:=vControl Else _
            RbnInt riSave, vValue, sControl:=vControl
    SavCtlValUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SavCtlLblUI(ByVal vControl As Variant, _
                   Optional ByVal vValue As Variant) As Boolean

'   Description:Save Control Value
'   Inputs:     sControl        Control to set
'               vValue          Label to save
'                               NOTE! If omitted, get from tblMCS[Values]
'   Outputs:    Me              Success/Failure
'   Requisites: Modules         me.RbnInt
'   Example:    ?SavCtlLblUI("Worksheet", "Workbook")

'     Date   Ini Modification
'   08/12/16 CWH Initial Development

'   Declarations
    Const cRoutine      As String = "SavCtlLblUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SavCtlLblUI = Failure
    
'   Initialize Variables
    If IsMissing(vValue) Then vValue = GetMCS(vControl, riValues)
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riSaveLabel, vValue, oRibbonControl:=vControl Else _
            RbnInt riSaveLabel, vValue, sControl:=vControl
    SavCtlLblUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function SavCtlLstUI(ByVal vControl As Variant, _
                   Optional ByVal vValue As Variant) As Boolean

'   Description:Save Control list (Combobox, dropdown, and Gallery)
'   Inputs:     sControl        Control to set
'               vValue          CSV of valid list options
'                               NOTE! If omitted, get from tblMCS[Values]
'   Outputs:    Me              Success: Value
'                               Failure: Null
'   Requisites: Modules         me.RbnInt
'   Example:    ?SavCtlLstUI(vControl:="Interval", _
                             vValue:=Collection2CSV([tblIntervals[Code]], False))

'     Date   Ini Modification
'   02/03/16 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "SavCtlLstUI"
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    SavCtlLstUI = Failure
    
'   Initialize Variables
    If IsMissing(vValue) Then vValue = GetMCS(vControl, riValues)
    
'   Procedure
    If TypeName(vControl) = "IRibbonControl" Then _
        RbnInt riSaveItems, vValue, oRibbonControl:=vControl Else _
            RbnInt riSaveItems, vValue, sControl:=vControl
    SavCtlLstUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function

'   Standard Menu Functions
Public Function DspAbtUI(Optional ByRef Control As IRibbonControl) As Boolean

'   Description:Display About
'   Inputs:     IRibbonControl  Ribbon Control calling this routine
'   Outputs:    Me              Success/Failure
'   Requisites: *None
'   Example:    ?DspAbt

'     Date   Ini Modification
'   10/29/13 CWH Initial Programming

'   Declarations
    Const cRoutine      As String = "DspAbtUI"
    Dim s               As String
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    DspAbtUI = Failure
    
'   Procedure
    s = Year(CDate(Split(ThisWorkbook.BuiltinDocumentProperties("Last Save Time"), " ")(0)))
    MsgBox ThisWorkbook.BuiltinDocumentProperties("Comments") & vbCr & vbCr & _
            "Copyright " & ThisWorkbook.BuiltinDocumentProperties("author") & " " & s & "." & vbCr & _
            "This revision date: " & _
            ThisWorkbook.BuiltinDocumentProperties("Last Save Time") & vbCr & vbCr & _
            "Others may copy and change this work but " & _
            "may not claim it as their own or sell it or bundle it with any commercial products or services." & vbCr & vbCr & _
            "Removing BXL Logos is not permitted.", _
            vbOKOnly, _
            "About " & ThisWorkbook.BuiltinDocumentProperties("Title")
    DspAbtUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function DspPDFUI(Optional ByRef Control As IRibbonControl) As Boolean

'   Description:Display User Guide
'   Inputs:     IRibbonControl  Ribbon Control calling this routine
'   Outputs:    Me              Success/Failure
'   Requisites: Routines        modGeneral.MLookup
'   Example:    ?DspPDF

'     Date   Ini Modification
'   08/18/15 CWH Initial Programming
'   01/03/18 CWH Switched from XL_Lookup to MLookup

'   Declarations
    Const cRoutine      As String = "DspPDFUI"
    Dim sPDF            As String           'PDF's Name
    Dim oMCS            As ListObject       'tblMCS
    Dim v               As Variant          'Generic Result
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    DspPDFUI = Failure
    
'   Initialize Variables
    Exists Tables(ThisWorkbook), "tblMCS", oMCS
    
'   Procedure
    Set v = MLookup(oMCS, "Setting", "Caption", "Guide")
    If v Is Nothing Then v = vbNullString
    If Not v = vbNullString Then _
        sPDF = CStr(v) Else _
            sPDF = Left(ThisWorkbook.Name, InStrRev(ThisWorkbook.Name, ".xl")) & "PDF"
    If Not sPDF Like "*/*" And Not sPDF Like "*\*" Then _
        sPDF = ThisWorkbook.Path & "\" & sPDF
    ThisWorkbook.FollowHyperlink sPDF
    DspPDFUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Is = -2147024894, -2147221014
            MsgBox Prompt:="Couldn't find " & sPDF, _
                   Title:="PDF not found", _
                   Buttons:=vbInformation
        Case Is = -2147467260                       'User Cancelled - Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function


Public Function DspWWWUI(Optional ByRef Control As IRibbonControl) As Boolean

'   Description:Display Website
'   Inputs:     IRibbonControl  Ribbon Control calling this routine
'   Outputs:    Me              Success/Failure
'   Requisites: Routines        modGeneral.MLookup
'                               modGeneral.Tables
'                               modGeneral.Exists
'   Example:    ?DspWWW

'     Date   Ini Modification
'   10/29/13 CWH Initial Programming
'   01/03/18 CWH Switched from XL_Lookup to MLookup

'   Declarations
    Const cRoutine      As String = "DspWWWUI"
    Dim sURL            As String           'Web Site URL
    Dim oMCS            As ListObject       'tblMCS
    Dim v               As Variant          'Generic Result
    
'   Error Handling Initialization
    On Error GoTo ErrHandler
    DspWWWUI = Failure
    
'   Initialize Variables
    Exists Tables(ThisWorkbook), "tblMCS", oMCS
    
'   Procedure
    Set v = MLookup(oMCS, "Setting", "Caption", "Website")
    If v Is Nothing Then v = vbNullString
    If Not v = vbNullString Then _
        sURL = CStr(v) Else _
            sURL = "https://sites.google.com/site/beyondexcel/"
    If Not sURL Like "http*" Then sURL = "http://" & sURL
    ThisWorkbook.FollowHyperlink Address:=sURL, _
                                 NewWindow:=True
    DspWWWUI = Success

ErrHandler:
    Select Case Err.Number
        Case Is = NoError:                          'Do nothing
        Case Else:
            Select Case DspErrMsg(cModule & "." & cRoutine)
                Case Is = vbAbort:  Stop: Resume    'Debug mode - Trace
                Case Is = vbRetry:  Resume          'Try again
                Case Is = vbIgnore:                 'End routine
            End Select
    End Select

End Function
Attribute VB_Name = "wksACTs"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


' InQuest injected base64 decoded content
' ~`ZrD
' z+az

INQUEST-PP=macro
