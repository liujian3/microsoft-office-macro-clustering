Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Sub IListMain()

'MsgBox "Achtung! Diese Funktion ist noch nicht fertig implementiert!!"
    Call StartWork


End Sub
Attribute VB_Name = "Modul1"
Option Explicit

Sub Makro1()
Attribute Makro1.VB_Description = "Makro am 30.07.2008 von tkm050 aufgezeichnet"
Attribute Makro1.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro1 Makro
' Makro am 30.07.2008 von tkm050 aufgezeichnet
'

'
    Range("A1").Select
    Selection.Interior.ColorIndex = xlNone
End Sub
Sub Makro2()
Attribute Makro2.VB_Description = "Makro am 30.07.2008 von tkm050 aufgezeichnet"
Attribute Makro2.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro2 Makro
' Makro am 30.07.2008 von tkm050 aufgezeichnet
'

'
    Selection.AutoFilter
End Sub
Sub Makro3()
Attribute Makro3.VB_Description = "Makro am 30.07.2008 von tkm050 aufgezeichnet"
Attribute Makro3.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro3 Makro
' Makro am 30.07.2008 von tkm050 aufgezeichnet
'

'
    Range("A2:C27").Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    With Selection.Borders(xlInsideVertical)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlInsideHorizontal)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
End Sub
Sub Makro4()
Attribute Makro4.VB_Description = "Makro am 30.07.2008 von tkm050 aufgezeichnet"
Attribute Makro4.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro4 Makro
' Makro am 30.07.2008 von tkm050 aufgezeichnet
'

'
    Cells.Select
    With Selection
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = xlBottom
        .WrapText = False
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = False
    End With
End Sub
Attribute VB_Name = "Modul2"
Option Explicit

Sub Makro5()
Attribute Makro5.VB_Description = "Makro am 30.07.2008 von tkm050 aufgezeichnet"
Attribute Makro5.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro5 Makro
' Makro am 30.07.2008 von tkm050 aufgezeichnet
'

'
    Range("A1:J17").Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlThick
        .ColorIndex = xlAutomatic
    End With
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    With Selection.Borders(xlInsideVertical)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlInsideHorizontal)
        .LineStyle = xlDot
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    Range("D22").Select
End Sub
Sub testxx()
    Dim x As New clsLocaleInfo
    Debug.Print x.GetLanguage(Abbreviated_Name)





End Sub
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "clsLocaleInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum NameTypeEnum
    Localized_Name = 0
    Abbreviated_Name = 1
    Native_Name = 2
    English_Name = 3
End Enum

Public Enum LCIDEnum
    System_Default = 0
    User_Default = 1
End Enum

Private Declare Function GetLocaleInfo Lib "kernel32" _
                                       Alias "GetLocaleInfoA" _
                                       (ByVal Locale As Long, _
                                        ByVal LCType As Long, _
                                        ByVal lpLCData As String, _
                                        ByVal cchData As Long) As Long

Private Function GetInfo(InfoID As Long, Optional LCID As LCIDEnum) As String
' GetInfo wird von den |fffd|ffentlichen (Public) Prozeduren _
  mit entsprechendem Parameter aufgerufen

    Const LOCALE_SYSTEM_DEFAULT As Long = &H800
    Const LOCALE_USER_DEFAULT As Long = &H400


    Dim lngRet As Long
    Dim strBuffer As String
    Dim lngLocale As Long

    Select Case LCID
    Case LCIDEnum.System_Default
        lngLocale = LOCALE_SYSTEM_DEFAULT
    Case LCIDEnum.User_Default
        lngLocale = LOCALE_USER_DEFAULT
    End Select


    lngRet = GetLocaleInfo(lngLocale, InfoID, vbNullString, 0)
    If lngRet > 0 Then
        strBuffer = String$(lngRet, 0)
        lngRet = GetLocaleInfo(lngLocale, InfoID, strBuffer, Len(strBuffer))
        If lngRet Then
            GetInfo = ClipNullChar(strBuffer)
        End If
    End If
End Function

Public Function GetDoNotUseUserOverwrites(Optional LCID As LCIDEnum = System_Default)
' Private Const LOCALE_NOUSEROVERRIDE = &H80000000  '  do not use user overrides
    GetDoNotUseUserOverwrites = GetInfo(&H80000000, LCID)
End Function

Public Function GetPositiveSign(Optional LCID As LCIDEnum = System_Default) As String
' Private Const LOCALE_SPOSITIVESIGN = &H50        '  positive sign
    GetPositiveSign = GetInfo(&H50, LCID)
End Function

Public Function GetPositiveSignPosition(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IPOSSIGNPOSN = &H52        '  positive sign position

' 1 Vorzeichen links vom Betrag
' 2 Vorzeichen rechts vom Betrag
' 3 Vorzeichen links vom W|fffd|hrungssymbol
' 4 Vorzeichen rechts vom W|fffd|hrungssymbol

    GetPositiveSignPosition = GetInfo(&H52, LCID)
End Function

Public Function GetNegativeSign(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SNEGATIVESIGN = &H51        '  negative sign
    GetNegativeSign = GetInfo(&H51, LCID)
End Function

Public Function GetNegativeSignPosition(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_INEGSIGNPOSN = &H53        '  negative sign position

' 0 Betrag und W|fffd|hrungssymbol in Klammern
' 1 Vorzeichen links vom Betrag
' 2 Vorzeichen rechts vom Betrag
' 3 Vorzeichen links vom W|fffd|hrungssymbol
' 4 Vorzeichen rechts vom W|fffd|hrungssymbol

    GetNegativeSignPosition = GetInfo(&H53, LCID)
End Function

Public Function GetMeasure(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IMEASURE = &HD
'  0 = metric, 1 = US
    GetMeasure = GetInfo(&HD, LCID)
End Function

Public Function GetLeadingZerosForDecimal(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ILZERO = &H12        '  leading zeros for decimal
    GetLeadingZerosForDecimal = GetInfo(&H12, LCID)
End Function

Public Function GetNativeASCII0to9(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SNATIVEDIGITS = &H13        '  native ascii 0-9
    GetNativeASCII0to9 = GetInfo(&H13, LCID)
End Function

Public Function GetNumerOfFractionalDigits(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IDIGITS = &H11        '  number of fractional digits
    GetNumerOfFractionalDigits = GetInfo(&H11, LCID)
End Function
Public Function GetDecimalseparator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SDECIMAL = &HE         '  decimal separator
    GetDecimalseparator = GetInfo(&HE, LCID)
End Function

Public Function GetThousandSeparator(Optional LCID As LCIDEnum = System_Default)
' Const LOCALE_STHOUSAND = &HF         '  thousand separator
    GetThousandSeparator = GetInfo(&HF, LCID)
End Function

Public Function GetDigitGrouping(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SGROUPING = &H10        '  digit grouping
    GetDigitGrouping = GetInfo(&H10, LCID)
End Function

Public Function GetMonetaryDecimalseparator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SMONDECIMALSEP = &H16        '  monetary decimal separator
    GetMonetaryDecimalseparator = GetInfo(&H16, LCID)
End Function

Public Function GetMonetaryThousandSeparator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SMONTHOUSANDSEP = &H17        '  monetary thousand separator
    GetMonetaryThousandSeparator = GetInfo(&H17, LCID)
End Function

Public Function GetLocalMonetarySymbol(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SCURRENCY = &H14        '  local monetary symbol
    GetLocalMonetarySymbol = GetInfo(&H14, LCID)
End Function

Public Function GetInternationalMonetarySymbol(Optional LCID As LCIDEnum = System_Default) As String
'    Private Const LOCALE_SINTLSYMBOL = &H15        '  intl monetary symbol
    GetInternationalMonetarySymbol = GetInfo(&H15, LCID)
End Function

Public Function GetInternationalMonetaryDigits(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IINTLCURRDIGITS = &H1A        '  # intl monetary digits
    GetInternationalMonetaryDigits = GetInfo(&H1A, LCID)
End Function

Public Function GetLocalMonetaryDigits(Optional LCID As LCIDEnum = System_Default) As String
' Private Const LOCALE_ICURRDIGITS = &H19        '  # local monetary digits
    GetLocalMonetaryDigits = GetInfo(&H19, LCID)
End Function

Public Function GetMonetaryGrouping(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SMONGROUPING = &H18        '  monetary grouping
    GetMonetaryGrouping = GetInfo(&H18, LCID)
End Function


Public Function GetPositiveCurrencyMode(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ICURRENCY = &H1B        '  positive currency mode
' 0:  W|fffd|hrungszeichen ohne Abstand vor dem Betrag       z.B. DM15,23
' 1:  W|fffd|hrungszeichen ohne Abstand nach dem Betrag    z.B. 15,23DM
' 2:  W|fffd|hrungszeichen mit Abstand (1 Leerzeichen) vor dem Betrag    z.B. DM 15,23
' 3:  W|fffd|hrungszeichen mit Abstand (1 Leerzeichen) nach dem Betrag z.B. 15,23 DM


    GetPositiveCurrencyMode = GetInfo(&H1B, LCID)
End Function

Public Function GetNegativeCurrencyMode(Optional LCID As LCIDEnum = System_Default) As String
'    Private Const LOCALE_INEGCURR = &H1C        '  negative currency mode

' Die R|fffd|ckgabewerte 0 ... 15 bedeuten die Darstellung _
  negativer W|fffd|hrungsbetr|fffd|ge nach folgendem Schema:

' 0:     (DM 24,15)     Ausdruck in Klammern, W|fffd|hrungssymbol, Leerzeichen, Betrag
' 1:     -DM24,15       Minuszeichen, W|fffd|hrungssymbol, Betrag
' 2:     DM-24,15       W|fffd|hrungssymbol, Minuszeichen, Betrag
' 3:     DM25,15-       W|fffd|hrungssymbol, Betrag, Minuszeichen
' 4:     (24,15DM)      Ausdruck in Klammern, Betrag, W|fffd|hrungszeichen
' 5:     -24,15DM       Minuszeichen, Betrag, W|fffd|hrungssymbol
' 6:     24,15-DM       Betrag, Minuszeichen, W|fffd|hrungssymbol
' 7:     24,15DM-       Betrag, W|fffd|hrungssymbol, Minuszeichen
' 8:     -25,15 DM      Minuszeichen, Betrag, Leerzeichen, W|fffd|hrungssymbol
' 9:     -DM 24,15      Minuszeichen, Leerzeichen, Betrag
'10:    24,15 DM-      Betrag, Leerzeichen, Betrag, Minuszeichen
'11:    DM 24,15-      W|fffd|hrungssymbol, Leerzeichen, Betrag, Minuszeichen
'12:    DM -24,15      W|fffd|hrungssymbol, Leerzeichen, Minuszeichen, Betrag
'13:    24,15- DM      Betrag, Minuszeichen, Leerzeichen, W|fffd|hrungssymbol
'14:    (DM 24,15)     Ausdruck in Klammern, W|fffd|hrungssymbol, Leerzeichen, Betrag
'15:    (24,15 DM)     Ausdruck in Klammern, Betrag, Leerzeichen, W|fffd|hrungssymbol

    GetNegativeCurrencyMode = GetInfo(&H1C, LCID)
End Function


Public Function GetShortDateFormat(Optional LCID As LCIDEnum = System_Default) As String
'  Const LOCALE_SSHORTDATE = &H1F        '  short date format string
    GetShortDateFormat = GetInfo(&H1F, LCID)
End Function

Public Function GetLongDateFormat(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SLONGDATE = &H20        '  long date format string
    GetLongDateFormat = GetInfo(&H20, LCID)
End Function

Public Function GetShortDateOrdering(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IDATE = &H21        '  short date format ordering
'0   Month -Day - Year
'1   Day -Month - Year
'2   Year -Month - Day
    GetShortDateOrdering = GetInfo(&H21, LCID)
End Function

Public Function GetCenturyFormat(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ICENTURY = &H24        '  century format specifier
' 0 = Abbreviated 2-digit century
' 1 = Full 4-digit century
    GetCenturyFormat = GetInfo(&H24, LCID)
End Function

Public Function GetTimeSeparator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_STIME = &H1E        '  time separator
    GetTimeSeparator = GetInfo(&H1E&, LCID)
End Function

Public Function GetTimeFormatSpecifier(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ITIME = &H23        '  time format specifier
' 0   AM / PM 12-Stunden-Format.
' 1   24-Stunden-Format.
    GetTimeFormatSpecifier = GetInfo(&H23, LCID)
End Function

Public Function GetTimeFormatString(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_STIMEFORMAT = &H1003      '  time format string
    GetTimeFormatString = GetInfo(&H1003, LCID)
End Function

Public Function GetAMDesignator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_S1159 = &H28        '  AM designator
    GetAMDesignator = GetInfo(&H28, LCID)
End Function

Public Function GetPMDesignator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_S2359 = &H29        '  PM designator
    GetPMDesignator = GetInfo(&H29, LCID)
End Function

Public Function GetDateSeparator(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_SDATE = &H1D        '  date separator
    GetDateSeparator = GetInfo(&H1D, LCID)
End Function

Public Function GetLongDateFormatOrderingNumber(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ILDATE = &H22        '  long date format ordering
'0   Month-Day-Year
'1   Day-Month-Year
'2   Year-Month-Day
    GetLongDateFormatOrderingNumber = GetInfo(&H22, LCID)
End Function

Public Function GetLongDateFormatOrderingText(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ILDATE = &H22        '  long date format ordering

'0   Month-Day-Year
'1   Day-Month-Year
'2   Year-Month-Day
    Dim lngBuffer As Long
    lngBuffer = CLng(GetInfo(&H22, LCID))
    Select Case lngBuffer
    Case 0
        GetLongDateFormatOrderingText = "Month-Day-Year"
    Case 1
        GetLongDateFormatOrderingText = "Day-Month-Year"
    Case 2
        GetLongDateFormatOrderingText = "Year-Month-Day"
    End Select
End Function

Public Function GetLeadingZerosInDayField(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IDAYLZERO = &H26        '  leading zeros in day field

'0  Tag ohne f|fffd|hrende Null   z.B. 5, 7, 23
'1  Tag mit f|fffd|hrender Null     z.B. 05, 07, 23

    GetLeadingZerosInDayField = GetInfo(&H26, LCID)
End Function

Public Function GetCountryCode(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ICOUNTRY = &H5         '  country code
    GetCountryCode = GetInfo(&H5, LCID)
End Function

Public Function GetDefaultCountryCode(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IDEFAULTCOUNTRY = &HA         '  default country code
    GetDefaultCountryCode = GetInfo(&HA, LCID)
End Function

Public Function GetDefaultCodePage(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IDEFAULTCODEPAGE = &HB         '  default code page
    GetDefaultCodePage = GetInfo(&HB, LCID)
End Function


Public Function GetDefaultLanguageID(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_IDEFAULTLANGUAGE = &H9         '  default language id
    GetDefaultLanguageID = GetInfo(&H9, LCID)
End Function

Public Function GetLanguageID(Optional LCID As LCIDEnum = System_Default) As String
' Const LOCALE_ILANGUAGE = &H1         '  language id
    GetLanguageID = GetInfo(&H1, LCID)
End Function


Public Function GetMonthName(Month As Integer, Optional Abbreviated As Boolean = False, Optional LCID As LCIDEnum = System_Default) As String
' gibt den lokalisierten Namen f|fffd|r den in Month als Zahl |fffd|bergebenen Monat zur|fffd|ck
' Abbreviated bestimmt ob der Name in voller L|fffd|nge oder abgek|fffd|rzt zur|fffd|ckgegeben wird

    Dim lngBaseValue As Long
    Select Case Month
    Case 1 To 12
        If Abbreviated Then
            lngBaseValue = &H43
        Else
            lngBaseValue = &H37
        End If
        GetMonthName = GetInfo(lngBaseValue + Month, LCID)
    Case Else
        GetMonthName = ""
    End Select
End Function

Public Function GetDayName(Day As Integer, Optional Abbreviated As Boolean = False, Optional LCID As LCIDEnum = System_Default) As String
' gibt den lokalisierten Namen des in Day als Zahl |fffd|bergebenen Tages zur|fffd|ck
' Abbreviated bestimmt ob der Name in voller L|fffd|nge oder abgek|fffd|rzt zur|fffd|ckgegeben wird.

    Dim lngBaseValue As Long
    Select Case Day
    Case 1 To 7
        If Abbreviated Then
            lngBaseValue = &H30
        Else
            lngBaseValue = &H29
        End If
        GetDayName = GetInfo(lngBaseValue + Day, LCID)
    Case Else
        GetDayName = ""
    End Select
End Function

Public Function GetLanguage(NameType As NameTypeEnum, Optional LCID As LCIDEnum = System_Default) As String
'    Const LOCALE_SLANGUAGE = &H2         '  localized name of language
'    Const LOCALE_SABBREVLANGNAME = &H3         '  abbreviated language name
'    Const LOCALE_SNATIVELANGNAME = &H4         '  native name of language
'    Const LOCALE_SENGLANGUAGE = &H1001      '  English name of language
    Select Case NameType
    Case NameTypeEnum.Localized_Name
        GetLanguage = GetInfo(&H2, LCID)
    Case NameTypeEnum.Abbreviated_Name
        GetLanguage = GetInfo(&H3, LCID)
    Case NameTypeEnum.Native_Name
        GetLanguage = GetInfo(&H4, LCID)
    Case NameTypeEnum.English_Name
        GetLanguage = GetInfo(&H1001, LCID)
    End Select

End Function

Public Function GetCountryName(NameType As NameTypeEnum, Optional LCID As LCIDEnum = System_Default) As String
'    Const LOCALE_SCOUNTRY = &H6         '  localized name of country
'    Const LOCALE_SABBREVCTRYNAME = &H7         '  abbreviated country name
'    Const LOCALE_SNATIVECTRYNAME = &H8         '  native name of country
'    Const LOCALE_SENGCOUNTRY = &H1002      '  English name of country

    Select Case NameType
    Case NameTypeEnum.Localized_Name
        GetCountryName = GetInfo(&H6, LCID)
    Case NameTypeEnum.Abbreviated_Name
        GetCountryName = GetInfo(&H7, LCID)
    Case NameTypeEnum.Native_Name
        GetCountryName = GetInfo(&H8, LCID)
    Case NameTypeEnum.English_Name
        GetCountryName = GetInfo(&H1002, LCID)
    End Select
End Function

Public Function ClipNullChar(Text As String) As String
' Hilfsfunktion ClipNullChar: _
  Schneidet Text beim ersten Vorkommen _
  von vbNullChar ab und gibt den _
  verbleibenden Text zur|fffd|ck.

    Dim Pos As Long
    Pos = InStr(Text, vbNullChar)
    If Pos Then
        ' alles ab vbNullChar abschneiden
        ClipNullChar = Left$(Text, Pos - 1)
    Else
        ' kein vbNullChar in Text vorhanden
        ClipNullChar = Text
    End If
End Function


Attribute VB_Name = "frmLangSel"
Attribute VB_Base = "0{CD6B1E30-744B-49D7-81A4-2A7C784A9245}{1F1D67B8-027A-4C18-9E55-05864D5EFBDF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub cmdOKAY_Click()
    Lang = txtLang.Value

    Me.Hide
    Unload Me
End Sub

Private Sub optDE_Click()
    txtLang.Value = "DE"
End Sub


Private Sub optEN_Click()
    txtLang.Value = "EN"
End Sub

Private Sub UserForm_Initialize()
    txtLang.Value = "DE"
End Sub
Attribute VB_Name = "frmVAT_GrossPrice"
Attribute VB_Base = "0{52AFA091-082B-4878-930B-75885AE6121D}{6439B0B6-DC27-477D-8A35-0DEAA5914D9D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit



Private Sub cbxInsertVAT_Click()
    Me.txtVAT.Visible = Me.cbxInsertVAT.Value
    Me.lblPerc.Visible = Me.cbxInsertVAT.Value
    Me.txtVAT.Enabled = Me.cbxInsertVAT.Value
    If Me.txtVAT.Visible Then
        Me.txtVAT.SetFocus
    End If


End Sub

Private Sub cmdOK_Click()

    VATX = True

    VAT = Me.cbxInsertVAT.Value
    If VAT Then
        VAT_Perc = CSng(IIf(Me.txtVAT.Value = "", 0, Me.txtVAT.Value))
    Else
        VAT_Perc = 0
    End If

    Me.Hide
    Unload Me


End Sub


Private Sub UserForm_Initialize()

    Select Case USER_LANG
    Case "DE"
        Me.Caption = DE_FORM_CAPTION
        lblGeneral.Caption = DE_FORM_INFO_LABEL
        cbxInsertVAT.Caption = DE_FORM_CBX_LABEL
        lblPerc.Caption = DE_FORM_VAT_LABEL
        cmdOK.Caption = DE_FORM_CMD_CAPT
    Case Else
        Me.Caption = EN_FORM_CAPTION
        lblGeneral.Caption = EN_FORM_INFO_LABEL
        cbxInsertVAT.Caption = EN_FORM_CBX_LABEL
        lblPerc.Caption = EN_FORM_VAT_LABEL
        cmdOK.Caption = EN_FORM_CMD_CAPT

    End Select

    VATX = False
    Me.cbxInsertVAT.Value = False
    Me.txtVAT.Value = ""
    Me.txtVAT.Visible = False
    Me.lblPerc.Visible = Me.cbxInsertVAT.Value
End Sub
Attribute VB_Name = "mdlForm"
'### ALTES PROGRAMM - BIS AUF KONSTANTE 'pw' ###


Option Explicit

Public Const pw As String = "LINDE_PROTECT_PRICES"


'KOPF-Tabelle
Private Const UEBERSCHRIFTEN_SPALTE = 1
Private Const WERTE_SPALTE = 2
Private Const EK_BELEG_ZEILE = 1
Private Const VENDOR_ZEILE = 2
Private Const SUBMISSION_ZEILE = 3
Private Const VENDOR_NAME_ZEILE = 4
Private Const PROJ_ZEILE = 5
Private Const PLANZIFFER_ZEILE = 6
Private Const BEZEICHNUNG_ZEILE = 7

'Positionstabelle
Private Const EINKAUFSBELEG_SPALTE = 1
Private Const POSITION_SPALTE = 2
Private Const MATERIAL_SPALTE = 3
Private Const BENENNUNG_IN_PRONTO_SPALTE = 4
Private Const WERKSTOFF_SPALTE = 5
Private Const WARENGRUPPE_SPALTE = 6
Private Const TAG_NUMMER_SPALTE = 7
Private Const ZIELMENGE_SPALTE = 8
Private Const BESTELL_ME_SPALTE = 9
Private Const BRUTTOSTUECKPREIS_SPALTE = 10
Private Const NETTOPREIS_SPALTE = 11
Private Const GEWICHT_SPALTE = 12
Private Const GEWICHTSEINHEIT_SPALTE = 13
Private Const TECHNLIEFERBED_SPALTE = 14
Private Const ZEUGNISANFORDERUNG_SPALTE = 15
Private Const KUNDEN_NORM_SPALTE = 16
Private Const NORMBLATT_SPALTE = 17
Private Const LEER_SPALTE = 18
Private Const SPEZIFIKATION_SPALTE = 19
Private Const WERKSTOFFNUMMER_SPALTE = 20
Private Const COMMODITY_CODE_SPALTE = 21
Private Const KUNDENIDENTNUMMER_SPALTE = 22
Private Const LMI_IDENTNUMMER_SPALTE = 23
Private Const BRUTTOPREIS_SPALTE = NETTOPREIS_SPALTE
Private Const SUMMEN_SPALTE = BRUTTOPREIS_SPALTE



'LINDE NEUE FELDER
Const ADDON_VEND_COMMENT_SPALTE = 1


'Bereicheingrenzung
Const ADDON_BEGIN = 24
Const ADDON_END = 24

'Bereichsbenennung
'''Const B_HEADER = "HEADER_TAB"
'''Const B_PLINE = "POSITION_LINE"
'''Const B_PTAB = "POSITION_TAB"
'''Const B_ACAPT = "LINDE_ADDON_CAPTION"
'''Const B_ADATA = "LINDE_ADDON_DATA"


Const HIDE_COLUMNS = "F;I;R;W"

Const Produktion As Boolean = True
Public Enum FARBWERTE
    fwHEADER = 23
    fwPOSLINE = 16
    fwBRUTPRS = 28
    fwVENDCOM = 37
End Enum
Public r1 As Range, _
       r2 As Range, _
       r3 As Range, _
       r4 As Range, _
       r5 As Range, _
       r6 As Range, _
       r7 As Range, _
       lfa As Range, _
       lfb As Range, _
       lfx As Range
'lfa+lfb=weitere Linde Felder (vendor Comment)

Public Lang$


Sub SETRANGES()
''''Dim bereich ' As Range
''''Dim xy, a1, a2
'''' Dim a1r As Range, a2r As Range
''''
''''Set r1 = Range(B_HEADER)
''''
''''Set r2 = Range(B_PLINE)
''''
''''Set r3 = Range(B_PTAB)
''''
''''Set r4 = Range(r2, r3)
''''
'''''xy = r4.Cells(r4.Rows.Count + 2, SUMMEN_SPALTE).Address
''''xy = Cells(r2.Row - 2, SUMMEN_SPALTE).Address
''''Set r5 = Range(xy)
''''
'''''xy = r4.Cells(r4.Rows.Count + 2, SUMMEN_SPALTE-1).Address
''''xy = Cells(r2.Row - 2, SUMMEN_SPALTE - 1).Address
''''Set r6 = Range(xy)
'''''MsgBox r5.Address & vbCrLf & r6.Address
''''
''''Set r7 = Range(r5, r6)
''''
''''
''''a1 = Cells(r2.Row, ADDON_BEGIN).Address
''''a2 = Cells(r2.Row, ADDON_END).Address
''''Set a1r = Range(a1)
''''Set a2r = Range(a2)
''''bereich = "=Sheet1!" & a1r.AddressLocal & ":" & a2r.AddressLocal
''''''ActiveWorkbook.Names.Add B_ACAPT, bereich
''''
''''
''''a1 = Cells(r2.Row + 1, ADDON_BEGIN).Address
''''a2 = r3.Cells(r3.Rows.Count, ADDON_END).Address
''''Set a1r = Range(a1)
''''Set a2r = Range(a2)
''''bereich = "=Sheet1!" & a1r.AddressLocal & ":" & a2r.AddressLocal
'''''''ActiveWorkbook.Names.Add B_ADATA, bereich
'''''''
'''''''Set lfa = Range(B_ACAPT)
'''''''Set lfb = Range(B_ADATA)
'''''''Set lfx = Range(lfa, lfb)

End Sub


Sub Format_MAIN_alt()
    On Error GoTo fehler
    Dim xy

    'Bereiche Definieren und Festlegen
    Call SETRANGES



    ' Autoformatvorlagen f|fffd|r Kopf und Positionstabelle
    '''r1.AutoFormat xlRangeAutoFormatClassic3
    '''r4.AutoFormat xlRangeAutoFormatClassic3
    '''lfx.AutoFormat xlRangeAutoFormatClassic3


    ''On Error Resume Next
    ''''Application.WindowState = xlMaximized
    ''''ActiveWindow.WindowState = xlMaximized
    ''''ActiveWindow.Zoom = ZOOM_STUFE
    'r1.Interior.ColorIndex = fwHEADER
    r1.Columns(UEBERSCHRIFTEN_SPALTE).Font.Bold = True
    r1.Columns(WERTE_SPALTE).HorizontalAlignment = xlCenter
    r1.Columns(WERTE_SPALTE).WrapText = True
    r1.VerticalAlignment = xlTop
    r2.HorizontalAlignment = xlCenter
    'r2.Interior.ColorIndex = fwPOSLINE
    r2.Font.Bold = True
    r7.Font.Bold = True
    r7.Interior.Color = vbYellow
    lfa.Font.ColorIndex = r2.Font.ColorIndex
    lfa.Font.Bold = True
    lfb.Font.Bold = False




    'Hervorhebung der Brottopreisspalte
    r3.Columns(BRUTTOSTUECKPREIS_SPALTE).Interior.ColorIndex = fwBRUTPRS
    lfb.Columns(ADDON_VEND_COMMENT_SPALTE).Interior.ColorIndex = fwVENDCOM


    'Linien ziehen

    With r1.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    With r1.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With

    With r3.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    With r3.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With

    'On Error Resume Next

    With r7.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = xlThick
        .ColorIndex = xlAutomatic
    End With

    With r7.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlThick
        .ColorIndex = xlAutomatic
    End With

    With r7.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlThick
        .ColorIndex = xlAutomatic
    End With

    With r7.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlThick
        .ColorIndex = xlAutomatic
    End With




    With lfb.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With
    With lfb.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = xlAutomatic
    End With

    On Error GoTo fehler

    '''''Eingabeg|fffd|ltigkeit festlegen!
    ''''    With r3.Validation
    ''''        .Delete
    ''''        .Add Type:=xlValidateDecimal, AlertStyle:=xlValidAlertStop, Operator _
     ''''        :=xlGreaterEqual, Formula1:="0"
    ''''        .IgnoreBlank = True
    ''''        .InCellDropdown = True
    ''''        .InputTitle = ""
    ''''        .ErrorTitle = "Error - Contents must be Number"
    ''''        .InputMessage = ""
    ''''        .ErrorMessage = "Entry not allowed. Please enter a number greater or equal 0!"
    ''''        .ShowInput = True
    ''''        .ShowError = True
    ''''    End With
    ''''
    ''''    With lfb.Validation
    ''''        .Delete
    ''''        .Add Type:=xlValidateTextLength, AlertStyle:=xlValidAlertWarning, _
     ''''        Operator:=xlBetween, Formula1:="1", Formula2:="100"
    ''''        .IgnoreBlank = True
    ''''        .InCellDropdown = True
    ''''        .InputTitle = ""
    ''''        .ErrorTitle = "Text exeeds proposed maximum"
    ''''        .InputMessage = ""
    ''''        .ErrorMessage = "Proposed text length is between 1 and 100. Please make your text shorter."
    ''''        .ShowInput = True
    ''''        .ShowError = True
    ''''    End With




    'Ausrichtung |fffd|ndern
    r1.Columns(WERTE_SPALTE).HorizontalAlignment = xlLeft
    r1.Rows(EK_BELEG_ZEILE).Font.Size = r1.Rows(EK_BELEG_ZEILE).Font.Size + 2
    r2.HorizontalAlignment = xlCenter
    r3.Columns(POSITION_SPALTE).HorizontalAlignment = xlCenter
    r3.Columns(WERKSTOFF_SPALTE).HorizontalAlignment = xlCenter
    r3.Columns(WARENGRUPPE_SPALTE).HorizontalAlignment = xlCenter


    'On Error GoTo Fehler2

    'Daten Sortieren
    Dim skey_adr
    skey_adr = r4.Cells(2, POSITION_SPALTE).Address
    r4.Select
    Selection.Sort Key1:=Range(skey_adr), Order1:=xlAscending, Header:=xlYes, _
                   OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, _
                   DataOption1:=xlSortNormal



    'BruttoPreis berechnen
    Dim i As Integer
    Debug.Print r3.Rows.Count
    For i = 1 To r3.Rows.Count
        r3.Cells(i, BRUTTOPREIS_SPALTE).Formula = "=" & r3.Cells(i, ZIELMENGE_SPALTE).Address & "*" & r3.Cells(i, BRUTTOSTUECKPREIS_SPALTE).Address
        If r3.Cells(i, MATERIAL_SPALTE).Value = "" Then
            r3.Cells(i, MATERIAL_SPALTE).Value = r3.Cells(i, LMI_IDENTNUMMER_SPALTE).Value
        End If
    Next i


    'Summe der Bruttost|fffd|ckpreisspalte als Formel

    r5.Formula = "=Sum(" & r3.Columns(BRUTTOPREIS_SPALTE).Address & ")"
    r6.Value = "Gesamtsumme:" & Chr(10) & _
               "Total Price:"

    r5.NumberFormat = "#,##0.00"
    r3.Columns(BRUTTOSTUECKPREIS_SPALTE).NumberFormat = "#,##0.00"
    r3.Columns(BRUTTOPREIS_SPALTE).NumberFormat = "#,##0.00"


    '|fffd|bersetzung
    ''''Call translate

    'spaltenbreite anpassen
    Call spaltenbreite


    'Blendet unerw|fffd|nschte Spalten aus
    '''Call sHide_Columns

    r1.Select

    ''''    ActiveSheet.Pictures.Insert("\\D1S07\UPGM\LOGOS\jpg-Format\LE_DesignModul_RGB.jpg"). _
     ''''        Select
    ''''    Selection.ShapeRange.IncrementLeft 500#
    ''''    Selection.ShapeRange.IncrementTop -25.5
    ''''    Selection.ShapeRange.ScaleWidth 0.71, msoFalse, msoScaleFromBottomRight
    ''''    Selection.ShapeRange.ScaleHeight 0.72, msoFalse, msoScaleFromTopLeft

    r3.Select

    Select Case Produktion
    Case True
        GoTo prot
    Case False

        Exit Sub
    End Select

prot:
    ' Gitternetzlinien entfernen

    With ActiveWindow
        .DisplayGridlines = False
        .DisplayHeadings = False
    End With



    Application.DisplayAlerts = False
    Sheets("TRANSLATE").Delete
    Application.DisplayAlerts = True

    'Fensterinhalt fixieren
    r2.Cells(1, FIXIEREN_SPALTE).Select
    xy = Selection.Row + 1
    Cells(xy, FIXIEREN_SPALTE).Select
    ActiveWindow.FreezePanes = True



    'Zellen pr|fffd|parieren (sperren)
    ''''Dim rx As Range
    ''''Dim adr1$, adr2$
    ''''adr1 = r3.Cells(1, BRUTTOSTUECKPREIS_SPALTE).Address
    ''''adr2 = r3.Cells(r3.Rows.Count - 1, BRUTTOSTUECKPREIS_SPALTE).Address
    ''''Set rx = Range(adr1 & ":" & adr2)
    ''''Cells.Locked = True
    ''''rx.Locked = False
    ''''lfb.Locked = False
    ''''rx.Select
    ''''ActiveSheet.Protect Password:=PW, DrawingObjects:=True, Contents:=True, Scenarios:=True
    ''''ActiveSheet.EnableSelection = xlUnlockedCells

    Call speichern

    'ActiveWorkbook.Save
    Dim txtDE$, txtEN$
    txtDE = "DE:   Dieses Formular wurde unter nachfolgenden Dateinamen gespeichert:"
    txtEN = "EN:   This Form was saved as:"
    MsgBox txtDE & vbCrLf & txtEN & vbCrLf & vbCrLf & vbTab & filenm, vbOKOnly + vbInformation, _
           "Positionsliste gespeichert / Item list saved)"

    Workbooks.Open filenm
    ThisWorkbook.Close False

    Exit Sub
fehler:
    If Err.Number = 1004 Then
        MsgBox "Noch keine Daten aus dem SAP empfangen!", vbCritical + vbOKOnly

        Exit Sub
    Else: Resume Next
    End If


    Exit Sub

Fehler2:
    Debug.Print Err.Number & " // " & Err.Description

    'SendKeys "^{BREAK}", True
    Resume Next

End Sub


'Sub translate()
'If Lang = "" Then
'    Lang = "DE"
'    End If
'
'Dim r1t As Range, r2t As Range, lfat As Range
'
'Const de_col_h = 2
'Const en_col_h = 3
'
'Const de_col_t = 4
'Const en_col_t = 5
'
'Const de_col_fc = 6
'Const en_col_fc = 7
'
'Set r1t = Range(B_HEADER)
'
'Set r2t = Range(B_PLINE)
'
'Set lfat = Range(B_ACAPT)
'
'
'Const TABL = "TRANSLATE!"
'Const TA_Rn = "$A$3:$G$25"
'Dim rn As Range
'Set rn = Range(TABL & TA_Rn)
'
'Dim C_HEAD_CAPTION As Integer, C_TAB_CAPTION As Integer, C_LF_CAPTION As Integer
''Lang = "de"
'
'
'Select Case UCase(Lang)
'Case "DE"
'C_HEAD_CAPTION = de_col_h
'C_TAB_CAPTION = de_col_t
'C_LF_CAPTION = de_col_fc
'Case "EN"
'C_HEAD_CAPTION = en_col_h
'C_TAB_CAPTION = en_col_t
'C_LF_CAPTION = en_col_fc
'End Select
'
''HEAD |fffd|BERSETZEN
'Dim i
'For i = 1 To r1.Rows.Count
'r1.Cells(i, 1).Value = ftranslate(rn, C_HEAD_CAPTION, i)
'Next i
'
''TAB |fffd|BERSETZEN
'For i = 1 To r2.Columns.Count
'r2.Cells(1, i).Value = ftranslate(rn, C_TAB_CAPTION, i)
'Next i
'
'
''LINDE ADDONS |fffd|BERSETZEN
'For i = 1 To lfat.Columns.Count
'lfat.Cells(1, i).Value = ftranslate(rn, C_LF_CAPTION, i)
'Next i
'
'End Sub
'
'Function ftranslate(rn As Range, ByVal col As Integer, ByVal idx As Integer) As String
'Dim wd$
'Dim i
'i = 1
'Do Until rn.Cells(i, 1) = ""
'    If rn.Cells(i, 1).Value = idx Then
'        wd = rn.Cells(i, col).Value
'        GoTo ausg 'Exit Do
'        End If
'
''Debug.Print rn.Cells(i, 1).Address & ": " & rn.Cells(i, 1).Value
'
'i = i + 1
'Loop
'ausg:
'ftranslate = wd
'
'End Function


Sub speichern()
    Const SLW = "X:\"    ' Standardlaufwerk
    Dim fl$, x
    Dim fn$
    Dim r As Range
    Set r = Range("HEADER_TAB")
    Dim dat$

    dat = format(Date, "ddmmyyyy") & "_" & format(Time, "hhnn")    'format(Time, "hhnnss")

    If Not fso.FolderExists(SLW) Then



        Dim fd As FileDialog
        Set fd = Application.FileDialog(msoFileDialogFolderPicker)
        fd.Title = "Speicherort ausw|fffd|hlen / Please choose path to save"
        fd.InitialFileName = "C:\TEMP\"
        fd.Show

        For Each x In fd.SelectedItems
            fl = fl & x
        Next x

        Set fd = Nothing
    Else
        fl = SLW
    End If



    Dim subm$, vend$, vendno$, bez$, langx$, datx$

    subm = r.Cells(SUBMISSION_ZEILE, WERTE_SPALTE).Value & "_"
    'subm = ""

    vend = r.Cells(VENDOR_NAME_ZEILE, WERTE_SPALTE).Value
    'vend = "_"

    vendno = "(" & r.Cells(VENDOR_ZEILE, WERTE_SPALTE).Value & ")_"
    'vendno = "_"

    'bez = r.Cells(BEZEICHNUNG_ZEILE, WERTE_SPALTE).Value & "_"
    bez = ""

    langx = Lang & "_"
    'langx = ""

    datx = dat
    'datx = ""

    fn = subm & _
         vend & _
         vendno & _
         bez & _
         langx & _
         datx & ".xls"

    fn = fl & IIf(Right(fl, 1) = "\", "", "\") & fn

    If Dir(fn) <> "" Then
        Kill fn
    End If


    ActiveWorkbook.SaveAs fn, xlNormal
    filenm = fn

End Sub



Sub sHide_Columns()
    If HIDE_COLUMNS = "" Then Exit Sub

    Dim hd() As String
    Dim i%, Cl As String, x%
    hd = Split(HIDE_COLUMNS, ";")
    '    Columns("F:F").Delete Shift:=xlToLeft

    For i = LBound(hd) To UBound(hd)
        Cl = hd(i)
        x = Range(Cl & 1).Column
        'Columns(x).ColumnWidth = 10.71
        Columns(x).EntireColumn.Hidden = True
    Next i

End Sub

Sub spaltenbreite()


    Cells.EntireRow.AutoFit
    Cells.EntireColumn.AutoFit
    r4.Cells.EntireColumn.AutoFit
    r3.Cells(1, BRUTTOSTUECKPREIS_SPALTE).Value = 0
    r4.Columns(POSITION_SPALTE).ColumnWidth = 15.5
    r4.Columns(BRUTTOPREIS_SPALTE).ColumnWidth = 15

    lfx.Cells.EntireColumn.AutoFit

End Sub



Attribute VB_Name = "mdlGUID"
Option Explicit



Public Declare Function ShellExecute Lib "shell32.dll" _
                                     Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal _
                                                                                lpOperation As String, ByVal lpFile As String, ByVal _
                                                                                                                               lpParameters As String, ByVal lpDirectory As String, _
                                                            ByVal nShowCmd As Long) As Long

Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(7) As Byte
End Type

Declare Function CoCreateGuid Lib "OLE32.DLL" (pGuid As GUID) As Long


Public Function NewGUID() As String
    Dim uid As GUID
    Dim i As Integer
    CoCreateGuid uid

    NewGUID = _
    hex0(uid.Data1, 8) & "-" & _
              hex0(uid.Data2, 4) & "-" & _
              hex0(uid.Data3, 4) & "-" & _
              hex0(uid.Data4(0), 2) & _
              hex0(uid.Data4(1), 2) & "-"
    For i = 2 To 7
        NewGUID = NewGUID & hex0(uid.Data4(i), 2)
    Next
    NewGUID = "{" & NewGUID & "}"
End Function
Public Function NewGUID_FN() As String
    Dim uid As GUID
    Dim i As Integer
    CoCreateGuid uid

    NewGUID_FN = _
    hex0(uid.Data1, 8) & "-" & _
                 hex0(uid.Data2, 4) & "-" & _
                 hex0(uid.Data3, 4) & "-" & _
                 hex0(uid.Data4(0), 2) & _
                 hex0(uid.Data4(1), 2) & "-"
    For i = 2 To 7
        NewGUID_FN = NewGUID_FN & hex0(uid.Data4(i), 2)
    Next
    NewGUID_FN = NewGUID_FN
End Function
Private Function hex0(N, digits As Integer) As String
    hex0 = Hex(N)
    hex0 = String(digits - Len(hex0), "0") & hex0
End Function

Attribute VB_Name = "mdlGeneral"
Option Explicit

Public Const GEN_DEL_COLUMNS = "A;E;G;N;T;V;W;X;Y"
'Public Const GEN_DEL_COLUMNS = "A;F;M;R;T;U;V;W"


Public Function getUsersLanguage() As String

    Dim x As New clsLocaleInfo

    Dim l As String
    l = x.GetLanguage(Abbreviated_Name)
    getUsersLanguage = Left(l, 2)

    Set x = Nothing

End Function

'Public Sub Main_HEAD_START()
'    ALLOW_MULTI_SELECT = True
'
'    '** Zun|fffd|chst werden Teile des Kopfes in Variablen geschrieben danach wird der Kopf geleert **
'
'    Application.WindowState = xlMaximized
'    ActiveWindow.WindowState = xlMaximized
'    ActiveWindow.Zoom = ZOOM_STUFE
'
'    strSubmissionsnr = Range(LH_SUBM_ADR).Value
'    strProjektNr = Range(LH_PROJNR_ADR).Value
'    strProjektName = Range(LH_PROJNM_ADR).Value
'
'    Rows("1:10").ClearContents
'
'
'
'
'End Sub
'
'Public Sub Format_MAIN()
'    Call OrganizeRangeNames
'
'
'    Range(BH_RANGE).AutoFormat xlRangeAutoFormatClassic3
'    Range(LH_RANGE).AutoFormat xlRangeAutoFormatClassic3
'    Range(RFQ_ITEMS).AutoFormat xlRangeAutoFormatClassic3
'
'    Call Format_TAB
'
'
'    Cells.EntireColumn.AutoFit
'    Select Case strType
'        Case "P"
'            Columns("D:D").ColumnWidth = 40
'        Case "E", "A"
'            Columns("C:C").ColumnWidth = 40
'    End Select
'
'
'
'End Sub

Private Sub Format_TAB()



End Sub





'Private Function getLastRowZ(Optional ByVal strCol$ = "B") As Long
'
'    Dim l: l = 65536
'
'    Do Until Range(strCol & l) <> ""
'        l = l - 1
'    Loop
'
'    getLastRow = l
'
'
'End Function


Public Sub OrganizeRangeNames()
    Dim lR
    lR = getLastRow("A")

    Dim r As Range
    Dim a$, b$




End Sub
Private Function getPLIN() As String
    Dim p1$, p2$, radr$
    Dim i
    Dim x

    i = 1
    x = 14


    p1 = Cells(x, i).Address


    Do Until Cells(14, i) = ""

        i = i + 1
    Loop
    i = i - 1      '//zur Korrektur da 1 Zelle zu weit gez|fffd|hlt wird!!





    p2 = Cells(x, i).Address

    radr = p1 & ":" & p2



    getPLIN = radr




End Function


Private Function getPTAB() As String
    Dim p1$, p2$, radr$
    Dim i
    Dim x

    i = 1
    x = 15


    p1 = Cells(x, i).Address


    Do Until Cells(14, i) = ""

        i = i + 1
    Loop
    i = i - 1      '//zur Korrektur da 1 Zelle zu weit gez|fffd|hlt wird!!

    Do Until Cells(x, 1) = ""

        x = x + 1
    Loop
    x = x - 1       '//zur Korrektur da 1 Zelle zu weit gez|fffd|hlt wird!!



    p2 = Cells(x, i).Address

    radr = p1 & ":" & p2



    getPTAB = radr




End Function




Public Sub Main_TAB()
'
'    '** f|fffd|hrt die |fffd|nderungen an der Tabelle durch (Daten|fffd|bertragung / Spaltenverschieben / Spalten l|fffd|schen)
'
'    Call CopyIdentNr
'
'    Call gen_deleteColumns(GEN_DEL_COLUMNS)
'
'
'
'
'    Call OrganizeRangeNames
'
'    Call ListeSortieren

End Sub


Public Sub FinalizePriceTable()

'    Call FixCols  '// Spalten fixieren
'
'
'    Application.DisplayAlerts = False
'    Sheets("TRANSLATE").Delete
'    Application.DisplayAlerts = True
'
'
'
'    Call
'
'
'
'    Workbooks.Open filenm
'
'    ThisWorkbook.Close False
End Sub









Public Sub MoveCols(ByVal fromX$, ByVal tox$)

    If Trim(fromX) = "" Or Trim(tox) = "" Then Exit Sub

    Dim arrFrx() As String
    Dim arrTox() As String

    Dim i%, clFr As String, clTo As String, x%
    arrFrx = Split(fromX, ";")
    arrTox = Split(tox, ";")

    For i = LBound(arrFrx) To UBound(arrFrx)
        clFr = arrFrx(i) & ":" & arrFrx(i)
        clTo = arrTox(i) & ":" & arrTox(i)


        Columns(clFr).Cut

        Columns(clTo).Insert Shift:=xlToRight
    Next i

End Sub


Public Sub InsertCOLS(ByVal COLS_ARR$)

    If Trim(COLS_ARR) = "" Then Exit Sub
    Dim f
    f = Range(B_PLINE).Row


    Dim hd() As String
    Dim i%, Cl As String, x%
    hd = Split(COLS_ARR, ";")

    For i = LBound(hd) To UBound(hd)
        Cl = hd(i) & ":" & hd(i)
        Columns(Cl).Select
        Selection.Insert Shift:=xlToRight
        Range(hd(i) & f).Value = "NEU"
    Next i
End Sub

Private Sub ListeSortieren()

    Dim r As Range
    Dim r2 As Range

    Set r = Range(RFQ_ITEMS)
    Set r2 = Range(Range(B_PTAB).Cells(1, 1).Address)

    r.Select
    Selection.Sort Key1:=r2, Order1:=xlAscending, Header:=xlGuess, _
                   OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, _
                   DataOption1:=xlSortNormal
End Sub
Attribute VB_Name = "mdlGrafikEinbinden"
Option Explicit
Public Const LOGO_BILD As String = "C:\TEMP\Logo.jpg"


Public Function LogoEinbinden() As String
Attribute LogoEinbinden.VB_Description = "Makro am 15.10.2008 von tkm050 aufgezeichnet"
Attribute LogoEinbinden.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro1 Makro
' Makro am 15.10.2008 von tkm050 aufgezeichnet
'

    Dim bld As String

    If fso.FileExists(LINDE_LOGO) Then

        bld = LINDE_LOGO
        GoTo ausgang
    Else
        If fso.FileExists(LINDE_LOGO) Then

            bld = LINDE_LOGO2

        Else
            GoTo doIT
        End If


    End If


doIT:

    Dim objShape As Shape
    Dim myChart As Chart, myChartObject As ChartObject

    Set objShape = Worksheets("LOGO").Shapes("Bild 1")

    objShape.CopyPicture 2, -4147


    Set myChart = Charts.Add

    Set myChartObject = _
    ActiveChart.ChartObjects.Add(0, 0, 1, 1)

    myChartObject.Height = objShape.Height
    myChartObject.Width = objShape.Width

    With myChartObject.Chart
        .Paste
        '   .Export "C:\TEMP\logo.jpg", "JPG", True

        .CopyPicture xlScreen, xlBitmap, xlScreen


    End With


    Application.DisplayAlerts = False
    myChart.Delete
    Application.DisplayAlerts = True

    Set myChart = Nothing
    Set myChartObject = Nothing
    '


    Call mdlPicFromClipboard.GrafikZwischenablage2Datei(LOGO_BILD)
    bld = LOGO_BILD

ausgang:


    LogoEinbinden = bld

End Function
Sub Makro2()
Attribute Makro2.VB_Description = "Makro am 15.10.2008 von tkm050 aufgezeichnet"
Attribute Makro2.VB_ProcData.VB_Invoke_Func = " \n14"
'
' Makro2 Makro
' Makro am 15.10.2008 von tkm050 aufgezeichnet
'

'
    Range("G21").Select

    Selection.Copy
    Sheets("Tabelle2").Select
    Charts.Add
    ActiveChart.ChartType = xlColumnClustered
    ActiveChart.SetSourceData Source:=Sheets("Tabelle2").Range("A1")
    ActiveChart.Location Where:=xlLocationAsNewSheet
    Charts.Add
    ActiveChart.ChartArea.Select
    ActiveChart.Paste

    ActiveChart.Export "C:\temp\pic.jpg"

End Sub
Sub Makro4()
'
' Makro4 Makro
' Makro am 16.10.2008 von tkm050 aufgezeichnet
'

'
    With ActiveSheet.PageSetup
        .PrintTitleRows = ""
        .PrintTitleColumns = ""
    End With
    ActiveSheet.PageSetup.PrintArea = ""
    With ActiveSheet.PageSetup
        .LeftHeader = ""
        .CenterHeader = ""
        .RightHeader = ""
        .LeftFooter = ""
        .CenterFooter = ""
        .RightFooter = ""
        .LeftMargin = Application.InchesToPoints(0.787401575)
        .RightMargin = Application.InchesToPoints(0.787401575)
        .TopMargin = Application.InchesToPoints(0.984251969)
        .BottomMargin = Application.InchesToPoints(0.984251969)
        .HeaderMargin = Application.InchesToPoints(0.4921259845)
        .FooterMargin = Application.InchesToPoints(0.4921259845)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .PrintQuality = 600
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlPortrait
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = 100
        .PrintErrors = xlPrintErrorsDisplayed
    End With
End Sub

Sub Bild_erstellen()
    Dim myChart As Chart, myChartObject As ChartObject
    Dim int_with As Integer, int_hight As Integer
    Application.ScreenUpdating = False
    ActiveSheet.Shapes("Picture 1").Select
    Selection.CopyPicture Appearance:=xlScreen, format:=xlPicture

    int_with = Selection.Width - Selection.Width / 100 * 8
    int_hight = Selection.Height - Selection.Height / 100 * 8


    Set myChart = Charts.Add

    Set myChartObject = _
    ActiveChart.ChartObjects.Add(0, 0, int_with, int_hight)


    With myChartObject.Chart
        .Paste
        .Export Filename:="C:\TEMP\LindeLogo.jpg", FilterName:="JPG", Interactive:=False
    End With

    Application.DisplayAlerts = False
    myChart.Delete
    Application.DisplayAlerts = True

    Set myChart = Nothing
    Set myChartObject = Nothing
    Application.ScreenUpdating = True



    ActiveSheet.PageSetup.RightHeaderPicture.Filename = _
    "C:\TEMP\LindeLogo.jpg"

    With ActiveSheet.PageSetup
        .PrintTitleRows = ""
        .PrintTitleColumns = ""
    End With

    ActiveSheet.PageSetup.PrintArea = ""

    With ActiveSheet.PageSetup
        .LeftHeader = ""
        .CenterHeader = ""
        .RightHeader = "&G"
        .LeftFooter = ""
        .CenterFooter = ""
        .RightFooter = ""
        .LeftMargin = Application.InchesToPoints(0.787401575)
        .RightMargin = Application.InchesToPoints(0.787401575)
        .TopMargin = Application.InchesToPoints(0.984251969)
        .BottomMargin = Application.InchesToPoints(0.984251969)
        .HeaderMargin = Application.InchesToPoints(0.4921259845)
        .FooterMargin = Application.InchesToPoints(0.4921259845)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .PrintQuality = 600
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlPortrait
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = 100
        .PrintErrors = xlPrintErrorsDisplayed
    End With
End Sub



Attribute VB_Name = "mdlLangTexts"
Option Explicit

Public Const DE_TABL_TOT_PRICE_CAPT = "Netto Preis"
Public Const EN_TABL_TOT_PRICE_CAPT = "Net Price"


Public Const DE_FORM_CAPTION = "VAT- und Bruttopreisspalte einf|fffd|gen?"
Public Const DE_FORM_INFO_LABEL = "Einf|fffd|gen von VAT-Spalte(USt) + Brutto-Wert bitte H|fffd|kchen setzen und den Steuersatz eingeben..."
Public Const DE_FORM_CBX_LABEL = "Steuerspalte+Bruttopreis-Spalte einf|fffd|gen!"
Public Const DE_FORM_VAT_LABEL = "Steuersatz hier eintragen:"
Public Const DE_FORM_CMD_CAPT = "Best|fffd|tigen und schlie|fffd|en"


Public Const EN_FORM_CAPTION = "Insert VAT and Gross price columns?"
Public Const EN_FORM_INFO_LABEL = "Please set checkbox and input VAT-Percentage to insert VAT and Gross-Price Column."""
Public Const EN_FORM_CBX_LABEL = "Insert VAT + Grossprice column!"
Public Const EN_FORM_VAT_LABEL = "Enter VAT percentage here:"
Public Const EN_FORM_CMD_CAPT = "Confirm and close"




Public Const DE_SAVE_MSG_TEXT = "Die Positionsliste wurde unter nachfolgenden Dateinamen gespeichert:"
Public Const DE_SAVE_MSG_CAPT = "Positionsliste wurde gespeichert"
Public Const DE_FINAL_MSG_TEXT = "Bitte nun noch die nicht ben|fffd|tigten Spalten manuell entfernen."
Public Const DE_FINAL_MSG_CAPT = "Arbeit erledigt"


Public Const EN_SAVE_MSG_TEXT = "Itemlist has been saved as:"
Public Const EN_SAVE_MSG_CAPT = "Itemlist export saved"
Public Const EN_FINAL_MSG_TEXT = "Please delete not required columns manually"
Public Const EN_FINAL_MSG_CAPT = "Work finished"

'MsgBox txtDE & vbCrLf & txtEN & vbCrLf & vbCrLf & vbTab & FI_Na, vbOKOnly + vbInformation, _
 "Positionsliste gespeichert / Itemlist export saved)"

'MsgBox "Bitte nun noch die nicht ben|fffd|tigten Spalten manuell entfernen." & vbCrLf & _
 "Please delete not required columns manually.", vbOKOnly, "Arbeit erledigt / Work finished"

Attribute VB_Name = "mdlPicFromClipboard"
Option Explicit

' ACHTUNG : Einbindung der Excel-Objektbibliotek erforderlich (Extras-Verweise)
'           Einbindung der OLE-Automation erforderlich  (Extras-Verweise)
' getestet unter AC97 und AC2000

Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type

'Declare a UDT to store the bitmap information
Private Type uPicDesc
    Size As Long
Type As Long
    hPic As Long
    hPal As Long
End Type

'''Windows API Function Declarations

'Does the clipboard contain a bitmap/metafile?
Private Declare Function IsClipboardFormatAvailable Lib "user32" (ByVal wFormat As Integer) As Long

'Open the clipboard to read
Private Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long

'Get a pointer to the bitmap/metafile
Private Declare Function GetClipboardData Lib "user32" (ByVal wFormat As Integer) As Long

'Close the clipboard
Private Declare Function CloseClipboard Lib "user32" () As Long

'Convert the handle into an OLE IPicture interface.
Private Declare Function OleCreatePictureIndirect Lib "olepro32.dll" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long

'Create our own copy of the metafile, so it doesn't get wiped out by subsequent clipboard updates.
Declare Function CopyEnhMetaFile Lib "gdi32" Alias "CopyEnhMetaFileA" (ByVal hemfSrc As Long, ByVal lpszFile As String) As Long

'Create our own copy of the bitmap, so it doesn't get wiped out by subsequent clipboard updates.
Declare Function CopyImage Lib "user32" (ByVal handle As Long, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As Long

'The API format types we're interested in
Const CF_BITMAP = 2
Const CF_PALETTE = 9
Const CF_ENHMETAFILE = 14
Const IMAGE_BITMAP = 0
Const LR_COPYRETURNORG = &H4

Function PastePicture(Optional lXlPicType As Long = xlPicture) As IPicture

'Some pointers
    Dim h As Long, hPicAvail As Long, hPtr As Long, hPal As Long, lPicType As Long, hCopy As Long

    'Convert the type of picture requested from the xl constant to the API constant
    lPicType = IIf(lXlPicType = xlBitmap, CF_BITMAP, CF_ENHMETAFILE)

    'Check if the clipboard contains the required format
    hPicAvail = IsClipboardFormatAvailable(lPicType)

    If hPicAvail <> 0 Then
        'Get access to the clipboard
        h = OpenClipboard(0&)

        If h > 0 Then
            'Get a handle to the image data
            hPtr = GetClipboardData(lPicType)

            'Create our own copy of the image on the clipboard, in the appropriate format.
            If lPicType = CF_BITMAP Then
                hCopy = CopyImage(hPtr, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG)
            Else
                hCopy = CopyEnhMetaFile(hPtr, vbNullString)
            End If

            'Release the clipboard to other programs
            h = CloseClipboard

            'If we got a handle to the image, convert it into a Picture object and return it
            If hPtr <> 0 Then Set PastePicture = CreatePicture(hCopy, 0, lPicType)
        End If
    End If

End Function

Private Function CreatePicture(ByVal hPic As Long, ByVal hPal As Long, ByVal lPicType) As IPicture

' IPicture requires a reference to "OLE Automation"
    Dim r As Long, uPicInfo As uPicDesc, IID_IDispatch As GUID, IPic As IPicture

    'OLE Picture types
    Const PICTYPE_BITMAP = 1
    Const PICTYPE_ENHMETAFILE = 4

    ' Create the Interface GUID (for the IPicture interface)
    With IID_IDispatch
        .Data1 = &H7BF80980
        .Data2 = &HBF32
        .Data3 = &H101A
        .Data4(0) = &H8B
        .Data4(1) = &HBB
        .Data4(2) = &H0
        .Data4(3) = &HAA
        .Data4(4) = &H0
        .Data4(5) = &H30
        .Data4(6) = &HC
        .Data4(7) = &HAB
    End With

    ' Fill uPicInfo with necessary parts.
    With uPicInfo
        .Size = Len(uPicInfo)                                                   ' Length of structure.
        .Type = IIf(lPicType = CF_BITMAP, PICTYPE_BITMAP, PICTYPE_ENHMETAFILE)  ' Type of Picture
        .hPic = hPic                                                            ' Handle to image.
        .hPal = IIf(lPicType = CF_BITMAP, hPal, 0)                              ' Handle to palette (if bitmap).
    End With

    ' Create the Picture object.
    r = OleCreatePictureIndirect(uPicInfo, IID_IDispatch, True, IPic)

    ' If an error occured, show the description
    If r <> 0 Then Debug.Print "Create Picture: " & fnOLEError(r)

    ' Return the new Picture object.
    Set CreatePicture = IPic

End Function
Private Function fnOLEError(lErrNum As Long) As String

'OLECreatePictureIndirect return values
    Const E_ABORT = &H80004004
    Const E_ACCESSDENIED = &H80070005
    Const E_FAIL = &H80004005
    Const E_HANDLE = &H80070006
    Const E_INVALIDARG = &H80070057
    Const E_NOINTERFACE = &H80004002
    Const E_NOTIMPL = &H80004001
    Const E_OUTOFMEMORY = &H8007000E
    Const E_POINTER = &H80004003
    Const E_UNEXPECTED = &H8000FFFF
    Const S_OK = &H0

    Select Case lErrNum
    Case E_ABORT
        fnOLEError = " Aborted"
    Case E_ACCESSDENIED
        fnOLEError = " Access Denied"
    Case E_FAIL
        fnOLEError = " General Failure"
    Case E_HANDLE
        fnOLEError = " Bad/Missing Handle"
    Case E_INVALIDARG
        fnOLEError = " Invalid Argument"
    Case E_NOINTERFACE
        fnOLEError = " No Interface"
    Case E_NOTIMPL
        fnOLEError = " Not Implemented"
    Case E_OUTOFMEMORY
        fnOLEError = " Out of Memory"
    Case E_POINTER
        fnOLEError = " Invalid Pointer"
    Case E_UNEXPECTED
        fnOLEError = " Unknown Error"
    Case S_OK
        fnOLEError = " Success!"
    End Select

End Function

Public Function GrafikZwischenablage2Datei(DatName As String) As Boolean
    Dim lPicType As Long, oPic As Variant
    lPicType = xlBitmap
    Set oPic = PastePicture(lPicType)
    If oPic Is Nothing Then Exit Function
    SavePicture oPic, DatName
    GrafikZwischenablage2Datei = True
End Function
Attribute VB_Name = "mdlVERSION"
Option Explicit

Private Const MAKRO_VERSION$ = "3.0.2"


Public Function getVersionInfo() As String

    Dim vinfo$
    vinfo = _
    "VERSION: " & vbTab & MAKRO_VERSION & vbCrLf

    getVersionInfo = vinfo

End Function


'## |fffd|nderungslog ##
'' -> Neue Versionen immer on Top <- ''


'** Version 1.4
'
' -> Einf|fffd|gen des LOGOS optimiert
'##Sollte der Server nicht zur Verf|fffd|gung stehen, wird das Logo aus der Datei in C:TEMP gespeichert _
 und in den Seitenkopf eingef|fffd|gt
'
'** Ende Version



'** Version 1.3
'
' -> Optimierung der Anzeige und Geschwindigkeit
' -> Fehler behoben beim Abspeichern - Datei wurde nicht ge|fffd|ffnet
' -> Fehler beim Einf|fffd|gen des LOGOS
'##Testweise wurde eine Bedingung eingebaut - wenn _
 das Logo existiert wird es angezogen _
 Ausserdem wurde 'On Error Resume Next eingebaut _
 damit bei einem Fehler weitergelaufen wird...
'
'** Ende Version

'** Version 1.1
'
' -> Die wichtigsten Punkte der Formatierung sind implementiert
'
'** Ende Version



'** Version 1.0
'
' -> Implementierung der Positionsdrucktabelle gestartet.
'
'** Ende Version



'## ENDE Versionslog
Attribute VB_Name = "mdlVariablen"
Option Explicit


'## Konstanten ##
Public Const FILE_LANG = "EN"
Public Const ZOOM_STUFE As Byte = 85
Public Const FIXIEREN_SPALTE As Byte = 5




Public Const MAIL_REC$ = "florian.gratzl@linde-le.com"
Public Const MAIL_TEXT$ = _
       "WRITE PROTECTION PASSWORD FOR ABOVE INQUIRY NO:" & vbCrLf & vbCrLf & _
       "<PW>"






'* Linde Head Bez|fffd|ge *

Public Const LH_PONR_ADR$ = "B1"
Public Const LH_PROJNR_ADR$ = "B2"
Public Const LH_PROJNM_ADR$ = "B3"

Public Const LH_PONR_ADR_CAP$ = "A1"
Public Const LH_PROJNR_ADR_CAP$ = "A2"
Public Const LH_PROJNM_ADR_CAP$ = "A3"

Public Const LH_PONO_CAP_VAL$ = "Purchase Order No."
Public Const LH_PROJNR_CAP_VAL$ = "Project No."
Public Const LH_PROJNM_CAP_VAL$ = "Project Name"

Public Const LH_SUBM_ADR_N$ = "B2"
Public Const LH_PROJNR_ADR_N$ = "B3"
Public Const LH_PROJNM_ADR_N$ = "B4"

Public Const LH_SUBM_NM$ = "PONR"
Public Const LH_PROJNR_NM$ = "PROJNR"
Public Const LH_PROJNM_NM$ = "PROJNM"


Public Const LH_PONR_ADR_CAP_N$ = "A1"
Public Const LH_PROJNR_ADR_CAP_N$ = "A2"
Public Const LH_PROJNM_ADR_CAP_N$ = "A3"

Public Const LH_RANGE = "$A$1:$C$4"
Public Const LH_RNG_NAME = "LINDE_HEAD"



Public Const POSTAB_H_ORIENTATION As Integer = 0
Public Const LINDE_LOGO$ = "\\D1S07\UPGM\LOGOS\jpg-Format\Linde_DesignModule_6-3_Farbe.jpg"
Public Const LINDE_LOGO2$ = "\\D1S07.le.grp\UPGM\LOGOS\jpg-Format\Linde_DesignModule_6-3_Farbe.jpg"

'Public Const LINDE_LOGO$ = "C:\Documents and Settings\tkm050\My Documents\LINDE\LE_DesignModul_RGB.jpg"



'Bereichsbenennung
Public Const B_HEADER = "HEADER_TAB"
Public Const B_PLINE = "POSITION_LINE"
Public Const B_PTAB = "POSITION_TAB"
Public Const RFQ_ITEMS = "RFQ_ITEMS"

'//Public Const B_ACAPT = "LINDE_ADDON_CAPTION"
'//Public Const B_ADATA = "LINDE_ADDON_DATA"

'## Variablen ##

Public ALLOW_MULTI_SELECT As Boolean
Public strPO_No$
Public strProjektNr$
Public strProjektName$
Public intQtyCol As Integer
Public intDescriptCol As Integer


Public pwx As String


Public strType As String * 1


Public rng_LH As Range
Public rng_BH As Range
Public rng_PR As Range
Public rng_TAB As Range


Public filenm$

Public fso As New FileSystemObject


Public USER_LANG As String * 2





Attribute VB_Name = "mdl_01_Start"
Option Explicit

Dim fso As New FileSystemObject
Dim WSH As New IWshShell_Class

Public VATX As Boolean
Public VAT As Boolean
Public VAT_Perc As Single

Private Const VAT_COLS_I = "T:U"

Private PO_No As String
Private PO_Vs As String

Private PR_No As String
Private PR_Na As String

Private FI_Na As String
Private Const FI_Pa As String = "X:\PO_ITEMLIST\"
Private Const PO_NO_ROW As Integer = 5
Private Const CAPT_ROW As Integer = 6
Private Const TITLE_ROWS = "$" & CAPT_ROW & ":$" & CAPT_ROW
Private Const DATA_START_ROW As Integer = CAPT_ROW + 1
Private Const DIFF_MENGE_COL_INDEX As Integer = 16
Private Const CHECK_COLS_NEGATIVE As String = "P;S;T;Z"
Private Const COLS_SET_ZERO_TO_NULL As String = "Q;R;S;Z"


'* Hier wird die eigentliche Arbeit an die Teilmodule/-makros weitergereicht



Public Sub StartWork()
    On Error Resume Next


    'Stop

    USER_LANG = getUsersLanguage()

    Call getVAT


    Application.ScreenUpdating = False


    '* Einlesen der Kopfdaten
    Call EinlesenKopfdaten
    ''Nach/mit dem Einlesen der Kopfdaten, wird die Spalte A gel|fffd|scht _
     und der neue Kopf geschrieben. Der Aufruf geschieht im Sub _
     EinlesenKopfdaten.

    '*|fffd|bersetzen Spalten|fffd|berschriften


    Call translate_TAB

    If VAT Then

        Call INSERT_VAT(VAT_Perc, VAT_COLS_I)
    End If




    '* Formatierung
    Call Formatieren_Main





    '* Seite einrichten
    Call Main_SiteSetup

    On Error Resume Next
    Application.DisplayAlerts = False
    Sheets("TRANSLATE").Delete
    Sheets("LOGO").Delete
    Application.DisplayAlerts = True


    Application.ScreenUpdating = True

    Range("A7").Select
    ActiveWindow.FreezePanes = True

    Application.ScreenUpdating = True
    '* Speichern
    Range("A" & DATA_START_ROW).Select

    Call SaveTable


    '
    Workbooks.Open FI_Na
    '
    ThisWorkbook.Close False

End Sub



Private Sub EinlesenKopfdaten()

    PO_No = Range("A" & PO_NO_ROW).Value
    PO_Vs = Range("C1")
    PR_No = Range("B1")
    PR_Na = Range("B2")

    Range("A1:C2").ClearContents

    Call setFileName
    Call Kopfdaten_NeuSchreiben


End Sub
Private Sub setFileName()
    FI_Na = getMyFilename()

End Sub

Private Function getMyFilename() As String
    On Error GoTo fehler

    Dim MAIL_BETR$, Mail_ATT$
    Dim fo As Folder
    Dim fx As String



    Const SLW = FI_Pa    '"X:\"    ' // Standardlaufwerk
    Dim fl$, x
    Dim fn$
    Dim r As Range
    'Set r = Range(B_HEADER)
    Dim dat$

    dat = format(Date, "ddmmyyyy") & "_" & format(Time, "hhnnss")    'format(Time, "hhnnss")

    If fso.FolderExists(SLW) Then
        fl = SLW
    Else
        Call fso.CreateFolder(SLW)


        'If Dir(SLW, vbDirectory) = "" Then


        fl = SLW


passt:

    End If



    Dim pono$, datx$, langx$, appendix$

    pono = PO_No & "_"


    langx = FILE_LANG & "_"

    datx = dat
    appendix = ""    'NewGUID_FN

    fn = pono & _
         langx & _
         datx & _
         appendix & ".xls"



    fn = fl & IIf(Right(fl, 1) = "\", "", "\") & fn

    If fso.FileExists(fn) Then
        Kill fn
    End If

    Do While InStrRev(fn, "__") >= 1

        fn = Replace(fn, "__", "_")
    Loop




    getMyFilename = fn

    Exit Function
fehler:
    fx = getSavingFolder


    Do While Not fso.FolderExists(fx)
        MsgBox "You did not choose a valid folder!" & vbCrLf & _
               "Please select a folder to save the Item List into!", vbExclamation, "Select a folder"
        fx = getSavingFolder
    Loop
    fl = fx
    GoTo passt

End Function


Private Function getSavingFolder() As String
    Dim fold
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFolderPicker)


    With fd

        .AllowMultiSelect = False
        .ButtonName = "Select"
        .InitialView = msoFileDialogViewList
        .Title = "Select folder to save in"
        .Show

        If .SelectedItems.Count = 0 Then
            getSavingFolder = "": Exit Function
        End If

        For Each fold In .SelectedItems
            getSavingFolder = fold
            Exit Function
        Next fold


    End With





End Function




Private Sub Kopfdaten_NeuSchreiben()


'L|fffd|schen der Spalte A (Noch der Einkaufsbeleg)
    Call gen_deleteColumns("A")

    'Einf|fffd|gen von 2 neuen Zeilen damit Platz f|fffd|r die neue _
     Kopfleiste geschaffen wird
    Rows("1:2").Insert Shift:=xlDown


    'Jetzt wird endlich die neue Kopfleiste geschrieben
    '' Captions
    Range("A1").Value = "P.O. No.:"
    Range("A2").Value = "Project No.:"
    Range("A3").Value = "Project Name:"
    Range("A4").Value = "Filename:"
    Range("A1:B1").Merge
    Range("A2:B2").Merge
    Range("A3:B3").Merge
    Range("A4:B4").Merge


    Range("C1").Value = PO_No & " / Version: " & PO_Vs
    Range("C2").Value = PR_No
    Range("C3").Value = PR_Na
    Range("C4").Value = FI_Na
    Range("C1:D1").Merge
    Range("C2:D2").Merge
    Range("C3:G3").Merge
    Range("C4:G4").Merge




End Sub
Public Sub gen_deleteColumns(ByVal COLS_DEL$)
    If Trim(COLS_DEL) = "" Then Exit Sub


    Dim hd() As String
    Dim i%, Cl As String, x%
    hd = Split(COLS_DEL, ";")
    '    Columns("F:F").Delete Shift:=xlToLeft




    For i = UBound(hd) To LBound(hd) Step -1
        Cl = hd(i)
        x = Range(Cl & 1).Column
        'Columns(x).ColumnWidth = 10.71
        'Columns(x).EntireColumn.Hidden = True
        Columns(x).Delete Shift:=xlToLeft

    Next i


End Sub

Public Function getPrintArea() As String
    Dim r_l As Long

    Dim c_l As Integer

    c_l = getLastCol(CAPT_ROW)
    r_l = getLastRow()


    Dim fCell As String, lCell As String
    Dim xcell As String

    fCell = Cells(DATA_START_ROW, 1).Address
    lCell = Cells(r_l, c_l).Address
    xcell = fCell & ":" & lCell
    getPrintArea = xcell


End Function
Private Function getFormatArea() As String


    Dim r_l As Long

    Dim c_l As Integer

    c_l = getLastCol(CAPT_ROW)
    r_l = getLastRow()


    Dim fCell As String, lCell As String
    Dim xcell As String

    fCell = Cells(CAPT_ROW, 1).Address
    lCell = Cells(r_l, c_l).Address
    xcell = fCell & ":" & lCell
    getFormatArea = xcell




End Function

Public Function getLastCol(ByVal Rw As Long) As Integer

    Dim i As Integer
    i = 1
    Do While Not Cells(Rw, i).Value = ""


        i = i + 1
    Loop

    getLastCol = i - 1

End Function



Public Function getLastRow(Optional ByVal Cl As Integer = 1) As Long
    Dim i As Long

    i = 65536

    Do While Cells(i, Cl) = ""
        If i = 1 Then Exit Do
        i = i - 1
    Loop

    getLastRow = i


End Function




Private Sub Main_SiteSetup()

'** Seite einrichten (Ausrichtung, Papierformat etc)
    On Error Resume Next
    With ActiveSheet.PageSetup.RightHeaderPicture

        .Filename = mdlGrafikEinbinden.LogoEinbinden()
        .Height = 25
        .Width = 100

    End With

    With ActiveSheet.PageSetup
        .PrintTitleRows = TITLE_ROWS
        '.PrintTitleColumns = "$A:$C"
        .PrintArea = getPrintArea()    'Range(ADD_TOTAL_PRICE_NAM, RFQ_ITEMS).Address
    End With


    '    Public Const LH_PROJNR_CAP_VAL$ = "Project No."
    'Public Const LH_PROJNM_CAP_VAL$ = "Project Name"
    'Public Const LH_SUBM_CAP_VAL$ = "Inquiry No."

    With ActiveSheet.PageSetup
        .LeftHeader = _
        "&""Arial,Fett""&12" & LH_PONO_CAP_VAL & vbTab & vbTab & PO_No & " / Version: " & PO_Vs & Chr(10) & _
                      "&""Arial,Standard""&10" & LH_PROJNR_CAP_VAL & vbTab & PR_No & Chr(10) & _
                      LH_PROJNM_CAP_VAL & vbTab & PR_Na

        .CenterHeader = ""
        .RightHeader = "&G"
        .LeftFooter = "File:" & vbTab & FI_Na
        .CenterFooter = "- [&P] -"
        .RightFooter = "&D"

        .LeftMargin = Application.InchesToPoints(0.393700787401575)   '// Linker Seitenrand: 1 cm
        .RightMargin = Application.InchesToPoints(0.393700787401575)  '// Rechter Seitenrand: 1 cm
        .TopMargin = Application.InchesToPoints(1.63)                 '// Oberer Seitenrand: 4,1 cm
        '.TopMargin = Application.InchesToPoints(1.18110236220472)     '// Oberer Seitenrand: 3 cm
        .BottomMargin = Application.InchesToPoints(0.590551181102362)    '// Unterer Seitenrand: 1,5 cm
        .HeaderMargin = Application.InchesToPoints(0.118110236220472)    '// Header Seitenrand: 0,3 cm
        .FooterMargin = Application.InchesToPoints(0.118110236220472)    '// Footer Seitenrand: 0,3cm
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlLandscape
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .PrintErrors = xlPrintErrorsDisplayed
    End With




End Sub

Private Sub SaveTable()
'
    ActiveWorkbook.SaveCopyAs FI_Na




    Dim txtSave$, cptSave$
    Dim txtFin$, cptFin$
    If USER_LANG = "DE" Then
        txtSave = DE_SAVE_MSG_TEXT
        cptSave = DE_SAVE_MSG_CAPT
        txtFin = DE_FINAL_MSG_TEXT
        cptFin = DE_FINAL_MSG_CAPT

    Else
        txtSave = EN_SAVE_MSG_TEXT
        cptSave = EN_SAVE_MSG_CAPT
        txtFin = EN_FINAL_MSG_TEXT
        cptFin = EN_FINAL_MSG_CAPT


    End If



    MsgBox txtSave & vbCrLf & vbCrLf & vbTab & FI_Na, vbOKOnly + vbInformation, _
           cptSave

    MsgBox txtFin, vbOKOnly, cptFin



End Sub


Private Function getCaptLine() As String
    Dim r_l As Long

    Dim c_l As Integer

    c_l = getLastCol(CAPT_ROW)



    Dim fCell As String, lCell As String
    Dim xcell As String

    fCell = Cells(CAPT_ROW, 1).Address
    lCell = Cells(CAPT_ROW, c_l).Address
    xcell = fCell & ":" & lCell
    getCaptLine = xcell

End Function
Public Sub translate_TAB()




    Dim r1t As Range, r2t As Range, lfat As Range
    Dim i

    Const E_col_t = 4
    Const P_col_t = 5




    Set r2t = Range(getCaptLine())


    Const TABL = "TRANSLATE!"
    Const TA_Rn = "$A$2:$C$33"
    Dim rn As Range
    Set rn = Range(TABL & TA_Rn)

    Dim C_TAB_CAPTION As Integer


    C_TAB_CAPTION = 3


    Set r2 = Range(getCaptLine())


    'TAB |fffd|BERSETZEN
    For i = 1 To r2t.Columns.Count
        r2.Cells(1, i).Value = ftranslate_TAB(rn, C_TAB_CAPTION, i)
    Next i

    Debug.Print i


End Sub

Private Function ftranslate_TAB(rn As Range, ByVal col As Integer, ByVal idx As Integer) As String
    Dim wd$
    Dim i
    i = 1
    Do Until rn.Cells(i, 1) = ""
        If rn.Cells(i, 1).Value = idx Then
            wd = rn.Cells(i, col).Value
            GoTo ausg    'Exit Do
        End If

        'Debug.Print rn.Cells(i, 1).Address & ": " & rn.Cells(i, 1).Value

        i = i + 1
    Loop
ausg:
    ftranslate_TAB = wd

End Function


Private Sub Formatieren_Main()

    Call Formatieren_List
    Call Formatieren_Header


    Cells.EntireRow.AutoFit
    Cells.EntireColumn.AutoFit


    '    Call FixCols  '// Spalten fixieren
    '


    Call CHECK_4_NEGATIVES
    '** wird eigentlich mehr ben|fffd|tigt, da die Werte aus dem SAP jetzt _
     als Zahl kommen.

    Call SET_ZERO_TO_NULL

    Cells.EntireRow.AutoFit
    Cells.EntireColumn.AutoFit









End Sub
Private Sub SET_ZERO_TO_NULL()
    Dim z As Long
    Dim x() As String
    x = Split(COLS_SET_ZERO_TO_NULL, ";")
    Dim rx As String
    Dim rBas As Range

    Dim rowStart As Long
    Dim rowEnd As Long

    Dim ry_a As String
    Dim ry As Long

    rx = getPrintArea
    Set rBas = ActiveSheet.Range("Tabelle1!" & rx)
    rowStart = rBas.Row
    rowEnd = rowStart + rBas.Rows.Count - 1
    Dim r As Long
    Set rBas = Nothing


    Dim valx As Double


    For z = LBound(x) To UBound(x)

        r = rowStart

        Do While r <= rowEnd
            'If InStrRev(Range(x(z) & r).Value, "-") > 0 Then

            'Range(x(z) & r).Value = getCleanNo(Range(x(z) & r).Value) ' * -1
            'Columns(x(z) & ":" & x(z)).ColumnWidth = 50
            If Range(x(z) & r).Value = 0 Then
                Range(x(z) & r).Value = ""
            End If

            ' End If

            r = r + 1
        Loop

    Next z

End Sub
Private Function getCleanNo(ByVal NumberFromString As String) As Double
    Dim commax As Long
    Dim mainx As String
    Dim meintemp As String
    Dim i As Long

    Dim erg As Double

    Dim tempstr As String
    Dim tempneg As String * 1
    If InStrRev(NumberFromString, "-") >= 1 Then
        tempneg = "-"
        NumberFromString = Replace(NumberFromString, "-", "")
    Else
        tempneg = ""
    End If

    If InStrRev(NumberFromString, ",") > 1 Then
        '    If (Left(Right(NumberFromString, 3), 1) = ",") And _
             '       InStrRev(NumberFromString, ".") > 1 Then
        commax = Mid(NumberFromString, InStrRev(NumberFromString, ",") + 1)
        mainx = Left(NumberFromString, InStrRev(NumberFromString, ",") - 1)


        For i = 1 To Len(mainx)
            If IsNumeric(Mid(mainx, i, 1)) Then
                meintemp = meintemp & Mid(mainx, i, 1)
            End If
        Next i

    Else

        '    If (Left(Right(NumberFromString, 3), 1) = ",") And _
             '       InStrRev(NumberFromString, ".") > 1 Then
        commax = 0
        mainx = NumberFromString

        For i = 1 To Len(mainx)
            If IsNumeric(Mid(mainx, i, 1)) Then
                meintemp = meintemp & Mid(mainx, i, 1)
            End If
        Next i
    End If

    tempstr = tempneg & meintemp & "," & commax
    erg = tempstr
    getCleanNo = erg



End Function
Public Sub CHECK_4_NEGATIVES()
    Dim z As Long
    Dim x() As String
    x = Split(CHECK_COLS_NEGATIVE, ";")
    Dim rx As String
    Dim rBas As Range

    Dim rowStart As Long
    Dim rowEnd As Long

    Dim ry_a As String
    Dim ry As Long

    rx = getPrintArea
    Set rBas = ActiveSheet.Range("Tabelle1!" & rx)
    rowStart = rBas.Row
    rowEnd = rowStart + rBas.Rows.Count - 1
    Dim r As Long
    Set rBas = Nothing


    Dim valx As Double


    For z = LBound(x) To UBound(x)

        r = rowStart

        Do While r < rowEnd
            'If InStrRev(Range(x(z) & r).Value, "-") > 0 Then

            'Range(x(z) & r).Value = getCleanNo(Range(x(z) & r).Value) ' * -1
            Columns(x(z) & ":" & x(z)).ColumnWidth = 50

            Range(x(z) & r).NumberFormat = "#,##0.00;[Red]-#,##0.00"
            ' End If

            r = r + 1
        Loop

    Next z


End Sub
Private Sub Formatieren_List()
    On Error Resume Next
    Dim fArea As String
    Dim pArea As String
    fArea = getFormatArea()
    pArea = getPrintArea()

    Range(fArea).AutoFormat xlRangeAutoFormatClassic3
    Range(pArea).Interior.ColorIndex = xlNone
    Range(pArea).Columns(DIFF_MENGE_COL_INDEX).Interior.Color = vbYellow

    Range(fArea).AutoFilter


    With Range(pArea)

        .Borders(xlDiagonalDown).LineStyle = xlNone
        .Borders(xlDiagonalUp).LineStyle = xlNone
        .Borders(xlEdgeLeft).LineStyle = xlNone
        .Borders(xlEdgeTop).LineStyle = xlNone

        .Borders(xlEdgeRight).LineStyle = xlNone
        With .Borders(xlInsideVertical)
            .LineStyle = xlDot
            .Weight = xlThin
            .ColorIndex = xlAutomatic
        End With


        With .Borders(xlEdgeBottom)
            .LineStyle = xlContinuous
            .Weight = xlThick
            .ColorIndex = xlAutomatic
        End With


        With .Borders(xlInsideHorizontal)
            .LineStyle = xlDot
            .Weight = xlThin
            .ColorIndex = xlAutomatic
        End With
    End With

    Range(fArea).Rows(1).HorizontalAlignment = xlLeft



End Sub
Private Sub Formatieren_Header()
    Range("A1:G4").AutoFormat xlRangeAutoFormatClassic3
    Range("A1:G4").HorizontalAlignment = xlLeft

End Sub

Private Sub FixCols()

    With ActiveWindow
        .DisplayGridlines = True
        .DisplayHeadings = True
    End With


    'Fensterinhalt fixieren
    Range(getPrintArea()).Cells(1, FIXIEREN_SPALTE).Select
    ActiveWindow.FreezePanes = True




End Sub







Public Function getVAT() As Single
    VATX = False


    Call frmVAT_GrossPrice.Show(1)


    If VATX Then
        getVAT = VAT_Perc
    Else
        getVAT = 0#
    End If




End Function

Public Sub INSERT_VAT(ByVal xVAT_PERC As Single, Optional ByVal vInsertCOLS As String = VAT_COLS_I)

    Dim lR As Long
    lR = getLastRow()
    Dim pC As Variant
    Dim rC As Variant


    Dim Formulax$
    Dim i&
    Dim x As Variant
    x = Split(vInsertCOLS, ":")

    Columns(vInsertCOLS).Select
    Selection.Insert Shift:=xlToRight



    pC = Range(x(LBound(x)) & CAPT_ROW).Column
    pC = Cells(CAPT_ROW, pC - 1).Address
    pC = Replace(Left(pC, InStrRev(pC, "$")), "$", "")

    rC = Range(x(LBound(x)) & CAPT_ROW).Column
    rC = Cells(CAPT_ROW, rC - 2).Address
    rC = Replace(Left(rC, InStrRev(rC, "$")), "$", "")

    Range(pC & CAPT_ROW).Value = EN_TABL_TOT_PRICE_CAPT
    Range(x(LBound(x)) & CAPT_ROW).Value = "VAT" & vbCrLf & Round(xVAT_PERC, 2) & " %"
    Range(x(UBound(x)) & CAPT_ROW).Value = "Gross Price" & vbCrLf & "incl. VAT"


    i = DATA_START_ROW

    Do While i <= lR
        Formulax = "=ROUND(" & pC & i & "*(" & Replace(xVAT_PERC, ",", ".") & "/100),2)"
        'Debug.Print Formulax

        Range(x(LBound(x)) & i).Formula = Formulax



        Range(x(UBound(x)) & i).Formula = "=" & pC & i & "+" & x(LBound(x)) & i


        'Range(x(LBound(x)) & i).Value = xVAT_PERC
        'Range(x(UBound(x)) & i).Formula = "=" & pC & i & "+(" & pC & i & "*" & x(LBound(x)) & i & "/100)"

        Range(x(LBound(x)) & i).NumberFormat = "#,##.00"

        Range(x(UBound(x)) & i).NumberFormat = "#,##.00"


        i = i + 1
    Loop

    Range(pC & (lR + 1)).Formula = "=SUM(" & pC & DATA_START_ROW & ":" & pC & lR & ")"

    Range(x(LBound(x)) & (lR + 1)).Formula = "=SUM(" & x(LBound(x)) & DATA_START_ROW & ":" & x(LBound(x)) & lR & ")"
    Range(x(UBound(x)) & (lR + 1)).Formula = "=SUM(" & x(UBound(x)) & DATA_START_ROW & ":" & x(UBound(x)) & lR & ")"

    With Range(pC & (lR + 1) & ":" & x(UBound(x)) & (lR + 1))

        .NumberFormat = "#,##0.00"
        .Font.Bold = True


    End With


    Range(rC & (lR + 3) & ":" & pC & (lR + 3)).Merge

    With Range(rC & (lR + 3))
        .Value = "Total Order Value incl. " & xVAT_PERC & "% VAT:"
        .HorizontalAlignment = xlRight
        .Font.Bold = True

    End With

    Range(x(LBound(x)) & (lR + 3)).Formula = "=" & pC & (lR + 1) & "+" & x(LBound(x)) & (lR + 1)
    Range(x(LBound(x)) & (lR + 3)).Font.Bold = True
    Range(x(LBound(x)) & (lR + 3)).NumberFormat = "#,##0.00"

    Range(pC & DATA_START_ROW & ":" & x(UBound(x)) & lR + 1).Interior.ColorIndex = 38


End Sub


' InQuest injected base64 decoded content
' jwRz
' *^r'
' )j[^

INQUEST-PP=macro
