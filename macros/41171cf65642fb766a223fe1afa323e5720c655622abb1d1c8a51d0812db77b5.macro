Attribute VB_Name = "Mod3Outros3"
Option Explicit
Declare Function GetFocus Lib "user32" () As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Function ExtractIcon Lib "Shell32.dll" Alias "ExtractIconA" (ByVal hInst As Long, ByVal lpszExeFileName As String, ByVal nIconIndex As Long) As Long
Declare Function DestroyIcon Lib "user32" (ByVal hIcon As Long) As Long
Declare Function SetFocusAPI Lib "user32" Alias "SetFocus" (ByVal hWnd As Long) As Long
'
' API Constants
Global Const WM_SETICON = &H80
'
' Various Windows Handles
Dim hPreviousXLMAINBigIcon As Long
Dim hPreviousXLMAINSmallIcon As Long
Dim hPreviousEXCEL9BigIcon As Long
Dim hPreviousEXCEL9SmallIcon As Long
Dim hNewIcon As Long
Dim hWndXLMAIN As Long
Dim hWndEXCEL9 As Long

Dim theIconSource As String

Function SetPerceptorIcon() As Boolean    'No 2013 SDI, foi necess|fffd|rio aqui tambem para cada janela de wb aberto. Nas vers|fffd|es anteriores s|fffd| existia e era suficiente em cpap.xla. Aqui |fffd| chamado s|fffd| de pri.
    Dim theIconIndex As Long
    Dim istat As Long

    theIconSource = ThisWorkbook.Path & "\Applicat1.ico"    ' can be any valid windows icon source(.EXE, .DLL, .ICO)
    If Dir(theIconSource) = "" Then theIconSource = ThisWorkbook.Path & "\config.exe"
    If Dir(theIconSource) = "" Then MsgBox "Arquivo de |fffd|cone n|fffd|o encontrado!", vbCritical, "CPAP|fffd| - Error!": Exit Function

    theIconIndex = 0    'the index to the icon within the source. If this index is 0, the ExtractIcon function returns the first icon in the source

    istat = SetNewIcon(theIconSource, theIconIndex)    ' do the deed
    SetPerceptorIcon = True
End Function

'   A routine to change the standard Excel Icons
Function SetNewIcon(theIconSource As String, theIconIndex As Long) As Long
    Dim L As Long
    ' Get handle to active window (Classname XLMAIN).
    If Val(Application.Version) > 9 Then hWndXLMAIN = Application.hWnd Else hWndXLMAIN = FindWindow("XLMAIN", Application.Caption)
    L = SetFocusAPI(hWndXLMAIN)
    hWndEXCEL9 = GetFocus()
    ' Getthe icon from the source
    hNewIcon = ExtractIcon(0, theIconSource, 0)
    SetNewIcon = hNewIcon                       ' return code from function
    If hNewIcon = Null Or hNewIcon = 1 Then MsgBox "|fffd|cone n|fffd|o encontrado! No arquivo " & theIconSource, vbCritical, "CPAP|fffd| - Error!": Exit Function         ' 1 means invalid icon source, 0means no icons in source

    hPreviousXLMAINBigIcon = SendMessage(hWndXLMAIN, WM_SETICON, 1, hNewIcon)  ' Big Icon
    hPreviousXLMAINSmallIcon = SendMessage(hWndXLMAIN, WM_SETICON, 0, hNewIcon)    ' Small Icon
    hPreviousEXCEL9BigIcon = SendMessage(hWndEXCEL9, WM_SETICON, 1, hNewIcon)  ' Big Icon
    hPreviousEXCEL9SmallIcon = SendMessage(hWndEXCEL9, WM_SETICON, 0, hNewIcon)    ' Small Icon
TidyUp:
End Function
'
'   A routine to restore the standard Excel Icons
Sub restoreXLIcon()
    Dim hIcon As Long
    Dim lRetv As Long

    hIcon = SendMessage(hWndXLMAIN, WM_SETICON, True, hPreviousXLMAINBigIcon)     ' restore Big Icon
    hIcon = SendMessage(hWndXLMAIN, WM_SETICON, False, hPreviousXLMAINSmallIcon)  ' restore Small Icon
    hIcon = SendMessage(hWndEXCEL9, WM_SETICON, True, hPreviousEXCEL9BigIcon)     ' restore Big Icon
    hIcon = SendMessage(hWndEXCEL9, WM_SETICON, False, hPreviousEXCEL9SmallIcon)  ' restore Small Icon
    lRetv = DestroyIcon(hIcon)      ' I think this is necessary to free memory reserved in ExtractIcon

End Sub

'From Bill Manville (Re: Message)
'MVP - Microsoft Excel, Oxford, England
'===============

Attribute VB_Name = "Mod3Outros4"
Option Explicit
'Para detectar a Janela VBE aberta via API
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hWnd As Long, lpdwProcessId As Long) As Long
Declare Function EnumThreadWindows Lib "user32" (ByVal dwThreadId As Long, ByVal lpfn As Long, ByVal lParam As Long) As Long
Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Declare Function IsWindowVisible Lib "user32" (ByVal hWnd As Long) As Long
Declare Function GetActiveWindow Lib "user32" () As Long   'Janela em foco no THEREAD que chamou
Declare Function GetForegroundWindow Lib "user32" () As Long    'Janela em o foco no WINDOWS
Dim ThreadCount As Integer                                 ' Number of Thread Windows
Public bVBEwinVis As Boolean: Dim VBE_hWnd As Long

'Para detectar VbExe running
'Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
'Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
'Const PROCESS_ALL_ACCESS = &H1F0FFF
Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Const GWL_HINSTANCE = (-6)

'Para EnableExc7Verif
Public Declare Function EnumChildWindows Lib "user32" (ByVal hWndParent As Long, ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long
Private Declare Function SendMessageByStr& Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String)
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Const GWL_ID = (-12)
Private Const WM_SETTEXT = &HC
Private Const WM_GETTEXT = &HD
Dim lExc7Verif As String '(Long)
Dim lControlId As Long, lCntCallExc7Vrf As Long
Public bOffTmpExc7Verif As Boolean

Function IsVBEVisible() As Boolean    'Para facilitar eventuais manuten|fffd||fffd|o, mantive todo o c|fffd|digo feito nos toEXE.
'Foi necess|fffd|rio porque .MainWindow.Visible d|fffd| erro, se o acesso ao VBE is not trustee no Office 10 em
'diante. Neste caso, mesmo aberto, retorna false. Deixei assim mesmo e, em caso de erro, melhorei usando API.
    Dim RetVal As Long: Dim ExcelObj As Application: Dim dHostAppVer As Long: Dim App_hWnd As Long: Set ExcelObj = Application: dHostAppVer = Val(ExcelObj.Version): If dHostAppVer > 9 Then App_hWnd = ExcelObj.hWnd Else App_hWnd = FindWindow("XLMAIN", ExcelObj.Caption)

    If VBE_hWnd <> 0 Then                                  'Se o handle do VBE j|fffd| tiver sido detectado, fica mais e menos intrusivo confirmar e acompanhar por ele e evita um AddressOf.
        Dim WinClassBuf As String * 255
        RetVal = GetClassName(VBE_hWnd, WinClassBuf, 255)
        If Left(WinClassBuf, RetVal) = "wndclass_desked_gsk" Then
            IsVBEVisible = IsWindowVisible(VBE_hWnd) <> 0
            Exit Function
        End If
    End If

    On Error Resume Next
    IsVBEVisible = ExcelObj.VBE.MainWindow.Visible

    If (Err.Number <> 0 And dHostAppVer > 9) Or (IsVBEVisible And VBE_hWnd = 0) Then    'Tentar API para melhorar. A segunda condi|fffd||fffd|o |fffd| para controle pelo handle, se v|fffd|sivel.
        Dim lParam As Long, ProcessID As Long, ThreadID As Long
        ThreadID = GetWindowThreadProcessId(App_hWnd, ProcessID)
        RetVal = EnumThreadWindows(ThreadID, AddressOf EnumThreadProc, lParam)
        IsVBEVisible = bVBEwinVis
    End If
End Function

'Para detectar a Janela VBE aberta via API
Function EnumThreadProc(ByVal lhWnd As Long, ByVal lParam As Long) As Long
    Dim RetVal As Long
    Dim WinClassBuf As String * 255, WinTitleBuf As String * 255
    Dim WinClass As String, WinTitle As String

    RetVal = GetClassName(lhWnd, WinClassBuf, 255)
    WinClass = StripNulls(WinClassBuf)                     ' remove extra Nulls & spaces
    RetVal = GetWindowText(lhWnd, WinTitleBuf, 255)
    WinTitle = StripNulls(WinTitleBuf)
    ThreadCount = ThreadCount + 1
    'see the Windows Class and Title for top level Window
    'Debug.Print "Thread Window Class = "; WinClass; ", Title = "; WinTitle

    EnumThreadProc = True                                  'Continua a procura
    If Not bVBEwinVis Then
        If WinClass = "wndclass_desked_gsk" Then           'Se encontrar a class do VBE window, bVBEwinVis fica true para esse API callback
            bVBEwinVis = IsWindowVisible(lhWnd) <> 0       'Verif. se est|fffd| vis|fffd|vel. Encontrar n|fffd|o |fffd| suficiente, pois se um c|fffd|digo precisar ser compilado no v|fffd|o a janela do VBE |fffd| criada, mas fica oculta
            VBE_hWnd = lhWnd
            EnumThreadProc = False                         'Para a procura se encontrou, oculta ou n|fffd|o, pois s|fffd| pode existir uma janela VBE
        End If
    End If
End Function
Function StripNulls(OriginalStr As String) As String
' This removes the extra Nulls so String comparisons will work
    If (InStr(OriginalStr, Chr(0)) > 0) Then
        OriginalStr = Left(OriginalStr, InStr(OriginalStr, Chr(0)) - 1)
    End If
    StripNulls = OriginalStr
End Function

'Function IsVbExeRun() As Boolean 'Nesta op|fffd||fffd|o vinha o PID do exe que rodava sem form, mas depois foi necess|fffd|rio o form para troca de info, ent|fffd|o preferi passar hWnd deste como no XLtoEXE, mas vou deixar aqui para uma eventualidades
'    Dim lPID As Long, lReturn As Long, lProcess As Long
'    lPID = Application.Evaluate(Workbooks("cpap_pri.mac").Names("VbExeShl").Value)
'    If lPID = 0 Then IsVbExeRun = True: Exit Function    'Se 0, n|fffd|o foi iniciado por exe, ent|fffd|o ignora cr|fffd|tica
'
'    lProcess = OpenProcess(PROCESS_ALL_ACCESS, 0&, lPID): CloseHandle lProcess
'    IsVbExeRun = lProcess <> 0 'Se teve sucesso em abrir e fechar o processo, ent|fffd|o est|fffd| rodando
'End Function
Function IsVbExeRun() As Boolean
    Dim hWnd As Long
    hWnd = Application.Evaluate(Workbooks("config.mac").Names("VbExeShl").Value)
    If hWnd = 0 Then IsVbExeRun = True: Exit Function    'Se 0, n|fffd|o foi iniciado por exe, ent|fffd|o ignora cr|fffd|tica
    IsVbExeRun = GetWindowLongA(hWnd, GWL_HINSTANCE) <> 0
End Function

Sub TestEnableExc7Verif()
    Workbooks("config.mac").Names.Add "VbExeShl", , , , , , , , , "=" & 329722 'No debug do cpap.exe(ExcelFre.vbp) pego hWnd de um Msgbox, assim debug aqui e o StaySpying l|fffd|.
    EnableExc7Verif
End Sub
Function EnableExc7Verif(Optional bEnable As Boolean = True, Optional bTemp As Boolean) As Boolean   'bEnable True pede o exe para atualizar lSumExc7LastUpdt e ficar verificando. False, pede pausa enquando abre ou fecha Wb.
    Dim hWnd As Long: EnableExc7Verif = True    'A priori, sempre retornar true.
    hWnd = Application.Evaluate(Workbooks("config.mac").Names("VbExeShl").Value)
    If bEnable And bTemp Then bOffTmpExc7Verif = False    'Religa ap|fffd|s ter sido desligado temporariamente.
    If hWnd = 0 Or bOffTmpExc7Verif Then Exit Function     'Se 0, n|fffd|o foi iniciado por exe, ent|fffd|o ignora cr|fffd|tica. Ou se desligado temporariamente
    'If lExc7Verif = "" Then If Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("InicioFim").Value Then Exit Function    'Para s|fffd| inciar depois que Ir.jap em pri for finalizado
    'If Not Workbooks("cpap_pri.mac").Excel4MacroSheets(1).Range("Aberto").Value Then Exit Function
    If bEnable = False And bTemp Then bOffTmpExc7Verif = True    'Desliga temporariamente, ignorando chamada com bEnable at|fffd| ser religado. O padr|fffd|o |fffd| Enable/Disable ao abrir wb, mas h|fffd| momento como na indexa|fffd||fffd|o por tr|fffd|s de um form em arq.mac que isso s|fffd| torna a opera|fffd||fffd|o muito lenta, ent|fffd|o desliga temporariamente, ignorando chamadas.

    lExc7Verif = IIf(bEnable, "1", CStr(hWnd)): lControlId = 0: lCntCallExc7Vrf = lCntCallExc7Vrf + 1
    EnumChildWindows hWnd, AddressOf EnumChildWin, ByVal 0&
    If lControlId = 0 Then EnableExc7Verif = False 'Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 7: Application.Run "cpap_pri.mac!Inst.incor"    'Sair CPAP se controle n|fffd|o encontrado
End Function

Public Function EnumChildWin(ByVal hWnd As Long, ByVal lParam As Long) As Long
    Dim sSave As String
    Dim RetVal As Long
    Dim sClassName As String: sClassName = String(255, Chr(0))    'Start as a buffer
    Dim sWindowText As String
    Dim StartDate As Date

    RetVal = GetClassName(hWnd, sClassName, 255)     'Get window class name
    sClassName = StripNulls(sClassName)

    If sClassName = "ThunderRT6TextBox" Or sClassName = "ThunderTextBox" Then    'No debug do VB6 o nome da classe n|fffd|o tem RT6
        lControlId = GetWindowLong(hWnd, GWL_ID)    'Get control Id.
        If lControlId <> 0 Then            'Only where lControlId is
            RetVal = SendMessageByStr(hWnd, WM_SETTEXT, 0, lExc7Verif)   'Set window text. |fffd| persistente e retorna 1 ou 0 se falhar.
            If RetVal = 0 Then lControlId = 0: Exit Function    'Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 8: Application.Run "cpap_pri.mac!Inst.incor": Exit Function    'Sair CPAP se conseguir passar info em 10s.

            If lCntCallExc7Vrf > 1 Then    'No VM trava ao iniciar, talvez seja o alerta para ativa|fffd||fffd|o do Excel. Ent|fffd|o salta a primeira, mesmo porque passando no teste anterior j|fffd| |fffd| bem seguro e este teste s|fffd| tem muita import|fffd|ncia quando desabilitando.
                Do    'Loop para s|fffd| continuar com a certeza de que foi capturado.
                    MyWait 0.1, False  'O MyWait sem DoEvents para evitar disparo de OnTime's ou fechamento wb pelo usu|fffd|rio.
                    If StartDate = 0 Then StartDate = Now Else If DateDiff("s", StartDate, Now) > 3 * 60 Then lControlId = 0: Exit Function     'Workbooks("cpap_pri.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 9: Application.Run "cpap_pri.mac!Inst.incor": Exit Function
                    sWindowText = String(255, Chr(0))   'Reset as a buffer
                    SendMessageByStr hWnd, WM_GETTEXT, 255, sWindowText    'Get window text.
                    sWindowText = StripNulls(sWindowText) ': Application.StatusBar = sWindowText & " " & (sWindowText = "Text1") & " " & Now: If ShiftDown Then Stop
                Loop While sWindowText <> "Text1"
            End If
        End If
    End If
    EnumChildWin = True    'Continue enumeration
End Function
Attribute VB_Name = "M|fffd|d1Divers"
'Option Explicit
Declare Function GetKeyState32 Lib "user32" Alias "GetKeyState" (ByVal vKey As Integer) As Integer
Public DirP As String
Dim ExcelObj As Object
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Public Function CopiarArq(Orig As String, Dest As String)
    On Error GoTo ErrorHandler
    FileCopy Orig, Dest
    CopiarArq = True
    GoTo Fim
ErrorHandler:
    CopiarArq = False
Fim:
End Function

Public Function CriarDir(NomeDir As String)
    On Error GoTo ErrorHandler
    MkDir NomeDir
    CriarDir = True
    GoTo Fim
ErrorHandler:
    CriarDir = False
Fim:
End Function

Public Function FSIZE_VB(Orig As String) As Long
    Dim vCount As Integer
    vCount = 0
    On Error GoTo ErrorHandler
    If Dir(Orig) <> "" Then FSIZE_VB = FileLen(Orig)
    GoTo Fim
ErrorHandler:
    FSIZE_VB = 0
    If vCount > 1 Then GoTo Fim
    vCount = vCount + 1
    Application.Wait Now + TimeValue("00:00:02")
    Resume
Fim:
End Function

Public Function RenArq(Orig As String, Dest As String)
    On Error GoTo ErrorHandler
    Name Orig As Dest
    RenArq = True
    GoTo Fim
ErrorHandler:
    RenArq = False
Fim:
End Function

Function GetDriveInfo()
    Dim fs, d
    On Error GoTo ErrorHandler
    Set fs = CreateObject("Scripting.FileSystemObject")
    DrvPath = ThisWorkbook.Path
    Set d = fs.GetDrive(fs.GetDriveName(fs.GetAbsolutePathName(DrvPath)))
    ' DriveType 0:Unknown 1:Removable 2:Fixed 3:Network 4:CD-ROM 5:RAM Disk
    GetDriveInfo = d.SerialNumber
    Exit Function
ErrorHandler:
    'Qualquer problema retorna zero que o mesmo qua n|fffd|o registrar.
    'Os problemas j|fffd| detectados: Falta do Scripting; Servidor de arquivo em esta|fffd||fffd|o atrav|fffd|s do NT
    GetDriveInfo = 0
End Function

Public Sub Cpap_arq()
'Este procedimento complementa o que seria feito caso os arquivos
'do CPAP tivessem sido extra|fffd|dos do autoextract cpap-arq.exe, ou seja,
'limpa a pasta do cpap e depois transfere todo arquivos na pasra arq-cpap
    DirP = ThisWorkbook.Path
    ChDir DirP
    InstCompleta = ThisWorkbook.Sheets(1).Range("InstCompleta")

    If InstCompleta And Dir(DirP & "\*.*") <> "" Then
        On Error Resume Next
        'Conservando antes de limpar todos os arquivos em DirP
        If Dir(DirP & "\arj.exe") <> "" Then Name DirP & "\arj.exe" As DirP & "\cpap-arq\arj.exe"
        If Dir(DirP & "\cpap-fun.bmp") <> "" Then Name DirP & "\cpap-fun.bmp" As DirP & "\cpap-arq\cpap-fun.bmp"
        If Dir(DirP & "\MSVBVM60.DLL") <> "" Then Name DirP & "\MSVBVM60.DLL" As DirP & "\cpap-arq\MSVBVM60.DLL"
        Kill DirP & "\*.*"
        On Error GoTo 0
    End If

    'Movendo de cpap-arq para DirP
    MyMoveFile "*.*", DirP & "\cpap-arq", DirP

    If Dir(DirP & "\areceber", vbDirectory) = "" Then MkDir (DirP & "\areceber")
    MyMoveFile "*.*", DirP & "\cpap-arq\areceber", DirP & "\areceber\"

    If Dir(DirP & "\avulso", vbDirectory) = "" Then MkDir (DirP & "\avulso")
    MyMoveFile "*.*", DirP & "\cpap-arq\avulso", DirP & "\avulso\"

    If Dir(DirP & "\banco", vbDirectory) = "" Then MkDir (DirP & "\banco")
    MyMoveFile "*.*", DirP & "\cpap-arq\banco", DirP & "\banco\"

    If Dir(DirP & "\exp_plan", vbDirectory) = "" Then MkDir (DirP & "\exp_plan")
    MyMoveFile "*.*", DirP & "\cpap-arq\exp_plan", DirP & "\exp_plan\"

    If Dir(DirP & "\tabelas", vbDirectory) = "" Then MkDir (DirP & "\tabelas")
    MyMoveFile "*.*", DirP & "\cpap-arq\tabelas", DirP & "\tabelas\"

    On Error Resume Next
    RmDir DirP & "\cpap-arq\areceber"
    RmDir DirP & "\cpap-arq\avulso"
    RmDir DirP & "\cpap-arq\banco"
    RmDir DirP & "\cpap-arq\exp_plan"
    RmDir DirP & "\cpap-arq\tabelas"
    RmDir DirP & "\cpap-arq"
End Sub

Sub MyMoveFile(vFiles As String, vOrigPath As String, vDestPath As String)
    vFileName = Dir(vOrigPath & "\" & vFiles)
    While vFileName <> ""
        If Dir(vDestPath & "\" & vFileName) <> "" Then Kill vDestPath & "\" & vFileName
        Name vOrigPath & "\" & vFileName As vDestPath & "\" & vFileName
        vFileName = Dir(vOrigPath & "\" & vFiles)
    Wend
End Sub


Public Sub Cpap_arq1()
'Esse Cpap_arq usa Scripting Object que parece n|fffd|o ter no servidor do Windows NT, fica para observa|fffd||fffd|o
'Este procedimento complementa o que seria feito caso os arquivos
'do CPAP tivessem sido extra|fffd|dos do autoextract cpap-arq.exe, ou seja,
'limpa a pasta do cpap e depois transfere todo arquivos na pasra arq-cpap
    DirP = ThisWorkbook.Path
    ChDir DirP
    Set fs = CreateObject("Scripting.FileSystemObject")
    'Conservando antes de limpar todos os arquivos
    If fs.FileExists(DirP & "\arj.exe") Then fs.movefile DirP & "\arj.exe", DirP & "\cpap-arq\"

    fs.DeleteFile DirP & "\*.*", True
    fs.movefile DirP & "\cpap-arq\*.*", DirP & "\"

    If fs.FolderExists(DirP & "\areceber") Then Else fs.CreateFolder (DirP & "\areceber")
    fs.copyfile DirP & "\cpap-arq\areceber\*.*", DirP & "\areceber\", True

    If fs.FolderExists(DirP & "\avulso") Then Else fs.CreateFolder (DirP & "\avulso")
    fs.copyfile DirP & "\cpap-arq\avulso\*.*", DirP & "\avulso\", True

    If fs.FolderExists(DirP & "\banco") Then Else fs.CreateFolder (DirP & "\banco")
    fs.copyfile DirP & "\cpap-arq\banco\*.*", DirP & "\banco\", True

    If fs.FolderExists(DirP & "\exp_plan") Then Else fs.CreateFolder (DirP & "\exp_plan")
    fs.copyfile DirP & "\cpap-arq\exp_plan\*.*", DirP & "\exp_plan\", True

    If fs.FolderExists(DirP & "\tabelas") Then Else fs.CreateFolder (DirP & "\tabelas")
    fs.copyfile DirP & "\cpap-arq\tabelas\*.*", DirP & "\tabelas\", True

    fs.getfolder(DirP & "\cpap-arq").Delete
End Sub

Sub AtivarPlan1()
    ActiveWorkbook.Sheets(1).Select
End Sub


Function Embaralhar(vFileName As String, vEmb As Boolean)
    TamFile = FileLen(vFileName)
    Dim StrSize As String
    StrSize = Space(1)
    Open vFileName For Binary As 1
    For I = 6 To 15000 Step 2
        If I > TamFile Then Exit For
        Seek 1, I
        Get 1, , StrSize
        vCod = Asc(StrSize)
        If vEmb Then
            vCod = vCod + 150
            If vCod > 255 Then vCod = vCod - 256
        Else
            vCod = vCod - 150
            If vCod < 0 Then vCod = vCod + 256
        End If
        StrSize = Chr(vCod)
        Seek 1, I
        Put 1, , StrSize
        j = j + 1
    Next
    Close 1
    Embaralhar = True
End Function

Sub ExecCpap()
    Set ExcelObj = New Excel.Application
    DirP = ThisWorkbook.Path
    ExcelObj.Workbooks.Open DirP & "\cpap.xla", 0, True, , "|fffd|~9|fffd|APF.XLA|fffd|G9z"
    ExcelObj.Visible = True
    ExcelObj.OnTime Now, "'" & DirP & "\[cpap.xla]Sheet2'!Iniciar"
End Sub

Public Function ShiftDown()
'Verif. se shift est|fffd| pressionada
    ShiftDown = (GetKeyState32(16) < 0)
End Function

Public Function AlertaCpap(vBot As Integer, vTitle As String, vMsg1 As String, Optional vMsg2 As String, Optional vMsg3 As String)
    If vTitle = "" Then vTitle = "CPAP|fffd|"
    AlertaCpap = MsgBox(vMsg1 & vMsg2 & vMsg3, Choose(vBot, vbOKOnly + vbInformation, vbOKCancel + vbQuestion, vbYesNoCancel + vbQuestion, vbAbortRetryIgnore + vbQuestion, vbCritical), vTitle)
    Select Case vBot
    Case 1    'OK inform
        AlertaCpap = True
    Case 2    'Ok ou Cancel quest
        AlertaCpap = AlertaCpap = vbOK
    Case 3    'sim n|fffd|o cancel
        AlertaCpap = -1 * (AlertaCpap = vbYes) - 2 * (AlertaCpap = vbNo) - 3 * (AlertaCpap = vbCancel)
    Case 4    'abortar retentar Ignorar
        AlertaCpap = -1 * (AlertaCpap = vbAbort) - 2 * (AlertaCpap = vbRetry) - 3 * (AlertaCpap = vbIgnore)
    Case 5    'Ok cr|fffd|tico
        AlertaCpap = True
    End Select
End Function

Public Function LeiameTxt() As Boolean
    Dim TextLine
    Dim TextLines As String
    DirP = ThisWorkbook.Path
    If Dir(DirP & "\leiame.txt") = "" Then
        MsgBox "O arquivo Leiame.txt n|fffd|o foi encontrado na pasta " & DirP, vbCritical, "CPAP|fffd|"
        Exit Function
    End If
    Open DirP & "\leiame.txt" For Input As #1
    Do While Not EOF(1)
        Line Input #1, TextLine
        TextLines = TextLines & TextLine & vbCrLf
    Loop
    Close #1
    TextLines = TextLines & vbCrLf & vbCrLf: SelecOption = 0
    UserFormLeiame.Text_Tb.Text = TextLines
    UserFormLeiame.Text_Tb.SelStart = 0
    UserFormLeiame.Show
    If SelecOption = 1 Then
        If Dir(DirP & "\leiame.doc") = "" Then
            MsgBox "O arquivo Leiame.doc n|fffd|o foi encontrado na pasta " & DirP, vbCritical, "CPAP|fffd|"
            Exit Function
        End If
        'Shell "Start " & DirP & "\leiame.doc" 'Usado no Win9x
        On Error GoTo ErrorHandler
        Set WordObj = CreateObject("Word.Application")
        WordObj.Visible = True
        WordObj.WindowState = 0
        AppActivate WordObj.Caption
        WordObj.Documents.Open DirP & "\leiame.doc"
        Set WordObj = Nothing
    End If
ErrorHandler:
    LeiameTxt = (Err.Number = 0)
End Function

Function HideObjectVBA(vStr As String, bHide As Boolean) As Boolean
'Bug 2007. Tanto em VBA (form button) quanto em XLM so funciona se pasta e planilha estiverem ativa, visivel e desprotegida. E ainda ScreenUpdate true logo depois de unhide
    Dim Shp As Shape
    Dim ActWb As Workbook
    Dim ActSh    'As Worksheet
    Dim bWbHid As Boolean
    Dim bShHid As Boolean

    Set ActWb = ActiveWorkbook
    Set ActSh = ActiveWorkbook.ActiveSheet
    bScrUpd = Application.ScreenUpdating
    bWbHid = ActWb.Windows(1).Visible
    bShHid = ActSh.Visible

    On Error Resume Next
    Set Shp = ActSh.Shapes(vStr)
    If Err.Number <> 0 Then
        MsgBox "O objeto '" & vStr & "' n|fffd|o existe!", vbCritical + vbOKOnly, "CPAP"
        HideObjectVBA = False
        Exit Function
    End If

    'Primeiro tenta normal, pois uma fez feito, enquanto nao for fechado, funciona ok. Alem disso
    'o bug pode ser corrigido no futuro e tem as versoes anteriores
    On Error Resume Next
    Shp.Visible = Not bHide
    If Err.Number = 0 Then HideObjectVBA = True: Exit Function
    On Error GoTo 0

    Application.ScreenUpdating = True

    If bWbHid = False Or bShHid = False Then
        ActWb.Windows(1).Visible = True
        ActSh.Visible = True
        ActSh.Activate
        ActWb.Activate
        DoEvents
    End If

    '    On Error Resume Next 'xxxx Por seguranca isso deve ser habilitado na versao para uso
    Shp.Visible = Not bHide

    If bWbHid = False Or bShHid = False Then
        ActSh.Visible = bShHid
        ActWb.Windows(1).Visible = bWbHid
        ActSh.Activate
        ActWb.Activate
    End If

    Application.ScreenUpdating = bScrUpd
    HideObjectVBA = True
End Function

Function TextBoxVBA(sString As String, sObjName As String, Optional lStart, Optional lLength)
'Bug 2007. o TEXT.BOX() XLM nao funciona
    If IsMissing(lStart) Then lStart = 0
    If IsMissing(lLength) Or lStart = 0 Then lLength = 0

    On Error Resume Next
    Set Shp = ActiveWorkbook.ActiveSheet.Shapes(sObjName)
    If Err.Number <> 0 Then
        MsgBox "O objeto '" & sObjName & "' n|fffd|o existe!", vbCritical + vbOKOnly, "CPAP"
        TextBoxVBA = False
        Exit Function
    End If

    'Alguns shapes sao convertido para um novo no Excel 2007, tipo wordart. Primeiro tenta normal, se falhar...
    If lLength = 0 Then
        If lStart = 0 Then
            'Indica subtituir tudo entao tem que limpar primeiro pois pode ter mais de 255 caracteres
            Do While Shp.TextFrame.Characters.Text <> ""
                Shp.TextFrame.Characters.Text = ""
            Loop
            Shp.TextFrame.Characters.Text = sString
        Else
            Shp.TextFrame.Characters(lStart).Text = sString
        End If
    Else
        Shp.TextFrame.Characters(lStart, lLength).Text = sString
    End If

    If Err.Number <> 0 Then
        Err.Clear
        Shp.TextEffect.Text = IIf(lStart = 1, "", Shp.TextEffect.Text) & sString
    End If

    If Err.Number = 0 Then TextBoxVBA = lStart + Len(sString) - 1 Else TextBoxVBA = False
End Function

Function EnableEventsVBA(bEnable As Boolean) As Boolean
    On Error Resume Next: Dim bEventsOn As Boolean: bEventsOn = Workbooks("config.mac").Excel4MacroSheets(1).Range("bEventsOn").Value    'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, o bEventsOn n|fffd|o vem mais pelo argumento, agora aqui s|fffd| se bEnable for True e bEventsOn tamb|fffd|m que Application.EnableEvents=True.
    Application.EnableEvents = bEnable
    Application.EnableEvents = bEnable And bEventsOn: EnableExc7Verif bEnable   'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, sempre que abilitar ou desabilitar evento, faz tamb|fffd|m EnableExc7Verif. E passou a trabalhar com eventos ligado no 2007 em diante tamb|fffd|m.
    EnableEventsVBA = Err.Number = 0
End Function

Function OptionsViewVBA(Optional bFormula, Optional bStatus, Optional lNotes) As Boolean
'No 2007 OPTIONS.VIEW(;;1) XLM n|fffd|o funciona. O OPTIONS.VIEW(TRUE) as vezes falha.
    On Error Resume Next
    If Not IsMissing(bFormula) Then Application.DisplayFormulaBar = bFormula
    If Not IsMissing(bStatus) Then Application.DisplayStatusBar = bStatus
    If Not IsMissing(lNotes) Then Application.DisplayCommentIndicator = -lNotes      '-1 xlCommentIndicatorOnly
    OptionsViewVBA = Err.Number = 0
End Function

Function SetEncryptionOptions(sWbName As String, bStrong As Boolean) As Boolean
    On Error Resume Next
    If bStrong Then
        Workbooks(sWbName).SetPasswordEncryptionOptions "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider", "RC4", 128, True
    Else
        Workbooks(sWbName).SetPasswordEncryptionOptions "", "OfficeStandard", 40, False
    End If
    SetEncryptionOptions = Err.Number = 0
End Function

Function ForceDisableMacros(bFlag As Boolean)
    On Error Resume Next
    Application.AutomationSecurity = IIf(bFlag, 3, 1)   'msoAutomationSecurityForceDisable msoAutomationSecurityLow
    If Err.Number <> 0 Then
        MsgBox "Requer Office 2002 SP2 ou posterior", , "Falha!"
    Else
        ForceDisableMacros = True
    End If
End Function

Function SaveAsVBA(document_text As String, type_num As Long, Optional prot_pwd, Optional backup, Optional write_res_pwd, Optional read_only_rec, Optional bErrAlert) As Boolean
'Precisou com o 2007, pois os formatos para 97 - 2003 n|fffd|o tem no XLM e o 2007 n|fffd|o aceita xlExcel4 (33)
'xlExcel5 e 7 39; xlExcel8 56
    If IsMissing(prot_pwd) Then prot_pwd = ""
    If IsMissing(backup) Then backup = False
    If IsMissing(write_res_pwd) Then write_res_pwd = ""
    If IsMissing(read_only_rec) Then read_only_rec = False
    If IsMissing(bErrAlert) Then bErrAlert = True    'Em XLM quando error(false) evita mensag de erro

    ADA = Application.DisplayAlerts
    Application.DisplayAlerts = False
    On Error Resume Next
Retry:
    Err.Number = 0
    ActiveWorkbook.SaveAs document_text, type_num, prot_pwd, write_res_pwd, read_only_rec, backup
    If ActiveWorkbook.Saved = False Then
        R = R + 1
        If R < 4 Then GoTo Retry
    End If
    SaveAsVBA = Err.Number = 0
    If SaveAsVBA = False And bErrAlert Then MsgBox "Voc|fffd| pode n|fffd|o estar devidamente logado na rede. Acione OK para continuar.", vbCritical + vbOKOnly, "Falha! - Ao salvar " & document_text
    Application.DisplayAlerts = ADA
End Function

Function MyWait(PauseSeg As Double, Optional bDovents As Boolean = True) As Boolean
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        If bDovents Then DoEvents    '|fffd|s vezes o DoEvents pode prejudicar um processo com disparo OnTime ou a|fffd||fffd|es do usu|fffd|rio como fechar Wb.
        If bDovents And PauseSeg > 2 Then Sleep 1    'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
    Loop
    MyWait = True
End Function

Function AbrirXLMVBA(Fn As String, lLinks As Long, Ro As Boolean, sPsw As String, Silence As Boolean)
'No 2010 open XLM ao abrir folha de macro as linhas ficam em altura m|fffd|xima. Isso |fffd| workaround
'preparado especificamente para substituir o OPEN xlm nas condi|fffd||fffd|es na macro AbrirXLM em pri.
    ADA = Application.DisplayAlerts ': WinSDIalinhGet    'No Excel 2013 SDI estoca pos e size da janela ativa para alinh a abrir.
    Application.DisplayAlerts = False
    On Error Resume Next
Retry:
    Err.Clear
    R = R + 1
    If R > 2 Then Application.StatusBar = R & "|fffd| tentativa para abrir " & Fn & "."
    'bEnableEvents = Application.EnableEvents No 2013 comentei porque o controle j|fffd| |fffd| feito no AbrirXLM. N|fffd|o seria prejudicial, apenas desnecess|fffd|rio.
    'Application.EnableEvents = False
    Workbooks.Open Filename:=Fn, UpdateLinks:=lLinks, ReadOnly:=Ro, Password:=sPsw
    'Application.EnableEvents = bEnableEvents
    If Err.Number = 0 Then GoTo End1
    If R - 7 * Int(R / 7) = 0 And Err.Number <> 0 Then
        If Silence Then
            GoTo End1
        Else
            If MsgBox("Uma outra esta|fffd||fffd|o da rede pode estar travada com o arquivo aberto, sua esta|fffd||fffd|o pode n|fffd|o est|fffd| devidamente logada na rede ou o arquivo foi salvo por uma vers|fffd|o mais recente ou muito antiga do Excel." & Chr(10) & Chr(10) & "Acione OK para mais 7 tentativas ou Cancelar para desistir." & Chr(10) & Chr(10) & "Excel Erro Info: (" & Err.Number & ") " & Err.Description, vbCritical + vbOKCancel, "Falha! Ao Abrir o Arquivo " & IIf(Len(Fn) > 34, "...", "") & Right(Fn, 34)) = vbOK Then GoTo Retry Else GoTo End1
        End If
    Else
        Application.Wait Now + TimeValue("00:00:01")
        GoTo Retry
    End If
End1:
    AbrirXLMVBA = IIf(Err.Number <> 0, CVErr(xlErrValue), True)
    Application.DisplayAlerts = ADA ': WinSDIalinhSet
    If R > 2 Then Application.StatusBar = False
End Function

Attribute VB_Name = "M|fffd|d1OnTime"
Option Explicit
Public ProxExec As Date
Dim LastSelec As String
Dim IntervVerif As String
Dim ManterAcelerado As Integer: Public bAutoCalcOff As Boolean
Dim Bv As Integer   'Num de barras vis|fffd|veis

Public Sub EvitarVBA()
'Este procedimento verifica de 6 em 6 seg. se o editor VBA _
  est|fffd| aberto e se h|fffd| mais de uma barra de comando em exibi|fffd||fffd| _
  Como usa on.time que interfere no protetor de tela, em 5 min _
  sem atividade ativa o menu que elimina a interfer|fffd|ncia.

    Application.EnableCancelKey = xlDisabled
    If IntervVerif = "" Then IntervVerif = "00:00:06"
    '    IntervDesOnTime = IIf(IntervVerif = "00:00:06", 40, 240)

    EvitarVBAb   'Protegendo barras def. pelo CPAP e s|fffd| aceita uma em exibi|fffd||fffd|o.
    If Bv > 1 Then Workbooks("config.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 1: GoTo Sair
    Dim AddInnCount, AddInnRib
    AddInnCount = Application.ExecuteExcel4Macro("COLUMNS(DOCUMENTS(2))")    'O cpap n|fffd|o tem Add-in, exceto no 2007
    If Not IsError(AddInnCount) Then
        If Val(Application.Version) >= 12 Then
            Set AddInnRib = Application.Workbooks("cpap.xlam")
            If AddInnRib.Sheets(1).Cells(65800, 260).Locked Then Workbooks("config.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 2: GoTo Sair            'Verifica mais uma vez a autenticidade por estilo padr|fffd|o
            AddInnCount = AddInnCount - 1
        End If
        If AddInnCount > 0 Then Workbooks("config.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 3: GoTo Sair
    End If

    If Application.EnableEvents <> Workbooks("config.mac").Excel4MacroSheets(1).Range("bEventsOn").Value Then Workbooks("config.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 4: GoTo Sair    'Pode indicar intrus|fffd|o atrav|fffd|s da primazia do ev op ou de Auto_open
    If Not IsVbExeRun Then Workbooks("config.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 5: GoTo Sair    'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, detecta se VbExe via API.
    On Error GoTo ErrorHandler
    If 2013 <> 2013 Then AppActivate "Microsoft Visual Basic" Else If Not IsVBEVisible Then GoTo ErrorHandler  'No Excel 2013, mas v|fffd|lido para todas vers|fffd|es, detecta visibilidade via VBA ou API s|fffd| na inst|fffd|ncia rodando o CPAP. Nas vers|fffd|es anteriores, se n|fffd|o houvesse erro ao ativar o t|fffd|tulo, ent|fffd|o estaria vis|fffd|vel em qualquer inst|fffd|ncia.
    AppActivate "CPAP": Workbooks("config.mac").Names.Add "VbaOcor", , , , , , , , , "=" & 6
Sair:
    If Not Workbooks("config.mac").Excel4MacroSheets(1).Range("Cont7").Value Then
        ProxExec = Now + TimeValue("00:00:02")
        Application.OnTime ProxExec, "EvitarVBA"
        Application.Run "config.mac!ValidPSusp"
    Else
        MsgBox "Sairia, mas EvitarVBA foi desativada."
        'If Val(Application.Version) <> 10 Then MsgBox "Excel " & Application.Version & "! Evitar salvar nesta vers|fffd|o, mas na 10 (2002-XP)"
    End If
    GoTo Fim
ErrorHandler:
    If ActiveWorkbook Is Nothing Then ProxExec = Now + TimeValue("00:00:02"): Application.OnTime ProxExec, "EvitarVBA": Exit Sub    '2013 mas era bug antigo, mais detalhe em Lembrete2013.txt.
    'If Not bAutoCalcOff Then AutoCalcular Else ManterAcelerado = 0
    ProxExec = Now + TimeValue(IntervVerif)
    Application.OnTime ProxExec, "EvitarVBA"
    If ActiveWorkbook.IsInplace Then Application.Run "config.mac!ValidPSusp"    'Application.OnTime Now, "'" & ThisWorkbook.Path & "\cpap_pri.mac'!InPlaceExit"


    If bOffTmpExc7Verif Then EnableExc7Verif True, True    'O padr|fffd|o |fffd| sempre ligado. Desliga temp ao indexar ligando logo em seguida. Esta |fffd| uma seguran|fffd|a se houver falha durando o desligamento.
Fim:
End Sub

Public Sub PararEvitarVBA()
'Suspende a pr|fffd|xima execu|fffd||fffd|o programada
    On Error Resume Next
    Application.OnTime ProxExec, "EvitarVBA", , False
End Sub


Public Sub SairEvitarVBA()
'Para sair de vez do CPAP
    On Error Resume Next
    Application.OnTime ProxExec, "EvitarVBA", , False

    'Retornando configura|fffd||fffd|o de ao iniciar
    'Nenhuma config necessita VBA.
End Sub

Public Sub EvitarVBAb()
'Verif. num de barras em exib e protege barra de menu de usuar. ativada pelo cpap
    Dim c As CommandBar, k
    Bv = 0
    For Each c In CommandBars
        If c.Visible Then
            Bv = Bv + 1
            If c.BuiltIn = False And c.Protection < 10 Then k = c.Name   'Quarda nome pra proteger ap|fffd|s loop
            'Ignora exib. da barra de Clipboard no Excel 2000, Task Pane no 2002 mas oculta
            If c.BuiltIn = True And (c.Name = "Clipboard" Or c.Name = "Task Pane") Then
                c.Visible = False
                Bv = Bv - 1
'                AcelAutoCalcular 20
            End If
            If Val(Application.Version) >= 15 And c.ID = 2149 Then Bv = Bv - 1    'No Excel 2013 permite a visibilidade da barra de Buy sem codename. Existe desde 12 eventualmente posso antecipar, mas parece ser um problema mais no Office 365 que pode estar sempre vencendo temp.
        End If
    Next

    'So no Excel 12 permite a visibilidade das novas barras Ribbon e Status Bar. Aqui em config Ribbon n|fffd|o.
    If Val(Application.Version) >= 12 Then Bv = Bv + CommandBars("Status Bar").Visible '+ CommandBars("Ribbon").Visible

    If Bv = 1 And k <> "" Then CommandBars(k).Protection = msoBarNoCustomize + msoBarNoMove + msoBarNoChangeVisible + msoBarNoChangeDock
End Sub

Function GetStatusBarName() As String
'No Excel 2007 a barra de status |fffd| uma barra de ferramenta que em XLM tem nome local. J|fffd| a Ribbon n|fffd|o parece variar
    On Error Resume Next
    If Val(Application.Version) >= 12 Then GetStatusBarName = Application.CommandBars("Status Bar").NameLocal
End Function

Public Function PauseEvitarVBA(Optional lTime As Long = -2) As Boolean
'Suspende a pr|fffd|xima execu|fffd||fffd|o programada e reprograma outra em lTime
    PararEvitarVBA
    ProxExec = Now + IIf(lTime < 0, -1, 1) * TimeSerial(0, 0, Abs(lTime)) 'TimeValue("00:00:02")
    Application.OnTime ProxExec, "EvitarVBA"
    PauseEvitarVBA = True
End Function

Public Sub WbSavedAll()    'Evitar alert de salvar ao suspender. Em Ex8 isto |fffd| feito em AutoCalcular
    Dim Wkb As Workbook
    For Each Wkb In Application.Workbooks
        Wkb.Saved = True
    Next
End Sub
Attribute VB_Name = "M|fffd|d2Histor"
Public Sub GerarHist(ArqNome As String, ArqPath As String, Novo As Boolean)
    If ArqNome = "CpapEdIm.Mac" Then Stop
    For Each Sh In Workbooks(ArqNome).Sheets
        NomeArqHist = Sh.Name
        If LCase(Right(NomeArqHist, 3)) = "hst" Then
            vFileName = ArqPath & "\banco\" & NomeArqHist
            NovoF = False
            Application.StatusBar = "Verificando o hist|fffd|rico " & NomeArqHist & " em " & ArqNome & "."
NovoFor|fffd|ar:
            If Dir(ArqPath & "\banco\" & NomeArqHist) = "" Or Novo Or NovoF Then
                'Criando Hist
                Application.Workbooks.Add xlWBATWorksheet
                ActiveWorkbook.Names.Add Name:="DadosHist", RefersToR1C1:=Cells(100, 1)
                Application.DisplayAlerts = False
                ActiveWorkbook.SaveAs vFileName, IIf(Val(Application.Version) >= 12, 56, xlWorkbookNormal)    'xlExcel8 56

                'Salvando Hist
                Workbooks(NomeArqHist).Sheets(1).Range("A1").CurrentRegion.ClearContents
                Workbooks(ArqNome).Sheets(NomeArqHist).Range("DadosFixos").CurrentRegion.Copy
                Workbooks(NomeArqHist).Sheets(1).Paste Range("A1")

                Workbooks(NomeArqHist).Sheets(1).Range("DadosHist").CurrentRegion.ClearContents
                I = Workbooks(ArqNome).Sheets(NomeArqHist).Range("DadosHist").Row
                Workbooks(NomeArqHist).Names.Add Name:="DadosHist", RefersToR1C1:=Workbooks(NomeArqHist).Sheets(1).Cells(I, 1)
                Workbooks(ArqNome).Sheets(NomeArqHist).Range("DadosHist").CurrentRegion.Copy
                Workbooks(NomeArqHist).Sheets(1).Paste Range("DadosHist")

                Application.CutCopyMode = False
                Workbooks(NomeArqHist).Activate
                ActiveWorkbook.ActiveSheet.Protect "MP542"
                ActiveWorkbook.Save
                ActiveWorkbook.Close False
                Application.DisplayAlerts = True
            Else
                'Verificando vers|fffd|o e integridade do arquivo hist|fffd|rico existente
                'Se abre
                On Error Resume Next
                Set I = Workbooks.Open(Filename:=vFileName, ReadOnly:=False, Notify:=False)
                On Error GoTo 0
                If I.Name = "" Then
                    NovoF = True
                    GoTo NovoFor|fffd|ar
                End If
                'Se cabe|fffd|alho mesma largura
                CabInstL = Workbooks(ArqNome).Sheets(NomeArqHist).Range("DadosHist").CurrentRegion.Columns.Count
                Workbooks(NomeArqHist).Sheets(1).Unprotect "MP542"
                CabHistL = Workbooks(NomeArqHist).Sheets(1).Range("DadosHist").CurrentRegion.Columns.Count
                If CabInstL <> CabHistL Then
                    NovoF = True
                    Workbooks(NomeArqHist).Close False
                    GoTo NovoFor|fffd|ar
                End If
                'Se cabe|fffd|alhos identicos
                For I = 0 To CabInstL - 1
                    If Workbooks(ArqNome).Sheets(NomeArqHist).Range("DadosHist").Offset(1, I).Value <> Workbooks(NomeArqHist).Sheets(1).Range("DadosHist").Offset(1, I).Value Then
                        NovoF = True
                        Workbooks(NomeArqHist).Close False
                        GoTo NovoFor|fffd|ar
                    End If
                Next
                Workbooks(NomeArqHist).Close False
            End If
        End If
    Next
    Workbooks(ArqNome).Close False
    Application.StatusBar = False
End Sub
Attribute VB_Name = "M|fffd|d3FileDateTime"
Option Explicit
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'|fffd| PROCEDURES:    SetFileDateTime and GetFileDateTime
'|fffd|
'|fffd| AUTHOR & DATE: FCO ORLANDO MAGALH|fffd|ES FILHO  4 Jan 2000
'|fffd|                Microsoft MVP - Excel
'|fffd|                Santa Quit|fffd|ria-Ce - Brazil
'|fffd|
'|fffd| CONTACT:       orlandof@geocities.com
'|fffd| WEB SITE:      http://cpap.com.br
'|fffd|
'|fffd| DESCRIPTION:   Set or/and Get file date and time
'|fffd|
'|fffd| ARGUMENTES:    See near above each procedure
'|fffd|
'|fffd| COPYRIGHTS:  Free to use with your application and free to distribute
'|fffd|              since this pack and any of file is not alter without previous
'|fffd|              authorization of the author.
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|

Private Const OFS_MAXPATHNAME = 260
Private Const OF_READ = &H0
Private Const OF_READWRITE = &H2

Type OFSTRUCT
    cBytes As Byte
    fFixedDisk As Byte
    nErrCode As Integer
    Reserved1 As Integer
    Reserved2 As Integer
    szPathName(OFS_MAXPATHNAME) As Byte
End Type

Private Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type

Private Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Long
End Type

Private Declare Function GetFileTime Lib "kernel32" _
        (ByVal hFile As Long, lpCreationTime As FILETIME, _
        lpLastAccessTime As FILETIME, _
        lpLastWriteTime As FILETIME) As Long

Private Declare Function SetFileTime Lib "kernel32" _
        (ByVal hFile As Long, _
        lpCreationTime As FILETIME, _
        lpLastAccessTime As FILETIME, _
        lpLastWriteTime As FILETIME) As Long

Private Declare Function FileTimeToSystemTime Lib "kernel32" _
        (lpFileTime As FILETIME, _
        lpSystemTime As SYSTEMTIME) As Long

Private Declare Function FileTimeToLocalFileTime Lib "kernel32" _
        (lpFileTime As FILETIME, lpLocalFileTime As FILETIME) As Long

Private Declare Function LocalFileTimeToFileTime Lib "kernel32" _
        (lpLocalFileTime As FILETIME, lpFileTime As FILETIME) As Long

Private Declare Function SystemTimeToFileTime Lib "kernel32" _
        (lpSystemTime As SYSTEMTIME, _
        lpFileTime As FILETIME) As Long

Private Declare Function OpenFile Lib "kernel32" _
        (ByVal lpFileName As String, _
        lpReOpenBuff As OFSTRUCT, _
        ByVal wStyle As Long) As Long

Private Declare Function CloseHandle Lib "kernel32" _
        (ByVal hFile As Long) As Long


Dim hFile As Long
Dim OFS As OFSTRUCT
Dim FT As FILETIME
Dim FTsys As SYSTEMTIME
Dim FT_CREATE As FILETIME
Dim FT_ACCESS As FILETIME
Dim FT_WRITE As FILETIME


'SetFileDateTime arguments:
'fName = "[PathName]FileName" If PathName ommited then it igual to currente folder
'      FileName addmits wild caracters ? and *
'fDate = "mm/dd/yy"  Date to set If ommited then it igual to local system date
'fTime = "hh:mm:ss"  Time to set If ommited then it igual to local system date
'TypeDate: 0 - All(Default if omitted); 1 - Create; 2 - Access; 3 - Write

Public Function SetFileDateTime(fName As String, Optional fDate As String, Optional fTime As String, Optional TypeDate As Single)
    Dim fNameWp, fPath As String
    Dim sPos, sPos1 As Single

    If fName = "" And Dir(fName) <> "" Then fName = CurDir & "\*.*"   'This statement permite fName optional, but I prefer not set
    If Dir(fName) = "" Then Exit Function
    If fDate = "" Then fDate = Format(Now, "dd/mm/yyyy")
    If fTime = "" Then fTime = Format(Now, "hh:mm:ss")

    'Extract Path
    sPos = InStr(1, fName, "\")
    If sPos > 0 Then
        While sPos > 0
            sPos1 = sPos
            sPos = InStr(sPos + 1, fName, "\")
        Wend
        fPath = Mid(fName, 1, sPos1)
        fName = Mid(fName, sPos1 + 1, Len(fName))
    Else
        fPath = CurDir & "\"
    End If

    fNameWp = Dir(fPath & fName)   'file name without path
    While fNameWp <> ""
        'Open file
        hFile = OpenFile(fPath & fNameWp, OFS, OF_READWRITE)
        fNameWp = Dir()   'Next file to open

        'Convert date and time file strings to a valid system time
        fDate = DateValue(fDate)
        fTime = TimeValue(fTime)

        With FTsys
            .wYear = Year(fDate)
            .wMonth = Month(fDate)
            .wDayOfWeek = Weekday(fDate, vbUseSystemDayOfWeek)
            .wDay = Day(fDate)
            .wHour = Hour(fTime)
            .wMinute = Minute(fTime)
            .wSecond = Second(fTime)
            .wMilliseconds = 500
        End With

        'Convert the system file time to a valid file time
        Call SystemTimeToFileTime(FTsys, FT)

        'Convert Local file time to system file time
        Call LocalFileTimeToFileTime(FT, FT)

        'Retrieve and set created, accessed or modified dates.
        Call GetFileTime(hFile, FT_CREATE, FT_ACCESS, FT_WRITE)
        If TypeDate = 0 Or TypeDate = 1 Then FT_CREATE = FT
        If TypeDate = 0 Or TypeDate = 2 Then FT_ACCESS = FT
        If TypeDate = 0 Or TypeDate = 3 Then FT_WRITE = FT
        Call SetFileTime(hFile, FT_CREATE, FT_ACCESS, FT_WRITE)

        'Closing the file
        Call CloseHandle(hFile)
    Wend
End Function

'GetFileDateTime arguments:
'fName = "[PathName]FileName" If PathName ommited then it igual to currente folder
'      FileName does not addmit wild characters ? and *
'TypeDate: 1 - Create; 2 - Access; 3 - Write(Default if omitted)

Public Function GetFileDateTime(fName As String, Optional TypeDate As Single) As Date
    GetFileDateTime = 2
    If Dir(fName) = "" Then Exit Function
    hFile = OpenFile(fName, OFS, OF_READ)
    Call GetFileTime(hFile, FT_CREATE, FT_ACCESS, FT_WRITE)
    If TypeDate = 1 Then FT = FT_CREATE
    If TypeDate = 2 Then FT = FT_ACCESS
    If TypeDate = 0 Or TypeDate = 3 Then FT = FT_WRITE

    'Convert system FILETIME to local FILETIME
    Call FileTimeToLocalFileTime(FT, FT)

    'Convert FILETIME to a valid SYSTEMTIME
    If FileTimeToSystemTime(FT, FTsys) Then
        GetFileDateTime = DateSerial(FTsys.wYear, FTsys.wMonth, FTsys.wDay) _
                + TimeSerial(FTsys.wHour, FTsys.wMinute, FTsys.wSecond)
    End If

    'Closing the file
    Call CloseHandle(hFile)
End Function


Sub Test()
    Dim Msg As String
    SetFileDateTime "C:\WINDOWS\Desktop\ComoMVP\FileDateTime\Sem t|fffd|tulo.txt", "06-05-99", "20:00:00"
    'Parece um bug, em write 7 sai 8, 15s sai sempre 16, 45 sempre 46
    Msg = GetFileDateTime("C:\WINDOWS\Desktop\ComoMVP\FileDateTime\Sem t|fffd|tulo.txt")
    MsgBox Format(Msg, "dd/mm/yy hh:mm:ss")
End Sub

Attribute VB_Name = "M|fffd|d4ProgBar"
'***************************************************************************
'*                                                                         *
'* MODULE NAME:     WORKSHEET PROGRESS BAR                                 *
'* AUTHOR & DATE:   STEPHEN BULLEN,  Stephen@BMSLtd.co.uk                  *
'*                                                                         *
'* DESCRIPTION:     Uses Windows API calls to draw a percent-complete bar  *
'*                  on a standard Excel worksheet.                         *
'*                  Enjoy and use.                                         *
'*                                                                         *
'@**************************************************************************

Option Base 1

'***
'*** Define some types for the API calls
'***

'SIZE32
Type SIZE32
    cx As Long
    cy As Long
End Type

'RECT32
Type RECT32
    cl As Long
    ct As Long
    cr As Long
    cb As Long
End Type

'***
'*** Declare the API calls - 32 bit
'***

'Get the handle for a window
Declare Function FindWindow32 Lib "user32" Alias "FindWindowA" (ByVal szClass$, ByVal szTitle$) As Long

'Get the dimensions of the window
Declare Sub GetClientRect32 Lib "user32" Alias "GetClientRect" (ByVal hWnd As Long, lpRECT32 As RECT32)

'Get a device context
Declare Function GetDC32 Lib "user32" Alias "GetDC" (ByVal hWnd As Long) As Long

'Create a solid brush for filling the Rectangle
Declare Function CreateSolidBrush32 Lib "GDI32" Alias "CreateSolidBrush" (ByVal crColor As Long) As Long

'Create a pen for drawing the Rectangle edges
Declare Function CreatePen32 Lib "GDI32" Alias "CreatePen" (ByVal nPenStyle As Long, ByVal nWidth As Long, ByVal crColor As Long) As Long

'Create a Font object to draw the text with
Declare Function CreateFont32 Lib "GDI32" Alias "CreateFontA" (ByVal H As Long, ByVal W As Long, ByVal E As Long, ByVal O As Long, ByVal W As Long, ByVal I As Long, ByVal u As Long, ByVal S As Long, ByVal c As Long, ByVal OP As Long, ByVal CP As Long, ByVal Q As Long, ByVal PAF As Long, ByVal f As String) As Long

'Select the brush and pen objects into the edit box device context
Declare Function SelectObject32 Lib "GDI32" Alias "SelectObject" (ByVal hDC As Long, ByVal hObject As Long) As Long

'Set the edit box background colour
Declare Function SetBkColor32 Lib "GDI32" Alias "SetBkColor" (ByVal hDC As Long, ByVal crColor As Long) As Long

'Draw a Rectangle
Declare Function Rectangle32 Lib "GDI32" Alias "Rectangle" (ByVal hDC As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long

'Get the text dimensions
Declare Function GetTextExtentPoint32 Lib "GDI32" Alias "GetTextExtentPointA" (ByVal hDC As Long, ByVal lpszString As String, ByVal cbString As Long, lpSIZE32 As SIZE32) As Long

'Set the text colour
Declare Function SetTextColor32 Lib "GDI32" Alias "SetTextColor" (ByVal hDC As Long, ByVal crColor As Long) As Long

'Draw the text on the edit box
Declare Function ExtTextOut32 Lib "GDI32" Alias "ExtTextOutA" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal wOptions As Long, lpRECT32 As Any, ByVal lpString As String, ByVal nCount As Long, ByVal lpDx As Any) As Long

'Delete the brush and pens objects
Declare Function DeleteObject32 Lib "GDI32" Alias "DeleteObject" (ByVal hObject As Long) As Long

'Release a device context
Declare Function ReleaseDC32 Lib "user32" Alias "ReleaseDC" (ByVal hWnd As Long, ByVal hDC As Long) As Long


'***
'*** Declare some constants for use with the API calls
'***

Const PS_SOLID = 0       'Solid Rectangle edges
Const ETO_CLIPPED = 4    'Clipped text box
Const ETO_OPAQUE = 2     'Opaque text box


'***
'*** Declare some variables for use with the API calls
'***

Dim dlgRect32 As RECT32
Dim hWndWks32 As Long
Dim hDCWks32 As Long
Dim hBr32 As Long, hBrOld32 As Long
Dim hPen32 As Long, hPenOld32 As Long
Dim hFont32 As Long, hFontOld32 As Long
Dim iLastPos32 As Long
Dim iBarColour32 As Long


'***
'*** Draw the progress bar background and bar area
'***

Sub ProgressShow32(Optional iWidth, Optional iHeight)

    Dim sBuff As String * 128
    Dim WksRect As RECT32
    On Error Resume Next   'Alterei

    If IsMissing(iWidth) Then
        iWidth = 300
    End If

    If IsMissing(iHeight) Then
        iHeight = 126
    End If


    'Set the progress bar colour to blue
    iBarColour32 = RGB(0, 0, 255)

    'Get the handle of the dialog box window - 'bosa_sdm_XL' is the class name
    'for an Excel dialog box.
    hWndWks32 = FindWindow32("XLMAIN", Application.Caption)

    'Get the device context of the edit box
    hDCWks32 = GetDC32(hWndWks32)

    'Get the edit box dimensions
    GetClientRect32 hWndWks32, WksRect

    'Create a brush to fill the Rectangle with - solid grey
    'hBr32 = CreateSolidBrush32(RGB(192, 192, 192))
    hBr32 = CreateSolidBrush32(RGB(190, 190, 255))   'Alterei
    hBrOld32 = SelectObject32(hDCWks32, hBr32)

    'Create a pen to draw the Rectangle outline - solid black
    hPen32 = CreatePen32(PS_SOLID, 0, RGB(0, 0, 0))
    hPenOld32 = SelectObject32(hDCWks32, hPen32)

    'Calculate the dimensions of the background rectangle, centred in the Excel window
    With dlgRect32
        .cl = (WksRect.cr - WksRect.cl - iWidth) \ 2 - IIf(WksRect.cr > 640, 78, 0)   'Alterei 78 e 178 para deslocar do centro
        .cr = (WksRect.cr - WksRect.cl + iWidth) \ 2 - IIf(WksRect.cr > 640, 78, 0)
        .ct = (WksRect.cb - WksRect.ct - iHeight) \ 2 + 178
        .cb = (WksRect.cb - WksRect.ct + iHeight) \ 2 + 178
    End With

    'Draw the background rectangle
    a = Rectangle32(hDCWks32, dlgRect32.cl, dlgRect32.ct, dlgRect32.cr, dlgRect32.cb)

    'Restore the old brush and delete the one we just used
    hBr32 = SelectObject32(hDCWks32, hBrOld32)
    a = DeleteObject32(hBr32)

    'Create a new brush in solid white
    hBr32 = CreateSolidBrush32(RGB(255, 255, 255))
    hBrOld32 = SelectObject32(hDCWks32, hBr32)

    'Draw the progress bar rectangle in white with a black border
    a = Rectangle32(hDCWks32, dlgRect32.cl + 10, dlgRect32.cb - 28, dlgRect32.cr - 10, dlgRect32.cb - 10)

    'Store the position of the left edge of the progress bar.
    iLastPos32 = dlgRect32.cl + 10 + 1

    'Restore the old brush and delete the one we just used
    hBr32 = SelectObject32(hDCWks32, hBrOld32)
    a = DeleteObject32(hBr32)

    'Create a blue brush for the progress bar
    hBr32 = CreateSolidBrush32(iBarColour32)
    hBrOld32 = SelectObject32(hDCWks32, hBr32)

    'Restore the old pen and delete the one we just used
    hPen32 = SelectObject32(hDCWks32, hPenOld32)
    a = DeleteObject32(hPen32)

    'Create a pen to draw the progress bar outline in solid blue
    hPen32 = CreatePen32(PS_SOLID, 0, iBarColour32)
    hPenOld32 = SelectObject32(hDCWks32, hPen32)

End Sub


'*** Draw the text of the progress bar message in black on grey
'*** sAlign is L, C or R

Sub ProgressSetText32(sText, Optional sAlign)

    Dim txtSize As SIZE32
    Dim txtPos As SIZE32
    Dim txtRect As RECT32
    On Error Resume Next   'Alterei

    If IsMissing(sAlign) Then
        sAlign = "L"
    End If

    'Make text black on grey
    'a = SetBkColor32(hDCWks32, RGB(192, 192, 192))
    a = SetBkColor32(hDCWks32, RGB(180, 180, 255))   'Alterei
    a = SetTextColor32(hDCWks32, RGB(0, 0, 0))

    'Calculate the size of the text area of the progress bar background
    With txtRect
        .cl = dlgRect32.cl + 10
        .cr = dlgRect32.cr - 10
        .ct = dlgRect32.ct + 10
        .cb = dlgRect32.cb - 38
    End With

    'Create the font to use for the text
    'CreateFont(Height, Width, Escapement, Orientation, Weight, _
     '           Italic, Underline, Strikeout, CharSet, Precision, _
     '           Clipping, Quality, Pitch & Family, Font Name)
    '
    'Times New Roman, 32pt, Bold:
    '  CreateFont32(-32, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, "Times New Roman")
    '
    'MS Sans Serif, 12pt, Normal, Italic, Underline & Strikeout:
    '  CreateFont32(-12, 0, 0, 0, 400, 1, 1, 1, 0, 0, 0, 0, 0, "MS Sans Serif")

    hFont32 = CreateFont32(-16, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, "Times New Roman")
    hFontOld32 = SelectObject32(hDCWks32, hFont32)

    'Convert the passed text string into an array of text elements,
    'so the text wraps within the background box.
    asText = StringToArray32(sText, txtRect.cr - txtRect.cl)

    'Draw each text item separately
    For I = 1 To UBound(asText)
        'Get the displayed width of the text string
        a = GetTextExtentPoint32(hDCWks32, asText(I), Len(asText(I)), txtSize)

        'Calculate the text position according to the desired alignment
        With txtPos
            Select Case sAlign
            Case "C"
                'Centre in the box
                .cx = (dlgRect32.cl + dlgRect32.cr - txtSize.cx) \ 2
            Case "R"
                'Right align
                .cx = (dlgRect32.cr - 10 - txtSize.cx)
            Case Else
                'Left align
                .cx = (dlgRect32.cl + 10)
            End Select

            'Calculate the vertical position of the text
            .cy = dlgRect32.ct + 10 + (I - 1) * txtSize.cy
        End With

        'Calculate the top and bottom of the bounding rectangle for this line of text
        txtRect.ct = txtPos.cy
        txtRect.cb = txtPos.cy + txtSize.cy

        'Draw the text to the screen
        a = ExtTextOut32(hDCWks32, txtPos.cx, txtPos.cy, ETO_CLIPPED + ETO_OPAQUE, txtRect, asText(I), Len(asText(I)), 0&)
    Next

    'Reset the font and delete the one we created
    a = SelectObject32(hDCWks32, hFontOld32)
    a = DeleteObject32(hFont32)

End Sub


'***
'*** Fill the progress bar according to the value passed
'***

Sub ProgressSetValue32(dVal, Optional dMax)

    Dim txtSize As SIZE32
    Dim txtRect As RECT32
    Dim BarRect As RECT32

    Dim a As Long, I As Long
    Dim iPos As Long, iTxtPos As Long
    On Error Resume Next   'Alterei

    If IsMissing(dMax) Then
        dMax = 100
    End If

    'Calculate the dimensions of the progress bar rectangle
    With BarRect
        .cl = dlgRect32.cl + 10 + 1
        .cr = dlgRect32.cr - 10 - 1
        .ct = dlgRect32.cb - 28 + 1
        .cb = dlgRect32.cb - 10 - 1
    End With

    'Set the vertical dimensions of the drawn text box
    txtRect.ct = BarRect.ct
    txtRect.cb = BarRect.cb

    'Find the new right-hand side of the blue Rectangle
    iPos = BarRect.cl + Int((BarRect.cr - BarRect.cl) / dMax * dVal)

    'Draw the blue Rectangle
    a = Rectangle32(hDCWks32, iLastPos32, BarRect.ct, iPos, BarRect.cb)

    'Update the position of where the box has been drawn so far
    iLastPos32 = iPos

    'Format the percent-complete text string
    sText = Format(dVal / dMax, "0%")

    'Get the displayed width of the text string
    a = GetTextExtentPoint32(hDCWks32, sText, Len(sText), txtSize)

    'Calculate the position to draw the text string
    iTxtPos = (BarRect.cr + BarRect.cl - txtSize.cx) \ 2

    'Draw the string, depending on the relative position of the text box and Rectangle
    If iPos <= iTxtPos Then

        'Rectangle is to the left of the text string, so draw the text blue-on-white
        a = SetBkColor32(hDCWks32, RGB(255, 255, 255))
        a = SetTextColor32(hDCWks32, iBarColour32)

        'Draw the entire text box
        txtRect.cl = iTxtPos
        txtRect.cr = iTxtPos + txtSize.cx

        'Draw it!
        a = ExtTextOut32(hDCWks32, iTxtPos, txtRect.ct, ETO_CLIPPED + ETO_OPAQUE, txtRect, sText, Len(sText), 0&)

    ElseIf iPos < iTxtPos + txtSize.cx Then

        'Rectangle is in the middle of the text string, so draw some of the text white-on-blue
        a = SetBkColor32(hDCWks32, iBarColour32)
        a = SetTextColor32(hDCWks32, RGB(255, 255, 255))

        'Only draw the left-hand bit of the text box white-on-blue
        txtRect.cl = iTxtPos
        txtRect.cr = iPos

        'Draw it
        a = ExtTextOut32(hDCWks32, iTxtPos, txtRect.ct, ETO_CLIPPED + ETO_OPAQUE, txtRect, sText, Len(sText), 0&)

        'Draw the rest of the text blue-on-white
        a = SetBkColor32(hDCWks32, RGB(255, 255, 255))
        a = SetTextColor32(hDCWks32, iBarColour32)

        'Draw the rest of the text box blue on white
        txtRect.cl = iPos
        txtRect.cr = iTxtPos + txtSize.cx
        a = ExtTextOut32(hDCWks32, iTxtPos, txtRect.ct, ETO_CLIPPED + ETO_OPAQUE, txtRect, sText, Len(sText), 0&)
    Else
        'Rectangle has passed the text string, so draw it all white-on-blue
        a = SetBkColor32(hDCWks32, iBarColour32)
        a = SetTextColor32(hDCWks32, RGB(255, 255, 255))

        'Draw the entire string
        txtRect.cl = iTxtPos
        txtRect.cr = iTxtPos + txtSize.cx

        'Draw it!
        a = ExtTextOut32(hDCWks32, iTxtPos, txtRect.ct, ETO_CLIPPED + ETO_OPAQUE, txtRect, sText, Len(sText), 0&)
    End If

End Sub


'***
'*** Tidy up the Windows environment after the progress bar has finished
'***

Sub ProgressClear32()
    On Error Resume Next   'Alterei
'Return the edit box colours to their defaults
    a = SetBkColor32(hDCWks32, RGB(255, 255, 255))
    a = SetTextColor32(hDCWks32, RGB(0, 0, 0))

    'Return the brush and pen objects to their defaults
    hBr32 = SelectObject32(hDCWks32, hBrOld32)
    hPen32 = SelectObject32(hDCWks32, hPenOld32)

    'Delete our custom brush and pen
    a = DeleteObject32(hBr32)
    a = DeleteObject32(hPen32)

    'Release the device context to the edit box
    a = ReleaseDC32(hWndWks32, hDCWks32)
End Sub

'***
'*** Convert the passed text string into an array of text elements,
'*** so the text wraps within the background box.
'***

Function StringToArray32(sText, iWidth) As Variant

    Dim txtSize As SIZE32
    Dim asText As Variant
    On Error Resume Next   'Alterei

    'Make a dummy area, so it can be ReDimmed
    asText = Array("", "")

    'Initialise the text string array
    ReDim asText(1)
    iRow = 1

    'Initialise a counter to loop through the text
    I = 1

    'Loop through the passed string
    Do
        'Find the next new-line character (if any)
        j = InStr(I, sText, Chr(10), 0)

        'If no new-line, get the position of the end of the string
        If j = 0 Then
            j = Len(sText) + 1
        End If

        'Get the text until the new-line character, or end of string
        sLine = Mid(sText, I, j - I)

        'If nothing there (e.g. 2 new-lines next to each other), use a space
        If sLine = "" Then
            sLine = " "
        End If

        'Get the displayed width of the text string
        a = GetTextExtentPoint32(hDCWks32, sLine, Len(sLine), txtSize)

        'Loop until the width fits in the rectangle
        Do Until txtSize.cx <= iWidth

            'If there is a space in the string...
            If InStr(1, sLine, " ", 0) <> 0 Then

                '... strip off a whole word from the end of the string
                Do
                    sLine = Left(sLine, Len(sLine) - 1)
                Loop Until Right(sLine, 1) = " " Or sLine = ""
            End If

            'If no text left, use a space
            If sLine = "" Then
                sLine = " "
            Else
                'Otherwise, strip off the space or single character
                sLine = Left(sLine, Len(sLine) - 1)
            End If

            'Get the new displayed width
            a = GetTextExtentPoint32(hDCWks32, sLine, Len(sLine), txtSize)
        Loop

        'By now, the text fits in the rectangle, so store it in the array
        ReDim Preserve asText(iRow)
        asText(iRow) = sLine
        iRow = iRow + 1

        'Update the pointer to account for the stored string
        I = I + Len(sLine)

        'Ignore the new-line character, or space at the end of the line
        If Mid(sText, I, 1) = Chr(10) Or Mid(sText, I, 1) = " " Then
            I = I + 1
        End If

        'Loop until all the text has been processed
    Loop Until I >= Len(sText)

    'Return the array
    StringToArray32 = asText

End Function

'Testando
Sub ShowProgress()

    Application.ScreenUpdating = False

    'Show the progress bar background
    ProgressShow32 500, 58

    'Set the text of the progress bar
    'sText = "A Progress Bar!" & Chr(10) & j & Chr(10) & "Developed by Stephen Bullen,  Stephen@BMSLtd.co.uk"
    sText = "Verificando Arquivos:"
    ProgressSetText32 sText, "L"

    'Loop to show the percent complete bar
    For I = 1 To 10
        'Update the percent-complete bar
        ProgressSetValue32 I, 10
        Application.Wait Now + TimeValue("00:00:01")
    Next

    'Tidy up after the progress bar
    ProgressClear32
End Sub

'Adaptei para chamar de XLM
Public Function ProgresBar(vPerc As Single, Optional vMsg As String)
    If WbIsOpen("conf-fun.pla") Then ProgresBar2 vPerc, vMsg: Exit Function    'Ver coment|fffd|rio em ProgresBar2

    On Error Resume Next
    If vPerc > 100 Then
        'Tidy up after the progress bar
        ProgressClear32
        Exit Function
    End If

    If vPerc = 0 And vMsg <> "" Then
        Application.ScreenUpdating = False

        'Show the progress bar background
        ProgressShow32 500, 58

        'Set the text of the progress bar
        'sText = "A Progress Bar!" & Chr(10) & j & Chr(10) & "Developed by Stephen Bullen,  Stephen@BMSLtd.co.uk"
        sText = vMsg
        ProgressSetText32 sText, "L"
    End If

    'Update the percent-complete bar
    ProgressSetValue32 vPerc
End Function


'=================
'O ProgressBar acima que desenha diretamente na tela usando API n|fffd|o funcionou no Excel 15, mas em vez de tentar fixar
'preferi usar o meu com objteto sobre a planilha que vinha usando em sob-mac. Nao ser porque nao havia feito isso ainda,
'pois pe mais consistente nao apagando se outra janela for ativada no windows.
Sub ProgresBar2(Perc As Single, Optional Msg As String)
    Dim FundSh As Worksheet
    On Error Resume Next
    Set FundSh = Workbooks("conf-fun.pla").Sheets(1)
    If Err.Number <> 0 Then Exit Sub
    Dim ActWb As Workbook: Set ActWb = ActiveWorkbook
    FundSh.Parent.Activate
    Dim bScrUpd As Boolean: bScrUpd = Application.ScreenUpdating: If Not bScrUpd Then Application.ScreenUpdating = True
    
    With FundSh
        If Perc = 0 Then
            .Shapes("QuadroFixo").Visible = True
            .Shapes("BarraMov").Visible = True
            .Shapes("BarraFixa").Visible = True
        End If

        If Msg <> "" Then .Shapes("QuadroFixo").TextFrame.Characters.Text = Msg
        .Shapes("BarraMov").Width = Perc / 100 * 374
        .Shapes("BarraMov").TextFrame.Characters.Text = IIf(Perc > 47, Format(Perc, "##0") & "%", "   ")
        .Shapes("BarraFixa").TextFrame.Characters.Text = IIf(Perc > 47, "   ", Format(Perc, "##0") & "%")

        If Perc > 100 Then
            .Shapes("QuadroFixo").Visible = False
            .Shapes("BarraMov").Visible = False
            .Shapes("BarraFixa").Visible = False
            .Shapes("BarraMov").Width = 0.01
        End If
    End With
    DoEvents: If Not bScrUpd Then Application.ScreenUpdating = False
    ActWb.Activate
End Sub

Sub TestProgresBar2()
    ProgresBar2 0, "Baixando Arquivos:"
    For I = 1 To 10
        ProgresBar2 (I * 10)
        MyWait 1
    Next
    ProgresBar2 102
End Sub

Sub TestProgresBar2b()
    ProgresBar2 0
    ProgresBar2 50
    ProgresBar2 100
    ProgresBar2 102
End Sub

Function WbIsOpen(WbName As String) As Boolean
    Dim Wb As Workbook
    On Error Resume Next
    Set Wb = Workbooks(WbName)
    WbIsOpen = Not Wb Is Nothing
End Function

Private Sub SalvarFunPla()
    Dim FundSh As Worksheet
    On Error Resume Next
    Set FundSh = Workbooks("conf-fun.pla").Sheets(1)
    If Err.Number <> 0 Then Exit Sub

    FundSh.Parent.Activate: FundSh.Select
    FundSh.Unprotect
    FundSh.Calculate

    FundSh.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
    FundSh.Range("A1").Select
    If ActiveWorkbook.ReadOnly Then ActiveWorkbook.ChangeFileAccess xlReadWrite
    With ActiveWindow
        .DisplayHeadings = False
        .DisplayZeros = False
        .DisplayHorizontalScrollBar = False
        .DisplayVerticalScrollBar = False
        .DisplayWorkbookTabs = False
    End With
    Application.DisplayFormulaBar = False
    
    ProgresBar2 102    'Para ocultar objetos que s|fffd|o desprotegidos
    
    If MsgBox("Salvar?", vbOKCancel) = vbOK Then ActiveWorkbook.Save
End Sub


Attribute VB_Name = "TOptMsgBoxForm"
Attribute VB_Base = "0{CE6CEC16-3863-4570-845F-AA46E0FBBC43}{049F44B8-1215-41ED-83FE-4DA451B3BAF0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Activate()
    Width = 345
    Prompt_Lb.Width = Width - 20
    Cancel_Bt.Width = Width - 45
    OptionButton1.Width = Width - 30
    OptionButton2.Width = Width - 30
    OptionButton3.Width = Width - 30
    OptionButton4.Width = Width - 30

    If OptionButton1.Caption = "" Then OptionButton1.Height = 0
    If OptionButton2.Caption = "" Then OptionButton2.Height = 0
    If OptionButton3.Caption = "" Then OptionButton3.Height = 0
    If OptionButton4.Caption = "" Then OptionButton4.Height = 0

    Cancel_Bt.Top = Prompt_Lb.Top + Prompt_Lb.Height + 7
    OptionButton1.Top = Cancel_Bt.Top + Cancel_Bt.Height + 3
    OptionButton2.Top = OptionButton1.Top + OptionButton1.Height + 3
    OptionButton3.Top = OptionButton2.Top + OptionButton2.Height + 3
    OptionButton4.Top = OptionButton3.Top + OptionButton3.Height + 3

    Height = OptionButton4.Top + OptionButton4.Height + 25

    Count_Lb.Visible = True
    Count_Lb.Top = Choose(SelecOption, OptionButton1, OptionButton2, OptionButton3, OptionButton4).Top _
            + Choose(SelecOption, OptionButton1, OptionButton2, OptionButton3, OptionButton4).Height / 2 _
            - Count_Lb.Height / 2
    Application.OnTime Now + TimeValue("00:00:01"), "Counting"
End Sub

Private Sub OptionButton1_Click()
    SelecOption = 1
    vCount = 1
    Counting
End Sub

Private Sub OptionButton2_Click()
    SelecOption = 2
    vCount = 1
    Counting
End Sub
Private Sub OptionButton3_Click()
    SelecOption = 3
    vCount = 1
    Counting
End Sub
Private Sub OptionButton4_Click()
    SelecOption = 4
    vCount = 1
    Counting
End Sub

Private Sub Cancel_Bt_Click()
    UserForm_QueryClose 0, 0
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then
        vCount = 0
        Cancel = 1
    End If
End Sub

'Pressing Enter key action the default option in regressive counting.
Private Sub vEnter(vKey As Integer)
    If vKey = 13 Then
        Unload TOptMsgBoxForm
        If NextCount > 0 Then Application.OnTime NextCount, "Counting", , False
    End If
End Sub
Private Sub OptionButton1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    vEnter KeyCode.Value
End Sub
Private Sub OptionButton2_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    vEnter KeyCode.Value
End Sub
Private Sub OptionButton3_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    vEnter KeyCode.Value
End Sub
Private Sub OptionButton4_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    vEnter KeyCode.Value
End Sub
Attribute VB_Name = "TOptMsgBoxMod"
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
'" FUNCTION:      TOptMsgBox
'"
'" AUTHOR & DATE: FCO ORLANDO MAGALH|fffd|ES FILHO  12 Dez 1999
'"                Microsoft MVP - Excel
'"                Santa Quit|fffd|ria-Ce - Brazil
'"
'" CONTACT:       mvp@cpap.com.br
'" WEB SITE:      http://cpap.com.br
'"
'" DESCRIPTION:   A Msgbox with four or more options where one of the
'"                options can choose automatically after a certain amount
'"                of seconds.
'"
'" ARGUMENTS:     Prompt - A text message to prompt on start.
'"                Title - A text to the title box (Optional)
'"                OptDefault - An integer of default option. (Optional)
'"                Timer - An integer for the numbers of seconds to choose
'"                    automatically the default option (Optional).
'"                Opt1-4 - Text messages for each option (Optional).
'"
'" OTHERS:        ESC key stop the regressive count timer.
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Public SelecOption As Integer
Public vCount As Integer
Public NextCount As Double
Public CtrlOptDefault As Control

Sub Test()
    MsgBox "Option " & TOptMsgBox("Please, choose an option." & Chr(10) & "In this test, option 2 will be select in 15 seconds.", "Test", 2, 15, "Option 1", "Option 2", "Option 3", "Option 4") & " was selected."
End Sub

Public Function AlertaConfig()
    DirP = ThisWorkbook.Path
    Dim vMsg As String
    ReInst = IsPastaCpap(DirP)    'Dir(dirP & "\BANCO\CPAP-MEM.MAC") <> "" _    No 2013 uniformizei a crit. de pasta cpap existente em .mac xlm (CritPastaInst) e Instl_cpap_.xls do autoextract com XLtoEXE
                            'Or Dir(dirP & "\BANCO\CPAP-IND.XLS") <> "" _
                            'Or Dir(dirP & "\BANCO\INDICE.MDA") <> ""
    vVer = Int(Val(Application.Version))
    vVer = Choose(1 - 1 * (vVer = 8) - 2 * (vVer = 9) - 3 * (vVer = 10) - 4 * (vVer = 11) - 5 * (vVer = 12) - 6 * (vVer = 14) - 7 * (vVer = 15), Application.Version, "97", "2000", "2002 (XP)", "2003", "2007", "2010", "2013")
    vMsg = "Na pasta " & DirP & IIf(ReInst, " aproveitando dados de uma instala|fffd||fffd|o anterior.", " sem NENHUM dado de instala|fffd||fffd|o anterior.") _
            & Chr(10) & Chr(10) & "EXCEL " & vVer & " instalado em " & Application.Path & "."
    AlertaConfig = TOptMsgBox(vMsg, "CPAP|fffd| - CONFIGURAR INSTALA|fffd||fffd|O", 1, 60, "Configurar agora usando as condi|fffd||fffd|es acima", "Cancelar")
    If 2 = 3 Then
        '   Sub FormatarGraf() Isso |fffd| para, suponho, pr|fffd| carregar drives para evitar erros ao compilar cpap-amt.mac
        NomeGraf = ActiveWorkbook.ActiveSheet.Range("NomeGraf").Value
        LimEsc = ActiveWorkbook.ActiveSheet.Range("LimEsc").Value
        ActiveWorkbook.ActiveSheet.ChartObjects(NomeGraf).Activate
        ActiveWorkbook.ActiveChart.ChartArea.Select
        ActiveWorkbook.ActiveChart.ChartType = xlAreaStacked
        ActiveWorkbook.ActiveChart.Axes(xlValue).MinimumScale = 0
        ActiveWorkbook.ActiveChart.Axes(xlValue).MaximumScale = LimEsc
        ActiveWindow.Visible = False
        'Windows("Plan8").Activate
        Range("A1").Select
        'End Sub
    End If
End Function


Public Function TOptMsgBox(Prompt As String, Optional Title As String, Optional OptDefault As Integer, Optional Timer As Integer, Optional Opt1 As String, Optional Opt2 As String, Optional Opt3 As String, Optional Opt4 As String) As Integer
    vCount = IIf(IsMissing(Timer), 0, Timer)

    SelecOption = IIf(IsMissing(OptDefault) Or vCount = 0, 1, OptDefault)
    If SelecOption > 3 And Opt4 = "" Then SelecOption = 3
    If SelecOption > 2 And Opt3 = "" Then SelecOption = 2
    If SelecOption > 1 And Opt2 = "" Then SelecOption = 1

    With TOptMsgBoxForm
        Set CtrlOptDefault = Choose(SelecOption, .OptionButton1, .OptionButton2, .OptionButton3, .OptionButton4)
        .Caption = Title
        .Prompt_Lb.Caption = Prompt
        .Count_Lb.Caption = ""
        .OptionButton1.Caption = Opt1
        .OptionButton2.Caption = Opt2
        .OptionButton3.Caption = Opt3
        .OptionButton4.Caption = Opt4
        .Show
    End With

    TOptMsgBox = SelecOption
End Function

Public Sub Counting(Optional HideCommand As String)
    If vCount = 0 Then
        TOptMsgBoxForm.Count_Lb.Visible = False
        NextCount = 0
        Exit Sub
    End If
    vCount = vCount - 1
    TOptMsgBoxForm.Count_Lb.Caption = Format(vCount, "00") & " |fffd|"
    CtrlOptDefault.ForeColor = IIf(vCount - Int(vCount / 2) * 2 = 0, &H80000012, &HFF&)
    If vCount > 0 Then
        NextCount = Now + TimeValue("00:00:01")
        Application.OnTime NextCount, "Counting"
    Else
        NextCount = 0
        Unload TOptMsgBoxForm
    End If
End Sub

Private Function IsPastaCpap(DirP As String) As Boolean     'Para detectar uma instala|fffd||fffd|o j|fffd| existente.
    IsPastaCpap = True
    If FilesVBA(DirP & "\cpap*.pla") > 3 And FilesVBA(DirP & "\cpap*.mac") > 15 Then Exit Function
    If FilesVBA(DirP & "\banco\cpap*mem.mac") > 0 Then Exit Function
    If FilesVBA(DirP & "\banco\cpap*ind.xls") > 0 Then Exit Function
    IsPastaCpap = False
End Function

Private Function FilesVBA(directory_text As String) As Long
    Dim arrayFiles() As String, Count As Long, f As String
    Count = 0
    f = Dir(directory_text)
    Do While Len(f) > 0
        Count = Count + 1
        ReDim Preserve arrayFiles(1 To Count)
        arrayFiles(Count) = f
        f = Dir()
    Loop
    FilesVBA = Count
End Function

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True







Attribute VB_Name = "UserFormLeiame"
Attribute VB_Base = "0{75B411ED-BCF2-43CD-9534-BAB9643E4EE1}{FBF051E0-3B72-4151-A5BB-A3AF5C7FA8E9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub AbrirWord_Bt_Click()
    SelecOption = 1
    Unload Me    'Hide
End Sub

Private Sub Fechar_bt_Click()
    Unload Me    'Hide
End Sub

' InQuest injected base64 decoded content
' )^N)

INQUEST-PP=macro
