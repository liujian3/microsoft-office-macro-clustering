Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True



Private Sub Workbook_BeforeClose(Cancel As Boolean)
  ExportAllVBA
End Sub

Private Sub Workbook_Open()
    kontrolliere_preisblatt
End Sub
Attribute VB_Name = "FormatTyp1"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Public toFormat As Range

Sub format()
    Dim zeile As Range
    Dim menge As Range
    Dim ep As Range
    For Each zeile In toFormat.Rows
    Set menge = zeile.Cells(1, 3)
    Set ep = zeile.Cells(1, 6)
    'Die G|fffd|ltigkeit f|fffd|r den Einzelpreis
    With ep.Validation
        .Delete
        .Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertStop, Operator:= _
        xlBetween, Formula1:="=ODER(SUMME(E12)=0;SUMME(E12)=0)"
        
        '.Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertStop, Operator:= _
        'xlBetween, Formula1:="=" & menge.Address & ">0"
        
        '.IgnoreBlank = True
        '.InCellDropdown = True
        '.InputTitle = ""
        '.ErrorTitle = "UNG|fffd|LTIG"
        '.InputMessage = ""
        '.ErrorMessage = "Bitte entweder einen Preis > 0 oder ""enthalten"" eingeben."
        '.ShowInput = True
        '.ShowError = True
    End With
    'die bedingte formatierung
    With ep
    .FormatConditions.Delete
    .FormatConditions.Add Type:=xlExpression, Formula1:="=UND(" & menge.Address & ">0;" & ep.Address & "=0)"
    .FormatConditions(1).Interior.ColorIndex = 3
   
    
    End With
    
    Next zeile

End Sub

Sub sagwas()
    MsgBox "Hallo"
End Sub
Attribute VB_Name = "PB_ButtonModul"
Sub button_mengenausschreibung()
Application.ScreenUpdating = False
    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    
    sa.doMengenAusschreibung
Application.ScreenUpdating = True
End Sub



Sub button_funktionalausschreibung()
Application.ScreenUpdating = False
    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    
    sa.doFunktionalAuschreibung
Application.ScreenUpdating = True
End Sub


Sub button_spaltenAusblenden()

    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    sa.spaltenAusblenden

End Sub


Sub button_spaltenEinblenden()

    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    sa.spaltenEinblenden

End Sub


Sub button_ZeilenAusblenden()

    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    sa.zeilenAusblenden

End Sub



Sub button_ZeilenEinblenden()

    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    sa.zeilenEinblenden

End Sub

Sub button_lmodus()
    frm1.Show
End Sub


Sub button_pmodus()
    frm2.Show
End Sub

Sub button_alle_menge()
Dim saf As New SheetAdminFactory
Dim ws As Worksheet
Dim sa As Variant
For Each ws In Worksheets
    Set sa = saf.getSheetAdmin(ws)
    Debug.Print sa.refWorksheet.Name
    sa.doMengenAusschreibung
   
Next ws

' mache mengen spalten auf erg|fffd|nzungsblatt wieder writeable
Dim zeile As Range

On Error GoTo ENDE
Set ws = Worksheets("Erg|fffd|nzungsblatt")
    For Each zeile In ws.Rows
      If (zeile.Cells(1, 3).Interior.ColorIndex = 36 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 36
        zeile.Cells(1, 10).Interior.ColorIndex = 36
        zeile.Cells(1, 15).Interior.ColorIndex = 36
        zeile.Cells(1, 5).Locked = False
        zeile.Cells(1, 10).Locked = False
        zeile.Cells(1, 15).Locked = False
      End If
    If (zeile.Row > 530) Then
        Exit For
    End If
    Next zeile
ENDE:
End Sub


Sub button_alle_funktional()
Dim saf As New SheetAdminFactory
Dim ws As Worksheet
Dim sa As Variant
For Each ws In Worksheets
    Set sa = saf.getSheetAdmin(ws)
    sa.doFunktionalAuschreibung
Next ws

End Sub


Sub button_zeile_ausblenden_|fffd|bersicht()
button_ZeilenAusblenden

Dim ws As Worksheet
For Each ws In Worksheets
If (ws.Range("B2").Value = "Nein") Then
        ws.Visible = xlSheetHidden
End If

Next ws
Worksheets("|fffd|bersicht").Select
Cells(1, 1).Select
End Sub



Sub button_zeile_einblenden_|fffd|bersicht()

button_ZeilenEinblenden

For Each ws In Worksheets

        ws.Visible = xlSheetVisible


Next ws
Worksheets("|fffd|bersicht").Select
Cells(1, 1).Select
End Sub
Attribute VB_Name = "PB_CodeModul"
Option Explicit

Public Sub lieferanten_modus(s_pw1 As String)

Dim ws As Worksheet
Dim saf As New SheetAdminFactory
Dim sa As Variant
    

   
For Each ws In Worksheets
    Debug.Print ws.Name
    'MsgBox "Suchen"
    Set sa = saf.getSheetAdmin(ws)
    'MsgBox "Formatieren"
    sa.unprotect
    sa.spaltenAusblenden
    sa.zeilenAusblenden
    
    buttons_ausblenden
    
     'schauen ob das blatt unsichtbar wird

    If (ws.Range("B2").Value = "Nein" Or ws.Name = "Nachtr|fffd|ge") Then
        ws.Visible = xlSheetHidden
    Else
        ws.Visible = xlSheetVisible
        
        ws.Select
        ws.Cells(1, 1).Select
    
        ActiveWindow.View = xlNormalView
        ActiveWindow.Zoom = 75
    End If
    
    ws.protect password:=s_pw1

    
Next ws
 Debug.Print "mappe sch|fffd|tzen"
ActiveWorkbook.protect Structure:=True, Windows:=False, password:=s_pw1
Worksheets("|fffd|bersicht").Select
Range("B1").Value = "Lieferanten Modus"
End Sub


Sub planer_modus(password As String)

Dim ws As Worksheet

ActiveWorkbook.unprotect password
Dim saf As New SheetAdminFactory
Dim sa As Variant


For Each ws In Worksheets

    Set sa = saf.getSheetAdmin(ws)
    ws.unprotect password
    ws.Visible = xlSheetVisible
    sa.spaltenEinblenden
    sa.zeilenEinblenden
    
    
Next ws

buttons_einblenden

Worksheets("|fffd|bersicht").Select
Range("B1").Value = "Planer Modus"

Set sa = saf.getSheetAdmin(ActiveSheet)
sa.zeilenEinblenden

End Sub


Sub buttons_ausblenden()

Dim ws As Worksheet
Dim b As Button
For Each ws In Worksheets
    For Each b In ws.Buttons
        If (Not (b.Caption = "Planermodus" Or b.Caption = "Blatt Check")) Then
            b.Visible = False
        End If
        
    Next b
Next ws
End Sub

Sub buttons_einblenden()

Dim ws As Worksheet
Dim b As Button
For Each ws In Worksheets
    For Each b In ws.Buttons
        b.Visible = True
    Next b
Next ws
End Sub

Sub validate_zeile(ByVal target As Range)
Dim zeile As Range
Dim zelle As Range
For Each zeile In target.EntireRow.Rows
    'For Each zelle In zeile.Range(Cells(1, 1), Cells(1, 10))
     '   MsgBox zelle
    'Next zelle

Next zeile
End Sub


'kontrolliert ob das preisblatt korrekt ausgef|fffd|llt ist
Sub kontrolliere_preisblatt()
    Dim ws As Worksheet
    Dim zelle As Range
    Dim OK As Boolean
    Dim entfallt As Boolean
    OK = True
    entfallt = False
    For Each ws In Worksheets
       
        For Each zelle In ws.Range("A1:Z1600").Cells
            If (zelle.Validation.Value = False) Then
               zelle.Parent.Select
               zelle.Select
                OK = False
                GoTo ENDE
            
            ElseIf (zelle.Value = "entf|fffd|llt") Then
                 'zelle.Parent.Select
                'zelle.Select
                entfallt = True
                'GoTo ENDE
            End If
        Next zelle
    Next ws
ENDE:
If (Not OK) Then
    Worksheets("|fffd|bersicht").Range("B6").Value = "Nicht OK"
ElseIf (entfallt = True) Then
    Worksheets("|fffd|bersicht").Range("B6").Value = "Entf|fffd|llt gefunden"
Else
     Worksheets("|fffd|bersicht").Range("B6").Value = "OK"
End If
End Sub

'weisst auf allen technikblattern den Buttons das korrekt makro zu
Public Sub weiseButtonsMakroZu()
Dim knopf, ws
For Each ws In Worksheets
If (ws.Range("IV1").Value = "technik") Then
 'den buttons des technikblatts das richrige makro zuweisen
    
    For Each knopf In ws.Buttons
        If (knopf.Caption = "Mengenausschreibung") Then
            knopf.OnAction = "button_mengenausschreibung"
        ElseIf (knopf.Caption = "Funktionalausschreibung") Then
            knopf.OnAction = "button_funktionalausschreibung"
        ElseIf (knopf.Caption = "Spalten einblenden") Then
            knopf.OnAction = "button_spaltenEinblenden"
        ElseIf (knopf.Caption = "Spalten ausblenden") Then
            knopf.OnAction = "button_spaltenAusblenden"
        ElseIf (knopf.Caption = "Zeilen einblenden") Then
            knopf.OnAction = "button_ZeilenEinblenden"
        ElseIf (knopf.Caption = "Zeilen ausblenden") Then
            knopf.OnAction = "button_zeilenAusblenden"
        End If
    Next knopf
    End If
Next ws
End Sub
Attribute VB_Name = "PB_DBModul"
'**************************************
'* Enth|fffd|lt Code um alles in die Datenbank schreiben
'**************************************

Option Explicit
Public id_lieferant As Integer
Public id_projekt As Integer
Public id_anlage As Integer

'ob statusmeldungen in form von msgboxen gegeben werden sollen
Public showMessages As Boolean

Public datensatze_counter As Integer

'der treiber der datenbank
Public strConnect As String
Dim myconn As New Connection


Sub kleiner_test()
'Dim zahl As String
'Dim zw As Double
'zw = Range("Fahrschiene").Cells(1, 6).Value
'MsgBox ("zw ist " & zw & crlf & "zw ist " & LTrim(Str(zw)))
'ActiveSheet.Range("B12:S20").Name = "Skid1_LRB"
Dim mcell As Range

For Each mcell In Range("Skid1_QGF")
MsgBox mcell.Value
Next mcell
End Sub

Private Sub open_connection()
Dim path As String
' den pfad dieses dokuments bestimmen
path = ActiveWorkbook.path
strConnect = "Provider=Microsoft.ACE.OLEDB.12.0; Data Source=" & path & "\ftkomponenten.accdb"
myconn.Open (strConnect)
End Sub

Private Sub close_connection()
myconn.Close
End Sub

Sub into_db()
 into_db_messages (True)
End Sub

Sub into_db_Nomessages()
 into_db_messages (False)
End Sub

'+++++++++++++++++++++++++++++++++++
'|fffd|berf|fffd|hrt die Daten in die DB
'+++++++++++++++++++++++++++++++++++
Sub into_db_messages(showM As Boolean)
'Dim cat_1_bez, cat_1_id, cat_2_bez, cat_2_id, projekt_bez, projekt_id, lieferant_bez, lieferant_id As String

showMessages = showM

Dim row_hash As Collection
Dim mldg As String

'fehler behandlung
'On Error GoTo Error

'|fffd|ffnet verbindung zur DB
open_connection
Dim line As Range


' kontrolieren ob bereits ein projekt mit diesem namen existiert.
' falls nicht wird automatisch eines angelegt
validate_projekt
' kontrolieren ob bereits eine anlage mit diesem namen existiert.
' falls nicht wird automatisch eines angelegt
validate_anlage
' kontrolieren ob bereits ein llieferant mit diesem namen existiert.
' falls nicht wird automatisch einer angelegt
validate_lieferant


datensatze_counter = 0
'Fortschritt.Show
If (showMessages) Then
MsgBox "Daten werden in Datenbank geschrieben. Der Vorgang kann einige Minuten dauern"
End If

'+++++++++++++++++++++++++++++
' Alle Bl|fffd|cke in die Datenbank schreiben
'+++++++++++++++++++++++++++++

'Dim ws
'For Each ws In Worksheets
'ws.Select
'If (ws.Range("IV1").Value = "technik") Then
'ws.schreibeBlocke
'End If
'Next ws

'fuer dynamische datenbank
allWorksheetsIntoDb

'hilfstabellen aktualisieren
update_cat1_proj_lief
update_cat2_proj_lief

'verbindung schliessen
If (showMessages) Then
MsgBox "Alle Daten in Datenbank geschrieben"
End If

GoTo ENDE
Error:
    If (Err.Number = 1004) Then
        mldg = "Ein Bereich konnte nicht gefunden werden"
    Else
        mldg = "Fehler beim Einf|fffd|gen in die Datenbank "
    End If
    MsgBox mldg
    Err.Clear
    Resume Next
ENDE:
'Fortschritt.Hide
myconn.Close


End Sub
'++++++++++++++++++++++++++++++++++++++++++++++++
' Zerlegt einen Bauteil Datensatz in seine einzelnen Felder
'+++++++++++++++++++++++++++++++++++++++++++++++
Function row2hash(line As Range, cat_1_id As String) As Collection
Dim komp_hash As New Collection
Dim id As String

id = cat_1_id & "." & line.Cells(1, 1).Value

komp_hash.Add id, "ID"
komp_hash.Add line.Cells(1, 2).Value, "bezeichnung"
komp_hash.Add line.Cells(1, 3).Value, "einheit"
komp_hash.Add line.Cells(1, 4).Value, "mont_menge"
komp_hash.Add line.Cells(1, 5).Value, "mont_menge_ist"
komp_hash.Add ezn(line.Cells(1, 6)), "mont_ep_mech"
komp_hash.Add ezn(line.Cells(1, 7)), "mont_ep_elektr"
komp_hash.Add line.Cells(1, 8).Value, "mont_gesamt"
komp_hash.Add line.Cells(1, 9).Value, "lief_menge"
komp_hash.Add line.Cells(1, 10).Value, "lief_menge_ist"
komp_hash.Add ezn(line.Cells(1, 11)), "lief_ep_mech"
komp_hash.Add ezn(line.Cells(1, 12)), "lief_ep_elektr"
komp_hash.Add line.Cells(1, 13).Value, "lief_gesamt"
komp_hash.Add line.Cells(1, 14).Value, "demont_menge"
komp_hash.Add line.Cells(1, 15).Value, "demont_menge_ist"
komp_hash.Add ezn(line.Cells(1, 16)), "demont_ep_mech"
komp_hash.Add ezn(line.Cells(1, 17)), "demont_ep_elektr"
komp_hash.Add line.Cells(1, 18).Value, "demont_gesamt"
'die tats|fffd|chlichen zellen werte
komp_hash.Add line.Cells(1, 6), "s_mont_ep_mech"
komp_hash.Add line.Cells(1, 7), "s_mont_ep_elektr"
komp_hash.Add line.Cells(1, 11), "s_lief_ep_mech"
komp_hash.Add line.Cells(1, 12), "s_lief_ep_elektr"
komp_hash.Add line.Cells(1, 16), "s_demont_ep_mech"
komp_hash.Add line.Cells(1, 17), "s_demont_ep_elektr"
Set row2hash = komp_hash
End Function


'++++++++++++++++++++++++++++++++
'Generiert den SQL Befehl Daten in die Komponenten Tabelle der DB zu schreiben
'++++++++++++++++++++++++++++++++
Function put_into_komponenten(line As Collection) As String
Dim strInsert As String

' generiere den SQL String
strInsert = "insert into komponenten (ID,cat_1,cat_2,cat_3,bezeichnung,einheit,reihenfolge) values" _
            & "('" & line("ID") & "','" & line("cat_1") & "','" & line("cat_2") & "','" & line("cat_3") & "','" _
            & line("bezeichnung") & "','" & line("einheit") & "'," & line("reihenfolge") & ")"

put_into_komponenten = strInsert
End Function


'++++++++++++++++++++++++++++++++
'Generiert den SQL Befehl Daten in die Komponenten Tabelle der DB zu schreiben
'++++++++++++++++++++++++++++++++
Function put_into_komp_proj_lief(line As Collection) As String
Dim strInsert As String

' generiere den SQL String
strInsert = "insert into komp_proj_lief (id_komponente,id_projekt,id_lieferant,mont_menge" _
            & ",mont_menge_ist,mont_ep_elektr,mont_ep_mech,mont_gesamt,demont_menge,demont_menge_ist, demont_ep_elektr" _
            & ",demont_ep_mech,demont_gesamt,lief_menge,lief_menge_ist,lief_ep_elektr, lief_ep_mech,lief_gesamt,gesamt,s_mont_ep_mech,s_mont_ep_elektr,s_lief_ep_mech,s_lief_ep_elektr,s_demont_ep_mech,s_demont_ep_elektr) values" _
            & "('" & line("ID") & "','" & Str(line("id_projekt")) & "','" & line("id_lieferant") & "'," _
            & Str(line("mont_menge")) & "," & Str(line("mont_menge_ist")) & "," & Str(line("mont_ep_elektr")) _
            & "," & Str(line("mont_ep_mech")) & "," & Str(line("mont_gesamt")) & "," & Str(line("demont_menge")) _
            & "," & Str(line("demont_menge_ist")) & "," & Str(line("demont_ep_elektr")) _
            & "," & Str(line("demont_ep_mech")) & "," & Str(line("demont_gesamt")) & "," & Str(line("lief_menge")) _
            & "," & Str(line("lief_menge_ist")) & "," & Str(line("lief_ep_elektr")) _
            & "," & Str(line("lief_ep_mech")) & "," & Str(line("lief_gesamt")) & "," & Str(line("lief_gesamt") + line("mont_gesamt") + line("demont_gesamt")) _
            & ",'" & line("s_mont_ep_mech") & "','" & line("s_mont_ep_elektr") & "','" & line("s_lief_ep_mech") & "','" & line("s_lief_ep_elektr") & "','" & line("s_demont_ep_mech") & "','" & line("s_demont_ep_elektr") & "' )"
            

put_into_komp_proj_lief = strInsert
End Function

'++++++++++++++++++++++++++++++
' checkt ob eine komponente bereits in der komponenten tabelle ist
'++++++++++++++++++++++++++++++
Function komponente_exists(line As Collection) As Boolean
Dim sqlquery As String
Dim komponenten As Recordset
Dim komponente_id As String
Dim exists As Boolean
komponente_id = line("ID")
sqlquery = "Select * from komponenten where ID='" & komponente_id & "'"
Set komponenten = myconn.Execute(sqlquery)
If komponenten.BOF And komponenten.EOF Then
exists = False
Else
exists = True
End If
komponente_exists = exists
End Function

'++++++++++++++++++++++++++++++
' checkt ob ein eintrag in komp_proj_lief existiert
'++++++++++++++++++++++++++++++
Function komp_proj_lief_exists(line As Collection) As Boolean
Dim sqlquery As String
Dim rs As Recordset
Dim id_komponente As String
Dim id_projekt As Integer
Dim id_lieferant As Integer
Dim komponente_id
Dim exists As Boolean

komponente_id = line("ID")

sqlquery = "Select * from komp_proj_lief where id_komponente='" & komponente_id & "'" _
            & " And id_projekt = " & line("id_projekt") & " And id_lieferant=" & line("id_lieferant")
            
Set rs = myconn.Execute(sqlquery)
If rs.BOF And rs.EOF Then
exists = False
Else
exists = True
End If
komp_proj_lief_exists = exists
End Function

'++++++++++++++++++++++++++++++++++++
'setzt einen bereich in die DB
'++++++++++++++++++++++++++++++++++++
Sub range_into_db(id_projekt As Integer, id_lieferant As Integer, cat_1_id As String, cat_2_id As String, cat_3_id As String, strWo As String)
range_into_db_range id_projekt, id_lieferant, cat_1_id, cat_2_id, cat_3_id, Range(strWo)

End Sub

Sub range_into_db_range(ByVal id_projekt As Integer, ByVal id_lieferant As Integer, ByVal cat_1_id As String, ByVal cat_2_id As String, ByVal cat_3_id As String, ByVal block As Range)
'der datensatz z|fffd|hler
datensatze_counter = datensatze_counter + 1
'Fortschritt.Label2.Caption = datensatze_counter

Dim row_hash As Collection
Dim line As Range
Dim sqlquery As String
Dim rs As Recordset
Dim reihenfolge As Integer
reihenfolge = 0
'+++++++++++++++++++++++++++++
' Fahrschiene in DB
'+++++++++++++++++++++++++++++
On Error GoTo FEHLER

For Each line In block.Rows
reihenfolge = reihenfolge + 1
'falls die aktuelle zeile kein g|fffd|ltiger datensatz ist

Select Case check_line(line)
    Case 0
    Case 1
        'Debug.Print line.Address & " enh|fffd|lt keine Komponente"
        GoTo N|fffd|CHSTE
    Case 2
        'Die Technik ist abgew|fffd|hlt
        GoTo N|fffd|CHSTE
    Case 3
        line.Parent.Select
        line.Select
        MsgBox line.Address & " ist nich korrekt ausgef|fffd|llt"
        GoTo N|fffd|CHSTE
End Select


'sonst ganz normal weitermachne

'falls tabellentyp 1
If (block.Parent.Range("IV3") = 1) Then
    Set row_hash = row2hash_engineering(line, cat_1_id)

'falls tabellentyp 2
ElseIf (block.Parent.Range("IV3") = 2) Then
    Set row_hash = row2hash_stahlbau(line, cat_1_id)
'falls normalfall
Else
    Set row_hash = row2hash(line, cat_1_id)
End If
'jetz noch einige infos hinzuf|fffd|gen
row_hash.Add cat_2_id, "cat_2"
row_hash.Add cat_1_id, "cat_1"
row_hash.Add cat_3_id, "cat_3"
row_hash.Add id_anlage, "id_projekt"
row_hash.Add id_lieferant, "id_lieferant"
row_hash.Add reihenfolge, "reihenfolge"

'query um zu schauen ob die aktueller komponente in der db ist
sqlquery = "Select id, bezeichnung from komponenten where ID='" & row_hash("id") & "'"
Set rs = myconn.Execute(sqlquery)

'Falls noch _KEIN_ Eintrag in "komponenten" existiert und es keine erg|fffd|zungsblatt komponente ist
If (rs.BOF And rs.EOF And Not ist_spezialkomponente(cat_1_id)) Then
    'in "komponenten" einf|fffd|gen
    myconn.Execute put_into_komponenten(row_hash)
    'in "komp_proj_lief" einf|fffd|gen
    myconn.Execute (put_into_komp_proj_lief(row_hash))
'falls bereits ein eintrag in "komponenten" vorhanden
Else
   
   ' falls es sich NICHT um eine komponennte aus dem erg|fffd|nzungsblatt handelt
    If (Not ist_spezialkomponente(cat_1_id)) Then
        'falls der planer die komponenten bezeichnung _NICHT_ ge|fffd|ndert hat
        If (rs.Fields("bezeichnung") = row_hash("bezeichnung")) Then
        
            'falls der eintrag in "komp_proj_lief" _NICHT_ existiert
            If (Not komp_proj_lief_exists(row_hash)) Then
                myconn.Execute put_into_komp_proj_lief(row_hash)
            ' falls der eintrag in "komp_proj_lief" bereits existiert
            Else
                myconn.Execute update_komp_proj_lief(row_hash)
            End If
        Else
        GoTo DOCH
        End If
    ' falls der Planer die komponenten bezeichnung doch ge|fffd|ndert hat oder es sich um erg|fffd|nzungsblatt komponente handelt
    ' also wenn es eine spezialkomponente ist
    Else
DOCH:
        sqlquery = "Select id, bezeichnung from spezial_komponenten where ID='" & row_hash("id") & "'" _
                    & "and id_projekt =" & id_projekt & " and id_lieferant=" & id_lieferant
        Set rs = myconn.Execute(sqlquery)
        ' falls _KEIN_ eintrag in "spezial_komponenten" existiert
        If (rs.BOF And rs.EOF) Then
            'in "spezial_komponenten" einf|fffd|gen
            myconn.Execute put_into_spezial_komponenten(row_hash)
            
        'falls bereits ein eintrag in "spezial_komponenten" vorhanden
        Else
            'diesen eintrag aktualisieren
            myconn.Execute update_spezial_komponenten(row_hash)
        End If
    End If
    
End If

N|fffd|CHSTE:
Next line

GoTo ENDE:
FEHLER:
Dim s_fehler As String
s_fehler = "Fehler beim Einf|fffd|gen in Block " & block
s_fehler = s_fehler & " Ursache: " & Err.Description
MsgBox s_fehler
Resume Next
ENDE:
End Sub


'updatet die komp_proj_lief tabelle falls eine zelle ge|fffd|ndert wurde
Function update_komp_proj_lief(line As Collection) As String
    Dim strUpdate As String
   
    strUpdate = "update komp_proj_lief " _
            & "Set id_komponente ='" & line("ID") & "'," _
            & " id_projekt =" & line("id_projekt") & "," _
            & " id_lieferant=" & line("id_lieferant") & "," _
            & " mont_menge=" & Str(line("mont_menge")) & "," _
            & " mont_menge_ist=" & Str(line("mont_menge_ist")) & "," _
            & " mont_ep_elektr=" & Str(line("mont_ep_elektr")) & "," _
            & " mont_ep_mech=" & Str(line("mont_ep_mech")) & "," _
            & " mont_gesamt=" & Str(line("mont_gesamt")) & "," _
            & " lief_menge=" & Str(line("lief_menge")) & "," _
            & " lief_menge_ist=" & Str(line("lief_menge_ist")) & "," _
            & " lief_ep_elektr=" & Str(line("lief_ep_elektr")) & "," _
            & " lief_ep_mech=" & Str(line("lief_ep_mech")) & "," _
            & " lief_gesamt=" & Str(line("lief_gesamt")) & "," _
            & " demont_menge=" & Str(line("demont_menge")) & "," _
            & " demont_menge_ist=" & Str(line("demont_menge_ist")) & "," _
            & " demont_ep_elektr=" & Str(line("demont_ep_elektr")) & "," _
            & " demont_ep_mech=" & Str(line("demont_ep_mech")) & "," _
            & " demont_gesamt=" & Str(line("demont_gesamt")) & "," _
            & " s_mont_ep_elektr='" & line("s_mont_ep_elektr") & "'," _
            & " s_mont_ep_mech='" & line("s_mont_ep_mech") & "'," & " s_lief_ep_elektr='" & line("s_lief_ep_elektr") & "'," & " s_lief_ep_mech='" & line("s_lief_ep_mech") & "'," & " s_demont_ep_elektr='" & line("s_demont_ep_elektr") & "'," & " s_demont_ep_mech='" & line("s_demont_ep_mech") & "', " _
            & " gesamt=" & Str(line("lief_gesamt") + line("mont_gesamt") + line("demont_gesamt")) _
            & " where id_komponente ='" & line("ID") & "' and " _
            & "id_projekt =" & line("id_projekt") & "and " _
            & "id_lieferant=" & line("id_lieferant")
            
    update_komp_proj_lief = strUpdate
End Function




'++++++++++++++++++++++++++++++++
'Generiert den SQL Befehl Daten in die Komponenten Tabelle der DB zu schreiben
'++++++++++++++++++++++++++++++++
Function put_into_spezial_komponenten(line As Collection) As String
Dim strInsert As String

' generiere den SQL String
strInsert = "insert into spezial_komponenten (ID,id_projekt,id_lieferant,cat_1,cat_2,cat_3,bezeichnung,einheit,mont_menge" _
            & ",mont_menge_ist,mont_ep_elektr,mont_ep_mech,mont_gesamt,demont_menge,demont_menge_ist, demont_ep_elektr" _
            & ",demont_ep_mech,demont_gesamt,lief_menge,lief_menge_ist,lief_ep_elektr, lief_ep_mech,lief_gesamt,gesamt,reihenfolge,s_mont_ep_mech,s_mont_ep_elektr,s_lief_ep_mech,s_lief_ep_elektr,s_demont_ep_mech,s_demont_ep_elektr) values" _
            & "('" & line("ID") & "','" & line("id_projekt") & "','" & line("id_lieferant") & "','" & line("cat_1") & "','" & line("cat_2") & "','" & line("cat_3") & "','" _
            & line("bezeichnung") & "','" & line("einheit") & "'," _
            & Str(line("mont_menge")) & "," & Str(line("mont_menge_ist")) & "," & Str(line("mont_ep_elektr")) _
            & "," & Str(line("mont_ep_mech")) & "," & Str(line("mont_gesamt")) & "," & Str(line("demont_menge")) _
            & "," & Str(line("demont_menge_ist")) & "," & Str(line("demont_ep_elektr")) _
            & "," & Str(line("demont_ep_mech")) & "," & Str(line("demont_gesamt")) & "," & Str(line("lief_menge")) _
            & "," & Str(line("lief_menge_ist")) & "," & Str(line("lief_ep_elektr")) _
            & "," & Str(line("lief_ep_mech")) & "," & Str(line("lief_gesamt")) & "," & Str(line("lief_gesamt") + line("mont_gesamt") + line("demont_gesamt")) & "," & line("reihenfolge") _
            & ",'" & line("s_mont_ep_mech") & "','" & line("s_mont_ep_elektr") & "','" & line("s_lief_ep_mech") & "','" & line("s_lief_ep_elektr") & "','" & line("s_demont_ep_mech") & "','" & line("s_demont_ep_elektr") & "')"
'MsgBox strInsert
put_into_spezial_komponenten = strInsert
End Function


'updatet die spezial_komponenten tabelle falls eine zelle ge|fffd|ndert wurde
Function update_spezial_komponenten(line As Collection) As String
    Dim strUpdate As String
    strUpdate = "update spezial_komponenten " _
            & "Set ID ='" & line("ID") & "'," _
            & " id_projekt =" & line("id_projekt") & "," _
            & " id_lieferant=" & line("id_lieferant") & "," _
            & " cat_1='" & line("cat_1") & "'," _
            & " cat_2='" & line("cat_2") & "', bezeichnung ='" & line("bezeichnung") & "'," _
            & " mont_menge=" & Str(line("mont_menge")) & "," _
            & " mont_menge_ist=" & Str(line("mont_menge_ist")) & "," _
            & " mont_ep_elektr=" & Str(line("mont_ep_elektr")) & "," _
            & " mont_ep_mech=" & Str(line("mont_ep_mech")) & "," _
            & " mont_gesamt=" & Str(line("mont_gesamt")) & "," _
            & " lief_menge=" & Str(line("lief_menge")) & "," _
            & " lief_menge_ist=" & Str(line("lief_menge_ist")) & "," _
            & " lief_ep_elektr=" & Str(line("lief_ep_elektr")) & "," _
            & " lief_ep_mech=" & Str(line("lief_ep_mech")) & "," _
            & " lief_gesamt=" & Str(line("lief_gesamt")) & "," _
            & " demont_menge=" & Str(line("demont_menge")) & "," _
            & " demont_menge_ist=" & Str(line("demont_menge_ist")) & "," _
            & " demont_ep_elektr=" & Str(line("demont_ep_elektr")) & "," _
            & " demont_ep_mech=" & Str(line("demont_ep_mech")) & "," _
            & " demont_gesamt=" & Str(line("demont_gesamt")) & "," & " s_mont_ep_elektr='" & line("s_mont_ep_elektr") & "'," & " s_mont_ep_mech='" & line("s_mont_ep_mech") & "'," & " s_lief_ep_elektr='" & line("s_lief_ep_elektr") & "'," & " s_lief_ep_mech='" & line("s_lief_ep_mech") & "'," & " s_demont_ep_elektr='" & line("s_demont_ep_elektr") & "'," & " s_demont_ep_mech='" & line("s_demont_ep_mech") & "'," _
            & " gesamt=" & Str(line("lief_gesamt") + line("mont_gesamt") + line("demont_gesamt")) _
            & " where ID ='" & line("ID") & "' and " _
            & "id_projekt =" & line("id_projekt") & "and " _
            & "id_lieferant=" & line("id_lieferant")
            
    update_spezial_komponenten = strUpdate
End Function

'********************************
'Schaut ob das Projekt dieses Preisblattes bereits in der DB existiert. Wenn nicht
'wird es angelegt
'********************************
Private Sub validate_projekt()

Dim sql_projekt As String
Dim rsProjekt As Recordset
Dim projekt_bezeichnung As String
Dim fahrzeug As String
Dim planer As String
Dim standort As String
Dim gebaude As String
Dim abteilung As String
Dim bereich As String
Dim datum As Date
Dim technik As String
Dim fordergut As String
Dim fordergut_detail As String
Dim anfrage_nr_audi As String

' falls hier ein fehler auftritt einfach weitermachen
' damit das db modul auch f|fffd|r |fffd|ltere preisbl|fffd|tter
' verwendet werden kann
On Error Resume Next
projekt_bezeichnung = Range("DB_2").Cells(1, 3).Value
fahrzeug = Range("DB_1").Cells(1, 3).Value
planer = Range("DB_5").Cells(1, 3).Value
standort = Range("DB_8").Cells(1, 3).Value
gebaude = Range("DB_6").Cells(1, 3).Value
'abteilung = Range("DB_7").Cells(1, 3).Value
bereich = Range("DB_7").Cells(1, 3).Value
datum = Range("DB_10").Cells(1, 3).Value
technik = Range("DB_3").Cells(1, 3).Value
fordergut = Range("DB_11").Cells(1, 3).Value
fordergut_detail = Range("DB_12").Cells(1, 3).Value
anfrage_nr_audi = Range("DB_14").Cells(1, 3).Value

'kontrolieren ob  felder ausgef|fffd|llt sind
If (fahrzeug = "") Then
    fahrzeug = "NICHT VORHANDEN"
End If
If (planer = "") Then
    planer = "NICHT VORHANDEN"
End If
If (standort = "") Then
    standort = "NICHT VORHANDEN"
End If
If (gebaude = "") Then
    gebaude = "NICHT VORHANDEN"
End If
If (bereich = "") Then
    bereich = "NICHT VORHANDEN"
End If
'If (datum = "") Then
 '   datum = "1.1.2000"
'End If
If (technik = "") Then
    technik = "NICHT VORHANDEN"
End If
If (fordergut = "") Then
    fordergut = "NICHT VORHANDEN"
End If
If (fordergut_detail = "") Then
    fordergut_detail = "NICHT VORHANDEN"
End If
If (anfrage_nr_audi = "") Then
    anfrage_nr_audi = "NICHT VORHANDEN"
End If

sql_projekt = "Select ID from oberprojekte where bezeichnung='" & projekt_bezeichnung & "'"
Set rsProjekt = myconn.Execute(sql_projekt)

'falls kein projekt mit diesem namen existiert
If (rsProjekt.BOF And rsProjekt.EOF) Then
If (showMessages) Then
    MsgBox "Projekt existiert noch nicht und wird angelegt"
    End If
    
    sql_projekt = "Insert into oberprojekte (bezeichnung, fahrzeug, planer, standort,datum,bereich,gebaude,technik,fordergut,fordergut_detail,anfrage_nr_audi) " _
                & " values ('" & projekt_bezeichnung & "','" & fahrzeug & "','" & planer & "','" & standort & "','" & datum & "','" & bereich & "','" & gebaude & "','" & technik & "','" & fordergut & "','" & fordergut_detail & "','" & anfrage_nr_audi & "')"
    myconn.Execute (sql_projekt)
    'jetz suche die ID des neu hinzuge|fffd|gten projektes
    sql_projekt = "Select ID from oberprojekte where bezeichnung='" & projekt_bezeichnung & "'"
    Set rsProjekt = myconn.Execute(sql_projekt)
    'setze die projekt id
     id_projekt = rsProjekt.Fields("ID")
     
'falls breits eins existiert
Else
 'setze die projekt id
 id_projekt = rsProjekt.Fields("ID")
 
End If

End Sub



'********************************
'Schaut ob die Anlage dieses Preisblattes bereits in der DB existiert. Wenn nicht
'wird es angelegt
'********************************
Private Sub validate_anlage()

Dim sql_anlage As String
Dim rsAnlage As Recordset
Dim anlage_bezeichnung As String

anlage_bezeichnung = Range("DB_4").Cells(1, 3).Value
sql_anlage = "Select ID from projekte where bezeichnung='" & anlage_bezeichnung & "'" _
            & " AND id_oberprojekt = " & id_projekt & ""
Set rsAnlage = myconn.Execute(sql_anlage)

'falls keine anlage mit diesem namen existiert
If (rsAnlage.BOF And rsAnlage.EOF) Then
    If (showMessages) Then
    MsgBox "Anlage existiert noch nicht und wird angelegt"
    End If
    sql_anlage = "Insert into projekte (bezeichnung,id_oberprojekt) values ('" & anlage_bezeichnung & "'," & id_projekt & ")"
    myconn.Execute (sql_anlage)
    'jetz suche die ID des neu hinzuge|fffd|gten projektes
    sql_anlage = "Select ID from projekte where bezeichnung='" & anlage_bezeichnung & "'" _
            & " AND id_oberprojekt = " & id_projekt & ""
    Set rsAnlage = myconn.Execute(sql_anlage)
    'setze die anlage id
     id_anlage = rsAnlage.Fields("ID")
     
'falls breits eins existiert
Else
 'setze die anlage id
 id_anlage = rsAnlage.Fields("ID")
 
End If

End Sub



'********************************
'Schaut ob der Lieferant dieses Preisblattes bereits in der DB existiert. Wenn nicht
'wird es angelegt
'********************************
Private Sub validate_lieferant()

Dim sql_lieferant As String
Dim rslieferant As Recordset
Dim lieferant_bezeichnung As String

lieferant_bezeichnung = Range("DB_9").Cells(1, 3).Value
sql_lieferant = "Select ID from lieferanten where name='" & lieferant_bezeichnung & "'"
Set rslieferant = myconn.Execute(sql_lieferant)

'falls keine lieferant mit diesem namen existiert
If (rslieferant.BOF And rslieferant.EOF) Then
If (showMessages) Then
    MsgBox "Lieferant existiert noch nicht und wird angelegt"
    End If
    sql_lieferant = "Insert into lieferanten (name) values ('" & lieferant_bezeichnung & "')"
    myconn.Execute (sql_lieferant)
    'jetz suche die ID des neu hinzuge|fffd|gten projektes
    sql_lieferant = "Select ID from lieferanten where name='" & lieferant_bezeichnung & "'"
    Set rslieferant = myconn.Execute(sql_lieferant)
    Set rslieferant = myconn.Execute(sql_lieferant)
    'setze die lieferant id
    id_lieferant = rslieferant.Fields("ID")
     
'falls breits eins existiert
Else
 'setze die lieferant id
 id_lieferant = rslieferant.Fields("ID")
 
End If

End Sub


'++++++++++++++++++++++++++++++++++++++++++++++++
' Zerlegt einen Engineer Datensatz in seine einzelnen Felder
'+++++++++++++++++++++++++++++++++++++++++++++++
Function row2hash_engineering(line As Range, cat_1_id As String) As Collection
Dim komp_hash As New Collection
Dim id As String

id = cat_1_id & "." & line.Cells(1, 1).Value

komp_hash.Add id, "ID"
komp_hash.Add line.Cells(1, 2).Value, "bezeichnung"
komp_hash.Add line.Cells(1, 3).Value, "einheit"
komp_hash.Add line.Cells(1, 4).Value, "mont_menge"
komp_hash.Add line.Cells(1, 5).Value, "mont_menge_ist"
komp_hash.Add ezn(line.Cells(1, 6)), "mont_ep_mech"
komp_hash.Add 0, "mont_ep_elektr"
komp_hash.Add line.Cells(1, 7).Value, "mont_gesamt"
komp_hash.Add 0, "lief_menge"
komp_hash.Add 0, "lief_menge_ist"
komp_hash.Add 0, "lief_ep_mech"
komp_hash.Add 0, "lief_ep_elektr"
komp_hash.Add 0, "lief_gesamt"
komp_hash.Add 0, "demont_menge"
komp_hash.Add 0, "demont_menge_ist"
komp_hash.Add 0, "demont_ep_mech"
komp_hash.Add 0, "demont_ep_elektr"
komp_hash.Add 0, "demont_gesamt"
'die tats|fffd|chlichen werte
komp_hash.Add line.Cells(1, 6), "s_mont_ep_mech"

komp_hash.Add "0", "s_mont_ep_elektr"
komp_hash.Add "0", "s_lief_ep_mech"
komp_hash.Add "0", "s_lief_ep_elektr"
komp_hash.Add "0", "s_demont_ep_mech"
komp_hash.Add "0", "s_demont_ep_elektr"
Set row2hash_engineering = komp_hash
End Function


'++++++++++++++++++++++++++++++++++++++++++++++++
' Zerlegt einen Engineer Datensatz in seine einzelnen Felder
'+++++++++++++++++++++++++++++++++++++++++++++++
Function row2hash_stahlbau(line As Range, cat_1_id As String) As Collection
Dim komp_hash As New Collection
Dim id As String

id = cat_1_id & "." & line.Cells(1, 1).Value

komp_hash.Add id, "ID"
komp_hash.Add line.Cells(1, 2).Value, "bezeichnung"
komp_hash.Add line.Cells(1, 3).Value, "einheit"
komp_hash.Add line.Cells(1, 4).Value, "mont_menge"
komp_hash.Add line.Cells(1, 5).Value, "mont_menge_ist"
komp_hash.Add ezn(line.Cells(1, 6)), "mont_ep_mech"
komp_hash.Add 0, "mont_ep_elektr"
komp_hash.Add line.Cells(1, 7).Value, "mont_gesamt"
komp_hash.Add line.Cells(1, 8).Value, "lief_menge"
komp_hash.Add line.Cells(1, 9).Value, "lief_menge_ist"
komp_hash.Add ezn(line.Cells(1, 10)), "lief_ep_mech"
komp_hash.Add 0, "lief_ep_elektr"
komp_hash.Add line.Cells(1, 11).Value, "lief_gesamt"
komp_hash.Add line.Cells(1, 12).Value, "demont_menge"
komp_hash.Add line.Cells(1, 13).Value, "demont_menge_ist"
komp_hash.Add ezn(line.Cells(1, 14)), "demont_ep_mech"
komp_hash.Add 0, "demont_ep_elektr"
komp_hash.Add line.Cells(1, 15).Value, "demont_gesamt"
'die tats|fffd|chlichen werte
komp_hash.Add line.Cells(1, 6), "s_mont_ep_mech"
komp_hash.Add line.Cells(1, 10), "s_lief_ep_mech"
komp_hash.Add line.Cells(1, 14), "s_demont_ep_mech"

komp_hash.Add "", "s_mont_ep_elektr"
komp_hash.Add "", "s_lief_ep_elektr"
komp_hash.Add "", "s_demont_ep_elektr"
Set row2hash_stahlbau = komp_hash
End Function


'++++++++++++++++++++++++++++++++++++++++++++
'F|fffd|llt die cat1_proj_lief tabelle der datenbank aus.
'sollte eigentlich ein trigger machen, geht aber mit access nicht
'++++++++++++++++++++++++++++++++++++++++++++

Private Sub update_cat1_proj_lief()
Dim sql_alle_cat1 As String
Dim sql_c1_proj_lief As String
Dim mont_gesamt As Double
Dim demont_gesamt As Double
Dim lief_gesamt As Double
Dim gesamt As Double
Dim rs_alle_cat1 As Recordset
Dim rs_c1_proj_lief As Recordset
Dim c1 As String

sql_alle_cat1 = "Select id from cat_1"
Set rs_alle_cat1 = myconn.Execute(sql_alle_cat1)
Do Until rs_alle_cat1.EOF
    
    mont_gesamt = 0
    demont_gesamt = 0
    lief_gesamt = 0
    gesamt = 0

    '1 - gesamtpreis cat 1
    sql_c1_proj_lief = "SELECT sum(sk.mont_gesamt), sum(sk.demont_gesamt), sum(sk.lief_gesamt), sum(sk.gesamt) " _
                        & "FROM spezial_komponenten AS sk " _
                        & "WHERE sk.id_lieferant = " & id_lieferant & " AND sk.cat_1='" & rs_alle_cat1(0) & "' and sk.ID_projekt=" & id_anlage & " " _
                        & "UNION SELECT sum(kpl.mont_gesamt), sum(kpl.demont_gesamt), sum(kpl.lief_gesamt),sum(kpl.gesamt) " _
                        & "FROM  komponenten k, komp_proj_lief kpl " _
                        & "WHERE  kpl.id_komponente = k.ID and kpl.id_lieferant =" & id_lieferant & " AND k.cat_1='" & rs_alle_cat1(0) & "' and kpl.ID_projekt=" & id_anlage & " and k.id not in (select id from spezial_komponenten where id_projekt=" & id_anlage & " and id_lieferant=" & id_lieferant & ")"

        
    Set rs_c1_proj_lief = myconn.Execute(sql_c1_proj_lief)
    'jetz die preise bestimmen. dazu m|fffd|ssen die eintr|fffd|ge aus den tabellen spezial_komponenten und komp_pro_lief addiert werden
     Do Until rs_c1_proj_lief.EOF
       ' MsgBox rs_c1_proj_lief.RecordCount
        ' hier kann es zu fehlern kommen falls von einer komponente kein eintrag in
        ' spezial_komponenten existiert. dieser fehler kann allerdings |fffd|bersprungen werden
        On Error Resume Next
        mont_gesamt = mont_gesamt + rs_c1_proj_lief.Fields(0)
        demont_gesamt = demont_gesamt + rs_c1_proj_lief.Fields(1)
        lief_gesamt = lief_gesamt + rs_c1_proj_lief.Fields(2)
        gesamt = gesamt + rs_c1_proj_lief.Fields(3)

        rs_c1_proj_lief.MoveNext
     Loop
        
    Dim sql_check As String
    sql_check = "Select * from cat1_proj_lief where cat_1 = '" & rs_alle_cat1.Fields("ID") & "' and id_projekt = " & id_anlage & " and id_lieferant = " & id_lieferant & ""
    'MsgBox sql_check
    Dim rs_check As Recordset
    Set rs_check = myconn.Execute(sql_check)
    'falls kein eintrag existiert einen neuen einf|fffd|gen
    If (rs_check.BOF And rs_check.EOF) Then
        Dim sql_insert As String
        sql_insert = "Insert into cat1_proj_lief (cat_1, id_lieferant, id_projekt,mont_gesamt, lief_gesamt, demont_gesamt, gesamt) values (" _
        & "'" & rs_alle_cat1.Fields("ID") & "'," & id_lieferant & "," & id_anlage & "," & Str(mont_gesamt) & "," & Str(lief_gesamt) & "," & Str(demont_gesamt) & "," & Str(gesamt) & ")"
        'MsgBox sql_insert
        myconn.Execute (sql_insert)
    'falls schon ein eintrag existiert diesen updaten
    Else
        Dim sql_update As String
        sql_update = "Update cat1_proj_lief " _
                    & " set mont_gesamt = " & Str(mont_gesamt) & "," _
                    & " lief_gesamt = " & Str(lief_gesamt) & "," _
                    & " demont_gesamt = " & Str(demont_gesamt) & "," _
                    & " gesamt = " & Str(gesamt) & "" _
                    & " where cat_1 = '" & rs_alle_cat1.Fields("ID") & "' and id_projekt = " & id_anlage & " and id_lieferant = " & id_lieferant & ""
        'MsgBox sql_update
        myconn.Execute (sql_update)
    End If
        
    rs_alle_cat1.MoveNext
Loop
End Sub



'++++++++++++++++++++++++++++++++++++++++++++
'F|fffd|llt die cat2_proj_lief tabelle der datenbank aus.
'sollte eigentlich ein trigger machen, geht aber mit access nicht
'++++++++++++++++++++++++++++++++++++++++++++

Private Sub update_cat2_proj_lief()
Dim sql_alle_cat1 As String
Dim sql_c1_proj_lief As String
Dim mont_gesamt As Double
Dim demont_gesamt As Double
Dim lief_gesamt As Double
Dim gesamt As Double
Dim rs_alle_cat1 As Recordset
Dim rs_c1_proj_lief As Recordset
Dim c1 As String

sql_alle_cat1 = "Select id from cat_2"
Set rs_alle_cat1 = myconn.Execute(sql_alle_cat1)
Do Until rs_alle_cat1.EOF
    
    mont_gesamt = 0
    demont_gesamt = 0
    lief_gesamt = 0
    gesamt = 0

    '2 - gesamtpreis cat 2
    sql_c1_proj_lief = "SELECT sum(sk.mont_gesamt), sum(sk.demont_gesamt), sum(sk.lief_gesamt), sum(sk.gesamt) " _
                        & "FROM spezial_komponenten AS sk " _
                        & "WHERE sk.id_lieferant = " & id_lieferant & " AND sk.cat_2='" & rs_alle_cat1(0) & "' and sk.ID_projekt=" & id_anlage & " " _
                        & "UNION SELECT sum(kpl.mont_gesamt), sum(kpl.demont_gesamt), sum(kpl.lief_gesamt),sum(kpl.gesamt) " _
                        & "FROM  komponenten k, komp_proj_lief kpl " _
                        & "WHERE  kpl.id_komponente = k.ID and kpl.id_lieferant =" & id_lieferant & " AND k.cat_2='" & rs_alle_cat1(0) & "' and kpl.ID_projekt=" & id_anlage & " and k.id not in (select id from spezial_komponenten where id_projekt=" & id_anlage & " and id_lieferant=" & id_lieferant & ")"

        
    Set rs_c1_proj_lief = myconn.Execute(sql_c1_proj_lief)
    'jetz die preise bestimmen. dazu m|fffd|ssen die eintr|fffd|ge aus den tabellen spezial_komponenten und komp_pro_lief addiert werden
     Do Until rs_c1_proj_lief.EOF
       ' MsgBox rs_c1_proj_lief.RecordCount
        ' hier kann es zu fehlern kommen falls von einer komponente kein eintrag in
        ' spezial_komponenten existiert. dieser fehler kann allerdings |fffd|bersprungen werden
        On Error Resume Next
        mont_gesamt = mont_gesamt + rs_c1_proj_lief.Fields(0)
        demont_gesamt = demont_gesamt + rs_c1_proj_lief.Fields(1)
        lief_gesamt = lief_gesamt + rs_c1_proj_lief.Fields(2)
        gesamt = gesamt + rs_c1_proj_lief.Fields(3)

        rs_c1_proj_lief.MoveNext
     Loop
        
    Dim sql_check As String
    sql_check = "Select * from cat2_proj_lief where cat_2 = '" & rs_alle_cat1.Fields("ID") & "' and id_projekt = " & id_anlage & " and id_lieferant = " & id_lieferant & ""
    'MsgBox sql_check
    Dim rs_check As Recordset
    Set rs_check = myconn.Execute(sql_check)
    'falls kein eintrag existiert einen neuen einf|fffd|gen
    If (rs_check.BOF And rs_check.EOF) Then
        Dim sql_insert As String
        sql_insert = "Insert into cat2_proj_lief (cat_2, id_lieferant, id_projekt,mont_gesamt, lief_gesamt, demont_gesamt, gesamt) values (" _
        & "'" & rs_alle_cat1.Fields("ID") & "'," & id_lieferant & "," & id_anlage & "," & Str(mont_gesamt) & "," & Str(lief_gesamt) & "," & Str(demont_gesamt) & "," & Str(gesamt) & ")"
        'MsgBox sql_insert
        myconn.Execute (sql_insert)
    'falls schon ein eintrag existiert diesen updaten
    Else
        Dim sql_update As String
        sql_update = "Update cat2_proj_lief " _
                    & " set mont_gesamt = " & Str(mont_gesamt) & "," _
                    & " lief_gesamt = " & Str(lief_gesamt) & "," _
                    & " demont_gesamt = " & Str(demont_gesamt) & "," _
                    & " gesamt = " & Str(gesamt) & "" _
                    & " where cat_2 = '" & rs_alle_cat1.Fields("ID") & "' and id_projekt = " & id_anlage & " and id_lieferant = " & id_lieferant & ""
        'MsgBox sql_update
        myconn.Execute (sql_update)
    End If
        
    rs_alle_cat1.MoveNext
Loop
End Sub

'|fffd|berpr|fffd|ft ob eine Zeile korrekt ausgef|fffd|llt ist und in die db geschrieben werden kann

'gibt einen Wert |fffd|ber den Status der Zeile zur|fffd|ck
' 1 - Zeile hat keine ID
' 2 - Zeile ist ok, soll aber nicht in DB geschrieben werden
' 3 - Zeile ist nich ok

Private Function check_line(line As Range) As Integer
'z|fffd|hlt wie viele felder einer zeile falsch ausge|fffd|llt sind
Dim count As Integer
count = 0
Dim valid As Boolean
valid = True
Dim wert As Integer

'erstmal ist alles OK
wert = 0

Dim i As Integer
'Kontrolliern ob bezeichnung und ID korrekt ausgef|fffd|llt sind
For i = 1 To 2
If (line.Cells(1, i).Value = "") Then
    wert = 1
    GoTo ENDE
End If
Next i



'falls alle preise 0 sind wird die komponente nicht ben|fffd|tigt und muss auch nicht in die db geschrieben werden
' ist ein problem wenn eine komponente vorher in der db war und bei einer aktualisierung durch den lieferanten komplett
' auf 0 gesetzt wird.

'11.11 BAUSTELLE
'If (line.Cells(1, 4).Value = "0" And line.Cells(1, 6).Value = "0" And line.Cells(1, 7).Value = "0" And line.Cells(1, 9).Value = "0" And line.Cells(1, 11).Value = "0" And line.Cells(1, 12).Value = "0" And line.Cells(1, 14).Value = "0" And line.Cells(1, 16).Value = "0" And line.Cells(1, 17).Value = "0") Then
'    wert = 2
'    GoTo ENDE
'End If

'Wenn die das Register nich ausgew|fffd|hlt ist auch Zeilen nicht in DB einf|fffd|gen
If (line.Parent.Cells(2, 3).Value = "Nein") Then
    wert = 2
    GoTo ENDE
End If

'checke die ersten 30 zellen der zeile ob sie g|fffd|ltig sind
'25.1 - es sollen auch ung|fffd|ltige zellen in die db geschrieben werden
'For i = 1 To 30
'    If (Not line.Cells(1, i).Validation.Value) Then
'        wert = 3
'        GoTo ENDE
'    End If
'Next i
ENDE:
check_line = wert
End Function


'pr|fffd|ft ob sich sich bei einer kategorie um ein spezial kategorie handelt,
'deren komponenten in die spezial_komponenten tabelle geschrieben werden m|fffd|ssen
Private Function ist_spezialkomponente(ByVal cat_1_id As Integer) As Boolean
'    If (cat_1_id = 15 Or cat_1_id = 16 Or cat_1_id = 18) Then
'        ist_spezialkomponente = True
'    Else
'        ist_spezialkomponente = False
'    End If

    ist_spezialkomponente = True
End Function

'===============ab hier dynamische datenbank

' schreibt alles technikblaetter in die datenbank
Sub allWorksheetsIntoDb()
Dim ws, id
id = 1
'myconn.Execute ("delete * from cat_1")
For Each ws In Worksheets
    'falls technikblatt
    If (ws.Range("IV1").Value = "technik") Then
        worksheetIntoDb ByVal id, ByVal ws
        id = id + 1
    End If
Next ws
End Sub

'schreibt ein technikblatt in die datenbank
Sub worksheetIntoDb(ByVal cat1Id As Integer, ByVal ws As Worksheet)
Dim sql_cat1, bezeichnung, zeile, cat2Nr, sql_cat2, cat2Bez, cat2Id, inBlock, blockStartLine, blockEndLine, block, tabellenTyp, reihenfolge
id_projekt = id_anlage
bezeichnung = ws.Name
tabellenTyp = ws.Range("IV3")
'die reihenfolge speichern
reihenfolge = cat1Id
'optionen sollen immer zuletzt in der AA auftauchen, daher reihenfolge wert hochsetzen
If (bezeichnung = "Optionen") Then
    reihenfolge = 9999
ElseIf (bezeichnung = "Erg|fffd|nzungsblatt") Then
    reihenfolge = 9990
ElseIf (bezeichnung = "Nachtr|fffd|ge") Then
    reihenfolge = 9993
ElseIf (bezeichnung = "|fffd|nderungsjournal") Then
    reihenfolge = 9997
End If


Dim rs_id, rs_max As Recordset
Dim id, sql_getCatNr, sql_maxID, maxId, maxIdNull

'open_connection
sql_getCatNr = "select id from cat_1 where bezeichnung = '" & bezeichnung & "'"
Set rs_id = myconn.Execute(sql_getCatNr)
'falls kein eintrag gefunden wurde
If (rs_id.EOF) Then
    sql_maxID = "select max(int(id)) as MAXIMUM from cat_1"
    Set rs_max = myconn.Execute(sql_maxID)
    'rs_max.MoveFirst
    maxId = rs_max.Fields("MAXIMUM")
   'Workaround weil keine ahung wie mit ado auf DB.Null checken
    maxIdNull = maxId & "Null"
     'falls die tabelle noch leer ist und es kein maximum wert gibt
    If (maxIdNull = "Null") Then
        'do nothing, cat1Id ist ja bereits gesetzt
    Else
        cat1Id = maxId + 1
    End If
    
    sql_cat1 = "insert into cat_1 (id,bezeichnung,reihenfolge,tabellenTyp) values (" & cat1Id & ",'" & bezeichnung & "'," & reihenfolge & ",'" & tabellenTyp & "')"
    myconn.Execute (sql_cat1)
'falls die cat_1 schon exisiert
Else
    cat1Id = rs_id.Fields("ID")
End If
'close_connection

'wahr falls in einem Block (cat2)
inBlock = False
cat2Nr = 1
For Each zeile In ws.Rows
    'falls ein block beginnt
    If (firstLineOfBlock(ByVal zeile)) Then
        Debug.Print zeile.Row
        cat2Bez = zeile.Cells(1, 3).Value
        'falls der block keine bezeichnung hat, ihn uerberspringen
        If (cat2Bez = "") Then
            GoTo WEITER
        End If
        Set blockStartLine = ws.Rows(zeile.Row + 1)
        inBlock = True
        cat2Id = cat1Id & "." & cat2Nr
        'falls der cat_2 record bereits existiert wird der fehler einfach uebersprungen
        On Error Resume Next
        sql_cat2 = "insert into cat_2 (id,vorganger,bezeichnung,reihenfolge) values ('" & cat2Id & "'," & cat1Id & ",'" & cat2Bez & "'," & cat2Nr & ")"
        myconn.Execute (sql_cat2)
        'close_connection
        cat2Nr = cat2Nr + 1
    'falls ein block endet
    ElseIf (lastLineOfBlock(ByVal zeile, ByVal inBlock)) Then
        Set blockEndLine = zeile
        inBlock = False
        'die erste spalte nicht in den block mit aufnehmen
        Set block = Range(blockStartLine.Cells(1, 2), blockEndLine.Cells(1, 255))
        range_into_db_range id_projekt, id_lieferant, ByVal cat1Id, ByVal cat2Id, "0.0.0", ByVal block
    'falls das technikblatt zu ende ist
    ElseIf (blattEnde(ByVal zeile)) Then
        Exit For
    End If
WEITER:
Next zeile

End Sub

Sub test()
worksheetIntoDb 1, ActiveSheet
End Sub

'checkt ob eine zeile der beginn eines blockes ist
Function firstLineOfBlock(ByVal zeile As Range) As Boolean
 firstLineOfBlock = (zeile.Cells(1, 2).Interior.ColorIndex = 35)
End Function

'checkt ob eine zeile das ende des technikblattes ist
Function blattEnde(ByVal zeile As Range) As Boolean
 blattEnde = (zeile.Cells(1, 2).Interior.ColorIndex = 40)
End Function


'checkt ob eine zeile das ende eines blockes ist
Function lastLineOfBlock(ByVal zeile As Range, ByVal inBlock As Boolean) As Boolean
    lastLineOfBlock = (zeile.Cells(1, 2).Interior.ColorIndex = -4142 And inBlock And zeile.Cells(1, 2).Value = "")
End Function

Attribute VB_Name = "PB_EigeneFunktionen"
Option Explicit

Function ezn(aRange As Range) As Double
    ezn = IIf((aRange.Value = "enthalten" Or aRange.Value = "entf|fffd|llt"), 0, aRange.Value)
'    If (aRange.Value = "enthalten" Or aRange.Value = "entf|fffd|llt") Then
'        ezn = 0
'    Else
'        ezn = aRange.Value
'    End If
End Function

'fuehrt eine Gueltigkeitspruefung auf Sonderzeichen durch
Function enthaltSonderzeichen(aRange As Range) As Boolean
'"Function enthaltSonderzeichen(inhalt As String) As Boolean
'Dim inhalt As String
Dim pos, inhalt
inhalt = aRange.Value
pos = InStr(1, inhalt, " ", 1)
If (pos > 0) Then
    enthaltSonderzeichen = True
Else
    enthaltSonderzeichen = False
End If
End Function

Attribute VB_Name = "PB_Hilfsmodul"
Option Explicit



'|fffd|bernimmt das format der ersten zeile f|fffd|r alle anderen
Sub alle_zeile_formatieren()
Attribute alle_zeile_formatieren.VB_ProcData.VB_Invoke_Func = "f\n14"
Dim zeile As Range
Dim c As Integer
c = 1


ActiveSheet.Range("E12:Y12").Copy

For Each zeile In ActiveSheet.Rows
    zeile.Cells(1, 5).Select
    If (Selection.Interior.ColorIndex = 36) Then
            
         zeile.Cells(1, 5).PasteSpecial
         
    End If
    
    c = c + 1
    If (c > 1600) Then
        Exit Sub
    End If
Next zeile
End Sub

Sub cell_ist_gultig()
    MsgBox ActiveCell.Validation.Value
End Sub

Sub sheets_formatieren()
Dim ws As Worksheet
For Each ws In Worksheets
    ws.Select
    alle_zeile_formatieren
Next ws
End Sub


Sub mache_buttons()
Dim ws As Worksheet
Dim b As Button
For Each ws In Worksheets
    For Each b In ws.Buttons
        If (b.Caption = "Mengenausschreibung") Then
        b.OnAction = "button_mengenausschreibung"
        ElseIf (b.Caption = "Funktionalausschreibung") Then
        b.OnAction = "button_funktionalausschreibung"
        ElseIf (b.Caption = "Spalten einblenden") Then
        b.OnAction = "button_spaltenEinblenden"
        ElseIf (b.Caption = "Spalten ausblenden") Then
        b.OnAction = "button_spaltenAusblenden"
        ElseIf (b.Caption = "Zeilen ausblenden") Then
        b.OnAction = "button_zeilenAusblenden"
        ElseIf (b.Caption = "Zeilen einblenden") Then
        b.OnAction = "button_zeilenEinblenden"
        End If
    Next b
Next ws
End Sub

Sub foo()
Dim n As Name
For Each n In Worksheets("Engineering (Elektrik)").Names
    Debug.Print n.Name
Next n
End Sub




Sub foo4()
    Debug.Print "+" & ActiveSheet.Name & "+"
End Sub

Sub ExportAllVBA()
Dim path, homedir
path = ActiveWorkbook.path
homedir = Left(path, InStrRev(path, "\"))

Dim VBComp As VBIDE.VBComponent
Dim Sfx As String
'checken ob wir im entwicklungsverzeichnis sind oder passwortschutz auf das projekt, sonst nix machen
If (Not FileExists(ActiveWorkbook.path & "\dev.tag") Or IsProjectLocked) Then
    Exit Sub
End If
For Each VBComp In ActiveWorkbook.VBProject.VBComponents
    Select Case VBComp.Type
        Case vbext_ct_ClassModule, vbext_ct_Document
           Sfx = ".cls"
        Case vbext_ct_MSForm
           Sfx = ".frm"
        Case vbext_ct_StdModule
           Sfx = ".bas"
        Case Else
           Sfx = ""
    End Select
    If Sfx <> "" Then
       VBComp.Export _
          Filename:=homedir & "\modules\basis\" & VBComp.Name & Sfx
    End If
Next VBComp
End Sub

Public Function FileExists(sFilePath As String) As Boolean
 
    If Trim(sFilePath) = "" Then Exit Function
    If Right(sFilePath, 1) = "\" Then Exit Function
'// ------------------------------------------------------------------------
'// Fehlerhandling einschalten, um VB-Meldung abzufangen
'// ------------------------------------------------------------------------
    On Error Resume Next
    FileExists = Dir(sFilePath) <> ""
    FileExists = FileExists And Err.Number = 0
'// ------------------------------------------------------------------------
'// Fehlerhandling wieder auschalten
'// ------------------------------------------------------------------------
    On Error GoTo 0
 
End Function

'|fffd|bernimmt das format der ersten zeile f|fffd|r alle anderen
Sub musterzeile_ubernehmen()

Dim zeile As Range
Dim c As Integer
c = 1


ActiveSheet.Range("E12:Y12").Copy

For Each zeile In ActiveSheet.Rows
    zeile.Cells(1, 5).Select
    If (Selection.Interior.ColorIndex = 36) Then
            
         zeile.Cells(1, 5).PasteSpecial
         
    End If
    
    c = c + 1
    If (c > 550) Then
        Exit Sub
    End If
Next zeile
End Sub


'setzt die schriftgr|fffd||fffd|e in der summenzeile
Sub summenzeile()
    Dim i As Integer
    Dim ws As Worksheet
    Set ws = ActiveSheet
    For Each ws In Worksheets
    ws.Select
    For i = 1 To 1000
        If (ws.Cells(i, 4).Interior.ColorIndex = 44) Then
            ws.Cells(i, 4).EntireRow.Select
            With Selection.Font
        .Name = "Arial"
        .Size = 12
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .OutlineFont = False
        .Shadow = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
            End With
            
        End If
    Next i
     ws.Cells(1, 1).Select
    Next ws
End Sub




Sub selectA1()
Dim ws As Worksheet
For Each ws In Worksheets
    ws.Select
    ws.Range("D1").Font.ColorIndex = 2
    ws.Range("A1").Select
Next ws
End Sub

'checkt ob auf das Vbproject ein passwort gesetzt ist, damit Lieferanten den Makro Code nicht sehen konnen
Function IsProjectLocked() As Boolean
Dim vbpProj As VBIDE.VBProject

' Set reference to document's VBA project.
Set vbpProj = ActiveWorkbook.VBProject
' Check Protection property of VBA project.
If vbpProj.Protection = vbext_pp_locked Then
IsProjectLocked = True
Else
IsProjectLocked = False
End If
End Function


Sub encrypt()
     'this sub is only present to demonstrate use of the function!
     'it is not required to use the function.
    Dim r As Range, retVal, sKey As String
    sKey = Application.InputBox("Enter your key", "Key entry", "My Key", , , , , 2)
    retVal = MsgBox("This is the key you entered:" & vbNewLine & Chr$(34) & sKey & Chr$(34) & vbNewLine & _
    "Please confirm OK or Cancel to exit", vbOKCancel, "Confirm Key")
    If retVal = vbCancel Then Exit Sub
    For Each r In Sheets("Sheet1").UsedRange
        If r.Interior.ColorIndex = 6 Then
            r.Value = XorC(r.Value, sKey)
        End If
    Next r
End Sub
 
Function XorC(ByVal sData As String, ByVal sKey As String) As String
    Dim l As Long, i As Long, byIn() As Byte, byOut() As Byte, byKey() As Byte
    Dim bEncOrDec As Boolean
     'confirm valid string and key input:
    If Len(sData) = 0 Or Len(sKey) = 0 Then XorC = "Invalid argument(s) used": Exit Function
     'check whether running encryption or decryption (flagged by presence of "xxx" at start of sData):
    If Left$(sData, 3) = "xxx" Then
        bEncOrDec = False 'decryption
        sData = Mid$(sData, 4)
    Else
        bEncOrDec = True 'encryption
    End If
     'assign strings to byte arrays (unicode)
    byIn = sData
    byOut = sData
    byKey = sKey
    l = LBound(byKey)
    For i = LBound(byIn) To UBound(byIn) - 1 Step 2
        byOut(i) = ((byIn(i) + Not bEncOrDec) Xor byKey(l)) - bEncOrDec 'avoid Chr$(0) by using bEncOrDec flag
        l = l + 2
        If l > UBound(byKey) Then l = LBound(byKey) 'ensure stay within bounds of Key
    Next i
    XorC = byOut
    If bEncOrDec Then XorC = "xxx" & XorC 'add "xxx" onto encrypted text
End Function


Attribute VB_Name = "PB_SmokeTest"
'fuellt alle roten felder automatisch aus
'zu test zwecken
Sub auto_ausfullen()
Dim i As Integer
Dim zelle As Range
Randomize
Dim ws
For Each ws In Worksheets
ws.Select
If (Not Range("IV1").Value = "technik") Then
   GoTo NACHSTES
End If
For Each zelle In Range("A1:Z500").Cells
i = (Rnd * 100) + (Rnd * 50)
Debug.Print zelle.Validation.Value
If (Not zelle.Validation.Value) Then
    zelle.Value = i
    
End If
Next zelle
NACHSTES:
Next ws
End Sub

'traegt immer den preis 100 ein
Sub auto_ausfullen_100()
Dim i As Integer
Dim zelle As Range
Randomize
Dim ws
For Each ws In Worksheets
ws.Select
If (Not Range("IV1").Value = "technik") Then
   GoTo NACHSTES
End If
For Each zelle In Range("A1:Z500").Cells

Debug.Print zelle.Validation.Value
If (Not zelle.Validation.Value) Then
    zelle.Value = 100
    
End If
Next zelle
NACHSTES:
Next ws
End Sub

' funktion ist fuer kompatibilitaet mit altem test
Sub testMengenEintragen()
testMengen 3
End Sub

' traegt bei n Komponenten auf jedem Technikblatt eine Mengenangabe ein
Sub testMengen(anzahlKomponente As Integer, Optional testString As String)
Dim ws As Worksheet

Dim menge As Integer

menge = 1

For Each ws In Worksheets
ws.Select
'falls technikblatt vom typ 1
If (ws.Range("IV3").Value = "1") Then
Dim i As Integer
Dim c As Integer
c = 0
' ColorIndex = 15 heisst grau
For i = 11 To 100
'falls die zelle eine mengen eintrag zulasst
If (Rows(i).Cells(1, 5).Interior.ColorIndex = 15) Then
    Rows(i).Cells(1, 5).Value = menge
    c = c + 1
    If (c = anzahlKomponente) Then
        Exit For
    End If
End If
Next i

'falls technikblatt vom typ 2
ElseIf (ws.Range("IV3").Value = "2") Then
c = 0
For j = 11 To 100
'falls die zelle eine mengen eintrag zulasst
If (Rows(j).Cells(1, 5).Interior.ColorIndex = 15) Then
    Rows(j).Cells(1, 5).Value = menge
    Rows(j).Cells(1, 10).Value = menge
    c = c + 1
    If (c = anzahlKomponente) Then
        Exit For
    End If
End If
Next j

'falls technikblatt vom typ 3
ElseIf (ws.Range("IV3").Value = "3") Then

c = 0
For k = 11 To 100
'falls die zelle eine mengen eintrag zulasst
If (Rows(k).Cells(1, 5).Interior.ColorIndex = 15) Then

'auf Erg|fffd|nzungblatt, Nachtr|fffd|ge, oder Optionen checken
If (ws.Name = "Erg|fffd|nzungsblatt") Then
    Rows(k).Cells(1, 3).Value = "Erg|fffd|nzung " & k & " " & testString
    Rows(k).Cells(1, 4).Value = "meter"
ElseIf (ws.Name = "Optionen") Then
    Rows(k).Cells(1, 3).Value = "Option " & k & " " & testString
    Rows(k).Cells(1, 4).Value = "meter"
ElseIf (ws.Name = "Nachtr|fffd|ge") Then
    Rows(k).Cells(1, 3).Value = "Nachtrag " & k & " " & testString
    Rows(k).Cells(1, 4).Value = "meter"
End If



    
    Rows(k).Cells(1, 5).Value = menge
    Rows(k).Cells(1, 10).Value = menge
    Rows(k).Cells(1, 15).Value = menge
    c = c + 1
    If (c = anzahlKomponente) Then
        Exit For
    End If
End If
Next k

End If
Next ws
End Sub
Attribute VB_Name = "SheetAdmin"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Private ws As Worksheet



Public Sub doMengenAusschreibung()

End Sub


Public Sub doFunktionalAuschreibung()


End Sub


Public Sub spaltenEinblenden()
ws.Range("A:A").EntireColumn.Hidden = False
End Sub


Public Sub spaltenAusblenden()
ws.Range("A:A").EntireColumn.Hidden = True
End Sub

Public Sub zeilenEinblenden()

 ws.Cells.EntireRow.Hidden = False

End Sub


Public Sub zeilenAusblenden()

For x = 1 To 1600
   
   If (ws.Cells(x, 1).Value = "Nein") Then
        ws.Cells(x, 1).EntireRow.Hidden = True
    End If
   Next x

End Sub



Public Sub protect()
    ws.protect
End Sub


Public Sub unprotect()
    ws.unprotect
End Sub

Public Function isComponentRow(zeile As Range) As Boolean
    isComponentRow = False

End Function


Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
End Property
Attribute VB_Name = "SheetAdminDeckblatt"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit

Private ws As Worksheet
Private sa As New SheetAdmin

Public Sub doMengenAusschreibung()

End Sub



Public Sub doFunktionalAuschreibung()


End Sub



Public Sub spaltenEinblenden()
    ws.Range("A:A").EntireColumn.Hidden = False
   ws.Range("J:L").EntireColumn.Hidden = False
End Sub

Public Sub spaltenAusblenden()
    ws.Range("A:A").EntireColumn.Hidden = True
    ws.Range("J:L").EntireColumn.Hidden = True
End Sub



Public Sub zeilenEinblenden()
  
    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    ws.Cells.EntireRow.Hidden = False

'    For Each ws In Worksheets
'        ws.Visible = xlSheetVisible
'    Next ws


End Sub


Public Sub zeilenAusblenden()
Dim wsh As Worksheet

Dim saf As New SheetAdminFactory
Dim sa As Variant
    
Set sa = saf.getSheetAdmin(ActiveSheet)

Dim x As Integer
For x = 1 To 600
   If (ws.Cells(x, 1).Value = "Nein") Then
        ws.Cells(x, 1).EntireRow.Hidden = True
    End If
    
Next x

'For Each wsh In Worksheets
'If (wsh.Range("K1").Value = "Nein") Then
'        wsh.Visible = xlSheetHidden
'    Else
'        wsh.Visible = xlSheetVisible
'
'        wsh.Select
'        wsh.Cells(1, 1).Select
'
'        ActiveWindow.View = xlNormalView
'        ActiveWindow.Zoom = 75
'    End If
'Next wsh

End Sub



Public Sub protect()
    sa.protect
End Sub


Public Sub unprotect()
    sa.unprotect

End Sub



Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
    'Das Worksheet in der "Oberklasse" setzen
    sa.refWorksheet = ws
End Property


Attribute VB_Name = "SheetAdminFactory"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit






Public Function getSheetAdmin(ws As Worksheet) As Variant
'die erste leere spalte des worksheets suchen und es anhand
'dieser indentifizieren
    Dim colum As Range
    Dim firstEmptyColumn As Integer
    Dim typ As Integer
    For Each colum In ws.Columns
        If (isEmpty(colum)) Then
            firstEmptyColumn = colum.Column
            Exit For
        End If
    Next colum
    
    Select Case firstEmptyColumn
        Case 10
            typ = 4 '|fffd|bersicht
        Case 11
            typ = 1 'Engenieuring-Bl|fffd|tter
        Case 24
            typ = 2 '|fffd|bergreifende Elektrik
        Case 27
            typ = 3 'Technikbl|fffd|tter
        Case Else
            typ = 0
    End Select
    
    If (ws.Name = "Deckblatt") Then
        typ = 5
    End If
    
     
    If (ws.Name = "Hinweise ") Then
        typ = 6
    End If
    
     Dim v As Variant
    If (typ = 1) Then
        Set v = New SheetAdminTyp1
        v.refWorksheet = ws
        
    ElseIf (typ = 2) Then
        Set v = New SheetAdminTyp2
        v.refWorksheet = ws
        
    ElseIf (typ = 3) Then
        Set v = New SheetAdminTyp3
        v.refWorksheet = ws
    ElseIf (typ = 4) Then
        Set v = New SheetAdminUbersicht
        v.refWorksheet = ws
    ElseIf (typ = 5) Then
        Set v = New SheetAdminDeckblatt
        v.refWorksheet = ws
    ElseIf (typ = 6) Then
        Set v = New SheetAdminHinweise
        v.refWorksheet = ws
    Else
        Set v = New SheetAdmin
        v.refWorksheet = ws
    End If
    
    Set getSheetAdmin = v
End Function








'checkt ob ein Bereich leer ist
Private Function isEmpty(r As Range) As Boolean
    Dim c As Range
    Dim leer As Boolean
    leer = True
    
    For Each c In r.Cells
        If (c.Value <> "") Then
            leer = False
            Exit For
        End If
    Next c
    isEmpty = leer
End Function
Attribute VB_Name = "SheetAdminHinweise"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit

Private ws As Worksheet
Private sa As New SheetAdmin

Public Sub doMengenAusschreibung()

End Sub



Public Sub doFunktionalAuschreibung()


End Sub



Public Sub spaltenEinblenden()
    ws.Range("J:J").EntireColumn.Hidden = False
  
End Sub

Public Sub spaltenAusblenden()
    ws.Range("J:J").EntireColumn.Hidden = True
    
End Sub



Public Sub zeilenEinblenden()
  
    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    ws.Cells.EntireRow.Hidden = False

  

End Sub


Public Sub zeilenAusblenden()
Dim wsh As Worksheet

Dim saf As New SheetAdminFactory
Dim sa As Variant
    
Set sa = saf.getSheetAdmin(ActiveSheet)

Dim x As Integer
'Alle Zeilen ausblenden die f|fffd|r den Planer aber nicht f|fffd|r den Lieferanten sind
For x = 1 To 600
   If (ws.Cells(x, 10).Value = "X" And ws.Cells(x, 11).Value = "") Then
        ws.Cells(x, 1).EntireRow.Hidden = True
    End If
Next x



End Sub



Public Sub protect()
    sa.protect
End Sub


Public Sub unprotect()
    sa.unprotect

End Sub



Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
    'Das Worksheet in der "Oberklasse" setzen
    sa.refWorksheet = ws
End Property

Attribute VB_Name = "SheetAdminTyp1"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit

Private ws As Worksheet
Private sa As New SheetAdmin

Public Sub doMengenAusschreibung()

    Dim zeile As Range
    For Each zeile In ws.Rows
    If (zeile.Cells(1, 5).Interior.ColorIndex = 36 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 15
        zeile.Cells(1, 5).Locked = True
    End If
    If (zeile.Row > 200) Then
        Exit For
    End If
    Next zeile

End Sub



Public Sub doFunktionalAuschreibung()

 Dim zeile As Range
    For Each zeile In ws.Rows
    If (zeile.Cells(1, 5).Interior.ColorIndex = 15 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 36
        zeile.Cells(1, 5).Locked = False
    End If
    If (zeile.Row > 200) Then
        Exit For
    End If
    Next zeile


End Sub



Public Sub spaltenEinblenden()
   ws.Range("A:A,J:J,F:F,I:I").EntireColumn.Hidden = False
End Sub

Public Sub spaltenAusblenden()

    ws.Range("A:A,J:J,F:F,I:I").EntireColumn.Hidden = True
End Sub



Public Sub zeilenEinblenden()
   sa.zeilenEinblenden

End Sub


Public Sub zeilenAusblenden()
    sa.zeilenAusblenden

End Sub



Public Sub protect()
    sa.protect
End Sub


Public Sub unprotect()
    sa.unprotect

End Sub



Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
    'Das Worksheet in der "Oberklasse" setzen
    sa.refWorksheet = ws
End Property
Attribute VB_Name = "SheetAdminTyp2"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit

Private ws As Worksheet
Private sa As New SheetAdmin

Public Sub doMengenAusschreibung()

    Dim zeile As Range
    For Each zeile In ws.Rows
    If (zeile.Cells(1, 5).Interior.ColorIndex = 36 And zeile.Cells(1, 9).Interior.ColorIndex = 36 And zeile.Cells(1, 13).Interior.ColorIndex = 36 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 15
        zeile.Cells(1, 9).Interior.ColorIndex = 15
        zeile.Cells(1, 13).Interior.ColorIndex = 15
        
        zeile.Cells(1, 5).Locked = True
        zeile.Cells(1, 9).Locked = True
        zeile.Cells(1, 13).Locked = True
    End If
    If (zeile.Row > 200) Then
        Exit For
    End If
    Next zeile

End Sub



Public Sub doFunktionalAuschreibung()

       Dim zeile As Range
    For Each zeile In ws.Rows
    If (zeile.Cells(1, 5).Interior.ColorIndex = 15 And zeile.Cells(1, 9).Interior.ColorIndex = 15 And zeile.Cells(1, 13).Interior.ColorIndex = 15 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 36
        zeile.Cells(1, 9).Interior.ColorIndex = 36
        zeile.Cells(1, 13).Interior.ColorIndex = 36
        
        zeile.Cells(1, 5).Locked = False
        zeile.Cells(1, 9).Locked = False
        zeile.Cells(1, 13).Locked = False
    End If
    If (zeile.Row > 200) Then
        Exit For
    End If
    Next zeile


End Sub



Public Sub spaltenEinblenden()
   
   ws.Range("A:A,F:F,J:J,N:N,S:Y").EntireColumn.Hidden = False
    
End Sub



Public Sub spaltenAusblenden()
    ws.Range("A:A,F:F,J:J,N:N,S:Y").EntireColumn.Hidden = True
End Sub

Public Sub zeilenEinblenden()
   sa.zeilenEinblenden

End Sub


Public Sub zeilenAusblenden()
    sa.zeilenAusblenden

End Sub



Public Sub protect()
    sa.protect
End Sub


Public Sub unprotect()
    sa.unprotect

End Sub



Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
    'Das Worksheet in der "Oberklasse" setzen
    sa.refWorksheet = ws
End Property

Attribute VB_Name = "SheetAdminTyp3"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit

Private ws As Worksheet
Private sa As New SheetAdmin

Public Sub doMengenAusschreibung()
Dim zeile As Range
    For Each zeile In ws.Rows
    If (zeile.Cells(1, 5).Interior.ColorIndex = 36 And zeile.Cells(1, 10).Interior.ColorIndex = 36 And zeile.Cells(1, 15).Interior.ColorIndex = 36 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 15
        zeile.Cells(1, 10).Interior.ColorIndex = 15
        zeile.Cells(1, 15).Interior.ColorIndex = 15
        
        zeile.Cells(1, 5).Locked = True
        zeile.Cells(1, 10).Locked = True
        zeile.Cells(1, 15).Locked = True
        
    End If
    If (zeile.Row > 1600) Then
        Exit For
    End If
    Next zeile



End Sub



Public Sub doFunktionalAuschreibung()

       Dim zeile As Range
    For Each zeile In ws.Rows
    If (zeile.Cells(1, 5).Interior.ColorIndex = 15 And zeile.Cells(1, 10).Interior.ColorIndex = 15 And zeile.Cells(1, 15).Interior.ColorIndex = 15 And zeile.Row > 10) Then
        zeile.Cells(1, 5).Interior.ColorIndex = 36
        zeile.Cells(1, 10).Interior.ColorIndex = 36
        zeile.Cells(1, 15).Interior.ColorIndex = 36
        
         zeile.Cells(1, 5).Locked = False
        zeile.Cells(1, 10).Locked = False
        zeile.Cells(1, 15).Locked = False
        
    End If
    If (zeile.Row > 1600) Then
        Exit For
    End If
    Next zeile



End Sub



Public Sub spaltenEinblenden()
   
   ws.Range("A:A,F:F,K:K,P:P,V:Z").EntireColumn.Hidden = False
    
End Sub


Public Sub spaltenAusblenden()

 ws.Range("A:A,F:F,K:K,P:P,V:Z").EntireColumn.Hidden = True
    
End Sub


Public Sub zeilenEinblenden()
   sa.zeilenEinblenden

End Sub


Public Sub zeilenAusblenden()
    sa.zeilenAusblenden

End Sub



Public Sub protect()
    sa.protect
End Sub


Public Sub unprotect()
    sa.unprotect

End Sub



Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
    'Das Worksheet in der "Oberklasse" setzen
    sa.refWorksheet = ws
End Property

Attribute VB_Name = "SheetAdminUbersicht"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False














Option Explicit

Private ws As Worksheet
Private sa As New SheetAdmin

Public Sub doMengenAusschreibung()

End Sub



Public Sub doFunktionalAuschreibung()


End Sub



Public Sub spaltenEinblenden()
    ws.Range("A:A,F:I").EntireColumn.Hidden = False
End Sub

Public Sub spaltenAusblenden()
    ws.Range("A:A,F:I").EntireColumn.Hidden = True
End Sub




Public Sub zeilenEinblenden()
  
    Dim saf As New SheetAdminFactory
    Dim sa As Variant
    
    Set sa = saf.getSheetAdmin(ActiveSheet)
    ws.Cells.EntireRow.Hidden = False

    For Each ws In Worksheets
        ws.Visible = xlSheetVisible
    Next ws


End Sub


Public Sub zeilenAusblenden()
Dim wsh As Worksheet

Dim saf As New SheetAdminFactory
Dim sa As Variant
    
Set sa = saf.getSheetAdmin(ActiveSheet)

Dim x As Integer
For x = 1 To 600
   If (ws.Cells(x, 1).Value = "Nein") Then
        ws.Cells(x, 1).EntireRow.Hidden = True
    End If
    If (ws.Cells(x, 2).Value = "Nachtr|fffd|ge") Then
        ws.Cells(x, 1).EntireRow.Hidden = True
    End If
Next x

For Each wsh In Worksheets
If (wsh.Range("K1").Value = "Nein") Then
        wsh.Visible = xlSheetHidden
    Else
        wsh.Visible = xlSheetVisible
        
        wsh.Select
        wsh.Cells(1, 1).Select
    
        ActiveWindow.View = xlNormalView
        ActiveWindow.Zoom = 75
    End If
Next wsh

End Sub



Public Sub protect()
    sa.protect
End Sub


Public Sub unprotect()
    sa.unprotect

End Sub



Public Property Get refWorksheet() As Variant
    Set refWorksheet = ws
End Property

Public Property Let refWorksheet(ByVal vNewValue As Variant)
    Set ws = vNewValue
    
    'Das Worksheet in der "Oberklasse" setzen
    sa.refWorksheet = ws
End Property

Attribute VB_Name = "Tabelle18"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Sub schreibeBlocke()

End Sub














Attribute VB_Name = "Tabelle191"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Sub schreibeBlocke()
'Optionen
range_into_db id_anlage, id_lieferant, "16", "16.1", "0.0.0", "O_1"
End Sub














Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Sub schreibeBlocke()
'EHB 500
range_into_db id_anlage, id_lieferant, "4", "4.1", "0.0.0", "EHB500_1"
range_into_db id_anlage, id_lieferant, "4", "4.2", "0.0.0", "EHB500_2"
range_into_db id_anlage, id_lieferant, "4", "4.3", "0.0.0", "EHB500_3"
range_into_db id_anlage, id_lieferant, "4", "4.4", "0.0.0", "EHB500_4"
range_into_db id_anlage, id_lieferant, "4", "4.5", "0.0.0", "EHB500_5"
range_into_db id_anlage, id_lieferant, "4", "4.6", "0.0.0", "EHB500_6"
range_into_db id_anlage, id_lieferant, "4", "4.7", "0.0.0", "EHB500_7"
range_into_db id_anlage, id_lieferant, "4", "4.8", "0.0.0", "EHB500_8"
range_into_db id_anlage, id_lieferant, "4", "4.9", "0.0.0", "EHB500_9"
range_into_db id_anlage, id_lieferant, "4", "4.10", "0.0.0", "EHB500_10"
range_into_db id_anlage, id_lieferant, "4", "4.11", "0.0.0", "EHB500_11"
range_into_db id_anlage, id_lieferant, "4", "4.12", "0.0.0", "EHB500_12"
range_into_db id_anlage, id_lieferant, "4", "4.13", "0.0.0", "EHB500_13"
End Sub
















Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


















Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Sub schreibeBlocke()
'engineering  mechanik

range_into_db id_anlage, id_lieferant, "1", "1.1", "0.0.0", "EM_1_1"
range_into_db id_anlage, id_lieferant, "1", "1.2", "0.0.0", "EM_1_2"
range_into_db id_anlage, id_lieferant, "1", "1.3", "0.0.0", "EM_2_1"
range_into_db id_anlage, id_lieferant, "1", "1.4", "0.0.0", "EM_3_1"
range_into_db id_anlage, id_lieferant, "1", "1.5", "0.0.0", "EM_3_2"
range_into_db id_anlage, id_lieferant, "1", "1.6", "0.0.0", "EM_4_1"
range_into_db id_anlage, id_lieferant, "1", "1.7", "0.0.0", "EM_5_1"
range_into_db id_anlage, id_lieferant, "1", "1.8", "0.0.0", "EM_6_1"
range_into_db id_anlage, id_lieferant, "1", "1.9", "0.0.0", "EM_7_1"
range_into_db id_anlage, id_lieferant, "1", "1.10", "0.0.0", "EM_8"
End Sub

















Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Sub schreibeBlocke()
'|fffd|bergreifende Elektrik
range_into_db id_anlage, id_lieferant, "3", "3.1", "0.0.0", "UeE_1"
range_into_db id_anlage, id_lieferant, "3", "3.2", "0.0.0", "UeE_2"
range_into_db id_anlage, id_lieferant, "3", "3.3", "0.0.0", "UeE_3"
range_into_db id_anlage, id_lieferant, "3", "3.4", "0.0.0", "UeE_4"
range_into_db id_anlage, id_lieferant, "3", "3.5", "0.0.0", "UeE_5"
range_into_db id_anlage, id_lieferant, "3", "3.6", "0.0.0", "UeE_6"
range_into_db id_anlage, id_lieferant, "3", "3.7", "0.0.0", "UeE_7"
End Sub
















Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Sub schreibeBlocke()
'|fffd|bergreifendes
range_into_db id_anlage, id_lieferant, "13", "13.1", "0.0.0", "Ue_1"
range_into_db id_anlage, id_lieferant, "13", "13.2", "0.0.0", "Ue_2"
range_into_db id_anlage, id_lieferant, "13", "13.3", "0.0.0", "Ue_3"
End Sub
















Attribute VB_Name = "Tabelle7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Sub schreibeBlocke()
'Stahlbau
range_into_db id_anlage, id_lieferant, "14", "14.1", "0.0.0", "StB_1"
range_into_db id_anlage, id_lieferant, "14", "14.2", "0.0.0", "StB_2"
range_into_db id_anlage, id_lieferant, "14", "14.3", "0.0.0", "StB_3"
range_into_db id_anlage, id_lieferant, "14", "14.4", "0.0.0", "StB_4"
End Sub
















Attribute VB_Name = "Tabelle8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Sub schreibeBlocke()
'Erg|fffd|nzungsblatt
range_into_db id_anlage, id_lieferant, "15", "15.1", "0.0.0", "EB_1"
range_into_db id_anlage, id_lieferant, "15", "15.2", "0.0.0", "EB_2"
range_into_db id_anlage, id_lieferant, "15", "15.3", "0.0.0", "EB_3"
range_into_db id_anlage, id_lieferant, "15", "15.4", "0.0.0", "EB_4"
range_into_db id_anlage, id_lieferant, "15", "15.5", "0.0.0", "EB_5"
End Sub
















Attribute VB_Name = "Tabelle81"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


















Attribute VB_Name = "TestModul"
Sub foo()
    Dim ws As Worksheet
Dim saf As New SheetAdminFactory
Dim sa As Variant
    
    

    MsgBox "Suchen"
    Set sa = saf.getSheetAdmin(ActiveSheet)
    MsgBox "Spalten ausblenden"
    'sa.unprotect
    sa.spaltenAusblenden
    MsgBox "Zeilen ausblenden"
    sa.zeilenAusblenden
    'ws.protect password:=s_pw1
    
End Sub




Sub bar()
 Dim path
    path = ActiveWorkbook.path
    homedir = Left(path, InStrRev(path, "\"))
    MsgBox homedir
End Sub

Sub test()
    Worksheets(4).schreibeBlocke
End Sub

Sub labelSheets()
For Each ws In Worksheets
    ws.Range("IV1").Value = "technik"
Next ws
End Sub
Attribute VB_Name = "frm1"
Attribute VB_Base = "0{88E362F2-738E-4B4E-B1CA-950124089F90}{4771321E-5007-4421-A465-37D9C05E25CC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
















Option Explicit


Private Sub CommandButton1_Click()
Dim s_pw1 As String
Dim s_pw2 As String

s_pw1 = pw1.Text
s_pw2 = pw2.Text



On Error GoTo FEHLER
If (pw1 <> pw2) Then
    Err.Raise 666
End If

If (Worksheets(2).Range("B3").Value = 1) Then
    Worksheets(2).Range("IV1").Value = XorC(pw1, "Neckarsulm")
End If

lieferanten_modus s_pw1

frm1.Hide
GoTo ENDE

FEHLER:
If (Err.Number = 666) Then
MsgBox "Das Passwort stimmt nicht |fffd|berein"
Else
MsgBox "Fehler !" & Err.Number & "," & Err.Description & "," & Err.Source

End If

frm1.Hide

ENDE:
End Sub

Attribute VB_Name = "frm2"
Attribute VB_Base = "0{EE923CD1-4099-459A-9973-8B170FF7CF12}{6E93AF7C-9D7F-46D9-9E99-8E6AEE04AF70}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False















Private Sub CommandButton1_Click()

Dim password As String

password = pw1.Text
    
On Error GoTo FEHLER

planer_modus (password)

frm2.Hide
GoTo ENDE:

FEHLER:
Select Case Err.Number
Case 1004
    MsgBox "Falsches Passwort"
    frm2.Hide
Case Else
    MsgBox Err.Number
End Select

ENDE:
End Sub

' InQuest injected base64 decoded content
' *'jV
' *'jV

INQUEST-PP=macro
