Attribute VB_Name = "AcceptRejectForm"
Attribute VB_Base = "0{70DDF8EC-5F9F-44BF-A31A-98A8C4E077AB}{7B6CF56A-31FA-4CCA-AD2F-9F440EEFDECA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub AcceptButton_Click()
  RJF (1)
End Sub

Private Sub CancelButton_Click()
  RJF (0)
End Sub

Private Sub RejectButton_Click()
  RJF (2)
End Sub

Private Sub Skipbutton_Click()
  RJF (3)
End Sub
Attribute VB_Name = "ConvertForm"
Attribute VB_Base = "0{0B40B2A2-AC57-4076-AC03-88A8522EF811}{F5BE601E-9E73-46C4-869F-B1EC5B366910}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub ConvertCancelButton_Click()
  ConvertForm.hide
End Sub

Private Sub NumeralsToTextButton_Click()
  NumeralsToWords (1)
End Sub

Private Sub RomanToArabicButton_Click()
  RomanToArabic (1)
End Sub

Private Sub TextToNumButton_Click()
  TextToNumbers (ConvertForm.ThousandsComma.Value)
End Sub
Attribute VB_Name = "CopyLayoutForm"
Attribute VB_Base = "0{A8C03F1A-5A85-4C5C-88DD-7BFAF550E49C}{8750A345-3E4A-4750-8A71-7302117EBF28}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub CancelButton_Click()
  CopyLayoutForm.hide
End Sub

Private Sub CopyLayoutButton_Click()
  GO_CopyLayout (1)
End Sub

Private Sub SourceListbox_Click()
  getSource (1)
End Sub
Attribute VB_Name = "CopyLayoutModule"
Option Explicit
Dim SourceSect As Section
Dim SourceSectNo As Long
Dim ThisSect As Section
Dim FromDoc As String
Dim Thisdoc As String
Dim ThisSectno As Long

Sub CopySectionLoad(n As Long)
Dim aDoc As Document
Dim k As Long
Dim j As Long
  If Selection.Sections.Count > 1 Then
    MsgBox "Selection must be in only one section"
    Exit Sub
  End If
  Thisdoc = ActiveDocument.Name
  ThisSectno = Selection.Information(wdActiveEndSectionNumber)
  Set ThisSect = Selection.Sections.First
  With CopyLayoutForm
    .StartUpPosition = 0
    .Top = 100
    .Left = hPoints - .Width - 30
    .SourceDocLabel.Caption = ""
    .ThisDocLabel = Thisdoc & vbCrLf & "Section" & Str(ThisSectno)
    .Show
    With .SourceListbox
      .Clear
      .AddItem Thisdoc
      k = Application.Documents.Count
      For j = 1 To k
        Set aDoc = Application.Documents(j)
        If aDoc.Name <> Thisdoc Then
         .AddItem aDoc.Name
         k = k + 1
        End If
      Next j
      .ListIndex = -1
    End With
  End With
End Sub

Sub getSource(n As Long)
Dim s As String
  FromDoc = CopyLayoutForm.SourceListbox.List(CopyLayoutForm.SourceListbox.ListIndex)
  If FromDoc = Thisdoc Then
    s = InputBox("Enter section number to copy from")
    SourceSectNo = Val(s)
    If SourceSectNo = ThisSectno Or SourceSectNo = 0 Or SourceSectNo > Documents(FromDoc).Sections.Count Then
      MsgBox "Not a valid section number or same as destination section"
      CopyLayoutForm.SourceListbox.ListIndex = -1
      Exit Sub
    End If
    Set SourceSect = Documents(FromDoc).Sections(SourceSectNo)
  Else
    Documents(FromDoc).Activate
    SourceSectNo = Selection.Information(wdActiveEndSectionNumber)
    Set SourceSect = Selection.Sections.First
    Documents(Thisdoc).Activate
  End If
 CopyLayoutForm.SourceDocLabel.Caption = FromDoc & vbCrLf & "Section" & Str(SourceSectNo)
End Sub

Sub GO_CopyLayout(n As Long)
  
  With CopyLayoutForm
    If .SourceDocLabel.Caption = "" Or .SourceListbox.ListIndex < 0 Then
      notification ("No source chosen")
      Exit Sub
    End If
    If Not CopySectionLayout(ThisSect, SourceSect, .PageCheckbox.Value, .HeaderCheckbox.Value, .FooterCheckbox.Value) Then
      MsgBox "ERROR. The document may be corrupted"
    Else
      notification ("Copy finished")
      CopyLayoutForm.hide
    End If
  End With
End Sub


Sub RemoveSection(n As Long)
Dim Sctn1 As Section, Sctn2 As Section
Dim aRange As Range
  With Selection
    If .Sections.Count = 1 Then
      MsgBox "Selection does not span a Section break", vbExclamation
      Exit Sub
    End If
  End With
  Set Sctn1 = Selection.Sections.First
  Set Sctn2 = Selection.Sections.Last
  If CopySectionLayout(Sctn1, Sctn2, True, True, True) Then
    With Selection
      While .Sections.Count > 1
        .Sections.First.Range.Characters.Last.Select
        Set aRange = Selection.Range
        aRange.Collapse
        .Sections.First.Range.Characters.Last.Delete
        aRange.Select
        On Error Resume Next
        Selection.InsertBreak (wdPageBreak)
        On Error GoTo 0
      Wend
    End With
  Else
    notification ("Error in removing section break" & vbCrLf & "Check document")
  End If
  
Set Sctn1 = Nothing: Set Sctn2 = Nothing
End Sub

Function CopySectionLayout(ByRef Sctn1 As Section, ByVal Sctn2 As Section, _
   LayoutSW As Boolean, headerSW As Boolean, FooterSw As Boolean) As Boolean
' copy section layout from Section 1 to Section 2 *************
Application.ScreenUpdating = False
Dim sPageHght As Single, sPageWdth As Single
Dim sHeaderDist As Single, sFooterDist As Single
Dim sTMargin As Single, sBMargin As Single
Dim sLMargin As Single, sRMargin As Single
Dim sGutter As Single, sGutterPos As Single
Dim lPaperSize As Long, lGutterStyle As Long
Dim lMirrorMargins As Long, lVerticalAlignment As Long
Dim lScnStart As Long, lScnDir As Long
Dim lOddEvenHdFt As Long, lDiffFirstHdFt As Long
Dim bTwoPagesOnOne As Boolean, bBkFldPrnt As Boolean
Dim bBkFldPrnShts As Boolean, bBkFldRevPrnt As Boolean
Dim bOrientation As Long, oHdFt As HeaderFooter
Dim aRange As Range
'Dim Sctn1 As Section, Sctn2 As Section
CopySectionLayout = False
'On Error GoTo Cerr
With Selection
'  Set Sctn1 = .Sections.First: Set Sctn2 = .Sections.Last
 If LayoutSW Then
  With Sctn1.PageSetup
    lPaperSize = .PaperSize
    lGutterStyle = .GutterStyle
    bOrientation = .Orientation
    lMirrorMargins = .MirrorMargins
    lScnStart = .SectionStart
    lScnDir = .SectionDirection
    lOddEvenHdFt = .OddAndEvenPagesHeaderFooter
    lDiffFirstHdFt = .DifferentFirstPageHeaderFooter
    lVerticalAlignment = .VerticalAlignment
    sPageHght = .PageHeight
    sPageWdth = .PageWidth
    sTMargin = .TopMargin
    sBMargin = .BottomMargin
    sLMargin = .LeftMargin
    sRMargin = .RightMargin
    sGutter = .Gutter
    sGutterPos = .GutterPos
    sHeaderDist = .HeaderDistance
    sFooterDist = .FooterDistance
    bTwoPagesOnOne = .TwoPagesOnOne
    bBkFldPrnt = .BookFoldPrinting
    bBkFldPrnShts = .BookFoldPrintingSheets
    bBkFldRevPrnt = .BookFoldRevPrinting
  End With
  With Sctn2.PageSetup
    .GutterStyle = lGutterStyle
    .MirrorMargins = lMirrorMargins
    .SectionStart = lScnStart
    .SectionDirection = lScnDir
    .OddAndEvenPagesHeaderFooter = lOddEvenHdFt
    .DifferentFirstPageHeaderFooter = lDiffFirstHdFt
    .VerticalAlignment = lVerticalAlignment
    .PageHeight = sPageHght
    .PageWidth = sPageWdth
    .TopMargin = sTMargin
    .BottomMargin = sBMargin
    .LeftMargin = sLMargin
    .RightMargin = sRMargin
    .Gutter = sGutter
    .GutterPos = sGutterPos
    .HeaderDistance = sHeaderDist
    .FooterDistance = sFooterDist
    .TwoPagesOnOne = bTwoPagesOnOne
    .BookFoldPrinting = bBkFldPrnt
    .BookFoldPrintingSheets = bBkFldPrnShts
    .BookFoldRevPrinting = bBkFldRevPrnt
    .PaperSize = lPaperSize
    .Orientation = bOrientation
  End With
 End If
 
  With Sctn2
    If FooterSw Then
      For Each oHdFt In .Footers
        oHdFt.LinkToPrevious = Sctn1.Footers(oHdFt.Index).LinkToPrevious
        If oHdFt.LinkToPrevious = False Then
          With oHdFt.Range
            .FormattedText = Sctn1.Footers(oHdFt.Index).Range.FormattedText
            Do While .Characters.Last.Previous = vbCr
              .Characters.Last.Previous.Delete
              If .Characters.Count = 1 Then Exit Do
            Loop
          End With
        End If
      Next oHdFt
    End If
    If headerSW Then
      For Each oHdFt In .Headers
        oHdFt.LinkToPrevious = Sctn1.Headers(oHdFt.Index).LinkToPrevious
        If oHdFt.LinkToPrevious = False Then
          With oHdFt.Range
            .FormattedText = Sctn1.Headers(oHdFt.Index).Range.FormattedText
            Do While .Characters.Last.Previous = vbCr
              .Characters.Last.Previous.Delete
              If .Characters.Count = 1 Then Exit Do
            Loop
          End With
        End If
      Next oHdFt
    End If
  End With
End With
Application.ScreenUpdating = True
CopySectionLayout = True
Exit Function
Cerr:
'MsgBox "Error. Your document may be corrupted"
End Function


Sub RemoveSectionBreakZZZZZ()
'Keeps page layout and footers/headers of preceding section *************
Application.ScreenUpdating = False
Dim sPageHght As Single, sPageWdth As Single
Dim sHeaderDist As Single, sFooterDist As Single
Dim sTMargin As Single, sBMargin As Single
Dim sLMargin As Single, sRMargin As Single
Dim sGutter As Single, sGutterPos As Single
Dim lPaperSize As Long, lGutterStyle As Long
Dim lMirrorMargins As Long, lVerticalAlignment As Long
Dim lScnStart As Long, lScnDir As Long
Dim lOddEvenHdFt As Long, lDiffFirstHdFt As Long
Dim bTwoPagesOnOne As Boolean, bBkFldPrnt As Boolean
Dim bBkFldPrnShts As Boolean, bBkFldRevPrnt As Boolean
Dim bOrientation As Long, oHdFt As HeaderFooter
Dim Sctn1 As Section, Sctn2 As Section
With Selection
  If .Sections.Count = 1 Then
    MsgBox "Selection does not span a Section break", vbExclamation
    Exit Sub
  End If
  Set Sctn1 = .Sections.First: Set Sctn2 = .Sections.Last
  With Sctn1.PageSetup
    lPaperSize = .PaperSize
    lGutterStyle = .GutterStyle
    bOrientation = .Orientation
    lMirrorMargins = .MirrorMargins
    lScnStart = .SectionStart
    lScnDir = .SectionDirection
    lOddEvenHdFt = .OddAndEvenPagesHeaderFooter
    lDiffFirstHdFt = .DifferentFirstPageHeaderFooter
    lVerticalAlignment = .VerticalAlignment
    sPageHght = .PageHeight
    sPageWdth = .PageWidth
    sTMargin = .TopMargin
    sBMargin = .BottomMargin
    sLMargin = .LeftMargin
    sRMargin = .RightMargin
    sGutter = .Gutter
    sGutterPos = .GutterPos
    sHeaderDist = .HeaderDistance
    sFooterDist = .FooterDistance
    bTwoPagesOnOne = .TwoPagesOnOne
    bBkFldPrnt = .BookFoldPrinting
    bBkFldPrnShts = .BookFoldPrintingSheets
    bBkFldRevPrnt = .BookFoldRevPrinting
  End With
  With Sctn2.PageSetup
    .GutterStyle = lGutterStyle
    .MirrorMargins = lMirrorMargins
    .SectionStart = lScnStart
    .SectionDirection = lScnDir
    .OddAndEvenPagesHeaderFooter = lOddEvenHdFt
    .DifferentFirstPageHeaderFooter = lDiffFirstHdFt
    .VerticalAlignment = lVerticalAlignment
    .PageHeight = sPageHght
    .PageWidth = sPageWdth
    .TopMargin = sTMargin
    .BottomMargin = sBMargin
    .LeftMargin = sLMargin
    .RightMargin = sRMargin
    .Gutter = sGutter
    .GutterPos = sGutterPos
    .HeaderDistance = sHeaderDist
    .FooterDistance = sFooterDist
    .TwoPagesOnOne = bTwoPagesOnOne
    .BookFoldPrinting = bBkFldPrnt
    .BookFoldPrintingSheets = bBkFldPrnShts
    .BookFoldRevPrinting = bBkFldRevPrnt
    .PaperSize = lPaperSize
    .Orientation = bOrientation
  End With
  With Sctn2
    For Each oHdFt In .Footers
      oHdFt.LinkToPrevious = Sctn1.Footers(oHdFt.Index).LinkToPrevious
      If oHdFt.LinkToPrevious = False Then
        With oHdFt.Range
          .FormattedText = Sctn1.Footers(oHdFt.Index).Range.FormattedText
          Do While .Characters.Last.Previous = vbCr
            .Characters.Last.Previous.Delete
            If .Characters.Count = 1 Then Exit Do
          Loop
        End With
      End If
    Next
    For Each oHdFt In .Headers
      oHdFt.LinkToPrevious = Sctn1.Headers(oHdFt.Index).LinkToPrevious
      If oHdFt.LinkToPrevious = False Then
        With oHdFt.Range
          .FormattedText = Sctn1.Headers(oHdFt.Index).Range.FormattedText
          Do While .Characters.Last.Previous = vbCr
            .Characters.Last.Previous.Delete
            If .Characters.Count = 1 Then Exit Do
          Loop
        End With
      End If
    Next
  End With
  While .Sections.Count > 1
    .Sections.First.Range.Characters.Last.Delete
  Wend
End With
Set Sctn1 = Nothing: Set Sctn2 = Nothing
Application.ScreenUpdating = True
End Sub

Attribute VB_Name = "HelpModule"
Option Explicit
Sub HelpSub(n As Long)
Dim s As String
  With HotKeysForm
    With .HelpTxt1
      s = "TRACK CHANGES" & vbCrLf & "Accept or Reject will step through revisions in the selection and give the opportunity to individually accept or reject. Cursor in a revision to change just that revision." & vbCrLf & vbCrLf & _
              "Accept all changes will give the final text of the whole document." & vbCrLf & vbCrLf & _
              "Options will display the Track Changes options dialog." & vbCrLf & vbCrLf
      s = s & "SPECIAL HOT KEYS FOR SETTING CASE" & vbCrLf & _
        "Case changes operate similar to Word's case changes but with differences." & vbCrLf & vbCrLf & _
        "Mark any text or place the cursor within the word then click the appropriate action button or use the hot key shown." & vbCrLf & vbCrLf & _
        "TITLE CASE capitalises the first character of each selected word except if it is a minor word, but always if the minor word is the first word of the sentence." & vbCrLf & _
       "Minor words: this at that and with by to the for as of from or in a an on" & vbCrLf & vbCrLf & _
       "SENTENCE CASE capitalises the first character of each selected sentence and removes any capitals from other words in the sentence. If a part sentence is selected then the whole sentence is processed." & vbCrLf & vbCrLf & _
        "UPPER and LOWER CASE operate on words or a group of words if more than one word is selected. You only need to click within the word or select one or more characters to change the whole word." & vbCrLf & vbCrLf & _
        "With any of the case changes, a single i is always capitalised."
        s = s & vbCrLf & vbCrLf & "Track changes will show only the changed characters, not the whole word."
 
        s = s & vbCrLf & vbCrLf & "NUMBERS TO TEXT. Place the cursor anywhere in the number or select the number. The number must be an integer up to 999 million. The number can include thousands commas. If preceeded by a $ then the word 'dollars' is added. The first word is capitalised if it is the first word in a paragraph."
        s = s & " Select the conversion option and click the Numbers to text button."
          
        s = s & vbCrLf & vbCrLf & "TEXT TO NUMBERS.  Select the phrase and click the Text to numbers button."
        s = s & " The phrase can be in any case and include 'and' and the character '-'. The phrase can be for a number up to nine hundred and ninety million." & vbCrLf & "Example: 'Nine hundred and seventy four thousand three hundred and five'"
        s = s & vbCrLf & vbCrLf & "DELETE SECTION BREAK. Will use the layout and headers/footers of first section for the combined sections whereas simply deleting the section break which will use the layout of the second section."
        s = s & vbCrLf & vbCrLf & "COPY SECTION DATA. Copies layout and header/footers from another section that may be in the same or another open document"
      .Caption = s
    End With
    .Show
  End With
End Sub
Attribute VB_Name = "HotKeyModule"
Option Explicit
Public vPoints As Single
Public hPoints As Single
Public inhibitClick As Boolean
Dim rr As Range
Dim rw As Range
Dim sTitle ' array of short titles
Dim ww As Range
Dim ch As Range
Dim showHold As Boolean
Dim wordCount As Long
Dim arj As Long
Dim shortHeight As Long
Dim longHeight As Long

Sub Go_HOTKEY()
  If Val(Application.Version) > 14 Then
    shortHeight = 250
    longHeight = 581  '621
  Else
    shortHeight = 242
    longHeight = 573  '613
  End If
  Open_Track_Changes
End Sub

Private Sub Open_Track_Changes()
  Call GiveScreenPoints(hPoints, vPoints)
  inhibitClick = False
  With TrackChangeForm
    .StartUpPosition = 0
    .Top = 0
    .Left = hPoints - .Width - 6
    .TCWhileEditing.Value = ActiveDocument.TrackRevisions
  '  .HighlightOnScreen.Value = ActiveWindow.View.ShowRevisionsAndComments
    .HoverCheckbox.Value = ActiveWindow.DisplayScreenTips
    .MoreButton.Caption = "More >>"
    .Height = shortHeight
    .Show
  End With
  show_Settings (1)
  CountRevisions
  Get_ShortTitles
 ' TrackChangeForm.Show ' ######################################
End Sub

Sub toggleHeight(n As Long)
  With TrackChangeForm
    If .MoreButton.Caption = "More >>" Then
      .Height = longHeight
      .MoreButton.Caption = "<< Less"
    Else
      .Height = shortHeight
      .MoreButton.Caption = "More >>"
    End If
  End With
End Sub

Sub show_Settings(n As Long)
  With TrackChangeForm
    .FormattingCheckbox.Value = ActiveWindow.View.ShowFormatChanges
    .InsertCheckbox.Value = ActiveWindow.View.ShowInsertionsAndDeletions
    .CommentsCheckbox.Value = ActiveWindow.View.ShowComments
    .TCWhileEditing.Value = ActiveDocument.TrackRevisions
    .HighlightOnScreen.Value = ActiveWindow.View.ShowRevisionsAndComments
  End With
  Selection.Range.Select
End Sub

Sub ToggleHoverSetting(n As Long)
  If TrackChangeForm.HoverCheckbox Then
    ActiveWindow.DisplayScreenTips = True
  Else
    ActiveWindow.DisplayScreenTips = False
  End If
End Sub

Sub change_Case(n As Long)
Dim rrhold As Range
  '  1=title sentences (disabled), 2=sentence, 3=uppercase, 4=lowercase, 5=title words
   ' +++++++++++++ TURN OFF SHOW CHANGES OTHERWISE INDEX IS INCORRECT
  showHold = ActiveDocument.ShowRevisions
  ActiveDocument.ShowRevisions = False
   
  Set rr = Selection.Range ' range selected by user
  If Selection.Start = Selection.End Then
     Set rr = Selection.Words(1)
     rr.Select
  End If
  Set rrhold = rr.Duplicate
  Set rw = rr.Duplicate
'  If Selection.Information(wdWithInTable) Then
'    Call Change_Case_inTable(n)
'  Else
    Call Change_Case_inTextbody(n)
'  End If
  rrhold.Select
  ActiveDocument.ShowRevisions = showHold
End Sub

Private Sub ParseTableCells()
Dim rTable As Table
Dim rnge As Range
Dim sCount As Long
  Set rTable = ActiveDocument.Tables(1)
  Set rnge = rTable.Rows(1).Cells(2).Range
  sCount = rnge.Sentences.Count
  If sCount > 1 Then rnge.Start = rnge.Sentences(sCount - 1).End
  
  rnge.MoveEnd Unit:=wdCharacter, Count:=-1
  MsgBox "QQ" & rnge.Text
End Sub
Sub ParseTableCell(sr As Range, n As Long) ' at present processes whole cell
Dim rTable As Table
Dim rnge As Range
Dim sCount As Long
Dim sIndex As Long
Dim rowNo As Long
Dim colNo As Long
  rowNo = sr.Information(wdStartOfRangeRowNumber)
'  rowFin = Selection.Information(wdEndOfRangeRowNumber)
'  colStart = Selection.Information(wdStartOfRangeColumnNumber)
  colNo = sr.Information(wdStartOfRangeColumnNumber)
  Set rTable = ActiveDocument.Tables(1)
  Set rnge = rTable.Rows(rowNo).Cells(colNo).Range
  sCount = rnge.Sentences.Count
  For sIndex = 1 To sCount - 1
'MsgBox "WW" & rnge.Sentences(sIndex)
     Call ParseSent(rnge.Sentences(sIndex), n)
  Next sIndex
  If sCount > 1 Then
    rnge.Start = rnge.Sentences(sCount - 1).End
    rnge.MoveEnd Unit:=wdCharacter, Count:=-1
    
 'MsgBox "QQ" & rnge.Text
    Call ParseSent(rnge, n)
  End If
End Sub
Sub ParseSent(sr As Range, n As Long)
  wordCount = 0
  For Each ww In sr.Words
    wordCount = wordCount + 1
    Set rw = sr
    If Trim(LCase(ww)) = "i" Then
      Call Change_Char_toUppercase(1) ' special case of I
    Else
      Select Case n
        Case 1
         ' Change_Title_case ' n=1= title for whole sentence
        Case 2
          Call Change_Sentence_Case(wordCount)
        Case 3
          Change_Uppercase
        Case 4
          Change_Lowercase
      End Select
    End If
  Next ww
End Sub
Sub Change_Case_inTextbody(n As Long)
Dim sentx As Range
Dim rX As Range
Dim sCount As Long
Dim sIndex As Long
Dim Sii As Long
  If n < 3 Then ' extend to end of sentence
    rr.EndOf Unit:=wdSentence, Extend:=wdExtend
    rr.StartOf Unit:=wdSentence, Extend:=wdExtend
  Else  ' extend to end of word
    rr.EndOf Unit:=wdWord, Extend:=wdExtend
    rr.StartOf Unit:=wdWord, Extend:=wdExtend
  End If
  
  If n < 3 Then ' title full sentence & sentence cases
    sCount = rw.Sentences.Count
    sIndex = 1
    Do
      Set sentx = rw.Sentences(sIndex)
      If sentx.Information(wdWithInTable) Then
        Call ParseTableCell(sentx, n)
        sIndex = sIndex + sentx.Sentences.Count
      Else
        Call ParseSent(sentx, n)
        sIndex = sIndex + 1
      End If
    Loop While sIndex <= rw.Sentences.Count
    
  Else
    If n = 3 Or n = 4 Then '  upper or lower cases
      For Each ww In rr.Words
        Set rX = Selection.Range
        Set rw = ww.Duplicate
     rw.Select
        If Trim(LCase(ww)) = "i" Then
          Call Change_Char_toUppercase(1) ' special case of I
        Else
          Select Case n
          Case 3
            Change_Uppercase
          Case 4
            Change_Lowercase
          End Select
        End If
      Next ww
    Else ' n=5 title words
      Set rX = rr.Duplicate
      wordCount = 0
      For Each ww In rX.Words
        wordCount = wordCount + 1
        Set rw = ww.Duplicate
        If Trim(LCase(ww)) = "i" Then
          Call Change_Char_toUppercase(1) ' special case of i
        Else
          Change_Title_Case
        End If
      Next ww
    End If
  End If
End Sub
Sub Change_Case_inTextbodyOLD(n As Long)
Dim sentx
Dim rX As Range
Dim sCount As Long
Dim Sii As Long
Dim tableFlag As Boolean

'rr.Select
  '####################################################
  If n < 3 Then ' extend to end of sentence
    rr.EndOf Unit:=wdSentence, Extend:=wdExtend
    rr.StartOf Unit:=wdSentence, Extend:=wdExtend
  Else  ' extend to end of word
    rr.EndOf Unit:=wdWord, Extend:=wdExtend
    rr.StartOf Unit:=wdWord, Extend:=wdExtend
  End If
  tableFlag = False
  If Right(rr, 1) = Chr(7) Then ' last sentenance in table
    tableFlag = True
    ' rr.MoveEnd unit:=wdCharacter, Count:=-2
  End If
   
  rr.Select
  sCount = rr.Sentences.Count
  For Sii = 1 To sCount
    If Sii = sCount And tableFlag Then
MsgBox "last in table"
    End If
    Set rw = rr.Sentences(Sii)
    For Each ww In rw.Words
      sCount = sCount
    Next ww
  Next Sii
  
  Set rw = rr.Duplicate
  If n < 3 Then ' title full sentence & sentence cases
   ' if
 
    For Each sentx In rw.Sentences
      If sentx.Text = Chr(13) & Chr(7) Then ' last sentence in table cell
        MsgBox "Last in cell " & sentx.Text & "  " & rr.Text
      End If
      Set rX = sentx.Duplicate
      wordCount = 0
      For Each ww In sentx.Words
        wordCount = wordCount + 1
        Set rw = ww.Duplicate
        If Trim(LCase(ww)) = "i" Then
          Call Change_Char_toUppercase(1) ' special case of I
        Else
          If n = 1 Then
           ' Change_Title_case ' n=1= title for whole sentence
          Else
            Call Change_Sentence_Case(wordCount)
          End If
        End If
      Next ww
     Next sentx
   Else
    If n = 3 Or n = 4 Then '  upper or lower cases
      For Each ww In rr.Words
        Set rX = Selection.Range
        Set rw = ww.Duplicate
     rw.Select
        If Trim(LCase(ww)) = "i" Then
          Call Change_Char_toUppercase(1) ' special case of I
        Else
          Select Case n
          Case 3
            Change_Uppercase
          Case 4
            Change_Lowercase
          End Select
        End If
      Next ww
    Else ' n=5 title words
      Set rX = rr.Duplicate
      wordCount = 0
      For Each ww In rX.Words
        wordCount = wordCount + 1
        Set rw = ww.Duplicate
        If Trim(LCase(ww)) = "i" Then
          Call Change_Char_toUppercase(1) ' special case of i
        Else
          Change_Title_Case
        End If
      Next ww
    End If
  End If
End Sub

Sub Change_Case_inTable(n As Long)
Dim rowstart As Integer
Dim rowFin As Integer
Dim colStart As Integer
Dim colFin As Integer
Dim rTable As Table
Dim iRow As Integer
Dim iCol As Integer

  If Selection.Information(wdAtEndOfRowMarker) Then
    MsgBox "Cannot process end of row marker"
    Exit Sub
  End If
  rr.Select
  With Selection
    rowstart = .Information(wdStartOfRangeRowNumber)
    rowFin = .Information(wdEndOfRangeRowNumber)
    colStart = .Information(wdStartOfRangeColumnNumber)
    colFin = .Information(wdEndOfRangeColumnNumber)
    If rowFin > .Information(wdMaximumNumberOfRows) Or _
      colFin > .Information(wdMaximumNumberOfColumns) Then Exit Sub
  
  Set rTable = .Tables(1)
  End With

  For iRow = rowstart To rowFin
'rTable.Select
    For iCol = colStart To colFin
      If rowstart = rowFin And colStart = colFin Then ' single cell
         Call Change_Case_inTextbody(n)
      Else ' multiple cells
        rTable.Rows(iRow).Cells(iCol).Select
        Set rr = Selection.Range
        Call Change_Case_inTextbody(n)
      End If
        
    Next iCol
  Next iRow
End Sub
Private Sub Change_Title_Case()
Dim shortSw As Boolean
Dim j As Long
  shortSw = TestShort(ww, wordCount)
  If shortSw Then
    Change_Lowercase
    Exit Sub
  End If
  j = 0
  For Each ch In ww.Characters
    j = j + 1
    If j = 1 Then
      Change_Char_toUppercase (j)
    Else
      Change_Char_toLowercase (j)
    End If
  Next ch
End Sub
Private Sub Change_Sentence_Case(iw As Long) ' in word ww
Dim j As Long
  j = 0
ww.Select
  For Each ch In ww.Characters
    j = j + 1
    If j = 1 And iw = 1 Then 'first character of first word in each sentence
      Change_Char_toUppercase (j)
    Else
      Change_Char_toLowercase (j)
    End If
  Next ch
End Sub
Private Sub Change_Uppercase()
Dim j As Long
  j = 0
  For Each ch In ww.Characters
    j = j + 1
    Call Change_Char_toUppercase(j)
  Next ch
End Sub
Private Sub Change_Lowercase()
Dim j As Long
  j = 0
  For Each ch In ww.Characters
    j = j + 1
    Change_Char_toLowercase (j)
  Next ch
End Sub

Sub Change_Char_toLowercase(n As Long) ' change nth character in ww
 Dim cs As String
 Dim cr As Range
   cs = Mid(ww, n, 1)
   If cs >= "A" And cs <= "Z" Then ' character is upper case
    ' Set cr = rw.Duplicate
     Set cr = ww.Duplicate
     cr.End = cr.Start ' ?????????????????ww.duplicate ?????
     cr.Select
     Selection.MoveRight Unit:=wdCharacter, Count:=n - 1
     Selection.TypeText LCase(cs)
     Selection.Delete Unit:=wdCharacter, Count:=1
   End If
End Sub

Sub Change_Char_toUppercase(n As Long)  ' change nth character in ww
 Dim cs As String
 Dim cr As Range
   cs = Mid(ww, n, 1)
   If cs >= "a" And cs <= "z" Then ' character is lower case
     Set cr = rw.Duplicate
     cr.End = cr.Start
     cr.Select
     Selection.MoveRight Unit:=wdCharacter, Count:=n - 1
     Selection.TypeText UCase(cs)
     Selection.Delete Unit:=wdCharacter, Count:=1
   End If
End Sub

Function TestShort(w, i) As Boolean
Dim j As Integer
  TestShort = False
  If i = 1 Then Exit Function ' first word always capitalised
  On Error Resume Next
  If UBound(sTitle) < 0 Then
    Get_ShortTitles
  End If
  On Error GoTo 0
  For j = 0 To UBound(sTitle)
    If sTitle(j) = LCase(Trim(w)) Then
      TestShort = True
      Exit Function
    End If
  Next j
End Function
Private Sub Get_ShortTitles()
  sTitle = Array("this", "at", "that", "and", "with", "by", "to", "the", "for", _
       "as", "of", "from", "or", "in", "a", "an", "on", "")
End Sub
Sub change_CaseTitle() ' hot keys jump to here
  change_Case (5)
End Sub
Sub change_CaseSentence()
  change_Case (2)
End Sub
Sub change_CaseUpper()
  change_Case (3)
End Sub
Sub change_CaseLower()
  change_Case (4)
End Sub
'Sub change_Case5TitleWords()
'  change_Case (5)
'End Sub


Sub CentreOnScreen(centre As Boolean)
  If centre Then ActiveWindow.ActivePane.LargeScroll
  Application.ActiveWindow.ScrollIntoView Selection.Range
End Sub


Function RightJustify(ByVal n As Integer, k As Integer) As String
Dim st As String
  st = Format(n, "#########0")
  Do While Len(st) < k
    st = " " & st
  Loop
  RightJustify = st
End Function


Sub Accept_Changes(n As Long)
Dim rStart As Range
Dim aCount As Long
Dim bCount As Long
Dim cRange As Range
Dim st As String

  If Selection.Start = Selection.End Then ' All document
    bCount = ActiveDocument.Range.Revisions.Count
    If MsgBox("Accept all " & bCount & _
      " changes in document" & vbCrLf & _
         "(to accept only some changes exit and try again with selected text)", _
         vbYesNo) = vbYes Then
       Set cRange = ActiveDocument.Range
       cRange.Revisions.AcceptAll
 '      WordBasic.AcceptChangesSelected
 '      WordBasic.AcceptAllChangesInDoc
      CountRevisions
    End If
    Exit Sub
  End If
  
 ' If Not ActiveDocument.ShowRevisions Then
 '   ActiveDocument.ShowRevisions = True
  If Not ActiveWindow.View.ShowRevisionsAndComments Then
    ActiveWindow.View.ShowRevisionsAndComments = True
    TrackChangeForm.HighlightOnScreen.Value = True
  End If
  Set cRange = Selection.Range
  'cRange.EndOf Unit:=wdWord, Extend:=wdExtend
  'cRange.StartOf Unit:=wdWord, Extend:=wdExtend
  cRange.Select
  bCount = cRange.Revisions.Count
  st = ""
  If MsgBox("Accept all " & bCount & " changes to the marked text" & vbCr & vbCr & st & _
     "(to accept only some changes use the Accept or Reject button)", vbYesNo) = vbNo Then Exit Sub
  Set rStart = Selection.Range
  rStart.End = rStart.Start
  rStart.Select
'  aCount = 0
  If bCount > 20 Then
    Application.ScreenUpdating = False
  End If
  
'  While cRange.Revisions.Count > 0 ' bloody VBA ***
'    cRange.Revisions(1).Accept
'    aCount = aCount + 1
'  Wend

  cRange.Revisions.AcceptAll
  Application.ScreenUpdating = True
  
  cRange.Select
  CountRevisions
End Sub

Sub Toggle_Pane(n As Integer)
Dim sWidth As Single
  sWidth = ActiveWindow.StyleAreaWidth
  ActiveWindow.View.SplitSpecial = wdPaneRevisions ' loses StyleArea
  ActiveWindow.StyleAreaWidth = sWidth
End Sub

Sub convertformload(n As Long)
  With ConvertForm
     .StartUpPosition = 0
    .Top = 100
    .Left = hPoints - .Width - 120
    .Show
  End With
End Sub

Sub NumeralsToWords(n As Long)
Dim fText As String
Dim sDigits As String
Dim s As String
Dim sBigStuff As String
Dim rDollar As Boolean
Dim rNextChar As Range
Dim docStart As Range
Dim aRange As Range
Dim overallRange As Range
Dim i As Long

  Set docStart = ActiveDocument.Range(Start:=0, End:=1)
    
  Do
    Selection.MoveStart Unit:=wdCharacter, Count:=-1
    s = Left(Selection.Text, 1)
  Loop Until (s < "0" Or s > "9") And s <> "," And s <> "$" Or docStart.InRange(Selection.Range)
  If Not docStart.InRange(Selection.Range) Then Selection.MoveStart Unit:=wdCharacter, Count:=1
  
  Do
    Selection.MoveEnd Unit:=wdCharacter, Count:=1
    s = Right(Selection.Text, 1)
  Loop Until (s < "0" Or s > "9") And s <> ","
  Selection.MoveEnd Unit:=wdCharacter, Count:=-1
  
  Set overallRange = Selection.Range
  
  If Left(Selection.Text, 1) = "$" Then
     rDollar = True
     sDigits = Mid(Selection.Text, 2)
   Else
     rDollar = False
     sDigits = Selection.Text
   End If
   
   Do Until InStr(sDigits, ",") = 0
     i = InStr(sDigits, ",")
     sDigits = Left(sDigits, i - 1) & Mid(sDigits, i + 1)
   Loop
     
    If Not IsNumeric(sDigits) Then GoTo Nerr
        
    If Len(sDigits) > 9 Then GoTo Nerr
      
    If (ConvertForm.RomanLowerOption Or ConvertForm.RomanUpperOption) And _
       Len(sDigits) > 4 Then
       MsgBox "Cannot give Roman numerals for numbers > 9999"
       Exit Sub
    End If
    
    fText = " \* "
    Selection.Text = sDigits
    With ConvertForm
      If .TextOption Then fText = fText & "CardText "
      If .OrdinalOption Then fText = fText & "Ordinal "
      If .OrdinalTextOption Then fText = fText & "OrdText "
      If .RomanLowerOption Then fText = fText & "roman "
      If .RomanUpperOption Then fText = fText & "ROMAN "
    End With
    
    sBigStuff = ""
    i = Len(sDigits)
    If i > 6 Then
      Set aRange = Selection.Range
      aRange.Start = aRange.Start + i - 5
      aRange.End = aRange.Start
      Selection.End = Selection.Start + i - 6
      sBigStuff = Selection.Text

      Selection.Fields.Add Range:=Selection.Range, _
           Type:=wdFieldEmpty, Text:="= " & sBigStuff & fText, _
           PreserveFormatting:=True

            ' Select the field and copy it
            ActiveWindow.View.ShowFieldCodes = False ' IMPORTANT ********
            
            Selection.MoveLeft Unit:=wdWord, Count:=1, Extend:=wdExtend
            sBigStuff = Selection.Text & " million "
            Selection.Text = sBigStuff
  '          sDigits = Right(sDigits, 6)
  '      End If
      aRange.End = aRange.Start + i - 4
      aRange.Start = aRange.Start - 1
      aRange.Select
      sDigits = aRange.Text
      
      Selection.End = Selection.End + 2
      Set aRange = Selection.Range
      sDigits = aRange.Text
    End If
 
        Selection.Fields.Add Range:=Selection.Range, _
          Type:=wdFieldEmpty, Text:="= " & sDigits & fText, PreserveFormatting:=True
       
       ActiveWindow.View.ShowFieldCodes = False ' IMPORTANT ********
        
        ' Select the field and copy it
        Selection.MoveLeft Unit:=wdWord, Count:=1, Extend:=wdExtend
        sDigits = Selection.Text 'sBigStuff & Selection.Text
        If rDollar And ConvertForm.TextOption Then
          sDigits = sDigits & " dollars"
        End If
        Set aRange = Selection.Range
        aRange.End = aRange.End + 1 ' otherwise aRange changes with selection
        
        ' Now put the words in the document overwriting field
        Selection.Text = sDigits

        overallRange.End = aRange.End - 1
        overallRange.Select
        
        aRange.Start = overallRange.Start
        aRange.End = aRange.Start + 1
        aRange.Select
        
        Set rNextChar = Selection.Paragraphs(1).Range
        rNextChar.End = rNextChar.Start + 1
        If aRange.Start = rNextChar.Start And ConvertForm.RomanLowerOption.Value = False Then
          aRange.Text = UCase(aRange.Text)
        End If

     overallRange.Select
  Exit Sub
Nerr:
  MsgBox "Is not a whole number or is too large"
End Sub

Sub RomanToArabic(NM As Long)
'Dim NM As Long
Dim st As String
   If Selection.Start < Selection.End Then
     st = Selection.Text
     If Left(st, 1) = " " Then Selection.Start = Selection.Start + 1
     If Right(st, 1) = Chr(13) Then Selection.End = Selection.End - 1
   End If
   If Selection.Words.Count = 1 Then
    Selection.Words(1).Select
     st = Selection.Text
     If Right(st, 1) = " " Then Selection.End = Selection.End - 1 'MoveLeft unit:=wdWord, Count:=1, Extend:=wdMove
   
     NM = (Arabic(Selection.Text))
   ' NM = Roman2Num(Selection.Text)
     If NM > -999999999 Then Selection.TypeText Text:=Trim(Str(NM))
   End If
End Sub

Function Arabic(ByVal Roman As String) As Long
Dim ArabicValues() As Integer
Dim convertedValue As Long
Dim currentChar As String * 1
Dim i As Integer
Dim message As String
Dim numChars As Integer
Dim N1 As Long
Dim N2 As Long
Dim V
  V = Array(1000, 500, 100, 50, 10, 5, 1, 0)
  Roman = UCase(LTrim(RTrim(Roman)))
  numChars = Len(Roman)
  If numChars = 0 Then    'if arg is null, we're outta here
    Arabic = -999999999#
     Exit Function
  End If
  ReDim ArabicValues(numChars)
  For i = 1 To numChars
    currentChar = Mid(Roman, i, 1)
    Select Case currentChar
        Case "M": ArabicValues(i) = 0 'V(0) '1000
        Case "D": ArabicValues(i) = 1 'V(1) '500
        Case "C": ArabicValues(i) = 2 'V(2) '100
        Case "L": ArabicValues(i) = 3 'V(3) '50
        Case "X": ArabicValues(i) = 4 'V(4) '10
        Case "V": ArabicValues(i) = 5 'V(5) ' 5
        Case "I": ArabicValues(i) = 6 'V(6) ' 1
        Case Else
       '"Sorry, " & Roman & " is not a valid Roman numeral!  "
        GoTo Nerr
    End Select
  Next i
' Check for invalid number.
' numbers must be equal or descend except can have one number, one less than the following on
  For i = 1 To numChars - 1
    N1 = ArabicValues(i)
    N2 = ArabicValues(i + 1)
    If N1 > N2 Then '  can only have one modifier
      
     ' also preceding digit must not be higher and than following digit
      If ArabicValues(i - 1) >= N2 Then GoTo Nerr
      
      ' can only be one level less
  '    If N1 <> N2 + 1 Then GoTo Nerr
      ' can only have one decrenenting modifier
    '  If i > 1 And N1 <> 0 Then
    '    If N1 = (ArabicValues(i - 1)) Then GoTo Nerr
    '  End If
    End If
  Next i
  If InStr(Roman, "IIII") > 0 Or InStr(Roman, "XXXX") > 0 Or InStr(Roman, "CCCC") > 0 Then GoTo Nerr
  If InStr(Roman, "VV") > 0 Or InStr(Roman, "LL") > 0 Or InStr(Roman, "DD") > 0 Then GoTo Nerr
  For i = 1 To numChars
    ArabicValues(i) = V(ArabicValues(i))
  Next i
  For i = 1 To numChars - 1
    If ArabicValues(i) < ArabicValues(i + 1) Then
        ArabicValues(i) = ArabicValues(i) * -1
    End If
  Next i
  For i = 1 To numChars
    Arabic = Arabic + ArabicValues(i)
  Next i
  Exit Function
Nerr:
  MsgBox "Invalid Roman number"
  Arabic = -999999999#
End Function

Sub TextToNumbers(isThousandsComma As Boolean)
Dim NT() As Variant
Dim NB As Variant
Dim n As Long
Dim ns As String
Dim R As Range
Dim k As Long
Dim L As Long
Dim LL As Long
Dim LLL As Long
Dim s As String
Dim ss As String
Dim sss As String
Dim j As Long
Dim m As Long
Dim mm As Long
Dim mmm As Long
Dim gA() As Long
Dim gB() As Long

Dim wCount As Long
  NT = Array("AND", "-", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "TEN", _
    "ELEVEN", "TWELVE", "THIRTEEN", "FOURTEEN", "FIFTEEN", "SIXTEEN", "SEVENTEEN", "EIGHTEEN", "NINETEEN", _
    "TWENTY", "THIRTY", "FORTY", "FIFTY", "SIXTY", "SEVENTY", "EIGHTY", "NINETY", _
    "HUNDRED", "THOUSAND", "MILLION", "$%$%")
  NB = Array(0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, _
          11, 12, 13, 14, 15, 16, 17, 18, 19, _
          20, 30, 40, 50, 60, 70, 80, 90, _
          100, 1000, 1000000, 0)
   
   Set R = Selection.Range
   s = R.Text
   If Right(s, 1) = Chr(13) Then R.MoveEnd Unit:=wdCharacter, Count:=-1
   s = R.Text
   If Right(s, 1) = "." Then R.MoveEnd Unit:=wdCharacter, Count:=-1
  
   If R.Paragraphs.Count > 1 Then
     MsgBox "Selection cannot span paragraphs"
     Exit Sub
   End If
   If Trim(R.Text) = "" Then
     MsgBox "Selection does not include a word"
     Exit Sub
   End If
   
   wCount = R.Words.Count
   ReDim gA(wCount + 1)
   ReDim gB(wCount + 1)
     
   n = 0
   ns = ""
      
   For k = 1 To R.Words.Count
     s = UCase(Trim(R.Words(k)))
     If s = Chr(13) Or s = "" Then
       gB(k) = 1
       gA(k) = 0
       GoTo FF2
     End If
     For m = 0 To UBound(NT) - 1
       If s = NT(m) Then GoTo FF
     Next m
     MsgBox "The word " & """" & R.Words(k) & """" & " is non numeric"
     Exit Sub
FF:
     gA(k) = NB(m)
     If m > UBound(NT) - 5 Then
       gB(k) = 2
     Else
       gB(k) = 1
     End If
FF2:
   Next k
   ' Arrays gA & gB hold word values and operator on that word
   
   wCount = removeZeros(gA(), gB(), wCount)
  ' go forward, combine multiple numbers and remove zero entries
   
   For k = 1 To wCount - 1
     If gB(k) = 1 And gB(k + 1) = 1 Then
       gA(k + 1) = gA(k + 1) + gA(k)
       gA(k) = 0
     End If
   Next k
   wCount = removeZeros(gA(), gB(), wCount)
    
   m = 1
   Do
     m = m + 1
   Loop Until m > wCount Or gA(m) = 1000000
   If m <= wCount Then ' 1000000 is at ga(m)
      ' check that there are no 1000s
       j = 1
     Do
       j = j + 1
     Loop Until j >= m Or gA(j) = 1000
     If j < m Then
       MsgBox "Cannot process thousands of millions"
       Exit Sub
     End If
     
     j = 1
     Do
       j = j + 1
     Loop Until j >= m Or gA(j) = 100
     If j < m Then
       gA(j) = gA(j) * gA(j - 1)
       gA(j - 1) = 0
       gB(j) = 1
     End If
     LL = 0
     For j = 1 To m - 1
       L = L + gA(j)
       gA(j) = 0
       gB(j) = 0
     Next j
     gA(m) = L * gA(m)
     gB(m) = 1
   Else
     m = 0
   End If ' 1000000 processed
   
    mm = j + 1
   If mm <= wCount Then
   Do
     mm = mm + 1
   Loop Until mm > wCount Or gA(mm) = 1000
   End If
   If mm <= wCount Then ' 1000 is at ga(mm)
     j = m + 1
     Do
       j = j + 1
     Loop Until j >= mm Or gA(j) = 100
     If j < mm Then ' have 100 preceeding 1000
       gA(j) = gA(j) * gA(j - 1)
       gA(j - 1) = 0
       gB(j) = 1
     End If
     LL = 0
     For j = m + 1 To mm - 1
       LL = LL + gA(j)
       gA(j) = 0
       gB(j) = 1
     Next j
     gA(mm) = LL * gA(mm)
     gB(mm) = 1
   Else
     mm = m
   End If ' 1000 is at mmth entry
   
   mmm = mm + 1
   If mmm <= wCount Then
   Do
     mmm = mmm + 1
   Loop Until mmm > wCount Or gA(mmm) = 100
   End If
   If mmm <= wCount Then ' 100 is at ga(mmm)
     gA(mmm) = gA(mmm - 1) * gA(mmm)
     gA(mmm - 1) = 0
     gB(mmm) = 1
   Else
     mm = m
   End If ' 100 is at mmmth entry
  
   LLL = 0
   For k = 1 To wCount
     LLL = LLL + gA(k)
   Next k
    
'   Call shw(gA(), gB(), wCount)
  If isThousandsComma Then
    s = Format(LLL, "Standard")
    s = Left(s, Len(s) - 3)
  Else
    s = Str(LLL)
  End If
'  MsgBox "Final figure=" & s

  R.Text = Trim(s)
  R.Select
End Sub

Function removeZeros(gA() As Long, gB() As Long, ByVal wCount As Long) As Long
 Dim q As Long
 Dim z As Long
     For q = wCount To 1 Step -1
       If gA(q) = 0 Then
         z = q
         Do While z < wCount
           gA(z) = gA(z + 1)
           gB(z) = gB(z + 1)
           z = z + 1
         Loop
         wCount = wCount - 1
       End If
     Next q
   removeZeros = wCount
End Function

Sub RJF(n As Long)
  arj = n
  AcceptRejectForm.hide
End Sub
Sub ReviewAndChange(n As Long)
Dim k As Long
Dim Rv As Revision
Dim RvDesc '() As String
Dim RvType As Long
Dim aRange As Range
  RvDesc = Array("No revision", "Insertion", "Deletion", "Property change", "Paragraph number change", "Field display changed", _
                 "Reconciled conflict", "Revision is a conflict", "Style changed", "Replaced", "Paragraph property changed", _
                 "Table property changed", "Section property changed", "Style definition changed", "Content moved from", _
                 "Content moved to", "Table cell inserted", "Table cell deleted", "Table cells merged")

  TrackChangeForm.HighlightOnScreen.Value = True
  If Selection.Range.Revisions.Count < 1 Then
    MsgBox "There are no revisions in selection"
  End If
  With TrackChangeForm
      .HighlightOnScreen.Value = False
      .CommentsCheckbox.Value = True
      .FormattingCheckbox.Value = True
      .InsertCheckbox.Value = True
      .HighlightOnScreen.Value = True
  End With
  
    If ActiveWindow.View.SplitSpecial = wdPaneNone Then
        ActiveWindow.ActivePane.View.Type = wdPrintView
  Else
        ActiveWindow.View.Type = wdPrintView
  End If
  
  ActiveWindow.View.MarkupMode = wdMixedRevisions
  ActiveWindow.View.ShowRevisionsAndComments = True
  TrackChangeForm.HighlightOnScreen.Value = True
  Set aRange = Selection.Range.Duplicate
  For Each Rv In aRange.Revisions
    Rv.Range.Select
    RvType = Rv.Type
    If RvType < 0 Or RvType > 18 Then RvType = 0
    arj = 0
    With AcceptRejectForm
      .InfoLabel.Caption = "Accept displays the change and removes from revisions" & vbCrLf & _
          "Reject will revert to what was there before the change"
      .RvTypeLabel = "Revision type: " & RvDesc(RvType) & vbCrLf & Rv.Range.Text
      .Show
    End With
    
    If arj = 0 Then
      Selection.Range.Select
      Exit Sub
    End If
    If arj = 1 Then
      Rv.Accept
    End If
    If arj = 2 Then
      Rv.Reject
    End If
    CountRevisions
    DoEvents
   
  Next Rv
  aRange.Select
  CountRevisions
End Sub
 Sub setShowRevisions(n As Long)
  With ActiveWindow.View
  '  If TrackChangeForm.CommentsCheckbox Then .ShowComments = True
  '  If TrackChangeForm.FormattingCheckbox Then .ShowFormatChanges = True
  '  If TrackChangeForm.InsertCheckbox Then .ShowInsertionsAndDeletions = True
    .ShowComments = TrackChangeForm.CommentsCheckbox.Value
    .ShowFormatChanges = TrackChangeForm.FormattingCheckbox
    .ShowInsertionsAndDeletions = TrackChangeForm.InsertCheckbox
    .ShowRevisionsAndComments = TrackChangeForm.HighlightOnScreen
    .MarkupMode = wdMixedRevisions
    .RevisionsView = 0
  End With
'   ActiveDocument.ShowRevisions = TrackChangeForm.HighlightOnScreen
   show_Settings (1)
   CentreOnScreen (True)
   Selection.Range.Select
End Sub

Private Sub CountRevisions()
Dim aStory As Range
Dim j As Long
  j = 0
  For Each aStory In ActiveDocument.StoryRanges
    j = j + aStory.Revisions.Count
  Next aStory
  TrackChangeForm.TCLabel.Caption = Trim(Str(j)) & " Track Changes"
 ' TrackChangeForm.TCLabel.Caption = "" '.Font.Size = 8
End Sub

Sub SpecialFindAndReplace(n As Long)
  With SpecialFindForm
    .SearchTextbox.Value = Selection.Range.Text
    .Show
  End With
End Sub

Sub Go_SpecialFind(n As Long)
Dim aRange As Range
Dim bRange As Range
Dim iCount As Long
Dim resetRange As Range
Dim txt As String
Dim k As Long
  txt = SpecialFindForm.SearchTextbox.Value
  If Trim(txt) = "" Then
    MsgBox "No search string"
    Exit Sub
  End If
  Call Get_ShortTitles
  Set resetRange = Selection.Range
  Set aRange = Selection.Range
  aRange.End = ActiveDocument.Range.Start
  iCount = 0
  With aRange.Find
    .ClearFormatting
    .Wrap = wdFindStop
    .Forward = True
    .Format = True
    .MatchCase = SpecialFindForm.CaseSensitiveCheckbox
    .MatchWildcards = False
    .Text = txt
    .Execute
    While .Found And aRange.Text <> ""
'aRange.Select
      iCount = iCount + 1
      Set bRange = aRange.Duplicate
      bRange.Start = bRange.End
'bRange.Select
      k = vbYes
      If SpecialFindForm.PromptTextbox Then
        aRange.Select
        k = MsgBox("Change case on this selection", vbYesNoCancel, "")
        If k = vbCancel Then Exit Sub
      End If
      If k = vbYes Then
        Set ww = aRange
        Set rw = ww.Duplicate
        With SpecialFindForm
          If .UcaseOption Then
            Change_Uppercase
          End If
          If .LcaseOption Then
            Change_Lowercase
            If aRange.Start = aRange.Sentences(1).Start _
              And SpecialFindForm.AlsoSentencecheckbox Then
              Change_Char_toUppercase (1)
            End If
          End If
      
          If .TitleCaseOption Then
            change_Case (5)
          End If
     
        End With
      End If
   
      aRange.Start = bRange.Start
      aRange.End = ActiveDocument.Range.End
      .Execute
    Wend
  End With
  resetRange.Select
  MsgBox iCount & " instances found"
End Sub

Sub notification(s As String)
  With NotificationForm
    .NoteLabel.Caption = s
    .Show
  End With
End Sub
Attribute VB_Name = "HotKeysForm"
Attribute VB_Base = "0{6DCDED31-94A7-4D12-93B2-CB637A4B84FA}{80270CBF-5A07-42D0-A021-5E1ADFE3C406}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub HotkeyCancel_Click()
  HotKeysForm.hide
End Sub

Private Sub URLlabel_Click()
 ActiveDocument.FollowHyperlink HotKeysForm.URLlabel.Caption
End Sub
Attribute VB_Name = "NotificationForm"
Attribute VB_Base = "0{B91CBFA7-C88B-485D-BC7B-71E0B19ED729}{2A3FA6EF-1837-45D8-B1F2-02B5FCD1268E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub OKButton_Click()
  NotificationForm.hide
End Sub
Attribute VB_Name = "SpecialFindForm"
Attribute VB_Base = "0{E6CDFEAC-7660-47F9-BBD6-B3D15AC062DF}{4E72AF53-4D17-48DB-A25F-AB5AEEB3A9BB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub CancelButton_Click()
  SpecialFindForm.hide
End Sub

Private Sub GoButton_Click()
  Go_SpecialFind (1)
End Sub

Private Sub LcaseOption_Click()
  SpecialFindForm.AlsoSentencecheckbox.Enabled = True
End Sub

Private Sub TitleCaseOption_Click()
  SpecialFindForm.AlsoSentencecheckbox.Enabled = False
End Sub

Private Sub UcaseOption_Click()
  SpecialFindForm.AlsoSentencecheckbox.Enabled = False
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "TrackChangeForm"
Attribute VB_Base = "0{79E548FB-7B2D-4642-9AFB-CECF360177E7}{D2A50697-7203-491E-B849-49D8A7F07199}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub AcceptChanges_Click()
  Accept_Changes (1)
End Sub

Private Sub CancelButton_Click()
  TrackChangeForm.hide
End Sub

Private Sub CommandButton1_Click()
  Toggle_Pane (1)
End Sub

Private Sub ConvertButton_Click()
  convertformload (1)
End Sub


Private Sub CopySectionsButton_Click()
  CopySectionLoad (1)
End Sub

Private Sub DeleteSectButton_Click()
  RemoveSection (1)
End Sub

Private Sub HighlightOnScreen_Click()
  'If Not inhibitClick Then setShowRevisions (1)
  ActiveWindow.View.ShowRevisionsAndComments = TrackChangeForm.HighlightOnScreen
End Sub

Private Sub InsertCheckbox_Click()
  ActiveWindow.View.ShowInsertionsAndDeletions = TrackChangeForm.InsertCheckbox.Value
  If TrackChangeForm.InsertCheckbox Then
    inhibitClick = False
    TrackChangeForm.HighlightOnScreen = True
    inhibitClick = False
  End If
End Sub

Private Sub CommentsCheckbox_Click()
   ActiveWindow.View.ShowComments = TrackChangeForm.CommentsCheckbox.Value
   If TrackChangeForm.CommentsCheckbox Then
    inhibitClick = True
    TrackChangeForm.HighlightOnScreen = True
    inhibitClick = False
  End If
End Sub

Private Sub FormattingCheckbox_Click()
   ActiveWindow.View.ShowFormatChanges = TrackChangeForm.FormattingCheckbox.Value
   If TrackChangeForm.FormattingCheckbox Then
    inhibitClick = True
    TrackChangeForm.HighlightOnScreen = True
    inhibitClick = False
  End If
End Sub

Private Sub Help2Button_Click()
  HelpSub (0)
End Sub

Private Sub HoverCheckbox_Click()
 ToggleHoverSetting (1)
End Sub

Private Sub HelpButton_Click()
  HelpSub (1)
End Sub

Private Sub MoreButton_Click()
  toggleHeight (1)
End Sub

Private Sub MultipleChangeButton_Click()
  SpecialFindAndReplace (1)
End Sub

Private Sub OptionsButton_Click()
  Call Dialogs(wdDialogToolsOptionsTrackChanges).Show
End Sub

Private Sub ReviewButton_Click()
  ReviewAndChange (1)
End Sub

Private Sub ShortcutsButton_Click()
  ActiveDocument.FollowHyperlink Address:="http://www.shortcutworld.com/en/win/Word_2010.html#link_6"
End Sub

Private Sub TCWhileEditing_Click()
  ActiveDocument.TrackRevisions = TrackChangeForm.TCWhileEditing.Value
  show_Settings (1)
  
End Sub

Private Sub SentenceCaseButton_Click()
  change_Case (2)
End Sub

Private Sub UpperCaseButton_Click()
  change_Case (3)
End Sub

Private Sub LowerCaseButton_Click()
  change_Case (4)
End Sub

Private Sub TitleWordButton_Click()
  change_Case (5)
End Sub

Attribute VB_Name = "UtilityPrograms"
Option Explicit
' can also use #If VBA7 to see if working in VBA 7 environment

#If Win64 Then
  Private Declare PtrSafe Function GetDC Lib "User32" (ByVal hWnd As Long) As Long
  Private Declare PtrSafe Function ReleaseDC Lib "User32" ( _
    ByVal hWnd As Long, _
    ByVal hDC As Long) As Long
  Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" ( _
    ByVal hDC As Long, _
    ByVal nIndex As Long) As Long
  Private Declare PtrSafe Function GetSystemMetrics Lib "User32" ( _
    ByVal nIndex As Long) As Long
 ' MsgBox "64 bit version"
#Else
  Private Declare Function GetDC Lib "User32" (ByVal hWnd As Long) As Long
  Private Declare Function ReleaseDC Lib "User32" ( _
    ByVal hWnd As Long, _
    ByVal hDC As Long) As Long
  Private Declare Function GetDeviceCaps Lib "gdi32" ( _
    ByVal hDC As Long, _
    ByVal nIndex As Long) As Long
  Private Declare Function GetSystemMetrics Lib "User32" ( _
    ByVal nIndex As Long) As Long
'MsgBox "32 bit version"
#End If

Const LOGPIXELSX = 88
Const LOGPIXELSY = 90
Const TWIPSPERINCH = 1440
Private Const SM_CXFULLSCREEN = 16 ' also 0 gives overall screenwidth
Private Const SM_CYFULLSCREEN = 17 ' 1 gives overall, 17 gives useable excluding taskbars

Private Sub ConvertPixelsToPoints(ByRef x As Single, ByRef y As Single)
Dim hDC As Long
Dim RetVal As Long
Dim XPixelsPerInch As Long
Dim YPixelsPerInch As Long
    hDC = GetDC(0)
    XPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX)
    YPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSY)
    RetVal = ReleaseDC(0, hDC)
    x = x * TWIPSPERINCH / 20 / XPixelsPerInch
    y = y * TWIPSPERINCH / 20 / YPixelsPerInch
End Sub
Sub GiveScreenPoints(ByRef scx As Single, ByRef scy As Single)
Dim wt As Single
Dim ht As Single
 wt = GetSystemMetrics(SM_CXFULLSCREEN)
 ht = GetSystemMetrics(SM_CYFULLSCREEN)
 ConvertPixelsToPoints wt, ht
 scx = wt
 scy = ht
End Sub
 
 



' InQuest injected base64 decoded content
' jFYe
' jZ N

INQUEST-PP=macro
