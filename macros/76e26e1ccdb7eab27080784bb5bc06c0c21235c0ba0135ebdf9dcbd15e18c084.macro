Attribute VB_Name = "AddCommentModule"
Option Explicit

Public Sub AddComment()
'------------------------------
'
' Add a Comment to the current cell
'
'------------------------------
        
        Dim existingComment As String
        Dim commentData As String
        Dim newComment As String
        Dim currentCell As Range
        Dim currentCommentText As String
        Dim row As Long
        Dim col As Long
        Dim nextNo As Integer

        Debug.Print "AddComment() called"
        
        row = ActiveCell.row
        col = 4
        
        If ((row < 8) Or (row > Sheet1.lastRow)) Then
            MsgBox getLocale("TRANSLATOR_COMMENTS_CAN_ONLY_BE_ADDED_TO_TARGET_LANGUAGE_SEGMENTS"), vbOKOnly, getLocale("INVALID_COMMENT_CELL")
            Exit Sub
        End If
        
        If (Cells(row, 2) = Empty) Then
            Dim i As Integer
            
            For i = row - 1 To 8 Step -1
                If (Cells(i, 2) <> Empty) Then
                    row = i
                    Exit For
                End If
            Next
            'Set currentCell = Range("D" & row)
        End If
        
        If (ThisWorkbook.Sheets("data").Cells(row, 4) = "IS_MERGED") Then
            MsgBox getLocale("CANNOT_ADD_COMMENTS_TO_A_MERGED_SEGMENT")
            
            Exit Sub
        End If
        
        Set currentCell = Cells(row, col)
        
        If currentCell.Comment Is Nothing Then
            existingComment = ""
        Else
            existingComment = currentCell.Comment.text
        End If
        
        If existingComment <> "" Then
            newComment = InputBox(getLocale("EXISTING_COMMENTS") & vbNewLine & existingComment & vbNewLine & vbNewLine & vbNewLine & vbNewLine & getLocale("PLEASE_ENTER_YOUR_COMMENT") & ":", getLocale("ADD_TRANSLATION_COMMENT"))
        Else
            newComment = InputBox(getLocale("PLEASE_ENTER_YOUR_COMMENT") & ":", getLocale("ADD_TRANSLATION_COMMENT"))
        End If

        If Trim(newComment) = "" Then
            Exit Sub
        End If
        
        If existingComment <> "" Then
            nextNo = FindNextNo(existingComment)
            
            commentData = existingComment & vbNewLine
        Else
            nextNo = 1
        End If
        
        commentData = commentData & getLocale("COMMENT_STR") & " " & nextNo & ":" & vbNewLine & _
                    newComment & vbNewLine & getLocale("LC_BY") & vbNewLine & _
                    "OfflineTranslator: " & Application.UserName & vbNewLine & getLocale("LC_DATE") & vbNewLine & _
                    Format(DateTime.now, "yyyy-MM-dd hh:mm")

        Call UpdateComment(newComment, commentData, currentCell, True)
    
        RefocusTargetCell (row)
    
End Sub
Public Sub UpdateVersionComment(previousText As String, newText As String, workingRow As Long)
'------------------------------
'
' Update the current cell comment with the previous version of the translation
'
'------------------------------
        Dim existingComment As String
        Dim newComment As String
        Dim currentCell As Range
        Dim currentCommentText As String
        Dim commentData As String
        Dim versionNo As Integer
        Dim existingMods As String
        
        Set currentCell = Cells(workingRow, 4)
        
        If currentCell.Comment Is Nothing Then
            existingComment = ""
        Else
            existingComment = currentCell.Comment.text
        End If
        
        existingMods = ThisWorkbook.Sheets("data").Cells(workingRow, SEGMENT_MODIFIED_OFFLINE)
                                                        
        If (existingMods = MODIFIED) Then 'Check to see if this is the first mod
            versionNo = FindVersionNumber(existingComment)
        Else 'Must be the first on then
            versionNo = 1
        
            If (existingComment <> Empty) Then
                existingComment = getLocale("ORIGINAL_COMMENT") & ":" & vbNewLine & existingComment
            End If
        End If
        
        newComment = getLocale("VERSION") & " " & versionNo & ": " & vbNewLine & getLocale("CHANGED_FROM") & vbNewLine & previousText & vbNewLine & getLocale("LC_TO") & vbNewLine & newText & vbNewLine & _
                      getLocale("LC_BY") & vbNewLine & Application.UserName & vbNewLine & _
                      getLocale("LC_DATE") & vbNewLine & Format(DateTime.now, "yyyy-MM-dd hh:mm")

        If (existingComment <> Empty) Then
            commentData = existingComment & vbNewLine & newComment
        Else
            commentData = newComment
        End If
        
        newComment = getLocale("VERSION") & " " & versionNo & ": " & vbNewLine & previousText & vbNewLine

        Call UpdateComment(newComment, commentData, currentCell, False)

End Sub
Private Function FindVersionNumber(existingComment As String) As Integer
'------------------------------
'
' Return the next version number to be used.
'
'------------------------------
    Dim i, x, y, lastX, verNo  As Integer
    Dim valStr As String
    
    x = 0
    
    Do
        lastX = x
        x = InStr(x + 1, existingComment, getLocale("VERSION"))
        
        If (x <> 0) Then
            y = InStr(x, existingComment, ":")
            
            If (y <> 0) Then
                valStr = Mid(existingComment, x + 8, y - x)
                verNo = Val(valStr)
            End If
            
        End If
    Loop While x <> 0
    
    FindVersionNumber = verNo + 1
    
End Function


Public Sub UpdateComment(newComment As String, commentData As String, currentCell As Range, translator As Boolean)
'------------------------------
'
' Update the current cell with the comment
'
'------------------------------
    
        Dim row As Long

        Dim unixTime As Double
        
        Dim commentType As String
        
        If (translator = True) Then
            commentType = "TRANSLATOR"
        Else
            commentType = "AUTO_CORRECTOR"
        End If
        
        unixTime = DateDiff("s", "1/1/1970", DateTime.now) * 1000
        
        row = currentCell.row
        ThisWorkbook.Sheets("data").Cells(row, 20).Value = ThisWorkbook.Sheets("data").Cells(row, 20).Value & _
        newComment & "&&&" & "OfflineTranslator: " & Application.UserName & "&&&" & unixTime & "&&&" & commentType & "@@@"
        
        Dim theComment As Comment
        
        With currentCell
                .ClearComments
                .AddComment
                .Comment.text text:=""
        End With
        
        Set theComment = currentCell.Comment
        
        Dim i, x, y, z, cLen As Long
        Dim endChar As String
        Dim c As String
        
        z = 0
        
        cLen = Len(commentData)
        
        For i = 1 To cLen
            c = Mid(commentData, i, 1)
            
            If ((c = vbNewLine) Or (c = vbCr)) Then
                x = 1
            Else
                x = x + 1
                
                If (c = " ") Then
                    z = i
                End If
                
                If (x = 39) Then
                    Dim a, b As String
                    a = Mid(commentData, 1, z - 1)
                    b = Mid(commentData, z + 1)
                    commentData = a & vbNewLine & b
                    x = i - z
                End If
            End If
        Next i
        
        theComment.text text:=commentData
        
ErrorHandler:
        Debug.Print ("Err = " & Err.Number & " = " & Err.Description)
        

End Sub


Function FindNextNo(ByRef commentText As String)
'------------------------------
'
' Find the next number to use as an identifier
' Count the number of newlines
'
'------------------------------
    Dim x, y As Integer
    Dim count As Integer
    Dim theVal As String
    
    Do
        x = InStr(x + 1, commentText, "Comment")
            
        If (x <> 0) Then
            y = InStr(x, commentText, ":")
                
            If (y <> 0) Then
                count = Val(Mid(commentText, x + 8, y - (x + 8)))
            End If
        End If
    Loop While (x <> 0)
        
    FindNextNo = count + 1
    
End Function










Attribute VB_Name = "AdvancedFormControl"
Option Explicit
Option Compare Text
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modFormControl
' By Chip Pearson, chip@cpearson.com, www.cpearson.com
' 21-March-2008
' URL: http://www.cpearson.com/Excel/FormControl.aspx
' Requires: modWindowCaption at http://www.cpearson.com/Excel/FileExtensions.aspx
'
' ----------------------------------
' Functions In This Module:
' ----------------------------------
'   SetFormParent
'       Sets a userform's parent to the Application or the ActiveWindow.
'   IsCloseButtonVisible
'       Returns True or False indicating whether the userform's Close button
'       is visible.
'   ShowCloseButton
'       Displays or hides the userform's Close button.
'   IsCloseButtonEnabled
'       Returns True or False indicating whether the userform's Close button
'       is enabled.
'   EnableCloseButton
'       Enables or disables a userform's Close button.
'   ShowTitleBar
'       Displays or hides a userform's Title Bar. The title bar cannot be
'       hidden if the form is resizable.
'   IsTitleBarVisible
'       Returns True or False indicating if the userform's Title Bar is visible.
'   MakeFormResizable
'       Makes the form resizable or not resizable. If the form is made resizable,
'       the title bar cannot be hidden.
'   IsFormResizable
'       Returns True or False indicating whether the userform is resizable.
'   SetFormOpacity
'       Sets the opacity of a form from fully opaque to fully invisible.
'   HasMaximizeButton
'       Returns True or False indicating whether the userform has a
'       maximize button.
'   HasMinimizeButton
'       Returns True or False indicating whether the userform has a
'       minimize button.
'   ShowMaximizeButton
'       Displays or hides a Maximize Window button on the userform.
'   ShowMinimizeButton
'       Displays or hides a Minimize Window button on the userform.
'   HWndOfUserForm
'       Returns the window handle (HWnd) of a userform.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Private Const C_USERFORM_CLASSNAME = "ThunderDFrame"
Private Const C_EXCEL_APP_CLASSNAME = "XLMain"
Private Const C_EXCEL_DESK_CLASSNAME = "XLDesk"
Private Const C_EXCEL_WINDOW_CLASSNAME = "Excel7"
Private Const MF_BYPOSITION = &H400
Private Const MF_REMOVE = &H1000
Private Const MF_ENABLED = &H0&
Private Const MF_DISABLED = &H2&
Private Const MF_GRAYED = &H1&
Private Const GWL_EXSTYLE = (-20)
Private Const GWL_STYLE = (-16)
Private Const GWL_HWNDPARENT = (-8)
Private Const WS_CAPTION = &HC00000
Private Const WS_SYSMENU = &H80000
Private Const WS_EX_LAYERED = &H80000
Private Const LWA_ALPHA = &H2&
Private Const C_ALPHA_FULL_TRANSPARENT As Byte = 0
Private Const C_ALPHA_FULL_OPAQUE As Byte = 255
Private Const WS_DLGFRAME = &H400000
Private Const WS_THICKFRAME = &H40000
Private Const WS_SIZEBOX = WS_THICKFRAME
Private Const WS_MAXIMIZEBOX = &H10000
Private Const WS_MINIMIZEBOX = &H20000

Public Enum FORM_PARENT_WINDOW_TYPE
    FORM_PARENT_NONE = 0
    FORM_PARENT_APPLICATION = 1
    FORM_PARENT_WINDOW = 2
End Enum

#If Win64 Then
    Private Declare PtrSafe Function SetParent Lib "user32" ( _
        ByVal hWndChild As LongPtr, _
        ByVal hWndNewParent As Long) As Long

    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" ( _
        ByVal lpClassName As String, _
        ByVal lpWindowName As String) As Long
    
    Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" ( _
        ByVal hWnd As LongPtr, _
        ByVal nIndex As Long) As Long

    Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" ( _
        ByVal hWnd As LongPtr, _
        ByVal nIndex As Long, _
        ByVal dwNewLong As Long) As Long
    
    Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" ( _
        ByVal hWnd As LongPtr, _
        ByVal crey As Byte, _
        ByVal bAlpha As Byte, _
        ByVal dwFlags As Long) As Long

    Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" ( _
        ByVal hWnd1 As LongPtr, _
        ByVal hWnd2 As LongPtr, _
        ByVal lpsz1 As String, _
        ByVal lpsz2 As String) As Long

    Private Declare PtrSafe Function GetActiveWindow Lib "user32" () As Long

    Private Declare PtrSafe Function DrawMenuBar Lib "user32" ( _
        ByVal hWnd As Long) As Long

    Private Declare PtrSafe Function GetMenuItemCount Lib "user32" ( _
        ByVal hMenu As Long) As Long

    Private Declare PtrSafe Function GetSystemMenu Lib "user32" ( _
        ByVal hWnd As LongPtr, _
        ByVal bRevert As Long) As Long
    
    Private Declare PtrSafe Function RemoveMenu Lib "user32" ( _
        ByVal hMenu As Long, _
        ByVal nPosition As Long, _
        ByVal wFlags As Long) As Long
    
    Private Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" ( _
        ByVal hWnd As LongPtr, _
        ByVal lpString As String, _
        ByVal cch As Long) As Long
    
    Private Declare PtrSafe Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" ( _
        ByVal hWnd As LongPtr) As Long

    Private Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" ( _
        ByVal hWnd As LongPtr, _
        ByVal lpClassName As String, _
        ByVal nMaxCount As Long) As Long

    Private Declare PtrSafe Function EnableMenuItem Lib "user32" ( _
        ByVal hMenu As LongPtr, _
        ByVal wIDEnableItem As Long, _
        ByVal wEnable As Long) As Long
#Else
    Private Declare Function SetParent Lib "user32" ( _
        ByVal hWndChild As Long, _
        ByVal hWndNewParent As Long) As Long

    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" ( _
        ByVal lpClassName As String, _
        ByVal lpWindowName As String) As Long
    
    Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" ( _
        ByVal hWnd As Long, _
        ByVal nIndex As Long) As Long

    Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" ( _
        ByVal hWnd As Long, _
        ByVal nIndex As Long, _
        ByVal dwNewLong As Long) As Long
    
    Private Declare Function SetLayeredWindowAttributes Lib "user32" ( _
        ByVal hWnd As Long, _
        ByVal crey As Byte, _
        ByVal bAlpha As Byte, _
        ByVal dwFlags As Long) As Long

    Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" ( _
        ByVal hWnd1 As Long, _
        ByVal hWnd2 As Long, _
        ByVal lpsz1 As String, _
        ByVal lpsz2 As String) As Long

    Private Declare Function GetActiveWindow Lib "user32" () As Long

    Private Declare Function DrawMenuBar Lib "user32" ( _
        ByVal hWnd As Long) As Long

    Private Declare Function GetMenuItemCount Lib "user32" ( _
        ByVal hMenu As Long) As Long

    Private Declare Function GetSystemMenu Lib "user32" ( _
        ByVal hWnd As Long, _
        ByVal bRevert As Long) As Long
    
    Private Declare Function RemoveMenu Lib "user32" ( _
        ByVal hMenu As Long, _
        ByVal nPosition As Long, _
        ByVal wFlags As Long) As Long
    
    Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" ( _
        ByVal hWnd As Long, _
        ByVal lpString As String, _
        ByVal cch As Long) As Long
    
    Private Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" ( _
        ByVal hWnd As Long) As Long

    Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" ( _
        ByVal hWnd As Long, _
        ByVal lpClassName As String, _
        ByVal nMaxCount As Long) As Long

    Private Declare Function EnableMenuItem Lib "user32" ( _
        ByVal hMenu As Long, _
        ByVal wIDEnableItem As Long, _
        ByVal wEnable As Long) As Long
#End If



Function ShowMaximizeButton(UF As MSForms.UserForm, _
    HideButton As Boolean) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ShowMaximizeButton
' Displays (if HideButton is False) or hides (if HideButton is True)
' a maximize window button.
' NOTE: If EITHER a Minimize or Maximize button is displayed,
' BOTH buttons are visible but may be disabled.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    ShowMaximizeButton = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
If HideButton = False Then
    WinInfo = WinInfo Or WS_MAXIMIZEBOX
Else
    WinInfo = WinInfo And (Not WS_MAXIMIZEBOX)
End If
R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)

ShowMaximizeButton = (R <> 0)

End Function

Function ShowMinimizeButton(UF As MSForms.UserForm, _
    HideButton As Boolean) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ShowMinimizeButton
' Displays (if HideButton is False) or hides (if HideButton is True)
' a minimize window button.
' NOTE: If EITHER a Minimize or Maximize button is displayed,
' BOTH buttons are visible but may be disabled.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    ShowMinimizeButton = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
If HideButton = False Then
    WinInfo = WinInfo Or WS_MINIMIZEBOX
Else
    WinInfo = WinInfo And (Not WS_MINIMIZEBOX)
End If
R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)

ShowMinimizeButton = (R <> 0)

End Function

Function HasMinimizeButton(UF As MSForms.UserForm) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' HasMinimizeButton
' Returns True if the userform has a minimize button, False
' otherwise.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    HasMinimizeButton = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

If WinInfo And WS_MINIMIZEBOX Then
    HasMinimizeButton = True
Else
    HasMinimizeButton = False
End If

End Function

Function HasMaximizeButton(UF As MSForms.UserForm) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' HasMaximizeButton
' Returns True if the userform has a maximize button, False
' otherwise.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    HasMaximizeButton = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

If WinInfo And WS_MAXIMIZEBOX Then
    HasMaximizeButton = True
Else
    HasMaximizeButton = False
End If

End Function


Function SetFormParent(UF As MSForms.UserForm, _
    Parent As FORM_PARENT_WINDOW_TYPE) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SetFormParent
' Set the UserForm UF as a child of (1) the Application, (2) the
' Excel ActiveWindow, or (3) no parent. Returns TRUE if successful
' or FALSE if unsuccessful.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WindHWnd As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    SetFormParent = False
    Exit Function
End If

Select Case Parent
    Case FORM_PARENT_APPLICATION
        R = SetParent(UFHWnd, Application.hWnd)
    Case FORM_PARENT_NONE
        R = SetParent(UFHWnd, 0&)
    Case FORM_PARENT_WINDOW
        If Application.ActiveWindow Is Nothing Then
            SetFormParent = False
            Exit Function
        End If
        WindHWnd = WindowHWnd(Application.ActiveWindow)
        If WindHWnd = 0 Then
            SetFormParent = False
            Exit Function
        End If
        R = SetParent(UFHWnd, WindHWnd)
    Case Else
        SetFormParent = False
        Exit Function
End Select
SetFormParent = (R <> 0)

End Function


Function IsCloseButtonVisible(UF As MSForms.UserForm) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsCloseButtonVisible
' Returns TRUE if UserForm UF has a close button, FALSE if there
' is no close button.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    IsCloseButtonVisible = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
IsCloseButtonVisible = (WinInfo And WS_SYSMENU)

End Function

Function ShowCloseButton(UF As MSForms.UserForm, HideButton As Boolean) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ShowCloseButton
' This displays (if HideButton is FALSE) or hides (if HideButton is
' TRUE) the Close button on the userform
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
If HideButton = False Then
    ' set the SysMenu bit
    WinInfo = WinInfo Or WS_SYSMENU
Else
    ' clear the SysMenu bit
    WinInfo = WinInfo And (Not WS_SYSMENU)
End If

R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)
ShowCloseButton = (R <> 0)

End Function


Function IsCloseButtonEnabled(UF As MSForms.UserForm) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsCloseButtonEnabled
' This returns TRUE if the close button is enabled or FALSE if
' the close button is disabled.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim hMenu As Long
Dim ItemCount As Long
Dim PrevState As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    IsCloseButtonEnabled = False
    Exit Function
End If
' Get the menu handle
hMenu = GetSystemMenu(UFHWnd, 0&)
If hMenu = 0 Then
    IsCloseButtonEnabled = False
    Exit Function
End If

ItemCount = GetMenuItemCount(hMenu)
' Disable the button. This returns MF_DISABLED or MF_ENABLED indicating
' the previous state of the item.
PrevState = EnableMenuItem(hMenu, ItemCount - 1, MF_DISABLED Or MF_BYPOSITION)

If PrevState = MF_DISABLED Then
    IsCloseButtonEnabled = False
Else
    IsCloseButtonEnabled = True
End If
' restore the previous state
EnableCloseButton UF, (PrevState = MF_DISABLED)

DrawMenuBar UFHWnd

End Function


Function EnableCloseButton(UF As MSForms.UserForm, Disable As Boolean) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' EnableCloseButton
' This function enables (if Disable is False) or disables (if
' Disable is True) the "X" button on a UserForm UF.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim hMenu As Long
Dim ItemCount As Long
Dim res As Long

' Get the HWnd of the UserForm.
UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    EnableCloseButton = False
    Exit Function
End If
' Get the menu handle
hMenu = GetSystemMenu(UFHWnd, 0&)
If hMenu = 0 Then
    EnableCloseButton = False
    Exit Function
End If

ItemCount = GetMenuItemCount(hMenu)
If Disable = True Then
    res = EnableMenuItem(hMenu, ItemCount - 1, MF_DISABLED Or MF_BYPOSITION)
Else
    res = EnableMenuItem(hMenu, ItemCount - 1, MF_ENABLED Or MF_BYPOSITION)
End If
If res = -1 Then
    EnableCloseButton = False
    Exit Function
End If
DrawMenuBar UFHWnd

EnableCloseButton = True


End Function

Function ShowTitleBar(UF As MSForms.UserForm, HideTitle As Boolean) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ShowTitleBar
' Displays (if HideTitle is FALSE) or hides (if HideTitle is TRUE) the
' title bar of the userform UF.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    ShowTitleBar = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

If HideTitle = False Then
    ' turn on the Caption bit
    WinInfo = WinInfo Or WS_CAPTION
Else
    ' turn off the Caption bit
    WinInfo = WinInfo And (Not WS_CAPTION)
End If
R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)
ShowTitleBar = (R <> 0)
End Function

Function IsTitleBarVisible(UF As MSForms.UserForm) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsTitleBarVisible
' Returns TRUE if the title bar of UF is visible or FALSE if the
' title bar is not visible.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    IsTitleBarVisible = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

IsTitleBarVisible = (WinInfo And WS_CAPTION)

End Function

Function MakeFormResizable(UF As MSForms.UserForm, Sizable As Boolean) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' MakeFormResizable
' This makes the userform UF resizable (if Sizable is TRUE) or not
' resizable (if Sizalbe is FALSE). Returns TRUE if successful or FALSE
' if an error occurred.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    MakeFormResizable = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
If Sizable = True Then
    WinInfo = WinInfo Or WS_SIZEBOX
Else
    WinInfo = WinInfo And (Not WS_SIZEBOX)
End If

R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)
MakeFormResizable = (R <> 0)


End Function

Function IsFormResizable(UF As MSForms.UserForm) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsFormResizable
' Returns TRUE if UF is resizable, FALSE if UF is not resizable.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim UFHWnd As Long
Dim WinInfo As Long
Dim R As Long

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    IsFormResizable = False
    Exit Function
End If

WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

IsFormResizable = (WinInfo And WS_SIZEBOX)

End Function


Function SetFormOpacity(UF As MSForms.UserForm, Opacity As Byte) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SetFormOpacity
' This function sets the opacity of the UserForm referenced by the
' UF parameter. Opacity specifies the opacity of the form, from
' 0 = fully transparent (invisible) to 255 = fully opaque. The function
' returns True if successful or False if an error occurred. This
' requires Windows 2000 or later -- it will not work in Windows
' 95, 98, or ME.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim UFHWnd As Long
Dim WinL As Long
Dim res As Long

SetFormOpacity = False

UFHWnd = HWndOfUserForm(UF)
If UFHWnd = 0 Then
    Exit Function
End If

WinL = GetWindowLong(UFHWnd, GWL_EXSTYLE)
If WinL = 0 Then
    Exit Function
End If

res = SetWindowLong(UFHWnd, GWL_EXSTYLE, WinL Or WS_EX_LAYERED)
If res = 0 Then
    Exit Function
End If

res = SetLayeredWindowAttributes(UFHWnd, 0, Opacity, LWA_ALPHA)
If res = 0 Then
    Exit Function
End If

SetFormOpacity = True

End Function


Function HWndOfUserForm(UF As MSForms.UserForm) As Long
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' HWndOfUserForm
' This returns the window handle (HWnd) of the userform referenced
' by UF. It first looks for a top-level window, then a child
' of the Application window, then a child of the ActiveWindow.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim AppHWnd As Long
Dim DeskHWnd As Long
Dim WinHWnd As Long
Dim UFHWnd As Long
Dim Cap As String
Dim WindowCap As String

Cap = UF.caption

' First, look in top level windows
UFHWnd = FindWindow(C_USERFORM_CLASSNAME, Cap)
If UFHWnd <> 0 Then
    HWndOfUserForm = UFHWnd
    Exit Function
End If
' Not a top level window. Search for child of application.
AppHWnd = Application.hWnd
UFHWnd = FindWindowEx(AppHWnd, 0&, C_USERFORM_CLASSNAME, Cap)
If UFHWnd <> 0 Then
    HWndOfUserForm = UFHWnd
    Exit Function
End If
' Not a child of the application.
' Search for child of ActiveWindow (Excel's ActiveWindow, not
' Window's ActiveWindow).
If Application.ActiveWindow Is Nothing Then
    HWndOfUserForm = 0
    Exit Function
End If
WinHWnd = WindowHWnd(Application.ActiveWindow)
UFHWnd = FindWindowEx(WinHWnd, 0&, C_USERFORM_CLASSNAME, Cap)
HWndOfUserForm = UFHWnd

End Function


Function ClearBit(Value As Long, ByVal BitNumber As Long) As Long
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ClearBit
' Clears the specified bit in Value and returns the result. Bits are
' numbered, right (most significant) 31 to left (least significant) 0.
' BitNumber is made positive and then MOD 32 to get a valid bit number.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim SetMask As Long
Dim ClearMask As Long

BitNumber = Abs(BitNumber) Mod 32

SetMask = Value
If BitNumber < 30 Then
    ClearMask = Not (2 ^ (BitNumber - 1))
    ClearBit = SetMask And ClearMask
Else
    ClearBit = Value And &H7FFFFFFF
End If

End Function



Attribute VB_Name = "AdvancedWindowCaption"
Option Explicit
Option Compare Text
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modWindowCaption
' By Chip Pearson, 15-March-2008, chip@cpearson.com, www.cpearson.com
' http://www.cpearson.com/Excel/FileExtensions.aspx
'
' This module contains code for working with Excel.Window captions. This code
' is necessary if you are going to use the FindWindowEx API call to get the
' HWnd of an Excel.Window.  Windows has a property called "Hide extensions of
' known file types". If this setting is TRUE, the file extension is not displayed
' (e.g., "Book1.xls" is displayed as just "Book1"). However, the Caption of an
' Excel.Window always includes the ".xls" file extension, regardless of the hide
' extensions setting. FindWindowEx requires that the ".xls" extension be removed
' if the "hide extensions" setting is True.
'
' This module contains a function named DoesWindowsHideFileExtensions, which returns
' TRUE if Windows is hiding file extensions or FALSE if Windows is not hiding file
' extensions. This is determined by a registry key. The module also contains a
' function named WindowCaption that returns the Caption of a specified Excel.Window
' with the ".xls" removed if necessary. The string returned by this function
' is suitable for use in FindWindowEx regardless of the value of the Windows
' "Hide Extensions" setting.
'
' This module also contains a function named WindowHWnd which returns the HWnd of
' a specified Excel.Window object. This function works regardless of the value of the
' Windows "Hide Extensions" setting.
'
' This module also includes the functions WindowText and WindowClassName which are
' just wrappers for the GetWindowText and GetClassName API functions.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
#If Win64 Then
    Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" ( _
        ByVal hWnd1 As LongPtr, _
        ByVal hWnd2 As LongPtr, _
        ByVal lpsz1 As String, _
        ByVal lpsz2 As String) As Long

    Private Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" ( _
        ByVal hWnd As LongPtr, _
        ByVal lpString As String, _
        ByVal cch As Long) As Long

    Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
        ByVal HKey As LongPtr, _
        ByVal lpSubKey As String, _
        ByVal ulOptions As Long, _
        ByVal samDesired As Long, _
        phkResult As Long) As Long
    
    Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
        ByVal HKey As LongPtr, _
        ByVal lpValueName As String, _
        ByVal lpReserved As Long, _
        LPType As Long, _
        LPData As Any, _
        lpcbData As Long) As Long

    Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" ( _
        ByVal HKey As Long) As Long

    Private Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" ( _
        ByVal hWnd As LongPtr, _
        ByVal lpClassName As String, _
        ByVal nMaxCount As Long) As Long

#Else
    Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" ( _
        ByVal hWnd1 As Long, _
        ByVal hWnd2 As Long, _
     ByVal lpsz1 As String, _
        ByVal lpsz2 As String) As Long

    Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" ( _
        ByVal hWnd As Long, _
        ByVal lpString As String, _
        ByVal cch As Long) As Long

    Private Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
        ByVal HKey As Long, _
        ByVal lpSubKey As String, _
        ByVal ulOptions As Long, _
        ByVal samDesired As Long, _
        phkResult As Long) As Long
    
    Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
        ByVal HKey As Long, _
        ByVal lpValueName As String, _
        ByVal lpReserved As Long, _
        LPType As Long, _
        LPData As Any, _
        lpcbData As Long) As Long

    Private Declare Function RegCloseKey Lib "advapi32.dll" ( _
        ByVal HKey As Long) As Long

    Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" ( _
        ByVal hWnd As Long, _
        ByVal lpClassName As String, _
        ByVal nMaxCount As Long) As Long
#End If

Private Const HKEY_CURRENT_USER As Long = &H80000001
Private Const HKEY_LOCAL_MACHINE As Long = &H80000002
Private Const HKEY_CLASSES_ROOT  As Long = &H80000000
Private Const HKEY_CURRENT_CONFIG  As Long = &H80000005
Private Const HKEY_DYN_DATA  As Long = &H80000006
Private Const HKEY_PERFORMANCE_DATA  As Long = &H80000004
Private Const HKEY_USERS  As Long = &H80000003
Private Const KEY_ALL_ACCESS  As Long = &H3F
Private Const ERROR_SUCCESS  As Long = 0&
Private Const HKCU  As Long = HKEY_CURRENT_USER
Private Const HKLM  As Long = HKEY_LOCAL_MACHINE

Private Enum REG_DATA_TYPE
    REG_DATA_TYPE_DEFAULT = 0   ' Default based on data type of value.
    REG_INVALID = -1            ' Invalid
    REG_SZ = 1                  ' String
    REG_DWORD = 4               ' Long
End Enum

Private Const C_EXCEL_APP_CLASSNAME = "XLMain"
Private Const C_EXCEL_DESK_CLASSNAME = "XLDesk"
Private Const C_EXCEL_WINDOW_CLASSNAME = "EXCEL7"


Function DoesWindowsHideFileExtensions() As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' DoesWindowsHideFileExtensions
' This function looks in the registry key
'   HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced
' for the value named "HideFileExt" to determine whether the Windows Explorer
' setting "Hide Extensions Of Known File Types" is enabled. This function returns
' TRUE if this setting is in effect (meaning that Windows displays "Book1" rather
' than "Book1.xls"), or FALSE if this setting is not in effect (meaning that Windows
' displays "Book1.xls").
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim res As Long
Dim RegKey As Long
Dim V As Long

Const KEY_NAME = "Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
Const VALUE_NAME = "HideFileExt"

''''''''''''''''''''''''''''''''''''''''''''''''''
' Open the registry key to get a handle (RegKey).
''''''''''''''''''''''''''''''''''''''''''''''''''
res = RegOpenKeyEx(HKey:=HKCU, _
                    lpSubKey:=KEY_NAME, _
                    ulOptions:=0&, _
                    samDesired:=KEY_ALL_ACCESS, _
                    phkResult:=RegKey)

If res <> ERROR_SUCCESS Then
    Exit Function
End If
''''''''''''''''''''''''''''''''''''''''''''''''''
' Get the value of the "HideFileExt" named value.
''''''''''''''''''''''''''''''''''''''''''''''''''
res = RegQueryValueEx(HKey:=RegKey, _
                    lpValueName:=VALUE_NAME, _
                    lpReserved:=0&, _
                    LPType:=REG_DWORD, _
                    LPData:=V, _
                    lpcbData:=Len(V))

If res <> ERROR_SUCCESS Then
    RegCloseKey RegKey
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''''''
' Close the key and return the result.
''''''''''''''''''''''''''''''''''''''''''''''''''
RegCloseKey RegKey
DoesWindowsHideFileExtensions = (V <> 0)


End Function


Function WindowCaption(W As Excel.Window) As String
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' WindowCaption
' This returns the Caption of the Excel.Window W with the ".xls" extension removed
' if required. The string returned by this function is suitable for use by
' the FindWindowEx API regardless of the value of the Windows "Hide Extensions"
' setting.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim HideExt As Boolean
Dim Cap As String
Dim Pos As Long

HideExt = DoesWindowsHideFileExtensions()
Cap = W.caption
If HideExt = True Then
    Pos = InStrRev(Cap, ".")
    If Pos > 0 Then
        Cap = Left(Cap, Pos - 1)
    End If
End If

WindowCaption = Cap

End Function

Function WindowHWnd(W As Excel.Window) As Long
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' WindowHWnd
' This returns the HWnd of the Window referenced by W.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim AppHWnd As Long
Dim DeskHWnd As Long
Dim WHWnd As Long
Dim Cap As String

AppHWnd = Application.hWnd
DeskHWnd = FindWindowEx(AppHWnd, 0&, C_EXCEL_DESK_CLASSNAME, vbNullString)
If DeskHWnd > 0 Then
    Cap = WindowCaption(W)
    WHWnd = FindWindowEx(DeskHWnd, 0&, C_EXCEL_WINDOW_CLASSNAME, Cap)
End If
WindowHWnd = WHWnd

End Function

Function WindowText(hWnd As Long) As String
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' WindowText
' This just wraps up GetWindowText.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim S As String
    Dim N As Long
    N = 255
    S = String$(N, vbNullChar)
    N = GetWindowText(hWnd, S, N)
    If N > 0 Then
        WindowText = Left(S, N)
    Else
        WindowText = vbNullString
    End If
End Function

Function WindowClassName(hWnd As Long) As String
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' WindowClassName
' This just wraps up GetClassName.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    Dim S As String
    Dim N As Long
    N = 255
    S = String$(N, vbNullChar)
    N = GetClassName(hWnd, S, N)
    If N > 0 Then
        WindowClassName = Left(S, N)
    Else
        WindowClassName = vbNullString
    End If

End Function


Attribute VB_Name = "ClipboardHandler"
 Option Explicit

  'adapted from:
  '  http://www.mrexcel.com/forum/excel-questions/411552-sendinput-visual-basic-applications.html

  Const INPUT_KEYBOARD = 1
  Const KEYEVENTF_KEYUP = &H2
 
  Private Type KEYBDINPUT
      wVK As Integer
      wScan As Integer
      dwFlags As Long
      time As Long
      dwExtraInfo As Long
  End Type

  Private Type GENERALINPUT
      dwType As Long
      xi(0 To 23) As Byte
  End Type
  
#If Win64 Then
  Private Declare PtrSafe Function SendInput Lib "user32.dll" _
      (ByVal nInputs As Long, _
      pInputs As GENERALINPUT, _
      ByVal cbSize As Long) As Long

  Private Declare PtrSafe Sub CopyMemory Lib "kernel32" _
      Alias "RtlMoveMemory" _
      (pDst As Any, _
      pSrc As Any, _
      ByVal ByteLen As Long)
#Else
  Private Declare Function SendInput Lib "user32.dll" _
      (ByVal nInputs As Long, _
      pInputs As GENERALINPUT, _
      ByVal cbSize As Long) As Long

  Private Declare Sub CopyMemory Lib "kernel32" _
      Alias "RtlMoveMemory" _
      (pDst As Any, _
      pSrc As Any, _
      ByVal ByteLen As Long)
#End If

Private Sub KeyDown(bKey As Byte)
      Dim GInput(0 To 1) As GENERALINPUT
      Dim KInput As KEYBDINPUT
      KInput.wVK = bKey
      KInput.dwFlags = 0
      GInput(0).dwType = INPUT_KEYBOARD
      CopyMemory GInput(0).xi(0), KInput, Len(KInput)
      Call SendInput(1, GInput(0), Len(GInput(0)))
End Sub

Private Sub KeyUp(bKey As Byte)
      Dim GInput(0 To 1) As GENERALINPUT
      Dim KInput As KEYBDINPUT
      KInput.wVK = bKey
      KInput.dwFlags = KEYEVENTF_KEYUP
      GInput(0).dwType = INPUT_KEYBOARD
      CopyMemory GInput(0).xi(0), KInput, Len(KInput)
     Call SendInput(1, GInput(0), Len(GInput(0)))
End Sub

Sub CopyToClipboard()
'------------------------------
'
' Simulate control-C to copy selection to the clipboard
'
'------------------------------
    Dim str As String
          
    KeyDown vbKeyControl
    KeyDown vbKeyC
    KeyUp vbKeyC
    KeyUp vbKeyControl

    DoEvents

    Dim Clip As MSForms.DataObject
    Set Clip = New MSForms.DataObject
    Clip.GetFromClipboard
    Debug.Print Clip.GetText
End Sub

Sub CutToClipboard()
'------------------------------
'
' Simulate control-X to cut selection to the clipboard
'
'------------------------------
    Dim str As String
    
    Call CopyToClipboard
    
    KeyDown vbKeyDelete
    KeyUp vbKeyDelete

    DoEvents

    Dim Clip As MSForms.DataObject
    Set Clip = New MSForms.DataObject
    Clip.GetFromClipboard
    Debug.Print Clip.GetText

End Sub
Sub PasteFromClipboard()
'------------------------------
'
' Simulate control-V to paste the selection from the clipboard
'
'------------------------------
      
    Dim str As String

      'Simulate control-C to copy selection to clipboard
    KeyDown vbKeyControl
    KeyDown vbKeyV
    KeyUp vbKeyV
    KeyUp vbKeyControl

    DoEvents

    Dim Clip As MSForms.DataObject
    Set Clip = New MSForms.DataObject
    Clip.GetFromClipboard
    Debug.Print Clip.GetText

End Sub

Sub SendKey(vbKey As Byte)
'------------------------------
'
' Send the key to the OS
'
'------------------------------

    KeyDown vbKey
    KeyUp vbKey
    
    DoEvents

End Sub
Sub SendShiftedKey(vbKey As Byte)
'------------------------------
'
' Send Shift + the key to the OS
'
'------------------------------
    KeyDown vbKeyShift
    KeyDown vbKey
    KeyUp vbKey
    KeyUp vbKeyShift
    
    DoEvents

End Sub





Attribute VB_Name = "CommonConst"
Option Explicit
'------------------------------
'
' Set stup common constants
'
'------------------------------

Public Const SEGNO As Integer = 2
Public Const SRCSEG As Integer = 3
Public Const TGTSEG As Integer = 4
Public Const Status As Integer = 5

Public Const FIRST_SEG As Long = 8

Public Const SPELL_LANG_WARNING = 249

Public Const SEGMENT_MODIFIED_OFFLINE As Integer = 250

Public Const LOG_START As Integer = 254
Public Const LOG_END As Integer = 255

Public Const MATCH_USED As Integer = 256
Public Const SEARCH_COL As Integer = 257
Public Const REPLACE_COL As Integer = 258

Public Const STATUS_CHANGED_INTENTIONALY As Integer = 120

Public Const SPELL_CHECK_ALL_SEGMENTS As Integer = 120 '1, 120
Public Const SHOW_ALL_COMMENTS As Integer = 121 '1, 121
Public Const SIMPLE_VIEW As Integer = 122

Public Const MODIFIED As String = "MODIFIED"

Public Const PASSWORD = "d9c7f325432043deafc09af9a3b989df"

Public Const Spanish As Integer = 1
Public Const French As Integer = 2
Public Const Dutch As Integer = 3
Public Const Greek As Integer = 4
Public Const OtherLang As Integer = 0

Attribute VB_Name = "Concordance"
Attribute VB_Base = "0{B36AC0BA-E2DF-4850-B3AD-71FFC9D9851E}{6CBAA117-0E6F-4CE6-B867-359E3E9F69B1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public source As Boolean
Private x As Integer
Private theTerm As String
Private termLen As Integer
Private results As String

Private currentRow As Long
Private currentCol As Long


Private Sub NextButton_Click()
    Dim line As Integer
    
    x = InStr(x + 1, UCase(results), UCase(theTerm))
    
    line = FindCurrentLine()
            
    If (x <> 0) Then
        With TextBox
            .SetFocus
            .CurX = x
            .CurLine = line
            .SelStart = x - 1
            .SelLength = termLen
        End With
    End If

End Sub

Private Function FindCurrentLine() As Integer
    Dim i, lCount As Integer
    Dim c As String
    
    For i = x To 1 Step -1
        c = Mid(results, i, 1)
        If (c = vbCr) Then
            lCount = lCount + 1
        End If
    Next
    
End Function

Private Sub TextBox_Change()
    TextBox.SetFocus
    TextBox.ScrollBars = fmScrollBarsBoth
    TextBox.SelStart = 0
End Sub

Private Sub UserForm_Activate()
    SourceToggle.Value = source
    TargetToggle.Value = Not source
    
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column

    'TextBox.Font.Size = 12
    'TextBox.Font.Bold = True
    
    TextBox.MultiLine = True
    
    Concordance.caption = getLocale("CONCORDANCE")
    Term.caption = getLocale("TERM")
    SourceToggle.caption = getLocale("SOURCE")
    TargetToggle.caption = getLocale("TARGET")
    Search.caption = getLocale("SEARCH")
    NextButton.caption = getLocale("NEXT")
    Frame1.caption = getLocale("RESULTS")
    
    Call SetupCombo(TermBox, SEARCH_COL)
    
End Sub
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call StoreCombo(TermBox, SEARCH_COL)
    
    Hide
    
End Sub

Private Sub Search_Click()
    Dim Concordances As Collection
    Dim conc As ConcordanceObject
    Dim theLen As Integer
    Dim line As Integer
    
    SetSource
    
    theTerm = Trim(TermBox)
    
    results = Empty
    
    If (theTerm = Empty) Then
        MsgBox ("please enter the term that you are searching for")
    Else
        Call Add2ComboBox(TermBox, theTerm)
        
        Set Concordances = Sheet1.ConcordanceSearch(theTerm, source)
        
        If (Concordances.count = 0) Then
            MsgBox ("No results found")
        Else
        
            For Each conc In Concordances
                If (Len(conc.TheSource) > theLen) Then
                    theLen = Len(conc.TheSource)
                End If
                
                If (Len(conc.TheTarget) > theLen) Then
                    theLen = Len(conc.TheTarget)
                End If
                
                
                results = results & "ID: " & conc.SegmentID & vbCr & _
                      "Source: " & conc.TheSource & vbCr & _
                      "Target: " & conc.TheTarget & vbCr & vbCr
            Next
        
            TextBox.Locked = False
            TextBox.Value = results
            
           ' With TextBox
           '     .Width = theLen * 6
           '     .HideSelection = False
                '.SelStart = 20
                '.SelLength = 10
            'End With
            
            termLen = Len(theTerm)
            
            x = InStr(UCase(results), UCase(theTerm))
            
            line = FindCurrentLine()

            If (x <> 0) Then
                With TextBox
                    .SetFocus
                    .CurLine = line

                    .SelStart = x - 1
                    '.SelStart = 1
                    .SelLength = termLen
                    '.SelLength = 0
                    '.AutoSize = True
                  
                End With
                
                TextBox.SetFocus
            End If
        End If
    End If
End Sub

Private Sub SourceToggle_Click()
    SetSource
End Sub

Private Sub TargetToggle_Click()
    SetSource
End Sub
Private Sub SetSource()
    source = SourceToggle.Value
End Sub



Attribute VB_Name = "ConcordanceObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private pTheSource As String
Private pTheTarget As String
Private pSegmentID As String

Public Property Get TheSource() As String
    TheSource = pTheSource
End Property

Public Property Get TheTarget() As String
    TheTarget = pTheTarget
End Property


Public Property Get SegmentID() As String
    SegmentID = pSegmentID
End Property

Public Property Let TheSource(Value As String)
    pTheSource = Value
End Property

Public Property Let TheTarget(Value As String)
    pTheTarget = Value
End Property


Public Property Let SegmentID(Value As String)
    pSegmentID = Value
End Property


Attribute VB_Name = "CustomiseMenus"
Option Explicit

Const MY_TAG = "MY_TAG"
Const ELLIPSIS = "..."


Public Sub DeleteAddTranslationCommentFromShortcut()
'------------------------------
'
' Delete the shortcut menu item so we do not end up with multiples
'
'------------------------------
        On Error Resume Next
        CommandBars("Cell").Controls("Add Translation Comment").Delete
        
End Sub

Public Sub CustomiseRMenus()

    Dim myCommandBar As Office.CommandBar
    Dim ctrl As Office.CommandBarControl
    Dim i As Integer, j As Integer
    Dim a(23) As String
               
    On Error Resume Next
    Debug.Print ("RemoveUnnecessaryRMenus() start")
    
    '//A list of right click menu items I don't need to see
    a(0) = getLocale("PICK_FROM_DROPDOWN_LIST") & ELLIPSIS
    a(1) = getLocale("ADD_WATCH")
    a(2) = getLocale("CREATE_LIST") & ELLIPSIS
    a(3) = getLocale("HYPERLINK") & ELLIPSIS
    a(4) = getLocale("LOOK_UP") & ELLIPSIS
    a(5) = getLocale("CUT")
    a(6) = getLocale("CLEAR_CONTENTS")
    a(7) = getLocale("FORMAT_CELLS") & ELLIPSIS
    a(8) = getLocale("SORT")
    a(9) = getLocale("FILTER")
    a(10) = getLocale("NAME_A_RANGE") & ELLIPSIS
    a(11) = getLocale("INSERT") & ELLIPSIS
    a(12) = getLocale("DELETE") & ELLIPSIS
    a(13) = getLocale("INSERT_COMMENT")
    a(14) = getLocale("DEFINE_NAME") & ELLIPSIS
    a(15) = getLocale("COPY")
    a(16) = getLocale("PASTE_OPTIONS")
    a(17) = getLocale("PASTE_SPECIAL") & ELLIPSIS
    a(18) = getLocale("DELETE_COMMENT")
    a(19) = getLocale("HIDE_COMMENT")
    a(20) = getLocale("SHOW_HIDE_COMMENTS")

    '//Tag the above list of inbuilt controls with my tag -
    '  my remove procedure will then remove them just like my custom controls
    
    'Application.CommandBars("Formula Bar").Enabled = False
    
    For Each myCommandBar In Application.CommandBars
        'If myCommandBar.Name = "Formula Bar" Then
        If myCommandBar.Name <> "Cell" Then
            myCommandBar.Enabled = False
        Else
        'myCommandBar.Enabled = False
        'If myCommandBar.Name = "Cell" Then
            For Each ctrl In myCommandBar.Controls
                ctrl.Tag = MY_TAG
            Next ctrl
         End If
    Next myCommandBar

    '//Removed all tagged controls (whether custom or tagged inbuilt controls)
    Set ctrl = Application.CommandBars.FindControl(Tag:=MY_TAG)
    Do Until ctrl Is Nothing
        ctrl.Delete
        Set ctrl = Application.CommandBars.FindControl(Tag:=MY_TAG)
    Loop
    
    i = 0
    
    'If (Application.Version = "12.0") Then
        For Each myCommandBar In Application.CommandBars
            i = i + 1
            'Debug.Print "myCommandBar.Name(" & i & ") = " & myCommandBar.Name
            'If ((myCommandBar.Name = "Cell") Or (myCommandBar.Name = "Formula Bar")) Then
            If (myCommandBar.Name = "Cell") Then
            Debug.Print "myCommandBar.Name(" & i & ") = " & myCommandBar.Name

                Call AddTheMenuItem(myCommandBar, getLocale("SPELLCHECK_ALL_SEGMENTS"), "Sheet1.SpellCheckAllSegments", 548)
                Call AddTheMenuItem(myCommandBar, getLocale("CONCORDANCE") & " " & getLocale("CTRL_BACKSLASH"), "sheet1.DoConcordance", 548)
                Call AddTheMenuItem(myCommandBar, getLocale("PREVIOUS_INCOMPLETE_SEGMENT"), "sheet1.GoToPreviousIncompleteSegment", 359)
                Call AddTheMenuItem(myCommandBar, getLocale("NEXT_INCOMPLETE_SEGMENT") & " " & getLocale("CTRL_M"), "sheet1.GoToNextIncompleteSegment", 360)
                Call AddTheMenuItem(myCommandBar, getLocale("ADD_TRANSLATION_COMMENT"), "AddComment", 201)
                Call AddTheMenuItem(myCommandBar, getLocale("PREVIOUS_SEGMENT_WITH_COMMENTS"), "sheet1.GoToPreviousSegmentWithComment", 38)
                Call AddTheMenuItem(myCommandBar, getLocale("NEXT_SEGMENT_WITH_COMMENTS"), "sheet1.GoToNextSegmentWithComment", 40)
                Call AddTheMenuItem(myCommandBar, getLocale("NEXT_SEGMENT_WITH_ERRORS"), "sheet1.GoToNextSegmentWithErrors", 463)
                Call AddTheMenuItem(myCommandBar, getLocale("FIND_AND_REPLACE"), "sheet1.FindAndReplace", 141)
                Call AddTheMenuItem(myCommandBar, getLocale("GO_TO_SEGMENT_NO") & ": " & getLocale("CTRL_G"), "Sheet1.GoToSegmentFunction", 51)
                Call AddTheMenuItem(myCommandBar, getLocale("SETTINGS"), "sheet1.SetupOptionsShow", 548)
                Call AddTheMenuItem(myCommandBar, getLocale("PRINT"), "sheet1.DoPrint", 548)
                Call AddTheMenuItem(myCommandBar, getLocale("HELP"), "DisplayPDFHelp", 548)
            End If
        Next myCommandBar
    'End If

    'make some modifications to cell right click control (to improve appearance of menu items)
    'On Error Resume Next
    'With Application.CommandBars("Cell")
    '    .Controls("&Delete...").Move Before:=5
    '    .Controls("&Delete...").BeginGroup = False
    '    .Controls("Insert Com&ment").BeginGroup = False
    'End With
    
    Debug.Print ("RemoveUnnecessaryRMenus() end")
    
End Sub
Private Sub AddTheMenuItem(myCommandBar As Office.CommandBar, caption As String, action As String, faceno As Integer)
    Dim NewControl As CommandBarButton
    
    Set NewControl = myCommandBar.Controls.Add(Type:=msoControlButton, temporary:=True)
    
    With NewControl
        .caption = caption
        .OnAction = action
        '.Picture = Application.CommandBars.GetImageMso("replace", 16, 16)
        '.FaceId = faceno
        .style = msoButtonIconAndCaption
    End With

End Sub

Public Sub RestoreCommandBars()
    Dim myCommandBar As Office.CommandBar

    On Error Resume Next
    
    For Each myCommandBar In Application.CommandBars
        myCommandBar.Enabled = True
        myCommandBar.Reset
    Next
End Sub








Attribute VB_Name = "DisplayHelp"
Option Explicit

#If Win64 Then
    Private Declare PtrSafe Function system Lib "user32" (ByVal command As String) As Long
    'Dummy define to get over 64bit compilation  problem under Windows 64bit
#Else
    Private Declare Function system Lib "libc.dylib" (ByVal command As String) As Long
#End If

Public Sub DisplayPDFHelp()
'------------------------------
'
' Display OLE PDF help, and if we cannot redirect to web page
'
'------------------------------
    Dim OS As String
    
    Dim MacOS As Boolean
    
    MacOS = False
    
    OS = Application.OperatingSystem
    
    If Left(OS, 9) = "Macintosh" Then
        MacOS = True
    End If
    
 On Error GoTo ErrHandler:
    If MacOS = True Then
        Call ShowSafariPDF
        MsgBox getLocale("PLEASE_FIND_THE_APPROPRIATE_XTM_EXCEL_EDITOR_HELP_RESOURCES_OPENED_IN_SAFARI_BROWSER")
    ElseIf Application.VERSION = "12.0" Then ' Excel 2007
        Call ShowBrowserHelp
    Else
        Dim currentRow As Long
        
        currentRow = ActiveCell.row

        'Application.EnableEvents = False
        Worksheets("data").OLEObjects(1).Activate
        'Worksheets("XTM-Editor").OLEObjects(1).Activate
        'Application.EnableEvents = True
        
        Sheet1.Activate
        'Sheet1.ActivateSegment
        
       
        Sheet1.Cells(currentRow, 4).Select
        
        RefocusTargetCell (currentRow)
        
        Debug.Print ("Exiting DisplayPDFHelp()")
    End If
    
    Exit Sub
ErrHandler:
    If MacOS = False Then
       Call ShowBrowserHelp
    End If
    
    Resume Next

End Sub
Public Sub ShowBrowserHelp()
    Dim objShell As Object
    Dim intMessage As Integer
    
    Set objShell = CreateObject("Wscript.Shell")

    intMessage = MsgBox(getLocale("DO_YOU_WANT_TO_ACCESS_HELP_FROM_THE_XTM_INTERNATIONAL_WEB_SITE"), _
            vbYesNo, getLocale("ONLINE_HELP"))

    If intMessage = vbYes Then
        objShell.Run ("http://www.xtm-intl.com/resources?f=xtm-offline-editor")
    End If

End Sub


Sub ShowSafariPDF()
    Dim result As Long
    result = system("open -a Safari https://xtm-intl.com/xtm-offline-editor")
    Debug.Print str(result)
End Sub

    







Attribute VB_Name = "ExcelCheck"
Option Explicit



Public Sub CheckExcelVersion()
'------------------------------
'
' Check the version of Excel
'
'------------------------------
    Dim OS As String
    Dim MacOS As Boolean
    
    
    MacOS = IsMacOS
    
    OS = Application.OperatingSystem
    
    If MacOS = False Then

'#If VBA7 And Win64 Then
'    MsgBox "The Excel 64-bit platform is not supported by the XTM Offline-Editor: some functionality may not be available"
'#End If
        If Left(OS, 7) = "Windows" Then
            If Application.VERSION < "12.0" Then 'Excel 2007'
                MsgBox getLocale("EXCEL_2007_OR_GREATER_IS_REQUIRED")
                Call FastQuit
            End If
        Else
            MsgBox getLocale("THIS_PLATFORM_IS_NOT_SUPPORTED_BY_THE_XTM_OFFLINE_EDITOR")
        End If
    Else
'        MsgBox "The XTM Offline-Editor does not currently support the Mac platform"
'        ThisWorkbook.Save
'        ThisWorkbook.Close
'
'        Call FastQuit
        If Application.VERSION < "14.0" Then
            MsgBox getLocale("FOR_MACINTOSH_EXCEL_2011_OR_GREATER_IS_REQUIRED")
            Call FastQuit
        End If
    End If
    
'    If (Application.Workbooks.count > 1) Then 'Check that we do not have more than one workbook open
'        MsgBox "WARNING: You can only have one XTM Off-Line Editor application active at a time."
'        Call FastQuit
'    End If
    
    'If Application.Version = "15.0" Then
    '    MsgBox "You are using Excel 2013."
    'ElseIf Application.Version = "14.0" Then
    '    MsgBox "You are using Excel 2010."
    'ElseIf Application.Version = "12.0" Then
    '    MsgBox "You are using Excel 2007."
    'ElseIf Application.Version = "11.0" Then
    '    MsgBox "You are using Excel 2003."
    'ElseIf Application.Version = "10.0" Then
    '    MsgBox "You are using Excel 2002."
    'ElseIf Application.Version = "9.0" Then
    '    MsgBox "You are using Excel 2000."
    'ElseIf Application.Version = "8.0" Then
    '    MsgBox "You are using Excel 97."
    'ElseIf Application.Version = "7.0" Then
    '    MsgBox "You are using Excel 95."
    'End If
    
    
End Sub




Attribute VB_Name = "FindAndReplaceDialog"
Attribute VB_Base = "0{2FA244A5-4C83-44E1-A073-2FA47ADC6308}{0633CB01-9E91-4B07-8FF0-8B5CC8A867C3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Public searchText As String
Public replaceText As String
Public matchCase As Boolean
Public source As Boolean
Public target As Boolean
Public REPLACE As Boolean
Public replaceFind As Boolean
Public forward As Boolean
Public wrap As Boolean

Private currentRow As Long
Private currentCol As Long
    

Private Sub UserForm_Activate()
    SearchTextBox.SetFocus
    SearchTextBox.SelStart = 0
    SetupComboSearches
    
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column
    
    FindAndReplaceDialog.caption = getLocale("FIND")
    Label1.caption = getLocale("FIND_WHAT") & ":"
    Label2.caption = getLocale("REPLACE_WITH") & ":"
    MatchCaseOption.caption = getLocale("MATCH_CASE")
    SearchSource.caption = getLocale("SEARCH_SOURCE")
    SearchTarget.caption = getLocale("SEARCH_TARGET")
    WrapSearch.caption = getLocale("WRAP_SEARCH")
    SearchForward.caption = getLocale("SEARCH_FORWARD")
    SearchBackward.caption = getLocale("SEARCH_BACKWARD")
    FindButton.caption = getLocale("FIND_NEXT")
    ReplaceFindButton.caption = getLocale("REPLACE_FIND")
    ReplaceButton.caption = getLocale("REPLACE")
    ReplaceAllButton.caption = getLocale("REPLACE_ALL")
    CloseButton.caption = getLocale("CLOSE")
    
End Sub

Private Sub SetupComboSearches()
    Call SetupCombo(SearchTextBox, SEARCH_COL)
    Call SetupCombo(ReplaceTextBox, REPLACE_COL)
End Sub

Private Sub StoreComboSearches()
    Call StoreCombo(SearchTextBox, SEARCH_COL)
    Call StoreCombo(ReplaceTextBox, REPLACE_COL)
End Sub


Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call ClearUp
    
    'If CloseMode = 0 Then Cancel = True

End Sub

Private Sub CheckBox1_Click()

End Sub

Private Sub CloseButton_Click()
    Call ClearUp
End Sub


Private Sub FindButton_Click()
    Call SetValues
    
    Call Sheet1.FindText
End Sub
Private Sub SetValues()
'---------------------------
'
' Set up all of the form values
'
'---------------------------

    If (SearchTarget.Enabled = True) Then
        target = True
    Else
        target = False
    End If
    
    If (SearchSource.Value = True) Then
        source = True
    Else
        source = False
    End If
    
    If (MatchCaseOption.Value = True) Then
        matchCase = True
    Else
        matchCase = False
    End If
    
    If (SearchForward.Value = True) Then
        forward = True
    Else
        forward = False
    End If
    
    If (WrapSearch.Value = True) Then
        wrap = True
    Else
        wrap = False
    End If
    
    replaceText = ReplaceTextBox.text

    searchText = SearchTextBox.text
    
    If (replaceText <> Empty) Then
        Call Add2ComboBox(ReplaceTextBox, replaceText)
        
    End If
    
    If (searchText <> Empty) Then
        Call Add2ComboBox(SearchTextBox, searchText)
    End If
    
    If (matchCase = False) Then
        searchText = LCase(searchText)
    End If
    
    REPLACE = False
    replaceFind = False
    
    Sheet1.finding = True
    
End Sub

Private Sub MatchCaseOption_Click()
    matchCase = MatchCaseOption.Enabled
End Sub

Private Sub ReplaceAllButton_Click()

    Call SetValues
    
    If (source = True) Then
        MsgBox ("You can only replace values in the target segments")
    Else
        Call Sheet1.ReplaceAllText
    End If
    
End Sub

Private Sub ReplaceButton_Click()
    Call SetValues
    
    REPLACE = True
    
    If (source = True) Then
        MsgBox ("You can only replace values in the target segments")
    Else
        Call Sheet1.ReplaceFindText
    End If
        
End Sub

Private Sub ReplaceFindButton_Click()
    Call SetValues
    
    REPLACE = True
    replaceFind = True
    
    If (source = True) Then
        MsgBox ("You can only replace values in the target segments")
    Else
        Call Sheet1.ReplaceFindText
    End If
    
    replaceFind = False
        
End Sub

Private Sub SearchBackward_Click()
    forward = False
End Sub

Private Sub SearchForward_Click()
    forward = True
End Sub

Private Sub SearchSource_Click()
    source = True
End Sub

Private Sub SearchTarget_Click()
    target = True
End Sub

Private Sub WrapSearch_Click()
    wrap = True
End Sub
Private Sub ClearUp()
    Hide
    Call StoreComboSearches
    
    Sheet1.finding = False
    Cells(currentRow, 2).Select
    DoEvents
    Cells(currentRow, currentCol).Select
    
End Sub






Attribute VB_Name = "KeyboardHandler"
Option Explicit

Const vbKeyBack = 8
Const vbKeyTab = 9
Const vbKeyClear = 12
Const vbKeyReturn = 13
Const vbKeyShift = 16
Const vbKeyControl = 17
Const vbKeyMenu = 18
Const vbKeyPause = 19
Const vbKeyCapital = 20
Const vbKeyEscape = 27
Const vbKeySpace = 32
Const vbKeyPageUp = 33
Const vbKeyPageDown = 34
Const vbKeyEnd = 35
Const vbKeyHome = 36
Const vbKeyLeft = 37
Const vbKeyUp = 38
Const vbKeyRight = 39
Const vbKeyDown = 40
Const vbKeySelect = 41
Const vbKeyPrint = 42
Const vbKeyExecute = 43
Const vbKeySnapshot = 44
Const vbKeyInsert = 45
Const vbKeyDelete = 46
Const vbKeyHelp = 47
Const vbKeyF = 70
Const vbKeyG = 71
Const vbKeyH = 72
Const vbKeyZ = 90
Const vbKeyAlt = 91
Const vbKeyNumlock = 144
Const vbKeyF1 = 112
Const vbKeyF2 = 113
Const vbKeyF3 = 114
Const vbKeyF4 = 115
Const vbKeyF5 = 116
Const vbKeyF6 = 117
Const vbKeyF7 = 118
Const vbKeyF8 = 119
Const vbKeyF9 = 120
Const vbKeyF10 = 121
Const vbKeyF11 = 122
Const vbKeyF12 = 123
Const vbKeyF13 = 124
Const vbKeyF14 = 125
Const vbKeyF15 = 126
Const vbKeyF16 = 127
Const vbKeyComma = 188
Const vbKeyDot = 190
Const vbKeyBslash = 222

Private Type POINTAPI
    x As Long
    y As Long
End Type


#If Win64 Then
Private Type MSG
    hWnd As LongPtr
    message As LongPtr
    wParam As Long
    lParam As Long
    time As Long
    pt As POINTAPI
End Type

    Private Declare PtrSafe Function WaitMessage Lib "user32" () As Long
    Private Declare PtrSafe Function TranslateMessage Lib "user32" (ByRef lpMsg As MSG) As Long
 
    Private Declare PtrSafe Function PeekMessage Lib "user32" Alias "PeekMessageA" _
        (ByRef lpMsg As MSG, ByVal hWnd As LongPtr, _
         ByVal wMsgFilterMin As Long, _
         ByVal wMsgFilterMax As Long, _
         ByVal wRemoveMsg As Long) As Long
 
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" _
        (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
 
    Private Declare PtrSafe Function PostMessage Lib "user32" Alias "PostMessageA" _
        (ByVal hWnd As LongPtr, ByVal wMsg As LongPtr, _
         ByVal wParam As Long, lParam As Any) As Long
         
    Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal vKey As Long) As Integer

#Else
Private Type MSG
    hWnd As Long
    message As Long
    wParam As Long
    lParam As Long
    time As Long
    pt As POINTAPI
End Type


    Private Declare Function WaitMessage Lib "user32" () As Long
    Private Declare Function TranslateMessage Lib "user32" (ByRef lpMsg As MSG) As Long
 
    Private Declare Function PeekMessage Lib "user32" Alias "PeekMessageA" _
        (ByRef lpMsg As MSG, ByVal hWnd As Long, _
         ByVal wMsgFilterMin As Long, _
         ByVal wMsgFilterMax As Long, _
         ByVal wRemoveMsg As Long) As Long
 
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" _
        (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
 
    Private Declare Function PostMessage Lib "user32" Alias "PostMessageA" _
        (ByVal hWnd As Long, ByVal wMsg As Long, _
         ByVal wParam As Long, lParam As Any) As Long
         
    Private Declare Function GetKeyState Lib "user32" (ByVal vKey As Long) As Integer

#End If
 
Private Const WM_KEYDOWN As Long = &H100
Private Const WM_CHAR As Long = &H102
Private Const WM_MOUSEFIRST As Long = &H200
Private Const WM_MOUSELAST As Long = &H209

Private Const WM_LBUTTONDOWN As Long = &H201
Private Const WM_RBUTTONDOWN As Long = &H204

Private Const PM_REMOVE As Long = &H1
Private Const PM_NOREMOVE As Long = &H0
Private Const PM_NOYIELD As Long = &H2
 
Private forever As Boolean
Private bCancel As Boolean

Private Const VK_SHIFT As Long = &H10
Private Const VK_CONTROL As Long = &H11
Private Const VK_MENU As Long = &H12
Private Const VK_CAPITAL As Long = &H14
Private Const VK_NUMLOCK As Long = &H90
Private Const VK_SCROLL As Long = &H91

Public Enum GetKeyStateKeyboardCodes
    gksKeyboardShift = VK_SHIFT
    gksKeyboardCtrl = VK_CONTROL
    gksKeyboardAlt = VK_MENU
    gksKeyboardCapsLock = VK_CAPITAL
    gksKeyboardNumLock = VK_NUMLOCK
    gksKeyboardScrollLock = VK_SCROLL
End Enum

Public Const RK_NULL = 0
Public Const RK_TAB = 1
Public Const RK_RET = 2
Public Const RK_CTRL_F = 3
Public Const RK_CTRL_G = 4
Public Const RK_CTRL_H = 5
Public Const RK_CTRL_END = 6
Public Const RK_CTRL_HOME = 7
Public Const RK_ESC = 8
Public Const RK_SHIFT_TAB = 9
Public Const RK_CTRL_T = 10
Public Const RK_F1 = 11
Public Const RK_CTRL_M = 12
Public Const RK_CTRL_O = 13
Public Const RK_CTRL_UP = 14
Public Const RK_CTRL_DOWN = 15
Public Const RK_CTRL_DOT = 16
Public Const RK_CTRL_COMMA = 17
Public Const RK_CTRL_E = 18
Public Const RK_CTRL_BACKSLASH = 19
Public Const RK_CTRL_P = 20
Public Const SELECTION_CHANGED = 21
Public Const RK_RIGHT_BUTTON_CLICK = 22

Public ActionDesc(22) As String


Public quit As Boolean
Public reading As Boolean

'Public currentRow As Long
'Public currentCol As Long


Public Sub QuitKeyboardHandler()
    If (reading = True) Then
        quit = True
    End If
End Sub
 
Public Function ReadKeyboardEvents(currentRow As Long, xtmLang As Integer) As Integer
'------------------------------
'
' Read and handle all keyboard input
'
'------------------------------
 
    Dim msgMessage As MSG
    Dim lHwnd As Long
    Dim ctrlPressed As Boolean
    Dim altPressed As Boolean
    
    Dim iKey As Long
    Dim last_iKey As Long
    
    forever = True
    
    Dim specialAccents As Boolean
    
    If ((xtmLang = Spanish) Or (xtmLang = French) Or (xtmLang = Dutch) Or (xtmLang = Greek)) Then
        specialAccents = True
    Else
        specialAccents = False
    End If
       
    'Application.Cursor = xlWait 'HourGlass
    Application.Cursor = xlDefault 'Back to normal
    
    Dim i As Long

    Debug.Print "Starting ReadKeyboardEvents: " & currentRow
    
    If (ActionDesc(0) = Empty) Then
        ActionDesc(0) = "RK_NULL"
        ActionDesc(1) = "RK_TAB"
        ActionDesc(2) = "RK_RET"
        ActionDesc(3) = "RK_CTRL_F"
        ActionDesc(4) = "RK_CTRL_G"
        ActionDesc(5) = "RK_CTRL_H"
        ActionDesc(6) = "RK_CTRL_END"
        ActionDesc(7) = "RK_CTRL_HOME"
        ActionDesc(8) = "RK_ESC"
        ActionDesc(9) = "RK_SHIFT_TAB"
        ActionDesc(10) = "RK_CTRL_T"
        ActionDesc(11) = "RK_F1"
        ActionDesc(12) = "RK_CTRL_M"
        ActionDesc(13) = "RK_CTRL_O"
        ActionDesc(14) = "RK_CTRL_UP"
        ActionDesc(15) = "RK_CTRL_DOWN"
        ActionDesc(16) = "RK_CTRL_DOT"
        ActionDesc(17) = "RK_CTRL_COMMA"
        ActionDesc(18) = "RK_CTRL_E"
        ActionDesc(19) = "RK_CTRL_BACKSLASH"
        ActionDesc(20) = "RK_CTRL_P"
        ActionDesc(21) = "SELECTION_CHANGED"

    End If

    'currentRow = ActiveCell.row
    'currentColumn = ActiveCell.Column
    
    'Cells(currentRow, 4).Interior.Color = RGB(150, 150, 150)

    'get the xl window handle
    lHwnd = FindWindow("XLMAIN", Application.caption)
    
    reading = True
    
    'Application.SendKeys "+{END}+{HOME}+{UP}+{UP}+{UP}+{UP}"
    'Application.SendKeys "^{HOME}^{HOME}+^{END}"
    Application.SendKeys "{F2}"
    'start loop to monitior key presses
    Do While forever
    
        If (ActiveCell.Column <> 4) Or (currentRow <> ActiveCell.row) Then
            Debug.Print "Mouse moved to different Cell: " & ActiveCell.Address
            'ReadKeyboardEvents = Sheet1.currentAction
            ReadKeyboardEvents = SELECTION_CHANGED
            currentRow = 0
            GoTo ExitFunction
        End If
    
        'wait for an input message.
        On Error GoTo Continue
        WaitMessage
        
        'check for right button click
        If PeekMessage _
            (msgMessage, lHwnd, WM_RBUTTONDOWN, WM_RBUTTONDOWN, PM_NOREMOVE) Then
            Debug.Print "PeekMessage: ReadKeyboardEvents = RIGHT_BUTTON_CLICK"
            Debug.Print "ActiveWindow.RangeFromPoint(" & msgMessage.pt.x & ", " & msgMessage.pt.y & ")"
            'Application.SendKeys "{ESCAPE}"
            'DoEvents
            'rightButtonPressed = True
            ReadKeyboardEvents = RK_RIGHT_BUTTON_CLICK
            'TestRightButtonClickSub
            'Cancel = True
            'AddComment
            'msgMessage.wParam = vbKeyEscape
            'TranslateMessage msgMessage
            Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)

            GoTo ExitFunction
        ElseIf PeekMessage _
            (msgMessage, lHwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE) Then
            TranslateMessage msgMessage
            
            iKey = msgMessage.wParam
            
            Debug.Print "iKey = " & iKey
            
            If (iKey > 31) And (iKey < 96) Then
                Debug.Print iKey & " = " & Chr(iKey)
            Else
                Debug.Print iKey
            End If
            
            'If (specialAccents = True) Then
            
            If ((iKey = 222) Or (iKey = 221) Or (iKey = 192) Or ((iKey = 186) And (xtmLang = Greek))) Then
                Debug.Print "Accent pressed"
            
                GoTo Continue
            End If
        
            If ((last_iKey = 221) Or (last_iKey = 222) Or (last_iKey = 192) Or ((last_iKey = 186) And (xtmLang = Greek))) Then
                Debug.Print "Processing accented vowel"
        
                GoTo DoLoop
            End If
            
            'End If
            
'            If ((iKey = 222) And (xtmLang = Spanish)) Then
'                Debug.Print "Spanish accute accent pressed"
'
'                GoTo Continue
'            ElseIf ((iKey = 221) And ((xtmLang = French) Or (xtmLang = Dutch))) Then
'                Debug.Print "French accute accent pressed"
'
'                GoTo Continue
'            End If
'
'            If ((last_iKey = 221) And ((xtmLang = French) Or (xtmLang = Dutch))) Then
'                Debug.Print "Processing French vowel"
'
'                GoTo DoLoop
'            End If
'
'            If ((last_iKey = 222) And (xtmLang = Spanish)) Then
'                Debug.Print "Processing Spanish vowel"
'
'                GoTo DoLoop
'            End If
            
            
            If iKey = vbKeyTab Then
                Debug.Print "{TAB} pressed"
                'Call ProcessMessage(msgMessage, lHwnd)
                ReadKeyboardEvents = RK_TAB
                
                If IsShiftKeyDown Then
                    ReadKeyboardEvents = RK_SHIFT_TAB
                End If
                'Application.SendKeys "{TAB}"
                GoTo ExitFunction
                'GoTo Continue
            ElseIf iKey = vbKeyReturn Then
                'MsgBox "{RETURN} pressed"
                ReadKeyboardEvents = RK_RET
                GoTo ExitFunction
                'GoTo Continue
            ElseIf iKey = vbKeyEscape Then
                Debug.Print "{ESCAPE} pressed"
                msgMessage.wParam = vbKeyEscape
                'TranslateMessage msgMessage
                Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                ReadKeyboardEvents = RK_ESC
                GoTo ExitFunction
                'GoTo Continue
                
            ElseIf iKey = vbKeyBack Then
                Debug.Print "{BACKSPACE} pressed"
                msgMessage.wParam = vbKeyLeft
                TranslateMessage msgMessage
                Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                msgMessage.wParam = vbKeyDelete
                TranslateMessage msgMessage
                Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                GoTo Continue
            ElseIf iKey = vbKeyDelete Then
                Debug.Print "vbKeyDelete pressed"
                TranslateMessage msgMessage
                Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                
                GoTo Continue
             ElseIf iKey = vbKeyUp Then
                Debug.Print "vbKeyUp pressed"
                If IsShiftKeyDown Then
                    Application.SendKeys "+{UP}"
                ElseIf IsControlKeyDown Then
                    Debug.Print "Ctrl+Up pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)

                    ReadKeyboardEvents = RK_CTRL_UP
                    'Application.SendKeys "^{f}"
                    GoTo ExitFunction
                    
                Else
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                End If
                
                GoTo Continue
             ElseIf iKey = vbKeyDown Then
                Debug.Print "vbKeyDown pressed"
                If IsShiftKeyDown Then
                    Application.SendKeys "+{DOWN}"
                ElseIf IsControlKeyDown Then
                    Debug.Print "Ctrl+Up pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)

                    ReadKeyboardEvents = RK_CTRL_DOWN
                    'Application.SendKeys "^{f}"
                    GoTo ExitFunction
                Else
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                End If
                
                GoTo Continue
           ElseIf iKey = vbKeyRight Then
                Debug.Print "vbKeyRight pressed"
                If IsControlKeyDown And IsShiftKeyDown Then
                    Debug.Print "IsControlKeyDown And IsShiftKeyDown"
                    Application.SendKeys "^+{RIGHT}"
                ElseIf IsControlKeyDown Then
                    Debug.Print "IsControlKeyDown"
                    Application.SendKeys "^+{RIGHT}"
                ElseIf IsShiftKeyDown Then
                    Debug.Print "IsShiftKeyDown"
                    Application.SendKeys "+{RIGHT}"
                Else
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                End If
                
                GoTo Continue
            ElseIf iKey = vbKeyLeft Then
                Debug.Print "vbKeyLeft pressed"
                If IsControlKeyDown And IsShiftKeyDown Then
                    Debug.Print "IsControlKeyDown And IsShiftKeyDown"
                    Application.SendKeys "^+{LEFT}"
                ElseIf IsControlKeyDown Then
                    Debug.Print "IsControlKeyDown"
                    Application.SendKeys "^+{LEFT}"
                ElseIf IsShiftKeyDown Then
                    Application.SendKeys "+{LEFT}"
                Else
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                End If
                
                GoTo Continue
            ElseIf iKey = vbKeyHome Then
                Debug.Print "vbKeyHome pressed"
                    
                If IsControlKeyDown Then
                    Debug.Print "Ctrl+{HOME} pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_HOME
                    GoTo ExitFunction
                
                ElseIf IsShiftKeyDown Then
                    Application.SendKeys "+{HOME}"
                Else
                    Application.SendKeys "{HOME}"
                End If
                
                GoTo Continue
            ElseIf iKey = vbKeyEnd Then
                Debug.Print "vbKeyEnd pressed"
                If IsControlKeyDown Then
                    Debug.Print "Ctrl+{END} pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_END
                    GoTo ExitFunction
                ElseIf IsShiftKeyDown Then
                    Application.SendKeys "+{END}"
                Else
                    Application.SendKeys "{END}"
                End If
                
                GoTo Continue
            ElseIf iKey = vbKeyF2 Then
                Debug.Print "{F2} pressed"
                'TranslateMessage msgMessage
                Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                GoTo Continue
            ElseIf iKey = vbKeyF1 Then
                ReadKeyboardEvents = RK_F1
                Debug.Print "{F1} pressed"
                GoTo ExitFunction
            End If
            
            If (IsControlKeyDown) Then
                If (iKey > 47) And (iKey < 59) Then 'Alt+Number
                    Dim seq As String
                    If (iKey = 48) Then
                        seq = "{{}" & Chr(iKey + 1) & Chr(iKey) & "{}}"
                    Else
                        seq = "{{}" & Chr(iKey) & "{}}"
                    End If
                    
                    Application.SendKeys (seq)
                    GoTo Continue
                    'msgMessage.wParam = Asc("{")
                    'TranslateMessage msgMessage
                    'Call PostMessage(lHwnd, msgMessage.Message, msgMessage.wParam, 0)
                    'msgMessage.wParam = Asc("9")
                    'TranslateMessage msgMessage
                    'Call PostMessage(lHwnd, msgMessage.Message, msgMessage.wParam, 0)
                    'msgMessage.wParam = Asc("}")
                    'TranslateMessage msgMessage
                    'Call PostMessage(lHwnd, msgMessage.Message, msgMessage.wParam, 0)
                ElseIf (iKey = vbKeySpace) Then 'Significant space
                    seq = "{{}" & Chr(115) & Chr(112) & "{}}"
                
                    Application.SendKeys (seq)
                    GoTo Continue
                ElseIf iKey = vbKeyF Then
                    Debug.Print "Ctrl+F pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)

                    ReadKeyboardEvents = RK_CTRL_F
                    'Application.SendKeys "^{f}"
                    GoTo ExitFunction
                ElseIf iKey = vbKeyM Then
                    Debug.Print "Ctrl+M pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)

                    ReadKeyboardEvents = RK_CTRL_M
                    'Application.SendKeys "^{f}"
                    GoTo ExitFunction
                ElseIf iKey = vbKeyO Then
                    Debug.Print "Ctrl+O pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)

                    ReadKeyboardEvents = RK_CTRL_O
                    'Application.SendKeys "^{f}"
                    GoTo ExitFunction
                ElseIf iKey = vbKeyP Then
                    Debug.Print "Ctrl+P pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)

                    ReadKeyboardEvents = RK_CTRL_P
                    'Application.SendKeys "^{f}"
                    GoTo ExitFunction
                ElseIf iKey = vbKeyA Then
                    Debug.Print "Ctrl+A pressed"
                    msgMessage.wParam = vbKeyHome
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                    msgMessage.wParam = vbKeyShift
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                    msgMessage.wParam = vbKeyEnd
                    TranslateMessage msgMessage
                    Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)
                    'Application.SendKeys "+{END}+{HOME}+{UP}+{UP}+{UP}+{UP}"
                    Application.SendKeys "^{HOME}+^{END}"
                    GoTo Continue
                ElseIf iKey = vbKeyE Then
                    Debug.Print "Ctrl+E pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_E
                    GoTo ExitFunction
 
                ElseIf iKey = vbKeyG Then
                    Debug.Print "Ctrl+G pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_G
                    GoTo ExitFunction
 
                ElseIf iKey = vbKeyH Then
                    Debug.Print "Ctrl+H pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_H
                    GoTo ExitFunction
                
                ElseIf iKey = vbKeyDot Then
                    Debug.Print "Ctrl+Dot pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_DOT
                    GoTo ExitFunction
                    
                 ElseIf iKey = vbKeyComma Then
                    Debug.Print "Ctrl+Comma pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_COMMA
                    GoTo ExitFunction
               ElseIf iKey = vbKeyBslash Then
                    Debug.Print "Ctrl+|fffd| pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_BACKSLASH
                    GoTo ExitFunction
               ElseIf (iKey = vbKeyT) Then
                    Debug.Print "Ctrl+T/RIGHT pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_T
                    GoTo ExitFunction
                
                ElseIf iKey = vbKeyC Then
                    Debug.Print "Ctrl+C pressed"
                    Application.SendKeys "^c"
                    GoTo Continue
                    
                ElseIf iKey = vbKeyX Then
                    Debug.Print "Ctrl+X pressed"
                    Application.SendKeys "^c"
                    Application.SendKeys "{Delete}"
                    GoTo Continue
                    
                ElseIf iKey = vbKeyV Then
                    Debug.Print "Ctrl+V pressed"
                    Application.SendKeys "^v"
                    GoTo Continue
                    
                ElseIf iKey = vbKeyRight Then
                    Debug.Print "Ctrl+RIGHT pressed"
                    
                    If IsShiftKeyDown Then
                        Application.SendKeys "^+{RIGHT}"
                    Else
                        Application.SendKeys "+{RIGHT}"
                    End If
                    GoTo Continue
                    
                ElseIf iKey = vbKeyLeft Then
                    Debug.Print "Ctrl+LEFT pressed"
                    
                    If IsShiftKeyDown Then
                        Application.SendKeys "^+{LEFT}"
                    Else
                        Application.SendKeys "+{LEFT}"
                    End If
                    GoTo Continue
                    
                ElseIf iKey = vbKeyEnd Then
                    Debug.Print "Ctrl+{END} pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_END
                    GoTo ExitFunction
                    
                ElseIf iKey = vbKeyHome Then
                    Debug.Print "Ctrl+{HOME} pressed"
                    Call PostLeaveSegmentMessage(msgMessage, lHwnd)
                    
                    ReadKeyboardEvents = RK_CTRL_HOME
                    GoTo ExitFunction
                    
               ElseIf iKey = vbKeyZ Then
                    With Application
                        .EnableEvents = False
                        .Undo
                        .EnableEvents = True
                     End With
                    GoTo Continue
                End If
                
                ctrlPressed = False
            End If
            
            If iKey = vbKeyControl Then
                Debug.Print "iKey = vbKeyControl"
                ctrlPressed = True
            Else
                ctrlPressed = False
            End If
            
            If iKey = vbKeyAlt Then
                Debug.Print "iKey = vbKeyAlt"
                altPressed = True
            Else
                altPressed = False
            End If
            
            Call ProcessMessage(msgMessage, lHwnd)
            'if the key pressed is a navigation or Function key implement it
            'for all other keys retrieve their ascii codes and
            'send them to our event handler
            
        'Else
        '    Debug.Print "In ELSE"
        '
        '    iKey = msgMessage.wParam
        '
        '    Debug.Print "iKey = " & iKey
            

        End If
        'Has the mouse moved
        
Continue:
        
        last_iKey = iKey
        
        DoEvents
        
        If quit Then
            GoTo ExitFunction
        End If
DoLoop:
    Loop
    
ExitFunction:
    Application.Cursor = xlDefault 'Back to normal
    'MsgBox "Exiting ReadKeyboardEvents for: " & currentRow
    'Cells(currentRow, 4).Interior.Color = RGB(255, 255, 255)
    reading = False
    quit = False
End Function

Private Sub PostLeaveSegmentMessage(msgMessage As MSG, lHwnd As Long)
'------------------------------
'
' Post exit segment edit message
'
'------------------------------
   msgMessage.wParam = vbKeyEscape
   TranslateMessage msgMessage
   Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)

End Sub
Private Sub ProcessMessage(msgMessage As MSG, lHwnd As Long)
'------------------------------
'
' Process the message
'
'------------------------------
    TranslateMessage msgMessage
    PeekMessage msgMessage, lHwnd, WM_CHAR, WM_CHAR, PM_REMOVE
    'Call PostMessage(lHwnd, msgMessage.message, msgMessage.wParam, 0)

End Sub
Private Function IsFunctionKey(KeyCode As Long) As Boolean
'------------------------------
'
' Is this a function key
'
'------------------------------
    Dim vArRet As Variant
    Dim lRet As Long
 
    vArRet = Array(vbKeyBack, vbKeyTab, vbKeyClear, vbKeyReturn, vbKeyShift, _
    vbKeyControl, vbKeyMenu, vbKeyPause, vbKeyCapital, vbKeyEscape, _
    vbKeySpace, vbKeyPageUp, vbKeyPageDown, vbKeyEnd, vbKeyHome, _
    vbKeyLeft, vbKeyUp, vbKeyRight, vbKeyDown, vbKeySelect, vbKeyPrint, _
    vbKeyExecute, vbKeySnapshot, vbKeyInsert, vbKeyDelete, vbKeyAlt, vbKeyHelp, _
    vbKeyNumlock, vbKeyF1, vbKeyF2, vbKeyF3, vbKeyF4, vbKeyF5, _
    vbKeyF6, vbKeyF7, vbKeyF8, vbKeyF9, vbKeyF10, vbKeyF11, vbKeyF12, _
    vbKeyF13, vbKeyF14, vbKeyF15, vbKeyF16)
 
    On Error Resume Next
    lRet = WorksheetFunction.Match(KeyCode, vArRet, 0)
    If Err.Number = 0 Then IsFunctionKey = True
 
End Function

Public Function IsKeyPressed(ByVal lKey As GetKeyStateKeyboardCodes) As Boolean
'------------------------------
'
' Has this key been pressed
'
'------------------------------

    Dim iResult As Integer
 
    iResult = GetKeyState(lKey)

    Select Case lKey
        Case gksKeyboardCapsLock, gksKeyboardNumLock, gksKeyboardScrollLock

        'For the three 'toggle' keys, the 1st bit says if it's
        'on or off, so clear any other bits that might be set,
        'using a binary AND
            iResult = iResult And 1
  
        Case gksKeyboardCtrl
            iResult = iResult And &H8000
 
        Case Else
        'For the other keys, the 16th bit says if it's down or
        'up, so clear any other bits that might be set, using a
        'binary AND
            iResult = iResult And &H8000
    End Select

 IsKeyPressed = (iResult <> 0)

End Function
Public Function IsCtrlPressed() As Boolean
'------------------------------
'
' Has the Ctrl key been pressed
'
'------------------------------

    If GetKeyState(VK_CONTROL) < 0 Then IsCtrlPressed = True Else IsCtrlPressed = False

End Function


















Attribute VB_Name = "KeyboardShortcuts"
Option Explicit

Public Sub DefineKeyboardShortcuts()
'------------------------------
'
' Define keyboard shortcuts, currently only Alt + down and Alt + up
'
'------------------------------
    Application.OnKey "%{DOWN}", "MoveDown"
    
    If IsMacOS Then
        Application.OnKey "{TAB}", "GoCopyTranslation"
    Else
        Application.OnKey "{TAB}", "MoveDown"
    End If
    
    Application.OnKey "{DOWN}", "MoveDownOneRow"
    Application.OnKey "{UP}", "MoveUpOneRow"
    
    Application.OnKey "^{UP}", "Sheet1.GoToPreviousIncompleteSegment" '
    Application.OnKey "^{DOWN}", "Sheet1.GoToNextIncompleteSegment"
    
    
    Application.OnKey "%{UP}", "MoveUp"
    Application.OnKey "+{TAB}", "MoveUp"
    
    Application.OnKey "^{HOME}", "GoHome"
    Application.OnKey "^{END}", "GoToLast"
    
    Application.OnKey "~", "GoCopyTranslation"
    
    Application.OnKey "{PGDN}", ""
    Application.OnKey "{PGUP}", ""
    
    'F1 Displays the Microsoft Office Excel Help task pane.
    Application.OnKey "{F1}", "DisplayPDFHelp" 'Help
    'CTRL+F1 displays or hides the Ribbon, a component of the Microsoft Office Fluent user interface.
    Application.OnKey "^{F1}", "DisplayPDFHelp"
    'ALT+F1 creates a chart of the data in the current range.
    Application.OnKey "%{F1}", "DisplayPDFHelp"
    'ALT+SHIFT+F1 inserts a new worksheet.
    Application.OnKey "+%{F1}", "DisplayPDFHelp"
    
    'Application.OnKey "{F2}", "EnterCell"
    'F2 Edits the active cell and positions the insertion point at the end of the cell contents. It also moves the insertion point into the Formula Bar when editing in a cell is turned off.
    'SHIFT+F2 adds or edits a cell comment.
    Application.OnKey "+{F2}", ""
    'CTRL+F2 displays the Print Preview window.
    Application.OnKey "^{F2}", ""
    
    'F3 Displays the Paste Name dialog box.
    Application.OnKey "{F3}", ""
    'SHIFT+F3 displays the Insert Function dialog box.
    Application.OnKey "+{F3}", ""
    
    'F4 Repeats the last command or action, if possible.
    'When a cell reference or range is selected in a formula, F4 cycles through the various combinations of absolute and relative references.
    Application.OnKey "{F4}", ""
    'CTRL+F4 closes the selected workbook window.
    Application.OnKey "^{F4}", ""
    
    'F5 Displays the Go To dialog box.
    Application.OnKey "{F5}", ""
    'CTRL+F5 restores the window size of the selected workbook window.
    Application.OnKey "^{F5}", ""
    
    'F6 Switches between the worksheet, Ribbon, task pane, and Zoom controls. In a worksheet that has been split (View menu, Manage This Window, Freeze Panes, Split Window command), F6 includes the split panes when switching between panes and the Ribbon area.
    Application.OnKey "{F6}", ""
    'SHIFT+F6 switches between the worksheet, Zoom controls, task pane, and Ribbon.
    Application.OnKey "+{F6}", ""
    'CTRL+F6 switches to the next workbook window when more than one workbook window is open.
    Application.OnKey "^{F6}", ""
    
    'F7 Displays the Spelling dialog box to check spelling in the active worksheet or selected range.
    Application.OnKey "{F7}", ""
    'CTRL+F7 performs the Move command on the workbook window when it is not maximized. Use the arrow keys to move the window, and when finished press ENTER, or ESC to cancel.
    Application.OnKey "^{F7}", ""
    
    'F8 Turns extend mode on or off. In extend mode, Extended Selection appears in the status line, and the arrow keys extend the selection.
    Application.OnKey "{F8}", ""
    'SHIFT+F8 enables you to add a nonadjacent cell or range to a selection of cells by using the arrow keys.
    Application.OnKey "+{F8}", ""
    'CTRL+F8 performs the Size command (on the Control menu for the workbook window) when a workbook is not maximized.
    Application.OnKey "^{F8}", ""
    'ALT+F8 displays the Macro dialog box to create, run, edit, or delete a macro.
    Application.OnKey "%{F8}", ""
    
    'F9 Calculates all worksheets in all open workbooks.
    Application.OnKey "{F9}", ""
    'SHIFT+F9 calculates the active worksheet.
    Application.OnKey "+{F9}", ""
    'CTRL+ALT+F9 calculates all worksheets in all open workbooks, regardless of whether they have changed since the last calculation.
    Application.OnKey "+^{F9}", ""
    'CTRL+ALT+SHIFT+F9 rechecks dependent formulas, and then calculates all cells in all open workbooks, including cells not marked as needing to be calculated.
    Application.OnKey "+^%{F9}", ""
    'CTRL+F9 minimizes a workbook window to an icon.
    Application.OnKey "^{F9}", ""
    
    'F10 Turns key tips on or off.
    Application.OnKey "{F10}", ""
    'SHIFT+F10 displays the shortcut menu for a selected item.
    Application.OnKey "+{F10}", ""
    'ALT+SHIFT+F10 displays the menu or message for a smart tag. If more than one smart tag is present, it switches to the next smart tag and displays its menu or message.
    Application.OnKey "+%{F10}", ""
    'CTRL+F10 maximizes or restores the selected workbook window.
    Application.OnKey "^{F10}", ""
    
    'F11 Creates a chart of the data in the current range.
    Application.OnKey "{F11}", ""
    'SHIFT+F11 inserts a new worksheet.
    Application.OnKey "+{F11}", ""
    'ALT+F11 opens the Microsoft Visual Basic Editor, in which you can create a macro by using Visual Basic for Applications (VBA).
    Application.OnKey "%{F11}", ""
    
    
    'CTRL+PgUp   Switches between worksheet tabs, from left-to-right.
    Application.OnKey "^{PGUP}", ""
    'CTRL+PgDn   Switches between worksheet tabs, from right-to-left.
    Application.OnKey "^{PGDN}", ""
    'CTRL+SHIFT+(    Unhides any hidden rows within the selection.
    Application.OnKey "^+{(}", ""
    'CTRL+SHIFT+)    Unhides any hidden columns within the selection.
    Application.OnKey "^+{)}", ""
    'CTRL+SHIFT+&    Applies the outline border to the selected cells.
    Application.OnKey "^+{&}", ""
    'CTRL+SHIFT_ Removes the outline border from the selected cells.
    Application.OnKey "^+{_}", ""
    'CTRL+SHIFT+~    Applies the General number format.
    Application.OnKey "^+{~}", ""
    'CTRL+SHIFT+$    Applies the Currency format with two decimal places (negative numbers in parentheses).
    Application.OnKey "^+{$}", ""
    'CTRL+SHIFT+%    Applies the Percentage format with no decimal places.
    Application.OnKey "^+{%}", ""
    'CTRL+SHIFT+^    Applies the Exponential number format with two decimal places.
    Application.OnKey "^+{^}", ""
    'CTRL+SHIFT+#    Applies the Date format with the day, month, and year.
    Application.OnKey "^+{#}", ""
    'CTRL+SHIFT+@    Applies the Time format with the hour and minute, and AM or PM.
    Application.OnKey "^+{@}", ""
    'CTRL+SHIFT+!    Applies the Number format with two decimal places, thousands separator, and minus sign (-) for negative values.
    Application.OnKey "^+{!}", ""
    'CTRL+SHIFT+*
    'Selects the current region around the active cell (the data area enclosed by blank rows and blank columns).
    'In a PivotTable, it selects the entire PivotTable report.
    Application.OnKey "^+{*}", ""
    'CTRL+SHIFT+:    Enters the current time.
    Application.OnKey "^+{:}", ""
    'CTRL SHIFT + "    Copies the value from the cell above the active cell into the cell or the Formula Bar."
    Application.OnKey "^+{""}", ""
    'CTRL+SHIFT+Plus (+) Displays the Insert dialog box to insert blank cells.
    Application.OnKey "^+{+}", ""
    'CTRL+Minus (-)  Displays the Delete dialog box to delete the selected cells.
    Application.OnKey "^{-}", ""
    'CTRL+;  Enters the current date.
    Application.OnKey "^{;}", ""
    'CTRL+`  Alternates between displaying cell values and displaying formulas in the worksheet.
    Application.OnKey "^{`}", ""
    'CTRL+'  Copies a formula from the cell above the active cell into the cell or the Formula Bar.
    Application.OnKey "^{'}", ""
    'CTRL+1  Displays the Format Cells dialog box.
    Application.OnKey "^{1}", ""
    'CTRL+2  Applies or removes bold formatting.
    Application.OnKey "^{2}", ""
    'CTRL+3  Applies or removes italic formatting.
    Application.OnKey "^{3}", ""
    'CTRL+4  Applies or removes underlining.
    Application.OnKey "^{4}", ""
    'CTRL+5  Applies or removes strikethrough.
    Application.OnKey "^{5}", ""
    'CTRL+6  Alternates between hiding objects, displaying objects, and displaying placeholders for objects.
    Application.OnKey "^{6}", ""
    'CTRL+8  Displays or hides the outline symbols.
    Application.OnKey "^{8}", ""
    'CTRL+9  Hides the selected rows.
    Application.OnKey "^{5}", ""
    'CTRL+0  Hides the selected columns.
    'Application.OnKey "^{0}", "" - Does not like this
    'CTRL A
    'Selects the entire worksheet.
    'If the worksheet contains data, CTRL+A selects the current region. Pressing CTRL+A a second time selects the current region and its summary rows. Pressing CTRL+A a third time selects the entire worksheet.
    'When the insertion point is to the right of a function name in a formula, displays the Function Arguments dialog box.
    Application.OnKey "^{a}", ""
    'CTRL+SHIFT+A inserts the argument names and parentheses when the insertion point is to the right of a function name in a formula.
    Application.OnKey "+^{a}", ""
    'CTRL+B  Applies or removes bold formatting.
    Application.OnKey "^{b}", ""
    'CTRL C
    'Copies the selected cells.
    'Application.OnKey "^{c}", "AddComment"
    'CTRL+C followed by another CTRL+C displays the Clipboard.
    'Application.OnKey "^{C}^{C}", "" - Does not like this
    'CTRL+D  Uses the Fill Down command to copy the contents and format of the topmost cell of a selected range into the cells below.
    Application.OnKey "^{d}", ""
    
    Application.OnKey "^{e}", "Sheet1.GoToNextSegmentWithErrors"
    'CTRL F
    'Displays the Find and Replace dialog box, with the Find tab selected.
    Application.OnKey "^{f}", "Sheet1.FindAndReplace"
    'SHIFT+F5 also displays this tab, while SHIFT+F4 repeats the last Find action.
    Application.OnKey "^{F5}", ""
    'CTRL+SHIFT+F opens the Format Cells dialog box with the Font tab selected.
    Application.OnKey "+^{f}", ""
    'CTRL G Displays the Go To dialog box.
    'F5 also displays this dialog box.
    Application.OnKey "^{g}", "Sheet1.GoToSegment"
    'CTRL+H  Displays the Find and Replace dialog box, with the Replace tab selected.
    Application.OnKey "^{h}", ""
    'CTRL+I  Applies or removes italic formatting.
    Application.OnKey "^{i}", ""
    'CTRL+K  Displays the Insert Hyperlink dialog box for new hyperlinks or the Edit Hyperlink dialog box for selected existing hyperlinks.
    Application.OnKey "^{k}", ""
    'CTRL+M
    Application.OnKey "^{m}", "AddComment"
     'CTRL+N  Creates a new, blank workbook.
    Application.OnKey "^{n}", ""
   'CTRL O
    'Displays the Open dialog box to open or find a file.
    Application.OnKey "^{o}", "Sheet1.DoConcordance"
    'CTRL+SHIFT+O selects all cells that contain comments.
    Application.OnKey "+^{o}", ""
    'CTRL P
    'Displays the Print dialog box.
    Application.OnKey "^{p}", "Sheet1.DoPrint"
    'CTRL+SHIFT+P opens the Format Cells dialog box with the Font tab selected.
    Application.OnKey "+^{p}", ""
    'CTRL+R  Uses the Fill Right command to copy the contents and format of the leftmost cell of a selected range into the cells to the right.
    Application.OnKey "^{r}", ""
    'CTRL+S  Saves the active file with its current file name, location, and file format.
    'CTRL+T  Displays the Create Table dialog box.
    Application.OnKey "^{t}", "Sheet1.CopySource2Target"
    'CTRL U
    'Applies or removes underlining.
    Application.OnKey "^{u}", ""
    'CTRL+SHIFT+U switches between expanding and collapsing of the formula bar.
    Application.OnKey "+^{u}", ""
    'CTRL V
    'Inserts the contents of the Clipboard at the insertion point and replaces any selection. Available only after you have cut or copied an object, text, or cell contents.
    'CTRL+ALT+V displays the Paste Special dialog box. Available only after you have cut or copied an object, text, or cell contents on a worksheet or in another program.
    'CTRL+W  Closes the selected workbook window.
    Application.OnKey "^{w}", ""
    'CTRL+X  Cuts the selected cells.
    'Application.OnKey "^{X}", ""
    'CTRL+Y  Repeats the last command or action, if possible.
    Application.OnKey "^{y}", ""
    
    
    
    Application.OnKey "^{.}", "Sheet1.GoToNextSegmentWithComment"
    Application.OnKey "^{,}", "Sheet1.GoToPreviousSegmentWithComment"
    Application.OnKey "^{\}", "sheet1.DoConcordance"
    
    Dim doClip As DataObject
    
    Set doClip = New DataObject
    
'    doClip.SetText "{1}"
'    doClip.PutInClipboard
    
    Set doClip = Nothing

End Sub







Attribute VB_Name = "Locale"
Option Explicit
#If Win32 Or Win64 Then

 Dim localesCollection As Collection

Public Sub CheckLangCodes()
'------------------------------
'
' Check the spelling languages codes
'
'------------------------------
    Dim langCode As Integer
    
    Dim xtmLang As String
    
    xtmLang = ThisWorkbook.Sheets("XTM-Editor").Cells(7, 4)
    
    langCode = getMsoLang(xtmLang)
        
    If (langCode = msoLanguageIDNone) Then 'Lang not found, try using base language instead
    
        Dim words As Variant
    
        Dim lang As String
    
        words = Split(xtmLang, " ")
    
        lang = words(0)
        
        langCode = getMsoLang(lang) 'Try using just the first word of the language
        
        If (langCode = msoLanguageIDNone) Then

            Dim appLang As Integer
        
            appLang = Application.SpellingOptions.DictLang
        
            Dim appLangDesc As String

            appLangDesc = getLanguageDescription(appLang)
       
            MsgBox getLocale("WARNING_COULD_NOT_SET_SPELL_CHECKING_LANGUAGE_FOR") & " " & xtmLang & vbNewLine & vbNewLine & _
                getLocale("DEFAULT_SPELL_CHECKING_LANGUAGE_WILL_BE_APPLIED") & ": " & appLangDesc
            Exit Sub
        End If
    End If
    
    'MsgBox ("xtmLang = " & xtmLang & " langCode = " & langCode)
    
    ThisWorkbook.Sheets("XTM-Editor").langCode = langCode
    
        
    Application.SpellingOptions.DictLang = langCode
    
'    appLang = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
'
'    If ((ThisWorkbook.Sheets("data").Cells(1, SPELL_LANG_WARNING) = Empty) And (langCode <> appLang)) Then
'        Dim xtmLangDesc As String
'        Dim appLangDesc As String
'
'        xtmLangDesc = getLanguageDescription(langCode)
'        appLangDesc = getLanguageDescription(appLang)
'
'        MsgBox "Warning: your Excel installed language: " & appLangDesc & _
'        " is not the same as the target language for this file: " & xtmLangDesc & _
'        " - Spell checking may not work properly." & vbNewLine & vbNewLine & _
'        "Please make sure that you install and set " & xtmLangDesc & _
'        " as the default language for Excel.", _
'        vbOKOnly, "Spell Check Language Warning"
'
'        ThisWorkbook.Sheets("data").Cells(1, SPELL_LANG_WARNING) = langCode
'    End If

End Sub

Public Sub InitLocales()
'------------------------------
'
' Initialization of locales collection
'
'------------------------------
Dim col As Integer
col = 27 'column AA

    Set localesCollection = New Collection
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(1, col), "GO_TO"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(2, col), "REQUIRES_MICROSOFT_EXCEL_2007_OR_NEWER"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(3, col), "FINISHED_SPELL_CHECKING_ALL_TARGET_SEGMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(4, col), "GO_TO_PREVIOUS_INCOMPLETE_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(5, col), "NO_PREVIOUS_INCOMPLETE_SEGMENT_FOUND"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(6, col), "GO_TO_NEXT_INCOMPLETE_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(7, col), "NO_NEXT_INCOMPLETE_SEGMENT_FOUND"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(8, col), "ADD_TRANSLATION_COMMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(9, col), "GO_TO_PREVIOUS_SEGMENT_WITH_COMMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(10, col), "NO_PREVIOUS_SEGMENT_WITH_COMMENTS_FOUND"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(11, col), "GO_TO_NEXT_SEGMENT_WITH_COMMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(12, col), "NO_NEXT_SEGMENT_WITH_COMMENTS_FOUND"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(13, col), "GO_TO_NEXT_SEGMENT_WITH_ERRORS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(14, col), "NO_SEGMENT_WITH_ERRORS_FOUND"
    'FindAndReplaceDialog
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(15, col), "FIND_WHAT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(16, col), "REPLACE_WITH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(17, col), "MATCH_CASE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(18, col), "SEARCH_SOURCE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(19, col), "SEARCH_TARGET"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(20, col), "WRAP_SEARCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(21, col), "SEARCH_FORWARD"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(22, col), "SEARCH_BACKWARD"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(23, col), "FIND_NEXT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(24, col), "REPLACE_FIND"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(25, col), "REPLACE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(26, col), "REPLACE_ALL"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(27, col), "CLOSE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(28, col), "FIND"
    'AddCommentModule
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(29, col), "INVALID_COMMENT_CELL"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(30, col), "TRANSLATOR_COMMENTS_CAN_ONLY_BE_ADDED_TO_TARGET_LANGUAGE_SEGMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(31, col), "CANNOT_ADD_COMMENTS_TO_A_MERGED_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(32, col), "ORIGINAL_COMMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(33, col), "PLEASE_ENTER_YOUR_COMMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(34, col), "EXISTING_COMMENTS"
    'SetupOptions form
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(35, col), "AUTO_SPELL_CHECK_EACH_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(36, col), "DISPLAY_ALL_COMMENTS_IN_ACTIVE_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(37, col), "SIMPLE_VIEW"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(38, col), "SETTINGS"
    'Concordance form
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(39, col), "CONCORDANCE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(40, col), "TERM"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(41, col), "SOURCE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(42, col), "TARGET"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(43, col), "SEARCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(44, col), "NEXT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(45, col), "RESULTS"
    'SegmentNo form
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(46, col), "GO_TO_SEGMENT_NO"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(47, col), "GO_TO_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(48, col), "GO"
    'ShowTIP form
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(49, col), "TIP"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(50, col), "YOU_CAN_USE_THE_TAB_KEY_TO_MOVE_TO_THE_NEXT_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(51, col), "TIP_DESC"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(52, col), "DO_NOT_SHOW_THE_MESSAGE_AGAIN"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(53, col), "OK"
    'All Statuses
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(54, col), "TO_BE_CORRECTED_ICE_MATCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(55, col), "REVIEWED_ICE_MATCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(56, col), "REVISED_ICE_MATCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(57, col), "TO_BE_REVISED_ICE_MATCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(58, col), "CHANGE_SEGMENT_STATUS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(59, col), "REVISED_MATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(60, col), "TO_BE_CORRECTED_MATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(61, col), "REVISED_NON_TRANSLATABLE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(62, col), "TO_BE_TRANSLATED_MATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(63, col), "TO_BE_REVISED_MATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(64, col), "TO_BE_CHECKED_MATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(65, col), "TO_BE_CORRECTED_NON_TRANSLATABLE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(66, col), "TO_BE_TRANSLATED_NON_TRANSLATABLE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(67, col), "TO_BE_CHECKED_NON_TRANSLATABLE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(68, col), "TRANSLATED_UNMATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(69, col), "REVISED_UNMATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(70, col), "TO_BE_CORRECTED_UNMATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(71, col), "TO_BE_TRANSLATED_UNMATCHED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(72, col), "TRANSLATED_NON_TRANSLATABLE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(73, col), "TO_BE_REVISED_UNMATCHED"
    'CustomiseMenus
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(74, col), "PICK_FROM_DROPDOWN_LIST"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(75, col), "ADD_WATCH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(76, col), "CREATE_LIST"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(77, col), "HYPERLINK"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(78, col), "LOOK_UP"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(79, col), "CUT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(80, col), "CLEAR_CONTENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(81, col), "FORMAT_CELLS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(82, col), "SORT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(83, col), "FILTER"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(84, col), "NAME_A_RANGE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(85, col), "INSERT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(86, col), "DELETE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(87, col), "INSERT_COMMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(88, col), "DEFINE_NAME"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(89, col), "COPY"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(90, col), "PASTE_OPTIONS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(91, col), "PASTE_SPECIAL"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(92, col), "DELETE_COMMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(93, col), "HIDE_COMMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(94, col), "SHOW_HIDE_COMMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(95, col), "SPELLCHECK_ALL_SEGMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(96, col), "CTRL_BACKSLASH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(97, col), "PREVIOUS_INCOMPLETE_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(98, col), "NEXT_INCOMPLETE_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(99, col), "PREVIOUS_SEGMENT_WITH_COMMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(100, col), "NEXT_SEGMENT_WITH_COMMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(101, col), "NEXT_SEGMENT_WITH_ERRORS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(102, col), "FIND_AND_REPLACE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(103, col), "CTRL_G"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(104, col), "PRINT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(105, col), "HELP"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(106, col), "CTRL_M"
    'DisplayHelp
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(107, col), "PLEASE_FIND_THE_APPROPRIATE_XTM_EXCEL_EDITOR_HELP_RESOURCES_OPENED_IN_SAFARI_BROWSER"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(108, col), "DO_YOU_WANT_TO_ACCESS_HELP_FROM_THE_XTM_INTERNATIONAL_WEB_SITE"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(109, col), "ONLINE_HELP"
    'ExcelCheck
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(110, col), "EXCEL_2007_OR_GREATER_IS_REQUIRED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(111, col), "THIS_PLATFORM_IS_NOT_SUPPORTED_BY_THE_XTM_OFFLINE_EDITOR"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(112, col), "FOR_MACINTOSH_EXCEL_2011_OR_GREATER_IS_REQUIRED"
    'Locale
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(113, col), "WARNING_COULD_NOT_SET_SPELL_CHECKING_LANGUAGE_FOR"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(114, col), "DEFAULT_SPELL_CHECKING_LANGUAGE_WILL_BE_APPLIED"
    'ScreenSize
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(115, col), "PLEASE_REOPEN_THE_XTM_OFFLINE_EDITOR_BY_DOUBLE_CLICKING_ON_THE_DOWNLOADED_FILE"
    'Sundry
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(116, col), "YOU_CANNOT_CHANGE_CELL_CONTENTS_IN_THE_REVIEW_STEP"
    'Sheet1(XTM-Editor)
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(117, col), "THIS_SEGMENT_HAS_INLINE_ERRORS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(118, col), "PLEASE_CORRECT_THESE_FIRST"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(119, col), "EMPTY_TARGET_TEXT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(120, col), "YOU_CANNOT_CHANGE_STATUS_FOR_MERGED_SEGMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(121, col), "WARNING_TARGET_TEXT_FOR_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(122, col), "IS_EMPTY"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(123, col), "IS_NOT_REQUIRED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(124, col), "IS_MISSING"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(125, col), "OVERLAPS_WITH"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(126, col), "SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(127, col), "HAS_THE_FOLLOWING_INLINE_ERRORS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(128, col), "INLINE_ERROR"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(129, col), "DO_YOU_REALLY_WANT_TO_OVERWRITE_THE_EXISTING_TARGET_TEXT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(130, col), "WARNING"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(131, col), "REPLACED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(132, col), "INSTANCES_OF"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(133, col), "STRING"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(134, col), "NOT_FOUND_IN_THE_CURRENT_TARGET_SEGMENT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(135, col), "NOT_FOUND"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(136, col), "CANNOT_CHANGE_TEXT_IN_LOCKED_ICE_MATCH_SEGMENTS"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(137, col), "DO_YOU_WANT_TO_OVERWRITE_THE_TARGET_WITH_THE_SOURCE_TEXT"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(138, col), "CHANGE_STATUS_FOR_ICE_MATCHES_IS_BLOCKED_FOR_THIS_PROJECT"
    'CommonConst
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(139, col), "LAST_MODIFIED"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(140, col), "COMMENT_STR"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(141, col), "VERSION"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(142, col), "BY"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(143, col), "DATE_COLLON"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(144, col), "CHANGED_FROM"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(145, col), "LC_TO"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(146, col), "LC_BY"
    localesCollection.Add ThisWorkbook.Sheets("data").Cells(147, col), "LC_DATE"
  
End Sub


Public Sub LoadStartLocales()
'------------------------------
'
' Load locales used on start screen of offline editor
'
'------------------------------
 ThisWorkbook.Sheets("XTM-Editor").Cells(4, 3) = getLocale("REQUIRES_MICROSOFT_EXCEL_2007_OR_NEWER")
 ThisWorkbook.Sheets("XTM-Editor").Cells(2, 5) = getLocale("GO_TO")

End Sub
Public Function getLocale(key As String)
'------------------------------
'
' Load particular locale from locale collection
'
'------------------------------
 getLocale = localesCollection.Item(key)

End Function

Public Function getMsoLang(xtmLang As String) As Integer
'------------------------------
'
' Given the XTM target language, work out the MS Language code
'
'------------------------------
    
    Dim langNo As Integer
    
    langNo = msoLanguageIDNone
    
    ThisWorkbook.Sheets("XTM-Editor").xtmLang = OtherLang
    
    Select Case xtmLang
        Case "Afrikaans (South Africa)"
            langNo = msoLanguageIDAfrikaans
        Case "Arabic"
            langNo = msoLanguageIDArabic
        Case "Arabic (United Arab Emirates)"
            langNo = msoLanguageIDArabicUAE
        Case "Arabic (Bahrain)"
            langNo = msoLanguageIDArabicBahrain
        Case "Arabic (Algeria)"
            langNo = msoLanguageIDArabicAlgeria
        Case "Arabic (Egypt)"
            langNo = msoLanguageIDArabicEgypt
        Case "Arabic (Western Sahara)"
            langNo = msoLanguageIDArabic
        Case "Arabic (Iraq)"
            langNo = msoLanguageIDArabicIraq
        Case "Arabic (Jordan)"
            langNo = msoLanguageIDArabicJordan
        Case "Arabic (Kuwait)"
            langNo = msoLanguageIDArabicKuwait
        Case "Arabic (Lebanon)"
            langNo = msoLanguageIDArabicLebanon
        Case "Arabic (Libya)"
            langNo = msoLanguageIDArabicLibya
        Case "Arabic (Morocco)"
            langNo = msoLanguageIDArabicMorocco
        Case "Arabic (Mauritania)"
            langNo = msoLanguageIDArabic
        Case "Arabic (Oman)"
            langNo = msoLanguageIDArabicOman
        Case "Arabic (Palestinian Territory)"
            langNo = msoLanguageIDArabicJordan
        Case "Arabic (Qatar)"
            langNo = msoLanguageIDArabicQatar
        Case "Arabic (Saudi Arabia)"
            langNo = msoLanguageIDArabic
        Case "Arabic (Sudan)"
            langNo = msoLanguageIDArabic
        Case "Arabic (Syria)"
            langNo = msoLanguageIDArabicSyria
        Case "Arabic (Chad)"
            langNo = msoLanguageIDArabic
        Case "Arabic (Tunisia)"
            langNo = msoLanguageIDArabicTunisia
        Case "Arabic (Yemen)"
            langNo = msoLanguageIDArabicYemen
        Case "Armenian"
            langNo = msoLanguageIDArmenian
        Case "Armenian (Eastern)"
            langNo = msoLanguageIDArmenian
        Case "Armenian (Western)"
            langNo = msoLanguageIDArmenian
        Case "Assamese"
            langNo = msoLanguageIDAssamese
        Case "Asturian (Spain)"
            langNo = msoLanguageIDSpanish
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Azeri (Cyrillic - Azerbaijan)"
            langNo = msoLanguageIDAzeriCyrillic
        Case "Azeri (Latin - Azerbaijan)"
            langNo = msoLanguageIDAzeriLatin
        Case "Bosnian (Cyrillic)"
            langNo = msoLanguageIDSerbianCyrillic
        Case "Bosnian (Latin)"
            langNo = msoLanguageIDSerbianLatin
        Case "Burmese"
            langNo = msoLanguageIDBurmese
        Case "Byelorussian"
            langNo = msoLanguageIDByelorussian
        Case "Catalan (Spain)"
            langNo = msoLanguageIDCatalan
        Case "Chinese (Simplified)"
            langNo = msoLanguageIDSimplifiedChinese
        Case "Chinese (Traditional)"
            langNo = msoLanguageIDTraditionalChinese
'        Case "Chinese (Hong Kong)" commented out - causes VBA error in Mac Excel 2016
'            langNo = msoLanguageIDChineseHongKong
        Case "Croatian"
            langNo = msoLanguageIDCroatian
        Case "Czech"
            langNo = msoLanguageIDCzech
        Case "Basque"
            langNo = msoLanguageIDBasque
        Case "Bengali"
            langNo = msoLanguageIDBengali
        Case "Bulgarian"
            langNo = msoLanguageIDBulgarian
        Case "Catalan"
            langNo = msoLanguageIDCatalan
        Case "Danish"
            langNo = msoLanguageIDDanish
        Case "Dutch"
            langNo = msoLanguageIDDutch
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Dutch
        Case "English (USA)"
            langNo = msoLanguageIDEnglishUS
        Case "English (UK)"
            langNo = msoLanguageIDEnglishUK
        Case "English (Asia)"
            langNo = msoLanguageIDEnglishPhilippines
        Case "English (Canada)"
            langNo = msoLanguageIDEnglishCanadian
        Case "English (Australia)"
            langNo = msoLanguageIDEnglishAUS
        Case "English (South Africa)"
            langNo = msoLanguageIDEnglishSouthAfrica
        Case "English (Hong Kong)"
            langNo = msoLanguageIDEnglishAUS
        Case "English (India)"
            langNo = msoLanguageIDEnglishUK
        Case "English (Ireland)"
            langNo = msoLanguageIDEnglishIreland
        Case "English (Singapore)"
            langNo = msoLanguageIDEnglishUK
        Case "English (United Arab Emirates)"
            langNo = msoLanguageIDEnglishUK
        Case "Estonian"
            langNo = msoLanguageIDEstonian
        Case "Faroese (Faroe Islands)"
            langNo = msoLanguageIDFaeroese
        Case "Finnish"
            langNo = msoLanguageIDFinnish
        Case "Dutch (Belgium)"
            langNo = msoLanguageIDBelgianDutch
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Dutch
        Case "French"
            langNo = msoLanguageIDFrench
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = French
        Case "French (Belgium)"
            langNo = msoLanguageIDBelgianFrench
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = French
        Case "French (Canada)"
            langNo = msoLanguageIDFrenchCanadian
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = French
        Case "French (Luxembourg)"
            langNo = msoLanguageIDFrenchLuxembourg
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = French
        Case "French (Switzerland)"
            langNo = msoLanguageIDSwissFrench
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = French
        Case "Frisian"
            langNo = msoLanguageIDFrisianNetherlands
        Case "Galician (Spain)"
            langNo = msoLanguageIDGalician
        Case "Georgian"
            langNo = msoLanguageIDGeorgian
        Case "German (Germany)"
            langNo = msoLanguageIDGerman
        Case "German (Belgium)"
            langNo = msoLanguageIDGerman
        Case "German (Austria)"
            langNo = msoLanguageIDGermanAustria
        Case "German (Switzerland)"
            langNo = msoLanguageIDSwissGerman
        Case "German (Luxembourg)"
            langNo = msoLanguageIDGermanLuxembourg
        Case "Greek"
            langNo = msoLanguageIDGreek
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Greek
        Case "Gujarati"
            langNo = msoLanguageIDGujarati
        Case "Hausa"
            langNo = msoLanguageIDHausa
        Case "Hebrew"
            langNo = msoLanguageIDHebrew
        Case "Hindi"
            langNo = msoLanguageIDHindi
        Case "Hungarian"
            langNo = msoLanguageIDHungarian
        Case "Icelandic"
            langNo = msoLanguageIDIcelandic
        Case "Igbo"
            langNo = msoLanguageIDIgbo
        Case "Indonesian"
            langNo = msoLanguageIDIndonesian
        Case "Inuktitut"
            langNo = msoLanguageIDInuktitut
        Case "Irish"
            langNo = msoLanguageIDGaelicIreland
        Case "Italian"
            langNo = msoLanguageIDItalian
        Case "Italian (Switzerland)"
            langNo = msoLanguageIDSwissItalian
        Case "Japanese"
            langNo = msoLanguageIDJapanese
        Case "Kashmiri"
            langNo = msoLanguageIDKashmiri
        Case "Kazakh"
            langNo = msoLanguageIDKazakh
        Case "Kirghiz"
            langNo = msoLanguageIDKirghiz
        Case "Kiswahili (Africa)"
            langNo = msoLanguageIDSwahili
        Case "Khmer"
            langNo = msoLanguageIDKhmer
        Case "Kannada"
            langNo = msoLanguageIDKannada
        Case "Konkani (India)"
            langNo = msoLanguageIDKonkani
        Case "Korean"
            langNo = msoLanguageIDKorean
        Case "Laothian"
            langNo = msoLanguageIDLao
        Case "Latvian"
            langNo = msoLanguageIDLatvian
        Case "Lithuanian"
            langNo = msoLanguageIDLithuanian
        Case "Macedonian"
            langNo = msoLanguageIDMacedonian
        Case "Malayalam (India)"
            langNo = msoLanguageIDMalayalam
        Case "Maltese"
            langNo = msoLanguageIDMaltese
        Case "Marathi"
            langNo = msoLanguageIDMarathi
        Case "Mongolian"
            langNo = msoLanguageIDMongolian
        Case "Montenegrin"
            langNo = msoLanguageIDSerbianLatin
        Case "Moldavian"
            langNo = msoLanguageIDRomanianMoldova
        Case "Nepali"
            langNo = msoLanguageIDNepali
        Case "Norwegian"
            langNo = msoLanguageIDNorwegianBokmol
        Case "Norwegian Bokmaal"
            langNo = msoLanguageIDNorwegianBokmol
        Case "Norwegian Nynorsk"
            langNo = msoLanguageIDNorwegianNynorsk
        Case "Oriya"
            langNo = msoLanguageIDOriya
        Case "Oromo"
            langNo = msoLanguageIDOromo
        Case "Pashto"
            langNo = msoLanguageIDPashto
        Case "Persian"
            langNo = msoLanguageIDFarsi
        Case "Polish"
            langNo = msoLanguageIDPolish
        Case "Portuguese"
            langNo = msoLanguageIDPortuguese
        Case "Portuguese (Brazil)"
            langNo = msoLanguageIDBrazilianPortuguese
        Case "Punjabi"
            langNo = msoLanguageIDPunjabi
        Case "Punjabi (India)"
            langNo = msoLanguageIDPunjabi
        Case "Punjabi (Pakistan)"
            langNo = msoLanguageIDPunjabi
        Case "Quechua"
            langNo = msoLanguageIDQuechuaPeru
        Case "Rhaeto-Romance"
            langNo = msoLanguageIDRhaetoRomanic
        Case "Romanian"
            langNo = msoLanguageIDRomanian
        Case "Russian"
            langNo = msoLanguageIDRussian
        Case "Scottish Gaelic"
            langNo = msoLanguageIDGaelicScotland
        Case "Sesotho"
            langNo = msoLanguageIDSesotho
        Case "Serbian"
            langNo = msoLanguageIDSerbianCyrillic
        Case "Serbian (Cyrillic)"
            langNo = msoLanguageIDSerbianCyrillic
        Case "Serbian - Montenegro (Cyrillic)"
            langNo = msoLanguageIDSerbianCyrillic
        Case "Serbian - Montenegro (Latin)"
            langNo = msoLanguageIDSerbianLatin
        Case "Serbian - Serbia (Latin)"
            langNo = msoLanguageIDSerbianLatin
        Case "Sindhi"
            langNo = msoLanguageIDSindhi
        Case "Singhalese"
            langNo = msoLanguageIDSinhalese
        Case "Slovak"
            langNo = msoLanguageIDSlovak
        Case "Slovenian"
            langNo = msoLanguageIDSlovenian
        Case "Somali"
            langNo = msoLanguageIDSomali
        Case "Sorbian (Lower)"
            langNo = msoLanguageIDSorbian
        Case "Sorbian (Upper)"
            langNo = msoLanguageIDSorbian
        Case "Spanish"
            langNo = msoLanguageIDSpanish
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Argentina)"
            langNo = msoLanguageIDSpanishArgentina
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Bolivia)"
            langNo = msoLanguageIDSpanishBolivia
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Chile)"
            langNo = msoLanguageIDSpanishChile
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Colombia)"
            langNo = msoLanguageIDSpanishColombia
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Costa Rica)"
            langNo = msoLanguageIDSpanishCostaRica
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Cuba)"
            langNo = msoLanguageIDSpanishCostaRica
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Dominican Republic)"
            langNo = msoLanguageIDSpanishDominicanRepublic
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Ecuador)"
            langNo = msoLanguageIDSpanishEcuador
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (El Salvador)"
            langNo = msoLanguageIDSpanishElSalvador
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Guatemala)"
            langNo = msoLanguageIDSpanishGuatemala
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Honduras)"
            langNo = msoLanguageIDSpanishHonduras
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Latin America)"
            langNo = msoLanguageIDSpanishChile
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Mexico)"
            langNo = msoLanguageIDMexicanSpanish
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Nicaragua)"
            langNo = msoLanguageIDSpanishNicaragua
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Panama)"
            langNo = msoLanguageIDSpanishPanama
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Paraguay)"
            langNo = msoLanguageIDSpanishParaguay
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Peru)"
            langNo = msoLanguageIDSpanishPeru
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Puerto Rico)"
            langNo = msoLanguageIDSpanishPuertoRico
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Uruguay)"
            langNo = msoLanguageIDSpanishUruguay
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (USA)"
            langNo = msoLanguageIDMexicanSpanish
            ThisWorkbook.Sheets("XTM-Editor").xtmLang = Spanish
        Case "Spanish (Venezuela)"
            langNo = msoLanguageIDSpanishVenezuela
        Case "Swahili (Somalia)"
            langNo = msoLanguageIDSwahili
        Case "Swahili (Tanzania)"
            langNo = msoLanguageIDSwahili
        Case "Swahili (Uganda)"
            langNo = msoLanguageIDSwahili
        Case "Swedish"
            langNo = msoLanguageIDSwedish
        Case "Sudanese Arabic"
            langNo = msoLanguageIDArabicEgypt
        Case "Syriac"
            langNo = msoLanguageIDSyriac
        Case "Tagalog"
            langNo = msoLanguageIDFilipino
        Case "Tajik"
            langNo = msoLanguageIDTajik
        Case "Tamil"
            langNo = msoLanguageIDTamil
        Case "Tatar"
            langNo = msoLanguageIDTatar
        Case "Telugu"
            langNo = msoLanguageIDTelugu
        Case "Thai"
            langNo = msoLanguageIDThai
        Case "Tibetan"
            langNo = msoLanguageIDTibetan
        Case "Tigrinya"
            langNo = msoLanguageIDTigrignaEthiopic
        Case "Tonga"
            langNo = msoLanguageIDTsonga
        Case "Tsonga"
            langNo = msoLanguageIDTsonga
        Case "Tswana"
            langNo = msoLanguageIDTswana
        Case "Turkish"
            langNo = msoLanguageIDTurkish
        Case "Turkmen"
            langNo = msoLanguageIDTurkmen
        Case "Ukrainian"
            langNo = msoLanguageIDUkrainian
        Case "Urdu"
            langNo = msoLanguageIDUrdu
        Case "Uzbek (Cyrillic)"
            langNo = msoLanguageIDUzbekCyrillic
        Case "Uzbek (Latin)"
            langNo = msoLanguageIDUzbekLatin
        Case "Welsh"
            langNo = msoLanguageIDWelsh
        Case "Vietnamese"
            langNo = msoLanguageIDVietnamese
        Case "Xhosa (South Africa)"
            langNo = msoLanguageIDXhosa
        Case "Yiddish"
            langNo = msoLanguageIDYiddish
        Case "Yiddish (Israel)"
            langNo = msoLanguageIDYiddish
        Case "Yoruba"
            langNo = msoLanguageIDYoruba
        Case "Zulu (Africa)"
            langNo = msoLanguageIDZulu
    End Select

    getMsoLang = langNo

End Function

Public Function getLanguageDescription(langCode As Integer) As String
'------------------------------
'
' Given the MS language code, work out the description
'
'------------------------------

    Dim langDesc As String
    
    Select Case langCode
        Case msoLanguageIDAfrikaans
            langDesc = "Afrikaans (South Africa)"
        Case msoLanguageIDArabic
            langDesc = "Arabic"
        Case msoLanguageIDArabicUAE
            langDesc = "Arabic (United Arab Emirates)"
        Case msoLanguageIDArabicBahrain
            langDesc = "Arabic (Bahrain)"
        Case msoLanguageIDArabicAlgeria
            langDesc = "Arabic (Algeria)"
        Case msoLanguageIDArabicEgypt
            langDesc = "Arabic (Egypt)"
        Case msoLanguageIDArabic
            langDesc = "Arabic (Western Sahara)"
        Case msoLanguageIDArabicIraq
            langDesc = "Arabic (Iraq)"
        Case msoLanguageIDArabicJordan
            langDesc = "Arabic (Jordan)"
        Case msoLanguageIDArabicKuwait
            langDesc = "Arabic (Kuwait)"
        Case msoLanguageIDArabicLebanon
            langDesc = "Arabic (Lebanon)"
        Case msoLanguageIDArabicLibya
            langDesc = "Arabic (Libya)"
        Case msoLanguageIDArabicMorocco
            langDesc = "Arabic (Morocco)"
        Case msoLanguageIDArabic
            langDesc = "Arabic (Mauritania)"
        Case msoLanguageIDArabicOman
            langDesc = "Arabic (Oman)"
        Case msoLanguageIDArabicJordan
            langDesc = "Arabic (Palestinian Territory)"
        Case msoLanguageIDArabicQatar
            langDesc = "Arabic (Qatar)"
        Case msoLanguageIDArabic
            langDesc = "Arabic (Saudi Arabia)"
        Case msoLanguageIDArabic
            langDesc = "Arabic (Sudan)"
        Case msoLanguageIDArabicSyria
            langDesc = "Arabic (Syria)"
        Case msoLanguageIDArabic
            langDesc = "Arabic (Chad)"
        Case msoLanguageIDArabicTunisia
            langDesc = "Arabic (Tunisia)"
        Case msoLanguageIDArabicYemen
            langDesc = "Arabic (Yemen)"
        Case msoLanguageIDArmenian
            langDesc = "Armenian"
        Case msoLanguageIDArmenian
            langDesc = "Armenian (Eastern)"
        Case msoLanguageIDArmenian
            langDesc = "Armenian (Western)"
        Case msoLanguageIDAssamese
            langDesc = "Assamese"
        Case msoLanguageIDSpanish
            langDesc = "Asturian (Spain)"
        Case msoLanguageIDAzeriCyrillic
            langDesc = "Azeri (Cyrillic - Azerbaijan)"
        Case msoLanguageIDAzeriLatin
            langDesc = "Azeri (Latin - Azerbaijan)"
        Case msoLanguageIDSerbianCyrillic
            langDesc = "Bosnian (Cyrillic)"
        Case msoLanguageIDSerbianLatin
            langDesc = "Bosnian (Latin)"
        Case msoLanguageIDBurmese
            langDesc = "Burmese"
        Case msoLanguageIDByelorussian
            langDesc = "Byelorussian"
        Case msoLanguageIDCatalan
            langDesc = "Catalan (Spain)"
        Case msoLanguageIDSimplifiedChinese
            langDesc = "Chinese (Simplified)"
        Case msoLanguageIDTraditionalChinese
            langDesc = "Chinese (Traditional)"
        Case msoLanguageIDChineseHongKong
            langDesc = "Chinese (Hong Kong)"
        Case msoLanguageIDCroatian
            langDesc = "Croatian"
        Case msoLanguageIDCzech
            langDesc = "Czech"
        Case msoLanguageIDBasque
            langDesc = "Basque"
        Case msoLanguageIDBengali
            langDesc = "Bengali"
        Case msoLanguageIDBulgarian
            langDesc = "Bulgarian"
        Case msoLanguageIDCatalan
            langDesc = "Catalan"
        Case msoLanguageIDDanish
            langDesc = "Danish"
        Case msoLanguageIDDutch
            langDesc = "Dutch"
        Case msoLanguageIDEnglishUS
            langDesc = "English (USA)"
        Case msoLanguageIDEnglishUK
            langDesc = "English (UK)"
        Case msoLanguageIDEnglishPhilippines
            langDesc = "English (Asia)"
        Case msoLanguageIDEnglishCanadian
            langDesc = "English (Canada)"
        Case msoLanguageIDEnglishAUS
            langDesc = "English (Australia)"
        Case msoLanguageIDEnglishSouthAfrica
            langDesc = "English (South Africa)"
        Case msoLanguageIDEnglishAUS
            langDesc = "English (Hong Kong)"
        Case msoLanguageIDEnglishUK
            langDesc = "English (India)"
        Case msoLanguageIDEnglishIreland
            langDesc = "English (Ireland)"
        Case msoLanguageIDEnglishUK
            langDesc = "English (Singapore)"
        Case msoLanguageIDEnglishUK
            langDesc = "English (United Arab Emirates)"
        Case msoLanguageIDEstonian
            langDesc = "Estonian"
        Case msoLanguageIDFaeroese
            langDesc = "Faroese (Faroe Islands)"
        Case msoLanguageIDFinnish
            langDesc = "Finnish"
        Case msoLanguageIDBelgianDutch
            langDesc = "Dutch (Belgium)"
        Case msoLanguageIDFrench
            langDesc = "French"
        Case msoLanguageIDBelgianFrench
            langDesc = "French (Belgium)"
        Case msoLanguageIDFrenchCanadian
            langDesc = "French (Canada)"
        Case msoLanguageIDFrenchLuxembourg
            langDesc = "French (Luxembourg)"
        Case msoLanguageIDSwissFrench
            langDesc = "French (Switzerland)"
        Case msoLanguageIDFrisianNetherlands
            langDesc = "Frisian"
        Case msoLanguageIDGalician
            langDesc = "Galician (Spain)"
        Case msoLanguageIDGeorgian
            langDesc = "Georgian"
        Case msoLanguageIDGerman
            langDesc = "German"
        Case msoLanguageIDGerman
            langDesc = "German (Belgium)"
        Case msoLanguageIDGermanAustria
            langDesc = "German (Austria)"
        Case msoLanguageIDSwissGerman
            langDesc = "German (Switzerland)"
        Case msoLanguageIDGermanLuxembourg
            langDesc = "German (Luxembourg)"
        Case msoLanguageIDGreek
            langDesc = "Greek"
        Case msoLanguageIDGujarati
            langDesc = "Gujarati"
        Case msoLanguageIDHausa
            langDesc = "Hausa"
        Case msoLanguageIDHebrew
            langDesc = "Hebrew"
        Case msoLanguageIDHindi
            langDesc = "Hindi"
        Case msoLanguageIDHungarian
            langDesc = "Hungarian"
        Case msoLanguageIDIcelandic
            langDesc = "Icelandic"
        Case msoLanguageIDIgbo
            langDesc = "Igbo"
        Case msoLanguageIDIndonesian
            langDesc = "Indonesian"
        Case msoLanguageIDInuktitut
            langDesc = "Inuktitut"
        Case msoLanguageIDGaelicIreland
            langDesc = "Irish"
        Case msoLanguageIDItalian
            langDesc = "Italian"
        Case msoLanguageIDSwissItalian
            langDesc = "Italian (Switzerland)"
        Case msoLanguageIDJapanese
            langDesc = "Japanese"
        Case msoLanguageIDKashmiri
            langDesc = "Kashmiri"
        Case msoLanguageIDKazakh
            langDesc = "Kazakh"
        Case msoLanguageIDKirghiz
            langDesc = "Kirghiz"
        Case msoLanguageIDSwahili
            langDesc = "Kiswahili (Africa)"
        Case msoLanguageIDKhmer
            langDesc = "Khmer"
        Case msoLanguageIDKannada
            langDesc = "Kannada"
        Case msoLanguageIDKonkani
            langDesc = "Konkani (India)"
        Case msoLanguageIDKorean
            langDesc = "Korean"
        Case msoLanguageIDLao
            langDesc = "Laothian"
        Case msoLanguageIDLatvian
            langDesc = "Latvian"
        Case msoLanguageIDLithuanian
            langDesc = "Lithuanian"
        Case msoLanguageIDMacedonian
            langDesc = "Macedonian"
        Case msoLanguageIDMalayalam
            langDesc = "Malayalam (India)"
        Case msoLanguageIDMaltese
            langDesc = "Maltese"
        Case msoLanguageIDMarathi
            langDesc = "Marathi"
        Case msoLanguageIDMongolian
            langDesc = "Mongolian"
        Case msoLanguageIDSerbianLatin
            langDesc = "Montenegrin"
        Case msoLanguageIDRomanianMoldova
            langDesc = "Moldavian"
        Case msoLanguageIDNepali
            langDesc = "Nepali"
        Case msoLanguageIDNorwegianBokmol
            langDesc = "Norwegian"
        Case msoLanguageIDNorwegianBokmol
            langDesc = "Norwegian Bokmaal"
        Case msoLanguageIDNorwegianNynorsk
            langDesc = "Norwegian Nynorsk"
        Case msoLanguageIDOriya
            langDesc = "Oriya"
        Case msoLanguageIDOromo
            langDesc = "Oromo"
        Case msoLanguageIDPashto
            langDesc = "Pashto"
        Case msoLanguageIDFarsi
            langDesc = "Persian"
        Case msoLanguageIDPolish
            langDesc = "Polish"
        Case msoLanguageIDPortuguese
            langDesc = "Portuguese"
        Case msoLanguageIDBrazilianPortuguese
            langDesc = "Portuguese (Brazil)"
        Case msoLanguageIDPunjabi
            langDesc = "Punjabi"
        Case msoLanguageIDPunjabi
            langDesc = "Punjabi (India)"
        Case msoLanguageIDPunjabi
            langDesc = "Punjabi (Pakistan)"
        Case msoLanguageIDQuechuaPeru
            langDesc = "Quechua"
        Case msoLanguageIDRhaetoRomanic
            langDesc = "Rhaeto-Romance"
        Case msoLanguageIDRomanian
            langDesc = "Romanian"
        Case msoLanguageIDRussian
            langDesc = "Russian"
        Case msoLanguageIDGaelicScotland
            langDesc = "Scottish Gaelic"
        Case msoLanguageIDSesotho
            langDesc = "Sesotho"
        Case msoLanguageIDSerbianCyrillic
            langDesc = "Serbian"
        Case msoLanguageIDSerbianCyrillic
            langDesc = "Serbian (Cyrillic)"
        Case msoLanguageIDSerbianCyrillic
            langDesc = "Serbian - Montenegro (Cyrillic)"
        Case msoLanguageIDSerbianLatin
            langDesc = "Serbian - Montenegro (Latin)"
        Case msoLanguageIDSerbianLatin
            langDesc = "Serbian - Serbia (Latin)"
        Case msoLanguageIDSindhi
            langDesc = "Sindhi"
        Case msoLanguageIDSinhalese
            langDesc = "Singhalese"
        Case msoLanguageIDSlovak
            langDesc = "Slovak"
        Case msoLanguageIDSlovenian
            langDesc = "Slovenian"
        Case msoLanguageIDSomali
            langDesc = "Somali"
        Case msoLanguageIDSorbian
            langDesc = "Sorbian (Lower)"
        Case msoLanguageIDSorbian
            langDesc = "Sorbian (Upper)"
        Case msoLanguageIDSpanish
            langDesc = "Spanish"
        Case msoLanguageIDSpanishArgentina
            langDesc = "Spanish (Argentina)"
        Case msoLanguageIDSpanishBolivia
            langDesc = "Spanish (Bolivia)"
        Case msoLanguageIDSpanishChile
            langDesc = "Spanish (Chile)"
        Case msoLanguageIDSpanishColombia
            langDesc = "Spanish (Colombia)"
        Case msoLanguageIDSpanishCostaRica
            langDesc = "Spanish (Costa Rica)"
        Case msoLanguageIDSpanishCostaRica
            langDesc = "Spanish (Cuba)"
        Case msoLanguageIDSpanishDominicanRepublic
            langDesc = "Spanish (Dominican Republic)"
        Case msoLanguageIDSpanishEcuador
            langDesc = "Spanish (Ecuador)"
        Case msoLanguageIDSpanishElSalvador
            langDesc = "Spanish (El Salvador)"
        Case msoLanguageIDSpanishGuatemala
            langDesc = "Spanish (Guatemala)"
        Case msoLanguageIDSpanishHonduras
            langDesc = "Spanish (Honduras)"
        Case msoLanguageIDSpanishChile
            langDesc = "Spanish (Latin America)"
        Case msoLanguageIDMexicanSpanish
            langDesc = "Spanish (Mexico)"
        Case msoLanguageIDSpanishNicaragua
            langDesc = "Spanish (Nicaragua)"
        Case msoLanguageIDSpanishPanama
            langDesc = "Spanish (Panama)"
        Case msoLanguageIDSpanishParaguay
            langDesc = "Spanish (Paraguay)"
        Case msoLanguageIDSpanishPeru
            langDesc = "Spanish (Peru)"
        Case msoLanguageIDSpanishPuertoRico
            langDesc = "Spanish (Puerto Rico)"
        Case msoLanguageIDSpanishUruguay
            langDesc = "Spanish (Uruguay)"
        Case msoLanguageIDMexicanSpanish
            langDesc = "Spanish (USA)"
        Case msoLanguageIDSpanishVenezuela
            langDesc = "Spanish (Venezuela)"
        Case msoLanguageIDSwahili
            langDesc = "Swahili (Somalia)"
        Case msoLanguageIDSwahili
            langDesc = "Swahili (Tanzania)"
        Case msoLanguageIDSwahili
            langDesc = "Swahili (Uganda)"
        Case msoLanguageIDSwedish
            langDesc = "Swedish"
        Case msoLanguageIDArabicEgypt
            langDesc = "Sudanese Arabic"
        Case msoLanguageIDSyriac
            langDesc = "Syriac"
        Case msoLanguageIDFilipino
            langDesc = "Tagalog"
        Case msoLanguageIDTajik
            langDesc = "Tajik"
        Case msoLanguageIDTamil
            langDesc = "Tamil"
        Case msoLanguageIDTatar
            langDesc = "Tatar"
        Case msoLanguageIDTelugu
            langDesc = "Telugu"
        Case msoLanguageIDThai
            langDesc = "Thai"
        Case msoLanguageIDTibetan
            langDesc = "Tibetan"
        Case msoLanguageIDTigrignaEthiopic
            langDesc = "Tigrinya"
        Case msoLanguageIDTsonga
            langDesc = "Tonga"
        Case msoLanguageIDTsonga
            langDesc = "Tsonga"
        Case msoLanguageIDTswana
            langDesc = "Tswana"
        Case msoLanguageIDTurkish
            langDesc = "Turkish"
        Case msoLanguageIDTurkmen
            langDesc = "Turkmen"
        Case msoLanguageIDUkrainian
            langDesc = "Ukrainian"
        Case msoLanguageIDUrdu
            langDesc = "Urdu"
        Case msoLanguageIDUzbekCyrillic
            langDesc = "Uzbek (Cyrillic)"
        Case msoLanguageIDUzbekLatin
            langDesc = "Uzbek (Latin)"
        Case msoLanguageIDWelsh
            langDesc = "Welsh"
        Case msoLanguageIDVietnamese
            langDesc = "Vietnamese"
        Case msoLanguageIDXhosa
            langDesc = "Xhosa (South Africa)"
        Case msoLanguageIDYiddish
            langDesc = "Yiddish"
        Case msoLanguageIDYiddish
            langDesc = "Yiddish (Israel)"
        Case msoLanguageIDYoruba
            langDesc = "Yoruba"
        Case msoLanguageIDZulu
            langDesc = "Zulu (Africa)"
    End Select
    
    getLanguageDescription = langDesc
    
End Function

#End If


Attribute VB_Name = "Logging"
Option Explicit

Public Sub LogStart()
'------------------------------
'
' Log start of work
'
'------------------------------
    On Error Resume Next
    
    Dim lastRow As Long
    
    lastRow = NextEmptyRow(LOG_START)
    
    Dim unixTime As Double
    
    unixTime = getNowAsUnixUTC()
    
    ThisWorkbook.Sheets("data").Cells(lastRow + 1, LOG_START) = unixTime 'Format(DateTime.Now, "yyyy-MM-dd hh:mm:ss")
    
End Sub

Public Function getNowAsUnixUTC() As Double
'------------------------------
'
' Return the current time as a unix UTC value
'
'------------------------------
    Dim unixTime As Double
    
    Dim now As Date
    
    Dim utcNow As Date
    
    now = DateTime.now
    
    utcNow = LocalTimeToUTC(now)
        
    unixTime = DateDiff("s", "1/1/1970", utcNow) * 1000
    
    getNowAsUnixUTC = unixTime

End Function

Public Sub LogEnd()
'------------------------------
'
' Log end of work
'
'------------------------------
    On Error Resume Next
    
    Dim nextrow As Long
    
    nextrow = NextEmptyRow(LOG_START)
    
    Dim unixTime As Double
        
    unixTime = getNowAsUnixUTC()
    
    ThisWorkbook.Sheets("data").Cells(nextrow, LOG_END) = unixTime 'Format(DateTime.Now, "yyyy-MM-dd hh:mm:ss")
    

End Sub





Attribute VB_Name = "MouseHandler"
Option Explicit

#If VBA7 And Win64 Then
    Private Declare PtrSafe Function SetCursorPos Lib "user32" (ByVal x As Long, ByVal y As Long) As Long
    Private Declare PtrSafe Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long)
#Else
    Private Declare Function SetCursorPos Lib "user32" (ByVal x As Long, ByVal y As Long) As Long
    Private Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long)
#End If
Private Const MOUSEEVENTF_LEFTDOWN = &H2
Private Const MOUSEEVENTF_RIGHTDOWN As Long = &H8
Private Const MOUSEEVENTF_RIGHTUP As Long = &H10


Public Sub SendRightMouseButtonClick()
'------------------------------
'
' Send right mouse click
'
'------------------------------
    mouse_event MOUSEEVENTF_RIGHTDOWN, 0&, 0&, 0&, 0&
    'and an up
    'mouse_event MOUSEEVENTF_RIGHTUP, 0&, 0&, 0&, 0&

End Sub


Attribute VB_Name = "Navigation"
Option Explicit
Public Sub MoveDownOneRow()
'------------------------------
'
' Navigate down one segment
'
'------------------------------
    
    Dim currentRow As Long
    Dim currentColumn As Long
    Dim i As Long

    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    Call UndoIllegalChanges(currentRow, currentColumn)
    
    currentRow = currentRow + 1
    
    If (currentRow < Sheet1.lastRow + 1) Then
        Cells(currentRow, 4).Select
    End If
    
#If Mac Then
    Call SetActiveCellForMac
#End If
     
End Sub
Public Sub MoveUpOneRow()
'------------------------------
'
' Navigate down one segment
'
'------------------------------
    
    Dim currentRow As Long
    Dim currentColumn As Long
    Dim i As Long

    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    Call UndoIllegalChanges(currentRow, currentColumn)
    
    currentRow = currentRow - 1
    
    For i = currentRow To 8 Step -1
        If (Cells(i, 2) <> Empty) Then
            Cells(i, 4).Select
        End If
    Next i
    
#If Mac Then
    Call SetActiveCellForMac
#End If
 
End Sub
Public Sub MoveDown()
'------------------------------
'
' Navigate down one segment
'
'------------------------------
    
    Dim currentRow As Long
    Dim currentColumn As Long
    Dim i As Long

    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    Call UndoIllegalChanges(currentRow, currentColumn)
    
    If (currentRow < Sheet1.lastRow) Then
        For i = currentRow + 1 To Sheet1.lastRow 'CHANGE 21 to 1
            If ((Cells(i, 2) <> Empty) And (Cells(i, 4) <> "Merged with the segment above:")) Then
                Exit For
            End If
        Next i
        
        Sheet1.currentAction = RK_TAB
        
        Cells(i, 4).Activate
    End If
    
    'Call Sheet1.ProcessCell
    

End Sub

Public Sub MoveUp()
'------------------------------
'
' Navigate up one segment
'
'------------------------------

    Dim currentRow As Long
    Dim currentColumn As Long
    Dim i As Long

    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    Call UndoIllegalChanges(currentRow, currentColumn)
    
    If (currentRow > 8) Then
        For i = currentRow - 1 To 8 Step -1
            If ((Cells(i, 2) <> Empty) And (Cells(i, 4) <> "Merged with the segment above:")) Then
                Exit For
            End If
        Next i
    
        Cells(i, 4).Activate
#If Mac Then
    Call SetActiveCellForMac
#End If
     End If
    
    'Call Sheet1.ProcessCell

End Sub

Public Sub GoCopyTranslation()
'------------------------------
'
' Go to the next segment and if there is any matching copy it
' automatically to the target segment and then enter editing mode
'
'------------------------------
    Call MoveDown
    
    Dim currentRow As Long
    Dim currentColumn As Long
    Dim i As Long

    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    If (currentRow < Sheet1.lastRow) Then
        For i = currentRow + 1 To Sheet1.lastRow 'CHANGE 21 to 1
            If Cells(i, 2) <> Empty Then
                Exit For
            End If
            If ThisWorkbook.Sheets("data").Cells(i, 17) <> Empty Then ' Column 17 = matchOrigin
                Cells(i, 4).Activate
                'Call ThisWorkbook.Sheets("XTM-Editor").CopyTranslation
                Exit For
                
            End If
        Next i
        
        Cells(currentRow, 4).Activate
    End If

End Sub
Public Sub UndoIllegalChanges(currentRow As Long, currentColumn As Long)
'------------------------------
'
' Undo any illegal changes that the user may have made
'
'------------------------------

    On Error Resume Next
    
    If ((Cells(currentRow, 2) <> Empty) And (currentColumn = 4)) Then
        Exit Sub
    ElseIf (Cells(currentRow, 2) <> Empty) Or (Cells(currentRow, 3) <> Empty) Then
        Application.EnableEvents = False
        Application.Undo
        
        Application.EnableEvents = True
    End If

End Sub

Public Sub GoHome()
'------------------------------
'
' Go to the first segment
'
'------------------------------
    
    Dim currentRow As Long
    Dim currentColumn As Long
    
    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    Call UndoIllegalChanges(currentRow, currentColumn)
    
    If (ActiveCell.row <> 8) Then 'Don't if we are already there
        Cells(8, 4).Activate
#If Mac Then
    Call SetActiveCellForMac
#End If
     End If

End Sub


Public Sub GoToLast()
'------------------------------
'
' Go to the last segment
'
'------------------------------

    Dim currentRow As Long
    Dim currentColumn As Long
    
    currentRow = ActiveCell.row
    currentColumn = ActiveCell.Column
    
    Call UndoIllegalChanges(currentRow, currentColumn)
    Dim i As Long
    
    For i = Sheet1.lastRow To 8 Step -1
        If Cells(i, 2) <> Empty Then
            Exit For
        End If
    Next i
    
    If (ActiveCell.row <> i) Then 'Don't if we are already there
        Cells(i, 4).Activate
#If Mac Then
    Call SetActiveCellForMac
#End If
     End If
    
End Sub


Public Sub RefocusTargetCell(currentRow As Long)
'------------------------------
'
' Get the focus back on the current target cell so that cursor is put back into the cell
'
'------------------------------

    Application.EnableEvents = True
    
    Cells(currentRow, 2).Select
    
    DoEvents
    
    Cells(currentRow, 4).Select

#If Mac Then
    Call SetActiveCellForMac
#End If
    
    Debug.Print "Exiting RefocusTargetCell()"
End Sub

Public Sub SetActiveCellForMac()
'------------------------------
'
' Open up the Active cell for Mac version of Excel 2011
'
'------------------------------
    Dim dummy As Boolean
    Call Sheet1.ProcessCell(dummy)
End Sub





Attribute VB_Name = "ScreenSize"
Option Explicit

' Window size
Private Type RECT
    x1 As Long
    y1 As Long
    x2 As Long
    y2 As Long
End Type

#If Win64 Then
    Private Declare PtrSafe Function GetDesktopWindow Lib "user32" () As Long
    Private Declare PtrSafe Function GetWindowRect Lib "user32" (ByVal hWnd As LongPtr, rectangle As RECT) As Long
#Else
        Private Declare Function GetDesktopWindow Lib "user32" () As Long
        Private Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, rectangle As RECT) As Long
#End If


Public Function GetScreenResolution() As String
'------------------------------
'
' To determine the current screen size or resolution.
'
'------------------------------
    Dim R As RECT
    Dim hWnd As Long
    Dim RetVal As Long
    
    hWnd = GetDesktopWindow()
    RetVal = GetWindowRect(hWnd, R)
    GetScreenResolution = (R.x2 - R.x1) & " X " & (R.y2 - R.y1)
    
End Function


Sub MaximizeWindow()
'------------------------------
'
' Maximize the screen size.
'
'------------------------------
    Dim ScreenZoom As Integer
    Dim ScreenDimension As String
    Dim resp As Integer
    Dim fixme As Boolean
    Dim MacOS As Boolean
    
    MacOS = IsMacOS
    
    On Error GoTo ExitError
    
    ActiveWindow.WindowState = xlMaximized 'First maximize the screen to the max monitor resolution
    
    Dim xRes As Integer
    
    If MacOS = True Then
        xRes = ThisWorkbook.Application.UsableWidth
    Else
        ScreenDimension = GetScreenResolution()
        
        Dim xResString As String
        
        Dim x As Integer
        
        x = InStr(1, ScreenDimension, " ")
        
        If (x <> 0) Then
            xResString = Mid(ScreenDimension, 1, x - 1)
            
            xRes = Val(xResString)
        Else
            xRes = 1280 'Default fallback value
        End If
    End If
        
    If MacOS = True Then
        ScreenZoom = 125
    ElseIf (xRes <= 800) Then
        ScreenZoom = 65
    ElseIf (xRes <= 1024) Then
        ScreenZoom = 75
    ElseIf (xRes < 1280) Then
        ScreenZoom = 82
    ElseIf (xRes < 1400) Then
        ScreenZoom = 84
    ElseIf (xRes <= 1440) Then
        ScreenZoom = 90
    Else
        ScreenZoom = 95
    End If
            
    'Now set Col C and D width
            
    Dim colWidth As Integer
            
    If (xRes <= 800) Then
        colWidth = 45
    ElseIf (xRes <= 1024) Then
        colWidth = 52
    ElseIf (xRes <= 1152) Then
        colWidth = 66
    ElseIf (xRes <= 1280) Then
        colWidth = 62
    ElseIf (xRes <= 1344) Then
        colWidth = 64
    ElseIf (xRes <= 1366) Then
        colWidth = 66
    ElseIf (xRes <= 1400) Then
        colWidth = 68
    ElseIf (xRes <= 1440) Then
        colWidth = 71
    ElseIf (xRes <= 1532) Then
        colWidth = 65
    ElseIf (xRes <= 1600) Then
        colWidth = 76
    ElseIf (xRes <= 1680) Then
        colWidth = 84
    ElseIf (xRes <= 1920) Then
        colWidth = 97
    ElseIf (xRes <= 2042) Then
        colWidth = 104
    ElseIf (xRes <= 2048) Then
        colWidth = 105
    Else
        colWidth = 115
    End If
            
    ThisWorkbook.Sheets("XTM-Editor").Columns("C:D").ColumnWidth = colWidth
    
    ActiveWindow.Zoom = ScreenZoom
    
    ActiveWorkbook.Save 'Necessary to reset rows
    
    Exit Sub
ExitError:
    MsgBox getLocale("PLEASE_REOPEN_THE_XTM_OFFLINE_EDITOR_BY_DOUBLE_CLICKING_ON_THE_DOWNLOADED_FILE")
    
    Call FastQuit

End Sub










Attribute VB_Name = "SegmentNo"
Attribute VB_Base = "0{457801C3-3032-4E84-938A-3DC0BD5DC5F5}{40FFFAA8-6678-42C9-BC53-B50DFD6BDD3A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public SEGNO As String


Private currentRow As Long
Private currentCol As Long
    

Private Sub UserForm_Activate()
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column
    
    SegmentNo.caption = getLocale("GO TO SEGMENT")
    Label1.caption = getLocale("GO TO SEGMENT NO") & ":"
    GoButton.caption = getLocale("GO")
    CloseButton.caption = getLocale("CLOSE")
    
End Sub


Private Sub CloseButton_Click()
    Call ClearUp
End Sub

Private Sub GoButton_Click()
    SEGNO = SegmentNoBox.text
    Call Sheet1.GoToSegment
    
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column

#If Mac Then
    Call SetActiveCellForMac
#End If
    
    Call ClearUp
End Sub

Private Sub SegmentNoBox_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Call GoButton_Click
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call ClearUp

    'If CloseMode = 0 Then Cancel = True

End Sub

Private Sub ClearUp()
    SegmentNo.Hide
    
    currentRow = ActiveCell.row
    
    Cells(currentRow, 2).Select
    DoEvents
    Cells(currentRow, currentCol).Select
End Sub



Attribute VB_Name = "SetupOptions"
Attribute VB_Base = "0{A5E1BBCB-2E60-4293-B310-606C488985FA}{694652F0-CF7A-46BE-9A30-ED9BEBC60527}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Private currentRow As Long
Private currentCol As Long
    


Private Sub CloseButton_Click()
    Call ClearUp
End Sub

Private Sub ShowAllComments_Click()
    If (ShowAllComments.Value = True) Then
        Sheet1.ShowAllComments = True
        
        ThisWorkbook.Sheets("data").Cells(1, SHOW_ALL_COMMENTS) = "YES"
        
    Else
        Sheet1.ShowAllComments = False
        
        ThisWorkbook.Sheets("data").Cells(1, SHOW_ALL_COMMENTS) = "NO"
        
    End If
End Sub

Private Sub SimpleView_Click()
    If (SimpleView.Value = True) Then
        Sheet1.SimpleView = True
        
        ThisWorkbook.Sheets("data").Cells(1, SIMPLE_VIEW) = "YES"
        Sheet1.Cells(1, 4) = "Simple View Active"
        
    Else
        Sheet1.SimpleView = False
        
        ThisWorkbook.Sheets("data").Cells(1, SIMPLE_VIEW) = "NO"
        Sheet1.Cells(1, 4) = Empty
        
    End If
End Sub

Private Sub SpellCheckEachSegment_Click()
    If (SpellCheckEachSegment.Value = True) Then
        Sheet1.SpellCheckEachSegment = True
        
        ThisWorkbook.Sheets("data").Cells(1, SPELL_CHECK_ALL_SEGMENTS) = "YES"
        
    Else
        Sheet1.SpellCheckEachSegment = False
        
        ThisWorkbook.Sheets("data").Cells(1, SPELL_CHECK_ALL_SEGMENTS) = "NO"
        
    End If
End Sub

Private Sub UserForm_Activate()
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column
    
    SpellCheckEachSegment.Value = Sheet1.SpellCheckEachSegment
    ShowAllComments.Value = Sheet1.ShowAllComments
    SimpleView.Value = Sheet1.SimpleView
    
    SetupOptions.caption = getLocale("SETTINGS")
    SpellCheckEachSegment.caption = getLocale("AUTO_SPELL_CHECK_EACH_SEGMENT")
    ShowAllComments.caption = getLocale("DISPLAY_ALL_COMMENTS_IN_ACTIVE_SEGMENT")
    SimpleView.caption = getLocale("SIMPLE_VIEW")
    CloseButton.caption = getLocale("CLOSE")
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call ClearUp

    'If CloseMode = 0 Then Cancel = True

End Sub

Private Sub ClearUp()
    Hide
    'Cells(currentRow, 2).Select
    RefocusTargetCell (currentRow)
End Sub


Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "GoToSegmentTextBox, 38, 26, MSForms, TextBox"
Attribute VB_Control = "NexIncompletetIcon, 37, 27, MSForms, Image"
Attribute VB_Control = "PreviousIncompleteIcon, 36, 28, MSForms, Image"
Attribute VB_Control = "SetupIcon, 35, 29, MSForms, Image"
Attribute VB_Control = "FindAndReplaceIcon, 34, 30, MSForms, Image"
Attribute VB_Control = "NextSegmentWithErrorIcon, 33, 31, MSForms, Image"
Attribute VB_Control = "CommentNextIcon, 32, 32, MSForms, Image"
Attribute VB_Control = "CommentPreviousIcon, 31, 33, MSForms, Image"
Attribute VB_Control = "AddCommentIcon, 30, 34, MSForms, Image"
Attribute VB_Control = "SpellCheckIcon, 29, 35, MSForms, Image"
Attribute VB_Control = "HelpIcon, 28, 36, MSForms, Image"
Option Explicit

'------------------------------
'
' Copyright @ XTM International 2012 - 2013
'
'------------------------------

'------------------------------
' Global defines
'
'
'------------------------------

Public workingCell As String
Public workingCellText As String
Public targetCellText As String
Public inlineError As Boolean
Public lastRow As Long
Public spellCheckingAllSegments As Boolean
Public finding As Boolean
Public changedStatus As Boolean
Public SpellCheckEachSegment As Boolean
Public nextActiveXPressed As Boolean
Public doNotShowTIPAgain As Boolean
Public ShowAllComments As Boolean
Public SimpleView As Boolean
Public Active As Boolean
Public xtmLang As Integer

Public langCode As Integer

Public MacOS As Boolean

Public currentAction As Integer

Const STATUS_DONE_MATCHED = "STATUS_DONE_MATCHED"
Const STATUS_DONE_UNMATCHED = "STATUS_DONE_UNMATCHED"
Const STATUS_TO_BE_CHECKED_LEVERAGED_YELLOW = "STATUS_TO_BE_CHECKED_LEVERAGED_YELLOW"
Const STATUS_TO_BE_CHECKED_NONTRANS = "STATUS_TO_BE_CHECKED_NONTRANS"

Const STATUS_TO_BE_DONE_MATCHED = "STATUS_TO_BE_DONE_MATCHED"
Const STATUS_TO_BE_DONE_UNMATCHED = "STATUS_TO_BE_DONE_UNMATCHED"
Const STATUS_TO_BE_DONE_NONTRANS = "STATUS_TO_BE_DONE_NONTRANS"
Const STATUS_TO_BE_CORRECTED_MATCHED = "STATUS_TO_BE_CORRECTED_MATCHED"
Const STATUS_TO_BE_CORRECTED_UNMATCHED = "STATUS_TO_BE_CORRECTED_UNMATCHED"
Const STATUS_TO_BE_CORRECTED_NONTRANS = "STATUS_TO_BE_CORRECTED_NOTRANS"
Const STATUS_DONE_NONTRANS = "STATUS_DONE_NONTRANS"

Const StatusDONE = "StatusDONE"
Const StatusTODO = "StatusTODO"
Const StatusTOCORRECT = "StatusTOCORRECT"
Const StatusCHECK = "StatusCHECK"

Const DONE = "DONE"
Const TO_BE_CORRECTED = "TO_BE_CORRECTED"
Const TO_BE_CHECKED = "TO_BE_CHECKED"
Const TO_BE_DONE = "TO_BE_DONE"
Const INVALID_INLINES = "INVALID_INLINES"
Const EMPTY_TARGET = "EMPTY_TARGET"


Const RED = "RED"
Const GREEN = "GREEN"
Const BLUE = "BLUE"
Const YELLOW = "YELLOW"

Const TRANSLATE = "TRANSLATE"
Const REVIEW = "REVIEW"
Const CORRECT = "CORRECT"

Private Type InlineInfo
            ID As String
            Found As Byte
            Single As Boolean
End Type

Private Type CommentStyle
            ID As String
            Color As Integer
            EndsWithCollon As Boolean
            Bold As Boolean
            
End Type

Private style(10) As CommentStyle


Public Sub ActivateSegment()
'------------------------------
'
' Activate the last segment row
'
'------------------------------
    Dim currentRow As Long
    Dim currentCol As Long
    
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column
    
    If (Cells(currentRow, 2) = Empty) Then
        Dim i As Long
        i = currentRow
        
        For i = currentRow To 8 Step -1
            If (Cells(i, 2) <> Empty) Then
                currentRow = i
                
                Exit For
            End If
        Next i
    End If
    
    workingCell = "D" + CStr(currentRow)
    On Error GoTo ExitError
    Cells(currentRow, 2).Select
    Cells(currentRow, 4).Select
    
    'Call Worksheet_SelectionChange(Range(workingCell))
    
    'Range(workingCell).Select
    'If (MacOS = False) And (ThisWorkbook.canChangeTarget = True) And (finding = False) Then
    '    Cells(currentRow, 4).Locked = False
    '    Application.SendKeys "{F2}+{END}+{HOME}+{UP}+{UP}+{UP}+{UP}", True
    'End If
    
    Exit Sub
    
ExitError:
    'MsgBox "ERROR" & Err.Number & ": " & Error.Description
End Sub
Public Sub calcLastRow()
'------------------------------
'
' Work out the last row value..
'
'------------------------------
    Dim rowNumber As Long
    
    lastRow = ActiveSheet.UsedRange.Rows.count 'nominal last row.

    If ThisWorkbook.Sheets("data").Cells(lastRow, 3) = Empty Then   'extra padding rows are sometimes added
        For rowNumber = lastRow - 1 To 5 Step -1                    'so we need to work out what the actual last row number is
            If ThisWorkbook.Sheets("data").Cells(rowNumber, 3) <> Empty Then
                Exit For
            End If
        Next rowNumber
        
        lastRow = rowNumber
    End If

End Sub

Private Sub AddCommentIcon_Click()
    Call AddComment
End Sub

Private Sub CommentNextIcon_Click()
    Call GoToNextSegmentWithComment
End Sub

Private Sub CommentPreviousIcon_Click()
    Call GoToPreviousSegmentWithComment
End Sub

Private Sub FindAndReplaceIcon_Click()
    Call FindAndReplace
End Sub

Private Sub HelpIcon_Click()
    Call DisplayPDFHelp
End Sub

Private Sub NexIncompletetIcon_Click()
    Call GoToNextIncompleteSegment
End Sub

Private Sub NextSegmentWithErrorIcon_Click()
    Call GoToNextSegmentWithErrors
End Sub

Private Sub PreviousIncompleteIcon_Click()
    Call GoToPreviousIncompleteSegment
End Sub

Private Sub SetupIcon_Click()
    Call SetupOptionsShow
End Sub

Private Sub SpellCheckIcon_Click()
    If (ThisWorkbook.canChangeTarget = False) Then 'Reviewers cannot change cell contents
        MsgBox (getLocale("YOU_CANNOT_CHANGE_CELL_CONTENTS_IN_THE_REVIEW_STEP"))
    Else
        Call SpellCheckAllSegments
    End If
End Sub

Private Sub Worksheet_Activate()

End Sub

Private Sub Worksheet_BeforeRightClick(ByVal target As Range, Cancel As Boolean)
    'MsgBox "Target = " & Target
End Sub

Private Sub Worksheet_Change(ByVal target As Range)
    On Error Resume Next
    
    If ((target.Column = 4) And (ActiveCell.row >= 8) And (ActiveCell.row <= lastRow + 1)) Then
        Dim row As Long
        
        row = target.row
        
        If Cells(row, 2) = Empty Then
            Application.EnableEvents = False
            Application.Undo
        
            Application.EnableEvents = True
    
            'MsgBox "You cannot change text in this field!"
        End If
    Else
        'must disable events if you change the sheet as it will
        'continually trigger the change event
        Application.EnableEvents = False
        Application.Undo
        Application.EnableEvents = True

        'MsgBox "You cannot change text in the source fields!"
    End If
End Sub

Private Sub Worksheet_SelectionChange(ByVal target As Range)
'------------------------------
'
' Event driven procedure for each change of selection
' Processes the previous and current Cells as required.
'
'------------------------------
  
  Debug.Print ("Entering Worksheet_SelectionChange for " & target.Address)

' UnhideMatching Macro
  With target

    If lastRow = 0 Then
        Call calcLastRow
    End If
    
    Dim currentRow As Long
    Dim currentColumn As Long
    Dim readKeyboard As Boolean
    Dim rightButtonClick As Boolean
    
    Dim MacOS As Boolean
    
    MacOS = IsMacOS

    If MacOS = False Then
        If (GetAsyncKeyState(vbKeyRButton)) Then
            Debug.Print "You have clicked the right button!" 'when you click right button
            rightButtonClick = True
        End If
    End If

    If (rightButtonClick = False) And (ActiveCell.row >= 8) And (ActiveCell.row < lastRow + 1) And (spellCheckingAllSegments = False) And (finding = False) Then
        
        currentRow = ActiveCell.row
        currentColumn = ActiveCell.Column
        
        Application.EnableEvents = False
        
        Call ProcessCell(readKeyboard)
        
        nextActiveXPressed = False
        
        currentAction = RK_NULL 'reset action

        Application.EnableEvents = True
        
        'Call QuitKeyboardHandler 'quit any existing reads

#If Win32 Or Win64 Then
    If (SimpleView = False) And (readKeyboard = True) Then
            Call ReadLoop(currentRow)
        End If
#End If
    
    End If

  End With
  
  Debug.Print ("Exiting Worksheet_SelectionChange for " & target.Address)

End Sub

Private Sub ReadLoop(currentRow As Long)
'------------------------------
'
' The main Segment read keyboard loop
'
'------------------------------
    Dim action As Integer
    
    Do
        Debug.Print ("Entering ReadKeyboardEvents for row = " & currentRow)
        On Error Resume Next
            
        action = ReadKeyboardEvents(currentRow, xtmLang)
            
        Debug.Print ("Exiting ReadKeyboardEvents, action = " & ActionDesc(action))

        changedStatus = False
    
        'If (action <> currentAction) Then
        Select Case action
            Case RK_NULL
                Exit Do
            Case RK_TAB
                'Call MoveDown
                Application.SendKeys "{TAB}"
                Exit Do
            Case RK_SHIFT_TAB
                Application.SendKeys "+{TAB}"
                Exit Do
            Case RK_RET
                'Call GoCopyTranslation
                Application.SendKeys "{RETURN}"
                Exit Do
            Case RK_ESC
                Application.SendKeys "{ESCAPE}"
                Application.SendKeys "{TAB}"
                Exit Do
            Case RK_F1
                'Application.SendKeys "{RETURN}"
                Call DisplayPDFHelp
                'Application.Wait (3)
                'Cells(currentRow, 4).Select
                'Exit Do
                
                    
                'DoEvents
                'Cells(currentRow, 4).Activate
                'Application.SendKeys "^{F1}"
                Exit Do
            Case RK_CTRL_E
                Application.SendKeys "^{e}"
                Exit Do
            Case RK_CTRL_F
                Application.SendKeys "{RETURN}"
                DoEvents
                FindAndReplace
                'RefocusTargetCell
                'Application.SendKeys "^{f}"
            Case RK_CTRL_G
                'SegmentNo.Show
                Application.SendKeys "{RETURN}"
                DoEvents
                SegmentNo.Show
                Exit Do
            Case RK_CTRL_H
                Application.SendKeys "{RETURN}"
                DoEvents
                FindAndReplace
            Case RK_CTRL_T
                Application.SendKeys "{RETURN}"
                DoEvents
                Application.SendKeys "^{T}"
            Case RK_CTRL_M
                Application.SendKeys "{RETURN}"
                DoEvents
                AddComment
                RefocusTargetCell (currentRow)
                Exit Do
            Case RK_CTRL_O, RK_CTRL_BACKSLASH
                Debug.Print ("RK_CTRL_O Or RK_CTRL_BACKSLASH")
                Application.SendKeys "{RETURN}"
                DoEvents
                DoConcordance
                RefocusTargetCell (currentRow)
                Exit Do
            Case RK_CTRL_P
                Application.SendKeys "{RETURN}"
                DoEvents
                DoPrint
                RefocusTargetCell (currentRow)
                Exit Do
            Case RK_CTRL_UP
                Application.SendKeys "^{UP}"
                Exit Do
            Case RK_CTRL_DOWN
                Application.SendKeys "^{DOWN}"
                Exit Do
            Case RK_CTRL_UP
                Application.SendKeys "^{UP}"
                Exit Do
            Case RK_CTRL_DOT
                Application.SendKeys "^{.}"
                Exit Do
            Case RK_CTRL_COMMA
                Application.SendKeys "^{,}"
                Exit Do
            Case RK_CTRL_HOME
                'Application.SendKeys "{RETURN}"
                Debug.Print "RK_CTRL_HOME"
                Application.SendKeys "^{HOME}"
                Exit Do
            Case RK_CTRL_END
                'Application.SendKeys "{RETURN}"
                Debug.Print "RK_CTRL_END"
                Application.SendKeys "^{END}"
                Exit Do
            Case RK_RIGHT_BUTTON_CLICK
                Debug.Print "In readLoop: RK_RIGHT_BUTTON_CLICK"
                Application.SendKeys "{RETURN}"
                Debug.Print "Sent: SendKeys {RETURN}"
                SendRightMouseButtonClick
                'Application.SendKeys "+{F10}"
                'Debug.Print "Sent: SendKeys +{F10}"
                DoEvents
                Exit Do
                'SendRightMouseButtonClick
            Case SELECTION_CHANGED
                Exit Do
                
        End Select
            'End If
        
        currentAction = action
    Loop While True

End Sub

Public Sub ProcessCell(ByRef readKeyboard As Boolean)
'------------------------------
'
' Event driven procedure for each change of selection
' Executes the following:
'
' 1. Hide any matching/terminology rows for the previously selected Cell
' 2. Update the Status for the previously selected Cell if the target language text has changed
' 3. Unhide any matching/terminology rows for the current selected Cell
' 4. Take a copy of the current Cell target text and the current Cell address
'
'------------------------------

  Application.ScreenUpdating = False
  
        Dim currentCell As String
        
        currentCell = ActiveCell.Address(False, False)
        'MsgBox "The selected cell is '" & currentCell & "'"
    
        Dim currentRow As Long
        Dim currentColumn As Long
        Dim canChangeTargetSegment As Boolean
        
        If ((ThisWorkbook.canChangeTarget = False) Or _
            ((Cells(ActiveCell.row, 5).text = "I") And (ThisWorkbook.canEditICEMatches = False))) Then 'Reviewers cannot change cell contents
            canChangeTargetSegment = False
        Else
            canChangeTargetSegment = True
        End If
    
        currentRow = ActiveCell.row
        currentColumn = ActiveCell.Column
        
        Call UpdateStatus
        
'        If ((currentColumn = 4 And Cells(currentRow, 2) <> Empty) Or (workingCell.Column = 4)) Then
'            If (ThisWorkbook.canChangeTarget = True) Then
'                Call UpdateStatus
'            Else
'                Call CheckTargetSpelling(currentRow)
'            End If
'        End If
        
        'If (inlineError <> 99) And ((currentColumn = 4) Or (currentColumn = 5)) Then
        On Error GoTo ErrHandler:

        'If ((currentColumn = 4) Or (currentColumn = 5)) Then
        If ((currentColumn > 1) And (currentColumn < 6)) Then
            If (Cells(currentRow, 2) <> Empty) Then
                Call Hide
                Call Unhide
                targetCellText = Cells(currentRow, 4)
                workingCell = "D" + CStr(currentRow) 'TODO make sure that this is a true text target cell !!!!!!!!!
                workingCellText = ActiveCell.text
            End If
            If ((currentColumn = 2) Or (currentColumn = 3) And (Cells(currentRow, 2) <> Empty)) Then 'If we are not in the target cell then exit
                Exit Sub
            End If
                
            If (((currentColumn = 4) And (ThisWorkbook.Sheets("data").Cells(currentRow, 17) <> Empty)) And (finding = False) And (canChangeTargetSegment = True)) Then ' Column 17 = matchOrigin
                Call CopyTranslation
            'changed data columns index to 0 from 20
            ElseIf ((currentColumn = 4 And ThisWorkbook.Sheets("data").Cells(currentRow, 4) = "TERMTARGET") And (finding = False) And (canChangeTargetSegment = True)) Then ' If entry Column 3 (COLUMNHEADER) = TERMTARGET
                Call CopyTerm
            ElseIf ((currentColumn = 5 And Cells(currentRow, 2) <> Empty) And (ThisWorkbook.Sheets("data").Cells(currentRow, 4) <> "IS_MERGED")) Then
                Call Hide
                Call Unhide
                targetCellText = Cells(currentRow, 4)
                workingCell = "D" + CStr(currentRow) 'TODO make sure that this is a true text target cell !!!!!!!!!
                'Call ChangeStatus(currentRow)
                Call ChangeWorkflowStatus(currentRow)
            ElseIf ((currentColumn = 5) And (Cells(currentRow, 2) = Empty)) Then  'We are currently not on a main segment row
                currentRow = GetMainRow(currentRow)                             'Find the main segment row
                targetCellText = Cells(currentRow, 4)
                Call ChangeWorkflowStatus(currentRow)
            End If
            
        
'        ElseIf ((currentColumn = 3) And (Cells(ActiveCell.row, 2) <> Empty) And (finding = False)) Then 'Clicked on source segment
'            If (canChangeTargetSegment = False) Then 'Reviewers cannot change cell contents
'                MsgBox ("Cannot overwrite protected target segment")
'            Else
'                Call CopySource2Target
'                Cells(ActiveCell.row, 4).Select
'            End If
        End If

        If (canChangeTargetSegment = False) Then 'Reviewers cannot change cell contents, or ICE matched segments locked
            Cells(ActiveCell.row, 4).Locked = True
        End If

Finish:

        If ((currentColumn = 4) And (Cells(ActiveCell.row, 2) <> Empty)) Then
            If (ThisWorkbook.Sheets("data").Cells(ActiveCell.row, 4) <> "IS_MERGED") Then 'Do not allow editing of merged segments
                If Cells(ActiveCell.row, 5).text = "U" Then
                    Cells(ActiveCell.row, 4).Interior.Color = RGB(255, 255, 255)
                    If (MacOS = False) And (ThisWorkbook.canChangeTarget = True) And (finding = False) Then
                        readKeyboard = True
                            
                        'Application.SendKeys "{F2}", True
                    End If
                ElseIf (Cells(ActiveCell.row, 5).text <> "I") And (finding = False) Then
                    Cells(ActiveCell.row, 4).Interior.Color = RGB(255, 255, 255)
                    If (MacOS = False) And (ThisWorkbook.canChangeTarget = True) Then
                        readKeyboard = True
                        'Application.SendKeys "{F2}", True
                    End If
                ElseIf (Cells(ActiveCell.row, 5).text = "I") And (ThisWorkbook.canEditICEMatches = True) Then
                    Cells(ActiveCell.row, 4).Interior.Color = RGB(255, 255, 255)
                    readKeyboard = True
                    If (MacOS = False) Then
                        'Application.SendKeys "{F2}", True
                    End If
                End If
            End If
                
        End If

 Application.ScreenUpdating = True
 
 Dim action As Integer

 'action = ReadKeyboardEvents

 'Call TrackKeyPress

Exit Sub

ErrHandler:
    Debug.Print "ERROR" & Err.Number & ": " & Err.Description
 Resume Finish:

End Sub
Private Sub DecorateSigSpaces()
'------------------------------
'
' Decorate significant spaces: {sp} in red
'
'------------------------------

    Dim i As Integer
        
    Dim workingRow As Long
    Dim targetString As String
    workingRow = Range(workingCell).row
        
    targetString = Cells(workingRow, 4)

    For i = 1 To Len(targetString)
        If Mid(targetString, i, 4) = "{sp}" Then
                Cells(workingRow, 4).Characters(i, 4).Font.ColorIndex = 3
        End If
    Next i

End Sub

Function GetInlinesForRow(workingRow As Long) As Variant
'------------------------------
'
' Get the inlines for this working row as an array
'
'------------------------------

GetInlinesForRow = Split(ThisWorkbook.Sheets("data").Cells(workingRow, 6), ",")


End Function

Private Sub DecorateTarget()
'------------------------------
'
' Decorate the inlines to bold green just in case
'
'------------------------------

    Dim targetString As String
        
    Dim x As Integer
        
    Dim y As Integer
    Dim z As Integer
        
    Dim tmpI As String
        
    Dim workingRow As Long
        
    workingRow = ActiveCell.row
        
    targetString = Cells(workingRow, 4)
        
    x = 1

    Do While x <> 0
        x = InStr(x, targetString, "{")
        If (x <> 0) Then
            y = InStr(x, targetString, "}")
                
            If ((x <> 0) And (y <> 0)) Then
                tmpI = Mid(targetString, x + 1, y - x - 1)
                      
                If Len(tmpI) > 0 And Len(tmpI) < 3 Then
                    Cells(workingRow, 4).Characters(x, 3).Font.ColorIndex = 10
                    Cells(workingRow, 4).Characters(x, 3).Font.FontStyle = "Bold"
                End If
                x = x + 1
            Else
                x = 0
            End If
        End If
    Loop

End Sub

Private Sub ChangeWorkflowStatus(currentRow As Long)
'------------------------------
'
' Change the worlflow status
'
'------------------------------
    Dim matchType As String
    Dim currentStatus As String
    
    If (ThisWorkbook.Sheets("data").Cells(currentRow, 4) = INVALID_INLINES) Then
        MsgBox getLocale("THIS_SEGMENT_HAS_INLINE_ERRORS") & vbLf & getLocale("PLEASE_CORRECT_THESE_FIRST")
        Exit Sub
    ElseIf (ThisWorkbook.Sheets("data").Cells(currentRow, 4) = EMPTY_TARGET) Then
        MsgBox getLocale("EMPTY_TARGET_TEXT") & vbLf & getLocale("PLEASE_CORRECT_THESE_FIRST")
        Exit Sub
    ElseIf (ThisWorkbook.Sheets("data").Cells(currentRow, 4) = "IS_MERGED") Then
        MsgBox getLocale("YOU_CANNOT_CHANGE_STATUS_FOR_MERGED_SEGMENTS")
        Exit Sub
    End If
    
    matchType = Cells(currentRow, 5)
    currentStatus = ThisWorkbook.Sheets("data").Cells(currentRow, 5)
    
    Dim toBeDone As Boolean
    
    If (InStr(currentStatus, "TO_BE") <> 0) Then
        toBeDone = True
    Else
        toBeDone = False
    End If
    
    If ((ThisWorkbook.workflowStage <> REVIEW) And (Cells(currentRow, 5) = "I") And (ThisWorkbook.canEditICEMatches = False)) Then
        MsgBox (getLocale("CHANGE_STATUS_FOR_ICE_MATCHES_IS_BLOCKED_FOR_THIS_PROJECT"))
    ElseIf ((ThisWorkbook.workflowStage = CORRECT) Or (ThisWorkbook.workflowStage = REVIEW)) Then
        Call ChangeCorrectWorkflowStatus(matchType, currentStatus, toBeDone, currentRow)
    Else 'Default = TRANSLATE
        Call ChangeTranslateWorkflowStatus(matchType, currentStatus, toBeDone, currentRow)
    End If

End Sub

Private Sub ChangeCorrectWorkflowStatus(currentStatusLetter As String, currentStatus As String, toBeDone As Boolean, currentRow As Long)
'------------------------------
'
' Change the status for the CORRECT worlflow stage
'
'------------------------------
    Dim Status As String
    Dim statusLetter As String
    
    If ((currentStatusLetter = "U") And (toBeDone = True)) Then '1. ToBeRevised U/M Blue
        If (currentStatus = STATUS_TO_BE_CORRECTED_UNMATCHED) Then
            StatusUNGreen.Show
        
            statusLetter = StatusUNGreen.letter
        
            If StatusUNGreen.Status = GREEN Then
                If (statusLetter = "U") Then
                    Status = STATUS_DONE_UNMATCHED
                ElseIf (statusLetter = "N") Then
                    Status = STATUS_DONE_NONTRANS
                End If
            
                Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
            End If
        Else
            StatusUNGreenUBlue.Show
        
            statusLetter = StatusUNGreenUBlue.letter
        
            If StatusUNGreenUBlue.Status = GREEN Then
                If (statusLetter = "U") Then
                    Status = STATUS_DONE_UNMATCHED
                ElseIf (statusLetter = "N") Then
                    Status = STATUS_DONE_NONTRANS
                End If
            
                Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
            
            ElseIf StatusUNGreenUBlue.Status = BLUE Then
                If (statusLetter = "U") Then
                    Status = STATUS_TO_BE_CORRECTED_UNMATCHED
                End If
            
                Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
            End If
        End If
    ElseIf ((currentStatusLetter = "M") And (currentStatus = STATUS_TO_BE_CORRECTED_MATCHED)) Then '6. ToBeCorrected U/M red
        StatusMGreenNGreen.Show
        
        statusLetter = StatusMGreenNGreen.letter
        
        If StatusMGreenNGreen.Status = GREEN Then
            If (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            Else
                Status = STATUS_DONE_MATCHED
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "M") And (toBeDone = True)) Then '1. ToBeRevised U/M red
        StatusMGreenMBlueNGreen.Show
        
        statusLetter = StatusMGreenMBlueNGreen.letter
        
        If StatusMGreenMBlueNGreen.Status = GREEN Then
            If (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            Else
                Status = STATUS_DONE_MATCHED
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        ElseIf StatusMGreenMBlueNGreen.Status = BLUE Then
            Status = STATUS_TO_BE_CORRECTED_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "U") And (toBeDone = False)) Then '2. Revised U/M green
        StatusURedUBlueNGreen.Show
        
        statusLetter = StatusURedUBlueNGreen.letter
        
        If StatusURedUBlueNGreen.Status = RED Then
            Status = STATUS_TO_BE_DONE_UNMATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        ElseIf StatusURedUBlueNGreen.Status = BLUE Then
            Status = STATUS_TO_BE_CORRECTED_UNMATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        ElseIf StatusURedUBlueNGreen.Status = GREEN Then
            If (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "M") And (toBeDone = False)) Then '2. Revised U/M green
        StatusMRedMBlueNGreen.Show
        
        statusLetter = StatusMRedMBlueNGreen.letter
        
        If StatusMRedMBlueNGreen.Status = RED Then
            Status = STATUS_TO_BE_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        ElseIf StatusMRedMBlueNGreen.Status = BLUE Then
            Status = STATUS_TO_BE_CORRECTED_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        ElseIf StatusMRedMBlueNGreen.Status = GREEN Then
            If (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "N") And (toBeDone = False)) Then '3. Revised N green
        StatusNYellowNBlueMRed.Show
        
        statusLetter = StatusNYellowNBlueMRed.letter
        
        If StatusNYellowNBlueMRed.Status = YELLOW Then
            If (statusLetter = "N") Then
                Status = STATUS_TO_BE_CHECKED_NONTRANS
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusCHECK, Status, statusLetter)
        ElseIf StatusNYellowNBlueMRed.Status = BLUE Then
            If (statusLetter = "N") Then
                Status = STATUS_TO_BE_CORRECTED_NONTRANS
            End If
                
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        ElseIf StatusNYellowNBlueMRed.Status = RED Then
            If (statusLetter = "M") Then
                Status = STATUS_TO_BE_DONE_MATCHED
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "N") And ((InStr(currentStatus, TO_BE_CHECKED) <> 0))) Then '4. ToBeChecked N Yellow
        StatusNGreenNBlueMRed.Show
        
        statusLetter = StatusNGreenNBlueMRed.letter
        
        If StatusNGreenNBlueMRed.Status = GREEN Then
            Status = STATUS_DONE_NONTRANS
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        ElseIf StatusNGreenNBlueMRed.Status = BLUE Then
            Status = STATUS_TO_BE_CORRECTED_NONTRANS
                
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        ElseIf StatusNGreenNBlueMRed.Status = RED Then
            Status = STATUS_TO_BE_DONE_UNMATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "N") And (InStr(currentStatus, TO_BE_CORRECTED) <> 0)) Then '5. ToBeCorrected N blue
        StatusNGreen.Show
        
        statusLetter = StatusNGreen.letter
        
        If StatusNGreen.Status = GREEN Then
            If (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
        
    ElseIf ((currentStatusLetter = "U") And (InStr(currentStatus, TO_BE_CORRECTED) <> 0)) Then '6. ToBeCorrected U/M blue
        StatusUNGreen.Show
        
        statusLetter = StatusUNGreen.letter
        
        If StatusUNGreen.Status = GREEN Then
            If (statusLetter = "U") Then
                Status = STATUS_DONE_UNMATCHED
            ElseIf (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "M") And (InStr(currentStatus, TO_BE_CORRECTED) <> 0)) Then '6. ToBeCorrected U/M blue
        StatusMGreen.Show
        
        statusLetter = StatusMGreen.letter
        
        If StatusMGreen.Status = GREEN Then
            Status = STATUS_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "I") And (InStr(currentStatus, TO_BE_CORRECTED) <> 0)) Then '9. ToBeCorrected I blue
        StatusIGreen.Show
        
        statusLetter = StatusIGreen.letter
        
        If StatusIGreen.Status = GREEN Then
            Status = STATUS_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "I") And (toBeDone = True)) Then '7. ToBeRevised I red[default]
        StatusIGreenIBlue.Show
        
        statusLetter = StatusIGreenIBlue.letter
        
        If StatusIGreenIBlue.Status = GREEN Then
            Status = STATUS_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        ElseIf StatusIGreenIBlue.Status = BLUE Then
            Status = STATUS_TO_BE_CORRECTED_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "I") And (toBeDone = False)) Then '8. Revised I green
        StatusIRedIBlue.Show
        
        statusLetter = StatusIRedIBlue.letter
        
        If StatusIRedIBlue.Status = RED Then
            Status = STATUS_TO_BE_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
            
        ElseIf StatusIRedIBlue.Status = BLUE Then
            Status = STATUS_TO_BE_CORRECTED_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTOCORRECT, Status, statusLetter)
        End If
    End If
End Sub
Private Sub ChangeTranslateWorkflowStatus(currentStatusLetter As String, currentStatus As String, toBeDone As Boolean, currentRow As Long)
'------------------------------
'
' Change the status for the TRANSLATE worlflow stage
'
'------------------------------
    
    Dim Status As String
    Dim statusLetter As String
    
    If ((currentStatusLetter = "U") And (toBeDone = True)) Then '1. ToBeTranslated U/M red
        StatusUNGreen.Show
        
        statusLetter = StatusUNGreen.letter
        
        If StatusUNGreen.Status = GREEN Then
            If (statusLetter = "U") Then
                Status = STATUS_DONE_UNMATCHED
            ElseIf (statusLetter = "N") Then
                Status = STATUS_DONE_NONTRANS
            End If
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
            
        End If
    ElseIf ((currentStatusLetter = "M") And (toBeDone = True)) Then '1. ToBeTranslated U/M red
        StatusMGreen.Show
        
        statusLetter = StatusMGreen.letter
        
        If StatusMGreen.Status = GREEN Then
            Status = STATUS_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
            
        End If
    ElseIf ((currentStatusLetter = "U") And (toBeDone = False)) Then '2. Translated U/M green
        StatusURedNGreen.Show
        
        statusLetter = StatusURedNGreen.letter
        
        If StatusURedNGreen.Status = RED Then
            Status = STATUS_TO_BE_DONE_UNMATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
            
        ElseIf StatusURedNGreen.Status = GREEN Then
            Status = STATUS_DONE_NONTRANS
                
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
     ElseIf ((currentStatusLetter = "M") And (toBeDone = False)) Then '2. Translated U/M green
        StatusMRed.Show
        
        statusLetter = StatusMRed.letter
        
        If StatusMRed.Status = RED Then
            Status = STATUS_TO_BE_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        End If
   ElseIf ((currentStatusLetter = "N") And (toBeDone = False)) Then '3. Translated N green
        StatusNRedNYellow.Show
        
        statusLetter = StatusNRedNYellow.letter
        
        If StatusNRedNYellow.Status = RED Then
            Status = STATUS_TO_BE_DONE_NONTRANS
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
            
        ElseIf StatusNRedNYellow.Status = YELLOW Then
            Status = STATUS_TO_BE_CHECKED_NONTRANS
                
            Call UpdateWorkflowStatusCells(currentRow, StatusCHECK, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "N") And ((InStr(currentStatus, TO_BE_CHECKED) <> 0) Or (InStr(currentStatus, TO_BE_DONE) <> 0))) Then '4. Translated N yellow
        StatusURedNGreen.Show
        
        statusLetter = StatusURedNGreen.letter
        
        If StatusURedNGreen.Status = GREEN Then
            Status = STATUS_DONE_NONTRANS
                
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        ElseIf StatusURedNGreen.Status = RED Then
            Status = STATUS_TO_BE_DONE_UNMATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "M") And ((InStr(currentStatus, TO_BE_CHECKED) <> 0))) Then '5. Matched M yellow
        StatusMGreen.Show
        
        statusLetter = StatusMGreen.letter
        
        If StatusMGreen.Status = GREEN Then
            Status = STATUS_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "I") And (toBeDone = False)) Then '6. ICE green
        StatusIRed.Show
        
        statusLetter = StatusIRed.letter
        
        If StatusIRed.Status = RED Then
            Status = STATUS_TO_BE_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusTODO, Status, statusLetter)
        End If
    ElseIf ((currentStatusLetter = "I") And (toBeDone = True)) Then '7. ICE red
        StatusIGreen.Show
        
        statusLetter = StatusIGreen.letter
        
        If StatusIGreen.Status = GREEN Then
            Status = STATUS_DONE_MATCHED
            
            Call UpdateWorkflowStatusCells(currentRow, StatusDONE, Status, statusLetter)
        End If
    End If
End Sub


Private Sub WrapCellsText()
'------------------------------
'
' Set all cells in this worksheets to rap the text
'
'------------------------------
   
    ActiveSheet.Cells.WrapText = True
       

End Sub
Private Sub UpdateStatus()
'------------------------------
'
' Update the Status for the previously selected Cell if the target language text has changed
'
'------------------------------
        Dim workingRow As Long
    
        Dim workingColumn As Long
        Dim newTargetCellText As String
        Dim sourceCellText As String
        Dim forwardMatching As String
        Dim previousCell As Range
        Dim segID As String
        Dim actID As String
        Dim currentRow As Long
        Dim currentCol As Long
        Dim emptyTarget As Boolean
                    
        currentRow = ActiveCell.row 'Make a note of the current active cell address
        currentCol = ActiveCell.Column

        If workingCell <> Empty Then
            Set previousCell = Range(workingCell)
        
            workingRow = previousCell.row
            
            If ((workingRow < 8) Or (workingRow > lastRow)) Then 'Not in the main body
                Exit Sub
            End If
    
            workingColumn = previousCell.Column

            segID = Cells(workingRow, 2)
            
            actID = Cells(ActiveCell.row, 2)
            
            If ((finding = False) And (changedStatus = False) And (nextActiveXPressed = False) And (currentAction = RK_NULL) And ((segID <> Empty) And (actID <> Empty))) Then
                Dim seg As Long
                Dim act As Long
                
                seg = Val(segID)
                act = Val(actID)
                
                If (((act - seg) = 1) And (doNotShowTIPAgain = False)) Then
                    
                    ShowTIP.Show
                    
                    If (ShowTIP.doNotShowTIPAgain = True) Then
                        doNotShowTIPAgain = True
                    End If
                    
                    On Error Resume Next
                    
                    Cells(currentRow, 1).Activate
                    Cells(currentRow, 1).Select
                    Cells(currentRow, currentCol).Select 'Reselect the current cell
                    
                    'MsgBox ("TIP:" & vbLf & _
                    '        "You can use the TAB key to move to the next segment." & vbLf & _
                    '        "Click on the help icon or press F1 to see a full list of keyboard shortcuts.")
                End If
            End If
       
            'MsgBox "UpdateStatus(): workingCell = '" & workingCell & "'"
                
            inlineError = False
            
            sourceCellText = Cells(workingRow, 3)
                
            newTargetCellText = Trim(Cells(workingRow, 4))

' Check spelling commented out for individual segments for the time being
            If (sourceCellText <> newTargetCellText) And _
               (Cells(workingRow, 5) <> "I") And _
               (SpellCheckEachSegment = True) And _
               (ThisWorkbook.Sheets("data").Cells(workingRow, 4) <> "IS_MERGED") Then 'do not spell check ICE matches, nor merged segments
                
                If Not SpellCheckWords(newTargetCellText) Then 'Check spelling before invoking Excel Dialog spell checker
                    Call CheckTargetSpelling(workingRow)
                    newTargetCellText = Cells(workingRow, 4)
                End If
            End If
            
            'If ((Trim(targetCellText) <> Trim(newTargetCellText)) And (Trim(newTargetCellText) <> Trim(sourceCellText)) And (Trim(targetCellText) <> Empty) And (Trim(targetCellText) <> Trim(Trim(sourceCellText)))) Then
            'If ((Trim(targetCellText) <> Trim(newTargetCellText)) And (Trim(newTargetCellText) <> Trim(sourceCellText) And (Trim(targetCellText) <> Empty) And ((ThisWorkbook.workflowStage = CORRECT) Or (Trim(targetCellText) <> Trim(Trim(sourceCellText)))))) Then
            If ( _
                (Trim(targetCellText) <> Trim(newTargetCellText)) And _
                (Trim(newTargetCellText) <> Trim(sourceCellText)) And _
                (Trim(targetCellText) <> Empty)) Then 'Segment has been modified - set flag
                ThisWorkbook.Sheets("data").Cells(workingRow, SEGMENT_MODIFIED_OFFLINE) = MODIFIED
                
                If (ThisWorkbook.workflowStage = CORRECT) Or _
                   (Trim(targetCellText) <> Trim(Trim(sourceCellText))) Then  'Only update version comment where we have modified the translation or we are in the corrector stage of the workflow
                    Call UpdateVersionComment(targetCellText, newTargetCellText, workingRow)
                End If
            End If

            'Reset the font for the cell
            Dim tlen As Integer
    
            tlen = Len(Cells(workingRow, 4))
            
            Cells(workingRow, 4).Characters(1, tlen).Font.ColorIndex = 1
            Cells(workingRow, 4).Characters(1, tlen).Font.FontStyle = "Normal"
            'End reset of font
        
            If (ThereAreInlines(workingRow) = True) And _
               (ThisWorkbook.Sheets("data").Cells(workingRow, 4) <> "IS_MERGED") Then
                Call CheckInlines(workingRow)
            End If
            
            If (Cells(workingRow, 2) <> Empty) And (newTargetCellText = Empty) Then
                MsgBox getLocale("WARNING_TARGET_TEXT_FOR_SEGMENT") & " " & segID & " " & getLocale("IS_EMPTY"), , getLocale("EMPTY_TARGET_TEXT")
                Cells(workingRow, 4).Interior.Color = RGB(224, 164, 163)
                Cells(workingRow, 3).Interior.Color = RGB(224, 164, 163)
                Cells(workingRow, 2).Interior.Color = RGB(255, 0, 0)
                ThisWorkbook.Sheets("data").Cells(workingRow, 4) = EMPTY_TARGET
                emptyTarget = True
            End If
                
            If (inlineError = False) Then 'Inlines OK
'                   If Not Application.CheckSpelling(Word:=newTargetCellText) Then
'                           Range(workingCell).Interior.ColorIndex = 6
'                   End If
                Dim Status As String
                Status = ThisWorkbook.Sheets("data").Cells(workingRow, 5)
                Dim toBeChecked As Integer
                
                toBeChecked = InStr(Status, "TO_BE")
                
                Dim statusIntentionallyChanged As String
                
                statusIntentionallyChanged = ThisWorkbook.Sheets("data").Cells(workingRow, 120) 'If the status has been intentionally changed then it can only be intentionally chnaged again
                
                
                If ((statusIntentionallyChanged = Empty) And _
                    (ThisWorkbook.Sheets("data").Cells(workingRow, 4) <> EMPTY_TARGET) And _
                    (changedStatus = False) And ((targetCellText <> newTargetCellText) Or _
                    (((targetCellText = newTargetCellText) And (targetCellText <> sourceCellText)) And _
                                (toBeChecked <> 0))) Or _
                     ((statusIntentionallyChanged = Empty) And (Cells(workingRow, 5) = "N") And (toBeChecked <> 0))) Then 'Target has changed or we have reviewed a translation and the status has not been changed manually by the user
                    Call UpdateStatusCells(workingRow, "StatusDONE")
                End If
                
                If (ThisWorkbook.workflowStage = CORRECT) Then 'No forward matching for corrector stage
                    forwardMatching = Empty
                Else
                    forwardMatching = ThisWorkbook.Sheets("data").Cells(workingRow, 15)
                End If
                
                If ((targetCellText <> newTargetCellText) And (forwardMatching <> Empty)) Then 'Target has changed and we have foward matching
                    Call MatchForward(workingRow, forwardMatching, newTargetCellText)
                        
                End If
                
                If (ThisWorkbook.canChangeTarget = True) Then
                    Dim sigSpaces As Integer
                
                    sigSpaces = InStr(newTargetCellText, "{sp}")
                
                    If (sigSpaces <> 0) Then
                        Call DecorateSigSpaces
                    End If
                End If

                If (ThisWorkbook.Sheets("data").Cells(workingRow, 4) = INVALID_INLINES) Or _
                   ((ThisWorkbook.Sheets("data").Cells(workingRow, 4) = EMPTY_TARGET) And (emptyTarget = False)) Then 'Corrected invalid inlines
                    ThisWorkbook.Sheets("data").Cells(workingRow, 4) = "TARGET"
                End If
            ElseIf (inlineError = True) Then
                ThisWorkbook.Sheets("data").Cells(workingRow, 4) = INVALID_INLINES
                'Range(workingCell).Select ' If we have an error then select old cell again
                
                'If MacOS = False Then
                '    Application.SendKeys "{F2}", True
                'End If
            End If
            
            If (ThisWorkbook.Sheets("data").Cells(workingRow, 10) <> Empty) Then 'we have terms
                Call DecorateTerms(workingRow)
            End If
        End If

End Sub
Private Sub DecorateTerms(workingRow As Long)
'------------------------------
'
' Decorate the terms in the target segment
'
'------------------------------
    Dim i As Long
    Dim count As Integer
    
    Dim srcTerms() As Variant
    Dim tgtTerms() As Variant
    
    For i = workingRow + 1 To lastRow
        If (Cells(i, 2) <> Empty) Then
            Exit For
        End If
    
        If (((Cells(i, 3) <> Empty) And (Cells(i, 4) <> Empty)) And _
            (ThisWorkbook.Sheets("data").Cells(i, 3) = "TERMSOURCE")) Then
            count = count + 1
            
        End If
    Next i

    ReDim srcTerms(count)
    ReDim tgtTerms(count)
    
    count = 0
    
    For i = workingRow + 1 To lastRow
        If (Cells(i, 2) <> Empty) Then
            Exit For
        End If
    
        If (((Cells(i, 3) <> Empty) And (Cells(i, 4) <> Empty)) And _
            (ThisWorkbook.Sheets("data").Cells(i, 3) = "TERMSOURCE")) Then

            srcTerms(count) = Cells(i, 3)
            tgtTerms(count) = Cells(i, 4)
            count = count + 1
        End If
    Next i
    
    'Cells(workingRow, 4).Characters.Font.ColorIndex = 1
    'Cells(workingRow, 4).Characters.Font.FontStyle = "Normal"
    
    Dim targetText As String
    Dim Term As String
    
    Dim x, y As Integer
    Dim trans As Boolean
    
    If (Cells(workingRow, 3) <> Cells(workingRow, 4)) Then 'Has the target segment been translated
        trans = True
    End If
                        
    targetText = Cells(workingRow, 4)
    
    Dim srcTerm As String
    Dim theTerm As String
    Dim tlen As Integer
    
    For x = 0 To count - 1
        If (trans = True) Then
            theTerm = CStr(tgtTerms(x))
        Else
            theTerm = CStr(srcTerms(x))
        End If
        
        tlen = Len(theTerm)
        y = 1
        
        Do While (y <> 0)
            On Error Resume Next
            y = InStr(y, targetText, theTerm)
            If (y <> 0) Then
                Cells(workingRow, 4).Characters(y, tlen).Font.ColorIndex = 5
                Cells(workingRow, 4).Characters(y, tlen).Font.FontStyle = "Bold"
                y = y + tlen
            End If
            
        Loop
          
    Next x
    
End Sub
Private Function CheckTargetSpelling(workingRow As Long) As Boolean
'------------------------------
'
' Check target text spelling
'
'------------------------------
        Dim dumbCell As Range
        Dim checkCell As Range
        Dim spellReturn As Variant
                
        Set dumbCell = Range("A1:A2")
        Set checkCell = Cells(workingRow, 4) 'Range("D" & workingRow)
        
        Cells(workingRow, 4).Interior.Color = RGB(255, 235, 204)
        
        Dim existingComment As String
        
        On Error GoTo ErrHandler
        
        existingComment = Empty
        
        If Not (checkCell.Comment Is Nothing) Then
            existingComment = checkCell.Comment.text
            If (existingComment <> Empty) Then
                If Not SpellCheckWords(existingComment) Then
                    Cells(workingRow, 4).Locked = False
                    checkCell.ClearComments
                    'checkCell.AddComment Text:="" - do not do this, it adds a blank comment
                End If
            End If
        End If
        
        Application.ScreenUpdating = True

#If Win64 Or Win32 Then
        spellReturn = Union(dumbCell, checkCell).CheckSpelling '(, , True, langCode)
#Else
        Union(dumbCell, checkCell).CheckSpelling
        spellReturn = True
#End If
        
        Cells(workingRow, 4).Interior.ColorIndex = 0
        Application.ScreenUpdating = False
        
        If spellReturn = False Then
            CheckTargetSpelling = False
        Else
            CheckTargetSpelling = True
        End If
       
        checkCell.AddComment text:=existingComment
        
        Exit Function
        
ErrHandler:

    MsgBox "From CheckTargetSpelling()" & Err.Description
    
End Function
Function ThereAreInlines(workingRow As Long) As Boolean
'------------------------------
'
' Are there any inlines for this segment
'
'------------------------------
    Dim inlines As Boolean
    
    inlines = False
    
    If ThisWorkbook.Sheets("data").Cells(workingRow, 6) <> Empty Then
        inlines = True
    End If
    
    ThereAreInlines = inlines
    
End Function
Private Sub CheckInlines(workingRow As Long)
'------------------------------
'
' Check to see if any inlines have been deleted
'
'------------------------------
        Dim sourceString As String
        Dim targetString As String
        Dim i As Integer
        Dim srcInlines As Variant
        Dim tgtInlines(512) As String

        Dim targetInline As String
        Dim tgtCount As Integer
        
        Dim x As Integer
        
        Dim srcI As String
        Dim tgtI As String
        Dim SEGNO As String
        Dim noInlines As Integer
        Dim y As Integer
        Dim z As Integer
        
        Dim tmpI As String
        
        Dim errorMessage As String
        
        inlineError = False
        

        sourceString = Cells(workingRow, 3)
        targetString = Cells(workingRow, 4)

        srcInlines = GetInlinesForRow(workingRow)
        
        y = Len(targetString)
        Cells(workingRow, 4).Characters(1, y).Font.ColorIndex = 1
        Cells(workingRow, 4).Characters(1, y).Font.FontStyle = "Normal"
        
        tgtCount = 0
        
'        Dim lookFor As String
'
'        Static RegEx As Object
'
'        If RegEx Is Nothing Then
'                Set RegEx = CreateObject("VBScript.RegExp")
'                With RegEx
'                        .Global = True
'                        .Pattern = "\{[0-9]\}"
'                End With
'        End If
'        tgtInlines = Trim(RegEx.Execute(targetString))

    noInlines = UBound(srcInlines)
      
    Dim inlines(512) As InlineInfo
        
    For i = 0 To noInlines
        inlines(i).ID = srcInlines(i)
        inlines(i).Found = 0
        inlines(i).Single = True
        
        For x = i + 1 To noInlines
            If (srcInlines(x) = inlines(i).ID) Then
                inlines(i).Single = False
                Exit For
            End If
        Next x
    Next i
    
    x = 1
        
    Do While x <> 0
        x = InStr(x, targetString, "{")
        If (x <> 0) Then
            y = InStr(x, targetString, "}")
                
            If ((x <> 0) And (y <> 0)) Then
                tmpI = Mid(targetString, x + 1, y - x - 1)
                
                If AllNumeric(tmpI) Then
                    tmpI = Mid(targetString, x, y - x + 1)
                    
                    For i = 0 To noInlines
                        If inlines(i).ID = tmpI Then
                            If inlines(i).Single = True Then
                                Cells(workingRow, 4).Characters(x, y - x + 1).Font.ColorIndex = 5
                            Else
                                Cells(workingRow, 4).Characters(x, y - x + 1).Font.ColorIndex = 10
                            End If
                    
                            Cells(workingRow, 4).Characters(x, y - x + 1).Font.FontStyle = "Bold"
                            
                            Exit For
                        End If
                    Next i
                    
                    tgtInlines(tgtCount) = Mid(targetString, x, y - x + 1)
                    tgtCount = tgtCount + 1
                End If
                x = x + 1
            Else
                x = 0
            End If
        End If
    Loop
        
        
    SEGNO = Cells(workingRow, 2)

    For i = 0 To tgtCount - 1
        tgtI = tgtInlines(i)
        For x = 0 To noInlines
            If ((inlines(x).ID = tgtI) And (inlines(x).Found = 0)) Then
                inlines(x).Found = 1
                Exit For
            End If
                Next x
        If (x > noInlines) Then
            errorMessage = errorMessage & tgtI & " " & getLocale("IS_NOT_REQUIRED") & vbLf
            'MsgBox ("Segment " & segNo & " has an inline error: " & tgtI & " is not required"), vbOKOnly, "Inline Error"
            inlineError = True
        End If
    Next i

    For i = 0 To noInlines
        If (inlines(i).Found = 0) Then
            srcI = inlines(i).ID
            errorMessage = errorMessage & srcI & " " & getLocale("IS_MISSING") & vbLf
            'MsgBox ("Segment " & segNo & " has an inline error. " & srcI & " is missing. Please check"), vbOKOnly, "Inline Error"
            
            inlineError = True
        End If
    Next i

    For i = 0 To tgtCount
        tgtI = tgtInlines(i)
        For x = i + 1 To tgtCount
            If (tgtI = tgtInlines(x)) Then ' This inline contains other inlines
                For y = i + 1 To x - 1
                    tmpI = tgtInlines(y) ' Go through all the encompassed inlines and see if they cross over the current inline
                    For z = y To tgtCount
                        If (tmpI = tgtInlines(z)) And (z > x) Then
                            errorMessage = errorMessage & tmpI & " " & getLocale("OVERLAPS_WITH") & tgtI & vbLf
                            'MsgBox ("Segment " & segNo & " has an inline error. " & tmpI & " overlaps with " & tgtI & ". Please check"), vbOKOnly, "Inline Error"
                            inlineError = True
                        End If
                    Next z
                Next y
            End If
        Next x
    Next i
        
    If (inlineError = True) Then 'Reset colour if all is now OK
        ThisWorkbook.Sheets("data").Cells(workingRow, 4) = INVALID_INLINES
        Cells(workingRow, 4).Interior.Color = RGB(224, 164, 163) '3 = red
        Cells(workingRow, 3).Interior.Color = RGB(224, 164, 163)
        Cells(workingRow, 2).Interior.Color = RGB(255, 0, 0)
        MsgBox getLocale("SEGMENT") & " " & SEGNO & " " & getLocale("HAS_THE_FOLLOWING_INLINE_ERRORS") & ": " & vbLf & errorMessage, vbOKOnly, getLocale("INLINE_ERROR")
    Else
        Cells(workingRow, 4).Interior.Color = RGB(255, 255, 255)
    End If
    
End Sub

Function AllNumeric(testString As String) As Boolean
'------------------------------
'
' Check to see if all of the string is numeric
'
'------------------------------
    Dim numeric As Boolean
    
    numeric = True
    
    Dim i As Integer
    
    For i = 1 To Len(testString)
        If (IsNumeric(Mid(testString, i, 1)) <> True) Then
            numeric = False
            
            Exit For
        End If
    Next i
    
    AllNumeric = numeric
    
End Function
Private Sub MatchForward(ByRef workingRow, ByRef forwardMatching, ByRef newTargetCellText)
'------------------------------
'
' Update any forward matches as required
'
'------------------------------
    Dim Matches As Variant
    Dim i As Integer
    Dim noMatches As Integer
    Dim matchRow As Long
    Dim currentStatus As String
        
    Matches = Split(forwardMatching, ",")
    noMatches = UBound(Matches)
        
    For i = 0 To noMatches - 1
        matchRow = Val(Matches(i))
        Dim mainMatchRow As Long
                
        mainMatchRow = GetMainRow(matchRow)
                
        currentStatus = ThisWorkbook.Sheets("data").Cells(mainMatchRow, 5)
              
        If Not ((InStr(currentStatus, TO_BE_DONE) = 0) And (InStr(currentStatus, "DONE") <> 0)) Then 'Not green status
            Cells(mainMatchRow, 4) = newTargetCellText 'Copy target text
            Cells(matchRow, 4) = newTargetCellText
            If ThisWorkbook.Sheets("data").Cells(matchRow, 4) = "MATCHLEVERAGED_INHERITED_REPETITION_TARGET" Then
                        '-- Cells(matchRow, 4).Style = "TargetMatched"
                Call UpdateStatusCells(matchRow, "StatusCHECK")
            End If
        End If
    Next i

End Sub
Private Function GetMainRow(workingRow As Long) As Long
'------------------------------
'
' Find the main row for this working row
'
'------------------------------

    Dim i As Long
    Dim mainRow As Long
   
    If Cells(workingRow, 2) = Empty Then
        For i = workingRow - 1 To 1 Step -1
            If Cells(i, 2) <> Empty Then
                mainRow = i
                Exit For
            End If
        Next i
    Else
        mainRow = workingRow
    End If
    
    GetMainRow = mainRow

End Function
Private Sub UpdateWorkflowStatusCells(workingRow As Long, statusStyle As String, Status As String, statusLetter As String)
'------------------------------
'
' Update the Status for the previously selected Cell if the target language text has changed
'
'------------------------------

    Dim i As Long
    Dim mainRow As Long
   
    
    mainRow = GetMainRow(workingRow)
    
    Cells(mainRow, 5).style = statusStyle
    '-- Cells(mainRow, 4).Style = "Done"
    With Range("B" & mainRow & ":E" & mainRow)
        With .Borders(xlEdgeBottom)
                 .LineStyle = xlContinuous
                 .Weight = xlThin
        End With
    End With
    
    ThisWorkbook.Sheets("data").Cells(mainRow, 5) = Status
    
    Cells(mainRow, 5) = statusLetter
      
    For i = mainRow + 1 To lastRow
        If ((Cells(i, 2) = Empty) And (Cells(i, 3) = Empty) And (Cells(i, 4) = Empty)) Then
            i = i - 1
            With Range("B" & i & ":E" & i)
                With .Borders(xlEdgeBottom)
                     .LineStyle = xlContinuous
                     .Weight = xlThin
                End With
            End With
            Exit For
        End If
        If Cells(i, 2) = Empty Then 'And Cells(i, 21) <> Empty Then 'Column "U" - COLUMNHEADER will always be populated, ergo if it is empty then we have reached the end
            Cells(i, 5).style = statusStyle
        Else
            Exit For
        End If
    Next i
    
    ThisWorkbook.Sheets("data").Cells(mainRow, 120) = Status
    changedStatus = True
    
    Cells(workingRow, 4).Select
    Application.SendKeys "{F2}"
    DoEvents
    
End Sub



Private Sub UpdateStatusCells(workingRow As Long, ByRef statusType)
'------------------------------
' DEPRECATED - replaced by UpdateWorkflowStatusCells
' Update the Status for the previously selected Cell if the target language text has changed
'
'------------------------------

    Dim i As Long
    Dim mainRow As Long
   
'    If Cells(workingRow, 2) = Empty Then
'        For i = workingRow - 1 To 1 Step -1
'            If Cells(i, 2) <> Empty Then
'                mainRow = i
'                Exit For
'            End If
'        Next i
'    Else
'        mainRow = workingRow
'    End If
    
    mainRow = GetMainRow(workingRow)
    
    Cells(mainRow, 5).style = statusType
    '-- Cells(mainRow, 4).Style = "Done"
    With Range("B" & mainRow & ":E" & mainRow)
        With .Borders(xlEdgeBottom)
                 .LineStyle = xlContinuous
                 .Weight = xlThin
        End With
    End With
    
    If statusType = "StatusDONE" Then
        ThisWorkbook.Sheets("data").Cells(mainRow, 5) = "DONE"
    ElseIf statusType = "StatusREJECTED" Then
        ThisWorkbook.Sheets("data").Cells(mainRow, 5) = "TO_BE_CORRECTED"
    ElseIf statusType = "StatusCHECK" Then
        ThisWorkbook.Sheets("data").Cells(mainRow, 5) = "TO_BE_CHECKED"
    ElseIf statusType = "StatusTODO" Then
        ThisWorkbook.Sheets("data").Cells(mainRow, 5) = "TO_BE_DONE"
    End If
    
    'lastRow = ActiveSheet.UsedRange.Rows.Count
      
    For i = mainRow + 1 To lastRow
        If ((Cells(i, 2) = Empty) And (Cells(i, 3) = Empty) And (Cells(i, 4) = Empty)) Then
                i = i - 1
                With Range("B" & i & ":E" & i)
                        With .Borders(xlEdgeBottom)
                                      .LineStyle = xlContinuous
                                      .Weight = xlThin
                          End With
                End With
                Exit For
        End If
        If Cells(i, 2) = Empty Then 'And Cells(i, 21) <> Empty Then 'Column "U" - COLUMNHEADER will always be populated, ergo if it is empty then we have reached the end
                Cells(i, 5).style = statusType
        Else
                Exit For
        End If
    Next i
 
End Sub
Private Sub FormatComment(currentRow As Long)
'------------------------------
'
' Format the comment text for colour
'
'------------------------------
    
    Dim i, x, y As Long
    Dim endChar As String
    Dim theComment As Comment
    Dim commentData As String
    
    Cells(currentRow, 4).Activate
    
    Set theComment = ActiveCell.Comment
    
    commentData = ActiveCell.Comment.text
    
    'ActiveCell.COMMENT.Delete
    
    'ActiveCell.AddComment (commentData)
        
    Set theComment = ActiveCell.Comment
    
    
    On Error GoTo ErrorHandler
        'theComment.Shape.TextFrame.VerticalOverflow = xlOartVerticalOverflowOverflow
        
    If (style(0).ID = Empty) Then
            style(0).ID = getLocale("VERSION")
            style(0).Color = 3
            style(0).EndsWithCollon = False
            style(0).Bold = True
        
            style(1).ID = getLocale("LAST_MODIFIED")
            style(1).Color = 5
            style(1).EndsWithCollon = False
            style(1).Bold = False
        
            style(2).ID = getLocale("COMMENT_STR")
            style(2).Color = 3
            style(2).EndsWithCollon = False
            style(2).Bold = True
        
            style(3).ID = getLocale("BY") & ":"
            style(3).Color = 3
            style(3).EndsWithCollon = True
            style(3).Bold = False
        
            style(4).ID = getLocale("DATE_COLLON") & ":"
            style(4).Color = 3
            style(4).EndsWithCollon = True
            style(4).Bold = False
            
            style(5).ID = getLocale("ORIGINAL_COMMENT")
            style(5).Color = 3
            style(5).EndsWithCollon = False
            style(5).Bold = True
            
            style(6).ID = getLocale("CHANGED_FROM")
            style(6).Color = 5
            style(6).EndsWithCollon = False
            style(6).Bold = True
            
            style(7).ID = getLocale("LC_TO")
            style(7).Color = 5
            style(7).EndsWithCollon = False
            style(7).Bold = True
            
            style(8).ID = getLocale("LC_BY")
            style(8).Color = 5
            style(8).EndsWithCollon = False
            style(8).Bold = True
            
            style(9).ID = getLocale("LC_DATE")
            style(9).Color = 5
            style(9).EndsWithCollon = False
            style(9).Bold = True
    End If
        
    With theComment.Shape.TextFrame
        .AutoSize = False
        .Characters.Font.Name = "Calibri"
        .Characters.Font.Size = 12
        .Characters.Font.ColorIndex = 1
    End With

    Dim startTime As Date
    Dim endTime As Date
        
    x = 0
        
    For i = 0 To 9
        Debug.Print ("UpdateComment style(" & i & "): " & style(i).ID & ", start time: " & Format(DateTime.now, "yyyy-MM-dd hh:mm:ss"))
        startTime = DateTime.now
        Do
            x = InStr(x + 1, commentData, style(i).ID)
            
            If (x <> 0) Then
                y = InStr(x, commentData, ":")
                
                If (y <> 0) Then
                    With theComment.Shape.TextFrame
                        .Characters(x, y - x).Font.ColorIndex = style(i).Color
                        .Characters(x, y - x).Font.Bold = style(i).Bold
                    End With
                End If
            End If
        Loop While x <> 0
        Debug.Print ("UpdateComment style(" & i & "): " & style(i).ID & ", end time: " & Format(DateTime.now, "yyyy-MM-dd hh:mm:ss"))
        endTime = DateTime.now
        Debug.Print ("Time taken = " & endTime - startTime)
    Next i
        
    Call HighlightDifferences
        
    With theComment.Shape
        .TextFrame.AutoSize = True
    End With
        
ErrorHandler:
    'MsgBox "ERROR" & Err.Number & ": " & Error.Description
    'Exit Sub
End Sub

Private Sub HighlightDifferences()
'------------------------------
'
' Highlight the differences between versions quoted in comments
'
'------------------------------
    Dim i, x, y  As Long
    Dim endChar As String
    Dim theComment As Comment
    Dim commentData As String
    
    Set theComment = ActiveCell.Comment
    
    commentData = theComment.text

    x = InStr(x + 1, commentData, getLocale("CHANGED_FROM"))
        
    Do While x <> 0
        Dim before As String
        Dim after As String
            
        Dim z As Long
            
        z = InStr(x, commentData, getLocale("LC_TO"))
            
        If (z = 0) Then
            Exit Sub
        End If
        
       
        x = x + Len(getLocale("CHANGED_FROM")) + 1 'The + 1 is for the vbNewLine
                
        before = Mid(commentData, x, z - x)
        
        With theComment.Shape.TextFrame 'Reset the font and colour
            .Characters(x, z - x).Font.ColorIndex = 1
            .Characters(x, z - x).Font.Bold = False
        End With
                
        y = InStr(z + 1, commentData, getLocale("LC_BY"))
                
        If (y = 0) Then
            after = Mid(commentData, z + 3)
        Else
            z = z + Len(getLocale("LC_TO")) + 1
            after = Mid(commentData, z, y - z)
        End If
        
        With theComment.Shape.TextFrame 'Reset the font and colour
            .Characters(z, Len(after)).Font.ColorIndex = 1
            .Characters(z, Len(after)).Font.Bold = False
        End With
        
        'Exit Sub
        
        Dim noBeforeWords As Integer
        Dim noAfterWords As Integer
        Dim beforeWords As Variant
        Dim afterWords As Variant
        
        Dim beforeWordMap As Collection
        Dim afterWordMap As Collection
        
        Dim word As String
        
        before = Normalize(before)
        after = Normalize(after)

        beforeWords = Split(before)
    
        noBeforeWords = UBound(beforeWords)
        
        afterWords = Split(after)
    
        noAfterWords = UBound(afterWords)
        
        Set beforeWordMap = New Collection
        Set afterWordMap = New Collection
        
        Dim i1, i2 As Integer
        
        i1 = x
        
        Dim stringDiff As StringDiffObject
        
        For i = 0 To noBeforeWords - 1 'Store before words
            word = beforeWords(i)
            
            If Not (Trim(word) = "") Then
                i1 = InStr(i1, commentData, word)
            
                Set stringDiff = New StringDiffObject
            
                stringDiff.TheStart = i1
                stringDiff.TheWord = word
            
                beforeWordMap.Add stringDiff
            End If
        Next i
        
        noBeforeWords = beforeWordMap.count
        
        i1 = z
        
        For i = 0 To noAfterWords - 1 'Store after words
            word = afterWords(i)
            
            If Not (Trim(word) = "") Then
                i1 = InStr(i1, commentData, word)
            
                Set stringDiff = New StringDiffObject
            
                stringDiff.TheStart = i1
                stringDiff.TheWord = word
            
                afterWordMap.Add stringDiff
            End If
        Next i
        
        noAfterWords = afterWordMap.count
        
        Dim beforeStringDiff, afterStringDiff As StringDiffObject
        
        For i = 0 To noAfterWords - 1
            Set stringDiff = afterWordMap.Item(i + 1)
                
            For y = 0 To noBeforeWords - 1
                Set beforeStringDiff = beforeWordMap(y + 1)
                
                If ((beforeStringDiff.IsUsed = False) And (stringDiff.TheWord = beforeStringDiff.TheWord)) Then
                'If (stringDiff.TheWord = beforeStringDiff.TheWord) Then
                    stringDiff.Used = True
                    beforeStringDiff.Used = True
                    Exit For
                End If
            Next y
        Next i
            
        If (noBeforeWords = noAfterWords) Then
            For i = 0 To noBeforeWords - 1
                
                Set beforeStringDiff = beforeWordMap.Item(i + 1)
                Set afterStringDiff = afterWordMap.Item(i + 1)
                
                If (beforeStringDiff.TheWord <> afterStringDiff.TheWord) Then
                    Set stringDiff = afterWordMap.Item(i + 1)
                    
                    i1 = stringDiff.TheStart
                    i2 = stringDiff.TheLength '+ i1
                    
                    With theComment.Shape.TextFrame
                        .Characters(i1 - 1, i2 + 1).Font.ColorIndex = 32
                        .Characters(i1 - 1, i2 + 1).Font.Bold = False
                    End With
                    
                    Set stringDiff = beforeWordMap.Item(i + 1)
                    
                    i1 = stringDiff.TheStart
                    i2 = stringDiff.TheLength '+ i1
                    
                    With theComment.Shape.TextFrame
                        .Characters(i1 - 1, i2).Font.ColorIndex = 3
                        .Characters(i1 - 1, i2).Font.Strikethrough = True
                    End With
                End If
            Next i
        Else
            
            For i = 0 To noBeforeWords - 1
                Set stringDiff = beforeWordMap.Item(i + 1)
                
                If (stringDiff.IsUsed = False) Then
                    stringDiff.Used = True
                    i1 = stringDiff.TheStart
                    i2 = stringDiff.TheLength '+ i1
                    
                    With theComment.Shape.TextFrame
                        .Characters(i1 - 1, i2).Font.ColorIndex = 3
                        .Characters(i1 - 1, i2).Font.Strikethrough = True
                    End With
                End If
                
            Next i
           
            For i = 0 To noAfterWords - 1
                Set stringDiff = afterWordMap.Item(i + 1)
                
                If (stringDiff.IsUsed = False) Then
                    stringDiff.Used = True
                    i1 = stringDiff.TheStart
                    i2 = stringDiff.TheLength '+ i1
                    
                    With theComment.Shape.TextFrame
                        .Characters(i1 - 1, i2).Font.ColorIndex = 32
                        .Characters(i1 - 1, i2).Font.Bold = False
                    End With
                End If
                
            Next i
            
        End If
                
        'Exit Sub
        
        x = InStr(x + 1, commentData, getLocale("CHANGED_FROM"))
    Loop


End Sub

Private Sub Unhide()
'------------------------------
'
' Unhide any hidden terminology/matching rows for the newly selected Cell
'
'------------------------------
    Dim i As Long
    Dim j As Long
    'Dim lastRow As Long
    Dim currentRow As Long
    Dim currentCol As Long
    
    Dim topOffset As Long
    Dim headerOffset As Long
    
    Dim topCell As Range
    
    Dim factor As Double
    Dim width As Double
    Dim height As Double
    Dim lArea As Double
    
'    If (SimpleView) Then
'        Exit Sub
'    End If
    
    currentRow = ActiveCell.row
    currentCol = ActiveCell.Column
        
    Cells(currentRow, 4).Interior.Color = RGB(221, 224, 240)
    Cells(currentRow, 3).Interior.Color = RGB(221, 224, 240)
    Cells(currentRow, 2).Interior.Color = RGB(221, 224, 240)
    
    With Cells(7, 5)
        headerOffset = .Top + 15
    End With

    'topOffset = topCell.top
    
    If (ThisWorkbook.Sheets("data").Cells(currentRow, 4) = "IS_MERGED") Then 'Do not allow editing of merged segments
        Cells(currentRow, 4).Locked = True
    Else
        Cells(currentRow, 4).Locked = False
        Cells(currentRow, 3).Locked = False
    
        If (Not (Cells(currentRow, 4).Comment Is Nothing)) Then
            Call FormatComment(currentRow)
            Cells(currentRow, currentCol).Select
        End If
        
        ThisWorkbook.Sheets("data").Cells(currentRow, 1) = Cells(currentRow, 3) 'Make a copy of the source
    End If
    
    'Cells(currentRow, 3).Locked = True
    Cells(currentRow, 2).Locked = True
        
    Range("B" & currentRow & ":E" & currentRow).Borders(xlEdgeBottom).LineStyle = xlNone

    'lastRow = ActiveSheet.UsedRange.Rows.Count
    Dim matchedText As String
    
    If (ShowAllComments = True) Then
        topOffset = CalcTopOffset(headerOffset, currentRow)
    End If

    'If (SimpleView = False) Then
        For i = currentRow To lastRow
            If (((Cells(i, 2) = Empty) And (Cells(i, 3) = Empty) And (Cells(i, 4) = Empty)) Or _
                ((i <> currentRow) And (Rows(i).Hidden = False))) Then
                Exit For
            End If
            'Rows(i).Select
            If (SimpleView = False) And (Rows(i).Hidden) Then
                Rows(i).Hidden = False
                Range("B" & i & ":E" & i).Cells.Locked = True
                Range("B" & i & ":E" & i).Cells.WrapText = True
                Cells(i, 3).Locked = True
                Cells(i, 4).Locked = True
                
                Range("B" & i & ":D" & i).Cells.Interior.Color = RGB(221, 224, 240)
                matchedText = Cells(i, 4).text
                
                If (MatchedForwardText(matchedText) = True) Then 'Matched with segment...
                    Dim matchSeg As String
                    Dim matchText As String
                    
                    matchSeg = ThisWorkbook.Sheets("data").Cells(i, 16)
                    
                    matchText = FindMatch(matchSeg)
                    
                    If (matchText <> Empty) Then
                        Cells(i, 4).Locked = False
                        Cells(i, 4) = matchText
                        Cells(i, 4).Locked = True
                    End If
                End If
                
                'Selection.Rows.Hidden = False
                If Rows(i + 1).Hidden Then
                    Range("B" & i & ":E" & i).Borders(xlEdgeBottom).LineStyle = xlNone
                End If
            End If
            
            If (SimpleView = False) Then
                If (ShowAllComments = False) And (i = currentRow) And (Not (Cells(i, 4).Comment Is Nothing)) Then
                    With Cells(i, 4).Comment
                        .Shape.Top = .Parent.Top
                        .Shape.Left = .Parent.Offset(0, 1).Left + 34
                    End With
                    
                    Cells(i, 4).Comment.Visible = True
                ElseIf (ShowAllComments = True) And (Not (Cells(i, 4).Comment Is Nothing)) Then
                    With Cells(i, 4).Comment
                        .Shape.Top = topOffset
                        .Shape.Left = .Parent.Offset(0, 1).Left + 34
                        topOffset = topOffset + .Shape.height + 5
                    End With
                    
                    Cells(i, 4).Comment.Visible = True
                ElseIf (Not (Cells(i, 4).Comment Is Nothing)) Then
                    Cells(i, 4).Comment.Visible = False
                End If
            End If
        Next
    
    'End If
    
    If (SimpleView) Then
        Cells(currentRow, 3).Select
        Cells(currentRow, 4).Select
    End If
    
    With Range("B" & i - 1 & ":E" & i - 1)
        With .Borders(xlEdgeBottom)
             .LineStyle = xlContinuous
             .Weight = xlThin
        End With
    End With

    ActiveCell.Select

End Sub
Private Function CalcTopOffset(headerOffset As Long, currentRow As Long) As Long
'------------------------------
'
' Calculate the top offset for comments.
'
'------------------------------
    Dim i As Long
    Dim totalSegHeight As Long
    Dim topOffset As Long
    Dim commentHeight As Long
    Dim y As Long
    Dim z As Long
    
    For i = currentRow To lastRow
        If (((Cells(i, 2) = Empty) And (Cells(i, 3) = Empty) And (Cells(i, 4) = Empty)) Or _
            ((i <> currentRow) And (Rows(i).Hidden = False))) Then
            Exit For
        End If
        
        If Not (Cells(i, 4).Comment Is Nothing) Then
            With Cells(i, 4).Comment
                commentHeight = commentHeight + .Shape.height + 5
            End With
        End If
    Next
    
    With Cells(currentRow, 4)
        topOffset = .Top
    End With
    
    totalSegHeight = (i - currentRow) * 15
    
    y = totalSegHeight / 2
    
    z = (commentHeight / 2) - 15
    
    If ((topOffset + y) - z) > headerOffset Then
        CalcTopOffset = (topOffset + y) - z
    Else
        CalcTopOffset = headerOffset
    End If
    
End Function
Private Function FindMatch(SEGNO As String) As String
'------------------------------
'
' Find the match text if it has been translated
'
'------------------------------
    Dim i As Integer
    
    FindMatch = Empty
    
    For i = ActiveCell.row To 8 Step -1
        If (Cells(i, 2) = SEGNO) Then
            If (Cells(i, 3) <> Cells(i, 4)) Then
                FindMatch = Cells(i, 4).text
            End If
            Exit For
        End If
    Next i
        
End Function

Private Function MatchedForwardText(theText As String) As Boolean
'------------------------------
'
' Does the text begin with "Matched with Segment" ?
'
'------------------------------
    If (UCase(Left(theText, 20)) = UCase("Matched with Segment")) Then
        MatchedForwardText = True
    Else
        MatchedForwardText = False
    End If
    
End Function
Private Sub Hide()
'------------------------------
'
' Hide any hidden terminology/matching rows for the previously selected Cell
'
'------------------------------

    Dim currentRow As Long
    Dim currentColumn As Long
    Dim i As Long
    'Dim lastRow As Long
    
    'lastRow = ActiveSheet.UsedRange.Rows.Count
'    If (SimpleView) Then
'        Exit Sub
'    End If
    
    If workingCell <> Empty Then
        'MsgBox "Hide(): workingCell = '" & workingCell & "'"

        currentRow = Range(workingCell).row
    
        currentColumn = Range(workingCell).Column
        
        Cells(currentRow, 4).Locked = True
        If Not (Cells(currentRow, 4).Comment Is Nothing) Then
            Cells(currentRow, 4).Comment.Visible = False
        End If
        
        If (ThisWorkbook.Sheets("data").Cells(currentRow, 1) <> Empty) And (ThisWorkbook.Sheets("data").Cells(currentRow, 1) <> Cells(currentRow, 3)) Then 'If the source text has been damaged then restore from backup made in Unhide() sub
            Cells(currentRow, 3) = ThisWorkbook.Sheets("data").Cells(currentRow, 1)
        End If
        
        'Application.ScreenUpdating = True

        If (ThisWorkbook.Sheets("data").Cells(currentRow, 4) <> INVALID_INLINES) And _
           (ThisWorkbook.Sheets("data").Cells(currentRow, 4) <> EMPTY_TARGET) Then
            Cells(currentRow, 2).Interior.Color = RGB(255, 255, 255)
            Cells(currentRow, 3).Interior.Color = RGB(255, 255, 255)
            If ((ThisWorkbook.workflowStage = CORRECT) And (ThisWorkbook.Sheets("data").Cells(currentRow, SEGMENT_MODIFIED_OFFLINE) = MODIFIED)) Then
                Cells(currentRow, 4).Interior.Color = RGB(255, 255, 153)
            Else
                Cells(currentRow, 4).Interior.Color = RGB(255, 255, 255)
            End If
        End If
        
        With Range("B" & currentRow & ":E" & currentRow) ' Do thick line for main segment row
            With .Borders(xlEdgeBottom)
                 .LineStyle = xlContinuous
                 .Weight = xlThin
            End With
        End With
       
        'If currentColumn = 4 And Cells(currentRow, 2) <> Empty Then
        If Cells(currentRow, 2) <> Empty Then
            For i = currentRow + 1 To lastRow 'CHANGE 21 to 1
                If Cells(i, 2) = Empty And ThisWorkbook.Sheets("data").Cells(i, 2) <> Empty Then 'Column "U" - COLUMNHEADER will always be populated, ergo if it is empty then we have reached the end
                    Rows(i).Hidden = True
                    With Range("B" & i & ":E" & i)
                        With .Borders(xlEdgeBottom)
                             .LineStyle = xlContinuous
                             .Weight = xlThin
                        End With
                    End With
                Else
                    Exit For
                End If
                
                If ((Cells(i, 2) = Empty) And (Cells(i, 3) = Empty) And (Cells(i, 4) = Empty)) Then
                    Exit For
                End If
            Next i
                 
            With Range("B" & i - 1 & ":E" & i - 1)
                With .Borders(xlEdgeBottom)
                     .LineStyle = xlContinuous
                     .Weight = xlThin
                End With
            End With
        End If
        
    End If
End Sub
Private Sub CopyTerm()
'------------------------------
'
' Try and copy Term into target text
'
'------------------------------

        Dim targetTerm As String
        Dim sourceTerm As String
        
        Dim targetText As String
        
        Dim rowNumber As Long
        Dim originalRow As Long
        
        Dim tlen As Integer
        
        If (ThisWorkbook.canChangeTarget = True) Then
            originalRow = ActiveCell.row

            targetTerm = ActiveCell.text
            tlen = Len(targetTerm)
        
            sourceTerm = Cells(ActiveCell.row, 3)
        
            For rowNumber = originalRow - 1 To 2 Step -1
                If Cells(rowNumber, 2) <> Empty Then
                    targetText = Cells(rowNumber, 4).text
                        
                    targetText = REPLACE(targetText, sourceTerm, targetTerm)
                        
                    Cells(rowNumber, 4) = targetText
                    
                    Cells(rowNumber, 4).Characters.Font.ColorIndex = 1
                    Cells(rowNumber, 4).Characters.Font.FontStyle = "Normal"
                    
                    Dim i As Integer
                        
                    For i = 1 To Len(targetText)
                        If Mid(targetText, i, tlen) = targetTerm Then
                            Cells(rowNumber, 4).Characters(i, tlen).Font.ColorIndex = 5
                            Cells(rowNumber, 4).Characters(i, tlen).Font.FontStyle = "Bold"
                            i = i + tlen
                        End If
                    Next i
            
                        'ActiveWorkbook.Save
                    Exit For
                End If
            Next rowNumber
        End If

End Sub

Private Sub CopyTranslation()
'------------------------------
'
' Copy any leveraged/fuzzy matching automatically upon selection to the target Cell
'
'------------------------------
        Dim matchedRow As Long
        Dim matchedCell As String
        Dim matchedText As String
        Dim intMessage As Integer

        matchedText = ActiveCell.text
        
   
        matchedRow = ActiveCell.row
        
       'CHANGE 20 to 0
        If ((matchedText <> Empty) And (UCase(Left(matchedText, 20)) <> UCase("Matched with Segment")) And _
            (ThisWorkbook.Sheets("data").Cells(matchedRow, 17) <> Empty)) And _
            (ThisWorkbook.canChangeTarget = True) Then
            
                Dim rowNumber As Long
                
                If (ThisWorkbook.Sheets("data").Cells(matchedRow, MATCH_USED) = "USED") Then
    
                    For rowNumber = matchedRow - 1 To 2 Step -1
                        If Cells(rowNumber, 2) <> Empty Then
                            matchedCell = Cells(rowNumber, 4).text
                            Exit For
                        End If
                    Next rowNumber
                    
                    If (matchedCell <> matchedText) Then
                        intMessage = MsgBox(getLocale("DO_YOU_REALLY_WANT_TO_OVERWRITE_THE_EXISTING_TARGET_TEXT"), _
                                vbYesNo, getLocale("WARNING"))

                        If intMessage <> vbYes Then
                            Exit Sub
                        End If
                    Else
                        Exit Sub 'Leveraged matching already copied
                    End If
                End If
                
                matchedCell = ActiveCell.Address
                Range(matchedCell).Select
                Selection.Copy
    
                For rowNumber = matchedRow - 1 To 2 Step -1
                    If Cells(rowNumber, 2) <> Empty Then
                        matchedCell = Cells(rowNumber, 4).Address
                        Range(matchedCell).Select
                                
                        Range(matchedCell) = matchedText
                                
                        Dim y As Integer
                                
                        y = Len(matchedText)
                        Cells(rowNumber, 4).Characters(1, y).Font.ColorIndex = 1
                        Cells(rowNumber, 4).Characters(1, y).Font.FontStyle = "Normal"

                        'ActiveSheet.PasteSpecial
 
                        'Cells(rowNumber, 4).Style = "Done"
            
                        Application.CutCopyMode = False
                        'ActiveWorkbook.Save
                                
                        ThisWorkbook.Sheets("data").Cells(matchedRow, MATCH_USED) = "USED"
                                
                        Exit For
                End If
            Next rowNumber
        End If
End Sub

Public Sub SpellCheckAllSegments()
'------------------------------
'
' Check spelling for all segments
'
'------------------------------
    Dim i As Long
    Dim text As String
    Dim currentRow As Long

    spellCheckingAllSegments = True
    
    currentRow = ActiveCell.row
    
    For i = 8 To lastRow
        
        If ((Cells(i, 2) <> Empty) And _
        ((Cells(i, 5) <> "N") And (Cells(i, 5) <> "I")) And _
        (ThisWorkbook.Sheets("data").Cells(i, 4) <> "IS_MERGED")) Then 'Do not spell check non-trans, ICE matches or MERGED segments
        
            text = Trim(Cells(i, 4))
            
            If (text = Empty) Then
                Cells(i, 4).Interior.Color = RGB(224, 164, 163)
                Cells(i, 3).Interior.Color = RGB(224, 164, 163)
                Cells(i, 2).Interior.Color = RGB(255, 0, 0)
                ThisWorkbook.Sheets("data").Cells(i, 4) = EMPTY_TARGET
            Else
                Call CheckInlines(i)
                
                If Not SpellCheckWords(text) Then
                    'Call UnprotectSheet - now done in CheckTargetSpelling
                    Cells(i, 1).Activate
                    
                    Application.GoTo ActiveCell, True
                
                    If CheckTargetSpelling(i) = False Then 'Cancel pressed in spell check
                        spellCheckingAllSegments = False
                        Exit Sub
                    End If
                    'Call ProtectSheet - now done in CheckTargetSpelling
                End If
            End If
        End If
    Next i
    
    spellCheckingAllSegments = False
    
    MsgBox getLocale("FINISHED_SPELL_CHECKING_ALL_TARGET_SEGMENTS")
    
    Cells(currentRow, 4).Activate
    Application.GoTo ActiveCell, True
    
End Sub



Function SpellCheckWords(targetString As String) As Boolean
'------------------------------
'
' Spell check all the words
'
'------------------------------
    Dim noWords As Integer
    Dim words As Variant
    Dim i As Integer
    Dim word As String

    words = Split(targetString, " ")
    
    noWords = UBound(words)
        
    For i = 0 To noWords
        word = words(i)
        If Not Application.CheckSpelling(word:=word) Then
            SpellCheckWords = False
            Exit Function
        End If
    Next i
    
    SpellCheckWords = True
    
End Function
Public Sub SetupOptionsShow()
    SetupOptions.Show
End Sub
Public Sub FindAndReplace()
'------------------------------
'
' kick off the Find window
'
'------------------------------
    'FindAndReplaceDialog.Show vbModeless
    
    finding = True
    
    
    FindAndReplaceDialog.Show vbModeless
    
    'Call UnprotectSheet
    
    'Application.CommandBars("Edit").Controls("Find...").Execute 'Will trigger WOrksheet_SelectionChange
    'Application.Dialogs(xlDialogFormulaFind).Show ' Will NOT trigger WOrksheet_SelectionChange
    
    'Call ProtectSheet
    
    finding = False
    
End Sub
Public Sub ReplaceAllText()
'------------------------------
'
' Replace all searchString text with ReplaceText
'
'------------------------------

    If FindAndReplaceDialog.searchText <> Empty Then
        Dim searchString As String
        Dim originalSearchString As String
        Dim i As Long
        Dim count As Long
        
        finding = True
        
        searchString = FindAndReplaceDialog.searchText
        originalSearchString = FindAndReplaceDialog.SearchTextBox
        
        For i = 8 To lastRow
            If (Cells(i, 2) <> Empty) And (FoundText(i, searchString)) Then
                Call replaceText(i, searchString, FindAndReplaceDialog.replaceText)
                count = count + 1
                
            End If
        Next i
        
        finding = False
        
        MsgBox (getLocale("REPLACED") & " " & count & " " & getLocale("INSTANCES_OF") & """" & originalSearchString & """")
        
    End If
    
End Sub

Public Sub ReplaceFindText()
'------------------------------
'
' Replace in the current cell and then search for the next occurance
'
'------------------------------

    If FindAndReplaceDialog.searchText <> Empty Then
        Dim searchString As String
        Dim currentRow As Long
        
        currentRow = ActiveCell.row
        
        searchString = FindAndReplaceDialog.searchText
        
        If ((Cells(currentRow, 2) <> Empty) And _
            (FoundText(currentRow, searchString))) Then
            Call replaceText(currentRow, searchString, FindAndReplaceDialog.replaceText)
                
            If (FindAndReplaceDialog.replaceFind = True) Then
                Call FindText
            End If
        Else
                MsgBox (getLocale("STRING") & ":" & """" & FindAndReplaceDialog.SearchTextBox & """" & getLocale("NOT_FOUND_IN_THE_CURRENT_TARGET_SEGMENT"))
        End If
    End If
    
End Sub

    
Public Sub FindText()
'------------------------------
'
' Find the text
'
'------------------------------
    If FindAndReplaceDialog.searchText <> Empty Then
        
        Dim searchString As String
        Dim startRow As Long
        Dim i As Long
        Dim text As String
        Dim Found As Boolean
    
        startRow = ActiveCell.row
        
        searchString = FindAndReplaceDialog.searchText
        
        If ((FoundText(startRow, searchString)) Or _
           (FindAndReplaceDialog.replaceFind = True)) Then
            If (FindAndReplaceDialog.forward = True) Then
                startRow = startRow + 1
            Else
                startRow = startRow - 1
            End If
        End If
        
        If (FindAndReplaceDialog.forward = True) Then
            For i = startRow To lastRow
                If (FoundText(i, searchString)) Then
                    Cells(i, 4).Select
                    Exit Sub
                End If
            Next i
        Else
            For i = startRow To 8 Step -1
                If (FoundText(i, searchString)) Then
                    Cells(i, 4).Select
                    Exit Sub
                End If
            Next i
        End If
        
        If (FindAndReplaceDialog.wrap = True) Then
            For i = 8 To startRow
                If (FoundText(i, searchString)) Then
                    Cells(i, 4).Select
                    Exit Sub
                End If
            Next i
        End If
        
        
        MsgBox (getLocale("STRING") & ":" & """" & FindAndReplaceDialog.SearchTextBox & """" & getLocale("NOT_FOUND"))
    End If
    
End Sub


Public Sub replaceText(i As Long, searchString As String, replaceText As String)
'-----------------------------
'
' Replace searchString with ReplaceText in Cells(i,4)
'
'-----------------------------
    Dim text As String
    
    If (Cells(i, 5) = "I") And (ThisWorkbook.canEditICEMatches = False) Then
        MsgBox (getLocale("CANNOT_CHANGE_TEXT_IN_LOCKED_ICE_MATCH_SEGMENTS"))
        Exit Sub
    End If
    
    Cells(i, 4).Locked = False
    
    text = Cells(i, 4)
    
    text = REPLACE(text, searchString, replaceText, 1, , vbTextCompare)
    
    Cells(i, 4) = text
    
    Dim tlen As Integer
    
    tlen = Len(Cells(i, 4))
            
    Cells(i, 4).Characters(1, tlen).Font.ColorIndex = 1
    Cells(i, 4).Characters(1, tlen).Font.FontStyle = "Normal"
    
End Sub

Public Function FoundText(i As Long, searchString As String) As Boolean
'-----------------------------
'
' Try and find the text in the row
'
'-----------------------------

    If ((Cells(i, 2) <> Empty)) Then
        If (FindAndReplaceDialog.matchCase = True) Then
            If (FindAndReplaceDialog.source And InStr(Cells(i, 3), searchString) <> 0) Then
                Cells(i, 3).Select
                Cells(i, 3).Copy
                finding = False
                FoundText = True
                Exit Function
            End If
            If (FindAndReplaceDialog.target And InStr(Cells(i, 4), searchString) <> 0) Then
                Cells(i, 4).Select
                Cells(i, 4).Copy
                'Application.SendKeys "{ESC}", True 'This prevents the cursor going into the cell
                FoundText = True
                Exit Function
            End If
        Else
            If (FindAndReplaceDialog.source And InStr(LCase(Cells(i, 3)), searchString) <> 0) Then
                Cells(i, 3).Select
                Cells(i, 3).Copy
                FoundText = True
                Exit Function
            End If
            If (FindAndReplaceDialog.target And InStr(LCase(Cells(i, 4)), searchString) <> 0) Then
                Cells(i, 4).Select
                'Application.SendKeys "{ESC}", True 'This prevents the cursor going into the cell
                Cells(i, 4).Copy
                FoundText = True
                Exit Function
            End If
        End If
    End If

    FoundText = False

End Function

Public Sub GoToSegmentFunction()

    SegmentNo.Show vbModeless
    
End Sub
Public Sub GoToPreviousIncompleteSegment()
'------------------------------
'
' Go to the previous incomplete segment
'
'------------------------------
    Dim currentRow As Long
    Dim i As Long, x As Long
    Dim Status As String
    
    currentRow = ActiveCell.row
    
    For i = currentRow - 1 To 8 Step -1
        If (Cells(i, 2) <> Empty) Then
            Status = ThisWorkbook.Sheets("data").Cells(i, 5)
            x = InStr(1, Status, "TO_BE")
            
            If x <> 0 Then
                Cells(i, 4).Select
                Call SetActiveCellForMac
                Exit Sub
            End If
        End If
    Next i

    MsgBox getLocale("NO_PREVIOUS_INCOMPLETE_SEGMENT_FOUND"), vbOKOnly, getLocale("GO_TO_PREVIOUS_INCOMPLETE_SEGMENT")


End Sub
Public Sub GoToPreviousSegmentWithComment()
'------------------------------
'
' Go to the previous segment with comments
'
'------------------------------
    Dim currentRow As Long
    Dim i As Long
    Dim Status As String
    
    currentRow = ActiveCell.row
    
    For i = currentRow - 1 To 8 Step -1
        If (Cells(i, 2) <> Empty) Then
            If Not (Cells(i, 4).Comment Is Nothing) Then
                Cells(i, 4).Select
                Call SetActiveCellForMac
                Exit Sub
            End If
        End If
    Next i

    MsgBox getLocale("NO_PREVIOUS_SEGMENT_WITH_COMMENTS_FOUND"), vbOKOnly, getLocale("GO_TO_PREVIOUS_SEGMENT_WITH_COMMENTS")

    RefocusTargetCell (currentRow)
    
End Sub
Public Sub GoToNextSegmentWithComment()
'------------------------------
'
' Go to the next segment with comments
'
'------------------------------
    Dim currentRow As Long
    Dim i As Long
    Dim Status As String
    
    currentRow = ActiveCell.row
    
    For i = currentRow + 1 To lastRow
        If (Cells(i, 2) <> Empty) Then
            If Not (Cells(i, 4).Comment Is Nothing) Then
                nextActiveXPressed = True
                Cells(i, 4).Select
                Call SetActiveCellForMac
                Exit Sub
            End If
        End If
    Next i

    MsgBox getLocale("NO_NEXT_SEGMENT_WITH_COMMENTS_FOUND"), vbOKOnly, getLocale("GO_TO_NEXT_SEGMENT_WITH_COMMENTS")

    RefocusTargetCell (currentRow)


End Sub
Public Sub GoToNextIncompleteSegment()
'------------------------------
'
' Go to the next incomplete segment
'
'------------------------------
    Dim currentRow As Long
    Dim i As Long, x As Long
    Dim Status As String
    
    currentRow = ActiveCell.row
    
    For i = currentRow + 1 To lastRow
        If (Cells(i, 2) <> Empty) Then
            Status = ThisWorkbook.Sheets("data").Cells(i, 5)
            x = InStr(1, Status, "TO_BE")
            
            If x <> 0 Then
                nextActiveXPressed = True
            
                Cells(i, 4).Select
                Call SetActiveCellForMac
                Exit Sub
            End If
        End If
    Next i

    MsgBox getLocale("NO_NEXT_INCOMPLETE_SEGMENT_FOUND"), vbOKOnly, getLocale("GO_TO_NEXT_INCOMPLETE_SEGMENT")

    RefocusTargetCell (currentRow)
End Sub
Public Sub GoToNextSegmentWithErrors()
'------------------------------
'
' Go to the next segment with errors
'
'------------------------------
    Dim currentRow As Long
    Dim i As Long
    Dim Status As String
    
    currentRow = ActiveCell.row
    
    For i = currentRow + 1 To lastRow
        If (Cells(i, 2) <> Empty) Then
            Status = ThisWorkbook.Sheets("data").Cells(i, 4)
            If (Status = INVALID_INLINES) Or (Status = EMPTY_TARGET) Then
                nextActiveXPressed = True
            
                Cells(i, 4).Select
                Call SetActiveCellForMac
                Exit Sub
            End If
        End If
    Next i
    
    MsgBox getLocale("NO_SEGMENT_WITH_ERRORS_FOUND"), vbOKOnly, getLocale("GO_TO_NEXT_SEGMENT_WITH_ERRORS")
    
    RefocusTargetCell (currentRow)
End Sub



Public Sub GoToSegment()
'------------------------------
'
' Go to a specific segment number.
'
'------------------------------
    If (SegmentNo.SEGNO <> Empty) Then
        Dim result As Boolean
        
        result = GoToTheSegment(SegmentNo.SEGNO)
        
    End If

End Sub


Private Function GoToTheSegment(SEGNO As String) As Boolean
'------------------------------
'
' Go to a specific segment number.
'
'------------------------------
    Dim i As Long
    Dim currentRow As Long
    
    currentRow = ActiveCell.row
    
    For i = 8 To lastRow
        If (Cells(i, 2) = SEGNO) Then
            Cells(i, 4).Select
            Call SetActiveCellForMac
            GoToTheSegment = True
            Exit Function
        End If
    Next i
    
    GoToTheSegment = False
    
    MsgBox getLocale("SEGMENT") & ":" & """" & SEGNO & """" & getLocale("NOT_FOUND"), vbSystemModal

    RefocusTargetCell (currentRow)
End Function

#If Win32 Or Win64 Then

Private Sub GoToSegmentTextBox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'------------------------------
'
' Go to a specific segment number.
'
'------------------------------
    If (GoToSegmentTextBox.text <> Empty) And ((KeyCode.Value = 10) Or (KeyCode.Value = 13)) Then
        Dim result As Boolean
        result = GoToTheSegment(GoToSegmentTextBox.text)
        
        If (result = False) Then
            GoToSegmentTextBox.text = Empty
        End If
    End If
End Sub

#End If

Public Sub CopySource2Target()
'------------------------------
'
' Copy source to target.
'
'------------------------------
        Dim activeRow As Long
        Dim sourceText As String
        Dim targetText As String
        Dim intMessage As Integer
        Dim tlen As Integer
   
        activeRow = ActiveCell.row
        
        sourceText = Cells(activeRow, 3)
        targetText = Cells(activeRow, 4)
        
        
        
        If (sourceText <> targetText) Then
            intMessage = MsgBox(getLocale("DO_YOU_WANT_TO_OVERWRITE_THE_TARGET_WITH_THE_SOURCE_TEXT"), vbYesNo, getLocale("WARNING"))

            If intMessage <> vbYes Then
                Exit Sub
            End If
            
            Cells(activeRow, 4).Locked = False
            
            tlen = Len(Cells(activeRow, 4))
            
            On Error GoTo errCond
            
            Cells(activeRow, 4).Characters(1, tlen).Font.ColorIndex = 1
            Cells(activeRow, 4).Characters(1, tlen).Font.FontStyle = "Normal"
            
            Cells(activeRow, 4) = sourceText
            Cells(activeRow, 4).Select
        End If

        Exit Sub
        
errCond:
    MsgBox "ERROR" & Err.Number & ": " & Error.Description
End Sub

Public Function ConcordanceSearch(Term As String, sourceSearch As Boolean) As Collection
'------------------------------
'
' Do a Concordance search
'
'------------------------------
    Dim Concordances As Collection
    Dim Concordance As ConcordanceObject
    
    Dim source As String
    Dim target As String
    Dim searchString As String
    
    Dim i As Long
    Dim index As Integer
    Dim count As Integer
    
    Set Concordances = New Collection
    
    If (lastRow = 0) Then
        Call calcLastRow
    End If
    
    For i = 8 To lastRow
        If (Cells(i, 2) <> Empty) Then
            If (sourceSearch = True) Then
                searchString = Cells(i, 3).text
            Else
                searchString = Cells(i, 4).text
            End If

            index = InStr(UCase(searchString), UCase(Term))
                
            If (index <> 0) Then
                target = Cells(1, 4).text
                    
                Set Concordance = BuildConcordanceObject(i)
                
                Concordances.Add Concordance
                
                count = count + 1
                
                If (count = 100) Then 'Restrict results to 100 for safety
                    Exit For
                End If
            End If
        End If
    Next i
    
    Set ConcordanceSearch = Concordances
End Function

Private Function BuildConcordanceObject(i As Long) As ConcordanceObject
'------------------------------
'
' Build the Concordance Object
'
'------------------------------
    Dim Concordance As ConcordanceObject

    Set Concordance = New ConcordanceObject
                    
    Concordance.TheSource = Cells(i, 3).text
    Concordance.TheTarget = Cells(i, 4).text
    Concordance.SegmentID = Cells(i, 2).text
    
    Set BuildConcordanceObject = Concordance

End Function


Public Sub DoConcordance()
'------------------------------
'
' Display the Concordance dialog box.
'
'------------------------------
    Concordance.Show
End Sub
Private Sub DoPrint()
'------------------------------
'
' Print!
'
'------------------------------
    Dim printRange As Range
    Dim res As Variant
    Dim currentRow As Long
    
    currentRow = ActiveCell.row
    
    'Set printRange = Range(Columns(1), Columns(5))
    Set printRange = Range(Cells(1, 1), Cells(lastRow, 5))
    
    With ActiveSheet.PageSetup
        .Orientation = xlLandscape
        '.Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
   'ActiveSheet.PageSetup.PrintArea = "$D$1:$I$41"
        
    
    printRange.Select
    
    res = Application.Dialogs(xlDialogPrint).Show(, , , , , , , , , , , 1)
End Sub





Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ShowTIP"
Attribute VB_Base = "0{71CF39C8-568D-4AD2-BD50-E594E67EB4DA}{4CFAD6B1-5A30-4EF5-BB28-6E5765FDA4DC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public doNotShowTIPAgain As Boolean

Private Sub DoNotShowAgain_Click()
    If (doNotShowTIPAgain = True) Then
        doNotShowTIPAgain = False
    Else
        doNotShowTIPAgain = True
    End If
End Sub

Private Sub OK_Click()
    Call ClearUp
End Sub

Private Sub ClearUp()
    Hide
    Cells(ActiveCell.row, 1).Select
    Cells(ActiveCell.row, 4).Select

End Sub

Private Sub UserForm_Activate()

ShowTIP.caption = getLocale("TIP") & ":"
Label1.caption = getLocale("YOU_CAN_USE_THE_TAB_KEY_TO_MOVE_TO_THE_NEXT_SEGMENT")
Label2.caption = getLocale("TIP_DESC")
DoNotShowAgain.caption = getLocale("DO_NOT_SHOW_THE_MESSAGE_AGAIN")
OK.caption = getLocale("OK")

End Sub
Attribute VB_Name = "StatusIBlue"
Attribute VB_Base = "0{60DF12C4-6619-4A3B-BFF5-C9AE36C41724}{EDB5420D-2262-4BA8-82C3-10397AB00820}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String

Private Sub IBLUE_Click()
    Status = "BLUE"
    letter = "I"
    StatusIBlue.Hide
End Sub

Private Sub UserForm_Activate()
IBLUE.caption = getLocale("TO_BE_CORRECTED_ICE_MATCH")
StatusIBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
End Sub
Attribute VB_Name = "StatusIGreen"
Attribute VB_Base = "0{174FA702-51B7-4A83-8A0D-F181593AE76D}{143DA4C0-2BD5-45CB-9953-7FAE334F3F52}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String

Private Sub IGREEN_Click()
    Status = "GREEN"
    letter = "I"
    StatusIGreen.Hide
End Sub

Private Sub UserForm_Activate()

IGREEN.caption = getLocale("REVIEWED_ICE_MATCH")
StatusIGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
End Sub
Attribute VB_Name = "StatusIGreenIBlue"
Attribute VB_Base = "0{2EFF70FE-A615-4267-A07A-E1DAD7FFAFE8}{7F311F2A-7EA3-4865-B5A9-687E85B42374}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String

Private Sub IGREEN_Click()
    Status = "GREEN"
    letter = "I"
    StatusIGreenIBlue.Hide
End Sub
Private Sub IBLUE_Click()
    Status = "BLUE"
    letter = "I"
    StatusIGreenIBlue.Hide
End Sub

Private Sub UserForm_Activate()

IGREEN.caption = getLocale("REVISED_ICE_MATCH")
IBLUE.caption = getLocale("TO_BE_CORRECTED_ICE_MATCH")
StatusIGreenIBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
End Sub

Attribute VB_Name = "StatusIRed"
Attribute VB_Base = "0{0482F738-6E7B-4073-BE64-B2DBDE76ADD0}{DB626156-FDC1-48CF-A1F1-B4FB6D32CB67}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String

Private Sub IRED_Click()
    Status = "RED"
    letter = "I"
    StatusIRed.Hide
End Sub

Private Sub UserForm_Activate()

IRED.caption = getLocale("TO_BE_REVISED_ICE_MATCH")
StatusIRed.caption = getLocale("CHANGE_SEGMENT_STATUS")
End Sub

Attribute VB_Name = "StatusIRedIBlue"
Attribute VB_Base = "0{C7E0E119-A890-45DB-80AC-DC017AE50E5D}{7D971B62-8679-4C3D-8E5A-DFE4CE2B3094}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String

Private Sub IRED_Click()
    Status = "RED"
    letter = "I"
    Hide
End Sub
Private Sub IBLUE_Click()
    Status = "BLUE"
    letter = "I"
    Hide
End Sub

Private Sub UserForm_Activate()
IBLUE.caption = getLocale("TO_BE_CORRECTED_ICE_MATCH")
IRED.caption = getLocale("TO_BE_REVISED_ICE_MATCH")
StatusIRedIBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
End Sub

Attribute VB_Name = "StatusMGreen"
Attribute VB_Base = "0{9B784AF1-3E88-440F-B268-227F28420E56}{06232D3A-DB29-4E02-BC7C-117E636881A5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String

Private Sub MGREEN_Click()
    Status = "GREEN"
    letter = "M"
    StatusMGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusMGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
MGREEN.caption = getLocale("REVISED_MATCHED")

End Sub


Attribute VB_Name = "StatusMGreenMBlue"
Attribute VB_Base = "0{4F1BB01D-2877-46FE-AF6C-56D63E2502BC}{CF79E3D2-8648-41E5-B1CD-860C998D1C94}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub MGREEN_Click()
    Status = "GREEN"
    letter = "M"
    StatusMGreenMBlue.Hide
End Sub


Private Sub MBLUE_Click()
    Status = "BLUE"
    letter = "M"
    StatusMGreenMBlue.Hide
End Sub

Private Sub UserForm_Activate()

StatusMGreenMBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
MGREEN.caption = getLocale("REVISED_MATCHED")
MBLUE.caption = getLocale("TO_BE_CORRECTED_MATCHED")

End Sub


Attribute VB_Name = "StatusMGreenMBlueNGreen"
Attribute VB_Base = "0{6F7878B7-993D-4578-AA3D-8A4124099E5D}{E8AB372D-A8B5-4481-91CC-EE4935E401CF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String


Private Sub MGREEN_Click()
    Status = "GREEN"
    letter = "M"
    StatusMGreenMBlueNGreen.Hide
End Sub


Private Sub MBLUE_Click()
    Status = "BLUE"
    letter = "M"
    StatusMGreenMBlueNGreen.Hide
End Sub

Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusMGreenMBlueNGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusMGreenMBlueNGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
MGREEN.caption = getLocale("REVISED_MATCHED")
MBLUE.caption = getLocale("TO_BE_CORRECTED_MATCHED")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")

End Sub

Attribute VB_Name = "StatusMGreenNGreen"
Attribute VB_Base = "0{9168FF54-C49A-479F-9C92-8F7E83406EE5}{909FE883-B0BB-4EF3-9C47-F5CB9045C3F8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public Status As String
Public letter As String


Private Sub MGREEN_Click()
    Status = "GREEN"
    letter = "M"
    Hide
End Sub


Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    Hide
End Sub


Private Sub UserForm_Activate()

StatusMGreenMBlueNGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
MGREEN.caption = getLocale("REVISED_MATCHED")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")

End Sub



Attribute VB_Name = "StatusMRed"
Attribute VB_Base = "0{651537D6-77D2-4DB9-BDDB-E5BD5F857211}{E9012DF0-57A0-4872-908A-27AEFFAF3E67}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub URED_Click()
    Status = "RED"
    letter = "U"
    StatusMRed.Hide
End Sub


Private Sub MRED_Click()
    Status = "RED"
    letter = "M"
    StatusMRed.Hide
End Sub

Private Sub UserForm_Activate()

StatusMRed.caption = getLocale("CHANGE_SEGMENT_STATUS")
MRED.caption = getLocale("TO_BE_TRANSLATED_MATCHED")

End Sub

Attribute VB_Name = "StatusMRedMBlue"
Attribute VB_Base = "0{E064EDAE-076D-4F35-897E-60F9042C896E}{D6FC5C5C-609B-46A6-890E-CAF06F4CDB95}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub MRED_Click()
    Status = "RED"
    letter = "M"
    StatusMRedMBlue.Hide
End Sub


Private Sub MBLUE_Click()
    Status = "BLUE"
    letter = "M"
    StatusMRedMBlue.Hide
End Sub


Private Sub UserForm_Activate()

StatusMRedMBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
MRED.caption = getLocale("TO_BE_REVISED_MATCHED")
MBLUE.caption = getLocale("TO_BE_CORRECTED_MATCHED")

End Sub

Attribute VB_Name = "StatusMRedMBlueNGreen"
Attribute VB_Base = "0{28ED828B-6BD9-4E09-916B-697424C6C749}{B2FA4E56-B042-42D0-9F95-3453C22F6258}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit


Public Status As String
Public letter As String


Private Sub MRED_Click()
    Status = "RED"
    letter = "M"
    StatusMRedMBlueNGreen.Hide
End Sub


Private Sub MBLUE_Click()
    Status = "BLUE"
    letter = "M"
    StatusMRedMBlueNGreen.Hide
End Sub


Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusMRedMBlueNGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusMRedMBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
MRED.caption = getLocale("TO_BE_REVISED_MATCHED")
MBLUE.caption = getLocale("TO_BE_CORRECTED_MATCHED")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")

End Sub
Attribute VB_Name = "StatusMYellow"
Attribute VB_Base = "0{DDE90592-6200-4FB9-A274-B466EF398E22}{507AEDBA-0167-4675-909C-E3598C171E0A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String

Private Sub MYELLOW_Click()
    Status = "YELLOW"
    letter = "M"
    StatusMYellow.Hide
End Sub

Private Sub UserForm_Activate()

StatusMYellow.caption = getLocale("CHANGE_SEGMENT_STATUS")
MYELLOW.caption = getLocale("TO_BE_CHECKED_MATCHED")

End Sub
Attribute VB_Name = "StatusNGreen"
Attribute VB_Base = "0{6416E1AC-3DBF-4181-850A-C37174E609D4}{8E90D8AB-2EF3-4220-BB85-9ECA4654F9B2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String

Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusNGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusNGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")

End Sub

Attribute VB_Name = "StatusNGreenNBlueMRed"
Attribute VB_Base = "0{3446C774-10AB-4AFF-882D-0A4E91FE5C11}{39AF9D1C-E9C1-4948-A006-FA16D276CBA9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public Status As String
Public letter As String



Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    Hide
End Sub

Private Sub NBLUE_Click()
    Status = "BLUE"
    letter = "N"
    Hide
End Sub



Private Sub MRED_Click()
    Status = "RED"
    letter = "M"
    Hide
End Sub

Private Sub UserForm_Activate()

StatusNGreenNBlueMRed.caption = getLocale("CHANGE_SEGMENT_STATUS")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")
MRED.caption = getLocale("TO_BE_REVISED_MATCHED")
NBLUE.caption = getLocale("TO_BE_CORRECTED_NON_TRANSLATABLE")

End Sub



Attribute VB_Name = "StatusNRedNYellow"
Attribute VB_Base = "0{01A5CB8E-10F5-4A63-8199-4DBFAF9EC12E}{7653940A-6C36-4884-A402-AA9FE69777FD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String

Private Sub NYELLOW_Click()
    Status = "YELLOW"
    letter = "N"
    StatusNRedNYellow.Hide
End Sub

Private Sub NRED_Click()
    Status = "RED"
    letter = "N"
    StatusNRedNYellow.Hide
End Sub

Private Sub UserForm_Activate()

StatusNRedNYellow.caption = getLocale("CHANGE_SEGMENT_STATUS")
NYELLOW.caption = getLocale("TO_BE_CHECKED_NON_TRANSLATABLE")
NRED.caption = getLocale("TO_BE_TRANSLATED_NON_TRANSLATABLE")

End Sub

Attribute VB_Name = "StatusNYellowNBlueMRed"
Attribute VB_Base = "0{3EAFE32D-076C-4F7B-A55C-23147B32E5B3}{A03F22BE-D5DD-4044-B696-15F44A7C2E19}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public Status As String
Public letter As String



Private Sub MRED_Click()
    Status = "RED"
    letter = "M"
    Hide
End Sub

Private Sub NYELLOW_Click()
    Status = "YELLOW"
    letter = "N"
    Hide
End Sub

Private Sub NBLUE_Click()
    Status = "BLUE"
    letter = "N"
    Hide
End Sub

Private Sub UserForm_Activate()

StatusNYellowNBlueMRed.caption = getLocale("CHANGE_SEGMENT_STATUS")
MRED.caption = getLocale("TO_BE_REVISED_MATCHED")
NBLUE.caption = getLocale("TO_BE_CORRECTED_NON_TRANSLATABLE")
NYELLOW.caption = getLocale("TO_BE_CHECKED_NON_TRANSLATABLE")

End Sub



Attribute VB_Name = "StatusUGreen"
Attribute VB_Base = "0{0C008A91-4A04-4236-8BEE-BB4A249DA0C1}{15027ED9-024C-493B-A535-E44D0FDF8B46}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub UGREEN_Click()
    Status = "GREEN"
    letter = "U"
    StatusUGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusUGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
UGREEN.caption = getLocale("TRANSLATED_UNMATCHED")

End Sub

Attribute VB_Name = "StatusUNGreen"
Attribute VB_Base = "0{0E188E5F-7C8D-49EE-ADD2-FC23C92DC0AC}{A4C6D962-8ADF-458C-821F-E656610C3AD9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public Status As String
Public letter As String


Private Sub UGREEN_Click()
    Status = "GREEN"
    letter = "U"
    StatusUNGreen.Hide
End Sub
Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusUNGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusUNGreen.caption = getLocale("CHANGE_SEGMENT_STATUS")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")
UGREEN.caption = getLocale("REVISED_UNMATCHED")

End Sub


Attribute VB_Name = "StatusUNGreenUBlue"
Attribute VB_Base = "0{417D6C3E-EC38-4423-A866-14A7DA022687}{8FE4ED6A-98BE-46F8-B7D6-3F6E624839F9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub UGREEN_Click()
    Status = "GREEN"
    letter = "U"
    StatusUNGreenUBlue.Hide
End Sub

Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusUNGreenUBlue.Hide
End Sub

Private Sub UBLUE_Click()
    Status = "BLUE"
    letter = "U"
    StatusUNGreenUBlue.Hide
End Sub

Private Sub UserForm_Activate()

StatusUNGreenUBlue.caption = getLocale("CHANGE_SEGMENT_STATUS")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")
UGREEN.caption = getLocale("REVISED_UNMATCHED")
UBLUE.caption = getLocale("TO_BE_CORRECTED_UNMATCHED")

End Sub


Attribute VB_Name = "StatusURedNGreen"
Attribute VB_Base = "0{E1BCE53F-7ABC-4CA3-BD94-F44B78764DCD}{83394175-B30F-4779-A862-0D1388914039}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub URED_Click()
    Status = "RED"
    letter = "U"
    StatusURedNGreen.Hide
End Sub

Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusURedNGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusUNGreenUBlue.caption = getLocale("StatusURedNGreen")
URED.caption = getLocale("TO_BE_TRANSLATED_UNMATCHED")
NGREEN.caption = getLocale("TRANSLATED_NON_TRANSLATABLE")

End Sub
Attribute VB_Name = "StatusURedUBlueNGreen"
Attribute VB_Base = "0{E38D3E31-39CB-4E91-A1B8-F018F1F79FFE}{AE82DB3D-67ED-4286-AABC-7139BCC62FBF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Status As String
Public letter As String


Private Sub URED_Click()
    Status = "RED"
    letter = "U"
    StatusURedUBlueNGreen.Hide
End Sub


Private Sub UBLUE_Click()
    Status = "BLUE"
    letter = "U"
    StatusURedUBlueNGreen.Hide
End Sub


Private Sub NGREEN_Click()
    Status = "GREEN"
    letter = "N"
    StatusURedUBlueNGreen.Hide
End Sub

Private Sub UserForm_Activate()

StatusURedUBlueNGreen.caption = getLocale("StatusURedNGreen")
NGREEN.caption = getLocale("REVISED_NON_TRANSLATABLE")
UBLUE.caption = getLocale("TO_BE_CORRECTED_UNMATCHED")
URED.caption = getLocale("TO_BE_REVISED_UNMATCHED")

End Sub

Attribute VB_Name = "StringDiffObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private pTheStart As Integer
Private pTheLength As Integer
Private pTheWord As String
Private pUsed As Boolean


Public Sub Init(start As Integer, word As String)
    pTheStart = start
    pTheLength = Len(word)
    pTheWord = word
End Sub


Public Property Get TheStart() As Integer
    TheStart = pTheStart
End Property

Public Property Get TheLength() As Integer
    TheLength = pTheLength + 1
End Property
Public Property Get TheWord() As String
    TheWord = pTheWord
    pTheLength = Len(pTheWord)
End Property

Public Property Get IsUsed() As Boolean
    IsUsed = pUsed
End Property


Public Property Let TheStart(Value As Integer)
    pTheStart = Value
End Property

Public Property Let TheLength(Value As Integer)
    pTheLength = Value
End Property

Public Property Let TheWord(Value As String)
    pTheWord = Value
End Property

Public Property Let Used(Value As Boolean)
    pUsed = Value
End Property
Attribute VB_Name = "Sundry"
Option Explicit

Public Protected As Boolean

Public Sub CopySourceToTarget()
'------------------------------
'
' Copy source to target
'
'------------------------------

    Call Sheet1.CopySource2Target
End Sub


Public Function Normalize(InputText As String) As String
'------------------------------
'
' Convert all tabs and new lines to spaces
'
'------------------------------
    Dim buff As String
    
    buff = REPLACE(InputText, vbTab, " ")
    buff = REPLACE(buff, vbNewLine, " ")
    buff = REPLACE(buff, vbLf, " ")
    buff = REPLACE(buff, vbFormFeed, " ")
    buff = REPLACE(buff, vbVerticalTab, " ")
    buff = REPLACE(buff, vbNullChar, " ")
    buff = REPLACE(buff, vbCr, " ")
    buff = REPLACE(buff, vbBack, " ")
    buff = REPLACE(buff, vbCrLf, " ")
    
    buff = TrimSpaces(buff)
    
    Normalize = buff
    
End Function
Public Function TrimSpaces(str As String) As String
'------------------------------
'
' Converts all multiple spaces to a single space
'
'------------------------------

If InStr(str, "  ") > 0 Then
    str = TrimSpaces(REPLACE(str, "  ", " "))
End If

TrimSpaces = str

End Function




Public Function IsMacOS() As Boolean
'------------------------------
'
' Check for MacOS
'
'------------------------------

    Dim OS As String
    
    Dim MacOS As Boolean
    
    MacOS = False
    
    OS = Application.OperatingSystem

#If Mac Then
    MacOS = True
#End If

    IsMacOS = MacOS
        
End Function

Public Sub AddToShortcut()
'------------------------------
'
' Add 'Add Comment' to shortcut menu
'
'------------------------------
        Dim Bar As CommandBar

        Dim NewControl As CommandBarButton
        
        Dim OS As String
        
        OS = Application.OperatingSystem

        DeleteAddTranslationCommentFromShortcut

        Set Bar = Application.CommandBars("Cell")
        Set NewControl = Bar.Controls.Add(Type:=msoControlButton, temporary:=True)
        
        If Left(OS, 7) = "Windows" Then
            With NewControl
                .caption = getLocale("ADD_TRANSLATION_COMMENT")
                .OnAction = "AddComment"
                '.Picture = Application.CommandBars.GetImageMso("WrapText", 16, 16)
                .style = msoButtonIconAndCaption
            End With
        Else
            With NewControl
                .caption = getLocale("ADD_TRANSLATION_COMMENT")
                .OnAction = "AddComment"
                '.Picture = Application.CommandBars. GetImageMso("WrapText", 16, 16)
                '.Style = msoButtonIconAndCaption
            End With
        End If
End Sub

Public Sub DeleteAddTranslationCommentFromShortcut()
'------------------------------
'
' Delete the shortcut menu item so we do not end up with multiples
'
'------------------------------
        On Error Resume Next
        CommandBars("Cell").Controls(getLocale("ADD_TRANSLATION_COMMENT")).Delete
        
End Sub

Public Sub FastQuit()
'------------------------------
'
' Get out FAST!
'
'------------------------------
    Debug.Print ("FastQuit called")
    ThisWorkbook.Saved = True
    Application.quit

End Sub
Public Sub UnprotectSheet()
'------------------------------
'
' Unprotect the Worksheet
'
'------------------------------
    ThisWorkbook.Sheets("XTM-Editor").Unprotect PASSWORD:=PASSWORD
    ThisWorkbook.Sheets("data").Unprotect PASSWORD:=PASSWORD
End Sub


Public Sub FinalProtectSheet()
'------------------------------
'
' Protect the Worksheet
'
'------------------------------
    ThisWorkbook.Sheets("data").protect PASSWORD:=PASSWORD
    ActiveSheet.protect PASSWORD:=PASSWORD, UserInterfaceOnly:=True
End Sub

Public Function NextEmptyRow(col As Integer) As Long
'------------------------------
'
' Locate the next empty row in the 'data' sheet for this column
'
'------------------------------

    Dim nextrow As Long

    NextEmptyRow = ThisWorkbook.Sheets("data").Cells(Rows.count, col).End(xlUp).row
    
End Function

#If Win32 Or Win64 Then

Public Sub ContextMenuCallBack(control As IRibbonControl)
'------------------------------
'
' Callbacks for CustomUI14 Excel 2010+
'
'------------------------------
    Select Case control.ID
    
    Case "SpellCheck"
        Sheet1.SpellCheckAllSegments
    Case "PreviousIncomplete"
        Sheet1.GoToPreviousIncompleteSegment
    Case "NextIncomplete"
        Sheet1.GoToNextIncompleteSegment
    Case "AddComment"
        AddComment
    Case "PreviousWithComment"
        Sheet1.GoToPreviousSegmentWithComment
    Case "NextWithComment"
        Sheet1.GoToNextSegmentWithComment
    Case "NextWithErrors"
        Sheet1.GoToNextSegmentWithErrors
    Case "FindAndReplace"
        Sheet1.FindAndReplace
    Case "GoToSegmentNo"
        Sheet1.GoToSegmentFunction
    Case "Settings"
        SetupOptions.Show
    Case "Help"
        DisplayPDFHelp
    
    End Select

End Sub

#End If

Public Sub Add2ComboBox(comb As ComboBox, text As String)
'------------------------------
'
' Add item to Combo Box control value
'
'------------------------------
    Dim i As Integer
    
    If (comb.ListCount = 0) Then
        comb.AddItem (text)
    Else
        For i = 1 To comb.ListCount
            If (text = comb.List(i - 1, 0)) Then
                Exit For
            End If
        Next i
        
        If ((i - 1) = comb.ListCount) Then
            comb.AddItem (text)
        End If
    End If
End Sub

Public Sub StoreCombo(comb As ComboBox, storeCol As Integer)
'------------------------------
'
' Store the Combo Box values to the 'data' sheet
'
'------------------------------
    Dim i As Long
    Dim j As Integer
    Dim searchString As String
    
    j = 1
    
    For i = 1 To comb.ListCount
        searchString = comb.List(i - 1, 0)
        
        If (searchString <> Empty) Then
            ThisWorkbook.Sheets("data").Cells(j, storeCol) = searchString
            j = j + 1
        End If
    Next
    
End Sub

Public Sub SetupCombo(comb As ComboBox, stroreCol As Integer)
'------------------------------
'
' Set up the search values from previous stored history
'
'------------------------------
    Dim i As Long
    Dim max As Long
    Dim searchString As String
    
    max = NextEmptyRow(stroreCol)
    
    For i = 1 To max
        searchString = Trim(ThisWorkbook.Sheets("data").Cells(i, stroreCol))
        
        If (searchString <> Empty) Then
            Call Add2ComboBox(comb, searchString)
        End If
    Next
    
End Sub

Public Sub GoToSegmentTextBox_Click()
    SegmentNo.Show
End Sub


Public Sub AddCommentIcon_Click()
    Call AddComment
End Sub

Public Sub CommentNextIcon_Click()
    Call Sheet1.GoToNextSegmentWithComment
End Sub

Public Sub CommentPreviousIcon_Click()
    Call Sheet1.GoToPreviousSegmentWithComment
End Sub

Public Sub FindAndReplaceIcon_Click()
    Call Sheet1.FindAndReplace
End Sub

Public Sub HelpIcon_Click()
    Call DisplayPDFHelp
End Sub

Public Sub NexIncompletetIcon_Click()
    Call Sheet1.GoToNextIncompleteSegment
End Sub

Public Sub NextSegmentWithErrorIcon_Click()
    Call Sheet1.GoToNextSegmentWithErrors
End Sub

Public Sub PreviousIncompleteIcon_Click()
    Call Sheet1.GoToPreviousIncompleteSegment
End Sub

Public Sub SetupIcon_Click()
    Call Sheet1.SetupOptionsShow
End Sub

Public Sub SpellCheckIcon_Click()
    If (ThisWorkbook.canChangeTarget = False) Then 'Reviewers cannot change cell contents
        MsgBox (getLocale("YOU_CANNOT_CHANGE_CELL_CONTENTS_IN_THE_REVIEW_STEP"))
    Else
        Call Sheet1.SpellCheckAllSegments
    End If
End Sub



Public Sub XTMEditor_AddCommentIcon_Click()
    Call AddComment
End Sub

Public Sub XTMEditor_CommentNextIcon_Click()
    Call Sheet1.GoToNextSegmentWithComment
End Sub

Public Sub XTMEditor_CommentPreviousIcon_Click()
    Call Sheet1.GoToPreviousSegmentWithComment
End Sub

Public Sub XTMEditor_FindAndReplaceIcon_Click()
    Call Sheet1.FindAndReplace
End Sub

Public Sub XTMEditor_HelpIcon_Click()
    Call DisplayPDFHelp
End Sub

Public Sub XTMEditor_NexIncompletetIcon_Click()
    Call Sheet1.GoToNextIncompleteSegment
End Sub

Public Sub XTMEditor_NextSegmentWithErrorIcon_Click()
    Call Sheet1.GoToNextSegmentWithErrors
End Sub

Public Sub XTMEditor_PreviousIncompleteIcon_Click()
    Call Sheet1.GoToPreviousIncompleteSegment
End Sub

Public Sub XTMEditor_SetupIcon_Click()
    Call Sheet1.SetupOptionsShow
End Sub

Public Sub XTMEditor_SpellCheckIcon_Click()
    Call SpellCheckIcon_Click
End Sub







Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'------------------------------
'
' Copyright @ XTM International 2012 - 2014
'
'------------------------------

'------------------------------
' Global defines
'
'
'------------------------------



Public canChangeTarget As Boolean
Public canEditICEMatches As Boolean
Public workflowStage As String

Const TRANSLATE = "TRANSLATE"
Const REVIEW = "REVIEW"
Const CORRECT = "CORRECT"
Const XTM_VERSION_NO = "119"



Private Sub DisableExcelElements()
'------------------------------
'
' Disable Excel ribon, formula and status bars plus workbook tabs
'
'------------------------------
    Application.ExecuteExcel4Macro "SHOW.TOOLBAR(""Ribbon"",False)"
    Application.DisplayFormulaBar = False
    Application.DisplayStatusBar = Not Application.DisplayStatusBar
    Application.ShowMenuFloaties = True
    Application.ShowSelectionFloaties = True

    ActiveWindow.DisplayWorkbookTabs = False

End Sub
Private Sub CustomiseApplication()
'------------------------------
'
' Customise the Excel Application
'
'------------------------------
    Application.AutoCorrect.AutoFillFormulasInLists = False
    
    Application.Calculation = xlCalculationManual
    
    Application.DisplayAlerts = False
    
    Application.EnableEvents = True
    
    Application.ScreenUpdating = False
    
    Application.ErrorCheckingOptions.NumberAsText = False

End Sub
Private Sub Workbook_BeforeClose(Cancel As Boolean)
'------------------------------
'
' Log end date/time on close
'
'------------------------------
    Debug.Print ("Workbook_BeforeClose()")
    
    Call LogEnd
    
    Call FinalProtectSheet
    
    On Error Resume Next
    
    Application.AutoCorrect.AutoFillFormulasInLists = True

    Application.ExecuteExcel4Macro "SHOW.TOOLBAR(""Ribbon"",True)"
    Application.DisplayFormulaBar = True
    Application.DisplayStatusBar = True
    Application.EnableAutoComplete = True

    ActiveWindow.DisplayWorkbookTabs = True
        
    Call RestoreCommandBars
    
    ActiveWorkbook.Save
    
    Exit Sub
    
SaveAs:
    Debug.Print ("ERROR" & Err.Number & ": " & Error.Description)
    'ActiveWorkbook.SaveAs

End Sub

Private Sub Workbook_Open()
'------------------------------
'
' Enable Events on openning the Workbook
'
'------------------------------
    
    On Error Resume Next
    'On Error GoTo ExitError
    Call InitLocales
    Call CheckExcelVersion
    
#If Mac Then
    ThisWorkbook.Sheets("XTM-Editor").MacOS = True
#End If

    ThisWorkbook.Sheets("XTM-Editor").Active = True
    
    Call CustomiseApplication
    
    'SplashWindow.Show
    
    'Application.Run "'" & ThisWorkbook.Name & "'!Sheets("XTM-Editor").UnprotectSheet"
    Protected = True
    
    Call UnprotectSheet
    
    Call MaximizeWindow
 
    Call CustomiseRMenus
    
    Call DefineKeyboardShortcuts
    
    Call DisableExcelElements
    
    canChangeTarget = True
    canEditICEMatches = True
    
    'Application.DisplayAlerts = False
    
    
    workflowStage = ThisWorkbook.Sheets("data").Cells(1, 1)
    
    If workflowStage = Empty Then
        workflowStage = TRANSLATE
    End If
    
    If workflowStage = REVIEW Then
        'MsgBox "ThisWorkbook.Sheets(data).Cells(1, 1) = " & ThisWorkbook.Sheets("data").Cells(1, 1)
        
        canChangeTarget = False
        
        'If MacOS = True Then
        '    Load ChangeSegmentStatusReviewMac
        'Else
        '    Load ChangeSegmentStatusReview
        'End If

        Dim lastRow As Long
        
        Call ThisWorkbook.Sheets("XTM-Editor").calcLastRow
        
        'Application.Run "'" & ThisWorkbook.Name & "'!Sheets("XTM-Editor").calcLastRow"
        
        ThisWorkbook.Sheets("XTM-Editor").Range("D2:D" & Sheets("XTM-Editor").lastRow).Locked = True
'    Else
'        If MacOS = True Then
'            Load ChangeSegmentStatusMac
'        Else
'            Load ChangeSegmentStatus
'        End If
    ElseIf (ThisWorkbook.Sheets("data").Cells(1, 21) <> True) Then
        canEditICEMatches = False
    End If

    ThisWorkbook.Sheets("XTM-Editor").MacOS = IsMacOS
    
    Dim SpellCheck As String
    
    SpellCheck = ThisWorkbook.Sheets("data").Cells(1, SPELL_CHECK_ALL_SEGMENTS)
    
    If (SpellCheck = "YES") Then
        ThisWorkbook.Sheets("XTM-Editor").SpellCheckEachSegment = True
    Else
        ThisWorkbook.Sheets("XTM-Editor").SpellCheckEachSegment = False
    End If
    
    Dim ShowAllComments As String
    
    ShowAllComments = ThisWorkbook.Sheets("data").Cells(1, SHOW_ALL_COMMENTS)
    
    If (ShowAllComments = "YES") Then
        ThisWorkbook.Sheets("XTM-Editor").ShowAllComments = True
    Else
        ThisWorkbook.Sheets("XTM-Editor").ShowAllComments = False
    End If
    
    Dim SimpleView As String
    
    SimpleView = ThisWorkbook.Sheets("data").Cells(1, SIMPLE_VIEW)
   
    If (SimpleView = "YES") Then
        ThisWorkbook.Sheets("XTM-Editor").SimpleView = True
        ThisWorkbook.Sheets("XTM-Editor").Cells(1, 4) = "Simple View Active"
    Else
        ThisWorkbook.Sheets("XTM-Editor").SimpleView = False
    End If
    
    ThisWorkbook.Sheets("XTM-Editor").workingCell = ActiveCell.Address(False, False)
    
    ThisWorkbook.Sheets("XTM-Editor").targetCellText = Cells(ActiveCell.row, 4)
    
    Call ThisWorkbook.Sheets("XTM-Editor").calcLastRow
    
    ThisWorkbook.Sheets("XTM-Editor").changedStatus = True
        
#If Win32 Or Win64 Then
    CheckLangCodes
#End If
    
    'Application.LanguageSettings.LanguageID = langCode
    
    'Call ThisWorkbook.Sheets("XTM-Editor").ProcessCell
    
    'ThisWorkbook.Sheets("XTM-Editor").Range("A8:A" & Sheets("XTM-Editor").lastRow).Rows.AutoFit
    ThisWorkbook.Sheets("XTM-Editor").Rows(6).RowHeight = 6
    ThisWorkbook.Sheets("XTM-Editor").Rows(3).RowHeight = 6
   
    If ThisWorkbook.Sheets("XTM-Editor").Cells(1, 3) <> Empty Then
        ThisWorkbook.Sheets("XTM-Editor").Cells(1, 3) = Empty
        ThisWorkbook.Sheets("XTM-Editor").Cells(1, 4) = Empty
        'ThisWorkbook.Sheets("XTM-Editor").Cells(4, 3) = Empty
    End If
    'aaaa
    'If ThisWorkbook.Sheets("XTM-Editor").Cells(5, 3) <> Empty Then 'Move project details up one row if required
    '    ThisWorkbook.Sheets("XTM-Editor").Cells(5, 3).Select
    '    Selection.Copy
    ''    ThisWorkbook.Sheets("XTM-Editor").Cells(4, 3).Select
    '   Selection.PasteSpecial
    '   'ThisWorkbook.Sheets("XTM-Editor").Cells(4, 3) = ThisWorkbook.Sheets("XTM-Editor").Cells(5, 3)
    '   ThisWorkbook.Sheets("XTM-Editor").Cells(5, 3) = Empty
    '   ThisWorkbook.Sheets("XTM-Editor").Cells(8, 4).Select
    'End If
    
    'Rows(6).Hidden = True

    ThisWorkbook.Sheets("XTM-Editor").EnableCalculation = False

    
    
    'Application.Run "'" & ThisWorkbook.Name & "'!Sheets("XTM-Editor").ProtectSheet"
    
    Call LogStart
    
    Application.EnableAutoComplete = False
    
    Application.DisplayAlerts = True
    
    Application.ScreenUpdating = True

    'Call WrapCellsText - not required, should all be done on the server via Java/Aspose
    
    'MsgBox "workingCell = " & ThisWorkbook.Sheets("XTM-Editor").workingCell
    
    'Call ReadKeyboardEvents
    'FloatingToolbar.Show vbModeless
    
    'FloatingToolbar.Repaint
    
    Call LoadStartLocales
    
    Call ThisWorkbook.Sheets("XTM-Editor").ActivateSegment
    
    Exit Sub
    
ExitError:
    Application.DisplayAlerts = False
    Application.quit    'MsgBox "ERROR from Workbook_Open()"
End Sub



Attribute VB_Name = "UTCDate"
Option Explicit

#If Win64 Then

    Public Declare PtrSafe Function SystemTimeToFileTime Lib _
        "kernel32" (lpSystemTime As SYSTEMTIME, _
        lpFileTime As FILETIME) As Long

    Public Declare PtrSafe Function LocalFileTimeToFileTime Lib _
        "kernel32" (lpLocalFileTime As FILETIME, _
        lpFileTime As FILETIME) As Long

    Public Declare PtrSafe Function FileTimeToSystemTime Lib _
        "kernel32" (lpFileTime As FILETIME, lpSystemTime _
        As SYSTEMTIME) As Long
#Else
    Public Declare Function SystemTimeToFileTime Lib _
        "kernel32" (lpSystemTime As SYSTEMTIME, _
        lpFileTime As FILETIME) As Long

    Public Declare Function LocalFileTimeToFileTime Lib _
        "kernel32" (lpLocalFileTime As FILETIME, _
        lpFileTime As FILETIME) As Long

    Public Declare Function FileTimeToSystemTime Lib _
        "kernel32" (lpFileTime As FILETIME, lpSystemTime _
        As SYSTEMTIME) As Long

#End If

Public Type FILETIME
    dwLowDateTime As Long
    dwHighDateTime As Long
End Type

Public Type SYSTEMTIME
    wYear As Integer
    wMonth As Integer
    wDayOfWeek As Integer
    wDay As Integer
    wHour As Integer
    wMinute As Integer
    wSecond As Integer
    wMilliseconds As Integer
End Type

Public Function LocalTimeToUTC(dteTime As Date) As Date
    Dim dteLocalFileTime As FILETIME
    Dim dteFileTime As FILETIME
    Dim dteLocalSystemTime As SYSTEMTIME
    Dim dteSystemTime As SYSTEMTIME

    dteLocalSystemTime.wYear = CInt(Year(dteTime))
    dteLocalSystemTime.wMonth = CInt(Month(dteTime))
    dteLocalSystemTime.wDay = CInt(Day(dteTime))
    dteLocalSystemTime.wHour = CInt(Hour(dteTime))
    dteLocalSystemTime.wMinute = CInt(Minute(dteTime))
    dteLocalSystemTime.wSecond = CInt(Second(dteTime))

    Call SystemTimeToFileTime(dteLocalSystemTime, _
      dteLocalFileTime)
    Call LocalFileTimeToFileTime(dteLocalFileTime, _
      dteFileTime)
    Call FileTimeToSystemTime(dteFileTime, dteSystemTime)

    LocalTimeToUTC = CDate(dteSystemTime.wYear & "-" & _
      dteSystemTime.wMonth & "-" & _
      dteSystemTime.wDay & " " & _
      dteSystemTime.wHour & ":" & _
      dteSystemTime.wMinute & ":" & _
      dteSystemTime.wSecond)
End Function
Attribute VB_Name = "modKeyState"
Option Explicit
Option Compare Text
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modKeyState
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
' This module contains functions for testing the state of the SHIFT, ALT, and CTRL
' keys.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''''
' Declaration of GetKeyState API function. This
' tests the state of a specified key.
''''''''''''''''''''''''''''''''''''''''''''''''''''
#If VBA7 And Win64 Then
    Public Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
    Public Declare PtrSafe Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer

#Else
    Public Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
    Public Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer

#End If
''''''''''''''''''''''''''''''''''''''''''
' This constant is used in a bit-wise AND
' operation with the result of GetKeyState
' to determine if the specified key is
' down.
''''''''''''''''''''''''''''''''''''''''''
Private Const KEY_MASK As Integer = &HFF80 ' decimal -128

'''''''''''''''''''''''''''''''''''''''''
' KEY CONSTANTS. Values taken
' from VC++ 6.0 WinUser.h file.
'''''''''''''''''''''''''''''''''''''''''
Private Const VK_LSHIFT = &HA0
Private Const VK_RSHIFT = &HA1
Private Const VK_LCONTROL = &HA2
Private Const VK_RCONTROL = &HA3
Private Const VK_LMENU = &HA4
Private Const VK_RMENU = &HA5
'''''''''''''''''''''''''''''''''''''''''
' The following four constants simply
' provide other names, CTRL and ALT,
' for CONTROL and MENU. "CTRL" and
' "ALT" are more familiar than
' "CONTROL" and "MENU". These constants
' provide no additional functionality.
' They simply provide more familiar
' names.
'''''''''''''''''''''''''''''''''''''''''
Private Const VK_LALT = VK_LMENU
Private Const VK_RALT = VK_RMENU
Private Const VK_LCTRL = VK_LCONTROL
Private Const VK_RCTRL = VK_RCONTROL

 ''''''''''''''''''''''''''''''''''''''''''''
' The following constants are used to specify,
' when testing CTRL, ALT, or SHIFT, whether
' the Left key, the Right key, either the
' Left OR Right, or BOTH the Left AND Right
' key is down.
'
' By default, the key-test procedures make
' no distinction between the Left and Right
' keys.
''''''''''''''''''''''''''''''''''''''''''''
Public Const BothLeftAndRightKeys = 0   ' Note: Bit-wise AND of LeftKey and RightKey
Public Const LeftKey = 1
Public Const RightKey = 2
Public Const LeftKeyOrRightKey = 3      ' Note: Bit-wise OR of LeftKey and RightKey


Public Function IsShiftKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey)
''''''''''''''''''''''''''''''''''''''''''''''''
' IsShiftKeyDown
' Returns TRUE or FALSE indicating whether the
' SHIFT key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right SHIFT key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left SHIFT key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' SHIFT key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            res = GetKeyState(VK_LSHIFT) And KEY_MASK
        Case RightKey
            res = GetKeyState(VK_RSHIFT) And KEY_MASK
        Case BothLeftAndRightKeys
            res = (GetKeyState(VK_LSHIFT) And GetKeyState(VK_RSHIFT) And KEY_MASK)
        Case Else
            res = GetKeyState(vbKeyShift) And KEY_MASK
    End Select
    
    IsShiftKeyDown = CBool(res)
End Function

Public Function IsControlKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''
' IsControlKeyDown
' Returns TRUE or FALSE indicating whether the
' CTRL key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right CTRL key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left CTRL key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' CTRL key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            res = GetKeyState(VK_LCTRL) And KEY_MASK
        Case RightKey
            res = GetKeyState(VK_RCTRL) And KEY_MASK
        Case BothLeftAndRightKeys
            res = (GetKeyState(VK_LCTRL) And GetKeyState(VK_RCTRL) And KEY_MASK)
        Case Else
            res = GetKeyState(vbKeyControl) And KEY_MASK
    End Select
    
    IsControlKeyDown = CBool(res)

End Function

Public Function IsAltKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''
' IsAltKeyDown
' Returns TRUE or FALSE indicating whether the
' ALT key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right ALT key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left ALT key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' ALT key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            res = GetKeyState(VK_LALT) And KEY_MASK
        Case RightKey
            res = GetKeyState(VK_RALT) And KEY_MASK
        Case BothLeftAndRightKeys
            res = (GetKeyState(VK_LALT) And GetKeyState(VK_RALT) And KEY_MASK)
        Case Else
            res = GetKeyState(vbKeyMenu) And KEY_MASK
    End Select
    
    IsAltKeyDown = CBool(res)

End Function


Sub Test()
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Test
' This is a procedrue to test and demonstrate the Key-State
' functions above. Since you can't run a macro in the VBA
' Editor if the SHIFT, ALT, or CTRL key is down, this procedure
' uses OnTime to execute the ProcTest test procedure. OnTime
' will call ProcTest two seconds after running this Test
' procedure. Immediately after executing Test, press the
' key(s) (Left/Right SHIFT, ALT, or CTRL) you want to test
' for. The procedure called by OnTime, ProcTest, displays the
' status of the Left/Right SHIFT, ALT, and CTRL keys.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Application.OnTime now + TimeSerial(0, 0, 2), "ProcTest", , True
End Sub


Sub ProcTest()
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ProcTest
' This procedure simply displays the status of the Left adn Right
' SHIFT, ALT, and CTRL keys.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Debug.Print "SHIFT KEY: ", "LEFT: " & CStr(IsShiftKeyDown(LeftKey)), _
                           "RIGHT: " & CStr(IsShiftKeyDown(RightKey)), _
                           "EITHER: " & CStr(IsShiftKeyDown(LeftKeyOrRightKey)), _
                           "BOTH:   " & CStr(IsShiftKeyDown(BothLeftAndRightKeys))
                        
Debug.Print "ALT KEY:   ", "LEFT: " & CStr(IsAltKeyDown(LeftKey)), _
                           "RIGHT: " & CStr(IsAltKeyDown(RightKey)), _
                           "EITHER: " & CStr(IsAltKeyDown(LeftKeyOrRightKey)), _
                           "BOTH:   " & CStr(IsAltKeyDown(BothLeftAndRightKeys))
                        
Debug.Print "CTRL KEY:   ", "LEFT: " & CStr(IsControlKeyDown(LeftKey)), _
                            "RIGHT: " & CStr(IsControlKeyDown(RightKey)), _
                            "EITHER: " & CStr(IsControlKeyDown(LeftKeyOrRightKey)), _
                            "BOTH:   " & CStr(IsControlKeyDown(BothLeftAndRightKeys))

End Sub


' InQuest injected base64 decoded content
' &z{V
' &z{V
' -F(!
' Kjx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' kzw!
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' "jph
' jx.j
' jx.j
' )bjs
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' jx.j
' I+j)
' jx.j
' jx.j
' jx.j
' &z{V
' (^rH
' &z{l
' XzYh
' t*'r

INQUEST-PP=macro
