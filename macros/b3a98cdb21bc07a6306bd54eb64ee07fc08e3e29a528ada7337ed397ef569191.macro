Attribute VB_Name = "BExEventHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents pAppEvents As Application
Attribute pAppEvents.VB_VarHelpID = -1

Private Sub Class_Initialize()
  Set pAppEvents = Application  ' enable events
End Sub

Private Sub pAppEvents_NewWorkbook(ByVal Wb As Workbook)
  Call Common.WorkbookNew(Wb)
End Sub

Private Sub pAppEvents_SheetActivate(ByVal Sh As Object)
 Call Common.SheetActivate(Sh)
End Sub

Private Sub pAppEvents_SheetBeforeDoubleClick(ByVal Sh As Object, ByVal Target As Range, Cancel As Boolean)
  Call Common.SheetBeforeDoubleClick(Sh, Target, Cancel)
End Sub

Private Sub pAppEvents_SheetBeforeRightClick(ByVal Sh As Object, ByVal Target As Range, Cancel As Boolean)
  Call Common.SheetBeforeRightClick(Sh, Target, Cancel)
End Sub

Private Sub pAppEvents_SheetChange(ByVal Sh As Object, ByVal Target As Range)
  Call Common.SheetChange(Sh, Target)
End Sub

Private Sub pAppEvents_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)
  Call Common.SheetSelectionChange(Sh, Target)
End Sub

Private Sub pAppEvents_WorkbookActivate(ByVal Wb As Workbook)
  Call Common.WorkbookActivate(Wb)
  Call Common.ChangeCaption
End Sub

Private Sub pAppEvents_WorkbookAddinInstall(ByVal Wb As Workbook)
    Call Common.AddinInstall(Wb)
End Sub

Private Sub pAppEvents_WorkbookAddinUninstall(ByVal Wb As Workbook)
   Call Common.AddinUninstall(Wb)
End Sub

Private Sub pAppEvents_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
  Call Common.WorkbookBeforeClose(Wb, Cancel)
End Sub

Private Sub pAppEvents_WorkbookBeforeSave(ByVal Wb As Workbook, ByVal SaveAsUI As Boolean, Cancel As Boolean)
  Call Common.WorkbookBeforeSave(Wb, SaveAsUI, Cancel)
End Sub

Private Sub pAppEvents_WorkbookOpen(ByVal Wb As Workbook)
  Call Common.WorkbookOpen(Wb)
End Sub


Private Sub pAppEvents_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
    Call Common.ChangeCaption
End Sub


Attribute VB_Name = "Common"
Option Explicit
Public pAddin As Object
Private pAppEventClass As BExEventHandler
Private pShapes As Collection
Private pBallonn As Balloon
Private lParam As Variant
Private pClosedWorkbooks As Collection
Private pDisableEvents  As Boolean

Public Enum ExcelFileFormat
      xlOpenXMLWorkbook = 51
      xlOpenXMLWorkbookMacroEnabled = 52
      xlExcel12 = 50
      xlExcelXLS = -4143
      xlCSV = 6
      xlCSVMSDOS = 24
      xlTextMSDOS = 21
      xlTextWindows = 20
      xlUnicodeText = 42
      xlCurrentPlatformText = -4158
      xlExcel9795 = 43
      xlExcelXLS11 = 56
End Enum

Sub Auto_Open()
  Call Common.SetStart
End Sub

Sub Auto_Close()
  On Error Resume Next
  Call pAddin.ExcelInterface.Close
  Call CommandBars("BEx Design Toolbox").Delete
  Call CommandBars("BEx Analysis Toolbox").Delete
End Sub

Public Function SetStart() As String
  On Error Resume Next
  Set pShapes = New Collection
  
  Set pAddin = CreateObject("com.sap.bi.et.analyzer.addin.BExConnect")
  If Err <> 0 Then
    SetStart = Err.Description
    Exit Function
  End If
  Call pAddin.ExcelInterface.SetExcel(Application)
  Set Common.pAppEventClass = New BExEventHandler
  ' F4 Help in Navigation Block
  Call Application.OnKey("{F4}", "F4ValueHelp")
  ' Expand/Collapse hierarchy
  Call Application.OnKey("+^{+}", "ExpandCollapseNode")
  Call Application.OnKey("+^{-}", "ExpandCollapseNode")
  Call Application.OnKey("+^{107}", "ExpandCollapseNode") ' + on num block
  Call Application.OnKey("+^{109}", "ExpandCollapseNode") ' - on num block
  Call Application.OnKey("+{F10}", "RightClickSimulate") ' right mouse button on keyboard
End Function

Public Function GetConnect() As Object
  Set GetConnect = pAddin
End Function

Public Sub AttachAddin(iAddin As Object)
  On Error Resume Next
  Set Common.pAddin = iAddin
End Sub

Public Sub SetStatusBar(iString As String)
  On Error Resume Next
  Application.StatusBar = iString
  On Error GoTo 0
End Sub

Private Function DetermineReturnDataType(iValue As Variant)
  If (IsNumeric(iValue) And Not IsDate(iValue)) Then
    DetermineReturnDataType = CDbl(iValue)
  Else
    DetermineReturnDataType = CStr(iValue)
  End If
End Function

Function GetBEx(Optional iWb As Workbook) As Object
  On Error Resume Next
  Dim lName As String
  If Not iWb Is Nothing Then
    lName = iWb.Name
  Else
    lName = Application.ActiveWorkbook.Name
  End If
  Set GetBEx = pAddin.ExcelInterface.WorkbookBExExcelApplication(lName)
End Function

Public Function BexGetData(iDataProv As String, ParamArray iParam() As Variant)
  Dim lRange As Range
  On Error GoTo label
  Set lRange = Application.Caller
  If Not pAddin Is Nothing Then
    lParam = iParam
    BexGetData = DetermineReturnDataType(pAddin.ExcelInterface.BexGetData(lRange.Parent.Parent.Name & "!" & iDataProv, lParam))
    Set lParam = Nothing
  End If
  Exit Function
label:   BexGetData = "#NV"
End Function

Public Function BexGetDataWB(iWorkbookName As String, iDataProv As String, ParamArray iParam() As Variant)
  If Not pAddin Is Nothing Then
    lParam = iParam
    BexGetDataWB = DetermineReturnDataType(pAddin.ExcelInterface.BexGetData(iWorkbookName & "!" & iDataProv, lParam))
  End If
End Function

Public Function BexSetData(iValue As Double, iDataProv As String, ParamArray iParam() As Variant)
  Dim lRange As Range
  On Error GoTo label
  Set lRange = Application.Caller
  If Not pAddin Is Nothing Then
    lParam = iParam
    BexSetData = DetermineReturnDataType(pAddin.ExcelInterface.BexSetData(iValue, lRange.Parent.Parent.Name & "!" & iDataProv, lParam))
    Set lParam = Nothing
  End If
  Exit Function
label:   BexSetData = "#NV"
End Function

Public Function BexSetDataWB(iValue As Double, iWorkbookName As String, iDataProv As String, ParamArray iParam() As Variant)
  If Not pAddin Is Nothing Then
    lParam = iParam
    BexSetDataWB = DetermineReturnDataType(pAddin.ExcelInterface.BexSetData(iValue, iWorkbookName & "!" & iDataProv, lParam))
    Set lParam = Nothing
  End If
End Function

Public Function BexGetCellData(iMemberX As String, iMemberY As String, iDataProv As String)
  On Error GoTo FormatError
  Dim lDouble As Double
  Dim lString As String
  lDouble = Common.pAddin.ExcelInterface.BexGetCellData(iMemberX, iMemberY, Application.Caller.Parent.Parent.Name & "!" & iDataProv)
  BexGetCellData = lDouble
  Exit Function
FormatError:   lString = Common.pAddin.ExcelInterface.BexGetCellData(iMemberX, iMemberY, iDataProv)
  BexGetCellData = lString
End Function

Public Sub DoNothing()
End Sub

Public Sub DesignIconClicked()
  On Error Resume Next
  Dim lCaller As String
  lCaller = Application.Caller
  Call Common.pAddin.ExcelInterface.IconClicked(lCaller)
End Sub

Public Sub InsertShape(iShape As Object)
  Dim lWorkbook As String
  On Error Resume Next
  lWorkbook = iShape.Parent.Parent.Name
  pShapes.Remove (iShape.Name & "!" & lWorkbook)
  Call pShapes.Add(iShape, iShape.Name & "!" & lWorkbook)
End Sub

Public Function GetShape(iName As String, iWorkbook As String) As Object
  Dim lShape As Object
  Dim lName As String
  Dim lWorkbook As Workbook
  Dim lSheet As Worksheet
  On Error Resume Next
  Set lShape = pShapes(iName & "!" & iWorkbook)
  lName = pShapes(iName).Name
  If Err <> 0 Then
    For Each lSheet In Workbooks(iWorkbook)
      For Each lShape In lSheet.Shapes
        If lShape.Name = iName Then
          Set GetShape = lShape
          Exit Function
        End If
      Next
    Next
  Else
    Set GetShape = pShapes(iName & "!" & iWorkbook)
  End If

End Function

Public Sub CustomizeButton(iButton As Object, iText As String)
  On Error Resume Next
  iButton.Object.Caption = iText
End Sub

Public Sub AssignStyle(iWorkbookName As String, iWorksheetName As String, iRangeAddress As String, iStyleName As String)
  Dim lRange As Range
  Dim lWorksheet As Worksheet
  On Error Resume Next
  Set lWorksheet = Application.Workbooks(iWorkbookName).Sheets(iWorksheetName)
  Set lRange = lWorksheet.Range(iRangeAddress)
  lRange.Style = iStyleName
End Sub

Public Sub AutoFitRanges(iWorkbookName As String, iWorksheetName As String, iRangeAddress As String, iSeparator As String)
  On Error Resume Next
  Dim lWorksheet As Worksheet
  Dim lRange As Range
  Dim lAddresses As Variant
  Dim lLoopCount As Integer
  Dim lAddress As String
  Set lWorksheet = Application.Workbooks(iWorkbookName).Sheets(iWorksheetName)
  Set lRange = lWorksheet.Range(iRangeAddress)
  Call lRange.Columns.AutoFit
End Sub

Public Sub FormatRanges1(iSheet As Object, itAddress As Variant, itStyle As Variant, itVBFormat As Variant)
  Dim lCount As Long
  Dim lAddress As Variant
  Dim lSheet As Worksheet
  Dim ltAddress() As String
  Dim ltStyle() As String
  Dim ltVBFormat() As String
  Set lSheet = iSheet
  ltAddress = itAddress
  ltStyle = itStyle
  ltVBFormat = itVBFormat
  
  For Each lAddress In ltAddress
    On Error Resume Next
    lSheet.Range(ltAddress(lCount)).Style = ltStyle(lCount)
    If ltVBFormat(lCount) <> "" Then
        ltVBFormat(lCount) = Replace(ltVBFormat(lCount), """$""", "\$")
        lSheet.Range(ltAddress(lCount)).NumberFormat = ltVBFormat(lCount)
        If Err.Number <> 0 Then WriteToTrace ("Error in FormatRanges1 (" & Err.Number & "): " & Err.Description)
    End If
   lCount = lCount + 1
 Next

End Sub

Public Sub FormatRanges(iWorkbookName As String, iWorksheetName As String, iRangeAddress As String, itRanges() As Object)
  
Dim lPointX As Integer
  Dim lPointY As Integer
  Dim lFormat As Variant
  Dim lRange As Range
  Dim lWorksheet As Worksheet
  Dim lFromMaxRows As Integer
  Dim lToMaxRows As Integer
  Dim lRangeObject As Range
  Dim FileExtStr As String
  Dim lSupportsMoreThan256Columns As Boolean
  Dim ExcelFormat As ExcelFileFormat
      
  On Error Resume Next
  Set lWorksheet = Application.Workbooks(iWorkbookName).Sheets(iWorksheetName)
  Set lRangeObject = lWorksheet.Range(iRangeAddress)
  lPointX = lRangeObject.Column - 1
  lPointY = lRangeObject.Row - 1
  
  'Determine the file format, handling the format column based on the file format
  'Excel 2007-2010 .xlsx, .xlsm, .xlsb supports more than 256 rows
  Select Case Application.Workbooks(iWorkbookName).FileFormat
    Case ExcelFileFormat.xlExcel12, ExcelFileFormat.xlOpenXMLWorkbook, ExcelFileFormat.xlOpenXMLWorkbookMacroEnabled
          lSupportsMoreThan256Columns = True
    Case ExcelFileFormat.xlExcelXLS, ExcelFileFormat.xlExcelXLS11
          lSupportsMoreThan256Columns = False
     Case Else
          lSupportsMoreThan256Columns = False
  End Select
  
  For Each lFormat In itRanges
    If lFormat.X1 + lPointX > 256 And lSupportsMoreThan256Columns = True Then
      lFromMaxRows = lFormat.X1 + lPointX
    ElseIf lFormat.X1 + lPointX > 256 And lSupportsMoreThan256Columns = False Then
       lFromMaxRows = 256
    Else
      lFromMaxRows = lFormat.X1 + lPointX
    End If

    If lFormat.X2 + lPointX > 256 And lSupportsMoreThan256Columns = True Then
        lToMaxRows = lFormat.X2 + lPointX
    ElseIf lFormat.X2 + lPointX > 256 And lSupportsMoreThan256Columns = False Then
        lToMaxRows = 256
    Else
       lToMaxRows = lFormat.X2 + lPointX
    End If

    Set lRange = lWorksheet.Range(lWorksheet.Cells(lFormat.Y1 + lPointY, lFromMaxRows), lWorksheet.Cells(lFormat.Y2 + lPointY, lToMaxRows))

    lRange.Style = lFormat.Style
    If lFormat.VBFORMAT <> "" Then lRange.NumberFormat = lFormat.VBFORMAT
  Next
  Exit Sub
End Sub

Sub SetColor(iWorkbookName As String, iColorIndex As Variant, iRGB As Double)
  On Error Resume Next
  Workbooks(iWorkbookName).Colors(iColorIndex) = iRGB
End Sub

Sub SetPicture(iToolbar As String, iButtonName As String, iObject As Variant)
  On Error Resume Next
  CommandBars(iToolbar).Controls(iButtonName).Picture = iObject
End Sub

Sub ShowForm(iForm As Object)
  On Error Resume Next
  Call iForm.Show
End Sub

Public Sub RenderBorders(iWorkbookName As String, iWorksheetName As String, iRangeAddress() As String)
  On Error Resume Next
  Dim lWorksheet As Worksheet
  Dim lRangeAddress As Variant
  Dim lRange As Range
  Set lWorksheet = Application.Workbooks(iWorkbookName).Sheets(iWorksheetName)
  For Each lRangeAddress In iRangeAddress
    Set lRange = lWorksheet.Range(lRangeAddress)
    lRange.Borders(xlDiagonalDown).LineStyle = xlNone
    lRange.Borders(xlDiagonalUp).LineStyle = xlNone
    With lRange.Borders(xlEdgeLeft)
      .LineStyle = xlDouble
      .Weight = xlThick
      .ColorIndex = xlAutomatic
    End With
    With lRange.Borders(xlEdgeTop)
      .LineStyle = xlDouble
      .Weight = xlThick
      .ColorIndex = xlAutomatic
    End With
    With lRange.Borders(xlEdgeBottom)
      .LineStyle = xlDouble
      .Weight = xlThick
      .ColorIndex = xlAutomatic
    End With
    With lRange.Borders(xlEdgeRight)
      .LineStyle = xlDouble
      .Weight = xlThick
      .ColorIndex = xlAutomatic
    End With
    With lRange.Borders(xlInsideVertical)
      .LineStyle = xlDouble
      .Weight = xlThick
      .ColorIndex = xlAutomatic
    End With
    With lRange.Borders(xlInsideHorizontal)
      .LineStyle = xlDouble
      .Weight = xlThick
      .ColorIndex = xlAutomatic
    End With
  Next
End Sub

Sub HookStatusBar()
  On Error Resume Next
  Call pAddin.ExcelInterface.HookStatusBar
End Sub

Public Sub runWorkbook(iWbid As String, Optional ByVal iDoNotRefresh As Boolean = False)
  On Error Resume Next
  Call pAddin.ExcelInterface.runWorkbook(iWbid, iDoNotRefresh)
End Sub

Public Sub runQuery(iCompID As String)
  On Error Resume Next
  Call pAddin.ExcelInterface.runQuery(iCompID)
End Sub
Public Sub runQueryView(iViewName As String)
  On Error Resume Next
  Call pAddin.ExcelInterface.runQueryView(iViewName)
End Sub

Public Sub SetBalloonText(Optional ByVal iLabel1 As String = "", Optional ByVal iLabel2 As String = "", Optional ByVal iLabel3 As String = "", Optional ByVal iHeading As String = "")
  If Val(Application.Version) > 12 Then Exit Sub
  If Not pBallonn Is Nothing Then
    Assistant.Animation = msoAnimationCheckingSomething
    pBallonn.Close
  End If
  Set pBallonn = Application.Assistant.NewBalloon
  pBallonn.BalloonType = 1
  pBallonn.Icon = 3
  pBallonn.Mode = msoModeModeless
  pBallonn.Button = 1
  pBallonn.Callback = "CloseBalloon"
  pBallonn.Heading = iHeading
  pBallonn.Labels(1).Text = iLabel1
  pBallonn.Labels(2).Text = iLabel2
  pBallonn.Labels(3).Text = iLabel3
  On Error Resume Next
  Call pBallonn.Show
End Sub

Public Sub CloseBalloon(bln As Balloon, lbtn As Long, lPriv As Long)
  If Not pBallonn Is Nothing Then
    Assistant.Animation = msoAnimationCheckingSomething
    pBallonn.Close
  End If
End Sub

Public Sub CreateArray(iCount, ByRef eArray)
  eArray = Array(iCount)
End Sub

Public Sub SelectPicture(iWorkbookName As String, iSheetName As String, iShapeName As String)
  Dim lShape As Shape
  On Error Resume Next
  Set lShape = Application.Workbooks(iWorkbookName).Worksheets(iSheetName).Shapes(iShapeName)
  lShape.Select
End Sub

Public Sub SetRange(iRange, iValue)
  iRange.Value = iValue
End Sub

Public Function LogOn(Optional iUser As String = "", Optional iSystemId As String = "", Optional iServer As String = "", Optional iSysNo As Long = 0, Optional iClient As String = "", Optional iLanguage As String = "", Optional iSNCName As String = "", Optional iSNCQuality As String = "", Optional iTicket As String = "", Optional irouter As String = "") As Boolean
  LogOn = pAddin.ExcelInterface.LogOn(iUser:=iUser, iSystemId:=iSystemId, iServer:=iServer, iSysNo:=iSysNo, iLanguage:=iLanguage, iClient:=iClient, iSNCName:=iSNCName, iSNCQuality:=iSNCQuality, iTicket:=iTicket, irouter:=irouter)
End Function

Public Sub FindLF(ByRef iRange, ByRef eRange)
  On Error Resume Next
  Set eRange = iRange.Find(Chr(10))
End Sub

Public Sub FindNextLF(ByRef iRange, ByRef eRange)
  On Error Resume Next
  Set eRange = iRange.FindNext(eRange)
End Sub

Public Sub DeleteProcedureCode(ByVal iWorkbookName As String, _
                               ByVal DeleteFromModuleName As String, ByVal ProcedureName As String)
' deletes ProcedureName from DeleteFromModuleName in wb
  Dim VBCM As Object, ProcStartLine As Long, ProcLineCount As Long
  Dim lWB As Object
  Const vbext_pk_Proc As Long = 0
  On Error Resume Next
  Set lWB = Application.Workbooks(iWorkbookName)
  Set VBCM = lWB.VBProject.VBComponents(DeleteFromModuleName).CodeModule
  If Not VBCM Is Nothing Then
    ' determine if the procedure exist in the codemodule
    ProcStartLine = 0
    ProcStartLine = VBCM.ProcStartLine(ProcedureName, vbext_pk_Proc)
    If ProcStartLine > 0 Then
      ProcLineCount = VBCM.ProcCountLines(ProcedureName, vbext_pk_Proc)
      VBCM.DeleteLines ProcStartLine, ProcLineCount
    End If
    Set VBCM = Nothing
  End If
  On Error GoTo 0
End Sub

Public Function RangeEmpty(iWorkbookName As String, iSheetName As String, iRangeAddress As String) As String
  Dim lRange As Range
  Dim lWorksheet As Worksheet
  Dim lRows As Integer
  Dim lCols As Integer
  Dim lAddress As String
  Dim lReturnRange As Range
  On Error Resume Next
  lAddress = ""
  Set lWorksheet = Application.Workbooks(iWorkbookName).Sheets(iSheetName)
  Set lRange = lWorksheet.Range(iRangeAddress)

  For lRows = 1 To lRange.Rows.Count
    For lCols = 1 To lRange.Columns.Count
      If Trim(lRange.Cells(lRows, lCols).Value) <> "" Then
        lAddress = lAddress & "|" & lRange.Cells(lRows, lCols).Address
      End If
    Next
  Next

  If Len(lAddress) > 1 Then
    RangeEmpty = Mid(lAddress, 2)
  Else
    RangeEmpty = ""
  End If
End Function

Public Sub MakeAddin(iValue As Boolean)
  Dim lAddin As AddIn
  Application.ScreenUpdating = False
  ThisWorkbook.isAddin = False
  Set lAddin = Application.AddIns.Add(ThisWorkbook.Path & "\BExAnalyzer.xla", False)
  lAddin.Installed = iValue
  ThisWorkbook.isAddin = True
  ThisWorkbook.Saved = True
  Application.ScreenUpdating = True
End Sub

'Macros Accessed from Outside
Public Sub CloseWorkbook(iWorkbookName As String, Optional iSaveChanges As Boolean = False)
  On Error Resume Next
  Call Workbooks(iWorkbookName).Close(iSaveChanges)
End Sub

Public Sub SetCommandBarButtonPicture(iCommandBarButton As CommandBarButton, iPicture As stdole.IPictureDisp)
  On Error Resume Next
  iCommandBarButton.Picture = iPicture
End Sub

Public Sub SetCommandBarButtonMask(iCommandBarButton As CommandBarButton, iMask As stdole.IPictureDisp)
  On Error Resume Next
  iCommandBarButton.Mask = iMask
End Sub

Public Sub RemoveVBProject(iProjectDescription As String)
  On Error Resume Next
  
  Dim lContinue As Boolean
  Dim lIndex As Integer
  
  lContinue = True
  While lContinue = True
    lIndex = lIndex + 1
    If Application.VBE.vbprojects.Item(lIndex).Description = iProjectDescription Then
      Application.VBE.vbprojects.Remove Application.VBE.vbprojects.Item(lIndex)
      lContinue = False
    End If
  Wend
End Sub

'Control Events
Public Sub F4ValueHelp()
  On Error Resume Next
  Dim lRange As Range
  Set lRange = Application.Selection
  If Not lRange Is Nothing Then
    Call pAddin.ExcelInterface.F4ValueHelp(lRange.Parent.Parent.Name, lRange.Parent.Name, lRange.Address)
  End If
End Sub

Public Sub ExpandCollapseNode()
  On Error Resume Next
  Dim lRange As Range
  Set lRange = Application.Selection
  If Not lRange Is Nothing Then
    Call pAddin.ExcelInterface.ExpandCollapseNode(lRange.Parent.Parent.Name, lRange.Parent.Name, lRange.Address)
  End If
End Sub

'Sheet Events
Public Sub SheetActivate(ByVal iSheet As Object)
  On Error Resume Next
  Call pAddin.ExcelInterface.SheetActivate(iSheet)
  On Error GoTo 0
End Sub

Public Sub SheetBeforeDoubleClick(ByVal iSheet As Worksheet, ByVal iTarget As Range, cCancel As Boolean)
  On Error Resume Next
  Call pAddin.ExcelInterface.SheetBeforeDoubleClick(iSheet, iTarget, cCancel)
  On Error GoTo 0
End Sub

Public Sub SheetBeforeRightClick(ByVal iSheet As Worksheet, ByVal iTarget As Range, cCancel As Boolean)
  On Error Resume Next
  Call pAddin.ExcelInterface.SheetBeforeRightClick(iSheet, iTarget, cCancel)
  On Error GoTo 0
End Sub

Public Sub SheetChange(ByVal iSheet As Worksheet, ByVal iTarget As Range)
  On Error Resume Next
  Call pAddin.ExcelInterface.SheetChange(iSheet, iTarget)
  On Error GoTo 0
End Sub

Public Sub SheetSelectionChange(ByVal iSheet As Worksheet, ByVal iTarget As Range)
  On Error Resume Next
  Call pAddin.ExcelInterface.SheetSelectionChange(iSheet, iTarget)
  On Error GoTo 0
End Sub

'Workbook Events
Public Sub WorkbookActivate(ByVal iWorkbook As Workbook)
  On Error Resume Next
  Call pAddin.ExcelInterface.WorkbookActivate(iWorkbook)
End Sub

Public Sub WorkbookBeforeSave(ByVal iWorkbook As Workbook, ByVal iSaveAsUI As Boolean, cCancel As Boolean)
  On Error Resume Next
  Call pAddin.ExcelInterface.WorkbookBeforeSave(iWorkbook, cCancel, iSaveAsUI)
End Sub

Public Sub WorkbookBeforeClose(ByVal iWorkbook As Workbook, cCancel As Boolean)
  On Error Resume Next
  
  Call pAddin.ExcelInterface.WorkbookBeforeClose(iWorkbook, cCancel)
End Sub
                                                        
Public Sub WorkbookClosed()
  On Error Resume Next
  
  Call pAddin.ExcelInterface.WorkbookClosed(Nothing)
End Sub
Public Sub ReSaveWorkbook()
  On Error Resume Next
  
  Call pAddin.ExcelInterface.ReSaveWorkbook(Nothing)
End Sub

Public Sub AdaptCaption()
  On Error Resume Next
  Call pAddin.ExcelInterface.AdaptCaption(Nothing)
End Sub

Public Function GetPlotBy(ByVal iChart As Chart) As Integer
' Code included to activate the chart for Excel application.
    Dim chartType As String
    chartType = iChart.chartType
    GetPlotBy = iChart.PlotBy
End Function

Public Sub WorkbookNew(ByVal iWorkbook As Workbook)
  On Error Resume Next
  Call pAddin.ExcelInterface.WorkbookNew(iWorkbook)
End Sub

Public Sub WorkbookOpen(ByVal iWorkbook As Workbook)
  On Error Resume Next
  
  'auto_open of sapbex0.xla is not to be performed within BExAnalyzer.xla
  If iWorkbook.Name = "sapbex0.xla" Then
    Exit Sub
  End If
  
  'Analysis Tool Pack Add-in crashes with BExAnalyzer.xla. All other Add-ins do not have this
  'issue. The Add-in FUNCRES.XLA(M) loads PROCDB.XLA(M) on demand.
  'If iWorkbook.Name = "PROCDB.XLAM" Or iWorkbook.Name = "PROCDB.XLA" Then
    'Exit Sub
  'End If
  
  'If it is an Add-in, Auto_Open macro will be called implicitly. Only Workbooks(E.g. Locally saved)
  'needs to be initialized and need to call 'Auto_Open' explicitly if any. Add-ins of type .XLL only
  'needs to be registered.
  Dim isAddin As Boolean
  If UCase(iWorkbook.Name) Like "*.XLA" Or UCase(iWorkbook.Name) Like "*.XLAM" Then
   isAddin = True
  End If
  If Not isAddin Then
    If Application.Version >= 15 Then   'JB47 Excel 2013 - Ribbon vanished
      Application.ScreenUpdating = False
      Application.ScreenUpdating = True
      DoEvents
    End If                              'JB47
    Call pAddin.ExcelInterface.WorkbookOpen(iWorkbook)
    Call iWorkbook.RunAutoMacros(xlAutoOpen)     'P:\730_SP_COR\com.sap.bi.et.analyzer\BexAddin\Resources
  End If
End Sub

'BExMenu Events
Public Sub RightClickSimulate()
  On Error Resume Next
  Dim lBoolean As Boolean
  Dim lBEx As Object
  Set lBEx = GetBEx()
  If lBEx.IsOccupied(ActiveCell) Then
    Call Common.SheetBeforeRightClick(ActiveSheet, ActiveCell, lBoolean)
  Else
    Application.CommandBars("Cell").ShowPopup
  End If
End Sub

Sub MenuOpen()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpen
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenQuery()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenQuery
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenWorkbook()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenWorkbook
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenWorkbookDirectInput()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenWorkbookDirectInput
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuShowObjectBrowser()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDShowObjectBrowser
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuShowRequestState()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDShowRequestState
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenFromHistory()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenFromHistory
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuSave()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDSave
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuSaveNewWorkbook()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDSaveNewWorkbook
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuSaveExistingWorkbook()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDSaveExistingWorkbook
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuSaveView()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDSaveView
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuAssignWorkbookToRole()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDAssignWorkbookToRole
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuPersonalizeWorkbook()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDPersonalizeWorkbook
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuRemovePersonalizedWorkbook()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDRemovePersonalizedWorkbook
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuRefreshSub()
On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDRefreshSub
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuRefresh()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDRefresh
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuToggleRefresh()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDToggleRefresh
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuFullRefresh()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDFullRefresh
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuSingleQueryRefresh()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDSingleQueryRefresh
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuRefreshVariables()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDRefreshVariables
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuTools()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDTools
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuToolsUpdate()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDToolsUpdate
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuCreateNewQuery()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDCreateNewQuery
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuChangeQuery()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDChangeQuery
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenBroadcaster()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenBroadcaster
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenPlanningWorkbench()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenPlanningWorkbench
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenReportDesigner()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenReportDesigner
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuOpenWebAnalyzer()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDOpenWebAnalyzer
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuCopySheet()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDCopySheet
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuGlobalSettings()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDGlobalSettings
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuDisplayMessages()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDDisplayMessages
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuToggleConnection()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDToggleConnection
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuConnectionConnect()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDConnectionConnect
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuConnectionDisConnect()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDConnectionDisConnect
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuAbout()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDAbout
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuDisplayAboutInfo()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDDisplayAboutInfo
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuHelp()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDHelp
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuControlsUpdate()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDControlsUpdate
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuToggleDesignMode()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDToggleDesignMode
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlGrid()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlGrid
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlNavigation()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlNavigation
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlFilter()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlFilter
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlButton()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlButton
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlDropdown()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlDropdown
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlCheckbox()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlCheckbox
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlRadioButton()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlRadioButton
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlConditions()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlConditions
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlExceptions()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlExceptions
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlText()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlText
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuInsertControlMessages()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDInsertControlMessages
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuWorkbookProperties()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDWorkbookProperties
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub

Sub MenuProcessPropertiesDialogOfControlItem()
  On Error Resume Next
  Dim lCMD As String
  lCMD = pAddin.ExcelInterface.cCMDProcessPropertiesDialogOfControlItem
  Call pAddin.ExcelInterface.ProcessBExMenuCommand(lCMD)
End Sub
Function MenuRefreshPrecalc(iVariables As Variant, iFileName As String, ByRef eTrace As String, iVariant As String) As Integer
  'this function is called by the precalculation server and does not really have anthing to do with BExMenu
  On Error Resume Next
  eTrace = "Begin MenuRefreshPrecalc" & Chr(13)
  Dim lResult As Boolean
  If pAddin Is Nothing Then eTrace = eTrace & Chr(13) & Common.SetStart
  If pAddin Is Nothing Then
    eTrace = eTrace & "Failed To Create BExConnect in MenuRefreshPrecalc"
    MenuRefreshPrecalc = 0
    Exit Function
  End If
  lResult = pAddin.MenuRefreshPrecalc(iVariables, iFileName, eTrace, iVariant)
  If lResult Then
    MenuRefreshPrecalc = 1
    eTrace = eTrace & Chr(13) & _
            "Success" & _
             "End of MenuRefreshPrecalc"
  Else
    eTrace = eTrace & Chr(13) & _
             "ErrorDesciption:" & _
             Err.Description & Chr(13) & _
             "Result: " & lResult & Chr(13) & _
             "End of MenuRefreshPrecalc"
    MenuRefreshPrecalc = 0
  End If
End Function



'xBEXapi
Public Sub WriteToTrace(iText As String)
  Call pAddin.WriteToTrace("3.x API Call Finished")
End Sub


'???
Sub MenuOpenInfoProvider()
  On Error Resume Next
  Call pAddin.MenuOpenInfoProvider
End Sub

Sub MenuOpenView()
  On Error Resume Next
  Call pAddin.MenuOpenView
End Sub

Sub MenuDisplayTrace()
  On Error Resume Next
  Call pAddin.MenuDisplayTrace
End Sub

Sub MenuDefaultWorkbook()
  On Error Resume Next
  Call pAddin.MenuDefaultWorkbook
End Sub

Sub MenuPauseRefresh()
  On Error Resume Next
  Call pAddin.MenuPauseRefresh
End Sub

Sub MenuServerInformation()
  On Error Resume Next
  Call pAddin.MenuServerInformation
End Sub

Sub MenuToolsWebApplicationDesigner()
  On Error Resume Next
  Call pAddin.MenuToolsWebApplicationDesigner
End Sub

Sub MenuTrace()
  On Error Resume Next
  Call pAddin.MenuTrace
End Sub

Sub MenuNewBlankWorkbook()
  On Error Resume Next
  Call pAddin.MenuNewBlankWorkbook
End Sub
Sub AddinInstall(ByVal iWorkbook As Workbook)
 If iWorkbook.Name = "BExAnalyzer.xla" Then
   Call Common.Auto_Open
 End If
End Sub
Sub AddinUninstall(ByVal iWorkbook As Workbook)
 If iWorkbook.Name = "BExAnalyzer.xla" Then
   Call Common.Auto_Close
 End If
End Sub
Public Function BExDisableEvents() As Boolean
pDisableEvents = True
BExDisableEvents = pDisableEvents
End Function
Public Function BExEnableEvents() As Boolean
pDisableEvents = False
BExEnableEvents = pDisableEvents
End Function
Sub ChangeCaption()
   If Not Application.ActiveWorkbook Is Nothing Then
       Call pAddin.ExcelInterface.ChangeCaption(Application.ActiveWorkbook.Name)
   End If
End Sub
Attribute VB_Name = "ConnectionHandling"
Option Explicit

#If Win64 Then    'JB2009
  Public Declare PtrSafe Function GetActiveWindow Lib "user32.dll" () As Long
  Private Declare PtrSafe Function FindWindow Lib "USER32" Alias "FindWindowA" _
                                      (ByVal lpClassName As Any, ByVal lpWindowName As Any) As Long
#Else
  Public Declare Function GetActiveWindow Lib "USER32" () As Long
  Private Declare Function FindWindow Lib "USER32" Alias "FindWindowA" _
                                      (ByVal lpClassName As Any, ByVal lpWindowName As Any) As Long
#End If

Public gBatch As Boolean
Public p_connectionObj As Object
Public g_logonObj As Object
Public pBExNco3Logon As Object

Function sapBEXgetConnection(Optional IWhat As Integer) As Variant
  If IWhat = 0 Then
    If pAddin Is Nothing Then Call SetStart
    If pAddin Is Nothing Then Exit Function
    If pAddin.ExcelInterface.IsNCo3 Then
      Set pBExNco3Logon = pAddin.ExcelInterface.NCo3Logon
      Set sapBEXgetConnection = pBExNco3Logon
    Else
      'try to get BexApi Connection
      Dim lBEx As Object
      Set lBEx = GetBEx
      On Error Resume Next
      Set p_connectionObj = lBEx.ComConnection
      If Err.Number <> 0 Then Set p_connectionObj = Nothing
      On Error GoTo 0
      If p_connectionObj Is Nothing Then If Not prepareConnection Then Exit Function
      Set sapBEXgetConnection = p_connectionObj
    End If
  End If
End Function

Function sapBEXinitConnection(Optional newConnectionObj As Object) As Boolean
  If Not newConnectionObj Is Nothing Then Set p_connectionObj = newConnectionObj
  sapBEXinitConnection = initConnection
End Function

Public Function GetMyWindow() As Long
  Application.Caption = "   Microsoft Excel"
  GetMyWindow = FindWindow(0&, Application.Caption)
  Application.Caption = Empty
End Function

Function SAPBEXsetVariables(varValues As Range) As Integer
Call pAddin.SetVariables(varValues.Value2, varValues.Application.ActiveWorkbook.Name)
End Function
Public Function initConnection() As Boolean
  initConnection = False
  If pAddin Is Nothing Then Call SetStart
  If pAddin Is Nothing Then Exit Function
  If IsConnected Then
    If Not pAddin.ExcelInterface.IsNCo3 Then
      Call pAddin.ExcelInterface.SetConnectionFromHandle(p_connectionObj)
    End If
    If Len(pWbid) > 1 Then
      Call pAddin.ExcelInterface.runWorkbook(pWbid)
    Else
      If Len(pQueryid) > 1 Then
        Call pAddin.ExcelInterface.runQuery(pQueryid)
      End If
    End If
  End If
  initConnection = IsConnected
End Function

Public Function prepareConnection() As Boolean
  prepareConnection = False
  If provideComponent(g_logonObj, "SAP.LogonControl.1", "Logon Manager") Then
    g_logonObj.ApplicationName = "BEx"
    g_logonObj.enable3d
    Set p_connectionObj = g_logonObj.newconnection()
    p_connectionObj.rfcwithdialog = 1
    #If ABAPDebug Then
      p_connectionObj.TraceLevel = vbKeyD
    #End If
    prepareConnection = True
  End If
End Function

Public Function IsConnected(Optional andRefreshed As Boolean, Optional andInteractive As Boolean, Optional andValid As Boolean) As Boolean
  IsConnected = False
  If Not p_connectionObj Is Nothing Then
    IsConnected = (p_connectionObj.IsConnected = 1)
  Else
    If pAddin Is Nothing Then Call SetStart
    If pAddin Is Nothing Then Exit Function
    If Not pBExNco3Logon Is Nothing Then
      IsConnected = CBool(pBExNco3Logon.IsConnected = 1)
    End If
  End If
End Function

Function provideComponent(compObj As Object, compName As String, compTitle As String) As Boolean
  provideComponent = True
  On Error Resume Next
  If compObj Is Nothing Then
    Set compObj = CreateObject(compName)
    If compObj Is Nothing Then
      provideComponent = False
    End If
  End If
End Function

Public Sub DoAllEvents()
  DoEvents
End Sub

Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "sample"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "xBEXapi"
Option Explicit

'Store the errors which occurred while executing the APIs in p_extErrorText.
'This can be requested using the SAPBEXgetErrorText API. If any API
'function returns an integer value <> 0, it means an error occurred
'and SAPBEXgetErrorText is used to get the error text
Private p_extErrorText As String

'Global variables to store the filters and drillstate passed using byref
Private g_SAPBEXgetFilterValue_IntValue As String
Private g_SAPBEXgetFilterValue_HierValue As String
Private g_SAPBEXgetDrillState_CurrentState As Integer
Private g_SAPBEXgetResultRange_ResultArea As Range

'Adapting the published APIs for the 3.x Analyzer to the 7.0 Analyzer

Public Sub SAPBEXpauseOn()
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXpauseOn called - NOT SUPPORTED IN 7.0!")
  p_extErrorText = "API not supported in 7.0"
End Sub

Public Sub SAPBEXpauseOff()
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXpauseOff called - NOT SUPPORTED IN 7.0!")
  p_extErrorText = "API not supported in 7.0"
End Sub

Private Sub extErrorBegin(callerText As String)
  p_extErrorText = ""
  Common.WriteToTrace (callerText)
End Sub

Private Sub extErrorEnd()
  Common.WriteToTrace ("3.x API Call Finished")
End Sub

Public Function SAPBEXgetErrorText() As String
  extErrorBegin ("3.x API SAPBEXgetErrorText called")
  SAPBEXgetErrorText = p_extErrorText
  extErrorEnd
End Function

Public Function SAPBEXrefresh(allQueries As Boolean, Optional atCell As Range) As Integer
  'In the 7.0 Analyzer, ALL the items in the workbook can be refreshed, but refreshing
  'a query individually is not supported
  On Error Resume Next
  
  extErrorBegin ("3.x API SAPBEXRefresh called")
  
  If allQueries = True Then
    Common.MenuRefresh
    SAPBEXrefresh = 0
  ElseIf Not atCell Is Nothing Then
    Dim lActiveCell As Range
    Set lActiveCell = ActiveCell
    Sheets(atCell.Worksheet.Name).Activate
    atCell.Select
    Common.MenuSingleQueryRefresh
    Sheets(lActiveCell.Worksheet.Name).Activate
    lActiveCell.Select
    SAPBEXrefresh = 0
  Else
    SAPBEXrefresh = 700
    p_extErrorText = "With 7.0, this API is partly supported to refresh ALL items in the workbook, NOT an individual Query"
  End If
  
  extErrorEnd
End Function

Public Function SAPBEXsetDrillState(newState As Integer, Optional atCell As Range) As Integer
  extErrorBegin ("3.x API SAPBEXsetDrillState called")

  If atCell Is Nothing Then Set atCell = Application.ActiveCell
  SAPBEXsetDrillState = pAddin.SAPBEXsetDrillState(ActiveWorkbook.Name, newState, atCell)

  extErrorEnd
End Function

Function SAPBEXgetDrillState_CurrentState() As Integer: SAPBEXgetDrillState_CurrentState = g_SAPBEXgetDrillState_CurrentState: End Function

Public Function SAPBEXgetDrillState(currentState As Integer, Optional atCell As Range) As Integer
  extErrorBegin ("3.x API SAPBEXgetDrillState called")

  If atCell Is Nothing Then Set atCell = Application.ActiveCell
  SAPBEXgetDrillState = pAddin.SAPBEXgetDrillState(ActiveWorkbook.Name, currentState, atCell)
  g_SAPBEXgetDrillState_CurrentState = currentState

  extErrorEnd
End Function

Public Function SAPBEXsetFilterValue(intValue As String, Optional hierValue As String, Optional atCell As Range) As Integer
  extErrorBegin ("3.x API SAPBEXsetFilterValue called")

  If atCell Is Nothing Then Set atCell = Application.ActiveCell
  SAPBEXsetFilterValue = pAddin.SAPBEXsetFilterValue(ActiveWorkbook.Name, intValue, hierValue, atCell)

  extErrorEnd
End Function

Function SAPBEXgetFilterValue_IntValue() As String: SAPBEXgetFilterValue_IntValue = g_SAPBEXgetFilterValue_IntValue: End Function

Function SAPBEXgetFilterValue_HierValue() As String: SAPBEXgetFilterValue_HierValue = g_SAPBEXgetFilterValue_HierValue: End Function

Public Function SAPBEXgetFilterValue(intValue As String, hierValue As String, Optional atCell As Range) As Integer
  extErrorBegin ("3.x API SAPBEXgetFilterValue called")

  If atCell Is Nothing Then Set atCell = Application.ActiveCell
  SAPBEXgetFilterValue = pAddin.SAPBEXgetFilterValue(ActiveWorkbook.Name, intValue, hierValue, atCell)
  g_SAPBEXgetFilterValue_IntValue = intValue
  g_SAPBEXgetFilterValue_HierValue = hierValue

  extErrorEnd
End Function

Public Function SAPBEXcopyFilterValue(fromCell As Range, Optional atCell As Range) As Integer
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXcopyFilterValue called - NOT SUPPORTED IN 7.0!")
  SAPBEXcopyFilterValue = 700
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXfireCommand(fCode As String, Optional atCell As Range) As Integer
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXfireCommand called - NOT SUPPORTED IN 7.0!")
  SAPBEXfireCommand = 700
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXcheckContext(fCode As String, Optional atCell As Range) As Integer
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXcheckContext called - NOT SUPPORTED IN 7.0!")
  SAPBEXcheckContext = 700
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXshowTextElements(Optional selectGroup As String, Optional atCell As Range) As Integer
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXshowTextElements called - NOT SUPPORTED IN 7.0!")
  SAPBEXshowTextElements = 700
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXjumpInitial(queryID As String, jumpType As String, jumpTarget As String) As String
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXjumpInitial called - NOT SUPPORTED IN 7.0!")
  SAPBEXjumpInitial = 700
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXjump(jumpType As String, jumpTarget As String, Optional atCell As Range) As Integer
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXjump called - NOT SUPPORTED IN 7.0!")
  SAPBEXjump = 700
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXgetResultRange_ResultArea() As Range
'Not supported in 7.0; Not a published 3.x API
  extErrorBegin ("3.x API SAPBEXgetResultRange_ResultArea called - NOT SUPPORTED IN 7.0!")
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXgetResultRange(ByRef resultArea As Range, dataOnly As Boolean, Optional atCell As Range) As Boolean
'Not supported in 7.0; Not a published 3.x API
  extErrorBegin ("3.x API SAPBEXgetResultRange called - NOT SUPPORTED IN 7.0!")
  SAPBEXgetResultRange = False
  p_extErrorText = "API not supported in 7.0"
End Function

Public Function SAPBEXgetResultRangeByID(ByVal queryID As String, Optional ByVal charName As String) As Range
  extErrorBegin ("3.x API SAPBEXgetResultRangeByID called")

  If Not queryID = "" Then
    On Error Resume Next
    Set SAPBEXgetResultRangeByID = pAddin.SAPBEXgetResultRangeByID(ActiveWorkbook.Name, queryID, charName)
  Else
    p_extErrorText = "queryID not specified"
  End If

  extErrorEnd
End Function

Public Function SAPBEXsaveWorkbook(Optional wbName As String) As Integer
'Not possible to save programmatically without the Open Save Dialog coming up
'Hence determine if it is in precalc mode
  extErrorBegin ("3.x API SAPBEXsaveWorkbook called")
  If Application.Visible = True Then
    Common.MenuSaveNewWorkbook
  Else
    SAPBEXsaveWorkbook = 700
    p_extErrorText = "In Precalc mode: Since Save Dialog will come up for saving the workbook cannot save using the API in precalc mode"
  End If
  extErrorEnd
End Function

Public Function SAPBEXreadWorkbook(wbID As String) As String
  extErrorBegin ("3.x API SAPBEXreadWorkbook called")
  SAPBEXreadWorkbook = pAddin.SAPBEXreadWorkbook(wbID)
  extErrorEnd
End Function

Public Function SAPBEXgetWorkbookID(wbName As String) As String
  extErrorBegin ("3.x API SAPBEXgetWorkbookID called")
  SAPBEXgetWorkbookID = pAddin.SAPBEXgetWorkbookID(wbName)
  extErrorEnd
End Function

Public Function SAPBEXembedQuery(genUID As String, Optional atActiveCell As Boolean) As String
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXembedQuery called - NOT SUPPORTED IN 7.0!")
  p_extErrorText = "API not supported in 7.0"
End Function

Public Sub SAPBEXunattended()
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXunattended called - NOT SUPPORTED IN 7.0!")
  p_extErrorText = "API not supported in 7.0"
End Sub

Public Sub SAPBEXtoolbar()
'Not supported in 7.0
  extErrorBegin ("3.x API SAPBEXtoolbar called - NOT SUPPORTED IN 7.0!")
  p_extErrorText = "API not supported in 7.0"
End Sub

Public Sub OpenWorkbook(iWorkbookID As String)
  On Error Resume Next
  Call SAPBEXreadWorkbook(iWorkbookID)
End Sub

Attribute VB_Name = "xBexPrec"
Option Explicit

Public pQueryid As String
Public pWbid As String
Private psConnObj As Object
Private g_serverObj As Object
Private pSheetName As String
Private pDummyindex As Integer
Private Const cReturnOK As Integer = 0  ' connection existed and was used
Private Const cReturnNoConn As Integer = 1  ' connection does not exist / add-in is not loaded
Private Const cReturnWrongConn As Integer = 2  ' connection existed, but addresses the wrong system
Private Const cReturnError As Integer = 3  ' connection can not be created on this PC
#If Win64 Then    'SNS_
Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long

#Else
Declare Function GetCurrentProcessId Lib "kernel32" () As Long

#End If

#If Win64 Then    'JB___
  Declare PtrSafe Function GetWindowThreadProcessId Lib "user32.dll" _
                                          (ByVal hwnd As Long, lpdwProcessId As Long) As Long
#Else
  Declare Function GetWindowThreadProcessId Lib "user32.dll" _
                                          (ByVal hwnd As Long, lpdwProcessId As Long) As Long
#End If

Public Function SAPBEX0directLaunch( _
       sysNo As String, user As String, _
       Optional jumpType As String, Optional jumpTarget As String _
                                  ) As Integer

  Dim connObj As Object
  Set connObj = sapBEXgetConnection
  If connObj Is Nothing Then
    SAPBEX0directLaunch = cReturnError
  Else
    With connObj
      If .IsConnected = 1 Then

        On Error Resume Next
        Dim currUser As String
        currUser = sapBEXgetConnection(1)
        If currUser = "" Then currUser = .user
        Dim currSysNumber As String
        currSysNumber = sapBEXgetConnection(2)
        If currSysNumber = "" Then currSysNumber = Format(.systemnumber, "00")
        On Error GoTo 0

        If sysNo = currSysNumber And (user = currUser Or currUser = "") Then
          ' note: '... Or .user = "" ...' is due to bug in 4.5a basis regarding the 'serverLaunch' case
          Application.OnTime Now, "doAction"  ' start asynchronous !
          SAPBEX0directLaunch = cReturnOK
        Else
          SAPBEX0directLaunch = cReturnWrongConn
        End If
      Else
        SAPBEX0directLaunch = cReturnNoConn
      End If
    End With
  End If

End Function

Public Function SAPBEX0serverLaunch(sysNo As String, user As String, gwService As String, gwHost As String, sessionID As String, ByRef eMessage As String) As Integer

  Dim directLaunch As Integer
  directLaunch = SAPBEX0directLaunch(sysNo, user)
  If directLaunch <> cReturnNoConn Then
    SAPBEX0serverLaunch = directLaunch
    eMessage = "Connection returned via DirectLaunch"
    Exit Function
  End If

  If Not (g_serverObj Is Nothing) Then
    g_serverObj.finish
    Set g_serverObj = Nothing
  End If

  On Error GoTo unexpectedError
  Set g_serverObj = CreateObject("SAP.BIWRFCServerCtrl.1")
  Set g_serverObj.configuration.ParentApplication = Application
  g_serverObj.configuration.Caller = "RUN"
  g_serverObj.configuration.eventconnected = ThisWorkbook.Name & "!SAPBEX0serverEvent"
    g_serverObj.progID = sessionID
    g_serverObj.gwService = Trim(gwService)
    g_serverObj.gwHost = Trim(gwHost)
    Set psConnObj = sapBEXgetConnection
    Set g_serverObj.Connection = psConnObj
    If Not g_serverObj.register Then
      eMessage = eMessage & "Registration to " & Trim(gwHost) & "/" & Trim(gwService) & " failed."
      Else
      eMessage = eMessage & "Registration to " & Trim(gwHost) & "/" & Trim(gwService) & " succeeded."
    End If
  SAPBEX0serverLaunch = cReturnNoConn
  Exit Function
unexpectedError:
  SAPBEX0serverLaunch = cReturnError
 eMessage = "Registration to " & Trim(gwHost) & "/" & Trim(gwService) & " failed. (" & Err.Description & ")"
End Function


Public Function SAPBEX0serverLaunchRRMX( _
       sysNo As String, user As String, _
       wbID As String, queryID As String, _
       gwService As String, gwHost As String, sessionID As String _
                                            ) As Integer
  Stop
  pWbid = wbID
  pQueryid = queryID
  Dim directLaunch As Integer
  directLaunch = SAPBEX0directLaunch(sysNo, user)
  If directLaunch <> cReturnNoConn Then
    SAPBEX0serverLaunchRRMX = directLaunch
    Exit Function
  End If
  If Not (g_serverObj Is Nothing) Then
    g_serverObj.finish
    Set g_serverObj = Nothing
  End If

  On Error GoTo unexpectedError
  Set g_serverObj = CreateObject("SAP.BIWRFCServerCtrl.1")


  With g_serverObj
    With .configuration
      Set .ParentApplication = Application
      .Caller = "RUN"
      .eventconnected = ThisWorkbook.Name & "!SAPBEX0serverEvent"
    End With
    .progID = sessionID
    .gwService = Trim(gwService)
    .gwHost = Trim(gwHost)
    Set psConnObj = sapBEXgetConnection
    Set .Connection = psConnObj
    .register
  End With


  SAPBEX0serverLaunchRRMX = cReturnNoConn
  Exit Function
unexpectedError:
  SAPBEX0serverLaunchRRMX = cReturnError

End Function


Public Sub SAPBEX0serverEvent()
'            Stop
'            Dim lfunctionName As String * 80
'            Dim lrfcHandle As Long
'            Dim lrfcFunctionName As String * 80
'            Dim lrfcException As String * 255
'            Dim lParamSpace As Long
'
'            lParamSpace = RfcAllocParamSpace(0, 0, 0)
''            RfcAddExportString myParamSpace, 0, "PASSWORD", 8, 0, 8, strPassword
'            lrfcHandle = psConnObj.ConnectionHandle
'            lfunctionName = "SYSTEM_ATTACH_GUI"
'            lrfcFunctionName = lfunctionName & vbNullChar
'
'            If RfcCallExt(lrfcHandle, lParamSpace, lrfcFunctionName) = 0 Then
'                lrfcException = Space(255)
'                If RfcReceiveExt(lrfcHandle, lParamSpace, lrfcException) = 0 Then
'                End If
'            End If
  gBatch = True
  Call sapBEXinitConnection(psConnObj)
End Sub


Public Function GetPid() As Long
  On Error Resume Next
  Dim ltest, ltest2 As Long
  'SNS excel 2013 pid 0
  'ltest = GetMyWindow()
  'ltest = GetWindowThreadProcessId(ltest, ltest2)
  ltest2 = GetCurrentProcessId()
  GetPid = ltest2

End Function

Public Function AddWorksheet() As String
  Dim lobj As Object
  Set lobj = ActiveWorkbook.Worksheets.Add
  pSheetName = lobj.Name
  AddWorksheet = lobj.Name
End Function

Public Sub AddVariables(iArray As Variant)
  On Error Resume Next
  Dim lCols As Integer
  Dim lRows As Integer
  Dim lRange As Range
  Dim i As Integer
  Dim j As Integer
  lCols = UBound(iArray, 2)
  lRows = UBound(iArray, 1)
  For i = 0 To lRows
    For j = 0 To lCols
      Sheets(pSheetName).Cells(i + 1, j + 1) = "'" & iArray(i, j)
    Next j
  Next i
  Set lRange = Sheets(pSheetName).Range(Sheets(pSheetName).Cells(1, 1), Sheets(pSheetName).Cells(lRows + 1, lCols + 1))
  Call SAPBEXsetVariables(lRange)
  Application.AlertBeforeOverwriting = False
  Application.DisplayAlerts = False
  Sheets(pSheetName).Delete
End Sub
Public Sub CreateHeader(iHeaderLeft As String, iHeaderMiddle As String, iHeaderRight As String)
  On Error Resume Next
  With ActiveSheet.PageSetup
    .PrintTitleRows = ""
    .PrintTitleColumns = ""
  End With
  ActiveSheet.PageSetup.PrintArea = ""
  With ActiveSheet.PageSetup
    .LeftHeader = iHeaderLeft
    .CenterHeader = iHeaderMiddle
    .RightHeader = iHeaderRight
    .LeftMargin = Application.InchesToPoints(0.75)
    .RightMargin = Application.InchesToPoints(0.75)
    .TopMargin = Application.InchesToPoints(1)
    .BottomMargin = Application.InchesToPoints(1)
    .HeaderMargin = Application.InchesToPoints(0.5)
    .FooterMargin = Application.InchesToPoints(0.5)
    .PrintHeadings = False
    .PrintGridlines = False
    .PrintComments = xlPrintNoComments
    .PrintQuality = 600
    .CenterHorizontally = False
    .CenterVertically = False
    .Orientation = xlPortrait
    .Draft = False
  End With

End Sub

Public Sub CreateFooter(iFooterLeft As String, iFooterMiddle As String, iFooterRight As String)
  On Error Resume Next
  With ActiveSheet.PageSetup
    .PrintTitleRows = ""
    .PrintTitleColumns = ""
  End With
  ActiveSheet.PageSetup.PrintArea = ""
  With ActiveSheet.PageSetup
    .LeftFooter = iFooterLeft
    .CenterFooter = iFooterMiddle
    .RightFooter = iFooterRight
    .LeftMargin = Application.InchesToPoints(0.75)
    .RightMargin = Application.InchesToPoints(0.75)
    .TopMargin = Application.InchesToPoints(1)
    .BottomMargin = Application.InchesToPoints(1)
    .HeaderMargin = Application.InchesToPoints(0.5)
    .FooterMargin = Application.InchesToPoints(0.5)
    .PrintHeadings = False
    .PrintGridlines = False
    .PrintComments = xlPrintNoComments
    .PrintQuality = 600
    .CenterHorizontally = False
    .CenterVertically = False
    .Orientation = xlPortrait
    .Draft = False
  End With

End Sub


Private Function GetHandleFomname(iQueryName As String) As Integer
  Dim lcnt As Integer
  lcnt = 4
  'Set p_currentRepoSheet = repoGetRepoSheet(ActiveWorkbook, False)
  'While p_currentRepoSheet.Cells(lcnt, 2) <> ""
  '   If p_currentRepoSheet.Cells(lcnt, 3) = iQueryName Then
  '    GetHandleFomname = p_currentRepoSheet.Cells(lcnt, 2)
  '    pDummyindex = lcnt
  'End If
  lcnt = lcnt + 1
  'Wend

End Function


Public Sub PerformOlapCommand(iQueryName As String, Params As Variant)
  On Error Resume Next
  '
  'Dim paramsRow As Object:
  'If tableReset("I_T_CMD_PARAMS") Then
  ''Stop
  'Dim lCols As Integer
  'Dim lRows As Integer
  'Dim i As Integer
  'Dim j As Integer
  'Dim lTarget As Range
  'lCols = UBound(Params, 2)
  'lRows = UBound(Params, 1)
  'For i = 0 To lRows
  '    If Params(i, 0) <> "" Then
  '        Set paramsRow = p_tables("I_T_CMD_PARAMS").Rows.Add
  '        paramsRow(1) = Params(i, 0)
  '        paramsRow(2) = Params(i, 1)
  '    End If
  'Next i
  '
  'Call rfcProcessCommand(GetHandleFomname(iQueryName), "CMD", 0, 0, 0, 0, "", True)
  'p_currentQueryIndex = pDummyindex
  'Set lTarget = RunGetTarget
  ' If lTarget Is Nothing Then Exit Sub
  ' Call rfcGetGrid(GetHandleFomname(iQueryName), False)
  'Call repoWriteQuery(False)
  '                p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQRefreshed) = True
  '                Call displayResult(lTarget, True)
  'End If
  '
End Sub

Public Sub ClearHandles()
'dialOutClearHandles ActiveWorkbook, True
End Sub

Public Sub OpenWb(iWb As String)
  Application.Workbooks.Open (iWb)
End Sub




' InQuest injected base64 decoded content
' x)br
' +y8Z
' *'v+b
' *'v+b
' [Qjx

INQUEST-PP=macro
