Attribute VB_Name = "CVersion"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const DotVersion = "4.2"

Sub get_version(dversion As String)
 dversion = DotVersion
End Sub

Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Public WithEvents xapp As Application
Attribute xapp.VB_VarHelpID = -1

Private Sub Document_New()
    ' Neues Dokument
    Dim v As Variable
    For Each v In ActiveDocument.Variables
        v.Delete
    Next
    
    ActiveDocument.Variables.Add "Beck_Meta_Geandert", "nein"
    ActiveDocument.Variables.Add "Beck_Original_Dateiname", "-1"
    
    CheckFirstPara
    init
End Sub

Private Sub Document_Open()
    Dim v As Variable
    If ActiveDocument.Type = wdTypeTemplate Then
        CheckFirstPara
        For Each v In ActiveDocument.Variables
            If StartsWith(v.Name, "Beck_Form_") Then
                v.Delete
            End If
        Next
    End If
    Dim p As Paragraph
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_DokType" Then
          'If ActiveDocument.Type = wdTypeTemplate Then
          '  v.Value = ""
          '  DocTyp = ""
          'Else
            DocTyp = v.Value
          'End If
        ElseIf v.Name = "downcast" Then
          On Error Resume Next
            ActiveDocument.Paragraphs.first.Range.ListFormat.RemoveNumbers NumberType:=wdNumberParagraph
          On Error GoTo 0
          If v.Value = True Then
            ActiveDocument.UpdateStyles
            ActiveDocument.UpdateStylesOnOpen = True
           ' For Each p In ActiveDocument.Paragraphs
           '   p.Style = p.Style
           ' Next p
         '   v.Value = "false"
         ' Else
            v.Delete
         '   ActiveDocument.Save
          End If
        End If
    Next
    
    AenderungsmodusAktiv = ActiveDocument.TrackRevisions
    ActiveDocument.TrackRevisions = False
    
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find
        .text = ChrW(61614)
        .Replacement.text = ChrW(-3922)
        .Replacement.font.Name = "Symbol"
        .Forward = True
        .Wrap = wdFindContinue
        .Format = True
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
    
    
    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
    
    'ListenDarstellungKorr False
    
    'ListenRestartsFixen ' Ausf|fffd|hrung hier nicht m|fffd|glich, da komisches Verhalten (z.B. erster Absatz wird umformatiert statt der Listen)
    init
End Sub


Private Sub CheckFirstPara()
    With ActiveDocument.Paragraphs(1)
        If .Range.text = Chr(13) And .Style = ActiveDocument.styles(wdStyleNormal) Then
            .Style = "Absatz"
        End If
    End With
End Sub

Private Sub xapp_DocumentBeforeClose(ByVal Doc As Document, Cancel As Boolean)
    ' Verlagswunsch: Pr|fffd|fung der Anmerkungsnummern
    'If Doc.Type = wdTypeTemplate Then Exit Sub
    
    Dim msg As String
    If InStr(Doc.AttachedTemplate, "Beck_Formularbuch.dotm") Then
        msg = modForms.AnmerkungsverweisePruefen(False)
        If msg <> "" Then
            Cancel = MsgBox(msg & vbNewLine & "M|fffd|chten Sie das Dokument nun weiter bearbeiten?", vbYesNo Or vbExclamation) = vbYes
        End If
    End If
End Sub
Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{296933D8-8F41-462F-A6F7-D93F63416484}{5FFD2947-4320-416D-A26D-B4632AA27C4E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private dversion As New CVersion

Private Sub UserForm_Initialize()
    Dim dokversion As String
    Dim sIntro As String
    sIntro = "Beck Formularbuch Dot Version "
    dversion.get_version dokversion
    intro.Caption = sIntro & dokversion
    
    lblCopy.Caption = "Reemers Publishing Services GmbH" & vbNewLine & _
    "Luisenstr. 62" & vbNewLine & _
    "D-47799 Krefeld" & vbNewLine & vbNewLine & _
    "Fon +49-2151-60773-0" & vbNewLine & _
    "Fax +49-2151-60773-99" & vbNewLine & vbNewLine & _
    "info@reemers.de" & vbNewLine & _
    "www.reemers.de"

End Sub
Attribute VB_Name = "frmAnmerkungsLink"
Attribute VB_Base = "0{519A5159-8F9B-4121-A4DA-58AEB54B1C53}{F53C024D-BFEA-4CDC-B2AF-C2FB23A6FC6C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

' Teilweise aus der alten BeckOnline (Formular) Dot |fffd|bernommen

Private Sub btnAbbrechen_Click()
    Unload Me
End Sub

Private Sub btnEintragen_Click()
    Dim nr As Integer, LeerzeichenNochRein As Boolean, bm As String, r As Range, CheckLeft As Boolean
    
    If lstVerweis.ListIndex = -1 Then
        MsgBox "Sie haben keine Anmerkungsnummer ausgew|fffd|hlt.", vbExclamation
        Exit Sub
    End If
    nr = lstVerweis.List(lstVerweis.ListIndex, 0)
    bm = lstVerweis.List(lstVerweis.ListIndex, 1)

    ' ACHTUNG:
    ' Es gibt ein fieses Problem (evtl. Bug von Word) wenn zwei Hyperlinks direkt nebeneinander stehen. Dann klappt der
    ' Zugriff auf die SubAdress-Eigenschaft n|fffd|mlich nicht mehr - warum auch immer. Manchmal st|fffd|rzt Word sogar ab.
    
    LeerzeichenNochRein = True
    CheckLeft = True
    
    ' Workaround wegen Tabellen
    Set r = Selection.Range.Duplicate
    If r.Information(wdWithInTable) Then
        r.Move
        If r.Information(wdAtEndOfRowMarker) Or r.Information(wdEndOfRangeColumnNumber) <> Selection.Information(wdEndOfRangeColumnNumber) Then
            Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
            Selection.TypeText " "
            Selection.Collapse
            Selection.Move , -1
            LeerzeichenNochRein = False
        End If
    End If
    Set r = Selection.Range.Duplicate
    r.Move , -1
    If r.Information(wdWithInTable) Or Selection.Information(wdWithInTable) Then
        If r.Information(wdAtEndOfRowMarker) Or r.Information(wdEndOfRangeColumnNumber) <> Selection.Information(wdEndOfRangeColumnNumber) Then
            CheckLeft = False
        End If
    End If
    
    ' Wenn hier schon eine Anmerkungsziffer steht dann danach noch ein Komma und Leerzeichen danach einf|fffd|gen (test nach rechts)
    Selection.MoveRight wdCharacter, 1, True
    If Selection.Hyperlinks.Count > 0 Then
        MsgBox "Links d|fffd|rfen nicht ohne Abstand nebeneinander stehen. Es wird danach noch ein Komma eingef|fffd|gt.", vbExclamation
        Selection.Collapse wdCollapseStart
        Selection.InsertAfter ", "
        Selection.Style = wdStyleDefaultParagraphFont
        LeerzeichenNochRein = False
    End If
    Selection.Collapse wdCollapseStart
    
    ' Wenn hier schon eine Anmerkungsziffer steht dann davor noch ein Komma und Leerzeichen danach einf|fffd|gen (test nach rechts)
    If CheckLeft Then
        Selection.MoveLeft wdCharacter, 1, True
        If Selection.Hyperlinks.Count > 0 Then
            MsgBox "Links d|fffd|rfen nicht ohne Abstand nebeneinander stehen. Es wird davor noch ein Komma eingef|fffd|gt.", vbExclamation
            Selection.Collapse wdCollapseEnd
            Selection.InsertAfter ", "
            Selection.Style = wdStyleDefaultParagraphFont
        End If
    End If
    Selection.Collapse wdCollapseEnd
    
    ' Den Link erzeugen
    CreateLink bm, nr
    
    ' Falls n|fffd|tig sicherheitshalber gleich noch ein Leerzeichen einf|fffd|gen
    If LeerzeichenNochRein Then
        Selection.Collapse wdCollapseEnd
        Selection.MoveEnd
        If Selection.text <> " " Then
            Selection.Collapse
            Selection.InsertAfter " "
        End If
        Selection.Style = wdStyleDefaultParagraphFont
        Selection.Collapse wdCollapseEnd
    Else
        Selection.Collapse wdCollapseEnd
        Set r = Selection.Range.Duplicate
        If r.MoveEnd Then
            If r.text = " " Then
                Selection.MoveRight
            End If
        End If
    End If
    
    ' Box schliessen
    Unload Me
End Sub

Private Sub lstVerweis_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    ' Doppelklick = Eintragen
    btnEintragen_Click
End Sub

Private Sub UserForm_Activate()
    ' UserForm_Initialize tritt vorher auf; dort darf aber nicht entladen werden
    If lstVerweis.ListCount = 0 Then
        MsgBox "Es gibt keine Anmerkungsnummern in diesem Formular.", vbExclamation
        Unload Me
    End If
End Sub

Private Sub UserForm_Initialize()
    ' Anmerkungsnummern sammeln
    Dim r As Range, colLinks As Collection, colBookmarks As Collection, aVerweise As Variant, i As Variant
    Set r = FormAnmLinkBereich.Duplicate
    GetBookmarks r, colLinks, colBookmarks
    
    ' Anmerkungsnummern sortieren
    aVerweise = SortCollection(colLinks)
    With lstVerweis
        .Clear
        If colBookmarks.Count > 0 Then
            For Each i In aVerweise
                .AddItem i
                .List(.ListCount - 1, 1) = colBookmarks("num" & i)
            Next
        End If
    End With
End Sub

Public Sub GetBookmarks(r As Range, ByRef colLinks As Collection, ByRef colBookmarks As Collection)
    Dim bm As Bookmark, i As Variant
    Set colLinks = New Collection
    Set colBookmarks = New Collection
    
    For Each bm In r.Bookmarks
        If bm.Range.InRange(r) Then ' Range Bookmarks gibt (u.U.?) dasselbe wie ActiveDocument.Bookmarks zur|fffd|ck
            If StartsWith(bm.Name, "AnmNr") Then  ' Schnelle Pr|fffd|fung
                ' Nummer holen
                Dim match As MatchCollection
                If RegexMatches("^AnmNr_(A[0-9]+_)?([0-9]+)$", bm.Name, match) Then
                    i = CInt(match.item(0).SubMatches(1))
                    On Error GoTo weiter
                    colLinks.Add i, "num" & i
                    colBookmarks.Add bm.Name, "num" & i
weiter:
                End If
            End If
        End If
    Next
End Sub

Public Sub CreateLink(bm As String, nr As Integer)
    ' Wird auch vom automatischem CE Makro aufgerufen
    ActiveDocument.Hyperlinks.Add Anchor:=Selection.Range, Address:="", SubAddress:=bm, ScreenTip:="", TextToDisplay:=Trim(str(nr))
    Selection.MoveLeft wdCharacter, 1, True ' TRICK Damit sollte genau der letzte Hyperlink selektiert sein
    If Selection.Fields.Count = 1 Then Selection.Fields(1).ShowCodes = False
    Selection.Hyperlinks(1).Range.font.Superscript = True ' Der neue muss der erste in der Selection sein!
End Sub
Attribute VB_Name = "frmBeckOF"
Attribute VB_Base = "0{629F854C-B7CA-4674-873F-CAC3B8188880}{292E4978-E193-4608-9F78-637946FBDF5C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub btBeckOF_Click()
    DocTyp = "StartBeckOF"
    btOK_Click
End Sub

Private Sub btOK_Click()
    Me.Hide
    ShowFormMeta_org
    Unload Me
End Sub
Attribute VB_Name = "frmErrorlog"
Attribute VB_Base = "0{08986EE8-D8A3-4868-8AFC-5D16319D19E5}{C7294BEE-5A16-4CBB-A80D-EE24774D7D91}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Public qstNoAss$, fehler As Integer

Private Sub cmdClose_Click()
'    ' Bookmarks entfernen
'    RemoveDokprBookmarks
'
'    'Warnungstext einf|fffd|gen
'    If fehler > 0 Then
'        ActiveDocument.Paragraphs(1).Range.Select
'        Selection.Collapse
'        InsertNewParaBefore
'        ActiveDocument.Paragraphs(1).Range.Select
'        Selection.Collapse
'        Selection.TypeText warningp1 & Chr(11) & warningp2 & Chr(11) & warningp3 & Chr(11) & _
'         FormatDateTime(Now, vbLongDate) & ", " & FormatDateTime(Now, vbLongTime)
'        ActiveDocument.Paragraphs(1).Style = "DPWarnungstext"
'        Selection.MoveDown
'        Selection.HomeKey
'    End If
    Unload Me
End Sub

Private Sub cmdErneutPruefen_Click()
    modDokpruefer.DokPruefen
End Sub

Private Sub cmdGo2Err_Click()
    qstNoAss$ = "Mit diesem Fehler ist keine Textstelle verkn|fffd|pft."
    On Error GoTo myerr
    If lstLog.ListIndex >= 0 Then
        Dim strFehler$
        strFehler = arrFehler(lstLog.ListIndex + 1)
        If InStr(strFehler, strHintTrennz) > 0 Then
            strFehler = Left(strFehler, InStr(strFehler, strHintTrennz) - 1)
        End If
        If InStr(strFehler, strFehlerTrennz) > 0 Then
            ' Fehlerinfos holen
            Dim intIdx As Double, strType$, ranIdx As Double, bmName As String
            If Mid(strFehler, InStr(strFehler, strFehlerTrennz) + Len(strFehlerTrennz), 1) = "r" Then
              ranIdx = Mid(strFehler, InStr(strFehler, strFehlerTrennz) + Len(strFehlerTrennz) + 1)
            ElseIf Mid(strFehler, InStr(strFehler, strFehlerTrennz) + Len(strFehlerTrennz), 1) = "b" Then
              bmName = Mid(strFehler, InStr(strFehler, strFehlerTrennz) + Len(strFehlerTrennz) + 1)
            Else
             intIdx = CDbl(Mid(strFehler, InStr(strFehler, strFehlerTrennz) + Len(strFehlerTrennz) + 1))
            End If
            strType = Mid(strFehler, InStr(strFehler, strFehlerTrennz) + Len(strFehlerTrennz), 1)
            Select Case strType
            Case "b"
                If ActiveDocument.Bookmarks.Exists(bmName) Then
                    ActiveDocument.Bookmarks(bmName).Range.Select
                Else
                    err.Raise vbObjectError + 997
                End If
            Case Else
                err.Raise vbObjectError + 998
            End Select
        Else
            MsgBox qstNoAss, vbExclamation
        End If
    Else
        MsgBox "Es ist kein Fehler ausgew|fffd|hlt!", vbExclamation
    End If
    Exit Sub
myerr:
    MsgBox qstAssExist, vbCritical
End Sub

Private Sub lstLog_Change()
    If lstLog.ListIndex >= 0 Then
        Dim strFehler$
        strFehler = arrFehler(lstLog.ListIndex + 1)
        If InStr(strFehler, strHintTrennz) > 0 Then
            lblInfo.Caption = Mid(strFehler, InStr(strFehler, strHintTrennz) + Len(strHintTrennz))
        Else
            lblInfo.Caption = strDefaultHint
        End If
    Else
        lblInfo.Caption = strHintHint
    End If
End Sub

Private Sub lstLog_Click()
    lstLog_Change
End Sub

Private Sub lstLog_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    cmdGo2Err_Click
End Sub

Private Sub UserForm_Initialize()
    If Not Application.Language = msoLanguageIDGerman Then
        cmdClose.Caption = "Close"
        cmdErneutPruefen.Caption = "Check document again"
        cmdGo2Err.Caption = "Go to errorposition"
    End If
    

End Sub

Private Sub UserForm_Terminate()
 ' Bookmarks entfernen
    RemoveDokprBookmarks
    
    'Warnungstext einf|fffd|gen
    If fehler > 0 Then
        ActiveDocument.Paragraphs(1).Range.Select
        Selection.Collapse
        InsertNewParaBefore
        ActiveDocument.Paragraphs(1).Range.Select
        Selection.Collapse
        Selection.TypeText warningp1 & Chr(11) & warningp2 & Chr(11) & warningp3 & Chr(11) & _
         FormatDateTime(Now, vbLongDate) & ", " & FormatDateTime(Now, vbLongTime)
        ActiveDocument.Paragraphs(1).Style = "DPWarnungstext"
        Selection.MoveDown
        Selection.HomeKey
    End If
End Sub
Attribute VB_Name = "frmFormLink"
Attribute VB_Base = "0{9FAE16AB-3808-4C4C-82B1-9D75A8F99C7D}{2CCA0011-8D60-46B8-BBC2-7A4283CE1F86}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Validieren As Boolean
Private orgText

Private Sub btnAbbrechen_Click()
    Unload Me
End Sub

Private Sub txtVerweis_Change()
    ' Wird auch beim Speichern aufgerufen
    Dim lSelStart As Long, lSelLength As Long, sResult As String
    lSelStart = txtVerweis.SelStart
    lSelLength = txtVerweis.SelLength
    sResult = EingabePruefen ' Kein Trim anwenden, sonst kann man kein Leerzeichen eintippen!
    If Trim(sResult) = "" Then
        ' Eingabe falsch
        txtVerweis.BackColor = FormCtl_ColorWrong
    Else
        ' Eingabe okay; ggf. aufgrund ndash-Anpassung neu setzen
        txtVerweis.BackColor = FormCtl_ColorNormal
        If sResult <> txtVerweis.text Then
            txtVerweis.text = sResult
            txtVerweis.SelStart = lSelStart
            txtVerweis.SelLength = lSelLength
        End If
    End If
    If Not Validieren Then
        txtVerweis.BackColor = &H80000005
    End If
End Sub

Private Sub btnEintragen_Click()
    Dim txtVerw As String
    ' Eingabe pr|fffd|fen
    txtVerweis_Change
    If Trim(txtVerweis.text) = "" Then
        MsgBox "Bitte Verweis eingeben.", vbExclamation
        txtVerweis.SetFocus
        Exit Sub
    End If
    If txtVerweis.BackColor = FormCtl_ColorWrong Then
        MsgBox "Der Verweis entspricht nicht dem Schema!", vbExclamation
        txtVerweis.SetFocus
        Exit Sub
    End If
    
    txtVerw = Trim(txtVerweis.text)
    
    
    Dim sSpace As String
    Dim regex As RegExp, matches As MatchCollection
    Set regex = New RegExp
    regex.IgnoreCase = False
    regex.Global = False
    regex.MultiLine = False
    sSpace = "[ " & Chr(160) & ChrW(8201) & ChrW(8202) & ChrW(8197) & "]+"
    regex.Pattern = "(Form\." & sSpace & "(([A-Z]|[IVX]{1,7}|[0-9]+)\.)+)" & sSpace & "(.+)"
    
    Set matches = regex.Execute(txtVerw)
    Do While matches.Count > 0
        txtVerw = matches(0).SubMatches(0) & matches(0).SubMatches(3)
        Set matches = regex.Execute(txtVerw)
    Loop

    
    If orgText = txtVerw Then Unload Me
    
    ' Verweis eintragen
    LinkEintragen txtVerw
End Sub

Public Sub LinkEintragen(sVerweis As String)
    ' Wird auch von Linktaggen aufgerufen
    Dim bFett As Boolean, bKursiv As Boolean, bLeerzeichenAmEnde, r As Range, smc As Boolean
    
    bFett = Selection.font.Bold
    bKursiv = Selection.font.Italic
    
    smc = Options.SmartCutPaste
    Options.SmartCutPaste = False
    On Error GoTo fehler
    
    If Selection.Paragraphs.first.Range.text <> Chr(13) And Selection.Paragraphs.first.Range.text <> Chr(13) & Chr(7) Then
      Selection.MoveStartWhile " " & Chr(160)
      Selection.MoveEndWhile Chr(13), -1
      bLeerzeichenAmEnde = False
    End If
    
    If Selection.start = Selection.End Or Trim(Selection.text) = "" Or RTrim(Selection.text) <> Selection.text Then
        bLeerzeichenAmEnde = True
    End If
    
    Selection.text = ""
    
    
    AenderungsmodusAktiv = ActiveDocument.TrackRevisions
    ActiveDocument.TrackRevisions = False

    
    ' Workaround wegen Tabellen
    Set r = Selection.Range.Duplicate
    If r.Information(wdWithInTable) Then
        r.Move
        If r.Information(wdAtEndOfRowMarker) Or r.Information(wdEndOfRangeColumnNumber) <> Selection.Information(wdEndOfRangeColumnNumber) Then
            Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
            Selection.font.Bold = bFett
            Selection.font.Italic = bKursiv
            Selection.TypeText " "
            Selection.Collapse
            Selection.Move , -1
            bLeerzeichenAmEnde = False
        End If
    End If
    
    ' Leerzeichen eintippen
    If Selection.MoveStart(, -1) Then
        If Selection.text = Chr(13) Then
            Selection.Style = wdStyleDefaultParagraphFont
        ElseIf Selection.text <> " " Then
            Selection.Collapse wdCollapseEnd
            Selection.TypeText " "
            Selection.Collapse wdCollapseEnd
            Selection.MoveStart , -1
            Selection.Style = wdStyleDefaultParagraphFont
            Selection.font.Bold = bFett
            Selection.font.Italic = bKursiv
        End If
    End If
    Selection.Collapse wdCollapseEnd
    Selection.Style = wdStyleDefaultParagraphFont
    EnsureResetStyle
    ApplyLinkStyle
    Selection.font.Bold = bFett
    Selection.font.Italic = bKursiv
    
    ' Pr|fffd|fix eintippen
    Dim sPraefix As String, arrow As String
    Set r = Nothing
    arrow = ChrW(8594) & " " ' Nicht |fffd|ndern ohne Codecheck!
    sPraefix = arrow
    'If FormLinkTyp = Abschnitt Then
    '    sPraefix = ""
    'End If
    If Trim(sPraefix) <> "" Then
        Set r = Selection.Range.Duplicate
        If Not StartsWith(Trim(r.text), Trim(sPraefix)) Then
            r.MoveStart , Len(sPraefix) * -1
        End If
        r.MoveStartWhile " " & Chr(160)
        If StartsWith(r.text, sPraefix) Or (sPraefix = arrow And AscW(r.Characters(1).text) = 8594) Then 'And AscW(r.Characters(1).text) = -3922 And r.Characters(1).font.Name = "Symbol"
            r.Collapse
            r.MoveEnd , Len(sPraefix)
            r.text = ""
        End If
'        Selection.TypeText sPraefix
        If StartsWith(sVerweis, sPraefix) Then
            sVerweis = Mid(sVerweis, Len(sPraefix) + 1)
        End If
    End If
    
    ' Verweis eintippen
    Dim font As String, rstyle As Range
    If sPraefix = arrow Then
        'font = Selection.font.Name
        'Selection.font.Name = "Symbol"
        Set rstyle = Selection.Range.Duplicate
        'Selection.TypeText ChrW(-3922)
        Selection.TypeText ChrW(8594)
        'Selection.font.Name = font
        Selection.TypeText " "
    Else
        Set rstyle = Selection.Range.Duplicate
        Selection.TypeText sPraefix
    End If
    'Selection.TypeText sVerweis
    
    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
    
    Dim macroButton As String
    macroButton = "MACROBUTTON FormVerweis " & sVerweis
    With Selection.Fields.Add(Selection.Range, wdFieldEmpty, macroButton, False)
        ' Zum Anklicken, so dass direkt das Makro ausgef|fffd|hrt wird
        .Code.text = Trim(.Code.text)
        .ShowCodes = False
        rstyle.End = .Result.End
    End With
    
    Set r = Selection.Range.Duplicate
    rstyle.Select
    'If rstyle.Characters(1).font.Name = "Symbol" Then
    '    ApplyLinkStyle
    '    rstyle.Characters(1).font.Name = "Symbol"
    'Else
        ApplyLinkStyle
    'End If
    r.Select
    Set r = Nothing

    Selection.Collapse wdCollapseEnd
    
    ' Leerzeichen nach Verweis
    Dim bAbsatzende As Boolean
    Selection.MoveEnd
    If Selection.text <> " " Then
        bAbsatzende = (Selection.text = Chr(13))
        Selection.Collapse
        If bLeerzeichenAmEnde Or bAbsatzende Then
            Selection.TypeText " "
            Selection.MoveStart , -1
        End If
    End If
    Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
    Selection.font.Bold = bFett
    Selection.font.Italic = bKursiv
    Selection.Collapse wdCollapseEnd
    If bAbsatzende Then
        Selection.MoveStart , -1
        If Selection.text = " " Then Selection.text = ""
        Selection.Collapse
    End If
    EnsureResetStyle
    
fertig:
    Options.SmartCutPaste = smc
    Unload Me
    Exit Sub
fehler:
    MsgBox "Es ist ein Fehler aufgetreten: " & err.Description, vbCritical
    GoTo fertig
End Sub

Public Sub ApplyLinkStyle()
    If FormLinkTyp = Formular Then
        Selection.Style = "Formularverweis"
    ElseIf FormLinkTyp = Anmerkung Then
        Selection.Style = "Anmerkungsverweis"
    ElseIf FormLinkTyp = Abschnitt Then
        Selection.Style = "Abschnittsverweis"
    Else
        Stop
    End If
End Sub

Private Sub UserForm_Initialize()
    ' Formular initialisieren
    Validieren = True
    lblInfo.Caption = "Bitte geben Sie das Verweisziel entsprechend der Gliederungsstruktur" & vbNewLine & "des konkreten Werkes ein." & vbNewLine & vbNewLine & "Beispiele: " & vbNewLine & vbNewLine & _
         "1. Formular- oder Checklistenverweis:" & vbNewLine & _
         vbTab & "- Form. I.1" & vbNewLine & _
         vbTab & "- Form. A.II" & vbNewLine & _
         vbTab & "- Form. A.I.1" & vbNewLine & _
         vbTab & "- Form. A.1" & vbNewLine & vbNewLine & _
          "2. Anmerkungsverweis:" & vbNewLine & _
          vbTab & "auf Anmerkungen zu einem anderen Formular:" & vbTab & "- Form. I.1 Anm. 1" & vbNewLine & _
          vbTab & "auf Anmerkungen zum selben Formular:" & vbTab & vbTab & "- Anm. 1" & vbNewLine & _
          vbTab & "auf Anmerkungen von bis:" & vbTab & vbTab & vbTab & "- Anm. 2" & Chr(150) & "5" & vbNewLine & _
          vbTab & "auf Anmerkungen hintereinander:" & vbTab & vbTab & "- Anm. 1, 2" & vbNewLine & vbNewLine & _
          "3. Vorbemerkungsverweis:" & vbNewLine & _
          vbTab & "- Vorb. A.I" & vbNewLine & vbTab & "- Vorb. A.I.1"
    
    If DocTyp = "BeckOF" Then
        lblInfo.Caption = "Bitte geben Sie das Verweisziel entsprechend der Gliederungsstruktur" & vbNewLine & "des konkreten BeckOF-Moduls ein:" & vbNewLine & vbNewLine & _
            vbNewLine & "Beispiele: " & vbNewLine & vbNewLine & vbNewLine & _
            "1. Formularverweis:" & vbTab & vbTab & vbTab & "- BeckOF Vertrag Form. 1.2" & vbNewLine & vbNewLine & vbNewLine & _
            "2. Anmerkungsverweis:" & vbNewLine & vbNewLine & _
            "Auf Anmerkungen zu einem anderen Formular:" & vbTab & "- BeckOF Vertrag Form. 1.2 Anm. 3" & vbNewLine & vbNewLine & _
            "Auf Anmerkungen zum selben Formular:" & vbTab & vbTab & "- Anm. 1" & vbNewLine & vbNewLine & _
            "Auf Anmerkungen von bis:" & vbTab & vbTab & vbTab & "- Anm. 1 - 5" & vbNewLine & vbNewLine & _
            "Auf Anmerkungen hintereinander:" & vbTab & vbTab & "- Anm. 1, 2"
    End If
    
    If Selection.Fields.Count > 0 Then
      txtVerweis.text = Replace(Selection.Fields.item(1).Code, "MACROBUTTON FormVerweis ", "")
    Else
      txtVerweis.text = GetSelectionText
    End If
    
    If Left(txtVerweis.text, 1) = ChrW(8594) Then
      txtVerweis.text = Right(txtVerweis.text, Len(txtVerweis.text) - 1)
    End If
    
    Do While Left(txtVerweis.text, 1) = ChrW(160) Or Left(txtVerweis.text, 1) = " "
      txtVerweis.text = Right(txtVerweis.text, Len(txtVerweis.text) - 1)
    Loop
    
    
    orgText = txtVerweis.text
    
    txtVerweis_Change
End Sub

Public Function EingabePruefen(Optional verweis As String = "") As String
    ' Wird auch f|fffd|r Linktagging benutzt
    Dim sRetval As String, sSpace As String, sSpaceOpt As String, sRegex As String
    EingabePruefen = ""
    
    sRetval = LTrim(IIf(verweis <> "", verweis, txtVerweis.text))
    ' ndash setzen
    sRetval = RegexReplace("([0-9]+)-([0-9]+)", sRetval, "$1" & Chr(150) & "$2")
    
    'Debug.Print AscW(Mid(sRetval, 5, 1))
    
    sSpace = "[ " & Chr(160) & ChrW(8201) & ChrW(8202) & ChrW(8197) & "]"
    sSpaceOpt = sSpace & "*"
    sSpace = sSpace & "+"
    
    If InStr(1, sRetval, "Form") Then
      FormLinkTyp = Formular
      'sRegex = "(Form)" & "(\." & sSpace & "([A-Z]|[IVX]{1,7}|[0-9]+))+" '& "(" & sSpace & "Alt." & sSpace & "([A-Z]|[IVX]{1,7}|[0-9]+))?"
      sRegex = "([A-Z]|[IVX]{1,7}|[0-9]+)"
      sRegex = "(Form)\." & sSpace & sRegex & "(\." & sSpaceOpt & sRegex & ")*"
    End If
    
    If DocTyp = "BeckOF" Then
        ' Sonderfall BeckOF: Andere Regexes
        sRetval = RegexReplace("([0-9]+" & sSpace & ")-(" & sSpace & "[0-9]+)", sRetval, "$1" & Chr(150) & "$2")
        If InStr(1, sRetval, "Form") Then
            FormLinkTyp = Formular
            sRegex = "(BeckOF [A-Za-z]+ Form\." & sSpace & ")" & "([0-9]+\.|[0-9]+(\.[0-9]+)+)"
        End If
        
        If InStr(1, sRetval, "Anm") Then
          FormLinkTyp = Anmerkung
          sRegex = "^(" & sRegex & sSpace & ")?Anm\." & sSpace & "([0-9]+|[0-9]+," & sSpace & "[0-9]+|[0-9]+" & sSpace & "[\-" & Chr(150) & "]" & sSpace & "[0-9]+)$"
        ElseIf InStr(1, sRetval, "Form") Then
          sRegex = "^" & sRegex & "$"
        End If
    ' F|fffd|r Nicht-BeckOF:
    ElseIf InStr(1, sRetval, "Anm") Then
      FormLinkTyp = Anmerkung
      sRegex = "^(" & sRegex & sSpace & ")?Anm\." & sSpace & "([0-9]+|[0-9]+," & sSpace & "[0-9]+|[0-9]+[\-" & Chr(150) & "][0-9]+)$"
    ElseIf InStr(1, sRetval, "Vorb") Then
      FormLinkTyp = Abschnitt
      sRegex = "^Vorb\." & sSpace & "([A-Z]|[IVX]{1,7}|[0-9]+)(\." & sSpaceOpt & "([A-Z]|[IVX]{1,7}|[0-9]+))*$" '(" & sSpace & "[0-9]+\)?)?$"
    ElseIf InStr(1, sRetval, "Form") Then
      sRegex = "^" & sRegex & "$"
    End If
    
    If sRegex = "" Then Exit Function
    
    
    If RegexMatches("^" & sRegex, sRetval) And Not RegexMatches("[0-9][^0-9]+$", sRetval) Then
        ' Die zweite Pr|fffd|fung ist u.a. um beim Linktagging zu verhindern dass ***Form. A. I. 1 A***nm. getagged wird (obwohl das kein g|fffd|ltiger Link w|fffd|re)
        ' Zudem: Laut den Beispielen im Formular m|fffd|ssen alle Verweise die Nummern enthalten auch auf eine Nummer enden
        EingabePruefen = sRetval
    Else
        EingabePruefen = ""
    End If
End Function
Attribute VB_Name = "frmFormmeta"
Attribute VB_Base = "0{2D525065-0574-4589-A88C-1ACE44B2A0C3}{06B57309-9F6A-4396-AB6E-3ECA254FCBEA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private pForm As Paragraph, pTitle As Paragraph, pMeta As Paragraph
Private Const MetaHinweis As String = "Dieser Absatz enth|fffd|lt Metadaten. Ver|fffd|ndern Sie ihn nicht. " & _
 "Verwenden Sie stattdessen den Befehl "
Private Const MetaHinweisButton As String = "Sonderfunktionen - Metadaten bearbeiten"



Dim orgMeta As String
Dim orgTitel As String
Dim newTitel As String
Dim geaendert As Boolean

Private init As Boolean

' Die fortlaufende Formularnummer und die Formular|fffd|berschrift (= Formularziffer & Formularname) sind nicht zu verwechseln!
' Die fortlaufende Formularnummer wird automatisch im Template generiert
' Dokument = Formular [bzw. Checkliste]

Private Sub btnCancel_Click()
    Unload Me
End Sub

Private Sub btnSave_Click()
    Dim v As Variable
    Dim doctitel As String, kuerzel As String
    Dim AutorName As String
    Dim varOrg As New Collection
    Dim temp
    
    ' Eingaben pr|fffd|fen und merken
    Dim ctl As control, number As String, title As String, meta As String, i As Integer, _
     tmp As String, msg As String, ctlName As String, ctlLabel As String, required As Boolean
    number = ""
    title = ""
    meta = ""
    kuerzel = ""
    
    doctitel = Me.txtWerkkuerzel.Value
    If doctitel = "" Then doctitel = Me.cboWerkkuerzel.text
    If doctitel <> "" Then doctitel = doctitel & "_"
    
    
    
    For Each v In ActiveDocument.Variables
        If StartsWith(v.Name, "GlobMeta") Then
            varOrg.Add v.Value, v.Name
            v.Delete
        ElseIf v.Name = "CurFileName" Then
            v.Delete
        End If
    Next
    

    For Each ctl In Me.Controls
        If StartsWith(ctl.Name, "txt") Or StartsWith(ctl.Name, "cbo") Or StartsWith(ctl.Name, "lst") Then
            ' Eingaben pr|fffd|fen
            If Not ctl.Enabled Then GoTo skip
            tmp = Trim(ctl.text)
            ctlName = Mid(ctl.Name, 4)
            ctlLabel = Trim(Me.Controls("lbl" & ctlName).Caption)
            required = False
            If Right(ctlLabel, 1) = "*" Then
                ctlLabel = Left(ctlLabel, Len(ctlLabel) - 1)
                required = True
            End If
            msg = ctlLabel & ": "
            If InStr(tmp, "#") Or InStr(tmp, vbTab) Or InStr(tmp, vbCrLf) Or InStr(tmp, vbCr) Or _
              InStr(tmp, vbLf) Then
                MsgBox msg & "Es sind unerlaubte Zeichen enthalten", vbExclamation
                GoTo wrong
            End If
            If tmp = "" And required And ctl.Name <> "lstRechtsgebiet" Then
                MsgBox msg & "Bitte angeben", vbExclamation
                GoTo wrong
            End If
            If ctl.Name = "txtFormularziffer" Then
                ' Formularziffer
                number = tmp
                'If Not (number Like "#" Or number Like "##" Or number Like "###" Or number Like "####") Then
                '    MsgBox msg & "Bitte eine maximal vierstellige Zahl angeben", vbExclamation
                If DocTyp = "BeckOF" Then
                    If Not RegexMatches("^([0-9]+\.|[0-9]+(\.[0-9]+)+)$", number) Then
                        MsgBox msg & "Bitte eine g|fffd|ltige Formularziffer angeben, " & vbNewLine & _
                        "zum Beispiel 1., 1.2, ...", vbExclamation
                        GoTo wrong
                    End If
                ElseIf Not RegexMatches("^" & FormzifferRegex & "$", number) Then
                    MsgBox msg & "Bitte eine g|fffd|ltige Formularziffer angeben, " & vbNewLine & _
                    "zum Beispiel A., 1., I. oder a)", vbExclamation
                    GoTo wrong
                End If
                
                tmp = ""
            ElseIf ctl.Name = "txtFormularname" Then
                If pForm.Style = "Checkliste Anfang" Then
                    If Trim(Replace(tmp, "Checkliste:", "")) = "" Then
                        MsgBox msg & "Bitte den Titel der Checkliste angeben", vbExclamation
                        GoTo wrong
                    ElseIf Not StartsWith(tmp, "Checkliste: ") Then
                        MsgBox msg & "Der Dokumentname einer Checkliste muss mit 'Checkliste: ' beginnen", vbExclamation
                        GoTo wrong
                    Else
                    End If
                End If
                title = tmp
                tmp = ""
            ElseIf StartsWith(ctl.Name, "txtHigherH") And DocTyp <> "BeckOF" Then
              If ctl.Visible Then
                If Not RegexMatches("^" & FormzifferRegexH & "$", tmp) Then
                    MsgBox msg & "Bitte eine g|fffd|ltige Ziffer angeben, " & vbNewLine & _
                    "zum Beispiel A., 1., I. oder a)", vbExclamation
                    GoTo wrong
                End If
                ActiveDocument.Variables.Add "GlobMeta" & Mid(ctl.Name, Len("txt") + 1), Trim(ctl.text)
                doctitel = doctitel & Replace(Replace(Trim(ctl.text), ")", ""), ".", "") & "."
              End If
              tmp = ""
            ElseIf StartsWith(ctl.Name, "txtHigherH") And DocTyp = "BeckOF" Then
                tmp = ""
            ElseIf ctl.Name = "cboEbenen" Then
                tmp = ""
            ElseIf ctl.Name = "cboDokumenttyp" Then
                tmp = ""
            ElseIf ctl.Name = "cboWerkkuerzel" Or ctl.Name = "txtWerkkuerzel" Then
                kuerzel = tmp
                tmp = ""
            ElseIf ctl.Name = "txtStand" Then
                ' Datum
                If tmp <> "" And Not tmp Like "[0-3][0-9].[0-2][0-9].[1-2][0-9][0-9][0-9]" Then
                    MsgBox msg & "Bitte ein Datum in der Form TT.MM.JJJJ angeben", vbExclamation
                    GoTo wrong
                End If
                If tmp <> "" And Not IsDate(tmp) Then
                    MsgBox msg & "Bitte ein g|fffd|ltiges Datum angeben", vbExclamation
                    GoTo wrong
                End If
            ElseIf ctl.Name = "txtAutor" Then
                AutorName = tmp
                ' Autor
                If tmp <> "" And InStr(tmp, " ") < 1 Then
                    MsgBox msg & "Bitte Vor- und Nachname angeben", vbExclamation
                    GoTo wrong
                End If
            ElseIf ctl.Name = "txtNormen" Then
                ' Pr|fffd|fen (und ggf. ndash setzen)
                txtNormen_Change
                If txtNormen.BackColor = FormCtl_ColorWrong Then
                    If MsgBox(msg & "Die Eingabe entspricht nicht den Richtlinien." & vbNewLine & "Dennoch eintragen?", vbExclamation Or _
                     vbYesNo Or vbDefaultButton2) <> vbYes Then
                        GoTo wrong
                    End If
                End If
            ElseIf ctl.Name = "txtStichworte" Or ctl.Name = "txtKanzlei" Then
                ' Nichts besonderes
            ElseIf ctl.Name = "lstRechtsgebiet" Then
                ' Ausgew|fffd|hlte Rechtsgebiete durch # trennen
                tmp = ""
                For i = 0 To lstRechtsgebiet.ListCount - 1
                    If lstRechtsgebiet.Selected(i) Then
                        If tmp <> "" Then
                            tmp = tmp & "#"
                        End If
                        tmp = tmp & lstRechtsgebiet.List(i, 1)
                    End If
                Next
                If tmp = "" And required Then
                    MsgBox msg & "Bitte angeben", vbExclamation
                    GoTo wrong
                End If
            Else
                Stop
            End If
            
            ' Meta zusammenbauen
            If tmp <> "" Then
                meta = meta & MetaDelim & ctlName & "=" & tmp
            End If
        End If
skip:
    Next
        
    
    DocTyp = cboDokumenttyp.Value
    
    
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_DokType" Then
            v.Delete
         ElseIf v.Name = "AutorName" Then
            v.Delete
        ElseIf v.Name = "Beck_Form_Werkkuerzel" And kuerzel <> "" Then
            v.Delete
        End If
    Next
    ActiveDocument.Variables.Add "Beck_Form_DokType", DocTyp
    ActiveDocument.Variables.Add "AutorName", AutorName
    If kuerzel <> "" Then
        ActiveDocument.Variables.Add "Beck_Form_Werkkuerzel", kuerzel
    End If
    
    DoEvents
    On Error Resume Next
    ActiveDocument.StoryRanges(wdPrimaryFooterStory).Fields.Update
    On Error GoTo 0
    
    
    If newdoc Then
    '  ActiveDocument.Range.Select
    '  If DocTyp = "Checkliste" Then
    '    Block_Erzeugen "Checkliste", True
    '  Else
    '    Block_Erzeugen FormularBlockName, True
    '  End If
      Set pForm = ActiveDocument.Paragraphs.first
    End If
    
    ' Eingaben umsetzen
    Dim rForm As Range
    Set rForm = pForm.Range.Duplicate
    If title <> "" And number <> "" Then
        If Not pTitle Is Nothing Then
            orgTitel = pTitle.Range.text
            pTitle.Range.Delete
        End If
        ' Titelabsatz erstellen
        pForm.Range.Select
        Selection.Collapse
        InsertNewParaBefore
'        Selection.Paragraphs.Last.Range.Select
'        Selection.Collapse
        
        'Selection.ClearFormatting
        EnsureResetStyle
        
        Set pTitle = Selection.Paragraphs.first
        pTitle.Style = ActiveDocument.styles(wdStyleHeading1)
        Selection.TypeText number & vbTab & title
        On Error Resume Next
          pTitle.Range.ListFormat.RemoveNumbers NumberType:=wdNumberParagraph
        On Error GoTo 0
        newTitel = pTitle.Range.text
    End If
    If Not pMeta Is Nothing Then
        orgMeta = pMeta.Range.text
        pMeta.Range.Delete
    End If
    
    ' Metadaten einf|fffd|gen
    If pTitle Is Nothing Then
        err.Raise vbObjectError + 990
        Exit Sub
    End If
    Set pForm = rForm.Paragraphs.first
    pTitle.Range.Select
    Selection.Collapse
    InsertNewParaAfter
    Selection.Paragraphs.Last.Range.Select
    Selection.Collapse
    Set pMeta = Selection.Paragraphs.first
    pMeta.Style = "Metadaten"
    Selection.Style = "Metadaten_Hinweis"
    Selection.TypeText MetaHinweis & Chr(34)
    Dim macroButton As String
    macroButton = "MACROBUTTON FormMetadaten " & Replace(MetaHinweisButton, "{typ}", FormularBlockName)
    With Selection.Fields.Add(Selection.Range, wdFieldEmpty, macroButton, False)
        ' Zum Anklicken, so dass direkt das Makro ausgef|fffd|hrt wird
        .Code.text = Trim(.Code.text)
        .ShowCodes = False
    End With
    Selection.TypeText Chr(34) & "."
    EnsureResetStyle
    Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
    Selection.TypeText meta
    Selection.MoveDown
    
    doctitel = doctitel & Replace(Replace(Trim(Me.txtFormularziffer), ")", ""), ".", "")
    
    temp = Split(Me.txtAutor.Value, "/")
    
    For i = 0 To UBound(temp)
        temp(i) = Trim(temp(i))
        If InStr(1, temp(i), "") > 0 Then
            doctitel = doctitel & "_" & Mid(temp(i), InStrRev(temp(i), " ") + 1)
        Else
            doctitel = doctitel & "_" & temp(i)
        End If
    Next i
    

    
    
'    Dim dp As Dialog
'     Set dp = Dialogs(wdDialogFileSummaryInfo)
'     dp.title = doctitel
'     dp.Execute
     
     ActiveDocument.Variables.Add "CurFileName", doctitel
     
    'ActiveDocument.BuiltInDocumentProperties("Title").Value = doctitel
    
    
    

    If pMeta.Range.text <> orgMeta Then
        geaendert = True
    End If
    If newTitel <> orgTitel Then
        geaendert = True
    End If
    
    
    
    On Error Resume Next
    For Each v In ActiveDocument.Variables
        If varOrg.item(v.Name) = v.Value Then varOrg.Remove v.Name
    Next
    On Error GoTo 0
    
    If varOrg.Count > 0 Then
        geaendert = True
    End If
    
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Meta_Geandert" Then
            v.Delete
        'nur f|fffd|r RK Daten
        ElseIf v.Name = "Beck_Original_Dateiname" And v.Value = "-1" Then
'            geaendert = False
        End If
    Next
    
    
    If geaendert Then
        ActiveDocument.Variables.Add "Beck_Meta_Geandert", "ja"
    Else
        ActiveDocument.Variables.Add "Beck_Meta_Geandert", "nein"
    End If
    
    ' Leerabsatz hinter Formularanfang ggf. entfernen
'    If IsNormalPara(pForm.Next) And pForm.Next.Range.text = Chr(13) Then
'        pForm.Next.Range.Delete
'    End If
    Unload Me
    Exit Sub
wrong:
    ctl.SetFocus
    Exit Sub
End Sub

Private Sub cboDokumenttyp_Change()
  checkPflichtfelder
  cboEbenen.Enabled = True
  If cboDokumenttyp.Value = "BeckOF" Then
        cboEbenen.Value = 0
        cboEbenen_Change
        cboEbenen.Enabled = False
 End If
End Sub


Private Sub cboEbenen_Change()
  Dim i As Integer
  
  For i = 1 To CInt(cboEbenen.text)
    Me.Controls("lblHigherH" & i).Visible = True
    Me.Controls("lblHigherH" & i & "a").Visible = True
    Me.Controls("txtHigherH" & i).Visible = True
  Next i
  
  For i = CInt(cboEbenen.text) + 1 To 4
    Me.Controls("lblHigherH" & i).Visible = False
    Me.Controls("lblHigherH" & i & "a").Visible = False
    Me.Controls("txtHigherH" & i).Visible = False
  Next i
  
  
  
  
  
    If DocTyp = "BeckOF" Then
        Frame1.Top = Frame1.Top - 48
        Me.Height = Me.Height - 48
    Else
        Frame1.Top = txtHigherH1.Top + CInt(cboEbenen.text) * 24
        Me.Height = txtHigherH1.Top + 294 + CInt(cboEbenen.text) * 24
    End If
  
  checkPflichtfelder
End Sub

Private Sub cboWerkkuerzel_Change()
    checkPflichtfelder
End Sub

Private Sub lstRechtsgebiet_Change()
    Dim i As Integer
    For i = 0 To lstRechtsgebiet.ListCount - 1
        If lstRechtsgebiet.Selected(i) Then
            If Not StartsWith(lstRechtsgebiet.List(i), "  ") Then
                lstRechtsgebiet.Selected(i) = False
            End If
        End If
    Next
    checkPflichtfelder
End Sub

Private Sub txtAutor_Change()
    checkPflichtfelder
End Sub

Private Sub txtFormularname_Change()
    checkPflichtfelder
End Sub

Private Sub txtFormularziffer_Change()
    checkPflichtfelder
End Sub

Private Sub txtHigherH1_Change()
  checkPflichtfelder
End Sub

Private Sub txtHigherH2_Change()
  checkPflichtfelder
End Sub

Private Sub txtHigherH3_Change()
  checkPflichtfelder
End Sub

Private Sub txtHigherH4_Change()
  checkPflichtfelder
End Sub

Private Sub txtKanzlei_Change()
    checkPflichtfelder
End Sub

'Private Sub txtHigherH5_Change()
'  checkPflichtfelder
'End Sub

Private Sub txtNormen_Change()
    ' Wird auch beim Speichern aufgerufen
    checkPflichtfelder
    If Not txtNormen.Enabled Then Exit Sub
    Exit Sub ' Nun generell nicht mehr Syntax pr|fffd|fen!
    If txtNormen.text = "" And InStr(lblNormen.Caption, "*") < 1 Then
        txtNormen.BackColor = FormCtl_ColorNormal
        Exit Sub
    End If
    Dim lSelStart As Long, lSelLength As Long, sResult As String
    lSelStart = txtNormen.SelStart
    lSelLength = txtNormen.SelLength
    sResult = NormkettePruefen ' Kein Trim anwenden, sonst kann man kein Leerzeichen eintippen!
    If Trim(sResult) = "" Then
        ' Eingabe falsch
        txtNormen.BackColor = FormCtl_ColorWrong
    Else
        ' Eingabe okay; ggf. aufgrund ndash-Anpassung neu setzen
        txtNormen.BackColor = FormCtl_ColorNormal
        If sResult <> txtNormen.text Then
            txtNormen.text = sResult
            txtNormen.SelStart = lSelStart
            txtNormen.SelLength = lSelLength
        End If
    End If
End Sub

Private Sub txtStand_Change()
    checkPflichtfelder
End Sub

Private Sub txtStichworte_Change()
    checkPflichtfelder
End Sub


Private Sub UserForm_Initialize()
    Dim sr As Boolean
    geaendert = False

    AenderungsmodusAktiv = ActiveDocument.TrackRevisions
    ActiveDocument.TrackRevisions = False

    sr = ActiveDocument.ShowRevisions
    ActiveDocument.ShowRevisions = False

    init = True
    ' Aufrufendes Makro setzt Auswahl entsprechend
    Set pForm = Selection.Paragraphs.first
    If pForm.Style = "Checkliste Anfang" Then
        txtFormularname.text = "Checkliste: "
     End If
    
    ' Kombobox f|fffd|llen
    cboEbenen.AddItem "0"
    cboEbenen.AddItem "1"
    cboEbenen.AddItem "2"
    cboEbenen.AddItem "3"
    cboEbenen.AddItem "4"
    'cboEbenen.AddItem "5"
    
    If DocTyp = "StartBeckOF" Then
        DocTyp = "BeckOF"
    Else
        DocTyp = ""
    End If
    
     Dim v As Variable, ctl As control, i As Integer, k As Integer, werk As String
    For Each v In ActiveDocument.Variables
    
        If v.Name = "Beck_Form_DokType" Then
            DocTyp = v.Value
        ElseIf v.Name = "Beck_Form_Werkkuerzel" Then
            txtWerkkuerzel.text = v.Value
            werk = v.Value
        ElseIf StartsWith(v.Name, "GlobMeta") Then
            Set ctl = Nothing
            On Error Resume Next
            Set ctl = Me.Controls(Replace(v.Name, "GlobMeta", "txt"))
            On Error GoTo 0
            If Not ctl Is Nothing Then
                ctl.text = v.Value
                k = CInt(Right(ctl.Name, 1))
                If k > i Then i = k
            End If
        End If
    Next
    cboEbenen.text = i
    
    
    modForms.InitVariables
    
    
    With cboDokumenttyp
        .Clear
        If DocTyp = "" Then
          For i = 0 To UBound(DocTyps)
              .AddItem DocTyps(i)
          Next
          .text = DocTypDefault
          .Enabled = True
        Else
          .AddItem DocTyp
          .text = DocTyp
          .Enabled = False
        End If
    End With
    
    Dim aWerke As Variant
    If DocTyp = "BeckOF" Then
        'txtWerkkuerzel.Enabled = True
        'txtWerkkuerzel.Visible = True
        'txtWerkkuerzel.SetFocus
        'cboWerkkuerzel.Enabled = False
        'cboWerkkuerzel.Visible = False
        
        cboEbenen.Value = 0
        cboEbenen.Visible = False
        lblEbenen.Visible = False
        Label18.Visible = False
        lblDokumenttyp.Visible = False
        cboDokumenttyp.Visible = False
        'lblWerkkuerzel.Caption = "Projekt"
        lblFormularziffer.Caption = "Formularziffer*"
        lblFormularname2.Caption = "Formularziffer und |fffd|berschrift*"
        lblFormularzifferErl.Caption = Replace(lblFormularzifferErl.Caption, "Gliederungsziffer", "Formularziffer")
        cboEbenen_Change
        
        aWerke = Array("BeckOF Vertrag", "BeckOF Prozess", "BeckOF BauR", "BeckOF ErbR", "BeckOF MedR", "BeckOF VerkehrsR", "BeckOF ZivilR")
    Else
        aWerke = Array("BeckFormB AktR", "BeckFormB ArbR", "BeckFormB BHW", "BeckFormB ErbR", "BeckFormB FamR", "BeckFormB SportR", "BeckFormB Strafverteidiger", "BeckFormB Anwaltskanzlei", "BeckFormB Rechtsabteilung", "BeckFormB GmbHR", "BeckFormB ImmobilienR", "BeckFormB IT-R", "BeckFormB M&A", "BeckFormB MedR", "BeckFormB MietR", "BeckFormB VergabeR", "BeckFormB WEG-R", "BeckFormB ZivilR", "BeckFormB ZV", "MPFormB ArbR", "MPFormB ErbR", "MPFormB FamR", "MPFormB GewRS", "MPFormB MietR", "MPFormB BauR", "MPFormB VerwR", "BeckPFormB", "Koreng/Lachmann", "Martinek/Semmler/Flohr", "Oberth|fffd|r/Seitz", "MVHdB I", "MVHdB II", "MVHdB III", "MVHdB IV", "MVHdB V", "MVHdB VI")
    End If
    
    ' Werke auflisten
    SortArray aWerke
    With cboWerkkuerzel
        .Clear
        For i = 0 To UBound(aWerke)
            .AddItem aWerke(i)
            If aWerke(i) = werk Then
                .ListIndex = .ListCount - 1
            End If
        Next
    End With
    
    ' Rechtsgebiete f|fffd|llen
    Dim aRechtsgebiete As Variant, aRechtsgebietskuerzel As Variant
    aRechtsgebiete = Array("B|fffd|rgerliches Recht", "    Miet- und Wohn-, Leasing-, Pachtrecht", "    Privates Baurecht, Vergaberecht", "    Wohnungseigentumsrecht", "    Familienrecht", "    Erbrecht", "    Sonstiges B|fffd|rgerliches Recht", _
                            "Handels- und Wirtschaftsrecht", "    Handelsrecht", "    Gesellschaftsrecht", "    Wertpapier-, Bank-, B|fffd|rsen-, W|fffd|hrungsrecht", "    Verm|fffd|gensrecht der ehemaligen DDR", "    EDV-, Multimedia-, Medien- und Postrecht", "    Unlauterer Wettbewerb", "    Markenrecht", "    Kartellrecht, EG-Kartellrecht", "    Patentrecht, Gebrauchsmusterecht", "    Urheberrecht, Verlagsrecht", "    Privatversicherungsrecht", _
                            "Zivilverfahren, FGG, Berufsrecht", "    Gerichtsverfassung und Zivilverfahren", "    Insolvenzrecht", "    Grundbuchrecht, FGG", "    Berufsrecht der Rechtsanw|fffd|lte und Notare", _
                            "Arbeits- und Sozialrecht", "    Arbeitsrecht", "    Sozialrecht", _
                            "|fffd|ffentliches Recht", "    Staats- und Verfassungsrecht", "    Verwaltungsverfahren und -prozess", "    |fffd|ffentliches Baurecht", "    Lebensmittel- / Pharmarecht", "    Umweltrecht", "    Ausl|fffd|nder- und Asylrecht", "    Kommunalrecht", "    |fffd|ffentliches Wirtschaftsrecht", "    Medizinrecht", "    sonst. besonderes Verwaltungsrecht", _
                            "Strafrecht", "    Strafrecht", "    Strafprozessrecht/OWiG", "    Stra|fffd|enverkehrsrecht", _
                            "Steuerrecht/Bilanzrecht", "    Einkommensteuer", "    Lohnsteuer", "    K|fffd|rperschaftsteuer / Umwandlungsteuer", "    Gewerbesteuer / Grundsteuer", "    Umsatzsteuer, Z|fffd|lle", "    Erbschaft-/ Schenkungsteuer, Bewertung, Verm|fffd|gensteuer, Sonstige Verkehrsteuern", "    Internationales Steuerrecht", "    Verfahrensrecht (AO, FGO, Gemeinn|fffd|tzigkeitsrecht)", "    Berufs- und Haftungsrecht", "    Bilanzrecht (national und international)", "    F|fffd|rderungsgesetze (Investitionszulagengesetz, F|fffd|rdergebietsgesetz), sonstiges Steuerrecht ", "    Steuerrecht alt", _
                            "Recht mit Auslandsber|fffd|hrung", "    Internationales Zivilrecht", "    Europarecht, ausl. Recht, V|fffd|lkerrecht", _
                            "Recht allgemein", "    Recht allgemein")

    aRechtsgebietskuerzel = Array("ZivilR", "MietR", "PrBauR", "WEigR", "FamR", "ErbR", "BR", _
                                    "HaWiR", "HandelsR", "GesR", "BankR", "VermRDDR", "MedienR", "UW", "MarkR", "KartellR", "PatR", "UrhR", "PrivVersR", _
                                    "ZiBeR", "ZivVerfR", "InsR", "FGR", "BerufsR", _
                                    "ArbSozR", "ArbR", "SozR", _
                                    "OeR", "StaatsR", "AllgVerwR", "OeffBauR", "LMR", "UmweltR", "AuslR", "KommR ", "OeffWiR ", "MedizinR", "BesVerwR", _
                                    "StrafR", "StR", "StPR", "StVR", _
                                    "SteuR", "ESt", "LSt", "KStUmwSt", "GewStGrSt", "UStZoll", "ErbStBewG", "IntSteuerR", "AOFGO", "BerufHaftR", "BilanzR", "InvZulFG", "SteuerR", _
                                    "EuroR", "IPR", "IntR", _
                                    "Allgemein", "Allg")
    
    With lstRechtsgebiet
        .Clear
        For i = 0 To UBound(aRechtsgebiete)
            .AddItem aRechtsgebiete(i)
            .List(i, 1) = aRechtsgebietskuerzel(i)
        Next i
    End With

  If Not newdoc Then
    ' Infos suchen
    Dim p As Paragraph, sTitle As String, r As Range, f As Field, tmpBool As Boolean, anmLink As Boolean, titleErr As Boolean, thisLink As Boolean
    Set p = pForm '.Next
    sTitle = ""
    For i = 1 To 5
        ' Titel (inkl. Ziffer)
        If sTitle = "" And (IsHeadingPara(p) Or p.Style = "Container Titel") Then
            Set pTitle = p
            txtFormularname.Enabled = False
            txtFormularziffer.Enabled = False
            'boTypographie.Enabled = False
            ' Auf manuelle Formatierungen, Fu|fffd|noten, ... pr|fffd|fen
            If pTitle.Range.footnotes.Count = 0 And pTitle.Range.Comments.Count = 0 Then
                titleErr = False
                anmLink = False
                
                ' Titelabsatz pr|fffd|fen und Titel ermitteln
                sTitle = ""
                Set r = pTitle.Range.Duplicate
                r.Collapse
                r.MoveEnd
                Do While r.Move
                    If r.Characters.first.text = Chr(13) Then Exit Do
                    If r.start > pTitle.Range.End Then Exit Do
                    For Each f In pTitle.Range.Fields
                        If r.start = f.Code.start - 1 Then
                            ' Felder |fffd|berspringen - Anmerkungslinks sollen nicht auftauchen, und XE-Felder auch nicht
                            tmpBool = f.ShowCodes
                            f.ShowCodes = True
                            r.start = f.Code.End
                            r.Move ' weil + 1 nicht funktioniert
                            r.MoveEnd
                            f.ShowCodes = tmpBool
                            Exit For
                        End If
                        If RegexMatches("^hyperlink [^" & Chr(34) & "]*" & Chr(34) & "anmnr_", LCase(Trim(f.Code))) Then
                            anmLink = True
                        ElseIf Not (StartsWith(UCase(Trim(f.Code)), "XE ")) Then
                            titleErr = True
                            Exit For
                        End If
                    Next
                    thisLink = False
                    If anmLink Then
                        thisLink = RegexMatches("^[ " & Chr(160) & ",]+$", r.Characters.first.text)
                    End If
                    If Not FormattingCheck(pTitle, r, thisLink) Then
                        titleErr = True
                    End If
                    If r.Characters.first.text = Chr(13) Then Exit Do ' Kann durch Feld der Fall sein
                    If r.font.Superscript = False Or thisLink = False Then
                        sTitle = sTitle & r.Characters.first.text
                    End If
                    If titleErr Then Exit Do
                Loop
            Else
                titleErr = True
            End If
            
            If Not (anmLink Or titleErr) Then
                titleErr = Not FormattingCheck(pTitle, pTitle.Range)
            End If
            
           If Not titleErr Then
                ' Alles roger, Titel ermitteln
                If anmLink Then
                    ' Hinweis bzgl. Entfernung bezieht sich auf angezeigten, deaktivierten Titel
                    MsgBox "Aus technischen Gr|fffd|nden m|fffd|ssen Anmerkungsnummern aus der Formular|fffd|berschrift entfernt werden. " & _
                     "Bitte weisen Sie diese dem Formular an der aus Ihrer Sicht jeweils sinnvollen Position zu.", vbExclamation
                ElseIf AenderungsmodusAktiv Then
                    sTitle = Replace(pTitle.Range.text, Chr(13), "")
                    If pTitle.Range.Revisions.Count > 0 Then
                        geaendert = True
                    End If
                Else
                    txtFormularname.Enabled = True
                    txtFormularziffer.Enabled = True
                    sTitle = Replace(pTitle.Range.text, Chr(13), "")
                End If
                sTitle = RegexReplace("^(" & FormzifferRegex & "+)[ \xA0]+", sTitle, "$1" & vbTab)
                sTitle = RegexReplace("\s*\x0B\s*", sTitle, " ", True) ' Zeilenumbruch weg
                If InStr(sTitle, vbTab) < 1 Then
                    txtFormularziffer.text = ""
                    txtFormularname.text = sTitle
                Else
                    txtFormularziffer.text = Left(sTitle, InStr(sTitle, vbTab) - 1)
                    txtFormularname.text = Mid(sTitle, Len(txtFormularziffer.text) + 2)
                End If
            Else
                MsgBox "Die Dokumentziffer oder der Dokumentname wurden manuell nachbearbeitet und k|fffd|nnen daher nicht |fffd|ber diesen Dialog ge|fffd|ndert werden.", vbExclamation
            End If
        ElseIf p.Style = "Metadaten" Then
            ' Sonstige Meta
            Set pMeta = p
            Dim meta As String, metadata As Variant, m As Integer, ctlName As String, ctlValue As String, rgk As Integer
            meta = Trim(Replace(pMeta.Range.text, Chr(13), ""))
            meta = Replace(meta, MetaHinweis, "")
            metadata = Split(meta, MetaDelim)
            For m = LBound(metadata) To UBound(metadata)
                ' Metadatum auswerten
                meta = metadata(m)
                If meta Like "[A-Za-z]*=*" Then
                    ctlName = "txt" & Left(meta, InStr(meta, "=") - 1)
                    ctlValue = Mid(meta, InStr(meta, "=") + 1)
                    If ctlName = "txtRechtsgebiet" Then
                        ctlValue = "#" & ctlValue & "#"
                        For rgk = 0 To UBound(aRechtsgebietskuerzel)
                            lstRechtsgebiet.Selected(rgk) = InStr(ctlValue, "#" & aRechtsgebietskuerzel(rgk) & "#") > 0
                        Next
                    End If
                    For Each ctl In Me.Controls
                        If ctl.Name = ctlName Then
                            ctl.text = ctlValue
                        End If
                    Next
                End If
            Next
        Else
            Exit For
        End If
        
        ' N|fffd|chster
        Set p = p.Next
        If p Is Nothing Then
            Exit For
        End If
    Next
  End If ' if newdoc
    
    ' Textfelder ggf. eingrauen
    For Each ctl In Me.Controls
        If StartsWith(ctl.Name, "txt") Or StartsWith(ctl.Name, "cbo") Then
            ' Bei "lst" bewusst nicht weil das Selected aufhebt
            If ctl.Enabled Then
                ctl.BackColor = FormCtl_ColorNormal
            Else
                ctl.BackColor = &H80000016
            End If
        End If
    Next
    If txtNormen.text <> "" Then
        txtNormen_Change
    End If
    init = False
    checkPflichtfelder
    
    ActiveDocument.ShowRevisions = sr
End Sub

Private Function FormattingCheck(p As Paragraph, r As Range, Optional ignoreSuper As Boolean = False) As Boolean
    If r.font.Bold = p.Style.font.Bold And r.font.Italic = p.Style.font.Italic And _
     r.Style = p.Style And (r.font.Superscript = False Or ignoreSuper) And r.font.Subscript = False Then
        FormattingCheck = True
    Else
        FormattingCheck = False
    End If
End Function

Private Function NormkettePruefen() As String
    Dim sRetval As String, bMatch As Boolean, sRegexEinzeln As String, _
     sRegexZahl As String, sRegexNdash As String
    ' G|fffd|ltige Beispiele:
    ' BGB |fffd| 12, GG Art. 1-12
    ' SGB IV |fffd||fffd| 12 f.
    ' RAG 12 |fffd| 20, BGV 1990 Art. 20
    ' ff. ist nicht erlaubt da dann nicht klar wie weit das geht
    sRegexZahl = "([0-9]+[a-z]?)"
    sRegexNdash = "((|fffd||fffd||Art\.) " & sRegexZahl & "( f\.|(" & Chr(150) & sRegexZahl & ")))"
    sRegexEinzeln = "((|fffd||Art\.) " & sRegexZahl & ")"
    sRegexEinzeln = "(([A-Z][A-Za-z]+( ([IVX]{1,5}|[0-9]+))?) (" & sRegexEinzeln & "|" & sRegexNdash & "))"
    
    ' ndash einsetzen
    sRetval = LTrim(RegexReplace(sRegexZahl & "-([0-9])", LTrim(txtNormen.text), "$1" & Chr(150) & "$2", True))
    
    ' Pr|fffd|fen
    If InStr(sRetval, ",") < 1 Then
        bMatch = RegexMatches("^" & sRegexEinzeln & "\s*$", sRetval)
    Else
        bMatch = RegexMatches("^(" & sRegexEinzeln & ", )+" & sRegexEinzeln & "\s*$", sRetval)
    End If
    
    ' Endg|fffd|ltige Pr|fffd|fung und R|fffd|ckgabe
    If bMatch Then
        ' Erfolgreich
        NormkettePruefen = sRetval
    Else
        ' Ung|fffd|ltige Eingabe
        NormkettePruefen = ""
    End If
End Function


Sub checkPflichtfelder()

    If init Then Exit Sub
    
    btnSave.Enabled = False
    Dim i As Integer, ctl As control, tmp As String, ctlName As String, ctlLabel As String, required As Boolean
    For i = 1 To CInt(cboEbenen.text)
        If Controls("txtHigherH" & i).text = "" Then Exit Sub
    Next i
    
    For Each ctl In Me.Controls
        If StartsWith(ctl.Name, "txt") Or StartsWith(ctl.Name, "cbo") Or StartsWith(ctl.Name, "lst") Then
            ' Eingaben pr|fffd|fen
            If Not ctl.Enabled Then GoTo skip
            tmp = Trim(ctl.text)
            ctlName = Mid(ctl.Name, 4)
            ctlLabel = Trim(Me.Controls("lbl" & ctlName).Caption)
            required = False
            If Right(ctlLabel, 1) = "*" Then
                ctlLabel = Left(ctlLabel, Len(ctlLabel) - 1)
                required = True
            End If
            If ctl.Name = "lstRechtsgebiet" Then
                For i = 0 To lstRechtsgebiet.ListCount - 1
                    If lstRechtsgebiet.Selected(i) Then
                        tmp = "*"
                        Exit For
                    End If
                Next
            End If
            If tmp = "" And required Then
                Exit Sub
            End If
        End If
skip:
    Next
    
    btnSave.Enabled = True

End Sub

Private Sub UserForm_Terminate()
    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
End Sub
Attribute VB_Name = "frmInsertTable"
Attribute VB_Base = "0{D75AF324-E185-4602-9FB5-655B848D46D8}{6C2DBFB8-01F3-4DB6-962D-A2CBCF284B2A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub btnOK_Click()
    Dim lCols As Long, lRows As Long, lHeads As Long
    lCols = SpinControl_CheckVal(Me, "Cols")
    If lCols < 0 Then
        Exit Sub
    End If
    lRows = SpinControl_CheckVal(Me, "Rows")
    If lRows < 0 Then
        Exit Sub
    End If
    lHeads = SpinControl_CheckVal(Me, "Heads")
    If lHeads < 0 Then
        Exit Sub
    End If
    If lHeads > lRows Then
        MsgBox "Die Anzahl der Kopfzeilen kann nicht gr|fffd||fffd|er sein als die Anzahl der Zeilen.", vbExclamation
        Exit Sub
    End If
    SetSelectionToParaEnd
    Dim tbl As Table
    Set tbl = Selection.Tables.Add(Selection.Range, lRows, lCols)
    tbl.Range.Paragraphs.Style = "Absatz"
    If lHeads > 0 Then
    Dim r As Long
        For r = 1 To lHeads
            tbl.Rows(r).HeadingFormat = True
        Next
    End If

      With tbl.Borders
        If chkLinien.Value Then
            .InsideLineStyle = wdLineStyleSingle
            .OutsideLineStyle = wdLineStyleSingle
        Else
            .InsideLineStyle = wdLineStyleNone
            .OutsideLineStyle = wdLineStyleNone
        End If
    End With
    
    
    tbl.Cell(1, 1).Select
    Selection.Collapse
    Unload Me
End Sub


Private Sub UserForm_Activate()
    sbCols_Change
    sbHeads_Change
    sbRows_Change
    btnOK.SetFocus
End Sub

Private Sub btnCancel_Click()
    Unload Me
End Sub

Private Sub sbCols_Change()
    SpinControl_HandleSpin Me, "Cols"
End Sub

Private Sub sbHeads_Change()
    SpinControl_HandleSpin Me, "Heads"
End Sub

Private Sub sbRows_Change()
    SpinControl_HandleSpin Me, "Rows"
End Sub

Private Sub txtCols_Change()
    SpinControl_HandleTextboxChange Me, "Cols"
End Sub

Private Sub txtHeads_Change()
    SpinControl_HandleTextboxChange Me, "Heads"
End Sub

Private Sub txtRows_Change()
    SpinControl_HandleTextboxChange Me, "Rows"
End Sub

Private Sub txtHeads_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    KeyCode = SpinControl_HandleTextboxKey(Me, "Heads", KeyCode, Shift)
End Sub

Private Sub txtCols_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    KeyCode = SpinControl_HandleTextboxKey(Me, "Cols", KeyCode, Shift)
End Sub

Private Sub txtRows_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    KeyCode = SpinControl_HandleTextboxKey(Me, "Rows", KeyCode, Shift)
End Sub
Public Sub SpinControl_HandleSpin(frm As Object, sName As String)
    Dim sb As SpinButton, txt As TextBox
    Set sb = frm.Controls("sb" & sName)
    Set txt = frm.Controls("txt" & sName)
    txt.text = sb.Value
End Sub

Public Sub SpinControl_HandleTextboxChange(frm As Object, sName As String)
    Dim sb As SpinButton, txt As TextBox
    Set sb = frm.Controls("sb" & sName)
    Set txt = frm.Controls("txt" & sName)
    If IsNumeric(txt.text) Then
        Dim lVal As Long
        lVal = CLng(txt.text)
        If lVal < sb.Min Then
            sb.Value = sb.Min
        ElseIf lVal > sb.max Then
            sb.Value = sb.max
        Else
            sb.Value = lVal
        End If
        txt.text = CStr(sb.Value)
    End If
End Sub

Public Function SpinControl_HandleTextboxKey(frm As Object, sName As String, KeyCode As MSForms.ReturnInteger, Shift As Integer)
    Dim sb As SpinButton, txt As TextBox
    Set sb = frm.Controls("sb" & sName)
    Set txt = frm.Controls("txt" & sName)
    If KeyCode = 38 Then
        If sb.Value < sb.max Then
            sb.Value = sb.Value + 1
        End If
        KeyCode = 0
    ElseIf KeyCode = 40 Then
        If sb.Value > sb.Min Then
            sb.Value = sb.Value - 1
        End If
        KeyCode = 0
    ElseIf KeyCode >= 48 And KeyCode <= 57 Then
        ' Zahl => Okay
    ElseIf KeyCode >= 96 And KeyCode <= 105 Then
        ' Zahl auf Numpad => Okay
    ElseIf KeyCode <> 37 And KeyCode <> 39 And KeyCode <> 46 And KeyCode <> 8 And _
      KeyCode <> 9 And KeyCode <> 35 And KeyCode <> 36 And KeyCode <> 27 And _
      KeyCode <> 13 Then
        ' Keine Zahl, Pfeiltaste, Entfernen oder so => Nicht okay
        KeyCode = 0
    End If
    txt.SetFocus
    SpinControl_HandleTextboxKey = KeyCode
End Function
Public Function SpinControl_CheckVal(frm As Object, sName As String) As Long
    Dim txt As TextBox, sb As SpinButton
    Set txt = frm.Controls("txt" & sName)
    Set sb = frm.Controls("sb" & sName)
    If Not IsNumeric(txt.text) Then
        MsgBox "Dies ist keine g|fffd|ltige Zahl.", vbExclamation
        txt.SetFocus
        SpinControl_CheckVal = -1
        Exit Function
    Else
        Dim lVal As Long
        lVal = CLng(txt.text)
        If lVal > sb.max Or lVal < sb.Min Then
            MsgBox "Die Zahl muss zwischen " & CStr(sb.Min) & " und " & CStr(sb.max) & " liegen.", vbExclamation
            txt.SetFocus
            SpinControl_CheckVal = -1
            Exit Function
        Else
            SpinControl_CheckVal = lVal
        End If
    End If
End Function
Attribute VB_Name = "frmLinktagging"
Attribute VB_Base = "0{54861A0D-FAC1-4041-98DE-6CF068DA3844}{94A7C692-1FF6-4A13-930C-E0D06B4FA68D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Private found As Boolean, footnotes As Boolean, anhang As Collection, mode As Integer, first As Boolean
Private colMainSearches As Collection

Private Sub CommandButton9_Click()
    UnloadThis
End Sub

Sub UnloadThis()
    Unload frmFormLink
    Unload Me
End Sub

Private Sub UserForm_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  If KeyCode = vbKeyRight And Shift Then
    CommandButton4_Click
  ElseIf KeyCode = vbKeyLeft And Shift Then
    CommandButton1_Click
  ElseIf KeyCode = vbKeyRight Then
    CommandButton2_Click
  ElseIf KeyCode = vbKeyLeft Then
    CommandButton3_Click
  End If
End Sub

Private Sub CommandButton1_Click()
    Selection.start = Selection.start - 1
    If Asc(Selection.Characters.first) = 13 Then Selection.start = Selection.start + 1
    Me.CommandButton5.Enabled = True
    If Selection.End - Selection.start = 0 Then Me.CommandButton5.Enabled = False
End Sub

Private Sub CommandButton2_Click()
    Selection.start = Selection.start + 1
    Me.CommandButton5.Enabled = True
    If Selection.End - Selection.start = 0 Then Me.CommandButton5.Enabled = False
End Sub

Private Sub CommandButton3_Click()
    Selection.End = Selection.End - 1
    Me.CommandButton5.Enabled = True
    If Selection.End - Selection.start = 0 Then Me.CommandButton5.Enabled = False
End Sub

Private Sub CommandButton4_Click()
    Selection.End = Selection.End + 1
    If Asc(Selection.Characters.Last) = 13 Then Selection.End = Selection.End - 1
    Me.CommandButton5.Enabled = True
    If Selection.End - Selection.start = 0 Then Me.CommandButton5.Enabled = False
End Sub

Private Sub CommandButton1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub
Private Sub CommandButton2_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub
Private Sub CommandButton3_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub
Private Sub CommandButton4_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub

Private Sub CommandButton5_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub

Private Sub CommandButton8_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub

Private Sub CommandButton9_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    UserForm_KeyDown KeyCode, Shift
End Sub

Private Sub Frame1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
UserForm_KeyDown KeyCode, Shift
End Sub

Private Sub CommandButton5_Click()
    'frmFormLink.ApplyLinkStyle
    Dim ok As Boolean
    ok = frmFormLink.EingabePruefen(Selection.text) <> ""
    frmFormLink.LinkEintragen Trim(Selection.text)
    Selection.MoveRight
    
    If Not ok Then
        MsgBox "Bitte den Link doppelklicken und G|fffd|ltigkeit pr|fffd|fen, danach Linktagging erneut starten.", vbExclamation
        UnloadThis
    Else
        findNext
    End If
End Sub

Private Sub CommandButton8_Click()
    Selection.MoveRight
    findNext
End Sub

Private Sub UserForm_Initialize()
  found = False
  footnotes = False
  mode = -1
  Set colMainSearches = New Collection
  initNext
  findNext
End Sub

Sub findNext()
Dim l As Integer, r As Range
  Do While True
'    Debug.Print mode & " " & footnotes & " " & Selection.Find.text
    If Not Selection.Find.Execute Then
        If Not initNext Then Exit Sub
    ElseIf Selection.Style <> ActiveDocument.styles("Formularverweis") And Selection.Style <> ActiveDocument.styles("Anmerkungsverweis") And _
     Selection.Style <> ActiveDocument.styles("Abschnittsverweis") And Selection.Paragraphs.Style <> "Formulartext Anfang" And _
     Selection.Paragraphs.Style <> "Formulartext Ende" Then
        found = True
        l = Selection.End - Selection.start
        
        If mode = 0 Or mode = 1 Then
            checkNormal
        ElseIf mode = 2 Then
            checkVorb
        Else
            Stop
        End If
        
        If (l <> Selection.End - Selection.start) Then
            GoTo ende:
        End If
    End If
  Loop

ende:

End Sub

Function initNext() As Boolean
    initNext = True
    
    If mode < 0 Or colMainSearches.Count > 0 Then
        If mode = -1 Then
            Set colMainSearches = New Collection
            colMainSearches.Add "Form."
            colMainSearches.Add "Formular"
        End If
        initMain colMainSearches.item(1)
        colMainSearches.Remove 1
    ElseIf mode = 0 Then
        initAnm
    ElseIf mode = 1 Then
        initVorb
    ElseIf footnotes = False And ActiveDocument.footnotes.Count > 0 Then
        footnotes = True
        mode = -1
    Else
        ActiveDocument.Characters.first.Select
        Selection.Collapse
        If found Then
            MsgBox "Keine weiteren Fundstellen.", vbInformation
        Else
            MsgBox "Keine Textstellen gefunden.", vbInformation
        End If
        UnloadThis
        initNext = False
    End If
    
End Function

Sub initMain(txt As String)
  mode = 0
  initSearch "<" & txt
End Sub

Sub initAnm()
  mode = 1
  initSearch "<Anm."
End Sub

Sub initVorb()
  mode = 2
  initSearch "<Vorb."
End Sub

Sub initSearch(s As String)
  If footnotes Then
    ActiveDocument.footnotes(1).Range.Characters.first.Select
  Else
    ActiveDocument.Characters.first.Select
  End If
  Selection.Collapse
  
  With Selection.Find
    .ClearFormatting
    .text = s
    .Replacement.ClearFormatting
    .Replacement.text = ""
    .Forward = True
    .Wrap = wdFindStop
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchAllWordForms = False
    .MatchSoundsLike = False
    .MatchWildcards = True
  End With
  
End Sub

Sub checkNormal()
    Dim success As Range, test As Range, found As Boolean, checkText As String
    If Selection.MoveEnd = 0 Then Exit Sub
    If Selection.Characters.Last.text <> Chr(160) And Selection.Characters.Last.text <> " " Then
        Selection.MoveEnd , -1
        Exit Sub
    End If
    Set success = Selection.Range.Duplicate
    Set test = success.Duplicate
    Do While test.MoveEnd
        If test.Characters.Last.text = Chr(7) Or test.Characters.Last.text = Chr(13) Then
            Exit Do
        End If
        checkText = test.text
        checkText = Replace(checkText, "Formular", "Form.")
        checkText = Replace(checkText, "Anmerkungen", "Anm.")
        checkText = Replace(checkText, "Anmerkung", "Anm.")
        If frmFormLink.EingabePruefen(checkText) <> "" Then
            Set success = test.Duplicate
            found = True
        End If
    Loop
    success.MoveEndWhile " ", -1
    success.Select
End Sub

Sub checkVorb()
    Dim success As Range, test As Range, found As Boolean
    If Selection.MoveStart(, -1) = 0 Then Exit Sub
    If Selection.Characters.first.text <> Chr(160) And Selection.Characters.first.text <> " " Then
        Selection.MoveEnd , -1
        Exit Sub
    End If
    Set success = Selection.Range.Duplicate
    Set test = success.Duplicate
    Do While test.MoveStart(, -1)
        If test.Characters.first.text = Chr(7) Or test.Characters.first.text = Chr(13) Then
            Exit Do
        End If
        If frmFormLink.EingabePruefen(test.text) <> "" Then
            Set success = test.Duplicate
            found = True
        End If
    Loop
    success.MoveStartWhile " "
    success.Select
End Sub
Attribute VB_Name = "frmPassword"
Attribute VB_Base = "0{06F02352-CEC3-4D10-BE2C-2C35F62C26FB}{0B5A1C96-74AA-4AB1-8E93-9FB7660F9C24}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Const pw As String = "form4beck"

Private Sub cmdOk_Click()
    Dim strIn As String
    strIn = txtPassword.text
    If strIn = pw Then
        globVerlag = True
    Else
        MsgBox "Passwort falsch", vbCritical
    End If
    txtPassword.text = ""
    Me.Hide
End Sub

Private Sub cmdCancel_Click()
    Me.Hide
End Sub

Private Sub txtPassword_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = wdKeyReturn Then
        cmdOk_Click
    End If
End Sub

Attribute VB_Name = "frmStichwort"
Attribute VB_Base = "0{80B436F0-B5D0-4ED8-992F-1AD1FA734B0B}{3BC9607E-33DB-48F5-BC28-9B40ED663940}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public Sub init()
    cboHSW.Clear
    Dim colItems As New Collection, f As Field, strHSW As String
    For Each f In ActiveDocument.Fields
        If f.Type = wdFieldIndexEntry Then
            strHSW = Mid(f.Code, Len(" XE " & Chr(34)) + 1)
            strHSW = Left(strHSW, InStr(strHSW, Chr(34)) - 1)
            If InStr(strHSW, ":") Then
                strHSW = Left(strHSW, InStr(strHSW, ":") - 1)
            End If
            On Error Resume Next
            If Not colItems(strHSW) Then
                colItems.Add strHSW, strHSW
            End If
            On Error GoTo 0
        End If
    Next
    Dim lListItems As Variant, i As Integer
    lListItems = SortCollection(colItems)
    For i = 0 To UBound(lListItems)
        Dim strItem As String
        strItem = lListItems(i)
        cboHSW.AddItem strItem
    Next
    cboHSW_Change
    txtUSW_Change
End Sub

Private Sub btnCancel_Click()
    Unload Me
End Sub

Private Sub btnOK_Click()
    If Trim(cboHSW.text) = "" Then
        MsgBox "Bitte geben Sie ein Hauptstichwort an.", vbExclamation
        cboHSW.SetFocus
        Exit Sub
    End If
    If Not validate("cboHSW") Then
        Exit Sub
    End If
    If Not validate("txtUSW") Then
        Exit Sub
    End If
    If Trim(Me.txtUSW) = "" Or chkHSW.Value Then
        Dim siehe As String
        siehe = ""
        If Trim(Me.txtUSW) = "" Then
            siehe = txtSiehe.text
        End If
        ActiveDocument.Indexes.MarkEntry Range:=Selection.Range, Entry:= _
            Me.cboHSW.text, EntryAutoText:=Me.cboHSW.text, _
            CrossReference:=siehe, CrossReferenceAutoText:="", BookmarkName:="", Bold:=False, Italic:=False
    End If
    If Trim(Me.txtUSW) <> "" Then
        ActiveDocument.Indexes.MarkEntry Range:=Selection.Range, Entry:= _
            Me.cboHSW.text & ":" & Me.txtUSW, EntryAutoText:=Me.cboHSW.text, _
            CrossReference:=txtSiehe.text, CrossReferenceAutoText:="", BookmarkName:="", Bold:=False, Italic:=False
    End If
    Unload Me
End Sub

Private Function validate(sName As String) As Boolean
    Dim txt As control
    Set txt = Me.Controls(sName)
    If InStr(txt.text, ":") > 0 Or InStr(txt.text, Chr(34)) Then
        MsgBox "Doppelpunkte oder Anf|fffd|hrungszeichen sind hier nicht erlaubt.", vbExclamation
        txt.SetFocus
        validate = False
        Exit Function
    End If
    validate = True
End Function

Public Sub cboHSW_Change()
    If Trim(cboHSW.text) = "" Then
        imgIndicator.BackColor = Me.BackColor
    ElseIf cboHSW.MatchFound = True Then
        imgIndicator.BackColor = RGB(50, 205, 50)
    Else
        imgIndicator.BackColor = vbRed
    End If
End Sub

Private Sub txtUSW_Change()
    chkHSW.Enabled = Trim(txtUSW.text) <> ""
End Sub

Attribute VB_Name = "frmUeberarbeitungsInfo"
Attribute VB_Base = "0{7AB117C1-6A90-4D98-A61E-934F489DD79B}{0CF1CF6E-5D0D-4542-98A5-A1985A5152CB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit



Private Sub btOK_Click()
Unload Me
End Sub

Private Sub btReset_Click()
    Dim v As Variable
    Dim p As Paragraph
    Dim r As Revision
     
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Meta_Geandert" Or v.Name = "Beck_Original_Dateiname" Then
            v.Delete
        End If
    Next
    
    ActiveDocument.Variables.Add "Beck_Meta_Geandert", "nein"
    If InStr(1, ActiveDocument.FullName, "\") Then
        ActiveDocument.Variables.Add "Beck_Original_Dateiname", ActiveDocument.Name
    Else
        ActiveDocument.Variables.Add "Beck_Original_Dateiname", "-1"
    End If
        
        
    For Each p In ActiveDocument.Paragraphs
        If p.Style = ActiveDocument.styles(wdStyleHeading1) Then
            If p.Range.Revisions.Count > 0 Then
                For Each r In p.Range.Revisions
                    r.Accept
                Next r
            End If
        Exit For
        End If
    Next p
        
    UserForm_Initialize
End Sub

Private Sub UserForm_Initialize()
    Dim metainfo As String
    Dim fn As String
    Dim v As Variable
    Dim p As Paragraph
    
    
    
    metainfo = "unbekannt"
    fn = "unbekannt"
    
    
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Meta_Geandert" Then
            metainfo = v.Value
        ElseIf v.Name = "Beck_Original_Dateiname" Then
            fn = v.Value
        End If
    Next


    For Each p In ActiveDocument.Paragraphs
        If p.Style = ActiveDocument.styles(wdStyleHeading1) Then
            If p.Range.Revisions.Count > 0 Then
                metainfo = "ja"
            End If
        Exit For
        End If
    Next p
    

    lblInfo.Caption = "Metadaten ge|fffd|ndert: " & vbTab & metainfo & vbCrLf & vbCrLf
    
    If fn = ActiveDocument.Name Or fn = "-1" Then
        lblInfo.Caption = lblInfo.Caption & "Dateiname ge|fffd|ndert: " & vbTab & "nein" & vbCrLf
    ElseIf fn = "unbekannt" Then
        lblInfo.Caption = lblInfo.Caption & "Dateiname ge|fffd|ndert: " & vbTab & "unbekannt"
    Else
        lblInfo.Caption = lblInfo.Caption & "Dateiname ge|fffd|ndert: " & vbTab & "ja" & vbCrLf & _
        "Original-Dateiname: " & vbTab & fn
    End If
                      


End Sub
Attribute VB_Name = "modCE"
Option Explicit

' Makros die beim Copy-Editing helfen

' Listenmakros deaktiviert wegen vorgezogenem CE - nun immer die Funktionen der Vorlage nutzen

'Sub PI_ListAlwaysRestart()
'    ProcessingInstruction "ListAlwaysRestart"
'End Sub
'
'Sub PI_ListContinue()
'    ProcessingInstruction "ListContinue"
'End Sub
'
'Private Sub ProcessingInstruction(Name As String)
'    Dim smc As Boolean
'    smc = Options.SmartCutPaste
'    Options.SmartCutPaste = False
'    On Error GoTo fehler
'
'    Selection.Collapse
'    Selection.Style = "Processing-Instruction"
'    Selection.TypeText Name
'    Selection.Collapse wdCollapseEnd
'    EnsureResetStyle
'
'fertig:
'    Options.SmartCutPaste = smc
'    Exit Sub
'fehler:
'    MsgBox "Es ist ein Fehler aufgetreten: " & err.Description, vbCritical
'    GoTo fertig
'End Sub

' =======================

Private AlleDateienBearbeitenZaehler As Integer

Sub AlleDateienBearbeiten()
    On Error GoTo fertig
    Dim workdir As String, startdir As String
    'workdir = CurDir
    startdir = InputBox("Bitte die Sub FileSub() anpassen und hier den Ordner angeben. Es werden auch Unterordner durchlaufen!")
    AlleDateienBearbeitenZaehler = 0
    FindSub startdir, "*.doc"
fertig:
    'ChDir workdir
    MsgBox "Fertig, " & AlleDateienBearbeitenZaehler & " Dateien.", vbInformation
    If err.number <> 0 Then
        On Error GoTo 0
        err.Raise err.number, , err.Description
    End If
    On Error GoTo 0
End Sub

Private Sub FindSub(start As String, FindWhat As String)
    Dim FindDir() As String
    Dim Find As String
    Dim i As Integer
    
    If Right(start, 1) <> "\" Then start = start & "\"
    
    dirSub start, FindWhat
    
    Find = dir(start & "*.*", vbDirectory)
    i = 0
    Do Until Find = ""
        ReDim Preserve FindDir(i)
        If Find <> "." And Find <> ".." Then
            FindDir(i) = start & Find
            i = i + 1
        End If
        Find = dir()
    Loop
    For i = 0 To UBound(FindDir)
        If dir(FindDir(i), vbNormal) = "" Then
            FindSub FindDir(i), FindWhat
        End If
    Next
End Sub

Private Sub dirSub(Folder As String, FindWhat As String)
    Dim Findfile As String
    Findfile = dir(Folder & FindWhat, vbNormal)
    
    Do While Findfile <> ""
        FileSub Folder & Findfile
        Findfile = dir()
    Loop
End Sub

Private Sub FileSub(file As String)
    On Error GoTo fertig
    
    ' |fffd|ffnen
    AlleDateienBearbeitenZaehler = AlleDateienBearbeitenZaehler + 1
    Dim Doc As Document
    Set Doc = Application.Documents.Open(file)
    
    ' *** Hier der Code der bei jeder Datei ausgef|fffd|hrt wird ***
    On Error Resume Next
    Doc.styles("Anmerkungsverweis").font.ColorIndex = wdBlue
    Doc.styles("Abschnittsverweis").font.ColorIndex = wdBlue
    Doc.styles("Formularverweis").font.ColorIndex = wdBlue
    Doc.UpdateStylesOnOpen = False
    On Error GoTo 0
    ' *** Ende ***
    
    Doc.Close wdSaveChanges
fertig:
    If err.number <> 0 Then
        On Error GoTo 0
        err.Raise err.number, , err.Description
    End If
    On Error GoTo 0
End Sub

' Makros u.a. f|fffd|r vorgelagertes CE

Sub Linktagging()
    On Error Resume Next
    frmLinktagging.Show 1
End Sub

Sub Autorenweise_Unterordner()
    ' Benutzer nach Ordner fragen
    Dim kuerzel As String, ordner As String, datei As String, dateien As Long, tmp As String, aktiv As String, _
     Doc As Document, p As Paragraph, autor As String, pos As Long, endung As String, istAktiv As Boolean, neuname As String
    
    Dim v As Variable
    
    ordner = InputBox("Bitte den Ordner angeben, in dem sich die .doc-Dateien befinden. In diesem Ordner werden pro Autor Unterordner erstellt " & _
     "und die jeweiligen Worddateien dorthin abgespeichert.", "Autorenweise Unterordner", _
     IIf(ActiveDocument.Type = wdTypeDocument And InStr(ActiveDocument.FullName, "\"), ActiveDocument.Path, ""))
    If Trim(ordner) = "" Then Exit Sub
    If Right(ordner, 1) <> "\" Then
        ordner = ordner & "\"
    End If
    tmp = dir(ordner & "\*", vbHidden Or vbDirectory)
    Do While tmp = "." Or tmp = ".."
        tmp = dir
    Loop
    If tmp <> "" Then
        If MsgBox(ordner & " enth|fffd|lt bereits Unterordner. Ggf. vorhandene Dateien werden ohne Nachfrage |fffd|berschrieben.", vbOKCancel Or vbExclamation) <> vbOK Then Exit Sub
    End If
    
    ' Dateien verarbeiten
    aktiv = ActiveDocument.FullName
    dateien = 0
    Do While True
        If datei <> "" Then
            datei = dir
        Else
            datei = dir(ordner & "*.docx")
        End If
        If datei = "" Then
            Exit Do
        End If
        endung = LCase(Right(datei, 5))
        If endung <> ".docx" Then
            GoTo goNext
        End If
        Set Doc = Application.Documents.Open(ordner & datei)
        istAktiv = (aktiv = Doc.FullName)
        
        ' Metadaten holen
        autor = "Unbekannt"
        For Each p In Doc.Paragraphs
            If p.Style = "Metadaten" Then
                tmp = Replace(p.Range.text, Chr(13), "")
                pos = InStr(tmp, MetaDelim & "Autor=")
                If pos > 0 Then
                    tmp = Mid(tmp, pos + Len(MetaDelim & "Autor=")) & MetaDelim
                    tmp = Trim(Left(tmp, InStr(tmp, MetaDelim) - 1))
                    If InStr(tmp, " ") Then
                        tmp = Mid(tmp, InStrRev(tmp, " ") + 1)
                    End If
                    tmp = RegexReplace("[.\\/:?*" & Chr(34) & "<>\|]+", Trim(tmp), "", True)
                    If Trim(tmp) <> "" Then
                        autor = tmp
                    End If
                End If
            End If
        Next
        tmp = Left(Doc.Name, Len(Doc.Name) - Len(endung))
        If Len(tmp) > Len(autor) Then
            If LCase(Right(tmp, Len(autor) + 1)) <> LCase("_" & autor) Then
                tmp = tmp & "_" & autor
            End If
        Else
            tmp = tmp & "_" & autor
        End If
        
        
'
'        doc.Range.Find.ClearFormatting
'        doc.Range.Find.Replacement.ClearFormatting
'        With doc.Range.Find
'        .text = "$#$Autor="
'        .Replacement.text = "$#$Rechtsgebiet=MietR#$Autor="
'        .Forward = True
'        .Wrap = wdFindContinue
'        .Format = False
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'        End With
'        doc.Range.Find.Execute Replace:=wdReplaceAll
        
        
        
        ' Speichern
        On Error Resume Next ' Dir hier nicht verwendbar (ist oben schon)
        MkDir ordner & autor
        neuname = ordner & autor & "\" & tmp & endung
savefile:
        err.number = 0
        
        For Each v In ActiveDocument.Variables
            If v.Name = "Beck_Original_Dateiname" Or v.Name = "Beck_Meta_Geandert" Then
                v.Delete
            End If
        Next
        
        ActiveDocument.Variables.Add "Beck_Original_Dateiname", tmp & endung
        ActiveDocument.Variables.Add "Beck_Meta_Geandert", "nein"
        
        Doc.SaveAs neuname
        If err.number <> 0 Then
                ' Zuf|fffd|lliger(?) Fehler der i.d.R. beim Wiederholen (nach kurzer Pause?) nicht mehr auftritt
            If MsgBox("Speichern von " & neuname & " fehlgeschlagen.", vbRetryCancel Or vbExclamation) = vbRetry Then
                GoTo savefile
            End If
            On Error GoTo 0
            Exit Sub
        End If
        On Error GoTo 0
        dateien = dateien + 1
        If Not istAktiv Then
            Doc.Close wdDoNotSaveChanges
        End If
goNext:
    Loop
    
    MsgBox "Es wurden " & dateien & " Datei(en) verarbeitet und in Unterordner gespeichert.", vbInformation
End Sub

Sub Werkkuerzel_Setzen_Ordner()
    ' Benutzer nach Ordner fragen und Werkk|fffd|rzel fragen
    Dim kuerzel As String, ordner As String, datei As String, dateien As Long, aktiv As String, Doc As Document, v As Variable
    ordner = InputBox("Bitte den Ordner angeben, in dem das Werkk|fffd|rzel f|fffd|r alle .doc-Dateien gesetzt werden soll.", "Werkk|fffd|rzel setzen", _
     IIf(ActiveDocument.Type = wdTypeDocument And InStr(ActiveDocument.FullName, "\"), ActiveDocument.Path, ""))
    If Trim(ordner) = "" Then Exit Sub
    If Right(ordner, 1) <> "\" Then
        ordner = ordner & "\"
    End If
    
    kuerzel = ""
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_Werkkuerzel" Then
            kuerzel = v.Value
        End If
    Next
    kuerzel = Trim(InputBox("Bitte das zu setzende Werkk|fffd|rzel inklusive Auflage eingeben (z.B. BeckFormB GmbH 2A):", "Werkk|fffd|rzel setzen", kuerzel))
    If kuerzel = "" Then Exit Sub
    
    ' Dateien bearbeiten
    aktiv = ActiveDocument.FullName
    dateien = 0
    Do While True
        If datei <> "" Then
            datei = dir
        Else
            datei = dir(ordner & "*.docx")
        End If
        If datei = "" Then
            Exit Do
        End If
        If LCase(Right(datei, 5)) <> ".docx" Then
            GoTo goNext
        End If
        Set Doc = Application.Documents.Open(ordner & datei)
        dateien = dateien + 1
        For Each v In Doc.Variables
            If v.Name = "Beck_Form_Werkkuerzel" Then
                v.Delete
            End If
        Next
        Doc.Variables.Add "Beck_Form_Werkkuerzel", kuerzel
'        doc.Activate
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        If aktiv <> Doc.FullName Then
            Doc.Close wdSaveChanges
        End If
goNext:
    Loop
    
    MsgBox "Das Werkk|fffd|rzel wurde bei " & dateien & " Datei(en) gesetzt.", vbInformation
End Sub

Private Function CheckCEOptions() As Boolean
    Dim smc As Boolean
    smc = Options.SmartCutPaste
    If smc Then
        MsgBox "Abbruch - SmartCutPaste ist an!", vbCritical
        CheckCEOptions = False
        Exit Function
    End If
    CheckCEOptions = True
End Function

Sub AnmFormatWandeln()
    ' Makro das Anm. Zeichenformate in Anm. laut Dot verwandelt (f|fffd|r vorgezones CE)
    If Not CheckCEOptions() Then Exit Sub
    ActiveDocument.Paragraphs.first.Range.Select
    Selection.Collapse
    With Selection.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Replacement.text = ""
        .Format = True
        .Forward = True
        .Wrap = wdFindStop
        .text = ""
    End With
    
    ' Anmerkungsnummern umwandeln
    Dim p As Paragraph, sel As Range, selEnd As Range, success As Boolean, tmp As String, failed As Boolean, r As Range
    failed = False
    With Selection.Find
        .Style = "Anmerkungsnummer"
        Do While .Execute(Replace:=wdReplaceNone)
            Set p = Selection.Paragraphs.first
            Set sel = Selection.Range.Duplicate
            Set selEnd = sel.Duplicate
            selEnd.Collapse wdCollapseEnd
            
            success = False
            If IsAnmNumField(Selection.Range) Then GoTo skip
            AnmerkungEinfuegen
            'sel.Select
            p.Range.Select
            Selection.Collapse
            'Selection.MoveEnd
            tmp = ""
            Do While Selection.End < p.Range.End And ( _
             IsAnmNumField(Selection.Range) Or (Selection.Style = p.Style And Selection.Characters.Last = " ") Or _
             Selection.Style = "Anmerkungsnummer") And Selection.End < sel.End
                If IsAnmNumField(Selection.Characters.first) And tmp = "" Then
                    tmp = Replace(Trim(Selection.Characters.first.Fields(1).Code.text), "MACROBUTTON AnmerkungsnummerInfo ", "")
                    Selection.start = Selection.Characters.first.Fields(1).Code.End
                    Selection.MoveStart
                End If
                Selection.MoveEnd
            Loop
            If RegexMatches("^\. [0-9]+\.[ ]?$", Selection.text) And IsAnmNumField(p.Range.Characters.first) Then
                If Selection.Characters.Last <> " " Then Selection.MoveEnd
                If Selection.Fields.Count = 0 And Selection.text = ". " & tmp & ". " Then
                    success = True
                    Selection.MoveStart , 2
                    Selection.Delete
                Else
                    'Stop
                End If
            Else
                'Stop
            End If
skip:
            selEnd.Select
            If Not success Then failed = True
        Loop
    End With
    If failed Then
        MsgBox "Bitte pr|fffd|fen - es blieben eventuell falsche Anmerkungsnummern |fffd|ber. Anmerkungslinks umwandeln erst starten wenn alle Anmerkungsnummern korrekt.", vbExclamation
    Else
        MsgBox "Fertig.", vbInformation
    End If
End Sub

Sub AnmLinksWandeln()
    ' Makro das Anm. Links Zeichenformate in Anm. laut Dot verwandelt (f|fffd|r vorgezones CE)
    If Not CheckCEOptions() Then Exit Sub
    Dim colLinks As Collection, colBookmarks As Collection
    Set FormAnmLinkBereich = ActiveDocument.Range.Duplicate
    frmAnmerkungsLink.GetBookmarks FormAnmLinkBereich, colLinks, colBookmarks
    
    ActiveDocument.Paragraphs.first.Range.Select
    Selection.Collapse
    With Selection.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Replacement.text = ""
        .Format = True
        .Forward = True
        .Wrap = wdFindStop
        .text = ""
    End With
    
    Dim sel As Range, selEnd As Range, success As Boolean, tmp As String, failed As Boolean, r As Range, nr As Integer
    failed = False
    With Selection.Find
        .Style = "Anmerkungslink"
        Do While .Execute(Replace:=wdReplaceNone)
            If Selection.Characters.Last = Chr(13) Then
                Selection.Characters.Last.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
                Selection.MoveEnd , -1
            End If
            Set sel = Selection.Range.Duplicate
            Set selEnd = sel.Duplicate
            selEnd.Collapse wdCollapseEnd
            
            Set r = sel.Duplicate
            r.MoveStart , -1
            r.MoveEnd
            
            success = False
            ' Es darf weder links noch rechts von dem Anmerkungslink ein Hyperlink sein - siehe frmAnmerkungsLink
            If r.Hyperlinks.Count = 0 And RegexMatches("^[0-9]+$", sel.text) Then
                nr = CInt(sel.text)
                tmp = ""
                If CollectionContainsItem(colLinks, nr) Then
                    tmp = colBookmarks.item("num" & sel.text)
                    If Not ActiveDocument.Bookmarks.Exists(tmp) Then tmp = ""
                End If
                If tmp <> "" Then
                    sel.Select
                    'Stop
                    Selection.Delete
                    frmAnmerkungsLink.CreateLink tmp, nr
                    success = True
                Else
                    Stop
                End If
            End If
            
            If Not success Then failed = True
            selEnd.Select
        Loop
    End With
    If failed Then
        MsgBox "Bitte pr|fffd|fen - es blieben eventuell Anmerkungslinks |fffd|ber.", vbExclamation
    Else
        MsgBox "Fertig.", vbInformation
    End If
End Sub

Private Function IsAnmNumField(r As Range) As Boolean
    If r.Fields.Count <> 0 Then
        If StartsWith(Trim(r.Fields(1).Code), "MACROBUTTON AnmerkungsnummerInfo") Then
            IsAnmNumField = True
            Exit Function
        End If
    End If
    IsAnmNumField = False
End Function

Sub FreitextFelderWandeln()
    ' Freitext-Felder (vorgezogenes CE)
    If Not CheckCEOptions() Then Exit Sub

    FreitextFeldWandeln "...."
    FreitextFeldWandeln ". . . . . ."
    FreitextFeldWandeln "|fffd|"
End Sub
Private Sub FreitextFeldWandeln(txt As String)
    ActiveDocument.Paragraphs.first.Range.Select
    Selection.Collapse
    
    Dim r As Range
    With Selection.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Replacement.text = ""
        .Format = False
        .Forward = True
        .MatchWildcards = False
        .Wrap = wdFindStop
        .text = txt
        
        Do While .Execute(Replace:=wdReplaceNone)
            ' Anfang erweitern
            Set r = Selection.Range.Duplicate
            Do While r.start >= Selection.Paragraphs.first.Range.start
                r.MoveStart , -1
                If r.Characters.first = "." Or r.Characters.first = "|fffd|" Then
                    r.Select
                Else
                    Exit Do
                End If
            Loop
            
            ' Ende erweitern
            Set r = Selection.Range.Duplicate
            Do While r.End < Selection.Paragraphs.first.Range.End
                r.MoveEnd
                If r.Characters.Last = "." Or r.Characters.Last = "|fffd|" Then
                    r.Select
                Else
                    Exit Do
                End If
            Loop
            
            
             If InStr(Replace(Replace(Replace(Selection.text, "|fffd|", "..."), ".|fffd|.|fffd|.|fffd|.|fffd|.|fffd|.", "......"), ". . . . . .", "......"), "....") Then
                Selection.Delete
                FormularfeldEinfuegen
            Else
                Selection.Collapse wdCollapseEnd
            End If
        Loop
    End With
End Sub




Sub unsetmeta()

        Selection.Find.ClearFormatting
        Selection.Find.Replacement.ClearFormatting
        With Selection.Find
        .text = "$#$Stichworte=[!$]@$"
        .Replacement.text = "$"
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = True
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        End With
        
        
        Selection.Find.Execute Replace:=wdReplaceAll
        Selection.Find.text = "$#$Normen=[!$]@$"
        Selection.Find.Execute Replace:=wdReplaceAll
        Selection.Find.text = "$#$Stand=[!$]@$"
        Selection.Find.Execute Replace:=wdReplaceAll
        ActiveDocument.Save
        'ActiveDocument.Close


End Sub

Sub DoktypVorbemerkung()
Dim v As Variable
For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_DokType" Then
          v.Delete
        End If
    Next
    ActiveDocument.Variables.Add "Beck_Form_DokType", "Vorbemerkung"
End Sub

Sub DoktypCheckliste()
Dim v As Variable
For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_DokType" Then
          v.Delete
        End If
    Next
    ActiveDocument.Variables.Add "Beck_Form_DokType", "Checkliste"
End Sub

Sub DoktypFormular()
Dim v As Variable
For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_DokType" Then
          v.Delete
        End If
    Next
    ActiveDocument.Variables.Add "Beck_Form_DokType", "Formular"
End Sub


    
    
    

Attribute VB_Name = "modContainer"
Option Explicit

' Die Struktur ist so, dass die meisten Container nicht innerhalb von Tabellen erzeugt werden d|fffd|rfen

Private Const FormcolsInfo As String = "Zweispaltiger Formulartext (Rubrum)"

' ******** VERZEICHNISSE ********

Sub Einfuegen_AbkVerz()
    Block_Erzeugen "Abk|fffd|rzungsverz"
End Sub

Sub Einfuegen_AutorVerz()
    Block_Erzeugen "Autorenverz"
End Sub

Sub Einfuegen_AbbVerz()
    Block_Erzeugen "Abbildungsverz"
End Sub

Sub Einfuegen_TabVerz()
    Block_Erzeugen "Tabellenverz"
End Sub

Sub Einfuegen_Literatur()
    Block_Erzeugen "Literatur"
End Sub

Sub Einfuegen_Schrifttum()
    If Not AnmerkungstextVerbotenPruefen Then Exit Sub
    'Block_Erzeugen "Schrifttum"
    ContainerMitTitel "Schrifttum", "Schrifttum:"
End Sub

' ******** FORMULARE ********

' Pr|fffd|fungen der |fffd|bergeordneten Container sind u.a. aus Performancegr|fffd|nden nur rudiment|fffd|r bzw. ggf. nicht vorhanden

Sub Einfuegen_Formular()
    'If Block_Erzeugen(FormularBlockName, True) Then
    '    Selection.Collapse
      '  FormMetadaten
    'End If
End Sub


Sub Einfuegen_Checkliste()
    ' Ist im XML das gleiche wie ein Formular
    If Block_Erzeugen("Checkliste", True) Then
        Selection.Collapse
      '  FormMetadaten
    End If
End Sub

Sub Einfuegen_Formulartext()
    ' Auch f|fffd|r Checklisten
    'If Not FormularPruefen Then Exit Sub
    Block_Erzeugen "Formulartext"
End Sub

Sub Einfuegen_Anmerkungen()
    ' Anmerkungs-Container einf|fffd|gen
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "Anmerkungen", "Anmerkungen"
End Sub

Sub Einfuegen_Sachverhalt()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "Sachverhalt", "Sachverhalt"
End Sub
Sub Einfuegen_MateriellesRecht()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "MateriellesRecht", "Materielles Recht"
End Sub
Sub Einfuegen_ProzessrechtVerfahrenshinweise()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "ProzessrechtVerfahrenshinweise", "Prozessrecht und Verfahrenshinweise"
End Sub
Sub Einfuegen_Steuern()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "Steuern", "Steuern"
End Sub
Sub Einfuegen_KostenGebuehren()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "KostenGeb|fffd|hren", "Kosten und Geb|fffd|hren"
End Sub
Sub Einfuegen_Fristen()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "Fristen", "Fristen"
End Sub
Sub Einfuegen_Rechtsmittel()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "Rechtsmittel", "Rechtsmittel"
End Sub

Sub Einfuegen_sonstRubrik()
    'If Not FormularPruefen Then Exit Sub
    ContainerMitTitel "Sonstige Rubrik", "Sonstige Rubrik"
End Sub



Private Sub ContainerMitTitel(sTyp As String, sTitel As String)
    If Block_Erzeugen(sTyp, True) Then
        ' Titel einf|fffd|gen
        Selection.Collapse
        If Selection.Paragraphs.first.Range.text <> Chr(13) Then
            InsertNewParaBefore
        End If
        Selection.Style = "Container Titel"
        Selection.TypeText sTitel
        Selection.MoveDown wdParagraph, 1
        
        ' Ggf. Absatz einf|fffd|gen
        If Selection.Paragraphs.Last.Style = sTyp & " Ende" Then
            InsertNewParaBefore
            Selection.Paragraphs.first.Style = "Absatz"
        End If
    End If
End Sub

Sub Einfuegen_Beweis()
    If Not FormulartextPruefen Then Exit Sub
    SetSelectionAF "Beweis"
    'Block_Erzeugen "Beweis"
    If Not StartsWith(Selection.Paragraphs.first.Range.text, "Beweis:") Then
        Selection.Paragraphs.first.Range.Select
        Selection.Collapse
        Selection.TypeText "Beweis: "
    End If
End Sub

Sub Einfuegen_Glaubhaftmachung()
    If Not FormulartextPruefen Then Exit Sub
    SetSelectionAF "Glaubhaftmachung"
    'Block_Erzeugen "Beweis"
    If Not StartsWith(Selection.Paragraphs.first.Range.text, "Glaubhaftmachung:") Then
        Selection.Paragraphs.first.Range.Select
        Selection.Collapse
        Selection.TypeText "Glaubhaftmachung: "
    End If
End Sub

Sub Einfuegen_Rechtsprechungszitat()
    If Not FormulartextPruefen Then Exit Sub
    SetSelectionAF "Rechtsprechungszitat"
    'Block_Erzeugen "Rechtsprechungszitat"
End Sub

Sub Einfuegen_Variante()
    If Not FormulartextPruefen Then Exit Sub
    Block_Erzeugen "Variante"
End Sub

Sub Einfuegen_Synopse()
    If Not AnmerkungstextVerbotenPruefen Then Exit Sub
    Dim t As Table
    Set t = FormularZweierTabelle(wdSeparateByParagraphs)
    If Not t Is Nothing Then
      t.Select
      Selection.MoveLeft
      Selection.MoveLeft
      Selection.TypeParagraph
      Selection.Paragraphs.Style = "Synopse Anfang"
      Selection.TypeText "Synopse Anfang"
      t.Select
      Selection.MoveDown
      Selection.TypeParagraph
      Selection.MoveUp
      Selection.Paragraphs.Style = "Synopse Ende"
      Selection.TypeText "Synopse Ende"
    End If
End Sub

Sub Einfuegen_Zweispaltig()
    ' Im XML: Formcols
    Dim tbl As Table, r As Range, p As Paragraph
    Set tbl = FormularZweierTabelle(wdSeparateByTabs)
    If tbl Is Nothing Then Exit Sub
    
    ' Tabellenzellen einrichten
    For Each p In tbl.Range.Paragraphs
        If p.Style = ActiveDocument.styles(wdStyleNormal) Then
            p.Style = "Absatz"
        End If
    Next
    tbl.Columns(1).Select
    Selection.ParagraphFormat.Alignment = wdAlignParagraphLeft
    tbl.Columns(2).Select
    Selection.ParagraphFormat.Alignment = wdAlignParagraphRight
    
    ' Kopfzeile mit Zweispaltig-Info einf|fffd|gen
    With tbl.Rows.Add(tbl.Rows.first)
        .Cells(1).Merge .Cells(.Cells.Count)
        .HeadingFormat = True
        Set r = .Cells(1).Range.Duplicate
        r.End = r.start
        r.Select
        With Selection.Fields.Add(Selection.Range, wdFieldMacroButton, _
         "FormulartextZweispaltigInfo " & FormcolsInfo, False)
            .ShowCodes = False
            .Code.text = Trim(.Code.text)
        End With
        Selection.Paragraphs.first.Style = "Absatz"
        Selection.Paragraphs.first.Alignment = wdAlignParagraphCenter
    End With
    
    ' Fertig
    Set r = tbl.Rows.Last.Cells(1).Range
    r.End = r.start
    r.Select
End Sub

Sub FormulartextZweispaltigInfo()
    ' MACROBUTTON als Info f|fffd|r Konvertierung
    Dim tbl As Table, f As Field, p As Paragraph
    If Selection.Tables.Count > 0 Then
        Set tbl = Selection.Tables(1)
        With Dialogs(wdDialogTableToText)
            If .Show = 0 Then Exit Sub
            ' Macrobutton ebenfalls entfernen
            For Each f In Selection.Fields
                If f.Type = wdFieldMacroButton Then
                    f.ShowCodes = False
                    If InStr(f.Code.text, "FormulartextZweispaltigInfo") Then
                        Set p = f.Result.Paragraphs.first
                        f.Delete
                        If Trim(p.Range.text) = Chr(13) Then
                            p.Range.Delete
                        End If
                    End If
                End If
            Next
        End With
    End If
End Sub

' Funktionen f|fffd|r Formular-Container

Private Function FormularZweierTabelle(separator As WdTableFieldSeparator) As Table
'    If Not FormulartextPruefen Then
'        Set FormularZweierTabelle = Nothing
'        Exit Function
'    End If
    If Not CheckContainersAllowed(False) Then
        Set FormularZweierTabelle = Nothing
        Exit Function
    End If
    
    ' Immer komplette Abs|fffd|tze markieren
    Dim tbl As Table, fehler As Boolean, r As Range, r2 As Range
    Selection.start = Selection.Paragraphs.first.Range.start
    Selection.End = Selection.Paragraphs.Last.Range.End
    
    ' Ggf. Abstand zu Tabelle dar|fffd|ber
    Set r = Selection.Range.Duplicate
    r.Collapse
    r.MoveStart , -1
    If r.Characters(1).Information(wdWithInTable) Then
        Set r2 = Selection.Range.Duplicate
        InsertNewParaBefore
        r2.Select
        Selection.start = Selection.Paragraphs.first.Next.Range.start
    End If
    
    ' Text zu Tabelle konvertieren
    On Error Resume Next
    err.number = 0
    Set tbl = Selection.ConvertToTable(separator, , 2)
    fehler = err.number <> 0
    On Error GoTo 0
    
    If fehler Then
        ' Tabelle einf|fffd|gen
        Set tbl = Selection.Tables.Add(Selection.Range, 1, 2)
    End If
    With tbl.Borders
        .InsideLineStyle = wdLineStyleNone
        .OutsideLineStyle = wdLineStyleNone
    End With
    Selection.Collapse
    Set FormularZweierTabelle = tbl
End Function

Private Function FormularPruefen() As Boolean
    ' Pr|fffd|fen ob Textcursor innerhalb eines Formulars (oder auch Checkliste)
'    If BlockAnfang_Finden(FormularBlockName, Selection.Paragraphs.First) Is Nothing And _
'     BlockAnfang_Finden("Checkliste", Selection.Paragraphs.First) Is Nothing Then
'        MsgBox "Dies ist nur innerhalb eines " & FormularBlockName & "- oder Checklisten-Containers m|fffd|glich.", vbExclamation
'        FormularPruefen = False
'        Exit Function
'    End If
    FormularPruefen = True
End Function

Function FormulartextPruefen() As Boolean
    If BlockAnfang_Finden("Formulartext", Selection.Paragraphs.first) Is Nothing And BlockAnfang_Finden("Checkliste", Selection.Paragraphs.first) Is Nothing Then
        MsgBox "Dies ist nur innerhalb eines Formulartext-Containers m|fffd|glich.", vbExclamation
        FormulartextPruefen = False
        Exit Function
    End If
    FormulartextPruefen = True
End Function

Function AnmerkungstextVerbotenPruefen() As Boolean
    If Not BlockAnfang_Finden("Anmerkungen", Selection.Paragraphs.first) Is Nothing Then
        MsgBox "Dies ist nicht innerhalb der Anmerkungen m|fffd|glich.", vbExclamation
        AnmerkungstextVerbotenPruefen = False
        Exit Function
    End If
    AnmerkungstextVerbotenPruefen = True
End Function

' ******** SONSTIGE ********

Sub Einfuegen_Kleindruck()
    Block_Erzeugen "Kleindruck", , True ' Kleindruck in Tabelle wird u.a. bei Checklisten ben|fffd|tigt
End Sub

Sub Einfuegen_Formulierungsbsp()
    Block_Erzeugen "Formulierungsvorschlag"
End Sub

Sub Einfuegen_Anhang()
    Block_Erzeugen "Anhang"
End Sub

Sub Einfuegen_Vorwort()
    Block_Erzeugen "Vorwort"
End Sub

Sub Einfuegen_Beweisblock()
    If Not FormulartextPruefen Then Exit Sub
    Dim sel As Range
    Set sel = Selection.Range.Duplicate
    If Not StartsWith(sel.Paragraphs.first.Range.text, "Beweis:") Then
        sel.Paragraphs.first.Range.Select
        Selection.Collapse
        Selection.TypeText "Beweis: "
        sel.Select
    End If
    Block_Erzeugen "Beweis"
End Sub

Sub Einfuegen_Klageantragblock()
    If Not FormulartextPruefen Then Exit Sub
    Block_Erzeugen "Klageantrag"
End Sub

Sub Einfuegen_Glaubhaftmachungblock()
    If Not FormulartextPruefen Then Exit Sub
    Dim sel As Range
    Set sel = Selection.Range.Duplicate
    If Not StartsWith(sel.Paragraphs.first.Range.text, "Glaubhaftmachung:") Then
        sel.Paragraphs.first.Range.Select
        Selection.Collapse
        Selection.TypeText "Glaubhaftmachung: "
        sel.Select
    End If
    Block_Erzeugen "Glaubhaftmachung"
End Sub

Sub Einfuegen_Rspzitblock()
    If Not FormulartextPruefen Then Exit Sub
    Block_Erzeugen "Rechtsprechungszitat"
End Sub


' ******** FUNKTIONEN ********

Public Function BlockAnfang_Finden(sTyp As String, pStart As Paragraph, Optional startErlaubt As Boolean = False) As Paragraph
    ' Zum Finden des Anfangs eines bestimmten offenen Containers
    Dim p As Paragraph
    Set p = pStart
    If pStart.Style = sTyp & " Anfang" And Not startErlaubt Then
        ' Sonderfall - pStart ist Startabsatz des Containers und ist somit nicht *innerhalb* des Containers
        Set BlockAnfang_Finden = Nothing
        Exit Function
    End If
    Do While Not p Is Nothing
        If p.Style = sTyp & " Anfang" Then
            ' Container-Anfang
            Set BlockAnfang_Finden = p
            Exit Function
        ElseIf p.Style = sTyp & " Ende" Then
            ' Container-Ende; immer aussteigen da pStart nicht *innerhalb* des Containers
            Set BlockAnfang_Finden = Nothing
            Exit Function
        End If
        Set p = p.Previous
    Loop
    
    ' Nicht gefunden
    Set BlockAnfang_Finden = Nothing
End Function

Public Function BlockEnde_Finden(sTyp As String, pStart As Paragraph) As Paragraph
    ' Zum Finden des Endes eines bestimmten offenen Containers
    Dim p As Paragraph
    Set p = pStart
    Do While Not p Is Nothing
        If p.Style = sTyp & " Anfang" Then
            ' Container-Anfang; immer aussteigen da pStart nicht *innerhalb* des Containers
            Set BlockEnde_Finden = Nothing
            Exit Function
        ElseIf p.Style = sTyp & " Ende" Then
            ' Container-Ende
            Set BlockEnde_Finden = p
            Exit Function
        End If
        Set p = p.Next
    Loop
    
    ' Nicht gefunden
    Set BlockEnde_Finden = Nothing
End Function

Public Function Block_Erzeugen(sTyp As String, Optional bSelParas As Boolean = False, Optional bAllowInTable As Boolean = False) As Boolean
    If Selection.Information(wdWithInTable) And bAllowInTable Then
      If Selection.Cells.Count > 1 Then Selection.Cells.item(1).Select
    End If
    If Not CheckContainersAllowed(bAllowInTable) Then
        Block_Erzeugen = False
        Exit Function
    End If
    Dim lParas As Long, i As Integer
    lParas = Block_Erzeugen_Do(sTyp)
    If bSelParas Then
        Selection.start = Selection.Paragraphs.first.Range.start
        Selection.End = Selection.Paragraphs.Last.Range.End
        If lParas > 1 Then
            For i = 1 To lParas - 1
                Selection.start = Selection.Paragraphs.first.Previous.Range.start
            Next
        End If
    End If
    Block_Erzeugen = True
End Function

Private Function Block_Erzeugen_Do(sTyp As String) As Long
    Dim lParas As Long
    lParas = Selection.Paragraphs.Count
    InsertNewParaBefore
    SetSelectionAF sTyp & " Anfang"
    insertField sTyp & " Anfang"
    Selection.MoveDown wdParagraph, lParas
    MacheBlockEnde sTyp
    Selection.MoveUp
    Block_Erzeugen_Do = lParas
End Function

Private Sub MacheBlockEnde(sTyp As String)
    InsertNewParaAfter
    SetSelectionAF sTyp & " Ende"
    insertField sTyp & " Ende"
End Sub

Private Function CheckContainersAllowed(bAllowTable As Boolean) As Boolean
    If SelectionInSpecialArea(bAllowTable) Then
        MsgBox "An dieser Stelle kann kein Container eingef|fffd|gt werden.", vbExclamation
        Exit Function
    End If
    
    CheckContainersAllowed = True
End Function

Private Sub insertField(text As String)
    Selection.Style = wdStyleDefaultParagraphFont
    Selection.Collapse wdCollapseEnd
    Selection.TypeText text
End Sub

Public Sub FillSems(ByRef arrSemTypes As Variant, ByRef colSems As Collection)
    ' Formular/Checkliste/Formulartext absichtlich am Anfang
    arrSemTypes = Array("Checkliste", "Formulartext", "Anmerkungen", _
      "Variante", "Kleindruck", "Formulierungsvorschlag", "Vorwort", "Anhang", "Abbildungsverz", _
      "Abk|fffd|rzungsverz", "Synopse", "Literatur", "Tabellenverz", "Autorenverz", "Schrifttum", "KostenGeb|fffd|hren", "Sachverhalt", "MateriellesRecht", "ProzessrechtVerfahrenshinweise", "Steuern", "Fristen", "Rechtsmittel", "Sonstige Rubrik", _
      "Beweis", "Klageantrag", "Glaubhaftmachung", "Rechtsprechungszitat")
    Dim lSem As Long
    For lSem = 0 To UBound(arrSemTypes)
        colSems.Add 0, arrSemTypes(lSem)
    Next
End Sub

Attribute VB_Name = "modControl"
Option Explicit

Private colBars As Collection
Public DocTyp As String
Public newdoc As Boolean
Global globVerlag As Boolean

Global blBeckRibbonForm As Boolean, blBeckRibbonAnm As Boolean, blBeckRibbonCheckliste As Boolean, blBeckRibbonVorbem As Boolean ', blBeckRibbonVerlag As Boolean

Option Private Module

Sub PlaceholderMacro()
    'MsgBox "hi"
    'FocusDocumentWnd
End Sub

Sub init()
  Set ThisDocument.xapp = Application
  DoToolbars True
  On Error Resume Next
  oRibbon.Invalidate
End Sub

Sub ShowDotAbout()
    Load frmAbout
    frmAbout.Show vbModal
    Unload frmAbout
End Sub

Sub DoToolbars(init As Boolean)
    Dim initRibbon As Boolean
    initRibbon = DocTyp = ""
    
    If FileExists(ActiveDocument.AttachedTemplate.Path & "\Commandbars.ini") Then blWordRibbonsVisibleCE = True
    
        ' F|fffd|r Autoren, Verlag, usw.
        'InitControlForm
        
        If ActiveDocument.Paragraphs.first.Style = ActiveDocument.styles(wdStyleHeading1) Then
            ActiveDocument.Paragraphs.first.Range.Select
            Selection.Collapse
            newdoc = False
        Else
          newdoc = True
        End If
        
        ' Dialog anzeigen
        If blWordRibbonsVisibleCE Then
        
        Else
            ShowFormMeta
        End If
        
        If DocTyp <> "" Then 'And initRibbon Then
            modRibbon.RibbonDocTypSet
        End If

'fertig:
'        Set p = Selection.Paragraphs.First
'        If p.Style = FormularBlockName & " Anfang" Or p.Style = "Checkliste Anfang" Or p.Style = "Metadaten" Then
'            Selection.MoveDown wdParagraph, 1
'        End If
'
'        ShowFormMeta
End Sub

Sub ShowFormMeta()
    If DocTyp <> "" Then
        ShowFormMeta_org
    Else
        frmBeckOF.Show 1
    End If
End Sub

'Version vor BeckOF wird nun vom frmBeckOF aus aufgerufen
Sub ShowFormMeta_org()
    Load frmFormmeta
    
    If Not frmFormmeta.btnSave.Enabled And Not newdoc Then
        MsgBox "Es sind noch nicht alle notwendigen Dokumenteigenschaften angegeben. Bitte in folgendem Dialog eintragen.", vbInformation Or vbOKOnly, "Hinweis"
    End If
    
    frmFormmeta.Show 1
End Sub
Attribute VB_Name = "modDokpruefer"
Option Explicit

Private dversion As New CVersion

Global arrFehler() As Variant
Global Const strFehlerTrennz$ = "|*|"
Global fehlerDoc As Document
Private Const strAFMustExist$ = "" ' Es muss mind. einen Absatz mit diesem Format geben; hier an Anfang + Ende kein |!
Public Enum errTypes
    normal = 0
    warning = 1
    part = 2
    sem = 3
End Enum
Private strErrorTypes$
Public DoneSetApp As Boolean

Global Const strHintTrennz$ = "|?*!|"

Global strHintHint$
Global strDefaultHint$
Global hintAnfang$
Global hintNachTeil$
Global hintFormat$
Global hintKapitel$
Global hintLeerabsatz$
Global hintSems$

Global Const qstAssExist$ = "Die verkn|fffd|pfte Textstelle existiert nicht mehr. Bitte klicken Sie auf 'Dokument erneut |fffd|berpr|fffd|fen'."
                      
Global Const errSpaceTab$ = "Leerzeichen+Tabulator"
Global Const errSpaceSpace$ = "Doppeltes Leerzeichen"
Global Const errSpaceNbsp$ = "Leerzeichen+gesch|fffd|tztes Leerzeichen"
Global Const errNbspTab$ = "Gesch|fffd|tztes Leerzeichen+Tabulator"
Global Const errTabNbsp$ = "Tabulator+gesch|fffd|tztes Leerzeichen"
Global Const errTabSpace$ = "Tabulator+Leerzeichen"
Global Const errNbspNbsp$ = "Gesch|fffd|tztes Leerzeichen+gesch|fffd|tztes Leerzeichen"
Global Const errNbspSpace$ = "Gesch|fffd|tztes Leerzeichen+Leerzeichen"
Global Const errTabTab$ = "Tabulator+Tabulator"
Global Const errSpaces$ = " wird im Text verwendet"
Global Const errSpacePunct$ = "Leerzeichen vor Interpunktion"

Global Const errInvalidFormatText = " wird im Fu|fffd|notentext verwendet"
Global Const errInvalidFormatFn = " wird im Text verwendet"

Public rangeBeforeDok As Range

Private autoCheck As Boolean
Private xmlLog As MSXML2.DOMDocument60


Sub DokprStyleCheck()
    ' Zum manuellen Aufruf
    IniErlaubteFormate ' globale Variablen strErlaubteFormate & strErlaubteFormateTrennz f|fffd|llen
    Dim a As Variant, item As Variant, st As Style, colAllowed As Collection
    a = Split(strErlaubteFormate, strErlaubteFormateTrennz)
    Set colAllowed = New Collection
    For Each item In a
        If CStr(item) = "" Then GoTo skip
        On Error Resume Next
        err.number = 0
        Set st = ActiveDocument.styles(CStr(item))
        If err.number <> 0 Then
            Debug.Print "Missing: " & item
        ElseIf st.BuiltIn Then
            Debug.Print "Builtin: " & st.NameLocal
        Else
            colAllowed.Add st.NameLocal
        End If
skip:
        On Error GoTo 0
    Next
    For Each st In ActiveDocument.styles
        If Not st.BuiltIn Then
            If Not CollectionContainsItem(colAllowed, st.NameLocal) Then
                ' Hier d|fffd|rfen nur DPWarnungstext und z...Block... auftauchen
                Debug.Print "Custom not allowed: " & st.NameLocal
            End If
        End If
        If st.Type <> wdStyleTypeCharacter And CollectionContainsItem(colAllowed, st.NameLocal) Then
            If Not CollectionContainsItem(colAllowed, st.NextParagraphStyle) Then
                Debug.Print "Next not allowed: " & st.NameLocal
            End If
        End If
    Next
End Sub

Sub CallDokPruefen(Optional nomsg As Boolean = False)
    Dim v As Variable
    Dim a As Boolean
    Dim sr As Boolean
    
    autoCheck = False
    If Not nomsg Then
        If MsgBox("Dieser Vorgang kann einige Zeit beanspruchen. M|fffd|chten Sie das Dokument jetzt pr|fffd|fen?", vbYesNo) = vbNo Then
          Exit Sub
        End If
    End If
    
'  If ActiveDocument.Revisions.Count > 0 Then
'    If MsgBox("Im Dokument sind |fffd|nderungsmarkierungen enthalten, das kann zu einem fehlerhaften Pr|fffd|fergebnis f|fffd|hren. Trotzdem fortfahren?", vbYesNo) = vbNo Then
'      Exit Sub
'    End If
'  End If
  
  
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Last_Check" Then
          v.Value = Now
          a = True
        End If
    Next
    If Not a Then ActiveDocument.Variables.Add "Beck_Last_Check", Now
  

    With ActiveDocument
        AenderungsmodusAktiv = .TrackRevisions
        .TrackRevisions = False
        sr = .ShowRevisions
        .ShowRevisions = False
    End With
    
'   With ActiveWindow.View
'      .ShowRevisionsAndComments = False
'      .RevisionsView = wdRevisionsViewOriginal
'    End With
    
    Set rangeBeforeDok = Selection.Range
    DokPruefen False
    
    
     With ActiveDocument
        .TrackRevisions = AenderungsmodusAktiv
        .ShowRevisions = sr
    End With
    
    
End Sub



Sub AutoDokPruefen()
    Set xmlLog = New MSXML2.DOMDocument60

    Set xmlLog.documentElement = xmlLog.createElement("log")
    

    autoCheck = True

    With ActiveDocument
        .TrackRevisions = False
        '.PrintRevisions = False
        '.ShowRevisions = False
    End With
    
    
    Set rangeBeforeDok = Selection.Range
    DokPruefen False
    
    xmlLog.Save Replace(Replace(ActiveDocument.FullName, ".docx", ".doc"), ".doc", ".xml")
    ActiveDocument.Save
    ActiveDocument.Close
End Sub


Public Sub DokPruefen(Optional blFromSaveEvent As Boolean = False)
    Dim hasMeta As Boolean
    Dim metaText As String
    
    'alten Warnungstext l|fffd|schen
    Dim wtfound As Boolean
    wtfound = True
    While wtfound = True
        wtfound = False
        Dim wpara As Paragraph
        For Each wpara In ActiveDocument.Paragraphs
            If wpara.Style = "DPWarnungstext" Then
                wtfound = True
                wpara.Range.Delete
            End If
        Next wpara
    Wend
    
    Dim intCurrentLevel As Integer
    Dim cAbsnr As Long
    
    set_dokpr_flag
    
    strErrorTypes = ""
    System.Cursor = wdCursorWait
    IniErlaubteFormate ' globale Variablen strErlaubteFormate & strErlaubteFormateTrennz f|fffd|llen
    
    Dim paraIdx As Double
    Dim arrAFMustExist() As String, arrDoExist() As Boolean
    If strAFMustExist <> "" Then
        arrAFMustExist = Split(strAFMustExist, "|")
        ReDim Preserve arrDoExist(UBound(arrAFMustExist))
    End If
    ReDim Preserve arrFehler(0)
    frmErrorlog.lstLog.Clear
    frmErrorlog.Hide
    
    intCurrentLevel = -2
    cAbsnr = 0
    
    hasMeta = False
    
    ' Sems initialisieren
    Dim arrSemTypes() As Variant, colSems As New Collection, colSemLastOpen As New Collection
    FillSems arrSemTypes, colSems
    Dim colOpenSems As New Collection
    
    Dim absatz As Paragraph
    Dim letztesAbsatzFormat As String
    
    modForms.InitVariables
    
    
    
    'Fu|fffd|notentest [aktuell keine Fu|fffd|noten erlaubt]
    Dim fnote As footnote
    For Each fnote In ActiveDocument.footnotes
        RecordError_Bookmark "Fu|fffd|noten sind nicht erlaubt.", part, , fnote.Reference
        
'        Dim fnpara As Paragraph
'        For Each fnpara In fnote.Range.Paragraphs
'            If fnpara.Style <> ActiveDocument.Styles(wdStyleFootnoteText) Then
'                If ArrayContains(listArray, fnpara.Style) = False Then
'                    Dim fnError As Boolean
'                    fnError = False
'                    If fnpara.Style = "Absatz" Then
'                        If fnpara.Range.Tables.Count > 0 Then
'                            'nix
'                        Else
'                            fnError = True
'                        End If
'                    Else
'                        fnError = True
'                    End If
'                    If fnError Then
'                        If Not (fnpara.Range.text = Chr(13) & Chr(7) And fnpara.Style = ActiveDocument.Styles(wdStyleNormal)) Then
'                            RecordError_Bookmark "Fu|fffd|note mit falschem Absatzformat " & fnpara.Style & " gefunden.", part, , fnpara.Range
'                        End If
'                    End If
'                End If
'            End If
'        Next fnpara
    Next fnote
        
    
    For Each absatz In ActiveDocument.Paragraphs
        paraIdx = paraIdx + 1
        Application.StatusBar = "Pr|fffd|fe Absatz " & paraIdx & " von " & ActiveDocument.Paragraphs.Count
        DoEvents
        DoEvents
        
        
        'metadaten
        If Not autoCheck And absatz.Style = "Metadaten" Then
            hasMeta = True
            metaText = absatz.Range.text
            metaText = Left(metaText, Len(metaText) - 1) & "$"
            If InStr(1, metaText, "$Autor=$") Then
                RecordError_Bookmark "Metadaten - Autor nicht angegeben.", sem, , absatz.Range
            End If
'            If InStr(1, metaText, "$Stand=$") Then
'                RecordError_Bookmark "Metadaten - Stand nicht angegeben.", sem, , absatz.Range
'            End If
'            If InStr(1, metaText, "$Rechtsgebiet=$") Then
'                RecordError_Bookmark "Metadaten - Rechtsgebiet/e nicht ausgew|fffd|hlt.", sem, , absatz.Range
'            End If
'            If InStr(1, metaText, "$Stichworte=$") Then
'                RecordError_Bookmark "Metadaten - Schlagwort/e nicht angegeben.", sem, , absatz.Range
'            End If
'            If InStr(1, metaText, "$Normen=$") Then
'                RecordError_Bookmark "Metadaten - Bezugsnorm/en nicht angegeben.", sem, , absatz.Range
'            End If
        End If
        
        ' Tabstops (einfache Pr|fffd|fung)
        If CountContainedTab(absatz.Range) > 1 Then
            RecordError_Bookmark "Mehrere Tabstops (anstatt Tabelle) verwendet.", part, , absatz.Range
        End If
        If CountContainedTab(absatz.Range) = 1 Then
            If Not ArrayContains(headerArray, absatz.Style) Then
                RecordError_Bookmark "Tabstops verwendet.", warning, , absatz.Range
            End If
        End If
        
        'Listentest, falls normale Abs|fffd|tze als Listen ausgezeichnet sind

        If absatz.Range.ListFormat.listType <> wdListNoNumbering Then
            If ArrayContains(listArray, absatz.Style) = False Then
                RecordError_Bookmark "Manuell formatierten Listenabsatz gefunden.", part, , absatz.Range
            End If
        End If
        
        '|fffd|berschriftentests auf Randnummern und doppelte |fffd|berschriften
        
        Dim rnhstring As Variant
        For Each rnhstring In headerArray
            If absatz.Style = rnhstring Then
                If Not absatz.Previous Is Nothing Then
'                    If absatz.Previous.Style = "Randnummer" Then
'                        RecordError_Bookmark "|fffd|berschrift nach Randnummer gefunden.", part, , absatz.Range
'                    End If
                End If
                Dim hstrng As Variant
                If Not absatz.Next Is Nothing Then
                    For Each hstrng In headerArray
                        If (absatz.Next.Style = hstrng) And (absatz.Style = absatz.Next.Style) Then
                            RecordError_Bookmark "Zwei gleiche |fffd|berschriften folgen aufeinander.", part, , absatz.Range
                        End If
                    Next hstrng
                End If
            End If
                
        Next rnhstring
        
    
        ' Bl|fffd|cke pr|fffd|fen
        Dim lSonstig As Long
        For lSonstig = 0 To UBound(arrSemTypes)
            Dim sBlockTyp As String
            sBlockTyp = arrSemTypes(lSonstig)
            Dim lBlockOpen As Long, lDiff As Long, blIsSemControl As Boolean
            blIsSemControl = False
            lBlockOpen = CLng(colSems(sBlockTyp))
            lDiff = 0
            If InStr(absatz.Style, sBlockTyp & " Anfang") Then
                ' Anfang
                blIsSemControl = True
                lDiff = 1
                Dim sParentSem As String
                sParentSem = ""
                If lBlockOpen > 0 Then
                    RecordError_Bookmark sBlockTyp & " wird ge|fffd|ffnet, obwohl " & sBlockTyp & " bereits ge|fffd|ffnet ist.", sem, , absatz.Range
                ElseIf colOpenSems.Count > 0 Then
                    sParentSem = colOpenSems("i" & colOpenSems.Count)
                    If sBlockTyp = "Checkliste" Then
                        If sParentSem <> "Formulartext" And sParentSem <> "Anmerkungen" Then
                            RecordError_Bookmark sBlockTyp & " darf nicht innerhalb eines Containers (au|fffd|er Formulartext/Anmerkungen) verwendet werden.", sem, , absatz.Range
                        End If
                    ElseIf sBlockTyp = FormularBlockName Then
                        RecordError_Bookmark sBlockTyp & " darf nicht innerhalb eines Containers verwendet werden.", sem, , absatz.Range
                    End If
                End If
'                If (sBlockTyp = "Anmerkungen" Or sBlockTyp = "Formulartext") And sParentSem <> FormularBlockName And sParentSem <> "Checkliste" Then
'                    RecordError_Bookmark sBlockTyp & " muss unmittelbar innerhalb eines " & FormularBlockName & "-/Checkliste-Containers verwendet werden.", sem, , absatz.Range
'                End If
                
                ' Merken, wann der Block ge|fffd|ffnet wurde
                On Error Resume Next
                colSemLastOpen.Remove sBlockTyp
                On Error GoTo 0
                colSemLastOpen.Add sBlockTyp & "|" & paraIdx, sBlockTyp
                ' Merken, welcher Block zuletzt ge|fffd|ffnet wurde
                colOpenSems.Add sBlockTyp, "i" & colOpenSems.Count + 1
            ElseIf InStr(absatz.Style, sBlockTyp & " Ende") Then
                ' Ende
                blIsSemControl = True
                ' Pr|fffd|fungen
                If lBlockOpen < 1 Then
                    RecordError_Bookmark sBlockTyp & " wird geschlossen, obwohl " & sBlockTyp & " nicht ge|fffd|ffnet ist.", sem, , absatz.Range
                Else
                    lDiff = -1
                   End If
               If Not absatz.Previous Is Nothing Then
                   If InStr(absatz.Previous.Style, sBlockTyp & " Anfang") Then
                       RecordError_Bookmark sBlockTyp & " wird ge|fffd|ffnet und direkt wieder geschlossen, ohne Abs|fffd|tze zu enthalten.", sem, , absatz.Range
                   End If
               End If
               ' Verschachtelung pr|fffd|fen; im Fehlerfall gemerkte Reihenfolge
               ' verwerfen, damit nicht mehrmals Fehler gemeldet werden
               err.number = 0
               On Error Resume Next
               If colOpenSems("i" & colOpenSems.Count) <> sBlockTyp Then
                   RecordError_Bookmark sBlockTyp & " wird geschlossen, bevor " & colOpenSems("i" & colOpenSems.Count) & " geschlossen wird.", sem, , absatz.Range
                   Set colOpenSems = New Collection
               End If
               On Error Resume Next
               colOpenSems.Remove colOpenSems.Count
               colSemLastOpen.Remove sBlockTyp
               On Error GoTo 0
           End If
           ' Merken, wie oft der Block ge|fffd|ffnet ist
           If lDiff <> 0 Then
               colSems.Remove sBlockTyp
               colSems.Add lBlockOpen + lDiff, sBlockTyp
           End If
           ' Inhalt des Steuerabsatzes pr|fffd|fen
           If blIsSemControl Then
               ' rSemPara muss sein, da es sonst in Tabellen Probleme mit der Pr|fffd|fung gibt
               Dim rSemPara As Range
               Set rSemPara = ActiveDocument.Range(absatz.Range.start, absatz.Range.End - 1)
               Dim blWrongSemControl As Boolean
               blWrongSemControl = True
               If rSemPara.Fields.Count = 1 Then
                   If rSemPara.start = rSemPara.Fields(1).Code.start - 1 And _
                       rSemPara.End = rSemPara.Fields(1).Code.End + 1 Then
                       If rSemPara.Fields(1).Type = wdFieldMacroButton Then
                               blWrongSemControl = False
                       End If
                   End If
               End If
               If blWrongSemControl Then
                    Dim sBlocktext As String
                    sBlocktext = Replace(rSemPara.text, Chr(13), "")
                    sBlocktext = Replace(sBlocktext, "Listenblock", "Liste")
                    If rSemPara.start <> rSemPara.End And sBlocktext <> rSemPara.Style Then
                       'MsgBox para.Range.Fields.count
                       RecordError_Bookmark "Anfang-/Ende-Absatz eines Containers enth|fffd|lt Text.", , "Solche Abs|fffd|tze d|fffd|rfen keinen Text enthalten.", absatz.Range
                    End If
               End If
           End If
       Next
       
       ' Formular|fffd|berschrift pr|fffd|fen
       Dim pNext As Paragraph
       'If (absatz.Style = FormularBlockName & " Anfang" Or absatz.Style = "Checkliste Anfang") And Not absatz.Previous Is Nothing Then
       If absatz.Style = FormularBlockName & " Anfang" And Not absatz.Previous Is Nothing Then
            Set pNext = absatz.Previous
            If pNext.Style = "Metadaten" And Not pNext.Previous Is Nothing Then
                Set pNext = pNext.Previous
            End If
            'If Not IsHeadingPara(pNext) Then
            If Not pNext.Style = ActiveDocument.styles(wdStyleHeading1) Then
                RecordError_Bookmark FormularBlockName & "/Checkliste ohne |fffd|berschrift", sem, , absatz.Range
            End If
       End If
       
       If (absatz.Style = "Anmerkungen Anfang") Then
          Dim bm As Bookmark
          Dim i As Integer
          For Each bm In ActiveDocument.Range.Bookmarks
              If StartsWith(bm.Name, "AnmNr") Then  ' Schnelle Pr|fffd|fung
                  ' Nummer holen
                  Dim match As MatchCollection
                  If RegexMatches("^AnmNr_(A[0-9]+_)?([0-9]+)$", bm.Name, match) Then
                      i = i + 1
                      If i >= 2 Then Exit For
                  End If
              End If
            Next
            If i = 1 Then
              RecordError_Bookmark "Es ist nur eine Anmerkungsnummer vergeben", sem, , absatz.Range
            End If
       End If
       
       
       
       ' Pr|fffd|fen von Nur-Formulartext-Containern
       Dim tmp As String
       tmp = Replace(absatz.Style, " Anfang", "")
       If tmp = "Beweis" Or tmp = "Glaubhaftmachung" Or tmp = "Rechtsprechungszitat" Or tmp = "Variante" Then
        If Not CollectionContainsItem(colOpenSems, "Formulartext") Then
         RecordError_Bookmark tmp & " au|fffd|erhalb von Formulartext verwendet.", sem, , absatz.Range
        End If
       End If
              
       ' Pr|fffd|fen auf erlaubtes Format
       If InStr(strErlaubteFormate, strErlaubteFormateTrennz & absatz.Style & strErlaubteFormateTrennz) = 0 Then
        ' Pr|fffd|fen ob Tabellenzeile-Ende (wenn ja: ignorieren)
        If Not (absatz.Range.text = Chr(13) & Chr(7) And absatz.Style = ActiveDocument.styles(wdStyleNormal)) Then
           RecordError_Bookmark "Unerlaubtes Absatzformat: " & absatz.Style, sem, , absatz.Range
        End If
       End If
       
       letztesAbsatzFormat = absatz.Style
       
    Next
    
    ' Anmerkungsverweise pr|fffd|fen (wie beim Dokument schlie|fffd|en)
    AnmerkungsverweisePruefen True
    
    'Pr|fffd|fen auf wei|fffd|e Schriftfarbe
    Dim r2 As Range
    Set r2 = ActiveDocument.Range.Duplicate
    'On Error Resume Next
    With r2.Find
        .ClearFormatting
        .text = ""
        .font.Color = wdColorWhite
        .Replacement.ClearFormatting
        .Replacement.text = ""
        r2.Collapse
        .Execute Wrap:=wdFindStop, Replace:=wdReplaceAll
'        Do While .Execute(Wrap:=wdFindStop, Replace:=wdReplaceNone)
'            On Error Resume Next
'            r2.Font.Color = ActiveDocument.Styles(r2.Style).Font.Color
'            On Error GoTo 0
'            If r2.Font.Color = wdColorWhite Then
'                r2.Font.Color = wdColorAutomatic
'            End If
'            r2.Collapse wdCollapseEnd
'        Loop
    End With
    'On Error GoTo 0
    
    ' Noch offene Bl|fffd|cke melden
    Dim sOpenSem As Variant
    For Each sOpenSem In colSemLastOpen
        Dim sOpenSemTyp As String, openSemParaIdx As Double
        sOpenSemTyp = CStr(Left(sOpenSem, InStr(sOpenSem, "|") - 1))
        openSemParaIdx = Mid(sOpenSem, InStr(sOpenSem, "|") + 1)
        RecordError_Bookmark sOpenSemTyp & " wird nicht geschlossen.", sem, , ActiveDocument.Paragraphs(openSemParaIdx).Range
    Next
    
    'Pr|fffd|fen auf Tabelle in Tabelle
    Dim tbl As Table
    Dim tblCell As Cell
    Dim tblcount As Double
    tblcount = 1
    For Each tbl In ActiveDocument.Tables
        For Each tblCell In tbl.Range.Cells
            If tblCell.Tables.Count > 0 Then
                RecordError_Bookmark "Tabelle in Tabelle.", part, , tblCell.Range
            End If
        Next
    tblcount = tblcount + 1
    Next
    
    ' |fffd|berpr|fffd|fen nach unerlaubten Styles, die verwendet werden
    Dim docStyle As Style, cStyle As Long, styleId As Double
    For Each docStyle In ActiveDocument.styles
      Application.StatusBar = "Pr|fffd|fe auf unerlaubte Formate: " & cStyle & " von " & ActiveDocument.styles.Count
      cStyle = cStyle + 1
        If docStyle.InUse = True And docStyle.NameLocal <> "" And _
         docStyle.NameLocal <> ActiveDocument.styles(wdStyleDefaultParagraphFont).NameLocal And _
         docStyle.NameLocal <> ActiveDocument.styles(wdStyleFootnoteReference).NameLocal And _
         docStyle.NameLocal <> ActiveDocument.styles(wdStyleFootnoteText).NameLocal And _
         (docStyle.Type = wdStyleTypeCharacter Or docStyle.Type = wdStyleTypeParagraph) Then
            If InStr(strErlaubteFormate, strErlaubteFormateTrennz & docStyle.NameLocal & strErlaubteFormateTrennz) = 0 And _
             docStyle.Type = wdStyleTypeCharacter Then
                ' Nur Zeichenformate pr|fffd|fen, da Absatzformate bereits bei den jeweiligen Abs|fffd|tzen gepr|fffd|ft
                ' Und zudem es bei Word 2003 einen Wordbug im Zusammenhang mit Tabellenendmarkern gibt
                
                ' Ist schonmal nicht gut...suchen obs wirklich vorkommt
                Dim r As Range, fr As Range
                Set r = ActiveDocument.Range
                On Error Resume Next
                With r.Find
                    .text = ""
                    .Format = True
                    .Style = docStyle.NameLocal
                    If .Execute(Wrap:=wdFindContinue, Replace:=wdReplaceNone) = True Then
                         If .Style = ActiveDocument.styles(wdStyleNormal) And r.Paragraphs.Count > 1 Then
                            ' Workaround f|fffd|r Bug der z.B. in Word 2003 auftritt
                            ' (gefunden werden sollte eigentlich nur der Tabellenendmarker)
                         Else
                            r.Select
                            styleId = Selection.start
                            RecordError_Bookmark "Unerlaubtes Format " & docStyle.NameLocal & " wird im Flie|fffd|text verwendet.", sem, hintFormat, r
                         End If
                    End If
                End With
                
                If ActiveDocument.footnotes.Count > 0 Then
                   Set fr = ActiveDocument.StoryRanges(wdFootnotesStory)
                    With fr.Find
                        .text = ""
                        .Format = True
                        .Style = docStyle.NameLocal
                        If .Execute(Wrap:=wdFindContinue, Replace:=wdReplaceNone) = True Then
                            fr.Select
                            paraIdx = CDbl(Selection.start)
                            RecordError_Bookmark "Unerlaubtes Format " & docStyle.NameLocal & " wird im Fu|fffd|notentext verwendet.", sem, hintFormat, fr
                        End If
                    End With

                   If ActiveWindow.ActivePane.View.SplitSpecial = wdPaneFootnotes Then
                    ActiveWindow.ActivePane.Close
                   End If
                
                End If
            End If
        End If
    Next
    
    If Not autoCheck And Not hasMeta Then
        RecordError_Bookmark "Keine Metadaten angegeben.", sem, , ActiveDocument.Paragraphs.first.Range
    End If

    
    Dim anmF As Field
    Dim anmI As Integer
    Dim temp
    
    
    anmI = 1
    
    For Each anmF In ActiveDocument.Fields
        If Left(anmF.Code, 33) = "MACROBUTTON AnmerkungsnummerInfo " Then
            If InStr(1, anmF.Code, "-") Then
                temp = Split(Right(anmF.Code, Len(anmF.Code) - 33), "-")
                If anmI <> CInt(temp(0)) Then
                    anmF.Select
                    RecordError_Bookmark "Anmerkungsnummer " & Right(anmF.Code, Len(anmF.Code) - 33) & " gefunden. Erwartet: " & anmI & ". Bitte ggf. neu durchz|fffd|hlen lassen.", normal, , Selection.Paragraphs.first.Range
                End If
                anmI = anmI + 1 + CInt(temp(1)) - CInt(temp(0))
            ElseIf anmI <> CInt(Right(anmF.Code, Len(anmF.Code) - 33)) Then
                anmF.Select
                RecordError_Bookmark "Anmerkungsnummer " & Right(anmF.Code, Len(anmF.Code) - 33) & " gefunden. Erwartet: " & anmI & ". Bitte ggf. neu durchz|fffd|hlen lassen.", normal, , Selection.Paragraphs.first.Range
                anmI = anmI + 1
            Else
                anmI = anmI + 1
            End If
            
        End If
    Next anmF

    
    On Error GoTo 0
    Application.StatusBar = "Pr|fffd|fe auf doppelte Leerzeichen..."
    search_spaces " " & Chr$(9), True, errSpaceTab
    If Application.Language = msoLanguageIDGerman Then
        search_spaces "[ ]{2;}", True, errSpaceSpace, , True ' Automatisch ersetzen
    Else
        search_spaces "[ ]{2,}", True, errSpaceSpace, , True ' Automatisch ersetzen
    End If
    search_spaces " ^s", True, errSpaceNbsp
    search_spaces "^s" & Chr$(9), True, errNbspTab
    search_spaces Chr$(9) & "^s", True, errTabNbsp
    search_spaces Chr$(9) & " ", True, errTabSpace
    search_spaces "^s^s", True, errNbspNbsp
    search_spaces "^s ", True, errNbspSpace
    search_spaces Chr$(9) & Chr$(9), True, errTabTab
    
    'Pr|fffd|fen auf Leerzeichen + Interpunktion
    ' Deaktiviert wegen . . . . in Formulartexten (die in Konvertierung getauscht werden)
    'search_spaces " " & "[.;:\)\}\]\?\!,]", True, errSpacePunct
    'search_spaces "^s" & "[.;:\}\)\]\?\!,]", True, errSpacePunct
    
    If autoCheck Then Exit Sub
    
    Application.StatusBar = "Fehlerliste erstellen"

    ' Fehlerliste erstellen
    frmErrorlog.fehler = 0
    Dim f As Integer, strFehler$, j As Long
    j = 0
    For f = LBound(arrFehler) + 1 To UBound(arrFehler) ' Ersten auslassen weil der leer ist
        strFehler = arrFehler(f)
       
        If InStr(strFehler, strFehlerTrennz) > 0 Then
            strFehler = Left(strFehler, InStr(strFehler, strFehlerTrennz) - 1)
        End If
        If InStr(1, strFehler, "(Fehler)") Then
          frmErrorlog.lstLog.AddItem "(Fehler)"
          frmErrorlog.fehler = frmErrorlog.fehler + 1
          frmErrorlog.lstLog.List(j, 1) = Mid(strFehler, 9, Len(strFehler))
        Else
         frmErrorlog.lstLog.AddItem "(Hinweis)"
         frmErrorlog.lstLog.List(j, 1) = Mid(strFehler, 10, Len(strFehler))
         
        
       End If
        j = j + 1
    Next
    frmErrorlog.lstLog.ForeColor = wdYellow
    Set fehlerDoc = Application.ActiveDocument
    If UBound(arrFehler) > 0 Then
        frmErrorlog.Show False
        frmErrorlog.lblInfo.Caption = strHintHint
        frmErrorlog.lblInfo.Top = frmErrorlog.lstLog.Top + frmErrorlog.lstLog.Height + 5
        
        On Error Resume Next
        ActiveDocument.Variables("errorLog").Delete
        ActiveDocument.Variables("errorLevel").Delete
        On Error GoTo 0
            
        Dim strVarErrorLog$, strVarFoundErrors$
        strVarErrorLog = ""
        strVarFoundErrors = strFehlerTrennz
        ' Errorlog in den Dokumentvariablen ablegen
        For f = LBound(arrFehler) + 1 To UBound(arrFehler) ' Ersten auslassen weil der leer ist
            strFehler = arrFehler(f)
            If InStr(strFehler, strFehlerTrennz) > 0 Then
                strFehler = Left(strFehler, InStr(strFehler, strFehlerTrennz) - 1)
            End If
            If InStr(strFehler, strHintTrennz) > 0 Then
                strFehler = Left(strFehler, InStr(strFehler, strHintTrennz) - 1)
            End If
            ' Nur aufzeichnen wenn noch nicht aufgezeichnet
            If InStr(strVarFoundErrors, strFehlerTrennz & strFehler & strFehlerTrennz) = 0 Then
                If strVarErrorLog <> "" Then
                    strVarErrorLog = strVarErrorLog & vbNewLine
                End If
                strVarErrorLog = strVarErrorLog & strFehler
                strVarFoundErrors = strVarFoundErrors & strFehler & strFehlerTrennz
            End If
        Next
        Dim errorLevel As Integer
        errorLevel = 1
        Dim intSemInstr As Integer, intPartInstr As Integer
        intSemInstr = InStr(strErrorTypes, strFehlerTrennz & errTypes.sem & strFehlerTrennz)
        intPartInstr = InStr(strErrorTypes, strFehlerTrennz & errTypes.part & strFehlerTrennz)
        If intSemInstr > 0 And intPartInstr > 0 Then
            errorLevel = -3
        ElseIf intSemInstr > 0 Then
            errorLevel = -2
        ElseIf intPartInstr > 0 Then
            errorLevel = -1
        End If
        ActiveDocument.Variables.Add "errorLog", strVarErrorLog
        ActiveDocument.Variables.Add "errorLevel", errorLevel
    ElseIf blFromSaveEvent = False Then
        MsgBox "Es wurden keine Fehler gefunden", vbInformation
        
        On Error Resume Next
        ActiveDocument.Variables("errorLevel").Delete
        ActiveDocument.Variables("errorLog").Delete
        ActiveDocument.Variables.Add "errorLevel", 0
        On Error GoTo 0
    End If
    System.Cursor = wdCursorNormal
    Application.StatusBar = "Fertig"
    
    'rangeBeforeDok.Select 'Cursorposition vor Dokpr|fffd|fer wiederherstellen
End Sub

Public Sub RecordError_Bookmark(ByVal strErr$, Optional errType As errTypes = 0, Optional ByVal strHint$ = "", Optional r As Range = Nothing)
    Dim strErrC As String

    If errType = warning Or errType = normal Then
        strErr = "(Hinweis) " & strErr
    ElseIf errType = part Or errType = sem Then
        strErr = "(Fehler) " & strErr
    End If
    
    strErrC = strErr
    
    strErrorTypes = strErrorTypes & strFehlerTrennz & errType & strFehlerTrennz
    
    Dim bmName As String, i As Integer
    i = 1
    Do While i < 10000
        bmName = "dokprErr" & i
        If Not ActiveDocument.Bookmarks.Exists(bmName) Then Exit Do
        i = i + 1
    Loop
    If i > 9900 Then
        err.Raise vbObjectError + 999, , "Zu viele Fehler"
    End If
    ActiveDocument.Bookmarks.Add bmName, r
    strErr = strErr & strFehlerTrennz & "b" & bmName
    
    If autoCheck Then
        Dim ErrElm As MSXML2.IXMLDOMElement
        Set ErrElm = xmlLog.createElement("err")
        ErrElm.setAttribute "bm", bmName
        ErrElm.text = strErrC
        xmlLog.documentElement.appendChild ErrElm
        Exit Sub
    End If
    
    If strHint <> "" Then
        strHint = Replace(strHint, "'''", Chr(34))
        strErr = strErr & strHintTrennz & strHint
    End If
    ReDim Preserve arrFehler(UBound(arrFehler) + 1)
    arrFehler(UBound(arrFehler)) = strErr
End Sub

Sub RemoveDokprBookmarks()
    Dim bm As Bookmark
    For Each bm In ActiveDocument.Bookmarks
        If bm.Name Like "dokprErr*" Then
            bm.Delete
        End If
    Next
End Sub

Sub set_dokpr_flag()
    Dim dokvar As Variable
    Dim vorfound As Boolean
    Dim vorcounter As String, pos1 As Long
    Dim DotVersion As String
    
    If ActiveDocument.Variables.Count > 0 Then
        dversion.get_version DotVersion
        For Each dokvar In ActiveDocument.Variables
          If dokvar.Name = "DokPr" Then
           vorfound = True
           pos1 = InStr(1, dokvar.Value, "x")
           vorcounter = Left(dokvar.Value, pos1 - 1)
           vorcounter = vorcounter + 1 & "x (gelaufen mit Version " & DotVersion & ") " & CStr(Date) & " " & CStr(Time)
           dokvar.Value = vorcounter
          End If
          
        Next dokvar
    End If
    If vorfound = False Then
        dversion.get_version DotVersion
        ActiveDocument.Variables.Add "DokPr", 1 & "x (gelaufen mit Version " & DotVersion & ") " & CStr(Date) & " " & CStr(Time)
        vorfound = True
    End If
End Sub

Sub search_spaces(strfind As String, blWildcard As Boolean, ausgabe As String, Optional hint As String, Optional bErsetzen As Boolean = False)
    Dim r As Range
    Set r = ActiveDocument.Range.Duplicate
    r.Collapse
    With r.Find
         .ClearFormatting
         .Replacement.text = IIf(bErsetzen, " ", "")
         .Replacement.ClearFormatting
         .Format = False
         .text = strfind
         .MatchWildcards = blWildcard
         .Wrap = wdFindStop
         If bErsetzen Then
            While .Execute(Replace:=wdReplaceAll)
                Set r = ActiveDocument.Range.Duplicate
                r.Collapse
            Wend
         Else
            While .Execute(Replace:=wdReplaceNone) = True
                RecordError_Bookmark ausgabe & errSpaces, warning, hint, r
                r.Collapse wdCollapseEnd
            Wend
        End If
         
    End With
     
    ' Fu|fffd|noten sind nicht erlaubt
'
'    If ActiveDocument.Footnotes.Count > 0 Then
'        Set r = ActiveDocument.Footnotes(1).Range
'        'r.Select
'        r.WholeStory
'        'r.Expand Unit:=wdStory
'        ' r.Select
'
'        With r.Find
'            .ClearFormatting
'            .Replacement.text = ""
'            .Replacement.ClearFormatting
'            .Format = False
'            .text = strfind
'            .MatchWildcards = blWildcard
'            .Wrap = wdFindStop
'            While .Execute(Replace:=wdReplaceNone) = True
'                r.Select
'                RecordError_Bookmark ausgabe & errInvalidFormatFn, warning, hint, r
'                Selection.Collapse wdCollapseEnd
'            Wend
'        End With
'    End If
End Sub
Attribute VB_Name = "modDokpruefer_Formate"
Public strErlaubteFormate$, strErlaubteFormateTrennz$
Public headerArray(15) As String
Public listArray() As String
Public warningp1 As String
Public warningp2 As String
Public warningp3 As String
'Public warningp4 As String


Sub IniErlaubteFormate()

    warningp1 = "!!! Wichtiger Hinweis !!!"
    warningp2 = "Ihr Dokument enth|fffd|lt noch Strukturfehler oder ung|fffd|ltige Formatierungen. Um genauere Informationen zu erhalten, f|fffd|hren Sie die |fffd|Dokument pr|fffd|fen|fffd|-Funktion aus, die Sie in der Symbolleiste |fffd|Beck Formularbuch|fffd| aufrufen k|fffd|nnen."
    warningp3 = "Enth|fffd|lt Ihr Dokument Strukturfehler (etwa Fehlen von Gliederungsebenen, Verwendung falscher Gliederungsebenen), k|fffd|nnte eventuell eine redaktionelle |fffd|berarbeitung sinnvoll sein. Durch eine fehlerfreie Gliederungsstruktur k|fffd|nnen Zeit und Kosten beim automatisierten Satz gespart werden. "
    'warningp4 = Now



    strErlaubteFormateTrennz = "|*|"
    'Vorlage strErlaubteFormate = strErlaubteFormate & "|*|"
    strErlaubteFormate = ""
    strErlaubteFormate = "|*|"
    strErlaubteFormate = strErlaubteFormate & "Absatz|*|Absatz_Abstand|*|Beweis|*|"
    strErlaubteFormate = strErlaubteFormate & "Container Titel|*|Container Untertitel|*|Metadaten|*|Metadaten_Hinweis|*|"
    strErlaubteFormate = strErlaubteFormate & "Listeneinzug 1. Ebene|*|Listeneinzug 2. Ebene|*|Listeneinzug 3. Ebene|*|Listeneinzug 4. Ebene|*|Listeneinzug 5. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste Kasten leer 1. Ebene|*|Liste Kasten leer 2. Ebene|*|Liste Kasten leer 3. Ebene|*|Liste Kasten leer 4. Ebene|*|Liste Kasten leer 5. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste Kasten voll 1. Ebene|*|Liste Kasten voll 2. Ebene|*|Liste Kasten voll 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste Punkt 1. Ebene|*|Liste Punkt 2. Ebene|*|Liste Punkt 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste Strich 1. Ebene|*|Liste Strich 2. Ebene|*|Liste Strich 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste I gro|fffd| 1. Ebene|*|Liste I gro|fffd| 2. Ebene|*|Liste I gro|fffd| 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste (aa) 1. Ebene|*|Liste (aa) 2. Ebene|*|Liste (aa) 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste (a) 1. Ebene|*|Liste (a) 2. Ebene|*|Liste (a) 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste (Num) 1. Ebene|*|Liste (Num) 2. Ebene|*|Liste (Num) 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste aa 1. Ebene|*|Liste aa 2. Ebene|*|Liste aa 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste a klein 1. Ebene|*|Liste a klein 2. Ebene|*|Liste a klein 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Liste Num 1. Ebene|*|Liste Num 2. Ebene|*|Liste Num 3. Ebene|*|"
    strErlaubteFormate = strErlaubteFormate & "Haupt|fffd|berschrift|*|Zwischen|fffd|berschrift 1|*|Zwischen|fffd|berschrift 2|*|Zwischen|fffd|berschrift 3|*|Zwischen|fffd|berschrift 4|*|Zwischen|fffd|berschrift 5|*|"
    strErlaubteFormate = strErlaubteFormate & "Vorwort Autor|*|Bildunterschrift|*|Anmerkungsnummer|*|Anmerkungsverweis|*|"
    strErlaubteFormate = strErlaubteFormate & "Vorbemerkungsverweis|*|Formularverweis|*|Abschnittsverweis|*|"
    
    ' Blockformate
    Dim arrSemTypes() As Variant, colSems As New Collection, item As Variant
    FillSems arrSemTypes, colSems
    For Each item In arrSemTypes
        If CStr(item) <> "" Then
            strErlaubteFormate = strErlaubteFormate & CStr(item) & " Anfang|*|"
            strErlaubteFormate = strErlaubteFormate & CStr(item) & " Ende|*|"
        End If
    Next
    
    ' Eingebaute Styles (Standard/Normal ist bewusst nicht erlaubt)
    strErlaubteFormate = strErlaubteFormate & ActiveDocument.styles(wdStyleHeading1).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading2).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading3).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading4).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading5).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading6).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading7).NameLocal & strErlaubteFormateTrennz
'    strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading8).NameLocal & strErlaubteFormateTrennz
    'strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleHeading9).NameLocal & strErlaubteFormateTrennz
    strErlaubteFormate = strErlaubteFormate & ActiveDocument.styles(wdStyleNormal) & strErlaubteFormateTrennz
    strErlaubteFormate = strErlaubteFormate & ActiveDocument.styles(wdStyleDefaultParagraphFont) & strErlaubteFormateTrennz
    strErlaubteFormate = strErlaubteFormate & ActiveDocument.styles(wdStyleCommentReference) & strErlaubteFormateTrennz
    'strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleFootnoteReference) & strErlaubteFormateTrennz
    'strErlaubteFormate = strErlaubteFormate & ActiveDocument.Styles(wdStyleFootnoteText) & strErlaubteFormateTrennz
    strErlaubteFormate = strErlaubteFormate & ActiveDocument.styles(wdStyleHyperlink) & strErlaubteFormateTrennz
    strErlaubteFormate = strErlaubteFormate & ActiveDocument.styles(wdStyleHyperlinkFollowed) & strErlaubteFormateTrennz
    
    'Absatzformate f|fffd|r |fffd|berschriften
    headerArray(0) = "Container Titel"
    headerArray(1) = "Container Untertitel"
    headerArray(2) = ActiveDocument.styles(wdStyleHeading1).NameLocal  ' "|fffd|berschrift 1"
'    headerArray(3) = ActiveDocument.Styles(wdStyleHeading2).NameLocal '"|fffd|berschrift 2"
'    headerArray(4) = ActiveDocument.Styles(wdStyleHeading3).NameLocal '"|fffd|berschrift 3"
'    headerArray(5) = ActiveDocument.Styles(wdStyleHeading4).NameLocal ' "|fffd|berschrift 4"
'    headerArray(6) = ActiveDocument.Styles(wdStyleHeading5).NameLocal '"|fffd|berschrift 5"
'    headerArray(7) = ActiveDocument.Styles(wdStyleHeading6).NameLocal '"|fffd|berschrift 6"
'    headerArray(8) = ActiveDocument.Styles(wdStyleHeading7).NameLocal '"|fffd|berschrift 7"
'    headerArray(9) = ActiveDocument.Styles(wdStyleHeading8).NameLocal '"|fffd|berschrift 8"
    'headerArray(10) = ActiveDocument.Styles(wdStyleHeading9).NameLocal '"|fffd|berschrift 9"
    headerArray(3) = "Haupt|fffd|berschrift"
    headerArray(4) = "Zwischen|fffd|berschrift 1"
    headerArray(5) = "Zwischen|fffd|berschrift 2"
    headerArray(6) = "Zwischen|fffd|berschrift 3"
    headerArray(13) = "Zwischen|fffd|berschrift 4"
    headerArray(14) = "Zwischen|fffd|berschrift 5"
    
    'Absatzformate f|fffd|r Listen
    Dim st As Style, iList As Integer
    iList = 0
    For Each st In ActiveDocument.styles
        If st.Type = wdStyleTypeParagraph Then
            If GetListName(st.NameLocal) <> "" Or st.NameLocal Like "Listeneinzug #. Ebene" Then
                If InStr(strErlaubteFormate, strErlaubteFormateTrennz & st.NameLocal & strErlaubteFormateTrennz) Then
                    ReDim Preserve listArray(iList)
                    listArray(iList) = st.NameLocal
                    iList = iList + 1
                End If
            End If
        End If
    Next
End Sub

Sub BuildErlaubteFormate()
    Dim str As String, s As Style, i As Integer
    IniErlaubteFormate
    str = "strErlaubteFormate = " & Chr(34) & strErlaubteFormateTrennz
    For Each s In ActiveDocument.styles
        If Not s.BuiltIn Then
            i = i + 1
            If i Mod 16 = 0 Then
                str = str & vbNewLine & Chr(9) & "strErlaubteFormate = strErlaubteFormate & " & Chr(34)
            ElseIf i Mod 4 = 0 Then
                str = str & Chr(34) & " & _" & vbNewLine & Chr(9) & "  " & Chr(34)
            End If
            str = str & s.NameLocal & strErlaubteFormateTrennz
        End If
    Next
    str = str & Chr(34)
    Dim oData As New DataObject
    With oData
        .SetText str
        .PutInClipboard
    End With
    ' Nicht zur ungepr|fffd|ften Verwendung!
    

End Sub

Attribute VB_Name = "modForms"
Option Explicit

Global AenderungsmodusAktiv As Boolean

Public FormAnmLinkBereich As Range, DocTypDefault As Variant, DocTyps As Variant
Private Const AnmerkungsnrButton = "AnmerkungsnummerInfo" ' Nicht |fffd|ndern!
Public Const FormularBlockName = "Formulartext"

Public Const FormCtl_ColorWrong As Long = &H80C0FF
Public Const FormCtl_ColorNormal As Long = &H80FFFF ' &H80000005

'Public Const FormzifferRegex As String = "([A-Z]\.|[IVX]{1,7}\.|[0-9]+\.|[0-9]+\.[0-9]+|[a-z]\))" ' Vorsicht bei Anpassung sollten auch die Beispiele
'Public Const FormzifferRegexH As String = "(Teil [0-9]+|[A-Z]\.|[IVX]{1,7}\.|[0-9]+\.|[0-9]+\.[0-9]+|[a-z]\))" ' Vorsicht bei Anpassung sollten auch die Beispiele
Public Const FormzifferRegex As String = "([A-Z]\.|[IVX]{1,7}\.|[0-9]+\.|[a-z]\))"
Public Const FormzifferRegexH As String = FormzifferRegex
' in den Formularen die diese Variable abfragen angepasst werden; Vorsicht frmFormLink verwendet eigene Regex
Private komplettLoeschen As Boolean



Public Sub InitVariables()
    DocTypDefault = "Formular"
    DocTyps = Array("Formular", "Checkliste", "Vorbemerkung") ', "BeckOF"
End Sub

' ********** CONTAINER **********

' Siehe modContainer

' ********** METADATEN **********

Sub FormMetadaten()
    ' Formularanfang suchen
'    Dim p As Paragraph, i As Integer, pForm As Paragraph, p2 As Paragraph
'    Set pForm = BlockAnfang_Finden(FormularBlockName, Selection.Paragraphs.First, True)
'    Set p2 = BlockAnfang_Finden("Checkliste", Selection.Paragraphs.First, True)
'    If Not (p2 Is Nothing) And Not (pForm Is Nothing) Then
'        Set pForm = Nothing
'    ElseIf pForm Is Nothing And Not p2 Is Nothing Then
'        Set pForm = p2
'    End If
'    If pForm Is Nothing Then
'        MsgBox "Dies ist nur innerhalb eines " & FormularBlockName & "- bzw. Checkliste-Containers m|fffd|glich.", vbExclamation
'        GoTo fertig
'    End If
'    pForm.Range.Select
'    Selection.Collapse
    
    
     ActiveDocument.Paragraphs.first.Range.Select
     Do While Selection.Paragraphs.first.Style = "DPWarnungstext"
      Selection.Paragraphs.first.Next.Range.Select
     Loop
     
       Selection.Collapse
      newdoc = False
    
    ' Dialog anzeigen
    ShowFormMeta
'fertig:
'    Set p = Selection.Paragraphs.First
'    If p.style = FormularBlockName & " Anfang" Or p.style = "Checkliste Anfang" Or p.style = "Metadaten" Then
'        Selection.MoveDown wdParagraph, 1
'    End If
End Sub

Sub FormVerweis()

    If (Selection.Range.Revisions.Count > 0) Then
        If Selection.Range.Revisions(1).Type = wdRevisionDelete Then Exit Sub
    End If

  Load frmFormLink
  frmFormLink.Show
End Sub

Private Function Block_Finden(sTyp As String) As Paragraph
    
    Dim p As Paragraph
    Set p = ActiveDocument.Paragraphs.first
    
    Do While Not p Is Nothing
        If p.Style = sTyp Then
            ' Container-Anfang
            Set Block_Finden = p
            Exit Function
        End If
        Set p = p.Next
    Loop
    
    ' Nicht gefunden
    Set Block_Finden = Nothing
End Function

' ********** ANMERKUNGEN **********

Sub Anmerkungsverweis()
    ' Struktur pr|fffd|fen
    Dim smc As Boolean
    smc = Options.SmartCutPaste
    Options.SmartCutPaste = False
    
'    If Selection.Paragraphs.first.Style = "Haupt|fffd|berschrift" Or _
'    StartsWith(Selection.Paragraphs.first.Style, "Zwischen|fffd|berschrift") Then
'        MsgBox "In |fffd|berschriften kann keine Anmerkungsnummern eingef|fffd|gt werden.", vbExclamation
'        Exit Sub
'    End If
    
    On Error GoTo fehler
    
    
    Selection.Collapse
    'If Selection.style = "Haupt|fffd|berschrift" Or Selection.style = "Zwischen|fffd|berschrift 1" Or Selection.style = "Zwischen|fffd|berschrift 3" Or Selection.style = "Zwischen|fffd|berschrift 3" Then
    'SelectionInSpecialArea = True
    
    'End If
    
    Dim pFormularStart As Paragraph, pFormularEnde As Paragraph, _
     pAnmerkungenStart As Paragraph, pAnmerkungenEnde As Paragraph, _
     rAnmerkungen As Range, tmp As String, r As Range, p As Paragraph
    Set rAnmerkungen = Nothing
    
'    ' Formular suchen
'    Set pFormularStart = Block_Finden(FormularBlockName, Selection.Paragraphs.First)
'    Set p = Block_Finden("Checkliste", Selection.Paragraphs.First)
'    If pFormularStart Is Nothing And Not p Is Nothing Then
'        ' Checkliste = Formular
'        Set pFormularStart = p
'        Set p = Nothing
'    End If
'    If p Is Nothing And Not pFormularStart Is Nothing Then
'        ' Formular (oder Checkliste) gefunden; Ende suchen
'        Set pFormularEnde = BlockEnde_Finden(Replace(pFormularStart.style, " Anfang", ""), Selection.Paragraphs.First)
'    End If
'    If Not (pFormularStart Is Nothing) And Not (pFormularEnde Is Nothing) Then
'        ' Formular ist vollst|fffd|ndig -> Anmerkung suchen und dabei Struktur pr|fffd|fen
'        ' Mehrere Anmerkungen sind nicht erlaubt
'        Set r = pFormularStart.Range.Duplicate
'        r.End = pFormularEnde.Range.End
'        tmp = ""
'        For Each p In r.Paragraphs
'            ' Anmerkungen
'            If p.style = "Anmerkungen Anfang" Then
'                If tmp = "" And pAnmerkungenEnde Is Nothing And pAnmerkungenStart Is Nothing Then
'                    Set pAnmerkungenStart = p
'                    tmp = "Anmerkungen"
'                Else
'                    Exit For
'                End If
'            ElseIf p.style = "Anmerkungen Ende" Then
'                If tmp = "Anmerkungen" And pAnmerkungenEnde Is Nothing And Not pAnmerkungenStart Is Nothing Then
'                    Set pAnmerkungenEnde = p
'                    tmp = ""
'                Else
'                    Exit For
'                End If
'            End If
'        Next
        
        
        Set pAnmerkungenStart = Block_Finden("Anmerkungen Anfang")
        Set pAnmerkungenEnde = Block_Finden("Anmerkungen Ende")
        ' Strukturpr|fffd|fung erfolgreich?
        If tmp = "" And Not (pAnmerkungenStart Is Nothing) And Not (pAnmerkungenEnde Is Nothing) Then
            ' rAnmerkungen wird gesetzt, damit ist die Strukturpr|fffd|fung abgeschlossen
            Set rAnmerkungen = pAnmerkungenStart.Range.Duplicate
            rAnmerkungen.End = pAnmerkungenEnde.Range.End
        End If

    
    ' Strukturpr|fffd|fung erfolgreich?
    If rAnmerkungen Is Nothing Then
        MsgBox "Es kann noch kein Anmerkungsverweis eingef|fffd|gt werden da noch keine Anmerkungen vorhanden sind.", vbExclamation
        Exit Sub
    End If
    If BlockAnfang_Finden("Formulartext", Selection.Paragraphs.first) Is Nothing And BlockAnfang_Finden("Checkliste", Selection.Paragraphs.first) Is Nothing Then
        If MsgBox("Anmerkungslinks werden normalerweise nur im Formulartext oder in Checklisten eingef|fffd|gt.", vbInformation Or vbOKCancel) <> vbOK Then
            Exit Sub
        End If
   End If
    
    
    Dim sr As Range
    Set sr = Selection.Range.Duplicate
    
    Dim f As Field
    Dim temp
    Dim sNumAlt As String
    Dim i As Integer
    For Each f In ActiveDocument.Fields
        If InStr(f.Code.text, "MACROBUTTON " & AnmerkungsnrButton) Then
            sNumAlt = Trim(Mid(f.Code.text, InStr(f.Code.text, AnmerkungsnrButton) + Len(AnmerkungsnrButton)))
            
            f.Select
            If (Selection.Range.Revisions.Count > 0) Then
                If Selection.Range.Revisions(1).Type = wdRevisionDelete Then
                    Selection.Collapse
                    GoTo NF
                End If
            End If
            
            If InStr(1, sNumAlt, "-") Then
                temp = Split(sNumAlt, "-")
'Fehlenden BM f|fffd|r bereiche nachtragen
                Selection.MoveLeft
                On Error GoTo bm_nachtrage_ende
                For i = (temp(0)) To temp(1)
                    ActiveDocument.Bookmarks.Add "AnmNr_A1_" & i, Selection.Range
                Next i
bm_nachtrage_ende:
                On Error GoTo 0
            End If
        End If
NF:
    sr.Select
    Next f
    
    
    
    ' Fenster |fffd|ffnen
    Set FormAnmLinkBereich = rAnmerkungen.Duplicate
    Load frmAnmerkungsLink
    frmAnmerkungsLink.Show 1
fertig:
    Set FormAnmLinkBereich = Nothing
    Options.SmartCutPaste = smc
    Exit Sub
fehler:
    MsgBox "Es ist ein Fehler aufgetreten: " & err.Description, vbCritical
    GoTo fertig
End Sub

Sub AnmerkungsnummerInfo()
    ' Dieser Makroname wird f|fffd|r die Konvertierung verwendet; beim Anklicken einer Anmerkungsnummer
    ' wird dieses Makro zwecks L|fffd|schen der Anmerkungsnummer aufgerufen
    Dim smc As Boolean
    smc = Options.SmartCutPaste
    Options.SmartCutPaste = False
    
    AenderungsmodusAktiv = ActiveDocument.TrackRevisions
    ActiveDocument.TrackRevisions = False
    
    On Error GoTo fehler
    
    Dim f As Field, fGeloescht As Field, num As String, r As Range
    Dim ende As Integer
    Dim temp
    Set fGeloescht = Nothing
    Dim sr As Range
    
    
    Set sr = Selection.Range.Duplicate
    komplettLoeschen = False
    
    For Each f In Selection.Paragraphs.first.Range.Fields
       If InStr(f.Code.text, "MACROBUTTON " & AnmerkungsnrButton) Then
           f.Select
            If (Selection.Range.Revisions.Count > 0) Then
               If Selection.Range.Revisions(1).Type = wdRevisionDelete Then
                   komplettLoeschen = True
               End If
           End If
        End If
    Next
    
    sr.Select
    
    For Each f In Selection.Fields
        If InStr(f.Code.text, "MACROBUTTON " & AnmerkungsnrButton) Then
            f.Select
            
             If (Selection.Range.Revisions.Count > 0) Then
                If Selection.Range.Revisions(1).Type = wdRevisionDelete Then
                    Selection.Collapse
                    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
                    Exit Sub
                End If
            End If
            
            f.ShowCodes = False
            If MsgBox("Anmerkungsnummer l|fffd|schen? Achtung es werden auch alle Links darauf gel|fffd|scht.", vbYesNo Or vbQuestion) = vbNo Then
                ActiveDocument.TrackRevisions = AenderungsmodusAktiv
                Exit Sub
            End If
            
            num = Trim(Mid(f.Code.text, InStr(f.Code.text, AnmerkungsnrButton) + Len(AnmerkungsnrButton)))
            
            f.Delete
            
            ActiveDocument.TrackRevisions = AenderungsmodusAktiv
            Set r = Selection.Range.Duplicate
            r.MoveEnd
            If r.Style = "Anmerkungsnummer" And r.text = "." Then
                r.MoveEndWhile " |fffd|"
                r.Delete
            End If
            ActiveDocument.TrackRevisions = False
            
            ' Feld f|fffd|r Neunummerierung
            Set fGeloescht = Selection.Fields.Add(Selection.Range, wdFieldMacroButton, Trim(AnmerkungsnrButton & " GELOESCHT " & num), False)
            fGeloescht.Code.text = Trim(fGeloescht.Code.text)
            fGeloescht.ShowCodes = False
            
            ActiveDocument.TrackRevisions = AenderungsmodusAktiv
            Selection.MoveRight
            If Selection.Style = "Anmerkungsnummer" And Selection.text = "." Then
                Selection.MoveEndWhile " |fffd|"
                Selection.Delete
            End If
            ActiveDocument.TrackRevisions = False
            Exit For
        End If
    Next
    If fGeloescht Is Nothing Then Exit Sub
    
    ' Anmerkungs-Block suchen
    Dim pAnmerkungStart As Paragraph, pAnmerkungEnde As Paragraph
    Set pAnmerkungStart = BlockAnfang_Finden("Anmerkungen", Selection.Paragraphs.first)
    Set pAnmerkungEnde = BlockEnde_Finden("Anmerkungen", Selection.Paragraphs.first)
    If BlockAnfang_Finden("Formulartext", Selection.Paragraphs.first) Is Nothing And _
     Not (pAnmerkungStart Is Nothing) And Not (pAnmerkungEnde Is Nothing) Then
        AnmerkungsnrDurchzaehlen pAnmerkungStart, pAnmerkungEnde
    Else
        MsgBox "Die gel|fffd|schte Anmerkungsnummer war nicht in einem g|fffd|ltigen Anmerkungs-Container enthalten. Daher k|fffd|nnen die Anmerkungsnummern und Links nicht aktualisiert werden.", vbExclamation
        ActiveDocument.TrackRevisions = AenderungsmodusAktiv
        Exit Sub
    End If
fertig:
    Options.SmartCutPaste = smc
    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
    Exit Sub
fehler:
    MsgBox "Es ist ein Fehler aufgetreten: " & err.Description, vbCritical
    GoTo fertig
End Sub

Sub AnmerkungLoeschen()
    ' Zum manuellen Aufrufen
    Dim f As Field
    
   
    For Each f In Selection.Paragraphs.first.Range.Fields
        If InStr(f.Code.text, "MACROBUTTON " & AnmerkungsnrButton) Then
            f.Select
            AnmerkungsnummerInfo
            Exit Sub
        End If
    Next
    MsgBox "In diesem Absatz gibt es keine Anmerkungsnummer. Bitte stellen Sie den Cursor in den Absatz mit der zu l|fffd|schenden Anmerkungsnummer.", vbExclamation
End Sub

Sub AnmerkungEinfuegen(Optional anzahl As Integer = 1)
    ' Wird auch vom automatischem CE Makro aufgerufen
    Dim smc As Boolean
    smc = Options.SmartCutPaste
    Options.SmartCutPaste = False
    
    
    On Error GoTo fehler
    
    ' Pr|fffd|fen ob erlaubt
    If SelectionInSpecialArea Then
        MsgBox "An dieser Stelle kann keine Anmerkungsnummer eingef|fffd|gt werden.", vbExclamation
        Exit Sub
    End If
    If Not BlockAnfang_Finden("Formulartext", Selection.Paragraphs.first) Is Nothing Then
        MsgBox "Im Formulartext d|fffd|rfen keine Anmerkungsnummern vergeben werden. Es sind nur Links auf Anmerkungsnummern erlaubt.", vbExclamation
        Exit Sub
    End If
    Dim pAnmerkungStart As Paragraph, pAnmerkungEnde As Paragraph
    Set pAnmerkungStart = BlockAnfang_Finden("Anmerkungen", Selection.Paragraphs.first)
    If pAnmerkungStart Is Nothing Then
        MsgBox "Anmerkungsnummern k|fffd|nnen nur in Anmerkungs-Containern eingef|fffd|gt werden.", vbExclamation
        Exit Sub
    End If
    Set pAnmerkungEnde = BlockEnde_Finden("Anmerkungen", Selection.Paragraphs.first)
    If pAnmerkungEnde Is Nothing Then
        MsgBox "Der Anmerkungs-Container wird nicht geschlossen.", vbExclamation
        Exit Sub
    End If
    
    ' Absatz ausw|fffd|hlen, pr|fffd|fen ob es schon eine Anmerkungsnummer gibt
    Dim f As Field
    Selection.Paragraphs.first.Range.Select
    For Each f In Selection.Fields
        If InStr(f.Code.text, "MACROBUTTON " & AnmerkungsnrButton) Then
            f.Select
            If Selection.Range.Revisions.Count > 0 Then
                If Selection.Range.Revisions(1).Type = wdRevisionDelete Then
                Exit For
                End If
            End If
            MsgBox "In diesem Absatz gibt es schon eine Anmerkungsnummer.", vbExclamation
            Exit Sub
        End If
    Next
    Selection.Collapse
    
    
    AenderungsmodusAktiv = ActiveDocument.TrackRevisions
    ActiveDocument.TrackRevisions = False

    
    ' Anmerkungsnummer einf|fffd|gen und danach neu durchz|fffd|hlen
    With Selection.Fields.Add(Selection.Range, wdFieldMacroButton, AnmerkungsnrButton & " NEU" & anzahl, False)
        .ShowCodes = False
        .Code.text = Trim(.Code.text)
        .Select
        
        ActiveDocument.TrackRevisions = AenderungsmodusAktiv
        Selection.Style = "Anmerkungsnummer"
        Selection.Collapse wdCollapseEnd
        Selection.TypeText "."
        Selection.MoveEnd
        If Selection.text <> " " Then
            Selection.Collapse
            Selection.TypeText " "
            Selection.MoveStart , -1
        End If
        Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
        Selection.Collapse wdCollapseEnd
        EnsureResetStyle
        
        ActiveDocument.TrackRevisions = False
    End With
    AnmerkungsnrDurchzaehlen pAnmerkungStart, pAnmerkungEnde
    
fertig:
    Options.SmartCutPaste = smc
    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
    Exit Sub
fehler:
    MsgBox "Es ist ein Fehler aufgetreten: " & err.Description, vbCritical
    GoTo fertig
End Sub



Sub AnmerkungEinfuegenBereich()
    Dim anzahl
    
    anzahl = InputBox("Wieviele Anmerkungsnummern soll der Bereich umfassen?", "Anmerkungsnummernbereich einf|fffd|gen", "1")
    If (IsNumeric(anzahl)) Then
        If anzahl > 0 Then
            AnmerkungEinfuegen CInt(anzahl)
        End If
    End If
End Sub

Sub AnmerkungNeuZaehlen()
    Dim smc As Boolean
    Dim pAnmerkungStart As Paragraph, pAnmerkungEnde As Paragraph
    
    smc = Options.SmartCutPaste
    Options.SmartCutPaste = False
    On Error GoTo fehler
    
    
    
    Set pAnmerkungStart = Block_Finden("Anmerkungen Anfang")
    If pAnmerkungStart Is Nothing Then
        Exit Sub
    End If
    
    Set pAnmerkungEnde = BlockEnde_Finden("Anmerkungen", pAnmerkungStart.Next)
    If pAnmerkungEnde Is Nothing Then
        Exit Sub
    End If
    
    AenderungsmodusAktiv = ActiveDocument.TrackRevisions
    ActiveDocument.TrackRevisions = False

    
    AnmerkungsnrDurchzaehlen pAnmerkungStart, pAnmerkungEnde
    
fertig:
    Options.SmartCutPaste = smc
    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
    Exit Sub
fehler:
    MsgBox "Es ist ein Fehler aufgetreten: " & err.Description, vbCritical
    GoTo fertig
End Sub

Sub AnmerkungsnrDurchzaehlen(pAnmerkungStart As Paragraph, pAnmerkungEnde As Paragraph)
    ' Anmerkungsblock markieren
    
    Dim rGemerkt As Range, sNumAlt As String, iNumNeu As Integer, colAltNeu As Collection, _
     rAnmerkung As Range, colBmAlt As Collection, sPraefix As String
     
    Dim f As Field, r As Range, i As Integer, tmp As String, p As Paragraph, bm As Bookmark, _
     h As Hyperlink
    
    Dim ende As Integer
    Dim temp
    
    Dim hasRevision As Boolean
    
    Set rGemerkt = Selection.Range.Duplicate
    pAnmerkungStart.Range.Select
    Selection.End = pAnmerkungEnde.Range.End - 1
    Set rAnmerkung = Selection.Range.Duplicate
    Selection.Collapse
    
    ' Alle AnmNr-Textmarken in Anmerkungsblock weg
    Set colBmAlt = New Collection
    For Each bm In rAnmerkung.Bookmarks
        If bm.Range.InRange(rAnmerkung) And StartsWith(bm.Name, "AnmNr") Then
            colBmAlt.Add bm.Name, bm.Name
            bm.Delete
        End If
    Next
    
    ' Textmarke in Blockanfang suchen
    sPraefix = "AnmPraefix-A0"
    For Each bm In pAnmerkungStart.Range.Bookmarks ' entspricht u.U. ActiveDocument.Bookmarks
        If bm.Range.InRange(pAnmerkungStart.Range) And StartsWith(bm.Name, "AnmPraefix") Then
            If RegexMatches(bm.Name, "^AnmPraefix_A[0-9]+$") Then
                sPraefix = bm.Name
            Else
                bm.Delete
            End If
            Exit For
        End If
    Next
    
    ' Pr|fffd|fen, ob Pr|fffd|fix verf|fffd|gbar
    i = 0
    tmp = "*"
    Do While tmp <> ""
        i = i + 1
        tmp = ""
        sPraefix = "AnmPraefix_A" & i
        For Each bm In ActiveDocument.Bookmarks
            If StartsWith(bm.Name, "AnmNr") Then
                If StartsWith(bm.Name, Replace(sPraefix, "Praefix", "Nr") & "_") Then
                    ' Hyperlink in einem anderen Anmerkungs-Block
                    tmp = bm.Name
                    Exit For
                ElseIf bm.Name = sPraefix Then
                    If Not bm.Range.InRange(pAnmerkungStart.Range) Then
                        ' Andere Pr|fffd|fix-Textmarke gleichen Namens
                        tmp = bm.Name
                        Exit For
                    End If
                End If
            End If
        Next
    Loop
    Set r = pAnmerkungStart.Range.Duplicate
    r.Collapse
    ActiveDocument.Bookmarks.Add sPraefix, r
    sPraefix = Replace(sPraefix, "Praefix", "Nr") & "_"
    
    ' Alle Anmerkungsnummern im Block neu durchz|fffd|hlen
    Set colAltNeu = New Collection
    iNumNeu = 0
    tmp = ""
    For Each f In rAnmerkung.Fields
        If InStr(f.Code.text, "MACROBUTTON " & AnmerkungsnrButton) Then
        
            'wenn bm dann schon verarbeitet
            Set r = f.Result.Paragraphs.first.Range.Duplicate
            r.Collapse
            For Each bm In r.Bookmarks
                If StartsWith(bm.Name, "AnmNr") Then
                    GoTo Next_F
                End If
            Next
            
            f.Select
            If Selection.Range.Revisions.Count > 0 Then
                If Selection.Range.Revisions(1).Type = wdRevisionDelete Then GoTo Next_F
            End If
            
        
            sNumAlt = Trim(Mid(f.Code.text, InStr(f.Code.text, AnmerkungsnrButton) + Len(AnmerkungsnrButton)))
            If StartsWith(sNumAlt, "GELOESCHT") Then
                tmp = Trim(f.Code.text)
                f.Delete
                On Error GoTo inkonsistenz
                sNumAlt = Trim(Mid(tmp, InStrRev(tmp, "GELOESCHT") + Len("GELOESCHT")))
                
                
                If AenderungsmodusAktiv And Not komplettLoeschen Then
                    Set f = Selection.Fields.Add(Selection.Range, wdFieldMacroButton, AnmerkungsnrButton & " " & sNumAlt, False)
                    f.Code.text = Trim(f.Code.text)
                    f.ShowCodes = False
                    ActiveDocument.TrackRevisions = True
                    f.Delete
                    ActiveDocument.TrackRevisions = False
                End If
                
                If InStr(1, sNumAlt, "-") Then
                    temp = Split(sNumAlt, "-")
                    sNumAlt = temp(0)
                    ende = temp(1)
                Else
                    ende = sNumAlt
                End If
                
                'If sNumAlt = "" Or Not IsNumeric(sNumAlt) Then
                '    err.Raise vbObjectError + 999
                'End If
                For i = sNumAlt To ende
                    colAltNeu.Add -1, "num" & i
                Next i
                colAltNeu.Add -1, "numGELOESCHT" ' F|fffd|r Pr|fffd|fung ob's mehrere gel|fffd|schte gibt
                On Error GoTo 0
            ElseIf InStr(1, sNumAlt, "-") Then
                temp = Split(sNumAlt, "-")
                iNumNeu = iNumNeu + 1
                ende = iNumNeu + temp(1) - temp(0)
                
'workaround f|fffd|r kaputte RK daten
                On Error GoTo workaround_ende
                For i = (temp(0) + 1) To temp(1)
                    colBmAlt.Add "AnmNr_" & i, "AnmNr_" & i
                Next i
workaround_ende:
               On Error GoTo 0
                
                On Error GoTo inkonsistenz
                    For i = temp(0) To temp(1)
                        colAltNeu.Add iNumNeu + i - temp(0), "num" & i
                    Next i
                On Error GoTo 0
                
                ' Button aktualisieren, Textmarke erzeugen
                'f.Code.text = "MACROBUTTON " & AnmerkungsnrButton & " " & iNumNeu & "-" & ende
                
                If sNumAlt <> iNumNeu & "-" & ende Then
                    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
                    f.Select
                    f.Delete
                    Set f = Selection.Fields.Add(Selection.Range, wdFieldMacroButton, AnmerkungsnrButton & " " & iNumNeu & "-" & ende, False)
                    f.Code.text = Trim(f.Code.text)
                    f.ShowCodes = False
                    ActiveDocument.TrackRevisions = False
                End If
                
                f.ShowCodes = False
                Set r = f.Result.Paragraphs.first.Range.Duplicate
                r.Collapse
                For i = iNumNeu To ende
                    ActiveDocument.Bookmarks.Add sPraefix & i, r
                Next i
                iNumNeu = ende
            Else
                ende = 1
                
                
                
                
                If InStr(1, sNumAlt, "NEU") Then
                    ende = Right(sNumAlt, Len(sNumAlt) - 3)
                    ' Button aktualisieren, Textmarke erzeugen
                    f.Select
                    f.Delete
                    ActiveDocument.TrackRevisions = AenderungsmodusAktiv
                    If ende > 1 Then
                        Set f = Selection.Fields.Add(Selection.Range, wdFieldMacroButton, AnmerkungsnrButton & " " & CStr(iNumNeu + 1) & "-" & CStr(iNumNeu + ende), False)
                    Else
                        Set f = Selection.Fields.Add(Selection.Range, wdFieldMacroButton, AnmerkungsnrButton & " " & CStr(iNumNeu + 1), False)
                    End If
                    f.Code.text = Trim(f.Code.text)
                    f.ShowCodes = False
                    ActiveDocument.TrackRevisions = False
                Else
                    ' Button aktualisieren, Textmarke erzeugen
                    If sNumAlt <> CStr(iNumNeu + 1) Then
                        ActiveDocument.TrackRevisions = AenderungsmodusAktiv
                        f.Select
                        f.Delete
                        Set f = Selection.Fields.Add(Selection.Range, wdFieldMacroButton, AnmerkungsnrButton & " " & CStr(iNumNeu + 1), False)
                        f.Code.text = Trim(f.Code.text)
                        f.ShowCodes = False
                        ActiveDocument.TrackRevisions = False
                    End If
                End If

                
                
                For i = 1 To ende
                    iNumNeu = iNumNeu + 1
                    
                    
                    If i = 1 Then
                        On Error GoTo inkonsistenz
                        colAltNeu.Add iNumNeu, "num" & sNumAlt
                        On Error GoTo 0
                    End If
                    
                    ' Textmarke erzeugen
                    
                    Set r = f.Result.Paragraphs.first.Range.Duplicate
                    r.Collapse
                    ActiveDocument.Bookmarks.Add sPraefix & iNumNeu, r
                Next i
            End If
        End If
        
Next_F:
    Next
    
    
    ' Bei der ***Verweisaktualisierung*** wird wie folgt vorgegangen:
    ' - Den Checklisten- bzw. Dokument-Container (im folgenden nur kurz "Formular")
    '   suchen in dem der Anmerkungs-Container ist
    ' - Im Formular alle Verweise durchlaufen
    ' - Die Verweise anhand colAltNeu aktualisieren, dabei pr|fffd|fen ob der Link ggf.
    '   aus einem anderen Formular stammt (in dem Fall existiert das alte durch
    '   die Textmarke angegebene Ziel nicht innerhalb des aktuellen Anmerkungs-Blocks)
    Dim pFormularStart As Paragraph, pChecklisteStart As Paragraph, pFormularEnde As Paragraph, _
      rArbeitsbereich As Range
'    Set pFormularStart = Block_Finden("Formulartext Anfang")
'    Set pChecklisteStart = Block_Finden("Checkliste Anfang")
'    Set rArbeitsbereich = Nothing
'    If pFormularStart Is Nothing And Not pChecklisteStart Is Nothing Then
'        ' Checkliste = Formular
'        Set pFormularStart = pChecklisteStart
'        Set pChecklisteStart = Nothing
'    End If
'    If pChecklisteStart Is Nothing And Not pFormularStart Is Nothing Then
    Set rArbeitsbereich = Nothing
    If True Then
        ' Formular (oder Checkliste) ist okay
        ' Sicherstellen, dass es nicht mehrere Anmerkungen gibt
        Dim pTmpAnmerkungStart As Paragraph, pTmpAnmerkungEnde As Paragraph
'        Set pTmpAnmerkungStart = Nothing
'        Set pTmpAnmerkungEnde = Nothing
'        Set pFormularEnde = BlockEnde_Finden(Replace(pFormularStart.style, " Anfang", ""), pAnmerkungEnde)
'        Set r = pFormularStart.Range.Duplicate
'        r.End = pFormularEnde.Range.End
'        tmp = ""
'        For Each p In r.Paragraphs
'            If p.style = "Anmerkungen Anfang" Then
'                If pTmpAnmerkungEnde Is Nothing And pTmpAnmerkungStart Is Nothing Then
'                    Set pTmpAnmerkungStart = p
'                Else
'                    tmp = "*"
'                    Exit For
'                End If
'            ElseIf p.style = "Anmerkungen Ende" Then
'                If pTmpAnmerkungEnde Is Nothing And Not pTmpAnmerkungStart Is Nothing Then
'                    Set pTmpAnmerkungEnde = p
'                Else
'                    tmp = "*"
'                    Exit For
'                End If
'            End If
'        Next
        
        ' Es gibt nur noch ein Formular/Checkliste o.|fffd|. pro Dokument
        Set r = ActiveDocument.Range(ActiveDocument.Paragraphs.first.Range.start, ActiveDocument.Paragraphs.Last.Range.End)
        tmp = ""
        
        Set pTmpAnmerkungStart = Block_Finden("Anmerkungen Anfang")
        Set pTmpAnmerkungEnde = Block_Finden("Anmerkungen Ende")
        
        If tmp = "" And Not (pTmpAnmerkungStart Is Nothing) And Not (pTmpAnmerkungEnde Is Nothing) Then
            ' Arbeitsbereich okay
            Set rArbeitsbereich = r.Duplicate
            For Each f In rArbeitsbereich.Fields
                If f.Type = wdFieldHyperlink Then
                    f.ShowCodes = False
                End If
            Next
            ' Verweise aktualisieren (immer, damit Ziel-Textmarke korrekt)
            
            
            
            i = 1
            Do While i <= rArbeitsbereich.Hyperlinks.Count
                Set h = rArbeitsbereich.Hyperlinks(i)
                
                hasRevision = False
                If h.Range.Revisions.Count > 0 Then
                    If h.Range.Revisions(1).Type = wdRevisionDelete Then hasRevision = True
                End If
                If Not hasRevision Then
                    If StartsWith(h.SubAddress, "AnmNr") Then
                        ' Anmerkungsverweis, pr|fffd|fen
                        If RegexMatches("^[0-9]+$", h.TextToDisplay) Then
                            sNumAlt = CStr(h.TextToDisplay)
                            
                            ' Neue Nummer ermitteln
                            iNumNeu = 0
                            On Error Resume Next
                            err.number = 0
                            
                            If colAltNeu("num" & sNumAlt) <> sNumAlt Then
                                ActiveDocument.TrackRevisions = AenderungsmodusAktiv
                                iNumNeu = CInt(colAltNeu("num" & sNumAlt))
                                If err.number <> 0 Then
                                    iNumNeu = 0
                                End If
                                On Error GoTo 0
                                If iNumNeu < 1 Then
                                    ' Nummer wurde entfernt (bei -1 handelt es sich um die gel|fffd|schte Nummer)
                                    If iNumNeu = 0 Then
                                        h.Range.Select
                                        MsgBox "Die Anmerkung auf die dieser Link verweist existiert nicht mehr, daher wird der Link entfernt.", vbExclamation
                                    End If
                                    h.Range.Select
                                    Selection.Delete
                                    If Not AenderungsmodusAktiv Then i = i - 1
                                Else
                                    ' Nummer aktualisieren (Hyperlink neu einf|fffd|gen da aktualisieren nicht richtig funktioniert)
                                    h.Range.Select
                                    Selection.Delete
                                    Selection.Hyperlinks.Add(Selection.Range, , sPraefix & iNumNeu, , CStr(iNumNeu)).Range.font.Superscript = True
                                    For Each f In Selection.Paragraphs.first.Range.Fields
                                        If f.Type = wdFieldHyperlink Then
                                            f.ShowCodes = False
                                        End If
                                    Next
                                    If AenderungsmodusAktiv Then i = i + 1
                                End If
                                ActiveDocument.TrackRevisions = False
                            End If
                        Else
                            h.Range.Select
                            MsgBox "Die Anmerkungsnummer konnte nicht erkannt werden. Dieser Link kann nicht aktualisiert werden.", vbExclamation
                        End If
                    End If
                End If
                i = i + 1
            Loop
        Else
            Set rArbeitsbereich = Nothing
        End If
    End If
    
    If rArbeitsbereich Is Nothing Then
        ' Formular/Checkliste fehlt, oder die beiden sind verschachtelt
        ' oder es gibt mehrere Anmerkungen
        'MsgBox "Die Verweise k|fffd|nnen nicht aktualisiert werden, da sich der Anmerkungs-Container entweder " & _
          "innerhalb eines " & FormularBlockName & "- oder Checkliste-Containers befinden muss und der " & _
          "einzige Anmerkungs-Container des Formulars sein muss.", vbExclamation
        MsgBox "Die Verweise k|fffd|nnen nicht aktualisiert werden, da der Anmerkungs-Container nicht erkannt werden konnte.", vbExclamation
    End If
    
    ' Fertig
fertig:
    rGemerkt.Select
    Exit Sub
inkonsistenz:
    MsgBox "Das Dokument ist inkonsistent. Bitte |fffd|berpr|fffd|fen Sie alle Anmerkungsnummern und die Links darauf.", vbExclamation
    GoTo fertig
End Sub

Public Function AnmerkungsverweisePruefen(bDokpruefer As Boolean) As String
    ' Anmerkungen holen
    Dim colLinks As Collection, colBookmarks As Collection, i As Long, rArbeitsbereich As Range, item As Variant, found As Boolean
    Dim f As Field, h As Hyperlink, hasRevision As Boolean, sNum As String, dictUsed As Scripting.Dictionary, msg As String
    AnmerkungsverweisePruefen = ""
    Set FormAnmLinkBereich = ActiveDocument.Range.Duplicate
    Set rArbeitsbereich = ActiveDocument.Range.Duplicate
    frmAnmerkungsLink.GetBookmarks rArbeitsbereich, colLinks, colBookmarks
    On Error Resume Next
    Unload frmAnmerkungsLink
    On Error GoTo 0
    Set dictUsed = New Scripting.Dictionary
    For Each item In colLinks
        dictUsed.Add "num" & item, 0
    Next
    
    ' Anmerkungslinks
    For Each f In rArbeitsbereich.Fields
        If f.Type = wdFieldHyperlink Then
            f.ShowCodes = False
        End If
    Next
    For i = 1 To rArbeitsbereich.Hyperlinks.Count
        Set h = rArbeitsbereich.Hyperlinks(i)
        
        hasRevision = False
        If h.Range.Revisions.Count > 0 Then
            If h.Range.Revisions(1).Type = wdRevisionDelete Then hasRevision = True
        End If
        If Not hasRevision Then
            If StartsWith(h.SubAddress, "AnmNr") Then
                ' Anmerkungsverweis, pr|fffd|fen
                If RegexMatches("^[0-9]+$", h.TextToDisplay) Then
                    found = False
                    sNum = "num" & CStr(h.TextToDisplay)
                    If dictUsed.Exists(sNum) Then
                        If dictUsed(sNum) >= 0 Then
                            found = True
                        End If
                    End If
                    If found Then
                        dictUsed(sNum) = dictUsed(sNum) + 1
                    Else
                        If bDokpruefer Then
                            modDokpruefer.RecordError_Bookmark "Ung|fffd|ltige Anmerkungsnummer-Zuweisung.", sem, , h.Range
                        End If
                        dictUsed.Add sNum, "-1"
                    End If
                End If
            End If
        End If
    Next
    
    ' Infos zusammensetzen
    If bDokpruefer Then
        msg = "Nicht vergebene/zugewiesene Anmerkungsnummern: "
    Else
        msg = "Das Dokument enth|fffd|lt nicht vergebene/zugewiesene Anmerkungsnummern:" & vbNewLine
    End If
    found = False
    For Each item In dictUsed.Keys
        sNum = Replace(item, "num", "")
        item = CLng(dictUsed(item))
        If item < 0 Then
            msg = "Das Dokument enth|fffd|lt ung|fffd|ltige Anmerkungsnummer-Zuweisungen."
            found = True
            Exit For
        ElseIf item < 1 Then
            If found Then
                msg = msg & ", "
            End If
            msg = msg & sNum
            found = True
        End If
    Next
    If found Then
        If bDokpruefer Then
            modDokpruefer.RecordError_Bookmark msg, part, , ActiveDocument.Range.Characters.Last
        End If
        AnmerkungsverweisePruefen = msg
    Else
        AnmerkungsverweisePruefen = ""
    End If
End Function

' ********** ZWEISPALTIGER TEXT **********

' Siehe auch modContainer

Function CountContainedTab(r As Range) As Integer
    CountContainedTab = UBound(Split(r.text, Chr(9)))
End Function

' ********** SONSTIGES **********

Sub CheckboxEinfuegen()
'    If BlockAnfang_Finden("Checkliste", Selection.Paragraphs.First) Is Nothing Then
'        MsgBox "Dies ist nur innerhalb eines Checkliste-Containers m|fffd|glich.", vbExclamation
'        Exit Sub
'    End If
'    If Not FormulartextPruefen Then Exit Sub
    Selection.Collapse
    Selection.InsertSymbol font:="Times New Roman", CharacterNumber:=9744, Unicode:=True
    Selection.TypeText Chr(160)
End Sub

Sub CheckboxMitHakenEinfuegen()
    If BlockAnfang_Finden("Checkliste", Selection.Paragraphs.first) Is Nothing Then
        MsgBox "Dies ist nur innerhalb eines Checkliste-Containers m|fffd|glich.", vbExclamation
        Exit Sub
    End If
    If Not FormulartextPruefen Then Exit Sub
    Selection.Collapse
    Selection.InsertSymbol font:="Times New Roman", CharacterNumber:=9745, Unicode:=True
    Selection.TypeText Chr(160)
End Sub

Sub FormularfeldEinfuegen()
    ' Wird auch vom automatischem CE Makro aufgerufen
    InsertCustomFormField "." & Chr(160) & "." & Chr(160) & "." & Chr(160) & "." & Chr(160) & "." '& Chr(160) & "."
End Sub

Sub InsertCustomFormField(txt As String)
    If Len(Selection.text) > 0 Then
        Selection.Collapse wdCollapseStart
    End If
    Selection.FormFields.Add Range:=Selection.Range, Type:= _
     wdFieldFormTextInput
    Selection.MoveLeft unit:=wdCharacter, Count:=1, Extend:=wdExtend
    With Selection.FormFields(1)
        .Name = "Replaceable_Dots"
        .EntryMacro = ""
        .ExitMacro = ""
        .Enabled = False
        .OwnHelp = False
        .HelpText = ""
        .OwnStatus = False
        .StatusText = ""
        .Result = txt
    End With
    Selection.Range.HighlightColorIndex = wdGray25
    Selection.Collapse wdCollapseEnd
    EnsureResetStyle True
End Sub

' Formularverweis und manueller Anmerkungsverweis siehe modMacros
Attribute VB_Name = "modFunctions"
Option Explicit

Function FileExists(sFile As String) As Boolean
    On Error GoTo err
    If Trim(sFile) = "" Or (GetAttr(sFile) And vbDirectory) Then
        FileExists = False
        Exit Function
    End If
    GetAttr sFile
    FileExists = True
    Exit Function
err:
    FileExists = False
End Function

Function RegexMatches(sRegex As String, sText As String, Optional ByRef retvalMatches As Object = Nothing) As Boolean
    Dim regex As RegExp, matches As MatchCollection
    Set regex = New RegExp
    regex.IgnoreCase = False
    regex.Global = False
    regex.MultiLine = False
    regex.Pattern = sRegex
    Set matches = regex.Execute(sText)
    If matches.Count > 0 Then
        Set retvalMatches = matches
        RegexMatches = True
        GoTo fertig
    End If
    Set retvalMatches = Nothing
    RegexMatches = False
fertig:
    Set regex = Nothing
End Function

Function RegexReplace(sRegex As String, sText As String, sReplace As String, Optional bGlobal As Boolean = False) As String
    Dim regex As RegExp
    Set regex = New RegExp
    regex.IgnoreCase = False
    regex.Global = bGlobal
    regex.MultiLine = False
    regex.Pattern = sRegex
    RegexReplace = regex.Replace(sText, sReplace)
End Function

Sub EnsureResetStyle(Optional blNoHighlight As Boolean = False)
    ' Damit beim Weitertippen nicht das ZF beibehalten wird:
    Selection.TypeText " "
    Selection.MoveLeft , 1, True
    Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
    If blNoHighlight Then Selection.Range.HighlightColorIndex = wdNoHighlight
    'Selection.TypeBackspace
    Selection.Delete
    With Selection.Paragraphs.Last.Range.Characters.Last
        If .text = Chr(13) And .Style <> wdStyleDefaultParagraphFont Then
            .Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
            If blNoHighlight Then .HighlightColorIndex = wdNoHighlight
        End If
    End With
End Sub

Function SelectionInSpecialArea(Optional bIgnoreTable As Boolean = False) As Boolean
    If (Selection.Information(wdWithInTable) And bIgnoreTable = False) Or _
      Selection.Information(wdInCommentPane) Or _
      Selection.Information(wdInFootnote) Then
        SelectionInSpecialArea = True
    Else
        SelectionInSpecialArea = False
    End If
End Function

Public Function GetSelectionText() As String
    If Selection.start = Selection.End Then
        GetSelectionText = ""
        Exit Function
    End If
    Dim sText As String, r As Range, f As Field
    Set r = Selection.Range.Duplicate
    For Each f In r.Fields
        f.ShowCodes = False
    Next
    sText = r.text
    If InStr(sText, vbCr) > 0 Then
        sText = Left(sText, InStr(sText, vbCr) - 1)
    End If
    If InStr(sText, Chr(7)) > 0 Then
        sText = Left(sText, InStr(sText, Chr(7)) - 1)
    End If
    If InStr(sText, Chr(19)) > 0 Then
        ' Felder ausfiltern
        sText = Left(sText, InStr(sText, Chr(19)) - 1)
    End If
    GetSelectionText = Trim(sText)
End Function

Public Function CollectionContainsItem(col As Collection, search As Variant) As Boolean
    Dim item As Variant
    For Each item In col
        If item = search Then
            CollectionContainsItem = True
            Exit Function
        End If
    Next
    CollectionContainsItem = False
End Function

Public Function ArrayContains(aItems As Variant, search As String) As Boolean
    Dim item As Variant
    For Each item In aItems
        If CStr(item) = search Then
            ArrayContains = True
            Exit Function
        End If
    Next
    ArrayContains = False
End Function

Public Sub SetSelectionAF(sStyle As String)
    On Error GoTo errHandler
    Dim p As Paragraph
    For Each p In Selection.Paragraphs
        p.Style = ActiveDocument.styles(sStyle)
    Next
    Exit Sub
errHandler:
    MsgBox "Fehler: Das Absatzformat " & sStyle & " existiert nicht.", vbCritical
    Exit Sub
End Sub

Public Sub InsertNewParaAfter()
    SetSelectionToParaEnd
    Selection.InsertParagraphAfter
    Selection.Collapse wdCollapseEnd
End Sub

Public Sub SetSelectionToParaEnd()
    If Selection.start <> Selection.Paragraphs(Selection.Paragraphs.Count).Range.End - 1 Or Selection.Paragraphs.Count > 1 Then
        Selection.Collapse wdCollapseEnd
    End If
    Selection.start = Selection.Paragraphs(1).Range.End - 1
End Sub

Public Sub InsertNewParaBefore()
    Selection.Collapse
    Selection.start = Selection.Paragraphs(1).Range.start
    Selection.InsertParagraphBefore
    Selection.Collapse
End Sub

Function StartsWith(str As String, search As String) As Boolean
    If Len(str) >= Len(search) Then
        If Left(str, Len(search)) = search Then
            StartsWith = True
            Exit Function
        End If
    End If
    StartsWith = False
End Function

Function IsNormalPara(p As Paragraph) As Boolean
    If p.Style = "Absatz" Or p.Style = "Absatz_Abstand" Then
        IsNormalPara = True
    Else
        IsNormalPara = False
    End If
End Function

Function IsHeadingPara(p As Paragraph) As Boolean
    ' Ganz bewusst nur Heading 1-9!
    IsHeadingPara = p.Style Like Replace(ActiveDocument.styles(wdStyleHeading1).NameLocal, "1", "#")
End Function

Public Function SortCollection(colItems As Collection) As Variant
    Dim i1 As Integer, i2 As Integer, tmp As String
    Dim lListItems As Variant
    If colItems.Count < 1 Then
        ReDim lListItems(0)
        SortCollection = lListItems
        Exit Function
    End If
    ReDim lListItems(0 To colItems.Count - 1)
    
    ' In Datenfeld einlesen und sortieren
    For i1 = 0 To colItems.Count - 1
        lListItems(i1) = colItems(i1 + 1)
        For i2 = i1 To 1 Step -1
            If lListItems(i2) < lListItems(i2 - 1) Then
                tmp = lListItems(i2)
                lListItems(i2) = lListItems(i2 - 1)
                lListItems(i2 - 1) = tmp
            End If
        Next i2
    Next i1
    SortCollection = lListItems
End Function

Public Sub SortArray(ByRef arr As Variant)
    Dim j As Integer, i As Integer, vTemp As Variant
    For j = UBound(arr) - 1 To LBound(arr) Step -1
        For i = LBound(arr) To j
            If arr(i) > arr(i + 1) Then
                vTemp = arr(i)
                arr(i) = arr(i + 1)
                arr(i + 1) = vTemp
            End If
        Next i
    Next j
End Sub
Attribute VB_Name = "modListTplToStyles"
' War zur einmaligen Ausf|fffd|hrung
' Danach wurden noch die fehlende Zuweisungen korrigiert (Liste Kasten leer/voll Ebenen)

Option Explicit

Private Const indentperlevel As Single = 0.8

Sub convertlists()
    Dim st As Style, ll As ListLevel, lstyle As Style, i As Integer, styles As Collection, max As Integer, stylesall As Collection, v As Variant
    Set stylesall = New Collection
    For Each st In ActiveDocument.styles
        If st.Type = wdStyleTypeParagraph Then
            If Not st.ListTemplate Is Nothing Then
                If st.NameLocal Like "Liste * 1. Ebene" Then
                    Set lstyle = ActiveDocument.styles.Add("L_" & Trim(Replace(Replace(st.NameLocal, "1. Ebene", ""), "Liste", "")), wdStyleTypeList)
                    lstyle.ListTemplate.OutlineNumbered = st.ListTemplate.OutlineNumbered
                    Debug.Print lstyle.NameLocal
                    Set styles = New Collection
                    For i = 1 To 9
                        Set ll = st.ListTemplate.ListLevels(i)
                        If ll.LinkedStyle <> "" Then
                            Debug.Print "-- " & ll.LinkedStyle
                            styles.Add ll.LinkedStyle, "ls" & i
                            max = i
                            ProcessListLevel lstyle.ListTemplate.ListLevels(i), ll
                        Else
                            Exit For
                        End If
                    Next
                    st.ParagraphFormat.LeftIndent = 0
                    st.ParagraphFormat.FirstLineIndent = 0
                    st.ParagraphFormat.TabStops.ClearAll
                    For i = 1 To max
                        With lstyle.ListTemplate.ListLevels(i)
                            .LinkedStyle = styles("ls" & i)
                            stylesall.Add i & "#" & styles("ls" & i)
                            If i > 1 And .ResetOnHigher <> i - 1 Then Stop
                            .NumberPosition = CentimetersToPoints((i - 1) * indentperlevel)
                            .TextPosition = CentimetersToPoints(i * indentperlevel)
                            .TabPosition = CentimetersToPoints(i * indentperlevel)
                        End With
                    Next
                End If
            End If
        End If
    Next
    For Each v In stylesall
        i = Left(v, 1)
        Set st = ActiveDocument.styles(Mid(v, 3))
        st.ParagraphFormat.LeftIndent = CentimetersToPoints(i * indentperlevel)
        ActiveDocument.Paragraphs.Last.Range.Select
        Selection.Collapse wdCollapseEnd
        Selection.TypeParagraph
        ActiveDocument.Paragraphs.Last.Style = st
    Next
End Sub

Private Sub ProcessListLevel(llnew As ListLevel, ll As ListLevel)
    With llnew
        .NumberFormat = ll.NumberFormat
        .TrailingCharacter = ll.TrailingCharacter
        .NumberStyle = ll.NumberStyle
        .NumberPosition = ll.NumberPosition
        .Alignment = ll.Alignment
        .TextPosition = ll.TextPosition
        .TabPosition = ll.TabPosition
        .ResetOnHigher = ll.ResetOnHigher
        .StartAt = ll.StartAt
'        With .Font
'            .Bold = ll.Font.Bold
'            .Italic = ll.Font.Italic
'            .StrikeThrough = ll.Font.StrikeThrough
'            .Subscript = ll.Font.Subscript
'            .Superscript = ll.Font.Superscript
'            .Shadow = ll.Font.Shadow
'            .Outline = ll.Font.Outline
'            .Emboss = ll.Font.Emboss
'            .Engrave = ll.Font.Engrave
'            .AllCaps = ll.Font.AllCaps
'            .Hidden = ll.Font.Hidden
'            .Underline = ll.Font.Underline
'            .Color = ll.Font.Color
'            .Size = ll.Font.Size
'            .Animation = ll.Font.Animation
'            .DoubleStrikeThrough = ll.Font.DoubleStrikeThrough
'            .Name = ll.Font.Name
'        End With
        '.LinkedStyle = ll.LinkedStyle
    End With
End Sub
Attribute VB_Name = "modLists"
Option Explicit

Private Const ListIndent As Integer = 8

Sub ListenDarstellungKorr(Optional showMsg As Boolean = True)
    Dim bm As Bookmark, p As Paragraph, st As Style, foundStyles As Collection, listName As String
    
    If CInt(Left(Application.Version, InStr(1, Application.Version, ".") - 1)) < 11 Then
        MsgBox "Listendarstellung korrigieren wird erst ab Word 2003 unterst|fffd|tzt.", vbExclamation
        Exit Sub
    End If
    
    Set foundStyles = New Collection
    
    ' Dartellung der Listen korrigieren
    For Each p In ActiveDocument.ListParagraphs
        Set st = p.Style
        If st.NameLocal Like "Liste * Ebene" Then
            p.Range.ListFormat.ApplyListTemplate st.ListTemplate
            listName = GetListName(st.NameLocal)
            If Not CollectionContainsItem(foundStyles, listName) Then
                ' Listenstyle Einz|fffd|ge einstellen
                SetupListIndents listName
                foundStyles.Add listName
            End If
        End If
    Next
    
    ' Neustarts anhand Bookmarks setzen
    For Each bm In ActiveDocument.Bookmarks
        If bm.Name Like "listRestart*" Then
            Set p = bm.Range.Paragraphs.first
            Set st = p.Style
            If st.NameLocal Like "Liste *. Ebene" Then
                ' Neustart setzen
                Dim r As Range
                Set r = p.Range.Duplicate
                r.Collapse
                r.ListFormat.ApplyListTemplate st.ListTemplate, False
            Else
                bm.Delete
            End If
        End If
    Next
    If showMsg Then MsgBox "Fertig.", vbInformation
End Sub

Sub ListeFortsetzen()
    ListeFortsetzenUmschalten 1
End Sub

Sub ListeNeuzaehlen()
    ListeFortsetzenUmschalten 0
End Sub

Sub ListeFortsetzenUmschalten(Optional val As Single = -1)
    ' Pr|fffd|fen
    If Selection.Paragraphs.Count <> 1 Then
        MsgBox "Es sind mehrere Abs|fffd|tze markiert. Bitte markieren Sie nur einen Absatz.", vbExclamation
        Exit Sub
    End If
    Dim st As Style, ok As Boolean, lvlPara As Integer, p As Paragraph
    Set p = Selection.Paragraphs.first
    ok = False
    Set st = ActiveDocument.styles(p.Style)
    If Not st.ListTemplate Is Nothing Then
        lvlPara = st.ListLevelNumber
        If st.ListTemplate.ListLevels(lvlPara).NumberStyle <> wdListNumberStyleNone And _
         st.ListTemplate.ListLevels(lvlPara).NumberStyle <> wdListNumberStyleBullet Then
            If st.NameLocal Like "Liste *. Ebene" Then
                ok = True
            End If
        End If
    End If
    If Not ok Then
        MsgBox "Es muss ein Absatz einer numerischen Liste markiert sein.", vbExclamation
        Exit Sub
    End If
    
    ' Setzen
    Dim continue As Boolean, rSel As Range
    Set rSel = p.Range
    rSel.Collapse
    If Not rSel.ListFormat.ListTemplate Is Nothing Then
        ' Word ver|fffd|ndert teilweise die Einz|fffd|ge -> korrekt setzen
        SetupListIndents GetListName(st.NameLocal)

        ' Listenformat auflegen
        With Selection.Range.ListFormat
            If val = 1 Then
                continue = True
            ElseIf val = 0 Then
                continue = False
            ElseIf val = -1 Then
                continue = .ListValue = 1
            Else
                Stop
            End If
            .ApplyListTemplate .ListTemplate, continue
            
            ' Restart Marker l|fffd|schen
            Dim bm As Bookmark
            For Each bm In p.Range.Bookmarks
                If bm Like "listRestart*" Then
                    If bm.Range.InRange(p.Range) Then
                        bm.Delete
                    End If
                End If
            Next
            
            ' Restartmarker setzen
            If Not continue Then
                Dim markerID As String
                Randomize
                Do While True
                    markerID = "listRestart" & p.Range.start & Int(1000 * Rnd + 1)
                    If Not ActiveDocument.Bookmarks.Exists(markerID) Then
                        Exit Do
                    End If
                Loop
                ActiveDocument.Bookmarks.Add markerID, rSel
            End If
        End With
    End If
End Sub

Function GetListName(styleName As String) As String
    Dim listName As String
    listName = ""
    If styleName Like "Liste * #. Ebene" Then
        listName = Replace(styleName, "Liste ", "")
        listName = Left(listName, Len(listName) - 9)
    End If
    If Trim(listName) = "" Then
        'Stop
    End If
    GetListName = listName
End Function

Sub SetupListIndents(listName As String)
    ' Einz|fffd|ge neu einstellen
    Dim lvl As Integer, st2 As Style, maxLevel As Integer
    For lvl = 1 To 5
        On Error Resume Next
        Set st2 = ActiveDocument.styles("Liste " & listName & " " & lvl & ". Ebene")
        If err.number <> 0 Then
            On Error GoTo 0
            Exit For
        End If
        On Error GoTo 0
        maxLevel = lvl
        ListSetIndent st2.ListTemplate.ListLevels(lvl), lvl
        ListSetParaIndent st2.ParagraphFormat, lvl
    Next
    If maxLevel < 1 Then
        Stop
    End If
End Sub

Private Sub FixListTemplates()
    ' Listendarstellung korrigieren (f|fffd|r Anpassung Dot)
    Dim lt As Integer
    For lt = 1 To 12
        If ActiveDocument.ListTemplates.Count < lt Then
            ActiveDocument.ListTemplates.Add True
        Else
            ActiveDocument.ListTemplates(lt).OutlineNumbered = True
        End If
    Next
    If ActiveDocument.ListTemplates.Count > 20 Then
        ' Speicher|fffd|berlauf bei 400 Listentemplates...
        MsgBox "Ups! Zu viele Listentemplates... Probleme nicht unwahrscheinlich!"
        Exit Sub
    End If
    For lt = 1 To ActiveDocument.ListTemplates.Count
        ActiveDocument.ListTemplates(lt).Name = ""
    Next
    MsgBox "Listtemplates: " & ActiveDocument.ListTemplates.Count
    ListSetTemplate Nothing, "Listeneinzug", 5, "", wdListNumberStyleNone
    ListSetTemplate ActiveDocument.ListTemplates(1), "(Num)", 5, "(%1)", wdListNumberStyleArabic
    ListSetTemplate ActiveDocument.ListTemplates(2), "Num", 5, "%1.", wdListNumberStyleArabic
    ListSetTemplate ActiveDocument.ListTemplates(3), "(a)", 5, "(%1)", wdListNumberStyleLowercaseLetter
    ListSetTemplate ActiveDocument.ListTemplates(4), "a klein", 5, "%1)", wdListNumberStyleLowercaseLetter
    ListSetTemplate ActiveDocument.ListTemplates(5), "A gro|fffd|", 3, "%1.", wdListNumberStyleUppercaseLetter
    ListSetTemplate ActiveDocument.ListTemplates(6), "(aa)", 5, "(%1%1)", wdListNumberStyleLowercaseLetter
    ListSetTemplate ActiveDocument.ListTemplates(7), "I gro|fffd|", 3, "%1.", wdListNumberStyleUppercaseRoman
    ListSetTemplate ActiveDocument.ListTemplates(8), "Strich", 5, Chr(150), wdListNumberStyleNone
    ListSetTemplate ActiveDocument.ListTemplates(9), "Punkt", 5, ChrW(8226), wdListNumberStyleNone
    ListSetTemplate ActiveDocument.ListTemplates(10), "Kasten voll", 2, ChrW(9632), wdListNumberStyleNone, 12
    ListSetTemplate ActiveDocument.ListTemplates(11), "Kasten leer", 2, ChrW(9744), wdListNumberStyleNone, 8
    ListSetTemplate ActiveDocument.ListTemplates(12), "aa", 5, "%1%1)", wdListNumberStyleLowercaseLetter
End Sub

Private Sub ListSetTemplate(lt As ListTemplate, Name As String, maxLevel As Integer, numFormat As String, _
 numStyle As WdListNumberStyle, Optional fontSize As Integer = 0, Optional fontName As String = "")
    Dim lvl As Integer, nameFormat As String, st As Style
    ' Listenformat einstellen
    For lvl = 1 To maxLevel
        If lt Is Nothing Then
            With ActiveDocument.styles(Name & " " & lvl & ". Ebene")
                ' Einzug
                .ParagraphFormat.LeftIndent = MillimetersToPoints(ListIndent * (lvl))
            End With
        Else
            ' Regul|fffd|re Liste
            nameFormat = "Liste " & Name & " " & lvl & ". Ebene"
            Set st = ActiveDocument.styles(nameFormat)
            If lvl = 1 Then
                lt.Name = Name
            End If
            With st
                .AutomaticallyUpdate = False
                .LinkToListTemplate Nothing
                .ParagraphFormat.LeftIndent = 0
                .ParagraphFormat.TabStops.ClearAll
            End With
            With lt.ListLevels(lvl)
                .LinkedStyle = ""
                .NumberStyle = numStyle
                .NumberFormat = Replace(numFormat, "%1", "%" & lvl)
                .TrailingCharacter = wdTrailingTab
                .NumberStyle = numStyle
                .Alignment = wdListLevelAlignLeft
                ListSetIndent lt.ListLevels(lvl), lvl
                .ResetOnHigher = lvl - 1
                .StartAt = 1
                With .font
                    .Bold = st.font.Bold
                    .Italic = st.font.Italic
                    .StrikeThrough = False
                    .Subscript = False
                    .Superscript = False
                    .Shadow = False
                    .Outline = False
                    .Emboss = False
                    .Engrave = False
                    .AllCaps = False
                    .Hidden = False
                    .Underline = False
                    .Color = st.font.Color
                    .Size = IIf(fontSize > 0, fontSize, st.font.Size)
                    .Animation = False
                    .DoubleStrikeThrough = False
                    .Name = IIf(fontName <> "", fontName, st.font.Name)
                End With
                .LinkedStyle = st.NameLocal
            End With
            With st
                .LinkToListTemplate lt, lvl
            End With
        End If
    Next
    
    ' Listenabsatzformat einstellen (wegen Word-Bug)
    If Not lt Is Nothing Then
        For lvl = 1 To maxLevel
           ListSetParaIndent ActiveDocument.styles("Liste " & Name & " " & lvl & ". Ebene").ParagraphFormat, lvl
        Next
    End If
End Sub

Private Sub ListSetIndent(ll As ListLevel, lvl As Integer)
    ll.NumberPosition = (MillimetersToPoints(ListIndent * (lvl - 1)))
    ll.TextPosition = MillimetersToPoints(ListIndent * lvl)
    ll.TabPosition = MillimetersToPoints(ListIndent * lvl)
End Sub

Private Sub ListSetParaIndent(pf As ParagraphFormat, lvl As Integer)
    With pf
        .TabStops.ClearAll
        .LeftIndent = MillimetersToPoints(ListIndent * lvl)
        .FirstLineIndent = MillimetersToPoints(ListIndent * -1)
        .TabStops.Add .LeftIndent
    End With
End Sub

Attribute VB_Name = "modMacros"
Option Explicit

Public Enum ELinkTyp
    Formular = 0
    Anmerkung = 1
    Abschnitt = 2
End Enum

Global FormLinkTyp As ELinkTyp
Global currPage As Integer
Global Const MetaDelim As String = "$#$"

Sub BildEinfuegen()
    ' Dialog vorbereiten
    Dim dlg As Dialog
    Set dlg = Dialogs(wdDialogInsertPicture)
    dlg.LinkToFile = True
    
    ' Dialog durchf|fffd|hren
    If dlg.Display = -1 Then
        ' Bild einf|fffd|gen
        InsertNewParaAfter
        Selection.Paragraphs.Last.Range.Select
        Selection.Collapse
        ActiveDocument.InlineShapes.AddPicture dlg.Name, True, False, Selection.Range
        InsertNewParaAfter
        Selection.Paragraphs.Last.Range.Select
        Selection.Collapse
    End If
End Sub

Sub Absatz_links()
    AbsatzAusrichtung wdAlignParagraphLeft
End Sub

Sub Absatz_rechts()
    AbsatzAusrichtung wdAlignParagraphRight
End Sub

Sub Absatz_mitte()
    AbsatzAusrichtung wdAlignParagraphCenter
End Sub

Sub Absatz_block()
    AbsatzAusrichtung wdAlignParagraphJustify
End Sub

Sub AbsatzAusrichtung(align As WdParagraphAlignment)
    Dim p As Paragraph
    For Each p In Selection.Paragraphs
        If Not IsNormalPara(p) Then
            MsgBox "Die Ausrichtung kann nur bei normalen Abs|fffd|tzen gesetzt werden.", vbExclamation
            Exit Sub
        End If
    Next
    Selection.Paragraphs.Alignment = align
End Sub

Sub ZeichenformatZuruecksetzen()
    Selection.font.Reset
    Selection.Style = ActiveDocument.styles(wdStyleDefaultParagraphFont)
    Selection.Range.HighlightColorIndex = wdAuto
End Sub

Public Sub InsertStiwo()
    If Selection.Information(wdInCommentPane) Then
        MsgBox "In Kommentare k|fffd|nnen keine Stichw|fffd|rter eingef|fffd|gt werden.", vbExclamation
        Exit Sub
    End If
    frmStichwort.cboHSW.text = GetSelectionText
    frmStichwort.txtUSW.text = ""
    frmStichwort.init
    frmStichwort.Show vbModal
End Sub

Public Sub InsertTableCustom()
    If Selection.Information(wdInCommentPane) Then
        MsgBox "In Kommentare k|fffd|nnen keine Tabellen eingef|fffd|gt werden.", vbExclamation
        Exit Sub
    End If
    If Selection.Information(wdWithInTable) Then
        MsgBox "Tabellen k|fffd|nnen nicht verschachtelt werden.", vbExclamation
        Exit Sub
    End If
'    On Error Resume Next
'    With Dialogs(wdDialogTableInsertTable)
'        .Show
'        If Selection.Tables.Count > 0 Then
'            Selection.Tables(1).Range.Paragraphs.Style = "Absatz"
'            If MsgBox("Soll die Tabelle Linien haben?", vbYesNo) = vbNo Then
'              TableNoBorders
'            End If
'        End If
'    End With

frmInsertTable.Show vbModal
    
    
End Sub

Public Sub TableNoBorders()
    If Selection.Tables.Count = 0 Then InsertTableCustom
    If Selection.Tables.Count = 0 Then Exit Sub
    With Selection.Tables(1).Borders
        If .InsideLineStyle <> wdLineStyleNone Or .OutsideLineStyle <> wdLineStyleNone Then
            .InsideLineStyle = wdLineStyleNone
            .OutsideLineStyle = wdLineStyleNone
        Else
            .InsideLineStyle = wdLineStyleSingle
            .OutsideLineStyle = wdLineStyleSingle
        End If
    End With
End Sub

Public Sub tabKopf()
On Error Resume Next
Selection.Rows.HeadingFormat = wdToggle
End Sub


'
'Sub InsertFN()
'    If Selection.Information(wdInFootnote) And Selection.Paragraphs.Style <> ActiveDocument.Styles(wdStyleFootnoteText) Then
'        If MsgBox("Sie befinden sich bereits im Fu|fffd|notenbereich. Beim Best|fffd|tigen mit OK wird das Fu|fffd|notentext-Absatzformat aufgelegt.", vbExclamation Or vbOKCancel) = vbOK Then
'            Selection.Paragraphs.Style = ActiveDocument.Styles(wdStyleFootnoteText)
'        End If
'        Exit Sub
'    ElseIf Selection.Information(wdInFootnote) Then
'        MsgBox "Sie befinden sich bereits im Fu|fffd|notenbereich.", vbExclamation
'        Exit Sub
'    ElseIf Selection.Information(wdInCommentPane) Then
'        MsgBox "In Kommentare k|fffd|nnen keine Fu|fffd|noten eingef|fffd|gt werden.", vbExclamation
'        Exit Sub
'    End If
'    ActiveDocument.Footnotes.Add Range:=Selection.Range, Reference:=""
'End Sub

Sub FormularVerweis()
    FormLinkTyp = Formular
    Load frmFormLink
    frmFormLink.Show 1
End Sub

Sub AnmerkungsverweisManuell()
    ' Nur f|fffd|r manuelle Verweise!
    If Not (BlockAnfang_Finden("Formular", Selection.Paragraphs.first) Is Nothing) Or _
     Not (BlockAnfang_Finden("Formular", Selection.Paragraphs.first) Is Nothing) Then
        If MsgBox("M|fffd|chten Sie einen Link auf eine Anmerkung dieses Formulars einf|fffd|gen?", vbYesNo Or vbQuestion) = vbYes Then
            Anmerkungsverweis
            Exit Sub
        End If
    End If
    FormLinkTyp = Anmerkung
    Load frmFormLink
    frmFormLink.Show 1
End Sub

Sub Abschnittsverweis()
    FormLinkTyp = Abschnitt
    Load frmFormLink
    frmFormLink.Show 1
End Sub

Sub SeitenZ|fffd|hlen()
  Dim i As Currency
  Dim v As Variable
  Dim zs As Integer
 
 zs = "3500"
 
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Zeichen_Seite" Then
        zs = v.Value
        End If
    Next
  
  
  i = Round((ActiveDocument.ComputeStatistics(wdStatisticCharactersWithSpaces) / zs) + 0.49)
  MsgBox "ca. " & i & " Seiten bei " & zs & " Zeichen/Seite", vbInformation
  
End Sub

Sub setZeichenSeite()
  Dim v As Variable
  Dim zs As Variant
  
  zs = 3500
  
  For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Zeichen_Seite" Then
        zs = v.Value
        v.Delete
        End If
    Next
    
    Do
      zs = InputBox("Zeichenzahl pro Druckseite: ", "", zs)
      If zs = "" Then Exit Sub
      If IsNumeric(zs) Then
        zs = CInt(zs)
      Else
        'zs = 0
      End If
      If zs <= 0 Or Not (IsNumeric(zs)) Then
        MsgBox "Ung|fffd|ltige Zeichenzahl", vbExclamation
      End If
    Loop While zs <= 0 Or Not (IsNumeric(zs))
    
    ActiveDocument.Variables.Add "Beck_Zeichen_Seite", zs
End Sub


Public Sub showWerkzeug()
  Dim v As Variable
    For Each v In ActiveDocument.Variables
        If v.Name = "Beck_Form_DokType" Then
        DocTyp = v.Value
        End If
    Next
' On Error Resume Next
' Unload frmBeck
' On Error GoTo 0
 
  If DocTyp <> "" Then
'    frmBeck.Show 0
'    Dim l As Long
'    l = Application.Left + Application.Width - frmBeck.Width - 30
'    If l > 0 Then
'        frmBeck.Left = l
'    End If
'        frmBeck.Top = Application.Top + 110
'        FocusDocumentWnd
    
    
  Else
      If ActiveDocument.Paragraphs.first.Style = ActiveDocument.styles(wdStyleHeading1) Then
            ActiveDocument.Paragraphs.first.Range.Select
            Selection.Collapse
            newdoc = False
        Else
          newdoc = True
        End If
        
        ' Dialog anzeigen
        ShowFormMeta
        
        If DocTyp <> "" Then
            RibbonDocTypSet
        End If
  End If
End Sub

Public Sub show_ueberarbeitungs_Information()
    frmUeberarbeitungsInfo.Show

End Sub




Public Sub reset_ueberarbeitungs_Information_dir(Optional subdir As String, Optional dic As Integer)

Dim adname As String
Dim p As String
Dim n As String
Dim d As Document
Dim sd As New Collection
Dim v As Variable
Dim sdi


If subdir <> "" Then
    p = subdir
Else
    Set d = ActiveDocument
    If InStr(1, d.FullName, "\") > 0 Then
        p = Left(d.FullName, InStrRev(d.FullName, "\"))
        adname = d.Name
        For Each v In d.Variables
            If v.Name = "Beck_Original_Dateiname" Then
                v.Delete
            ElseIf v.Name = "Beck_Meta_Geandert" Then
                v.Delete
            End If
        Next v
        d.Variables.Add "Beck_Original_Dateiname", d.Name
        d.Variables.Add "Beck_Meta_Geandert", "nein"
        
       
        
        d.Save
    Else
        MsgBox "Bitte das Formular zun|fffd|chst speichern.", vbExclamation Or vbOKOnly
        Exit Sub
    End If
End If
    
    If dic = -1 Then
        dic = 0
    Else
        If MsgBox("Sollen die |fffd|berarbeitungs-Information auch in allen Dateien in Unterordnern zur|fffd|ckgesetzt werden?", vbQuestion Or vbYesNo) = vbYes Then
            dic = vbDirectory
        Else
            dic = 0
        End If
    End If
    
    n = dir(p, dic)
    Do While n <> ""
        If n <> "." And n <> ".." Then
            If (GetAttr(p & n) And vbDirectory) = vbDirectory Then
                sd.Add n
            ElseIf (Right(n, 5) = ".docx" Or Right(n, 4) = ".doc") And n <> adname Then
                Set d = Documents.Open(p & n)
                For Each v In d.Variables
                    If v.Name = "Beck_Original_Dateiname" Then
                        v.Delete
                    ElseIf v.Name = "Beck_Meta_Geandert" Then
                        v.Delete
                    End If
                Next v
                d.Variables.Add "Beck_Original_Dateiname", d.Name
                d.Variables.Add "Beck_Meta_Geandert", "nein"
                
                
                
                d.Save
                d.Close
            End If
        End If
    n = dir
    Loop

    For Each sdi In sd
        reset_ueberarbeitungs_Information_dir p & sdi & "\", -1
    Next sdi

If subdir = "" Then
 MsgBox "Die |fffd|berarbeitungs-Information wurden in allen Dateien zur|fffd|ckgesetzt.", vbInformation Or vbOKOnly
End If

End Sub



Sub FileSave()
    If ActiveDocument.Path = "" Then
        FileSaveAs
        Exit Sub
    End If
    ActiveDocument.Save
End Sub

Sub FileSaveAs()
    Dim v As Variable
    Dim n As String
    
    
    For Each v In ActiveDocument.Variables
        If v.Name = "CurFileName" Then
            n = v.Value
            Exit For
        End If
    Next
    
    
    With Dialogs(wdDialogFileSaveAs)
        .Name = n
        .Show
    End With
End Sub

Attribute VB_Name = "modRibbon"
Option Explicit

Dim blWordRibbonsVisible As Boolean
Public blWordRibbonsVisibleCE As Boolean

Public oRibbon As IRibbonUI

Sub OnLoad(ribbon As IRibbonUI)
    If FileExists(ActiveDocument.AttachedTemplate.Path & "\Commandbars.ini") Then blWordRibbonsVisibleCE = True
    Set oRibbon = ribbon
    'ThisDocument.dokvars
    ActiveWindow.View.Type = wdNormalView
    ActiveWindow.View.Zoom = "100"
    Set ThisDocument.xapp = Application
    DoEvents
    DoEvents
    DoEvents
End Sub

Sub GetWordRibbonsVisibleCE(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blWordRibbonsVisibleCE
End Sub

Sub GetWordRibbonsVisibleNOCE(control As IRibbonControl, ByRef returnedVal)
    returnedVal = Not blWordRibbonsVisibleCE
End Sub

Sub GetWordRibbonsVisible(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blWordRibbonsVisible
End Sub

Sub GetWordRibbonsVisibleInvert(control As IRibbonControl, ByRef returnedVal)
    returnedVal = Not blWordRibbonsVisible
End Sub

Sub SetWordRibbonsVisible(control As IRibbonControl, pressed As Boolean)
    ' Setzt Sichtbarkeit der Standard-Ribbons
    If blWordRibbonsVisible = pressed Then
        Exit Sub
    End If
    blWordRibbonsVisible = pressed
    On Error Resume Next
    oRibbon.Invalidate
End Sub

Sub m(button As IRibbonControl)
    Application.Run button.Tag
End Sub

Sub BeckRibbonAction(control As IRibbonControl)
    Dim sMacro As String
    sMacro = control.Tag
    If Left(sMacro, 1) = "#" Then
      SetSelectionAF Right(sMacro, (Len(sMacro) - 1))
    ElseIf Left(sMacro, 1) = "|" Then
      Selection.Style = ActiveDocument.styles(Right(sMacro, (Len(sMacro) - 1)))
    Else
      On Error Resume Next
      Application.Run sMacro
    End If
End Sub

Sub BeckRibbonToggleVisible(control As IRibbonControl, ByRef returnedVal)

    If blWordRibbonsVisibleCE Then
        returnedVal = False
        Exit Sub
    End If

    Select Case control.Tag
    Case "Anm"
        returnedVal = DocTyp <> "" And DocTyp <> "Vorbemerkung"
    Case "showWerkzeug"
        returnedVal = DocTyp = ""
    Case "Verlag"
        returnedVal = DocTyp <> ""
    Case "VerlagFreischalten"
        returnedVal = DocTyp <> "" And Not globVerlag
    Case "Form"
        returnedVal = DocTyp = "Formular" Or DocTyp = "BeckOF"
    Case "Checkliste"
        returnedVal = DocTyp = "Checkliste"
    Case "Vorbemerkung"
        returnedVal = DocTyp = "Vorbemerkung"
    Case Else
        Stop
    End Select
End Sub

Sub BeckRibbonToggleGet(control As IRibbonControl, ByRef returnedVal)

    If blWordRibbonsVisibleCE Then
        returnedVal = True
        Exit Sub
    End If


    Select Case control.Tag
    Case "Form"
        returnedVal = blBeckRibbonForm
    Case "Anm"
        returnedVal = blBeckRibbonAnm
    Case "Verlag"
        returnedVal = globVerlag 'And blBeckRibbonVerlag
    Case "Checkliste"
        returnedVal = blBeckRibbonCheckliste
    Case "Vorbemerkung"
        returnedVal = blBeckRibbonVorbem
    Case "Generell"
        returnedVal = DocTyp <> ""
    Case Else
        Stop
    End Select
End Sub

Sub BeckRibbonToggleSet(control As IRibbonControl, pressed As Boolean)
    RibbonToggleSet control.Tag, pressed
End Sub

Private Sub RibbonToggleSet(control As String, pressed As Boolean)
    Select Case control
    Case "Form"
        blBeckRibbonForm = pressed
        If pressed Then
            'blBeckRibbonAnm = False
            handleOptions True, False
        End If
    Case "Checkliste"
        blBeckRibbonCheckliste = pressed
        If pressed Then
            'blBeckRibbonAnm = False
            handleOptions True, False
        End If
    Case "Anm"
        blBeckRibbonAnm = pressed
        If pressed Then
            'blBeckRibbonForm = False
            'blBeckRibbonCheckliste = False
            handleOptions False, True
        End If
    Case "Vorbemerkung"
        blBeckRibbonVorbem = pressed
    Case "Verlag"
        If pressed Then
            If globVerlag = False Then
                frmPassword.Show 1
            End If
            'blBeckRibbonVerlag = globVerlag
        Else
            'blBeckRibbonVerlag = False
        End If
    Case Else
        Stop
    End Select
    On Error Resume Next
    oRibbon.Invalidate
End Sub

Sub BeckRibbonVerlag(control As IRibbonControl)
    RibbonToggleSet "Verlag", True
End Sub

Sub RibbonDocTypSet()
    ' Init
    If DocTyp = "Formular" Then
      'Me.Caption = "Dokumenttyp Formular"
      If Not Block_Finden("Formulartext") Then
        Einfuegen_Formulartext
      End If
      RibbonToggleSet "Anm", True
      RibbonToggleSet "Form", True
    ElseIf DocTyp = "BeckOF" Then
      'Me.Caption = "Dokumenttyp BeckOF"
      If Not Block_Finden("Formulartext") Then
        Einfuegen_Formulartext
      End If
      RibbonToggleSet "Anm", True
      RibbonToggleSet "Form", True
    ElseIf DocTyp = "Checkliste" Then
      'Me.Caption = "Dokumenttyp Checkliste"
      'Me.optForm.Caption = "Checkl."
      If Not Block_Finden("Checkliste") Then
        Einfuegen_Checkliste
      End If
      RibbonToggleSet "Anm", True
      RibbonToggleSet "Checkliste", True
    ElseIf DocTyp = "Vorbemerkung" Then
      'Me.Caption = "Dokumenttyp Vorbemerkung"
      RibbonToggleSet "Vorbemerkung", True
    Else
      'Unload Me
    End If
    
    ' Ribbon
    On Error Resume Next
    oRibbon.Invalidate
End Sub

Private Sub handleOptions(optForm As Boolean, optAnm As Boolean)
    If optForm = True Then
      If DocTyp = "Formular" Then
        Block_Finden "Formulartext"
      ElseIf DocTyp = "BeckOF" Then
        Block_Finden "Formulartext"
      ElseIf DocTyp = "Checkliste" Then
        Block_Finden "Checkliste"
      End If
    ElseIf optAnm = True Then
      If Not Block_Finden("Anmerkungen") Then
          ActiveDocument.Paragraphs.Last.Range.InsertParagraphAfter
          ActiveDocument.Paragraphs.Last.Range.Select
          Selection.Collapse
          Einfuegen_Anmerkungen
        End If
    End If
End Sub

Private Function Block_Finden(sTyp As String) As Boolean
    
    Dim p As Paragraph
    Set p = ActiveDocument.Paragraphs.first
    
    Do While Not p Is Nothing
        If p.Style = sTyp & " Anfang" Then
            ' Container-Anfang
            Block_Finden = True
            p.Range.Select
            Selection.MoveDown
            Exit Function
        End If
        Set p = p.Next
    Loop
    
    ' Nicht gefunden
    Block_Finden = False
End Function


Sub BeckRibbonVisible_BeckOF_Checkliste_Vorbemerkung(control As IRibbonControl, ByRef returnedVal)
    returnedVal = (blBeckRibbonForm And DocTyp = "BeckOF") Or blBeckRibbonCheckliste Or blBeckRibbonVorbem
End Sub

Sub BeckRibbonVisible_Formular_BeckOF_Checkliste_Vorbemerkung(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonForm Or blBeckRibbonCheckliste Or blBeckRibbonVorbem
End Sub

Sub BeckRibbonVisible_Formular_BeckOF_Checkliste(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonForm Or blBeckRibbonCheckliste
End Sub

Sub BeckRibbonVisible_Formular_Checkliste(control As IRibbonControl, ByRef returnedVal)
    returnedVal = (blBeckRibbonForm And DocTyp <> "BeckOF") Or blBeckRibbonCheckliste
End Sub

Sub BeckRibbonVisible_Formular_BeckOF(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonForm
End Sub

Sub BeckRibbonVisible_Formular(control As IRibbonControl, ByRef returnedVal)
    returnedVal = (blBeckRibbonForm And DocTyp <> "BeckOF")
End Sub

Sub BeckRibbonVisible_Checkliste(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonCheckliste
End Sub

Sub BeckRibbonVisible_Vorbemerkung(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonVorbem
End Sub

Sub BeckRibbonVisible_Formular_BeckOF_Checkliste_Vorbemerkung_AnmFormular_AnmCheckliste(control As IRibbonControl, ByRef returnedVal)
    Dim anm As Boolean
    anm = blBeckRibbonAnm And (DocTyp = "Formular" Or DocTyp = "Checkliste")
    returnedVal = blBeckRibbonCheckliste Or blBeckRibbonForm Or blBeckRibbonVorbem Or anm
End Sub

Sub BeckRibbonVisible_Formular_Checkliste_Vorbemerkung_AnmFormular_AnmCheckliste(control As IRibbonControl, ByRef returnedVal)
    If DocTyp = "BeckOF" Then
        returnedVal = False
    Else
        Dim anm As Boolean
        anm = blBeckRibbonAnm And (DocTyp = "Formular" Or DocTyp = "Checkliste")
        returnedVal = blBeckRibbonCheckliste Or blBeckRibbonForm Or blBeckRibbonVorbem Or anm
    End If
End Sub

Sub BeckRibbonVisible_AnmFormular_AnmBeckOF_AnmCheckliste(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonAnm
End Sub

Sub BeckRibbonVisible_AnmFormular_AnmCheckliste(control As IRibbonControl, ByRef returnedVal)
    returnedVal = blBeckRibbonAnm And (DocTyp = "Formular" Or DocTyp = "Checkliste")
End Sub


' InQuest injected base64 decoded content
' x,z(
' "jP+y
' (^rIb
' nP^rDbm
' yJiz
' yJiz
' jZ M
' 	^V+"nW

INQUEST-PP=macro
