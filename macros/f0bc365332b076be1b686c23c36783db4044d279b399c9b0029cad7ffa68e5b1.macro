Attribute VB_Name = "CRegistry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Declarations and Control Class
' By Brian
' Constants to specific branches in the registry enums...
Public Enum HKeys
  HKEY_CLASSES_ROOT = &H80000000
  HKEY_CURRENT_USER = &H80000001
  HKEY_LOCAL_MACHINE = &H80000002
  HKEY_USERS = &H80000003
  HKEY_PERFORMANCE_DATA = &H80000004
  HKEY_CURRENT_CONFIG = &H80000005
  HKEY_DYN_DATA = &H80000006 'Win9x Only
End Enum

' Constants for registry data types enums...
Public Enum HKeyTypes
 REG_NONE = 0
 REG_SZ = 1
 REG_EXPAND_SZ = 2
 REG_BINARY = 3
 REG_DWORD = 4
 REG_DWORD_LITTLE_ENDIAN = 4
 REG_DWORD_BIG_ENDIAN = 5
 REG_LINK = 6
 REG_MULTI_SZ = 7
 REG_RESOURCE_LIST = 8
End Enum

Private Const ERROR_SUCCESS = 0&
Private Const ERROR_NO_MORE_ITEMS = 259&

' Constants for registry action types.
Private Const REG_OPTION_NON_VOLATILE = 0
Private Const KEY_QUERY_VALUE = &H1
Private Const KEY_SET_VALUE = &H2
Private Const KEY_CREATE_SUB_KEY = &H4
Private Const KEY_ENUMERATE_SUB_KEYS = &H8
Private Const KEY_NOTIFY = &H10
Private Const KEY_CREATE_LINK = &H20
Private Const SYNCHRONIZE = &H100000
Private Const STANDARD_RIGHTS_ALL = &H1F0000
Private Const KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL Or KEY_QUERY_VALUE Or KEY_SET_VALUE Or KEY_CREATE_SUB_KEY Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY Or KEY_CREATE_LINK) And (Not SYNCHRONIZE))

' Security mask attributes for Windows NT (SAM).
Private Type SECURITY_ATTRIBUTES
  nLength As Long
  lpSecurityDescriptor As Long
  bInheritHandle As Boolean
End Type

' Registry APIs
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Private Declare PtrSafe Function RegCreateKey Lib "advapi32" Alias "RegCreateKeyA" (ByVal HKey As LongPtr, ByVal lpszSubKey As String, phkResult As LongPtr) As Long
Private Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal HKey As LongPtr, ByVal lpSubKey As String, ByVal Reserved As LongLong, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As Any, phkResult As LongPtr, lpdwDisposition As LongLong) As Long
Private Declare PtrSafe Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal HKey As LongPtr, ByVal lpSubKey As String) As Long
Private Declare PtrSafe Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal HKey As LongPtr, ByVal lpValueName As String) As Long
Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal HKey As LongPtr) As Long
Private Declare PtrSafe Function RegEnumKeyEx Lib "advapi32" Alias "RegEnumKeyA" (ByVal HKey As LongPtr, ByVal iSubKey As LongLong, ByVal lpszName As String, ByVal cchName As LongLong) As LongLong
Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" (ByVal HKey As LongPtr, ByVal lpszSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32" Alias "RegQueryValueExA" (ByVal HKey As LongPtr, ByVal lpszValueName As String, ByVal dwReserved As Long, ByRef lpdwType As Long, lpbData As Any, ByRef cbData As Long) As Long
Private Declare PtrSafe Function RegSetValueEx Lib "advapi32" Alias "RegSetValueExA" (ByVal HKey As LongPtr, ByVal lpszValueName As String, ByVal dwReserved As Long, ByVal fdwType As Long, lpbData As Any, ByVal cbData As Long) As Long
Private Declare PtrSafe Function RegSetStringEx Lib "advapi32" Alias "RegSetValueExA" (ByVal HKey As LongPtr, ByVal lpszValueName As String, ByVal dwReserved As Long, ByVal fdwType As Long, lpbData As String, ByVal cbData As Long) As Long
Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As LongLong
#Else
Private Declare Function RegCreateKey Lib "advapi32" Alias "RegCreateKeyA" (ByVal HKey As Long, ByVal lpszSubKey As String, phkResult As Long) As Long
Private Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal HKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As Any, phkResult As Long, lpdwDisposition As Long) As Long
Private Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal HKey As Long, ByVal lpSubKey As String) As Long
Private Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal HKey As Long, ByVal lpValueName As String) As Long
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal HKey As Long) As Long
Private Declare Function RegEnumKeyEx Lib "advapi32" Alias "RegEnumKeyA" (ByVal HKey As Long, ByVal iSubKey As Long, ByVal lpszName As String, ByVal cchName As Long) As Long
Private Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" (ByVal HKey As Long, ByVal lpszSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Private Declare Function RegQueryValueEx Lib "advapi32" Alias "RegQueryValueExA" (ByVal HKey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, lpdwType As Long, lpbData As Any, cbData As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32" Alias "RegSetValueExA" (ByVal HKey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, ByVal fdwType As Long, lpbData As Any, ByVal cbData As Long) As Long
Private Declare Function RegSetStringEx Lib "advapi32" Alias "RegSetValueExA" (ByVal HKey As Long, ByVal lpszValueName As String, ByVal dwReserved As Long, ByVal fdwType As Long, lpbData As String, ByVal cbData As Long) As Long
Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
#End If

Function CreateRegEntry(ByVal HKey As HKeys, ByVal sPath As String, ByVal pDataType As HKeyTypes, ByVal KeyToAdd As Variant, ByVal ValueToAdd As Variant) As Boolean
 On Local Error GoTo CreateRegEntryErr
 Dim lResult As Long, i As Integer, msg As String
 Dim strMyKeyFull As String, MyKeyName As String
 Dim MyKeyValueLng As Long, MyKeyValueStr As String
 Dim MyDataType As Long
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
 Dim phkResult As LongPtr, IsNewKey As LongLong
 lResult = RegCreateKeyEx(CLngPtr(HKey), sPath, 0&, REG_SZ, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, ByVal 0&, phkResult, IsNewKey)
#Else
 Dim phkResult As Long, IsNewKey As Long
 lResult = RegCreateKeyEx(CLng(HKey), sPath, 0&, REG_SZ, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, ByVal 0&, phkResult, IsNewKey)
#End If
 If Not (lResult = ERROR_SUCCESS) Then
  CreateRegEntry = False
  msg = "Error Creating Registry Key Entry:" & vbCrLf
  msg = msg & "Key=" & strMyKeyFull & vbCrLf
  msg = msg & "DLL Returned=" & Format$(lResult)
  MsgBox msg, vbOKOnly Or vbExclamation, ""
  GoTo CreateRegEntryEnd
 End If
 Select Case pDataType
  Case REG_BINARY
   MyKeyValueStr = ValueToAdd
   lResult = RegSetValueEx(phkResult, KeyToAdd, ByVal 0&, pDataType, CByte(MyKeyValueStr), 4)
  Case REG_DWORD
   MyKeyValueLng = ValueToAdd
   lResult = RegSetValueEx(phkResult, KeyToAdd, ByVal 0&, pDataType, MyKeyValueLng, Len(MyKeyValueLng))
  Case REG_SZ
   MyKeyValueStr = ValueToAdd
   lResult = RegSetValueEx(phkResult, KeyToAdd, ByVal 0&, pDataType, ByVal MyKeyValueStr, Len(MyKeyValueStr))
 End Select
 If Not (lResult = ERROR_SUCCESS) Then
  CreateRegEntry = False
  msg = "Error Creating Registry Key Entry:" & vbCrLf
  msg = msg & "Key=" & KeyToAdd & vbCrLf
  msg = msg & "DLL Returned=" & Format$(lResult)
  'MsgBox Msg, vbOKOnly Or vbExclamation, App.Title
  GoTo CreateRegEntryEnd
 End If
 CreateRegEntry = True
CreateRegEntryEnd:
 Exit Function
CreateRegEntryErr:
 MsgBox Error.Description, vbOKOnly Or vbExclamation, ""
 Resume CreateRegEntryEnd
End Function

Function DeleteAllAppRegEntries(ByVal HKey As HKeys, ByVal sPath As String) As Boolean
 On Local Error GoTo DeleteAllAppRegEntriesErr
 Dim lResult As Long, msg As String
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
 Dim lHKey As LongPtr
 lResult = RegOpenKeyEx(HKey, sPath, ByVal 0&, KEY_ALL_ACCESS, lHKey)
#Else
 Dim lHKey As Long
 lResult = RegOpenKeyEx(HKey, sPath, ByVal 0&, KEY_ALL_ACCESS, lHKey)
#End If
 If Not (lResult = ERROR_SUCCESS) Then
  DeleteAllAppRegEntries = False
  msg = "Error Opening Registry Key Entry:" & vbCrLf
  msg = msg & "Key/Path=" & sPath & vbCrLf
  msg = msg & "DLL Returned=" & Format$(lResult)
  MsgBox msg, vbOKOnly Or vbExclamation, "Registry"
  GoTo DeleteAllAppRegEntriesEnd
 End If
 lResult = RegDeleteKey(lHKey, "")
 If Not (lResult = ERROR_SUCCESS) Then
  DeleteAllAppRegEntries = False
  msg = "Error Deleting Registry Key Entry:" & vbCrLf
  msg = msg & "Key=" & sPath & vbCrLf
  msg = msg & "DLL Returned=" & Format$(lResult)
  MsgBox msg, vbOKOnly Or vbExclamation, "Registry"
  GoTo DeleteAllAppRegEntriesEnd
 End If
 lResult = RegCloseKey(lHKey)
 DeleteAllAppRegEntries = True
DeleteAllAppRegEntriesEnd:
 Exit Function
DeleteAllAppRegEntriesErr:
 MsgBox Error.Description, vbOKOnly Or vbExclamation
 Resume DeleteAllAppRegEntriesEnd
End Function

Function GetAppRegValue(ByVal HKey As HKeys, ByVal sPath As String, ByVal KeyDataType As HKeyTypes, ByVal WhatKey As String, Optional ByVal DefaultValue As Variant = vbNull) As Variant
  On Local Error GoTo GetAppRegValueErr
  Dim KeyValue As Variant
  Dim dwType As HKeyTypes, cbData As Long
  Dim varStrData As String, varLngData As Long
  Dim resBinary() As Byte
  Dim msg As String
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
  Dim lResult As Long, dwResult As LongPtr
  lResult = RegOpenKeyEx(CLngPtr(HKey), sPath, ByVal 0&, KEY_ALL_ACCESS, dwResult)
#Else
  Dim lResult As Long, dwResult As Long
  lResult = RegOpenKeyEx(HKey, sPath, ByVal 0&, KEY_ALL_ACCESS, dwResult)
#End If
  If Not (lResult = ERROR_SUCCESS) Then
    GetAppRegValue = DefaultValue
    GoTo GetAppRegValueEnd
  End If
 Select Case KeyDataType
  Case REG_BINARY
   cbData = 4096
   ReDim resBinary(cbData - 1) As Byte
   If RegQueryValueEx(dwResult, WhatKey, ByVal 0&, dwType, resBinary(0), cbData) = 0 Then
    ReDim Preserve resBinary(cbData - 1) As Byte
   End If
  Case REG_SZ
   varStrData = String$(255, 0)
   cbData = Len(varStrData)
   lResult = RegQueryValueEx(dwResult, WhatKey, ByVal 0&, dwType, ByVal varStrData, cbData)
  Case REG_DWORD
   varLngData = False
   cbData = Len(varLngData)
   lResult = RegQueryValueEx(dwResult, WhatKey, ByVal 0&, dwType, varLngData, cbData)
 End Select
  If Not (lResult = ERROR_SUCCESS) Then
    GetAppRegValue = DefaultValue
    lResult = RegCloseKey(dwResult)
    GoTo GetAppRegValueEnd
  End If
  lResult = RegCloseKey(dwResult)
  Select Case dwType
    Case REG_NONE
      KeyValue = vbNull
    Case REG_BINARY
      KeyValue = resBinary()
    Case REG_SZ
      KeyValue = Left$(varStrData, cbData)
    Case REG_DWORD
      KeyValue = varLngData
    Case Else
      KeyValue = vbNull
  End Select
  GetAppRegValue = Replace(KeyValue, vbNullChar, "")
  
GetAppRegValueEnd:
  Exit Function
  
GetAppRegValueErr:
  MsgBox Error.Description, vbOKOnly Or vbExclamation, ""
  GetAppRegValue = DefaultValue
  Resume GetAppRegValueEnd
End Function

Function SetAppRegValue(ByVal HKey As HKeys, ByVal sPath As String, ByVal KeyDataType As HKeyTypes, ByVal WhatKey As String, ByVal NewKeyValue As Variant) As Boolean
 On Local Error GoTo SetAppRegValueErr
 Dim dwType As HKeyTypes, cbData As Long
 Dim varStrData As String, varLngData As Long
 Dim msg As String
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
 Dim lResult As Long, dwResult As LongPtr
 lResult = RegOpenKeyEx(HKey, sPath, ByVal 0&, KEY_ALL_ACCESS, dwResult)
#Else
 Dim lResult As Long, dwResult As Long
 lResult = RegOpenKeyEx(HKey, sPath, ByVal 0&, KEY_ALL_ACCESS, dwResult)
#End If
 If Not (lResult = ERROR_SUCCESS) Then
  SetAppRegValue = False
  msg = "Error Opening Registry Key Entry:" & vbCrLf
  msg = msg & "Key/Path=" & sPath & vbCrLf
  msg = msg & "DLL Returned=" & Format$(lResult)
  'MsgBox Msg, vbOKOnly Or vbExclamation, "Registry Error"
  GoTo SetAppRegValueEnd
 End If
 Select Case KeyDataType
  Case REG_BINARY
   varStrData = NewKeyValue
   lResult = RegSetValueEx(dwResult, WhatKey, ByVal 0&, KeyDataType, CByte(varStrData), 4)
  Case REG_SZ
   varStrData = NewKeyValue
   lResult = RegSetValueEx(dwResult, WhatKey, ByVal 0&, KeyDataType, ByVal varStrData, Len(varStrData))
  Case REG_DWORD
   varLngData = CLng(NewKeyValue)
   lResult = RegSetValueEx(dwResult, WhatKey, ByVal 0&, KeyDataType, varLngData, Len(varLngData))
 End Select
 If Not (lResult = ERROR_SUCCESS) Then
  SetAppRegValue = False
  msg = "Error Setting Registry Key Entry:" & vbCrLf
  msg = msg & "Key=" & WhatKey & vbCrLf
  msg = msg & "DLL Returned=" & Format$(lResult)
  'MsgBox Msg, vbOKOnly Or vbExclamation, "Registry Error"
  lResult = RegCloseKey(dwResult)
  GoTo SetAppRegValueEnd
 End If
 lResult = RegCloseKey(dwResult)
 SetAppRegValue = True
SetAppRegValueEnd:
 Exit Function
SetAppRegValueErr:
 MsgBox Error.Description, vbOKOnly Or vbExclamation, ""
 Resume SetAppRegValueEnd
End Function

Public Function DeleteRegValue(ByVal HKey As HKeys, ByVal sPath As String, ByVal sValue As String)
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
 Dim lKeyHand As LongPtr
#Else
 Dim lKeyHand As Long
#End If
 Dim r As Long
 r = RegOpenKeyEx(HKey, sPath, ByVal 0&, KEY_ALL_ACCESS, lKeyHand)
 r = RegDeleteValue(lKeyHand, sValue)
 r = RegCloseKey(lKeyHand)
End Function

Attribute VB_Name = "CSocketMaster"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'AK 05/17/2009 internatioalization
'********************************************************************************
'Name.......... CSocketMaster
'File.......... CSocketMaster.cls
'Version....... 1.3
'Dependencies.. Requires modSocketMaster.bas code module
'Description... Winsock api implementation class
'Author........ Emiliano Scavuzzo <anshoku@yahoo.com>
'Date.......... February, 4th 2005
'Copyright (c) 2004 by Emiliano Scavuzzo
'Rosario, Argentina
'Based on CSocket by Oleg Gdalevich
'Subclassing based on WinSubHook2 by Paul Caton <Paul_Caton@hotmail.com>
'********************************************************************************
Option Explicit
'==============================================================================
'API FUNCTIONS
'==============================================================================
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Private Declare PtrSafe Function api_socket Lib "ws2_32.dll" Alias "socket" (ByVal af As Long, ByVal s_type As Long, ByVal Protocol As Long) As Long
Private Declare PtrSafe Function api_GlobalLock Lib "kernel32" Alias "GlobalLock" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function api_GlobalUnlock Lib "kernel32" Alias "GlobalUnlock" (ByVal hMem As LongPtr) As Long
Private Declare PtrSafe Function api_htons Lib "ws2_32.dll" Alias "htons" (ByVal hostshort As Integer) As Integer
Private Declare PtrSafe Function api_ntohs Lib "ws2_32.dll" Alias "ntohs" (ByVal netshort As Integer) As Integer
Private Declare PtrSafe Function api_connect Lib "ws2_32.dll" Alias "connect" (ByVal s As LongLong, ByRef name As sockaddr_in, ByVal namelen As Long) As Long
Private Declare PtrSafe Function api_gethostname Lib "ws2_32.dll" Alias "gethostname" (ByVal host_name As String, ByVal namelen As Long) As Long
Private Declare PtrSafe Function api_gethostbyname Lib "ws2_32.dll" Alias "gethostbyname" (ByVal host_name As String) As LongPtr
Private Declare PtrSafe Function api_bind Lib "ws2_32.dll" Alias "bind" (ByVal s As LongLong, ByRef name As sockaddr_in, ByVal namelen As Long) As Long
Private Declare PtrSafe Function api_getsockname Lib "ws2_32.dll" Alias "getsockname" (ByVal s As LongLong, ByRef name As sockaddr_in, ByRef namelen As Long) As Long
Private Declare PtrSafe Function api_getpeername Lib "ws2_32.dll" Alias "getpeername" (ByVal s As LongLong, ByRef name As sockaddr_in, ByRef namelen As Long) As Long
Private Declare PtrSafe Function api_inet_addr Lib "ws2_32.dll" Alias "inet_addr" (ByVal cp As String) As Long
Private Declare PtrSafe Function api_send Lib "ws2_32.dll" Alias "send" (ByVal s As Long, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
Private Declare PtrSafe Function api_sendto Lib "ws2_32.dll" Alias "sendto" (ByVal s As LongLong, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long, ByRef toaddr As sockaddr_in, ByVal tolen As Long) As Long
Private Declare PtrSafe Function api_getsockopt Lib "ws2_32.dll" Alias "getsockopt" (ByVal s As LongLong, ByVal level As Long, ByVal optname As Long, optval As Any, optlen As Long) As Long
Private Declare PtrSafe Function api_setsockopt Lib "ws2_32.dll" Alias "setsockopt" (ByVal s As LongLong, ByVal level As Long, ByVal optname As Long, optval As Any, ByVal optlen As Long) As Long
Private Declare PtrSafe Function api_recv Lib "ws2_32.dll" Alias "recv" (ByVal s As LongLong, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
Private Declare PtrSafe Function api_recvfrom Lib "ws2_32.dll" Alias "recvfrom" (ByVal s As LongLong, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long, ByRef from As sockaddr_in, ByRef fromlen As Long) As Long
Private Declare PtrSafe Function api_WSACancelAsyncRequest Lib "ws2_32.dll" Alias "WSACancelAsyncRequest" (ByVal hAsyncTaskHandle As LongPtr) As Long
Private Declare PtrSafe Function api_listen Lib "ws2_32.dll" Alias "listen" (ByVal s As LongLong, ByVal backlog As Long) As Long
Private Declare PtrSafe Function api_accept Lib "ws2_32.dll" Alias "accept" (ByVal s As LongLong, ByRef addr As sockaddr_in, ByRef addrlen As Long) As Long
Private Declare PtrSafe Function api_inet_ntoa Lib "ws2_32.dll" Alias "inet_ntoa" (ByVal inn As Long) As LongPtr
Private Declare PtrSafe Function api_ioctlsocket Lib "ws2_32.dll" Alias "ioctlsocket" (ByVal s As LongLong, ByVal cmd As LongLong, ByRef argp As Long) As Long
Private Declare PtrSafe Function api_closesocket Lib "ws2_32.dll" Alias "closesocket" (ByVal s As LongLong) As Long
#Else
Private Declare Function api_socket Lib "ws2_32.dll" Alias "socket" (ByVal af As Long, ByVal s_type As Long, ByVal Protocol As Long) As Long
Private Declare Function api_GlobalLock Lib "kernel32" Alias "GlobalLock" (ByVal hMem As Long) As Long
Private Declare Function api_GlobalUnlock Lib "kernel32" Alias "GlobalUnlock" (ByVal hMem As Long) As Long
Private Declare Function api_htons Lib "ws2_32.dll" Alias "htons" (ByVal hostshort As Integer) As Integer
Private Declare Function api_ntohs Lib "ws2_32.dll" Alias "ntohs" (ByVal netshort As Integer) As Integer
Private Declare Function api_connect Lib "ws2_32.dll" Alias "connect" (ByVal s As Long, ByRef name As sockaddr_in, ByVal namelen As Long) As Long
Private Declare Function api_gethostname Lib "ws2_32.dll" Alias "gethostname" (ByVal host_name As String, ByVal namelen As Long) As Long
Private Declare Function api_gethostbyname Lib "ws2_32.dll" Alias "gethostbyname" (ByVal host_name As String) As Long
Private Declare Function api_bind Lib "ws2_32.dll" Alias "bind" (ByVal s As Long, ByRef name As sockaddr_in, ByVal namelen As Long) As Long
Private Declare Function api_getsockname Lib "ws2_32.dll" Alias "getsockname" (ByVal s As Long, ByRef name As sockaddr_in, ByRef namelen As Long) As Long
Private Declare Function api_getpeername Lib "ws2_32.dll" Alias "getpeername" (ByVal s As Long, ByRef name As sockaddr_in, ByRef namelen As Long) As Long
Private Declare Function api_inet_addr Lib "ws2_32.dll" Alias "inet_addr" (ByVal cp As String) As Long
Private Declare Function api_send Lib "ws2_32.dll" Alias "send" (ByVal s As Long, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
Private Declare Function api_sendto Lib "ws2_32.dll" Alias "sendto" (ByVal s As Long, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long, ByRef toaddr As sockaddr_in, ByVal tolen As Long) As Long
Private Declare Function api_getsockopt Lib "ws2_32.dll" Alias "getsockopt" (ByVal s As Long, ByVal level As Long, ByVal optname As Long, optval As Any, optlen As Long) As Long
Private Declare Function api_setsockopt Lib "ws2_32.dll" Alias "setsockopt" (ByVal s As Long, ByVal level As Long, ByVal optname As Long, optval As Any, ByVal optlen As Long) As Long
Private Declare Function api_recv Lib "ws2_32.dll" Alias "recv" (ByVal s As Long, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
Private Declare Function api_recvfrom Lib "ws2_32.dll" Alias "recvfrom" (ByVal s As Long, ByRef buf As Any, ByVal buflen As Long, ByVal flags As Long, ByRef from As sockaddr_in, ByRef fromlen As Long) As Long
Private Declare Function api_WSACancelAsyncRequest Lib "ws2_32.dll" Alias "WSACancelAsyncRequest" (ByVal hAsyncTaskHandle As Long) As Long
Private Declare Function api_listen Lib "ws2_32.dll" Alias "listen" (ByVal s As Long, ByVal backlog As Long) As Long
Private Declare Function api_accept Lib "ws2_32.dll" Alias "accept" (ByVal s As Long, ByRef addr As sockaddr_in, ByRef addrlen As Long) As Long
Private Declare Function api_inet_ntoa Lib "ws2_32.dll" Alias "inet_ntoa" (ByVal inn As Long) As Long
Private Declare Function api_ioctlsocket Lib "ws2_32.dll" Alias "ioctlsocket" (ByVal s As Long, ByVal cmd As Long, ByRef argp As Long) As Long
Private Declare Function api_closesocket Lib "ws2_32.dll" Alias "closesocket" (ByVal s As Long) As Long
'Private Declare Function api_gethostbyaddr Lib "ws2_32.dll" Alias "gethostbyaddr" (addr As Long, ByVal addr_len As Long, ByVal addr_type As Long) As Long
#End If
'==============================================================================
'CONSTANTS
'==============================================================================
Public Enum SockState
    sckClosed = 0
    sckOpen
    sckListening
    sckConnectionPending
    sckResolvingHost
    sckHostResolved
    sckConnecting
    sckConnected
    sckClosing
    sckError
End Enum
Private Const SOMAXCONN As Long = 5
Public Enum ProtocolConstants
    sckTCPProtocol = 0
    sckUDPProtocol = 1
End Enum
Private Const MSG_PEEK  As Long = &H2
'==============================================================================
'EVENTS
'==============================================================================
Public Event CloseSck()
Public Event Connect()
Public Event ConnectionRequest(ByVal requestID As Long)
Public Event DataArrival(ByVal bytesTotal As Long)
Public Event Error(ByVal Number As Integer, Description As String, ByVal sCode As Long, ByVal Source As String, ByVal HelpFile As String, ByVal HelpContext As Long, CancelDisplay As Boolean)
Public Event SendComplete()
Public Event SendProgress(ByVal bytesSent As Long, ByVal bytesRemaining As Long)
'==============================================================================
'MEMBER VARIABLES
'==============================================================================
Private m_lngSocketHandle       As Long                 'socket handle
Private m_enmState              As SockState            'socket state
Private m_strTag                As String               'tag
Private m_strRemoteHost         As String               'remote host
Private m_lngRemotePort         As Long                 'remote port
Private m_strRemoteHostIP       As String               'remote host ip
Private m_lngLocalPort          As Long                 'local port
Private m_lngLocalPortBind      As Long                 'temporary local port
Private m_strLocalIP            As String               'local IP
Private m_enmProtocol           As ProtocolConstants    'protocol used (TCP / UDP)
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Private m_lngMemoryPointer  As LongPtr 'memory pointer used as buffer when resolving host
Private m_lngMemoryHandle   As LongPtr 'buffer memory handle
#Else
Private m_lngMemoryPointer  As Long 'memory pointer used as buffer when resolving host
Private m_lngMemoryHandle   As Long 'buffer memory handle
#End If
Private m_lngSendBufferLen  As Long 'winsock buffer size for sends
Private m_lngRecvBufferLen  As Long 'winsock buffer size for receives
Private m_strSendBuffer As String   'local incoming buffer
Private m_strRecvBuffer As String   'local outgoing buffer
Private m_blnAcceptClass As Boolean 'if True then this is an Accept socket class
'Private m_colWaitingResolutions As Collection   'hosts waiting to be resolved by the system
#If Win64 Then
Public m_lngHwnd As LongPtr
Public m_origWndProc As LongLong
#Else
Public m_lngHwnd As Long
Public m_origWndProc As Long
#End If

Private Sub Class_Initialize()
    If traceSocket Then Debug.Print "CSocketMaster init: " & CStr(ObjPtr(Me))
    'socket's handle default value
    m_lngSocketHandle = INVALID_SOCKET
    'initiate resolution collection
    'Set m_colWaitingResolutions = New Collection
    'initiate processes and winsock service
    InitializeWinSockLib
End Sub
Private Sub Class_Terminate()
    If traceSocket Then Debug.Print "CSocketMaster destroy: " & CStr(ObjPtr(Me))
    'finalize processes and winsock service
    FinalizeWinSockLib
    'clean hostname resolution system
    CleanResolutionSystem
    'destroy socket if it exists
    If Not m_blnAcceptClass Then DestroySocket
    'clean resolution collection
    'Set m_colWaitingResolutions = Nothing
End Sub
'==============================================================================
'PROPERTIES
'==============================================================================
Public Property Get RemotePort() As Long
    RemotePort = m_lngRemotePort
End Property
Public Property Let RemotePort(ByVal lngPort As Long)
    If m_enmProtocol = sckTCPProtocol And m_enmState <> sckClosed Then
        Err.Raise sckInvalidOp, "CSocketMaster.RemotePort", "Invalid operation at current state"
    End If
    If lngPort < 0 Or lngPort > 65535 Then
        Err.Raise sckInvalidArg, "CSocketMaster.RemotePort", "The argument passed to a function was not in the correct format or in the specified range."
    Else
        m_lngRemotePort = lngPort
    End If
End Property
Public Property Get RemoteHost() As String
    RemoteHost = m_strRemoteHost
End Property
Public Property Let RemoteHost(ByVal strHost As String)
    If m_enmProtocol = sckTCPProtocol And m_enmState <> sckClosed Then
        Err.Raise sckInvalidOp, "CSocketMaster.RemoteHost", "Invalid operation at current state"
    End If
    m_strRemoteHost = strHost
End Property
Public Property Get RemoteHostIP() As String
    RemoteHostIP = m_strRemoteHostIP
End Property
Public Property Get LocalPort() As Long
If m_lngLocalPortBind = 0 Then
    LocalPort = m_lngLocalPort
Else
    LocalPort = m_lngLocalPortBind
End If
End Property
Public Property Let LocalPort(ByVal lngPort As Long)
    If m_enmState <> sckClosed Then
        Err.Raise sckInvalidOp, "CSocketMaster.LocalPort", "Invalid operation at current state"
    End If
    If lngPort < 0 Or lngPort > 65535 Then
        Err.Raise sckInvalidArg, "CSocketMaster.LocalPort", "The argument passed to a function was not in the correct format or in the specified range."
    Else
        m_lngLocalPort = lngPort
    End If
End Property
Public Property Get State() As SockState
    State = m_enmState
End Property
Public Property Get LocalHostName() As String
    LocalHostName = GetLocalHostName
End Property
Public Property Get LocalIP() As String
    If m_enmState = sckConnected Then
        LocalIP = m_strLocalIP
    Else
        LocalIP = GetLocalIP
    End If
End Property
Public Property Get BytesReceived() As Long
    If m_enmProtocol = sckTCPProtocol Then
        BytesReceived = Len(m_strRecvBuffer)
    Else
        BytesReceived = GetBufferLenUDP
    End If
End Property
Public Property Get SocketHandle() As Long
    SocketHandle = m_lngSocketHandle
End Property
Public Property Get Tag() As String
    Tag = m_strTag
End Property
Public Property Let Tag(ByVal strTag As String)
    m_strTag = strTag
End Property
Public Property Get Protocol() As ProtocolConstants
    Protocol = m_enmProtocol
End Property
Public Property Let Protocol(ByVal enmProtocol As ProtocolConstants)
    If m_enmState <> sckClosed Then
        Err.Raise sckInvalidOp, "CSocketMaster.Protocol", "Invalid operation at current state"
    Else
        m_enmProtocol = enmProtocol
    End If
End Property
'Raise Winsock Exception
Private Sub RaiseException(method As String)
    Dim lngErrorCode As Long
    lngErrorCode = Err.LastDllError
    Err.Raise lngErrorCode, method, GetErrorDescription(lngErrorCode)
End Sub

'Destroys the socket if it exists and unregisters it
'from control list.
Private Sub DestroySocket()
    If Not (m_lngSocketHandle = INVALID_SOCKET) Then
        Dim lngResult As Long
        'Destroy Window instance
        UnSubclassCSocketMaster Me
        lngResult = api_closesocket(m_lngSocketHandle)
        If lngResult = SOCKET_ERROR Then
            m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
            RaiseException "CSocketMaster.DestroySocket"
        Else
            If traceSocket Then Debug.Print "OK Destroyed socket " & m_lngSocketHandle
            m_lngSocketHandle = INVALID_SOCKET
        End If
    End If
End Sub

Public Sub CloseSck()
    If m_lngSocketHandle = INVALID_SOCKET Then Exit Sub
    m_enmState = sckClosing
    If traceSocket Then Debug.Print "STATE: sckClosing"
    CleanResolutionSystem
    DestroySocket
    m_lngLocalPortBind = 0
    m_strRemoteHostIP = ""
    m_strRecvBuffer = ""
    m_strSendBuffer = ""
    m_lngSendBufferLen = 0
    m_lngRecvBufferLen = 0
    m_enmState = sckClosed
    If traceSocket Then Debug.Print "STATE: sckClosed"
End Sub
'Tries to create a socket if there isn't one yet and registers
'it to the control list.
'Returns TRUE if it has success
Private Function SocketExists() As Boolean
    SocketExists = True
    Dim lngResult As Long
    Dim lngErrorCode As Long
    'check if there is a socket already
    If m_lngSocketHandle = INVALID_SOCKET Then
        'decide what kind of socket we are creating, TCP or UDP
        If m_enmProtocol = sckTCPProtocol Then
            lngResult = api_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
        Else
            lngResult = api_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
        End If
        If lngResult = INVALID_SOCKET Then
            m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
            If traceSocket Then Debug.Print "ERROR trying to create socket"
            SocketExists = False
            lngErrorCode = Err.LastDllError
            Dim blnCancelDisplay As Boolean
            blnCancelDisplay = True
            RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.SocketExists", "", 0, blnCancelDisplay)
            If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.SocketExists"
        Else
            If traceSocket Then Debug.Print "OK Created socket: " & lngResult
            m_lngSocketHandle = lngResult
            'set and get some socket options
            ProcessOptions
            'Initializes Window instance to process messages
            SubClassCSocketMaster Me

            RegisterSocket
        End If
    End If
End Function
'Tries to connect to RemoteHost if it was passed, or uses
'm_strRemoteHost instead. If it is a hostname tries to
'resolve it first.
Public Sub Connect(Optional RemoteHost As Variant, Optional RemotePort As Variant)
    If m_enmState <> sckClosed Then
        Err.Raise sckInvalidOp, "CSocketMaster.Connect", "Invalid operation at current state"
    End If
    If Not IsMissing(RemoteHost) Then
        m_strRemoteHost = CStr(RemoteHost)
    End If
    'for some reason we get a GPF if we try to
    'resolve a null string, so we replace it with
    'an empty string
    If m_strRemoteHost = vbNullString Then
        m_strRemoteHost = ""
    End If
    'check if RemotePort is a number between 1 and 65535
    If Not IsMissing(RemotePort) Then
        If IsNumeric(RemotePort) Then
            If CLng(RemotePort) > 65535 Or CLng(RemotePort) < 1 Then
                Err.Raise sckInvalidArg, "CSocketMaster.Connect", "The argument passed to a function was not in the correct format or in the specified range."
            Else
                m_lngRemotePort = CLng(RemotePort)
            End If
        Else
            Err.Raise sckUnsupported, "CSocketMaster.Connect", "Unsupported variant type."
        End If
    End If
    'create a socket if there isn't one yet
    If Not SocketExists Then Exit Sub
    'Here we bind the socket
    If Not BindInternal Then Exit Sub
    'If we are using UDP we just exit silently.
    'Remember UDP is a connectionless protocol.
    If m_enmProtocol = sckUDPProtocol Then
        m_enmState = sckOpen:   If traceSocket Then Debug.Print "STATE: sckOpen"
        Exit Sub
    End If
    'try to get a 32 bits long that is used to identify a host
    Dim lngAddress As Long
    lngAddress = ResolveIfHostname(m_strRemoteHost)
    'We've got two options here:
    '1) m_strRemoteHost was an IP, so a resolution wasn't
    '   necessary, and now lngAddress is a 32 bits long and
    '   we proceed to connect.
    '2) m_strRemoteHost was a hostname, so a resolution was
    '   necessary and it's taking place right now. We leave
    '   silently.
    If lngAddress <> vbNull Then
        ConnectToIP lngAddress, 0
    End If
End Sub
'When the system resolves a hostname in asynchronous way we
'call this function to decide what to do with the result.
Public Sub PostResolution(ByVal lngAsynHandle As Long, ByVal lngErrorCode As Long)
'erase that record from the collection since we won't need it any longer
'm_colWaitingResolutions.Remove "R" & lngAsynHandle
If m_enmState <> sckResolvingHost Then Exit Sub
If lngErrorCode = 0 Then 'if there weren't errors trying to resolve the hostname
    m_enmState = sckHostResolved:   If traceSocket Then Debug.Print "STATE: sckHostResolved"
    Dim udtHostent As HOSTENT
    Dim lngPtrToIP As Long
    Dim arrIpAddress(1 To 4) As Byte
    Dim lngRemoteHostAddress As Long
    Dim Count As Integer
    Dim strIpAddress As String
    api_CopyMemory udtHostent, ByVal m_lngMemoryPointer, LenB(udtHostent)
    api_CopyMemory lngPtrToIP, ByVal udtHostent.hAddrList, 4
    api_CopyMemory arrIpAddress(1), ByVal lngPtrToIP, 4
    api_CopyMemory lngRemoteHostAddress, ByVal lngPtrToIP, 4
    'free memory, won't need it any longer
    FreeMemory
    'We turn the 32 bits long into a readable string.
    'Note: we don't need this string. I put this here just
    'in case you need it.
    For Count = 1 To 4
        strIpAddress = strIpAddress & arrIpAddress(Count) & "."
    Next
    strIpAddress = Left$(strIpAddress, Len(strIpAddress) - 1)
    ConnectToIP lngRemoteHostAddress, 0
Else 'there were errors trying to resolve the hostname
    'free buffer memory
    FreeMemory
    ConnectToIP vbNull, lngErrorCode
End If
End Sub
'This procedure is called by the WindowProc callback function.
'The lngEventID argument is an ID of the network event
'occurred for the socket. The lngErrorCode argument contains
'an error code only if an error was occurred during an
'asynchronous execution.
Public Sub PostSocket(ByVal lngEventID As Long, ByVal lngErrorCode As Long)
On Error GoTo PostSocket_Err
Dim blnCancelDisplay As Boolean
'handle any possible error
If lngErrorCode <> 0 Then
    m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
    blnCancelDisplay = True
    RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.PostSocket", "", 0, blnCancelDisplay)
    If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.PostSocket"
    Exit Sub
End If
Dim udtSockAddr As sockaddr_in
Dim lngResult As Long
Dim lngBytesReceived As Long
Select Case lngEventID
'======================================================================
Case FD_CONNECT
    'Arrival of this message means that the connection initiated by the call
    'of the connect Winsock API function was successfully established.
      If traceSocket Then Debug.Print "FD_CONNECT " & m_lngSocketHandle
    If m_enmState <> sckConnecting Then
          If traceSocket Then Debug.Print "WARNING: Omitting FD_CONNECT"
        Exit Sub
    End If
    'Get the local parameters
    GetLocalInfo m_lngSocketHandle, m_lngLocalPortBind, m_strLocalIP
    'Get the connection local end-point parameters
    GetRemoteInfo m_lngSocketHandle, m_lngRemotePort, m_strRemoteHostIP, m_strRemoteHost
    m_enmState = sckConnected:   If traceSocket Then Debug.Print "STATE: sckConnected"
    RaiseEvent Connect
'======================================================================
Case FD_WRITE
    'This message means that the socket in a write-able
    'state, that is, buffer for outgoing data of the transport
    'service is empty and ready to receive data to send through
    'the network.
      If traceSocket Then Debug.Print "FD_WRITE " & m_lngSocketHandle
    If m_enmState <> sckConnected Then
          If traceSocket Then Debug.Print "WARNING: Omitting FD_WRITE"
        Exit Sub
    End If
    If Len(m_strSendBuffer) > 0 Then
        SendBufferedData
    End If
'======================================================================
Case FD_READ
    'Some data has arrived for this socket.
      If traceSocket Then Debug.Print "FD_READ " & m_lngSocketHandle
    If m_enmProtocol = sckTCPProtocol Then
        If m_enmState <> sckConnected Then
              If traceSocket Then Debug.Print "WARNING: Omitting FD_READ"
            Exit Sub
        End If
        'Call the RecvDataToBuffer function that move arrived data
        'from the Winsock buffer to the local one and returns number
        'of bytes received.
        lngBytesReceived = RecvDataToBuffer
        If lngBytesReceived > 0 Then
            RaiseEvent DataArrival(Len(m_strRecvBuffer))
        End If
    Else 'UDP protocol
        If m_enmState <> sckOpen Then
              If traceSocket Then Debug.Print "WARNING: Omitting FD_READ"
            Exit Sub
        End If
        'If we use UDP we don't remove data from winsock buffer.
        'We just let the user know the amount received so
        'he/she can decide what to do.
        lngBytesReceived = GetBufferLenUDP
        If lngBytesReceived > 0 Then
            RaiseEvent DataArrival(lngBytesReceived)
        End If
        'Now the buffer is emptied no matter what the user
        'dicided to do with the received data
        EmptyBuffer
    End If
'======================================================================
Case FD_ACCEPT
    'When the socket is in a listening state, arrival of this message
    'means that a connection request was received. Call the accept
    'Winsock API function in order to create a new socket for the
    'requested connection.
    If traceSocket Then Debug.Print "FD_ACCEPT " & m_lngSocketHandle
    If m_enmState <> sckListening Then
          If traceSocket Then Debug.Print "WARNING: Omitting FD_ACCEPT"
        Exit Sub
    End If
    lngResult = api_accept(m_lngSocketHandle, udtSockAddr, LenB(udtSockAddr))
    If lngResult = INVALID_SOCKET Then
        lngErrorCode = Err.LastDllError
        m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
        blnCancelDisplay = True
        RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.PostSocket", "", 0, blnCancelDisplay)
        If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.PostSocket"
    Else
        'We change remote info before firing ConnectionRequest
        'event so the user can see which host is trying to
        'connect.
        Dim lngTempRP As Long
        Dim strTempRHIP As String
        Dim strTempRH As String
        lngTempRP = m_lngRemotePort
        strTempRHIP = m_strRemoteHostIP
        strTempRH = m_strRemoteHost
        m_strRemoteHost = ""
        GetRemoteInfo lngResult, m_lngRemotePort, m_strRemoteHostIP, m_strRemoteHost
          If traceSocket Then Debug.Print "OK Accepted socket: " & lngResult
        RaiseEvent ConnectionRequest(lngResult)
        'we return original info
        If m_enmState = sckListening Then
             m_lngRemotePort = lngTempRP
             m_strRemoteHostIP = strTempRHIP
             m_strRemoteHost = strTempRH
        End If
        'This is very important. If the connection wasn't accepted
        'we must close the socket.
'        If IsAcceptRegistered(lngResult) Then
'            api_closesocket lngResult
'            modSocketMaster.UnregisterSocket lngResult
'            modSocketMaster.UnregisterAccept lngResult
'              If traceSocket Then Debug.Print "OK Closed accepted socket: " & lngResult
'        End If
    End If
'======================================================================
Case FD_CLOSE
    'This message means that the remote host is closing the conection
      If traceSocket Then Debug.Print "FD_CLOSE " & m_lngSocketHandle
    If m_enmState <> sckConnected Then
          If traceSocket Then Debug.Print "WARNING: Omitting FD_CLOSE"
        Exit Sub
    End If
    m_enmState = sckClosing:   If traceSocket Then Debug.Print "STATE: sckClosing"
    RaiseEvent CloseSck
End Select
Exit Sub
PostSocket_Err:
  Exit Sub
End Sub
'Connect to a given 32 bits long ip
Private Sub ConnectToIP(ByVal lngRemoteHostAddress As Long, ByVal lngErrorCode As Long)
Dim blnCancelDisplay As Boolean
'Check and handle errors
If lngErrorCode <> 0 Then
    m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
    blnCancelDisplay = True
    RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.ConnectToIP", "", 0, blnCancelDisplay)
    If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.ConnectToIP"
    Exit Sub
End If
  If traceSocket Then Debug.Print "OK Connecting to: " + m_strRemoteHost + " " + m_strRemoteHostIP
m_enmState = sckConnecting:   If traceSocket Then Debug.Print "STATE: sckConnecting"
Dim udtSockAddr As sockaddr_in
Dim lngResult As Long
'Build the sockaddr_in structure to pass it to the connect
'Winsock API function as an address of the remote host.
With udtSockAddr
    .sin_addr = lngRemoteHostAddress
    .sin_family = AF_INET
    .sin_port = api_htons(modSocketMaster.UnsignedToInteger(m_lngRemotePort))
End With
'Call the connect Winsock API function in order to establish connection.
lngResult = m_lngSocketHandle
If traceSocket Then Debug.Print "Socket " + CStr(lngResult)
DoEvents
lngResult = api_connect(lngResult, udtSockAddr, LenB(udtSockAddr))
'Check and handle errors
If lngResult = SOCKET_ERROR Then
    lngErrorCode = Err.LastDllError
    If lngErrorCode <> WSAEWOULDBLOCK Then
        If lngErrorCode = WSAENOTSOCK Then
            lngResult = api_connect(m_lngSocketHandle, udtSockAddr, LenB(udtSockAddr))
        End If
    End If
End If
If lngResult = SOCKET_ERROR Then
    lngErrorCode = Err.LastDllError
    If lngErrorCode <> WSAEWOULDBLOCK Then
        If lngErrorCode = WSAEADDRNOTAVAIL Then
            Err.Raise WSAEADDRNOTAVAIL, "CSocketMaster.ConnectToIP", GetErrorDescription(WSAEADDRNOTAVAIL)
        Else
            m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError " + CStr(lngErrorCode)
            blnCancelDisplay = True
            RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.ConnectToIP", "", 0, blnCancelDisplay)
            If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.ConnectToIP"
        End If
    End If
End If
End Sub
Public Sub Bind(Optional LocalPort As Variant, Optional LocalIP As Variant)
If m_enmState <> sckClosed Then
    Err.Raise sckInvalidOp, "CSocketMaster.Bind", "Invalid operation at current state"
End If
If BindInternal(LocalPort, LocalIP) Then
    m_enmState = sckOpen:   If traceSocket Then Debug.Print "STATE: sckOpen"
End If
End Sub
'This function binds a socket to a local port and IP.
'Retunrs TRUE if it has success.
Private Function BindInternal(Optional ByVal varLocalPort As Variant, Optional ByVal varLocalIP As Variant) As Boolean
If m_enmState = sckOpen Then
    BindInternal = True
    Exit Function
End If
Dim lngLocalPortInternal As Long
Dim strLocalHostInternal As String
Dim strIP As String
Dim lngAddressInternal As Long
Dim lngResult As Long
Dim lngErrorCode As Long
BindInternal = False
'Check if varLocalPort is a number between 0 and 65535
If Not IsMissing(varLocalPort) Then
    If IsNumeric(varLocalPort) Then
        If varLocalPort < 0 Or varLocalPort > 65535 Then
            BindInternal = False
            Err.Raise sckInvalidArg, "CSocketMaster.BindInternal", "The argument passed to a function was not in the correct format or in the specified range."
        Else
            lngLocalPortInternal = CLng(varLocalPort)
        End If
    Else
        BindInternal = False
        Err.Raise sckUnsupported, "CSocketMaster.BindInternal", "Unsupported variant type."
    End If
Else
    lngLocalPortInternal = m_lngLocalPort
End If
If Not IsMissing(varLocalIP) Then
    If varLocalIP <> vbNullString Then
        strLocalHostInternal = CStr(varLocalIP)
    Else
        strLocalHostInternal = ""
    End If
Else
    strLocalHostInternal = ""
End If
'get a 32 bits long IP
lngAddressInternal = ResolveIfHostnameSync(strLocalHostInternal, strIP, lngResult)
If lngResult <> 0 Then
    Err.Raise sckInvalidArg, "CSocketMaster.BindInternal", "Invalid argument"
End If
'create a socket if there isn't one yet
If Not SocketExists Then Exit Function
Dim udtSockAddr As sockaddr_in
With udtSockAddr
    .sin_addr = lngAddressInternal
    .sin_family = AF_INET
    .sin_port = api_htons(modSocketMaster.UnsignedToInteger(lngLocalPortInternal))
End With
'bind the socket
lngResult = api_bind(m_lngSocketHandle, udtSockAddr, LenB(udtSockAddr))
If lngResult = SOCKET_ERROR Then
    lngErrorCode = Err.LastDllError
    Err.Raise lngErrorCode, "CSocketMaster.BindInternal", GetErrorDescription(lngErrorCode)
Else
    If lngLocalPortInternal <> 0 Then
          If traceSocket Then Debug.Print "OK Bind HOST: " & strLocalHostInternal & " PORT: " & lngLocalPortInternal
        m_lngLocalPort = lngLocalPortInternal
    Else
        lngResult = GetLocalPort(m_lngSocketHandle)
        If lngResult = SOCKET_ERROR Then
            lngErrorCode = Err.LastDllError
            Err.Raise lngErrorCode, "CSocketMaster.BindInternal", GetErrorDescription(lngErrorCode)
        Else
              If traceSocket Then Debug.Print "OK Bind HOST: " & strLocalHostInternal & " PORT: " & lngResult
            m_lngLocalPortBind = lngResult
        End If
    End If
    BindInternal = True
End If
End Function
'Allocate some memory for HOSTEN structure and returns
'a pointer to this buffer if no error occurs.
'Returns 0 if it fails.

'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Private Function AllocateMemory() As LongPtr
#Else
Private Function AllocateMemory() As Long
#End If
m_lngMemoryHandle = api_GlobalAlloc(GMEM_FIXED, MAXGETHOSTSTRUCT)
If m_lngMemoryHandle <> 0 Then
    m_lngMemoryPointer = api_GlobalLock(m_lngMemoryHandle)
    If m_lngMemoryPointer <> 0 Then
        api_GlobalUnlock (m_lngMemoryHandle)
        AllocateMemory = m_lngMemoryPointer
    Else
        api_GlobalFree (m_lngMemoryHandle)
        AllocateMemory = m_lngMemoryPointer '0
    End If
Else
    AllocateMemory = m_lngMemoryHandle '0
End If
End Function
'Free memory allocated by AllocateMemory
Private Sub FreeMemory()
If m_lngMemoryHandle <> 0 Then
    m_lngMemoryPointer = 0
    api_GlobalFree m_lngMemoryHandle
    m_lngMemoryHandle = 0
      If traceSocket Then Debug.Print "OK Freed resolution memory"
End If
End Sub
Private Function GetLocalHostName() As String
Dim strHostNameBuf As String * LOCAL_HOST_BUFF
Dim lngResult As Long
lngResult = api_gethostname(strHostNameBuf, LOCAL_HOST_BUFF)
If lngResult = SOCKET_ERROR Then
    GetLocalHostName = vbNullString
    Dim lngErrorCode As Long
    lngErrorCode = Err.LastDllError
    Err.Raise lngErrorCode, "CSocketMaster.GetLocalHostName", GetErrorDescription(lngErrorCode)
Else
    GetLocalHostName = Left(strHostNameBuf, InStr(1, strHostNameBuf, vbNullChar) - 1)
End If
End Function
'Get local IP when the socket isn't connected yet
Private Function GetLocalIP() As String
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Dim lngResult As LongPtr
#Else
Dim lngResult As Long
#End If
Dim lngPtrToIP As Long
Dim strLocalHost As String
Dim arrIpAddress(1 To 4) As Byte
Dim Count As Integer
Dim udtHostent As HOSTENT
Dim strIpAddress As String
strLocalHost = GetLocalHostName
lngResult = api_gethostbyname(strLocalHost)
If lngResult = 0 Then
    GetLocalIP = vbNullString
    Dim lngErrorCode As Long
    lngErrorCode = Err.LastDllError
    Err.Raise lngErrorCode, "CSocketMaster.GetLocalIP", GetErrorDescription(lngErrorCode)
Else
    api_CopyMemory udtHostent, ByVal lngResult, LenB(udtHostent)
    api_CopyMemory lngPtrToIP, ByVal udtHostent.hAddrList, 4
    api_CopyMemory arrIpAddress(1), ByVal lngPtrToIP, 4
    For Count = 1 To 4
        strIpAddress = strIpAddress & arrIpAddress(Count) & "."
    Next
    strIpAddress = Left$(strIpAddress, Len(strIpAddress) - 1)
    GetLocalIP = strIpAddress
End If
End Function
'If Host is an IP doesn't resolve anything and returns a
'a 32 bits long IP.
'If Host isn't an IP then returns vbNull, tries to resolve it
'in asynchronous way.
Private Function ResolveIfHostname(ByVal Host As String) As Long
Dim lngAddress As Long
lngAddress = api_inet_addr(Host)
If lngAddress = INADDR_NONE Then 'if Host isn't an IP
    ResolveIfHostname = vbNull
    m_enmState = sckResolvingHost:   If traceSocket Then Debug.Print "STATE: sckResolvingHost"
    If AllocateMemory Then
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
        Dim lngAsynHandle As LongPtr
#Else
        Dim lngAsynHandle As Long
#End If
        lngAsynHandle = ResolveHost(Host, m_lngMemoryPointer)
        If lngAsynHandle = 0 Then
            FreeMemory
            m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
            Dim lngErrorCode As Long
            lngErrorCode = Err.LastDllError
            Dim blnCancelDisplay As Boolean
            blnCancelDisplay = True
            RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.ResolveIfHostname", "", 0, blnCancelDisplay)
            If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.ResolveIfHostname"
        Else
            'm_colWaitingResolutions.Add lngAsynHandle, "R" & lngAsynHandle
              If traceSocket Then Debug.Print "Resolving host " & Host; " with handle " & lngAsynHandle
        End If
    Else
        m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
          If traceSocket Then Debug.Print "Error trying to allocate memory"
        Err.Raise sckOutOfMemory, "CSocketMaster.ResolveIfHostname", "Out of memory"
    End If
Else 'if Host is an IP doen't need to resolve anything
    ResolveIfHostname = lngAddress
End If
End Function
'Resolves a host (if necessary) in synchronous way
'If succeeds returns a 32 bits long IP,
'strHostIP = readable IP string and lngErrorCode = 0
'If fails returns vbNull,
'strHostIP = vbNullString and lngErrorCode <> 0
Private Function ResolveIfHostnameSync(ByVal Host As String, ByRef strHostIP As String, ByRef lngErrorCode As Long) As Long
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Dim lngPtrToHOSTENT As LongPtr
#Else
Dim lngPtrToHOSTENT As Long
#End If
Dim udtHostent As HOSTENT
Dim lngAddress As Long
Dim lngPtrToIP As Long
Dim arrIpAddress(1 To 4) As Byte
Dim Count As Integer
lngAddress = api_inet_addr(Host)
If lngAddress = INADDR_NONE Then 'if Host isn't an IP
    lngPtrToHOSTENT = api_gethostbyname(Host)
    If lngPtrToHOSTENT = 0 Then
        lngErrorCode = Err.LastDllError
        strHostIP = vbNullString
        ResolveIfHostnameSync = vbNull
    Else
        api_CopyMemory udtHostent, ByVal lngPtrToHOSTENT, LenB(udtHostent)
        api_CopyMemory lngPtrToIP, ByVal udtHostent.hAddrList, 4
        api_CopyMemory arrIpAddress(1), ByVal lngPtrToIP, 4
        api_CopyMemory lngAddress, ByVal lngPtrToIP, 4
        For Count = 1 To 4
            strHostIP = strHostIP & arrIpAddress(Count) & "."
        Next
        strHostIP = Left$(strHostIP, Len(strHostIP) - 1)
        lngErrorCode = 0
        ResolveIfHostnameSync = lngAddress
    End If
Else 'if Host is an IP doen't need to resolve anything
    lngErrorCode = 0
    strHostIP = Host
    ResolveIfHostnameSync = lngAddress
End If
End Function
'Returns local port from a connected or bound socket.
'Returns SOCKET_ERROR if fails.
Private Function GetLocalPort(ByVal lngSocket As Long) As Long
Dim udtSockAddr As sockaddr_in
Dim lngResult As Long
lngResult = api_getsockname(lngSocket, udtSockAddr, LenB(udtSockAddr))
If lngResult = SOCKET_ERROR Then
    GetLocalPort = SOCKET_ERROR
Else
    GetLocalPort = modSocketMaster.IntegerToUnsigned(api_ntohs(udtSockAddr.sin_port))
End If
End Function
Public Sub SendData(Data As Variant)
Dim arrData() As Byte 'We store the data here before send it
If m_enmProtocol = sckTCPProtocol Then
    If m_enmState <> sckConnected Then
        Err.Raise sckBadState, "CSocketMaster.SendData", "Wrong protocol or connection state for the requested transaction or request"
        Exit Sub
    End If
Else 'If we use UDP we create a socket if there isn't one yet
    If Not SocketExists Then Exit Sub
    If Not BindInternal Then Exit Sub
    m_enmState = sckOpen:   If traceSocket Then Debug.Print "STATE: sckOpen"
End If
'We need to convert data variant into a byte array
Select Case varType(Data)
        Case vbString
            Dim strData As String
            strData = CStr(Data)
            If Len(strData) = 0 Then Exit Sub
            ReDim arrData(Len(strData) - 1)
            arrData() = StrConv(strData, vbFromUnicode, 1033)
        Case vbArray + vbByte
            Dim strArray As String
            strArray = StrConv(Data, vbUnicode, 1033)
            If Len(strArray) = 0 Then Exit Sub
            arrData() = StrConv(strArray, vbFromUnicode, 1033)
        Case vbBoolean
            Dim blnData As Boolean
            blnData = CBool(Data)
            ReDim arrData(LenB(blnData) - 1)
            api_CopyMemory arrData(0), blnData, LenB(blnData)
        Case vbByte
            Dim bytData As Byte
            bytData = CByte(Data)
            ReDim arrData(LenB(bytData) - 1)
            api_CopyMemory arrData(0), bytData, LenB(bytData)
        Case vbCurrency
            Dim curData As Currency
            curData = CCur(Data)
            ReDim arrData(LenB(curData) - 1)
            api_CopyMemory arrData(0), curData, LenB(curData)
        Case vbDate
            Dim datData As Date
            datData = CDate(Data)
            ReDim arrData(LenB(datData) - 1)
            api_CopyMemory arrData(0), datData, LenB(datData)
        Case vbDouble
            Dim dblData As Double
            dblData = CDbl(Data)
            ReDim arrData(LenB(dblData) - 1)
            api_CopyMemory arrData(0), dblData, LenB(dblData)
        Case vbInteger
            Dim intData As Integer
            intData = CInt(Data)
            ReDim arrData(LenB(intData) - 1)
            api_CopyMemory arrData(0), intData, LenB(intData)
        Case vbLong
            Dim lngData As Long
            lngData = CLng(Data)
            ReDim arrData(LenB(lngData) - 1)
            api_CopyMemory arrData(0), lngData, LenB(lngData)
        Case vbSingle
            Dim sngData As Single
            sngData = CSng(Data)
            ReDim arrData(LenB(sngData) - 1)
            api_CopyMemory arrData(0), sngData, LenB(sngData)
        Case Else
            Err.Raise sckUnsupported, "CSocketMaster.SendData", "Unsupported variant type."
    End Select
'if there's already something in the buffer that means we are
'already sending data, so we put the new data in the buffer
'and exit silently
If Len(m_strSendBuffer) > 0 Then
    m_strSendBuffer = m_strSendBuffer + StrConv(arrData(), vbUnicode, 1033)
    Exit Sub
Else
    m_strSendBuffer = m_strSendBuffer + StrConv(arrData(), vbUnicode, 1033)
End If
'send the data
SendBufferedData
End Sub
'Check which protocol we are using to decide which
'function should handle the data sending.
Private Sub SendBufferedData()
If m_enmProtocol = sckTCPProtocol Then
    SendBufferedDataTCP
Else
    SendBufferedDataUDP
End If
End Sub
'Send buffered data if we are using UDP protocol.
Private Sub SendBufferedDataUDP()
Dim lngAddress As Long
Dim udtSockAddr As sockaddr_in
Dim arrData() As Byte
Dim lngBufferLength As Long
Dim lngResult As Long
Dim lngErrorCode As Long
Dim strTemp As String
lngAddress = ResolveIfHostnameSync(m_strRemoteHost, strTemp, lngErrorCode)
If lngErrorCode <> 0 Then
    m_strSendBuffer = ""
    If lngErrorCode = WSAEAFNOSUPPORT Then
        Err.Raise lngErrorCode, "CSocketMaster.SendBufferedDataUDP", GetErrorDescription(lngErrorCode)
    Else
        Err.Raise sckInvalidArg, "CSocketMaster.SendBufferedDataUDP", "Invalid argument"
    End If
End If
With udtSockAddr
    .sin_addr = lngAddress
    .sin_family = AF_INET
    .sin_port = api_htons(modSocketMaster.UnsignedToInteger(m_lngRemotePort))
End With
lngBufferLength = Len(m_strSendBuffer)
arrData() = StrConv(m_strSendBuffer, vbFromUnicode, 1033)
m_strSendBuffer = ""
lngResult = api_sendto(m_lngSocketHandle, arrData(0), lngBufferLength, 0&, udtSockAddr, LenB(udtSockAddr))
If lngResult = SOCKET_ERROR Then
    lngErrorCode = Err.LastDllError
    If lngErrorCode = WSAEWOULDBLOCK Then
        Err.Raise WSAEWOULDBLOCK, "CSocketMaster.SendBufferedDataUDP", GetErrorDescription(lngErrorCode)
    Else
        m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
        Dim blnCancelDisplay As Boolean
        blnCancelDisplay = True
        RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.SendBufferedDataUDP", "", 0, blnCancelDisplay)
        If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.SendBufferedDataUDP"
    End If
End If
End Sub
'Send buffered data if we are using TCP protocol.
Private Sub SendBufferedDataTCP()
Dim arrData()       As Byte
Dim lngBufferLength As Long
Dim lngResult    As Long
Dim lngTotalSent As Long
Do Until lngResult = SOCKET_ERROR Or Len(m_strSendBuffer) = 0
    lngBufferLength = Len(m_strSendBuffer)
    If lngBufferLength > m_lngSendBufferLen Then
        lngBufferLength = m_lngSendBufferLen
        arrData() = StrConv(Left$(m_strSendBuffer, m_lngSendBufferLen), vbFromUnicode, 1033)
    Else
        arrData() = StrConv(m_strSendBuffer, vbFromUnicode, 1033)
    End If
    lngResult = api_send(m_lngSocketHandle, arrData(0), lngBufferLength, 0&)
    If lngResult = SOCKET_ERROR Then
        Dim lngErrorCode As Long
        lngErrorCode = Err.LastDllError
        If lngErrorCode = WSAEWOULDBLOCK Then
              If traceSocket Then Debug.Print "WARNING: Send buffer full, waiting..."
            If lngTotalSent > 0 Then RaiseEvent SendProgress(lngTotalSent, Len(m_strSendBuffer))
        Else
            m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
            Dim blnCancelDisplay As Boolean
            blnCancelDisplay = True
            RaiseEvent Error(lngErrorCode, GetErrorDescription(lngErrorCode), 0, "CSocketMaster.SendBufferedData", "", 0, blnCancelDisplay)
            If blnCancelDisplay = False Then MsgBox GetErrorDescription(lngErrorCode), vbOKOnly, "CSocketMaster.SendBufferedData"
        End If
    Else
          If traceSocket Then Debug.Print "OK Bytes sent: " & lngResult
        lngTotalSent = lngTotalSent + lngResult
        If Len(m_strSendBuffer) > lngResult Then
            m_strSendBuffer = Mid$(m_strSendBuffer, lngResult + 1)
        Else
              If traceSocket Then Debug.Print "OK Finished SENDING"
            m_strSendBuffer = ""
            Dim lngTemp As Long
            lngTemp = lngTotalSent
            lngTotalSent = 0
            RaiseEvent SendProgress(lngTemp, 0)
            RaiseEvent SendComplete
        End If
    End If
Loop
End Sub
'This function retrieves data from the Winsock buffer
'into the class local buffer. The function returns number
'of bytes retrieved (received).
Private Function RecvDataToBuffer() As Long
Dim arrBuffer() As Byte
Dim lngBytesReceived As Long
Dim strBuffTemporal As String
ReDim arrBuffer(m_lngRecvBufferLen - 1)
lngBytesReceived = api_recv(m_lngSocketHandle, arrBuffer(0), m_lngRecvBufferLen, 0&)
If lngBytesReceived = SOCKET_ERROR Then
    m_enmState = sckError:   If traceSocket Then Debug.Print "STATE: sckError"
    Dim lngErrorCode As Long
    lngErrorCode = Err.LastDllError
    Err.Raise lngErrorCode, "CSocketMaster.RecvDataToBuffer", GetErrorDescription(lngErrorCode)
ElseIf lngBytesReceived > 0 Then
    strBuffTemporal = StrConv(arrBuffer(), vbUnicode, 1033)
    m_strRecvBuffer = m_strRecvBuffer & Left$(strBuffTemporal, lngBytesReceived)
    RecvDataToBuffer = lngBytesReceived
End If
End Function
'Retrieves some socket options.
'If it is an UDP socket also sets SO_BROADCAST option.
Private Sub ProcessOptions()
Dim lngResult As Long
Dim lngBuffer As Long
Dim lngErrorCode As Long
If m_enmProtocol = sckTCPProtocol Then
    lngResult = api_getsockopt(m_lngSocketHandle, SOL_SOCKET, SO_RCVBUF, lngBuffer, LenB(lngBuffer))
    If lngResult = SOCKET_ERROR Then
        lngErrorCode = Err.LastDllError
        Err.Raise lngErrorCode, "CSocketMaster.ProcessOptions", GetErrorDescription(lngErrorCode)
    Else
        m_lngRecvBufferLen = lngBuffer
    End If
    lngResult = api_getsockopt(m_lngSocketHandle, SOL_SOCKET, SO_SNDBUF, lngBuffer, LenB(lngBuffer))
    If lngResult = SOCKET_ERROR Then
        lngErrorCode = Err.LastDllError
        Err.Raise lngErrorCode, "CSocketMaster.ProcessOptions", GetErrorDescription(lngErrorCode)
    Else
        m_lngSendBufferLen = lngBuffer
    End If
Else
    lngBuffer = 1
    lngResult = api_setsockopt(m_lngSocketHandle, SOL_SOCKET, SO_BROADCAST, lngBuffer, LenB(lngBuffer))
    lngResult = api_getsockopt(m_lngSocketHandle, SOL_SOCKET, SO_MAX_MSG_SIZE, lngBuffer, LenB(lngBuffer))
    If lngResult = SOCKET_ERROR Then
        lngErrorCode = Err.LastDllError
        Err.Raise lngErrorCode, "CSocketMaster.ProcessOptions", GetErrorDescription(lngErrorCode)
    Else
        m_lngRecvBufferLen = lngBuffer
        m_lngSendBufferLen = lngBuffer
    End If
End If
  If traceSocket Then Debug.Print "Winsock buffer size for sends: " & m_lngRecvBufferLen
  If traceSocket Then Debug.Print "Winsock buffer size for receives: " & m_lngSendBufferLen
End Sub
Public Sub GetData(ByRef Data As Variant, Optional varType As Variant, Optional maxLen As Variant)
If m_enmProtocol = sckTCPProtocol Then
    If m_enmState <> sckConnected And Not m_blnAcceptClass Then
        Err.Raise sckBadState, "CSocketMaster.GetData", "Wrong protocol or connection state for the requested transaction or request"
        Exit Sub
    End If
Else
    If m_enmState <> sckOpen Then
        Err.Raise sckBadState, "CSocketMaster.GetData", "Wrong protocol or connection state for the requested transaction or request"
        Exit Sub
    End If
    If GetBufferLenUDP = 0 Then Exit Sub
End If
If Not IsMissing(maxLen) Then
    If IsNumeric(maxLen) Then
        If CLng(maxLen) < 0 Then
            Err.Raise sckInvalidArg, "CSocketMaster.GetData", "The argument passed to a function was not in the correct format or in the specified range."
        End If
    Else
        If m_enmProtocol = sckTCPProtocol Then
            maxLen = Len(m_strRecvBuffer)
        Else
            maxLen = GetBufferLenUDP
        End If
    End If
End If
Dim lngBytesRecibidos  As Long
lngBytesRecibidos = RecvData(Data, False, varType, maxLen)
  If traceSocket Then Debug.Print "OK Bytes obtained from buffer: " & lngBytesRecibidos & "> " & Data
End Sub
Public Sub PeekData(ByRef Data As Variant, Optional varType As Variant, Optional maxLen As Variant)
If m_enmProtocol = sckTCPProtocol Then
    If m_enmState <> sckConnected Then
        Err.Raise sckBadState, "CSocketMaster.PeekData", "Wrong protocol or connection state for the requested transaction or request"
        Exit Sub
    End If
Else
    If m_enmState <> sckOpen Then
        Err.Raise sckBadState, "CSocketMaster.PeekData", "Wrong protocol or connection state for the requested transaction or request"
        Exit Sub
    End If
    If GetBufferLenUDP = 0 Then Exit Sub
End If
If Not IsMissing(maxLen) Then
    If IsNumeric(maxLen) Then
        If CLng(maxLen) < 0 Then
            Err.Raise sckInvalidArg, "CSocketMaster.PeekData", "The argument passed to a function was not in the correct format or in the specified range."
        End If
    Else
        If m_enmProtocol = sckTCPProtocol Then
            maxLen = Len(m_strRecvBuffer)
        Else
            maxLen = GetBufferLenUDP
        End If
    End If
End If
Dim lngBytesRecibidos  As Long
lngBytesRecibidos = RecvData(Data, True, varType, maxLen)
  If traceSocket Then Debug.Print "OK Bytes obtained from buffer: " & lngBytesRecibidos
End Sub
'This function is to retrieve data from the buffer. If we are using TCP
'then the data is retrieved from a local buffer (m_strRecvBuffer). If we
'are using UDP the data is retrieved from winsock buffer.
'It can be called by two public methods of the class - GetData and PeekData.
'Behavior of the function is defined by the blnPeek argument. If a value of
'that argument is TRUE, the function returns number of bytes in the
'buffer, and copy data from that buffer into the data argument.
'If a value of the blnPeek is FALSE, then this function returns number of
'bytes received, and move data from the buffer into the data
'argument. MOVE means that data will be removed from the buffer.
Private Function RecvData(ByRef Data As Variant, ByVal blnPeek As Boolean, Optional varClass As Variant, Optional maxLen As Variant) As Long
Dim blnMaxLenMiss   As Boolean
Dim blnClassMiss    As Boolean
Dim strRecvData     As String
Dim lngBufferLen    As Long
Dim arrBuffer()     As Byte
Dim lngErrorCode    As Long
If m_enmProtocol = sckTCPProtocol Then
    lngBufferLen = Len(m_strRecvBuffer)
Else
    lngBufferLen = GetBufferLenUDP
End If
blnMaxLenMiss = IsMissing(maxLen)
blnClassMiss = IsMissing(varClass)
'Select type of data
If varType(Data) = vbEmpty Then
    If blnClassMiss Then varClass = vbArray + vbByte
Else
    varClass = varType(Data)
End If
'As stated on Winsock control documentation if the
'data type passed is string or byte array type then
'we must take into account maxLen argument.
'If it is another type maxLen is ignored.
If varClass = vbString Or varClass = vbArray + vbByte Then
    If blnMaxLenMiss Then 'if maxLen argument is missing
        If lngBufferLen = 0 Then
            RecvData = 0
            arrBuffer = StrConv("", vbFromUnicode, 1033)
            Data = arrBuffer
            Exit Function
        Else
            RecvData = lngBufferLen
            BuildArray lngBufferLen, blnPeek, lngErrorCode, arrBuffer
        End If
    Else 'if maxLen argument is not missing
        If maxLen = 0 Or lngBufferLen = 0 Then
            RecvData = 0
            arrBuffer = StrConv("", vbFromUnicode, 1033)
            Data = arrBuffer
            If m_enmProtocol = sckUDPProtocol Then
                EmptyBuffer
                Err.Raise WSAEMSGSIZE, "CSocketMaster.RecvData", GetErrorDescription(WSAEMSGSIZE)
            End If
            Exit Function
        ElseIf maxLen > lngBufferLen Then
            RecvData = lngBufferLen
            BuildArray lngBufferLen, blnPeek, lngErrorCode, arrBuffer
        Else
            RecvData = CLng(maxLen)
            BuildArray CLng(maxLen), blnPeek, lngErrorCode, arrBuffer
        End If
    End If
End If



    Select Case varClass
    Case vbString
        Dim strData As String
        strData = StrConv(arrBuffer(), vbUnicode, 1033) 'AK 1033
        Data = strData
        'Debug.Print Data 'ak
    Case vbArray + vbByte
        Data = arrBuffer
    Case vbBoolean
        Dim blnData As Boolean
        If LenB(blnData) > lngBufferLen Then Exit Function
        BuildArray LenB(blnData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(blnData)
        api_CopyMemory blnData, arrBuffer(0), LenB(blnData)
        Data = blnData
    Case vbByte
        Dim bytData As Byte
        If LenB(bytData) > lngBufferLen Then Exit Function
        BuildArray LenB(bytData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(bytData)
        api_CopyMemory bytData, arrBuffer(0), LenB(bytData)
        Data = bytData
    Case vbCurrency
        Dim curData As Currency
        If LenB(curData) > lngBufferLen Then Exit Function
        BuildArray LenB(curData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(curData)
        api_CopyMemory curData, arrBuffer(0), LenB(curData)
        Data = curData
    Case vbDate
        Dim datData As Date
        If LenB(datData) > lngBufferLen Then Exit Function
        BuildArray LenB(datData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(datData)
        api_CopyMemory datData, arrBuffer(0), LenB(datData)
        Data = datData
    Case vbDouble
        Dim dblData As Double
        If LenB(dblData) > lngBufferLen Then Exit Function
        BuildArray LenB(dblData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(dblData)
        api_CopyMemory dblData, arrBuffer(0), LenB(dblData)
        Data = dblData
    Case vbInteger
        Dim intData As Integer
        If LenB(intData) > lngBufferLen Then Exit Function
        BuildArray LenB(intData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(intData)
        api_CopyMemory intData, arrBuffer(0), LenB(intData)
        Data = intData
    Case vbLong
        Dim lngData As Long
        If LenB(lngData) > lngBufferLen Then Exit Function
        BuildArray LenB(lngData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(lngData)
        api_CopyMemory lngData, arrBuffer(0), LenB(lngData)
        Data = lngData
    Case vbSingle
        Dim sngData As Single
        If LenB(sngData) > lngBufferLen Then Exit Function
        BuildArray LenB(sngData), blnPeek, lngErrorCode, arrBuffer
        RecvData = LenB(sngData)
        api_CopyMemory sngData, arrBuffer(0), LenB(sngData)
        Data = sngData
    Case Else
        Err.Raise sckUnsupported, "CSocketMaster.RecvData", "Unsupported variant type."
    End Select
'if BuildArray returns an error is handled here
If lngErrorCode <> 0 Then
    Err.Raise lngErrorCode, "CSocketMaster.RecvData", GetErrorDescription(lngErrorCode)
End If
End Function
'Returns a byte array of Size bytes filled with incoming buffer data.
Private Sub BuildArray(ByVal Size As Long, ByVal blnPeek As Boolean, ByRef lngErrorCode As Long, ByRef bytArray() As Byte)
Dim strData As String
If m_enmProtocol = sckTCPProtocol Then
    strData = Left$(m_strRecvBuffer, CLng(Size))
    bytArray = StrConv(strData, vbFromUnicode, 1033)
    If Not blnPeek Then
        m_strRecvBuffer = Mid$(m_strRecvBuffer, Size + 1)
    End If
Else 'UDP protocol
    Dim arrBuffer() As Byte
    Dim lngResult As Long
    Dim udtSockAddr As sockaddr_in
    Dim lngFlags As Long
    If blnPeek Then lngFlags = MSG_PEEK
    ReDim arrBuffer(Size - 1)
    lngResult = api_recvfrom(m_lngSocketHandle, arrBuffer(0), Size, lngFlags, udtSockAddr, LenB(udtSockAddr))
    If lngResult = SOCKET_ERROR Then
        lngErrorCode = Err.LastDllError
    End If
    bytArray = arrBuffer
    GetRemoteInfoFromSI udtSockAddr, m_lngRemotePort, m_strRemoteHostIP, m_strRemoteHost
End If
End Sub
'Clean resolution system that is in charge of
'asynchronous hostname resolutions.
Private Sub CleanResolutionSystem()
'Dim varAsynHandle As Variant
'Dim lngResult As Long
''cancel async resolutions if they're still running
'For Each varAsynHandle In m_colWaitingResolutions
'    lngResult = api_WSACancelAsyncRequest(varAsynHandle)
'    If lngResult = 0 Then
'        Set m_colWaitingResolutions = Nothing
'        Set m_colWaitingResolutions = New Collection
'        'free memory buffer where resolution results are stored
'        FreeMemory
'    End If
'Next
End Sub
Public Sub Listen()
If m_enmState <> sckClosed And m_enmState <> sckOpen Then
    Err.Raise sckInvalidOp, "CSocketMaster.Listen", "Invalid operation at current state"
End If
If Not SocketExists Then Exit Sub
If Not BindInternal Then Exit Sub
Dim lngResult As Long
lngResult = api_listen(m_lngSocketHandle, SOMAXCONN)
If lngResult = SOCKET_ERROR Then
    Dim lngErrorCode As Long
    lngErrorCode = Err.LastDllError
    Err.Raise lngErrorCode, "CSocketMaster.Listen", GetErrorDescription(lngErrorCode)
Else
    m_enmState = sckListening:   If traceSocket Then Debug.Print "STATE: sckListening"
End If
End Sub
Public Sub Accept(requestID As Long)
'If m_enmState <> sckClosed Then
'    Err.Raise sckInvalidOp, "CSocketMaster.Accept", "Invalid operation at current state"
'End If
'm_lngSocketHandle = requestID
'm_enmProtocol = sckTCPProtocol
'ProcessOptions
'If Not modSocketMaster.IsAcceptRegistered(requestID) Then
'    If IsSocketRegistered(requestID) Then
'        m_lngSocketHandle = INVALID_SOCKET
'        m_lngRecvBufferLen = 0
'        m_lngSendBufferLen = 0
'        Err.Raise sckBadState, "CSocketMaster.Accept", "Wrong protocol or connection state for the requested transaction or request"
'    Else
'        m_blnAcceptClass = True
'        m_enmState = sckConnected:   If traceSocket Then Debug.Print "STATE: sckConnected"
'        GetLocalInfo m_lngSocketHandle, m_lngLocalPortBind, m_strLocalIP
'        modSocketMaster.RegisterSocket m_lngSocketHandle, Me, False
'        Exit Sub
'    End If
'End If
'Dim clsSocket As CSocketMaster
'Set clsSocket = GetAcceptClass(requestID)
'modSocketMaster.UnregisterAccept requestID
'GetLocalInfo m_lngSocketHandle, m_lngLocalPortBind, m_strLocalIP
'GetRemoteInfo m_lngSocketHandle, m_lngRemotePort, m_strRemoteHostIP, m_strRemoteHost
'm_enmState = sckConnected:  If traceSocket Then Debug.Print "STATE: sckConnected"
'If clsSocket.BytesReceived > 0 Then
'    clsSocket.GetData m_strRecvBuffer
'End If
'modSocketMaster.Subclass_ChangeOwner requestID, Me
'If Len(m_strRecvBuffer) > 0 Then RaiseEvent DataArrival(Len(m_strRecvBuffer))
'If clsSocket.State = sckClosing Then
'    m_enmState = sckClosing:  If traceSocket Then Debug.Print "STATE: sckClosing"
'    RaiseEvent CloseSck
'End If
'Set clsSocket = Nothing
End Sub
'Retrieves local info from a connected socket.
'If succeeds returns TRUE and loads the arguments.
'If fails returns FALSE and arguments are not loaded.
Private Function GetLocalInfo(ByVal lngSocket As Long, ByRef lngLocalPort As Long, ByRef strLocalIP As String) As Boolean
GetLocalInfo = False
Dim lngResult As Long
Dim udtSockAddr As sockaddr_in
lngResult = api_getsockname(lngSocket, udtSockAddr, LenB(udtSockAddr))
If lngResult = SOCKET_ERROR Then
    lngLocalPort = 0
    strLocalIP = ""
Else
    GetLocalInfo = True
    lngLocalPort = IntegerToUnsigned(api_ntohs(udtSockAddr.sin_port))
    strLocalIP = StringFromPointer(api_inet_ntoa(udtSockAddr.sin_addr))
End If
End Function
'Retrieves remote info from a connected socket.
'If succeeds returns TRUE and loads the arguments.
'If fails returns FALSE and arguments are not loaded.
Private Function GetRemoteInfo(ByVal lngSocket As Long, ByRef lngRemotePort As Long, ByRef strRemoteHostIP As String, ByRef strRemoteHost As String) As Boolean
GetRemoteInfo = False
Dim lngResult As Long
Dim udtSockAddr As sockaddr_in
lngResult = api_getpeername(lngSocket, udtSockAddr, LenB(udtSockAddr))
If lngResult = 0 Then
    GetRemoteInfo = True
    GetRemoteInfoFromSI udtSockAddr, lngRemotePort, strRemoteHostIP, strRemoteHost
Else
   lngRemotePort = 0
   strRemoteHostIP = ""
   strRemoteHost = ""
End If
End Function
'Gets remote info from a sockaddr_in structure.
Private Sub GetRemoteInfoFromSI(ByRef udtSockAddr As sockaddr_in, ByRef lngRemotePort As Long, ByRef strRemoteHostIP As String, ByRef strRemoteHost As String)
'Dim lngResult As Long
'Dim udtHostent As HOSTENT
lngRemotePort = IntegerToUnsigned(api_ntohs(udtSockAddr.sin_port))
strRemoteHostIP = StringFromPointer(api_inet_ntoa(udtSockAddr.sin_addr))
'lngResult = api_gethostbyaddr(udtSockAddr.sin_addr, 4&, AF_INET)
'If lngResult <> 0 Then
'    api_CopyMemory udtHostent, ByVal lngResult, LenB(udtHostent)
'    strRemoteHost = StringFromPointer(udtHostent.hName)
'Else
'    strRemoteHost = ""
'End If
End Sub
'Returns winsock incoming buffer length from an UDP socket.
Private Function GetBufferLenUDP() As Long
Dim lngResult As Long
Dim lngBuffer As Long
lngResult = api_ioctlsocket(m_lngSocketHandle, FIONREAD, lngBuffer)
If lngResult = SOCKET_ERROR Then
    GetBufferLenUDP = 0
Else
    GetBufferLenUDP = lngBuffer
End If
End Function
'Empty winsock incoming buffer from an UDP socket.
Private Sub EmptyBuffer()
Dim B As Byte
api_recv m_lngSocketHandle, B, Len(B), 0&
End Sub
'Adds the socket to the m_colSocketsInst collection, and
'registers that socket with WSAAsyncSelect Winsock API
'function to receive network events for the socket.
'If this socket is the first one to be registered, the
'window and collection will be created in this function as well.
Public Function RegisterSocket() As Boolean
'Do we need to register socket events?
    Dim lngEvents As Long
    Dim lngResult As Long
    Dim lngErrorCode As Long
    lngEvents = FD_READ Or FD_WRITE Or FD_ACCEPT Or FD_CONNECT Or FD_CLOSE
    lngResult = api_WSAAsyncSelect(m_lngSocketHandle, m_lngHwnd, SOCKET_MESSAGE, lngEvents)
    If lngResult = SOCKET_ERROR Then
         If traceSocket Then Debug.Print "ERROR trying to register events from socket " & m_lngSocketHandle
        lngErrorCode = Err.LastDllError
        Err.Raise lngErrorCode, "modSocketMaster.RegisterSocket", GetErrorDescription(lngErrorCode)
    Else
         If traceSocket Then Debug.Print "OK Registered events from socket " & m_lngSocketHandle
    End If
    RegisterSocket = True
End Function
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Public Function ResolveHost(ByVal strHost As String, ByVal lngHOSTENBuf As LongPtr) As LongPtr
Dim lngAsynHandle As LongPtr
    lngAsynHandle = api_WSAAsyncGetHostByName(m_lngHwnd, RESOLVE_MESSAGE, strHost, ByVal lngHOSTENBuf, MAXGETHOSTSTRUCT)
    ResolveHost = lngAsynHandle
End Function
#Else
Public Function ResolveHost(ByVal strHost As String, ByVal lngHOSTENBuf As Long) As Long
Dim lngAsynHandle As Long
    lngAsynHandle = api_WSAAsyncGetHostByName(m_lngHwnd, RESOLVE_MESSAGE, strHost, ByVal lngHOSTENBuf, MAXGETHOSTSTRUCT)
    ResolveHost = lngAsynHandle
End Function
#End If


Attribute VB_Name = "CommForm"
Attribute VB_Base = "0{36195B8B-8601-4C3C-88DB-6ED1C9FD5079}{7114D2FA-59EE-47EC-A4AC-5597E97E9256}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' 05/17/2009 Windows back end enabled - to work with jserv_xld_2.4.jar
'Works with CSocketMaster
'------- Jserv/Cli.p Protocol Constants ---------------
' (see also Progress ttlibm.i)
Const MFLD_DEL        As Integer = 1
Const MVAL_DEL        As Integer = 3
Const MREF_DEL        As Integer = 11
Const MLINE_DEL       As Integer = 20
Const MRESP_DEL1      As Integer = 3
Const MRESP_DEL2      As Integer = 9
Const MRESP_END       As Integer = 2
Const MAX_PARAM_SIZE  As Long = 14000   ' (must be < 30k)
Const RESP_TIMEOUT    As Long = 900000  ' 15 min
Const CONN_TIMEOUT    As Long = 60000   ' 1 min
Const TIMEOUT_STEP    As Long = 200     ' 0.2 sec
'-------------------------------------------------------
Const msgTerminated   As String = "Connection Terminated by Server!"
Const msgAborted      As String = "Connection Aborted."
Const msgTimeout      As String = "Response Timeout Expired!"
Const msgConnFailed   As String = "Connection Failed!"
Const msgProtocol     As String = "Protocol Error - "

Dim Host              As String
Dim port              As Long

Dim iCmdMsgs          As String
Dim iCmdCodes         As String
Dim iCmdResponse      As String
Dim iErrMsg           As String
Dim iCmdSuccess       As Boolean

Dim rcvdData          As String
Dim startPos          As Long
Dim bCheckHi          As Boolean
Dim bDataArrival      As Boolean

Dim multiProg         As String
Dim multiAction       As String
Dim multiParams       As String
Dim multiLine         As String
Dim multiClbkParam    As Variant
Dim multiResult       As Boolean

Public WithEvents tcpClient As CSocketMaster
Attribute tcpClient.VB_VarHelpID = -1
'By Victor H. Garcia, x64 compatibility issue
#If Win64 Then
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If
Private Sub UserForm_Initialize()
  initTcpClient
End Sub
'============================
'===  Public Properties
'============================
Public Property Get pCmdSuccess() As Boolean
  pCmdSuccess = iCmdSuccess
End Property
' Get the whole Cmd-Response
Public Property Get pCmdResponse() As String
  pCmdResponse = FromUTF8(iCmdResponse)
End Property
' Get Cmd-Response Messages (separated by ";")
Public Property Get pCmdMessages() As String
  pCmdMessages = TrimNonPrinting(iCmdMsgs)
End Property
' Get Cmd-Response Codes (separated by HT)
Public Property Get pCmdCodes() As String
  pCmdCodes = TrimNonPrinting(iCmdCodes)
End Property
' Get Critical Error Message
Public Property Get pErrorMessage() As String
  pErrorMessage = iErrMsg
End Property
'============================
'===  Public Methods
'============================
Public Function connectToQad() As Boolean
  Dim vTemp As Variant
  connectToQad = True
  initCon
  If (tcpClient.State <> 7) Then
    vTemp = Application.Cursor
    Application.Cursor = xlDefault
    MsgBox iErrMsg & Chr$(10) _
      & Chr$(10) & "Can't connect to QAD server. Check setup." _
      & Chr$(10) & "Make sure you connected to network or contact IT." _
      & Chr$(10), vbExclamation ' vbCritical
    'Setup.promptForSetup
    Application.Cursor = vTemp
    connectToQad = False
    'initCon
    'If (tcpClient.State <> 7) Then
    '  connectToQad = False
    '  MsgBox iErrMsg & Chr$(10) _
    '    & Chr$(10) & "Can't connect to QAD server." _
    '    & Chr$(10) & "Make sure you connected to network or contact IT." _
    '    & Chr$(10), vbCritical
    'End If
  End If
End Function
Public Sub closeCon()
  Dim strData As String
  On Local Error GoTo xClose
  DoEvents
  If tcpClient.State = 7 Then
      tcpClient.SendData "_QUIT_" & Chr$(10)
      Sleep 200
      DoEvents
      If tcpClient.State = 7 Then tcpClient.GetData strData
  End If
xClose:
  tcpClient.CloseSck
  Unload Me
  DoEvents
End Sub
Public Sub abortCon()
  On Local Error GoTo endsub
  DoEvents
  tcpClient.CloseSck
endsub:
  setErrMsg msgAborted
  DoEvents
End Sub
Public Function runRawCmd(iprg As String, iParams As String) As Boolean
  runRawCmd = False
  If Not sendCmd("_RUN_", iprg, iParams) Then Exit Function
  If Not getCmdResponse() Then Exit Function
  runRawCmd = True
End Function
Public Function runCmd(iprg As String, iParams As String) As Boolean
  Dim vStr As String, vPos As Long
  runCmd = False
  If Not sendCmd("_RUN_", iprg, iParams) Then Exit Function
  If Not getCmdResponse() Then Exit Function
  ' Parse Response:
  vPos = InStr(iCmdResponse, Chr$(9))
  If vPos <= 0 Then
    iErrMsg = msgProtocol & "1"
    Exit Function
  End If
  runCmd = True
  If Right$(iCmdResponse, 1) = Chr$(10) Then
    iCmdResponse = Left$(iCmdResponse, Len(iCmdResponse) - 1) ' Skip LF at the end
  End If
  'iCmdSuccess = (Left$(iCmdResponse, vPos - 1) = "true")  'AK 10/22/08
  iCmdSuccess = InStr(iCmdResponse, "true") > 0            'AK 10/22/08
  vStr = Mid$(iCmdResponse, vPos + 1)
  vPos = InStr(vStr, Chr$(3))
  If vPos > 0 Then
    iCmdMsgs = Left$(vStr, vPos - 1)
    iCmdCodes = Mid$(vStr, vPos + 1)
  Else
    iCmdMsgs = vStr
  End If
End Function
'===================================
'===  Multi-Validation Support
'===================================
Public Sub multiOpenCmd(iProg As String, iAction As String, Optional iClbkParam As Variant = Null)
  multiProg = iProg
  multiAction = iAction
  multiClbkParam = iClbkParam
  multiParams = ""
  multiLine = ""
  multiResult = True
End Sub
Public Sub multiAddValue(iRef As String, ParamArray strValues() As Variant)
    Dim Line As String
    Line = Join(strValues(), Chr$(MFLD_DEL)) & Chr$(MREF_DEL) & iRef & Chr$(MVAL_DEL)
    multiLine = multiLine & Line
End Sub
Public Sub multiPutLine()
    multiLine = multiLine & Chr$(MLINE_DEL)
    If (Len(multiParams) + Len(multiLine)) > MAX_PARAM_SIZE Then
        multiRunCmd
        multiParams = ""
    End If
    multiParams = multiParams & multiLine
    multiLine = ""
End Sub
Public Function multiJoin(ListValue As String, iRef As String, ParamArray strValues() As Variant)
    multiJoin = ListValue & Join(strValues(), Chr$(MFLD_DEL)) & Chr$(MREF_DEL) & iRef & Chr$(MVAL_DEL)
End Function
Public Sub multiPut(iRef As String, ParamArray strValues() As Variant)
    Dim Line As String
    Line = Join(strValues(), Chr$(MFLD_DEL)) & Chr$(MREF_DEL) & iRef & Chr$(MVAL_DEL)
    If (Len(multiParams) + Len(Line)) > MAX_PARAM_SIZE Then
        multiRunCmd
        multiParams = ""
    End If
    multiParams = multiParams & Line
End Sub
Public Function multiCloseCmd() As Boolean
  If Len(multiParams) > 0 Then
    multiRunCmd
    multiParams = ""
  End If
  multiCloseCmd = multiResult
End Function
Private Sub multiRunCmd()
  Dim myArr() As String, elem As Variant, desc As String, ref As String, Pos As Long
  If Not multiResult Then Exit Sub
  If sendCmd("_RUN_", multiProg, multiAction & Chr$(9) & multiParams & Chr$(9)) _
  Then
    If getCmdResponse() Then
      myArr = Split(iCmdResponse, Chr$(MRESP_DEL2))
      For Each elem In myArr
        elem = Replace(elem, Chr(10), "") 'AK 10/22/08
        elem = Replace(elem, Chr(13), "") 'AK 10/22/08
        Pos = InStr(elem, Chr$(MRESP_DEL1))
        If Pos > 0 Then
          multiErrCallback Left$(elem, Pos - 1), Mid$(elem, Pos + 1), multiClbkParam
        Else
          elem = Trim(elem)     'AK 10/22/08
          If Len(elem) > 0 Then 'AK 10/22/08
            multiErrCallback Str$(elem), "", multiClbkParam
          End If                'AK 10/22/08
        End If
      Next
      multiResult = True   ' *** OK ***
      Exit Sub
    End If
  End If
  multiResult = False
End Sub
'============================
'===  tcpClient Events
'============================
Private Sub tcpClient_DataArrival(ByVal bytesTotal As Long)
  bDataArrival = True
End Sub
Private Sub tcpClient_Close()
  tcpClient.CloseSck
End Sub
Private Sub tcpClient_Error(ByVal Number As Integer, Description As String, ByVal sCode As Long, ByVal Source As String, ByVal HelpFile As String, ByVal HelpContext As Long, CancelDisplay As Boolean)
  iErrMsg = "Socket Error " & Number & ": " & Description
End Sub
'============================
'===  Private Helpers
'============================
Private Sub initTcpClient()
Set tcpClient = New CSocketMaster
  rcvdData = ""
  startPos = 1
  bCheckHi = True
  bDataArrival = False
  iErrMsg = ""
  Host = Setup.qHost
  port = Setup.qPort
  tcpClient.RemoteHost = Host
  tcpClient.RemotePort = port
  tcpClient.Protocol = sckTCPProtocol
End Sub
Private Function sendCmd(iact As String, iprg As String, iParams As String) As Boolean
  On Local Error GoTo sendErr
  sendCmd = False
  iCmdResponse = ""
  iCmdMsgs = ""
  iCmdCodes = ""
  iCmdSuccess = False
  DoEvents
  If tcpClient.State = 7 Then
    tcpClient.SendData iact & Chr$(2) & iprg & Chr$(2) & iParams & Chr$(10)
    sendCmd = True
  Else
    setErrMsg msgAborted
  End If
  Exit Function
sendErr:
  setErrMsg msgAborted
End Function
Private Sub initCon()
  Dim tm As Long
  On Local Error GoTo InitConErr
  DoEvents
  If tcpClient.State <> 0 Then
    tcpClient.CloseSck
    Sleep 1000
  End If
  If tcpClient.State = 0 Then
    initTcpClient
    tcpClient.Connect
    Sleep 100
    DoEvents
  End If
  ' Connecting...
  For tm = 0 To CONN_TIMEOUT Step TIMEOUT_STEP
    Select Case tcpClient.State
      Case 4, 5, 6 ' sckResolvingHost, sckHostResolved, sckConnecting
        Sleep TIMEOUT_STEP
        DoEvents
      Case Else
        Exit For   ' Stop waiting
    End Select
  Next tm
  If tcpClient.State <> 7 Then iErrMsg = msgConnFailed
  Exit Sub
InitConErr:
  setErrMsg msgConnFailed
  DoEvents
End Sub
Private Function tryCmdResponse() As Boolean
    Dim Pos As Long
    tryCmdResponse = False
    If startPos > Len(rcvdData) Then Exit Function
    Pos = InStr(startPos, rcvdData, Chr$(MRESP_END))
    If (Pos <= 0) Then
      startPos = Len(rcvdData) + 1    ' There is no MRESP_END
      ' Check  "Bye"
      If Len(rcvdData) >= 4 And Right$(rcvdData, 4) = ("Bye" & Chr$(10)) Then
        'TODO: .... Skip Bye line from rcvdData
        iErrMsg = msgTerminated
      End If
    ElseIf (Pos >= Len(rcvdData)) Then
      startPos = Len(rcvdData)        ' There is no LF after MRESP_END yet
    Else                              ' OK: 0 < pos < Len(rcvdData)
      iCmdResponse = Left$(rcvdData, Pos - 1)
      rcvdData = Mid$(rcvdData, Pos + 2) ' Get data after MRESP_END and LF
      startPos = 1
      ' Skip "Hi"
      If bCheckHi Then
        If Left$(iCmdResponse, 3) = ("Hi" & Chr$(10)) Then
          iCmdResponse = Mid$(iCmdResponse, 4)
        End If
        bCheckHi = False
      End If
      tryCmdResponse = True
    End If
End Function
Private Function getCmdResponse() As Boolean
    Dim strData As String, tm As Long
    On Local Error GoTo socketErr
    getCmdResponse = False
    For tm = 0 To RESP_TIMEOUT Step TIMEOUT_STEP
      DoEvents
      If tryCmdResponse() Then
        getCmdResponse = True   '*** OK ***
        Exit Function
      End If
      If tcpClient.State <> 7 Or Len(iErrMsg) > 0 Then
        Exit For  '*** Socket Error ***
      End If
      strData = ""
      If bDataArrival Then
        bDataArrival = False
        tcpClient.GetData strData
      End If
'AK'      strData = FromUTF8(strData)
      If Len(strData) > 0 Then
        rcvdData = rcvdData & strData
      Else
        Sleep TIMEOUT_STEP
      End If
    Next tm
socketErr:
    setErrMsg IIf(tcpClient.State = 7, msgTimeout, msgAborted)
End Function
Public Function TrimNonPrinting(ByVal txt As String) As String
  Dim ch As String
  ' Remove leading characters.
  Do While Len(txt) > 0
    ch = Left$(txt, 1)
    If (ch >= " ") And (ch <= "~") Then Exit Do
    txt = Mid$(txt, 2)
  Loop
  ' Remove trailing characters.
  Do While Len(txt) > 0
    ch = Mid$(txt, Len(txt))
    If (ch >= " ") And (ch <= "~") Then Exit Do
    txt = Mid$(txt, 1, Len(txt) - 1)
  Loop
  TrimNonPrinting = txt
End Function
Private Sub setErrMsg(defMsg As String)
  If Len(iErrMsg) <= 0 Then
    iErrMsg = IIf(Err.Number <> 0, Err.Description, defMsg)
  End If
End Sub
'=========================================
'===  Parser
'=========================================
Public Function NumEntriesFld(ByRef strText As String) As Long
    NumEntriesFld = NumEntries(strText, Chr(MFLD_DEL))
End Function
Public Function NumEntriesVal(ByRef strText As String) As Long
    NumEntriesVal = NumEntries(strText, Chr(MFLD_VAL))
End Function
Public Function NumEntriesRef(ByRef strText As String) As Long
    NumEntriesRef = NumEntries(strText, Chr(MFLD_REF))
End Function
Public Function NumEntriesLine(ByRef strText As String) As Long
    NumEntriesLine = NumEntries(strText, Chr(MLINE_DEL))
End Function
Public Function EntryFld(ByVal intPiec As Long, ByRef strText As String) As String
    EntryFld = Entry(intPiec, strText, Chr(MFLD_DEL))
End Function
Public Function EntryVal(ByVal intPiec As Long, ByRef strText As String) As String
    EntryVal = Entry(intPiec, strText, Chr(MVAL_DEL))
End Function
Public Function EntryRef(ByVal intPiec As Long, ByRef strText As String) As String
    EntryRef = Entry(intPiec, strText, Chr(MREF_DEL))
End Function
Public Function EntryLine(ByVal intPiec As Long, ByRef strText As String) As String
    EntryLine = Entry(intPiec, strText, Chr(MLINE_DEL))
End Function
Private Function CountIn(ByRef strText As String, ByRef strFind As String) As Long
  Dim inCount As Long
  Dim intPos  As Long
  If Len(strFind) > 0 Then
    intPos = 1
    Do
      intPos = InStr(intPos, strText, strFind)
      If intPos > 0 Then
        intCount = intCount + 1
        intPos = intPos + Len(strFind)
      End If
    Loop While intPos > 0
  Else
    intCount = 0
  End If
  CountIn = intCount
End Function
Public Function NumEntries(ByRef strText As String, ByVal strDelimiter As String) As Long
  Dim strChar As String * 1
  If Len(strText) = 0 Then
    NumEntries = 0
  Else
    strChar = Left(strDelimiter, 1)
    NumEntries = CountIn(strText, strChar) + 1
  End If
End Function
Public Function Entry(ByVal intPiec As Long, ByRef strText As String, ByVal strDelimiter As String) As String
  Dim intPos     As Long
  Dim intLastPos As Long
  Dim intLoop    As Long
  Dim intPos1    As Long
  Dim strChar    As String * 1
  intPos = 0
  intLastPos = 0
  intLoop = intPiec
  strChar = Left(strDelimiter, 1)
  Do While intLoop > 0
    intLastPos = intPos
    intPos1 = InStr(intPos + 1, strText, strChar)
    If intPos1 > 0 Then
      intPos = intPos1
      intLoop = intLoop - 1
    Else
      intPos = Len(strText) + 1
      Exit Do
    End If
  Loop
  If (intPos = 0) And (intLoop <> intPiece) And (intLoop > 1) Then
    Entry = ""
  Else
    Entry = Mid(strText, intLastPos + 1, intPos - intLastPos - 1)
  End If
End Function
Attribute VB_Name = "Module1"
' 25.15.4 v2.12i - look-ups
' 08/01/2009
' eb2, asian fix
Option Explicit
Const firstRow      As Long = 8
Const firstCol      As Long = 1
Const lastCol       As Long = 8
Const descrCol      As Long = 5

Const appErrNum     As Long = 100

' User Input Cells:
Const ref_entity    As String = "c1"
Const ref_entityTo  As String = "d1"
Const ref_curr      As String = "c2"
Const ref_spZero    As String = "d2"
Const ref_beg_dt    As String = "c3"
Const ref_end_dt    As String = "d3"
Const ref_accFrom   As String = "c4"
Const ref_accTo     As String = "d4"
Const ref_subFrom   As String = "c5"
Const ref_subTo     As String = "d5"
Const ref_ccFrom    As String = "c6"
Const ref_ccTo      As String = "d6"

Const ref_status    As String = "E1"

Const progressPrg   As String = "tttrbl.p"
Const qadMenu       As String = "25.15.4"
Const dateFmt       As String = "mm/dd/yy"                  'This should correspond to progress session date
Const amtFmt        As String = "#,##0.00;[Red](#,##0.00)"  '
Const accFmt        As String = "_($* #,##0.00_);_($* (#,##0.00);;_(@_)"   '"#,##0.00;[Red](#,##0.00);"
Const decFmt        As String = "#,##0.00;[Red](#,##0.00);"
Const decFmt2       As String = "#,##0.0;[Red](#,##0.0)"
Const intFmt        As String = "#;[Red](#);"
Const costFmt       As String = "#,##0.00000"
Const pctFmt        As String = "0.00%;[Red]0.00%;"
Const rndMaxDec     As Integer = 2

' User Input Values:
Dim entity          As String
Dim entityTo        As String
Dim date_from       As Date
Dim date_to         As Date
Dim curr            As String
Dim domain          As String
Dim accFrom         As String
Dim accTo           As String
Dim subFrom         As String
Dim subTo           As String
Dim ccFrom          As String
Dim ccTo            As String

Dim validError      As Boolean
Dim lastRow         As Long
' Dim lastCol         As Long
Dim dbName          As String

Dim hasQADOutput    As Boolean

Dim mySheet         As Worksheet
Dim appVer          As Integer
'=========================================
'===  CommForm.multiPut Callback Function
'=========================================
Public Sub multiErrCallback(iErrDesc As String, iRef As String, iClbkParam As Variant)
Attribute multiErrCallback.VB_ProcData.VB_Invoke_Func = " \n14"
  validError = True
  On Error GoTo critical  ' Guard against bad iRef
  Application.EnableCancelKey = xlErrorHandler
  
  If Len(iRef) > 0 Then
    setComment mySheet.Range(iRef), iErrDesc  ' AddComent to Cell
    Exit Sub
  End If
critical:
  ' Handle Critical Server Errors (not related to cells' values ):
  connStatus iErrDesc
  If statForm.Visible Then
    writeStatus iErrDesc
  Else
    MsgBox iErrDesc, vbCritical
  End If
End Sub
'============================
'===  Setup
'============================
Private Sub runSetup()
Attribute runSetup.VB_Description = "Setup"
Attribute runSetup.VB_ProcData.VB_Invoke_Func = "u\n14"
  setMySheet
  If ActiveSheet.name <> "worksheet" Then
    Exit Sub
  End If
  Setup.promptForSetup
End Sub
'============================
'===  Clear Data
'============================
Sub cleandata()  'CTRL+E
Attribute cleandata.VB_ProcData.VB_Invoke_Func = " \n14"
  setMySheet
  If ActiveSheet.name <> "worksheet" Then
    Exit Sub
  End If
  If Rows.Count > firstRow Then mySheet.Range(CStr(firstRow) & ":" & Rows.Count).Delete
  mySheet.Range(ref_status).ClearContents
End Sub
Private Sub initArea()
  Dim y As Long, x As Long, r As Range
  For x = 1 To lastCol
    Set r = mySheet.Cells(firstRow, x)
    If Not r.Comment Is Nothing Then r.Comment.Delete
    r.Interior.ColorIndex = 36
  Next x
  For y = firstRow To lastRow
    For x = 1 To lastCol
      Set r = mySheet.Cells(y, x)
      If Not r.Comment Is Nothing Then r.Comment.Delete
      r.Interior.ColorIndex = -4142
    Next x
  Next y
End Sub
Private Sub validateEntity()
  Dim c As Range
  CommForm.multiOpenCmd progressPrg, "ValidateEntity", Null
  Set c = mySheet.Range(ref_entity)
  CommForm.multiAddValue cellRef(c), CommForm.TrimNonPrinting(c.Value)
  Set c = mySheet.Range(ref_entityTo)
  CommForm.multiAddValue cellRef(c), CommForm.TrimNonPrinting(c.Value)
  CommForm.multiPutLine
  If Not CommForm.multiCloseCmd Then raiseError CommForm.pErrorMessage
End Sub
Private Sub validateCurr()
  Dim c As Range
  CommForm.multiOpenCmd progressPrg, "ValidateCurr", Null
  Set c = mySheet.Range(ref_curr)
  CommForm.multiPut cellRef(c), c.Text
  If Not CommForm.multiCloseCmd Then raiseError CommForm.pErrorMessage
End Sub
Private Sub validateDates()
  setMySheet
  getUserInput
  Dim c As Range
  CommForm.multiOpenCmd progressPrg, "ValidateDates", Null
  Set c = mySheet.Range(ref_beg_dt)
  CommForm.multiAddValue cellRef(c), formatDate(c.Value, True)
  Set c = mySheet.Range(ref_end_dt)
  CommForm.multiAddValue cellRef(c), formatDate(c.Value, True)
  CommForm.multiPutLine
  If Not CommForm.multiCloseCmd Then raiseError CommForm.pErrorMessage
End Sub
Private Sub writeStatus(iStr As String)
  statForm.addLine (iStr)
End Sub
Sub getTB()    'CTRL+W
Attribute getTB.VB_Description = "Download TB  ctrl+w"
Attribute getTB.VB_ProcData.VB_Invoke_Func = "w\n14"
   If Len(Setup.qHost) = 0 Then 'if db not selected give a prompt
     selectDB
     Exit Sub
   End If
  
  Dim param As String
  setMySheet
  If ActiveSheet.name <> "worksheet" Then
    Exit Sub
  End If
  waitCursor True
  connStatus ""
  validError = False
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  cleandata
  If Not getUserInput() Then GoTo stop_sub
  connStatus "Connecting..."
  If Not CommForm.connectToQad() Then
    connStatus CommForm.pErrorMessage
    GoTo stop_sub
  End If
  If Not setGlobUserid() Then GoTo stop_sub

  validateEntity
  If validError Then raiseError "Errors occured! Fix the data and try again."
  
  validateCurr
  If validError Then raiseError "Errors occured! Fix the data and try again."

  validateDates
  If validError Then raiseError "Errors occured! Fix the data and try again."
  
''Chr$(2) & entityTo &
  param = entity & "/" & entityTo & Chr$(9) & _
          curr & Chr$(9) & _
          formatDate(date_from, True) & Chr$(9) & formatDate(date_to, True) & Chr$(9) & _
          accFrom & Chr$(9) & accTo & Chr$(9) & _
          subFrom & Chr$(9) & subTo & Chr$(9) & _
          ccFrom & Chr$(9) & ccTo & Chr$(9) & mySheet.Range(ref_spZero)

'Debug.Print param

  If Not CommForm.runRawCmd(progressPrg, "getTB" & Chr$(9) & param) Then raiseError CommForm.pErrorMessage
  writeData CommForm.pCmdResponse, firstRow, firstCol, 9
  connStatus "Downloaded Successfully from " & dbName & " on " & Now()
  
stop_sub:
  Dim statMsg As String
  statMsg = getErrMessage() ' Firstly, store the Err message!

  CommForm.closeCon
  waitCursor False
  mySheet.Activate
  Beep

  If Len(statMsg) > 0 Then
    connStatus statMsg
    MsgBox statMsg, vbExclamation
  End If
End Sub
Private Sub writeData(mstr As String, StartRow As Long, startCol As Long, wLastCol As Long) 'wLastCol = expected # of fields
    Dim y As Long, x As Long, NL As Long, NF As Long, singleRow As Boolean
    Dim curRow As Long, strLine As String
    Dim strFld As String, strVal As String, strRef As String
    Dim ent() As String, col() As String
    Erase ent
    Erase col
    ReDim Preserve ent(wLastCol, y)
    ReDim Preserve col(x)
    NL = CommForm.NumEntriesLine(mstr) ' Number of Rows
    For y = 1 To NL Step 1
        ReDim Preserve ent(wLastCol, y)
        strLine = CommForm.EntryLine(y, mstr)
        strLine = CommForm.TrimNonPrinting(strLine)
        If Len(strLine) > 0 Then
            curRow = curRow + 1
            NF = CommForm.NumEntriesFld(strLine) ' Number of Fields defined in progress
            For x = 1 To NF
                strFld = CommForm.EntryFld(x, strLine)   'Get Field
                strVal = CommForm.EntryRef(1, strFld)    'Get Value Field
                strRef = CommForm.EntryRef(2, strFld)    'Get Type Field
                If strVal = "?" Then strVal = ""
                ent(x - 1, y - 1) = CStr(CommForm.TrimNonPrinting(strVal))
                If y = 1 Then
                  ReDim Preserve col(x)
                  col(x) = strRef
                End If
            Next x
        End If ' If Len(strLine) > 0 Then
    Next y
    
    lastRow = curRow + firstRow - 1
    hasQADOutput = True
    singleRow = False
    If lastRow < firstRow Then
      hasQADOutput = False  'DOES NOT HAVE QAD OUTPUT
    ElseIf lastRow = firstRow Then
      singleRow = True
    End If

    If Not hasQADOutput Then Exit Sub
   
    Dim fmt As String
    For x = 1 To NF
      'Debug.Print x & ":" & col(x)
      Select Case col(x)
      Case "S":  fmt = "@"
      Case "A":  fmt = GetCurrFormat() 'amtFmt
      Case "P":  fmt = pctFmt
      Case "I":  fmt = intFmt
      Case "N":  fmt = GetCurrFormat() 'decFmt
      Case "E":  fmt = decFmt2
      Case "C":  fmt = costFmt
      Case "D":  fmt = GetDateFormat() 'dateFmt
      Case Else: fmt = ""
      End Select
      mySheet.Range(Change2Letter(x) & CStr(firstRow) & ":" & Change2Letter(x) & CStr(lastRow)).NumberFormat = fmt
    Next x

    Dim r As Range
    Set r = mySheet.Range(Change2Letter(firstCol) & CStr(firstRow) & ":" & Change2Letter(wLastCol) & CStr(lastRow))
    
    'Paste array: for older versions of excel Transpose does not work properly, so use manual function Array2DTranspose
    If appVer < 11 Then
      r.Value = Array2DTranspose(ent)
    Else
      r.Value = Application.WorksheetFunction.Transpose(ent)
    End If

    'BORDERS
    r.Borders(xlDiagonalDown).LineStyle = xlNone
    r.Borders(xlDiagonalUp).LineStyle = xlNone
    r.Borders(xlEdgeLeft).LineStyle = xlNone
    r.Borders(xlEdgeTop).LineStyle = xlNone
    r.Borders(xlEdgeBottom).LineStyle = xlNone
    r.Borders(xlEdgeRight).LineStyle = xlNone
    With r.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 15
    End With
If Not singleRow Then
    With r.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 15
    End With
End If
    With r.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 15
    End With
    With r.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 15
    End With
    Set r = Nothing
End Sub
'============================
'===  Module Helpers
'============================
Private Sub initInputCells(ParamArray cellNames() As Variant)
    Dim i As Integer, r As Range
    For i = 0 To UBound(cellNames())
      Set r = mySheet.Range(CStr(cellNames(i)))
      If Not r.Comment Is Nothing Then r.Comment.Delete
      r.Interior.ColorIndex = 36
    Next i
End Sub
Private Function getUserInput() As Boolean
  'setMySheet
  getUserInput = True
  initInputCells ref_entity, ref_entityTo, ref_curr, ref_beg_dt, ref_end_dt, ref_accFrom, ref_accTo, ref_subFrom, ref_subTo, ref_ccFrom, ref_ccTo
  entity = Trim(CStr(mySheet.Range(ref_entity).Value))
  entityTo = Trim(CStr(mySheet.Range(ref_entityTo).Value))
  
  Dim cdt As String
  cdt = Trim(CStr(mySheet.Range(ref_beg_dt).Value))
  If Not IsDate(cdt) Then
    setComment mySheet.Range(ref_beg_dt), "Should be date"
    getUserInput = False
    Exit Function
  End If
  date_from = Format(cdt, GetDateFormat())
  
  cdt = Trim(CStr(mySheet.Range(ref_end_dt).Value))
  If Not IsDate(cdt) Then
    setComment mySheet.Range(ref_end_dt), "Should be date"
    getUserInput = False
    Exit Function
  End If
  date_to = Format(cdt, GetDateFormat())
  curr = Trim(CStr(mySheet.Range(ref_curr).Value))
  accFrom = Trim(CStr(mySheet.Range(ref_accFrom).Value))
  accTo = Trim(CStr(mySheet.Range(ref_accTo).Value))
  subFrom = Trim(CStr(mySheet.Range(ref_subFrom).Value))
  subTo = Trim(CStr(mySheet.Range(ref_subTo).Value))
  ccFrom = Trim(CStr(mySheet.Range(ref_ccFrom).Value))
  ccTo = Trim(CStr(mySheet.Range(ref_ccTo).Value))
  
End Function
Private Function setGlobUserid() As Boolean
  Dim Count As Integer
  Count = 0
  Do While Not loginToQAD()
    Count = Count + 1
    If Count > 3 Then
      MsgBox "Can't login to QAD server!", vbExclamation
      setGlobUserid = False
      Exit Function
    End If
    waitCursor False
    If Not loginForm.showForm Then
      connStatus "Login Canceled."
      MsgBox "Can't login to QAD server!", vbExclamation
      setGlobUserid = False
      Exit Function
    End If
    waitCursor True
    connStatus ""
  Loop
  setGlobUserid = True
End Function
Private Function loginToQAD() As Boolean
  Dim objCreg As Object, userID As String, Password As String
  loginToQAD = False
  dbName = "QAD DB"
  userID = loginForm.userID
  Password = loginForm.userPass
  If Len(userID) <= 0 Then
    connStatus "Please Log In."
    Exit Function
  End If
  If Not CommForm.runCmd(progressPrg, "setUser" & Chr$(9) & userID & Chr$(9) & Password & Chr$(9) & qadMenu) Then
    raiseError CommForm.pErrorMessage
  End If
  loginToQAD = CommForm.pCmdSuccess
  If CommForm.pCmdSuccess Then
    ' Get DB Name
    If Not CommForm.runCmd("ttdbname.p", userID & Chr$(9) & Password) Then
      raiseError CommForm.pErrorMessage
    End If
    If (CommForm.pCmdSuccess) Then dbName = CommForm.pCmdMessages
    connStatus "You connected to " & dbName
  Else
    connStatus "Can't login: " & CommForm.pCmdMessages
  End If
End Function
Private Function connStatus(iStr As String)
  Dim ref As String
  ref = ref_status
  If ActiveSheet.name <> "worksheet" Then ref = "G1"
  mySheet.Range(ref).Value = iStr
  connStatus = iStr
End Function
Private Sub waitCursor(bWait As Boolean)
  Application.Cursor = IIf(bWait, xlWait, xlDefault)
End Sub
Private Sub setComment(iCell As Range, iStr As String)
  validError = True
  iCell.Interior.ColorIndex = 3
  If Not iCell.Comment Is Nothing Then iCell.Comment.Delete
  iCell.AddComment "ERROR: " & iStr
  With iCell.Comment.Shape
    .Width = 200
    .Height = 30
  End With
End Sub
Private Sub raiseError(desc As String, Optional src As String = "", Optional num As Long = 0)
  Err.Raise appErrNum + num, src, desc
End Sub
Private Function getErrMessage()
  Dim descr As String
  descr = ""
  If Err.Number <> 0 Then
    descr = Err.Description
    If Err.Source <> "" Then descr = descr & " (" & Err.Source & ":" & Err.Number & ")"
  End If
  getErrMessage = descr
End Function
Private Sub setMySheet()
  Set mySheet = ActiveSheet 'ThisWorkbook.Worksheets(SheetN)
  If IsNumeric(Left(Application.Version, InStr(Application.Version, ".") - 1)) Then
    appVer = CInt(Left(Application.Version, InStr(Application.Version, ".") - 1))
  Else
    MsgBox "Unknown version of Excel. Please call IT." & Application.Version, vbCritical
  End If
End Sub
Private Sub showReport(params As String)
  waitCursor True
  connStatus ""
  validError = False
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  'If Not getUserInput() Then GoTo stop_sub
  connStatus "Connecting..."
  If Not CommForm.connectToQad() Then
    connStatus CommForm.pErrorMessage
    GoTo stop_sub
  End If
  If Not setGlobUserid() Then GoTo stop_sub
  'validateEntity
  'If validError Then raiseError "Errors occured! Fix the data and try again."
  If Not CommForm.runRawCmd(progressPrg, params) Then
    raiseError CommForm.pErrorMessage
    GoTo stop_sub
  End If
  connStatus "Downloaded Successfully from " & dbName & " on " & Now()
  report.setText CommForm.pCmdResponse
stop_sub:
  Dim statMsg As String
  statMsg = getErrMessage() ' Firstly, store the Err message!
  CommForm.closeCon
  waitCursor False
  mySheet.Activate
  Beep
  If Len(statMsg) > 0 Then
    connStatus statMsg
    MsgBox statMsg, vbExclamation
  Else
    report.show
  End If
End Sub
Sub closeThisSheet() 'CTRL+e
Attribute closeThisSheet.VB_Description = "Closes Drill Down Sheet  ctrl+e"
Attribute closeThisSheet.VB_ProcData.VB_Invoke_Func = "e\n14"
  setMySheet
  If ActiveSheet.name = "worksheet" Then Exit Sub
  If ActiveSheet.name = "acc-dd" Then Exit Sub
  If ActiveSheet.name = "db" Then Exit Sub
  ThisWorkbook.Worksheets("worksheet").Activate
  Application.DisplayAlerts = False
  mySheet.Delete
  Application.DisplayAlerts = True
  setMySheet
  
End Sub
Public Sub showAccdd()  'CTRL+D
Attribute showAccdd.VB_Description = "Account Drill Down  ctrl+d"
Attribute showAccdd.VB_ProcData.VB_Invoke_Func = "d\n14"
   If Len(Setup.qHost) = 0 Then 'if db not selected give a prompt
     selectDB
     Exit Sub
   End If
  
  Dim accDesc As String, newSheetName As String
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  setMySheet
  If ActiveSheet.name <> "worksheet" Then Exit Sub
  If ActiveCell.Row < firstRow Then Exit Sub
  getUserInput 'Grabs: entity, date_from, date_to, curr
  Dim acc As String, sa As String, cc As String
  acc = mySheet.Cells(Application.ActiveCell.Row, firstCol + 1).Value
  sa = mySheet.Cells(Application.ActiveCell.Row, firstCol + 2).Value
  cc = mySheet.Cells(Application.ActiveCell.Row, firstCol + 3).Value
  accDesc = mySheet.Cells(Application.ActiveCell.Row, firstCol + 4).Value
  acc = acc & "-" & sa & "-" & cc
  If acc = "--" Then Exit Sub
  
  If SheetExists(acc) Then
    ThisWorkbook.Worksheets(acc).Activate
    MsgBox "Sheet " & acc & " already exists"
    Exit Sub
  End If
ThisWorkbook.Worksheets("acc-dd").Copy After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count)
newSheetName = getSheet("acc-dd (")
If newSheetName = "" Then
  MsgBox "Problem getting drill down, please contact IT", vbCritical
  Exit Sub
End If
Set mySheet = ThisWorkbook.Worksheets(newSheetName)
  mySheet.name = acc
  mySheet.Range("B1").Value = acc & " " & accDesc
  mySheet.Visible = xlSheetVisible
  mySheet.Activate
  showDD "accDet" & Chr$(9) & acc & Chr$(9) & entity & "/" & entityTo _
    & Chr$(9) & formatDate(date_from, True) _
    & Chr$(9) & formatDate(date_to, True)

stop_sub:
  Dim statMsg As String
  statMsg = getErrMessage() ' Firstly, store the Err message!
  CommForm.closeCon
  waitCursor False
  'mySheet.Activate
  Beep
  If Len(statMsg) > 0 Then
    connStatus statMsg
    MsgBox statMsg, vbExclamation
  End If
End Sub
Private Sub showDD(params As String)
  waitCursor True
  connStatus ""
  validError = False
  Set mySheet = ActiveSheet
  mySheet.Visible = xlSheetVisible
  
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  
  'If Not getUserInput() Then GoTo stop_sub
  connStatus "Connecting..."
  If Not CommForm.connectToQad() Then
    connStatus CommForm.pErrorMessage
    GoTo stop_sub
  End If
  If Not setGlobUserid() Then GoTo stop_sub
  'validateEntity
  'If validError Then raiseError "Errors occured! Fix the data and try again."
  If Not CommForm.runRawCmd(progressPrg, params) Then raiseError CommForm.pErrorMessage
  connStatus "Downloaded Successfully from " & dbName & " on " & Now()
  'report.setText CommForm.pCmdResponse
    
  writeData CommForm.pCmdResponse, firstRow, firstCol, 26

  If getLastRow(firstRow, 2) >= firstRow Then
    ActiveSheet.Range("M1").Formula = "=sum(M8:M" & CStr(getLastRow(firstRow, 2)) & ")"
  End If
  
stop_sub:
  Dim statMsg As String
  statMsg = getErrMessage() ' Firstly, store the Err message!
  CommForm.closeCon
  waitCursor False
  'mySheet.Activate
  Beep
  If Len(statMsg) > 0 Then
    connStatus statMsg
    MsgBox statMsg, vbExclamation
  End If
End Sub
Public Sub showTrn()
Attribute showTrn.VB_Description = "Show Transaction ctrl+t"
Attribute showTrn.VB_ProcData.VB_Invoke_Func = "t\n14"
  Set mySheet = ActiveSheet
  Dim trn
  trn = mySheet.Cells(Application.ActiveCell.Row, 2).Value
  showReport "showTrn" & Chr$(9) & trn
End Sub
Public Sub showDoc()
Attribute showDoc.VB_Description = "Show Document  ctrl+o"
Attribute showDoc.VB_ProcData.VB_Invoke_Func = "o\n14"
  Set mySheet = ActiveSheet
  Dim doc As String, dt As String
  dt = mySheet.Cells(Application.ActiveCell.Row, 11).Value
  doc = mySheet.Cells(Application.ActiveCell.Row, 10).Value
  If doc = Empty Then
     MsgBox "Document not available"
     Exit Sub
  End If
  If dt = "I" Then
    showReport "showInv" & Chr$(9) & doc
  ElseIf dt = "VO" Then
    showReport "showVch" & Chr$(9) & doc
  ElseIf dt = "IC" Then
    showReport "showIct" & Chr$(9) & doc
  ElseIf dt = "CK" Then
    showReport "showChk" & Chr$(9) & doc
  ElseIf dt = "P" Then
    showReport "showArChk" & Chr$(9) & doc
  Else
   MsgBox "Document Drill Down not available"
  End If
End Sub
Public Sub showPO() 'Ctrl+p
Attribute showPO.VB_ProcData.VB_Invoke_Func = "p\n14"
  Set mySheet = ActiveSheet
  Dim doc As String, dt As String, desc As String
  'desc = mySheet.Cells(Application.ActiveCell.Row, 12).Value
  'dt = mySheet.Cells(Application.ActiveCell.Row, 11).Value
  doc = mySheet.Cells(Application.ActiveCell.Row, 18).Value
  If Len(doc) = 0 Then
     MsgBox "Document PO not available"
     Exit Sub
  End If
  'If desc = Empty Then
  '   MsgBox "Document PO not available"
  '   Exit Sub
  'End If
  'If CommForm.NumEntries(desc, " ") < 2 Then
  '   MsgBox "Document PO not available"
  '   Exit Sub
  'End If
  'doc = CommForm.Entry(2, desc, " ")
  'If dt = "IC" And Left(desc, 6) = "RCT-PO" Then
    showReport "showPO" & Chr$(9) & doc
  'Else
  '   MsgBox "Document PO not available"
  'End If
End Sub
Public Sub showAPChecks()
  Set mySheet = ActiveSheet
  Dim doc As String
  doc = mySheet.Cells(Application.ActiveCell.Row, 24).Value
  If Len(doc) = 0 Then
     MsgBox "No Checks Available"
     Exit Sub
  End If
  showReport "showAPChecks" & Chr$(9) & doc
End Sub
Public Sub showVouchers()
  Set mySheet = ActiveSheet
  Dim doc As String
  doc = mySheet.Cells(Application.ActiveCell.Row, 18).Value
  If Len(doc) = 0 Then
     MsgBox "No Vouchers Available"
     Exit Sub
  End If
  showReport "showVouchers" & Chr$(9) & doc
End Sub
Property Get QADmenuPath()
 QADmenuPath = qadMenu
End Property
Sub showHelp()
  help.addText ("")
  help.addText ("Welcome to Excel Automation World!")
  help.addText ("")
  help.addText ("Use keyboard shortcuts:")
  help.addText ("Download" & Chr$(9) & "CTRL+w")
  help.addText ("Drill Down" & Chr$(9) & "CTRL+d")
  help.addText ("Setup" & Chr$(9) & Chr$(9) & "CTRL+u")
  help.addText ("Document" & Chr$(9) & "CTRL+o")
  help.addText ("Transaction" & Chr$(9) & "CTRL+t")
  help.addText ("PO" & Chr$(9) & "CTRL+p")
  help.addText ("Close Sheet" & Chr$(9) & "CTRL+e")
  help.addText ("")
  help.show
End Sub
Function getSheet(startsWith As String) As String
Dim sh As Worksheet
For Each sh In ThisWorkbook.Worksheets
  If startsWith = Left(sh.name, Len(startsWith)) Then
    getSheet = sh.name
    Exit Function
  End If
Next
getSheet = ""
End Function

Sub lookupCode()
Attribute lookupCode.VB_ProcData.VB_Invoke_Func = "l\n14"
  If Len(Setup.qHost) = 0 Then selectDB
  Dim params As String, iName As String, maxNumberRecordsLookup As Integer
  maxNumberRecordsLookup = 30
  
  delLookup
  setMySheet
  connStatus ""
  'If ActiveCell.Row < firstRow + 1 Then Exit Sub
  If Application.Intersect(ActiveSheet.Range("C5:D7"), ActiveCell) Is Nothing Then Exit Sub 'allow lookup only in range
  validError = False
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  'grab suppname
  iName = CStr(ActiveCell.Offset(-1, 0).Value) 'get description from the upper cell
  If Len(iName) = 0 Then Exit Sub
  waitCursor True
  connStatus "Connecting..."
  If Not CommForm.connectToQad() Then
    connStatus CommForm.pErrorMessage
    GoTo stop_sub
  End If
  If Not setGlobUserid() Then GoTo stop_sub
  If validError Then raiseError "Errors occured! Fix the data and try again."
  params = "lookupCode" & Chr$(9) & iName & Chr$(9) & CStr(Application.ActiveCell.Address) & Chr$(9) & _
    mySheet.Range("C2").Value & Chr$(9) & CStr(maxNumberRecordsLookup) 'C2 range is really not required
  If Not CommForm.runRawCmd(progressPrg, params) Then raiseError CommForm.pErrorMessage
  connStatus dbName & " at " & Now()
  prepareSelection CommForm.pCmdResponse
stop_sub:
  Dim statMsg As String
  statMsg = getErrMessage() ' Firstly, store the Err message!
  CommForm.closeCon
  waitCursor False
  mySheet.Activate
  If Len(statMsg) > 0 Then
    connStatus statMsg
  End If
End Sub
Private Sub prepareSelection(mstr As String)
    'First prepare 2 dimantional Array (table) and fill it with progress data
    Dim y As Long, x As Long, nbrOfCol As Integer, strLine As String, strVal As String, ent() As String
    Erase ent
    nbrOfCol = 2
    ReDim Preserve ent(nbrOfCol, y)
    For y = 1 To CommForm.NumEntriesLine(mstr)           'parse by line
        ReDim Preserve ent(nbrOfCol, y)
        strLine = CommForm.TrimNonPrinting(CommForm.EntryLine(y, mstr))
        If Len(strLine) > 0 Then
          For x = 1 To CommForm.NumEntriesFld(strLine)   'Number of Fields defined in progress
            ent(x - 1, y - 1) = CStr(CommForm.TrimNonPrinting(CommForm.EntryFld(x, strLine)))  'Get Field Value
            'Debug.Print ent(x - 1, y - 1)
          Next x
        End If   'If Len(strLine) > 0 Then
    Next y
Dim sh1 As Shape, gtop As Integer, gleft As Integer, i As Integer, lRes As Integer
setMySheet
'If ActiveCell.Row < firstRow + 1 Then Exit Sub
ActiveCell.Offset(-1, 0).Activate  'Select the cell
lRes = UBound(ent, 2)       'restrict max results by the number of lines in progress table
gtop = ActiveCell.Top + ActiveCell.Height     'coordinate of popup :remember active cell coordinates
gleft = ActiveCell.Offset(0, -1).Left         'coordinate of popup :ActiveCell.Left + ActiveCell.Width
For i = 1 To lRes
  Dim cdID As String, cdName As String
  cdID = ent(0, i - 1)
  cdName = ent(1, i - 1)
  Set sh1 = mySheet.Shapes.AddShape(msoShapeFlowchartProcess, gleft, gtop, 200, 20)
  sh1.Select
  With Selection
    .ShapeRange.Fill.ForeColor.RGB = RGB(229, 229, 255)
    If (i Mod 2) <> 0 Then .ShapeRange.Fill.ForeColor.RGB = RGB(255, 255, 204)
    .ShapeRange.Line.Visible = msoFalse
    .Characters.Text = cdName & " " & cdID
    sh1.AlternativeText = cdID & ":" & cdName
    .HorizontalAlignment = xlLeft
    .OnAction = "'ShapeClick " & sh1.ID & " '"
    .name = "lookupSh"
    .Height = ActiveCell.Height
    .Font.name = "Lucida Console"
    .Font.Size = 8
    .Font.Color = RGB(0, 0, 0)
    If i = lRes Then
      '.Characters.Text = "X"
      '.AutoSize = True
      .OnAction = "delLookup"
      .ShapeRange.Fill.ForeColor.RGB = RGB(255, 0, 0)
      '.Font.Bold = True
      '.Font.Size = 7
      '.Top = .Top - .Height
      .Left = gleft + 200 - .Width
      .Height = 5
    End If
  End With
  gtop = gtop + sh1.Height - 1
  Set sh1 = Nothing
Next i
ActiveCell.Select
End Sub
Sub ShapeClick(ByVal sID As String)
 Dim s As Shape, vVal As String, sName As String, vParams As Variant
 setMySheet
 For Each s In mySheet.Shapes
   If s.name = "lookupSh" Then
    If s.ID = sID Then
      vParams = Split(s.AlternativeText, ":")
      vVal = vParams(0)
      sName = vParams(1)
      connStatus "You selected " & s.AlternativeText
    End If
   End If
 Next s
 delLookup
 ActiveCell.Value = Trim(vVal)
 ActiveCell.Offset(1, 0).Activate
End Sub
Sub showShape()
 Dim s As Shape
 setMySheet
 For Each s In mySheet.Shapes
  s.Visible = msoTrue
 Next s
End Sub
Sub delLookup()
 Dim s As Shape
 For Each s In ActiveSheet.Shapes
   If s.name = "lookupSh" Then s.Delete
 Next s
End Sub
Sub test()
 Dim s As Shape
 For Each s In ActiveSheet.Shapes
   Debug.Print s.name
 Next s
End Sub


Attribute VB_Name = "Setup"
Attribute VB_Base = "0{BAFDCEFB-F5AA-428C-9152-7A71B8B140D2}{9938B0AE-6473-4842-8373-E651ED4702C6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


' 08/23/2008
Const cHost     As String = "3.130.233.190"
Const cPort     As Long = 10013
Public Sub promptForSetup()
   Dim objCreg As Object
   Set objCreg = New CRegistry
   Setup.hostTB.Text = objCreg.GetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", cHost)
   Setup.portTB.Text = objCreg.GetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", CStr(cPort))
   Set objCreg = Nothing
   Setup.show (1)
End Sub
Public Property Get qHost() As String
   Dim objCreg As Object
   Set objCreg = New CRegistry
   qHost = objCreg.GetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", cHost)
   Set objCreg = Nothing
End Property
Public Property Get qPort() As Long
   Dim objCreg As Object
   Set objCreg = New CRegistry
   qPort = CLng(objCreg.GetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", Str(cPort)))
   Set objCreg = Nothing
End Property
Private Sub saveBtn_Click()
  Dim objCreg As Object
  Set objCreg = New CRegistry
  Dim SetVal As Boolean
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", hostTB.Text) Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", hostTB.Text)
  End If
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", portTB.Text) Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", portTB.Text)
  End If
  Unload Me
  Set objCreg = Nothing
End Sub
Private Sub cancelBtn_Click()
  Unload Me
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  loginForm.resetPwd
  Dim s As Worksheet
  Set s = Application.ThisWorkbook.Worksheets("worksheet")
  If s Is Nothing Then 'Doesn't exist
    MsgBox "Worksheet does not exist or was renamed", vbCritical, "32SOFT"
    GoTo stop_sub
  End If
  s.Range("C3").NumberFormat = GetDateFormat()
  s.Range("D3").NumberFormat = GetDateFormat()
  Set s = Application.ThisWorkbook.Worksheets("acc-dd")
  If s Is Nothing Then 'Doesn't exist
    MsgBox "Worksheet does not exist or was renamed", vbCritical, "32SOFT"
    GoTo stop_sub
  End If
  s.Range("M1").NumberFormat = GetCurrFormat()
  s.Visible = xlSheetHidden
  Set s = Nothing
stop_sub:
End Sub
Attribute VB_Name = "commonLib"
' 05/17/2009 commonLib
' Commonly used static functions
' which never are changed from template to template
' getLastRow added, formatDate was changed
' GetCurrFormat red
Option Explicit
Public Const CP_UTF8 = 65001
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" (ByVal CodePage As Long, _
                                                                ByVal dwFlags As Long, _
                                                                ByVal lpMultiByteStr As String, _
                                                                ByVal cbMultiByte As Long, _
                                                                ByVal lpWideCharStr As LongPtr, _
                                                                ByVal cchWideChar As Long) As Long
Private Declare PtrSafe Function WideCharToMultiByte Lib "Kernel32.dll" (ByVal CodePage As Long, _
                                                                ByVal dwFlags As Long, _
                                                                ByVal lpWideCharStr As LongPtr, _
                                                                ByVal cchWideChar As Long, _
                                                                ByVal lpMultiByteStr As String, _
                                                                ByVal cbMultiByte As Long, _
                                                                ByVal lpDefaultChar As String, _
                                                                ByRef lpUsedDefaultChar As Long) As Long
#Else
Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" (ByVal CodePage As Long, ByVal dwFlags As Long, ByVal lpMultiByteStr As String, ByVal cbMultiByte As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long) As Long
Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" (ByVal CodePage As Long, ByVal dwFlags As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long, ByVal lpMultiByteStr As String, ByVal cbMultiByte As Long, ByVal lpDefaultChar As String, ByRef lpUsedDefaultChar As Long) As Long
#End If
Public Function ToUTF8(ByRef inString As String) As String
  Dim buflen As Long
  buflen = WideCharToMultiByte(CP_UTF8, 0&, ByVal StrPtr(inString), Len(inString), vbNullString, 0&, vbNullString, ByVal 0&)
  If (buflen > 0) Then
    ToUTF8 = Space$(buflen)
    Call WideCharToMultiByte(CP_UTF8, 0&, ByVal StrPtr(inString), Len(inString), ToUTF8, buflen, vbNullString, ByVal 0&)
  End If
End Function
Public Function FromUTF8(ByRef inString As String) As String
  Dim buflen As Long
  buflen = MultiByteToWideChar(CP_UTF8, 0&, inString, -1, 0&, 0&)
  If (buflen > 0) Then
     FromUTF8 = Space$(buflen)
     buflen = MultiByteToWideChar(CP_UTF8, 0&, inString, Len(inString), ByVal StrPtr(FromUTF8), buflen)
     FromUTF8 = Left$(FromUTF8, buflen) ' Trim null
  End If
End Function
' internationalization
' formats date for progress format mm/dd/yy
Function formatDate(v As Variant, Optional shortYear As Boolean) As String
    If Not IsDate(v) Then
      formatDate = "?"
    Else
      If shortYear Then
        formatDate = Format(v, "mm/dd/yy")
      Else
        formatDate = Format(v, "mm/dd/yyyy")
      End If
    End If
    formatDate = Replace(formatDate, Application.International(xlDateSeparator), "/")
End Function
' internationalization
' used to set Excel date fields to proper local format
Function GetDateFormat() As String
 Dim s As String
 s = Application.International(xlDateSeparator)
 Select Case Application.International(xlDateOrder)
  Case 0 '= month-day-year
    GetDateFormat = "MM" & s & "DD" & s & "YYYY"
  Case 1 '= day-month-year
    GetDateFormat = "DD" & s & "MM" & s & "YYYY"
  Case 2 '= year-month-day
    GetDateFormat = "YYYY" & s & "MM" & s & "DD"
  Case Else
    GetDateFormat = "DD/MM/YYYY"
 End Select
End Function
Function GetCurrFormat() As String 'internationalization
  GetCurrFormat = "#,##0.00;[red](#,##0.00);"
End Function
'internationalization ;; the ourput format should correspond to progress decimal format
'this converts double to string with proper decimal point for progress
Function getProgressAmtFormat(s As Double) As String
 Dim v As String
 v = Format(s, "general number")
 v = Replace(v, Application.International(xlDecimalSeparator), ".")
 getProgressAmtFormat = v
End Function
Function Change2Letter(OrgVal As Long)
 Dim FirstNum As Long, SecondNum As Long
 FirstNum = Int((OrgVal - 1) / 26)
 SecondNum = OrgVal - (26 * FirstNum)
 If OrgVal <= 26 Then
   Change2Letter = Chr(OrgVal + 64)
 Else
   Change2Letter = Chr(FirstNum + 64) & Chr(SecondNum + 64)
 End If
End Function
Function Array2DTranspose(avValues As Variant) As Variant
    Dim lThisCol As Long, lThisRow As Long
    Dim lUb2 As Long, lLb2 As Long
    Dim lUb1 As Long, lLb1 As Long
    Dim avTransposed As Variant
    If IsArray(avValues) Then
        On Error GoTo ErrFailed
        lUb2 = UBound(avValues, 2)
        lLb2 = LBound(avValues, 2)
        lUb1 = UBound(avValues, 1)
        lLb1 = LBound(avValues, 1)
        ReDim avTransposed(lLb2 To lUb2, lLb1 To lUb1)
        For lThisCol = lLb1 To lUb1
            For lThisRow = lLb2 To lUb2
                avTransposed(lThisRow, lThisCol) = avValues(lThisCol, lThisRow)
            Next
        Next
    End If
    Array2DTranspose = avTransposed
    Exit Function
ErrFailed:
    MsgBox "Call IT. " & Err.Description
    Debug.Assert False
    Array2DTranspose = Empty
    Exit Function
    Resume
End Function
Function cellRef(rCell As Range) As String
  cellRef = rCell.Address(RowAbsolute:=False, ColumnAbsolute:=False)
End Function
Public Sub saveDB()
  Dim wSheet As Worksheet
  On Error Resume Next
  Set wSheet = Sheets("db")
  If wSheet Is Nothing Then 'Doesn't exist
    MsgBox "Worksheet DB does not exist", vbCritical
    Set wSheet = Nothing
    Exit Sub
  End If
  wSheet.Visible = False
  ActiveWorkbook.Save
  MsgBox "SAVED. PLEASE CLICK SETUP BUTTON AND SELECT DB", vbExclamation
End Sub
Public Sub selectDB()
  dbselect.show
End Sub
Function getLastRow(StartRow As Long, DownCol As Long) As Long
    Dim r As Range
    Set r = ActiveSheet.Cells(StartRow, DownCol)
    Set r = r.End(xlDown)
    getLastRow = r.Row
    If r.Text = Empty Then
      Set r = ActiveSheet.Cells(StartRow, DownCol)
      If r.Text <> Empty Then
        getLastRow = StartRow
      Else
        getLastRow = 1
      End If
    End If
End Function
Sub doBackup()
  Dim fname As String
  fname = Module1.QADmenuPath & "_" & Format(Now, "mm-dd-yyyy") & "_" & CStr(100 * Rnd) & ".xls"
  If Not fIsFileDIR("c:\program files", vbDirectory) Then
    MkDir "c:\program files"
  End If
  If Not fIsFileDIR("c:\program files\32soft", vbDirectory) Then
    MkDir "c:\program files\32soft"
  End If
  ActiveWorkbook.SaveCopyAs ("c:\program files\32soft\" & fname)
End Sub
Function fIsFileDIR(stPath As String, Optional lngType As Long) As Boolean
'To check for a file:   ? fIsFileDIR("c:\winnt\win.ini")
'To check for a Dir:    ? fIsFileDir("c:\msoffice",vbdirectory)
    On Error Resume Next
    fIsFileDIR = Len(Dir(stPath, lngType)) > 0
End Function
Function SheetExists(SheetName As String) As Boolean
' returns TRUE if the sheet exists in the active workbook
    SheetExists = False
    On Error GoTo NoSuchSheet
    If Len(Sheets(SheetName).name) > 0 Then
        SheetExists = True
        Exit Function
    End If
NoSuchSheet:
End Function
Sub FindErrorValue()
Dim rFound As Range
    On Error Resume Next
    With ActiveSheet
        Set rFound = Cells.Find(What:="ERROR", After:=ActiveCell, LookIn:=xlComments, _
         SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False _
        , SearchFormat:=False).Activate
    On Error GoTo 0
        If Not rFound Is Nothing Then Application.GoTo rFound, True
    End With
End Sub

Attribute VB_Name = "dbselect"
Attribute VB_Base = "0{D622EFD5-23B9-49AC-B167-20BE7BED4138}{E802F449-2AAD-4F27-90A9-5CBAB5DB9D89}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'05/28/2009
'dbselect module work together with setup form
Dim rcArray() As String
Option Explicit
Private Sub backBtn_Click()
  Mode True
End Sub
Private Sub cancelSelBtn_Click()
  Unload Me
End Sub
Private Sub enterBtn_Click()   '''GETTING ACCESS TO DB LIST SHEET
  Dim wSheet As Worksheet
  On Error Resume Next
  If (passwordTxt.Value = "32SOFT") Then
    Set wSheet = Sheets("db")
    If wSheet Is Nothing Then 'Doesn't exist
      MsgBox "Worksheet DB does not exist", vbCritical
      Set wSheet = Nothing
      Exit Sub
    End If
    wSheet.Visible = True
    wSheet.Select
    eraseDbNameFromRegistry
  End If
  Unload Me
End Sub
Private Sub eraseDbNameFromRegistry()
  Dim objCreg As Object
  Set objCreg = New CRegistry
  Dim SetVal As Boolean
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "dbname", "") Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "dbname", "")
  End If
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", "") Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", "")
  End If
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", "") Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", "")
  End If
  Set objCreg = Nothing
  loginForm.resetPwd
End Sub
Private Sub maintainDBbtn_Click()
  Mode False
  passwordTxt.SetFocus
End Sub
Private Sub selectBtn_Click()
  If ListBox1.ListIndex = -1 Then
    MsgBox "No DB selected, please select"
    Exit Sub
  End If
  Dim dbnm As String
  dbnm = rcArray(ListBox1.ListIndex + 1, 1)
  save2register
  Unload Me
  MsgBox "DATABASE " & dbnm & " Selected", vbApplicationModal
End Sub
Private Sub save2register()
  Dim objCreg As Object, SetVal As Boolean
  Set objCreg = New CRegistry
  'MsgBox ListBox1.ListIndex & " DB name:" & rcArray(ListBox1.ListIndex + 1, 1) _
  '  & " server:" & rcArray(ListBox1.ListIndex + 1, 2) _
  '  & " port:" & rcArray(ListBox1.ListIndex + 1, 3)
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "dbname", rcArray(ListBox1.ListIndex + 1, 1)) Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "dbname", rcArray(ListBox1.ListIndex + 1, 1))
  End If
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", rcArray(ListBox1.ListIndex + 1, 2)) Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "host", rcArray(ListBox1.ListIndex + 1, 2))
  End If
  If Not objCreg.SetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", rcArray(ListBox1.ListIndex + 1, 3)) Then
    SetVal = objCreg.CreateRegEntry(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "port", rcArray(ListBox1.ListIndex + 1, 3))
  End If
  Set objCreg = Nothing
  Erase rcArray
End Sub
Private Sub UserForm_Activate()
  
  'Enable db selection
  Mode True
  Dim lb As msforms.ListBox
  Dim lrw As Long, lcol As Long
  Dim rngTarget As Range
  'Define the range you want to use
  With ThisWorkbook.Sheets("db")
    Set rngTarget = .Range("A2", .Range("C2").End(xlDown))
  End With
  
  Dim lastRow As Long
  lastRow = rngTarget.Rows.Count
  If lastRow > 200 Then lastRow = 1  'LIMIT # of DB
  
  'Set the boundaries of the array
  ReDim Preserve rcArray(1 To rngTarget.Rows.Count, 1 To rngTarget.Columns.Count)
  'Fill the array with data from the worksheet
  With rngTarget
   For lrw = 1 To lastRow '.Rows.count
    For lcol = 1 To 3
      rcArray(lrw, lcol) = rngTarget.Cells(lrw, lcol)
      'Debug.Print .Cells(lrw, lcol).Value; lrw; lcol
    Next lcol
   Next lrw
  End With
  
  'Place the array in the listbox
  Set lb = Me.ListBox1
  With lb
    '.ColumnCount = 3
    '.ColumnWidths = "50;80;100"
    .List = rcArray
  End With
  
  'GET DBname from registry
  Dim objCreg As Object, cdbname As String, i As Long
  Set objCreg = New CRegistry
  cdbname = objCreg.GetAppRegValue(HKEY_CURRENT_USER, "software\32soft\xld", REG_SZ, "dbname", "")
  Set objCreg = Nothing
  'SELECT DBname in LISTBOX
  If cdbname <> "" Then
    For i = LBound(rcArray, 1) To UBound(rcArray, 1)
      If rcArray(i, 1) = cdbname Then
        ListBox1.Selected(i - 1) = True
        Exit For
      End If
    Next i
  End If
  
End Sub
Private Sub Mode(selDB As Boolean)
  If (selDB = True) Then
    ListBox1.Visible = True
    cancelSelBtn.Visible = True
    maintainDBbtn.Visible = True
    selectDBLbl.Visible = True
    selectBtn.Visible = True
    Label1.Visible = True
    passwordTxt.Visible = False
    enterBtn.Visible = False
    enterPwdLbl.Visible = False
    backBtn.Visible = False
  Else
    ListBox1.Visible = False
    cancelSelBtn.Visible = False
    maintainDBbtn.Visible = False
    selectDBLbl.Visible = False
    Label1.Visible = False
    passwordTxt.Visible = True
    enterBtn.Visible = True
    enterPwdLbl.Visible = True
    selectBtn.Visible = False
    backBtn.Visible = True
  End If
End Sub
Attribute VB_Name = "help"
Attribute VB_Base = "0{012034BF-146A-4FD2-91D4-652327DA9FCF}{BFE549E1-E614-42D0-A625-B6EFC06008B9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub closeBtn_Click()
 Unload Me
End Sub
Public Sub addText(s As String)
  If Len(TextBox.Text) > 0 Then
    TextBox.Text = TextBox.Text & Chr(10) & s
  Else
    TextBox.Text = s
  End If
End Sub

Attribute VB_Name = "loginForm"
Attribute VB_Base = "0{723C2A64-C0D5-47FB-B881-7BECBB8DD98D}{B2DE08D3-479E-4A5E-A7B5-473569AA643C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


' 08/23/2008
Const xldRegKey As String = "software\32soft\xld"
Dim bClickLogin As Boolean
Private Sub loginBtn_Click()
  Dim objCreg As Object, uid As String
  uid = Trim(useridTB.Text)
  If Len(uid) > 0 Then
    Set objCreg = New CRegistry
    objCreg.SetAppRegValue HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERID", uid
    objCreg.SetAppRegValue HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERPass", passwordTB.Text
    Set objCreg = Nothing
    bClickLogin = True
    Unload Me
  Else
    MsgBox "Please Enter User ID!", vbExclamation
  End If
End Sub
Private Sub cancelBtn_Click()
  Unload Me
End Sub
Public Function showForm() As Boolean
  Dim objCreg As Object
  Set objCreg = New CRegistry
  useridTB.Text = _
    objCreg.GetAppRegValue(HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERID", "")
  passwordTB.Text = _
    objCreg.GetAppRegValue(HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERPass", "")
  Set objCreg = Nothing
  bClickLogin = False
  show 1
  showForm = bClickLogin
End Function
Public Property Get userID() As String
  Dim objCreg As Object
  Set objCreg = New CRegistry
  userID = objCreg.GetAppRegValue(HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERID", "")
  Set objCreg = Nothing
End Property
Public Property Get userPass() As String
  Dim objCreg As Object
  Set objCreg = New CRegistry
  userPass = objCreg.GetAppRegValue(HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERPass", "")
  Set objCreg = Nothing
End Property
Public Property Get xldRegKeyPath() As String
   xldRegKeyPath = xldRegKey
End Property
Public Function resetPwd() As Boolean
  Dim objCreg As Object
  Set objCreg = New CRegistry
  objCreg.SetAppRegValue HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERID", "qaduser"
  objCreg.SetAppRegValue HKEY_CURRENT_USER, xldRegKey, REG_SZ, "USERPass", ""
  Set objCreg = Nothing
End Function
Attribute VB_Name = "modSocketMaster"
'**************************************************************************************
'AK See line 630 commented,line 370 I entered application.hinst instead of app.hinst.
' xl2000-2007 compartible DD 08/17/2009
'modSocketMaster module 1.3
'Copyright (c) 2004 by Emiliano Scavuzzo <anshoku@yahoo.com>
'Rosario, Argentina
'**************************************************************************************
'This module contains API declarations and helper functions for the CSocketMaster class
'**************************************************************************************
'Modifications by Victor H. Garcia, Jan 21-2011 Marked As 'By VG> Explanation
'x64 compatibility issue is solved using precompilation sentences #if Win64 Then -> #Else -> #End If
'Replaced old subclasing functionality for a new VBA completely subclasing functionality
Option Explicit
Public Const traceSocket   As Boolean = False
'==============================================================================
'API FUNCTIONS
'==============================================================================
#If Win64 Then
Public Declare PtrSafe Sub api_CopyMemory Lib "kernel32" _
                                    Alias "RtlMoveMemory" (Destination As Any, _
                                                            Source As Any, _
                                                            ByVal Length As LongLong)
Public Declare PtrSafe Function api_GlobalAlloc Lib "kernel32" _
                                    Alias "GlobalAlloc" (ByVal wFlags As Long, _
                                                            ByVal dwBytes As LongLong) As LongPtr
Public Declare PtrSafe Function api_GlobalFree Lib "kernel32" _
                                    Alias "GlobalFree" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function api_WSAStartup Lib "ws2_32.dll" _
                                    Alias "WSAStartup" (ByVal wVersionRequired As Integer, _
                                                            lpWSADATA As WSAData) As Long
Private Declare PtrSafe Function api_WSACleanup Lib "ws2_32.dll" _
                                    Alias "WSACleanup" () As Long
Public Declare PtrSafe Function api_WSAAsyncGetHostByName Lib "ws2_32.dll" _
                                    Alias "WSAAsyncGetHostByName" (ByVal hWnd As LongPtr, _
                                                            ByVal wMsg As Long, _
                                                            ByVal strHostName As String, _
                                                            buf As Any, _
                                                            ByVal buflen As Long) As LongPtr
Public Declare PtrSafe Function api_WSAAsyncSelect Lib "ws2_32.dll" _
                                    Alias "WSAAsyncSelect" (ByVal s As LongLong, _
                                                            ByVal hWnd As LongPtr, _
                                                            ByVal wMsg As Long, _
                                                            ByVal lEvent As Long) As Long
Private Declare PtrSafe Function api_CreateWindowEx Lib "User32" _
                                    Alias "CreateWindowExA" (ByVal dwExStyle As Long, _
                                                            ByVal lpClassName As String, _
                                                            ByVal lpWindowName As String, _
                                                            ByVal dwStyle As Long, _
                                                            ByVal x As Long, _
                                                            ByVal y As Long, _
                                                            ByVal nWidth As Long, _
                                                            ByVal nHeight As Long, _
                                                            ByVal hWndParent As LongPtr, _
                                                            ByVal hMenu As LongPtr, _
                                                            ByVal hInstance As LongPtr, _
                                                            ByVal lpParam As LongPtr) As LongPtr
Private Declare PtrSafe Function api_DestroyWindow Lib "User32" _
                                    Alias "DestroyWindow" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function api_lstrlen Lib "kernel32" _
                                    Alias "lstrlenA" (ByVal lpString As LongPtr) As Long
Private Declare PtrSafe Function api_lstrcpy Lib "kernel32" _
                                    Alias "lstrcpyA" (ByVal lpString1 As String, _
                                                            ByVal lpString2 As LongPtr) As Long
Private Declare PtrSafe Function api_LoadLibrary Lib "kernel32" _
                                    Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
Private Declare PtrSafe Function api_SetTimer Lib "User32" _
                                    Alias "SetTimer" (ByVal hWnd As LongPtr, _
                                                            ByVal nIDEvent As LongPtr, _
                                                            ByVal uElapse As Long, _
                                                            ByVal lpTimerFunc As LongPtr) As LongPtr
Private Declare PtrSafe Function api_KillTimer Lib "User32" _
                                    Alias "KillTimer" (ByVal hWnd As LongPtr, _
                                                            ByVal nIDEvent As LongPtr) As Long
#Else
Public Declare Sub api_CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Public Declare Function api_GlobalAlloc Lib "kernel32" Alias "GlobalAlloc" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Public Declare Function api_GlobalFree Lib "kernel32" Alias "GlobalFree" (ByVal hMem As Long) As Long
Private Declare Function api_WSAStartup Lib "ws2_32.dll" Alias "WSAStartup" (ByVal wVersionRequired As Long, lpWSADATA As WSAData) As Long
Private Declare Function api_WSACleanup Lib "ws2_32.dll" Alias "WSACleanup" () As Long
Public Declare Function api_WSAAsyncGetHostByName Lib "ws2_32.dll" Alias "WSAAsyncGetHostByName" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal strHostName As String, buf As Any, ByVal buflen As Long) As Long
Public Declare Function api_WSAAsyncSelect Lib "ws2_32.dll" Alias "WSAAsyncSelect" (ByVal s As Long, ByVal hWnd As Long, ByVal wMsg As Long, ByVal lEvent As Long) As Long
Private Declare Function api_CreateWindowEx Lib "User32" Alias "CreateWindowExA" (ByVal dwExStyle As Long, ByVal lpClassName As String, ByVal lpWindowName As String, ByVal dwStyle As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As Long, ByVal hMenu As Long, ByVal hInstance As Long, lpParam As Any) As Long
Private Declare Function api_DestroyWindow Lib "User32" Alias "DestroyWindow" (ByVal hWnd As Long) As Long
Private Declare Function api_lstrlen Lib "kernel32" Alias "lstrlenA" (ByVal lpString As Any) As Long
Private Declare Function api_lstrcpy Lib "kernel32" Alias "lstrcpyA" (ByVal lpString1 As String, ByVal lpString2 As Long) As Long
Private Declare Function api_LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Private Declare Function api_SetTimer Lib "User32" Alias "SetTimer" (ByVal hWnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
Private Declare Function api_KillTimer Lib "User32" Alias "KillTimer" (ByVal hWnd As Long, ByVal nIDEvent As Long) As Long
#End If
'Private Declare Function api_FindWindow Lib "User32" Alias "FindWindowA" (ByVal ClassName As String, ByVal Title As String) As Long
'Private Declare Function api_GetClassName Lib "User32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, nMaxCount As Long) As Long
'==============================================================================
'CONSTANTS
'==============================================================================
Public Const SOCKET_ERROR   As Long = -1
Public Const INVALID_SOCKET As Long = -1
Public Const INADDR_NONE As Long = &HFFFF
Private Const WSADESCRIPTION_LEN As Integer = 257
Private Const WSASYS_STATUS_LEN  As Integer = 129
Private Enum WinsockVersion
    SOCKET_VERSION_11 = &H101
    SOCKET_VERSION_22 = &H202
End Enum
Public Const MAXGETHOSTSTRUCT As Long = 1024
Public Const AF_INET        As Long = 2
Public Const SOCK_STREAM    As Long = 1
Public Const SOCK_DGRAM     As Long = 2
Public Const IPPROTO_TCP    As Long = 6
Public Const IPPROTO_UDP    As Long = 17
Public Const FD_READ    As Integer = &H1&
Public Const FD_WRITE   As Integer = &H2&
Public Const FD_ACCEPT  As Integer = &H8&
Public Const FD_CONNECT As Integer = &H10&
Public Const FD_CLOSE   As Integer = &H20&
Private Const OFFSET_2 As Long = 65536
Private Const MAXINT_2 As Long = 32767
Public Const GMEM_FIXED As Integer = &H0
Public Const LOCAL_HOST_BUFF As Integer = 256
Public Const SOL_SOCKET         As Long = 65535
Public Const SO_SNDBUF          As Long = &H1001&
Public Const SO_RCVBUF          As Long = &H1002&
Public Const SO_MAX_MSG_SIZE    As Long = &H2003
Public Const SO_BROADCAST       As Long = &H20
Public Const FIONREAD           As Long = &H4004667F
'==============================================================================
'ERROR CODES
'==============================================================================
Public Const WSABASEERR         As Long = 10000
Public Const WSAEINTR           As Long = (WSABASEERR + 4)
Public Const WSAEACCES          As Long = (WSABASEERR + 13)
Public Const WSAEFAULT          As Long = (WSABASEERR + 14)
Public Const WSAEINVAL          As Long = (WSABASEERR + 22)
Public Const WSAEMFILE          As Long = (WSABASEERR + 24)
Public Const WSAEWOULDBLOCK     As Long = (WSABASEERR + 35)
Public Const WSAEINPROGRESS     As Long = (WSABASEERR + 36)
Public Const WSAEALREADY        As Long = (WSABASEERR + 37)
Public Const WSAENOTSOCK        As Long = (WSABASEERR + 38)
Public Const WSAEDESTADDRREQ    As Long = (WSABASEERR + 39)
Public Const WSAEMSGSIZE        As Long = (WSABASEERR + 40)
Public Const WSAEPROTOTYPE      As Long = (WSABASEERR + 41)
Public Const WSAENOPROTOOPT     As Long = (WSABASEERR + 42)
Public Const WSAEPROTONOSUPPORT As Long = (WSABASEERR + 43)
Public Const WSAESOCKTNOSUPPORT As Long = (WSABASEERR + 44)
Public Const WSAEOPNOTSUPP      As Long = (WSABASEERR + 45)
Public Const WSAEPFNOSUPPORT    As Long = (WSABASEERR + 46)
Public Const WSAEAFNOSUPPORT    As Long = (WSABASEERR + 47)
Public Const WSAEADDRINUSE      As Long = (WSABASEERR + 48)
Public Const WSAEADDRNOTAVAIL   As Long = (WSABASEERR + 49)
Public Const WSAENETDOWN        As Long = (WSABASEERR + 50)
Public Const WSAENETUNREACH     As Long = (WSABASEERR + 51)
Public Const WSAENETRESET       As Long = (WSABASEERR + 52)
Public Const WSAECONNABORTED    As Long = (WSABASEERR + 53)
Public Const WSAECONNRESET      As Long = (WSABASEERR + 54)
Public Const WSAENOBUFS         As Long = (WSABASEERR + 55)
Public Const WSAEISCONN         As Long = (WSABASEERR + 56)
Public Const WSAENOTCONN        As Long = (WSABASEERR + 57)
Public Const WSAESHUTDOWN       As Long = (WSABASEERR + 58)
Public Const WSAETIMEDOUT       As Long = (WSABASEERR + 60)
Public Const WSAEHOSTUNREACH    As Long = (WSABASEERR + 65)
Public Const WSAECONNREFUSED    As Long = (WSABASEERR + 61)
Public Const WSAEPROCLIM        As Long = (WSABASEERR + 67)
Public Const WSASYSNOTREADY     As Long = (WSABASEERR + 91)
Public Const WSAVERNOTSUPPORTED As Long = (WSABASEERR + 92)
Public Const WSANOTINITIALISED  As Long = (WSABASEERR + 93)
Public Const WSAHOST_NOT_FOUND  As Long = (WSABASEERR + 1001)
Public Const WSATRY_AGAIN       As Long = (WSABASEERR + 1002)
Public Const WSANO_RECOVERY     As Long = (WSABASEERR + 1003)
Public Const WSANO_DATA         As Long = (WSABASEERR + 1004)
'==============================================================================
'WINSOCK CONTROL ERROR CODES
'==============================================================================
Public Const sckOutOfMemory As Long = 7
Public Const sckBadState    As Long = 40006
Public Const sckInvalidArg  As Long = 40014
Public Const sckUnsupported As Long = 40018
Public Const sckInvalidOp   As Long = 40020
'==============================================================================
'STRUCTURES
'==============================================================================
'WSAData Structure
#If Win64 Then
Private Type WSAData
   wVersion       As Integer
   wHighVersion   As Integer
   szDescription  As String * WSADESCRIPTION_LEN
   szSystemStatus As String * WSASYS_STATUS_LEN
   iMaxSockets    As Integer
   iMaxUdpDg      As Integer
   lpVendorInfo   As LongPtr
End Type
#Else
Private Type WSAData
   wVersion       As Integer
   wHighVersion   As Integer
   szDescription  As String * WSADESCRIPTION_LEN
   szSystemStatus As String * WSASYS_STATUS_LEN
   iMaxSockets    As Integer
   iMaxUdpDg      As Integer
   lpVendorInfo   As Long
End Type
#End If
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Public Type HOSTENT
    hName     As LongPtr
    hAliases  As LongPtr
    hAddrType As Integer
    hLength   As Integer
    hAddrList As LongPtr
End Type
#Else
Public Type HOSTENT
    hName     As Long
    hAliases  As Long
    hAddrType As Integer
    hLength   As Integer
    hAddrList As Long
End Type
#End If
Public Type sockaddr_in
    sin_family       As Integer
    sin_port         As Integer
    sin_addr         As Long
    sin_zero(1 To 8) As Byte
End Type
'==============================================================================
'MEMBER VARIABLES
'==============================================================================
Private m_lngSocksQuantity      As Long         'number of instances created
'==============================================================================
'SUBCLASSING DECLARATIONS
'by Paul Caton
'==============================================================================
'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Private Declare PtrSafe Function api_IsWindow Lib "User32" _
                                    Alias "IsWindow" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function api_GetWindowLong Lib "User32" _
                                    Alias "GetWindowLongPtrA" (ByVal hWnd As LongPtr, _
                                    ByVal nIndex As Long) As LongLong
Private Declare PtrSafe Function api_SetWindowLong Lib "User32" _
                                    Alias "SetWindowLongPtrA" (ByVal hWnd As LongPtr, _
                                    ByVal nIndex As Long, _
                                    ByVal dwNewLong As LongLong) As LongLong
Private Declare PtrSafe Function api_CallWindowProc Lib "User32" _
                                    Alias "CallWindowProcA" (ByVal wndProcOrig As LongPtr, _
                                    ByVal hWnd As LongPtr, _
                                    ByVal uMsg As Long, _
                                    ByVal wParam As LongLong, _
                                    ByVal lParam As LongLong) As LongLong
Private Declare PtrSafe Function api_GetModuleHandle Lib "kernel32" _
                                    Alias "GetModuleHandleA" (ByVal lpModuleName As String) As LongPtr
Private Declare PtrSafe Function api_GetProcAddress Lib "kernel32" _
                                    Alias "GetProcAddress" (ByVal hModule As LongPtr, _
                                    ByVal lpProcName As String) As LongPtr
#Else
Private Declare Function api_IsWindow Lib "User32" Alias "IsWindow" (ByVal hWnd As Long) As Long
Private Declare Function api_GetWindowLong Lib "User32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function api_SetWindowLong Lib "User32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function api_CallWindowProc Lib "User32" Alias "CallWindowProcA" (ByVal wndProcOrig, ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function api_GetModuleHandle Lib "kernel32" Alias "GetModuleHandleA" (ByVal lpModuleName As String) As Long
Private Declare Function api_GetProcAddress Lib "kernel32" Alias "GetProcAddress" (ByVal hModule As Long, ByVal lpProcName As String) As Long
#End If

Private Const GWL_WNDPROC As Long = (-4)
Private Const GWL_USERDATA As Long = (-21)
Private Const WM_APP As Long = 32768 '0x8000
Public Const RESOLVE_MESSAGE As Long = WM_APP
Public Const SOCKET_MESSAGE  As Long = WM_APP + 1
Public Const WM_TIMER  As Long = 275 '0x0113
Private Const TIMER_TIMEOUT As Long = 1000   'control timer time out, in milliseconds
#If Win64 Then
    Private m_containerWndProc As LongPtr
#Else
    Private m_containerWndProc As Long
#End If
'This Functions returns an instance of CSocketMaster from a Pointer if it is possible
'If not returns Nothing, maybe the pointer is not of a CSocketMaster instance or is ZERO
#If Win64 Then
Private Function PtrToCSocketMaster(ptr As LongPtr) As CSocketMaster
On Error GoTo PtrToCSocketMaster_Err
    Set PtrToCSocketMaster = Nothing
    If ptr <> 0 Then
        Dim obj As Object
        'Copies the IUnknown pointer address
        api_CopyMemory obj, ptr, LenB(ptr)
        If (Not obj Is Nothing) And (TypeOf obj Is CSocketMaster) Then
            'Do a QueryInterface Call over the pointer
            Set PtrToCSocketMaster = obj
        End If
        api_CopyMemory obj, CLngPtr(0), LenB(ptr)
    End If
    Exit Function
PtrToCSocketMaster_Err:
    Set PtrToCSocketMaster = Nothing
End Function
#Else
Private Function PtrToCSocketMaster(ptr As Long) As CSocketMaster
On Error GoTo PtrToCSocketMaster_Err
    Set PtrToCSocketMaster = Nothing
    If ptr <> 0 Then
        Dim obj As Object
        'Copies the IUnknown pointer address
        api_CopyMemory obj, ptr, LenB(ptr)
        If (Not obj Is Nothing) And (TypeOf obj Is CSocketMaster) Then
            'Do a QueryInterface Call over the pointer
            Set PtrToCSocketMaster = obj
        End If
        api_CopyMemory obj, CLng(0), LenB(ptr)
    End If
    Exit Function
PtrToCSocketMaster_Err:
    Set PtrToCSocketMaster = Nothing
End Function
#End If

'This Function Processes All Windows Messages Of CSocketMaster HWND Instances
'The Function Tries to obtain the CSocketMaster Instance that generated the event.
'If any error o Exception the Message is ignored. Or if the window is
'not related to a CSocketMaster instance
#If Win64 Then
Private Function cSocketMasterWndProc(ByVal hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongLong, ByVal lParam As LongLong) As LongLong
On Error GoTo cSocketMasterWndProc_Err
Dim cSocket As CSocketMaster
    cSocketMasterWndProc = 0
    'Get the instance that received the event, stored on HWND Windows object
    Set cSocket = PtrToCSocketMaster(api_GetWindowLong(hWnd, GWL_USERDATA))
    If cSocket Is Nothing Then
        cSocketMasterWndProc = api_CallWindowProc(m_containerWndProc, hWnd, uMsg, wParam, lParam)
        Exit Function
    End If
    If uMsg = RESOLVE_MESSAGE Then
        cSocket.PostResolution CLng(wParam), HiWord(CLng(lParam))
    ElseIf uMsg = SOCKET_MESSAGE Then
        cSocket.PostSocket LoWord(CLng(lParam)), HiWord(CLng(lParam))
    ElseIf uMsg = WM_TIMER Then
        api_KillTimer 0, wParam
'    Else
'        cSocketMasterWndProc = api_CallWindowProc(cSocket.m_origWndProc, hWnd, uMsg, wParam, lParam)
    End If
    Exit Function
cSocketMasterWndProc_Err:
    cSocketMasterWndProc = 0
End Function
#Else
Private Function cSocketMasterWndProc(ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
On Error GoTo cSocketMasterWndProc_Err
Dim cSocket As CSocketMaster
    cSocketMasterWndProc = 0
    'Get the instance that received the event, stored on HWND Windows object
    Set cSocket = PtrToCSocketMaster(api_GetWindowLong(hWnd, GWL_USERDATA))
    If cSocket Is Nothing Then
        cSocketMasterWndProc = api_CallWindowProc(m_containerWndProc, hWnd, uMsg, wParam, lParam)
        Exit Function
    End If
    If uMsg = RESOLVE_MESSAGE Then
        cSocket.PostResolution CLng(wParam), HiWord(CLng(lParam))
    ElseIf uMsg = SOCKET_MESSAGE Then
        cSocket.PostSocket LoWord(CLng(lParam)), HiWord(CLng(lParam))
    ElseIf uMsg = WM_TIMER Then
        api_KillTimer 0, wParam
 '   Else
        'cSocketMasterWndProc = api_CallWindowProc(cSocket.m_origWndProc, hWnd, uMsg, wParam, lParam)
    End If
    Exit Function
cSocketMasterWndProc_Err:
    cSocketMasterWndProc = 0
End Function
#End If
'VG> Set the window subclass, creates the Window instance object and bind it to our Subclassing process
Public Sub SubClassCSocketMaster(ByVal cSocket As CSocketMaster)
    cSocket.m_lngHwnd = CreateMessageWindow()
    Debug.Assert api_IsWindow(cSocket.m_lngHwnd)
'    If Subclass_InIDE Then
'        'Create the control timer
'        api_SetTimer 0, ObjPtr(cSocket), TIMER_TIMEOUT, AddressOf cSocketMasterWndProc
'    End If
    api_SetWindowLong cSocket.m_lngHwnd, GWL_USERDATA, ObjPtr(cSocket)
    cSocket.m_origWndProc = api_SetWindowLong(cSocket.m_lngHwnd, GWL_WNDPROC, AddressOf cSocketMasterWndProc)
End Sub
'VG> Unset the window Subclass
Public Sub UnSubclassCSocketMaster(ByVal cSocket As CSocketMaster)
    Debug.Assert api_IsWindow(cSocket.m_lngHwnd)
    api_SetWindowLong cSocket.m_lngHwnd, GWL_WNDPROC, cSocket.m_origWndProc
    Dim lngResult As Long
    lngResult = api_DestroyWindow(cSocket.m_lngHwnd)
    If lngResult = 0 Then
        Err.Raise sckOutOfMemory, "modSocketMaster.DestroyWinsockMessageWindow", "Out of memory"
    Else
        If traceSocket Then Debug.Print "OK Destroyed winsock message window " & cSocket.m_lngHwnd
    End If
End Sub

'VG> Create a Window instance object, using Windows API
#If Win64 Then
Private Function CreateMessageWindow() As LongPtr
    If Application.Version = "9.0" Then
        CreateMessageWindow = api_CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, 0&, ByVal 0&)
    Else
    #If VBA7 Then
        CreateMessageWindow = api_CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, Application.HinstancePtr, ByVal 0&)
    #Else
        CreateMessageWindow = api_CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, Application.hInstance, ByVal 0&)
    #End If
    End If
    If CreateMessageWindow = 0 Then
        Err.Raise sckOutOfMemory, "modSocketMaster.CreateMessageWindow", "Out of memory"
    Else
        If traceSocket Then Debug.Print "OK Created winsock message window " & CStr(CreateMessageWindow)
    End If
End Function
#Else
Private Function CreateMessageWindow() As Long
    If Application.Version = "9.0" Then
        CreateMessageWindow = api_CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, 0&, ByVal 0&)
    Else
    #If VBA7 Then
        CreateMessageWindow = api_CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, Application.HinstancePtr, ByVal 0&)
    #Else
        CreateMessageWindow = api_CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, Application.hInstance, ByVal 0&)
    #End If
    End If
    If CreateMessageWindow = 0 Then
        Err.Raise sckOutOfMemory, "modSocketMaster.CreateMessageWindow", "Out of memory"
    Else
        If traceSocket Then Debug.Print "OK Created winsock message window " & CStr(CreateMessageWindow)
    End If
End Function
#End If

'VG> Initializes Winsock Librarie if not loaded
Public Sub InitializeWinSockLib()
    m_lngSocksQuantity = m_lngSocksQuantity + 1
    If m_lngSocksQuantity = 1 Then
        Dim udtWSAData As WSAData
        Dim lngResult As Long
        m_containerWndProc = api_GetWindowLong(Application.hWnd, GWL_WNDPROC)
        lngResult = api_WSAStartup(SOCKET_VERSION_11, udtWSAData)
        If lngResult = 0 Then
             If traceSocket Then Debug.Print "OK Winsock service initiated"
        Else
             If traceSocket Then Debug.Print "ERROR trying to initiate winsock service"
            Err.Raise lngResult, "modSocketMaster.InitializeWinSockLib", GetErrorDescription(lngResult)
        End If
    End If
End Sub

'Reduces the number of loaded CSocketMaster instances if it is ZERO unitializes the WinSock Library
Public Sub FinalizeWinSockLib()
    m_lngSocksQuantity = m_lngSocksQuantity - 1
    If m_lngSocksQuantity = 0 Then
        Dim lngResult As Long
        lngResult = api_WSACleanup
        If lngResult = 0 Then
             If traceSocket Then Debug.Print "OK Winsock service finalized"
        Else
             If traceSocket Then Debug.Print "ERROR trying to finalize winsock service"
            Err.Raise lngResult, "modSocketMaster.FinalizeWinSockLib", GetErrorDescription(lngResult)
        End If
    End If
End Sub
''This function receives a number that represents an error
''and returns the corresponding description string.
Public Function GetErrorDescription(ByVal lngErrorCode As Long) As String
Select Case lngErrorCode
    Case WSAEACCES
        GetErrorDescription = "Permission denied."
    Case WSAEADDRINUSE
        GetErrorDescription = "Address already in use."
    Case WSAEADDRNOTAVAIL
        GetErrorDescription = "Cannot assign requested address."
    Case WSAEAFNOSUPPORT
        GetErrorDescription = "Address family not supported by protocol family."
    Case WSAEALREADY
        GetErrorDescription = "Operation already in progress."
    Case WSAECONNABORTED
        GetErrorDescription = "Software caused connection abort."
    Case WSAECONNREFUSED
        GetErrorDescription = "Connection refused."
    Case WSAECONNRESET
        GetErrorDescription = "Connection reset by peer."
    Case WSAEDESTADDRREQ
        GetErrorDescription = "Destination address required."
    Case WSAEFAULT
        GetErrorDescription = "Bad address."
    Case WSAEHOSTUNREACH
        GetErrorDescription = "No route to host."
    Case WSAEINPROGRESS
        GetErrorDescription = "Operation now in progress."
    Case WSAEINTR
        GetErrorDescription = "Interrupted function call."
    Case WSAEINVAL
        GetErrorDescription = "Invalid argument."
    Case WSAEISCONN
        GetErrorDescription = "Socket is already connected."
    Case WSAEMFILE
        GetErrorDescription = "Too many open files."
    Case WSAEMSGSIZE
        GetErrorDescription = "Message too long."
    Case WSAENETDOWN
        GetErrorDescription = "Network is down."
    Case WSAENETRESET
        GetErrorDescription = "Network dropped connection on reset."
    Case WSAENETUNREACH
        GetErrorDescription = "Network is unreachable."
    Case WSAENOBUFS
        GetErrorDescription = "No buffer space available."
    Case WSAENOPROTOOPT
        GetErrorDescription = "Bad protocol option."
    Case WSAENOTCONN
        GetErrorDescription = "Socket is not connected."
    Case WSAENOTSOCK
        GetErrorDescription = "Socket operation on nonsocket."
    Case WSAEOPNOTSUPP
        GetErrorDescription = "Operation not supported."
    Case WSAEPFNOSUPPORT
        GetErrorDescription = "Protocol family not supported."
    Case WSAEPROCLIM
        GetErrorDescription = "Too many processes."
    Case WSAEPROTONOSUPPORT
        GetErrorDescription = "Protocol not supported."
    Case WSAEPROTOTYPE
        GetErrorDescription = "Protocol wrong type for socket."
    Case WSAESHUTDOWN
        GetErrorDescription = "Cannot send after socket shutdown."
    Case WSAESOCKTNOSUPPORT
        GetErrorDescription = "Socket type not supported."
    Case WSAETIMEDOUT
        GetErrorDescription = "Connection timed out."
    Case WSAEWOULDBLOCK
        GetErrorDescription = "Resource temporarily unavailable."
    Case WSAHOST_NOT_FOUND
        GetErrorDescription = "Host not found."
    Case WSANOTINITIALISED
        GetErrorDescription = "Successful WSAStartup not yet performed."
    Case WSANO_DATA
        GetErrorDescription = "Valid name, no data record of requested type."
    Case WSANO_RECOVERY
        GetErrorDescription = "This is a nonrecoverable error."
    Case WSASYSNOTREADY
        GetErrorDescription = "Network subsystem is unavailable."
    Case WSATRY_AGAIN
        GetErrorDescription = "Nonauthoritative host not found."
    Case WSAVERNOTSUPPORTED
        GetErrorDescription = "Winsock.dll version out of range."
    Case Else
        GetErrorDescription = "Unknown error."
End Select
End Function
'Returns the hi word from a double word.
Public Function HiWord(lngValue As Long) As Long
If (lngValue And &H80000000) = &H80000000 Then
    HiWord = ((lngValue And &H7FFF0000) \ &H10000) Or &H8000&
Else
    HiWord = (lngValue And &HFFFF0000) \ &H10000
End If
End Function
'Returns the low word from a double word.
Public Function LoWord(lngValue As Long) As Long
LoWord = (lngValue And &HFFFF&)
End Function
'Receives a string pointer and it turns it into a regular string.

'Victor H. Garcia, fix of x64 compatibility issue
#If Win64 Then
Public Function StringFromPointer(ByVal lPointer As LongPtr) As String
Dim lRetVal As LongPtr
#Else
Public Function StringFromPointer(ByVal lPointer As Long) As String
Dim lRetVal As Long
#End If
Dim strTemp As String
Dim lSize As Long
lSize = api_lstrlen(ByVal lPointer) + 1
strTemp = String$(lSize, 0)
lRetVal = api_lstrcpy(ByVal strTemp, ByVal lPointer)
If lRetVal Then StringFromPointer = strTemp
End Function
'The function takes an unsigned Integer from and API and|fffd|
'converts it to a Long for display or arithmetic purposes
Public Function UnsignedToInteger(Value As Long) As Integer
If Value < 0 Or Value >= OFFSET_2 Then Error 6 ' Overflow
If Value <= MAXINT_2 Then
    UnsignedToInteger = Value
Else
    UnsignedToInteger = Value - OFFSET_2
End If
End Function
'The function takes a Long containing a value in the range|fffd|
'of an unsigned Integer and returns an Integer that you|fffd|
'can pass to an API that requires an unsigned Integer
Public Function IntegerToUnsigned(Value As Integer) As Long
If Value < 0 Then
    IntegerToUnsigned = Value + OFFSET_2
Else
    IntegerToUnsigned = Value
End If
End Function
Attribute VB_Name = "report"
Attribute VB_Base = "0{630C7EB2-AB41-40F0-9027-7BB2D94EA9C2}{763CE4B9-5D6D-4016-A21D-8FF053339DE4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'12/01/2009 has fix for curline
Private Function CountIn(ByRef strText As String, ByRef strFind As String) As Long
  Dim inCount As Long
  Dim intPos  As Long
  If Len(strFind) > 0 Then
    intPos = 1
    Do
      intPos = InStr(intPos, strText, strFind)
      If intPos > 0 Then
        intCount = intCount + 1
        intPos = intPos + Len(strFind)
      End If
    Loop While intPos > 0
  Else
    intCount = 0
  End If
  CountIn = intCount
End Function

Private Function NumEntries(ByRef strText As String, ByVal strDelimiter As String) As Long
  Dim strChar As String * 1
  If Len(strText) = 0 Then
    NumEntries = 0
  Else
    strChar = Left(strDelimiter, 1)
    NumEntries = CountIn(strText, strChar) + 1
  End If
End Function
Private Function Entry(ByVal intPiec As Long, ByRef strText As String, ByVal strDelimiter As String) As String
  Dim intPos     As Long
  Dim intLastPos As Long
  Dim intLoop    As Long
  Dim intPos1    As Long
  Dim strChar    As String * 1
  intPos = 0
  intLastPos = 0
  intLoop = intPiec
  strChar = Left(strDelimiter, 1)
  Do While intLoop > 0
    intLastPos = intPos
    intPos1 = InStr(intPos + 1, strText, strChar)
    If intPos1 > 0 Then
      intPos = intPos1
      intLoop = intLoop - 1
    Else
      intPos = Len(strText) + 1
      Exit Do
    End If
  Loop
  If (intPos = 0) And (intLoop <> intPiece) And (intLoop > 1) Then
    Entry = ""
  Else
    Entry = Mid(strText, intLastPos + 1, intPos - intLastPos - 1)
  End If
End Function

'report.frm dd: 12/20/2008
Private Sub CommandButton1_Click()
  Unload Me
End Sub
Public Sub setText(s As String)
  On Error GoTo stop_sub
  Application.EnableCancelKey = xlErrorHandler
  TextBox1.multiLine = True
  TextBox1.BackColor = RGB(228, 233, 221) '&H80000001
  TextBox1.Locked = False
  TextBox1.Enabled = True
  TextBox1.Font.name = "courier new"
  TextBox1.Font.Size = 8
  TextBox1.ScrollBars = fmScrollBarsVertical
  TextBox1.Text = s
  TextBox1.SetFocus
  TextBox1.CurLine = 0
  TextBox1.Locked = True
stop_sub:
End Sub
Private Sub CommandButton2_Click()
    Application.ScreenUpdating = False
    Sheets.Add
    Columns("A:A").ColumnWidth = 80
    N = NumEntries(TextBox1.Text, vbCrLf)
    With Range("A1:A" & N).Font
        .name = "Courier New"
        .Bold = True
        .Size = 8
    End With
    For i = 1 To N
        Range("A" & i).Value = Entry(i, TextBox1.Text, vbCrLf)
    Next i
    Rows("1:" & N).RowHeight = 12
    ActiveSheet.PrintOut
    Application.DisplayAlerts = False
    ActiveSheet.Delete
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
End Sub
Attribute VB_Name = "statForm"
Attribute VB_Base = "0{BFE04F80-5BA3-4E6C-AF1D-4C77A84E5A28}{429A87CE-A0E4-40BA-AFFE-19DAE3F49F8B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Const maxNbrLines As Integer = 9
Dim nline     As Integer
Dim bCancel   As Boolean

'By Victor H. Garcia, x64 compatibility issue
#If Win64 Then
Private Declare PtrSafe Function ShellExecute Lib "shell32" Alias "ShellExecuteA" (ByVal hWnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal plDirectory As String, ByVal nShowCmd As Long) As Long
#Else
Private Declare Function ShellExecute Lib "shell32" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
#End If

Private Sub closeBtn_Click()
  Application.Cursor = xlDefault
  lbl.Caption = ""
  Unload Me
  If bCancel Then
    CommForm.abortCon
  End If
End Sub

Private Sub ttlbl_Click()
  ShellExecute hWnd, "open", "http://www.32soft.com", vbNullString, vbNullString, SW_SHOWNORMAL
End Sub

Private Sub UserForm_Initialize()
  initForm
End Sub

Private Sub UserForm_Activate()
  initForm
End Sub

Private Sub UserForm_Terminate()
  closeBtn.Caption = "Cancel"
  Unload Me
End Sub

Private Sub UserForm_KeyPress(ByVal KeyAscii As msforms.ReturnInteger)
 If (KeyAscii = vbKeyReturn Or KeyAscii = vbKeyCancel) Then
  'User pressed a number key. Do whatever
  Beep
  'Unload Me
End If
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = True
End Sub

Public Sub addLine(iStr As String)
  Dim oStr As String
  nline = nline + 1
  If nline > maxNbrLines Then
    oStr = Mid(lbl.Caption, InStr(lbl.Caption, Chr$(10)) + 1)
    nline = maxNbrLines
    lbl.Caption = oStr
  End If
  
  If Len(lbl.Caption) > 0 Then
    lbl.Caption = lbl.Caption & Chr$(10) & iStr
  Else
    lbl.Caption = iStr
  End If

End Sub

Public Sub enableClose()
  bCancel = False
  closeBtn.Visible = True
  closeBtn.Caption = "Close"
  closeBtn.ControlTipText = ""
End Sub

Private Sub initForm()
  bCancel = True
  closeBtn.Caption = "Cancel"
  closeBtn.ControlTipText = "Break connection"
End Sub


' InQuest injected base64 decoded content
' {(rC

INQUEST-PP=macro
