Attribute VB_Name = "ChartForm"
Attribute VB_Base = "0{14EC8034-5D66-4F92-971C-C94A96560077}{D80E5D08-D817-41AB-A2C1-FFFDA9453894}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Dim oFrameMain As MSForms.Frame


Private Sub chkUpdateAll_Click()
   If chkUpdateAll Then
      ToggleAllUpdateCheckBoxes True
      If SelectionCount > 0 Then
         ToggleOkButton True
      Else
         ToggleOkButton False
      End If
   Else
      ToggleAllUpdateCheckBoxes False
   End If
End Sub

Private Sub cmdCancel_Click()
   Unload Me
End Sub

Private Sub cmdOK_Click()
   LockWord oDocument
   InsertCharts GetSelectedItems
   Unload Me
   UnlockWord oDocument
End Sub

Private Sub cmdSearchExcel_Click()
   Dim sPath As String
   sPath = ReturnExcelPath
   
   If LenB(sPath) > 0 Then
      txtWorkbook = sPath
   End If
   
End Sub

Private Sub cmdTest_Click()
   For Each ctl In Me.Controls
      Debug.Print ctl.Name
   Next
   'oExcel.Visible = True
End Sub

Private Sub txtWorkbook_Change()
   Dim colWorksheets As New Collection
   Dim oCurrentSheet As Worksheet
   Dim oItem
   Dim lConnection As Long
   
   On Error GoTo BailOut
   
   ExcelPath = txtWorkbook.Text
   lConnection = ConnectToExcel
   
   txtWorksheet.Clear
'      For I = 0 To txtWorksheet.ListCount - 1
'         txtWorksheet.List.RemoveItem (I)
'      Next
   txtWorksheet.AddItem "Alle ark"
   For Each oCurrentSheet In oWorkbook.Worksheets
      txtWorksheet.AddItem oCurrentSheet.Name
   Next

   txtWorksheet.Text = ""
  
BailOut:
   Resume Next
    'MsgBox "Error connecting to Excel"
End Sub

Private Sub txtWorksheet_Change()
   On Error GoTo BailOut
   ExcelSheet = txtWorksheet.Text
   Dim curWorksheet As Worksheet
   'ConnectToExcel
   Set SelectedWorksheets = New cPropertyBag
   If txtWorksheet.ListIndex = 0 Then
      For Each curWorksheet In oWorkbook.Worksheets
         SelectedWorksheets.Add curWorksheet.Name, curWorksheet.Name, curWorksheet.Index
      Next
   Else
      SelectedWorksheets.Add txtWorksheet.Text, txtWorksheet.Text, oWorkbook.Worksheets(txtWorksheet.Text).Index
      'Set oWorksheet = oWorkbook.Worksheets(ExcelSheet)
   End If
   RemountControlsWithExcelMatch
   Exit Sub
   
BailOut:
   txtWorksheet.Text = ""
   DialogCollapse
End Sub

Private Sub UserForm_Initialize()
   Dim lIndex As Long
   Dim colData As Collection
   
   Set oForm = Me
   InitializeComponents
   GetDataFromDocument
   MountControls
   
   LoadFormPosition Me, 100, 110, 350, 350
   
   For lIndex = 1 To TableTypeNumber
      Me.Controls("lblType" & lIndex).Visible = True
      Me.Controls("lblType" & lIndex).Caption = TableTypes(lIndex)
   Next
   If UpdateState Then
      ExcelPath = GetDocumentProperty("SD_ExcelPath", eplcDocPropCustom, oDocument)
      ExcelSheet = GetDocumentProperty("SD_ExcelSheet", eplcDocPropCustom, oDocument)
      txtWorkbook.Text = ExcelPath
      txtWorksheet.Text = ExcelSheet
      chkUpdateAll.Visible = True
      cmdOK.Caption = "Opdater grafer"
   Else
      DialogCollapse
   End If
   
   'DialogExpand
   ToggleOkButton False
   cmdTest.Visible = False
   
End Sub
Sub MountControls()
   
   Dim oTempControl As cFormChartControl
   Dim lIndex As Long
   
   Set oFrameMain = Me.Controls.Add("Forms.Frame.1", "frmMain")
   oFrameMain.Top = 96
   oFrameMain.Left = 6
   oFrameMain.Width = 300
   oFrameMain.Height = 300
   oFrameMain.BackColor = wdColorWhite
   oFrameMain.Visible = True
   
   For lIndex = 0 To TableRangeNumber - 1
      Set oTempControl = New cFormChartControl
      oTempControl.CreateControl oFrameMain, TableList(lIndex + 1).Value, TableRangeNumber, lIndex, TableList(lIndex + 1).ItemTag
      TableControls.Add oTempControl
   Next
   
   If TableRangeNumber > 15 Then
      oFrameMain.Width = oFrameMain.Width + 10
      oFrameMain.ScrollBars = fmScrollBarsVertical
      oFrameMain.ScrollHeight = TableRangeNumber * 20
      
   End If
   
End Sub

Sub RemountControlsWithExcelMatch()
   Dim oControl
   Dim oParentControl As cFormChartControl
   Dim sResult As String
   Dim lblName As String
   Dim sTitle As String
   Dim sChartName As String
   
   For Each oItem In TableControls
      oItem.NumberOfMatches = 0
      oItem.ValidExcelMatch = False
   Next
   Set ExcelTables = New cPropertyBag
   For Each oControl In CheckBoxControls
      'If (UpdateState And oControl.Enabled = True) Or Not UpdateState Then
         If Len(oControl.Name) = LONG_BOOKMARK_LENGTH Or Len(oControl.Name) = LONG_BOOKMARK_LENGTH_INDEXED Then
            Set oParentControl = GetChartControlByName(Left(oControl.Name, Len(oControl.Name) - 4))
         Else
            Set oParentControl = GetChartControlByName(oControl.Name)
         End If
         
         sChartName = oControl.Name
         If Len(sChartName) = SHORT_BOOKMARK_LENGTH_INDEXED Or Len(sChartName) = LONG_BOOKMARK_LENGTH_INDEXED Then
            sChartName = Left(sChartName, 11) & Right(sChartName, 4)
         End If
         
         sResult = ChartMatchWithExcel(sChartName)
         lblString = "lbl_" & Me.Controls(Left(oControl.Name, Len(oControl.Name) - 4)).Name
         If LenB(sResult) = 0 Then
            oControl.Enabled = False
         Else
            oControl.Enabled = True
            sTitle = ExcelChartTitle(sResult)
            If LenB(sTitle) > 0 Then
               If LenB(Me.Controls(lblString).Caption) = 0 Or Left(Me.Controls(lblString).Caption, 4) = "CHT_" Then
                  Me.Controls(lblString).ControlTipText = Me.Controls(lblString).Caption
                  Me.Controls(lblString).Caption = sTitle
               End If
            Else
               If LenB(Me.Controls(lblString).Caption) = 0 Or Left(Me.Controls(lblString).Caption, 4) = "CHT_" Then
                  Me.Controls(lblString).ControlTipText = "Sigende titel for denne graf mangler i Excel"
               End If
            End If
           oParentControl.ValidExcelMatch = True
           oParentControl.ctlUpdateCheckBox.Enabled = True
         End If
      'End If
   Next
   
   
   Dim bMatchFound As Boolean
   For Each oItem In TableControls
      'Debug.Print oItem.Name
      If Not oItem.IsTitleLabel Then
         'Debug.Print oItem.Name & oItem.Caption
         If Not oItem.ValidExcelMatch Then
            oItem.DisableElements
         Else
            oItem.EnableElements
            bMatchFound = True
         End If
      End If
      
   Next
   
'   If bMatchFound Then
   DialogExpand
   If Not UpdateState Then ToggleOkButton True
'   Else
'      DialogCollapse
'   End If
End Sub

Function GetSelectedItems() As cPropertyBag
   Dim oChartControl
   Dim oTypedChartControl As cFormChartControl
   Dim oControl
   Dim oTypedCheckBoxControl As cFormControlCheckBox
   Dim colItems As New cPropertyBag
   Dim sValue As String
   Dim sName As String
   Dim bValidUpdate As Boolean
   
   For Each oChartControl In TableControls
      Set oTypedChartControl = oChartControl
      If Not oTypedChartControl.IsTitleLabel Then
         sName = oTypedChartControl.Name & "_NUL"
         sValue = "NUL"
         For Each oControl In oTypedChartControl.OptionsGroup
            sName = oTypedChartControl.Name
            Set oTypedCheckBoxControl = oControl
            If Left(oTypedCheckBoxControl.Name, 4) = "CHT_" And (Len(oTypedCheckBoxControl.Name) = LONG_BOOKMARK_LENGTH Or Len(oTypedCheckBoxControl.Name) = LONG_BOOKMARK_LENGTH_INDEXED) Then
               If oTypedCheckBoxControl.ctlCheckBox.Value Then
                  If oTypedCheckBoxControl.Enabled Then
                     sName = oTypedCheckBoxControl.Name
                     sValue = Right(oTypedCheckBoxControl.Name, 3)
                  End If
               End If
            End If
         Next
         If oTypedChartControl.ValidUpdate Then
'            If sValue <> "SD_EMPTY" Then
               colItems.Add sName, sValue
'            Else
'               colItems.Add sValue
'            End If
         End If
      End If
   Next
   
   Set GetSelectedItems = colItems
   
End Function

Sub ToggleAllUpdateCheckBoxes(bVal As Boolean)
   Dim oItem 'As cFormChartControl
   Dim oStrongTypedItem As cFormChartControl
   For Each oItem In ChartControls
      Set oStrongTypedItem = oItem
      If Not oStrongTypedItem.IsTitleLabel Then
         If oStrongTypedItem.ctlUpdateCheckBox.Enabled Then
            oStrongTypedItem.ctlUpdateCheckBox = bVal
         End If
      End If
   Next
   ToggleOkButton bVal
End Sub

Public Function SelectionCount() As Long
   Dim oItem 'As cFormChartControl
   Dim lCount As Long
   Dim oStrongTypedItem As cFormChartControl
   For Each oItem In ChartControls
      Set oStrongTypedItem = oItem
      If Not oStrongTypedItem.IsTitleLabel Then
         If oStrongTypedItem.ctlUpdateCheckBox Then
            lCount = lCount + 1
         End If
      End If
   Next
   SelectionCount = lCount
End Function

Sub ToggleOkButton(bVal As Boolean)
'   If lCount > 0 Then
   cmdOK.Enabled = bVal
'   Else
'      cmdOK.Enabled = False
'   End If
End Sub
Sub DialogCollapse()
   oFrameMain.Visible = False
   frmNav.Top = txtWorksheet.Top + txtWorksheet.Height + 10
   Me.Height = frmNav.Height + frmNav.Top + 30
End Sub
Sub DialogExpand()
   oFrameMain.Visible = True
   frmNav.Top = oFrameMain.Top + oFrameMain.Height + 10
   Me.Height = frmNav.Height + frmNav.Top + 30
   Me.Repaint
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
   CloseExcelObjects
   SaveFormPosition Me, True, True
End Sub

Private Sub UserForm_Terminate()
   CloseExcelObjects
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "cDebugLog"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Form|fffd|l       :  Creates a Debug object that writes messages to an external
'                 debugger such as DebugView from Sysinternals.com
'
' Dependencies :  None
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  13. april 2010
' Modified     :  23. August 2011 /JAS    1) 32/64-bit 2010 support implemented.
'
' TODO         :  Enable logging to file. Must be considered wisely !!!

Private Const CLASS_NAME = "cDebugLog"

Public Enum enDebugEventTypes
   dbgLogNone = 0                  ' No logging
   dbgLogError = 2 ^ 0             ' Errors
   dbgLogWarning = 2 ^ 1           ' Warnings
   dbgLogInformational = 2 ^ 2     ' Info
   dbgWindowProc = 2 ^ 3           ' WindowProc (callbacks in general)
   dbgResources = 2 ^ 4            ' Resources
   '
   ' ... Room for new events types ...
   dbgLogCheckPoint = 2 ^ 10       ' check marks
   dbgNoCheckpoints = dbgLogError Or dbgLogWarning Or dbgLogInformational Or dbgWindowProc Or dbgResources
End Enum

Private m_FileNum             As Long
Private m_FilePath            As String
Private m_EventTypes          As Long
Private m_DebuggerEventTypes  As Long
Private m_AssertEventTypes    As Long
Private m_TimeStampMask       As String

Public EnableFileLogging      As Boolean
'
' There is no advantage with the W version of this function (says MSDN).
#If VBA7 Then
   Private Declare PtrSafe Sub OutputDebugStringA Lib "kernel32" (ByVal lpOutputString As String)
#Else
   Private Declare Sub OutputDebugStringA Lib "kernel32" (ByVal lpOutputString As String)
#End If

Public Property Get EventTypes() As enDebugEventTypes
   EventTypes = m_EventTypes
End Property
Public Property Let EventTypes(ByVal NewValue As enDebugEventTypes)
   m_EventTypes = NewValue
End Property

Public Property Get DebuggerEventTypes() As enDebugEventTypes
   DebuggerEventTypes = m_DebuggerEventTypes
End Property
Public Property Let DebuggerEventTypes(ByVal NewValue As enDebugEventTypes)
   m_DebuggerEventTypes = NewValue
End Property

Public Property Get AssertEventTypes() As enDebugEventTypes
   AssertEventTypes = m_AssertEventTypes
End Property
Public Property Let AssertEventTypes(ByVal NewValue As enDebugEventTypes)
   m_AssertEventTypes = NewValue
End Property

Public Property Get TimeStampMask() As String
   TimeStampMask = m_TimeStampMask
End Property
Public Property Let TimeStampMask(ByVal NewValue As String)
   m_TimeStampMask = NewValue
End Property

Public Sub DebugMessage(ByRef DebugText As String, _
                        Optional EventType As enDebugEventTypes = dbgLogCheckPoint, _
                        Optional ByVal ForceEntry As Boolean)

   Dim sEventType As String
      
   Select Case EventType
      Case dbgLogError
         sEventType = "  ERROR  "
      Case dbgLogWarning
         sEventType = "  WARN   "
      Case dbgLogInformational
         sEventType = "  INFO   "
      Case dbgWindowProc
         sEventType = "  WPROC  "
      Case dbgResources
         sEventType = "  *RES*  "
      Case Else 'dbgLogCheckPoint
         sEventType = "  CHECK  "
   End Select
   '
   ' Remove line breaks. The debugger does NOT accept them.
   DebugText = VBA.Replace(DebugText, vbCrLf, " ")
   '
   ' Log to file (must be rewritten)
   On Error Resume Next
   If EnableFileLogging Then
      m_FileNum = FreeFile
      Open m_FilePath For Append As m_FileNum
      Print #m_FileNum, Format$(Now(), m_TimeStampMask) & sEventType & DebugText
      Close m_FileNum
   End If
   '
   ' Send to debugger, eg. Mark Russinovich's DebugView (download from www.SysInternals.com).
   If (m_DebuggerEventTypes And EventType) <> 0 Or ForceEntry Then
      #If Mac = 1 Then
         Debug.Print ThisDocument.Name & " " & sEventType & DebugText & vbNullChar
      #Else
         OutputDebugStringA ThisDocument.Name & " " & sEventType & DebugText & vbNullChar
      #End If
   End If

End Sub

Private Sub Class_Initialize()
   m_TimeStampMask = "dd/mm hh:mm:ss"
   m_FilePath = CombinePaths(GetSpecialFolder(CSIDL_APPDATA), ThisDocument.Name & ".Log")
   
   EnableFileLogging = True
   
   If FileExists(m_FilePath) Then Call FileDeleteEx(m_FilePath)
   If EnableFileLogging Then
      DebugMessage CLASS_NAME & "::Initialize: Starting File Logging", dbgLogInformational
   End If
   
End Sub

Private Sub Class_Terminate()
   If EnableFileLogging Then
      DebugMessage CLASS_NAME & "::Terminate: Stopping File Logging", dbgLogInformational
   End If
End Sub
Attribute VB_Name = "cErrorHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'
' Module name  :  cErrorHandling.cls
' Requirements :  mErrorHandling.bas
'
' Created by   :  Jacob Sch|fffd|ffer
' Created date :  13. april 2010

Private Const CLASS_NAME = "cErrorHandler"

' ClassError - Triggered when an error occurs in a class module
'   Number - The error number
'   Source - The class that experienced the error
'   Description - The text explanation of the error
Public Event ClassError(ByVal Number As Long, ByVal Source As String, ByVal Description As String)

Friend Sub RaiseError(ByVal Number As Long, ByVal Source As String, ByVal Description As String)
    '
    ' Raise an error when we have one
    If Number <> 0 Then
        RaiseEvent ClassError(Number, Source, Description)
    End If

End Sub


Attribute VB_Name = "cFormChartControl"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents ctlControl As MSForms.Frame
Attribute ctlControl.VB_VarHelpID = -1
Public WithEvents ctlLabel As MSForms.label
Attribute ctlLabel.VB_VarHelpID = -1
Public WithEvents ctlUpdateCheckBox As MSForms.CheckBox
Attribute ctlUpdateCheckBox.VB_VarHelpID = -1

Private p_colOptionsGroup As Collection

Private p_HostFrame As MSForms.Frame
Private p_sTag As String
Private p_bUnderUpdate As Boolean
Private p_sName As String
Private p_sFullName As String
Private p_sType As String
Private p_sLabelText As String
Private p_bValidUpdate As Boolean
Private p_bValidExcelMatch As Boolean
Private p_bIsTitleLabel As Boolean
Private p_lNumberOfMatches As Long



Public Function CreateControl(ByVal oFrame As MSForms.Frame, sName As String, lCheckBoxNumber As Long, lRangeNumber As Long, sControlType As String)
   Set HostFrame = oFrame
   Name = sName
   Set ctlControl = oFrame.Controls.Add("Forms.Frame.1", sName, True)
   ctlControl.Width = 300
   ctlControl.Height = 20
   
   If sControlType <> "TITLE" Then
      Set ctlUpdateCheckBox = ctlControl.Controls.Add("Forms.CheckBox.1", "chkUpdate", True)
      ctlUpdateCheckBox.Left = 2
      ctlUpdateCheckBox.Width = 20
      ctlUpdateCheckBox.Height = 20
      ctlUpdateCheckBox.BackStyle = fmBackStyleTransparent
      If UpdateState Then
         ctlUpdateCheckBox.Visible = True
      Else
         ctlUpdateCheckBox.Value = True
         ctlUpdateCheckBox.Visible = False
      End If

      Set ctlLabel = ctlControl.Controls.Add("Forms.Label.1", "lbl_" & sName, True)
      ctlLabel.BorderStyle = fmBorderStyleNone
      ctlLabel.BackStyle = fmBackStyleTransparent
      ctlLabel.Top = 4
      ctlLabel.Left = 15
      ctlLabel.Width = 149
      ctlControl.Left = 0
      ctlControl.Top = 20 * (lRangeNumber)
      Caption = TableList(lRangeNumber + 1).Value

      Dim iIndex As Long
      Dim oTempCheckBox As cFormControlCheckBox

      Set OptionsGroup = New Collection

      For iIndex = 0 To TableTypeNumber - 1
         Set oTempCheckBox = New cFormControlCheckBox
         Set oTempCheckBox.Parent = Me
         OptionsGroup.Add oTempCheckBox

         oTempCheckBox.HostFrame = Me.ctlControl
         oTempCheckBox.CreateControl iIndex
      Next

      Me.ctlControl.BorderStyle = fmBorderStyleSingle
      Me.ctlControl.BorderColor = wdColorGray25
   Else
      IsTitleLabel = True
      Set ctlLabel = ctlControl.Controls.Add("Forms.Label.1", "lbl_" & sName, True)
      ctlControl.Left = 0
      ctlControl.Top = 20 * (lRangeNumber)
      ctlLabel.Top = 7
      ctlLabel.Left = 4
      ctlLabel.Width = 300
      ctlLabel.Caption = sName
      ctlLabel.Font.Bold = True
      Me.ctlControl.BorderStyle = fmBorderStyleSingle
      Me.ctlControl.BorderColor = wdColorWhite
   End If
   
End Function
Public Property Let Tag(sVal As String)
   p_sTag = sVal
End Property

Public Property Get Tag() As String
   Tag = p_sTag
End Property

Public Property Let Name(sVal As String)
    p_sName = sVal
End Property

Public Property Get Name() As String
    Name = p_sName
End Property
Public Property Let Caption(sVal As String)
   ctlLabel.Caption = sVal
End Property
Public Property Get Caption() As String
   Caption = ctlLabel.Caption
End Property
Public Property Get HostFrame() As MSForms.Frame
    Set HostFrame = p_HostFrame
End Property
Public Property Set HostFrame(oFrame As MSForms.Frame)
    Set p_HostFrame = oFrame
End Property
Public Property Get OptionsGroup() As Collection
   Set OptionsGroup = p_colOptionsGroup
End Property
Public Property Set OptionsGroup(colVal As Collection)
   Set p_colOptionsGroup = colVal
End Property
Public Property Let UnderUpdate(bVal As Boolean)
    p_bUnderUpdate = bVal
End Property
Public Property Get UnderUpdate() As Boolean
    UnderUpdate = p_bUnderUpdate
End Property
Public Property Get ValidUpdate() As Boolean
    ValidUpdate = ctlControl.Controls("chkUpdate").Value
End Property
Public Property Let ValidUpdate(bVal As Boolean)
    p_bValidUpdate = bVal
End Property

Public Property Get ValidExcelMatch() As Boolean
    ValidExcelMatch = p_bValidExcelMatch
End Property
Public Property Let ValidExcelMatch(bVal As Boolean)
    p_bValidExcelMatch = bVal
End Property
Public Property Get IsTitleLabel() As Boolean
    IsTitleLabel = p_bIsTitleLabel
End Property
Public Property Let IsTitleLabel(bVal As Boolean)
    p_bIsTitleLabel = bVal
End Property
Public Property Get NumberOfMatches() As Long
    NumberOfMatches = p_lNumberOfMatches
End Property
Public Property Let NumberOfMatches(lVal As Long)
    p_lNumberOfMatches = lVal
End Property

Public Sub OptionsGroupChange(sCheckBoxName As String)
   
   If UnderUpdate Then Exit Sub
   Dim oItem
   Dim oTempCheckBoxControl As cFormControlCheckBox
   UnderUpdate = True
   For Each oItem In OptionsGroup
      Set oTempCheckBoxControl = oItem
      If sCheckBoxName <> oTempCheckBoxControl.Name Then
         oTempCheckBoxControl.ctlCheckBox.Value = False
'      Else
'         oTempCheckBoxControl.ctlCheckBox.Value = True
      End If
   Next
   
   UnderUpdate = False
   
End Sub

Sub DisableElements()
   ctlUpdateCheckBox.Value = False
   ctlUpdateCheckBox.Enabled = False
   ctlLabel.ForeColor = wdColorGray40
   ctlControl.BackColor = RGB(240, 255, 190)
   ctlLabel.Caption = ctlControl.Name
End Sub

Sub EnableElements()
   ctlUpdateCheckBox.Enabled = True
   ctlLabel.ForeColor = wdColorBlack
   ctlControl.BackColor = wdColorWhite
End Sub

Private Sub ctlUpdateCheckBox_Change()
   oForm.ToggleOkButton oForm.SelectionCount > 0
End Sub

Attribute VB_Name = "cFormControlCheckBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents ctlCheckBox As MSForms.CheckBox
Attribute ctlCheckBox.VB_VarHelpID = -1

Private p_HostFrame As MSForms.Frame
Private p_oParent As cFormChartControl
Private p_sTag As String

Private p_sName As String
Private p_sFullName As String
Private p_sType As String
Public Property Let Tag(sVal As String)
   p_sTag = sVal
End Property

Public Property Get Tag() As String
   Tag = p_sTag
End Property

Public Property Let Name(sVal As String)
    p_sName = sVal
End Property

Public Property Get Name() As String
    Name = p_sName
End Property

Public Property Get HostFrame() As MSForms.Frame
    Set HostFrame = p_HostFrame
End Property
Public Property Let HostFrame(oFrame As MSForms.Frame)
    Set p_HostFrame = oFrame
End Property

Public Sub CreateControl(lIndex As Long)
   Set ctlCheckBox = HostFrame.Controls.Add("Forms.CheckBox.1", HostFrame.Name & "_" & TableTypes(lIndex + 1), True)
   Name = HostFrame.Name & "_" & TableTypes(lIndex + 1)
   ctlCheckBox.Width = 22
   ctlCheckBox.Height = 22
   ctlCheckBox.Left = 12 + 154 + lIndex * 35
   ctlCheckBox.BackStyle = fmBackStyleTransparent
   CheckBoxControls.Add ctlCheckBox
   
   Select Case UpdateState
      Case False
      ' First run. The document's bookmarks decide which checkbox value to choose
         If oDocument.Bookmarks.Exists(Name) Then
            ctlCheckBox.Value = True
         Else
            ctlCheckBox.Value = False
         End If
      
      Case True
      ' Update run. The checkboxes are filled out of state properties stored as document properties
         Dim sTempProperty As String
         If DocumentPropertyExists(HostFrame.Name, eplcDocPropCustom, oDocument) Then
            sTempProperty = GetDocumentProperty(HostFrame.Name, eplcDocPropCustom, oDocument)
            If UCase(TableTypes(lIndex + 1)) = UCase(sTempProperty) Then
               ctlCheckBox.Value = True
            End If
         Else
               If oDocument.Bookmarks.Exists(Name) Then
                  ctlCheckBox.Value = True
               Else
                  ctlCheckBox.Value = False
               End If
         End If
   End Select
   
   ctlCheckBox.Width = 20
   ctlCheckBox.Height = 20
   ctlCheckBox.Left = 12 + 154 + lIndex * 35
End Sub

Private Sub ctlCheckBox_Change()
'   If ctlCheckBox.Value = True Then
'      'MsgBox HostFrame.Name
'
'   End If
   
   Parent.OptionsGroupChange Name
End Sub


Public Property Get Enabled() As Boolean
   Enabled = ctlCheckBox.Enabled
End Property
Public Property Let Enabled(bVal As Boolean)
   ctlCheckBox.Enabled = bVal
End Property

Public Property Get Parent() As cFormChartControl
   Set Parent = p_oParent
End Property
Public Property Set Parent(oVal As cFormChartControl)
   Set p_oParent = oVal
End Property

Private Sub ctlCheckBox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
   ctlCheckBox.Value = Not ctlCheckBox.Value
End Sub

Private Sub ctlCheckBox_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
   'ctlCheckBox.Value = Not ctlCheckBox.Value
End Sub
Attribute VB_Name = "cIconLoaderEx"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
'
' Purpose      :  Loads an icon file into memory and dispatch each contained icon as
'                 an IPictureDisp object (such as a eg. the StdPicture object).
'
' Dependencies :  mCore_FileOperationsW.bas
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  24. october 2010
' Last modified:  28. december 2010 /JAS
'                 25. August 2011 /JAS    1) 64-bit 2010 support implemented.
'                 14. December 2011 /JAS  1) Bug-fixes for combined 32/64-bit use.
'
' Remarks      :  Currently only prepared for ICO files to be shown in a "Image" control,
'                 which works beutifully. For loading into the Ribbon *always* use PNG files.
'
' TODO         :  1) Get hands on the transparency mask for GIF and PNG files so we can
'                    load GIF and PNG files *correctly* into an Image control. Currently
'                    loading WMF/EMF and GIF/PNG formats with GDI+ via our RibbonPictureFromFile()
'                    function (in mIconLoader) fills the transparency region with black.
'                    We have to apply an OR/XOR-mask as we do for icons with the GetIconByIndex()
'                    function.
'                 2) Implement support for 256x256 icons.
'                 3) Debug why some ICO files will not load directly into the Ribbon !!!
'
Private Const CLASS_NAME = "cIconLoaderEx"

Private Enum enPictureTypeConstants
   eptcPicTypeBitmap = 1
   eptcPicTypeEMetafile = 4
   eptcPicTypeIcon = 3
   eptcPicTypeMetafile = 2
   eptcPicTypeNone = 0
End Enum

Private Const S_OK As Long = 0&
Private Const LR_DEFAULTCOLOR As Long = &H0
Private Const IID_IPicture As String = "{7BF80980-BF32-101A-8BBB-00AA00300CAB}"

Private Const my_cIconVersion As Long = &H30000

Private Type BITMAPINFOHEADER
   biSize As Long
   biWidth As Long
   biHeight As Long
   biPlanes As Integer
   biBitCount As Integer
   biCompression As Long
   biSizeImage As Long
   biXPelsPerMeter As Long
   biYPelsPerMeter As Long
   biClrUsed As Long
   biClrImportant As Long
End Type

Private Type IconHeader
   ihReserved As Integer
   ihType As Integer
   ihCount As Integer
End Type

Private Type IconEntry
   ieWidth As Byte
   ieHeight As Byte
   ieColorCount As Byte
   ieReserved As Byte
   iePlanes As Integer
   ieBitCount As Integer
   ieBytesInRes As Long
   ieImageOffset As Long
End Type
'
' GUID data type. Holds GUID for the IPictureDisp interface.
Private Type iID
   Data1 As Long
   Data2 As Integer
   Data3 As Integer
   Data4(0 To 7)  As Byte
End Type
'
' Note that hPalOrXYExt is a Union data type that VBA cannot directly deal with,
' and it change by the picType parameter. However, the structure size is constant !!!
' Be sure to declare different structures for each picture type.
Private Type PICTDESC
   cbSizeofStruct As Long
   picType As Long
   #If VBA7 Then
      hGdiObj As LongPtr
      hPalOrXYExt As LongPtr
   #Else
      hGdiObj As Long
      hPalOrXYExt As Long
   #End If
End Type
'
' GDI+ Startup information
Private Type GdiplusStartupInput
   GdiplusVersion As Long
   #If VBA7 Then
      DebugEventCallback As LongPtr
   #Else
      DebugEventCallback As Long
   #End If
   SuppressBackgroundThread As Long
   SuppressExternalCodecs As Long
End Type

#If VBA7 Then
   '
   ' GDI+ functions
   Private Declare PtrSafe Function GdiplusStartup Lib "GDIPlus" (token As LongPtr, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As LongPtr = 0) As Long
   Private Declare PtrSafe Function GdiplusShutdown Lib "GDIPlus" (ByVal token As LongPtr) As Long
   Private Declare PtrSafe Function GdipCreateBitmapFromHICON Lib "GdiPlus.dll" (ByVal hIcon As LongPtr, GpBitmap As LongPtr) As Long
   Private Declare PtrSafe Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal FileName As LongPtr, bitmap As LongPtr) As Long
   Private Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As LongPtr, hbmReturn As LongPtr, ByVal background As Long) As Long
   Private Declare PtrSafe Function GdipDisposeImage Lib "GDIPlus" (ByVal image As LongPtr) As Long
   
   Private Declare PtrSafe Sub RtlMoveMemory Lib "kernel32.dll" (ByRef pDst As Any, ByRef pSrc As Any, ByVal ByteLen As Long)
   '
   ' Loads an Icon from a byte array
   Private Declare PtrSafe Function CreateIconFromResourceEx Lib "User32.dll" (ByRef pbResBits As Any, ByVal dwResSize As Long, ByVal fIcon As Long, ByVal dwVersion As Long, ByVal cxDesired As Long, ByVal cyDesired As Long, ByVal uFlags As Long) As LongPtr
                            
   Private Declare PtrSafe Function IIDFromString Lib "ole32.dll" (ByVal lpsz As LongPtr, ByRef lpIID As iID) As Long
   Private Declare PtrSafe Function OleCreatePictureIndirect Lib "oleaut32.dll" (ByRef lpPictDesc As PICTDESC, ByRef riid As iID, ByVal fOwn As Boolean, ByRef lplpvObj As Object) As Long
   Private Declare PtrSafe Function OleTranslateColor Lib "oleaut32.dll" (ByVal lOleColor As Long, ByVal lHPalette As LongPtr, ByRef lColorRef As Any) As Long
#Else
   '
   ' GDI+ functions
   Private Declare Function GdiplusStartup Lib "GDIPlus" (token As Long, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As Long = 0) As Long
   Private Declare Function GdiplusShutdown Lib "GDIPlus" (ByVal token As Long) As Long
   Private Declare Function GdipCreateBitmapFromHICON Lib "GdiPlus.dll" (ByVal hIcon As Long, GpBitmap As Long) As Long
   Private Declare Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal FileName As Long, bitmap As Long) As Long
   Private Declare Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As Long, hbmReturn As Long, ByVal background As Long) As Long
   Private Declare Function GdipDisposeImage Lib "GDIPlus" (ByVal image As Long) As Long
   
   Private Declare Sub RtlMoveMemory Lib "kernel32.dll" (ByRef pDst As Any, ByRef pSrc As Any, ByVal ByteLen As Long)
   '
   ' Loads an Icon from a byte array
   Private Declare Function CreateIconFromResourceEx Lib "User32.dll" (ByRef pbResBits As Any, ByVal dwResSize As Long, ByVal fIcon As Long, ByVal dwVersion As Long, ByVal cxDesired As Long, ByVal cyDesired As Long, ByVal uFlags As Long) As Long
                            
   Private Declare Function IIDFromString Lib "ole32.dll" (ByVal lpsz As Long, ByRef lpIID As iID) As Long
   Private Declare Function OleCreatePictureIndirect Lib "oleaut32.dll" (ByRef lpPictDesc As PICTDESC, ByRef riid As iID, ByVal fOwn As Boolean, ByRef lplpvObj As Object) As Long
   Private Declare Function OleTranslateColor Lib "oleaut32.dll" (ByVal lOleColor As Long, ByVal lHPalette As Long, ByRef lColorRef As Any) As Long
#End If
'
' Structures to hold the Icon info
Private p_tIconHeader As IconHeader
Private p_taIconEntry() As IconEntry
Private p_yaIconData() As Byte
'

'
' Returns Icon(index) from the Icon ressource
Public Function GetIconByIndex(ByVal lIndex As Long, Optional ByVal TransColor32Bit As Long = vbButtonFace) As IPictureDisp
#If Not Mac = 1 Then
   
#If VBA7 Then
   Dim hIcon As LongPtr
#Else
   Dim hIcon As Long
#End If

   Dim lAlpha As Long
   Dim lRed As Long
   Dim lGreen As Long
   Dim lBlue As Long
   Dim lCol As Long
   Dim lRow As Long
   Dim lPictOffset As Long
   Dim lMaskOffset As Long
   Dim lPictPos As Long
   Dim lMaskPos As Long
   Dim lPictThisPart As Long
   Dim lMaskThisPart As Long
   Dim ya32Bit() As Byte
   Dim yaARGB(0 To 3) As Byte
   Dim tIID As iID
   Dim tPictDesc As PICTDESC
   Dim tBITMAPINFO As BITMAPINFOHEADER
   Dim oPicture As IPicture
   '
   ' The preferred colour depth for icons is 32 bit. However we can load non-32 bit
   ' icons with the CreateIconFromResourceEx API and get a valid hIcon afterall
   If IconColorDepth(lIndex) < 32 Then
   
      ' All the Icon Data is held in p_yaIconData. We extract the
      ' currently selected icon from its index.
      '
      ' Get the handle
      hIcon = CreateIconFromResourceEx(p_yaIconData(p_taIconEntry(lIndex).ieImageOffset), p_taIconEntry(lIndex).ieBytesInRes, 1, my_cIconVersion, p_taIconEntry(lIndex).ieWidth, p_taIconEntry(lIndex).ieHeight, LR_DEFAULTCOLOR)
           
   Else
      '
      ' 32 Bit Icons are more complex, since we have to mix icon colours
      ' with the background colour of the destination hDC to simulate
      ' proper transparency.
      '
      ' So we convert system colours and split their long values into RGB channels
      If OleTranslateColor(TransColor32Bit, 0&, yaARGB(0)) = S_OK Then
          '
          ' Get data for the currently selected icon.
          ReDim ya32Bit(p_taIconEntry(lIndex).ieBytesInRes - 1)
          Call RtlMoveMemory(ya32Bit(0), p_yaIconData(p_taIconEntry(lIndex).ieImageOffset), p_taIconEntry(lIndex).ieBytesInRes)
          '
          ' Calculate the size of this icon entry (incl. padding)
          lPictThisPart = p_taIconEntry(lIndex).ieWidth * 4 ' 32bpp
          lMaskThisPart = ((p_taIconEntry(lIndex).ieWidth + 31) And Not 31) \ 8 ' 1bpp
          '
          ' Calculate where in ya32Bit our data is located
          lPictOffset = Len(tBITMAPINFO)
          lMaskOffset = lPictOffset + (p_taIconEntry(lIndex).ieHeight * lPictThisPart)
          '
          ' Analyze all pixels, row by row, one by one
          For lRow = 0 To p_taIconEntry(lIndex).ieHeight - 1
            For lCol = 0 To p_taIconEntry(lIndex).ieWidth - 1
               '
               ' Calculate the pixel position
               lPictPos = lPictOffset + (lRow * lPictThisPart) + (lCol * 4)
               lMaskPos = lMaskOffset + (lRow * lMaskThisPart) + (lCol \ 8)
               '
               ' Is this a White pixel in the Mask?
               If (ya32Bit(lMaskPos) And CByte(&H80 / (2 ^ (lCol And &H7)))) = CByte(&H80 / (2 ^ (lCol And &H7))) Then
                  '
                  ' If so, we set this pixel to be transparent and set it to Black
                  ' in the Mask Bitmap
                  lAlpha = 0
                  ya32Bit(lMaskPos) = ya32Bit(lMaskPos) And Not CByte(&H80 / (2 ^ (lCol And &H7)))
               Else
                  '
                  ' The pixel was Black in the Mask, so the pixel becomes opaque in the image part
                  lAlpha = CLng(ya32Bit(lPictPos + 3)) ' A
               End If
               '
               ' Calculate the Alpha value
               lAlpha = 255 - lAlpha
               '
               ' Calculate each RGB value (note that the byte order is BGR)
               lRed = CLng(ya32Bit(lPictPos + 2))     ' R
               lGreen = CLng(ya32Bit(lPictPos + 1))   ' G
               lBlue = CLng(ya32Bit(lPictPos + 0))    ' B
               '
               ' Finally we mix the RGB values with TransColor32Bit and blend with Alpha
               ya32Bit(lPictPos + 2) = CByte(lRed - (((lRed - yaARGB(0)) * lAlpha) / 255))
               ya32Bit(lPictPos + 1) = CByte(lGreen - (((lGreen - yaARGB(1)) * lAlpha) / 255))
               ya32Bit(lPictPos + 0) = CByte(lBlue - (((lBlue - yaARGB(2)) * lAlpha) / 255))
                    
            Next ' lCol
         Next ' lRow
          
      End If
      '
      ' Try to get the handle
      hIcon = CreateIconFromResourceEx(ya32Bit(0), p_taIconEntry(lIndex).ieBytesInRes, 1, my_cIconVersion, p_taIconEntry(lIndex).ieWidth, p_taIconEntry(lIndex).ieHeight, LR_DEFAULTCOLOR)
           
   End If
   '
   ' Return result
   If hIcon <> 0 Then
      Set GetIconByIndex = LoadIconFromIconHandle(hIcon)
   End If
#End If
End Function

'
' Works for ICO files only with max size 128x128 pixels.
' TODO: Implement support for 256x256 icons.
Public Function LoadIconFile(ByVal sIconFile As String) As Boolean
#If Not Mac = 1 Then
   
   Dim lFno As Long
   
   If FileExists(sIconFile) Then
      '
      ' Clear old data
      Erase p_yaIconData
      Erase p_taIconEntry
      
      ' Load the binary Icon Data
      lFno = FreeFile
      Open sIconFile For Binary Access Read As #lFno
      ReDim p_yaIconData(LOF(lFno) - 1)
      Get #lFno, , p_yaIconData()
      Close #lFno
      '
      ' Get the IconHeader part from p_yaIconData
      Call RtlMoveMemory(p_tIconHeader, p_yaIconData(0), Len(p_tIconHeader))
      '
      ' If it's a valid header for Icon Data, then p_tIconHeader.ihType = 1
      ' Hmmm ... Why? 1 is normally eptcPicTypeBitmap !!!
      If p_tIconHeader.ihType = 1 Then
         '
         ' Hence, we must have at least one icon
         If p_tIconHeader.ihCount >= 1 Then
            '
            ' ... but we may have an arbitrary number of icons. The p_tIconHeader.ihCount
            ' tells us how many entries we have to cope with.
            ReDim p_taIconEntry(p_tIconHeader.ihCount - 1)
            '
            ' Get the Icon Entries from the byte array.
            Call RtlMoveMemory(p_taIconEntry(0), p_yaIconData(Len(p_tIconHeader)), Len(p_taIconEntry(0)) * p_tIconHeader.ihCount)
            
            LoadIconFile = True
         End If
      End If
   End If
#End If
End Function

'
' The handle MUST be a hBitmap type. If you have a hIcon type handle you
' MUST call the LoadIconFromIconHandle function instead.
#If VBA7 Then
   Public Function BitmapHandleToPicture(ByVal hGDIHandle As LongPtr) As IPictureDisp
#Else
   Public Function BitmapHandleToPicture(ByVal hGDIHandle As Long) As IPictureDisp
#End If

   Dim tIID As iID
   Dim tPictDesc As PICTDESC
   Dim oPicture As IPictureDisp
   '
   ' Did we get a valid handle?
   If hGDIHandle <> 0 Then
      '
      ' Fill the picture type GUID structure (tIID)
      If IIDFromString(StrPtr(IID_IPicture), tIID) = S_OK Then
         
         With tPictDesc
            .cbSizeofStruct = Len(tPictDesc)
            .picType = enPictureTypeConstants.eptcPicTypeBitmap
            .hGdiObj = hGDIHandle
         End With
         '
         ' Get the StdPicture interface for the bitmap
         If OleCreatePictureIndirect(tPictDesc, tIID, 1, oPicture) = S_OK Then
             Set BitmapHandleToPicture = oPicture
         End If
      End If
   End If
    
End Function

#If VBA7 Then
   Public Function LoadIconFromIconHandle(ByVal hIcon As LongPtr) As IPictureDisp
      Dim hGdiPlus As LongPtr
      Dim hGdiImage As LongPtr
      Dim hBitmap As LongPtr
#Else
   Public Function LoadIconFromIconHandle(ByVal hIcon As Long) As IPictureDisp
      Dim hGdiPlus As Long
      Dim hGdiImage As Long
      Dim hBitmap As Long
#End If

   Dim uGdiInput As GdiplusStartupInput
   Dim lRes As Long
   
   ' Load the GDI+ library
   uGdiInput.GdiplusVersion = 1
   lRes = GdiplusStartup(hGdiPlus, uGdiInput)
   If lRes = 0 Then
      '
      ' Load the image
      lRes = GdipCreateBitmapFromHICON(hIcon, hGdiImage)
      If lRes = 0 Then
         '
         ' Convert hIcon to a hBitmap type of handle
         lRes = GdipCreateHBITMAPFromBitmap(hGdiImage, hBitmap, 0)
         '
         ' Create the IPictureDisp object from hBitmap
         Set LoadIconFromIconHandle = Me.BitmapHandleToPicture(hBitmap)

         ' Clean the house
         GdipDisposeImage hGdiImage
      End If

      ' Unload GDI+
      GdiplusShutdown hGdiPlus
   End If

End Function

'
' Loading icons from PNG and ICO format.
' TODO: Debug why some ICO files will not load directly into the Ribbon !!!
Public Function LoadIconFromFile(ByVal sFileName As String, Optional ByVal lBackColor As Long) As IPictureDisp
#If Not Mac = 1 Then

   #If VBA7 Then
      Dim hGdiPlus As LongPtr
      Dim hGdiImage As LongPtr
      Dim hBitmap As LongPtr
   #Else
      Dim hGdiPlus As Long
      Dim hGdiImage As Long
      Dim hBitmap As Long
   #End If

   Dim uGdiInput As GdiplusStartupInput
   Dim lRes As Long
   '
   ' Load the GDI+ library
   uGdiInput.GdiplusVersion = 1
   lRes = GdiplusStartup(hGdiPlus, uGdiInput)
   If lRes = 0 Then
      '
      ' Load the image
      lRes = GdipCreateBitmapFromFile(StrPtr(sFileName), hGdiImage)
      If lRes = 0 Then
         '
         ' Get a bitmap handle from the loaded image
         lRes = GdipCreateHBITMAPFromBitmap(hGdiImage, hBitmap, lBackColor)
         '
         ' Create the IPictureDisp object from hBitmap
         Set LoadIconFromFile = Me.BitmapHandleToPicture(hBitmap)
         '
         ' Clean the house
         GdipDisposeImage hGdiImage
      End If
      '
      ' Unload GDI+
      GdiplusShutdown hGdiPlus
   End If
#End If
End Function

Public Property Get IconCount() As Long
   IconCount = p_tIconHeader.ihCount
End Property

Public Property Get IconWidth(ByVal lIndex As Long) As Long
   IconWidth = p_taIconEntry(lIndex).ieWidth
End Property

Public Property Get IconHeight(ByVal lIndex As Long) As Long
   IconHeight = p_taIconEntry(lIndex).ieHeight
End Property

Public Property Get IconColorDepth(ByVal lIndex As Long) As Long
   
   If p_taIconEntry(lIndex).iePlanes = 1 Then
      '
      ' 16 bit, 24 bit or 32 bit
      IconColorDepth = p_taIconEntry(lIndex).ieBitCount
       
   Else
      '
      ' 1 bit, 4 bit or 8 bit
      Select Case p_taIconEntry(lIndex).ieColorCount
      
      Case 2
          IconColorDepth = 1
          
      Case 16
          IconColorDepth = 4
          
      Case Else
          IconColorDepth = 8
          
      End Select
       
   End If
   
End Property

Private Sub Class_Initialize()
   '
End Sub

Private Sub Class_Terminate()
   '
   ' Clear old data
   Erase p_yaIconData
   Erase p_taIconEntry
End Sub
Attribute VB_Name = "cPerformanceTester"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Purpose      :  Creates a private performance tester object
'
' Dependencies :  None. This is a drop-in class.
'
' Created by   :  Jacob Sch|fffd|ffer
' Created      :  13. april 2010
' Modified     :  24. August 2011 /JAS    1) 64-bit support implemented.

' Sample code  :  Dim cP As cPerformanceTester
'                 Set cP = New cPerformanceTester
'                 cP.StartTimer
'
'                 ... Do something
'
'                 cP.StopTimer
'                 MsgBox "The procress took " & cP.TickTime & " seconds."
'                 Set cP = Nothing
'
' API for getting time
#If VBA7 Then
   #If Win64 Then
      Private Declare PtrSafe Function GetTickCount Lib "kernel32" Alias "GetTickCount64" () As LongLong
   #Else
      Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
   #End If
#Else
   Private Declare Function GetTickCount Lib "kernel32" () As Long
#End If
'
' Private property holders
#If Win64 Then
   Private my_lStartTick As LongLong
   Private my_lStopTick As LongLong
#Else
   Private my_lStartTick As Long
   Private my_lStopTick As Long
#End If
'

Public Sub StartTimer()
   StopTimer
#If Not Mac = 1 Then
   my_lStartTick = GetTickCount()
#End If
End Sub

Public Sub StopTimer()
#If Not Mac = 1 Then
   my_lStopTick = GetTickCount()
#End If
End Sub

#If Win64 Then
   Public Property Get Ticks() As LongLong
#Else
   Public Property Get Ticks() As Long
#End If
   Ticks = my_lStopTick - my_lStartTick
End Property

Public Property Get TickTime() As String
   TickTime = FormatNumber(Ticks / 1000, 3)
End Property

Private Sub Class_Initialize()
   StartTimer
End Sub
Attribute VB_Name = "cPropertyBag"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Binary
'
' Purpose      :  Creates a collection class object with support for "For ... Next"
'                 loops and sets the "Item" property as default proc for the class.
'
'                 cPropertyBag is holding a collection of cPropertyObject
'                 Key/Value-objects, but can be used as a master template for
'                 other collection class objects. See Remarks for instructions.
'
' Dependencies :  cPropertyObject.cls
'                 cPropertyBagsCollection.cls
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  25. May 2010
' Last modified:  01. October 2010 /HPZ
'                 23. December 2010 /JAS  1) GetFirstItemByItemTag() function implemented.
'                                         2) Case sensitivity removed from the GetByItemTag() function
'                 15. August 2011 /JAS    1) Sort() function implemented. It's based on the in-place
'                                            version of Tony Hoare's QuickSort algoritm described at
'                                            http://en.wikipedia.org/wiki/Quicksort
'                 16. August 2011 /JAS    1) Bug fixes in GetByItem*() functions which now also return
'                                            references to each item's DataSource object (if any).
'                                         2) List() function implemented to provide a simple way to
'                                            list elements in a GUI list.
'                 18. November 2011 /JAS  1) The List() function can now return multiple dimensions.
'                                         2) The Exists() function can now identify property objects
'                                            by Key, Value, ItemTag or ItemData (Defaults to Key)
'                                         3) IndexForValue() property added
'                                         4) IndexForItemData() property added
'                                         5) IndexForItemTag() property added
'                 12. January 2012 /JAS   1) Fixed a bug in the Sort() function.
'
' Remarks      :  1) You can *NOT* copy the code in this class into a new class
'                    module and preserve support for "For ... Next" loops, because
'                    procedure attributes (such as VB_UserMemId and VB_MemberFlags)
'                    gets lost. To preserve these attributes you *MUST* do as follows:

'                    a) Export this class module to a new name.
'                    b) Open this new .cls file in NotePad2, PSPad or similar
'                    c) Search/replace any "cPropertyBag" name with a new name
'                       and save the .cls file
'                    d) Import the .cls file.
'
' TODO         :  1) Write a Replace function when need be. Currently we have to
'                    remove an item before we can add one with the same sKey again.
'
Private Const CLASS_NAME = "cPropertyBag"
'
' Constants for QuickSort compare/swap decisions
Private Const OBJECT1_LESS_THAN_OBJECT2 As Long = -1
Private Const OBJECT1_EQUALS_OBJECT2 As Long = 0
Private Const OBJECT1_GREATER_THAN_OBJECT2 As Long = 1
'
' Enum for QuickSort criteria, see the Sort() function
Public Enum enSortPropertyConstants
   espcSortByKey = 0
   espcSortByValue = 1
   espcSortByItemData = 2
   espcSortByItemTag = 3
End Enum
'
' Enum for Listing criteria, see the List() function
Public Enum enListingTypeConstants
   eltcListByKey = 0
   eltcListByValue = 1
   eltcListByItemData = 2
   eltcListByItemTag = 3
End Enum
'
' Private collection object for item storage
Private my_oCol As Collection
'
Private my_sKey As String
Private my_lItemData As Long
Private my_sItemTag As String

Public Parent As cPropertyBagsCollection
'
' Events fired
Public Event OnBeforeAddItem(ByRef oPropertyObject As cPropertyObject, ByRef bCancel As Boolean)
Public Event OnBeforeClear(ByRef bCancel As Boolean)
Public Event OnBeforeRemoveItem(ByRef oPropertyObject As cPropertyObject, ByRef bCancel As Boolean)
Public Event OnCleared()
Public Event OnItemAdded(ByRef oPropertyObject As cPropertyObject)
Public Event OnItemExisted(ByRef oPropertyObject As cPropertyObject)
Public Event OnItemRemoved(ByRef oPropertyObject As cPropertyObject)
Public Event OnSortingBegin(ByRef bCancel As Boolean)
Public Event OnSortingDone(ByVal bSuccess As Boolean)

Public Property Let Key(ByVal sNewKey As String)
   my_sKey = sNewKey
End Property
Public Property Get Key() As String
   Key = my_sKey
End Property

Public Property Let Index(ByVal lNewIndex As Long)
   Err.Raise 383, CLASS_NAME & "::Index (Property Let)", "The Index property is Read-Only."
End Property
Public Property Get Index() As Long
   If Not Parent Is Nothing Then
      Index = Parent.IndexForKey(my_sKey)
   Else
      Index = 0
   End If
End Property

Public Property Let ItemData(ByVal lNewItemData As Long)
   my_lItemData = lNewItemData
End Property
Public Property Get ItemData() As Long
   ItemData = my_lItemData
End Property

Public Property Let ItemTag(ByVal sNewItemTag As String)
   my_sItemTag = sNewItemTag
End Property
Public Property Get ItemTag() As String
   ItemTag = my_sItemTag
End Property
'
' Validates that an Item with the specified ItemId exists
' in the collection.
Public Function Exists(ByVal ItemId As Variant, _
                       Optional eLookupBy As enSortPropertyConstants = espcSortByKey) As Boolean
   
   Select Case eLookupBy
      '
      ' Backward compatible behaviour
      Case espcSortByKey
         Exists = (Not Item(CStr(ItemId)) Is Nothing)
      
      Case espcSortByValue
         Exists = (IndexForValue(ItemId) > 0)
         
      Case espcSortByItemTag
         Exists = (IndexForItemTag(CStr(ItemId)) > 0)
      
      Case espcSortByItemData
         Exists = (IndexForItemData(CLng(ItemId)) > 0)
   
   End Select

End Function

'
' Adds a new cPropertyObject item to the collection *if* it
' doesn't exist i advance. The ItemId is sKey, its value is
' vValue (Variant). Returns Nothing if the function fail.
Public Function Add(ByVal sKey As String, _
                    ByVal vValue As Variant, _
                    Optional ByVal lItemData As Long, _
                    Optional ByVal sItemTag As String, _
                    Optional ByVal bAllowDuplicateKeys As Boolean = True, _
                    Optional ByRef vDataSource As Object) As cPropertyObject
                    
' Extra optional lItemData and sItemTag properties are allowed eg.
' for pointer storage, but its useful for many purposes.
'
' NOTE: this function does not replace an item if sKey
' already exists in the collection.
                    
   Dim bCancel As Boolean
   Dim oNew As cPropertyObject
   Set oNew = New cPropertyObject
   '
   ' Create the object
   With oNew
      .Key = sKey
      .Value = vValue
      .ItemData = lItemData
      .ItemTag = sItemTag
      Set .DataSource = vDataSource
      Set .Parent = Me
   End With
   '
   ' Allow a potential event listener (eg. a GUI) to interact, ie.
   ' make changes to oNew or cancel the operation.
   RaiseEvent OnBeforeAddItem(oNew, bCancel)
   If Not bCancel Then
      
      On Error Resume Next
      
      If bAllowDuplicateKeys Then
          my_oCol.Add oNew
      Else
          my_oCol.Add oNew, oNew.Key
      End If
      
      If Err.Number = 457 Then
         RaiseEvent OnItemExisted(oNew)
         Set Add = Nothing
      Else
         RaiseEvent OnItemAdded(oNew)
         Set Add = oNew
      End If
      On Error GoTo 0
   
   Else
      Set Add = Nothing
   End If
   
   Set oNew = Nothing

End Function

'
' Return the number of Item members
Public Property Get Count() As Long
   If my_oCol Is Nothing Then
      Count = 0
   Else
      Count = my_oCol.Count
   End If
End Property

'
' Returns the Item with ItemId (representing either Key or Index)
' The Item property is the default property of this class.
Public Property Get Item(ByVal ItemId As Variant) As cPropertyObject
Attribute Item.VB_UserMemId = 0
   Dim i As Long
   Dim cO As cPropertyObject
   '
   ' 23/12-2010 /JAS
   ' Remove case sensitivity
   ItemId = LCase$(ItemId)
   
   On Error Resume Next
   If Not IsNumeric(ItemId) Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
        ' If cO.key = ItemId Then
         If LCase$(cO.Key) = ItemId Then
            Exit For
         End If
      Next 'I
   Else
      i = CLng(ItemId)
   End If
   Set Item = my_oCol(i)
   
   Err.Clear
   Set cO = Nothing
End Property

Public Property Get Items() As Collection
    Set Items = my_oCol
End Property

'
' Returns the Index in our collection for the specified sKey.
Public Property Get IndexForKey(ByVal sKey As String) As Long
   Dim i As Long
   Dim cO As cPropertyObject
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.Key = sKey Then
         IndexForKey = i
         Exit For
      End If
   Next 'I
   
   Set cO = Nothing
End Property

'
' Returns the Index in our collection for the specified vValue.
' Usefull in cases where values are unique and represent Strings or Numbers.
' If values are not unique Index for the first match is returned.
Public Property Get IndexForValue(ByVal vValue As Variant) As Long
   Dim i As Long
   Dim cO As cPropertyObject
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      
' TODO: Implement support for Objects and other data types.
      
      If IsNumeric(vValue) Then
         If cO.Value = CLng(vValue) Then
            IndexForValue = i
            Exit For
         End If
      Else
         If cO.Value = vValue Then
            IndexForValue = i
            Exit For
         End If
      End If
   Next 'I
   
   Set cO = Nothing
End Property

'
' Returns the Index in our collection for the specified sItemTag.
' Usefull in cases where ItemTag values are unique.
' If ItemTag values are not unique Index for the first match is returned.
Public Property Get IndexForItemTag(ByVal sItemTag As String) As Long
   Dim i As Long
   Dim cO As cPropertyObject
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.ItemTag = sItemTag Then
         IndexForItemTag = i
         Exit For
      End If
   Next 'I
   
   Set cO = Nothing
End Property

'
' Returns the Index in our collection for the specified sItemData.
' Usefull in cases where ItemData values are unique.
' If ItemData values are not unique Index for the first match is returned.
Public Property Get IndexForItemData(ByVal lItemData As Long) As Long
   Dim i As Long
   Dim cO As cPropertyObject
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.ItemData = lItemData Then
         IndexForItemData = i
         Exit For
      End If
   Next 'I
   
   Set cO = Nothing
End Property

'
' Returns a cPropertyBag object holding all cPropertyObject Items
' with the specified ItemData property.
Public Function GetByItemData(ByVal lItemData As Long) As cPropertyBag

   Dim i As Long
   Dim cO As cPropertyObject
   Dim oProps As New cPropertyBag
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.ItemData = lItemData Then
         Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
      End If
   Next 'I
     
   Set GetByItemData = oProps
   
   Set cO = Nothing

End Function

'
' Returns a cPropertyBag object holding all cPropertyObject Items
' with the specified ItemTag property.
Public Function GetByItemTag(ByVal sItemTag As String) As cPropertyBag

   Dim i As Long
   Dim cO As cPropertyObject
   Dim oProps As New cPropertyBag
   Dim bUseWildCard As Boolean
   '
   ' 23/12-2010 /JAS
   ' Remove case sensitivity
   sItemTag = LCase$(sItemTag)
   
'<JAS 11/12-2014: Add support for advanced WildCards>
   bUseWildCard = (InStr(1, sItemTag, "*", vbTextCompare) <> 0) Or (InStr(1, sItemTag, "?", vbTextCompare) <> 0)
   If bUseWildCard Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If IsMatchingSearchMask(cO.ItemTag, sItemTag) Then
            Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
         End If
      Next 'I
'</JAS 11/12-2014>
   Else
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
        ' If cO.ItemTag = sItemTag Then
         If LCase$(cO.ItemTag) = sItemTag Then
            Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
         End If
      Next 'I
   End If
   Set GetByItemTag = oProps
   
   Set cO = Nothing

End Function

'
' Returns a cPropertyBag object holding all cPropertyObject Items
' with the specified ItemKey property.
Public Function GetByItemKey(ByVal sItemKey As String) As cPropertyBag

   Dim i As Long
   Dim cO As cPropertyObject
   Dim oProps As New cPropertyBag
   Dim bUseWildCard As Boolean
   '
   ' 23/12-2010 /JAS
   ' Remove case sensitivity
   sItemKey = LCase$(sItemKey)
   
'<JAS 11/12-2014: Add support for advanced WildCards>
   bUseWildCard = (InStr(1, sItemKey, "*", vbTextCompare) <> 0) Or (InStr(1, sItemKey, "?", vbTextCompare) <> 0)
   If bUseWildCard Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If IsMatchingSearchMask(cO.Key, sItemKey) Then
            Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
         End If
      Next 'I
'</JAS 17/01-2014>
   Else
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If LCase$(cO.Key) = sItemKey Then
            Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
         End If
      Next 'I
   End If
   
   Set GetByItemKey = oProps
   
   Set cO = Nothing

End Function

'
' Returns a cPropertyBag object holding all cPropertyObject Items
' with the specified ItemKey property.
Public Function GetByItemValue(ByVal sItemValue As String) As cPropertyBag

   Dim i As Long
   Dim cO As cPropertyObject
   Dim oProps As New cPropertyBag
   Dim bUseWildCard As Boolean
   '
   ' 23/12-2010 /JAS
   ' Remove case sensitivity
   sItemValue = LCase$(sItemValue)
   
'<JAS 11/12-2014: Add support for advanced WildCards>
   bUseWildCard = (InStr(1, sItemValue, "*", vbTextCompare) <> 0) Or (InStr(1, sItemValue, "?", vbTextCompare) <> 0)
   If bUseWildCard Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If IsMatchingSearchMask(cO.Value, sItemValue) Then
            Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
         End If
      Next 'I
'</JAS 11/12-2014>
   Else
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If LCase$(cO.Value) = sItemValue Then
            Call oProps.Add(cO.Key, cO.Value, cO.ItemData, cO.ItemTag, True, cO.DataSource)
         End If
      Next 'I
   End If
   Set GetByItemValue = oProps
   
   Set cO = Nothing

End Function

'
' Returns a reference to the first cPropertyObject object with the specified ItemTag.
' Lookup is NOT case sensitive.
Public Function GetFirstItemByItemTag(ByVal sItemTag As String) As cPropertyObject

   Dim i As Long
   Dim cO As cPropertyObject
   '
   ' 23/12-2010 /JAS
   ' Remove case sensitivity
   sItemTag = LCase$(sItemTag)
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
     ' If cO.ItemTag = sItemTag Then
      If LCase$(cO.ItemTag) = sItemTag Then
         Set GetFirstItemByItemTag = cO
      End If
   Next 'I

End Function

Public Function Import(ByRef oSourceBag As cPropertyBag, _
                       Optional bAllowDuplicateKeys As Boolean = True, _
                       Optional oSeparator As cPropertyObject) As Long

   Dim i As Long

   If Not oSourceBag Is Nothing Then

      If Not oSeparator Is Nothing Then
         Add oSeparator.Key, oSeparator.Value, oSeparator.ItemData, oSeparator.ItemTag, bAllowDuplicateKeys, oSeparator.DataSource
      End If
   
      For i = 1 To oSourceBag.Count
         Add oSourceBag(i).Key, oSourceBag(i).Value, oSourceBag(i).ItemData, oSourceBag(i).ItemTag, bAllowDuplicateKeys, oSourceBag(i).DataSource
      Next
   
      Import = oSourceBag.Count
   
   Else
      Err.Raise 91, CLASS_NAME & "::Import", "Nothing to Import. The source object to import from is not initialized."
   End If
   
End Function

'Public Function ImportFromXMLNodes(ByRef oXMLNodes As cXMLNodes, _
'                                   Optional bAllowDuplicateKeys As Boolean = True) As Long
'
'   Dim I As Long
'   Dim oTheseNodes As cXMLNodes
'   Dim oThisNode As cXMLNode
'
'   If Not oXMLNodes Is Nothing Then
'      For I = 1 To oXMLNodes.Count
'         Add oXMLNodes(I).Name, oXMLNodes(I).Text, , , bAllowDuplicateKeys, oXMLNodes(I)
'      Next
'      ImportFromXMLNodes = Count
'   Else
'      Err.Raise 91, CLASS_NAME & "::ImportFromXMLNodes", "Nothing to Import. The source object to import from is not initialized."
'      Exit Function
'   End If
'
'End Function

Public Function List(Optional ByVal eListByFirstColumn As enListingTypeConstants = eltcListByKey, _
                     Optional ByVal eListBySecondColumn As enListingTypeConstants = -1, _
                     Optional ByVal eListByThirdColumn As enListingTypeConstants = -1, _
                     Optional ByVal eListByFourthColumn As enListingTypeConstants = -1, _
                     Optional ByVal sTextIfIsMissing As String = "N/A" _
                     ) As String()

   Dim i As Long
   Dim cO As cPropertyObject
   Dim lNumColumns As Long
   Dim saListValues() As String
   '
   ' Default to 1 column.
   lNumColumns = 1
   If eListBySecondColumn > -1 Then
      lNumColumns = 2
   End If
   If eListByThirdColumn > -1 Then
      lNumColumns = 3
   End If
   If eListByFourthColumn > -1 Then
      lNumColumns = 4
   End If
   
   If my_oCol.Count > 0 Then
      '
      ' Resize the array
      If lNumColumns = 1 Then
         ReDim saListValues(0 To my_oCol.Count - 1)
      ElseIf lNumColumns = 2 Then
         ReDim saListValues(0 To my_oCol.Count - 1, 0 To 1)
      ElseIf lNumColumns = 3 Then
         ReDim saListValues(0 To my_oCol.Count - 1, 0 To 2)
      Else
         ReDim saListValues(0 To my_oCol.Count - 1, 0 To 3)
      End If
      '
      ' Build the list
      For i = 0 To my_oCol.Count - 1
         Set cO = my_oCol(i + 1)
      
         If lNumColumns = 1 Then
            saListValues(i) = GetValueForList(cO, eListByFirstColumn, sTextIfIsMissing)
         
         ElseIf lNumColumns = 2 Then
            saListValues(i, 0) = GetValueForList(cO, eListByFirstColumn, sTextIfIsMissing)
            saListValues(i, 1) = GetValueForList(cO, eListBySecondColumn, sTextIfIsMissing)
            
         ElseIf lNumColumns = 3 Then
            saListValues(i, 0) = GetValueForList(cO, eListByFirstColumn, sTextIfIsMissing)
            saListValues(i, 1) = GetValueForList(cO, eListBySecondColumn, sTextIfIsMissing)
            saListValues(i, 2) = GetValueForList(cO, eListByThirdColumn, sTextIfIsMissing)
            
         ElseIf lNumColumns = 4 Then
            saListValues(i, 0) = GetValueForList(cO, eListByFirstColumn, sTextIfIsMissing)
            saListValues(i, 1) = GetValueForList(cO, eListBySecondColumn, sTextIfIsMissing)
            saListValues(i, 2) = GetValueForList(cO, eListByThirdColumn, sTextIfIsMissing)
            saListValues(i, 3) = GetValueForList(cO, eListByFourthColumn, sTextIfIsMissing)
         End If
            
      Next ' I = 0 To my_oCol.Count - 1
      
   Else
      If lNumColumns = 1 Then
         ReDim saListValues(0 To 0)
         saListValues(0) = sTextIfIsMissing
      
      ElseIf lNumColumns = 2 Then
         ReDim saListValues(0 To 0, 0 To 1)
         saListValues(0, 0) = sTextIfIsMissing
         saListValues(0, 1) = sTextIfIsMissing
      
      ElseIf lNumColumns = 3 Then
         ReDim saListValues(0 To 0, 0 To 2)
         saListValues(0, 0) = sTextIfIsMissing
         saListValues(0, 1) = sTextIfIsMissing
         saListValues(0, 2) = sTextIfIsMissing
      
      ElseIf lNumColumns = 4 Then
         ReDim saListValues(0 To 0, 0 To 3)
         saListValues(0, 0) = sTextIfIsMissing
         saListValues(0, 1) = sTextIfIsMissing
         saListValues(0, 2) = sTextIfIsMissing
         saListValues(0, 3) = sTextIfIsMissing
      End If
   End If
   '
   ' Return the list
   List = saListValues

End Function

Private Function GetValueForList(ByRef oPropObj As cPropertyObject, _
                                 ByVal eValueType As enListingTypeConstants, _
                                 Optional ByVal sTextIfIsMissing As String = "N/A") As String

   Select Case eValueType
      Case eltcListByKey
         GetValueForList = oPropObj.Key
      
      Case eltcListByItemData
         GetValueForList = CStr(oPropObj.ItemData)
      
      Case eltcListByItemTag
         GetValueForList = oPropObj.ItemTag
      
      Case eltcListByValue
         If Not IsObject(oPropObj.Value) Then
            GetValueForList = oPropObj.Value
         Else
            Err.Raise 13, CLASS_NAME & "::List", "Type mismatch. The List() function cannot build the list when Value represent an Object."
            Exit Function
         End If
      '
      ' eltcListByKey or any invalid value defaults to Key
      Case Else
         GetValueForList = sTextIfIsMissing
         
   End Select

End Function

'
' Implements a Clear method. This method is implemented because it can
' be too slow to use the Remove function on each element, so here we simply
' re-initialize the collection object we use for storage.
Public Sub Clear()
   Dim bCancel As Boolean
   RaiseEvent OnBeforeClear(bCancel)
   If Not bCancel Then
      RaiseEvent OnCleared
      Set my_oCol = New Collection
   End If
End Sub

'
' Removes the Item with ItemId if it exists
Public Sub Remove(ByVal ItemId As Variant)
   Dim bCancel As Boolean
   Dim cO As cPropertyObject
   
   If Exists(ItemId) Then
      Set cO = Item(ItemId)
      '
      ' Allow a potential event listener (eg. a GUI) to interact, ie.
      ' cancel the operation.
      RaiseEvent OnBeforeRemoveItem(cO, bCancel)
      If Not bCancel Then
         my_oCol.Remove ItemId
         RaiseEvent OnItemRemoved(cO)
      End If
   End If

   Set cO = Nothing

End Sub

'
' Implements support for "For ... Next" loops in cooperation
' with the Item property. See the "Remarks" section at the
' beginning of this module.
' ***DON'T*** change the declaration to Private or Friend.
Public Property Get NewEnum() As IEnumVARIANT
Attribute NewEnum.VB_UserMemId = -4
Attribute NewEnum.VB_MemberFlags = "40"
   Set NewEnum = my_oCol.[_NewEnum]
End Property

' *********************************************************************************************************************
' Implements simple QuickSort Sort algorithms for sorting *either* by Key, Value, ItemData *or* ItemTag.
' This function is NOT using the multi-level HeapSort as the cSortedFileList class (perhaps a TODO thing)
' *********************************************************************************************************************
'
' The Sort() function sorts all elements in the my_oCol Collection, but it could potentially
' be modified to sort only parts of the my_oCol Collection, for example a sub-collection
' extracted by GetByItemTag() or GetByItemData() functions.
Public Function Sort(Optional ByVal bDescending As Boolean, _
                     Optional ByVal eCompareMethod As VbCompareMethod = vbTextCompare, _
                     Optional ByVal eSortByProperty As enSortPropertyConstants = espcSortByKey) As Boolean

   Dim i As Long
   Dim bCancel As Boolean
   '
   ' Give a GUI listener the chance of cancelling the sort
   RaiseEvent OnSortingBegin(bCancel)
   If bCancel Then GoTo EndFunction
   '
   ' We can't directly sort a VBA Collection, so we turn the Collection
   ' into an Array, which we can dimension precisely using Base 1 to Count ...
   Dim vaObjArr() As cPropertyObject
   If my_oCol.Count = 0 Then GoTo EndFunction
   ReDim vaObjArr(1 To my_oCol.Count)

   Dim cP As cPerformanceTester
   Set cP = New cPerformanceTester
   cP.StartTimer
   
   If my_oCol.Count > 1 Then
      '
      ' Prepare the Array
      For i = 1 To my_oCol.Count
         Set vaObjArr(i) = New cPropertyObject
         Set vaObjArr(i) = my_oCol(i)
      Next
      '
      ' Sort the Array.
      If pQuickSort(vaObjArr, LBound(vaObjArr), UBound(vaObjArr), bDescending, eCompareMethod, eSortByProperty) Then
         '
         ' If sorting was successful we re-create our Collection with elements sorted
         ' according to the function parameters
         Set my_oCol = New Collection
         For i = LBound(vaObjArr) To UBound(vaObjArr)
            With vaObjArr(i)
               '
               ' We need to allow for Duplicate Keys, since we don't know how
               ' the elements originally got into the my_oCol Collection.
               Me.Add .Key, .Value, .ItemData, .ItemTag, True, .DataSource
            End With
         Next
         '
         ' Set return value
         Sort = True
      End If
   Else
      '
      ' Set return value
      Sort = True
   End If
   
   If Sort Then
      If my_oCol.Count > 1 Then
        ' DebugMsg CLASS_NAME & "::Sort: Sorted " & CStr(Me.Count) & " objects in " & cP.TickTime & " seconds.", dbgLogCheckPoint
      End If
   Else
      DebugMsg CLASS_NAME & "::Sort: Sorting failed for an unknown reason.", dbgLogWarning
   End If
   
EndFunction:
   '
   ' Clean the house
   Erase vaObjArr
   Set cP = Nothing
   '
   ' Let a GUI listener know that sorting ended and provide the result.
   RaiseEvent OnSortingDone(Sort)
   
End Function
'
' This function sorts the array vaInputArray directly, ie. its the original array that's sorted.
' vaInputArray must be an array of cPropertyObject class objects (though objects = Nothing are
' accepted.) The algorithm is based on the in-place version of Tony Hoare's QuickSort algoritm
' described at http://en.wikipedia.org/wiki/Quicksort.
Private Function pQuickSort(ByRef vaInputArray() As cPropertyObject, _
                            Optional ByVal lLowerBound As Long = -1&, _
                            Optional ByVal lUpperBound As Long = -1&, _
                            Optional ByVal bDescending As Boolean, _
                            Optional ByVal eCompareMethod As VbCompareMethod = vbTextCompare, _
                            Optional ByVal eSortByProperty As enSortPropertyConstants = espcSortByKey) As Boolean
   '
   ' The function considers an object that is Nothing to be less than any object of
   ' any type that is not Nothing.
   Dim oTemp As cPropertyObject
   Dim oBuffer As cPropertyObject
   Dim lLeft As Long
   Dim lRight As Long
   Dim lPivot As Long
   Dim lIdx As Long
   Dim peCompareMethod As VbCompareMethod
   '
   ' Level of recursion (the function is calling itself during sorting).
   Static lLevel As Long
   '
   ' Prevent sanaty checking on recursive calls. Checking should
   ' be sufficient at first level.
   lLevel = lLevel + 1
   If lLevel = 1 Then
      '
      ' Got something useful?
      If (Not IsArray(vaInputArray)) Then
         '
         ' Nope. No need to continue :-)
         lLevel = lLevel - 1
         Exit Function
      End If
      '
      ' Test lLowerBound and lUpperBound.
      ' If < 0 then set to LBound and UBound of vaInputArray.
      If lLowerBound < 0 Then
         lLowerBound = LBound(vaInputArray)
      End If
      If lUpperBound < 0 Then
         lUpperBound = UBound(vaInputArray)
      End If
      '
      ' We sort ONLY single dimensional arrays ...
      If pGetNumberOfArrayDimensions(vaInputArray) = 1 Then
         '
         ' Check that lLowerBound is valid
         Select Case lLowerBound
            Case Is < LBound(vaInputArray)
               lLevel = lLevel - 1
               Exit Function
            Case Is > UBound(vaInputArray)
               lLevel = lLevel - 1
               Exit Function
            Case Is > lUpperBound
               lLevel = lLevel - 1
               Exit Function
         End Select
         '
         ' Check that lUpperBound is valid
         Select Case lUpperBound
            Case Is > UBound(vaInputArray)
               lLevel = lLevel - 1
               Exit Function
            Case Is < LBound(vaInputArray)
               lLevel = lLevel - 1
               Exit Function
            Case Is < lLowerBound
               lLevel = lLevel - 1
               Exit Function
         End Select
         '
         ' If lUpperBound = lLowerBound, we have nothing to sort, so we bail ...
         If lUpperBound = lLowerBound Then
            pQuickSort = True
            lLevel = lLevel - 1
            Exit Function
         End If
            
      Else
         '
         ' We can't sort multi-dimensional arrays, so we bail ...
         lLevel = lLevel - 1
         Exit Function
      End If ' pGetNumberOfArrayDimensions(vaInputArray) = 1
   
   End If ' lLevel = 1
   '
   ' Ensure that eCompareMethod is either vbBinaryCompare or vbTextCompare. If it's neither, default to vbTextCompare.
   If (eCompareMethod = vbBinaryCompare) Or (eCompareMethod = vbTextCompare) Then
      peCompareMethod = eCompareMethod
   Else
      peCompareMethod = vbTextCompare
   End If
   '
   ' Here we begin sorting. To do that we need to set indices for
   ' lLeft <= lPivot <= lRight for the QuickSort algorithm.
   '
   ' lLeft is the index of the leftmost element of the array.
   ' lRight is the index of the rightmost element of the array.
   ' lPivot is the element to pick.
   lLeft = lLowerBound
   lRight = lUpperBound
   '
   ' lPivot should NOT be set to the leftmost element, since this would trigger a worst-case
   ' speed issue on already sorted arrays. Hence, we choose the median of the first, middle
   ' and last element of the partition for the pivot (as recommended by R. Sedgewick), see
   ' "Implementation issues" -> "Choice of pivot" at http://en.wikipedia.org/wiki/Quicksort
   ' for details :-)
   lPivot = (lLowerBound + lUpperBound) \ 2 ' Must be Integer division
   Set oTemp = vaInputArray(lPivot)
   '
   ' If the list has 2 or more items
   Do While (lLeft <= lRight)
      '
      ' Get lists of bigger and smaller items and final position of pivot
      Do While pQuickSortCompare(vaInputArray(lLeft), oTemp, peCompareMethod, eSortByProperty) < 0
         lLeft = lLeft + 1
         If lLeft = lUpperBound Then
            Exit Do
         End If
      Loop
      
      Do While pQuickSortCompare(oTemp, vaInputArray(lRight), peCompareMethod, eSortByProperty) < 0
         lRight = lRight - 1
         If lRight = lLowerBound Then
            Exit Do
         End If
      Loop
      '
      ' Swap the objects
      If (lLeft <= lRight) Then
         Set oBuffer = vaInputArray(lLeft)
         Set vaInputArray(lLeft) = vaInputArray(lRight)
         Set vaInputArray(lRight) = oBuffer
         lLeft = lLeft + 1
         lRight = lRight - 1
      End If
   Loop
   '
   ' Recursively sort elements smaller than the pivot
   If lLowerBound < lRight Then
      pQuickSort vaInputArray, lLowerBound, lRight, bDescending, peCompareMethod, eSortByProperty
   End If
   '
   ' Recursively sort elements at least as big as the pivot
   If lLeft < lUpperBound Then
      pQuickSort vaInputArray, lLeft, lUpperBound, bDescending, peCompareMethod, eSortByProperty
   End If
   '
   ' If bDescending is True, reverse the order of the array if lLevel is 1.
   If bDescending = True Then
      If lLevel = 1 Then
         pQuickSortReverseArray vaInputArray
      End If
   End If
   
   lLevel = lLevel - 1
   pQuickSort = True

End Function

'
' Get the number of dimensions of an array. An unallocated dynamic array
' has 0 dimensions.
Private Function pGetNumberOfArrayDimensions(Arr As Variant) As Integer
   
   Dim lIdx As Integer
   Dim lRes As Integer
   On Error Resume Next
   '
   ' Traverse the dimension index lIdx, until an error occurs.
   ' An error will occur when lIdx exceeds the number of dimensions
   ' in the array. Return lIdx - 1.
   Do
      lIdx = lIdx + 1
      lRes = UBound(Arr, lIdx)
   Loop Until Err.Number <> 0
   
   pGetNumberOfArrayDimensions = lIdx - 1

End Function

'
' This reverses the order of objects in an array of objects.
Private Function pQuickSortReverseArray(ByRef vaInputArray() As cPropertyObject) As Boolean

   Dim oTemp As cPropertyObject
   Dim lIdx As Long
   Dim lIdx2 As Long
   
   If (Not IsArray(vaInputArray)) Then
      Exit Function
   End If
   '
   ' Only an allocated 1-dimensional array is allowed.
   If Not pGetNumberOfArrayDimensions(vaInputArray) = 1 Then
      Exit Function
   End If
   '
   ' Set pivot element index
   lIdx2 = UBound(vaInputArray)
   '
   ' Traverse from LBound of vaInputArray to the midpoint of vaInputArray.
   For lIdx = LBound(vaInputArray) To ((UBound(vaInputArray) - LBound(vaInputArray) + 1) \ 2)
      '
      ' Swap the elements
      Set oTemp = vaInputArray(lIdx)
      Set vaInputArray(lIdx) = vaInputArray(lIdx2)
      Set vaInputArray(lIdx2) = oTemp
      '
      ' Decrement upper index
      lIdx2 = lIdx2 - 1
   Next
   
   pQuickSortReverseArray = True

End Function

'
' QuickSort Compare Method
Private Function pQuickSortCompare(ByRef Obj1 As cPropertyObject, _
                                   ByRef Obj2 As cPropertyObject, _
                                   Optional ByVal eCompareMethod As VbCompareMethod = vbTextCompare, _
                                   Optional ByVal eSortByProperty As enSortPropertyConstants = espcSortByKey) As Long

   ' Returns:
   '
   ' -1 if Obj1.Prop is less than Obj2.Prop
   '  0 if Obj1.Prop is equal to Obj2.Prop
   ' +1 if Obj1.Prop is greater than Obj2.Prop
   '
   ' as defined by the OBJECT1* constants
   '
   ' If both Obj1 and Obj2 are Nothing, then return 0 indicating they are equal.
   ' "Nothings" are always equal.
   If (Obj1 Is Nothing) And (Obj2 Is Nothing) Then
      pQuickSortCompare = OBJECT1_EQUALS_OBJECT2
      Exit Function
   End If
   '
   ' If Obj1 is NOT Nothing and Obj2 is Nothing, then return 1.
   ' Any object that is not Nothing is greater than any object that is Nothing.
   If (Not Obj1 Is Nothing) And (Obj2 Is Nothing) Then
      pQuickSortCompare = OBJECT1_GREATER_THAN_OBJECT2
      Exit Function
   End If
   '
   ' If Obj1 is Nothing and Obj2 is not Nothing, then return -1.
   ' Any object that is Nothing is less than any object that is not Nothing.
   If (Obj1 Is Nothing) And (Not Obj2 Is Nothing) Then
      pQuickSortCompare = OBJECT1_LESS_THAN_OBJECT2
      Exit Function
   End If
   '
   ' At this point, we know that both Obj1 and Obj2 are not Nothing.
   ' Hence, we can safely compare them by the chosen property.
   Select Case eSortByProperty
      
      Case espcSortByValue
         '
         ' If Value are NOT vbStrings
         If Obj1.DataType = vbString And Obj2.DataType = vbString Then
            pQuickSortCompare = StrComp(Obj1.Value, Obj2.Value, eCompareMethod)
         Else
            If Obj1.Value > Obj2.Value Then
               pQuickSortCompare = OBJECT1_GREATER_THAN_OBJECT2
            ElseIf Obj1.Value < Obj1.Value Then
               pQuickSortCompare = OBJECT1_LESS_THAN_OBJECT2
            End If
         End If
      '
      ' "Long" data type
      Case espcSortByItemData
         If Obj1.ItemData > Obj2.ItemData Then
            pQuickSortCompare = OBJECT1_GREATER_THAN_OBJECT2
         ElseIf Obj1.ItemData < Obj2.ItemData Then
            pQuickSortCompare = OBJECT1_LESS_THAN_OBJECT2
         End If
      '
      ' For "String" data types we use StrComp()
      Case espcSortByItemTag
         pQuickSortCompare = StrComp(Obj1.ItemTag, Obj2.ItemTag, eCompareMethod)
      '
      ' Sort by Key if none of the above properties are selected
      Case Else
         pQuickSortCompare = StrComp(Obj1.Key, Obj2.Key, eCompareMethod)
   
   End Select
   
End Function

Private Sub Class_Initialize()
   Set my_oCol = New Collection
   RaiseEvent OnCleared ' Hmmm ... doesn't fire in VBA during Class_Initialize ???
End Sub

Private Sub Class_Terminate()
   Set my_oCol = Nothing
End Sub
Attribute VB_Name = "cPropertyBagsCollection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'
' Purpose      :  Creates a collection class object with support for "For ... Next"
'                 loops and sets the "Item" property as default proc for the class.
'
'                 cPropertyBagsCollection is holding a collection of cPropertyObject
'                 Key/Value-objects, but can be used as a master template for
'                 other collection class objects. See Remarks for instructions.
'
' Dependencies :  cPropertyBag.cls
'                 cPropertyObject.cls
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  30. july 2010
' Last modified:  01. october 2010 / HPZ
'                 20. december 2010 /JAS  1) Optimized the function ReturnArrayDataSet_FilterRowsByTag()
'                                            for speed by implementing the bFirstMatchOnly flag for
'                                            use where only ONE return value is of interest.
'                 23. december 2010 /JAS  1) GetPropertyObjectFromPath() function implemented.
'
' Remarks      :  1) You can *NOT* copy the code in this class into a new class
'                    module and preserve support for "For ... Next" loops, because
'                    procedure attributes (such as VB_UserMemId and VB_MemberFlags)
'                    gets lost. To preserve these attributes you *MUST* do as follows:

'                    a) Export this class module to a new name.
'                    b) Open this new .cls file in NotePad2, PSPad or similar
'                    c) Search/replace any "cPropertyBagsCollection" name with a new name
'                       and save the .cls file
'                    d) Import the .cls file.
'
' TODO         :  1) Write a Replace function when need be. Currently we have to
'                    remove an item before we can add one with the same sKey again.
'
'                 2) We might need a QuickSort rutine so we can sort by Key, by Value,
'                    by ItemData, by ItemTag or by DataType for display purposes.
'
Const CLASS_NAME = "cPropertyBagsCollection"
'
' Private collection object for item storage
Private my_oCol As Collection
'
' Events fired
Public Event OnBeforeAddItem(ByRef oPropertyBag As cPropertyBag, ByRef bCancel As Boolean)
Public Event OnBeforeClear(ByRef bCancel As Boolean)
Public Event OnBeforeRemoveItem(ByRef oPropertyBag As cPropertyBag, ByRef bCancel As Boolean)
Public Event OnCleared()
Public Event OnItemAdded(ByRef oPropertyBag As cPropertyBag)
Public Event OnItemExisted(ByRef oPropertyBag As cPropertyBag)
Public Event OnItemRemoved(ByRef oPropertyBag As cPropertyBag)
'
' Validates that an Item with the specified ItemId exists
' in the collection.
Public Function Exists(ByVal ItemId As String) As Boolean
   Exists = (Not Item(ItemId) Is Nothing)
End Function
'
' Adds a new cPropertyBag item to the collection *if* it
' doesn't exist i advance. The ItemId is sKey, its value is
' vValue (Variant). Returns Nothing if the function fail.
Public Function Add(ByVal oPropertyBag As cPropertyBag, _
                    Optional ByVal sKey As String, _
                    Optional ByVal lItemData As Long, _
                    Optional ByVal sItemTag As String, _
                    Optional ByVal bAllowDuplicateKeys As Boolean = True _
                    ) As cPropertyBag
                    
' Extra optional lItemData and sItemTag properties are allowed eg.
' for pointer storage, but its useful for many purposes.
'
' NOTE: this function does not replace an item if sKey
' already exists in the collection.
                    
   Dim bCancel As Boolean
   '
   ' Create the object
   With oPropertyBag
      If LenB(sKey) <> 0 Then
         .Key = sKey
      End If
      If lItemData > -1 Then
         .ItemData = lItemData
      End If
      If LenB(sItemTag) <> 0 Then
         .ItemTag = sItemTag
      End If
      Set .Parent = Me
   End With
   '
   ' Allow a potential event listener (eg. a GUI) to interact, ie.
   ' make changes to oNew or cancel the operation.
   RaiseEvent OnBeforeAddItem(oPropertyBag, bCancel)
   If Not bCancel Then
      
      On Error Resume Next
      If bAllowDuplicateKeys Then
         my_oCol.Add oPropertyBag
      Else
         my_oCol.Add oPropertyBag, oPropertyBag.Key
      End If
      If Err.Number = 457 Then
         RaiseEvent OnItemExisted(oPropertyBag)
         Set Add = Nothing
      Else
         RaiseEvent OnItemAdded(oPropertyBag)
         Set Add = oPropertyBag
      End If
      On Error GoTo 0
   
   Else
      Set Add = Nothing
   End If

End Function

'
' Implements a Clear method. This method is implemented because it can
' be too slow use the Remove function on each element, so here we simply
' re-initialize the collection object we use for storage.
Public Sub Clear()
   Dim bCancel As Boolean
   RaiseEvent OnBeforeClear(bCancel)
   If Not bCancel Then
      RaiseEvent OnCleared
      Set my_oCol = New Collection
   End If
End Sub

'
' Return the number of Item members
Public Property Get Count() As Long
   If my_oCol Is Nothing Then
      Count = 0
   Else
      Count = my_oCol.Count
   End If
End Property

'
' Returns a cPropertyBagsCollection object holding all cPropertyBag Items
' with the specified ItemData property.
Public Function GetByItemData(ByVal lItemData As Long) As cPropertyBagsCollection

   Dim i As Long
   Dim cO As cPropertyBag
   Dim oBags As New cPropertyBagsCollection
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.ItemData = lItemData Then
         Call oBags.Add(cO)
      End If
   Next 'I
     
   Set GetByItemData = oBags
   
   Set cO = Nothing

End Function

'
' Returns a cPropertyBagsCollection object holding all cPropertyBag Items
' with the specified ItemKey property.
Public Function GetByItemKey(ByVal sItemKey As String) As cPropertyBagsCollection

   Dim i As Long
   Dim cO As cPropertyBag
   Dim oBags As New cPropertyBagsCollection
   Dim bUseWildCard As Boolean
   '
   ' 19/03-2015 /JAS
   ' Remove case sensitivity
   sItemKey = LCase$(sItemKey)
   
'<JAS 19/03-2015: Rev 626, Added support for advanced WildCards>
   bUseWildCard = (InStr(1, sItemKey, "*", vbTextCompare) <> 0) Or (InStr(1, sItemKey, "?", vbTextCompare) <> 0)
   If bUseWildCard Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If IsMatchingSearchMask(cO.Key, sItemKey) Then
            Call oBags.Add(cO)
         End If
      Next 'I
'</JAS 19/03-2015>
   Else
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If LCase$(cO.Key) = sItemKey Then
            Call oBags.Add(cO)
         End If
      Next 'I
   End If
   
   Set GetByItemKey = oBags
   
   Set cO = Nothing

End Function

'
' Returns a cPropertyBagsCollection object holding all cPropertyBag Items
' with the specified ItemKey property.
Public Function GetByItemKeyEx(ByVal sItemKey As String, Optional ByVal saColumnNames As Variant) As cPropertyBagsCollection

   Dim i As Long
   Dim J As Long
   Dim bFound As Boolean
   Dim cO As cPropertyBag
   Dim oBags As New cPropertyBagsCollection
   Dim bUseWildCard As Boolean
   Dim saFilter() As String
   Dim sFilterKey As String
   Dim sFilterValue As String
   '
   ' 19/03-2015 /JAS
   ' Remove case sensitivity
   sItemKey = LCase$(sItemKey)
   
'<JAS 19/03-2015: Rev 626, Added support for advanced WildCards>
   bUseWildCard = (InStr(1, sItemKey, "*", vbTextCompare) <> 0) Or (InStr(1, sItemKey, "?", vbTextCompare) <> 0)
   If bUseWildCard Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If IsMatchingSearchMask(cO.Key, sItemKey) Then
            If IsMissing(saColumnNames) Then
               Call oBags.Add(cO)
            Else
               If IsArray(saColumnNames) Then
                  bFound = True ' Assume True
                  For J = LBound(saColumnNames) To UBound(saColumnNames)
                     If Not cO.Exists(saColumnNames(J)) Then
                        bFound = False
                        Exit For
                     End If
                  Next
                  If bFound Then
                     Call oBags.Add(cO)
                  End If
               ElseIf TypeName(saColumnNames) = "String" Then
                  If cO.Exists(saColumnNames) Then
                     Call oBags.Add(cO)
                  End If
               Else
                  ' Filter specified, but no match was found
               End If
            End If
         End If
      Next 'I
'</JAS 19/03-2015>
   Else
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If LCase$(cO.Key) = sItemKey Then
            If IsMissing(saColumnNames) Then
               Call oBags.Add(cO)
            Else
               If IsArray(saColumnNames) Then
                  ' JAS TODO: Fix this test-code for Arrays. Conceptually wrong. Missing value to measure on.
                  bFound = True ' Assume True
                  For J = LBound(saColumnNames) To UBound(saColumnNames)
                     If Not cO.Exists(saColumnNames(J)) Then
                        bFound = False
                        Exit For
                     End If
                  Next
                  If bFound Then
                     Call oBags.Add(cO)
                  End If
               ElseIf TypeName(saColumnNames) = "String" Then
                  saFilter = VBA.Split(saColumnNames, ":", , vbTextCompare)
                  sFilterKey = saFilter(0)
                  sFilterValue = saFilter(1)
                  If cO.Exists(sFilterKey) Then
                     If cO(sFilterKey).Value = sFilterValue Then
                        Call oBags.Add(cO)
                     End If
                  End If
               Else
                  ' Filter specified, but no match was found
               End If
            End If
         End If
      Next 'I
   End If
   
   Set GetByItemKeyEx = oBags
   
   Set cO = Nothing

End Function
'
' Returns a cPropertyBagsCollection object holding all cPropertyBag Items
' with the specified ItemTag property.
Public Function GetByItemTag(ByVal sItemTag As String) As cPropertyBagsCollection

   Dim i As Long
   Dim cO As cPropertyBag
   Dim oBags As New cPropertyBagsCollection
   Dim bUseWildCard As Boolean
   '
   ' 19/03-2015 /JAS
   ' Remove case sensitivity
   sItemTag = LCase$(sItemTag)
   
'<JAS 19/03-2015: Rev 626, Added support for advanced WildCards>
   bUseWildCard = (InStr(1, sItemTag, "*", vbTextCompare) <> 0) Or (InStr(1, sItemTag, "?", vbTextCompare) <> 0)
   If bUseWildCard Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If IsMatchingSearchMask(cO.ItemTag, sItemTag) Then
            Call oBags.Add(cO)
         End If
      Next 'I
'</JAS 19/03-2015>
   Else
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If LCase$(cO.ItemTag) = sItemTag Then
            Call oBags.Add(cO)
         End If
      Next 'I
   End If
   
   Set GetByItemTag = oBags
   
   Set cO = Nothing

End Function

Public Function Import(ByRef oSource As cPropertyBagsCollection, _
                       Optional bAllowDuplicateKeys As Boolean = True) As Long

   Dim i As Long

   If Not oSource Is Nothing Then
      For i = 1 To oSource.Count
         Add oSource(i), , , , bAllowDuplicateKeys
      Next
      Import = oSource.Count
   Else
      Err.Raise 91, CLASS_NAME & "::Import", "Nothing to Import. The source object to import from is not initialized."
   End If
   
End Function


Public Function GetByItemTagFirst(ByVal sItemTag As String) As cPropertyBag

   Dim i As Long
   Dim cO As cPropertyBag
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.ItemTag = sItemTag Then
         Set GetByItemTagFirst = cO
         Exit For
      End If
   Next 'I
   Set cO = Nothing

End Function

'
' Returns the Index in our collection for the specified sKey.
Public Property Get IndexForKey(ByVal sKey As String) As Long
   Dim i As Long
   Dim cO As cPropertyBag
   
   For i = 1 To my_oCol.Count
      Set cO = my_oCol(i)
      If cO.Key = sKey Then
         IndexForKey = i
         Exit For
      End If
   Next 'I
   
   Set cO = Nothing
End Property

'
' Returns the Item with ItemId (representing either Key or Index)
' The Item property is the default property of this class.
Public Property Get Item(ByVal ItemId As Variant) As cPropertyBag
Attribute Item.VB_UserMemId = 0
   Dim i As Long
   Dim cO As cPropertyBag
   
   On Error Resume Next
   If Not IsNumeric(ItemId) Then
      For i = 1 To my_oCol.Count
         Set cO = my_oCol(i)
         If cO.Key = ItemId Then
            Exit For
         End If
      Next 'I
   Else
      i = CLng(ItemId)
   End If
   Set Item = my_oCol(i)
   
   Err.Clear
   Set cO = Nothing
End Property

'
' Removes the Item with ItemId if it exists
Public Sub Remove(ByVal ItemId As Variant)
   Dim bCancel As Boolean
   Dim cO As cPropertyBag
   
   If Exists(ItemId) Then
      Set cO = Item(ItemId)
      '
      ' Allow a potential event listener (eg. a GUI) to interact, ie.
      ' cancel the operation.
      RaiseEvent OnBeforeRemoveItem(cO, bCancel)
      If Not bCancel Then
         my_oCol.Remove ItemId
         RaiseEvent OnItemRemoved(cO)
      End If
   End If

   Set cO = Nothing

End Sub

'
' Implements support for "For ... Next" loops in cooperation
' with the Item property. See the "Remarks" section at the
' beginning of this module.
' ***DON'T*** change the declaration to Private or Friend.
Public Property Get NewEnum() As IEnumVARIANT
Attribute NewEnum.VB_UserMemId = -4
Attribute NewEnum.VB_MemberFlags = "40"
   Set NewEnum = my_oCol.[_NewEnum]
End Property

Private Sub Class_Initialize()
   Set my_oCol = New Collection
End Sub

Private Sub Class_Terminate()
   Set my_oCol = Nothing
End Sub

'
' Return Array of PropertyObject.value from PropertyBag collection filtered by PropertyBagTag
'Function ReturnArrayDataSet_FilterRowsByTag(sPropertyBagTag As String, _
'                                            sPropertyObjectName As String, _
'                                            Optional sPropertyObjectFilterValue As String, _
'                                            Optional sPropertyObjectFilterName As String, _
'                                            Optional bFirstMatchOnly As Boolean = False) As String()
'
'   'sPropertyBagTag = en kolonne der filtereres p|fffd|
'   'sPropertyObjectName = kolonnenavn der returneres
'   'sPropertyObjectFilterValue = v|fffd|rdi der skal v|fffd|re i sPropertyObjectName for at den returneres
'   'sPropertyObjectFilterName = kolonnenavn, hvor sPropertyObjectFilterValue skal v|fffd|re for at sPropertyObjectName returneres
'
'   Dim sTempName As String
'   Dim bFound As Boolean
'
'   Dim oPropertyBag As cPropertyBag
'   Dim oPropertyObject As cPropertyObject
'   Dim oPropertyObjectFilter As cPropertyObject
'
'   'find all oPropertyBags that match
'   Dim oPropertyBagCollection As cPropertyBagsCollection
'   Set oPropertyBagCollection = GetByItemTag(sPropertyBagTag)
'
'   Dim I As Integer
'   Dim sResult()  As String
'
'   'Return all values from all PropertyObjects in PropertyBag where oPropertyObject.key = sPropertyObjectName
'   If LenB(sPropertyObjectFilterValue) = 0 And LenB(sPropertyObjectFilterName) = 0 Then
'
'      sTempName = LCase$(sPropertyObjectName)  ' Don't LCase$() more than once
'
'      For Each oPropertyBag In oPropertyBagCollection
'         For Each oPropertyObject In oPropertyBag.Items
'            If LCase$(oPropertyObject.ItemTag) = sTempName Then
'               AddStringToStringArray sResult, oPropertyObject.Value
'               If bFirstMatchOnly Then
'                  bFound = True
'                  Exit For
'               End If
'            End If
'         Next
'         If bFound Then Exit For
'      Next
'
'   'If both filter value or filter node name are provided we need to be able to iterate through the parent node
'   ElseIf LenB(sPropertyObjectFilterValue) <> 0 And LenB(sPropertyObjectFilterName) <> 0 Then
'
'      sTempName = LCase$(sPropertyObjectFilterValue)  ' Don't LCase$() more than once
'
'      For Each oPropertyBag In oPropertyBagCollection
'         If LCase$(oPropertyBag.GetByItemTag(sPropertyObjectFilterName).Item(1).Value) = sTempName Then
'            AddStringToStringArray sResult, oPropertyBag.GetByItemTag(sPropertyObjectName).Item(1).Value
'            If bFirstMatchOnly Then
'               Exit For
'            End If
'         End If
'      Next
'   End If
'
'   ReturnArrayDataSet_FilterRowsByTag = sResult
'
'End Function

'
' Return PropertyObject.Value from first occurence of PropertyBag in collection with given tag
Function ReturnValue_FilterRowsByTag(sPropertyBagTag As String, sPropertyObjectName As String) As String
    
   'sPropertyBagTag = en kolonne der filtereres p|fffd|
   'sPropertyObjectName = kolonnenavn
   
   Dim oPropertyBag As cPropertyBag
   Dim oPropertyObject As cPropertyObject
   
   Set oPropertyBag = GetByItemTagFirst(sPropertyBagTag)
     
   Dim sResult  As String
   
   On Error Resume Next
   
   Set oPropertyObject = oPropertyBag.Item(sPropertyObjectName)
   If Not oPropertyObject Is Nothing Then
      sResult = oPropertyObject.Value
   End If
   
   If LenB(sResult) = 0 Then
      Err.Clear
      Set oPropertyBag = oPropertyBag.GetByItemTag(sPropertyObjectName)
      If Not oPropertyBag Is Nothing Then
         sResult = oPropertyBag.Item(1).Value
      End If
   End If
   
   ReturnValue_FilterRowsByTag = sResult

End Function

'
' Return a reference to the first PropertyObject from the PropertyBag
Function GetPropertyObjectFromPath(ByRef sPropertyPath As String, sPropertyName As String) As cPropertyObject
    
   ' sPropertyBagTag = en kolonne der filtereres p|fffd|
   ' sPropertyObjectName = kolonnenavn
   
   Dim oPropertyBag As cPropertyBag
             
   On Error Resume Next
   Set oPropertyBag = GetByItemTagFirst(sPropertyPath)
   
   Set GetPropertyObjectFromPath = oPropertyBag.GetFirstItemByItemTag(sPropertyName)

End Function

Attribute VB_Name = "cPropertyObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Binary
'
' Purpose      :  Creates a private Key/Value object for holding most
'                 properties we can think of.
'
' Dependencies :  cPropertyBag.cls
'                 cPropertyBagsCollection.cls
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  25. may 2010
' Modified     :  25. april 2014 /JAS
'
Private Const CLASS_NAME = "cPropertyObject"
'
' Holding properties
Private my_sKey As String
Attribute my_sKey.VB_VarHelpID = 662
Private my_vValue As Variant
Attribute my_vValue.VB_VarHelpID = 660
Private my_lItemData As Long
Private my_sItemTag As String
Private my_vDataSource As Object

Public Parent As cPropertyBag
Attribute Parent.VB_VarHelpID = 652
'

Public Property Let Key(ByVal sNewKey As String)
   my_sKey = sNewKey
End Property
Public Property Get Key() As String
   Key = my_sKey
End Property

Public Property Get Name() As String
   Name = my_sKey
End Property

Public Property Let Index(ByVal lNewIndex As Long)
   Err.Raise 383, CLASS_NAME & "::Index (Property Let)", "The Index property is Read-Only."
End Property
Public Property Get Index() As Long
   If Not Parent Is Nothing Then
      Index = Parent.IndexForKey(my_sKey)
   Else
      Index = 0
   End If
End Property

Public Property Let ItemData(ByVal lNewItemData As Long)
   my_lItemData = lNewItemData
End Property
Public Property Get ItemData() As Long
   ItemData = my_lItemData
End Property

Public Property Let ItemTag(ByVal sNewItemTag As String)
   my_sItemTag = sNewItemTag
End Property
Public Property Get ItemTag() As String
   ItemTag = my_sItemTag
End Property

Public Property Let Value(ByVal vNewValue As Variant)
   my_vValue = vNewValue
End Property
Public Property Get Value() As Variant
Attribute Value.VB_HelpID = 649
   Value = my_vValue
End Property

Public Property Set DataSource(ByVal vNewDataSource As Object)
    Set my_vDataSource = vNewDataSource
End Property
Public Property Get DataSource() As Object
    Set DataSource = my_vDataSource
End Property

Public Property Get IsArray() As Boolean
   IsArray = ((VarType(my_vValue) And vbArray) = vbArray)
End Property

Public Property Get DataType() As VbVarType
   
   Dim eVarType As VbVarType
   
   eVarType = VarType(my_vValue)
   
   If IsArray Then
      eVarType = eVarType - vbArray
   End If
   
   DataType = eVarType

End Property

Public Property Get DataTypeName() As String
   
   Dim sName As String
   Dim sExtraName As String
   Dim eVarType As VbVarType
   
   eVarType = VarType(my_vValue)

   If IsArray Then
      sExtraName = "vbArray"
      eVarType = eVarType - vbArray
   End If

   Select Case eVarType
      Case vbBoolean
         sName = "vbBoolean"
      Case vbByte
         sName = "vbByte"
      Case vbCurrency
         sName = "vbCurrency"
      Case vbDataObject
         sName = "vbDataObject"
      Case vbDate
         sName = "vbDate"
      Case vbDecimal
         sName = "vbDecimal"
      Case vbDouble
         sName = "vbDouble"
      Case vbEmpty
         sName = "vbEmpty"
      Case vbError
         sName = "vbError"
      Case vbInteger
         sName = "vbInteger"
      Case vbLong
         sName = "vbLong"
      Case vbNull
         sName = "vbNull"
      Case vbObject
         sName = "vbObject"
      Case vbSingle
         sName = "vbSingle"
      Case vbString
         sName = "vbString"
      Case vbUserDefinedType
         sName = "vbUserDefinedType"
      Case vbVariant
         sName = "vbVariant"
      Case Else
         If Len(sName) = 0 Then sName = "Unknown"
   
   End Select
   
   If Len(sExtraName) > 0 Then
      DataTypeName = sExtraName & " (" & sName & ")"
   Else
      DataTypeName = sName
   End If
   
End Property

Attribute VB_Name = "mCore_2007AddOns"
Sub RibbonXOnAction(ctl As IRibbonControl)
    Application.Run ctl.Tag
End Sub


Sub FunctionDelegator(ByVal sFunction As String)
   Dim arrTemp() As String
   
   If Len(sFunction) > 0 Then
      arrTemp = Split(sFunction, ";")
      
      Select Case UBound(arrTemp)
         Case 0
            Application.Run arrTemp(0)
         Case 1
            Application.Run arrTemp(0), arrTemp(1)
         Case Else
            Exit Sub
      End Select
   End If
   
End Sub
Sub InsertAutoText(ctl As IRibbonControl)
   'Denne funktion inds|fffd|tter en autotext fra (i n|fffd|vnte r|fffd|kkef|fffd|lge):
   '1. det aktive dokuments underliggende skabelon
   '2. common.dotm
   '3. common.dot
    
   Dim strAutoTextName As String
   Dim sLastColorCommand As String
   
   strAutoTextName = ctl.Tag
   
   Application.ScreenUpdating = False
   
   Dim strStartupPath As String
   strStartupPath = Application.Options.DefaultFilePath(wdStartupPath) & "\"
   
   If strStartupPath = "" Then
       Exit Sub
   End If
    
   On Error GoTo InsertAutotextFra2007
   Application.Templates(ThisDocument.AttachedTemplate.FullName).BuildingBlockEntries(strAutoTextName).Insert Where:=Selection.Range, RichText:=True
   GoTo ApplyLastColor
    
InsertAutotextFra2007:
   On Error GoTo InsertAutotextFra2003
   Application.Templates(strStartupPath & "AddOns.dotm").BuildingBlockEntries(strAutoTextName).Insert Where:=Selection.Range, RichText:=True
   GoTo ApplyLastColor

InsertAutotextFra2003:
   On Error GoTo errorhandler
   Application.Templates(strStartupPath & "Common.dot").BuildingBlockEntries(strAutoTextName).Insert Where:=Selection.Range, RichText:=True
   GoTo ApplyLastColor
   
ApplyLastColor:
   '
   ' If a non-default color choice was applied to the document we need to reapply it,
   ' since the AutoTextEntry may not have correct colors.
   If DocumentPropertyExists("LastColorCommand", eplcDocPropCustom, ActiveDocument) Then
      sLastColorCommand = GetDocumentProperty("LastColorCommand", eplcDocPropCustom, ActiveDocument)
      If LenB(sLastColorCommand) <> 0 Then
         On Error Resume Next
         Application.Run sLastColorCommand
         On Error GoTo 0
      End If
   End If
    
   Application.ScreenUpdating = True
   Exit Sub
   
errorhandler:
   Resume Next
   
End Sub
Attribute VB_Name = "mCore_Arrays"
Option Explicit
Option Compare Binary
'
'Purpose       :  Array helper functions
'
'Dependencies  :  None
'
'Public        :  ArrayIsEmpty()             ' Validates whether or not an array contain data
'
'Created by    :  HPZ
'Creation date :  27/10-2010
'Modified      :  28/10-2010 NRV
'Modified      :  25. novebmer 2010  /JAS    1) ArrayIsEmpty() function added. Should generally supersede
'                                               the IsBound() function, which is useless in many cases.
'                                            2) Redundant debugging messages commented out.
'
'TODO          :
'
'
'Module name for debugging
Private Const MODULE_NAME As String = "mArrays"

Private sErrorString As String

'
' This function validates whether or not an array contain data.
' Supports most array types that VBA can handle, incl. variant
' arrays and arrays holding UDT's (User Defined Types)
'
' Sample use:
'
'  If Not ArrayIsEmpty(MyArray) Then
'     Dim I as long
'     For I = LBound(MyArray) To UBound(MyArray)
'        ' Do something
'     Next
'  Else
'     ' Array is empty
'  End if
Public Function ArrayIsEmpty(ByRef vArrayToCheck As Variant) As Boolean
   Dim i As Long
   On Error Resume Next
   i = LBound(vArrayToCheck, 1)
   ArrayIsEmpty = (Err.Number <> 0)
   Err = 0
End Function


Public Function IsBound(sArray() As String) As Boolean
'sErrorString = MODULE_NAME & " :: " & "IsBound"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---

    On Error GoTo errorhandler
    IsBound = -1

    If UpperBoundStringArray(sArray) = -1 Then
        IsBound = False
    End If

    Exit Function
errorhandler:
    IsBound = False
    
'--- code  end  ---
End Function

Public Function IsBoundVariant(sArray() As Variant) As Boolean
'sErrorString = MODULE_NAME & " :: " & "IsBound"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---

    On Error GoTo errorhandler
    IsBoundVariant = -1

    If UpperBoundVariantArray(sArray) = -1 Then
        IsBoundVariant = False
    End If

    Exit Function
errorhandler:
    IsBoundVariant = False
    
'--- code  end  ---
End Function


Public Function UpperBoundStringArray(sArray() As String) As Integer
'sErrorString = MODULE_NAME & " :: " & "UpperBoundStringArray"
'DebugMsg sErrorString, dbgLogCheckPoint
On Error GoTo errorhandler
'--- code start ---
    
    UpperBoundStringArray = -1
    UpperBoundStringArray = UBound(sArray)
errorhandler:
    
'--- code  end  ---
End Function

Public Function UpperBoundVariantArray(sArray() As Variant) As Integer
'sErrorString = MODULE_NAME & " :: " & "UpperBoundStringArray"
'DebugMsg sErrorString, dbgLogCheckPoint
On Error GoTo errorhandler
'--- code start ---
    
    UpperBoundVariantArray = -1
    UpperBoundVariantArray = UBound(sArray)
errorhandler:
    
'--- code  end  ---
End Function

Public Sub AddStringToStringArray(ByRef sArray() As String, ByRef sStr As String)
'sErrorString = MODULE_NAME & " :: " & "AddToStringArray"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---

    Dim i As Integer
    If IsBound(sArray) Then
        i = UBound(sArray) + 1
    Else
        i = 0
    End If

    ReDim Preserve sArray(i)
    sArray(i) = sStr

'--- code  end  ---
End Sub

Public Sub AddStringArrayToStringArray(ByRef sMainArray() As String, ByRef sExtraArray() As String)
'sErrorString = MODULE_NAME & " :: " & "AddToStringArray"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---

    Dim i As Integer
    Dim J As Integer
    
    If IsBound(sMainArray) Then
        i = UBound(sMainArray) + 1
    Else
        i = 0
    End If

    If IsBound(sExtraArray) Then
        J = UBound(sExtraArray)
    Else
        J = -1
    End If
    
    If J > -1 And i + J >= 0 Then
    
        ReDim Preserve sMainArray(i + J)
        
        Dim k As Integer
        For k = i To J + i
            sMainArray(k) = sExtraArray(k - i)
        Next k
                
    End If
    
'--- code  end  ---
End Sub

Public Function StringArrayToString(ByRef asArray() As String) As String
'sErrorString = MODULE_NAME & " :: " & "AddToStringArray"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---
    
    If IsBound(asArray) Then
            
        Dim i As Integer
        
        For i = 0 To UBound(asArray)
            StringArrayToString = StringArrayToString & vbNewLine & i & ": " & asArray(i)
        Next i
    
    Else
        StringArrayToString = ""
    End If
    
'--- code  end  ---
End Function

Public Sub ClearStringArray(ByRef asArray() As String)
'sErrorString = MODULE_NAME & " :: " & "ClearStringArray"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---
    
    Dim newArray() As String
    asArray = newArray
    
'--- code  end  ---
End Sub
Attribute VB_Name = "mCore_Auto"
Sub AutoNew()
   
   Dim sMissingFonts As String
   If HasMissingFonts(ActiveDocument, sMissingFonts) Then
      '
      ' Display the missing fonts list
      VBA.MsgBox GetLanguageString("MissingFontsMessage", "You should install the following missing fonts before you work with this document:") & vbCr & _
                 Replace(sMissingFonts, "|", vbCr & "- "), vbInformation + vbOKOnly, _
                 GetLanguageString("MissingFontsTitle", "Missing fonts")
                 
   End If
   
   If ActiveDocument.Bookmarks.Exists("start") Then
      ActiveDocument.Bookmarks("start").Range.Select
   End If

End Sub

Sub AutoOpen()
   
   Dim sMissingFonts As String
   If HasMissingFonts(ActiveDocument, sMissingFonts) Then
      '
      ' Display the missing fonts list
      VBA.MsgBox GetLanguageString("MissingFontsMessage", "You should install the following missing fonts before you work with this document:") & vbCr & _
                 Replace(sMissingFonts, "|", vbCr & "- "), vbInformation + vbOKOnly, _
                 GetLanguageString("MissingFontsTitle", "Missing fonts")
                 
   End If
   
   If ActiveDocument.Bookmarks.Exists("start") Then
      ActiveDocument.Bookmarks("start").Range.Select
   End If
End Sub



Attribute VB_Name = "mCore_Code"

Option Explicit
Option Private Module
Option Compare Text
'
#If Win32 Or SIMULATE_MAC = 1 Then
   '
   ' For Windows and "WE MacIntosh Mode" on Windows
   Public Const WE_PATH_SEPARATOR As String = "\"
#Else
   '
   ' Specificly for the MacIntosh environment
   Public Const WE_PATH_SEPARATOR As String = ":"
#End If

Sub InsertPageColumns(ctl As IRibbonControl)
   '
   Dim lNumColumns As Long
   Dim oDoc As Document
   Dim lSecCount As Long
   Dim lSecStart As Long
   Dim lCounter As Long
   
   On Error GoTo ErrHandler
   
   lSecCount = Selection.Information(wdActiveEndSectionNumber)
   lNumColumns = CLng(ctl.Tag)
   
      If Not ActiveDocument.Sections(lSecCount).PageSetup.TextColumns.Count = lNumColumns Then
         Dim oRange As Range
         Set oRange = Selection.Range
         ActiveDocument.Sections.Add Range:=oRange, Start:=wdSectionBreakNextPage
         
         Set oRange = ActiveDocument.Sections(lSecCount + 1).Range
         
         oRange.PageSetup.TextColumns.SetCount lNumColumns
         
         If lNumColumns <> 1 Then
            oRange.PageSetup.TextColumns.Spacing = CentimetersToPoints(0.5)
         End If
         oRange.Collapse (wdCollapseStart)
         Selection.Move wdParagraph, 1
      End If
   
   Exit Sub

ErrHandler:
   Debug.Print Err.Number & "; " & Err.Description
   
End Sub

'
' Local version of FillVariables()
Public Function FillVariables(ByVal sStringToFill As String) As String
   
   FillVariables = sStringToFill
End Function

'
' Local version of FillVariables
Public Function GetActiveDocument() As Document
   
   Dim i As Long
   Dim J As Long
   Dim sDocName As String
   Dim bFound As Boolean
   '
   ' This function can be used where a document object
   ' is required and ActiveDocument isn't initialized,
   ' for example when a document is opened from ProtectedView.
   On Error Resume Next
   Set GetActiveDocument = ActiveDocument
   '
   ' did we get error 4248, "This command is not available because no document is open."
   If Err.Number = 4248 Then
      '
      ' In 2010 we can refer to the document via the new ProtectedViewWindows
      ' collection and then fetch the Document object from the Documents collection.
      ' The code below is not entirely correct (if more than one protected document is open),
      ' but it does catch the *first* protected document in the Documents collection.
#If VBA7 Then
      If ProtectedViewWindows.Count <> 0 Then
         For i = 1 To ProtectedViewWindows.Count
            sDocName = ProtectedViewWindows(i).SourceName
            For J = 1 To Documents.Count
               If Documents(J).Name = sDocName Then
                  Set GetActiveDocument = Documents(J)
                  bFound = True
                  Exit For
               End If
            Next ' J = 1 To Documents.Count
            If bFound Then Exit For
         Next ' I = 1 To ProtectedViewWindows.Count
      End If
#Else
      '
      ' 2007 may also open documents in Protected View, but in this
      ' case we can't currently do anything reasonable when
      ' ActiveDocument isn't initialized.
      Set GetActiveDocument = Nothing
#End If

   End If
   
End Function



Public Function ReturnTwoDigitNumber(iNumber) As String

    ReturnTwoDigitNumber = String(2 - Len(CStr(iNumber)), "0") & iNumber

End Function

Function CurrentSectionCount() As Integer

   CurrentSectionCount = ActiveDocument.Range(0, Selection.Sections(1).Range.End).Sections.Count
   
End Function

Public Sub DeleteSectionContentBack()

  ' Removes the section containing the insertion point by folding it into the preceding section,
  ' rather than into the next section, which is what Word does by default.  This also makes it
  ' possible to delete the last section.

  Dim SectionNumber As Long
  Dim WorkingRange  As Word.Range
  Dim sec As Section
  ' Only run if there is nothing selected (to avoid section ambiguity), and the insertion point is in
  ' the body of the document, and there are multiple sections, and we're not in the first section.

  'If Selection.Type <> wdSelectionIP Then Exit Sub
  If Selection.StoryType <> wdMainTextStory Then Exit Sub
  If ActiveDocument.Sections.Count = 1 Then Exit Sub
  Dim rngTemp1 As Range
  Dim rngTemp2 As Range
  Set rngTemp1 = Selection.Range
  Set rngTemp2 = Selection.Range
  rngTemp1.SetRange rngTemp1.Start, rngTemp1.Start
  rngTemp2.SetRange rngTemp2.End, rngTemp2.End
  If rngTemp1.Information(wdActiveEndSectionNumber) <> rngTemp2.Information(wdActiveEndSectionNumber) Then Exit Sub
  
  SectionNumber = Selection.Information(wdActiveEndSectionNumber)
  
  If SectionNumber = 1 Then Exit Sub
  
  ' Copy the contents of the section being deleted.  If not the last section, adjust the range end
  ' to exclude the section's trailing character 12.
  
  Set WorkingRange = ActiveDocument.Sections(SectionNumber).Range
'  For x = SectionNumber + 1 To ActiveDocument.Sections.Count Step 1
'   Set sec = ActiveDocument.Sections(x)
'   If sec.PageSetup.SectionStart = wdSectionNewPage Then
'        WorkingRange.SetRange WorkingRange.Start, sec.Range.Start
'        Debug.Print sec.PageSetup.SectionStart
'        Exit For
'    End If
'  Next
  If SectionNumber < ActiveDocument.Sections.Count Then
    Call WorkingRange.MoveEnd(wdCharacter, -1)
  End If
  Dim testRng As Range
  Set testRng = WorkingRange
'  If Trim(testRng) <> Chr(13) & Chr(13) & Chr(13) & Chr(13) Then
'    Call WorkingRange.Copy
'    Dim bmkCopied As Bookmark
'    For Each bmkCopied In WorkingRange.Bookmarks
'      bmkCopied.Delete
'    Next
'  End If
  
  If SectionNumber > 1 Then
      
  End If
  Set WorkingRange = Nothing
  
  ' Paste the copied contents into the previous section at the section's end.
  
  Set WorkingRange = ActiveDocument.Sections(SectionNumber - 1).Range
  
  Call WorkingRange.EndOf(wdSection, wdMove)
'  Dim rngSel As Range
'  Set rngSel = WorkingRange
'  rngSel.Move Unit:=wdCharacter, Count:=1
  
'  If Trim(testRng) <> Chr(13) & Chr(13) & Chr(13) & Chr(13) Then
'    Call WorkingRange.Paste
 ' End If
  
 
  Set WorkingRange = Nothing
  
  ' Delete the original section.  If deleting the last section, adjust the range start to include
  ' the preceding section's trailing character 12.
  
  Set WorkingRange = ActiveDocument.Sections(SectionNumber).Range
  
  If SectionNumber = ActiveDocument.Sections.Count Then
    WorkingRange.Select
    WorkingRange.Text = ""
    Call WorkingRange.MoveStart(wdCharacter, -1)
  
    ' Unique last section headers and footers aren't replaced by those in the prior section like
    ' other section characteristics (e.g., orientation, paper size, borders) when the last section is
    ' programmatically "deleted".  One way to resolve this is to first void the uniqueness of the last
    ' section's headers and footers by linking them with the prior section's headers and footers.  This
    ' causes the last section's header/footer content to reflect the prior section's header/footer content.
    ' If the prior section's headers and footers are also derived from the section that precedes it (in
    ' other words, it too is linked to its predecessor), then we're done.  However, if the section prior
    ' to the last one is not linked to its predecessor, then the last section, whose headers/footers will
    ' be folded back over the previous section's content, must be unlinked in order to preserve the content
    ' it just adopted from its predecessor when it was (temporarily) linked with it.  The code below does
    ' this for the simplest case where the last section and its predecessor do not incorporate unique
    ' odd/even and/or first page headers and footers.  Much more work would be required to handle all the
    ' possible header and footer combinations in a general way.
  
    ActiveDocument.Sections(SectionNumber).Headers(wdHeaderFooterPrimary).LinkToPrevious = True
    If Not ActiveDocument.Sections(SectionNumber - 1).Headers(wdHeaderFooterPrimary).LinkToPrevious Then
      ActiveDocument.Sections(SectionNumber).Headers(wdHeaderFooterPrimary).LinkToPrevious = False
    End If
    
    ActiveDocument.Sections(SectionNumber).Footers(wdHeaderFooterPrimary).LinkToPrevious = True
    If Not ActiveDocument.Sections(SectionNumber - 1).Footers(wdHeaderFooterPrimary).LinkToPrevious Then
      ActiveDocument.Sections(SectionNumber).Footers(wdHeaderFooterPrimary).LinkToPrevious = False
    End If
    
  End If
  
  Call WorkingRange.Delete
  
  Set WorkingRange = Nothing
    'rngSel.Select
End Sub
Public Sub ChangeBookmarkText_RichAutoText(strBookmarkName As String, strAutoTextName As String)
    On Error GoTo ChangeBookmarkText_AutoText_error
    
    Dim rng As Range
    
    Dim strStartupPath As String
    
    On Error GoTo ChangeBookmarkText_AutoText_error
    
    strStartupPath = Options.DefaultFilePath(wdStartupPath) & "\"

    Set rng = ActiveDocument.Bookmarks(strBookmarkName).Range
    
    ActiveDocument.AttachedTemplate.AutoTextEntries(strAutoTextName).Insert _
        Where:=rng, RichText:=True

    ActiveDocument.Bookmarks.Add strBookmarkName, rng
    Set rng = Nothing
       
ChangeBookmarkText_AutoText_error:

End Sub

Sub OpenNewWrite(ctl As IRibbonControl)
   '
   Dim sDocName As String
   Dim sPath As String
   
   
   sPath = Options.DefaultFilePath(wdUserTemplatesPath)
   If Len(sPath) > 0 Then
      sDocName = sPath & "\Skriveskabelon.dotm"
      Documents.Add Template:=sDocName, NewTemplate:=False, DocumentType:=0
   End If

End Sub

Attribute VB_Name = "mCore_DocumentProperties"
Option Explicit
Option Compare Text
'
' Purpose      :  Implements functionality to Set/Get Word document properties. Supports
'                 protected documents if we know the password.
'
'                 Implements the following Public functions:
'
'                 DocumentPropertyExists  ' Validates existance of a document property.
'                 DeleteDocumentProperty  ' Deletes a document property.
'                 GetDocumentProperty     ' Fetches a document property.
'                 SetDocumentProperty     ' Creates or changes a document property.
'
' Dependencies :  Reference to Microsoft Office Object library (version specific)
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  20. july 2010
' Last modified:  11. november 2010 /JAS  1) Implemented private pGetPropertyDataType() function for
'                                            internal data type validation i function SetDocumentProperty()
'
' TODO         :  Implement support for Linked Content
'
' Location for document properties
Public Enum enPropertyLocationConstants
   eplcDocPropBuiltIn = 1
   eplcDocPropCustom = 2
   eplcDocPropBoth = 3
End Enum
'

'
' Creates or changes a document property. If sPropName doesn't exist in advance
' it will be created when eLocation is either eplcDocPropCustom or eplcDocPropBoth.
' If oDocument is Nothing then the function works on ThisDocument.
Public Function SetDocumentProperty(ByVal sPropName As String, _
                                    ByVal eLocation As enPropertyLocationConstants, _
                                    ByRef vPropValue As Variant, _
                                    Optional ByRef oDocument As Document, _
                                    Optional sProtectionPassword As String) As Boolean
    
   Dim oDoc As Document
   Dim oProp As Office.DocumentProperty
   Dim oBuiltInProps As Office.DocumentProperties
   Dim oCustomProps As Office.DocumentProperties
   Dim vPropType As Variant
   Dim bIsProtected As Boolean
   Dim eProtectionType As WdProtectionType
   '
   ' Sanity checks
   If LenB(sPropName) = 0 Then
      Exit Function
   End If
   '
   ' Arrays are not accepted as data value
   If IsArray(vPropValue) Then
      Exit Function
   End If
   '
   ' Did we get a document to work on?
   ' If not we default to ThisDocument (ie. the template itself)
   If Not oDocument Is Nothing Then
      Set oDoc = oDocument
   Else
      Set oDoc = ThisDocument
   End If
   '
   ' Is the document password protected?
   If oDoc.ProtectionType <> wdNoProtection And LenB(sProtectionPassword) > 0 Then
      eProtectionType = oDoc.ProtectionType
      oDoc.Unprotect sProtectionPassword
      bIsProtected = True
   End If
   '
   ' Create objects to work with
   Set oBuiltInProps = oDoc.BuiltInDocumentProperties
   Set oCustomProps = oDoc.CustomDocumentProperties
   
   On Error Resume Next
   '
   ' If we work on a built-in property we can't refer to Linked Content
   If eLocation = eplcDocPropBuiltIn Then
      '
      ' Lookup the property
      Set oProp = oBuiltInProps(sPropName)
      '
      ' ... and set the value
      If Not oProp Is Nothing Then
         oProp.Value = vPropValue
         GoTo BailOut
      End If
      Err.Clear
      GoTo EndFunction
   '
   ' If the property is user-defined we delete and replace it
   ElseIf (eLocation = eplcDocPropCustom) Or (eLocation = eplcDocPropBoth) Then
      '
      ' Lookup the property
      Set oProp = oCustomProps(sPropName)
      '
      ' If found, delete it (the expectation is that we can re-create it below)
      If Not oProp Is Nothing Then
          oProp.Delete
      End If
      Err.Clear
      '
      ' The data type must be valid
      vPropType = pGetPropertyDataType(vPropValue)
      If IsNull(vPropType) Then
         GoTo EndFunction
      End If
      Err.Clear
      '
      ' If we get here we try to create the property
      ' TODO: Implement support for Linked Content
      oCustomProps.Add sPropName, False, vPropType, vPropValue
   End If
   
BailOut:
   
   SetDocumentProperty = CBool(Err.Number = 0)
   Err.Clear

EndFunction:

   If bIsProtected Then
      '
      ' Re-create protection if required
      oDoc.Protect eProtectionType, , sProtectionPassword
      oDoc.Saved = True
   End If


End Function

'
' Deletes a document property. If sPropName represent a built-in property the value will
' be reset instead of deleted. When eLocation is either eplcDocPropCustom or eplcDocPropBoth
' the property will be deleted only if eLocation turns out to be eplcDocPropCustom.
' If oDocument is Nothing then the function works on ThisDocument.
Public Function DeleteDocumentProperty(ByVal sPropName As String, _
                                       ByVal eLocation As enPropertyLocationConstants, _
                                       Optional ByRef oDocument As Document, _
                                       Optional sProtectionPassword As String) As Boolean
   
   Dim oDoc As Document
   Dim oProp As Office.DocumentProperty
   Dim oBuiltInProps As Office.DocumentProperties
   Dim oCustomProps As Office.DocumentProperties
   Dim vPropType As Variant
   Dim bIsProtected As Boolean
   Dim eProtectionType As WdProtectionType
   '
   ' Sanity checks
   If LenB(sPropName) = 0 Then
       Exit Function
   End If
   '
   ' Did we get a document to work on?
   ' If not we default to ThisDocument (ie. the template itself)
   If Not oDocument Is Nothing Then
       Set oDoc = oDocument
   Else
       Set oDoc = ThisDocument
   End If
   '
   ' Is the document password protected?
   If oDoc.ProtectionType <> wdNoProtection And LenB(sProtectionPassword) > 0 Then
      eProtectionType = oDoc.ProtectionType
      oDoc.Unprotect sProtectionPassword
      bIsProtected = True
   End If
   '
   ' Create objects to work with
   Set oBuiltInProps = oDoc.BuiltInDocumentProperties
   Set oCustomProps = oDoc.CustomDocumentProperties
   
   On Error Resume Next
   '
   ' If we work on a built-in property we reset its value
   If eLocation = eplcDocPropBuiltIn Then
      '
      ' Lookup the property
      Set oProp = oBuiltInProps(sPropName)
      '
      ' If found, reset the value
      If Not oProp Is Nothing Then
         oProp.Value = ""
         GoTo BailOut
      End If
      '
      ' If we get here the property didn't exist,
      ' so we return True by clearing any error.
      Err.Clear
   '
   ' If the property is user-defined we delete it
   ElseIf (eLocation = eplcDocPropCustom) Or (eLocation = eplcDocPropBoth) Then
      '
      ' Lookup the property
      Set oProp = oCustomProps(sPropName)
      '
      ' If found, delete it
      If Not oProp Is Nothing Then
         oProp.Delete
         GoTo BailOut
      End If
      '
      ' If we get here the property didn't exist,
      ' so we return True by clearing any error.
      Err.Clear
   
   End If
   
BailOut:
   
   DeleteDocumentProperty = CBool(Err.Number = 0)
   Err.Clear

EndFunction:

   If bIsProtected Then
      '
      ' Re-create protection if required
      oDoc.Protect eProtectionType, , sProtectionPassword
      oDoc.Saved = True
   End If

End Function

'
' Fetches a document property. If eLocation is input eplcDocPropBoth and sPropName was found
' eLocation will return eplcDocPropCustom if the property was a custom property but retain
' its value in all other cases.
' If oDocument is Nothing then the function works on ThisDocument.
Public Function GetDocumentProperty(ByVal sPropName As String, _
                                    ByRef eLocation As enPropertyLocationConstants, _
                                    Optional oDocument As Document) As Variant
   
   Dim oDoc As Document
   Dim oProps1 As Office.DocumentProperties
   Dim oProps2 As Office.DocumentProperties
   Dim oProp As Office.DocumentProperty

   If Not oDocument Is Nothing Then
      Set oDoc = oDocument
   Else
      Set oDoc = ThisDocument
   End If
   '
   ' Create objects to work with
   Select Case eLocation
      Case eplcDocPropBuiltIn
         Set oProps1 = oDoc.BuiltInDocumentProperties
      Case eplcDocPropCustom
         Set oProps1 = oDoc.CustomDocumentProperties
      Case eplcDocPropBoth
         Set oProps1 = oDoc.BuiltInDocumentProperties
         Set oProps2 = oDoc.CustomDocumentProperties
      Case Else
         '
         ' Don't do anything here
   End Select
   
   On Error Resume Next
   '
   ' Make the search
   Set oProp = oProps1(sPropName)
   '
   ' Success?
   If Not oProp Is Nothing Then
      '
      ' Return the value
      GetDocumentProperty = oProp.Value
      Exit Function
   Else
      '
      ' No, so we check the next data set
      If Not oProps2 Is Nothing Then
         '
         ' We ONLY get here if eLocation = eplcDocPropBoth
         Err.Clear
         Set oProp = oProps2(sPropName)
         If Not oProp Is Nothing Then
            '
            ' Return the value
            GetDocumentProperty = oProp.Value
            '
            ' ... and in this special case, also the property location
            eLocation = eplcDocPropCustom
            Exit Function
         End If
      End If
   End If
   '
   ' We should only get here if the property didn't exist
   GetDocumentProperty = Null
   Err.Clear

End Function

'
' Validates whether or not a document property exists. If eLocation is input eplcDocPropBoth and
' sPropName was found eLocation will return eplcDocPropCustom if the property was a custom property,
' but retain its value in all other cases.
' If oDocument is Nothing then the function works on ThisDocument.
Public Function DocumentPropertyExists(ByRef sPropName As String, _
                                       ByRef eLocation As enPropertyLocationConstants, _
                                       Optional ByRef oDocument As Document) As Boolean

   DocumentPropertyExists = Not IsNull(GetDocumentProperty(sPropName, eLocation, oDocument))

End Function

'
' Analyzing vPropType to assure that the data type is legal.
' Returns Null if the data type is illegal.
Private Function pGetPropertyDataType(ByRef vPropType As Variant) As Variant

   Select Case VarType(vPropType)
      Case vbArray, vbDataObject, vbEmpty, vbError, vbNull, vbObject, vbUserDefinedType, vbCurrency, vbDecimal
         pGetPropertyDataType = Null
      
      Case vbString
         pGetPropertyDataType = msoPropertyTypeString
      
      Case vbBoolean
         pGetPropertyDataType = msoPropertyTypeBoolean
      
      Case Else
         '
         ' All nummeric values are equally treated,
         ' Integers, Longs, Singles etc
         pGetPropertyDataType = msoPropertyTypeFloat
   End Select

End Function

Public Sub DeleteAllCustomProps(Optional oDocument As Document)

   If oDocument Is Nothing Then
      Set oDocument = ActiveDocument
   End If
   
   Dim oProp As Office.DocumentProperty
   For Each oProp In oDocument.CustomDocumentProperties
      oProp.Delete
   Next

End Sub

Attribute VB_Name = "mCore_FileOperationsW"
Option Explicit
Option Compare Binary
'
' Purpose      :  Implements VBA-friendly subsets of the most important general purpose
'                 file I/O and string functions. These function do NOT fail with Unicode
'                 file names such as the VBA functions do (Error 52, Bad file name or number)
'                 See the Remarks section below.
'
'                 Implements the following Public functions:
'
'                 AddBackslash            ' Appends a "\" if there isn't one
'                 CombinePaths            ' Combines two Path components, inserting a backslash if needed.
'                 CompactPathByChars      ' Truncates sPath to fit within the specified number of characters (for GUI use).
'                 CreatePath              ' Creates the specified path from the root (drive letter) if it doesn't exist.
'                 FileContentIsUnicode    ' Checks a text file's content and returns True if it's UTF-16 Little Endian (Windows Unicode)
'                 FileCopyEx              ' Copies files, folders and folder trees (with or without progress bars, prompting etc)
'                 FileDeleteEx            ' Deletes or moves to Recycle Bin files, folders and folder trees (with or without progress bars, prompting etc)
'                 FileExists              ' Returns True when a path exists (also folders - use FolderExists to isolate folders from files)
'                 FileMoveEx              ' Moves files, folders and folder trees (with or without progress bars, prompting etc)
'                 FileRenameEx            ' Renames files and folders (on the same drive)
'                 FolderExists            ' Returns True when a path has the Directory attribute set
'                 GetFileExtension        ' Returns the file extension from sPath
'                 GetFileName             ' Returns the file name from sPath
'                 GetFolderName           ' Returns the folder name from sPath
'               * GetShortName            ' Returns the MS-DOS 8.3 conventional file name
'                 GetSpecialFolder        ' Returns the full qualified path to special folders such as Desktop, AppData, Recycle Bin etc.
'                 IsMatchingSearchMask    ' Determine if a file name fits into a search pattern, eg. "*.doc;*.txt;*.xls"
'                 QuotePath               ' Encloses sPath in quotes if sPath contains spaces.
'                 RemoveBackslash         ' Removes a trailing "\" if there is one
'                 RemoveExtension         ' Removes the Extension part of a file name
'                 RenameExtension         ' Renames the extension of sPath if there is one, or adds the extension if there is none
'                 ShellAndWait            ' Executes a file item with parameters, and optionally waits until the file is closed
'                 ShowFileOpenDialog      ' Displays a Shell File Open dialog
'                 ShowFileSaveDialog      ' Displays a Shell File Save dialog
'                 UnquotePath             ' Removes any leading and trailing quotes from sPath.
'
' Dependencies :  None
'
' Created by   :  Jacob Sch|fffd|ffer
' Created      :  20. july 2010
'                 19. october 2010 /JAS   Implemented handling of non-standard Error Codes returned from
'                                         SHFileOperationW.
' Modified     :  05. november 2010 /JAS  Implemented the ShellAndWait function incl. handling of non-standard
'                                         Error Codes returned in SHELLEXECUTEINFO.hAppInst.
'                 23. August 2011 /JAS    1) 32/64-bit 2010 support implemented.
'                 28. December 2011 /JAS  1) Byte alignment bug with SHFILEOPSTRUCTW fixed.
'
' Remarks      :  The intrinsic VBA file functions does NOT work with Unicode file names on non-DBCS systems.
'                 Hence, before calling the Open, Kill, Name and FileCopy statements you should use the
'                 GetShortName function in this module to obtain a valid file name, or simply use the
'                 provided FileDeleteEx, FileMoveEx, FileRenameEx and FileCopyEx functions instead.
'
' TODO         :  1) GetLastError is not reliable with error codes from the SHFileOperationW function.
'                    Anyway, we have assumed that most error codes match system error codes. Should be
'                    changed only if our assumption appear to be a problem.
'                 2) Implement other functions as need be.
'
'
Private Const MODULE_NAME = "mCore_FileOperationsW"
'
' Non-standard Error Codes for SHFileOperation.
' Any other error code match GetLastError() from the Shell.
Private Const DE_SAMEFILE = &H71          ' Source and destination file are the same
Private Const DE_MANYSRC1DEST = &H72      ' Multiple paths were specified in the source of the operation, but only one Destination Path
Private Const DE_DIFFDIR = &H73           ' Rename operation was specified but the destination path is a different directory. Use move instead.
Private Const DE_ROOTDIR = &H74           ' Source is a root directory, cannot be moved or renamed
Private Const DE_OPCANCELLED = &H75       ' Operation was cancelled by the user (or silently cancelled if the specified flags were supplied to SHFileOperation)
Private Const DE_DESTSUBTREE = &H76       ' The destination is a sub-tree of the source
Private Const DE_ACCESSDENIEDSRC = &H78   ' Security problems on source
Private Const DE_PATHTOODEEP = &H79       ' The source or destination path exceeded or would exceed MAX_PATH
Private Const DE_MANYDEST = &H7A          ' Operation involved multiple destination paths which can fail in the case of a Move Operation
Private Const DE_INVALIDFILES = &H7C      ' The paths in the source or destination were invalid
Private Const DE_DESTSAMETREE = &H7D      ' Source and destination have the same parent folder.
Private Const DE_FLDDESTISFILE = &H7E     ' The destination path is to an existing file
Private Const DE_FILEDESTISFLD = &H80     ' The destination path is to an existing folder
Private Const DE_FILENAMETOOLONG = &H81   ' The name of the file exceeds MAX_PATH
Private Const DE_DEST_IS_CDROM = &H82     ' Destination is a Read-Only CDRom, possibly unformatted
Private Const DE_DEST_IS_DVD = &H83       ' Destination is a Read-Only DVD, possibly unformatted
Private Const DE_DEST_IS_CDRECORD = &H84  ' Destination is a Recordable (AudioL) CDRom, possibly unformatted
Private Const DE_FILE_TOO_LARGE = &H85    ' The file involved in the operation is too large for the destination media or file System
Private Const DE_SRC_IS_CDROM = &H86      ' Source is a Read-Only CDRom, possibly unformatted
Private Const DE_SRC_IS_DVD = &H87        ' Source is a Read-Only DVD, possibly unformatted
Private Const DE_SRC_IS_CDRECORD = &H88   ' Source is a Recordable (AudioL) CDRom, possibly unformatted
Private Const DE_ERROR_MAX = &HB7         ' MAX_PATH was exceeded during the operation.
Private Const ERRORONDEST = &H10000       ' An unspecified error occurred on the destination.
Private Const DE_ROOTRENAME = &H10074     ' Destination is a root directory, cannot be renamed
'
' Constants for SHFileOperation wFunc member in SHFILEOPSTRUCT
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_MOVE = &H1
Private Const FO_RENAME = &H4
'
' Constants for SHFileOperation fFlags member in SHFILEOPSTRUCT
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_FILESONLY = &H80
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_NO_CONNECTED_ELEMENTS = &H2000
Private Const FOF_NOCONFIRMATION = &H10
Private Const FOF_NOCONFIRMMKDIR = &H200
Private Const FOF_NOCOPYSECURITYATTRIBS = &H800
Private Const FOF_NOERRORUI = &H400
Private Const FOF_NORECURSION = &H1000
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_SILENT = &H4
Private Const FOF_SIMPLEPROGRESS = &H100
Private Const FOF_WANTMAPPINGHANDLE = &H20
Private Const FOF_WANTNUKEWARNING = &H4000
'
' Struct for SHFileOperationW API
Type SHFILEOPSTRUCTW
   #If VBA7 Then
      hWnd                    As LongPtr  ' 8 bytes
      wFunc                   As Long     ' 4
      pFrom                   As LongPtr  ' 8
      pTo                     As LongPtr  ' 8
      fFlags                  As Integer  ' 2   ' *Must* be an Integer, even with 64-bit VBA. If declared as Long we get a byte alignment problem.
      fAnyOperationsAborted   As Long     ' 4
      hNameMappings           As LongPtr  ' 8
      ' Only used if FOF_SIMPLEPROGRESS:
      lpszProgressTitle       As LongPtr  ' 8 = 50 bytes total
   #Else
      hWnd                   As Long      ' 4 bytes
      wFunc                  As Long      ' 4
      pFrom                  As Long      ' 4
      pTo                    As Long      ' 4
      fFlags                 As Integer   ' 2   ' *Must* be an Integer. If declared as Long we get a byte alignment problem.
      fAnyOperationsAborted  As Long      ' 4
      hNameMappings          As Long      ' 4
      lpszProgressTitle      As Long      ' 4 = 30 bytes total
   #End If
End Type

' int SHFileOperation(
'   __in  LPSHFILEOPSTRUCT lpFileOp
' );
' Copies, moves, renames, or deletes a file system object.
' See: http://msdn.microsoft.com/en-us/library/bb762164(VS.85).aspx
'Private Declare Function SHFileOperationW Lib "shell32.dll" (lpFileOp As SHFILEOPSTRUCTW) As Long
#If VBA7 Then
   Private Declare PtrSafe Function SHFileOperationW Lib "shell32.dll" (lpFileOp As Any) As Long
#Else
   Private Declare Function SHFileOperationW Lib "shell32.dll" (lpFileOp As Any) As Long
#End If
'
' Enum for passing on SHFILEOPSTRUCTW.wFunc parameters
Public Enum enFileOperationConstants
   efocCopy = FO_COPY
   efocDelete = FO_DELETE
   efocMove = FO_MOVE
   efocRename = FO_RENAME
End Enum
'
' Enum for passing on SHFILEOPSTRUCTW.fFlags parameters
' Not all possible flags are implemented here
Public Enum enFileOperationFlags
   efofAllowUndo = FOF_ALLOWUNDO                ' Preserve undo information, if possible
   efofFilesOnly = FOF_FILESONLY                ' Perform the operation only on files (not on folders) if a wildcard file name (*.*) is specified
   ' FOF_MULTIDESTFILES
   efofNoConfirmation = FOF_NOCONFIRMATION      ' Respond with Yes to All for any dialog box that is displayed
   efofNoConfirmNewDir = FOF_NOCONFIRMMKDIR     ' Do not ask the user to confirm the creation of a new directory if the operation requires one to be created
   ' FOF_NO_CONNECTED_ELEMENTS
   ' FOF_NOCOPYSECURITYATTRIBS
   efofNoErrorUI = FOF_NOERRORUI                ' Do not display a dialog to the user if an error occurs
   efofNoRecursion = FOF_NORECURSION            ' Only perform the operation in the local directory. Don't operate recursively into subdirectories, which is the default behavior.
   efofRenameIfExists = FOF_RENAMEONCOLLISION   ' Give the file being operated on a new name in a move, copy, or rename operation if a file with the target name already exists at the destination
   efofNoProgressDlg = FOF_SILENT               ' Do not display a progress dialog box
   efofSimpleProgressDlg = FOF_SIMPLEPROGRESS   ' Display a progress dialog box but do not show individual file names as they are operated on
   ' FOF_WANTMAPPINGHANDLE
   ' FOF_WANTNUKEWARNING
End Enum
   
Private Const MAX_PATH As Long = 260
'
' Fast Windows Unikode API's for File/Path manipulation
#If VBA7 Then
   Private Declare PtrSafe Sub RtlMoveMemory Lib "kernel32.dll" (ByRef pDst As Any, ByRef pSrc As Any, ByVal ByteLen As Long)
   Private Declare PtrSafe Function lstrlenW Lib "kernel32" (ByVal lpString As LongPtr) As Long
   Private Declare PtrSafe Function PathAppendW Lib "Shlwapi" (ByVal pszPath As LongPtr, ByVal pszMore As LongPtr) As Long
   Private Declare PtrSafe Function PathFileExistsW Lib "Shlwapi" (ByVal lpszPath As LongPtr) As Long
   Private Declare PtrSafe Function PathFindExtensionW Lib "Shlwapi" (ByVal pPath As LongPtr) As LongPtr
   Private Declare PtrSafe Function PathFindFileNameW Lib "Shlwapi" (ByVal pPath As LongPtr) As LongPtr
   Private Declare PtrSafe Function PathIsDirectoryW Lib "Shlwapi" (ByVal lpszPath As LongPtr) As Long
   Private Declare PtrSafe Function PathIsFileSpecW Lib "Shlwapi" (ByVal lpszPath As LongPtr) As Long
   Private Declare PtrSafe Sub PathRemoveExtensionW Lib "Shlwapi" (ByVal lpszPath As LongPtr)
   Private Declare PtrSafe Function PathSearchAndQualifyW Lib "Shlwapi" (ByVal pcszPath As LongPtr, ByVal pszFullyQualifiedPath As LongPtr, ByVal cchFullyQualifiedPath As Integer) As Boolean
   Private Declare PtrSafe Function PathAddBackslashW Lib "Shlwapi" (ByVal lpszPath As LongPtr) As Long
   Private Declare PtrSafe Function PathMatchSpecW Lib "Shlwapi" (ByVal pszFileParam As LongPtr, ByVal pszSpec As LongPtr) As Long
   Private Declare PtrSafe Function PathRemoveBackslashW Lib "Shlwapi" (ByVal lpszPath As LongPtr) As Long
   Private Declare PtrSafe Function PathRemoveFileSpecW Lib "Shlwapi" (ByVal pszPath As LongPtr) As Long
   
   Private Declare PtrSafe Function PathCompactPathExW Lib "Shlwapi" (ByVal pszOut As LongPtr, ByVal pszSrc As LongPtr, ByVal cchMax As Integer, dwFlags As Long) As Long
   Private Declare PtrSafe Function PathRenameExtensionW Lib "Shlwapi" (ByVal lpszPath As LongPtr, ByVal pszExtension As LongPtr) As Long
   Private Declare PtrSafe Sub PathQuoteSpacesW Lib "Shlwapi" (ByVal lpsz As LongPtr)
   Private Declare PtrSafe Sub PathUnquoteSpacesW Lib "Shlwapi" (ByVal lpsz As LongPtr)
#Else
   Private Declare Sub RtlMoveMemory Lib "kernel32" (ByRef pDst As Any, ByRef pSrc As Any, ByVal ByteLen As Long)
   Private Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long
   Private Declare Function PathAppendW Lib "Shlwapi" (ByVal pszPath As Long, ByVal pszMore As Long) As Long
   Private Declare Function PathFileExistsW Lib "Shlwapi" (ByVal lpszPath As Long) As Long
   Private Declare Function PathFindExtensionW Lib "Shlwapi" (ByVal pPath As Long) As Long
   Private Declare Function PathFindFileNameW Lib "Shlwapi" (ByVal pPath As Long) As Long
   Private Declare Function PathIsDirectoryW Lib "Shlwapi" (ByVal lpszPath As Long) As Long
   Private Declare Function PathIsFileSpecW Lib "Shlwapi" (ByVal lpszPath As Long) As Long
   Private Declare Sub PathRemoveExtensionW Lib "Shlwapi" (ByVal lpszPath As Long)
   Private Declare Function PathSearchAndQualifyW Lib "Shlwapi" (ByVal pcszPath As Long, ByVal pszFullyQualifiedPath As Long, ByVal cchFullyQualifiedPath As Integer) As Boolean
   Private Declare Function PathAddBackslashW Lib "Shlwapi" (ByVal lpszPath As Long) As Long
   Private Declare Function PathMatchSpecW Lib "Shlwapi" (ByVal pszFileParam As Long, ByVal pszSpec As Long) As Long
   Private Declare Function PathRemoveBackslashW Lib "Shlwapi" (ByVal lpszPath As Long) As Long
   Private Declare Function PathRemoveFileSpecW Lib "Shlwapi" (ByVal pszPath As Long) As Long
   
   Private Declare Function PathCompactPathExW Lib "Shlwapi" (ByVal pszOut As Long, ByVal pszSrc As Long, ByVal cchMax As Integer, dwFlags As Long) As Long
   Private Declare Function PathRenameExtensionW Lib "Shlwapi" (ByVal lpszPath As Long, ByVal pszExtension As Long) As Long
   Private Declare Sub PathQuoteSpacesW Lib "Shlwapi" (ByVal lpsz As Long)
   Private Declare Sub PathUnquoteSpacesW Lib "Shlwapi" (ByVal lpsz As Long)
#End If
'
' Windows Unikode Path creation API
#If VBA7 Then
   Private Type SECURITY_ATTRIBUTES
      nLength As Long
      lpSecurityDescriptor As LongPtr
      bInheritHandle As Long
   End Type
#Else
   Private Type SECURITY_ATTRIBUTES
      nLength As Long
      lpSecurityDescriptor As Long
      bInheritHandle As Long
   End Type
#End If
' BOOL WINAPI CreateDirectory(
'   __in      LPCTSTR lpPathName,
'   __in_opt  LPSECURITY_ATTRIBUTES lpSecurityAttributes
' );
#If VBA7 Then
   Private Declare PtrSafe Function CreateDirectoryW Lib "kernel32" (ByVal lpPathName As LongPtr, lpSecurityAttributes As SECURITY_ATTRIBUTES) As Long
#Else
   Private Declare Function CreateDirectoryW Lib "kernel32" (ByVal lpPathName As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES) As Long
#End If
'
' API for decoding Err.LastDLLError numbers to a descriptive text
' DWORD WINAPI FormatMessage(
'   __in      DWORD dwFlags,
'   __in_opt  LPCVOID lpSource,
'   __in      DWORD dwMessageId,
'   __in      DWORD dwLanguageId,
'   __out     LPTSTR lpBuffer,
'   __in      DWORD nSize,
'   __in_opt  va_list *Arguments
' );
' See: http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
Private Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
#If VBA7 Then
   Private Declare PtrSafe Function FormatMessageW Lib "kernel32" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As LongPtr) As Long
#Else
   Private Declare Function FormatMessageW Lib "kernel32" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As Long) As Long
#End If

' DWORD WINAPI GetShortPathName(
'   __in   LPCTSTR lpszLongPath,
'   __out  LPTSTR lpszShortPath,
'   __in   DWORD cchBuffer
' );
#If VBA7 Then
    Private Declare PtrSafe Function GetShortPathNameW Lib "kernel32" (ByVal lpszLongPath As LongPtr, ByVal lpszShortPath As LongPtr, ByVal cchBuffer As Long) As Long
#Else
    Private Declare Function GetShortPathNameW Lib "kernel32" (ByVal lpszLongPath As Long, ByVal lpszShortPath As Long, ByVal cchBuffer As Long) As Long
#End If
'
' Structures and API's for Unicode Open and Save file dialogs
#If VBA7 Then
   Public Type OPENFILENAMEW
      lStructSize As Long          ' Filled with UDT size
      hwndOwner As LongPtr            ' Tied to hOwner
      hInstance As LongPtr            ' Ignored (used only by templates)
      lpstrFilter As LongPtr          ' Tied to Filter
      lpstrCustomFilter As LongPtr    ' Ignored
      nMaxCustFilter As Long       ' Ignored
      nFilterIndex As Long         ' Tied to FilterIndex
      lpstrFile As LongPtr            ' Tied to FileName
      nMaxFile As Long             ' Handled internally
      lpstrFileTitle As LongPtr       ' Tied to FileTitle
      nMaxFileTitle As Long        ' Handled internally
      lpstrInitialDir As LongPtr      ' Tied to InitDir
      lpstrTitle As LongPtr           ' Tied to DlgTitle
      eFlags As Long               ' Tied to Flags
      nFileOffset As Integer       ' Ignored (*must* be declared as Integer)
      nFileExtension As Integer    ' Ignored (*must* be declared as Integer)
      lpstrDefExt As LongPtr          ' Tied to DefaultExt
      lCustData As LongPtr            ' Ignored (needed for hooks)
      lpfnHook As LongPtr             ' Ignored (hooks not easy)
      lpTemplateName As LongPtr       ' Ignored (templates even worse)
      
     ' pvReserved As LongPtr
     ' dwReserved As Long
     ' FlagsEx As Long
   
   End Type
#Else
   Public Type OPENFILENAMEW
      lStructSize As Long          ' Filled with UDT size
      hwndOwner As Long            ' Tied to hOwner
      hInstance As Long            ' Ignored (used only by templates)
      lpstrFilter As Long          ' Tied to Filter
      lpstrCustomFilter As Long    ' Ignored
      nMaxCustFilter As Long       ' Ignored
      nFilterIndex As Long         ' Tied to FilterIndex
      lpstrFile As Long            ' Tied to FileName
      nMaxFile As Long             ' Handled internally
      lpstrFileTitle As Long       ' Tied to FileTitle
      nMaxFileTitle As Long        ' Handled internally
      lpstrInitialDir As Long      ' Tied to InitDir
      lpstrTitle As Long           ' Tied to DlgTitle
      eFlags As Long               ' Tied to Flags
      nFileOffset As Integer       ' Ignored (*must* be declared as Integer)
      nFileExtension As Integer    ' Ignored (*must* be declared as Integer)
      lpstrDefExt As Long          ' Tied to DefaultExt
      lCustData As Long            ' Ignored (needed for hooks)
      lpfnHook As Long             ' Ignored (hooks not easy)
      lpTemplateName As Long       ' Ignored (templates even worse)
   End Type
#End If
'
' BOOL WINAPI GetOpenFileName(
'   __inout  LPOPENFILENAME lpofn
' );
' See: http://msdn.microsoft.com/en-us/library/ms646927(VS.85).aspx
#If VBA7 Then
   Private Declare PtrSafe Function GetOpenFileNameW Lib "COMDLG32" (ByVal lpOpenFileStruct As LongPtr) As Long
#Else
   Private Declare Function GetOpenFileNameW Lib "COMDLG32" (ByVal lpOpenFileStruct As Long) As Long
#End If
'
' BOOL WINAPI GetSaveFileName(
'   __inout  LPOPENFILENAME lpofn
' );
' See: http://msdn.microsoft.com/en-us/library/ms646928(v=VS.85).aspx
#If VBA7 Then
   Private Declare PtrSafe Function GetSaveFileNameW Lib "COMDLG32" (ByVal lpOpenFileStruct As LongPtr) As Long
#Else
   Private Declare Function GetSaveFileNameW Lib "COMDLG32" (ByVal lpOpenFileStruct As Long) As Long
#End If

'
' DWORD WINAPI CommDlgExtendedError(void);
' See: http://msdn.microsoft.com/en-us/library/ms646916(VS.85).aspx
#If VBA7 Then
   Private Declare PtrSafe Function CommDlgExtendedError Lib "COMDLG32" () As Long
#Else
   Private Declare Function CommDlgExtendedError Lib "COMDLG32" () As Long
#End If
'
' Flags for GetSave- and GetOpenFileName
Public Enum enOpenFileConstants
   OFN_READONLY = &H1
   OFN_OVERWRITEPROMPT = &H2
   OFN_HIDEREADONLY = &H4
   OFN_NOCHANGEDIR = &H8
   OFN_SHOWHELP = &H10
   OFN_ENABLEHOOK = &H20
   OFN_ENABLETEMPLATE = &H40
   OFN_ENABLETEMPLATEHANDLE = &H80
   OFN_NOVALIDATE = &H100
   OFN_ALLOWMULTISELECT = &H200
   OFN_EXTENSIONDIFFERENT = &H400
   OFN_PATHMUSTEXIST = &H800
   OFN_FILEMUSTEXIST = &H1000
   OFN_CREATEPROMPT = &H2000
   OFN_SHAREAWARE = &H4000
   OFN_NOREADONLYRETURN = &H8000&
   OFN_NOTESTFILECREATE = &H10000
   OFN_NONETWORKBUTTON = &H20000
   OFN_NOLONGNAMES = &H40000
   OFN_EXPLORER = &H80000
   OFN_NODEREFERENCELINKS = &H100000
   OFN_LONGNAMES = &H200000
   OFN_DONTADDTORECENT = &H2000000
End Enum
'
' Common Dialog Error Constants
' TODO: Implement proper error handling
Public Enum enCommonDialogErrors
   CDERR_DIALOGFAILURE = &HFFFF     ' The dialog box could not be created. The common dialog box function's call to the DialogBox function failed.
                                    ' For example, this error occurs if the common dialog box call specifies an invalid window handle.
   CDERR_STRUCTSIZE = &H1           ' The lStructSize member of the initialization structure for the corresponding common dialog box is invalid.
   CDERR_INITIALIZATION = &H2       ' The common dialog box function failed during initialization. This error often occurs when sufficient memory is not available.
   CDERR_NOTEMPLATE = &H3           ' The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box,
                                    ' but you failed to provide a corresponding template.
   CDERR_NOHINSTANCE = &H4          ' The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box,
                                    ' but you failed to provide a corresponding instance handle.
   CDERR_LOADSTRFAILURE = &H5       ' The common dialog box function failed to load a specified string.
   CDERR_FINDRESFAILURE = &H6       ' The common dialog box function failed to find a specified resource.
   CDERR_LOADRESFAILURE = &H7       ' The common dialog box function failed to load a specified string.
   CDERR_LOCKRESFAILURE = &H8       ' The common dialog box function failed to lock a specified resource.
   CDERR_MEMALLOCFAILURE = &H9      ' The common dialog box function was unable to allocate memory for internal structures.
   CDERR_MEMLOCKFAILURE = &HA       ' The common dialog box function was unable to lock the memory associated with a handle.
   CDERR_NOHOOK = &HB               ' The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box,
                                    ' but you failed to provide a pointer to a corresponding hook procedure.
   CDERR_REGISTERMSGFAIL = &HC      ' The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.
   
   CDERR_GENERALCODES = &H0         ' Nothing wrong. The user might have cancelled/aborted.
   

   PDERR_PRINTERCODES = &H1000
   PDERR_SETUPFAILURE = &H1001
   PDERR_PARSEFAILURE = &H1002
   PDERR_RETDEFFAILURE = &H1003
   PDERR_LOADDRVFAILURE = &H1004
   PDERR_GETDEVMODEFAIL = &H1005
   PDERR_INITFAILURE = &H1006
   PDERR_NODEVICES = &H1007
   PDERR_NODEFAULTPRN = &H1008
   PDERR_DNDMMISMATCH = &H1009
   PDERR_CREATEICFAILURE = &H100A
   PDERR_PRINTERNOTFOUND = &H100B
   PDERR_DEFAULTDIFFERENT = &H100C

   CFERR_CHOOSEFONTCODES = &H2000
   CFERR_NOFONTS = &H2001
   CFERR_MAXLESSTHANMIN = &H2002

   FNERR_FILENAMECODES = &H3000
   FNERR_SUBCLASSFAILURE = &H3001
   FNERR_INVALIDFILENAME = &H3002
   FNERR_BUFFERTOOSMALL = &H3003

   CCERR_CHOOSECOLORCODES = &H5000
End Enum
'
' Special Folder constants for the GetSpecialFolder function
Public Enum enCSIDLConstants
   CSIDL_DESKTOP = &H0                   ' (desktop)
   CSIDL_INTERNET = &H1                  ' Internet Explorer (icon on desktop)
   CSIDL_PROGRAMS = &H2                  ' Start Menu\Programs
   CSIDL_CONTROLS = &H3                  ' My Computer\Control Panel
   CSIDL_PRINTERS = &H4                  ' My Computer\Printers
   CSIDL_PERSONAL = &H5                  ' My Documents
   CSIDL_FAVORITES = &H6                 ' (user name)\Favorites
   CSIDL_STARTUP = &H7                   ' Start Menu\Programs\Startup
   CSIDL_RECENT = &H8                    ' (user name)\Recent
   CSIDL_SENDTO = &H9                    ' (user name)\SendTo
   CSIDL_BITBUCKET = &HA                 ' (desktop)\Recycle Bin
   CSIDL_STARTMENU = &HB                 ' (user name)\Start Menu
   CSIDL_DESKTOPDIRECTORY = &H10         ' (user name)\Desktop
   CSIDL_DRIVES = &H11                   ' My Computer
   CSIDL_NETWORK = &H12                  ' Network Neighborhood
   CSIDL_NETHOOD = &H13                  ' (user name)\nethood
   CSIDL_FONTS = &H14                    ' windows\fonts
   CSIDL_TEMPLATES = &H15
   CSIDL_COMMON_STARTMENU = &H16         ' All Users\Start Menu
   CSIDL_COMMON_PROGRAMS = &H17          ' All Users\Programs
   CSIDL_COMMON_STARTUP = &H18           ' All Users\Startup
   CSIDL_COMMON_DESKTOPDIRECTORY = &H19  ' All Users\Desktop
   CSIDL_APPDATA = &H1A                  ' (user name)\Application Data
   CSIDL_PRINTHOOD = &H1B                ' (user name)\PrintHood
   CSIDL_LOCAL_APPDATA = &H1C            ' (user name)\Local Settings\Applicaiton Data (non roaming)
   CSIDL_ALTSTARTUP = &H1D               ' non localized startup
   CSIDL_COMMON_ALTSTARTUP = &H1E        ' non localized common startup
   CSIDL_COMMON_FAVORITES = &H1F
   CSIDL_INTERNET_CACHE = &H20
   CSIDL_COOKIES = &H21
   CSIDL_HISTORY = &H22
   CSIDL_COMMON_APPDATA = &H23           ' All Users\Application Data
   CSIDL_WINDOWS = &H24                  ' GetWindowsDirectory()
   CSIDL_SYSTEM = &H25                   ' GetSystemDirectory()
   CSIDL_PROGRAM_FILES = &H26            ' C:\Program Files
   CSIDL_MYPICTURES = &H27               ' C:\Program Files\My Pictures
   CSIDL_PROFILE = &H28                  ' USERPROFILE
   CSIDL_PROGRAM_FILES_COMMON = &H2B     ' C:\Program Files\Common
   CSIDL_COMMON_TEMPLATES = &H2D         ' All Users\Templates
   CSIDL_COMMON_DOCUMENTS = &H2E         ' All Users\Documents
   CSIDL_COMMON_ADMINTOOLS = &H2F        ' All Users\Start Menu\Programs\Administrative Tools
   CSIDL_ADMINTOOLS = &H30               ' (user name)\Start Menu\Programs\Administrative Tools
End Enum
'
' typedef struct _SHITEMID {
'   USHORT cb;
'   BYTE   abID[1];
' } SHITEMID;
Private Type SHITEMID
#If VBA7 Then
   cb As LongPtr          ' The size of identifier, in bytes, including cb itself.
#Else
   cb As Long          ' The size of identifier, in bytes, including cb itself.
#End If
   abID As Byte        ' A variable-length item identifier.
End Type
'
' typedef struct _ITEMIDLIST {
'   SHITEMID mkid;
' } ITEMIDLIST;
Private Type ITEMIDLIST
   mkid As SHITEMID    ' A list of item identifiers.
End Type
'
' HRESULT SHGetSpecialFolderLocation(
'   __in   HWND hwndOwner,
'   __in   int nFolder,
'   __out  PIDLIST_ABSOLUTE *ppidl
' );
#If VBA7 Then
   Private Declare PtrSafe Function SHGetSpecialFolderLocation Lib "shell32.dll" (ByVal hwndOwner As LongPtr, ByVal nFolder As Long, ByRef pidl As ITEMIDLIST) As Long
#Else
   Private Declare Function SHGetSpecialFolderLocation Lib "shell32.dll" (ByVal hwndOwner As Long, ByVal nFolder As Long, ByRef pidl As ITEMIDLIST) As Long
#End If
'
' BOOL SHGetPathFromIDList(
'   __in   PCIDLIST_ABSOLUTE pidl,
'   __out  LPTSTR pszPath
' );
#If VBA7 Then
   Private Declare PtrSafe Function SHGetPathFromIDListW Lib "shell32.dll" (ByVal pidl As LongPtr, ByVal pszPath As LongPtr) As Long
#Else
   Private Declare Function SHGetPathFromIDListW Lib "shell32.dll" (ByVal pidl As Long, ByVal pszPath As Long) As Long
#End If
'
' void CoTaskMemFree(
'   __in_opt  LPVOID pv
' );
' Private Declare Sub CoTaskMemFree Lib "ole32.dll" (ByVal pv As Long)
'
' Constants for the "nShow" parameter in SHELLEXECUTEINFO
Public Enum enShellShowConstants
   essSW_HIDE = 0
   essSW_MAXIMIZE = 3
   essSW_MINIMIZE = 6
   essSW_SHOWMAXIMIZED = 3
   essSW_SHOWMINIMIZED = 2
   essSW_SHOWNORMAL = 1
   essSW_SHOWNOACTIVATE = 4
   essSW_SHOWNA = 8
   essSW_SHOWMINNOACTIVE = 7
   essSW_SHOWDEFAULT = 10
   essSW_RESTORE = 9
   essSW_SHOW = 5
End Enum
'
' WaitMode constants for the ShellAndWait function
Public Enum enWaitConstants
   enwcNone = 0
   enwcInitialize = 1
   enwcTerminate = 2
End Enum
'
' Error codes for the ShellAndWait function
Private Const ERROR_FILE_NOT_FOUND = 2&
Private Const ERROR_PATH_NOT_FOUND = 3&
Private Const ERROR_BAD_FORMAT = 11&
Private Const SE_ERR_ACCESSDENIED = 5            '  access denied
Private Const SE_ERR_ASSOCINCOMPLETE = 27
Private Const SE_ERR_DDEBUSY = 30
Private Const SE_ERR_DDEFAIL = 29
Private Const SE_ERR_DDETIMEOUT = 28
Private Const SE_ERR_DLLNOTFOUND = 32
Private Const SE_ERR_FNF = 2                     '  file not found
Private Const SE_ERR_NOASSOC = 31
Private Const SE_ERR_PNF = 3                     '  path not found
Private Const SE_ERR_OOM = 8                     '  out of memory
Private Const SE_ERR_SHARE = 26
'
' For Waiting and Terminating processses
Private Const WAIT_OBJECT_0 = &H0
Private Const WAIT_FAILED = &HFFFFFFFF
#If VBA7 Then
   Private Declare PtrSafe Function WaitForInputIdle Lib "user32" (ByVal hProcess As LongPtr, ByVal dwMilliseconds As Long) As Long
   Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As Long
   Private Declare PtrSafe Function TerminateProcess Lib "kernel32" (ByVal hProcess As LongPtr, ByVal uExitCode As Long) As Long
#Else
   Private Declare Function WaitForInputIdle Lib "user32" (ByVal hProcess As Long, ByVal dwMilliseconds As Long) As Long
   Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
   Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
#End If
'
' SHELLEXECUTEINFO fMask constants
Private Const SEE_MASK_NO_CONSOLE = &H8000
'  Note CLASSKEY overrides CLASSNAME
Private Const SEE_MASK_CLASSNAME = &H1
Private Const SEE_MASK_CLASSKEY = &H3
'  Note INVOKEIDLIST overrides IDLIST
Private Const SEE_MASK_IDLIST = &H4
Private Const SEE_MASK_INVOKEIDLIST = &HC
Private Const SEE_MASK_ICON = &H10
Private Const SEE_MASK_HOTKEY = &H20
Private Const SEE_MASK_NOCLOSEPROCESS = &H40
Private Const SEE_MASK_CONNECTNETDRV = &H80
Private Const SEE_MASK_FLAG_DDEWAIT = &H100
Private Const SEE_MASK_DOENVSUBST = &H200
Private Const SEE_MASK_FLAG_NO_UI = &H400
'
' Struture for the ShellExecuteEx function
#If VBA7 Then
   Private Type SHELLEXECUTEINFO
      cbSize As Long
      fMask As Long
      hWnd As LongPtr
      lpVerb As LongPtr
      lpFile As LongPtr
      lpParameters As LongPtr
      lpDirectory As LongPtr
      nShow As Long
      hInstApp As LongPtr
      lpIDList As LongPtr
      lpClass As LongPtr
      hkeyClass As LongPtr
      dwHotKey As Long
      hIcon As LongPtr
      hProcess As LongPtr
   End Type
#Else
   Private Type SHELLEXECUTEINFO
      cbSize As Long
      fMask As Long
      hWnd As Long
      lpVerb As Long
      lpFile As Long
      lpParameters As Long
      lpDirectory As Long
      nShow As Long
      hInstApp As Long
      lpIDList As Long
      lpClass As Long
      hkeyClass As Long
      dwHotKey As Long
      hIcon As Long
      hProcess As Long
   End Type
#End If
'
' BOOL ShellExecuteEx(
'   __inout  LPSHELLEXECUTEINFO lpExecInfo
' );
' See: http://msdn.microsoft.com/en-us/library/bb762154(VS.85).aspx
#If VBA7 Then
   Private Declare PtrSafe Function ShellExecuteExW Lib "shell32.dll" (lpExecInfo As SHELLEXECUTEINFO) As Long
#Else
   Private Declare Function ShellExecuteExW Lib "shell32.dll" (lpExecInfo As SHELLEXECUTEINFO) As Long
#End If
'
' Represents the numeric value of the "." character
Private Const vbDot = 46
'


' Performs SHFileOperation functions.
' If eFlags <> 0 all optional parameters are ignored.
Private Function pFileOperation(ByRef eOperation As enFileOperationConstants, _
                               ByRef sFrom As String, _
                               ByRef sTo As String, _
                               ByVal eFlags As enFileOperationFlags, _
                               ByRef bIsAborted As Boolean, _
                               Optional bSilent As Boolean = True, _
                               Optional bDisableConfirmationDlg As Boolean = True, _
                               Optional bRenameOnNameCollision As Boolean = False, _
                               Optional bDontConfirmFolderCreation As Boolean = True, _
                               Optional bAllowUndo As Boolean = False) As Long
   
   Dim lRes As Long
   Dim lFlags As Long
   Dim tFileOp As SHFILEOPSTRUCTW
   
   Dim sSource As String
   Dim sDestination As String
      
   If eFlags <> 0 Then
      lFlags = eFlags
   Else
      If bSilent Then lFlags = lFlags Or FOF_SILENT
      If bDisableConfirmationDlg Then lFlags = lFlags Or FOF_NOCONFIRMATION
      If bRenameOnNameCollision Then lFlags = lFlags Or FOF_RENAMEONCOLLISION
      If bDontConfirmFolderCreation Then lFlags = lFlags Or FOF_NOCONFIRMMKDIR
      If bAllowUndo Then lFlags = lFlags Or FOF_ALLOWUNDO
   End If
   '
   ' Important! Double NULL termination because the function actually
   ' ca take an array of file names for both sSource and sDestination
   sSource = sFrom & vbNullChar & vbNullChar
   sDestination = sTo & vbNullChar & vbNullChar
   '
   ' Build the data structure
   With tFileOp
      .wFunc = eOperation
      .pFrom = StrPtr(sSource)
      If LenB(sTo) <> 0 Then
         .pTo = StrPtr(sDestination)
      End If
      .fFlags = lFlags
     ' .hWnd = hWndOwner
     ' .lpszProgressTitle  = StrPtr("Copying/Renaming etc...")
   End With
   '
   ' Ready to make the call ...
   lRes = SHFileOperationW(tFileOp)
   '
   ' If the User hits the Cancel button while the operation is in progress,
   ' the fAnyOperationsAborted parameter will be true (i.e. = 1)
   If lRes = 0 And tFileOp.fAnyOperationsAborted = 0 Then
      pFileOperation = 0
   Else
      pFileOperation = lRes
   End If
   '
   ' Return whether the user (or silent overwrites) hit the Cancel button.
   bIsAborted = (tFileOp.fAnyOperationsAborted <> 0)
            
End Function

'
' FileCopy function with support for Unicode file names, nested folders etc.
' If sSource is a folder FileCopyEx will copy all files and subfolders
' to sDestination (which will be teated as a folder name).
Public Function FileCopyEx(ByRef sSource As String, _
                           ByRef sDestination As String, _
                           Optional ByVal bShowProgress As Boolean = False, _
                           Optional ByVal bConfirmOverwrites As Boolean = False _
                           ) As Boolean

   Dim lRet As Long
   Dim bIsAborted As Boolean
   '
   ' Can't work with qualified paths
   sSource = RemoveBackslash(sSource)
   sDestination = RemoveBackslash(sDestination)
   '
   ' Perform the Copy operation
   lRet = pFileOperation(efocCopy, sSource, sDestination, 0, bIsAborted, Not bShowProgress, Not bConfirmOverwrites, False, Not bConfirmOverwrites, False)
   '
   ' If unsuccesful raise an error
   If lRet <> 0 And (Not bIsAborted) Then
      Err.Raise lRet, MODULE_NAME & "::FileCopyEx", "Error " & " &H" & CStr(Hex(lRet)) & ": " & pGetFileOperationError(lRet)
   End If

   FileCopyEx = (lRet = 0) And (Not bIsAborted)

End Function

'
' Advanced FileDelete function with support for Unicode file names,
' nested folders etc. If sSource is a folder FileDeleteEx will delete
' all files and subfolders in sSource. If bAllowUndo is True the
' function will try to move sSource to Recycle Bin (local drives only).
Public Function FileDeleteEx(ByRef sSource As String, _
                           Optional ByVal bAllowUndo As Boolean = False, _
                           Optional ByVal bShowProgress As Boolean = False, _
                           Optional ByVal bConfirmDelete As Boolean = False _
                           ) As Boolean
   
   #If Mac = 1 Then
      '
      ' MacIntosh
      ' Build a new function using pure VBA functions
      On Error Resume Next
      Kill sSource
      FileDeleteEx = (Err.Number = 0)
      Exit Function
   #End If

   Dim lRet As Long
   Dim bIsAborted As Boolean
   '
   ' Can't work with qualified paths
   sSource = RemoveBackslash(sSource)
   '
   ' Perform the Delete operation
   lRet = pFileOperation(efocDelete, sSource, vbNullString, 0, bIsAborted, Not bShowProgress, Not bConfirmDelete, False, Not bConfirmDelete, bAllowUndo)
   '
   ' If unsuccesful raise an error
   If lRet <> 0 And (Not bIsAborted) Then
      Err.Raise lRet, MODULE_NAME & "::FileDeleteEx", "Error " & " &H" & CStr(Hex(lRet)) & ": " & pGetFileOperationError(lRet)
   End If

   FileDeleteEx = (lRet = 0) And (Not bIsAborted)

End Function

'
' FileMove function with support for Unicode file names, nested folders etc.
' If sSource is a folder FileMoveEx will move all files and subfolders
' to sDestination (which will be teated as a folder name).
Public Function FileMoveEx(ByRef sSource As String, _
                           ByRef sDestination As String, _
                           Optional ByVal bShowProgress As Boolean = False, _
                           Optional ByVal bConfirmOverwrites As Boolean = False _
                           ) As Boolean

   #If Mac = 1 Then
      '
      ' MacIntosh
      ' Build a new function using pure VBA functions
      FileMoveEx = False
      Exit Function
   #End If

   Dim lRet As Long
   Dim bIsAborted As Boolean
   Dim bMustDelete As Boolean
   Dim sToDelete As String
   '
   ' If sSource is a folder we move its *contents*, i.e. files and
   ' subfolders instead of the folder itself. This will leave the
   ' source folder behind on the system, so we signal that we must
   ' delete it.
   If FolderExists(sSource) Then
      sToDelete = RemoveBackslash(sSource)
      sSource = AddBackslash(sSource) & "*.*"
      bMustDelete = True
   End If
   '
   ' Can't work with qualified paths
   sSource = RemoveBackslash(sSource)
   sDestination = RemoveBackslash(sDestination)
   '
   ' Perform the Move operation
   lRet = pFileOperation(efocMove, sSource, sDestination, 0, bIsAborted, Not bShowProgress, Not bConfirmOverwrites, False, Not bConfirmOverwrites, False)
   '
   ' If unsuccesful raise an error
   If lRet <> 0 And (Not bIsAborted) Then
      Err.Raise lRet, MODULE_NAME & "::FileMoveEx", "Error " & " &H" & CStr(Hex(lRet)) & ": " & pGetFileOperationError(lRet)
   End If
   '
   ' Set return value
   FileMoveEx = (lRet = 0) And (Not bIsAborted)
   '
   ' Attempt to delete sSource if required.
   If FileMoveEx And bMustDelete Then
      Call FileDeleteEx(sToDelete, True, False, False)
   End If

End Function

'
' Advanced FileRename function with support for Unicode file names,
' nested folders etc. If sSource is a folder FileRenameEx will rename
' the folder.
Public Function FileRenameEx(ByVal sSource As String, _
                             ByVal sDestination As String, _
                             Optional ByVal bAutoOverwrite As Boolean = False, _
                             Optional ByVal bHideProgressDialog As Boolean = True _
                             ) As Boolean

   #If Mac = 1 Then
      '
      ' MacIntosh
      On Error Resume Next
      If bAutoOverwrite And FileExists(sDestination) Then
         Call FileDeleteEx(sDestination, True, False, False)
      End If
      Name sSource As sDestination
      FileRenameEx = (Err.Number = 0)
      Exit Function
   #End If
   
   Dim lRet As Long
   Dim bIsAborted As Boolean
   '
   ' Can't work with qualified paths
   sSource = RemoveBackslash(sSource)
   '
   ' Can't rename if sDestination exists, so we try to delete sDestination
   ' and send the previous sDestination version to Recycle Bin (if possible).
   If bAutoOverwrite And FileExists(sDestination) Then
      Call FileDeleteEx(sDestination, True, False, False)
   End If
   '
   ' Perform the Rename operation
   lRet = pFileOperation(efocRename, sSource, sDestination, 0, bIsAborted, bHideProgressDialog, True, False, False, False)
   '
   ' If unsuccesful raise an error
   If lRet <> 0 And (Not bIsAborted) Then
      Err.Raise lRet, MODULE_NAME & "::FileRenameEx", "Error " & " &H" & CStr(Hex(lRet)) & ": " & pGetFileOperationError(lRet)
   End If

   FileRenameEx = (lRet = 0) And (Not bIsAborted)

End Function

'
' Blindingly fast FileExists function
Public Function FileExists(ByRef sFileToCheck As String) As Boolean
   
   Dim lRet As Long
   
   #If Mac = 1 Then
      '
      ' !Important: The GetAttr() function may sometimes fail on the MacIntosh when
      ' an *uninitialized* string is passed (vbNullString, vbNullChar or Empty)
      If LenB(Trim$(sFileToCheck)) = 0 Then Exit Function
      '
      ' MacIntosh
      On Error Resume Next
      lRet = GetAttr(sFileToCheck)
      FileExists = (Err.Number = 0)
      On Error GoTo 0
   #Else
      '
      ' Windows
      lRet = PathFileExistsW(StrPtr(sFileToCheck))
      FileExists = (lRet <> 0)
   #End If

End Function

'
' Blindingly fast FolderExists function
Public Function FolderExists(ByRef sPath As String) As Boolean
   
   Dim lRet As Long
   
   #If Mac = 1 Then
      '
      ' !Important: The GetAttr() function may sometimes fail on the MacIntosh when
      ' an *uninitialized* string is passed (vbNullString, vbNullChar or Empty)
      If LenB(Trim$(sPath)) = 0 Then Exit Function
      '
      ' MacIntosh
      On Error Resume Next
      lRet = GetAttr(sPath)
      If Err.Number = 0 Then
         FolderExists = (lRet And vbDirectory)
      End If
      On Error GoTo 0
   #Else
      lRet = PathIsDirectoryW(StrPtr(sPath))
      FolderExists = (lRet <> 0)
   #End If

End Function

'
' Adds "\" if not already there
Public Function AddBackslash(ByVal sPath As String) As String
   
   #If Mac = 1 Then
      '
      ' MacIntosh
      Dim sFirstPart As String
      sFirstPart = sPath
      If LenB(sFirstPart) <> 0 Then
         If Right$(sFirstPart, 1) = WE_PATH_SEPARATOR Then
            AddBackslash = sFirstPart
         Else
            AddBackslash = sFirstPart & WE_PATH_SEPARATOR
         End If
      Else
         '
         ' Perhaps wrong. Let's see if this is a problem.
         AddBackslash = WE_PATH_SEPARATOR
      End If
   #Else
      '
      ' Windows
      #If VBA7 Then
         Dim lpAddr As LongPtr
      #Else
         Dim lpAddr As Long
      #End If
      lpAddr = StrPtr(pPadBuffer(sPath))
      Call PathAddBackslashW(lpAddr)
      AddBackslash = pPtr2StrW(lpAddr)
   #End If

End Function

'
' Removes ending "\", if available
Public Function RemoveBackslash(ByVal sPath As String) As String
   
   #If Mac = 1 Then
      '
      ' MacIntosh
      Dim sFirstPart As String
      sFirstPart = sPath
      If LenB(sFirstPart) <> 0 Then
         If Right$(sFirstPart, 1) = WE_PATH_SEPARATOR Then
            RemoveBackslash = Mid$(sFirstPart, 1, Len(sFirstPart) - 1)
         Else
            RemoveBackslash = sFirstPart
         End If
      End If
   #Else
      '
      ' Windows
      #If VBA7 Then
         Dim lpAddr As LongPtr
      #Else
         Dim lpAddr As Long
      #End If
      lpAddr = StrPtr(sPath)
      Call PathRemoveBackslashW(lpAddr)
      RemoveBackslash = pPtr2StrW(lpAddr)
   #End If

End Function
  
'
' Removes the extension, if any.
Public Function RemoveExtension(ByVal sPath As String) As String
   
   #If SIMULATE_MAC = 1 Or Mac = 1 Then
   
      Dim lPos As Long
      Dim lStart As Long
      Dim sTemp As String
      '
      ' Don't make mistakes. Paths can contain "." in their name, so we need
      ' to assure that we have our hands on the last part of the path before
      ' we look for the extension.
      lStart = InStrRev(sPath, WE_PATH_SEPARATOR, , vbTextCompare)
      If lStart <> 0 Then
         lPos = InStr(lStart, sPath, ".", vbTextCompare)
      Else
         lPos = InStrRev(sPath, ".", , vbTextCompare)
      End If
      '
      ' Any extension found?
      If lPos <> 0 Then
         RemoveExtension = Mid$(sPath, 1, lPos - 1)
      Else
         RemoveExtension = sPath
      End If
   
   #Else
   
      #If VBA7 Then
         Dim lpAddr As LongPtr
      #Else
         Dim lpAddr As Long
      #End If
      lpAddr = StrPtr(sPath)
      Call PathRemoveExtensionW(lpAddr)
      RemoveExtension = pPtr2StrW(lpAddr)
   
   #End If
   
End Function

'
' Renames the extension of the Path if there is one, or adds the extension if there is none.
Public Function RenameExtension(ByVal sPath As String, ByVal sExtension As String) As String
   
   #If SIMULATE_MAC = 1 Or Mac = 1 Then
      
      sPath = RemoveExtension(sPath)
      pQualifyExtension sExtension
      RenameExtension = sPath & sExtension
   
   #Else
      #If VBA7 Then
         Dim lpAddr As LongPtr
      #Else
         Dim lpAddr As Long
      #End If
      pQualifyExtension sExtension
      lpAddr = StrPtr(pPadBuffer(sPath))
      Call PathRenameExtensionW(lpAddr, StrPtr(sExtension))
      RenameExtension = pPtr2StrW(lpAddr)
   #End If
End Function

'
' Searches a string using a Microsoft MS-DOS wild card match type.
' Supports several masks separated by semicolon, eg. "*.doc;*.txt;*.xls"
Public Function IsMatchingSearchMask(ByRef sFileName As String, ByRef sMask As String) As Boolean
   
   #If Mac = 1 Or SIMULATE_MAC = 1 Then
      IsMatchingSearchMask = IsMatchingSearchMaskMac(sFileName, sMask)
   #Else
      IsMatchingSearchMask = (PathMatchSpecW(StrPtr(sFileName), StrPtr(sMask)) <> 0)
   #End If
   
End Function

Private Function IsMatchingSearchMaskMac(ByRef sFileName As String, ByVal sMask As String) As Boolean
   '
   ' sMask may contain several DOS file specifications and wildcards,
   ' separated by semicolon. This is no problem on Windows, but on
   ' MacIntosh wildcards are not supported. Hence, a lot of work.
   '
   ' TODO: Check if the "*" character is legal in a file name on MacIntosh
   '
   Dim i As Long
   Dim J As Long
   Dim saMasks() As String
   Dim saThisMask() As String
   Dim bFound As Boolean
   Dim lPos1 As Long
   Dim lPos2 As Long
   '
   ' First a sanity check. If all files are required we don't bother
   ' about filtering.
   If LenB(sMask) <> 0 Then
      If sMask = "*" Or sMask = "*.*" Then
         IsMatchingSearchMaskMac = True
         Exit Function
      End If
      '
'      lPos1 = InStr(1, sMask, "\")
'      If lPos1 <> 0 Then sMask = Mid$(sMask, lPos1 + 1)
      '
      ' Check each mask segment
      saMasks = VBA.Split(sMask, ";", , vbTextCompare)
      For i = LBound(saMasks) To UBound(saMasks)
         '
         ' Each segment may contain a "*" in the file part of the name
         ' and again in the extension part. Hence, we need to divide
         ' the mask string into pieces, and check for each match.
         '
         ' Remove the "\" character. It's used as an escape for special characters
         ' and is required by the Windows API in some cases, but not here.
         lPos1 = InStr(1, saMasks(i), "\")
         If lPos1 <> 0 Then saMasks(i) = Mid$(saMasks(i), lPos1 + 1)
         
         saThisMask = VBA.Split(saMasks(i), "*", , vbTextCompare)
         For J = LBound(saThisMask) To UBound(saThisMask)
            '
            ' "*" was not present, so we need an exact match
            If UBound(saThisMask) = 0 Then
               If saThisMask(0) = sFileName Then
                  bFound = True
                  Exit For
               End If
            '
            ' "*" was the first character, and we didn't have a second "*".
            ' Hence, everything right of the "*" position requires an exact match
            ElseIf UBound(saThisMask) = 1 And LenB(saThisMask(0)) = 0 Then
               lPos1 = Len(saThisMask(1))
               bFound = (Right(sFileName, lPos1) = saThisMask(1))
               If bFound Then Exit For
            
            ' "*" was the first character and the last character.
            ' Hence, what's in between those "*" markers can match
            ElseIf UBound(saThisMask) = 2 And LenB(saThisMask(0)) = 0 Then
               bFound = (InStr(1, sFileName, saThisMask(1), vbTextCompare) <> 0)
               If bFound Then Exit For
            
            ' "*" was NOT the first character, and we didn't find a second.
            ' Hence, everything right of the "*" position requires an exact match
            ElseIf UBound(saThisMask) = 1 And LenB(saThisMask(0)) <> 0 Then
               lPos1 = Len(saThisMask(0))
               If Left(sFileName, lPos1) = saThisMask(0) Then
                  bFound = (Right(sFileName, lPos1) = saThisMask(1))
                  If bFound Then Exit For
               End If
            
            ' "*" was NOT the first character, BUT we found a second.
            ' Hence, what's in between those "*" markers can match
            ElseIf UBound(saThisMask) = 2 And LenB(saThisMask(0)) <> 0 Then
               lPos1 = Len(saThisMask(0))
               If Left(sFileName, lPos1) = saThisMask(0) Then
                  bFound = (InStr(lPos1 + 1, sFileName, saThisMask(1), vbTextCompare) <> 0)
                  If bFound Then Exit For
               End If
            
            Else
               Err.Raise 13, MODULE_NAME & "::IsMatchingSearchMask", "The MacIntosh version of this function doesn't support the """ & saMasks(i) & " entry."
            End If
          
         Next ' J = LBound(saThisMask) To UBound(saThisMask)
          
         If bFound Then Exit For
          
      Next ' I = LBound(saMasks) To UBound(saMasks)
      
      IsMatchingSearchMaskMac = bFound
      Exit Function
   Else
      '
      ' Mask is not specified, so we can't find a match.
      ' Potential Error or Debug message goes here
   End If

End Function

Public Function GetFileList(ByRef oFileList As cPropertyBag, _
                            ByVal sFromPath As String, _
                            Optional ByVal sFileIncludeMask As String = "*.*", _
                            Optional ByVal sFileExcludeMask As String, _
                            Optional ByVal bIncludeFolderNames As Boolean = True, _
                            Optional ByVal sFolderExcludeMask As String, _
                            Optional ByVal bRemoveFileExtensions As Boolean, _
                            Optional ByVal bRecursiveDepth As Boolean) As Boolean
   
   On Error GoTo BailOut
   '
   ' Prepare the File Object we return
   If oFileList Is Nothing Then
      Set oFileList = New cPropertyBag
   Else
      oFileList.Clear
   End If
   
   Dim sThisFile As String
   
   sFromPath = FillVariables(AddBackslash(sFromPath))
   '
   ' Initialize Dir$() to return all files (and folders) found
   If bIncludeFolderNames Then
      sThisFile = Dir$(sFromPath, vbDirectory)
   Else
      sThisFile = Dir$(sFromPath)
   End If
   '
   ' Walk through the full file list and filter according to sFileMask
   While LenB(Trim$(sThisFile)) <> 0

      If FolderExists(sFromPath & sThisFile) Then
         '
         ' Filter the MS DOS "." and ".." entries
         ' (and any file name name starting with ".")
         If Asc(sThisFile) <> vbDot Then
            '
            ' Black-listed folder? If not, we add it
            If Not IsMatchingSearchMask(sThisFile, sFolderExcludeMask) Then
               '
               ' JAS TODO: Here we could check for other filters, such as eg.
               ' FolderIsEmpty etc. (and bRecursiveDepth)
              ' If bIncludeFolderNames Then
                  oFileList.Add sFromPath & sThisFile, sThisFile, vbDirectory
              ' End If
              ' If bRecursiveDepth Then
                 ' Call GetFileList(oFileList, sFromPath & sThisFile, sFileIncludeMask, sFileExcludeMask, bIncludeFolderNames, sFolderExcludeMask, bRemoveFileExtensions, bRecursiveDepth)
              '    Call GetFileList(oFileList, sFromPath & sThisFile, sFileIncludeMask, sFileExcludeMask, False, sFolderExcludeMask, bRemoveFileExtensions, bRecursiveDepth)
              ' End If
            End If
         End If
      Else
         '
         ' First check. Include the file?
         If IsMatchingSearchMask(sThisFile, sFileIncludeMask) Then
            '
            ' ... or is it black-listed? If not, we add the file.
            If Not IsMatchingSearchMask(sThisFile, sFileExcludeMask) Then
               If Not bRemoveFileExtensions Then
                  oFileList.Add sFromPath & sThisFile, sThisFile
               Else
                  oFileList.Add sFromPath & sThisFile, RemoveExtension(sThisFile)
               End If
            End If ' Not IsMatchingSearchMask (Exceptions)
         End If ' IsMatchingSearchMask (choice)
      End If ' FolderExists(sFromPath & sThisFile)
      '
      ' Get next file item
      sThisFile = Dir$
   Wend ' LenB(Trim$(sThisFile)) <> 0
 
   GetFileList = (oFileList.Count <> 0)
 
   GoTo EndFunction
   
BailOut:
   DebugMsg MODULE_NAME & "::GetFileList: Error " & CStr(Err.Number) & " / " & Err.Description & " (" & sFromPath & ")", dbgLogError
   Resume Next
   
EndFunction:
 
 
End Function

Public Function GetFileListWithIANAfilter(ByRef oFileList As cPropertyBag, _
                            ByVal sFromPath As String, _
                            Optional ByVal sFileIncludeMask As String = "*.*", _
                            Optional ByVal sFileExcludeMask As String, _
                            Optional ByVal bIncludeFolderNames As Boolean = True, _
                            Optional ByVal sFolderExcludeMask As String, _
                            Optional ByVal bRemoveFileExtensions As Boolean, _
                            Optional ByVal sIANAincludeMask As String) As Boolean
   '
   ' Prepare the File Object we return
   If oFileList Is Nothing Then
      Set oFileList = New cPropertyBag
   Else
      oFileList.Clear
   End If
   
   Dim sThisFile As String
   
   sFromPath = FillVariables(AddBackslash(sFromPath))
   '
   ' Initialize Dir$() to return all files (and folders) found
   If bIncludeFolderNames Then
      sThisFile = Dir$(sFromPath, vbDirectory)
   Else
      sThisFile = Dir$(sFromPath)
   End If
   '
   ' Walk through the full file list and filter according to sFileMask
   While LenB(Trim$(sThisFile)) <> 0

      If FolderExists(sFromPath & sThisFile) Then
         '
         ' Filter the MS DOS "." and ".." entries
         ' (and any file name name starting with ".")
         If Asc(sThisFile) <> vbDot Then
            '
            ' Black-listed folder? If not, we add it
            If Not IsMatchingSearchMask(sThisFile, sFolderExcludeMask) Then
               '
               ' TODO: Here we could check for other filters, such as eg.
               ' FolderIsEmpty etc.
               oFileList.Add sFromPath & sThisFile, sThisFile, vbDirectory
            End If
         End If
      Else
         '
         ' First check. Include the file?
         If IsMatchingSearchMask(sThisFile, sFileIncludeMask) Then
            '
            ' ... or is it black-listed? If not, we add the file.
            If Not IsMatchingSearchMask(sThisFile, sFileExcludeMask) Then
            
               ' Folder with IANA string?
               If Not IsMatchingSearchMask(sThisFile, "*_??-??.*") Then
                  If Not bRemoveFileExtensions Then
                     oFileList.Add sFromPath & sThisFile, sThisFile
                  Else
                     oFileList.Add sFromPath & sThisFile, RemoveExtension(sThisFile)
                  End If
               Else
                  '
                  ' If yes - does it macth our IANA string?
                  If IsMatchingSearchMask(sThisFile, "*_" & sIANAincludeMask & ".*") Then
                     '
                     'Remove IANA code from filename
                     If Not bRemoveFileExtensions Then
                        oFileList.Add sFromPath & sThisFile, Replace(sThisFile, "_" & sIANAincludeMask, "", , , vbTextCompare)
                     Else
                        oFileList.Add sFromPath & sThisFile, RemoveExtension(Replace(sThisFile, "_" & sIANAincludeMask, "", , , vbTextCompare))
                     End If
                  End If
               End If
            
            End If ' Not IsMatchingSearchMask (Exceptions)
         End If ' IsMatchingSearchMask (choice)
      End If ' FolderExists(sFromPath & sThisFile)
      '
      ' Get next file item
      sThisFile = Dir$
   Wend ' LenB(Trim$(sThisFile)) <> 0
 
   GetFileListWithIANAfilter = (oFileList.Count <> 0)
 
End Function

Public Function GetFolderList(ByRef oFolderList As cPropertyBag, _
                              ByVal sFromPath As String, _
                              Optional ByVal sFolderExcludeMask As String) As Boolean
   '
   ' Prepare the Folder Object we return
   If oFolderList Is Nothing Then
      Set oFolderList = New cPropertyBag
   Else
      oFolderList.Clear
   End If
   
   If LenB(sFolderExcludeMask) = 0 Then
      '
      ' Important! Otherwise IsMatchingSearchMask() below will return
      ' rubbish, since the mask is "" which is NOT the same as vbNullString
      ' when working with pointers
      sFolderExcludeMask = vbNullString
   End If
   
   Dim sThisFolder As String
   
   sFromPath = AddBackslash(sFromPath)
   '
   ' Initialize Dir$() to return all folders found
   sThisFolder = Dir$(sFromPath, vbDirectory)
   '
   ' Walk through the full Folder list and filter according to sFolderExcludeMask
   While LenB(Trim$(sThisFolder)) <> 0
 
      If FolderExists(sFromPath & sThisFolder) Then
         '
         ' Filter the MS DOS "." and ".." entries
         ' (and any Folder name name starting with ".")
         If Asc(sThisFolder) <> vbDot Then
            '
            ' Black-listed folder? If not, we add it
            If Not IsMatchingSearchMask(sThisFolder, sFolderExcludeMask) Then
               '
               ' TODO: Here we could check for other filters, such as eg.
               ' FolderIsEmpty etc.
               oFolderList.Add sFromPath & sThisFolder, sThisFolder, vbDirectory
            End If
         End If
      
      End If
      '
      ' Get next Folder item
      sThisFolder = Dir$
      
   Wend ' LenB(Trim$(sThisFolder)) <> 0
   GetFolderList = (oFolderList.Count <> 0)
End Function

Public Function GetFolderListWithIANAfilter(ByRef oFolderList As cPropertyBag, _
                              ByVal sFromPath As String, _
                              Optional ByVal sFolderExcludeMask As String, _
                              Optional ByVal sIANAincludeMask As String) As Boolean
   '
   ' Prepare the Folder Object we return
   If oFolderList Is Nothing Then
      Set oFolderList = New cPropertyBag
   Else
      oFolderList.Clear
   End If
   
   If LenB(sFolderExcludeMask) = 0 Then
      '
      ' Important! Otherwise IsMatchingSearchMask() below will return
      ' rubbish, since the mask is "" which is NOT the same as vbNullString
      ' when working with pointers
      sFolderExcludeMask = vbNullString
   End If
   
   If LenB(sIANAincludeMask) = 0 Then
      '
      ' Important! Otherwise IsMatchingSearchMask() below will return
      ' rubbish, since the mask is "" which is NOT the same as vbNullString
      ' when working with pointers
      sIANAincludeMask = vbNullString
   End If
   
   Dim sThisFolder As String
   
   sFromPath = AddBackslash(sFromPath)
   '
   ' Initialize Dir$() to return all folders found
   sThisFolder = Dir$(sFromPath, vbDirectory)
   '
   ' Walk through the full Folder list and filter according to sFolderExcludeMask
   While LenB(Trim$(sThisFolder)) <> 0
 
      If FolderExists(sFromPath & sThisFolder) Then
         '
         ' Filter the MS DOS "." and ".." entries
         ' (and any Folder name name starting with ".")
         If Asc(sThisFolder) <> vbDot Then
            '
            ' Black-listed folder? If not, we add it
            If Not IsMatchingSearchMask(sThisFolder, sFolderExcludeMask) Then
               '
               ' Folder with IANA string?
               If Not IsMatchingSearchMask(sThisFolder, "*_??-??*") Then
                  oFolderList.Add sFromPath & sThisFolder, sThisFolder, vbDirectory
               Else
                  '
                  ' If yes - does it macth our IANA string?
                  If IsMatchingSearchMask(sThisFolder, "*_" & sIANAincludeMask & "*") Then
                     '
                     'Remove IANA code from filename
                     oFolderList.Add sFromPath & sThisFolder, Replace(sThisFolder, "_" & sIANAincludeMask, "", , , vbTextCompare), vbDirectory
                  End If
               End If
      
            End If
         End If
      
      End If
      '
      ' Get next Folder item
      sThisFolder = Dir$
      
   Wend ' LenB(Trim$(sThisFolder)) <> 0
   GetFolderListWithIANAfilter = (oFolderList.Count <> 0)
End Function

Public Function GetShortName(ByRef sFileName As String) As String
   
   #If Mac = 1 Then
      '
      ' MacIntosh
      ' TODO: Find a way to overcome the file name length limitation
      GetShortName = sFileName
      Exit Function
   #End If
   
   Dim lRet As Long
   Dim sTemp As String
     
   If Not FileExists(sFileName) Then
      Err.Raise 53, MODULE_NAME & "::GetShortName", "The file """ & sFileName & """ not found."
      Exit Function
   End If
   
   sTemp = String$(MAX_PATH, 0)
   lRet = GetShortPathNameW(StrPtr(sFileName), StrPtr(sTemp), Len(sTemp) * 2)
   GetShortName = pPtr2StrW(StrPtr(sTemp))

End Function

'
' Returns the Extension from a Path name.
Public Function GetFileExtension(ByVal sPath As String) As String
   
   #If SIMULATE_MAC = 1 Or Mac = 1 Then
      Dim lPos As Long
      Dim lStart As Long
      Dim sTemp As String
      '
      ' Don't make mistakes. Paths can contain "." in their name, so we need
      ' to assure that we have our hands on the last part of the path before
      ' we look for the extension.
      lStart = InStrRev(sPath, WE_PATH_SEPARATOR, , vbTextCompare)
      If lStart <> 0 Then
         lPos = InStr(lStart, sPath, ".", vbTextCompare)
      Else
         lPos = InStrRev(sPath, ".", , vbTextCompare)
      End If
      '
      ' Any extension found?
      If lPos <> 0 Then
         GetFileExtension = Mid$(sPath, lPos)
      Else
         GetFileExtension = ""
      End If
   
   #Else
      GetFileExtension = pPtr2StrW(PathFindExtensionW(StrPtr(sPath)))
   #End If
End Function

'
' Returns the filename from a Path name.
Public Function GetFileName(ByVal sPath As String) As String
   
   #If SIMULATE_MAC = 1 Or Mac = 1 Then
      
      Dim lStart As Long
      
      lStart = InStrRev(sPath, WE_PATH_SEPARATOR, , vbTextCompare)
      If lStart <> 0 Then
         GetFileName = Mid$(sPath, lStart + 1)
      Else
         GetFileName = sPath
      End If
   
   #Else
   
      GetFileName = pPtr2StrW(PathFindFileNameW(StrPtr(sPath)))

   #End If

End Function

'
' Returns the folder name from a Path name.
Public Function GetFolderName(ByVal sPath As String) As String
   
   #If SIMULATE_MAC = 1 Or Mac = 1 Then
      Dim lPos As Long
      Dim lStart As Long
      Dim sTemp As String
      
      lStart = InStrRev(sPath, WE_PATH_SEPARATOR, , vbTextCompare)
      '
      ' Don't preserve trailing backslash, since we need to be
      ' compatible with PathRemoveFileSpecW() on Windows.
      If lStart <> 0 Then
         GetFolderName = Mid$(sPath, 1, lStart - 1)
      Else
         GetFolderName = sPath
      End If
   
   #Else
   
      #If VBA7 Then
         Dim lpAddr As LongPtr
      #Else
         Dim lpAddr As Long
      #End If
      lpAddr = StrPtr(sPath)
      Call PathRemoveFileSpecW(lpAddr)
      GetFolderName = pPtr2StrW(lpAddr)
   
   #End If

End Function

#If VBA7 Then
   Public Function ShowFileOpenDialog(ByRef sFileName As String, _
                                      Optional ByRef sFileTitle As String, _
                                      Optional ByVal bFileMustExist As Boolean = True, _
                                      Optional ByVal bMultiSelect As Boolean = False, _
                                      Optional ByRef bReadOnly As Boolean = False, _
                                      Optional ByVal bHideReadOnly As Boolean = False, _
                                      Optional ByRef sFilter As String = "Text files (*.ini;*.txt;*.xml;*.json)|*.ini;*.txt;*.xml;*.json|All files (*.*)|*.*", _
                                      Optional ByRef lFilterIndex As Long = 1, _
                                      Optional ByRef sInitDir As String, _
                                      Optional ByRef sDialogTitle As String, _
                                      Optional ByRef sDefaultExtension As String, _
                                      Optional ByVal hOwner As LongPtr = -1, _
                                      Optional ByVal eFlags As enOpenFileConstants = 0) As Boolean
#Else
   Public Function ShowFileOpenDialog(ByRef sFileName As String, _
                                      Optional ByRef sFileTitle As String, _
                                      Optional ByVal bFileMustExist As Boolean = True, _
                                      Optional ByVal bMultiSelect As Boolean = False, _
                                      Optional ByRef bReadOnly As Boolean = False, _
                                      Optional ByVal bHideReadOnly As Boolean = False, _
                                      Optional ByRef sFilter As String = "Text files (*.ini;*.txt;*.xml;*.json)|*.ini;*.txt;*.xml;*.json|All files (*.*)|*.*", _
                                      Optional ByRef lFilterIndex As Long = 1, _
                                      Optional ByRef sInitDir As String, _
                                      Optional ByRef sDialogTitle As String, _
                                      Optional ByRef sDefaultExtension As String, _
                                      Optional ByVal hOwner As Long = -1, _
                                      Optional ByVal eFlags As enOpenFileConstants = 0) As Boolean
#End If

   Dim tOfn As OPENFILENAMEW
   Dim sTemp As String
   Dim sFilterTemp As String
   Dim lRet As Long
   Dim eRet As enCommonDialogErrors
   Dim sError As String
   Dim i As Long
   Dim saTemp() As String  ' Buffer to hold return values if bMultiSelect is True
   
   #If Mac = 1 Then
      On Error Resume Next
      sTemp = MacScript("Choose File")
      On Error GoTo 0
      If LenB(sTemp) <> 0 Then
         sFileName = sTemp
         sFileTitle = GetFileName(sFileName)
         ShowFileOpenDialog = True
      End If
      Exit Function
   #End If
   '
   ' Setup the dialog parameters
   If eFlags = 0 Then
      eFlags = OFN_EXPLORER Or OFN_EXTENSIONDIFFERENT Or OFN_DONTADDTORECENT  'Or OFN_CREATEPROMPT
   End If
   
   With tOfn
      .lStructSize = LenB(tOfn)  ' Important on 64-bit windows to use LenB() instead of Len()
      
      .eFlags = (-bFileMustExist * OFN_FILEMUSTEXIST) Or _
                (-bMultiSelect * OFN_ALLOWMULTISELECT) Or _
                (-bReadOnly * OFN_READONLY) Or _
                (-bHideReadOnly * OFN_HIDEREADONLY) Or _
                (eFlags And CLng(Not (OFN_ENABLEHOOK Or OFN_ENABLETEMPLATE)))
      
      If hOwner <> -1 Then .hwndOwner = hOwner
      
      .lpstrInitialDir = StrPtr(sInitDir)
      .lpstrDefExt = StrPtr(sDefaultExtension)
      .lpstrTitle = StrPtr(sDialogTitle)
      
      ' To make Windows-style filter we replace | with vbNullChar
      sFilterTemp = Replace(sFilter, "|", vbNullChar, , , vbBinaryCompare)
      
      sFilterTemp = sFilterTemp & vbNullChar & vbNullChar
      .lpstrFilter = StrPtr(sFilterTemp)
      .nFilterIndex = lFilterIndex
      '
      ' TODO: Allocate a reasonable buffer in case of MultiSelect
      If bMultiSelect Then
         sTemp = pPadBuffer(sFileName) ', 32767)
      Else
         sTemp = pPadBuffer(sFileName)
      End If
      
      .lpstrFile = StrPtr(sTemp)
      .nMaxFile = Len(sTemp)
      
      sTemp = pPadBuffer(sFileTitle)
      .lpstrFileTitle = StrPtr(sTemp)
      .nMaxFileTitle = Len(sTemp)
      
      lRet = GetOpenFileNameW(VarPtr(tOfn))
      Select Case lRet
         '
         ' Cancel or error
         Case 0
            ShowFileOpenDialog = False
            sFileName = ""
            sFileTitle = ""
            eFlags = 0
            lFilterIndex = -1
            sFilter = ""
            '
            ' Check for errors
            eRet = CommDlgExtendedError()
            If eRet <> CDERR_GENERALCODES Then
               '
               ' Error codes does not match system errors, so we have our own translation
               ' table for the enCommonDialogErrors enum.
               sError = pGetCommonDialogError(eRet)
               Err.Raise eRet, MODULE_NAME & "::ShowFileOpenDialog", "GetOpenFileName failed with error code " & " &H" & CStr(Hex(eRet)) & ": " & sError
            End If
         '
         ' Success
         Case Else
            ShowFileOpenDialog = True
            '
            ' If multi-select was enabled sFileName contain an array of
            ' files with FilePath as element 0 and the FileNames as elements 1
            ' to N. We reformat the string to use "|" as separator.
            If bMultiSelect Then
               sFileTitle = vbNullString
               sFileName = pPtr2StrW(.lpstrFile, MAX_PATH)
               saTemp = Split(sFileName, vbNullChar, , vbBinaryCompare)
               For i = LBound(saTemp) To UBound(saTemp)
                  If Len(saTemp(i)) <> 0 Then
                     If i = 0 Then
                        sFileName = saTemp(i)
                     Else
                        sFileName = sFileName & vbCr & saTemp(i)
                     End If
                  Else
                     Exit For
                  End If
               Next
            Else
               sFileTitle = pPtr2StrW(.lpstrFileTitle)
               sFileName = pPtr2StrW(.lpstrFile)
            End If
            
            eFlags = .eFlags
            lFilterIndex = .nFilterIndex
            '
            ' Look up the filter selected by the user
            sFilter = pFilterLookup(sFilter, lFilterIndex)
            
            If (.eFlags And OFN_READONLY) Then bReadOnly = True
      End Select
   
   End With

End Function

#If VBA7 Then
   Function ShowFileSaveDialog(ByRef sFileName As String, _
                               Optional ByRef sFileTitle As String, _
                               Optional ByRef bOverWritePrompt As Boolean = True, _
                               Optional ByRef sFilter As String = "All (*.*)| *.*", _
                               Optional ByRef lFilterIndex As Long = 1, _
                               Optional ByRef sInitialDir As String, _
                               Optional ByRef sDialogTitle As String, _
                               Optional ByRef sDefaultExtension As String, _
                               Optional ByVal hOwner As LongPtr = -1, _
                               Optional ByVal eFlags As enOpenFileConstants = 0) As Boolean
#Else
   Function ShowFileSaveDialog(ByRef sFileName As String, _
                               Optional ByRef sFileTitle As String, _
                               Optional ByRef bOverWritePrompt As Boolean = True, _
                               Optional ByRef sFilter As String = "All (*.*)| *.*", _
                               Optional ByRef lFilterIndex As Long = 1, _
                               Optional ByRef sInitialDir As String, _
                               Optional ByRef sDialogTitle As String, _
                               Optional ByRef sDefaultExtension As String, _
                               Optional ByVal hOwner As Long = -1, _
                               Optional ByVal eFlags As enOpenFileConstants = 0) As Boolean
#End If
   Dim tOfn As OPENFILENAMEW
   Dim sTemp As String
   Dim yTempName() As Byte    ' Better to use Byte Arrays, since we that way can go beyond MAXPATH to 32.000 chars
   Dim yTempTitle() As Byte   ' TODO: Implement into ShowFileOpenDialog() as well
   Dim lRet As Long
   Dim eRet As enCommonDialogErrors
   Dim sError As String

   With tOfn
      .lStructSize = LenB(tOfn)
      
      .eFlags = (-bOverWritePrompt * OFN_OVERWRITEPROMPT) Or OFN_HIDEREADONLY Or _
                (eFlags And CLng(Not (OFN_ENABLEHOOK Or OFN_ENABLETEMPLATE)))
      
      If hOwner <> -1 Then
         .hwndOwner = hOwner
      End If
      
      .lpstrInitialDir = StrPtr(sInitialDir)
      .lpstrTitle = StrPtr(sDialogTitle)
      .lpstrDefExt = StrPtr(sDefaultExtension)
            
      ' Make new sFilter with bars (|) replacing nulls and double null at end
      Dim ch As String, i As Integer
      For i = 1 To Len(sFilter)
          ch = Mid$(sFilter, i, 1)
          If ch = "|" Or ch = ":" Then
              sTemp = sTemp & vbNullChar
          Else
              sTemp = sTemp & ch
          End If
      Next
      '
      ' Important! Put double null at end
      sTemp = sTemp & vbNullChar & vbNullChar
      .lpstrFilter = StrPtr(sTemp)
      .nFilterIndex = lFilterIndex
      
      ' Pad file and file title buffers to maximum path
      yTempName = sFileName 'pStringToByteArray(FileName, True, True)
      ReDim Preserve yTempName(0 To 32767) As Byte
      .lpstrFile = VarPtr(yTempName(0))
      .nMaxFile = UBound(yTempName) + 1
      '
      ' Open the dialog
      lRet = GetSaveFileNameW(VarPtr(tOfn))
      Select Case lRet
         '
         ' The Dialog was cancelled by the user or an error occurred
         Case 0
            ShowFileSaveDialog = False
            sFileName = ""
            sFileTitle = ""
            eFlags = 0
            lFilterIndex = 0
            sFilter = ""
            '
            ' Check for errors
            eRet = CommDlgExtendedError()
            If eRet <> 0 Then
               '
               ' Error codes does not match system errors, so we have our own translation
               ' table for the enCommonDialogErrors enum.
               sError = pGetCommonDialogError(eRet)
               Err.Raise eRet, MODULE_NAME & "::ShowFileSaveDialog", "GetSaveFileName failed with error code " & " &H" & CStr(Hex(eRet)) & ": " & sError
            End If
         '
         ' The function succeded
         Case Else
            ShowFileSaveDialog = True
            sFileName = pPtr2StrW(.lpstrFile)
            sFileTitle = pPtr2StrW(.lpstrFileTitle)
            eFlags = .eFlags
            lFilterIndex = .nFilterIndex
            '
            ' Look up the filter selected by the user
            sFilter = pFilterLookup(sFilter, lFilterIndex)
      End Select
   
   End With

End Function

'
' Looks up the filter name for the provided filter index.
Private Function pFilterLookup(ByVal sFilters As String, ByVal lCurFilterIndex As Long) As String
   Dim lStart As Long
   Dim lEnd As Long
   Dim sTemp As String
   
   lStart = 1
   If sFilters = "" Then Exit Function
   
   Do
      lEnd = InStr(lStart, sFilters, "|")
      If lEnd = 0 Then Exit Function
      
      lEnd = InStr(lEnd + 1, sFilters, "|")
      If lEnd <> 0 Then
          sTemp = Mid$(sFilters, lStart, lEnd - lStart)
      Else
          sTemp = Mid$(sFilters, lStart)
      End If
      
      lStart = lEnd + 1
      If lCurFilterIndex = 1 Then
          pFilterLookup = sTemp
          Exit Function
      End If
      
      lCurFilterIndex = lCurFilterIndex - 1
      
   Loop While lCurFilterIndex
   
End Function

'
' Truncates sPath to fit within the specified number of characters.
Public Function CompactPathByChars(ByRef sPath As String, ByVal MaxChars As Long) As String
   Dim strBuff As String * MAX_PATH
   #If VBA7 Then
      Dim lpAddr As LongPtr
   #Else
      Dim lpAddr As Long
   #End If
   lpAddr = StrPtr(strBuff)
   Call PathCompactPathExW(lpAddr, StrPtr(sPath), MaxChars + 1, 0)
   CompactPathByChars = pPtr2StrW(lpAddr)
End Function

'
' Combines two Path components, inserting a backslash if needed.
Public Function CombinePaths(ByVal sPath As String, ByVal sFile As String) As String
   
   #If Mac = 1 Or SIMULATE_MAC = 1 Then
      '
      ' MacIntosh
      Dim sFirstPart As String
      Dim sNextPart As String
      '
      ' Temporary storage. Important!
      sFirstPart = RemoveBackslash(sPath)
      sNextPart = sFile
      
      If LenB(sPath) <> 0 Then
         If Left$(sNextPart, 1) = WE_PATH_SEPARATOR Then
            sNextPart = Mid$(sNextPart, 2)
         End If
         CombinePaths = AddBackslash(sFirstPart) & sNextPart
      Else
         CombinePaths = sFile
      End If
   
   #Else
      '
      ' Windows
      #If VBA7 Then
         Dim lpAddr As LongPtr
      #Else
         Dim lpAddr As Long
      #End If
      lpAddr = StrPtr(pPadBuffer(sPath))
      Call PathAppendW(lpAddr, StrPtr(sFile))
      CombinePaths = pPtr2StrW(lpAddr)

   #End If

End Function
   
'
' Encloses sPath in quotes if sPath contains spaces.
Public Function QuotePath(ByVal sPath As String) As String
   #If VBA7 Then
      Dim lpAddr As LongPtr
   #Else
      Dim lpAddr As Long
   #End If
   lpAddr = StrPtr(pPadBuffer(sPath))
   Call PathQuoteSpacesW(lpAddr)
   QuotePath = pPtr2StrW(lpAddr)
End Function
  
'
' Removes any leading and trailing quotes from the Path.
Public Function UnquotePath(ByVal sPath As String) As String
   #If VBA7 Then
      Dim lpAddr As LongPtr
   #Else
      Dim lpAddr As Long
   #End If
   lpAddr = StrPtr(sPath)
   Call PathUnquoteSpacesW(lpAddr)
   UnquotePath = pPtr2StrW(lpAddr)
End Function

'
' See http://en.wikipedia.org/wiki/Byte_order_mark
Public Function FileContentIsUnicode(ByVal sFileName As String) As Boolean
   
   Dim yaData(0 To 1) As Byte
   Dim sShortName As String
   Dim lFileNo As Long
   
   If FileExists(sFileName) And Not FolderExists(sFileName) Then
      '
      ' If sFileName is in Unicode and contain DBCS characters we
      ' MUST use the MS-DOS name on non-DBCS systems. Otherwise the
      ' "Open" statement will fail with error 52 - Bad File name or number.
      sShortName = GetShortName(sFileName)
      If FileLen(sShortName) > 1 Then
   
         lFileNo = FreeFile
         Open sShortName For Binary Access Read As #lFileNo
         Get #lFileNo, , yaData
         Close #lFileNo
   
         If UBound(yaData) > 0 Then
            If ((yaData(0) = &HFF And yaData(1) = &HFE)) Then
               FileContentIsUnicode = True
            End If
         End If
      End If
   End If
   
End Function

'
' Returns the path of special folders
Public Function GetSpecialFolder(ByVal eCSIDL As enCSIDLConstants) As String
       
   #If Mac = 1 Then
      '
      ' This concept MUST be followed for compatibility reasons
      ' applications folder
      ' documents folder
      ' favorites folder
      ' home folder
      ' library folder
      ' movies folder
      ' music folder
      ' pictures folder
      ' public folder
      ' shared documents
      ' shared documents folder
      ' sites folder
      ' utilities folder
      
      If eCSIDL = CSIDL_APPDATA Then
' <JAS 02/09-2013, Revision 149, Resolve Macintosh problem with UserData position>
        ' GetSpecialFolder = AddBackslash(MacScript("return (path to applications folder) as string")) ' "MacIntosh HD:Applications"
         GetSpecialFolder = AddBackslash(MacScript("return (path to documents folder) as string")) ' "MacIntosh HD:Documents"
' <JAS 02/09-2013>
      ElseIf eCSIDL = CSIDL_COMMON_APPDATA Then
         GetSpecialFolder = AddBackslash(MacScript("return (path to applications folder) as string")) ' "MacIntosh HD:Applications"
      ElseIf eCSIDL = CSIDL_COMMON_PROGRAMS Then
         GetSpecialFolder = AddBackslash(MacScript("return (path to applications folder) as string")) ' "MacIntosh HD:Applications"
      ElseIf eCSIDL = CSIDL_PROGRAM_FILES Then
         GetSpecialFolder = AddBackslash(MacScript("return (path to applications folder) as string")) ' "MacIntosh HD:Applications"
      Else
         GetSpecialFolder = AddBackslash(MacScript("return (path to applications folder) as string")) ' "MacIntosh HD:Applications"
      End If
       
   #Else
       
      Dim tIDList As ITEMIDLIST
      Dim sPath As String
      Dim lRet As Long
      '
      ' Get the special folder as an ITEMIDLIST
      lRet = SHGetSpecialFolderLocation(ByVal 0&, eCSIDL, tIDList)
      If lRet = 0 Then
         '
         ' Create a buffer to receive the path
         sPath$ = String$(MAX_PATH * 2, vbNullChar)
         '
         ' Get the path from the IDList
         lRet = SHGetPathFromIDListW(ByVal tIDList.mkid.cb, ByVal StrPtr(sPath))
         If lRet <> 0 Then
            GetSpecialFolder = pPtr2StrW(StrPtr(sPath))
            If Len(GetSpecialFolder) <> 0 Then
               GetSpecialFolder = AddBackslash(GetSpecialFolder)
            End If
         Else
            GetSpecialFolder = ""
         End If
      Else
         GetSpecialFolder = ""
      End If
   #End If
   
End Function

'
' Executes a file object with the specified parameters
Public Function ShellAndWait(ByVal sVerb As String, _
                             ByVal sFilePath As String, _
                             Optional sParameters As String, _
                             Optional sWorkingFolder As String, _
                             Optional eWindowShowMode As enShellShowConstants = essSW_SHOWNORMAL, _
                             Optional eWaitMode As enWaitConstants = enwcNone, _
                             Optional lWaitMilliseconds As Long = -1, _
                             Optional bCloseProcess As Boolean = False) As Long

   Dim lRet As Long
   
   Dim tSEI As SHELLEXECUTEINFO
   '
   ' If not provided set the working folder to the document's path
   If LenB(sWorkingFolder) = 0 Then
      sWorkingFolder = mCore_FileOperationsW.GetFolderName(sFilePath)
   End If
   '
   ' Set-up the ShellEx parameters
   With tSEI
      .cbSize = LenB(tSEI)
      .fMask = SEE_MASK_NOCLOSEPROCESS Or SEE_MASK_FLAG_NO_UI
      .hWnd = 0   ' We don't need to set the hWndOwner
      .lpVerb = StrPtr(sVerb)
      .lpFile = StrPtr(sFilePath)
      .lpParameters = StrPtr(sParameters)
      .lpDirectory = StrPtr(sWorkingFolder)
      .nShow = eWindowShowMode
   End With
   '
   ' Call the host
   On Error Resume Next
   lRet = ShellExecuteExW(tSEI)
   '
   If lRet = 0 Then
      '
      ' The call failed.
      '
      ' TODO: Here we should call Err.LastDllError in addition to
      ' the SE_ERR_XXX codes casted to hInstApp.
      ShellAndWait = pGetShellExecuteError(CLng(tSEI.hInstApp))
      Exit Function
   End If
   '
   ' Act upon the specified WaitMode
   If eWaitMode <> enwcNone Then

      If eWaitMode = enwcInitialize Then
         '
         ' Wait until the called process has finished initializing
         lRet = WaitForInputIdle(tSEI.hProcess, lWaitMilliseconds)
      Else
         '
         ' Wait while the called process is running
         lRet = WaitForSingleObject(tSEI.hProcess, lWaitMilliseconds)
      End If

      If lRet = WAIT_FAILED Then ShellAndWait = -2 ' "Couldn't wait."

   End If
   '
   ' Stop the process if required
   If bCloseProcess Then
      lRet = TerminateProcess(tSEI.hProcess, 1)
      If lRet <> 0 Then ShellAndWait = -3 ' "Couldn't stop."
   End If

End Function

'
' Creates nested directories on the drive included in the path by parsing the final
' directory string into an array of folder/subfolder names (loops through each to
' create the final path). Issues may apply to UNC paths (not tested/JAS).
Public Function CreatePath(ByVal sPathToCreate As String) As Long
   
  ' #If Mac = 1 Then
      '
      ' TODO: Build a new function based on the use of Dir() and MkDir()
  '    CreatePath = 0
  '    Exit Function
   
  ' #End If
   
   Dim SA As SECURITY_ATTRIBUTES
   Dim sDrive As String
   Dim sNewDir  As String
   Dim sItem As String
   Dim sFolders() As String
   Dim lPos As Long
   Dim lCount As Long
   Dim lRes As Long
   
   sPathToCreate = AddBackslash(sPathToCreate)
   If Trim$(sPathToCreate) = "" Then
      CreatePath = 0
      Exit Function
   End If
   '
   ' If we have a drive in the path we get it.
   ' Else, we do nothing, ie. we assume current drive
   lPos = InStr(sPathToCreate, ":")
   If lPos > 0 Then
      sDrive = pGetFirstPart(sPathToCreate, WE_PATH_SEPARATOR)
   Else
      sDrive = ""
   End If
   '
   ' Collect the remaining path items that make up the string
   Do Until sPathToCreate = ""
      '
      ' Strip off one item (i.e. "Files\")
      sItem = pGetFirstPart(sPathToCreate, WE_PATH_SEPARATOR)
      '
      ' Add it to an array for later use, and if this is the first item (lCount=0),
      ' append the sDrive
      ReDim Preserve sFolders(0 To lCount) As String
      If lCount = 0 Then sItem = sDrive & sItem
      sFolders(lCount) = sItem
      '
      ' Increment the array counter
      lCount = lCount + 1
   
   Loop
   
   ' Now we create the directories. Because the first dir is element 0 in the array
   ' we reinitialize lCount to -1
   lCount = -1
   
   Do
      lCount = lCount + 1
      '
      ' Just keep appending the folders in the array to sNewDir.
      ' When lCount=0 sNewDir is "", so sNewDir gets assigned <drive>:\<firstfolder>.
      '
      ' Subsequent loops adds the next member of the array to the path,
      ' forming a fully qualified path to the new directory.
      sNewDir = sNewDir & sFolders(lCount)
      '
      ' The only member of the SA (Security Attributes) type needed
      SA.nLength = LenB(SA)
      '
      ' No error handling required at this time
      #If Mac = 1 Then
         Call pCreateFolderMac(sNewDir)
      #Else
         lRes = CreateDirectoryW(StrPtr(sNewDir), SA)
      #End If
      '
      ' TODO: error handling
     ' If lRes = 0 Then
     '    If Err.LastDllError <> ERROR_ALREADY_EXISTS Then
     '    Else
     '    End If
     ' End If
            
   Loop Until lCount = UBound(sFolders)
   '
   ' Done. Return lCount, but add 1 for the 0-based array.
   CreatePath = lCount + 1

End Function

'
' Takes a string separated by "sDelimiter", splits off an item,
' and shortens the string so that the next item is ready for removal.
Private Function pGetFirstPart(ByRef sFrom As String, ByVal sDelimiter As String) As String
   
   Dim lCount As Long
   Dim sItem As String
   
   lCount = 1
   
   Do
      If Mid$(sFrom, lCount, 1) = sDelimiter Then
         sItem = Mid$(sFrom, 1, lCount)
         sFrom = Mid$(sFrom, lCount + 1, Len(sFrom))
         pGetFirstPart = sItem
         Exit Function
      End If
      lCount = lCount + 1
   Loop

End Function

#If Mac = 1 Then
Private Sub pCreateFolderMac(ByVal sFolder As String)
    
    Dim sMacScript As String

    ' Make folder named TestFolder on the Desktop
    ' sFolder = MacScript("return (path to desktop folder) as string") & "TestFolder:"
    
    ' Or enter the complete path
    ' sFolder = "Macintosh HD:Users:YourUserName:Desktop:TestFolder:"

    sMacScript = "tell application " & ChrW$(34) & _
                 "Finder" & ChrW$(34) & ChrW$(13)
    sMacScript = sMacScript & _
                 "do shell script ""mkdir -p "" & quoted form of posix path of " & _
                 ChrW$(34) & sFolder & ChrW$(34) & ChrW$(13)
    sMacScript = sMacScript & "end tell"

    On Error Resume Next
    MacScript (sMacScript)
    On Error GoTo 0

End Sub
#End If

'#If VBA7 Then
'   Private Function pGetShellExecuteError(ByVal lErrorCode As LongPtr) As Long
'#Else
   Private Function pGetShellExecuteError(ByVal lErrorCode As Long) As Long
'#End If

   Dim lErr As Long
   Dim sErr As String

   If lErrorCode > 32 Then
      pGetShellExecuteError = 0
   Else
      
      lErr = lErrorCode
      Select Case lErrorCode
         Case 0
            lErr = 7
            sErr = "Out of memory"
         Case ERROR_FILE_NOT_FOUND
            lErr = 53
            sErr = "File not found"
         Case ERROR_PATH_NOT_FOUND
            lErr = 76
            sErr = "Path not found"
         Case ERROR_BAD_FORMAT
            sErr = "The executable file is invalid or corrupt"
         Case SE_ERR_ACCESSDENIED
            lErr = 75
            sErr = "Path/file access error"
         Case SE_ERR_ASSOCINCOMPLETE
            sErr = "This file type does not have a valid file association."
         Case SE_ERR_DDEBUSY
            lErr = 285
            sErr = "The file could not be opened because the target application is busy. Please try again in a moment."
         Case SE_ERR_DDEFAIL
            lErr = 285
            sErr = "The file could not be opened because the DDE transaction failed. Please try again in a moment."
         Case SE_ERR_DDETIMEOUT
            lErr = 286
            sErr = "The file could not be opened due to time out. Please try again in a moment."
         Case SE_ERR_DLLNOTFOUND
            lErr = 48
            sErr = "The specified dynamic-link library was not found."
         Case SE_ERR_FNF
            lErr = 53
            sErr = "File not found"
         Case SE_ERR_NOASSOC
            sErr = "No application is associated with this file type."
         Case SE_ERR_OOM
            lErr = 7
            sErr = "Out of memory"
         Case SE_ERR_PNF
            lErr = 76
            sErr = "Path not found"
         Case SE_ERR_SHARE
            lErr = 75
            sErr = "A sharing violation occurred."
         Case Else
            sErr = "An error occurred occurred while trying to open or print the selected file."
      End Select
              
      pGetShellExecuteError = lErr
      DebugMsg MODULE_NAME & "::ShellAndWait: Error: " & sErr & " (" & CStr(lErr) & ")"
     ' Err.Raise ByVal lErr, MODULE_NAME & "::pGetShellExecuteError", sErr
   End If
   
End Function

'
' Expands a string buffer to MAX_PATH or lMaxLength
Private Function pPadBuffer(ByVal sPath As String, Optional ByVal lMaxLength As Long) As String
   If lMaxLength <> 0 Then
      pPadBuffer = sPath & String$(lMaxLength - Len(sPath), 0)
   Else
      pPadBuffer = sPath & String$(MAX_PATH - Len(sPath), 0)
   End If
End Function

'
' Read string content from the memory pointer
#If VBA7 Then
   Private Function pPtr2StrW(ByVal lpAddr As LongPtr, Optional ByVal lMaxLength As Long) As String
      Dim lLength As Long
      If lMaxLength <> 0 Then
         lLength = lMaxLength
      Else
         lLength = lstrlenW(lpAddr)
      End If
      pPtr2StrW = Space$(lLength)
      RtlMoveMemory ByVal StrPtr(pPtr2StrW), ByVal lpAddr, lLength * 2
#Else
   Private Function pPtr2StrW(ByVal lpAddr As Long, Optional ByVal lMaxLength As Long) As String
      Dim lLength As Long
      If lMaxLength <> 0 Then
         lLength = lMaxLength
      Else
         lLength = lstrlenW(lpAddr)
      End If
      pPtr2StrW = Space$(lLength)
      RtlMoveMemory ByVal StrPtr(pPtr2StrW), ByVal lpAddr, lLength * 2
#End If

End Function

Private Sub pQualifyExtension(ByRef sExtension As String)
  If Left$(sExtension, 1) <> "." Then sExtension = "." & sExtension
End Sub

Private Function pGetLastError(ByVal lLastDLLError As Long) As String

   Dim lRet As Long
   Dim sBuffer As String
   Dim lBufferSize As Long
   '
   ' Assign a proper buffer
   sBuffer = String$(512, vbNullChar)
   lBufferSize = Len(sBuffer)
   '
   ' Get the error description from the system (i.e. the descriptive string)
   lRet = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, ByVal 0&, lLastDLLError, 0, StrPtr(sBuffer), lBufferSize, 0)
   If lRet <> 0 Then
      sBuffer = Left$(sBuffer, lRet - 2)
   Else
      sBuffer = "Error (" & CStr(lLastDLLError) & ") not defined as a system error."
   End If
   '
   ' Return the string
   pGetLastError = sBuffer

End Function

Private Function pGetFileOperationError(ByVal lLastDLLError As Long) As String
   '
   ' SHFileOperation is a ancient function that was first implemented with Windows 3.X.
   ' since then it has evolved with each platform, but some Error Codes are non-standard
   ' for Windows and comes from DOS (note the DE prefix). To provide relevant error
   ' messages we need to "translate" these into relevant text, which we do here :-)
   '
   ' Any other error code match GetLastError() from the Shell.
   
   Dim sBuffer As String
   
   Select Case lLastDLLError
      Case DE_SAMEFILE
         sBuffer = "Source and destination file are the same."
      Case DE_MANYSRC1DEST
         sBuffer = "Multiple paths were specified in the source of the operation, but only one Destination Path."
      Case DE_DIFFDIR
         sBuffer = "Rename operation was specified but the destination path is a different directory. Use move instead."
      Case DE_ROOTDIR
         sBuffer = "Source is a root directory, cannot be moved or renamed."
      Case DE_OPCANCELLED
         sBuffer = "Operation was cancelled by the user (or silently cancelled if the specified flags were supplied to SHFileOperation)."
      Case DE_DESTSUBTREE
         sBuffer = "The destination is a sub-tree of the source."
      Case DE_ACCESSDENIEDSRC
         sBuffer = "Security problems on source."
      Case DE_PATHTOODEEP
         sBuffer = "The source or destination path exceeded or would exceed MAX_PATH."
      Case DE_MANYDEST
         sBuffer = "Operation involved multiple destination paths which can fail in the case of a Move Operation."
      Case DE_INVALIDFILES
         sBuffer = "The paths in the source or destination were invalid."
      Case DE_DESTSAMETREE
         sBuffer = "Source and destination have the same parent folder."
      Case DE_FLDDESTISFILE
         sBuffer = "The destination path is to an existing file."
      Case DE_FILEDESTISFLD
         sBuffer = "The destination path is to an existing folder."
      Case DE_FILENAMETOOLONG
         sBuffer = "The name of the file exceeds MAX_PATH."
      Case DE_DEST_IS_CDROM
         sBuffer = "Destination is a Read-Only CDRom, possibly unformatted."
      Case DE_DEST_IS_DVD
         sBuffer = "Destination is a Read-Only DVD, possibly unformatted."
      Case DE_DEST_IS_CDRECORD
         sBuffer = "Destination is a Recordable (AudioL) CDRom, possibly unformatted."
      Case DE_FILE_TOO_LARGE
         sBuffer = "The file involved in the operation is too large for the destination media or file system."
      Case DE_SRC_IS_CDROM
         sBuffer = "Source is a Read-Only CDRom, possibly unformatted."
      Case DE_SRC_IS_DVD
         sBuffer = "Source is a Read-Only DVD, possibly unformatted."
      Case DE_SRC_IS_CDRECORD
         sBuffer = "Source is a Recordable (AudioL) CDRom, possibly unformatted."
      Case DE_ERROR_MAX
         sBuffer = "MAX_PATH was exceeded during the operation."
      Case ERRORONDEST
         sBuffer = "An unspecified error occurred on the destination."
      Case DE_ROOTRENAME
         sBuffer = "Destination is a root directory, which cannot be renamed."
      
      Case Else
         sBuffer = pGetLastError(lLastDLLError)

   End Select
   
   pGetFileOperationError = sBuffer
   
End Function

Private Function pGetCommonDialogError(ByVal eErrorCode As enCommonDialogErrors) As String

   Dim sError As String
   
   Select Case eErrorCode
      Case CDERR_DIALOGFAILURE
         sError = "The dialog box could not be created. The common dialog box function's call to the DialogBox function failed. For example, this error occurs if the common dialog box call specifies an invalid window handle."
      Case CDERR_STRUCTSIZE
         sError = "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid."
      Case CDERR_INITIALIZATION
         sError = "The common dialog box function failed during initialization. This error often occurs when sufficient memory is not available."
      Case CDERR_NOTEMPLATE
         sError = "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box, but you failed to provide a corresponding template."
      Case CDERR_NOHINSTANCE
         sError = "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box, but you failed to provide a corresponding instance handle."
      Case CDERR_LOADSTRFAILURE
         sError = "The common dialog box function failed to load a specified string."
      Case CDERR_FINDRESFAILURE
         sError = "The common dialog box function failed to find a specified resource."
      Case CDERR_LOADRESFAILURE
         sError = "The common dialog box function failed to load a specified string."
      Case CDERR_LOCKRESFAILURE
         sError = "The common dialog box function failed to lock a specified resource."
      Case CDERR_MEMALLOCFAILURE
         sError = "The common dialog box function was unable to allocate memory for internal structures."
      Case CDERR_MEMLOCKFAILURE
         sError = "The common dialog box function was unable to lock the memory associated with a handle."
      Case CDERR_NOHOOK
         sError = "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box, but you failed to provide a pointer to a corresponding hook procedure."
      Case CDERR_REGISTERMSGFAIL
         sError = "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function."
                     
      Case Else
         sError = "Unknown error."
      
   End Select

   pGetCommonDialogError = sError

End Function

'Sub TestFolder()
'
'   Debug.Print GetSpecialFolder(CSIDL_APPDATA)
'
'End Sub


Attribute VB_Name = "mCore_HelperFunctions"
Option Explicit
Option Compare Binary
'
'Purpose       : Helper functions
'
'Dependencies  :
'
'Public        :
'                GetNumberFromBookmarkName              : Get sequence number from ContentBit bookmark name
'
'Created by    : HPZ
'Creation date : 27/10-2010
'Modified      : 28/10-2010 NRV
'
'TODO          :
'
'
'Module name for debugging
Private Const MODULE_NAME = "mHelperFunctions"

Private sErrorString As String

'Public Function GetNumberFromBookmarkName(ByVal sBmkName As String) As String
''sErrorString = MODULE_NAME & " :: " & "GetNumberFromBookmarkName"
''DebugMsg sErrorString, dbgLogCheckPoint
''--- code start ---
'
'    Dim I As Integer
'    Dim J As Integer
'    Dim K As Integer
'    Dim sSequenceIdentifier As String
'
'    sSequenceIdentifier = mSettings.SequenceIdentifier
'
'    I = InStr(1, sBmkName, sSequenceIdentifier)
'    J = InStr(1, sBmkName, PathIdentifier)
'    If I > 0 Then
'        If J > I Then
'            K = CInt(Mid(sBmkName, I + Len(sSequenceIdentifier), J - I - Len(sSequenceIdentifier) - 1))
'        Else
'            K = CInt(Right(sBmkName, Len(sBmkName) - Len(sSequenceIdentifier) - I + 1))
'        End If
'
'    End If
'    GetNumberFromBookmarkName = "(" & K & ")"
'
''--- code  end  ---
'End Function

'Public Function GetContentBitSequenceNumber(ByRef docref As Document, ByVal sContentBitName As String, Optional ByRef NextSequenceNumber As Boolean = True) As Integer
''sErrorString = MODULE_NAME & " :: " & "GetContentBitSequenceNumber"
''DebugMsg sErrorString, dbgLogCheckPoint
''--- code start ---
'
'    Dim bBmk As Bookmark
'    Dim I As Integer
'    Dim J As Integer
'    Dim K As Integer
'    Dim L As Integer
'
'    I = 0
'
'    'go through all bookmarks in document and search for highest sequence number in bookmarks with the same name
'    For Each bBmk In docref.Bookmarks
'
'        J = 0
'        K = 0
'        L = 0
'
'        If InStr(1, bBmk.Name, sContentBitName) > 0 Then
'
'            K = InStr(1, bBmk.Name, mSettings.SequenceIdentifier)
'
'            If K > 0 Then
'                L = InStr(1, Mid(bBmk.Name, K), "_")
'                J = CInt(Mid(bBmk.Name, K + Len(mSettings.SequenceIdentifier), L))
'            End If
'
'            If J > I Then I = J
'
'        End If
'    Next
'
'    If NextSequenceNumber Then
'        I = I + 1
'    End If
'
'    GetContentBitSequenceNumber = I
'
''--- code  end  ---
'End Function

Public Function GetDocumentObject(ByRef sFileName As String) As Document
'sErrorString = MODULE_NAME & " :: " & "GetDocumentObject"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---

    Dim oDocument As Document
    Set oDocument = Application.Documents.Open(sFileName)
    
    Set GetDocumentObject = oDocument

'--- code  end  ---
End Function

Public Sub CloseDocumentObject(ByRef docref As Document)
'sErrorString = MODULE_NAME & " :: " & "CloseDocumentObject"
'DebugMsg sErrorString, dbgLogCheckPoint
'--- code start ---

    docref.Close False

'--- code  end  ---
End Sub

'Public Function GetFilesInFolder(ByVal sFolderName As String) As String()
''run when program starts to get a list of all files in ContentBit folder
''sErrorString = MODULE_NAME & " :: " & "GetFilesInFolder"
''DebugMsg sErrorString, dbgLogCheckPoint
''--- code start ---
'
'    Dim sTmpFilename As String
'    Dim I As Single
'    Dim fsFileSystem As Object
'    Dim fFolder As Object
'    Dim fFile As Object
'    Dim asFolders() As String
'    Dim vFolderName As Variant
'    Dim asResult() As String
'
'    Set fsFileSystem = CreateObject("Scripting.FileSystemObject")
'
'    sFolderName = FillVariables(sFolderName)
'    If FolderExists(sFolderName) Then
'
'       Set fFolder = fsFileSystem.GetFolder(sFolderName)
'
'       I = 0
'       For Each fFile In fFolder.Files
'           sTmpFilename = sFolderName & "\" & fFile.Name
'           If FileExists(sTmpFilename) And _
'              Left(fFile.Name, 1) <> "~" And _
'              SameLanguage(ActiveDocument.FullName, sTmpFilename) Then
'               AddStringToStringArray asResult, sTmpFilename
'               I = I + 1
'           End If
'       Next
'
'    Else
'       'Err.Raise 1, sErrorString, "File does not exist"
'    End If
'
'    GetFilesInFolder = asResult
'
''--- code  end  ---
'End Function


'Public Sub SetBookmarkValue(ByRef oDocument As Document, sBookmarkName As String, sBookmarkValue As String)
'    Dim iCounter As Integer
'    Dim sBookmarkNameWithIdentifier As String
'
'    If InStr(1, sBookmarkValue, "*", vbTextCompare) Then
'       sBookmarkValue = Replace(sBookmarkValue, "*", Chr(11))
'    End If
'
'    FormatTextString sBookmarkValue, sBookmarkName
'
'    For iCounter = 0 To 5
'      If iCounter = 0 Then
'          sBookmarkNameWithIdentifier = sBookmarkName
'      Else
'          sBookmarkNameWithIdentifier = sBookmarkName & "_N" & iCounter
'      End If
'
'      If oDocument.Bookmarks.Exists(sBookmarkNameWithIdentifier) Then
'          Dim rng As Range
'          Set rng = oDocument.Bookmarks(sBookmarkNameWithIdentifier).Range
'          rng.Text = sBookmarkValue
'          oDocument.Bookmarks.Add sBookmarkNameWithIdentifier, rng
'
''          rng.LanguageID = wdAfrikaans
''          If rng.Bookmarks.Count = 2 Then
''            Dim rngSurroundingBookmark As Range
''            Set rngSurroundingBookmark = rng.Bookmarks(1).Range
''            rngSurroundingBookmark.SetRange rng.End, rngSurroundingBookmark.End
''            oDocument.Bookmarks.Add rng.Bookmarks(1).Name, rngSurroundingBookmark
''          End If
'      End If
'
'      Dim rngHide As Range
'      If oDocument.Bookmarks.Exists("HIF_" & sBookmarkNameWithIdentifier) Then
'          Set rngHide = oDocument.Bookmarks("HIF_" & sBookmarkNameWithIdentifier).Range
'          rngHide.Font.Hidden = False
'          If LenB(sBookmarkValue) = 0 Then
'              rngHide.Font.Hidden = True
'          End If
'      End If
'      If oDocument.Bookmarks.Exists("DIF_" & sBookmarkNameWithIdentifier) Then
'         Set rngHide = oDocument.Bookmarks("DIF_" & sBookmarkNameWithIdentifier).Range
'         If LenB(sBookmarkValue) = 0 Then
'             rngHide.Delete
'         End If
'      End If
'    Next
'End Sub

Public Sub SetBookmarkValueOld(ByRef oDocument As Document, sBookmarkName As String, sBookmarkValue As String)
   Dim iCounter As Integer
   Dim sBookmarkNameWithIdentifier As String
   Dim iHyperlinkType As Integer
   
   If InStr(1, sBookmarkValue, "*", vbTextCompare) Then
      sBookmarkValue = Replace(sBookmarkValue, "*", Chr(11))
   End If

   'FormatTextString sBookmarkValue, sBookmarkName
   
   For iCounter = 0 To 5
      If iCounter = 0 Then
         sBookmarkNameWithIdentifier = sBookmarkName
      Else
         sBookmarkNameWithIdentifier = sBookmarkName & "_N" & iCounter
      End If
      
      If oDocument.Bookmarks.Exists(sBookmarkNameWithIdentifier) Then
         Dim rng As Range
         Set rng = oDocument.Bookmarks(sBookmarkNameWithIdentifier).Range
          
         If rng.Hyperlinks.Count > 0 Then
            If InStr(rng.Hyperlinks(1).Address, "mailto:") <> 0 Then
               iHyperlinkType = 1
            ElseIf InStr(rng.Hyperlinks(1).Address, "http://") <> 0 Then
               iHyperlinkType = 2
            End If
            
            rng.Hyperlinks(1).Delete
            rng.Text = sBookmarkValue
                   
            If iHyperlinkType = 1 Then
               rng.Hyperlinks.Add rng, "mailto:" & sBookmarkValue, , UCase(sBookmarkValue)
            ElseIf iHyperlinkType = 2 Then
               rng.Hyperlinks.Add rng, "http://" & sBookmarkValue, , UCase(sBookmarkValue)
            End If
         Else
            rng.Text = sBookmarkValue
         End If
          
         oDocument.Bookmarks.Add sBookmarkNameWithIdentifier, rng
'          If rng.Bookmarks.Count = 2 Then
'            Dim rngSurroundingBookmark As Range
'            Set rngSurroundingBookmark = rng.Bookmarks(1).Range
'            rngSurroundingBookmark.SetRange rng.End, rngSurroundingBookmark.End
'            oDocument.Bookmarks.Add rng.Bookmarks(1).Name, rngSurroundingBookmark
'          End If
      End If
        
      Dim rngHide As Range
      If oDocument.Bookmarks.Exists("HIF_" & sBookmarkNameWithIdentifier) Then
          Set rngHide = oDocument.Bookmarks("HIF_" & sBookmarkNameWithIdentifier).Range
          rngHide.Font.Hidden = False
          If LenB(sBookmarkValue) = 0 Then
              rngHide.Font.Hidden = True
          End If
      End If
      If oDocument.Bookmarks.Exists("DIF_" & sBookmarkNameWithIdentifier) Then
         Set rngHide = oDocument.Bookmarks("DIF_" & sBookmarkNameWithIdentifier).Range
         If LenB(sBookmarkValue) = 0 Then
             rngHide.Delete
         End If
      End If
    Next
End Sub


Function CountLinesInString(strVal As String, Optional strEnterSign As String) As Integer
    'Counts number of carriage returns. No CR = 1 line
    Dim strTemp As String
    Dim iPos As Integer
    Dim i As Integer
    
    i = 1
    strTemp = strVal
    
    If strEnterSign = "" Then
        While InStr(1, strTemp, vbCr) <> 0
            iPos = InStr(1, strTemp, vbCr)
            strTemp = Mid(strTemp, iPos + 1)
            i = i + 1
        Wend
    Else
        While InStr(1, strTemp, strEnterSign) <> 0
            iPos = InStr(1, strTemp, strEnterSign)
            strTemp = Mid(strTemp, iPos + 1)
            i = i + 1
        Wend
    End If

    CountLinesInString = i
End Function

Public Property Get SeperatorSign() As String
    Static strVal As String
    If strVal <> "" Then
    Else
      '[HACK]
        strVal = "*"
    End If
    SeperatorSign = strVal
End Property

'
' Formerly the ConvertSignToEnter() function
Function FilterSpecialMarkers(sValue As String) As String
         
   ' This function is also called in GetLanguageStringEx(), so DO NOT use the nested call
   ' FilterSpecialMarkers(GetLanguageStringEx(xx, yy, zz)) for any reason
   
   ' Constant        Content              Use/meaning
   ' ---------------------------------------------------------------------------------------------------------------------
   ' vbCr            Chr(13)              Carriage return character
   ' vbLf            Chr(10)              Linefeed character
   ' vbCrLf          Chr(13) + Chr(10)    Carriage return - linefeed combination
   ' vbNewLine       Chr(13) + Chr(10)    New line character
   ' vbNullChar      Chr(0)               Character having a value of 0. Useful for passing to external DLLs
   '                                      Should be used in place of Chr(0)
   '                                      Returns Chr(0)
   ' vbNullString    String with value 0  NOT the same as a zero-length string (""); used for calling external procedures.
   '                                      Cannot be passed to any DLL's unless passed via StrPtr()
   ' vbTab           Chr(9)               Normal Tab character
   ' vbBack          Chr(8)               Backspace character
   ' vbFormFeed      Chr(12)              Manual page break (Ctrl + Enter in Word)
   ' vbVerticalTab   Chr(11)              Manual line break (Shift + Enter in Word)
   
   
   If InStr(1, sValue, "*") <> 0 Then sValue = Replace(sValue, "*", vbCr)
   If InStr(1, sValue, Chr$(164)) <> 0 Then sValue = Replace(sValue, Chr$(164), vbVerticalTab)
   If InStr(1, sValue, "~") <> 0 Then sValue = Replace(sValue, "~", vbVerticalTab)  ' Har aldrig set denne i brug. Kan den fjernes?
   
   If InStr(1, sValue, "%tab%") <> 0 Then sValue = Replace(sValue, "%tab%", vbTab)
   
   If InStr(1, sValue, "<none>") <> 0 Then sValue = Replace(sValue, "<none>", "")
   If InStr(1, sValue, "%none%") <> 0 Then sValue = Replace(sValue, "%none%", "")
   If InStr(1, sValue, "%asterix%") <> 0 Then sValue = Replace(sValue, "%asterix%", "*")
   If InStr(1, sValue, "%asterisk%") <> 0 Then sValue = Replace(sValue, "%asterisk%", "*")
   '
   ' No-break-space
   If InStr(1, sValue, "&nbsp;") <> 0 Then sValue = Replace(sValue, "&nbsp;", Chr$(160))
   
   FilterSpecialMarkers = sValue
   
End Function

Function GetStringWithAlternateValueIfMissing(sValueOne As String, Optional sValueTwo As String, Optional sDefaultValue As String) As String
   On Error GoTo errorhandler
   If LenB(sValueOne) <> 0 Then
      GetStringWithAlternateValueIfMissing = str$(sValueOne)
   ElseIf LenB(sValueTwo) <> 0 Then
      GetStringWithAlternateValueIfMissing = str$(sValueTwo)
   ElseIf Not IsMissing(sDefaultValue) Then
      GetStringWithAlternateValueIfMissing = str$(sDefaultValue)
   Else
      GetStringWithAlternateValueIfMissing = ""
   End If
   Exit Function

errorhandler:
   GetStringWithAlternateValueIfMissing = ""
End Function

Function GetSingleWithAlternateValueIfMissing(sValueOne As String, Optional sValueTwo As String, Optional sngDefaultValue As Single) As Single
   On Error GoTo errorhandler
   If LenB(sValueOne) <> 0 Then
      GetSingleWithAlternateValueIfMissing = CSng(sValueOne)
   ElseIf LenB(sValueTwo) <> 0 Then
      GetSingleWithAlternateValueIfMissing = CSng(sValueTwo)
   ElseIf Not IsMissing(sngDefaultValue) Then
      GetSingleWithAlternateValueIfMissing = CSng(sngDefaultValue)
   Else
      GetSingleWithAlternateValueIfMissing = 0
   End If
   Exit Function

errorhandler:
   GetSingleWithAlternateValueIfMissing = 0
End Function

Function GetBooleanWithAlternateValueIfMissing(sValueOne As String, Optional sValueTwo As String, Optional blnDefaultValue As Boolean) As Boolean
   On Error GoTo errorhandler
   If LenB(sValueOne) <> 0 Then
      GetBooleanWithAlternateValueIfMissing = CBool(sValueOne)
   ElseIf LenB(sValueTwo) <> 0 Then
      GetBooleanWithAlternateValueIfMissing = CBool(sValueTwo)
   ElseIf Not IsMissing(blnDefaultValue) Then
      GetBooleanWithAlternateValueIfMissing = blnDefaultValue
   Else
      GetBooleanWithAlternateValueIfMissing = False
   End If
   Exit Function

errorhandler:
   GetBooleanWithAlternateValueIfMissing = False
End Function

Sub ConvertBookmarksToNewVersion()
   Dim oBookmark As Bookmark
   Dim colBookmarks As New Collection
   For Each oBookmark In ActiveDocument.Bookmarks
      colBookmarks.Add oBookmark.Name
   Next
   
   Dim oBookmarkValue
   Dim sBookmark As String
   Dim sStrippedName As String
   For Each oBookmarkValue In colBookmarks
      sBookmark = oBookmarkValue
      If Left(sBookmark, 5) = "bmkAD" Then
         sStrippedName = Replace(sBookmark, "bmkAD", "")
         ChangeBookmarkName sBookmark, "SD_USR_" & sStrippedName
      ElseIf Left(sBookmark, 6) = "bmkOff" Then
         sStrippedName = Replace(sBookmark, "bmkOff", "")
         ChangeBookmarkName sBookmark, "SD_OFF_" & sStrippedName
      ElseIf Left(sBookmark, 6) = "bmkOvs" Then
         sStrippedName = Replace(sBookmark, "bmkOvs", "")
         ChangeBookmarkName sBookmark, "SD_LAN_" & sStrippedName
      ElseIf Left(sBookmark, 6) = "bmkFld" Then
         sStrippedName = Replace(sBookmark, "bmkFld", "")
         ChangeBookmarkName sBookmark, "SD_FLD_" & sStrippedName
      End If
   Next
End Sub

Sub ChangeBookmarkName(sOldName As String, sNewName As String)
   If Not ActiveDocument.Bookmarks.Exists(sOldName) Then
      Exit Sub
   End If

   If ActiveDocument.Bookmarks.Exists(sNewName) Then
      Exit Sub
   End If

   ActiveDocument.Bookmarks.Add sNewName, ActiveDocument.Bookmarks(sOldName).Range
   ActiveDocument.Bookmarks(sOldName).Delete
End Sub

Public Function GetBookmarkNameCollectionByPrefix(sBookmarkPrefix As String) As Collection
   Dim colBookmarkNames As New Collection
   Dim bmk As Bookmark
   For Each bmk In ActiveDocument.Bookmarks
      If Left(bmk.Name, Len(sBookmarkPrefix)) = sBookmarkPrefix Then
         colBookmarkNames.Add bmk.Name
      End If
   Next
   Set GetBookmarkNameCollectionByPrefix = colBookmarkNames
End Function

Sub DeleteBookmarkRange(sBookmarkName As String)
   Dim oDocument As Document
   
   On Error GoTo BailOut
   
   Set oDocument = ActiveDocument
   
   If oDocument.Bookmarks.Exists(sBookmarkName) Then
      Dim oRng As Range
      Set oRng = oDocument.Bookmarks(sBookmarkName).Range
   Else
      GoTo BailOut
   End If
   
   With oDocument
      .Bookmarks(sBookmarkName).Range.Text = ""
      .Bookmarks.Add sBookmarkName, oRng
   End With
   
   Exit Sub
   
BailOut:
   Resume Next
   
End Sub

Public Function IsSelectionInTextbox() As Boolean
   On Error GoTo errorhandler
   Dim sh As Shape
   Set sh = Selection.ShapeRange(1)
   Set sh = Nothing
   IsSelectionInTextbox = True
   Exit Function
errorhandler:
   IsSelectionInTextbox = False
End Function

Public Sub AddItemToCollection(ByRef oCol As Collection, vAddItem As Variant, sKeyName As String)
   On Error GoTo errorhandler
   If LenB(sKeyName) = 0 Then
      oCol.Add vAddItem
   Else
      oCol.Add vAddItem, sKeyName
   End If
errorhandler:
End Sub



Public Function ConvertToSingle(ByVal sVal As String) As Single
   '
   ' Conversion of strings to Single may introduce a scaling problem in some locales.
   ' For example, CSng("2,48") may scale to 248 after conversion instead of 2.48.
   ' Similarly CSng("2,4") may return 24, CSng("2,480") may return 2480 and
   ' CSng("2,480000") may return 2480000.
   '
   ' Hence, we need to find the decimal position and build a string that represent
   ' the scale factor and divide the result of CSng(sVal) by that scale factor to
   ' get a stable result we can rely on.
   '
   ' Typical decimal dividers are the comma and period characters, so we concentrate
   ' on those. More characters MAY apply in some locales (NLS cultures).
   '
   ' NOTE: We do NOT resolve Thousand Separators, which are considered illegal.
   
   Dim lPosPeriod As Long
   Dim lPosComma As Long
   Dim snScaleFactor As Single
   
   lPosPeriod = InStrRev(sVal, ".", , vbTextCompare)
   lPosComma = InStrRev(sVal, ",", , vbTextCompare)
   
   sVal = Trim$(sVal)
   
   Select Case True
      
      Case (InStr(1, sVal, " ", vbTextCompare) <> 0)
         Err.Raise 13, MODULE_NAME & "::ConvertToSingle", "The parameter """ & sVal & """ may not contain space characters."
      
      Case Not IsNumeric(sVal)
         Err.Raise 13, MODULE_NAME & "::ConvertToSingle", "The parameter """ & sVal & """ isn't numeric. Nice try, but no cigar :-)"
   
      Case (lPosPeriod <> 0) And (lPosComma <> 0)
         Err.Raise 13, MODULE_NAME & "::ConvertToSingle", "Can't convert " & sVal & " because it features a Thousand Separator."
         
      Case (lPosPeriod <> 0)
         snScaleFactor = CSng("1." & String(Len(sVal) - lPosPeriod, "0"))
         
      Case (lPosComma <> 0)
         snScaleFactor = CSng("1," & String(Len(sVal) - lPosComma, "0"))
   
      Case Else
         snScaleFactor = 1
         
   End Select
      
   ConvertToSingle = CSng(sVal) / snScaleFactor
   
End Function

Public Function FormatNumberToMask(ByVal sNumberToFormat As String, ByVal sMask As String) As String
'
' This function formats a numeric string or numeric AND date based string according to sMask.
' If the function fail it returns an empty string.
   
   Dim i As Long
   Dim sValue As String
   Dim saDigits() As String
   Dim saSeparators() As String
   Dim saParts() As String
   Dim sTemp As String
   Dim sPrefix As String
   Dim lMaskDigits As Long
   Dim lInputDigits As Long
   Dim lThisDigit As Long
   Dim lSeparators As Long
   Dim lFirstDigitPosition As Long
   Dim lLastDigitPosition As Long
   Dim lRequestedYear As Long
   Dim lThisYear As Long
   
   sTemp = sNumberToFormat
   '
   ' Do we have a perfect match?
   If sTemp Like sMask Then
      FormatNumberToMask = sTemp
      Exit Function
   End If
   '
   ' Count the number of digits in the mask and find the position of the
   ' first digit that isn't part of a potential prefix.
   For i = 1 To Len(sMask)
      If Mid(sMask, i, 1) = "#" Then
         lMaskDigits = lMaskDigits + 1
         If lFirstDigitPosition = 0 Then
            lFirstDigitPosition = i
         End If
      End If
   Next
   '
   ' If we have a prefix we might need to filter it from the string
   ' we are asked to format.
   If lFirstDigitPosition > 1 Then
      sPrefix = Mid$(sMask, 1, lFirstDigitPosition - 1)
      '
      ' If the input string has a prefix we remove it
      If InStr(1, sTemp, sPrefix) <> 0 Then
         sTemp = Mid$(sTemp, Len(sPrefix))
      End If
   End If
   '
   ' Remove space characters and hyphens from the number string
   sTemp = VBA.Replace(sTemp, " ", "", , , vbBinaryCompare)
   sTemp = VBA.Replace(sTemp, "-", "", , , vbBinaryCompare)
   sTemp = VBA.Replace(sTemp, ".", "", , , vbBinaryCompare)
   sTemp = VBA.Replace(sTemp, "/", "", , , vbBinaryCompare)
   '
   ' Capture each digit from the number.
   ReDim saDigits(0) As String
   For i = Len(sTemp) To Len(sTemp) - lMaskDigits + 1 Step -1
      If i > 0 Then
         If Mid(sTemp, i, 1) Like "#" Then
            lInputDigits = lInputDigits + 1
            ReDim Preserve saDigits(lInputDigits) As String
            saDigits(lInputDigits) = Mid(sTemp, i, 1)
         End If
      End If
   Next
   '
   ' If the number of input digits equals the number of placeholders
   ' in the mask we fill the mask with digits and return sValue.
   If lMaskDigits = lInputDigits Then
      sValue = sMask
      For i = Len(sValue) To 1 Step -1
         If Mid(sValue, i, 1) = "#" Then
            lThisDigit = lThisDigit + 1
            Mid$(sValue, i, 1) = saDigits(lThisDigit)
         End If
      Next
   End If
   '
   ' Did we get a result yet? If not, we likely have some
   ' kind of numeric date format.
   If (LenB(sValue) = 0) Then
      '
      ' Get any non-numeric placeholders (separators) contained in the
      ' number part of the mask
      ReDim saSeparators(0) As String
      lLastDigitPosition = InStrRev(sMask, "#", , vbBinaryCompare)
      If lFirstDigitPosition < lLastDigitPosition Then
         For i = lFirstDigitPosition To lLastDigitPosition
            If Mid(sMask, i, 1) <> "#" Then
               If lSeparators <> 0 Then
                  ReDim Preserve saSeparators(lSeparators) As String
               End If
               saSeparators(lSeparators) = Mid(sMask, i, 1)
               lSeparators = lSeparators + 1
            End If
         Next
      End If
      '
      ' If we get here we try a qualified guess on the original
      ' number string. First we standardize the string ...
      sTemp = sNumberToFormat
      sTemp = VBA.Replace(sTemp, " ", ".", , , vbBinaryCompare)
      sTemp = VBA.Replace(sTemp, "-", ".", , , vbBinaryCompare)
     ' sTemp = VBA.Replace(sTemp, ".", ".", , , vbBinaryCompare)
      sTemp = VBA.Replace(sTemp, "/", ".", , , vbBinaryCompare)
      '
      ' Standardize a little more :-)
      lThisYear = Year(Date)
      If sTemp Like "####" Then
         sTemp = Mid$(sTemp, 1, 2) & "." & Mid$(sTemp, 3, 2) & "." & CStr(lThisYear)
      ElseIf sTemp Like "######" Then
         sTemp = Mid$(sTemp, 1, 2) & "." & Mid$(sTemp, 3, 2) & "." & Mid$(sTemp, 5, 2)
      End If
      '
      ' Test for some different "fixed" masks (mostly short date masks)
      If (sTemp Like "*.*.##") Then
         '
         ' If we get here we must decide whether year entries such as "3/2-12" or "3/3-97" belong
         ' in the 19'ties or 20'ties. We calculate 20 years forward or back to year 2000 to decide.
         saParts = Split(sTemp, ".", , vbBinaryCompare)
         If lSeparators = 2 Then
            lRequestedYear = CLng("20" & Format$(saParts(2), "00"))
            If Abs(lRequestedYear - lThisYear) <= 20 Or (lRequestedYear - 2000) < CLng(Mid(CStr(lThisYear), 3)) Then
               sValue = Format$(saParts(0), "00") & saSeparators(0) & Format$(saParts(1), "00") & saSeparators(1) & "20" & Format$(saParts(2), "00")
            Else
               sValue = Format$(saParts(0), "00") & saSeparators(0) & Format$(saParts(1), "00") & saSeparators(1) & "19" & Format$(saParts(2), "00")
            End If
         End If
      ElseIf (sTemp Like "*.*.####") Then
         saParts = Split(sTemp, ".", , vbBinaryCompare)
         If lSeparators = 2 Then
            sValue = Format$(saParts(0), "00") & saSeparators(0) & Format$(saParts(1), "00") & saSeparators(1) & saParts(2)
         End If
      ElseIf sTemp Like "*.*" Then
         saParts = Split(sTemp, ".", , vbBinaryCompare)
         If lSeparators = 2 Then
            sValue = Format$(saParts(0), "00") & saSeparators(0) & Format$(saParts(1), "00") & saSeparators(1) & CStr(lThisYear)
         ElseIf lSeparators = 1 Then
            sValue = Format$(saParts(0), "00") & saSeparators(0) & Format$(saParts(1), "00")
         End If
      End If
      
   End If

   FormatNumberToMask = sValue

End Function

Public Function TrimValueWithComma(sVal As String)
   sVal = Trim(sVal)
   If Not LenB(sVal) = 0 Then
      sVal = sVal & ", "
   End If
   TrimValueWithComma = sVal
End Function

Public Function TrimLastComma(sVal As String)
   sVal = Trim(sVal)
   If Right(sVal, 1) = "," Then
      sVal = Left(sVal, Len(sVal) - 1)
   End If
   TrimLastComma = sVal
End Function

'FRN 25/11/2009
'
Function ReturnBookmarkNameWithFirstAvailableIndex(strBmkName As String) As String
    Dim i As Long
    Dim strNewBmkName As String
    
    strNewBmkName = Left(strBmkName, Len(strBmkName) - 3)
    
    If Not ActiveDocument.Bookmarks.Exists(strNewBmkName) Then
        ReturnBookmarkNameWithFirstAvailableIndex = strNewBmkName
        Exit Function
    End If
    
    i = 1
    Do While ActiveDocument.Bookmarks.Exists(strNewBmkName & "_N" & i)
        i = i + 1
    Loop
    
    ReturnBookmarkNameWithFirstAvailableIndex = strNewBmkName & "_N" & i
    
End Function

Sub ConvertSectionBreakFields()
   On Error GoTo errorhandler
   Dim oFld As Field
   For Each oFld In ActiveDocument.Fields
      If IsFieldSectionBreak(oFld) Then
      
         Dim oRange As Range
         Set oRange = oFld.Result
         oRange.InsertBreak GetFieldSectionBreakType(oFld)
         oFld.Delete
      End If
   Next
errorhandler:
End Sub

Function IsFieldSectionBreak(oFld As Field) As Boolean
   Dim sFieldText As String
   sFieldText = oFld.Code
   
   If InStr(1, sFieldText, "SectionBreak_") Then
      IsFieldSectionBreak = True
   End If
End Function

Function GetFieldSectionBreakType(oFld As Field) As WdBreakType
   Dim sFieldText As String
   sFieldText = oFld.Code
   
   If InStr(1, sFieldText, "SectionBreak_NewPage") Then
      GetFieldSectionBreakType = wdSectionBreakNextPage
   ElseIf InStr(1, sFieldText, "SectionBreak_Continuous") Then
      GetFieldSectionBreakType = wdSectionBreakContinuous
   ElseIf InStr(1, sFieldText, "SectionBreak_EvenPage") Then
      GetFieldSectionBreakType = wdSectionBreakEvenPage
   ElseIf InStr(1, sFieldText, "SectionBreak_OddPage") Then
      GetFieldSectionBreakType = wdSectionBreakOddPage
   End If
End Function



Sub InsertAutoTextWithIndexedBookmark(ByRef vIRibbonControlOrString As Variant, Optional ByRef sTemplateName As String)
    
   Dim oTemplate As Template
   Dim oRange As Range
   Dim sAutotext As String
   Dim oBookmark As Bookmark
   '
   ' Did we get a valid parameter?
   If TypeName(vIRibbonControlOrString) = "IRibbonControl" Then
      sAutotext = vIRibbonControlOrString.Tag
   ElseIf TypeName(vIRibbonControlOrString) = "String" Then
      sAutotext = vIRibbonControlOrString
   Else
      Err.Raise 13, MODULE_NAME & "::InsertAutoTextWithIndexedBookmark", "Type mismatch (bad parameter)." & " " & "The ""vIRibbonControlOrString"" parameter is neither a String value nor an IRibbonControl interface."
   End If

   If Len(Trim$(sTemplateName)) <> 0 Then
      Dim sFileName As String
      sFileName = CombinePaths(ThisDocument.Path, sTemplateName)
      If FileExists(sFileName) Then
         Set oTemplate = Application.Templates(sFileName)
      Else
         ' TODO: Evt fejlh|fffd|ndtering
      End If
   Else
      Set oTemplate = ActiveDocument.AttachedTemplate
   End If
   
   If Not oTemplate Is Nothing Then
   
      Set oRange = oTemplate.BuildingBlockEntries(sAutotext).Insert(Selection.Range, True)
      '*** Indsat af MAC for at l|fffd|se autotekst _NX problem i IMR
      For Each oBookmark In oRange.Bookmarks
      
          If UCase(Right(oBookmark.Name, 3)) = "_NX" Then
              ChangeBookmarkName oBookmark.Name, ReturnBookmarkNameWithFirstAvailableIndex(oBookmark.Name)
          End If
          
      Next
      
'*** Fjernet af MAC
'      For Each oBookmark In oRange.Bookmarks
'
'          If UCase(Mid(oBookmark.Name, Len(oBookmark.Name) - 2, 2)) = "_N" And Not IsNumeric(Right(oBookmark.Name, 1)) Then
'              ChangeBookmarkName oBookmark.Name, GetReindexedBookmarkName(oBookmark.Name)
'          End If
'
'      Next
      
   
   Else
         ' TODO: Evt fejlh|fffd|ndtering
   End If
   
End Sub

'
' Returns a random number equal to or between lMinimum and lMaximum.
' Only positive numbers are allowed for input.
Public Function GetRandomNumber(ByVal lMinimum As Long, ByVal lMaximum As Long) As Long
   
   Dim lResult As Long
   Dim lLastRandomValue As Long
   Dim sAppName As String
   Dim sSection As String
   Dim sKey As String
   
   sAppName = mCore_FileOperationsW.RemoveExtension(ThisDocument.Name)
   sSection = "RandomResult"
   sKey = "LastRandomValue"
   
   If lMinimum < lMaximum And lMinimum > 0 Then

TryAgain:
      '
      ' Set the seed for Rnd()
      Randomize
      '
      ' Calculate a random result
      lResult = Int((lMaximum + 1 - lMinimum) * Rnd + lMinimum)
      '
      ' There is a chance that the same number comes out twice. To avoid the user
      ' exploring that we store the last value in HKEY_LOCAL_USER, so we can generate a new
      ' random value in this case.
      lLastRandomValue = CLng(GetSetting(sAppName, sSection, sKey, CStr((lMaximum - lMinimum) \ 2)))
      '
      ' Avoid the duplication scenario
      If lResult = lLastRandomValue Then
         GoTo TryAgain
      End If
      '
      ' If we get here we have a new result, so we store it for the
      ' next restore comparison above
      SaveSetting sAppName, sSection, sKey, CStr(lResult)
      '
      ' And return it
      GetRandomNumber = lResult
   
   Else
      Err.Raise 9, MODULE_NAME & "::GetRandomNumber", "Bad parameter: Parameters must be > 0 and lMinimum must be < lMaximum."
   End If
   
End Function


Public Sub UpdateFieldsEx(ByRef oDoc As Document)
   
   Dim oStoryRange As Range
   Dim oShape As Shape
   Dim oField As Field
   Dim sCode As String
   Dim oRange As Range

   For Each oStoryRange In oDoc.StoryRanges
      Do
         On Error Resume Next
         '
         ' Locked fields will raise an error.
         ' JAS TODO: Unlock, update and lock again. Should be optional, so
         ' potentially locked Date fields are NOT updated.
         oStoryRange.Fields.Update
         
         Select Case oStoryRange.StoryType
            Case 6, 7, 8, 9, 10, 11
               If oStoryRange.ShapeRange.Count > 0 Then
                  For Each oShape In oStoryRange.ShapeRange
                     If oShape.TextFrame.HasText Then
                        If oShape.TextFrame.TextRange.Fields.Count > 0 Then
                           oShape.TextFrame.TextRange.Fields.Update
                        End If
                     End If
                  Next ' oShape
               End If
            
            Case Else
                'Do Nothing
         
         End Select
         
         On Error GoTo 0
         '
         ' Get next linked story (if any)
         Set oStoryRange = oStoryRange.NextStoryRange
      Loop Until oStoryRange Is Nothing
   Next ' oStoryRange
   
End Sub

Public Sub UpdateAllFields()
   
   UpdateFieldsEx ActiveDocument
   
   On Error GoTo BailOut
   Dim lIndex As Long
   
   For lIndex = 1 To ActiveDocument.TablesOfContents.Count
      ActiveDocument.TablesOfContents(lIndex).Update
   Next

   For lIndex = 1 To ActiveDocument.TablesOfFigures.Count
      ActiveDocument.TablesOfFigures(lIndex).Update
   Next


BailOut:
   Resume Next

End Sub

Public Function SetPaperSize(Optional ByRef sPaperSizeName As String, _
                             Optional ByVal snPageWidth As Single, _
                             Optional ByVal snPageHeight As Single, _
                             Optional ByRef oDocument As Document) As Boolean

   Dim bHadErrors As Boolean
   Dim oSection As Section
   Dim ePaperSize As WdPaperSize
   
   On Error GoTo BailOut
   
   If oDocument Is Nothing Then Set oDocument = ActiveDocument
   
   If LenB(sPaperSizeName) <> 0 Then
      ePaperSize = GetPaperSizeFromName(sPaperSizeName)
      oDocument.PageSetup.PaperSize = ePaperSize
      For Each oSection In oDocument.Sections
         oSection.PageSetup.PaperSize = ePaperSize
      Next
   End If
      
   SetPaperSize = Not bHadErrors
      
   Exit Function
      
BailOut:
   bHadErrors = True
   Resume Next

End Function

Public Function GetPaperSizeFromName(sPaperSizeName) As WdPaperSize
   '
   ' Just add new sizes as need be
   Select Case LCase$(sPaperSizeName)

      Case "a5"
         GetPaperSizeFromName = wdPaperA5
      
      Case "a4"
         GetPaperSizeFromName = wdPaperA4
      
      Case "a3"
         GetPaperSizeFromName = wdPaperA3
         
      Case "a4small"
         GetPaperSizeFromName = wdPaperA4Small
         
      Case "letter"
         GetPaperSizeFromName = wdPaperLetter
      
      Case "ledger"
         GetPaperSizeFromName = wdPaperLedger
      
   End Select
   
End Function

Public Sub ShowHiddenDocuments()

   Dim oDoc As Document
   
   For Each oDoc In Documents
   #If Not Mac = 1 Then
      oDoc.ActiveWindow.Visible = True
   #End If
   Next

End Sub

' <JAS 15/7-2014: As in WE 424 or later>
Public Sub CropAndResize(Optional ctl As Variant)
      
   Dim sTag As String
   Dim oBookmark As Bookmark
   
   On Error GoTo BailOut

   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      Else
         sTag = ctl.Tag
      End If
   Else
      sTag = Application.CommandBars.ActionControl.Tag
   End If
   
   Call mPlug_PictureInCell.SelectBookmarkedPictureForEditing(sTag, ActiveDocument)

   GoTo EndFunction

BailOut:
  ' DebugMsg MODULE_NAME & "::CropAndResize: Error" & CStr(Err.Number) & " / " & Err.Description
   Resume Next

EndFunction:

End Sub
' </JAS 15/7-2014>

Public Sub CropAndResizeOld(Optional ctl As Variant)
      
   Dim sTag As String
   Dim oBookmark As Bookmark
   On Error GoTo ErrHandler

   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      Else
         sTag = ctl.Tag
      End If
   Else
      sTag = Application.CommandBars.ActionControl.Tag
   End If
   
      
   'first run ,,, dont place selection in a table
   If Not Selection.Information(wdWithInTable) Then
      Set oBookmark = ActiveDocument.Bookmarks.Add("SD_Pos", Selection.Range)
      mPlug_PictureInCell.SelectFrontPagePictureForEditing sTag
      GoTo ExitHere
   Else
      ' Is it the second run ...
      If ActiveDocument.Bookmarks.Exists("SD_Pos") Then
         mPlug_PictureInCell.IP_CropAndResize
      Else
'         MsgBox GetLanguageStringEx("%CropAndResizeCursorInTabelMessage%"), vbOKOnly, _
'         GetLanguageStringEx("%CropAndResizeCursorInTabelTitle%"), , , , , , , , False
         MsgBox "An error has occured. Please place the cursor outside a table.", vbCritical, "Edit frontpage picture"
      End If
   End If

   ' Place selection as it was and clean up
   If ActiveDocument.Bookmarks.Exists("SD_Pos") Then
      ActiveDocument.Bookmarks("SD_Pos").Select
      ActiveDocument.Bookmarks("SD_Pos").Delete
   End If

ExitHere:
   Exit Sub

ErrHandler:
   GoTo ExitHere

End Sub


Attribute VB_Name = "mCore_Language"
Option Explicit
Option Compare Text
'
' Purpose      :  Provides National Language Support
'
' Usage        :  Add strings as required to the GetLanguageString() function
'                 to implement support for multilingual templates.
'
' Dependencies :  None
'
' Created by   :  Jacob Sch|fffd|ffer
' Created      :  07. july 2014
'

Public Function GetLanguageString(ByRef sKey As String, ByRef sDefault As String) As String
'
' Add strings as required to this GetLanguageString() function
' to implement support for multilingual templates/new languages.
   
   Dim eLCID As WdLanguageID
   Dim sResult As String
   
   On Error GoTo BailOut
   eLCID = Application.Language
   '
   ' Select locale
   Select Case eLCID
      '
      ' Select a Danish string (da-DK)
      Case wdDanish
         Select Case sKey
            '
            ' ReturnPicturePath dialog
            Case "FileFilterPictureFiles":      sResult = "Billedfiler"
            Case "FileFilterAllFiles":          sResult = "Alle filer"
            Case "DialogTitlePictureFiles":     sResult = "V|fffd|lg billede ..."
            '
            ' EditFrontPagePictureInBookmark
            Case "EditFPPictureTitle":          sResult = "Rediger forsidebillede"
            Case "EditFPPictureMessage":        sResult = "Dobbeltklik p|fffd| den forside der skal benyttes og rediger forsidebilledet derefter."
            '
            ' Missing fonts dialog
            Case "MissingFontsTitle":          sResult = "Manglende skrifttyper"
            Case "MissingFontsMessage":        sResult = "Du mangler f|fffd|lgende skrifter for at arbejde med dette dokument:"
            
         End Select ' Case sKey
      '
      ' Select a non-Danish string (en-GB)
      Case Else
         Select Case sKey
            '
            ' ReturnPicturePath
            Case "FileFilterPictureFiles":      sResult = "Picture files"
            Case "FileFilterAllFiles":          sResult = "All files"
            Case "DialogTitlePictureFiles":     sResult = "Select picture ..."
            '
            ' EditFrontPagePictureInBookmark
            Case "EditFPPictureTitle":          sResult = "Edit front page picture"
            Case "EditFPPictureMessage":        sResult = "Double click the front page you want to use and then edit the picture."
            '
            ' Missing fonts dialog
            Case "MissingFontsTitle":          sResult = "Missing fonts"
            Case "MissingFontsMessage":        sResult = "You should install the following missing fonts before you work with this document:"
      
         End Select ' Case sKey
   End Select ' Case eLCID
   '
   ' If no lookup key exists we return the default value
   If LenB(sResult) <> 0 Then
      GetLanguageString = sResult
   Else
      GetLanguageString = sDefault
   End If
   
   Exit Function
   
BailOut:
   Resume Next

End Function
Attribute VB_Name = "mCore_MissingFonts"
Option Explicit
Option Compare Text
'
'

'
' Finds the missing fonts in the document
Public Function HasMissingFonts(ByRef oDoc As Document, ByRef sMissingFonts As String) As Boolean

   Dim lUndoCount As Long
   Dim oStory As Range
   Dim sTmp As String
   Dim bFailed As Boolean
   
   On Error Resume Next
     
   ' Check for missing fonts
   If Application.Dialogs(wdDialogFontSubstitution).UnavailableFont = "" Then
      ' MsgBox "No fonts missing.", vbInformation + vbOKOnly
       GoTo BailOut
   End If
   '
   ' Find the missing fonts one after the other
   Do Until Application.Dialogs(wdDialogFontSubstitution).UnavailableFont = "" Or bFailed
      '
      ' Fetch the missing font name
      sTmp = Application.Dialogs(wdDialogFontSubstitution).UnavailableFont
      '
      ' Add it to the list
      sMissingFonts = sMissingFonts & "|" & sTmp
      '
      ' Substitute the missing font on all parts of the document
      For Each oStory In oDoc.StoryRanges
         If SubstituteFont(oStory.Duplicate, sTmp) Then
            '
            ' Count the changes made
            lUndoCount = lUndoCount + 1
         Else
            bFailed = True
         End If
      Next oStory
   Loop
   '
   ' Revert the changes
   oDoc.Undo lUndoCount
   
   HasMissingFonts = (lUndoCount <> 0)
   
BailOut:

End Function

'
' Substitutes the missing fonts with "Arial" to aid in processing
Private Function SubstituteFont(ByVal rngSrc As Range, ByVal sMissingFont As String) As Boolean

    On Error Resume Next
    
    With rngSrc.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Forward = True
        .Wrap = wdFindContinue
        .Text = ""
        .Replacement.Text = ""
        .Font.Name = sMissingFont
        .Replacement.Font.Name = "Arial"
        If .Execute(Replace:=wdReplaceAll) Then
            SubstituteFont = True
        End If
    End With

End Function

Attribute VB_Name = "mCore_SharedFilehandling"
Public fso As Object

Public Function ExpandFileLocationsInPath(strVal As String) As String
    strVal = Replace(UCase(strVal), "[USERTEMPLATES]", Options.DefaultFilePath(wdUserTemplatesPath))
    strVal = Replace(UCase(strVal), "[WORKGROUPTEMPLATES]", Options.DefaultFilePath(wdWorkgroupTemplatesPath))
    strVal = Replace(UCase(strVal), "[STARTUP]", Options.DefaultFilePath(wdStartupPath))
    ExpandFileLocationsInPath = strVal
End Function

Public Function FindFileInDefaultFilepaths(strFilename As String) As String
    CreateFSO
    If fso.FileExists(StartupPath & strFilename) Then
        FindFileInDefaultFilepaths = StartupPath & strFilename
        Exit Function
    ElseIf fso.FileExists(UserTemplatesPath & strFilename) Then
        FindFileInDefaultFilepaths = UserTemplatesPath & strFilename
        Exit Function
    ElseIf fso.FileExists(WorkgroupTemplatesPath & strFilename) Then
        FindFileInDefaultFilepaths = WorkgroupTemplatesPath & strFilename
        Exit Function
    ElseIf fso.FileExists(EnsureTrailingBackslash(ActiveDocument.AttachedTemplate.Path) & strFilename) Then
        FindFileInDefaultFilepaths = EnsureTrailingBackslash(ActiveDocument.AttachedTemplate.Path) & strFilename
        Exit Function
'    ElseIf fso.FileExists(EnsureTrailingBackslash(ActiveDocument.Path) & strFilename) Then
'        FindFileInDefaultFilepaths = EnsureTrailingBackslash(ActiveDocument.Path) & strFilename
'        Exit Function
    ElseIf fso.FileExists(strFilename) Then
        FindFileInDefaultFilepaths = strFilename
        Exit Function
    Else
        FindFileInDefaultFilepaths = ""
    End If
End Function

Public Property Get StartupPath() As String
    Dim strVal As String
    strVal = Options.DefaultFilePath(wdStartupPath)
    If strVal <> "" Then
        StartupPath = EnsureTrailingBackslash(strVal)
    End If
End Property

Public Property Get UserTemplatesPath() As String
    Dim strVal As String
    strVal = Options.DefaultFilePath(wdUserTemplatesPath)
    If strVal <> "" Then
        UserTemplatesPath = EnsureTrailingBackslash(strVal)
    End If
End Property

Public Property Get WorkgroupTemplatesPath() As String
    Dim strVal As String
    strVal = Options.DefaultFilePath(wdWorkgroupTemplatesPath)
    If strVal <> "" Then
        WorkgroupTemplatesPath = EnsureTrailingBackslash(strVal)
    End If
End Property

Public Sub CreateFSO()
    If fso Is Nothing Then
        Set fso = CreateObject("Scripting.FileSystemObject")
    End If
End Sub

Function EnsureTrailingBackslash(strVal As String) As String
    strVal = strVal & "\"
    If Right(strVal, 2) = "\\" Then
        strVal = Left(strVal, Len(strVal) - 1)
    End If
    EnsureTrailingBackslash = strVal
End Function
Attribute VB_Name = "mDialogFunctions"
Option Explicit
Option Compare Binary
'
' Purpose      :  Implements functionality to Set/Get the position of UserForm
'                 objects and alter their behaviour.
'
'                 Implements the following Public functions:
'
'                 ControlExists           ' Looks up a IFormControl object by FullName and returns True if found
'                 FormAction              ' ??? Hmmm ... may be a redundant function ???
'                 InputBox                ' Substitutes the VBA InputBox function
'                 LoadFormPosition        ' Sets the Left/Top coordinates from last time the UserForm was displayed.
'                 MsgBox                  ' Substitutes the VBA MsgBox function
'                 SaveFormPosition        ' Saves the Left/Top coordinates for a UserForm.
'                 SetFormBorders          ' Sets the style bits for a UserForm object to "sizable" and/or "toolbox".
'                 SetFormLanguage         ' Applies language strings to all controls on a UserForm
'                 SetFormLayout           ' Applies global styling and colouring of controls.
'                 ShowDialog              ' Displays a UserForm by Name
'
' Dependencies :  mCore_FileOperationsW.bas
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  20. july 2010
' Last modified:  02. december 2010 /JAS  ' Changed key for storage in HKCU to accomodate the need for
'                                         ' dealing with multiple instances individually.
'                 18. August 2011 /JAS    1) Function ControlExists() added.
'                                         2) Function FormAction() added
'                 25. August 2011 /JAS    1) 32/64-bit 2010 support implemented.
'
' Remarks      :  Load/SaveFormPosition reads/writes from/to the Registry key:
'                 HKCU\Software\VB and VBA Program Settings\<RemoveExtension(ThisDocument.Name)>
'
' TODO         :  Implement support for automatic centering on a specific monitor in cases where
'                 the user actually have more than one monitor available.
'
Private Const MODULE_NAME As String = "mDialogFunctions"

Public Const vbaPointsToPixels As Single = 1.33333333333

Private Const WS_THICKFRAME As Long = &H40000   ' Resize bit flag
Private Const WS_CAPTION As Long = &HC00000     ' Caption bit flag

Private Const WS_EX_TOOLWINDOW As Long = &H80   ' ToolWindow bit flag (EX style)
Private Const GWL_STYLE As Long = -16           ' Get or set bit flag
Private Const GWL_EXSTYLE As Long = -20         ' Get or set extended styles

Public Const HWND_BOTTOM = 1
Public Const HWND_TOP = 0
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2
Public Const SWP_FRAMECHANGED = &H20        '  The frame changed: send WM_NCCALCSIZE
Public Const SWP_HIDEWINDOW = &H80
Public Const SWP_NOACTIVATE = &H10
Public Const SWP_NOCOPYBITS = &H100
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOOWNERZORDER = &H200      '  Don't do owner Z ordering
Public Const SWP_NOREDRAW = &H8
Public Const SWP_NOSIZE = &H1
Public Const SWP_NOZORDER = &H4
Public Const SWP_SHOWWINDOW = &H40
Public Const SWP_NOREPOSITION = SWP_NOOWNERZORDER
Public Const SWP_DRAWFRAME = SWP_FRAMECHANGED
Public Const WM_SETREDRAW = &HB
'
' Expose to all forms
Public Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

#If VBA7 Then
   Dim p_hWndWordDoc As LongPtr
   Dim p_hWndEditArea As LongPtr
#Else
   Dim p_hWndWordDoc As Long
   Dim p_hWndEditArea As Long
#End If

#If VBA7 Then
   
   Private Declare PtrSafe Function SendMessageW Lib "user32" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long
   
   #If Win64 Then
      Private Declare PtrSafe Function GetWindowLongPtr Lib "user32" Alias "GetWindowLongPtrA" (ByVal hWnd As LongPtr, ByVal nIndex As Long) As LongPtr
      Private Declare PtrSafe Function SetWindowLongPtr Lib "user32" Alias "SetWindowLongPtrA" (ByVal hWnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
   #Else
      Private Declare PtrSafe Function GetWindowLongPtr Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As LongPtr, ByVal nIndex As Long) As LongPtr
      Private Declare PtrSafe Function SetWindowLongPtr Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
   #End If
   
   Public Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
   '
   ' Declared Public to avoid having them on all forms (the first four).
   Public Declare PtrSafe Function FindWindowW Lib "user32" (ByVal lpClassName As LongPtr, ByVal lpWindowName As LongPtr) As LongPtr
   Public Declare PtrSafe Function FindWindowExW Lib "user32" (ByVal hWnd1 As LongPtr, ByVal hWnd2 As LongPtr, ByVal lpsz1 As LongPtr, ByVal lpsz2 As LongPtr) As Long
   Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
   Public Declare PtrSafe Function GetClientRect Lib "user32" (ByVal hWnd As LongPtr, lpRect As RECT) As Long
   Public Declare PtrSafe Function GetWindowRect Lib "user32" (ByVal hWnd As LongPtr, lpRect As RECT) As Long
   Public Declare PtrSafe Function GetParent Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
   Public Declare PtrSafe Function SetParent Lib "user32" (ByVal hWndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
   Public Declare PtrSafe Function GetWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal wCmd As Long) As LongPtr
   Public Declare PtrSafe Function IsWindow Lib "user32" (ByVal hWnd As LongPtr) As Long
   Private Declare PtrSafe Function LockWindowUpdate Lib "user32" (ByVal hWndLock As LongPtr) As Long
   Private Declare PtrSafe Function OleTranslateColor Lib "oleaut32.dll" (ByVal lOleColor As Long, ByVal hPal As LongPtr, ByRef lpColorRef As Any) As Long
#Else

   Private Declare Function SendMessageW Lib "user32" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long
   
   Private Declare Function GetWindowLongPtr Lib "User32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
   Private Declare Function SetWindowLongPtr Lib "User32.dll" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
   Public Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal flags As Long) As Long
   '
   ' Declared Public to avoid having them on all forms (the first four).
   Public Declare Function FindWindowW Lib "user32" (ByVal lpClassName As Long, ByVal lpWindowName As Long) As Long
   Public Declare Function FindWindowExW Lib "user32" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As Long, ByVal lpsz2 As Long) As Long
   Public Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
   Public Declare Function GetClientRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
   Public Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
   Public Declare Function GetParent Lib "user32" (ByVal hWnd As Long) As Long
   Public Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
   Public Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
   Public Declare Function IsWindow Lib "user32" (ByVal hWnd As Long) As Long
   Private Declare Function LockWindowUpdate Lib "user32" (ByVal hWndLock As Long) As Long
   Private Declare Function OleTranslateColor Lib "olepro32.dll" (ByVal lOleColor As Long, ByVal hPal As Long, ByRef lpColorRef As Long) As Long
#End If
Private Const CLR_INVALID = -1
'
' GetWindow() Constants
Private Const GW_HWNDFIRST = 0
Private Const GW_HWNDLAST = 1
Private Const GW_HWNDNEXT = 2
Private Const GW_HWNDPREV = 3
Private Const GW_OWNER = 4
Private Const GW_CHILD = 5
Private Const GW_MAX = 5
      
Public Type RGBTRIPLE
   Blue As Byte
   Green As Byte
   Red As Byte
End Type

Public Enum enMessageBoxButtons
   embbOKOnly = VbMsgBoxStyle.vbOKOnly
   embbOKCancel = VbMsgBoxStyle.vbOKCancel
   embbAbortRetryIgnore = VbMsgBoxStyle.vbAbortRetryIgnore
   embbYesNoCancel = VbMsgBoxStyle.vbYesNoCancel
   embbYesNo = VbMsgBoxStyle.vbYesNo
   embbRetryCancel = VbMsgBoxStyle.vbRetryCancel
End Enum

Public Enum enMessageBoxIcons
   embiNone = 8
   embiCritical = VbMsgBoxStyle.vbCritical
   embiQuestion = VbMsgBoxStyle.vbQuestion
   embiExclamation = VbMsgBoxStyle.vbExclamation
   embiInformation = VbMsgBoxStyle.vbInformation
End Enum

Private p_oDialogsResultCache As cPropertyBagsCollection
'
' Regarding Calls to WE from External sources
Private p_sExtCallerAppID As String
Private p_lCallingStartTime As Long
Private p_oExtTimer As cPerformanceTester
'

Public Property Get DialogsResultCache(Optional bForceRefresh As Boolean) As cPropertyBagsCollection
   If p_oDialogsResultCache Is Nothing Or bForceRefresh Then
      Set p_oDialogsResultCache = New cPropertyBagsCollection
   Else
      Set DialogsResultCache = p_oDialogsResultCache
   End If
End Property

'Public Function DumpToDialogsResultCache(ByRef oDialogObject As ufWordEngine) As Boolean
'
'   Dim oThisControl As control
'   Dim oThisPropSet As cPropertyBag
'   Dim oThisProp As cPropertyObject
'   Dim sTemp As String
'   Dim sName As String
'   Dim lPos As Long
'   Dim sValue As Variant
'
'   On Error GoTo BailOut
'   '
'   ' We don't monitor our own Engine, since it's an Add-In - it's NOT a document.
'   If ActiveDocument.Name = ThisDocument.Name Then
'      MsgBox "Dear developer. Please open a new document to work on :-)" & vbCr & "We don't cache information for " & ThisDocument.Name, vbCritical Or vbOKOnly, "For your eyes only"
'     ' Exit Function
'   End If
'   '
'   ' Sanity check. We need an object to work with.
'   If p_oDialogsResultCache Is Nothing Then
'      Set p_oDialogsResultCache = New cPropertyBagsCollection
'   End If
'   '
'   ' Locate which property set we work on
'  ' sTemp = RemoveExtension(ActiveDocument.Name) & ":" & oDialogObject.Tag
'   sTemp = RemoveExtension(ActiveDocument.Name) & ":" & oDialogObject.FormName
'   '
'   ' If this property set already exists we clear any entry it contain.
'   If p_oDialogsResultCache.Exists(sTemp) Then
'      p_oDialogsResultCache.Clear
'   End If
'   '
'   ' Prepare the object that collect userform properties
'   Set oThisPropSet = New cPropertyBag
'   '
'   ' Iterate to fetch these properties
'   For Each oThisControl In oDialogObject.Controls
'      '
'      ' Filter the form prefix if such a beast exists
'      lPos = InStr(1, oThisControl.Name, "_")
'      If lPos <> 0 Then
'         sName = Mid$(oThisControl.Name, lPos + 1)
'      Else
'         sName = oThisControl.Name
'      End If
'      '
'      ' Add the property. If this property does NOT have a .Value property
'      ' the .Value call will raise an error and the BailOut "Resume Next" will
'      ' assure that we continue our search until all controls have been examinated.
'      '
'      ' The Property Bag will hold all required Key/Value pairs we need.
'      oThisPropSet.Add sName, oThisControl.Value, , TypeName(oThisControl)
'   Next
'   '
'   ' Add the PropertyBag to our collection class, and don NOT accept
'   ' duplicate identifier keys
'   p_oDialogsResultCache.Add oThisPropSet, sTemp, , , False
'
'   GoTo EndFunction
'
'BailOut:
'   DebugMsg "Test" & "::DumpToDialogsResultCache: Error " & CStr(Err.Number) & ": " & Err.Description
'   Resume Next
'
'EndFunction:
'
'End Function

'
' Looks up a Control by FullName and returns True if found
'Public Function ControlExists(sControlName As String, ByRef colControls As Collection) As Boolean
'
'  ' Dim oControl
'' <JAS 18/8-2011>
'   Dim oControl As IFormControl
'' </JAS 18/8-2011>
'
'   For Each oControl In colControls
'      If oControl.FullName = sControlName Then
'         ControlExists = True
'         Exit Function
'      End If
'   Next
'End Function

'
' Points to a Client function that does what the form requires.

'
Public Sub SetFormLayout(ByRef oUserForm As Object)
   
   Dim i As Long
   Dim sTmp As String
   '
   ' Use the same font as MS Office. ClearType should be enabled in Display Properties
   Dim sF As New StdFont
   With sF
      .Name = "Segoe UI"
      .Size = 8
   End With
           
   With oUserForm
      .BackColor = SystemColorConstants.vbButtonFace
      '
      ' OOPS! Controls are a base-0 array
      For i = 0 To .Controls.Count - 1
         sTmp = TypeName(.Controls(i))
         Select Case sTmp
            '
            ' Set properties for TextBox AND ComboBox elements
            Case "TextBox", "ComboBox"
               .Controls(i).SpecialEffect = fmSpecialEffectFlat
               .Controls(i).BorderStyle = fmBorderStyleSingle
               .Controls(i).BorderColor = SystemColorConstants.vbButtonShadow
               .Controls(i).BackStyle = fmBackStyleOpaque
               .Controls(i).BackColor = SystemColorConstants.vbWindowBackground
               If sTmp = "TextBox" Then
                  If Not .Controls(i).MultiLine Then
                     .Controls(i).Height = 15
                  End If
                  If .Controls(i).locked Then
                     .Controls(i).BackStyle = fmBackStyleTransparent
                  End If
               Else
                  .Controls(i).Height = 15
               End If
            '
            ' Set properties for ListBox elements
            Case "ListBox"
               .Controls(i).SpecialEffect = fmSpecialEffectFlat
               .Controls(i).BorderStyle = fmBorderStyleSingle
               .Controls(i).BorderColor = SystemColorConstants.vbButtonShadow
               .Controls(i).BackColor = SystemColorConstants.vbWindowBackground
               .Controls(i).Height = 15
            
            Case "Label"
               If LCase$(.Controls(i).Tag) = "hidden" Then
                  .Controls(i).SpecialEffect = fmSpecialEffectFlat
                  .Controls(i).BorderStyle = fmBorderStyleSingle
                  .Controls(i).BorderColor = SystemColorConstants.vbButtonShadow
                  .Controls(i).BackColor = SystemColorConstants.vbWindowBackground
               Else
                  .Controls(i).BorderStyle = fmBorderStyleNone
                 ' .Controls(I).BorderStyle = fmBorderStyleSingle ' Use for visual size/position debugging
                  .Controls(i).BackStyle = fmBackStyleTransparent
               End If
            
            Case "CommandButton"
               .Controls(i).BackStyle = fmBackStyleOpaque
               .Controls(i).Height = 21
            
            Case "Frame"
              ' .Controls(I).BorderStyle = fmBorderStyleNone
               .Controls(i).SpecialEffect = fmSpecialEffectEtched
              ' .Controls(I).BackStyle = fmBackStyleTransparent
              ' sF.Bold = True
              ' Set .Controls(I).Font = sF
            '
            ' Set properties for other elements
            Case Else
            
         End Select
         '
         ' For labels, set font to Bold if the Tag property indicates so
         If sTmp = "Label" Then
            sF.Bold = IIf(.Controls(i).Tag = "Heading", True, False)
            Set .Controls(i).Font = sF
         End If
      
      Next
      
   End With
   
   Set sF = Nothing

End Sub

Public Sub SetFormFont(ByRef oUserForm As Object)
   
   Dim i As Long
   Dim sTmp As String
   '
   ' Use the same font as MS Office. ClearType should be enabled in Display Properties
   Dim sF As New StdFont
   With sF
      .Name = "Segoe UI"
      .Size = 8.25
   End With
           
   With oUserForm
      '
      ' OOPS! Controls are a base-0 array
      For i = 0 To .Controls.Count - 1
         sTmp = TypeName(.Controls(i))
         '
         ' For labels, set font to Bold if the Tag property indicates so
         If sTmp = "Label" Then
            sF.Bold = IIf(.Controls(i).Tag = "Heading", True, False)
            Set .Controls(i).Font = sF
         End If
      
      Next
      
   End With
   
   Set sF = Nothing

End Sub


'Public Sub SetFormLanguage(ByRef oUserForm As Object, Optional ByVal bForceRefresh As Boolean)
'
'   Dim I As Long
'   Dim sTmp As String
'   Dim sCaption As String
'
'   If bForceRefresh Then
'      Call mLanguage.CreateGUILanguageTable(True)
'   End If
'
'   With oUserForm
'      '
'      ' The forms title
'      .Caption = GetLanguageStringEx(.Name & "DialogTitle", .Name & "DialogTitle")
'      '
'      ' OOPS! Controls are a base-0 array
'      For I = 0 To .Controls.Count - 1
'         sTmp = TypeName(.Controls(I))
'         Select Case sTmp
'            '
'            ' Set properties for controls with a Caption property
'            Case "Label"
'               If LCase$(.Controls(I).Tag) = "hidden" Then
'                  .Controls(I).Caption = ""
'               ElseIf LCase$(.Controls(I).Tag) = "intro" Then
'                  sCaption = GetLanguageStringEx(.Name & .Controls(I).Name, .Name & .Controls(I).Name)
'                  If sCaption = .Name & .Controls(I).Name Then
'                     .Controls(I).Caption = ""
'                  Else
'                     .Controls(I).Caption = sCaption
'                  End If
'               Else
'                  .Controls(I).Caption = GetLanguageStringEx(.Name & .Controls(I).Name, .Name & .Controls(I).Name)
'               End If
'
'              ' DebugMsg .Name & .Controls(I).Name
'
'            Case "CommandButton", "OptionButton", "CheckBox"
'               .Controls(I).Caption = GetLanguageStringEx(.Name & .Controls(I).Name, .Name & .Controls(I).Name)
'
'            Case "Frame"
'               If InStr(1, .Name, "ufWordEngine", vbTextCompare) = 1 Then
'                  If LenB(.Controls(I).Caption) <> 0 Then
'                     .Controls(I).Caption = GetLanguageStringEx(.Name & .Controls(I).Name, .Name & .Controls(I).Name)
'                  End If
'               Else
'                  .Controls(I).Caption = GetLanguageStringEx(.Name & .Controls(I).Name, .Name & .Controls(I).Name)
'               End If
'             '  DebugMsg .Name & .Controls(I).Name
'
'            '
'            ' Set properties for other elements
'            Case Else
'
'         End Select
'
'      Next
'
'   End With
'
'End Sub

'Public Sub SetFrameProperties(ByRef oHostFrame As MSForms.Frame, Optional sNamePrefix As String, Optional ByVal bForceRefresh As Boolean)
'
'   Dim I As Long
'   Dim sTmp As String
'   Dim sCaption As String
'
'   On Error GoTo BailOut
'   '
'   ' Use the same font as MS Office. ClearType should be enabled in Display Properties
'   Dim sF As New StdFont
'   With sF
'      .Name = "Segoe UI"
'     ' .Size = 9 * UImagnificationConstant
'      .Size = 8.5 * UImagnificationConstant
'   End With
'
'   If Not oHostFrame Is Nothing Then
'
'      If bForceRefresh Then
'         Call mLanguage.CreateGUILanguageTable(True)
'      End If
'
'      With oHostFrame
'         '
'         .SpecialEffect = fmSpecialEffectFlat
'         .Caption = ""
'         If .Tag = "Background" Then
'            .BorderStyle = fmBorderStyleSingle
'            .BorderColor = SystemColorConstants.vbButtonShadow
'            .BackColor = TranslateColor(RGB(255, 255, 255))
'         ElseIf .Tag = "Border" Then
'            .BorderStyle = fmBorderStyleSingle
'            .BorderColor = SystemColorConstants.vbButtonShadow
'         Else
'            .BorderStyle = fmBorderStyleNone
'         End If
'         '
'         ' OOPS! Controls are a base-0 array
'         For I = 0 To .Controls.Count - 1
'            sTmp = TypeName(.Controls(I))
'            Select Case sTmp
'               '
'               ' Set properties for controls with a Caption property
'               Case "Label"
'                  .Controls(I).AutoSize = True
'                  If LCase$(.Controls(I).Tag) = "hidden" Then
'                     .Controls(I).SpecialEffect = fmSpecialEffectFlat
'                     .Controls(I).BorderStyle = fmBorderStyleSingle
'                     .Controls(I).BorderColor = SystemColorConstants.vbButtonShadow
'                     .Controls(I).BackColor = SystemColorConstants.vbWindowBackground
'                  Else
'                     .Controls(I).BorderStyle = fmBorderStyleNone
'                    ' .Controls(I).BorderStyle = fmBorderStyleSingle ' Use ONLY for visual size/position debugging
'                     .Controls(I).BackStyle = fmBackStyleTransparent
'                  End If
'                  If LCase$(.Controls(I).Tag) = "hidden" Then
'                     .Controls(I).Caption = ""
'                  ElseIf LCase$(.Controls(I).Tag) = "intro" Then
'                     sCaption = GetLanguageStringEx(sNamePrefix & .Controls(I).Name, sNamePrefix & .Controls(I).Name)
'                     If sCaption = sNamePrefix & .Controls(I).Name Then
'                        .Controls(I).Caption = ""
'                     Else
'                        .Controls(I).Caption = sCaption
'                     End If
'                  ElseIf LCase$(.Controls(I).Tag) = "divider" Then
'                     .Controls(I).Caption = ""
'                     .Controls(I).BorderStyle = fmBorderStyleSingle
'                     .Controls(I).BorderColor = SystemColorConstants.vbButtonShadow
'                  Else
'                     If InStr(1, .Controls(I).Tag, "PreserveCaption", vbTextCompare) <> 0 Then
'                       ' Debug.Print ""
'                     End If
'                     '
'                     ' Top and Tip texts can't have KeyPreview and captions are set elsewhere
'                     If InStr(1, .Controls(I).Name, "Tip", vbTextCompare) = 0 And _
'                        InStr(1, .Controls(I).Name, "Top", vbTextCompare) = 0 Then
'                           Call mDialogFunctions.SetCaptionAndAccelerator(.Controls(I), GetLanguageStringEx(sNamePrefix & .Controls(I).Name, sNamePrefix & .Controls(I).Name))
'                     Else
'                        .Controls(I).AutoSize = True
'                     End If
'                  End If
'               '
'               ' Set properties for TextBox AND ComboBox elements
'               Case "TextBox", "ComboBox"
'                  .Controls(I).SpecialEffect = fmSpecialEffectFlat
'                  .Controls(I).BorderStyle = fmBorderStyleSingle
'                  .Controls(I).BorderColor = SystemColorConstants.vbButtonShadow
'                  .Controls(I).BackStyle = fmBackStyleOpaque
'
'                  .Controls(I).BackColor = SystemColorConstants.vbWindowBackground
'
'                  If sTmp = "TextBox" Then
'                     If Not .Controls(I).MultiLine Then
'                        .Controls(I).Height = 15 * UImagnificationConstant
'                     End If
'                     If .Controls(I).locked Then
'                        .Controls(I).BackStyle = fmBackStyleTransparent
'                     End If
'                  Else
'                     .Controls(I).Height = 15 * UImagnificationConstant
'                     .Controls(I).ListStyle = fmListStylePlain
'                     .Controls(I).ListRows = 20
'                     .Controls(I).Style = fmStyleDropDownList
'                     .Controls(I).MatchRequired = True
'                    ' .Controls(I).ShowDropButtonWhen = fmShowDropButtonWhenFocus
'                  End If
'
'               Case "CommandButton"
'                  .Controls(I).BackStyle = fmBackStyleOpaque
'                  .Controls(I).Height = 21 * UImagnificationConstant
'                  Call mDialogFunctions.SetCaptionAndAccelerator(.Controls(I), GetLanguageStringEx(sNamePrefix & .Controls(I).Name, sNamePrefix & .Controls(I).Name))
'
'               Case "OptionButton", "CheckBox"
'                  .Controls(I).BackStyle = fmBackStyleOpaque
'                  .Controls(I).Height = 15 * UImagnificationConstant
'                  Call mDialogFunctions.SetCaptionAndAccelerator(.Controls(I), GetLanguageStringEx(sNamePrefix & .Controls(I).Name, sNamePrefix & .Controls(I).Name))
'
'               Case "Frame"
'                  .Controls(I).Caption = ""
'                  .Controls(I).SpecialEffect = fmSpecialEffectFlat
'                  If .Controls(I).Tag = "Background" Then
'                     .Controls(I).BorderStyle = fmBorderStyleSingle
'                     .Controls(I).BorderColor = SystemColorConstants.vbButtonShadow
'                  Else
'                     .Controls(I).BorderStyle = fmBorderStyleNone
'                  End If
'
'               '
'               ' Set properties for other elements
'               Case Else
'
'            End Select
'            '
'            ' For labels, set font to Bold if the Tag property indicates so
'            If sTmp = "Label" Then
'               '
'               ' Top and Tip texts can't have KeyPreview and captions are set elsewhere
'               If (InStr(1, .Controls(I).Name, "Tip", vbTextCompare) <> 0) Or (InStr(1, .Controls(I).Name, "Top", vbTextCompare) <> 0) Then
'                 ' Debug.Print .Controls(I).Name
'                  sF.Size = 6.5 * UImagnificationConstant
'                  .Controls(I).ForeColor = SystemColorConstants.vbGrayText
'               Else
'                 ' sF.Size = 9 * UImagnificationConstant
'                  sF.Size = 8.5 * UImagnificationConstant
'                  .Controls(I).ForeColor = SystemColorConstants.vbButtonText
'               End If
'               sF.Bold = IIf(.Controls(I).Tag = "Heading", True, False)
'            Else
'              ' sF.Size = 9 * UImagnificationConstant
'               sF.Size = 8.5 * UImagnificationConstant
'               sF.Bold = IIf(.Controls(I).Tag = "Heading", True, False)
'            End If
'
'            If sTmp <> "Image" Then
'               Set .Controls(I).Font = sF
'            End If
'
'         Next
'
'      End With
'
'   End If
'
'   GoTo EndFunction
'
'BailOut:
'   DebugMsg MODULE_NAME & "::SetFrameProperties: Error " & Err.Number & "/" & Err.Description, dbgLogError
'   Resume Next
'
'EndFunction:
'   '
'   ' Potentially clean the house
'
'End Sub


'
Public Sub SaveFormPosition(ByRef oUserForm As Object, _
                            Optional ByVal bIncludeWidth As Boolean = False, _
                            Optional ByVal bIncludeHeight As Boolean = False)
'
' Write settings to the registry
' HKCU\Software\VB and VBA Program Settings\<sKey>

   Dim sKey As String
   sKey = mCore_FileOperationsW.RemoveExtension(ThisDocument.Name)
   
   If Len(oUserForm.Name) > 0 Then
     SaveSetting sKey, oUserForm.Caption, "Left", CStr(oUserForm.Left)
     SaveSetting sKey, oUserForm.Caption, "Top", CStr(oUserForm.Top)
   
     If bIncludeWidth Then SaveSetting sKey, oUserForm.Caption, "Width", CStr(oUserForm.Width)
     If bIncludeHeight Then SaveSetting sKey, oUserForm.Caption, "Height", CStr(oUserForm.Height)
   End If
End Sub
 
'
Public Sub LoadFormPosition(ByRef oUserForm As Object, _
                            Optional ByVal lLeftDefault As Long = 180, _
                            Optional ByVal lTopDefault As Long = 110, _
                            Optional ByVal lWidthDefault As Long = -1, _
                            Optional ByVal lHeightDefault As Long = -1)
'
' Read settings from the registry
' HKCU\Software\VB and VBA Program Settings\<sKey>
 
   Dim sKey As String
   sKey = mCore_FileOperationsW.RemoveExtension(ThisDocument.Name)
   
   Dim lLeft As Long, lTop As Long, lWidth As Long, lHeight As Long

   lLeft = CLng(GetSetting(sKey, oUserForm.Caption, "Left", CStr(lLeftDefault)))
   lTop = CLng(GetSetting(sKey, oUserForm.Caption, "Top", CStr(lTopDefault)))
   
   If lWidthDefault > 0 Then
      lWidth = CLng(GetSetting(sKey, oUserForm.Caption, "Width", CStr(lWidthDefault)))
   End If
   
   If lHeightDefault > 0 Then
      lHeight = CLng(GetSetting(sKey, oUserForm.Caption, "Height", CStr(lHeightDefault)))
   End If
   
   oUserForm.StartUpPosition = 0
   oUserForm.Left = lLeft
   oUserForm.Top = lTop
   If lWidthDefault > 0 And lWidth > 0 Then oUserForm.Width = lWidth
   If lHeightDefault > 0 And lHeight > 0 Then oUserForm.Height = lHeight
 
End Sub

#If VBA7 Then
   Public Sub SetFormBorders(ByVal hWnd As LongPtr, ByVal bMakeSizable As Boolean, ByVal bMakeToolWindow As Boolean)
   Dim lStyle As LongPtr
#Else
   Public Sub SetFormBorders(ByVal hWnd As Long, ByVal bMakeSizable As Boolean, ByVal bMakeToolWindow As Boolean)
   Dim lStyle As Long
#End If
   '
   ' Get existing style bits and add WS_THICKFRAME to make it sizable
   If bMakeSizable Then
      lStyle = GetWindowLongPtr(hWnd, GWL_STYLE)
      Call SetWindowLongPtr(hWnd, GWL_STYLE, lStyle Or WS_THICKFRAME)
   End If
   '
   ' Get existing EX style bits and add WS_EX_TOOLWINDOW to make it "palette" style
   If bMakeToolWindow Then
      lStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE)
      Call SetWindowLongPtr(hWnd, GWL_EXSTYLE, lStyle Or WS_EX_TOOLWINDOW)
   End If
   
End Sub

'
' This function MUST know the relation between the form name
' defined in our XML code and how to load the form.
'
' This ShowDialog() function can be called from any instance of the
' cMenuSectionButtonCommands class, ie. ANY cMenuSectionButton instance
' can show the dialog by calling its own .Execute() method. This way
' we can define Menu Section Buttons in XML that displays the dialog.
'
' Similarly for cRibbonControlCommands called from cRibbonControl instances.
'Public Function ShowDialog(ByVal sDialogName As String, eShowMode As FormShowConstants) As Boolean
'
'   Select Case LCase$(sDialogName)
'
'      Case "ufwordengine"
'         '[HACK]: find a way to configure a type of WordEngine that handles this
'         If Not TestForUserprofilesSetup Then
'            Exit Function
'         End If
'         If AllowDocInfoShow Then
'            ShowDocumentInfoForm "DocumentInfo", eShowMode
'            ShowDialog = True
'         Else
'            ShowDialog = False
'         End If
'
'      Case "ufuserprofileseditor"
'         Call ShowDocumentInfoForm("UserProfilesEditor", vbModal)
'
'      Case "ufcorporatesignature"
'         If Not TestForUserprofilesSetup Then
'            Exit Function
'         End If
'         Call ShowDocumentInfoForm("CorporateSignatureForm", vbModal)
'
'      Case "appendixreference"
'         If ReadCustomDocumentProperty("HasAppendixReference", ActiveDocument) = "True" Then
'
'            Call ShowDocumentInfoForm("AppendixReference", vbModal)
'            ShowDialog = True
'         End If
'
'      Case "ufsampleform"
'         ufSampleForm.Show eShowMode
'         ShowDialog = True
'
'      Case "ufmessage"
'         ufMessage.Show eShowMode
'         ShowDialog = True
'
'      Case "ufabout"
'         ufAbout.Show eShowMode
'         ShowDialog = True
'
'      Case "ufquickprint"
'         ufQuickPrint.Show eShowMode
'         ShowDialog = True
'
'      Case "ufcultures"
'         ufCultures.Show eShowMode
'         ShowDialog = True
'
'      Case "uftemplatebuilder"
'         ufTemplateBuilder.Show eShowMode
'         ShowDialog = True
'
'      Case "ufdate"
'         If ActiveDocument.Bookmarks.Exists("SD_FLD_DocumentDate") Or ActiveDocument.Bookmarks.Exists("bmkDocumentDate") Then
'            ufDate.Show eShowMode
'            ShowDialog = True
'         Else
'            MsgBox GetLanguageStringEx("ufDateMsgDocumentNotPrepared", "This document is not prepared for this function."), _
'                   vbOKCancel Or vbInformation, _
'                   GetLanguageStringEx("ufDateMsgDocumentNotPreparedTitle", "Insert/Modify Date")
'         End If
'
'      Case "ufnumofannexes"
'         '
'         ' Prim|fffd|rt til FIR, FMN og FAUK skabeloner
'         If ActiveDocument.Bookmarks.Exists("bmkNumOfAnnexes") Then
'            ufNumOfAnnexes.Show eShowMode
'            ShowDialog = True
'         Else
'            MsgBox "Bilagsfeltet i denne dokumenttype er ikke forberedt for anvendelse af Inds|fffd|t/ret antal bilag funktionen.", vbOKCancel Or vbInformation, "Inds|fffd|t/ret antal bilag"
'         End If
'
'      Case "ufdocumentnumber"
'         '
'         ' Prim|fffd|rt til FIR, FMN og FAUK skabeloner
'         If ActiveDocument.Bookmarks.Exists("dok_aktlbnr") Then
'            ufDocumentNumber.Show eShowMode
'            ShowDialog = True
'         Else
'            MsgBox "Denne dokumenttype er ikke forberedt for anvendelse af Ret/inds|fffd|t dokumentnummer funktionen.", vbOKCancel Or vbInformation, "Ret/inds|fffd|t dokumentnummer"
'         End If
'
'      Case "ufdocprops"
'         ufDocProps.Show eShowMode
'         ShowDialog = True
'
'      Case "uflabels"
'         ufLabels.Show eShowMode
'         ShowDialog = True
'
'      '
'      ' Return False if unsuccessful so we can trace the error with DbgView.exe
'      ' at runtime (cMenuSectionButtonCommands.ShowDialog() will report the error).
'      Case Else
'
'         Call ShowDocumentInfoForm(sDialogName, eShowMode, , ActiveDocument)
'         ShowDialog = True
'
'   End Select
'
'End Function
'
'Public Function ExtShowProfilesDialog(ByRef sCallerAppID As Variant) As String
'
'   On Error Resume Next
'   InitializeWordEngine
'   Call ShowDocumentInfoForm("UserProfilesEditor", vbModal)
'
'   ExtShowProfilesDialog = mSettings.CurrentGlobalXMLDoc.GetMarkup
'
'
'End Function

'Public Sub ExtLockDocumentWindow(Optional ByRef oDocument As Object, _
'                                 Optional ByRef sCallerAppID As Variant, _
'                                 Optional ByVal bUseTimer As Variant = True, _
'                                 Optional ByVal bSimulateOnly As Variant)
'
'   DebugMsg "Entering ExtLockDocumentWindow function"
'
'   If bUseTimer Then
'      Set p_oExtTimer = New cPerformanceTester
'      p_oExtTimer.StartTimer
'   End If
'
'   If oDocument Is Nothing Then
'      Set oDocument = GetActiveDocument
'   End If
'
'   p_sExtCallerAppID = sCallerAppID
'
'   If Not bSimulateOnly Then
'      DebugMsg "Locking " & oDocument.Name & " by request from " & p_sExtCallerAppID
'      LockWord oDocument
'   Else
'      DebugMsg "Simulating lock on " & oDocument.Name & " by request from " & p_sExtCallerAppID
'   End If
'
'End Sub

'Public Sub ExtUnlockDocumentWindow(Optional ByRef oDocument As Object)
'
'   If oDocument Is Nothing Then
'      Set oDocument = GetActiveDocument
'   End If
'
'   DebugMsg "Releasing locking on " & oDocument.Name & " by request from " & p_sExtCallerAppID
'   UnlockWord oDocument
'
'   If Not p_oExtTimer Is Nothing Then
'      p_oExtTimer.StopTimer
'      DebugMsg "The locked process took " & p_oExtTimer.TickTime & " seconds."
'   End If
'
'End Sub


' This function substitutes the standard MsgBox function and is largely compatible.
Public Function MsgBox(ByVal sPrompt As String, _
                       Optional ByVal eButtons As VbMsgBoxStyle, _
                       Optional sMessageTitle As String, _
                       Optional eShowMode As FormShowConstants = vbModal, _
                       Optional bShowCheckBox As Boolean, _
                       Optional sCheckBoxCaption As String, _
                       Optional sButtonCaption01 As String, _
                       Optional sButtonCaption02 As String, _
                       Optional sButtonCaption03 As String, _
                       Optional ByRef bCheckBoxValue As Boolean, _
                       Optional bShowDontShowAgain As Boolean = True, _
                       Optional ByRef bDontShowAgainValue As Boolean _
                       ) As VbMsgBoxResult

#If Mac = 1 Then
   VBA.MsgBox sPrompt, eButtons, sMessageTitle
#Else

' <JAS 17/12-2012 Generic "Don't show this message again" switch implemented. >
' Messages are identified by their title and results are stored in UserSettings.XML
   Dim sResult As String
   If bShowDontShowAgain And Len(sMessageTitle) <> 0 Then
      sResult = "" 'mSettings.GetMostSpecificSetting("Messages", VBA.Replace(sMessageTitle, " ", ":"))
      If IsNumeric(sResult) Then
         MsgBox = CLng(sResult)
         Exit Function
      End If
   End If
' </JAS>

   With ufMessage
      .MsgBoxText = sPrompt
      .MsgBoxTitle = sMessageTitle
      '
      ' Must read from eButtons BEFORE we apply our private Extra's
      .IsInputBox = False
      .SetStylesFromMsgBox eButtons
      '
      ' New button captions, if provided.
      If LenB(sButtonCaption01) <> 0 Then
         .cmdAction01.Caption = sButtonCaption01
      End If
      If LenB(sButtonCaption02) <> 0 Then
         .cmdAction02.Caption = sButtonCaption02
      End If
      If LenB(sButtonCaption03) <> 0 Then
         .cmdClose.Caption = sButtonCaption03

' <JAS 09/08-2013: Revision 131>
         '
         ' When used as a non-modal status MsgBox "cmdClose"
         ' is hacked to be disabled. Then, if a modal MsgBox is displayed
         ' inside the lifetime of the non-modal MsgBox the button is
         ' disabled - which it should not be.
         If Not .cmdClose.Enabled Then .cmdClose.Enabled = True
' </JAS 09/08-2013>

      End If
      '
      .chkOption.Visible = bShowCheckBox
      If LenB(sCheckBoxCaption) <> 0 Then
         .chkOption.Caption = sCheckBoxCaption
      End If
      .chkOption.Value = bCheckBoxValue

      .chkDontShowAgain.Visible = (bShowDontShowAgain And Len(sMessageTitle) <> 0)

      .KeepLoaded = True
      .ShowMode = eShowMode
      If .Visible Then .Hide
      .Show eShowMode
      If eShowMode = vbModal Then .KeepLoaded = False

   End With

   MsgBox = ufMessage.MsgBoxResult

' <JAS 23/11-2012 Disabled and bCheckBoxValue return parameter added >
' <JAS 17/12-2012 Generic "Don't show this message again" switch implemented. >
  ' If bShowCheckBox Then
  '    ufMessage.Hide
  ' Else
      bCheckBoxValue = ufMessage.chkOption.Value
      bDontShowAgainValue = ufMessage.chkDontShowAgain.Value

      If bDontShowAgainValue And ufMessage.MsgBoxResult <> vbCancel And ufMessage.MsgBoxResult <> vbNo And Len(sMessageTitle) <> 0 Then
         'mSettings.SetXMLSetting extcLocalUser, "Messages", VBA.Replace(sMessageTitle, " ", ":"), CStr(ufMessage.MsgBoxResult), True
      End If

      Unload ufMessage
  ' End If
' </JAS>

#End If
End Function

'
' This function substitutes the standard InputBox function and is largely compatible.
'Public Function InputBox(ByVal sPrompt As String, _
'                         Optional sMessageTitle As String, _
'                         Optional sDefaultText As String, _
'                         Optional bShowCheckBox As Boolean, _
'                         Optional sCheckBoxCaption As String, _
'                         Optional sButtonCaption01 As String, _
'                         Optional sButtonCaption02 As String) As String
'#If Mac = 1 Then
'   InputBox = VBA.InputBox(sPrompt, sMessageTitle, sDefaultText)
'#Else
'
'   With ufMessage
'      .MsgBoxText = sDefaultText
'      .MsgBoxTitle = sPrompt
'      '
'      ' Must read from eButtons BEFORE we apply our private Extra's
'      .SetStylesFromMsgBox vbOKCancel
'      '
'      ' Must set this flag BEFORE potentially overriding button captions
'      .IsInputBox = True
'      '
'      ' New button captions, if provided.
'      If LenB(sButtonCaption01) <> 0 Then
'         '.cmdAction02.Caption = sButtonCaption01
'         Call SetCaptionAndAccelerator(.cmdAction02, sButtonCaption01)
'      End If
'      If LenB(sButtonCaption02) <> 0 Then
'         '.cmdClose.Caption = sButtonCaption02
'         Call SetCaptionAndAccelerator(.cmdClose, sButtonCaption02)
'      End If
'      '
'      .chkOption.Visible = bShowCheckBox
'      If LenB(sCheckBoxCaption) <> 0 Then
'         '.chkOption.Caption = sCheckBoxCaption
'         Call SetCaptionAndAccelerator(.chkOption, sCheckBoxCaption)
'      End If
'
'      .KeepLoaded = True
'      .Show vbModal
'      .KeepLoaded = False
'
'   End With
'
'   If ufMessage.MsgBoxResult = vbOK Then
'      InputBox = ufMessage.MsgBoxText
'   Else
'      '
'      ' 10/4-2012 Conceptually wrong to return sDefaultText when the user selects Cancel.
'      ' Instead we must return an empty string when the Cancel button is pressed. /JAS
'      InputBox = ""  ' sDefaultText
'   End If
'
'   Unload ufMessage
'#End If
'End Function

Public Sub LockWord(ByRef oDocument As Document)

' Exit Sub

#If Not Mac = 1 Then
   
   Dim lRet As Long
   Dim sDocName As String
   '
   ' If Word displays a document i compatibility mode we need to know the
   ' full window caption including the appended localized wording of
   ' "[Compatibility Mode]"
  ' oDocument.ActiveWindow.Visible = False
      
   sDocName = oDocument.ActiveWindow.Caption
   '
   ' Argh ... if a document hasn't yet been shown its ActiveWindow
   ' may not yet have a caption.
   If LenB(sDocName) = 0 Then
      sDocName = oDocument.Name
   End If
   '
   ' In Office 2013 the caption differ from that in 2010 and 2007
   If pGetVersion(Application.Version) > 14 Then
      sDocName = sDocName & " - Word"
   Else
      sDocName = sDocName & " - Microsoft Word"
   End If

   ' If Word is running this API call returns its handle.
   p_hWndWordDoc = FindWindowW(StrPtr("OpusApp"), StrPtr(sDocName))
   '
   ' Application.ScreenUpdating = False seem only to lock the top-level
   ' document window represented by p_hWndWordDoc. This is NOT enough to
   ' gain proper speed. We need to prevent the edit area of the document
   ' window from updating as well.
   Application.ScreenUpdating = False
   '
   ' The edit area is quite well hidden and is found in the stack order
   ' OPUSAPP -> _WwF -> _WwB -> _WwG, which we find this way
   If p_hWndWordDoc <> 0 Then
      p_hWndEditArea = FindWindowExW(p_hWndWordDoc, ByVal 0, StrPtr("_WwF"), ByVal 0)
      p_hWndEditArea = FindWindowExW(p_hWndEditArea, ByVal 0, StrPtr("_WwB"), ByVal 0)
      p_hWndEditArea = FindWindowExW(p_hWndEditArea, ByVal 0, StrPtr("_WwG"), ByVal 0)
      '
      ' If the handle is valid we ask Windows NOT to send WM_PAINT messages
      ' anymore. We MUST set WM_SETREDRAW to True when we finish !!!
      If p_hWndEditArea <> 0 Then
         lRet = SendMessageW(p_hWndEditArea, WM_SETREDRAW, ByVal 0&, ByVal 0&)
         lRet = LockWindowUpdate(p_hWndEditArea)
         DebugMsg "Handle " & CStr(p_hWndEditArea) & " locked with code " & CStr(lRet)
         ' lRet = 0 betyder fejl.
      End If
   End If
   
   
#End If
End Sub
  
Public Sub UnlockWord(ByRef oDocument As Document)

' Exit Sub

#If Not Mac = 1 Then
      
   Dim lRet As Long
   lRet = LockWindowUpdate(0)
   oDocument.ActiveWindow.Visible = True
   
   Dim sDocName As String
   '
   ' If Word displays a document i compatibility mode we need to know the
   ' full window caption including the appended localized wording of
   ' "[Compatibility Mode]"
   '
   ' We already *should* have a valid handle - saved by a call to LockWord()
   If p_hWndWordDoc = 0 Then
      sDocName = oDocument.ActiveWindow.Caption
      If LenB(sDocName) = 0 Then
         sDocName = oDocument.Name
      End If
      sDocName = sDocName & " - Microsoft Word"
      '
      ' Get a handle to the document window
      p_hWndWordDoc = FindWindowW(StrPtr("OPUSAPP"), StrPtr(sDocName))
      If p_hWndWordDoc <> 0 Then
         p_hWndEditArea = FindWindowExW(p_hWndWordDoc, ByVal 0, StrPtr("_WwF"), ByVal 0)
         p_hWndEditArea = FindWindowExW(p_hWndEditArea, ByVal 0, StrPtr("_WwB"), ByVal 0)
         p_hWndEditArea = FindWindowExW(p_hWndEditArea, ByVal 0, StrPtr("_WwG"), ByVal 0)
      End If
   End If
   '
   ' If the handle is valid we ask Windows to send WM_PAINT messages
   ' again. Hence, we MUST set WM_SETREDRAW to True !!!
   If p_hWndWordDoc <> 0 And p_hWndEditArea <> 0 Then
      lRet = SendMessageW(p_hWndEditArea, WM_SETREDRAW, ByVal 1&, ByVal 0&)
      '
      ' SetWindowPos shouldn't be necessary. Can be enabled if problems with
      ' screen redraw occur.
     ' lRet = mDialogFunctions.SetWindowPos(p_hWndWordDoc, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW Or SWP_NOMOVE Or SWP_NOSIZE)
   End If
   '
   ' Clean up - prepare for next call
   p_hWndWordDoc = 0
   p_hWndEditArea = 0

   Application.ScreenUpdating = True

#End If
End Sub

'Public Function DisplayWelcomeMessage() As Long
'
'   ' Error Handling mangler
'
'   Dim sTemp As String
'   '
'   ' By default we show a Welcome Message
'   Dim bShowWelcomeMessage As Boolean
'   bShowWelcomeMessage = True
'   sTemp = GetMostSpecificSetting("\General", "ShowWelcomeMessage")
'   If LenB(sTemp) <> 0 Then
'      If LCase$(Trim$(sTemp)) = False Then
'         bShowWelcomeMessage = False
'      End If
'   End If
'
'   If bShowWelcomeMessage Then
'      '
'      ' Skal delegeres til GetLanguageStringEx ...
'      MsgBox "Denne tekstbox er |fffd|bnet ved start af Word.", _
'             vbInformation Or vbOKOnly, _
'             "Velkommen til WordEngine", _
'             vbModal, False
'
'   End If
'
'End Function

'Public Function GetAcceleratorKey(ByRef sFrom As String, Optional ByVal sIdentifier As String = "&") As String
'
'   Dim sTemp As String
'   Dim lPos As Long
'
'   lPos = InStr(1, sFrom, sIdentifier, vbTextCompare)
'   If lPos <> 0 Then
'      If lPos < Len(sFrom) Then
'         GetAcceleratorKey = Mid$(sFrom, lPos + 1, 1)
'      Else
'         GetAcceleratorKey = Left(sFrom, 1)
'      End If
'      '
'      ' Remove only the first occurrence !!!
'      sFrom = VBA.Replace(sFrom, sIdentifier, "", 1, 1, vbTextCompare)
'   Else
'      GetAcceleratorKey = Left(sFrom, 1)
'   End If
'
'End Function

'
' Returns 0 upon success and <> 0 upon error
'Public Function SetCaptionAndAccelerator(oControl As control, ByVal sFrom As String) As Long
'
'   On Error Resume Next
'
'   oControl.Accelerator = GetAcceleratorKey(sFrom, "&")
'   oControl.Caption = sFrom
'
'   SetCaptionAndAccelerator = Err.Number
'
'End Function
'
'Sub ShowLabelsDialog()
'   ShowDialog "ufLabels", vbModal
'End Sub
'
'Sub ShowDateDialog()
'   ShowDialog "ufDate", vbModal
'End Sub
'
'Public Function AddIconWhenSuitable(ByRef oHostFrame As MSForms.Frame, ByRef oImageControl As MSForms.image) As Boolean
'
'   If oHostFrame Is Nothing Then
'      Err.Raise 9, MODULE_NAME & "::AddIconWhenSuitable", "The Host Frame must be initialized before calling this function."
'      Exit Function
'   End If
'
'   Dim oIconLoader As cIconLoaderEx
'   Dim bShowCustomerIcons As Boolean
'   Dim sTemp As String
'   Dim sLogoIcon As String
'   '
'   ' Assume default behavior
'   bShowCustomerIcons = True
'   sTemp = GetMostSpecificSetting("\General", "ShowAvatarIcons")
'   If LenB(sTemp) <> 0 Then
'      If LCase$(Trim$(sTemp)) = False Then
'         bShowCustomerIcons = False
'      End If
'   End If
'
'   If bShowCustomerIcons Then
'      '
'      ' Here we assume assume failure
'      Set oImageControl = oHostFrame.Add("Forms.Image.1", "imgCustomerIcon")
'      oImageControl.Visible = False
'      '
'      ' Apply the Icon
'      sLogoIcon = GetMostSpecificSetting("\General", "CustomerIcon")
'      If LenB(sLogoIcon) <> 0 Then
'         sLogoIcon = CombinePaths(GetWordEngineFolder(ewefWEGraphics), sLogoIcon)
'
'         If FileExists(sLogoIcon) Then
'            Set oIconLoader = New cIconLoaderEx
'            '
'            ' Since AutoSize is On  and the image is right-aligned we must remember
'            ' to adjust position in pResize()
'            With oImageControl
'               .BorderStyle = fmBorderStyleNone
'               .AutoSize = True
'               .Visible = True
'               .PictureAlignment = fmPictureAlignmentTopRight
'            End With
'
'            If LCase$(GetFileExtension(sLogoIcon)) = "ico" Then
'               '
'               ' When the file is in ICO format this MUST be provided as a max 128x128 pixels
'               ' 32-bit ICO-file with ONLY one icon entry.
'               If oIconLoader.LoadIconFile(sLogoIcon) Then
'                  oImageControl.Picture = oIconLoader.GetIconByIndex(0, oImageControl.BackColor)
'               End If
'            Else
'               '
'               ' When the file is in another format (PNG with Alpha channel preferred) size
'               ' is NOT limited to 128 pixels.
'               oImageControl.Picture = oIconLoader.LoadIconFromFile(sLogoIcon)
'            End If
'            oImageControl.AutoSize = False
'            Set oIconLoader = Nothing
'            '
'            ' Report success
'            AddIconWhenSuitable = True
'         Else
'            DebugMsg MODULE_NAME & "::AddIconWhenSuitable: Requested icon file """ & sLogoIcon & """ not found.", dbgLogWarning
'            Set oImageControl = Nothing
'         End If ' FileExists(sLogoIcon)
'      Else
'         Set oImageControl = Nothing
'      End If ' LenB(sLogoIcon) <> 0
'   Else
'      Set oImageControl = Nothing
'   End If ' bShowCustomerIcons
'
'End Function

'Public Sub LongToRGB(ByVal lColor As Long, ByRef tRgbType As RGBTRIPLE)
'   On Error Resume Next
'   '
'   ' Split a color value represented as a Long variable into RGB parts
'   tRgbType.Red = (lColor Mod 256)
'   tRgbType.Green = ((lColor And &HFF00) / 256) Mod 256
'   tRgbType.Blue = ((lColor And &HFF0000) / 65536)
'End Sub
'
'Public Function TranslateColor(ByVal oClr As OLE_COLOR, Optional hPal As Long = 0) As Long
'#If Not Mac = 1 Then
'   If OleTranslateColor(oClr, hPal, TranslateColor) Then
'      TranslateColor = CLR_INVALID
'   End If
'#Else
'   TranslateColor = CLng(oClr)
'#End If
'End Function
'
Private Function pGetVersion(ByVal sVersion As String) As Long
'
' Omregner Major-delen af en versionsnummer-streng
' til en long variabel.

    Dim lPos As Long
    '
    ' S|fffd|t indledningsvis returv|fffd|rdien til laveste
    ' versionsnummer vi supporterer i vores kode.
    pGetVersion = 10
    '
    ' Beregn derefter det faktisk versionsnummer
    ' og return|fffd|r dette
    If IsNumeric(sVersion) Then
        lPos = InStr(1, sVersion, ".")
        If lPos > 0 And lPos < Len(sVersion) Then
            pGetVersion = CLng(Mid$(sVersion, 1, lPos - 1))
        End If
    End If

End Function
Attribute VB_Name = "mEnumResolverFunctions"
Option Explicit
Option Compare Text  ' Important /JAS
'
' Purpose      :  Implements functions to convert trings to enums and vice versa.
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  07. july 2015
'
' Remarks      :  To avoid case sensivity this module use "Option Compare Text"
'                 as default string compare option.
'
Private Const MODULE_NAME = "mEnumResolverFunctions"
'

Public Function StoryTypeEnumToString(ByRef eStoryType As WdStoryType) As String
'GetRangeFromStoryType(eStoryType)
   Select Case eStoryType
      
      Case wdCommentsStory ' 4
         StoryTypeEnumToString = "Comments story"
      
      Case wdEndnoteContinuationNoticeStory ' 17
         StoryTypeEnumToString = "Endnote continuation notice story"
      
      Case wdEndnoteContinuationSeparatorStory ' 16
         StoryTypeEnumToString = "Endnote continuation separator story"
      
      Case wdEndnoteSeparatorStory ' 15
         StoryTypeEnumToString = "Endnote separator story"
      
      Case wdEndnotesStory  ' 3
         StoryTypeEnumToString = "Endnotes story"
      
      Case wdEvenPagesFooterStory ' 8
         StoryTypeEnumToString = "Even pages footer story"
      
      Case wdEvenPagesHeaderStory ' 6
         StoryTypeEnumToString = "Even pages header story"
      
      Case wdFirstPageFooterStory ' 11
         StoryTypeEnumToString = "First page footer story"
      
      Case wdFirstPageHeaderStory ' 10
         StoryTypeEnumToString = "First page header story"
      
      Case wdFootnoteContinuationNoticeStory ' 14
         StoryTypeEnumToString = "Footnote continuation notice story"
      
      Case wdFootnoteContinuationSeparatorStory ' 13
         StoryTypeEnumToString = "Footnote continuation separator story"
      
      Case wdFootnoteSeparatorStory ' 12
         StoryTypeEnumToString = "Footnote separator story"
      
      Case wdFootnotesStory ' 2
         StoryTypeEnumToString = "Footnotes story"
      
      Case wdMainTextStory ' 1
         StoryTypeEnumToString = "Main text story"
      
      Case wdPrimaryFooterStory ' 9
         StoryTypeEnumToString = "Primary footer story"
      
      Case wdPrimaryHeaderStory ' 7
         StoryTypeEnumToString = "Primary header story"
      
      Case wdTextFrameStory ' 5
         StoryTypeEnumToString = "Text frame story"
      
      Case Else
         StoryTypeEnumToString = "Unknown"
   
   End Select
   
End Function

Public Function ShapeTypeEnumToString(ByVal eShapeType As MsoShapeType) As String

   Select Case eShapeType
      
      Case msoAutoShape ' 1
         ShapeTypeEnumToString = "AutoShape"
      
      Case msoCallout ' 2
         ShapeTypeEnumToString = "Callout"
      
      Case msoCanvas ' 20
         ShapeTypeEnumToString = "Canvas"
      
      Case msoChart ' 3
         ShapeTypeEnumToString = "Chart"
      
      Case msoComment ' 4
         ShapeTypeEnumToString = "Comment"
      
      Case msoDiagram ' 21
         ShapeTypeEnumToString = "Diagram"
      
      Case msoEmbeddedOLEObject ' 7
         ShapeTypeEnumToString = "Embedded OLE object"
      
      Case msoFormControl ' 8
         ShapeTypeEnumToString = "Form control"
      
      Case msoFreeform ' 5
         ShapeTypeEnumToString = "Freeform"
      
      Case msoGroup ' 6
         ShapeTypeEnumToString = "Group"
      
      Case msoSmartArt ' 24
         ShapeTypeEnumToString = "SmartArt graphic"
      
      Case msoInk ' 22
         ShapeTypeEnumToString = "Ink"
      
      Case msoInkComment ' 23
         ShapeTypeEnumToString = "Ink comment"
      
      Case msoLine ' 9
         ShapeTypeEnumToString = "Line"
      
      Case msoLinkedOLEObject ' 10
         ShapeTypeEnumToString = "Linked OLE object"
      
      Case msoLinkedPicture ' 11
         ShapeTypeEnumToString = "Linked picture"
      
      Case msoMedia ' 16
         ShapeTypeEnumToString = "Media"
      
      Case msoOLEControlObject ' 12
         ShapeTypeEnumToString = "OLE control object"
      
      Case msoPicture ' 13
         ShapeTypeEnumToString = "Picture"
      
      Case msoPlaceholder ' 14
         ShapeTypeEnumToString = "Placeholder"
      
#If Not Mac = 1 Then
      Case msoScriptAnchor ' 18
         ShapeTypeEnumToString = "Script anchor"
#End If
         
      Case msoShapeTypeMixed ' -2
         ShapeTypeEnumToString = "Mixed shape type"
      
      Case msoTable ' 19
         ShapeTypeEnumToString = "Table"
      
      Case msoTextBox ' 17
         ShapeTypeEnumToString = "Text box"
      
      Case msoTextEffect ' 15
         ShapeTypeEnumToString = "Text effect"
      '
      ' Only available in 2013
'      Case msoWebVideo
'         ShapeTypeEnumToString = "Web Video"
      
      Case Else
         ShapeTypeEnumToString = "Unknown"
   
   End Select

End Function

Public Function GetRangeFromStoryType(ByRef oDocument As Document, ByRef eStoryType As WdStoryType, Optional ByVal lSection As Long = 1) As Range

   If oDocument Is Nothing Then Set oDocument = GetActiveDocument

   Select Case eStoryType
      
      Case wdCommentsStory ' 4
        ' Set GetRangeFromStoryType = "Comments story"
      
      Case wdEndnoteContinuationNoticeStory ' 17
        ' Set GetRangeFromStoryType = "Endnote continuation notice story"
      
      Case wdEndnoteContinuationSeparatorStory ' 16
        ' Set GetRangeFromStoryType = "Endnote continuation separator story"
      
      Case wdEndnoteSeparatorStory ' 15
        ' Set GetRangeFromStoryType = "Endnote separator story"
      
      Case wdEndnotesStory  ' 3
        ' Set GetRangeFromStoryType = "Endnotes story"
      
      Case wdEvenPagesFooterStory ' 8
         Set GetRangeFromStoryType = oDocument.Sections(lSection).Footers(wdHeaderFooterEvenPages).Range
      
      Case wdEvenPagesHeaderStory ' 6
         Set GetRangeFromStoryType = oDocument.Sections(lSection).Headers(wdHeaderFooterEvenPages).Range
      
      Case wdFirstPageFooterStory ' 11
         Set GetRangeFromStoryType = oDocument.Sections(lSection).Footers(wdHeaderFooterFirstPage).Range
      
      Case wdFirstPageHeaderStory ' 10
         Set GetRangeFromStoryType = oDocument.Sections(lSection).Headers(wdHeaderFooterFirstPage).Range
      
      Case wdFootnoteContinuationNoticeStory ' 14
        ' Set GetRangeFromStoryType = "Footnote continuation notice story"
      
      Case wdFootnoteContinuationSeparatorStory ' 13
        ' Set GetRangeFromStoryType = "Footnote continuation separator story"
      
      Case wdFootnoteSeparatorStory ' 12
        ' Set GetRangeFromStoryType = "Footnote separator story"
      
      Case wdFootnotesStory ' 2
        ' Set GetRangeFromStoryType = "Footnotes story"
      
      Case wdMainTextStory ' 1
        ' Set GetRangeFromStoryType = "Main text story"
      
      Case wdPrimaryFooterStory ' 9
         Set GetRangeFromStoryType = oDocument.Sections(lSection).Footers(wdHeaderFooterPrimary).Range
      
      Case wdPrimaryHeaderStory ' 7
         Set GetRangeFromStoryType = oDocument.Sections(lSection).Headers(wdHeaderFooterPrimary).Range
      
      Case wdTextFrameStory ' 5
        ' Set GetRangeFromStoryType = "Text frame story"
      
      Case Else
        ' Set GetRangeFromStoryType = "Unknown"
   
   End Select
   
End Function

Public Function StoryTypeNameToEnum(ByRef sStoryType As String) As WdStoryType
   
   Select Case sStoryType
      
      Case "Comments"
         StoryTypeNameToEnum = wdCommentsStory ' 4
      
      Case "EndnoteContinuationNotice"
         StoryTypeNameToEnum = wdEndnoteContinuationNoticeStory ' 17
      
      Case "EndnoteContinuationSeparator"
         StoryTypeNameToEnum = wdEndnoteContinuationSeparatorStory ' 16
      
      Case "EndnoteSeparator"
         StoryTypeNameToEnum = wdEndnoteSeparatorStory ' 15
      
      Case "Endnotes"
         StoryTypeNameToEnum = wdEndnotesStory  ' 3
      
      Case "EvenPagesFooter"
         StoryTypeNameToEnum = wdEvenPagesFooterStory ' 8
      
      Case "EvenPagesHeader"
         StoryTypeNameToEnum = wdEvenPagesHeaderStory ' 6
      
      Case "FirstPageFooter"
         StoryTypeNameToEnum = wdFirstPageFooterStory ' 11
      
      Case "FirstPageHeader"
         StoryTypeNameToEnum = wdFirstPageHeaderStory ' 10
      
      Case "FootnoteContinuationNotice"
         StoryTypeNameToEnum = wdFootnoteContinuationNoticeStory ' 14
      
      Case "FootnoteContinuationSeparator"
         StoryTypeNameToEnum = wdFootnoteContinuationSeparatorStory ' 13
      
      Case "FootnoteSeparator"
         StoryTypeNameToEnum = wdFootnoteSeparatorStory ' 12
      
      Case "Footnotes"
         StoryTypeNameToEnum = wdFootnotesStory ' 2
      
      Case "MainText"
         StoryTypeNameToEnum = wdMainTextStory ' 1
      
      Case "PrimaryFooter"
         StoryTypeNameToEnum = wdPrimaryFooterStory ' 9
      
      Case "PrimaryHeader"
         StoryTypeNameToEnum = wdPrimaryHeaderStory ' 7
      
      Case "TextFrame"
         StoryTypeNameToEnum = wdTextFrameStory ' 5
      
      Case Else
         StoryTypeNameToEnum = wdMainTextStory ' 1
         Err.Raise 13, MODULE_NAME & "::StoryTypeNameToEnum", "Can't resolve the """ & sStoryType & """ name. Assuming wdMainTextStory."
   
   End Select
   
End Function
Attribute VB_Name = "mErrorHandler"
Option Explicit
'
' Purpose      :  Provides useful error handling and debugging functions.
'
' Dependencies :  mErrorHandler.bas
'                 cDebugLog.cls
'                 cErrorHandler.cls
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  13. april 2010
' Modified     :  01. november 2010 /NRV  1) Function DisplayErrorForm() added
'                 14. december 2010 /JAS  1) "New" keyword removed from global Debug and Error objects
'                 23. August 2011 /JAS    1) 32/64-bit 2010 support implemented.
'
' TODO         :  1) NeedToHave: The FormatMessage() declaration should be changed to fully support Unicode.
'                    Currently "lpBuffer" is passed ByVal As String, which forces implicit ANSI conversion.
'                    Will be fixed by JAS when time permits.
'                 2) NiceToHave: The ReportError() function may need an overhawl depending on policy
'                    regarding error propagation through nested class objects.
'
Private Const MODULE_NAME As String = "mErrorHandler"
'
' API for decoding Err.LastDLLError numbers into text
Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
#If VBA7 Then
   Private Declare PtrSafe Function FormatMessageW Lib "kernel32" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As LongPtr) As Long
#Else
   Private Declare Function FormatMessageW Lib "kernel32" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As Long) As Long
#End If
'
' Global objects.
Public goDebugObj As cDebugLog
Public goErrorObj As cErrorHandler

'
' Writes a message to external debuggers.
Public Sub DebugMsg(ByVal sDbgMsg As String, Optional eDbgEvent As enDebugEventTypes = dbgLogCheckPoint)
   '
   ' Can happen in Break Mode
   If goDebugObj Is Nothing Then
      Set goDebugObj = New cDebugLog
   End If
   
   goDebugObj.DebugMessage sDbgMsg, eDbgEvent, True
   
End Sub

Public Sub ReportError(ByVal Number As Long, ByVal Source As String, ByVal Description As String)

   If goErrorObj Is Nothing Then
      Err.Raise Number, Source, Description
   Else
      goErrorObj.RaiseError Number, Source, Description
   End If
   
  ' Err.Clear

End Sub

'
' Returns the message from the system which describes the last dll error to occur, as
' held in Err.LastDllError. Should be called as soon after the API call which might
' have errored as possible, since this member can be reset to zero by any subsequent
' API calls.
Public Function LastSystemError(Optional ByVal lErrorNumber As Long = -1) As String
   '
   ' Preinitilise a string buffer to put any error message into
   Dim sError As String * 500
   Dim lErrNum As Long
   Dim lErrMsg As Long
   '
   ' Get the error number
   If lErrorNumber = -1 Then
      lErrNum = Err.LastDllError
   Else
      lErrNum = lErrorNumber
   End If
   '
   ' Get the error description from the system (i.e. the descriptive string)
   lErrMsg = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, ByVal 0&, lErrNum, 0, sError, Len(sError), 0)
   
   If lErrMsg Then
      sError = Left$(StrConv(sError, vbFromUnicode), lErrMsg - 2) ' Remove Cr/Lf
   Else
      sError = "Error (" & CStr(lErrNum) & ") not defined."
   End If
   '
   ' Return the string
   LastSystemError = Trim$(sError)
   
End Function

Public Function GetSystemError(ByVal lDllErrNum As Long) As String
   '
   ' Preinitilise a string buffer to put any error message into
   Dim sError As String * 500
   Dim lErrMsg As Long
   '
   ' Get the error description from the system (i.e. the descriptive string)
   lErrMsg = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, ByVal 0&, lDllErrNum, 0, sError, Len(sError), 0)
   
   If lErrMsg Then
      sError = Left$(sError, lErrMsg - 2) ' Remove Cr/Lf
   Else
      sError = "Error (" & CStr(lDllErrNum) & ") not defined."
   End If
   '
   ' Return the string
   GetSystemError = Trim$(sError)

End Function

Attribute VB_Name = "mExcelConnection"
Public oExcel As Excel.Application
Public oWorkbook As Excel.Workbook
Public oWorkSheet As Excel.Worksheet

Private bCloseExcelApp As Boolean
Private bCloseExcelWorkbook As Boolean

Private sExcelPath As String
Private sExcelSheet As String


Public Function ReturnExcelPath(Optional sDefaultPath As String) As String
   Dim sFileName As String
   Dim sFileTitle As String
   Dim sInitialDir As String
   Dim sDialogTitle As String
   Dim sDefaultExtension As String
   Dim sFilter As String
   Dim lFilterIndex As Long
   Dim sExcelFolder As String
   ' Specify a reasonable set of file filters (Windows only)
   sFilter = "|*.xlsx;*.xlsm;*.xls;*.xlt;*.xltm|"
   '
   ' Select the first filter
   lFilterIndex = 1
   '
   ' Preselect a path to open
   sExcelFolder = System.PrivateProfileString(Application.Options.DefaultFilePath(wdUserTemplatesPath) & "\user.ini", "LastImageFolder", "Folder")

    If FileExists(sExcelFolder) Then
        sInitialDir = sExcelFolder
    Else
        sInitialDir = "C:\"
    End If

   '
   ' If not found then default to something meaningful
'   If Not mCore_FileOperationsW.FolderExists(sInitialDir) Then
'      sInitialDir = mSettings.GetWordEngineFolder(ewefWEFolder)
'   End If
   '
   ' Give the dialog a reasonble title
   sDialogTitle = "Select picture ..."
   sDefaultExtension = "xlsx"
   '
   ' Open the dialog. Note that sFileName and sFileTitle are output parameters.
   If mCore_FileOperationsW.ShowFileOpenDialog(sFileName, sFileTitle, True, False, False, True, sFilter, lFilterIndex, sInitialDir, sDialogTitle, sDefaultExtension) Then
      '
      ' sFileTitle is vbNullString if sFileName returns a "|" separated array,
      ' but since MultiSelect is Off sFileTitle will always represent the
      ' file name without path specification. sFileName does specify the full
      ' file name including the path.
      If Len(sFileTitle) <> 0 Then
         'Clean up the file name on MAC
         sFileName = Replace(sFileName, "alias ", "")
         '
         ' ... so, this a single file name
         ReturnExcelPath = sFileName
         '
         ' Save the path to our UserSettings.xml file.
         System.PrivateProfileString(Application.Options.DefaultFilePath(wdUserTemplatesPath) & "\user.ini", "LastImageFolder", "Folder") = ReturnFolderName(sFileName)
      Else
         '
         ' Should never happen here
      End If
      
   Else
     '
     ' The user pressed cancel or an error occurred.
   End If
End Function
Function ReturnFolderName(strVal As String) As String
    Dim iPos As Integer
    iPos = InStrRev(strVal, "\")
    If iPos <> 0 Then
        ReturnFolderName = Left(strVal, iPos - 1)
    End If

End Function
Function ReturnFileName(strVal As String) As String
    Dim iPos As Integer
    iPos = InStrRev(strVal, "\")
    If iPos <> 0 Then
        ReturnFileName = Mid(strVal, iPos + 1)
    End If

End Function

Public Property Get CloseExcelOnTerminate() As Boolean
   CloseExcelOnTerminate = bCloseExcelApp
End Property
Public Property Let CloseExcelOnTerminate(bVal As Boolean)
   bCloseExcelApp = bVal
End Property

Public Property Get CloseWorkbookOnTerminate() As Boolean
   CloseExcelOnTerminate = bCloseExcelWorkbook
End Property
Public Property Let CloseWorkbookOnTerminate(bVal As Boolean)
   bCloseExcelWorkbook = bVal
End Property
Public Property Let ExcelPath(sVal As String)
    sExcelPath = sVal
End Property
Public Property Get ExcelPath() As String
    ExcelPath = sExcelPath
End Property
Public Property Let ExcelSheet(sVal As String)
    sExcelSheet = sVal
End Property
Public Property Get ExcelSheet() As String
    ExcelSheet = sExcelSheet
End Property
Function ConnectToExcel() As Long
   
   On Error GoTo NoExcelConnectionError
   Set oExcel = GetObject(, "Excel.Application")
   If oExcel.Application Is Nothing Then
       Set oExcel = CreateObject("Excel.Application")
       oExcel.Visible = False
       bCloseExcelApp = True
   End If
   
   On Error GoTo WorkbookConnectionError
   If LenB(ExcelPath) > 0 Then
      If IsWorkbookOpened(ExcelPath) Then
         Set oWorkbook = oExcel.Workbooks(ReturnFileName(ExcelPath))
      Else
         Set oWorkbook = oExcel.Workbooks.Open(ExcelPath, True)
         bCloseExcelWorkbook = True
      End If
   End If
   
   On Error GoTo WorksheetConnectionError
   If LenB(ExcelSheet) > 0 Then
      
      'Set oWorksheet = oWorkbook.Worksheets(ExcelSheet)
   End If
      
   Exit Function
NoExcelConnectionError:
  ' MsgBox "Could not connect to Excel."
   Resume Next
WorkbookConnectionError:
   'MsgBox "Could not connect to the specified workbook."
   ConnectToExcel = -1
   'Resume Next
   Exit Function
WorksheetConnectionError:
   ConnectToExcel = -2
   'Resume Next
   'MsgBox "Could not connect to the specified woorksheet."
   Exit Function
End Function

Function IsWorkbookOpened(sPath As String) As Boolean
   Dim curWorkbook As Workbook
   For Each curWorkbook In oExcel.Workbooks
      'Debug.Print LCase(curWorkbook.FullName)
      If LCase(curWorkbook.FullName) = LCase(sPath) Then
         IsWorkbookOpened = True
         Exit Function
      End If
   Next

End Function

Sub CloseExcelObjects()
   On Error GoTo BailOut
   If bCloseExcelWorkbook Then
      oWorkbook.Close False
   End If
   If bCloseExcelApp Then
      oExcel.Quit
      Exit Sub
   End If
   
BailOut:
   
End Sub

Function TestExcelConnection() As Integer

On Error Resume Next

   Dim oExcel As Object
   Set oExcel = GetObject(, "Excel.Application")
   
   If Not oExcel Is Nothing Then
      If oExcel.Workbooks.Count < 2 Then
         TestExcelConnection = 0
      Else
         TestExcelConnection = -2
      End If
   Else
      TestExcelConnection = -1
   End If

ExitHere:
   Exit Function

ErrHandler:
   Resume Next

End Function
Attribute VB_Name = "mFunctions"
Option Explicit

Public oDocument As Document
Public oForm As ChartForm

Public Const LONG_BOOKMARK_LENGTH = 15
Public Const LONG_BOOKMARK_LENGTH_INDEXED = 18
Public Const SHORT_BOOKMARK_LENGTH = 11
Public Const SHORT_BOOKMARK_LENGTH_INDEXED = 14

Private colChartTypes As Collection
Private colTableTypes As Collection

Private lChartRangeNumber As Long
Private lChartTypeNumber As Long

Private lTableRangeNumber As Long
Private lTableTypeNumber As Long

Private colChartList As cPropertyBag
Private colRawBookmarkList As cPropertyBag
Private colCheckBoxControls As Collection
Private colChartControls As Collection
Private colSelectedWorksheets As cPropertyBag
Private colExcelCharts As cPropertyBag

Private colTableList As cPropertyBag
Private colTableControls As Collection
Private colExcelTables As cPropertyBag

Private bUpdateState As Boolean

Private arChartTypes() As String
Private arrTableTypes() As String

Public Const UImagnificationConstant = 1.5
Private Const MODULE_NAME = "mFunctions"

Sub InsertTextFromXLCells()
   '
   Dim oExcel As Excel.Application
   Dim oWb As Excel.Workbook
   Dim oActiveSheet As Excel.Worksheet
   Dim oXLRange  As Excel.Range
   Dim oCell As Excel.Range
   Dim sCellStyle As String
   Dim oTextRange As Range
   
   Set oExcel = GetObject(, "Excel.Application")
   Set oWb = oExcel.ActiveWorkbook
   Set oActiveSheet = oWb.ActiveSheet
   Set oXLRange = oExcel.Selection
   
   For Each oCell In oXLRange.Cells
      sCellStyle = oCell.Style.Name
      
      If Not StyleExists(sCellStyle) Then
         sCellStyle = "Normal"
      End If
      
      Set oTextRange = Selection.Range
      oTextRange = oCell.Text
      With oTextRange
         .Style = sCellStyle
         .InsertParagraphAfter
         .Collapse wdCollapseEnd
         .Select
      End With
      
   Next

End Sub


Function StyleExists(StyleName As String) As Boolean
    Dim MyStyle As Word.Style
    On Error Resume Next
     ' maybe this ...
    Set MyStyle = ActiveDocument.Styles(StyleName)
     ' or maybe this ...
     ' Set MyStyle = ActiveDocument.AttachedTemplate.Styles(StyleName)
    StyleExists = Not MyStyle Is Nothing
End Function

'Sub CloseExcel()
'   On Error GoTo BailOut
'   oWorkbook.Close False
'BailOut:
'End Sub
Public Sub InitializeComponents()
   Set colTableTypes = New Collection
   Set colRawBookmarkList = New cPropertyBag
   Set colTableList = New cPropertyBag
   Set colCheckBoxControls = New Collection
   Set colTableControls = New Collection
   
   Set oDocument = ActiveDocument
   On Error GoTo BailOut
   UpdateState = CBool(GetDocumentProperty("SD_TableUpdate", eplcDocPropCustom, oDocument))
   Exit Sub
BailOut:
   UpdateState = False
End Sub

Public Function GetDataFromDocument() As Collection
   Dim sTableTypes As String
   Dim i As Long
   sTableTypes = GetDocumentProperty("SD_TableTypes", eplcDocPropCustom, oDocument)
   
   arrTableTypes = Split(sTableTypes, ";")
   For i = 0 To UBound(arrTableTypes)
      colTableTypes.Add arrTableTypes(i)
   Next
   TableTypeNumber = colTableTypes.Count
   
'  Keep that order
'   FillBookmarkList
   FillTableTitleList
   FillChartList
   
   TableRangeNumber = colTableList.Count
End Function

Public Property Get TableRangeNumber() As Long
   TableRangeNumber = lTableRangeNumber
End Property
Public Property Let TableRangeNumber(lVal As Long)
   lTableRangeNumber = lVal
End Property
Public Property Get TableTypeNumber() As Long
   TableTypeNumber = lTableTypeNumber
End Property
Public Property Let TableTypeNumber(lVal As Long)
   lTableTypeNumber = lVal
End Property
Public Property Get TableList() As cPropertyBag
   Set TableList = colTableList
End Property
Public Property Set TableList(colVal As cPropertyBag)
   Set colTableList = colVal
End Property
Public Property Get RawBookmarkList() As cPropertyBag
   Set RawBookmarkList = colRawBookmarkList
End Property
Public Property Set RawBookmarkList(colVal As cPropertyBag)
   Set colRawBookmarkList = colVal
End Property
Public Property Get ExcelTables() As cPropertyBag
   Set ExcelTables = colExcelTables
End Property
Public Property Set ExcelTables(colVal As cPropertyBag)
   Set colExcelTables = colVal
End Property
Public Property Get SelectedWorksheets() As cPropertyBag
   Set SelectedWorksheets = colSelectedWorksheets
End Property
Public Property Set SelectedWorksheets(colVal As cPropertyBag)
   Set colSelectedWorksheets = colVal
End Property

Public Property Get TableTypes() As Collection
   Set TableTypes = colTableTypes
End Property
Public Property Set TableTypes(colVal As Collection)
   Set colTableTypes = colVal
End Property
Public Property Get CheckBoxControls() As Collection
   Set CheckBoxControls = colCheckBoxControls
End Property
Public Property Set CheckBoxControls(colVal As Collection)
   Set colCheckBoxControls = colVal
End Property
Public Property Get TableControls() As Collection
   Set TableControls = colTableControls
End Property
Public Property Set TableControls(colVal As Collection)
   Set colTableControls = colVal
End Property


Public Property Get UpdateState() As Boolean
   UpdateState = bUpdateState
End Property
Public Property Let UpdateState(bVal As Boolean)
   bUpdateState = bVal
End Property


Sub FillBookmarkList()
   Dim oBookmark As Bookmark
   Set colRawBookmarkList = New cPropertyBag
   
   For Each oBookmark In ActiveDocument.Bookmarks
      If (UCase(Left(oBookmark.Name, 4)) = "CHT_") And UCase(Right(oBookmark.Name, 6)) <> "_TITLE" Then
'         If Len(oBookmark.Name) = LONG_BOOKMARK_LENGTH_INDEXED Or Len(oBookmark.Name) = SHORT_BOOKMARK_LENGTH_INDEXED Then
'            colRawBookmarkList.Add oBookmark.Name, Left(oBookmark.Name, Len(oBookmark.Name) - 3), oBookmark.Start, Mid(oBookmark.Name, 5, 4)
'         Else
            colRawBookmarkList.Add oBookmark.Name, oBookmark.Name, oBookmark.Start, Mid(oBookmark.Name, 5, 4)
'         End If
      ElseIf UCase(Left(oBookmark.Name, 4)) = "CHT_" Or UCase(Left(oBookmark.Name, 4)) = "TBL_" And UCase(Right(oBookmark.Name, 6)) = "_TITLE" Then
         colRawBookmarkList.Add oBookmark.Name, oBookmark.Range.Text, oBookmark.Start, "TITLE"
      End If
   Next
   
End Sub
Sub FillChartList()
   Dim oItem As cPropertyObject
   Dim sKey As String
   Dim sValue As String
   Dim sBookmarkName As String
   Dim sChartName As String
   
   Set colTableList = New cPropertyBag
   
   For Each oItem In colRawBookmarkList
      sBookmarkName = oItem.Key
      sChartName = oItem.Value
      If Len(sChartName) = LONG_BOOKMARK_LENGTH Or Len(sChartName) = LONG_BOOKMARK_LENGTH_INDEXED Then
         sChartName = Left(sChartName, Len(sChartName) - 4)
      End If
     
     'Debug.Print sChartName
      colTableList.Add sBookmarkName, sChartName, oItem.ItemData, oItem.ItemTag, False
   Next
   
   colTableList.Sort , vbBinaryCompare, espcSortByItemData
   'colChartList.Sort , , espcSortByItemData
   Dim i As Integer
   For i = 1 To colTableList.Count
      Set oItem = colTableList(i)
      'Debug.Print oItem.Key & vbTab & oItem.ItemData
   Next
End Sub

Sub FillTableTitleList()
   Dim oTable As Table
   Dim sTableTitle As String
   Dim lTablePos As Long
   Dim sTableHeader As String
   
   Set colRawBookmarkList = New cPropertyBag
   
   For Each oTable In oDocument.Tables
      sTableTitle = oTable.Title
      If UCase(Left(oTable.Title, 4)) = "TBL_" Then
         lTablePos = oTable.Range.Start
         sTableHeader = oTable.Cell(1, 1).Range.Text
         colRawBookmarkList.Add oTable.Title, sTableHeader, lTablePos, Mid(oTable.Title, 5, 3)
      End If
   Next
   
End Sub


Function ExistsInList(colVal As cPropertyBag, sName As String) As Boolean
   Dim oItem As cPropertyObject
   ExistsInList = False
   For Each oItem In colVal
      If oItem.Key = sName Then
         ExistsInList = True
         Exit Function
      End If
   Next
   
End Function
'Returns the Name of the Shape (the chart) if found
'Returns "" otherwise
Public Function ChartMatchWithExcel(sChartName As String) As String
   Dim oChart
   Dim sName As String
   Dim sMatchString As String
   Dim curWorksheet As Worksheet
   Dim oItem
   
   ChartMatchWithExcel = ""
   
   For Each oItem In SelectedWorksheets
      Set curWorksheet = oWorkbook.Worksheets(oItem.Key)
      For Each oChart In curWorksheet.ChartObjects
         'sName = oChart.Name
         sMatchString = oChart.Name 'oWorksheet.Shapes(sName).AlternativeText
         If InStr(LCase(Trim(sMatchString)), LCase(sChartName)) <> 0 Then
            ChartMatchWithExcel = UCase(oChart.Name)
            ExcelTables.Add UCase(oChart.Name), curWorksheet.Name, , curWorksheet.Shapes(oChart.Name).Title, False
            Exit Function
         End If
      Next
   Next
End Function
Function ExcelChartTitle(sChartName As String) As String
   
   ExcelChartTitle = ExcelTables(sChartName).ItemTag
   
End Function


Sub InsertCharts(colSelectedItems As cPropertyBag)
   Dim oItem
   Dim oChart As Excel.ChartObject
   Dim oRange As Word.Range
   Dim sChartName As String
   Dim sChartPath As String
   
   For Each oItem In colSelectedItems
      If oItem.Value <> "NUL" Then
         If Len(oItem.Key) = SHORT_BOOKMARK_LENGTH Then
            sChartName = UCase(oItem.Key) & "_" & UCase(oItem.Value)
         ElseIf Len(oItem.Key) = SHORT_BOOKMARK_LENGTH_INDEXED Then
            sChartName = UCase(Left(oItem.Key, SHORT_BOOKMARK_LENGTH)) & "_" & UCase(oItem.Value)
         Else
            sChartName = UCase(oItem.Key)
         End If
         sChartPath = ReturnChartPath(sChartName)
         Dim lSeparator As Long
         lSeparator = InStr(sChartPath, "\")
         Set oWorkSheet = oWorkbook.Worksheets(Left(sChartPath, lSeparator - 1)) 'oWorkbook.Worksheets(ExcelCharts(sChartName).Value)
         oWorkSheet.Activate
         Set oChart = ReturnExcelChartObject(oWorkSheet, Mid(sChartPath, lSeparator + 1)) 'oWorksheet.ChartObjects(sChartName)
         oChart.Select
         oExcel.Selection.Copy
      End If
      InsertClipboardContentInBookmark CStr(oItem.Key), CStr(oItem.Value)
   Next
   
   SetDocumentProperty "SD_TableUpdate", eplcDocPropCustom, "True", oDocument
   SetDocumentProperty "SD_ExcelPath", eplcDocPropCustom, ExcelPath, oDocument
   SetDocumentProperty "SD_ExcelSheet", eplcDocPropCustom, ExcelSheet, oDocument

End Sub
Function ReturnExcelChartObject(oWorkSheet As Excel.Worksheet, sChartName As String) As Excel.ChartObject
   Dim oChart As Excel.ChartObject
  
   For Each oChart In oWorkSheet.ChartObjects
      If InStr(UCase(oChart.Name), UCase(sChartName)) <> 0 Then
         Set ReturnExcelChartObject = oChart
         Exit Function
      End If
   Next
End Function

Sub InsertTables(colSelectedItems As cPropertyBag)
   Dim oItem
   Dim oChart As Excel.ChartObject
   Dim oXLName As Excel.Name
   Dim oRange As Word.Range
   Dim sChartName As String
   Dim sChartPath As String
   
   For Each oItem In colSelectedItems
      If oItem.Value <> "NUL" Then
         If Len(oItem.Key) = SHORT_BOOKMARK_LENGTH Then
            sChartName = UCase(oItem.Key) & "_" & UCase(oItem.Value)
         ElseIf Len(oItem.Key) = SHORT_BOOKMARK_LENGTH_INDEXED Then
            sChartName = UCase(Left(oItem.Key, SHORT_BOOKMARK_LENGTH)) & "_" & UCase(oItem.Value)
         Else
            sChartName = UCase(oItem.Key)
         End If
         sChartPath = ReturnChartPath(sChartName)
         Dim lSeparator As Long
         lSeparator = InStr(sChartPath, "\")
         Set oWorkSheet = oWorkbook.Worksheets(Left(sChartPath, lSeparator - 1)) 'oWorkbook.Worksheets(ExcelCharts(sChartName).Value)
         oWorkSheet.Activate
         
         Set oXLName = ReturnExcelTableObject(oWorkSheet, Mid(sChartPath, lSeparator + 1)) 'oWorksheet.ChartObjects(sChartName)
         Dim oXLRange As Excel.Range
         Set oXLRange = Excel.Range(oXLName.Name)
         
         PasteXlRegnskabsTable oXLRange
         
         
'         Set oChart = ReturnExcelChartObject(oWorksheet, Mid(sChartPath, lSeparator + 1)) 'oWorksheet.ChartObjects(sChartName)
'         oChart.Select
'         oExcel.Selection.Copy
      
      End If
      
      InsertClipboardContentInBookmark CStr(oItem.Key), CStr(oItem.Value)
   Next
   
   SetDocumentProperty "SD_ChartUpdate", eplcDocPropCustom, "True", oDocument
   SetDocumentProperty "SD_ExcelPath", eplcDocPropCustom, ExcelPath, oDocument
   SetDocumentProperty "SD_ExcelSheet", eplcDocPropCustom, ExcelSheet, oDocument

End Sub
Function ReturnExcelTableObject(oWorkSheet As Excel.Worksheet, sChartName As String) As Excel.Name
   Dim oTable As Excel.Name
  
   For Each oTable In oWorkSheet.Names
      If InStr(UCase(oTable.Name), UCase(sChartName)) <> 0 Then
         Set ReturnExcelTableObject = oTable
         Exit Function
      End If
   Next
End Function

Function ReturnChartPath(sChartName As String) As String
   Dim oChart As Excel.ChartObject
   Dim oWorkSheet As Excel.Worksheet
   
   For Each oWorkSheet In oWorkbook.Worksheets
      For Each oChart In oWorkSheet.ChartObjects
         If InStr(UCase(oChart.Name), UCase(sChartName)) <> 0 Then
            ReturnChartPath = oWorkSheet.Name & "\" & oChart.Name
            Exit Function
         End If
      Next
   Next
   
End Function
Public Sub InsertClipboardContentInBookmark(sSelectedItem As String, sType As String)
   Dim oRange As Range
   Dim oShape As Shape
   Dim sCurrentBookmarkName As String
   
   On Error GoTo BailOut
   sCurrentBookmarkName = ReturnExistingBookmark(sSelectedItem)
   If Len(sCurrentBookmarkName) = LONG_BOOKMARK_LENGTH Then
      RenameBookmark sCurrentBookmarkName, Left(sCurrentBookmarkName, SHORT_BOOKMARK_LENGTH), oDocument
      sCurrentBookmarkName = Left(sCurrentBookmarkName, SHORT_BOOKMARK_LENGTH)
   ElseIf Len(sCurrentBookmarkName) = LONG_BOOKMARK_LENGTH_INDEXED Then
      RenameBookmark sCurrentBookmarkName, Left(sCurrentBookmarkName, SHORT_BOOKMARK_LENGTH_INDEXED), oDocument
      sCurrentBookmarkName = Left(sCurrentBookmarkName, SHORT_BOOKMARK_LENGTH_INDEXED)
   End If
   
   Set oRange = oDocument.Bookmarks(sCurrentBookmarkName).Range
      oRange.Text = ""
   If sType <> "NUL" Then
      
      oRange.PasteSpecial
      oRange.Select
      oRange.SetRange oRange.Start - 1, oRange.End
   End If
   oDocument.Bookmarks.Add sCurrentBookmarkName, oRange
'      Set oRange = oDocument.Bookmarks(oItem.Key).Range
'      oRange.SetRange oRange.Start, oRange.Start
'      oDocument.Bookmarks(oItem.Key).Range.Text = ""
'      oDocument.Bookmarks.Add oItem.Key, oRange
      'SetDocumentProperty sCurrentBookmarkName, eplcDocPropCustom, "NUL", oDocument
   
   If oRange.InlineShapes(1).HasChart Then
      oDocument.Bookmarks(sCurrentBookmarkName).Range.InlineShapes(1).Chart.ChartData.BreakLink
   End If
   SetDocumentProperty sCurrentBookmarkName, eplcDocPropCustom, UCase(sType), oDocument
   
   Exit Sub
   
BailOut:
   DebugMsg MODULE_NAME & "::SetBookmarkValue: Error with " & sCurrentBookmarkName & ": " & CStr(Err.Number) & "/" & Err.Description, dbgLogError
   Resume Next
   
End Sub

Function ReturnExistingBookmark(ByVal sBookmarkName As String)
   Dim oBookmark As Bookmark
   If oDocument.Bookmarks.Exists(sBookmarkName) Then
      ReturnExistingBookmark = sBookmarkName
      Exit Function
      sBookmarkName = Left(sBookmarkName, Len(sBookmarkName) - 4)
   End If
   If Len(sBookmarkName) = LONG_BOOKMARK_LENGTH Then
      sBookmarkName = Left(sBookmarkName, Len(sBookmarkName) - 4)
   End If
   If Len(sBookmarkName) = SHORT_BOOKMARK_LENGTH_INDEXED Then
      For Each oBookmark In oDocument.Bookmarks
      
         If Left(oBookmark.Name, SHORT_BOOKMARK_LENGTH_INDEXED) = sBookmarkName Then
            ReturnExistingBookmark = oBookmark.Name
            Exit Function
         End If
      Next
   End If
   For Each oBookmark In oDocument.Bookmarks
      
      If Left(oBookmark.Name, SHORT_BOOKMARK_LENGTH) = sBookmarkName And Len(oBookmark.Name) <> SHORT_BOOKMARK_LENGTH_INDEXED Then
         ReturnExistingBookmark = oBookmark.Name
         Exit Function
      End If
   Next
   
   
End Function
Public Sub RenameBookmark(sOldBookmark As String, sNewBookmark As String, Optional ByRef oDocument As Document)
   
   On Error GoTo BailOut
   Dim oRange As Range
   
   If Application.Windows.Count <> 0 Then
      If oDocument Is Nothing Then Set oDocument = ActiveDocument
   Else
      Exit Sub
   End If
   
   If Not oDocument.Bookmarks.Exists(sOldBookmark) Then Exit Sub
   
   Set oRange = oDocument.Bookmarks(sOldBookmark).Range
   oDocument.Bookmarks(sOldBookmark).Delete
   oDocument.Bookmarks.Add sNewBookmark, oRange
   
   GoTo EndFunction
   
BailOut:
   Resume Next

EndFunction:
   Set oRange = Nothing
   
End Sub
Sub testBook()
   Dim bgBmks As New cPropertyBag
   Dim bmk As Bookmark
   Dim oItem As cPropertyObject
   
   ActiveDocument.Bookmarks.DefaultSorting = wdSortByLocation
   
   For Each bmk In ActiveDocument.Bookmarks
      bgBmks.Add bmk.Name, bmk.Name, bmk.Start
   Next
   bgBmks.Sort , , espcSortByItemData
   For Each oItem In bgBmks
      'Debug.Print oItem.Key & vbTab & oItem.ItemData
   Next
End Sub
Public Function GetChartControlByName(sName As String) As cFormChartControl
   Dim oItem
   For Each oItem In TableControls
         Debug.Print oItem.Name & vbCrLf & sName
      If oItem.Name = sName Then
         Set GetChartControlByName = oItem
         Exit Function
      End If
   Next
End Function
Attribute VB_Name = "mPlug_ApplyStyle"
Option Compare Text

Sub ApplyStyleNew(ctl As IRibbonControl)
   '
      Dim sTag As String
      Dim p_Stylename As WdBuiltinStyle
      
      sTag = ctl.Tag
      
      If Left(UCase(sTag), 2) = "WD" Then
         Select Case UCase(sTag)
            Case "NORMAL"
               p_Stylename = wdStyleNormal
            Case "WDSTYLEHEADING1"
               p_Stylename = wdStyleHeading1
            Case "WDSTYLEHEADING2"
               p_Stylename = wdStyleHeading2
            Case "WDSTYLEHEADING3"
               p_Stylename = wdStyleHeading3
            Case "WDSTYLEHEADING4"
               p_Stylename = wdStyleHeading4
            Case "WDSTYLEHEADING5"
               p_Stylename = wdStyleHeading5
            Case "WDSTYLEHEADING6"
               p_Stylename = wdStyleHeading6
            Case "WDSTYLEHEADING7"
               p_Stylename = wdStyleHeading7
            Case "WDSTYLELISTBULLET"
               p_Stylename = wdStyleListBullet
            Case "WDSTYLELISTNUMBER"
               p_Stylename = wdStyleListNumber
            Case "WDSTYLEEMPHASIS"
               p_Stylename = wdStyleEmphasis
            Case Else
               p_Stylename = wdStyleNormal
         End Select
         Selection.Style = ActiveDocument.Styles(p_Stylename)
      Else
         Selection.Style = ActiveDocument.Styles(sTag)
      End If

   Exit Sub

ErrHandler:
   MsgBox "Applying style error", vbOKOnly, "The requested style is not present in this document.", vbModeless, , , , , _
      "Close", , False
   ufMessage.cmdClose.Enabled = True
   ufMessage.KeepLoaded = False
   DoEvents
   

End Sub

Sub UpdateStyles(ctr As IRibbonControl)
   
On Error GoTo ErrHandler
   
System.Cursor = wdCursorWait
  
  
    'Heading 1
    Dim strStyleName As String
    
    strStyleName = "Heading 1,MainHeading"
    
    If Not StyleExists(strStyleName) Then
        strStyleName = "Heading 1;MainHeading"
    End If
   
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .Name = "TDC Black"
            .Size = 25
            .Bold = True
            .Italic = False
            .Underline = wdUnderlineNone
            .UnderlineColor = wdColorAutomatic
            .AllCaps = False
            .Color = RGB(0, 60, 103)
            .Superscript = False
            .Subscript = False
            .Scaling = 100
            .Kerning = 16
        End With
        With ActiveDocument.Styles("Heading 1")
            .AutomaticallyUpdate = False
            .BaseStyle = "Normal"
            .NextParagraphStyle = "Normal"
        End With
        With ActiveDocument.Styles(strStyleName).ParagraphFormat
            .LineSpacingRule = wdLineSpaceExactly
            .LineSpacing = 27
            .KeepWithNext = True
            .KeepTogether = True
            .PageBreakBefore = True
        End With
        With ActiveDocument.Styles(strStyleName).Frame
            .TextWrap = True
            .WidthRule = wdFrameExact
            .Width = CentimetersToPoints(25.7)
            .HeightRule = wdFrameAuto
            .HorizontalPosition = wdFrameLeft
            .RelativeHorizontalPosition = wdRelativeHorizontalPositionMargin
            .VerticalPosition = CentimetersToPoints(3.25)
            .RelativeVerticalPosition = wdRelativeVerticalPositionPage
            .HorizontalDistanceFromText = CentimetersToPoints(0)
            .VerticalDistanceFromText = CentimetersToPoints(0)
            .LockAnchor = False
        End With
    End If
    
    'Chart - Heading text
    strStyleName = "Chart - Heading text"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
    End If
    
    'Chart - Heading text Left
    strStyleName = "Chart - Heading text Left"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
    End If
    
    'Chart - Heading text Right
    strStyleName = "Chart - Heading text Right"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
    End If

 'Chart heading in greytable
    strStyleName = "Chart heading in greytable"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
    End If
    
 'Product Chart Topheading
    strStyleName = "Product Chart Topheading"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
    End If
    
'Product Chart Heading
    strStyleName = "Product Chart Heading"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
        With ActiveDocument.Styles(strStyleName).ParagraphFormat
            .LeftIndent = CentimetersToPoints(0.15)
            .RightIndent = CentimetersToPoints(0.15)
        End With
    End If
    
    
'Product Chart
    strStyleName = "Product Chart"
    
    If StyleExists(strStyleName) Then
        With ActiveDocument.Styles(strStyleName).Font
            .AllCaps = False
        End With
        With ActiveDocument.Styles(strStyleName).ParagraphFormat
            .LeftIndent = CentimetersToPoints(0.15)
            .RightIndent = CentimetersToPoints(0.15)
        End With
    End If
    
'TOC 5
   With ActiveDocument.Styles(wdStyleTOC5).Font
      .Name = "TDC Black"
      .Size = 10
      .Bold = False
      .Italic = False
      .Underline = wdUnderlineNone
      .UnderlineColor = wdColorAutomatic
      .AllCaps = False
      .Color = RGB(0, 0, 0)
      .Superscript = False
      .Subscript = False
   End With
   With ActiveDocument.Styles(wdStyleTOC8)
      .ParagraphFormat.TabStops.Add CentimetersToPoints(28), wdAlignTabRight
   End With

'TOC 6
    With ActiveDocument.Styles(wdStyleTOC6).Font
      .Name = "TDC Black"
      .Size = 10
      .Bold = False
      .Italic = False
      .Underline = wdUnderlineNone
      .UnderlineColor = wdColorAutomatic
      .AllCaps = False
      .Color = RGB(0, 0, 0)
      .Superscript = False
      .Subscript = False
    End With

'TOC 8
   With ActiveDocument.Styles(wdStyleTOC8).Font
      .Name = "TDC Black"
      .Size = 10
      .Bold = False
      .Italic = False
      .Underline = wdUnderlineNone
      .UnderlineColor = wdColorAutomatic
      .AllCaps = False
      .Color = RGB(0, 0, 0)
      .Superscript = False
      .Subscript = False
   End With
   With ActiveDocument.Styles(wdStyleTOC8)
      .ParagraphFormat.TabStops.Add CentimetersToPoints(0), wdAlignTabLeft
      .ParagraphFormat.TabStops.Add CentimetersToPoints(28), wdAlignTabRight
   End With
   With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(1)
      .NumberFormat = "%1."
      .TrailingCharacter = wdTrailingTab
      .NumberStyle = wdListNumberStyleArabic
      .NumberPosition = CentimetersToPoints(-25)
      .Alignment = wdListLevelAlignLeft
      .TextPosition = CentimetersToPoints(0)
      .TabPosition = wdUndefined
      .ResetOnHigher = 0
      .StartAt = 1
      With .Font
         .Bold = wdUndefined
         .Italic = wdUndefined
         .StrikeThrough = wdUndefined
         .Subscript = wdUndefined
         .Superscript = wdUndefined
         .Shadow = wdUndefined
         .Outline = wdUndefined
         .Emboss = wdUndefined
         .Engrave = wdUndefined
         .AllCaps = wdUndefined
         .Hidden = wdUndefined
         .Underline = wdUndefined
         .Color = wdUndefined
         .Size = 8
         .Animation = wdUndefined
         .DoubleStrikeThrough = wdUndefined
         .Name = "TDC Light"
      End With
      .LinkedStyle = "TOC 8"
   End With
   With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(2)
      .NumberFormat = "%1.%2."
      .TrailingCharacter = wdTrailingTab
      .NumberStyle = wdListNumberStyleArabic
      .NumberPosition = CentimetersToPoints(0)
      .Alignment = wdListLevelAlignLeft
      .TextPosition = CentimetersToPoints(0.8)
      .TabPosition = wdUndefined
      .ResetOnHigher = 1
      .StartAt = 1
      With .Font
         .Bold = False
         .Italic = False
         .StrikeThrough = wdUndefined
         .Subscript = wdUndefined
         .Superscript = wdUndefined
         .Shadow = wdUndefined
         .Outline = wdUndefined
         .Emboss = wdUndefined
         .Engrave = wdUndefined
         .AllCaps = wdUndefined
         .Hidden = wdUndefined
         .Underline = wdUndefined
         .Color = wdUndefined
         .Size = 8
         .Animation = wdUndefined
         .DoubleStrikeThrough = wdUndefined
         .Name = "TDC Light"
      End With
      .LinkedStyle = "TOC 9"
   End With
   
   '***
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(3)
        .NumberFormat = ChrW(61607)
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(0.8)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(1.1)
        .TabPosition = wdUndefined
        .ResetOnHigher = 2
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Wingdings"
        End With
        .LinkedStyle = ""
    End With
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(4)
        .NumberFormat = ChrW(61623)
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(1.1)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(1.3)
        .TabPosition = wdUndefined
        .ResetOnHigher = 3
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Symbol"
        End With
        .LinkedStyle = ""
    End With
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(5)
        .NumberFormat = "o"
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(1.3)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(1.8)
        .TabPosition = wdUndefined
        .ResetOnHigher = 4
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Courier New"
        End With
        .LinkedStyle = ""
    End With
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(6)
        .NumberFormat = ChrW(61607)
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(1.8)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(2.1)
        .TabPosition = wdUndefined
        .ResetOnHigher = 5
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Wingdings"
        End With
        .LinkedStyle = ""
    End With
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(7)
        .NumberFormat = ChrW(61623)
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(2.1)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(2.4)
        .TabPosition = wdUndefined
        .ResetOnHigher = 6
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Symbol"
        End With
        .LinkedStyle = ""
    End With
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(8)
        .NumberFormat = "o"
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(2.1)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(2.4)
        .TabPosition = CentimetersToPoints(2.4)
        .ResetOnHigher = 7
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Courier New"
        End With
        .LinkedStyle = ""
    End With
    With ListGalleries(wdOutlineNumberGallery).ListTemplates(1).ListLevels(9)
        .NumberFormat = ChrW(61607)
        .TrailingCharacter = wdTrailingTab
        .NumberStyle = wdListNumberStyleBullet
        .NumberPosition = CentimetersToPoints(2.4)
        .Alignment = wdListLevelAlignLeft
        .TextPosition = CentimetersToPoints(2.7)
        .TabPosition = CentimetersToPoints(2.7)
        .ResetOnHigher = 8
        .StartAt = 1
        With .Font
            .Bold = wdUndefined
            .Italic = wdUndefined
            .StrikeThrough = wdUndefined
            .Subscript = wdUndefined
            .Superscript = wdUndefined
            .Shadow = wdUndefined
            .Outline = wdUndefined
            .Emboss = wdUndefined
            .Engrave = wdUndefined
            .AllCaps = wdUndefined
            .Hidden = wdUndefined
            .Underline = wdUndefined
            .Color = wdUndefined
            .Size = wdUndefined
            .Animation = wdUndefined
            .DoubleStrikeThrough = wdUndefined
            .Name = "Wingdings"
        End With
        .LinkedStyle = ""
    End With   '***
   
   ListGalleries(wdOutlineNumberGallery).ListTemplates(1).Name = ""
   Selection.Range.ListFormat.ApplyListTemplateWithLevel ListTemplate:= _
      ListGalleries(wdOutlineNumberGallery).ListTemplates(1), _
      ContinuePreviousList:=True, ApplyTo:=wdListApplyToWholeList, _
      DefaultListBehavior:=wdWord10ListBehavior


ErrHandler:
   System.Cursor = wdCursorNormal

End Sub
Attribute VB_Name = "mPlug_AutoText"
Option Explicit
Option Compare Text
'

Function PlaceholdersInColumns(ByRef vIRibbonControlOrString As Variant)
   Dim lNumCol As Long
   Dim sParams As String
   Dim sAutotext As String
   
   ' Did we get a valid parameter?
   If TypeName(vIRibbonControlOrString) = "IRibbonControl" Then
      sParams = vIRibbonControlOrString.Tag
   ElseIf TypeName(vIRibbonControlOrString) = "String" Then
      sParams = vIRibbonControlOrString
   Else
      'Err.Raise 13, MODULE_NAME & "::PicturePlaceholders", "Type mismatch (bad parameter)." & " " & "The ""vIRibbonControlOrString"" parameter is neither a String value nor an IRibbonControl interface."
   End If
   
   lNumCol = Selection.PageSetup.TextColumns.Count
   
   Select Case lNumCol
      Case 1
         sAutotext = sParams & "1Column"
      Case 2
         sAutotext = sParams & "2Columns"
      Case 3
         sAutotext = sParams & "3Columns"
      Case Else
         sAutotext = sParams & "1Column"
   End Select
   
   SD_InsertAutoText sAutotext
   
End Function

Public Sub SD_InsertAutoText(ByRef vIRibbonControlOrString As Variant, Optional ByRef sTemplateName As String)
    
   Dim oTemplate As Template
   Dim oRange As Range
   Dim sAutotext As String
   Dim oBookmark As Bookmark
   Dim sLastColorCommand As String
   
   #If VBA7 Then
      Dim oUndoBuffer As UndoRecord
      Set oUndoBuffer = Application.UndoRecord
      oUndoBuffer.StartCustomRecord "Inds|fffd|t indholdselement"
   #End If
   '
   ' Did we get a valid parameter?
   If TypeName(vIRibbonControlOrString) = "IRibbonControl" Then
      sAutotext = vIRibbonControlOrString.Tag
   ElseIf TypeName(vIRibbonControlOrString) = "String" Then
      sAutotext = vIRibbonControlOrString
   Else
      'Err.Raise 13, MODULE_NAME & "::InsertAutoTextWithIndexedBookmark", "Type mismatch (bad parameter)." & " " & "The ""vIRibbonControlOrString"" parameter is neither a String value nor an IRibbonControl interface."
   End If

   If Len(Trim$(sTemplateName)) <> 0 Then
      Dim sFileName As String
      sFileName = CombinePaths(ThisDocument.Path, sTemplateName)
      If FileExists(sFileName) Then
         Set oTemplate = Application.Templates(sFileName)
      Else
         ' TODO: Evt fejlh|fffd|ndtering
      End If
   Else
      Set oTemplate = ActiveDocument.AttachedTemplate
   End If
   
   If Not oTemplate Is Nothing Then
   
      Set oRange = oTemplate.BuildingBlockEntries(sAutotext).Insert(Selection.Range, True)
      
      For Each oBookmark In oRange.Bookmarks
         If Right$(oBookmark.Name, 3) = "_NX" Then
            ChangeBookmarkName oBookmark.Name, ReturnBookmarkNameWithFirstAvailableIndex(oBookmark.Name)
         End If
      Next
      '
      ' If a non-default color choice was applied to the document we need to reapply it,
      ' since the AutoTextEntry may not have correct colors.
      If DocumentPropertyExists("LastColorCommand", eplcDocPropCustom, ActiveDocument) Then
         sLastColorCommand = GetDocumentProperty("LastColorCommand", eplcDocPropCustom, ActiveDocument)
         If LenB(sLastColorCommand) <> 0 Then
            On Error Resume Next
            Application.Run sLastColorCommand
            On Error GoTo 0
         End If
      End If
   
   Else
      ' TODO: Evt fejlh|fffd|ndtering
   End If
   
   #If VBA7 Then
      oUndoBuffer.EndCustomRecord
   #End If
   
   
End Sub

Attribute VB_Name = "mPlug_BulletsAndNumbering"
Public Sub FormatBulletDefault()
    If Selection.Range.ListFormat.ListType <> wdListBullet Then
        Selection.Style = wdStyleNormal
        Selection.Style = wdStyleListBullet
    Else
        Selection.Style = wdStyleNormal
    End If
End Sub

Public Sub FormatNumberDefault()
    If Selection.Range.ListFormat.ListType <> 4 Then
        Selection.Style = wdStyleNormal
        Selection.Style = wdStyleListNumber
    Else
        Selection.Style = wdStyleNormal
    End If
End Sub

Attribute VB_Name = "mPlug_InsertObject"

'Usage:
'2007/2010: Create Ribbon button: OnAction="InsertObject"; Tag="ObjectName=xxx" / Tag="ObjectName=xxx*Parameter=yyy"

'2003: Create commanbar button: OnAction="InsertObject2003"; Caption="ObjectName=xxx" / Caption="ObjectName=xxx*Parameter=yyy"
'2003: Comment out InsertObject(ctl as IRibbonControl)

Private Enum ObjectFileType
    Word = 0
    Excel = 1
    PowerPoint = 2
End Enum

Sub InsertObject(ctl As IRibbonControl)
    HandleTagAndDoInsertObject ctl.Tag
End Sub

Sub InsertObject2003()
    Dim strCommandBarCaption As String
    strCommandBarCaption = CommandBars.ActionControl.Caption
    strCommandBarCaption = Replace(strCommandBarCaption, "&", "")
    
    HandleTagAndDoInsertObject strCommandBarCaption
End Sub

Sub HandleTagAndDoInsertObject(sTag As String)
    Dim sCommand() As String
    sCommand = Split(sTag, "*")

    Dim sObjectName As String
    Dim sParameters As String
    
    sObjectName = ReturnValueFromPropertyString(sCommand(0), "ObjectName")
    
    If sObjectName = "" Then
        sObjectName = sCommand(0)
    End If
    
    If UBound(sCommand) > 0 Then
        sParameters = sCommand(1)
    End If

    DoInsertObject sObjectName, sParameters
End Sub

Sub DoInsertObject(strObjectName As String, Optional sParameters As String)
    On Error GoTo errorhandler
    Dim strFullFilename As String
    strFullFilename = FindObjectFileInObjectFilesFolderAndReturnFullFilename(strObjectName, Word)
    
    If strFullFilename = "" Then
        Exit Sub
    End If
    
    Dim strObjectBookmarkInDestinationDocument As String
    strObjectBookmarkInDestinationDocument = "bmkObj" & CleanObjectName(strObjectName)
    
    Selection.Collapse wdCollapseStart
        
    Dim rngInsertRange As Range
    Set rngInsertRange = InsertObject_InsertRange(strObjectName)
    
    If rngInsertRange Is Nothing Then
        If ActiveDocument.Bookmarks.Exists(strObjectBookmarkInDestinationDocument) Then
            Set rngInsertRange = ActiveDocument.Bookmarks(strObjectBookmarkInDestinationDocument).Range
        Else
            Set rngInsertRange = Selection.Range
        End If
    End If
    
    Dim rngSurroundingRange As Range
    Set rngSurroundingRange = ActiveDocument.Range(rngInsertRange.Start - 1, rngInsertRange.End + 1)
 
    rngInsertRange.InsertFile strFullFilename
    
    ActiveDocument.Bookmarks.Add "bmkInsertObject", rngSurroundingRange
    
    InsertObject_AfterInsert strObjectName, sParameters
errorhandler:
End Sub


Private Function FindObjectFileInObjectFilesFolderAndReturnFullFilename(strObjectName, eObjectFileType As ObjectFileType) As String
    Dim colFileExtensions As New Collection
    
    Select Case eObjectFileType
    Case ObjectFileType.Word
        colFileExtensions.Add ".dotm"
        colFileExtensions.Add ".dotx"
        colFileExtensions.Add ".dot"
        colFileExtensions.Add ".docm"
        colFileExtensions.Add ".docx"
        colFileExtensions.Add ".doc"
    Case ObjectFileType.Excel
        colFileExtensions.Add ".xlsm"
        colFileExtensions.Add ".xlsx"
        colFileExtensions.Add ".xls"
        colFileExtensions.Add ".xtsm"
        colFileExtensions.Add ".xtsx"
        colFileExtensions.Add ".xts"
    End Select

    Dim strAttachedTemplateName As String
    strAttachedTemplateName = ActiveDocument.AttachedTemplate.Name
    strAttachedTemplateName = Replace(strAttachedTemplateName, ".dotm", "")
    strAttachedTemplateName = Replace(strAttachedTemplateName, ".dotx", "")
    strAttachedTemplateName = Replace(strAttachedTemplateName, ".dot", "")

    Dim strFullFilename As String
    
    Dim sFileExtension As Variant
    
    For Each sFileExtension In colFileExtensions
        strFullFilename = FindFileInDefaultFilepaths("Objects_WE\" & strObjectName & sFileExtension)
        If Not strFullFilename = "" Then
            Exit For
        End If
    Next

    If strFullFilename = "" Then
        For Each sFileExtension In colFileExtensions
            strFullFilename = FindFileInDefaultFilepaths("Objects_WE\" & strAttachedTemplateName & "\" & strObjectName & sFileExtension)
            If Not strFullFilename = "" Then
                Exit For
            End If
        Next
    End If

    FindObjectFileInObjectFilesFolderAndReturnFullFilename = strFullFilename
End Function

Private Function CleanObjectName(ByVal sObjectName As String) As String
    sObjectName = Replace(sObjectName, " ", "")
    sObjectName = Replace(sObjectName, "-", "")
    sObjectName = Replace(sObjectName, "+", "")
    CleanObjectName = sObjectName
End Function


Private Function ReturnValueFromPropertyString(ByVal sCommandString, ByVal sPropertyValue As String)
    
    Dim iPropertyNamePosition As Integer
    iPropertyNamePosition = InStr(1, UCase(sCommandString), UCase(sPropertyValue))
    If iPropertyNamePosition = 0 Then
        ReturnValueFromPropertyString = sCommandString
        Exit Function
    End If
    
    Dim sValue As String
    sCommandString = Mid(sCommandString, iPropertyNamePosition)
    
    Dim iEqualSignPosition As Integer
    iEqualSignPosition = InStr(1, UCase(sCommandString), "=")
    If iEqualSignPosition = 0 Then
        Exit Function
    End If
    
    sCommandString = Mid(sCommandString, iEqualSignPosition + 1)
    
    Dim iDelimiterSignPosition As Integer
    iDelimiterSignPosition = InStr(1, UCase(sCommandString), "*")
    
    If iDelimiterSignPosition > 0 Then
        sCommandString = Mid(sCommandString, iDelimiterSignPosition - 1)
    End If
    
    ReturnValueFromPropertyString = sCommandString
End Function

Sub InsertObject_AfterInsert(strObjectName As String, Optional sParameters As String)

    On Error Resume Next

    If Not ActiveDocument.Bookmarks.Exists("bmkInsertObject") Then
        Exit Sub
    End If
    
    Dim rngInsertObjectRange As Range
    Set rngInsertObjectRange = ActiveDocument.Bookmarks("bmkInsertObject").Range
    
    Dim tbl As Table
    For Each tbl In rngInsertObjectRange.Tables
    Next

    Dim shInlineShape As InlineShape
    For Each shInlineShape In rngInsertObjectRange.InlineShapes
    Next

    Dim p As Paragraph
    For Each p In rngInsertObjectRange.Paragraphs
    Next
    
    Dim sh As Shape
    For Each sh In rngInsertObjectRange.ShapeRange
        sh.TextFrame.AutoSize = True
    Next
    
    Dim oField As Field
    For Each oField In rngInsertObjectRange.Fields
        oField.Update
        
        Dim sChartName As String
        If IsChartField(oField, sChartName) Then
            oField.Select
            InsertChart ReturnValueFromPropertyString(sParameters, "ChartName"), Selection.Range
        End If
    Next
    
End Sub

Function InsertObject_InsertRange(strObjectName) As Range
    Select Case Left(UCase(strObjectName), 7)
    Case "BAGSIDE"
        Selection.EndKey unit:=wdStory, Extend:=wdMove
    End Select
End Function

Function IsChartField(oField As Field, sChartName As String) As Boolean
    
    If Not oField.Type = wdFieldMacroButton Then
        Exit Function
    End If
    
    Dim sFieldCode As String
    sFieldCode = Trim(UCase(oField.Code))
    sFieldCode = Mid(sFieldCode, InStr(1, sFieldCode, " ") + 1)
    
    Dim sFieldParameter1 As String
    Dim sFieldParameter2 As String
    
    sFieldParameter1 = Trim(Left(sFieldCode, InStr(1, sFieldCode, " ")))
    sFieldParameter2 = Trim(Mid(sFieldCode, InStr(1, sFieldCode, " ") + 1))
    
    If Not sFieldParameter1 = "CHART" Then
        Exit Function
    End If
    
    sChartName = sFieldParameter2
    IsChartField = True
End Function

Sub TEST_insertchart()
    
    Dim oField As Field
    For Each oField In Selection.Range.Fields
        oField.Update
        
        Dim sChartName As String
        If IsChartField(oField, sChartName) Then
            oField.Select
            InsertChart "Columns_Lilla", Selection.Range
        End If
    Next
    
End Sub

Sub InsertChart(sChartName As String, rInsertRange As Range)

    On Error GoTo errorhandler
    Dim sFullFilename As String
    sFullFilename = FindObjectFileInObjectFilesFolderAndReturnFullFilename(sChartName, Excel)
    
    If sFullFilename = "" Then
        Exit Sub
    End If
    
    Dim appExcel As Object
    Set appExcel = CreateObject("Excel.Application")
    
    If appExcel Is Nothing Then
        Exit Sub
    End If
    
    appExcel.Visible = True
    
    Dim oWorkbook As Object
    Set oWorkbook = appExcel.Workbooks.Open(FileName:=sFullFilename, ReadOnly:=True)
    
    Dim oWorkSheet As Object
    Set oWorkSheet = oWorkbook.sheets(sChartName)
    
    oWorkSheet.Select
    oWorkSheet.ChartObjects(1).Copy
    rInsertRange.Select
    rInsertRange.PasteSpecial Link:=False, DataType:=wdPasteOLEObject, Placement:=wdInLine, DisplayAsIcon:=False

errorhandler:
    If Not oWorkSheet Is Nothing Then
        Set oWorkSheet = Nothing
    End If
    
    If Not oWorkbook Is Nothing Then
        oWorkbook.Close SaveChanges:=False
        Set oWorkbook = Nothing
    End If
    
    If Not appExcel Is Nothing Then
        appExcel.Quit
    End If
    
End Sub

'CLIENTCODE

Attribute VB_Name = "mPlug_PictureInCell"
Option Explicit
Option Compare Text

Const DefDbClicButtonText = "MACROBUTTON  InsertPictureInCell [Dobbeltklik for at inds|fffd|tte et billede] "

Enum sdDefaultGraphicFilePath
   sdAttachedTemplatePath = 0
   sdCustomDocumentProperty = 1
   sdUserIniSetting = 2
   sdGlobalIniSetting = 3
End Enum

Enum SDInsertionType
   SD_LockedHeight = 0
   SD_FreeHeight = 1
   SD_MaxWidthFreeHeight = 4
   SD_Encapsulated = 2
   SD_EncapsulatedFreeSize = 3
End Enum

Public Function ReturnPicturePath(Optional ByVal sDefaultPath As String) As String

   Dim sFileName As String
   Dim sFileTitle As String
   Dim sInitialDir As String
   Dim sDialogTitle As String
   Dim sDefaultExtension As String
   Dim sFilter As String
   Dim lFilterIndex As Long
   '
   ' Specify a reasonable set of file filters (Windows only)
   sFilter = GetLanguageString("FileFilterPictureFiles", "Picture files") & _
             "|*.jpg;*.bmp;*.png;*.tif;*.tiff;*.eps;*.wmf;*.emf|" & _
             GetLanguageString("FileFilterAllFiles", "All files") & _
             "|*.*"
   '
   ' Select the first filter
   lFilterIndex = 1
   '
   ' Preselect a path to open
   If LenB(sDefaultPath) <> 0 Then
      sInitialDir = sDefaultPath
   Else
      If DocumentPropertyExists("LastImageFolder", eplcDocPropCustom, ActiveDocument) Then
         sInitialDir = GetDocumentProperty("LastImageFolder", eplcDocPropCustom, ActiveDocument)
      End If
      If LenB(sInitialDir) = 0 Then
         sInitialDir = GetSpecialFolder(CSIDL_MYPICTURES)
      End If
   End If
   '
   ' If not found then default to something meaningful
   If Not FolderExists(sInitialDir) Then
      sInitialDir = GetSpecialFolder(CSIDL_DESKTOP)
   End If
   '
   ' Give the dialog a reasonble title
   sDialogTitle = GetLanguageString("DialogTitlePictureFiles", "Select picture ...")
   sDefaultExtension = "jpg"
   '
   ' Open the dialog. Note that sFileName and sFileTitle are output parameters.
   If ShowFileOpenDialog(sFileName, sFileTitle, True, False, False, True, sFilter, lFilterIndex, sInitialDir, sDialogTitle, sDefaultExtension) Then
      '
      ' sFileTitle is vbNullString if sFileName returns a "|" separated array,
      ' but since MultiSelect is Off sFileTitle will always represent the
      ' file name without path specification. sFileName does specify the full
      ' file name including the path.
      If Len(sFileTitle) <> 0 Then
         'Clean up the file name on MAC
         sFileName = Replace(sFileName, "alias ", "")
         '
         ' ... so, this a single file name
         ReturnPicturePath = sFileName
         '
         ' Save the path to a Document Property.
         SetDocumentProperty "LastImageFolder", eplcDocPropCustom, GetFolderName(sFileName), ActiveDocument
      Else
         '
         ' Should never happen here
      End If
      
   Else
     '
     ' The user pressed cancel or an error occurred.
   End If

End Function

Sub TestFolder()

   Debug.Print ReturnPicturePath  '("%AppData%")

End Sub


Function ReturnFolderName(strVal As String) As String
    Dim iPos As Integer
    iPos = InStrRev(strVal, "\")
    If iPos <> 0 Then
        ReturnFolderName = Left(strVal, iPos - 1)
    End If

End Function
Public Function FindShape(sShapeName As String, ByRef oShape As Shape) As Boolean

    Dim sh As Shape
    Dim sec As Section
    Dim hdrftr As HeaderFooter
    
    FindShape = False
    
    For Each sh In ActiveDocument.Shapes
        If sh.Name = sShapeName Then
            Set oShape = sh
            FindShape = True
            Exit Function
        End If
    Next

    For Each sec In ActiveDocument.Sections
        For Each hdrftr In sec.Headers
            For Each sh In hdrftr.Shapes
                If sh.Name = sShapeName Then
                    Set oShape = sh
                    FindShape = True
                    Exit Function
                End If
            Next
        Next
    Next

    For Each sec In ActiveDocument.Sections
        For Each hdrftr In sec.Footers
            For Each sh In hdrftr.Shapes
                If sh.Name = sShapeName Then
                    Set oShape = sh
                    FindShape = True
                    Exit Function
                End If
            Next
        Next
    Next

End Function

Sub InsertPictureInCell(strFile As String, oThisRange As Range, Optional InsertionType As SDInsertionType, Optional sBookmarkName As String)
    
    Dim pic As Shape
    Dim c As Cell
    
    '****
    Dim fld As Field
    Dim r As Range
    Dim iProtect As Integer
    Dim strFieldCode As String
    Dim sOldHeight As Single
    Dim sOldWidth As Single
    Dim sh As InlineShape
    Dim cellRatio As Single
    Dim pictRatio As Single
    Dim shOldHeight As Single
    Dim shOldWidth As Single
    Dim cWidth As Single
    Dim cHeight As Single
   ' Dim sBookmarkName As String
    
    Dim bFieldInCell As Boolean
   
   Dim snScaleHeight As Single
   Dim snScaleWidth  As Single
    
    
    On Error GoTo errorhandler
    
    
    iProtect = ActiveDocument.ProtectionType
    If iProtect <> wdNoProtection Then
        ActiveDocument.Unprotect
    End If
    
    Set c = oThisRange.Cells(1)
        
    If LenB(sBookmarkName) = 0 Then
      If c.Range.Bookmarks.Count > 0 Then
          sBookmarkName = c.Range.Bookmarks(1).Name
      End If
    End If
    
    If c.Range.Fields.Count = 1 Then
        bFieldInCell = True
    End If
    If bFieldInCell Then
        Set fld = c.Range.Fields(1)
        Set r = fld.Code
        strFieldCode = r.Text
        Dim iBracketPosition As Integer
        iBracketPosition = Len(fld.Code) - InStr(1, fld.Code, "[") + 1
    
        r.SetRange r.End - 1, r.End
        'r.Select
   
        oThisRange.Fields.ToggleShowCodes
        If oThisRange.InlineShapes.Count = 0 Then
            r.SetRange r.End - iBracketPosition, r.End
            r.Select
            oThisRange.Delete wdCharacter, 1
        End If
    End If
    

    oThisRange.Text = ""
    oThisRange.InlineShapes.AddPicture FileName:=strFile, LinkToFile:=False, SaveWithDocument:=True
    

    If oThisRange.InlineShapes.Count = 0 Then
        oThisRange.SetRange oThisRange.Start, oThisRange.End + 1
    End If

    Set sh = oThisRange.InlineShapes(1)
    
    
    Dim sNewWidth As Single
    Dim sFontIndent As Single
    Dim oStyle As Style
    Set oStyle = oThisRange.Style
    sFontIndent = oStyle.ParagraphFormat.LeftIndent
        
    cWidth = c.Width - c.RightPadding - c.LeftPadding - sFontIndent
    cHeight = c.Height - c.TopPadding - c.BottomPadding
    
    Set c = oThisRange.Cells(1)
    
    cellRatio = cHeight / cWidth
    pictRatio = sh.Height / sh.Width
    
    sh.Reset
    sh.ScaleHeight = 100
    sh.ScaleWidth = 100
    
    sh.LockAspectRatio = True
    
    shOldHeight = sh.Height
    shOldWidth = sh.Width
    
   Dim snCropAmount As Single
   Dim snScaleFactor As Single
   
    'let's go into the resizing algorythms...
    Select Case InsertionType
    
        Case SD_FreeHeight
            c.HeightRule = wdRowHeightAuto
            sh.Width = cWidth
        
        Case SD_MaxWidthFreeHeight
            c.HeightRule = wdRowHeightAuto
            If sh.Width > cWidth Then
               sh.Width = cWidth
               sh.Height = shOldHeight * sh.Width / shOldWidth
            End If
        
        Case SD_LockedHeight
            c.HeightRule = wdRowHeightExactly
           ' If cellRatio > pictRatio Then
           '     sh.Height = c.Height
           '     sh.Width = shOldWidth * sh.Height / shOldHeight
           ' Else
           '     sh.Width = cWidth
           '     sh.Height = shOldHeight * sh.Width / shOldWidth
           ' End If
            sh.Height = c.Height
            If sh.Width <= c.Width Then
               sh.Width = c.Width
               snCropAmount = sh.Height - c.Height
               snScaleFactor = shOldWidth / sh.Width
               sh.PictureFormat.CropTop = snCropAmount * snScaleFactor / 2
               sh.PictureFormat.CropBottom = snCropAmount * snScaleFactor / 2
            Else
               snCropAmount = sh.Width - c.Width
               snScaleFactor = shOldHeight / sh.Height
               sh.PictureFormat.CropLeft = snCropAmount * snScaleFactor / 2
               sh.PictureFormat.CropRight = snCropAmount * snScaleFactor / 2
            End If
            
           ' CropPictureToCenterOld sh
           ' snScaleHeight = sh.Height / shOldHeight * 100
           ' snScaleWidth = sh.Width / shOldWidth * 100
           ' CropPictureToCenter sh, snScaleWidth, snScaleHeight, cWidth, cHeight
            
        Case SD_Encapsulated
            c.HeightRule = wdRowHeightExactly
            If cellRatio < pictRatio Then
                sh.Height = c.Height
                sh.Width = shOldWidth * sh.Height / shOldHeight
            Else
                sh.Width = cWidth
                sh.Height = shOldHeight * sh.Width / shOldWidth
            End If
            
        Case SD_EncapsulatedFreeSize
            c.HeightRule = wdRowHeightExactly
            If sh.Width <= cWidth And sh.Height <= cHeight Then
            
            Else
                If cellRatio < pictRatio Then
                    sh.Height = c.Height
                    sh.Width = shOldWidth * sh.Height / shOldHeight
                Else
                    sh.Width = cWidth
                    sh.Height = shOldHeight * sh.Width / shOldWidth
                End If
            End If
    End Select
    
    If LenB(sBookmarkName) > 0 Then
        ActiveDocument.Bookmarks.Add sBookmarkName, c.Range
    End If
    
    For Each fld In c.Range.Fields
        
        fld.ShowCodes = False
    Next
    
    
    Exit Sub
errorhandler:
    

    
End Sub
Sub CropPictureToCenterOld(oShape As InlineShape)
    
   Dim c As Cell
   
   Set c = oShape.Range.Cells(1)
   Set oShape = c.Range.InlineShapes(1)
   If oShape.Height > c.Height Then
      oShape.PictureFormat.CropTop = ((oShape.Height - c.Height) / 2) / (oShape.ScaleHeight / 100)
      oShape.PictureFormat.CropBottom = oShape.PictureFormat.CropTop
   Else
      oShape.PictureFormat.CropLeft = ((oShape.Width - c.Width) / 2) / (oShape.ScaleWidth / 100)
      oShape.PictureFormat.CropRight = oShape.PictureFormat.CropLeft
   End If
    
End Sub

Sub CropPictureToCenter(oShape As InlineShape, snScaleWidth As Single, snScaleHeight As Single, snCellWidth As Single, snCellHeight As Single)
    On Error GoTo BailOut
    Dim c As Cell
    Dim snHeightRatio As Single
    Dim snWidthRatio As Single
    
    
    Set c = oShape.Range.Cells(1)
    Set oShape = c.Range.InlineShapes(1)
    
    snHeightRatio = oShape.Height / snCellHeight
    snWidthRatio = oShape.Width / snCellWidth
    
    If oShape.ScaleHeight > 0 Then snScaleHeight = oShape.ScaleHeight
    If oShape.ScaleWidth > 0 Then snScaleWidth = oShape.ScaleWidth
    
    If snHeightRatio > snWidthRatio Then
        oShape.PictureFormat.CropTop = ((oShape.Height - snCellHeight) / 2) / (snScaleHeight / 100)
        oShape.PictureFormat.CropBottom = oShape.PictureFormat.CropTop
    Else
        oShape.PictureFormat.CropLeft = ((oShape.Width - snCellWidth) / 2) / (snScaleWidth / 100)
        oShape.PictureFormat.CropRight = oShape.PictureFormat.CropLeft
    End If
    
   Exit Sub
    
BailOut:
   Resume Next
   
End Sub
Sub ChangeSelectedPicture(ctl As IRibbonControl)
   
On Error GoTo ErrHandler
   
   If Selection.Type = wdSelectionInlineShape Then
      If Selection.Information(wdWithInTable) Then
         IP_DbClickFreeHeight
      End If
   End If

ExitHere:
   Exit Sub

ErrHandler:
   MsgBox Err.Number & " - " & Err.Description

End Sub
Function ReturnInsertionRangeListFromSelectionRange() As Collection
    Dim oBookmark As Bookmark
    Dim colBookmarks As Collection
    Dim sBookmarkName As String
    Dim sBookmarkRootName As String
    Dim oRange As Range
    Dim bNoBookmark As Boolean
    
    Set oRange = Selection.Range
    Set colBookmarks = New Collection
    
    If oRange.Bookmarks.Count > 0 Then
         For Each oBookmark In oRange.Bookmarks
            If oBookmark.Name <> "bmkInsertObject" Then
               sBookmarkName = oBookmark.Name
               
               Exit For
            End If
         Next
        
        If LenB(sBookmarkName) = 0 Then
            bNoBookmark = True
        Else
         
            If IsNumeric(Right(sBookmarkName, 2)) Then
                sBookmarkRootName = Left(sBookmarkName, Len(sBookmarkName) - 2)
                For Each oBookmark In ActiveDocument.Bookmarks
                   
                   If IsNumeric(Right(oBookmark.Name, 2)) And Left(oBookmark.Name, Len(sBookmarkRootName)) = sBookmarkRootName Then
                      If oBookmark.Range.Cells.Count > 0 Then
                            colBookmarks.Add oBookmark.Range.Cells(1).Range
                      End If
                   End If
                Next
            Else
                Set oBookmark = oRange.Bookmarks(1)
                If oBookmark.Range.Cells.Count > 0 Then
                    colBookmarks.Add oBookmark.Range.Cells(1).Range
                End If
            End If
         End If
    Else
       bNoBookmark = True
    End If
     
    If bNoBookmark Then
        If oRange.Cells.Count = 1 Then
            colBookmarks.Add oRange.Cells(1).Range
        End If
     
    End If
    
    Set ReturnInsertionRangeListFromSelectionRange = colBookmarks
    
End Function
Function ReturnInsertionRangeListFromBookmarkName(ByVal sBookmarkName As String, ByRef colBookmarkNames) As Collection
    Dim oBookmark As Bookmark
    Dim colBookmarks As Collection
    Dim sBookmarkRootName As String
    
    'Dim colBookmarkNames As New Collection
    Set colBookmarks = New Collection
    
    
    
    If IsNumeric(Right(sBookmarkName, 2)) Then
        sBookmarkRootName = Left(sBookmarkName, Len(sBookmarkName) - 2)
    Else
        sBookmarkRootName = sBookmarkName
    End If
    
    
    For Each oBookmark In ActiveDocument.Bookmarks
       
       If IsNumeric(Right(oBookmark.Name, 2)) And Left(oBookmark.Name, Len(sBookmarkRootName)) = sBookmarkRootName Then
          If oBookmark.Range.Cells.Count > 0 Then
                colBookmarks.Add oBookmark.Range
                colBookmarkNames.Add oBookmark.Name
          End If
       End If
    Next
    
    If ActiveDocument.Bookmarks.Exists(sBookmarkRootName) Then
        Set oBookmark = ActiveDocument.Bookmarks(sBookmarkRootName)
        If oBookmark.Range.Cells.Count > 0 Then
            colBookmarks.Add oBookmark.Range
            colBookmarkNames.Add oBookmark.Name
        End If
    End If
    
    Set ReturnInsertionRangeListFromBookmarkName = colBookmarks

End Function

Sub IP_DbClickFreeHeight(Optional ByRef ctl As Variant)
   
   ExecuteInsertionDoubleClick SD_FreeHeight
   
End Sub

Sub IP_DbClickMaxWidthFreeHeight(Optional ByRef ctl As Variant)
   
   ExecuteInsertionDoubleClick SD_MaxWidthFreeHeight
   
End Sub

Sub IP_DbClickLockedHeight(Optional ByRef ctl As Variant)
   
   ExecuteInsertionDoubleClick SD_LockedHeight
   
End Sub

Sub IP_DbClickEncapsulated(Optional ByRef ctl As Variant)
   
   ExecuteInsertionDoubleClick SD_Encapsulated

End Sub

Sub IP_DbClickEncapsulatedFreeSize(Optional ByRef ctl As Variant)
   
   ExecuteInsertionDoubleClick SD_EncapsulatedFreeSize

End Sub

Sub ExecuteInsertionDoubleClick(InsertionType As SDInsertionType)
   
   Dim sFileName As String
   Dim oRange As Range
   Dim colInsertionRanges As Collection
   
   On Error GoTo BailOut
   
   #If VBA7 Then
      Dim oUndoBuffer As UndoRecord
      Set oUndoBuffer = Application.UndoRecord
      oUndoBuffer.StartCustomRecord "Inds|fffd|t billede"
   #End If
   
   Set colInsertionRanges = ReturnInsertionRangeListFromSelectionRange
     
   If colInsertionRanges.Count = 0 Then Exit Sub
   
   sFileName = ReturnPicturePath
   If LenB(sFileName) = 0 Then Exit Sub
   
   System.Cursor = wdCursorWait
   Application.ScreenUpdating = False
   
   Dim oWrapType As Integer
   If Options.PictureWrapType <> wdWrapMergeInline Then
      oWrapType = Options.PictureWrapType
      Options.PictureWrapType = wdWrapMergeInline
   End If
   
   For Each oRange In colInsertionRanges
      InsertPictureInCell sFileName, oRange.Cells(1).Range, InsertionType
   Next
   
   If oWrapType <> wdWrapMergeInline Then
     Options.PictureWrapType = oWrapType
   End If
   
   #If VBA7 Then
      oUndoBuffer.EndCustomRecord
   #End If
      
BailOut:
    
   Application.ScreenUpdating = True
   System.Cursor = wdCursorNormal

End Sub

Sub IP_InBookmarkFreeHeight(Optional ByRef ctl As Variant)
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   ExecuteInsertionByBookmark sTag, SD_FreeHeight

End Sub

Sub IP_InBookmarkMaxWidthFreeHeight(Optional ByRef ctl As Variant)
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   ExecuteInsertionByBookmark sTag, SD_MaxWidthFreeHeight

End Sub

Sub IP_InBookmarkLockedHeight(Optional ByRef ctl As Variant)
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   ExecuteInsertionByBookmark sTag, SD_LockedHeight

End Sub

Sub IP_InBookmarkEncapsulated(Optional ByRef ctl As Variant)
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   ExecuteInsertionByBookmark sTag, SD_Encapsulated

End Sub

Sub IP_InBookmarkEncapsulatedFreeSize(Optional ByRef ctl As Variant)
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   ExecuteInsertionByBookmark sTag, SD_EncapsulatedFreeSize

End Sub

Sub ExecuteInsertionByBookmark(sBookmarkName As String, InsertionType As SDInsertionType, Optional sFileFullName As String)
    
    Dim sFileName As String
    Dim oRange As Range
    Dim colInsertionRanges As Collection
    Dim colBookmarkNames As Collection
    
    On Error GoTo BailOut
    
   #If VBA7 Then
      Dim oUndoBuffer As UndoRecord
      Set oUndoBuffer = Application.UndoRecord
      oUndoBuffer.StartCustomRecord "Inds|fffd|t billede"
   #End If
    
    Set colBookmarkNames = New Collection
    Set colInsertionRanges = ReturnInsertionRangeListFromBookmarkName(sBookmarkName, colBookmarkNames)
    
    If colInsertionRanges.Count = 0 Then Exit Sub
    
    If LenB(sFileFullName) = 0 Then
      sFileName = ReturnPicturePath
    Else
      sFileName = sFileFullName
    End If
    
    If LenB(sFileName) = 0 Then Exit Sub
    
    System.Cursor = wdCursorWait
    Application.ScreenUpdating = False

    Dim oWrapType As Integer
    If Options.PictureWrapType <> wdWrapMergeInline Then
      oWrapType = Options.PictureWrapType
      Options.PictureWrapType = wdWrapMergeInline
    End If
    
    Dim lIndex As Long
    lIndex = 1
    For Each oRange In colInsertionRanges
        InsertPictureInCell sFileName, oRange.Cells(1).Range, InsertionType, colBookmarkNames(lIndex)
        lIndex = lIndex + 1
    Next
    
    If oWrapType <> wdWrapMergeInline Then
      Options.PictureWrapType = oWrapType
    End If
   
   #If VBA7 Then
      oUndoBuffer.EndCustomRecord
   #End If
    
BailOut:
    
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal

End Sub

Sub DeleteFrontPagePicture(Optional ByRef ctl As Variant)
   
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   Dim oColBookmarks As Collection
   
   #If VBA7 Then
      Dim oUndoBuffer As UndoRecord
      Set oUndoBuffer = Application.UndoRecord
      oUndoBuffer.StartCustomRecord "Slet forsidebillede"
   #End If
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   Set oColBookmarks = GetBookmarkNameCollectionByPrefix(sTag)
   
   Dim i As Integer
   
   For i = 1 To oColBookmarks.Count
      DeleteBookmarkRange oColBookmarks(i)
   Next

   #If VBA7 Then
      oUndoBuffer.EndCustomRecord
   #End If

End Sub

Sub EditFrontPagePictureInBookmark(Optional ByRef ctl As Variant)
   
   Dim sTag As String
   Dim iRibbonCtl As IRibbonControl
   Dim oColBookmarks As Collection
   Dim sBmkName As String
   
   If Not IsMissing(ctl) Then
      If VarType(ctl) = vbString Then
         sTag = ctl
      ElseIf TypeName(ctl) = "IRibbonControl" Then
         Set iRibbonCtl = ctl
         sTag = iRibbonCtl.Tag
      End If
   Else
      Exit Sub
   End If
   
   Set oColBookmarks = GetBookmarkNameCollectionByPrefix(sTag)
   
   If oColBookmarks.Count = 1 Then
      sBmkName = oColBookmarks(1)
      CropAndResize sBmkName
   ElseIf oColBookmarks.Count > 1 Then
      VBA.MsgBox GetLanguageString("EditFPPictureMessage", "Dobbeltklik p|fffd| den forside der skal benyttes og rediger forsidebilledet derefter."), vbOKOnly Or vbInformation, GetLanguageString("EditFPPictureTitle", "Rediger forsidebillede")
   End If
   
End Sub


Sub EditFrontPagePicture(Optional ByRef ctl As Variant)
   Dim oShape As InlineShape

'   With ActiveDocument.ActiveWindow.View
'       .Type = wdPrintView
'       .SeekView = wdSeekFirstPageFirstPageHeader
'   End With
   
   Set oShape = ActiveDocument.Sections(1).Headers(wdHeaderFooterFirstPage).Shapes(1).TextFrame.TextRange.Tables(1).Cell(1, 1).Range.InlineShapes(1)
   oShape.Select
   
   EditSelectedPicture

End Sub

Sub EditSelectedPicture(Optional ByRef ctl As Variant)
   
   If Selection.Range.InlineShapes.Count = 1 Then
      Application.CommandBars.ExecuteMso ("PictureCrop")
   End If

End Sub

Public Function SelectBookmarkedPictureForEditing(ByVal sBookmarkName As String, ByRef oDoc As Document) As Boolean
   
   Dim oShape As InlineShape
   Dim oBookmarkRange As Range
   Dim bHadErrors As Boolean
   
   On Error GoTo BailOut

   If oDoc Is Nothing Then Set oDoc = ActiveDocument

#If Not Mac = 1 And Not OfficeVersion = 2003 Then
   Set oBookmarkRange = oDoc.Bookmarks(sBookmarkName).Range
   If Not oBookmarkRange Is Nothing Then
      Set oShape = oBookmarkRange.InlineShapes(1)
      oShape.Select
      Application.CommandBars.ExecuteMso ("PictureCrop")
   End If
#Else
   VBA.MsgBox "The SelectBookmarkedPictureForEditing() function is available only with Word 2007/2010/2013 on Windows."
#End If
   
   GoTo EndFunction

BailOut:
   bHadErrors = True
  ' DebugMsg MODULE_NAME & "::SelectBookmarkedPictureForEditing: Error" & CStr(Err.Number) & " / " & Err.Description
   Resume Next
   
EndFunction:
   SelectBookmarkedPictureForEditing = Not bHadErrors

End Function


Public Function SelectFrontPagePictureForEditing(sBookmarkName As String) As Boolean
     
   Dim oShape As InlineShape
   Dim oBookmarkRange As Range
   Dim bHadErrors As Boolean
   Dim oDoc As Document
   
   On Error GoTo BailOut

   Set oDoc = ActiveDocument

#If Not Mac = 1 And Not OfficeVersion = 2003 Then
   Set oBookmarkRange = oDoc.Bookmarks(sBookmarkName).Range
   If Not oBookmarkRange Is Nothing Then
      Set oShape = oBookmarkRange.InlineShapes(1)
      oShape.Select
      Application.CommandBars.ExecuteMso ("PictureCrop")
   End If
#Else
   VBA.MsgBox "The SelectFrontPagePictureForEditing() function is available only with Word 2007/2010/2013 on Windows."
#End If
   
   GoTo EndFunction

BailOut:
   bHadErrors = True
  ' DebugMsg MODULE_NAME & "::SelectFrontPagePictureForEditing: Error" & CStr(Err.Number) & " / " & Err.Description
   Resume Next
   
EndFunction:
   SelectFrontPagePictureForEditing = Not bHadErrors
   
'   Dim oShape As InlineShape
'   Dim rngHF As Range
'   Dim rngTbl As Range
'   Dim rngBmk As Range
'   Dim intSec As Integer
'   Dim intHFType As Integer
'   Dim strBmkNavn As String
'
'   On Error GoTo ErrHandler
'
'   strBmkNavn = bookmarkName
'
'   ' Run through sections
'   For intSec = 1 To ActiveDocument.Sections.Count
'      With ActiveDocument.Sections(intSec)
'         ' and HF
'         For intHFType = 1 To 3
'            Set rngHF = ActiveDocument.Sections(intSec).Headers(intHFType).Range
'
'               Dim shp As Shape
'               Dim tbl As Table
'               Dim rngTxt As Range
'
'               'and shapes
'               For Each shp In rngHF.ShapeRange
'                  If shp.Type = msoTextBox Then
'                     Set rngTxt = shp.TextFrame.TextRange
'                     ' and tables
'                     For Each tbl In rngTxt.Tables
'                        Set rngTbl = tbl.Cell(1, 1).Range
'                        'to find the bookmark
'                        If rngTbl.Bookmarks.Exists(strBmkNavn) Then
'                           Set rngBmk = rngTbl.Bookmarks(strBmkNavn).Range
'                           GoTo MoveOn
'                        End If
'                     Next
'                  End If
'               Next
'         Next intHFType
'      End With
'   Next
'
'   GoTo ExitHere
'
'MoveOn:
'
'   'select shape and start croping
'   Set oShape = rngBmk.InlineShapes(1)
'   oShape.Select
'
'   #If VBA7 Then
'      Application.CommandBars.ExecuteMso ("PictureCrop")
'   #End If
'
'ExitHere:
'   Exit Sub
'
'ErrHandler:
'   GoTo ExitHere

End Function


Sub IP_CropAndResize(Optional ByRef ctl As Variant)
   ' Resize the picture so that the croped area fits the
   ' size of the cell
   
   On Error GoTo errorhandler
   
   If Selection.Tables.Count = 0 Then Exit Sub
   
   Dim oCell As Cell
   Dim oShape As InlineShape
   
   Set oCell = Selection.Cells(1)
   If oCell.Range.InlineShapes.Count = 0 Then Exit Sub
   
   System.Cursor = wdCursorWait
   Application.ScreenUpdating = False
   
   Set oShape = oCell.Range.InlineShapes(1)
   
   Dim cWidth As Single
   Dim cHeight As Single
   Dim cellRatio As Single
   Dim pictRatio As Single
   Dim shOldHeight As Single
   Dim shOldWidth As Single
   
   cWidth = oCell.Width - oCell.RightPadding - oCell.LeftPadding ' - sFontIndent
   cHeight = oCell.Height - oCell.TopPadding - oCell.BottomPadding
   
   cellRatio = cHeight / cWidth
   pictRatio = oShape.Height / oShape.Width
   
   oShape.LockAspectRatio = True

   shOldHeight = oShape.Height
   shOldWidth = oShape.Width
    
   If oCell.HeightRule = wdRowHeightExactly Then
      If cellRatio > pictRatio Then
       oShape.Height = oCell.Height
       oShape.Width = shOldWidth * oShape.Height / shOldHeight
      Else
          oShape.Width = cWidth
          oShape.Height = shOldHeight * oShape.Width / shOldWidth
      End If
   Else
      oShape.Width = cWidth
   End If
   
   oShape.Select
   
   #If VBA7 Then
       Application.CommandBars.ExecuteMso ("PictureCrop")
   #End If
    
errorhandler:

   Application.ScreenUpdating = True
   System.Cursor = wdCursorNormal
   
End Sub


Attribute VB_Name = "mPlug_Table"
Public Const blnExcelScreenUpdating = False
Public Const blnExcelVisibility = False

Sub TableLightBlueBackground(oControl As IRibbonControl)
   Dim c As Cell
   
   If Selection.Information(wdWithInTable) Then
      For Each c In Selection.Cells
         c.Shading.BackgroundPatternColor = RGB(227, 242, 251)
      Next
   End If
   
End Sub

Sub TableNoBackground(oControl As IRibbonControl)
   Dim c As Cell
   
   If Selection.Information(wdWithInTable) Then
      For Each c In Selection.Cells
         c.Shading.BackgroundPatternColorIndex = wdAuto
      Next
   End If
   
End Sub


Sub BorderTopBlue(oControl As IRibbonControl)
    ColorBorderBottom RGB(117, 190, 233), wdBorderTop
End Sub

Sub BorderBottomBlue(oControl As IRibbonControl)
    ColorBorderBottom RGB(117, 190, 233), wdBorderBottom
End Sub

Sub ColorBorderBottom(RGBvalue As Double, iBorder)
    Dim tbl As Table
    Dim r As Row
    Dim c As Cell
    Dim iRowNumber As Integer
    
    Select Case Selection.Cells.Count
    Case 1
        Select Case Selection.Cells(1).ColumnIndex
        Case 1
            Set tbl = Selection.Tables(1)
            Set c = Selection.Cells(1)
            iRowNumber = c.RowIndex
            Set r = tbl.Rows(iRowNumber)
            
            With r.Cells
                With .Borders(iBorder)
                    .LineStyle = wdLineStyleSingle
                    .LineWidth = wdLineWidth050pt
                    .Color = RGBvalue
                End With
            End With
        Case Else
            With Selection.Cells
                With .Borders(iBorder)
                    .LineStyle = wdLineStyleSingle
                    .LineWidth = wdLineWidth050pt
                    .Color = RGBvalue
                End With
            End With
        End Select
    Case Else
        With Selection.Cells
            With .Borders(iBorder)
                .LineStyle = wdLineStyleSingle
                .LineWidth = wdLineWidth050pt
                .Color = RGBvalue
            End With
        End With
    End Select
    
End Sub

Sub RemoveBorderTopBottom(Optional ctr As IRibbonControl)
   
   If Selection.Information(wdWithInTable) Then
      With Selection
         .Borders(wdBorderBottom).LineStyle = wdLineStyleNone
         .Borders(wdBorderTop).LineStyle = wdLineStyleNone
      End With
   End If

End Sub


Function TableWidth(oTable As Table) As Single
   '
   Dim oRng As Range
   Dim sngWidth As Single

   With oTable
      Set oRng = .Cell(1, 1).Range
      Do While oRng.Cells(1).RowIndex = 1
        sngWidth = sngWidth + oRng.Cells(1).Width
        oRng.Move unit:=wdCell, Count:=1
      Loop
      TableWidth = PointsToCentimeters(sngWidth)
   End With

End Function

Attribute VB_Name = "mStrinFunctions"
Option Explicit

Function strClean(strToClean)
   Dim iterator As Long
   Dim currentChar As String
   Dim inStringArray()
   ReDim inStringArray(Len(strToClean) - 1)

   For iterator = 1 To Len(strToClean)
      currentChar = Mid(strToClean, iterator, 1)
      
      Select Case currentChar
      Case "?", "/", "\", ":", "*", """", "<", ">", "", "#", "~", "%", "(", ")", "{", "}", "+", "-", ".", " ", ","
         inStringArray(iterator - 1) = "_"
      Case "&"
         inStringArray(iterator - 1) = "_and_"
      Case Else
         inStringArray(iterator - 1) = currentChar
      End Select
   
   Next
   
   strClean = Join(inStringArray, "")
End Function
Attribute VB_Name = "mXLFunctions"
Function GetRangeName(ByVal oWorkbook As Workbook, Optional sType As String) As String
   Dim oSheet As Worksheet
   Dim oName As Name
   Dim sAddress As String
   Dim sRangeName As String
   Dim oBook As Excel.Workbook
   Dim sTempType As String
   Dim sSheetName As String
   
   If Len(sType) > 0 Then
      sTempType = "_" & sType
   End If
   
   Set oBook = oWorkbook
   Set oSheet = oBook.ActiveSheet
   
   sAddress = oSheet.Name & "'!"
   sAddress = sAddress & oBook.Application.Selection.Address
   
   For Each oName In oBook.Names
      If InStr(oName.RefersTo, sAddress) > 0 Then
         If InStr(oName.Name, "Print_") Then
            oName.Delete
         Else
            sRangeName = oName.Name
         End If
         Exit For
      End If
   Next
        
   If Len(sRangeName) = 0 Then
      sAddress = oBook.Application.Selection.Address
      sAddress = Replace(sAddress, ":", "")
      sAddress = Replace(sAddress, "$", "")
      sAddress = strClean(sAddress)
      sSheetName = oSheet.Name
      sSheetName = strClean(sSheetName)
      sRangeName = sSheetName & "_" & sAddress & sTempType
      
      oBook.Names.Add Name:=sRangeName, RefersTo:=oBook.Application.Selection
   End If
   
   GetRangeName = sRangeName
   
End Function

Function SelectRangeByName(sRangeName As String, ByVal oWorkbook As Workbook, bSucces As Boolean)
   Dim oSheet As Worksheet
   Dim oName As Name
   Dim oRng As Excel.Range
   Dim oBook As Excel.Workbook
   
   
   
   Set oBook = oWorkbook
   
   For Each oName In oBook.Names
      If InStr(oName.Name, sRangeName) > 0 Then
         Set oRng = oName.RefersToRange
         Set oSheet = oRng.Worksheet
         oSheet.Select
         oRng.Select
'         Set SelectRangeByName = oRng
         bSucces = True
         GoTo ExitHere
      End If
   Next
   
'   Set SelectRangeByName = Nothing
   bSucces = False

ExitHere:
   
End Function
Attribute VB_Name = "modButton"
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Public bShowProgress As Boolean
Public blTrackChanges As Boolean

Sub SetShowProgress()
   '
   Dim bProgress As Boolean
   Dim oDoc As Document
   
   Set oDoc = ActiveDocument
   
   If DocumentPropertyExists("SD_ShowProgress", eplcDocPropCustom, oDoc) Then
      bProgress = CBool(GetDocumentProperty("SD_ShowProgress", eplcDocPropCustom, oDoc))
   Else
      bProgress = True
   End If
   
   bShowProgress = bProgress
   
   blWrapAroundText = True
   p_TablePosition = wdRelativeHorizontalPositionMargin
   blTrackChanges = oDoc.TrackRevisions

End Sub

Public Function SD_PasteXLtable(oRibbonControl As IRibbonControl)
   '
   Dim strTableType As String
   Dim sTag As String
   Dim arrTag() As String
   
   blUpdateOnlyNumbers = False
   
   SetShowProgress
   
   sTag = oRibbonControl.Tag
   
   If InStr(sTag, ";") Then
      arrTag = Split(sTag, ";")
      strTableType = arrTag(0)
      SetTableWidth CSng(arrTag(1)), False
   Else
      strTableType = sTag
      blWrapAroundText = False
      snTabelBredde = DEFAULTTABLEWIDTH
   End If
   
   sTableBookmarkName = ""
   
         
   If bShowProgress Then
      MsgBox "Creating a new table in the document ...", vbOKOnly, "Updating document, Please Wait ...", vbModeless, , , , , _
         "Close", , False
      ufMessage.cmdClose.Enabled = False
      DoEvents
   End If
   
   ActiveDocument.TrackRevisions = False
   
   PasteXlRegnskabsTable , strTableType
   
   If bShowProgress Then
      ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & " Finished!"
      DoEvents
      Sleep 1500
      ufMessage.KeepLoaded = False
      Unload ufMessage
   End If
   
   
   'Fjern l|fffd|s
   UnlockWord ActiveDocument
   
   ActiveDocument.TrackRevisions = blTrackChanges
   
   ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & vbCr & vbCr & "Done !!!"
   DoEvents
   ufMessage.KeepLoaded = False
   Unload ufMessage


End Function

Function UpdateSelectedTable(Optional ctl As Variant)
   '
   Dim oDoc As Document
   Dim oTable As Table
   Dim sPlaceHolder As String
   Dim sTag As String
   
   sTag = ctl.Tag
   
   If Len(sTag) > 0 Then
      If CBool(sTag) Then
         blUpdateOnlyNumbers = True
      End If
   End If
   
   SetShowProgress
   
   Set oDoc = ActiveDocument
   
   oDoc.Bookmarks.ShowHidden = True
   
   oDoc.TrackRevisions = False
   
   If Selection.Information(wdWithInTable) Then
      Set oTable = Selection.Tables(1)
      If Not oTable.Parent = ActiveDocument Then
         If oTable.Parent.Shapes.Count > 0 Then
            sPlaceHolder = oTable.Parent.Shapes(1).Name
         
            If InStr(UCase(sPlaceHolder), "COLUMNS") Then
               Dim snNumber As Single
               snNumber = CSng(Right(sPlaceHolder, 1))
               SetTableWidth snNumber
            Else
               GoTo ErrHandler
            End If
         End If
      Else
         Dim snTableWidth As Single
         snTableWidth = TableWidth(oTable)
         If Abs(snTableWidth - ONECOLUMNTABLEWIDTH) < 0.2 Then
            SetTableWidth 1, True
         ElseIf Abs(snTableWidth - TWOCOLUMNTABLEWIDTH) < 0.2 Then
            SetTableWidth 2, True
         ElseIf Abs(snTableWidth - THREECOLUMNTABLEWIDTH) < 0.2 Then
            SetTableWidth 3, True
         Else
            SetTableWidth 4, True
         End If
      End If
      
      
      If oTable.Range.Bookmarks.Count > 0 Then
         sTableBookmarkName = oTable.Range.Bookmarks(1).Name
         
         If InStr(UCase(sTableBookmarkName), "START") Then Exit Function
         
         If bShowProgress Then
            MsgBox "Updating document with ..." & vbCr, vbExclamation, "Updating document, Please Wait ...", vbModeless, , , , , _
               "Close", , False
            ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & vbCr & "    Table at bookmark: " & sTableBookmarkName & " ..."
            ufMessage.cmdClose.Enabled = False
            DoEvents
         End If
         
         PasteXlRegnskabsTable
         
         If bShowProgress Then
            ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & " Done !"
            ufMessage.KeepLoaded = True
            DoEvents
         End If
         
      Else
         MsgBox "Tabellen blev ikke opdateret. Tabellen er ikke indsat med PasteExcel.", , "Tabelopdatering"
      End If
   
      If bShowProgress Then
         ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & vbCr & vbCr & "Finished!"
         DoEvents
         Sleep 1500
         ufMessage.KeepLoaded = False
         Unload ufMessage
      End If
      
   End If

ExitHere:
   'Fjern l|fffd|s
   UnlockWord oDoc
   oDoc.TrackRevisions = blTrackChanges
   Exit Function
   
ErrHandler:
   MsgBox "Updating document with ..." & vbCr, vbExclamation, "Cannot update this table because the placeholder is not in the correct format.", vbModeless, , , , , _
               "Close", , False
   DoEvents
   Sleep 1500
   ufMessage.KeepLoaded = False
   Unload ufMessage
   GoTo ExitHere

End Function

Function UpdateAllTables(ctl As IRibbonControl)
   Dim oTable As Table
   Dim oRange As Range
   Dim sBookmarkName As String
   Dim oDocument As Document
   Dim oPropertyBag As cPropertyBag
   
   SetShowProgress
   
   Set oDocument = ActiveDocument
   oDocument.TrackRevisions = False
   
   oDocument.Bookmarks.ShowHidden = True
   
   Set oPropertyBag = New cPropertyBag
   
   If oDocument.Tables.Count > 0 Then
      Dim lNumTables As Long
      Dim lCount As Long
      lNumTables = oDocument.Tables.Count
      For lCount = 1 To lNumTables
         sBookmarkName = ""
         Set oTable = oDocument.Tables(lCount)
         Set oRange = oTable.Range
         If oRange.Bookmarks.Count > 0 Then
            sBookmarkName = oRange.Bookmarks(1).Name
            
            oPropertyBag.Add CStr(lCount), oRange, , sBookmarkName, , oRange
         End If
'         oPropertyBag.Add CStr(lCount), oRange, , sBookmarkName
      Next 'lNumTables
      
      If oPropertyBag.Count > 0 Then
      
         If bShowProgress Then
            MsgBox "Updating document with ..." & vbCr, vbExclamation, "Updating document, Please Wait ...", vbModeless, , , , , _
               "Close", , False
            DoEvents
         End If
      
         Dim oPropObj As cPropertyObject
         oPropertyBag.Sort , , espcSortByKey
         For Each oPropObj In oPropertyBag
            Set oRange = oPropObj.DataSource
            oRange.Select
            sTableBookmarkName = oPropObj.ItemTag
         
            If InStr(UCase(sTableBookmarkName), "START") Then GoTo NextBookmark
         
            If bShowProgress Then
               ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & vbCr & "    Table at bookmark: " & sTableBookmarkName & " ..."
               ufMessage.cmdClose.Enabled = False
               DoEvents
            End If
            
            PasteXlRegnskabsTable
            
            If bShowProgress Then
               ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & " Done !"
               ufMessage.KeepLoaded = True
               DoEvents
            End If

NextBookmark:
         Next
   
         If bShowProgress Then
            ufMessage.txtMessage.Text = ufMessage.txtMessage.Text & vbCr & vbCr & "Finished!"
            DoEvents
            Sleep 1500
            ufMessage.KeepLoaded = False
            Unload ufMessage
         End If
      
      Else
         MsgBox "Ingen tabeller blev opdateret. Tabellerne er ikke indsat med PasteExcel.", , "Tabelopdatering"
      End If
   End If
   
   Dim oShape As Shape
   Dim oTbl As Table
   
   
   For Each oShape In ActiveDocument.Shapes
      If oShape.TextFrame.TextRange.Tables.Count > 0 Then
         For Each oTbl In oShape.TextFrame.TextRange.Tables
            'Set oTbl = oShape.TextFrame.TextRange.Tables(1)
            oTbl.Select
         
            UpdateSelectedTable
         Next
      End If
   Next oShape

   
   'Fjern l|fffd|s
   UnlockWord oDocument
   
   oDocument.TrackRevisions = blTrackChanges
  
End Function

Sub SetTableWidth(snColumns As Single, Optional blUpdate As Boolean)
   '
   Dim sAutotext As String
   Dim sBmk As String
      
      Select Case snColumns
         Case 1
            snTabelBredde = ONECOLUMNTABLEWIDTH
            blWrapAroundText = False
            p_TablePosition = wdRelativeHorizontalPositionColumn
         Case 2
            snTabelBredde = TWOCOLUMNTABLEWIDTH
            blWrapAroundText = False
            p_TablePosition = wdRelativeHorizontalPositionColumn
         Case 3
            snTabelBredde = THREECOLUMNTABLEWIDTH
            blWrapAroundText = False
            p_TablePosition = wdRelativeHorizontalPositionColumn
         Case Else
            snTabelBredde = DEFAULTTABLEWIDTH
            blWrapAroundText = False
      End Select

   
   If Len(sAutotext) And Not blUpdate Then
      SD_InsertAutoText sAutotext, "RegnskabsTool.dotm"
      ActiveDocument.Bookmarks(sBmk).Select
      ActiveDocument.Bookmarks(sBmk).Delete
   End If

End Sub

Sub TableDelete(ctl As IRibbonControl)
   '
   DeletePasteXLTable
End Sub

Sub DeleteSpacesOnSelection(ctl As IRibbonControl)
   DeleteSpaceStyleOccurences Selection.Range
End Sub

Sub DeleteSpacesOnEntireDocument(ctl As IRibbonControl)
   DeleteSpaceStyleOccurences ActiveDocument.Range
End Sub

Sub DeleteSpaceStyleOccurences(oRange As Range)
   Dim oParagraph As Paragraph
   System.Cursor = wdCursorWait
   For Each oParagraph In oRange.Paragraphs
      If oParagraph.Style = "Note spacer" Then
         oParagraph.Range.Delete
      End If
   Next
   System.Cursor = wdCursorNormal
End Sub

Public Sub RunChartImport(ctl As IRibbonControl)
   Dim sValidDocument As String
   
   If DocumentPropertyExists("SD_TABLE", eplcDocPropCustom, ActiveDocument) Then
      sValidDocument = GetDocumentProperty("SD_TABLE", eplcDocPropCustom, ActiveDocument)
   End If
   
   If LCase(sValidDocument) <> "true" Then
      MsgBox "Dette dokument er ikke designet til at importere grafer fra Excel."
      Exit Sub
   End If
   
   Load ChartForm
   ChartForm.Show
   
End Sub

Sub PageBreakBeforeToggle(ctl As IRibbonControl)
    '
    'Selection.Paragraphs(1).PageBreakBefore = Not Selection.Paragraphs(1).PageBreakBefore
    Selection.InsertBreak wdPageBreak
    
    
End Sub

Sub LockAnchorToggle(ctl As IRibbonControl)
    '
    Dim sh As Shape
    
    On Error GoTo errorhandler
    
    
    Set sh = Selection.ShapeRange(1)
    sh.LockAnchor = Not sh.LockAnchor
    
errorhandler:

End Sub

Sub RydFormatering(ctl As IRibbonControl)
    '
'    Selection.Font.Reset
'    Selection.ParagraphFormat.Reset
   Selection.ClearFormatting
   
End Sub


Public Sub InsertColumnBreak(ctl As IRibbonControl)
   Selection.Collapse wdCollapseStart
   Selection.InsertBreak WdBreakType.wdColumnBreak
End Sub

Sub btnInsertTextFromExcel(ctl As IRibbonControl)
   '
   InsertTextFromXLCells

End Sub

'
'Public Sub SetTableNumbersToHidden(ctl As IRibbonControl)
'   On Error Resume Next
'
'   Dim tbl As Table
'   Dim p As Paragraph
'
'   Application.ScreenUpdating = False
'
'   For Each tbl In ActiveDocument.Tables
'      For Each p In tbl.Range.Paragraphs
'         Select Case p.Style
'         Case "Table - Number", "Table - Number small", "Table - Number Sum", "Table - Number Sum small", "Table - Number Negative", "Table - Number Negative small", "Table - Number Sum Negative", "Table - Number Sum Negative small"
'            p.Range.Font.Hidden = True
'         End Select
'         If CellText(p.Range.Text) = "2010" Or CellText(p.Range.Text) = "2011" Then
'            p.Range.Font.Hidden = True
'         End If
'      Next
'   Next
'
'   Application.ScreenUpdating = True
'End Sub
'
'Public Sub SetTableNumbersToVisible(ctl As IRibbonControl)
'   On Error Resume Next
'   ActiveDocument.Range.Font.Hidden = False
''   ActiveDocument.Styles("Table - Number").Font.Hidden = False
''   ActiveDocument.Styles("Table - Number Sum").Font.Hidden = False
'End Sub
'
'Public Sub OrddelAfsnit(ctl As IRibbonControl)
'   Selection.Paragraphs.Hyphenation = True
'End Sub
'
'Public Sub OrddelIkkeAfsnit(ctl As IRibbonControl)
'   Selection.Paragraphs.Hyphenation = False
'End Sub
'
'Sub MarkupText(ctr As IRibbonControl)
'Dim lColor As Long
'
'   'Values of lColor is:
'   '0 = No color
'   '7 = Yellow
'   lColor = CLng(ctr.Tag)
'
'   Options.DefaultHighlightColorIndex = lColor
'   Selection.Range.HighlightColorIndex = lColor
'
'End Sub
'
'
Attribute VB_Name = "modShapes"
Sub AnchorLock(oCtl As IRibbonControl)
Dim shp As Shape
Dim rng As Range
Dim bLock As Boolean

bLock = CBool(oCtl.Tag)

Set rng = Selection.Range

For Each shp In rng.ShapeRange
    shp.LockAnchor = bLock
Next

End Sub
Attribute VB_Name = "modTable"
Option Explicit

Public objXL As Excel.Application
Public sTableBookmarkName As String

Public Const blnScreenUpdating As Boolean = False
Public Const blnHandlePrintTitles As Boolean = False
Public Const DEFAULTTABLEWIDTH As Single = 16
Public Const ONECOLUMNTABLEWIDTH As Single = 7.5
Public Const TWOCOLUMNTABLEWIDTH As Single = 13.6
Public Const THREECOLUMNTABLEWIDTH As Single = 20.65

Public blWrapAroundText As Boolean
Public p_TablePosition As WdRelativeHorizontalPosition

Public snTabelBredde As Single
Public lNumColumns As Long

Public blUpdateOnlyNumbers As Boolean

Public Enum KolonneBredde
    NoteTal = 0.9
    Note = 1.05
    TalSmal = 1.6
    tal = 2.3
    talbred = 3
    'TalXBred = 1.8
    Tekst = 7.25
    TekstSmal = 1.5
End Enum

Public Enum KolonneType
    Spacer = 1
    Note = 2
    tal = 3
    Tekst = 4
    SmalTekst = 5
    talbred = 6
    TalXBred = 7
    TalSmal = 8
End Enum

Public Enum CelleType
    tal = 1
    TalFarvet = 2
    TalHvid = 3
    TalFed = 4
    TalSum = 5
    TalSumFarvet = 6
    TalSumHvid = 7
    Tekst = 8
    TekstSum = 9
    TekstKursiv = 10
    Unknown = 11
    Overskrift1 = 12
    ColumnTitle = 13
    ColumnTitleLeft = 14
    TekstCenter = 15
    TekstSumCenter = 16
    ColumnTitleCenter = 17
    ColumnTitleModerselskab = 18
    ColumnTitleKoncern = 19
    ColumnTitleSmall = 20
    ColumnTitleSmallLeft = 21
    TalGr|fffd| = 22
    Note = 23
    NoteColumnTekst = 24
    NoteColumnTekstLeft = 25
    NoteColumnNum = 26
    NoteColumnCenter = 27
    NoteTitleText = 28
    NoteTitleNum = 29
    NoteTextBold = 30
    NoteText = 31
    NoteTextSum = 32
    NoteTextSmall = 33
    NoteNum = 34
    NoteNumSum = 35
    ColumnCurrentYear = 36
    NoteColumnCurrentYear = 37
    Tekstfarvet = 38
    
End Enum

Public Const strPrintTitles As String = "Udskriftstitler"
Public Const strPrintArea As String = "Udskriftsomr|fffd|de"

'**** PASTEXL

'HER STARTER FUNKTIONEN PASTE


Sub PasteXlRegnskabsTable(Optional preSelection As Excel.Range, Optional sTblType As String)

   'For at optimere performance
   Options.CheckSpellingAsYouType = False
   Options.CheckGrammarAsYouType = False

   Dim timestart
   Dim timeend
   Dim sErrorSection As String

   timestart = Time
   
   Debug.Print "Start : " & Time

   Dim rngPaste As Range
   Dim tbl As Table
   Dim col As Column
   Dim rw As Row
   Dim c As Cell
   Dim xlcol
   Dim xlC
   
   
   Dim iTest As Integer
'   iTest = TestExcelConnection
'   If iTest <> 0 Then
'      GoTo NoExcelConnectionError
'   End If
   
    
'Nurse XL start
    
   On Error GoTo NoExcelConnectionError:
   'Hent nuv|fffd|rende XL objekt
   'Hav KUN |fffd|n XL fil |fffd|ben
   If IsEmpty(objXL) Then
      Set objXL = GetObject(, "Excel.Application")
   ElseIf objXL Is Nothing Then
      Set objXL = GetObject(, "Excel.Application")
   End If
      
      
   On Error GoTo ErrHandler

   objXL.ScreenUpdating = blnScreenUpdating
   
   
   Dim activeWB As Excel.Workbook
'      Dim pasteWB
   Dim activeSH As Excel.Worksheet
   Dim activeSelection As Excel.Range
   
   Set activeWB = objXL.ActiveWorkbook
   

'<MAC 10/9-2014>
   If Len(sTableBookmarkName) > 0 Then
      Dim bSucces As Boolean
      SelectRangeByName sTableBookmarkName, activeWB, bSucces
      If Not bSucces Then
         MsgBox "This table cannot be updated due to a range mismatch in Excel. On Page " & Selection.Information(wdActiveEndPageNumber) & ", Insert the range from Excel by using the PasteXL button"
         'ActiveDocument.Bookmarks(sTableBookmarkName).Delete
         ufMessage.cmdClose.Enabled = True
         DoEvents
         GoTo ExitHere
      End If
   End If
'</MAC 10/9-2014>
   
   sErrorSection = "Nurse Excel table."
   
If Not blUpdateOnlyNumbers Then
   
   'Hvis man st|fffd|r i en tabel, s|fffd| foruds|fffd|ttes det at man |fffd|nsker at repaste den
   If Selection.Tables.Count = 1 Then
      Selection.Tables(1).Delete
   End If

   If Selection.Fields.Count = 1 Then
      Selection.Fields(1).Delete
   End If
    
   Selection.Collapse wdCollapseStart
   Set rngPaste = Selection.Range
End If
        
   If preSelection Is Nothing Then
      Set activeSelection = objXL.Selection
   Else
      activeSelection = preSelection.Select
   End If
        
'<MAC 10/9-2014>
      If Len(sTableBookmarkName) = 0 Then
         sTableBookmarkName = GetRangeName(activeWB, sTblType)
      Else
         If LCase(Right(sTableBookmarkName, 5)) = "_note" Then
            sTblType = "Note"
         End If
      End If
'</MAC 10/9-2014>
      
      Dim strActiveSheet As String
      strActiveSheet = objXL.ActiveSheet.Name
      Set activeSH = activeWB.sheets(strActiveSheet)

      'H|fffd|ndter printtitles
      Dim rngTitles
      Set rngTitles = Nothing
      If activeSH.PageSetup.PrintTitleRows <> "" Then
         Dim iColumnStart As Integer
         Dim iColumnEnd As Integer
         iColumnStart = InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", Mid(objXL.Selection.Columns(1).entirecolumn.Address, 2, 1))
         iColumnEnd = InStr(1, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", Mid(objXL.Selection.Columns(objXL.Selection.Columns.Count).entirecolumn.Address, 2, 1))
         
         Set rngTitles = objXL.Range(activeSH.Range(ReturnPrintTitlesLocalLanguage).Columns(iColumnStart).Cells(2), _
            activeSH.Range(ReturnPrintTitlesLocalLanguage).Columns(iColumnEnd).Cells(activeSH.Range(ReturnPrintTitlesLocalLanguage).Columns(iColumnEnd).Cells.Count))
          
      End If
        
        
        Dim objSheet As Excel.Worksheet
        Set objSheet = activeWB.sheets.Add(After:=activeWB.sheets(activeWB.sheets.Count))
        
        objSheet.Name = "Paste"
        
        objSheet.Cells.Clear
        objSheet.Columns.columnwidth = 12

        activeWB.Activate
        activeWB.sheets(strActiveSheet).Select
        
        objXL.cutcopymode = False
        
        's|fffd|rg for at kolonner i paste arket har samme kolonnebredde som source arket
        Dim iColCount As Integer
        For Each xlcol In objXL.Selection.Columns
            iColCount = iColCount + 1
            objSheet.Columns(iColCount).columnwidth = xlcol.columnwidth
        Next
        
ClipboardEmptyTryAgain:
        If blnHandlePrintTitles Then
            If Not rngTitles Is Nothing Then
                rngTitles.Copy
            
                objSheet.Select
                objSheet.Range("A1").Select
                
                objXL.Selection.PasteSpecial -4163, -4142, False, False
                objXL.Selection.PasteSpecial Paste:=-4122, Operation:=-4142, SkipBlanks:=False, Transpose:=False
            
                objXL.cutcopymode = False
            End If
        End If
        
        activeSH.Activate
        
        
        objXL.Selection.Copy
        
        objSheet.Select
        
        If Not rngTitles Is Nothing Then
            objSheet.Range("A1").offset(rngTitles.Rows.Count, 0).Select
        Else
            objSheet.Range("A1").Select
        End If
        
        objXL.Selection.PasteSpecial -4163, -4142, False, False
        objXL.Selection.PasteSpecial Paste:=-4122, Operation:=-4142, SkipBlanks:=False, Transpose:=False
    
        objXL.cutcopymode = False
        
        Dim rngPasteRange
        Set rngPasteRange = objXL.Selection
        
        Dim i As Integer
        
        'slet skjulte r|fffd|kker
        For i = activeSelection.Rows.Count To 1 Step -1
            If activeSelection.Rows(i).Hidden = True Then
                rngPasteRange.Rows(i).entirerow.Delete
            End If
        Next
        
        'slet skjulte kolonner
        For i = activeSelection.Columns.Count To 1 Step -1
            If activeSelection.Columns(i).Hidden = True Then
                rngPasteRange.Columns(i).entirecolumn.Delete
            End If
        Next
        
        'Slet allerede her smalle kolonner s|fffd| bliver resten af processen nemlig hurtig
        For Each xlcol In objSheet.UsedRange.Columns
            'Debug.Print xlcol.columnwidth
            If xlcol.columnwidth < 0.55 Then
                xlcol.entirecolumn.Delete
            ElseIf xlcol.columnwidth < 5 Then
                xlcol.columnwidth = 5
            End If
        Next
        
        'Slet allerede her smalle kolonner s|fffd| bliver resten af processen nemlig hurtig
        For Each xlcol In objSheet.UsedRange.Columns
            'Debug.Print xlcol.columnwidth
            If xlcol.columnwidth < 5 Then
                xlcol.columnwidth = 5
            End If
        Next
        
                
   If Not blUpdateOnlyNumbers Then
      Dim iColorIndex As Integer
      iColorIndex = 13
      's|fffd|t farve p|fffd| mergede celler
      For Each xlC In objSheet.UsedRange.Cells
          'xl'c.select
          If xlC.Orientation = -4171 Then
              xlC.Font.ColorIndex = 54
          End If
          
          If xlC.MergeCells = True Then
              xlC.Font.ColorIndex = iColorIndex
          End If
      Next
      
      'unmerge alle celler
      objSheet.UsedRange.MergeCells = False
   End If
        
        's|fffd|rg for at alle celler har indhold (tomme celler = |fffd|) pga. paste bug i Word
        For Each xlC In objSheet.UsedRange.Cells
            If xlC.Formula = "" Then
                xlC.Value = "|fffd|"
            End If
        Next
                
        objXL.ScreenUpdating = True
        
    'saml kolonnebredderne op fra XL
    Dim colExcelTableColumnWidths As New Collection
    For Each xlcol In objSheet.UsedRange.Columns
        colExcelTableColumnWidths.Add (xlcol.columnwidth * 6.18438761776581)
    Next
    
    'kopier tabellen fra XL
    objSheet.UsedRange.Copy
    

    'Nurse XL end
        
    sErrorSection = "Paste table into Word."
        
    Dim tblPaste As Table
    
    'paste ind i Word
    If Selection.Tables.Count = 0 Then
        rngPaste.PasteExcelTable False, False, False
        'rngPaste.Paste
    End If
    
    'placer cursoren i den indpastede tabel - OBS her kan den fejle sommetider.
    If Selection.Tables.Count > 0 Then
        Set tblPaste = Selection.Tables(1)
    Else
        Selection.MoveDown wdLine
        Set tblPaste = Selection.Tables(1)
    End If
    
    Debug.Print "Nurse XL: " & Time
    
   'L|fffd|s Word
   LockWord ActiveDocument
    
   'Style match
    
   Dim xlCell As Excel.Range
   Dim xlCellNext As Excel.Range
   Dim oWdCell As Cell
   Dim lRow As Long
   Dim lColumn As Long
   Dim sCellStyle As String
   Dim lCellColor As Long
   Dim sNegative As String
   
   Dim lCountRow As Long
   Dim lCountColumn As Long

   Dim borderType As Variant
   Dim k As Integer
   
   Dim iWordMerged As Integer
   Dim iCountMerged As Integer
   Dim blMergedCells As Boolean
   
   borderType = Array(wdBorderTop, wdBorderLeft, wdBorderBottom, wdBorderRight)
    

   lCountRow = objSheet.UsedRange.Rows.Count
   lCountColumn = objSheet.UsedRange.Columns.Count
      
   sErrorSection = "Finding styles."
      
   For lRow = 1 To lCountRow
      iWordMerged = 0
      iCountMerged = 0
      blMergedCells = False
      
      For lColumn = 1 To lCountColumn
         'Set xlCell = objSheet.usedrange.Rows(1)
         Set xlCell = objSheet.UsedRange.Cells(lRow, lColumn)
         
         'Set xlCellNext = objSheet.UsedRange.Cells(lRow, lColumn + 1) 'tjek at next findes TODO
         
         sCellStyle = xlCell.Style.Name
         lCellColor = xlCell.Font.Color
         If Not IsError(xlCell) Then
            If IsNumeric(Trim(xlCell.Value)) Then
               If CLng(Trim(xlCell.Value)) < 0 Then
                  sNegative = " - Negative"
               End If
            End If
         End If
         If Not StyleExists(sCellStyle) Then
            Debug.Print sCellStyle
            sCellStyle = "Normal"
         End If
         
         If Not blUpdateOnlyNumbers Then
            Set oWdCell = tblPaste.Cell(lRow, lColumn)
            oWdCell.Range.Style = sCellStyle ' & sNegative
            
            If lCellColor = wdColorViolet Then
               oWdCell.Range.Font.Color = wdColorViolet
            End If
         Else
            Set oWdCell = tblPaste.Cell(lRow, lColumn - iWordMerged)
            
            If xlCell.MergeCells Then
               iCountMerged = iCountMerged + 1
               If iCountMerged = 1 Then
                  oWdCell.Range.Text = xlCell.Value
               End If
               'iWordMerged = lColumn - xlCell.MergeArea.Count
               If iCountMerged - xlCell.MergeArea.Count = 0 Then
                  iCountMerged = 0
               Else
                  iWordMerged = iWordMerged + 1
               End If
            Else
               oWdCell.Range.Text = xlCell.Value
            End If
            oWdCell.Range.Style = sCellStyle ' & sNegative
         End If
                  
         sNegative = ""
      Next lColumn
      'Borders
      
      For k = 0 To 2 Step 2
          With tblPaste.Rows(lRow).Borders(borderType(k))
              If .Visible = True And .LineWidth = wdLineWidth100pt Then
                  .Color = RGB(128, 128, 128)
                  .LineWidth = wdLineWidth150pt
              End If
          End With
      Next
      
   Next lRow
    
   Debug.Print "Style match: " & Time
    
   sErrorSection = "Close Excel and cleanup."
   
   'ryd op og luk XL
   objSheet.Range("A1").Select
   objXL.Selection.Copy
   objXL.cutcopymode = False
   objXL.DisplayAlerts = False
   objSheet.Delete
   objXL.DisplayAlerts = True
'   pasteWB.Saved = True
'   pasteWB.Close 2
   
   activeWB.Activate
   objXL.sheets(strActiveSheet).Select
   objXL.cutcopymode = False
   
   If bShowProgress Then
      ufMessage.KeepLoaded = True
      DoEvents
   End If
   
   Application.ScreenUpdating = blnScreenUpdating
   
   If blUpdateOnlyNumbers Then GoTo ExitHere
   
   sErrorSection = "Cleanup table."
   
    'Stop
    
    '1. Grov oprydning af tabellen
    
    'Selection.Orientation = wdTextOrientationDownward
    
    'nulstil r|fffd|kkeh|fffd|jder
    tblPaste.Rows.HeightRule = wdRowHeightAuto
    'tblPaste.Rows.Height = CentimetersToPoints(0.3)
    
    's|fffd|t vertikal alignment i celler - OBS kan evt. ikke passe for alle kunder
    tblPaste.Range.Cells.VerticalAlignment = wdCellAlignVerticalBottom

    'yderligere tabelnulstilling
   With tblPaste
      .TopPadding = CentimetersToPoints(0)
      .BottomPadding = CentimetersToPoints(0)
      'OBS skal dette ogs|fffd| g|fffd|lde for kunden?
      .LeftPadding = CentimetersToPoints(0)
      If InStr(sTblType, "Note") > 0 Then
       .RightPadding = CentimetersToPoints(0)
      Else
       .RightPadding = CentimetersToPoints(0)
      End If
      .Spacing = 0
      .AllowPageBreaks = True
      .AllowAutoFit = False
      
      .Rows.WrapAroundText = blWrapAroundText
      If blWrapAroundText Then
         .Rows.HorizontalPosition = wdTableLeft
         .Rows.RelativeHorizontalPosition = p_TablePosition
         .Rows.DistanceLeft = CentimetersToPoints(0.25)
         .Rows.DistanceRight = CentimetersToPoints(0.25)
         .Rows.VerticalPosition = CentimetersToPoints(0)
         .Rows.RelativeVerticalPosition = wdRelativeVerticalPositionParagraph
         .Rows.DistanceTop = CentimetersToPoints(0)
         .Rows.DistanceBottom = CentimetersToPoints(0)
         .Rows.AllowOverlap = False
      End If
   End With
    
    'modsvar leftpadding.
'   If InStr(sTblType, "Note") > 0 Then
'      tblPaste.Rows.LeftIndent = CentimetersToPoints(0)
'   Else
'      tblPaste.Rows.LeftIndent = CentimetersToPoints(0)
'   End If
    tblPaste.Rows.LeftIndent = CentimetersToPoints(0)
    'Slet alle |fffd| i tabellen
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find
        .Text = "|fffd|"
        .Replacement.Text = ""
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
  
    'slet overskydende mellemrum i h|fffd|jrestillede celler (modsvar paste bug)
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find
        .Text = "   "
        .Replacement.Text = ""
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
    
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find
        .Text = "######"
        .Replacement.Text = "    "
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
    
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find
        .Text = "###"
        .Replacement.Text = "  "
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
    
    
    
   'Fix paste as HTML columnwidth bug
   tblPaste.PreferredWidthType = wdPreferredWidthAuto
   tblPaste.PreferredWidth = 0
   
   
   Dim iColumnCountExcel As Integer
   For Each col In tblPaste.Columns
       iColumnCountExcel = iColumnCountExcel + 1
       col.Width = colExcelTableColumnWidths(iColumnCountExcel)
   Next
   
   Debug.Print "Grov oprydning af tabellen: " & Time
   
   sErrorSection = "Adjusting columns."

   Dim iTekstColumnCount As Integer
   
    
   'Kolonneformatering
   For Each col In tblPaste.Columns
        
      'Kolonnebredde
      'col.Select
      'OBS ColumnType skal kodes for hver kunde
      Select Case ColumnType(col)
      Case KolonneType.Spacer
         col.Width = CentimetersToPoints(0.8)
      Case KolonneType.Note
         col.Width = CentimetersToPoints(1.4)
      Case KolonneType.TalSmal
         col.Width = CentimetersToPoints(1.6)
      Case KolonneType.tal
         col.Width = CentimetersToPoints(2.3)
      Case KolonneType.talbred
         col.Width = CentimetersToPoints(3)
      Case KolonneType.Tekst
   '            col.Width = CentimetersToPoints(7.25) '205,5118
      End Select
   
      '    'Tjek om der er data i kolonnen
      '    For Each col In tblPaste.Columns
       Dim blnHasValues As Boolean
       blnHasValues = False
      ' col.Select
       For Each c In col.Cells
           'c.Select
           If Len(Trim(c.Range.Text)) > 2 Then
               blnHasValues = True
               Exit For
           End If
       Next
      
       If Not blnHasValues Then
           col.Delete
       End If
         
   Next
    
    'slet SPACER ordet der kan v|fffd|re brugt til at undg|fffd| at en "tom" kolonne slettes
    tblPaste.Select
    
    '<MAC: 11/9-2014>
    Selection.Bookmarks.Add sTableBookmarkName, Selection.Range
    '</MAC: 11/9-2014>
    
    Selection.Find.ClearFormatting
    Selection.Find.Replacement.ClearFormatting
    With Selection.Find
        .Text = "spacer"
        .Replacement.Text = ""
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    Selection.Find.Execute Replace:=wdReplaceAll
    
   Dim sTableWidth As Single
   't|fffd|l antal talkolonner
   For Each col In tblPaste.Columns
       sTableWidth = sTableWidth + PointsToCentimeters(col.Width)
   Next
    
   Dim blnTekstKolonneFound As Boolean
    
    For Each col In tblPaste.Columns
        If col.Width > CentimetersToPoints(2.5) Then
            'tekstkolonne
            col.Width = col.Width + CentimetersToPoints(snTabelBredde - sTableWidth)
            blnTekstKolonneFound = True
            Exit For
        End If
    Next
    
    Debug.Print "Kolonneformatering: " & Time
    
    'OBS MULIG FEJLKILDE HVIS TEKSTKOLONNE IKKE IDENTIFICERES RIGTIGT
    'Find tekstkolonnen og tilret residual bredden p|fffd| den
    Dim snWidestColumn As Single
    Dim snTotalWidth As Single
    Dim iWidestColumnIndex As Integer
    For Each col In tblPaste.Columns
      snTotalWidth = snTotalWidth + col.Width
      If col.Width > snWidestColumn Then
         snWidestColumn = col.Width
         iWidestColumnIndex = col.Index
      End If
    Next
    
    If iTekstColumnCount < 2 Then
        tblPaste.Columns(iWidestColumnIndex).Width = tblPaste.Columns(iWidestColumnIndex).Width + (CentimetersToPoints(snTabelBredde) - snTotalWidth)
    End If
    
    'H|fffd|ndter at visse tabeller kun har 3 kolonner, hvor den f|fffd|rste er tekstkolonne, men fejlagtigt
    'anses for at v|fffd|re talkolonne
    
    If tblPaste.Columns.Count = 3 And tblPaste.Columns(1).Width < CentimetersToPoints(3) Then
        tblPaste.Columns(1).Width = tblPaste.Columns(1).Width + CentimetersToPoints(snTabelBredde - sTableWidth)
        blnTekstKolonneFound = True
    End If
    
    'Hvis der kun er |fffd|n kolonne, s|fffd| skal dette v|fffd|re en tekstkolonne
    If tblPaste.Columns.Count = 1 Then
        tblPaste.Columns.Width = CentimetersToPoints(snTabelBredde)
        blnTekstKolonneFound = True
    End If

   sErrorSection = "Merging cells."
    
    'Merge Celler
    Dim iMergeStart As Integer
    Dim iMergeEnd As Integer
    Dim iMergeCell As Integer
    Dim sMergeStyle As String
    
    For Each rw In tblPaste.Rows
        iMergeStart = 0
        iMergeEnd = 0
        iMergeCell = 0
        For Each c In rw.Cells
            sMergeStyle = c.Range.Style
            c.Select
            iMergeCell = iMergeCell + 1
            'If c.Shading.ForegroundPatternColor = wdColorPlum Then
            If c.Range.Font.Color = wdColorViolet And Len(c.Range.Text) > 2 And iMergeStart = 0 Then
                'If iMergeStart = 0 Then
                    iMergeStart = iMergeCell
                'Else
                '    iMergeEnd = iMergeCell
                'End If
                c.Range.Style = wdStyleNormal
                c.Range.Style = ActiveDocument.Styles(sMergeStyle)
            ElseIf c.Range.Font.Color = wdColorViolet And Len(Trim(c.Range.Text)) <= 3 Then
                iMergeEnd = iMergeCell
                c.Range.Style = wdStyleNormal
                c.Range.Style = ActiveDocument.Styles(sMergeStyle)
            Else
                On Error Resume Next
                If iMergeStart <> 0 Then
                    rw.Cells(iMergeStart).Select
                    Selection.MoveRight unit:=wdCharacter, Count:=iMergeEnd - iMergeStart, Extend:=wdExtend
                    If Selection.Cells.Count > 1 Then
                        Selection.Cells.Merge
                        iMergeCell = iMergeCell - (iMergeEnd - iMergeStart)
                    End If
                End If
                If c.Range.Font.Color = wdColorViolet And Len(c.Range.Text) > 2 And iMergeStart > 0 Then
                    iMergeStart = iMergeCell
                c.Range.Style = wdStyleNormal
                c.Range.Style = ActiveDocument.Styles(sMergeStyle)
                Else
                    iMergeStart = 0
                End If
                
            End If
        Next
                On Error Resume Next
                If iMergeStart <> 0 Then
                    rw.Cells(iMergeStart).Select
                    Selection.MoveRight unit:=wdCharacter, Count:=iMergeEnd - iMergeStart, Extend:=wdExtend
                    Selection.Cells.Merge
                End If
                iMergeStart = 0
    Next
    
    Debug.Print "Merge Celler : " & Time
    
    sErrorSection = "Finishing up."
    
'    tblPaste.Rows(1).Borders(wdBorderRight).LineStyle = wdLineStyleNone
    
    'Styles
    For Each rw In tblPaste.Rows
        'debug.print "Rowstart: " & Now()
        'rw.Select
        For Each c In rw.Cells
            'debug.print , "Cellstart: " & Now()
            'c.select
            Application.ScreenUpdating = False

'            pTimeStartApplyStyle = Time
            
            'MODVIRK BUG - L|fffd|G TO MELLEMRUMSTEGN I TOMME CELLE
            If Len(c.Range.Text) = 2 Then
                c.Range.Text = "  "
            End If
            

        Next
    Next
    
    tblPaste.Rows.Last.Cells(tblPaste.Rows.Last.Cells.Count).Select
    
    
    Application.ScreenRefresh
    Application.ScreenUpdating = True

    objXL.ScreenUpdating = True
    DeleteSheet objXL, "Paste"
    'Set objXL = Nothing
    
    
    
    
    Options.CheckSpellingAsYouType = True

ExitHere:
   timeend = Time
   Debug.Print timestart & " " & timeend
   
   DeleteSheet objXL, "Paste"
   
   On Error Resume Next
   
   objXL.ScreenUpdating = True
   Set objXL = Nothing
   Exit Sub
    
NoExcelConnectionError:
   Select Case iTest
      Case -1
         ufMessage.cmdClose.Enabled = True
         MsgBox "Could not connect to Excel.", vbExclamation, "PasteXL Excel Connection"
         DoEvents
      Case -2
         ufMessage.cmdClose.Enabled = True
         MsgBox "Make sure that only one Excel workbook is open when using PasteXL.", vbExclamation, "PasteXL Excel Connection"
         DoEvents
   End Select
      GoTo ExitHere
    
ErrHandler:
   'Resume Next
   ufMessage.cmdClose.Enabled = True
   DoEvents
   MsgBox "An error has occured in 'modTable.PasteXlRegnskabsTable', section: '" & sErrorSection & "'. Error number: " & Err.Number & "; Error Description: " & Err.Description, vbCritical, "PasteXL Error"
   If Err.Number = 4605 Then ' clipboard is empty or not valid.
      DoEvents
      Resume ClipboardEmptyTryAgain
   Else
      GoTo ExitHere
   End If
   
End Sub

Function ColumnType(col As Column) As Integer
   '
   'OBS KUNDESPECIFIK
   '
   'XL bredde - WD bredde
   ' 8 - 1.75 (9 - 1.96)
   ' 12 - 2.62 (13 - 2.84)
   ' 15 - 3.28 (16 - 3.49)
   ' Text - +9
   
    
    Dim sColWidth As Single
    sColWidth = PointsToCentimeters(col.Width)
   
   If sColWidth < 1.3 And InStr(UCase(col.Cells(1)), "SPACER") Then
      ColumnType = KolonneType.Spacer
   ElseIf sColWidth < 1.6 Then
      ColumnType = KolonneType.Note
   ElseIf sColWidth < 2 Then
      ColumnType = KolonneType.TalSmal
   ElseIf sColWidth < 3 Then
      ColumnType = KolonneType.tal
   ElseIf sColWidth < 4 Then
      ColumnType = KolonneType.talbred
   ElseIf sColWidth > 3 Then
       ColumnType = KolonneType.Tekst
   End If

End Function


Sub SetTableHeight()

    Dim tbl As Table
    Set tbl = Selection.Tables(1)
    Dim rw As Row
    Dim c As Cell
    Dim rng As Range
    
    Set rw = tbl.Rows.Last
    Set c = rw.Cells(1)
    Set rng = c.Range
    c.VerticalAlignment = wdCellAlignVerticalBottom
    Dim sRowPosition As Single
    
    sRowPosition = rng.Information(wdVerticalPositionRelativeToPage)
    
    rw.Height = CentimetersToPoints(27.2) - sRowPosition

End Sub


Sub SetAllTableHeights()
   '
   Dim tbl As Table
   
    For Each tbl In ActiveDocument.Tables
        If tbl.Rows(1).Cells(1).Range.Style = "Overskrift 1 - 4 sektion TAL" Then
            tbl.Select
            SetTableHeight
        End If
    Next

End Sub


'Sub MergeSomeCells()
'
'    Dim tbl As Table
'    Set tbl = Selection.Tables(1)
'
'    Dim rw As Row
'    Dim c As Cell
'
'    Dim iMergeStart As Integer
'    Dim iMergeEnd As Integer
'    Dim iMergeCell As Integer
'
'    For Each rw In tblPaste.Rows
'        iMergeStart = 0
'        iMergeEnd = 0
'        iMergeCell = 0
'        For Each c In rw.Cells
'            'c.select
'            iMergeCell = iMergeCell + 1
'            If c.Shading.ForegroundPatternColor = wdColorPlum Then
'                If iMergeStart = 0 Then
'                    iMergeStart = iMergeCell
'                Else
'                    iMergeEnd = iMergeCell
'                End If
'            End If
'        Next
'        On Error Resume Next
'        If iMergeStart <> 0 Then
'            rw.Cells(iMergeStart).Select
'            Selection.MoveRight Unit:=wdCharacter, Count:=iMergeEnd - iMergeStart, Extend:=wdExtend
'            Selection.Cells.Merge
'        End If
'    Next
'
'End Sub


'Sub NurseExcelCopyArea()
'
'
'    Dim objXL
'    Set objXL = GetObject(, "Excel.Application")
'
''    objXL.sheets("Paste").Select
'    objXL.sheets("Paste").Cells.Clear
'    objXL.sheets("Paste").Columns.columnwidth = 12
'
''    objXL.sheets("Paste").Cells.Select
''   objXL.Selection.Clear
'
''    objXL.Selection.ColumnWidth = 12
'
''    objXL.sheets("Paste").usedrange.Clear
''    objXL.sheets("Paste").usedrange.Columns.ColumnWidth = 12
'
'    objXL.cutcopymode = False
'    objXL.Selection.MergeCells = False
'
'    Dim iColCount As Integer
'    For Each col In objXL.Selection.Columns
'        iColCount = iColCount + 1
'        objXL.sheets("Paste").Columns(iColCount).columnwidth = col.columnwidth
'    Next
'
'
'    objXL.Selection.Copy
'
'    objXL.sheets("Paste").Select
'    objXL.sheets("Paste").Range("A1").Select
'
'    objXL.Selection.PasteSpecial -4163, -4142, False, False
'    objXL.Selection.PasteSpecial Paste:=-4122, Operation:=-4142, SkipBlanks:=False, Transpose:=False
'
'    objXL.cutcopymode = False
'
'    For Each c In objXL.sheets("Paste").UsedRange.Cells
'        If c.Formula = "" Then
'            c.Value = "|fffd|"
'        End If
'    Next
'
'    objXL.sheets("Paste").UsedRange.Copy
'
'    Set objXL = Nothing
'End Sub
'
'Sub HvidKolonne()
'    Dim c As Cell
'    For Each c In Selection.Cells
'        If c.Shading.ForegroundPatternColor <> iColorSumOliven Then
'            c.Shading.ForegroundPatternColor = wdColorWhite
'        End If
'    Next
'End Sub
'
'Sub FarvetKolonne()
'    Dim c As Cell
'    For Each c In Selection.Cells
'        If c.Shading.ForegroundPatternColor <> iColorSumOliven Then
'            c.Shading.ForegroundPatternColor = iColorLysOliven
'        End If
'    Next
'End Sub
'
'Sub SumLinie()
'    Dim c As Cell
'    For Each c In Selection.Rows(1).Cells
'        c.Shading.ForegroundPatternColor = CellInteriorColorType.SumLinie
'        If c.Width < 50 Then
'            c.Range.Style = "Normal - TalTabel TalSum"
'        Else
'            c.Range.Style = "Normal - TalTabel TekstSum"
'        End If
'    Next
'End Sub
'
'Sub AlmLinie()
'    Dim c As Cell
'    For Each c In Selection.Rows(1).Cells
'
'        Dim iAboveBelowColor As Double
'        iAboveBelowColor = CellBelowColor(c)
'
'        If iAboveBelowColor = 0 Then
'            iAboveBelowColor = CellAboveColor(c)
'        End If
'
'        If iAboveBelowColor <> 0 Then
'            c.Shading.ForegroundPatternColor = iAboveBelowColor
'        End If
'
'        If c.Width < 50 Then
'            c.Range.Style = "Normal - TalTabel Tal"
'        Else
'            c.Range.Style = "Normal - TalTabel Tekst"
'        End If
'    Next
'End Sub
'
'Function CellBelowColor(c As Cell) As Double
'    On Error GoTo errorhandler
'    Dim iRowIndex As Integer
'    Dim iColumnIndex As Integer
'    Dim CellBelow As Cell
'    'c.select
'    iRowIndex = c.RowIndex + 1
'    iColumnIndex = c.ColumnIndex
'    Set CellBelow = Selection.Tables(1).Cell(iRowIndex, iColumnIndex)
'    CellBelowColor = CellBelow.Shading.ForegroundPatternColor
'    Debug.Print CellBelowColor
'    Exit Function
'errorhandler:
'    RowBelowColor = 0
'End Function
'
'Function CellAboveColor(c As Cell) As Double
'    On Error GoTo errorhandler
'    Dim iRowIndex As Integer
'    Dim iColumnIndex As Integer
'    Dim CellAbove As Cell
'    'c.select
'    iRowIndex = c.RowIndex - 1
'    iColumnIndex = c.ColumnIndex
'    Set CellAbove = Selection.Tables(1).Cell(iRowIndex, iColumnIndex)
'    CellAboveColor = CellAbove.Shading.ForegroundPatternColor
'    Debug.Print CellAboveColor
'    Exit Function
'errorhandler:
'    RowAboveColor = 0
'End Function


Sub TabelStreg()

End Sub
Sub DeleteSheet(objApp As Excel.Application, strSheetName As String)

    On Error Resume Next
    objApp.DisplayAlerts = False
    objApp.sheets(strSheetName).Delete
    objApp.DisplayAlerts = True

End Sub

'Function IsRangeInRange(objApp, rng1, rng2) As Boolean
'    Set isect = objApp.Intersect(rng1, rng2)
'    If Not isect Is Nothing Then
'        IsRangeInRange = True
'    End If
'End Function
'
'
'Sub PastePageByPage()
'
'
'    Application.StatusBar = "Starting"
'
'    Dim rng
'    Dim strAddresses() As String
'
'    Set objXL = GetObject(, "Excel.Application")
'
'    Dim strActiveSheet As String
'    strActiveSheet = objXL.ActiveSheet.Name
'
'    Dim activeWB
'    Dim pasteWB
'    Dim activeSH
'    Dim activeSelection
'
'    Set activeWB = objXL.ActiveWorkbook
'
'
'    Set activeSH = activeWB.sheets(strActiveSheet)
'    Set activeSelection = objXL.Selection
'
'    strAddresses = ReturnPageByPage(activeSH)
'
'    For i = 0 To UBound(strAddresses)
'        If i = 0 Then
'            Dim rngTitles
'            Set rng = objXL.Range(strAddresses(i))
'            If activeSH.PageSetup.PrintTitleRows <> "" Then
'                Set rngTitles = activeSH.Range(ReturnPrintTitlesLocalLanguage)
'                Set rng = objXL.Range(rng.Rows(rngTitles.Rows.Count + 1), _
'                    rng.Rows(rng.Rows.Count))
'            End If
'            rng.Select
'
'        Else
'            Set rng = objXL.Range(strAddresses(i))
'            rng.Select
'        End If
'
'        PasteXlRegnskabsTable
'
'        Application.StatusBar = "Done: Page " & i & " " & strAddresses(i)
'
'        Selection.MoveDown Unit:=wdLine, Count:=1
'        Selection.TypeParagraph
'
'    Next
'
'
'    Application.StatusBar = "Finished " & i & "pages"
'    Set objXL = Nothing
'    Debug.Print "Done"
'    Debug.Print
'End Sub
'
'Function ReturnPageByPage(sh) As String()
'    Dim iCount As Integer
'    Dim pb 'As HPageBreak
'
'    Dim rngPrintArea 'As Range
'
'    Dim rngPageStart 'As Range
'    Dim rngPageEnd 'As Range
'
'    Dim iNumColumns As Integer
'    Dim iNumRows As Integer
'
'    Dim strAddresses() As String
'    'sh.Select
'
'    Set rngPrintArea = objXL.Range(ReturnPrintAreaLocalLanguage)
'    iNumColumns = rngPrintArea.Columns.Count
'    iNumRows = rngPrintArea.Rows.Count
'
'    Set rngPageStart = rngPrintArea.Rows(1)
'
'    For Each pb In sh.HPageBreaks
'        Set rngPageEnd = rngPrintArea.Rows(pb.Location.Row - 1) 'objXL.Range(pb.Location.offset(-1, 0), pb.Location.offset(-1, iNumColumns - 1))
'         'Set rngPageEnd = objXL.Range(pb.Location.offset(-1, 0), pb.Location.offset(-1, iNumColumns - 1))
'
'        ReDim Preserve strAddresses(iCount) As String
'        strAddresses(iCount) = objXL.Range(rngPageStart, rngPageEnd).Address
'        Debug.Print strAddresses(iCount)
'        Set rngPageStart = rngPrintArea.Rows(pb.Location.Row)   'objXL.Range(pb.Location, pb.Location.offset(0, iNumColumns - 1))
'        'Set rngPageStart = objXL.Range(pb.Location, pb.Location.offset(0, iNumColumns - 1))
'        iCount = iCount + 1
'    Next
'
'    Set rngPageEnd = rngPrintArea.Rows(iNumRows)
'
'    ReDim Preserve strAddresses(iCount) As String
'    strAddresses(iCount) = objXL.Range(rngPageStart, rngPageEnd).Address
'
'    ReturnPageByPage = strAddresses
'
'End Function

Function CellType(c As Cell, Optional sTbl As String) As Integer

   Dim pTimeStart
   pTimeStart = Time

   Dim sCellWidth As Single
   
   If LCase(sTbl) = "note" Then
   ' Der er klikket p|fffd| knappen Paste Excel Note
      'Kolonne Tekst
   Else
      ' Der er klikket p|fffd| knappen Paste Excel Regnskab
      c.Range.Style.Name = ""
      
      'Bold Header - 5pt
      'Bold Header - 6pt
      'Bold Header - Right - 5pt
      'Bold Header - Right - 6pt
      'Bold number - 5pt
      'Bold number - 6pt
      'Bold number - 5 pt - negative
      'Bold number - 6pt - negative
      'Bold text - 5pt
      'Bold text - 6pt
      'Decimals - 5pt
      'Decimals - 6pt
      'Decimals - 5pt - negative
      'Decimals - 6pt - negative
      'Header - Center - 5pt
      'Header - Center - 6pt
      'Header - Right - 5pt
      'Header - Right - 6pt
      'Heading 1
      'No-Number - 5pt
      'No-Number - 6pt
      'Number - 5pt
      'Number - 6pt
      'Number - 5pt - negative
      'Number - 6pt - negative
      'Percent - 5pt
      'Percent - 6pt
      'Tables/Graphs Header
      'Text - 5pt
      'Text - 6pt
      'Bottom text - 5pt
      'Bottom text - 6pt
      
      
      ' Note overskrift
      If c.RowIndex <= 3 And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Bold = True And _
         c.Range.Font.Size = 11 Then
          
         CellType = CelleType.ColumnTitleLeft
         Exit Function
      
      ' Kolonne Overskrift
      ElseIf c.RowIndex <= 3 And _
         c.Range.ParagraphFormat.Alignment = wdAlignParagraphRight And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Bold = True And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.ColumnTitle
         Exit Function
      
      ' Kolonne Overskrift venstre
      ElseIf c.RowIndex <= 3 And _
         c.Range.ParagraphFormat.Alignment = wdAlignParagraphLeft And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Bold = True And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.ColumnTitleSmallLeft
         Exit Function
      
      
      'Tekst Total
      ElseIf c.Range.ParagraphFormat.Alignment = wdAlignParagraphLeft And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Bold = True And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.TekstSum
         Exit Function
      
      'Note nummer
      ElseIf c.Range.ParagraphFormat.Alignment = wdAlignParagraphCenter And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Bold = True And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.NoteNum
         Exit Function
      
      'Tal Total
      ElseIf c.Range.ParagraphFormat.Alignment = wdAlignParagraphRight And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Bold = True And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.TalSum
         Exit Function
      
      'Tekst Kursiv
      ElseIf c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Italic = True And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.TekstKursiv
         Exit Function
      
      'Tal
      ElseIf c.Range.ParagraphFormat.Alignment = wdAlignParagraphRight And _
         c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.tal
         Exit Function
      
      'Tekst
      ElseIf c.Range.Font.Name = "Times New Roman" And _
         c.Range.Font.Size = 9 Then
          
         CellType = CelleType.Tekst
         Exit Function

      Else
         'Ikke kendt
         CellType = CelleType.Unknown
      
      End If
   End If
    
    'debug.print , , "Celltype: " & Time - pTimeStart
    
End Function

Function ReturnPrintAreaLocalLanguage() As String
    Select Case Application.Language
        Case 1030
            ReturnPrintAreaLocalLanguage = "Udskriftsomr|fffd|de"
        Case 1033
            ReturnPrintAreaLocalLanguage = "Print_Area"
    End Select
End Function

Function ReturnPrintTitlesLocalLanguage() As String
    Select Case Application.Language
        Case 1030
            ReturnPrintTitlesLocalLanguage = "Udskriftstitler"
        Case 1033
            ReturnPrintTitlesLocalLanguage = "Print_Titles"
    End Select
End Function

Sub DeletePasteXLTable()
   '
   Dim oTbl As Table
   
   If Selection.Information(wdWithInTable) Then
      Set oTbl = Selection.Tables(1)
      If oTbl.Range.Bookmarks.Count > 0 Then
         oTbl.Range.Bookmarks(1).Delete
         oTbl.Delete
      End If
   End If
   
End Sub

Attribute VB_Name = "ufMessage"
Attribute VB_Base = "0{76E5AADA-7250-4F4B-B90F-1A51B27D5ADE}{EE778C71-6605-4383-977C-2D8ABB0EA111}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit
Option Compare Binary
'
' Purpose      :  WordEngine Message Box and Input Box dialog object.
'
' Dependencies :  mDialogFunctions.bas
'                 mFormDocumentInfo.bas
'                 cForm* classes
'                 cIconLoaderEx.cls
'
' Created by   :  Jacob Sch|fffd|ffer
' Creation date:  21. december 2010       1) Added "hDC", "hWnd", "KeepLoaded" and "DialogTitle"
'                                            properties.
'                                         2) Added code to "Activate", "Initialize", "QueryClose" and
'                                            "Resize" events.
'                                         3) Added several private functions and new functionality.
'
' Remarks      :  ***************************************************************
'                 Do NOT set the UserForms Caption property. This will INVALIDATE
'                 the current hWnd. Use the DialogTitle property instead !!!
'                 ***************************************************************
'
' TODO         :  Decide what to do when the KeepLoaded property is True (currently false by default).
'                 This flag can be used to avoid a time consuming rebuild for each time the dialog
'                 is displayed.

Private Const MODULE_NAME As String = "ufMessage"
'
' For implementing hWnd and hDC properties
#If VBA7 Then
   ' 32/64-bit 2010
   Private p_hWnd As LongPtr
   Private p_HDC As LongPtr
#Else
   ' 32-bit 2007/2003
   Private p_hWnd As Long
   Private p_HDC As Long
#End If
'
' For implementing a BorderWidth property
Private p_snBorderWidth As Single
'
' Icon objects
Private p_oIcon As cIconLoaderEx
'
' Private properties
Private p_bKeepLoaded As Boolean
Private p_sDialogTitle As String
Private p_sMessageID As String

Private p_eMsgBoxButtons As enMessageBoxButtons
Private p_eMsgBoxIcon As enMessageBoxIcons
Private p_eMsgBoxResult As VbMsgBoxResult
Private p_eShowMode As FormShowConstants
Private p_bShowAvatarIcons As Boolean
'
' For InputBox mode
Private p_bIsInputBox As Boolean
Private p_snMaxHeight As Single
'

'
' New hDC property. This property is useful when we need to
' paint something on the UserForm with Windows API painting tools.
#If VBA7 Then
   ' 32/64-bit 2010
   Public Property Get hDC() As LongPtr
       If p_HDC = 0 Then
           If p_hWnd = 0 Then
               If hWnd <> 0 Then
                   p_HDC = mDialogFunctions.GetDC(p_hWnd)
               End If
           Else
               p_HDC = mDialogFunctions.GetDC(p_hWnd)
           End If
       End If
       hDC = p_HDC
   End Property
#Else
   ' 32-bit 2007/2003
   Public Property Get hDC() As Long
       If p_HDC = 0 Then
           If p_hWnd = 0 Then
               If hWnd <> 0 Then
                   p_HDC = mDialogFunctions.GetDC(p_hWnd)
               End If
           Else
               p_HDC = mDialogFunctions.GetDC(p_hWnd)
           End If
       End If
       hDC = p_HDC
   End Property
#End If

'
' New hWnd property. This property is useful when we need to
' apply new style bits to the UserForm or otherwise subclass it.
' ***************************************************************
' Do NOT set the UserForms Caption property. This will INVALIDATE
' the current hWnd. Use the DialogTitle property instead !!!
' ***************************************************************
#If VBA7 Then
   ' 32/64-bit 2010
   Public Property Get hWnd() As LongPtr
       Dim sTitle As String
       Dim sClass As String
       sTitle = Me.Caption & vbNullChar
       sClass = "ThunderDFrame" & vbNullChar
       If p_hWnd = 0 Then
         If Len(sTitle) > 0 Then
            p_hWnd = mDialogFunctions.FindWindowW(StrPtr(sClass), StrPtr(sTitle))
         End If
       End If
       hWnd = p_hWnd
   End Property
#Else
   ' 32-bit 2007/2003
   Public Property Get hWnd() As Long
       Dim sTitle As String
       Dim sClass As String
       sTitle = Me.Caption & vbNullChar
       sClass = "ThunderDFrame" & vbNullChar
       If p_hWnd = 0 Then
         If Len(sTitle) > 0 Then
            p_hWnd = mDialogFunctions.FindWindowW(StrPtr(sClass), StrPtr(sTitle))
         End If
       End If
       hWnd = p_hWnd
   End Property
#End If

'
' New BorderWidth property. This property is useful when we need to
' resize a UserForm consistently on XP and newer platforms.
Public Property Get BorderWidth() As Single

   Dim tWindow As RECT
   Dim tClient As RECT
   Dim lRet As Long
   
   If p_snBorderWidth = 0 Then
      '
      ' Get coordinates for the outer bounds of the UserForm
      lRet = mDialogFunctions.GetWindowRect(hWnd, tWindow)
      '
      ' Get coordinates for the inner bounds of the UserForm
      lRet = mDialogFunctions.GetClientRect(hWnd, tClient)
      '
      ' Calculate the width difference (ie the total for both Left and Right border)
      p_snBorderWidth = (tWindow.Right - tWindow.Left) - (tClient.Right - tClient.Left)
      '
      ' Got a reasonble result?
      If p_snBorderWidth = 0 Then
         '
         ' If not we assume reasonable values
'         If Not mVersion.IsWinVistaOrNewer Then
            '
            ' Typical for Windows XP
'            p_snBorderWidth = 8
'         Else
            '
            ' Typical for Windows Areo on Vista/Win7
            p_snBorderWidth = 16
'         End If
      End If
      
'      If Not mVersion.IsWinVistaOrNewer Then
'         p_snBorderWidth = PointsToPixels(p_snBorderWidth) ' NOT completely true, but works for now.
'      Else
         p_snBorderWidth = p_snBorderWidth
'      End If
   End If

   BorderWidth = p_snBorderWidth

End Property

'
' Property to control whether full unload is required or not.
' If True the form contents is cached for the next reload,
' and a time consuming, complete rebuild can be skipped.
Public Property Let KeepLoaded(ByVal bKeepLoaded As Boolean)
   p_bKeepLoaded = bKeepLoaded
End Property
Public Property Get KeepLoaded() As Boolean
   KeepLoaded = p_bKeepLoaded
End Property

'
' Property to control whether full unload is required or not.
' If vbModeless the form is shown until the next call to MsgBox.
Public Property Let ShowMode(ByVal eShowMode As FormShowConstants)
   p_eShowMode = eShowMode
End Property
Public Property Get ShowMode() As FormShowConstants
   ShowMode = p_eShowMode
End Property

'
' Sets the UserForm Caption, resets the hWnd, restores
' special non-standard border properties, scaling etc.
'Public Property Let DialogTitle(ByVal sDialogTitle As String)
'   p_sDialogTitle = sDialogTitle
'   If Len(p_sDialogTitle) > 0 Then
'      Me.Caption = p_sDialogTitle
'      p_hWnd = 0
'      pSetFormProperties
'   End If
'   pResize
'End Property
Public Property Get DialogTitle() As String
   DialogTitle = p_sDialogTitle
End Property

Public Property Let MessageID(ByVal sNewID As String)
   p_sMessageID = sNewID
End Property
Public Property Get MessageID() As String
   MessageID = p_sMessageID
End Property

Public Property Get OptionValue() As Boolean
   OptionValue = chkOption.Value
End Property

Public Property Get DontShowAgain() As Boolean
   DontShowAgain = chkDontShowAgain.Value
End Property

Private Sub cmdAction01_Click()
   '
   ' Leftmost button, ie. only in use when 3 buttons are displayed
   Select Case p_eMsgBoxButtons
      
      Case embbAbortRetryIgnore
         p_eMsgBoxResult = vbAbort
         
      Case embbYesNoCancel
         p_eMsgBoxResult = vbYes
      
      Case Else
         ' Should NEVER happen. Invalid button click.
         
   End Select

   Unload Me 'Me.Hide

End Sub

Private Sub cmdAction02_Click()
   '
   ' Middle button, ie. in use when 2 or 3 buttons are displayed
   Select Case p_eMsgBoxButtons
      
      Case embbOKOnly
         ' Should NEVER happen. Invalid button click.
      
      Case embbOKCancel
         p_eMsgBoxResult = vbOK
      
      Case embbAbortRetryIgnore
         p_eMsgBoxResult = vbRetry
      
      Case embbYesNoCancel
         p_eMsgBoxResult = vbNo
      
      Case embbYesNo
         p_eMsgBoxResult = vbYes
      
      Case embbRetryCancel
         p_eMsgBoxResult = vbRetry
   
   End Select

   Unload Me 'Me.Hide

End Sub

Private Sub cmdClose_Click()
   '
   ' Rightmost button, ie. always displayed
   Select Case p_eMsgBoxButtons
      
      Case embbOKOnly
         p_eMsgBoxResult = vbOK
      
      Case embbOKCancel
         p_eMsgBoxResult = vbCancel
      
      Case embbAbortRetryIgnore
         p_eMsgBoxResult = vbIgnore
      
      Case embbYesNoCancel
         p_eMsgBoxResult = vbCancel
      
      Case embbYesNo
         p_eMsgBoxResult = vbNo
      
      Case embbRetryCancel
         p_eMsgBoxResult = vbCancel
   
   End Select
   
   Unload Me 'Me.Hide
   
End Sub

Private Sub UserForm_Activate()
   '
   ' Sometimes the NC_PAINT event gets invalidated, in which case our
   ' UserForm object will NOT be redrawn as expected. To avoid that
   ' we refresh here as a precaution.
   On Error Resume Next
   pResize

End Sub

Private Sub UserForm_Initialize()
   '
   ' Apply the properties we wish
   pSetFormProperties
   '
   ' Cache the form or not?
   p_bKeepLoaded = False
   p_eShowMode = vbModal
   '
   ' Initialize the form's content (fill controls etc.)
   lblMessageTitle.Caption = ""
   '
   ' Make sure the form paints properly
   pResize

End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
   '
   ' Unfortunately it's not easy to create an EventSink class via pure VBA,
   ' which actually inherits the QueryClose event. Therefore, we should assure
   ' that this code is available on all UserForm objects.
   Dim i As VbQueryClose
   i = CloseMode
   
   Select Case i
      ' 0, 1
      Case vbFormControlMenu, vbFormCode
         If Me.Visible Then
            If p_eShowMode = vbModal Then Me.Hide
            Cancel = p_bKeepLoaded
         End If
         
      ' 2, 3 (vbAppWindows, vbAppTaskManager)
      Case Else
   
   End Select
         
   pSaveUserSettings
   mDialogFunctions.SaveFormPosition Me, True, True

End Sub

Private Sub UserForm_Resize()
   On Error Resume Next
   pResize
End Sub

Private Sub pSetFormProperties()
#If Not Mac = 1 Then
   
   Dim sLogoIcon As String
   Dim sTemp As String
   
   Dim oCtrl As control
   On Error Resume Next
   Me.BackColor = ColorConstants.vbWhite
   For Each oCtrl In Me.Controls
      oCtrl.BackColor = ColorConstants.vbWhite
   Next
     
   If p_oIcon Is Nothing Then
      Set p_oIcon = New cIconLoaderEx
   End If
   '
   ' Properties that need to be set before our subclassing
   If p_bIsInputBox Then
      Me.Caption = "PasteXL asks for input"
      chkDontShowAgain.Visible = False
   Else
      Me.Caption = "Message from PasteXL"
   End If
   
   Me.MsgBoxIcon = embiNone
  ' chkOption.Caption = mLanguage.GetLanguageStringEx("ufMessageChkOptionDefaultCaption", "Don't show this message again.")
   chkDontShowAgain.Caption = "Don't show this message again."
   '
   ' By default we display Avatar Icons
'   p_bShowAvatarIcons = True
'   sTemp = GetMostSpecificSetting("\General", "ShowAvatarIcons")
'   If LenB(sTemp) <> 0 Then
'      If LCase$(Trim$(sTemp)) = False Then
'         p_bShowAvatarIcons = False
'      End If
'   End If
'
'   If p_bShowAvatarIcons Then
'      '
'      ' Assume failure
'      imgCustomerIcon.Visible = False
'      '
'      ' Apply the Icon
'      sTemp = GetMostSpecificSetting("\General", "CustomerIcon")
'      If LenB(sTemp) <> 0 Then
'         sLogoIcon = mSettings.FillVariables(sTemp)
'         If Not FileExists(sLogoIcon) Then
'            sLogoIcon = CombinePaths(GetEngineFolder(ewefSDSharedIcons), sTemp)
'            sLogoIcon = mSettings.FillVariables(sLogoIcon)
'         End If
'         If Not FileExists(sLogoIcon) Then
'            sTemp = mCore_FileOperationsW.GetFileName(sTemp)
'            sLogoIcon = CombinePaths(GetEngineFolder(ewefSDSharedIcons), sTemp)
'         End If
'
'         If FileExists(sLogoIcon) Then
'            '
'            ' Since AutoSize is On  and the image is right-aligned we must remember
'            ' to adjust position in pResize()
'            imgCustomerIcon.AutoSize = True
'            imgCustomerIcon.Visible = True
'            imgCustomerIcon.PictureAlignment = fmPictureAlignmentTopRight
'
'            If LCase$(GetFileExtension(sLogoIcon)) = ".ico" Then
'               '
'               ' When the file is in ICO format this MUST be provided as a max 128x128 pixels
'               ' 32-bit ICO-file with ONLY one icon entry.
'               If p_oIcon.LoadIconFile(sLogoIcon) Then
'                  imgCustomerIcon.Picture = p_oIcon.GetIconByIndex(0, imgCustomerIcon.BackColor)
'               End If
'            Else
'               '
'               ' When the file is in another format (PNG with Alpha channel preferred) size
'               ' is NOT limited to 128 pixels.
'               imgCustomerIcon.Picture = p_oIcon.LoadIconFromFile(sLogoIcon)
'            End If
'         Else
'            DebugMsg MODULE_NAME & "::pSetFormProperties: Requested icon file """ & sLogoIcon & """ not found.", dbgLogWarning
'         End If
'      End If
'   End If ' p_bShowAvatarIcons
   '
   ' Here we "standardize" how a UserForm object should look.
   If Me.hWnd <> 0 Then
      mDialogFunctions.SetFormBorders Me.hWnd, True, True
   End If
   '
   ' Set size and position as of last time or apply defaults.
   If Len(Me.Caption) > 0 Then
      mDialogFunctions.LoadFormPosition Me, 100, 110, 270, 200
   End If
   '
   ' Apply colours, font etc.
   mDialogFunctions.SetFormLayout Me
   '
   ' Load "saved" user choices
   pLoadUserSettings
   '
   ' Size all controls properly (the pResize() function may be almost empty)
   pResize
   '
   ' Assure that the dialog is displayed on the Display Monitor where
   ' the mouse cursor is.
'   Call ShowDialogOnWhichMonitor(Me.hWnd, GetMonitorFromMouse)
   '
   ' And assure that the dialog is displayed in full and not overlapped
   ' between monitors.
'   Call IsDialogOffScreen(Me.hWnd, False, True)
#End If
End Sub

Private Sub pResize()
   
   On Error Resume Next
   
   Dim lHeaderLeft As Single
   Dim lHeaderWidth As Single
   Dim lHeaderTop As Single
   
   lHeaderLeft = 6
   lHeaderWidth = Me.Width - 24
   lHeaderTop = 56
   '
   ' If run in InputBox mode MaxHeight is set
   If p_snMaxHeight <> 0 Then
      Me.Height = p_snMaxHeight
   End If
   
   With lblMessageTitle
      ' Leave room for an icon and auto size the height
      .AutoSize = True
      .Width = lHeaderWidth - 56
      .AutoSize = False
      ' Calculate .top when Height is fixed by auto size
      .Top = lHeaderTop - lblMessageTitle.Height - 14
   End With
   
   With lblBackground
      .Top = -2
      .Left = -2
      .Width = Me.Width + 4
      .Height = 50
   End With
   
   With imgCustomerIcon
      .Top = 6
      .Left = Me.Width - .Width - 18
   End With
                                                               
   With imgIcon
      .AutoSize = True
      .Top = lHeaderTop
      .Left = lHeaderLeft
   End With
                                       
   With txtMessage
      .Top = lHeaderTop
      If imgIcon.Visible Then
         .Left = imgIcon.Left + imgIcon.Width + lHeaderLeft
         .Width = lHeaderWidth - (.Left - lHeaderLeft)
      Else
         .Left = lHeaderLeft
         .Width = lHeaderWidth
      End If
      If chkOption.Visible Then
         .Height = Me.Height - .Top - cmdClose.Height - (38 + chkOption.Height)
      Else
         .Height = Me.Height - .Top - cmdClose.Height - (38)
      End If
      
      If chkDontShowAgain.Visible Then
         .Height = .Height - chkDontShowAgain.Height
      End If
      
   End With
   If imgIcon.Visible Then
      imgIcon.Top = txtMessage.Top
   End If
                    
   With chkOption
      .Top = txtMessage.Top + txtMessage.Height + 4
      .Left = txtMessage.Left
      .Width = txtMessage.Width
   End With
   
   With chkDontShowAgain
      If chkOption.Visible Then
         .Top = chkOption.Top + chkOption.Height
      Else
         .Top = txtMessage.Top + txtMessage.Height + 4
      End If
      .Left = txtMessage.Left
      .Width = txtMessage.Width
   End With
   
   '
   ' Buttons
   With cmdAction01
      If chkOption.Visible Then
         .Top = chkOption.Top + chkOption.Height + 3
      Else
         .Top = txtMessage.Top + txtMessage.Height + 6
      End If
      
      If chkDontShowAgain.Visible Then
         .Top = .Top + chkDontShowAgain.Height ' chkDontShowAgain.Top + chkDontShowAgain.Height + 3
     ' Else
     '    .Top = txtMessage.Top + txtMessage.Height + 6
      End If
      
      .Left = lHeaderLeft
      .Width = (lHeaderWidth / 3) - 3
   End With
   
   With cmdAction02
      .Top = cmdAction01.Top
      .Left = cmdAction01.Left + cmdAction01.Width + 4
      .Width = cmdAction01.Width
   End With
   
   With cmdClose
      .Top = cmdAction01.Top
      .Left = cmdAction02.Left + cmdAction02.Width + 4
      .Width = cmdAction02.Width
   End With
                                      
   If Me.Visible Then Me.Repaint
         
End Sub

Private Sub pSaveUserSettings()

   If LenB(Me.Caption) <> 0 Then
      ' Code here
   End If
   
End Sub

Private Sub pLoadUserSettings()

   If LenB(Me.Caption) <> 0 Then
      ' Code here
   End If
   
End Sub

Property Get MsgBoxResult() As VbMsgBoxResult
   MsgBoxResult = p_eMsgBoxResult
End Property

Property Let MsgBoxButtons(ByVal eStyle As enMessageBoxButtons)
   p_eMsgBoxButtons = eStyle
   
   Select Case p_eMsgBoxButtons
      
      Case embbOKOnly
         cmdClose.Caption = "OK"
         cmdAction01.Visible = False
         cmdAction02.Visible = False
         cmdClose.Default = True
      
      Case embbOKCancel
         cmdAction02.Caption = "OK"
         cmdClose.Caption = "Cancel"
         cmdAction01.Visible = False
         cmdAction02.Visible = True
         cmdAction02.Default = True
         cmdClose.Cancel = True
      
      Case embbAbortRetryIgnore
         cmdAction01.Caption = "Abort"
         cmdAction02.Caption = "Retry"
         cmdClose.Caption = "Ignore"
         cmdAction01.Visible = True
         cmdAction02.Visible = True
      
      Case embbYesNoCancel
         cmdAction01.Caption = "Yes"
         cmdAction02.Caption = "No"
         cmdClose.Caption = "Cancel"
         cmdAction01.Visible = True
         cmdAction02.Visible = True
         cmdAction01.Default = True
         cmdClose.Cancel = True
      
      Case embbYesNo
         cmdAction02.Caption = "Yes"
         cmdClose.Caption = "No"
         cmdAction01.Visible = False
         cmdAction02.Visible = True
         cmdAction02.Default = True
         cmdClose.Cancel = True
      
      Case embbRetryCancel
         cmdAction02.Caption = "Retry"
         cmdClose.Caption = "Cancel"
         cmdAction01.Visible = False
         cmdAction02.Visible = True
         cmdAction02.Default = True
         cmdClose.Cancel = True
   
   End Select
   
End Property
Property Get MsgBoxButtons() As enMessageBoxButtons
   MsgBoxButtons = p_eMsgBoxButtons
End Property

Property Let MsgBoxIcon(ByVal eIcon As enMessageBoxIcons)
   
   Dim sIconFileName As String
   p_eMsgBoxIcon = eIcon
   '
   ' Re-initialize the IconLoader Object if required
   If p_oIcon Is Nothing Then
      Set p_oIcon = New cIconLoaderEx
   End If
   '
   ' Choose which file to load
   Select Case p_eMsgBoxIcon
      
      Case embiCritical
         sIconFileName = "C:\ProgramData\SkabelonDesign\Shared\Icons\" & "Critical.ico"
      
      Case embiExclamation
         sIconFileName = "C:\ProgramData\SkabelonDesign\Shared\Icons\" & "Exclamation.ico"
      
      Case embiInformation
         sIconFileName = "C:\ProgramData\SkabelonDesign\Shared\Icons\" & "Information.ico"
      
      Case embiNone
         sIconFileName = ""
         
      Case embiQuestion
         sIconFileName = "C:\ProgramData\SkabelonDesign\Shared\Icons\" & "Question.ico"
   
   End Select
   '
   ' Load the icon and set visibility properly
   If FileExists(sIconFileName) Then
      If p_oIcon.LoadIconFile(sIconFileName) Then
         '
         ' TODO: Here we should find the icon-index for an icon that match the display
         ' colour depth. Currently we choose the 48x48 pixels 32-bit icon.
         imgIcon.Picture = p_oIcon.GetIconByIndex(4, imgIcon.BackColor)
         imgIcon.Visible = True
      End If
   Else
      If LenB(sIconFileName) <> 0 Then
         DebugMsg MODULE_NAME & "::MsgBoxIcon (Let): Requested icon file """ & sIconFileName & """ not found.", dbgLogError
      End If
      imgIcon.Visible = False
   End If
   
   pResize
   
End Property
Property Get MsgBoxIcon() As enMessageBoxIcons
   MsgBoxIcon = p_eMsgBoxIcon
End Property

Property Let MsgBoxTitle(ByRef sTitle As String)
   lblMessageTitle.Caption = sTitle
End Property
Property Get MsgBoxTitle() As String
   MsgBoxTitle = lblMessageTitle.Caption
End Property

Property Let MsgBoxText(ByRef sText As String)
   txtMessage.Text = sText
End Property
Property Get MsgBoxText() As String
   MsgBoxText = txtMessage.Text
End Property

Property Let IsInputBox(ByVal bInputBox As Boolean)
   p_bIsInputBox = bInputBox

   txtMessage.locked = Not p_bIsInputBox
   If p_bIsInputBox Then
      txtMessage.MultiLine = False
     ' txtMessage.Height = 15
      txtMessage.BackColor = SystemColorConstants.vbWindowBackground
      txtMessage.BackStyle = MSForms.fmBackStyle.fmBackStyleOpaque
      cmdAction02.Caption = "Save"
      
      txtMessage.SelStart = 0
      txtMessage.SelLength = Len(txtMessage.Text)
      
      p_snMaxHeight = 130
   Else
      p_snMaxHeight = 0
   End If
   
   pSetFormProperties

End Property
Property Get IsInputBox() As Boolean
   IsInputBox = p_bIsInputBox
End Property

Public Sub SetStylesFromMsgBox(ByVal eStyle As VbMsgBoxStyle)
   '
   ' Find out which buttons we must activate
   If (eStyle And vbOKOnly) = vbOKOnly Then p_eMsgBoxButtons = embbOKOnly
   If (eStyle And vbOKCancel) = vbOKCancel Then p_eMsgBoxButtons = embbOKCancel
   If (eStyle And vbAbortRetryIgnore) = vbAbortRetryIgnore Then p_eMsgBoxButtons = embbAbortRetryIgnore
   If (eStyle And vbYesNoCancel) = vbYesNoCancel Then p_eMsgBoxButtons = embbYesNoCancel
   If (eStyle And vbYesNo) = vbYesNo Then p_eMsgBoxButtons = embbYesNo
   If (eStyle And vbRetryCancel) = vbRetryCancel Then p_eMsgBoxButtons = embbRetryCancel
   '
   ' Apply the button(s)
   MsgBoxButtons = p_eMsgBoxButtons
   '
   ' Find out which icon to display
   p_eMsgBoxIcon = embiNone
   If (eStyle And vbCritical) = vbCritical Then p_eMsgBoxIcon = embiCritical
   If (eStyle And vbQuestion) = vbQuestion Then p_eMsgBoxIcon = embiQuestion
   If (eStyle And vbExclamation) = vbExclamation Then p_eMsgBoxIcon = embiExclamation
   If (eStyle And vbInformation) = vbInformation Then p_eMsgBoxIcon = embiInformation
   '
   ' Apply the icon
   MsgBoxIcon = p_eMsgBoxIcon
   '
   ' TODO: Default Button, Modality etc. as need be.
   '
   ' Default button (the one that is active when the user hits Enter)
   

End Sub

Private Sub UserForm_Terminate()

   Set p_oIcon = Nothing

End Sub

' InQuest injected base64 decoded content
' ~`ZrD
' {-j{l
' *^r&
' *'~*
' x%yh
' jA/zs
' Szjej
' )^"p
' ZrK%j
' {-j{
' 'vz-x*'
' 'vz-x*'
' 'vz-y'
' Z,yj+
' +-jw
' Szjej
' )>'-
' zu)u
' ZrH+
' x(d:

INQUEST-PP=macro
